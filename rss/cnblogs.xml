<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>程序员过关斩将--自定义线程池来实现文档转码 - 架构师修行之路</title>
<link>http://www.cnblogs.com/zhanlang/p/12178914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanlang/p/12178914.html</guid>
<description>&lt;h3&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我司在很久之前，一位很久之前的同事写过一个文档转图片的服务，具体业务如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;用户在客户端上传文档，可以是ppt，word，pdf 等格式，用户上传完成可以在客户端预览上传的文档，预览的时候采用的是图片形式（不要和我说用别的方式预览，现在已经来不及了）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当用户把文档上传到云端之后（阿里云），把文档相关的信息记录在数据库，然后等待转码完成&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;服务器有一个转码服务（其实就是一个windows service）不停的在轮训待转码的数据，如果有待转码的数据，则从数据库取出来，然后根据文档的网络地址下载到本地进行转码（转成多张图片）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当文档转码完毕，把转码出来的图片上传到云端，并把云端图片的信息记录到数据库&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;客户端有预览需求的时候，根据数据库来判断有没有转码成功，如果成功，则获取数据来显示。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;文档预览的整体过程如以上所说，老的转码服务现在什么问题呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;由于一个文档同时只能被一个线程进行转码操作，所以老的服务采用了把待转码数据划分管道的思想，一共有六个管道，映射到数据库大体就是 Id=》管道ID 这个样子。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个控制台程序，根据配置文件信息，读取某一个管道待转码的文档，然后单线程进行转码操作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一共有六个管道，所以服务器上起了六个cmd的黑窗口……&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;有的时候个别文档由于格式问题或者其他问题 转码过程中会卡住，具体的表现为：停止了转码操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果程序卡住了，需要运维人员重新启动转码cmd窗口（这种维护比较蛋疼）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;后来机缘巧合，这个程序的维护落到的菜菜头上，维护了一周左右，大约重启了10多次，终于忍受不了了，重新搞一个吧。仔细分析过后，刨除实际文档转码的核心操作之外，整个转码流程其实还有很多注意点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;需要保证转码服务不被卡住，如果和以前一样就没有必要重新设计了&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;尽量避免开多个进程的方式，其实在这个业务场景下，多个进程和多个线程作用是一致的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个文档只能被转码一次，如果一个文档被转码多次，不仅浪费了服务器资源，而且还有可能会有数据不一致的情况发生&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;转码失败的文档需要有一定次数的重试，因为一次失败不代表第二次失败，所以一定要给失败的文档再次被操作的机会&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;因为程序不停的把文档转码成本地图片，所以需要保证这些文件在转码完成在服务器上删除，不然的话，时间长了会生成很多无用的文件&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;说了这么多，其实需要注意的点还是很多的。以整个的转码流程来说，本质上是一个任务池的生产和消费问题，任务池中的任务就是待转码的文档，生产者不停的把待转码文档丢进任务池，消费者不停的把任务池中文档转码完成。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;线程池&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这很显然和线程池很类似，菜菜之前就写过一个线程池的文章，有兴趣的同学可以去翻翻历史。今天我们就以这个线程池来解决这个转码问题。线程池的本质是初始化一定数目的线程，不停的执行任务。&lt;/p&gt;
&lt;pre readability=&quot;30.5&quot;&gt;
&lt;code readability=&quot;55&quot;&gt; &lt;span&gt;//线程池定义 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;LXThreadPool&lt;/span&gt;:&lt;span&gt;IDisposable&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;bool&lt;/span&gt; PoolEnable = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//线程池是否可用 &lt;/span&gt;&lt;br/&gt;List&amp;lt;Thread&amp;gt; ThreadContainer = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//线程的容器&lt;/span&gt;&lt;br/&gt;ConcurrentQueue&amp;lt;ActionData&amp;gt; JobContainer = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//任务的容器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; _maxJobNumber; &lt;span&gt;//线程池最大job容量&lt;/span&gt;&lt;p&gt;ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, DateTime&amp;gt; JobIdList = &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, DateTime&amp;gt;(); &lt;span&gt;//job的副本，用于排除某个job 是否在运行中&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LXThreadPool&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; threadNumber,&lt;span&gt;int&lt;/span&gt; maxJobNumber=&lt;span&gt;1000&lt;/span&gt;&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(threadNumber&amp;lt;=&lt;span&gt;0&lt;/span&gt; || maxJobNumber &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;线程池初始化失败&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;_maxJobNumber = maxJobNumber;&lt;br/&gt;ThreadContainer = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Thread&amp;gt;(threadNumber);&lt;br/&gt;JobContainer = &lt;span&gt;new&lt;/span&gt; ConcurrentQueue&amp;lt;ActionData&amp;gt;();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; threadNumber; i++)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; t = &lt;span&gt;new&lt;/span&gt; Thread(RunJob);&lt;br/&gt;t.Name = &lt;span&gt;$&quot;转码线程&lt;span&gt;{i}&lt;/span&gt;&quot;&lt;/span&gt;;&lt;br/&gt;ThreadContainer.Add(t);&lt;br/&gt;t.Start();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//清除超时任务的线程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; tTimeOutJob = &lt;span&gt;new&lt;/span&gt; Thread(CheckTimeOutJob);&lt;br/&gt;tTimeOutJob.Name = &lt;span&gt;$&quot;清理超时任务线程&quot;&lt;/span&gt;;&lt;br/&gt;tTimeOutJob.Start();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;//往线程池添加一个线程,返回线程池的新线程数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;AddThread&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; number=&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(!PoolEnable || ThreadContainer==&lt;span&gt;null&lt;/span&gt; || !ThreadContainer.Any() || JobContainer==&lt;span&gt;null&lt;/span&gt;|| !JobContainer.Any())&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (number &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; t = &lt;span&gt;new&lt;/span&gt; Thread(RunJob);&lt;br/&gt;ThreadContainer.Add(t);&lt;br/&gt;t.Start();&lt;br/&gt;number -= number;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; ThreadContainer?.Count ?? &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;//向线程池添加一个任务,返回0：添加任务失败   1：成功&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;AddTask&lt;/span&gt;(&lt;span&gt;Action&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; job, &lt;span&gt;object&lt;/span&gt; obj,&lt;span&gt;string&lt;/span&gt; actionId, Action&amp;lt;Exception&amp;gt; errorCallBack = &lt;span&gt;null&lt;/span&gt;&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (JobContainer != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(JobContainer.Count&amp;gt;= _maxJobNumber)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//首先排除10分钟还没转完的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; timeoOutJobList = JobIdList.Where(s =&amp;gt; s.Value.AddMinutes(&lt;span&gt;10&lt;/span&gt;) &amp;lt; DateTime.Now);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(timeoOutJobList!=&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp; timeoOutJobList.Any())&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; timeoutJob &lt;span&gt;in&lt;/span&gt; timeoOutJobList)&lt;br/&gt;{&lt;br/&gt;JobIdList.TryRemove(timeoutJob.Key,&lt;span&gt;out&lt;/span&gt; DateTime v);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;if&lt;/span&gt; (!JobIdList.Any(s =&amp;gt; s.Key == actionId))&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(JobIdList.TryAdd(actionId, DateTime.Now))&lt;br/&gt;{&lt;br/&gt;JobContainer.Enqueue(&lt;span&gt;new&lt;/span&gt; ActionData { Job = job, Data = obj, ActionId = actionId, ErrorCallBack = errorCallBack });&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;101&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;}            &lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}  &lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;RunJob&lt;/span&gt;()&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (JobContainer != &lt;span&gt;null&lt;/span&gt;  &amp;amp;&amp;amp; PoolEnable)&lt;br/&gt;{&lt;/p&gt;&lt;p&gt;&lt;span&gt;//任务列表取任务&lt;/span&gt;&lt;br/&gt;ActionData job = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;JobContainer?.TryDequeue(&lt;span&gt;out&lt;/span&gt; job);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (job == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;//如果没有任务则休眠&lt;/span&gt;&lt;br/&gt;Thread.Sleep(&lt;span&gt;20&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;try&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;//执行任务&lt;/span&gt;&lt;br/&gt;job.Job.Invoke(job.Data);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;catch&lt;/span&gt; (Exception error)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;//异常回调&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (job != &lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp; job.ErrorCallBack!=&lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;job?.ErrorCallBack(error);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;span&gt;finally&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (!JobIdList.TryRemove(job.ActionId,&lt;span&gt;out&lt;/span&gt; DateTime v))&lt;br/&gt;{&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;//终止线程池&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Dispose&lt;/span&gt;()&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;PoolEnable = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;JobContainer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (ThreadContainer != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt; ThreadContainer)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;//强制线程退出并不好，会有异常&lt;/span&gt;&lt;br/&gt;t.Join();&lt;br/&gt;}&lt;br/&gt;ThreadContainer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;//清理超时的任务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;CheckTimeOutJob&lt;/span&gt;()&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//首先排除10分钟还没转完的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; timeoOutJobList = JobIdList.Where(s =&amp;gt; s.Value.AddMinutes(&lt;span&gt;10&lt;/span&gt;) &amp;lt; DateTime.Now);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (timeoOutJobList != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; timeoOutJobList.Any())&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; timeoutJob &lt;span&gt;in&lt;/span&gt; timeoOutJobList)&lt;br/&gt;{&lt;br/&gt;JobIdList.TryRemove(timeoutJob.Key, &lt;span&gt;out&lt;/span&gt; DateTime v);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;System.Threading.Thread.Sleep(&lt;span&gt;60000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ActionData&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;//任务的id，用于排重&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ActionId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;span&gt;//执行任务的参数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Data { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;span&gt;//执行的任务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; Action&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; Job { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;span&gt;//发生异常时候的回调方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; Action&amp;lt;Exception&amp;gt; ErrorCallBack { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是一个线程池的具体实现，和具体的业务无关，完全可以用于任何适用于线程池的场景，其中有一个注意点，我新加了任务的标示，主要用于排除重复的任务被投放多次（只排除正在运行中的任务）。当然代码不是最优的，有需要的同学可以自己去优化&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;使用线程池&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;接下来，我们利用以上的线程池来完成我们的文档转码任务，首先我们启动的时候初始化一个线程池,并启动一个独立线程来不停的往线程池来输送任务，顺便起了一个监控线程去监视发送任务的线程&lt;/p&gt;
&lt;pre readability=&quot;20.5&quot;&gt;
&lt;code readability=&quot;35&quot;&gt;       &lt;span&gt;string&lt;/span&gt; lastResId = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;string&lt;/span&gt; lastErrorResId = &lt;span&gt;null&lt;/span&gt;;&lt;p&gt;Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt; ResErrNumber = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;(); &lt;span&gt;//转码失败的资源重试次数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; MaxErrNumber = &lt;span&gt;5&lt;/span&gt;;&lt;span&gt;//最多转码错误的资源10次&lt;/span&gt;&lt;br/&gt;Thread tPutJoj = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;LXThreadPool pool = &lt;span&gt;new&lt;/span&gt; LXThreadPool(&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;OnStart&lt;/span&gt;()&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;//初始化一个线程发送转码任务&lt;/span&gt;&lt;br/&gt;tPutJoj = &lt;span&gt;new&lt;/span&gt; Thread(PutJob);&lt;br/&gt;tPutJoj.IsBackground = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;tPutJoj.Start();&lt;/p&gt;&lt;p&gt;&lt;span&gt;//初始化 监控线程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; tMonitor = &lt;span&gt;new&lt;/span&gt; Thread(MonitorPutJob);&lt;br/&gt;tMonitor.IsBackground = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;tMonitor.Start();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//监视发放job的线程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;MonitorPutJob&lt;/span&gt;()&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(tPutJoj == &lt;span&gt;null&lt;/span&gt;|| !tPutJoj.IsAlive)&lt;br/&gt;{&lt;br/&gt;Log.Error(&lt;span&gt;$&quot;发送转码任务线程停止==========&quot;&lt;/span&gt;);&lt;br/&gt;tPutJoj = &lt;span&gt;new&lt;/span&gt; Thread(PutJob);&lt;br/&gt;tPutJoj.Start();&lt;br/&gt;Log.Error(&lt;span&gt;$&quot;发送转码任务线程重新初始化并启动==========&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;System.Threading.Thread.Sleep(&lt;span&gt;5000&lt;/span&gt;);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;PutJob&lt;/span&gt;()&lt;br/&gt;&lt;/span&gt;{           &lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;try&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;//先搜索等待转码的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; fileList = DocResourceRegisterProxy.GetFileList(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] { (&lt;span&gt;int&lt;/span&gt;)FileToImgStateEnum.Wait }, &lt;span&gt;30&lt;/span&gt;, lastResId);&lt;br/&gt;Log.Error(&lt;span&gt;$&quot;拉取待转码记录===总数：lastResId:&lt;span&gt;{lastResId}&lt;/span&gt;,结果：&lt;span&gt;{fileList?.Count() ?? &lt;span&gt;0&lt;/span&gt;}&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (fileList == &lt;span&gt;null&lt;/span&gt; || !fileList.Any())&lt;br/&gt;{&lt;br/&gt;lastResId = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;Log.Error(&lt;span&gt;$&quot;待转码数量为0，开始拉取转码失败记录，重新转码==========&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//如果无待转，则把出错的 尝试&lt;/span&gt;&lt;br/&gt;fileList = DocResourceRegisterProxy.GetFileList(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] { (&lt;span&gt;int&lt;/span&gt;)FileToImgStateEnum.Error, (&lt;span&gt;int&lt;/span&gt;)FileToImgStateEnum.TimeOut, (&lt;span&gt;int&lt;/span&gt;)FileToImgStateEnum.Fail }, &lt;span&gt;1&lt;/span&gt;, lastErrorResId);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (fileList == &lt;span&gt;null&lt;/span&gt; || !fileList.Any())&lt;br/&gt;{&lt;br/&gt;lastErrorResId = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;// Log.Error($&quot;开始转码失败记录：{JsonConvert.SerializeObject(fileList)}&quot;);&lt;/span&gt;&lt;br/&gt;List&amp;lt;DocResourceRegister&amp;gt; errFilter = &lt;span&gt;new&lt;/span&gt; List&amp;lt;DocResourceRegister&amp;gt;();&lt;br/&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; errRes &lt;span&gt;in&lt;/span&gt; fileList)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (ResErrNumber.TryGetValue(errRes.res_id, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; number))&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (number &amp;gt; MaxErrNumber)&lt;br/&gt;{&lt;br/&gt;Log.Error(&lt;span&gt;$&quot;资源:&lt;span&gt;{errRes.res_id}&lt;/span&gt; 转了&lt;span&gt;{MaxErrNumber}&lt;/span&gt;次不成功，放弃===========&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;errFilter.Add(errRes);&lt;br/&gt;ResErrNumber[errRes.res_id] = number + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;ResErrNumber.Add(errRes.res_id, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;errFilter.Add(errRes);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;fileList = errFilter;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (fileList.Any())&lt;br/&gt;{&lt;br/&gt;lastErrorResId = fileList.Select(s =&amp;gt; s.res_id).Max();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;lastResId = fileList.Select(s =&amp;gt; s.res_id).Max();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;if&lt;/span&gt; (fileList != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; fileList.Any())&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt; fileList)&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;//如果 任务投放线程池失败，则等待一面继续投放&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; poolRet = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (poolRet &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;poolRet = pool.AddTask(s =&amp;gt; {&lt;br/&gt;AliFileService.ConvertToImg(file.res_id + &lt;span&gt;$&quot;.&lt;span&gt;{file.res_ext}&lt;/span&gt;&quot;&lt;/span&gt;, FileToImgFac.Instance(file.res_ext));&lt;br/&gt;}, file, file.res_id);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (poolRet &amp;lt;= &lt;span&gt;0&lt;/span&gt; || poolRet &amp;gt; &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;Log.Error(&lt;span&gt;$&quot;发放转码任务失败==========线程池返回结果：&lt;span&gt;{poolRet}&lt;/span&gt;&quot;&lt;/span&gt;);&lt;br/&gt;System.Threading.Thread.Sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//每一秒去数据库取一次数据&lt;/span&gt;&lt;br/&gt;System.Threading.Thread.Sleep(&lt;span&gt;3000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;catch&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是发放任务，线程池执行任务的所有代码，由于具体的转码代码涉及到隐私，这里不在提供，如果有需要可以私下找菜菜索要，虽然我深知还有更优的方式，但是我觉得线程池这样的思想可能会对部分人有帮助，其中任务超时的核心代码如下(采用了polly插件)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &lt;span&gt;var&lt;/span&gt; policy= Policy.Timeout(TimeSpan.FromSeconds(&lt;span&gt;this&lt;/span&gt;.TimeOut), &lt;span&gt;onTimeout&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;context, timespan, task&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;ret.State=Enum.FileToImgStateEnum.TimeOut;                   &lt;br/&gt;});&lt;br/&gt;policy.Execute(&lt;span&gt;&lt;span&gt;s&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;.....&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;把你的更优方案写在留言区吧，2020年大家越来越好&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 11 Jan 2020 00:49:00 +0000</pubDate>
<dc:creator>架构师修行之路</dc:creator>
<og:description>背景 我司在很久之前，一位很久之前的同事写过一个文档转图片的服务，具体业务如下： 文档预览的整体过程如以上所说，老的转码服务现在什么问题呢？ 后来机缘巧合，这个程序的维护落到的菜菜头上，维护了一周左右</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanlang/p/12178914.html</dc:identifier>
</item>
<item>
<title>海思dv300cv500交叉编译webrtc - 云中双月</title>
<link>http://www.cnblogs.com/Johness/p/webrtc-compile-on-hisidv300cv500.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Johness/p/webrtc-compile-on-hisidv300cv500.html</guid>
<description>&lt;p&gt;　　感谢声网提供的&lt;a title=&quot;WebRTC 国内镜像&quot; href=&quot;https://webrtc.org.cn/mirror/&quot; target=&quot;_blank&quot;&gt;webrtc国内源码镜像&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　首先要安装好海思编译工具链和git。&lt;/p&gt;
&lt;p&gt;　　&lt;img title=&quot;安装好海思编译链和git&quot; src=&quot;https://img2018.cnblogs.com/blog/372875/202001/372875-20200110234540318-1804826047.png&quot; alt=&quot;安装好海思编译链和git&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　先替换一下webrtc代码的仓库网址路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; git config --global user.email &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100582783@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; git config --global user.name &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;linxing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/webrtc.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/webrtc.git&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/base.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/src/base&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/build.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/src/build&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/buildtools.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/src/buildtools&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/gradle.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/github.com/gradle/gradle.git&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/ios.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/src/ios.git&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/testing.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/src/testing&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/third_party.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/src/third_party&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/clang-format.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/llvm-project/cfe/tools/clang-format.git&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/libcxx.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/llvm-project/libcxx.git&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/libcxxabi.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/llvm-project/libcxxabi.git&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/libunwind.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/llvm.org/libunwind.git&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/android_ndk.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/android_ndk.git&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/android_tools.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/android_tools.git&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/auto.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/github.com/google/auto.git&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/catapult.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/catapult.git&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/compact_enc_det.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/github.com/google/compact_enc_det.git&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/colorama.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/colorama.git&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/depot_tools.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/tools/depot_tools.git&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/errorprone.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/third_party/errorprone.git&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/ffmpeg.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/third_party/ffmpeg.git&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/findbugs.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/deps/findbugs.git&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/freetype2.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/src/third_party/freetype2.git&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/harfbuzz.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/github.com/harfbuzz/harfbuzz.git&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/gtest-parallel.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/github.com/google/gtest-parallel&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/googletest.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/github.com/google/googletest.git&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/icu.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/deps/icu.git&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/jsr-305.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/jsr-305.git&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/jsoncpp.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/github.com/open-source-parsers/jsoncpp.git&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/junit.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/junit.git&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/fuzzer.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/llvm-project/compiler-rt/lib/fuzzer.git&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/libjpeg_turbo.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/deps/libjpeg_turbo.git&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/libsrtp.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/deps/libsrtp.git&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/libvpx.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/webm/libvpx.git&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/libyuv.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/libyuv/libyuv.git&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/linux-syscall-support.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/linux-syscall-support.git&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/mockito.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/mockito/mockito.git&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/nasm.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/deps/nasm.git&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/openh264.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/github.com/cisco/openh264&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/requests.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/github.com/kennethreitz/requests.git&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/robolectric.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/robolectric.git&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/ub-uiautomator.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/third_party/ub-uiautomator.git&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/usrsctp.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/external/github.com/sctplab/usrsctp&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/binaries.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/deps/yasm/binaries.git&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/patched-yasm.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/deps/yasm/patched-yasm.git&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/tools.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/chromium/src/tools&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/client-py.git.insteadOf &lt;/span&gt;&lt;span&gt;https://chromium.googlesource.com/infra/luci/client-py.git&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; git config --global url.http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/boringssl.git.insteadOf &lt;/span&gt;&lt;span&gt;https://boringssl.googlesource.com/boringssl.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　(第一二句改一下哈，写的是我的)&lt;/p&gt;

&lt;p&gt;　　然后选择一个文件夹作为工作目录，我们所有的东西都在这里搞。然后把depot_tools拉下来&lt;/p&gt;
&lt;p&gt;　　&lt;img title=&quot;拉取depot_tools&quot; src=&quot;https://img2018.cnblogs.com/blog/372875/202001/372875-20200110234651286-1718767543.png&quot; alt=&quot;拉取depot_tools&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
export WORKSPACE=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/mnt/d/webrtc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
cd $WORKSPACE
&lt;/span&gt;&lt;span&gt;rm&lt;/span&gt; -rf depot_tools &amp;amp;&amp;amp; git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;chromium.googlesource.com/chromium/tools/depot_tools.git&lt;/span&gt;
&lt;span&gt;
cd $WORKSPACE&lt;/span&gt;/depot_tools &amp;amp;&amp;amp;&lt;span&gt; git checkout gitlab
&lt;/span&gt;&lt;span&gt;chmod&lt;/span&gt; +x $WORKSPACE/depot_tools/&lt;span&gt;cipd
export PATH&lt;/span&gt;=$WORKSPACE/depot_tools:$PATH
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　然后拉取代码&lt;/p&gt;
&lt;p&gt;　　&lt;img title=&quot;拉取代码&quot; src=&quot;https://img2018.cnblogs.com/blog/372875/202001/372875-20200111021405112-1712566575.png&quot; alt=&quot;拉取代码&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rm&lt;/span&gt; -rf $WORKSPACE/code &amp;amp;&amp;amp; &lt;span&gt;mkdir&lt;/span&gt; $WORKSPACE/&lt;span&gt;code
cd $WORKSPACE&lt;/span&gt;/code &amp;amp;&amp;amp; gclient config --name src https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;chromium.googlesource.com/external/webrtc.git@gitlab&lt;/span&gt;
&lt;span&gt;
export CDS_CLANG_BUCKET_OVERRIDE&lt;/span&gt;=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;120.92.49.206:3232/chromiumsrc/commondatastorage/raw/master/public/chromium-browser-clang&lt;/span&gt;
&lt;span&gt;
cd $WORKSPACE&lt;/span&gt;/code &amp;amp;&amp;amp; gclient &lt;span&gt;sync&lt;/span&gt; --&lt;span&gt;patch&lt;/span&gt;-ref=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;chromium.googlesource.com/chromium/src/build.git@gitlab&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  　　(这个过程可能持续2个小时，因为拉取的代码有10个G)&lt;/p&gt;

&lt;p&gt;　　然后生成解决方案（最好先把软件源换到阿里云，一共要通过apt-get下载960多个系统组件，你用ubuntu自带的源搞不定），而且最好切换到root，因为要用sudo，这个过程会持续一整天，如果不su，中途sudo的session过期可能导致你失败&lt;/p&gt;
&lt;p&gt;　　&lt;img title=&quot;生成解决方案1&quot; src=&quot;https://img2018.cnblogs.com/blog/372875/202001/372875-20200111010836936-574255669.png&quot; alt=&quot;生成解决方案1&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
./build/&lt;span&gt;install&lt;/span&gt;-build-deps.&lt;span&gt;sh&lt;/span&gt; --no-chromeos-fonts
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;img title=&quot;生成解决方案2&quot; src=&quot;https://img2018.cnblogs.com/blog/372875/202001/372875-20200111011222378-2021512810.png&quot; alt=&quot;生成解决方案2&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　图中的gn参数为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
gn gen out/Release --args=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;target_os=&quot;linux&quot; enable_iterator_debugging=false enable_profiling=false is_clang=false is_debug=false is_desktop_linux=false is_nacl_glibc=true libyuv_use_neon=true rtc_build_with_neon=true rtc_include_internal_audio_device=false rtc_include_pulse_audio=false rtc_libvpx_build_vp9=false rtc_use_gtk=false strip_absolute_paths_from_debug_symbols=true treat_warnings_as_errors=false use_aura=false use_custom_libcxx=true use_dbus=false target_sysroot=&quot;/opt/hisi-linux/x86-arm/arm-himix200-linux/target&quot; use_gold=true use_goma=false use_lld=false use_ozone=false use_udev=false rtc_build_examples=false rtc_build_tools=false rtc_include_tests=false use_glib=false target_cpu=&quot;arm&quot; rtc_use_x11 = false&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　解决方案生成之后，需要把toolchain.ninja中的arm编译工具改为hisi的交叉编译链，然后直接编译&lt;/p&gt;
&lt;p&gt;　　&lt;img title=&quot;开始编译&quot; src=&quot;https://img2018.cnblogs.com/blog/372875/202001/372875-20200111011726239-233385296.png&quot; alt=&quot;开始编译&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ninja -C out/Release
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　编译完成之后，可以在$WORKSPACE/code/src/out/Release/obj中找到libwebrtc.a&lt;/p&gt;

&lt;p&gt;　　其实整篇文章中，精髓在gn gen的参数，这个参数需要你自己调教出来。首先有几个你必须加入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
target_os=&quot;linux&quot;&lt;span&gt;
target_sysroot&lt;/span&gt;=&quot;/opt/hisi-linux/x86-arm/arm-himix200-linux/target&quot;&lt;span&gt;
target_cpu&lt;/span&gt;=&quot;arm&quot;&lt;span&gt;
rtc_use_x11&lt;/span&gt;=false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果不需要测试工程，下面的几个也可以加入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rtc_build_examples=&lt;span&gt;false
rtc_build_tools&lt;/span&gt;=&lt;span&gt;false
rtc_include_tests&lt;/span&gt;=false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其他的是我从google的论坛扒下来的（做了一些减法），不过我个人认为可能有些是不需要的，你应该先都不加，然后gn gen，如果报错，就去找到导致报错的模块，把它的编译选项关掉。下文我展示一下rtc_use_x11是怎么发掘的，给大家打个样&lt;/p&gt;
&lt;p&gt;　　首先是不知道要加这个开关时，我们可以gn gen成功，但编译会报错，如下图&lt;/p&gt;
&lt;p&gt;　　 &lt;img title=&quot;rtc_use_x11_1&quot; src=&quot;https://img2018.cnblogs.com/blog/372875/202001/372875-20200111014824743-2128336699.png&quot; alt=&quot;rtc_use_x11_1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　怎么排查问题，没别的办法，只有文件夹全局搜索&lt;/p&gt;
&lt;p&gt;　　&lt;img title=&quot;全局搜素&quot; src=&quot;https://img2018.cnblogs.com/blog/372875/202001/372875-20200111015704781-1477250818.png&quot; alt=&quot;全局搜素&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　（注意，具体的调教过程可能没这么简单哈！你得稍微会一点gn）&lt;/p&gt;
&lt;p&gt;　　（当然，linux下递归搜索可能要麻烦一些）&lt;/p&gt;



&lt;p&gt; 　　&lt;img title=&quot;qq群&quot; src=&quot;https://img2018.cnblogs.com/blog/372875/201910/372875-20191030100807030-720874413.jpg&quot; alt=&quot;qq群&quot; width=&quot;540&quot; height=&quot;740&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　最后修改日期：2020-01-11 02:00:44&lt;/p&gt;
</description>
<pubDate>Fri, 10 Jan 2020 18:03:00 +0000</pubDate>
<dc:creator>云中双月</dc:creator>
<og:description>感谢声网提供的webrtc国内源码镜像。 首先要安装好海思编译工具链和git。 先替换一下webrtc代码的仓库网址路径 (第一二句改一下哈，写的是我的) 然后选择一个文件夹作为工作目录，我们所有的东</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Johness/p/webrtc-compile-on-hisidv300cv500.html</dc:identifier>
</item>
<item>
<title>Linux网络管理之多网卡绑定 - qiuhom</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12178412.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12178412.html</guid>
<description>&lt;p&gt;　　一、bonding介绍&lt;/p&gt;
&lt;p&gt;　　在企业Linux服务器管理里中，服务器的可靠性、可用性以及I/O速度都非常重要，保持服务器的高可用和安全性是生产环境的重要指标，其中最重要的一点是服务器网络连接的高可用性。通常我们会把重要的服务器做主备，其目的在于当主服务器宕机，备份服务器马上接管其主服务器的工作，从而实现服务的连续，不至于服务的停用。还有一种情况，我们会给服务器做负载均衡，当一个服务器对外提供服务，接收到用户请求太多，会导致服务器宕机，这个时候我们用主备显得力不从心，怎么办呢，这个时候我们就需要考虑把原来访问一台服务器的流量，分别用很多台服务器来分担，这样一来把原来一台服务器承受的压力分别用很多台服务器来承担。我们知道一张物理网卡的网络吞吐量是有限的，当服务器上的网卡吞吐量达到上限，这个时候就算性能再好的服务器我们访问它都会感觉慢，这时我们就需要考虑增大网卡的网络吞吐量。一张网卡不够用，我们用两张，三张，很多张。虽然很多张网卡同时对外提供服务是可以解决吞吐量的问题，但是新的问题又产生了，用户怎么知道我们其他网卡上的ip呢？通常情况我们的都是以一个ip对外服务，（当然也有多个ip对外服务，一个域名对外服务，后台可能是多个IP），用户只知道一个ip或者域名，那我们虽然装了很多张网卡，但直接使用好像是达不到我们理想的效果。有没有一种技术将很多张网卡虚拟成一个大的网卡，就有点类似于LVM磁盘管理一样，可以把很多张网卡整合成一张，然后来提高网卡的性能呢？诶，有的，bonding就有这样的功能。它可以将多张网卡绑定同一IP地址对外提供服务，可实现高可用或负载均衡。我们都知道两张网卡或多张网卡设置同一IP地址是不可以的，但bonding可以，它的底层工作原理就是通过虚拟一块网卡对外提供连接，物理网卡的MAC地址都会被修改成相同的MAC地址。这样一来就实现了提高网卡的性能的同时也有冗余的网卡。&lt;/p&gt;
&lt;p&gt;　　二、bonding工作模式&lt;/p&gt;
&lt;p&gt;　　bonding的工作模式有七种，其中有三种是最为常用&lt;/p&gt;
&lt;p&gt;　　Mode 0 (balance-rr)轮转策略：这种模式就是从头到尾顺序的在每一个slave接口上发送数据包，它提供了网卡的负载均衡和容错的能力&lt;/p&gt;
&lt;p&gt;　　mode 1 (active-backup) 活动-备份策略：这种模式只有一个slave被激活，当且仅当活动的slave接口失败时才会激活其他slave，为了避免交换机发生混乱，此时绑定的MAC地址只有一个外部端口上可见&lt;/p&gt;
&lt;p&gt;　　mode 3(broadcast)广播策略：这种模式在所有的slave接口上传送所有的报文，提供容错能力。&lt;/p&gt;
&lt;p&gt;　　注意：active-backup、balance-tlb 和 balance-alb 模式不需要交换机的任何特殊配置。其他绑定模式需要配置交换机以便整合链接。如：Cisco 交换机需要在模式 0、2 和 3 中使用 EtherChannel，但在模式4中需要 LACP和EtherChannel&lt;/p&gt;
&lt;p&gt;　　三、bonding实现 mode 0 并测试&lt;/p&gt;
&lt;p&gt;　　1）查看系统是否加载了bonding模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# lsmod|grep bonding
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：如果你的系统执行了lsmod命令 没有过滤到bonding相关的内容，说明你的系统没有加载bonding模块&lt;/p&gt;
&lt;p&gt;　　2）加载bonding模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# lsmod|grep bonding
[root@test-centos7-node1 ~]# modprobe bonding
[root@test-centos7-node1 ~]# lsmod |grep bonding
bonding               145728  0 
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：通常情况下内核版本2.4以后都是默认支持bonding模块，无需手动编译&lt;/p&gt;
&lt;p&gt;　　3）备份原有的网卡配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 test]# ls /etc/sysconfig/network-scripts/
ifcfg-ens33  ifdown-ippp    ifdown-sit       ifup-bnep  ifup-plusb   ifup-TeamPort
ifcfg-ens36  ifdown-ipv6    ifdown-Team      ifup-eth   ifup-post    ifup-tunnel
ifcfg-lo     ifdown-isdn    ifdown-TeamPort  ifup-ippp  ifup-ppp     ifup-wireless
ifdown       ifdown-post    ifdown-tunnel    ifup-ipv6  ifup-routes  init.ipv6-global
ifdown-bnep  ifdown-ppp     ifup             ifup-isdn  ifup-sit     network-functions
ifdown-eth   ifdown-routes  ifup-aliases     ifup-plip  ifup-Team    network-functions-ipv6
[root@test-centos7-node1 test]# cp /etc/sysconfig/network-scripts/{ifcfg-ens33,ifcfg-ens33.bak}
[root@test-centos7-node1 test]# cp /etc/sysconfig/network-scripts/{ifcfg-ens36,ifcfg-ens36.bak}
[root@test-centos7-node1 test]# ls /etc/sysconfig/network-scripts/
ifcfg-ens33      ifdown       ifdown-isdn    ifdown-Team      ifup-bnep  ifup-plip    ifup-sit       init.ipv6-global
ifcfg-ens33.bak  ifdown-bnep  ifdown-post    ifdown-TeamPort  ifup-eth   ifup-plusb   ifup-Team      network-functions
ifcfg-ens36      ifdown-eth   ifdown-ppp     ifdown-tunnel    ifup-ippp  ifup-post    ifup-TeamPort  network-functions-ipv6
ifcfg-ens36.bak  ifdown-ippp  ifdown-routes  ifup             ifup-ipv6  ifup-ppp     ifup-tunnel
ifcfg-lo         ifdown-ipv6  ifdown-sit     ifup-aliases     ifup-isdn  ifup-routes  ifup-wireless
[root@test-centos7-node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4）创建bonding配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 test]# vim /etc/sysconfig/network-scripts/ifcfg-bond0
  
DEVICE=bond0
ONBOOT=YES
BOOTPROTO=static
IPADDR=192.168.0.33
PREFIX=24
GATEWAY=192.168.0.1
DNS1=192.168.0.1
BONDING_OPTS=&quot;miimon=100 mode=0&quot;
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
~                                                                                                                           
&quot;/etc/sysconfig/network-scripts/ifcfg-bond0&quot; [New] 8L, 141C written                                       
[root@test-centos7-node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：band0相对于原来的物理网卡它也是一块网卡，我们可以像配置物理网卡一样配置，但它又区别于物理网卡，它是一张虚拟的网卡，我们除了配置ip地址信息之外，还需要配置它工作的模式，以及心跳检测时间，其中miimon 是用来进行链路监测的。如果miimon=100，那么系统每100ms 监测一次链路连接状态，如果有一条线路不通就转入另一条线路。&lt;/p&gt;
&lt;p&gt;　　5）修改物理网卡配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 test]# cat /etc/sysconfig/network-scripts/ifcfg-ens33
NAME=ens33
DEVICE=ens33
ONBOOT=yes
BOOTPROTO=none
MASTER=bond0
SLAVE=yes
[root@test-centos7-node1 test]# cat /etc/sysconfig/network-scripts/ifcfg-ens36
NAME=ens36
DEVICE=ens36
ONBOOT=yes
BOOTPROTO=none
MASTER=bond0
SLAVE=yes
[root@test-centos7-node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：把原有的配置ip信息去掉，把BOOTPROTO修改成none，然后新加MASTER=bond0，SLAVE=yes即可&lt;/p&gt;
&lt;p&gt;　　6）重启网络服务并测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200110222340612-2075366697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　说明：重启网络服务我用的crt会一直卡在哪里，原因是我们重新配置了IP地址。我们可用crt重新连接新配的地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 test]# ip a s
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: &amp;lt;BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast master bond0 state UP qlen 1000
    link/ether 00:0c:29:f2:82:0c brd ff:ff:ff:ff:ff:ff
3: ens36: &amp;lt;BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast master bond0 state UP qlen 1000
    link/ether 00:0c:29:f2:82:0c brd ff:ff:ff:ff:ff:ff
5: bond0: &amp;lt;BROADCAST,MULTICAST,MASTER,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP qlen 1000
    link/ether 00:0c:29:f2:82:0c brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.33/24 brd 192.168.0.255 scope global bond0
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fef2:820c/64 scope link tentative dadfailed 
       valid_lft forever preferred_lft forever
[root@test-centos7-node1 test]# cat /proc/net/bonding/bond0 
Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)

Bonding Mode: load balancing (round-robin)
MII Status: up
MII Polling Interval (ms): 100
Up Delay (ms): 0
Down Delay (ms): 0

Slave Interface: ens33
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:f2:82:0c
Slave queue ID: 0

Slave Interface: ens36
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:f2:82:16
Slave queue ID: 0
[root@test-centos7-node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到两张物理网卡和bond0的MAC都变成一样了，况且两张物理网卡上没有任何ip地址，bond0上是我们刚才配置的ip地址，说明我们配置的bond0已经可以使用了。当然我们也可以看/proc/net/bonding/bond0来查看bond的详细信息，其中可以看到两块物理网卡都从属bond0,band0的工作模式是load balancing。此模式实现了网卡的负载均衡和容错，我们可任意断开一个物理网卡，其网络服务不断开。测试的话可选择下载一个大文件来测试。&lt;/p&gt;
&lt;p&gt;　　下载http://192.168.0.99/bigfile 文件测试&lt;/p&gt;
&lt;p&gt;　　1）使用bond0 两物理网卡负载均衡来下载&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 test]# time wget http://192.168.0.99/bigfile
--2020-01-10 10:33:48--  http://192.168.0.99/bigfile
Connecting to 192.168.0.99:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 5211422720 (4.9G)
Saving to: ‘bigfile’

100%[============================================================&amp;gt;] 5,211,422,720 57.2MB/s   in 93s    

2020-01-10 10:35:21 (53.6 MB/s) - ‘bigfile’ saved [5211422720/5211422720]


real    1m32.961s
user    0m0.502s
sys     0m21.582s
[root@test-centos7-node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说：可看到下载一个4.9G的大文件，用bond0下载平均下载速度是53.6MB/S&lt;/p&gt;
&lt;p&gt;　　2）不使用bond0下载，恢复两物理网卡，让其都是用不同的IP&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# ls /etc/sysconfig/network-scripts/
ifcfg-ens33      ifdown-ippp    ifdown-TeamPort  ifup-isdn    ifup-TeamPort
ifcfg-ens33.bak  ifdown-ipv6    ifdown-tunnel    ifup-plip    ifup-tunnel
ifcfg-ens36      ifdown-isdn    ifup             ifup-plusb   ifup-wireless
ifcfg-ens36.bak  ifdown-post    ifup-aliases     ifup-post    init.ipv6-global
ifcfg-lo         ifdown-ppp     ifup-bnep        ifup-ppp     network-functions
ifdown           ifdown-routes  ifup-eth         ifup-routes  network-functions-ipv6
ifdown-bnep      ifdown-sit     ifup-ippp        ifup-sit
ifdown-eth       ifdown-Team    ifup-ipv6        ifup-Team
[root@test-centos7-node1 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens33
NAME=ens33
DEVICE=ens33
ONBOOT=yes
IPADDR=192.168.0.10
PREFIX=24
GATEWAY=192.168.0.1
DNS1=192.168.0.1
[root@test-centos7-node1 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens36
NAME=ens36
DEVICE=ens36
ONBOOT=yes
IPADDR=192.168.0.20
PREFIX=24
GATEWAY=192.168.0.1
DNS1=192.168.0.1
[root@test-centos7-node1 ~]# ip a 
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:f2:82:0c brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.10/24 brd 192.168.0.255 scope global ens33
       valid_lft forever preferred_lft forever
3: ens36: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:f2:82:16 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.20/24 brd 192.168.0.255 scope global ens36
       valid_lft forever preferred_lft forever
5: bond0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,MASTER,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN qlen 1000
    link/ether e6:e0:29:24:b5:e1 brd ff:ff:ff:ff:ff:ff
[root@test-centos7-node1 ~]# time wget http://192.168.0.99/bigfile
--2020-01-10 10:42:55--  http://192.168.0.99/bigfile
Connecting to 192.168.0.99:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 5211422720 (4.9G)
Saving to: ‘bigfile’

100%[=================================================&amp;gt;] 5,211,422,720 63.6MB/s   in 2m 48s 

2020-01-10 10:45:43 (29.6 MB/s) - ‘bigfile’ saved [5211422720/5211422720]


real    2m48.065s
user    0m0.823s
sys     1m6.360s
[root@test-centos7-node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可看到不使用bond0 下载平均速度是29.6MB/S&lt;/p&gt;
&lt;p&gt;　　四、bonding实现 mode 1 并测试&lt;/p&gt;
&lt;p&gt;　　前面的网卡配置文件备份，这里就不在演示，同上面的一样，这里只需要修改bond0 的配置文件，将其mode=0 修改成mode=1 ,物理网卡的配置文件同上面的一样&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# ip a l
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: &amp;lt;BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast master bond0 state UP qlen 1000
    link/ether e6:e0:29:24:b5:e1 brd ff:ff:ff:ff:ff:ff
3: ens36: &amp;lt;BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast master bond0 state UP qlen 1000
    link/ether e6:e0:29:24:b5:e1 brd ff:ff:ff:ff:ff:ff
5: bond0: &amp;lt;BROADCAST,MULTICAST,MASTER,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP qlen 1000
    link/ether e6:e0:29:24:b5:e1 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.33/24 brd 192.168.0.255 scope global bond0
       valid_lft forever preferred_lft forever
    inet6 fe80::e4e0:29ff:fe24:b5e1/64 scope link 
       valid_lft forever preferred_lft forever
[root@test-centos7-node1 ~]# cat /proc/net/bonding/bond0 
Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)

Bonding Mode: fault-tolerance (active-backup)
Primary Slave: None
Currently Active Slave: ens33
MII Status: up
MII Polling Interval (ms): 100
Up Delay (ms): 0
Down Delay (ms): 0

Slave Interface: ens33
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:f2:82:0c
Slave queue ID: 0

Slave Interface: ens36
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:f2:82:16
Slave queue ID: 0
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：可以看到，两个网卡都是启动的状态，当前活跃的网卡是ens33&lt;/p&gt;
&lt;p&gt;　　测试：模拟ens33网线断了，看看ens36会不会顶替上去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200111003136470-1582204667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200111003233225-20708907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　说明：可以看到ens33出现故障 ens36 立即就顶替上去了，这里需要注意一点ens33如果恢复了，它不会去顶替ens36 它会一直盯着ens36 直到它ens36死了，它才会顶替上去。&lt;/p&gt;
&lt;p&gt;　　五、bonding实现 mode 3&lt;/p&gt;
&lt;p&gt;　　前期准备同上，只需更改bond0配置文件/etc/sysconfig/network-scripts/ifcfg-bond0，把mode=1  修改成mode=3，然后重启服务网络即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# cat /etc/sysconfig/network-scripts/ifcfg-bond0
DEVICE=bond0
ONBOOT=YES
BOOTPROTO=static
IPADDR=192.168.0.33
PREFIX=24
GATEWAY=192.168.0.1
DNS1=192.168.0.1
BONDING_OPTS=&quot;miimon=100 mode=3&quot;
[root@test-centos7-node1 ~]# systemctl restart network
[root@test-centos7-node1 ~]# ip a 
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: &amp;lt;BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast master bond0 state UP qlen 1000
    link/ether e6:e0:29:24:b5:e1 brd ff:ff:ff:ff:ff:ff
3: ens36: &amp;lt;BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast master bond0 state UP qlen 1000
    link/ether e6:e0:29:24:b5:e1 brd ff:ff:ff:ff:ff:ff
5: bond0: &amp;lt;BROADCAST,MULTICAST,MASTER,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP qlen 1000
    link/ether e6:e0:29:24:b5:e1 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.33/24 brd 192.168.0.255 scope global bond0
       valid_lft forever preferred_lft forever
    inet6 fe80::e4e0:29ff:fe24:b5e1/64 scope link tentative dadfailed 
       valid_lft forever preferred_lft forever
[root@test-centos7-node1 ~]# cat /proc/net/bonding/bond0 
Ethernet Channel Bonding Driver: v3.7.1 (April 27, 2011)

Bonding Mode: fault-tolerance (broadcast)
MII Status: up
MII Polling Interval (ms): 100
Up Delay (ms): 0
Down Delay (ms): 0

Slave Interface: ens33
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:f2:82:0c
Slave queue ID: 0

Slave Interface: ens36
MII Status: up
Speed: 1000 Mbps
Duplex: full
Link Failure Count: 0
Permanent HW addr: 00:0c:29:f2:82:16
Slave queue ID: 0
[root@test-centos7-node1 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：此模式是广播模式，什么意思呢，就是访问bond0 它就会广播给每个网卡，然后每张物理网卡收到广播后都会回应。&lt;/p&gt;
&lt;p&gt;　　测试：在192.168.0.99 上ping 192.168.0.33&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test html]# ping 192.168.0.33
PING 192.168.0.33 (192.168.0.33) 56(84) bytes of data.
64 bytes from 192.168.0.33: icmp_seq=1 ttl=64 time=1.43 ms
64 bytes from 192.168.0.33: icmp_seq=1 ttl=64 time=1.51 ms (DUP!)
64 bytes from 192.168.0.33: icmp_seq=2 ttl=64 time=1.38 ms
64 bytes from 192.168.0.33: icmp_seq=2 ttl=64 time=1.45 ms (DUP!)
64 bytes from 192.168.0.33: icmp_seq=3 ttl=64 time=2.22 ms
64 bytes from 192.168.0.33: icmp_seq=3 ttl=64 time=2.28 ms (DUP!)
64 bytes from 192.168.0.33: icmp_seq=4 ttl=64 time=0.997 ms
64 bytes from 192.168.0.33: icmp_seq=4 ttl=64 time=1.06 ms (DUP!)
64 bytes from 192.168.0.33: icmp_seq=5 ttl=64 time=0.618 ms
64 bytes from 192.168.0.33: icmp_seq=5 ttl=64 time=0.764 ms (DUP!)
64 bytes from 192.168.0.33: icmp_seq=6 ttl=64 time=0.600 ms
64 bytes from 192.168.0.33: icmp_seq=6 ttl=64 time=0.670 ms (DUP!)
64 bytes from 192.168.0.33: icmp_seq=7 ttl=64 time=0.584 ms
64 bytes from 192.168.0.33: icmp_seq=7 ttl=64 time=0.707 ms (DUP!)
64 bytes from 192.168.0.33: icmp_seq=8 ttl=64 time=0.581 ms
64 bytes from 192.168.0.33: icmp_seq=8 ttl=64 time=0.651 ms (DUP!)
64 bytes from 192.168.0.33: icmp_seq=9 ttl=64 time=0.579 ms
64 bytes from 192.168.0.33: icmp_seq=9 ttl=64 time=0.650 ms (DUP!)
64 bytes from 192.168.0.33: icmp_seq=10 ttl=64 time=0.589 ms
64 bytes from 192.168.0.33: icmp_seq=10 ttl=64 time=0.661 ms (DUP!)
^C
--- 192.168.0.33 ping statistics ---
10 packets transmitted, 10 received, +10 duplicates, 0% packet loss, time 9006ms
rtt min/avg/max/mdev = 0.579/0.999/2.284/0.528 ms
[root@test html]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：0.99向0.33发送一条ping报文，0.99上收到了两个消息，是不是很奇怪呀，出去一个回来两个重复的。这就是因为0.33上的两块物理网卡收到广播后都进行了回应，所以在0.99上会收到2条重复的回应消息。&lt;/p&gt;
&lt;p&gt;　　六、卸载bonding 恢复原有物理网卡&lt;/p&gt;
&lt;p&gt;　　1）恢复配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos7-node1 ~]# cp /etc/sysconfig/network-scripts/{ifcfg-ens33.bak,ifcfg-ens33}
cp: overwrite ‘/etc/sysconfig/network-scripts/ifcfg-ens33’? y
[root@test-centos7-node1 ~]# cp /etc/sysconfig/network-scripts/{ifcfg-ens36.bak,ifcfg-ens36}
cp: overwrite ‘/etc/sysconfig/network-scripts/ifcfg-ens36’? y
[root@test-centos7-node1 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens33
NAME=ens33
DEVICE=ens33
ONBOOT=yes
IPADDR=192.168.0.10
PREFIX=24
GATEWAY=192.168.0.1
DNS1=192.168.0.1
[root@test-centos7-node1 ~]# cat /etc/sysconfig/network-scripts/ifcfg-ens36
NAME=ens36
DEVICE=ens36
ONBOOT=yes
IPADDR=192.168.0.20
PREFIX=24
GATEWAY=192.168.0.1
DNS1=192.168.0.1
[root@test-centos7-node1 ~]# mv /etc/sysconfig/network-scripts/{ifcfg-bond0,ifcfg-bond0.bak} 
[root@test-centos7-node1 ~]# ls /etc/sysconfig/network-scripts/
ifcfg-bond0.bak  ifcfg-lo     ifdown-ipv6    ifdown-sit       ifup-aliases  ifup-isdn   ifup-routes    ifup-wireless
ifcfg-ens33      ifdown       ifdown-isdn    ifdown-Team      ifup-bnep     ifup-plip   ifup-sit       init.ipv6-global
ifcfg-ens33.bak  ifdown-bnep  ifdown-post    ifdown-TeamPort  ifup-eth      ifup-plusb  ifup-Team      network-functions
ifcfg-ens36      ifdown-eth   ifdown-ppp     ifdown-tunnel    ifup-ippp     ifup-post   ifup-TeamPort  network-functions-ipv6
ifcfg-ens36.bak  ifdown-ippp  ifdown-routes  ifup             ifup-ipv6     ifup-ppp    ifup-tunnel
[root@test-centos7-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）卸载bonding 模块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202001/1503305-20200111012146908-315811817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　3）重启&lt;/p&gt;
&lt;p&gt;　　正常情况下修改了配置文件后重启网络服务就可以了 ，如果要卸载bonding模块，卸载后重启网络服务，物理网卡是启动不起来的，需要把服务器重启下即可恢复正常。&lt;/p&gt;
&lt;p&gt;　　总结：通过上面的实验可以看到 bonding技术类似raid技术，它可把多张网卡绑定在一起,不同的模式有着不同模式的特点。mode 0 轮循负载均衡，可提高网卡的性能的同时也有冗余网卡。mode1 主备模式，可实现网卡的高可用。mode3 广播模式，提供容错能力。其他模式可参考文档&lt;a href=&quot;https://www.kernel.org/doc/Documentation/networking/bonding.txt&quot; target=&quot;_blank&quot;&gt;https://www.kernel.org/doc/Documentation/networking/bonding.txt&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 Jan 2020 17:33:00 +0000</pubDate>
<dc:creator>qiuhom</dc:creator>
<og:description>一、bonding介绍 在企业Linux服务器管理里中，服务器的可靠性、可用性以及I/O速度都非常重要，保持服务器的高可用和安全性是生产环境的重要指标，其中最重要的一点是服务器网络连接的高可用性。通常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12178412.html</dc:identifier>
</item>
<item>
<title>【tf.keras】AdamW: Adam with Weight decay - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/12178778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/12178778.html</guid>
<description>&lt;p&gt;论文 &lt;a href=&quot;https://arxiv.org/abs/1711.05101&quot;&gt;Decoupled Weight Decay Regularization&lt;/a&gt; 中提到，Adam 在使用时，L2 regularization 与 weight decay 并不等价，并提出了 AdamW，在神经网络需要正则项时，用 AdamW 替换 Adam+L2 会得到更好的性能。&lt;/p&gt;
&lt;p&gt;TensorFlow 2.0 在 &lt;a href=&quot;https://github.com/tensorflow/addons&quot;&gt;tensorflow_addons&lt;/a&gt; 库里面实现了 AdamW，目前在 Mac 和 Linux 上可以直接&lt;code&gt;pip install tensorflow_addons&lt;/code&gt;进行安装，在 windows 上还不支持，但也可以直接把这个仓库下载下来使用。&lt;/p&gt;
&lt;p&gt;下面是一个利用 AdamW 的示例程序（TF 2.0, tf.keras），在使用 AdamW 的同时，使用 learning rate decay：（以下程序中，AdamW 的结果不如 Adam，这是因为模型比较简单，加入 regularization 反而影响性能）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import tensorflow as tf
import os
from tensorflow_addons.optimizers import AdamW

import numpy as np

from tensorflow.python.keras import backend as K
from tensorflow.python.util.tf_export import keras_export
from tensorflow.keras.callbacks import Callback


def lr_schedule(epoch):
    &quot;&quot;&quot;Learning Rate Schedule
    Learning rate is scheduled to be reduced after 20, 30 epochs.
    Called automatically every epoch as part of callbacks during training.
    # Arguments
        epoch (int): The number of epochs
    # Returns
        lr (float32): learning rate
    &quot;&quot;&quot;
    lr = 1e-3

    if epoch &amp;gt;= 30:
        lr *= 1e-2
    elif epoch &amp;gt;= 20:
        lr *= 1e-1
    print('Learning rate: ', lr)
    return lr


def wd_schedule(epoch):
    &quot;&quot;&quot;Weight Decay Schedule
    Weight decay is scheduled to be reduced after 20, 30 epochs.
    Called automatically every epoch as part of callbacks during training.
    # Arguments
        epoch (int): The number of epochs
    # Returns
        wd (float32): weight decay
    &quot;&quot;&quot;
    wd = 1e-4

    if epoch &amp;gt;= 30:
        wd *= 1e-2
    elif epoch &amp;gt;= 20:
        wd *= 1e-1
    print('Weight decay: ', wd)
    return wd


# just copy the implement of LearningRateScheduler, and then change the lr with weight_decay
@keras_export('keras.callbacks.WeightDecayScheduler')
class WeightDecayScheduler(Callback):
    &quot;&quot;&quot;Weight Decay Scheduler.

    Arguments:
        schedule: a function that takes an epoch index as input
            (integer, indexed from 0) and returns a new
            weight decay as output (float).
        verbose: int. 0: quiet, 1: update messages.

    ```python
    # This function keeps the weight decay at 0.001 for the first ten epochs
    # and decreases it exponentially after that.
    def scheduler(epoch):
      if epoch &amp;lt; 10:
        return 0.001
      else:
        return 0.001 * tf.math.exp(0.1 * (10 - epoch))

    callback = WeightDecayScheduler(scheduler)
    model.fit(data, labels, epochs=100, callbacks=[callback],
              validation_data=(val_data, val_labels))
    ```
    &quot;&quot;&quot;

    def __init__(self, schedule, verbose=0):
        super(WeightDecayScheduler, self).__init__()
        self.schedule = schedule
        self.verbose = verbose

    def on_epoch_begin(self, epoch, logs=None):
        if not hasattr(self.model.optimizer, 'weight_decay'):
            raise ValueError('Optimizer must have a &quot;weight_decay&quot; attribute.')
        try:  # new API
            weight_decay = float(K.get_value(self.model.optimizer.weight_decay))
            weight_decay = self.schedule(epoch, weight_decay)
        except TypeError:  # Support for old API for backward compatibility
            weight_decay = self.schedule(epoch)
        if not isinstance(weight_decay, (float, np.float32, np.float64)):
            raise ValueError('The output of the &quot;schedule&quot; function '
                             'should be float.')
        K.set_value(self.model.optimizer.weight_decay, weight_decay)
        if self.verbose &amp;gt; 0:
            print('\nEpoch %05d: WeightDecayScheduler reducing weight '
                  'decay to %s.' % (epoch + 1, weight_decay))

    def on_epoch_end(self, epoch, logs=None):
        logs = logs or {}
        logs['weight_decay'] = K.get_value(self.model.optimizer.weight_decay)


if __name__ == '__main__':
    os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = '1'

    gpus = tf.config.experimental.list_physical_devices(device_type='GPU')
    for gpu in gpus:
        tf.config.experimental.set_memory_growth(gpu, enable=True)
    print(gpus)
    cifar10 = tf.keras.datasets.cifar10

    (x_train, y_train), (x_test, y_test) = cifar10.load_data()
    x_train, x_test = x_train / 255.0, x_test / 255.0

    model = tf.keras.models.Sequential([
        tf.keras.layers.Conv2D(16, (3, 3), padding='same', activation='relu', input_shape=(32, 32, 3)),
        tf.keras.layers.AveragePooling2D(),
        tf.keras.layers.Conv2D(32, (3, 3), padding='same', activation='relu'),
        tf.keras.layers.AveragePooling2D(),
        tf.keras.layers.Flatten(),
        tf.keras.layers.Dense(10, activation='softmax')
    ])

    optimizer = AdamW(learning_rate=lr_schedule(0), weight_decay=wd_schedule(0))
    # optimizer = tf.keras.optimizers.Adam(learning_rate=1e-3)

    tb_callback = tf.keras.callbacks.TensorBoard(os.path.join('logs', 'adamw'),
                                                 profile_batch=0)
    lr_callback = tf.keras.callbacks.LearningRateScheduler(lr_schedule)
    wd_callback = WeightDecayScheduler(wd_schedule)

    model.compile(optimizer=optimizer,
                  loss='sparse_categorical_crossentropy',
                  metrics=['accuracy'])

    model.fit(x_train, y_train, epochs=40, validation_split=0.1,
              callbacks=[tb_callback, lr_callback, wd_callback])

    model.evaluate(x_test, y_test, verbose=2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码实现了在 learning rate decay 时使用 AdamW，虽然只能是在 epoch 层面进行学习率衰减。&lt;/p&gt;
&lt;p&gt;在使用 AdamW 时，如果要使用 learning rate decay，那么对 weight_decay 的值要进行同样的学习率衰减，不然训练会崩掉。&lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tensorflow/addons/issues/844#issuecomment-573011015&quot;&gt;How to use AdamW correctly? -- wuliytTaotao&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://arxiv.org/abs/1711.05101&quot;&gt;Loshchilov, I., &amp;amp; Hutter, F. Decoupled Weight Decay Regularization. ICLR 2019. Retrieved from http://arxiv.org/abs/1711.05101&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 Jan 2020 16:45:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>论文 &amp;quot;Decoupled Weight Decay Regularization&amp;quot; 中提到，Adam 在使用时，L2 regularization 与 weight decay</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuliytTaotao/p/12178778.html</dc:identifier>
</item>
<item>
<title>深入浅出 JVM 系列（一）什么是 JVM？它处于什么位置？ - 小李不秃</title>
<link>http://www.cnblogs.com/ferryman/p/12178688.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ferryman/p/12178688.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;阅读本文大概需要 5.6 分钟&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 Java 开发中，我们经常会提到 JVM。我们知道 JVM 是 Java 虚拟机，但是它的运行原理是什么？它的内存结构是什么？如何进行优化？如何去定位问题？面试中遇到 JVM 问题如何回答？&lt;/p&gt;
&lt;p&gt;接下来我会开启 JVM 的章节，为大家一一解答上面的问题。现在就开启我们的 JVM 学习之路吧！&lt;/p&gt;

&lt;p&gt;面试官：什么是 JVM？&lt;/p&gt;
&lt;p&gt;小李：JVM（Java Virtual Machine）是 Java 虚拟机，用于运行 Java 编译后的二进制字节码，最后生成机器指令。（心里一想，简简单单）&lt;/p&gt;
&lt;p&gt;面试官：那为什么 Java 研发体系需要 JVM？你对 JVM 的运行原理了解多少？我们写的 Java 代码到底是如何运行起来的？&lt;/p&gt;
&lt;p&gt;小李：嗯。。。就是。。。嗯。。。是那个。。。嗯。。。&lt;/p&gt;
&lt;p&gt;面试官：面试就到这里了，先回去等通知吧。&lt;/p&gt;
&lt;p&gt;小李：好的！（哭着回答）&lt;/p&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2WWLus7YmakQcOkaE65o38tKGgiamM7mt2dn4rTuogXXqhtKwMYCz4QQ/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;hr/&gt;&lt;p&gt;这里面试官对小李进行三连问：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;为什么 Java 研发体系需要 JVM？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;你对 JVM 的运行原理了解多少？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;我们写的 Java 代码到底是如何运行起来的？&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这套组合拳看似很厉害，其实就是军体拳。&lt;/p&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2ia1VL1IMiaL1WgnG3CZj6ibjkj9yLqCw3BRgHYUQ0mLpv6JovAdSXHCYg/0?wx_fmt=jpeg&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;如果想完美的练这套军体拳，不，是完美的回答这三个问题，就需要首先要了解 JVM 是什么？它和 Java 是什么关系？又和 JDK 有什么渊源？那要弄清楚这些问题，就需要从三个维度去思考：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;JVM 和操作系统的关系；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;JVM 、JRE、JDK 的关系；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Java 虚拟机规范和 Java 语言规范的关系。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;弄清楚这这几者的关系，我们再通过一个简单代码示例来看一个 Java 程序到底是如何执行的。&lt;/p&gt;
&lt;h2 id=&quot;hjvm-1&quot;&gt;&lt;span&gt;JVM 和 操作系统的关系&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们知道炼制一把牛逼的大宝剑，不仅需要上等的技术，还需要一鼎经百炼的剑炉。而工程师就相当于铸剑的剑师，JVM 便是剑炉。&lt;/p&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2b8iaPiatQO37J0uvuDCwHdORlnyF8adBeLj1R68eNcIKxoeNNuOW7y3A/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;JVM 就是我们耳熟能详的 Java 虚拟机。它能识别 .class 后缀文件，并且能够解析它的指令，最终调用操作系统上的函数，完成我们想要的操作。&lt;/p&gt;
&lt;p&gt;Java 程序和 C++ 程序有什么不同呢？这里用两张图进行说明。&lt;/p&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2dBDFn3ib7BMDH305FRr99amKQRbJHcAgTL3IvmD2aRX5ZqjEj9x4B2w/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2LLoPlIibgwZPxRIHribbjznqxODtdV8mSTWQq8rQsOR2jlgEcYMXzicjw/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;对比两张图可以看到 C++ 开发的程序可以翻译成操作系统能识别的 .exe 文件。而 Java 程序需要通过 javac 编译成 .class 文件之后，然后由 JVM 负责调用系统函数执行程序，操作系统并不认识 .class 文件。&lt;/p&gt;
&lt;p&gt;那读者就劝小李了，转 C++ 开发吧，这 Java 还搞了一个处于程序和操作系统的虚拟机，不像 C++ 编译后直接在操作系统上运行，肯定不是啥好玩意。&lt;/p&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P23U5wOOXyvj6ogbwcCjcB0dpkVNiateYFGCX0kqeMtdn0VO85ZkVmIxA/0?wx_fmt=jpeg&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;我就知道你们坏的很，知道 JVM 的过人之处，还不告诉小李。那我给小李讲讲 JVM 的过人之处：&lt;/p&gt;
&lt;p&gt;Java 是一门&lt;strong&gt;抽象度特别高&lt;/strong&gt;的语言，提供了&lt;strong&gt;自动内存管理&lt;/strong&gt;等一系列的特性。这些特性在操作系统上基本上是无望了，所以就需要 JVM 进行一番转换。&lt;/p&gt;
&lt;p&gt;经过上面的介绍，我们可以做如下的类比：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;JVM：等同于操作系统；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Java 字节码：等同于汇编语言。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Java 字节码还是比较容易读懂，从侧面上也证明了 Java 语言的抽象程度高。我们可以认为 JVM 是一个翻译器，会持续不断的翻译执行 Java 字节码，然后调用真正的操作系统函数，这些操作系统函数是与平台息息相关的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;可以把 JVM 想象一个有道词典，.class 文件是英文，而输出的结果是中文。有道词典有 windows版本，也有 Linux 版本，内部具体的实现肯定不同，但最终都会得到相同的结果，这样就好理解一些了）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2CPLdaRJ6TanPtms2ibbtDh1AfVbREVN653roqp2o3dgwqEWOlkBtj5w/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;当有个 JVM 这个抽象层，就可以实现跨平台了。JVM 只需要正确执行 .class 文件，就可以运行在 Linux、Windos、MacOS 等平台了。&lt;/p&gt;
&lt;p&gt;Java 跨平台的意义在于一次编译，处处运行，这里 JVM 功不可没。比如在 Maven 仓库下载的 jar 包就可以到处运行，不需要在每个平台上再编译一次。&lt;/p&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2ZWudQufPzuRWTkr9NpdcWCCXZ5xs2wgCFgTwcnfr96epDrDHf20aEg/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;&lt;strong&gt;我们来概括 JVM 与操作系统之间的关系&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;JVM 上承开发语言，下接操作系统，它的中间接口就是字节码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;hjvmjrejdk&quot;&gt;&lt;span&gt;JVM、JRE、JDK 的关系&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;通过上面的学习，我们了解到 JVM 是 Java 程序能够运行的核心。但是我们要知道，JVM 自己什么也干不了，你需要给它提供原料（.class 文件）。俗话说：巧妇难为无米之炊。JVM 功能虽然强大，但还是需要为它提供 .class 文件。&lt;/p&gt;
&lt;p&gt;但是仅靠 JVM 是无法完成一次编译，到处运行的。它需要一个基本的类库，比如怎么操作文件、怎么连接网络、怎么教你出拳（小李已疯）等。而 Java 体系会一次性将 JVM 运行所需的类库都传递给它。JVM 标准加上基本类库就组成了 Java 的运行环境，就是 JRE （Java Runtime Enviroment）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JVM + 基本类库 = JRE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那 JDK 又是什么呢？&lt;/p&gt;
&lt;p&gt;JDK 全称 Java Development Kit，Kit 是装备的意思。所以 JDK 不仅包含 JRE，还有一些小工具，比如 javac、java、jar等。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;JRE + javac/java/jar 等指令工具 = JDK&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JVM、JRE、JDK 它们三者之间的关系，可以用一个包含关系表示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;JDK &amp;gt; JRE &amp;gt; JVM&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2kqbKPrEdsRIJKvCHtnw5niavFCQz2lMySUGib2tmhU9VyvvDgpDllaTg/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;h2 id=&quot;hjavajava&quot;&gt;&lt;span&gt;Java 虚拟机规范和 Java 语言规范的关系&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;从广义上来讲，JVM 是一种规范，它是最为官方、准确的文档；狭义上来讲，由于我们使用 Hotspot 更多一些，所以我们在谈到这个概念时，会将他们等同起来。&lt;/p&gt;
&lt;p&gt;如果再加我们平常使用的 Java 语言，可以得到下面一张图。&lt;/p&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P236ibJR8V1oQOOUCR5GAfluzpQhJ6XV4pBcFpiaxxOIzMNZeH6h7E6g1Q/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;左边是 Java 虚拟机规范，为字节码的解析提供一个环境。右边是 Java 语法规范，比如 switch、for、泛型、lambda 等相关的程序，最终都会编译成字节码。而字节码是链接左右两部分的桥梁。&lt;/p&gt;
&lt;p&gt;如果 .class 文件的规格是不变的，这两部分是可以独立进行优化的。But 没有如果，现在都已经到 Java 13 了，为了支持更多的特性，肯定会增加一些字节码指令。&lt;/p&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2Mdmm7e9Fd3p3cnrOyHqCr3UzXzlHoFgfa4XqnhfwZkolicabGeYZlKQ/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;此刻优秀的小李提出了一个让人深思的问题：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果我不学习 JVM，会影响我写 Java 代码么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理论上，这两者没有必然的联系。他们之间通过 .class 文件进行交互，即使你不了解 JVM，也能够写大多数的 Java 代码。就像你是写 C++ 代码一样，并不需要特别深入的了解操作系统的底层是如何实现的。&lt;/p&gt;
&lt;p&gt;那我还学个锤子！瞬间关了该页面。&lt;/p&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2lXujAKicX5KCYs9VaMcvlk7B4mpiancUSWpFCTyiaymq4A3qZR0OMuEFA/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;客官别走，还有但是没说呢。&lt;/p&gt;
&lt;p&gt;但是，如果你想要写一些比较精巧、效率比较高的代码，就需要了解一些执行层面的知识了。了解 JVM，主要用在调优以及故障排查上面，你会对运行中的各种资源分配，有一个比较全面的掌控。（是不是内心还有点小期待呢！）&lt;/p&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P23bPROwqfdZJyqPTEXibEdYDap57LzeicI4FclETtktnDgS3XUI8IFviag/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;h2 id=&quot;hjava&quot;&gt;&lt;span&gt;Java 代码到底是如何运行起来的&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;最后，我们简单看一下 Java 程序的执行过程，了解下它到底是如何运行起来的。&lt;/p&gt;
&lt;p&gt;这里的 Java 程序是文本格式的。比如下面这段 HelloXiaoli.java，它遵循的就是 Java 语言规范。其中，我们调用的 System.out 等模块，就是 JRE 提供的类库。&lt;/p&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2IpGheHnA7ye8fHNfoYqoZCzfGesYFBxO3KOww74Dm1LLGCQ86sHL7w/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;通过 JDK 的工具 javac 进行编译后，就会产生 HelloWorld 的字节码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;javac HelloXiaoli.java&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2VJN9PpuNXp6GaicjFo2phuMvZdQf49ZEL2ynIAsfEeaDGqTyZibf8VXg/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;Java 字节码是沟通 JVM 和 Java 程序的桥梁，下面使用 javap 来看一下字节码到底长什么样子。&lt;a href=&quot;https://blog.csdn.net/hantiannan/article/details/7659904&quot;&gt;javap基本使用&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;javap -verbose HelloXiaoli.class&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs objectivec&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; getstatic &lt;span class=&quot;hljs-meta&quot;&gt;#2 &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;java/lang/System.out&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; ldc &lt;span class=&quot;hljs-meta&quot;&gt;#3 &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;Hello Xiaoli&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; invokevirtual &lt;span class=&quot;hljs-meta&quot;&gt;#4 &lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;java/io/PrintStream.println&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java 虚拟机采用基于栈的架构（为什么基于栈的架构详见：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMTQxNjgwOA==&amp;amp;mid=2247483661&amp;amp;idx=1&amp;amp;sn=e949f3f0f9689933fec1dfa9171a1725&amp;amp;chksm=e8a5378adfd2be9c65c4f4bc428643ffbe934a28cbe1a8a43b55799031721ab184a48679ad03&amp;amp;token=1006818297&amp;amp;lang=zh_CN#rd&quot;&gt;JVM 体系结构与工作方式&lt;/a&gt;），其指令由操作码和操作数组成。这些字节码指令，就叫做 opcode。其中，getstatic、ldc、invokeevirtual、return 等，就是 opcode。&lt;/p&gt;
&lt;p&gt;我们继续使用 hexdump 看一下字节码的二进制内容&lt;a href=&quot;https://man.linuxde.net/hexdump&quot;&gt;hexdump 命令&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;b2&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;02&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;03&lt;/span&gt; b6 &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;04&lt;/span&gt; b1&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看一下它们的对应关系。&lt;a href=&quot;https://blog.csdn.net/u013294097/article/details/103747429&quot;&gt;JVM 字节码对照表&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0xb2&lt;/span&gt;   getstatic       获取静态字段的值&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0x12&lt;/span&gt;   ldc             常量池中的常量值入栈&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0xb6&lt;/span&gt;   invokevirtual   运行时方法绑定调用方法&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0xb1&lt;/span&gt;   &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;          &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; 函数返回&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;opcode 是一个字节的长度（0~255），意味着指令集的操作码个数不能超过 256 条。紧跟在 opcode 后面的是被操作数。比如 b2 00 02，就代表了 getstatic #2 。&lt;/p&gt;
&lt;p&gt;JVM 就是靠解析这些 opcode 和 操作数来完成程序的执行的，当我们使用 Java 命令运行 .class 文件的时候，实际上就相当于启动了一个 JVM 进程。&lt;/p&gt;
&lt;p&gt;JVM 会翻译这些字节码，它有两种执行方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;解释执行，将 opcode + 操作数翻译成机器代码；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;JIT，即时编译，它会在一定条件下将字节码翻译成机器码之后再执行。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/36746487&quot;&gt;即时编译器与解释器的区别？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.class 文件会被加载、存放到 metaspace 中，等待被调用，这里会有一个类加载器的概念。&lt;/p&gt;
&lt;p&gt;JVM 的程序运行，都是在栈上完成的，这和其他普通程序的执行是类似的，分为堆和栈。比如我们程序运行到了 main 方法，就会给它分配一个栈帧。当推出方法体时，会弹出相应的栈帧。其实，大多数字节码指令，就是不断的对栈帧进行操作。&lt;/p&gt;
&lt;p&gt;而其它大块数据，是存放在堆上的。Java 在内存划分上会更为细致，关于这些概念，会在后面的章节中详细介绍。&lt;/p&gt;
&lt;p&gt;我们看下面的图，JVM 部分是我们系列需要讲解的部分。&lt;/p&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2WiakEVlY1S8vax1kvltZqrficgNticMQC4bTgcnAIckbGngSicicgJbxtPQ/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上面讲了这么多，让我们再回头看看面试官提问的三个问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;为什么 Java 研发系统需要 JVM？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为 Java 是一门抽象的语言，并且有自动内存管理机制。而操作系统无法去进行自动垃圾回收等操作，所以就有了虚拟机。虚拟机可以对字节码加载、自动垃圾回收、并发等。而 JVM 只是一个规范，定义了 .class 文件的结构、加载机制、数据存储、运行时栈等诸多内容，最常用的 JVM 实现就是 Hotspot。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;你对 JVM 的运行原理了解多少？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JVM 的生命周期是和 Java 程序的运行一样，当程序运行结束，JVM 实例也就跟着消失了。具体的运行原理，会在后续文章中详细介绍，请关注小李哦！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;我们写的 Java 代码到底是如何运行起来的？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Java 程序通过 javac 编译成 .class 文件，然后虚拟机将其加载到&lt;strong&gt;元数据区&lt;/strong&gt;，执行引擎将会通过&lt;strong&gt;混合模式&lt;/strong&gt;执行这些字节码。执行时，会翻译成操作系统相关的函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过程如下&lt;/strong&gt;：Java 文件-&amp;gt;编译器-&amp;gt;字节码-&amp;gt;JVM-&amp;gt;机器码&lt;/p&gt;

&lt;p&gt;本篇文章从三个角度了解了 JVM 在 Java 研发体系中的位置，并以一个简单的程序，看了下一个 Java 程序的执行过程。&lt;/p&gt;
&lt;p&gt;我们说的 JVM，狭义上指的就是 HotSpot。如果没有特殊说明，我们都以 HotSpot 为准。&lt;/p&gt;
&lt;p&gt;我们知道 Java 之所以跨平台，就是由于 JVM 的存在。Java 的字节码，是沟通 Java 语言与 JVM 的桥梁，同时也是沟通 JVM 与操作系统的桥梁。&lt;/p&gt;
&lt;p&gt;JVM 是一个非常小的集合，我们常说的 Java 运行时环境，也就是 JRE 包含 JVM 和一部分基础类库。如果加上我们常用的一些开发工具，就构成了整个 JDK。&lt;/p&gt;
&lt;p&gt;Java 虚拟机栈采用基于栈的架构，有比较丰富的 opcode。这些字节码可以解释执行，也可以编译成机器码，运行在底层硬件上，可以说 JVM 是一种混合执行的策略。&lt;/p&gt;
&lt;p&gt;留两道思考题给大家：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;栈上都会有哪些数据？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;垃圾回收会发生在什么地方？&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;思考题我会在后面的章节为大家一一解答。&lt;/p&gt;

&lt;p&gt;http://pc-shop.xiaoe-tech.com/appcCrwMYBx6232/video_details?id=v_5e14662379d00_UAifIZpt&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMTQxNjgwOA==&amp;amp;mid=2247483661&amp;amp;idx=1&amp;amp;sn=e949f3f0f9689933fec1dfa9171a1725&amp;amp;chksm=e8a5378adfd2be9c65c4f4bc428643ffbe934a28cbe1a8a43b55799031721ab184a48679ad03&amp;amp;token=1006818297&amp;amp;lang=zh_CN#rd&quot;&gt;JVM 体系结构与工作方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMTQxNjgwOA==&amp;amp;mid=2247483654&amp;amp;idx=1&amp;amp;sn=0cb6f1656d306338cdf022e40a200288&amp;amp;chksm=e8a53781dfd2be977403f5f43a71c85e54f510e000db7670fa16485a4f1079baf74570b415be&amp;amp;token=1006818297&amp;amp;lang=zh_CN#rd&quot;&gt;学习反射看这一篇就够了&lt;/a&gt;&lt;/p&gt;
&lt;img title=&quot;img&quot; src=&quot;https://mmbiz.qlogo.cn/mmbiz_png/puJI9KpRbPWHSPQicfOCnYDx8S7VDY2P2Qn8VoLibtgkAuoDxMZmZGFalu9OCVeq6uKSbTCB7x72agcV05qic1eAQ/0?wx_fmt=png&quot; alt=&quot;img&quot;/&gt;</description>
<pubDate>Fri, 10 Jan 2020 15:37:00 +0000</pubDate>
<dc:creator>小李不秃</dc:creator>
<og:description>阅读本文大概需要 5.6 分钟 前言 在 Java 开发中，我们经常会提到 JVM。我们知道 JVM 是 Java 虚拟机，但是它的运行原理是什么？它的内存结构是什么？如何进行优化？如何去定位问题？面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ferryman/p/12178688.html</dc:identifier>
</item>
<item>
<title>投票：OAuth2.0 技术选型你会怎么选 - 码农小胖哥</title>
<link>http://www.cnblogs.com/felordcn/p/12178682.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/felordcn/p/12178682.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/Hea01a7018ebc445787a9789dde52b592p.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;在使用 &lt;strong&gt;OAuth2.0&lt;/strong&gt; 中 &lt;strong&gt;Authorization Server&lt;/strong&gt; （授权服务器）是一个回避不了的设施，在大多数情况下我们调用的是一些知名的、可靠的、可信任的第三方平台，比如 &lt;strong&gt;QQ、微信、微博、github&lt;/strong&gt; 等。我们的应用只作为 &lt;strong&gt;Client&lt;/strong&gt; 进行注册接入即可。也就是说我们只需要实现 &lt;strong&gt;OAuth2.0&lt;/strong&gt; 客户端的逻辑就可以了，无须关心授权服务器的实现。然而有时候我们依然希望构建自己的 &lt;strong&gt;Authorization Server&lt;/strong&gt;。我们应该如何实现？今天不会讨论具体的技术细节，来谈谈 &lt;strong&gt;OAuth2.0&lt;/strong&gt; 的技术选型。&lt;/p&gt;
&lt;h2 id=&quot;spring-security-oauth2-现状&quot;&gt;2. Spring Security OAuth2 现状&lt;/h2&gt;
&lt;p&gt;在做 &lt;a href=&quot;https://www.felord.cn/categories/spring-security/&quot; title=&quot;Spring Security 相关教程&quot;&gt;Spring Security 相关教程&lt;/a&gt; 的时候首先会考虑 &lt;strong&gt;Spring&lt;/strong&gt; 提供的 &lt;strong&gt;OAuth2.0&lt;/strong&gt; 功能。当我去 Spring 官网了解相关的类库时发现居然 &lt;strong&gt;Spring&lt;/strong&gt; 的 &lt;strong&gt;OAuth2.0&lt;/strong&gt; 类库即将过期的通知，有图有真相：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ae01.alicdn.com/kf/H4745701d08de44ccb4467afb62dabe7eV.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结以下就是 Spring Security OAuth 的模块即将过期，后续的功能已经迁移到 Spring Security 5.2.x 中，但是不会再提供 Authorization Server 的功能。&lt;/strong&gt; 在官方声明中还提到， 当前 &lt;strong&gt;Spring Security OAuth&lt;/strong&gt; 分支是 &lt;code&gt;2.3.x&lt;/code&gt; 和 &lt;code&gt;2.4.x&lt;/code&gt;。&lt;code&gt;2.3.x&lt;/code&gt;版本将于 2020 年 3 月寿命终止。我们将在达到功能均等后至少一年支持 2.4.x 版本。因此鼓励用户开始将其旧版 &lt;code&gt;OAuth 2.0&lt;/code&gt; 客户端和资源服务器应用程序迁移到&lt;strong&gt;Spring Security 5.2&lt;/strong&gt; 中的新支持。详细参见 &lt;a href=&quot;https://spring.io/blog/2019/11/14/spring-security-oauth-2-0-roadmap-update&quot; title=&quot;官方博客&quot;&gt;官方博客&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;对-oauth2.0-的技术选型&quot;&gt;3. 对 OAuth2.0 的技术选型&lt;/h2&gt;
&lt;p&gt;从上面的信息看来， &lt;strong&gt;Spring Security&lt;/strong&gt; 未来依然提供 &lt;strong&gt;OAuth2&lt;/strong&gt; 的 &lt;strong&gt;客户端支持&lt;/strong&gt; 和 &lt;strong&gt;资源服务器支持&lt;/strong&gt;。&lt;strong&gt;授权服务器&lt;/strong&gt; 将逐渐退出 &lt;strong&gt;Spring Security&lt;/strong&gt; 的生态环境。所以如果没有授权服务器需求的情况下选择 &lt;strong&gt;Spring Security&lt;/strong&gt; 依然是没有问题的，一旦有这个需求我们该如何选择？我这里调研了几个开源免费的项目。&lt;/p&gt;
&lt;h3 id=&quot;keycloak&quot;&gt;3.1 keycloak&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/keycloak/keycloak&quot; title=&quot;keycloak&quot;&gt;keycloak&lt;/a&gt;是 &lt;strong&gt;RedHat&lt;/strong&gt; 公司出品。是一个致力于解决应用和服务身份验证与访问管理的开源工具。可以通过简单的配置达到保护应用和服务的目的。它提供了身份和访问管理的有用功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单点登录（&lt;strong&gt;SSO&lt;/strong&gt;），身份代理和第三方登录。&lt;/li&gt;
&lt;li&gt;支持 &lt;strong&gt;OpenID Connect&lt;/strong&gt;，&lt;strong&gt;OAuth 2.0&lt;/strong&gt; 和 &lt;strong&gt;SAML 2.0&lt;/strong&gt; 等标准协议。&lt;/li&gt;
&lt;li&gt;用户集中管理。&lt;/li&gt;
&lt;li&gt;客户端适配器，轻松保护应用程序和服务。&lt;/li&gt;
&lt;li&gt;可视化管理控制台和帐户管理控制台。&lt;/li&gt;
&lt;li&gt;可扩展性、高性能、快速实现落地。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文档比较完毕，而且是一个成熟的、免费的商业级产品。&lt;/p&gt;
&lt;h3 id=&quot;nimbus-sdk&quot;&gt;3.2 Nimbus SDK&lt;/h3&gt;
&lt;p&gt;全称是 &lt;a href=&quot;https://connect2id.com/products/nimbus-oauth-openid-connect-sdk&quot; title=&quot;Nimbus OAuth 2.0 / OpenID Connect SDK&quot;&gt;Nimbus OAuth 2.0 / OpenID Connect SDK&lt;/a&gt;，这是一个类库。Spring 官方在博客中提到可以使用该类库构建 &lt;strong&gt;Authorization Server&lt;/strong&gt;，它同时支持 &lt;strong&gt;OAuth2.0&lt;/strong&gt; 和 &lt;strong&gt;OpenID Connect&lt;/strong&gt;，比较完整地实现了这两个协议，而且针对补充协议也在积极的跟进。缺点在于中文教程不多而且是一个类库性质的。不过官方提供了 &lt;strong&gt;DEMO&lt;/strong&gt; ，有能力的同学入门也不算难事。&lt;/p&gt;
&lt;h3 id=&quot;apache-oltu&quot;&gt;3.3 Apache Oltu&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/OLTU/Documentation&quot; title=&quot;Apache Oltu&quot;&gt;Apache Oltu&lt;/a&gt; 是 Apache 基金会旗下的一个毕业项目。提供了 &lt;strong&gt;OAuth2.0&lt;/strong&gt; 的常用实现，根据文档提供的信息来看上手还是比较简单的，模块化的提供了对 &lt;strong&gt;Authorization Server、Resource Server、Client、JOSE、&lt;/strong&gt; 的支持。中文教程网上还是有不少的，缺点在于项目维护比较滞后，最新的版本是 2016 年发布的。&lt;/p&gt;
&lt;h3 id=&quot;vertx-auth-oauth2&quot;&gt;3.4 Vertx-auth-oauth2&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://vertx.io/docs/vertx-auth-oauth2/java/&quot; title=&quot;vertx-auth-oauth2&quot;&gt;vertx-auth-oauth2&lt;/a&gt; 属于 &lt;strong&gt;Vert.x&lt;/strong&gt; 生态，提供了比较完整的 OAuth2.0 实现，而且项目维护比较活跃，唯一的缺点在于有技术栈的局限性。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;针对 &lt;strong&gt;Java&lt;/strong&gt; 的一些 &lt;strong&gt;OAuth2.0&lt;/strong&gt; 技术选型参考就是上面几个了。不知道你会选择哪一个？ 我在公众号：&lt;strong&gt;Felordcn&lt;/strong&gt; 发起了一个关于 &lt;strong&gt;OAuth2.0&lt;/strong&gt; 技术选型的投票，希望你能够参与。&lt;a href=&quot;https://mp.weixin.qq.com/s/vpUPPO7_19df7-xCnZMxXg&quot;&gt;投票传送门【复制链接到微信中打开投票】&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 Jan 2020 15:32:00 +0000</pubDate>
<dc:creator>码农小胖哥</dc:creator>
<og:description>1. 前言 在使用 OAuth2.0 中 Authorization Server （授权服务器）是一个回避不了的设施，在大多数情况下我们调用的是一些知名的、可靠的、可信任的第三方平台，比如 QQ、微</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/felordcn/p/12178682.html</dc:identifier>
</item>
<item>
<title>嵌入式开发10种常见数字滤波算法 - 半个圆</title>
<link>http://www.cnblogs.com/HalfCircle/p/44af2b4c5ec986a5a6e197889f9604c3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HalfCircle/p/44af2b4c5ec986a5a6e197889f9604c3.html</guid>
<description>&lt;p&gt;在单片机开发中，经常需要对输入的数据进行过滤处理，如传感器数据输出，AD采样等，合适的滤波处理能达到更好效果。下面分享几种较简单而常用的滤波算法：&lt;/p&gt;
&lt;hr/&gt;
&lt;a href=&quot;https://www.cnblogs.com/HalfCircle/p/44af2b4c5ec986a5a6e197889f9604c3.html#wizToc&quot;&gt;TOC&lt;/a&gt;
&lt;hr/&gt;&lt;h3 id=&quot;一、限幅滤波法（又称程序判断滤波法）&quot;&gt;一、限幅滤波法（又称程序判断滤波法）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;A、方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据经验判断，确定两次采样允许的最大偏差值（设为A）&lt;/li&gt;
&lt;li&gt;每次检测到新值时判断：&lt;/li&gt;
&lt;li&gt;如果本次值与上次值之差&amp;lt;=A,则本次值有效&lt;/li&gt;
&lt;li&gt;如果本次值与上次值之差&amp;gt;A,则本次值无效,放弃本次值,用上次值代替本次值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;B、优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;能有效克服因偶然因素引起的脉冲干扰&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;C、缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;无法抑制那种周期性的干扰&lt;/li&gt;
&lt;li&gt;平滑度差&lt;/li&gt;
&lt;/ol&gt;&lt;div data-mode=&quot;c&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code&gt;int Filter_Value;
int Value;

void setup() {
  Serial.begin(9600);       // 初始化串口通信
  randomSeed(analogRead(0)); // 产生随机种子
  Value = 300;
}

void loop() {
  Filter_Value = Filter();       // 获得滤波器输出值
  Value = Filter_Value;          // 最近一次有效采样的值，该变量为全局变量
  Serial.println(Filter_Value); // 串口输出
  delay(50);
}

// 用于随机产生一个300左右的当前值
int Get_AD() {
  return random(295, 305);
}

// 限幅滤波法（又称程序判断滤波法）
#define FILTER_A 1
int Filter() {
  int NewValue;
  NewValue = Get_AD();
  if(((NewValue - Value) &amp;gt; FILTER_A) || ((Value - NewValue) &amp;gt; FILTER_A))
    return Value;
  else
    return NewValue;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;二、中位值滤波法&quot;&gt;&lt;strong&gt;二、中位值滤波法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;A、方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连续采样N次（N取奇数）&lt;/li&gt;
&lt;li&gt;把N次采样值按大小排列&lt;/li&gt;
&lt;li&gt;取中间值为本次有效值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;B、优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;能有效克服因偶然因素引起的波动干扰&lt;/li&gt;
&lt;li&gt;对温度、液位的变化缓慢的被测参数有良好的滤波效果&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;C、缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;对流量、速度等快速变化的参数不宜&lt;/li&gt;
&lt;/ol&gt;&lt;div data-mode=&quot;c&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code&gt;/*  N值可根据实际情况调整排序采用冒泡法*/
#define N  11

char filter()
{
   char value_buf[N];
   char count,i,j,temp;
   for ( count=0;count&amp;lt;N;count++)
   {
      value_buf[count] =get_ad();
      delay();
   }
   for (j=0;j&amp;lt;N-1;j++)
   {
      for (i=0;i&amp;lt;N-j;i++)
      {
         if (value_buf&amp;gt;value_buf[i+1] )
         {
           temp = value_buf;
           value_buf = value_buf[i+1];
            value_buf[i+1] = temp;
         }
      }
   }
   return value_buf[(N-1)/2];
}  &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;三、算术平均滤波法&quot;&gt;&lt;strong&gt;三、算术平均滤波法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;A、方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连续取N个采样值进行算术平均运算&lt;/li&gt;
&lt;li&gt;N值较大时：信号平滑度较高，但灵敏度较低&lt;/li&gt;
&lt;li&gt;N值较小时：信号平滑度较低，但灵敏度较高&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;N值的选取：一般流量，N=12；压力：N=4&lt;br/&gt;&lt;strong&gt;B、优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;适用于对一般具有随机干扰的信号进行滤波&lt;/li&gt;
&lt;li&gt;这样信号的特点是有一个平均值，信号在某一数值范围附近上下波动&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;C、缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;对于测量速度较慢或要求数据计算速度较快的实时控制不适用&lt;/li&gt;
&lt;li&gt;比较浪费RAM&lt;/li&gt;
&lt;/ol&gt;&lt;div data-mode=&quot;c&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code&gt;#define N 12

char filter()
{
   int  sum = 0;
   for (count=0;count&amp;lt;N;count++)
   {
      sum + = get_ad();
      delay();
   }
   return (char)(sum/N);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;四、递推平均滤波法&quot;&gt;&lt;strong&gt;四、递推平均滤波法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;A、方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把连续取N个采样值看成一个队列&lt;/li&gt;
&lt;li&gt;队列的长度固定为N&lt;/li&gt;
&lt;li&gt;每次采样到一个新数据放入队尾,并扔掉原来队首的一次数据.(先进先出原则)&lt;/li&gt;
&lt;li&gt;把队列中的N个数据进行算术平均运算,就可获得新的滤波结果&lt;/li&gt;
&lt;li&gt;N值的选取：流量，N=12；压力：N=4；液面，N=4~12；温度，N=1~4&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;B、优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;对周期性干扰有良好的抑制作用，平滑度高&lt;/li&gt;
&lt;li&gt;适用于高频振荡的系统&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;C、缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;灵敏度低&lt;/li&gt;
&lt;li&gt;对偶然出现的脉冲性干扰的抑制作用较差&lt;/li&gt;
&lt;li&gt;不易消除由于脉冲干扰所引起的采样值偏差&lt;/li&gt;
&lt;li&gt;不适用于脉冲干扰比较严重的场合&lt;/li&gt;
&lt;li&gt;比较浪费RAM&lt;/li&gt;
&lt;/ol&gt;&lt;div data-mode=&quot;c&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code&gt;// 递推平均滤波法（又称滑动平均滤波法）
#define FILTER_N 12
int filter_buf[FILTER_N + 1];
int Filter() {
  int i;
  int filter_sum = 0;
  filter_buf[FILTER_N] = Get_AD();
  for(i = 0; i &amp;lt; FILTER_N; i++) {
    filter_buf[i] = filter_buf[i + 1]; // 所有数据左移，低位仍掉
    filter_sum += filter_buf[i];
  }
  return (int)(filter_sum / FILTER_N);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;五、中位值平均滤波法&quot;&gt;&lt;strong&gt;五、中位值平均滤波法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;A、方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;相当于“中位值滤波法”+“算术平均滤波法”&lt;/li&gt;
&lt;li&gt;连续采样N个数据，去掉一个最大值和一个最小值&lt;/li&gt;
&lt;li&gt;然后计算N-2个数据的算术平均值&lt;/li&gt;
&lt;li&gt;N值的选取：3~14&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;B、优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;融合了两种滤波法的优点&lt;/li&gt;
&lt;li&gt;对于偶然出现的脉冲性干扰，可消除由于脉冲干扰所引起的采样值偏差&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;C、缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;测量速度较慢，和算术平均滤波法一样&lt;/li&gt;
&lt;li&gt;比较浪费RAM&lt;/li&gt;
&lt;/ol&gt;&lt;div data-mode=&quot;c&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code&gt;// 中位值平均滤波法（又称防脉冲干扰平均滤波法）（算法1）
#define FILTER_N 100
int Filter() {
  int i, j;
  int filter_temp, filter_sum = 0;
  int filter_buf[FILTER_N];
  for(i = 0; i &amp;lt; FILTER_N; i++) {
    filter_buf[i] = Get_AD();
    delay(1);
  }
  // 采样值从小到大排列（冒泡法）
  for(j = 0; j &amp;lt; FILTER_N - 1; j++) {
    for(i = 0; i &amp;lt; FILTER_N - 1 - j; i++) {
      if(filter_buf[i] &amp;gt; filter_buf[i + 1]) {
        filter_temp = filter_buf[i];
        filter_buf[i] = filter_buf[i + 1];
        filter_buf[i + 1] = filter_temp;
      }
    }
  }
  // 去除最大最小极值后求平均
  for(i = 1; i &amp;lt; FILTER_N - 1; i++) filter_sum += filter_buf[i];
  return filter_sum / (FILTER_N - 2);
}


//  中位值平均滤波法（又称防脉冲干扰平均滤波法）（算法2）
#define FILTER_N 100
int Filter() {
  int i;
  int filter_sum = 0;
  int filter_max, filter_min;
  int filter_buf[FILTER_N];
  for(i = 0; i &amp;lt; FILTER_N; i++) {
    filter_buf[i] = Get_AD();
    delay(1);
  }
  filter_max = filter_buf[0];
  filter_min = filter_buf[0];
  filter_sum = filter_buf[0];
  for(i = FILTER_N - 1; i &amp;gt; 0; i--) {
    if(filter_buf[i] &amp;gt; filter_max)
      filter_max=filter_buf[i];
    else if(filter_buf[i] &amp;lt; filter_min)
      filter_min=filter_buf[i];
    filter_sum = filter_sum + filter_buf[i];
    filter_buf[i] = filter_buf[i - 1];
  }
  i = FILTER_N - 2;
  filter_sum = filter_sum - filter_max - filter_min + i / 2; // +i/2 的目的是为了四舍五入
  filter_sum = filter_sum / i;
  return filter_sum;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;六、限幅平均滤波法&quot;&gt;&lt;strong&gt;六、限幅平均滤波法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;A、方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;相当于“限幅滤波法”+“递推平均滤波法”&lt;/li&gt;
&lt;li&gt;每次采样到的新数据先进行限幅处理，&lt;/li&gt;
&lt;li&gt;再送入队列进行递推平均滤波处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;B、优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;融合了两种滤波法的优点&lt;/li&gt;
&lt;li&gt;对于偶然出现的脉冲性干扰，可消除由于脉冲干扰所引起的采样值偏差&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;C、缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;比较浪费RAM&lt;/li&gt;
&lt;/ol&gt;&lt;div data-mode=&quot;c&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code&gt;// 限幅平均滤波法
#define FILTER_A 1
int Filter() {
  int i;
  int filter_sum = 0;
  filter_buf[FILTER_N - 1] = Get_AD();
  if(((filter_buf[FILTER_N - 1] - filter_buf[FILTER_N - 2]) &amp;gt; FILTER_A) || ((filter_buf[FILTER_N - 2] - filter_buf[FILTER_N - 1]) &amp;gt; FILTER_A))
    filter_buf[FILTER_N - 1] = filter_buf[FILTER_N - 2];
  for(i = 0; i &amp;lt; FILTER_N - 1; i++) {
    filter_buf[i] = filter_buf[i + 1];
    filter_sum += filter_buf[i];
  }
  return (int)filter_sum / (FILTER_N - 1);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;七、一阶滞后滤波法&quot;&gt;&lt;strong&gt;七、一阶滞后滤波法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;A、方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;取a=0~1&lt;/li&gt;
&lt;li&gt;本次滤波结果=（1-a）&lt;em&gt;本次采样值+a&lt;/em&gt;上次滤波结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;B、优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;对周期性干扰具有良好的抑制作用&lt;/li&gt;
&lt;li&gt;适用于波动频率较高的场合&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;C、缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;相位滞后，灵敏度低&lt;/li&gt;
&lt;li&gt;滞后程度取决于a值大小&lt;/li&gt;
&lt;li&gt;不能消除滤波频率高于采样频率的1/2的干扰信号&lt;/li&gt;
&lt;/ol&gt;&lt;div data-mode=&quot;c&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code&gt;// 一阶滞后滤波法
#define FILTER_A 0.01
int Filter() {
  int NewValue;
  NewValue = Get_AD();
  Value = (int)((float)NewValue * FILTER_A + (1.0 - FILTER_A) * (float)Value);
  return Value;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;八、加权递推平均滤波法&quot;&gt;&lt;strong&gt;八、加权递推平均滤波法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;A、方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是对递推平均滤波法的改进，即不同时刻的数据加以不同的权&lt;/li&gt;
&lt;li&gt;通常是，越接近现时刻的数据，权取得越大。&lt;/li&gt;
&lt;li&gt;给予新采样值的权系数越大，则灵敏度越高，但信号平滑度越低&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;B、优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;适用于有较大纯滞后时间常数的对象&lt;/li&gt;
&lt;li&gt;和采样周期较短的系统&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;C、缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;对于纯滞后时间常数较小，采样周期较长，变化缓慢的信号&lt;/li&gt;
&lt;li&gt;不能迅速反应系统当前所受干扰的严重程度，滤波效果差&lt;/li&gt;
&lt;/ol&gt;&lt;div data-mode=&quot;c&quot; readability=&quot;21&quot;&gt;
&lt;pre&gt;
&lt;code&gt;// 加权递推平均滤波法
#define FILTER_N 12
int coe[FILTER_N] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};    // 加权系数表
int sum_coe = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12; // 加权系数和
int filter_buf[FILTER_N + 1];
int Filter() {
  int i;
  int filter_sum = 0;
  filter_buf[FILTER_N] = Get_AD();
  for(i = 0; i &amp;lt; FILTER_N; i++) {
    filter_buf[i] = filter_buf[i + 1]; // 所有数据左移，低位仍掉
    filter_sum += filter_buf[i] * coe[i];
  }
  filter_sum /= sum_coe;
  return filter_sum;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;九、消抖滤波法&quot;&gt;&lt;strong&gt;九、消抖滤波法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;A、方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置一个滤波计数器&lt;/li&gt;
&lt;li&gt;将每次采样值与当前有效值比较：&lt;/li&gt;
&lt;li&gt;如果采样值＝当前有效值，则计数器清零&lt;/li&gt;
&lt;li&gt;如果采样值&amp;lt;&amp;gt;当前有效值，则计数器+1，并判断计数器是否&amp;gt;=上限N(溢出)&lt;/li&gt;
&lt;li&gt;如果计数器溢出,则将本次值替换当前有效值,并清计数器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;B、优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;对于变化缓慢的被测参数有较好的滤波效果,&lt;/li&gt;
&lt;li&gt;可避免在临界值附近控制器的反复开/关跳动或显示器上数值抖动&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;C、缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;对于快速变化的参数不宜&lt;/li&gt;
&lt;li&gt;如果在计数器溢出的那一次采样到的值恰好是干扰值,则会将干扰值当作有效值导入系统&lt;/li&gt;
&lt;/ol&gt;&lt;div data-mode=&quot;c&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code&gt;// 消抖滤波法
#define FILTER_N 12
int i = 0;
int Filter() {
  int new_value;
  new_value = Get_AD();
  if(Value != new_value) {
    i++;
    if(i &amp;gt; FILTER_N) {
      i = 0;
      Value = new_value;
    }
  }
  else
    i = 0;
  return Value;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;十、限幅消抖滤波法&quot;&gt;&lt;strong&gt;十、限幅消抖滤波法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;A、方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;相当于“限幅滤波法”+“消抖滤波法”&lt;/li&gt;
&lt;li&gt;先限幅,后消抖&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;B、优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;继承了“限幅”和“消抖”的优点&lt;/li&gt;
&lt;li&gt;改进了“消抖滤波法”中的某些缺陷,避免将干扰值导入系统&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;C、缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;wiz-list-level1&quot;&gt;&lt;li&gt;对于快速变化的参数不宜&lt;/li&gt;
&lt;/ol&gt;&lt;div data-mode=&quot;c&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code&gt;// 限幅消抖滤波法
#define FILTER_A 1
#define FILTER_N 5
int i = 0;
int Filter() {
  int NewValue;
  int new_value;
  NewValue = Get_AD();
  if(((NewValue - Value) &amp;gt; FILTER_A) || ((Value - NewValue) &amp;gt; FILTER_A))
    new_value = Value;
  else
    new_value = NewValue;
  if(Value != new_value) {
    i++;
    if(i &amp;gt; FILTER_N) {
      i = 0;
      Value = new_value;
    }
  }
  else
    i = 0;
  return Value;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;




</description>
<pubDate>Fri, 10 Jan 2020 15:22:00 +0000</pubDate>
<dc:creator>半个圆</dc:creator>
<og:description>在单片机开发中，经常需要对输入的数据进行过滤处理，如传感器数据输出，AD采样等，合适的滤波处理能达到更好效果。下面分享几种较简单而常用的滤波算法： 一、限幅滤波法（又称程序判断滤波法）二、中位值滤波法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/HalfCircle/p/44af2b4c5ec986a5a6e197889f9604c3.html</dc:identifier>
</item>
<item>
<title>如何实现一个短链接服务 - rickiyang</title>
<link>http://www.cnblogs.com/rickiyang/p/12178644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rickiyang/p/12178644.html</guid>
<description>&lt;p&gt;短链接，通俗来说，就是将长的URL网址，通过程序计算等方式，转换为简短的网址字符串。&lt;/p&gt;
&lt;p&gt;大家经常会收到一些莫名的营销短信，里面有一个非常短的链接让你跳转。新浪微博因为限制字数，所以也会经常见到这种看着不像网址的网址。短链的兴起应该就是微博限制字数激起了大家的创造力。&lt;/p&gt;
&lt;p&gt;如果创建一个短链系统，我们应该做什么呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将长链接变为短链；&lt;/li&gt;
&lt;li&gt;用户访问短链接，会跳转到正确的长链接上去。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;查找到对应的长网址，并跳转到对应的页面。&lt;/p&gt;
&lt;h4 id=&quot;短链生成方法&quot;&gt;短链生成方法&lt;/h4&gt;
&lt;p&gt;短码一般是由 &lt;code&gt;[a - z, A - Z, 0 - 9]&lt;/code&gt; 这62 个字母或数字组成，短码的长度也可以自定义，但一般不超过8位。比较常用的都是6位，6位的短码已经能有568亿种的组合：(26+26+10)^6 = 56800235584，已满足绝大多数的使用场景。&lt;/p&gt;
&lt;p&gt;目前比较流行的生成短码方法有：&lt;code&gt;自增id&lt;/code&gt;、&lt;code&gt;摘要算法&lt;/code&gt;、&lt;code&gt;普通随机数&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;自增id&quot;&gt;自增id&lt;/h5&gt;
&lt;p&gt;该方法是一种无碰撞的方法，原理是，每新增一个短码，就在上次添加的短码id基础上加1，然后将这个10进制的id值，转化成一个62进制的字符串。&lt;/p&gt;
&lt;p&gt;一般利用数据表中的自增id来完成：每次先查询数据表中的自增id最大值max，那么需要插入的长网址对应自增id值就是 max+1，将max+1转成62进制即可得到短码。&lt;/p&gt;
&lt;p&gt;但是短码 id 是从一位长度开始递增，短码的长度不固定，不过可以用 id 从指定的数字开始递增的方式来处理，确保所有的短码长度都一致。同时，生成的短码是有序的，可能会有安全的问题，可以将生成的短码id，结合长网址等其他关键字，进行md5运算生成最后的短码。&lt;/p&gt;
&lt;h5 id=&quot;摘要算法&quot;&gt;摘要算法&lt;/h5&gt;
&lt;p&gt;摘要算法又称哈希算法，它表示输入任意长度的数据，输出固定长度的数据。相同的输入数据始终得到相同的输出，不同的输入数据尽量得到不同的输出。&lt;/p&gt;
&lt;p&gt;算法过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将长网址md5生成32位签名串,分为4段, 每段8个字节；&lt;/li&gt;
&lt;li&gt;对这四段循环处理, 取8个字节, 将他看成16进制串与0x3fffffff(30位1)与操作, 即超过30位的忽略处理；&lt;/li&gt;
&lt;li&gt;这30位分成6段, 每5位的数字作为字母表的索引取得特定字符, 依次进行获得6位字符串；&lt;/li&gt;
&lt;li&gt;总的md5串可以获得4个6位串；取里面的任意一个就可作为这个长url的短url地址；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种算法,虽然会生成4个,但是仍然存在重复几率。&lt;/p&gt;
&lt;p&gt;虽然几率很小，但是该方法依然存在碰撞的可能性，解决冲突会比较麻烦。不过该方法生成的短码位数是固定的，也不存在连续生成的短码有序的情况。&lt;/p&gt;
&lt;h5 id=&quot;普通随机数&quot;&gt;普通随机数&lt;/h5&gt;
&lt;p&gt;该方法是从62个字符串中随机取出一个6位短码的组合，然后去数据库中查询该短码是否已存在。如果已存在，就继续循环该方法重新获取短码，否则就直接返回。&lt;/p&gt;
&lt;p&gt;该方法是最简单的一种实现，不过由于&lt;code&gt;Math.round()&lt;/code&gt;方法生成的随机数属于伪随机数，碰撞的可能性也不小。在数据比较多的情况下，可能会循环很多次，才能生成一个不冲突的短码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上算法利弊我们一个一个来分析。&lt;/p&gt;
&lt;p&gt;如果使用自增id算法，会有一个问题就是不法分子是可以穷举你的短链地址的。原理就是将10进制数字转为62进制，那么别人也可以使用相同的方式遍历你的短链获取对应的原始链接。打个比方说：http://tinyurl.com/a3300和 http://bit.ly/a3300，这两个短链网站，分别从a3300 - a3399，能够试出来多次返回正确的url。所以这种方式生成的短链对于使用者来说其实是不安全的。&lt;/p&gt;
&lt;p&gt;摘要算法，其实就是hash算法吧，一说hash大家可能觉得很low，但是事实上hash可能是最优解。比如：http://www.sina.lt/ 和 http://mrw.so/ 连续生成的url发现并没有规律，很有可能就是使用hash算法来实现。&lt;/p&gt;
&lt;p&gt;普通随机数算法，这种算法生成的东西和摘要算法一样，但是碰撞的概率会大一些。因为摘要算法毕竟是对url进行hash生成，随机数算法就是简单的随机生成，数量一旦上来必然会导致重复。&lt;/p&gt;
&lt;p&gt;综合以上，我选择最low的算法：摘要算法。&lt;/p&gt;
&lt;h5 id=&quot;实现&quot;&gt;实现&lt;/h5&gt;
&lt;h6 id=&quot;存储方案&quot;&gt;存储方案&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;数据库存储方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;短网址基础数据采用域名和后缀分开存储的形式。另外域名需要区分 HTTP 和 HTTPS，hash方案针对整个链接进行hash而不是除了域名外的链接。域名单独保存可以用于分析当前域名下链接的使用情况。&lt;/p&gt;
&lt;p&gt;增加当前链接有效期字段，一般有短链需求的可能是相关活动或者热点事件，这种短链在一段时间内会很活跃，过了一定时间热潮会持续衰退。所以没有必要将这种链接永久保存增加每次查询的负担。&lt;/p&gt;
&lt;p&gt;对于过期数据的处理，可以在新增短链的时候判断当前短链的失效日期，将每天到达失效日期的数据在HBase单独建一张表，有新增的时候判断失效日期放到对应的HBase表中即可，每天只用处理当天HBase表中的失效数据。&lt;/p&gt;
&lt;p&gt;数据库基础表如下:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;http://www.aichacha.com&lt;/td&gt;
&lt;td&gt;/search/12345&lt;/td&gt;
&lt;td&gt;edfg3s&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;http://www.aichacha.com//search/12345&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;http://www.aichacha.com&lt;/td&gt;
&lt;td&gt;/aiCheck/getResult/123&lt;/td&gt;
&lt;td&gt;Fe9dq&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;http://www.aichacha.com//aiCheck/getResult/123&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;http://www.baidu.com&lt;/td&gt;
&lt;td&gt;/wenku/12354&lt;/td&gt;
&lt;td&gt;lcfr53&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;http://www.baidu.com/wenku/12354&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;字段释义：&lt;/p&gt;
&lt;p&gt;base_url：域名&lt;/p&gt;
&lt;p&gt;suffix_url：链接除了域名外的后缀&lt;/p&gt;
&lt;p&gt;full_url：完整链接&lt;/p&gt;
&lt;p&gt;shot_code：当前 suffix_url 链接的短码&lt;/p&gt;
&lt;p&gt;expiration_date：失效日期&lt;/p&gt;
&lt;p&gt;total_click_count：当前链接总点击次数&lt;/p&gt;
&lt;p&gt;expiration_date：当前链接失效时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存方案&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查询需求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;个人认为对于几百个G的数据量都放在缓存肯定是不合适的，所以有个折中的方案：将最近3个月内有查询或者有新增的url放入缓存，使用LRU算法进行热更新。这样最近有使用的发概率会命中缓存，就不用走库。查不到的时候再走库更新缓存。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新增需求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于新增的链接就先查缓存是否存在，缓存不存在再查库，数据库已经分表了，查询的效率也不会很低。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存的设计&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;查询的需求是用户拿着短链查询对应的真实地址，那么缓存的key只能是短链，可以使用 KV的形式存储。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;番外&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实也可以考虑别的存储方案，比如HBase，HBase作为NOSQL数据库，性能上仅次于redis但是存储成本比redis低很多个数量级，存储基于HDFS，写数据的时候会先先写入内存中，只有内存满了会将数据刷入到HFile。读数据也会快，原因是因为它使用了LSM树型结构，而不是B或B+树。HBase会将最近读取的数据使用LRU算法放入缓存中，如果想增强读能力，可以调大blockCache。&lt;/p&gt;
&lt;p&gt;其次，也可以使用ElasticSearch，合适的索引规则效果不输缓存方案。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;是否有分库分表的需要？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于单条数据10b以内，一亿条数据总容量大约为 953G，单表肯定无法撑住这么大的量，所以有分表的需要，如果你对服务很有信心2年内能达到这个规模，那么你可以从一开始设计就考虑分表的方案。&lt;/p&gt;
&lt;p&gt;那么如何定义分表的规则呢？&lt;/p&gt;
&lt;p&gt;如果按照单表500万条记录来算，总计可以分为20张表，那么单表容量就是47G，还是挺大，所以考虑分表的 key 和单表容量，如果分为100张表那么单表容量就是10G，并且通过数字后缀路由到表中也比较容易。可以对short_code 做encoding编码生成数字类型然后做路由。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何转跳&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们在浏览器里输入 http://bit.ly/a3300 时&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DNS首先解析获得 http://bit.ly的 &lt;code&gt;IP&lt;/code&gt; 地址&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;DNS&lt;/code&gt; 获得 &lt;code&gt;IP&lt;/code&gt; 地址以后（比如：12.34.5.32），会向这个地址发送 &lt;code&gt;HTTP&lt;/code&gt; &lt;code&gt;GET&lt;/code&gt; 请求，查询短码 &lt;code&gt;a3300&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[http://bit.ly 服务器会通过短码 &lt;code&gt;a3300&lt;/code&gt; 获取对应的长 URL&lt;/li&gt;
&lt;li&gt;请求通过 &lt;code&gt;HTTP&lt;/code&gt; &lt;code&gt;301&lt;/code&gt; 转到对应的长 URL http://www.theaustralian.news.com.au/story/0,25197,26089617-5013871,00.html。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里有个小的知识点，为什么要用 301 跳转而不是 302 呐？&lt;/p&gt;
&lt;p&gt;知识点：为什么要使用302跳转，而不是301跳转呢？&lt;/p&gt;
&lt;blockquote readability=&quot;10.734406438632&quot;&gt;
&lt;p&gt;301是永久重定向，302是临时重定向。短地址一经生成就不会变化，所以用301是符合http语义的。但是如果用了301， Google，百度等搜索引擎，搜索的时候会直接展示真实地址，那我们就无法统计到短地址被点击的次数了，也无法收集用户的Cookie, User Agent 等信息，这些信息可以用来做很多有意思的大数据分析，也是短网址服务商的主要盈利来源。&lt;/p&gt;
&lt;p&gt;引自知乎-武林的回答，&lt;a href=&quot;https://www.zhihu.com/question/20103344/answer/573638467&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;附上两个算法：&lt;/p&gt;
&lt;p&gt;摘要算法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import org.apache.commons.lang3.StringUtils;

import javax.xml.bind.DatatypeConverter;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.concurrent.atomic.AtomicLong;

import static com.alibaba.fastjson.util.IOUtils.DIGITS;

/**
 * @author rickiyang
 * @date 2020-01-07
 * @Desc TODO
 */
public class ShortUrlGenerator {

    public static void main(String[] args) {
        String sLongUrl = &quot;http://www.baidu.com/121244/ddd&quot;;
        for (String shortUrl : shortUrl(sLongUrl)) {
            System.out.println(shortUrl);
        }
    }

    public static String[] shortUrl(String url) {
        // 可以自定义生成 MD5 加密字符传前的混合 KEY
        String key = &quot;dwz&quot;;
        // 要使用生成 URL 的字符
        String[] chars = new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;,
                &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;,
                &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;,
                &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;,
                &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;,
                &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;
        };
        // 对传入网址进行 MD5 加密
        String sMD5EncryptResult = &quot;&quot;;
        try {
            MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
            md.update((key + url).getBytes());
            byte[] digest = md.digest();
            sMD5EncryptResult = DatatypeConverter.printHexBinary(digest).toUpperCase();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }

        String[] resUrl = new String[4];
        //得到 4组短链接字符串
        for (int i = 0; i &amp;lt; 4; i++) {
            // 把加密字符按照 8 位一组 16 进制与 0x3FFFFFFF 进行位与运算
            String sTempSubString = sMD5EncryptResult.substring(i * 8, i * 8 + 8);
            // 这里需要使用 long 型来转换，因为 Inteper .parseInt() 只能处理 31 位 , 首位为符号位 , 如果不用 long ，则会越界
            long lHexLong = 0x3FFFFFFF &amp;amp; Long.parseLong(sTempSubString, 16);
            String outChars = &quot;&quot;;
            //循环获得每组6位的字符串
            for (int j = 0; j &amp;lt; 6; j++) {
                // 把得到的值与 0x0000003D 进行位与运算，取得字符数组 chars 索引(具体需要看chars数组的长度   以防下标溢出，注意起点为0)
                long index = 0x0000003D &amp;amp; lHexLong;
                // 把取得的字符相加
                outChars += chars[(int) index];
                // 每次循环按位右移 5 位
                lHexLong = lHexLong &amp;gt;&amp;gt; 5;
            }
            // 把字符串存入对应索引的输出数组
            resUrl[i] = outChars;
        }
        return resUrl;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数字转为base62算法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * @author rickiyang
 * @date 2020-01-07
 * @Desc TODO
 * &amp;lt;p&amp;gt;
 * 进制转换工具，最大支持十进制和62进制的转换
 * 1、将十进制的数字转换为指定进制的字符串；
 * 2、将其它进制的数字（字符串形式）转换为十进制的数字
 */
public class NumericConvertUtils {

    public static void main(String[] args) {
        String str = toOtherNumberSystem(22, 62);
        System.out.println(str);
    }


    /**
     * 在进制表示中的字符集合，0-Z分别用于表示最大为62进制的符号表示
     */
    private static final char[] digits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
            'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};

    /**
     * 将十进制的数字转换为指定进制的字符串
     *
     * @param number 十进制的数字
     * @param seed   指定的进制
     * @return 指定进制的字符串
     */
    public static String toOtherNumberSystem(long number, int seed) {
        if (number &amp;lt; 0) {
            number = ((long) 2 * 0x7fffffff) + number + 2;
        }
        char[] buf = new char[32];
        int charPos = 32;
        while ((number / seed) &amp;gt; 0) {
            buf[--charPos] = digits[(int) (number % seed)];
            number /= seed;
        }
        buf[--charPos] = digits[(int) (number % seed)];
        return new String(buf, charPos, (32 - charPos));
    }

    /**
     * 将其它进制的数字（字符串形式）转换为十进制的数字
     *
     * @param number 其它进制的数字（字符串形式）
     * @param seed   指定的进制，也就是参数str的原始进制
     * @return 十进制的数字
     */
    public static long toDecimalNumber(String number, int seed) {
        char[] charBuf = number.toCharArray();
        if (seed == 10) {
            return Long.parseLong(number);
        }

        long result = 0, base = 1;

        for (int i = charBuf.length - 1; i &amp;gt;= 0; i--) {
            int index = 0;
            for (int j = 0, length = digits.length; j &amp;lt; length; j++) {
                //找到对应字符的下标，对应的下标才是具体的数值
                if (digits[j] == charBuf[i]) {
                    index = j;
                }
            }
            result += index * base;
            base *= seed;
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 10 Jan 2020 15:19:00 +0000</pubDate>
<dc:creator>rickiyang</dc:creator>
<og:description>短链接服务实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rickiyang/p/12178644.html</dc:identifier>
</item>
<item>
<title>你真的看懂Android事件分发了吗？ - Jymoon</title>
<link>http://www.cnblogs.com/jymblog/p/12178527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jymblog/p/12178527.html</guid>
<description>&lt;h3 id=&quot;引子&quot;&gt;引子&lt;/h3&gt;
&lt;p&gt;Android事件分发其实是老生常谈了，但是说实话，我觉得很多人都只是懂其大概，模棱两可。本文的目的就是再次从源码层次梳理一下，重点放在ViewGroup的dispatchTouchEvent方法上，这个方法是事件分发的核心中的核心！我们借此以小见大，理解事件分发的机制。ps，本文着重在源码和分析，就不怎么画图了(其实是懒)，大家可以看网上相关图片，随便一搜很多。&lt;/p&gt;
&lt;h3 id=&quot;先简单讲一下事件分发的源头&quot;&gt;先简单讲一下事件分发的源头&lt;/h3&gt;
&lt;p&gt;很多人讲事件分发，都说其开始是从Activity的dispatchTouchEvent开始的，大家可以简单这么理解，但是肯定会有人疑问，Activity的这个方法从哪儿调用的呢？我写了一个简单的Demo，然后在Activity的dispatchTouchEvent方法里加了一个断点得到其函数调用栈，看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2573909-c5284b00bc64c24d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;stack.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好家伙，原来Activity分发之前还有这么多过程，简单梳理了一下：大概是从InputEventReceiver开始，经过ViewRootImpl，里面各种InputStage调用之后，最后给了DecorView，然后DecorView传给的Activity。其实这里挺有意思的，本来DecorView先获取到事件的，但是后来它又分配给了Activity，Activity之后又通过phoneWindow把事件传回给了DecorView，一来一回，就是为了让Activity去处理一下事件而已。Activity传给DecorView之后，DecorView会调用&lt;code&gt;superDispatchTouchEvent&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public boolean superDispatchTouchEvent(MotionEvent event){
        return super.dispatchTouchEvent(event);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为DecorView是一个FrameLayout，它最终还是调用了我们熟悉的ViewGroup的dispatchTouchEvent()，这也是本文的主角。所谓的事件分发，本质上就是一个递归函数的调用，这个递归函数就是dispatchTouchEvent，至于onIntercepterTouchEvent，onTouchEvent，OnTouchListener，onClickListener...balabala都是在这个递归函数里面的操作而已，最核心，最骨干的还是dispatchTouchEvent，所以我们来分析它：&lt;/p&gt;
&lt;h3 id=&quot;viewgroup的事件分发&quot;&gt;ViewGroup的事件分发&lt;/h3&gt;
&lt;p&gt;大家应该或多或少读过其源码，源码虽然不是太长，但乍一看还是会头大的，我想大多数人可能大概看懂了其逻辑，对于里面很多东西不明所以。比如mFirstTouchTarget是干嘛的？临时变量alreadyDispatchedToNewTouchTarget是干嘛的？里面好像有链表啊，干嘛使的？&lt;/p&gt;
&lt;p&gt;这里稍微补充一句，对于事件分发来说，从用户按下到抬起，这是一组事件，以ACTION_DOWN为开头，UP或CANCEL结束。我们后面分析的也是这一组事件。&lt;/p&gt;
&lt;p&gt;源码较长，我写了伪代码给大家看看，说是伪代码，其实还是比较全面详细的，省略了部分函数参数，但重点的代码都包含了，重点看注释。如果嫌长，可以直接先看后面的结论，再回头看伪代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//本源码来自 api 28,不同版本略有不同。
public boolean dispatchTouchEvent(MotionEvent ev) {
    // 第一步：处理拦截
   boolean intercepted;  
     // 注意这个条件，后面会讲
   if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
    // 子view调用了parent.requestDisallowInterceptTouchEvent干预父布局的拦截，不让它爸拦截它
       final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
       if (!disallowIntercept) {
             intercepted = onInterceptTouchEvent(ev);
             ev.setAction(action); 
         } else {
             intercepted = false;
         }
     } else {
        //既不是DOWN事件，mFirstTouchTarget还是null，这种情况挺常见：如果ViewGroup的所有的子View都不消费                //事件，那么当ACTION_MOVE等非DOWN事件到来时，都被拦截了。
         intercepted = true;
     }

    // 第二步，分发ACTION_DOWN
    boolean handled = false;
    boolean alreadyDispatchedToNewTouchTarget = false; //注意这个变量,会用到
   // 不拦截才会分发它，如果拦截了，就不分发ACTION_DOWN了
    if (!intercepted) {
        //处理DOWN事件，捕获第一个被触摸的mFirstTouchTarget，mFirstTouchTarget很重要，
        保存了消费了ACTION_DOWN事件的子view
        if (ev.getAction == MotionEvent.ACTION_DOWN) {
            //遍历所有子view(看源码知子View是按照Z轴排好序的)
            for (int i = childrenCount - 1; i &amp;gt;= 0; i--) {
                //子view如果：1.不包含事件坐标 2. 在动画  则跳过
                if (!isTransformedTouchPointInView() || !canViewReceivePointerEvents()) {
                    continue;
                }
                //将事件传递给子view的坐标空间，并且判断该子view是否消费这个触摸事件（分发Down事件）
                if (dispatchTransformedTouchEvent()) {
                    //将该view加入头节点，并且赋值给mFirstTouchTarget
                    newTouchTarget = addTouchTarget(child, idBitsToAssign);
                    alreadyDispatchedToNewTouchTarget = true;
                }

            }
        }
    }

        //第三步：分发非DOWN事件
        //如果没有子view捕获ACTION_DOWN，则交给本ViewGroup处理这个事件。我们看到，这里并没有判断是否拦截，
        //为什么呢？因为如果拦截的话，上面的代码不会执行，就会导致mFirstTouchTarget== null，于是就走下面第一                         //个条件里的逻辑了
        if (mFirstTouchTarget == null) {
            super.dispatchTouchEvent(ev); //调用View的dispatchTouchEvent，也就是自己处理
        } else {
            //遍历touchTargets链表，依次分发事件
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                if (alreadyDispatchedToNewTouchTarget) {
                  handled = true
                } else {
                    if (dispatchTransformedTouchEvent()) {
                      handled = true;
                    }
                  target = target.next;
                }
            }
        }

        //处理ACTION_UP和CANCEL，手指抬起来以后相关变量重置
        if (ev.getAction == MotionEvent.ACTION_UP) {
            reset();
        }
    }
    return handled;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结一下：ViewGroup事件分发分为三步&lt;/p&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;第一步：判断要不要拦截：这里的条件分支要看清，外层的判断语句意思是，&lt;strong&gt;要么肯定会拦截，要么可能不拦截，可能不拦截的话需要满足以下两个条件之一：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;事件是DOWN事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;非DOWN事件也可以，但是需要满足mFirstTouchTarget != null 。这个条件意味着什么呢？意味着在之前的DOWN事件中，至少有一个子View捕获(消费)了DOWN事件，也就是意味着对于这一组分发事件来说，有子View愿意处理这个事件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在可能拦截的情况下，我们进入拦截判断流程，很简单： 先看子view有没有调parent.requestDisallowIntercept，如果调用了，不拦截，没有的话走到onIntercepteTouchEvent方法，根据其返回值决定是否拦截。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第二步：如果没有拦截，分发DOWN事件：遍历所有子View，查看触摸区域是否有子view有资格消费这个事件，判断依据有二：子View是否有动画？以及触摸点是否落在子View的范围内。如果前两者都满足，则将DOWN事件分发给子View，这一步引出了一个重要的方法：&lt;code&gt;dispatchTransformedTouchEvent&lt;/code&gt; ，这个方法干的活就是最重要的事情：分发给子view，也就是说，这个方法进行了递归的调用，感兴趣的同学可以自己阅读其源码。另外，这个分发方法有个返回值，如果为true，则为mFirstTouchTarget赋值，否则其值仍为null。这一步最后有个方法，addTouchTarget，这个方法牵扯到了链表的构建，链表保存的什么呢？其实对于任何一个事件的位置坐标，屏幕上可能有多个View都包含了该坐标，分发事件的时候必然要让所有这些View都分发一遍，这些被分发的View就被保存到一个链表当中，方便后面的遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第三步：分发其他事件：首先判断mFirstTouchTarget，如果为null，说明前一步的DOWN事件没有子view消费掉，这种情况表示该ViewGroup的孩子View都不打算处理事件，这种情况自然要交给ViewGroup自身处理，代码里交给了super.dispatchTouchEvent，也就是调用了ViewGroup的父类View处理(onTouchEvent)。如果不为null，说明有子View要处理事件，进入else语句里，把事件分发下去。 这里眼尖的读者应该看到了，第二步不会已经分发了DOWN事件了吗，这里为啥还要再分发一次呢？不重复了吗，这里就到了前面讲的另外一个变量出场了，&lt;code&gt;alreadyDispatchedToNewTouchTarget&lt;/code&gt;，这个变量在伪代码里第二步的开头提到了，当第二步里有子View消费了事件后，该变量会变成true，此时第三步会判断该值，如果为true，就直接返回handle=true，不再分发事件了。这就避免了DOWN事件被两次分发。对于其他事件，这个变量肯定是false，所以一定会走else的逻辑，进行分发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在浓缩一下，加点大白话：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public boolean dispatchTouchEvent(MotionEvent event) {

        boolean intercepted = false;
        if (DOWN 或者 DOWN的时候没有孩子想处理) {
            if (孩子不让拦截？) {
                intercepted = false;
            } else {
                intercepted = onIntercept();
            }
        } else {
          intercepted = true;
        }

        if (DOWN &amp;amp;&amp;amp; !intercepted) {
            for (遍历孩子View) {
                if（如果该孩子能消费就给分发给它，如果它真消费了DOWN事件）{
                    给mFirstTouchTarget赋值 ;
                    Down事件已经分发了;
                }
            }
        }

        if (mFirstTouchTarget == null) {
            孩子都不想消费，交给我自己处理吧;
        } else {
            while(遍历所有孩子，将事件分发下去) {
                if (DOWN事件已经分发了) {
                    return true;
                }else {
                    分发给子View，如果有人消费，返回true;
                }
            }
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，我们就把ViewGroup的事件分发讲完了，接下来分析一下View的dispatchTouchEvent&lt;/p&gt;
&lt;h3 id=&quot;view的事件分发&quot;&gt;View的事件分发&lt;/h3&gt;
&lt;p&gt;View的非常简单&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent event) {
    boolean result = false;
    if (onTouchListener.onTouch()) {
        result = true;
    }
    if (!result &amp;amp;&amp;amp; onTouchEvent()) {
        result = true;
    }
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，先判断listener，如果listener返回true了，onTouchEvent就不进入了，否则，走onTouchEvent方法。&lt;/p&gt;
&lt;p&gt;View的复杂点的地方在onTouchEvent方法的默认实现里，里面处理了很多onClick,onLongclick事件的逻辑，感兴趣的同学可以自行阅读源码，这里只说一点，一旦设置了onClickListener或者onLongclickListener，那么onTouchEvent就会返回true，也就是消费，其他情况下默认不消费，源码里这么写的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        final boolean clickable = ((viewFlags &amp;amp; CLICKABLE) == CLICKABLE
                || (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags &amp;amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;clickable为true，则返回true，否则返回false。&lt;/p&gt;
&lt;h3 id=&quot;举个例子练习一下&quot;&gt;举个例子练习一下&lt;/h3&gt;
&lt;p&gt;问题很简单，一个FrameLayout中间放了一个按钮，Framelayout和按钮都添加了点击事件，那么，请问点击按钮和点击按钮之外的区域事件分发过程是怎样的？&lt;/p&gt;
&lt;p&gt;先看按钮之外： FrameLayout是一个ViewGroup，而且没有重写dispatchTouchEvent方法。根据以上分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步，down来了以后，进入拦截逻辑，framelayout不拦截，所以intercepted == false&lt;/li&gt;
&lt;li&gt;第二步，处理down事件，发现触摸点没有子view，所以不会有人处理这个事件的，mFirstTouchTarget == null&lt;/li&gt;
&lt;li&gt;第三步，交给自身处理，自身会调用onTouchEvent，在这里由于设置了clickListener，返回true，消费了事件。&lt;/li&gt;
&lt;li&gt;后续move和up，由于mFirstTouchTarget == null，第一步会拦截，所以直接交给自身处理，同上面的第三步，同时，up的时候会响应click事件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按钮内：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步，同上&lt;/li&gt;
&lt;li&gt;第二步， 发现触摸点有子view，mFirstTouchTarget != null，且将DOWN事件分发给了子View。&lt;/li&gt;
&lt;li&gt;第三步，mFirstTouchTarget非null，但&lt;code&gt;alreadyDispatchedToNewTouchTarget&lt;/code&gt;这个变量为true，所以直接返回true。&lt;/li&gt;
&lt;li&gt;后续move和up，第一步不会拦截，因为不是down事件所以第二步跳过，第三步将事件分发给了子View，子View响应了点击事件，返回true，而这个过程中，ViewGroup没有消费任何事件，所以自然不会响应onClick事件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样，是不是就解释了两层View都添加click事件时的响应结果了～&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;用的来说，事件分发分两步，拦截和分发，其中分发有两种情况，Down事件和非&lt;br/&gt;Down事件，down事件是事件链的起点，决定了要不要消费事件，会影响后续的所有非down事件的分发，如果down事件不消费，会使得mFirstTouchTarget为null，后面的所有事件就不再分发给子view了，直接由本view group处理。&lt;br/&gt;越来越感到读源码的重要性，Let's read the fucking sourceCode!&lt;/p&gt;
</description>
<pubDate>Fri, 10 Jan 2020 15:08:00 +0000</pubDate>
<dc:creator>Jymoon</dc:creator>
<og:description>引子 Android事件分发其实是老生常谈了，但是说实话，我觉得很多人都只是懂其大概，模棱两可。本文的目的就是再次从源码层次梳理一下，重点放在ViewGroup的dispatchTouchEvent方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jymblog/p/12178527.html</dc:identifier>
</item>
<item>
<title>从头学pytorch(十六):VGG NET - core!</title>
<link>http://www.cnblogs.com/sdu20112013/p/12176304.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/12176304.html</guid>
<description>&lt;p&gt;AlexNet在Lenet的基础上增加了几个卷积层,改变了卷积核大小,每一层输出通道数目等,并且取得了很好的效果.但是并没有提出一个简单有效的思路.&lt;br/&gt;VGG做到了这一点,提出了可以通过重复使⽤简单的基础块来构建深度学习模型的思路.&lt;/p&gt;
&lt;p&gt;论文地址:&lt;a href=&quot;https://arxiv.org/abs/1409.1556&quot; class=&quot;uri&quot;&gt;https://arxiv.org/abs/1409.1556&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;vgg的结构如下所示:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/202001/583030-20200110101932660-2062522034.png&quot;/&gt;&lt;br/&gt;上图给出了不同层数的vgg的结构.也就是常说的vgg16,vgg19等等.&lt;/p&gt;
&lt;h2 id=&quot;vgg-block&quot;&gt;VGG BLOCK&lt;/h2&gt;
&lt;p&gt;vgg的设计思路是,通过不断堆叠3x3的卷积核,不断加深模型深度.vgg net证明了加深模型深度对提高模型的学习能力是一个很有效的手段.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/202001/583030-20200110103318124-1895063989.png&quot;/&gt;&lt;br/&gt;看上图就能发现,&lt;strong&gt;连续的2个3x3卷积,感受野和一个5x5卷积是一样的,但是前者有两次非线性变换,后者只有一次!&lt;/strong&gt;,这就是连续堆叠小卷积核能提高&lt;br/&gt;模型特征学习的关键.此外,2个3x3的参数数量也比一个5x5少.(2x3x3 &amp;lt; 5x5)&lt;/p&gt;
&lt;p&gt;vgg的基础组成模块,每一个卷积层都由n个3x3卷积后面接2x2的最大池化.池化层的步幅为2.从而卷积层卷积后,宽高不变,池化后,宽高减半.&lt;br/&gt;我们可以有以下代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def make_layers(in_channels,cfg):
    layers = []
    previous_channel = in_channels #上一层的输出的channel数量
    for v in cfg:
        if v == 'M':
            layers.append(nn.MaxPool2d(kernel_size=2,stride=2))
        else:
            layers.append(nn.Conv2d(previous_channel,v,kernel_size=3,padding=1))
            layers.append(nn.ReLU())

            previous_channel = v

    conv = nn.Sequential(*layers)
    return conv


cfgs = {
    'A': [64, 'M', 128, 'M', 256, 256, 'M', 512, 512, 'M', 512, 512, 'M'],
    'B': [64, 64, 'M', 128, 128, 'M', 256, 256, 'M', 512, 512, 'M', 512, 512, 'M'],
    'D': [64, 64, 'M', 128, 128, 'M', 256, 256, 256, 'M', 512, 512, 512, 'M', 512, 512, 512, 'M'],
    'E': [64, 64, 'M', 128, 128, 'M', 256, 256, 256, 256, 'M', 512, 512, 512, 512, 'M', 512, 512, 512, 512, 'M'],
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cfgs定义了不同的vgg模型的结构,比如'A'代表vgg11．　数字代表卷积后的channel数. 'M'代表Maxpool&lt;/p&gt;
&lt;p&gt;我们可以给出模型定义&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class VGG(nn.Module):
    def __init__(self,input_channels,cfg,num_classes=10, init_weights=True):
        super(VGG, self).__init__()
        self.conv = make_layers(input_channels,cfg) # torch.Size([1, 512, 7, 7])
        self.fc = nn.Sequential(
            nn.Linear(512*7*7,4096),
            nn.ReLU(),
            nn.Linear(4096,4096),
            nn.ReLU(),
            nn.Linear(4096,num_classes)
        )
    
    def forward(self, img):
        feature = self.conv(img)
        output = self.fc(feature.view(img.shape[0], -1))
        return output&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;卷积层的输出可由以下测试代码得出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# conv = make_layers(1,cfgs['A'])
# X = torch.randn((1,1,224,224))
# out = conv(X)
# #print(out.shape)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;加载数据&quot;&gt;加载数据&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;batch_size,num_workers=4,4
train_iter,test_iter = learntorch_utils.load_data(batch_size,num_workers,resize=224)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里batch_size调到8我的显存就不够了...&lt;/p&gt;
&lt;h2 id=&quot;定义模型&quot;&gt;定义模型&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;net = VGG(1,cfgs['A']).cuda()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;定义损失函数&quot;&gt;定义损失函数&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;loss = nn.CrossEntropyLoss()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;定义优化器&quot;&gt;定义优化器　&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;opt = torch.optim.Adam(net.parameters(),lr=0.001)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;定义评估函数&quot;&gt;定义评估函数&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;def test():
    acc_sum = 0
    batch = 0
    for X,y in test_iter:
        X,y = X.cuda(),y.cuda()
        y_hat = net(X)
        acc_sum += (y_hat.argmax(dim=1) == y).float().sum().item()
        batch += 1
    #print('acc_sum %d,batch %d' % (acc_sum,batch))

    return 1.0*acc_sum/(batch*batch_size)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;训练&quot;&gt;训练&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;num_epochs = 3
def train():
    for epoch in range(num_epochs):
        train_l_sum,batch,acc_sum = 0,0,0
        start = time.time()
        for X,y in train_iter:
            # start_batch_begin = time.time()
            X,y = X.cuda(),y.cuda()
            y_hat = net(X)
            acc_sum += (y_hat.argmax(dim=1) == y).float().sum().item()

            l = loss(y_hat,y)
            opt.zero_grad()
            l.backward()

            opt.step()
            train_l_sum += l.item()

            batch += 1

            mean_loss = train_l_sum/(batch*batch_size) #计算平均到每张图片的loss
            start_batch_end = time.time()
            time_batch = start_batch_end - start

            print('epoch %d,batch %d,train_loss %.3f,time %.3f' % 
                (epoch,batch,mean_loss,time_batch))

        print('***************************************')
        mean_loss = train_l_sum/(batch*batch_size) #计算平均到每张图片的loss
        train_acc = acc_sum/(batch*batch_size)     #计算训练准确率
        test_acc = test()                           #计算测试准确率
        end = time.time()
        time_per_epoch =  end - start
        print('epoch %d,train_loss %f,train_acc %f,test_acc %f,time %f' % 
                (epoch + 1,mean_loss,train_acc,test_acc,time_per_epoch))

train()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4G的GTX 1050显卡,训练一个epoch大概一个多小时.&lt;br/&gt;完整代码:&lt;a href=&quot;https://github.com/sdu2011/learn_pytorch&quot; class=&quot;uri&quot;&gt;https://github.com/sdu2011/learn_pytorch&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 Jan 2020 14:54:00 +0000</pubDate>
<dc:creator>core!</dc:creator>
<og:description>VGG AlexNet在Lenet的基础上增加了几个卷积层,改变了卷积核大小,每一层输出通道数目等,并且取得了很好的效果.但是并没有提出一个简单有效的思路. VGG做到了这一点,提出了可以通过重复使⽤</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdu20112013/p/12176304.html</dc:identifier>
</item>
</channel>
</rss>