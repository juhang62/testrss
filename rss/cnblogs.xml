<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>浅谈堆-Heap（一） - 小-欢-欢</title>
<link>http://www.cnblogs.com/blentle/p/10941119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blentle/p/10941119.html</guid>
<description>&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;应用场景和前置知识复习&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;排序我们都很熟悉，如冒泡排序、选择排序、希尔排序、归并排序、快速排序等，其实堆也可以用来排序，严格来说这里所说的堆是一种数据结构，排序知识它的应用场景之一&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;+&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Top N的求解&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;优先队列&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;堆得另一个重要的应用场景就是优先队列&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们知道普通队列是：先进先出&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;而 优先队列：出队顺序和入队顺序无关；和优先级相关&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;实际生活中有很多优先队列的场景，如医院看病，急诊病人是最优先的,虽然这一类病人可能比普通病人到的晚，但是他们可能随时有生命危险，需要及时进行治疗. 再比如 操作系统要&quot;同时&quot;执行多个任务，实际上现代操作系统都会将CPU的执行周期划分成非常小的时间片段，每个时间片段只能执行一个任务，究竟要执行哪个任务，是有每个任务的优先级决定的.每个任务都有一个优先级.操作系统动态的每一次选择一个优先级最高的任务执行.要让操作系统动态的选择优先级最高的任务去执行，就需要维护一个优先队列，也就是说所有任务都会进入这个优先队列.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;基本实现&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;首先堆是一颗二叉树，这个二叉树必须满足两个两条件&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个二叉树必须是一颗完全二叉树，所谓完全二叉树就是除了最后一层外，其他层的节点的个数必须是最大值，且最后一层的节点都必须集中在左侧.即最后一层从左往右数节点必须是紧挨着的，不能是中间空出一个，右边还有兄弟节点.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个二叉树必须满足 左右子树的节点值必须小于或等于自身的值（大顶堆） 或者 左右子树的节点值必须大于或等于自身的值(小顶堆)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;下图分别是一个大顶堆和小顶堆的示例&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528230753899-1043600200.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;看到这两颗二叉树，我们首先就能定义出树节点的结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;Class Node {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点本身的值&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object value;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node left;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node right;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    ....getter and setter
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;但是这里我们利用完全二叉树的性质用数组来构建这棵树.先从上到下，自左至右的来给树的每一个节点编上号.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;以大顶堆为例&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528230937422-1308709609.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;标上编号后，我们发现每个节点的左子节点(如果存在)的序号都是其自身的2倍，右子节点(如果存在)的序号是其自身的2倍加1. 相反，如果已知某个节点的序号，父节点的序号是其自身的二分之一(计算机中整型相除，舍弃余数)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;下面来用代码构建一个堆得骨骼&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d2dbbd7c-76fe-4b3d-8a7a-539694b202d6')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_d2dbbd7c-76fe-4b3d-8a7a-539694b202d6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d2dbbd7c-76fe-4b3d-8a7a-539694b202d6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d2dbbd7c-76fe-4b3d-8a7a-539694b202d6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d2dbbd7c-76fe-4b3d-8a7a-539694b202d6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MaxHeap {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 堆中有多少元素
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * 存放堆数据的数组
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object[] data;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; MaxHeap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;         * 因为序号是从1 开始的，我们不用下标是0的这个位置的数
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.data = &lt;span&gt;new&lt;/span&gt; Object[capacity + 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * 返回堆中有多少数据
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size()  {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     * 堆是否还有元素
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; count == 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     
&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;骨骼是构建好了，乍一看堆中存放的数据是一个object类型的数据, 父子节点按节点值 无法比较，这里再调整一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MaxHeap&amp;lt;T &lt;span&gt;extends&lt;/span&gt; Comparable&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 堆中有多少元素
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * 存放堆数据的数组
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; T[] data;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; clazz 堆里放的元素的类型
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; capacity  堆的容量
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; MaxHeap(Class&amp;lt;T&amp;gt; clazz, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;         * 因为序号是从1 开始的，我们不用下标是0的这个位置的数
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.data = (T[]) Array.newInstance(clazz, capacity + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * 返回堆中有多少数据
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     * 堆是否还有元素
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; count == 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T[] getData() {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样骨架算是相对完好了，下面实现向堆中添加数据的过程,首先我们先把上面的二叉树的形式按标号映射成数组的形式如图对比(已经说了0号下标暂时不用)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231154344-680307708.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;现在这个大顶堆被映射成数组，所以向堆中插入元素，相当于给数组添加元素，这里我们规定每新插入一个元素就插在当前数组最后面，也即数组最大标 + 1的位置处.对于一颗完全二叉树来说就是插在最后一层的靠左处，如果当前二叉树是一颗满二叉树，则新开辟一层，插在最后一层最左侧.但是这样插入有可能破坏堆的性质. 如插入节点45&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231232559-1062605216.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;插入新节点后已经破坏了大顶堆的性质，因为45比父节点17大, 这里我们只要把新插入的节点45和父节点17 交换，类似依次比较与父节点的大小做交换即可&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;第一次交换:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231303945-1506002520.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;第二次交换:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231343274-548580213.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;这里我们发现经过两次交换，已经满足了堆的性质,这样我们就完成了一次插入,这个过程，我们发现待插入的元素至底向顶依次向树根上升，我们给这个过程起个名叫shiftUp,用代码实现便是:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 插入元素t到堆中
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; t
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(T t) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把这个元素插入到数组的尾部,这时堆的性质可能被破坏&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         data[count + 1] =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入一个元素，元素的个数增加1&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动数据,进行shiftUp操作,修正堆&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        shiftUp(count);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; shiftUp(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (index &amp;gt; 1 &amp;amp;&amp;amp; ((data[index].compareTo(data[index &amp;gt;&amp;gt; 1]) &amp;gt; 0&lt;span&gt;))) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             swap(index, index &amp;gt;&amp;gt;&amp;gt; 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             index &amp;gt;&amp;gt;&amp;gt;= 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * 这里使用引用交换，防止基本类型值传递
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index1
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index2
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; swap(&lt;span&gt;int&lt;/span&gt; index1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index2) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         T tmp =&lt;span&gt; data[index1];
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         data[index1] =&lt;span&gt; data[index2];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         data[index2] =&lt;span&gt; tmp;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有一个隐藏的问题，初始化我们指定了存放数据数组的大小，随着数据不断的添加，总会有数组越界的这一天.具体体现在以上代码 data[count + 1] = t 这一行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 插入元素t到堆中
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; t
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(T t) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把这个元素插入到数组的尾部,这时堆的性质可能被破坏&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         data[count + 1] = t;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一行会引发数组越界异常
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入一个元素，元素的个数增加1&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动数据,进行shiftUp操作,修正堆&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        shiftUp(count);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以考虑在插入之前判断一下容量,所以声明一个成员变量,在实例初始化时，初始化这个capacity&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造方法变成:&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; clazz 堆里放的元素的类型
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; capacity  堆的容量
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; MaxHeap(Class&amp;lt;T&amp;gt; clazz, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;         * 因为序号是从1 开始的，我们不用下标是0的这个位置的数
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.data = (T[]) Array.newInstance(clazz, capacity + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * 插入元素t到堆中
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; t
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(T t) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入的方法加入容量限制判断&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(count + 1 &amp;gt;&lt;span&gt; capacity)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IndexOutOfBoundsException(&quot;can't insert a new element...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把这个元素插入到数组的尾部,这时堆的性质可能被破坏&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         data[count + 1] = t;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一行会引发数组越界异常
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入一个元素，元素的个数增加1&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动数据,进行shiftUp操作,修正堆&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        shiftUp(count);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;至此，整个大顶堆的插入已经还算完美了，来一波儿数据测试一下，应该不是问题&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;可能上面插入时我们看到有shiftUp这个操作，可能会想到从堆中删除元素是不是shiftDown这个操作. 没错就是shiftDown,只不过是删除堆中元素只能删除根节点元素，对于大顶堆也就是剔除最大的元素.下面我们用图说明一下.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231750405-1657101035.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;删除掉根节点，那根节点的元素由谁来补呢. 简单，直接剁掉原来数组中最后一个元素，也就是大顶堆中最后一层最后一个元素,摘了补给根节点即可,相应的堆中元素的个数要减一&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231815968-948292176.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;最终我们删除了大顶堆中最大的元素，也就是根节点,堆中序号最大的元素变成了根节点.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231846048-408152744.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;此时整个堆不满足大顶堆的性质,因为根节点17比其子节点小，这时，shiftDown就管用了，只需要把自身与子节点交换即可，可是子节点有两个，与哪个交换呢，如果和右子节点30交换，30变成父节点，比左子节点45小，还是不满足大顶堆的性质.所以应该依次与左子节点最大的那个交换，直至父节点比子节点大才可.所以剔除后新被替换的根节点依次下沉，所以这个过程被称为shiftDown，最终变成&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700414/201905/700414-20190528231915209-2008272600.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;所以移除z最大元素的方法实现:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 弹出最大的元素并返回
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T popMax() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (count &amp;lt;= 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IndexOutOfBoundsException(&quot;empty heap&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         T max = data[1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把最后一个元素补给根节点&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         swap(1&lt;span&gt;, count);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;补完后元素个数减一&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         count--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下沉操作&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         shiftDown(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * 下沉
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; shiftDown(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只要这个index对应的节点有左子节点(完全二叉树中不存在 一个节点只有 右子节点没有左子节点)&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (count &amp;gt;= (index &amp;lt;&amp;lt; 1&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较左右节点谁大，当前节点跟谁换位置
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子节点的inedx&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; left = index &amp;lt;&amp;lt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右子节点则是&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; right = left + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果右子节点存在,且右子节点比左子节点大,则当前节点与右子节点交换&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (right &amp;lt;=&lt;span&gt; count) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;有右子节点&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; ((data[left].compareTo(data[right]) &amp;lt; 0&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子节点比右子节点小,且节点值比右子节点小&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (data[index].compareTo(data[right]) &amp;lt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                        swap(index, right);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                         index =&lt;span&gt; right;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     } &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子节点比右子节点大&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (data[index].compareTo(data[left]) &amp;lt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                        swap(index, left);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                         index =&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     } &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右子节点不存在,只有左子节点&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (data[index].compareTo(data[left]) &amp;lt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                    swap(index, left);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                     index =&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;index 的值大于左子节点，终止循环&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，大顶堆的插入和删除最大元素就都实现完了.来写个测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a1e2520d-1a8e-4f36-92dc-16cb7a5b4013')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_a1e2520d-1a8e-4f36-92dc-16cb7a5b4013&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a1e2520d-1a8e-4f36-92dc-16cb7a5b4013&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a1e2520d-1a8e-4f36-92dc-16cb7a5b4013',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a1e2520d-1a8e-4f36-92dc-16cb7a5b4013&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         MaxHeap&amp;lt;Integer&amp;gt; mh = &lt;span&gt;new&lt;/span&gt; MaxHeap&amp;lt;Integer&amp;gt;(Integer.&lt;span&gt;class&lt;/span&gt;, 12&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         mh.insert(66&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         mh.insert(44&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         mh.insert(30&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         mh.insert(27&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         mh.insert(17&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         mh.insert(25&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         mh.insert(13&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         mh.insert(19&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         mh.insert(11&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         mh.insert(8&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         mh.insert(45&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         Integer[] data =&lt;span&gt; mh.getData();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1 ; i &amp;lt;= mh.count ; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             System.err.print(data[i] + &quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        mh.popMax();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1 ; i &amp;lt;= mh.count ; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             System.err.print(data[i] + &quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;嗯，还不错，结果跟上面图上对应的数组一样.结果倒是期望的一样，但总感觉上面的shiftDown的代码比shiftUp的代码要多几倍，而且看着很多类似一样的重复的代码, 看着难受.于是乎想个办法优化一下. 对我这种强迫症来说，不干这件事，晚上老是睡不着觉.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;思路: 上面我们不断的循环条件是这个index对应的节点有子节点.如果节点堆的性质破坏，最终是要用这个值与其左子节点或者右子节点的值交换，所以我们计算出了左子节点和右子节点的序号.其实不然，我们定义一个抽象的最终要和父节点交换的变量，这个变量可能是左子节点，也可能是右子节点，初始化成左子节点的序号，只有在其左子节点的值小于右子节点，且父节点的值也左子节点,父节点才可能与右子节点，这时让其这个交换的变量加1变成右子节点的序号即可，其他情况则要么和左子节点交换，要么不作交换，跳出循环,所以shiftDown简化成：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 下沉
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; shiftDown(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只要这个index对应的节点有左子节点(完全二叉树中不存在 一个节点只有 右子节点没有左子节点)&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (count &amp;gt;= (index &amp;lt;&amp;lt; 1&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;比较左右节点谁大，当前节点跟谁换位置
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子节点的inedx&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; left = index &amp;lt;&amp;lt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;data[index]预交换的index的序号&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; t =&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果右子节点存在,且右子节点比左子节点大,则当前节点可能与右子节点交换&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (((t + 1) &amp;lt;= count) &amp;amp;&amp;amp; (data[t].compareTo(data[t + 1]) &amp;lt; 0&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 t += 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果index序号节点比t序号的节点小，才交换,否则什么也不作, 退出循环&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(data[index].compareTo(data[t]) &amp;gt;= 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            swap(index, t);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             index =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;嗯，还不错，这下完美了.简单多了.其他还有待优化的地方留在下篇讨论&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;+&quot; readability=&quot;2.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;首先复习了堆的应用场景，具体的应用场景代码实现留在下一篇.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;引入堆的概念，性质和大顶堆，小顶堆的概念,实现了大顶堆的元素添加和弹出&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;根据堆的性质和弹出时下沉的规律，优化下沉方法代码.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;下一篇优化堆的构建，用代码实现其应用场景，如排序， topN问题，优先队列等并引入其他的堆分析及其与普通堆的性能差异&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 15:30:00 +0000</pubDate>
<dc:creator>小-欢-欢</dc:creator>
<og:description>应用场景和前置知识复习 堆排序 堆排序 排序我们都很熟悉，如冒泡排序、选择排序、希尔排序、归并排序、快速排序等，其实堆也可以用来排序，严格来说这里所说的堆是一种数据结构，排序知识它的应用场景之一 To</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/blentle/p/10941119.html</dc:identifier>
</item>
<item>
<title>比特币入门一基础介绍 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/10932936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/10932936.html</guid>
<description>&lt;p&gt;由于前面以太仿教程是汇智网的在线课程，所以后面重要的几篇就不列出来了。毕竟是人家作者辛辛苦苦的劳动成果，列出来几篇一是记录下有点类似最近比较火的vlog，同时想着借此机会宣传下我的新书，没想到还要等一段时间，上周ISBN号下来了，CIP号还未下来，可能要到下周才下来，二也是帮助作者宣传一下课程，以太仿的课程确实不错。&lt;/p&gt;
&lt;p&gt;一、什么是比特币&lt;/p&gt;
&lt;p&gt;当我们谈到比特币时，其实在不同的场景下有不同的指代。&lt;/p&gt;
&lt;p&gt;比特币首先是一种数字加密货币，用户可以通过比特币网络进行 比特币转账或商品结算，就和传统的货币一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190527201852480-2032636042.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过比特币是基于密码学技术的虚拟化货币，它没有实体，仅仅 隐含在从发送方到接收方的交易中，接收方必须使用其持有的密钥来 消费收到的比特币。&lt;/p&gt;
&lt;p&gt;对于科技从业者而言，比特币则更多了一层含义：比特币对应着 一种划时代的数字加密货币系统，其内容包含通信协议、激励机制、实现代码 与承载网络等：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190527201936219-1414513717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事实上，比特币是数十年来密码学技术、分布式计算等领域的集大成者， 它不是第一个出现的数字货币，但无疑是最成功的，一个洞察了人性的 虚拟产品。&lt;/p&gt;
&lt;p&gt;二、区块链结构&lt;/p&gt;
&lt;p&gt;比特币是一个专用数据库，它只保存一种类型的数据记录 —— 交易，例如 张三转给李四几个币，或者李四转给王五几个币：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190527202045870-500055580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一旦涉及到资金，大家都会变得慎重了。因此交易记录最好在技术上可以保证 是不能篡改的，这样出了问题可以翻翻老账，这就要求账本必须值得信赖。&lt;/p&gt;
&lt;p&gt;比特币采用一种特殊的数据结构区块链/Blockchain来保障交易的不可篡改性， 每一个包含一批交易数据的区块，同时也包含了前一个区块的指纹：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190527202116131-513386463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在比特币中，一个区块的指纹是使用密码学中常见的哈希函数来实现的。 哈希函数可以将大块数据压缩成精简的表示，而且可以保证如果精简 的表示不同，那么其对应的原始数据也不同。&lt;/p&gt;
&lt;p&gt;例如，在上图中如果12#区块被攻击者篡改，那么它的哈希结果将不同于在 13#区块中保存的其原始指纹，这使得识别篡改的区块这一任务很容易，或者 说篡改的难度很大 —— 攻击者必须同时修改12#之后的所有区块才能保证 指纹校验成功。&lt;/p&gt;
&lt;p&gt;另一方面，如果攻击者直接篡改14#区块（我们假设这是最后一个块），那么 显然是可行的，因为它缺乏之后更多区块的保护。这引入了在比特币中常用 的一个概念：交易的确认数 / Confirmations。&lt;/p&gt;
&lt;p&gt;交易一旦被确认打包到区块中，它的确认数就是1，之后每增长一个区块 则确认数加1。例如对于上图中的标注交易，当链增长到14#块时，该交易的 确认数就是3。&lt;/p&gt;
&lt;p&gt;显然一个交易的确认数越多，意味着攻击者篡改交易的可能性越小。在比特币 中的应用当中，交易的接收者通常需要在六个确认之后，才可以将该笔 交易视为成功。&lt;/p&gt;
&lt;p&gt;三、去中心化机制&lt;/p&gt;
&lt;p&gt;与当前流通的任何法币都不同，比特币是去中心化的，没有一个中央机构 来管理比特币的发行与流通，因此比特币网络是一个典型的P2P网络，在每个 （全）节点上都有完整的区块链数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190527202317264-394846693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这样的分布式计算环境下，如何保证新的交易在各个节点区块链中得以 一致的更新，就是经典的分布式一致性问题了 —— 每个节点都有可能提交 新的交易，而不同节点提交的交易也可能不相同，到底以哪个节点为准？&lt;/p&gt;
&lt;p&gt;解决这种问题的经典方法就是（动态）选举一个决策者，其他节点复制 决策者的行为即可避免节点之间的不一致了。比特币的解决思路也一样， 不过它采用了一种类似于抢答的机制来动态选择胜出的节点，由胜出的 节点负责出块并打包交易 —— 所有节点都同时求解同一个问题，最先得到结果 的节点获胜并获得出块权利，其他节点则转而求解下一次出块的问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201905/733213-20190527202351442-1118634383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比特币给出的问题不可以通过解析方法求解，节点必须在所有的可能 结果中暴力尝试求解，由于胜出的节点可以获得比特币奖励，使得 节点旳动机和行为颇为类似于淘金的西部牛仔，因此这一求解过程被 称为挖矿/Mining。&lt;/p&gt;
&lt;p&gt;理论上每个节点都有获胜的概率，但显然，在同样的时间内，计算力强大的 节点会比其他节点尝试的机会更多，因此获胜的概率也越大 —— 在这种抢答机制下， 算力代替了智力，而这种依赖于暴力求解问题从而达成节点一致性的共识算法 被称为工作量证明/Proof Of Work。&lt;/p&gt;

</description>
<pubDate>Tue, 28 May 2019 15:28:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>由于前面以太仿教程是汇智网的在线课程，所以后面重要的几篇就不列出来了。毕竟是人家作者辛辛苦苦的劳动成果，列出来几篇一是记录下有点类似最近比较火的vlog，同时想着借此机会宣传下我的新书，没想到还要等一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/5ishare/p/10932936.html</dc:identifier>
</item>
<item>
<title>AcWing算法基础1.2 - 少年冲冲冲</title>
<link>http://www.cnblogs.com/chuyds/p/10941073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chuyds/p/10941073.html</guid>
<description>&lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;归并排序&lt;/p&gt;
&lt;p&gt;归并排序和快速排序相反，快排是先排后分再合并，归并则是先分后排再合并&lt;/p&gt;
&lt;p&gt;归并排序时间复杂度是O(n logn)&lt;/p&gt;
&lt;p&gt;分析：    -----------------------------------------------------------------      //待排序的序列长度&lt;/p&gt;
&lt;p&gt;               -----------------------------  ----------------------------------     &lt;/p&gt;
&lt;p&gt;               -------------  --------------   --------------  ------------------&lt;/p&gt;
&lt;p&gt;               ......&lt;/p&gt;
&lt;p&gt;               -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -    // 总共logn层&lt;/p&gt;
&lt;p&gt;待排序列会被分成logn层，对于每层我们需要执行n次操作，所以时间复杂度就是O(n logn)&lt;/p&gt;
&lt;p&gt;要是不太明白最下面有张图，看着图容易理解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模板&lt;/strong&gt; &lt;strong&gt;:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; merge_sort(&lt;span&gt;int&lt;/span&gt; q[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(l &amp;gt;= r)  &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; mid = l + r &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    merge_sort(q, l, mid);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     merge_sort(q, mid + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, r);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;0&lt;/span&gt;, i = l, j = mid + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;=&lt;span&gt; r)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(q[i] &amp;lt; q[j])  temp[k++] = q[i++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;  temp[k++] = q[j++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;lt;= mid)  tmep[k++] = q[i++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(j &amp;lt;= r)  temp[k++] = q[j++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = l, j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt;= r; i ++, j ++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         q[i] =&lt;span&gt; temp[j];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;图片&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1626164/201905/1626164-20190528231722990-1169061445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 15:20:00 +0000</pubDate>
<dc:creator>少年冲冲冲</dc:creator>
<og:description>排序 归并排序 归并排序和快速排序相反，快排是先排后分再合并，归并则是先分后排再合并 归并排序时间复杂度是O(n logn) 分析： //待排序的序列长度 ...... - - - - - - - -</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chuyds/p/10941073.html</dc:identifier>
</item>
<item>
<title>deepin15.10重装nvidia驱动及cuda - ManWingloeng</title>
<link>http://www.cnblogs.com/ManWingloeng/p/10941075.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ManWingloeng/p/10941075.html</guid>
<description>&lt;h2 id=&quot;问题描述&quot;&gt;问题描述：&lt;/h2&gt;
&lt;p&gt;nvidia-smi也有显示，显卡驱动是在的，而且nvcc显示出来的cuda版本9.0也没错，不是9.1。不知道问题所在，索性重装全部。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo tee /proc/acpi/bbswitch &amp;lt;&amp;lt;&amp;lt;ON
# ON
nvidia-smi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Tue May 28 22:21:07 2019       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI 390.67                 Driver Version: 390.67                    |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|===============================+======================+======================|
|   0  GeForce GTX 950M    Off  | 00000000:01:00.0 Off |                  N/A |
| N/A   50C    P0    N/A /  N/A |      0MiB /  2004MiB |      0%      Default |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                       GPU Memory |
|  GPU       PID   Type   Process name                             Usage      |
|=============================================================================|
|  No running processes found                                                 |
+-----------------------------------------------------------------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;nvcc --version&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2017 NVIDIA Corporation
Built on Fri_Sep__1_21:08:03_CDT_2017
Cuda compilation tools, release 9.0, V9.0.176&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;lspci | grep -i nvidia&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;01:00.0 3D controller: NVIDIA Corporation GM107M [GeForce GTX 950M] (rev a2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查pytorch调用cuda是否正常：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python -c 'import torch; print(torch.cuda.is_available())'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;False&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;卸载cuda&quot;&gt;卸载cuda&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo /usr/local/cuda-9.0/bin/uninstall_cuda_9.0.pl  
#这里之后只剩下cudnn的东西，也可以完全删了。
sudo rm -rf /usr/local/cuda-9.0/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;卸载nvidia驱动及大黄蜂bunmblebee&quot;&gt;卸载nvidia驱动及大黄蜂bunmblebee&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo apt-get remove --purge nvidia-cuda-dev nvidia-cuda-toolkit nvidia-nsight nvidia-visual-profiler
sudo apt autoremove --purge bumblebee-nvidia nvidia-driver nvidia-settings&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装显卡驱动和大黄蜂bumblebee&quot;&gt;安装显卡驱动和大黄蜂bumblebee&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo apt-get install nvidia-smi
sudo apt-get install bumblebee-nvidia nvidia-driver nvidia-settings&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装显卡驱动测试程序&quot;&gt;安装显卡驱动测试程序&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo apt-get install mesa-utils&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示N卡相关信息：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;optirun glxinfo|grep NVIDIA&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行测试程序&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;optirun glxgears -info&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功调用显卡驱动，信息如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;GL_RENDERER   = GeForce GTX 950M/PCIe/SSE2
GL_VERSION    = 4.6.0 NVIDIA 390.67
GL_VENDOR     = NVIDIA Corporation&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装cuda&quot;&gt;安装cuda&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.nvidia.com/cuda-90-download-archive?target_os=Linux&amp;amp;target_arch=x86_64&amp;amp;target_distro=Ubuntu&amp;amp;target_version=1604&amp;amp;target_type=runfilelocal&quot; class=&quot;uri&quot;&gt;https://developer.nvidia.com/cuda-90-download-archive?target_os=Linux&amp;amp;target_arch=x86_64&amp;amp;target_distro=Ubuntu&amp;amp;target_version=1604&amp;amp;target_type=runfilelocal&lt;/a&gt;&lt;br/&gt;下载runfile&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo ./cuda_9.0.176_384.81_linux.run&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装过程只有这个选no&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 384.81?
(y)es/(n)o/(q)uit: n&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;下载安装cudnn&quot;&gt;下载安装cudnn&lt;/h2&gt;
&lt;p&gt;&amp;lt;&lt;a href=&quot;https://developer.nvidia.com/rdp/cudnn-archive&quot; class=&quot;uri&quot;&gt;https://developer.nvidia.com/rdp/cudnn-archive&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;登录下载对应版本我是选择了&lt;/p&gt;
&lt;p&gt;cudnn-9.0-linux-x64-v7.5.0.56&lt;/p&gt;
&lt;p&gt;这个版本的&lt;/p&gt;
&lt;p&gt;把对应的额外的cudnn库放入cuda对应的位置：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sudo cp lib64/* /usr/local/cuda/lib64/
sudo cp include/* /usr/local/cuda/include/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后检查环境变量并开启默认N卡&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 检查LD_LIABRARY_PATH和PATH
sudo vim ~/.bashrc

# 用大黄蜂开启默认N卡
sudo tee /proc/acpi/bbswitch&amp;lt;&amp;lt;&amp;lt;ON&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次检查pytorch是否能调用cuda&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python -c &quot;import torch;print(torch.cuda.is_available())&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查tensorflow是否正常调用gpu&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python3 -c &quot;import tensorflow as tf;print(tf.test.is_gpu_available());print(tf.test.gpu_device_name())&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;2019-05-28 22:52:25.862539: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA
2019-05-28 22:52:26.319239: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:964] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero
2019-05-28 22:52:26.319674: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1432] Found device 0 with properties: 
name: GeForce GTX 950M major: 5 minor: 0 memoryClockRate(GHz): 1.124
pciBusID: 0000:01:00.0
totalMemory: 1.96GiB freeMemory: 1.92GiB
2019-05-28 22:52:26.319696: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1511] Adding visible gpu devices: 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;都正常了，没有比我这更复杂了吧，卸了重装，有卸载过程和安装过程。&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 15:20:00 +0000</pubDate>
<dc:creator>ManWingloeng</dc:creator>
<og:description>deepin15.10重装nvidia驱动及cuda，安装版本为cuda9.0，nvidia的Driver Version:为390.67</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ManWingloeng/p/10941075.html</dc:identifier>
</item>
<item>
<title>javaScript基础 - 曾经有一首歌</title>
<link>http://www.cnblogs.com/ruckly/p/10941031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ruckly/p/10941031.html</guid>
<description>&lt;h2&gt;1JavaScript语言：&lt;/h2&gt;
&lt;p&gt;一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。&lt;/p&gt;
&lt;p&gt;广泛应用于：PC浏览器/PC软件/手机浏览器/手机app/微信小程序/微信公众号开发/硬件开发/服务器开发/AR/VR/深度学习/机器学习&lt;/p&gt;
&lt;h2&gt;2js的使用：&lt;/h2&gt;
&lt;p&gt;Script标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!DOCTYPE html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;head&amp;gt;
&lt;span&gt; 4&lt;/span&gt;         &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;/head&amp;gt;
&lt;span&gt; 7&lt;/span&gt;     &amp;lt;body&amp;gt;
&lt;span&gt; 8&lt;/span&gt;         &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; a = '你好'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            console.log(a);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &amp;lt;/script&amp;gt;
&lt;span&gt;12&lt;/span&gt;     &amp;lt;/body&amp;gt;
&lt;span&gt;13&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Script标签将js文件进行引用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;script src=&quot;js/index.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.js的执行顺序：&lt;/h2&gt;
&lt;p&gt;Script标签内容的执行，是按顺序执行，但是加载是按照异步进行加载。&lt;/p&gt;
&lt;h2&gt;4.同步与异步:&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;同步：一个事情完成之后，才能做下一件事情，有等待就是同步。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步：一个事情发起之后，下一个事情也可以立即发起，不需要等待前面一个事情完成之后才发起。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;so:Script&lt;/strong&gt;&lt;strong&gt;标签里面如果有代码出错，仅仅只会影响到这个script&lt;/strong&gt;&lt;strong&gt;标签代码的执行。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;5.运行原理：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;浏览器首先会解析HTML,解析到script标签时候，会用调用JS引擎执行script标签里的代码，先会对代码&lt;strong&gt;预编译&lt;/strong&gt;（&lt;strong&gt;一些语法纠正和变量提升处理）&lt;/strong&gt;，然后解释执行。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;6.js变量的申明：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Js是弱类型语言，所以申明变量的时候，统一用var进行申明变量。如果这个变量没有申明，这个变量就会申明一个全局变量。&lt;/p&gt;
&lt;p&gt;申明变量方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; a,b,c;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = &quot;username&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;未赋值的变量，会设置为undefined；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：js在预编译的时候，变量的声明会被提升到最上面。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 全局变量：在&lt;strong&gt;最外层申明的变量&lt;/strong&gt;以及在&lt;strong&gt;函数内部未用&lt;/strong&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;strong&gt;申明变量&lt;/strong&gt;（变量提升），那么就是全局变量，所有的全局变量都会在window上&lt;/p&gt;
&lt;p&gt;局部变量：&lt;strong&gt;在函数内部申明的变量就是局部变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Js变量命名规范：&lt;/p&gt;
&lt;p&gt;必须用字母或者_或者$作为首字母，字母加_加$加数字构成变量名。&lt;/p&gt;
&lt;p&gt;js类型:&lt;/p&gt;
&lt;p&gt;数值类型:&lt;strong&gt;整数&lt;/strong&gt;/&lt;strong&gt;浮点数&lt;/strong&gt;/&lt;strong&gt;infinite&lt;/strong&gt;/-infinite/nan&lt;/p&gt;
&lt;p&gt;字符串类型:”abc”,’123’&lt;/p&gt;
&lt;p&gt;对象:{}，new object()&lt;/p&gt;
&lt;p&gt;布尔值：true和false&lt;/p&gt;
&lt;p&gt;Undefined：1.无申明2.有申明但是未赋值。3.没有任何属性值&lt;/p&gt;
&lt;p&gt;Null：这是赋值为空的内容。&lt;/p&gt;
&lt;p&gt;注意：两个字符型类型为数值的情况：只要有字符类型都按字符的拼接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!DOCTYPE html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &amp;lt;head&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
&lt;span&gt; 6&lt;/span&gt;         &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &amp;lt;/head&amp;gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &amp;lt;body&amp;gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &amp;lt;h1&amp;gt;JavaScript 数字&amp;lt;/h1&amp;gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &amp;lt;p&amp;gt;一个常见的错误是期望这个结果为 30：&amp;lt;/p&amp;gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &amp;lt;p id=&quot;demo&quot;&amp;gt;&amp;lt;/p&amp;gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &amp;lt;script&amp;gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; x = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; y = 20&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             document.getElementById(&quot;demo&quot;).innerHTML = &lt;span&gt;&quot;结果是：&quot;&lt;/span&gt; + x +&lt;span&gt; y;　　//字符+数值+数值
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &amp;lt;/script&amp;gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &amp;lt;/body&amp;gt;
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1663911/201905/1663911-20190528225721980-1119306942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;7.js运算：&lt;/h2&gt;
&lt;h3&gt;算数运算&lt;/h3&gt;
&lt;p&gt;加 +&lt;/p&gt;
&lt;p&gt;减 -&lt;/p&gt;
&lt;p&gt;乘 *&lt;/p&gt;
&lt;p&gt;除 /&lt;/p&gt;
&lt;p&gt;求余 %&lt;/p&gt;

&lt;h3&gt;赋值运算&lt;/h3&gt;
&lt;p&gt;+=&lt;/p&gt;
&lt;p&gt;-=&lt;/p&gt;
&lt;p&gt;*=&lt;/p&gt;
&lt;p&gt;/=&lt;/p&gt;
&lt;p&gt;%=&lt;/p&gt;
&lt;p&gt;++&lt;/p&gt;
&lt;p&gt;--&lt;/p&gt;

&lt;h3&gt;逻辑运算&lt;/h3&gt;
&lt;p&gt;和运算：&amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;或运算：||&lt;/p&gt;
&lt;p&gt;非：!&lt;/p&gt;

&lt;h3&gt;比较运算&lt;/h3&gt;
&lt;p&gt;大于：&amp;gt;&lt;/p&gt;
&lt;p&gt;大于等于：&amp;gt;=&lt;/p&gt;
&lt;p&gt;小于：&amp;lt;&lt;/p&gt;
&lt;p&gt;小于等于：&amp;lt;=&lt;/p&gt;
&lt;p&gt;等于：==&lt;/p&gt;
&lt;p&gt;备注：js在做比较的时候会进行转换，如果能够通过类型转换成一样的内容，就为真。&lt;/p&gt;
&lt;p&gt;全等于：===&lt;/p&gt;
&lt;p&gt;备注：不做任何的类型转换，直接比较&lt;/p&gt;
&lt;p&gt;不等：!=&lt;/p&gt;
&lt;p&gt;备注：这个在比较的时候会做类型转换，转换之后还是不能一样，才是不等&lt;/p&gt;
&lt;p&gt;全不等！==&lt;/p&gt;
&lt;p&gt;备注：不做任何类型转换&lt;/p&gt;
&lt;h3&gt;条件运算&lt;/h3&gt;
&lt;p&gt;条件？”为真的时候执行”：”为假的时候执行”&lt;/p&gt;
&lt;p&gt;三元运算符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = 3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = 4

&lt;span&gt;var&lt;/span&gt; c = a&amp;gt;b?&quot;大于&quot;:&quot;小于&quot;&lt;span&gt;;
console.log(c)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;8.js的流程控制和循环&lt;/h2&gt;
&lt;p&gt;if语句:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; age = 19
            &lt;span&gt;if&lt;/span&gt;(age&amp;gt;18&lt;span&gt;){
                console.log(&lt;/span&gt;&quot;欢迎来到我们这个网站&quot;&lt;span&gt;)
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                console.log(&lt;/span&gt;&quot;对不起，你还未成年&quot;&lt;span&gt;)
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; swicth:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; userType = &quot;穷鬼VIP&quot;
            
            &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(userType){
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;vip&quot;&lt;span&gt;:
                    console.log(&lt;/span&gt;&quot;随意看全场视频，还没有广告&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;穷鬼VIP&quot;&lt;span&gt;:
                    console.log(&lt;/span&gt;&quot;随意看，但有广告&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;普通用户&quot;&lt;span&gt;:
                    console.log(&lt;/span&gt;&quot;请充值，充值会让你更强大&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    console.log(&lt;/span&gt;&quot;你是属于非法进入&quot;&lt;span&gt;);
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;for语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;10;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                console.log(i)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             
&lt;span&gt; 5&lt;/span&gt;             
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; arr = ['习大大向中国国际服务贸易交易会致贺信','句句箴言，品读习大大引用的诗词典故','习大大：培养一茬茬、一代代合格的红军传人'&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; libiao = document.querySelector('#libiao'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;arr.length;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 libiao.innerHTML += '&amp;lt;li&amp;gt;'+ arr[i] + &quot;&amp;lt;/li&amp;gt;&quot;
&lt;span&gt;10&lt;/span&gt;             }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; n = 1
&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; result=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;(n&amp;lt;=100&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 result +=&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 n++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            console.log(result)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; n = 1
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; result=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 
&lt;span&gt;13&lt;/span&gt;                 result +=&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 n++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             }&lt;span&gt;while&lt;/span&gt;(n&amp;lt;=100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             console.log(result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Continue&lt;/p&gt;
&lt;p&gt;跳过当次循环&lt;/p&gt;
&lt;p&gt;Break&lt;/p&gt;
&lt;p&gt;跳过整个循环块&lt;/p&gt;
&lt;h2&gt;9.js函数：&lt;/h2&gt;
&lt;h3&gt;函数定义的方式&lt;/h3&gt;
&lt;p&gt;方式1：function count(a){ return x }&lt;/p&gt;
&lt;p&gt;方式2：var count = function(){}&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;say();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;            info();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; say(){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; n = '李二'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 console.log('张大娘'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; info = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;                 console.log('皇帝'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;             }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;函数的参数&lt;/h3&gt;
&lt;p&gt;对函数调用时候，不会对参数做任何的检测。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;arguments&lt;/strong&gt;&lt;strong&gt;关键词：获取调用函数时候的所有参数&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;函数的返回值&lt;/h3&gt;
&lt;p&gt;用return直接返回对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：如果没有写返回值，那么函数默认会返回undefined&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 10.js数组：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JavaScript的数组是可变长，里面的内容也是可以随意的替换，没有类型的限制&lt;/p&gt;
&lt;p&gt;创建数组的方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!DOCTYPE html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;head&amp;gt;
&lt;span&gt; 4&lt;/span&gt;         &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;/head&amp;gt;
&lt;span&gt; 7&lt;/span&gt;     &amp;lt;body&amp;gt;
&lt;span&gt; 8&lt;/span&gt;         &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、字面量的方式创建数组&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; arr1 = [&quot;蔡徐坤&quot;,&quot;郭敬明&quot;,&quot;范冰冰&quot;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、new Array()创建数组&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; arr2 = &lt;span&gt;new&lt;/span&gt; Array(&quot;苹果&quot;,1,&quot;香蕉&quot;,&lt;span&gt;function&lt;/span&gt;(){console.log(123&lt;span&gt;)})
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            console.log(arr1)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            console.log(arr2)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组内容的获取&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             console.log(arr1[0&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             console.log(arr1[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             arr2[3&lt;span&gt;]()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组内容的设置&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             arr2[3]  = 3
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            console.log(arr2)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过循环输出列表内容&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;arr1.length;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                console.log(arr1[i])
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列==》先进先出&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;栈==》先进后出&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &amp;lt;/script&amp;gt;
&lt;span&gt;33&lt;/span&gt;     &amp;lt;/body&amp;gt;
&lt;span&gt;34&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数组实现队列的2个方法:&lt;/p&gt;
&lt;p&gt;Push：在数组最后添加元素&lt;/p&gt;
&lt;p&gt;Shift:在数组的最前面删除元素&lt;/p&gt;

&lt;p&gt;数组实现栈的2个方法：&lt;/p&gt;
&lt;p&gt;Push:在数组最后添加元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!DOCTYPE html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt; 3&lt;/span&gt;     &amp;lt;head&amp;gt;
&lt;span&gt; 4&lt;/span&gt;         &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt;         &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;/head&amp;gt;
&lt;span&gt; 7&lt;/span&gt;     &amp;lt;body&amp;gt;
&lt;span&gt; 8&lt;/span&gt;         &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; duilie = [&quot;范冰冰&quot;,&quot;李晨&quot;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            console.log(duilie)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             duilie.push('蔡徐坤'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            console.log(duilie)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             duilie.push(&quot;郭敬明&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            console.log(duilie)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;push将内容添加到数组最后&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             
&lt;span&gt;17&lt;/span&gt;             
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;去掉数组的第一个元素&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;duilie.shift()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            console.log(duilie)&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;去掉数组的最后一个元素&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;duilie.pop()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            console.log(duilie)&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在数组的第一个元素前面插入数据&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;duilie.unshift(&quot;雷军&quot;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            console.log(duilie)&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在duilie.slice(0,2),在数组从索引0开始切，切到索引2的位置，不包括2；&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;console.log(duilie.slice(0,2))
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            console.log(duilie)&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;splice可以增加或者是删除指定元素，duilie.splice(删除或者增加索引的位置,删除多少个元素,增加的内容（可选）)&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;console.log(duilie.splice(0,2,&quot;迪丽热巴&quot;,&quot;古力娜扎&quot;))
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            console.log(duilie)&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;             
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并两个数组&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             duilie = duilie.concat(['葡萄','香蕉',&quot;雪梨&quot;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相当于for循环&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;             duilie.forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                console.log(item)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             
&lt;span&gt;45&lt;/span&gt;             
&lt;span&gt;46&lt;/span&gt;         &amp;lt;/script&amp;gt;
&lt;span&gt;47&lt;/span&gt;     &amp;lt;/body&amp;gt;
&lt;span&gt;48&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 28 May 2019 15:11:00 +0000</pubDate>
<dc:creator>曾经有一首歌</dc:creator>
<og:description>1JavaScript语言： 一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。 广泛应用于：PC浏览器/PC软件/手机浏览器/手机app/微信小程序/微信公众号开发/硬件开发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ruckly/p/10941031.html</dc:identifier>
</item>
<item>
<title>算法导论课后习题解答 第一部分 练习1.1-1-&gt;1.1-5 - godoforange</title>
<link>http://www.cnblogs.com/godoforange/p/10940674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/godoforange/p/10940674.html</guid>
<description>&lt;p&gt;很高兴能和大家一起共同学习算法导论这本书。笔者将在业余时间把算法导论后面的题解以博文的形式展现出来希望能得到大家的支持谢谢。如果有可能我会做一些教学视频免费的供大家观看。&lt;/p&gt;
&lt;p&gt;练习题选自算法导论中文第三版第6页中的练习。&lt;/p&gt;
&lt;h2&gt;1.1-1 给出现实生活中需要&lt;span&gt;排序&lt;/span&gt;的一个例子或者现实生活中需要&lt;span&gt;计算凸壳&lt;/span&gt;的一个例子。&lt;/h2&gt;
&lt;p&gt;这个问题有俩个子问题。我一一解答：&lt;/p&gt;
&lt;p&gt;(1) 首先是排序，日常需要排序的地方很多，例如今日微博热搜等等这个不用细说了。&lt;/p&gt;
&lt;p&gt;(2)但是关于第二个问题我需要多写一点。&lt;/p&gt;
&lt;p&gt;第一这本书的&lt;span&gt;翻译的地方有误&lt;/span&gt;，凸壳在这里指的是计算几何中的多边形凸包问题。&lt;/p&gt;
&lt;p&gt;下面摘选自百度百科。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
⒈对于一个集合D，D中任意有限个点的凸组合的全体称为D的凸包。
⒉对于一个集合D，所有包含D的凸集之交称为D的凸包。
可以证明，上述两种定义是等价的
概念
示例图（一）
示例图（一）
1 　点集Q的凸包（convex hull）是指一个最小凸多边形，满足Q中的点或者在多边形边上或者在其内。右图中由红色线段表示的多边形就是点集Q={p0,p1,...p12}的凸包。
2 　一组平面上的点，求一个包含所有点的最小的凸多边形，这就是凸包问题了。这可以形象地想成这样：在地上放置一些不可移动的木桩，用一根绳子把他们尽量紧地圈起来，并且为凸边形，这就是凸包了。
数学定义：设S为欧几里得空间  的任意子集。包含S的最小凸集称为S的凸包，记作conv(S)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201905/1590876-20190528221131266-1419770736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 凸包问题在实际中的应用很广泛，它可以应用于冶金术、城市规划、图像处理、统计学等等多个领域。&lt;/p&gt;
&lt;h2&gt;1.1-2 除速度外，在真实环境中还可能使用哪些其他有关效率的量度？&lt;/h2&gt;
&lt;p&gt;学过高中物理的都知道有功率吧。实际生产中还有开发效率，生产效率。&lt;/p&gt;
&lt;p&gt;别的笔者暂时也想不出来。&lt;/p&gt;
&lt;h2&gt;1.1-3 选择一种你以前&lt;span&gt;已知的数据结构&lt;/span&gt;并讨论其优势和局限。&lt;/h2&gt;
&lt;p&gt;笔者在这里列举一个图的数据结构-------邻接矩阵。并以PAT练习平台中的某一道题来举例子。&lt;/p&gt;
&lt;p&gt;首先介绍一下邻接矩阵：（图画的不咋好请谅解）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201905/1590876-20190528224434574-1004524156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里 我们完全可以用一个矩阵来将右边的无向图的节点和节点之间的关系完美的表现出来，但是当我们的节点过多，而关系少的时候，这个邻接矩阵就显得过于臃肿了，所以我们可以总结出以下俩点：&lt;/p&gt;
&lt;p&gt;1）邻接矩阵的优势在于描述通俗易懂，算法实现起来简单，在稠密矩阵中效率依然很高。&lt;/p&gt;
&lt;p&gt;2）邻接矩阵的局限性在于在处理的节点过多的时候（即稀疏矩阵），无论是时间复杂度还是空间复杂度均过高。&lt;/p&gt;
&lt;p&gt;下面这道题是一道练手的简单题，有兴趣的朋友可以去做一下来感受一下邻接矩阵和稀疏矩阵的不同。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pintia.cn/problem-sets/994805342720868352/problems/994805514284679168&quot; target=&quot;_blank&quot;&gt;题目链接：&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590876/201905/1590876-20190528223558537-2026251944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这道题如果你认真的去做了，你就会发现。虽然邻接矩阵无论是在算法实现上还是结构都很简单，但是无论如何也不能避免他在遍历的时候的时间复杂度过高，（一般都是O^2级别）。&lt;/p&gt;
&lt;p&gt;因此一般在处理稀疏矩阵的时候，我们一般选择邻接表的实现方法去替代邻接矩阵的实现方法。&lt;/p&gt;
&lt;h2&gt; 1.1-4 前面给出的最短路径与旅行商问题有哪些相似之处又有哪些不同？&lt;/h2&gt;
&lt;p&gt;旅行商问题简而言之就是选出所有可能的候选路径，而非最短路径。&lt;/p&gt;
&lt;p&gt;它们是相似的，因为每个人都必须走一个图并在其中找到一条路径。&lt;/p&gt;
&lt;p&gt;他们又是不同的，最短路径仅需要两点之间的路径，而旅行推销员需要在返回第一点的更多点之间的路径。&lt;/p&gt;
&lt;p&gt;至于如何寻找最短路径最简单的方法就是进行BFS（宽度优先遍历）。&lt;/p&gt;
&lt;p&gt;下面是摘取百度百科的介绍&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
已知图G=&lt;span&gt;(V,E)和一个源顶点s，宽度优先搜索以一种系统的方式探寻G的边，从而“发现”s所能到达的所有顶点，并计算s到所有这些顶点的距离(最少边数)，该算法同时能生成一棵根为s且包括所有可达顶点的宽度优先树。对从s可达的任意顶点v，宽度优先树中从s到v的路径对应于图G中从s到v的最短路径，即包含最小边数的路径。该算法对有向图和无向图同样适用。
之所以称之为宽度优先算法，是因为算法自始至终一直通过已找到和未找到顶点之间的边界向外扩展，就是说，算法首先搜索和s距离为k的所有顶点，然后再去搜索和S距离为k&lt;/span&gt;+l的其他顶点。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通俗点说，就是在每一次遍历的时候，将每个子节点放入一个队列中，然后再不断递归以此寻找最短路径。&lt;/p&gt;
&lt;p&gt;对于最短路径的寻找方法还有俩种最经典的。&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;
&lt;div readability=&quot;28&quot;&gt;
&lt;h4&gt;1）Dijkstra（迪杰斯特拉）算法&lt;/h4&gt;
&lt;p&gt;他的算法思想是按路径长度递增的次序一步一步并入来求取，是贪心算法的一个应用，用来解决单源点到其余顶点的最短路径问题。&lt;/p&gt;
&lt;h4&gt;算法思想&lt;/h4&gt;
&lt;p&gt;首先，我们引入一个辅助向量D，它的每个分量D[i]表示当前找到的从起始节点v到终点节点vi的最短路径的长度。它的初始态为：若从节点v到节点vi有弧，则D[i]为弧上的权值，否则D[i]为∞，显然，长度为&lt;strong&gt;D[j] = Min{D[i] | vi ∈V}&lt;/strong&gt;的路径就是从v出发最短的一条路径，路径为(v, vi)。&lt;br/&gt;那么，下一条长度次短的最短路径是哪一条呢？假设次短路径的终点是vk，则可想而知，这条路径或者是(v, vk)或者是(v, vj, vk)。它的长度或者是从v到vk的弧上的权值，或者是D[j]和从vj到vk的权值之和。&lt;/p&gt;
&lt;p&gt;一般情况下，假设S为已知求得的最短路径的终点集合，则可证明：一下条最短路径（设其终点为x）或者是弧(v, x)或者是中间只经过S中的顶点而最后到达顶点x的路径。这可用反证法来证明，假设此路径上有一个顶点不在S中，则说明存在一条终点不在S中而长度比此路径短的路径。但是这是不可能的。因为，我们是按路径常度的递增次序来产生个最短路径的，故长度比此路径端的所有路径均已产生，他们的终点必定在S集合中，即假设不成立。&lt;/p&gt;
&lt;p&gt;因此下一条次短的最短路径的长度是：&lt;strong&gt;D[j] = Min{D[i] | vi ∈ V - S}&lt;/strong&gt;，其中，D[i]或者是弧(v, vi)的权值，或者是D[k](vk ∈ S)和弧(vk, vi)上权值之和。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;h4&gt;2）Floyd（弗洛伊德）算法&lt;/h4&gt;
&lt;p&gt;Floyd算法是一个经典的&lt;strong&gt;动态规划&lt;/strong&gt;算法。是解决&lt;strong&gt;任意两点间的最短路径&lt;/strong&gt;(称为多源最短路径问题)的一种算法，可以正确处理有向图或负权的最短路径问题。（动态规划算法是通过拆分问题规模，并定义问题状态与状态的关系，使得问题能够以递推（分治）的方式去解决，最终合并各个拆分的小问题的解为整个问题的解。）&lt;/p&gt;
&lt;h4&gt;算法思想&lt;/h4&gt;
&lt;p&gt;从任意节点i到任意节点j的最短路径不外乎2种可能：&lt;strong&gt;1)直接从节点i到节点j，2)从节点i经过若干个节点k到节点j&lt;/strong&gt;。所以，我们假设arcs(i,j)为节点i到节点j的最短路径的距离，对于每一个节点k，我们检查arcs(i,k) + arcs(k,j) &amp;lt; arcs(i,j)是否成立，如果成立，证明从节点i到节点k再到节点j的路径比节点i直接到节点j的路径短，我们便设置arcs(i,j) = arcs(i,k) + arcs(k,j)，这样一来，当我们遍历完所有节点k，arcs(i,j)中记录的便是节点i到节点j的最短路径的距离。（由于动态规划算法在执行过程中，需要保存大量的临时状态（即小问题的解），因此它天生适用于用矩阵来作为其数据结构，因此在本算法中，我们将不使用Guava-Graph结构，而采用邻接矩阵来作为本例的数据结构）&lt;/p&gt;
&lt;/div&gt;
这俩种算法如果以后有机会，我会将具体实现介绍给大家。&lt;/div&gt;


&lt;h2&gt;1.1-5 提供一个现实生活的问题，其中只有最佳解才行。然后提供一个问题，其中近似最佳的一个解也足够好。&lt;/h2&gt;
&lt;p&gt;这个。。。。呵呵呵呵&lt;/p&gt;

&lt;p&gt;当你考研的时候，作为理工科的你最佳选择是去麻省理工大学继续深造。&lt;/p&gt;
&lt;p&gt;最后发现只要是个大学就行。&lt;/p&gt;

&lt;p&gt;近似解。。呵呵呵&lt;/p&gt;


&lt;h3&gt;总结：这一篇的习题侧重于对于算法的启发，希望我能在空余时间，将后面的各式各样的练习题答案以博客的形式发表出来，并加上我自己的一些见解。&lt;/h3&gt;
</description>
<pubDate>Tue, 28 May 2019 15:08:00 +0000</pubDate>
<dc:creator>godoforange</dc:creator>
<og:description>很高兴能和大家一起共同学习算法导论这本书。笔者将在业余时间把算法导论后面的题解以博文的形式展现出来希望能得到大家的支持谢谢。如果有可能我会做一些教学视频免费的供大家观看。 练习题选自算法导论中文第三版</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/godoforange/p/10940674.html</dc:identifier>
</item>
<item>
<title>朱晔的互联网架构实践心得S2E7:漫谈平台架构的工作（基础架构、基础服务、基础平台、基础中间件等等） - lovecindywang</title>
<link>http://www.cnblogs.com/lovecindywang/p/10941007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecindywang/p/10941007.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;程序开发毕竟还不是搬砖这种无脑体力劳动，需要事先有标准，有架构，有设计，绝对不是新公司今天创立，明天就可以开始编码的。其实很多公司在起步的时候没有财力和资源建设独立的基础架构或平台架构部门，甚至运维团队都没有，但是这不妨碍我们心中有一个蓝图知道努力的方向，本文我们就简单聊聊平台架构相关的工作内容（或者说作为一个技术管理，应该去梳理、统一、明确的部分）的蓝图。由于本文覆盖的内容比较多，只能抛砖引玉大概提一些，无法一一展开太详细的东西。图中的数字是我认为的优先级，仅供参考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/powerzhuye/odmb3b9fsnqd2jj0r2rek32j/Framework.jpg&quot; alt=&quot;Framework.jpg-1246.5kB&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;规范&quot;&gt;规范&lt;/h2&gt;
&lt;p&gt;规范它虽然不是一个实际的代码或组件，只是一个文档，但是我觉得非常重要。没有规范，那么员工加下去任何一行新代码可能都是错的，整个研发流程也可能会因为没有规范导致很多不必要的事故产生。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码提交&amp;amp;分支管理规范，我们可以在gitflow基础上根据实际情况（结合运维流程，项目复杂度，团队人数，发布周期）进行细化，涉及到：
&lt;ul&gt;&lt;li&gt;有哪几个常驻分支，哪几个临时分支？&lt;/li&gt;
&lt;li&gt;分支命名规范？&lt;/li&gt;
&lt;li&gt;提交代码描述规范？&lt;/li&gt;
&lt;li&gt;分支迁出和合并的时机？&lt;/li&gt;
&lt;li&gt;哪些分支普通开发没有权限直接提交？&lt;/li&gt;
&lt;li&gt;测试用什么分支，上线又用什么分支？&lt;/li&gt;
&lt;li&gt;多版本并行开发如何提测？&lt;/li&gt;
&lt;li&gt;Hotfix如何处理分支？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;编码规范，比如Java代码可以以阿里Java开发手册为基础，大家一起过一遍，针对项目的实际情况（时间要求，对性能要求），选择其中的一些坚决执行，然后补充一些其它的。我们也可以让大家的IDE使用（导入）统一的Code Style Template来要求一致的编码格式。因为Code Style的不一致导致提交的时候大范围的代码新增删除完全会污染提交，让大家很难看出提交的代码到底改了什么。&lt;/li&gt;
&lt;li&gt;数据库设计规范。阿里Java开发手册里包含了一小部分数据库设计规范，术业有专攻，这个还是应该请资深DBA来给出一定的规范，包括但不限于：
&lt;ul&gt;&lt;li&gt;命名（表和字段前缀后缀命名，外键字段命名、通用字段命名统一）规范&lt;/li&gt;
&lt;li&gt;字段设计类型规范&lt;/li&gt;
&lt;li&gt;字段冗余规范&lt;/li&gt;
&lt;li&gt;通用字段规范&lt;/li&gt;
&lt;li&gt;索引使用规范&lt;/li&gt;
&lt;li&gt;……。可以参考《朱晔的互联网架构实践心得S2E1：业务代码究竟难不难写？》中提到的一些内容&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;项目结构规范，对于Java Maven项目来说基本目录结构比较统一，对于其它语言的项目（比如Python），目录结构没有一定标准的话，项目源码结构会千奇百怪，最好还是对于项目结构有一个规范，包括：
&lt;ul&gt;&lt;li&gt;三层结构目录划分&lt;/li&gt;
&lt;li&gt;多环境（Profile）配置文件&lt;/li&gt;
&lt;li&gt;服务接口、服务实现、Web、Job模块命名&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最后是项目管理流程，有一些公司会有专门的PMO，有一些初创公司研发Leader也会充当PMO的角色，虽然这个活一般和平台架构没啥关系，不管怎么样，既然是项目肯定少不了项目管理，作为技术管理角色需要关注的一个点，项目管理流程也是比较重要的：
&lt;ul&gt;&lt;li&gt;迭代周期，迭代周期中的大环节大概发生的时间点&lt;/li&gt;
&lt;li&gt;开哪些会，开会时间点是？（日站会、周例会、启动会、回顾会、复盘会、排期会、PRD预评审会、PRD评审会、测试用例评审会、上线方案讨论会）&lt;/li&gt;
&lt;li&gt;项目生命周期中每一个角色产出哪些文档？&lt;/li&gt;
&lt;li&gt;任务在哪里管理，每一个角色怎么去维护任务状态的流转？不可能任务的每一个状态的流转都由PMO来做&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基础框架&quot;&gt;基础框架&lt;/h2&gt;
&lt;p&gt;使用一些基础框架来做应用开发是必须的，对于Java技术栈，大家所熟悉的框架有Spring Cloud全家桶、Spring Boot套件（封装的各种starters）、Mybatis等，直接使用这些框架进行开发是可以的，但是更建议的是由基础架构团队封装自己的框架，自己做一层封装，我们可以以类似Spring Boot Starter的模式，为所有的组件封装自己的Starter模块，好处是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;方便进行统一的外部依赖类库 &amp;amp; 库版本管理和约定&lt;/li&gt;
&lt;li&gt;方便针对公司内部情况做更合适的自动配置（甚至实现0配置）&lt;/li&gt;
&lt;li&gt;如果内部技术栈是异构的话，使用统一的框架有助于技术栈后端基础设施的打通&lt;/li&gt;
&lt;li&gt;为所有的模块打通监控，自动配置AOP做相应的拦截统一抓取获取监控数据&lt;/li&gt;
&lt;li&gt;模块之间可以相互整合和配合，实现1+1&amp;gt;2的效果&lt;/li&gt;
&lt;li&gt;还有很重要的一点是，我们可以提供相应的管控后台来配合框架使用，把框架的配置、管理和审计暴露在控制台上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实说白了，就是使用自己封装的类库占坑，哪怕只是一层浅浅的封装，也是很有好处的，不仅仅是做了各种统一（使用框架的统一，框架版本号的统一），更多的是因为占了坑（当然，要扩展做Java agent动态字节码注入的方式也是可行的，这种方式的缺点是没有办法提供API给业务使用），以后直接可以通过升级框架通过IOC组件替换+AOP直接做各种扩展（不需要再麻烦业务团队了）。&lt;/p&gt;
&lt;p&gt;我们来看看这里脑图上大概列出的一些业务开发需要用到的常见模块（可以看一下我们公司开源的框架https://github.com/ke-finance/summerframework ，当然开源出来的模块比较少，实际内部封装了这里提到的所有模块）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Web MVC：可以基于Spring MVC进行封装，增加一些模板引擎的支持等&lt;/li&gt;
&lt;li&gt;数据访问：可以基于MyBatis或Mybatis Plus+Druid数据源进行封装，做一些额外的功能，比如敏感数据加密保存&lt;/li&gt;
&lt;li&gt;RPC服务调用或微服务：可以基于Dubbo或Spring Cloud（Feign+Eureka）进行封装，在客户端方面扩展一些更智能的LB算法，以及路由策略（比如灰度）等功能&lt;/li&gt;
&lt;li&gt;Web API：可以在Spring MVC+Swagger UI基础上实现功能，提供统一的RESTful服务端API的标准，比如规范化API版本、响应结构体自动包装（自适应）、错误包装、HATEOAS超媒体资源导航整合、数据加解密实现、Collection资源的规范化、自动的mock接口的实现等&lt;/li&gt;
&lt;li&gt;配置：可以基于携程Apollo（&lt;a href=&quot;https://github.com/ctripcorp/apollo&quot; class=&quot;uri&quot;&gt;https://github.com/ctripcorp/apollo&lt;/a&gt; ）客户端进行封装，做自动配置&lt;/li&gt;
&lt;li&gt;消息：可以封装RabbitMQ、RocketMQ的客户端实现统一的消息API，然后扩展事务消息（收发消息和业务逻辑本地事务在一个事务中处理）等功能&lt;/li&gt;
&lt;li&gt;缓存：可以基于CacheCloud（&lt;a href=&quot;https://github.com/sohutv/cachecloud&quot; class=&quot;uri&quot;&gt;https://github.com/sohutv/cachecloud&lt;/a&gt; ）提供Redis缓存服务&lt;/li&gt;
&lt;li&gt;调度：可以封装XXLJob（&lt;a href=&quot;https://github.com/xuxueli/xxl-job/&quot; class=&quot;uri&quot;&gt;https://github.com/xuxueli/xxl-job/&lt;/a&gt; ）或ElasticJob（&lt;a href=&quot;http://elasticjob.io%EF%BC%89%E6%8F%90%E4%BE%9B%E8%B0%83%E5%BA%A6%E6%9C%8D%E5%8A%A1&quot; class=&quot;uri&quot;&gt;http://elasticjob.io）提供调度服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;日志监控：可以基于Micrometer实现应用打点，找一个APM（Skywalking &lt;a href=&quot;https://github.com/apache/skywalking&quot; class=&quot;uri&quot;&gt;https://github.com/apache/skywalking&lt;/a&gt; 或Pinpoint &lt;a href=&quot;https://github.com/naver/pinpoint&quot; class=&quot;uri&quot;&gt;https://github.com/naver/pinpoint&lt;/a&gt; ）整合trace功能，扩展logback做日志脱敏，扩展Spring Boot Actuator Endpoint等功能&lt;/li&gt;
&lt;li&gt;锁：可以基于Redisson封装分布式锁，使用统一的API来提供内存锁和分布式锁&lt;/li&gt;
&lt;li&gt;分布式事务：主要是两块，同步2PC分布式事务处理（比如我们开源的https://github.com/ke-finance/dts ），异步的saga思想的实现，参考https://github.com/eventuate-tram/eventuate-tram-sagas 。&lt;/li&gt;
&lt;li&gt;弹性：流控+隔离+熔断，考虑基于https://github.com/alibaba/Sentinel 来实现，可以是独立的模块提供服务，也可以整合到Web API或RPC模块中去&lt;/li&gt;
&lt;li&gt;安全：可以基于Spring Security进行扩展，加入符合业务需求的风控策略进去&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基础平台&quot;&gt;基础平台&lt;/h2&gt;
&lt;p&gt;基础平台（管理平台）需要和基础框架打配合，框架是开发的时候使用的，平台更多的是开发或运维人员做技术运营时使用的。很多开源框架都已经提供了管理后台，我们需要做的可能只是一些小修改，比如包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打通公司内部自己的账号登录体系和权限体系&lt;/li&gt;
&lt;li&gt;根据不同的环境（开发、测试、灰度、生产）部署多份管理控制台&lt;/li&gt;
&lt;li&gt;根据需要看是否需要做多租户的改造，实现业务隔离&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有些平台是重流程的，这些可能需要自主开发，大概介绍一下脑图上提到的这些：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置平台：如果使用了携程Apollo，自然就是使用Apollo的管理后台&lt;/li&gt;
&lt;li&gt;微服务管理平台：这里我列出了两个方面的工作，一个是服务中心，更多的是服务维护、管理、监控方面的功能，可以基于Spring Cloud Admin进行改造；一个是服务集市，更多的是服务标准化方面的管理，比如服务上线需要的文档，接入的监控系统，以及上线后统一的文档中心，服务集市类似于App Store的概念&lt;/li&gt;
&lt;li&gt;缓存平台，如果使用了CacheCloud，可以使用CacheCloud的管理后台&lt;/li&gt;
&lt;li&gt;日志平台，分为两块，一块是日志收集展示基本ELK已经是标准；还有一块是日志异常报警，可以自己来开发，基于Kafka消费日志异步做日志筛选+聚合结合自己公司的IM和邮件体系做报警&lt;/li&gt;
&lt;li&gt;数据库管理平台：
&lt;ul&gt;&lt;li&gt;DDL/DML工作流：开发提交申请，主管审批，自动执行，外加自动的风险检测，优化建议等&lt;/li&gt;
&lt;li&gt;DDL/DML变更通知：方便大数据以及运营团队针对感兴趣的数据库和表进行订阅，在DDL应用到各个环境（测试、生产）的时候能够第一时间得到通知可以进行人工、自动处理（类似before，after Filter的概念）&lt;/li&gt;
&lt;li&gt;数据库知识库：有一个统一的地方查看数据库的结构说明、字典枚举的定义&lt;/li&gt;
&lt;li&gt;当然数据库管理平台还可以进一步做数据库监控、慢SQL优化原因分析等功能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;全链路追踪平台：比如如果使用Skywalking的话可以实现它提供的管理台，主要功能无非是依赖拓扑分析、Trace查看、服务性能分析等&lt;/li&gt;
&lt;li&gt;指标查看平台：分为两块，Dashboard一般可以考虑直接使用Grafana，报警的话虽然Grafana也有Alert但是还是建议在更底层（数据源头）去做，可以基于流处理去做或基于定时拉的方式去实现&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;基础中间件&quot;&gt;基础中间件&lt;/h2&gt;
&lt;p&gt;中间件是指独立部署的不具有业务逻辑耦合 的通用服务，存储服务在广义上归到中间件也不是不可以，这里大概列了几个典型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MQ代理（Broker，不是Proxy），比如RabbitMQ、RocketMQ、Kafka&lt;/li&gt;
&lt;li&gt;API网关，有很多开源的网关实现，比如Kong（&lt;a href=&quot;https://github.com/Kong/kong&quot; class=&quot;uri&quot;&gt;https://github.com/Kong/kong&lt;/a&gt; ）、Spring Cloud Gateway，我们也实现了一套https://github.com/ke-finance/tesla ，一般网关的主要功能是调用路由、协议转换、调用编排，然后也会以插件和过滤器形式提供很多安全、弹性方面的扩展功能&lt;/li&gt;
&lt;li&gt;DB代理，比如类似https://github.com/flike/kingshard 和https://github.com/Qihoo360/Atlas 的MySQL Proxy，实现数据库的读写分离、分表分库、故障转移、弹性处理、监控、SQL优化等功能&lt;/li&gt;
&lt;li&gt;ES集群，也可以理解为中间件，毕竟ES其实做的就是基于Lucene的分布式集群管理工作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些中间件虽然很多时候做的是Proxy背后的其它服务，但是节点本身很可能是有状态的，也需要考虑中间件本身的高可用性问题。&lt;/p&gt;
&lt;h2 id=&quot;基础服务&quot;&gt;基础服务&lt;/h2&gt;
&lt;p&gt;一般而言如果公司具有多个项目的话，项目之间肯定会用到一些通用的内部和外部能力，这些能力和业务逻辑没有太多关系，可以考虑把这些能力进行统一的封装独立部署以微服务形式提供出来，这样所有项目都可以快速对接。&lt;/p&gt;
&lt;p&gt;在这里把基础服务分为了两类，一类是没有业务逻辑的纯基础服务，往往是对接封装一个或多个外部服务通道，另外一类是包含一些业务的业务基础服务。对于第一类基础服务你可能会想，既然是对接外部服务通道直接使用他们的SDK或服务是不是直接在业务系统使用那些三方SDK就好了，基础服务是需要做什么呢？我觉得基础服务应该这么封装：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;封装外部服务的SDK，一般而言比如短信也好、推送也好、存储也好，都会使用多家提供的服务做备份、降级，通过我们的SDK提供统一的对内API，屏蔽不同SDK的API差异&lt;/li&gt;
&lt;li&gt;提供一个服务端，在服务端做数据落地，落地的目的有几个：
&lt;ul&gt;&lt;li&gt;方便和外部进行服务消费对账&lt;/li&gt;
&lt;li&gt;方便出错的时候查找原因&lt;/li&gt;
&lt;li&gt;方便和外部服务同步调用状态（比如短信到达）&lt;/li&gt;
&lt;li&gt;方便进行服务余额预警&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;服务端除了做数据落地，由统一的服务端做出口的好处是：
&lt;ul&gt;&lt;li&gt;做权限控制，一般而言即使是公司内部的项目进行基础服务的调用应该也是需要先申请再使用的，甚至需要做服务调用量的控制（类似在内部再实现一层SaaS）&lt;/li&gt;
&lt;li&gt;收敛调用源IP&lt;/li&gt;
&lt;li&gt;集中管理调用外部SaaS服务的密钥&lt;/li&gt;
&lt;li&gt;外部服务的降级和切换策略更换比较方便&lt;/li&gt;
&lt;li&gt;给接入方做报警&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;做一个管理后台，虽然外部服务提供方作为SaaS产品一般都会有不错的控制台（其实更多的时候，不可能把外部服务的控制台的权限放给所有人看，内部业务方看自己的基础服务控制台即可），但是我们内部做一个管理后台意义还是很大的，主要的功能一般是：
&lt;ul&gt;&lt;li&gt;统一登录&lt;/li&gt;
&lt;li&gt;账号（包括Secret）申请和分配，以及配额、限流等配置（管理员权限）&lt;/li&gt;
&lt;li&gt;调用记录（请求、结果）查看&lt;/li&gt;
&lt;li&gt;调用模板的配置（考虑一下是不是放开服务的使用，比如短信、邮件、推送一般是基于模板的，模板需要内部外部审核后才能使用）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果每一个服务都有控制台的话，可以大大方便业务方的自主接入和问题排查，这是基础服务封装非常有价值的一个点，对于大点的公司内部项目众多就更需要把基础服务在内部进行SaaS化了，而且最好对于不同的基础服务打通接入方（统一的地方来申请所有需要的基础服务）。&lt;/p&gt;
&lt;p&gt;这里脑图上大概列了一些常见的基础服务和业务服务，每一个公司根据自己的业务一般都会不尽相同，基础服务包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;短信：接入多个短信渠道，根据政策、费率、到达率等情况路由&lt;/li&gt;
&lt;li&gt;文件存储：接入多个小文件存储服务（比如七牛、腾讯云），根据存储服务提供的功能，文件大小、费率等情况路由&lt;/li&gt;
&lt;li&gt;邮件：接入内部和外部（比如SendCloud）的邮件服务，根据使用场景进行路由&lt;/li&gt;
&lt;li&gt;推送：接入多个推送渠道（比如极光、个推），并且做用户、设备的关系维护&lt;/li&gt;
&lt;li&gt;唯一ID：全局唯一ID的生成&lt;/li&gt;
&lt;li&gt;图形、滑动、点击、智能验证码：提供统一的验证码服务，可以根据场景自动选择验证码类型&lt;/li&gt;
&lt;li&gt;电子签章：接入多个电子签章服务，根据费率等因素路由&lt;/li&gt;
&lt;li&gt;地图服务：接入多个外部地图服务，根据功能以及接入方使用的地图进行服务选择&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;业务服务包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RBAC权限控制：统一的RBAC配置后台，以及方便的SDK&lt;/li&gt;
&lt;li&gt;通用表单服务：根据后台配置的表单自动生成界面，以及表单信息的收集&lt;/li&gt;
&lt;li&gt;状态机：可以借鉴https://github.com/hekailiang/squirrel ，基于状态(State)、行为(Action)、转移(Transition)、条件(Condition)等概念，构建基于数据库的状态机平台&lt;/li&gt;
&lt;li&gt;统一支付：聚合支付，业务方可以快速接入多种支付渠道，并且统一支付可以提供统一的SDK和H5来实现统一的支付收银台&lt;/li&gt;
&lt;li&gt;工作流、爬虫、SSO……不详细说明了&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;工程效率&quot;&gt;工程效率&lt;/h2&gt;
&lt;p&gt;接下去也简单提一下工程效率和运维范畴的事情，虽然这和平台架构没啥太大关系，但是这两块是很重要的技术基建工作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;源代码仓库：比如可以选择Gitlab或atlassian三件套的Bitbucket&lt;/li&gt;
&lt;li&gt;内部类库仓库：比如Java的Maven仓库，可以自己搭建Nexus仓库&lt;/li&gt;
&lt;li&gt;项目管理平台：可以选择SaaS产品（比如Tower、Teambition），比较有名的是atlassian三件套的Jira&lt;/li&gt;
&lt;li&gt;知识管理平台：可以选择SaaS或开源Wiki产品，比较有名的是atlassian三件套的Confluence&lt;/li&gt;
&lt;li&gt;Bug管理平台：比如可以选择禅道或直接复用Jira&lt;/li&gt;
&lt;li&gt;代码质量分析：比如可以搭建SonarQube平台&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;运维&quot;&gt;运维&lt;/h2&gt;
&lt;p&gt;这里提到的一些运维系统相关工作有的公司是架构团队来建设的，列一个大概：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CI/CD平台：一般而言需要自己结合公司的工作流程做一套CI/CD平台（底层可以基于Jenkins（或直接SSH+脚本）封装），这个平台需要结合公司的工作流程去做，比如谁可以发起流程，每一个发布环节需要谁来审批，发布时间窗口等等&lt;/li&gt;
&lt;li&gt;DNS平台：一般会直接使用域名管理商的平台或类似DNSPod这种平台&lt;/li&gt;
&lt;li&gt;CMDB：一般都会根据自己的情况自建平台，进行运维各个层次相关资源的元数据以及配置管理&lt;/li&gt;
&lt;li&gt;监控：一般会基于Prometheus+Grafana+Zabbix等开源项目来打造运维的基础监控&lt;/li&gt;
&lt;li&gt;CDN平台：一般是用云的，比如七牛、又拍或三大云服务的CDN都可以&lt;/li&gt;
&lt;li&gt;集群配置管理：这个不是指CMDB，是指批量进行集群配置应用操作，管理操作的平台，比如Chef、Puppet、Ansible、Fabric，一般也是基于开源改造封装或直接用开源的&lt;/li&gt;
&lt;li&gt;容器编排：比如K8S平台，一般可能会基于k8s的API做一套自己的k8s管控平台或选用类似Rancher这种更好用更高层的服务，完全基于命令行的k8s运维不是很高效易用&lt;/li&gt;
&lt;li&gt;容器镜像仓库：比如Docker私有仓库Harbor&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;好吧，的确一些中大型互联网公司是有超过100个内部系统是和研发相关的，甚至需要有专门的导航网站来管理工程效率、运维、基础框架、基础服务、基础中间件、基础平台的这些网站，这些系统本身的维护工作量也是不小的，一整理就会发现原来除了业务程序还有这么多周边的东西是为研发服务的，欢迎大家针对本文的内容进行补充。&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 15:07:00 +0000</pubDate>
<dc:creator>lovecindywang</dc:creator>
<og:description>前言 程序开发毕竟还不是搬砖这种无脑体力劳动，需要事先有标准，有架构，有设计，绝对不是新公司今天创立，明天就可以开始编码的。其实很多公司在起步的时候没有财力和资源建设独立的基础架构或平台架构部门，甚至</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lovecindywang/p/10941007.html</dc:identifier>
</item>
<item>
<title>nginx配置SSL证书实现https服务 - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/10940977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/10940977.html</guid>
<description>&lt;p&gt;在前面一篇文章中，使用&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/10927722.html&quot; target=&quot;_blank&quot;&gt;openssl生成了免费证书&lt;/a&gt; 后，我们现在使用该证书来实现我们本地node服务的https服务需求。假如我现在node基本架构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
|----&lt;span&gt;项目
&lt;/span&gt;| |---&lt;span&gt; static         # 存放html文件
&lt;/span&gt;| | |---&lt;span&gt; index.html   # index.html
&lt;/span&gt;| |---&lt;span&gt; node_modules   # 依赖包
&lt;/span&gt;| |---&lt;span&gt; app.js         # node 入口文件
&lt;/span&gt;| |---&lt;span&gt; package.json  
&lt;/span&gt;| |--- .babelrc       # 转换es6文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;index.html 文件代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=utf-8&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;referrer&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;never&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;nginx配置https&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;欢迎使用https来访问页面&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;app.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const Koa = require('koa'&lt;span&gt;);
const fs &lt;/span&gt;= require('fs'&lt;span&gt;);
const path &lt;/span&gt;= require('path'&lt;span&gt;);
const router &lt;/span&gt;= require('koa-router'&lt;span&gt;)();
const koaBody &lt;/span&gt;= require('koa-body'&lt;span&gt;);
const static &lt;/span&gt;= require('koa-static'&lt;span&gt;);

const app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Koa();

router.get(&lt;/span&gt;'/', (ctx, next) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置头类型, 如果不设置，会直接下载该页面&lt;/span&gt;
  ctx.type = 'html'&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取文件&lt;/span&gt;
  const pathUrl = path.join(__dirname, '/static/index.html'&lt;span&gt;);
  ctx.body &lt;/span&gt;=&lt;span&gt; fs.createReadStream(pathUrl);
  next();
});

app.use(static(path.join(__dirname)));

app.use(router.routes());
app.use(router.allowedMethods());

app.listen(&lt;/span&gt;3001, () =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'server is listen in 3001'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;package.json 代码如下;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;name&quot;: &quot;uploadandload&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;version&quot;: &quot;1.0.0&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;description&quot;: &quot;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;main&quot;: &quot;app.js&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;scripts&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;dev&quot;: &quot;nodemon ./app.js&quot;&lt;span&gt;
  },
  &lt;/span&gt;&quot;author&quot;: &quot;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;license&quot;: &quot;ISC&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;dependencies&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;fs&quot;: &quot;0.0.1-security&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;koa&quot;: &quot;^2.7.0&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;koa-body&quot;: &quot;^4.1.0&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;koa-router&quot;: &quot;^7.4.0&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;koa-send&quot;: &quot;^5.0.0&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;koa-static&quot;: &quot;^5.0.0&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;nodemon&quot;: &quot;^1.19.0&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;path&quot;: &quot;^0.12.7&quot;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我在项目的根目录下执行 npm run dev 后，就可以在浏览器下访问 http://localhost:3001 了，但是为了我想使用域名访问的话，因此我们可以在 hosts文件下绑定下域名，比如叫 xxx.abc.com . hosts文件如下绑定：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
127.0.0.1  xxx.abc.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此这个时候我们使用 http://xxx.abc.com:3001/ 就可以访问页面了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528224831920-1952060532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上所示，我们就可以访问页面了，但是我们有没有发现，在chrome浏览器下 显示http请求是不安全的，因此这个时候我想使用https来访问就好了，网页的安全性就得到了保障，但是这个时候如果我什么都不做，直接使用https去访问的话是不行的，比如地址：https://xxx.abc.com:3001. 如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528224905355-56510952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道使用https访问的话，一般是需要安全证书的，因此我们现在的任务是需要使用nginx来配置下安全证书之类的事情，然后使用https能访问网页就能达到目标。&lt;br/&gt;如果想要学习nginx基本安装及基本知识点，请看我之前的&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/category/1205593.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;nginx配置https服务&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 首先进入nginx目录下，使用命令：cd /usr/local/etc/nginx。然后在该目录下创建 cert文件夹，目的是存放证书文件。&lt;/strong&gt;&lt;br/&gt;使用命令：mkdir cert 如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225102075-1020160352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 然后我们需要把证书相关的文件，比如server.crt 和 server.key 文件复制到该 cert目录下。比如如下证书文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225118292-233498278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于如上证书是如何生存的，可以请看我上篇文字 &lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/10927722.html&quot; target=&quot;_blank&quot;&gt;使用openssl 生存免费证书&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;移动命令：mv server.key /usr/local/etc/nginx/cert， 比如把server.key 和 server.crt文件都移动到 /usr/local/etc/nginx/cert目录下。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225228557-1817272601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们再查看下 /usr/local/etc/nginx/cert 目录下，有如下文件，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225242820-1241232565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. nginx的配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nginx的配置需要加上如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
  listen       &lt;/span&gt;443&lt;span&gt; ssl;
  server_name    xxx.abc.com;
  ssl on;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该配置项需要去掉&lt;/span&gt;
  ssl_certificate      cert/server.crt;
  ssl_certificate_key  cert/server.key;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   设置ssl/tls会话缓存的类型和大小。如果设置了这个参数一般是shared，buildin可能会参数内存碎片，默认是none，和off差不多，停用缓存。如shared:SSL:10m表示我所有的nginx工作进程共享ssl会话缓存，官网介绍说1M可以存放约4000个sessions。
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  ssl_session_cache    shared:SSL:1m;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 客户端可以重用会话缓存中ssl参数的过期时间，内网系统默认5分钟太短了，可以设成30m即30分钟甚至4h。&lt;/span&gt;
&lt;span&gt;  ssl_session_timeout  5m;

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   选择加密套件，不同的浏览器所支持的套件（和顺序）可能会不同。
   这里指定的是OpenSSL库能够识别的写法，你可以通过 openssl -v cipher 'RC4:HIGH:!aNULL:!MD5'（后面是你所指定的套件加密算法） 来看所支持算法。
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  ssl_ciphers  HIGH:&lt;/span&gt;!aNULL:!&lt;span&gt;MD5;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置协商加密算法时，优先使用我们服务端的加密套件，而不是客户端浏览器的加密套件。&lt;/span&gt;
&lt;span&gt;  ssl_prefer_server_ciphers  on;

  location &lt;/span&gt;/&lt;span&gt; {
    proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:3001;&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：如上 ssl on; 这个配置项需要去掉。假如是如上的配置后，我重新启动下nginx命令会报错，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225352227-1003439378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SSL: error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt error:0906A065:PEM routines:PEM_do_header:bad decrypt 类似这样的错，然后通过百度搜索这个错误，通过如下方法可以解决：&lt;/p&gt;
&lt;p&gt;进入到该目录下：cd /usr/local/etc/nginx/cert 然后执行下面两句代码即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cp server.key server.key.org
openssl rsa &lt;/span&gt;-&lt;span&gt;in&lt;/span&gt; server.key.org -out server.key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225446528-576585575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看百度搜索出来的页面(&lt;a href=&quot;http://ju.outofmemory.cn/entry/17732&quot; target=&quot;_blank&quot;&gt;http://ju.outofmemory.cn/entry/17732&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;然后当我继续重启下 nginx, 发现还会报错，报错信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
nginx: [warn] the &quot;ssl&quot; directive is deprecated, use the &quot;listen ... ssl&quot; directive instead 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后继续把 ssl on; 这句配置项去掉就可以了，可能和nginx的版本有关系，请看这篇文章(&lt;a href=&quot;https://blog.csdn.net/ootw/article/details/81059677&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/ootw/article/details/81059677&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;现在我继续重启下nginx就ok了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225709122-2067543723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是如上配置后，我们还不能直接 使用 域名 https://xxx.abc.com/ 访问了，我们还需要在浏览器下把自己之前生成的client.crt 证书安装上去，在mac系统下操作步骤如下：&lt;/p&gt;
&lt;p&gt;1. 点击如下启动台。如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225736680-1451391708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 搜索钥匙串访问，点击进去，如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225751376-604474745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 进入到证书页面，把我们之前的client.crt证书拖进到证书里面去即可，比如我之前生成的 client.crt证书，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225806538-823170558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 右键点击我的证书，然后点击 &quot;显示简介&quot;, 进入到证书详情页面后。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225820938-1512273675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5. 进入页面后，使用证书时，选择始终信任后，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225838094-1910525499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6. 然后退出，可能需要输入电脑开机密码，输入完成，会自动保存。然后我们在浏览器访问该 https://xxx.abc.com/ 页面后就可以访问的到了。如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225900582-1031374577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们点击继续访问即可看到页面了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225914584-1968422200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上就是使用 nginx + 证书 实现 本地node https服务了。&lt;/p&gt;
&lt;p&gt;但是如上https虽然可以访问，但是https前面还是显示不安全的文案； 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201905/561794-20190528225929265-1284631440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可能的原因该证书是自己生成的证书，不是购买第三方的证书导致的吧。具体啥原因，目前我也不知道，至少现在我们可以使用https来访问我们的项目了。&lt;br/&gt;&lt;a href=&quot;https://github.com/tugenhua0707/web-security/tree/master/openssl&quot; target=&quot;_blank&quot;&gt;github上简单node服务启动的源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 15:01:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>nginx配置SSL证书实现https服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tugenhua0707/p/10940977.html</dc:identifier>
</item>
<item>
<title>Kaggle八门神器（一）：竞赛神器之XGBoost介绍 - chengzy</title>
<link>http://www.cnblogs.com/chdee/p/10940380.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chdee/p/10940380.html</guid>
<description>&lt;p&gt;Xgboost为一个十分有效的机器学习模型，在各种竞赛中均可以看到它的身影，同时Xgboost在工业届也有着广泛的应用，本文以&lt;code&gt;Titanic&lt;/code&gt;数据集为研究对象，简单地探究Xgboost模型建模过程，同时对数据清理以及特征工程的内容作简单的介绍，以此作为Xgboost模型的学习笔记，错误和不足之处还请各位看官指出。&lt;/p&gt;
&lt;h2 id=&quot;数据集&quot;&gt;数据集&lt;/h2&gt;
&lt;p&gt;本文数据集源自于竞赛&lt;a href=&quot;https://www.kaggle.com/c/titanic&quot;&gt;Titanic: Machine Learning from Disaster&lt;/a&gt;，竞赛中我们要求根据数据集提供的乘客编号、姓名性别等信息，运用机器学习模型预测船上乘客的存活与否&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;泰坦尼克号沉没事故（英语：Sinking of the RMS Titanic）是1912年4月14日深夜至15日凌晨在北大西洋发生的著名船难，事发时是泰坦尼克号从英国南安普敦港至美国纽约港首航的第5天，该船当时是世界最大的邮轮。1912年4月14日星期天23时40分[a]与一座冰山擦撞前，已经收到6次海冰警告，但当瞭望员看到冰山时，该船的行驶速度正接近最高速。由于无法快速转向，该船右舷侧面遭受了一次撞击，部分船体出现缝隙，使16个水密隔舱中的5个进水。泰坦尼克号的设计仅能够承受4个水密隔舱进水，因此沉没。 --Wikipedia&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pandas as pd
pd.options.mode.chained_assignment = None&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;titanic = pd.read_csv('Titanic/train.csv')&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;titanic.head(5)&lt;/code&gt;
&lt;/pre&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;PassengerId&lt;/th&gt;
&lt;th&gt;Survived&lt;/th&gt;
&lt;th&gt;Pclass&lt;/th&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Sex&lt;/th&gt;
&lt;th&gt;Age&lt;/th&gt;
&lt;th&gt;SibSp&lt;/th&gt;
&lt;th&gt;Parch&lt;/th&gt;
&lt;th&gt;Ticket&lt;/th&gt;
&lt;th&gt;Fare&lt;/th&gt;
&lt;th&gt;Cabin&lt;/th&gt;
&lt;th&gt;Embarked&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;th&gt;0&lt;/th&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Braund, Mr. Owen Harris&lt;/td&gt;
&lt;td&gt;male&lt;/td&gt;
&lt;td&gt;22.0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;A/5 21171&lt;/td&gt;
&lt;td&gt;7.2500&lt;/td&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;th&gt;1&lt;/th&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Cumings, Mrs. John Bradley (Florence Briggs Th...&lt;/td&gt;
&lt;td&gt;female&lt;/td&gt;
&lt;td&gt;38.0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;PC 17599&lt;/td&gt;
&lt;td&gt;71.2833&lt;/td&gt;
&lt;td&gt;C85&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;2&lt;/th&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Heikkinen, Miss. Laina&lt;/td&gt;
&lt;td&gt;female&lt;/td&gt;
&lt;td&gt;26.0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;STON/O2. 3101282&lt;/td&gt;
&lt;td&gt;7.9250&lt;/td&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;th&gt;3&lt;/th&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;Futrelle, Mrs. Jacques Heath (Lily May Peel)&lt;/td&gt;
&lt;td&gt;female&lt;/td&gt;
&lt;td&gt;35.0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;113803&lt;/td&gt;
&lt;td&gt;53.1000&lt;/td&gt;
&lt;td&gt;C123&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;4&lt;/th&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;Allen, Mr. William Henry&lt;/td&gt;
&lt;td&gt;male&lt;/td&gt;
&lt;td&gt;35.0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;373450&lt;/td&gt;
&lt;td&gt;8.0500&lt;/td&gt;
&lt;td&gt;NaN&lt;/td&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2 id=&quot;数据清理&quot;&gt;数据清理&lt;/h2&gt;
&lt;p&gt;数据分析中维持一个干净的数据集对建模十分关键，可靠的数据集主要由以下几个方面来评估：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据的可靠性，这个方面由原始数据集保证&lt;/li&gt;
&lt;li&gt;数据的版本控制, 输入数据对机器学习建模影响很大，如果模型训练输入数据不断发生变化的话很可能无法生成正确的模型，即上游的输入数据供给进程突然发生变化会波及到模型建立的过程&lt;/li&gt;
&lt;li&gt;特征的必要性，建模特征数量和模型精度并不呈现严格的正相关&lt;/li&gt;
&lt;li&gt;特征的相关性，建模过程中我们尽可能减少相关特征的数量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在本例子，&lt;code&gt;Name&lt;/code&gt;和&lt;code&gt;Ticket&lt;/code&gt;和存活条件相关性较低，我们可以考虑将这些特征剔除&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X = titanic[['Pclass', 'Age', 'Sex']]
y = titanic['Survived']&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 对于年龄空缺的乘客我们使用平均年龄进行填充
X['Age'] = X['Age'].fillna(X['Age'].mean())&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.model_selection import train_test_split&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=33)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X_train.head(5)&lt;/code&gt;
&lt;/pre&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;Pclass&lt;/th&gt;
&lt;th&gt;Age&lt;/th&gt;
&lt;th&gt;Sex&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;110&lt;/th&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;47.000000&lt;/td&gt;
&lt;td&gt;male&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;360&lt;/th&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;40.000000&lt;/td&gt;
&lt;td&gt;male&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;364&lt;/th&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;29.699118&lt;/td&gt;
&lt;td&gt;male&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;320&lt;/th&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;22.000000&lt;/td&gt;
&lt;td&gt;male&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;296&lt;/th&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;23.500000&lt;/td&gt;
&lt;td&gt;male&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2 id=&quot;特征工程&quot;&gt;特征工程&lt;/h2&gt;
&lt;p&gt;传统编码工作的关注点在于代码编码的过程，而机器学习和数据分析工作者则是着力于数据特征的表示过程，开发者通过特征工程（新特征可以来源于数据济原始特征的逻辑运算）建立一个良好的数据特征原型。特征工程的主要工作有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;映射字符串字符为整型&lt;/li&gt;
&lt;li&gt;采用One-Hot编码方式映射枚举值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在本例中，我们将&lt;code&gt;Titanic&lt;/code&gt;数据集的&lt;code&gt;Sex&lt;/code&gt;一列的男性和女性映射为整型值0和1&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X_train['Sex'] = X_train['Sex'].map({'male':0,'female':1})
X_test['Sex'] = X_test['Sex'].map({'male':0,'female':1})&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 检视映射处理结果
X_train.head(5)&lt;/code&gt;
&lt;/pre&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;Pclass&lt;/th&gt;
&lt;th&gt;Age&lt;/th&gt;
&lt;th&gt;Sex&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;110&lt;/th&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;47.000000&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;360&lt;/th&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;40.000000&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;364&lt;/th&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;29.699118&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;320&lt;/th&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;22.000000&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;296&lt;/th&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;23.500000&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.ensemble import RandomForestClassifier&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;titanic_rf = RandomForestClassifier()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;titanic_rf.fit(X_train, y_train)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print('The accuracy of Random Forest Classifier on testing set:', titanic_rf.score(X_test, y_test))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;The accuracy of Random Forest Classifier on testing set: 0.8026905829596412&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from xgboost import XGBClassifier

titanic_xgb = XGBClassifier()
titanic_xgb.fit(X_train, y_train)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print('The accuracy of eXtreme Gradient Boosting Classifier on testing set:', titanic_xgb.score(X_test, y_test))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;The accuracy of eXtreme Gradient Boosting Classifier on testing set: 0.8385650224215246&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分类结果报告&quot;&gt;分类结果报告&lt;/h2&gt;
&lt;p&gt;目标分类中常用的指标有精确率、召回率以及F1均值，公式如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;精确率 &lt;span class=&quot;math inline&quot;&gt;\(Precision = \frac{T_P}{(T_P + F_P)}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;召回率 &lt;span class=&quot;math inline&quot;&gt;\(Recall = \frac{T_P}{(T_P + F_N)}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;F1值 &lt;span class=&quot;math inline&quot;&gt;\(F1 = 2 \times \frac{Precision \times Recall}{(Precision + Recall)}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import classification_report, precision_recall_curve
from sklearn.metrics import f1_score

rf_result = titanic_rf.predict(X_test)
xgb_result = titanic_xgb.predict(X_test)

print('随机森林模型: \n ' + classification_report(rf_result, y_test, digits=4))
print('XGBoost模型: \n ' + classification_report(xgb_result, y_test, digits=4))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;随机森林模型: 
               precision    recall  f1-score   support

           0     0.8731    0.8125    0.8417       144
           1     0.6966    0.7848    0.7381        79

   micro avg     0.8027    0.8027    0.8027       223
   macro avg     0.7849    0.7987    0.7899       223
weighted avg     0.8106    0.8027    0.8050       223

XGBoost模型: 
               precision    recall  f1-score   support

           0     0.9179    0.8311    0.8723       148
           1     0.7191    0.8533    0.7805        75

   micro avg     0.8386    0.8386    0.8386       223
   macro avg     0.8185    0.8422    0.8264       223
weighted avg     0.8510    0.8386    0.8414       223&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到随机森林模型和XGBoost的F1均值分别为0.8050和0.8414，XGBoost在&lt;code&gt;Titanic&lt;/code&gt;数据集中略胜一筹&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 14:30:00 +0000</pubDate>
<dc:creator>chengzy</dc:creator>
<og:description>Xgboost为一个十分有效的机器学习模型，在各种竞赛中均可以看到它的身影，同时Xgboost在工业届也有着广泛的应用，本文以 数据集为研究对象，简单地探究Xgboost模型建模过程，同时对数据清理以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chdee/p/10940380.html</dc:identifier>
</item>
<item>
<title>单周期cpu设计代码解读 - 小塞</title>
<link>http://www.cnblogs.com/hesse-summer/p/10940775.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hesse-summer/p/10940775.html</guid>
<description>&lt;p&gt;欢迎转载，转载请说明出处。&lt;/p&gt;

&lt;h2 id=&quot;概念回顾&quot;&gt;概念回顾&lt;/h2&gt;
&lt;h4 id=&quot;一电子计算机的部件&quot;&gt;一、电子计算机的部件&lt;/h4&gt;
&lt;p&gt;分为：中央处理器（cpu）、内部存储器（Memory）、输入/输出（I/O）设备，以及连接它们的总线（Bus）。下图为图示，注意色块的区分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281706/201905/1281706-20190528222600250-138215364.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;二cpu&quot;&gt;二、cpu&lt;/h4&gt;
&lt;p&gt;又包括控制器（Controller）和数据通路（Data Path）。下图为图示，注意色块区分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281706/201905/1281706-20190528222616699-1779421981.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;三控制器&quot;&gt;三、控制器&lt;/h4&gt;
&lt;p&gt;分为主控（Main Control）和局控（Local Control或ALU Control）。将二进制指令输入控制器，生成控制信号，该过程称为&lt;strong&gt;译码&lt;/strong&gt;。控制信号控制数据通路工作。且不同的指定对应不同的控制信号。&lt;/p&gt;
&lt;p&gt;下图为在控制器中译码的逻辑示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281706/201905/1281706-20190528222637392-238423748.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图为在控制器中译码的物理示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281706/201905/1281706-20190528222649059-28718644.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;讲解一下从逻辑图到物理图的转换：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先由主控解析op指令，如果发现该指令为“000000”则表示该指令是R指令，输出中间信号R-Type为1，否则为0；如果发现该指令是其他值，则按照逻辑图，为RegDst等信号赋相应的值；&lt;/li&gt;
&lt;li&gt;中间信号R-Type起到二路选择的作用，如图。&lt;/li&gt;
&lt;li&gt;中间信号ALUop，在R-Type为0（选择0路）时，直接通过局控，输出成为ALUctr信号，对应上面逻辑图的最后一行后5列；在R-Type为1时，局控起作用。&lt;/li&gt;
&lt;li&gt;局控解析R指令的func部分，输出对应指令的ALUctr信号。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;四数据通路&quot;&gt;四、数据通路：&lt;/h4&gt;
&lt;p&gt;是包括运算器、寄存器组、存储器（高速缓存）、多路选择器等等在内的元件的有结构的组合。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281706/201905/1281706-20190528222704219-794021857.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【数据通路各部分的讲解将结合代码完成】&lt;/p&gt;
&lt;h2 id=&quot;verilog代码讲解&quot;&gt;Verilog代码讲解&lt;/h2&gt;
&lt;p&gt;在代码讲解之前有必要放几张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281706/201905/1281706-20190528222718554-2078350726.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281706/201905/1281706-20190528222729394-2078538369.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;shift.v&quot;&gt;&lt;code&gt;shift.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*移位*/
/*输入一个数，返回移位之后的结果*/
/*输入d(待移的数)、sa(移动的位数)、right(移动方向)、arith(空位补全方式)*/
/*输出sh(移位后的结果)*/
module shift (d,sa,right,arith,sh);
input  [31:0]  d;
input  [4:0]     sa;
input  right,arith;
output [31:0] sh;
reg  [31:0] sh;
    
// 组合逻辑
always  @*  begin
    if   (!right)  begin // right为逻辑0时，左移
        sh = d &amp;lt;&amp;lt; sa;
    end else  if   (!arith)  begin // right为逻辑1，且arith为逻辑0时，右移、0补空
        sh =  d  &amp;gt;&amp;gt;  sa;
    end else begin // 右移、1补空                     
        sh =  $signed(d)  &amp;gt;&amp;gt;&amp;gt;  sa;
    end
end
endmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;scinstmem.v&quot;&gt;&lt;code&gt;scinstmem.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*从ROM（只读存储器）读数据*/
/*输入目标数据在ROM中的地址a*/
/*输出地址对应的数据inst*/
module scinstmem (a,inst); 
    input [31:0] a; 
    output [31:0] inst; 
    wire [31:0] rom [0:31]; // 定义32个32位的存储器ROM

    // 想ROM中写入一组指令，指令对应的汇编含义见行注释
    assign  rom[5'h00] = 32'h3c010000; // (00) main: lui r1,0
    assign  rom[5'h01] = 32'h34240050; // (04)      ori r4,r1,80
    assign  rom[5'h02] = 32'h20050004; // (08)      addi r5,r0, 4
    assign  rom[5'h03] = 32'h0c000018; // (0c)call: jal sum
    assign  rom[5'h04] = 32'hac820000; // (10)      sw r2,0(r4)
    assign  rom[5'h05] = 32'h8c890000;  //  (14)        lw  r9, 0(r4)
    assign  rom[5'h06] = 32'h01244022;  //  (18)        sub r8, r9. r4
    assign  rom[5'h07] = 32'h20050003;  //  (lc)        addi    r5, r0. 3
    assign  rom[5'h08] = 32'h20a5ffff;  //  (20)    loop2:  addi    r5, r5, -1
    assign  rom[5'h09] = 32'h34a8ffff;  //  (24)        ori r8, r5, 0xffff
    assign  rom[5'h0A] = 32'h39085555;  //  (28)        xori    r8. r8, 0x5555
    assign  rom[5'h0B] = 32'h2009ffff;  //  (2c)        addi    r9, rO, -1
    assign  rom[5'h0C] = 32'h312affff;  //  (30)        andi    rlO,    r9, 0xffff
    assign  rom[5'h0D] = 32'h01493025;  //  (34)        or  r6. rlO,    r9
    assign  rom[5'h0E] = 32'h01494026;  //  (38)        xor r8, rlO,    r9
    assign  rom[5'h0F] = 32'h01463824;  //  (3c)        and r7, rlO,    r6
    assign  rom[5'h10] = 32'h10a00001;  //  (40)        beq r5, r0, shift
    assign  rom[5'h11] = 32'h08000008;  //  (44)        j   loop2   
    assign  rom[5'h12] = 32'h2005ffff;  //  (48)    shift:  addi    r5. r0, -1
    assign  rom[5'h13] = 32'h000543c0;  //  (4c)        sll r8. r5. 15
    assign  rom[5'h14] = 32'h00084400;  //  (50)        sll r8, r8, 16
    assign  rom[5'h15] = 32'h00084403;  //  (54)        sra r8, r8, 16
    assign  rom[5'h16] = 32'h000843c2;  //  (58)        srl r8. r8. 15
    assign  rom[5'h17] = 32'h08000017;  //  (5c)    finish: j   finish  
    assign  rom[5'h18] = 32'h00004020;  //  (60)    sum:    add r8, r0, r0
    assign  rom[5'h19] = 32'h8c890000;  //  (64)    loop:   lw  r9, (r4)
    assign  rom[5'h1A] = 32'h20840004;  //  (68)        addi    r4, r4, 4
    assign  rom[5'h1B] = 32'h01094020;  //  (6c)        add r8, r8, r9
    assign  rom[5'h1C] = 32'h20a5ffff;  //  (70)        addi    r5, r5, -1
    assign  rom[5'h1D] = 32'h14a0fffb;  //  (74)        bne rS, r0, loop
    assign  rom[5'h1E] = 32'h00081000;  //  (78)        sll r2f r8f 0
    assign  rom[5'h1F] = 32'h03e00008;  //  (7c)        jr  r31     

    // 将地址对应的数据放入inst
    assign inst = rom[a[6:2]];

endmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;scdatamem.v&quot;&gt;&lt;code&gt;scdatamem.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*将数据写入RAM中（随机存取存储器）的指定位置*/
/*输入待写数据datain、目标地址addr；写使能信号we；时钟信号clk、inclk、outclk*/
/*输出将被覆盖的数据dataout*/
module scdatamem (clk,dataout,datain,addr,we,inclk,outclk);
input   [31:0]  datain;
input   [31:0]  addr ;
input       clk, we, inclk, outclk;
output  [31:0]  dataout;
reg [31:0] ram  [0:31]; // 定义32个32位RAM
// 把将被覆盖的数据放入dataout
assign  dataout =ram[addr[6:2]];
// 时序逻辑，clk的上升沿触发
always @ (posedge clk) begin
    if (we) ram[addr[6:2]] = datain; // 如果写使能信号we为1，将数据写入目标地址
end
// 为RAM赋值，这一步不是必要的，只是欲运行的自定义程序的需要。
integer i;
initial begin
    for (i = 0;i &amp;lt; 32;i = i + 1)
        ram[i] = 0;
    ram[5'h14] = 32'h000000a3;
    ram[5'h15] = 32'h00000027;
    ram[5'h16] = 32'h00000079;
    ram[5'h17] = 32'h00000115;
end
endmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;sccu_dataflow.v&quot;&gt;&lt;code&gt;sccu_dataflow.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*基于MIPS指令集的控制器*/
/*输入指令的op字段、func字段、z信号*/
/*输出wreg,regrt，aluc,pcsource等等控制信号*/
module sccu_dataflow (op,func,z,wmem,wreg,regrt,m2reg,aluc,shift,aluimm,pcsource,jal,sext);
    input [5:0] op,func;
    input z;
    output wreg,regrt,jal,m2reg,shift,aluimm,sext,wmem;
    output [3:0] aluc;
    output [1:0] pcsource;
    
    // 确定内部信号r_type的值
    wire r_type = ~|op;
    
    // 如果r_type为真，根据func，确定是哪一种R型指令
    wire i_add = r_type&amp;amp;func[5]&amp;amp;~func[4]&amp;amp;~func[3]&amp;amp;~func[2]&amp;amp;~func[1]&amp;amp;~func[0];
    wire i_sub = r_type&amp;amp;func[5]&amp;amp;~func[4]&amp;amp;~func[3]&amp;amp;~func[2]&amp;amp;func[1]&amp;amp;~func[0];
    wire i_and = r_type&amp;amp;func[5]&amp;amp;~func[4]&amp;amp;~func[3]&amp;amp;func[2]&amp;amp;~func[1]&amp;amp;~func[0];
    wire i_or = r_type&amp;amp;func[5]&amp;amp;~func[4]&amp;amp;~func[3]&amp;amp;func[2]&amp;amp;~func[1]&amp;amp;func[0];
    wire i_xor = r_type&amp;amp;func[5]&amp;amp;~func[4]&amp;amp;~func[3]&amp;amp;func[2]&amp;amp;func[1]&amp;amp;~func[0];
    wire i_sll = r_type&amp;amp;~func[5]&amp;amp;~func[4]&amp;amp;~func[3]&amp;amp;~func[2]&amp;amp;~func[1]&amp;amp;~func[0];
    wire i_srl = r_type&amp;amp;~func[5]&amp;amp;~func[4]&amp;amp;~func[3]&amp;amp;~func[2]&amp;amp;func[1]&amp;amp;~func[0];
    wire i_sra = r_type&amp;amp;~func[5]&amp;amp;~func[4]&amp;amp;~func[3]&amp;amp;~func[2]&amp;amp;func[1]&amp;amp;func[0];
    wire i_jr = r_type&amp;amp;~func[5]&amp;amp;~func[4]&amp;amp;func[3]&amp;amp;~func[2]&amp;amp;~func[1]&amp;amp;~func[0];
    // 如果r_type为假，根据op，确定是哪一种指令
    wire i_addi = ~op[5]&amp;amp;~op[4]&amp;amp;op[3]&amp;amp;~op[2]&amp;amp;~op[1]&amp;amp;~op[0];
    wire i_andi = ~op[5]&amp;amp;~op[4]&amp;amp;op[3]&amp;amp;op[2]&amp;amp;~op[1]&amp;amp;~op[0];
    wire i_ori = ~op[5]&amp;amp;~op[4]&amp;amp;op[3]&amp;amp;op[2]&amp;amp;~op[1]&amp;amp;op[0];
    wire i_xori = ~op[5]&amp;amp;~op[4]&amp;amp;op[3]&amp;amp;op[2]&amp;amp;op[1]&amp;amp;~op[0];
    wire i_lw = op[5]&amp;amp;~op[4]&amp;amp;~op[3]&amp;amp;~op[2]&amp;amp;op[1]&amp;amp;op[0];
    wire i_sw = op[5]&amp;amp;~op[4]&amp;amp;op[3]&amp;amp;~op[2]&amp;amp;op[1]&amp;amp;op[0];
    wire i_beq = ~op[5]&amp;amp;~op[4]&amp;amp;~op[3]&amp;amp;op[2]&amp;amp;~op[1]&amp;amp;~op[0];
    wire i_bne = ~op[5]&amp;amp;~op[4]&amp;amp;~op[3]&amp;amp;op[2]&amp;amp;~op[1]&amp;amp;op[0];
    wire i_lui = ~op[5]&amp;amp;~op[4]&amp;amp;op[3]&amp;amp;op[2]&amp;amp;op[1]&amp;amp;op[0];
    wire i_j = ~op[5]&amp;amp;~op[4]&amp;amp;~op[3]&amp;amp;~op[2]&amp;amp;op[1]&amp;amp;~op[0];
    wire i_jal = ~op[5]&amp;amp;~op[4]&amp;amp;~op[3]&amp;amp;~op[2]&amp;amp;op[1]&amp;amp;op[0];
    
    // 在确定了指令的情况下，确定控制信号的取值
    assign wreg = i_add|i_sub|i_and|i_or|i_xor|i_sll|i_srl|i_sra|i_addi|i_andi|i_ori|i_xori|i_lw|i_lui|i_jal;
    assign regrt= i_addi|i_andi|i_ori|i_xori|i_lw|i_lui;
    assign jal= i_jal;
    assign m2reg= i_lw;
    assign shift=i_sll|i_srl|i_sra;
    assign aluimm=i_addi|i_andi|i_ori|i_xori|i_lw|i_lui|i_sw;
    assign sext =i_addi|i_lw|i_sw|i_beq|i_bne;
    assign aluc[3]=i_sra;
    assign aluc[2]=i_sub|i_or|i_srl|i_sra|i_ori|i_lui;
    assign aluc[1]=i_xor|i_sll|i_sra|i_xori|i_beq|i_bne|i_lui;
    assign aluc[0]=i_and|i_or|i_sll|i_srl|i_sra|i_andi|i_ori;
    assign wmem = i_sw;
    assign pcsource[1]=i_jr|i_j|i_jal;
    assign pcsource[0]=i_beq&amp;amp;z|i_bne&amp;amp;~z|i_j|i_jal;
endmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mux2x32.v&quot;&gt;&lt;code&gt;mux2x32.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*32位二路选择器*/
/*输入决定选择哪一路的控制信号s，输入待选择的信号a0、a1*/
/*输出被选择的信号y*/
module mux2x32 (a0,a1,s,y);
    input [31:0] a0,a1;
    input s;
    output [31:0] y;
    assign y = s?a1:a0; // 如果s为1，选择a1，否则选择a0
endmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mux2x5.v&quot;&gt;&lt;code&gt;mux2x5.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*5位二路选择器*/
/*逻辑同上*/
module mux2x5 (a0,a1,s,y);
    input [4:0] a0,a1;
    input s;
    output [4:0] y;
    assign y = s?a1:a0;
endmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mux4x32.v&quot;&gt;&lt;code&gt;mux4x32.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*32位四路选择器*/
/*待选择的数是a0~a3，控制信号为s，选择结果为y*/
/*s如何控制，由case语句决定*/
module mux4x32 (a0,a1,a2,a3,s,y);
    input [31:0] a0,a1,a2,a3;
    input [1:0] s;
    output [31:0] y;
    function [31:0] select;
        input [31:0] a0,a1,a2,a3;
        input [1:0] s;

        case (s)
            2'b00: select = a0; //s为00时，选择a0
            2'b01: select = a1;
            2'b10: select = a2;
            2'b11: select = a3;
        endcase
    endfunction
    assign  y = select(a0,a1,a2,a3,s); // y为选择的结果
endmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;dff32.v&quot;&gt;&lt;code&gt;dff32.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*将数据送入指定寄存器*/
/*输入待存数据d，待存寄存器q；时钟clk和clrn*/
/*没有输出*/
module dff32(d,clk,clrn,q);
    input [31:0] d;
    input   clk,clrn;
    output [31:0] q;
    reg  [31:0] q; 
    /*时序逻辑，clk的上升沿降沿触发、clrn的下降沿触发*/
    always @ (negedge clrn or posedge clk)
        // clrn是清零时钟
        if (clrn == 0) begin // 当清零时钟到来时
            q &amp;lt;= 0; // 为q赋值0
        end else begin
            q &amp;lt;= d; // 否则赋值d
        end
endmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;cla32.v&quot;&gt;&lt;code&gt;cla32.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*下面所有程序都是为了实现一个东东：32位并行加法器*/
/*从最基本的加法进位模型add实现全加器cla_2，
  逐步集成为4位全加器cla_4、8位的全加器cla_8、
  16位全加器cla_16、32位全加器cla_32,
  最终实现32位并行加法器cla32
*/

/*加数是a、b，和是s*/
/*借位是ci，进位是co*/
module cla32 (a,b,ci,s,co);
    input   [31:0]  a,b;
    input  ci;
    output   [31:0]   s;
    output co;
    wire  g_out, p_out;
    cla_32  cla   (a,b, ci,g_out,p_out, s); // 向下调用
    assign  co  =  g_out| p_out &amp;amp;  ci;
endmodule




module add(a,b,c,g,p,s);
    input a,b,c;
    output g,p,s;
    assign s = a^b^c;
    assign g = a &amp;amp; b;
    assign p = a | b;
endmodule



module g_p  (g,p,c_in,g_out,p_out,c_out);
input  [1:0]  g,p;
input  c_in;
output g_out, p_out, c_out;
assign g_out = g[1]|p[1] &amp;amp; g[0];
assign p_out = p[1]  &amp;amp; p[0];
assign c_out = g[0]   |  p[0]  &amp;amp;  c_in;
endmodule



module cla_2 (a,b,c_in,g_out,p_out,s) ;
input  [1:0]  a,b;
input c_in;
output g_out, p_out;
output  [1:0]  s;
wire  [1:0]  g,p;
wire c_out;
add add0 (a[0],b[0],c_in, g[0],p[0],s[0]);
add add1 (a[1],b[1],c_out, g[1],p[1],s[1]);
g_p g_p0 (g,p,c_in,  g_out,p_out,c_out);
endmodule

module cla_4 (a,b, c_in,g_out,p_out,s);
input  [3:0]  a,b;
input  c_in;
output g_out, p_out;
output  [3:0]  s;
wire  [1:0]  g,p;
wire c_out;
cla_2 cla0 (a[1:0],b[1:0],c_in, g[0],p[0],s[1:0]);
cla_2 clal (a[3:2],b[3:2],c_out,g[1],p[1],s[3:2]);
g_p    g_p0  (g,p,c_in, g_out,p_out,c_out);
endmodule

module  cla_8   (a,b, c_in,g_out,p_out, s);
input   [7:0]  a,b;
input  c_in;
output  g_out, p_out;
output   [7:0]   s;
wire   [1:0]   g,p;
wire  c_out;
cla_4  cla0  (a[3:0],b[3:0],c_in, g[0],p[0],s[3:0]);
cla_4  c1a1  (a[7:4],b[7:4],c_out,g[1],p[1],s[7:4]);
g_p   g_p0  (g,p,c_in,  g_out,p_out,c_out);
endmodule


module cla_16 (a,b, c_in,g_out,p_out, s);
input   [15:0]  a,b;
input  c_in;
output  g_out, p_out;
output   [15:0]  s;
wire  [1:0]  g,p;
wire  c_out;
cla_8  cla0   (a[7:0],b[7:0],c_in,g[0],p[0],s[7:0]);
cla_8  cla1   (a[15:8],b[15:8],c_out,g[1],p[1],s[15:8]);
g_p    g_p0  (g,p,c_in,  g_out,p_out,c_out);
endmodule


module cla_32  (a,b,c_in,g_out,p_out, s);
input  [31:0]  a,b;
input c_in;
output  g_out, p_out;
output  [31:0]  s;
wire  [1:0]  g,p;
wire c_out;
cla_16 c1a0 (a[15:0],b[15:0],c_in,g[0],p[0],s[15:0]);
cla_16 c1a1 (a[31:16],b[31:16],c_out,g[1],p[1],s[31:16]);
g_p    g_p0  (g,p,c_in, g_out,p_out,c_out);
endmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;addsub32.v&quot;&gt;&lt;code&gt;addsub32.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*32位加减运算模块*/
/*调用32位加法模块*/
/*是加是减，取决于sub的取值*/
module addsub32(a,b,sub,s);
    input [31:0] a,b;
    input       sub;
    output [31:0] s;
    cla32 as32 (a,b^{32{sub}},sub,s);
endmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;alu.v&quot;&gt;&lt;code&gt;alu.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*alu算数逻辑单元*/
/*输入操作数a、b，操作类型信号aluc*/
/*输出运算结果r；z是？*/
module alu (a,b,aluc,r,z);
input [31:0] a,b; 
// aluc是3位的，每一位都有作用，见下
input [3:0] aluc; 
output  [31:0]  r;  
output z;            
wire  [31:0]  d_and = a &amp;amp; b; // 求和
wire  [31:0] d_or = a | b; // 求或
wire  [31:0] d_xor = a ^ b; // 求异或
wire  [31:0]  d_lui = {b[15:0],16'h0}; // 拼接，低16位补0

wire  [31:0]  d_and_or = aluc[2]? d_or : d_and; // aluc[2]决定 与/或
wire  [31:0]  d_xor_1ui= aluc[2]? d_lui : d_xor;  // aluc[2]决定 异或/拼接

wire  [31:0]  d_as,d_sh; // 加减法结果保存到d_as中；移位结果存入d_sh中
// aluc[2]控制加减法
addsub32 as32  (a,b,aluc[2],d_as); 
// b为待移的数，a[4:0]为移动位数，aluc[2]决定左右移，aluc[3]决定补全方式，结果保存在d_sh中
shift shifter  (b,a[4:0],aluc[2],aluc[3],d_sh) ; 

// 四路选择，aluc[1:0]控制选择哪一路，r为选择结果
mux4x32 se1ect  (d_as,d_and_or, d_xor_1ui, d_sh, aluc[1:0],r);
assign z = ~|r;
endmodule    &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;regfile.v&quot;&gt;&lt;code&gt;regfile.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*读寄存器堆、写寄存器堆*/
/*输入将要读取哪一个寄存器rna、rnb；输出读出的内容qa、qb*/
/*输入写使能we、待写入的寄存器wn，待写入的数据d*/
/*输入时钟clk、clrn*/
module regfile  (rna, rnb, d, wn,we, clk, clrn, qa, qb);
input       [4:0]  rna,rnb,wn;
input     [31:0]  d;
input     we, clk, clrn;
output  [31:0]  qa,qb;
reg     [31:0]  register  [1:31];  // 定义32个32位寄存器

// 读寄存器
// 如果指定的是rna，即rna不为0，将rna寄存器中的内容放入qa
assign qa  =   (rna ==  0) ? 0 : register[rna]; 
// 如果指定的是rnb，即rnb不为0，将rnb寄存器中的内容放入qb
assign qb  =   (rnb ==  0) ? 0 : register[rnb];
 

// 写寄存器
// 时序逻辑，clk的上升沿或clrn的下降沿触发
always @(posedge clk or negedge clrn)
begin 
if  (clrn==0) // 当为清空时钟信号时
begin
    integer i;
    for(i=1;i&amp;lt;32;i=i+1)
        register[i] &amp;lt;= 0; // 清空所有寄存器
end 
else  if((wn!=0)&amp;amp;&amp;amp;we) // 当写使能为逻辑1，且wn不是0时
register[wn]  &amp;lt;= d; // 将d写入wn寄存器
end
endmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;sccpu_dataflow.v&quot;&gt;&lt;code&gt;sccpu_dataflow.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*cpu*/
/*输入时钟信号clock、是否进行清零的信号resetn*/
/*输入32位指令inst、以及其他值*/
module  sccpu_dataflow(clock, resetn, inst, mem, pc, wmem, alu, data);
input     [31:0]   inst,mem;
input         clock, resetn;
output   [31:0]  pc,alu,data;
 
output wmem;
wire  [31:0] p4 , bpc, npc, adr, ra, alua, alub, res, alu_mem;
wire  [3:0] aluc;
wire  [4:0] reg_dest, wn;
wire  [1:0] pcsource;
wire  zero, wmem, wreg, regrt, m2reg, shift, aluimm, jal, sext;
wire  [31:0]  sa  =  {27'b0,inst[10:6]};
wire  [31:0]  offset  =  {imm[13:0],inst[15:0],2'b00};

/*控制器*/
// 输入inst[31:26]即op字段、inst[5:0]即func字段、0标志位zero
// 输出wmem、wreg等控制信号
sccu_dataflow cu  (inst[31:26] , inst[5:0] , zero, wmem,wreg,regrt,m2reg, aluc, shift, aluimm,pcsource, jal, sext);

/*0拓展或符号拓展*/
wire   e  =  sext  &amp;amp;  inst[15]; // 取出0或者符号 
wire   [15:0]       imm =  {16{e}}; 
wire  [31:0]       immediate  =  {imm,inst[15:0]}; // 拼接、拓展

/*修改PC，使PC指向下一条地址*、
dff32  ip  (npc,clock,resetn,pc); // 将npc（即下一条指令的地址）写入寄存器pc

/*计算下地址*/
// 四路选择器的0路
cla32  pcplus4   (pc,32'h4,1'b0,p4); // pc和32位十六进制4相加，再加上进位0，结果放入p4
// 四路选择器的1路
cla32  br_adr     (p4,offset,1'b0, adr); // p4和拓展后的imm相加，再加上进位0，结果放入adr
// 四路选择器的3路
wire  [31:0]        jpc =  {p4[31:28],inst[25:0],2'b00}; // 如图

/*二路选择器*/
// ③号。在ra即q1、sa之间选择，控制信号是shift，选择结果为alua
mux2x32  alu_a  (ra,sa,shift,alua);
// ④号。在data即q2、immediate之间选择，控制信号是aluimm，选择结果为alub
mux2x32  alu_b  (data, immediate,aluimm, alub);
// ⑤号。在alu即r、mem即do之间选择，控制信号是m2reg,选择结果为alu_mem
mux2x32  result   (alu,mem,m2reg,alu_mem);
// ②号。在alu_mem、p4之间选择，控制信号是jal即call，选择结构是res
mux2x32  link (alu_mem,p4,jal,res);
// ①号。在inst[15:11]即rd，inst[20: 16]即rt之间选择，控制信号是regrt，选择结果是reg_dest
mux2x5  reg_wn   (inst[15:11], inst[20: 16] , regrt, reg_dest);
// 对应图中的①号后面的f器件（不知道做什么的...）
assign wn = reg_dest   |   {5{jal}}; 

/*四路选择器，计算下地址*/
// 在p4、adr即addr、ra即q1、jpc即p4+immidiate&amp;lt;&amp;lt;2，之间选择，控制信号是pcsource，选择结果是npc
mux4x32  nextpc  (p4,adr,ra, jpc,pcsource,npc);

/*寄存器组*/
// 定义一个寄存器，输入端口是inst[25:21]即rs(n1)、inst[20:16]即rt(n2)
// 输出端口是data即ra即q1、data即q2
// 输入写使能wreg、待写寄存器wn即n
// 输入时钟clock即clk、清零时钟resetn
regfile  rf   (inst[25:21] ,inst[20:16] ,res,wn,wreg,clock,resetn,ra,data);

/*alu*/
// 操作数是alua、alub，操作结果是aluu空r、标志位zero即z
// 控制信号是aluc
alu  al_unit   (alua,alub,aluc,alu, zero); 
endmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;sccmop_dataflow.v&quot;&gt;&lt;code&gt;sccmop_dataflow.v&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;verilog&quot;&gt;
&lt;code&gt;/*最顶层的控制模块*/
/*输入时钟clock和resetn*/
/*输出 指令inst、PC的值pc、ALU的运算结果aluout、存储器的输出memout、时钟信号mem_clk*/
module  sccomp_dataflow(clock, resetn, inst, pc, aluout, memout,mem_clk);
input  clock, resetn,mem_clk;
output   [31:0]  inst,pc, aluout,memout;
wire [31:0]   data;
wire   wmem;
// 实例化一个cpu
sccpu_dataflow s (clock, resetn, inst,memout,pc, wmem, aluout, data);
// 实例化一个ROM
scinstmem imem (pc,inst);
// 实例化一个RAM
scdatamem dmem (clock, memout, data, aluout, wmem, mem_clk, mem_clk);
endmodule&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 28 May 2019 14:29:00 +0000</pubDate>
<dc:creator>小塞</dc:creator>
<og:description>[TOC] 写在前面 欢迎转载，转载请说明出处。 单周期cpu设计代码讲解 概念回顾 一、电子计算机的部件 分为：中央处理器（cpu）、内部存储器（Memory）、输入/输出（I/O）设备，以及连接它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hesse-summer/p/10940775.html</dc:identifier>
</item>
</channel>
</rss>