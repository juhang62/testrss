<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[C#.NET 拾遗补漏]03：你可能不知道的几种对象初始化方式 - LiamWang</title>
<link>http://www.cnblogs.com/willick/p/13063609.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/13063609.html</guid>
<description>&lt;p&gt;阅读本文大概需要 1.2 分钟。&lt;/p&gt;
&lt;p&gt;随着 C# 的升级，C# 在语法上对对象的初始化做了不少简化，来看看有没有你不知道的。&lt;/p&gt;
&lt;h2&gt;数组的初始化&lt;/h2&gt;
&lt;p&gt;在上一篇罗列数组的小知识的时候，其中也提到了数组的初始化，这时直接引用过来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[&lt;span&gt;3&lt;/span&gt;] {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;}; &lt;span&gt;// 正儿八经的初始化&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; [] {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;};     &lt;span&gt;// 简化掉了 int 和数组容量声明&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt;[] arr = {&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;};            &lt;span&gt;// 终极简化&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;字典的两种初始化方式&lt;/h2&gt;
&lt;p&gt;第二种是 C# 6 的语法，可能很多人不知道。&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code readability=&quot;4&quot;&gt;&lt;span&gt;// 方式一：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; dict = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;br/&gt;{&lt;br/&gt;{ &lt;span&gt;&quot;key1&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; },&lt;br/&gt;{ &lt;span&gt;&quot;key2&quot;&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt; }&lt;br/&gt;};&lt;p&gt;&lt;span&gt;// 方式二：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; dict = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;br/&gt;{&lt;br/&gt;[&lt;span&gt;&lt;span&gt;&quot;key1&quot;&lt;/span&gt;&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;[&lt;span&gt;&lt;span&gt;&quot;key2&quot;&lt;/span&gt;&lt;/span&gt;] = &lt;span&gt;20&lt;/span&gt;&lt;br/&gt;};&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;含自定义索引器的对象初始化&lt;/h2&gt;
&lt;p&gt;这种初始化原理上其实是和上面字典的第二种初始化是一样的。&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code readability=&quot;3&quot;&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;IndexableClass&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;int t&lt;/span&gt;&lt;span&gt;his&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt; index]&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;set&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;Console.WriteLine(&lt;span&gt;&quot;{0} was assigned to index {1}&quot;&lt;/span&gt;, &lt;span&gt;value&lt;/span&gt;, index);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;p&gt;&lt;span&gt;var&lt;/span&gt; foo = &lt;span&gt;new&lt;/span&gt; IndexableClass&lt;br/&gt;{&lt;br/&gt;[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;10&lt;/span&gt;,&lt;br/&gt;[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;20&lt;/span&gt;&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;元组（Tuple）的三种初始化方式&lt;/h2&gt;
&lt;p&gt;前面两种方式很常见，后面一种是 C# 7 的语法，可能有些人不知道。&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code readability=&quot;8&quot;&gt;&lt;span&gt;// 方式一：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; tuple = &lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;, MyClass&amp;gt;(&lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;123&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; MyClass());&lt;p&gt;&lt;span&gt;// 方式二：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; tuple = Tuple.Create(&lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;123&lt;/span&gt;, new MyClass());&lt;/p&gt;&lt;p&gt;&lt;span&gt;// 方式三：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; tuple = (&lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;123&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; MyClass());&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外补充个小知识，在 C# 7 中，元组的元素可以被解构命名：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(&lt;span&gt;int&lt;/span&gt; number, &lt;span&gt;bool&lt;/span&gt; flage) tuple = (&lt;span&gt;123&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;Console.WriteLine(tuple.number); &lt;span&gt;// 123&lt;/span&gt;&lt;br/&gt;Console.WriteLine(tuple.flag);   &lt;span&gt;// True&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;自定义集合类的初始化&lt;/h2&gt;
&lt;p&gt;只要自定义集合类包含&lt;code&gt;Add&lt;/code&gt;方法，便可以使用下面这种初始化方式为集合初始化元素。&lt;/p&gt;
&lt;pre readability=&quot;9.5&quot;&gt;
&lt;code readability=&quot;13&quot;&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;Program&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt;()&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; collection = &lt;span&gt;new&lt;/span&gt; MyCollection {&lt;br/&gt;&lt;span&gt;&quot;foo&quot;&lt;/span&gt;,         &lt;span&gt;// 对应方法：Add(string item)&lt;/span&gt;&lt;br/&gt;{ &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; },  &lt;span&gt;// 对应方法：Add(string item, int count)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;baz&quot;&lt;/span&gt;,         &lt;span&gt;// 对应方法：Add(string item)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;123.45&lt;/span&gt;d,       &lt;span&gt;// 对应扩展方法：Add(this MyCollection @this, double value)&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;}&lt;br/&gt;}&lt;p&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;MyCollection&lt;/span&gt; : &lt;span&gt;IEnumerable&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt; IList _list = &lt;span&gt;new&lt;/span&gt; ArrayList();&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Add&lt;/span&gt;(&lt;span&gt;&lt;span&gt;string&lt;/span&gt; item&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;_list.Add(item);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Add&lt;/span&gt;(&lt;span&gt;&lt;span&gt;string&lt;/span&gt; item, &lt;span&gt;int&lt;/span&gt; count&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++)&lt;br/&gt;{&lt;br/&gt;_list.Add(item);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerator &lt;span&gt;GetEnumerator&lt;/span&gt;()&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; _list.GetEnumerator();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;static &lt;/span&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;MyCollectionExtensions&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Add&lt;/span&gt;(&lt;span&gt;&lt;span&gt;this&lt;/span&gt; MyCollection @&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;double&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt; =&amp;gt;&lt;br/&gt;@this.Add(&lt;span&gt;value&lt;/span&gt;.ToString());&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;对象的集合属性初始化&lt;/h2&gt;
&lt;p&gt;我们知道对集合的初始化必须使用&lt;code&gt;new&lt;/code&gt;创建该集合，不能省略，比如：&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code readability=&quot;3&quot;&gt;&lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;IList&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; synonyms = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; { &lt;span&gt;&quot;c#&quot;&lt;/span&gt;, &lt;span&gt;&quot;c-sharp&quot;&lt;/span&gt; };&lt;p&gt;&lt;span&gt;// 编译报错，不能省略 new List&amp;lt;string&amp;gt;&lt;/span&gt;&lt;br/&gt;IList&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; synonyms = { &lt;span&gt;&quot;c#&quot;&lt;/span&gt;, &lt;span&gt;&quot;c-sharp&quot;&lt;/span&gt; };&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但如果该集合作为另外一个类的属性，则可以省略&lt;code&gt;new&lt;/code&gt;，比如：&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code readability=&quot;3&quot;&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;Tag&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; IList&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Synonyms { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;}&lt;p&gt;&lt;span&gt;var&lt;/span&gt; tag = &lt;span&gt;new&lt;/span&gt; Tag&lt;br/&gt;{&lt;br/&gt;Synonyms = { &lt;span&gt;&quot;c#&quot;&lt;/span&gt;, &lt;span&gt;&quot;c-sharp&quot;&lt;/span&gt; } &lt;span&gt;// OK&lt;/span&gt;&lt;br/&gt;};&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;能想到和找到的就这么点了，希望以上会对你的编程有所帮助。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jun 2020 00:38:00 +0000</pubDate>
<dc:creator>LiamWang</dc:creator>
<og:description>阅读本文大概需要 1.2 分钟。 随着 C# 的升级，C# 在语法上对对象的初始化做了不少简化，来看看有没有你不知道的。 数组的初始化 在上一篇罗列数组的小知识的时候，其中也提到了数组的初始化，这时直</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/13063609.html</dc:identifier>
</item>
<item>
<title>GitHub 热点速览 Vol.23：前后端最佳实践 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13062369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13062369.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607212829472-1904418824.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：最佳实践，又名 best-practices，是 GitHub 常见的项目名，也是本周 Trending 关键词。25 年 Python 开发经验的 David Beazley 撰写的 practical-python 开局并获得了超 1k 的 star，而老项目 Node.js 最佳实践在六月也开启了更新模式，持续更新 Node.js 性能实践篇。卡内基梅隆大学开源的 Penrose 一个可将复杂的数学符号转换为各种风格的简单图表的项目无疑是数据图表的最佳实践…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自微博&lt;a href=&quot;https://www.weibo.com/hellogithub/&quot;&gt;@HelloGitHub&lt;/a&gt; 的 GitHub Trending，选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 7 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过一周。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;本周特推&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 青春回忆：CnC_Remastered_Collection&lt;/li&gt;
&lt;li&gt;1.2 实用指南：practical-python&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;GitHub Trending 周榜&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 跨平台自动化：robotgo&lt;/li&gt;
&lt;li&gt;2.2 Docker 上的 Mac：Docker-OSX&lt;/li&gt;
&lt;li&gt;2.3 数学图表生成工具：Penrose&lt;/li&gt;
&lt;li&gt;2.4 换脸技术：Deepfakes&lt;/li&gt;
&lt;li&gt;2.5 面经：go-interview&lt;/li&gt;
&lt;li&gt;2.6 高颜值播放器：ZY-Player&lt;/li&gt;
&lt;li&gt;2.7 最佳实践：nodebestpractices&lt;/li&gt;
&lt;li&gt;2.8 苹果开源密码管理器：password-manager-resources&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;本周 GitHub Trending #Python 开发小工具# 主题的主力军&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1 内存占用分析：Memory Profiler&lt;/li&gt;
&lt;li&gt;3.2 异常监控：Sentry&lt;/li&gt;
&lt;li&gt;3.3 内存分析：scalene&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607212845451-1672410813.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-本周特推&quot;&gt;1. 本周特推&lt;/h2&gt;
&lt;h3 id=&quot;11-青春回忆：cnc_remastered_collection&quot;&gt;1.1 青春回忆：CnC_Remastered_Collection&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：7550+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt; CnC_Remastered_Collection 收录了游戏公司 EA 发布的《命令与征服》和《红色警戒》原作源代码。开源的代码不涉及游戏引擎和游戏素材，只包括 TiberianDawn.dll 和 RedAlert.dll 的源代码，开源的 DLL 可帮助玩家设计地图、创建自定义单位、替换艺术作品，以及更改游戏逻辑和编辑数据。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/electronicarts/CnC_Remastered_Collection&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607212902907-574404908.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-实用指南：practical-python&quot;&gt;1.2 实用指南：practical-python&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1050+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt;practical-python 是一名有 25 年 Python 开发经验的程序员撰写的实用 Python 指南。无需任何 Python 开发经验，非 Python 程序员也可以学习下该项目。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/dabeaz-course/practical-python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-github-trending-周榜&quot;&gt;2. GitHub Trending 周榜&lt;/h2&gt;
&lt;h3 id=&quot;21-跨平台自动化：robotgo&quot;&gt;2.1 跨平台自动化：robotgo&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;robotgo 是 Golang 跨平台自动化系统，控制键盘鼠标位图和读取屏幕，窗口句柄以及全局事件监听。支持 Windows、Linux、macOS。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/go-vgo/robotgo&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;22-docker-上的-mac：docker-osx&quot;&gt;2.2 Docker 上的 Mac：Docker-OSX&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：3700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt; Docker-OSX 是一个能让你在 Docker 上跑 Mac 的项目，它支持近乎原生的 OSX-KVM。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/sickcodes/Docker-OSX&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607212924968-511719108.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-数学图表生成工具：penrose&quot;&gt;2.3 数学图表生成工具：Penrose&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1550+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Penrose 一个只需在纯文本中输入数学符号就可以创建漂亮的图表的工具。这样做的目的是为了方便非专家专心研究更有有挑战性的技术，而非花精力研究如何创建和探索高质量图上。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/penrose/penrose&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607212937575-846852852.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;24-换脸技术：deepfakes&quot;&gt;2.4 换脸技术：Deepfakes&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1000+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Deepfakes 是一种利用机器学习中的深度学习实现深度视频换脸的技术。这种技术在特定的场合下可以做出非常逼真自然的换脸视频。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/iperov/DeepFaceLab&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607212948528-939511799.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;25-面经：go-interview&quot;&gt;2.5 面经：go-interview&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;go-interview 收录了用 Go 解决技术面试的方法。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/public-apis/public-apis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607213000070-1098887776.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;26-高颜值播放器：zy-player&quot;&gt;2.6 高颜值播放器：ZY-Player&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ZY-Player 是一个跨平台桌面端视频资源播放器，简洁无广告且颜值高。特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全平台支持：Windows、Mac、Linux&lt;/li&gt;
&lt;li&gt;12 个视频源&lt;/li&gt;
&lt;li&gt;支持历史播放记录，并记录播放进度&lt;/li&gt;
&lt;li&gt;支持分享功能，可一键分享海报图片&lt;/li&gt;
&lt;li&gt;精简模式支持修改透明度&lt;/li&gt;
&lt;li&gt;收藏夹同步更新视频追剧&lt;/li&gt;
&lt;li&gt;支持演员名称搜索&lt;/li&gt;
&lt;li&gt;后台自动更新&lt;/li&gt;
&lt;li&gt;全新布局配色&lt;/li&gt;
&lt;li&gt;多语言&lt;/li&gt;
&lt;li&gt;全局快捷键&lt;/li&gt;
&lt;li&gt;支持下载&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/Hunlongyu/ZY-Player&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607213013499-1533732627.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;27-最佳实践：nodebestpractices&quot;&gt;2.7 最佳实践：nodebestpractices&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nodebestpractices 是一个 Node.js 最佳实践列表，收录 5 篇项目结构实践、11 篇错误处理实践、12 篇代码风格实践、13 篇测试和整体质量实践、19 篇生产实践、25 篇安全实践及 2 篇性能实践，项目持续更新中，如果你对 Node.js 最佳实践用有心得不妨和项目作者交流下。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/goldbergyoni/nodebestpractices&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607213025334-266715450.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;28-苹果开源密码管理器：password-manager-resources&quot;&gt;2.8 苹果开源密码管理器：password-manager-resources&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：800+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt;苹果推出全新开源项目——Password Manager Resources，它集成苹果 iCloud Keychain Password Manager，可以让密码管理 App 开发者为特定网站创建可以兼容的强密码，这个机制与 iCloud 钥匙串密码管理器相同。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/apple/password-manager-resources&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607213038864-1264447080.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-本周-github-trending-python-开发小工具主题的主力军&quot;&gt;3. 本周 GitHub Trending #Python 开发小工具#主题的主力军&lt;/h2&gt;
&lt;p&gt;在本期主题模块，小鱼干这里选取了 3 个 Python 性能相关的小工具，希望能提高你的开发效率。&lt;/p&gt;
&lt;h3 id=&quot;31-内存占用分析：memory-profiler&quot;&gt;3.1 内存占用分析：Memory Profiler&lt;/h3&gt;
&lt;p&gt;Memory Profiler 一听名字就是一个 Python 程序内存占用分析工具，它可以监视一个进程的内存消耗，甚至可以一行一行的分析 Python 程序的内存消耗。Memory Profiler 由 Python 实现，用户可选 psutil 模块（强烈推荐）作为依赖，会分析得更快。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/pythonprofilers/memory_profiler&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607213051864-911963009.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-异常监控：sentry&quot;&gt;3.2 异常监控：Sentry&lt;/h3&gt;
&lt;p&gt;Sentry，一款免费开源的 Python 实时异常监控平台。Sentry 采用 C/S 模式，服务器端通过 Python 实现，同时提供 web 管理页面，支持从任何语言、任何应用程序发送事件。一个成熟的服务必要的一环就是异常告警，Sentry 可以帮你及时知道服务非预期的异常。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/getsentry/sentry&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607213102639-2020859128.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-内存分析：scalene&quot;&gt;3.3 内存分析：scalene&lt;/h3&gt;
&lt;p&gt;scalene 一个 Python 的高性能 CPU 和内存分析器。Scalene 很快、占用资源少、展示信息全面，可用来排查、优化 Python 程序占用资源过多等问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/emeryberger/scalene&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607213113607-819129926.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 23 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200607213256599-1237413020.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 08 Jun 2020 00:33:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub-小鱼干 摘要：最佳实践，又名 best-practices，是 GitHub 常见的项目名，也是本周 Trending 关键词。25 年 Python 开发经验的 Dav</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13062369.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core通过Nacos SDK读取阿里云ACM - Catcher8</title>
<link>http://www.cnblogs.com/catcher1994/p/13063585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/catcher1994/p/13063585.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;前段时间，cranelee 在Github上给老黄提了个issues， 问到了如何用Nacos的SDK访问阿里云ACM。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/catcherwong/nacos-sdk-csharp/issues/13&quot;&gt;https://github.com/catcherwong/nacos-sdk-csharp/issues/13&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚看到这个issues的时候，老黄也是觉得一脸懵逼，好像这两者没有什么必然联系，打开ACM的文档一看，就知道为什么了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202006/558945-20200608082226235-1967191421.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来Java和Go的已经是可以用nacos的SDK来访问的了。那就说明两者是兼容的。&lt;/p&gt;
&lt;p&gt;这段时间抽空看了一下，把这个功能基本实现了。&lt;/p&gt;
&lt;p&gt;下面就简单介绍一下。&lt;/p&gt;
&lt;h2 id=&quot;简单看看acm&quot;&gt;简单看看ACM&lt;/h2&gt;
&lt;p&gt;开通ACM之后，可以看到类似这样的界面。其实和Nacos控制台的配置部分差不远。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202006/558945-20200608082246758-671518738.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要使用这个的话，需要几个东西，一个是ACM上面的命名空间，一个是AccessKey ID，一个是AccessKey Secret。&lt;/p&gt;
&lt;p&gt;其中的AK/SK可以在命名空间详情里面获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202006/558945-20200608082306388-1562665722.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就是添加配置了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202006/558945-20200608082321652-1080980732.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三张图，看个大概就好了，下面来具体看看在.NET Core中怎么使用。&lt;/p&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;如何使用&lt;/h2&gt;
&lt;h3 id=&quot;安装最新预览版的sdk&quot;&gt;安装最新预览版的SDK&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&quot;nacos-sdk-csharp-unofficial.Extensions.Configuration&quot; Version=&quot;0.2.7-alpha7&quot; /&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：目前还没有发布正式版，不过不影响正常使用了。&lt;/p&gt;
&lt;h3 id=&quot;修改program&quot;&gt;修改Program&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class Program
{
    public static void Main(string[] args)
    {
        // 处理编码问题
        System.Text.Encoding.RegisterProvider(System.Text.CodePagesEncodingProvider.Instance);

        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((context, builder) =&amp;gt;
            {
                // 这两行代码就是关键
                var c = builder.Build();
                builder.AddNacosConfiguration(c.GetSection(&quot;NacosConfig&quot;));
            })
            .ConfigureWebHostDefaults(webBuilder =&amp;gt;
            {
                webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
            });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;调整appsettingsjson&quot;&gt;调整appsettings.json&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;NacosConfig&quot;: {
    &quot;Optional&quot;: false,
    &quot;DataId&quot;: &quot;msconfigapp&quot;,
    &quot;Group&quot;: &quot;&quot;,
    &quot;Tenant&quot;: &quot;&amp;lt;换成您的命名空间&amp;gt;&quot;,
    &quot;ServerAddresses&quot;: [],
    &quot;AccessKey&quot;: &quot;&amp;lt;换成您的AK&amp;gt;&quot;,
    &quot;SecretKey&quot;: &quot;&amp;lt;换成您的SK&amp;gt;&quot;,
    &quot;EndPoint&quot;: &quot;acm.aliyun.com&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注： 由于老黄开通个人开通的，没有内网服务器，所以用的是公网的EndPoint，这个需要根据情况自行调整。&lt;/p&gt;
&lt;h3 id=&quot;实体映射非必须&quot;&gt;实体映射(非必须)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public class AppSettings
{
    public string Str { get; set; }

    public int Num { get; set; }

    public List&amp;lt;int&amp;gt; Arr { get; set; }

    public SubObj SubObj { get; set; }
}

public class SubObj
{
    public string a { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了方便和配置一一对应，可以建立实体，做一个映射。&lt;/p&gt;
&lt;p&gt;加了这个的，需要在Startup上面配置一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public void ConfigureServices(IServiceCollection services)
{   
    // others ...
    
    services.Configure&amp;lt;AppSettings&amp;gt;(Configuration.GetSection(&quot;AppSettings&quot;));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;读取配置&quot;&gt;读取配置&lt;/h3&gt;
&lt;p&gt;这里用控制器做为示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ApiController]
[Route(&quot;api/[controller]&quot;)]
public class ConfigController : ControllerBase
{
    private readonly ILogger&amp;lt;ConfigController&amp;gt; _logger;
    private readonly IConfiguration _configuration;
    private readonly AppSettings _settings;
    private readonly AppSettings _sSettings;
    private readonly AppSettings _mSettings;

    public ConfigController(
        ILogger&amp;lt;ConfigController&amp;gt; logger,
        IConfiguration configuration,
        IOptions&amp;lt;AppSettings&amp;gt; options,
        IOptionsSnapshot&amp;lt;AppSettings&amp;gt; sOptions,
        IOptionsMonitor&amp;lt;AppSettings&amp;gt; _mOptions
        )
    {
        _logger = logger;
        _configuration = configuration;
        _settings = options.Value;
        _sSettings = sOptions.Value;
        _mSettings = _mOptions.CurrentValue;
    }

    [HttpGet]
    public string Get()
    {
        string id = Guid.NewGuid().ToString(&quot;N&quot;);

        _logger.LogInformation($&quot;============== begin {id} =====================&quot;);

        var conn = _configuration.GetConnectionString(&quot;Default&quot;);
        _logger.LogInformation($&quot;{id} conn = {conn}&quot;);

        var version = _configuration[&quot;version&quot;];
        _logger.LogInformation($&quot;{id} version = {version}&quot;);

        var str1 = Newtonsoft.Json.JsonConvert.SerializeObject(_settings);
        _logger.LogInformation($&quot;{id} IOptions = {str1}&quot;);

        var str2 = Newtonsoft.Json.JsonConvert.SerializeObject(_sSettings);
        _logger.LogInformation($&quot;{id} IOptionsSnapshot = {str2}&quot;);

        var str3 = Newtonsoft.Json.JsonConvert.SerializeObject(_mSettings);
        _logger.LogInformation($&quot;{id} IOptionsMonitor = {str3}&quot;);

        _logger.LogInformation($&quot;===============================================&quot;);
        _logger.LogInformation($&quot;===============================================&quot;);
        _logger.LogInformation($&quot;===============================================&quot;);

        return &quot;ok&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;附上一张操作动图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/558945/202006/558945-20200608082349167-578209442.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在ACM上修改之后，程序是可以马上读取到的。&lt;/p&gt;
&lt;p&gt;下面是本文的示例代码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/catcherwong-archive/2020/tree/master/06/NacosACMDemo&quot;&gt;https://github.com/catcherwong-archive/2020/tree/master/06/NacosACMDemo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;Nacos和ACM的操作基本都是一致的，比较不一样的地方是，从直连Nacos变成要先去地址服务拿到Nacos的地址后再操作。&lt;/p&gt;
</description>
<pubDate>Mon, 08 Jun 2020 00:26:00 +0000</pubDate>
<dc:creator>Catcher8</dc:creator>
<og:description>ASP.NET Core通过Nacos SDK读取阿里云ACM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/catcher1994/p/13063585.html</dc:identifier>
</item>
<item>
<title>异步函数async await在wpf都做了什么？ - RyzenAdorer</title>
<link>http://www.cnblogs.com/ryzen/p/13062963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ryzen/p/13062963.html</guid>
<description>&lt;p&gt;首先我们来看一段控制台应用代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt; class Program
 {
     static async Task Main(string[] args)
     {
        System.Console.WriteLine($&quot;Thread Id is Thread:{Thread.CurrentThread.ManagedThreadId},Is Thread Pool:{Thread.CurrentThread.IsThreadPoolThread}&quot;);
        var result = await ExampleTask(2);
        System.Console.WriteLine($&quot;Thread Id is Thread:{Thread.CurrentThread.ManagedThreadId},Is Thread Pool:{Thread.CurrentThread.IsThreadPoolThread}&quot;);
        System.Console.WriteLine(result);
        Console.WriteLine(&quot;Async Completed&quot;);
     }

     private static async Task&amp;lt;string&amp;gt; ExampleTask(int Second)
     {
        await Task.Delay(TimeSpan.FromSeconds(Second));
        return $&quot;It's Async Completed in {Second} seconds&quot;;
     }
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread Id is Thread:1,Is Thread Pool:False
Thread Id is Thread:4,Is Thread Pool:True
It's Async Completed in 2 seconds
Async Completed
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果这段代码在WPF运行，猜猜会输出啥？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;      private async void Async_Click(object sender, RoutedEventArgs e)
      {
          Debug.WriteLine($&quot;Thread Id is Thread:{Thread.CurrentThread.ManagedThreadId},Is Thread Pool:{Thread.CurrentThread.IsThreadPoolThread}&quot;);
          var result= await ExampleTask(2);
          Debug.WriteLine($&quot;Thread Id is Thread:{Thread.CurrentThread.ManagedThreadId},Is Thread Pool:{Thread.CurrentThread.IsThreadPoolThread}&quot;);
          Debug.WriteLine(result);
          Debug.WriteLine(&quot;Async Completed&quot;);   
      }

      private async Task&amp;lt;string&amp;gt; ExampleTask(int Second)
      {
          await Task.Delay(TimeSpan.FromSeconds(Second));
          return $&quot;It's Async Completed in {Second} seconds&quot;;
      }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread Id is Thread:1,Is Thread Pool:False
Thread Id is Thread:1,Is Thread Pool:False
It's Async Completed in 2 seconds
Async Completed
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候你肯定是想说，小朋友，你是否有很多问号？？？？，我们接下看下去&lt;/p&gt;
&lt;h3 id=&quot;一synchronizationcontext同步上下文&quot;&gt;一.&lt;strong&gt;SynchronizationContext&lt;/strong&gt;(同步上下文)&lt;/h3&gt;
&lt;p&gt;首先我们知道async await 异步函数本质是状态机,我们通过反编译工具dnspy，看看反编译的两段代码是否有不同之处：&lt;/p&gt;
&lt;p&gt;控制台应用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;internal class Program
{
    [DebuggerStepThrough]
        private static Task Main(string[] args)
        {
                Program.&amp;lt;Main&amp;gt;d__0 &amp;lt;Main&amp;gt;d__ = new Program.&amp;lt;Main&amp;gt;d__0();
                &amp;lt;Main&amp;gt;d__.args = args;
                &amp;lt;Main&amp;gt;d__.&amp;lt;&amp;gt;t__builder = AsyncTaskMethodBuilder.Create();
                &amp;lt;Main&amp;gt;d__.&amp;lt;&amp;gt;1__state = -1;
                &amp;lt;Main&amp;gt;d__.&amp;lt;&amp;gt;t__builder.Start&amp;lt;Program.&amp;lt;Main&amp;gt;d__0&amp;gt;(ref &amp;lt;Main&amp;gt;d__);
                return &amp;lt;Main&amp;gt;d__.&amp;lt;&amp;gt;t__builder.Task;
        }
    
        [DebuggerStepThrough]
        private static Task&amp;lt;string&amp;gt; ExampleTask(int Second)
        {
                Program.&amp;lt;ExampleTask&amp;gt;d__1 &amp;lt;ExampleTask&amp;gt;d__ = new Program.&amp;lt;ExampleTask&amp;gt;d__1();
                &amp;lt;ExampleTask&amp;gt;d__.Second = Second;
                &amp;lt;ExampleTask&amp;gt;d__.&amp;lt;&amp;gt;t__builder = AsyncTaskMethodBuilder&amp;lt;string&amp;gt;.Create();
                &amp;lt;ExampleTask&amp;gt;d__.&amp;lt;&amp;gt;1__state = -1;
                &amp;lt;ExampleTask&amp;gt;d__.&amp;lt;&amp;gt;t__builder.Start&amp;lt;Program.&amp;lt;ExampleTask&amp;gt;d__1&amp;gt;(ref &amp;lt;ExampleTask&amp;gt;d__);
                return &amp;lt;ExampleTask&amp;gt;d__.&amp;lt;&amp;gt;t__builder.Task;
        }

        [DebuggerStepThrough]
        private static void &amp;lt;Main&amp;gt;(string[] args)
        {
                Program.Main(args).GetAwaiter().GetResult();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;WPF:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class MainWindow : Window, IComponentConnector
{

        public MainWindow()
        {
               this.InitializeComponent();
        }

        [DebuggerStepThrough]
        private void Async_Click(object sender, RoutedEventArgs e)
        {
                MainWindow.&amp;lt;Async_Click&amp;gt;d__1 &amp;lt;Async_Click&amp;gt;d__ = new MainWindow.&amp;lt;Async_Click&amp;gt;d__1();
                &amp;lt;Async_Click&amp;gt;d__.&amp;lt;&amp;gt;4__this = this;
                &amp;lt;Async_Click&amp;gt;d__.sender = sender;
                &amp;lt;Async_Click&amp;gt;d__.e = e;
                &amp;lt;Async_Click&amp;gt;d__.&amp;lt;&amp;gt;t__builder = AsyncVoidMethodBuilder.Create();
                &amp;lt;Async_Click&amp;gt;d__.&amp;lt;&amp;gt;1__state = -1;
                &amp;lt;Async_Click&amp;gt;d__.&amp;lt;&amp;gt;t__builder.Start&amp;lt;MainWindow.&amp;lt;Async_Click&amp;gt;d__1&amp;gt;(ref &amp;lt;Async_Click&amp;gt;d__);
        }

        [DebuggerStepThrough]
        private Task&amp;lt;string&amp;gt; ExampleTask(int Second)
        {
                MainWindow.&amp;lt;ExampleTask&amp;gt;d__3 &amp;lt;ExampleTask&amp;gt;d__ = new MainWindow.&amp;lt;ExampleTask&amp;gt;d__3();
                &amp;lt;ExampleTask&amp;gt;d__.&amp;lt;&amp;gt;4__this = this;
                &amp;lt;ExampleTask&amp;gt;d__.Second = Second;
                &amp;lt;ExampleTask&amp;gt;d__.&amp;lt;&amp;gt;t__builder = AsyncTaskMethodBuilder&amp;lt;string&amp;gt;.Create();
                &amp;lt;ExampleTask&amp;gt;d__.&amp;lt;&amp;gt;1__state = -1;
                &amp;lt;ExampleTask&amp;gt;d__.&amp;lt;&amp;gt;t__builder.Start&amp;lt;MainWindow.&amp;lt;ExampleTask&amp;gt;d__3&amp;gt;(ref &amp;lt;ExampleTask&amp;gt;d__);
                return &amp;lt;ExampleTask&amp;gt;d__.&amp;lt;&amp;gt;t__builder.Task;
        }

        [DebuggerNonUserCode]
        [GeneratedCode(&quot;PresentationBuildTasks&quot;, &quot;4.8.1.0&quot;)]
        public void InitializeComponent()
        {
                bool contentLoaded = this._contentLoaded;
                if (!contentLoaded)
                {
                     this._contentLoaded = true;
                     Uri resourceLocater = new Uri(&quot;/WpfApp1;component/mainwindow.xaml&quot;, UriKind.Relative);
                     Application.LoadComponent(this, resourceLocater);
                }
        }
        private bool _contentLoaded;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到完全是一致的，没有任何区别，为什么编译器生成的代码是一致的，却会产生不一样的结果，我们看看创建和启动状态机代码部分的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static AsyncVoidMethodBuilder Create()
{
        SynchronizationContext synchronizationContext = SynchronizationContext.Current;
        if (synchronizationContext != null)
        {
                synchronizationContext.OperationStarted();
        }
        return new AsyncVoidMethodBuilder
        {
                _synchronizationContext = synchronizationContext
        };
}

[DebuggerStepThrough]
[MethodImpl(MethodImplOptions.AggressiveInlining)]
public void Start&amp;lt;[Nullable(0)] TStateMachine&amp;gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine
{
        AsyncMethodBuilderCore.Start&amp;lt;TStateMachine&amp;gt;(ref stateMachine);
}

[DebuggerStepThrough]
public static void Start&amp;lt;TStateMachine&amp;gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine
{
        if (stateMachine == null)
        {
                ThrowHelper.ThrowArgumentNullException(ExceptionArgument.stateMachine);
        }
        Thread currentThread = Thread.CurrentThread;
        Thread thread = currentThread;
        ExecutionContext executionContext = currentThread._executionContext;
        ExecutionContext executionContext2 = executionContext;
        SynchronizationContext synchronizationContext = currentThread._synchronizationContext;
        try
        {
             stateMachine.MoveNext();//状态机执行代码
        }
        finally
        {
             SynchronizationContext synchronizationContext2 = synchronizationContext;
             Thread thread2 = thread;
             if (synchronizationContext2 != thread2._synchronizationContext)
             {
                  thread2._synchronizationContext = synchronizationContext2;
             }
             ExecutionContext executionContext3 = executionContext2;
             ExecutionContext executionContext4 = thread2._executionContext;
             if (executionContext3 != executionContext4)
             {
                 ExecutionContext.RestoreChangedContextToThread(thread2, executionContext3, executionContext4);
             }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里总结下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建状态机的&lt;strong&gt;Create&lt;/strong&gt;函数通过&lt;strong&gt;SynchronizationContext.Current&lt;/strong&gt;获取到当前同步执行上下文&lt;/li&gt;
&lt;li&gt;启动状态机的&lt;strong&gt;Start&lt;/strong&gt;函数之后通过&lt;strong&gt;MoveNext&lt;/strong&gt;函数执行我们的异步方法&lt;/li&gt;
&lt;li&gt;这里还有一个小提示，不管&lt;strong&gt;async&lt;/strong&gt;函数里面有没有&lt;strong&gt;await&lt;/strong&gt;，都会生成状态机，只是&lt;strong&gt;MoveNext&lt;/strong&gt;函数执行同步方法,因此没await的情况下避免将函数标记为async，会损耗性能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同样的这里貌似没能获取到原因，但是有个很关键的地方，就是&lt;strong&gt;Create&lt;/strong&gt;函数为啥要获取当前同步执行上下文，之后我从MSDN找到关于&lt;a href=&quot;https://docs.microsoft.com/zh-cn/archive/msdn-magazine/2011/february/msdn-magazine-parallel-computing-it-s-all-about-the-synchronizationcontext&quot;&gt;SynchronizationContext&lt;/a&gt;&lt;br/&gt;的介绍，有兴趣的朋友可以去阅读以下，以下是各个.NET框架使用的SynchronizationContext：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;SynchronizationContext&lt;/th&gt;
&lt;th&gt;默认&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;WindowsFormsSynchronizationContext&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;WindowsForm&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;DispatcherSynchronizationContext&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;WPF/Silverlight&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;AspNetSynchronizationContext&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;ASP.NET&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们貌似已经一步步接近真相了，接下来我们来看看&lt;strong&gt;DispatcherSynchronizationContext&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;二dispatchersynchronizationcontext&quot;&gt;二.&lt;strong&gt;DispatcherSynchronizationContext&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;首先来看看&lt;strong&gt;DispatcherSynchronizationContext&lt;/strong&gt;类的比较关键的几个函数实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public DispatcherSynchronizationContext(Dispatcher dispatcher, DispatcherPriority priority)
{
     if (dispatcher == null)
     {
         throw new ArgumentNullException(&quot;dispatcher&quot;);
     }
     Dispatcher.ValidatePriority(priority, &quot;priority&quot;);
     _dispatcher = dispatcher;
     _priority = priority;
     SetWaitNotificationRequired();
 }

//同步执行
public override void Send(SendOrPostCallback d, object state)
{
     if (BaseCompatibilityPreferences.GetInlineDispatcherSynchronizationContextSend() &amp;amp;&amp;amp; _dispatcher.CheckAccess())
     {
         _dispatcher.Invoke(DispatcherPriority.Send, d, state);
     }
     else
     {
          _dispatcher.Invoke(_priority, d, state);
     }
}

//异步执行
public override void Post(SendOrPostCallback d, object state)
{
     _dispatcher.BeginInvoke(_priority, d, state);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们貌似看到了熟悉的东西了，Send函数调用Dispatcher的Invoke函数，Post函数调用Dispatcher的BeginInvoke函数，那么是否WPF执行异步函数之后会调用这里的函数吗？我用dnspy进行了调试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1294271/202006/1294271-20200607232014268-649516237.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我通过调试之后发现，当等待执行完整个状态机的之后，也就是两秒后跳转到该Post函数，那么，我们可以将之前的WPF那段代码大概可以改写成如此：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;private async void Async_Click(object sender, RoutedEventArgs e)
{
    //async生成状态机的Create函数。获取到UI主线程的同步执行上下文
    DispatcherSynchronizationContext synchronizationContext = (DispatcherSynchronizationContext)SynchronizationContext.Current;
    
    //UI主线程执行
    Debug.WriteLine($&quot;Thread Id is Thread:{Thread.CurrentThread.ManagedThreadId},Is Thread Pool:{Thread.CurrentThread.IsThreadPoolThread}&quot;);
    
    //开始在状态机的MoveNext执行该异步操作
    var result= await ExampleTask(2);
    
    //等待两秒，异步执行完成，再在同步上下文异步执行
    synchronizationContext.Post((state) =&amp;gt;
    {
         //模仿_dispatcher.BeginInvoke
         Debug.WriteLine($&quot;Thread Id is Thread:{Thread.CurrentThread.ManagedThreadId},Is Thread Pool:{Thread.CurrentThread.IsThreadPoolThread}&quot;);
         Debug.WriteLine(result);
         Debug.WriteLine(&quot;Async Completed&quot;);  
     },&quot;Post&quot;);           
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread Id is Thread:1,Is Thread Pool:False
Thread Id is Thread:1,Is Thread Pool:False
It's Async Completed in 2 seconds
Async Completed
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是asyn负责生成状态机和执行状态机，await将代码分为两部分，一部分是异步执行状态机部分，一部分是异步执行完之后，通过之前拿到的DispatcherSynchronizationContext，再去异步执行接下来的部分。我们可以通过dnspy调试DispatcherSynchronizationContext的 _dispatcher字段的Thread属性，知道Thread为UI主线程，而同步界面UI控件的时候，也就是通过Dispatcher的BeginInvoke函数去执行同步的&lt;/p&gt;
&lt;h3 id=&quot;三taskconfigureawait&quot;&gt;三.Task.ConfigureAwait&lt;/h3&gt;
&lt;p&gt;Task有个ConfigureAwait方法，是可以设置是否对Task的awaiter的延续任务执行原始上下文，也就是为true时，是以一开始那个UI主线程的DispatcherSynchronizationContext执行Post方法,而为false，则以await那个Task里面的DispatcherSynchronizationContext执行Post方法，我们来验证下：&lt;/p&gt;
&lt;p&gt;我们将代码改为以下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;private async void Async_Click(object sender, RoutedEventArgs e)
{
    Debug.WriteLine($&quot;Thread Id is Thread:{Thread.CurrentThread.ManagedThreadId},Is Thread Pool:{Thread.CurrentThread.IsThreadPoolThread}&quot;);
    var result= await ExampleTask(2).ConfigureAwait(false);
    Debug.WriteLine($&quot;Thread Id is Thread:{Thread.CurrentThread.ManagedThreadId},Is Thread Pool:{Thread.CurrentThread.IsThreadPoolThread}&quot;);
    Debug.WriteLine(result);
    Debug.WriteLine($&quot;Async Completed&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread Id is Thread:1,Is Thread Pool:False
Thread Id is Thread:4,Is Thread Pool:True
It's Async Completed in 2 seconds
Async Completed
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果和控制台输出的一模一样，且通过dnspy断点调试依旧进入到DispatcherSynchronizationContext的Post方法,因此我们也可以证明我们上面的猜想，而且默认ConfigureAwait的参数是为true的,我们还可以将异步结果赋值给UI界面的Text block：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;private async void Async_Click(object sender, RoutedEventArgs e)
{
    Debug.WriteLine($&quot;Thread Id is Thread:{Thread.CurrentThread.ManagedThreadId},Is Thread Pool:{Thread.CurrentThread.IsThreadPoolThread}&quot;);
    var result= await ExampleTask(2).ConfigureAwait(false);
    Debug.WriteLine($&quot;Thread Id is Thread:{Thread.CurrentThread.ManagedThreadId},Is Thread Pool:{Thread.CurrentThread.IsThreadPoolThread}&quot;);
    this.txt.Text = result;//修改部分
    Debug.WriteLine($&quot;Async Completed&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抛出异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;调用线程无法访问此对象，因为另一个线程拥有该对象
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 08 Jun 2020 00:19:00 +0000</pubDate>
<dc:creator>RyzenAdorer</dc:creator>
<og:description>首先我们来看一段控制台应用代码： class Program { static async Task Main(string[] args) { System.Console.WriteLine($&amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ryzen/p/13062963.html</dc:identifier>
</item>
<item>
<title>基于Azure IoT开发.NET物联网应用系列-全新的Azure IoT架构 - Eric zhou</title>
<link>http://www.cnblogs.com/tianqing/p/13061828.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianqing/p/13061828.html</guid>
<description>&lt;p&gt;物联网技术已经火了很多年了，业界各大厂商都有各自成熟的解决方案。我们公司主要搞新能源汽车充电，充电桩就是物联网技术的最大应用，车联网、物联网、互联网三网合一。2017年的时候重点研究过Azure IoT技术架构和使用，&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle1&quot; href=&quot;http://www.cnblogs.com/tianqing/p/6711060.html&quot;&gt;Azure IoT 技术研究系列1-入门篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;随着业界技术的发展，近期又重新关注并研究了最新的Azure  IoT架构，现在将结合着.NET Core技术和Azure IoT 做一些物联网应用，将研究的成果分享给大家。&lt;/p&gt;
&lt;p&gt;关于IoT的一些基本概念，重新梳理一下，分享给大家：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IoT：&lt;strong&gt;Internet of Things，即万网互联&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;IoT Devices：物联网设备。&lt;/li&gt;
&lt;li&gt;IoT Edge Devices：物联网边缘计算设备。&lt;/li&gt;
&lt;li&gt;IoT Gateway：IoT网关，负责IoT物联网设备的接入、管理和控制、通讯（上行和下行）&lt;/li&gt;
&lt;li&gt;通讯协议：TCP、MQTT、AMQP、HTTPS、zgebee等等&lt;/li&gt;
&lt;li&gt;Azure IoT Central。 IoT Central 是完全托管的 IoT物联网 SaaS（软件即服务）服务&lt;/li&gt;
&lt;li&gt;目前Azure仍然提供了Azure IoT Hub：直译为&lt;strong&gt;Azure的物联网中心&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Azure IoT Hub为物联网设备提供&lt;strong&gt;注册、管理、沟通交互&lt;/strong&gt;的云服务。可用于管理数十亿物联网设备，提供可靠和安全的云端与设备之间的双向通信支持，每月可处理数以万亿计消息，并简化了与其他Azure服务之间的集成，包括Azure机器学习以及&lt;/li&gt;
&lt;li&gt;Azure流分析等。它是微软Azure IoT Suite的重要组成部分，也是微软物联网战略的重要基础。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，我们看一下Azure IoT最新的技术架构：&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202006/23525-20200607193229647-115037538.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   下面，我们详细介绍一下这个架构组成：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   一、 Things（物联网设备侧）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  1. IoT devices：前面已经介绍过了，泛指各类物联网设备。设备可以安全地注册到云中，并且可以连接到云之后，发送和接收数据。&lt;/p&gt;
&lt;p&gt;  2. IoT edge devices:物联网边缘计算设备，某些设备可能会是在设备本身上或在现场网关中执行一些数据处理的边缘设备。举个大家平时常见的设备：充电桩，作为IoT边缘计算设备，其自身有嵌入式操作系统、AI智能芯片，可以实现一些简单的边缘计算场景&lt;/p&gt;
&lt;p&gt;  3. Cloud Gateway：云网关，云网关提供一个云中心，以便设备安全地连接到云并发送数据。 它还提供设备管理功能，包括设备的命令和控制。&lt;/p&gt;
&lt;p&gt;      对于云网关，Azure 建议使用Azure  IoT 中心。Azure IoT 中心是从设备引入事件的托管云服务，充当设备与后端服务之间的消息代理。 同时提供安全连接、事件引入、双向通信和设备管理。&lt;/p&gt;
&lt;p&gt;      当然，我们也可以自建云网关，支持各类物联网设备的接入、管理和控制。&lt;/p&gt;
&lt;p&gt;  4. Bulk devices provisioning：设备批量设置，统一管理设置海量设备。 对于注册和连接许多组设备。可以使用 IoT 中心设备预配服务 (DPS)。 DPS 可用于大规模分配设备并将设备注册到特定 Azure IoT 中心终结点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、Insights（洞察、洞见，可以理解为设备接入管理、数据处理、数据持久化、数据分析、可视化）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;1. Streaming Processing：流式数据处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  Azure提供了专门的流分析服务。 流分析可以使用时间开窗函数、流聚合和外部数据源联接大规模执行复杂分析。假如说我们自建系统做物联网数据流式分析的话，可以使用Kafka、Flink、Spark等主流的大数据流式分析技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  2. Data transformation：数据转换操作或聚合遥测数据流。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  常见的场景包括通讯协议转换，例如，将二进制数据转换为 JSON，或者合并数据点。 如果数据在到达 IoT 中心之前必须转换，可以使用协议网关（一个可以转换数据的网关）。 同时，数据可以在到达 IoT 中心后转换。&lt;/p&gt;
&lt;p&gt;  在这种情况下，可以使用 Azure Functions 函数计算，Azure Functions内置了与 IoT 中心、Cosmos DB 和 Blob 存储的集成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  3. Warm path store：热存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  热存储，存储实时物联网设备上传下发的数据，这些数据必须可按设备实时查询，以用于报告和可视化。举个实际的业务场景：充电桩实时上传的电压、电流、SOC等实时设备数据，这些数据的实时性要求高，可以存储在热存储中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  4. Cold path store：冷存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  如果所有的物联网设备数据全部存储在热存储中，其硬件成本会很高。数据具备一定的时效性，因为，当数据失去了一定的时效性要求后，可以存储在冷存储中，降低存储的成本。&lt;/p&gt;
&lt;p&gt;  这些数据会保留较长时间，用于批处理。 对于冷路径存储，可以使用 Azure Blob 存储。 数据可无限期地以较低成本在 Blob 存储中存档，并且可以轻松访问以进行批处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  5. UI Reporting and tools：可视化展现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  可视化展现方面，通常包含：IoT设备管理UI、设备控制UI、趋势图、连接状态图表、数据分析图表等等，这个地方可以使用各类UI展现技术实现了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、 Action（运维管理、操作）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  1. Machine Learning：机器学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   大家会问，用机器学习干什么？通过历史遥测数据执行模型训练，实现IoT设备的预测性维护，同时还能做什么？还可以对上报的数据建立不同的模型，实时进行训练，智能控制设备。比如说充电桩的例子，动态调控充电功率，实现最大充电效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  2. Business integration：业务流程集成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   业务流程集成根据来自设备数据执行各类后续操作。 可以包括：存储实时消息、引发警报、发送电子邮件或短信，或者与 CRM 集成。举个实际的业务场景：当需要设备运维时，发出一个运维工单到产品运维部门，实现IoT设备的智能运维和派单处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  3. User Management：用户管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   用户管理限制哪些用户或组可以在设备上执行操作，例如升级固件。 它还定义应用程序中的用户功能。&lt;/p&gt;
&lt;p&gt;  综上是Azure IoT架构的详细介绍和说明，比2017年时，产品更加SaaS化，更加AI智能、更加体系。分享给大家。&lt;/p&gt;


&lt;p&gt;周国庆&lt;/p&gt;
&lt;p&gt;2020/6/7&lt;/p&gt;
</description>
<pubDate>Sun, 07 Jun 2020 23:51:00 +0000</pubDate>
<dc:creator>Eric zhou</dc:creator>
<og:description>物联网技术已经火了很多年了，业界各大厂商都有各自成熟的解决方案。我们公司主要搞新能源汽车充电，充电桩就是物联网技术的最大应用，车联网、物联网、互联网三网合一。2017年的时候重点研究过Azure Io</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tianqing/p/13061828.html</dc:identifier>
</item>
<item>
<title>分布式锁没那么难，手把手教你实现 Redis 分布锁！|保姆级教程 - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13063532.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13063532.html</guid>
<description>&lt;h2 id=&quot;书接上文&quot;&gt;书接上文&lt;/h2&gt;
&lt;p&gt;上篇文章「&lt;a href=&quot;https://studyidea.cn/mysql-rr-bug&quot;&gt;MySQL 可重复读，差点就让我背上了一个 P0 事故！&lt;/a&gt;」发布之后，收到很多小伙伴们的留言，从中又学习到很多，总结一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073932644-1578286838.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上篇文章可能举得例子有点不恰当，导致有些小伙伴没看懂为什么余额会变负。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073932992-1795582857.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次我们举得实际一点，还是上篇文章 account 表，假设 &lt;strong&gt;id=1，balance=1000&lt;/strong&gt;，不过这次我们扣款 &lt;strong&gt;1000&lt;/strong&gt;，两个事务的时序图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073933500-412750065.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次使用两个命令窗口真实执行一把：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073933872-1392031325.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意事务 2，③处查询到 &lt;strong&gt;id=1，balance=1000&lt;/strong&gt;，但是实际上由于此时事务 1 已经提交，最新结果如②处所示 &lt;strong&gt;id=1，balance=900&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本来 Java 代码层会做一层余额判断：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (balance - amount &amp;lt; 0) {
  throw new XXException(&quot;余额不足，扣减失败&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是此时由于 ③ 处使用快照读，读到是个旧值，未读到最新值，导致这层校验失效，从而代码继续往下运行，执行了数据更新。&lt;/p&gt;
&lt;p&gt;更新语句又采用如下写法:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;UPDATE account set balance=balance-1000 WHERE id =1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条更新语句又必须是在这条记录的最新值的基础做更新，更新语句执行结束，这条记录就变成了 &lt;strong&gt;id=1，balance=-1000&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073934511-1263757950.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前有朋友疑惑 t12 更新之后，再次进行快照读，结果会是多少。&lt;/p&gt;
&lt;p&gt;上图执行结果 ④ 可以看到结果为 &lt;strong&gt;id=1,balance=-1000&lt;/strong&gt;,可以看到已经查询最新的结果记录。&lt;/p&gt;
&lt;p&gt;这行数据最新版本由于是事务 2 自己更新的，&lt;strong&gt;自身事务更新永远对自己可见&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外这次问题上本质上因为 Java 层与数据库层数据不一致导致，有的朋友留言提出，可以在更新余额时加一层判断：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;UPDATE account set balance=balance-1000 WHERE id =1 and balance&amp;gt;0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后更新完成，Java 层判断更新有效行数是否大于 0。这种做法确实能规避这个问题。&lt;/p&gt;
&lt;p&gt;最后这位朋友留言总结的挺好，粘贴一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073934883-216786857.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;先赞后看，微信搜索「程序通事」，关注就完事了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;手撸分布式锁&quot;&gt;手撸分布式锁&lt;/h2&gt;
&lt;p&gt;现在切回正文，这篇文章本来是准备写下 Mysql 查询左匹配的问题，但是还没研究出来。那就先写下最近在鼓捣一个东西，使用 Redis 实现可重入分布锁。&lt;/p&gt;
&lt;p&gt;看到这里，有的朋友可能会提出来使用 &lt;strong&gt;redisson&lt;/strong&gt; 不香吗，为什么还要自己实现？&lt;/p&gt;
&lt;p&gt;哎，&lt;strong&gt;redisson&lt;/strong&gt; 真的很香，但是现有项目中没办法使用，只好自己手撸一个可重入的分布式锁了。&lt;/p&gt;
&lt;p&gt;虽然用不了 &lt;strong&gt;redisson&lt;/strong&gt;，但是我可以研究其源码，最后实现的可重入分布锁参考了 &lt;strong&gt;redisson&lt;/strong&gt; 实现方式。&lt;/p&gt;
&lt;h2 id=&quot;分布式锁&quot;&gt;分布式锁&lt;/h2&gt;
&lt;p&gt;分布式锁特性就要在于排他性，同一时间内多个调用方加锁竞争，只能有一个调用方加锁成功。&lt;/p&gt;
&lt;p&gt;Redis 由于内部单线程的执行，内部按照请求先后顺序执行，没有并发冲突，所以只会有一个调用方才会成功获取锁。&lt;/p&gt;
&lt;p&gt;而且 Redis 基于内存操作，加解锁速度性能高，另外我们还可以使用集群部署增强 Redis 可用性。&lt;/p&gt;
&lt;h3 id=&quot;加锁&quot;&gt;加锁&lt;/h3&gt;
&lt;p&gt;使用 Redis 实现一个简单的分布式锁，非常简单，可以直接使用 &lt;strong&gt;SETNX&lt;/strong&gt; 命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SETNX&lt;/strong&gt; 是『SET if Not eXists』，如果不存在，才会设置，使用方法如下：&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073935115-1948756209.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过直接使用 &lt;strong&gt;SETNX&lt;/strong&gt; 有一个缺陷，我们没办法对其设置过期时间，如果加锁客户端宕机了，这就导致这把锁获取不了了。&lt;/p&gt;
&lt;p&gt;有的同学可能会提出，执行 &lt;strong&gt;SETNX&lt;/strong&gt; 之后，再执行 &lt;strong&gt;EXPIRE&lt;/strong&gt; 命令，主动设置过期时间，伪码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;var result = setnx lock &quot;client&quot;
if(result==1){
    // 有效期 30 s
    expire lock 30
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过这样还是存在缺陷，加锁代码并不能原子执行，如果调用加锁语句，还没来得及设置过期时间，应用就宕机了，还是会存在锁过期不了的问题。&lt;/p&gt;
&lt;p&gt;不过这个问题在 Redis 2.6.12 版本 就可以被完美解决。这个版本增强了 SET 命令，可以通过带上 NX,EX 命令原子执行加锁操作，解决上述问题。参数含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EX second ：设置键的过期时间，单位为秒&lt;/li&gt;
&lt;li&gt;NX 当键不存在时，进行设置操作，等同与 SETNX 操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用 SET 命令实现分布式锁只需要一行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;SET lock_name anystring NX EX lock_time
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解锁&quot;&gt;解锁&lt;/h3&gt;
&lt;p&gt;解锁相比加锁过程，就显得非常简单，只要调用 &lt;code&gt;DEL&lt;/code&gt; 命令删除锁即可:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DEL lock_name
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过这种方式却存在一个缺陷，可能会发生错解锁问题。&lt;/p&gt;
&lt;p&gt;假设应用 1 加锁成功，锁超时时间为 30s。由于应用 1 业务逻辑执行时间过长，30 s 之后，锁过期自动释放。&lt;/p&gt;
&lt;p&gt;这时应用 2 接着加锁，加锁成功，执行业务逻辑。这个期间，应用 1 终于执行结束，使用 &lt;code&gt;DEL&lt;/code&gt; 成功释放锁。&lt;/p&gt;
&lt;p&gt;这样就导致了应用 1 错误释放应用 2 的锁，另外锁被释放之后，其他应用可能再次加锁成功，这就可能导致业务重复执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073935698-941204302.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了使锁不被错误释放，我们需要在加锁时设置随机字符串，比如 UUID。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;SET lock_name uuid NX EX lock_time
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;释放锁时，需要提前获取当前锁存储的值，然后与加锁时的 uuid 做比较，伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;var value= get lock_name
if value == uuid
        // 释放锁成功
else
        // 释放锁失败
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码我们不能通过 Java 代码运行,因为无法保证上述代码原子化执行。&lt;/p&gt;
&lt;p&gt;幸好 Redis 2.6.0 增加执行 Lua 脚本的功能，lua 代码可以运行在 Redis 服务器的上下文中，并且整个操作将会被当成一个整体执行，中间不会被其他命令插入。&lt;/p&gt;
&lt;p&gt;这就保证了脚本将会以原子性的方式执行，当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。在其他的别的客户端看来，执行脚本的效果，要么是不可见的，要么就是已完成的。&lt;/p&gt;
&lt;h2 id=&quot;eval-与-evalsha&quot;&gt;EVAL 与 EVALSHA&lt;/h2&gt;
&lt;h3 id=&quot;eval&quot;&gt;EVAL&lt;/h3&gt;
&lt;p&gt;Redis 可以使用 EVAL 执行 LUA 脚本，而我们可以在 LUA 脚本中执行判断求值逻辑。EVAL 执行方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;EVAL script numkeys key [key ...] arg [arg ...]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;numkeys&lt;/code&gt; 参数用于建明参数，即后面 key 数组的个数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;key [key ...]&lt;/code&gt; 代表需要在脚本中用到的所有 Redis key，在 Lua 脚本使用使用数组的方式访问 key，类似如下 &lt;code&gt;KEYS[1]&lt;/code&gt; ， &lt;code&gt;KEYS[2]&lt;/code&gt;。注意 Lua 数组起始位置与 Java 不同，Lua 数组是从 1 开始。&lt;/p&gt;
&lt;p&gt;命令最后，是一些附加参数，可以用来当做 Redis Key 值存储的 Value 值，使用方式如 &lt;code&gt;KEYS&lt;/code&gt; 变量一样，类似如下：&lt;code&gt;ARGV[1]&lt;/code&gt; 、 &lt;code&gt;ARGV[2]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;用一个简单例子运行一下 EVAL 命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;eval &quot;return {KEYS[1],KEYS[2],ARGV[1],ARGV[2],ARGV[3]}&quot; 2 key1 key2 first second third
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073936003-97799494.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到 &lt;code&gt;KEYS&lt;/code&gt; 与 &lt;code&gt;ARGVS&lt;/code&gt;内部数组可以不一致。&lt;/p&gt;
&lt;p&gt;在 Lua 脚本可以使用下面两个函数执行 Redis 命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;redis.call()&lt;/li&gt;
&lt;li&gt;redis.pcall()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两个函数作用法与作用完全一致，只不过对于错误的处理方式不一致，感兴趣的小伙伴可以具体点击以下链接，查看错误处理一章。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://doc.redisfans.com/script/eval.html&quot;&gt;http://doc.redisfans.com/script/eval.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我们统一在 Lua 脚本中使用 &lt;code&gt;redis.call()&lt;/code&gt;，执行以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;eval &quot;return redis.call('set',KEYS[1],ARGV[1])&quot; 1 foo 楼下小黑哥
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073936258-891721940.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;evalsha&quot;&gt;EVALSHA&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;EVAL&lt;/code&gt; 命令每次执行时都需要发送 Lua 脚本，但是 Redis 并不会每次都会重新编译脚本。&lt;/p&gt;
&lt;p&gt;当 Redis 第一次收到 Lua 脚本时，首先将会对 Lua 脚本进行 &lt;strong&gt;sha1&lt;/strong&gt; 获取签名值，然后内部将会对其缓存起来。后续执行时，直接通过 &lt;strong&gt;sha1&lt;/strong&gt; 计算过后签名值查找已经编译过的脚本，加快执行速度。&lt;/p&gt;
&lt;p&gt;虽然 Redis 内部已经优化执行的速度，但是每次都需要发送脚本，还是有网络传输的成本，如果脚本很大，这其中花在网络传输的时间就会相应的增加。&lt;/p&gt;
&lt;p&gt;所以 Redis 又实现了 &lt;code&gt;EVALSHA&lt;/code&gt; 命令，原理与 &lt;code&gt;EVAL&lt;/code&gt; 一致。只不过 &lt;code&gt;EVALSHA&lt;/code&gt; 只需要传入脚本经过 &lt;strong&gt;sha1&lt;/strong&gt;计算过后的签名值即可，这样大大的减少了传输的字节大小，减少了网络耗时。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EVALSHA&lt;/code&gt;命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;evalsha c686f316aaf1eb01d5a4de1b0b63cd233010e63d 1 foo 楼下小黑哥
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073936676-406674675.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;SCRIPT FLUSH&lt;/code&gt; 命令用来清除所有 Lua 脚本缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到，如果之前未执行过 &lt;code&gt;EVAL&lt;/code&gt;命令，直接执行 &lt;code&gt;EVALSHA&lt;/code&gt; 将会报错。&lt;/p&gt;
&lt;h3 id=&quot;优化执行-eval&quot;&gt;优化执行 EVAL&lt;/h3&gt;
&lt;p&gt;我们可以结合使用 &lt;code&gt;EVAL&lt;/code&gt; 与 &lt;code&gt;EVALSHA&lt;/code&gt;，优化程序。下面就不写伪码了，以 Jedis 为例，优化代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//连接本地的 Redis 服务
Jedis jedis = new Jedis(&quot;localhost&quot;, 6379);
jedis.auth(&quot;1234qwer&quot;);

System.out.println(&quot;服务正在运行: &quot; + jedis.ping());

String lua_script = &quot;return redis.call('set',KEYS[1],ARGV[1])&quot;;
String lua_sha1 = DigestUtils.sha1DigestAsHex(lua_script);

try {
    Object evalsha = jedis.evalsha(lua_sha1, Lists.newArrayList(&quot;foo&quot;), Lists.newArrayList(&quot;楼下小黑哥&quot;));
} catch (Exception e) {
    Throwable current = e;
    while (current != null) {
        String exMessage = current.getMessage();
        // 包含 NOSCRIPT，代表该 lua 脚本从未被执行，需要先执行 eval 命令
        if (exMessage != null &amp;amp;&amp;amp; exMessage.contains(&quot;NOSCRIPT&quot;)) {
            Object eval = jedis.eval(lua_script, Lists.newArrayList(&quot;foo&quot;), Lists.newArrayList(&quot;楼下小黑哥&quot;));
            break;
        }

    }
}
String foo = jedis.get(&quot;foo&quot;);
System.out.println(foo);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码看起来还是很复杂吧，不过这是使用原生 jedis 的情况下。如果我们使用 Spring Boot 的话，那就没这么麻烦了。Spring 组件执行的 &lt;code&gt;Eval&lt;/code&gt; 方法内部就包含上述代码的逻辑。&lt;/p&gt;
&lt;p&gt;不过需要注意的是，如果 Spring-Boot 使用 Jedis 作为连接客户端,并且使用Redis Cluster 集群模式，需要使用 &lt;strong&gt;2.1.9&lt;/strong&gt; 以上版本的&lt;strong&gt;spring-boot-starter-data-redis&lt;/strong&gt;,不然执行过程中将会抛出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;org.springframework.dao.InvalidDataAccessApiUsageException: EvalSha is not supported in cluster environment.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详细情况可以参考这个修复的 &lt;strong&gt;Issue&lt;/strong&gt;&lt;a href=&quot;https://jira.spring.io/browse/DATAREDIS-1005&quot;&gt;Add support for scripting commands with Jedis Cluster&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;优化分布式锁&quot;&gt;优化分布式锁&lt;/h2&gt;
&lt;p&gt;讲完 Redis 执行 LUA 脚本的相关命令，我们来看下如何优化上面的分布式锁，使其无法释放其他应用加的锁。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以下代码基于 spring-boot 2.2.7.RELEASE 版本，Redis 底层连接使用 Jedis。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;加锁的 Redis 命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;SET lock_name uuid NX EX lock_time
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加锁代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 非阻塞式加锁，若锁存在，直接返回
 *
 * @param lockName  锁名称
 * @param request   唯一标识，防止其他应用/线程解锁，可以使用 UUID 生成
 * @param leaseTime 超时时间
 * @param unit      时间单位
 * @return
 */
public Boolean tryLock(String lockName, String request, long leaseTime, TimeUnit unit) {
    // 注意该方法是在 spring-boot-starter-data-redis 2.1 版本新增加的，若是之前版本 可以执行下面的方法
    return stringRedisTemplate.opsForValue().setIfAbsent(lockName, request, leaseTime, unit);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于&lt;code&gt;setIfAbsent&lt;/code&gt;方法是在 spring-boot-starter-data-redis 2.1 版本新增加，之前版本无法设置超时时间。如果使用之前的版本的，需要如下方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 适用于 spring-boot-starter-data-redis 2.1 之前的版本
 *
 * @param lockName
 * @param request
 * @param leaseTime
 * @param unit
 * @return
 */
public Boolean doOldTryLock(String lockName, String request, long leaseTime, TimeUnit unit) {
    Boolean result = stringRedisTemplate.execute((RedisCallback&amp;lt;Boolean&amp;gt;) connection -&amp;gt; {
        RedisSerializer valueSerializer = stringRedisTemplate.getValueSerializer();
        RedisSerializer keySerializer = stringRedisTemplate.getKeySerializer();

        Boolean innerResult = connection.set(keySerializer.serialize(lockName),
                valueSerializer.serialize(request),
                Expiration.from(leaseTime, unit),
                RedisStringCommands.SetOption.SET_IF_ABSENT
        );
        return innerResult;
    });
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解锁需要使用 Lua 脚本:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;-- 解锁代码
-- 首先判断传入的唯一标识是否与现有标识一致
-- 如果一致，释放这个锁，否则直接返回
if redis.call('get', KEYS[1]) == ARGV[1] then
   return redis.call('del', KEYS[1])
else
   return 0
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段脚本将会判断传入的唯一标识是否与 Redis 存储的标示一致，如果一直，释放该锁，否则立刻返回。&lt;/p&gt;
&lt;p&gt;释放锁的方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 解锁
 * 如果传入应用标识与之前加锁一致，解锁成功
 * 否则直接返回
 * @param lockName 锁
 * @param request 唯一标识
 * @return
 */
public Boolean unlock(String lockName, String request) {
    DefaultRedisScript&amp;lt;Boolean&amp;gt; unlockScript = new DefaultRedisScript&amp;lt;&amp;gt;();
    unlockScript.setLocation(new ClassPathResource(&quot;simple_unlock.lua&quot;));
    unlockScript.setResultType(Boolean.class);
    return stringRedisTemplate.execute(unlockScript, Lists.newArrayList(lockName), request);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于公号外链无法直接跳转，关注『程序通事』，回复&lt;strong&gt;分布式锁&lt;/strong&gt;获取源代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;redis-分布式锁的缺陷&quot;&gt;Redis 分布式锁的缺陷&lt;/h2&gt;
&lt;h3 id=&quot;无法重入&quot;&gt;无法重入&lt;/h3&gt;
&lt;p&gt;由于上述加锁命令使用了 &lt;code&gt;SETNX&lt;/code&gt; ，一旦键存在就无法再设置成功，这就导致后续同一线程内继续加锁，将会加锁失败。&lt;/p&gt;
&lt;p&gt;如果想将 Redis 分布式锁改造成可重入的分布式锁，有两种方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地应用使用 ThreadLocal 进行重入次数计数，加锁时加 1，解锁时减 1，当计数变为 0 释放锁&lt;/li&gt;
&lt;li&gt;第二种，使用 Redis Hash 表存储可重入次数，使用 Lua 脚本加锁/解锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一种方案可以参考这篇文章&lt;a href=&quot;https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/&quot;&gt;分布式锁的实现之 redis 篇&lt;/a&gt;。第二个解决方案，下一篇文章就会具体来聊聊，敬请期待。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073936936-2074260268.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;锁超时释放&quot;&gt;锁超时释放&lt;/h3&gt;
&lt;p&gt;假设线程 A 加锁成功，锁超时时间为 30s。由于线程 A 内部业务逻辑执行时间过长，30s 之后锁过期自动释放。&lt;/p&gt;
&lt;p&gt;此时线程 B 成功获取到锁，进入执行内部业务逻辑。此时线程 A 还在执行执行业务，而线程 B 又进入执行这段业务逻辑，这就导致业务逻辑重复被执行。&lt;/p&gt;
&lt;p&gt;这个问题我觉得，一般由于锁的超时时间设置不当引起，可以评估下业务逻辑执行时间，在这基础上再延长一下超时时间。&lt;/p&gt;
&lt;p&gt;如果超时时间设置合理，但是业务逻辑还有偶发的超时，个人觉得需要排查下业务执行过长的问题。&lt;/p&gt;
&lt;p&gt;如果说一定要做到业务执行期间，锁只能被一个线程占有的，那就需要增加一个守护线程，定时为即将的过期的但未释放的锁增加有效时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073937138-1582903812.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加锁成功后，同时创建一个守护线程。守护线程将会定时查看锁是否即将到期，如果锁即将过期，那就执行 &lt;strong&gt;EXPIRE&lt;/strong&gt; 等命令重新设置过期时间。&lt;/p&gt;
&lt;p&gt;说实话，如果要这么做，真的挺复杂的，感兴趣的话可以参考下 &lt;strong&gt;redisson watchdog&lt;/strong&gt; 实现方式。&lt;/p&gt;
&lt;h3 id=&quot;redis-分布式锁集群问题&quot;&gt;Redis 分布式锁集群问题&lt;/h3&gt;
&lt;p&gt;为了保证生产高可用，一般我们会采用主从部署方式。采用这种方式，我们可以将读写分离，主节点提供写服务，从节点提供读服务。&lt;/p&gt;
&lt;p&gt;Redis 主从之间数据同步采用异步复制方式，主节点写入成功后，立刻返回给客户端，然后异步复制给从节点。&lt;/p&gt;
&lt;p&gt;如果数据写入主节点成功，但是还未复制给从节点。此时主节点挂了，从节点立刻被提升为主节点。&lt;/p&gt;
&lt;p&gt;这种情况下，还未同步的数据就丢失了，其他线程又可以被加锁了。&lt;/p&gt;
&lt;p&gt;针对这种情况， Redis 官方提出一种 &lt;strong&gt;RedLock&lt;/strong&gt; 的算法，需要有 N 个Redis 主从节点，解决该问题，详情参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://redis.io/topics/distlock%E3%80%82&quot;&gt;https://redis.io/topics/distlock。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个算法自己实现还是很复杂的，幸好 &lt;strong&gt;redisson&lt;/strong&gt; 已经实现的 &lt;strong&gt;RedLock&lt;/strong&gt;，详情参考：&lt;a href=&quot;https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8#84-%E7%BA%A2%E9%94%81redlock&quot;&gt;redisson redlock&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本来这篇文章是想写 Redis 可重入分布式锁的，可是没想到写分布式锁的实现方案就已经写了这么多，再写下去，文章可能就很长，所以拆分成两篇来写。&lt;/p&gt;
&lt;p&gt;嘿嘿，这不下星期不用想些什么了，真是个小机灵鬼~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200608073937365-1826120615.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，帮大家再次总结一下本文内容。&lt;/p&gt;
&lt;p&gt;简单的 Redis 分布式锁的实现方式还是很简单的，我们可以直接用 SETNX/DEL 命令实现加解锁。&lt;/p&gt;
&lt;p&gt;不过这种实现方式不够健壮，可能存在应用宕机，锁就无法被释放的问题。&lt;/p&gt;
&lt;p&gt;所以我们接着引入以下命令以及 Lua 脚本增强 Redis 分布式锁。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;SET lock_name anystring NX EX lock_time
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后 Redis 分布锁还是存在一些缺陷，在这里提出一些解决方案，感兴趣同学可以自己实现一下。&lt;/p&gt;
&lt;p&gt;下篇文章再来将将 Redis 可重入分布式锁~&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/&quot;&gt;分布式锁的实现之 redis 篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crossoverjie.top/2018/03/29/distributed-lock/distributed-lock-redis/&quot;&gt;基于 Redis 的分布式锁&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 07 Jun 2020 23:40:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>分布式锁实现姿势~</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13063532.html</dc:identifier>
</item>
<item>
<title>搭上末班车去了京东，终于可以做东哥兄弟... - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/13063530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/13063530.html</guid>
<description>&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;介绍下自己&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开篇先简单介绍一下自己，双非本科，大三在读，通信学院物联网工程专业。这个专业的发展方向大致分为软、硬件两种，大二的时候感觉自己更喜欢软件方面，也就开始学习比较常用的 Java。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到了今年三月，开始投简历，投的都是 Java 开发工程师岗，参与春招实习生招聘，想体验一下笔试、面试的过程，最好能拿到实习offer。&lt;/p&gt;
&lt;img src=&quot;https://img01.sogoucdn.com/app/a/100520093/e18d20c94006dfe0-7524faeb6c8ff751-58d4db3a2a4c52769b5bc5b9240348be.jpg&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;搭上了末班车&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;春招基本结束了，算是搭上了春招的末班车，被春招支配的恐惧也可以告一段落了，借此机会梳理一下我的春招历程。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;被恐惧支配&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始心态很差，每过一面就会感觉很放松，可能会开心一下，这种开心的时候可能就不是很用心的在学习。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而每挂一面就会非常沮丧，心情很低落，连续几天都会整理不好心情继续沉浸在学习中。还会怀疑自己是不是不行，是不是能力不够，是不是....&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;心情起起落落，甚至在每面完一场，都会隔几分钟就刷新官网，看下流程情况，看下自己是不是挂掉了。焦灼的心，颤抖的手，浮躁的状态。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gf2dc3b6nlg306u07ewev.gif&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完完全全被焦虑和恐惧给支配，没心思学习，感觉自己整个思路、情绪、状态都到了一个极点，而且是自己没办法突破的极点。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;被恐惧支配比恐惧本身恐惧多了，而且后劲十足&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我苦苦在寻找一个突破口，但一直没能找到如何突破。如果找不到这个突破口，接下来的春招之路感觉很难走下去。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;我遇到了龙叔&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一次偶然在朋友圈看到同学转发一篇文章，是说面试介绍的 &lt;a href=&quot;https://mp.weixin.qq.com/s/veEprCLH63gSQymEaSAdYQ&quot;&gt;当你面试“自我介绍”还在我是XXX时，看到这篇文章的同学们已经拿到了offer...&lt;/a&gt; ，看是关于面试的文章，就点进去看了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看这篇文章确实补充了我很多盲点，于是我就点进去看了下其他的文章，比如这篇 &lt;a href=&quot;https://mp.weixin.qq.com/s/KWHVgiUYjxtGnZbhrWWz0g&quot;&gt;学会龙叔这套面试秘诀，一套大招带走面试官&lt;/a&gt; ，发现里面可以&lt;strong&gt;加交流群&lt;/strong&gt; 和 加&lt;strong&gt;作者微信&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还看到龙叔给粉丝辅导简历，于是我就&lt;strong&gt;鼓起勇气&lt;/strong&gt;加了龙叔微信，把自己的情况描述了下。抱着试试的态度，没想到龙叔非常认真的回答了我，而且还在粉丝交流群里给大家说了。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gf2crj5nm6j30s42bc4qp.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常幸运的遇到了龙叔，他告诉我，&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;面试完就不要总是等待结果，面试就像期末考，考完我们都不会再去翻书了。面完了，结果就不在我们考虑范围之内了，要为下一场准备，也不能寄希望于一个公司，应该把心思放在复习和准备上。时刻保持自己的面试状态，充满斗志、不要灰心。因为 offer 是需要流程的，不是面完就发，多准备，多面，之后就是收割 offer 的事情。天天忧心忡忡的，实在无济于事，完全是浪费自己的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我听完犹如醍醐灌顶，受益匪浅，麻溜儿地写在便签纸上，贴在眼前，提醒自己。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人总有失意和遇到困难想不通的时候，而这时候能让我的思想从短路变为通路，非常感谢龙叔。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gf2dd8xxmdj307706za9z.jpg&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;成功的路总是不平坦的&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后四月份，身边同学陆陆续续有收到 offer 的，去牛客网每次刷新的时候，也都是喜提校招或者实习 offer的记录帖，羡慕、恰柠檬之余。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我为自己还没有理想的offer 感到发愁，又到了浮躁的一个新阶段。这个阶段虽说是浮躁，但是比起刚开始那一堵墙，已经好很多了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会和朋友相互鼓励，相互吐槽失败的面试，心情 down 的时候听听大张伟的《阳光彩虹小白马》 &quot;你就是最强哒最棒哒最亮哒最发光哒&quot;，努力让自己平和、快乐，强行相信自己。很快就能调整好自己的状态，继续投入到战斗中。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;心态太重要了，只有心态好了，复习才能更加有效率&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个月的面试中，让我自己印象深刻的是腾讯三面，可能是传说中的压力面之类的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时操作系统学的不好，说明了之后，面试官还是在操作系统这方面穷追不舍地发问，从一开始的语气温柔、带着笑意，到后来渐渐严肃、带着凶意，与此同时我也意识到这最后一轮技术面多半是凉透了，要和我 say byebye了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后面试官甚至问 你到底有没有学过操作系统？你是女生，为什么要学开发？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时的面试，我没控制住情绪，为自己的菜流下了委屈的泪水&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gf2fbzpegzj30730740sp.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实也没什么委屈的，毕竟菜是原罪，哈哈哈。可能因为人生第一回总监面，没见过这种大场面的原因吧，还是要见多识广啊。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事后反思，这样实在是不合适，这是顶不住压力的表现，面试官希望看到的，应该是沉着冷静的，&lt;strong&gt;尝试去解决问题的求职者&lt;/strong&gt;，而不是这样爱哭鼻子的。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;一些总结&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经历这近三个月的面试，从开始自我介绍都结巴，到现在可以心跳正常地和面试官&lt;strong&gt;交流&lt;/strong&gt;，收获还是蛮多的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我感到&lt;strong&gt;实力才是硬道理&lt;/strong&gt;，结果的决定权在公司手里，作为求职者，我们总是会被置于与其他同样水平的人作比较的地位，只能不断提高实力，才可能脱颖而出。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保持平和的心态会带来一些好的运气，还有就是坚持下去，最后一定会收获好结果的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从简历筛选、笔试、轮轮面试，一步一步过关，每次面试过程会录音，之后&lt;strong&gt;复盘&lt;/strong&gt;，通过复盘去看自己当时为什么没有回答上来，为什么没有收到面试官的青睐。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过复盘，把不会的问题都搞明白，把该加分没加上的，在后续的面试一定加上。面试完需要尽快查漏补缺，保持心态，坚持下去。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;春季实习招聘还是比较宽容的，大厂也没有因为我学历不出色而不给面试机会，而且很多家的面试体验还是很不错的，有的面试官会引导我、会纠正我的错误、给予建议。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使最后没有通过，也是学到了一些东西，面试本身就是一种学习。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;面试最好的状态是和面试官交流，而不是硬生的回答。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后希望秋招时，我可以拥有更平和的心态和更扎实的基础，收获自己心仪的offer~ ，也希望和我一起奋斗的你们都能找到满意的offer。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;高频考点&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里列出遇到的面试中高频的考点（被问到三次以上的那种~）：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Java 基础：HashMap源码、泛型、NIO&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;数据结构与算法：红黑树、堆、 海量数据中找top k 问题、 快速排序、堆排序&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;JVM ：垃圾回收机制、Full GC、类加载机制&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;数据库：事务、索引、锁、查询优化、排查慢查询&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Spring 框架：IOC、AOP、事务、SpringMVC、常见注解&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;操作系统：进程和线程、虚拟内存&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;网络：HTTPS、TCP三次握手四次挥手、HTTP状态码&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;手撕算法：基本都是剑指offer上面的原题，还有 生产者-消费者模型&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;再有，如果有读过并发包中的源码，或者对线程安全相关问题有自己的思考，也是很加分的。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些是非常高频的面试题，还有一些常规的，就不一一列举了。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gev7zm5qpnj30p00dw0tn.jpg&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Sun, 07 Jun 2020 23:35:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>皇天不负有心人，终于搭上末班车去了京东</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/13063530.html</dc:identifier>
</item>
<item>
<title>小师妹学JavaIO之:文件系统和WatchService - flydean</title>
<link>http://www.cnblogs.com/flydean/p/java-io-file-watchservice.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/java-io-file-watchservice.html</guid>
<description>&lt;p&gt;小师妹这次遇到了监控文件变化的问题，F师兄给小师妹介绍了JDK7 nio中引入的WatchService，没想到又顺道普及了一下文件系统的概念，万万没想到。&lt;/p&gt;

&lt;p&gt;小师妹：F师兄最近你有没有感觉到呼吸有点困难，后领有点凉飕飕的，说话有点不顺畅的那种？&lt;/p&gt;
&lt;p&gt;没有啊小师妹，你是不是秋衣穿反了？&lt;/p&gt;
&lt;p&gt;小师妹：不是的F师兄，我讲的是心里的感觉，那种莫须有的压力，还有一丝悸动缠绕在心。&lt;/p&gt;
&lt;p&gt;别绕弯子了小师妹，是不是又遇到问题了。&lt;/p&gt;
&lt;p&gt;更多精彩内容且看：&lt;/p&gt;
&lt;blockquote readability=&quot;2.9166666666667&quot;&gt;
&lt;p&gt;更多内容请访问&lt;a href=&quot;https://www.cnblogs.com/flydean/p/www.flydean.com&quot;&gt;www.flydean.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小师妹：还是F师兄懂我，这不上次的Properties文件用得非常上手，每次修改Properties文件都要重启java应用程序，真的是很痛苦。有没有什么其他的办法呢？&lt;/p&gt;
&lt;p&gt;办法当然有，最基础的办法就是开一个线程定时去监控属性文件的最后修改时间，如果修改了就重新加载，这样不就行了。&lt;/p&gt;
&lt;p&gt;小师妹：写线程啊，这么麻烦，有没有什么更简单的办法呢？&lt;/p&gt;
&lt;p&gt;就知道你要这样问，还好我准备的比较充分，今天给你介绍一个JDK7在nio中引入的类WatchService。&lt;/p&gt;

&lt;p&gt;WatchService是JDK7在nio中引入的接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200518144135360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;监控的服务叫做WatchService，被监控的对象叫做Watchable：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;WatchKey register(WatchService watcher,
                      WatchEvent.Kind&amp;lt;?&amp;gt;[] events,
                      WatchEvent.Modifier... modifiers)
        throws IOException;
WatchKey register(WatchService watcher, WatchEvent.Kind&amp;lt;?&amp;gt;... events)
        throws IOException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Watchable通过register将该对象的WatchEvent注册到WatchService上。从此只要有WatchEvent发生在Watchable对象上，就会通知WatchService。&lt;/p&gt;
&lt;p&gt;WatchEvent有四种类型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ENTRY_CREATE 目标被创建&lt;/li&gt;
&lt;li&gt;ENTRY_DELETE 目标被删除&lt;/li&gt;
&lt;li&gt;ENTRY_MODIFY 目标被修改&lt;/li&gt;
&lt;li&gt;OVERFLOW 一个特殊的Event，表示Event被放弃或者丢失&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;register返回的WatchKey就是监听到的WatchEvent的集合。&lt;/p&gt;
&lt;p&gt;现在来看WatchService的4个方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;close 关闭watchService&lt;/li&gt;
&lt;li&gt;poll 获取下一个watchKey，如果没有则返回null&lt;/li&gt;
&lt;li&gt;带时间参数的poll 在等待的一定时间内获取下一个watchKey&lt;/li&gt;
&lt;li&gt;take 获取下一个watchKey，如果没有则一直等待&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;小师妹：F师兄，那怎么才能构建一个WatchService呢？&lt;/p&gt;
&lt;p&gt;上次文章中说的文件系统，小师妹还记得吧，FileSystem中就有一个获取WatchService的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract WatchService newWatchService() throws IOException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看下FileSystem的结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200518143230776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在我的mac系统上，FileSystem可以分为三大类，UnixFileSystem，JrtFileSystem和ZipFileSystem。我猜在windows上面应该还有对应的windows相关的文件系统。小师妹你要是有兴趣可以去看一下。&lt;/p&gt;
&lt;p&gt;小师妹：UnixFileSystem用来处理Unix下面的文件，ZipFileSystem用来处理zip文件。那JrtFileSystem是用来做什么的？&lt;/p&gt;
&lt;p&gt;哎呀，这就又要扯远了，为什么每次问问题都要扯到天边....&lt;/p&gt;
&lt;p&gt;从前当JDK还是9的时候，做了一个非常大的改动叫做模块化JPMS（Java Platform Module System），这个Jrt就是为了给模块化系统用的，我们来举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void useJRTFileSystem(){
        String resource = &quot;java/lang/Object.class&quot;;
        URL url = ClassLoader.getSystemResource(resource);
        log.info(&quot;{}&quot;,url);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面一段代码我们获取到了Object这个class的url，我们看下如果是在JDK8中，输出是什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;jar:file:/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home/jre/lib/rt.jar!/java/lang/Object.class
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果是jar:file表示这个Object class是放在jar文件中的，后面是jar文件的路径。&lt;/p&gt;
&lt;p&gt;如果是在JDK9之后：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;jrt:/java.base/java/lang/Object.class
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果是jrt开头的，java.base是模块的名字，后面是Object的路径。看起来是不是比传统的jar路径更加简洁明了。&lt;/p&gt;
&lt;p&gt;有了文件系统，我们就可以在获取系统默认的文件系统的同时，获取到相应的WatchService：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;WatchService watchService = FileSystems.getDefault().newWatchService();
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;小师妹：F师兄，WatchSerice是咋实现的呀？这么神奇，为我们省了这么多工作。&lt;/p&gt;
&lt;p&gt;其实JDK提供了这么多类的目的就是为了不让我们重复造轮子，之前跟你讲监控文件的最简单办法就是开一个独立的线程来监控文件变化吗？其实.....WatchService就是这样做的！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PollingWatchService() {
        // TBD: Make the number of threads configurable
        scheduledExecutor = Executors
            .newSingleThreadScheduledExecutor(new ThreadFactory() {
                 @Override
                 public Thread newThread(Runnable r) {
                     Thread t = new Thread(null, r, &quot;FileSystemWatcher&quot;, 0, false);
                     t.setDaemon(true);
                     return t;
                 }});
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的方法就是生成WatchService的方法，小师妹看到没有，它的本质就是开启了一个daemon的线程，用来接收监控任务。&lt;/p&gt;
&lt;p&gt;下面看下怎么把一个文件注册到WatchService上面：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void startWatcher(String dirPath, String file) throws IOException {
        WatchService watchService = FileSystems.getDefault().newWatchService();
        Path path = Paths.get(dirPath);
        path.register(watchService, ENTRY_MODIFY);

        Runtime.getRuntime().addShutdownHook(new Thread(() -&amp;gt; {
            try {
                watchService.close();
            } catch (IOException e) {
                log.error(e.getMessage());
            }
        }));

        WatchKey key = null;
        while (true) {
            try {
                key = watchService.take();
                for (WatchEvent&amp;lt;?&amp;gt; event : key.pollEvents()) {
                    if (event.context().toString().equals(fileName)) {
                        loadConfig(dirPath + file);
                    }
                }
                boolean reset = key.reset();
                if (!reset) {
                    log.info(&quot;该文件无法重置&quot;);
                    break;
                }
            } catch (Exception e) {
                log.error(e.getMessage());
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的关键方法就是path.register，其中Path是一个Watchable对象。&lt;/p&gt;
&lt;p&gt;然后使用watchService.take来获取生成的WatchEvent，最后根据WatchEvent来处理文件。&lt;/p&gt;

&lt;p&gt;道生一，一生二，二生三，三生万物。一个简简单单的功能其实背后隐藏着...道德经，哦，不对，背后隐藏着道的哲学。&lt;/p&gt;
&lt;p&gt;本文的例子&lt;a href=&quot;https://github.com/ddean2009/learn-java-io-nio&quot;&gt;https://github.com/ddean2009/learn-java-io-nio&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8.3707317073171&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/java-io-file-watchservice/&quot;&gt;http://www.flydean.com/java-io-file-watchservice/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:程序那些事，更多精彩等着您！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 07 Jun 2020 23:14:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 小师妹这次遇到了监控文件变化的问题，F师兄给小师妹介绍了JDK7 nio中引入的WatchService，没想到又顺道普及了一下文件系统的概念，万万没想到。 监控的痛点 小师妹：F师兄最近你有没</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/java-io-file-watchservice.html</dc:identifier>
</item>
<item>
<title>详解SpringBoot(2.3)应用制作Docker镜像(官方方案) - zq2599</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13063508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13063508.html</guid>
<description>&lt;h3 id=&quot;关于《springboot-23容器化技术》系列&quot;&gt;关于《SpringBoot-2.3容器化技术》系列&lt;/h3&gt;
&lt;p&gt;《SpringBoot-2.3容器化技术》系列，旨在和大家一起学习实践2.3版本带来的最新容器化技术，让咱们的Java应用更加适应容器化环境，在云计算时代依旧紧跟主流，保持竞争力；&lt;/p&gt;
&lt;p&gt;全系列文章分为主题和辅助两部分，主题部分如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106597358&quot;&gt;《体验SpringBoot(2.3)应用制作Docker镜像(官方方案)》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106598189&quot;&gt;《详解SpringBoot(2.3)应用制作Docker镜像(官方方案)》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106605264&quot;&gt;《掌握SpringBoot-2.3的容器探针：基础篇》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106606442&quot;&gt;《掌握SpringBoot-2.3的容器探针：深入篇》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106607225&quot;&gt;《掌握SpringBoot-2.3的容器探针：实战篇》&lt;/a&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;辅助部分是一些参考资料和备忘总结，如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106600620&quot;&gt;《SpringBoot-2.3镜像方案为什么要做多个layer》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106590784&quot;&gt;《设置非root账号不用sudo直接执行docker命令》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106594392&quot;&gt;《开发阶段，将SpringBoot应用快速部署到K8S》&lt;/a&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;本篇简介&quot;&gt;本篇简介&lt;/h3&gt;
&lt;p&gt;在&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106597358&quot;&gt;前文&lt;/a&gt;，咱们快速体验了官方推荐的docker镜像制作方案，但也产生了几个疑问：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;SpringBoot-2.3版本推荐的镜像构建方案和旧版本比有什么不同？&lt;/li&gt;
&lt;li&gt;pom.xml中&lt;span&gt;spring-boot-maven-plugin&lt;/span&gt;插件新增的参数，到底做了什么？&lt;/li&gt;
&lt;li&gt;Dockerfile中，&lt;span&gt;java -Djarmode=layertools -jar application.jar extract&lt;/span&gt;这个操作啥意思?&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本篇的目标就是解答上述问题，在寻找答案的过程中不断补全知识点，提升自己；&lt;/p&gt;
&lt;h3 id=&quot;关键知识点：镜像layer&quot;&gt;关键知识点：镜像layer&lt;/h3&gt;
&lt;p&gt;前文多次提到的镜像layer到底是什么，为什么会有多层layer？有必要先把这个知识点夯实了，请参考文章&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106600620&quot;&gt;《SpringBoot-2.3镜像方案为什么要做多个layer》&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;老版本springboot的官方方案&quot;&gt;老版本SpringBoot的官方方案&lt;/h3&gt;
&lt;p&gt;以&lt;span&gt;SpringBoot-2.2.0.RELEASE&lt;/span&gt;版本为例，官方文档(&lt;br/&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.2.0.RELEASE/reference/pdf/spring-boot-reference.pdf&quot;&gt;https://docs.spring.io/spring-boot/docs/2.2.0.RELEASE/reference/pdf/spring-boot-reference.pdf&lt;/a&gt;)给出的做法如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将SpringBoot工程编译构建，在target目录得到jar；&lt;/li&gt;
&lt;li&gt;在target目录新建dependency文件夹；&lt;/li&gt;
&lt;li&gt;将jar解压到dependency文件夹；&lt;/li&gt;
&lt;li&gt;编写Dockerfile文件，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG DEPENDENCY=target/dependency
COPY ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY ${DEPENDENCY}/META-INF /app/META-INF
COPY ${DEPENDENCY}/BOOT-INF/classes /app
ENTRYPOINT [&quot;java&quot;,&quot;-cp&quot;,&quot;app:app/lib/*&quot;,&quot;com.example.MyApplication&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;可见，官方推荐的做法是将整个jar文件解压，在Dockerfile中多次用COPY命令分别复制，这样做的好处显而易见：多个layer，如果镜像的新版本中只修改了应用代码，那么下载镜像时只会下载/app这个layer，其他部分直接使用本地缓存，这是docker镜像的常规优化手段；&lt;/li&gt;
&lt;li&gt;上述方案有个小问题：&lt;span&gt;麻烦！！！&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;于是2.3.0.RELEASE版本做了些优化，让事情变得简单些；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;230release版本方案和旧版的区别&quot;&gt;2.3.0.RELEASE版本方案和旧版的区别&lt;/h3&gt;
&lt;p&gt;2.3.0.RELEASE版本构建Docker的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;pom.xml中的spring-boot-maven-plugin插件增加一个配置项；&lt;br/&gt;2.编译构建生成jar；&lt;/li&gt;
&lt;li&gt;编写Dockerfile，里面用到了多阶段构建(multi-stage builds)，用工具从jar中提取拆分后，再多次执行COPY命令将拆分后的内容放入镜像，达到多个layer的目的；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此，2.3.0.RELEASE版本和旧版本相比有如下变化：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;pom.xml&lt;/span&gt;中多了个参数；&lt;/li&gt;
&lt;li&gt;构建好jar后，无需自己解压jar；&lt;/li&gt;
&lt;li&gt;Dockefile内容不一样，旧版是手动解压jar，再在Dockerfile分别复制，2.3.0.RELEASE是通过&lt;span&gt;java命令从jar中提取出各部分内容&lt;/span&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;搞清楚了新旧版本的区别，咱们继续研究下一个问题吧；&lt;/p&gt;
&lt;h3 id=&quot;pomxml中spring-boot-maven-plugin插件新增的参数&quot;&gt;pom.xml中spring-boot-maven-plugin插件新增的参数&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;pring-boot-maven-plugin插件新增参数如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200608065810201-882469618.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;2. 上述参数有啥用？我这边编译构建了两次jar，第一次有上述参数，第二次没有，将两次生成的jar解压后对比，发现用了上述参数后，生成的jar会多出下图红框中的两个文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200608065810873-464429530.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;看看&lt;span&gt;layers.idx&lt;/span&gt;文件的内容，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200608065811331-713050625.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;上图中的内容分别是什么意思呢？官方已给出了详细解释，如下图红框：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200608065811655-1255080138.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;综上所述，layers.idx文件是个清单，里面记录了所有要被复制到镜像中的信息，接下来看看如何使用layers.idx文件，这就涉及到jar包中新增的另一个文件：&lt;span&gt;spring-boot-jarmode-layertools-2.3.0.RELEASE.jar&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;spring-boot-jarmode-layertools工具&quot;&gt;spring-boot-jarmode-layertools工具&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;前面已经介绍过jar中除了layers.idx，还多了个文件：&lt;span&gt;spring-boot-jarmode-layertools-2.3.0.RELEASE.jar&lt;/span&gt; ，来看看这个文件的用处；&lt;/li&gt;
&lt;li&gt;进入工程的&lt;span&gt;target&lt;/span&gt;目录，这里面是编译后的jar文件(我这里文件名为dockerlayerdemo-0.0.1-SNAPSHOT.jar)，注意此时的&lt;span&gt;spring-boot-maven-plugin&lt;/span&gt;插件是带上了下图红框中的参数的：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200608065811925-1444605359.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;执行以下命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;java -Djarmode=layertools -jar dockerlayerdemo-0.0.1-SNAPSHOT.jar list
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;得到结果如下图所示，是layers.idx文件的内容：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200608065812111-1993489950.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;来看看官方对这个&lt;span&gt;layertools&lt;/span&gt;的解释，list参数的作用上面我们已经体验过了，重点是红框中的&lt;span&gt;extract&lt;/span&gt;参数，它的作用是从jar中提取构建镜像所需的内容：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200608065812405-155982792.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;看到这里，您是否想到了&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106597358&quot;&gt;《体验SpringBoot(2.3)应用制作Docker镜像(官方方案)》&lt;/a&gt;中Dockerfile的内容，请看下图的红框和红字，是否有种恍然大悟的感觉：jar构建生成清单layers.idx，Dockerfile中根据清单从jar提取文件放入镜像：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200608065812728-352415533.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，三个问题都已经找到了答案，小结一下：&lt;/p&gt;
&lt;h3 id=&quot;springboot-230release推荐的镜像构建方案和旧版本相比有什么不同&quot;&gt;SpringBoot-2.3.0.RELEASE推荐的镜像构建方案和旧版本相比有什么不同&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;pom.xml中的spring-boot-maven-plugin插件增加一个配置项；&lt;/li&gt;
&lt;li&gt;构建好jar后，旧版本要自己解压jar，新版不需要；&lt;/li&gt;
&lt;li&gt;新版本的jar中，多了个文件清单&lt;span&gt;layers.idx&lt;/span&gt;和镜像文件处理工具&lt;span&gt;spring-boot-jarmode-layertools-2.3.0.RELEASE.jar&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;旧版的Dockefile内容：因为前面解压好了，所有在Dockerfile里直接复制前面解压的内容，这里就有个风险：前一步解压和当前复制的文件位置要保证一致；&lt;/li&gt;
&lt;li&gt;新版的Dockerfile内容：使用工具spring-boot-jarmode-layertools-2.3.0.RELEASE.jar，根据的layers.idx内容从jar中提取文件，复制到镜像中；&lt;/li&gt;
&lt;li&gt;新版的Dockerfile中，由于使用了分阶段构建，因此从jar提取文件的操作不会保存到镜像的layer中；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;pomxml中spring-boot-maven-plugin插件新增的参数，到底做了什么&quot;&gt;pom.xml中spring-boot-maven-plugin插件新增的参数，到底做了什么&lt;/h3&gt;
&lt;p&gt;spring-boot-maven-plugin插件新增的参数，使得编译构建得到jar中多了两个文件，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200608065813440-487814552.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;java -Djarmode=layertools -jar application.jar extract&lt;/span&gt;的作用是从jar中提取文件，这些文件是docker镜像的一部分；&lt;/li&gt;
&lt;li&gt;上述操作的参数是&lt;span&gt;extract&lt;/span&gt;，另外还有两个参数，官方解释它们的作用如下：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200608065813803-1300900921.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，问题已全部澄清，相信您对SpringBoot-2.3.0.RELEASE官方的镜像构建方案也足够了解了，最后是我根据自己的认识画的流程图，帮助您快速理解整个构建流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200608065814133-250029337.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;h3 id=&quot;欢迎关注我的公众号：程序员欣宸&quot;&gt;欢迎关注我的公众号：程序员欣宸&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202006/485422-20200608065814435-595192523.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Jun 2020 22:58:00 +0000</pubDate>
<dc:creator>zq2599</dc:creator>
<og:description>关于《SpringBoot-2.3容器化技术》系列 《SpringBoot-2.3容器化技术》系列，旨在和大家一起学习实践2.3版本带来的最新容器化技术，让咱们的Java应用更加适应容器化环境，在云计</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13063508.html</dc:identifier>
</item>
<item>
<title>jvm知识点总结 - pavi</title>
<link>http://www.cnblogs.com/pavi/p/13063301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pavi/p/13063301.html</guid>
<description>&lt;h3 id=&quot;1-jvm结构图&quot;&gt;1 jvm结构图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200608010401560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhdmljbg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-类的装载器&quot;&gt;2 类的装载器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200608010832685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhdmljbg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;​  将类的字节码文件加载到jvm中，会把这些内容转化为方法区运行的数据结构。jvm会创建对应的Class对象，保存到堆中。&lt;/p&gt;
&lt;p&gt;装载器有如下几种：虚拟机自带装载器：启动类加载器（BootStrap）C++、扩展类加载器（Extension）Java、应用程序类加载器（AppClassLoader）Java,也叫系统类加载器，加载当前应用的classpath的所有类&lt;br/&gt;用户自定义加载器：Java.lang.ClassLoader的子类&lt;/p&gt;
&lt;p&gt;双亲委派机制：如果一个类收到加载的请求，他首先会让它的父类尝试去完成，当他的父类无法完成时，它才会尝试加载这个类。&lt;/p&gt;
&lt;p&gt;沙箱：比如启动类加载器它加载了java.lang.String,如果本地也是创建相同的包且有String类，它会以启动的时候首先加载的那个类为准。&lt;/p&gt;
&lt;h3 id=&quot;3-执行引擎&quot;&gt;3 执行引擎&lt;/h3&gt;
&lt;p&gt;​ 功能：解释命令，提交给操作系统执行。&lt;/p&gt;
&lt;h3 id=&quot;4--本地方法栈、本地方法接口、本地方法库&quot;&gt;4 本地方法栈、本地方法接口、本地方法库&lt;/h3&gt;
&lt;p&gt;​  native修饰的方法是本地方法，由于java代码无能为力，可能需要调用操作系统或C++等代码。这些方法会注册到本地方法栈，这些本地方法通过调用本地方法接口调用非java代码，执行引擎会加载本地方法库。&lt;/p&gt;
&lt;h3 id=&quot;5-pc寄存器&quot;&gt;5 PC寄存器&lt;/h3&gt;
&lt;p&gt;​  用于指向当前线程所执行的字节码的行号显示器&lt;/p&gt;
&lt;h3 id=&quot;6-方法区&quot;&gt;6 方法区&lt;/h3&gt;
&lt;p&gt;​  存储类的结构信息，有静态变量（静态域），运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容。在jdk7中这里是永久代，jdk8采用的是元空间实现。&lt;/p&gt;
&lt;h3 id=&quot;7--栈&quot;&gt;7 栈&lt;/h3&gt;
&lt;p&gt;​  在线程创建时创建，线程结束栈内存也结束，所有不存在垃圾回收。栈中存储8种基本数据变量、对象的引用变量、实例方法。栈中存储的方法就是栈帧，存储三种数据，本地变量：输入输出参数以及方法内的变量，栈的操作：记录入栈和出栈、栈帧数据：方法。&lt;br/&gt;​  栈中存储直接对象的地址，堆中存储对象以及类元数据的地址即Class的地址，方法区存储类元数据。&lt;/p&gt;
&lt;h3 id=&quot;8--堆&quot;&gt;8 堆&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200608010819700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhdmljbg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;​  在jdk7中堆在逻辑上分为新生区，养老区，永久存储区，而在物理上堆只有新生区和养老区，永久存储区为方法区，在jdk8中永久区被原空间取代，二者区别时永久存储区使用堆内存，而元空间的大小和物理内存有关。&lt;br/&gt;​  在伊甸区如果对象满了，会触发 Minor GC ，会把存活的对象移动到幸存0区（from），对象的年龄加一。第二次伊甸区对象满了，会把幸存0区和伊甸区存活的对象复制到幸存1区并且年龄加一，幸存0区有from区变为to区，幸存1区由to变为from区,清理伊甸区和to区,这样一直进行下去，如果哪些对象年龄达到15，就会进入养老区，这个值也可以自己设置，在jdk8种在0-15之间。如果养老区满了，会触发full gc。&lt;/p&gt;
&lt;h3 id=&quot;9-gc算法&quot;&gt;9 GC算法&lt;/h3&gt;
&lt;p&gt;​  分代收集算法，新生区和养老区采用的算法是不一样的，由于新生区发生gc比较频繁，而养老区次数比较少，在jdk7中永久存储区基本不清理，在jdk8中元空间不使用堆内存故不需要清理。&lt;/p&gt;
&lt;h4 id=&quot;91-引用计数法&quot;&gt;9.1 引用计数法&lt;/h4&gt;
&lt;p&gt;​ 在每次引用时，会加一，置为null会减一，但是这个算法有如下缺点，要使用计数器，会有内存消耗，无法处理循环引用。&lt;/p&gt;
&lt;h4 id=&quot;92-复制算法&quot;&gt;9.2 复制算法&lt;/h4&gt;
&lt;p&gt;​ 触发 Minor GC ，会把存活的对象移动到幸存0区（from），对象的年龄加一。第二次伊甸区对象满了，会把幸存0区和伊甸区存活的对象复制到幸存1区并且年龄加一，幸存0区有from区变为to区，幸存1区由to变为from区,清理伊甸区和to区,这样一直进行下去，如果哪些对象年龄达到15，就会进入养老区。&lt;/p&gt;
&lt;p&gt;缺点：①：消耗内存&lt;br/&gt;②：如果生存率高的化，也是比较浪费的。&lt;br/&gt;这个算法在新生区使用，因为新生区存活率低。&lt;/p&gt;
&lt;h4 id=&quot;93-标记清除&quot;&gt;9.3 标记清除&lt;/h4&gt;
&lt;p&gt;​ ①：从根集合开始扫描，对存活的对象进行标记&lt;br/&gt;​ ②：扫描整个内存空间，清理未被标记的对象。&lt;/p&gt;
&lt;p&gt;缺点：需要暂停整个应用，会产生内存碎片&lt;br/&gt;老年代一般是由标记清除或者是标记清除与标记整理的混合实现&lt;/p&gt;
&lt;h4 id=&quot;94-标记压缩&quot;&gt;9.4 标记压缩&lt;/h4&gt;
&lt;p&gt;​ ①：从根集合开始扫描，对存活的对象进行标记&lt;br/&gt;​ ②：将标记的对象移动到一边，不需要清理&lt;/p&gt;
&lt;p&gt;缺点：虽然不需要回收对象，但是不仅要标记所有存活对象，还要整理所有存活对象的引用地址。&lt;/p&gt;
&lt;p&gt;还有一个算法是标记清除压缩算法，这个算法结合3，4,和标记清除是类似的，只不过多次gc后才进行压缩。&lt;br/&gt;老年代一般是由标记清除或者是标记清除与标记整理的混合实现&lt;br/&gt;​&lt;/p&gt;
</description>
<pubDate>Sun, 07 Jun 2020 17:12:00 +0000</pubDate>
<dc:creator>pavi</dc:creator>
<og:description>1 jvm结构图 2 类的装载器 ​ 将类的字节码文件加载到jvm中，会把这些内容转化为方法区运行的数据结构。jvm会创建对应的Class对象，保存到堆中。 装载器有如下几种：虚拟机自带装载器：启动类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pavi/p/13063301.html</dc:identifier>
</item>
</channel>
</rss>