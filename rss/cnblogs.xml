<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C# 字符串转byte数组 - pingg</title>
<link>http://www.cnblogs.com/pingg2019/p/10778968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pingg2019/p/10778968.html</guid>
<description>&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;public static byte[] HexstringToByte(string InString)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;string[] ByteStrings;&lt;/p&gt;
&lt;p&gt;ByteStrings = InString.Split(&quot; &quot;.ToCharArray());&lt;/p&gt;
&lt;p&gt;byte[] ByteOut;&lt;/p&gt;
&lt;p&gt;ByteOut = new byte[ByteStrings.Length];&lt;/p&gt;
&lt;p&gt;for (int i = 0; i &amp;lt;= ByteStrings.Length - 1; i++)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;ByteOut[i] = Byte.Parse(ByteStrings[i], System.Globalization.NumberStyles.HexNumber);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;return ByteOut;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 27 Apr 2019 07:44:00 +0000</pubDate>
<dc:creator>pingg</dc:creator>
<og:description>public static byte[] HexstringToByte(string InString) { string[] ByteStrings; ByteStrings = InString</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pingg2019/p/10778968.html</dc:identifier>
</item>
<item>
<title>k8s日志收集方案 - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/10778962.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/10778962.html</guid>
<description>&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;strong&gt;　k8s日志收集方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201904/1271786-20190427152903839-96635418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三种收集方案的优缺点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201904/1271786-20190427153030350-1849795614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们就实践第二种日志收集方案：&lt;/p&gt;
&lt;h3&gt;一、安装ELK&lt;/h3&gt;
&lt;p&gt;下面直接采用yum的方式安装ELK（源码包安装参考：&lt;a href=&quot;https://www.cnblogs.com/Dev0ps/p/9309103.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/Dev0ps/p/9309103.html&lt;/a&gt;）&lt;br/&gt;1.安装jdk&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
yum install -y java
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.添加ELK源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
cat &amp;lt;&amp;lt; EOF &amp;gt;&amp;gt;/etc/yum.repos.d/logstash.repo
[logstash-7.x]
name=Elastic repository for 7.x packages
baseurl=https://artifacts.elastic.co/packages/7.x/yum
gpgcheck=1
gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch
enabled=1
autorefresh=1
type=rpm-md
EOF
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.安装ELK组件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
yum install elasticsearch logstash kibana -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4.修改kibana的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master ~]# grep -Ev '^$|^#' /etc/kibana/kibana.yml
server.port: 5601
server.host: &quot;0.0.0.0&quot;
elasticsearch.hosts: [&quot;http://localhost:9200&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 5.启动服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
systemctl start elasticsearch
systemctl start kibana
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 二、收集k8s的日志&lt;/h3&gt;
&lt;p&gt;1.添加logstash配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
input {
  beats {
     port =&amp;gt; 5044
  }
}


filter {
}

output {
       if [app] == &quot;k8s&quot; {
        if [type] == &quot;module&quot; {
           elasticsearch {
              hosts =&amp;gt; [&quot;http://127.0.0.1:9200&quot;]
              index =&amp;gt; &quot;k8s-log-%{+YYYY.MM.dd}&quot;
           }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2.启动logstash&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/logstash-to-es.conf &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3.创建filebeat的yaml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master logs]# cat k8s-logs.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: k8s-logs-filebeat-config
  namespace: kube-system
 
data:
  filebeat.yml: |-
    filebeat.prospectors:
      - type: log
        paths:
          - /messages
        fields:
          app: k8s
          type: module
        fields_under_root: true

    output.logstash:
      hosts: ['172.31.182.140:5044']

---

apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: k8s-logs
  namespace: kube-system
spec:
  selector:
    matchLabels:
      project: k8s
      app: filebeat
  template:
    metadata:
      labels:
        project: k8s
        app: filebeat
    spec:
      containers:
      - name: filebeat
        image: docker.elastic.co/beats/filebeat:6.4.2
        args: [
          &quot;-c&quot;, &quot;/etc/filebeat.yml&quot;,
          &quot;-e&quot;,
        ]
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
          limits:
            cpu: 500m
            memory: 500Mi
        securityContext:
          runAsUser: 0
        volumeMounts:
        - name: filebeat-config
          mountPath: /etc/filebeat.yml
          subPath: filebeat.yml
        - name: k8s-logs
          mountPath: /messages
      volumes:
      - name: k8s-logs
        hostPath:
          path: /var/log/messages
          type: File
      - name: filebeat-config
        configMap:
          name: k8s-logs-filebeat-config
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4.创建pod&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
kubectl apply -f k8s-logs.yaml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 5.kibana添加索引&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201904/1271786-20190427153611411-23475408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201904/1271786-20190427153623251-2082518205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201904/1271786-20190427153634852-1250973098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;三、收集nginx日志&lt;/h3&gt;
&lt;p&gt;1.创建nginx-deployment&lt;br/&gt;默认的日志路径为：/var/log/nginx/&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master logs]# cat nginx-deployment.yaml
apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: nginx-demo
#  namespace: test
spec:
  replicas: 3
  selector:
    matchLabels:
      project: www
      app: www
  template:
    metadata:
      labels:
        project: www
        app: www
    spec:
      imagePullSecrets:
      - name: registry-pull-secret
      containers:
      - name: nginx
        image: nginx:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 80
          name: web
          protocol: TCP
        resources:
          requests:
            cpu: 0.5
            memory: 256Mi
          limits:
            cpu: 1
            memory: 1Gi
        resources:
          requests:
            cpu: 0.5
            memory: 256Mi
          limits:
            cpu: 1
            memory: 1Gi
        livenessProbe:
          httpGet:
            path: /index.html
            port: 80
          initialDelaySeconds: 6
          timeoutSeconds: 20
        volumeMounts:
        - name: nginx-logs
          mountPath: /var/log/nginx/

      - name: filebeat
        image: docker.elastic.co/beats/filebeat:6.4.2
        args: [
          &quot;-c&quot;, &quot;/etc/filebeat.yml&quot;,
          &quot;-e&quot;,
        ]
        resources:
          limits:
            memory: 500Mi
          requests:
            cpu: 100m
            memory: 100Mi
        securityContext:
          runAsUser: 0
        volumeMounts:
        - name: filebeat-config
          mountPath: /etc/filebeat.yml
          subPath: filebeat.yml
        - name: nginx-logs
          mountPath: /var/log/nginx/

      volumes:
      - name: nginx-logs
        emptyDir: {}
      - name: filebeat-config
        configMap:
          name: filebeat-nginx-config
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2.创建filebest收集日志&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master logs]# cat filebeat-nginx-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: filebeat-nginx-config
#  namespace: test
 
data:
  filebeat.yml: |-
    filebeat.prospectors:
      - type: log
        paths:
          - /var/log/nginx/access.log
        # tags: [&quot;access&quot;]
        fields:
          app: www
          type: nginx-access
        fields_under_root: true

      - type: log
        paths:
          - /var/log/nginx/error.log
        # tags: [&quot;error&quot;]
        fields:
          app: www
          type: nginx-error
        fields_under_root: true

    output.logstash:
      hosts: ['172.31.182.140:5044']
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3.添加logstas配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master logs]# cat /etc/logstash/conf.d/logstash-to-es.conf
input {
  beats {
     port =&amp;gt; 5044
  }
}


filter {
}

output {
    if [app] == &quot;www&quot; {
        if [type] == &quot;nginx-access&quot; {
           elasticsearch {
              hosts =&amp;gt; [&quot;http://127.0.0.1:9200&quot;]
              index =&amp;gt; &quot;nginx-access-%{+YYYY.MM.dd}&quot;
           }
        }
        else if [type] == &quot;nginx-error&quot; {
           elasticsearch {
              hosts =&amp;gt; [&quot;http://127.0.0.1:9200&quot;]
              index =&amp;gt; &quot;nginx-error-%{+YYYY.MM.dd}&quot;
           }
        }
    } else if [app] == &quot;k8s&quot; {
        if [type] == &quot;module&quot; {
           elasticsearch {
              hosts =&amp;gt; [&quot;http://127.0.0.1:9200&quot;]
              index =&amp;gt; &quot;k8s-log-%{+YYYY.MM.dd}&quot;
           }
        }
    }
#  stdout { codec=&amp;gt; rubydebug }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4.kibana添加索引&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201904/1271786-20190427153755984-881266814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;四、收集tomcat日志&lt;/h3&gt;
&lt;p&gt;1.1.创建tomcat-deployment&lt;br/&gt;默认的日志路径为：/usr/local/tomcat/logs&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master logs]# cat tomcat-deployment.yaml
apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: tomcat-java-demo
#  namespace: test
spec:
  replicas: 3
  selector:
    matchLabels:
      project: www
      app: www
  template:
    metadata:
      labels:
        project: www
        app: www
    spec:
      imagePullSecrets:
      - name: registry-pull-secret
      containers:
      - name: tomcat
        image: tomcat:latest
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
          name: web
          protocol: TCP
        resources:
          requests:
            cpu: 0.5
            memory: 1Gi
          limits:
            cpu: 1
            memory: 2Gi
        livenessProbe:
          httpGet:
            path: /
            port: 8080
          initialDelaySeconds: 60
          timeoutSeconds: 20
        readinessProbe:
          httpGet:
            path: /
            port: 8080
          initialDelaySeconds: 60
          timeoutSeconds: 20
        volumeMounts:
        - name: tomcat-logs
          mountPath: /usr/local/tomcat/logs

      - name: filebeat
        image: docker.elastic.co/beats/filebeat:6.4.2
        args: [
          &quot;-c&quot;, &quot;/etc/filebeat.yml&quot;,
          &quot;-e&quot;,
        ]
        resources:
          limits:
            memory: 500Mi
          requests:
            cpu: 100m
            memory: 100Mi
        securityContext:
          runAsUser: 0
        volumeMounts:
        - name: filebeat-config
          mountPath: /etc/filebeat.yml
          subPath: filebeat.yml
        - name: tomcat-logs
          mountPath: /usr/local/tomcat/logs
      volumes:
      - name: tomcat-logs
        emptyDir: {}
      - name: filebeat-config
        configMap:
          name: filebeat-config
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2.创建filebest收集tomcat日志&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master logs]# cat filebeat-tomcat-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: filebeat-config
#  namespace: test
 
data:
  filebeat.yml: |-
    filebeat.prospectors:
    - type: log
      paths:
        - /usr/local/tomcat/logs/catalina.*
      # tags: [&quot;tomcat&quot;]
      fields:
        app: www
        type: tomcat-catalina
      fields_under_root: true
      multiline:
        pattern: '^\['
        negate: true
        match: after
    output.logstash:
      hosts: ['172.31.182.140:5044']
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3.添加logstas配置后重启&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@master logs]# cat /etc/logstash/conf.d/logstash-to-es.conf
input {
  beats {
     port =&amp;gt; 5044
  }
}


filter {
}

output {
    if [app] == &quot;www&quot; {
        if [type] == &quot;nginx-access&quot; {
           elasticsearch {
              hosts =&amp;gt; [&quot;http://127.0.0.1:9200&quot;]
              index =&amp;gt; &quot;nginx-access-%{+YYYY.MM.dd}&quot;
           }
        }
        else if [type] == &quot;nginx-error&quot; {
           elasticsearch {
              hosts =&amp;gt; [&quot;http://127.0.0.1:9200&quot;]
              index =&amp;gt; &quot;nginx-error-%{+YYYY.MM.dd}&quot;
           }
        }
        else if [type] == &quot;tomcat-catalina&quot; {
           elasticsearch {
              hosts =&amp;gt; [&quot;http://127.0.0.1:9200&quot;]
              index =&amp;gt; &quot;tomcat-catalina-%{+YYYY.MM.dd}&quot;
           }
        }
    } else if [app] == &quot;k8s&quot; {
        if [type] == &quot;module&quot; {
           elasticsearch {
              hosts =&amp;gt; [&quot;http://127.0.0.1:9200&quot;]
              index =&amp;gt; &quot;k8s-log-%{+YYYY.MM.dd}&quot;
           }
        }
    }
#  stdout { codec=&amp;gt; rubydebug }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4.kibana添加索引&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201904/1271786-20190427153933172-1005838312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Sat, 27 Apr 2019 07:44:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<og:description>k8s日志收集方案 三种收集方案的优缺点： 下面我们就实践第二种日志收集方案： 一、安装ELK 下面直接采用yum的方式安装ELK（源码包安装参考：https://www.cnblogs.com/De</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dev0ps/p/10778962.html</dc:identifier>
</item>
<item>
<title>ABP框架展示异常信息 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/10776948.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/10776948.html</guid>
<description>&lt;p&gt;　　&lt;strong&gt;接触ABP框架有一段时间了，也遇到了一些问题，看了官网文档，但是或许是看的不够细致的原因，实际开发中还是遇到了一些问题，耗费了时间去处理，回头一看，原来文档中早已提及。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;开发环境：ABP+MPA模式+Asp.Net Core&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;一、异常信息处理&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　犹如ABP官网文档所介绍的，ABP已经帮我们把异常这块处理的很完善了，我们要做的就是利用好ABP处理异常的功能。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201904/1133736-20190427131034083-1425012872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ABP提供了直接将应用层对外服务的功能，通过ABP运行时所创建的动态API层，我们可以使用js方法去直接调用应用层服务，当然直接访问控制器下的方法并没有被舍弃。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201904/1133736-20190427135412822-167485095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在ABP内自动封装好了一批处理异常的类，配合着这些异常类的使用，ABP在前端也封装了一些方法，方便我们处理异常信息，同时我们也可以改造前端在展示异常的方式，ABP封装的是使用Message API展示异常信息并使用的是sweetAlert插件，ABP前端js中提供了方式可以使得我们阻止默认的展示，进而使用自定义的展示插件和展示方式。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201904/1133736-20190427123158644-1401072553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　在封装的类中，UserFriendlyException是对用户友好的，对于一些操作可能产生的问题，可以通过抛出UserFriendlyException直接展示给用户看，而对于其它异常，前端会将详细信息的隐藏，因为用户并不会关心具体报错原因，只知道是报错了。在代码中，有些操作可能需要我们进行判断，然后反馈给用户，以便提示用户更改相关数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[AbpAuthorize(AppPermissions.Pages_Standard_ItemCode_Create)]
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task CreateItemCodeAsync(CreateOrUpdateItemCodeInput input)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; itemCode = ObjectMapper.Map&amp;lt;ItemCode&amp;gt;&lt;span&gt;(input.ItemCode);
    itemCode.Id &lt;/span&gt;=&lt;span&gt; itemCode.CreateUniqueItemCode();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; existedItemCode = &lt;span&gt;await&lt;/span&gt; _itemCodeRepository.FirstOrDefaultAsync(t =&amp;gt;&lt;span&gt; t.Id.Equals(itemCode.Id));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (existedItemCode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UserFriendlyException(L(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该检测项目已经存在.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    }

    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _itemCodeRepository.InsertAsync(itemCode);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如上，在做一个操作前，可能需要判断是否有相同的记录，如果有，需要提示给用户，通过直接抛出UserFriendlyException，在控制器内或在应用层抛出异常都行，可以将信息直接呈现给用户，但是需要注意的是有一些条件限制，需要满足相关的条件才能获取到该错误信息，否则很有可能拿到如下结果或是英文错误：&lt;strong&gt;&quot;An error has occurred! Error detail not sent by server.&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201904/1133736-20190427132858982-1416739404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;二、展示异常信息的方式&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　在ABP文档中，专门有一篇文章是处理异常的，&lt;a href=&quot;https://aspnetboilerplate.com/Pages/Documents/Handling-Exceptions&quot;&gt;https://aspnetboilerplate.com/Pages/Documents/Handling-Exceptions&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201904/1133736-20190427141316161-718255659.png&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;368&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1、非Ajax请求，则直接展示错误页，此处模拟抛出两种异常类型，然后在界面中看异常信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;throw new System.Exception(&quot;error message&quot;);&lt;/span&gt;
    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UserFriendlyException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果是抛出的异常不是UserFriendlyException类型，则错误页中展示的信息可能会被隐藏，展示的是描述性的，只需要知道内部出错就行。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201904/1133736-20190427143616068-267930724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当抛出的是UserFriendlyException类型时，可以看到一些直观的错误信息。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201904/1133736-20190427143941175-751541190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当然，可以在WebCoreModule模块的预加载方法中启动展示详细信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Configuration.Modules.AbpWebCommon().SendAllExceptionsToClients = &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　比如开启后，可以看到如下具体错误信息，虽然这些信息对于用户来讲是没有什么价值的。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201904/1133736-20190427143723313-178985860.png&quot; alt=&quot;&quot; width=&quot;889&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、Ajax请求中，跟着官方给定的文档走一遍是没有错的，就怕一些小细节没有把握到，然后产生大问题，Ajax形式的调用并结合WrapResult特性使用后，在出现异常时，会将数据封装成如下简约形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;targetUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An internal error occurred during your request!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;details&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unAuthorizedRequest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　这里需要注意一个关键的一点，是调用控制器下某个方法的返回类型，必须要&lt;span&gt;&lt;strong&gt;object、JsonResult和ObjectResult&lt;/strong&gt;&lt;/span&gt;类型，否则将会页面错误框中看不到具体的错误信息。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201904/1133736-20190427144913299-2076998449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从开发习惯来讲，控制器中的方法返回值类型，我喜欢写如下的格式(错误用法)，直接使用IActionResult很方便，但是也会有麻烦，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpPost]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; CreateXXX([FromBody]ItemCodeViewModel itemCodeViewModel)
{&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　　//do something...&lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　当在中抛出异常或是方法内调用应用层服务内抛出异常时，界面上的方法总是无法获取到异常信息，通过查看浏览器内响应的内容总是只会有错误页响应回来，而页面内只能看到&lt;strong&gt;&quot;An error has occurred! Error detail not sent by server.&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201904/1133736-20190427132858982-1416739404.png&quot; alt=&quot;&quot; width=&quot;402&quot; height=&quot;268&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　具体原因就是这个方法的返回值不符合ABP文档给定的要求，而这些细节，在初看文档或是二次看文档中都没有发现它，&lt;strong&gt;细节很重要！！！&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　3、直接通过动态Api层请求应用层服务，这种情形下，当应用层抛出异常时，会将异常信息经WrapResult封装，在前端获取的错误信息便是直接封装完毕的错误信息，然后再经处理展示到页面中。&lt;/p&gt;

&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;&lt;span class=&quot;hljs-number&quot;&gt;2019-&lt;span class=&quot;hljs-number&quot;&gt;04-&lt;span class=&quot;hljs-number&quot;&gt;27,望技术有成后能回来看见自己的脚步&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 27 Apr 2019 07:05:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>接触ABP框架有一段时间了，也遇到了一些问题，看了官网文档，但是或许是看的不够细致的原因，实际开发中还是遇到了一些问题，耗费了时间去处理，回头一看，原来文档中早已提及。 开发环境：ABP+MPA模式+</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/10776948.html</dc:identifier>
</item>
<item>
<title>netty源码学习 - 【刘光亮】</title>
<link>http://www.cnblogs.com/mantu/p/10778674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantu/p/10778674.html</guid>
<description>&lt;p data-source-line=&quot;2&quot;&gt;Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp;amp; clients.&lt;/p&gt;
&lt;h2 id=&quot;系统架构图&quot; data-source-line=&quot;4&quot;&gt;系统架构图&lt;/h2&gt;
&lt;p data-source-line=&quot;5&quot;&gt;&lt;img src=&quot;https://netty.io/images/components.png?ynotemdtimestamp=1556345778868&quot; alt=&quot;eventloop.png&quot; data-src=&quot;https%3A%2F%2Fnetty.io%2Fimages%2Fcomponents.png&quot; data-processed=&quot;https%3A%2F%2Fnetty.io%2Fimages%2Fcomponents.png&quot;/&gt;&lt;/p&gt;

&lt;p data-source-line=&quot;9&quot;&gt;我们首先通过netty官方的demo来分析一下，&lt;a href=&quot;https://github.com/netty/netty/blob/4.1/example/src/main/java/io/netty/example/telnet/TelnetServer.java&quot; target=&quot;_blank&quot;&gt;TelnetServer&lt;/a&gt;。&lt;/p&gt;
&lt;pre data-source-line=&quot;10&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;TelnetServer {

    &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;boolean SSL = System.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ssl&quot;) != &lt;span class=&quot;hljs-keyword&quot;&gt;null;
    &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;int PORT = Integer.parseInt(System.getProperty(&lt;span class=&quot;hljs-string&quot;&gt;&quot;port&quot;, SSL? &lt;span class=&quot;hljs-string&quot;&gt;&quot;8992&quot; : &lt;span class=&quot;hljs-string&quot;&gt;&quot;8023&quot;));

    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;main&lt;span class=&quot;hljs-params&quot;&gt;(String[] args) &lt;span class=&quot;hljs-keyword&quot;&gt;throws Exception {
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;43&quot;&gt;通过上面的代码，我们总结一下：&lt;/p&gt;
&lt;ul data-source-line=&quot;44&quot;&gt;&lt;li&gt;服务端在启动时，需要使用到两个EventLoopGroup，一个是作为监听服务端口，用于accept客户端的连接请求，并创建channel的线程池，线程数量一般设为1即可；另一个是负责channel的read &amp;amp; write等事件的worker线程池，如果没有指定初始值大小，默认为cpu核数*2，详见源码&lt;a href=&quot;https://github.com/netty/netty/blob/4.1/transport/src/main/java/io/netty/channel/MultithreadEventLoopGroup.java&quot; target=&quot;_blank&quot;&gt;MultithreadEventLoopGroup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;指定channel类为NioServerSocketChannel&lt;/li&gt;
&lt;li&gt;通过childHandler方法指定业务处理的ChannelHandler&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;系统监听&quot; data-source-line=&quot;48&quot;&gt;系统监听&lt;/h2&gt;
&lt;p data-source-line=&quot;49&quot;&gt;TelnetServer中的bossGroup的线程数量设置为1，我有个疑问，线程数量如果大于1会怎么样？我们先看看netty相关的系统监听和服务注册的源码。服务的起点在b.bind(PORT).sync().channel().closeFuture().sync()，那么我们就线程b.bind(PORT)开始：&lt;/p&gt;
&lt;pre data-source-line=&quot;50&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-function&quot;&gt;ChannelFuture &lt;span class=&quot;hljs-title&quot;&gt;bind&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int inetPort) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return bind(&lt;span class=&quot;hljs-keyword&quot;&gt;new InetSocketAddress(inetPort));
    }
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-function&quot;&gt;ChannelFuture &lt;span class=&quot;hljs-title&quot;&gt;bind&lt;span class=&quot;hljs-params&quot;&gt;(SocketAddress localAddress) {
        validate();
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (localAddress == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new NullPointerException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;localAddress&quot;);
        }
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-title&quot;&gt;doBind&lt;span class=&quot;hljs-params&quot;&gt;(localAddress);
    }
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-function&quot;&gt;ChannelFuture &lt;span class=&quot;hljs-title&quot;&gt;doBind&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final SocketAddress localAddress) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;final ChannelFuture regFuture = initAndRegister();
        ...
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (regFuture.isDone()) {
            &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;76&quot;&gt;上面的三个方法的代码中，最重要的是initAndRegister()和doBind0两个方法，下面我们先来看一下initAndRegister方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;77&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    final ChannelFuture initAndRegister() {
        Channel channel = null&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;91&quot;&gt;其中，channelFactory.newChannel()会创建一个NioServerSocketChannel的实例，这个就和我们的demo中.channel(NioServerSocketChannel.class)就联系起来了。我们重点来看看init(channel)和config().group().register(channel)，先来看看init方法，init方法在ServerBootstrap中：&lt;/p&gt;
&lt;pre data-source-line=&quot;93&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;void init(Channel channel) &lt;span class=&quot;hljs-keyword&quot;&gt;throws Exception {
        &lt;span class=&quot;hljs-keyword&quot;&gt;final Map&amp;lt;ChannelOption&amp;lt;?&amp;gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;Object&amp;gt; options = options0();
        &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized (options) {
            setChannelOptions(channel, options, logger);
        }

        &lt;span class=&quot;hljs-keyword&quot;&gt;final Map&amp;lt;AttributeKey&amp;lt;?&amp;gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;Object&amp;gt; attrs = attrs0();
        &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized (attrs) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;for (Entry&amp;lt;AttributeKey&amp;lt;?&amp;gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;Object&amp;gt; e: attrs.entrySet()) {
                @SuppressWarnings(&lt;span class=&quot;hljs-string&quot;&gt;&quot;unchecked&quot;)
                AttributeKey&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;Object&amp;gt; &lt;span class=&quot;hljs-built_in&quot;&gt;key = (AttributeKey&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;Object&amp;gt;) e.getKey();
                channel.attr(&lt;span class=&quot;hljs-built_in&quot;&gt;key).&lt;span class=&quot;hljs-built_in&quot;&gt;set(e.getValue());
            }
        }

        ChannelPipeline p = channel.pipeline();
        System.out.&lt;span class=&quot;hljs-built_in&quot;&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hanlder names is :&quot;+p.names());
        &lt;span class=&quot;hljs-keyword&quot;&gt;final EventLoopGroup currentChildGroup = childGroup;
        &lt;span class=&quot;hljs-keyword&quot;&gt;final ChannelHandler currentChildHandler = childHandler;
        &lt;span class=&quot;hljs-keyword&quot;&gt;final Entry&amp;lt;ChannelOption&amp;lt;?&amp;gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;Object&amp;gt;[] currentChildOptions;
        &lt;span class=&quot;hljs-keyword&quot;&gt;final Entry&amp;lt;AttributeKey&amp;lt;?&amp;gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;Object&amp;gt;[] currentChildAttrs;
        &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized (childOptions) {
            currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.&lt;span class=&quot;hljs-built_in&quot;&gt;size()));
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized (childAttrs) {
            currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.&lt;span class=&quot;hljs-built_in&quot;&gt;size()));
        }

        p.addLast(&lt;span class=&quot;hljs-keyword&quot;&gt;new ChannelInitializer&amp;lt;Channel&amp;gt;() {
            @Override
            &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void initChannel(&lt;span class=&quot;hljs-keyword&quot;&gt;final Channel ch) &lt;span class=&quot;hljs-keyword&quot;&gt;throws Exception {
                &lt;span class=&quot;hljs-keyword&quot;&gt;final ChannelPipeline pipeline = ch.pipeline();
                ChannelHandler handler = config.handler();
                &lt;span class=&quot;hljs-keyword&quot;&gt;if (handler != &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
                    pipeline.addLast(handler);
                }

                ch.eventLoop().execute(&lt;span class=&quot;hljs-keyword&quot;&gt;new Runnable() {
                    @Override
                    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void run() {
                        pipeline.addLast(&lt;span class=&quot;hljs-keyword&quot;&gt;new ServerBootstrapAcceptor(
                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                    }
                });
            }
        });
        System.out.&lt;span class=&quot;hljs-built_in&quot;&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hanlder names is :&quot;+p.names());
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;143&quot;&gt;上面的代码可以发现，init主要干了下面的几件事：&lt;/p&gt;
&lt;ul data-source-line=&quot;144&quot;&gt;&lt;li&gt;初始化option和AttributeKey参数；&lt;/li&gt;
&lt;li&gt;获取到channel对应的pipeline，注意每个channel的一生中都会有且只有一个pipeline，这里我们只要知道这个pipeline的类型是：DefaultChannelPipeline，我们对于pipeline添加了两行system.out代码，第一行输出：hanlder names is :[DefaultChannelPipeline$TailContext#0]，；&lt;/li&gt;
&lt;li&gt;p.addLast(new ChannelInitializer&amp;lt;Channel&amp;gt;()主要是为了加入新的连接处理器，后面的章节会专门来介绍pipeline，加入完新的链接处理器后，我们的输出变为了：hanlder names is :[ServerBootstrap$1#0, DefaultChannelPipeline$TailContext#0]；&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;148&quot;&gt;我们再来看看config().group().register(channel)相关的代码，其中config().group()获取到的group就是demo中的：bossGroup，看一下此group下实现的register源码：&lt;/p&gt;
&lt;pre data-source-line=&quot;149&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public ChannelFuture &lt;span class=&quot;hljs-title&quot;&gt;register&lt;span class=&quot;hljs-params&quot;&gt;(Channel channel) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return next().&lt;span class=&quot;hljs-keyword&quot;&gt;register(channel);
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;154&quot;&gt;其中的next()方法会从此group中获取到一个NioEventLoop，关于创建NioEventLoop的过程及分配线程的细节，大家有兴趣的可以自行研究一下&lt;a href=&quot;https://github.com/netty/netty/blob/4.1/transport/src/main/java/io/netty/channel/nio/NioEventLoopGroup.java&quot; target=&quot;_blank&quot;&gt;NioEventLoopGroup&lt;/a&gt;。接下来，我们再来看看NioEventLoop的register方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;155&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public ChannelFuture &lt;span class=&quot;hljs-title&quot;&gt;register&lt;span class=&quot;hljs-params&quot;&gt;(Channel channel) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;register(&lt;span class=&quot;hljs-keyword&quot;&gt;new DefaultChannelPromise(channel, &lt;span class=&quot;hljs-keyword&quot;&gt;this));
    }
    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public ChannelFuture &lt;span class=&quot;hljs-title&quot;&gt;register&lt;span class=&quot;hljs-params&quot;&gt;(final ChannelPromise promise) {
        ObjectUtil.checkNotNull(promise, &lt;span class=&quot;hljs-string&quot;&gt;&quot;promise&quot;);
        promise.channel().unsafe().&lt;span class=&quot;hljs-keyword&quot;&gt;register(&lt;span class=&quot;hljs-keyword&quot;&gt;this, promise);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return promise;
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;166&quot;&gt;其中promise.channel().unsafe().register方法在AbstractUnsafe类里面：&lt;/p&gt;
&lt;pre data-source-line=&quot;167&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;register&lt;span class=&quot;hljs-params&quot;&gt;(EventLoop eventLoop, &lt;span class=&quot;hljs-keyword&quot;&gt;final ChannelPromise promise) {
            ...
            AbstractChannel.&lt;span class=&quot;hljs-keyword&quot;&gt;this.eventLoop = eventLoop;
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (eventLoop.inEventLoop()) {
                register0(promise);
            } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
                &lt;span class=&quot;hljs-keyword&quot;&gt;try {
                    eventLoop.execute(&lt;span class=&quot;hljs-keyword&quot;&gt;new Runnable() {
                        &lt;span class=&quot;hljs-meta&quot;&gt;@Override
                        &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run&lt;span class=&quot;hljs-params&quot;&gt;() {
                            register0(promise);
                        }
                    });
                } 
                ...
            }
        }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;186&quot;&gt;AbstractChannel.this.eventLoop = eventLoop 这行代码将此unsafe对象和NioEventLoopGroup分配的NioEventLoop绑定，其实就是将NioServerSocketChannel和它的eventLoop进行绑定，使得此NioServerSocketChannel相关的代码只能在eventLoop的专属线程里执行，这里也可以回答了我们开头的问题：“TelnetServer中的bossGroup的线程数量设置为1，我有个疑问，线程数量如果大于1会怎么样？”，答案是：线程数量只能设置为1，因为有且只有一个线程会服务于NioServerSocketChannel，设置多了是浪费。我们再来看看register0()相关的代码，注意register0()相关的代码执行已经是在eventLoop的专属线程里执行的了：&lt;/p&gt;
&lt;pre data-source-line=&quot;187&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;        &lt;span class=&quot;hljs-selector-tag&quot;&gt;private &lt;span class=&quot;hljs-selector-tag&quot;&gt;void &lt;span class=&quot;hljs-selector-tag&quot;&gt;register0(ChannelPromise promise) {
            &lt;span class=&quot;hljs-selector-tag&quot;&gt;try {
                ...
                &lt;span class=&quot;hljs-selector-tag&quot;&gt;doRegister();
                ...
                &lt;span class=&quot;hljs-selector-tag&quot;&gt;pipeline&lt;span class=&quot;hljs-selector-class&quot;&gt;.invokeHandlerAddedIfNeeded();

                &lt;span class=&quot;hljs-selector-tag&quot;&gt;safeSetSuccess(promise);
                &lt;span class=&quot;hljs-selector-tag&quot;&gt;pipeline&lt;span class=&quot;hljs-selector-class&quot;&gt;.fireChannelRegistered();
                &lt;span class=&quot;hljs-selector-tag&quot;&gt;if (isActive()) {
                    &lt;span class=&quot;hljs-selector-tag&quot;&gt;if (firstRegistration) {
                        &lt;span class=&quot;hljs-selector-tag&quot;&gt;pipeline&lt;span class=&quot;hljs-selector-class&quot;&gt;.fireChannelActive();
                    } &lt;span class=&quot;hljs-selector-tag&quot;&gt;else &lt;span class=&quot;hljs-selector-tag&quot;&gt;if (config().isAutoRead()) {
                        &lt;span class=&quot;hljs-selector-tag&quot;&gt;beginRead();
                    }
                }
            } 
            ...
        }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;208&quot;&gt;这里面比较重要的是doRegister()、isActive()，我们先来看看doRegister()方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;209&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;doRegister&lt;span class=&quot;hljs-params&quot;&gt;() &lt;span class=&quot;hljs-keyword&quot;&gt;throws Exception {
        &lt;span class=&quot;hljs-keyword&quot;&gt;boolean selected = &lt;span class=&quot;hljs-keyword&quot;&gt;false;
        &lt;span class=&quot;hljs-keyword&quot;&gt;for (;;) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;try {
                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), &lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-keyword&quot;&gt;this);
                &lt;span class=&quot;hljs-keyword&quot;&gt;return;
            } 
            ...
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;221&quot;&gt;javaChannel().register方法调用jdk底层的channel进行注册，具体逻辑就不深入下去，我们再来看看上面的isActive()方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;222&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean &lt;span class=&quot;hljs-title&quot;&gt;isActive&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return javaChannel().socket().isBound();
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;227&quot;&gt;判断端口是否绑定，因为我们现在还没绑定，所以这里会返回false。接下来，我们再来回头看之前提到的AbstractBootstrap的doBind0()方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;228&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;doBind0&lt;span class=&quot;hljs-params&quot;&gt;(
            &lt;span class=&quot;hljs-keyword&quot;&gt;final ChannelFuture regFuture, &lt;span class=&quot;hljs-keyword&quot;&gt;final Channel channel,
            &lt;span class=&quot;hljs-keyword&quot;&gt;final SocketAddress localAddress, &lt;span class=&quot;hljs-keyword&quot;&gt;final ChannelPromise promise) {

        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;247&quot;&gt;上面代码中的channel.bind会调用到AbstractChannel的bind方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;248&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-function&quot;&gt;ChannelFuture &lt;span class=&quot;hljs-title&quot;&gt;bind&lt;span class=&quot;hljs-params&quot;&gt;(SocketAddress localAddress, ChannelPromise promise) {
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return pipeline.&lt;span class=&quot;hljs-title&quot;&gt;bind&lt;span class=&quot;hljs-params&quot;&gt;(localAddress, promise);
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;253&quot;&gt;继续来看DefaultChannelPipeline中的bind方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;254&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-function&quot;&gt;ChannelFuture &lt;span class=&quot;hljs-title&quot;&gt;bind&lt;span class=&quot;hljs-params&quot;&gt;(SocketAddress localAddress, ChannelPromise promise) {
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return tail.&lt;span class=&quot;hljs-title&quot;&gt;bind&lt;span class=&quot;hljs-params&quot;&gt;(localAddress, promise);
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;259&quot;&gt;tail的类型是TailContext，我们来看看它里面的bind方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;260&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public ChannelFuture bind(&lt;span class=&quot;hljs-keyword&quot;&gt;final SocketAddress localAddress, &lt;span class=&quot;hljs-keyword&quot;&gt;final ChannelPromise promise) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;final AbstractChannelHandlerContext &lt;span class=&quot;hljs-keyword&quot;&gt;next = findContextOutbound();
        EventExecutor executor = &lt;span class=&quot;hljs-keyword&quot;&gt;next.executor();
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (executor.inEventLoop()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;next.invokeBind(localAddress, promise);
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
            safeExecute(executor, &lt;span class=&quot;hljs-keyword&quot;&gt;new Runnable() {
                @Override
                &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void run() {
                    &lt;span class=&quot;hljs-keyword&quot;&gt;next.invokeBind(localAddress, promise);
                }
            }, promise, &lt;span class=&quot;hljs-keyword&quot;&gt;null);
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;return promise;
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;277&quot;&gt;上面的代码中的next类型为HeadContext，因为已经在eventLoop里面，所以会直接执行next.invokeBind(localAddress, promise)，源码如下：&lt;/p&gt;
&lt;pre data-source-line=&quot;278&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;invokeBind&lt;span class=&quot;hljs-params&quot;&gt;(SocketAddress localAddress, ChannelPromise promise) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (invokeHandler()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;try {
                ((ChannelOutboundHandler) &lt;span class=&quot;hljs-keyword&quot;&gt;handler()).bind(&lt;span class=&quot;hljs-keyword&quot;&gt;this, localAddress, promise);
            } &lt;span class=&quot;hljs-keyword&quot;&gt;catch (Throwable t) {
                notifyOutboundHandlerException(t, promise);
            }
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
            bind(localAddress, promise);
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;291&quot;&gt;((ChannelOutboundHandler) handler()).bind方法，我们再来看看这个hanlder的bind方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;292&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;bind&lt;span class=&quot;hljs-params&quot;&gt;(
               ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)
               &lt;span class=&quot;hljs-keyword&quot;&gt;throws Exception {
           unsafe.bind(localAddress, promise);
       }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;299&quot;&gt;又调到了unsafe里面的方法，我们继续分析：&lt;/p&gt;
&lt;pre data-source-line=&quot;300&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;bind&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final SocketAddress localAddress, &lt;span class=&quot;hljs-keyword&quot;&gt;final ChannelPromise promise) {
          ...
           &lt;span class=&quot;hljs-keyword&quot;&gt;boolean wasActive = isActive();
           &lt;span class=&quot;hljs-keyword&quot;&gt;try {
               doBind(localAddress);
           } 
           ...
           &lt;span class=&quot;hljs-keyword&quot;&gt;if (!wasActive &amp;amp;&amp;amp; isActive()) {
               invokeLater(&lt;span class=&quot;hljs-keyword&quot;&gt;new Runnable() {
                   &lt;span class=&quot;hljs-meta&quot;&gt;@Override
                   &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run&lt;span class=&quot;hljs-params&quot;&gt;() {
                       pipeline.fireChannelActive();
                   }
               });
           }
           safeSetSuccess(promise);
       }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;319&quot;&gt;核心代码是doBind方法的调用，它在NioServerSocketChannel中，我们来继续分析：&lt;/p&gt;
&lt;pre data-source-line=&quot;320&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-selector-tag&quot;&gt;protected &lt;span class=&quot;hljs-selector-tag&quot;&gt;void &lt;span class=&quot;hljs-selector-tag&quot;&gt;doBind(SocketAddress localAddress) &lt;span class=&quot;hljs-selector-tag&quot;&gt;throws &lt;span class=&quot;hljs-selector-tag&quot;&gt;Exception {
       &lt;span class=&quot;hljs-selector-tag&quot;&gt;if (PlatformDependent.javaVersion() &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;7) {
           &lt;span class=&quot;hljs-selector-tag&quot;&gt;javaChannel()&lt;span class=&quot;hljs-selector-class&quot;&gt;.bind(localAddress, config.getBacklog());
       } &lt;span class=&quot;hljs-selector-tag&quot;&gt;else {
           &lt;span class=&quot;hljs-selector-tag&quot;&gt;javaChannel()&lt;span class=&quot;hljs-selector-class&quot;&gt;.socket()&lt;span class=&quot;hljs-selector-class&quot;&gt;.bind(localAddress, config.getBacklog());
       }
   }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;330&quot;&gt;doBind方法里面就开始调用jdk的相关绑定端口的底层代码，到此我们nioserver的启动流程就已经分析完毕，我们来总结一下:&lt;/p&gt;
&lt;ul data-source-line=&quot;331&quot;&gt;&lt;li&gt;ServerBootstrap bossGroup的线程数设置为1是最好的，因为在netty中任何channel的eventloop只能有一个；&lt;/li&gt;
&lt;li&gt;ServerBootstap在启动过程中有两个比较重要的流程分析，分别是：initAndRegister()和doBind0两个方法，其中initAndRegister实现NioServerSocketChannel的创建、参数的初始化、eventloop的初始化和channel的绑定、业务的handler注册到pipeline中；doBind0主要是调用jdk底层进行端口监听；&lt;/li&gt;
&lt;li&gt;下图是以时序图的方式做的一个流程总结；&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003073/201904/1003073-20190427142439631-276756471.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;336&quot;&gt;启动过程中涉及到的设计模式总结：&lt;/p&gt;
&lt;ul data-source-line=&quot;337&quot;&gt;&lt;li&gt;工厂方法+反射：NioServerSocketChannel类对象的创建使用了工厂方法+反射的机制，使得netty在架构上可以支持Channel接口的实现类的扩展；&lt;/li&gt;
&lt;li&gt;Future模式：netty中的ChannelFuture和ChannelPromise都是Future模式的使用和扩展；&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-source-line=&quot;341&quot;&gt;在前面的server启动分析时，我们就遇到了ChannelPipeline,这个章节我们着重介绍一下ChannelPipeline。首先我们来看一下ChannelPipeline的类结构关系图：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;img src=&quot;https://lexiangla.com/assets/f223196a510711e9804f5254000947ea?ynotemdtimestamp=1556345778868&quot; alt=&quot;channelpipeline.jpg&quot; data-src=&quot;https%3A%2F%2Flexiangla.com%2Fassets%2Ff223196a510711e9804f5254000947ea&quot; data-processed=&quot;https%3A%2F%2Flexiangla.com%2Fassets%2Ff223196a510711e9804f5254000947ea&quot;/&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 如上图所示，ChannelPipeline的继承关系比较简单，我们实际使用的pipeline对象都是DefaultChannelPipeline类的对象。我们在来看一张pipeline和其它重要对象的关系图：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;img src=&quot;https://file.lexiang-asset.com/company_77004d48323611e892fb525400dbda40/assets/2019/03/08dde02c-51ee-11e9-a6ee-525400b4d70f.png?sign=8+BwnIKm6TyIDK+HSwz2lzOG5DFhPTEwMDI5MTYyJms9QUtJRE4yMmgydDZqV0pscEtMYWdsVVRSaWx6czFycjZvYWZ2JmU9MTU1NDQ0NjY0MSZ0PTE1NTM4NDE4NDEmcj0xNDY2NTAzNzMwJmY9L2NvbXBhbnlfNzcwMDRkNDgzMjM2MTFlODkyZmI1MjU0MDBkYmRhNDAvYXNzZXRzLzIwMTkvMDMvMDhkZGUwMmMtNTFlZS0xMWU5LWE2ZWUtNTI1NDAwYjRkNzBmLnBuZyZiPWxleGlhbmctMTAwMjkxNjI=&amp;amp;ynotemdtimestamp=1556345778868&quot; alt=&quot;channelpipe.png&quot; data-src=&quot;https%3A%2F%2Ffile.lexiang-asset.com%2Fcompany_77004d48323611e892fb525400dbda40%2Fassets%2F2019%2F03%2F08dde02c-51ee-11e9-a6ee-525400b4d70f.png%3Fsign%3D8%2BBwnIKm6TyIDK%2BHSwz2lzOG5DFhPTEwMDI5MTYyJms9QUtJRE4yMmgydDZqV0pscEtMYWdsVVRSaWx6czFycjZvYWZ2JmU9MTU1NDQ0NjY0MSZ0PTE1NTM4NDE4NDEmcj0xNDY2NTAzNzMwJmY9L2NvbXBhbnlfNzcwMDRkNDgzMjM2MTFlODkyZmI1MjU0MDBkYmRhNDAvYXNzZXRzLzIwMTkvMDMvMDhkZGUwMmMtNTFlZS0xMWU5LWE2ZWUtNTI1NDAwYjRkNzBmLnBuZyZiPWxleGlhbmctMTAwMjkxNjI%3D&quot; data-processed=&quot;https%3A%2F%2Ffile.lexiang-asset.com%2Fcompany_77004d48323611e892fb525400dbda40%2Fassets%2F2019%2F03%2F08dde02c-51ee-11e9-a6ee-525400b4d70f.png%3Fsign%3D8%2BBwnIKm6TyIDK%2BHSwz2lzOG5DFhPTEwMDI5MTYyJms9QUtJRE4yMmgydDZqV0pscEtMYWdsVVRSaWx6czFycjZvYWZ2JmU9MTU1NDQ0NjY0MSZ0PTE1NTM4NDE4NDEmcj0xNDY2NTAzNzMwJmY9L2NvbXBhbnlfNzcwMDRkNDgzMjM2MTFlODkyZmI1MjU0MDBkYmRhNDAvYXNzZXRzLzIwMTkvMDMvMDhkZGUwMmMtNTFlZS0xMWU5LWE2ZWUtNTI1NDAwYjRkNzBmLnBuZyZiPWxleGlhbmctMTAwMjkxNjI%3D&quot;/&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 由上面的图片上可以看出，以下几点：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul data-source-line=&quot;346&quot;&gt;&lt;li&gt;在netty中，每一个channel都有且只有一个ChannelPipeline为之提供服务；&lt;/li&gt;
&lt;li&gt;DefaultChannelPipeline中有两个固定的ContextHandler存在，一个是head(HeadContext)，一个是tail(TailContext);&lt;/li&gt;
&lt;li&gt;我们需要添加的业务处理Context会添加到head和tail之间，并形成一个双向链表；&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;350&quot;&gt;我们先提个问题，为什么要有双向链表，难道单向的链表不可以吗？我们先来看看DefaultChannelPipeline中的构造方法源码：&lt;/p&gt;
&lt;pre data-source-line=&quot;351&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    protected DefaultChannelPipeline(Channel channel) {
        &lt;span class=&quot;hljs-built_in&quot;&gt;this.channel = ObjectUtil.checkNotNull(channel, &lt;span class=&quot;hljs-string&quot;&gt;&quot;channel&quot;);
        succeededFuture = &lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-type&quot;&gt;SucceededChannelFuture(channel, &lt;span class=&quot;hljs-literal&quot;&gt;null);
        voidPromise =  &lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-type&quot;&gt;VoidChannelPromise(channel, &lt;span class=&quot;hljs-literal&quot;&gt;true);

        tail = &lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-type&quot;&gt;TailContext(&lt;span class=&quot;hljs-built_in&quot;&gt;this);
        head = &lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-type&quot;&gt;HeadContext(&lt;span class=&quot;hljs-built_in&quot;&gt;this);

        head.next = tail;
        tail.prev = head;
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;364&quot;&gt;DefaultChannelPipeline在初始化的时候，会创建两个context，一个为tail，一个为head，tail和head组成双向链表结构，后续业务添加的context/handler对，都会加入到这个双向链表结构里面。我们先来看一下TailContext的源码：&lt;/p&gt;
&lt;pre data-source-line=&quot;365&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;   &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;TailContext &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;AbstractChannelHandlerContext &lt;span class=&quot;hljs-title&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;ChannelInboundHandler {

        &lt;span class=&quot;hljs-type&quot;&gt;TailContext(&lt;span class=&quot;hljs-type&quot;&gt;DefaultChannelPipeline pipeline) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;super(pipeline, &lt;span class=&quot;hljs-literal&quot;&gt;null, &lt;span class=&quot;hljs-type&quot;&gt;TAIL_NAME, &lt;span class=&quot;hljs-literal&quot;&gt;true, &lt;span class=&quot;hljs-literal&quot;&gt;false);
            setAddComplete();
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;374&quot;&gt;上面的代码中，主要是调用了父类的构造方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;375&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name,
                                  boolean inbound, boolean outbound) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.name = ObjectUtil.checkNotNull(name, &lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.pipeline = pipeline;
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.executor = executor;
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.inbound = inbound;
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.outbound = outbound;
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;387&quot;&gt;注意，tail的outbound标志是false，inbound是true，从字面意义来理解，tail是用来处理inbound事件的，它不能处理outbound相关的事件。但真实的情况却并不完全是这样，head会是一个例外。head和tail它们既是HandlerContext的同时，又是HandlerContext关联的hanlder，来看一下代码：&lt;/p&gt;
&lt;pre data-source-line=&quot;388&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public ChannelHandler handler() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;this;
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;394&quot;&gt;我们再来看看HeadContext的源码：&lt;/p&gt;
&lt;pre data-source-line=&quot;395&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;HeadContext &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;AbstractChannelHandlerContext
            implements &lt;span class=&quot;hljs-type&quot;&gt;ChannelOutboundHandler, &lt;span class=&quot;hljs-type&quot;&gt;ChannelInboundHandler {

        &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-type&quot;&gt;Unsafe unsafe;

        &lt;span class=&quot;hljs-type&quot;&gt;HeadContext(&lt;span class=&quot;hljs-type&quot;&gt;DefaultChannelPipeline pipeline) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;super(pipeline, &lt;span class=&quot;hljs-literal&quot;&gt;null, &lt;span class=&quot;hljs-type&quot;&gt;HEAD_NAME, &lt;span class=&quot;hljs-literal&quot;&gt;false, &lt;span class=&quot;hljs-literal&quot;&gt;true);
            unsafe = pipeline.channel().unsafe();
            setAddComplete();
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;408&quot;&gt;head的inbound标志是true，outbound的标志是false，按照之前的说法，head就只能处理outbound相关的事件的，但事实上不是这样的：我们可以发现一个head和tail实现细节的不同：head同时实现了ChannelOutboundHandler和ChannelInboundHandler接口，而tail只实现了ChannelInboundHandler接口。下面以一个inbound事件来进行分析一下：先来看DefaultPipeline中的fireChannelRegistered()：&lt;/p&gt;
&lt;pre data-source-line=&quot;410&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final ChannelPipeline fireChannelRegistered() {
        AbstractChannelHandlerContext.invokeChannelRegistered(head);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;this;
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;417&quot;&gt;方法调用了AbstractChannelHandlerContext的静态方法，并将head作为参数：&lt;/p&gt;
&lt;pre data-source-line=&quot;419&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void invokeChannelRegistered(&lt;span class=&quot;hljs-keyword&quot;&gt;final AbstractChannelHandlerContext &lt;span class=&quot;hljs-keyword&quot;&gt;next) {
        EventExecutor executor = &lt;span class=&quot;hljs-keyword&quot;&gt;next.executor();
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (executor.inEventLoop()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;next.invokeChannelRegistered();
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
            executor.execute(&lt;span class=&quot;hljs-keyword&quot;&gt;new Runnable() {
                @Override
                &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void run() {
                    &lt;span class=&quot;hljs-keyword&quot;&gt;next.invokeChannelRegistered();
                }
            });
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;435&quot;&gt;上面的代码将会在eventloop下调用head的invokeChannelRegistered，我们再来看看：&lt;/p&gt;
&lt;pre data-source-line=&quot;437&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;invokeChannelRegistered&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (invokeHandler()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;try {
                ((ChannelInboundHandler) &lt;span class=&quot;hljs-keyword&quot;&gt;handler()).channelRegistered(&lt;span class=&quot;hljs-keyword&quot;&gt;this);
            } &lt;span class=&quot;hljs-keyword&quot;&gt;catch (Throwable t) {
                notifyHandlerException(t);
            }
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
            fireChannelRegistered();
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;451&quot;&gt;上面的方法会调用到head的channelRegistered方法里面，我们暂时分析到这里，代码分析的结论与我们刚刚的分析判断是一致的：head既可以处理inbound事件，也可以处理outbound事件。&lt;/p&gt;
&lt;h2 id=&quot;inbound-outbound事件&quot; data-source-line=&quot;453&quot;&gt;inbound &amp;amp; outbound事件&lt;/h2&gt;
&lt;p data-source-line=&quot;454&quot;&gt;我们刚刚分析的ChannelRegistered，就是一个典型的inbound事件。下面我们来分析一下inbound和outbound事件。下图是来自于netty官网关于inbound和outbound事件顺序的图示。由图可知：&lt;/p&gt;
&lt;ul data-source-line=&quot;455&quot;&gt;&lt;li&gt;inbound事件一般是来源于socket.read方法；&lt;/li&gt;
&lt;li&gt;outbound事件来源于上层业务的调用，一般会调用到socket.write方法；&lt;/li&gt;
&lt;li&gt;inbound和outbound事件的处理方向相反，但都会沿着各自的方向单向传播；&lt;/li&gt;
&lt;/ul&gt;&lt;pre data-source-line=&quot;459&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;                                             I/O Request
                                        via Channel or
                                    ChannelHandlerContext
                                                    |&lt;span class=&quot;hljs-string&quot;&gt;
+---------------------------------------------------+---------------+
|&lt;span class=&quot;hljs-string&quot;&gt;                           ChannelPipeline         |&lt;span class=&quot;hljs-string&quot;&gt;               |
|&lt;span class=&quot;hljs-string&quot;&gt;                                                  \|&lt;span class=&quot;hljs-string&quot;&gt;/              |
|&lt;span class=&quot;hljs-string&quot;&gt;    +---------------------+            +-----------+----------+    |
|&lt;span class=&quot;hljs-string&quot;&gt;    |&lt;span class=&quot;hljs-string&quot;&gt; Inbound Handler  N  |&lt;span class=&quot;hljs-string&quot;&gt;            |&lt;span class=&quot;hljs-string&quot;&gt; Outbound Handler  1  |&lt;span class=&quot;hljs-string&quot;&gt;    |
|&lt;span class=&quot;hljs-string&quot;&gt;    +----------+----------+            +-----------+----------+    |
|&lt;span class=&quot;hljs-string&quot;&gt;              /|&lt;span class=&quot;hljs-string&quot;&gt;\                                  |&lt;span class=&quot;hljs-string&quot;&gt;               |
|&lt;span class=&quot;hljs-string&quot;&gt;               |&lt;span class=&quot;hljs-string&quot;&gt;                                  \|&lt;span class=&quot;hljs-string&quot;&gt;/              |
|&lt;span class=&quot;hljs-string&quot;&gt;    +----------+----------+            +-----------+----------+    |
|&lt;span class=&quot;hljs-string&quot;&gt;    |&lt;span class=&quot;hljs-string&quot;&gt; Inbound Handler N-1 |&lt;span class=&quot;hljs-string&quot;&gt;            |&lt;span class=&quot;hljs-string&quot;&gt; Outbound Handler  2  |&lt;span class=&quot;hljs-string&quot;&gt;    |
|&lt;span class=&quot;hljs-string&quot;&gt;    +----------+----------+            +-----------+----------+    |
|&lt;span class=&quot;hljs-string&quot;&gt;              /|&lt;span class=&quot;hljs-string&quot;&gt;\                                  .               |
|&lt;span class=&quot;hljs-string&quot;&gt;               .                                   .               |
|&lt;span class=&quot;hljs-string&quot;&gt; ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|
|&lt;span class=&quot;hljs-string&quot;&gt;        [ method call]                       [method call]         |
|&lt;span class=&quot;hljs-string&quot;&gt;               .                                   .               |
|&lt;span class=&quot;hljs-string&quot;&gt;               .                                  \|&lt;span class=&quot;hljs-string&quot;&gt;/              |
|&lt;span class=&quot;hljs-string&quot;&gt;    +----------+----------+            +-----------+----------+    |
|&lt;span class=&quot;hljs-string&quot;&gt;    |&lt;span class=&quot;hljs-string&quot;&gt; Inbound Handler  2  |&lt;span class=&quot;hljs-string&quot;&gt;            |&lt;span class=&quot;hljs-string&quot;&gt; Outbound Handler M-1 |&lt;span class=&quot;hljs-string&quot;&gt;    |
|&lt;span class=&quot;hljs-string&quot;&gt;    +----------+----------+            +-----------+----------+    |
|&lt;span class=&quot;hljs-string&quot;&gt;              /|&lt;span class=&quot;hljs-string&quot;&gt;\                                  |&lt;span class=&quot;hljs-string&quot;&gt;               |
|&lt;span class=&quot;hljs-string&quot;&gt;               |&lt;span class=&quot;hljs-string&quot;&gt;                                  \|&lt;span class=&quot;hljs-string&quot;&gt;/              |
|&lt;span class=&quot;hljs-string&quot;&gt;    +----------+----------+            +-----------+----------+    |
|&lt;span class=&quot;hljs-string&quot;&gt;    |&lt;span class=&quot;hljs-string&quot;&gt; Inbound Handler  1  |&lt;span class=&quot;hljs-string&quot;&gt;            |&lt;span class=&quot;hljs-string&quot;&gt; Outbound Handler  M  |&lt;span class=&quot;hljs-string&quot;&gt;    |
|&lt;span class=&quot;hljs-string&quot;&gt;    +----------+----------+            +-----------+----------+    |
|&lt;span class=&quot;hljs-string&quot;&gt;              /|&lt;span class=&quot;hljs-string&quot;&gt;\                                  |&lt;span class=&quot;hljs-string&quot;&gt;               |
+---------------+-----------------------------------+---------------+
                |&lt;span class=&quot;hljs-string&quot;&gt;                                  \|&lt;span class=&quot;hljs-string&quot;&gt;/
+---------------+-----------------------------------+---------------+
|&lt;span class=&quot;hljs-string&quot;&gt;               |&lt;span class=&quot;hljs-string&quot;&gt;                                   |&lt;span class=&quot;hljs-string&quot;&gt;               |
|&lt;span class=&quot;hljs-string&quot;&gt;       [ Socket.read() ]                    [ Socket.write() ]     |
|&lt;span class=&quot;hljs-string&quot;&gt;                                                                   |
|&lt;span class=&quot;hljs-string&quot;&gt;  Netty Internal I/O Threads (Transport Implementation)            |
+-------------------------------------------------------------------+
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;inbound事件&quot; data-source-line=&quot;500&quot;&gt;inbound事件&lt;/h3&gt;
&lt;p data-source-line=&quot;501&quot;&gt;我们来详细的分析一下inbound事件相关的源码。首先，我们来看看inbound事件有哪些：&lt;/p&gt;
&lt;pre data-source-line=&quot;502&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    fireChannelRegistered&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;513&quot;&gt;inbound事件共用9个事件，它们都是以fire...开头。我们来简单看一下fireChannelRead相关的流程代码，流程的起点是在NioByteUnsafe的read方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;515&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;        public final void read() {
            ...
            try {
                do {
                    &lt;span class=&quot;hljs-keyword&quot;&gt;byteBuf = allocHandle.allocate(allocator)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;540&quot;&gt;每次从底层的socket里面读取到内容，netty都会调用pipeline的fireChannelRead方法，此方法就是我们刚刚看到的inbound事件里面的方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;542&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final ChannelPipeline fireChannelRead(Object msg) {
        AbstractChannelHandlerContext.invokeChannelRead(head, msg);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;this;
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;549&quot;&gt;上面的pipeline代码会调用到AbstractChannelHandlerContext的invokeChannelRead方法并将head和读取到的msg传递过去，我们再来看看invokeChannelRead：&lt;/p&gt;
&lt;pre data-source-line=&quot;551&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void invokeChannelRead(&lt;span class=&quot;hljs-keyword&quot;&gt;final AbstractChannelHandlerContext &lt;span class=&quot;hljs-keyword&quot;&gt;next, Object msg) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;final Object m = &lt;span class=&quot;hljs-keyword&quot;&gt;next.pipeline.touch(ObjectUtil.checkNotNull(msg, &lt;span class=&quot;hljs-string&quot;&gt;&quot;msg&quot;), &lt;span class=&quot;hljs-keyword&quot;&gt;next);
        EventExecutor executor = &lt;span class=&quot;hljs-keyword&quot;&gt;next.executor();
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (executor.inEventLoop()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;next.invokeChannelRead(m);
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
            executor.execute(&lt;span class=&quot;hljs-keyword&quot;&gt;new Runnable() {
                @Override
                &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void run() {
                    &lt;span class=&quot;hljs-keyword&quot;&gt;next.invokeChannelRead(m);
                }
            });
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;568&quot;&gt;上面的方法会先调用head的invokeChannelRead方法，进入head中进行处理：&lt;/p&gt;
&lt;pre data-source-line=&quot;570&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;invokeChannelRead&lt;span class=&quot;hljs-params&quot;&gt;(Object msg) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (invokeHandler()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;try {
                ((ChannelInboundHandler) &lt;span class=&quot;hljs-keyword&quot;&gt;handler()).channelRead(&lt;span class=&quot;hljs-keyword&quot;&gt;this, msg);
            } &lt;span class=&quot;hljs-keyword&quot;&gt;catch (Throwable t) {
                notifyHandlerException(t);
            }
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
            fireChannelRead(msg);
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;584&quot;&gt;流程进入到head的channelRead方法，我们来看看：&lt;/p&gt;
&lt;pre data-source-line=&quot;586&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;channelRead&lt;span class=&quot;hljs-params&quot;&gt;(ChannelHandlerContext ctx, Object msg) &lt;span class=&quot;hljs-keyword&quot;&gt;throws Exception {
            ctx.fireChannelRead(msg);
        }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;592&quot;&gt;上面的代码中的ctx还是head本身，我们来看看head的fireChannelRead方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;594&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public ChannelHandlerContext fireChannelRead(&lt;span class=&quot;hljs-keyword&quot;&gt;final Object msg) {
        invokeChannelRead(findContextInbound(), msg);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;this;
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;601&quot;&gt;上面的方法中会通过我们看看已经看到过的invokeChannelRead方法，调用到head的下一个的处理inbound事件的Context中去，后面代码我们便不展开。我们总结一下inbound相关事件的处理：&lt;/p&gt;
&lt;ul data-source-line=&quot;602&quot;&gt;&lt;li&gt;inbound事件一般是来源于socket的read方法；&lt;/li&gt;
&lt;li&gt;netty目前的inbound事件一共有9种；&lt;/li&gt;
&lt;li&gt;netty的inbound事件在pipeline中方法的起点是以fire...()开头的方法，inbound事件会从head节点开始向后传递并处理；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;outbound事件&quot; data-source-line=&quot;606&quot;&gt;outbound事件&lt;/h3&gt;
&lt;p data-source-line=&quot;607&quot;&gt;我们再来看看outbound的事件有哪些，outbound的事件比inbound事件会复杂一些，因为它的外部调用接口会比较多，但是抽象一下，就是下面这几种事件：&lt;/p&gt;
&lt;pre data-source-line=&quot;609&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    bind&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;620&quot;&gt;outbound的事件入口也在pipeline的公共方法里，例如write的流程调用：&lt;/p&gt;
&lt;pre data-source-line=&quot;622&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-function&quot;&gt;ChannelFuture &lt;span class=&quot;hljs-title&quot;&gt;writeAndFlush&lt;span class=&quot;hljs-params&quot;&gt;(Object msg) {
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return tail.&lt;span class=&quot;hljs-title&quot;&gt;writeAndFlush&lt;span class=&quot;hljs-params&quot;&gt;(msg);
    }

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;629&quot;&gt;上面的方法会调用到tail的writeAndFlush方法里面。关于write流程的分析，后面会有专门的章节分析，在此不展开了。&lt;/p&gt;
&lt;h3 id=&quot;异常事件&quot; data-source-line=&quot;631&quot;&gt;异常事件&lt;/h3&gt;
&lt;p data-source-line=&quot;632&quot;&gt;通过上面的分析，我们都了解了inbound和outbound事件相关处理细节，那么在处理inbound和outbound事件时，如果处理逻辑遇到了异常，ChannelPipeline是如何处理的？我们接下来便来分析一下ChannelPipeline里关于异常的处理。按下面三种情况，异常事件的处理情况是不同的：&lt;/p&gt;
&lt;ul data-source-line=&quot;633&quot;&gt;&lt;li&gt;inbound事件；&lt;/li&gt;
&lt;li&gt;outbound事件，且需要ChannelPromise模式回调通知的方法；&lt;/li&gt;
&lt;li&gt;outbound事件，但不需要ChannelPromise模式回调通知的方法；&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;637&quot;&gt;其中，第一和第三两种情况处理方式相同。我们先来看看inbound异常事件的处理。&lt;/p&gt;
&lt;h4 id=&quot;inbound异常事件&quot; data-source-line=&quot;639&quot;&gt;inbound异常事件&lt;/h4&gt;
&lt;p data-source-line=&quot;640&quot;&gt;我们选择channelActive来分析，首先来看DefaultPipeline中的fireChannelActive：&lt;/p&gt;
&lt;pre data-source-line=&quot;642&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final ChannelPipeline fireChannelActive() {
        AbstractChannelHandlerContext.invokeChannelActive(head);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;this;
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;649&quot;&gt;我们再接着往下看：&lt;/p&gt;
&lt;pre data-source-line=&quot;651&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void invokeChannelActive(&lt;span class=&quot;hljs-keyword&quot;&gt;final AbstractChannelHandlerContext &lt;span class=&quot;hljs-keyword&quot;&gt;next) {
        EventExecutor executor = &lt;span class=&quot;hljs-keyword&quot;&gt;next.executor();
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (executor.inEventLoop()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;next.invokeChannelActive();
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
            executor.execute(&lt;span class=&quot;hljs-keyword&quot;&gt;new Runnable() {
                @Override
                &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void run() {
                    &lt;span class=&quot;hljs-keyword&quot;&gt;next.invokeChannelActive();
                }
            });
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;667&quot;&gt;上面的静态方法中，会直接进入到next.invokeChannelActive()，此时的ChannelHandlerContext为head：&lt;/p&gt;
&lt;pre data-source-line=&quot;669&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;invokeChannelActive&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (invokeHandler()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;try {
                ((ChannelInboundHandler) &lt;span class=&quot;hljs-keyword&quot;&gt;handler()).channelActive(&lt;span class=&quot;hljs-keyword&quot;&gt;this);
            } &lt;span class=&quot;hljs-keyword&quot;&gt;catch (Throwable t) {
                notifyHandlerException(t);
            }
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
            fireChannelActive();
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;683&quot;&gt;在上面的代码中，我们假设在try{}模块内抛出了异常，流程便走到了notifyHandlerException：&lt;/p&gt;
&lt;pre data-source-line=&quot;685&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;notifyHandlerException&lt;span class=&quot;hljs-params&quot;&gt;(Throwable cause) {
        ...
        invokeExceptionCaught(cause);
    }

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;693&quot;&gt;直接看重点的invokeExceptionCaught：&lt;/p&gt;
&lt;pre data-source-line=&quot;695&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;invokeExceptionCaught&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final Throwable cause) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (invokeHandler()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;try {
                &lt;span class=&quot;hljs-keyword&quot;&gt;handler().exceptionCaught(&lt;span class=&quot;hljs-keyword&quot;&gt;this, cause);
            } &lt;span class=&quot;hljs-keyword&quot;&gt;catch (Throwable &lt;span class=&quot;hljs-keyword&quot;&gt;error) {
                ...
            }
        } 
        ...
    }

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;709&quot;&gt;上面的代码会调用到Context对应的handler的exceptionCaught方法，目前我们的context还是head：&lt;/p&gt;
&lt;pre data-source-line=&quot;711&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;exceptionCaught&lt;span class=&quot;hljs-params&quot;&gt;(ChannelHandlerContext ctx, Throwable cause) &lt;span class=&quot;hljs-keyword&quot;&gt;throws Exception {
            ctx.fireExceptionCaught(cause);
        }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;717&quot;&gt;再接着看AbstractChannelHandlerContext的方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;719&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public ChannelHandlerContext fireExceptionCaught(&lt;span class=&quot;hljs-keyword&quot;&gt;final Throwable cause) {
        invokeExceptionCaught(next, cause);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;this;
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;726&quot;&gt;注意上面方法中的next，它是head的next节点，我们再来看看invokeExceptionCaught：&lt;/p&gt;
&lt;pre data-source-line=&quot;728&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void invokeExceptionCaught(&lt;span class=&quot;hljs-keyword&quot;&gt;final AbstractChannelHandlerContext &lt;span class=&quot;hljs-keyword&quot;&gt;next, &lt;span class=&quot;hljs-keyword&quot;&gt;final Throwable cause) {
        ObjectUtil.checkNotNull(cause, &lt;span class=&quot;hljs-string&quot;&gt;&quot;cause&quot;);
        EventExecutor executor = &lt;span class=&quot;hljs-keyword&quot;&gt;next.executor();
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (executor.inEventLoop()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;next.invokeExceptionCaught(cause);
        }
        ...
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;739&quot;&gt;上面的代码会调用next(下一个Context)的invokeExceptionCaught方法，最终会调用到能处理异常的hanlder，然后终止，netty建议我们将异常处理的Context作为最后一个，也就是tail前面的一个。如果没有能处理此异常的hanlder，那么最后会走到tail中的处理方法。&lt;/p&gt;
&lt;p data-source-line=&quot;741&quot;&gt;inbound异常事件总结：&lt;/p&gt;
&lt;ul data-source-line=&quot;742&quot;&gt;&lt;li&gt;异常事件也是在ChanelPipeline上进行传递，传递顺序为由前向后；&lt;/li&gt;
&lt;li&gt;一般会将tail前一个Context作为异常事件的处理节点，如没有，则会在tail中进行处理；&lt;/li&gt;
&lt;li&gt;outbound异常事件(不需要回调通知ChannelPromise)，与inbound事件的处理逻辑完全一致；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;outbound异常事件channelpromise&quot; data-source-line=&quot;746&quot;&gt;outbound异常事件(ChannelPromise)&lt;/h4&gt;
&lt;p data-source-line=&quot;747&quot;&gt;关于outbound异常事件(ChannelPromise)的处理流程并不是在链表上进行传递处理的，它因为需要通知到ChannelPromise，因此，它的代码最终会走到PromiseNotificationUtil方法中：&lt;/p&gt;
&lt;pre data-source-line=&quot;749&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;tryFailure&lt;span class=&quot;hljs-params&quot;&gt;(Promise&amp;lt;?&amp;gt; p, Throwable cause, InternalLogger logger) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (!p.tryFailure(cause) &amp;amp;&amp;amp; logger != &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
            Throwable err = p.cause();
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (err == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
                logger.warn(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Failed to mark a promise as failure because it has succeeded already: {}&quot;, p, cause);
            } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
                logger.warn(
                        &lt;span class=&quot;hljs-string&quot;&gt;&quot;Failed to mark a promise as failure because it has failed already: {}, unnotified cause: {}&quot;,
                        p, ThrowableUtil.stackTraceToString(err), cause);
            }
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;764&quot;&gt;上面的代码如果调用通知promise成功，则返回，否则打印日志。&lt;/p&gt;
&lt;p data-source-line=&quot;766&quot;&gt;outbound异常事件(ChannelPromise)总结：&lt;/p&gt;
&lt;ul data-source-line=&quot;767&quot;&gt;&lt;li&gt;处理流程简单，直接通知ChannePromise，并不会在ChannelPipeline上进行传递；&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;769&quot;&gt;最后，我们总结一下inbound和outbound事件：&lt;/p&gt;
&lt;ul data-source-line=&quot;770&quot;&gt;&lt;li&gt;inbound事件一般是来源于socket的read方法；&lt;/li&gt;
&lt;li&gt;netty目前的inbound事件一共有9种；&lt;/li&gt;
&lt;li&gt;netty的inbound事件在pipeline中方法的起点是以fire...()开头的方法，inbound事件会从head节点开始向后传递并处理；&lt;/li&gt;
&lt;li&gt;outbound事件一般从pipeline中的方法开始，然后会调用到tail中的方法，然后向前传递并处理，最终会经过head，调用到socket的操作；&lt;/li&gt;
&lt;li&gt;netty目前的outbound事件一共有8种；&lt;/li&gt;
&lt;li&gt;pipeline的双向链表数据结构是为了支持inbound和outbound两种事件的传递；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;channelpipeline小结&quot; data-source-line=&quot;777&quot;&gt;ChannelPipeline小结&lt;/h2&gt;
&lt;ul data-source-line=&quot;778&quot;&gt;&lt;li&gt;ChannelPipeline的底层数据结构是一个双向链表结构，双向链表从数据结构上即支持了inbound的outbound两种事件的流转；&lt;/li&gt;
&lt;li&gt;每个channel都会创建唯一的ChannelPipeline为之服务；&lt;/li&gt;
&lt;li&gt;inbound事件的起点是head、outbound事件的起点是tail;&lt;/li&gt;
&lt;li&gt;ChannelPipeline可以支持Context&amp;amp;Handler动态的添加和删除；&lt;/li&gt;
&lt;li&gt;异常事件的处理分为inbound异常事件处理、outbound异常事件处理且需要通知ChannelPromise和outbound异常事件但无需通知ChannelPromise三种情况。其中第一种和第三种，都需要在ChannelPipeline上从前到后进行传递；第二种直接回调通知ChannelPromise即可；&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;784&quot;&gt;涉及到的设计模式总结：&lt;/p&gt;
&lt;ul data-source-line=&quot;785&quot;&gt;&lt;li&gt;管道模型(pipeline)：在netty中，所有inbound和outbound事件的传递都离不开pipeline，它的pipeline模型的底层是一个双向链表的数据结构，每个链表的节点代表一个对应事件的handler，当事件传递到某个节点时，先判断是否应该处理，最后向下一个节点传递，可以支持handler的热插拔；&lt;/li&gt;
&lt;/ul&gt;
&lt;p data-source-line=&quot;788&quot;&gt;因为write的流程相对比较复杂，在此我们单独拿一个章节来进行分析。首先，我们来拿netty4中的telnet的demo来说明netty4的write流程：&lt;/p&gt;
&lt;ul data-source-line=&quot;789&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;涉及到的类：TelnetClient、AbstractChannel、DefaultChannelPipeline、TailContext、AbstractChannelHandlerContext、SingleThreadEventExecutor、NioEventLoop、AbstractEventExecutor、AbstractChannelHandlerContext.WriteAndFlushTask、&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;流程顺序是：TelnetClient -&amp;gt; AbstractChannel -&amp;gt; DefaultChannelPipeline -&amp;gt; TailContext(AbstractChannelHandlerContext) -&amp;gt; NioEventLoop (SingleThreadEventExecutor) -&amp;gt;NioEventLoop(run方法) -&amp;gt; AbstractEventExecutor(safeExecute方法) -&amp;gt; WriteAndFlushTask(run方法) -&amp;gt; AbstractChannelHandlerContext(hanlder为StringEncoder) -&amp;gt; StringEncoder(write方法) -&amp;gt; HeadContext(invokeWrite方法) -&amp;gt; NioSocketChannelUnsafe(write)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;793&quot;&gt;流程的起点在TelnetClient，我们来看一下源码：&lt;/p&gt;
&lt;pre data-source-line=&quot;794&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;lastWriteFuture = ch.writeAndFlush(line + &lt;span class=&quot;hljs-string&quot;&gt;&quot;\r\n&quot;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;797&quot;&gt;其中的ch为NioSocketChannel，telnetclient直接调用了NioSocketChannel的父类AbstractChannel(不是直接的父类)中的writeAndFlush方法，代码如下：&lt;/p&gt;
&lt;pre data-source-line=&quot;798&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-function&quot;&gt;ChannelFuture &lt;span class=&quot;hljs-title&quot;&gt;writeAndFlush&lt;span class=&quot;hljs-params&quot;&gt;(Object msg) {
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return pipeline.&lt;span class=&quot;hljs-title&quot;&gt;writeAndFlush&lt;span class=&quot;hljs-params&quot;&gt;(msg);
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;803&quot;&gt;上面的方法比较简单，直接调用了DefaultChannelPipeline的writeAndFlush方法，也就是outbound事件开始在pipeline中传递：&lt;/p&gt;
&lt;pre data-source-line=&quot;804&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-function&quot;&gt;ChannelFuture &lt;span class=&quot;hljs-title&quot;&gt;writeAndFlush&lt;span class=&quot;hljs-params&quot;&gt;(Object msg) {
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return tail.&lt;span class=&quot;hljs-title&quot;&gt;writeAndFlush&lt;span class=&quot;hljs-params&quot;&gt;(msg);
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;809&quot;&gt;上面的方法调用了TailContext的writeAndFlush方法，其实是TailContext的父类AbstractChannelHandlerContext中的方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;810&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public ChannelFuture writeAndFlush(Object msg) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return writeAndFlush(msg, newPromise());
    }
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (msg == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new NullPointerException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;msg&quot;);
        }

        &lt;span class=&quot;hljs-keyword&quot;&gt;if (isNotValidPromise(promise, &lt;span class=&quot;hljs-keyword&quot;&gt;true)) {
            ReferenceCountUtil.release(msg);
            &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;852&quot;&gt;上面的最后一个方法中，会被调用两次。第一次调用时，第一次的next的ChannelHandlerContext对应的context为handler对应为io.netty.handler.codec.string.StringEncoder的context，context和handler的对应关系为一对一。首先因为executor.inEventLoop() = false，也就是当前线程和channel的专属负责读写的线程不是同一个线程，所以会先走到else中的逻辑里面，先创建一个WriteAndFlushTask类型的task，然后调用safeExecute方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;853&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;safeExecute&lt;span class=&quot;hljs-params&quot;&gt;(EventExecutor executor, Runnable runnable, ChannelPromise promise, Object msg) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;try {
            executor.execute(runnable);
        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch (Throwable cause) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;try {
                promise.setFailure(cause);
            } &lt;span class=&quot;hljs-keyword&quot;&gt;finally {
                &lt;span class=&quot;hljs-keyword&quot;&gt;if (msg != &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
                    ReferenceCountUtil.release(msg);
                }
            }
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;868&quot;&gt;safeExecute会调用NioEventLoop(SingleThreadEventExecutor)里的execute方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;869&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void execute(Runnable &lt;span class=&quot;hljs-keyword&quot;&gt;task) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (&lt;span class=&quot;hljs-keyword&quot;&gt;task == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new NullPointerException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;task&quot;);
        }

        &lt;span class=&quot;hljs-keyword&quot;&gt;boolean inEventLoop = inEventLoop();
        addTask(&lt;span class=&quot;hljs-keyword&quot;&gt;task);
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (!inEventLoop) {
            startThread();
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (isShutdown() &amp;amp;&amp;amp; removeTask(&lt;span class=&quot;hljs-keyword&quot;&gt;task)) {
                reject();
            }
        }

        &lt;span class=&quot;hljs-keyword&quot;&gt;if (!addTaskWakesUp &amp;amp;&amp;amp; wakesUpForTask(&lt;span class=&quot;hljs-keyword&quot;&gt;task)) {
            wakeup(inEventLoop);
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;889&quot;&gt;上面的代码重点在于addTask方法，我们来看一下细节：&lt;/p&gt;
&lt;pre data-source-line=&quot;890&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;void addTask(Runnable &lt;span class=&quot;hljs-keyword&quot;&gt;task) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (&lt;span class=&quot;hljs-keyword&quot;&gt;task == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new NullPointerException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;task&quot;);
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (!offerTask(&lt;span class=&quot;hljs-keyword&quot;&gt;task)) {
            reject(&lt;span class=&quot;hljs-keyword&quot;&gt;task);
        }
    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;boolean offerTask(Runnable &lt;span class=&quot;hljs-keyword&quot;&gt;task) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (isShutdown()) {
            reject();
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;return taskQueue.offer(&lt;span class=&quot;hljs-keyword&quot;&gt;task);
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;907&quot;&gt;上面的代码显示了，之前生成的task会最终存进类型为: 的taskQueue中LinkedBlockingQueue中，到此为止，业务线程已经将write的操作任务通过队列移交给了NioEventLoop的线程，那么我们再来看看NioEventLoop是如何处理上面的task任务的：&lt;/p&gt;
&lt;pre data-source-line=&quot;908&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;run&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;for (;;) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;try {
                ...
                &lt;span class=&quot;hljs-keyword&quot;&gt;if (ioRatio == &lt;span class=&quot;hljs-number&quot;&gt;100) {
                    ...
                } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
                    &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;long ioStartTime = System.nanoTime();
                    &lt;span class=&quot;hljs-keyword&quot;&gt;try {
                        processSelectedKeys();
                    } &lt;span class=&quot;hljs-keyword&quot;&gt;finally {
                        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;931&quot;&gt;上面代码中最核心的处理之前task的地方是通过runAllTasks方法，我们再来看看runAllTasks方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;932&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;boolean runAllTasks(&lt;span class=&quot;hljs-keyword&quot;&gt;long timeoutNanos) {
        fetchFromScheduledTaskQueue();
        Runnable &lt;span class=&quot;hljs-keyword&quot;&gt;task = pollTask();
        ...
        &lt;span class=&quot;hljs-keyword&quot;&gt;for (;;) {
            safeExecute(&lt;span class=&quot;hljs-keyword&quot;&gt;task);
            ...
            &lt;span class=&quot;hljs-keyword&quot;&gt;task = pollTask();
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (&lt;span class=&quot;hljs-keyword&quot;&gt;task == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
                lastExecutionTime = ScheduledFutureTask.nanoTime();
                &lt;span class=&quot;hljs-keyword&quot;&gt;break;
            }

        }

        afterRunningAllTasks();
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.lastExecutionTime = lastExecutionTime;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;true;
    }
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void safeExecute(Runnable &lt;span class=&quot;hljs-keyword&quot;&gt;task) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;try {
            &lt;span class=&quot;hljs-keyword&quot;&gt;task.run();
        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch (Throwable t) {
            logger.warn(&lt;span class=&quot;hljs-string&quot;&gt;&quot;A task raised an exception. Task: {}&quot;, &lt;span class=&quot;hljs-keyword&quot;&gt;task, t);
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;961&quot;&gt;上段代码通过调用父类AbstractEventExecutor的safeExecute()方法，最终调用到了在之前生成的WriteAndFlushTask的run方法，我们来看一下在WriteAndFlushTask中的代码流程：&lt;/p&gt;
&lt;pre data-source-line=&quot;962&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;void run() {
            &lt;span class=&quot;hljs-keyword&quot;&gt;try {
                &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;989&quot;&gt;上面的代码在WriteAndFlushTask及它的父类中，最终会执行这行代码：ctx.invokeWrite(msg, promise)，又调用回了AbstractChannelHandlerContext(hanlder为StringEncoder)，我们来分析一下：&lt;/p&gt;
&lt;pre data-source-line=&quot;990&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;void invokeWrite(Object msg, ChannelPromise promise) {
        &lt;span class=&quot;hljs-built_in&quot;&gt;if (invokeHandler()) {
            invokeWrite0(msg, promise);
        } &lt;span class=&quot;hljs-built_in&quot;&gt;else {
            System.out.&lt;span class=&quot;hljs-built_in&quot;&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;not invoke write.&quot;);
            &lt;span class=&quot;hljs-built_in&quot;&gt;write(msg, promise);
        }
    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;void invokeWrite0(Object msg, ChannelPromise promise) {
        &lt;span class=&quot;hljs-built_in&quot;&gt;try {
            ((ChannelOutboundHandler) handler()).&lt;span class=&quot;hljs-built_in&quot;&gt;write(&lt;span class=&quot;hljs-keyword&quot;&gt;this, msg, promise);
        } &lt;span class=&quot;hljs-built_in&quot;&gt;catch (Throwable t) {
            notifyOutboundHandlerException(t, promise);
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;1008&quot;&gt;在上面的代码中最终会执行到((ChannelOutboundHandler) handler()).write(this, msg, promise)，也就是StringEncoder的write方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;1009&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
        CodecOutputList &lt;span class=&quot;hljs-keyword&quot;&gt;out = &lt;span class=&quot;hljs-literal&quot;&gt;null;
        &lt;span class=&quot;hljs-keyword&quot;&gt;try {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (acceptOutboundMessage(msg)) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;out = CodecOutputList.newInstance();
                &lt;span class=&quot;hljs-keyword&quot;&gt;@SuppressWarnings(&lt;span class=&quot;hljs-string&quot;&gt;&quot;unchecked&quot;)
                I &lt;span class=&quot;hljs-keyword&quot;&gt;cast = (I) msg;
                &lt;span class=&quot;hljs-keyword&quot;&gt;try {
                    encode(ctx, &lt;span class=&quot;hljs-keyword&quot;&gt;cast, &lt;span class=&quot;hljs-keyword&quot;&gt;out);
                } 
            } 
            ...
        } &lt;span class=&quot;hljs-keyword&quot;&gt;finally {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (&lt;span class=&quot;hljs-keyword&quot;&gt;out != &lt;span class=&quot;hljs-literal&quot;&gt;null) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;int sizeMinusOne = &lt;span class=&quot;hljs-keyword&quot;&gt;out.size() - &lt;span class=&quot;hljs-number&quot;&gt;1;
                &lt;span class=&quot;hljs-keyword&quot;&gt;if (sizeMinusOne == &lt;span class=&quot;hljs-number&quot;&gt;0) {
                    ctx.write(&lt;span class=&quot;hljs-keyword&quot;&gt;out.get(&lt;span class=&quot;hljs-number&quot;&gt;0), promise);
                } 
                ...
            }
        }
    }

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;1034&quot;&gt;上面的代码主要是对string进行编码，然后再调用ctx的write方法，此刻的ctx为StringEncoder对应的context，我们再来分析一下context的write方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;1035&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public ChannelFuture &lt;span class=&quot;hljs-keyword&quot;&gt;write(&lt;span class=&quot;hljs-keyword&quot;&gt;final Object msg, &lt;span class=&quot;hljs-keyword&quot;&gt;final ChannelPromise promise) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (msg == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;throw &lt;span class=&quot;hljs-keyword&quot;&gt;new NullPointerException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;msg&quot;);
        }

        &lt;span class=&quot;hljs-keyword&quot;&gt;try {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (isNotValidPromise(promise, &lt;span class=&quot;hljs-keyword&quot;&gt;true)) {
                ReferenceCountUtil.release(msg);
                &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;1078&quot;&gt;我们又回到了之前分析过的write方法，只不过这次的next的类型为HeadContext，已经是write的最后一个context了，代码最终会执行到next.invokeWrite(m, promise)，我们来继续分析：&lt;/p&gt;
&lt;pre data-source-line=&quot;1079&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;invokeWrite&lt;span class=&quot;hljs-params&quot;&gt;(Object msg, ChannelPromise promise) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if (invokeHandler()) {
            invokeWrite0(msg, promise);
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
            write(msg, promise);
        }
    }
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;invokeWrite0&lt;span class=&quot;hljs-params&quot;&gt;(Object msg, ChannelPromise promise) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;try {
            ((ChannelOutboundHandler) &lt;span class=&quot;hljs-keyword&quot;&gt;handler()).write(&lt;span class=&quot;hljs-keyword&quot;&gt;this, msg, promise);
        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch (Throwable t) {
            notifyOutboundHandlerException(t, promise);
        }
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;1096&quot;&gt;上面的两个方法最终会执行((ChannelOutboundHandler) handler()).write(this, msg, promise)，因为现在的context是HeadContext，那么我们来看看HeadContext的Handler()会是什么？&lt;/p&gt;
&lt;pre data-source-line=&quot;1097&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-function&quot;&gt;ChannelHandler &lt;span class=&quot;hljs-title&quot;&gt;handler&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;this;
    }
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;write&lt;span class=&quot;hljs-params&quot;&gt;(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) &lt;span class=&quot;hljs-keyword&quot;&gt;throws Exception {
        unsafe.write(msg, promise);
    }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;1106&quot;&gt;原来HeadContext的Handler()就是它自己，代码会调用到unsafe的write方法，unsafe的类型为：NioSocketChannelUnsafe，我们再来看看进入到unsafe中的代码：&lt;/p&gt;
&lt;pre data-source-line=&quot;1107&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-keyword&quot;&gt;write(Object msg, ChannelPromise promise) {
            assertEventLoop();
            ChannelOutboundBuffer outboundBuffer = &lt;span class=&quot;hljs-keyword&quot;&gt;this.outboundBuffer;
            ...
            outboundBuffer.addMessage(msg, &lt;span class=&quot;hljs-keyword&quot;&gt;size, promise);
        }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;1115&quot;&gt;上面的代码将msg信息存入到outboundBuffer中，我们之前在研究WriteAndFlushTask的run方法时，最后还有一个flush操作，当将msg信息存入到outbondBuffer后，unsafe中的flush方法会被调用，我们来看一下：&lt;/p&gt;
&lt;pre data-source-line=&quot;1116&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;flush&lt;span class=&quot;hljs-params&quot;&gt;() {
            assertEventLoop();
            ChannelOutboundBuffer outboundBuffer = &lt;span class=&quot;hljs-keyword&quot;&gt;this.outboundBuffer;
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (outboundBuffer == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;return;
            }

            outboundBuffer.addFlush();
            flush0();
        }
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;flush0&lt;span class=&quot;hljs-params&quot;&gt;() {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (inFlush0) {
                &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;1145&quot;&gt;上面的方法，最终会调用此unsafe的doWrite方法：&lt;/p&gt;
&lt;pre data-source-line=&quot;1146&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;void doWrite(ChannelOutboundBuffer &lt;span class=&quot;hljs-keyword&quot;&gt;in) throws Exception {
        SocketChannel ch = javaChannel();
        &lt;span class=&quot;hljs-keyword&quot;&gt;int writeSpinCount = config().getWriteSpinCount();
        &lt;span class=&quot;hljs-keyword&quot;&gt;do {
            &lt;span class=&quot;hljs-keyword&quot;&gt;if (&lt;span class=&quot;hljs-keyword&quot;&gt;in.isEmpty()) {
                &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;1210&quot;&gt;最终代码将由unsafe的doWrite方法来调用jdk的nio相关操作。&lt;/p&gt;
&lt;h2 id=&quot;write流程小结&quot; data-source-line=&quot;1211&quot;&gt;write流程小结：&lt;/h2&gt;
&lt;p data-source-line=&quot;1212&quot;&gt;通过分析netty4的源码及流程，我们总结如下：&lt;/p&gt;
&lt;ul data-source-line=&quot;1213&quot;&gt;&lt;li&gt;netty4中的最终write的线程是channel的worker线程，与read线程为同一个线程；&lt;/li&gt;
&lt;li&gt;每个channel在它的生命周期内，有且只有一个worker线程为它服务；&lt;/li&gt;
&lt;li&gt;write操作的流程正如我们上面总结的顺序：TelnetClient -&amp;gt; AbstractChannel -&amp;gt; DefaultChannelPipeline -&amp;gt; TailContext(AbstractChannelHandlerContext) -&amp;gt; NioEventLoop (SingleThreadEventExecutor) -&amp;gt;NioEventLoop(run方法) -&amp;gt; AbstractEventExecutor(safeExecute方法) -&amp;gt; WriteAndFlushTask(run方法) -&amp;gt; AbstractChannelHandlerContext(hanlder为StringEncoder) -&amp;gt; StringEncoder(write方法) -&amp;gt; HeadContext(invokeWrite方法) -&amp;gt; NioSocketChannelUnsafe(write)；&lt;/li&gt;
&lt;li&gt;下面的时序图详细的总结了netty4里面的write流程&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003073/201904/1003073-20190427142831971-1043864125.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2 id=&quot;netty小结&quot; data-source-line=&quot;1220&quot;&gt;netty小结&lt;/h2&gt;
&lt;p data-source-line=&quot;1221&quot;&gt;在本文中，我们先后分析了：netty服务启动流程、netty的信息流转通道channelPipeline机制、并详细的分析了netty4的write流程。我们现在给本次分享做一个小结：&lt;/p&gt;
&lt;ul data-source-line=&quot;1222&quot;&gt;&lt;li&gt;netty极其简化了nio的编程复杂度；&lt;/li&gt;
&lt;li&gt;bossGroup的线程数设置为1是最好，在netty的eventloop架构下，一个channel只能被同一个thread服务；&lt;/li&gt;
&lt;li&gt;一个channel会有唯一的一个ChannelPipeline，ChannelPipeline的核心是一个双向链表结构。inbound事件从head开始，outbound事件从tail开始，其它的业务context都在head和tail之间，按照顺序处理；&lt;/li&gt;
&lt;li&gt;netty的inbound和outbound事件最终都会在channel的唯一的eventloop架构下按顺序执行；&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 27 Apr 2019 06:34:00 +0000</pubDate>
<dc:creator>【刘光亮】</dc:creator>
<og:description>netty4源码分析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mantu/p/10778674.html</dc:identifier>
</item>
<item>
<title>自学编程的朋友，我想给你们这 5 个建议 - 黄小斜</title>
<link>http://www.cnblogs.com/xll1025/p/10778688.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/10778688.html</guid>
<description>&lt;p&gt;&lt;strong&gt;作者：黄小斜&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章来源：微信公众号【程序员江湖】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阅读本文大概需要 2.8 分钟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;6&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://pic1.zhimg.com/v2-738a3cdd45f1ec99ae1bb8790ab4ffc8_b.jpg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://pic1.zhimg.com/v2-738a3cdd45f1ec99ae1bb8790ab4ffc8_b.jpg&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://pic1.zhimg.com/v2-738a3cdd45f1ec99ae1bb8790ab4ffc8_b.jpg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　很多人都想转行互联网，不管是出于兴趣、行业前景还是薪资的考虑，想要转行互联网的人们必须要面对一个问题，那就是如何自学编程，更确切的说，是如何0基础学编程。&lt;/p&gt;
&lt;p&gt;　　其实我基本上也是0基础自学编程的，大学的时候学的电信专业，对于编程语言只懂得一点皮毛，那些内容，相信大部分人看一些网上的教程也可以掌握了。&lt;/p&gt;
&lt;p&gt;　　作为过来人，想给大家一些建议，不管你是学生想要自学，还是跨界转行，亦或是纯粹当做兴趣爱好，都可以把我的建议作为参考，不会有坏处。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;

&lt;p&gt;　　这句话大家都听过，但我觉得，不管是你想从事哪个行业，想要做的比较好，去比较好的公司，至少要有兴趣，其他的能力、专业水平暂且不谈，如果连兴趣都没有，那么为什么要从0开始去做这个行业，去学这样技术，显然是非常不理智的行为。&lt;/p&gt;
&lt;p&gt;　　有兴趣，才有动力去学习每一样东西，不管是计算机基础、编程语言、算法等等，兴趣是原动力，没有了它，你一定坚持不了多久。&lt;/p&gt;
&lt;p&gt;　　可能很多人觉得兴趣不一定最重要，可以靠努力、靠坚持、靠意志力去学习，但是，那样又有什么意义呢，你愿意这么不快乐地去学习么，你的坚持又能持续多久呢。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://pic2.zhimg.com/v2-99c8a245c215f0271ab1b4d7eaf01545_b.jpg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://pic2.zhimg.com/v2-99c8a245c215f0271ab1b4d7eaf01545_b.jpg&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://pic2.zhimg.com/v2-99c8a245c215f0271ab1b4d7eaf01545_b.jpg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;

&lt;p&gt;　　学习编程这件事，需要从长计议，怎么说呢，就是需要花很长时间，绝对不是一蹴而就的，你可以说你花3个月培训学会了一门语言，以及相关的项目实战技能。&lt;/p&gt;
&lt;p&gt;　　但是在我看来，这也只是掌握了一项技能而已，学习编程的路还有很长，不管是你自己做项目，还是参加工作，学习编程都是一件需要持续做的事情。&lt;/p&gt;
&lt;p&gt;　　曾经有人提出10000小时理论，就是你在一个领域投入至少1w个小时，就可以成为该领域的专家，学习编程也不例外。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;4&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://pic1.zhimg.com/v2-827633c3b31037aaeb50cab6bfbf510c_b.jpg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://pic1.zhimg.com/v2-827633c3b31037aaeb50cab6bfbf510c_b.jpg&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://pic1.zhimg.com/v2-827633c3b31037aaeb50cab6bfbf510c_b.jpg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;

&lt;p&gt;　　很多新手都是初生牛犊不怕虎，因为对编程领域不了解，便不假思索地定了一些很高的目标，比如想进大厂，想做有复杂度的项目，想短时间学习一门语言并找到工作。&lt;/p&gt;
&lt;p&gt;　　理想很丰满，现实很骨感，你可能低估了入行的难度，并不是只要有心，就可以很快地完成学习过程的。&lt;/p&gt;
&lt;p&gt;　　一定要先易后难，一步一来，比如先搞懂语法，尝试写一写demo，接着了解高级特效，实现高级特性，然后自己脱离教程写一些代码，最后做项目，大概是这样的一个逻辑。&lt;/p&gt;
&lt;p&gt;　　别看我说的简单，其实对于新人来说，要完成这几道工序并不容易，别看学点基础语法没什么难度，但是真的要上手实践，可能会遇到很多问题，比如环境配置，IDE安装和使用，这些搞定之后，代码语法错误、编译错误、执行错误，对于新手来说都是很难解决的，如果不借助外力，基本上是无从下手的。&lt;/p&gt;
&lt;p&gt;　　所以，学习编程，没有你想象的那么简单。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://pic2.zhimg.com/v2-2be37afb7818884b6bd0fcab158fab11_b.jpg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://pic2.zhimg.com/v2-2be37afb7818884b6bd0fcab158fab11_b.jpg&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://pic2.zhimg.com/v2-2be37afb7818884b6bd0fcab158fab11_b.jpg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;

&lt;p&gt;　　就像我刚才所说，如果在学习过程中遇到困难，可能真的很难独立解决，这种时候应该怎么办呢，如果没有人指导你，那么就只能够硬着头皮自己解决了，解决的方法无非就是百度、谷歌，到网上看看有没有人遇到和你一样的问题。&lt;/p&gt;
&lt;p&gt;　　如果你觉得这样子效率很低，那也可以找一些基础方面的书籍先看看，了解基本的编程知识，或者看一些网课，加深对知识的理解，然后再去尝试各种代码实践，可能会让你更加顺利一些。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://pic4.zhimg.com/v2-5e949370c2b7fa16e454b6bfdaa63ba7_b.jpg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://pic4.zhimg.com/v2-5e949370c2b7fa16e454b6bfdaa63ba7_b.jpg&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://pic4.zhimg.com/v2-5e949370c2b7fa16e454b6bfdaa63ba7_b.jpg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;

&lt;p&gt;　　很多人觉得学习编程只需要刚才我说的那几步，学习语法、写简单demo，然后学习高级特性，最后着手做项目就可以了。但是这只是最初级的程序员，离开这门语言，他们可能就什么都不剩下了。&lt;/p&gt;
&lt;p&gt;　　没有计算机基础的支撑，他们不明白计算机网络的原理，不知道为什么要考虑网络编程，不明白为什么要考虑DNS、负载均衡，不知道操作系统的原理，就不能够理解服务器出问题时的根本原因，无法排查，不懂得数据结构和算法，就不明白为什么有的程序是这么写的，有的集合类是这么设计的。&lt;/p&gt;
&lt;p&gt;　　重视基础，是每一个程序员都要做到的一点，离开基础，其他的东西都是空中楼阁，基础不扎实，你连谈论技术时也不会有底气，更别说谈架构、谈业务场景了。&lt;/p&gt;
&lt;p&gt;　　综上，都是我想给那些自学编程的人的一些建议，自学编程不易，千万要想清楚了再开始，特别是想要转行，做程序员，以此谋生的那些人，一定要慎重。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://pic3.zhimg.com/v2-f61122c97285227e47f909d9a357ba66_b.jpg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://pic3.zhimg.com/v2-f61122c97285227e47f909d9a357ba66_b.jpg&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://pic3.zhimg.com/v2-f61122c97285227e47f909d9a357ba66_b.jpg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;文能码字，武能coding，是我黄小斜，不是黄老邪噢。&lt;/p&gt;

</description>
<pubDate>Sat, 27 Apr 2019 06:32:00 +0000</pubDate>
<dc:creator>黄小斜</dc:creator>
<og:description>作者：黄小斜 文章来源：微信公众号【程序员江湖】 阅读本文大概需要 2.8 分钟。 ​ 很多人都想转行互联网，不管是出于兴趣、行业前景还是薪资的考虑，想要转行互联网的人们必须要面对一个问题，那就是如何</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xll1025/p/10778688.html</dc:identifier>
</item>
<item>
<title>头条笔试：母牛生产 - JeannieLi</title>
<link>http://www.cnblogs.com/xdliyin/p/10778583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xdliyin/p/10778583.html</guid>
<description>&lt;p&gt;母牛从3-7岁初每年会生产1头小母牛，10岁后死亡（10岁仍然存活），假设初始有1头刚出生的母牛，请问第n年有多少头母牛？（年从第一年开始计数）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1298601/201904/1298601-20190427141747520-1008674855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;注： 在没有任何思路的情况下，可以先暴力分析，顺着题意将给出的示例推导出来，然后再从中观察规律，找到更为便捷的方法；&lt;/p&gt;

&lt;p&gt;1. 先暴力分析：从第一年开始，计算每年的母牛个数；&lt;/p&gt;
&lt;p&gt;基本思路：以最开始的母牛为基准进行分析，分析每年它生产的孩子的个数，最后加1 就是每年牛的个数；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1298601/201904/1298601-20190427141328449-1952105133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1298601/201904/1298601-20190427141337768-327890452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;观察上述分析结果，我们会发现：有很多重复地方，即母牛这题含有重复子结构，最常用的方法就是：用数组变量，将重复的地方记录下来。&lt;/p&gt;
&lt;p&gt;（1）sum：记录每次的求和部分&lt;/p&gt;
&lt;p&gt;（2）opt[ i ]：记录第 i 年母牛的个数， opt[ -1] ：表示最终的输出结果&lt;/p&gt;
&lt;p&gt;（3）一次循环遍历，记录 sum 和 opt[ i ]，时间复杂度：O(n)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Python代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 母牛生产&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; sys.stdin:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     n =&lt;span&gt; int(line)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; n &amp;lt; 3&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         opt = [0 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(n + 1&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         opt[0] = -1
&lt;span&gt;10&lt;/span&gt;         opt[1] = 1
&lt;span&gt;11&lt;/span&gt;         opt[2] = 1
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         sum =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3, n+1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; i &amp;gt;=  3 &lt;span&gt;and&lt;/span&gt; i &amp;lt;=7&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 sum = sum + opt[i - 2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 opt[i] = sum + 1
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;elif&lt;/span&gt; i &amp;gt;= 8 &lt;span&gt;and&lt;/span&gt; i &amp;lt;= 10&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 sum = sum - opt[i-7] + opt[i-2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 opt[i] = sum + 1
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 sum = sum - opt[i-7] + opt[i-2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 opt[i] =&lt;span&gt; sum
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(opt[-1])
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 27 Apr 2019 06:09:00 +0000</pubDate>
<dc:creator>JeannieLi</dc:creator>
<og:description>1. 母牛生产 母牛从3-7岁初每年会生产1头小母牛，10岁后死亡（10岁仍然存活），假设初始有1头刚出生的母牛，请问第n年有多少头母牛？（年从第一年开始计数） 思路： 注： 在没有任何思路的情况下，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xdliyin/p/10778583.html</dc:identifier>
</item>
<item>
<title>『建议』给博客园官方的一个意见 - InkFx</title>
<link>http://www.cnblogs.com/shuxiaolong/p/20190427_1352.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuxiaolong/p/20190427_1352.html</guid>
<description>&lt;p&gt;亲爱的博客园官方：&lt;/p&gt;

&lt;p&gt;    您好。&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;先直接说建议吧：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;&lt;span&gt;希望博客园能够有自己的 MVP认证 机制。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;    原因如下：&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;技术人坚持写博客可以提高“身价”，获得荣誉和金钱&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    我是 博客园的 InkFx， 2011 年我就加入了 博客园 —— 并且将其作为自己的 第一技术博客。&lt;/p&gt;
&lt;p&gt;    在对外提到博客园时，我每次都会加上 “博客园（中国最大的程序员论坛）” 这样的字眼。&lt;/p&gt;
&lt;p&gt;    拍马屁只是其次 —— 我的目的很简单： &lt;strong&gt;&lt;span&gt;博客园官方 和 各个技术博主 其实是相互依存 的关系 —— 博客园知名度提高，我们这些博主的身价 也会水涨船高。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;     “身价” 对 我们这些博主有啥用？&lt;/p&gt;
&lt;p&gt;    往大了说，聚拢人气，聚集生态 —— 成为 “XX之父”，成为 “XX奠基人” （这种大成的结果就是：学成文武艺，货卖帝王家 —— 直接入选 “国家千人、百人计划” 为国效力 ...）。&lt;/p&gt;
&lt;p&gt;    往小了说，聚集粉丝，多上几次头条 —— 自己的面试简历 多几个链接 （我曾经在博客园上过头条，引起过轰动），面试官自当另眼相待，工资也会高个几千。&lt;/p&gt;

&lt;p&gt;     2013年年末，我在老家闭关了 6个月。&lt;/p&gt;
&lt;p&gt;     2014年，我在博客园 发表了几篇文章，连上了好几次头条，在博客园首页直接呆了 30天。&lt;/p&gt;
&lt;p&gt;     然后我就开始面试：（简历里面非常嚣张的写着 “目前已在博客园首页头条推荐呆了20天”） —— 那段时间我面试，工资相比2013年辞职时，直接翻倍。&lt;/p&gt;


&lt;p&gt;    是的，这就是我在博客园写博客的 “私心” —— 如果我写几篇博客，就能让自己面试 涨 30% ~ 100% 的工资，我当然愿意坚持写博客呀！&lt;/p&gt;
&lt;p&gt;    事实上，我很忙，很少有时间写 重量级头条博文，平时都只是一些小打小闹。&lt;/p&gt;
&lt;p&gt;    基本上，凡是我上头条的文章，都是我在面试的时期 写的：一方面 那时候的自己有时间写博客，另一方面 是为了面试加分。&lt;/p&gt;
&lt;p&gt;    我也懒得给自己戴上 “为网友免费解答” “乐于助人” “开源达人” 的高帽 —— 我就是一个俗人，我写博客、开源技术、上头条 只是为了 &lt;strong&gt;面试加工资&lt;/strong&gt;。 &lt;/p&gt;




&lt;p&gt;&lt;strong&gt;&lt;span&gt;博客园的推荐机制可以助力园友 提高身价&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    我记得一年前，博客园 新晋级了几个 “微软MVP” （是博客园推荐给微软官方的，在这里要感谢博客园为博友付出的努力）。&lt;/p&gt;
&lt;p&gt;    但奇怪的是：这些新秀成为 微软MVP 之后，反倒写博客变少了。&lt;/p&gt;
&lt;p&gt;    原因或许和我一样：有了“身价”，面试工资直接翻倍，工作中被安排的工作多了 —— 自然也就没时间写博客了。&lt;/p&gt;
&lt;p&gt;    —— 从这里我们就能看出博客园的力量： &lt;strong&gt;&lt;span&gt;博客园的 “头条推荐”，“微软MVP推荐”，是可以让各位博友 工资翻倍的！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;&lt;span&gt;在博客园获得的荣誉，也会有尴尬的地方&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    但是，我也挺替一些其他博友可惜的。&lt;/p&gt;
&lt;p&gt;    比如，博客园里面 有一些 嵌入式、单片机 大神 —— 他们自己设计电路，让我们看到很多耳目一新的创意，他们也上过好多次 博客园的头条。&lt;/p&gt;
&lt;p&gt;    他们的工资也因此翻倍了不少。&lt;/p&gt;
&lt;p&gt;    但 &lt;strong&gt;“微软MVP” &lt;/strong&gt;永远和他们无缘 （因为他们用的不是微软的技术）。&lt;/p&gt;
&lt;p&gt;    他们最大的荣誉就是 &lt;strong&gt;“十几次博客园头条推荐”  &lt;/strong&gt;—— 随着时间的推移，这些零碎的荣誉 就会 逐渐消散。&lt;/p&gt;

&lt;p&gt;    而且，这种&lt;strong&gt; “零碎的荣誉” &lt;/strong&gt;还会着他们带来新的麻烦：&lt;/p&gt;
&lt;p&gt;         面试官：你说你上了十几次头条，你来讲讲你的这篇文章的设计原理和思想。&lt;/p&gt;
&lt;p&gt;         面试者：额 ~ 这篇文章过去6年了，我也只能讲个大概，先让我想想当时的思路 ...&lt;/p&gt;
&lt;p&gt;         面试官：我就知道你是抄袭别人的技术，工资我们只能给你这么多 ~&lt;/p&gt;

&lt;p&gt;    这种尴尬的处境，我之前就遇到过&lt;/p&gt;

&lt;p&gt;    当时还真有一个面试官 研究了我的框架，问我：如何扩展一个  &quot;'AAA' IN ('AAA', 'BBB')&quot; 的 IN 表达式计算插件。&lt;/p&gt;
&lt;p&gt;    当时，还真把我卡住了，那场面试就被压了工资 （那场面试从 下午2点到晚上9点，总计 7个小时，最后面试官死守他的工资线，我也就烦了，没有入职）&lt;/p&gt;





&lt;p&gt;&lt;strong&gt;&lt;span&gt;希望博客源 推出自己的 “MVP” 机制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    当年，刘备入主西川，手下大臣纷纷希望刘备 进位 “汉中王”，之后 还希望刘备 “称帝”。&lt;/p&gt;
&lt;p&gt;    刘备不同意，诸葛亮甚至装病：“手下大臣，跟随主公这么久，不就为了攀龙附凤么？！ —— 主公不进位，这些大臣恐怕就要寒心，离心离德 ...”&lt;/p&gt;

&lt;p&gt;    回到最开始的那句 “&lt;strong&gt;&lt;span&gt;博客园官方 和 各个技术博主 其实是相互依存 的关系 —— 博客园知名度提高，我们这些博主的身价 也会水涨船高。&lt;/span&gt;&lt;/strong&gt;” &lt;/p&gt;
&lt;p&gt;    如果各个博主，在博客园 永远只能得到 “零碎的荣誉” —— 而得不到类似 “微软MVP” 那样，固化几年，固化某个专业 的 “固化的荣誉” —— 恐怕，博客园园友 迟早离心离德，离开博客园。&lt;/p&gt;

&lt;p&gt;   &lt;span&gt; “博客园每年都会推荐园友成为 “微软MVP” 呀？！，为什么 还需要 “博客园MVP” ？？”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &amp;gt; 微软MVP 只有 微软的技术适用，博客园里面 其他技术领域的大神 —— 永远都得不到这种固化荣誉。&lt;/p&gt;
&lt;p&gt;    &amp;gt; 退一万不说：某些博主用的是 微软的技术，具备成为 “微软MVP” 的条件 —— 但特朗普先生有个政策：美国不欢迎小粉红。&lt;/p&gt;
&lt;p&gt;       这就更僵了：你想成为 微软MVP，甚至你还得 顺着一点 特朗普，跪舔一下美国（至少宣传一下 要与美国亲善 的口号）。不然 微软MVP的露脸活动 —— 你永远都参加不了。&lt;/p&gt;
&lt;p&gt;       —— 博客园作为中国最大的技术论坛，我们这些园友 不想聊政治、也不想被政治掣肘 （但 “微软MVP” 这种荣誉，确实有他 尴尬的地方）。&lt;/p&gt;

&lt;p&gt;    &lt;span&gt;“博客园MVP 需要给予哪些奖励？这些奖励也是需要资金的呀，博客园资金不够啊！”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &amp;gt; 资金问题不难，Dota2 每年2000W 的资金，都是网友捐款的 —— 博客园也可以在每年 评选MVP 期间，开放 捐赠机制。&lt;/p&gt;
&lt;p&gt;    &amp;gt; 微软MVP 不也只有一个奖杯、一份 CSDN文档 作为奖励么 —— 成本也就一个 奖杯的钱 而已 &lt;/p&gt;
&lt;p&gt;    &amp;gt; 同理，博客园MVP 我们不需要什么金钱奖励，一个奖杯造型可以摆在办公桌上就很知足了。&lt;/p&gt;
&lt;p&gt;    &amp;gt; 就像你小时候满墙的奖状，几张纸不值钱，但每当有客人来时，你就忍不住想要 “不经意” 的带客人到 贴满奖状的房间。  &lt;/p&gt;
&lt;p&gt;    &amp;gt; 一个奖杯实物，不值几个钱，但能固化一种荣誉 —— 摆在办公桌上，你和你的公司 就忍不住想要 “不经意” 的让到公司视察的 甲方看到。&lt;/p&gt;

&lt;p&gt;    &lt;span&gt;“博客园MVP 有这个含金量么？博客园MVP 根本不是 微软MVP 的对手啊！”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &amp;gt; 还记得之前 的 “红芯浏览器” 事件么！&lt;/p&gt;
&lt;p&gt;       为什么这个人 套个 Chrome 的皮肤就能出名？  —— 因为他是 “国家千人计划” 成员。&lt;/p&gt;
&lt;p&gt;       为什么 “国家千人计划” 会入选一个 浪得虚名之人？ —— 因为他是 “微软MVP”。&lt;/p&gt;
&lt;p&gt;       不是郭嘉 不重用人才，而是 有才之人 如果没有 “固化的荣誉” —— 郭嘉很难把这些人找出来。&lt;/p&gt;

&lt;p&gt;    &amp;gt; 博客园MVP 不正是 这样一种 推选机制么！&lt;/p&gt;
&lt;p&gt;       郭嘉需要人才了，就来 “博客园MVP”  名单中 筛选一下 —— 而不是跑到国外的 “微软MVP” “Oracle MVP” 名单 中去筛选。   &lt;/p&gt;
&lt;p&gt;       这样，相当于 博客园MVP 可以先替 郭嘉人才选拔 把一层关 —— 而不是 让 国外的机构 替中国的人才选拔 把关。&lt;/p&gt;
&lt;p&gt;       —— 这样，对所有 有才华的技术人 不也是一件好事。&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;em&gt;个人愚见，仅当参考，如有见识不足而导致的建议错误，望见谅。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;



&lt;div readability=&quot;6.5380710659898&quot;&gt;                                                                                            小Ink   InkFx （&lt;a href=&quot;https://mail.qq.com/InkFx%20%EF%BC%88https://www.cnblogs.com/shuxiaolong/&quot;&gt;https://www.cnblogs.com/shuxiaolong/&lt;/a&gt;）&lt;/div&gt;
</description>
<pubDate>Sat, 27 Apr 2019 05:53:00 +0000</pubDate>
<dc:creator>InkFx</dc:creator>
<og:description>亲爱的博客园官方： 您好。 先直接说建议吧： 希望博客园能够有自己的 MVP认证 机制。 原因如下： 技术人坚持写博客可以提高“身价”，获得荣誉和金钱 我是 博客园的 InkFx， 2011</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shuxiaolong/p/20190427_1352.html</dc:identifier>
</item>
<item>
<title>迭代器 - 咸鱼Chen</title>
<link>http://www.cnblogs.com/nickchen121/p/10778506.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nickchen121/p/10778506.html</guid>
<description>&lt;p&gt;迭代器：迭代的工具。迭代是更新换代，如你爷爷生了你爹，你爹生了你，迭代也可以说成是重复，并且但每一次的重复都是基于上一次的结果来的。如计算机中的迭代开发，就是基于软件的上一个版本更新。以下代码就不是迭代，它只是单纯的重复&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;while True:
    print('*'*10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/nickchen121/1447696/o_49%E8%BF%AD%E4%BB%A3%E5%99%A8-%E5%A8%83.jpg&quot; alt=&quot;49迭代器-娃.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;python中一切皆对象，如&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;x = 1
name = 'nick'
lis = [1, 2]
tup = (1, 2)
dic = {'name': 'nick'}
s1 = {'a', 'b'}


def func():
    pass


f = open('49w.txt', 'w', encoding='utf-8)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于这一切的对象中，但凡有&lt;code&gt;__iter__&lt;/code&gt;方法的对象，都是可迭代对象。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# x = 1.__iter__  # SyntaxError: invalid syntax

# 以下都是可迭代的对象

name = 'nick'.__iter__
lis = [1, 2].__iter__
tup = (1, 2).__iter__
dic = {'name': 'nick'}.__iter__
s1 = {'a', 'b'}.__iter__
f = open('49w.txt', 'w', encoding='utf-8')
f.__iter__
f.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;可迭代的对象：Python内置str、list、tuple、dict、set、file都是可迭代对象。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;内置有&lt;code&gt;__iter__&lt;/code&gt;方法的都叫可迭代的对象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/nickchen121/1447696/o_49%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%A3%85%E9%80%BC.jpg&quot; alt=&quot;49迭代器-装逼.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;只有字符串和列表都是依赖索引取值的，而其他的可迭代对象都是无法依赖索引取值的。因此我们得找到一个方法能让其他的可迭代对象不依赖索引取值。&lt;/p&gt;
&lt;p&gt;在找到该方法前，首先我们给出迭代器对象的概念：可迭代的对象执行&lt;code&gt;__iter__&lt;/code&gt;方法得到的返回值。并且可迭代对象会有一个&lt;code&gt;__next__&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 不依赖索引的数据类型迭代取值
dic = {'a': 1, 'b': 2, 'c': 3}
iter_dic = dic.__iter__()
print(iter_dic.__next__())
print(iter_dic.__next__())
print(iter_dic.__next__())
# print(iter_dic.__next__())  # StopIteration:&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;a
b
c&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 依赖索引的数据类型迭代取值
lis = [1, 2, 3]
iter_lis = lis.__iter__()
print(iter_lis.__next__())
print(iter_lis.__next__())
print(iter_lis.__next__())
# print(iter_lis.__next__())  # StopIteration:&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;1
2
3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述的方法是非常繁琐的，我们可以使用while循环精简下。其中使用的&lt;code&gt;try...except...&lt;/code&gt;为异常处理模块，以后会详细讲解。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;s = 'hello'
iter_s = s.__iter__()

while True:
    try:
        print(iter_s.__next__())
    except StopIteration:
        break&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;h
e
l
l
o&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;迭代器对象：执行可迭代对象的&lt;code&gt;__iter__&lt;/code&gt;方法，拿到的返回值就是迭代器对象。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;内置&lt;code&gt;__next__&lt;/code&gt;方法，执行该方法会拿到迭代器对象中的一个值&lt;/li&gt;
&lt;li&gt;内置有&lt;code&gt;__iter__&lt;/code&gt;方法，执行该方法会拿到迭代器本身&lt;/li&gt;
&lt;li&gt;文件本身就是迭代器对象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;取值麻烦，只能一个一个取，并且只能往后取，值取了就没了&lt;/li&gt;
&lt;li&gt;无法使用len()方法获取长度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;for循环称为迭代器循环，in后必须是可迭代的对象。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;lis = [1, 2, 3]
for i in lis:
    print(i)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;1
2
3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为迭代器使用&lt;code&gt;__iter__&lt;/code&gt;后还是迭代器本身，因此for循环不用考虑in后的对象是可迭代对象还是迭代器对象。&lt;/p&gt;
&lt;p&gt;由于对可迭代对象使用&lt;code&gt;__iter__&lt;/code&gt;方法后变成一个迭代器对象，这个迭代器对象只是占用了一小块内存空间，他只有使用&lt;code&gt;__next__&lt;/code&gt;后才会吐出一个一个值。如&lt;code&gt;lis = [1,2,3,4,5,...]&lt;/code&gt;相当于一个一个鸡蛋，而&lt;code&gt;lis = [1,2,3,4,5,...].__iter__&lt;/code&gt;相当于一只老母鸡，如果你需要蛋，只需要&lt;code&gt;__next__&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;Python2中&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(range(10))  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Python3中&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(range(10))  # range(0, 10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/nickchen121/1447696/o_49%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%80%81%E6%AF%8D%E9%B8%A1.jpg&quot; alt=&quot;49迭代器-老母鸡.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Apr 2019 05:50:00 +0000</pubDate>
<dc:creator>咸鱼Chen</dc:creator>
<og:description>[TOC] 迭代器：迭代的工具。迭代是更新换代，如你爷爷生了你爹，你爹生了你，迭代也可以说成是重复，并且但每一次的重复都是基于上一次的结果来的。如计算机中的迭代开发，就是基于软件的上一个版本更新。以下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nickchen121/p/10778506.html</dc:identifier>
</item>
<item>
<title>线性表概述及单链表的Java实现 - 帅气陈吃苹果</title>
<link>http://www.cnblogs.com/sqchen/p/10778472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sqchen/p/10778472.html</guid>
<description>&lt;h4 id=&quot;一线性表概述&quot;&gt;一、线性表概述&lt;/h4&gt;
&lt;p&gt;线性表是指一组数据元素之间具有线性关系的元素序列，它表现为：除第一个元素没有直接前驱元素、最后一个元素没有直接后继元素外，其余所有元素都有且仅有一个直接前驱元素和直接后继元素。&lt;/p&gt;
&lt;p&gt;根据存储结构的不同，线性表可以分为顺序存储和链式存储。&lt;/p&gt;
&lt;h5 id=&quot;顺序存储&quot;&gt;1、顺序存储&lt;/h5&gt;
&lt;p&gt;顺序存储结构是指用一段地址连续的存储单元依次存储线性表的数据元素。&lt;/p&gt;
&lt;p&gt;数组就是采用顺序存储结构来存储的，数组元素的保存和读取操作的时间复杂度都是&lt;code&gt;O(1)&lt;/code&gt;，而插入和删除操作的时间复杂度为&lt;code&gt;O(n)&lt;/code&gt;，其优缺点如下：&lt;/p&gt;
&lt;table readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;快速存取，时间复杂度O(1)&lt;/td&gt;
&lt;td&gt;插入、删除时，时间复杂度较高为，O(n)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;无需为表示元素之间的逻辑关系而增加额外的存储空间&lt;/td&gt;
&lt;td&gt;存储空间固定，不易扩展，容易造成空间的浪费&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;h5 id=&quot;链式存储&quot;&gt;2、链式存储&lt;/h5&gt;
&lt;p&gt;链式存储是指数据元素在内存空间中的存储地址可以是不连续的，元素之间的逻辑关系通过其附带的指示信息来进行关联。&lt;/p&gt;
&lt;p&gt;单链表、双向链表、循环链表等都是采用链式存储结构进行存储的。&lt;/p&gt;
&lt;p&gt;对于单链表来说，单个结点分为数据域和指针域，指针域附带的指示信息是下一个结点的存储地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.nowamagic.net/librarys/images/201205/2012_05_04_03.jpg&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单链表元素的读取、插入和删除的时间复杂度都是&lt;code&gt;O(n)&lt;/code&gt;，在插入和删除的操作上，如果我们不知道所要操作结点的指针，那么相比顺序存储结构的数组没有优势，在知道要操作结点的指针的情况下，对于插入或删除越频繁，单链表的效率优势就越明显。&lt;/p&gt;
&lt;p&gt;比如插入10个元素，对于数组来说，每插入一个元素都要移动n-1个结点，每次的时间复杂度都是O(n)，而对于单链表来说，只需要在第一次插入时找到目标位置结点的指针，后续插入都只需要通过移动指针来完成，时间复杂度为&lt;code&gt;O(1)&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;二单链表的java实现&quot;&gt;二、单链表的Java实现&lt;/h4&gt;
&lt;h5 id=&quot;定义单链表的存储结构&quot;&gt;1、定义单链表的存储结构&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public class Node&amp;lt;E&amp;gt; {
    E element;
    Node next;

    Node() {
    }

    Node(E e) {
        this.element = e;
        this.next = null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个Node结点包含两个属性，&lt;code&gt;E element&lt;/code&gt;为存储的数据，指定为泛型；&lt;code&gt;Node next&lt;/code&gt;为逻辑上的下一个结点的存储地址。&lt;/p&gt;
&lt;h5 id=&quot;定义操作接口&quot;&gt;2、定义操作接口&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public interface Collection&amp;lt;E&amp;gt; {

    void add(E e);

    void insert( E e, int index);

    void delete(int index);

    E get(int index);

    void modify( E e,int index);

    boolean isEmpty();

    int size();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为集合、列表类操作定义一个包含公有行为的接口。&lt;/p&gt;
&lt;h5 id=&quot;实现单链表&quot;&gt;3、实现单链表&lt;/h5&gt;
&lt;p&gt;单链表的插入和删除操作可以抽象成两个步骤：&lt;/p&gt;
&lt;p&gt;（1）找到目标结点&lt;/p&gt;
&lt;p&gt;通过头节点进行遍历，直到找到目标结点；&lt;/p&gt;
&lt;p&gt;（2）插入或删除；&lt;/p&gt;
&lt;p&gt;插入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//front为index - 1结点，即要插入位置的前一个结点
node.next = front.next;
front.next = node;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//front为index - 1结点，即要删除位置的前一个结点
node = front.next;
front.next = node.next;
//释放node结点
node = null;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;单链表完整实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LinkedList&amp;lt;E&amp;gt; implements Collection&amp;lt;E&amp;gt; {

    /**
     * 头指针
     */
    private Node&amp;lt;E&amp;gt; head;

    /**
     * 尾指针
     */
    private Node&amp;lt;E&amp;gt; tail;

    private int size;

    public LinkedList() {
        //初始化时创建空的头指针和尾指针，并指向同一个节点，后续增加元素时，尾指针后移，但头指针一直不变
        head = new Node&amp;lt;E&amp;gt;();
        tail = head;
        size = 0;
    }

    @Override
    public void add(E e) {
        Node node = new Node&amp;lt;E&amp;gt;(e);
        //设置尾指针的下一个节点为node
        tail.next = node;
        //设置node为新的尾指针
        tail = node;
        //长度+1
        size++;
    }

    @Override
    public void insert(E e, int index) {
        verifyIndex(index, size);
        Node node = new Node&amp;lt;E&amp;gt;(e);
        //先遍历找到index-1结点，然后在index-1结点插入，复杂度O(n)
        int i = 0;
        //index - 1结点
        Node front = head;
        while (i &amp;lt; index) {
            front = front.next;
            i++;
        }
        node.next = front.next;
        front.next = node;
        size++;
        System.out.println(this.toString());
    }

    @Override
    public void delete(int index) {
        verifyIndex(index, size - 1);
        //找到index-1节点
        int i = 0;
        Node front = head;
        while (i &amp;lt; index) {
            front = front.next;
            i++;
        }
        Node target = front.next;
        front.next = target.next;
        target = null;
        size--;
        System.out.println(this.toString());
    }

    @Override
    public E get(int index) {
        verifyIndex(index, size - 1);
        Node node = head;
        int i = 0;
        while (i &amp;lt;= index) {
            node = node.next;
            i++;
        }
        return (E) node.element;
    }

    @Override
    public void modify(E e, int index) {
        verifyIndex(index, size - 1);
        Node node = head;
        int i = 0;
        while (i &amp;lt;= index) {
            node = node.next;
            i++;
        }
        node.element = e;
        System.out.println(this.toString());
    }

    @Override
    public boolean isEmpty() {
        return size &amp;lt;= 0;
    }

    @Override
    public int size() {
        return 0;
    }

    /**
     * 判断操作的索引是否合法，
     * @param index
     * @param end   右边界，插入时允许在末尾插入，即end = size
     * @return
     */
    private void verifyIndex(int index, int end) {
        if (index &amp;lt; 0 || index &amp;gt; end) {
            throw new IndexOutOfBoundsException(&quot;invalid index for LinkedList：&quot; + this.toString());
        }
    }

    @Override
    public String toString() {
        Node node = head;
        StringBuilder stringBuilder = new StringBuilder();
        while (node.next != null) {
            node = node.next;
            stringBuilder.append(node.element + &quot; &quot;);
        }
        return stringBuilder.toString();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/AmazingChen/Algorithm&quot;&gt;Github下载地址&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Apr 2019 05:34:00 +0000</pubDate>
<dc:creator>帅气陈吃苹果</dc:creator>
<og:description>一、线性表概述 线性表是指一组数据元素之间具有线性关系的元素序列，它表现为：除第一个元素没有直接前驱元素、最后一个元素没有直接后继元素外，其余所有元素都有且仅有一个直接前驱元素和直接后继元素。 根据存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sqchen/p/10778472.html</dc:identifier>
</item>
<item>
<title>STM32学习笔记（二）：GPIO口工作原理 - Geeksongs</title>
<link>http://www.cnblogs.com/geeksongs/p/10778429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geeksongs/p/10778429.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;STM32每个IO口具有7个寄存器来控制，每个IO口都可以自由进行编程控制，我们编程实际上控制的是通过控制那7个寄存器来控制我们的IO口，我们可以通过编程控制IO口，把IO口配置成如下八种模式：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1、输入浮空&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2、输入上拉&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;3、输入下拉&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;4、模拟输入&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;5、开漏输出&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;6、推挽输出&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;7、推挽式复用功能&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;8、开漏复用功能&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每个IO口所对应的7个寄存器分别是：&lt;/p&gt;
&lt;p&gt;1.CRL和CRH：均为32位寄存器&lt;/p&gt;
&lt;p&gt;2.IDR和ODR：均为32位寄存器，但是只用到了低16位&lt;/p&gt;
&lt;p&gt;3.BRR：16位寄存器，用于复位&lt;/p&gt;
&lt;p&gt;4.LCKR：32位，锁存寄存器&lt;/p&gt;

&lt;p&gt;下面是STM32的端口配置表17，来自于《STM32中文参考手册V10》：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201904/1363478-20190427125612188-1616261500.png&quot; alt=&quot;&quot; width=&quot;667&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以及表18，输出模式位：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201904/1363478-20190427125717529-2115433688.png&quot; alt=&quot;&quot; width=&quot;477&quot; height=&quot;168&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;一.寄存器CRL和CRH&lt;/h2&gt;
&lt;p&gt;接下来我们看看端口低配置寄存器 &lt;span&gt;&lt;strong&gt;CRL&lt;/strong&gt;&lt;/span&gt; 的描述，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201904/1363478-20190427125839613-1813378584.png&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;477&quot;/&gt;&lt;/p&gt;

&lt;p&gt;CRH 的作用和 CRL 完全一样，只是 CRL 控制的是低 8 位输出口，而 CRH 控制的是高 8位输出口。&lt;/p&gt;
&lt;p&gt;在固件库开发中，操作寄存器 CRH 和 CRL 来配置 IO 口的&lt;span&gt;&lt;strong&gt;模式和速度&lt;/strong&gt;&lt;/span&gt;是通过 GPIO 初始化函数完成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)；
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个参数是用来指定 GPIO，取值范围为 GPIOA~GPIOG。&lt;br/&gt;第二个参数为初始化参数结构体指针，结构体类型为 GPIO_InitTypeDef&lt;/p&gt;
&lt;p&gt;初始化 GPIO 的常用格式是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;GPIO_InitTypeDef GPIO_InitStructure;
GPIO_InitStructure.GPIO_Pin &lt;/span&gt;= GPIO_Pin_5;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;LED0--&amp;gt;PB.5 端口配置&lt;/span&gt;
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;推挽输出&lt;/span&gt;
GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;速度 50MHz&lt;/span&gt;
GPIO_Init(GPIOB, &amp;amp;GPIO_InitStructure);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据设定参数配置 GPIO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IO 口速度设置，有三个可选值，在 MDK 中同样是通过枚举类型定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;enum&lt;/span&gt;&lt;span&gt;
{
GPIO_Speed_10MHz &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
GPIO_Speed_2MHz,
GPIO_Speed_50MHz
}GPIOSpeed_TypeDef;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模式则有8个可选.在MDK当中的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;enum&lt;/span&gt;&lt;span&gt;
{ GPIO_Mode_AIN &lt;/span&gt;= &lt;span&gt;0x0&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟输入&lt;/span&gt;
GPIO_Mode_IN_FLOATING = &lt;span&gt;0x04&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浮空输入&lt;/span&gt;
GPIO_Mode_IPD = &lt;span&gt;0x28&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下拉输入&lt;/span&gt;
GPIO_Mode_IPU = &lt;span&gt;0x48&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上拉输入&lt;/span&gt;
GPIO_Mode_Out_OD = &lt;span&gt;0x14&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开漏输出&lt;/span&gt;
GPIO_Mode_Out_PP = &lt;span&gt;0x10&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通用推挽输出&lt;/span&gt;
GPIO_Mode_AF_OD = &lt;span&gt;0x1C&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;复用开漏输出&lt;/span&gt;
GPIO_Mode_AF_PP = &lt;span&gt;0x18&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;复用推挽&lt;/span&gt;
}GPIOMode_TypeDef;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;二，寄存器IDR&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;IDR&lt;/span&gt;&lt;/strong&gt; 是一个端口输入数据寄存器，一共有32位但是只用了低 16 位，因此只能以16 位的形式读出。且该寄存器为只读寄存器。&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;寄存器描述，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201904/1363478-20190427130716705-1930833691.png&quot; alt=&quot;&quot; width=&quot;695&quot; height=&quot;236&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个寄存器用于查看IO口的电平状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 在固件库中操作 IDR 寄存器读取 IO 端口数据是通过 GPIO_ReadInputDataBit 函数实现的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如我要读 GPIOA.5 的电平状态，那么方法是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_5);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回值是 1(Bit_SET)或者 0(Bit_RESET)&lt;/p&gt;
&lt;h2&gt;三.寄存器ODR&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;是一个端口输出数据寄存器，也只用了&lt;strong&gt;&lt;span&gt;低 16 位&lt;/span&gt;&lt;/strong&gt;，从该寄存器读取数据可&lt;/span&gt;&lt;span&gt;以用于判断当前 IO 口的输出状态。从该寄存器写入数据可以用于判断某个IO口的输出电平高低。其原理如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201904/1363478-20190427131257513-1526824991.png&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;218&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;在固件库中设置 ODR 寄存器的值来控制 IO 口的输出状态是通过函数 GPIO_Write 来实现的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数一般用来往一次性一个 GPIO 的多个端口设值。&lt;/p&gt;
&lt;h2&gt;四.寄存器BSRR&lt;/h2&gt;
&lt;p&gt; 这个寄存器是端口位设置/清除寄存器，用来设置 GPIO 端口的输出位是 1 还是 0，和ODR寄存器有着类似的作用。描述如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1363478/201904/1363478-20190427131624847-1395830359.png&quot; alt=&quot;&quot; width=&quot;652&quot; height=&quot;312&quot;/&gt;&lt;/p&gt;

&lt;p&gt;该寄存器通过举例子可以很清楚了解它的使用方法。例如你要设置 GPIOA 的第 1 个端口值为 1，那么你只需要往寄存器 BSRR 的低 16 位对应位写 1 即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
GPIOA-&amp;gt;BSRR=&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;如果你要设置 GPIOA 的第 1 个端口值为 0，你只需要往寄存器高 16 位对应为写 1 即可：&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
GPIOA-&amp;gt;BSRR=&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;(&lt;span&gt;16&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;该寄存器往相应位写 0 是无影响的，所以我们要设置某些位，我们不用管其他位的值。&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Apr 2019 05:18:00 +0000</pubDate>
<dc:creator>Geeksongs</dc:creator>
<og:description>STM32每个IO口具有7个寄存器来控制，每个IO口都可以自由进行编程控制，我们编程实际上控制的是通过控制那7个寄存器来控制我们的IO口，我们可以通过编程控制IO口，把IO口配置成如下八种模式： 1、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geeksongs/p/10778429.html</dc:identifier>
</item>
</channel>
</rss>