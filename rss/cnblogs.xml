<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深入理解并发编程 -- 多线程（二）底层运行原理、线程状态 - StanleyBlogs</title>
<link>http://www.cnblogs.com/StanleyBlogs/p/10894463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StanleyBlogs/p/10894463.html</guid>
<description>&lt;p&gt;作者 ： Stanley 罗昊&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;多线程 -- 并发编程（一） ： https://www.cnblogs.com/StanleyBlogs/p/10890906.html&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【&lt;strong&gt;转载请注明出处和署名，谢谢！&lt;/strong&gt;】&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;多线程底层执行原理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;说道底层运行，那么是不是就是需要&lt;strong&gt;&lt;span&gt;依靠CPU&lt;/span&gt;&lt;/strong&gt;啊；&lt;/p&gt;
&lt;p&gt;那，各位之前有没有听过一句话叫做，&lt;strong&gt;&lt;span&gt;一个CPU在同一个时间片只能执行一个程序&lt;/span&gt;&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;什么意思呢？&lt;/p&gt;
&lt;p&gt;就是，你的程序是不是都运行在一个CPU上啊，那你真正一个CPU在同一个时间片里是不是只能执行一个程序呀，那这个程序究竟要执行那个程序，是不是就需要通过线程之间时间片的一个争抢；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间片：微小的时间段；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;多线程说白了就是时间片的争夺，那个线程获取了时间片，就执行那个线程的代码；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201905/1545884-20190520091913423-5327653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设，&lt;strong&gt;&lt;span&gt;t1线程先获得时间片，那么，t1线程就优先执行；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，它不可能拿着那个时间片不放吧，因为在CPU执行的过程中，&lt;strong&gt;&lt;span&gt;底层运用轮循制的；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;多线程执行的时候，CPU分配时间片是采取轮循的方式进行分配的；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;就是轮流，有点像值日的时候，轮流值日一样；&lt;/p&gt;
&lt;p&gt;那，CPU在分配时间片的时候&lt;span&gt;，第一个t1先抢占到了之后，他先执行了一段时间之后，CPU把这个t1执行完了以后，CPU是不是接着把时间片分配给t2去执行了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那事实上，也是t2也在去抢占时间片&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;当&lt;strong&gt;&lt;span&gt;t1执行完毕后，那么，CPU就将迎来新的一轮争夺，这个时候t2抢到了，就开始执行t2的代码；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就是多线程的底层执行原理；&lt;/p&gt;
&lt;p&gt;多线程它在本质上运行的时候，他是同时执行的，还是轮流执行的呢？&lt;/p&gt;
&lt;p&gt;肯定不是同时执行的，也就是不是我们常说的并发执行；那在你们看来，实际就是宏观上你来看就是同时执行，但是在微观上是不是的；&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;线程的状态&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;线程总共有五种状态；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;第一个状态 新建状态&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;新建状态，就是你新建一个线程是的状态，也就是你新建了一个线程但还没有启动时的状态；&lt;/p&gt;
&lt;p&gt;当线程执行start方法的时候，就会进入就绪状态；&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;第二个状态 就绪状态&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;进入就绪状态的时候，事实上就是准备抢占CPU的时间片；&lt;/p&gt;
&lt;p&gt;一旦抢占到了CPU的时间片它就会立即进入运行状态；&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;第三个状态 运行状态&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;当线程抢占到了CPU时间片的时候，它才会运行，所以第三个状态是，运行状态；&lt;/p&gt;
&lt;p&gt;在它的运行状态中，还有可能执行一个代码，&lt;strong&gt;&lt;span&gt;Throad.sleep();睡眠；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就是在你执行的时候，突然让你睡眠了，我都让你这个线程睡眠了，你还有必要去争夺这个CPU资源吗？&lt;/p&gt;
&lt;p&gt;就肯定&lt;strong&gt;&lt;span&gt;没有必要再去争夺这个CPU资源了&lt;/span&gt;&lt;/strong&gt;，那这个时候你就需要释放CPU啊，对不对，你释放之后，你下次再运行的时候，你就需要重新获取CPU的时间片，所以这种状态就叫做堵塞状态；&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;第四个状态 堵塞状态与sleep方法&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;想让线程阻塞，最常用的方式就是使用&lt;strong&gt;&lt;span&gt;sleep，用sleep这个方法，可以使运行中的线程&lt;/span&gt;&lt;span&gt;回到就绪状态；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为它需要重新抢占CPU资源的，所以，sleep状态的最终目的是让改线程回到就读状态；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;就比如，我现在想让这个线程，进我想让它每次进入run方法中的for循环打印里写一个睡眠，一遍循环遍历输出，一边睡眠看会发生什么：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201905/1545884-20190520144405170-1500245136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在run方法中业务写完后，我们测试一下该线程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201905/1545884-20190520144513755-509810075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，可以发现，我同时调用了两次start方法，说明，我执行了两次我一次性开启了两次线程，并且执行了两次，我们看看会不会出现交替执行的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201905/1545884-20190520144710443-914265797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从输出结果来看，确实交替执行了并且，是俩俩执行的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201905/1545884-20190520144805544-828441493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每过一秒，就会执行一次：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1545884/201905/1545884-20190520144829343-877625473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我就不继续演示了；&lt;/p&gt;
&lt;p&gt;所以，我们从中可以看出，不管哪个线程过来，&lt;strong&gt;&lt;span&gt;t1也好t2也好，执行的时候，均睡眠一秒钟，睡眠完一秒钟之后，谁先醒了，谁就继续向下执行，这个就是到点自然醒的；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;也可以使用join来造成线程堵塞；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;join&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;刚刚，我们在上面介绍了sleep，我们来看看join；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;join()：是线程加入&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它底层执行的是，当你在执行一个线程的时候，如果遇到其他线程加入，则会先执行加入的线程，直到的加入的线程执行完成，才会继续执行原来线程的任务；&lt;/p&gt;
&lt;p&gt;什么意思呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;就是说，还是上面那个t1，与t2的例子，那假设说，t1在执行的过程中，突然遇到了一个代码t2.join，这时候，就会在这个时间片，优先执行t2的线程；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;join（）方法可以给一个参数，参数代表执行的毫秒； &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;第五个状态 死亡状态&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;线程执行完了，或因异常退出了，都会结束生命周期，这就是死亡状态；&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 07:37:00 +0000</pubDate>
<dc:creator>StanleyBlogs</dc:creator>
<og:description>并发编程 -- 多线程底层运行原理、线程状态 作者 ： Stanley 罗昊 多线程 -- 并发编程（一） ： https://www.cnblogs.com/StanleyBlogs/p/10890</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/StanleyBlogs/p/10894463.html</dc:identifier>
</item>
<item>
<title>谷歌断供华为：背水一战，自研芯片系统将上线 - 我命倾尘</title>
<link>http://www.cnblogs.com/guobin-/p/10894437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guobin-/p/10894437.html</guid>
<description>&lt;p&gt;&lt;strong&gt;事件背景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　2019年5月20日，多家媒体报道了路透社称，谷歌已撤销华为的Android许可证。&lt;/p&gt;
&lt;p&gt;　　华为现在无法访问Android操作系统的更新，这意味着华为以前销售的所有Android智能手机都不再接收安全更新。与此同时，华为未来智能手机预装谷歌服务框架也会消失。这会影响到用户对于Google Play，Gmail和Google地图，以及其他所有其他官方谷歌应用的下载使用。&lt;/p&gt;
&lt;p&gt;　　谷歌撤销华为Android许可证背景显然是特朗普所签署的所谓美国进入“国家紧急状态”，以禁止美国通讯企业与包括中国华为公司在内的一切被控会“威胁”美国国家安全的公司进行商业交易。简单的说，就是华为无法从美国买到美国研发的技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;国外现状：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　美国自不必说，反正老美也撕破脸皮了。&lt;/p&gt;
&lt;p&gt;　　欧洲的立场还是大多站在华为这一方的，华为5G毕竟是既便宜又高性能，北京的5G试运行也印证了此点。&lt;/p&gt;
&lt;p&gt;　　颇具讽刺的是，德国《每日镜报》刊发文章称，他们&lt;span&gt;&lt;strong&gt;没有在中国华为的设备上找到所谓的“后门或漏洞”&lt;/strong&gt;&lt;/span&gt;。&lt;strong&gt;&lt;span&gt;但在美国思科公司提供的设备上，却经常能发现这些安全漏洞&lt;/span&gt;&lt;/strong&gt;（所谓后门），并且已经达到了10个之多。对此，德国媒体向欧洲各国表示，不要盲从“白宫的行政命令”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;国内现状：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　前段时间有人说联想断供华为，这个事儿闹得也是满城风雨，不过后来联想官方也出来辟谣，证实此事为假。&lt;/p&gt;
&lt;p&gt;　　一波未平，一波又起，近日又有消息称谷歌向华为断供Android。美国在特朗普的带领下，真是从各方面开始针对中国，加关税打贸易战，又打压华为对5G的部署。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1198161/201905/1198161-20190520152238203-1617461919.png&quot; alt=&quot;&quot; width=&quot;394&quot; height=&quot;331&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　加关税的事情，几天前的新闻联播也专门说了这件事，更是坚定地表示：　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
谈，大门敞开；&lt;p&gt;打，奉陪到底。
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　官方已经摆明了对美国的态度。&lt;/p&gt;
&lt;p&gt;　　在华为这件事情上，之前北京多思科技工业园股份有限公司负责人刘大力曾说：“&lt;strong&gt;没有民族芯片产业，中国信息产业将很容易受到攻击，国家安全也形同虚设。&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;　　这不，在中国的信息产业露头的时候，美国按耐不住了，赶紧跳出来进行打压。&lt;/p&gt;
&lt;p&gt;　　华为曾经公布过一则消息，华为拥有自主研发的芯片和系统，为的就是防美国搞这么一手。当然，当时只是把自主系统作为计划B，依旧优先使用Android，留一个后手以防万一。果不其然，任正非一语成谶。&lt;/p&gt;
&lt;p&gt;　　在不久后，华为或许就要动用自主研发的系统。&lt;/p&gt;
&lt;p&gt;　　当然，前期可能会遭受一些挫折，在IT这个圈子里，操作系统想要崛起，是不容易的。毕竟大部分的应用和市场被Android和苹果死死地把控着，大量的应用都是根植与这两个系统，已然形成了一个&lt;span&gt;&lt;strong&gt;“生态”&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　若要让华为的系统崛起，需要大量的移动应用开发者加入到华为自主系统的应用开发工作上，短时间内首先要能满足大部分用户使用的基本需要，再逐渐地扩展直到系统的各方面功能趋于完善。只有这样，才可以使华为快速逼退Android和苹果在操作系统上的垄断，在国际市场开辟一席之地。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　据说，华为的系统，取名为“鸿蒙”，应是有着“鸿蒙现，混沌开”之意。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从国内发展到现在，华为是第一个敢于摆脱美国对技术的控制的。不管如何，我们还是该多多支持国产。华为和美国的这场战斗，可以说是背水一战，此战若是胜了，华为就将彻底摆脱美国对核心技术的控制，国产也就终于有了出头之日。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1198161/201905/1198161-20190520153159617-1910805010.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 07:33:00 +0000</pubDate>
<dc:creator>我命倾尘</dc:creator>
<og:description>事件背景： 2019年5月20日，多家媒体报道了路透社称，谷歌已撤销华为的Android许可证。 华为现在无法访问Android操作系统的更新，这意味着华为以前销售的所有Android智能手机都不再接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guobin-/p/10894437.html</dc:identifier>
</item>
<item>
<title>python接口自动化（三十七）-封装与调用--读取excel 数据（详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10892379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10892379.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　在进行软件接口测试或设计自动化测试框架时，一个不比可避免的过程就是: 参数化，在利用python进行自动化测试开发时，通常会使用excel来做数据管理，利用xlrd、xlwt开源包来读写excel。例如：当我们登录的账号有多个的时候，我们一般用&lt;/p&gt;
&lt;p&gt;excel 存放测试数据，本篇文章介绍，python 读取excel 方法，并保存为字典格式。&lt;/p&gt;
&lt;h2&gt;官网&lt;/h2&gt;
&lt;p&gt;　　通过官网来查看如何使用python读取Excel，python excel官网： &lt;a href=&quot;http://www.python-excel.org/&quot; target=&quot;_blank&quot;&gt;http://www.python-excel.org/&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;1、以下是翻译后的官网文档：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520100216229-654332433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、点击“文档”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520101235338-1741101075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、点击“安装说明”&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520101341406-591577215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、根据以上安装说明，进行准备&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520101128682-1547343429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;环境准备&lt;/h2&gt;
&lt;p&gt;1、以下是小编环境是：&lt;/p&gt;
&lt;p&gt;操作系统：win10&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520100750779-682148014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;python环境：python3.7&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520100827606-641939549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、根据官方文档先安装 xlrd 模块，打开 cmd，输入 pip install xlrd 在线安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520101716394-1200765055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、出现红色圈的内容表示xlrd安装成功&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520101526671-146997712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; python对Excel的基本操作&lt;/h2&gt;
&lt;p&gt;1、打开电子表格文件以进行数据提取，官方文档API&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520104040097-1372698205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、通过工作表索引、名称获取内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520115206531-1538743374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、实例1&lt;/p&gt;
&lt;p&gt;（1）Excel内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520114847460-1403913047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）代码实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520115325724-1081420078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520115410974-1958472211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）参考代码1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; # &lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; # &lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;20&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-&lt;span&gt;宏哥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用python读取Excel
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; # &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import xlrd
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    # excel文件全路径
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     xlPath = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\DELL\\Desktop\\test.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    # 用于读取excel
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     xlBook =&lt;span&gt; xlrd.open_workbook(xlPath)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    # 获取excel工作簿数
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     count =&lt;span&gt; len(xlBook.sheets())
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     print(u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;工作簿数为:  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, count)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    # 获取 表 数据的行列数
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     table = xlBook.sheets()[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     nrows =&lt;span&gt; table.nrows
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     ncols =&lt;span&gt; table.ncols
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     print(u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;表数据行列为(%d, %d)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (nrows, ncols))
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    # 循环读取数据
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, nrows):
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         rowValues =&lt;span&gt; table.row_values(i)  # 按行读取数据
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        # 输出读取的数据
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; data &lt;span&gt;in&lt;/span&gt;&lt;span&gt; rowValues:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             print(data, &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         print(&lt;span&gt;&quot;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、参考代码2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; # &lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; # &lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;20&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-&lt;span&gt;宏哥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用python读取Excel
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; # &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import xlrd
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    # 打开 exlce 表格，参数是文件路径
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     data = xlrd.open_workbook(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\\Users\\DELL\\Desktop\\test.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     # table = data.sheets()[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;] # 通过索引顺序获取
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     # table = data.sheet_by_index(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) # 通过索引顺序获取
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     table = data.sheet_by_name(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  # 通过名称获取
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     nrows =&lt;span&gt; table.nrows  # 获取总行数
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     ncols =&lt;span&gt; table.ncols  # 获取总列数
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    # 获取一行或一列的值，参数是第几行
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     print(table.row_values(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)) # 获取第一行值
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     print(table.col_values(&lt;span&gt;0&lt;/span&gt;)) # 获取第一列值
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、以上代码运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520131225877-1308365306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Excel存放数据（参数）&lt;/h2&gt;
&lt;p&gt;1、在 excel 中存放数据，第一行为标题，也就是对应字典里面的 key 值，如登录的参数：username，password&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520131844228-1459931335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;封装读取参数或者数据方法&lt;/h2&gt;
&lt;p&gt;1、最终读取的数据是多个字典的 list 类型数据，第一行数据就是字典里的 key 值，从第二行开始一一对应 value 值&lt;/p&gt;
&lt;p&gt;2、封装好的代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520145620750-1184782622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520145648605-1397316611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;1、在安装xlrd模块的时候后边，还有一些黄色的警告，小伙伴们不需要的担心，翻译看一下，是需要更新pip&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520110017114-824605163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、将提示的命令选中后，回车，另起一行粘贴，运行即可将pip更新到最新版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520110228385-1871871858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、小伙伴们可能发现在运行结果的显示：只有出现数字就会有个.0，解决办法：&lt;/p&gt;
&lt;p&gt;　　如果 excel 数据中有纯数字的一定要右键》设置单元格格式》文本格式，要不然读取的数据是浮点数（先设置单元格格式后编辑，编辑成功左上角有个小三角图标）&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520150229108-1392186232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　修改单元格式，运行代码结果：可以清楚看到.0没有了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190520150333063-1584747590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、好了关于python读取Excel的内容，就先讲解到这个，有兴趣可以看其官方文档对表格进行合并、样式设置等等系列动作！！！&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 07:07:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 在进行软件接口测试或设计自动化测试框架时，一个不比可避免的过程就是: 参数化，在利用python进行自动化测试开发时，通常会使用excel来做数据管理，利用xlrd、xlwt开源包来读写exce</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/du-hong/p/10892379.html</dc:identifier>
</item>
<item>
<title>原创｜高逼格企业级MySQL数据库备份方案，原来是这样.... - 民工哥</title>
<link>http://www.cnblogs.com/youkanyouxiao/p/10893765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youkanyouxiao/p/10893765.html</guid>
<description>&lt;p&gt;很多人，这里说的是运维工程师们，一提到写某某方案，很是头疼。不是上某度一统搜索，就是同样一句话在N个群全部群发一遍：“有没有某某方案，可以共享一下的吗？？求助，各位大佬们”，估计十有八九，全部石沉大海，杳无音讯。&lt;/p&gt;
&lt;p&gt;其实，到底是真的很难，还是说你没有完全掌握整个备份思路的整理？一个方案的好坏，在于对于外行人来说，能不能一眼就能看懂其中要表达的意思，而且不需要很多的思考就可以。&lt;/p&gt;
&lt;p&gt;一份好的备份方案无非包括以下几点：&lt;/p&gt;
&lt;p&gt;那么，此文将从以上几个角度，结合一些实际的实战经验，分步阐述一个完整的备份方案到底是怎么样构成的。需要学习更多Mysql数据库相关的知识，可以在公众号：民工哥技术之路的后台回复「MySQL」即可获取一份最全的MySQL数据库学习指南。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么需要数据库备份？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多人，一看这标题，肯定张口就会答，这不是废话么。不备份故障了怎么办？跑路吗？数据被沙雕开发（不许喷）误删了怎么办？背锅吗？&lt;/p&gt;
&lt;p&gt;当然，大家都知道备份的重要性与必要性。&lt;/p&gt;
&lt;p&gt;1、保证数据安全与完整&lt;/p&gt;
&lt;p&gt;企业的数据安全应该来说是企业的命脉，一旦丢失或造成损坏，轻则损失客户与金钱，重则倒闭（已经有前例在）。&lt;/p&gt;
&lt;p&gt;备份的目的：为了保证数据在被人为失误、操作不当、蓄意等情况下删除或损坏后，能及时、有效的进行恢复并不会很大程度上影响到业务运行。&lt;/p&gt;
&lt;p&gt;2、为业务提供不间断服务&lt;/p&gt;
&lt;p&gt;实际生产环境对数据库的要求，首先就是具备7×24×365不间断服务的能力，这也是一定要备份数据库的其中原因之一。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;数据库的备份方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常用的备份方式包括以下：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;逻辑备份&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;物理备份&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1、逻辑备份&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;逻辑备份其实就是利用MySQL数据库自带的mysqldump命令，或者使用第三方的工具，然后把数据库里的数据以SQL语句的方式导出成文件的形式。在需要恢复数据时，通过使用相关的命令（如：source ）将备份文件里的SQL语句提取出来重新在数据库中执行一遍，从而达到恢复数据的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqldump -A -B --single-transaction &amp;gt;&lt;span&gt;/server/backup/mysql_$(date +%F).sql&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般备份时都会进行压缩处理，以节省磁盘空间，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqldump -A -B --single-transaction ｜gzip&amp;gt;&lt;span&gt;/server/backup/mysql_$(date +%F).sql.gz&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;恢复操作&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /server/&lt;span&gt;backup/&lt;/span&gt;&lt;/code&gt;&lt;code readability=&quot;2&quot;&gt;gzip -o mysql_$(&lt;span readability=&quot;4&quot;&gt;date +%F).sql.gz&lt;p&gt;mysql -uroot -pMyadmin -h mysqldb.mingongge.com&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;gt; source /&lt;span&gt;server/&lt;span&gt;backup/mysql_$(&lt;span&gt;date +%F).sql&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;逻辑备份的优点与使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：简单，易操作，自带工具方便、可靠。&lt;/p&gt;
&lt;p&gt;使用场景：数据库数据量不大的情况可以使用，数据量比较大（超过20G左右）时备份速度比较慢，一定程度上还会影响数据库本身的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、物理备份&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;物理备份就是利用命令（如cp、tar、scp等）直接将数据库的存储数据文件复制一份或多份，分别存放在其它目录，以达到备份的效果。&lt;/p&gt;
&lt;p&gt;这种备份方式，由于在备份时数据库还会存在数据写入的情况，一定程度上会造成数据丢失的可能性。在进行数据恢复时，需要注意新安装的数据的目录路径、版本、配置等与原数据要保持高度一致，否则同样也会有问题。&lt;/p&gt;
&lt;p&gt;所以，这种物理备份方式，常常需要在停机状态下进行，一般对实际生产中的数据库不太可取。因此，此方式比较适用于数据库物理迁移，这种场景下这种方式比较高效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;物理备份的优点及使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：速度快，效率高。&lt;/p&gt;
&lt;p&gt;场景：可用于停机维护及数据库物理迁移场景中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际生产环境中，具体使用哪种方式，就需要看需求与应用场景所定。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;全量与增量备份概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在介绍完备份方式之后，再来介绍一下，增量与全量备份这两个概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是全量备份？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全量备份：就是将数据库中的所有数据，或者是某一个特定的库里的所有数据，一次全部备份下。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1024722/201905/1024722-20190520135232060-797719108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;备份数据库中所有数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqldump -A -B --single-transaction ｜gzip&amp;gt;&lt;span&gt;/server/backup/All_data_$(date +%F).sql.gz&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备份某个库的数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqldump -A -B --single-transaction testDB1｜gzip&amp;gt;&lt;span&gt;/server/backup/testDB1_$(date +%F).sql.gz&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;什么是增量备份？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;增量备份：指的是上一次全量备份之后到下一次全量备份这前这段时间内数据库所更新或者是增加的数据，将其备份下来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1024722/201905/1024722-20190520135252098-751880490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.21036585365853658&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPqrUJeb6AzKsibFAMvZB4oI3da4wZDKBPfVD7NPoeNdry5XErdicy4iabXvCnQwRNPBvkwQy3JdAtxKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：全量备份是一个文件，而增量备份则是MySQL的binlog日志文件。所以常说的增量备份就是备份binlog日志文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;两者的区别在哪？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全量备份：需要的备份时间长一点，恢复时间会短一点，因为文件数少，维护方便。但是，全量备份的文件大，占用一定的磁盘空间，全理备份时会一定程序上影响数据库的性能（这也就是为什么在0:00点备份的原因），也因文件大的原因，不便于服务器本地保存过多文件，重要业务的全量备份文件可能需要手工下载或迁移到服务器之外的存储空间中。&lt;/p&gt;
&lt;p&gt;增量备份：备份简单，恢复时复杂一点，因为文件数量多，需将所有binlog文件解析成SQL语句，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;mysqlbinlog testDB1-bin.&lt;span&gt;000001 testDB1-bin.&lt;span&gt;000002 &amp;gt;./bin.sql&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，再通过恢复的方式进行恢复&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql -uroot -pMyadmin -h mysqldb.mingongge.com&lt;br/&gt;&lt;span&gt;&lt;br/&gt;&amp;gt;&lt;span&gt; &lt;span&gt;source /server/backup/bin.sql&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者如下操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /server/&lt;span&gt;backup&lt;p&gt;mysql testDB1 &amp;lt;./bin.sql&lt;/p&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;备份与恢复实践操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于Mysql数据库的备份，一般采取脚本+定时任务进行日常备份。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用执行策略是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分享一个我在一个创业公司初期的一个备份方案实例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阿里云数据库服务器备份方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前数据库是主从同步，从库开启binlog日志功能进行异地备份，就目前数据量而言，只需要在从库的基础上进行定时全量与增量备份数据库即可。&lt;/p&gt;
&lt;pre readability=&quot;11&quot;&gt;
&lt;code readability=&quot;16&quot;&gt;1、创建备份目录&lt;p&gt;mkdir /server/&lt;span&gt;backup&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、备份数据库到指定目录&lt;/span&gt;&lt;/p&gt;&lt;p&gt;mysqldump &lt;span&gt;--single-transaction -F -B phoenix_coupon_production|gzip &amp;gt;/server/backup/phoenix_$(date +%F).sql.gz&lt;/span&gt;&lt;/p&gt;&lt;p&gt;mysqldump &lt;span&gt;--single-transaction -F -B ywotx|gzip &amp;gt;/server/backup/ywotx_$(date+%F).sql.gz&lt;/span&gt;&lt;/p&gt;&lt;p&gt;find /&lt;span&gt;server/&lt;span&gt;backup/ -&lt;span&gt;type f –&lt;span&gt;name “*.sql.gz”-mtime +&lt;span&gt;7 |xargs rm-f&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;将脚本写入定时任务，分时段进行打包备份 &lt;/p&gt;&lt;p&gt;&lt;span&gt;3、定时备份二进制文件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通过参数刷新&lt;span&gt;binlog产生新的文件，通过脚本判断文件新旧，然后备份旧的日志文件&lt;br/&gt;mysqladmin -uroot -pywotx!&lt;span&gt;123 &lt;span&gt;flush-&lt;span&gt;logs #刷新日志，产生新的日志文件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终将备份文件同步或定时手工下载到异地备份服务器异地存储备份文件，实现数据库备份文件双备份存储，防止服务器硬件故障。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后期数据量增大之后，数据库需要进行读写分离，实现主写，从读，主从同步的架构，备份还是按照原来的备份方案进行，可采用分库分表进行数据备份，防止数据量大导致的恢复时间的问题，提升恢复效率。&lt;/p&gt;

&lt;pre readability=&quot;9&quot;&gt;
&lt;code readability=&quot;12&quot;&gt;1、创建备份目录&lt;p&gt;Mkdir /server/backup&lt;/p&gt;&lt;p&gt;2、备份数据到指定目录( 分库分表)&lt;br/&gt;&lt;span&gt;#/bin/sh&lt;br/&gt;&lt;span&gt;#create by mingongge at 2017-06-01&lt;br/&gt;BACKUPDIR=/server/backup&lt;br/&gt;DATE=`date +%F`&lt;br/&gt;USER=root&lt;br/&gt;PASSWD=”123456”&lt;br/&gt;CMD=”mysql –u&lt;span&gt;$USER –p&lt;span&gt;$PASSWD”&lt;br/&gt;DUMPCMD=”mysqldump –u&lt;span&gt;$USER –p&lt;span&gt;$PASSWD --single-transaction -F”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;for dbname &lt;span&gt;in `&lt;span&gt;${CMD} –e “show databases”|sed ‘1d’`&lt;br/&gt;&lt;span&gt;do&lt;br/&gt;mkdir –p&lt;span&gt;${BACKUPDIR}/&lt;span&gt;${dbname}&lt;br/&gt;&lt;span&gt;for tablename &lt;span&gt;in`&lt;span&gt;${CMD} –D &lt;span&gt;${dbname} –e “show tables”|sed ‘1d’`&lt;br/&gt;&lt;span&gt;do&lt;br/&gt;&lt;span&gt;${DUMPCMD} --tables&lt;span&gt;${dbname} &lt;span&gt;${tablename} |gzip &amp;gt; &lt;span&gt;${BACKUPDIR}/&lt;span&gt;${dbname}/&lt;span&gt;${tablename}_$(DATE).sql.gz&lt;br/&gt;&lt;span&gt;done&lt;br/&gt;&lt;span&gt;done&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;find /server/backup/&lt;span&gt;${dbname} -&lt;span&gt;type f –name “*.sql.gz”-mtime +7|xargs rm -f&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、定时备份二进制文件（增量）&lt;br/&gt;备份方法同方案一&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;备份频率：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库的备份，每天一次全备，在全备时会更新binlog日志，重新生成新的日志文件，因此在下一次增量备份时再刷新binlog,再次产生新的日志文件，实现从全备之后对数据库的操作的增量备份，一旦发现数据问题，立即刷新binlog重新成新的日志文件，将原来的日志文件手工备份一份，然后找出产生数据问题的点，从而利用日志文件进行恢复全备到产生数据问题点之间的数据,然后恢复从问题点到发现问题时间段之间的数据.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新增一台备份服务器，配置如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实例配置：2核/4G/40G + 200G高效云盘 经典网络 1M  295元/月&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于数据库服务器本地的备份文件基本上只保留一周时间内的数据，备份服务器按需求（一般保留至少30天的数据），保留30天的数据包括数据库全备文件与增量备份文件，后期可按实际生产需求进行修改，保留时间长短只会增加相应的服务器磁盘空间，增加一定的成本，其它无需改动，操作较为灵活、方便。&lt;/p&gt;
&lt;p&gt;如果需要整套备份方案的，可以在民工哥技术之路公众号后台回复「备份」获取全套方案的下载地址。有兴趣的读者朋友们可以试试更多的关键字：「项目、MySQL、避坑」。&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 05:54:00 +0000</pubDate>
<dc:creator>民工哥</dc:creator>
<og:description>很多人，这里说的是运维工程师们，一提到写某某方案，很是头疼。不是上某度一统搜索，就是同样一句话在N个群全部群发一遍：“有没有某某方案，可以共享一下的吗？？求助，各位大佬们”，估计十有八九，全部石沉大海</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youkanyouxiao/p/10893765.html</dc:identifier>
</item>
<item>
<title>一个C#开发者重温C++的心路历程 - kiba518</title>
<link>http://www.cnblogs.com/kiba/p/10863049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kiba/p/10863049.html</guid>
<description>&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;这是一篇C#开发重新学习C++的体验文章。&lt;/p&gt;
&lt;p&gt;作为一个C#开发为什么要重新学习C++呢？因为在C#在很多业务场景需要调用一些C++编写的COM组件，如果不了解C++，那么，很容易注定是要被C++同事忽悠的。&lt;/p&gt;
&lt;p&gt;我在和很多C++开发者沟通的时候，发现他们都有一个非常奇怪的特点，都很爱装X，都觉得自己技术很好，还很爱瞧不起人；但如果多交流，会发现更奇怪的问题，他们几乎都不懂代码设计，代码写的也都很烂。&lt;/p&gt;
&lt;p&gt;所以，这次重温C++也是想了解下这种奇异现象的原因。&lt;/p&gt;
&lt;p&gt;C++重温&lt;/p&gt;
&lt;p&gt;首先打开VisualStudio，创建一个C++的Windows控制台应用程序，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201905/243596-20190519073050742-11613635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中有四个文件，系统默认为我打开了头文件和源文件的文件夹。&lt;/p&gt;
&lt;p&gt;系统这么做是有意义的，因为刚学习时，外部依赖项，可以暂时不用看，而资源文件夹是空的，所以我们只专注这两个文件夹就可以了。&lt;/p&gt;
&lt;p&gt;作为一个C#开发，我对C++就是一知半解，上学学过的知识也都忘记的差不多了，不过，我知道程序入口是main函数，所以我在项目里先找拥有main函数的文件。&lt;/p&gt;
&lt;p&gt;结果发现ConsoleTest.cpp 文件里有main函数，那么，我就在这个文件里开始学习C++了，而且它的命名和我项目名也一样，所以很确定，它就是系统为我创建的项目入口文件。&lt;/p&gt;
&lt;p&gt;然后我打开ConsoleTest.cpp 文件，定义一个字符串hello world，准备在控制台输出一下，结果发现编译器报错。。。只好调查一下了。&lt;/p&gt;
&lt;p&gt;调查后得知，原来，c++里没有string类型，想使用string类型，只能先引用string的头文件，在引用命名空间std，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &quot;pch.h&quot; 
&lt;span&gt;#include &amp;lt;string&amp;gt;
using namespace std;&lt;/span&gt;
int main()
{
        string str = &quot;Hello World!\n&quot;; 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;头文件&lt;/p&gt;
&lt;p&gt;头文件到底是什么呢？&lt;/p&gt;
&lt;p&gt;头文件，简单来说就是一部分写在main函数上面的代码。&lt;/p&gt;
&lt;p&gt;比如上面的代码，我们将其中的引用头文件和使用命名空间的代码提取出来，写进pch.h头文件；然后，我们得到代码如下图：&lt;/p&gt;
&lt;p&gt;pch.h头文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201905/243596-20190519085533776-1388136924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ConsoleTest.cpp文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201905/243596-20190519085731319-523358948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说，头文件是用来提取.cpp文件的代码的。&lt;/p&gt;
&lt;p&gt;呃。。。好像头文件很鸡肋啊，一个文件的代码为什么要提取一部分公共的？写一起不就好了！为什么要搞个文件来单独做，多傻的行为啊！&lt;/p&gt;
&lt;p&gt;好吧，一开始我也的确是这么想的。&lt;/p&gt;
&lt;p&gt;后来我发现，头文件，原来并不是单纯的提取代码，还是跨文件调用的基础。&lt;/p&gt;
&lt;p&gt;也就是说，ConsoleTest.cpp文件，想调用其他Cpp文件的变量，必须通过头文件来调用。&lt;/p&gt;
&lt;p&gt;比如，我新建一个test.cpp和一个test.h文件。&lt;/p&gt;
&lt;p&gt;然后我在test.cpp中，定义变量test=100；如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pch.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; test = &lt;span&gt;100&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着我在test.h文件中再声明下test变量，并标记该变量为外部变量，如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
extern int test;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，我在回到ConsoleTest.cpp文件，引用test.h文件；然后我就可以在ConsoleTest.cpp文件中使用test.cpp中定义的test变量了，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &quot;pch.h&quot; 
#include &quot;test.h&quot; 
int main()
{
        string str = &quot;Hello World!\n&quot;; 
        cout &amp;lt;&amp;lt; test &amp;lt;&amp;lt; endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上述代码所示，我们成功的输出了test变量，其值为100。&lt;/p&gt;
&lt;p&gt;到此，我们应该了解到了，头文件的主要作用应该是把被拆散的代码，扭到一起的纽带。&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;PS：我在上面引用字符串头文件时，使用的引用方法是【#include &amp;lt;string&amp;gt;】；我发现，引用该头文件时，并没有加后缀.h；我把后缀.h加上后【#include &amp;lt;string.h&amp;gt;】，发现编译依然可以通过。&lt;/p&gt;
&lt;p&gt;简单的调查后得知，【#include &amp;lt;string&amp;gt;】是C++的语法，【#include &amp;lt;string.h&amp;gt;】是语法。因为C++要包含所有C的语法，所以，该写法也支持。&lt;/p&gt;
&lt;p&gt;Cin与Cout&lt;/p&gt;
&lt;p&gt;Cin与Cout是控制台的输入和输出函数，我在测试时发现，使用Cin与Cout需要引用iostream头文件【#include &amp;lt;iostream&amp;gt;】，同时也要使用命名空间std。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面，我们提到过，使用字符串类型string时，需要引用头文件string.h和使用命名空间std，那么现在使用Cout也要使用命名空间std。这是为什么呢？&lt;/p&gt;
&lt;p&gt;只能推断，两个头文件string.h和iostream.h在定义时，都定义在命名空间std下了。而且，通过我后期使用，发现还有好多类和类型也定义在std下了。&lt;/p&gt;
&lt;p&gt;对此，我只能说，好麻烦。。。首先，缺失基础类型这种事，就很奇怪，其次不是一个头文件的东西，定义到一个命名空间下，也容易让人混乱。&lt;/p&gt;
&lt;p&gt;不过，对于C++，这么做好像已经是最优解了。&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;PS：Cin与Cout是控制台的输入和输出函数，开始时，我也不太明白，为什么使用这样两个不是单词的东西来作为输入输出，后来，在调查资料时，才明白，原来这个俩名字要拆开来读。&lt;/p&gt;
&lt;p&gt;读法应该是这样的C&amp;amp;in和C&amp;amp;out，这样我们就清晰明白的理解了该函数了。&lt;/p&gt;
&lt;p&gt;define，typedef，指针，引用类型，const&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;define&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先说define，define在C++里好像叫做宏。就定义一个全局的字符串，然后再任何地方都可以替换，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &quot;pch.h&quot; 
#include &quot;test.h&quot; 
#define ERROR 518
int defineTest()
{
        return ERROR;
}
int main()
{ 
        cout &amp;lt;&amp;lt; defineTest() &amp;lt;&amp;lt; endl;
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是说，define定义的宏，在C++里就是个【行走的字符串】，在编译时，该字符串会被替换回最初定义的值。这。。。这简直就是编译器允许的bug。。。&lt;/p&gt;
&lt;p&gt;不过，它当然也有好处，就是字符串更容易记忆和理解。但是说实话，定义一个枚举一样好记忆，而且适用场景更加丰富，所以，个人感觉这个功能是有点鸡肋，不过C++好多代码都使用了宏，所以还是需要了解起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;typedef&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;typedef是一个别名定义器，用来给复杂的声明，定义成简洁的声明。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
struct kiba_Org {
        int id;
};
typedef struct kiba_new {
        int id;
} kiba;
int main()
{
        struct kiba_Org korg;
        korg.id = 518;
        kiba knew;
        knew.id = 520;
        cout &amp;lt;&amp;lt; korg.id &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; knew.id &amp;lt;&amp;lt; endl;
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上述代码所示，我定义了一个结构体kiba_Org，如果我要用kiba_Org声明一个变量，我需要这样写【struct kiba_Org korg】，必须多写一个struct。&lt;/p&gt;
&lt;p&gt;但我如果用typedef给【struct kiba_Org korg】定义一个别名kiba，那么我就可以直接拿kiba声明变量了。&lt;/p&gt;
&lt;p&gt;呃。。。对此，我只能说，为什么会这么麻烦！！！&lt;/p&gt;
&lt;p&gt;以为这就很麻烦了吗？NO！！！还有更麻烦的。&lt;/p&gt;
&lt;p&gt;比如，我想在我定义的结构体里使用自身的类型，要怎么定义呢？&lt;/p&gt;
&lt;p&gt;因为在C++里，变量定义必须按照先声明后使用的【绝对顺序】，那么，在定义时就使用自身类型，编译器会提示错误。&lt;/p&gt;
&lt;p&gt;如果想要让编译器通过，就必须在使用前，先给自身类型定义个别名，这样就可以在定义时使用自身类型了。&lt;/p&gt;
&lt;p&gt;呃。。。好像有点绕，我们直接看代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
typedef struct kibaSelf *kibaSelfCopy;
struct kibaSelf
{
        int id;
        kibaSelfCopy myself;
};
int main()
{
        kibaSelf ks;
        ks.id = 518;
        kibaSelf myself;
        myself.id = 520;
        ks.myself = &amp;amp;myself;
        cout &amp;lt;&amp;lt; ks.id &amp;lt;&amp;lt; endl;
        cout &amp;lt;&amp;lt; ks.myself-&amp;gt;id &amp;lt;&amp;lt; endl; 
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上述代码所示，我们在定义结构体之前，先给它定义了个别名。&lt;/p&gt;
&lt;p&gt;那么，变量定义不是必须按照先声明后使用的【绝对顺序】吗？为什么这里，又在定义前，可以定义别名了呢？这不是矛盾了吗？&lt;/p&gt;
&lt;p&gt;不知道，反正，C++就是这样。。。就这么屌。。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指针在C++中，就是在变量前加个*号，下面我们定义个指针来看看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int i = 518;
int *ipointer = &amp;amp;i;
int* ipointer2 = &amp;amp;i;
cout &amp;lt;&amp;lt; &quot;*ipointer&quot; &amp;lt;&amp;lt; *ipointer &amp;lt;&amp;lt; &quot;===ipointer&quot; &amp;lt;&amp;lt; ipointer &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上述代码所示，我们定义了俩指针，int *ipointer 和int* ipointer2。可以看到，我这俩指针的*一个靠近变量一个靠近声明符int，但两种写法都正确，编译器可以编译通过。&lt;/p&gt;
&lt;p&gt;呃。。。就是这么屌，学起来就是这么优雅。。。&lt;/p&gt;
&lt;p&gt;接着，我们用取地址符号&amp;amp;，取出i变量的地址给指针，然后指针变量*ipointer中ipointer存储的是i的地址，而*ipointer存储的是518，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201905/243596-20190519121325661-619418996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，我们明明是把i的地址给了变量*ipointer，为什么*ipointer存储的是518呢？&lt;/p&gt;
&lt;p&gt;因为。。。就是这么屌。。。&lt;/p&gt;
&lt;p&gt;哈哈，不开玩笑了，我们先看这样一段代码，就可以理解了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int i = 518;
int *ipointer;
int* ipointer2;
ipointer = &amp;amp;i;
ipointer2 = &amp;amp;i;
cout &amp;lt;&amp;lt; &quot;*ipointer&quot; &amp;lt;&amp;lt; *ipointer &amp;lt;&amp;lt; &quot;===ipointer&quot; &amp;lt;&amp;lt; ipointer &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上述代码所示，我把声明和赋值给分开了，这样就形象和清晰了。&lt;/p&gt;
&lt;p&gt;我们把i的地址给了指针（*ipointer）中的ipointer，所以ipointer存的就是i的地址，而*ipointer则是根据ipointer所存储的地址找到对应的值。&lt;/p&gt;
&lt;p&gt;那么，int *ipointer = &amp;amp;i;这样赋值是什么鬼？这应该报错啊，应该不允许把i的地址给*ipointer啊。&lt;/p&gt;
&lt;p&gt;呃。。。还是那句话，就是这么屌。。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;-&amp;gt;这个符号大概是指针专用的。下面我们来看这样一段代码来了解-&amp;gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
kiba kinstance;
kiba *kpointer;
kpointer = &amp;amp;kinstance;
(*kpointer).id = 518;
kpointer-&amp;gt;id = 518;
//*kpointer-&amp;gt;id = 518;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先我们定义一个kiba结构体的实例，定义定义一个kiba结构体的指针，并把kinstance的地址给该指针。&lt;/p&gt;
&lt;p&gt;此时，如果我想为结构体kiba中的字段id赋值，就需要这样写【(*kpointer).id = 518】。&lt;/p&gt;
&lt;p&gt;我必须把*kpointer扩起来，才能点出它对应的字段id，如果不扩起来编译器会报错。&lt;/p&gt;
&lt;p&gt;这样很麻烦，没错，按说，微软应该在编译器中解决这个问题，让他*kpointer不用被扩起来就可以使用。&lt;/p&gt;
&lt;p&gt;但很显然，微软没这样解决，编译器给的答案是，我们省略写*号，然后直接用存储地址的kpointer来调用字段，但调用字段时，就不能再用点(.)了，而是改用-&amp;gt;。&lt;/p&gt;
&lt;p&gt;呃。。。解决的就是这么优雅。。。没毛病。。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先定义接受引用类型的函数，如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int usage(int &amp;amp;i) {
        i = 518;
        return i;
}
int main()
{
        int u = 100;
        usage(u);
        cout &amp;lt;&amp;lt; &quot;u&quot; &amp;lt;&amp;lt; u &amp;lt;&amp;lt; endl; 
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上述代码所示，u经过函数usage后，他的值被改变了。&lt;/p&gt;
&lt;p&gt;如果我们删除usage函数中变量i前面的&amp;amp;，那么u的值就不会改变。&lt;/p&gt;
&lt;p&gt;好了，那么&amp;amp;符号不是我们刚才讲的取地址吗？怎么到这里又变成了引用符了呢？&lt;/p&gt;
&lt;p&gt;还是那句话。。。就是这么屌。。。&lt;/p&gt;
&lt;p&gt;呃。。。还有更屌的。。。我们来引用个指针。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
void usagePointer(kiba *&amp;amp;k, kiba &amp;amp;kiunew) {
        k = &amp;amp;kiunew;
        k-&amp;gt;id = 518;
}
int main()
{
        kiba kiunew;
        kiba kiu;
        kiba *kiupointer;
        kiupointer = &amp;amp;kiu; 
        kiupointer-&amp;gt;id = 100;
        kiunew.id = 101;
        cout &amp;lt;&amp;lt; &quot;kiupointer-&amp;gt;id&quot; &amp;lt;&amp;lt; kiupointer-&amp;gt;id &amp;lt;&amp;lt; &quot;===kiupointer&quot; &amp;lt;&amp;lt; kiupointer &amp;lt;&amp;lt; endl;
        usagePointer(kiupointer, kiunew);
        cout &amp;lt;&amp;lt; &quot;kiupointer-&amp;gt;id&quot; &amp;lt;&amp;lt; kiupointer-&amp;gt;id &amp;lt;&amp;lt; &quot;===kiupointer&quot; &amp;lt;&amp;lt; kiupointer &amp;lt;&amp;lt; endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上述代码所示，我定义了两个结构体变量kiunew，kiu，和一个指针*kiupointer，然后我把kiu的地址赋值给指针。&lt;/p&gt;
&lt;p&gt;接着我把指针和kiunew一起发送给函数usagePointer，在函数里，我把指针的地址改成了kiunew的地址。&lt;/p&gt;
&lt;p&gt;运行结果如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201905/243596-20190519125335320-944266291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，指针地址已经改变了。&lt;/p&gt;
&lt;p&gt;如果我删除掉函数usagePointer中的【引用符&amp;amp;】(某些情况下也叫取地址符)。我们将得到如下结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201905/243596-20190519125533434-1076642612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们从图中发现，不仅地址没改变，赋值也失败了。&lt;/p&gt;
&lt;p&gt;也就是说，如果我们不使用【引用符&amp;amp;】来传递指针，那么指针就是只读的，无法修改。&lt;/p&gt;
&lt;p&gt;另外，大家应该也注意到了，指针的引用传递时，【引用符&amp;amp;】是在*和变量之间的，如果*&amp;amp;k。而普通变量的引用类型传递时，【引用符&amp;amp;】是在变量前的，如&amp;amp;i。&lt;/p&gt;
&lt;p&gt;呃。。。指针，就是这么屌。。。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;const是定义常量的，这里就不多说了。下面说一下，在函数中使用const符号。。。没错，你没看错，就是在函数中使用const符号。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int constusage(const int i) { 
        return i;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如代码所示，我们在入参int i前面加上了const修饰，然后，我们得到这样的效果。&lt;/p&gt;
&lt;p&gt;i在函数constusage，无法被修改，一但赋值就报错。&lt;/p&gt;
&lt;p&gt;呃。。。基于C#，估计肯定不好理解这个const存在的意义了，因为如果不想改，就别改啊，标只读这么费劲干什么。。。&lt;/p&gt;
&lt;p&gt;不过我们换位思考一下，C++中这么多内存控制，确实很乱，有些时候加上const修饰，标记只读，还是很有必要的。&lt;/p&gt;
&lt;p&gt;PCH&lt;/p&gt;
&lt;p&gt;在项目创建的时候，系统为我们创建了一个pch.h头文件，并且，每个.cpp文件都引用了这个头文件【#include &quot;pch.h&quot;】。&lt;/p&gt;
&lt;p&gt;打开.pch发现，里面是空代码，在等待我们填写。&lt;/p&gt;
&lt;p&gt;既然.pch没有被使用，那么将【#include &quot;pch.h&quot;】删掉来简化代码，删除后，发现编译器报错了。&lt;/p&gt;
&lt;p&gt;调查后发现，原来项目在创建的时候，为我们设置了一个属性，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201905/243596-20190519140304483-1328506113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，系统我们创建的pch.h头文件，被设置成了预编辑头文件。&lt;/p&gt;
&lt;p&gt;下面，我修改【预编译头】属性，修改为不使用预编译头，然后我们再删除【#include &quot;pch.h&quot;】引用，编译器就不会报错了。&lt;/p&gt;
&lt;p&gt;那么，为什么创建文件时，会给我们设置一个预编译头呢？微软这么做肯定是有目的。&lt;/p&gt;
&lt;p&gt;我们通过名字，字面推测一下。&lt;/p&gt;
&lt;p&gt;pch.h是预编译头，那么它的对应英文，大概就是Precompile Header。即然叫做预编译，那应该在正式编译前，执行的编译。&lt;/p&gt;
&lt;p&gt;也就是，编译时，文件被分批编译了，pch.h预编译头会被提前编译，我们可以推断，预编译头是用于提高编译速度的。&lt;/p&gt;
&lt;p&gt;类&lt;/p&gt;
&lt;p&gt;C++是一个同时面向过程和面向对象的编程语言，所以，C++里也有类和对象的存在。&lt;/p&gt;
&lt;p&gt;类的基础定义就不多说了，都一样。&lt;/p&gt;
&lt;p&gt;不过在C++中，因为，引用困难的原因（上面已经描述了，只能引用其他.cpp文件对应的头文件，并且，.cpp实现的变量，还得在头文件里外部声明一下），所以类的定义写法也发生了改变。&lt;/p&gt;
&lt;p&gt;C++中创建类，需要在头文件中声明函数，然后在.cpp文件中，做函数实现。&lt;/p&gt;
&lt;p&gt;但是这样做，明显是跨文件声明类了，但C++中又没有类似partial关键字让俩个文件合并编译，那么怎么办呢？&lt;/p&gt;
&lt;p&gt;微软给出的解决方案是，在.Cpp文件中提供一个类外部编写函数的方法。&lt;/p&gt;
&lt;p&gt;下面，我们简单的创建一个类，在头文件中声明一些函数和一些外部变量，然后在.cpp文件中实现这些函数和变量。&lt;/p&gt;
&lt;p&gt;右键头文件文件夹—&amp;gt;添加——&amp;gt;类，在类名处输入classtest，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201905/243596-20190519142100403-692054622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们会发现，系统为我们创建了俩文件，一个.h头文件和一个.cpp文件，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/243596/201905/243596-20190519142029810-315714562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后编写代码如下：&lt;/p&gt;
&lt;p&gt;classtest.h头文件:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
class classtest
{
public:
        int id;
        string name;
        classtest();
        ~classtest();
        int excute(int id);
private:
        int number;
        int dosomething();
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;calsstest.cpp文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &quot;pch.h&quot;
#include &quot;classtest.h&quot; 
classtest::classtest()
{
} 
classtest::~classtest()
{
}
int classtest::excute(int id)
{
        this-&amp;gt;id = id;
        return this-&amp;gt;id;
}
int classtest::dosomething()
{
        this-&amp;gt;number = 520;
        return this-&amp;gt;number;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用测试代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &quot;pch.h&quot; 
#include &quot;classtest.h&quot; 
int main()
{
        classtest ct;
        ct.excute(518);
        classtest *ctPointer = new classtest;
        ctPointer-&amp;gt;excute(520);
        cout &amp;lt;&amp;lt; &quot;ct.id&quot; &amp;lt;&amp;lt; ct.id &amp;lt;&amp;lt; &quot;===ctPointer&quot; &amp;lt;&amp;lt; ctPointer-&amp;gt;id &amp;lt;&amp;lt; endl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结语&lt;/p&gt;
&lt;p&gt;通过重温，我得出如下结论。&lt;/p&gt;
&lt;p&gt;一，C++并不是一门优雅的开发语言，他自身存在非常多的设定矛盾和混淆内容，因此，C++的学习和应用的难度远大于C# ；其难学的原因是C++本身缺陷导致，而不是C++多么难学。&lt;/p&gt;
&lt;p&gt;二，指针是C++开发学习设计模式的拦路虎，用C++学习那传说中的26种设计模式，还勉强可以；但，如果想学习MVVM,AOP等等这些的设计模式的话，C++的指针会让C++开发付出更多的代码量，因此多数C++开发对设计模式理解水平很低也是可以理解的了。&lt;/p&gt;
&lt;p&gt;三，通过学习和反思，发现，我曾经接触的那些爱装X的C++开发，确实是坐井观天、夜郎自大，他们的编写代码的思维逻辑，确确实实是被C++的缺陷给限制住了。&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;到此，我重温C++的心路历程就结束了。&lt;/p&gt;
&lt;p&gt;代码已经传到Github上了，欢迎大家下载。&lt;/p&gt;
&lt;p&gt;Github地址：&lt;a href=&quot;https://github.com/kiba518/C-ConsoleTest&quot; target=&quot;_blank&quot;&gt;https://github.com/kiba518/C-ConsoleTest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;注：此文章为原创，欢迎转载，请在文章页面明显位置给出此文链接！&lt;br/&gt;若您觉得这篇文章还不错，请点击下方的&lt;span&gt;【&lt;strong&gt;推荐】&lt;/strong&gt;&lt;/span&gt;，非常感谢！&lt;/p&gt;

</description>
<pubDate>Mon, 20 May 2019 04:36:00 +0000</pubDate>
<dc:creator>kiba518</dc:creator>
<og:description>前言 这是一篇C#开发重新学习C++的体验文章。 作为一个C#开发为什么要重新学习C++呢？因为在C#在很多业务场景需要调用一些C++编写的COM组件，如果不了解C++，那么，很容易注定是要被C++同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kiba/p/10863049.html</dc:identifier>
</item>
<item>
<title>Kubernetes(k8s)底层网络原理刨析 - Jo_ZSM</title>
<link>http://www.cnblogs.com/JoZSM/p/10893460.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JoZSM/p/10893460.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480383/201905/1480383-20190520120554400-1570508078.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;• 一个外部的business-manager请求，首先进入集群的入口（ingress），ingress反向代理后负载到business-manager的service。Service层再负载到某个node下的具体的business-manager pod&lt;br/&gt;• Business-manager pod再将请求发往data-product的service，同理，service层继续随机选择一个data-product的Pod来接收请求&lt;br/&gt;• 上面这个请求，涉及到容器的网络-docker0、跨主机通讯-flannel网络方案、ingress和service组件，以及DNS等，下面我会挨个介绍它们的基本原理。&lt;/p&gt;

&lt;p&gt;写这个文档的同时，我在虚拟机上搭建了一个K8S环境，集群内包含2台主机，ip分别为192.168.0.21和192.168.0.22，主要组件为ingress-&amp;gt;nginx、service-&amp;gt;kube-proxy、网络-&amp;gt;flannel，我们以这个集群为例进行分析。&lt;br/&gt;在深入之前，我们先科普一下K8S集群内常见IP的含义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# kubectl get po -o wide
NAME                                READY   STATUS    RESTARTS   AGE    IP            NODE        
business-manager-666f454f7f-bg2bt   1/1     Running   0          153m   172.30.76.4   192.168.0.21
business-manager-666f454f7f-kvn5z   1/1     Running   0          153m   172.30.76.5   192.168.0.21
business-manager-666f454f7f-ncjp7   1/1     Running   0          153m   172.30.9.4    192.168.0.22
data-product-6664c6dcb9-7sxnz       1/1     Running   0          160m   172.30.76.2   192.168.0.21
data-product-6664c6dcb9-j2f48       1/1     Running   0          160m   172.30.76.3   192.168.0.21
data-product-6664c6dcb9-p5xkw       1/1     Running   0          160m   172.30.9.3    192.168.0.22&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Node ip：&lt;/strong&gt;宿主机的ip，由路由器分配。上图最右边的NODE列代表的就是容器所在的宿主机的物理ip，可以看到现在集群内2台主机都有分配容器。&lt;br/&gt;&lt;strong&gt;Pod ip：&lt;/strong&gt;被docker0网桥隔离的pod子网的ip。K8s在每个Node里虚拟出的局域网。上图的IP列，就是每个pod ip，可以看到同一宿主机下Pod在同网段（后面我会介绍不同的node下的Pod，是如何借助flannel来实现跨主机通讯的）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# kubectl get svc
NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)     AGE
business-manager   ClusterIP   10.254.80.22     &amp;lt;none&amp;gt;        80/TCP      156m
data-product       ClusterIP   10.254.116.224   &amp;lt;none&amp;gt;        50051/TCP   159m
kubernetes         ClusterIP   10.254.0.1       &amp;lt;none&amp;gt;        443/TCP     5h8m&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Cluster ip：&lt;/strong&gt;k8s分配给每个service的全局唯一的虚拟ip，也可以叫VIP。VIP没有挂接到网络设备，不能直接访问。（后面会介绍这个ip的用处）&lt;/p&gt;
&lt;p&gt;除了上面的3个主要ip，集群里还有其他的一些特定的ip和网段：&lt;br/&gt;• DNS服务器：这里配置的是10.254.0.2:53&lt;br/&gt;• 10.254.0.0/16网段，是可配置的当前集群的网段，DNS和service的虚拟Ip正是处在这个网段里。&lt;/p&gt;

&lt;p&gt;在介绍Ingress和service这两个组件之前，我们先简单了解一下k8s节点之间的底层网络原理及典型的flannel-VXLAN方案。后面的章节，默认在节点之间的传输，都会有docker0网桥和flannel插件的功劳。（有资料提到K8S采用cni0网桥替代了docker0网桥，两者的原理是一样的，我搭建的环境里只有docker0网桥，所以我们按docker0来分析）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# kubectl get po -o wide
NAME                                READY   STATUS    RESTARTS   AGE     IP            NODE        
business-manager-666f454f7f-7l86b   1/1     Running   1          11m     172.30.76.7   192.168.0.21
business-manager-666f454f7f-h5tvw   1/1     Running   1          11m     172.30.76.6   192.168.0.21
business-manager-666f454f7f-zxmsx   1/1     Running   0          8s      172.30.9.3    192.168.0.22
data-product-6664c6dcb9-4zk27       1/1     Running   1          11m     172.30.76.5   192.168.0.21
data-product-6664c6dcb9-7bn7p       1/1     Running   1          11m     172.30.76.3   192.168.0.21
data-product-6664c6dcb9-tkmms       1/1     Running   0          5m39s   172.30.9.2    192.168.0.22&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家注意到没有，每个pod具备不同的Ip（这里指k8s集群内可访问的虚拟ip），不同node下的pod甚至在不同的网段。那么问题来了，集群内不同IP、不同网段的节点是怎么实现通讯的呢？这样归功于docker0和flannel.1这两个虚拟网络设备，我们先ifconfig查看一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# ifconfig
docker0: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu 1450
        inet 172.30.76.1  netmask 255.255.255.0  broadcast 172.30.76.255
        inet6 fe80::42:67ff:fe05:b530  prefixlen 64  scopeid 0x20&amp;lt;link&amp;gt;
        ether 02:42:67:05:b5:30  txqueuelen 0  (Ethernet)
        RX packets 31332  bytes 2136665 (2.0 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 21146  bytes 2125957 (2.0 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

eth0: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu 1500
        inet 192.168.0.21  netmask 255.255.255.0  broadcast 192.168.0.255
        inet6 fe80::d34:64ee:27c8:3713  prefixlen 64  scopeid 0x20&amp;lt;link&amp;gt;
        ether 00:15:5d:02:b2:00  txqueuelen 1000  (Ethernet)
        RX packets 1588685  bytes 265883182 (253.5 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1604521  bytes 211279156 (201.4 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

flannel.1: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu 1450
        inet 172.30.21.0  netmask 255.255.255.255  broadcast 0.0.0.0
        inet6 fe80::8822:81ff:fe5e:d8b7  prefixlen 64  scopeid 0x20&amp;lt;link&amp;gt;
        ether 8a:22:81:5e:d8:b7  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 8 overruns 0  carrier 0  collisions 0

...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;部署flannel和docker后，会在宿主机上创建上述两个网络设备。接下来我们通过一个示意图来了解这两个设备的工作：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1480383/201905/1480383-20190520120739616-1699277253.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;• K8s在每个宿主机(node)上创建了cni0网桥（这篇文档对应的集群环境采用的是docker0网桥，原理一样）：容器的网关，实际指向的是这个网桥。&lt;br/&gt;• Flannel则在每个宿主机上创建了一个VTEP（虚拟隧道端点）设备flannel.1。&lt;/p&gt;
&lt;p&gt;现在我们来分析下docker0和flannel.1是怎么实现跨主机通讯的（由node1的business-manager：172.30.76.7发往node2的data-product：172.30.9.2）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         gateway         0.0.0.0         UG    100    0        0 eth0
172.30.0.0      0.0.0.0         255.255.0.0     U     0      0        0 flannel.1
172.30.76.0     0.0.0.0         255.255.255.0   U     0      0        0 docker0
192.168.0.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;上图是node1的路由表：第2行表示凡是发往172.30.0.0/16网段的包均交给node1-flannel.1设备处理；第3行表示凡是发往172.30.76.0/8网段的包均交给node1-docker0网桥处理。&lt;/li&gt;
&lt;li&gt;于是business- manager的请求，首先到达node1-docker0网桥，目的地址是172.30.9.2，只能匹配第2条规则，请求被交给node1-flannel.1设备。&lt;/li&gt;
&lt;li&gt;node1-flannel.1又如何处理呢？请看下图，展示的是flannel.1的ARP表：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;# ip neigh show dev flannel.1
172.30.9.2 lladdr 96:8f:2d:49:c5:31 REACHABLE
172.30.9.1 lladdr 96:8f:2d:49:c5:31 REACHABLE
172.30.9.0 lladdr 96:8f:2d:49:c5:31 STALE&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;node1-flannel.1的ARP表记录的是ip和对应节点上的flannel.1设备mac的映射。于是发往172.30.9.2匹配到了上述第1条规则，需要发往mac地址为96:8f:2d:49:c5:31的设备。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;# bridge fdb show flannel.1 |grep 96:8f:2d:49:c5:31
96:8f:2d:49:c5:31 dev flannel.1 dst 192.168.0.22 self permanent&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;这时候node1-flannel.1设备又扮演一个网桥的角色，上图为node1上查询出的桥接规则，96:8f:2d:49:c5:31的目的ip对应于192.168.0.22，这正是我们这个例子里node2的宿主机Ip。于是这个请求被转发给了node2。&lt;/li&gt;
&lt;li&gt;不难理解，node2也有一个像第1步那样的路由表，于是来自node1-business-manager：172.30.76.7的请求最终经node2-docker0送达node2-data-product：172.30.9.2。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;• 随着node和pod加入和退出集群，flannel进程会从ETCD感知相应的变化，并及时更新上面的规则。&lt;br/&gt;• 现在我们已实现通过ip访问pod，但pod的ip随着k8s调度会变化，不可能隔三差五的去人工更新每个ip配置吧，这就需要service这个组件了，请看下一章。&lt;/p&gt;

&lt;h2 id=&quot;service&quot;&gt;4.1 service&lt;/h2&gt;
&lt;p&gt;pod的ip不是固定的，而且同一服务的多个pod需要有负载均衡，这正是创建service的目的。&lt;br/&gt;Service是由kube-proxy组件和iptables来共同实现的。&lt;br/&gt;分析service原理前，大家可以先带上这个问题：service的ip为什么ping不通？&lt;br/&gt;OK，我们现在直接上图，随便一个node的iptables（内容比较丰富，我随便截了几段，下文会挑几个重要的规则展开分析）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# iptables-save
...
-A KUBE-FIREWALL -m comment --comment &quot;kubernetes firewall for dropping marked packets&quot; -m mark --mark 0x8000/0x8000 -j DROP
-A KUBE-FORWARD -m comment --comment &quot;kubernetes forwarding rules&quot; -m mark --mark 0x4000/0x4000 -j ACCEPT
-A KUBE-FORWARD -s 10.254.0.0/16 -m comment --comment &quot;kubernetes forwarding conntrack pod source rule&quot; -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A KUBE-FORWARD -d 10.254.0.0/16 -m comment --comment &quot;kubernetes forwarding conntrack pod destination rule&quot; -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A KUBE-SERVICES -d 10.254.0.2/32 -p tcp -m comment --comment &quot;kube-system/kube-dns:dns-tcp has no endpoints&quot; -m tcp --dport 53 -j REJECT --reject-with icmp-port-unreachable
-A KUBE-SERVICES -d 10.254.0.2/32 -p udp -m comment --comment &quot;kube-system/kube-dns:dns has no endpoints&quot; -m udp --dport 53 -j REJECT --reject-with icmp-port-unreachable
...
-A KUBE-MARK-DROP -j MARK --set-xmark 0x8000/0x8000
-A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000
-A KUBE-POSTROUTING -m comment --comment &quot;kubernetes service traffic requiring SNAT&quot; -m mark --mark 0x4000/0x4000 -j MASQUERADE
-A KUBE-SEP-CNIAJ35IU3EJ7UR6 -s 172.30.9.3/32 -j KUBE-MARK-MASQ
-A KUBE-SEP-CNIAJ35IU3EJ7UR6 -p tcp -m tcp -j DNAT --to-destination 172.30.9.3:8080
-A KUBE-SEP-DGXT5Z3WOYVLBGRM -s 172.30.76.3/32 -j KUBE-MARK-MASQ
-A KUBE-SEP-DGXT5Z3WOYVLBGRM -p tcp -m tcp -j DNAT --to-destination 172.30.76.3:50051
...
-A KUBE-SERVICES -d 10.254.80.22/32 -p tcp -m comment --comment &quot;default/business-manager:business-manager cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-FZ5DC5B5DCQ4E7RC
-A KUBE-SERVICES -m comment --comment &quot;kubernetes service nodeports; NOTE: this must be the last rule in this chain&quot; -m addrtype --dst-type LOCAL -j KUBE-NODEPORTS
-A KUBE-SVC-45TXGSBX3LGQQRTB -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-DGXT5Z3WOYVLBGRM
-A KUBE-SVC-45TXGSBX3LGQQRTB -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-P6GCAAVN4MLBXK7I
-A KUBE-SVC-45TXGSBX3LGQQRTB -j KUBE-SEP-QFJ7ESRM37V67WJQ
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在可以回答service ip ping不通的问题了，因为service不是真实存在的（没有挂接具体的网络设备），而是由上图这些iptables规则组成的一个虚拟的服务。&lt;br/&gt;• Iptables是linux内核提供给用户的可配置的网络层防火墙规则，内核在解析网络层ip数据包时，会加入相应的检查点，匹配iptables定义的规则。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# kubectl get svc
NAME               TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)     AGE
business-manager   ClusterIP   10.254.80.22     &amp;lt;none&amp;gt;        80/TCP      3h28m
data-product       ClusterIP   10.254.116.224   &amp;lt;none&amp;gt;        50051/TCP   3h32m
kubernetes         ClusterIP   10.254.0.1       &amp;lt;none&amp;gt;        443/TCP     6h&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;• 我们还是看第3章的例子，business-manager要访问data-product，于是往service-data-product的ip和port（10.254.116.224:50051）发送请求。&lt;strong&gt;每个service对象被创建时，k8s均会分配一个集群内唯一的ip给它，并且该ip伴随service的生命周期不会变化，这就解决了本节开篇的Pod ip不固定的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-A KUBE-SERVICES -d 10.254.116.224/32 -p tcp -m comment --comment &quot;default/data-product:data-product cluster IP&quot; -m tcp --dport 50051 -j KUBE-SVC-45TXGSBX3LGQQRTB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;• &lt;strong&gt;KUBE-SERVICES：&lt;/strong&gt;Iptables表里存在上面这条规则，表示发往10.254.116.224:50051的数据包，跳转到KUBE-SVC-45TXGSBX3LGQQRTB规则。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-A KUBE-SVC-45TXGSBX3LGQQRTB -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-DGXT5Z3WOYVLBGRM
-A KUBE-SVC-45TXGSBX3LGQQRTB -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-P6GCAAVN4MLBXK7I
-A KUBE-SVC-45TXGSBX3LGQQRTB -j KUBE-SEP-QFJ7ESRM37V67WJQ&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;• &lt;strong&gt;KUBE-SVC-xxx：&lt;/strong&gt;这条规则，实际上是一条规则链，data-product我建了3个pod，所以这条规则链对应的正是这3个pod。这里是service负载均衡的关键实现，第1条规则表示采用随机模式，有1/3(33%)的概率跳转到KUBE-SEP-DGXT5Z3WOYVLBGRM；第2条规则的概率是1/2(50%)；第3条则直接跳转。这里有个需要注意的地方，iptables是顺序往下匹配的，所以多节点随机算法，概率是递增的，以data-product为例，我配置了3个Pod，就有3条规则，第1条被选中的概率为1/3，第2条则为1/2，最后1条没得挑了，概率配置为1或直接跳转。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-A KUBE-SEP-P6GCAAVN4MLBXK7I -s 172.30.76.5/32 -j KUBE-MARK-MASQ
-A KUBE-SEP-P6GCAAVN4MLBXK7I -p tcp -m tcp -j DNAT --to-destination 172.30.76.5:50051&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;• &lt;strong&gt;KUBE-SEP-xxx：&lt;/strong&gt;假设随机到第2条KUBE-SEP-P6GCAAVN4MLBXK7I，这里又是两条规则。第1条是给转发的数据包加标签Mark，目的是在集群多入口的场景下，保证数据包从哪进来的就从哪个node返回给客户端，详细原理就不展开说了。同时这里还涉及到一个技术点，经过service转发的数据包，pod只能追查到转发的service所在的Node，如果有场景需要Pod明确知道外部client的源Ip，可以借用service的spec.externalTrafficPolicy=local字段实现。&lt;br/&gt;• &lt;strong&gt;KUBE-SEP-xxx：&lt;/strong&gt;第2条规则就很简单了，数据包转发给172.30.76.5:50051，这里已经拿到pod的ip和port，可以通过第3章的docker0和flannel.1网络进行通信了。&lt;/p&gt;
&lt;p&gt;上面是基于iptables的service方案，存在一个风险，当pod数量很大，几百、几千时，遍历iptables将会是性能瓶颈。IPVS虚拟网卡技术在大量级的pod场景下表现比iptables优秀（运维的同事反馈11版本的k8s，官方已默认采用IPVS）。这不属于本文档的目的，不展开说。&lt;br/&gt;本节开头我们提到service是由kube-proxy和iptables共同实现的，所以Kube-proxy所扮演的角色就不难想象了，kube-proxy负责感知集群的变化，及时更新service的规则。&lt;/p&gt;
&lt;p&gt;最后，我们还面临着一个小问题，上面的过程是基于服务的VIP的访问服务的，通过服务名的方式访问又是怎么实现的呢，请看下一节：DNS&lt;/p&gt;
&lt;h2 id=&quot;dns&quot;&gt;4.2 DNS&lt;/h2&gt;
&lt;p&gt;本来写这个文档没想到要有DNS这一章节的，但集群搭建好之后发现通过服务名无法访问服务，通过VIP却可以，才想起来集群还需要额外搭个DNS组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# kubectl get po -n kube-system
NAME                        READY   STATUS             RESTARTS   AGE
kube-dns-7cd94476cd-kr76t   4/4     Running            0          25s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DNS组件是跑在kube-system命名空间下的一个pod，监听着集群ip：10.254.0.2:53。通过这个Ip:port（创建kubelet时指定DNS的ip）即可获取到集群内部的DNS解析服务。&lt;br/&gt;现在我们随便进入一个pod里，可以看到dns的信息已被k8s写入。同时我们ping一个service：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cat /etc/resolv.conf
nameserver 10.254.0.2
search default.svc.cluster.local svc.cluster.local cluster.local
options ndots:5
# ping data-product.default.svc.cluster.local
PING data-product.default.svc.cluster.local (10.254.116.224) 56(84) bytes of data.
^C
--- data-product.default.svc.cluster.local ping statistics ---
3 packets transmitted, 0 received, 100% packet loss, time 1999ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然是ping不通的，但vip已经被解析出来了。&lt;br/&gt;Kubenetes可以为pod提供稳定的DNS名字，且这个名字可通过pod名和service名拼接出来，以上面的data-product为例，该服务的完整域名是[服务名].[命名空间].svc.[集群名称]。相应的，每个pod也有类似规则的域名。&lt;/p&gt;

&lt;h2 id=&quot;外部访问service&quot;&gt;5.1 外部访问service&lt;/h2&gt;
&lt;p&gt;Service代理的是集群内部的ip和端口，出了集群这个ip:port就没什么意义了。所以如何在集群外部访问到service呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式一：配置service的type=NodePort&lt;/strong&gt;，此方式下k8s会给service做端口映射。这种方式是最常用的，我们DEV环境下很多service做了端口映射，可以通过宿主机Ip加映射出去的端口号直接访问服务。这种方式的原理简单，kube-proxy只需要在iptables里增加一条规则，将外部端口的包导向第4章的service规则去处理即可。（下一节要讲的ingress，正是这种方式的一种更细致的实现）&lt;br/&gt;&lt;strong&gt;方式二：type=LoadBalancer&lt;/strong&gt;，适用于公有云提供的K8s环境，此时K8s使用一个叫作CloudProvider的转接层与公有云的API交互，并由公有云API来实现负载均衡。&lt;br/&gt;&lt;strong&gt;方式三：type=ExternalName&lt;/strong&gt;，这个方式的用法我还没搞清楚。&lt;/p&gt;
&lt;p&gt;按前面章节的套路，这里我们依然会面临一个小问题，把外部需要访问的服务大量的通过端口映射方式暴露出去，势必给端口的管理带来麻烦。所以，接下来我们看看ingress是怎么作为集群的入口，帮我们管理后端服务的。&lt;/p&gt;
&lt;h2 id=&quot;ingress&quot;&gt;5.2 ingress&lt;/h2&gt;
&lt;p&gt;4.2章节，在集群内部我们实现了通过域名（服务名）获取具体的服务vip，从而免去了管理Vip烦恼。那么从外部访问集群的服务，又如何实现通过域名的方式呢？后端的服务有很多，我们也需要一个全局的负载均衡器来管理后面服务。这就是ingress。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# kubectl get po -n ingress-nginx
NAME                                       READY   STATUS    RESTARTS   AGE
nginx-ingress-controller-546bfbff9-hpwsz   1/1     Running   0          84s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;• 使用ingress，我们除了要创建ingress对象以外，还需要安装一个ingress-controller，这里我们选择最常用的nginx-ingress-controller。如上所示，安装之后，会增加一个ingress-nginx命名空间，运行着nginx-ingress-controller容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# kubectl exec -ti nginx-ingress-controller-546bfbff9-hpwsz sh -n ingress-nginx
$ more /etc/nginx/nginx.conf
...
## start server data-product
    server {
        server_name data-product ;
        listen 80;
        set $proxy_upstream_name &quot;-&quot;;
        location / {
            set $namespace      &quot;default&quot;;
            set $ingress_name   &quot;data-product&quot;;
            set $service_name   &quot;data-product&quot;;
            set $service_port   &quot;50051&quot;;
            set $location_path  &quot;/&quot;;
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;• 当Ingress对象被创建时，nginx-ingress-controller会在这个nginx容器内部生成一个配置文件/etc/nginx/nginx.conf（内容比较丰富，上图我截了一小段，可以看到data-product.default的主要配置），并用这个文件启动nginx服务。当ingress对象被更新时，nginx-ingress-controller会实现nginx服务的动态更新。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cat ing.yaml 
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name:  business-user
  namespace: ns-jo
  annotations:
    kubernetes.io/ingress.class: &quot;nginx&quot;
spec:
  rules:
  - host:  business-user.ns-jo
    http:
      paths:
      - path: /
        backend:
          serviceName: business-user
          servicePort: 80&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;• Nginx服务的功能：随便找一个ingress文件查看，rules字段包含一组域名、路径、后端服务名、服务端口的映射，这就是个反向代理的配置文件。当前我们用nginx做反向代理，以及将请求负载给后端的service。加上证书，nginx还可以解析https，给后端依然是http明文通信&lt;/p&gt;
&lt;p&gt;现在又面临一个小问题了，这个nginx服务居然运行在容器里，参考5.1章节，这个服务外部还是访问不了啊？所以安装nginx-ingress-controller时还需要创建一个服务，将这个pod里的nginx服务监听的80和443端口暴露出去。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# kubectl describe svc ingress-nginx -n ingress-nginx
Name:                     ingress-nginx
Namespace:                ingress-nginx
Labels:                   app.kubernetes.io/name=ingress-nginx
                          app.kubernetes.io/part-of=ingress-nginx
Annotations:              &amp;lt;none&amp;gt;
Selector:                 app.kubernetes.io/name=ingress-nginx,app.kubernetes.io/part-of=ingress-nginx
Type:                     NodePort
IP:                       10.254.189.164
Port:                     http  80/TCP
TargetPort:               80/TCP
NodePort:                 http  30799/TCP
Endpoints:                172.30.76.2:80
Port:                     https  443/TCP
TargetPort:               443/TCP
NodePort:                 https  31522/TCP
Endpoints:                172.30.76.2:443
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   &amp;lt;none&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这个服务，正是ingress-nginx的SVC，它向外暴露的端口(NodePort)是30799和31522，对应的endpoints正是nginx容器里的nginx服务监听的两个端口80和433。这个ingress-service加上ingress-nginx容器，共同组成了ingress。所以广义上，ingress提供的是集群入口服务，是一个虚拟的概念。不考虑具体的功能的话，business层以NodePort方式运作时，就可以看作business层就是data层的ingress。&lt;/p&gt;
&lt;p&gt;现在我们可以用business-manager.default:30799/api/v1/product/list来发起请求。&lt;/p&gt;

&lt;p&gt;原理分析的再多再深入，最终还是希望能够为我们的工作提供一些帮助。所以下面的篇幅我记录了在分析过程中看到或是想到的可能有助于我们实际工作的思路，限于精力有限，这些思路我暂时还没有完整验证过，同学们有兴趣的话可以参与进来。&lt;/p&gt;
&lt;h2 id=&quot;附a-用service实现db的管理&quot;&gt;附A 用service实现DB的管理&lt;/h2&gt;
&lt;p&gt;当前DB的ip和端口是配置在每个应用的configmap里的，如果出现DB切换、迁移等因素导致IP或端口变更，我们需要挨个去修改每个应用的config。&lt;br/&gt;K8s支持指定service的endpoints为一个特定的点，比如可以指定为DB的IP和端口。这样我们可以创建两个service：service-DB-read，和service-DB-write。由service来管理DB的IP和PORT，变更只需要修改这两个service的config即可。由4.1章节的分析我们知道，应用访问上述两个service，数据包会被转发给endpoints也就是真正的db。&lt;/p&gt;
&lt;p&gt;请见下图，Endpoints指向集群外部数据库的service-mysql：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# kubectl describe svc mysql
Name:              mysql
Namespace:         default
Labels:            &amp;lt;none&amp;gt;
Annotations:       &amp;lt;none&amp;gt;
Selector:          &amp;lt;none&amp;gt;
Type:              ClusterIP
IP:                10.254.84.209
Port:              &amp;lt;unset&amp;gt;  3306/TCP
TargetPort:        3306/TCP
Endpoints:         192.168.0.103:3306
Session Affinity:  None
Events:            &amp;lt;none&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用层通过访问service-mysql，流量最终会到达endpoints也就是集群外部的真实数据库的ip:port。细心的同学应该能想到，这玩意可以用于简单的数据库负载均衡，比如有多个读库的情况下，我们只需要让service-mysql的endpoints指向这几个读库，流量即能被负载均衡到各个库。&lt;/p&gt;
&lt;h2 id=&quot;附b-用networkpolicy实现访问权限隔离&quot;&gt;附B 用NetworkPolicy实现访问权限隔离&lt;/h2&gt;
&lt;p&gt;以DB为例，当前集群的DB对所有pod开放，那有没有办法限制访问权限呢，比如只允许data层访问。回想第4.1章节service的本质是iptables规则，那么就有可能通过iptables实现更细致的规则，比如DB的访问权限管理。这就是k8s的NetworkPolicy，支持以pod的标签的形式制定相应的iptables规则。目前flannel网络插件不支持NetworkPolicy，flannel + Calico插件可以实现。&lt;/p&gt;
&lt;h2 id=&quot;附c-用secret对象管理账户密码&quot;&gt;附C 用secret对象管理账户密码&lt;/h2&gt;
</description>
<pubDate>Mon, 20 May 2019 04:08:00 +0000</pubDate>
<dc:creator>Jo_ZSM</dc:creator>
<og:description>[TOC] 1 典型的数据传输流程图 • 一个外部的business manager请求，首先进入集群的入口（ingress），ingress反向代理后负载到business manager的serv</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JoZSM/p/10893460.html</dc:identifier>
</item>
<item>
<title>聊聊Java里常用的并发集合 - 深夜里的程序猿</title>
<link>http://www.cnblogs.com/coding-night/p/10893410.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coding-night/p/10893410.html</guid>
<description>&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt; &lt;/h3&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;在我们的程序开发过程中，如果涉及到多线程环境，那么对于集合框架的使用就必须更加谨慎了，因为大部分的集合类在不施加额外控制的情况下直接在并发环境中直接使用可能会出现数据不一致的问题，所以为了解决这个潜在的问题，我们要么在自己的业务逻辑中加上一些额外的控制，例如&lt;code&gt;锁&lt;/code&gt;，或者我们直接使用Java提供的可在并发环境中使用的集合类,这是一个简便而且高效的方法。那么我们下面就来了解下Java提供了哪些“神器”可以让我们安全的使用集合。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;正文&lt;/h3&gt;

&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;非阻塞式安全列表 - ConcurrentLinkedDeque&lt;/h4&gt;
&lt;p&gt;ConcurrentLinkedDeque可以在并发环境中直接使用，所谓的非阻塞，就是当列表为空的时候，我们还继续从列表中取数据的话，它会直接返回null或者抛出异常。下面列出来一些常用的方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;peekFirst()&lt;/code&gt;、&lt;code&gt;peekLast()&lt;/code&gt; ：返回列表中首位跟末尾元素，如果列表为空则返回null。返回的元素不从列表中删除。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getFirst()&lt;/code&gt;、&lt;code&gt;getLast()&lt;/code&gt; ：返回列表中首位跟末尾元素，如果列表为空则抛出&lt;code&gt;NoSuchElementExceotion&lt;/code&gt;异常。返回的元素不从列表中删除。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;removeFirst()&lt;/code&gt;、&lt;code&gt;removeLast()&lt;/code&gt; ：返回列表中首位跟末尾元素，如果列表为空则抛出&lt;code&gt;NoSuchElementExceotion&lt;/code&gt;异常。【返回的元素会从列表中删除】。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt; &lt;/h4&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;阻塞式安全列表 - LinkedBlockingDeque&lt;/h4&gt;
&lt;p&gt;LinkedBlockingDeque是一个阻塞式的线程安全列表，它跟 ConcurrentLinkedDeque最大的区别就是，当列表中元素满了或者为空的时候，我们对该列表的操作不会立即返回，而是阻塞当前操作，直到该操作可以执行时才返回。我们对比着上面ConcurrentLinkedDeque的常用方法，来看下LinkedBlockingDeque会有哪些不一致的地方呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;put()&lt;/code&gt; ：插入元素至列表中，当表中元素已满的时候，该操作将会被阻塞，直到表中存在空余空间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;take()&lt;/code&gt; : 从列表中获取元素，当列表为空，该操作会被阻塞，直到列表不为空。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;peekFirst()&lt;/code&gt;、&lt;code&gt;peekLast()&lt;/code&gt; ：返回列表中首位跟末尾元素，如果列表为空则返回null。返回的元素不从列表中删除。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getFirst()&lt;/code&gt;、&lt;code&gt;getLast()&lt;/code&gt; ：返回列表中首位跟末尾元素，如果列表为空则抛出&lt;code&gt;NoSuchElementExceotion&lt;/code&gt;异常。返回的元素不从列表中删除。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addFirst()&lt;/code&gt;、&lt;code&gt;addLast()&lt;/code&gt; ：将元素添加至首位跟末尾，如果列表已满，则会抛出&lt;code&gt;IllegalStateException&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看出不管是从获取还是插入元素，都多了不少“花样”，其差别就在于是否阻塞，不满足条件是否返回null，不满足条件是否抛异常这几个方面来区分。&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt; &lt;/h4&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;优先级排序阻塞式安全列表 - PriorityBlockingQueue&lt;/h4&gt;
&lt;p&gt;相信大家都写过把某个列表元素按照特定的规则来排序之类的代码，在&lt;code&gt;PriorityBlockingQueue&lt;/code&gt;中，存放进去的元素必须要实现Comparable接口。在这个接口中，有一个&lt;code&gt;compareTo()&lt;/code&gt;方法,当执行该方法的对象跟参数传入的对象进行比较的时候，这个方法会返回一个数字值，如果值小于0，则当前对象小于参数传入对象。大于0则相反，等于0就表示两个对象相等。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DemoObj &lt;span&gt;implements&lt;/span&gt; Comparable&amp;lt;DemoObj&amp;gt;&lt;span&gt; {
   
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; priority;
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; compareTo(DemoObj &lt;span&gt;do&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.getPriority() &amp;gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;.getPriority()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.getPriority() &amp;lt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;.getPriority()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略getset ...&lt;/span&gt;
&lt;span&gt;}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;==== use ===================&lt;/span&gt;
&lt;span&gt;
PriorityBlockingQueue&lt;/span&gt;&amp;lt;DemoObj&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; PriorityBlockingQueue()&amp;lt;&amp;gt;&lt;span&gt;;
queue.put(DemoObj);
queue.peek();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其常用方法跟上面提到的类基本都差不多大家可以动手实现一下，简单对比的话，可以说是LinkedBlockingDeque的增强版，多了元素排序功能。&lt;/p&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt; &lt;/h4&gt;
&lt;h4 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;延迟元素线程安全列表 - DelayQueue&lt;/h4&gt;
&lt;p&gt;DelayQueue 里面存放着带有日期的元素，当我们从列表获取数据的时候，未到时间的元素将会被忽略。因此，存放进来的元素必须实现Delayed接口，使之成为一个延迟对象。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *  compareTo方法与getDelay方法需排序一致
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Order &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Delayed{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name ;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time ;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyDelayedTask(String name,&lt;span&gt;long&lt;/span&gt;&lt;span&gt; time) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.time =&lt;span&gt; time;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 需要实现的接口，获得延迟时间   用过期时间-当前时间
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; unit
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getDelay(TimeUnit unit) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; unit.convert((start+time) -&lt;span&gt; System.currentTimeMillis(),TimeUnit.MILLISECONDS);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 延迟队列内部排序   当前对象延迟时间 - 入参对象的延迟时间
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; o
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(Delayed o) {
        Order o1 &lt;/span&gt;=&lt;span&gt; (Order) o;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;) (&lt;span&gt;this&lt;/span&gt;.getDelay(TimeUnit.MILLISECONDS) -&lt;span&gt; o1.getDelay(TimeUnit.MILLISECONDS));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用方式如下&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DelayQueue delayQueue  = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DelayQueue();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

                delayQueue.offer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Order(&quot;t3000&quot;,3000&lt;span&gt;));
                delayQueue.offer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Order(&quot;t4000&quot;,4000&lt;span&gt;));
                delayQueue.offer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Order(&quot;t2000&quot;,2000&lt;span&gt;));
                delayQueue.offer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Order(&quot;t6000&quot;,6000&lt;span&gt;));
                delayQueue.offer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Order(&quot;t1000&quot;,1000&lt;span&gt;));

            }
        }).start();

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            Delayed take &lt;/span&gt;=&lt;span&gt; delayQueue.take();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于结果的输出大家可以动手尝试一下~&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt; &lt;/h3&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;这里仅仅是介绍了几种常用的并发集合，其目的主要是让大家对这些集合有一个直观的认识，在使用的时候可以思考下自己的场景用哪种更合适，如果当前介绍的类没合适的，那么是否还有其他并发集合会更有用呢？这里就当做抛砖引玉吧，有兴趣的朋友可以多去了解一下相关技术，相信你会有不少收获的。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;公众号博文同步Github仓库，有兴趣的朋友可以帮忙给个Star哦，码字不易，感谢支持。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/PeppaLittlePig/blog-wechat&quot;&gt;https://github.com/PeppaLittlePig/blog-wechat&lt;/a&gt;&lt;a href=&quot;https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FPeppaLittlePig%2Fblog-wechat&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;《&lt;a href=&quot;https://www.cnblogs.com/coding-night/p/10794391.html&quot; target=&quot;_blank&quot;&gt;如何优化代码中大量的if/else,switch/case?&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/coding-night/p/10772631.html&quot;&gt;如何提高使用Java反射的效率？&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDA4MjQyNQ==&amp;amp;mid=2465729631&amp;amp;idx=1&amp;amp;sn=42a0da4f030357f4607c93e842d99dbe&amp;amp;chksm=b14698498631115f00949cae8d058f8bb87583988458718f7b62258996d36e6f11764bd93993&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Java日志正确使用姿势&lt;/a&gt;》&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;span&gt;有收获的话，就点个赞吧&lt;/span&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关注「深夜里的程序猿」，分享最干的干货&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/center&gt;


&lt;p&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/4/17/16a28c18805b08e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; width=&quot;163&quot; height=&quot;163&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/4/17/16a28c18805b08e1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;200&quot; data-height=&quot;200&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 03:59:00 +0000</pubDate>
<dc:creator>深夜里的程序猿</dc:creator>
<og:description>前言 在我们的程序开发过程中，如果涉及到多线程环境，那么对于集合框架的使用就必须更加谨慎了，因为大部分的集合类在不施加额外控制的情况下直接在并发环境中直接使用可能会出现数据不一致的问题，所以为了解决这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coding-night/p/10893410.html</dc:identifier>
</item>
<item>
<title>阿里是如何处理分布式事务的 - 春哥大魔王</title>
<link>http://www.cnblogs.com/xiguain/p/10893231.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiguain/p/10893231.html</guid>
<description>&lt;p&gt;分布式事务中的TCC模式，貌似是阿里提出来的，所以阿里自研的分布式事务框架总是少不了TCC的影子。&lt;/p&gt;
&lt;h2 id=&quot;服务拆分&quot;&gt;服务拆分&lt;/h2&gt;
&lt;p&gt;很多系统早期都是单系统服务架构，所有业务聚合在少数几个系统中对外提供服务。随着业务发展，服务之间耦合比较严重，一般会对服务进行重构，重构的主要思想也就是围绕“拆分”展开。&lt;/p&gt;
&lt;p&gt;比如按照功能进行解耦的垂直拆分，拆分之后原有系统中的业务调用，就变成了分布式的调用了，但是由于网络的不可靠性，数据一致性问题，可扩展性问题，高可用容灾问题成为分布式事务的主要挑战。而对于在服务之间数据交付的时候容易造成的数据不一致问题，一般需要引入分布式事务对数据一致性做控制。&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/b9c5cbda6f13424c6cad2dcd70a05bdbe70.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单系统到微服务拆分的过程，是一个资源横向扩展的过程，当单台机器资源无法承担更大的请求时，可以多台机器形成集群。&lt;/p&gt;
&lt;p&gt;资源拆分主要有两个执行方向：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;按业务拆分，也就是将数据按照业务分组，将不同服务的数据放到不同的存储上，类似于soa架构下的服务化，已业务单元为核心。&lt;/li&gt;
&lt;li&gt;按数据拆分，也就是常说的数据分片，按照横向扩展纬度，将单个DB拆分成多个DB，数据存储具备统一的Sharding功能，达到资源横向扩展，承担更高的吞吐。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;seata模式&quot;&gt;Seata模式&lt;/h2&gt;
&lt;p&gt;Seata关注的是微服务架构下的数据一致性问题，是整套的分布式事务解决方案。Seata框架包含两种模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AT模式，关注的是数据分片角度，关注DB访问的数据一致性，多服务下多DB数据访问的一致性&lt;/li&gt;
&lt;li&gt;TCC模式，TCC模式主要是围绕业务拆分展开，当业务在横向扩展资源时，解决了服务之间调用的一致性，保证资源访问的事务性&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;at模式&quot;&gt;AT模式&lt;/h2&gt;
&lt;p&gt;AT模式下会把每个DB当作一个Resource，数据库就是 DataSource Resource。业务通过标准的JDBC接口访问数据库资源，Seata框架会对所有请求进行拦截，做事务操作。&lt;/p&gt;
&lt;p&gt;在每个事务提交时，Seata Resource Manager（RM 资源管理器）都会向Transaction Coorrdinator（TC 事务协调器）注册一个分支事务。&lt;/p&gt;
&lt;p&gt;当请求链路调用完成后，发起方通知TC事务提交或者进行事务回滚，进入两阶段提交调用流程。&lt;/p&gt;
&lt;p&gt;二阶段操作时，TC根据之前注册的分支事务回调对应参与者去执行对应资源的第二阶段。&lt;/p&gt;
&lt;p&gt;每个资源都有全局唯一的资源ID，在初始化时用这个ID向TC注册，之后的事务协调过程中，TC就可以根据事务ID找到事务和资源的对应关系。事务协调过程中，每个事务的注册都会携带这个资源ID，这样TC可以通过资源ID在第二阶段调用时找到正确的资源了。&lt;/p&gt;
&lt;p&gt;简单来说AT模式，就是把数据库当作一个Resource，本地事务提交时会去注册一个分支事务。&lt;/p&gt;
&lt;h2 id=&quot;tcc模式&quot;&gt;TCC模式&lt;/h2&gt;
&lt;p&gt;在Seata框架中，每组TCC接口当作一个Resource，称为TCC Resource。当然一组TCC接口可以是RPC，也可以是服务内JVM调用。&lt;/p&gt;
&lt;p&gt;业务启动时，Seata框架自动扫描识别到对应的TCC接口及其调用方和发布方。&lt;/p&gt;
&lt;p&gt;如果是事务的发布方，会在业务启动时向TC注册TC Resource，类似于DataSource Resource，每个资源有唯一的全局资源ID。&lt;/p&gt;
&lt;p&gt;如果是事务的调用方，Seata框架给调用方加上切面，类似于AT模式，运行时拦截所有TCC接口调用。&lt;br/&gt;每调用一次Try接口，切面会先向TC注册一个分支事务，然后才会执行原有的RPC调用。&lt;br/&gt;当请求链路调用完成后，TC通过分支事务的资源ID回调正确的参与者去执行对应的TCC资源的Confirm或Cancel方法。&lt;/p&gt;
&lt;p&gt;了解了框架模型后，可以知道框架本身会扫描TCC接口，注册资源，拦截接口调用，注册分支事务，之后回调第二阶段接口。&lt;/p&gt;
&lt;p&gt;核心是TCC接口的实现逻辑。&lt;/p&gt;
&lt;h2 id=&quot;tcc接口实现&quot;&gt;TCC接口实现&lt;/h2&gt;
&lt;p&gt;在业务接入事务框架的TCC模式之后，大部分工作都是在考虑如何实现TCC服务上。&lt;/p&gt;
&lt;p&gt;设计TCC接口需要注意业务逻辑的拆解和资源调用的隔离。&lt;/p&gt;
&lt;h3 id=&quot;业务逻辑分解&quot;&gt;业务逻辑分解&lt;/h3&gt;
&lt;p&gt;需要将操作分成两阶段完成的方式，TCC=Try-Confirm-Cancel 相对于XA等传统模式，特征在于不依赖RM对分布式事务的支持，而是通过业务逻辑分解来实现分布式事务。&lt;/p&gt;
&lt;p&gt;TCC模式对于业务系统存在假设，其对外提供的服务需要接受一些不确定性，外部对于业务逻辑的调用首先是个临时操作，外部调用对于后续的业务处理保留取消权。如果业务调用认为全局事务应该回滚，就需要取消之前的临时操作。如果业务调用认为全局事务可以提交，就会放弃之前临时操作的取消权。初步的临时操作最后都会被确认或取消。&lt;/p&gt;
&lt;p&gt;TCC对假设抽象成以下逻辑：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初步操作Try：完成所有业务检查，预留必要的业务资源。&lt;/li&gt;
&lt;li&gt;确认操作Confirm：真正执行业务逻辑，不做任何检查，只使用Try阶段预留的业务资源。所以只要try成功，confirm必须成功。同时confirm需满足幂等性，因为框架面对不确定性普遍会进行重试，以保证事务提交并只成功一次。&lt;/li&gt;
&lt;li&gt;取消操作Cancel：释放Try阶段预留的资源，同样，cancel操作需要满足幂等性。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;资源调用隔离&quot;&gt;资源调用隔离&lt;/h3&gt;
&lt;p&gt;业务系统需要根据自身业务特点和业务模型控制并发，类似于ACID的隔离性。&lt;/p&gt;
&lt;p&gt;以金融核心链路的简化模型为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/f9c6c33e1fd5b0e49049b440d467e616d9a.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个账户或商户有一个账号及其可用余额。交易逻辑涉及到交易，充值，转账，退款等这些都是对账户进行加钱和扣钱。&lt;/p&gt;
&lt;p&gt;于是可以把账务系统拆分成两套TCC接口，两个TCC Resource，一个加钱TCC接口，一个扣钱TCC接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扣钱TCC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A转账30元给B，A的余额需要从100元减去30元，余额就是所谓的业务资源。&lt;/p&gt;
&lt;p&gt;按照TCC原则，第一阶段需要检查并预留业务资源：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查：在TCC资源的Try接口中检查A是否有足够的余额&lt;/li&gt;
&lt;li&gt;预留：然后预留余额紫玉啊，并扣除30元&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/d77b3660da086c9fcff7944c93343470b24.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于业务资源已经在第一阶段的try接口里面扣除了，第二阶段的confirm接口可以什么都不做，是个空实现。&lt;br/&gt;cancel接口需要把try接口里面扣除的30元还给账户，进行资源释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加钱TCC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一阶段的try接口不能直接给账户加钱，因为如果加钱之后，账户的余额就会被使用了。因此真正的加钱操作需要放到confirm接口中。&lt;br/&gt;第一阶段的try接口不需要预留任何资源，可以设计为空实现。&lt;br/&gt;Cancel接口没有资源需要释放，所以也可以是个空实现。&lt;br/&gt;真正提交时，执行confirm接口增加可用余额。&lt;/p&gt;
&lt;h2 id=&quot;事务并发控制&quot;&gt;事务并发控制&lt;/h2&gt;
&lt;p&gt;Seata框架本身提供两阶段原子提交，保证分布式事务原子性。事务的隔离则是交给了业务逻辑来实现。隔离的本质就是控制并发，防止并发事务操作相同资源引起结果错乱。&lt;/p&gt;
&lt;p&gt;以经典的转账为例，当用户发起交易时，首先检查用户资金，资金充足，扣除交易金额，增加卖家资金，完成交易。&lt;br/&gt;如果没有事务隔离，用户发起两笔交易，两笔交易都认为资金充足，实际上只够一笔交易，结果两笔交易都支付成功，导致资损。&lt;/p&gt;
&lt;p&gt;所以并发控制是业务逻辑正确执行的保证，如果采用基于数据库的两阶段锁控制并发访问，需要在事务中一直持有数据库资源锁到整个事务执行结束，如果在分布式架构下，锁需要持有到事务第二阶段结束，由于锁的持有时间过长，会导致并发能力的下降。&lt;/p&gt;
&lt;p&gt;因此TCC模式的隔离思想体现在通过业务改造实现。&lt;/p&gt;
&lt;p&gt;第一阶段结束之后，从底层数据库资源层面加锁过度到上层业务层面的加锁，从而降低底层数据库锁资源，放宽分布式事务锁协议，将锁粒度降到最低，更大限度提高并发性能。&lt;/p&gt;
&lt;p&gt;如果A账户有100元，事务T1需要扣除30元，事务T2需要扣除20元，出现了并发。&lt;br/&gt;TCC对于这种操作，在第一阶段Try操作中，需要利用数据库资源层面加锁，检查账户可用余额，如果余额充足，则预留业务资源，扣除本次交易金额，一阶段结束后，虽然数据库层面资源锁释放了，但是这笔资金被业务隔离，不允许本次事务之外的其他并发事务动用。&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/8d11eb20fa63e6bc00028d6820a921a5732.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事务T1结束之后释放数据库层面资源锁，事务T2可以发起自己的第一阶段操作，进行加锁，检查余额，扣除金额等操作。&lt;/p&gt;
&lt;p&gt;事务T1和事务T2分别扣除自己资金，相互直接不受干扰，这样在第二阶段时，无论T1是提交还是回滚都不会对T2产生影响，这样T1和T2就可以在同一个账户上并发执行了。&lt;/p&gt;
&lt;p&gt;所以第一阶段结束后，实际上采用业务加锁方式，隔离账户资金。第一阶段结束后，释放底层资源锁，用户和卖家的其他交易都可以立刻并发执行，而不用等到整个分布式事务结束。&lt;/p&gt;
&lt;h2 id=&quot;转账模型优化&quot;&gt;转账模型优化&lt;/h2&gt;
&lt;p&gt;在系统了解了TCC模型的思想后，可以对我们之前的转账模型进行优化了。&lt;/p&gt;
&lt;p&gt;真实项目中，为了更好的用户体验，第一阶段一般不会直接把账户的余额自动扣除，而是冻结，这样给用户展示的时候，可以清晰的知道，可用余额有哪些，冻结中金额有哪些。&lt;/p&gt;
&lt;p&gt;业务模型变成如下：&lt;br/&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/7cac474c1987ce6dbbfdc72ca026ac03e7f.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要在模型中增加冻结金额字段，用来表示账户中多少金额处于冻结状态。&lt;/p&gt;
&lt;p&gt;优化之后的TCC模型里面的扣钱TCC逻辑如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;try接口不再直接扣除账户可用余额，而是真正预留资源，冻结部分空用余额，也就相应减少了可用金额。&lt;/li&gt;
&lt;li&gt;confirm接口不再是空操作，而是使用try接口预留的业务资源，将冻结金额扣除。&lt;/li&gt;
&lt;li&gt;cancel接口中，释放预留资源，把try里面冻结的金额扣除，增加可用金额。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;加钱TCC逻辑不涉及冻结金额的使用，无需修改。&lt;/p&gt;
&lt;p&gt;优化后的模型可以规整的看到预留资源，使用资源，释放资源的过程。&lt;/p&gt;
&lt;p&gt;并发控制逻辑如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事务T1在第一阶段try操作中，先锁定账户，检查账户可用余额，如果余额充足，预留业务资源，减少可用金额，增加冻结金额。&lt;/li&gt;
&lt;li&gt;并发的事务T2，类似的需要加锁，检查余额，减少可用余额，增加冻结余额。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在第二阶段各自事务使用第一阶段try锁定的冻结金额资源即可。&lt;br/&gt;所以第一层面的是通过数据库层面的锁，预留业务资源，冻结金额。通过业务隔离方式将这部分资源加锁，不允许本地事务之外的其他并发事务调用，保证事务在第二阶段正确顺利执行。&lt;/p&gt;
&lt;p&gt;所以整个TCC模式核心是进行业务逻辑拆分，拆成两个阶段，try，confirm，cancel。try进行资源检查，资源预留，confirm使用资源，cancel接口释放预留资源。&lt;br/&gt;并发控制采用数据库锁和业务加锁组合方式实现，由于业务加锁特性不影响性能，可以降低数据库锁粒度，提高并发能力。&lt;/p&gt;
&lt;h2 id=&quot;tcc异常处理&quot;&gt;TCC异常处理&lt;/h2&gt;
&lt;p&gt;在面对分布式系统需要面对的网络超时，重发，宕机等不可用问题时，事务框架往往有不同的问题，最常见的有：空回滚，幂等，悬挂。&lt;/p&gt;
&lt;p&gt;因此在TCC接口里面需要处理这三类异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空回滚&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就是对于一个分布式事务，在没有调用TCC资源try方法的情况下，调用了第二阶段的cancel方法，cancel方法需要识别出这是一个空回滚，然后返回成功。&lt;/p&gt;
&lt;p&gt;什么情况会返回空回滚呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/55e8c51470cee34d7bc68df907dc15c09de.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在进行RPC调用时，Seata框架会进行切面拦截请求，进行分支事务注册，先向TC注册分布式事务，然后执行RPC调用逻辑。&lt;br/&gt;如果RPC调用逻辑有问题，比如调用方机器宕机，网络异常，会造成RPC调用失败，也就是未能成功执行Try方法。但事务已经开启，需要推进到终态，因此TC会回调第二阶段cancel接口，从而形成空回滚。&lt;/p&gt;
&lt;p&gt;解决空回滚需要额外的一个事务控制表，其中有分布式事务id和分支事务id，第一阶段try方法里面插入一条记录，表示一阶段执行了。cancel接口读取该记录，如果记录存在，正常回滚。如果记录不存在，执行空回滚。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;幂等&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务框架里面幂等的目的是为了解决，同一个分布式事务里面同一个分支事务，调用该分支事务的第二阶段接口，因此TCC里面的二阶段提交的confirm和cancel接口需要保证幂等，不会重发使用或者释放资源。幂等控制没有做好的话，很有可能导致资损等问题。&lt;/p&gt;
&lt;p&gt;什么样情况会造成重复提交呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/78b29e5391b863a76125ec1c04651218227.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提交或回滚是一次TC到参与者网络的调用。因此，网络故障，参与者宕机等都有可能造成参与者TCC资源实际执行第二阶段方法，但是TC没有收到返回结果的情况，这是TC会重复调用，直到调用成功，整个分布式事务结束。&lt;/p&gt;
&lt;p&gt;解决重复执行幂等问题的思路是，可以记录每个分支事务的执行状态，在执行前状态，如果执行已执行，就不再执行。否则，正常执行。&lt;/p&gt;
&lt;p&gt;参照事务控制表，事务控制表的每条记录关联一个分支事务，可以在这张事务控制表增加一个状态字段，用来记录每个分支事务的执行状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/92081b6c1fb825992630d96134bdfa09415.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该状态字段有三个值，分别是初始化，已提交，已回滚。&lt;br/&gt;try方法插入时，是初始化状态。&lt;br/&gt;第二阶段confirm和cancel方法执行后修改为已提交或回滚状态。&lt;br/&gt;当重复调用二阶段接口时，先获取该事务控制表对应记录，检查状态，如果已执行，则返回成功，否则正常执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;悬挂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;悬挂就是对于一个分布式事务，第二阶段cancel接口比try接口先执行，因为允许空回滚，cancel接口认为try接口没有执行，空回滚执行返回成功，seata框架认为，分布式事务第二阶段接口已经执行成功，整个分布式事务就结束了。&lt;/p&gt;
&lt;p&gt;但是此时有可能真正的try方法才真正执行，预留业务资源，由于try过程中会加锁预留资源，并且只有当前事务可以使用，但seata框架认为分布式事务已经结束，就会出现第一阶段预留的业务资源没人能够处理，这种情况属于悬挂。&lt;/p&gt;
&lt;p&gt;在RPC调用时，先注册分支事务，在执行RPC调用，如果此时RPC调用网络阻塞，通常RPC调用是有超时时间的，RPC超时以后，发起方通知TC回滚该事务，可能回滚完成后，RPC请求才到达参与者，真正执行，从而造成悬挂。&lt;/p&gt;
&lt;p&gt;为了防止悬挂，如果第二阶段完成，一阶段就不能在继续了，因此一阶段执行时，需要先检查二阶段释放已经执行完成，如果执行完成，则一阶段不再执行。否则可以正常执行。&lt;/p&gt;
&lt;p&gt;同样依赖于事务控制表，在二阶段执行时插入一条事务控制记录，状态为回滚，这样当一阶段执行时，先读取该记录，如果存在，就认为二阶段已执行。否则认为二阶段没有执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分析完回滚，幂等，悬挂之后，考虑如何通过TCC解决问题。&lt;/p&gt;
&lt;p&gt;try方法需要考虑两个问题，try方法能够告诉二阶段接口已经预留资源成功。还需要检查二阶段是否执行完成，如果完成不再执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/a5cb9ad2009af6995c003bc7c487f34446c.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先插入事务控制表，如果插入成功，说明二阶段还没有执行，可以继续执行第一阶段，如果插入失败，说二阶段已经执行或正在执行，抛出异常，终止。&lt;/p&gt;
&lt;p&gt;confirm方法不允许空回滚，所以confirm方法一定要在try方法之后执行，所以confirm方法只需要关注重复提交的问题，可以先锁事务记录，如果事务记录为空，则说明是一个空提交，不允许，终止执行。&lt;br/&gt;如果事务记录不为空，则继续检查状态是否为初始化，如果是，说明一阶段正确执行，二阶段正常执行即可。如果状态为已提交，则认为重复提交，直接返回成功即可。如果状态是已回滚，就是一个异常事务，一个已经回滚的事务不能重新提交，需要拦截到这种情况，并报警。&lt;/p&gt;
&lt;p&gt;cancel方法不允许空回滚，在先执行时，需要让try感知到，所以需要锁定事务记录，如果事务记录为空，则认为try方法还没有执行，为空回滚。空回滚情况下先插入一条事务记录，确保后续try方法不会再执行。&lt;br/&gt;如果插入成功，说明try还没有执行，空回滚继续执行。如果插入失败，认为try方法正在执行，等待tc重试即可。&lt;/p&gt;
&lt;p&gt;如果一开始读取事务记录不为空，说明try方法已经执行完毕，在检查状态是否为初始化，如果是，则还没有执行二阶段方法，正常执行cancel逻辑。&lt;br/&gt;如果状态为已回滚，说明是重复调用，允许幂等，直接返回成功即可。如果状态为已提交，则同样是个异常，一个已提交的事务，不能再次回滚。&lt;/p&gt;
&lt;h2 id=&quot;性能优化&quot;&gt;性能优化&lt;/h2&gt;
&lt;p&gt;随着业务中对于Seata框架的使用越来越多，TCC的性能问题越来越明显。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分支事务记录和业务数据在相同的数据库中，在切面调用时不再向TC注册，而是直接向业务数据库里面插入一条记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/5933a26a251edc7547892695e640eb9540d.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个分布式事务的提交和回滚还是由发起方通知TC，但是由于分支事务记录保存在业务数据库，不是TC端，所以TC不知道哪些分支事务记录，在收到提交或回滚通知后，仅仅记录下该分布式事务的状态。&lt;br/&gt;为了执行二阶段操作，各个参与者内部启动一个异步任务，定时捞取业务数据库中未结束的分支事务记录，然后向TC检查整个分布式事务的状态，就是statecheckrequest请求。TC在收到这个请求后，根据之前保存的分布式事务状态，告诉参与者是提交还是回滚，从而完成分支记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/7060790f4265626c3098cdc7d8f6bac29c0.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边是同步模式前调用图，每次调用一个参与者的时候，都是向TC注册一个分布式事务记录，TC持久化存储在自己的数据库中，就是说一个分支事务注册包含了一次RPC和一次持久化存储。&lt;/p&gt;
&lt;p&gt;右边是优化后的调用图，每次调用一个参与者的时候，都是直接保存在业务数据库中，减少了和TC之间的RPC调用，优化后，有多少个参与者，就节约了多少RPC调用。&lt;/p&gt;
&lt;p&gt;一个数据库方案，把分支记录保存在业务数据库中，减少了和TC的RPC调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCC模型把两阶段拆分成了两个独立的阶段，通过资源业务锁定方式进行关联。资源锁定好处是，不会阻塞其他事务第一阶段对于相同资源的继续使用，也不会影响第二阶段的正确执行，理论上说，只要业务允许，事务的二阶段什么时候执行都可以，反正资源已经锁定了，不会被其他事务锁定该资源。&lt;/p&gt;
&lt;p&gt;对于一些资源锁定，但是资源执行间隔比较久的业务场景来说，可以在第一阶段后，认为本次交易环节完成，并向用户和商户返回支付成功结果，并不需要马上执行二阶段的confirm操作，可以降低热点数据性能问题，在业务低峰期慢慢消化，异步的执行。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;整体上了解了一个分布式事务框架的原理和实现，并解决常见的异常问题和性能问题，可以帮助我们自研一套框架解决业务分布式事务需求。&lt;br/&gt;当然不同业务要求不同，一个好的分布式事务需要适配自身业务特点，找到更合适的结合点。&lt;/p&gt;
&lt;p&gt;更多内容：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/376571/201905/376571-20190520113603510-369359451.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 03:36:00 +0000</pubDate>
<dc:creator>春哥大魔王</dc:creator>
<og:description>分布式事务中的TCC模式，貌似是阿里提出来的，所以阿里自研的分布式事务框架总是少不了TCC的影子。 服务拆分 很多系统早期都是单系统服务架构，所有业务聚合在少数几个系统中对外提供服务。随着业务发展，服</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiguain/p/10893231.html</dc:identifier>
</item>
<item>
<title>ORM取数据很简单！是吗？ - CUBA-China</title>
<link>http://www.cnblogs.com/cubacn/p/cuba-readdata.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cubacn/p/cuba-readdata.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　几乎任何系统都以某种方式与外部数据存储一起运行。大多数情况下，外部数据存储是一个关系数据库，并且在实现时通常将数据提取任务委托给某些&lt;/span&gt; ORM。 尽管 ORM 包含很多 routine 代码，但是另一方面也提供了一些新的抽象。&lt;/p&gt;
&lt;p&gt;　　Martin Fowler 写过一篇关于 ORM 的有趣&lt;a href=&quot;https://dzone.com/articles/martin-fowler-orm-hate&quot;&gt;&lt;span&gt;&lt;span&gt;文章&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，其中一个主要思想是&lt;/span&gt; “ ORM 帮助我们处理大多数企业应用程序中的一个非常现实的问题... ORM 不是漂亮的工具，但它解决的问题也不是可爱的。我认为他们应该得到更多的尊重和更多的理解”。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt; &lt;a href=&quot;https://cuba-platform.com/&quot;&gt;&lt;span&gt;CUBA&lt;/span&gt;&lt;/a&gt; &lt;span&gt;框架中，我们大量地使用了&lt;/span&gt; ORM，因为我们在世界各地都有各种各样的项目，所以我们非常了解它的局限性。关于 ORM 有很多方面可以讨论，但这里我们只关注其中一个：Lazy 和 Eager 方式加载数据。我们将会讨论数据获取的不同方法（主要在 JPA API 和 Spring 中），以及我们如何在 CUBA 中获取数据，还有我们在 CUBA 中改进 ORM 层所做的研发工作。我们还会了解哪些基本要素需要在使用ORM时考虑，以避免可怕的性能问题。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　如果数据模型只包含一个实体，那使用&lt;/span&gt; ORM 不会有问题。我们来看看这个例子。有一个User实体，包含 ID 和 Name 属性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520104712906-25801120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　要获取这个实体，我们只需要简单的使用&lt;/span&gt; EntityManager：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520104748954-1559592258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　但是如果有实体之间的一对多关系的话，事情就变得有点意思了：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520104813700-2021134872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果我们想从数据库中获取用户记录，就会出现一个问题：&lt;/span&gt;“我们也应该同时获取一个 address 吗？”。而“正确”的答案将是：“看情况”。在某些情况下，我们可能需要获取地址信息。通常，ORM提供两种获取数据的选项：Lazy 和 Eager。大多数ORM默认设置使用Lazy模式。因此，当我们编写以下代码时：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520104833950-1853010293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们会遇到所谓的&lt;/span&gt; “LazyInitException”，这会让ORM新手非常困惑。所以这里我们需要解释“Attach”和“Detach”对象的概念，以及数据库会话和事务。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么，一个实体实例应该关联到一个数据库会话，这样我们才能够获取详细信息属性（比如&lt;/span&gt; User.addresses）。但是在这种情况下，我们遇到了另一个问题，事务会变得越来越长，因此，会增加了数据库死锁的风险。可是，如果将我们的代码拆分为一系列短事务的话，又会由于非常短的单独查询语句数量的急剧增加，导致数据库“数百万只蚊子死亡” - 太多小事务。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如上所述，我们可能需要获取地址属性或者不需要，因此只是在某些情况下或者更多的条件判断之后使用&lt;/span&gt; Address 集合。 嗯....看起来变得越来越复杂了。&lt;/p&gt;
&lt;p&gt;　　好的，另一种获取类型会有帮助吗？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520104909009-490749711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　并没有想象的那么好。虽然使用&lt;/span&gt; Eager 方式能避免烦人的懒加载初始化异常，也不需要检查实例是 Attach 还是 Detach。但是这里我们会遇到性能问题，因为我们并不是针对所有情况都需要用户的地址信息，可是用 Eager 方式会始终获取地址信息。那还有其他办法吗？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　一些开发人员对&lt;/span&gt;ORM非常恼火，因此使用Spring JDBC并切换到“半自动”映射。在这种情况下，我们会为唯一用例创建唯一查询语句，并返回包含仅对特定用例有效的属性的对象。&lt;/p&gt;
&lt;p&gt;　　这种方式给了我们很大的灵活性。比如，我们可以只获取一个属性：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520104936535-2031723837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　或者整个对象：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520105001353-1252366942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　您也可以使用&lt;/span&gt; ResultSetExtractor 获取 addresses，但需要涉及编写一些额外的代码，还需要知道如何编写 SQL join 语句以避免 &lt;a href=&quot;https://www.javacodegeeks.com/2018/04/jpa-tips-avoiding-the-n-1-select-problem.html&quot;&gt;&lt;span&gt;n+1 select 问题&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好吧，又变得复杂了。使用&lt;/span&gt; Spring JDBC 您可以控制所有查询并控制结果映射，但是您必须编写更多代码，学习 SQL 并了解数据库查询语句的执行方式。虽然我认为了解 SQL 基础知识对于几乎每个开发人员来说都是一项必要的技能，但有些人并不这么认为，而我也不打算与他们争论。因为现在我们知道 x86 汇编程序对每个人来说都不是一项至关重要的技能。我们只是考虑如何能简化开发。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　我们回过头想想，我们到底要实现什么样的目标？好像就是确切地说明在不同的用例中我们需要获取哪些实体属性。&lt;/span&gt;JPA 2.1 引入了一个新的 API - Entity Graph。这个API背后的想法很简单 - 您只需编写几个注解来描述应该获取的内容。我们来看看这个例子：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520105030816-1812828109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于这个实体，我们描述了两个实体图（&lt;/span&gt;entity graphs） - user-only-entity-graph 不加载addresses属性（标记为lazy），而第二个实体图需要 ORM 获取 addresses。但是如果我们将属性标记为 Eager，则将忽略实体图设置并获取属性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因此，从&lt;/span&gt;JPA 2.1开始，您可以通过以下方式选择实体：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520105052813-1071692140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这种方法极大地简化了开发人员的工作，无需&lt;/span&gt;“触摸” Lazy 属性并创建长事务。最棒的是，实体图可以在生成SQL的级别使用，因此不会从数据库中将额外数据提取到Java应用程序。但是这里仍然存在问题：在外部调用时不方便知道提取了哪些属性。有一个API可以检查： 使用 PersistenceUnit 类检查属性是否加载：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520114124240-1134128457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　但是这样做很无聊。我们有办法简化并且不显示无法获取的属性吗？&lt;/p&gt;

&lt;p&gt;　　Spring Framework 提供了一个名为 &lt;a href=&quot;https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#projections&quot;&gt;&lt;span&gt;Projections&lt;/span&gt;&lt;/a&gt; &lt;span&gt;的出色工具（它与&lt;/span&gt;Hibernate的 &lt;a href=&quot;https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#criteria-projection&quot;&gt;&lt;span&gt;Projections&lt;/span&gt;&lt;/a&gt; &lt;span&gt;不同）。如果我们只想获取实体的某些属性，我们可以指定一个接口，&lt;/span&gt;Spring 将从数据库中选择接口“实例”。我们来看看这个例子。如果我们定义以下接口：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520105120473-1326785879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后定义&lt;/span&gt; Spring JPA repository 以获取我们的用户实体：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520105137719-603570256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在这种情况下，在调用&lt;/span&gt; findByName 方法之后，我们将无法访问未获取的属性！同样的原则也适用于 detail entity 类。因此，您可以通过这种方式获取 master 记录和 detail 记录。此外，在大多数情况下，Spring 能生成 “合适的” SQL 并仅提取 projection 中指定的属性，也就是说 projections 能像实体图一样工作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这是一个非常强大的概念，您可以使用&lt;/span&gt; SpEL 表达式，使用类而不是接口，等等。如果您感兴趣，可以在&lt;a href=&quot;https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#projections&quot;&gt;&lt;span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;中了解更多信息。&lt;/p&gt;
&lt;p&gt;　　Projections 的唯一问题是它们在底层使用 map 实现，所以是只读的。因此，您可以为 projection 定义 setter 方法，但无法使用 CRUD repositories 和 EntityManager 来保存更改。您可以将 projection 视为DTO，但是您必须编写自己的 DTO-to-entity 转换代码。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　从&lt;/span&gt;CUBA框架开发开始，我们尝试优化与处理数据库的代码。在框架中，我们使用 &lt;a href=&quot;https://www.eclipse.org/eclipselink/&quot;&gt;&lt;span&gt;EclipseLink&lt;/span&gt;&lt;/a&gt; &lt;span&gt;来实现数据访问层&lt;/span&gt;API。关于 &lt;a href=&quot;https://www.eclipse.org/eclipselink/&quot;&gt;&lt;span&gt;EclipseLink&lt;/span&gt;&lt;/a&gt; &lt;span&gt;的好处&lt;/span&gt; - 它从一开始就支持部分实体加载，这就是我们首先选择它而不选 Hibernate 的原因。在 JPA 2.1 成为标准之前，使用这个 ORM 就能准确指定加载哪些属性。因此，我们在 CUBA 框架中加入了内部的 “Entity Graph” 概念 - &lt;a href=&quot;https://doc.cuba-platform.com/manual-7.0/views.html?_ga=2.46895399.1839163924.1557830988-1998441411.1554175093&quot;&gt;&lt;span&gt;CUBA 视图&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。视图非常强大&lt;/span&gt; - 您可以对视图进行扩展、组合等等。创建 CUBA 视图背后的第二个原因 - 我们希望使用短事务，并主要使用 detach 对象，否则，我们没办法让丰富的web UI 以响应式并且快速的方式运行。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;CUBA中，视图描述存储在 XML 文件中，如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520105216140-717090834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　此视图会告诉&lt;/span&gt; CUBA DataManager 使用其 name 属性获取User实体，并在查询级别获取地址时使用 address-street-only-view 视图。视图定义之后，您可以在使用 DataManager 类获取实体时使用视图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520105234986-238192943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这就像魔法一样。由于不加载未使用的属性，能节省大量的网络流量，但是跟&lt;/span&gt; JPA Entity Graph 类似，有一个小问题：我们不知道加载了用户实体的哪些属性。在 CUBA 中，我们非常讨厌 “IllegalStateException: Cannot get unfetched attribute [...] from detached object”。与 JPA 一样，您可以检查属性是否已获取，但是为每个正在加载的实体编写这些检查是一项无聊的工作，开发人员对此有些不满。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　如果我们能够充分利用两种方式呢？我们决定实现使用&lt;/span&gt; Spring 方法的所谓实体接口，不同的是，这些接口在应用程序启动期间转换为 CUBA 视图，然后可以在 DataManager 中使用。这个想法非常简单：您定义了一个指定实体图的接口（或一组接口）。它看起来像 Spring Projections 并且像 Entity Graph 一样工作：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520105258138-1989348261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　请注意，如果&lt;/span&gt; AddressStreetOnly 接口只在一种情况下使用，则可以声明其为内部接口。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后在&lt;/span&gt; CUBA 应用程序启动期间（事实上，主要是Spring Context 初始化的过程中），我们为 CUBA 视图创建一个程序化表示，并将它们存储在 Spring Context 的内部 repository bean中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　之后我们需要调整&lt;/span&gt; DataManager，然后，除了CUBA 视图的字符串名称之外它还可以接受类名，加载时，我们只需传递上面定义的接口类：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520105330323-190843346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　跟&lt;/span&gt; Hibernate 一样，我们生成代理，为从数据库中提取的每个实例实现实体视图。当您尝试获取属性的值时，代理会将调用转发给具体的实体执行。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过这个实现，我们试着能一石二鸟：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;未在接口中声明的数据不会加载到&lt;/span&gt;Java应用程序代码，从而节省了服务器资源&lt;/p&gt;
&lt;p&gt;　　l &lt;span&gt;开发人员只使用被提取的属性，因此不再出现&lt;/span&gt; “UnfetchedAttribute” 错误（在 Hibernate中也称为 LazyInitException）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　与&lt;/span&gt; Spring Projections 相比，实体视图能包装实体并实现了 CUBA 的 Entity 接口，因此可以将它们视为实体：您可以更新属性并将更改保存到数据库。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里还有&lt;/span&gt; “ 第三只鸟” - 你可以定义一个只包含 getter 的 “只读”接口，能完全阻止实体在API级别进行修改。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　此外，我们可以在&lt;/span&gt; detach 的实体上实现一些操作，例如将此用户的名称转换为小写：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520105414939-1143012824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在这种情况下，可以从实体模型移除所有需要计算的属性，因此不会在实体内部将数据获取逻辑与特定于用例的业务逻辑混合使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另一个有趣的机会&lt;/span&gt; - 您可以继承接口。这使您可以使用不同的属性集准备多个视图，然后根据需要混合它们。例如，您可以拥有一个包含用户名和电子邮件的界面，另一个界面包含用户名和地址。如果你需要一个应该包含用户名，电子邮件和地址的第三个视图界面，你可以通过组合两者来实现 - 这要归功于Java中的多接口继承。请注意，您可以将此第三个接口传递给使用第一个或第二个接口的方法，这里也能使用OOP原则。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们还在视图之间实现了实体转换&lt;/span&gt; - 每个实体视图都有reload()方法，它接受另一个视图类作为参数：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201905/1438872-20190520105440268-551656341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　UserFullView 可能包含其他属性，因此使用时，会从数据库重新加载实体。实体重新加载是一个 Lazy 的过程，只有在尝试获取实体属性值时才会执行。我们故意这样做是因为在 CUBA 中我们有一个 web 模块，可以呈现丰富的 UI，并且可能包含自定义的 REST 控制器。在此模块中，跟 core 模块（也叫中间件）使用相同的实体，但是 web 模块可以部署在单独的服务器上。因此，每个实体重新加载都会通过 core 模块向数据库发出附加请求。所以，通过引入实体重新懒加载，我们节省了一些网络流量和数据库查询。&lt;/p&gt;
&lt;p&gt;　　PoC 代码可以从&lt;a href=&quot;https://github.com/cuba-rnd/entity-views-sample&quot;&gt;&lt;span&gt;GitHub&lt;/span&gt;&lt;/a&gt;&lt;span&gt;下载&lt;/span&gt; - 随意试试看。&lt;/p&gt;

&lt;p&gt;　　ORM 将在不久的将来在企业应用程序中大量使用。我们只需要提供一些将数据库行转换为 Java 对象的东西。当然，在复杂，高负载的应用程序中，我们也能继续看到独特的解决方案，但只要 RDBMS 存在，ORM 也会继续存在。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt; CUBA 框架中，我们试图简化 ORM 的使用，使开发人员尽可能轻松。在接下来的版本中，我们将引入更多更改。我不确定这些是视图接口还是其他东西，但我很确定一件事 - 在下一版本中我们将简化 CUBA 中 ORM 的使用方法。&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 03:30:00 +0000</pubDate>
<dc:creator>CUBA-China</dc:creator>
<og:description>简介 几乎任何系统都以某种方式与外部数据存储一起运行。大多数情况下，外部数据存储是一个关系数据库，并且在实现时通常将数据提取任务委托给某些 ORM。 尽管 ORM 包含很多 routine 代码，但是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cubacn/p/cuba-readdata.html</dc:identifier>
</item>
<item>
<title>JSBridge框架解决通信问题实现移动端跨平台开发 - 宜信技术</title>
<link>http://www.cnblogs.com/yixinjishu/p/10893027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yixinjishu/p/10893027.html</guid>
<description>&lt;h2 id=&quot;toc_1&quot;&gt;一、跨平台开发是趋势&lt;/h2&gt;
&lt;p&gt;目前主流的移动端平台主要是Android和iOS，为了尽可能复用代码和节省开发成本，各大巨头都开发了自己的跨平台框架，比如Facebook的React-Native、阿里的Weex、Cordova，以及今年Google开发者大会上介绍的Flutter框架。这些框架各有优缺点，但是到目前为止都没有大规模地推广开来，在我看来主要有以下几个原因：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、开发者生态圈还不够成熟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RN是三大跨平台框架中关注人最多、生态最活跃的框架，但是到目前为止也没有到1.0版本（最新的release是0.57.8），更别说作为后来者的Weex和Flutter了。生态不成熟，意味着开发文档少，可以使用的开源控件少，比如在RN上想做一个最基本的下拉刷新和上拉加载更多的listview都比较费劲。Weex已经贡献给Apache，很久没有更新release了。Flutter现在还在beta版本，其发展还有待观察。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、性能问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然这几大框架都对渲染性能做了优化，但是相比原生还是差一些，RN和weex都自己实现了一个浏览器内核（JSCore），因此多了一层js解析，渲染较慢。比如RN的listview，如果数据量太大就会出现卡顿。Flutter虽然自带绘制引擎，但是跟原生比起来还是有一些距离。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、兼容问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然这三大平台的初衷都是为了跨平台（Write/Learn once, run everywhere），但在实际应用中还是需要耗费很多的精力去兼容和适配，比如RN在Android低端机器上表现就不尽如人意，连曾经RN的坚实拥护者Airbnb都宣布放弃使用RN了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、开发集成成本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;三个框架都需要学习新的语言React/vue/dart，weex的最大优势就是入门简单，但是版本迭代慢，RN上手门槛高，开发调试难度大，集成RN和weex框架还会加入很多so文件，增加安装包的大小(至少在10M左右)，这还不包括第三方的library。Flutter因为刚出来，应用的人还不多，其效果还有待观察。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：虽然上述自主研发的跨平台框架都或多或少地存在问题，但是移动开发的跨平台是大势所趋，可以节省开发成本，提高开发效率，迅速响应业务变化，现在主流的应用还是使用H5和原生的通信来实现跨平台的开发。Android和iOS平台都有自己内置的浏览器内核webkit框架，跨平台的本质就是用H5/JS编写的代码能够分别运行在Android和IOS的WebView中，从而实现一套代码两个平台都能运行的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190110/1547108123246047167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;二、安卓跨平台开发实践&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在Android平台上要实现Native和JS的通信主要通过WebViewClient和WebChromeClient两个类来实现。&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;WebViewClient的作用是帮助WebView处理各种通知、事件请求，其主要的方法有：onLoadResource、onPageStart、onPageFinished、onReceiveError、shouldOverrideUrlLoading等；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;WebChromeClient处理JS页面的事件响应，比如网页中的对话框、网页图标、网站标题、网页的加载进度等事件，对应的响应方法有onJsAlert、onJsConfirm、onJsConsole、onProgressChanged、onReceiveIcon、onReceiveTitle等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;要实现Java和JS通信就要：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;解决Java调JS；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JS调Java。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Java调用JS通过loadUrl和evaluateJavaScript两个方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过webview.loadUrl(“javascript:alert(‘hello world’)”)，可以在android平台将js代码注入到html页面，loadUrl方法可以直接调用js中定义的函数，也可以把android本地的assets目录下的js文件以字符串的形式注入到html页面中，但是这个注入时机一定要等到html页面加载完毕才能做，即在WebViewClient.onPageFinished的回调函数中调用，这样就相当于在html页面中直接引用了js资源文件。对于客户端来说，java调用js本质上是一个拼接js字符串的过程，但是调用loadUrl不能直接获取js函数的返回值，而要实现Java调用js函数后。&lt;/p&gt;
&lt;p&gt;获取js函数的返回值可以使用webview.evaluateJavaScript方法，但是该方法只有在android4.4及以上的版本才可以使用。其他用法和loadUrl一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS调用Java可以分为三种：对象映射、URL拦截、JS方法拦截。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象映射是通过webview.addJavascriptInterface(new JSObject(), “javaObject”)，这样可以js代码中可以直接调用javaObject对象，从而实现JS调用Java的功能，但是这个方法在android4.2以下会有安全漏洞，利用反射机制调用Android API getRuntime执行shell命令进行攻击，比如遍历sdcard、发送短信、安装木马APK等。&lt;/p&gt;
&lt;p&gt;URL拦截是指在html页面通过iframe.src、window.open、documention.location或者href，这四种方法都可以在html页面中打开一个连接，从而会触发Java中的WebViewClient.shouldOverrideUrlLoading方法。例如在js中执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190110/1547108153585008923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在shouldOverrrideUrlLoading中可以根据约定的协议格式（Scheme）和协议名（Authority）获取从JS中传输过来的数据（Data）。&lt;/p&gt;
&lt;p&gt;在JS中调用alert、console、prompt、confirm等方法就会触发WebChromeClient的onJsAlert、onConsoleMessage、onJsPrompt、onJsConfirm方法的回调。比如在js中可以调用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190110/1547108181168094048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在onJsPrompt的message中可以获取prompt的内容，然后根据约定的协议格式可以获取数据。&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;三、JSBridge框架&lt;/h2&gt;
&lt;p&gt;为了解决JS和Native的通信问题，需要使用一个JSBridge框架（https://github.com/lzyzsd/JsBridge）用来负责H5和Java之间的通信，此时需要解决以下两个问题：&lt;/p&gt;
&lt;p&gt;1）JS互相Java调用后如何回调，将responseData传递回去；&lt;/p&gt;
&lt;p&gt;2）JS调用Java有三种方法，如果选择哪一种方法比较合适。&lt;/p&gt;
&lt;p&gt;针对问题1，可以在java端和js端定义一个数据结构: Message={callbackId:xxx, handleName:xxx,responseData:xxx,responseId:xxx}。将回调函数保存在callbackId中，当JS或者Java处理完数据回调的时候再将保存在callbackId的回调函数存放在responseId，相应的回调的数据存放在responseData中，这样就能响应JS或者Java调用后的回调消息。&lt;/p&gt;
&lt;p&gt;Js调用Java的方法虽然有三种，但是addJavaScriptInterface存在安全性问题一般不建议使用，JS中的alert、console方法都会在Html页面比较常用，confirm和prompt虽然不常用但是某些手机系统版本上会有对话框弹出，不通用，所以比较好的选择是url拦截，可以通过iframe.src触发shouldOverrideUrlLoading。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JsBridge框架的使用主要分为：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在H5页面加载完毕注入一个本地的js文件；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Java代码中注册BridgeHandler，用来处理JS发送过来的消息；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在本地注入的js文件中定义_handleMessageFromNative，用来接收java传递过来的消息；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;因为客户端注入js是异步的，所以需要在js文件中注册Event监听器，成功后通知H5。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Native调用JS，例如通过&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;webview.loadUrl(
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;javascript:WebViewJavascriptBridge._handleMessageFromNative('{&lt;/span&gt;
\&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;callbackId\&quot;:\&quot;JAVA_CB_2_559\&quot;,\&quot;data\&quot;:\&quot;just data from java\&quot;&lt;/span&gt;
}&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;这样就可以调用JS的handleMessageFromNative方法，传递的数据格式是Message，callBackId响应js的回调，发送前会存储到HashMap中，js回调的时候根据JAVA_CB_2_559找到对应的的回调函数处理js的响应数据，具体流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190110/1547108235710003647.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Js调用Java，通过sendMessageQueue将传递的信息转换成&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Message= {data: {…}, callbackId: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cb_1_1234&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;其中callbackId是js的回调函数。然后通过&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
iframe.src=’yy:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return/_fetchQueue/[{&quot;data&quot;:&quot;xxxx&quot;,&quot;callbackId&quot;:&quot;cb_1_4321&quot;}]’，&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;触发shouldOverrideUrlLoading方法，java处理完js传递过来的data后，将回调函数cb_1_4321设置到&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Message={responseId: cb_1_4321, responseData:XXX}，
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;这样在js中就能处理回调函数。具体的流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190110/1547108327553011057.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JsBridge框架提供两种Handler方法，registerHandler方法需要传入handler的名字，这样需要iOS、Android、H5三方约定这个名字，因为H5开发的的业务需求变化比较快，而且H5调用原生的方法也是随机的，所以每次都用registerHandler约定名字需要使用全局变量存放这些handler方法名不便于扩展，所以实际开发中使用defaultHanlder，H5调用原生方法的的时候约定一个cmd，即约定data={cmd:xxx,time:data:{…}}，只要在原生代码中对cmd命令有对应的功能，那么H5页面就可以随时调用原生的方法。&lt;/p&gt;
&lt;p&gt;JSBridge的改进建议，由于webview调用js方法的时候必须在主线程才能生效，所以偶然会出现java调用js失败。另外，Js调用Java偶尔也会失败，因为iframe机制不能保证每次都能触发shouldOverrideUrlLoading回调。&lt;/p&gt;
&lt;p&gt;目前JSBridge采用的是url scheme的方式，如果不考虑Android4.2以下，iOS7以下，可以采用的交互，比如直接使用addJavaScriptInterface在JS页面注入一个Native对象，将之前触发u步骤变为使用这个Native对象向Native发送消息。这种方法只是一个可行的方案，实际使用过程中目前的JSBridge方案基本上满足业务需求了。&lt;/p&gt;
&lt;p&gt;作者：周智&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://college.creditease.cn/article&quot;&gt;宜信技术学院&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 03:11:00 +0000</pubDate>
<dc:creator>宜信技术</dc:creator>
<og:description>移动开发的跨平台是大势所趋，可以节省开发成本，提高开发效率，迅速响应业务变化，现在主流的应用还是使用H5和原生的通信来实现跨平台的开发。JSBridge框架解决JS和Native的通信问题实现移动端跨</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yixinjishu/p/10893027.html</dc:identifier>
</item>
</channel>
</rss>