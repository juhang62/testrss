<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用c语言计算分期贷款折算年化收益率（内部收益率IRR*12） - 皇家救星</title>
<link>http://www.cnblogs.com/kingstarer/p/10322343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingstarer/p/10322343.html</guid>
<description>&lt;p&gt;　　众所周知，现在银行的分期贷款利率是很有诱惑性人。表面看利率是很低的，例如招行的闪电贷有时给我的利率是4.3%&lt;/p&gt;
&lt;p&gt;但是，由于贷款是分期还本的，我手上的本金每月都在减少，到最后一个月时手上只有少量本金，但是还的利息却还是跟第一个月一样。&lt;/p&gt;
&lt;p&gt;　　excel提供了一个公式叫irr，专门用来计算这种分期贷款实际利率的。&lt;/p&gt;
&lt;p&gt;irr函数有两个参数，第一个是现金流，第二个是预估值。只要我们根据贷款情况填好总贷款金额和每月还款金额就可以算出每月的内部收益率。&lt;/p&gt;
&lt;p&gt;月内部收益率*12就是我们的实际贷款利率。预估值一般不用填，只有irr计算失败返回&lt;span&gt;#NUM!&lt;/span&gt;才要考虑填，具体可见office官方说明。&lt;/p&gt;
&lt;p&gt;　　https://support.office.com/zh-cn/article/IRR-%E5%87%BD%E6%95%B0-64925eaa-9988-495b-b290-3ad0c163c1bc&lt;/p&gt;
&lt;p&gt;　　为方便计算，我做了一个excel表格，有兴趣大家可以去下载。只要输入下面图片黄底黑体列，即可自动得出折算年利率。招行的闪电贷利率表面看是4.3%,实际年化利率是7.84%。&lt;/p&gt;
&lt;p&gt;　　如果你把钱投理财产品，没有7.84%以上你实际是亏本的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/781609/201901/781609-20190125233617973-12250114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当然，本文重点不是介绍irr函数，而是我写（抄）的一个计算irr的程序（函数）。使用的是二分迭代法（网上看还有牛顿迭代法和加速迭代法，这两种需要用到数学知识）&lt;/p&gt;
&lt;p&gt;之所以用c语言写一个，原因是我们最近项目组有一个c程序需要计算内部收益率。我从网上找了一个程序改了一下，变成一个函数，并加上注释，方便理解和调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/781609/201901/781609-20190125234221301-700408013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　程序和代码还有前面提到的表格我都已经上传，有需要可以去下载。实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; testirr.cpp : 定义控制台应用程序的入口点。
&lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;math.h&amp;gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;const double zero = 1e-5;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int n;&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
//代码是在csdn上找到的 我拿下来改了一下
//&lt;/span&gt;&lt;span&gt;https://blog.csdn.net/dinghaoseu/article/details/50322117&lt;/span&gt;&lt;span&gt;
//这是原来的代码
double quickpow(double a, int b)
{
    double ans = 1;
    while(b)
    {
        if(b &amp;amp; 1) ans = ans * a;
        a = a * a;
        b &amp;gt;&amp;gt;= 1;
    }
    return ans;
}

double makeans(double irr)
{
    double ans = 0;
    for(int i = 1; i &amp;lt;= n; i++)
        ans += ( a[i] / (quickpow(1 + irr, i)) );
    return ans;
}
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算流出Npv&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt; getNpvOut(&lt;span&gt;double&lt;/span&gt; irr, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; arrOutMoney[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; npv = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; denominator = &lt;span&gt;1&lt;/span&gt; + irr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分母&lt;/span&gt;
    &lt;span&gt;double&lt;/span&gt; multiplier = denominator; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;乘数&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; ++&lt;span&gt;i)
    {
        npv &lt;/span&gt;+= arrOutMoney[i] / denominator; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;即：arrOutMoney[i] / (quickpow(1 + irr, i)&lt;/span&gt;
        denominator *=&lt;span&gt; multiplier;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; npv;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小最大IRR（内部收益率） 用于折算年化率计算
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小值必须大于-1 最大值1其实就足够了，折算成年化收益率是120%（国家规定利率不能超过30%）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数字越小计算速度越快，为保险计这里填10&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IRR_MIN -1.0f
&lt;span&gt;#define&lt;/span&gt; IRR_MAX 10.0f

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二分迭代寻找合适的irr值（如果存在多个irr，取第一次找到的值，不保证大小顺序）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arrInOutMoney是分期现金流 nArrLen是arrInOutMoney元素个数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arrInOutMoney[0]必须是负数，代表总分期金额（负数），后面是每期还款金额（正数）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回[IRR_MIN, IRR_MAX]之间的数字代表符合要求的IRR值，&amp;lt;IRR_MIN代表找不到合适的IRR&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt; binarySearchGetIrr(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; arrInOutMoney[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nArrLen)
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; l = IRR_MIN, r = IRR_MAX; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;irr取值-1~10之间 &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; n = nArrLen - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int nCnt = 0;&lt;/span&gt;

    &lt;span&gt;while&lt;/span&gt; (l &amp;lt;&lt;span&gt; r)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次从最大和最小期望IRR中间取一个数值进行npv测算&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; mid = (l + r) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;现在是用除法求Npv，其实可以改成用乘法求，效率会高一点
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为计算机处理乘法速度比较快&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; npvOut =&lt;span&gt; getNpvOut(mid, arrInOutMoney, n);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;++nCnt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果结果等于0说明找到符合要求的IRR&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (fabs(npvOut + arrInOutMoney[&lt;span&gt;0&lt;/span&gt;]) &amp;lt;= 1e-&lt;span&gt;5&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;double类型不能直接与0比较判断是否相等&lt;/span&gt;
&lt;span&gt;        {    
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;nCnt = %d\n&quot;, nCnt); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;经测试，一般分12期迭代次数在30~60之间&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;irr越大，npvOut越小，故npvOut太大时irr就应该落在mid和r之间，反之则反之&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (npvOut &amp;gt; -arrInOutMoney[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]) 
        {
            l &lt;/span&gt;=&lt;span&gt; mid;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            r &lt;/span&gt;=&lt;span&gt; mid;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;nCnt = %d\n&quot;, nCnt);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找不到返回比IRR_MIN还小的值&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; IRR_MIN - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入按月分期现金流，输出对应irr和折算年化收益率
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arrInOutMoney是分期现金流 nArrLen是arrInOutMoney元素个数（一般是7或者13）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arrInOutMoney[0]必须是负数，代表总分期金额，后面是每期还款金额（正数）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nCheckFlag = 0，代表直接计算irr，否则会先对数据合法性做检查
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回0代表成功 其它代表失败 失败原因存放在errBuf（调用者需要保证至少有256个字节空间）&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; GetIrrAndAnnualizedRate(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; arrInOutMoney[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nArrLen,
    OUT &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; *pIrr, OUT &lt;span&gt;double&lt;/span&gt; *&lt;span&gt;pAnnualizedRate, 
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nCheckFlag, OUT &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;errBuf)
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; irr = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nCheckFlag != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; inMoney, outMoney;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arrInOutMoney == NULL || nArrLen &amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        {
            strcpy(errBuf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;arrInOutMoney需要非空并且元素个数大于2个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
        }

        inMoney &lt;/span&gt;= arrInOutMoney[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        outMoney &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; nArrLen; ++&lt;span&gt;i)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arrInOutMoney[i] &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不支持多次现金流入（因为没这个需求，不要浪费计算力）&lt;/span&gt;
                outMoney = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            outMoney &lt;/span&gt;+=&lt;span&gt; arrInOutMoney[i];
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (inMoney &amp;gt;= &lt;span&gt;0&lt;/span&gt; || (-inMoney &amp;gt;&lt;span&gt; outMoney))
        {
            strcpy(errBuf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第一个元素必须是负现金流，之后每个元素均是正现金流，&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;并且正现金流之和要大于负现金流&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
        }
    }

    irr &lt;/span&gt;=&lt;span&gt; binarySearchGetIrr(arrInOutMoney, nArrLen);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (irr &amp;lt;&lt;span&gt; IRR_MIN)
    {
        sprintf(errBuf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%.5f(%.2f%%)~%.5f(%.2f%%)之间无法找到合适的irr，请检查现金流是否输入异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            IRR_MIN, IRR_MIN &lt;/span&gt;* &lt;span&gt;12&lt;/span&gt; * &lt;span&gt;100&lt;/span&gt;, IRR_MAX, IRR_MAX * &lt;span&gt;12&lt;/span&gt; * &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;*pIrr =&lt;span&gt; irr;
    &lt;/span&gt;*pAnnualizedRate = irr * &lt;span&gt;12&lt;/span&gt; * &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getIrrDemo()
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; irr, annualizedRate;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a[&lt;span&gt;100&lt;/span&gt; * &lt;span&gt;12&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, nRet;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; errBuf[&lt;span&gt;256&lt;/span&gt;&lt;span&gt;];

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;**************如果要退出，请在还款期数填0**************\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input 还款期数 n（0代表退出）:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) &amp;amp;&amp;amp; ~scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;n) &amp;amp;&amp;amp;&lt;span&gt; n)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, n);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;gt;= &lt;span&gt;sizeof&lt;/span&gt;(a) / &lt;span&gt;sizeof&lt;/span&gt;(a[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]))
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n值太大，不支持\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入分期金额（负数）:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;a[&lt;span&gt;0&lt;/span&gt;]) != &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入的金额不能包含非数字和小数点\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            getchar();
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入%d期还款金额（正数），每输入一期按一次回车:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, n);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
        {
            scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;a[i]);
        }

        nRet &lt;/span&gt;= GetIrrAndAnnualizedRate(a, n + &lt;span&gt;1&lt;/span&gt;, &amp;amp;irr, &amp;amp;annualizedRate, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, errBuf);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nRet != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error:[%s]\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, errBuf);
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算irr常用的方法是迭代计算，即不断尝试可能值，根据尝试结果缩小范围，直到找到符合要求的值
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;网上能找到的迭代算法有二分迭代，牛顿迭代，加速迭代，其中二分迭代最好理解，最容易开发&lt;/span&gt;
        irr = binarySearchGetIrr(a, n + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (irr &amp;lt;&lt;span&gt; IRR_MIN)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;找不到合适的irr\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;irr = %.6f  年化收益率(12 * irr) = %.4f%%\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, irr, annualizedRate);
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}


&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    getIrrDemo();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;system(&quot;pause&quot;);&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




</description>
<pubDate>Fri, 25 Jan 2019 15:50:00 +0000</pubDate>
<dc:creator>皇家救星</dc:creator>
<og:description>众所周知，现在银行的分期贷款利率是很有诱惑性人。表面看利率是很低的，例如招行的闪电贷有时给我的利率是4.3% 但是，由于贷款是分期还本的，我手上的本金每月都在减少，到最后一个月时手上只有少量本金，但是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kingstarer/p/10322343.html</dc:identifier>
</item>
<item>
<title>开源工具软件XMusicDownloader——音乐下载神器 - JadePeng</title>
<link>http://www.cnblogs.com/xiaoqi/p/xmusicdownloader.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoqi/p/xmusicdownloader.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/jadepeng/XMusicDownloader&quot;&gt;XMusicDownloader&lt;/a&gt;，一款 支持从百度、网易、qq和酷狗等音乐网站搜索并下载歌曲的程序。&lt;/p&gt;
&lt;p&gt;缘起：&lt;/p&gt;
&lt;p&gt;一直用网易音乐听歌，但是诸如李健、周杰伦的不少歌曲，网易都没有版权，要从QQ等音乐去下载，因此一直想写一个小程序，可以从其他音乐网站下载相关歌曲，趁放假，花了几小时做了这样一个程序。&lt;/p&gt;
&lt;p&gt;BTW: 之前写过一个&lt;a href=&quot;https://github.com/jadepeng/musicDecryptor&quot;&gt;从酷狗和网易音乐提取缓存文件的程序&lt;/a&gt;，感兴趣的可以查看。&lt;/p&gt;
&lt;h2 id=&quot;功能&quot;&gt;功能&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;聚合搜索多家音乐网站&lt;/li&gt;
&lt;li&gt;支持音乐批量下载&lt;/li&gt;
&lt;li&gt;搜索结果综合排序&lt;/li&gt;
&lt;li&gt;可以编写Provider程序，支持其他音乐网站&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现IMusicProvider即可，主要是搜索和获取下载链接的方法。&lt;/p&gt;
&lt;pre class=&quot;csharp?linenums&quot;&gt;
&lt;code&gt;    public interface IMusicProvider
    {
        string Name { get; }

        string getDownloadUrl(Song song);
        List&amp;lt;Song&amp;gt; SearchSongs(string keyword, int page, int pageSize);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;界面截图&quot;&gt;界面截图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/jadepeng/blogpic/raw/master/images/2019/1-25/1548431781568.png&quot; alt=&quot;预览&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;下载程序&quot;&gt;下载程序&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jadepeng/XMusicDownloader/releases&quot; class=&quot;uri&quot;&gt;https://github.com/jadepeng/XMusicDownloader/releases&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现方案介绍&quot;&gt;实现方案介绍&lt;/h2&gt;
&lt;h3 id=&quot;定义song实体&quot;&gt;定义song实体&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class Song
    {
        public string id { get; set; }
        public string name { get; set; }
        public string singer { get; set; }
        public string album { get; set; }
        public string source { get; set; }
        public double duration { get; set; }
        public double size { get; set; }
        public string url { get; set; }
        public int rate { get; set; }
        public int index { get; set; }

        public string getFileName()
        {
            return singer + &quot;-&quot; + name + &quot;.mp3&quot;;
        }

        public string getMergedKey()
        {
            return singer.Replace(&quot; &quot;, &quot;&quot;) + name.Replace(&quot; &quot;, &quot;&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;封装各个音乐网站&quot;&gt;封装各个音乐网站&lt;/h3&gt;
&lt;p&gt;抽象为MusicProvider，音乐提供方:)，定义Name为名称，SearchSongs搜索歌曲，getDownloadUrl获取音乐下载地址。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
    public interface IMusicProvider
    {
        string Name { get; }

        string getDownloadUrl(Song song);
        List&amp;lt;Song&amp;gt; SearchSongs(string keyword, int page, int pageSize);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就是依次实现百度、网易等音乐网站，以QQ为例。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt; public class QQProvider : IMusicProvider
    {
        static HttpConfig DEFAULT_CONFIG = new HttpConfig
        {
            Referer = &quot;http://m.y.qq.com&quot;,

        };

        public string Name { get; } = &quot;QQ&quot;;

        static string[] prefixes = new string[] { &quot;M800&quot;, &quot;M500&quot;, &quot;C400&quot; };

        public List&amp;lt;Song&amp;gt; SearchSongs(string keyword,int page,int pageSize)
        {
            var searchResult = HttpHelper.GET(string.Format(&quot;http://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?w={0}&amp;amp;format=json&amp;amp;p={1}&amp;amp;n={2}&quot;, keyword, page,pageSize), DEFAULT_CONFIG);
            var searchResultJson = JsonParser.Deserialize(searchResult).data.song;
            var result = new List&amp;lt;Song&amp;gt;();

            var index = 1;
            foreach(var songItem in searchResultJson.list)
            {
                var song = new Song
                {
                    id = songItem[&quot;songmid&quot;],
                    name = songItem[&quot;songname&quot;],
                    album = songItem[&quot;albumname&quot;],
                    rate = 128,
                    size = songItem[&quot;size128&quot;],
                    source = Name,
                    index = index++,
                    duration = songItem[&quot;interval&quot;]
                };
                song.singer = &quot;&quot;;
                foreach (var ar in songItem[&quot;singer&quot;])
                {
                    song.singer += ar[&quot;name&quot;] + &quot; &quot;;
                }
                result.Add(song);
            }

            return result;

        }

        public string getDownloadUrl(Song song)
        {
            var guid = new Random().Next(1000000000, 2000000000);

            var key = JsonParser.Deserialize(HttpHelper.GET(string.Format(&quot;http://base.music.qq.com/fcgi-bin/fcg_musicexpress.fcg?guid={0}&amp;amp;format=json&amp;amp;json=3&quot;,guid), DEFAULT_CONFIG)).key;
            foreach(var prefix in prefixes)
            {
               
                var musicUrl = string.Format(&quot;http://dl.stream.qqmusic.qq.com/{0}{1}.mp3?vkey={2}&amp;amp;guid={3}&amp;amp;fromtag=1&quot;, prefix, song.id, key, guid);
                if (HttpHelper.GetUrlContentLength(musicUrl) &amp;gt; 0)
                {
                    return musicUrl;
                }
            }

            return null;

        }
    
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;搜索调用&lt;code&gt;http://c.y.qq.com/soso/fcgi-bin/search_for_qq_cp?w={0}&amp;amp;format=json&amp;amp;p={1}&amp;amp;n={2}&lt;/code&gt;接口，获取下载地址调用&lt;code&gt;http://base.music.qq.com/fcgi-bin/fcg_musicexpress.fcg?guid={0}&amp;amp;format=json&amp;amp;json=3&lt;/code&gt;,然后再组合。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;聚合搜索&quot;&gt;聚合搜索&lt;/h3&gt;
&lt;p&gt;设计一个MusicProviders，加载所有的IMusicProvider，提供一个SearchSongs方法，并发调用各个网站的搜索，然后merge到一起。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
  public List&amp;lt;MergedSong&amp;gt; SearchSongs(string keyword, int page, int pageSize)
        {
            var songs = new List&amp;lt;Song&amp;gt;();
            Providers.AsParallel().ForAll(provider =&amp;gt;
            {
                var currentSongs = provider.SearchSongs(keyword, page, pageSize);
                songs.AddRange(currentSongs);
            });

            // merge

            return songs.GroupBy(s =&amp;gt; s.getMergedKey()).Select(g =&amp;gt; new MergedSong(g.ToList())).OrderByDescending(s =&amp;gt; s.score).ToList();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于merge，核心就是将相同的歌曲合并到一起，我们暂且认为歌手+歌曲名相同的为同一首歌曲：&lt;/p&gt;
&lt;pre class=&quot;csharp?linenums&quot;&gt;
&lt;code&gt;   public string getMergedKey()
        {
            return singer.Replace(&quot; &quot;, &quot;&quot;) + name.Replace(&quot; &quot;, &quot;&quot;);
        }
        &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此按megekey分组，就能实现聚合。我们设计一个&lt;code&gt;MergedSong&lt;/code&gt;来包裹。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class MergedSong
    {
        public List&amp;lt;Song&amp;gt; items
        {
            get; set;
        }

        public MergedSong(List&amp;lt;Song&amp;gt; items)
        {
            this.items = items;
        }

        public string name
        {
            get
            {
                return this.items[0].name;
            }
        }
        public string singer
        {
            get
            {
                return this.items[0].singer;
            }
        }
        public string album
        {
            get
            {
                return this.items[0].album;
            }
        }

        public string source
        {
            get
            {
                return string.Join(&quot;,&quot;, this.items.Select(i =&amp;gt; i.source).ToArray());
            }
        }


        public double duration
        {
            get
            {
                return this.items[0].duration;
            }
        }

        public double size
        {
            get
            {
                return this.items[0].size;
            }
        }

        public double rate
        {
            get
            {
                return this.items[0].rate;
            }
        }


        public double score
        {
            get
            {
                // 投票+排序加权  (各50%）
                return this.items.Count / (MusicProviders.Instance.Providers.Count - 1) + (20 - this.items.Average(i =&amp;gt; i.index)) / 20;
            }
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MergedSong的核心是定义了一个score，我们通过投票+搜索结果排序，用来决定合并结果的排序。&lt;/p&gt;
&lt;h3 id=&quot;下载&quot;&gt;下载&lt;/h3&gt;
&lt;p&gt;下载主要是通过provider获取真实url，然后下载即可。&lt;/p&gt;
&lt;pre class=&quot;csharp?linenums&quot;&gt;
&lt;code&gt;public class SongItemDownloader
    {
        MusicProviders musicProviders;
        string target;
        MergedSong song;

        public event DownloadFinishEvent DownloadFinish;

        public SongItemDownloader(MusicProviders musicProviders, string target, MergedSong song)
        {
            this.musicProviders = musicProviders;
            this.target = target;
            this.song = song;
        }

        public long totalBytes;

        public long bytesReceived;

        public double ReceiveProgress;


        public double receiveSpeed;

        DateTime lastTime = DateTime.Now;

        public void Download()
        {
            WebClient client = new WebClient();
            client.DownloadProgressChanged += Client_DownloadProgressChanged;
            new Thread(() =&amp;gt;
            {
                // 多来源，防止单个来源出错
                foreach (var item in song.items)
                {
                    try
                    {
                        client.DownloadFile(musicProviders.getDownloadUrl(item), target + &quot;\\&quot; + item.getFileName());
                        DownloadFinish?.Invoke(this, this);
                        break;

                    }
                    catch
                    {
                    }
                }

            }).Start();
        }

        private void Client_DownloadProgressChanged(object sender, DownloadEventArgs e)
        {
            this.bytesReceived = e.bytesReceived;
            this.totalBytes = e.totalBytes;
            this.receiveSpeed = e.receiveSpeed;
            this.ReceiveProgress = e.ReceiveProgress;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7.3156342182891&quot;&gt;
&lt;p&gt;作者：Jadepeng&lt;br/&gt;出处：jqpeng的技术记事本--&lt;a href=&quot;http://www.cnblogs.com/xiaoqi&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xiaoqi&lt;/a&gt;&lt;br/&gt;您的支持是对博主最大的鼓励，感谢您的认真阅读。&lt;br/&gt;本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 25 Jan 2019 15:46:00 +0000</pubDate>
<dc:creator>JadePeng</dc:creator>
<og:description>一款 支持从百度、网易、qq和酷狗等音乐网站搜索并下载歌曲的开源c# windows程序。聚合搜索多家音乐网站，支持音乐批量下载，搜索结果综合排序，可以编写Provider程序，扩展支持其他音乐网站</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoqi/p/xmusicdownloader.html</dc:identifier>
</item>
<item>
<title>如何学习新技术 - 和牛</title>
<link>http://www.cnblogs.com/heniu/p/10322118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heniu/p/10322118.html</guid>
<description>&lt;p&gt;&lt;span&gt;我总是感觉自己在盲目的学习一些看上去很火热的技术。比如 React Native，Flutter 等等。我家里堆了各种编程语言的入门书籍，有 Go 的，有 Erlang 的，有 c++ 的，还有 JavaScript 和 CSS。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我到现在都搞不懂这个事情。我连主流的 Python 语言都没有掌握清楚为什么要去看这么多语言的入门书呢？我在工作和生活中根本就用不到他们。只是因为在某一篇文章中看到 Go 语言是趋势，Erlang 的稳定性无人能敌，c++ 你永远都让不开等等。这些东西我都研究过，可是到现在为止还没有用他们写过一行有用的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相信很多童鞋都有类似的情况。程序员学习新技术的想法是件大好事，总比不思进取的思想状态要好，可结果却并不一定比原地踏步强，因为不一定有用，会造成技术浪费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;浪费的事情我们生活中做得很多。我们想要买更贵的手机，因为 cpu 更强，可是很多人并不一定需要那么强的 cpu。本来只需要买个上网本看看电视却要买个工作站。我们的理由自然也很充足：万一有一天要用到呢？万一有一天我需要玩游戏呢？万一有一天我要 3D 渲染呢？追求新技术的理由也同样：万一以后它火了，我就走在了时代的前面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种情况确实有可能发生，前提是你能将这门新技术研究得很透彻，比别人更懂，否则那些基础更强的能用很短的时间就能超越你。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我想在学习新技术之前应该做几件事情：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先了解自己的需求是什么？在未来 3-5 年内的主要工作是 python 开发，那就应该围绕这个需求来学习。首先是 Python 的高级特性和工程设计思想，这些都落实在具体的实践上，需要积累大量项目经验，可以自己选择一些 side project 练习。自己做的时候还应该参考优秀的开源框架，看看别人的设计思路和实现方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要了解 web 原理。像 HTTP 协议、TCP/IP 协议都需要精通，这样才能站在更基础的层面来进行开发，不是在网上找几套解决方案就能做出一套好的系统。看完基本经典书籍以后，要学会用抓包工具来分析流量走向，定位问题的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要性能优化。要熟练掌握各种算法和数据结构，知道常用算法的应用场景和复杂度。学好算法基础就要去看 python 的各种内置函数实现他们的性能如何，你写出来的代码性能如何。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;性能还需要涉猎并发和异步知识。这些东西往往是操作层面的，可以先熟悉多进程、多线程和协程等在 python 的应用，消息队列等各种异步操作的实现，但是迟早还是要深入研究操作系统是怎么去进行资源调度的，《深入理解计算机系统》就该去看一看了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个过程中，还应该看一看《重构》《程序员修炼之道》这样的方法论书籍，争取能形成一套自己的编码和改进体系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在工作中应该尽量避免的问题是原地踏步、google 编程，这次搜索完一套方案下次还是不知道，几年做的都是重复的事情。盲目追求新技术，拼命加班改 bug 都是技术领域尽力要避免的陷阱，看起来非常努力，实际上是在原地不动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学习应该是有目的的，不是看着哪个火就去学哪个。小时候都学过捡了芝麻丢了西瓜的课文，现在正是不停的在重蹈覆辙，学这个，学那个，最后自己的真正专业都没有做好了。一门技术的探究最终都会落到基础知识上，编译原理、操作系统、算法和数据结构。如果学好了一门技术真正落实到了基础上，去学另一门技术不应该是很难的事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在确定了方向以后把重心放在自己的方向上，平时可以花少量的时间来关注新技术，看看他们的应用领域和简单实现。喜欢玩手机并不代表每个品牌的手机都要买回来天天使用，那是职业测评师干的事，我们的思路是买一个牌子的当主力机，一个当备用机，其他的偶尔去专卖店感受一下就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在项目的技术选型上也应该遵循以需求为重心的原则。如果不是高并发的项目为什么要使用热门语言 Go 呢？用 python 快速实现行不行？现在的技术团队有几个人懂这门语言，外面招人好招吗？现有人员培训需要多久呢？一定要用微服务吗？一定要用docker吗？很多都没有必要的！只是自己给自己挖的一个一个陷阱，把整个团队推进去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来是怎么实现的问题。如果要突然去学非常枯燥和底层的操作系统原理，肯定会两眼一抹黑。突然从 windows 系统换到 linux 系统也会让人手足无措。一个可行性很高的方案就是渐进式改变。和菜头在一篇文章中写道：如果一家餐厅几十年的口味都不变，那肯定逃不过关门的命运。那些说自己坚持不变的人或者产品往往在发生悄无声息的改变，他们的变化如此微小，以至于你根本察觉不到，多少年以来，微信添加了多少微小的功能，很多都隐藏在 UI 之下，我们像寻宝一样一点点的发现，用习惯了以后就感觉它们从一开始就被设计出来了一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要学好操作系统不一定要全心全意去攻克每一个知识点，在工作中接触到了多线程，先看看线程消耗，锁机制和信号量行不行？一点一点来，每天进步一点。人往往会高估短期能力而低估长期能力，这是思维和眼光的局限性导致的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学习是个非常讲究方法论的事情，盲目的学习是不行的。都是参加高考，为什么那些看上去努力的学生大多成绩平平，天天打篮球、约会的就考上清华北大呢？智商是一方面，不过我到现在都不相信高考能到达人类平均智商的极限，估计方法是更加重要的一面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;万维钢关于学习的话题我觉得是很有意思的，概括几个要点是：循序渐进、逃离舒适区、重复的基础训练。最重要的是要形成整个体系和思维，不然学到的知识都不是自己的。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 25 Jan 2019 14:40:00 +0000</pubDate>
<dc:creator>和牛</dc:creator>
<og:description>我总是感觉自己在盲目的学习一些看上去很火热的技术。比如 React Native，Flutter 等等。我家里堆了各种编程语言的入门书籍，有 Go 的，有 Erlang 的，有 c++ 的，还有 Ja</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heniu/p/10322118.html</dc:identifier>
</item>
<item>
<title>自定义Token的CAS登录 - lichdr</title>
<link>http://www.cnblogs.com/lichdr/p/10316972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lichdr/p/10316972.html</guid>
<description>&lt;p&gt;工作中实际遇到的需求，我们有一个旧系统，用了CAS的单点登录，现在有一个外部系统，准备从它那里单点进来，这个外部系统提供了一个token参数来标记这是哪一个用户，我们用他们提供的方式解析出对应的用户，以这个用户从CAS登录进系统。&lt;/p&gt;
&lt;p&gt;有关CAS登录的分析网上多如牛毛，这里不准备多作分析了，直接上解决过程。&lt;/p&gt;
&lt;p&gt;这里实现是基于我们以前系统的，是CAS 3.5.2&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先在登录流程文件login-webflow.xml里在on-start节点后面插入&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;box&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;code&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;decision-state &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;tokenCheck&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;requestParameters.token != null and requestParameters.token != ''&quot;&lt;/span&gt;&lt;span&gt; then&lt;/span&gt;&lt;span&gt;=&quot;tokenValidate&quot;&lt;/span&gt;&lt;span&gt; else&lt;/span&gt;&lt;span&gt;=&quot;ticketGrantingTicketExistsCheck&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;decision-state&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里检查是否有token参数，有的话执行token验证，没有的话走正常流程，ticketGrantingTicketExistsCheck就是原有的正常流程。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;定义token验证节点&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;box&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;code&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action-state &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;tokenValidate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;evaluate &lt;/span&gt;&lt;span&gt;expression&lt;/span&gt;&lt;span&gt;=&quot;tokenLoginAction.doExecute(flowRequestContext)&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition &lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;=&quot;error&quot;&lt;/span&gt;&lt;span&gt; to&lt;/span&gt;&lt;span&gt;=&quot;generateLoginTicket&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transition &lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;=&quot;success&quot;&lt;/span&gt;&lt;span&gt; to&lt;/span&gt;&lt;span&gt;=&quot;sendTicketGrantingTicket&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action-state&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;失败则走generateLoginTicket分支，会生成一个LT，并重定向到登录页面，这也是通常页面登录失败后的路径&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;成功则走sendTicketGrantingTicket分支，即页面正常登录成功时走的路径&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;实现token验证流程节点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在cas-servlet.xml里添加添加tokenLoginAction Bean&lt;/p&gt;
&lt;div class=&quot;box&quot;&gt;
&lt;div class=&quot;code&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;tokenLoginAction&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.jasig.cas.web.flow.TokenLoginAction&quot;&lt;/span&gt;&lt;span&gt;
    p:centralAuthenticationService-ref&lt;/span&gt;&lt;span&gt;=&quot;centralAuthenticationService&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现TokenLoginAction&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里主要解析token，并生成TGT。主要代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('771b1669-12d2-4244-b47f-52971f7e21b4')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_771b1669-12d2-4244-b47f-52971f7e21b4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_771b1669-12d2-4244-b47f-52971f7e21b4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('771b1669-12d2-4244-b47f-52971f7e21b4',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_771b1669-12d2-4244-b47f-52971f7e21b4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
HttpServletRequest request =&lt;span&gt; WebUtils.getHttpServletRequest(context);
String token &lt;/span&gt;= request.getParameter(&quot;token&quot;&lt;span&gt;);

 &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析Token,略。。。。。。&lt;/span&gt;
&lt;span&gt;
   CasCredentials credentials &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CasCredentials();
   credentials.setUsername(userName);
   credentials.setPassword(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
   credentials.setNoAuth(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
  
   String tgt &lt;/span&gt;=&lt;span&gt; centralAuthenticationService.createTicketGrantingTicket(credentials);
   WebUtils.putTicketGrantingTicketInRequestScope(context,tgt);
  
 } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
   e.printStackTrace();
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;error&quot;&lt;span&gt;;
 }
 
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TokenLoginAction的主要逻辑代码&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面centralAuthenticationService是注入的属性，&lt;/p&gt;
&lt;p&gt;CasCredentials则是继承自&lt;strong&gt;UsernamePasswordCredentials&lt;/strong&gt;的一个自定义Credentials，在用户名、密码基础上添加了一个&lt;strong&gt;noAuth&lt;/strong&gt;属性，用来标记是不是需要验证密码。这里由外系统提供的token保证安全性，把noAuth设为true。&lt;/p&gt;
&lt;p&gt;而登录验证逻辑在createTicketGrantingTicket这个方法里，验证未通过会抛出异常。&lt;/p&gt;
&lt;p&gt;真正验证的地方则是在authenticationManager里，里面有authenticationHandlers定义了验证方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;修改登录验证逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;login-webflow.xml顶部把credentials的定义先改了&lt;/p&gt;
&lt;div class=&quot;box&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;code&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;var &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;credentials&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.cas.util.CasCredentials&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;deployerConfigContext.xml找到自定义登录验证所在&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;box&quot;&gt;
&lt;div class=&quot;code&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;authenticationManager&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;authenticationHandlers&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.cas.util.QueryUserAuthenticationHandler&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
......
                           &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在这个QueryUserAuthenticationHandler class里，验证密码之前加入&lt;/p&gt;
&lt;div class=&quot;box&quot;&gt;
&lt;div class=&quot;code&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;if&lt;/span&gt; (CasCredentials.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isInstance(credentials)) {
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (((CasCredentials)credentials).isNoAuth())
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样就完成了传入第三方token的CAS登录。&lt;/p&gt;
&lt;p&gt;似乎是完成了，但其实还有一些东西，&lt;/p&gt;
&lt;p&gt;比如第三方进来的时候是不用他们传&lt;strong&gt;Service&lt;/strong&gt;这个参数的，而这个参数是在CAS登录初始化时处理掉的，后面没有地方自己往request里加这个参数让CAS来处理它，自己写requestscope里写Service对象又很麻烦，看了下代码，得注入很多东西才行。这样就在进入CAS流程前，自己往请求里塞一个&lt;strong&gt;Service&lt;/strong&gt;参数，然后重定向到CAS登录的url。&lt;/p&gt;
&lt;p&gt;再比如，这次是别人提供Token用他们的方法解；以后有需求是我们提供一个Token出去，接收进来后用我们的方法自己解。所以其实TokenLoginAction那里解析Token其实是解本方提供出去的Token。解别人的Token呢前置到塞&lt;strong&gt;Service&lt;/strong&gt;参数那个地方，那里解析出来用户名后，再用自己的方法生成一个Token发给CAS。这样就把第三方的Token解析分离出去了，CAS登录的地方不会跟别人的实现绑在一起。&lt;/p&gt;

</description>
<pubDate>Fri, 25 Jan 2019 14:12:00 +0000</pubDate>
<dc:creator>lichdr</dc:creator>
<og:description>工作中实际遇到的需求，我们有一个旧系统，用了CAS的单点登录，现在有一个外部系统，准备从它那里单点进来，这个外部系统提供了一个token参数来标记这是哪一个用户，我们用他们提供的方式解析出对应的用户，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lichdr/p/10316972.html</dc:identifier>
</item>
<item>
<title>Gradle中的闭包 - HappyCorn</title>
<link>http://www.cnblogs.com/lwbqqyumidi/p/10322034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwbqqyumidi/p/10322034.html</guid>
<description>&lt;div readability=&quot;165&quot;&gt;
&lt;p&gt;Gradle是基于Groovy的DSL基础上的构建工具，Gradle中的闭包，其原型上实际上即Groovy中闭包。而在表现形式上，其实，Gradle更多的是以&lt;code&gt;约定&lt;/code&gt;和基于约定基础上的&lt;code&gt;配置&lt;/code&gt;去展现。但本质上，大多数&lt;code&gt;配置&lt;/code&gt;，实际上都对应着闭包以及闭包的具体使用。&lt;/p&gt;
&lt;p&gt;例如，实际Android项目中，我们经常看到类似如下的所谓配置项：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;allprojects {
    repositories {
        mavenLocal()
        maven {
            url &lt;span class=&quot;hljs-string&quot;&gt;'http://maven.aliyun.com/nexus/content/groups/public/'
        }
        google()
        jcenter()
    }

    configurations.all {
        resolutionStrategy.cacheChangingModulesFor 1, &lt;span class=&quot;hljs-string&quot;&gt;'seconds'
    }
}

task clean(&lt;span class=&quot;hljs-built_in&quot;&gt;type: Delete) {
    delete rootProject.buildDir
    delete &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;${rootProject.rootDir}/jenkinsOut&quot;
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们在&lt;code&gt;allprojects&lt;/code&gt;上按住command键时，发现有如下图所示的提示。&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/1/25/16884d7d318c5118?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2019/1/25/16884d7d318c5118?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;390&quot; data-height=&quot;105&quot;/&gt;&lt;/div&gt;
&lt;p&gt;出现的提示指的是此配置项所对应的Gradle中原型，可以点击直接进入对应的Gradle API。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;/**
     * &amp;lt;p&amp;gt;Configures this project and each of its sub-projects.&amp;lt;/p&amp;gt;
     *
     * &amp;lt;p&amp;gt;This method executes the given closure against this project and its sub-projects. The target {@link Project}
     * is passed to the closure as the closure&lt;span class=&quot;hljs-string&quot;&gt;'s delegate.&amp;lt;/p&amp;gt;
     *
     * @param configureClosure The closure to execute.
     */
    void allprojects(Closure configureClosure);
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现，我们常用的&lt;code&gt;allprojects&lt;/code&gt;配置，实际上真正对应着的，是一个&lt;code&gt;void allprojects(Closure configureClosure)&lt;/code&gt;Java方法，而其后&lt;code&gt;{}&lt;/code&gt;中的配置，实际上整体是一个&lt;code&gt;Closure&lt;/code&gt;类型的参数，在方法说明中，指出&lt;code&gt;这个方法是为当前项目及其子项目执行给定的闭包，目标@Project作为闭包的委托传递给闭包&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;于是，到底什么是闭包，闭包具体的运作机制是怎么样的，有必要实际窥探一番。&lt;/p&gt;
&lt;p&gt;点击Gradle API中的Closure，可以进入对应的Closure类型声明，实际上对应的是Groovy jar包中的class文件声明。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;package groovy.lang;

import ...

public abstract class Closure&amp;lt;V&amp;gt; extends GroovyObjectSupport implements Cloneable, Runnable, GroovyCallable&amp;lt;V&amp;gt;, Serializable {
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Closure&lt;/code&gt;，翻译过来是&lt;code&gt;闭包&lt;/code&gt;，在JS等语言中也存在闭包的概念，但是，不同语言中，对于闭包的具体描述或实际的应用，不同语言，可能还有所不同。&lt;/p&gt;
&lt;p&gt;先了解一下&lt;code&gt;Groovy&lt;/code&gt;中&lt;code&gt;闭包&lt;/code&gt;的描述：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;闭包，是一个代码块，或可以理解成一个匿名函数，在外部方法调用时，可以将其作为方法的实参传递给方法的形参，并在方法内部回调此匿名函数，且回调此匿名函数时可以传递实参给到匿名函数的内部去接收，并执行此匿名函数。
同时，此代码块或匿名函数也可以赋值给一个变量，使其具有自执行的能力，且最后一行的执行语句作为匿名函数的返回。
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看着好像不太容易理解，可以具体看几个实际例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;// 1,定义一个闭包，赋值给一个变量，并进行显示的自我调用。
def t = {
    println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure&quot;
}
// 此处也可以写成t.call()
t()

// 运行后，输出结果为：
Hello  Closure
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，以变量的方式调用闭包&lt;code&gt;t()&lt;/code&gt;与&lt;code&gt;t.call()&lt;/code&gt;是等价的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;// 2,定义一个闭包，赋值给一个变量，并进行显示的自我调用，并检测其返回值
def t = {
    println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure&quot;
    &lt;span class=&quot;hljs-string&quot;&gt;&quot;ttt&quot;
}
println &lt;span class=&quot;hljs-string&quot;&gt;&quot;closure return: &quot; + t.call()

// 运行后，输出结果为：
Hello  Closure
closure &lt;span class=&quot;hljs-built_in&quot;&gt;return: ttt
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;// 3,定义一个闭包，赋值给一个变量，并进行显示的自我调用，调用时向闭包传递实参
def t = {
    println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + it
}

t(&lt;span class=&quot;hljs-string&quot;&gt;&quot;mm&quot;)

// 运行后，输出结果为：
Hello  Closure, the param value is: mm
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用闭包时，如果向闭包传递实参，闭包内部如果没有声明形参接收，默认是以it的变量的一个形参去接收实参。&lt;/p&gt;
&lt;p&gt;因此，例3实际上是等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;def t = {
    it -&amp;gt;
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + it
}

t(&lt;span class=&quot;hljs-string&quot;&gt;&quot;mm&quot;)
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;// 4,如果闭包中显示的声明了形参，则以显示的声明的形参去接收实参
def t = {
    x, y -&amp;gt;
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + x + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot; + y
}

t(&lt;span class=&quot;hljs-string&quot;&gt;&quot;mm&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;nn&quot;)

// 运行后，输出结果为：
Hello  Closure, the param value is: mm, nn
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上，都是将闭包赋值给一个变量后，进行的闭包的调用行为。&lt;/p&gt;
&lt;p&gt;同时，我们也可以将闭包作为一个方法实参，在方法调用时传递给方法形参，然后方法内部形成对此闭包的回调。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;// 5,将闭包作为一个方法实参，在方法调用时传递给方法形参，然后方法内部形成对此闭包的回调
class Person {

    String getName(Closure closure) {
        closure(&lt;span class=&quot;hljs-string&quot;&gt;&quot;cc&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;dd&quot;)
    }
}

def t = {
    x, y -&amp;gt;
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + x + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot; + y
}

new Person().getName(t)

// 运行后，输出结果为：
Hello  Closure, the param value is: cc, dd
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例5中的闭包如果没有事先赋值给变量&lt;code&gt;t&lt;/code&gt;，而也可以直接使用，效果等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;class Person {

    String getName(Closure closure) {
        closure(&lt;span class=&quot;hljs-string&quot;&gt;&quot;cc&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;dd&quot;)
    }
}


new Person().getName({
    x, y -&amp;gt;
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + x + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot; + y
})
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;闭包作为方法中的最后一个参数，可以从&lt;code&gt;()&lt;/code&gt;中拿出来，则等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;new Person().&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;getName(){
    x, y -&amp;gt;
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + x + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot; + y
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时，方法后的&lt;code&gt;()&lt;/code&gt;可以去掉，则等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;new Person().getName {
    x, y -&amp;gt;
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + x + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, &quot; + y
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果外部调用闭包的方法传递实参时，没有传递实参或只传递了一个参数（如果没有传递实参，则it为null），则进一步演化成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;class Person {

    String getName(Closure closure) {
        closure(&lt;span class=&quot;hljs-string&quot;&gt;&quot;cc&quot;)
    }
}


new Person().getName {
    println &lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello  Closure, the param value is: &quot; + it
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这也就是我们在Gradle中经常见到的闭包形式，即表面上只有&lt;code&gt;{}&lt;/code&gt;的配置形式。&lt;/p&gt;
&lt;p&gt;将闭包理解成一个特殊的匿名函数，无论是通过变量的自调用，还是作为方法实参的传递后，在方法内部被回调，闭包的最后一行执行被当做匿名函数的整体返回，都可以很好的得以理解。同时，也能容易的理解闭包可以嵌套使用等（即当做匿名函数的嵌套）。&lt;/p&gt;
&lt;p&gt;闭包在&lt;code&gt;Gradle&lt;/code&gt;中的配置中，被大量使用。理解&lt;code&gt;Gradle&lt;/code&gt;中的闭包，对一些特殊的写法，如Gradle构建生命周期中的闭包回调中的实参使用等，可以有很好的运用。&lt;/p&gt;
&lt;p&gt;如常见的在&lt;code&gt;Gradle&lt;/code&gt;构建的&lt;code&gt;配置阶段&lt;/code&gt;中的&lt;code&gt;afterEvaluate&lt;/code&gt; &lt;code&gt;hook&lt;/code&gt;中，可以设置相关&lt;code&gt;task&lt;/code&gt;的依赖关系等。此时，&lt;code&gt;it&lt;/code&gt;接收的是回传进来的当前&lt;code&gt;project&lt;/code&gt;实参。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;afterEvaluate {
    ...

    Task assembleJenkinsTask = rootProject.tasks.getByName(&lt;span class=&quot;hljs-string&quot;&gt;'assembleJenkins')

    Task unitTestTask = it.tasks.findByName(&lt;span class=&quot;hljs-string&quot;&gt;'testDebugUnitTest')

    &lt;span class=&quot;hljs-keyword&quot;&gt;if (unitTestTask != null) {
        assembleJenkinsTask.dependsOn unitTestTask

    }

    ...
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在一定意义上，&lt;code&gt;Groovy&lt;/code&gt;中闭包的概念，以及其实际的用法上，实质上根&lt;code&gt;Java 8&lt;/code&gt;中的&lt;code&gt;lambda&lt;/code&gt;表达式具有很相近的含义。&lt;/p&gt;
&lt;/div&gt;&lt;p&gt;
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;</description>
<pubDate>Fri, 25 Jan 2019 14:09:00 +0000</pubDate>
<dc:creator>HappyCorn</dc:creator>
<og:description>Gradle是基于Groovy的DSL基础上的构建工具，Gradle中的闭包，其原型上实际上即Groovy中闭包。而在表现形式上，其实，Gradle更多的是以约定和基于约定基础上的配置去展现。但本质上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwbqqyumidi/p/10322034.html</dc:identifier>
</item>
<item>
<title>找到bug的根源，问五次为什么 - owenandhisfriends</title>
<link>http://www.cnblogs.com/owenandhisfriends/p/10322015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/owenandhisfriends/p/10322015.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;20&quot;&gt;
&lt;p&gt;在学习《问题分析与解决》时学到了一种找到问题根源的方法——问五次为什么。具体内容是：当遇到一个问题，不要只看当前答案，要继续往下问，为什么，连问五次，就能够找到更深层次的问题。&lt;br/&gt;最近在复盘bug的时候，也使用了这种方法，屡试不爽。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;案例&lt;/h2&gt;
&lt;p&gt;前端发布后，页面按钮点击失效，用户反馈问题，前端回滚代码后恢复。&lt;br/&gt;问题一、为什么按钮点击会失效？&lt;br/&gt;因为前端代码写出了一个bug，没有对空对象进行判空，导致页面js抛出异常，按钮失效。&lt;br/&gt;一般到这里就结束了，把代码加上对象判空，继续发布就完成了。&lt;br/&gt;但是大家集思广益，问五次为什么，看看是否有新的发现。&lt;br/&gt;之后又问了几个为什么，果真有收获。&lt;br/&gt;问题二、为什么是用户反馈，而不是告警发现？&lt;br/&gt;因为当时发现了告警，但是看日志没有查出什么异常，就忽略了。&lt;br/&gt;问题三、为什么没有查出日志，是没写日志，还是写了没查到？&lt;br/&gt;有写日志，但是当时查日志系统特别慢，平时要十多分钟才能查出来，那天一个小时都没出来。&lt;br/&gt;问题四、为什么系统会查不出日志？&lt;br/&gt;不知道。后来找维护系统的人查了下，发现硬盘有问题，紧急更换了磁盘。&lt;br/&gt;问题五、为什么平时要十多分钟才能查出来日志，这么慢？&lt;br/&gt;因为查询日志没有用主key查询，日志量太多，导致查询慢。改进：记录日志时把key值写好，精简不需要的日志。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;经过问五个为什么，把一个看似简单的线上bug，挖出了更多可以修改的点。为以后及时发现问题，少出事故，做了很大的贡献。&lt;br/&gt;如果只问一个为什么，那么修改的只有表象问题，把代码判断空加上就结束了。&lt;br/&gt;问了五个为什么之后，做了这几件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修复代码判空的bug。&lt;/li&gt;
&lt;li&gt;发现了日志系统的磁盘问题。&lt;/li&gt;
&lt;li&gt;发现了系统的冗余日志，要精简掉。&lt;/li&gt;
&lt;li&gt;发现记录日志的方式不对，修改。&lt;br/&gt;特别是2，如果不找出来，其他系统也会掉到这个坑里，也算是举一反三。发现一个问题，把关联问题，和根本问题都解决了&lt;br/&gt;很多时候，我们遇到的问题都有更深层次的原因。一个问题出现，也都是多个问题同时发生的结果。在大问题发生之前，一定有很多次小问题出现。问5个为什么，就像进行了5次深度和广度的搜索，把问题又向四周和更深的地方挖掘。&lt;br/&gt;每次出问题时都能多问几次为什么？才是从根本上消除问题的一个好方法！&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 25 Jan 2019 14:04:00 +0000</pubDate>
<dc:creator>owenandhisfriends</dc:creator>
<og:description>在学习《问题分析与解决》时学到了一种找到问题根源的方法——问五次为什么。具体内容是：当遇到一个问题，不要只看当前答案，要继续往下问，为什么，连问五次，就能够找到更深层次的问题。最近在复盘bug的时候，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/owenandhisfriends/p/10322015.html</dc:identifier>
</item>
<item>
<title>STM32串口接收中断——基于HAL库 - 山无言</title>
<link>http://www.cnblogs.com/UnfriendlyARM/p/10321838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/UnfriendlyARM/p/10321838.html</guid>
<description>&lt;p&gt;　　最近需要使用一款STM32L4系列的芯片进行开发，需要学习使用HAL库。在进行串口中断使用的时候遇到了一些小麻烦，写下解决方案供大家参考。&lt;/p&gt;
&lt;div readability=&quot;52&quot;&gt;

 　　由于本人直接使用MDK进行开发，没有使用CubeMX，所以一些初始化需要手动进行。在引用UART相关的头文件时，记得将&quot;stm32l4xx_hal_conf.h&quot;文件中的相关宏定义取消注释，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503563/201901/1503563-20190125213300900-1697140903.png&quot; alt=&quot;&quot;/&gt;
　　接收字符串主要有两种方法，一种是对中断函数进行改造，另一种是对接收回调函数进行改造。&lt;br/&gt;　　在阐述这两种方法之前，需要介绍函数“HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)”。该函数的作用是用户自定义一个缓冲区（即参数pData），接受一定数量（由参数Size决定）的字符存入缓冲区中。同时，参数Size还决定着进入回调函数的频率，即每接收Size个字符，就进入一次回调函数。需要注意的是，Size只决定进入回调函数的频率，而不能影响进入接收中断的频率，无论Size是多少，每接收完成一个字符都会进入一次接收中断。
&lt;h2&gt;方法1：改造回调函数&lt;/h2&gt;
　　①首先在主函数中进入主循环前的位置调用一次 HAL_UART_Receive_IT函数，定义一个字符数组getBuffer[]作为缓冲区，参数Size设定为10。即每接收10个字符，就进入一次回调函数。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503563/201901/1503563-20190125221743988-858096354.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　②注册中断函数 　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; USART1_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    HAL_UART_IRQHandler(&amp;amp;UartHandle); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该函数会清空中断标志，取消中断使能，并间接调用回调函数&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　③在文件“stm32l4xx_hal_uart.h”中，我们可以看到串口接收回调函数的定义。使用“_weak”关键字定义的函数，其具有如下特性： 一般情况下和一般函数相同。但是当有一个同名函数但是不带__weak被定义时，所有对这个函数的调用都是指向后者(不带__weak那个)。也就是说，ST官方提供的这个回调函数需要我们自己进行改写。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    * @brief Rx Transfer completed callback.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    * @param huart UART handle.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    * @retval None
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   __weak &lt;span&gt;void&lt;/span&gt; HAL_UART_RxCpltCallback(UART_HandleTypeDef *&lt;span&gt;huart)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Prevent unused argument(s) compilation warning &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    UNUSED(huart);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; NOTE : This function should not be modified, when the callback is needed,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;              the HAL_UART_RxCpltCallback can be implemented in the user file.
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们在主函数所在的文件中对回调函数进行改写：  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;   uint8_t myBuffer[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I have gotten your message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户提示信息&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;   uint8_t Enter[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回车换行&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;   uint8_t getBuffer[&lt;span&gt;100&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户自定义的缓冲区&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;void&lt;/span&gt; HAL_UART_RxCpltCallback(UART_HandleTypeDef *&lt;span&gt;UartHandle)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(HAL_UART_Transmit(UartHandle, (uint8_t*)myBuffer, COUNTOF(myBuffer), &lt;span&gt;5000&lt;/span&gt;)!= HAL_OK); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送字符串，用户提示信息&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(HAL_UART_Transmit(UartHandle, (uint8_t*)getBuffer, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;5000&lt;/span&gt;)!= HAL_OK); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送用户自定义缓冲区中的数据&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(HAL_UART_Transmit(UartHandle, (uint8_t*)Enter, COUNTOF(Enter), &lt;span&gt;5000&lt;/span&gt;)!= HAL_OK); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送回车换行&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上代码的作用是把用户发送给单片机数据再返回给用户。运行效果如下图：&lt;/p&gt;
 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1503563/201901/1503563-20190125213347889-30868576.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　我们可以看到，用户向单片机发送了10个字符，单片机向串口助手返回了这10个数据。但是以上程序只能实现一次，当我们再次向单片机发送数据时，单片机却不再返回数据。这是因为我们在中断函数中取消了中断使能，所以导致了进入一次中断后，中断被关闭，无法再次进入中断的现象。为了实现多次数据返回，我们要在中断处理函数中添加一行代码： &lt;/div&gt;
&lt;div readability=&quot;39&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; USART1_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    HAL_UART_IRQHandler(&amp;amp;UartHandle); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该函数会清空中断标志，取消中断使能，并间接调用回调函数&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;    HAL_UART_Receive_IT(&amp;amp;UartHandle, (uint8_t *)&amp;amp;value,&lt;span&gt;1&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加的一行代码&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样就可以实现多次数据返回了，新的执行结果如下图：&lt;/p&gt;
　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503563/201901/1503563-20190125213446538-72463262.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　可见，函数HAL_UART_Receive_IT还有中断使能的作用。这一功能的实现我们可以在HAL_UART_Receive_IT函数中找到。&lt;/p&gt;
&lt;h2&gt; 方法2：改造中断处理函数&lt;/h2&gt;
　　①首先在主函数中进入主循环前的位置调用一次 HAL_UART_Receive_IT函数，定义一个字符value作为缓冲区，参数Size设定为1。即每接收1个字符，就进入一次回调函数。使得进入回调函数的频率与进入中断处理函数的频率相同。这样，我们就可以直接在中断函数中对接收的数据进行处理了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503563/201901/1503563-20190125221646891-309900616.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　②注册中断函数  　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   uint8_t myBuffer[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I have gotten your message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   uint8_t getBuffer[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   uint8_t Enter[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;void&lt;/span&gt; USARTx_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    HAL_UART_IRQHandler(&amp;amp;UartHandle); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该函数会清空中断标志，取消中断使能，并间接调用回调函数&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;    
&lt;span&gt; 8&lt;/span&gt;    getBuffer[countOfGetBuffer++] =&lt;span&gt; value; 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt;(countOfGetBuffer == &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(HAL_UART_Transmit(&amp;amp;UartHandle, (uint8_t*)myBuffer, COUNTOF(myBuffer), &lt;span&gt;5000&lt;/span&gt;)!=&lt;span&gt; HAL_OK);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(HAL_UART_Transmit(&amp;amp;UartHandle, (uint8_t*)getBuffer, countOfGetBuffer, &lt;span&gt;5000&lt;/span&gt;)!=&lt;span&gt; HAL_OK);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(HAL_UART_Transmit(&amp;amp;UartHandle, (uint8_t*)Enter, COUNTOF(Enter), &lt;span&gt;5000&lt;/span&gt;)!=&lt;span&gt; HAL_OK);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     countOfGetBuffer = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;    HAL_UART_Receive_IT(&amp;amp;UartHandle, (uint8_t *)&amp;amp;value,&lt;span&gt;1&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于接收中断是每接收一个字符便进入一次，所以这一行代码必须添加，否则只能接收一个字符，而无法接收整个字符串&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上代码的作用是接收每个来自用户的字符，并依次存入用户自定义的缓冲区中，数量达到10个后，将缓冲区中的所有数据返回给用户，同时清空计数，准备接下来10个字符的接收。运行效果如下图：&lt;/p&gt;
 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1503563/201901/1503563-20190125213518301-89568796.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;　　看完本文，大家可能对&lt;span&gt;回调函数&lt;/span&gt;和&lt;span&gt;中断处理函数&lt;/span&gt;的关系产生了疑问。其实是这样的，单片机每完成接收一个字符，就会进入一次&lt;span&gt;中断处理函数&lt;/span&gt;，而在&lt;span&gt;中断处理函数&lt;/span&gt;中，我们又调用了函数“void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)”，该函数会间接调用&lt;span&gt;回调函数&lt;/span&gt;，也就是说&lt;span&gt;回调函数&lt;/span&gt;是由&lt;span&gt;中断处理函数&lt;/span&gt;间接调用的。而函数“HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)”决定了&lt;span&gt;中断处理函数&lt;/span&gt;调用&lt;span&gt;回调函数&lt;/span&gt;的频率，若Size为1，则每进入一次&lt;span&gt;中断处理函数&lt;/span&gt;都会调用一次&lt;span&gt;回调函数&lt;/span&gt;；若Size为10，则每第十次进入&lt;span&gt;中断处理函数&lt;/span&gt;时，才会调用&lt;span&gt;回调函数&lt;/span&gt;。方法2使用了标准库中断处理数据的思想。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 25 Jan 2019 13:52:00 +0000</pubDate>
<dc:creator>山无言</dc:creator>
<og:description>写在前面 最近需要使用一款STM32L4系列的芯片进行开发，需要学习使用HAL库。在进行串口中断使用的时候遇到了一些小麻烦，写下解决方案供大家参考。 1.UART相关的头文件引用错误 由于本人直接使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/UnfriendlyARM/p/10321838.html</dc:identifier>
</item>
<item>
<title>初识Redux的Middleware - Raion</title>
<link>http://www.cnblogs.com/raion/p/10312056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/raion/p/10312056.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;原先改变store是通过dispatch(action) = &amp;gt; reducer；那Redux的Middleware是什么呢？就是dispatch(action) = &amp;gt; reducer过程中搞点事情，既不更改原代码，还能扩展原有功能，这就是Redux的中间件。&lt;/p&gt;
&lt;p&gt;至于Redux的Middleware是怎么演变来的，推荐去看看&lt;a href=&quot;https://www.redux.org.cn/docs/advanced/Middleware.html&quot; target=&quot;_blank&quot;&gt;Redux的官网文档&lt;/a&gt;，讲得很不错，诸位一定要多看几遍。如果你发现还是不好理解，那请你花点时间，细心看看这篇文章。文章内容比较多，希望你跟着我一步一步敲着代码学习，这样收获更多，要是有什么疑惑或者不对的地方，请指出！🤝🤝🤝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;基础环境&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里使用create-react-app搭建环境，方便快速。注意请先自行安装node。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
sudo npm i -g create-react-app (如果已经安装过，请忽略；期间根据提示输入密码即可。window用户执行npm i -g create-react-app) &lt;br/&gt;create-react-app redux-&lt;span&gt;middleware
cd redux&lt;/span&gt;-&lt;span&gt;middleware
yarn add redux react-redux mockjs axios（create-react-app默认使用yarn作为包管理，这里就照着用）&lt;p&gt;// 下面是版本号&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&quot;dependencies&quot;: {&lt;br/&gt;&quot;axios&quot;: &quot;^0.18.0&quot;,&lt;br/&gt;&quot;mockjs&quot;: &quot;^1.0.1-beta3&quot;,&lt;br/&gt;&quot;react&quot;: &quot;^16.7.0&quot;,&lt;br/&gt;&quot;react-dom&quot;: &quot;^16.7.0&quot;,&lt;br/&gt;&quot;react-redux&quot;: &quot;^6.0.0&quot;,&lt;br/&gt;&quot;react-scripts&quot;: &quot;2.1.3&quot;,&lt;br/&gt;&quot;redux&quot;: &quot;^4.0.1&quot;&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一个小例子&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了方便，使用mock拦截，模仿后台接口，根据输入内容，返回模拟数据。现在改写App.js，其余不变。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
import React, { Component } from 'react'&lt;span&gt;;
import axios from &lt;/span&gt;'axios'&lt;span&gt;;
import Mock from &lt;/span&gt;'mockjs'&lt;span&gt;;

Mock.mock(&lt;/span&gt;'http://test.com/search'&lt;span&gt;, {
  &lt;/span&gt;'list|0-5'&lt;span&gt;: [{
    &lt;/span&gt;'id|+1': 1&lt;span&gt;,
    name: &lt;/span&gt;'@character(&quot;lower&quot;)'&lt;span&gt;,
    &lt;/span&gt;'version': '@float(1, 10, 2, 2)'&lt;span&gt;,
    publisher: &lt;/span&gt;'@cname'&lt;span&gt;
  }]
});

class App extends Component {
  state &lt;/span&gt;=&lt;span&gt; {
    data: [],
    searchValue: &lt;/span&gt;''&lt;span&gt;
  };
  handleSearch &lt;/span&gt;= e =&amp;gt;&lt;span&gt; {
    e.preventDefault();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.searchValue) {
      axios.get(`http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;test.com/search`).then(result =&amp;gt; {&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (result.status === 200&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState({ data: result.data.list.map(item =&amp;gt; ({...item, name: `${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.searchValue}${item.name}`})) });
        }
      })
    }
  };
  changeValue &lt;/span&gt;= e =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({ searchValue: e.target.value });
  };
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;div style={{ textAlign: 'center', margin: '40px' }}&amp;gt;
        &amp;lt;form onSubmit={&lt;span&gt;this&lt;/span&gt;.handleSearch}&amp;gt;
          &amp;lt;input type=&quot;text&quot; value={&lt;span&gt;this&lt;/span&gt;.state.searchValue} onChange={&lt;span&gt;this&lt;/span&gt;.changeValue} /&amp;gt;
          &amp;lt;button type=&quot;submit&quot;&amp;gt;搜索&amp;lt;/button&amp;gt;
        &amp;lt;/form&amp;gt;
        &amp;lt;ul&amp;gt;&lt;span&gt;
        {&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state.data.map(item =&amp;gt;&lt;span&gt; (
          &lt;/span&gt;&amp;lt;li key={item.id} style={{ listStyle: 'none' }}&amp;gt;
            &amp;lt;p&amp;gt;{item.name}&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;&lt;span&gt;
              {item.publisher} publish {item.version}
            &lt;/span&gt;&amp;lt;/p&amp;gt;
          &amp;lt;/li&amp;gt;
&lt;span&gt;          ))}
        &lt;/span&gt;&amp;lt;/ul&amp;gt;
      &amp;lt;/div&amp;gt;
&lt;span&gt;    );
  }
}

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; App;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;开始redux中间件之旅&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在将App组件与redux关联起来，数据存入state中。&lt;/p&gt;
&lt;p&gt;更改index.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import React from 'react'&lt;span&gt;;
import ReactDOM from &lt;/span&gt;'react-dom'&lt;span&gt;;
import { createStore } from &lt;/span&gt;'redux'&lt;span&gt;;
import { Provider } from &lt;/span&gt;'react-redux'&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
import App from &lt;/span&gt;'./App'&lt;span&gt;;
import &lt;/span&gt;* as serviceWorker from './serviceWorker'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; listReducer(state =&lt;span&gt; { list: [] }, action) {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'receive'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        list: action.data
      };
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
  }
}

const store &lt;/span&gt;=&lt;span&gt; createStore(listReducer);

ReactDOM.render(
  &lt;/span&gt;&amp;lt;Provider store={store}&amp;gt;
    &amp;lt;App /&amp;gt;
  &amp;lt;/Provider&amp;gt;, document.getElementById('root'));
&lt;span&gt;
serviceWorker.unregister();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更改App.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
import React, { Component } from 'react'&lt;span&gt;;
import { connect } from &lt;/span&gt;'react-redux'&lt;span&gt;;
import axios from &lt;/span&gt;'axios'&lt;span&gt;;
import Mock from &lt;/span&gt;'mockjs'&lt;span&gt;;

Mock.mock(&lt;/span&gt;'http://test.com/search'&lt;span&gt;, {
  &lt;/span&gt;'list|0-5'&lt;span&gt;: [{
    &lt;/span&gt;'id|+1': 1&lt;span&gt;,
    name: &lt;/span&gt;'@character(&quot;lower&quot;)'&lt;span&gt;,
    &lt;/span&gt;'version': '@float(1, 10, 2, 2)'&lt;span&gt;,
    publisher: &lt;/span&gt;'@cname'&lt;span&gt;
  }]
});

class App extends Component {
  state &lt;/span&gt;=&lt;span&gt; {
    searchValue: &lt;/span&gt;''&lt;span&gt;
  };
  handleSearch &lt;/span&gt;= e =&amp;gt;&lt;span&gt; {
    e.preventDefault();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.searchValue) {
      axios.get(`http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;test.com/search`).then(result =&amp;gt; {&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (result.status === 200&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.props.changeList(result.data.list.map(item =&amp;gt; ({...item, name: `${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.searchValue}${item.name}`})));
        }
      })
    }
  };
  changeValue &lt;/span&gt;= e =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({ searchValue: e.target.value });
  };
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;div style={{ textAlign: 'center', margin: '40px' }}&amp;gt;
        &amp;lt;form onSubmit={&lt;span&gt;this&lt;/span&gt;.handleSearch}&amp;gt;
          &amp;lt;input type=&quot;text&quot; value={&lt;span&gt;this&lt;/span&gt;.state.searchValue} onChange={&lt;span&gt;this&lt;/span&gt;.changeValue} /&amp;gt;
          &amp;lt;button type=&quot;submit&quot;&amp;gt;搜索&amp;lt;/button&amp;gt;
        &amp;lt;/form&amp;gt;
        &amp;lt;ul&amp;gt;&lt;span&gt;
        {&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.props.list.map(item =&amp;gt;&lt;span&gt; (
          &lt;/span&gt;&amp;lt;li key={item.id} style={{ listStyle: 'none' }}&amp;gt;
            &amp;lt;p&amp;gt;{item.name}&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;&lt;span&gt;
              {item.publisher} publish {item.version}
            &lt;/span&gt;&amp;lt;/p&amp;gt;
          &amp;lt;/li&amp;gt;
&lt;span&gt;          ))}
        &lt;/span&gt;&amp;lt;/ul&amp;gt;
      &amp;lt;/div&amp;gt;
&lt;span&gt;    );
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mapStateToProps(state) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    list: state.list
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mapDispatchToProps(dispatch) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    changeList: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
      dispatch({ type: &lt;/span&gt;'receive'&lt;span&gt;, data });
    }
  }
}

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; connect(mapStateToProps, mapDispatchToProps)(App);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试一下，我们搜索rxjs，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190124202702706-1904644043.png&quot; alt=&quot;&quot; width=&quot;253&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不错，现在是时候了解下redux的中间件了。首先，我想实现一个日志记录的中间件，在dispatch(action) =&amp;gt; reducer的过程中能打印派发的action和更改后的store。在没有中间件时，我们来更改下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; MapStateToProps(state) {
  &lt;span&gt;console.log(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;'nextState: ', state);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    list: state.list
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mapDispatchToProps(dispatch) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    changeList: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
      &lt;span&gt;const action &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= { type: 'receive', data };
      console.log('dispatch: '&lt;/span&gt;&lt;span&gt;&lt;span&gt;, action);
      dispatch(action);&lt;/span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190124203307608-797035085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很可惜，虽然实现了，但在组件初始化时，却打印了初始化的state。原因在于mapStateToProps方法无法判断是初始化返回的数据还是dispatch(action) =&amp;gt; reducer引发的state更改。当然这里你可以用一个变量去保存是不是初始化组件（即第一次调用mapStateToProps），但是加入了额外的开销不说，还手动更改了mapStateToProps和mapDispatchToProps方法，代码一下子不好看了。这该怎么办呢？先回溯到更改state过程：dispatch(action) =&amp;gt; reducer =&amp;gt; state。由于reducer是一个纯函数，只要函数参数唯一，返回结果必定唯一。通过reducer来实现日志当然可以，但是感觉reducer不纯了。你本来只负责生成新state，不能有自己的小心思。那只好把目光放到dispatch上，先来看看dispatch内部实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; dispatch(action) {
    ...&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据校验&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      isDispatching &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      currentState &lt;/span&gt;=&lt;span&gt; currentReducer(currentState, action)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈哈，新state在此&lt;/span&gt;
    } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
      isDispatching &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    }

    const listeners &lt;/span&gt;= (currentListeners =&lt;span&gt; nextListeners)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; listeners.length; i++&lt;span&gt;) {
      const listener &lt;/span&gt;=&lt;span&gt; listeners[i]
      listener()
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; action
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dispatch是store提供的一个方法，要访问只能在调用dispatch时做些文章。那我试试替换dispatch方法呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; logMiddleware(action) {
    console.log(&lt;/span&gt;'dispatch: '&lt;span&gt;, action);
    dispatch(action);
    console.log(&lt;/span&gt;'nextState: '&lt;span&gt;, currentState);
}

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    dispatch: &lt;span&gt;logMiddleware&lt;/span&gt;,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样明目张胆改了源码不好，换一种方式。更改index.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
import React from 'react'&lt;span&gt;;
import ReactDOM from &lt;/span&gt;'react-dom'&lt;span&gt;;
import { createStore } from &lt;/span&gt;'redux'&lt;span&gt;;
import { Provider } from &lt;/span&gt;'react-redux'&lt;span&gt;;
import App from &lt;/span&gt;'./App'&lt;span&gt;;
import &lt;/span&gt;* as serviceWorker from './serviceWorker'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; listReducer(state =&lt;span&gt; { list: [] }, action) {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'receive'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        list: action.data
      };
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
  }
}

const store &lt;/span&gt;=&lt;span&gt; createStore(listReducer);

&lt;span&gt;let next &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= store.dispatch;
store.dispatch = function logMiddleware(action) {
  console.log('dispatch: ', action);
  next(action);
  console.log('nextState: '&lt;/span&gt;&lt;span&gt;&lt;span&gt;, store.getState());
};&lt;/span&gt;

ReactDOM.render(
  &lt;/span&gt;&amp;lt;Provider store={store}&amp;gt;
    &amp;lt;App /&amp;gt;
  &amp;lt;/Provider&amp;gt;, document.getElementById('root'));
&lt;span&gt;
serviceWorker.unregister();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除App.js中我们加入的日志记录代码。再次搜索如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190124222637918-1189734121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样乍一看好像可行，如果再加一个中间件呢？再次更改index.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
...&lt;br/&gt;let next =&lt;span&gt; store.dispatch;
store.dispatch &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; logMiddleware(action) {
  console.log(&lt;/span&gt;'dispatch: '&lt;span&gt;, action);
  next(action);
  console.log(&lt;/span&gt;'nextState: '&lt;span&gt;, store.getState());
};
&lt;span&gt;let next2 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= store.dispatch;&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的store.dispatch是logMiddleware&lt;/span&gt;
&lt;span&gt;store.dispatch = function logMiddleware2(action) {
  console.log('logMiddleware2 start');
  next2(action);
  console.log('logMiddleware2 end');
};&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190124223937880-1170202398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;糟糕，每次加入一个中间件都得用个变量去存吗？这样的代码太滑稽了，那该如何优雅的获取上一个中间件呢？换个角度思考下，如果将中间件作为参数传递，那效果是不是不一样呢？更改后的index.js如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt;&lt;/span&gt;&lt;span&gt; logMiddleware(dispatch, action) {
  console.log('dispatch: ', action);
  let next = dispatch(action);
  console.log('nextState: ', store.getState());
  return next;
}
function logMiddleware2(dispatch, action) {
  console.log('logMiddleware2 start');
  let next = dispatch(action);
  console.log('logMiddleware2 end');
  return next;
}

let dispatch = logMiddleware2(logMiddleware(store.dispatch, action), action);
store.dispatch = dispatch;&lt;/span&gt;&lt;br/&gt;...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里action这样传递是有问题的，得琢磨琢磨。既然是dispatch(action)，那中间件返回一个函数，函数的参数就是action呢？修改index.js如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;function&lt;/span&gt;&lt;span&gt; logMiddleware(&lt;span&gt;dispatch&lt;/span&gt;) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;&lt;span&gt; (action)&lt;/span&gt; {
    console.log(&lt;/span&gt;'dispatch: '&lt;span&gt;, action);
    let next &lt;/span&gt;=&lt;span&gt; dispatch(action);
    console.log(&lt;/span&gt;'nextState: '&lt;span&gt;, store.getState());
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next;
  }
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; logMiddleware2(&lt;span&gt;dispatch&lt;/span&gt;) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;&lt;span&gt; (action)&lt;/span&gt; {
    console.log(&lt;/span&gt;'logMiddleware2 start'&lt;span&gt;);
    let next &lt;/span&gt;=&lt;span&gt; dispatch(action);
    console.log(&lt;/span&gt;'logMiddleware2 end'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next;
  }
}

&lt;span&gt;let dispatch &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; logMiddleware2(logMiddleware(store.dispatch));&lt;/span&gt;
store.dispatch &lt;/span&gt;= dispatch;&lt;br/&gt;...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190124225715056-2107009500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Yes，we can！！！但是细看代码还是不完美，logMiddleware中store是直接获取的，严重耦合在一起。如果将logMiddleware单独放入一个模块文件中，代码就不能正常运行了。那还不简单，将store导出，再导入到logMiddleware模块中不就完了。可是这样还是严重耦合，只是换了一种方式而已(你写的中间件应该是其他小伙伴拿来即用的，不应该有其他骚操作)。骚年，还得再想想办法。index.js，不要抱怨，还得再改改你。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;function&lt;/span&gt;&lt;span&gt;&lt;span&gt; logMiddleware(store)&lt;/span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dispatch) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (action) {
      console.log(&lt;/span&gt;'dispatch: '&lt;span&gt;, action);
      let next &lt;/span&gt;=&lt;span&gt; dispatch(action);
      console.log(&lt;/span&gt;'nextState: '&lt;span&gt;, store.getState());
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next;
    }
  }
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&lt;span&gt; logMiddleware2(store)&lt;/span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (dispatch) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (action) {
      console.log(&lt;/span&gt;'logMiddleware2 start'&lt;span&gt;);
      let next &lt;/span&gt;=&lt;span&gt; dispatch(action);
      console.log(&lt;/span&gt;'logMiddleware2 end'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next;
    }
  }
}

&lt;/span&gt;&lt;span&gt;let dispatch = logMiddleware2(store)(logMiddleware(store)(store.dispatch));&lt;/span&gt;&lt;span&gt;&lt;span&gt;
store.dispatch&lt;/span&gt; &lt;/span&gt;= dispatch;&lt;br/&gt;...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以发现logMiddleware中dispatch是store.dispatch，logMiddleware2中的dispatch是logMiddleware中间件。既然如此，那换个名称，以免误会。这里统一改成next。最后let dispatch = ...只是为了让大家看懂过程，现在也改一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;function&lt;/span&gt;&lt;span&gt; logMiddleware(store) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (&lt;span&gt;next&lt;/span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (action) {
      console.log(&lt;/span&gt;'dispatch: '&lt;span&gt;, action);
      &lt;span&gt;let result &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; next(action);&lt;/span&gt;
      console.log(&lt;/span&gt;'nextState: '&lt;span&gt;, store.getState());
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;&lt;span&gt; result&lt;/span&gt;;
    }
  }
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; logMiddleware2(store) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (&lt;span&gt;next&lt;/span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (action) {
      console.log(&lt;/span&gt;'logMiddleware2 start'&lt;span&gt;);
      &lt;span&gt;let result &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; next(action);&lt;/span&gt;
      console.log(&lt;/span&gt;'logMiddleware2 end'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;&lt;span&gt; result&lt;/span&gt;;
    }
  }
}

&lt;span&gt;const middlewares &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= [logMiddleware2, logMiddleware];
const chain = middlewares.map(middleware =&amp;gt; middleware(store));
const chains = chain.reduce((a, b) =&amp;gt; (...args) =&amp;gt; a(b(...args)));
let dispatch =&lt;/span&gt;&lt;span&gt;&lt;span&gt; chains(store.dispatch);&lt;/span&gt;
store.dispatch &lt;/span&gt;= dispatch;&lt;br/&gt;...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190125002734378-244848742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;讲到这里，基础也差不多讲完了，希望你能对redux中间件有一个比较初步的认识。&lt;/p&gt;

</description>
<pubDate>Fri, 25 Jan 2019 13:41:00 +0000</pubDate>
<dc:creator>Raion</dc:creator>
<og:description>前言 原先改变store是通过dispatch(action) = &gt; reducer；那Redux的Middleware是什么呢？就是dispatch(action) = &gt; reduc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/raion/p/10312056.html</dc:identifier>
</item>
<item>
<title>MongoDB 中的【加减乘除】运算 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/10321650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/10321650.html</guid>
<description>&lt;p&gt;很多同学因为对MongoDB不熟悉，加之应用的不是很多，有时候会认为MongoDB数据库对一些功能不支持，或者认为支持不好。今天我们 演示一下 MongoDB对“加减乘除”的使用。&lt;/p&gt;
&lt;p&gt;在MongoDB数据库中“加减乘除”运算，又称为 数学表达式（mathematical expression；或算术表达式），主要用于操作数值。&lt;/p&gt;
&lt;h3&gt;1.$add操作符（+）&lt;/h3&gt;
&lt;h4&gt;1.1 语法及功能介绍&lt;/h4&gt;
&lt;p&gt;$add 操作符主要用于将一组数字相加；也可以用于在指定时间上添加一定的时间间隔。时间间隔单位为milliseconds（毫秒）。&lt;/p&gt;
&lt;p&gt;$add操作符的语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
{ $add: [ &amp;lt;expression1&amp;gt;, &amp;lt;expression2&amp;gt;, ... ] }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个操作符接受一个或多个表达式作为参数，将这些表达式相加。&lt;/p&gt;
&lt;h4&gt;1.2 案例演示&lt;/h4&gt;
&lt;p&gt;例如我们有一个sales的集合， 其中有 商品类别 字段、商品价格 字段，商品服务费 字段。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : &lt;span&gt;10&lt;/span&gt;, &quot;fee&quot; : &lt;span&gt;2&lt;/span&gt;, date: ISODate(&quot;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;01T08:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;:00Z&quot;) }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;item&quot; : &quot;jkl&quot;, &quot;price&quot; : &lt;span&gt;20&lt;/span&gt;, &quot;fee&quot; : &lt;span&gt;1&lt;/span&gt;, date: ISODate(&quot;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;01T09:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;:00Z&quot;) }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : &lt;span&gt;5&lt;/span&gt;,  &quot;fee&quot; : &lt;span&gt;0&lt;/span&gt;, date: ISODate(&quot;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;15T09:&lt;span&gt;00&lt;/span&gt;:00Z&quot;) }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有个需求，要统计 商品 的 总费用（price + fee），那么其统计SQL 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;db.sales.aggregate(
   &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
     { $project: { item: 1, total: { $add: [ &quot;$price&quot;, &quot;$fee&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; } } }
   ]
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果显示如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;item&quot; : &quot;abc&quot;, &quot;total&quot; : &lt;span&gt;12&lt;/span&gt;&lt;span&gt; }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;item&quot; : &quot;jkl&quot;, &quot;total&quot; : &lt;span&gt;21&lt;/span&gt;&lt;span&gt; }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &quot;item&quot; : &quot;xyz&quot;, &quot;total&quot; : &lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在我们来看下在时间上的$add运算，例如，在上面的集合中，我们想看看商品的 &lt;strong&gt;有效日期&lt;/strong&gt; ，假如商品的有效日期是在现有的date字段数据 + 3天（注意时间参数的单位为毫秒）。&lt;/p&gt;
&lt;p&gt;有效日期 命名为 expire_date，则相应的SQL如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;db.sales.aggregate(
   &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
     { $project: { item: 1, expire_date: { $add: [ &quot;$date&quot;, 3*24*60*60*1000 &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; } } }
   ]
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果显示为 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;item&quot; : &quot;abc&quot;, &quot;expire_date&quot; : ISODate(&quot;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;04T08:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;:00Z&quot;) }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;item&quot; : &quot;jkl&quot;, &quot;expire_date&quot; : ISODate(&quot;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;04T09:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;:00Z&quot;) }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &quot;item&quot; : &quot;xyz&quot;, &quot;expire_date&quot; : ISODate(&quot;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;18T09:&lt;span&gt;00&lt;/span&gt;:00Z&quot;) }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：此案例中有关时间的这种运算，在SQL Server 数据库中是通过函数 &lt;strong&gt;DATEADD(）&lt;/strong&gt;来实现的。&lt;/p&gt;
&lt;h3&gt;2.$subtract操作符（－）&lt;/h3&gt;
&lt;h4&gt;2.1 语法及功能介绍&lt;/h4&gt;
&lt;p&gt;$subtract操作符是$add的逆运算，它可以计算&lt;strong&gt;两个数值&lt;/strong&gt;的差值；可以计算 2个日期时间的间隔；还可以在指定日期上减去指定的时间间隔。关于时间的计算，参数的单位都是milliseconds（毫秒）。&lt;/p&gt;
&lt;p&gt;$subtract操作符的语法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{ $subtract: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; &amp;lt;expression1&amp;gt;, &amp;lt;expression2&amp;gt; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接受两个表达式作为参数，用第一个表达式减去第二个表达式作为结果。&lt;/p&gt;
&lt;h4&gt;2.2 案例演示&lt;/h4&gt;
&lt;p&gt;将案例1的集合 sales清空，插入以下数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : &lt;span&gt;10&lt;/span&gt;, &quot;fee&quot; : &lt;span&gt;2&lt;/span&gt;, &quot;discount&quot; : &lt;span&gt;5&lt;/span&gt;, &quot;date&quot; : ISODate(&quot;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;01T08:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;:00Z&quot;) }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;item&quot; : &quot;jkl&quot;, &quot;price&quot; : &lt;span&gt;20&lt;/span&gt;, &quot;fee&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;discount&quot; : &lt;span&gt;2&lt;/span&gt;, &quot;date&quot; : ISODate(&quot;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;01T09:&lt;span&gt;00&lt;/span&gt;:00Z&quot;) }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新的数据，添加了 商品打折 的字段 。如果此时统计商品的总费用，则需要 商品价格字段 + 服务费用字段 - 打折字段 &lt;/p&gt;
&lt;p&gt;SQL 语句如下 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
db.sales.aggregate( &lt;span&gt;[&lt;/span&gt;&lt;span&gt; { $project: { item: 1, total: { $subtract: [ { $add: [ &quot;$price&quot;, &quot;$fee&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }, &quot;$discount&quot; ] } } } ] )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;统计结果显示如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;item&quot; : &quot;abc&quot;, &quot;total&quot; : &lt;span&gt;7&lt;/span&gt;&lt;span&gt; }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;item&quot; : &quot;jkl&quot;, &quot;total&quot; : &lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于时间的减法运算有2个场景&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;场景1&lt;/strong&gt;&lt;/span&gt; ：计算两个日期的时间间隔（统计单位为毫秒）&lt;/p&gt;
&lt;p&gt;例如，我们计算sales中商品已生成存在的时间（现在的时间-集合中date字段）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
db.sales.aggregate( &lt;span&gt;[&lt;/span&gt;&lt;span&gt; { $project: { item: 1, dateDifference: { $subtract: [ new Date(), &quot;$date&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; } } } ] )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果显示为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;item&quot; : &quot;abc&quot;, &quot;dateDifference&quot; : NumberLong(&quot;&lt;span&gt;154747094624&lt;/span&gt;&lt;span&gt;&quot;) }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;item&quot; : &quot;jkl&quot;, &quot;dateDifference&quot; : NumberLong(&quot;&lt;span&gt;154743494624&lt;/span&gt;&quot;) }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：此案例中关于时间的这种运算，在SQL Server 数据库中是通过函数 &lt;strong&gt;DATEDiff(）&lt;/strong&gt;来实现的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;场景2：&lt;/span&gt;指定日期上减去一定的时间间隔&lt;/p&gt;
&lt;p&gt;假如sales集合中的商品一般是规定提前3个小时package的(date字段 --3个小时)，那么我们来计算出 这个package_date&lt;/p&gt;
&lt;p&gt;实现SQL的语句如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
db.sales.aggregate( &lt;span&gt;[&lt;/span&gt;&lt;span&gt; { $project: { item: 1, dateDifference: { $subtract: [ &quot;$date&quot;, 3 * 60 * 60 * 1000 &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; } } } ] )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果显示如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;item&quot; : &quot;abc&quot;, &quot;dateDifference&quot; : ISODate(&quot;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;01T05:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;:00Z&quot;) }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;item&quot; : &quot;jkl&quot;, &quot;dateDifference&quot; : ISODate(&quot;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;01T06:&lt;span&gt;00&lt;/span&gt;:00Z&quot;) }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：此案例中关于时间的这种运算，在SQL Server数据库中是通过函数 &lt;strong&gt;DATEADD(）&lt;/strong&gt;来实现的。&lt;/p&gt;
&lt;h3&gt;3.$multiply操作符（*）&lt;/h3&gt;
&lt;h4&gt;3.1 语法及功能介绍&lt;/h4&gt;
&lt;p&gt;$multiply操作符主要用来一组数值相乘。&lt;/p&gt;
&lt;p&gt;$multiplyt操作符的语法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
{ $multiply: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; &amp;lt;expression1&amp;gt;, &amp;lt;expression2&amp;gt;, ... &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接受一个或多个表达式，并将它们相乘。&lt;/p&gt;
&lt;h4&gt;3.2 案例演示&lt;/h4&gt;
&lt;p&gt;将案例2的集合 sales清空，插入以下数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;item&quot; : &quot;abc&quot;, &quot;price&quot; : &lt;span&gt;10&lt;/span&gt;, &quot;quantity&quot;: &lt;span&gt;2&lt;/span&gt;, date: ISODate(&quot;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;01T08:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;:00Z&quot;) }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;item&quot; : &quot;jkl&quot;, &quot;price&quot; : &lt;span&gt;20&lt;/span&gt;, &quot;quantity&quot;: &lt;span&gt;1&lt;/span&gt;, date: ISODate(&quot;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;01T09:&lt;span&gt;00&lt;/span&gt;&lt;span&gt;:00Z&quot;) }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &quot;item&quot; : &quot;xyz&quot;, &quot;price&quot; : &lt;span&gt;5&lt;/span&gt;, &quot;quantity&quot;: &lt;span&gt;10&lt;/span&gt;, date: ISODate(&quot;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;15T09:&lt;span&gt;00&lt;/span&gt;:00Z&quot;) }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个商品销售集合中，有商品的价格字段，还有商品数量字段，我们需要统计出，每个商品的总额（商品价格*商品数据量）&lt;/p&gt;
&lt;p&gt;统计的SQL语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   db.sales.aggregate(
   &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
     { $project: {  item: 1, total_price: { $multiply: [ &quot;$price&quot;, &quot;$quantity&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; } } }
   ]
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果显示如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;item&quot; : &quot;abc&quot;, &quot;total_price&quot; : &lt;span&gt;20&lt;/span&gt;&lt;span&gt; }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;item&quot; : &quot;jkl&quot;, &quot;total_price&quot; : &lt;span&gt;20&lt;/span&gt;&lt;span&gt; }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &quot;item&quot; : &quot;xyz&quot;, &quot;total_price&quot; : &lt;span&gt;50&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;4.$divide操作符（/）&lt;/h3&gt;
&lt;h4&gt;4.1 语法及功能介绍&lt;/h4&gt;
&lt;p&gt;$divide操作符主要用来2个数字相除。&lt;/p&gt;
&lt;p&gt;$divide操作符的语法为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{ $divide: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; &amp;lt;expression1&amp;gt;, &amp;lt;expression2&amp;gt; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;接受两个表达式&lt;/strong&gt;，将第一个表达式除以第二个表达式的商作为结果。&lt;/p&gt;
&lt;h4&gt;4.2 案例演示&lt;/h4&gt;
&lt;p&gt;例如我们有一个关于项目计划的集合&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;planning&lt;/span&gt;&lt;/code&gt; ， 在这个集合中 有关于耗时的字段 &lt;span class=&quot;s2&quot;&gt;hours，数据格式如下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;name&quot; : &quot;A&quot;, &quot;hours&quot; : &lt;span&gt;80&lt;/span&gt;, &quot;resources&quot; : &lt;span&gt;7&lt;/span&gt;&lt;span&gt; },
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;name&quot; : &quot;B&quot;, &quot;hours&quot; : &lt;span&gt;40&lt;/span&gt;, &quot;resources&quot; : &lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的数据是安照工时统计的，如果我们安照工作日统计（工时/8）,其SQL语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;db.planning.aggregate(
   &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
     { $project: { name: 1, workdays: { $divide: [ &quot;$hours&quot;, 8 &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; } } }
   ]
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果显示如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;name&quot; : &quot;A&quot;, &quot;workdays&quot; : &lt;span&gt;10&lt;/span&gt;&lt;span&gt; }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;name&quot; : &quot;B&quot;, &quot;workdays&quot; : &lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5  求余 运算（$mod）&lt;/h3&gt;
&lt;p&gt;讲到除法运算，自然就会想到求余的运算（%），下面我们简单介绍以下求余运算符$mod。&lt;/p&gt;
&lt;h4&gt;5.1 语法及功能介绍&lt;/h4&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{ $mod: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; &amp;lt;expression1&amp;gt;, &amp;lt;expression2&amp;gt; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;接受两个表达式&lt;/strong&gt;，将第一个表达式除以第二个表达式得到的余数作为结果。&lt;/p&gt;
&lt;h4&gt;5.2 案例演示&lt;/h4&gt;
&lt;p&gt;还是上面的关于任务计划的集合，上面有工时字段，还有任务字段，数据格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;project&quot; : &quot;A&quot;, &quot;hours&quot; : &lt;span&gt;80&lt;/span&gt;, &quot;tasks&quot; : &lt;span&gt;7&lt;/span&gt;&lt;span&gt; }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;project&quot; : &quot;B&quot;, &quot;hours&quot; : &lt;span&gt;40&lt;/span&gt;, &quot;tasks&quot; : &lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们统计每个任务平均后，剩余的时间，SQL语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;db.planning.aggregate(
   &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
     { $project: { remainder: { $mod: [ &quot;$hours&quot;, &quot;$tasks&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; } } }
   ]
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果显示如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;remainder&quot; : &lt;span&gt;3&lt;/span&gt;&lt;span&gt; }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;remainder&quot; : &lt;span&gt;0&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;6.案例分析&lt;/h3&gt;
&lt;p&gt;在文章的最后一节，我们用一个例子，巩固一下上面的学习，同时引入另外一个知识点----逻辑表达式。&lt;/p&gt;
&lt;h4&gt;6.1 案例探究&lt;/h4&gt;
&lt;p&gt;假如有个大学教授想通过某种比较复杂的计算为他的学生打分：出勤率占10%，日常测验成绩占30%，期末考试成绩占60%，但如果是老师宠爱的学生，那么分数就是100.&lt;/p&gt;
&lt;p&gt;关于学生students集合的数据格式如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;sno&quot; : &lt;span&gt;201501010001&lt;/span&gt;, &quot;name&quot; : &quot;xiaoming&quot;, &quot;attendanceAvg&quot; : &lt;span&gt;90&lt;/span&gt;, &quot;quizzAvg&quot; : &lt;span&gt;95&lt;/span&gt;, &quot;testAvg&quot; : &lt;span&gt;98&lt;/span&gt;&lt;span&gt;, &quot;teacherPet&quot; : true }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;sno&quot; : &lt;span&gt;201501010002&lt;/span&gt;, &quot;name&quot; : &quot;xiaoli&quot;, &quot;attendanceAvg&quot; : &lt;span&gt;100&lt;/span&gt;, &quot;quizzAvg&quot; : &lt;span&gt;90&lt;/span&gt;, &quot;testAvg&quot; : &lt;span&gt;90&lt;/span&gt;&lt;span&gt;, &quot;teacherPet&quot; : false }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &quot;sno&quot; : &lt;span&gt;201501010003&lt;/span&gt;, &quot;name&quot; : &quot;xiaohong&quot;, &quot;attendanceAvg&quot; : &lt;span&gt;100&lt;/span&gt;, &quot;quizzAvg&quot; : &lt;span&gt;80&lt;/span&gt;, &quot;testAvg&quot; : &lt;span&gt;100&lt;/span&gt;, &quot;teacherPet&quot; : false }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;满足此教授老师需求的查询SQL语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;db.students.aggregate(
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
        {
            $project:
                {

                    &quot;sno&quot;: 1, &quot;name&quot;: 1,
                    grade:
                        {
                            $cond: [&quot;$teacherPet&quot;, 100, {
                                &quot;$add&quot;:
                                    [
                                        { &quot;$multiply&quot;: [&quot;$attendanceAvg&quot;, .1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; },
                                        { &quot;$multiply&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;$quizzAvg&quot;, .3&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; },
                                        { &quot;$multiply&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;$testAvg&quot;, .6&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; }
                                    ]
                            }]
                        }
                }
        }
    ]
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询的结果如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;sno&quot; : &lt;span&gt;201501010001&lt;/span&gt;, &quot;name&quot; : &quot;xiaoming&quot;, &quot;grade&quot; : &lt;span&gt;100&lt;/span&gt;&lt;span&gt; }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;sno&quot; : &lt;span&gt;201501010002&lt;/span&gt;, &quot;name&quot; : &quot;xiaoli&quot;, &quot;grade&quot; : &lt;span&gt;91&lt;/span&gt;&lt;span&gt; }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &quot;sno&quot; : &lt;span&gt;201501010003&lt;/span&gt;, &quot;name&quot; : &quot;xiaohong&quot;, &quot;grade&quot; : &lt;span&gt;94&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在本例中我们不仅用到了数学表达式$add,$$multiply，还用到了逻辑表达式$cond（&lt;strong&gt;if 老师宠爱的学生 就100，否则 计算分数...&lt;/strong&gt;）。下面，我们粗略讲解一下关于 MongoDB的逻辑表达式。&lt;/p&gt;
&lt;h4&gt;6.2 常用逻辑表达式&lt;/h4&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;24.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;类别&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;操作符&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;语法&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;功能用途&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td rowspan=&quot;3&quot;&gt;布尔表达式&lt;/td&gt;
&lt;td&gt;$and&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;nx&quot;&gt;{$and&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;p&quot;&gt;[ &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nx&quot;&gt;expression1&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nx&quot;&gt;expression2&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;p&quot;&gt;... &lt;span class=&quot;p&quot;&gt;]}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;如果所有表达式的值为true，那就返回true，否则返回false。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;$or&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;nx&quot;&gt;{$or&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;p&quot;&gt;[ &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nx&quot;&gt;expression1&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nx&quot;&gt;expression2&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;p&quot;&gt;... &lt;span class=&quot;p&quot;&gt;]}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;只要有任意表达式的值为true，那就返回true，否则返回false。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;$not&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;p&quot;&gt;{ &lt;span class=&quot;nx&quot;&gt;$not&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;p&quot;&gt;[ &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nx&quot;&gt;expression&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;p&quot;&gt;] &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;对&lt;span class=&quot;p&quot;&gt;expression取反。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12.5&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;控制表达式&lt;/td&gt;
&lt;td&gt;$cond&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;p&quot;&gt;{ &lt;span class=&quot;nx&quot;&gt;$cond&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;p&quot;&gt;{ &lt;span class=&quot;k&quot;&gt;if&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;kr&quot;&gt;boolean&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;nx&quot;&gt;expression&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;nx&quot;&gt;then&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;kc&quot;&gt;true&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;k&quot;&gt;case&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;k&quot;&gt;else&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;kc&quot;&gt;false&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;k&quot;&gt;case&lt;span class=&quot;o&quot;&gt;-&amp;gt; &lt;span class=&quot;p&quot;&gt;} &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;或者&lt;br/&gt;&lt;span class=&quot;p&quot;&gt;{ &lt;span class=&quot;nx&quot;&gt;$cond&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;p&quot;&gt;[ &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;kr&quot;&gt;boolean&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;nx&quot;&gt;expression&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;kc&quot;&gt;true&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;k&quot;&gt;case&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;kc&quot;&gt;false&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;k&quot;&gt;case&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;p&quot;&gt;] &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt; 如果&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;k&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;kr&quot;&gt;boolean&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;nx&quot;&gt;expression为的值是true，那就返回&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;k&quot;&gt;case，否则返回&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;k&quot;&gt;case。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt; $ifNull&lt;/td&gt;
&lt;td&gt; { &lt;span class=&quot;nx&quot;&gt;$ifNull&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;p&quot;&gt;[ &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nx&quot;&gt;expression&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nx&quot;&gt;replacement&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;nx&quot;&gt;expression&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;k&quot;&gt;if&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;p&quot;&gt;] &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; 如果&lt;span class=&quot;nx&quot;&gt;expression是null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;k&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;kr&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nx&quot;&gt;，那就返回&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nx&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nx&quot;&gt;replacement&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;nx&quot;&gt;expression&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;k&quot;&gt;if&lt;span class=&quot;o&quot;&gt;-&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，否则返回&lt;/span&gt;expression。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td rowspan=&quot;3&quot;&gt;比较表达式&lt;/td&gt;
&lt;td&gt; $cmp&lt;/td&gt;
&lt;td&gt; { &lt;span class=&quot;nx&quot;&gt;$cmp&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;p&quot;&gt;[ &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nx&quot;&gt;expression1&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nx&quot;&gt;expression2&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;p&quot;&gt;] &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; 比较expression1和expression2，如果相等，返回0；如果前者大于后者，返回一个正数1；如果前者小于后者。返回一个负数-1。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt; $strcasecmp&lt;/td&gt;
&lt;td&gt; { &lt;span class=&quot;nx&quot;&gt;$strcasecmp&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;p&quot;&gt;[ &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nx&quot;&gt;expression1&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nx&quot;&gt;expression2&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;p&quot;&gt;] &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; $cmp的细化。用来比较expression1和expression2；区分大小写，主要针对ASCII characters。如果相等，返回0；如果前者大于后者，返回一个正数1；如果前者小于后者。返回一个负数-1。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt; $eq/$ne/$gt/$gte/$lt/$lte&lt;/td&gt;
&lt;td&gt; $eq/$ne/$gt/$gte/$lt/$lte :[ &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nx&quot;&gt;expression1&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;span class=&quot;nx&quot;&gt;expression2&lt;span class=&quot;o&quot;&gt;&amp;gt; &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; 对expression1和expression2执行相应的比较操作，返回比较的结构（true或false）。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;通过这些操作符，就可以在聚合中使用更复杂的逻辑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文部分例子来自官网及网络，在此感谢。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 25 Jan 2019 13:29:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>很多同学因为对MongoDB不熟悉，加之应用的不是很多，有时候会认为MongoDB数据库对一些功能不支持，或者认为支持不好。今天我们 演示一下 MongoDB对“加减乘除”的使用。 在MongoDB数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/10321650.html</dc:identifier>
</item>
<item>
<title>如何将Azure DevOps中的代码发布到Azure App Service中 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10321718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10321718.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;标题：如何将Azure DevOps中的代码发布到Azure App Service中&lt;br/&gt;作者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近做了几个项目一直在用Azure DevOps和Azure App Service, 每次都要从零开始搭建从Azure DevOps向Azure App Service发布代码的环境，由于步骤比较繁琐，每次都会忘记其中几个步骤，所以在此总结一下，已备后续再次使用。&lt;/p&gt;
&lt;h2 id=&quot;azure-devops和azure-app-service&quot;&gt;Azure DevOps和Azure App Service&lt;/h2&gt;
&lt;h3 id=&quot;azure-devops&quot;&gt;Azure DevOps&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125211935317-1969397947.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Azure DevOps其实就是以前的Visutal Studio Team Services Online, 提供了项目管理和源代码管理的功能。你可以将项目源代码代码托管到Azure DevOps，并使用它的Build Pipeline将代码发布指定的服务器或者App Service中。&lt;/p&gt;
&lt;h3 id=&quot;azure-app-service&quot;&gt;Azure App Service&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125211943450-2008805314.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;App Service使用Azure中的一种重要服务，用户使用它可以快速构建、部署和缩放在任何平台上运行的企业级Web应用、移动应用和API应用。当你需要部署项目的时候，你不需要搭建任何环境，只需要将代码发布到App Service即可, Azure会为你准备好程序运行的环境。&lt;/p&gt;
&lt;p&gt;另外App Service提供了许多运维的功能，比如备份，缩放，日志，你只需要进行简单配置就可实现许多复杂的功能。&lt;/p&gt;
&lt;h2 id=&quot;如何将azure-devops中的代码发布到azure-app-service中&quot;&gt;如何将Azure DevOps中的代码发布到Azure App Service中？&lt;/h2&gt;
&lt;p&gt;为了演示如何将Azure DevOps中的代码发布到Azure App Service中，我们首先在Azure DevOps中创建一个新的代码库，代码库中只有一个index.html文件，代码如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212004779-1180338886.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;Hello World!&amp;lt;/body&amp;gt;
&amp;lt;/html  &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第一步添加一个azure-app-service&quot;&gt;第一步：添加一个Azure App Service&lt;/h3&gt;
&lt;p&gt;为了部署我们的项目，我们首先需要在Azure Portal中创建一个App Service.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212016406-1948493321.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们将当前Web应用起名为LamondTest, 后续我们就可以使用http://LamondTest.azurewebsites.net的域名来访问我们的应用。&lt;/p&gt;
&lt;h3 id=&quot;第二步-在azure-ad中添加一个app-registration&quot;&gt;第二步： 在Azure AD中添加一个App Registration&lt;/h3&gt;
&lt;p&gt;为了将Azure Devops中的代码发布到Azure App Service中，我们需要在Azure AD中注册一个App。&lt;/p&gt;
&lt;p&gt;我们可以从左侧菜单中选择Azure AD, 然后选择App Registration, 你就能看到如下页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212025902-1264361038.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击+New application registration&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212031998-149985958.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我给这个Application命名为DeploymentApp, 然后Application type选择Web app / API。&lt;/p&gt;
&lt;p&gt;因为我们这个Application只是来辅助发布项目的，所以Sign-on URL对我们不是很重要，所以我就随便用了度娘的URL.&lt;/p&gt;
&lt;p&gt;创建成功之后，你会看到一下界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212038738-1252331236.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里比较重要的是Application ID, 你需要将它记下来，以便后续操作使用&lt;/p&gt;
&lt;h3 id=&quot;第二步创建访问应用使用的key&quot;&gt;第二步：创建访问应用使用的Key&lt;/h3&gt;
&lt;p&gt;如果你完成上一步操作之后，不要关闭面板，继续点击面板中的Settings按钮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212044698-212372710.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择API ACCESS -&amp;gt; Keys&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212049818-940964695.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加一个TestKey, 并设置永不过期，Value值可以任何设置一个，保存之后这个Value值保存成一串密钥，这里这串密钥需要保存一下，以备后续使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212055590-126469572.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第三歩-为deploymentapp分配contributor角色&quot;&gt;第三歩： 为DeploymentApp分配Contributor角色&lt;/h3&gt;
&lt;p&gt;为了借助DeploymentApp发布代码，我们需要将LamondTest这个App Service的Contributor角色分配给DeploymentApp.&lt;/p&gt;
&lt;p&gt;这里我们可以通过LamondTest -&amp;gt; Access Control(IAM) -&amp;gt; Add role assignment添加角色，并保存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212104239-1612894615.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212110740-447444075.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第四步获取tenantid和subscriptionid&quot;&gt;第四步：获取TenantId和SubscriptionId&lt;/h3&gt;
&lt;p&gt;除了前面的Application ID和密钥，我们还需要找到当前Azure的Tenant Id和Subscription Id&lt;/p&gt;
&lt;h4 id=&quot;tenant-id&quot;&gt;Tenant Id&lt;/h4&gt;
&lt;p&gt;我们可以从 Azure Active Directory -&amp;gt; Properties 中查找到Directory ID, 这里Directory ID即我们所需的Tenant Id&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212128029-384595118.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;subscription-id&quot;&gt;Subscription Id&lt;/h4&gt;
&lt;p&gt;Subscription Id，即订阅Id, 我们可以在Subscription模块中找到它&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212134626-839959534.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;第五步创建azure-resource-manager&quot;&gt;第五步：创建Azure Resource Manager&lt;/h3&gt;
&lt;p&gt;前面四步都是在Azure Portal中的操作，后面的所有操作都是在Azure DevOps中来操作&lt;/p&gt;
&lt;p&gt;首先我们需要来添加Azure Resource Manager, 我们可以通过Project Settings -&amp;gt; Service connections -&amp;gt; +New service connections -&amp;gt; Azure Resource Manager来打开添加界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212142594-1364060804.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击use the full version of the service connection dialog&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212148305-1391477733.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里Subscription ID和Tenant ID就是第四步中获取到的2个ID，Service principal client ID和Service principal key分别就是第二步中的Application ID和密钥。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：这里Subscription name必须输入正确，通常来说都是Pay-As-You-Go, 如果不同，你可以根据你自己的Azure Subscription name来替换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212155893-1431581608.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我将这个连接命名为LamondTestConnection。&lt;/p&gt;
&lt;p&gt;点击OK之前我们可以通过Verify connection来尝试连接，连接成功会返回一个Verified状态图标&lt;/p&gt;
&lt;h3 id=&quot;第六步创建build-pipeline&quot;&gt;第六步：创建Build Pipeline&lt;/h3&gt;
&lt;p&gt;当前面操作都完成之后，我们就可以开始创建Build Pipleline了&lt;/p&gt;
&lt;p&gt;我们可以通过Pipelines -&amp;gt; Builds -&amp;gt; New Pipeline打开添加Build Pipleline界面。&lt;/p&gt;
&lt;p&gt;这里我们需要选择代码来源Azure Repos Git， 然后选择我们之前创建的源代码仓储HelloWorld, 点击Continue&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212203614-865799864.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后选择Empty Job&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212210270-1116028954.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212216342-508600741.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Pipeline管理页面中，点击加号，选择Azure App Service Deploy&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212222482-821352852.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择Azure App Service Deploy: LamondTest, 设置Azure subscription为LamondTestConnection, 并选择App Service name为LamondTest&lt;/p&gt;
&lt;p&gt;最后将Package or folder设置为$(System.DefaultWorkingDirectory)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212228018-101141891.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后点击Save &amp;amp; Queue, 我们的代码就会自动发布到之前定义好的App Service中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212235078-2141703810.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后我们使用浏览器访问https://lamondtest.azurewebsites.net/, 网页代码就正确显示了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212240677-2041071976.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;附加-启用持续集成&quot;&gt;附加： 启用持续集成&lt;/h3&gt;
&lt;p&gt;Azure DevOps的Build Pipeline还支持持续集成，我们可以设置每天定时发布或者每次check-in都触发代码发布，我们可以修改刚才创建的Build Pipeline.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212252818-155272534.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Triggers页签中，我们可以启用Enable continous integration.&lt;/p&gt;
&lt;p&gt;在下面的Branch Filter中，你可以设置监控的代码分支。&lt;/p&gt;
&lt;p&gt;现在我们去修改之前的index.html.&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;Hello Continuous Integration!&amp;lt;/body&amp;gt;
&amp;lt;/html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后签入代码。&lt;/p&gt;
&lt;p&gt;现在我们返回Azure DevOps的Build Pipleline界面，你会发现代码开始自动发布了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212259238-955287878.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发布成功之后，我们重新用浏览器访问https://lamondtest.azurewebsites.net/, 新的代码已经启用了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190125212304117-1965363828.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这说明我们的代码持续集成配置成功了。&lt;/p&gt;
</description>
<pubDate>Fri, 25 Jan 2019 13:26:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>最近做了几个项目一直在用Azure DevOps和Azure App Service, 每次都要从零开始搭建从Azure DevOps向Azure App Service发布代码的环境，由于步骤比较繁</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10321718.html</dc:identifier>
</item>
</channel>
</rss>