<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring简单介绍 - qiuxuhui</title>
<link>http://www.cnblogs.com/qxhIndex/p/14131640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qxhIndex/p/14131640.html</guid>
<description>&lt;p&gt;官网：spring.io&lt;/p&gt;
&lt;p&gt;1，spring是一个开源框架。&lt;/p&gt;
&lt;p&gt;　　1，包下载：https://repo.spring.io/release/org/springframework/spring/&lt;/p&gt;
&lt;p&gt;　　　　https://mvnrepository.com/artifact/org.slf4j/slf4j-api/2.0.0-alpha1&lt;/p&gt;
&lt;p&gt;　　2，导包：commons-logging-1.2.jar&lt;/p&gt;
&lt;p&gt;　　　　　　spring-beans-5.3.2.jar&lt;/p&gt;
&lt;p&gt;　　　　　　spring-context-5.3.2.jar&lt;/p&gt;
&lt;p&gt;　　　　　　spring-core-5.3.2.jar&lt;/p&gt;
&lt;p&gt;　　　　　　spring-expression-5.3.2.jar&lt;/p&gt;
&lt;p&gt;　　　　　　spring-test-5.3.2.jar&lt;/p&gt;
&lt;p&gt;2，spring是分层的JavaEE，一站式轻量级框架。&lt;/p&gt;
&lt;p&gt;　　分层的javaEE：&lt;/p&gt;
&lt;p&gt;　　　　持久层：--jdbc(性能)、Mybatis()&lt;/p&gt;
&lt;p&gt;　　　　视图层：--jsp/servlet&lt;/p&gt;
&lt;p&gt;　　　　控制层：--servlet&lt;/p&gt;
&lt;p&gt;　　一站式：JavaEE 每层都有解决方案&lt;/p&gt;
&lt;p&gt;　　轻量级：spring无侵入式（低耦合，高内聚）&lt;/p&gt;
&lt;p&gt;3，spring版本：&lt;/p&gt;
&lt;p&gt;　　1，GA 稳定版&lt;/p&gt;
&lt;p&gt;　　2，SNAPSHOT 快照版，可以稳定使用，且仍在继续改进&lt;/p&gt;
&lt;p&gt;　　3，RELEASE 预览版，内侧版本&lt;/p&gt;
&lt;p&gt;4，spring核心：&lt;/p&gt;
&lt;p&gt;　　1，ioc &amp;amp; di&lt;/p&gt;
&lt;p&gt;　　　　IOC控制反转 Inverse object control&lt;/p&gt;
&lt;p&gt;　　　　　　1，控制什么？new对象的权利&lt;/p&gt;
&lt;p&gt;　　　　　　　　1，项目，程序中都是程序员 new对象&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　（以前我们要自己new对象，现在spring帮我们new对象，以后我们需要对象，就找spring要）&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　以前：做鞋子手工做，效率低，每个细节都要关注&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　现在：工厂做，效率高，不需要关注每个细节&lt;/p&gt;
&lt;p&gt;　　　　　　2，谁控制谁？&lt;/p&gt;
&lt;p&gt;　　　　　　　　1，程序控制 new对象&lt;/p&gt;
&lt;p&gt;　　　　　　3，反转什么？&lt;/p&gt;
&lt;p&gt;　　　　　　　　1，程序员 new对象的权利反转给spring&lt;/p&gt;
&lt;p&gt;　　2，aop&lt;/p&gt;
&lt;p&gt;　　3，事物管理器&lt;/p&gt;
&lt;p&gt;　　4，spring mvc&amp;amp;webFlux --最新的 mvc框架&lt;/p&gt;
&lt;p&gt;5，spring中为什么叫bean工厂而不叫对象工厂？&lt;/p&gt;
&lt;p&gt;　　1，对象----new类出来就是对象（女朋友，说换就换）&lt;/p&gt;
&lt;p&gt;　　2，bean---具有生命周期的对象（媳妇，不能说换就换）&lt;/p&gt;
&lt;p&gt;6，spring bean工厂&lt;/p&gt;
&lt;p&gt;　　1，不适用bean工厂模式&lt;/p&gt;
&lt;p&gt;　　　　面向对象的六大原则：开闭原则 系统/程序对修改关闭，对扩展开放&lt;/p&gt;
&lt;p&gt;　　2，自己实现工厂----GOF23设计模式（单列模式，工厂模式）&lt;/p&gt;
&lt;p&gt;　　　　1，自己阅读工厂模式材料学习&lt;/p&gt;
&lt;p&gt;　　　　2，开闭原则：对修改关闭，对扩展开发&lt;/p&gt;





&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//创建一个BlackPig类 继承Pig父类&lt;br/&gt;public class BlackPig extends Pig{
    private int age;
    private String name;
    public BlackPig() {
        System.out.println(&quot;调用了BlackPig的构造方法&quot;);
    }
    public BlackPig(int age, String name) {
        super();
        this.age = age;
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return &quot;BlackPig [age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;;
    }
  
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//创建一个pig类
public class Pig {

}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//创建一个工厂
/*
 * 对象工厂还不能说是bean工厂
 * 
 * 
 */
public class ObjectFactory&amp;lt;T&amp;gt; {
    //不够优雅
//    public RedPig createRedpig() {
//        return new RedPig();
//    }
//    public BlackPig createBlackPig() {
//        return new BlackPig();
//    }
    
    
    /**
     * 稍微修改 多态：父引用指向任何子类对象
     * Pig p1 = new RedPig();
     * 
     * Pig p2 = new BlackPig();
     */
    
//    public Pig createPig(String type) {
//        if(type.equals(&quot;red&quot;)) {
//            return new RedPig();
//        }else if(type.equals(&quot;black&quot;)) {
//            return new BlackPig();
//        }else if(type.equals(&quot;blue&quot;)) {
//            return new BluePig();
//        }else if(type.equals(&quot;green&quot;)) {
//            return new GreenPig();
//        }else {
//            return null;
//        }
//    }
    //优雅的玩法 符合开闭原则的玩法 spring玩法
    public T createPig(Class clazz) {
        try {
            return (T) clazz.newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        return null;
    }
    
    
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//测试
public class Test {
    public static void main(String[] args) {
        //1.通过猪对象工厂获取黑猪或红猪对象
        ObjectFactory&amp;lt;Pig&amp;gt; factory = new ObjectFactory&amp;lt;Pig&amp;gt;();
        //获取黑猪
        Pig blackPig =factory.createPig(BlackPig.class);// (BlackPig) factory.createPig(&quot;black&quot;);//factory.createBlackPig();
        
        //获取狗，一样需要dog父类，和dog类
        ObjectFactory&amp;lt;Dog&amp;gt;  factory2 = new ObjectFactory&amp;lt;Dog&amp;gt;();
        Dog createPig = factory2.createPig(RedDog.class);
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 15 Dec 2020 00:44:00 +0000</pubDate>
<dc:creator>qiuxuhui</dc:creator>
<og:description>官网：spring.io 1，spring是一个开源框架。 1，包下载：https://repo.spring.io/release/org/springframework/spring/ https</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qxhIndex/p/14131640.html</dc:identifier>
</item>
<item>
<title>【小菜学网络】以太网帧结构 - fasionchan</title>
<link>http://www.cnblogs.com/fasionchan/p/ethernet-frame.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fasionchan/p/ethernet-frame.html</guid>
<description>&lt;p&gt;上一小节，我们通过一个虚构的协议，初步认识了数据链路层的工作原理。数据链路层主要解决由若干主机组成的本地网络的通讯问题，&lt;strong&gt;寻址&lt;/strong&gt; 和 &lt;strong&gt;复用分用&lt;/strong&gt; 思想在其中发挥着关键作用。&lt;/p&gt;
&lt;p&gt;数据链路层有一个非常重要的协议—— &lt;strong&gt;以太网协议&lt;/strong&gt; 。接下来，我们一起来揭开它的神秘面纱！&lt;/p&gt;
&lt;p&gt;使用以太网协议进行通信的主机间，必须通过某种介质直接相连。通信介质可以是真实的物理设备，如网线、网卡等；也可以是通过虚拟化技术实现的虚拟设备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/p/c63b3ba2aa5bfe2d5f850bf8d66f8d04eb97abbc.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在以太网中，数据通信的基本单位是 &lt;strong&gt;以太网帧&lt;/strong&gt; ( &lt;em&gt;frame&lt;/em&gt; )，由 &lt;strong&gt;头部&lt;/strong&gt; ( &lt;em&gt;header&lt;/em&gt; )、&lt;strong&gt;数据&lt;/strong&gt; ( &lt;em&gt;data&lt;/em&gt; )以及 &lt;strong&gt;校验和&lt;/strong&gt; ( &lt;em&gt;checksum&lt;/em&gt; )三部分构成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/p/e8209e82c82e391c860bd5ef35678232cc38b083.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;请注意，这图中的单位为字节，而不是比特了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;头部&quot;&gt;头部&lt;/h2&gt;
&lt;p&gt;以太网帧头部包含 &lt;em&gt;3&lt;/em&gt; 个字段，依次是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;目的地址&lt;/strong&gt; ，长度是 &lt;em&gt;6&lt;/em&gt; 字节，用于标记数据由哪台机器接收；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;源地址&lt;/strong&gt; ，长度也是 &lt;em&gt;6&lt;/em&gt; 字节，用于标记数据由哪台机器发送；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型&lt;/strong&gt; ，长度是 &lt;em&gt;2&lt;/em&gt; 字节，用于标记数据该如何处理， &lt;code&gt;0x0800&lt;/code&gt; 表示该帧数据是一个 &lt;em&gt;IP&lt;/em&gt; 包(后续章节介绍)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了字段长度有所拓展之外，以太网帧跟我们虚构出来的协议如出一辙。对了，我们注意到一点小差异——在以太网帧中， &lt;strong&gt;目的地址&lt;/strong&gt; 放在最前面。 这其中有什么特殊考虑吗？&lt;/p&gt;
&lt;p&gt;确实是有的。接收方收到一个以太网帧后，最先处理 &lt;strong&gt;目的地址&lt;/strong&gt; 字段。如果发现该帧不是发给自己的，后面的字段以及数据就不需要处理了。基础网络协议影响方方面面，设计时处理效率也是一个非常重要的考量。&lt;/p&gt;
&lt;h2 id=&quot;数据&quot;&gt;数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt; 可以是任何需要发送的信息，长度可变， &lt;em&gt;46&lt;/em&gt; 至 &lt;em&gt;1500&lt;/em&gt; 字节均可。&lt;/p&gt;
&lt;p&gt;上层协议报文，例如 &lt;em&gt;IP&lt;/em&gt; 包，可以作为数据封装在以太网帧中，在数据链路层中传输。因此，数据还有另一个更形象的称谓，即 &lt;strong&gt;负荷&lt;/strong&gt; ( &lt;em&gt;payload&lt;/em&gt; )。请自行脑补数据 &lt;strong&gt;搭载&lt;/strong&gt; 在以太网帧这个交通工具上旅行的画面。&lt;/p&gt;
&lt;h2 id=&quot;校验和&quot;&gt;校验和&lt;/h2&gt;
&lt;p&gt;由于物理信号可能受到环境的干扰，网络设备传输的比特流可能会出错。一个以太网帧从一台主机传输到另一台主机的过程中，也可能因各种因素而出错。那么当主机收到以太网帧时，如何确定它是完好无损的呢？&lt;/p&gt;
&lt;p&gt;答案是： &lt;strong&gt;校验和&lt;/strong&gt; 。我们可以用诸如 &lt;strong&gt;循环冗余校验&lt;/strong&gt; ( &lt;em&gt;CRC&lt;/em&gt; )算法，为以太网帧计算校验和。如果以太网帧在传输的过程出错，校验和将发生改变。&lt;/p&gt;
&lt;p&gt;注意到，以太网帧最后面有一个 &lt;em&gt;4&lt;/em&gt; 字节字段，用于保存校验和。发送者负责为每个以太网帧计算校验和，并将计算结果填写在校验和字段中；接收者接到以太网帧后，重新计算校验和并与校验和字段进行对比；如果两个校验和不一致，说明该帧在传输时出错了。&lt;/p&gt;
&lt;p&gt;【小菜学网络】系列文章首发于公众号【小菜学编程】，敬请关注：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.fasionchan.com/coding-fan-wechat-soso.png?x-oss-process=image/resize,w_359&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 Dec 2020 00:20:00 +0000</pubDate>
<dc:creator>fasionchan</dc:creator>
<og:description>上一小节，我们通过一个虚构的协议，初步认识了数据链路层的工作原理。数据链路层主要解决由若干主机组成的本地网络的通讯问题，寻址 和 复用分用 思想在其中发挥着关键作用。 数据链路层有一个非常重要的协议—</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fasionchan/p/ethernet-frame.html</dc:identifier>
</item>
<item>
<title>路由器你竟然是这样的... - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/14136686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/14136686.html</guid>
<description>&lt;blockquote readability=&quot;4&quot;&gt;
&lt;p&gt;我把自己以往的文章汇总成为了 Github ，欢迎各位大佬 star&lt;br/&gt;&lt;a href=&quot;https://github.com/crisxuan/bestJavaer&quot; target=&quot;_blank&quot;&gt;https://github.com/crisxuan/bestJavaer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面我们学习了运输层如何为客户端和服务器输送数据的，提供进程端到端的通信。那么下面我们将学习网络层实际上是怎样实现主机到主机的通信服务的。&lt;strong&gt;几乎每个端系统都有网络层这一部分&lt;/strong&gt;。所以，网络层必然是很复杂的。下面我将花费大量篇幅来介绍一下计算机网络层的知识。&lt;/p&gt;
&lt;h2 id=&quot;网络层概述&quot;&gt;网络层概述&lt;/h2&gt;
&lt;p&gt;网络层是 OSI 参考模型的第三层，它位于传输层和链路层之间，网络层的主要目的是实现两个端系统之间透明的数据传输。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215080838621-208650246.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网络层的作用从表面看上去非常简单，即将&lt;code&gt;分组&lt;/code&gt;从一台主机移动到另外一台主机。为了实现这个功能，网络层需要两种功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;转发&lt;/code&gt;：因为在互联网中有很多&lt;code&gt;路由器&lt;/code&gt;的存在，而路由器是构成互联网的根本，路由器最重要的一个功能就是&lt;code&gt;分组转发&lt;/code&gt;，当一个分组到达某路由器的一条输入链路时，该路由器会将分组移动到适当的输出链路。转发是在数据平面中实现的唯一功能。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在网络中存在两种平面的选择&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据平面(data plane)：负责转发网络流量，如路由器交换机中的转发表（我们后面会说）。&lt;/li&gt;
&lt;li&gt;控制平面(control plane)：控制网络的行为，比如网络路径的选择。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;路由选择&lt;/code&gt;：当分组由发送方流向接收方时，网络层必须选择这些分组的路径。计算这些路径选择的算法被称为 &lt;code&gt;路由选择算法(routing algorithm)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说，&lt;strong&gt;转发是指将分组从一个输入链路转移到适当输出链路接口的路由器本地动作&lt;/strong&gt;。而路由选择是指确定分组从源到目的地所定位的路径的选择。我们后面会经常提到转发和路由选择这两个名词。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么此处就有一个问题，路由器怎么知道有哪些路径可以选择呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每台路由器都有一个关键的概念就是 &lt;code&gt;转发表(forwarding table)&lt;/code&gt;。路由器通过检查数据包标头中字段的值，来定位转发表中的项来实现转发。标头中的值即对应着转发表中的值，这个值指出了分组将被转发的路由器输出链路。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215080853380-1662437244.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中有一个 1001 分组到达路由器后，首先会在转发表中进行索引，然后由路由选择算法决定分组要走的路径。每台路由器都有两种功能：&lt;strong&gt;转发和路由选择&lt;/strong&gt;。下面我们就来聊一聊路由器的工作原理。&lt;/p&gt;
&lt;h2 id=&quot;路由器工作原理&quot;&gt;路由器工作原理&lt;/h2&gt;
&lt;p&gt;下面是一个路由器体系结构图，路由器主要是由 4 个组件构成的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215080904125-1099348507.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入端口：&lt;code&gt;输入端口(input port)&lt;/code&gt;有很多功能。&lt;code&gt;线路终端功能&lt;/code&gt;和&lt;code&gt;数据链路处理&lt;/code&gt;功能，这两个功能实现了路由器的单个输入链路相关联的物理层和数据链路层。&lt;code&gt;输入端口查找/转发功能&lt;/code&gt;对路由器的交换功能来说至关重要，由路由器的交换结构来决定输出端口，具体来讲应该是查询转发表来确定的。&lt;/li&gt;
&lt;li&gt;交换结构：&lt;code&gt;交换结构(Switching fabric)&lt;/code&gt;就是将路由器的输入端口连接到它的输出端口。这种交换结构相当于是路由器内部的网络。&lt;/li&gt;
&lt;li&gt;输出端口：&lt;code&gt;输出端口(Output ports)&lt;/code&gt; 通过交换结构转发分组，并通过物理层和数据链路层的功能传输分组，因此，输出端口作为输入端口执行反向数据链接和物理层功能。&lt;/li&gt;
&lt;li&gt;路由选择处理器：&lt;code&gt;路由选择处理器(Routing processor)&lt;/code&gt; 在路由器内执行路由协议，维护路由表并执行网络管理功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面只是这几个组件的简单介绍，其实这几个组件的组成并不像描述的那样简单，下面我们就来深入聊一聊这几个组件。&lt;/p&gt;
&lt;h3 id=&quot;输入端口&quot;&gt;输入端口&lt;/h3&gt;
&lt;p&gt;上面介绍了输入端口有很多功能，包括线路终端、数据处理、查找转发，其实这些功能在输入端口的内部有相应的模块，输入端口的内部实现如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215080913263-624852825.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个输入端口中都有一个路由处理器维护的&lt;strong&gt;路由表的副本&lt;/strong&gt;，根据路由处理器进行更新。这个路由表的副本能 够使每个输入端口进行切换，而无需经过路由处理器统一处理。这是一种&lt;code&gt;分散式&lt;/code&gt;的切换，这种方式避免了路 由选择器统一处理造成转发瓶颈。&lt;/p&gt;
&lt;p&gt;在输入端口处理能力有限的路由器中，输入端口不会进行交换功能，而是由路由处理器统一处理，然后根据 路由表查找并将数据包转发到相应的输出端口。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一般这种路由器不是单独的路由器，而是工作站或者服务器充当的路由，这种路由器内部中，路由处理器其实就是 &lt;code&gt;CPU&lt;/code&gt;，而输入端口其实只是&lt;code&gt;网卡&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入端口会根据转发表定位输出端口，然后再会进行分组转发，那么现在就有一个问题，是不是每一个分组都有自己的一条链路呢？如果分组数量非常大，到达亿级的话，也会有亿个输出端口路径吗？&lt;/p&gt;
&lt;p&gt;我们的潜意识中显然不是的，来看下面一个例子。&lt;/p&gt;
&lt;p&gt;下面是三个输入端口对应了转发表中的三个输出链路的示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215080923683-554770697.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，对于这个例子来说，路由器转发表中不需要那么多条链路，只需要四条就够，即对应输出链路 0 1 2 3 。也就是说，能够使用 4 个转发表就可以实现亿级链路。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何实现呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用这种风格的转发表，路由器分组的地址 &lt;code&gt;前缀(prefix)&lt;/code&gt; 会与该表中的表项进行匹配。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215080932443-24439226.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果存在一个匹配项，那么就会转发到对应的链路上，可能不好理解，我举个例子来说吧。&lt;/p&gt;
&lt;p&gt;比如这时有一个分组是 11000011 10010101 00010000 0001100 到达，因为这个分组与 11000011 10010101 00010000 相匹配，所以路由器会转发到 0 链路接口上。如果一个前缀不匹配上面三个输出链路中的一种，那么路由器将向链路接口 3 进行转发。&lt;/p&gt;
&lt;p&gt;路由匹配遵循 &lt;code&gt;最长前缀原则(longest prefix matching rule)&lt;/code&gt;，最长匹配原则故名思义就是如果有两个匹配项一个长一个短的话，就匹配最长的。&lt;/p&gt;
&lt;p&gt;一旦通过查找功能确定了分组的输出端口后，那么该分组就会进入交换结构。在进入交换结构时，如果交换结构正在被使用，就会阻塞新到的分组，等到交换结构调度新的分组。&lt;/p&gt;
&lt;h3 id=&quot;交换结构&quot;&gt;交换结构&lt;/h3&gt;
&lt;p&gt;交换结构是路由器的核心功能，通过交换功能把分组从输入端口转发至输出端口，这就是交换结构的主要功能。交换结构有多种形式，主要分为 &lt;strong&gt;通过内存交换、通过总线交换、通过互联网络进行交换&lt;/strong&gt;，下面我们分开来探讨一下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;经过内存交换：最开始的传统计算机就是使用&lt;code&gt;内存交换&lt;/code&gt;的，在输入端口和输出端口之间是通过 CPU 进行的。输入端口和输出端口的功能就好像传统操作系统中的 I/O 设备一样。当一个分组到达输入端口时，这个端口会首先以&lt;code&gt;中断&lt;/code&gt; 的方式向路由选择器发出信号，将分组从输入端口拷贝到内存中。然后，路由选择处理器从分组首部中提取目标地址，在转发表中找出适当的输出端口进行转发，同时将分组复制到输出端口的缓存中。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里需要注意一点，如果内存带宽以每秒读取或者写入 B 个数据包，那么总的交换机吞吐量(数据包从输入端口到输出端口的总速率) 必须小于 B/2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215080959297-1190156930.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;经过总线交换：在这种处理方式中，总线经由输入端口直接将分组传送到输出端口，中间不需要路由选择器的干预。总线的工作流程如下：输入端口给分组分配一个&lt;code&gt;标签&lt;/code&gt;，然后分组经由总线发送给所有的输出端口，每个输出端口都会判断标签中的端口和自己的是否匹配，如果匹配的话，那么这个输出端口就会把标签拆掉，这个标签只用于交换机内部跨越总线。如果同时有 &lt;code&gt;多个&lt;/code&gt; 分组到达路由器的话，那么只有一个分组能够被处理，其他分组需要再进入交换结构前等待。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215081010497-500749636.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;经过互联网络交换：客服单一、共享式总线带宽限制的一种方法是使用一个更复杂的互联网络。如下图所示&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215081022490-1520260643.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每条垂直的的总线在交叉点与每条水平的总线交叉，交叉点通过交换结构控制器能够在任何时候开启和闭合。当分组到达输入端口 A 时，如果需要转发到端口 X，交换机控制器会闭合 A 到 X 交叉部分的交叉点，然后端口 A 在总线上进行分组转发。这种网络互联式的交换结构是 &lt;code&gt;非阻塞的(non-blocking)&lt;/code&gt;的，也就是说 A -&amp;gt; X 的交叉点闭合不会影响 B -&amp;gt; Y 的链路。如果来自两个不同输入端口的两个分组其目的地为相同的输出端口的话，这种情况下只能有一个分组被交换，另外一个分组必须进行等待。&lt;/p&gt;
&lt;h3 id=&quot;输出端口处理&quot;&gt;输出端口处理&lt;/h3&gt;
&lt;p&gt;如下图所示，输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上。包括选择和去除排队的分组进行传输，执行所需的链路层和物理层的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215081030428-1393967996.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在输入端口中有等待进入交换的排队队列，而在输出端口中有等待转发的排队队列，排队的位置和程度取决于&lt;strong&gt;流量负载、交换结构&lt;/strong&gt;的相对频率和线路速率。&lt;/p&gt;
&lt;p&gt;随着队列的不断增加，会导致路由器的缓存空间被耗尽，进而使没有内存可以存储溢出的队列，致使分组出现&lt;code&gt;丢包(packet loss)&lt;/code&gt;，这就是我们说的在网络中丢包或者被路由器丢弃。&lt;/p&gt;
&lt;h2 id=&quot;何时出现排队&quot;&gt;何时出现排队&lt;/h2&gt;
&lt;p&gt;下面我们通过输入端口的排队队列和输出端口的排队队列来介绍一下可能出现的排队情况。&lt;/p&gt;
&lt;h3 id=&quot;输入队列&quot;&gt;输入队列&lt;/h3&gt;
&lt;p&gt;如果交换结构的处理速度没有输入队列到达的速度快，在这种情况下，输入端口将会出现排队情况，到达交换结构前的分组会加入输入端口队列中，以等待通过交换结构传送到输出端口。&lt;/p&gt;
&lt;p&gt;为了描述清楚输入队列，我们假设以下情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用网络互联的交换方式；&lt;/li&gt;
&lt;li&gt;假定所有链路的速度相同；&lt;/li&gt;
&lt;li&gt;在链路中一个分组由输入端口交换到输出端口所花的时间相同，从任意一个输入端口传送到给定的输出端口；&lt;/li&gt;
&lt;li&gt;分组按照 FCFS 的方式，只要输出端口不同，就可以进行并行传送。但是如果位于任意两个输入端口中的分组是发往同一个目的地的，那么其中的一个分组将被阻塞，而且必须在输入队列中俄等待，因为交换结构一次只能传输一个到指定端口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215081042140-13329271.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 A 队列中，输入队列中的两个分组会发送至同一个目的地 X，假设在交换结构正要发送 A 中的分组，在这个时候，C 队列中也有一个分组发送至 X，在这种情况下，C 中发送至 X 的分组将会等待，不仅如此，C 队列中发送至 Y 输出端口的分组也会等待，即时 Y 中没有出现竞争的情况。这种现象叫做 &lt;code&gt;线路前部阻塞(Head-Of-The-Line, HOL)&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;输出队列&quot;&gt;输出队列&lt;/h3&gt;
&lt;p&gt;我们下面讨论输出队列中出现等待的情况。假设交换速率要比输入/输出的传输速率快很多，而且有 N 个输入分组的目的地是转发至相同的输出端口。在这种情况下，在向输出链路发送分组的过程中，将会有 N 个新分组到达传输端口。因为输出端口在一个单位时间内只能传输一个分组，那么这 N 个分组将会等待。然而在等待 N 个分组被处理的过程中，同时又有 N 个分组到达，所以 ，分组队列能够在输出端口形成。这种情况下最终会因为分组数量变的足够大，从而&lt;code&gt;耗尽&lt;/code&gt; 输出端口的可用内存。&lt;/p&gt;
&lt;p&gt;如果没有足够的内存来缓存分组的话，就必须考虑其他的方式，主要有两种：一种是丢失分组，采用 &lt;code&gt;弃尾(drop-tail)&lt;/code&gt; 的方法；一种是删除一个或多个已经排队的分组，从而来为新的分组腾出空间。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;网络层的策略对 TCP 拥塞控制影响很大的就是路由器的分组丢弃策略。在最简单的情况下，路由器的队列通常都是按照 FCFS 的规则处理到来的分组。由于队列长度总是有限的，因此当队列已经满了的时候，以后再到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫做尾部丢弃策略。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常情况下，在缓冲填满之前将其丢弃是更好的策略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215081056524-1401611980.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，A B C 每个输入端口都到达了一个分组，而且这个分组都是发往 X 的，同一时间只能处理一个分组，然后这时，又有两个分组分别由 A B 发往 X，所以此时有 4 个分组在 X 中进行等待。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215081105854-1487620615.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;等上一个分组被转发完成后，输出端口就会选择在剩下的分组中根据 &lt;code&gt;分组调度(packet scheduleer)&lt;/code&gt; 选择一个分组来进行传输，我们下面就会聊到分组传输。&lt;/p&gt;
&lt;h2 id=&quot;分组调度&quot;&gt;分组调度&lt;/h2&gt;
&lt;p&gt;现在我们来讨论一下分组调度次序的问题，即排队的分组如何经输出链路传输的问题。我们生活中有无数排队的例子，但是我们生活中一般的排队算法都是 &lt;code&gt;先来先服务(FCFS)&lt;/code&gt;，也是&lt;code&gt;先进先出(FIFO)&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;先进先出&quot;&gt;先进先出&lt;/h3&gt;
&lt;p&gt;先进先出就映射为数据结构中的&lt;code&gt;队列&lt;/code&gt;，只不过它现在是链路调度规则的排队模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215081115654-756714178.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FIFO 调度规则按照分组到达输出链路队列的相同次序来选择分组，先到达队列的分组将先会被转发。在这种抽象模型中，如果队列已满，那么弃尾的分组将是队列末尾的后面一个。&lt;/p&gt;
&lt;h3 id=&quot;优先级排队&quot;&gt;优先级排队&lt;/h3&gt;
&lt;p&gt;优先级排队是先进先出排队的改良版本，到达输出链路的分组被分类放入输出队列中的优先权类，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215081125473-1586966020.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通常情况下，每个优先级不同的分组有自己的优先级类，每个优先级类有自己的队列，分组传输会首先从优先级高的队列中进行，在同一类优先级的分组之间的选择通常是以 FIFO 的方式完成。&lt;/p&gt;
&lt;h3 id=&quot;循环加权公平排队&quot;&gt;循环加权公平排队&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;循环加权公平规则(round robin queuing discipline)&lt;/code&gt; 下，分组像使用优先级那样被分类。然而，在类之间却不存在严格的服务优先权。循环调度器在这些类之间循环轮流提供服务。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202012/1515111-20201215081135035-532731238.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在循环加权公平排队中，类 1 的分组被传输，接着是类 2 的分组，最后是类 3 的分组，这算是一个循环，然后接下来又重新开始，又从 1 -&amp;gt; 2 -&amp;gt; 3 这个顺序进行轮询。每个队列也是一个先入先出的队列。&lt;/p&gt;
&lt;p&gt;这是一种所谓的&lt;code&gt;保持工作排队(work-conserving queuing)&lt;/code&gt; 的规则，就是说如果轮询的过程中发现有空队列，输出端口不会等待分组，而是继续轮询下面的队列。&lt;/p&gt;
&lt;p&gt;另外，我自己肝了六本 PDF，微信搜索「程序员cxuan」关注公众号后，在后台回复 cxuan ，领取全部 PDF，这些 PDF 如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://s3.ax1x.com/2020/11/30/DgOK6f.png&quot; target=&quot;_blank&quot;&gt;六本 PDF 链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202011/1515111-20201130090550310-1032998206.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 Dec 2020 00:15:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>我把自己以往的文章汇总成为了 Github ，欢迎各位大佬 star https://github.com/crisxuan/bestJavaer 前面我们学习了运输层如何为客户端和服务器输送数据的，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/14136686.html</dc:identifier>
</item>
<item>
<title>数据类型· 第1篇《元组和列表的性能分析、命名元组》 - 清菡</title>
<link>http://www.cnblogs.com/qinghan123/p/14136681.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qinghan123/p/14136681.html</guid>
<description>&lt;h2 id=&quot;坚持原创输出，点击蓝字关注我吧&quot;&gt;坚持原创输出，点击蓝字关注我吧&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214114911.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：清菡&lt;br/&gt;博客：oschina、云+社区、知乎等各大平台都有。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;一、元组和列表
&lt;ul&gt;&lt;li&gt;1.元组和列表的性能分析&lt;/li&gt;
&lt;li&gt;2.为什么列表在 Python 中是最常用的呢？&lt;/li&gt;
&lt;li&gt;3.timeit 里面有个 Timer 类&lt;/li&gt;
&lt;li&gt;4.timeit 里面还有个直接用的 timeit 的方法，timeit.timeit()&lt;/li&gt;
&lt;li&gt;5.这 2 个方法有啥区别？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;二、命名元组&lt;/li&gt;
&lt;li&gt;三、命名元组有什么特点？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一、元组和列表&quot;&gt;一、元组和列表&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214060759.jpg&quot; alt=&quot;元组vs列表&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;1元组和列表的性能分析&quot;&gt;1.元组和列表的性能分析&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;元组和列表用来存储数据，在元组和列表里面查询的时候，到底哪个更快呢？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;计算创建元组和列表所需的时间：ipython 中使用&lt;code&gt;timeit&lt;/code&gt;这个命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算时间模块介绍：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import timeit
#timeit.timeit
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以用这个模块来测试函数的性能。&lt;/p&gt;
&lt;p&gt;安装 ipython：&lt;code&gt;pip install ipython&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214062010.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ipython 是个交互环境，就跟我们输入 Python 进去是一样的。只不过它外面做了一层封装，比 Python 交互环境更好用一点。&lt;/p&gt;
&lt;p&gt;ipython 里面有一个命令叫做&lt;code&gt;timeit&lt;/code&gt;，后面可以跟一个 Python 表达式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如定义一个列表在后面：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214063603.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;敲完这行命令，返回了一行时间。这个是在内存中初始化一个列表，如图可以看到创建了一千万次，时间是 48.4ns&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以看出，创建一个元组比创建一个列表要快得多。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;元组的速度比列表要快 3 倍多。在内存里，当我们创建一个列表的时候，会划分一块区域出来，拿一块区域给列表来储存值。例如初始化，里面给它留了 20 个位置在这个列表里面储存值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214072636.png&quot; alt=&quot;列表占用内存如图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当储存到一定程度，Python 解释器检测到列表快要盛满了的时候，它会对列表做一个扩容。&lt;/p&gt;
&lt;p&gt;给扩容到 200，当存储到 150 的时候，发现又快存储满了，又会给你继续扩容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随着数据的增多，底层会不断给这个列表扩容。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;初始化一个元组，同样也是一千万次，只需 12.8ns&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214064607.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;元组是一个不可变的类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如定义的元组里面有 3 个元素，Python 解释器在给它分内存的时候，就给它分了 3 个格子。&lt;/p&gt;
&lt;p&gt;这里面只能存 3 条数据，就这么大，所以元组占用的内存比列表要少。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214073620.png&quot; alt=&quot;元组和列表内存占用对比图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用一个列表存储 50 条数据和用一个元组存储 50 条数据，那么元组占用的内存要比列表小得多。&lt;/p&gt;
&lt;h3 id=&quot;2为什么列表在-python-中是最常用的呢？&quot;&gt;2.为什么列表在 Python 中是最常用的呢？&lt;/h3&gt;
&lt;p&gt;因为列表比较灵活，用列表的话，可以往里面不断得添加元素。如果元素固定的，那就用元组。&lt;/p&gt;
&lt;h3 id=&quot;3timeit-里面有个-timer-类。&quot;&gt;3.timeit 里面有个 Timer 类。&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;来看看这个类的源码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214075933.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214080629.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;timer=default_timer&lt;/code&gt;代表的是：创建一个列表、元组等，它要执行的一个次数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;看源码，默认是一千万次：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214080445.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;import timeit  # 这个模块可以用来做性能分析


def func():
    for i in range(10):
        print(i)

# 这个对象有个方法叫做timeit
res = timeit.Timer(func).timeit(100) # 把这个func函数传进去，运行100次，然后返回的是个时间
# timeit.Timer(func).timeit(100)中函数func是不需要加引号的，如果是字符串、列表这些需要加
# 引号放进去

print(res)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到运行 100 次需要的时间是：0.0043269999999999975&lt;/p&gt;
&lt;h3 id=&quot;4timeit-里面还有个直接用的-timeit-的方法，timeittimeit&quot;&gt;4.timeit 里面还有个直接用的 timeit 的方法，timeit.timeit()&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;import timeit  # 这个模块可以用来做性能分析


def func():
    for i in range(10):
        print(i)

# 这个对象有个方法叫做timeit
# res = timeit.Timer(func).timeit(100) # 把这个func函数传进去，运行100次，然后返回的是个时间
# timeit.Timer(func).timeit(100)中函数func是不需要加引号的，如果是字符串、列表这些需要加引号放进去

# print(res)

res2 = timeit.timeit('[1,2,3]')
print(res2)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这个模块的作用：&lt;/strong&gt; 大家写的功能函数，可以用它测下功能函数的速度，执行大概要多久。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认是一千万次，结果如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214082618.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果列表不加引号直接传是会报错的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214083855.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提示不可被调用！&lt;/p&gt;
&lt;h3 id=&quot;5这-2-个方法有啥区别？&quot;&gt;5.这 2 个方法有啥区别？&lt;/h3&gt;
&lt;p&gt;其实它们是一个东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214084922.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、命名元组&quot;&gt;二、命名元组&lt;/h2&gt;
&lt;p&gt;元组的性能是大大优于列表的。元组、列表在使用的时候，都是通过下标索引取值的。&lt;/p&gt;
&lt;p&gt;下标索引取值不太人性化，如果我知道数据储存在元组里面，但是我不知道它具体储存的下标位置。这个时候找这个元素，还得先把下标找出来，知道下标再去拿，这样很不方便。&lt;/p&gt;
&lt;p&gt;字典的话，这方面就比较有优势。数据是存储在字典里面的，只要通过键，就能把值找到。字典相对于元组和列表，有一定的优势和劣势。&lt;/p&gt;
&lt;p&gt;命名元组使用的时候可以让元组像字典一样去取值。&lt;/p&gt;
&lt;p&gt;例如，有个元组里面保存了 3 条数据：&lt;/p&gt;
&lt;p&gt;创建一个命名元组的话，需要用到 Python 的一个内置模块&lt;code&gt;from collections import namedtuple&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214100718.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;import timeit  # 这个模块可以用来做性能分析
from collections import namedtuple
# namedtuple是个函数，创建命名元组可以通过这个函数来创建

def func():
    for i in range(10):
        print(i)

# 这个对象有个方法叫做timeit
# res = timeit.Timer(func).timeit(100) # 把这个func函数传进去，运行100次，然后返回的是个时间
# timeit.Timer(func).timeit(100)中函数func是不需要加引号的，如果是字符串、列表这些需要加引号放进去

# print(res)

res2 = timeit.timeit('[1,2,3]')

print(res2)


# 命名元组

# 如果知道里面储存的具体位置，可以通过下标取值。例如tu=[0]
# 如果我不知道名字存储在哪里，通过下标去取值就不好取了

# 命名元组可以使取值的时候像列表一样取

student_info = namedtuple('info_tuple',['name','age','gender']) # 这个函数接收2个参数，第一个参数是创建命名元组的类型的名字；
# 第二个参数的话，传一个列表
# 列表里写创建命名元组的一个命名，例如第一个元素命名为name
# 这个函数调用传了2个参数，返回出来一个对象。这个对象叫做student_info
# 通过这个对象student_info创建命名元组

tu = student_info('qinghan',18,'nv')
print(tu)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214100917.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个 tu 就是个命名元组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;student_info&lt;/code&gt; 是通过命名元组这个&lt;code&gt;namedtuple&lt;/code&gt;函数创建命名元组类型：&lt;code&gt;namedtuple('info_tuple',['name','age','gender'])&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后返回出来一个对象&lt;code&gt;student_info&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;student_info&lt;/code&gt;这个对象传入对应的元组，定义元组的时候就通过这个对象把元素写进去，返回的就是命名元组。&lt;/p&gt;
&lt;h2 id=&quot;三、命名元组有什么特点？&quot;&gt;三、命名元组有什么特点？&lt;/h2&gt;
&lt;p&gt;它取值的时候可以像字典一样取值，通过对应的键，找到对应的值。&lt;strong&gt;命名元组使用起来更像对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样用：&lt;code&gt;命名元组.name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这样就能找到 name 所对应的值：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;
import timeit  # 这个模块可以用来做性能分析
from collections import namedtuple
# namedtuple是个函数，创建命名元组可以通过这个函数来创建

def func():
    for i in range(10):
        print(i)

# 这个对象有个方法叫做timeit
# res = timeit.Timer(func).timeit(100) # 把这个func函数传进去，运行100次，然后返回的是个时间
# timeit.Timer(func).timeit(100)中函数func是不需要加引号的，如果是字符串、列表这些需要加引号放进去

# print(res)

res2 = timeit.timeit('[1,2,3]')

print(res2)


# 命名元组

# 如果知道里面储存的具体位置，可以通过下标取值。例如tu=[0]
# 如果我不知道名字存储在哪里，通过下标去取值就不好取了

# 命名元组可以使取值的时候像列表一样取

student_info = namedtuple('info_tuple',['name','age','gender']) # 这个函数接收2个参数，第一个参数是创建命名元组的类型的名字；
# 第二个参数的话，传一个列表
# 列表里写创建命名元组的一个命名，例如第一个元素命名为name
# 这个函数调用传了2个参数，返回出来一个对象。这个对象叫做student_info
# 通过这个对象student_info创建命名元组

tu = student_info('qinghan',18,'nv')
print(tu.name)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214102516.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设定命名元组类型的时候，它返回的这个对象它里面只包含了传进去的这几个名字。&lt;/p&gt;
&lt;p&gt;接下来，要创建命名元组的时候，元素和它一样多，名字和对应的元素的值是一一对应的，不能多，不能少。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;否则就会报错：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214102859.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;print(type(tu)) # 看下它的类型&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214103442.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214103838.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它返回的对象和类型名用的同一个名字。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;print(type(student_info))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201214104509.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-PYTHON&quot;&gt;import timeit  # 这个模块可以用来做性能分析
from collections import namedtuple
# namedtuple是个函数，创建命名元组可以通过这个函数来创建

def func():
    for i in range(10):
        print(i)

# 这个对象有个方法叫做timeit
# res = timeit.Timer(func).timeit(100) # 把这个func函数传进去，运行100次，然后返回的是个时间
# timeit.Timer(func).timeit(100)中函数func是不需要加引号的，如果是字符串、列表这些需要加引号放进去

# print(res)

res2 = timeit.timeit('[1,2,3]')

print(res2)


# 命名元组

# 如果知道里面储存的具体位置，可以通过下标取值。例如tu=[0]
# 如果我不知道名字存储在哪里，通过下标去取值就不好取了

# 命名元组可以使取值的时候像列表一样取
# 设定命名元组类型
# student_info是个类
student_info = namedtuple('student_info',['name','age','gender']) # 这个函数接收2个参数，第一个参数是创建命名元组的类型的名字；
# 第二个参数的话，传一个列表
# 列表里写创建命名元组的一个命名，例如第一个元素命名为name
# 这个函数调用传了2个参数，返回出来一个对象。这个对象叫做student_info
# 通过这个对象student_info创建命名元组

tu = student_info('qinghan',18,'nv')
print(tu.name)

print(type(tu)) # 看下它的类型
print(type(student_info))
# 因为student_info是个类，所以看student_info的type就是个type。随便看哪个类都是一样的。
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;公众号 &lt;strong&gt;「清菡软件测试」&lt;/strong&gt; 首发，更多原创文章：清菡软件测试 105+原创文章，欢迎关注、交流，禁止第三方擅自转载。&lt;/p&gt;
</description>
<pubDate>Tue, 15 Dec 2020 00:11:00 +0000</pubDate>
<dc:creator>清菡</dc:creator>
<og:description>坚持原创输出，点击蓝字关注我吧 作者：清菡 博客：oschina、云+社区、知乎等各大平台都有。 目录 一、元组和列表 1.元组和列表的性能分析 2.为什么列表在 Python 中是最常用的呢？ 3.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qinghan123/p/14136681.html</dc:identifier>
</item>
<item>
<title>Java 8 新特性——实践篇 - 卡斯特梅的雨伞</title>
<link>http://www.cnblogs.com/castamere/p/14136615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/castamere/p/14136615.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1ut411g7E9?from=search&amp;amp;seid=5400886361499974806&quot; target=&quot;_blank&quot;&gt;Java8新特性&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;重要更新：Lambda 表达式和Stream API&lt;/p&gt;
&lt;h2 id=&quot;lambda-表达式&quot;&gt;Lambda 表达式&lt;/h2&gt;
&lt;p&gt;Lambda 表达式引入之前：&lt;/p&gt;
&lt;p&gt;举个场景例子：当我们要对一个班级里的学生对象里各种成绩进行过滤时，比如大于85分获得A的学生集合，最初的方式是写不同的方法处理不同的科目成绩过滤；再后面就可以用策略模式，声明一个接口ScoreFilterStrategy，针对不同的科目实现不同的策略算法。再优化一下，我们可以对策略模式进行升级，直接用匿名内部类实现我们的接口ScoreFilterStrategy，自定义策略实现。但基于其代码的繁琐性，我们可以使用Lambda 表达式进行函数式编程优化，更可以对集合进行Stream API流的调用处理来实现想要的效果。参考如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-a182f0a831b61086.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Lambda 是一个匿名函数，我们可以把Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。&lt;/p&gt;
&lt;h3 id=&quot;lambda-表达式语法&quot;&gt;Lambda 表达式语法&lt;/h3&gt;
&lt;p&gt;Lambda 表达式在Java 语言中引入了一个新的语法元素和操作符。这个操作符为“-&amp;gt;” ，该操作符被称为&lt;strong&gt;Lambda 操作符或剪头操作符&lt;/strong&gt;。它将Lambda 分为两个部分：&lt;br/&gt;左侧：指定了Lambda &lt;strong&gt;表达式需要的所有参数&lt;/strong&gt;。&lt;br/&gt;右侧：指定了Lambda 体，即Lambda &lt;strong&gt;表达式要执行的功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Lambda 表达式需要函数式接口的支持。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LambdaTest {

    //语法格式一：无参，无返回值，Lambda 体只需一条语句
    @Test
    public void test1() {
        Runnable r = () -&amp;gt; System.out.println(&quot;helo world&quot;);
        r.run();
    }

    //语法格式二：Lambda 需要一个参数
    @Test
    public void test2() {
        Consumer&amp;lt;String&amp;gt; consumer = (str) -&amp;gt; System.out.println(str);
        consumer.accept(&quot;I am Batman&quot;);
    }


    //语法格式三：Lambda 只需要一个参数时，参数的小括号可以省略
    @Test
    public void test3() {
        Consumer&amp;lt;String&amp;gt; consumer = str -&amp;gt; System.out.println(str);
        consumer.accept(&quot;I am Batman&quot;);
    }

    //语法格式四：Lambda 需要两个参数，并且有返回值,并且lambda体中有多条语句时要加{}
    @Test
    public void test4() {
        Comparator&amp;lt;Integer&amp;gt; comparator = (x, y) -&amp;gt; {
            System.out.println(&quot;比较数据&quot;);
            return Integer.compare(x, y);
        };
        comparator.compare(1, 2);
    }


    //语法格式五：当Lambda 体只有一条语句时，return 与大括号可以省略
    @Test
    public void test5() {
        Comparator&amp;lt;Integer&amp;gt; comparator = (x, y) -&amp;gt; Integer.compare(x, y);
        comparator.compare(1, 2);
    }

    //语法格式六：Lambda 表达式的参数列表上的参数类型可以省略不写，因为JVM编译器(javac)会通过程序上下文推动出数据类型，
    // 即类型推断。这是JDK1.8的新特性，在JDK1.7上写类型推断的代码是编译不通过的。
    @Test
    public void test6() {
        Comparator&amp;lt;Integer&amp;gt; comparator = (x, y) -&amp;gt; Integer.compare(x, y);
        comparator.compare(1, 2);
    }

    //类型推断实例
    @Test
    public void test7() {
        String[] strings = {&quot;a&quot;, &quot;b&quot;, &quot;ddd&quot;};
        //如果像下面这样写就无法通过上下文进行类型推断
//        String[] string2;
//        string2 = {&quot;a&quot;, &quot;b&quot;, &quot;ddd&quot;};
        //后面的new ArrayList&amp;lt;&amp;gt;();尖括号里面也可以省略不写也是通过类型推断得来的。
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        //创建的new HashMap&amp;lt;&amp;gt;()尖括号里面也可以省略不写也是通过类型推断得来的，他会采用operate方法里的泛型格式
        operate(new HashMap&amp;lt;&amp;gt;());
    }

    private void operate(Map&amp;lt;String,String&amp;gt; map){

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数式接口&quot;&gt;函数式接口&lt;/h2&gt;
&lt;p&gt;接口中&lt;strong&gt;只包含一个抽象方法的接口&lt;/strong&gt;，称为函数式接口。我们可以使用@FunctionalInterface注解修饰该接口，用于检测是否是函数式接口。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterfacepublic interface MyFunc {    Integer getValue(Integer t);}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterfacepublic interface CustomFunc {    String execute(String str);}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface CauclateFunc&amp;lt;T,R&amp;gt; {

    R getValue(T t1,T t2);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LambdaTest2 {

    @Test
    public void test() {
        System.out.println(operate(100, x -&amp;gt; x * x));
    }

    //函数式接口作为方法参数传递，这样我们便能在调用方法时自定义我们的lambda函数的操作
    private Integer operate(Integer t, MyFunc myFunc) {
        return myFunc.getValue(t);
    }

    @Test
    public void test2() {
        System.out.println(concate(&quot;hello&quot;,str -&amp;gt; str + &quot; world&quot;));
        String concate = concate(&quot;I&quot;, str -&amp;gt; {
            System.out.println(&quot;prepare...&quot;);
            return str + &quot; am &quot; + &quot;batman&quot;;
        });
        System.out.println(concate);
    }

    private String concate(String str,CustomFunc customFunc){
        return customFunc.execute(str);
    }
    
    @Test
    public void test3() {
        Long calcute = calcute(100L, 200L, (x, y) -&amp;gt; x * y);
        System.out.println(calcute);
        Long calcute2 = calcute(100L, 200L, (x, y) -&amp;gt; x - y);
        System.out.println(calcute2);
    }

    private Long calcute(Long l1, Long l2, CauclateFunc&amp;lt;Long, Long&amp;gt; cauclateFunc) {
        return cauclateFunc.getValue(l1, l2);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;输出：
hello world
prepare...
I am batman

20000
-100
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;java-内置四大核心函数式接口&quot;&gt;Java 内置四大核心函数式接口&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-2809b85b0be8d21d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他子接口是在四大核心函数式接口的基础上进行个性化的参数添加和处理定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-2174056caefb05b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四大核心函数式接口使用示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FunctionalInterfaceTest {
    /**
     * Consumer&amp;lt;T&amp;gt; :消费型接口：接收一个参数进行消费处理，无返回
     * void accept(T t)
     */
    @Test
    public void test() {
        call(&quot;麻包锅&quot;, name -&amp;gt; System.out.println(name + &quot;被老师点名了！&quot;));
    }
    //麻包锅被老师点名了！

    private void call(String name, Consumer&amp;lt;String&amp;gt; consumer) {
        consumer.accept(name);
    }

    /**
     * Supplier&amp;lt;T&amp;gt; :供给型接口 :返回一些东西
     * T get();
     */
    @Test
    public void test2() {
        //注意加括号，int强转是针对整个只而不是Math.random()返回的，否则为0
        List&amp;lt;Integer&amp;gt; list = supply(5, () -&amp;gt; (int) (Math.random() * 100));
        System.out.println(list);
    }
    //[78, 96, 66, 20, 0]

    private List&amp;lt;Integer&amp;gt; supply(Integer num, Supplier&amp;lt;Integer&amp;gt; supplier) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; num; i++) {
             list.add(supplier.get());
        }
        return list;
    }

    /**
     * Function&amp;lt;T, R&amp;gt;:函数型接口 ：对T类型参数对象处理返回R类型对象
     * R apply(T t);
     */
    @Test
    public void test3() {
        String concate = concate(&quot;希望耗子尾汁！&quot;, str -&amp;gt; &quot;老同志，&quot; + str);
        System.out.println(concate);
        String filterStr = filterStr(&quot;偷袭，   骗我老同志！ &quot;, s -&amp;gt; s.replace(&quot; &quot;,&quot;&quot;));
        System.out.println(filterStr);
    }
    //老同志，希望耗子尾汁！
    //偷袭，骗我老同志！

    private String concate(String str, Function&amp;lt;String,String&amp;gt; function) {
        return function.apply(str);
    }

    private String filterStr(String str, Function&amp;lt;String,String&amp;gt; function) {
        return function.apply(str);
    }


    /**
     * Predicate&amp;lt;T&amp;gt; :断言型接口
     * boolean test(T t);
     */
    @Test
    public void test4() {
        List&amp;lt;Integer&amp;gt; numList = new ArrayList&amp;lt;&amp;gt;();
        numList.add(1);
        numList.add(13);
        numList.add(23);
        numList.add(67);
        List&amp;lt;Integer&amp;gt; list = check(numList, n -&amp;gt; n &amp;gt; 15);
        System.out.println(list);
    }
    //[23, 67]

    List&amp;lt;Integer&amp;gt; check(List&amp;lt;Integer&amp;gt; list,Predicate&amp;lt;Integer&amp;gt; predicate){
        List&amp;lt;Integer&amp;gt; newList = new ArrayList&amp;lt;&amp;gt;();
        for (Integer num : list) {
           if (predicate.test(num)){
               newList.add(num);
           }
        }
        return newList;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;方法引用与构造器引用&quot;&gt;方法引用与构造器引用&lt;/h2&gt;
&lt;h3 id=&quot;方法引用&quot;&gt;方法引用&lt;/h3&gt;
&lt;p&gt;当要传递给Lambda体的操作，如果Lambda 体中的内容有方法实现了，就可以使用“方法引用”。即方法引用是lambda表达式的另一种表现形式。&lt;/p&gt;
&lt;p&gt;有以下三种语法形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对象::实例方法&lt;/li&gt;
&lt;li&gt;类::静态方法&lt;/li&gt;
&lt;li&gt;类::实例方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;lambda体中调用方法的参数列表和返回值类型，要与函数式接口中的抽象方法的参数列表和返回值类型保持一致。&lt;/li&gt;
&lt;li&gt;如果lambda参数列表中的第一个参数是示例方法的调用者，第二个参数是示例方法的参数时，可以使用ClassName::methodName。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;构造器引用&quot;&gt;构造器引用&lt;/h3&gt;
&lt;p&gt;格式：ClassName::new&lt;/p&gt;
&lt;p&gt;构造器引用与函数式接口相结合，自动与函数式接口中方法兼容。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当我们把构造器引用赋值给定义的方法时，需要调用的构造器的参数列表要与函数式接口中抽象方法的参数列表一致！&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;数组引用&quot;&gt;数组引用&lt;/h3&gt;
&lt;p&gt;格式：type[] :: new&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MethodRefTest {
    /**
     * 对象::实例方法
     * 注意方法引用使用时：lamda表达式需要实现的抽象方法的参数类型和返回值要与当前调用的方法的参数类型和返回值保持一致
     * Consumer&amp;lt;T&amp;gt;  : void accept(T t);
     * PrintStream : void println(String x);
     * 当调用方法有一个参数无返回值时适用于Consumer的消费型接口
     */
    @Test
    public void test() {
        Consumer&amp;lt;String&amp;gt; consumer = System.out::println;
        consumer.accept(&quot;朋友们好啊！&quot;);
    }

    /**
     * Supplier&amp;lt;T&amp;gt; T get();
     * 调用方法无参数有返回值时适用于Supplier的供给型接口
     * 典型的如对象的get方法
     */
    @Test
    public void test2() {
        User user = new User();
        Supplier&amp;lt;String&amp;gt; supplier = user::getName;
        System.out.println(supplier.get());
    }

    /**
     * 类::静态方法
     * Comparator&amp;lt;T&amp;gt; : int compare(T o1, T o2);
     * Integer : static int compare(int x, int y)
     */
    @Test
    public void test3() {
        List&amp;lt;Integer&amp;gt; numList = new ArrayList&amp;lt;&amp;gt;();
        numList.add(111);
        numList.add(13);
        numList.add(2);
        numList.add(67);
//        Comparator&amp;lt;Integer&amp;gt; comparator = Integer::compare;
//        Collections.sort(numList,comparator);
        Collections.sort(numList, Integer::compare);
        System.out.println(numList);
    }
    //[2, 13, 67, 111]


    /**
     * 类::实例方法
     * 使用条件：如果lambda参数列表中的第一个参数是示例方法的调用者，第二个参数是示例方法的参数时
     * BiPredicate&amp;lt;T, U&amp;gt; : boolean test(T t, U u);
     * String : boolean equals(Object anObject)
     */
    @Test
    public void test4() {
        boolean isEqual = checkEqual(&quot;music&quot;, &quot;Music&quot;, String::equals);
        System.out.println(isEqual);
    }
    //false

    private boolean checkEqual(String a, String b, BiPredicate&amp;lt;String, String&amp;gt; biPredicate) {
        return biPredicate.test(a, b);
    }

    /**
     * 构造器引用
     * 需要调用的构造器的参数列表要与函数式接口中抽象方法的参数列表一致
     * Supplier&amp;lt;T&amp;gt; : T get(); 对于无参构造器
     * Function&amp;lt;T, R&amp;gt; : R apply(T t); 对于一个参数构造器
     * BiFunction&amp;lt;T, U, R&amp;gt; :  R apply(T t, U u); 对于两个参数构造器
     */
    @Test
    public void test5() {
        //函数式编程写法
        Supplier&amp;lt;User&amp;gt; supplier1 = () -&amp;gt; new User();
        //构造器引用
        Supplier&amp;lt;User&amp;gt; supplier = User::new;
        //一个参数构造器
        Function&amp;lt;String, User&amp;gt; function = User::new;
        User user = function.apply(&quot;年轻人&quot;);
        System.out.println(user);//User{id=0, age=0, name='年轻人'}
        BiFunction&amp;lt;Integer, String, User&amp;gt; biFunction = User::new;
        User user1 = biFunction.apply(69, &quot;老同志&quot;);
        System.out.println(user1);//User{id=0, age=69, name='老同志'}
    }

    /**
     * 数组引用
     */
    @Test
    public void test6() {
        Function&amp;lt;Integer, String[]&amp;gt; function1 = x -&amp;gt; new String[x];
        Function&amp;lt;Integer, String[]&amp;gt; function = String[]::new;
        String[] strings = function.apply(5);
        System.out.println(strings.length);//5
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class User {

    private int id;

    private int age;

    private String name;

    public User() {
    }

    public User(int age, String name) {
        this.age = age;
        this.name = name;
    }

    public User(String name) {
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, age=&quot; + age +
                &quot;, name='&quot; + name + '\'' +
                '}';
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;stream-api&quot;&gt;Stream API&lt;/h2&gt;
&lt;p&gt;Stream 是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用SQL 执行的数据库查询。也可以使用Stream API 来并行执行操作。简而言之，&lt;strong&gt;Stream API 提供了一种高效且易于使用的处理数据的方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;集合讲的是数据，Stream流讲的是计算。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Stream 自己&lt;strong&gt;不会存储元素&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Stream &lt;strong&gt;不会改变源对象&lt;/strong&gt;。相反，他们会返回一个持有结果的新Stream。&lt;/li&gt;
&lt;li&gt;Stream &lt;strong&gt;操作是延迟执行的&lt;/strong&gt;，这意味着他们会等到需要结果的时候才执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Stream 的操作有三个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;创建Stream&lt;/strong&gt;&lt;br/&gt;一个数据源（如：集合、数组），获取一个流&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中间操作&lt;/strong&gt;&lt;br/&gt;一个中间操作链，对数据源的数据进行处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终止操作&lt;/strong&gt;&lt;br/&gt;一个终止操作，执行中间操作链，并产生结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-c37b8ce153153857.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建stream&quot;&gt;&lt;strong&gt;创建Stream&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;创建Stream流的4种方式示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StreamTest {

    //创建Stream流的4种方式
    @Test
    public void test() {
        //1、集合创建流：通过Collection系列集合提供的stream()或parallelStream()方法创建流
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        //串行流
        Stream&amp;lt;String&amp;gt; stream = list.stream();
        //并行流
        Stream&amp;lt;String&amp;gt; parallelStream = list.parallelStream();

        //2、数组创建流：通过Arrays.stream(T[] array)静态方法获取数组流
        User[] users = new User[5];
        Stream&amp;lt;User&amp;gt; userStream = Arrays.stream(users);

        //3、Stream创建流： 通过Stream.of(T... values)静态方法创建流
        Stream&amp;lt;Integer&amp;gt; integerStream = Stream.of(1, 2, 3, 66, 75);

        //4、创建无限流
        // A:通过Stream.iterate(final T seed, final UnaryOperator&amp;lt;T&amp;gt; f)传入seed和一元函数式接口实现无限流
        Stream&amp;lt;Integer&amp;gt; stream1 = Stream.iterate(1, x -&amp;gt; x + 1);
        stream1.limit(5).forEach(System.out::println);

        // B:通过Stream.igenerate(Supplier&amp;lt;T&amp;gt; s) 提供一个供给型接口实现无限流
        Stream&amp;lt;Double&amp;gt; stream2 = Stream.generate(()-&amp;gt;Math.random());
        stream2.limit(5).forEach(System.out::println);

    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1
2
3
4
5
0.19737667335799347
0.4379300542517345
0.626269580987739
0.8557261379085842
0.09320455087266999

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;中间操作&quot;&gt;&lt;strong&gt;中间操作&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;多个中间操作可以连接起来形成一个流水线，&lt;strong&gt;除非流水线上触发终止操作，否则中间操作不会执行任何的处理&lt;/strong&gt;！&lt;br/&gt;而在终止操作时一次性全部处理，称为“&lt;strong&gt;惰性求值&lt;/strong&gt;”或者叫&lt;strong&gt;延迟加载&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-ac115d377f45342e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-9085c31311a5cf80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-7aef703bd3fc78d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;中间操作示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StreamTest2 {
    List&amp;lt;User&amp;gt; users = Arrays.asList(new User(1, 27, &quot;大青山&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(2, 47, &quot;池寒枫&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(3, 25, &quot;艾米&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(4, 18, &quot;池傲天&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(5, 380, &quot;霍恩斯&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(5, 500, &quot;霍恩斯&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(5, 320, &quot;霍恩斯1&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(5, 600, &quot;霍恩斯2&quot;, Arrays.asList(&quot;guangzhou&quot;, &quot;shengzhen&quot;)));

    //中间操作
    @Test
    public void test() {
        //filter: boolean test(T t); 通过断言型接口参数过滤
        //forEach 是内部迭代，由Stream api 完成，相对的外部迭代就是我们自己写迭代代码iterator
        users.stream().filter(user -&amp;gt; user.getAge() &amp;gt; 23).forEach(System.out::println);
    }

    @Test
    public void test2() {
        //limit 截断流，截取maxSize个，当截取到足够的个数后便会短路，不再迭代下去
        users.stream().filter(user -&amp;gt; user.getAge() &amp;gt; 23)
                .limit(2).forEach(System.out::println);
    }

    /**
     * User{id=1, age=27, name='大青山'}
     * User{id=2, age=47, name='池寒枫'}
     */

    @Test
    public void test3() {
        //skip 跳过n个
        //distinct 去重 如果是对象需要重写hashCode和equal方法
        users.stream().filter(user -&amp;gt; user.getAge() &amp;gt; 23)
                .skip(2).distinct().forEach(System.out::println);
    }

    /**
     * User{id=3, age=25, name='艾米'}
     * User{id=5, age=500, name='霍恩斯'}
     */

    @Test
    public void test4() {
        //map 映射 参数是函数式接口Function&amp;lt;? super T, ? extends R&amp;gt;
        users.stream().map(user -&amp;gt; user.getName()).forEach(System.out::println);
    }

    /**
     * 大青山
     * 池寒枫
     * 艾米
     * 池傲天
     * 霍恩斯
     * 霍恩斯
     */

    @Test
    public void test5() {
        //flatMap 映射成流,将流中的每个值都映射成流，把所有的流连接成一个流。
        // 参数是函数式接口Function&amp;lt;? super T, ? extends Stream&amp;lt;? extends R&amp;gt;&amp;gt; mapper ,注意出参必须是个Stream流对象。因此lambda表达式的返回值要是个流
        Stream&amp;lt;String&amp;gt; stream = users.stream().flatMap(user -&amp;gt; user.getAddress().stream());
//        List&amp;lt;String&amp;gt; collect = stream.collect(Collectors.toList());
//        System.out.println(collect);
        stream.forEach(System.out::println);
    }

    @Test
    public void test6() {
        //sorted() 排序：沒有传参数默认自然排序：  Comparable ：注意，要排序的对象必须实现Comparable才能调用自然排序sorted()
        /**像String就能调用sorted() 排序，因为他实现了Comparable。
         * 否则会报错：java.lang.ClassCastException: com.self.practice.lambda.User cannot be cast to java.lang.Comparable
         * public final class String
         *     implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence
         */
        //sorted(Comparator&amp;lt;? super T&amp;gt; comparator); 定制排序 Comparator
        Stream&amp;lt;User&amp;gt; stream = users.stream().sorted((e1, e2) -&amp;gt; {
            if (e1.getName().equals(e2.getName())) {
                return e1.getAge().compareTo(e2.getAge());//倒序取反就行，加个负号 -
            } else {
                return e1.getName().compareTo(e2.getName());
            }
        });
        stream.forEach(System.out::println);
    }
}
/**
     * User{id=1, age=27, name='大青山'}
     * User{id=4, age=18, name='池傲天'}
     * User{id=2, age=47, name='池寒枫'}
     * User{id=3, age=25, name='艾米'}
     * User{id=5, age=380, name='霍恩斯'}
     * User{id=5, age=500, name='霍恩斯'}
     * User{id=5, age=320, name='霍恩斯1'}
     * User{id=5, age=600, name='霍恩斯2'}
     */

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;终止操作&quot;&gt;&lt;strong&gt;终止操作&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-14bdb7a95fece6de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-507a56fc840dd96a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-2b6392ef633bb10d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到List、Set、Map)。但是Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-1770e695c8d06297.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-45e006c4d877b33f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StreamTest {

    //创建Stream流的4种方式
    @Test
    public void test() {
        //1、集合创建流：通过Collection系列集合提供的stream()或parallelStream()方法创建流
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        //串行流
        Stream&amp;lt;String&amp;gt; stream = list.stream();
        //并行流
        Stream&amp;lt;String&amp;gt; parallelStream = list.parallelStream();

        //2、数组创建流：通过Arrays.stream(T[] array)静态方法获取数组流
        User[] users = new User[5];
        Stream&amp;lt;User&amp;gt; userStream = Arrays.stream(users);

        //3、Stream创建流： 通过Stream.of(T... values)静态方法创建流
        Stream&amp;lt;Integer&amp;gt; integerStream = Stream.of(1, 2, 3, 66, 75);

        //4、创建无限流
        // A:通过Stream.iterate(final T seed, final UnaryOperator&amp;lt;T&amp;gt; f)传入seed和一元函数式接口实现无限流
        Stream&amp;lt;Integer&amp;gt; stream1 = Stream.iterate(1, x -&amp;gt; x + 1);
        stream1.limit(5).forEach(System.out::println);

        // B:通过Stream.igenerate(Supplier&amp;lt;T&amp;gt; s) 提供一个供给型接口实现无限流
        Stream&amp;lt;Double&amp;gt; stream2 = Stream.generate(()-&amp;gt;Math.random());
        stream2.limit(5).forEach(System.out::println);

    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StreamTest2 {
    List&amp;lt;User&amp;gt; users = Arrays.asList(new User(1, 27, &quot;大青山&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(2, 47, &quot;池寒枫&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(3, 25, &quot;艾米&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(4, 18, &quot;池傲天&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(5, 380, &quot;霍恩斯&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(5, 500, &quot;霍恩斯&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(5, 320, &quot;霍恩斯1&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(5, 600, &quot;霍恩斯2&quot;, Arrays.asList(&quot;guangzhou&quot;, &quot;shengzhen&quot;)));

    //中间操作
    @Test
    public void test() {
        //filter: boolean test(T t); 通过断言型接口参数过滤
        //forEach 是内部迭代，由Stream api 完成，相对的外部迭代就是我们自己写迭代代码iterator
        users.stream().filter(user -&amp;gt; user.getAge() &amp;gt; 23).forEach(System.out::println);
    }

    @Test
    public void test2() {
        //limit 截断流，截取maxSize个，当截取到足够的个数后便会短路，不再迭代下去
        users.stream().filter(user -&amp;gt; user.getAge() &amp;gt; 23)
                .limit(2).forEach(System.out::println);
    }

    /**
     * User{id=1, age=27, name='大青山'}
     * User{id=2, age=47, name='池寒枫'}
     */

    @Test
    public void test3() {
        //skip 跳过n个
        //distinct 去重 如果是对象需要重写hashCode和equal方法
        users.stream().filter(user -&amp;gt; user.getAge() &amp;gt; 23)
                .skip(2).distinct().forEach(System.out::println);
    }

    /**
     * User{id=3, age=25, name='艾米'}
     * User{id=5, age=500, name='霍恩斯'}
     */

    @Test
    public void test4() {
        //map 映射 参数是函数式接口Function&amp;lt;? super T, ? extends R&amp;gt;
        users.stream().map(user -&amp;gt; user.getName()).forEach(System.out::println);
    }

    /**
     * 大青山
     * 池寒枫
     * 艾米
     * 池傲天
     * 霍恩斯
     * 霍恩斯
     */

    @Test
    public void test5() {
        //flatMap 映射成流,将流中的每个值都映射成流，把所有的流连接成一个流。
        // 参数是函数式接口Function&amp;lt;? super T, ? extends Stream&amp;lt;? extends R&amp;gt;&amp;gt; mapper ,注意出参必须是个Stream流对象。因此lambda表达式的返回值要是个流
        Stream&amp;lt;String&amp;gt; stream = users.stream().flatMap(user -&amp;gt; user.getAddress().stream());
//        List&amp;lt;String&amp;gt; collect = stream.collect(Collectors.toList());
//        System.out.println(collect);
        stream.forEach(System.out::println);
    }

    @Test
    public void test6() {
        //sorted() 排序：沒有传参数默认自然排序：  Comparable ：注意，要排序的对象必须实现Comparable才能调用自然排序sorted()
        /**像String就能调用sorted() 排序，因为他实现了Comparable。
         * 否则会报错：java.lang.ClassCastException: com.self.practice.lambda.User cannot be cast to java.lang.Comparable
         * public final class String
         *     implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence
         */
        //sorted(Comparator&amp;lt;? super T&amp;gt; comparator); 定制排序 Comparator
        Stream&amp;lt;User&amp;gt; stream = users.stream().sorted((e1, e2) -&amp;gt; {
            if (e1.getName().equals(e2.getName())) {
                return e1.getAge().compareTo(e2.getAge());//倒序取反就行，加个负号 -
            } else {
                return e1.getName().compareTo(e2.getName());
            }
        });
        stream.forEach(System.out::println);
    }
    /**
     * User{id=1, age=27, name='大青山'}
     * User{id=4, age=18, name='池傲天'}
     * User{id=2, age=47, name='池寒枫'}
     * User{id=3, age=25, name='艾米'}
     * User{id=5, age=380, name='霍恩斯'}
     * User{id=5, age=500, name='霍恩斯'}
     * User{id=5, age=320, name='霍恩斯1'}
     * User{id=5, age=600, name='霍恩斯2'}
     */
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StreamTest3 {
    List&amp;lt;User&amp;gt; users = Arrays.asList(new User(3, 25, &quot;艾米&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(1, 27, &quot;大青山&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(2, 47, &quot;池寒枫&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
//            new User(3, 25, &quot;艾米&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
//            new User(4, 18, &quot;池傲天&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
//            new User(4, 18, &quot;池傲天&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
//            new User(4, 18, &quot;池傲天&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
//            new User(4, 18, &quot;池傲天&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(4, 18, &quot;池傲天&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
//            new User(5, 380, &quot;霍恩斯&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(5, 500, &quot;霍恩斯&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)));

    //终止操作
    @Test
    public void test() {
        //anyMatch(Predicate&amp;lt;? super T&amp;gt; predicate) 检查是否至少匹配一个元素
        boolean b = users.stream().anyMatch(user -&amp;gt; user.getAge() &amp;gt; 600);
        System.out.println(b);//false
        //allMatch(Predicate&amp;lt;? super T&amp;gt; predicate) 检查是否匹配所有元素
        boolean b1 = users.stream().allMatch(user -&amp;gt; user.getAge() &amp;lt; 600);
        System.out.println(b1);//true
        //noneMatch(Predicate&amp;lt;? super T&amp;gt; predicate) 检查是否所有元素都没有匹配到
        boolean b2 = users.stream().noneMatch(user -&amp;gt; &quot;雷葛&quot;.equals(user.getName()));
        System.out.println(b2);//true
        //先排序再获取第一个最大或最小的值
        //Optional&amp;lt;T&amp;gt; findFirst() 返回第一个元素 ,注意因为集合可能为空因此返回了Optional对象
        Optional&amp;lt;User&amp;gt; user = users.stream().sorted(Comparator.comparing(User::getAge)).findFirst();
        user.ifPresent(System.out::println);

        //先过滤出符合条件的随便找一个
        // Optional&amp;lt;T&amp;gt; findAny() 返回当前流中的任意元素,总感觉不是返回任意一个？而是返回第一个符合条件的
        Optional&amp;lt;User&amp;gt; userOptional = users.stream().filter(u -&amp;gt; u.getAge() &amp;lt; 30).findAny();
        userOptional.ifPresent(System.out::println);

        long count = users.stream().count();
        System.out.println(count);
        //Optional&amp;lt;T&amp;gt; max(Comparator&amp;lt;? super T&amp;gt; comparator) 返回流中最大值
        Optional&amp;lt;User&amp;gt; max = users.stream().max(Comparator.comparing(User::getAge));
        System.out.println(max);
        //Optional&amp;lt;T&amp;gt; min(Comparator&amp;lt;? super T&amp;gt; comparator) 返回流中最小值
        Optional&amp;lt;String&amp;gt; min = users.stream().map(u -&amp;gt; u.getName()).min(String::compareTo);
        System.out.println(min);

    }

    //归约
    @Test
    public void test1(){
        /**
         * 归约，可以将流中的元素反复结合起来，得到一个值。像我们下面可以对各个值进行累加操作，也可以进行累乘等操作
         * identity作为起始值作为x，然后把流中的元素作为y进行操作；得到的结果继续作为x，继续对流的元素填充y进行操作
         * T reduce(T identity, BinaryOperator&amp;lt;T&amp;gt; accumulator);
         *BinaryOperator&amp;lt;T&amp;gt; :R apply(T t, U u);
         */
//        Integer totalAge = users.stream().map(user -&amp;gt; user.getAge()).reduce(0, (x, y) -&amp;gt; x + y);
        //get和累加的两种写法
//        Integer totalAge = users.stream().map(User::getAge).reduce(0, Integer::sum);
        //如果没有identity作为起始值，那么返回的是Optional，因为集合可能为空
        //map-reduce连接称为map-reduce模式，网络搜索模式（大数据搜索）
        Optional&amp;lt;Integer&amp;gt; totalAge = users.stream().map(User::getAge).reduce( Integer::sum);
        System.out.println(totalAge.get());//617

        //归约拼接字符串
        Optional&amp;lt;String&amp;gt; stringOptional = users.stream().map(User::getName).reduce(String::concat);
        System.out.println(stringOptional.get());//艾米大青山池寒枫池傲天霍恩斯
    }

    //收集
    @Test
    public void test2(){
        /**
         * collect将流转化为其他的形式，接收一个collector实现，用于给stream中元素做汇总的方法
         */
        List&amp;lt;String&amp;gt; list = users.stream().map(User::getName).collect(Collectors.toList());
        list.forEach(System.out::print);//艾米大青山池寒枫池傲天霍恩斯

        //set去重
        Set&amp;lt;String&amp;gt; set = users.stream().map(User::getName).collect(Collectors.toSet());
        set.forEach(System.out::print);//艾米大青山池寒枫池傲天霍恩斯

        //把流中元素收集到创建的集合.如HashSet::new
        HashSet&amp;lt;String&amp;gt; hashSet = users.stream().map(User::getName).collect(Collectors.toCollection(HashSet::new));
        hashSet.forEach(System.out::print);//艾米大青山池寒枫池傲天霍恩斯

        //收集统计
        Long total = users.stream().collect(Collectors.counting());
        System.out.println(total);//5

        //平均值。年龄平均值
        Double avarage = users.stream().collect(Collectors.averagingInt(User::getAge));
        System.out.println(avarage);//123.4

        //总和
        Integer sum = users.stream().collect(Collectors.summingInt(User::getAge));
        System.out.println(sum);//617

        //最大值
//        Optional&amp;lt;User&amp;gt; max = users.stream().max((u1, u2) -&amp;gt; Integer.compare(u1.getAge(), u2.getAge()));
        Optional&amp;lt;User&amp;gt; max = users.stream().collect(Collectors.maxBy((u1, u2) -&amp;gt; Integer.compare(u1.getAge(), u2.getAge())));
        System.out.println(max.get());//User{id=5, age=500, name='霍恩斯'}

        //最小值.注意不是对象就可以用Integer::compare方法引用替换，对象的话还是要写函数式方法
        Optional&amp;lt;Integer&amp;gt; min = users.stream().map(User::getAge).collect(Collectors.minBy(Integer::compare));
        System.out.println(min.get());//18
    }

    //分组
    @Test
    public void test3(){
        //按名字分组
        Map&amp;lt;String, List&amp;lt;User&amp;gt;&amp;gt; map = users.stream().collect(Collectors.groupingBy(User::getName));
        System.out.println(map);
        //{霍恩斯=[User{id=5, age=500, name='霍恩斯'}], 艾米=[User{id=3, age=25, name='艾米'}], 池傲天=[User{id=4, age=18, name='池傲天'}], 大青山=[User{id=1, age=27, name='大青山'}], 池寒枫=[User{id=2, age=47, name='池寒枫'}]}

        //多级分组
        Map&amp;lt;String, Map&amp;lt;String, List&amp;lt;User&amp;gt;&amp;gt;&amp;gt; collect = users.stream().collect(Collectors.groupingBy(user -&amp;gt; {
            if (user.getAge() &amp;lt; 20) {
                return &quot;young&quot;;
            } else if (user.getAge() &amp;lt; 50) {
                return &quot;adult&quot;;
            } else {
                return &quot;old&quot;;
            }
        }, Collectors.groupingBy(User::getName)));
        System.out.println(collect);
        //{young={池傲天=[User{id=4, age=18, name='池傲天'}]}, old={霍恩斯=[User{id=5, age=500, name='霍恩斯'}]}, adult={艾米=[User{id=3, age=25, name='艾米'}], 大青山=[User{id=1, age=27, name='大青山'}], 池寒枫=[User{id=2, age=47, name='池寒枫'}]}}
    }

    //分区，即满足与不满足条件的元素区分
    @Test
    public void test4(){
        //年龄大于50的为true，满足条件
        Map&amp;lt;Boolean, List&amp;lt;User&amp;gt;&amp;gt; map = users.stream().collect(Collectors.partitioningBy(user -&amp;gt; user.getAge() &amp;gt; 50));
        System.out.println(map);
        //{false=[User{id=3, age=25, name='艾米'}, User{id=1, age=27, name='大青山'}, User{id=2, age=47, name='池寒枫'}, User{id=4, age=18, name='池傲天'}], true=[User{id=5, age=500, name='霍恩斯'}]}
    }

    @Test
    public void test5(){
        //获取统计,收集流中Integer属性的统计值。
        IntSummaryStatistics statistics = users.stream().collect(Collectors.summarizingInt(User::getAge));
        System.out.println(statistics.getAverage());//123.4
        System.out.println(statistics.getMax());//500
        System.out.println(statistics.getSum());//617
    }

    //连接流中每个字符串
    @Test
    public void test6(){
        String str = users.stream().map(User::getName).collect(Collectors.joining());
        //加分隔符，
        String str1 = users.stream().map(User::getName).collect(Collectors.joining(&quot;-&quot;));
        //加前缀、后缀
        String str2 = users.stream().map(User::getName).collect(Collectors.joining(&quot;-&quot;,&quot;start&quot;,&quot;end&quot;));
        System.out.println(str);//艾米大青山池寒枫池傲天霍恩斯
        System.out.println(str1);//艾米-大青山-池寒枫-池傲天-霍恩斯
        System.out.println(str2);//start艾米-大青山-池寒枫-池傲天-霍恩斯end

    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StreamPractice {
    List&amp;lt;User&amp;gt; users = Arrays.asList(new User(3, 25, &quot;艾米&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(1, 27, &quot;大青山&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(2, 47, &quot;池寒枫&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(4, 18, &quot;池傲天&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)),
            new User(5, 500, &quot;霍恩斯&quot;, Arrays.asList(&quot;shanghai&quot;, &quot;beijing&quot;)));
    @Test
    public void test() {
        List&amp;lt;Integer&amp;gt; list = Arrays.asList(1, 3, 5, 8);
        List&amp;lt;Integer&amp;gt; collect = list.stream().map(e -&amp;gt; e * e).collect(Collectors.toList());
        System.out.println(collect);//[1, 9, 25, 64]
    }

    @Test
    public void test1() {
        Optional&amp;lt;Integer&amp;gt; total = users.stream().map(user -&amp;gt; 1).reduce(Integer::sum);
        System.out.println(total);//5
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;并行流&quot;&gt;并行流&lt;/h4&gt;
&lt;p&gt;Fork/Join 框架与传统线程池的区别&lt;br/&gt;&lt;strong&gt;采用“工作窃取”模式（work-stealing）&lt;/strong&gt;：&lt;br/&gt;当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。&lt;br/&gt;相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子问题的&lt;strong&gt;线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间,提高了性能.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-78f3e7ca2e8834e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @Test
    public void test2() {
        Instant start = Instant.now();
        OptionalLong aLong = LongStream.rangeClosed(0, 100000000).parallel().reduce(Long::sum);
        System.out.println(aLong);
        Instant end = Instant.now();
        System.out.println(&quot;耗时长：&quot; + Duration.between(start, end).toMillis());
    }
    //OptionalLong[5000000050000000]
    //耗时长：55

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;optional容器类&quot;&gt;Optional——容器类&lt;/h4&gt;
&lt;p&gt;Optional 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用null 表示一个值不存在，现在Optional 可以更好的表达这个概念。并且可以避免空指针异常。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class OptionalTest {

    /**
     * 常用方法：
     * Optional.of(T t) : 创建一个Optional 实例
     * Optional.empty() : 创建一个空的Optional 实例
     * Optional.ofNullable(T t):若t 不为null,创建Optional 实例,否则创建空实例
     * isPresent() : 判断是否包含值
     * orElse(T t) : 如果调用对象包含值，返回该值，否则返回t
     * orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回s 获取的值
     * map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回Optional.empty()
     * flatMap(Function mapper):与map 类似，要求返回值必须是Optional
     */

    @Test
    public void test(){
        //Optional.of(T t) : 创建一个Optional 实例
        Optional&amp;lt;User&amp;gt; userOptional = Optional.of(new User());
        User user = userOptional.get();
        System.out.println(user);//User{id=null, age=null, name='null'}
        Optional&amp;lt;User&amp;gt; empty = Optional.empty();
//        User user1 = empty.get();//java.util.NoSuchElementException: No value present
//        System.out.println(user1);
        //Optional.ofNullable(T t):若t 不为null,创建Optional 实例,否则创建空实例
        //是of和empty方法的组合使用
        Optional&amp;lt;User&amp;gt; userOptional2 = Optional.ofNullable(new User());
        //isPresent() : 判断是否包含值
        if (userOptional2.isPresent()){
            System.out.println(userOptional2.get());
        }
        //ifPresent(Consumer&amp;lt;? super T&amp;gt; consumer) 判断存在包含值,存在则进行Consumer消费，一般选择这个处理Optional
        userOptional2.ifPresent(System.out::print);
        //orElse(T t) : 如果调用对象包含值，返回该值，否则返回参数值t
        User user1 = empty.orElse(new User());
        //orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则调用供给型函数获取值，
        User user2 = empty.orElseGet(User::new);
        //ap(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回Optional.empty()
//        Optional&amp;lt;String&amp;gt; s = userOptional2.map(e -&amp;gt; e.getName());

        //flatMap要求返回值必须是Optional,因此必须对返回值进行Optional.of包装
        Optional&amp;lt;String&amp;gt; optionalS = userOptional2.flatMap(e -&amp;gt; {
            return Optional.of(e.getName());
        });
    }

    @Test
    public void test1(){
        Optional&amp;lt;User&amp;gt; optional = Optional.ofNullable(null);
        String fanName = getFanName(optional);
        System.out.println(fanName);//null
    }

     //注意方法参数列表同样可以使用Optional包装
    public String getFanName(ser){
        //Optional使用Optional封装属性值对象及orElse来避免过多的空指针判断
        return user.orElse(new User())
                .getFan()
                .orElse(new Fan())
                .getName();//null
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;接口中的默认方法与静态方法&quot;&gt;接口中的默认方法与静态方法&lt;/h4&gt;
&lt;p&gt;Java 8中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用default关键字修饰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口默认方法的”类优先”原则&lt;/strong&gt;&lt;br/&gt;若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;选择父类中的方法&lt;/strong&gt;。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略&lt;/li&gt;
&lt;li&gt;接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突。&lt;strong&gt;覆盖选择其中一个接口的默认实现或者自己重写一个实现。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface IHello {

    default void say(){
        System.out.println(&quot;say hello&quot;);
    }

    String getName();

    //Java8 中，接口中允许添加静态方法
    public static void staticMethod(String str){
        System.out.println(str);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;新时间日期api&quot;&gt;新时间日期API&lt;/h4&gt;
&lt;p&gt;LocalDate、LocalTime、LocalDateTime 类的实例是&lt;strong&gt;不可变的对象&lt;/strong&gt;，因此是线程安全的，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。而SimpleDateFormat是可变对象，因此不是线程安全的，在使用时要注意每次使用时new创建一个新的SimpleDateFormat对象或者把SimpleDateFormat放在ThreadLocal上。&lt;/p&gt;
&lt;p&gt;注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法。&lt;/p&gt;
&lt;p&gt;Instant 时间戳，用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算&lt;/p&gt;
&lt;p&gt;Duration:用于计算两个“时间”间隔&lt;br/&gt;Period:用于计算两个“日期”间隔&lt;/p&gt;
&lt;p&gt;Java8 中加入了对时区的支持，带时区的时间为分别为：&lt;br/&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1252599548343744/1303904694304801&quot; target=&quot;_blank&quot;&gt;ZonedDate、ZonedTime、ZonedDateTime参考地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-389598bd2fe9f7fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-7d6e8f17a55a4118.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LocalDateTest {

    //LocalDateTime :本地日期时间 LocalDate LocalTime
    @Test
    public void test(){
        //获取当前日期时间
        LocalDateTime now = LocalDateTime.now();
        System.out.println(now);//2018-12-15T01:40:03.375
        //获取指定日期时间
        LocalDateTime time = LocalDateTime.of(2018, 7, 10, 10, 10, 59);
        System.out.println(time);//2018-07-10T10:10:59
        //获取增加一天的日期时间
        LocalDateTime nextDay = now.plusDays(1);
        System.out.println(nextDay);//2018-12-16T01:41:41.071
        //获取减少2个月的日期时间
        LocalDateTime time1 = now.minusMonths(2);
        System.out.println(time1);//2018-10-15T01:42:43.969
        System.out.println(now.getMonth());//DECEMBER
        System.out.println(now.getDayOfMonth());//15
        System.out.println(now.getMonthValue());//12
        System.out.println(now.getSecond());//45
    }

    //Instant 时间戳
    @Test
    public void test2(){
        //获取当前时间戳，默认获取的是UTC时区的时间戳
        Instant now = Instant.now();
        System.out.println(now);//2020-12-14T17:58:20.991Z
        OffsetDateTime dateTime = now.atOffset(ZoneOffset.ofHours(8));
        System.out.println(dateTime);//2020-12-15T02:05:57.558+08:00
        OffsetDateTime dateTime1 = now.atOffset(ZoneOffset.of(&quot;+8&quot;));
        System.out.println(dateTime1);//2020-12-15T02:05:57.558+08:00
        //获取当前时间的时间戳
        long epochMilli = now.toEpochMilli();
        //旧的获取方式
        long l = System.currentTimeMillis();
        //新老获取时间戳的值是一样的，只是新的时间戳返回的时间是UTC时区的日期时间，但在用new Date(l)转化时或默认转化为
        //当前日期时间。这个需要注意
        System.out.println(epochMilli);//1607968605927
        System.out.println(l);//1607968605927
        System.out.println(new Date(l));//Tue Dec 15 01:59:01 CST 2020
    }

    //Duration:时间间隔
    @Test
    public void test3(){
        Instant now = Instant.now();
        Instant instant = Instant.ofEpochMilli(1607968605927L);
        //Duration:用于计算两个“时间”间隔.注意间隔是用第二个参数减去第一个参数的间隔，因此当第一个参数是比较晚时得到的是负数
        Duration duration = Duration.between(instant, now);
        //获取间隔的毫秒值用to
        System.out.println(duration.toMillis());//992143
        //获取间隔的秒值用get
        System.out.println(duration.getSeconds());//992

        LocalDateTime localDateTime = LocalDateTime.now();
        LocalDateTime dateTime = LocalDateTime.of(2020, 12, 15, 0, 0, 0);
        Duration between = Duration.between(localDateTime, dateTime);
        System.out.println(between.getSeconds());//-8261
    }

    //Period:日期间隔
    @Test
    public void test5(){
        LocalDate now = LocalDate.now();
        LocalDate date = LocalDate.of(2020, 11, 11);
        //Period:用于计算两个“日期”间隔 获取值不好用
        Period period = Period.between(date, now);
        System.out.println(period);//P1M4D:表示间隔1个月04天
        System.out.println(period.getChronology());//ISO 年表
        System.out.println(period.getYears());//0
        System.out.println(period.getMonths());//1
        System.out.println(period.getDays());//4
    }

    //TemporalAdjuster:时间校正器
    @Test
    public void test6(){
        LocalDateTime now = LocalDateTime.now();
        //调整日期为该月的第一天
        LocalDateTime dateTime = now.withDayOfMonth(1);
        System.out.println(dateTime);//2020-12-01T02:39:06.111
        //调整日期为该月的第一天
        LocalDateTime time = now.with(TemporalAdjusters.firstDayOfMonth());
        System.out.println(time);//2020-12-01T02:35:01.715
        //调整日期为下一个星期天
        LocalDateTime nextSunday = now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));
        System.out.println(nextSunday);//2020-12-20T02:37:01.322

        //自定义时间校正器 :获取下一个工作日
        LocalDateTime nextWorkDate = now.with(temporal -&amp;gt; {
            LocalDateTime dateTime1 = (LocalDateTime) temporal;
            if (dateTime1.getDayOfWeek().equals(DayOfWeek.FRIDAY)) {
                return dateTime1.plusDays(3);
            } else if (dateTime1.getDayOfWeek().equals(DayOfWeek.SATURDAY)) {
                return dateTime1.plusDays(2);
            } else {
                return dateTime1.plusDays(1);
            }
        });
        System.out.println(nextWorkDate);//2020-12-16T02:44:45.370
    }

    //DateTimeFormatter :格式化时间/日期
    @Test
    public void test7(){
        DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE;
        DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd 时HH分mm秒ss&quot;);
        LocalDateTime now = LocalDateTime.now();
        //日期转指定格式的字符串
        String str = formatter.format(now);
        System.out.println(str);//2020-12-15
        String str2 = formatter2.format(now);
        System.out.println(str2);//2020-12-15 时02分54秒47

        //注意2020-12-15这种类型的字符串没法转化为日期时间LocalDateTime,只能转化为日期LocalDate
//        会报错：java.time.format.DateTimeParseException: Text '2020-12-15' could not be parsed: Unable to obtain LocalDateTime from TemporalAccessor: {},ISO resolved to 2020-12-15 of type java.time.format.Parsed
//        LocalDateTime dateTime = now.parse(str, formatter);
        LocalDate date = LocalDate.parse(str, formatter);
        System.out.println(date);//2020-12-15
        //指定格式字符串转日期时间
        LocalDateTime dateTime2 = LocalDateTime.parse(str2, formatter2);
        System.out.println(dateTime2);//2020-12-15T03:01:43

    }

    //带时区的时间为分别为：ZonedDate、ZonedTime、ZonedDateTime
    //Asia/Shanghai  America/New_York
    @Test
    public void test9(){
        //获取带时区的日期和时间 方式一
        //默认时区
        ZonedDateTime now1 = ZonedDateTime.now();
        System.out.println(now1);//2020-12-15T03:34:44.479+08:00[Asia/Shanghai]
        //用指定时区获取当前时间
        ZonedDateTime newyorkNow = ZonedDateTime.now(ZoneId.of(&quot;America/New_York&quot;));
        System.out.println(newyorkNow);//2020-12-14T14:36:21.999-05:00[America/New_York]

        //获取带时区的日期和时间 方式二
        //以这种方式创建的ZonedDateTime，它的日期和时间与LocalDateTime相同，但附加的时区不同，因此是两个不同的时刻
        LocalDateTime now = LocalDateTime.now(ZoneId.of(&quot;America/New_York&quot;));
        System.out.println(now.atZone(ZoneId.systemDefault()));//2020-12-14T14:39:04.255+08:00[Asia/Shanghai]

        LocalDateTime now2 = LocalDateTime.now(ZoneId.of(&quot;America/New_York&quot;));
        //获取到的区域时间是当地日期时间 +时区时间差
        ZonedDateTime zonedDateTime = now2.atZone(ZoneId.of(&quot;America/New_York&quot;));
        System.out.println(zonedDateTime);//2020-12-14T14:19:41.923-05:00[America/New_York]

        //时区转换
        //通过withZoneSameInstant()将关联时区转换到另一个时区，转换后日期和时间都会相应调整。
        //时区转换的时候，由于夏令时的存在，不同的日期转换的结果很可能是不同的。
        //涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。
        //默认时区
        ZonedDateTime now3 = ZonedDateTime.now();
        ZonedDateTime newYorkDateTime1 = now3.withZoneSameInstant(ZoneId.of(&quot;America/New_York&quot;));
        System.out.println(now3);//2020-12-15T03:42:58.940+08:00[Asia/Shanghai]
        System.out.println(newYorkDateTime1);//2020-12-14T14:42:58.940-05:00[America/New_York]
        //纽约时区时间转换为本地时间
        LocalDateTime localDateTime = newYorkDateTime1.toLocalDateTime();
        System.out.println(localDateTime);//丢弃了时区信息

        //练习：某航线从北京飞到纽约需要13小时20分钟，请根据北京起飞日期和时间计算到达纽约的当地日期和时间。
        ZonedDateTime now4 = ZonedDateTime.now();
        ZonedDateTime zonedDateTime1 = now4.plusHours(13).plusMinutes(20);
        ZonedDateTime newyorkDateTime2 = zonedDateTime1.withZoneSameInstant(ZoneId.of(&quot;America/New_York&quot;));
        System.out.println(newyorkDateTime2);//2020-12-15T04:12:39.611-05:00[America/New_York]
        System.out.println(&quot;before:&quot;+now4);//before:2020-12-15T03:52:39.611+08:00[Asia/Shanghai]
        System.out.println(&quot;after:&quot;+zonedDateTime1);//after:2020-12-15T17:12:39.611+08:00[Asia/Shanghai]
    }

    @Test
    public void test8(){
        Set&amp;lt;String&amp;gt; zoneIds = ZoneId.getAvailableZoneIds();
        zoneIds.forEach(System.out::println);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重复注解和类型注解&quot;&gt;重复注解和类型注解&lt;/h4&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//定义可重复注解的容器
@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface NameAnnotions {
    NameAnnotion[] value();
}

//可重复注解必须加@Repeatable(NameAnnotions.class)，NameAnnotions为其容器
@Repeatable(NameAnnotions.class)
//注意类型注解要求这两个目标注解都要标注才能使用，否则报错：ElementType.PARAMETER,ElementType.TYPE_PARAMETER
@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD,ElementType.TYPE,ElementType.PARAMETER,ElementType.TYPE_PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface NameAnnotion {
    String value() default &quot;&quot;;
}

public class AnnotionTest {

    @Test
    public void test() throws NoSuchMethodException {
        Class&amp;lt;AnnotionTest&amp;gt; aClass = AnnotionTest.class;
        Method work = aClass.getMethod(&quot;work&quot;);
        NameAnnotion[] annotations = work.getAnnotationsByType(NameAnnotion.class);
        for (NameAnnotion annotation : annotations) {
            System.out.println(annotation.value());
        }
    }

    //可重复注解
    @NameAnnotion(&quot;996&quot;)
    @NameAnnotion(&quot;955&quot;)
    public void work(@NameAnnotion String str) {
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;其他新特性&quot;&gt;其他新特性&lt;/h4&gt;
&lt;h5 id=&quot;hashmap的新特性从数组加链表的存储方式转变为数组加链表红黑树的方式。&quot;&gt;HashMap的新特性——从数组加链表的存储方式转变为数组加(链表/红黑树)的方式。&lt;/h5&gt;
&lt;p&gt;HashMap在存储数据的时候会先计算出Key的hash值，再通过运算得到我们底层存储的数组的下标索引值。 当hash值一样时，会调用equal()方法比较内容是否相等，如果相等则替换原有的值，如果不相等，此时就产生了hash碰撞，数据会被以链表的形式存放起来。而当hash碰撞严重时，比如极端情况下，链表就会很长，导致查询或插入比较时效率低下，这时候我们就引入了采用红黑树来替换链表的形式进行存储。&lt;/p&gt;
&lt;p&gt;链表转红黑树的条件是：当链表的长度大于8且HashMap的容量大于64时会触发由链表转红黑树逻辑。红黑树除了添加以外其他的效率都很高，因为链表添加的时候是添加在末尾比较快，而红黑树添加时要进行比较大小添加。&lt;/p&gt;
&lt;p&gt;加载因子设置为0.75的原因，因为如果太小，HashMap就会不断扩容，浪费效率。太大了可能插入的值就是一直产生碰撞形成了链表，没有插入到数组的索引位置，导致一直没有扩容，效率低下。&lt;/p&gt;
&lt;h5 id=&quot;concurrenthashmap的新特性把锁分段技术改成cas算法&quot;&gt;ConcurrentHashMap的新特性——把锁分段技术改成CAS算法&lt;/h5&gt;
&lt;p&gt;ConcurrentHashMap在JDK1.8之前是采用锁分段技术，默认由16个分段，对于16把锁。因为分段的数量不好控制，如果分段过多就会浪费空间，因为很多段里面其实没有数据进入，而太小也不好，这样就导致效率太低，因为会导致太多操作竞争同一个段锁。&lt;/p&gt;
&lt;p&gt;底层也采用数组加(链表/红黑树)的方式提高效率。&lt;/p&gt;
&lt;h5 id=&quot;方法区实现从永久代实现变为元空间metaspace。&quot;&gt;方法区实现从永久代实现变为元空间MetaSpace。&lt;/h5&gt;
&lt;p&gt;元空间使用的是物理内存。默认物理内存有多大，元空间就可以是多大，只受限于物理内存的大小，当然我们也可以指定MetaSpaceSize指定元空间大小，MaxMetaSpaceSize指定最大元空间大小。取代了永久代的PermGenSize和MaxPermGenSize.&lt;/p&gt;
</description>
<pubDate>Mon, 14 Dec 2020 20:32:00 +0000</pubDate>
<dc:creator>卡斯特梅的雨伞</dc:creator>
<og:description>Java 8 新特性——实践篇 参考 Java8新特性 重要更新：Lambda 表达式和Stream API Lambda 表达式 Lambda 表达式引入之前： 举个场景例子：当我们要对一个班级里的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/castamere/p/14136615.html</dc:identifier>
</item>
<item>
<title>DPSK通信系统的FPGA实现 - 羽扇纶巾o0</title>
<link>http://www.cnblogs.com/gjblog/p/14136351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gjblog/p/14136351.html</guid>
<description>&lt;p&gt;之前接触过一些FPGA的相关知识，借着实现一个简单的DPSK系统，顺便复习和记录一下Verilog HDL的简单使用方法。准备直接用一张图展现DPSK的调制解调原理，再按照模块介绍Verilog的实现步骤，然后进行软件仿真，最后给出完整的代码。&lt;/p&gt;
&lt;h2 id=&quot;一：dpsk的实现原理&quot;&gt;一：DPSK的实现原理&lt;/h2&gt;
&lt;p&gt;DPSK，中文叫差分相位键控，与最简单的BPSK调相系统很像，只不过DPSK是把数字信号源做了一个差分处理，用载波的相位变化来承载信号信息。这里我们让系统越简单越好，不考虑同步、信道、噪声等因素。首先直接用一个手绘流程图来展现DPSK系统信号的变化过程：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048856/202012/2048856-20201214000800301-1743469374.png&quot; width=&quot;500&quot; height=&quot;550&quot; alt=&quot;&quot; align=&quot;center&quot;/&gt;&lt;p&gt;是不是很神奇，只要经过这些步骤，信号源信号就能被恢复出来！&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;二：verilog模块实现&quot;&gt;二：verilog模块实现&lt;/h2&gt;
&lt;p&gt;这里我用的是Quartus13.0加ModelSim，一个比较老的版本来做仿真，所以想按照下面配置跟着一步一步实现的话，最好选用相同的软件比较好。由于只想简单快速实现一下系统，其实也是太难的模块写不出来。。。所以稍微难一点的地方都用自带的IP核来实现了，相关的配置也会以图片的形式总结出来。&lt;/p&gt;
&lt;h3 id=&quot;21-分频器模块&quot;&gt;2.1 分频器模块&lt;/h3&gt;
&lt;p&gt;要生成各种信号核进行信号之间的运算，肯定要用时钟来控制。这里先给出几个时钟设计要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;固定系统时钟频率：clk = 50Mhz&lt;/li&gt;
&lt;li&gt;正弦载波生成模块需要的时钟频率：clk10m = 10Mhz&lt;/li&gt;
&lt;li&gt;信号源生成模块需要的时钟频率：clk100k = 100Khz&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们已经有了固定的系统时钟为50Mhz了，所以只用分频得到10Mhz核100Khz的时钟就可以了。&lt;/p&gt;
&lt;h4 id=&quot;211-代码实现&quot;&gt;2.1.1 代码实现&lt;/h4&gt;
&lt;p&gt;分频器模块代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module divide(
clk,rst_n,clkout);
 
        input   clk,rst_n;                       //输入信号
        output  clkout;                          //输出信号，可以连接到LED观察分频的时钟
 
        parameter       WIDTH   = 3;             //计数器的位数，计数的最大值为 2**WIDTH-1
        parameter       N       = 5;             //分频系数，请确保 N &amp;lt; 2**WIDTH-1，否则计数会溢出
 
        reg     [WIDTH-1:0]     cnt_p,cnt_n;     //cnt_p为上升沿触发时的计数器，cnt_n为下降沿触发时的计数器
        reg                     clk_p,clk_n;     //clk_p为上升沿触发时分频时钟，clk_n为下降沿触发时分频时钟
 
        //上升沿触发时计数器的控制
        always @ (posedge clk or negedge rst_n )         //posedge和negedge是verilog表示信号上升沿和下降沿
                                                         //当clk上升沿来临或者rst_n变低的时候执行一次always里的语句
                begin
                        if(!rst_n)
                                cnt_p&amp;lt;=0;
                        else if (cnt_p==(N-1))
                                cnt_p&amp;lt;=0;
                        else cnt_p&amp;lt;=cnt_p+1;             //计数器一直计数，当计数到N-1的时候清零，这是一个模N的计数器
                end
 
         //上升沿触发的分频时钟输出,如果N为奇数得到的时钟占空比不是50%；如果N为偶数得到的时钟占空比为50%
         always @ (posedge clk or negedge rst_n)
                begin
                        if(!rst_n)
                                clk_p&amp;lt;=0;
                        else if (cnt_p&amp;lt;(N&amp;gt;&amp;gt;1))          //N&amp;gt;&amp;gt;1表示右移一位，相当于除以2去掉余数
                                clk_p&amp;lt;=0;
                        else 
                                clk_p&amp;lt;=1;               //得到的分频时钟正周期比负周期多一个clk时钟
                end
 
        //下降沿触发时计数器的控制          
        always @ (negedge clk or negedge rst_n)
                begin
                        if(!rst_n)
                                cnt_n&amp;lt;=0;
                        else if (cnt_n==(N-1))
                                cnt_n&amp;lt;=0;
                        else cnt_n&amp;lt;=cnt_n+1;
                end
 
        //下降沿触发的分频时钟输出，和clk_p相差半个时钟
        always @ (negedge clk)
                begin
                        if(!rst_n)
                                clk_n&amp;lt;=0;
                        else if (cnt_n&amp;lt;(N&amp;gt;&amp;gt;1))  
                                clk_n&amp;lt;=0;
                        else 
                                clk_n&amp;lt;=1;                //得到的分频时钟正周期比负周期多一个clk时钟
                end
 
        assign clkout = (N==1)?clk:(N[0])?(clk_p&amp;amp;clk_n):clk_p;      //条件判断表达式
                                                                    //当N=1时，直接输出clk
                                                                    //当N为偶数也就是N的最低位为0，N（0）=0，输出clk_p
                                                                    //当N为奇数也就是N最低位为1，N（0）=1，输出clk_p&amp;amp;clk_n。正周期多所以是相与
endmodule     
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;22-正弦载波生成模块&quot;&gt;2.2 正弦载波生成模块&lt;/h3&gt;
&lt;p&gt;下面我们来生成正弦载波信号，这里我们先给出此模块的参数设计实现要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;正弦载波驱动时钟频率：clk10m = 10Mhz&lt;/li&gt;
&lt;li&gt;正弦载波输出频率：fsin_o = 100Khz&lt;/li&gt;
&lt;li&gt;输出两个载波相位分别为0和&lt;span class=&quot;math inline&quot;&gt;\(\pi\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;输出幅度累加器精度：M = 14&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要实现数字调相系统，正弦载波的正确生成至关重要。这里我们直接用NCO IP核可以用来作为生产正弦载波的模块。设置好生成频率或数据精度等IP核内部参数后，只需要在主程序模块中例化IP核，接口输入设计中要求的参数即可。&lt;/p&gt;
&lt;p&gt;NCO IP核的配置图如下：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048856/202012/2048856-20201213223512720-633054316.png&quot; width=&quot;480&quot; height=&quot;350&quot; alt=&quot;&quot; align=&quot;center&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048856/202012/2048856-20201213223521039-1478663887.png&quot; width=&quot;480&quot; height=&quot;350&quot; alt=&quot;&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;&lt;p&gt;按上图这样生成好IP核之后，会自动生成一个IP核的接口函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module sine_ip (
        phi_inc_i,
        clk,
        reset_n,
        clken,
        phase_mod_i,
        fsin_o,
        out_valid);


        input   [31:0]  phi_inc_i;
        input           clk;
        input           reset_n;
        input           clken;
        input   [13:0]  phase_mod_i;
        output  [13:0]  fsin_o;
        output          out_valid;


        sine_ip_st      sine_ip_st_inst(
                .phi_inc_i(phi_inc_i),
                .clk(clk),
                .reset_n(reset_n),
                .clken(clken),
                .phase_mod_i(phase_mod_i),
                .fsin_o(fsin_o),
                .out_valid(out_valid));
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的接口函数有几个参数要注意一下：&lt;/p&gt;
&lt;p&gt;（1） phi_inc_i是相位增益，它的大小控制着输出正弦信号的频率，它的位宽控制着输出的精度，它的位宽我们设置为32。&lt;/p&gt;
&lt;p&gt;由于输入时钟频率为10Mhz，我们想要的输出信号频率为100Khz，输出信号位宽M为14，由公式：&lt;/p&gt;
&lt;p&gt;\[f_0 = \frac{\phi_{INC} f_{clk}}{2^M} \]&lt;/p&gt;
&lt;p&gt;计算出&lt;span class=&quot;math inline&quot;&gt;\(\phi_{INC}\)&lt;/span&gt;约为42949673。将此相位增量作为输入，便可得到期望频率的正弦波。&lt;/p&gt;
&lt;p&gt;（2） phase_mod_i是相位调整参数，它的大小控制着输出正弦信号的相位，它的位宽控制着输出的精度，它的位宽我们设置为14。&lt;/p&gt;
&lt;p&gt;输出相位为0时，此值为二进制14'b10_0110_0000_1010（好像是我试出来的？）。想要得到相位差&lt;span class=&quot;math inline&quot;&gt;\(\pi\)&lt;/span&gt;的两个正弦载波，只需要将第二个载波的调相参数值在前者的基础上加上二进制的100...0，位数为14，于是便可很方便的产生两相位差&lt;span class=&quot;math inline&quot;&gt;\(\pi\)&lt;/span&gt;的载波。&lt;/p&gt;
&lt;p&gt;（3） fsin_o是输出正弦波，设置的位宽为14。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;23-信号源生成模块&quot;&gt;2.3 信号源生成模块&lt;/h3&gt;
&lt;p&gt;关于信号源的生成，直接随机生成的话感觉B格不够，所以准备用伪随机序列：PN码（也叫m序列）来当成生成的数字信号源，此模块的参数设计要求如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数字信号源速率：Rb = 100Kbps；&lt;/li&gt;
&lt;li&gt;PN码为5阶本原多项式：f(x) = x5 + x2 + 1；&lt;/li&gt;
&lt;li&gt;寄存器初值：reg_state = [1 0 1 1 0];&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用下图的移位寄存器方式便能源源不断的生成周期为&lt;span class=&quot;math inline&quot;&gt;\(2^5\)&lt;/span&gt;的PN码：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048856/202012/2048856-20201213230553732-781911380.jpg&quot; width=&quot;400&quot; height=&quot;100&quot; alt=&quot;&quot; align=&quot;center&quot;/&gt;&lt;h4 id=&quot;231-代码实现&quot;&gt;2.3.1 代码实现&lt;/h4&gt;
&lt;p&gt;话不多说，代码奉上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module PnCode (
        rst,clk,pn); 

        input    rst;                                           //复位信号，高电平有效
        input    clk;                                           //分频得到的PN码生成时钟，100khz
        output pn;                                                      //输出的PN码序列
   
        //设置PN码的本原多项式及初始相位
        parameter Len = 5;                              //寄存器长度
        wire [Len-1:0] reg_state = 5'b10110;   //寄存器初值
        wire [Len:0]   polynomial= 6'b100101;  //本原多项式   
   reg [Len-1:0] pn_reg = 5'b10110;             //初始化与寄存器初值相同
   reg pncode = 1'b0;
        integer i;
        reg poly=1'b0;
        always @(posedge clk)  //这里一定要在rst信号来的时候处于时钟上升沿，要不然没法赋初值
                if (rst)
                   begin
                           pn_reg &amp;lt;= reg_state;
                                pncode &amp;lt;= 1'b0;
                        end
                else
                   begin
                                //第１位寄存器的值为根据多项式异或运算后的值
                                pn_reg[0] &amp;lt;= poly;
                           //最末位寄存器的值输出为pn码
                           pncode &amp;lt;= pn_reg[Len-1];
                                //pn_reg中的内容左移１位，左高位右低位
                           for (i=0; i&amp;lt;=(Len-2); i=i+1)
                                        pn_reg[i+1] &amp;lt;= pn_reg[i];
                        end
                        
        integer j; ///用reg
        
        //根据多项式的值产生组合逻辑电路
   always @(*)              /// 用posedage???
                for (j=(Len-1); j&amp;gt;=0; j=j-1)
                   begin
                           if (j==(Len-1))
                              poly = pn_reg[j];
                      else if (polynomial[j+1])
                              poly = poly ^ pn_reg[j];
                   end
                        
   assign pn = pncode;
endmodule

&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;24-差分模块&quot;&gt;2.4 差分模块&lt;/h3&gt;
&lt;p&gt;这里的差分不是指把信号源取反的差分，而是指把信号源看作绝对码，给定一个初始值然后输出相对码的过程。形象的波形变化见最开始的那个DPSK流程图。由于取了信号源的差分，所以在调制的时候相当于用载波相位的变化来承载信号，非相干解调时只需要把载波作个延时，然后与未延时的载波相乘，就可以得到解调信号了。所以这个模块我们输出信号源的差分码即可。&lt;/p&gt;
&lt;h4 id=&quot;241-代码实现&quot;&gt;2.4.1 代码实现&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;module difcode (
clk,rst,pn,difpn);

input clk;   //与pn同频率100khz
input rst;
input pn;
output difpn;

reg difpn1;

always @(posedge clk or posedge rst) 
        if(rst) difpn1 &amp;lt;= 1'b0;
        else
                begin
                        if((pn == 0) &amp;amp;&amp;amp; (difpn1 == 0))
                                difpn1 &amp;lt;= 0;
                        else if((pn == 0) &amp;amp;&amp;amp; (difpn1 == 1))
                                difpn1 &amp;lt;= 1;
                        else if((pn == 1) &amp;amp;&amp;amp; (difpn1 == 0))
                                difpn1 &amp;lt;= 1;
                        else if((pn == 1) &amp;amp;&amp;amp; (difpn1 == 1))
                                difpn1 &amp;lt;= 0;
                end
        assign difpn = difpn1;
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;25-数据选择模块&quot;&gt;2.5 数据选择模块&lt;/h3&gt;
&lt;p&gt;这个其实都不能算作是一个模块，因为太简单了，就做一个开关，当上面数据源为1时，输出相位为0的正弦载波；当数据源为0时，输出相位为&lt;span class=&quot;math inline&quot;&gt;\(\pi\)&lt;/span&gt;的正弦载波。但为什么又把它作为一个模块呢？因为其实这就是信号的相位调制部分啊！不用考虑其他复杂的处理的话，输出的信号就能够发射出去经过信道，然后被接收了。&lt;/p&gt;
&lt;h4 id=&quot;251-代码实现&quot;&gt;2.5.1 代码实现&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;module data_sel (
clk,difpn,sine1,sine2,sine_mod);

input clk;
input difpn;
input [13:0]sine1;
input [13:0]sine2;
output [13:0]sine_mod;
reg [13:0]sine_mod1;

always @(posedge clk)
        if(difpn == 1)
                sine_mod1 &amp;lt;= sine1;
        else
                sine_mod1 &amp;lt;= sine2;

        assign sine_mod = sine_mod1;
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;26-延时与相乘模块&quot;&gt;2.6 延时与相乘模块&lt;/h3&gt;
&lt;p&gt;延时与相乘模块已经算是DPSK的解调部分了，DPSK系统的好处就是它解调简单，如最开始波形图所示，只需要把接收到的载波信号与延时一个码元长度的载波信号相乘，再经过低通滤波器的处理就可以恢复源信号了&lt;/p&gt;
&lt;p&gt;关于延时的部分，我们只需要延时一个PN码码元长度即可，即100Khz时钟的一个周期长度。本设计采用的是先将差分码延时，再利用相位选择法调制的方式，而不是先调制再延时。其中延时部分可以根据PN码的生成时钟来设计，因为PN码的每一个码都是在时钟上升沿产生的，所以在100KHz的分频时钟下降沿到达时，将此时的信号存储起来，置于寄存器中，在下一个分频时钟信号上升沿到达时输出存储的信号，便得到了延时一个码元长度的PN码。经过数据选择器后，相应的输出波形也延时相同长度。&lt;/p&gt;
&lt;p&gt;关于相乘的部分，这里用的是相乘器IP核LPM_MULT，具体参数配置如下图：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048856/202012/2048856-20201214222718810-1281137895.png&quot; width=&quot;480&quot; height=&quot;350&quot; alt=&quot;&quot; align=&quot;center&quot;/&gt;&lt;p&gt;只用设置输出位宽就OK了，生成的IP核接口代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module mult18 (
        dataa,
        datab,
        result);

        input   [13:0]  dataa;
        input   [13:0]  datab;
        output  [27:0]  result;

        wire [27:0] sub_wire0;
        wire [27:0] result = sub_wire0[27:0];

        lpm_mult        lpm_mult_component (
                                .dataa (dataa),
                                .datab (datab),
                                .result (sub_wire0),
                                .aclr (1'b0),
                                .clken (1'b1),
                                .clock (1'b0),
                                .sum (1'b0));
        defparam
                lpm_mult_component.lpm_hint = &quot;MAXIMIZE_SPEED=5&quot;,
                lpm_mult_component.lpm_representation = &quot;SIGNED&quot;,
                lpm_mult_component.lpm_type = &quot;LPM_MULT&quot;,
                lpm_mult_component.lpm_widtha = 14,
                lpm_mult_component.lpm_widthb = 14,
                lpm_mult_component.lpm_widthp = 28;


endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;27-低通滤波器模块&quot;&gt;2.7 低通滤波器模块&lt;/h3&gt;
&lt;p&gt;在进行最终的信号判决恢复之前，我们还需要对解调信号进行低通滤波。从最前面的信号波形处理流程图可以看出，经过相乘模块之后的信号从‘上下上下’这种正弦型振荡变成了‘上上下下’这种类似全波整流的振荡信号，但这还不足以让我们恢复原始的PN码信号源，于是使用低通滤波器滤去高频，使得信号更平滑、正和负区分的更为明显一些。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048856/202012/2048856-20201214223840158-65788476.png&quot; width=&quot;480&quot; height=&quot;350&quot; alt=&quot;&quot; align=&quot;center&quot;/&gt;&lt;p&gt;这里我们还是使用IP核模块FIR Compiler来设计低通滤波器，对于低通滤波器核的设计分为以下四步：&lt;/p&gt;
&lt;p&gt;第一步：在工程文件中新建一个FIR Compiler v13.0核。之后进入一个新的参数设置界面，具体界面如下图所示。&lt;/p&gt;
&lt;p&gt;第二步：设置FIR核参数。设置低通滤波器系数位宽为12比特；滤波器实现结构选择多时钟周期结构（Multi-Cycle），不同的结构所需要的内部资源不同，运算速率也不同；根据前面乘法器输出模块数据的位宽，确定滤波器输入位宽为28bit，然后FIR核会自动计算出滤波器输出数据位宽为45bit。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048856/202012/2048856-20201214224924870-1612479497.png&quot; width=&quot;480&quot; height=&quot;350&quot; alt=&quot;&quot; align=&quot;center&quot;/&gt;&lt;p&gt;第三步：设置滤波器参数。进入Edit Coefficient Set界面。选择低通滤波器类型，目的是滤去解调输出的高频信号，恢复基带信号；在滤波器采样频率方面，由于在正弦载波生成模块使用的输入时钟信号为10MHz，于是对数据进行采样输入滤波器中时，也设置相同的频率10MHz；选择矩形窗口类型。在滤波器截止频率设置过程中，考虑基带PN码生成时钟频率为100KHz，所以滤波器截止频率设置为50KHz。这样滤波后能正确地恢复原信号。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048856/202012/2048856-20201214224934643-411200608.png&quot; width=&quot;480&quot; height=&quot;350&quot; alt=&quot;&quot; align=&quot;center&quot;/&gt;&lt;p&gt;最终生成FIR滤波器IP核接口，下面是自己又写了个小模块来使用这个接口的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module fir_mod(
clk,reset_n,sine_demod1,sine_demod2);
        
        input clk,reset_n;
        input signed [27:0] sine_demod1;
        output signed [44:0] sine_demod2;
        
        wire    sink_valid, ast_source_ready, ast_source_valid;
        wire    [1:0]   ast_sink_error;
        wire    [1:0]   ast_source_error;

        assign ast_source_ready = 1'b1;
        assign ast_sink_error = 2'd0;
                
        //reg count;  //1clk
        reg  ast_sink_valid;
        always @(posedge clk or negedge reset_n)
           if (!reset_n)
                        ast_sink_valid &amp;lt;= 1'b0;
                else 
                        ast_sink_valid &amp;lt;= 1'b1; //每个时钟信号都有1个输入信号，所以ast_sink_valid一直为1，否则应该有时候为0的
                
        assign  sink_valid = ast_sink_valid;
                
        fir_lpf a1( //例化IP核接口
                .clk(clk),
                .reset_n(reset_n),
                .ast_sink_data(sine_demod1),
                .ast_sink_valid(sink_valid),
                .ast_source_ready(ast_source_ready),  ////111
                .ast_sink_error(ast_sink_error),
                .ast_source_data(sine_demod2),
                .ast_sink_ready(ast_sink_ready),  ////////1111
                .ast_source_valid(ast_source_valid),
                .ast_source_error(ast_source_error));
                
        endmodule       

&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三：testbench文件&quot;&gt;三：TestBench文件&lt;/h2&gt;
&lt;p&gt;顶层代码模块和各个子模块写完了，接下来在软件仿真前需要写一个testbench文件来支持软件仿真，其实也就是例化一下顶层模块，然后&lt;s&gt;看你心情给输入参数谁便赋个值&lt;/s&gt;，赋值的时候一定要注意时钟和复位信号要与顶层模块计划的值的大小相匹配，输入用reg，输出用wire。&lt;span&gt;还有在setting里一定要弄好仿真的相关设置！&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;`timescale 1ps / 1ps

module test_tb();
reg rst1;
reg clk;
wire led1;

DPSK_system u0(
.rst1(rst1),
.clk(clk),
.led1(led1));

parameter PERIOD = 20; // 设置系统时钟为50Mhz

always #20 clk = ~clk; 

initial begin 
clk = 1'b0; #40;
rst1 = 1'b0; #40; 
rst1 = 1'b1; 
end

endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;四：软件仿真查看波形&quot;&gt;四：软件仿真查看波形&lt;/h2&gt;
&lt;p&gt;顶层代码和各个模块写完了，接下来进行Modelsim软件仿真，下面放一个DPSK系统调制解调波形的全家福，可以对比开头画的那个波形流程图看，完美的实现了。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048856/202012/2048856-20201214233657515-1371234348.png&quot; width=&quot;880&quot; height=&quot;450&quot; alt=&quot;&quot; align=&quot;center&quot;/&gt;&lt;hr/&gt;&lt;h2 id=&quot;五：顶层模块代码&quot;&gt;五：顶层模块代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;module DPSK_system (
        rst1,clk,led1);
        
        input rst1;                        // 复位信号，高电平有效
        input clk;                                              // FPGA系统时钟:50MHz
        output led1;                                            //亮个灯玩玩
        
        wire reset_n,out_valid1,out_valid2,clken;
        wire [31:0] phi_inc_i1;         // 相位增益，生成特定频率正弦信号用
        wire [31:0] phi_inc_i2;         // 相位增益，生成特定频率正弦信号用
        wire [13:0]phase_mod_i1;        // 相位调整，改变正弦信号相位用
        wire [13:0]phase_mod_i2;        // 相位调整，改变正弦信号相位用
        wire [13:0]sine1;               //产生的0相位正弦载波信号
        wire [13:0]sine2;               //产生的π相位正弦载波信号
        wire rst;
        wire clk10m;                                    //产生一个10Mhz时钟分频信号，用于正弦信号用
        wire clk100k;                                   //产生一个100khz时钟分频信号,用作pn码周期
        wire pn;                                        //pn码作为信号源
        wire difpn;                             //差分变换后的pn码
        wire difpn_dey;                         //整体延迟一个周期的差分pn码，为了差分解调
        reg difpn_dey_reg;
        reg difpn_dey_reg1 = 0;
        wire [13:0]sine_mod;                        //DPSK已调信号波形
        wire [13:0]sine_mod_dey;            //DPSK已调波形整体延迟一个周期，为了差分解调
        wire [27:0]sine_demod1;                  //相干（相乘）解调后的DPSK解调信号
        wire [44:0]sine_demod2;                  // 解调信号经过低通滤波器后的信号
        wire sine_recover;                               //最终判决后的恢复信号（其实也没有判决的步骤）
                
        assign rst = !rst1;
        assign reset_n = !rst;
        assign clken = 1'b1;
        assign phi_inc_i1 = 32'd42949673;       //sine1相位增益，输出100khz
        assign phi_inc_i2 = 32'd42949673;       //sine2相位增益，输出100khz
        assign phase_mod_i1 = 14'b10_0110_0000_1010;                                    //sine1相位调整，输出0相位
        assign phase_mod_i2 = phase_mod_i1 + 14'b10_0000_0000_0000; // sine2相位调整，输出Π相位
        assign led1 = ~out_valid1;
        
        divide #(.WIDTH(3),.N(5)) u1 (          //分频器模块,产生一个10mHz（一个周期）时钟分频信号,正弦信号生成用               
                .clk(clk),
                .rst_n(reset_n),                 
                .clkout(clk10m));  
        
        divide #(.WIDTH(7),.N(100)) u1_1 (  //分频器模块,产生一个100kHz（一个周期）时钟分频信号,PN码生成用                   
                .clk(clk10m),
                .rst_n(reset_n),                 
                .clkout(clk100k));  
        
        sine_ip u2 (                            //实例化nco ip核模块，生成100khz，0相位正弦信号
                .phi_inc_i (phi_inc_i1),                          //输入相位增益信号，由时钟频率和输出频率计算得到
                .clk (clk10m),
                .reset_n (reset_n),
                .clken (clken),                                           //时钟使能信号              
                .phase_mod_i(phase_mod_i1),
                .fsin_o (sine1),                                                  //输出正弦波sine1
                .out_valid (out_valid1));                         //正弦波输出有效信号
                
        sine_ip2        u2_1(
                .phi_inc_i(phi_inc_i2),                         //实例化nco ip核模块，生成100khz，Π相位正弦信号
                .clk(clk10m),                                                     //输入相位增益信号，由时钟频率和输出频率计算得到
                .reset_n(reset_n),
                .clken(clken),                                                    //时钟使能信号
                .phase_mod_i(phase_mod_i2),
                .fsin_o(sine2),                                           //输出正弦波sine2
                .out_valid(out_valid2));                          //正弦波输出有效信号
                        
        PnCode u3(                                                              //pn码生成模块，5阶本原多项式
                .rst(rst),
                .clk(clk100k),
                .pn(pn));                                                 //输出pn码

        difcode u4(                                                     //pn码 --&amp;gt; 差分pn码模块
                .clk(clk100k),
                .rst(rst),
                .pn(pn),                                                          //输入pn码
                .difpn(difpn));                                           //输出差分码
                                
        data_sel u5(                                                            //相位选择法调制模块
                .clk(clk10m),
                .difpn(difpn),                                                    //输入差分码
                .sine1(sine1),                                                    //输入0相位正弦载波
                .sine2(sine2),                                                    //输入Π相位正弦载波
                .sine_mod(sine_mod));                             //输出已调信号
        
        always@(negedge clk100k)
                difpn_dey_reg = difpn;
                
        always@(posedge clk100k)
                difpn_dey_reg1 = difpn_dey_reg;

        assign difpn_dey = difpn_dey_reg1;
                        
        data_sel u6(                                            //相位选择法调制模块
                .clk(clk10m),
                .difpn(difpn_dey),                                        //输入延迟一个码元过后的差分码
                .sine1(sine1),
                .sine2(sine2),
                .sine_mod(sine_mod_dey));                         //输出延迟一个码元过后的已调信号
                
        mult18  u7 (                                                    //实例化相乘器ip核模块，差分解调部分
                .dataa (sine_mod),
                .datab (sine_mod_dey),
                .result (sine_demod1));                           //输出差分解调后的解调信号
                
                
        fir_mod u8(                                             //实例化低通滤波器ip核模块
                .clk(clk10m),
                .reset_n(reset_n),
                .sine_demod1(sine_demod1),                //输入解调信号
                .sine_demod2(sine_demod2));               //输出滤波后信号
        
        assign sine_recover = sine_demod2[44];//最高位符号位为恢复信号（为了简单） 
        
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;六：参考文献&quot;&gt;六：参考文献&lt;/h2&gt;
&lt;p&gt;[1] 杜勇. 数字调制解调技术的MATLAB与FPGA实现[M]. Altera/Verilog版. 北京：电子工业出版社，2015.&lt;/p&gt;
&lt;p&gt;[2] 樊昌信，曹丽娜. 通信原理[M]. 第六版. 北京：国防工业出版社，2006.&lt;/p&gt;
</description>
<pubDate>Mon, 14 Dec 2020 16:05:00 +0000</pubDate>
<dc:creator>羽扇纶巾o0</dc:creator>
<og:description>之前接触过一些FPGA的相关知识，借着实现一个简单的DPSK系统，顺便复习和记录一下Verilog HDL的简单使用方法。准备直接用一张图展现DPSK的调制解调原理，再按照模块介绍Verilog的实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gjblog/p/14136351.html</dc:identifier>
</item>
<item>
<title>[python学习手册-笔记]004.动态类型 - 不愿透露姓名的高杨</title>
<link>http://www.cnblogs.com/thecatcher/p/14136331.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thecatcher/p/14136331.html</guid>
<description>&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本系列文章是我个人学习《python学习手册（第五版）》的学习笔记，其中大部分内容为该书的总结和个人理解，小部分内容为相关知识点的扩展。&lt;/p&gt;
&lt;p&gt;非商业用途转载请注明作者和出处；商业用途请联系本人（gaoyang1019@hotmail.com）获取许可。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;基础概念的解释&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来解释一些基础概念，看不懂的可以跳过，这对于初学者不是很重要。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;强类型语言和弱类型语言&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，强弱类型语言的区分不是看变量声明的时候是否显式的定义数据类型。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;强类型语言，定义是任何变量在使用的时候必须要指定这个变量的类型，而且在程序的运行过程中这个变量只能存储这个类型的数据。因此，对于强类型语言，一个变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换。比如java，python都属于强类型语言。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;强类型语言在编译的时候，就可以检查出类型错误，避免一些不可预知的错误，使得程序更加安全。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与之对应的是弱类型语言，在变量使用的时候，不严格的检查数据类型，比如vbScript，数字12和字符串3进行连接，可以直接得到123。再比如C语言中&lt;code&gt;int i = 0.0&lt;/code&gt;是可以通过编译的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外知乎上关于&lt;a href=&quot;https://www.zhihu.com/question/19918532&quot;&gt;相关问题&lt;/a&gt; &lt;a href=&quot;https://www.zhihu.com/people/rainoftime&quot;&gt;rainoftime&lt;/a&gt; 大神也有相关解答，没有查到权威解释，对大神的解答存疑，但是可以参考，帮助我们理解。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;动态类型语言和静态类型语言&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动态类型和静态类型的区别主要在数据类型检查的阶段。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动态类型语言：运行期间才去做数据类型的检查。在动态类型语言中，不需要给变量显式的指明其数据类型，该语言会在第一次赋值的时候，将内部的数据类型记录下来。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态类型语言，在编译阶段就进行数据类型检查。也就是说静态类型语言，在定义变量的时候，必须声明数据类型。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个比较经典的图：&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20201206195520.png&quot; alt=&quot;各类语言的定义&quot;/&gt;各类语言的定义
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;堆和栈&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，堆儿（不好意思，这里不应该带儿化音...）,堆（heap）和栈（stack）的概念在不同范畴是有不同含义的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据结构中，堆指的是满足父子节点满足大小关系的一种完全二叉树。栈指的是满足后进先出（LIFO），支持pop和push两种操作的一个“桶”（本来想说序列，但是不知道准不准确，所以说了个桶...）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在操作系统中，堆儿和栈指的是内存空间。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;栈，和数据结构中的栈差不多，是一个LIFO队列，由编译器自动分配和释放，主要用来存放函数的参数值，局部变量的值等内容。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆，一般由程序员分配和释放，当然，像java和python这类语言也有自动垃圾回收的机制。这个我们在后面会讲到。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于堆儿和栈的详细解释可以参考 &lt;a href=&quot;https://gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html&quot;&gt;Memory : Stack vs Heap&lt;/a&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;变量、对象和引用&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;python中的变量声明是不需要显式的指定类型的，但这并不表明python是一个弱类型语言。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们的一条简单的赋值语句&lt;code&gt;a=3&lt;/code&gt;，那么接下来python编译器会做哪些事情呢？&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;创建变量和字面量：
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;创建一个字面量3（如果这个字面量还没有被创建过的情况下）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;创建一个名称叫a的变量。一般我们理解在这个变量a第一次被赋值的时候就创建了它。（实际python解释器在运行代码之前就会检测变量名）&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;检查变量类型：
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;python中类型是针对对象而言的，并不是针对变量名而言的。 对象会包含两个重要的头部信息，一个是类型标志符，一个是引用计数器。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;变量名并不会限制变量的类型。也就是说这个&lt;code&gt;a&lt;/code&gt; 它只是一个名字，具体“关联”什么类型的变量，这个是没有限制的。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;变量的使用
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;当变量出现在表达式中的时候，它就会被当前引用的对象所代替。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;还是说这个例子，如果在之后的代码中使用了a，比如&lt;code&gt;a+1&lt;/code&gt;那么这里的a就会被指向3这个字面量&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单总结，当我们执行&lt;code&gt;a=3&lt;/code&gt;的时候，实际做了三件事：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;创建一个对象实例，3&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;创建一个变量，a&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;将变量名a引用到对象实例3上&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20201214204038.png&quot; alt=&quot;image-20201214204037907&quot;/&gt;image-20201214204037907
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里提到了一个概念，引用。 引用其实就是一种关系，是通过内存中的指针所实现的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好嘞，这里又出现了一个新的概念，指针。 指针这个东西，简单来说可以理解为内存地址的一个指向。就是对初学者不好解释（主要是我懒得解释，就是属于那种懂的不需要讲，不懂的一时半会讲了也是不懂，但是随着学习的深入，慢慢就理解了的东西。。。）&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;变量的类型&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，python是一个强类型语言，这是毫无疑问的。 但是python不需要显式的声明变量类型。 这是因为python的类型是记录在对象实例中的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面我们讲到过，python中的对象会包含两个重要的头部信息：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;类型标志符（type designator）:用来标识这个对象的类型&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;引用计数器（reference counter）: 表明有多少个变量引用到了这个对象上，用于跟踪改对象应该何时被回收&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为对象的这个机制，python中的变量声明的时候，就不需要再指定类型了。 也就是说变量名与变量类型是无关的。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;a=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;a=&lt;span class=&quot;hljs-string&quot;&gt;'spam'&lt;/span&gt;&lt;br/&gt;a=&lt;span class=&quot;hljs-number&quot;&gt;1.123&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且如上所示，同一个变量名可以赋值给不同类型的对象实例。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;共享引用&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里提出一个问题，如下代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;]: a=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;&lt;br/&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;]: b=a&lt;br/&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;]: a=&lt;span class=&quot;hljs-string&quot;&gt;'spam'&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在经过这一系列操作之后，a和b的值分别是啥？&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;]: a&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;]: &lt;span class=&quot;hljs-string&quot;&gt;'spam'&lt;/span&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;]: b&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;]: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来看，在执行&lt;code&gt;a=3&lt;/code&gt;和&lt;code&gt;b=a&lt;/code&gt;之后，发生了什么&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20201214210333.png&quot; alt=&quot;image-20201214210333750&quot;/&gt;image-20201214210333750
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;a=3&lt;/code&gt;根据之前的介绍，比较好理解了。&lt;code&gt;b=a&lt;/code&gt;实际上变量名b只是复制了a的引用，然后b也引用到了对象实例3上。那在之后这一句&lt;code&gt;a='spam'&lt;/code&gt;又发生了什么？&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20201214210854.png&quot; alt=&quot;image-20201214210854202&quot;/&gt;image-20201214210854202
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个图就说的很清楚了，在我们执行了&lt;code&gt;a='spam'&lt;/code&gt;之后，a被指向了另外一个对象。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搞清楚了这个之后，我们再来看下一个例子：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;a=&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;&lt;br/&gt;b=a&lt;br/&gt;a=a+&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个前两句就不需要解释了，第三句&lt;code&gt;a=a+3&lt;/code&gt; 其实一眼就可以看出来，此时a是6。这个就涉及到前面说的，当a出现在表达式中的时候，它就会“变成”它所引用的对象实例。&lt;code&gt;a=a+3&lt;/code&gt;也就是会变成&lt;code&gt;3+3&lt;/code&gt; 计算后得出新的对象实例6，然后变量a引用到6这个对象上。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;在原位置修改&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于共享引用，这里看一个特殊的例子：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;8&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;]: L1=[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;]: L2=L1&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;18&lt;/span&gt;]: L1[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;1111&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;]: L1&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;]: [&lt;span class=&quot;hljs-number&quot;&gt;1111&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;]: L2&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;]: [&lt;span class=&quot;hljs-number&quot;&gt;1111&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照之前的剧本，L2和L1都是指向列表&lt;code&gt;[1,2,3]&lt;/code&gt;这个对象的，那为什么在我们修改&lt;code&gt;L1[0]&lt;/code&gt; 这个元素之后，为什么L2也跟着发生变化了呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我自己画了图，从这个图可以看出来，实际上对于L1和L2的共享引用来看，并没有违反我们上面说的共享引用的原则。只是对于序列中元素的修改，&lt;code&gt;L1[0]&lt;/code&gt;会在原位置覆盖列表对象中的某部分值。&lt;/p&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20201214212941.png&quot; alt=&quot;image-20201214212940939&quot;/&gt;image-20201214212940939
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了如果在修改L1[0]之后，并不想L2的值受到影响，那该怎么办？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把列表原原本本的复制一份就好了。 复制的办法有三种：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种针对列表而言，可以直接创建一个完整的切片，本质上是一种浅拷贝。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;13.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;21&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt;]: L1=[[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;],&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;]&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;33&lt;/span&gt;]: L2=L1[:]&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;34&lt;/span&gt;]: L2&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;34&lt;/span&gt;]: [[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;]&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;37&lt;/span&gt;]: L1[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]=&lt;span class=&quot;hljs-string&quot;&gt;'aaa'&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;38&lt;/span&gt;]: L2&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;38&lt;/span&gt;]: [[&lt;span class=&quot;hljs-number&quot;&gt;1111&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;]&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;39&lt;/span&gt;]: L1&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;39&lt;/span&gt;]: [[&lt;span class=&quot;hljs-number&quot;&gt;1111&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'aaa'&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;]&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种，浅拷贝，如下面这个例子中的&lt;code&gt;D1.copy()&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;10&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;]: D1={a:[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;],b:&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;}&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;27&lt;/span&gt;]: &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; copy&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;28&lt;/span&gt;]: D2=D1.copy()&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;29&lt;/span&gt;]: D2&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;29&lt;/span&gt;]: {&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;: [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;}&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;]: D1[a][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;1111&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;]: D2&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;31&lt;/span&gt;]: {&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;: [&lt;span class=&quot;hljs-number&quot;&gt;1111&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三种，深拷贝，如下&lt;code&gt;D2=copy.deepcopy(D1)&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;16.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;27&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;41&lt;/span&gt;]: &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; copy&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt;]: D1={&lt;span class=&quot;hljs-string&quot;&gt;'A'&lt;/span&gt;:[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;],&lt;span class=&quot;hljs-string&quot;&gt;'B'&lt;/span&gt;:&lt;span class=&quot;hljs-string&quot;&gt;'spam'&lt;/span&gt;}&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt;]: D1&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt;]: {&lt;span class=&quot;hljs-string&quot;&gt;'A'&lt;/span&gt;: [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;'B'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'spam'&lt;/span&gt;}&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;47&lt;/span&gt;]: D2=copy.deepcopy(D1)&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt;]: D2&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;48&lt;/span&gt;]: {&lt;span class=&quot;hljs-string&quot;&gt;'A'&lt;/span&gt;: [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;'B'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'spam'&lt;/span&gt;}&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;49&lt;/span&gt;]: D1[&lt;span class=&quot;hljs-string&quot;&gt;'A'&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;hljs-number&quot;&gt;1111&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;]: D1&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;]: {&lt;span class=&quot;hljs-string&quot;&gt;'A'&lt;/span&gt;: [&lt;span class=&quot;hljs-number&quot;&gt;1111&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;'B'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'spam'&lt;/span&gt;}&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;51&lt;/span&gt;]: D2&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;51&lt;/span&gt;]: {&lt;span class=&quot;hljs-string&quot;&gt;'A'&lt;/span&gt;: [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;hljs-string&quot;&gt;'B'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'spam'&lt;/span&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信，看到这里，对于深拷贝和浅拷贝有些读者已经明白了，但是有些读者还是迷糊的。 这里简单说一下，&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;浅拷贝：只拷贝父对象，不会拷贝对象内部的子对象。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;section readability=&quot;2&quot;&gt;&lt;p&gt;深拷贝：完全拷贝父对象和子对象。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20201214215612.png&quot; alt=&quot;浅拷贝&quot;/&gt;浅拷贝 &lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20201214215632.png&quot; alt=&quot;深拷贝&quot;/&gt;深拷贝
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更详细的内容见： &lt;a href=&quot;https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html&quot;&gt;Python 直接赋值、浅拷贝和深度拷贝解析&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;关于相等&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看一个例子&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;4&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;59&lt;/span&gt;]: L1=[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;60&lt;/span&gt;]: L2=L1&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;61&lt;/span&gt;]: L1==L2&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;61&lt;/span&gt;]: &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;62&lt;/span&gt;]: L1 &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; L2&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;62&lt;/span&gt;]: &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;4&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;66&lt;/span&gt;]: L1=[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;67&lt;/span&gt;]: L2=[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;68&lt;/span&gt;]: L1==L2&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;68&lt;/span&gt;]: &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;69&lt;/span&gt;]: L1 &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; L2&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;69&lt;/span&gt;]: &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面这个例子就可以看出来，&lt;code&gt;==&lt;/code&gt;比较的是值，&lt;code&gt;is&lt;/code&gt; 实际比较的是实现引用的指针。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;对象的垃圾收集和弱引用&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垃圾回收机制也是一件很复杂的事情，但是python编译器可以自己去处理这玩意儿。 所以在初级阶段，我们不需要过多关注这玩意儿。 知道有这么个东西就够了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里简单的介绍下，python中的垃圾回收就是我们所谓的GC，靠的是对象的引用计数器。引用计数器为0的时候，这个对象实例就会被释放。对象的引用计数器可以通过&lt;code&gt;sys.getrefcount(istance)&lt;/code&gt;来查看。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;70&lt;/span&gt;]: &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; sys&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;72&lt;/span&gt;]: sys.getrefcount(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;72&lt;/span&gt;]: &lt;span class=&quot;hljs-number&quot;&gt;2719&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用计数器的引入可以很好的跟踪对象的使用情况，但是在某些情况下，也可能会带来问题。 比如循环引用的问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;73&lt;/span&gt;]: L =[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;74&lt;/span&gt;]: L.append(L)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，正常人肯定不会写出这种智障代码，但是在一些复杂的数据结构中，子对象互相引用，就可能会造成死锁。比如：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]: &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Node&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;...:   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;...:     self.parent=&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;&lt;br/&gt;...:     self.child=&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;&lt;br/&gt;...:   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add_child&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,child)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;...:     self.child=child&lt;br/&gt;...:     child.parent=self&lt;br/&gt;...:   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__del__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;...:     print(&lt;span class=&quot;hljs-string&quot;&gt;'deleted'&lt;/span&gt;)&lt;br/&gt;...:&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们定义了一个简单的类。这时，如果我们创建一个节点，然后删除它，可以看到，对象被回收，并且准确的打印出了deleted。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]: a=Node()&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]: &lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt; a&lt;br/&gt;deleted&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，像下面这个例子，在删除a节点之后，貌似没有触发垃圾回收，只有手动的gc之后，这两个对象实例才被删除。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在删除a之后，没有触发垃圾回收，是因为它俩互相引用，实例的引用计数器并没有置0 。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那在手动gc之后，由于python的gc会检测这种循环引用，并删除它。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;4&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]: a=Node()&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;]: a.add_child(Node())&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;]: &lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt; a&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;]: &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; gc&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;]: gc.collect()&lt;br/&gt;deleted&lt;br/&gt;deleted&lt;br/&gt;Out[&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;]: &lt;span class=&quot;hljs-number&quot;&gt;356&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://wmcoding.oss-cn-hangzhou.aliyuncs.com/wmcoding/20201214230754.png&quot; alt=&quot;A和B的关系&quot;/&gt;A和B的关系
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如果使用弱引用的话，效果就不一样了&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;4&quot;&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;]: &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; weakref&lt;br/&gt;...:&lt;br/&gt;...: &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Node&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;...:   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;...:     self.parent=&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;&lt;br/&gt;...:     self.child=&lt;span class=&quot;hljs-literal&quot;&gt;None&lt;/span&gt;&lt;br/&gt;...:   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;add_child&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,child)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;...:     self.child=child&lt;br/&gt;...:     child.parent=weakref.ref(self)&lt;br/&gt;...:   &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__del__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;...:     print(&lt;span class=&quot;hljs-string&quot;&gt;'deleted'&lt;/span&gt;)&lt;br/&gt;...:&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;]: a=Node()&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;]: a.add_child(Node())&lt;/p&gt;&lt;p&gt;In [&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;]: &lt;span class=&quot;hljs-keyword&quot;&gt;del&lt;/span&gt; a&lt;br/&gt;deleted&lt;br/&gt;deleted&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这里就可以看出来，所谓弱引用，其实并没有增加对象的引用计数器，即使弱引用存在，垃圾回收器也会当做没看见。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;弱引用一般可以拿来做缓存使用，对象存在时可用，对象不存在的时候返回None。这正符合缓存有则使用，无则重新获取的性质。&lt;/p&gt;
</description>
<pubDate>Mon, 14 Dec 2020 15:23:00 +0000</pubDate>
<dc:creator>不愿透露姓名的高杨</dc:creator>
<og:description>004.动态类型 ❝ 本系列文章是我个人学习《python学习手册（第五版）》的学习笔记，其中大部分内容为该书的总结和个人理解，小部分内容为相关知识点的扩展。 非商业用途转载请注明作者和出处；商业用途</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/thecatcher/p/14136331.html</dc:identifier>
</item>
<item>
<title>Apache（httpd）详解 - Praywu</title>
<link>http://www.cnblogs.com/hgzero/p/14136149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hgzero/p/14136149.html</guid>
<description>&lt;p class=&quot;has-text-align-center&quot;&gt;&lt;strong&gt;思维导图&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;1. httpd服务&lt;/h2&gt;
&lt;h3&gt;1.1 httpd概述&lt;/h3&gt;
&lt;p&gt;ASF（Apache Software Foundation）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）服务器的类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;http服务器（httpd，nginx，Lighttpd）&lt;/li&gt;
&lt;li&gt;应用程序服务器（IIS：.NET  ，tomcat：.JSP）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）httpd的特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;高度模块化（Core+modules）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DSO机制（Dynamic Shared Object ，动态共享对象）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MPM（Multipath Procession Modules，多路处理模块）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以通过修改MPM来修改并发响应模型&lt;/li&gt;
&lt;li&gt;2.4支持MPM模块动态切换，2.2不支持&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3）httpd的并发响应模型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;prefork&lt;/span&gt;：两级进程模型，父进程管理子进程，每个进程响应一个请求&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 工作模型&lt;/span&gt;
&lt;span&gt;一个主进程：
    负责生成子进程及回收子进程
    负责创建套接字、接受请求，并将其派发给某子进程进行处理
n个子进程：
    每个子进程处理一个请求

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意：&lt;/span&gt;
&lt;span&gt;会预先生成几个空闲进程，随时等待用于响应用户请求
最大空闲和最小空闲&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;worker&lt;/span&gt;：三级进程模型，父进程管理子进程，子进程通过线程响应用户请求，每个线程处理一个用户请求&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 工作模型&lt;/span&gt;
&lt;span&gt;一个主进程：
　　负责生成子进程、创建套接字、接受请求，并将其派发给某子进程进行处理
多个子进程：
　　每个子进程负责生成多个线程
每个线程：
　　负责响应用户请求

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 并发响应数量：&lt;/span&gt;
子进程数 * 每个子进程能创建的最大线程数
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;event&lt;/span&gt;：两级模型，父进程管理子进程，子进程通过事件驱动event-driven机制直接响应n个请求&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 工作模型：&lt;/span&gt;
&lt;span&gt;一个主进程：
    负责生成子进程、创建套接字、接受请求，并将其派发给某子进程进行处理
子进程：
    基于事件驱动机制直接响应多个请求

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; httpd-2.4中的event机制可以在生产环境中使用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2 httpd的程序结构&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;httpd2.2（CentOS6中）&lt;/li&gt;
&lt;li&gt;httpd2.4（CentOS7及以上）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202008/1278240-20200822191619738-1665890061.png&quot; alt=&quot;&quot; width=&quot;770&quot; height=&quot;545&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3. httpd的主配置文件&lt;/h2&gt;
&lt;h3&gt;3.1 配置文件结构和格式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）整体结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全局环境配置（Global Environment）：对进程自己的工作特点，对所有虚拟主机都通用的设定&lt;/p&gt;
&lt;p&gt;主服务器配置段（“Main” server configuration）：在2.2上如果要使用主服务器，则要将虚拟主机关掉&lt;/p&gt;
&lt;p&gt;虚拟主机（Virtual Hosts）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）配置格式：directive value&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;directive，不区分字符大小写&lt;/li&gt;
&lt;li&gt;value，为路径时，是否区分字符大小写，取决于文件系统&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3.2 &lt;strong&gt;监听的IP和PORT&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 格式：&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;Listen  [IP:]Port  [protocol]
    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 若省略IP则表示0.0.0.0&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Listen指令可以重复出现多次&lt;/span&gt;
        Listen 80&lt;span&gt;
        Listen &lt;/span&gt;8080        

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意：&lt;/span&gt;
&lt;span&gt;修改监听的套接字，重启服务进程才能生效
&lt;strong&gt;限制其必须通过ssl通信时，protocol需要定义为https&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;3.3 用户和用户组&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 作用：&lt;/span&gt;
&lt;span&gt;指定以哪个用户的身份运行httpd服务器进程
    
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 格式：&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;User apache
Group apache
    
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对主控进程是root用户的说明：&lt;/span&gt;
&lt;span&gt;&lt;strong&gt;主控进程是root，因为80端口是特权端口（小于1024的端口），只有管理员才能使用&lt;/strong&gt;
&lt;strong&gt;所以主控进程是root，而其他的进程使用普通用户权限&lt;/strong&gt;
        
SUexec在某些指令执行时可以切换到另外一个用户（默认没有装载）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;3.4 默认字符集&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置默认字符集&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 格式&lt;/span&gt;
&lt;strong&gt;AddDefaultCharset   UTF-8&lt;/strong&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 中文字符集：&lt;/span&gt;
GBK、GB2312、GB18030
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;3.5 站点主页面&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 格式：&lt;/span&gt;
&lt;strong&gt;DirectoryIndex  index.html  index.html.var&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;3.6 持久连接&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 持久连接 Persistent Connection  保持连接，长连接&lt;/span&gt;
&lt;span&gt;tcp连接建立后，每个资源获取完成后不断开连接，而是继续等待其他资源请求的进行
        
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 断开条件&lt;/span&gt;
1&lt;span&gt;. 数量限制
&lt;/span&gt;2&lt;span&gt;. 时间限制
        
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 副作用&lt;/span&gt;
&lt;span&gt;对并发访问量较大的服务器，长连接机制会使得后续某些请求无法得到正常响应
        
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 折中方案&lt;/span&gt;
1&lt;span&gt;. 使用较短的持久连接时长
&lt;/span&gt;2&lt;span&gt;. 限制较少的请求数量
    
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置&lt;/span&gt;
KeepAlive  On | Off        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否启用长连接&lt;/span&gt;
KeepAliveTimeout  15       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 超时时长，单位为秒&lt;/span&gt;
MaxKeepAliveRequests  100  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保持连接上面所能获取的最大请求数量（每个连接上面的最大请求数量）&lt;/span&gt;&lt;/strong&gt;
        
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意&lt;/span&gt;
httpd2.4的KeepAliveTimeout可以是毫秒级，如果要设置毫秒级，可以直接在数值后面加上ms表示毫秒
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;可以用telnet命令来对持久连接进行测试&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
telnet 10.0.0.110 80&lt;span&gt;
GET / HTTP/1.1&lt;span&gt;
Host: 10.0.0.110&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.7 配置MPM&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在2.2中（CentOS6的rpm包）专门提供了三个应用程序文件；因为httpd2.2不支持通过编译多个MPM模块，所以只能编译选定要使用的那个；&lt;/p&gt;
&lt;p&gt;这三个应用程序文件分别用于实现对不同的MPM机制的支持，默认是使用prefork机制&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;httpd（prefork）默认就是使用prefork机制&lt;/li&gt;
&lt;li&gt;httpd.worker&lt;/li&gt;
&lt;li&gt;httpd.event&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）查看httpd程序的模块列表&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看httpd程序的模块列表&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看静态编译的模块&lt;/span&gt;
&lt;strong&gt;httpd -&lt;span&gt;l

&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看静态编译及动态编译的模块，查看所有模块&lt;/span&gt;
&lt;strong&gt;httpd -M&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3）切换MPM机制&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 2.2中&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1.更换使用的httpd程序，以支持其他MPM机制&lt;/span&gt;
vim  &lt;strong&gt;/etc/sysconfig/&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;httpd&lt;/strong&gt;
    HTTPD&lt;/span&gt;=/usr/sbin/&lt;span&gt;httpd.{worker,event}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.然后启用的时候要使用/usr/sbin/httpd.worker&lt;/span&gt;
&lt;strong&gt;/usr/sbin/httpd.worker -&lt;span&gt;k start

&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 2.4中&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 直接在这个文件中将对应的模块取消注释就ok&lt;/span&gt;
vim &lt;strong&gt; /etc/httpd/conf.modules.d/00-&lt;span&gt;mpm.conf
        
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看当前的工作模式&lt;/span&gt;
httpd -&lt;span&gt;V
    
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意：重启服务方可生效&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4）MPM的配置&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; prefork的配置：&lt;/span&gt;
        &amp;lt;IfModule prefork.c&amp;gt;&lt;span&gt;
                StartServers      &lt;/span&gt;8   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; httpd服务进程启用以后自动创建出空闲的子进程数量&lt;/span&gt;
                MinSpareServers   5   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最少空闲进程数，无论如何都需要有5个空闲进程来对待新请求&lt;/span&gt;
                MaxSpareServers  20   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最大空闲进程数，要大于StartServers的数量&lt;/span&gt;
                ServerLimit      256  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 同时在生命周期内处于活跃状态的服务器进程数（跟MaxClients应该是相同的）&lt;/span&gt;
                MaxClients       256  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最大允许启动的服务器子进程的数量&lt;/span&gt;
                MaxRequestsPerChild  4000  
                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一个子进程最多能处理的请求，若超过这个值，就将这个进程kill掉而创建新的进程&lt;/span&gt;
                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置为0则表示永不过期&lt;/span&gt;
        &amp;lt;/IfModule&amp;gt;
        
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; worker的配置：&lt;/span&gt;
        &amp;lt;IfModule worker.c&amp;gt;&lt;span&gt;
                StartServers     &lt;/span&gt;4      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; httpd服务进程启动以后自动创建出空闲的子进程数量&lt;/span&gt;
                MinSpareThreads  25     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最少空闲的线程数&lt;/span&gt;
                MaxSpareThreads  75     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最大空闲的线程数&lt;/span&gt;
        MaxClients       300    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最大的允许在线的线程数&lt;/span&gt;
                ThreadsPerChild  25     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每个子进程生成多少个线程&lt;/span&gt;
                MaxRequestsPerChild  0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 单个进程最大允许响应多少个请求&lt;/span&gt;
        &amp;lt;IfModule&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.8 模块加载&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; DSO动态共享对象&lt;/span&gt;
    
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模块位置&lt;/span&gt;
/etc/httpd/conf.modules.d/&lt;span&gt; 
在这个目录下的模块对应的配置文件中修改
    
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 加载模块&lt;/span&gt;
&lt;strong&gt;LoadModule   &amp;lt;mod_name&amp;gt;  &amp;lt;mod_path&amp;gt;&lt;/strong&gt;&lt;span&gt;
模块文件路径可使用相对路径，相对于ServerRoot，默认是 &lt;/span&gt;/etc/httpd
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.9 定义Main Server&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义Main Server&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;ServerName  FQDN

&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 语法格式&lt;/span&gt;
ServerName [scheme://]fully-qualified-domain-&lt;span&gt;name[:port]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处的名字是用来表示当前主机认为主机主要是服务于谁的&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如果这条指令没有定义，那么httpd启动时会试图反解本地的IP地址（把IP解析为主机名），如果解析不成功，则会警告&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;    
DocumentRoot   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/www/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 作用：指明网站的站点的url映射到本地的哪个文件系统路径下&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 文档路径映射：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; DocumentRoot指向的路径为URL路径的起始位置，其相当于站点URL的根路径&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; URL PATH与FileSystem PATH不是等同的，而是存在一种映射关系&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.10 路径别名&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 格式：&lt;/span&gt;
&lt;strong&gt;Alias  /URL/   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/PATH/TO/SOMEDIR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把URL跟另外的其他的目录建立映射关系&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意：在httpd2.4中要对那个目录进行显示授权（在Directory中定义那个目录的权限）&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;Alias和DocumentRoot的区别：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;DocumentRoot&lt;/strong&gt; &quot;/www/htdocs&quot;&lt;span&gt;
        http://www.hgzero.com/download/&lt;span&gt;xxx.txt 
                             /www/htdocs/download/&lt;span&gt;xxx.txt
                
&lt;strong&gt;Alias &lt;/strong&gt; /download/  &quot;/doc/pub/&quot;&lt;span&gt;
        http://www.hgzero.com/download/&lt;span&gt;xxx.txt
                             /doc/pub/&lt;span&gt;xxx.txt&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.11 站点访问控制&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 文件系统路径：&lt;/span&gt;
        &amp;lt;&lt;strong&gt;Directory &lt;/strong&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对目录下的所有资源进行控制&lt;/span&gt;
&lt;span&gt;          ...
        &lt;/span&gt;&amp;lt;/Directory&amp;gt;
        
        &amp;lt;&lt;strong&gt;File &lt;/strong&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 针对某个文件进行控制&lt;/span&gt;
&lt;span&gt;          ...
        &lt;/span&gt;&amp;lt;/File&amp;gt;
        
        &amp;lt;&lt;strong&gt;FileMatch &lt;/strong&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PATTERN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 针对符合正则匹配的所有文件进行控制&lt;/span&gt;
&lt;span&gt;          ...
        &lt;/span&gt;&amp;lt;/FileMatch&amp;gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; URL路径：&lt;/span&gt;
        &amp;lt;&lt;strong&gt;Location &lt;/strong&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 针对URL路径进行控制&lt;/span&gt;
&lt;span&gt;          ...
        &lt;/span&gt;&amp;lt;/Location&amp;gt;
        
        &amp;lt;&lt;strong&gt;LocationMatch &lt;/strong&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
          ...
        &lt;/span&gt;&amp;lt;/LocationMatch&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.12 status页面&lt;/h3&gt;
&lt;p&gt;在2.4上面要装载的模块：LoadModule status_module modules/mod_status.so&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在httpd2.2中：&lt;/span&gt;
        &amp;lt;Location  /server-status&amp;gt;&lt;span&gt;
                SetHandler server&lt;/span&gt;-&lt;span&gt;status
                Order allow,deny
                Allow  &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;  172.16
        &amp;lt;/Location&amp;gt;
        
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在httpd2.4中：&lt;/span&gt;
        &amp;lt;Location  /server-status&amp;gt;&lt;span&gt;
                SetHandler server&lt;/span&gt;-&lt;span&gt;status
                &lt;/span&gt;&amp;lt;RequireAll&amp;gt;&lt;span&gt;
                        Require ip &lt;/span&gt;172.16
                &amp;lt;/RequireAll&amp;gt;
        &amp;lt;/Location&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.13 页面压缩deflate&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）作用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用mod_deflate模块压缩页面优化传输速度（压缩文本文件，图片文件不需要压缩）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）适用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;节约带宽，额外消耗CPU；同时，可能有些较老浏览器不支持&lt;/li&gt;
&lt;li&gt;压缩适于压缩的资源，例如文件文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3）设置示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
SetOutputFilter DEFLATE    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置一个叫DEFLATE的过滤器&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; mod_deflate configuration&lt;/span&gt;

 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Restrict compression to these MIME types  # 指定对哪些内容做压缩&lt;/span&gt;
AddOutputFilterByType DEFLATE text/&lt;span&gt;plain 
AddOutputFilterByType DEFLATE text&lt;/span&gt;/&lt;span&gt;html
AddOutputFilterByType DEFLATE application&lt;/span&gt;/xhtml+&lt;span&gt;xml
AddOutputFilterByType DEFLATE text&lt;/span&gt;/&lt;span&gt;xml
AddOutputFilterByType DEFLATE application&lt;/span&gt;/&lt;span&gt;xml
AddOutputFilterByType DEFLATE application&lt;/span&gt;/x-&lt;span&gt;javascript
AddOutputFilterByType DEFLATE text&lt;/span&gt;/&lt;span&gt;javascript
AddOutputFilterByType DEFLATE text&lt;/span&gt;/&lt;span&gt;css
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Level of compression (Highest 9 - Lowest 1) # 指定压缩比&lt;/span&gt;
DeflateCompressionLevel 9
 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Netscape 4.x has some problems.  # 匹配特定的浏览器，再对其做特定的压缩，因为可能有些浏览器的特性不一样，如IE&lt;/span&gt;
BrowserMatch ^Mozilla/4  gzip-only-text/&lt;span&gt;html
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Netscape 4.06-4.08 have some more problems&lt;/span&gt;
BrowserMatch  ^Mozilla/4\.0[678]  no-&lt;span&gt;gzip
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; MSIE masquerades as Netscape, but it is fine&lt;/span&gt;
BrowserMatch \bMSI[E]  !no-gzip !gzip-only-text/html
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4. 虚拟主机&lt;/h2&gt;
&lt;h3&gt;4.1 虚拟主机概述&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）站点标识（IP、PORT、FQDN）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IP相同，端口不同&lt;/li&gt;
&lt;li&gt;IP不同，端口均为默认端口&lt;/li&gt;
&lt;li&gt;FQDN不同：http请求报文首部中 Host：www.hgzero.com&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）虚拟主机种类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于IP地址：为每个虚拟主机准备至少一个ip地址，默认是匹配自上而下的第一个符合条件的&lt;/li&gt;
&lt;li&gt;基于端口PORT：为每个虚拟主机使用至少一个独立的port&lt;/li&gt;
&lt;li&gt;基于FQDN：为每个虚拟主机使用至少一个FQDN
&lt;ul&gt;&lt;li&gt;基于FQDN时，要将所有的FQDN都解析到同一个IP地址上&lt;/li&gt;
&lt;li&gt;可以在本地hosts文件中定义或者在DNS服务器上指定&lt;/li&gt;
&lt;li&gt;基于FQDN时，是根据http请求报文中的host值来判断的，这个host值是不会被解析的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.2 匹配规则&amp;amp;匹配格式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）匹配规则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通配的越少的虚拟主机，匹配优先级越高&lt;/li&gt;
&lt;li&gt;如果基于名称的虚拟主机无法匹配上，则采用虚拟主机列表中的第一个虚拟主机作为响应主机&lt;/li&gt;
&lt;li&gt;如果所有的虚拟主机都无法匹配上，则采用主配置段中的主机，如果主配置段中注释了DocumentRoot，则返回对应的错误&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一般虚拟主机不要与中心主机混用，如果要使用虚拟主机，得先禁用main主机；2.4则可以不禁Main Server&lt;/li&gt;
&lt;li&gt;禁用中心主机：注释DocumentRoot即可&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）虚拟主机配置格式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;VirtualHost  &lt;strong&gt;IP:PORT&lt;/strong&gt;&amp;gt;&lt;span&gt;
        ServerName  &lt;strong&gt;FQDN&lt;/strong&gt;
        DocumentRoot  &quot;&quot;&lt;span&gt;
    ...
    ServerAlias：虚拟主机的别名，可多次使用
&amp;lt;/VirtualHost&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.3 虚拟主机配置示例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）基于IP的虚拟主机（基于端口）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 基于IP的虚拟主机（基于端口的虚拟主机无非就是IP地址相同，而端口不同而已）：&lt;/span&gt;
&amp;lt;VirtualHost 10.0.0.201:81&amp;gt;&lt;span&gt;
        ServerName www.hgzero.com
        DocumentRoot &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/html/www&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &amp;lt;Directory &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/html/www&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
                Options None
                AllowOverride None
                Require all granted
        &lt;/span&gt;&amp;lt;/Directory&amp;gt;&lt;span&gt;
        CustomLog &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/html/www/log/access_log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; combined
&lt;/span&gt;&amp;lt;/VirtualHost&amp;gt;

&amp;lt;VirtualHost *:82&amp;gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里的*表示监听本地所有地址&lt;/span&gt;
&lt;span&gt;        ServerName bbs.hgzero.com
        DocumentRoot &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/html/bbs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &amp;lt;Directory &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/html/bbs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
                Options None
                AllowOverride None
                Require all granted
        &lt;/span&gt;&amp;lt;/Directory&amp;gt;&lt;span&gt;
        CustomLog &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/html/bbs/log/access_log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; combined
&lt;/span&gt;&amp;lt;/VirtualHost&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2）基于FQDN的虚拟主机&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 基于主机名（FQDN）&lt;/span&gt;
&amp;lt;VirtualHost *:80&amp;gt;&lt;span&gt;
        ServerName web.hgzero.com
        DocumentRoot &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/html/www&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &amp;lt;Directory &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/html/www&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
                Options None
                AllowOverride None
                Require all granted
        &lt;/span&gt;&amp;lt;/Directory&amp;gt;&lt;span&gt;
        CustomLog &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/html/www/log/access_log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; combined
&lt;/span&gt;&amp;lt;/VirtualHost&amp;gt;

&amp;lt;VirtualHost *:80&amp;gt;&lt;span&gt;
        ServerName bbs.hgzero.com
        DocumentRoot &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/html/bbs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &amp;lt;Directory &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/html/bbs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
                Options None
                AllowOverride None
                Require all granted 
        &lt;/span&gt;&amp;lt;/Directory&amp;gt;&lt;span&gt;
        CustomLog &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/data/html/bbs/log/access_log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; combined
&lt;/span&gt;&amp;lt;/VirtualHost&amp;gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意：如果是在http2.2上，则使用基于FQDN的虚拟主机时，要事先使用如下指令&lt;/span&gt;
        NameVirtualHost  172.16.100.6:80
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 意为在这个IP和端口上，开放基于主机名的虚拟主机&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3）注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于名称的虚拟主机必须指定ServerName指令，否则它将会继承操作系统的FQDN&lt;/p&gt;
&lt;p&gt;对于基于名称的虚拟主机，如果使用IP地址请求无法匹配到任何虚拟主机时，将采用第一个虚拟主机作为默认虚拟主机&lt;/p&gt;
&lt;h2&gt;5. 访问控制&lt;/h2&gt;
&lt;h3&gt;5.1 基于源地址的访问控制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）httpd2.2和httpd2.4中的访问控制&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## httpd-2.2 ###&lt;/span&gt;
AllowOverride   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表示是否允许覆盖这里的配置；与访问控制相关的指令可以放在.htaccess文件中&lt;/span&gt;
&lt;span&gt;    All
    None
        
order           &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义生效次序，写在后面的表示默认法则&lt;/span&gt;
&lt;span&gt;    allow
    deny
        
Allow &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 允许哪些地址的访问&lt;/span&gt;
Deny &lt;span&gt;from&lt;/span&gt;       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;拒绝哪些地址的访问&lt;/span&gt;
    &lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## httpd-2.4 ###&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 基于IP控制&lt;/span&gt;
&lt;span&gt;Require  ip  IP_ADDR
Require  &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt;  ip  IP_ADDR
        
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 基于主机名控制&lt;/span&gt;
&lt;span&gt;Require  host  主机名或域名
Require  &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt;  host  主机名或域名
        
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 注意：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 以上的这些控制信息需要定义在&amp;lt;RequireAll&amp;gt;...&amp;lt;/RequireAll&amp;gt;中或&amp;lt;RequireAny&amp;gt;配置块中&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2.4中的源地址的访问控制需要显示指定&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2）Options选项&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Indexes        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指明的URL路径下不存在与定义的主页面资源相等的资源文件时，返回索引列表给用户&lt;/span&gt;
FollowSymLinks &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 允许跟踪符号链接文件所指向的源文件（在配置别名时很有用）&lt;/span&gt;
&lt;span&gt;None
All&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3）httpd2.4中的配置示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 配置示例&lt;/span&gt;
&amp;lt;Directory &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/www/html/bbs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        Options None                     
        AllowOverride None
        &lt;/span&gt;&amp;lt;RequireAll&amp;gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里定义了基于IP的访问控制（这里也可以缓存域名或主机名）&lt;/span&gt;
                Require &lt;strong&gt;ip&lt;/strong&gt; 192.168.0.0/16&lt;span&gt;
                Require &lt;/span&gt;&lt;strong&gt;&lt;span&gt;not&lt;/span&gt; ip&lt;/strong&gt; 192.168.1.102
        &amp;lt;/RequireAll&amp;gt;
&amp;lt;/Directory&amp;gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 来源地址的格式：如果是基于主机名的话，要写成Requrie host node1.com &lt;/span&gt;
&lt;span&gt;        IP
        NetAddr：
                &lt;/span&gt;172.16
                172.16.0.0/16
                172.16.0.0/255.255.0.0
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;5.2 控制页面允许or不允许所有主机访问&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 控制页面资源允许所有来源的主机可访问：&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; http-2.2&lt;/span&gt;
                &amp;lt;Directory  &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
                        ...
                        Order  allow,deny
                        Allow &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; all
                &lt;/span&gt;&amp;lt;/Directory&amp;gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; http-2.4&lt;/span&gt;
                &amp;lt;Directory  &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
                        ...
                        Require all granted
                &lt;/span&gt;&amp;lt;/Directory&amp;gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 控制页面资源拒绝所有来源的主机可访问：&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; http-2.2&lt;/span&gt;
                &amp;lt;Directory  &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
                        ...
                        Order  allow,deny
                        Deny &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; all
                &lt;/span&gt;&amp;lt;/Directory&amp;gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; http-2.4&lt;/span&gt;
                &amp;lt;Directory  &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
                        ...
                        Require all denied
                &lt;/span&gt;&amp;lt;/Directory&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.3 htpasswd&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201214221256100-2054850372.png&quot; alt=&quot;&quot; width=&quot;667&quot; height=&quot;296&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.4 基于用户的访问控制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）认证概述&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 认证质询&lt;/span&gt;
WWW-&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;Authenticate，响应码为401，拒绝客户端请求，并说明要求客户端提供账号和密码&lt;/strong&gt;
客户端用户填入账号和密码后再次发送请求报文，若认证通过，则服务器发送响应的资源
    
&lt;/span&gt;&lt;strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 认证方式&lt;/span&gt;
&lt;span&gt;basic：明文
digest：消息摘要认证
表单认证
    
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 安全域&lt;/span&gt;
&lt;span&gt;需要用户认证后方能访问的路径
应该通过名称对其特性标识，以便告知用户认证的原因
    
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户的账号和密码存放的位置&lt;/span&gt;
&lt;span&gt;虚拟账号：仅用于访问某服务时用到的认证标识
存储：
    文本文件
    SQL数据库
    ldap目录存储&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2）basic认证配置示例&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于用户的认证：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义安全域：&lt;/span&gt;
        &amp;lt;Directory  &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
                Options  None
                AllowOverride None &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否允许覆盖这里的配置，一般都是设置为None&lt;/span&gt;
                AuthType Basic     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 也可以指明digest认证方式&lt;/span&gt;
                AuthName &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指明提示信息&lt;/span&gt;
                AuthUserFile  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/httpd/conf.d/.htpasswd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 密码文件,最好将其设置为隐藏文件&lt;/span&gt;
                Require user username1 username2 ...         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 允许登录的用户&lt;/span&gt;
        Require valid-user  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 允许账号文件中的所有用户登录访问&lt;/span&gt;
        &amp;lt;/Directory&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;基于组账号进行认证：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义安全域：&lt;/span&gt;
        &amp;lt;Directory  &lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
                Options  None
                AllowOverride  None
                AuthType  Basic
                AuthName  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                AuthUserFile  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PATH/TO/HTTPD_USER_PASSWD_FILE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                AuthGroupFile  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/PATH/TO/HTTPD_GROUP_FILE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里引用的是组账号的文件&lt;/span&gt;
                Require  group  groupname1  grpname2 ...       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 允许登录的组&lt;/span&gt;
        &amp;lt;/Directory&amp;gt;
        
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建用户账号和组账号文件：&lt;/span&gt;
          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 组账号定义格式：&lt;/span&gt;
&lt;span&gt;    组文件：每一行定义一个组（创建组账号文件）
    GRP_NAME：username1  username2 ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6. https的配置&lt;/h2&gt;
&lt;h3&gt;6.1 https的工作流程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）SSL会话过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201214221723937-1886919978.png&quot; alt=&quot;&quot; width=&quot;1016&quot; height=&quot;467&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 2）SSL会话缓存&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SSL会话的时长
&lt;ul&gt;&lt;li&gt;若每次通信都经过ssl handshake，那将是非常浪费资源的，所以Server端可以吧ssl会话给缓存下来&lt;/li&gt;
&lt;li&gt;在一段时间内同一客户端访问时这个ssl handshake过程就不必再做了，直接利用此前已经建立的会话资源就可以了&lt;/li&gt;
&lt;li&gt;但是此会话不能保存太长时间，一般是五分钟之内都是有效的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;SSL会话是基于IP地址创建的，所以单IP的主机上，仅可以使用一个https的虚拟主机&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;6.2 配置httpd支持https&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201214222025944-601065874.png&quot; alt=&quot;&quot; width=&quot;692&quot; height=&quot;534&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;7. 日志相关&lt;/h2&gt;
&lt;h3&gt;7.1 日志的记录&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201214222657073-110658739.png&quot; alt=&quot;&quot; width=&quot;1567&quot; height=&quot;764&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;7.2 日志轮替&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;cronolog&lt;/li&gt;
&lt;li&gt;rotatelog&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201214222800709-1589089414.png&quot; alt=&quot;&quot; width=&quot;1103&quot; height=&quot;336&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;8. 压测工具&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201214222906289-1531248889.png&quot; alt=&quot;&quot; width=&quot;1071&quot; height=&quot;414&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;9. httpd自带的工具程序&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;apachectl&lt;/li&gt;
&lt;li&gt;apxs&lt;/li&gt;
&lt;li&gt;suexec&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201214222953778-1072569427.png&quot; alt=&quot;&quot; width=&quot;901&quot; height=&quot;403&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;10. LAMP基本架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1278240/202012/1278240-20201214223203663-2062597626.png&quot; alt=&quot;&quot; width=&quot;1350&quot; height=&quot;1389&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;










</description>
<pubDate>Mon, 14 Dec 2020 14:44:00 +0000</pubDate>
<dc:creator>Praywu</dc:creator>
<og:description>思维导图 Apache（httpd）详解 1. httpd服务 1.1 httpd概述 ASF（Apache Software Foundation） 1）服务器的类型 http服务器（httpd，n</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hgzero/p/14136149.html</dc:identifier>
</item>
<item>
<title>【分布式锁的演化】什么是锁？ - 程序员老猫</title>
<link>http://www.cnblogs.com/kdaddy/p/14136138.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kdaddy/p/14136138.html</guid>
<description>&lt;p&gt;从本篇开始，我们来好好梳理一下Java开发中的锁，通过一些具体简单的例子来描述清楚从Java单体锁到分布式锁的演化流程。本篇我们先来看看什么是锁，以下老猫会通过一些日常生活中的例子也说清楚锁的概念。&lt;/p&gt;
&lt;h3 id=&quot;描述&quot;&gt;描述&lt;/h3&gt;
&lt;p&gt;锁在Java中是一个非常重要的概念，在当今的互联网时代，尤其在各种高并发的情况下，我们更加离不开锁。那么到底什么是锁呢？在计算机中，锁(lock)或者互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁可以强制实施排他互斥、并发控制策略。举一个生活中的例子，大家都去超市买东西，如果我们带了包的话，要放到储物柜。我们再把这个例子极端一下，假如柜子只有一个，那么此时同时来了三个人A、B、C都要往这个柜子里放东西。那么这个场景就是一个多线程，多线程自然也就离不开锁。简单示意图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2200669/202012/2200669-20201214223843165-1298926761.png&quot; alt=&quot;存储柜子模型&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A、B、C都要往柜子里面放东西，可是柜子只能存放一个东西，那么怎么处理？这个时候我们就引出了锁的概念，三个人中谁先抢到了柜子的锁，谁就可以使用这个柜子，其他的人只能等待。比如C抢到了锁，C就可以使用这个柜子，A和B只能等待，等到C使用完毕之后，释放了锁，AB再进行抢锁，谁先抢到了，谁就有使用柜子的权利。&lt;/p&gt;
&lt;h3 id=&quot;抽象成代码&quot;&gt;抽象成代码&lt;/h3&gt;
&lt;p&gt;我们其实可以将以上场景抽象程相关的代码模型，我们来看一下以下代码的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author kdaddy@163.com
 * @date 2020/11/2 23:13
 */
public class Cabinet {
    //表示柜子中存放的数字
    private int storeNumber;

    public int getStoreNumber() {
        return storeNumber;
    }
    public void setStoreNumber(int storeNumber) {
        this.storeNumber = storeNumber;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;柜子中存储的是数字。&lt;/p&gt;
&lt;p&gt;然后我们把3个用户抽象成一个类，如下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author kdaddy@163.com
 * @date 2020/11/7 22:03
 */
public class User {
    // 柜子
    private Cabinet cabinet;
    // 存储的数字
    private int storeNumber;

    public User(Cabinet cabinet, int storeNumber) {
        this.cabinet = cabinet;
        this.storeNumber = storeNumber;
    }
    // 表示使用柜子
    public void useCabinet(){
        cabinet.setStoreNumber(storeNumber);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在用户的构造方法中，需要传入两个参数，一个是要使用的柜子，另一个是要存储的数字。以上我们把柜子和用户都已经抽象完毕，接下来我们再来写一个启动类，模拟一下3个用户使用柜子的场景。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author kdaddy@163.com
 * @date 2020/11/7 22:05
 */
public class Starter {
    public static void main(String[] args) {
        final Cabinet cabinet = new Cabinet();
        ExecutorService es = Executors.newFixedThreadPool(3);

        for(int i= 1; i &amp;lt; 4; i++){
            final int storeNumber = i;
            es.execute(()-&amp;gt;{
                User user = new User(cabinet,storeNumber);
                user.useCabinet();
                System.out.println(&quot;我是用户&quot;+storeNumber+&quot;,我存储的数字是：&quot;+cabinet.getStoreNumber());
            });
        }
        es.shutdown();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们仔细的看一下这个main函数的过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先创建一个柜子的实例，由于场景中只有一个柜子，所以我们只创建了一个柜子实例。&lt;/li&gt;
&lt;li&gt;然后我们新建了一个线程池，线程池中一共有三个线程，每个线程执行一个用户的操作。&lt;/li&gt;
&lt;li&gt;再来看看每个线程具体的执行过程，新建用户实例，传入的是用户使用的柜子，我们这里只有一个柜子，所以传入这个柜子的实例，然后传入这个用户所需要存储的数字，分别是1,2,3，也分别对应了用户1,2,3。&lt;/li&gt;
&lt;li&gt;再调用使用柜子的操作，也就是想柜子中放入要存储的数字，然后立刻从柜子中取出数字，并打印出来。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们运行一下main函数，看看得到的打印结果是什么？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-tex&quot;&gt;我是用户1,我存储的数字是：3
我是用户3,我存储的数字是：3
我是用户2,我存储的数字是：2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果中，我们可以看出三个用户在存储数字的时候两个都是3，一个是2。这是为什么呢？我们期待的应该是每个人都能获取不同的数字才对。其实问题就是出在&quot;user.useCabinet();&quot;这个方法上，这是因为柜子这个实例没有加锁的原因，三个用户并行执行，向柜子中存储他们的数字，虽然3个用户并行同时操作，但是在具体赋值的时候，也是有顺序的，因为变量storeNumber只有一块内存，storeNumber只存储一个值，存储最后的线程所设置的值。至于哪个线程排在最后，则完全不确定，赋值语句执行完成之后，进入打印语句，打印语句取storeNumber的值并打印，这时storeNumber存储的是最后一个线程锁所设置的值，3个线程取到的值有两个是相同的，就像上面打印的结果一样。&lt;/p&gt;
&lt;p&gt;那么如何才能解决这个问题？这就需要我们用到锁。我们再赋值语句上加锁，这样当多个线程（此处表示用户）同时赋值的时候，谁能优先抢到这把锁，谁才能够赋值，这样保证同一个时刻只能有一个线程进行赋值操作，避免了之前的混乱的情况。&lt;/p&gt;
&lt;p&gt;那么在程序中，我们如何加锁呢？&lt;/p&gt;
&lt;p&gt;下面我们介绍一下Java中的一个关键字synchronized。关于这个关键字，其实有两种用法。&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;synchronized方法，顾名思义就是把synchronize的关键字写在方法上，它表示这个方法是加了锁的，当多个线程同时调用这个方法的时候，只有获得锁的线程才能够执行，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public synchronized String getTicket(){
        return &quot;xxx&quot;;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上我们可以看到getTicket（）方法加了锁，当多个线程并发执行的时候，只有获得锁的线程才可以执行，其他的线程只能够等待。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;synchronized代码块。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;synchronized (对象锁){
    ……
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将需要加锁的语句都写在代码块中，而在对象锁的位置，需要填写加锁的对象，它的含义是，当多个线程并发执行的时候，只有获得你写的这个对象的锁，才能够执行后面的语句，其他的线程只能等待。synchronized块通常的写法是synchronized（this），这个this是当前类的实例，也就是说获得当前这个类的对象的锁，才能够执行这个方法，此写法等同于synchronized方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;回到刚才的例子中，我们又是如何解决storeNumber混乱的问题呢？咱们试着在方法上加上锁，这样保证同时只有一个线程能调用这个方法，具体如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author kdaddy@163.com
 * @date 2020/12/2 23:13
 */
public class Cabinet {
    //表示柜子中存放的数字
    private int storeNumber;

    public int getStoreNumber() {
        return storeNumber;
    }

    public synchronized void setStoreNumber(int storeNumber) {
        this.storeNumber = storeNumber;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们运行一下代码，结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我是用户2,我存储的数字是：2
我是用户3,我存储的数字是：2
我是用户1,我存储的数字是：1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现结果还是混乱的，并没有解决问题。我们检查一下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; es.execute(()-&amp;gt;{
                User user = new User(cabinet,storeNumber);
                user.useCabinet();
                System.out.println(&quot;我是用户&quot;+storeNumber+&quot;,我存储的数是：&quot;+cabinet.getStoreNumber());
            });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到在useCabinet和打印的方法是两个语句，并没有保持原子性，虽然在set方法上加了锁，但是在打印的时候又存在了并发，打印语句是有锁的，但是不能确定哪个线程去执行。所以这里，我们要保证useCabinet和打印的方法的原子性，我们使用synchronized块，但是synchronized块里的对象我们使用谁的？这又是一个问题，user还是cabinet?回答当然是cabinet，因为每个线程都初始化了user，总共有3个User对象，而cabinet对象只有一个，所以synchronized要用cabine对象，具体代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author kdaddy@163.com
 * @date 2020/12/7 22:05
 */
public class Starter {
    public static void main(String[] args) {
        final Cabinet cabinet = new Cabinet();
        ExecutorService es = Executors.newFixedThreadPool(3);

        for(int i= 1; i &amp;lt; 4; i++){
            final int storeNumber = i;
            es.execute(()-&amp;gt;{
                User user = new User(cabinet,storeNumber);
                synchronized (cabinet){
                    user.useCabinet();
                    System.out.println(&quot;我是用户&quot;+storeNumber+&quot;,我存储的数字是：&quot;+cabinet.getStoreNumber());
                }
            });
        }
        es.shutdown();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们再去运行一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我是用户3,我存储的数字是：3
我是用户2,我存储的数字是：2
我是用户1,我存储的数字是：1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们加了synchronized块，保证了存储和取出的原子性，这样用户存储的数字和取出的数字就对应上了，不会造成混乱，最后我们用图来表示一下上面例子的整体情况。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2200669/202012/2200669-20201214223913376-1193021014.png&quot; alt=&quot;最终模型&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，线程A，线程B，线程C同时调用Cabinet类的setStoreNumber方法，线程B获得了锁，所以线程B可以执行setStore的方法，线程A和线程C只能等待。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;通过上面的场景以及例子，我们可以了解多线程情况下，造成的变量值前后不一致的问题，以及锁的作用，在使用了锁以后，可以避免这种混乱的现象，后续，老猫会和大家介绍一个Java中都有哪些关于锁的解决方案，以及项目中所用到的实战。&lt;/p&gt;
</description>
<pubDate>Mon, 14 Dec 2020 14:41:00 +0000</pubDate>
<dc:creator>程序员老猫</dc:creator>
<og:description>分布式锁的演化之什么是锁？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kdaddy/p/14136138.html</dc:identifier>
</item>
<item>
<title>恕我直言，你可能连 GitHub 搜索都不会用 - 如何精准搜索的神仙技巧 - 天明夜尽</title>
<link>http://www.cnblogs.com/biaochenxuying/p/14136094.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/biaochenxuying/p/14136094.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-3efe8dea94368cd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家好，我是你们的 前端章鱼猫，一个不喜欢喵、又不喜欢吃鱼的超级猫 ~&lt;/p&gt;
&lt;p&gt;今天给大家带来的是 &lt;strong&gt;在 GitHub 上如何精准搜索的神仙技巧&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-428220a865dcd2b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7.0588235294118&quot;&gt;
&lt;p&gt;【前端GitHub：&lt;a href=&quot;https://github.com/biaochenxuying/FrontEndGitHub&quot; target=&quot;_blank&quot;&gt;https://github.com/biaochenxuying/FrontEndGitHub&lt;/a&gt; 】，专注于挖掘 GitHub 上优秀的前端开源项目，专注于挖掘 GitHub 上优秀的前端开源项目，并以专题的形式推荐，每专题大概 10 个好项目，每周会有一到三篇精华文章推送。涵盖 JavaScript、Vue、React、Node、小程序、Flutter、Deno、HTML、CSS、数据结构与算法 等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;平时如何发现好的开源项目，可以看看这篇文章：&lt;a href=&quot;https://github.com/biaochenxuying/blog/issues/45&quot; target=&quot;_blank&quot;&gt;GitHub 上能挖矿的神仙技巧 - 如何发现优秀开源项目&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;以下为【前端GitHub】的第 4 期内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-29efafa962d0cd20.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;普通的搜索&quot;&gt;普通的搜索&lt;/h2&gt;
&lt;p&gt;相信一般人搜索项目时，都是直接搜索技术栈相关的项目。&lt;/p&gt;
&lt;p&gt;高级一点的搜索，会根据 最匹配、最多 Star 来进行排序、选择相应的语言、选择仓库或者代码来进行筛选。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-358be34642d35c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是 GitHub 的搜索功能只支持以上这些而已吗 ？&lt;/p&gt;
&lt;p&gt;No!&lt;/p&gt;
&lt;p&gt;如果你只会用以上的功能，那你知道的仅仅是 GitHub 搜索的冰山一角！&lt;/p&gt;
&lt;p&gt;GitHub 的搜索是非常强大的！下面介绍更高级的搜索技巧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-3e6836282fb4bc59.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;搜索语法&quot;&gt;搜索语法&lt;/h2&gt;
&lt;p&gt;搜索 GitHub 时，你可以构建匹配特定数字和单词的查询。&lt;/p&gt;
&lt;h3 id=&quot;查询大于或小于另一个值的值&quot;&gt;查询大于或小于另一个值的值&lt;/h3&gt;
&lt;p&gt;您可以使用 &lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;gt;=&lt;/code&gt;、&lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;=&lt;/code&gt; 搜索大于、大于等于、小于以及小于等于另一个值的值。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;查询&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.3372781065089&quot;&gt;&lt;tr readability=&quot;1.679012345679&quot;&gt;&lt;td&gt;&lt;code&gt;&amp;gt;*n*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=vue+stars%3A%3E1000&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;vue vue:&amp;gt;1000&lt;/a&gt;&lt;/strong&gt; 匹配含有 &quot;vue&quot; 字样、星标超过 1000 个的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6744186046512&quot;&gt;&lt;td&gt;&lt;code&gt;&amp;gt;=*n*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=vue+topics%3A%3E%3D5&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;vue topics:&amp;gt;=5&lt;/a&gt;&lt;/strong&gt; 匹配含有 &quot;vue&quot; 字样、有 5 个或更多主题的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6428571428571&quot;&gt;&lt;td&gt;&lt;code&gt;&amp;lt;*n*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=vue+size%3A%3C10000&amp;amp;type=Code&quot; target=&quot;_blank&quot;&gt;vue size:&amp;lt;10000&lt;/a&gt;&lt;/strong&gt; 匹配小于 10 KB 的文件中含有 &quot;vue&quot; 字样的代码。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6666666666667&quot;&gt;&lt;td&gt;&lt;code&gt;&amp;lt;=*n*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=vue+stars%3A%3C%3D50&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;vue stars:&amp;lt;=50&lt;/a&gt;&lt;/strong&gt; 匹配含有 &quot;vue&quot; 字样、星标不超过 50 个的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;您还可以使用 范围查询 搜索大于等于或小于等于另一个值的值。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;查询&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.6103896103896&quot;&gt;&lt;tr readability=&quot;2.6086956521739&quot;&gt;&lt;td&gt;&lt;code&gt;*n*..*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=vue+stars%3A10..*&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;vue stars:10..*&lt;/a&gt;&lt;/strong&gt; 等同于 &lt;code&gt;stars:&amp;gt;=10&lt;/code&gt; 并匹配含有 &quot;vue&quot; 字样、有 10 个或更多星号的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.6086956521739&quot;&gt;&lt;td&gt;&lt;code&gt;*..*n*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=vue+stars%3A%22*..10%22&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;vue stars:*..10&lt;/a&gt;&lt;/strong&gt; 等同于 &lt;code&gt;stars:&amp;lt;=10&lt;/code&gt; 并匹配含有 &quot;vue&quot; 字样、有不超过 10 个星号的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;查询范围之间的值&quot;&gt;查询范围之间的值&lt;/h3&gt;
&lt;p&gt;您可以使用范围语法 &lt;code&gt;*n*..*n*&lt;/code&gt; 搜索范围内的值，其中第一个数字 &lt;em&gt;n&lt;/em&gt; 是最低值，而第二个是最高值。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;查询&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;0.82222222222222&quot;&gt;&lt;tr readability=&quot;1.6444444444444&quot;&gt;&lt;td&gt;&lt;code&gt;*n*..*n*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=cats+stars%3A10..50&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;vue stars:10..50&lt;/a&gt;&lt;/strong&gt; 匹配含有 &quot;vue&quot; 字样、有 10 到 50 个星号的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;查询日期&quot;&gt;查询日期&lt;/h3&gt;
&lt;p&gt;您可以通过使用 &lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;gt;=&lt;/code&gt;、&lt;code&gt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;lt;=&lt;/code&gt; 和 范围查询 搜索早于或晚于另一个日期，或者位于日期范围内的日期。&lt;/p&gt;
&lt;p&gt;日期格式必须遵循 &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot; target=&quot;_blank&quot;&gt;ISO8601&lt;/a&gt; 标准，即 &lt;code&gt;YYYY-MM-DD&lt;/code&gt;（年-月-日）。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;查询&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9.2511111111111&quot;&gt;&lt;tr readability=&quot;2.425&quot;&gt;&lt;td&gt;&lt;code&gt;&amp;gt;*YYYY*-*MM*-*DD*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=vue+created%3A%3E2016-04-29&amp;amp;type=Issues&quot; target=&quot;_blank&quot;&gt;vue created:&amp;gt;2016-04-29&lt;/a&gt;&lt;/strong&gt; 匹配含有 &quot;vue&quot; 字样、在 2016 年 4 月 29 日之后创建的议题。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.4193548387097&quot;&gt;&lt;td&gt;&lt;code&gt;&amp;gt;=*YYYY*-*MM*-*DD*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=vue+created%3A%3E%3D2017-04-01&amp;amp;type=Issues&quot; target=&quot;_blank&quot;&gt;vue created:&amp;gt;=2017-04-01&lt;/a&gt;&lt;/strong&gt; 匹配含有 &quot;vue&quot; 字样、在 2017 年 4 月 1 日或之后创建的议题。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.4803149606299&quot;&gt;&lt;td&gt;&lt;code&gt;&amp;lt;*YYYY*-*MM*-*DD*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?q=vue+pushed%3A%3C2012-07-05&amp;amp;type=Code&amp;amp;utf8=%E2%9C%93&quot; target=&quot;_blank&quot;&gt;vue pushed:&amp;lt;2012-07-05&lt;/a&gt;&lt;/strong&gt; 匹配在 2012 年 7 月 5 日之前推送的仓库中含有 &quot;vue&quot; 字样的代码。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.4193548387097&quot;&gt;&lt;td&gt;&lt;code&gt;&amp;lt;=*YYYY*-*MM*-*DD*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=vue+created%3A%3C%3D2012-07-04&amp;amp;type=Issues&quot; target=&quot;_blank&quot;&gt;vue created:&amp;lt;=2012-07-04&lt;/a&gt;&lt;/strong&gt; 匹配含有 &quot;vue&quot; 字样、在 2012 年 7 月 4 日或之前创建的议题。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3.9144736842105&quot;&gt;&lt;td&gt;&lt;code&gt;*YYYY*-*MM*-*DD*..*YYYY*-*MM*-*DD*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=vue+pushed%3A2016-04-30..2016-07-04&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;vue pushed:2016-04-30..2016-07-04&lt;/a&gt;&lt;/strong&gt; 匹配含有 &quot;vue&quot; 字样、在 2016 年 4 月末到 7 月之间推送的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.3951612903226&quot;&gt;&lt;td&gt;&lt;code&gt;*YYYY*-*MM*-*DD*..*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=vue+created%3A2012-04-30..*&amp;amp;type=Issues&quot; target=&quot;_blank&quot;&gt;vue created:2012-04-30..*&lt;/a&gt;&lt;/strong&gt; 匹配在 2012 年 4 月 30 日之后创建、含有 &quot;vue&quot; 字样的议题。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.390243902439&quot;&gt;&lt;td&gt;&lt;code&gt;*..*YYYY*-*MM*-*DD*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=vue+created%3A*..2012-07-04&amp;amp;type=Issues&quot; target=&quot;_blank&quot;&gt;vue created:*..2012-04-30&lt;/a&gt;&lt;/strong&gt; 匹配在 2012 年 7 月 4 日之前创建、含有 &quot;vue&quot; 字样的议题。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;您也可以在日期后添加可选的时间信息 &lt;code&gt;THH:MM:SS+00:00&lt;/code&gt;，以便按小时、分钟和秒进行搜索。 这是 &lt;code&gt;T&lt;/code&gt;，随后是 &lt;code&gt;HH:MM:SS&lt;/code&gt;（时-分-秒）和 UTC 偏移 (&lt;code&gt;+00:00&lt;/code&gt;)。&lt;/p&gt;
&lt;h3 id=&quot;排除特定结果&quot;&gt;排除特定结果&lt;/h3&gt;
&lt;p&gt;您可以使用 &lt;code&gt;NOT&lt;/code&gt; 语法排除包含特定字词的结果。 &lt;code&gt;NOT&lt;/code&gt; 运算符只能用于字符串关键词， 不适用于数字或日期。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;查询&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;0.82758620689655&quot;&gt;&lt;tr readability=&quot;1.6551724137931&quot;&gt;&lt;td&gt;&lt;code&gt;NOT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/search?q=hello+NOT+world&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;hello NOT world&lt;/a&gt;&lt;/strong&gt; 匹配含有 &quot;hello&quot; 字样但不含有 &quot;world&quot; 字样的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;缩小搜索结果范围的另一种途径是排除特定的子集。 您可以为任何搜索限定符添加 &lt;code&gt;-&lt;/code&gt; 前缀，以排除该限定符匹配的所有结果。&lt;/p&gt;
&lt;h3 id=&quot;对带有空格的查询使用引号&quot;&gt;对带有空格的查询使用引号&lt;/h3&gt;
&lt;p&gt;如果搜索含有空格的查询，您需要用引号将其括起来。 例如：&lt;/p&gt;
&lt;p&gt;某些非字母数字符号（例如空格）会从引号内的代码搜索查询中删除，因此结果可能出乎意料。&lt;/p&gt;
&lt;h3 id=&quot;使用用户名的查询&quot;&gt;使用用户名的查询&lt;/h3&gt;
&lt;p&gt;如果搜索查询包含需要用户名的限定符，例如 &lt;code&gt;user&lt;/code&gt;、&lt;code&gt;actor&lt;/code&gt; 或 &lt;code&gt;assignee&lt;/code&gt;，您可以使用任何 GitHub 用户名指定特定人员，或使用 &lt;code&gt;@me&lt;/code&gt; 指定当前用户。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@me&lt;/code&gt; 只能与限定符一起使用，而不能用作搜索词，例如 &lt;code&gt;@me main.workflow&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;高级的搜索&quot;&gt;高级的搜索&lt;/h2&gt;
&lt;h3 id=&quot;按仓库名称、说明或自述文件内容搜索&quot;&gt;按仓库名称、说明或自述文件内容搜索&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;in&lt;/code&gt; 限定符，您可以将搜索限制为仓库名称、仓库说明、自述文件内容或这些的任意组合。&lt;/p&gt;
&lt;p&gt;如果省略此限定符，则只搜索仓库名称和说明。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;限定符&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.0056022408964&quot;&gt;&lt;tr readability=&quot;1.6716417910448&quot;&gt;&lt;td&gt;&lt;code&gt;in:name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=vue+in%3Aname&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;vue in:name&lt;/strong&gt;&lt;/a&gt; 匹配其名称中含有 &quot;jquery&quot; 的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.25&quot;&gt;&lt;td&gt;&lt;code&gt;in:description&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=vue+in%3Aname%2Cdescription&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;vue in:name,description&lt;/strong&gt;&lt;/a&gt; 匹配其名称或说明中含有 &quot;vue&quot; 的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6486486486486&quot;&gt;&lt;td&gt;&lt;code&gt;in:readme&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=vue+in%3Areadme&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;vue in:readme&lt;/strong&gt;&lt;/a&gt; 匹配其自述文件中提及 &quot;vue&quot; 的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.404958677686&quot;&gt;&lt;td&gt;&lt;code&gt;repo:owner/name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=repo%3Abiaochenxuying%2Fblog&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;repo:biaochenxuying/blog&lt;/strong&gt;&lt;/a&gt; 匹配特定仓库名称，比如：用户为 biaochenxuying 的 blog 项目。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-b20d13aad4ad81af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;在用户或组织的仓库内搜索&quot;&gt;在用户或组织的仓库内搜索&lt;/h3&gt;
&lt;p&gt;要在 &lt;code&gt;特定用户或组织&lt;/code&gt; 拥有的所有仓库中搜索，您可以使用 &lt;code&gt;user&lt;/code&gt; 或 &lt;code&gt;org&lt;/code&gt; 限定符。&lt;/p&gt;
&lt;h3 id=&quot;按仓库大小搜索&quot;&gt;按仓库大小搜索&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;size&lt;/code&gt; 限定符使用 &lt;a href=&quot;https://docs.github.com/cn/free-pro-team@latest/articles/understanding-the-search-syntax&quot; target=&quot;_blank&quot;&gt;大于、小于和范围限定符&lt;/a&gt; 查找匹配特定大小（以千字节为单位）的仓库。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;限定符&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.207729468599&quot;&gt;&lt;tr readability=&quot;1.6603773584906&quot;&gt;&lt;td&gt;&lt;code&gt;size:*n*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=size%3A1000&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;size:1000&lt;/strong&gt;&lt;/a&gt; 匹配恰好为 1 MB 的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5&quot;&gt;&lt;td/&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=size%3A%3E%3D30000&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;size:&amp;gt;=30000&lt;/strong&gt;&lt;/a&gt; 匹配至少为 30 MB 的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.609756097561&quot;&gt;&lt;td/&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=size%3A%3C50&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;size:&amp;lt;50&lt;/strong&gt;&lt;/a&gt; 匹配小于 50 KB 的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6129032258065&quot;&gt;&lt;td/&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=size%3A50..120&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;size:50..120&lt;/strong&gt;&lt;/a&gt; 匹配介于 50 KB 与 120 KB 之间的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-578522b061d6f9ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;按关注者数量搜索&quot;&gt;按关注者数量搜索&lt;/h3&gt;
&lt;p&gt;您可以使用 &lt;code&gt;followers&lt;/code&gt; 限定符以及&lt;a href=&quot;https://docs.github.com/cn/free-pro-team@latest/articles/understanding-the-search-syntax&quot; target=&quot;_blank&quot;&gt;大于、小于和范围限定符&lt;/a&gt;基于仓库拥有的关注者数量过滤仓库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-7ba0decd991d8861.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-3dc349660bb647fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;按复刻数量搜索&quot;&gt;按复刻数量搜索&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;forks&lt;/code&gt; 限定符使用&lt;a href=&quot;https://docs.github.com/cn/free-pro-team@latest/articles/understanding-the-search-syntax&quot; target=&quot;_blank&quot;&gt;大于、小于和范围限定符&lt;/a&gt;指定仓库应具有的复刻数量。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;限定符&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.3127753303965&quot;&gt;&lt;tr readability=&quot;1.7454545454545&quot;&gt;&lt;td&gt;&lt;code&gt;forks:*n*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=forks%3A5&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;forks:5&lt;/strong&gt;&lt;/a&gt; 匹配只有 5 个复刻的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6140350877193&quot;&gt;&lt;td/&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=forks%3A%3E%3D205&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;forks:&amp;gt;=205&lt;/strong&gt;&lt;/a&gt; 匹配具有至少 205 个复刻的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6666666666667&quot;&gt;&lt;td/&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=forks%3A%3C90&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;forks:&amp;lt;90&lt;/strong&gt;&lt;/a&gt; 匹配具有少于 90 个复刻的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5862068965517&quot;&gt;&lt;td/&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=forks%3A10..20&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;forks:10..20&lt;/strong&gt;&lt;/a&gt; 匹配具有 10 到 20 个复刻的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-f51734b43275169c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;按星号数量搜索&quot;&gt;按星号数量搜索&lt;/h3&gt;
&lt;p&gt;您可以使用 &lt;a href=&quot;https://docs.github.com/cn/free-pro-team@latest/articles/understanding-the-search-syntax&quot; target=&quot;_blank&quot;&gt;大于、小于和范围限定符&lt;/a&gt; 基于仓库具有的 &lt;a href=&quot;https://docs.github.com/cn/free-pro-team@latest/articles/saving-repositories-with-stars&quot; target=&quot;_blank&quot;&gt;星标&lt;/a&gt; 数量搜索仓库&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;限定符&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.7790262172285&quot;&gt;&lt;tr readability=&quot;1.7230769230769&quot;&gt;&lt;td&gt;&lt;code&gt;stars:*n*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=stars%3A500&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;stars:500&lt;/strong&gt;&lt;/a&gt; 匹配恰好具有 500 个星号的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6842105263158&quot;&gt;&lt;td/&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=stars%3A10..20+size%3A%3C1000&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;stars:10..20&lt;/strong&gt;&lt;/a&gt; 匹配具有 10 到 20 个星号、小于 1000 KB 的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.1774193548387&quot;&gt;&lt;td/&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=stars%3A%3E%3D500+fork%3Atrue+language%3Avue&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;stars:&amp;gt;=500 fork:true language:vue&lt;/strong&gt;&lt;/a&gt; 匹配具有至少 500 个星号，包括复刻的星号（以 vue 编写）的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-f22c2cf0ab6dde85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;按仓库创建或上次更新时间搜索&quot;&gt;按仓库创建或上次更新时间搜索&lt;/h3&gt;
&lt;p&gt;你可以基于创建时间或上次更新时间过滤仓库。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于仓库创建，您可以使用 &lt;code&gt;created&lt;/code&gt; 限定符；&lt;/li&gt;
&lt;li&gt;要了解仓库上次更新的时间，您要使用 &lt;code&gt;pushed&lt;/code&gt; 限定符。 &lt;code&gt;pushed&lt;/code&gt; 限定符将返回仓库列表，按仓库中任意分支上最近进行的提交排序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两者均采用日期作为参数。 日期格式必须遵循 ISO8601 标准，即 &lt;code&gt;YYYY-MM-DD&lt;/code&gt;（年-月-日）。&lt;/p&gt;
&lt;p&gt;也可以在日期后添加可选的时间信息 &lt;code&gt;THH:MM:SS+00:00&lt;/code&gt;，以便按小时、分钟和秒进行搜索。 这是 &lt;code&gt;T&lt;/code&gt;，随后是 &lt;code&gt;HH:MM:SS&lt;/code&gt;（时-分-秒）和 UTC 偏移 (&lt;code&gt;+00:00&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;日期支持 &lt;code&gt;大于、小于和范围限定符&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-81cb3cb714ee6913.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;按语言搜索&quot;&gt;按语言搜索&lt;/h3&gt;
&lt;p&gt;您可以基于其编写采用的主要语言搜索仓库。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;限定符&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;0.78301886792453&quot;&gt;&lt;tr readability=&quot;1.5660377358491&quot;&gt;&lt;td&gt;&lt;code&gt;language:*LANGUAGE*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=vue+language%3Ajavascript&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;vue language:javascript&lt;/strong&gt;&lt;/a&gt; 匹配具有 &quot;vue&quot; 字样、以 JavaScript 编写的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-4b8f7e13e07a8590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;按主题搜索&quot;&gt;按主题搜索&lt;/h3&gt;
&lt;p&gt;您可以查找归类为特定 &lt;a href=&quot;https://docs.github.com/cn/free-pro-team@latest/articles/classifying-your-repository-with-topics&quot; target=&quot;_blank&quot;&gt;主题&lt;/a&gt; 的所有仓库。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;限定符&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;0.81012658227848&quot;&gt;&lt;tr readability=&quot;1.620253164557&quot;&gt;&lt;td&gt;&lt;code&gt;topic:*TOPIC*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=topic%3Aalgorithm&amp;amp;type=Repositories&amp;amp;ref=searchresults&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;topic:algorithm&lt;/strong&gt;&lt;/a&gt; 匹配已归类为 &quot;algorithm&quot; 主题的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;估计又有很多人不知道 GitHub 上有话题一说的吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-303e444d6bca3b9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-b0ed87151a4a06bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;按主题数量搜索&quot;&gt;按主题数量搜索&lt;/h3&gt;
&lt;p&gt;您可以使用 &lt;code&gt;topics&lt;/code&gt; 限定符以及 &lt;a href=&quot;https://docs.github.com/cn/free-pro-team@latest/articles/understanding-the-search-syntax&quot; target=&quot;_blank&quot;&gt;大于、小于和范围限定符&lt;/a&gt; 按应用于仓库的 &lt;a href=&quot;https://docs.github.com/cn/free-pro-team@latest/articles/classifying-your-repository-with-topics&quot; target=&quot;_blank&quot;&gt;主题&lt;/a&gt; 数量搜索仓库。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;限定符&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1.6761904761905&quot;&gt;&lt;tr readability=&quot;1.719298245614&quot;&gt;&lt;td&gt;&lt;code&gt;topics:*n*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=topics%3A5&amp;amp;type=Repositories&amp;amp;ref=searchresults&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;topics:5&lt;/strong&gt;&lt;/a&gt; 匹配具有五个主题的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6170212765957&quot;&gt;&lt;td/&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=topics%3A%3E3&amp;amp;type=Repositories&amp;amp;ref=searchresults&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;topics:&amp;gt;3&lt;/strong&gt;&lt;/a&gt; 匹配超过三个主题的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-8ae28aeccc8f883d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用可视界面搜索&quot;&gt;使用可视界面搜索&lt;/h3&gt;
&lt;p&gt;还可以使用 &lt;a href=&quot;https://github.com/search&quot; target=&quot;_blank&quot;&gt;search&lt;/a&gt; page 或 &lt;a href=&quot;https://github.com/search/advanced&quot; target=&quot;_blank&quot;&gt;advanced search&lt;/a&gt; page 搜索 GitHub 哦。&lt;/p&gt;
&lt;p&gt;这种搜索方式，估计就更少人知道了吧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/search/advanced&quot; target=&quot;_blank&quot;&gt;advanced search&lt;/a&gt; page 提供用于构建搜索查询的可视界面。&lt;/p&gt;
&lt;p&gt;您可以按各种因素过滤搜索，例如仓库具有的星标数或复刻数。 在填写高级搜索字段时，您的查询将在顶部搜索栏中自动构建。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-7d920dc88311609b.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;高级搜索&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;按许可搜索&quot;&gt;按许可搜索&lt;/h3&gt;
&lt;p&gt;您可以按其&lt;a href=&quot;https://docs.github.com/cn/free-pro-team@latest/articles/licensing-a-repository&quot; target=&quot;_blank&quot;&gt;许可&lt;/a&gt;搜索仓库。 您必须使用&lt;a href=&quot;https://docs.github.com/cn/free-pro-team@latest/articles/licensing-a-repository/#searching-github-by-license-type&quot; target=&quot;_blank&quot;&gt;许可关键词&lt;/a&gt;按特定许可或许可系列过滤仓库。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;限定符&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1.625&quot;&gt;&lt;tr readability=&quot;3.25&quot;&gt;&lt;td&gt;&lt;code&gt;license:*LICENSE_KEYWORD*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=license%3Aapache-2.0&amp;amp;type=Repositories&amp;amp;ref=searchresults&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;license:apache-2.0&lt;/strong&gt;&lt;/a&gt; 匹配根据 Apache License 2.0 授权的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;按公共或私有仓库搜索&quot;&gt;按公共或私有仓库搜索&lt;/h3&gt;
&lt;p&gt;您可以基于仓库是公共还是私有来过滤搜索。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;限定符&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1.566265060241&quot;&gt;&lt;tr readability=&quot;1.4285714285714&quot;&gt;&lt;td&gt;&lt;code&gt;is:public&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?q=is%3Apublic+org%3Agithub&amp;amp;type=Repositories&amp;amp;utf8=%E2%9C%93&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;is:public org:github&lt;/strong&gt;&lt;/a&gt; 匹配 GitHub 拥有的公共仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6631578947368&quot;&gt;&lt;td&gt;&lt;code&gt;is:private&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=pages+is%3Aprivate&amp;amp;type=Repositories&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;is:private pages&lt;/strong&gt;&lt;/a&gt; 匹配您有访问权限且包含 &quot;pages&quot; 字样的私有仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;按公共或私有仓库搜索-1&quot;&gt;按公共或私有仓库搜索&lt;/h3&gt;
&lt;p&gt;您可以根据仓库是否为镜像以及托管于其他位置托管来搜索它们。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;限定符&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1.5882352941176&quot;&gt;&lt;tr readability=&quot;1.5853658536585&quot;&gt;&lt;td&gt;&lt;code&gt;mirror:true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=mirror%3Atrue+GNOME&amp;amp;type=&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;mirror:true GNOME&lt;/strong&gt;&lt;/a&gt; 匹配是镜像且包含 &quot;GNOME&quot; 字样的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5862068965517&quot;&gt;&lt;td&gt;&lt;code&gt;mirror:false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=mirror%3Afalse+GNOME&amp;amp;type=&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;mirror:false GNOME&lt;/strong&gt;&lt;/a&gt; 匹配并非镜像且包含 &quot;GNOME&quot; 字样的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;基于仓库是否已存档搜索&quot;&gt;基于仓库是否已存档搜索&lt;/h3&gt;
&lt;p&gt;你可以基于仓库是否&lt;a href=&quot;https://docs.github.com/cn/free-pro-team@latest/articles/about-archiving-repositories&quot; target=&quot;_blank&quot;&gt;已存档&lt;/a&gt;来搜索仓库。&lt;/p&gt;
&lt;h3 id=&quot;基于具有-good-first-issue-或-help-wanted-标签的议题数量搜索&quot;&gt;基于具有 &lt;code&gt;good first issue&lt;/code&gt; 或 &lt;code&gt;help wanted&lt;/code&gt; 标签的议题数量搜索&lt;/h3&gt;
&lt;p&gt;您可以使用限定符 &lt;code&gt;help-wanted-issues:&amp;gt;n&lt;/code&gt; 和 &lt;code&gt;good-first-issues:&amp;gt;n&lt;/code&gt; 搜索具有最少数量标签为 &lt;code&gt;help-wanted&lt;/code&gt; 或 &lt;code&gt;good-first-issue&lt;/code&gt; 议题的仓库。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;限定符&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.4238410596026&quot;&gt;&lt;tr readability=&quot;2.4076433121019&quot;&gt;&lt;td&gt;&lt;code&gt;good-first-issues:&amp;gt;n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=javascript+good-first-issues%3A%3E2&amp;amp;type=&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;good-first-issues:&amp;gt;2 javascript&lt;/strong&gt;&lt;/a&gt; 匹配具有超过两个标签为 &lt;code&gt;good-first-issue&lt;/code&gt; 的议题且包含 &quot;javascript&quot; 字样的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.4375&quot;&gt;&lt;td&gt;&lt;code&gt;help-wanted-issues:&amp;gt;n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/search?utf8=%E2%9C%93&amp;amp;q=react+help-wanted-issues%3A%3E4&amp;amp;type=&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;help-wanted-issues:&amp;gt;4 react&lt;/strong&gt;&lt;/a&gt; 匹配具有超过四个标签为 &lt;code&gt;help-wanted&lt;/code&gt; 的议题且包含 &quot;React&quot; 字样的仓库。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;学习&quot;&gt;学习&lt;/h2&gt;
&lt;p&gt;其实，以上很多内容的都是来自于 GitHub 的官方文档，如果你还想学习更多技巧，请看&lt;/p&gt;
&lt;blockquote readability=&quot;0.3125&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.github.com/cn&quot; target=&quot;_blank&quot;&gt;GitHub 官方文档&lt;/a&gt; : &lt;a href=&quot;https://docs.github.com/cn&quot; target=&quot;_blank&quot;&gt;https://docs.github.com/cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-e551732946f5ba62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-4bb6234d4ddd0d55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你还不了解或者不会使用 GitHub ，可以看看这一章节：&lt;/p&gt;
&lt;blockquote readability=&quot;0.16326530612245&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/git-and-github-learning-resources&quot; target=&quot;_blank&quot;&gt;Git 和 GitHub 学习资源&lt;/a&gt; ：&lt;a href=&quot;https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/git-and-github-learning-resources&quot; target=&quot;_blank&quot;&gt;https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/git-and-github-learning-resources&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-7a0a0ecfc8fa5b1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12890819-7bf0fb9f5c58e873.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;[前端GitHub] 地址：&lt;a href=&quot;https://github.com/biaochenxuying/FrontEndGitHub&quot; target=&quot;_blank&quot;&gt;https://github.com/biaochenxuying/FrontEndGitHub&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;平时如何发现好的开源项目，可以看看这篇文章：&lt;a href=&quot;https://github.com/biaochenxuying/blog/issues/45&quot; target=&quot;_blank&quot;&gt;GitHub 上能挖矿的神仙技巧 - 如何发现优秀开源项目&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;觉得有用 ？喜欢就收藏，顺便点个赞吧，你的支持是我最大的鼓励！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;往期精文&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 Dec 2020 14:31:00 +0000</pubDate>
<dc:creator>天明夜尽</dc:creator>
<og:description>大家好，我是你们的 前端章鱼猫，一个不喜欢喵、又不喜欢吃鱼的超级猫 ~ 今天给大家带来的是 在 GitHub 上如何精准搜索的神仙技巧。 【前端GitHub：https://github.com/bi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/biaochenxuying/p/14136094.html</dc:identifier>
</item>
</channel>
</rss>