<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SpringBoot 配置的加载 - zhouweixin</title>
<link>http://www.cnblogs.com/zhouweixin/p/13698466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouweixin/p/13698466.html</guid>
<description>&lt;p&gt;SpringBoot配置及环境变量的加载提供许多便利的方式，接下来一起来学习一下吧!&lt;/p&gt;
&lt;p&gt;本章内容的源码按实战过程采用小步提交，可以按提交的节点一步一步来学习，仓库地址：&lt;a href=&quot;https://github.com/zhouweixin/spring-boot-configuration%E3%80%82&quot;&gt;https://github.com/zhouweixin/spring-boot-configuration。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;java: 1.8.0_265&lt;/li&gt;
&lt;li&gt;gradle: 6.6.1&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1-准备&quot;&gt;1 准备&lt;/h2&gt;
&lt;p&gt;用你喜欢的方式创建一个SpringBoot工程，并写一个hello的接口，及相应的集成测试，进行实验吧！&lt;/p&gt;
&lt;h3 id=&quot;11-hello接口代码&quot;&gt;1.1 hello接口代码&lt;/h3&gt;
&lt;p&gt;HelloController.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class HelloController {
    @GetMapping(&quot;/hello&quot;)
    public String hello() {
        return &quot;Hello world!&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;12-hello集成测试代码&quot;&gt;1.2 hello集成测试代码&lt;/h3&gt;
&lt;p&gt;HelloControllerTest.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootTest
@AutoConfigureMockMvc
class HelloControllerTest {
    @Autowired
    MockMvc mockMvc;

    @Test
    void hello() throws Exception {
        mockMvc.perform(MockMvcRequestBuilders.get(&quot;http://localhost:8080/hello&quot;))
                .andExpect(MockMvcResultMatchers.status().isOk())
                .andExpect(MockMvcResultMatchers.jsonPath(&quot;$&quot;, Matchers.is(&quot;Hello world!&quot;)));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2-注解value&quot;&gt;2 注解@Value&lt;/h2&gt;
&lt;h3 id=&quot;21-介绍&quot;&gt;2.1 介绍&lt;/h3&gt;
&lt;p&gt;@Value通过直接注解在属性上为属性设置&lt;/p&gt;
&lt;p&gt;如下所示，为name设置值为tangseng&lt;/p&gt;
&lt;p&gt;HelloController.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;tangseng&quot;)
private String name;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22-加载配置文件&quot;&gt;2.2 加载配置文件&lt;/h3&gt;
&lt;p&gt;当然，上面的写法不涉及配置文件的读取，但是从配置文件加载数据也是同样简单&lt;/p&gt;
&lt;p&gt;如下所示，在${}中用json的方式设置配置文件中设置的key值&lt;/p&gt;
&lt;p&gt;HelloController.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;${value.string}&quot;)
private String valueString;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件的内容为&lt;/p&gt;
&lt;p&gt;application.properties&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;value.string=sunwukong
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;23-数据类型转换&quot;&gt;2.3 数据类型转换&lt;/h3&gt;
&lt;p&gt;当然，@Value的功能还远不止于此，它可以实现数据类型的转换&lt;/p&gt;
&lt;p&gt;即，在配置文件中配置的所有内容是没有数据类型的，@Value会根据属性的类型，实现自动转换&lt;/p&gt;
&lt;p&gt;如下所示，基本数据类型@Value注解都是可以正确转换的，使用起来有没有感觉很简单呢？&lt;/p&gt;
&lt;p&gt;application.properties&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;value.int=1
value.float=1.11
value.string=sunwukong
value.bool=true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HelloController.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;${value.int}&quot;)
private int valueInt;

@Value(&quot;${value.float}&quot;)
private float valueFloat;

@Value(&quot;${value.string}&quot;)
private String valueString;

@Value(&quot;${value.bool}&quot;)
private boolean valueBool;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;24-默认值&quot;&gt;2.4 默认值&lt;/h3&gt;
&lt;p&gt;写到这里，你肯定认为@Value注解的功能就结束了&lt;/p&gt;
&lt;p&gt;然而，并没有，@Value还可以设置默认值&lt;/p&gt;
&lt;p&gt;即，假如配置文件中没有配置该属性，也可以有默认值兜底的&lt;/p&gt;
&lt;p&gt;默认值的设置格式如下所示&lt;/p&gt;
&lt;p&gt;HelloController.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;${value.double:2.22}&quot;)
private double valueDouble;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;25-时间转换&quot;&gt;2.5 时间转换&lt;/h3&gt;
&lt;p&gt;这次，你一定又一次认为@Value的学习结束了，但是想再分享@Value对时间的处理，因为实际项目中经常会配置超时时间等类似的时间，比较实用&lt;/p&gt;
&lt;p&gt;假如配置文件里配置了&lt;code&gt;timeout=60&lt;/code&gt;，你认为是60s呢还是60ms，或是60m，是不是有点不清楚呢？&lt;/p&gt;
&lt;p&gt;因此，多是配置成&lt;code&gt;timeout=60s&lt;/code&gt;, 利用@DurationUnit进行单位的转换&lt;/p&gt;
&lt;p&gt;还是看个例子比较直观些&lt;/p&gt;
&lt;p&gt;首先配置一个&lt;code&gt;10分钟&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;application.properties&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;value.time=10m
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后用&lt;code&gt;秒&lt;/code&gt;去解析，看看结果是否正确，这里悄悄告诉你，结果依然是正确的，转成了&lt;code&gt;600s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;HelloController.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;${value.time}&quot;)
@DurationUnit(ChronoUnit.SECONDS)
private Duration time;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;26-集成测试&quot;&gt;2.6 集成测试&lt;/h3&gt;
&lt;p&gt;接下来，写个接口及集成测试，测试一下结果&lt;/p&gt;
&lt;p&gt;HelloController.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@GetMapping(&quot;/helloValue&quot;)
public Object helloValue() {
    Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    map.put(&quot;name&quot;, name);
    map.put(&quot;valueInt&quot;, valueInt);
    map.put(&quot;valueFloat&quot;, valueFloat);
    map.put(&quot;valueString&quot;, valueString);
    map.put(&quot;valueBool&quot;, valueBool);
    map.put(&quot;valueDouble&quot;, valueDouble);
    return map;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HelloControllerTest.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
void helloValue() throws Exception {
    mockMvc.perform(MockMvcRequestBuilders.get(&quot;http://localhost:8080/helloValue&quot;))
            .andExpect(MockMvcResultMatchers.status().isOk())
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.name&quot;, Matchers.is(&quot;tangseng&quot;)))
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.valueInt&quot;, Matchers.is(1)))
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.valueFloat&quot;, Matchers.is(1.11)))
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.valueString&quot;, Matchers.is(&quot;sunwukong&quot;)))
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.valueBool&quot;, Matchers.is(true)))
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.valueDouble&quot;, Matchers.is(2.22)))
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.time&quot;, Matchers.is(&quot;600s&quot;)));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然也可以用请求查看一下结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl http://localhost:8080/helloValue
{&quot;valueString&quot;:&quot;sunwukong&quot;,&quot;name&quot;:&quot;tangseng&quot;,&quot;valueDouble&quot;:2.22,&quot;time&quot;:&quot;600s&quot;,&quot;valueInt&quot;:1,&quot;valueFloat&quot;:1.11,&quot;valueBool&quot;:true}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-注解configurationproperties&quot;&gt;3 注解@ConfigurationProperties&lt;/h2&gt;
&lt;h3 id=&quot;31-介绍&quot;&gt;3.1 介绍&lt;/h3&gt;
&lt;p&gt;@ConfigurationProperties实现了更加丰富的功能，但是该属性需要配置@ConfigurationPropertiesScan使用&lt;/p&gt;
&lt;p&gt;即，首先需要将@ConfigurationPropertiesScan注解到启动类上，即XxxApplication.java&lt;/p&gt;
&lt;p&gt;然后便可以利用@ConfigurationProperties上&lt;/p&gt;
&lt;p&gt;@ConfigurationProperties是用来注解类上，用来批量从配置文件中加载数据&lt;/p&gt;
&lt;p&gt;比如，配置中有如下属性&lt;/p&gt;
&lt;p&gt;application.properties&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;student.name=xiaoming
student.email=123456@qq.com
student.age=18
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;便可以定义Student类，并将@ConfigurationProperties注解其上&lt;/p&gt;
&lt;p&gt;注意：属性名需要和配置文件里对应的名字相同，你肯定观察到了&lt;/p&gt;
&lt;p&gt;Student.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ConfigurationProperties(&quot;student&quot;)
public class Student {
    private String name;
    private String email;
    private int age;
    
    // ... 省略setter, getter方法， setter方法必须有
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-加载集合数据&quot;&gt;3.2 加载集合数据&lt;/h3&gt;
&lt;p&gt;@ConfigurationProperties除了可以读单值数据，也可以读List和Map数据&lt;/p&gt;
&lt;p&gt;比如，配置文件里有如下配置&lt;/p&gt;
&lt;p&gt;application.properties&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;# class.list
student.friends[0]=zhubajie
student.friends[1]=shaheshang

# class.map
student.parent.father=tangseng
student.parent.mother=nverguoguowang
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要在Student类中再添加两个属性即可，不要忘记setter和getter方法哟&lt;/p&gt;
&lt;p&gt;Student.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private List&amp;lt;String&amp;gt; friends;
private Map&amp;lt;String, String&amp;gt; parent;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加getStudent接口&lt;/p&gt;
&lt;p&gt;HelloController.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@GetMapping(&quot;/getStudent&quot;)
public Student getStudent() {
    return student;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33-集成测试&quot;&gt;3.3 集成测试&lt;/h3&gt;
&lt;p&gt;HelloControllerTest.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
void getStudent() throws Exception {
    mockMvc.perform(MockMvcRequestBuilders.get(&quot;http://localhost:8080/getStudent&quot;))
            .andExpect(MockMvcResultMatchers.status().isOk())
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.name&quot;, Matchers.is(&quot;xiaoming&quot;)))
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.email&quot;, Matchers.is(&quot;123456@qq.com&quot;)))
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.age&quot;, Matchers.is(18)))
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.friends[0]&quot;, Matchers.is(&quot;zhubajie&quot;)))
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.friends[1]&quot;, Matchers.is(&quot;shaheshang&quot;)))
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.parent.father&quot;, Matchers.is(&quot;tangseng&quot;)))
            .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.parent.mother&quot;, Matchers.is(&quot;nverguoguowang&quot;)));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接求观测也是可以的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl http://localhost:8080/getStudent
{&quot;name&quot;:&quot;xiaoming&quot;,&quot;email&quot;:&quot;123456@qq.com&quot;,&quot;age&quot;:18,&quot;friends&quot;:[&quot;zhubajie&quot;,&quot;shaheshang&quot;],&quot;parent&quot;:{&quot;father&quot;:&quot;tangseng&quot;,&quot;mother&quot;:&quot;nverguoguowang&quot;}}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 19 Sep 2020 18:45:00 +0000</pubDate>
<dc:creator>zhouweixin</dc:creator>
<og:description>SpringBoot 配置的加载 SpringBoot配置及环境变量的加载提供许多便利的方式，接下来一起来学习一下吧! 本章内容的源码按实战过程采用小步提交，可以按提交的节点一步一步来学习，仓库地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhouweixin/p/13698466.html</dc:identifier>
</item>
<item>
<title>位运算的应用 - fourther</title>
<link>http://www.cnblogs.com/fourther/p/13698424.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fourther/p/13698424.html</guid>
<description>&lt;p&gt;平常都很少用到位运算，这里介绍一种&lt;code&gt;jdk&lt;/code&gt;使用位运算的小案例。它是用位运算来优化一个类所占的大小。下面介绍：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么情况下，符合这种优化条件；&lt;/li&gt;
&lt;li&gt;用具体的例子来介绍；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;优化情况&quot;&gt;优化情况&lt;/h4&gt;
&lt;p&gt;假设一个类需要有很多&lt;code&gt;boolean&lt;/code&gt;类型得属性，如果直接用&lt;code&gt;boolean&lt;/code&gt;类型，那么这个类会在内存中占用很大空间。通常情况下，一个&lt;code&gt;boolean&lt;/code&gt;类型属性会占4个字节。&lt;a href=&quot;https://www.cnblogs.com/wangtianze/p/6690665.html?utm_source=itdadao&amp;amp;utm_medium=referral&quot;&gt;但这不是一定得，JAVA得boolean属性占用字节不一定&lt;/a&gt;。这时候，使用多个&lt;code&gt;boolean&lt;/code&gt;类型的属性就占用很多内存。&lt;/p&gt;
&lt;p&gt;在这种情况下，可以使用字节得0、1来代表true、false。使用位运算来获取、设置boolean属性得值。比如说：我们可以使用&lt;code&gt;int&lt;/code&gt;来存储32个boolean属性，这样就会节省大量的内存。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;JDK&lt;/code&gt;中有具体得例子，如&lt;code&gt;java.lang.reflect.Modifier&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;具体例子&quot;&gt;具体例子&lt;/h4&gt;
&lt;p&gt;假设一个猫有三个属性：&lt;code&gt;cute&lt;/code&gt;、&lt;code&gt;fat&lt;/code&gt;、&lt;code&gt;white&lt;/code&gt;，其取值只有俩种true、false。现在用int的后面三个位来存储这三个类型的值。&lt;br/&gt;即：在&lt;code&gt;int&lt;/code&gt;最后一个位作为&lt;code&gt;cute&lt;/code&gt;属性得值；倒数第二位作为&lt;code&gt;fat&lt;/code&gt;属性得值；倒数第三位作为&lt;code&gt;white&lt;/code&gt;属性得值。&lt;/p&gt;
&lt;p&gt;1、创建&lt;code&gt;int&lt;/code&gt;属性得值，作为存储这三个属性得属性值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Cat {
    // 存储三个boolean属性得值
    private int properties = 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1227210/202009/1227210-20200920021225424-1522172882.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、设置三个&lt;code&gt;int&lt;/code&gt;属性作为三个属性都为true；这是为了后期方便设置值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Cat {
    private static int CUTE = 0x1;
    private static int FAT = 0x2;
    private static int WHITE = 0x4;
    private int properties = 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、以&lt;code&gt;cute&lt;/code&gt;属性的获取、设置&lt;br/&gt;（1）获取值的时候&lt;br/&gt;指获取&lt;code&gt;properties&lt;/code&gt;属性的最后一位的值，需要注意的是获取最后一位值得时候，不能影响其他位得值！！！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * 这只猫萌吗？请在此处使用位运算读取properties，得到猫是否萌的结果
     *
     * @return 萌则返回true，否则返回false
     */
    public boolean isCute() {
        return (properties &amp;amp; Cat.CUTE) != 0;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用与运算得时候，其他位不受影响；最后一位也是取决于&lt;code&gt;properties&lt;/code&gt;最后一位得值&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1227210/202009/1227210-20200920021308050-130461180.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（2）设置值的时候&lt;br/&gt;在设置&lt;code&gt;properties&lt;/code&gt;属性得最后一位得值，需要注意得是设置最后一位的值的时候，不能影响其他位得值！！！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * 使用位运算设置猫咪萌的属性
     *
     * @param cute true为萌，false为不萌
     */
    public void setCute(boolean cute) {
        if (cute == true){
            properties = properties | Cat.CUTE;
        } else {
            properties = properties &amp;amp; (~Cat.CUTE);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1227210/202009/1227210-20200920021329084-929330893.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、设置其他属性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * 使用位运算设置猫咪胖的属性
     *
     * @param fat true为胖，false为不胖
     */
    public void setFat(boolean fat) {
        if (fat){
            properties = properties | Cat.FAT;
        } else {
            properties = properties &amp;amp; (~Cat.FAT);
        }
    }

    /**
     * 这只猫胖吗？请在此处使用位运算读取properties，得到猫是否胖的结果
     *
     * @return 胖则返回true，否则返回false
     */
    public boolean isFat() {
        return (properties &amp;amp; Cat.FAT) != 0;
    }

    /**
     * 使用位运算设置猫咪白的属性
     *
     * @param white true为白，false为不白
     */
    public void setWhite(boolean white) {
        if (white){
            properties = properties | Cat.WHITE;
        } else {
            properties = properties &amp;amp; (~Cat.WHITE);
        }
    }

    /**
     * 这只猫白吗？请在此处使用位运算读取properties，得到猫是否白的结果
     *
     * @return 白则返回true，否则返回false
     */
    public boolean isWhite() {
        return (properties &amp;amp; Cat.WHITE) != 0;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;一般情况下，获取值使用&lt;code&gt;&amp;amp;&lt;/code&gt;；设置值使用&lt;code&gt;|&lt;/code&gt;、&lt;code&gt;~&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;。关键就是在使用位运算的时候，只影响指定位置的值，其他位置的值不能改变。完整代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Cat {
    private static int CUTE = 0x1;
    private static int FAT = 0x2;
    private static int WHITE = 0x4;
    private int properties = 0;

    /**
     * 使用位运算设置猫咪萌的属性
     *
     * @param cute true为萌，false为不萌
     */
    public void setCute(boolean cute) {
        if (cute == true){
            properties = properties | Cat.CUTE;
        } else {
            properties = properties &amp;amp; (~Cat.CUTE);
        }
    }

    /**
     * 这只猫萌吗？请在此处使用位运算读取properties，得到猫是否萌的结果
     *
     * @return 萌则返回true，否则返回false
     */
    public boolean isCute() {
        return (properties &amp;amp; Cat.CUTE) != 0;
    }

    /**
     * 使用位运算设置猫咪胖的属性
     *
     * @param fat true为胖，false为不胖
     */
    public void setFat(boolean fat) {
        if (fat){
            properties = properties | Cat.FAT;
        } else {
            properties = properties &amp;amp; (~Cat.FAT);
        }
    }

    /**
     * 这只猫胖吗？请在此处使用位运算读取properties，得到猫是否胖的结果
     *
     * @return 胖则返回true，否则返回false
     */
    public boolean isFat() {
        return (properties &amp;amp; Cat.FAT) != 0;
    }

    /**
     * 使用位运算设置猫咪白的属性
     *
     * @param white true为白，false为不白
     */
    public void setWhite(boolean white) {
        if (white){
            properties = properties | Cat.WHITE;
        } else {
            properties = properties &amp;amp; (~Cat.WHITE);
        }
    }

    /**
     * 这只猫白吗？请在此处使用位运算读取properties，得到猫是否白的结果
     *
     * @return 白则返回true，否则返回false
     */
    public boolean isWhite() {
        return (properties &amp;amp; Cat.WHITE) != 0;
    }

    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.setCute(true);
        cat.setFat(true);
        cat.setWhite(false);
        System.out.println(&quot;这只猫萌吗：&quot; + cat.isCute());
        System.out.println(&quot;这只猫胖吗：&quot; + cat.isFat());
        System.out.println(&quot;这只猫白吗：&quot; + cat.isWhite());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;位运算的一些坑&quot;&gt;位运算的一些坑&lt;/h2&gt;
&lt;p&gt;交换俩个值得功能可以用位运算这种骚操作完成。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) {
        Main main = new Main();
        int[] arr = {1,2};
        main.test(0,1,arr);
    }

    public void test(int a, int b, int[] arr){
        arr[a] = arr[a] ^ arr[b];
        arr[b] = arr[a] ^ arr[b];
        arr[a] = arr[a] ^ arr[b];
        System.out.println(Arrays.toString(arr));//[2,1]
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但这里有个坑，如果你传得俩个地址是一样得话，就会出错：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) {
        Main main = new Main();
        int[] arr = {1,2};
        main.test(0,0,arr);
    }

    public void test(int a, int b, int[] arr){
        arr[a] = arr[a] ^ arr[b];
        arr[b] = arr[a] ^ arr[b];
        arr[a] = arr[a] ^ arr[b];
        System.out.println(Arrays.toString(arr));//[0,1]
    }
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 19 Sep 2020 18:15:00 +0000</pubDate>
<dc:creator>fourther</dc:creator>
<og:description>平常都很少用到位运算，这里介绍一种jdk使用位运算的小案例。它是用位运算来优化一个类所占的大小。下面介绍： 什么情况下，符合这种优化条件； 用具体的例子来介绍； 优化情况 假设一个类需要有很多bool</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fourther/p/13698424.html</dc:identifier>
</item>
<item>
<title>神奇的莫队 - SD！LTF</title>
<link>http://www.cnblogs.com/sdltf/p/13698417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdltf/p/13698417.html</guid>
<description>&lt;h2 id=&quot;part--1-参考资料&quot;&gt;Part -1: 参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/WAMonster/p/10118934.html&quot;&gt;参考资料1&lt;/a&gt;&lt;br/&gt;万分感谢这个大佬，祝他报送清华北大！&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/255475031&quot;&gt;本文同步发表于知乎&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;part-0-一些介绍&quot;&gt;Part 0: 一些介绍&lt;/h2&gt;
&lt;p&gt;莫队由莫涛神仙首次提出，是一种区间操作算法。&lt;/p&gt;
&lt;p&gt;即便是板子题，难度也很高（差评）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920010238787-1309158580.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，在阅读后文之前，请你先深呼吸，喝杯咖啡，吃点饼干，听听自己喜欢的歌&lt;/p&gt;
&lt;p&gt;然后，&lt;s&gt;停止呼吸&lt;/s&gt;，放下杯子，扔开饼干，摘下耳机，接受莫涛大神思想光辉的洗礼&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;part-1：莫队算法的引入&quot;&gt;Part 1：莫队算法的引入&lt;/h2&gt;
&lt;p&gt;先别谈莫队，我们来回顾一下，遇到&lt;strong&gt;区间问题&lt;/strong&gt;一般怎么解决？&lt;/p&gt;
&lt;p&gt;很好，&lt;s&gt;暴力&lt;/s&gt;线段树&lt;/p&gt;
&lt;p&gt;也就是说，我们一直在通过维护两个序列——左序列&lt;span class=&quot;math inline&quot;&gt;\([l,mid]\)&lt;/span&gt;与右序列&lt;span class=&quot;math inline&quot;&gt;\([mid + 1,r]\)&lt;/span&gt;，从而来维护&lt;span class=&quot;math inline&quot;&gt;\([l, r]\)&lt;/span&gt;，当然，这个操作会一直递归下去&lt;/p&gt;
&lt;p&gt;然而，当题目这么问：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;令数组&lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt;大小为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;且每个元素&lt;span class=&quot;math inline&quot;&gt;\(Q_i &amp;lt; n\)&lt;/span&gt;，有&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个询问，每次询问给定&lt;span class=&quot;math inline&quot;&gt;\(l,r\)&lt;/span&gt;，请找出&lt;span class=&quot;math inline&quot;&gt;\([l,r]\)&lt;/span&gt;中至少重复出现&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;此的数字的个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;换句话说：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在&lt;span class=&quot;math inline&quot;&gt;\(Q_l\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(Q_r\)&lt;/span&gt;内找出现次数多余&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;的数字的个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;of course，你可以暴力，&lt;s&gt;但你会暴零&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;那么我们试着用线段树，首先，你需要维护左边的序列，然后你需要维护右边的序列，然后……&lt;/p&gt;
&lt;p&gt;然后你会发现很难做到短时间甚至&lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;的时间完成对线段树单一节点的维护，因为你总是要层层递进向上叠加。&lt;/p&gt;
&lt;p&gt;淦！这不是欺负人吗&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920011024381-1394176051.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们先试试暴力吧，用个&lt;span class=&quot;math inline&quot;&gt;\(count\)&lt;/span&gt;记录一下出现次数，然后在扫一遍&lt;/p&gt;
&lt;p&gt;暴力是万能的，答案当然正确，但是你的时间复杂度哭了——&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920011512026-534235019.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我们可以看看是否可以改进一下，用上&lt;span class=&quot;math inline&quot;&gt;\(t(wo)p(oints)\)&lt;/span&gt;算法：&lt;/p&gt;
&lt;p&gt;假设有两个指针，&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;，每次询问的时候用移动&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;的方式来尝试和要求区间重合&lt;/p&gt;
&lt;p&gt;是不是有点蒙？我举个栗子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920012714272-1776494199.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此图中，两个Q是待求的区间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920012912934-1896050605.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初始化&lt;span class=&quot;math inline&quot;&gt;\(r = 0,l = 1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此时，发现&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;和要求的区间左端重合了，而&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;没有，那么我们把&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;往右边移动一位&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920013152914-418772590.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;发现了一个新的值&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;，总数记录一下，继续右移动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920013305117-231592410.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;又发现了一个新数值&lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt;，总数记录一下，继续右移动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920013414774-1665191379.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此处&lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt;被记录过了，总数值不变&lt;/p&gt;
&lt;p&gt;一直到&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;与右端点重合，得到下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920013608009-1205564696.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个区间就算处理完了，我们来看下一个&lt;/p&gt;
&lt;p&gt;首先，&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;不在左端点，我们把它右移&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920013722088-1872961366.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一次，&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;所遇到的数值在区间&lt;span class=&quot;math inline&quot;&gt;\([l, r]\)&lt;/span&gt;只能够存在，总数不变&lt;/p&gt;
&lt;p&gt;下一次也是如此，一直到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920013823457-48492137.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你会发现，这时，区间&lt;span class=&quot;math inline&quot;&gt;\([l,r]\)&lt;/span&gt;将（也就是在下一次移动后）不会有&lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt;存在了，那么总数就一个&lt;span class=&quot;math inline&quot;&gt;\(-1\)&lt;/span&gt;，而正好本题需要统计的就是区间内数值的个数，总数改变：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920014200530-1481096130.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如此循环往复，得到最终答案，所以我们可以得出这个代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;int arr[maxn], cnt[maxn]   // 每个位置的数值、每个数值的计数器
int l = 1, r = 0, now = 0; // 左指针、右指针、当前统计结果（总数）
void add(int pos) {             // 添加一个数
    if(!cnt[arr[pos]]) ++ now;  // 在区间中新出现，总数要+1
    ++ cnt[arr[pos]];
}
void del(int pos) {             // 删除一个数
    -- cnt[arr[pos]];
    if(!cnt[arr[pos]]) -- now;  // 在区间中不再出现，总数要-1
}
void work() {
    for(int i = 1; i &amp;lt;= q; i ++) {
        int ql, qr;
        scanf(&quot;%d%d&quot;, &amp;amp;ql, &amp;amp;qr);    
        while(l &amp;lt; ql) del(l++); // 左指针在查询区间左方，左指针向右移直到与查询区间左端点重合
        while(l &amp;gt; ql) add(--l); // 左指针在查询区间左端点右方，左指针左移
        while(r &amp;lt; qr) add(++r); // 右指针在查询区间右端点左方，右指针右移
        while(r &amp;gt; qr) del(r--); // 否则左移
        printf(&quot;%d\n&quot;, now);    // 输出统计结果
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;嗯，干得漂亮，但是这是莫队吗？不是&lt;/p&gt;
&lt;p&gt;如果区间特别多，&lt;span class=&quot;math inline&quot;&gt;\(l,r\)&lt;/span&gt;反复横跳，结果皮断了腿，时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(nm)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920014736877-1007053454.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么现在的问题已经变成了：&lt;strong&gt;如何尽量减少&lt;span class=&quot;math inline&quot;&gt;\(l,r\)&lt;/span&gt;移动的次数&lt;/strong&gt;？&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;part-2：莫队的正确打开方式&quot;&gt;Part 2：莫队的正确打开方式&lt;/h2&gt;
&lt;p&gt;首先，看到尽量减少&lt;span class=&quot;math inline&quot;&gt;\(l,r\)&lt;/span&gt;移动的次数，我们会想到排个序&lt;/p&gt;
&lt;p&gt;排序排什么的顺序呢？是排端点吗？显然不是，哪怕左端点有序，右端点就会杂乱无章；右端点有序，左端点就会杂乱无章……&lt;/p&gt;
&lt;p&gt;这里，我们运用一下&lt;strong&gt;分块&lt;/strong&gt;的思想，把序列分为&lt;span class=&quot;math inline&quot;&gt;\(\sqrt{n}\)&lt;/span&gt;块，把查询区间按照左端点所在块的序号排个序，如果左端点所在块相同，再按右端点排序。&lt;/p&gt;
&lt;p&gt;这个算法需要的时间复杂度为&lt;span class=&quot;math inline&quot;&gt;\(sort+move_{\texttt{左指针}}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;span class=&quot;math inline&quot;&gt;\(sort\)&lt;/span&gt;的时间复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(n\log n)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(move_{\texttt{做指针}}\)&lt;/span&gt;的时间复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(n\sqrt{n})\)&lt;/span&gt;，那么总的时间复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(n\sqrt{n})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;好耶！降了一个根号！鼓掌！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920015536022-642156339.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其次，我们需要考虑一下更新的策略&lt;/p&gt;
&lt;p&gt;一般来说，我们只要找到指针移动一位以后，统计数据与当前数据的差值，找出规律（可以用数学方法或打表），然后每次移动时用这个规律更新就行&lt;/p&gt;
&lt;p&gt;最后给出总代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

#define maxn 1010000
#define maxb 1010
int aa[maxn], cnt[maxn], belong[maxn];
int n, m, size, bnum, now, ans[maxn];
struct query {
        int l, r, id;
} q[maxn];

int cmp(query a, query b) {
        return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &amp;lt; belong[b.l] : ((belong[a.l] &amp;amp; 1) ? a.r &amp;lt; b.r : a.r &amp;gt; b.r);
}
#define isdigit(x) ((x) &amp;gt;= '0' &amp;amp;&amp;amp; (x) &amp;lt;= '9')
int read() {
        int res = 0;
        char c = getchar();
        while(!isdigit(c)) c = getchar();
        while(isdigit(c)) res = (res &amp;lt;&amp;lt; 1) + (res &amp;lt;&amp;lt; 3) + c - 48, c = getchar();
        return res;
}
void printi(int x) {
        if(x / 10) printi(x / 10);
        putchar(x % 10 + '0');
}

int main() {
        scanf(&quot;%d&quot;, &amp;amp;n);
        size = sqrt(n);
        bnum = ceil((double)n / size);
        for(int i = 1; i &amp;lt;= bnum; ++i) 
                for(int j = (i - 1) * size + 1; j &amp;lt;= i * size; ++j) {
                        belong[j] = i;
                }
        for(int i = 1; i &amp;lt;= n; ++i) aa[i] = read(); 
        m = read();
        for(int i = 1; i &amp;lt;= m; ++i) {
                q[i].l = read(), q[i].r = read();
                q[i].id = i;
        }
        sort(q + 1, q + m + 1, cmp);
        int l = 1, r = 0;
        for(int i = 1; i &amp;lt;= m; ++i) {
                int ql = q[i].l, qr = q[i].r;
                while(l &amp;lt; ql) now -= !--cnt[aa[l++]];
                while(l &amp;gt; ql) now += !cnt[aa[--l]]++;
                while(r &amp;lt; qr) now += !cnt[aa[++r]]++;
                while(r &amp;gt; qr) now -= !--cnt[aa[r--]];
                ans[q[i].id] = now;
        }
        for(int i = 1; i &amp;lt;= m; ++i) printi(ans[i]),putchar('\n');
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;part-3：关于莫队的一些卡常数&quot;&gt;Part 3：关于莫队的一些卡常数&lt;/h2&gt;
&lt;p&gt;卡常数作为OIer的家常便饭，相信大家一定不陌生了&lt;/p&gt;
&lt;p&gt;卡常数包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;位运算&lt;/li&gt;
&lt;li&gt;&lt;s&gt;O2&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;快读&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而莫队的神奇之处在于他的独特优化：奇偶性排序&lt;br/&gt;原代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;int cmp(query a, query b) {
    return belong[a.l] == belong[b.l] ? a.r &amp;lt; b.r : belong[a.l] &amp;lt; belong[b.l];
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;int cmp(query a, query b) {
        return (belong[a.l] ^ belong[b.l]) ? belong[a.l] &amp;lt; belong[b.l] : ((belong[a.l] &amp;amp; 1) ? a.r &amp;lt; b.r : a.r &amp;gt; b.r);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;别人说跑的很快我还不信，自己跑了一下才知道……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;真的跑的很快啊……&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;part-4-能修改的莫队&quot;&gt;Part 4: 能修改的莫队&lt;/h2&gt;
&lt;p&gt;我知道，你拿着上面别个大佬写的代码（再次膜拜写这个代码的大佬orz）兴冲冲的去刷题，一路上披荆斩棘，直到你看到了&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1903&quot;&gt;Luogu1903——国家集训队-数颜色&lt;/a&gt;，你彻底傻了眼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920020615224-1592005240.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;妈耶，他要是这么一修改我岂不是要重新sort？跑了跑了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1646455/202009/1646455-20200920020654168-199428239.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于莫队本身就是离线的，而你需要修改，得想个办法让他在线，具体做法是：“就是再弄一指针，在修改操作上跳来跳去，如果当前修改多了就改回来，改少了就改过去，直到次数恰当为止。”&lt;br/&gt;（再次感谢这个大佬，，好喜欢这个解释）&lt;/p&gt;
</description>
<pubDate>Sat, 19 Sep 2020 18:11:00 +0000</pubDate>
<dc:creator>SD！LTF</dc:creator>
<og:description>Part -1: 参考资料 参考资料1 万分感谢这个大佬，祝他报送清华北大！ 本文同步发表于知乎 Part 0: 一些介绍 莫队由莫涛神仙首次提出，是一种区间操作算法。 即便是板子题，难度也很高（差评</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdltf/p/13698417.html</dc:identifier>
</item>
<item>
<title>Jenkins持续集成git、gitlab、sonarqube(7.0)、nexus，自动化部署实战，附安装包，严禁转载！！！ - 陈彦斌</title>
<link>http://www.cnblogs.com/chenyanbin/p/qq543210188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyanbin/p/qq543210188.html</guid>
<description>&lt;p&gt;　　之前用的都是SVN，由于工作需要用到Git，&lt;span&gt;&lt;strong&gt;求人不如求己&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;技多不压身&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;多学一项技能&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;未来就少求别人一次&lt;/strong&gt;&lt;/span&gt;，系统的学一遍，自己搭建一整套环境，自动化部署(自动发版)，代码质量检测等等(&lt;span&gt;&lt;strong&gt;为啥不用docker搭建环境呢，个人平时比较忙，暂未学习docker，过段时间会学docker相关，也会写相应博文&lt;/strong&gt;&lt;/span&gt;)。为啥要打水印，Wechar上有人告诉我，之前很多博文，被某些网站白嫖，然后挂到自己网站(&lt;span&gt;&lt;strong&gt;未来博客上都会打水印&lt;/strong&gt;&lt;/span&gt;)，~@￥#%￥@%#@%￥再次声明，&lt;span&gt;&lt;strong&gt;创作不易，严禁转载！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;踩坑&lt;/h2&gt;
&lt;p&gt;　　从10月12、13(周末)天天搞到夜里2、3点，周一至周五，由于个人原因，刚换份工作，平时也忙，个人精力有限，只能晚上花2、3小时，学习-搭建-踩坑-度娘-搭建-成功，一直到今天，才完整的搭建出来，博客才发出来。安装过程中，并不是一帆风顺的，在此为了避免学习的小朋友踩相同的坑，最好版本和我一致，下面都会有提供我使用的安装包。&lt;span&gt;&lt;strong&gt;那些坑，我已经巧妙的绕开啦，按照我的步骤来，干就完事儿啦，欧力给~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;演示环境&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;mac系统&lt;/li&gt;
&lt;li&gt;虚拟机：Centos 6.5(&lt;span&gt;&lt;strong&gt;我分配了4G，2核，配置低了会卡！里面用到ES服务器配置低，服务起不来，ES脑补链接：&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/category/1811337.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;，磁盘至少分50G，当初我给了20G，最后服务配置太多以后，导致服务跑步起来你了&lt;/strong&gt;&lt;/span&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Git是什么&lt;/h2&gt;
&lt;p&gt;　　Git 是一个&lt;span&gt;&lt;strong&gt;开源&lt;/strong&gt;&lt;/span&gt;的&lt;span&gt;&lt;strong&gt;分布式版本控制&lt;/strong&gt;&lt;/span&gt;系统，用于&lt;span&gt;&lt;strong&gt;敏捷高效&lt;/strong&gt;&lt;/span&gt;地处理任何或小或大的&lt;span&gt;&lt;strong&gt;项目&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。&lt;/p&gt;
&lt;p&gt;　　Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。&lt;/p&gt;
&lt;h2&gt;Git的安装&lt;/h2&gt;
&lt;p&gt;　　官网地址：&lt;a href=&quot;https://git-scm.com/downloads&quot; target=&quot;_blank&quot;&gt;https://git-scm.com/downloads&lt;/a&gt;&lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　不要慌，最下面我会提供我使用的所有安装包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;linux：yum install -y git
mac：自带的有git
windows：需要自动手动下载,一直下一步即可&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200911225758950-147529876.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装git完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200911225824757-32561371.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　yum自动下载的git不是最新的，如果想安装最新的git版本，自行百度查，方法很多滴~由于时间关系，就不带领小伙伴实操啦，功能都大差不差的。&lt;/p&gt;
&lt;h2&gt;常用命令&lt;/h2&gt;
&lt;h3&gt;帮助&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1、git                       查看git的帮助文档
2、git --help              查看git的帮助文档
3、git add --help        查看某个命令的帮助文档&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200911230852528-521726819.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;版本号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200911231126386-13879443.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;生产空的本地仓库&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200911231402402-1023799257.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;将文件添加暂存区&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200911231614713-1281078212.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;提交&lt;/h3&gt;
&lt;p&gt;初次commit之前，需要配置用户邮箱及用户名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;git config --global user.email &quot;you@example.com&quot;
git config --global user.name &quot;Your Name&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;git commit：将暂存区的文件提交到本地仓库&lt;/p&gt;
&lt;h3&gt;远程仓库&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200911234821380-191021487.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;echo &quot;# git-test&quot; &amp;gt;&amp;gt; README.md
git init
git add README.md
git commit -m &quot;first commit&quot;
git branch -M master
git remote add origin https://github.com/543210188/git-test.git
git push -u origin master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200911235335477-1221222116.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200911235910337-309706799.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;推送&lt;/h3&gt;
&lt;p&gt;git push -u origin master：往名字为origin的仓库的master分支上提交变更&lt;/p&gt;
&lt;h3&gt;拉取&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1、git fetch       拉取远程仓库的变更到本地仓库
2、git merge origin/master    将远程的变更，合并到本地仓库的master分支

3、上面2个命令等价于 git pull&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;取消添加&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;git rm --cache 1.txt
注意：如果只是：git rm --cache，仅删除暂存区里的文件
如果不加--cache，会删除工作区里的文件，并提交到暂存区&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;恢复文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1、git checkout master 文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：直接加文件名，从暂存区将文件恢复到工作区，如果工作区已经有该文件，则会覆盖&lt;/p&gt;
&lt;p&gt;加了[分支名]+文件名，表示从分支名为所写的分支名中拉取文件，并覆盖工作区里的文件&lt;/p&gt;
&lt;h3&gt;git文件状态&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git status  查看git的状态
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;git图形化客户端&lt;/h2&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://www.sourcetreeapp.com/&quot; target=&quot;_blank&quot;&gt;https://www.sourcetreeapp.com/ &lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912095840924-2034244122.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;拉取代码&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912103906829-2020762343.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912103938860-353846100.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;分支&lt;/h2&gt;
&lt;p&gt;　　软件项目中&lt;strong&gt;&lt;span&gt;启动一套单独&lt;/span&gt;&lt;/strong&gt;的&lt;span&gt;&lt;strong&gt;开发路线&lt;/strong&gt;&lt;/span&gt;的方法，可以&lt;span&gt;&lt;strong&gt;避免版本兼容&lt;/strong&gt;&lt;/span&gt;开发问题，&lt;span&gt;&lt;strong&gt;避免&lt;/strong&gt;&lt;/span&gt;不同&lt;span&gt;&lt;strong&gt;版本&lt;/strong&gt;&lt;/span&gt;之&lt;span&gt;&lt;strong&gt;间&lt;/strong&gt;&lt;/span&gt;的&lt;span&gt;&lt;strong&gt;影响&lt;/strong&gt;&lt;/span&gt;，封装一个开发阶段，解决bug的时候新建分支，用于对该bug的研究。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912113527544-1344076103.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;创建分支&amp;amp;查看分支&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;创建分支：git branch 分支名
查看分支：git branch
注：列出所有的分支，分支前面有*号，代表当前所在那个分支&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912114121295-1543218506.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;删除分支&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;删除：git branch -d 分支名
注：不能删除当前所在的分支&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912114622016-1937477413.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;修改分支名&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
修改分支名：git branch -m 旧分支名 新分支名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912114834172-1473543640.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;开发v2.0版本分支(切换分支并推送到github)&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;切换分支：git checkout 分支名
注：如果在分支上面对文件进行修改之后，没有commit就切换到另外一个分支，是不允许的，必须commit之后，才能切换分支

强制切换分支：git checkout -f 分支名
注：强制切换分支，如果有未提交的变更，直接丢弃&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912121242014-239054329.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912121434916-470702573.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;查看历史&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
查看提交历史：git log&lt;br/&gt;查看最近2次的提交：git log -2&lt;br/&gt;查看最近2次提交差异：git log -p -2&lt;br/&gt;查看某个人提交的代码：git log --author 作者&lt;br/&gt;显示简要的信息：git log --oneline&lt;br/&gt;整个提交历史：git log --graph
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912122157045-1974075403.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;代码对比&lt;/h2&gt;
&lt;h3&gt;作用&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;解决冲突&lt;/li&gt;
&lt;li&gt;制作补丁&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;比较工作区跟暂存区的差异：git diff
比较暂存区与分支差异：git diff --cached 或者 --staged
跟当前分支比较：git diff HEAD&lt;br/&gt;比较当前分支与另外一个分支差异：git diff 分支名&lt;br/&gt;查看两个分支的差异(针对已提交)：git diff 分支名1 分支名2&lt;br/&gt;查看单纯的一个文件差异：git diff 文件名&lt;br/&gt;查看两次不同提交差异：git diff commitid_1 commitid_2&lt;br/&gt;查看有变更的文件：git diff --stat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912123924389-1424494273.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;git更改提交 &lt;/h2&gt;
&lt;h3&gt;用途&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;将暂存区中不必要的文件移除&lt;/li&gt;
&lt;li&gt;版本回滚&lt;/li&gt;
&lt;li&gt;只修改提交的摘要信息&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;把暂存区中的文件移除出来_1：git reset HEAD 文件名 
把暂存区中的文件移除出来_2：git reset HEAD^
修改暂存区中的摘要信息(需要重新提交git commit -m &quot;test&quot;)：git reset --soft HEAD^
丢失修改过的代码(重置代码)：git reset --hard HEAD^&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;分支合并冲突&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
分支合并(拿指定的分支名与当前分支进行合并)：git merge 分支名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912151204049-216168761.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912151440800-1085292584.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;冲突解决&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;合并分支：git merge 分支名
查看冲突文件(重要)：git diff --name-only --diff-filter=U&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;注：视情况，是只要master的代码还是v2.0(分支)代码，我这里处理是要2边的代码。 &lt;/strong&gt;&lt;/span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912152241884-1533004756.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;标签&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;打上标签(给最近的打上标签)：git tag 标签名
给指定的提交打上标签(git log获取commitid值，也就是获取提交的版本)：git tag 标签名 commitid
显示标签(以字母序，非时间)：git tag
显示该标签提交的那次相关信息：git show 标签名
删除标签(不会删除那次提交)：git tag -d 标签名
将标签推送到远程服务器上(标签必须存在)：git push origin 分支名 标签名
删除远程服务器上的标签：
1、删除本地的标签：git tag -d 标签名
2、删除远程的：git push origin :refs/tags/标签名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912155426637-145229282.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912155216335-2142677299.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;gitignore文件 &lt;/h2&gt;
&lt;h3&gt;用途&lt;/h3&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;忽略不必要的文件 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1、创建gitignore文件：touch .gitignore
2、在.gitignore添加忽略的目录：
target
.idea


.log：表示忽略项目中所有以.log结尾的文件
123?.log：表示忽略项目中所有以123加任意字符的文件 
/error.log：表示忽略项目中根目录中的error.log 这个文件 
src/main/test/：表示忽略/src/main/test/目录下的所有文件
*.class **/java/：匹配所有java目录下的所有文件
!/error.log：表示在之前的匹配规则下，被命中的文件，可以使用!对前面的规则进行否定&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;如果项目已经推送到远程服务器中，可通过这种方式删除
1、先删除本地暂存区文件(git rm -rf --cache target/)：git rm -rf --cache 目录名
2、提交：git commit -m &quot;删除本地暂存区&quot;
3、推送：git push&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912160620304-2092725218.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912160910931-767464669.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　GitLab 是一个用于仓库管理系统的开源项目，使用&lt;a href=&quot;https://baike.baidu.com/item/Git&quot; target=&quot;_blank&quot;&gt;Git&lt;/a&gt;作为代码管理工具，并在此基础上搭建起来的web服务。安装方法是参考GitLab在GitHub上的Wiki页面。&lt;/p&gt;
&lt;h2&gt;为什么要使用gitlab？ &lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;基础功能开源，可自行搭建&lt;/li&gt;
&lt;li&gt;可以进行权限控制，使代码对部分人可见&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;安装gitlab(Centos6.5)&lt;/h2&gt;
&lt;h3&gt;目录结构及说明&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/etc/gitlab/gitlab.rb          #gitlab配置文件
/opt/gitlab                    #gitlab的程序安装目录
/var/opt/gitlab                #gitlab目录数据目录
/var/opt/gitlab/git-data       #存放仓库数据
gitlab-ctl reconfigure         #重新加载配置
gitlab-ctl status              #查看当前gitlab所有服务运行状态
gitlab-ctl stop                #停止gitlab服务
gitlab-ctl stop nginx          #单独停止某个服务
gitlab-ctl tail                #查看所有服务的日志

Gitlab的服务构成：
nginx：                 静态web服务器
gitlab-workhorse        轻量级反向代理服务器
logrotate              日志文件管理工具
postgresql             数据库
redis                  缓存数据库
sidekiq                用于在后台执行队列任务（异步执行）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;官网&lt;/h3&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://about.gitlab.com/&quot; target=&quot;_blank&quot;&gt;https://about.gitlab.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;国内镜像：&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/&quot; target=&quot;_blank&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;在线下载及安装&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum install -y curl policycoreutils-python openssh-server        #安装依赖
wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6/gitlab-ce-13.1.11-ce.0.el6.x86_64.rpm --no-check-certificate  #centos6.5
rpm -ivh gitlab-ce-13.1.11-ce.0.el6.x86_64.rpm # 安装包gitlab
sudo service postfix start
sudo chkconfig postfix on&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;linux其他版本安装方式&lt;/h3&gt;
&lt;p&gt;　　centos其他版本下载包方式，当然啦，也&lt;span&gt;&lt;strong&gt;可以先把包下载到本地，然后在丢到linux，执行安装效果是一样的&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913115731207-248850992.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;修改对外开放域名或ip&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /etc/gitlab/gitlab.rb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开后有一行 external_url 的设置改成要对外开放 web 的 url ，&lt;br/&gt;例如我可以指定 git.chenyanbin.com&lt;br/&gt;只想內部使用也可以改成 http://192.168.199.199:8888 这样的内部IP地址.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913122257393-457504492.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
配置生效：gitlab-ctl reconfigure&lt;br/&gt;重启：gitlab-ctl restart
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
设置防火墙端口(防火墙已全部关闭的话，可忽略)：vim /etc/sysconfig/iptables
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912194704479-796888708.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;启动gitlab&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo gitlab-ctl reconfigure
sudo lokkit -s http -s ssh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;停止gitlab：gitlab-ctl stop
重启gitlab：gitlab-ctl start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;登录&lt;/h2&gt;
&lt;p&gt;　　注：第一次登录时，需要设置初始密码，然后用root+密码登录即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913123533655-741038749.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;创建项目并推送到gitlab&lt;/h2&gt;
&lt;p&gt;　　本地新建一个项目并用git，将文件夹推送到gitlab上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913125531851-1110979490.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913125607211-852823302.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;邮件服务&lt;/h2&gt;
&lt;h3&gt;作用&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;有合并请求时，邮件通知&lt;/li&gt;
&lt;li&gt;账号注册时，邮件验证&lt;/li&gt;
&lt;li&gt;修改密码时，通过邮件修改&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;步骤&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;开启QQ邮箱的smtp服务&lt;/li&gt;
&lt;li&gt;修改gitlab配置&lt;/li&gt;
&lt;li&gt;测试邮件服务是否正常&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200912234708661-1511804355.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;gitlab_rails['smtp_enable'] = true 
gitlab_rails['smtp_address'] = &quot;smtp.qq.com&quot; 
gitlab_rails['smtp_port'] = 465 
gitlab_rails['smtp_user_name'] = &quot;543210188@qq.com&quot; 
gitlab_rails['smtp_password'] = &quot;邮箱随机字符串&quot; 
gitlab_rails['smtp_domain'] = &quot;qq.com&quot; 
gitlab_rails['smtp_authentication'] = &quot;login&quot; 
gitlab_rails['smtp_enable_starttls_auto'] = true 
gitlab_rails['smtp_tls'] = true 
user['git_user_email'] = &quot;543210188@qq.com&quot; 
gitlab_rails['gitlab_email_from'] = '543210188@qq.com'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;重启配置文件：gitlab-ctl reconfigure
重启服务：gitlab-ctl restart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 测试邮件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;gitlab-rails console
Notify.test_email('543210188@qq.com','邮件测试','博客地址：https://www.cnblogs.com/chenyanbin/').deliver_now&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913143433606-1762708017.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;账号注册和分组&lt;/h2&gt;
&lt;h3&gt;用户注册(&lt;span&gt;未开启邮箱检验&lt;/span&gt;)&lt;/h3&gt;
&lt;p&gt;　　缺点：随便添加账户，乱注册，不符合企业管理标准&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913150104309-961310622.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913150128282-685713734.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;用户注册(邮箱校验)&lt;/h3&gt;
&lt;p&gt;　　开启校验并真实邮箱注册&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913151704974-521915125.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913151737351-380810035.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;创建组并邀请成员(&lt;span&gt;配置过邮件服务，会邮件提醒&lt;/span&gt;)&lt;/h3&gt;
&lt;h4&gt;访问权限&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;private：只有组成员才能看到&lt;/li&gt;
&lt;li&gt;Internal：只要登录的用户就能看到&lt;/li&gt;
&lt;li&gt;Public：所有人都能看到&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;组权限&lt;/h4&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;Guest：可以创建issue、发表评论，不能读写版本库&lt;/li&gt;
&lt;li&gt;Reporter：可以克隆代码，不能提交&lt;/li&gt;
&lt;li&gt;Developer(&lt;span&gt;&lt;strong&gt;推荐&lt;/strong&gt;&lt;/span&gt;)：可以克隆代码、开发、提交、push&lt;/li&gt;
&lt;li&gt;Master：可以创建项目、添加tag、保护分支、添加项目成员、编辑项目&lt;/li&gt;
&lt;li&gt;Owner：可以设置项目访问权限 - Visibility Level、删除项目、迁移项目、管理组成员&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913153338293-874968429.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913153410100-2096420564.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成随机密钥&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ssh-keygen -t rsa
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913155812781-1097899857.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;分支及标签保护&lt;/h2&gt;
&lt;h3&gt;为什么要保护分支？&lt;/h3&gt;
&lt;p&gt;　　保护特定的分支不被随便合并，以免影响相应的分支&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913165121851-907335129.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913172036428-173291513.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913173253310-1334021931.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913173517599-2072814616.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　自己部署好gitlab，然后赋予账户权限，体验下就好&lt;/p&gt;
&lt;p&gt;注：能push就能merge，相应的权限自我控制(master分支设置只能master可以合并)。 &lt;/p&gt;
&lt;p&gt;第二种方式合并请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913174846718-1158224250.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913174914817-62458949.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。&lt;/p&gt;
&lt;h2&gt;好处&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;节省人力成本&lt;/li&gt;
&lt;li&gt;加快软件开发进度&lt;/li&gt;
&lt;li&gt;实时交付&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;重要组件&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;gitlab&lt;/li&gt;
&lt;li&gt;Jenkins：持续集成引擎&lt;/li&gt;
&lt;li&gt;maven：构建&lt;/li&gt;
&lt;li&gt;sonarqube：代码质量管理&lt;/li&gt;
&lt;li&gt;JDK&lt;/li&gt;
&lt;li&gt;Tomcat&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;jdk和maven安装&lt;/h2&gt;
&lt;p&gt;jdk安装：&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/12843149.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;maven安装：&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/13662849.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;nexus私服安装&lt;/h2&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://www.sonatype.com/nexus/repository-oss/download&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　下面百度云盘也会提供哟~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200913213836017-829140289.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;解压&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar -zxvf nexus-3.27.0-03-unix.tar.gz -C /usr/local
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修改启动端口号&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /usr/local/nexus-3.27.0-03/etc/nexus-default.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200914213949978-1709293017.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;开启防火墙端口&lt;/h3&gt;
&lt;p&gt;　　注：因为我本地没有使用8081端口，所以默认端口可以使用。但是防火墙端口记得开放哟~ &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /etc/sysconfig/iptables
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200914214616612-735837311.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;重启防火墙&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service iptables restart
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;启动nexus&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;注意：jdk版本必须得1.8！！！nexus版本不同，可能需要的jdk版本不同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200914231443302-769316469.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;nexus不推荐使用root用户启动(可忽略)

也可以自己手动创建个用户，然后加入到组，赋予权限，步骤如下
1、useradd nexus
2、chown -R nexus:nexus xxxx/xxxx/nexus-3.27xxx/&lt;br/&gt;3、chown -R nexus:nexus xxxx/xxxx/sonatype-work/
4、su nexus
5、./nexus start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;踩了个坑&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200914231611381-1137454276.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;小技巧&lt;/h4&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;注：./nexus start，启动完成之后，查看nexus是否启动：ps aux|grep nexus，若没有启动的话，可以使用：./nexus run；此时启动项目就会提示哪里出错啦~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;访问&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200914232624206-1853457574.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;注：点击右上角登录，默认账号密码：admin/admin123；从nexus3.17以后，默认密码改为随机的了，文件路径在：/usr/local/sonatype-work/nexus3/admin.password里！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200914233858942-1273936158.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;修改最大文件数(默认1024)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200914234348747-924591816.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200914234634489-2087095822.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;注：记得重启！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;设置nexus开机自启动&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
 vim /etc/rc.d/rc.local 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200914235403083-1939250488.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;nexus安装及使用&lt;/h2&gt;
&lt;h3&gt;项目maven大概过程分析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200915000108101-1290019301.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;设置maven的setting.xml&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;settings &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
          xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pluginGroups&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;proxies&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ybchen-releases&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;admin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;admin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ybchen-snapshots&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;admin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;admin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mirrors&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;profiles&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ybchen&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;activation&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;activeByDefault&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;false&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;activeByDefault&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;activation&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 私有库地址&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;repositories&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;repository&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ybchen&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://192.168.199.199:8088/repository/maven-public/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;releases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;enabled&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;enabled&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;releases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;snapshots&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;enabled&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;enabled&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;snapshots&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;repository&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;repositories&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;插件库地址&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pluginRepositories&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pluginRepository&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ybchen&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://192.168.199.199:8088/repository/maven-public/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;releases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;enabled&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;enabled&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;releases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;snapshots&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;enabled&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;enabled&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;snapshots&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pluginRepository&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pluginRepositories&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;profiles&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;activeProfiles&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;activeProfile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ybchen&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;activeProfile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;activeProfiles&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;settings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;设置nexus的代理地址，并添加到组中&lt;/h3&gt;
&lt;p&gt;　　阿里云地址：http://maven.aliyun.com/nexus/content/groups/public/ &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200915214249491-1882267203.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;测试&lt;/h3&gt;
&lt;p&gt;　　本地库，我已经清空，所有下载的都会先去nexus看看，没有的话，才会走阿里云代理上下载，然后还会下载到nexus。  &lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200915221217254-1454376531.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;将本地jar上传至nexus&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200915223307185-835182963.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200915223659089-2075232877.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;distributionManagement&amp;gt;
    &amp;lt;repository&amp;gt;
        &amp;lt;id&amp;gt;ybchen-releases&amp;lt;/id&amp;gt;
        &amp;lt;name&amp;gt;Nexus Release Repository&amp;lt;/name&amp;gt;
        &amp;lt;url&amp;gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;xxx.xxx.xxx.xxx:port/repository/maven-releases/&amp;lt;/url&amp;gt;&lt;/span&gt;
    &amp;lt;/repository&amp;gt;
    &amp;lt;snapshotRepository&amp;gt;
        &amp;lt;id&amp;gt;ybchen-releases&amp;lt;/id&amp;gt;
        &amp;lt;name&amp;gt;Nexus Release Repository&amp;lt;/name&amp;gt;
        &amp;lt;url&amp;gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;xxxx.xxxx.xxx.xxx:port/repository/maven-snapshots/&amp;lt;/url&amp;gt;&lt;/span&gt;
    &amp;lt;/snapshotRepository&amp;gt;
&amp;lt;/distributionManagement&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;安装mysql&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/13144042.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;代码质量管理平台sonarQube安装及使用&lt;/h2&gt;
&lt;h3&gt;前置条件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;mysql 5.6 | 5.7&lt;/li&gt;
&lt;li&gt;jdk1.8&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 我使用的是7.0，版本要求：&lt;a href=&quot;https://docs.sonarqube.org/7.0/Requirements.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;a href=&quot;https://docs.sonarqube.org/7.9/requirements/requirements/&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200916222747488-145410555.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-7.0.zip&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;官网&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sonarqube.org/&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1、依赖：yum install unzip -y
2、解压：unzip sonarqube-7.0.zip 
3、移动：mv sonarqube-7.0 /usr/local/
4、切换： cd /usr/local/
5、登录mysql：mysql -u root -p
6、创建库：CREATE DATABASE sonar DEFAULT CHARACTER SET utf8;
7、退出mysql：exit
8、进入sonarqube：cd sonarqube-7.0/conf/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修改配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vim sonar.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;主要配置以下内容
sonar.jdbc.username=root
sonar.jdbc.password=root
sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&lt;/span&gt;&lt;span&gt;&amp;amp;characterEncoding&lt;/span&gt;=utf8&lt;span&gt;&amp;amp;rewriteBatchedStatements&lt;/span&gt;=true&lt;span&gt;&amp;amp;useConfigs&lt;/span&gt;=maxPerformance&lt;span&gt;&amp;amp;useSSL&lt;/span&gt;&lt;span&gt;=false
sonar.web.host=0.0.0.0
sonar.web.context=/sonar
sonar.web.port=9000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;启动&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;useradd sonar
chown -R sonar:sonar /usr/local/sonarqube-7.0
su sonar
cd /usr/local/sonarqube-7.0/bin/linux-x86-64/
./sonar.sh start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;访问&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;记得开放防火墙端口：9000，账号/密码：admin/admin&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919001951915-1087621668.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;汉化&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919003452658-1423757856.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　安装完，重启服务再次打开网页即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sonar7.0的中文包，网页在线安装不上，我是去github上下载，手动安装的，按照以下几步即可，下面我也会提供，我直接下载的是jar包，源码包还得编码(因为我懒)
1. 在https://github.com/SonarCommunity/sonar-l10n-zh，下载汉化包源码；
2. 本地打包，cmd里面，在解压包里面运行： mvn install 
3. 将打好的jar包，放到： sonarqube/extensions/plugins  目录先；
4. 重启sonar，即可&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体操作如下，github地址：&lt;a href=&quot;https://github.com/SonarQubeCommunity/sonar-l10n-zh&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919012354888-474918393.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919012430004-1732477344.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;使用&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;settings.xml
============================
&lt;/span&gt;&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;settings
    &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
          xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pluginGroups&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pluginGroups&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;proxies&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;proxies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servers&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mirrors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;maven代理开始&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;huaweicloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mirrorOf&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;*,!HuaweiCloudSDK&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mirrorOf&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;https://mirrors.huaweicloud.com/repository/maven/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aliyun&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aliyun Maven&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mirrorOf&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;*,!HuaweiCloudSDK&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mirrorOf&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mirror&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;maven代理结束&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mirrors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;profiles&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;sonar配置开始&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;sonar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;activation&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;activeByDefault&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;activeByDefault&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;activation&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;.jdbc.url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jdbc:mysql://192.168.199.199:3306/sonar?useUnicode=true&lt;span&gt;&amp;amp;amp;&lt;/span&gt;characterEncoding=utf8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sonar.jdbc.url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;.jdbc.username&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sonar.jdbc.username&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;.jdbc.password&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sonar.jdbc.password&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;.host.url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://192.168.199.199:9000/sonar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sonar.host.url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;sonar配置结束&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;profiles&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;settings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;git init
mvn clean install
mvn sonar:sonar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919152803604-53961896.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919152838847-516007499.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Jenkins&lt;/h2&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;p&gt;前置条件&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JDK(jdk8)；安装：&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/12843149.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;tomcat(tomcat9)；安装：&lt;a href=&quot;https://www.cnblogs.com/chenyanbin/p/12548645.html&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;jenkins下载：&lt;a href=&quot;https://www.jenkins.io/download/&quot; target=&quot;_blank&quot;&gt;点我直达&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919160433530-289245121.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;将jenkins放到tomcat中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919161352121-1266332598.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;问题排查(&lt;span&gt;重要&lt;/span&gt;)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;查看tomcat是否启动&lt;/li&gt;
&lt;li&gt;查看端口8080是否开启：netstat -tlun&lt;/li&gt;
&lt;li&gt;查看防火墙端口是否开启，记得重启防火墙&lt;/li&gt;
&lt;li&gt;查看tomcat日志：/var/soft/apache-tomcat-9.0.38/logs/catalina.out&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919161553850-1044639546.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;注：可以看到，地址被占用了！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;修改tomcat的端口号，我这里修改为：9999，记得防火墙！！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919163506881-1724122368.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;访问&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919163721464-672654315.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919163903056-291460049.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;安装推荐组件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919164506979-2003559144.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919164643470-1433842112.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;创建用户名密码&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919165528396-463266875.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;实例配置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919165646090-331801061.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;登录&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919165858264-317616050.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;插件安装及配置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919171814507-213909656.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919172114543-1724145693.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919172416804-289253408.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;系统配置&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;jdk&lt;/li&gt;
&lt;li&gt;maven&lt;/li&gt;
&lt;li&gt;sonarqube&lt;/li&gt;
&lt;li&gt;邮件&lt;/li&gt;
&lt;li&gt;gitlab授权&lt;/li&gt;
&lt;li&gt;免密登录&lt;/li&gt;
&lt;/ol&gt;&lt;h5&gt;配置jdk和maven&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919173012099-717099464.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;配置邮件&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919174010726-218996607.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;配置sonarqube&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919175803067-1678202661.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续到全局配置里设置sonarqube&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919180403896-618373839.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;授权登录&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919181620506-1975453850.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;生成密钥&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum -y install openssh-clients
ssh-keygen -t rsa&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919182058303-2029992963.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;生成的key放到gitlab&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
more ~/.ssh/id_rsa.pub
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919182950815-1255550059.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;创建项目&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919190130920-971979171.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：git方式拉代码，直接不报红，代表搭建成功&lt;/p&gt;
&lt;h3&gt;jenkins手动发版测试&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;linux创建目录
1、cd /
2、mkdir springboot_demo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jenkins配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;clean install

mv target/*.jar /springboot_demo/
cd /springboot_demo
BUILD_ID= java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar &amp;gt;log 2&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;amp;1&lt;/span&gt; &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;clean install

mv target/*.jar /springboot_demo/
cd /springboot_demo
BUILD_ID= java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar &amp;gt;log 2&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;amp;1&lt;/span&gt; &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919213534694-2123527325.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919214025600-308607359.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919214433968-845388837.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;整合sonar然后发布&lt;/h2&gt;
&lt;p&gt;　　刚开始的时候sonarqube里面没有项目随着代码的重新发布，会将项目也提交到sonarqube中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#projectKey项目的唯一标识，不能重复
sonar.projectKey=yb
sonar.projectName=springboot-test
sonar.projectVersion=1.0
sonar.sourceEncoding=UTF-8
sonar.modules=java-module
# Java module 
java-module.sonar.projectName=test 
java-module.sonar.language=java 
# .表示projectBaseDir指定的目录 
java-module.sonar.sources=src 
java-module.sonar.projectBaseDir=. 
java-module.sonar.java.binaries=target/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919230059479-775588360.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919231127604-429068352.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919231625508-118511158.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;提交后自动发布&lt;/h2&gt;
&lt;h3&gt;功能描述&lt;/h3&gt;
&lt;p&gt;　　本地代码修改完成之后，往gitlab上推代码，然后Jenkins自动打包发版程序，不用人工手动发版。&lt;/p&gt;
&lt;h3&gt;安装插件(gitlab)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200919232427324-509871244.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;装完插件后，虚拟机上的磁盘满了，导致服务起不来，今天先到这吧，不搞这玩意了(明天要搞其他东西，搭建这一整套东西，恶心我几百回了，处处坑~)，自行去找度娘吧，只需要简单配置2步就好，前面服务都全部搭建出来了，这个因为linux磁盘满了，懒得搞了，有点小遗憾，拜~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200920004356137-1185854086.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1504448/202009/1504448-20200920004723902-378166677.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
链接: https://pan.baidu.com/s/1OixJ3oHvjEjKLtvuvplclA  密码: fbqs
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 19 Sep 2020 16:57:00 +0000</pubDate>
<dc:creator>陈彦斌</dc:creator>
<og:description>导读 之前用的都是SVN，由于工作需要用到Git，求人不如求己，技多不压身，多学一项技能，未来就少求别人一次，系统的学一遍，自己搭建一整套环境，自动化部署(自动发版)，代码质量检测等等(为啥不用doc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenyanbin/p/qq543210188.html</dc:identifier>
</item>
<item>
<title>iOS多线程之超实用理论+demo演示（可下载） - Dast1</title>
<link>http://www.cnblogs.com/Dast1/p/13698286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dast1/p/13698286.html</guid>
<description>&lt;p&gt;     在初学iOS相关知识过程中，大多都对多线程有些恐惧的心里，同时感觉工作中用上的概率不大。但是如果平时不多积累并学透多线程，当工作中真的需要用到的时候，就很可能简单百度后把一些知识点稀里糊涂地就用到工作中了，殊不知里面有很多的坑，也有很多技巧需要在理论上先做了解，再结合实战，进一步去体会多线程的魅力和强大。&lt;/p&gt;
&lt;p&gt;     接下来，就对多线程来源的背景进行简单的介绍：&lt;/p&gt;
&lt;p&gt;     在计算的早期，计算机可以执行的最大工作量是由 CPU 的时钟速度决定的。但是随着技术的进步和处理器设计的紧凑化，热量和其他物理约束开始限制处理器的最大时钟速度。因此，芯片制造商寻找其他方法来提高芯片的总体性能。他们决定的解决方案是增加每个芯片上的处理器核心数量。通过增加内核的数量，一个单独的芯片可以每秒执行更多的指令，而不用增加 CPU 的速度或改变芯片的大小或热特性。唯一的问题是如何利用额外的内核。&lt;/p&gt;
&lt;p&gt;     应用程序使用多核的传统方法是创建多个线程。与依赖线程不同，iOS 采用异步设计方法来解决并发问题。通常，这项工作涉及获取一个后台线程，在该线程上启动所需的任务，然后在任务完成时向调用方发送通知(通常通过一个回调函数)。&lt;/p&gt;
&lt;p&gt;     iOS 提供了一些技术，允许您异步执行任何任务，而无需自己管理线程。异步启动任务的技术之一是 Grand Central Dispatch (GCD)。这种技术采用线程管理代码，并将该代码移动到系统级别。您所要做的就是定义要执行的任务，并将它们添加到适当的分派队列中。GCD 负责创建所需的线程，并安排任务在这些线程上运行。由于线程管理现在是系统的一部分，GCD 提供了任务管理和执行的整体方法，比传统线程提供了更高的效率。&lt;/p&gt;
&lt;p&gt;     OperationQueue（操作队列，api 类名为 NSOperationQueue ）是 Objective-C 对象，是对 GCD 的封装。其作用非常类似于分派队列。您定义要执行的任务，然后将它们添加到 OperationQueue 中， OperationQueue 处理这些任务的调度和执行。与 GCD 一样， OperationQueue 为您处理所有线程管理，确保在系统上尽可能快速有效地执行任务。&lt;/p&gt;
&lt;p&gt;     接下来，就对现在工作中常用的这两种技术进行比较和实例解析。&lt;/p&gt;

&lt;h2 id=&quot;核心理念&quot;&gt;核心理念&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;GCD的核心概念：将 任务(block) 添加到队列，并且指定执行任务的函数。&lt;/li&gt;
&lt;li&gt;NSOperation 的核心概念：把 操作(异步) 添加到 队列。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;区别&quot;&gt;区别&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;GCD：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将任务（block）添加到队列(串行/并发/主队列)，并且指定任务执行的函数(同步/异步)&lt;/li&gt;
&lt;li&gt;GCD是底层的C语言构成的API&lt;/li&gt;
&lt;li&gt;iOS 4.0 推出的，针对多核处理器的并发技术&lt;/li&gt;
&lt;li&gt;在队列中执行的是由 block 构成的任务，这是一个轻量级的数据结构&lt;/li&gt;
&lt;li&gt;要停止已经加入 queue 的 block 需要写复杂的代码&lt;/li&gt;
&lt;li&gt;需要通过 Barrier（dispatch_barrier_async）或者同步任务设置任务之间的依赖关系&lt;/li&gt;
&lt;li&gt;只能设置队列的优先级&lt;/li&gt;
&lt;li&gt;高级功能：&lt;br/&gt;dispatch_once_t（一次性执行, 多线程安全）；&lt;br/&gt;dispatch_after（延迟）；&lt;br/&gt;dispatch_group（调度组）；&lt;br/&gt;dispatch_semaphore（信号量）；&lt;br/&gt;dispatch_apply（优化顺序不敏感大体量for循环）；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OperationQueue：&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;OC 框架，更加面向对象，是对 GCD 的封装。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;iOS 2.0 推出的，苹果推出 GCD 之后，对 NSOperation 的底层进行了全部重写。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以设置队列中每一个操作的 QOS（） 队列的整体 QOS&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;操作相关&lt;br/&gt;Operation作为一个对象，为我们提供了更多的选择：&lt;br/&gt;任务依赖（addDependency），可以跨队列设置操作的依赖关系；&lt;br/&gt;在队列中的优先级（queuePriority）&lt;br/&gt;服务质量（qualityOfService, iOS8+）;&lt;br/&gt;完成回调（void (^completionBlock)(void）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;队列相关&lt;br/&gt;服务质量（qualityOfService, iOS8+）;&lt;br/&gt;最大并发操作数（maxConcurrentOperationCount），GCD 不易实现;&lt;br/&gt;暂停/继续（suspended）；&lt;br/&gt;取消所有操作（cancelAllOperations）；&lt;br/&gt;KVO 监听队列任务执行进度（progress, iOS13+）；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;     接下来通过文字，结合实践代码（&lt;strong&gt;工程链接在文末&lt;/strong&gt;）和运行效果 gif 图对部分功能进行分析。&lt;/p&gt;

&lt;h2 id=&quot;队列&quot;&gt;队列&lt;/h2&gt;
&lt;h3 id=&quot;串行队列（serial-queues）&quot;&gt;串行队列（Serial Queues）&lt;/h3&gt;
&lt;p&gt;     串行队列中的任务按顺序执行；但是不同串行队列间没有任何约束； 多个串行队列同时执行时，不同队列中任务执行是并发的效果。比如：火车站买票可以有多个卖票口，但是每个排的队都是串行队列，整体并发，单线串行。&lt;/p&gt;
&lt;p&gt;     注意防坑：串行队列创建的位置。比如下面代码示例中：在for循环内部创建时，每个循环都是创建一个新的串行队列，里面只装一个任务，多个串行队列，结果整体上是并发的效果。想要串行效果，必须在for循环外部创建串行队列。&lt;/p&gt;
&lt;p&gt;     串行队列适合管理共享资源。保证了顺序访问，杜绝了资源竞争。&lt;/p&gt;
&lt;p&gt;      代码示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;    private func serialExcuteByGCD(){
        let lArr : [UIImageView] = [imageView1, imageView2, imageView3, imageView4]
        
        //串行队列，异步执行时，只开一个子线程
        let serialQ = DispatchQueue.init(label: &quot;com.companyName.serial.downImage&quot;)
        
        for i in 0..&amp;lt;lArr.count{
            let lImgV = lArr[i]
            
            //清空旧图片
            lImgV.image = nil
            
         //注意，防坑：串行队列创建的位置,在这创建时，每个循环都是一个新的串行队列，里面只装一个任务，多个串行队列，整体上是并行的效果。
            //            let serialQ = DispatchQueue.init(label: &quot;com.companyName.serial.downImage&quot;)
            
            serialQ.async {
                
                print(&quot;第\(i)个 开始，%@&quot;,Thread.current)
                Downloader.downloadImageWithURLStr(urlStr: imageURLs[i]) { (img) in
                    let lImgV = lArr[i]
                    
                    print(&quot;第\(i)个 结束&quot;)
                    DispatchQueue.main.async {
                        print(&quot;第\(i)个 切到主线程更新图片&quot;)
                        lImgV.image = img
                    }
                    if nil == img{
                        print(&quot;第\(i+1)个img is nil&quot;)
                    }
                }
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;gif 效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/804040/202009/804040-20200920001353522-1355774959.gif&quot; alt=&quot;serialGCD&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;图中下载时可顺利拖动滚动条，是为了说明下载在子线程，不影响UI交互&lt;/p&gt;
&lt;p&gt;log:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第0个 开始
第0个 结束
第1个 开始
第0个 更新图片
第1个 结束
第2个 开始
第1个 更新图片
第2个 结束
第3个 开始
第2个 更新图片
第3个 结束
第3个 更新图片
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;      由 log 可知: GCD 切到主线程也需要时间，切换完成之前，指令可能已经执行到下个循环了。但是看起来图片还是依次下载完成和显示的，因为每一张图切到主线程显示都需要时间。&lt;/p&gt;
&lt;h3 id=&quot;并发队列（concurrent-queues）&quot;&gt;并发队列（Concurrent Queues）&lt;/h3&gt;
&lt;p&gt;     并发队列依旧保证中任务按加入的先后顺序开始（FIFO），但是无法知道执行顺序，执行时长和某一时刻的任务数。按 FIFO 开始后，他们之间不会相互等待。&lt;/p&gt;
&lt;p&gt;     比如：提交了 #1，#2，#3 任务到并发队列，开始的顺序是 #1，#2，#3。#2 和 #3 虽然开始的比 #1 晚，但是可能比 #1 执行结束的还要早。任务的执行是由系统决定的，所以执行时长和结束时间都无法确定。&lt;/p&gt;
&lt;p&gt;     需要用到并发队列时，&lt;strong&gt;强烈建议&lt;/strong&gt; 使用系统自带的四种全局队列之一。但是，当你需要使用 barrier 对队列中任务进行栅栏时，只能使用自定义并发队列。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Use a barrier to synchronize the execution of one or more tasks in your dispatch queue. When you add a barrier to a concurrent dispatch queue, the queue delays the execution of the barrier block (and any tasks submitted after the barrier) until all previously submitted tasks finish executing. After the previous tasks finish executing, the queue executes the barrier block by itself. Once the barrier block finishes, the queue resumes its normal execution behavior.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;     对比：barrier 和锁的区别&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;依赖对象不同，barrier 依赖的对象是自定义并发队列，锁操作依赖的对象是线程。&lt;/li&gt;
&lt;li&gt;作用不同，barrier 起到自定义并发队列中栅栏的作用；锁起到多线程操作时防止资源竞争的作用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      代码示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;private func concurrentExcuteByGCD(){
        let lArr : [UIImageView] = [imageView1, imageView2, imageView3, imageView4]
        
        for i in 0..&amp;lt;lArr.count{
            let lImgV = lArr[i]
            
            //清空旧图片
            lImgV.image = nil
            
            //并行队列:图片下载任务按顺序开始，但是是并行执行，不会相互等待，任务结束和图片显示顺序是无序的，多个子线程同时执行，性能更佳。
            let lConQ = DispatchQueue.init(label: &quot;cusQueue&quot;, qos: .background, attributes: .concurrent)
            lConQ.async {
                print(&quot;第\(i)个开始，%@&quot;, Thread.current)
                Downloader.downloadImageWithURLStr(urlStr: imageURLs[i]) { (img) in
                    let lImgV = lArr[i]
                      print(&quot;第\(i)个结束&quot;)
                    DispatchQueue.main.async {
                        lImgV.image = img
                    }
                    if nil == img{
                        print(&quot;第\(i+1)个img is nil&quot;)
                    }
                }
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;gif 效果图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/804040/202009/804040-20200920001353877-659343596.gif&quot; alt=&quot;conGCD&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;log:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第0个开始，%@ &amp;lt;NSThread: 0x600002de2e00&amp;gt;{number = 4, name = (null)}
第1个开始，%@ &amp;lt;NSThread: 0x600002dc65c0&amp;gt;{number = 6, name = (null)}
第2个开始，%@ &amp;lt;NSThread: 0x600002ddc8c0&amp;gt;{number = 8, name = (null)}
第3个开始，%@ &amp;lt;NSThread: 0x600002d0c8c0&amp;gt;{number = 7, name = (null)}
第0个结束
第3个结束
第1个结束
第2个结束
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;串行、并发队列对比图&quot;&gt;串行、并发队列对比图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/804040/202009/804040-20200920001354470-785338603.jpg&quot; alt=&quot;gcd-cheatsheet&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;无论串行还是并发队列，都是 FIFO ；&lt;br/&gt;一般创建 任务（blocks）和加任务到队列是在主线程，但是任务执行一般是在其他线程（asyc）。需要刷新 UI 时，如果当前不再主线程，需要切回主线程执行。当不确定当前线程是否在主线程时，可以使用下面代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;/**
 Submits a block for asynchronous execution on a main queue and returns immediately.
 */
static inline void dispatch_async_on_main_queue(void (^block)()) {
    if (NSThread.isMainThread) {
        block();
    } else {
        dispatch_async(dispatch_get_main_queue(), block);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;主队列是串行队列，每个时间点只能有一个任务执行，因此如果耗时操作放到主队列，会导致界面卡顿。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;系统提供一个串行主队列，&lt;u&gt;4个&lt;/u&gt; 不同优先级的全局队列。&lt;br/&gt;用 dispatch_get_global_queue 方法获取全局队列时，第一个参数有 4 种类型可选:&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;DISPATCH_QUEUE_PRIORITY_HIGH
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;DISPATCH_QUEUE_PRIORITY_LOW
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;DISPATCH_QUEUE_PRIORITY_BACKGROUND
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;串行队列异步执行时，切到主线程刷 UI 也需要时间，切换完成之前，指令可能已经执行到下个循环了。但是看起来图片还是依次下载完成和显示的，因为每一张图切到主线程显示都需要时间。详见 demo 示例。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;iOS8 之后，如果需要添加可被取消的任务，可以使用 DispatchWorkItem 类，此类有 cancel 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;应该避免创建大量的串行队列,如果希望并发执行大量任务，请将它们提交给全局并发队列之一。创建串行队列时，请尝试&lt;strong&gt;为每个队列确定一个用途&lt;/strong&gt;，例如保护资源或同步应用程序的某些关键行为(如蓝牙检测结果需要有序处理的逻辑)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;block（块）相关&quot;&gt;block（块）相关&lt;/h2&gt;
&lt;p&gt;     调度队列复制添加到它们中的块，并在执行完成时释放块。&lt;br/&gt;     虽然队列在执行小任务时比原始线程更有效，但是创建块并在队列上执行它们仍然存在开销。如果一个块执行的工作量太少，那么内联执行它可能比将它分派到队列中要便宜得多。判断一个块是否工作量太少的方法是使用性能工具为每个路径收集度量数据并进行比较。&lt;br/&gt;     您可能希望将 block 的部分代码包含在 @autoreleasepool 中，以处理这些对象的内存管理。尽管 GCD 调度队列拥有自己的自动释放池，但它们不能保证这些池何时耗尽。如果您的应用程序是内存受限的，那么创建您自己的自动释放池可以让您以更有规律的间隔释放自动释放对象的内存。&lt;/p&gt;
&lt;h2 id=&quot;dispatch_after&quot;&gt;dispatch_after&lt;/h2&gt;
&lt;p&gt;     dispatch_after 函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到队列中。这个时间并不是绝对准确的。&lt;br/&gt;  代码示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@&quot;2s后执行&quot;);
    });
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dispatch_semaphore&quot;&gt;dispatch_semaphore&lt;/h2&gt;
&lt;p&gt;      在多线程访问可变变量时，是非线程安全的。可能导致程序崩溃。此时，可以通过使用信号量（semaphore）技术，保证多线程处理某段代码时，后面线程等待前面线程执行，保证了多线程的安全性。使用方法记两个就行了，一个是wait（dispatch_semaphore_wait），一个是signal（dispatch_semaphore_signal）。&lt;/p&gt;
&lt;blockquote readability=&quot;2.9166666666667&quot;&gt;
&lt;p&gt;具体请参考文章&lt;a href=&quot;https://www.cnblogs.com/Dast1/p/11392835.html&quot;&gt;Semaphore回顾&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;dispatch_apply&quot;&gt;dispatch_apply&lt;/h2&gt;
&lt;p&gt;     当每次迭代中执行工作与其他所有迭代中执行的工作不同，且每个循环完成的顺序不重要时，可以用 dispatch_apply 函数替换循环。注意：替换后， dispatch_apply 函数整体上是同步执行，内部 block 的执行类型（串行/并发）由队列类型决定，但是串行队列易死锁，建议用并发队列。&lt;/p&gt;
&lt;p&gt;原循环：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;for (i = 0; i &amp;lt; count; i++) {
   printf(&quot;%u\n&quot;,i);
}
printf(&quot;done&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优化后：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
 
 //count 是迭代的总次数。
dispatch_apply(count, queue, ^(size_t i) {
   printf(&quot;%u\n&quot;,i);
});

//同样在上面循环结束后才调用。
printf(&quot;done&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;     您应该确保您的任务代码在每次迭代中完成合理数量的工作。与您分派到队列的任何块或函数一样，调度该代码以便执行会带来开销。如果循环的每次迭代只执行少量的工作，那么调度代码的开销可能会超过将代码分派到队列可能带来的性能优势。如果您在测试期间发现这一点是正确的，那么您可以使用步进来增加每个循环迭代期间执行的工作量。通过大步前进，您可以将原始循环的多个迭代集中到一个块中，并按比例减少迭代次数。例如，如果您最初执行了 100次 迭代，但决定使用步长为 4 的迭代，那么您现在从每个块执行 4 次循环迭代，迭代次数为 25次 。&lt;/p&gt;
&lt;h2 id=&quot;自问自答&quot;&gt;自问自答&lt;/h2&gt;
&lt;ul readability=&quot;5.820293398533&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;一个队列的不同任务可以在多个线程执行吗？&lt;br/&gt;答：串行队列，异步执行时，只开一个子线程；无所谓多个线程执行；&lt;br/&gt;并发队列，异步执行时，会自动开多个线程，可以在多个线程并发执行不同的任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;一个线程可以同时执行多个队列的任务吗？&lt;br/&gt;答：一个线程某个时间点只能执行一个任务，执行完毕后，可能执行到来自其他队列的任务（如果有的话）。比如：主线程除了执行主队列中任务外，也可能会执行非主队列中的任务。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;队列与线程关系示例图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/804040/202009/804040-20200920001354776-509411110.jpg&quot; alt=&quot;queues &amp;amp; threads&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;qualityOfService 和 queuePriority 的区别是什么？&lt;br/&gt;答：&lt;br/&gt;qualityOfService:&lt;br/&gt;     用于表示 operation 在获取系统资源时的优先级，默认值：NSQualityOfServiceBackground，我们可以根据需要给 operation 赋不同的优化级，如最高优化级：NSQualityOfServiceUserInteractive。&lt;br/&gt;queuePriority:&lt;br/&gt;     用于设置 operation 在 operationQueue 中的相对优化级，同一 queue 中优化级高的 operation(isReady 为 YES) 会被优先执行。&lt;br/&gt;     需要注意区分 qualityOfService (在系统层面，operation 与其他线程获取资源的优先级) 与 queuePriority (同一 queue 中 operation 间执行的优化级)的区别。同时，需要注意 dependencies (严格控制执行顺序)与 queuePriority (queue 内部相对优先级)的区别。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.78969957081545&quot;&gt;
&lt;p&gt;添加依赖后，队列中网络请求任务有依赖关系时，任务结束判定以数据返回为准还是以发起请求为准？&lt;br/&gt;答：以发起请求为准。分析过程详见&lt;a href=&quot;https://www.cnblogs.com/Dast1/p/12168103.html&quot;&gt;NSOperationQueue队列中操作依赖相关思考&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;NSOperation&lt;br/&gt;     NSOperation 是一个&quot;抽象类&quot;，不能直接使用。抽象类的用处是定义子类共有的属性和方法。NSOperation 是基于 GCD 做的面向对象的封装。相比较 GCD 使用更加简单，并且提供了一些用 GCD 不是很好实现的功能。是苹果公司推荐使用的并发技术。它有两个子类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NSInvocationOperation (调用操作)&lt;/li&gt;
&lt;li&gt;NSBlockOperation (块操作)&lt;br/&gt;     一般常用NSBlockOperation，代码简单，同时由于闭包性使它没有传参问题。任务被封装在 NSOperation 的子类实例类对象里，一个 NSOperation 子类对象可以添加多个任务 block 和 一个执行完成 block ，当其关联的所有 block 执行完时，就认为操作结束了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;NSOperationQueue&lt;br/&gt;      OperationQueue也是对 GCD 的高级封装，更加面向对象，可以实现 GCD 不方便实现的一些效果。被添加到队列的操作默认是异步执行的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS：常见的抽象类有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UIGestureRecognizer&lt;/li&gt;
&lt;li&gt;CAAnimation&lt;/li&gt;
&lt;li&gt;CAPropertyAnimation&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;可以实现-非fifo-效果&quot;&gt;可以实现 非FIFO 效果&lt;/h2&gt;
&lt;p&gt;通过对不同操作设置依赖,或优先级，可实现 非FIFO 效果。&lt;br/&gt;  代码示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;func testDepedence(){
        let op0 = BlockOperation.init {
            print(&quot;op0&quot;)
        }
        
        let op1 = BlockOperation.init {
            print(&quot;op1&quot;)
        }
        
        let op2 = BlockOperation.init {
            print(&quot;op2&quot;)
        }
        
        let op3 = BlockOperation.init {
            print(&quot;op3&quot;)
        }
        
        let op4 = BlockOperation.init {
            print(&quot;op4&quot;)
        }
        
        op0.addDependency(op1)
        op1.addDependency(op2)
        
        op0.queuePriority = .veryHigh
        op1.queuePriority = .normal
        op2.queuePriority = .veryLow
        
        op3.queuePriority = .low
        op4.queuePriority = .veryHigh
        
        gOpeQueue.addOperations([op0, op1, op2, op3, op4], waitUntilFinished: false)
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;log:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; op4
 op2
 op3
 op1
 op0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; op4
 op3
 op2
 op1
 op0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：操作间不存在依赖时，按优先级执行；存在依赖时，按依赖关系先后执行（与无依赖关系的其他任务相比，依赖集合的执行顺序不确定）&lt;/p&gt;
&lt;h2 id=&quot;队列暂停继续&quot;&gt;队列暂停/继续&lt;/h2&gt;
&lt;p&gt;通过对队列的&lt;code&gt;isSuspended&lt;/code&gt;属性赋值，可实现队列中未执行任务的暂停和继续效果。正在执行的任务不受影响。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;///暂停队列，只对未执行中的任务有效。本例中对串行队列的效果明显。并发队列因4个任务一开始就很容易一起开始执行，即使挂起也无法影响已处于执行状态的任务。
    @IBAction func pauseQueueItemDC(_ sender: Any) {
        gOpeQueue.isSuspended = true
    }
    
    ///恢复队列，之前未开始执行的任务会开始执行
    @IBAction func resumeQueueItemDC(_ sender: Any) {
       gOpeQueue.isSuspended = false
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;gif 效果图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/804040/202009/804040-20200920001355143-933783100.gif&quot; alt=&quot;pauseResume&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;取消操作&quot;&gt;取消操作&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一旦添加到操作队列中，操作对象实际上归队列所有，不能删除。取消操作的唯一方法是取消它。可以通过调用单个操作对象的 cancel 方法来取消单个操作对象，也可以通过调用队列对象的 cancelAllOperations 方法来取消队列中的所有操作对象。&lt;/li&gt;
&lt;li&gt;更常见的做法是取消所有队列操作，以响应某些重要事件，如应用程序退出或用户专门请求取消，而不是有选择地取消操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;取消单个操作对象&quot;&gt;取消单个操作对象&lt;/h3&gt;
&lt;p&gt;取消（cancel）时，有 3 种情况：&lt;br/&gt;1.操作在队列中等待执行，这种情况下，操作将不会被执行。&lt;br/&gt;2.操作已经在执行中，此时，系统不会强制停止这个操作，但是，其 &lt;code&gt;cancelled&lt;/code&gt;属性会被置为 true 。&lt;br/&gt;3.操作已完成，此时，cancel 无任何影响。&lt;/p&gt;
&lt;h3 id=&quot;取消队列中的所有操作对象&quot;&gt;取消队列中的所有操作对象&lt;/h3&gt;
&lt;p&gt;方法： cancelAllOperations。同样只会对未执行的任务有效。&lt;br/&gt;demo 中代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;    deinit {
        gOpeQueue.cancelAllOperations()
        print(&quot;die:%@&quot;,self)
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自问自答-2&quot;&gt;自问自答&lt;/h2&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;通过设置操作间依赖，可以实现 非FIFO 的指定顺序效果。那么，通过设置最大并发数为 1 ，可以实现指定顺序效果吗？&lt;br/&gt;A:不可以！&lt;br/&gt;设置最大并发数为 1 后，虽然每个时间点只执行一个操作，但是操作的执行顺序仍然基于其他因素，如操作的依赖关系，操作的优先级（依赖关系比优先级级别更高，即先根据依赖关系排序;不存在依赖关系时，才根据优先级排序）。因此，序列化 &lt;strong&gt;操作队列&lt;/strong&gt; 不会提供与 GCD 中的序列 &lt;strong&gt;分派队列&lt;/strong&gt; 完全相同的行为。如果操作对象的执行顺序对您很重要，那么您应该在将操作添加到队列之前使用 &lt;strong&gt;依赖关系&lt;/strong&gt; 建立该顺序，或改用 &lt;strong&gt;GCD 的 串行队列&lt;/strong&gt; 实现序列化效果。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Operation Queue的 block 中为何无需使用 [weak self] 或 [unowned self] ？&lt;br/&gt;A:即使队列对象是为全局的，self -&amp;gt; queue -&amp;gt; operation block -&amp;gt; self，的确会造成循环引用。但是在队列里的操作执行完毕时，队列会自动释放操作，自动解除循环引用。所以不必使用 [weak self] 或 [unowned self] 。&lt;br/&gt;此外，这种循环引用在某些情况下非常有用，你无需额外持有任何对象就可以让操作自动完成它的任务。比如下载页面下载过程中，退出有循环引用的界面时，如果不执行 cancelAllOperation 方法，可以实现继续执行剩余队列中下载任务的效果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;func addOperation(_ op: Operation)&lt;br/&gt;Discussion:&lt;br/&gt;Once added, the specified operation remains in the queue until it finishes executing.&lt;br/&gt;Declaration&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;func addOperation(_ block: @escaping () -&amp;gt; Void)&lt;br/&gt;Parameters&lt;br/&gt;block&lt;br/&gt;The block to execute from the operation. The block takes no parameters and has no return value.&lt;br/&gt;Discussion&lt;br/&gt;This method adds a single block to the receiver by first wrapping it in an operation object. You should not attempt to get a reference to the newly created operation object or determine its type information.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;操作的 QOS 和队列的 QOS 有何关系？&lt;br/&gt;A:队列的 QOS 设置，会自动把较低优先级的操作提升到与队列相同优先级。（原更高优先级操作的优先级保持不变）。后续添加进队列的操作，优先级低于队列优先级时，也会被自动提升到与队列相同的优先级。&lt;br/&gt;注意，苹果文档如下的解释是错误的 &lt;code&gt;This property specifies the service level applied to operation objects added to the queue. If the operation object has an explicit service level set, that value is used instead.&lt;/code&gt;&lt;br/&gt;原因详见：&lt;a href=&quot;https://stackoverflow.com/questions/31062196/can-nsoperation-have-a-lower-qualityofservice-than-nsoperationqueue&quot;&gt;Can NSOperation have a lower qualityOfService than NSOperationQueue?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;如何解决资源竞争问题&quot;&gt;如何解决资源竞争问题&lt;/h2&gt;
&lt;p&gt;资源竞争可能导致数据异常，死锁，甚至因访问野指针而崩溃。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于有明显先后依赖关系的任务，最佳方案是 &lt;strong&gt;GCD串行队列&lt;/strong&gt;,可以在不使用线程锁时保证资源互斥。&lt;/li&gt;
&lt;li&gt;其他情况，对存在资源竞争的代码加锁或使用信号量（初始参数填1，表示只允许一条线程访问资源）。&lt;/li&gt;
&lt;li&gt;串行队列同步执行时，如果有&lt;strong&gt;任务相互等待&lt;/strong&gt;，会死锁。&lt;br/&gt;比如：在主线程上同步执行任务时，因任务和之前已加入主队列但未执行的任务会相互等待，导致死锁。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;  func testDeadLock(){
        //主队列同步执行，会导致死锁。block需要等待testDeadLock执行，而主队列同步调用，又使其他任务必须等待此block执行。于是形成了相互等待，就死锁了。
        DispatchQueue.main.sync {
            print(&quot;main block&quot;)
        }
        print(&quot;2&quot;)
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是下面代码不会死锁，故&lt;strong&gt;串行队列同步执行任务不一定死锁&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;- (void)testSynSerialQueue{
    dispatch_queue_t myCustomQueue;
    myCustomQueue = dispatch_queue_create(&quot;com.example.MyCustomQueue&quot;, NULL);
     
    dispatch_async(myCustomQueue, ^{
        printf(&quot;Do some work here.\n&quot;);
    });
     
    printf(&quot;The first block may or may not have run.\n&quot;);
     
    dispatch_sync(myCustomQueue, ^{
        printf(&quot;Do some more work here.\n&quot;);
    });
    printf(&quot;Both blocks have completed.\n&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何提高代码效率&quot;&gt;如何提高代码效率&lt;/h2&gt;
&lt;h3 id=&quot;西饼传说&quot;&gt;“西饼传说”&lt;/h3&gt;
&lt;p&gt;代码设计优先级：&lt;strong&gt;系统方法 &amp;gt; 并行 &amp;gt; 串行 &amp;gt; 锁&lt;/strong&gt;，简记为：&lt;em&gt;&lt;u&gt;西饼传说&lt;/u&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尽可能依赖 &lt;strong&gt;系统&lt;/strong&gt; 框架。实现并发性的最佳方法是利用系统框架提供的内置并发性。&lt;/li&gt;
&lt;li&gt;尽早识别系列任务，并尽可能使它们更加 &lt;strong&gt;并行&lt;/strong&gt;。如果因为某个任务依赖于某个共享资源而必须连续执行该任务，请考虑更改体系结构以删除该共享资源。您可以考虑为每个需要资源的客户机制作资源的副本，或者完全消除该资源。&lt;/li&gt;
&lt;li&gt;不使用锁来保护某些共享资源，而是指定一个 &lt;strong&gt;串行&lt;/strong&gt;队列 (或使用操作对象依赖项)以正确的顺序执行任务。&lt;/li&gt;
&lt;li&gt;避免使用 &lt;strong&gt;锁&lt;/strong&gt;。&lt;strong&gt;GCD 调度队列&lt;/strong&gt; 和 &lt;strong&gt;操作队列&lt;/strong&gt; 提供的支持使得在大多数情况下不需要锁定。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;确定操作对象的适当范围&quot;&gt;确定操作对象的适当范围&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;尽管可以向操作队列中添加任意大量的操作，但这样做通常是不切实际的。与任何对象一样，NSOperation 类的实例消耗内存，并且具有与其执行相关的实际成本。如果您的每个操作对象只执行少量的工作，并且您创建了数以万计的操作对象，那么您可能会发现，您花在调度操作上的时间比花在实际工作上的时间更多。如果您的应用程序已经受到内存限制，那么您可能会发现，仅仅在内存中拥有数万个操作对象就可能进一步降低性能。&lt;/li&gt;
&lt;li&gt;有效使用操作的关键是 &lt;u&gt;在你需要做的工作量和保持计算机忙碌之间找到一个适当的平衡&lt;/u&gt; 。尽量确保你的业务做了合理的工作量。例如，如果您的应用程序创建了 100 个操作对象来对 100 个不同的值执行相同的任务，那么可以考虑创建 10 个操作对象来处理每个值。&lt;/li&gt;
&lt;li&gt;您还应该避免将大量操作一次性添加到队列中，或者避免连续地将操作对象添加到队列中的速度快于处理它们的速度。与其用操作对象淹没队列，不如&lt;u&gt;批量创建这些对象。当一个批处理完成执行时，使用完成块告诉应用程序创建一个新的批处理&lt;/u&gt;。当您有很多工作要做时，您希望保持队列中充满足够的操作，以便计算机保持忙碌，但是您&lt;u&gt;不希望一次创建太多操作，以至于应用程序耗尽内存。&lt;/u&gt;&lt;/li&gt;
&lt;li&gt;当然，您创建的操作对象的数量以及在每个操作对象中执行的工作量是可变的，并且完全取决于您的应用程序。你应该经常使用像 Instruments 这样的工具来帮助你在效率和速度之间找到一个适当的平衡。有关 Instruments 和其他可用于为代码收集度量标准的性能工具的概述，请参阅 &lt;a href=&quot;https://developer.apple.com/library/archive/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410&quot;&gt;性能概述&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;异步任务（asynchronous tasks）：由一个线程启动，但实际上在另一个线程上运行，利用额外的处理器资源更快地完成工作。&lt;/li&gt;
&lt;li&gt;互斥（mutex）：提供对共享资源的互斥访问的锁。&lt;br/&gt;互斥锁一次只能由一个线程持有。试图获取由不同线程持有的互斥对象会使当前线程处于休眠状态，直到最终获得锁为止。&lt;/li&gt;
&lt;li&gt;进程（process）：应用软件或程序的运行时实例。&lt;br/&gt;进程有自己的虚拟内存空间和系统资源(包括端口权限) ，这些资源独立于分配给其他程序的资源。一个进程总是包含至少一个线程(主线程) ，并且可能包含任意数量的其他线程。&lt;/li&gt;
&lt;li&gt;信号量（semaphore）：限制对共享资源访问的受保护变量。&lt;br/&gt;互斥（Mutexes）和条件（conditions）都是不同类型的信号量。&lt;/li&gt;
&lt;li&gt;任务（task），表示需要执行的工作量。&lt;/li&gt;
&lt;li&gt;线程（thread)：进程中的执行流程。&lt;br/&gt;每个线程都有自己的堆栈空间，但在其他方面与同一进程中的其他线程共享内存。&lt;/li&gt;
&lt;li&gt;运行循环（run loop）: 一个事件处理循环，&lt;br/&gt;接收事件并派发到适当的处理程序。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Glossary/Glossary.html#//apple_ref/doc/uid/TP40008091-CH104-SW2&quot;&gt;官方并发编程词汇表&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/WoopDast1/MultiThreadDemo&quot;&gt;MultiThreadDemo&lt;/a&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091-CH1-SW1&quot;&gt;Concurrency Programming Guide&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.appcoda.com/ios-concurrency/&quot;&gt;iOS Concurrency: Getting Started with NSOperation and Dispatch Queues&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文中提到的知识点，&lt;u&gt;“与其用操作对象淹没队列，不如批量创建这些对象。当一个批处理完成执行时，使用完成块告诉应用程序创建一个新的批处理”&lt;/u&gt;，在最近的工作中的确有需要类似的需求，等有时间会进行总结，就作为下一篇文章的预告吧。&lt;/p&gt;
&lt;blockquote readability=&quot;4.3661971830986&quot;&gt;
&lt;p&gt;本文由博客群发一文多发等运营工具平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 19 Sep 2020 16:14:00 +0000</pubDate>
<dc:creator>Dast1</dc:creator>
<og:description>背景简介 在初学iOS相关知识过程中，大多都对多线程有些恐惧的心里，同时感觉工作中用上的概率不大。但是如果平时不多积累并学透多线程，当工作中真的需要用到的时候，就很可能简单百度后把一些知识点稀里糊涂地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dast1/p/13698286.html</dc:identifier>
</item>
<item>
<title>Java审计之文件操作漏洞 - nice_0e3</title>
<link>http://www.cnblogs.com/nice0e3/p/13698256.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nice0e3/p/13698256.html</guid>
<description>&lt;h2 id=&quot;0x00-前言&quot;&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;本篇内容打算把Java审计中会遇到的一些文件操作的漏洞，都给叙述一遍。比如一些任意文件上传，文件下载，文件读取，文件删除，这些操作文件的漏洞。&lt;/p&gt;
&lt;h2 id=&quot;0x01-文件上传漏洞&quot;&gt;0x01 文件上传漏洞&lt;/h2&gt;
&lt;h3 id=&quot;randomaccessfile类上传文件案例：&quot;&gt;RandomAccessFile类上传文件案例：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package com.test;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
@WebServlet(&quot;/FileUploadServlet&quot;)
public class domain extends HttpServlet {
    private static final long serialVersionUID = 1L;
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        InputStream inputStream = request.getInputStream();
        String realPath = request.getServletContext().getRealPath(&quot;/upload&quot;);

        System.out.println(realPath);
        File tempFile = new File(realPath,&quot;temp.tmp&quot;);
        if (!tempFile.exists()){
            tempFile.createNewFile();
        }
        FileOutputStream fos = new FileOutputStream(tempFile);
        byte[] buffer = new byte[1024];
        int len = 0;
        while(-1 != (len = inputStream.read(buffer))){
            fos.write(buffer, 0, len);
        }
        RandomAccessFile randomFile = new RandomAccessFile(tempFile, &quot;r&quot;);
        randomFile.readLine();
        String contentDisposition = randomFile.readLine();
        String filename = contentDisposition.substring(contentDisposition.indexOf(&quot;filename=\&quot;&quot;), contentDisposition.lastIndexOf(&quot;\&quot;&quot;));
        filename = filename.replace(&quot;filename=\&quot;&quot;, &quot;&quot;);
// 防止中文乱码
        filename = new String(filename.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);
        System.out.println(filename);
        randomFile.seek(0);
        long start = 0;
        int forth = 1;
        while(-1 != (len = randomFile.readByte()) &amp;amp;&amp;amp; (forth&amp;lt;=4)){
            if(len == '\n'){
                start = randomFile.getFilePointer();
                forth++;
            }
        }
        fos.close();
        inputStream.close();
        File saveFile = new File(realPath,filename);
        RandomAccessFile randomAccessFile = new RandomAccessFile(saveFile, &quot;rw&quot;);
        randomFile.seek(randomFile.length());
        long endPosition = randomFile.getFilePointer();
        int j = 1;
        while((endPosition &amp;gt;= 0) &amp;amp;&amp;amp; j &amp;lt;= 2){
            endPosition --;
            randomFile.seek(endPosition);
            if(randomFile.readByte() =='\n'){
                j++;
            }
        }
        randomFile.seek(start);
        long startPoint = randomFile.getFilePointer();
        while(startPoint &amp;lt; endPosition-1){
            randomAccessFile.write(randomFile.readByte());
            startPoint = randomFile.getFilePointer();
        }
        randomAccessFile.close();
        randomFile.close();
        tempFile.delete();
        System.out.println(&quot;文件上传成功&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里并没有校验任何的文件类型，进行了上传。&lt;/p&gt;
&lt;h3 id=&quot;commons-fileupload类上传案例：&quot;&gt;commons-fileupload类上传案例：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package com.test;
import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.util.List;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
@WebServlet(&quot;/FileUploadServlet&quot;)


public class domain extends HttpServlet{

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //得到上传文件的保存目录，将上传的文件存放于WEB-INF目录下，不允许外界直接访问，保证上传文件的安全
        String savePath = this.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;);
        File file = new File(savePath);
        if(!file.exists()&amp;amp;&amp;amp;!file.isDirectory()){
            System.out.println(&quot;目录或文件不存在！&quot;);
            file.mkdir();
        }
        //消息提示
        String message = &quot;&quot;;
        try {
            //使用Apache文件上传组件处理文件上传步骤：
            //1、创建一个DiskFileItemFactory工厂
            DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory();
            //2、创建一个文件上传解析器
            ServletFileUpload fileUpload = new ServletFileUpload(diskFileItemFactory);
            //解决上传文件名的中文乱码
            fileUpload.setHeaderEncoding(&quot;UTF-8&quot;);
            //3、判断提交上来的数据是否是上传表单的数据
            if(!fileUpload.isMultipartContent(request)){
                //按照传统方式获取数据
                return;
            }
            //4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List&amp;lt;FileItem&amp;gt;集合，每一个FileItem对应一个Form表单的输入项
            List&amp;lt;FileItem&amp;gt; list = fileUpload.parseRequest(request);
            for (FileItem item : list) {
                //如果fileitem中封装的是普通输入项的数据
                if(item.isFormField()){
                    String name = item.getFieldName();
                    //解决普通输入项的数据的中文乱码问题
                    String value = item.getString(&quot;UTF-8&quot;);
                    String value1 = new String(name.getBytes(&quot;iso8859-1&quot;),&quot;UTF-8&quot;);
                    System.out.println(name+&quot;  &quot;+value);
                    System.out.println(name+&quot;  &quot;+value1);
                }else{
                    //如果fileitem中封装的是上传文件，得到上传的文件名称，
                    String fileName = item.getName();
                    System.out.println(fileName);
                    if(fileName==null||fileName.trim().equals(&quot;&quot;)){
                        continue;
                    }
                    //注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如：  c:\a\b\1.txt，而有些只是单纯的文件名，如：1.txt
                    //处理获取到的上传文件的文件名的路径部分，只保留文件名部分
                    fileName = fileName.substring(fileName.lastIndexOf(File.separator)+1);
                    //获取item中的上传文件的输入流
                    InputStream is = item.getInputStream();
                    //创建一个文件输出流
                    FileOutputStream fos = new FileOutputStream(savePath+File.separator+fileName);
                    //创建一个缓冲区
                    byte buffer[] = new byte[1024];
                    //判断输入流中的数据是否已经读完的标识
                    int length = 0;
                    //循环将输入流读入到缓冲区当中，(len=in.read(buffer))&amp;gt;0就表示in里面还有数据
                    while((length = is.read(buffer))&amp;gt;0){
                        //使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath + &quot;\\&quot; + filename)当中
                        fos.write(buffer, 0, length);
                    }
                    //关闭输入流
                    is.close();
                    //关闭输出流
                    fos.close();
                    //删除处理文件上传时生成的临时文件
                    item.delete();
                    message = &quot;文件上传成功&quot;;
                }
            }
        } catch (FileUploadException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            message = &quot;文件上传失败&quot;;
        }
        request.setAttribute(&quot;message&quot;,message);
        request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response);
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doGet(request, response);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里判断了文件是否为空，但是没有判断文件的类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class UploadHandleServlet1 extends HttpServlet{

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //得到上传文件的保存目录，将上传的文件存放于WEB-INF目录下，不允许外界直接访问，保证上传文件的安全
        String savePath = this.getServletContext().getRealPath(&quot;/WEB-INF/upload&quot;);
        //上传时生成的临时文件保存目录
        String tempPath = this.getServletContext().getRealPath(&quot;/WEB-INF/temp&quot;);
        File file = new File(tempPath);
        if(!file.exists()&amp;amp;&amp;amp;!file.isDirectory()){
            System.out.println(&quot;目录或文件不存在！&quot;);
            file.mkdir();
        }
        //消息提示
        String message = &quot;&quot;;
        try {
            //使用Apache文件上传组件处理文件上传步骤：
            //1、创建一个DiskFileItemFactory工厂
            DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory();
            //设置工厂的缓冲区的大小，当上传的文件大小超过缓冲区的大小时，就会生成一个临时文件存放到指定的临时目录当中。
            diskFileItemFactory.setSizeThreshold(1024*100);
            //设置上传时生成的临时文件的保存目录
            diskFileItemFactory.setRepository(file);
            //2、创建一个文件上传解析器
            ServletFileUpload fileUpload = new ServletFileUpload(diskFileItemFactory);
            //解决上传文件名的中文乱码
            fileUpload.setHeaderEncoding(&quot;UTF-8&quot;);
            //监听文件上传进度
            fileUpload.setProgressListener(new ProgressListener(){
                public void update(long pBytesRead, long pContentLength, int arg2) {
                    System.out.println(&quot;文件大小为：&quot; + pContentLength + &quot;,当前已处理：&quot; + pBytesRead);
                }
            });
            //3、判断提交上来的数据是否是上传表单的数据
            if(!fileUpload.isMultipartContent(request)){
                //按照传统方式获取数据
                return;
            }
            //设置上传单个文件的大小的最大值，目前是设置为1024*1024字节，也就是1MB
            fileUpload.setFileSizeMax(1024*1024);
            //设置上传文件总量的最大值，最大值=同时上传的多个文件的大小的最大值的和，目前设置为10MB
            fileUpload.setSizeMax(1024*1024*10);
            //4、使用ServletFileUpload解析器解析上传数据，解析结果返回的是一个List&amp;lt;FileItem&amp;gt;集合，每一个FileItem对应一个Form表单的输入项
            List&amp;lt;FileItem&amp;gt; list = fileUpload.parseRequest(request);
            for (FileItem item : list) {
                //如果fileitem中封装的是普通输入项的数据
                if(item.isFormField()){
                    String name = item.getFieldName();
                    //解决普通输入项的数据的中文乱码问题
                    String value = item.getString(&quot;UTF-8&quot;);
                    String value1 = new String(name.getBytes(&quot;iso8859-1&quot;),&quot;UTF-8&quot;);
                    System.out.println(name+&quot;  &quot;+value);
                    System.out.println(name+&quot;  &quot;+value1);
                }else{
                    //如果fileitem中封装的是上传文件，得到上传的文件名称，
                    String fileName = item.getName();
                    System.out.println(fileName);
                    if(fileName==null||fileName.trim().equals(&quot;&quot;)){
                        continue;
                    }
                    //注意：不同的浏览器提交的文件名是不一样的，有些浏览器提交上来的文件名是带有路径的，如：  c:\a\b\1.txt，而有些只是单纯的文件名，如：1.txt
                    //处理获取到的上传文件的文件名的路径部分，只保留文件名部分
                    fileName = fileName.substring(fileName.lastIndexOf(File.separator)+1);
                    //得到上传文件的扩展名
                    String fileExtName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)+1);
                    if(&quot;jsp&quot;.equals(fileExtName)||&quot;rar&quot;.equals(fileExtName)||&quot;tar&quot;.equals(fileExtName)||&quot;jar&quot;.equals(fileExtName)){
                        request.setAttribute(&quot;message&quot;, &quot;上传文件的类型不符合！！！&quot;);
                        request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response);
                        return;
                    }
                    //如果需要限制上传的文件类型，那么可以通过文件的扩展名来判断上传的文件类型是否合法
                    System.out.println(&quot;上传文件的扩展名为:&quot;+fileExtName);
                    //获取item中的上传文件的输入流
                    InputStream is = item.getInputStream();
                    //得到文件保存的名称
                    fileName = mkFileName(fileName);
                    //得到文件保存的路径
                    String savePathStr = mkFilePath(savePath, fileName);
                    System.out.println(&quot;保存路径为:&quot;+savePathStr);
                    //创建一个文件输出流
                    FileOutputStream fos = new FileOutputStream(savePathStr+File.separator+fileName);
                    //创建一个缓冲区
                    byte buffer[] = new byte[1024];
                    //判断输入流中的数据是否已经读完的标识
                    int length = 0;
                    //循环将输入流读入到缓冲区当中，(len=in.read(buffer))&amp;gt;0就表示in里面还有数据
                    while((length = is.read(buffer))&amp;gt;0){
                        //使用FileOutputStream输出流将缓冲区的数据写入到指定的目录(savePath + &quot;\\&quot; + filename)当中
                        fos.write(buffer, 0, length);
                    }
                    //关闭输入流
                    is.close();
                    //关闭输出流
                    fos.close();
                    //删除处理文件上传时生成的临时文件
                    item.delete();
                    message = &quot;文件上传成功&quot;;
                }
            }
        } catch (FileUploadBase.FileSizeLimitExceededException e) {
            e.printStackTrace();
            request.setAttribute(&quot;message&quot;, &quot;单个文件超出最大值！！！&quot;);
            request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response);
            return;
        }catch (FileUploadBase.SizeLimitExceededException e) {
            e.printStackTrace();
            request.setAttribute(&quot;message&quot;, &quot;上传文件的总的大小超出限制的最大值！！！&quot;);
            request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response);
            return;
        }catch (FileUploadException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            message = &quot;文件上传失败&quot;;
        }
        request.setAttribute(&quot;message&quot;,message);
        request.getRequestDispatcher(&quot;/message.jsp&quot;).forward(request, response);
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request, response);
    }
    //生成上传文件的文件名，文件名以：uuid+&quot;_&quot;+文件的原始名称
    public String mkFileName(String fileName){
        return UUID.randomUUID().toString()+&quot;_&quot;+fileName;
    }
    public String mkFilePath(String savePath,String fileName){
        //得到文件名的hashCode的值，得到的就是filename这个字符串对象在内存中的地址
        int hashcode = fileName.hashCode();
        int dir1 = hashcode&amp;amp;0xf;
        int dir2 = (hashcode&amp;amp;0xf0)&amp;gt;&amp;gt;4;
        //构造新的保存目录
        String dir = savePath + &quot;\\&quot; + dir1 + &quot;\\&quot; + dir2;
        //File既可以代表文件也可以代表目录
        File file = new File(dir);
        if(!file.exists()){
            file.mkdirs();
        }
        return dir;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码和上面不同的是添加多了一个黑名单，多了一个判断条件， &lt;code&gt;if(&quot;jsp&quot;.equals(fileExtName)||&quot;rar&quot;.equals(fileExtName)||&quot;tar&quot;.equals(fileExtName)||&quot;jar&quot;.equals(fileExtName)&lt;/code&gt;,但是这样的黑名单还是能过去绕过的。&lt;/p&gt;
&lt;p&gt;主要的审计要是看上传地方是不是黑名单，如果是黑名单，该怎么去绕过。如果是白名单，在jdk低版本中也可以使用%00截断。&lt;/p&gt;
&lt;h3 id=&quot;验证mime类型文件上传案例&quot;&gt;验证Mime类型文件上传案例&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class mimetype {
    public static String main(String fileUrl) throws IOException {
        String type = null;
        

        URL u = new URL(fileUrl);

        URLConnection uc = u.openConnection();
        type = uc.getContentType();
        return type;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;0x01 任意文件读取&lt;/p&gt;
&lt;p&gt;任意文件读取漏洞其实比较简单，基本上就2种方法，一个是字节输入流InputStream，一个是FileReader字符输入流。&lt;/p&gt;
&lt;p&gt;InputStream:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/readServlet&quot;)
public class readServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    this.doGet(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String filename = request.getParameter(&quot;filename&quot;);
        File file = new File(filename);
        OutputStream outputStream = null;
        InputStream inputStream = new FileInputStream(file);
        
        int len;
        byte[] bytes = new byte[1024];
        while(-1 != (len = inputStream.read())) {
            outputStream.write(bytes,0,len);
        }
}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FileReader:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/downServlet&quot;)
public class readServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    this.doGet(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String filename = request.getParameter(&quot;filename&quot;);
        String fileContent = &quot;&quot;;
        FileReader fileReader = new FileReader(filename);
        
        BufferedReader bufferedReader = new BufferedReader(fileReader);
        String line = &quot;&quot;;
        while (null != (line = bufferedReader.readLine())) {
            fileContent += (line + &quot;\n&quot;);
        }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两种方法除了读写方式不一样外，其余的都是一样的。&lt;/p&gt;
&lt;h2 id=&quot;0x02-任意文件下载&quot;&gt;0x02 任意文件下载&lt;/h2&gt;
&lt;p&gt;在前面的ssrf中其实提到了这个文件读取和下载，但是ssrf中是进行了远程请求的时候获取的输入流，然后进行输出。而在任意文件读取或下载中，是直接去使用io流进行读写，显示出来给我们。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/downServlet&quot;)
public class readServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    this.doGet(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        
        String filename = request.getParameter(&quot;filename&quot;);
        String fileContent = &quot;&quot;;
        FileReader fileReader = new FileReader(filename);
        response.setHeader(&quot;content-disposition&quot;, &quot;attachment;fileName=&quot; + filename);
        BufferedReader bufferedReader = new BufferedReader(fileReader);
        String line = &quot;&quot;;
        while (null != (line = bufferedReader.readLine())) {
            fileContent += (line + &quot;\n&quot;);
        }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和前面的文件读取也差不多，只是多了设置了一个响应体。&lt;/p&gt;
&lt;h2 id=&quot;0x03-任意文件删除&quot;&gt;0x03 任意文件删除&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/downServlet&quot;)
public class readServlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    this.doGet(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        String filename = request.getParameter(&quot;filename&quot;);
        File file = new File(filename);
        PrintWriter writer = response.getWriter();
        if(file != null &amp;amp;&amp;amp; file.exists() &amp;amp;&amp;amp; file.delete()) {
            writer.println(&quot;删除成功&quot;);
        } else {
            writer.println(&quot;删除失败&quot;);
        }
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;https://www.cnblogs.com/lcngu/p/5471610.html
https://xz.aliyun.com/t/6986
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x04-结尾&quot;&gt;0x04 结尾&lt;/h2&gt;
&lt;p&gt;本文的一些代码其实比较简单，但是如果实际中还是需要注意一些可能产生漏洞的点。&lt;/p&gt;
</description>
<pubDate>Sat, 19 Sep 2020 15:58:00 +0000</pubDate>
<dc:creator>nice_0e3</dc:creator>
<og:description>Java审计之文件操作漏洞篇 0x00 前言 本篇内容打算把Java审计中会遇到的一些文件操作的漏洞，都给叙述一遍。比如一些任意文件上传，文件下载，文件读取，文件删除，这些操作文件的漏洞。 0x01</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nice0e3/p/13698256.html</dc:identifier>
</item>
<item>
<title>Kubernetes入门(四)——如何在Kubernetes中部署一个可对外服务的Tensorflow机器学习模型 - bjehp</title>
<link>http://www.cnblogs.com/ljhbjehp/p/13698146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhbjehp/p/13698146.html</guid>
<description>&lt;p&gt;机器学习模型常用Docker部署，而如何对Docker部署的模型进行管理呢？工业界的解决方案是使用Kubernetes来管理、编排容器。Kubernetes的理论知识不是本文讨论的重点，这里不再赘述，有关Kubernetes的优点读者可自行Google。笔者整理的Kubernetes入门系列的侧重点是如何实操，前三节介绍了Kubernets的安装、Dashboard的安装，以及如何在Kubernetes中部署一个无状态的应用，本节将讨论如何在Kubernetes中部署一个可对外服务的Tensorflow机器学习模型，作为Kubernetes入门系列的结尾。&lt;/p&gt;
&lt;p&gt;希望Kubernetes入门系列能对K8S初学者提供一些参考，对文中描述有不同观点，或者对工业级部署与应用机器学习算法模型有什么建议，欢迎大家在评论区讨论与交流~~~&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;运行half_plus_two模型 &lt;sup&gt;[1]&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# Download the TensorFlow Serving Docker image and repo
docker pull tensorflow/serving

mkdir /data0/modules
cd /data0/modules
git clone https://github.com/tensorflow/serving
# Location of demo models
TESTDATA=&quot;/data0/modules/serving/tensorflow_serving/servables/tensorflow/testdata/&quot;

# Start TensorFlow Serving container and open the REST API port
docker run -dit --rm -p 8501:8501 \
-v /data0/modules/serving/tensorflow_serving/servables/tensorflow/testdata/saved_model_half_plus_two_cpu:/models/half_plus_two \
-e MODEL_NAME=half_plus_two  tensorflow/serving 

# Query the model using the predict API
curl -d '{&quot;instances&quot;: [1.0, 2.0, 5.0]}' \
    -X POST http://localhost:8501/v1/models/half_plus_two:predict

# Returns =&amp;gt; { &quot;predictions&quot;: [2.5, 3.0, 4.5] }
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;后台运行serving容器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;docker run -d --rm --name serving_base tensorflow/serving
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;拷贝模型数据到容器中的model目录&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;docker cp /data0/modules/serving/tensorflow_serving/servables/tensorflow/testdata/saved_model_half_plus_two_cpu serving_base:/models/half_plus_two
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;生成关于模型的镜像&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;docker commit --change &quot;ENV MODEL_NAME half_plus_two&quot; serving_base ljh/half_plus_two
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;停止serving容器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;docker kill serving_base
docker rm serving_base
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;启动服务&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;docker run -dit --rm -p 8501:8501 \
-e MODEL_NAME=half_plus_two  ljh/half_plus_two
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查询模型&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;curl -d '{&quot;instances&quot;: [1.0, 2.0, 5.0]}'    -X POST http://localhost:8501/v1/models/half_plus_two:predict

# Returns =&amp;gt; { &quot;predictions&quot;: [2.5, 3.0, 4.5] }
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;创建关于模型的deployment&quot;&gt;创建关于模型的Deployment&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;yaml文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;cat deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: halfplustwo-deployment
spec:
  selector:
    matchLabels:
      app: halfplustwo
  replicas: 1
  template:
    metadata:
      labels:
        app: halfplustwo
    spec:
      containers:
        - name: halfplustwo
          image: ljh/half_plus_two:latest
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8501
              name: restapi
            - containerPort: 8500
              name: grpc
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建一个Deployment:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;kubectl apply -f deployment.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;展示Deployment相关信息:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;kubectl get deployment -o wide
kubectl describe deployment halfplustwo-deployment
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;列出deployment创建的pods:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;kubectl get pods -l app=halfplustwo
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;展示某一个pod信息&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;kubectl describe pod &amp;lt;pod-name&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用service暴露你的应用&quot;&gt;使用service暴露你的应用&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;yaml文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;cat service.yaml
apiVersion: v1
kind: Service
metadata:
  labels:
    run: halfplustwo-service
  name: halfplustwo-service
spec:
  ports:
    - port: 8501
      targetPort: 8501
      name: restapi
    - port: 8500
      targetPort: 8500
      name: grpc
  selector:
    app: halfplustwo
  type: LoadBalancer
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;启动service&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;kubectl create -f service.yaml
or
kubectl apply -f service.yaml
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查看service&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;kubectl get service
#output:
NAME                  TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                         AGE
halfplustwo-service   LoadBalancer   10.96.181.116   &amp;lt;pending&amp;gt;     8501:30771/TCP,8500:31542/TCP   4s
kubernetes            ClusterIP      10.96.0.1       &amp;lt;none&amp;gt;        443/TCP                         8d
nginx                 NodePort       10.96.153.10    &amp;lt;none&amp;gt;        80:30088/TCP                    29h
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;curl -d '{&quot;instances&quot;: [1.0, 2.0, 5.0]}'    -X POST http://localhost:8501/v1/models/half_plus_two:predict
{&quot;predictions&quot;: [2.5, 3.0, 4.5]}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;删除deployment和service&quot;&gt;删除deployment和service&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;kubectl delete -f deployment.yaml
kubectl delete -f service.yaml
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;[1] https://www.tensorflow.org/tfx/serving/docker    TensorFlow Serving 与 Docker
[2] https://www.tensorflow.org/tfx/serving/serving_kubernetes?hl=zh_cn   将TensorFlow Serving与 Kubernetes结合使用
[3] https://towardsdatascience.com/scaling-machine-learning-models-using-tensorflow-serving-kubernetes-ed00d448c917  Scaling Machine Learning models using Tensorflow Serving &amp;amp; Kubernetes
[4] http://www.tuwee.cn/2019/03/03/Kubernetes+Tenserflow-serving%E6%90%AD%E5%BB%BA%E5%8F%AF%E5%AF%B9%E5%A4%96%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BA%94%E7%94%A8/ Kubernetes+Tenserflow-serving搭建可对外服务的机器学习应用
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 19 Sep 2020 15:26:00 +0000</pubDate>
<dc:creator>bjehp</dc:creator>
<og:description>机器学习模型常用Docker部署，而如何对Docker部署的模型进行管理呢？工业界的解决方案是使用Kubernetes来管理、编排容器。Kubernetes的理论知识不是本文讨论的重点，这里不再赘述，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ljhbjehp/p/13698146.html</dc:identifier>
</item>
<item>
<title>深度长文整理-Redis进阶 - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/13697951.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/13697951.html</guid>
<description>&lt;h3 id=&quot;一、基础&quot;&gt;一、基础&lt;/h3&gt;
&lt;p&gt;重新整理了一下，这篇笔记之前还有一篇基础相关的笔记，&lt;a href=&quot;https://www.cnblogs.com/ZhuChangwu/p/11150535.html&quot;&gt;点击进入&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222317905-1049971542.png&quot; alt=&quot;image-20200919193313950&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、为什么redis是单线程的？&quot;&gt;二、为什么Redis是单线程的？&lt;/h3&gt;
&lt;p&gt;官方回答：&lt;/p&gt;
&lt;p&gt;Redis是基于内存操作，CPU不是Redis的性能瓶颈，Redis的性能瓶颈是机器的内存大小、以及网络的带宽，既然单线程容易实现，那就直接使用单线程来实现了&lt;/p&gt;
&lt;p&gt;此外：&lt;/p&gt;
&lt;p&gt;使用单线程实现，那所有的命令就会排队执行，不需要考虑各种同步问题和加锁带来的性能消耗问题。&lt;/p&gt;
&lt;p&gt;既然CPU不是Redis的瓶颈，那么如果不想让服务器的其他CPU闲置，可以考虑起多个Redis进程，因为Redis不是关系型数据库，数据之间也没有约束。这样还能搭建集群，分压分流。&lt;/p&gt;
&lt;h3 id=&quot;三、为什么单线程这么快？&quot;&gt;三、为什么单线程这么快？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Redis是一款内存数据库，基于内存的读写速度本来就很快&lt;/li&gt;
&lt;li&gt;如果使用多线程的话会有线程上下文的切换。对于内存系统来说，单线程操作内存的效率才是最高的。&lt;/li&gt;
&lt;li&gt;Redis使用了epoll IO多路复用，可以实现用一条线程处理并发的网络请求&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;四、select、poll、epoll&quot;&gt;四、select、poll、epoll&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;我可能对这块对理解是稍微有点问题，epoll漏掉了树、队列这些细节，我后续会修改，然后会去掉这段话&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以直接看这篇文章，讲的很好的：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/63179839&quot;&gt;https://zhuanlan.zhihu.com/p/63179839&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;select、poll、eopll是操作系统处理网络上传输过来的数据的不同实现，数据从经过网线流入网卡，网卡中的驱动程序会向CPU发出中断信号，在交互系统中，中断信号的优先级是很高的，CPU立刻去处理这个中断信息，CPU通过终端表找到相应的处理函数：&lt;/p&gt;
&lt;p&gt;1、禁用网卡的中断信号，告诉网卡下次有数据过来直接写内存就ok&lt;/p&gt;
&lt;p&gt;2、通过驱动程序申请、初始化一块内存，将网卡中的数据写进内存中&lt;/p&gt;
&lt;p&gt;3、然后解析处理数据：操作系统先校验数据是否符合os structure、数据往上层传递，&lt;strong&gt;Ehthernet校验数据&lt;/strong&gt;是否符合预期的格式，继续向上层传递到ip层，再往上到tcp/udp层并按照指定的协议去解析&lt;/p&gt;
&lt;p&gt;4、应用层想使用这部分数据就有一个拆包+格式校验的过程&lt;/p&gt;
&lt;p&gt;内存指的的socket文件的接受缓冲区。&lt;/p&gt;
&lt;p&gt;作为一个网络服务器同一时刻可能有多个socket和他建立连接与他进行数据的交互，这里的select、poll、epoll说的其实就是在众多的socket中如何快速高效的找到接受缓冲区存在数据的socket文件，然后交给应用层的代码去处理它&lt;/p&gt;
&lt;p&gt;Select模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-85dba5430f3c439e4647ea4d97ba54fc_hd.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;操作系统为每一个Tcp连接都会相应的创建sock文件，这些sock文件隶属于操作系统的文件列表。&lt;/p&gt;
&lt;p&gt;当sock2收到了数据，会调用中断程序唤醒进程A，将进程A从所有的Sock的等来队列中移除，加入到内核空间的工作队列中进程A只知道至少有一个sock的接受缓冲区已经由数据了，但是它不知道到底是哪个sock，所以它得通过遍历sock列表的方式找到这个sock。&lt;/p&gt;
&lt;p&gt;select的缺点和不足：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进程A需要添加进所有的sock的等待队列中，这会进行一次遍历。&lt;/li&gt;
&lt;li&gt;当有sock就收到数据时，又得将进程A从所有的sock等待队列中移除，这又是一次遍历。&lt;/li&gt;
&lt;li&gt;进程A寻找有数据的sock时，还会发生一次遍历。&lt;/li&gt;
&lt;li&gt;为了放置单个进程将系统的所有资源都耗干，linux会限制单个进程能打开的fd文件句柄数，即使你可以修改配置，突破这会个限制&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Poll模型&lt;/p&gt;
&lt;p&gt;poll本质上和select没有区别，都会进行好几次无谓的遍历才能找到到底是那个sock文件的接受缓冲区中接受到了数据。&lt;/p&gt;
&lt;p&gt;优点：它没有最大连接数的限制，原因是&lt;strong&gt;它是基于链表来存储的文件句柄的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Epoll模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_hd.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Epoll的设计目标就是优化掉Select 和 Poll模型中查找接收到数据的sock文件时进行的无谓的遍历操作。&lt;/p&gt;
&lt;p&gt;看上图：在select模型中，需要将进程添加进每一个sock的等待队列，然后阻塞，假如10万TCP连接对应着10万个sock文件，那这个添加+阻塞的操作就得重复10万次&lt;/p&gt;
&lt;p&gt;对于epoll来说可以看到，这个添加的过程只进行了一次...见下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-40bd5825e27cf49b7fd9a59dfcbe4d6f_1440w.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int s = socket(AF_INET, SOCK_STREAM, 0);   
bind(s, ...)
listen(s, ...)
 
int epfd = epoll_create(...);
epoll_ctl(epfd, ...); //将所有需要监听的socket添加到epfd中
 
while(1){
    int n = epoll_wait(...)
    for(接收到数据的socket){
        //处理
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当执行系统调用 epoll_create(...) 内核会创建上图中的eventpoll对象，eventpoll对象也隶属于操作系统的文件系统，此外所有的sock都注册在eventpoll中。&lt;/p&gt;
&lt;p&gt;进程不再注册在每一个sock的等待队列中，而是注册在eventpoll的等待队列中，此外，接受缓冲区存在数据的sock会被注册进eventpoll的rdlist中。这样当进程再次被唤醒添加到操作系统的工作队列中时，从eventpoll的rdlist中就能确切的获取到哪些sock是需要处理的sock，免去了遍历之苦&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Epoll的连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考(这个大佬讲的超级好)：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/63179839&quot;&gt;https://zhuanlan.zhihu.com/p/63179839&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;五、redis的事务&quot;&gt;五、Redis的事务&lt;/h3&gt;
&lt;p&gt;原子性：一组命令要么同时成功，要么同时失败&lt;/p&gt;
&lt;p&gt;但是redis中的每一条单独的命令是有原子性的，但是Redis中的事务不能保证原子性&lt;/p&gt;
&lt;p&gt;redis中的事务没有隔离级别的概念，不可能出现脏读、幻读、不可重复读&lt;/p&gt;
&lt;p&gt;在redis中，事务的本质是一组命令的集合，一个事务中的所有命令都会有被序列化，在事务执行的过程中：顺序、排他、一次性执行。&lt;/p&gt;
&lt;p&gt;Redis事务的过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开启事务&lt;/li&gt;
&lt;li&gt;一连串普通命令&lt;/li&gt;
&lt;li&gt;执行事务&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 开启事务
127.0.0.1:16379&amp;gt; MULTI
OK

# 添加命令
127.0.0.1:16379&amp;gt; SET k1 v1
QUEUED
127.0.0.1:16379&amp;gt; SET k2 v2
QUEUED

# 执行事务
127.0.0.1:16379&amp;gt; EXEC
1) OK
2) OK
127.0.0.1:16379&amp;gt;

# 开启事务
127.0.0.1:16379&amp;gt; MULTI
OK
# 添加命令
127.0.0.1:16379&amp;gt; set k3 v3
QUEUED
127.0.0.1:16379&amp;gt; SET k4 v4
QUEUED
# 取消事务
127.0.0.1:16379&amp;gt; DISCARD
OK
# 检查结果，确实没有执行刚刚添加的命令
127.0.0.1:16379&amp;gt; keys *
1) &quot;k1&quot;
2) &quot;k2&quot;
127.0.0.1:16379&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设开启时候后，多条命令中有一个命令出现运行时异常有什么影响？&lt;/p&gt;
&lt;p&gt;出现异常的命令不会被执行，但是这个异常的命令不会影响它后面的命令执行，因为这个原因我们说redis的事务不支持原子性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# k1的值为字符串
127.0.0.1:16379&amp;gt; set k1 &quot;v1&quot;
OK
# 开启事务
127.0.0.1:16379&amp;gt; MULTI
OK
# 设置事务的值
127.0.0.1:16379&amp;gt; set k2 v2
QUEUED
# 对字符串类型的值+1，会抛出运行时异常
127.0.0.1:16379&amp;gt; INCR k1
QUEUED
# 继续添加两个值
127.0.0.1:16379&amp;gt; set k3 v3
QUEUED
127.0.0.1:16379&amp;gt; set k4 v4
QUEUED
# 执行事务，看到，运行时异常的命令不会影响后续的命令执行
127.0.0.1:16379&amp;gt; exec
1) OK
2) (error) ERR value is not an integer or out of range
3) OK
4) OK
127.0.0.1:16379&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设开启时候后，多条命令中有一个命令出现编译异常有什么影响？&lt;/p&gt;
&lt;p&gt;出现编译型异常，所有的命令都不会被执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 开启事务
127.0.0.1:16379&amp;gt; MULTI
OK
# 往命令队列中添加命令
127.0.0.1:16379&amp;gt; set k1 v1
QUEUED
127.0.0.1:16379&amp;gt; set k2 v2
QUEUED
# 故意添加一个语法错误的命令，导致编译异常
127.0.0.1:16379&amp;gt; GETSET k3
(error) ERR wrong number of arguments for 'getset' command
127.0.0.1:16379&amp;gt; set k4 v4
QUEUED
# 执行事务
127.0.0.1:16379&amp;gt; exec
(error) EXECABORT Transaction discarded because of previous errors.
# 检查结果，发现所有的命令都没有被执行
127.0.0.1:16379&amp;gt; keys *
(empty list or set)
127.0.0.1:16379&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CAP理论&lt;/p&gt;
&lt;p&gt;nosql同样也有一套属于自己的CAP&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;C(Consistency 强一致性)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A(Availability可用性)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P(Partition tolerance分区容错性)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CAP 的理论核心是: 一个分布式的系统,不可能很好的满足一致性,可用性,分区容错性这三个需求,最多同时只能满足两个.因此CAP原理将nosql分成了三大原则:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CA- 单点集群,满足强一致性和可用性,比如说oracle,扩展性收到了限制&lt;/li&gt;
&lt;li&gt;CP- 满足一致性,和分区容错性&lt;strong&gt;Redis和MongoDB都属于这种类型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;AP- 选择了可用性和分区容错性,他也是大多数网站的选择,容忍数据可以暂时不一致,但是不容忍系统挂掉&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;六、redis的监控&quot;&gt;六、Redis的监控&lt;/h3&gt;
&lt;p&gt;redis可使用watch监视某一个key，然后开启事务操作某一个key，当key没有发生异常变动时，事务正常结束&lt;/p&gt;
&lt;p&gt;一旦事务成功执行后，watch就会自动取消掉&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;127.0.0.1:16379&amp;gt; set money 100
OK
127.0.0.1:16379&amp;gt; set out 0
OK
# 监视key
127.0.0.1:16379&amp;gt; WATCH money
OK
127.0.0.1:16379&amp;gt; MULTI
OK
127.0.0.1:16379&amp;gt; DECRBY money 20
QUEUED
127.0.0.1:16379&amp;gt; INCRBY out 20
QUEUED
127.0.0.1:16379&amp;gt; exec
1) (integer) 80
2) (integer) 20
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面演示一个出现异常的例子：&lt;/p&gt;
&lt;p&gt;事务中，添加watch的key被修改后，执行事务返回nil，表示失败&lt;/p&gt;
&lt;p&gt;验证了watch机制使用的是乐观锁机制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222319792-365831141.png&quot; alt=&quot;image-20200919095619327&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当遇到上面这种返回nil的情况下，可以像下面这样处理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 取消监视（解锁）
127.0.0.1:16379&amp;gt; UNWATCH
OK
# 重新监视
127.0.0.1:16379&amp;gt; watch money
OK
# 重新开启事务
127.0.0.1:16379&amp;gt; MULTI
OK
127.0.0.1:16379&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;七、redis的配置文件&quot;&gt;七、Redis的配置文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;## 启动redis的方式
./redis-server /path/to/redis.conf

# 可以像下面这样让在当前配置文件包含引用其他配置文件
include /path/to/local.conf
include /path/to/other.conf

# 指定哪些客户端可以连接使用redis
Examples:
bind 192.168.1.100 10.0.0.1  # 指定ip
bind 127.0.0.1 ::1 # 仅限于本机可访问

# 是否处于受保护的模式，默认开启
protected-mode yes

# 对外暴露的端口
port 16379

# TCP的通用配置
tcp-backlog 511
timeout 0
tcp-keepalive 300

# 是否以守护进程的方式运行，默认为no
daemonize yes

# 如果进程在后台运行，需要指定这个pid文件
pidfile /var/run/redis_6379.pid

# 日志级别
# debug 测试开发节点
# verbose (和dubug很像，会产生大量日志)
# notice (生产环境使用)
# warning (only very important / critical messages are logged)
loglevel notice

# 日志文件名
logfile &quot;&quot;

# 数据库的数量，默认16个
databases 16

# 是否总是显示logo
always-show-logo yes


# 设置redis的登陆密码（默认没有密码）
# 设置完密码后，使用redis-cli登陆时，使用auth password 认证登陆
requirepass foobared

# 设置能连接上redis的客户端的最大数量
maxclients 10000

# 给redis设置最大的内存容量
maxmemory &amp;lt;bytes&amp;gt;

# 内存达到上限后的处理策略
# volatile-lru -&amp;gt; 只针对设置了过期时间的key进行LRU移除
# allkeys-lru -&amp;gt; 删除LRU算法的Key
# volatile-lfu -&amp;gt; 使用具有过期集的密钥在近似的LFU中进行驱逐。
# allkeys-lfu -&amp;gt; 使用近似的LFU退出任何密钥。
# volatile-random -&amp;gt; 随机删除即将过期的key
# allkeys-random -&amp;gt; 随机删除
# volatile-ttl -&amp;gt; 删除即将过期的
# noeviction -&amp;gt; 永不过期，返回错误
maxmemory-policy noeviction
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;八、redis的持久化&quot;&gt;八、Redis的持久化&lt;/h3&gt;
&lt;h4 id=&quot;81、fork系统调用&quot;&gt;8.1、fork()系统调用&lt;/h4&gt;
&lt;p&gt;这里很突兀的来个fork()系统调用原因是应为：Redis的单线程的，那如果主线程去做这种耗时的IO同步操作时，Redis整体的性能会被拖垮的。&lt;/p&gt;
&lt;p&gt;fork()它是一个系统调用，一般用它来创建一个和当前进程一模一样的子进程。当在程序中调用它时，系统为新的进程分配存储、资源，将原程序中的值也复制给他。&lt;/p&gt;
&lt;p&gt;fork()函数调用一次会返回两次，在父进程得到的返回值是子进程的pid，在子进程中得到的是0，出错则返回负数。&lt;/p&gt;
&lt;p&gt;Redis的实现是通过fork()系统调用创建一个子进程。 由这个子进程去负责执行这些耗时的IO操作，父子进程会共享内存，然后被共享的这块内存不可写，新的数据写入到新的内存文件中&lt;/p&gt;
&lt;h4 id=&quot;82、rdb&quot;&gt;8.2、RDB&lt;/h4&gt;
&lt;p&gt;写RDB文件是Redis的一种持久化方式。在指定的时间间隔内将内存中的数据写入到磁盘，RDB文件是一个紧凑的二进制文件，每一个文件都代表了&lt;strong&gt;某一个时刻&lt;/strong&gt;（执行fork的时刻）Redis完整的数据快照，恢复数据时，将快照文件读入内存即可。&lt;/p&gt;
&lt;p&gt;RDB持久化的详细过程:&lt;/p&gt;
&lt;p&gt;Redis会通过系统调用fork()出一个子进程，父子进程是会共享内存的，父进程和子进程共享的这块内存就是在执行fork操作那个时刻的内存快照。由linux的copy on write机制将父子进程共享的这块内存标记为只读状态。&lt;/p&gt;
&lt;p&gt;此时对子进程来说，它的任务就是将这块只读内存中的数据保存成RDB文件。&lt;/p&gt;
&lt;p&gt;对父进程来说它是有可能收到写命令的，当父进程尝试往这个加了只读状态的内存地址写入数据时，就会触发保护异常，执行linux的 copy on write，也就是将原来内存对应的数据页复制出来一份后，然后对这个副本进行修改。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;这里就会出现一个丢数据的概念：你想，fork出来的子进程将要保存的数据是执行fork系统调用那个时刻的内存中的数据，很快这个内存就被标记为只读了，后续的增量数据没有写入到这个只读内存中，那就算是RDB成功生成了，这些增量的数据依然会丢（所以得使用AOF辅助）&lt;/p&gt;
&lt;p&gt;第二种RDB出现数据的丢失的情况是：RDB过程中，直接失败了，文件都没生成，不光是增量数据，原来的数据都丢了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/rnceU9sSG0VC_e-JYsDqbQ&quot;&gt;参考：linux的copy on write&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/&quot;&gt;欢迎关注大佬：三国梦回&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RDB相关配置如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 把下面的注释打开就会禁用掉RDB的持久化策略
# save &quot;&quot;

# 快照相关，指的是在规定的时间内执行了多少次操作才会持久化到文件
save 900 1 # 900秒内1次
save 300 10 # 300秒内10次
save 60 10000 # 60秒内1万次

# 持久化出错了，是否让redis继续工作
stop-writes-on-bgsave-error yes

# 是否压缩RBD文件（redis会采用LZF压缩算法进行压缩）需要消耗CPU资源
rdbcompression yes

# 保存rbc文件时是否检验rbd文件格式
# 使用CRC64算法进行数据校验,但是这样会增加大约 10%的性能消耗
rdbchecksum yes

# dump DB的文件名
dbfilename dump.rdb

# rdb文件的持久化目录（当前目录）
dir ./
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;触发保存RDB文件4种情况&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;手动执行save命令、bgsave&lt;/li&gt;
&lt;li&gt;满足配置文件中配置的save相关配置项时，自动触发&lt;/li&gt;
&lt;li&gt;手动执行flushall&lt;/li&gt;
&lt;li&gt;关闭redisshutdown&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如何让redis加载rdb文件？&lt;/p&gt;
&lt;p&gt;只需要将rdb文件放在redis的启动目录下，redis其中时会自动加载它&lt;/p&gt;
&lt;p&gt;RDB模式的优缺点：&lt;/p&gt;
&lt;p&gt;优点：RDB过程中，由子进程代替主进程进行备份的IO操作。保证了主进程仍然提供高性能的服务。适合大规模的数据备份恢复过程。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;默认情况下，它是每隔一段时间进行一次数据备份，所以一旦出现最后一次持久化的数据丢失，将丢失大规模的数据。&lt;/li&gt;
&lt;li&gt;fork()子进程时会占用一定的内存空间，如果在fork()子进程的过程中，父进程夯住了，那也就是redis卡住了，不能对外提供服务。所以不要让生成RDB文件的时间间隔太长，不然每次生成的RDB文件过大对Redis本身也是有影响的。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;83、aof&quot;&gt;8.3、AOF&lt;/h4&gt;
&lt;p&gt;AOF是什么？&lt;/p&gt;
&lt;p&gt;Append Only File，他也是Redis的持久化策略。即将所有的写命令都以日志的方式追加记录下来（只追加，不修改），恢复的时候将这个文件中的命令读出来回放。&lt;/p&gt;
&lt;p&gt;当我们执行 flushall 命令,清空了redis在内存中的数据，appendonly.aof 同样会记录下这条命令,所以,我们想恢复数据的话,需要去除 appendonly.aof 里面的 flushall 命令&lt;/p&gt;
&lt;p&gt;AOF相关的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 默认不开启aof
appendonly no

# aof文件名
appendfilename &quot;appendonly.aof&quot;

# redis通过fsync()调用告诉操作系统实际在磁盘上写入数据
# aof文件落盘的策略
# appendfsync always 每次发生数据变更,立刻记录到磁盘，但是导致redis吞吐量降低
# appendfsync everysec 可能会丢失1秒的数据
# appendfsync no
appendfsync everysec

# 当时用bfwriteaof时，fork一个子进程写aof文件，就算aof文件很大，也不会阻塞主进程
# 意外情况：但是当主进程、子进程同时写aof文件时，可能会出现由于子进程大量的IO操作阻塞主进程
# 当出现这种意外情况时：设置这个参数为no，可以保证数据不会丢失，但是得容忍主进程被阻塞
# 当出现这种意外情况时：设置这个参数为yes,主进程不会被阻塞主，但是不保证数据安全性
# 综上：如果应用无法忍受延迟：设置为yes。无法忍受数据丢失：设置为no
no-appendfsync-on-rewrite no

# 在当前aof文件的体积超过上次aof文件的体积的100%时，写新文件
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb # 最开始的aof文件体积至少达到60M时才重写

# 回放aof文件时，如果最后一条命令存在问题，是否允许忽略
aof-load-truncated yes

# 是否允许AOF和RDB这两种持久化方式并存
aof-use-rdb-preamble yes
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当aof文件出错怎么办？&lt;/p&gt;
&lt;p&gt;redis为我们提供了修复aof文件的工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222321582-1198484015.png&quot; alt=&quot;image-20200919120015772&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@instance-lynj0v9k-19 bin]# redis-check-aof  --fix appendonly.aof
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;aof模式的优缺点 优点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;aof是用追加的形式写，没有随机磁盘IO那样的寻址开销，性能还是比较高的。&lt;/li&gt;
&lt;li&gt;aof可以更好的保护数据不丢失或者尽可能的少丢失：设置让redis每秒同步一次数据，即使redis宕机了，最多也就丢失1秒的数据。&lt;/li&gt;
&lt;li&gt;即使aof真的体积很大，也可以设置后台重写，不影响客户端的重写。&lt;/li&gt;
&lt;li&gt;aof适合做灾难性的误删除紧急恢复：比如不小心执行了flushall，然后可以在发生rewrite之前 快速备份下aof文件，去掉末尾的 flushall，通过恢复机制恢复数据&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;缺点：使用aof一直追加写，导致aof的体积远大于RDB文件的体积，恢复数据、修复的速度要比rdb慢很多。&lt;/p&gt;
&lt;p&gt;aof的重写&lt;/p&gt;
&lt;p&gt;AOF采取的是文件追加的方式,文件的体积越来越大,为了优化这种现象,增加了重写机制,当aof文件的体积到达我们在上面的配置文件上的阕值时,就会触发重写策略,只保留和数据恢复相关的命令&lt;/p&gt;
&lt;p&gt;手动触发重写&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# redis会fork出一条新的进程
# 同样是先复制到一份新的临时文件,最后再rename,遍历每一条语句,记录下有set的语句
bgrewriteaof
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;84、rdb和aof的选择&quot;&gt;8.4、RDB和AOF的选择&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;如果我们的redis只是简单的作为缓存，那两者都不要也没事&lt;/li&gt;
&lt;li&gt;如果数据需要持久化，那不要仅仅使用RDB，因为一旦发生故障，你会丢失很多数据&lt;/li&gt;
&lt;li&gt;同时开启两者: 在这种情况下,redis优先加载的是aof,因为它的数据很可能比rdb更全,但是并不建议只是用aof,因为aof不是那么的安全,很可能存在潜在的bug&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;推荐：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;建议在从机slave上只备份rdb文件，而且只要15分钟备份一次就够了。&lt;/li&gt;
&lt;li&gt;如果启动了aof,我们尽量减少rewrite的频率,基础大小设置为5G完全可以,起步也要3G。&lt;/li&gt;
&lt;li&gt;如果我们不选择aof, 而是选择了主从复制的架构实现高可用同样可以,能省掉一大笔IO操作,但是意外发生的话,会丢失十几分钟的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;九、发布订阅&quot;&gt;九、发布订阅&lt;/h3&gt;
&lt;p&gt;Redis的发布订阅模型是一种：消息通信方式，发布者发送到redis到队列中，消息的订阅者可以接收到消息，Redis的客户端可以订阅任意数量的消息&lt;/p&gt;
&lt;p&gt;应用场景：关注订阅、消息推送、实时广播、网络聊天室&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png&quot; alt=&quot;chanel1频道&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.runoob.com/wp-content/uploads/2014/11/pubsub2.png&quot; alt=&quot;订阅发布&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试发布、订阅&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222323200-1435439108.png&quot; alt=&quot;image-20200919141129930&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;十、主从复制&quot;&gt;十、主从复制&lt;/h3&gt;
&lt;p&gt;概念：和MySQL的主从复制的概念大同小异，分成leader节点和follower节点，主节点承接线上的写流量，从节点承接线上的读流量为主库分流减压，从库的数据从主库中同步过来&lt;/p&gt;
&lt;p&gt;主从复制的作用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;理论上主库从库的数据是需要保持的，这也是一种数据冗余热备份的机制&lt;/li&gt;
&lt;li&gt;故障恢复：当leader节点出现故障时，可以由从节点提供服务，保证应用的可用性&lt;/li&gt;
&lt;li&gt;负载均衡：在主从复制的接触上，可以将客户端的读写不同类型的流量分摊到不同的机器上，分流减压&lt;/li&gt;
&lt;li&gt;主从复制+哨兵，构建高可用的redis集群，解决了单点故障问题&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;十一、集群搭建及小实验&quot;&gt;十一、集群搭建及小实验&lt;/h3&gt;
&lt;p&gt;redis默认自己就是一个主库，所以我们搭建主从架构的redis，只需要配置Redis从库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222324352-433841505.png&quot; alt=&quot;image-20200919142947104&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;111、架构一：一主两从&quot;&gt;11.1、架构一：一主两从&lt;/h4&gt;
&lt;p&gt;下面搭建这样的一主两从的redis集群&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222325535-1079573856.png&quot; alt=&quot;image-20200919152728847&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;role&lt;/th&gt;
&lt;th&gt;ip&lt;/th&gt;
&lt;th&gt;port&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;主库&lt;/td&gt;
&lt;td&gt;xxx&lt;/td&gt;
&lt;td&gt;16379&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;从库&lt;/td&gt;
&lt;td&gt;xxx&lt;/td&gt;
&lt;td&gt;16378&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;从库&lt;/td&gt;
&lt;td&gt;xxx&lt;/td&gt;
&lt;td&gt;16377&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果是在一台服务器上启动多台Redis，需要修改一下配置文件中的端口、pid文件名、日志名、dump.db名&lt;/p&gt;
&lt;p&gt;启动三台redis&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222328424-1648907372.png&quot; alt=&quot;image-20200919143804002&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让16378、16377认16379为leader，执行如下命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222331313-904951350.png&quot; alt=&quot;image-20200919145315854&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;搭建完主从环境之后，查看是否可以从slave中写入数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 结果很明显，不能写入
127.0.0.1:16378&amp;gt; set k1 v0
(error) READONLY You can't write against a read only replica.
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;MySQL中只要你不设置从库read only，从库也是可以写入的并产生自己的binlog的&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试：从master写入，从slave读出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222335542-1550081902.png&quot; alt=&quot;image-20200919145910731&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试：主机宕机，slave有什么表现&lt;/p&gt;
&lt;p&gt;主机宕机后，从库的role依然是slave，并且显示master的状态为down&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222338157-1252921818.png&quot; alt=&quot;image-20200919150316225&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试：主机宕机后又重启了，slave有什么表现&lt;/p&gt;
&lt;p&gt;主机重启后，slave会重连主机，主机的状态为up，salve可以正常在主库上同步数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222340443-158511119.png&quot; alt=&quot;image-20200919150815126&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试：从机宕机，然后有新数据写到了主库，从机再重启问：重启后的从机能不能获取到她宕机期间主库的增量数据？&lt;/p&gt;
&lt;p&gt;答案是：获取不到了，因为如果是通过命令行搭建的主从，从库一旦重启，角色会变回master&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222343349-84441522.png&quot; alt=&quot;image-20200919151448322&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果这时再把16378变成16379的从库，问能不能获取到增量数据呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222346278-1973581827.png&quot; alt=&quot;image-20200919151904041&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;全量复制和增量复制&lt;/p&gt;
&lt;p&gt;从库第一次连接到主库上肯定会进行一次全量复制，即：master会启动后台的存盘进程，同时收集所有用于修改数据集的命令，在后台完成同步，然后将整个数据文件发送给slave，让slave完成一次数据的全量复制&lt;/p&gt;
&lt;p&gt;除第一次复制数据之外的主从复制都是增量复制，即master仅仅会将收到的增量写命令发送给slave。&lt;/p&gt;
&lt;h4 id=&quot;112、架构二&quot;&gt;11.2、架构二&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222347215-1341399832.png&quot; alt=&quot;image-20200919154359193&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的17378既是Master又是Slave&lt;/p&gt;
&lt;p&gt;对于16377来说，它确实认了16378为主，但是16378本身又是16379的slave，所以他们之间数据同步的走向是 ： 16379 --&amp;gt; 16378 --&amp;gt; 16377 ，对于16378来说，即使有实例认它当master，它依然是不能写&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222352377-863805464.png&quot; alt=&quot;image-20200919154111295&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果主库16379宕机了，16378的状态依然是slave，并且它能察觉master已经挂了，执行 slave no one, 可以将自己提升为master。 在整个过程中，16377不受影响&lt;/p&gt;
&lt;p&gt;即使旧master开机重启了，旧的master依然是master，也不能自动的加入到 16377 16378集群中&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222356333-1066997191.png&quot; alt=&quot;image-20200919160136653&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;113、架构三：sentinel&quot;&gt;11.3、架构三：Sentinel&lt;/h4&gt;
&lt;p&gt;上面的两种架构模式中，主库挂了之后都需要人为的去选举一个的新的master来承接读流量&lt;/p&gt;
&lt;p&gt;redis2.8之之后，提供了哨兵模式：哨兵监控到当主服务器挂了，发起投票选新主库，实现自动的完成选主，承接线上写流量，完成止损&lt;/p&gt;
&lt;p&gt;哨兵作为一个独立的进程存在，原理是：哨兵通过发送命令和redis服务器交互，从而监控运行整个集群中的多个Redis实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222357409-54791756.png&quot; alt=&quot;image-20200919161434493&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Redis的哨兵在Redis 的安装目录下可以找到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222359733-864723860.png&quot; alt=&quot;image-20200919161605419&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了防护哨兵出现单点故障，所以通常使用多个哨兵对集群进行监控&lt;/p&gt;
&lt;p&gt;集群中的每个哨兵彼此相互监控，每个哨兵也都监控着集群中的所有Redis实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222401129-1271129499.png&quot; alt=&quot;image-20200919162152949&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主观下线和客观下线&lt;/p&gt;
&lt;p&gt;当一个哨兵发现master不可用时，系统不会马上进行failover，仅仅是这一个哨兵主观意义上认为这个master不可用，这时如果其他的哨兵也来探测master，并且大部分的哨兵都主观认为master确实不可用了，哨兵们就会投票在slave中选出一个当得票最多的slave作为新的master。进行failover操作。&lt;/p&gt;
&lt;p&gt;通过发布订阅的模式，哨兵告诉自己监控的那些服务器将master切换为刚刚的票最多的那个实例，这个过程就叫做&lt;strong&gt;客观下线&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;集群搭建&lt;/p&gt;
&lt;p&gt;首先是创建一主二从的redis集群, 此处省略，参照上面架构1部分即可&lt;/p&gt;
&lt;p&gt;编写sentinel的配置文件，配置文件的名称、配置项不能写错～&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# myredis1 监控的这个redis实例啥
# 127.0.0.1 监控的这个redis实例的ip
# 16379 监控的这个redis实例的端口
# 1 监控的这个redis实例的挂了后，自动投票选主
sentinel monitor myredis1 127.0.0.1 16379 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动sentinel&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919222405076-1888123804.png&quot; alt=&quot;image-20200919164321594&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，当master宕机后，哨兵会自动选择一个新的slave作为新主，主库重启后，sentinel会将其作为slave自动加入到现有的redis集群中&lt;/p&gt;
&lt;p&gt;更多更详细的sentinel配置文件可以看看这个博文：&lt;a href=&quot;https://www.cnblogs.com/heroinss/p/10340925.html&quot;&gt;https://www.cnblogs.com/heroinss/p/10340925.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;十二、缓存穿透、缓存击穿、雪崩&quot;&gt;十二、缓存穿透、缓存击穿、雪崩&lt;/h3&gt;
&lt;p&gt;缓存穿透&lt;/p&gt;
&lt;p&gt;比如这种应用场景：使用redis缓存用户信息，当有新用户注册时先将用户的信息写入Redis，然后写入Mysql，有修改操作时，修改完MySQl中的数据后，同步的也会修改Redis中的数据，而且我们也没有给Redis中的key设置过期时间。（这就意味着，数据库中有指定的KV的信息的话，缓存中也会有。那当用户查询时缓存中没有的话，说明数据库中99.999%也不会有）&lt;/p&gt;
&lt;p&gt;这时候有大量的请求突然打向了Redis，Redis中又没有存储用户查询的数据，大量的请求一下子打到了数据库上，瞬间击垮数据库，这种现象称为缓存穿透。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;布隆过滤器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202009/1496926-20200919224835199-976986131.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;布隆过滤器可以理解成一个bit数组，数组中每一个非0即1&lt;/p&gt;
&lt;p&gt;客户端的请求统一先打向布隆过滤器，布隆过滤器放在应用的控制层，布隆过滤器中存在多个hash函数，分别对这个key进行hash得到hashcode，然后将hashcode%数组长度，将算出来的下标标记为1。&lt;/p&gt;
&lt;p&gt;key以此经过所有hash，再%size算出的下标对应的值，只要存在一个不为1的数，我们就认为key没在缓存中，直接丢弃用户的这次请求，符合要求把请求打向Redis。从而避免这个请求对底层存储的查询压力。&lt;/p&gt;
&lt;p&gt;缓存空对象：&lt;/p&gt;
&lt;p&gt;当用户查询的时候，如果发现缓存中没有，就往缓存中放置一个空的对象，然后返回给用户这个控对象，也能避免用户的请求直接打向数据库。&lt;/p&gt;
&lt;p&gt;缓存击穿：&lt;/p&gt;
&lt;p&gt;缓存击穿指的是Redis中确确实实存在用户查询的key，但是呢用户的访问频率太猛烈了，导致Redis扛不住挂了，导致大量的请求直接打向数据库，或者当某一个key的过期时间到了的瞬间，大量的请求打向数据库导致数据库直接挂了&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置key永不过期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加互斥锁&lt;/strong&gt;：对这个查询操作添加分布式锁，将原来的大并发直接访问缓存转换成了并发获取分布式锁，只有获取到分布式锁后才能去查询缓存。&lt;/p&gt;
&lt;p&gt;雪崩：&lt;/p&gt;
&lt;p&gt;比我们启动redis进行一些数据预热，就是将一些数据库中的数据提前导入到redis中，然后给这些数据设置了过期时间。&lt;/p&gt;
&lt;p&gt;抢购时间一到系统迎来了一大批并发，但是由于缓存中的数据充足，所以能扛住这波并发。一段时间后，redis中的key集中式的过期了，这时再来一大批并发请求可能就直接将redis打垮。redis挂了后，大量的请求直接打向MySQL，导致MySQL跟着雪崩式的垮掉&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;异地多活，添加redis的实例的数量&lt;/p&gt;
&lt;p&gt;加分布式锁&lt;/p&gt;
&lt;p&gt;在应用和缓存之间添加消息中间件做缓冲&lt;/p&gt;
&lt;p&gt;合理为不同的key设置不同的过期时间，放置缓存中的key出现集中式过期的情况&lt;/p&gt;
</description>
<pubDate>Sat, 19 Sep 2020 14:49:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>一、基础 重新整理了一下，这篇笔记之前还有一篇基础相关的笔记，点击进入 二、为什么Redis是单线程的？ 官方回答： Redis是基于内存操作，CPU不是Redis的性能瓶颈，Redis的性能瓶颈是机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/13697951.html</dc:identifier>
</item>
<item>
<title>现代C++教程：高速上手(四）-容器 - Ryan669</title>
<link>http://www.cnblogs.com/coding-space/p/13697991.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coding-space/p/13697991.html</guid>
<description>&lt;h2 id=&quot;1、线性容器&quot;&gt;1、线性容器&lt;/h2&gt;
&lt;p&gt;std::array与std::vector不同的是，array对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用std::array容器。&lt;/p&gt;
&lt;p&gt;由于std::vector是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作，容器并不会自动归还被删除元素相应的内存，这时候需要手动运行shrink_to_fit()释放这部分内存。&lt;/p&gt;
&lt;p&gt;std::array C风格接口传参：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void foo(int *p, int len){
    return;
}
std::array&amp;lt;int, 4&amp;gt; arr = {1,2,3,4};
//foo(arr,arr.size()); //非法，无法隐式转换
foo(&amp;amp;arr[0], arr.size());
foo(arr.data(), arr.size());

//使用std::sort
std::sort(arr.begin(), arr.end());
//升序
std::sort(arr.begin(), arr.end(), [](int a, int b){
    return b &amp;gt; a;
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;std::forward_list是一个列表容器，使用方法和std::list基本类似。和list的双向链表的实现不同，forward_list使用单向链表进行实现，提供了O(1)复杂度的元素插入，不支持快速随机访问，也是标准库容器中唯一一个不提供size()方法的容器。当不需要双向迭代时，具有比list更高的空间利用率。&lt;/p&gt;
&lt;h2 id=&quot;2、无序容器&quot;&gt;2、无序容器&lt;/h2&gt;
&lt;p&gt;传统c++中的有序容器 std::map / std::set，这些元素内部通过红黑树进行实现，插入和搜索的平均复杂度均为O(log(size))。在插入元素时，会根据&amp;lt;操作符比较元素大小并判断元素是否相同，并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照&amp;lt;操作符的顺序来逐个遍历。&lt;/p&gt;
&lt;p&gt;而无序容器中的元素是不进行排序的，内部通过Hash表实现，插入和搜索元素的平均复杂度为O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。&lt;/p&gt;
&lt;p&gt;c++11引入了两组无序容器：std::unordered_map / std::unordered_multimap和std::unordered_set / std::unordered_multiset。&lt;br/&gt;它们的用法和原有的std::map / std::multimap / std::set / std::multiset基本类似。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;unordered_map&amp;gt;
#include &amp;lt;map&amp;gt;

using namespace std;

int main(){
    unordered_map&amp;lt;int, string&amp;gt; u = {
        {1, &quot;1&quot;},
        {3, &quot;3&quot;},
        {2, &quot;2&quot;}
    };

    map&amp;lt;int, string&amp;gt; v = {
        {1, &quot;1&quot;},
        {3, &quot;3&quot;},
        {2, &quot;2&quot;}  
    };

    cout &amp;lt;&amp;lt; &quot;std::unordered_map&quot; &amp;lt;&amp;lt; endl;
    for(const auto &amp;amp;n : u){
        cout &amp;lt;&amp;lt; &quot;Key:[&quot; &amp;lt;&amp;lt; n.first &amp;lt;&amp;lt; &quot;] Value:[&quot; &amp;lt;&amp;lt; n.second &amp;lt;&amp;lt; &quot;]\n&quot;;
    }

    cout &amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; &quot;std::map&quot; &amp;lt;&amp;lt; endl;
    for (const auto &amp;amp; n : v){
        cout &amp;lt;&amp;lt; &quot;Key:[&quot; &amp;lt;&amp;lt; n.first &amp;lt;&amp;lt; &quot;] Value:[&quot; &amp;lt;&amp;lt; n.second &amp;lt;&amp;lt; &quot;]\n&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、元组&quot;&gt;3、元组&lt;/h2&gt;
&lt;p&gt;传统c++中的容器，除了std::pair外，似乎没有现成的结构能够用来存放不同类型的数据。但std::pair的缺陷是显而易见的，只能保存两个元素。&lt;/p&gt;
&lt;h3 id=&quot;元组基本操作&quot;&gt;元组基本操作&lt;/h3&gt;
&lt;p&gt;三个核心函数:&lt;br/&gt;1、std::make_tuple: 构造元组&lt;br/&gt;2、std::get：获得元组某个位置的值&lt;br/&gt;3、std::tie：元组拆包&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;tuple&amp;gt;

using namespace std;

auto get_student(int id){
    switch (id)
    {
    case 0:
        return make_tuple(3.8, 'A', &quot;张三&quot;);
        break;
    case 1:
        return make_tuple(2.9, 'C', &quot;李四&quot;);
        break;
    case 2:
        return make_tuple(1.7, 'D', &quot;王五&quot;);
        break;
    default:
        return make_tuple(0.0, 'D', &quot;null&quot;);
        break;
    }
}

int main(){
    auto student = get_student(0);
    std::cout &amp;lt;&amp;lt; &quot;ID: 0, &quot;
    &amp;lt;&amp;lt; &quot;GPA: &quot; &amp;lt;&amp;lt; get&amp;lt;0&amp;gt;(student) &amp;lt;&amp;lt; &quot;, &quot;
    &amp;lt;&amp;lt; &quot;成绩：&quot; &amp;lt;&amp;lt; get&amp;lt;1&amp;gt;(student) &amp;lt;&amp;lt; &quot;, &quot;
    &amp;lt;&amp;lt; &quot;姓名：&quot; &amp;lt;&amp;lt; get&amp;lt;2&amp;gt;(student) &amp;lt;&amp;lt; &quot;\n&quot;;

    double gpa;
    char grade;
    string name;

    //元祖进行拆包
    tie(gpa, grade, name) = get_student(1);
    std::cout &amp;lt;&amp;lt; &quot;ID: 1, &quot;
    &amp;lt;&amp;lt; &quot;GPA: &quot; &amp;lt;&amp;lt; gpa &amp;lt;&amp;lt; &quot;, &quot;
    &amp;lt;&amp;lt; &quot;成绩：&quot; &amp;lt;&amp;lt; grade &amp;lt;&amp;lt; &quot;, &quot;
    &amp;lt;&amp;lt; &quot;姓名：&quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &quot;\n&quot;;

    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;std::get除了使用常量获取元组对象外，c++14增加了使用类型来获取元组中的对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;std::tuple&amp;lt;std::string, double, double, int&amp;gt; t(&quot;123&quot;, 4.5, 6.7, 8);
std::cout &amp;lt;&amp;lt; std::get&amp;lt;std::string&amp;gt;(t) &amp;lt;&amp;lt; std::endl;
std::cout &amp;lt;&amp;lt; std::get&amp;lt;double&amp;gt;(t) &amp;lt;&amp;lt; std::endl; //非法，引发编译期错误
std::cout &amp;lt;&amp;lt; std::get&amp;lt;int&amp;gt;(t) &amp;lt;&amp;lt; std::endl;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行期索引&quot;&gt;运行期索引&lt;/h3&gt;
&lt;p&gt;std::get&amp;lt;&amp;gt;依赖一个编译期的常量，所以下面的方式是不合法的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;int index = 1;
std::get&amp;lt;index&amp;gt;(t); //非法
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;c++17引入了std::variant&amp;lt;&amp;gt;，提供给variant&amp;lt;&amp;gt;的类型模版参数 可以让一个variant&amp;lt;&amp;gt;从而容纳提供的几种类型的变量（在其他语言，例如Python/JavaScrpit等，表现为动态类型）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;variant&amp;gt;

template &amp;lt;size_t n, typename... T&amp;gt;
constexpr std::variant&amp;lt;T...&amp;gt; _tuple_index(const std::tuple&amp;lt;T...&amp;gt;&amp;amp; tpl, size_t i){
    if constexpr(n &amp;gt;= sizeof...(T))
        throw std::out_of_range(&quot;越界.&quot;);
    if(i == n)
        return std::variant&amp;lt;T...&amp;gt;{
            std::in_place_index&amp;lt;n&amp;gt;, std::get&amp;lt;n&amp;gt;(tpl)
        };
    
    return _tuple_index&amp;lt;(n &amp;lt; sizeof...(T)-1 ? n+1 : 0)&amp;gt;(tpl, i);
}
template &amp;lt;typename... T&amp;gt;
constexpr std::variant&amp;lt;T...&amp;gt; tuple_index(const std::tuple&amp;lt;T...&amp;gt;&amp;amp; tpl, size_t i){
    return _tuple_index&amp;lt;0&amp;gt;(tpl, i);
}
template &amp;lt;typename T0, typename ... TS&amp;gt;
std::ostream &amp;amp; operator&amp;lt;&amp;lt; (std::ostream &amp;amp; s, std::variant&amp;lt;T0, TS...&amp;gt; const &amp;amp; v){
    std::visit([&amp;amp;](auto &amp;amp;&amp;amp; x){s&amp;lt;&amp;lt;x;}, v);
    return s;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就能：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;int i = 1;
std::cout &amp;lt;&amp;lt; tuple_index(student, i) &amp;lt;&amp;lt; endl;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;元组合并与遍历&quot;&gt;元组合并与遍历&lt;/h3&gt;
&lt;p&gt;还有一个常见的需求就是合并两个元组，这可以通过std::tuple_cat来实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;auto new_tuple = std::tuple_cat(get_student(1), std::move(t));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要遍历首先我们需要知道一个元组的长度，可以：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;template &amp;lt;typename T&amp;gt;
auto tuple_len(T &amp;amp;tpl){
    return std::tuple_size&amp;lt;T&amp;gt;::value;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就能够对元组进行迭代了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//迭代
for（int i = 0; i != tuple_len(new_tuple); ++i){
     //运行期索引
    std::cout &amp;lt;&amp;lt; tuple_index&amp;lt;i, new_tuple) &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;std::tuple虽然有效，但是标准库提供的功能有限，没办法满足运行期索引和迭代的需求，好在我们还有其他办法可以自行实现。&lt;/p&gt;
</description>
<pubDate>Sat, 19 Sep 2020 14:32:00 +0000</pubDate>
<dc:creator>Ryan669</dc:creator>
<og:description>1、线性容器 stdarray与stdvector不同的是，array对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用std::array容器。 由于std::vector是自动扩容的，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/coding-space/p/13697991.html</dc:identifier>
</item>
<item>
<title>使用Jasmine和karma对传统js进行单元测试 - 叶伟民</title>
<link>http://www.cnblogs.com/adalovelacer/p/enable-unit-test-at-legcy-javascript-code.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adalovelacer/p/enable-unit-test-at-legcy-javascript-code.html</guid>
<description>[unable to retrieve full-text content]当你拿到十五年前的一堆javascript的代码，你如何对这堆javascript代码写单元测试呢？</description>
<pubDate>Sat, 19 Sep 2020 14:25:00 +0000</pubDate>
<dc:creator>叶伟民</dc:creator>
<dc:identifier>https://www.cnblogs.com/adalovelacer/p/enable-unit-test-at-legcy-javascript-code.html</dc:identifier>
</item>
</channel>
</rss>