<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java集合概述（上） - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/12153635.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/12153635.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;先说说，为什么要写这么一篇博客（我总是喜欢写原因）。因为最近到年底了，正好又要准备面试，所以在做各方面的技术总结。而Java集合是Java非常重要的一部分，自己前前后后也花了不少时间学习，但是一直比较零散。所以，打算趁着这个机会，来写一个总结。&lt;/p&gt;
&lt;p&gt;由于能力有限，这方面没有足够积累，如果有什么问题，还请指出。谢谢。&lt;/p&gt;
&lt;p&gt;集合分类，主要分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Collection（继承Iterable接口）：按照单个元素存储的集合
&lt;ul&gt;&lt;li&gt;List：一种线性数据结构的主要体现。有序，可重复&lt;/li&gt;
&lt;li&gt;Set：一种不允许出现重复元素的集合。无序（插入顺序与输出顺序不一致），不可重复&lt;/li&gt;
&lt;li&gt;Queue：一种先进先出（FIFO）的数据结构。有序，可重复，先进先出&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Map（无继承接口）：按照K-V存储的Map
&lt;ul&gt;&lt;li&gt;keySet：可以查看所有的Key。底层实现各不相同。ConcurrentHashMap则是采用的自定义实现的KeySetView内部静态类（实现了Set接口），而HashMap这样的AbstractMap子类，则是是Set接口&lt;/li&gt;
&lt;li&gt;values：同上，ConcurrentHashMap采用ValueSetView，HashMap采用Set接口&lt;/li&gt;
&lt;li&gt;entrySet：同上，ConcurrentHashMap采用EntrySetView，HashMap采用Set接口&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;原本Map是打算按照 AbstractMap；SortedMap；ConcurrentMap；来分类，但是发现这个分类属于理论价值，大于使用价值，也可能是我现在层次不够吧。最后还是学着孤尽大佬在《码处高效》中那样，通过三个视图，来观察Map。具体后面阐述，我也只是阐述其中部分的Map。&lt;/p&gt;
&lt;p&gt;论述方面，我主要会从数据组织方式（底层数据存储方式），数据处理方式（如HashMap的put操作等），特点小结结三个方面进行阐述。但是由于内容量的问题，这里并不会非常细致地阐述代码实现。&lt;/p&gt;
&lt;p&gt;最后，由于内容量的缘故，这部分内容，我将分为两个部分。这篇博客主要论述List与Map，而Set与Queue放在另外一篇博客。&lt;/p&gt;
&lt;h2 id=&quot;一list&quot;&gt;一，List&lt;/h2&gt;
&lt;h3 id=&quot;arraylist&quot;&gt;ArrayList&lt;/h3&gt;
&lt;h4 id=&quot;数据组织方式&quot;&gt;数据组织方式&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    transient Object[] elementData; // non-private to simplify nested class access
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ArrayList的底层是一个Object类型的数组。那么ArrayList就有着和数组一样的特点：随机查询快，但数据的插入，删除慢（因为很可能需要移动其他元素）。&lt;/p&gt;
&lt;h4 id=&quot;数据处理方式&quot;&gt;数据处理方式&lt;/h4&gt;
&lt;h5 id=&quot;add&quot;&gt;add&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    public void add(int index, E element) {
        // 校验index是否在0-size范围内，如果不是，抛出异常IndexOutOfBoundsException
        rangeCheckForAdd(index);

        // 这个操作后面有多个操作，总结一下，就是校验，判断是否需要扩容，扩容。
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        // 通过System.arraycopy操作，为新添加的元素element，在elementData数组的对应index位置，腾出空间
        System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
        // 紧跟着上面的操作elementData数组的index位置，赋值为element
        elementData[index] = element;
        // 数组元素数量+1
        size++;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;grow&quot;&gt;grow&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    // 简单来说， 就是根据所给的minCapacity，计算对应容量（2的幂次方），然后校验容量，最后扩容
    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);
        if (newCapacity - minCapacity &amp;lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;根据其数据组织方式，与数据处理方式，可以明确：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ArrayList随机查询快（直接通过index定位数据中具体元素）&lt;/li&gt;
&lt;li&gt;ArrayList插入与删除操作慢（涉及数组元素移动操作System.arraycopy，还可能涉及扩容操作）&lt;/li&gt;
&lt;li&gt;ArrayList是容量可变的（自带扩容操作，初始化，默认为DEFAULT_CAPACITY=10）&lt;/li&gt;
&lt;li&gt;ArrayList是非线程安全的（没有线程安全措施）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;补充：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ArrayList的默认容量为10（即无参构造时）&lt;/li&gt;
&lt;li&gt;出于性能考虑，避免多次扩容，最好在初始化时设置对应size（即使后面不够了，它也可以自动扩容）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linkedlist&quot;&gt;LinkedList&lt;/h3&gt;
&lt;h4 id=&quot;数据组织方式-1&quot;&gt;数据组织方式&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    private static class Node&amp;lt;E&amp;gt; {
        E item;
        Node&amp;lt;E&amp;gt; next;
        Node&amp;lt;E&amp;gt; prev;

        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;LinkedList的底层是自定义的Node双向链表。那么LinkedList就有着和链表一样的特点：数据的插入与删除快，但是随机访问慢。&lt;/p&gt;
&lt;h4 id=&quot;数据处理方式-1&quot;&gt;数据处理方式&lt;/h4&gt;
&lt;h5 id=&quot;add-1&quot;&gt;add&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    public void add(int index, E element) {
        // 数据校验，index是否超出0-size范围
        checkPositionIndex(index);

        if (index == size)
            // 如果插入的元素是放在最后一个，那就执行尾插入操作（因为LinkedList是有保存first与last两个Node的，所以可以直接操作）
            linkLast(element);
        else
            // 首先通过node(index)方法，获取到当前index位置的Node元素（内部实现，依旧是遍历。不过会根据index与列表中值的比较结果，判断是从first开始遍历，还是从last开始遍历），再通过linkBefore方法，进行插入操作
            linkBefore(element, node(index));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;peek&quot;&gt;peek&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    
    // LinkedList实现了Deque接口，所以需要实现其中的peek方法。获取当前数组的第一个元素，但不进行删除操作
    public E peek() {
        final Node&amp;lt;E&amp;gt; f = first;
        return (f == null) ? null : f.item;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;小结-1&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;根据其数据组织方式，与数据处理方式，可以明确：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;LinkedList随机查询慢（需要进行遍历查询，虽然通过列表中值，降低了一半的遍历范围，但其数据组织方式决定了它的速度慢）：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;测试表明，10W条数据，LinkedList的随即提取速度与ArrayList相比，存在数百倍的差距（引自《码出高效》）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;LinkedList插入与删除操作快（依旧需要靠遍历来定位目标元素，但只需要修改链表节点的前后节点引用）&lt;/li&gt;
&lt;li&gt;LinkedList是容量可变的（链表可以随意链接）&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;LinkedList是非线程安全的（没有线程安全措施）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;补充：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过链表，可以有效地将零散的内存单元通过引用的方式串联起来，形成按链路顺序查找的线性结构，内存利用率较高（引用自《码出高效》）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;vector&quot;&gt;Vector&lt;/h3&gt;
&lt;p&gt;Vector本质与ArrayList没太大区别，底层同样是Object数组，默认大小依旧为10（不过Vector采用的是不推荐的魔法数字）。&lt;/p&gt;
&lt;p&gt;唯一的区别，就是Vector在关键方法上添加了Sychronized关键字，来确保线程安全。&lt;/p&gt;
&lt;p&gt;但是，由于处理得较为粗糙，以及其特点，所以性能很差，基本已经被抛弃。&lt;/p&gt;
&lt;p&gt;这里就不再赘述了。&lt;/p&gt;
&lt;h3 id=&quot;copyonwritearraylist&quot;&gt;CopyOnWriteArrayList&lt;/h3&gt;
&lt;p&gt;CopyOnWriteArrayList，作为COW容器的一员，其思想就是空间换时间，主要针对读多写少的场景。当有元素写入时，会新建一个数组，将原有数组的元素复制过来，然后进行写操作（此时数组的读操作，还是针对原数组）。在写操作完成后，会将读操作针对的数组引用，从原数组指向新数组。这样就可以在写操作进行时，不影响读操作的进行。&lt;/p&gt;
&lt;h4 id=&quot;数据组织方式-2&quot;&gt;数据组织方式&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    /** The array, accessed only via getArray/setArray. */
    // 一方面通过transient避免序列化，另一方面通过volatile确保可见性，从而确保单个属性（这里是引用变量）的线程安全
    private transient volatile Object[] array;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数据处理方式-2&quot;&gt;数据处理方式&lt;/h4&gt;
&lt;h5 id=&quot;add-2&quot;&gt;add&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    public void add(int index, E element) {
        final ReentrantLock lock = this.lock;
        // 进行加锁，同时只能有一个写操作
        // 另外，加锁操作放在try块外，一方面是try规范（lock操作并不会发生异常，并且可以减少try块大小），另一方面是避免加锁失败，finally的释放锁出现IllegalMonitorStateException异常
        lock.lock();
        try {
            // 获取原有数组，并赋值给elements（引用变量）
            Object[] elements = getArray();
            int len = elements.length;
            // 数据校验
            if (index &amp;gt; len || index &amp;lt; 0)
                throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+
                                                    &quot;, Size: &quot;+len);
            // 下面的操作，就是对原有数组进行复制，并赋值给newElements（并且留出index位置）
            Object[] newElements;
            int numMoved = len - index;
            if (numMoved == 0)
                newElements = Arrays.copyOf(elements, len + 1);
            else {
                newElements = new Object[len + 1];
                System.arraycopy(elements, 0, newElements, 0, index);
                System.arraycopy(elements, index, newElements, index + 1,
                                 numMoved);
            }
            // 设置新数组index位置的值为element，完成赋值操作
            newElements[index] = element;
            // 将数组引用（读操作正在读的数组引用）改为newElements
            setArray(newElements);
        } finally {
            // 无论是否异常，都需要释放锁，
            lock.unlock();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最大的特色，就是这部分了。至于remove操作，都是类似的。故不再赘述。&lt;/p&gt;
&lt;h4 id=&quot;小结-2&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;由于CopyOnWriteArrayList的数据组织方式与ArrayList一致，也是采用的数组，故：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CopyOnWriteArrayList随机查询快&lt;/li&gt;
&lt;li&gt;CopyOnWriteArrayList插入与读写慢&lt;/li&gt;
&lt;li&gt;CopyOnWriteArrayList是容量可变的（每次进行增删的写操作，都会新建一个数组，进而进行替换）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;补充：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CopyOnWriteArrayList是线程安全的（读写操作隔离，写操作通过ReentrantLock确保线程安全）&lt;/li&gt;
&lt;li&gt;CopyOnWriteArrayList的写操作不直接影响读操作（两者在内存上针对的不是同一个数组）&lt;/li&gt;
&lt;li&gt;CopyOnWriteArrayList只适用于读多写少场景（毕竟写操作是需要复制数组）&lt;/li&gt;
&lt;li&gt;CopyOnWriteArrayList占据双倍内存（因为写操作的时候需要复制数组）&lt;/li&gt;
&lt;li&gt;CopyOnWriteArrayList的性能会随着写入频次与数组大小上升，而快速下降（写入频次m x 数组大小n）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;推荐：高并发请求下，可以攒一下要进行的写操作（如添加，或删除，可以分开保存），然后进行addAll或removeAll操作。这样可以有效减低资源消耗。但是这个攒的度需要好好把握，就和请求合并一样，需要好好权衡。&lt;/p&gt;
&lt;h2 id=&quot;二map&quot;&gt;二，Map&lt;/h2&gt;
&lt;h3 id=&quot;treemap&quot;&gt;TreeMap&lt;/h3&gt;
&lt;h4 id=&quot;数据组织方式-3&quot;&gt;数据组织方式&lt;/h4&gt;
&lt;h4 id=&quot;数据处理方式-3&quot;&gt;数据处理方式&lt;/h4&gt;
&lt;h4 id=&quot;小结-3&quot;&gt;小结&lt;/h4&gt;
&lt;h3 id=&quot;hashmap&quot;&gt;HashMap&lt;/h3&gt;
&lt;p&gt;HashMap一方面是工作中用的非常多的集合，另一方面是面试的高频（我每次面试几乎都会被人问这个）。&lt;/p&gt;
&lt;p&gt;而HashMap，与ConcurrentHashMap一样，都存在Jdk8之前与Jdk8之后的区别。不过，我应该会以Jdk8之后为重点，毕竟现在SpringBoot2.x都要求Jdk8了。&lt;/p&gt;
&lt;h4 id=&quot;数据组织方式-4&quot;&gt;数据组织方式&lt;/h4&gt;
&lt;h5 id=&quot;jdk8之前&quot;&gt;Jdk8之前&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    // jdk8之前，其底层是数组+链表
    // 链表底层Entry是Map的内部接口
    transient Entry&amp;lt;K, V&amp;gt;[] table;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;jdk8之后&quot;&gt;Jdk8之后&lt;/h6&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    transient Node&amp;lt;K, V&amp;gt;[] table;


    static class Node&amp;lt;K, V&amp;gt; implements Map.Entry&amp;lt;K, V&amp;gt; {
        final int hash;
        final K key;
        V value;
        Node&amp;lt;K, V&amp;gt; next;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数据处理方式-4&quot;&gt;数据处理方式&lt;/h4&gt;
&lt;h5 id=&quot;jdk8之前的put方法注释并不多因为我没有源码我是按照笔记图片手撸的这段&quot;&gt;Jdk8之前的put方法（注释并不多，因为我没有源码，我是按照笔记图片，手撸的这段）&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    public V put (K key, V value) {
        // HashMap采用延迟创建。判断当前table是否为空。如果为空，就根据默认值15，创建一个数组，并赋值给table
        if (table == EMPTY_TABLE) {
            inflateTable(threshold);
        }
        // 数据校验
        if ( key == null) 
            return putForNullKey(value);
        // 根据key，计算哈希值
        int hash = hash(key);
        // 通过indexFor（内部貌似采用位运算），根据key的哈希值与数组长度，计算该K-V键值对在数组中的下标i
        int i = indexFor(hash, table.length);
        for (Entry&amp;lt;K, V&amp;gt; e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash = hash &amp;amp;&amp;amp; ((k = e.key) || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

            // 记录修改次数+1，类似版本号
        modCount++;
        addEntry(hash, key, value, i);
        return null;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;jdk8之后的put方法&quot;&gt;Jdk8之后的put方法&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }


    // 计算key的哈希值（数据校验，key的哈希值，即其hashCode）
    static final int hash(Object key) {
        int h;
        // 通过其hashCode的高16位与其低16位的异或运算，既降低系统性能开销，又避免高位不参加下标运算造成的碰撞
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
    }


    // 执行主要put操作
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
        // 从下面这个代码块，可以看出Java8后的HashMap等，代码晦涩不少
        if ((tab = table) == null || (n = tab.length) == 0)
            // 如果table为null，或table.length为0（其中混杂了赋值语句），就进行进行初始化操作（通过resize()操作，这点与Spring的refresh()应用是一致的），并将其长度赋值给n（注意这里，都赋值给了局部变量，而非全局变量）
            n = (tab = resize()).length;
        // 根据key的hash值，计算其下标，并判断数组中对应下标位置是否为null
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
            // 如果对应位置为null，直接通过newNode方法（生成Node），设置数组对应i位置为对应新Node
            tab[i] = newNode(hash, key, value, null);
        else {
            // 如果对应位置不为null，那就需要进行链表操作，进而判断是否树化（红黑树），是否扩容等
            Node&amp;lt;K,V&amp;gt; e; K k;
            // 通过hash与equals等，判断新添加值的key与已存在值的key是否真正相等
            // 这里扩展两点：第一，判断对象是否相等，必须hashcode与equals都判断相等。前者避免两个对象只是值，但不是同一个对象（两位都是p9大佬，不代表两位就是同一个人）。后者避免哈希碰撞问题（即使是两个不同的对象的内存地址，也可能哈希值相等）
            // 第二，我看到这里的时候，比较担心，会不会出现value相等，但是hashCode不同，导致这里判断为false。然后我发现包装类型，早就重写了hashCode方法，如Integer的hashCode就直接返回value
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                // 如果相等，就直接更新对应Node即可
                e = p;
            // 如果上面判断失败，则判断原有的数组元素，是不是已经树化（不再是Node类型，而是TreeNode，当然TreeNode依旧是由Node构成的）
            else if (p instanceof TreeNode)
                // 如果原有数组元素已经树化，那么就进行调用putTreeVal方法，将当前元素，置入目标红黑树中（其中涉及红黑树的旋转等操作）
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            // 如果不是空，也不是相同元素，更不是红黑树，那说明那已经是一个链表（已经由多个元素），或即将成为链表（已经有一个元素，并即将添加一个新的元素）
            else {
                // 遍历对应链表元素，并通过binCount记录链表已存在的元素数
                for (int binCount = 0; ; ++binCount) {
                    // 如果e=p.next()为null，说明达到了链表的最后（e的前一个值为当前链表的最后一个元素）
                    if ((e = p.next) == null) {
                        // 通过newNode获得对应p的Node，并将其设置为链表的最后一个元素
                        p.next = newNode(hash, key, value, null);
                        // 通过binCount，判断链表的长度是否达到了树化的阈值
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            // 达到阈值，则通过当前table数组与hash值，以及treefyBin方法，将当前数组位置的链表树化
                            treeifyBin(tab, hash);
                        break;
                    }
                    // 在遍历过程中，找到了相同的元素，即跳过（因为内容相同）
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    // 该赋值操作，属于链表的操作，从而继续链表遍历
                    p = e;
                }
            }
            // 下面这段代码，就涉及到HashMap的putIfAbsent（也是调用putVal，只是第四个参数onlyIfAbsent不同）
            // 简单来说，就是遇到key相同的元素，怎么处理。put操作是直接赋值，而putIfAbsent则是判断对应key的value是否为null，如果是null，才会赋值。否则就不变（类似Redis）
            // 只不过，这个过程通过新增的第四个参数控制，从而确保同一套代码（putVal方法），实现两种不同功能（put与putIfAbsent）
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        // 版本号
        ++modCount;
        // 一方面size前缀自增，另一方面，判断自增后的size是否超过阈值（默认16*0.75=12，数组容量*负载因子）
        if (++size &amp;gt; threshold)
            // 扩容（扩容2倍后，重排）
            resize();
        // 空方法，为子类保留的，如LinkedHashMap
        afterNodeInsertion(evict);
        return null;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法可以算是HashMap的核心，毕竟通过这个方法，也算是摸到了HashMap的运行机制了。&lt;/p&gt;
&lt;p&gt;流程简述：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果HashMap的底层数组没有初始化，则通过resize()方法进行构建&lt;/li&gt;
&lt;li&gt;对key计算hash值，然后再计算下标&lt;/li&gt;
&lt;li&gt;如果数组对应下标位置为null（这里我认为不该用哈希碰撞），则直接放入对应位置&lt;/li&gt;
&lt;li&gt;如果数组对应下标位置为TreeNode（即对应位置已经树化），则通过putTreeVal方法，将对应Node置入树中&lt;/li&gt;
&lt;li&gt;否则遍历数组对应下标位置的链表，将对应Node置入&lt;/li&gt;
&lt;li&gt;如果链表的长度超过阈值，则进行树化操作&lt;/li&gt;
&lt;li&gt;如果节点存在旧值，直接替换&lt;/li&gt;
&lt;li&gt;如果数组的元素数量超过阈值（数组容量*负载因子），则进行扩容（扩容2倍，重排）&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;jdk8之后的get方法&quot;&gt;Jdk8之后的get方法&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    public V get(Object key) {
        Node&amp;lt;K,V&amp;gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }


    // 这里我觉得没什么说的。根据不同情况，分别从数组，红黑树，数组来获取目标元素
    final Node&amp;lt;K,V&amp;gt; getNode(int hash, Object key) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; first, e; int n; K k;
        if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
            (first = tab[(n - 1) &amp;amp; hash]) != null) {
            if (first.hash == hash &amp;amp;&amp;amp; // always check first node
                ((k = first.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                return first;
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode&amp;lt;K,V&amp;gt;)first).getTreeNode(hash, key);
                do {
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;小结-4&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;就使用场景而言，《码出高效》给出这样一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;除局部方法或绝对线程安全的情形外，优先推荐ConcurrentHashMap。两者虽然性能相差无几，但后者解决了高并发下的线程安全问题。HashMap的死链问题及扩容数据丢失问题是慎用HashMap的两个主要原因。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里，我忍不住站在Java工程师的角度，推荐《码出高效》以及配套的《阿里Java开发手册》。作为一名也算看过不少技术书籍的开发者，这两本书在我这儿，也算得上是优秀书籍了。&lt;/p&gt;
&lt;p&gt;不过，文中也提到，这种情形，在Jdk8之后有所修复，改善。具体的，可以看看书籍（主要内容有点多）。&lt;/p&gt;
&lt;h3 id=&quot;concurrenthashmap&quot;&gt;ConcurrentHashMap&lt;/h3&gt;
&lt;p&gt;ConcurrentHashMap部分，我将只描述Jdk8之后的版本。&lt;/p&gt;
&lt;p&gt;而Jdk8之前的版本，其实底层就是类似HashTable的Segament组成的数组。通过分段锁，达成线程安全。算是HashTable与HashMap的折中方案。复杂度并不是很高，不过Jdk8之后的版本，就较为复杂。首先，引入红黑树，优化存储结构。其次，取消原有的分段锁设计，采用了更高效的线程安全设计方案（利用了无锁操作CAS与头节点同步锁等）。最后，使用了更优化的方式统计集合内的元素数量（引用自《码出高效》，我还真没注意到这点）。&lt;/p&gt;
&lt;h4 id=&quot;数据组织方式-5&quot;&gt;数据组织方式&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    transient volatile Node&amp;lt;K,V&amp;gt;[] table;


    static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
        final int hash;
        final K key;
        volatile V val;
        volatile Node&amp;lt;K,V&amp;gt; next;

        Node(int hash, K key, V val, Node&amp;lt;K,V&amp;gt; next) {
            this.hash = hash;
            this.key = key;
            this.val = val;
            this.next = next;
        }

        // 此处省略其内部方法，感兴趣的，可以自行查看
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述来看，ConcurrentHashMap的底层数据组织为数组+链表。依据Jdk8后的HashMap，可以推测，在对应条件下，链表会转为红黑树结构。事实也是如此，请看下代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    static final class TreeNode&amp;lt;K,V&amp;gt; extends Node&amp;lt;K,V&amp;gt; {
        TreeNode&amp;lt;K,V&amp;gt; parent;  // red-black tree links
        TreeNode&amp;lt;K,V&amp;gt; left;
        TreeNode&amp;lt;K,V&amp;gt; right;
        TreeNode&amp;lt;K,V&amp;gt; prev;    // needed to unlink next upon deletion
        boolean red;

        TreeNode(int hash, K key, V val, Node&amp;lt;K,V&amp;gt; next,
                 TreeNode&amp;lt;K,V&amp;gt; parent) {
            super(hash, key, val, next);
            this.parent = parent;
        }

        // 此处省略其内部方法，感兴趣的，可以自行查看
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ConcurrentHashMap，与HashMap一样，其内部也有专门为红黑树服务的TreeNode。&lt;/p&gt;
&lt;p&gt;所以，从数据组织方面来看，其实ConcurrentHashMap与同版本的HashMap，可以说就是一个模子刻出来的（毕竟都是Doug Lea带着撸的）。&lt;/p&gt;
&lt;p&gt;两者的区别，或者说ConcurrentHashMap的精妙之处，就在于ConcurrentHashMap对多线程的考虑与处理。&lt;/p&gt;
&lt;p&gt;其中的细节挺多的，我只阐述我对其中一些大头的理解（因为很多细节，我也不知道，也是看了大佬的总结，才发现）。&lt;/p&gt;
&lt;h4 id=&quot;数据处理方式-5&quot;&gt;数据处理方式&lt;/h4&gt;
&lt;h5 id=&quot;put&quot;&gt;put&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    public V put(K key, V value) {
        return putVal(key, value, false);
    }

    /** Implementation for put and putIfAbsent */
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        // 数据校验，如果key或value为Null，直接NPE
        if (key == null || value == null) throw new NullPointerException();
        // 通过spread方法，计算hash值（本质还是与HashMap一样，针对hashCode进行高低16位异或计算等）
        int hash = spread(key.hashCode());
        // 记录链表长度
        int binCount = 0;
        // 这里的循环操作是为了之后的CAS操作（就是CAS的自旋操作）
        for (Node&amp;lt;K,V&amp;gt;[] tab = table;;) {
            Node&amp;lt;K,V&amp;gt; f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                // 同HashMap一样，如果数组为空或长度为0，则进行数组初始化操作（循环头中已经完成赋值操作）
                tab = initTable();
            else if ((f = tabAt(tab, i = (n - 1) &amp;amp; hash)) == null) {
                // 如果数组对应位置为null，则通过CAS操作，进行值的插入操作
                if (casTabAt(tab, i, null,
                             new Node&amp;lt;K,V&amp;gt;(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            // 如果对应节点的Node.hash值为MOVED=-1
            else if ((fh = f.hash) == MOVED)
                // 进行resize协助操作（具体协助方式，还没研究）
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        // 如果数组对应位置（即首节点）的哈希值大于等于零（树化后等情况下，对应位置哈希值小于零）
                        //  static final int MOVED     = -1; // hash for forwarding nodes
                        //  static final int TREEBIN   = -2; // hash for roots of trees
                        //  static final int RESERVED  = -3; // hash for transient reservations
                        if (fh &amp;gt;= 0) {
                            // 说明此情况下，数组对应位置，存储的是链表。进行链表插入，遍历操作（具体参照HashMap的put操作）
                            binCount = 1;
                            for (Node&amp;lt;K,V&amp;gt; e = f;; ++binCount) {
                                K ek;
                                if (e.hash == hash &amp;amp;&amp;amp;
                                    ((ek = e.key) == key ||
                                     (ek != null &amp;amp;&amp;amp; key.equals(ek)))) {
                                    oldVal = e.val;
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                Node&amp;lt;K,V&amp;gt; pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node&amp;lt;K,V&amp;gt;(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        // 如果数组对应位置的元素，是树化节点（即为TreeBin实例）
                        else if (f instanceof TreeBin) {
                            Node&amp;lt;K,V&amp;gt; p;
                            binCount = 2;
                            // 调用putTreeVal方法，进行红黑树的值插入操作
                            if ((p = ((TreeBin&amp;lt;K,V&amp;gt;)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                // 判断onlylfAbsent参数，进行val设置。具体参照HashMap的put方法的对应位置解释
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                // 前面的各类操作，都会计算binCount（数组当前位置存储的节点数）
                if (binCount != 0) {
                    // 如果对应节点数超过了树化阈值TREEIFY_THRESHOLD=8
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD)
                        // 对数组当前位置，进行树化操作
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
            // 计数
        addCount(1L, binCount);
        return null;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;小结-5&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;ConcurrentHashMap的魅力在于其线程安全的实现，有机会好好研究研究，专门写一个相关的博客。&lt;/p&gt;
&lt;h2 id=&quot;三总结&quot;&gt;三，总结&lt;/h2&gt;
&lt;p&gt;其实，Java集合主要从两个维度分析。一个是底层数据组织方式，如链表与数组（基本就这两种，或者如HashMap那样组合两种）。另一个是线程安全方式，就是线程安全与非线程安全。&lt;/p&gt;
&lt;p&gt;最后就是由于一些底层数据组织方式的调整，带来的循环，有序等特性。&lt;/p&gt;
</description>
<pubDate>Fri, 10 Jan 2020 00:48:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<og:description>Java集合概述（上） 前言 先说说，为什么要写这么一篇博客（我总是喜欢写原因）。因为最近到年底了，正好又要准备面试，所以在做各方面的技术总结。而Java集合是Java非常重要的一部分，自己前前后后也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tiancheng-Duan/p/12153635.html</dc:identifier>
</item>
<item>
<title>小白学 Python 爬虫（36）：爬虫框架 Scrapy 入门基础（四） Downloader Middleware - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/12174444.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/12174444.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/202001/908359-20200110084602691-1690376939.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我用 Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/13/3303836941/&quot;&gt;小白学 Python 爬虫（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/20/2586166930/&quot;&gt;小白学 Python 爬虫（2）：前置准备（一）基本类库的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/21/1005563697/&quot;&gt;小白学 Python 爬虫（3）：前置准备（二）Linux基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/22/3679472340/&quot;&gt;小白学 Python 爬虫（4）：前置准备（三）Docker基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/24/334078215/&quot;&gt;小白学 Python 爬虫（5）：前置准备（四）数据库基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/25/1881661601/&quot;&gt;小白学 Python 爬虫（6）：前置准备（五）爬虫框架的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/26/1197821400/&quot;&gt;小白学 Python 爬虫（7）：HTTP 基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/27/101847406/&quot;&gt;小白学 Python 爬虫（8）：网页基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/28/1668465912/&quot;&gt;小白学 Python 爬虫（9）：爬虫基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/01/2475257648/&quot;&gt;小白学 Python 爬虫（10）：Session 和 Cookies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/02/2333822325/&quot;&gt;小白学 Python 爬虫（11）：urllib 基础使用（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/03/819896244/&quot;&gt;小白学 Python 爬虫（12）：urllib 基础使用（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/04/2992515886/&quot;&gt;小白学 Python 爬虫（13）：urllib 基础使用（三）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/05/104488944/&quot;&gt;小白学 Python 爬虫（14）：urllib 基础使用（四）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/07/2788855167/&quot;&gt;小白学 Python 爬虫（15）：urllib 基础使用（五）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/09/1691033431/&quot;&gt;小白学 Python 爬虫（16）：urllib 实战之爬取妹子图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/10/1910005577/&quot;&gt;小白学 Python 爬虫（17）：Requests 基础使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/11/1468953802/&quot;&gt;小白学 Python 爬虫（18）：Requests 进阶操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/12/3568648672/&quot;&gt;小白学 Python 爬虫（19）：Xpath 基操&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/13/2569867940/&quot;&gt;小白学 Python 爬虫（20）：Xpath 进阶&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/15/2789385418/&quot;&gt;小白学 Python 爬虫（21）：解析库 Beautiful Soup（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/16/876770087/&quot;&gt;小白学 Python 爬虫（22）：解析库 Beautiful Soup（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/17/876770088/&quot;&gt;小白学 Python 爬虫（23）：解析库 pyquery 入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/18/1275791678/&quot;&gt;小白学 Python 爬虫（24）：2019 豆瓣电影排行&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/19/1066903974/&quot;&gt;小白学 Python 爬虫（25）：爬取股票信息&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/20/788803015/&quot;&gt;小白学 Python 爬虫（26）：为啥买不起上海二手房你都买不起&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/22/151891020/&quot;&gt;小白学 Python 爬虫（27）：自动化测试框架 Selenium 从入门到放弃（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/24/1100772905/&quot;&gt;小白学 Python 爬虫（28）：自动化测试框架 Selenium 从入门到放弃（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/25/7469407721/&quot;&gt;小白学 Python 爬虫（29）：Selenium 获取某大型电商网站商品信息&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/26/9565104888/&quot;&gt;小白学 Python 爬虫（30）：代理基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/30/8571162753/&quot;&gt;小白学 Python 爬虫（31）：自己构建一个简单的代理池&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/31/5591013128/&quot;&gt;小白学 Python 爬虫（32）：异步请求库 AIOHTTP 基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2020/01/05/4332169375/&quot;&gt;小白学 Python 爬虫（33）：爬虫框架 Scrapy 入门基础（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2020/01/06/5952331367/&quot;&gt;小白学 Python 爬虫（34）：爬虫框架 Scrapy 入门基础（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2020/01/07/5324623576/&quot;&gt;小白学 Python 爬虫（35）：爬虫框架 Scrapy 入门基础（三） Selector 选择器&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;Downloader Middleware 直译过来是下载器中间件，本文后续就叫它下载中间件了。&lt;/p&gt;
&lt;p&gt;下载器中间件主要用于 Scrapy 的 Request 和 Response 处理。&lt;/p&gt;
&lt;p&gt;Downloader Middleware 的功能非常的强大，可以修改 UA 头、处理重定向、设置代理、设置超时时间、失败重试、设置 Cookies 等功能。&lt;/p&gt;
&lt;h2 id=&quot;内置下载器中间件&quot;&gt;内置下载器中间件&lt;/h2&gt;
&lt;p&gt;Scrapy 已经为我们提供相当多的内置的下载器中间件，用于各种功能，列表如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;{
    'scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware': 100,
    'scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware': 300,
    'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware': 350,
    'scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware': 400,
    'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': 500,
    'scrapy.downloadermiddlewares.retry.RetryMiddleware': 550,
    'scrapy.downloadermiddlewares.ajaxcrawl.AjaxCrawlMiddleware': 560,
    'scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware': 580,
    'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware': 590,
    'scrapy.downloadermiddlewares.redirect.RedirectMiddleware': 600,
    'scrapy.downloadermiddlewares.cookies.CookiesMiddleware': 700,
    'scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware': 750,
    'scrapy.downloadermiddlewares.stats.DownloaderStats': 850,
    'scrapy.downloadermiddlewares.httpcache.HttpCacheMiddleware': 900,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些列表定义在 &lt;code&gt;DOWNLOADER_MIDDLEWARES_BASE&lt;/code&gt; 变量中。&lt;/p&gt;
&lt;p&gt;这些列表的数据结构是一个字典格式，后面的值代表了优先级，数字越小代表了越靠近 Scrapy 引擎，数字越大越靠近下载器，数字小的会被优先调用。&lt;/p&gt;
&lt;h2 id=&quot;自定义下载器中间件&quot;&gt;自定义下载器中间件&lt;/h2&gt;
&lt;p&gt;如果要在项目自定义一个下载器中间件，需要我们自己设置 &lt;code&gt;DOWNLOADER_MIDDLEWARES&lt;/code&gt; 这个变量，这个变量位于 settings.py ，默认是注释状态，当我们需要的时候直接打开这个注释就可以了，这里不仅可以自定义我们所需要的下载器中间件，还可以禁用 &lt;code&gt;DOWNLOADER_MIDDLEWARES_BASE&lt;/code&gt; 中定义的下载器中间件。&lt;/p&gt;
&lt;p&gt;每个下载器中间件都是一个Python类，该类定义了以下定义的一个或多个方法。&lt;/p&gt;
&lt;p&gt;核心方法共有 4 个，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;process_request(request, spider)&lt;/li&gt;
&lt;li&gt;process_response(request, response, spider)&lt;/li&gt;
&lt;li&gt;process_exception(request, exception, spider)&lt;/li&gt;
&lt;li&gt;from_crawler(cls, crawler)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而我们至少只需要实现其中的一个方法就可以定义一个下载器中间件。&lt;/p&gt;
&lt;h3 id=&quot;process_requestrequest-spider&quot;&gt;process_request(request, spider)&lt;/h3&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;request（Request对象）–正在处理的请求&lt;/li&gt;
&lt;li&gt;spider（Spider对象）–此请求所针对的蜘蛛&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于通过下载中间件的每个请求，都会调用此方法。&lt;/p&gt;
&lt;p&gt;process_request() 应该是：return None，返回一个 Response 对象，返回一个Request 对象或引发 IgnoreRequest 异常。&lt;/p&gt;
&lt;p&gt;如果返回 None ，则 Scrapy 将继续处理此请求，执行所有其他中间件，直到最终将适当的下载程序处理程序称为执行的请求（并下载了其响应）。&lt;/p&gt;
&lt;p&gt;如果它返回一个 Response 对象， Scrapy 不会打扰调用任何其他 process_request() 或 process_exception() 方法，或相应的下载功能; 它将返回该响应。 process_response() 总是在每个响应上调用已安装中间件的方法。&lt;/p&gt;
&lt;p&gt;如果返回一个 Request 对象， Scrapy 将停止调用 process_request 方法并重新计划返回的请求。一旦执行了新返回的请求，就会在下载的响应上调用适当的中间件链。&lt;/p&gt;
&lt;p&gt;如果引发 IgnoreRequest 异常，则所有的下载器中间件的方法 process_exception() 会依次执行，如果没有一个方法处理该异常，那么 Request 的 errback() 方法就会回调，如果该异常还没处理，那么就会忽略。&lt;/p&gt;
&lt;h3 id=&quot;process_responserequest-response-spider&quot;&gt;process_response(request, response, spider)&lt;/h3&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;request （是一个 Request 对象）–发起响应的请求&lt;/li&gt;
&lt;li&gt;response （response 对象）–正在处理的响应&lt;/li&gt;
&lt;li&gt;spider （spider 对象）–此响应预期用于的蜘蛛&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;process_response() 应该：返回响应对象，返回请求对象或引发 IgnoreRequest 异常。&lt;/p&gt;
&lt;p&gt;如果它返回一个 Response （它可以是相同的给定响应，也可以是全新的响应），那么该响应将继续使用链中下一个中间件的 process_response() 进行处理。&lt;/p&gt;
&lt;p&gt;如果它返回一个 Request 对象，则中间件链将暂停，并将返回的请求重新安排为将来下载。 这与从 process_request() 返回请求的行为相同。&lt;/p&gt;
&lt;p&gt;如果引发 IgnoreRequest 异常，则调用请求的 errback 函数（Request.errback）。 如果没有代码处理引发的异常，则将其忽略并且不记录（与其他异常不同）。&lt;/p&gt;
&lt;h3 id=&quot;process_exceptionrequest-exception-spider&quot;&gt;process_exception(request, exception, spider)&lt;/h3&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;request （是一个Request对象）–生成异常的请求&lt;/li&gt;
&lt;li&gt;exception （Exception对象）–引发的异常&lt;/li&gt;
&lt;li&gt;spider （spider对象）–此请求所针对的蜘蛛&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当下载处理程序或 process_request() （从下载程序中间件中）引发异常（包括 IgnoreRequest 异常）时， Scrapy 会调用 process_exception() 。&lt;/p&gt;
&lt;p&gt;process_exception() 应该返回：无，响应对象或请求对象。&lt;/p&gt;
&lt;p&gt;如果返回 None ，则 Scrapy 将继续处理此异常，执行已安装中间件的任何其他 process_exception() 方法，直到没有中间件为止，并且默认异常处理开始。&lt;/p&gt;
&lt;p&gt;如果返回 Response 对象，则会启动已安装中间件的 process_response() 方法链，并且 Scrapy 不会费心调用中间件的任何其他 process_exception() 方法。&lt;/p&gt;
&lt;p&gt;如果它返回一个 Request 对象，则将返回的请求重新安排为将来下载。 这将停止执行中间件的 process_exception() 方法，就像返回响应一样。&lt;/p&gt;
&lt;h3 id=&quot;from_crawlercls-crawler&quot;&gt;from_crawler(cls, crawler)&lt;/h3&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;crawler（搜寻器对象）–使用此中间件的搜寻器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果存在，则调用该类方法以从 Crawler 创建中间件实例。 它必须返回中间件的新实例。 搜寻器对象提供对所有 Scrapy 核心组件（如设置和信号）的访问； 它是中间件访问它们并将其功能连接到 Scrapy 中的一种方式。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;首先，我们还是在前面的 Scrapy 的项目上新建一个 Spider ，具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding: utf-8 -*-
import scrapy

class HttpbinSpider(scrapy.Spider):
    name = 'httpbin'
    allowed_domains = ['httpbin.org']
    start_urls = ['https://httpbin.org/get']

    def parse(self, response):
        self.logger.debug(response.text)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用如下命令运行一下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;scrapy crawl httpbin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果部分截取如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;args&quot;: {},
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;,
    &quot;Accept-Encoding&quot;: &quot;gzip,deflate,br&quot;,
    &quot;Accept-Language&quot;: &quot;en&quot;,
    &quot;Host&quot;: &quot;httpbin.org&quot;,
    &quot;User-Agent&quot;: &quot;Scrapy/1.8.0 (+https://scrapy.org)&quot;
  },
  &quot;origin&quot;: &quot;183.195.68.215, 183.195.68.215&quot;,
  &quot;url&quot;: &quot;https://httpbin.org/get&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里的 UA 头是 &lt;code&gt;Scrapy/1.8.0 (+https://scrapy.org)&lt;/code&gt; ，这个其实是由 Scrapy 内置的 &lt;code&gt;UserAgentMiddleware&lt;/code&gt; 设置的。&lt;/p&gt;
&lt;p&gt;这里我们通过修改一下 UA 头，当然修改 UA 头可以通过 settings 中的 USER_AGENT 进行设置，这里我们要演示下载器中间件嘛，所以就使用下载器中间件设置一下。&lt;/p&gt;
&lt;p&gt;首先我们在 &lt;code&gt;middlewares.py&lt;/code&gt; 中新增一个 UaDownLoaderMiddleware ，示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class UaDownLoaderMiddleware(object):
    
    def process_request(self, request, spider):

        request.headers['User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新增完成后，还需要在配置文件 settings 中开启这个下载器中间件，找到 &lt;code&gt;DOWNLOADER_MIDDLEWARES&lt;/code&gt; ，将注释去掉，修改为：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;DOWNLOADER_MIDDLEWARES = {
   'first_scrapy.middlewares.UaDownLoaderMiddleware': 543,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，我们的修改就完成了，可以重新运行这只爬虫：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;scrapy crawl httpbin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果部分截取如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;args&quot;: {},
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;,
    &quot;Accept-Encoding&quot;: &quot;gzip,deflate,br&quot;,
    &quot;Accept-Language&quot;: &quot;en&quot;,
    &quot;Host&quot;: &quot;httpbin.org&quot;,
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36&quot;
  },
  &quot;origin&quot;: &quot;183.195.68.215, 183.195.68.215&quot;,
  &quot;url&quot;: &quot;https://httpbin.org/get&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里响应的 UA 已经变成了我们刚才设置的 UA 头，证明我们的修改是成功的。&lt;/p&gt;
&lt;p&gt;本篇就先到这里了，希望各位同学可以自己动手试一下。&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/python-spider/first_scrapy&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/python-learning/tree/master/python-spider/first_scrapy&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.scrapy.org/en/latest/topics/settings.html#std:setting-DOWNLOADER_MIDDLEWARES_BASE&quot; class=&quot;uri&quot;&gt;https://docs.scrapy.org/en/latest/topics/settings.html#std:setting-DOWNLOADER_MIDDLEWARES_BASE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.scrapy.org/en/latest/topics/downloader-middleware.html&quot; class=&quot;uri&quot;&gt;https://docs.scrapy.org/en/latest/topics/downloader-middleware.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 Jan 2020 00:46:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我用 Python 前文传送门： &amp;quot;小白学 Python 爬虫（1）：开篇&amp;quot; &amp;quot;小白学 Python 爬虫（2）：前置准备（一）基本类库的安装&amp;quot; &amp;q</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/12174444.html</dc:identifier>
</item>
<item>
<title>高并发场景下锁的使用技巧 - 张飞洪[厦门]</title>
<link>http://www.cnblogs.com/jackyfei/p/12142840.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackyfei/p/12142840.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如何确保一个方法，或者一块代码在高并发情况下，同一时间只能被一个线程执行，单体应用可以使用并发处理相关的 API 进行控制，但单体应用架构演变为分布式微服务架构后，跨进程的实例部署，显然就没办法通过应用层锁的机制来控制并发了。那么锁都有哪些类型，为什么要使用锁，锁的使用场景有哪些？今天我们来聊一聊高并发场景下锁的使用技巧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　不同的应用场景对锁的要求各不相同，我们先来看下锁都有哪些类别，这些锁之间有什么区别。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java 中的重量级锁 synchronize(悲观锁)&lt;/li&gt;
&lt;li&gt;Java 中的轻量级锁 volatile 和 CAS(乐观锁)&lt;/li&gt;
&lt;li&gt;数据库行锁(悲观锁)&lt;/li&gt;
&lt;li&gt;悲观锁(synchronize)&lt;/li&gt;
&lt;li&gt;乐观锁(数据库版本好)&lt;/li&gt;
&lt;li&gt;分布式锁(Redis锁) &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　就好比说是你是一个生活态度乐观积极向上的人，总是往最好的情况去想，比如你每次去获取共享数据的时候会认为别人不会修改，所以不会上锁，但是在更新的时候你会判断这期间有没有人去更新这个数据。&lt;/p&gt;
&lt;p&gt;　　乐观锁使用在前，判断在后。我们看下伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;reduce()
{
    &lt;/span&gt;&lt;span&gt;select&lt;/span&gt; total_amount &lt;span&gt;from&lt;/span&gt;&lt;span&gt; table_1
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(total_amount &amp;lt;&lt;span&gt; amount ){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; failed.  
    }  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他业务逻辑&lt;/span&gt;
    update total_amount = total_amount -&lt;span&gt; amount &lt;/span&gt;&lt;strong&gt;where&lt;/strong&gt; total_amount &amp;gt; amount&lt;span&gt;; &lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;数据库的版本号属于乐高锁；&lt;/li&gt;
&lt;li&gt;通过CAS算法实现的类属于乐观锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　悲观锁是怎么理解呢？相对乐观锁刚好反过来，总是假设最坏的情况，假设你每次拿数据的时候会被其他人修改，所以你在每次共享数据的时候会对他加一把锁，等你使用完了再释放锁，再给别人使用数据。&lt;/p&gt;
&lt;p&gt;　　悲观锁判断在前，使用在后。我们也看下伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;reduce()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他业务逻辑&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; num = update total_amount = total_amount - amount &lt;span&gt;where&lt;/span&gt; total_amount &amp;gt;&lt;span&gt; amount; 
　　 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(num ==&lt;span&gt;1&lt;/span&gt;&lt;span&gt; ){
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务逻辑.  &lt;/span&gt;
    } &lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;Java中的的synchronize是重量级锁 ，属于悲观锁；&lt;/li&gt;
&lt;li&gt;数据库行锁属于悲观锁；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　这里举一个非常常见的例子，在高并发情况下余额扣减，或者类似商品库存扣减，也可以是资金账户的余额扣减。扣减操作会发生什么问题呢？很容易可以看到，可能会发生的问题是&lt;span&gt;&lt;strong&gt;扣减导致的超卖&lt;/strong&gt;&lt;/span&gt;，也就是扣减成了负数。&lt;/p&gt;
&lt;p&gt;　　举个例子，比如我的库存数据只有100个。并发情况下第1笔请求卖出100个，第2批卖出100元，导致当前的库存数量为负数。遇到这种场景应该如何破解呢？这里列举四种方案。&lt;/p&gt;
&lt;h3&gt;方案1：同步排它锁&lt;/h3&gt;
&lt;p&gt;　　这时候很容易想到最简单的方案：&lt;span&gt;&lt;strong&gt;同步排它锁&lt;/strong&gt;&lt;/span&gt;(synchronize)。但是排他锁的缺点很明显：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其中一个缺点是，线程串行导致的性能问题，性能消耗比较大。&lt;/li&gt;
&lt;li&gt;另一个缺点是无法解决分布式部署情况下跨进程问题；&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;方案2：数据库行锁&lt;/h3&gt;
&lt;p&gt;　　第二我们可能会想到，那用数据库行锁来锁住这条数据，这种方案相比排它锁解决了跨进程的问题，但是依然有缺点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其中一个缺点就是性能问题，在数据库层面会一直阻塞，直到事务提交，这里也是串行执行；&lt;/li&gt;
&lt;li&gt;第二个需要注意设置事务的隔离级别是Read Committed，否则并发情况下，另外的事务无法看到提交的数据，依然会导致超卖问题；&lt;/li&gt;
&lt;li&gt;缺点三是容易打满数据库连接，如果事务中有第三方接口交互(存在超时的可能性)，会导致这个事务的连接一直阻塞，打满数据库连接。&lt;/li&gt;
&lt;li&gt;最后一个缺点，容易产生交叉死锁，如果多个业务的加锁控制不好，就会发生AB两条记录的交叉死锁。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;方案3：redis分布式锁&lt;/h3&gt;
&lt;p&gt;　　前面的方案本质上是把数据库当作分布式锁来使用，所以同样的道理，redis，zookeeper都相当于数据库的一种锁，其实当遇到加锁问题，代码本身无论是synchronize或者各种lock使用起来都比较复杂，所以思路是把代码处理一致性的问难题交给一个能够帮助你处理一致性的问题的专业组件，比如数据库，比如redis，比如zookeeper等。&lt;/p&gt;
&lt;p&gt;　　这里我们分析下分布式锁的优缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：
&lt;ul&gt;&lt;li&gt;可以&lt;strong&gt;&lt;span&gt;避免大量对数据库排他锁的征用，提高系统的响应能力&lt;/span&gt;&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;&lt;li&gt;设置锁和设置超时时间的原子性；&lt;/li&gt;
&lt;li&gt;不设置超时时间的缺点；&lt;/li&gt;
&lt;li&gt;服务宕机或线程阻塞超时的情况；&lt;/li&gt;
&lt;li&gt;超时时间设置不合理的情况；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;加锁和过期设置的原子性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　redis加锁的命令setnx，设置锁的过期时间是expire，解锁的命令是del，但是2.6.12之前的版本中，加锁和设置锁过期命令是两个操作，不具备原子性。如果setnx设置完key-value之后，还没有来得及使用expire来设置过期时间，当前线程挂掉了或者线程阻塞，会导致当前线程设置的key一直有效，后续的线程无法正常使用setnx获取锁，导致死锁。&lt;/p&gt;
&lt;p&gt;　　针对这个问题，redis2.6.12以上的版本增加了可选的参数，可以在加锁的同时设置key的过期时间，保证了加锁和过期操作原子性的。&lt;/p&gt;
&lt;p&gt;　　但是，即使解决了原子性的问题，业务上同样会遇到一些极端的问题，比如分布式环境下，A获取到了锁之后，因为线程A的业务代码耗时过长，导致锁的超时时间，锁自动失效。后续线程B就意外的持有了锁，之后线程A再次恢复执行，直接用del命令释放锁，这样就错误的将线程B同样Key的锁误删除了。代码耗时过长还是比较常见的场景，假如你的代码中有外部通讯接口调用，就容易产生这样的场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置合理的时长&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　刚才讲到的线程超时阻塞的情况，那么如果不设置时长呢，当然也不行，如果线程持有锁的过程中突然服务宕机了，这样锁就永远无法失效了。同样的也存在锁超时时间设置是否合理的问题，如果设置所持有时间过长会影响性能，如果设置时间过短，有可能业务阻塞没有处理完成，是否可以合理的设置锁的时间?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;续命锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这是一个很不容易解决的问题，不过有一个办法能解决这个问题，那就是续命锁，我们可以先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间之后重新去设置这个锁的超时时间，续命锁的实现过程就是写一个守护线程，然后去判断对象锁的情况，快失效的时候，再次进行重新加锁，但是一定要判断锁的对象是同一个，不能乱续。&lt;/p&gt;
&lt;p&gt;　　同样，主线程业务执行完了，守护线程也需要销毁，避免资源浪费，使用续命锁的方案相对比较而言更复杂，所以如果业务比较简单，可以根据经验类比，合理的设置锁的超时时间就行。&lt;/p&gt;
&lt;h3&gt;方案4：数据库乐观锁&lt;/h3&gt;
&lt;p&gt;　　数据库乐观锁加锁的一个原则就是尽量想办法减少锁的范围。锁的范围越大，性能越差，数据库的锁就是把锁的范围减小到了最小。我们看下面的伪代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;reduce()
{
    &lt;/span&gt;&lt;span&gt;select&lt;/span&gt; total_amount &lt;span&gt;from&lt;/span&gt;&lt;span&gt; table_1
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(total_amount &amp;lt;&lt;span&gt; amount ){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; failed.  
    }  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他业务逻辑&lt;/span&gt;
    update total_amount = total_amount -&lt;span&gt; amount;  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　我们可以看到修改前的代码是没有where条件的。修改后，再加where条件判断：总库存大于将被扣减的库存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
update total_amount = total_amount - amount &lt;span&gt;where&lt;/span&gt; total_amount &amp;gt; amount
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果更新条数返回0，说明在执行过程中被其他线程抢先执行扣减，并且避免了扣减为负数。&lt;/p&gt;
&lt;p&gt;　　但是这种方案还会涉及一个问题，如果在之前的update代码中，以及其他的业务逻辑中还有一些其他的数据库写操作的话，那这部分数据如何回滚呢？&lt;/p&gt;
&lt;p&gt;　　我的建议是这样的，你可以选择下面这两种写法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用事务回滚写法：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　我们先给业务方法增加事务，方法在扣减库存影响条数为零的时候扔出一个异常，这样对他之前的业务代码也会回滚。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;reduce()
{
    &lt;/span&gt;&lt;span&gt;select&lt;/span&gt; total_amount &lt;span&gt;from&lt;/span&gt;&lt;span&gt; table_1
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(total_amount &amp;lt;&lt;span&gt; amount ){
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; failed.  
    }  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他业务逻辑&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; num = update total_amount = total_amount -&lt;span&gt; amount &lt;/span&gt;where total_amount &amp;gt; amount&lt;span&gt;; &lt;br/&gt;　　if(num==0) throw Exception;&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;第二种写法&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;reduce()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他业务逻辑&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; num = update total_amount = total_amount - amount &lt;span&gt;where&lt;/span&gt; total_amount &amp;gt;&lt;span&gt; amount; &lt;br/&gt;　　 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(num ==1&lt;span&gt; ){
          //业务逻辑&lt;/span&gt;&lt;span&gt;.  
    }  else{&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　throw&lt;/span&gt;&lt;span&gt; Exception;&lt;br/&gt;　　}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先执行update业务逻辑，如果执行成功了再去执行逻辑操作，这种方案是我相对比较建议的方案。在并发情况下对共享资源扣减操作可以使用这种方法，但是这里需要引出一个问题，比如说万一其他业务逻辑中的业务，因为特殊原因失败了该怎么办呢？比如说在扣减过程中服务OOM了怎么办？&lt;/p&gt;
&lt;p&gt;　　我只能说这些非常极端的情况，比如突然宕机中间数据都丢了，这种极少数的情况下只能人工介入，如果所有的极端情况都考虑到，也不现实。我们讨论的重点是并发情况下，共享资源的操作如何加锁的问题。&lt;/p&gt;

&lt;p&gt;　　最后我来给你总结一下，如果你可以非常熟练的解决这类问题，第一时间肯定想到的是：数据库版本号解决方案或者分布式锁的解决方案；但是如果你是一个初学者，相信你一定会第一时间考虑到Java中提供的同步锁或者数据库行锁。&lt;/p&gt;
&lt;p&gt;　　今天讨论的目的就是希望把这几种场景中的锁放到一个具体的场景中，逐步去对比和分析，让你能够更加全面体系的了解使用锁这个问题的来龙去脉。我是张飞洪，希望我的分享可以帮助到你。&lt;/p&gt;
</description>
<pubDate>Fri, 10 Jan 2020 00:38:00 +0000</pubDate>
<dc:creator>张飞洪[厦门]</dc:creator>
<og:description>如何确保一个方法，或者一块代码在高并发情况下，同一时间只能被一个线程执行，单体应用可以使用并发处理相关的 API 进行控制，但单体应用架构演变为分布式微服务架构后，跨进程的实例部署，显然就没办法通过应</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jackyfei/p/12142840.html</dc:identifier>
</item>
<item>
<title>SpringBoot2 整合 Zookeeper组件，管理架构中服务协调 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/12174394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/12174394.html</guid>
<description>&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/middle-ware-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/middle-ware-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;概念简介&quot;&gt;1、概念简介&lt;/h2&gt;
&lt;p&gt;Zookeeper是一个Apache开源的分布式的应用，为系统架构提供协调服务。从设计模式角度来审视：该组件是一个基于观察者模式设计的框架，负责存储和管理数据，接受观察者的注册，一旦数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的观察者做出相应的反应，从而实现集群中类似Master/Slave管理模式。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。&lt;/p&gt;
&lt;h2 id=&quot;基本理论&quot;&gt;2、基本理论&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;数据结构&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ZooKeeper记录数据的结构与Linux文件系统相似，整体可以看作一棵树，每个节点称ZNode。每个Znode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/202001/1691717-20200110073747199-1745043023.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;节点类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;短暂（ephemeral）：客户端和服务器端断开连接后，创建的节点自动删除。&lt;br/&gt;持久（persistent）：客户端和服务器端断开连接后，创建的节点持久化保存。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;集群服务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在Zookeeper集群服务是由一个领导者（leader），多个跟随者（follower）组成的集群。领导者负责进行投票的发起和决议，更新集群服务状态。跟随者用于接收客户请求并向客户端返回结果，在选举Leader过程中参与投票。集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据一致性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个server保存一份相同的数据拷贝，客户端无论请求到被集群中哪个server处理，得到的数据都是一致的。&lt;/p&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;3、应用场景&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;经典应用：Dubbo框架的服务注册和发现；&lt;/li&gt;
&lt;li&gt;分布式消息同步和协调机制；&lt;/li&gt;
&lt;li&gt;服务器节点动态上下线；&lt;/li&gt;
&lt;li&gt;统一配置管理、负载均衡、集群管理；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;操作权限&quot;&gt;1、操作权限&lt;/h2&gt;
&lt;p&gt;ZooKeeper的节点有5种操作权限：CREATE(增)、READ(查)、WRITE(改)、DELETE(删)、ADMIN(管理)等相关权限，这5种权限集合可以简写为crwda，每个单词的首字符拼接而成。&lt;/p&gt;
&lt;h2 id=&quot;认证方式&quot;&gt;2、认证方式：&lt;/h2&gt;
&lt;p&gt;默认方式，开放的权限，意解为全世界都能随意访问。&lt;/p&gt;
&lt;p&gt;已经授权且认证通过的用户才可以访问。&lt;/p&gt;
&lt;p&gt;用户名:密码方式认证，实际业务开发中最常用的方式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IP白名单&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;授权指定的Ip地址，和指定的权限点，控制访问。&lt;/p&gt;
&lt;h2 id=&quot;digest授权流程&quot;&gt;3、Digest授权流程&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;添加认证用户&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;addauth digest 用户名:密码&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置权限&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;setAcl /path auth:用户名:密码:权限&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查看Acl设置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;getAcl /path&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;完整操作流程&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;-- 添加授权用户
[zk: localhost:2181] addauth digest smile:123456
-- 创建节点
[zk: localhost:2181] create /cicada cicada
-- 节点授权
[zk: localhost:2181] setAcl /cicada auth:smile:123456:cdrwa
-- 查看授权
[zk: localhost:2181] getAcl /cicada&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;核心依赖&quot;&gt;1、核心依赖&lt;/h2&gt;
&lt;p&gt;Curator是Apache开源的一个Zookeeper客户端连接和操作的组件，Curator框架在Zookeeper原生API接口上进行二次包装。提供ZooKeeper各种应用场景：比如：分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等API封装。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;curator-framework&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.12.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;curator-recipes&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.12.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.curator&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;curator-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.12.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;zookeeper参数&quot;&gt;2、Zookeeper参数&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;zoo:
  keeper:
    #开启标志
    enabled: true
    #服务器地址
    server: 127.0.0.1:2181
    #命名空间，被称为ZNode
    namespace: cicada
    #权限控制，加密
    digest: smile:123456
    #会话超时时间
    sessionTimeoutMs: 3000
    #连接超时时间
    connectionTimeoutMs: 60000
     #最大重试次数
    maxRetries: 2
    #初始休眠时间
    baseSleepTimeMs: 1000&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;服务初始化配置&quot;&gt;3、服务初始化配置&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class ZookeeperConfig {
    private static final Logger LOGGER = LoggerFactory.getLogger(ZookeeperConfig.class) ;
    @Resource
    private ZookeeperParam zookeeperParam ;
    private static CuratorFramework client = null ;
    /**
     * 初始化
     */
    @PostConstruct
    public void init (){
        //重试策略，初试时间1秒，重试10次
        RetryPolicy policy = new ExponentialBackoffRetry(
                zookeeperParam.getBaseSleepTimeMs(),
                zookeeperParam.getMaxRetries());
        //通过工厂创建Curator
        client = CuratorFrameworkFactory.builder()
                .connectString(zookeeperParam.getServer())
                .authorization(&quot;digest&quot;,zookeeperParam.getDigest().getBytes())
                .connectionTimeoutMs(zookeeperParam.getConnectionTimeoutMs())
                .sessionTimeoutMs(zookeeperParam.getSessionTimeoutMs())
                .retryPolicy(policy).build();
        //开启连接
        client.start();
        LOGGER.info(&quot;zookeeper 初始化完成...&quot;);
    }
    public static CuratorFramework getClient (){
        return client ;
    }
    public static void closeClient (){
        if (client != null){
            client.close();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;封装系列接口&quot;&gt;4、封装系列接口&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ZookeeperService {
    /**
     * 判断节点是否存在
     */
    boolean isExistNode (final String path) ;
    /**
     * 创建节点
     */
    void createNode (CreateMode mode,String path ) ;
    /**
     * 设置节点数据
     */
    void setNodeData (String path, String nodeData) ;
    /**
     * 创建节点
     */
    void createNodeAndData (CreateMode mode, String path , String nodeData) ;
    /**
     * 获取节点数据
     */
    String getNodeData (String path) ;
    /**
     * 获取节点下数据
     */
    List&amp;lt;String&amp;gt; getNodeChild (String path) ;
    /**
     * 是否递归删除节点
     */
    void deleteNode (String path,Boolean recursive) ;
    /**
     * 获取读写锁
     */
    InterProcessReadWriteLock getReadWriteLock (String path) ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;接口实现&quot;&gt;5、接口实现&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class ZookeeperServiceImpl implements ZookeeperService {
    private static final Logger LOGGER = LoggerFactory.getLogger(ZookeeperServiceImpl.class);
    @Override
    public boolean isExistNode(String path) {
        CuratorFramework client = ZookeeperConfig.getClient();
        client.sync() ;
        try {
            Stat stat = client.checkExists().forPath(path);
            return client.checkExists().forPath(path) != null;
        } catch (Exception e) {
            LOGGER.error(&quot;isExistNode error...&quot;, e);
            e.printStackTrace();
        }
        return false;
    }
    @Override
    public void createNode(CreateMode mode, String path) {
        CuratorFramework client = ZookeeperConfig.getClient() ;
        try {
            // 递归创建所需父节点
            client.create().creatingParentsIfNeeded().withMode(mode).forPath(path);
        } catch (Exception e) {
            LOGGER.error(&quot;createNode error...&quot;, e);
            e.printStackTrace();
        }
    }
    @Override
    public void setNodeData(String path, String nodeData) {
        CuratorFramework client = ZookeeperConfig.getClient() ;
        try {
            // 设置节点数据
            client.setData().forPath(path, nodeData.getBytes(&quot;UTF-8&quot;));
        } catch (Exception e) {
            LOGGER.error(&quot;setNodeData error...&quot;, e);
            e.printStackTrace();
        }
    }
    @Override
    public void createNodeAndData(CreateMode mode, String path, String nodeData) {
        CuratorFramework client = ZookeeperConfig.getClient() ;
        try {
            // 创建节点，关联数据
            client.create().creatingParentsIfNeeded().withMode(mode)
                  .forPath(path,nodeData.getBytes(&quot;UTF-8&quot;));
        } catch (Exception e) {
            LOGGER.error(&quot;createNode error...&quot;, e);
            e.printStackTrace();
        }
    }
    @Override
    public String getNodeData(String path) {
        CuratorFramework client = ZookeeperConfig.getClient() ;
        try {
            // 数据读取和转换
            byte[] dataByte = client.getData().forPath(path) ;
            String data = new String(dataByte,&quot;UTF-8&quot;) ;
            if (StringUtils.isNotEmpty(data)){
                return data ;
            }
        }catch (Exception e) {
            LOGGER.error(&quot;getNodeData error...&quot;, e);
            e.printStackTrace();
        }
        return null;
    }
    @Override
    public List&amp;lt;String&amp;gt; getNodeChild(String path) {
        CuratorFramework client = ZookeeperConfig.getClient() ;
        List&amp;lt;String&amp;gt; nodeChildDataList = new ArrayList&amp;lt;&amp;gt;();
        try {
            // 节点下数据集
            nodeChildDataList = client.getChildren().forPath(path);
        } catch (Exception e) {
            LOGGER.error(&quot;getNodeChild error...&quot;, e);
            e.printStackTrace();
        }
        return nodeChildDataList;
    }
    @Override
    public void deleteNode(String path, Boolean recursive) {
        CuratorFramework client = ZookeeperConfig.getClient() ;
        try {
            if(recursive) {
                // 递归删除节点
                client.delete().guaranteed().deletingChildrenIfNeeded().forPath(path);
            } else {
                // 删除单个节点
                client.delete().guaranteed().forPath(path);
            }
        } catch (Exception e) {
            LOGGER.error(&quot;deleteNode error...&quot;, e);
            e.printStackTrace();
        }
    }
    @Override
    public InterProcessReadWriteLock getReadWriteLock(String path) {
        CuratorFramework client = ZookeeperConfig.getClient() ;
        // 写锁互斥、读写互斥
        InterProcessReadWriteLock readWriteLock = new InterProcessReadWriteLock(client, path);
        return readWriteLock ;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基于swagger2接口&quot;&gt;6、基于Swagger2接口&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Api(&quot;Zookeeper接口管理&quot;)
@RestController
public class ZookeeperApi {
    @Resource
    private ZookeeperService zookeeperService ;
    @ApiOperation(value=&quot;查询节点数据&quot;)
    @GetMapping(&quot;/getNodeData&quot;)
    public String getNodeData (String path) {
        return zookeeperService.getNodeData(path) ;
    }
    @ApiOperation(value=&quot;判断节点是否存在&quot;)
    @GetMapping(&quot;/isExistNode&quot;)
    public boolean isExistNode (final String path){
        return zookeeperService.isExistNode(path) ;
    }
    @ApiOperation(value=&quot;创建节点&quot;)
    @GetMapping(&quot;/createNode&quot;)
    public String createNode (CreateMode mode, String path ){
        zookeeperService.createNode(mode,path) ;
        return &quot;success&quot; ;
    }
    @ApiOperation(value=&quot;设置节点数据&quot;)
    @GetMapping(&quot;/setNodeData&quot;)
    public String setNodeData (String path, String nodeData) {
        zookeeperService.setNodeData(path,nodeData) ;
        return &quot;success&quot; ;
    }
    @ApiOperation(value=&quot;创建并设置节点数据&quot;)
    @GetMapping(&quot;/createNodeAndData&quot;)
    public String createNodeAndData (CreateMode mode, String path , String nodeData){
        zookeeperService.createNodeAndData(mode,path,nodeData) ;
        return &quot;success&quot; ;
    }
    @ApiOperation(value=&quot;递归获取节点数据&quot;)
    @GetMapping(&quot;/getNodeChild&quot;)
    public List&amp;lt;String&amp;gt; getNodeChild (String path) {
        return zookeeperService.getNodeChild(path) ;
    }
    @ApiOperation(value=&quot;是否递归删除节点&quot;)
    @GetMapping(&quot;/deleteNode&quot;)
    public String deleteNode (String path,Boolean recursive) {
        zookeeperService.deleteNode(path,recursive) ;
        return &quot;success&quot; ;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/middle-ware-parent
GitEE·地址
https://gitee.com/cicadasmile/middle-ware-parent&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Jan 2020 23:50:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： &amp;quot;GitHub&amp;#183;点这里&amp;quot; || &amp;quot;GitEE&amp;#183;点这里&amp;quot; 一、Zookeeper基础简介 1、概念简介 Zookeeper是一个A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/12174394.html</dc:identifier>
</item>
<item>
<title>讲真，这两个IDE插件，可以让你写出质量杠杠的代码 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12174391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12174391.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;77.871673003802&quot;&gt;
&lt;p&gt;昨晚躺在床上看《拯救大兵瑞恩》的时候，不由得感叹道：“斯皮尔伯格的电影质量真高，片头真实地还原了二战的残酷性。”看完后，我的精神异常的亢奋，就想写篇文章来帮助大家提高一下代码的质量，毕竟二哥也是一个有态度的作者啊，向斯皮尔伯格学习。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-plugin-code-quality-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;代码质量的重要性就不用我来赘述了，大家都懂。没有人喜欢糟糕的代码，就像没有人喜欢烂片一样。这里推荐两个优秀的 IDE 插件给大家，保管能提高你的代码质量，我亲身实操过的，确实很不错。&lt;/p&gt;
&lt;h3 id=&quot;h01alibabajava&quot;&gt;&lt;span&gt;01、Alibaba Java 代码规范插件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;阿里巴巴的《Java 开发手册》，相信大家都不会感到陌生，其配套的代码规范插件的下载次数据说达到了 80 万次。好吧，我今天又贡献了一次。😁。&lt;/p&gt;
&lt;p&gt;插件的 GitHub 地址如下所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/p3c&quot;&gt;https://github.com/alibaba/p3c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该项目此刻的 star 数达到了 19.9K，很不错的成绩哦。&lt;/p&gt;
&lt;p&gt;插件（有 IDEA 版本和 Eclipse 版）的安装教程地址如下所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/alibaba/p3c/wiki&quot;&gt;https://github.com/alibaba/p3c/wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IDEA 的安装方法更便捷一点，直接在【Plugins】面板中搜索关键字“alibaba”，第一个选项就是该插件，直接点击【Install】就可以了。见下图。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-plugin-code-quality-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;安装成功后，我扫描了一下当前项目【右键菜单→编码规约扫描】，发现了下图中这些建议。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-plugin-code-quality-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;此时此刻，我只能套用周杰伦老师那句：“哎呀，不错哦”。&lt;/p&gt;
&lt;p&gt;PS：项目代码已经同步到 GitHub，地址为 &lt;a href=&quot;https://github.com/qinggee/JavaPoint&quot;&gt;itwanger.JavaPoint&lt;/a&gt;，欢迎大家 star 和 issue。&lt;/p&gt;
&lt;h3 id=&quot;h02sonarlint&quot;&gt;&lt;span&gt;02、SonarLint 插件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;SonarLint 插件的官方地址如下所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sonarlint.org/&quot;&gt;https://www.sonarlint.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;来看一下该插件的自我介绍：&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-plugin-code-quality-04.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;用我蹩脚的英语翻译一下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;SonarLint 是一个 IDE 插件，可以帮助你在编写代码时检测到问题，并进行修复。就像拼写检查器一样实时，SonarLint 可以方便你在提交代码之前就对其进行修复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SonarLint 插件也有各种版本，不仅支持 Eclipse 和 IDEA，还支持 Visual Studio 和 VS Code。IDEA 的安装方法也很简单，直接在【Plugins】面板中搜索关键字“SonarLint”，直接点击【Install】就可以了。见下图。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-plugin-code-quality-05.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;安装成功后，我扫描了一下当前项目【右键菜单→SonarLint → Analysis With SonarLint 】，发现了下面这些建议。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-plugin-code-quality-06.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;PPS：项目代码已经同步到 GitHub，地址为 &lt;a href=&quot;https://github.com/qinggee/JavaPoint&quot;&gt;itwanger.JavaPoint&lt;/a&gt;，欢迎大家 star 和 issue。&lt;/p&gt;
&lt;h3 id=&quot;h03alibabasonarlint&quot;&gt;&lt;span&gt;03、对比 Alibaba 代码规范插件和 SonarLint 插件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这两款插件各有不同，首先最大的不同就是 Alibaba 代码规范插件是中文版的，SonarLint 是英文版的，😄。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-plugin-code-quality-07.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;其次呢，对比两款插件扫描的截图就可以发现，Alibaba 代码规范插件是按照问题的等级归类的；而 SonarLint 插件是按照不同的类归类的。&lt;/p&gt;
&lt;p&gt;能不能说重点？好，好，好，客官别着急嘛。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Alibaba 代码规范插件比较关心的是编码风格上的规范，比如说 long 变量的赋值、条件语句后的大括号、重写的时候有没有使用 &lt;code&gt;@Override&lt;/code&gt; 注解等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;SonarLint 插件比较关心的是代码的正确性，比如说尽量不要重写 clone 方法、使用日志系统代替 &lt;code&gt;System.out&lt;/code&gt;、重写 clone 方法的时候不要返回 null 等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之呢，两者之间没有冲突，建议配合使用，Alibaba 代码规范插件用来规范代码，SonarLint 插件用来发现代码隐藏的问题。这样的话，就能够在代码编写阶段规避风险，消灭隐患，提高程序的健壮性。&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;&lt;span&gt;04、鸣谢&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;好了，各位读者朋友们，以上就是本文的全部内容了。&lt;strong&gt;能看到这里的都是最优秀的程序员，升职加薪就是你了&lt;/strong&gt;👍。如果觉得不过瘾，还想看到更多，我再推荐几篇给大家。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/i1RZRO4mNCJ32Y_EX6QM2g&quot;&gt;惊呆了！Java程序员最常犯的错竟然是这10个&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/J8rnSdji3Mkrml98soFBFw&quot;&gt;2019年，我在全网最受欢迎的10篇文章，阅读量超60万&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Iq6C56_H6CThR5w6v_sQ7Q&quot;&gt;面试官刁难：Java字符串可以引用传递吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原创不易，如果觉得有点用的话，请不要吝啬你手中点赞的权力&lt;/strong&gt;；如果想要第一时间看到二哥更新的文章，请扫描下方的二维码，关注沉默王二公众号。我们下篇文章见！&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/cmower_2.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 09 Jan 2020 23:43:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>昨晚躺在床上看《拯救大兵瑞恩》的时候，不由得感叹道：“斯皮尔伯格的电影质量真高，片头真实地还原了二战的残酷性。”看完后，我的精神异常的亢奋，就想写篇文章来帮助大家提高一下代码的质量，毕竟二哥也是一个有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12174391.html</dc:identifier>
</item>
<item>
<title>Windows 7 + Tiny Linux 4.19 + XFS + Vmware Workstation 15 (PRO) 下篇dockerの奥义 - A.Z</title>
<link>http://www.cnblogs.com/A-Z/p/docker2dockerfile.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/A-Z/p/docker2dockerfile.html</guid>
<description>&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;美好的事物总是来自不易，而我是一个docker新手&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;
&lt;p&gt;从以上开场，请各位follow me站在一个初学者的角度，一步一步用最简单的视角审视docker和它的真实存在&lt;/p&gt;
&lt;p&gt;上篇&lt;a id=&quot;post_title_link_12154457&quot; href=&quot;https://www.cnblogs.com/A-Z/p/preview_docker_s2.html&quot;&gt;预告:Windows 7 + Tiny Linux 4.19 + XFS + Vmware Workstation 15 (PRO)下篇dockerの奥义&lt;/a&gt; 我提到了今天这篇随笔的内容，虽然不出意外，但是...但是亮点总在最后&lt;/p&gt;
&lt;p&gt;XFS提供了很好的并发性能，而docker又以轻量级的虚拟化容器著称，两者结合会插出怎么样的水花呢&lt;/p&gt;
&lt;p&gt;嗯，在我的环境里，非常流畅，不同于甲骨巨婴VBOX, Vmware在负荷下CPU调度妥贴，丝毫感受不到虚拟机的存在，跑题了，这句下上文异常&lt;/p&gt;
&lt;p&gt;从XFS出发，首先需要一个额外的虚拟存储，那么怎么制作XFS disk呢...此处省略500字...so far so good...XFS disk制作好了，那么相比单存储又有什么优势呢...一个问题接一个问题...那就是docker-machine rm default后所有的images containers volumes etc.并不丢失呢&lt;/p&gt;
&lt;p&gt;以下是案例教学：&lt;/p&gt;
&lt;p&gt;有一位网友发了一条信息给boot2docker官方,内容如下&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;after update boot2docker.iso,my data lost&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这位网友的头像是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://avatars0.githubusercontent.com/u/25222094?s=460&amp;amp;v=4&quot; alt=&quot;&quot; width=&quot;363&quot; height=&quot;363&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了杜绝此类悲剧再次上演，请合理布局docker &lt;span&gt;&lt;sup&gt;😄&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在下面这张图片里，额外的虚拟存储被使用，最关键的是它的路径和docker无关，所以即便docker被完整删除，所有的资料还可以保存下来&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/A-Z/117549/o_vmware_default.PNG&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;NaN&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以下的图片是Vmware中的详细配置，请注意重点圈注的内容，后续会提到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/A-Z/117549/o_vmware_default_opt.PNG&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;NaN&quot;/&gt;&lt;/p&gt;

&lt;p&gt;按照预告的内容，符合新手的下一步，一定必定肯定是pull一个container来划划水&lt;/p&gt;
&lt;p&gt;嗯？应该是image更为确切，但是docker的cli有一个很简化的命令run，连pull带run，很好呢&lt;/p&gt;
&lt;p&gt;用一个最简单的命令就可以夯出水花哦 -&amp;gt; docker run -v /mnt/hgfs/Users/:/home -itd mcr.microsoft.com/dotnet/core/runtime:latest bash&lt;/p&gt;
&lt;p&gt;嗯，这条命令一共花了三个小时，这可是满城千兆的时尚之都，mcr.microsoft.com是从ISP拿到的IP，三小时后，我从朦胧睡意中醒来，大惊，retry...retry...retry的日志试图在证明docker很无辜&lt;/p&gt;
&lt;p&gt;往日下一些大片速度都是杠杠的，怎么碰到mcr.microsoft.com，突然变了呢&lt;/p&gt;
&lt;p&gt;把曾经美好的印象一下子仿佛失去了色彩&lt;/p&gt;
&lt;p&gt;过去或者将来我都会很耿直的直连mcr.microsoft.com，并不是我很傻很天真，只是出于一个求知者必经的求实&lt;/p&gt;
&lt;p&gt;上dockerhub，pull一个runtime三小时出成绩很好呢&lt;/p&gt;
&lt;p&gt;忘了顺便提一句，在powershell里是这样的，用bash要//. 这样就可以访问user(hosthome)了，鼠标点击图片的左侧圈注，请把c:\users改为其他目录，熟悉Windows的我们一定对这个目录相当的敏感，告别c:\users从点点滴滴做起&lt;/p&gt;
&lt;p&gt;三个小时后我打出了dotnet new, 然后想了一想，这是runtime!!!一语惊醒梦中人，放弃，打出--version，嗯？&lt;/p&gt;
&lt;p&gt;忘了attach, bash的minitty果不其然，不如powershell&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;

&lt;p&gt;  It was not possible to find any installed .NET Core SDKs&lt;/p&gt;
&lt;p&gt;  Did you mean to run .NET Core SDK commands? Install a .NET Core SDK from:&lt;/p&gt;
&lt;p&gt;      https://aka.ms/dotnet-download&lt;/p&gt;

&lt;p&gt;Host (useful for support):&lt;/p&gt;
&lt;p&gt;  Version: 3.1.0&lt;/p&gt;
&lt;p&gt;  Commit:  157910edee&lt;/p&gt;

&lt;p&gt;.NET Core SDKs installed:&lt;/p&gt;
&lt;p&gt;  No SDKs were found.&lt;/p&gt;

&lt;p&gt;.NET Core runtimes installed:&lt;/p&gt;
&lt;p&gt;  Microsoft.NETCore.App 3.1.0 [/usr/share/dotnet/shared/Microsoft.NETCore.App]&lt;/p&gt;

&lt;p&gt;To install additional .NET Core runtimes or SDKs:&lt;/p&gt;
&lt;p&gt;  https://aka.ms/dotnet-download&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是所有的--info，一阵眩晕我又倒下睡了&lt;/p&gt;
&lt;p&gt;彻夜无梦......&lt;/p&gt;
&lt;p&gt;按照预告的内容，写到这里应该也快到尾声了，无意发现的0-3.boot2docker.pool.ntp.org的ntp请求，好像也不能改，毕竟是人家官方的branding bits&lt;/p&gt;
&lt;p&gt;好了，整理一下从一个命令出发需要整理的知识点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt; shareName, hostDir, shareDir 分别对应 &quot;Users&quot;, &quot;C:\\Users&quot;, &quot;/hosthome&quot;&lt;/li&gt;
&lt;li&gt; 从rcS出发到tc-config到bootsync.sh到bootsync.sh(2)到bootlocal.sh,ntpd牢牢地卡在最前方，没有pre-script可以inject&lt;/li&gt;
&lt;li&gt;即使三个小时retry，docker毅然的坚挺，值得肯定&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后就很华丽不是吗？？？&lt;/p&gt;
&lt;p&gt;这不是你期待的吗？？？&lt;/p&gt;
&lt;p&gt;我是一个docker新手，于是我开始了第一个dockfile， 这将是???&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/A-Z/117549/o_docker_image_build.PNG&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;NaN&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说起这张图，在起初的5分钟(第一次气定神闲的打出docker build不带T)，我是一名很好，很懒的新手，我什么都不想干，什么都不想做，什么都不想理，但是5分钟过去了，我看了看进度，突然&lt;/p&gt;
&lt;p&gt;一个idea出现了！！！&lt;/p&gt;
&lt;p&gt;于是我看了很多404,很多很多404，而这些404在下一个瞬间又会变成200，这就是著名的&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;Schrödinger's &quot;Cat 404&quot;&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在漫漫的等待后，我又看到了一张新的图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/A-Z/117549/o_boot2eva.PNG&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;115&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请记住这张图，请不要伸手索要，KERNEL_CONFIG变了，TINY LINUX变了，VM CLIENTS变了&lt;/p&gt;
&lt;p&gt;终于彻底的移除了巨婴VBOX的支持，升级了VMWARE的版本，然后还有什么我想想...0-3.boot2docker.pool.ntp.org???做人要厚道，怎么可以对这么好用的boot2docker branding下手！！！&lt;/p&gt;
&lt;p&gt;最后密码当然是和driver一起&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;超级便便便&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好像不经意间用了CentOS的efiboot做了一个UEFI和BIOS都支持的ISO，成功的进入了...grub，验证了fat image的合理性，BIOS是完美的&lt;/p&gt;
&lt;p&gt;在篇末隆重宣告后续の补完篇  ：UEFI制作&lt;/p&gt;

&lt;p&gt;数一数我的第一：&lt;/p&gt;
&lt;p&gt;第一次MAKE linux的项目是（不是hello world噢）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nas2x.com/threads/arm-linuxaria2-1-34-0-rpc2.550/&quot; target=&quot;_blank&quot;&gt;&quot;&lt;strong&gt;&lt;span&gt;大概是世界上最好的支持最古老的ARM LINUX系统的aria2,版本1.34.0,修改了最大连接数,RPC限制2个以上的网络接口&lt;/span&gt;&lt;/strong&gt; &quot;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第一次MAKE linux的OS是 （不是redhat噢）：&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_11353299&quot; href=&quot;https://www.cnblogs.com/A-Z/p/QCA9558_ATH79_NANDDRIVER.html&quot;&gt;全世界仅有的唯一最高LINUX版本的白菜路由，支持NAND记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第一次MAKE dockerfile是？&lt;/p&gt;
&lt;p&gt;本篇带给你全新的感受了吗???&lt;/p&gt;
</description>
<pubDate>Thu, 09 Jan 2020 16:28:00 +0000</pubDate>
<dc:creator>A.Z</dc:creator>
<og:description>本篇随笔意在从初学者出发，介绍docker使用中的一些个人感受，篇末很华丽，大概也算是世界第一吧，亮点图中找</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/A-Z/p/docker2dockerfile.html</dc:identifier>
</item>
<item>
<title>AVR单片机教程——ADC - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/12169442.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/12169442.html</guid>
<description>&lt;h3 id=&quot;adc&quot;&gt;ADC&lt;/h3&gt;
&lt;p&gt;计算机的世界是0和1的。单片机可以通过读取0和1来确定按键状态，也可以输出0和1来控制LED。即使是看起来不太0和1的PWM，好像可以输出0到5V之间的电压一样，达到0和1之间的效果，但本质上还是高低电平。&lt;/p&gt;
&lt;p&gt;但是，世界上终究还是有0和1无法表示的。如果引脚上被施加0到5V之间的电压，寄存器&lt;code&gt;PINx&lt;/code&gt;无法告诉我们具体情况，只能指示这个电压是1.5V以下还是3V以上（参考数据手册“Electrical characteristics”）。这种可以连续变化的信号称为&lt;em&gt;模拟信号&lt;/em&gt;，与离散的、只能取0或1（0或5V）的&lt;em&gt;数字信号&lt;/em&gt;对立。&lt;/p&gt;
&lt;p&gt;这并不代表数字世界无法处理模拟信号，相反，一种相当常用的处理模拟信号的方法，就是把模拟信号转换成数字信号，用处理器来运算，然后再转换成模拟信号。这个过程中涉及到模拟-数字转换和数字-模拟转换，分别需要ADC和DAC来实现。大多数单片机，作为现实世界中的工具，需要接触模拟信号，尤其是模拟信号的输入，会集成ADC。&lt;/p&gt;
&lt;p&gt;ADC的一个参数是分辨率，指它的位数，反映了可以产生的不同输出的数量（8位ADC可以产生0~255的值）与量化最小物理量（通常是电压）的能力（比如当参考电压为2.56V时，理想情况下，8位ADC可以分辨两个相差0.01V的电压的不同）。AVR单片机带有的ADC是10位的。&lt;/p&gt;
&lt;p&gt;另一个参数是转换速率，每秒进行A/D转换的次数。AVR单片机的ADC为了达到10位分辨率的精度，最大转换速率为15kSPS（千次采样每秒）。如果可以接受较低的精度，也可以以200kSPS采样，获得8位数据。&lt;/p&gt;
&lt;p&gt;分辨率与精度是不同的概念。在这篇入门级教程中，我们只需要知道，A/D转换是会有误差的（数据手册23.7.4一节介绍了可能的误差来源）。即使是相同的电压，两次测量的结果也可能是不同的。&lt;/p&gt;
&lt;p&gt;要进行A/D转换，需要提供参考电压和待测电压，转换的结果为&lt;span class=&quot;math inline&quot;&gt;\(\frac {待测电压} {参考电压} \times 2^{分辨率}\)&lt;/span&gt;。寄存器&lt;code&gt;ADMUX&lt;/code&gt;中的&lt;code&gt;ADLAR&lt;/code&gt;位控制转换结果的对齐方式。当右对齐时，公式中分辨率取10，转换结果在16位寄存器&lt;code&gt;ADC&lt;/code&gt;中（实际上是两个8位寄存器&lt;code&gt;ADCH&lt;/code&gt;与&lt;code&gt;ADCL&lt;/code&gt;，但程序可以直接使用&lt;code&gt;ADC&lt;/code&gt;，编译器会处理好一些注意事项）；当左对齐时，分辨率取8，转换结果在&lt;code&gt;ADCH&lt;/code&gt;中。可以直接把&lt;code&gt;ADC&lt;/code&gt;当做16位寄存器，编译器会处理好一些注意事项。&lt;/p&gt;
&lt;p&gt;ADC有4种参考电压可供选择，分别是&lt;code&gt;AREF&lt;/code&gt;、&lt;code&gt;AVCC&lt;/code&gt;（5V）、&lt;code&gt;1.1V&lt;/code&gt;和&lt;code&gt;2.56V&lt;/code&gt;，由&lt;code&gt;REFS1:0&lt;/code&gt;选择。8个单端端口（开发板上引出了4个，端口&lt;code&gt;0&lt;/code&gt;到&lt;code&gt;3&lt;/code&gt;），以及一些差分端口（&lt;code&gt;1x&lt;/code&gt;、&lt;code&gt;10x&lt;/code&gt;、&lt;code&gt;200x&lt;/code&gt;增益）和两个参考电压，共32个通道，可以通过多路复用器连接到ADC上进行转换，由&lt;code&gt;MUX4:0&lt;/code&gt;选择。注意，ADC只有一个，在同一时刻只能转换一个通道的电压。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ADCSRA&lt;/code&gt;和&lt;code&gt;ADCSRB&lt;/code&gt;用于控制A/D转换。&lt;code&gt;ADCSRA&lt;/code&gt;中&lt;code&gt;ADEN&lt;/code&gt;启用ADC组件，&lt;code&gt;ADSC&lt;/code&gt;位启动一次转换，到&lt;code&gt;ADIF&lt;/code&gt;位为&lt;code&gt;1&lt;/code&gt;时转换结束，需要写&lt;code&gt;1&lt;/code&gt;才能清零。&lt;code&gt;ADPS2:0&lt;/code&gt;选择ADC时钟分频系数，这关系到转换速率：首次采样（启用ADC后第一次或同时）需要25个ADC时钟周期，随后每次采样需要13个。&lt;code&gt;ADCSRB&lt;/code&gt;可以选择A/D转换触发源。&lt;/p&gt;
&lt;p&gt;开发板提供了3.3V电源，可用于给只支持3.3V的设备供电。我们用ADC来测量这个电压，然后在串口上输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;avr/io.h&amp;gt;
#include &amp;lt;ee1/uart.h&amp;gt;

int main()
{
    uart_init(UART_TX);
    ADMUX  =    0b01 &amp;lt;&amp;lt; REFS0  // AVCC as reference
           |     0b0 &amp;lt;&amp;lt; ADLAR  // right adjust
           | 0b00000 &amp;lt;&amp;lt; MUX0;  // ADC0 single ended
    ADCSRA =       1 &amp;lt;&amp;lt; ADEN   // enable ADC
           |       1 &amp;lt;&amp;lt; ADSC   // start conversion
           |       1 &amp;lt;&amp;lt; ADIF   // clear flag
           |   0b111 &amp;lt;&amp;lt; ADPS0; // divide by 128
           
    while (!(ADCSRA &amp;amp; 1 &amp;lt;&amp;lt; ADIF)) // wait until flag is set
        ;
    
    uint16_t voltage = (uint32_t)ADC * 500 &amp;gt;&amp;gt; 10; // ADC / 1024 * 500 (* 10mV)
    uint8_t integer = 0;                          // integer part of voltage
    while (integer * 100 &amp;lt;= voltage)              // calculate integer part
        ++integer;
    --integer;
    uint8_t decimal = voltage - integer * 100;    // calculate decimal part
    
    uart_print_int(integer);                      // print the voltage
    uart_print_char('.');
    uart_set_align(UART_ALIGN_RIGHT, 2, '0');
    uart_print_int(decimal);
    uart_print_string(&quot;V\n&quot;);
    
    while (1)
        ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据手册28.8节指明，当ADC时钟为200kHz时，ADC绝对精度可以达到1.9LSB（1LSB就是1024中的1）。经计算得，为了使ADC时钟不超过这个速率，分频系数应该取128。&lt;/p&gt;
&lt;p&gt;所测电压为&lt;span class=&quot;math inline&quot;&gt;\(voltage = \frac {ADC} {1024} \times 5V\)&lt;/span&gt;，但直接这样计算会涉及到浮点运算，而AVR硬件不支持浮点，所有浮点运算都是软件实现的，速度相当慢，两个&lt;code&gt;float&lt;/code&gt;相乘需要1000多个指令周期，除法需要更多，都是应该竭力避免的。尽管最后的电压是一个小数，但可以通过移动小数点把它变成整数。5V参考电压下，精度1.9LSB约为9.28mV，因此右移两位，以10mV为单位计算。先算乘法以避免浮点除法，算式变为&lt;span class=&quot;math inline&quot;&gt;\(voltage = \frac {ADC \times 500} {1024}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ADC&lt;/code&gt;的值直接与&lt;code&gt;500&lt;/code&gt;相乘会溢出，因此需要先提升为&lt;code&gt;uint32_t&lt;/code&gt;。当然，你可以把算式约分一下，但不改变会溢出的事实。尽管32位整数不太好处理，但相比浮点数还是容易得多。然后是一个除法。16位整数除法需要173个CPU指令周期（参考：&lt;a href=&quot;http://ww1.microchip.com/downloads/en/AppNotes/doc0936.pdf&quot; target=&quot;_blank&quot;&gt;Multiply and Divide Routines&lt;/a&gt;），是比较耗时的。尽管这个程序中只计算一次，但还是应该尽量想办法避免耗时的操作。注意到除数&lt;code&gt;1024&lt;/code&gt;是一个特殊的数，是2的10次方，可以通过移位运算来做除法，而移位运算相比除法快得多（也许编译器会把&lt;code&gt;/ 1024&lt;/code&gt;优化成&lt;code&gt;&amp;gt;&amp;gt; 10&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;然后我们需要把这个数的百位部分拿出来作电压的整数部分，十位和个位作小数部分，可以通过除以&lt;code&gt;100&lt;/code&gt;和模&lt;code&gt;100&lt;/code&gt;来实现。由于这里的&lt;code&gt;100&lt;/code&gt;是一个编译期常数，编译期很可能把这个除法和取模优化掉，不调用100多周期的过程。这里我们感受一下手动优化。由于变量&lt;code&gt;voltage&lt;/code&gt;一定小于&lt;code&gt;500&lt;/code&gt;，可以用乘法和比较的循环来试出这个商，其中乘法的执行次数不超过6次——AVR单片机有双周期乘法指令。然后，用乘法与减法求出余数。&lt;/p&gt;
&lt;p&gt;ADC是单片机编程中相对容易用到浮点与乘除法的场合，设计算法时应尽量注意避免耗时的运算，或手动编写优化的算法来代替。&lt;/p&gt;
&lt;h3 id=&quot;电位器&quot;&gt;电位器&lt;/h3&gt;
&lt;p&gt;电位器，开发板右侧两个旋钮中左边一个，可以连续转动300°。电气属性相当于物理实验中的滑动变阻器，如果把两个定片接在&lt;code&gt;VCC&lt;/code&gt;和&lt;code&gt;GND&lt;/code&gt;上，动片电压就可以指示旋钮旋转的角度，并且通常与角度是成正比的。&lt;/p&gt;
&lt;p&gt;之前提到过，A/D转换是有误差的，即使输入电压保持不变，转换结果也可能上下浮动。如果再加上一些电磁干扰，比如附近有电机，这种噪音会更加明显。如果一个程序需要检测电位器旋转的位置在中点的哪边，并仅仅是简单地比较转换结果与&lt;code&gt;128&lt;/code&gt;的大小关系，这种噪声会导致严重后果，如红色波形所示：&lt;/p&gt;
&lt;p&gt;[picture]&lt;/p&gt;
&lt;p&gt;在阈值&lt;code&gt;128&lt;/code&gt;附近，噪声使转换结果上下浮动，导致判断出的状态迅速跳变。用户只是慢慢地把旋钮转过中间的位置，这显然不是我们想要的结果。&lt;/p&gt;
&lt;p&gt;这时候就需要滞回比较器出场了。滞回比较器的核心特性是，使输出在0和1之间改变的输入阈值在两个方向上是不同的：当信号从低到高越过高阈值时，输出变为1；当信号从高到低越过低阈值时，输出变为0；如绿色波形所示（图中是反相的）。于是，当输入达到高阈值时，输出变为1，此时只要噪音没有大到使输入回到低阈值，输出将一直保持为1，滤除了噪声。&lt;/p&gt;
&lt;p&gt;我们写一个程序，用LED来指示电位器旋钮位置在中点的哪一侧，并在串口上输出每一次状态改变，方便我们观察。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;ee1/pot.h&amp;gt;
#include &amp;lt;ee1/led.h&amp;gt;
#include &amp;lt;ee1/uart.h&amp;gt;
#include &amp;lt;ee1/delay.h&amp;gt;

void init();
void normal();
void hysteresis();

int main()
{
    init();
    while (1)
    {
        normal();
//         hysteresis();
        delay(1);
    }
}

static bool status;

void change(bool _value)
{
    status = _value;
    uart_print_string(_value ? &quot;on\n&quot; : &quot;off\n&quot;);
    led_set(LED_BLUE, _value);
}

void init()
{
    pot_init(ADC_0);
    led_init();
    uart_init(UART_TX);
    status = pot_read() &amp;gt;= 128;
}

void normal()
{
    bool now = pot_read() &amp;gt;= 128;
    if (status != now)
        change(now);
}

void hysteresis()
{
    uint8_t pot = pot_read();
    if (status &amp;amp;&amp;amp; pot &amp;lt; 124)
        change(0);
    else if (!status &amp;amp;&amp;amp; pot &amp;gt;= 132)
        change(1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;normal&lt;/code&gt;和&lt;code&gt;hysteresis&lt;/code&gt;函数二选一，其中后者使用了滞回比较的算法。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;normal&lt;/code&gt;模式下，把电位器调整到中点附近的一个位置，你会发现黄色的TX指示灯发了疯一样地闪，串口软件显示一长串的“on”和“off”（仔细调，一定会有）——你根本不需要制造任何干扰，仅凭ADC的误差就可以让程序运行地非常糟糕。如果用满10位的分辨率，这样的现象会更加明显。&lt;/p&gt;
&lt;p&gt;而在&lt;code&gt;hysteresis&lt;/code&gt;模式下，这样的状况不会出现。&lt;/p&gt;
&lt;h3 id=&quot;光敏电阻&quot;&gt;光敏电阻&lt;/h3&gt;
&lt;p&gt;光敏电阻是一种特殊的电阻器，在光强的时候电阻小，在光弱的时候电阻大。将一个光敏电阻与一个普通电阻串联，接在&lt;code&gt;VCC&lt;/code&gt;和&lt;code&gt;GND&lt;/code&gt;之间，测量中间点的电压，就能知道光的强弱。&lt;/p&gt;
&lt;p&gt;当然，已知开发板上与光敏电阻串联的电阻是10kΩ，根据某一时刻的ADC转换结果，也可以计算出此时光敏电阻的阻值。不过不要误会，是通过电压而不是阻值来获得光强。&lt;/p&gt;
&lt;p&gt;与电位器一样，如果要检测光的强与弱两种状态，也要用到滞回比较。取两个阈值为&lt;code&gt;100&lt;/code&gt;和&lt;code&gt;150&lt;/code&gt;，两者相差较大，这是因为我们要在光较弱时开灯，这又会增强亮度（有点负反馈的意味），如果相差不够大，就会陷入循环当中。&lt;/p&gt;
&lt;p&gt;这两个阈值是随便取的，实际应用应根据具体环境取值。于是容易想到要把这个功能从应用程序中抽离出来成为一个库。但是，不同于之前常用的、返回外设状态让客户来决定操作的函数（尽管还是可以这么写），这个库是事件驱动的：客户注册事件发生时要执行的动作，把程序流程交给框架来控制。&lt;/p&gt;
&lt;p&gt;程序分为三个文件：&lt;code&gt;event.h&lt;/code&gt;、&lt;code&gt;event.c&lt;/code&gt;和&lt;code&gt;main.c&lt;/code&gt;，前两个可以独立成库，供以后使用，为了方便，和可执行程序放在一起了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;event.h&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifndef EVENT_H
#define EVENT_H

#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;stdbool.h&amp;gt;

void ldr_event_init(uint8_t _thl, uint8_t _thh, void (*_func)(bool));
void ldr_event_cycle();

#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;event.c&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;event.h&quot;
#include &amp;lt;ee1/ldr.h&amp;gt;

static void (*handler)(bool);
static uint8_t low, high;
static bool status;

void ldr_event_init(uint8_t _thl, uint8_t _thh, void (*_func)(bool))
{
    ldr_init(ADC_1);
    low = _thl;
    high = _thh;
    handler = _func;
    uint8_t ldr = ldr_read();
    if (ldr &amp;lt;= low)
        handler(status = 0);
    else
        handler(status = 1);
}

void ldr_event_cycle()
{
    uint8_t ldr = ldr_read();
    if (status &amp;amp;&amp;amp; ldr &amp;lt;= low)
        handler(status = 0);
    else if (!status &amp;amp;&amp;amp; ldr &amp;gt;= high)
        handler(status = 1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;main.c&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;ee1/led.h&amp;gt;
#include &amp;lt;ee1/delay.h&amp;gt;
#include &quot;event.h&quot;

void handler(bool e)
{
    if (e)
        led_off();
    else
        led_on();
}

int main()
{
    led_init();
    ldr_event_init(100, 150, handler);
    while (1)
    {
        ldr_event_cycle();
        delay(1000);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户先编写事件处理函数&lt;code&gt;handler&lt;/code&gt;，参数为一个&lt;code&gt;bool&lt;/code&gt;，返回&lt;code&gt;void&lt;/code&gt;，这是&lt;code&gt;ldr_event_init&lt;/code&gt;所规定的。&lt;code&gt;handler&lt;/code&gt;根据参数执行相应动作：当&lt;code&gt;e&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;时，光由弱变强，关灯；反之开灯。在调用&lt;code&gt;ldr_event_init&lt;/code&gt;时，把这个函数的指针作为参数传入。随后，每隔1秒调用一次&lt;code&gt;ldr_event_cycle&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;请先花一点时间，把库的每一行理解清楚。然后，我们站在客户的角度来看，使用这个库是相对方便的——只需考虑事件，即光的变化，而无需考虑过程，即如何检测这一变化——事实上客户根本没有去检测，更别说如何了。不过，&lt;code&gt;main&lt;/code&gt;函数必须每隔一段时间调用一次&lt;code&gt;ldr_event_cycle&lt;/code&gt;。在学了定时器中断以后，&lt;code&gt;main&lt;/code&gt;函数就可以完全还给客户了。&lt;/p&gt;
&lt;h3 id=&quot;作业&quot;&gt;作业&lt;/h3&gt;
&lt;ol readability=&quot;0.41216216216216&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查阅相关资料，了解ADC有哪些类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;改进上一讲中的RGBW灯程序，使LED亮度适应环境光强。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;结合代码消化吸收事件驱动的概念。推荐阅读：&lt;a href=&quot;http://www.technologyuk.net/computing/software-development/software-design/event-driven-programming.shtml&quot; target=&quot;_blank&quot;&gt;Event-driven Programming - TechnologyUK&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 09 Jan 2020 16:17:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>ADC 计算机的世界是0和1的。单片机可以通过读取0和1来确定按键状态，也可以输出0和1来控制LED。即使是看起来不太0和1的PWM，好像可以输出0到5V之间的电压一样，达到0和1之间的效果，但本质上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/12169442.html</dc:identifier>
</item>
<item>
<title>认清自我，不在迷茫！2019个人年终总结！ - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/12174112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/12174112.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;又到了年度总结的时间段，按照去年所希望的，今年的我也将继续写下今年的年终总结！本篇总结主要是讲述今年做的事、得到的收获和人生感悟！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;今年事件&quot;&gt;今年事件&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在工作中:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;今年在工作上从某种方面来说很成功，在部门中是核心人员，负责技术选型、方案设计、框架整合、规范制定、文档编写、代码审查等，今年开始也负责带新人了，当然，有此地位并不是个人很厉害的原因，而是&lt;strong&gt;山中无老虎，猴子当大王！&lt;/strong&gt;&lt;br/&gt;O__O &quot;… 所以在部门中编写的文档以及编写的一些代码成为了新员工的参考对象，新项目基本是按照我所写的那一套示例在执行。&lt;br/&gt;今年开始带新人了，总体而言还算不错，后面基本都可以独自处理自己的事情了，不过有的地方因为经验欠缺问题，因为时间紧迫，就有点过度的去帮助新员工了，导致后续过程中形成依赖了，对双方来说都不好配，好在后续意识到了，&lt;strong&gt;授人鱼不如授人以渔&lt;/strong&gt;，最后还是成长起来了。&lt;br/&gt;今年在公司使用Kafka+ElasticSearch技术处理月活百亿级的数据，其中关于技术选型、集群规划到方案设计和开发基本是由个人独立负责，这个算人生中第一个月活百亿级的项目了，想想还有点小激动 .&lt;code&gt;~_~&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;在社区中:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要是在博客园、CSDN、掘金、黑客派、GitHub等技术社区这块:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编写了SpringCloud系列的博客和几篇SpringBoot整合系列的博客，依旧将这些博客中讲到的项目放到GitHub进行了开源；&lt;/li&gt;
&lt;li&gt;在GitHub上面主要维护了&lt;a href=&quot;https://github.com/xuwujing/java-study&quot;&gt;java-study&lt;/a&gt;、&lt;a href=&quot;https://github.com/xuwujing/springBoot-study&quot;&gt;springBoot-study&lt;/a&gt;、&lt;a href=&quot;https://github.com/xuwujing/springcloud-study&quot;&gt;springcloud-study&lt;/a&gt;这几个项目，这几个项目的star累计已过千；&lt;/li&gt;
&lt;li&gt;有20多篇的博文访问量破万了；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然上面的成绩对于大佬来说没什么，但是对于本人来说还是有不少的鼓励作用，起码写的博文，开源的项目能够确切的帮助到一些人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200107215046610.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200107215108558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;看了一些技术电子书籍，、&amp;lt;分布式服务框架原理与实践&amp;gt;、&amp;lt;每天5分钟玩转Docker容器技术&amp;gt;，但是只是看了而已，在工作中用到的时候才会去查看 ;&lt;/li&gt;
&lt;li&gt;看了几本非技术书籍，&amp;lt;红与黑&amp;gt;、&amp;lt;活着&amp;gt;、&amp;lt;:平凡的世界&amp;gt;，&amp;lt;活着&amp;gt;是我这么多年看的书籍中影响最深的一本，刚看完的时候有点抑郁，觉得过于悲惨，但后来仔细品味，又发现了另一种感受，人活着本身就是为了活着而活着，活下去就是最好的人生；&lt;/li&gt;
&lt;li&gt;看了不少的的电影和电视剧，&amp;lt;流浪地球&amp;gt;、&amp;lt;驯龙高手3&amp;gt;、&amp;lt;哪吒&amp;gt;、&amp;lt;罗小黑战记&amp;gt;、&amp;lt;我和我的祖国&amp;gt;等， &amp;lt;哪吒&amp;gt;是今年感觉最燃的， &amp;lt;驯龙高手3&amp;gt;是感觉最有情怀的，很喜欢这样的电影， 而&amp;lt;罗小黑战记&amp;gt;是看完感觉最舒适的，无论是配色还是音乐，都特别的舒适；&lt;/li&gt;
&lt;li&gt;将去年的每天1万步当做了习惯了，已经不用刻意去达成了；&lt;/li&gt;
&lt;li&gt;因加班长胖了5斤，立志减肥，一个月减了10斤;&lt;/li&gt;
&lt;li&gt;坚持保护牙齿，饭后漱口，每年洗牙；&lt;/li&gt;
&lt;li&gt;坚持保护眼睛，佩戴蓝光眼镜、电子产品开启护眼模式；&lt;/li&gt;
&lt;li&gt;坚持保护颈椎和手指，多运动；&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;今年算上重要事件的就是有了房贷了，不能任性了。。。&lt;br/&gt;相比去年而言，今年个人为人处世有了一些改变，对待工作和对待生活有了不同的态度，虽然可能有些王婆卖瓜，自卖自夸，但是对待工作，个人还是很认真负责、可靠、自律、沟通闭环。。。等等&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对待工作：可靠、&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;今年有点意思的就是，在某时间内发现一串神秘数字，或许这早已暗示着什么了 &lt;code&gt;~ _~&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200107220600202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200107220612460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;去年的目标完成情况&quot;&gt;去年的目标完成情况&lt;/h2&gt;
&lt;p&gt;去年的目标:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200107224316821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly94dXd1amluZy5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;去年未定的目标基本有一些是已经养成了习惯，不自觉的就完成了，但是还是有不少没有坚持下来，比如每周一篇博客，今年也才写了20篇左右，相比去年少了一半，质量也没多大提升，每月坚持户外运动，也依旧没有每月达成。至于实际的目标，可以非常明确的说，没有完成，今年总体而言过得也不开心，也没有有喜欢做的事情和喜欢的人， 原因无在时间不够、变懒了。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;时间不够主要还是因为工作，今年工作占比有点过高了，已经非常的影响生活了，加班变多了，上半年相对于还好，一个月一般也就一个周末加下班，也就是995和996轮换，但是到了下半年，慢慢的996开始了，从9月份到12月份，双休很难见到了，在双十一这两个礼拜内，变成了997，半个月午休，不过好在熬过来了，没有猝死 ε(┬┬﹏┬┬)，工作量也变大很多了，因为很多事情部门中只有我能去做。今年工作已经侵占生活太多时间了，除了加班外，休息的时候也不得不远程工作，有时出门但是因为一番电话又不得不回来加班处理， 有时即使下班了还因为事情的情况不得不折返回去加班。还有几次，时间特别紧急，只能快马加鞭的赶，还好最后是做出来了，只不过做完之后手特别的的酸痛，那几天都不想再碰键盘了。。。&lt;br/&gt;很多时候想做一件事情，但是因为工作而不得不放弃，好不容易有了休息时间就会额外的珍惜这段时间，在这段时间中什么都不想做，因此导致很多都没完成，这也导致累，不开心￣へ￣，也没时间去做自己想做的事情。比如今年的年终总结本来在2019年12月份就可以写完的，但是硬生生的拖到了2020年1月份了。&lt;br/&gt;当然上述的依旧是&quot;借口&quot;，最主要的原因还是自己毅力不足，没有去做、没有坚持去做、没有努力坚持去做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;感悟&quot;&gt;感悟&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;2019年总体而言过于平淡，在这一年中并没有留下一些特别的回忆，一眨眼就过去了-_-!&lt;br/&gt;在这一年中，除了工作上的事情，其他很多想做的事情都没有完成，比如锻炼出一副好身体，还有一些在脑海里的想法也没去实现，比如学习下黑客相关的知识，但最后&lt;strong&gt;因种种原因&lt;/strong&gt;，好像什么都没做到....&lt;br/&gt;在这一年中，感到过很多次的迷茫，因工作时间占比过长而对现在工作的目的而迷茫，因重复工作疲倦而无法得到明显的成长而感到迷茫，因各种新技术层出不穷而无法快速学习掌握焦虑而对未来工作迷茫，因看到IT新闻某某员工和公司之间官司而对未来前景感到迷茫， 因内向不善于交际无法改变而对自我产生怀疑而迷茫。。。&lt;br/&gt;在这一年的最后一段时间中，对自我整年的情况进行了思考，也慢慢的认清了自我。我本是一个普通的程序员，没有高学历，也没有过人的才能， 算得上不错的只有自我认知，知道自己能做什么，什么能做到，比如拥有不错的学习能力，能够快速的学习和掌握，对待短期的事物可以制定一个小目标基本能够完成， 相对的也没有持久的毅力，对长期的事件无法坚持下去；拥有不错的字面沟通能力，也就是在聊天软件上沟通得得心应手，相对的在人与人之间的交流就有点相形见拙了；在工作中认真负责、可靠自律，但是在生活中对待自己就有点随意了；实战经验不错，无论是在工作和生活中，可以很快掌握，但理论知识却不行，很多事知其然不知其所以然；解决问题能力不错，在工作中遇到过很多问题，但只要我接触的，基本都已解决，不过有点奇怪的是很多解决思路在梦中O__O &quot;…&lt;br/&gt;回顾过去，我所追求的不过是在世活好每一天而已，每一天力求过得开心而已。今年说实话，过得很不开心，去年也是，但去年起码收获了不少，可以感觉明显的进步，但今年除了工资多了一点之外，实际并没有多少的进步，当然这也和我自己的情况有关，因为工作忙碌，导致有一段时间错误的认为自己很重要，有点安逸，在下班之后给自己休息娱乐找借口， 但是后想想以及和一位大佬交流，发觉自己这种想法有点过于危险了，这样容易让自己原地踏步，无法上进，最终身陷泥沼不得返。&lt;br/&gt;因此，从2020年开始，我对自己必须要有两个要求，第一、活好每一天；第二、坚持学习；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今年的一些感悟如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间会流逝，但记忆还在，所以把这些你经历过的记录下来吧！&lt;/li&gt;
&lt;li&gt;人所做的一切，其实都只是为了能让自己安心罢了！&lt;/li&gt;
&lt;li&gt;人生是没有意义，来世走一趟过好自己的人生即可！&lt;/li&gt;
&lt;li&gt;如果今天的努力不能让明天的自己过得更好，那么没有必要让自己这么累，活得轻松一点，开心一点就好！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实今年的感悟有很多，但是因为种种原因，还是没有写下来，脑子里每天想得很多，但是相要写的时候却总是怎么也写不出来。。。&lt;/p&gt;
&lt;h2 id=&quot;明年的目标&quot;&gt;明年的目标&lt;/h2&gt;
&lt;p&gt;去年的目标定得有些过于含糊了，今年的目标就简单具体一些吧。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;拾起自己坚持6年写日记的习惯，每周在记事本写一篇日记；&lt;/li&gt;
&lt;li&gt;拾起自己坚持10年早起的习惯，每天在6点半之前起床；&lt;/li&gt;
&lt;li&gt;每月一天远离手机、电脑；&lt;/li&gt;
&lt;li&gt;每月一天沉浸做自己喜欢做的事情；&lt;/li&gt;
&lt;li&gt;依旧坚持写年度总结；&lt;/li&gt;
&lt;li&gt;明年的这个时候评价一下去年的自己；&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;相关文章推荐:&lt;/p&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;
&lt;p&gt;推荐一首非常舒适的音乐，听着这首音乐，感觉就像在躺着夏天夜晚的草地上，夏虫语冰、微风吹拂，惬意的看着天上的星星~&lt;/p&gt;

&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：&lt;a href=&quot;http://www.cnblogs.com/xuwujing&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xuwujing&lt;/a&gt;&lt;br/&gt;CSDN出处：&lt;a href=&quot;http://blog.csdn.net/qazwsxpcm&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qazwsxpcm&lt;/a&gt;　　　　&lt;br/&gt;掘金出处：&lt;a href=&quot;https://juejin.im/user/5ae45d5bf265da0b8a6761e4&quot; class=&quot;uri&quot;&gt;https://juejin.im/user/5ae45d5bf265da0b8a6761e4&lt;/a&gt;&lt;br/&gt;个人博客出处：&lt;a href=&quot;http://www.panchengming.com&quot; class=&quot;uri&quot;&gt;http://www.panchengming.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Jan 2020 15:54:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 又到了年度总结的时间段，按照去年所希望的，今年的我也将继续写下今年的年终总结！本篇总结主要是讲述今年做的事、得到的收获和人生感悟！ 今年事件 在工作中: 今年在工作上从某种方面来说很成功，在部门</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuwujing/p/12174112.html</dc:identifier>
</item>
<item>
<title>探究Dubbo的拓展机制: 上 - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/12174031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/12174031.html</guid>
<description>&lt;p&gt;&lt;strong&gt;这篇博文是我决心深度学习Dubbo框架时记录的笔记, 主题是Dubbo的拓展点, 下面的几个部分相对来说比较零散, 貌似是不和主题挂钩的 , 并且是一些很冷门的知识点 , 但是它们确实是深入学习Dubbo的前置知识&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;知识储备一-dubbo的架构图&quot;&gt;知识储备一: Dubbo的架构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/202001/1496926-20200109221335274-1530251735.png&quot; alt=&quot;architecture&quot;/&gt;&lt;/p&gt;
&lt;p&gt;细化一下上图的各个组成部分:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;服务提供者&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;提供服务接口的实现类&lt;/li&gt;
&lt;li&gt;注册服务 (远程注册, 本地注册)&lt;/li&gt;
&lt;li&gt;对外暴露服务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注册中心&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;保存 服务名称&amp;amp;服务地址 的映射关系&lt;/li&gt;
&lt;li&gt;当服务地址发生变动时, 主动通知消费者&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务消费者&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;启动时从注册中心拉取服务提供者的地址, 缓存在本地&lt;/li&gt;
&lt;li&gt;根据负载均衡策略选出一个服务进行远程调用 (Dubbo会将下面的信息封装成对象通过网络发送给服务提供者)
&lt;ul&gt;&lt;li&gt;参数1: 接口名&lt;/li&gt;
&lt;li&gt;参数2: 方法名&lt;/li&gt;
&lt;li&gt;参数3: 参数列表类型&lt;/li&gt;
&lt;li&gt;参数4: 参数值列表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控中心&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;统计RPC过程的细节数据, 如: 服务调用次数, 调用时间&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;知识储备二-dubbo中的核心概念&quot;&gt;知识储备二: Dubbo中的核心概念&lt;/h2&gt;
&lt;h3 id=&quot;url&quot;&gt;URL&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Dubbo自己有个封装类叫URL&lt;/strong&gt;如下: URL: 全称 Uniform Resources Loactor 统一资源定位符, &lt;strong&gt;它是不可变的, 也是线程安全的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/202001/1496926-20200109221334811-476508255.png&quot; alt=&quot;url&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;URL的作用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;其实, Dubbo它作为一款RPC通信框架, 主体功能就是负责在服务集群中各个点之间进行数据的传递, 打个例子比如: 服务消费者调用服务的提供者，这个过程中的通信是Dubbo框架实现的, 通信的格式就好比自定义协议一样, Dubbo将服务提供者和服务消费者两种之间进行数据传递 需要的协议信息/ 端口号信息/ 请求那个接口 / 参数信息 / 账号 / 密码信息. 等一系列的信息进行封装,于是上图中的 URL 诞生了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对URL的理解&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;&lt;strong&gt;对URL最直观的理解: URL是dobbo 对一系列数据的封装, 方便代码的编写, 参数的传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多人也将URL称为Dubbo的消息总线, 说URL贯穿于Dubbo的上下文, 我感觉到这个结论也许是这样得出的, 就是说 Dubbo作为一款RPC框架, 首要的任务就是 RPC 远程过程调用, 怎么样找到提供服务的机器呢? 无论是发起socket 还是借助Thrift或者Netty这种框架实现也罢, 前提是得知道提供服务的机器在哪里, 它的哪些接口对外暴露服务 , 没错! 这些信息都被Dubbo封装在了URL中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;URL常见的组成&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;protobuf - 协议信息, 如 zk / Dubbo / http / Thrift&lt;/li&gt;
&lt;li&gt;host/port - 目标主机端口信息&lt;/li&gt;
&lt;li&gt;path - 接口的名称&lt;/li&gt;
&lt;li&gt;parameters - 参数键值对信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;典型的Dubbo URL格式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;# 描述 Dubbo 协议的服务
Dubbo://192.168.1.6:20880/moe.cnkirito.sample.HelloService?timeout=3000

# 描述 zookeeper 注册中心
zookeeper://127.0.0.1:2181/org.apache.Dubbo.registry.RegistryService?application=demo-consumer&amp;amp;Dubbo=2.0.2&amp;amp;interface=org.apache.Dubbo.registry.RegistryService&amp;amp;pid=1214&amp;amp;qos.port=33333&amp;amp;timestamp=1545721981946

# 描述消费者 服务
consumer://30.5.120.217/org.apache.Dubbo.demo.DemoService?application=demo-consumer&amp;amp;category=consumers&amp;amp;check=false&amp;amp;Dubbo=2.0.2&amp;amp;interface=org.apache.Dubbo.demo.DemoService&amp;amp;methods=sayHello&amp;amp;pid=1209&amp;amp;qos.port=33333&amp;amp;side=consumer&amp;amp;timestamp=1545721827784

# for this case, url protocol = null, url host = 192.168.1.3, port = 20880, url path = null
192.168.1.3:20880

# for this case, url protocol = file, url host = null, url path = home/user1/router.js
file:///home/user1/router.js?type=script

... 更多参照URL源码&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;invoker&quot;&gt;Invoker&lt;/h3&gt;
&lt;p&gt;invoker 直译调用者&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在服务提供方: invoker 对象被构造出来去调用提供服务的函数&lt;/li&gt;
&lt;li&gt;在服务的消费方: invoker用于调用 执行远程过程调用的类&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;invocation&quot;&gt;Invocation&lt;/h3&gt;
&lt;p&gt;指代程序中的调用对象, 包含了 接口名 / 方法名 / 参数类型列表 / 参数值列表 等&lt;/p&gt;
&lt;h2 id=&quot;知识储备三-java-spi-service-provider-interface&quot;&gt;知识储备三: Java SPI (Service Provider Interface )&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;怎么理解SPI机制呢?&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;如果说SPI是java提供的一种拓展机制, 其实是不明确的, 结合java本身的语言特性来说, SPI直观的看就是 基于接口的编程 + 策略模式 + 配置文件 组合实现的动态加载机制, 用大白话解释就是说, 一个框架的设计为了后期的拓展性, 肯定先会在顶层设计接口, 然后再为这些接口提供一些默认的实现类, 未了良好的拓展性, 如果想让, 如果想实现允许当前框架 识别 / 加载 / 使用 第三方提供的jar包时 , 就可以使用SPI实现接口的动态加载, 只要遵循SPI的规范, java就能将我们自己的类也加载进JVM供我们使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;说起来总归是模糊的, 看下面的小Demo自然就懂了&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 接口
public interface Person {
    String getName();
}
// 实现类一: 
public class Student implements Person {
    @Override
    public String getName() {
        return &quot;Student&quot;;
    }
}
//  实现类二: 
public class Teacher implements Person {
    @Override
    public String getName() {
        return &quot;Teacher&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;strong&gt;resource/META-INF/services/&lt;/strong&gt; 目录下面添加配置文件, 文件名称为 Person接口的全限定名, 内容如下&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;com.changwu.javaspi.api.Student
com.changwu.javaspi.api.Teacher&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试程序:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        // 加载接口中的实现类
        ServiceLoader&amp;lt;Person&amp;gt; load = ServiceLoader.load(Person.class);
        Iterator&amp;lt;Person&amp;gt; iterator = load.iterator();
        while (iterator.hasNext()){
            Person next = iterator.next();
            System.out.println(next.getName());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果控制台输出如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Student
Teacher&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dubbo-spi&quot;&gt;Dubbo SPI&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Dubbo自己也封装了一套SPI机制, 并将此作为它的扩展点,如果我们有更好的想法, 可以使用Dubbo这个特性加将我们自己的类注入给Dubbo&lt;/strong&gt;, 它用法和JDK原生的SPI相似, 不同点在哪里呢? Dubbo的更强大, 比如相对于JDK的SPI , 它支持根据名称获取出指定的拓展类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个小demo&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接口如下 , 注意点 Dubbo的SPI需要在接口上标注注解 @SPI&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SPI
public interface PersonInterface {
   String getName();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;两个实现类&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Student implements PersonInterface {
    @Override
    public String getName() {
        return &quot;Student&quot;;
    }
}

public class Teacher implements PersonInterface {
    @Override
    public String getName() {
        return &quot;Teacher&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/202001/1496926-20200109221334289-2097554711.png&quot; alt=&quot;配置文件&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试类 &lt;strong&gt;可以根据名称明确指出使用哪一个实现类&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        // todo 第一点:  Dubbo 的SPI算作是他的一个可扩展的机制
        ExtensionLoader&amp;lt;PersonInterface&amp;gt; extensionLoader = ExtensionLoader.getExtensionLoader(PersonInterface.class);
        PersonInterface carInterface = extensionLoader.getExtension(&quot;student&quot;);
        System.out.println(carInterface.getName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dubbo-ioc&quot;&gt;Dubbo IOC&lt;/h2&gt;
&lt;p&gt;Spring 的IOC肯定是鼎鼎大名的, 很直接的能想到Spring的 @Autowired 注解, 或者的配置文件版本的 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt;标签中可以帮我们自动维护bean之间的相互的依赖的关系&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dubbo 也实现了自己的IOC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如下面的代码这样: Human.java 中依赖了 PersonInterface 类型的对象, 打眼看上去, 这个对象肯定是借助我们提供的setter方法完成的注入&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Human implements PersonInterface {

    private PersonInterface carInterface;

    //todo 第一个关注点: 我们的关注点就是说, BeazCar 会帮我们将哪一个实现类当成入参注入进来呢?
    //todo 答案是 URL ，Dubbo自己封装的URL,  统一资源定位符, Dubbo 会解析入参位置的 url中封装的map
    //todo map中的key 与 CarInteface中的使用   @Adaptive(&quot;car&quot;) 注解标记的value对应, 那么值就是将要注入的实际类型
    //todo 第二个关注点: Dubbo底层很可能是通过反射使用构造方法完成的属性注入
    public void setCarInterface(PersonInterface carInterface) {
        this.carInterface = carInterface;
    }

    @Override
    public String getColor(URL url) {
        System.out.println(&quot;i am Human &quot;);
        return &quot;i am Human + &quot; + carInterface.getColor(url);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;那么问题来了, 假如我们在配置文件中添加了多个&lt;code&gt;PersonInterface&lt;/code&gt;接口的实现类, 那Dubbo是如何得知需要注入哪一个的呢? 答案就在入参位置的URL中, 也就是我在 知识储备二中提到的概念URL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以看下面这段测试代码, 怎么读下面的这段代码呢?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单独看 &lt;code&gt;(PersonInterface) extensionLoader.getExtension(&quot;human&quot;);&lt;/code&gt; 其实就是前面所说的 Dubbo的SPI机制, 但是在这个基础上多出来的逻辑是啥呢? 是我们构建了一个URL, 那为什么加进去一个URL? 因为上面的示例代码说了, human依赖了一个 PersonInterface 类型的变量, Dubbo就是根据这个URL变量, 进而得知自己到底该该注入哪一个变量Personinterface实例的 (因为我提供了两个 一个是Student , 另一个是Teacher)&lt;/p&gt;
&lt;p&gt;此外, 他需要的是map , 我们给它的也是一个hashmap , 特性就是HashMap的key是不重复的, 用大白话说, 它的底层肯定是 key=value 唯一绑定, 并且key也不会出现重复的情况&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {
    public static void main(String[] args) {
        // todo 源码的入口, 进入 getExtensionLoader()
        ExtensionLoader extensionLoader = ExtensionLoader.getExtensionLoader(PersonInterface.class);
        HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&quot;human&quot;, &quot;student&quot;);
        URL url = new URL(&quot;&quot;, &quot;&quot;,1,map);
        // todo 继续跟进这个方法
        PersonInterface carInterface = (PersonInterface) extensionLoader.getExtension(&quot;human&quot;);
        System.out.println(carInterface.getName(url));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;那说了这么多, 到底注入的是哪一个对象呢? 从&lt;code&gt;map.put(&quot;human&quot;, &quot;student&quot;);&lt;/code&gt; 也能很清楚的看出来, 不就是Student吗? 是的, 确实是它, 但是还少了点东西, 就是Personinterface怎么编写呢? 如下:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// @SPI(&quot;stu&quot;) 可以给注解添加参数, 参数表示 CarInterface 的默认实现类
@SPI
public interface PersonInterface {
    // todo 下面的注解很重要, 啥意思呢?  可以点进这个注解, 我有一些翻译
    // 验证AOP, 依然注入的信息从 url中获取出来
    @Adaptive(&quot;human&quot;)
    String getName(URL url);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上面的代码, 除了@SPI注解, 还有一个注解就是@Adaptive注解, 这个注解的value部分决定了Dubbo到底需要注入哪一个 ExtensionObject&lt;/p&gt;
&lt;p&gt;因为Dubbo在启动的过程中会去读取/META-INF/services/ Dubbo-SPI配置文件, 并将每行数据读取维护在一个map中, key就是我们自定义的名字, 值就是左边的全类名&lt;/p&gt;
&lt;p&gt;看下面我们传递进去的是 human , 表示告诉Dubbo, 让Dubbo拿着human去查找, 很显然Dubbo把我们前面传递给它的&lt;code&gt;student&lt;/code&gt; 找出来, 有了Student 进一步再从上下文中所有的 ExtensionObject中(包含了我们在配置文件中添加进去的Personinterface的两个实现) 找到具体的注入对象&lt;/p&gt;
&lt;h2 id=&quot;dubbo-aop&quot;&gt;Dubbo AOP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;还是说, AOP是面向切面编程的思想, Spring自己实现了一套, Dubbo 也实现了一套&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;验证Dubbo的AOP实现类如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Dubbo的AOP增强实现和静态代理的编码方式相似, 比如我们就增强 PersonInterface中的方法, 所以我们继承PersonInterface, 提供构造方法入, 留给Dubbo通过反射完成指定目标对象的注入, 并在注入进来的目标对象的目标方法前后植入增强的逻辑&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PersonWrapper implements PersonInterface {

    // todo 验证Dubbo的自动注入
    private PersonInterface carInterface;
    // todo 根据构造方法进行注入
    public PersonWrapper(PersonInterface in){ // 假设传递进来的就是具体的实现类
        this.carInterface=in;
    }

    // todo 当我们将 CarWrapper 配置进 Dubbo的 spi中时, 通过Dubbo的Spi获取CarInterface执行时,下面的方法就会被执行
    @Override
    public String getName() {
        System.out.println(&quot;before... &quot;);
        String color = carInterface.getName();
        System.out.println(&quot;after... &quot;);
        return &quot;getName&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;那如何让Dubbo知道包含我们增强逻辑的 PersonWrapper对象呢? 还是老样子, 通过配置文件完成, 如下:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496926/202001/1496926-20200109221333581-1796317411.png&quot; alt=&quot;配置文件2&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试如下:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
        // todo 第一点:  Dubbo 的SPI算作是他的一个可扩展的机制
        ExtensionLoader&amp;lt;PersonInterface&amp;gt; extensionLoader = ExtensionLoader.getExtensionLoader(PersonInterface.class);
        PersonInterface carInterface = extensionLoader.getExtension(&quot;student&quot;);
        System.out.println(carInterface.getName());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;before...
after...
getName  &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;如过存在多个AOP增强类, 比如从上到下出现的顺序是 w1 w2 ... 那么增强的逻辑添加顺序是 before2 before1&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语:&lt;/h2&gt;
&lt;p&gt;​下一篇博文就是探究Dubbo的这些拓展点的底层实现细节了 , 还是挺带劲的...&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;最后打一个小广告: 我是bloger 赐我白日梦, 本科大三在读, 热衷java研发, 期望有一份Java相关实习岗位的工作, 可以全职实习半年左右, 最理想城市是北京, 求大佬的内推哇&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 09 Jan 2020 15:28:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>这篇博文是我决心深度学习Dubbo框架时记录的笔记, 主题是Dubbo的拓展点, 下面的几个部分相对来说比较零散, 貌似是不和主题挂钩的 , 并且是一些很冷门的知识点 , 但是它们确实是深入学习Dub</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/12174031.html</dc:identifier>
</item>
<item>
<title>VMware上安装Kali Linux 超详细教程 - 暮良文王</title>
<link>http://www.cnblogs.com/liangmingshen/p/12173769.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangmingshen/p/12173769.html</guid>
<description>&lt;h2 id=&quot;二安装&quot;&gt;一、下载镜像文件&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下载好系统对应镜像文件  &lt;a href=&quot;https://www.kali.org/downloads/&quot; rel=&quot;nofollow&quot;&gt;https://www.kali.org/downloads/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;二安装&quot;&gt;二、创建新的虚拟机&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1、&lt;/span&gt;&lt;span&gt;创建新的虚拟机 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们使用自定义的配置方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109221052211-1393271513.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、添加镜像文件的路径 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109221222470-1319628811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、选择系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109221541935-663138935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.输入虚拟机的名称和安装位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109221636104-561919416.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5、处理器配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109221748983-273810629.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6、内存分配&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建议不要超过提示的最大推荐内存，这里分配2GB。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109221835516-2043576837.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、添加网络&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109221958592-1311844393.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8、继续点击下一步，使用&lt;span&gt;推荐&lt;/span&gt;选项，直至出现&lt;span&gt;磁盘容量分配&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一定要比建议分配容量大！一定要比建议分配容量大！一定要比建议分配容量大！否则后面安装时会卡在奇怪的地方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择将虚拟磁盘存储为单个文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109222313598-1397142304.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9、完成虚拟机的创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109222441774-637322262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;二安装&quot;&gt;三、安装Kali Linux&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1、&lt;/span&gt;&lt;span&gt;开启虚拟机，进入安装界面，选择图形界面安装（Graphical install）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109222702422-1017505886.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、自定义主机名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109223223456-44589056.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、设置密码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109223326958-1809722841.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4、磁盘分区，使用整个磁盘&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109223506659-1900238318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109223600400-769855710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5、写入磁盘&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109223656591-1716335668.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109223712709-1363796644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;6、等待系统安装（时间较长，要耐心嗷）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果配置虚拟机时分配磁盘空间不足，这个时候可能会卡死。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109224604585-36989039.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;7、将GRUB安装至硬盘&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109225100359-575278408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;8、这里一定一定一定 选第二个！！ 不然之后会安装失败&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1337485/202001/1337485-20200109230033422-1741102575.png&quot; alt=&quot;&quot; width=&quot;980&quot; height=&quot;599&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 9、大功告成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109230832113-1965624476.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;10、重启虚拟机后进入系统，输入用户名和密码，用户名默认为root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1337485/202001/1337485-20200109231553151-956454987.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Jan 2020 15:17:00 +0000</pubDate>
<dc:creator>暮良文王</dc:creator>
<og:description>一、下载镜像文件 下载好系统对应镜像文件 https://www.kali.org/downloads/ 二、创建新的虚拟机 1、创建新的虚拟机 我们使用自定义的配置方法。 2、添加镜像文件的路径 3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liangmingshen/p/12173769.html</dc:identifier>
</item>
</channel>
</rss>