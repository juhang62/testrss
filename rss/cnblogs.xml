<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>关于面向对象和面向过程本质的区别（个人感悟） - 风好大呀</title>
<link>http://www.cnblogs.com/pylearner/p/10903266.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pylearner/p/10903266.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　接触面向对象的概念也差不多两年了，对于面向对象也有着自己的一些感悟，期间也看到过面向过程的一些文章，但总是对于两种思想没有明确的区别概念，刚好今天在某篇博客上看到对于两者的区别。所以便写下这篇博客来记录下感悟。&lt;/p&gt;

&lt;p&gt;一、面向对象的特点&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;strong&gt;&lt;span&gt;什么是对象，简单来说对象就是现实世界存在的任何事务都可以称之为对象，有着自己独特的个性。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;          &lt;span&gt;用思维导图来简洁表示一下就是这样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1639419/201905/1639419-20190521230506419-1855150581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;面向对象就是构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;二、面向过程的特点&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;什么是过程，我认为过程就是步骤，是解决问题的按部就班。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  面向过程用图片表示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1639419/201905/1639419-20190521231748531-554450079.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　面向过程不同于面向对象，面向过程分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 三、面向对象和面向工程的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　之前在那篇博客上看到这个比喻，觉得特别恰当，挺容易让人理解的，现在分享一下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;用面向过程的方法写出来的程序是一份蛋炒饭，而用面向对象写出来的程序是一份盖浇饭。所谓盖浇饭，北京叫盖饭，东北叫烩饭，广东叫碟头饭，就是在一碗白米饭上面浇上一份盖菜，你喜欢什么菜，你就浇上什么菜。我觉得这个比喻还是比较贴切的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　蛋炒饭制作的细节，我不太清楚，因为我没当过厨师，也不会做饭，但最后的一道工序肯定是把米饭和鸡蛋混在一起炒匀。盖浇饭呢，则是把米饭和盖菜分别做好，你如果要一份红烧肉盖饭呢，就给你浇一份红烧肉；如果要一份青椒土豆盖浇饭，就给浇一份青椒土豆丝。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　蛋炒饭的好处就是入味均匀，吃起来香。如果恰巧你不爱吃鸡蛋，只爱吃青菜的话，那么唯一的办法就是全部倒掉，重新做一份青菜炒饭了。盖浇饭就没这么多麻烦，你只需要把上面的盖菜拨掉，更换一份盖菜就可以了。盖浇饭的缺点是入味不均，可能没有蛋炒饭那么香。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　到底是蛋炒饭好还是盖浇饭好呢？其实这类问题都很难回答，非要比个上下高低的话，就必须设定一个场景，否则只能说是各有所长。如果大家都不是美食家，没那么多讲究，那么从饭馆角度来讲的话，做盖浇饭显然比蛋炒饭更有优势，他可以组合出来任意多的组合，而且不会浪费。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　盖浇饭的好处就是”菜”“饭”分离，从而提高了制作盖浇饭的灵活性。饭不满意就换饭，菜不满意换菜。用软件工程的专业术语就是”可维护性“比较好，”饭” 和”菜”的耦合度比较低。蛋炒饭将”蛋”“饭”搅和在一起，想换”蛋”“饭”中任何一种都很困难，耦合度很高，以至于”可维护性”比较差。软件工程追求的目标之一就是可维护性，可维护性主要表现在3个方面：可理解性、可测试性和可修改性。面向对象的好处之一就是显著的改善了软件系统的可维护性。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　面向过程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　　　缺点：没有面向对象易维护、易复用、易扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　面向对象：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 &lt;br/&gt;　　　　缺点：性能比面向过程低&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 21 May 2019 15:37:00 +0000</pubDate>
<dc:creator>风好大呀</dc:creator>
<og:description>前言： 接触面向对象的概念也差不多两年了，对于面向对象也有着自己的一些感悟，期间也看到过面向过程的一些文章，但总是对于两种思想没有明确的区别概念，刚好今天在某篇博客上看到对于两者的区别。所以便写下这篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pylearner/p/10903266.html</dc:identifier>
</item>
<item>
<title>如何优雅地停止Java进程 - 2Simple</title>
<link>http://www.cnblogs.com/nuccch/p/10903162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nuccch/p/10903162.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;h2 id=&quot;理解停止java进程的本质&quot;&gt;理解停止Java进程的本质&lt;/h2&gt;
&lt;p&gt;我们知道，Java程序的运行需要一个运行时环境，即：JVM，启动Java进程即启动了一个JVM。&lt;br/&gt;因此，所谓停止Java进程，本质上就是关闭JVM。&lt;br/&gt;那么，哪些情况会导致JVM关闭呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201905/722072-20190521232151642-1040297586.png&quot; alt=&quot;JVM关闭&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;应该如何正确地停止java进程&quot;&gt;应该如何正确地停止Java进程&lt;/h2&gt;
&lt;p&gt;通常来讲，停止一个进程只需要杀死进程即可。&lt;br/&gt;但是，在某些情况下可能需要在JVM关闭之前执行一些数据保存或者资源释放的工作，此时就不能直接强制杀死Java进程。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对于正常关闭或异常关闭的几种情况，JVM关闭前，都会调用已注册的关闭钩子，基于这种机制，我们可以将扫尾的工作放在关闭钩子中，进而使我们的应用程序安全的退出。而且，基于平台通用性的考虑，更推荐应用程序使用System.exit(0)这种方式退出JVM。&lt;/li&gt;
&lt;li&gt;对于强制关闭的几种情况：&lt;code&gt;系统关机&lt;/code&gt;，操作系统会通知JVM进程等待关闭，一旦等待超时，系统会强制中止JVM进程；而&lt;code&gt;kill -9&lt;/code&gt;、&lt;code&gt;Runtime.halt()&lt;/code&gt;、&lt;code&gt;断电&lt;/code&gt;、&lt;code&gt;系统crash&lt;/code&gt;这些方式会直接无商量中止JVM进程，JVM完全没有执行扫尾工作的机会。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;综上所述：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;除非非常确定不需要在Java进程退出之前执行收尾的工作，否则强烈不建议使用&lt;code&gt;kill -9&lt;/code&gt;这种简单暴力的方式强制停止Java进程（除了&lt;code&gt;系统关机&lt;/code&gt;，&lt;code&gt;系统Crash&lt;/code&gt;，&lt;code&gt;断电&lt;/code&gt;，和&lt;code&gt;Runtime.halt()&lt;/code&gt;我们无能为力之外）。&lt;/li&gt;
&lt;li&gt;不论如何，都应该在Java进程中注册关闭钩子，尽最大可能地保证在Java进程退出之前做一些善后的事情（实际上，大多数时候都需要这样做）。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;如何注册关闭钩子&quot;&gt;如何注册关闭钩子&lt;/h3&gt;
&lt;p&gt;在Java中注册关闭钩子通过Runtime类实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override
    public void run() {
        // 在JVM关闭之前执行收尾工作
        // 注意事项：
        // 1.在这里执行的动作不能耗时太久
        // 2.不能在这里再执行注册，移除关闭钩子的操作
        // 3 不能在这里调用System.exit()
        System.out.println(&quot;do shutdown hook&quot;);
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为JVM注册关闭钩子的时机不固定，可以在启动Java进程之前，也可以在Java进程之后（如：在监听到操作系统信号量之后再注册关闭钩子也是可以的）。&lt;/p&gt;
&lt;h3 id=&quot;使用关闭钩子的注意事项&quot;&gt;使用关闭钩子的注意事项&lt;/h3&gt;
&lt;p&gt;1.关闭钩子本质上是一个线程（也称为Hook线程），对于一个JVM中注册的多个关闭钩子它们将会并发执行，所以JVM并不保证它们的执行顺序；由于是并发执行的，那么很可能因为代码不当导致出现竞态条件或死锁等问题，为了避免该问题，强烈建议只注册一个钩子并在其中执行一系列操作。&lt;br/&gt;2.Hook线程会延迟JVM的关闭时间，这就要求在编写钩子过程中必须要尽可能的减少Hook线程的执行时间，避免hook线程中出现耗时的计算、等待用户I/O等等操作。&lt;br/&gt;3.关闭钩子执行过程中可能被强制打断，比如在操作系统关机时，操作系统会等待进程停止，等待超时，进程仍未停止，操作系统会强制的杀死该进程，在这类情况下，关闭钩子在执行过程中被强制中止。&lt;br/&gt;4.在关闭钩子中，不能执行注册、移除钩子的操作，JVM将关闭钩子序列初始化完毕后，不允许再次添加或者移除已经存在的钩子，否则JVM抛出IllegalStateException异常。&lt;br/&gt;5.不能在钩子调用System.exit()，否则卡住JVM的关闭过程，但是可以调用Runtime.halt()。&lt;br/&gt;6.Hook线程中同样会抛出异常，对于未捕捉的异常，线程的默认异常处理器处理该异常（将异常信息打印到System.err），不会影响其他hook线程以及JVM正常退出。&lt;/p&gt;
&lt;h3 id=&quot;信号量机制&quot;&gt;信号量机制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/722072/201905/722072-20190521231712569-1043190647.png&quot; alt=&quot;优雅地关闭Java进程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注册关闭钩子的目的是为了在JVM关闭之前执行一些收尾的动作，而从上述描述可以知道，触发关闭钩子动作的执行需要满足JVM正常关闭或异常关闭的情形。&lt;br/&gt;显然，我们应该正常关闭JVM（异常关闭JVM的情形不希望发生，也无法百分之百地完全杜绝），即执行：&lt;code&gt;System.exit()&lt;/code&gt;，&lt;code&gt;Ctrl + C&lt;/code&gt;， &lt;code&gt;kill -15 进程ID&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;System.exit()：通常我们在程序运行完毕之后调用，这是在应用代码中写死的，无法在进程外部进行调用。&lt;/li&gt;
&lt;li&gt;Ctrl + C：如果Java进程运行在操作系统前台，可以通过键盘中断的方式结束运行；但是当进程在后台运行时，就无法通过&lt;code&gt;Ctrl + C&lt;/code&gt;方式退出了。&lt;/li&gt;
&lt;li&gt;Kill (-15)SIGTERM信号：使用kill命令结束进程是使用操作系统的信号量机制，不论进程运行在操作系统前台还是后台，都可以通过kill命令结束进程，这也是结束进程使用得最多的方式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上，大多数情况下的进程结束操作通常是在进程运行过程中需要停止进程或者重启进程，而不是等待进程自己运行结束（服务程序都是一直运行的，并不会主动结束）。也就是说，针对JVM正常关闭的情形，大多数情况是使用&lt;code&gt;kill -15 进程ID&lt;/code&gt;的方式实现的。那么，我们是否可以结合操作系统的信号量机制和JVM的关闭钩子实现优雅地关闭Java进程呢？答案是肯定的，具体实现步骤如下：&lt;/p&gt;
&lt;p&gt;第一步：在应用程序中监听信号量&lt;br/&gt;由于不通的操作系统类型实现的信号量动作存在差异，所以监听的信号量需要根据Java进程实际运行的环境而定（如：Windows使用SIGINT，Linux使用SIGTERM）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Signal sg = new Signal(&quot;TERM&quot;); // kill -15 pid
Signal.handle(sg, new SignalHandler() {
    @Override
    public void handle(Signal signal) {
        System.out.println(&quot;signal handle: &quot; + signal.getName());
        // 监听信号量，通过System.exit(0)正常关闭JVM，触发关闭钩子执行收尾工作
        System.exit(0);
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步：注册关闭钩子&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override
    public void run() {
        // 执行进程退出前的工作
        // 注意事项：
        // 1.在这里执行的动作不能耗时太久
        // 2.不能在这里再执行注册，移除关闭钩子的操作
        // 3 不能在这里调用System.exit()
        System.out.println(&quot;do something&quot;);
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ShutdownTest {
    public static void main(String[] args) {
        System.out.println(&quot;Shutdown Test&quot;);

        Signal sg = new Signal(&quot;TERM&quot;); // kill -15 pid
        // 监听信号量
        Signal.handle(sg, new SignalHandler() {
            @Override
            public void handle(Signal signal) {
                System.out.println(&quot;signal handle: &quot; + signal.getName());
                System.exit(0);
            }
        });
        // 注册关闭钩子
        Runtime.getRuntime().addShutdownHook(new Thread(){
            @Override
            public void run() {
                // 在关闭钩子中执行收尾工作
                // 注意事项：
                // 1.在这里执行的动作不能耗时太久
                // 2.不能在这里再执行注册，移除关闭钩子的操作
                // 3 不能在这里调用System.exit()
                System.out.println(&quot;do shutdown hook&quot;);
            }
        });

        mockWork();

        System.out.println(&quot;Done.&quot;);
        System.exit(0);
    }

    // 模拟进程正在运行
    private static void mockWork() {
        //mockRuntimeException();
        //mockOOM();
        try {
            Thread.sleep(120 * 1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } 
    }

    // 模拟在应用中抛出RuntimeException时会调用注册钩子
    private static void mockRuntimeException() {
        throw new RuntimeException(&quot;This is a mock runtime ex&quot;);
    }

    // 模拟应用运行出现OOM时会调用注册钩子
    // -xms10m -xmx10m
    private static void mockOOM() {
        List list = new ArrayList();
        for(int i = 0; i &amp;lt; 1000000; i++) {
            list.add(new Object());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;网上有文章总结说可以直接使用监听信号量的机制来实现优雅地关闭Java进程（详见：&lt;img src=&quot;https://blog.csdn.net/carlislelee/article/details/52688693&quot; alt=&quot;Java程序优雅关闭的两种方法&quot;/&gt;，实际上这是有问题的。因为单纯地监听信号量，并不能覆盖到异常关闭JVM的情形（如：RuntimeException或OOM），这种方式与注册关闭钩子的区别在于：&lt;br/&gt;1.关闭钩子是在独立线程中运行的，当应用进程被kill的时候main函数就已经结束了，仅会运行ShutdownHook线程中run()方法的代码。&lt;br/&gt;2.监听信号量方法中handle函数会在进程被kill时收到TERM信号，但对main函数的运行不会有任何影响，需要使用别的方式结束main函数（如：在main函数中添加布尔类型的flag，当收到TERM信号时修改该flag，程序便会正常结束；或者在handle函数中调用System.exit())。&lt;/p&gt;
&lt;p&gt;【参考】&lt;br/&gt;https://blog.csdn.net/u011001084/article/details/73480432 JVM安全退出（如何优雅的关闭java服务）&lt;br/&gt;http://yuanke52014.iteye.com/blog/2306805 Java保证程序结束时调用释放资源函数&lt;br/&gt;https://tessykandy.iteye.com/blog/2005767 基于kill信号优雅的关闭JAVA程序&lt;br/&gt;https://www.cnblogs.com/taobataoma/archive/2007/08/30/875743.html Linux 信号signal处理机制&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 15:18:00 +0000</pubDate>
<dc:creator>2Simple</dc:creator>
<og:description>目录 '理解停止Java进程的本质' '应该如何正确地停止Java进程' '如何注册关闭钩子' '使用关闭钩子的注意事项' '信号量机制' '总结' 理解停止Java进程的本质 我们知道，Java程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nuccch/p/10903162.html</dc:identifier>
</item>
<item>
<title>浅析JavaScript异步 - Aaron-攻城狮</title>
<link>http://www.cnblogs.com/aaron---blog/p/10903118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aaron---blog/p/10903118.html</guid>
<description>&lt;p&gt;一直以来都知道&lt;code&gt;JavaScript&lt;/code&gt;是一门单线程语言，在笔试过程中不断的遇到一些输出结果的问题，考量的是对异步编程掌握情况。一般被问到异步的时候脑子里第一反应就是&lt;code&gt;Ajax&lt;/code&gt;，&lt;code&gt;setTimseout&lt;/code&gt;...这些东西。在平时做项目过程中，基本大多数操作都是异步的。&lt;code&gt;JavaScript&lt;/code&gt;异步都是通过回调形式完成的，开发过程中一直在处理回调，可能不知不觉中自己就已经处在&lt;code&gt;回调地狱&lt;/code&gt;中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器线程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在开始之前简单的说一下浏览器的线程，对浏览器的作业有个基础的认识。之前说过&lt;code&gt;JavaScript&lt;/code&gt;是单线程作业，但是并不代表浏览器就是单线程的。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;JavaScript&lt;/code&gt;引擎中负责解析和执行&lt;code&gt;JavaScript&lt;/code&gt;代码的线程只有一个。但是除了这个主进程以外，还有其他很多辅助线程。那么诸如&lt;code&gt;onclick&lt;/code&gt;回调，&lt;code&gt;setTimeout&lt;/code&gt;，&lt;code&gt;Ajax&lt;/code&gt;这些都是怎么实现的呢？即浏览器搞了几个其他线程去辅助&lt;code&gt;JavaScript&lt;/code&gt;线程的运行。&lt;/p&gt;
&lt;p&gt;浏览器有很多线程，例如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;GUI渲染线程 - GUI渲染线程处于挂起状态的，也就是冻结状态&lt;/li&gt;
&lt;li&gt;JavaScript引擎线程 - 用于解析JavaScript代码&lt;/li&gt;
&lt;li&gt;定时器触发线程 - 浏览器定时计数器并不是 js引擎计数&lt;/li&gt;
&lt;li&gt;浏览器事件线程 - 用于解析BOM渲染等工作&lt;/li&gt;
&lt;li&gt;http线程 - 主要负责数据请求&lt;/li&gt;
&lt;li&gt;EventLoop轮询处理线程 - 事件被触发时该线程会把事件添加到待处理队列的队尾&lt;/li&gt;
&lt;li&gt;等等等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从上面来看可以得出，浏览器其实也做了很多事情，远远的没有想象中的那么简单，上面这些线程中&lt;code&gt;GUI渲染线程&lt;/code&gt;,&lt;code&gt;JavaScript引擎线程&lt;/code&gt;,&lt;code&gt;浏览器事件线程&lt;/code&gt;是浏览器的常驻线程。&lt;/p&gt;
&lt;p&gt;当浏览器开始解析代码的时候，会根据代码去分配给不同的辅助线程去作业。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程是指在操作系统中正在运行的一个应用程序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程是指进程内独立执行某个任务的一个单元。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)。&lt;/p&gt;
&lt;p&gt;进程中包含线程，一个进程中可以有N个进程。我们可以在电脑的任务管理器中查看到正在运行的进程，可以认为一个进程就是在运行一个程序，比如用浏览器打开一个网页，这就是开启了一个进程。但是比如打开3个浏览器，那么就开启了3个进程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同步&amp;amp;异步&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然要了解同步异步当然要简单的说一下同步和异步。说到同步和异步最有发言权的真的就属&lt;code&gt;Ajax&lt;/code&gt;了，为了让例子更加明显没有使用&lt;code&gt;Ajax&lt;/code&gt;举例。(●ˇ∀ˇ●)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步会逐行执行代码，会对后续代码造成阻塞，直至代码接收到预期的结果之后，才会继续向下执行。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;console.log(1);
alert(&quot;同步&quot;);
console.log(2);

//  结果：
//  1
//  同步
//  2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;异步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果在函数返回的时候，调用者还不能够得到预期结果，而是将来通过一定的手段得到结果（例如回调函数），这就是异步。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;console.log(1);
setTimeout(() =&amp;gt; {
   alert(&quot;异步&quot;); 
},0);
console.log(2);

//  结果：
//  1
//  2
//  异步&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么JavaScript要采用异步编程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始就说过，&lt;code&gt;JavaScript&lt;/code&gt;是一种单线程执行的脚本语言（这可能是由于历史原因或为了简单而采取的设计）。它的单线程表现在任何一个函数都要从头到尾执行完毕之后，才会执行另一个函数，界面的更新、鼠标事件的处理、计时器（&lt;code&gt;setTimeout、setInterval&lt;/code&gt;等）的执行也需要先排队，后串行执行。假如有一段&lt;code&gt;JavaScript&lt;/code&gt;从头到尾执行时间比较长，那么在执行期间任何&lt;code&gt;UI&lt;/code&gt;更新都会被阻塞，界面事件处理也会停止响应。这种情况下就需要异步编程模式，目的就是把代码的运行打散或者让&lt;code&gt;IO&lt;/code&gt;调用（例如&lt;code&gt;AJAX&lt;/code&gt;）在后台运行，让界面更新和事件处理能够及时地运行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;语言的设计者意识到，这时主线程完全可以不管&lt;code&gt;IO&lt;/code&gt;设备，挂起处于等待中的任务，先运行排在后面的任务。等到&lt;code&gt;IO&lt;/code&gt;设备返回了结果，再回过头，把挂起的任务继续执行下去。&lt;/p&gt;
&lt;p&gt;异步运行机制：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;所有同步任务都在主线程上执行，形成一个执行栈。&lt;/li&gt;
&lt;li&gt;主线程之外，还存在一个&lt;code&gt;任务队列&lt;/code&gt;。只要异步任务有了运行结果，就在&lt;code&gt;任务队列&lt;/code&gt;之中放置一个事件。&lt;/li&gt;
&lt;li&gt;一旦&lt;code&gt;执行栈&lt;/code&gt;中的所有同步任务执行完毕，系统就会读取&lt;code&gt;任务队列&lt;/code&gt;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。&lt;/li&gt;
&lt;li&gt;主线程不断重复上面的第三步。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;button onclick=&quot;updateSync()&quot;&amp;gt;同步&amp;lt;/button&amp;gt;
&amp;lt;button onclick=&quot;updateAsync()&quot;&amp;gt;异步&amp;lt;/button&amp;gt;
&amp;lt;div id=&quot;output&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
function updateSync() {
  for (var i = 0; i &amp;lt; 1000000; i++) {
    document.getElementById('output').innerHTML = i;
  }
}
function updateAsync() {
  var i = 0;
  function updateLater() {
    document.getElementById('output').innerHTML = (i++);
    if (i &amp;lt; 1000000) {
      setTimeout(updateLater, 0);
    }
  }
  updateLater();
}
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击&lt;code&gt;同步&lt;/code&gt;按钮会调用&lt;code&gt;updateSync&lt;/code&gt;的同步函数，逻辑非常简单，循环体内每次更新&lt;code&gt;output&lt;/code&gt;结点的内容为&lt;code&gt;i&lt;/code&gt;。如果在其他多线程模型下的语言，你可能会看到界面上以非常快的速度显示从&lt;code&gt;0&lt;/code&gt;到&lt;code&gt;999999&lt;/code&gt;后停止。但是在&lt;code&gt;JavaScript&lt;/code&gt;中，你会感觉按钮按下去的时候卡了一下，然后看到一个最终结果&lt;code&gt;999999&lt;/code&gt;，而没有中间过程，这就是因为在&lt;code&gt;updateSync&lt;/code&gt;函数运行过程中&lt;code&gt;UI&lt;/code&gt;更新被阻塞，只有当它结束退出后才会更新&lt;code&gt;UI&lt;/code&gt;。反之，当点击&lt;code&gt;异步&lt;/code&gt;的时候，会明显的看到&lt;code&gt;Dom&lt;/code&gt;在逐步更新的过程。&lt;/p&gt;
&lt;p&gt;从上面的例子中可以明显的看出，异步编程对于&lt;code&gt;JavaScript&lt;/code&gt;来说是多么多么的重要。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;异步编程有什么好处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从编程方式来讲当然是同步编程的方式更为简单，但是同步有其局限性一是假如是单线程那么一旦遇到阻塞调用，会造成整个线程阻塞，导致&lt;code&gt;cpu&lt;/code&gt;无法得到有效利用，而浏览器的&lt;code&gt;JavaScript&lt;/code&gt;执行和浏览器渲染是运行在单线程中，一旦遇到阻塞调用不仅意味&lt;code&gt;JavaScript&lt;/code&gt;的执行被阻塞更意味整个浏览器渲染也被阻塞这就导致界面的卡死，若是多线程则不可避免的要考虑互斥和同步问题，而互斥和同步带来复杂度也很大，实际上浏览器下因为同时只能执行一段&lt;code&gt;JavaScript&lt;/code&gt;代码这意味着不存在互斥问题，但是同步问题仍然不可避免，以往回调风格中异步的流程控制（其实就是同步问题）也比较复杂。浏览器端的编程方式也即是&lt;code&gt;GUI编程&lt;/code&gt;，其本质就是事件驱动的（鼠标点击，&lt;code&gt;Http&lt;/code&gt;请求结束等）异步编程更为自然。&lt;/p&gt;
&lt;p&gt;突然有个疑问，既然如此为什么&lt;code&gt;JavaScript&lt;/code&gt;没有使用多线程作业呢？就此就去&lt;code&gt;Google&lt;/code&gt;了一下&lt;code&gt;JavaScript多线程&lt;/code&gt;，在&lt;code&gt;HTML5&lt;/code&gt;推出之后是提供了多线程只是比较局限。在使用多线程的时候无法使用&lt;code&gt;window&lt;/code&gt;对象。若&lt;code&gt;JavaScript&lt;/code&gt;使用多线程，在&lt;code&gt;A&lt;/code&gt;线程中正在操作&lt;code&gt;DOM&lt;/code&gt;，但是&lt;code&gt;B&lt;/code&gt;线程中已经把该&lt;code&gt;DOM&lt;/code&gt;已经删除了（只是简单的小栗子，可能还有很多问题，至于这些历史问题无从考究了）。会给编程作业带来很大的负担。就我而言我想这也就说明了为什么&lt;code&gt;JavaScript&lt;/code&gt;没有使用异步编程的原因吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;异步与回调&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回调到底属于异步么？会想起刚刚开始学习&lt;code&gt;JavaScript&lt;/code&gt;的时候常常吧这两个概念混合在一起。在搞清楚这个问题，首先要明白什么是回调函数。&lt;/p&gt;
&lt;p&gt;百科：&lt;a href=&quot;https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0&quot;&gt;回调函数&lt;/a&gt;;回调函数是一个函数，它作为参数传递给另一个函数，并在父函数完成后执行。回调的特殊之处在于，出现在“父类”之后的函数可以在回调执行之前执行。另一件需要知道的重要事情是如何正确地传递回调。这就是我经常忘记正确语法的地方。&lt;/p&gt;
&lt;p&gt;通过上面的解释可以得出，回调函数本质上其实就是一种设计模式，例如我们熟悉的&lt;code&gt;JQuery&lt;/code&gt;也只不过是遵循了这个设计原则而已。在&lt;code&gt;JavaScript&lt;/code&gt;中，回调函数具体的定义为：函数&lt;code&gt;A&lt;/code&gt;作为参数(函数引用)传递到另一个函数&lt;code&gt;B&lt;/code&gt;中，并且这个函数&lt;code&gt;B&lt;/code&gt;执行函数&lt;code&gt;A&lt;/code&gt;。我们就说函数&lt;code&gt;A&lt;/code&gt;叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。&lt;/p&gt;
&lt;p&gt;简单的举个小例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function test (n,fn){
    console.log(n);
    fn &amp;amp;&amp;amp; fn(n);
}
console.log(1);
test(2);
test(3,function(n){
    console.log(n+1)
});
console.log(5)

//  结果
//  1
//  2
//  3
//  4
//  5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的代码输出的结果可以得出回调函数不一定属于异步，一般同步会阻塞后面的代码，通过输出结果也就得出了这个结论。回调函数，一般在同步情境下是最后执行的，而在异步情境下有可能不执行，因为事件没有被触发或者条件不满足。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回调函数应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;资源加载：动态加载js文件后执行回调，加载iframe后执行回调，ajax操作回调，图片加载完成执行回调，AJAX等等。&lt;/li&gt;
&lt;li&gt;DOM事件及Node.js事件基于回调机制(Node.js回调可能会出现多层回调嵌套的问题)。&lt;/li&gt;
&lt;li&gt;setTimeout的延迟时间为0，这个hack经常被用到，settimeout调用的函数其实就是一个callback的体现&lt;/li&gt;
&lt;li&gt;链式调用：链式调用的时候，在赋值器(setter)方法中(或者本身没有返回值的方法中)很容易实现链式调用，而取值器(getter)相对来说不好实现链式调用，因为你需要取值器返回你需要的数据而不是this指针，如果要实现链式方法，可以用回调函数来实现。&lt;/li&gt;
&lt;li&gt;setTimeout、setInterval的函数调用得到其返回值。由于两个函数都是异步的，即：调用时序和程序的主流程是相对独立的，所以没有办法在主体里面等待它们的返回值，它们被打开的时候程序也不会停下来等待，否则也就失去了setTimeout及setInterval的意义了，所以用return已经没有意义，只能使用callback。callback的意义在于将timer执行的结果通知给代理函数进行及时处理。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;JavaScript中的那些异步操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;既然有很多的辅助线程，不可能所有的工作都是通过主线程去做，既然分配给辅助线程去做事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;XMLHttpRequest&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象应该不是很陌生的，主要用于浏览器的数据请求与数据交互。&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象提供两种请求数据的方式，一种是&lt;code&gt;同步&lt;/code&gt;，一种是&lt;code&gt;异步&lt;/code&gt;。可以通过参数进行配置。默认为异步。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;XMLHttpRequest&lt;/code&gt;这里就不作太多的赘述了。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var xhr = new XMLHttpRequest();
xhr.open(&quot;GET&quot;, url, false);    //同步方式请求 
xhr.open(&quot;GET&quot;, url, true);     //异步
xhr.send();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同步&lt;code&gt;Ajax&lt;/code&gt;请求：&lt;/p&gt;
&lt;p&gt;当请求开始发送时，&lt;code&gt;浏览器事件线程&lt;/code&gt;通知&lt;code&gt;主线程&lt;/code&gt;，让&lt;code&gt;Http线程&lt;/code&gt;发送数据请求，主线程收到请求之后，通知&lt;code&gt;Http线程&lt;/code&gt;发送请求，&lt;code&gt;Http线程&lt;/code&gt;收到&lt;code&gt;主线程&lt;/code&gt;通知之后就去请求数据，等待服务器响应，过了&lt;code&gt;N&lt;/code&gt;年之后，收到请求回来的数据，返回给&lt;code&gt;主线程&lt;/code&gt;数据已经请求完成，&lt;code&gt;主线程&lt;/code&gt;把结果返回给了&lt;code&gt;浏览器事件线程&lt;/code&gt;，去完成后续操作。&lt;/p&gt;
&lt;p&gt;异步&lt;code&gt;Ajax&lt;/code&gt;请求：&lt;/p&gt;
&lt;p&gt;当请求开始发送时，&lt;code&gt;浏览器事件线程&lt;/code&gt;通知，&lt;code&gt;浏览器事件线程&lt;/code&gt;通知&lt;code&gt;主线程&lt;/code&gt;，让&lt;code&gt;Http线程&lt;/code&gt;发送数据请求，主线程收到请求之后，通知&lt;code&gt;Http线程&lt;/code&gt;发送请求，&lt;code&gt;Http线程&lt;/code&gt;收到&lt;code&gt;主线程&lt;/code&gt;通知之后就去请求数据，并通知&lt;code&gt;主线程&lt;/code&gt;请求已经发送，&lt;code&gt;主进程&lt;/code&gt;通知&lt;code&gt;浏览器事件线程&lt;/code&gt;已经去请求数据，则&lt;br/&gt;&lt;code&gt;浏览器事件线程&lt;/code&gt;，只需要等待结果，并不影响其他工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;setInterval&amp;amp;setTimeout&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setInterval&lt;/code&gt;与&lt;code&gt;setTimeout&lt;/code&gt;同属于异步方法，其异步是通过回调函数方式实现。其两者的区别则&lt;code&gt;setInterval&lt;/code&gt;会连续调用回调函数，则&lt;code&gt;setTimeout&lt;/code&gt;会延时调用回调函数只会执行一次。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setInterval(() =&amp;gt; {
    alert(1)
},2000)
//  每隔2s弹出一次1
setTimeout(() =&amp;gt; {
    alert(2)
},2000)
//  进入页面后2s弹出2，则不会再次弹出&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;requestAnimationFarme&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;字面意思就是去请求动画帧，在没有&lt;code&gt;API&lt;/code&gt;之前都是基于&lt;code&gt;setInterval&lt;/code&gt;，与&lt;code&gt;setInterval&lt;/code&gt;相比，&lt;code&gt;requestAnimationFrame&lt;/code&gt;最大的优势是由系统来决定回调函数的执行时机。具体一点讲，如果屏幕刷新率是&lt;code&gt;60Hz&lt;/code&gt;,那么回调函数就每&lt;code&gt;16.7ms&lt;/code&gt;被执行一次，如果刷新率是&lt;code&gt;75Hz&lt;/code&gt;，那么这个时间间隔就变成了&lt;code&gt;1000/75=13.3ms&lt;/code&gt;，换句话说就是，&lt;code&gt;requestAnimationFrame&lt;/code&gt;的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。&lt;/p&gt;
&lt;p&gt;举个小例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var progress = 0;
//回调函数
function render() {
    progress += 1; //修改图像的位置
    if (progress &amp;lt; 100) {
        //在动画没有结束前，递归渲染
        window.requestAnimationFrame(render);
    }
}
//第一帧渲染
window.requestAnimationFrame(render);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Object.observe - 观察者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Object.observe&lt;/code&gt;是一个提供数据监视的&lt;code&gt;API&lt;/code&gt;，在&lt;code&gt;chrome&lt;/code&gt;中已经可以使用。是&lt;code&gt;ECMAScript 7&lt;/code&gt; 的一个提案规范，官方建议的是&lt;code&gt;谨慎使用&lt;/code&gt;级别，但是个人认为这个&lt;code&gt;API&lt;/code&gt;非常有用，例如可以对现在流行的&lt;code&gt;MVVM&lt;/code&gt;框架作一些简化和优化。虽然标准还没定，但是标准往往是滞后于实现的，只要是有用的东西，肯定会有越来越多的人去使用，越来越多的引擎会支持，最终促使标准的生成。从&lt;code&gt;observe&lt;/code&gt;字面意思就可以知道，这玩意儿就是用来做观察者模式之类。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var obj = {a: 1};
Object.observe(obj, output);
obj.b = 2;
obj.a = 2;
Object.defineProperties(obj, {a: { enumerable: false}}); //修改属性设定
delete obj.b;
function output(change) {
    console.log(1)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;是对异步编程的一种抽象。它是一个代理对象，代表一个必须进行异步处理的函数返回的值或抛出的异常。也就是说&lt;code&gt;Promise&lt;/code&gt;对象代表了一个异步操作，可以将异步对象和回调函数脱离开来，通过&lt;code&gt;then&lt;/code&gt;方法在这个异步操作上面绑定回调函数。&lt;/p&gt;
&lt;p&gt;在Promise中最直观的例子就是&lt;code&gt;Promise.all&lt;/code&gt;统一去请求，返回结果。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var p1 = Promise.resolve(3);
var p2 = 42;
var p3 = new Promise(function(resolve, reject) {
  setTimeout(resolve, 100, 'foo');
});
Promise.all([p1, p2, p3]).then(function(values) {
  console.log(values);
});
// expected output: Array [3, 42, &quot;foo&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Generator&amp;amp;Async/Await&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ES6&lt;/code&gt;的&lt;code&gt;Generator&lt;/code&gt;却给异步操作又提供了新的思路，马上就有人给出了如何用&lt;code&gt;Generator&lt;/code&gt;来更加优雅的处理异步操作。&lt;code&gt;Generator&lt;/code&gt;函数是协程在&lt;code&gt;ES6&lt;/code&gt;的实现，最大特点就是可以交出函数的执行权（即暂停执行）。整个&lt;code&gt;Generator&lt;/code&gt;函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。&lt;code&gt;Generator&lt;/code&gt;函数的执行方法如下。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function * greneratorDome(){
    yield &quot;Hello&quot;;
    yield &quot;World&quot;;
    return &quot;Ending&quot;;
}
let grenDome = greneratorDome();
console.log(grenDome.next());
// {value: &quot;Hello&quot;, done: false}
console.log(grenDome.next());
// {value: &quot;World&quot;, done: false}
console.log(grenDome.next());
// {value: &quot;Ending&quot;, done: true}
console.log(grenDome.next());
// {value: undefined, done: true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;粗略实现&lt;code&gt;Generator&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function makeIterator(array) {
  var nextIndex = 0;
  return {
    next: function() {
      return nextIndex &amp;lt; array.length ?
        {value: array[nextIndex++], done: false} :
        {value: undefined, done: true};
    }
  };
}
var it = makeIterator(['a', 'b']);
it.next() // { value: &quot;a&quot;, done: false }
it.next() // { value: &quot;b&quot;, done: false }
it.next() // { value: undefined, done: true }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Async/Await&lt;/code&gt;与&lt;code&gt;Generator&lt;/code&gt;类似，&lt;code&gt;Async/await&lt;/code&gt;是&lt;code&gt;Javascript&lt;/code&gt;编写异步程序的新方法。以往的异步方法无外乎回调函数和&lt;code&gt;Promise&lt;/code&gt;。但是&lt;code&gt;Async/await&lt;/code&gt;建立于Promise之上,个人理解是使用了&lt;code&gt;Generator&lt;/code&gt;函数做了语法糖。&lt;code&gt;async&lt;/code&gt;函数就是隧道尽头的亮光，很多人认为它是异步操作的终极解决方案。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function a(){
    return new Promise((resolve,reject) =&amp;gt; {
        console.log(&quot;a函数&quot;)
        resolve(&quot;a函数&quot;)
    })
}
function b (){
    return new Promise((resolve,reject) =&amp;gt; {
        console.log(&quot;b函数&quot;)
        resolve(&quot;b函数&quot;)
    })
}
async function dome (){
    let A = await a();
    let B = await b();
    return Promise.resolve([A,B]);
}
dome().then((res) =&amp;gt; {
    console.log(res);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Node.js异步I/O&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们发起&lt;code&gt;IO&lt;/code&gt;请求时，调用的是各个不同平台的操作系统内部实现的线程池内的线程。这里的&lt;code&gt;IO&lt;/code&gt;请求可不仅仅是读写磁盘文件，在&lt;code&gt;*nix&lt;/code&gt;中，将计算机抽象了一层，磁盘文件、硬件、套接字等几乎所有计算机资源都被抽象为文件，常说的&lt;code&gt;IO&lt;/code&gt;请求就是抽象后的文件。完成&lt;code&gt;Node&lt;/code&gt;整个异步&lt;code&gt;IO&lt;/code&gt;环节的有事件循环、观察者、请求对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件循环机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。于是就有一个概念，任务队列。如果排队是因为计算量大，&lt;code&gt;CPU&lt;/code&gt;忙不过来，倒也算了，但是很多时候&lt;code&gt;CPU&lt;/code&gt;是闲着的，因为&lt;code&gt;IO&lt;/code&gt;设备（输入输出设备）很慢（比如&lt;code&gt;Ajax&lt;/code&gt;操作从网络读取数据），不得不等着结果出来，再往下执行。&lt;/p&gt;
&lt;p&gt;事件循环是&lt;code&gt;Node&lt;/code&gt;的自身执行模型，正是事件循环使得回调函数得以在&lt;code&gt;Node&lt;/code&gt;中大量的使用。在进程启动时&lt;code&gt;Node&lt;/code&gt;会创建一个&lt;code&gt;while(true)&lt;/code&gt;死循环，这个和&lt;code&gt;Netty&lt;/code&gt;也是一样的，每次执行循环体，都会完成一次&lt;code&gt;Tick&lt;/code&gt;。每个&lt;code&gt;Tick&lt;/code&gt;的过程就是查看是否有事件等待被处理。如果有，就取出事件及相关的回调函数，并执行关联的回调函数。如果不再有事件处理就退出进程。&lt;/p&gt;
&lt;img src=&quot;https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3205663441,2452156941&amp;amp;fm=26&amp;amp;gp=0.jpg&quot;/&gt;&lt;p&gt;线程只会做一件事情，就是从事件队列里面取事件、执行事件，再取事件、再事件。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;while(true) {
    var message = queue.get();
    execute(message);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以把整个事件循环想象成一个事件队列，在进入事件队列时开始对事件进行弹出操作，直至事件为&lt;code&gt;0&lt;/code&gt;为止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;process.nextTick&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;process.nextTick()&lt;/code&gt;方法可以在当前&quot;执行栈&quot;的尾部--&amp;gt;下一次&lt;code&gt;Event Loop&lt;/code&gt;（主线程读取&quot;任务队列&quot;）之前--&amp;gt;触发&lt;code&gt;process&lt;/code&gt;指定的回调函数。也就是说，它指定的任务总是发生在所有异步任务之前，当前主线程的末尾。（&lt;code&gt;nextTick&lt;/code&gt;虽然也会异步执行，但是不会给其他&lt;code&gt;io&lt;/code&gt;事件执行的任何机会）;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;process.nextTick(function A() {
  console.log(1);
  process.nextTick(function B(){console.log(2);});
});
setTimeout(function C() {
  console.log(3');
}, 0);
// 1
// 2
// 3&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;异步过程的构成要素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;异步函数实际上很快就调用完成了，但是后面还有工作线程执行异步任务，通知主线程，主线程调用回调函数等很多步骤。我们把整个过程叫做异步过程，异步函数的调用在整个异步过程中只是一小部分。&lt;/p&gt;
&lt;p&gt;一个异步过程的整个过程：主线程发一起一个异步请求，相应的工作线程接收请求并告知主线程已收到通知（异步函数返回）；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作（调用回调函数）。&lt;/p&gt;
&lt;p&gt;它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。&lt;code&gt;args&lt;/code&gt;是这个函数需要的参数，&lt;code&gt;callbackFn&lt;/code&gt;（回调函数）也是这个函数的参数，但是它比较特殊所以单独列出来。所以，从主线程的角度看，一个异步过程包括下面两个要素：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;发起函数;&lt;/li&gt;
&lt;li&gt;回调函数callbackFn&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;它们都是主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。&lt;/p&gt;
&lt;p&gt;举个具体的栗子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;setTimeout(function,1000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;setTimeout&lt;/code&gt;就是异步过程的发起函数，&lt;code&gt;function&lt;/code&gt;是回调函数。&lt;/p&gt;
&lt;p&gt;注：前面说得形式&lt;code&gt;A(args...,callbackFn)&lt;/code&gt;只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var xhr = new XMLHttpRequest();
xhr.onreadystatechange = xxx;
xhr.open('GET'， url);
xhr.send();　　&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;的异步编程模式不仅是一种趋势，而且是一种必要，因此作为&lt;code&gt;HTML5&lt;/code&gt;开发者是非常有必要掌握的。采用第三方的异步编程库和异步同步化的方法，会让代码结构相对简洁，便于维护，推荐开发人员掌握一二，提高团队开发效率。&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 15:09:00 +0000</pubDate>
<dc:creator>Aaron-攻城狮</dc:creator>
<og:description>一直以来都知道 是一门单线程语言，在笔试过程中不断的遇到一些输出结果的问题，考量的是对异步编程掌握情况。一般被问到异步的时候脑子里第一反应就是 ，`setTimseout JavaScript 回调地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aaron---blog/p/10903118.html</dc:identifier>
</item>
<item>
<title>java数据结构和算法09（哈希表） - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/10890349.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/10890349.html</guid>
<description>&lt;p&gt;　　树的结构说得差不多了，现在我们来说说一种数据结构叫做哈希表（hash table），哈希表有是干什么用的呢？我们知道树的操作的时间复杂度通常为O（logN），那有没有更快的数据结构？当然有，那就是哈希表；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.哈希表简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　哈希表（hash table）是一种数据结构，提供很快速的插入和查找操作（有的时候甚至删除操作也是），时间复杂度为O(1)，对比时间复杂度就可以知道哈希表比树的效率快得多，并且哈希表的实现也相对容易，然而没有任何一种数据结构是完美的，哈希表也是；哈希表最大的缺陷就是基于数组，因为数组初始化的时候大小是确定的，数组创建后扩展起来比较困难；&lt;/p&gt;
&lt;p&gt;　　当哈希表装满了之后，就要把数据转移到一个更大的哈希表中，这会很费时间，而且哈希表不支持有顺序的遍历，因为从哈希表中遍历数据是随机的；所以我们使用哈希表的前提是：不需要有序的遍历数据，可以大概知道数据量的多少；满足这两点就可以用哈希表；&lt;/p&gt;
&lt;p&gt;　　那有人就要问了，说得这么厉害，哈希表到底是什么样子的啊？下面就随便说两个吧。。。&lt;/p&gt;
&lt;p&gt;　　很经典的例子就是英语字典，我们查字典的时候可以根据这个单词就可以找到第xxx页，在这里该单词和页数就对应起来了，这可以说是一个哈希表；&lt;/p&gt;
&lt;p&gt;　　再举个现实中的例子，在上学的时候每个人在学校里都会有一个学号，你这个人在学校中就对应这个学号，假如校长手上有一个记录全校学生的表，然后根据学号找一个学生时，就能很快锁定这个学生的姓名，性别，班级等信息；有没有想过假如没有学号的话，校长想找一个学生就只能根据姓名去找，可是同名同姓的人这么多，想找到目标学生不是一件容易的事。。。。。&lt;/p&gt;
&lt;p&gt;　　ok，在这里哈希表可以看作是校长手上的那个表（其实就是一个数组），我们根据我们要存的信息生成一个表中的位置的号码（在这里这个号码就是数组的下标），根据这个号码我们就知道该数据存在数组的哪个位置，然后将数据保存进去就可以了；假如有个大小为20的数组，我要存“aaa”,我们可以想个很厉害的办法将这个字符串变成一个比较小的数字，比如是10，那么就把这个字符串存到数组的第10个位置，这样做的好处就是下次如果要从哈希表中查询（或删除）“aaa”这个字符串时，只需要将“aaa”字符串算出那个号码10，然后直接去数组中第10个位置找一个看有没有这个字符串，是不是很简单啊！&lt;/p&gt;
&lt;p&gt;　　所以现在我们需要解决的就是想个很厉害的办法可以将字符串变成一个比较小的数字（这个过程叫做哈希化），还要保证这个数字不能超过数组的最大边界！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2 哈希化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　哈希化就是想办法将我们要保存的数据对应一个数组下标，在数组的该位置下保存数据；我们可以把这个过程专业一点的说一下：把要保存的数据，通过哈希函数转化为对应的数组下标；现在我们的目标就是怎么编写一个哈希函数可以使得字符串变成数组下标；&lt;/p&gt;
&lt;p&gt;　　这里我们可以假设一个字符串t数组的大小为30，String[] str = new String[30];   要存“cats”这个单词，最容易想到的办法就是用ASCII码，但是由于ASCII码太多了不好记，于是我们可以自己设置一套规则，我就假设a到z分别对应1到26，外加空格对应0，现在一套最简陋的规则就出来了,我那么“cats”这个单词：c = 3,a = 1,t = 20,s = 19，现在“cats”有两种办法变成数组的下标；&lt;/p&gt;
&lt;p&gt;　　额外补充一下：假如我们要保存的字符串有50个，那么我们new的数组大小一定要是它的两倍大，即 new String[100];，后面会说到这个原因&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.1哈希函数实现一&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　怎么实现比较好呢？别想那么多，直接相加就好，3+1+20+19 = 43，这个时候就有个小问题，我们的数组的大小为30，也就是说数组下标最大值是29，而这里我们的数字为43，怎么将43变成29以内的数（包括29）呢？因为任何数除以30的余数只都在0-29之间，于是我们用43除以30拿到余数13，那么我们就把”cats“放到数组下标为13的位置,str[13] = &quot;cats&quot;;&lt;/p&gt;
&lt;p&gt;　　这种哈希函数的实现很容易，但是往往越容易的东西缺点就越大，最大的缺陷就是有很多单词变成数字是相同的，比如was，tin，give等100多个单词变成数字后都是43，然后我们恰巧添加单词的时候就是这些单词，现在问题来了，多个单词最后算出来的数组下标很大概率上是一样的，也就是数组一个位置要放多个数据，怎么解决这个问题呢？我们可以换一种哈希函数的实现来降低这个概率&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;2.2 哈希函数实现二&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由2.1可以知道太多的单词变成数字的结果是一样的，那么我们就要想办法为每一个单词都对应一个独一无二的整数，然后用这个整数除以数组的大小取余数，就可以知道该单词在数组中的存放位置；&lt;/p&gt;
&lt;p&gt;　　于是啊，我们可以利用幂的连乘来得到这个独一无二的整数，比如“cats”用这种计算方法：3*27&lt;sup&gt;3&lt;/sup&gt;+1*27&lt;sup&gt;2&lt;/sup&gt;+20*27&lt;sup&gt;1&lt;/sup&gt;+19*27&lt;sup&gt;0&lt;/sup&gt;，有点类似二进制变成十进制，通过这个算法，可以得到一个独一无二的整数，其他的任何单词通过这种方法算出来的结果几乎是不可能相等的，有兴趣的可以试试；然后将这个计算结果除以30取余数，就可以得到一个数组的位置，然后将该字符串丢到里面即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190520103041142-1996864430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　不知道大家有没有发现这种方法的一个问题，因为数组的大小是一定的，而且我们是通过取余数来得到数组的位置，那么问题来了，即使是两个不相同的整数分别除以30，最后的余数是相等的；&lt;/p&gt;
&lt;p&gt;　　就比如有两个字符串通过幂的连乘最后得到32和62（当然我们这里肯定不会得到这两个整数，为了好理解随便拿两个数），虽然这两个数是独一无二的，但是除以30余数都为2，那么两个数据要保存到哈希表中肯定会有冲突，下后面我们来解决一下这个冲突；&lt;/p&gt;

&lt;p&gt;　　有个简单的哈希函数实现看一下（虽然还可以进行修改一下，但是这个已经差不多了）；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190521192024032-525912526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190521222710633-1714166036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.冲突&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　冲突的原因就是两个独一无二的整数除以数组的大小，取余数是相等的，而数组中一个位置只能存一个数据，这就导致了冲突，解决冲突的办法有两种；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;.&lt;/span&gt;1 解决方法一（开放地址法）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　还记得前面说过数组的大小要为实际数量的两倍吗？就是为了这个时候用的，假如一个单词已经放在了数组的第15个位置那里，另外一个单词本来也要放在第15的位置，由于这个位置已经被别人占了。那就放在数组的另外一个位置上，反正还有很多数组比较大，这种方式叫做------开放地址法&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;3.2 解决方法二（链地址法 ）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　既然有两个数据都要放在数组的一个位置上，那就想办法把第二个数据连在第一个数据后面，通过第一个数据可以找到第二个数据，而数组中只保存第一个数据的地址；其实就是一句话，数组中每个位置放一个链表；&lt;/p&gt;
&lt;p&gt;　　这种方法的好处很明显，完美解决上述冲突，不需要用什么花里胡哨的操作；缺陷就是当链表太长了，我们要查询这个链表的最后面的数据，只能慢慢遍历这个链表，而我们知道，链表的优势是插入和删除，而对于查询这种操作是比较坑爹的，而我们前面用了红黑树这样的结构来完美解决链表的缺点；最后，我们就差不多想到了一个比较实用的方法：数组的每个位置都存放一个链表，当链表的节点很少的时候，那就用链表吧！但是当链表慢慢的变长，当节点数目到达一个界限的时候，我们就把这个链表变成一个红黑树，比较完美的方案，这也叫做------链地址法 &lt;/p&gt;
&lt;p&gt;　　顺便一提，jdk7的HashMap就是数组中放链表，即使链表很长也不会变红黑树；jdk8中的HashMap才增加了变红黑树这个操作&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.开放地址法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　所谓的开放地址法就是：根据我们要保存的数据计算出来的数组下标的那个位置已经存放了数据，这个时候我们就要再找一个空位置，然后将要保存的数据丢进去即可，那么怎么找比较好呢？这里提供三种方式，线性探测，二次探测和再哈希法，下面就看看这三种方式到底是怎么工作的；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;4.1 线程探测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　看名字线性就知道是从前往后寻找空的位置，举个很简单的例子，当一个字符串经过运算对应于数组下标为52，然而此时52这个位置上已经有了数据，那么就尝试放到53的位置，假如53的位置也已经放了数据，那就放到54位置，就这样一直往后慢慢找，直到找到一个空的位置就把数据放进去；而此时找的次数越多，假如已经找到56的位置，那么从53到56这么多位置叫做填充序列，当填充序列很长的时候，我们就称为原始聚集，下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190520170721861-2062869760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里填充序列的中有5个填充单元，我们也可以说步数为1，每次探测都是前进一步；我们可以知道当探测的次数越多的时候，说明聚集越严重，下一次再想添加到这个位置的数据的效率就越低；&lt;/p&gt;
&lt;p&gt;　　还有就是当哈希表填充得越满，效率也就越低，所以当哈希表快满了之后就要扩展，而java中数组是不能直接进行扩展的，需要再新建一个数组，然后想办法将这个哈希表中的数据复制到新的数组中，注意，这里不能直接复制，因为新的数组的容量和原来的数组不一样，那么原来哈希表中所有的数据必须要重新哈希化，然后放入到新的数组中，非常耗时....&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;4.2 二次探测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　根据前面我们的线性探测可以知道，假如经过哈希函数计算出来的原始数组下标为x，那么线性探测的位置是x+1，x+2，x+3，x+4.....,；那么 进行二次探测找的位置就是x+1&lt;sup&gt;2&lt;/sup&gt;，x+2&lt;sup&gt;2&lt;/sup&gt;，x+3&lt;sup&gt;2&lt;/sup&gt;，x+4&lt;sup&gt;2&lt;/sup&gt;.....其实就是按照步数的平方进行探测看里面有没有数据，没有的话才放进去新的数据，二次探测可以防止聚集太长所导致的效率下降问题；&lt;/p&gt;
&lt;p&gt;　　对于二次探测来说，如果当前计算出来的位置为x，首先会探测x后面一个位置，如果这个位置有数据，那就多往后4个位置看有没有数据，假如还是有数据，那么二次探测可能会觉得你这个聚集特别长，于是这次跳得更远的位置，当前位置后面的16的位置等等，直到最后跳过整个数组， 这样可以避免一个一个的位置慢慢探测的底下效率，二次探测下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190520173539719-989075880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　二次探测也有点问题，会导致二次聚集，那什么又是二次聚集呢？其实跟原始聚集差不多吧！比如184，302，420，544这几个整数都要放到哈希表中，而且这几个数经过哈希算法算出来的数组下标都为7，302需要以1步长进行探测，而420要先以1为步长，然后以4步长进行探测，而544要先以1为步长，然后以4为步长，最后以16步长进行探测，假如后面还有数据对应的数组下标为7，那么还是要重复这个步骤，而且是越来越长....这也是一种聚集，个人感觉从某种意义来说和原始聚集性质差不多吧！&lt;/p&gt;
&lt;p&gt;　   二次探测不常用，因为有更好的办法解决，就是再哈希法；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;4.3 再哈希法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用再哈希法可以消除原始聚集和二次聚集，那么什么是再哈希法呢？我们可以知道产生原始聚集和二次聚集的原因其实差不多，都是由于多个数据添加到哈希表中的同一个位置，然后根据步长一个一个位置的探测，直到找到一个空的位置，如果需要找的位置特别多，那么这就是聚集，添加的效率的就会大幅度降低； &lt;/p&gt;
&lt;p&gt;　　那么我们就要想一种方法即使多个数据要放在哈希表的同一个位置，但是不需要从头开始一个一个位置的探测，如果每个数据都可以产生一个独一无二的步长那不就好了么！然后直接根据这个步长探测该位置将数据丢进去就ok了；&lt;/p&gt;
&lt;p&gt;　　于是我们准备了两个哈希函数，一个哈希函数就是我们上面说到的可以产生对应的数组下标，另外一个哈希函数可以产生步长，其实就是多个数据放在同一个位置产发生冲突，就用这个哈希函数再次哈希化产生一个步长，根据这个步长进行探测就可以了，而不用每次都从第一个步长开始；比如下面就有一个产生步长的哈希函数，我们可以知道步长的范围是1-constant，注意步长不能为0，否则就原地踏步了。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190521102603631-1988865701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图中，假如我们往哈希表中添加的数据是数字，那就直接将数据和数组大小取余得到数组下标，这里的key就是我们的数据，constant只要是小于数组容量的一个质数，随便什么都可以&lt;/p&gt;
&lt;p&gt;　　顺便一提：再哈希法使用的前提必须保证数组的容量为一个质数，因为这样才能使得所有位置都被探测到；可以试试假如数组容量为15，步长为5，一个数据经过计算得到额数组下标为0，那么探测的位置应该为：（0+5）%15 = 5,、（5+5）%15 = 10，（10+5）%15 = 0，只会探测0、5、10这三个位置；但是如果数组容量为质数13，步长为5，第一个数据下标还是0，那么探测位置为：（0+5）%13 = 5,、（5+5）%13 = 10，（10+5）%13 = 2、（2+5）%13 = 7，（7+5）%13 = 12，（12+5）%13 = 4，（4+5）%13 = 9等等，可以看到每次探测的位置都不一样，可以探测到数组中所有位置只要有空的就把数据当进去即可；&lt;/p&gt;
&lt;p&gt;　　假如使用的是开放地址法，那么探测序列就用这个再哈希法生成，其实很容易！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.链地址法&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　可以看到上面的开放地址法有点麻烦，需要找到探测序列真的是日了狗了，麻烦的我都不想看了，如果可以不用这么麻烦那该多好呀，ok，那就用链地址法吧！就类似下面这样的结构，原始的数组中不直接保存数据，每个位置只是保存第一个数据的引用，通过该位置第一个引用就可以取到后面所有的数据！如果链表太长遍历起来就比较费劲，可以转为红黑树效率就高了很多；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201905/1368608-20190521110521180-1894926834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这里其实没什么好说的，因为数组和链表的使用很熟悉了，没什么特别难的东西，基本逻辑：只需要新建一个MyHashTable的类，这个类中有几个属性：一个数组，一个int类型的属性标识数组真实容量的大小；最好有个节点类为静态内部类，这个静态内部类中实现了对链表的增删改查的操作；然后在MyHashTable类中写一个哈希函数的方法，根据这个哈希函数得出来的数组下标，最后对数组的增删改查了！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　哈希表其实还可以用在外部存储中，也就是硬盘中，有兴趣的可以看看，不过我感觉到这里就差不多了！其实哈希表的内容没多少吧，最主要的就是哈希函数的选取，选择一个好的哈希函数可以使得我们的哈希表的效率更高！然后就是数组中存数据的方式，可以直接在数组中存数据，也可以在数组中存节点的引用，其实吧，知不知道二维数组？在我们这个数组中每个位置存的是另外一个数组的引用，这样其实也行，由于扩展起来很困难，使用链表比使用二维数组好。。。&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 14:58:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>树的结构说得差不多了，现在我们来说说一种数据结构叫做哈希表（hash table），哈希表有是干什么用的呢？我们知道树的操作的时间复杂度通常为O（logN），那有没有更快的数据结构？当然有，那就是哈希</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/10890349.html</dc:identifier>
</item>
<item>
<title>可落地的DDD的(2)-为什么说MVC工程架构已经过时 - stoneFang</title>
<link>http://www.cnblogs.com/stoneFang/p/10903008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneFang/p/10903008.html</guid>
<description>&lt;p&gt;mvc是一种软件设计模式，最早由Trygve Reenskaug在1978年提出，他有效的解决了表示层，控制器层，逻辑层的代码混合在一起的问题，很好的做到了职责分离。但是在实际的编码实践过程中，你会发现这个模式随着业务的扩展，变的逻辑混乱，代码重合度很高。这里提出借鉴DDD思想的一种新的工程结构&lt;/p&gt;

&lt;p&gt;通常一个前后端分离的系统，后端工程系统结构图通常下面这样&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201905192015096.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  1. 四层 controller/service/manager/mapper

  2. 不可以同级调用

  3. 上级可以知晓下级，下级不可知晓上级，也就是bean的转化放在上级&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个分层结构职责分离是按照纵向切分的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  1. 资源服务层repository是面向DB编程

  2. service层是面向前端页面编程。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，对于某一块的业务，他没有将逻辑抽象到一起，他只是将一次request按照纵向切分了。没有进行横向的业务切分。&lt;br/&gt;这样将会导致的问题&lt;br/&gt;&lt;strong&gt;职责分散，逻辑重复度高&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bean的创建太随意，基本就是一个需求对应一些dto, vo，query bean&lt;/li&gt;
&lt;li&gt;不同开发者对于同一个领域的东西有不同的bean，同一个开发者对于相同逻辑的bean，过了几个月，又定义出一个差不多的bean&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;没有边界&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根本没有上下文/边界的概念，比如说店铺会和用户有交互，订单会和用户有交互，通常在DB存储时只会存关联id，然后需要去取对应的名称，其他属性信息。这些信息的获取，有些开发在manager层操作，然后将属性定义到了店铺相关的DTO中;有些放在了service层做。controller/service/manager各个层次都可以调用，没有任何约束。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mvc的演进&quot;&gt;mvc的演进&lt;/h2&gt;
&lt;p&gt;按照上述的说明，在一个单体服务中，随着业务的不断迭代，可能会发生什么严重的问题。&lt;/p&gt;
&lt;p&gt;举几个真实鲜活的例子&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分库分表的例子&lt;/strong&gt;&lt;br/&gt;实体A是我们业务中的一个基础的重要的实体，对应的数据表tableA,一开始业务很简单，只有1个服务，在这个服务里面调用。后来业务扩张了，有十几个服务了，然后十几个服务直接查这个tableA。tableA也扩张成为了tableA,tableB,tableC。有些人觉得代码重复度高了，将mapper/manager层拆成共通的部分打成一个jar包，然后各个微服务中引入这个jar。业务变得更加复杂了，服务扩展到几十个了，tableA数据也有几千万了，这时候要做分库分表了，怎么整。&lt;/p&gt;
&lt;p&gt;最后花了差不多1年，涉及十几个团队，才把这个mapper/manager调用改掉，然后做分库分表。&lt;/p&gt;
&lt;p&gt;有人可能觉得这个只要在服务拆分时，避免直接调用就可以了，那再举个其他类型的例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户等级的例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户的等级，用户的分级是很复杂的，不同的业务阶段有这个不同的定义。比如一开始定义一个字段叫grade的代表用户等级。&lt;br/&gt;然后各个业务都在查这个表的字段grade进行判断，然后产品需要改了，增加了判断必须同时要达到什么条件才能称作等级x。这时候你又得满世界的改了。&lt;/p&gt;
&lt;h2 id=&quot;ddd的工程架构&quot;&gt;DDD的工程架构&lt;/h2&gt;
&lt;p&gt;那如何运用DDD的思想进行改造呢&lt;br/&gt;&lt;strong&gt;核心思想：封装领域内的逻辑，统一对外暴露的入口，防止业务逻辑泄露。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190521224831685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在mvc纵向切分的基础上，增加一层领域的横向切分&lt;/li&gt;
&lt;li&gt;同一个工程里面，领域之间的调用只能通过domainService,这样可以屏蔽领域内的数据库是如何持久化的，业务逻辑是如何判断的、算法是如何实现的。&lt;br/&gt;service之间可以直接调用。&lt;/li&gt;
&lt;li&gt;领域内还是纵向切分，安装mvc分层结构。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的只是一个草图，我们真实的结构图比这要稍微复杂些。领域内会区分领域对象，领域服务，基础设施层。这样在领域内进行指责分离，不过从实际的执行过程中领域内的比较细节，执行起来ROI比较低，推荐大家可以先按这套执行。&lt;/p&gt;
&lt;p&gt;画外音：估计有些程序员看到这个工程结构变化呵呵一笑，觉得没多大价值，没什么改变必要。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这种工程的结构划分从提出来的到真正被我们团队成员接受的时间周期差不多是8个月。&lt;br/&gt;原因大概是这么几类&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;引入新的分层，太复杂了，增加了代码复杂度&lt;/li&gt;
&lt;li&gt;我这块业务很简单，CRUD就行了，没涉及到服务之间的交互。直接mvc一条道走到黑就可以。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;如果你看这篇文章也是这种感受，不妨花点时间看下你们业务的代码，看看重复度有多高，看看逻辑有多散乱。你就会明白。&lt;/p&gt;
&lt;h3 id=&quot;ddd工程的演进&quot;&gt;DDD工程的演进&lt;/h3&gt;
&lt;p&gt;DDD工程的演进也就是服务的拆分了，放到下期讲。&lt;/p&gt;

&lt;p&gt;很多DDD的文章都在说传统的编程方式是面试数据库编程，导致对象中只有getter,setter，也就是贫血模型，贫血模型是没有业务逻辑，面向过程设计，不符合面向对象设计原则。&lt;/p&gt;
&lt;p&gt;对于这个结论我是同意的，但是对于造成的原因不是很同意。个人认为造成这个原因的主要原因还是在于长期以来的MVC这种模式只有纵向切分导致。如果结合横向切分，有没有DDD也无所谓。这里再引用一下&lt;a href=&quot;https://www.infoq.cn/article/star-driven-approaches&quot;&gt;驱动方法不能改变任何事情&lt;/a&gt;这段话，如果你能深入理解职责、封装。并随着业务的迭代，不断的重构你的代码，那么你不需要什么DDD,或者其他方法论。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;使用职责、封装和组合；&lt;br/&gt;以接口的视角思考，即“人们如何使用我的组件？”；&lt;br/&gt;使用相关技术写好代码，包括可读性、信息性、简洁、自描述，尽量避免显式地使用模式；&lt;br/&gt;有能力回答特定业务的“本质”；“本质”是一个模型，但不意味着类和方法，它意味着回答问题“这个业务如何真正地工作？”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为这些约束，都是强迫你去思考，去做职责的思考，去做模块的封装。如果你/你团队成员已经领会其中的道理并很好的运用，还需要这些条条框框干吗呢？&lt;/p&gt;
&lt;p&gt;下一篇领域与微服务划分，欲知后事如何，请听下回分解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/stoneFang/p/10888630.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/stoneFang/p/10888630.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注【方丈的寺院】，第一时间收到文章的更新，与方丈一起开始技术修行之路&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190418000000125.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9mYW5nemhhbmcuYmxvZy5jc2RuLm5ldA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 14:51:00 +0000</pubDate>
<dc:creator>stoneFang</dc:creator>
<og:description>摘要 mvc是一种软件设计模式，最早由Trygve Reenskaug在1978年提出，他有效的解决了表示层，控制器层，逻辑层的代码混合在一起的问题，很好的做到了职责分离。但是在实际的编码实践过程中，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneFang/p/10903008.html</dc:identifier>
</item>
<item>
<title>ML.NET调用Tensorflow模型示例——MNIST - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10902431.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10902431.html</guid>
<description>&lt;p&gt;ML.NET在不久前发行了1.0版本，在考虑这一新轮子的实际用途时，最先想到的是其能否调用已有的模型，特别是最被广泛使用的Tensorflow模型。于是在查找了不少资料后，有了本篇示例。希望可以有抛砖引玉之功。&lt;/p&gt;

&lt;p&gt;Tensorflow 1.13.1&lt;br/&gt;Microsoft.ML 1.0.0&lt;br/&gt;Microsoft.ML.TensorFlow 0.12.0&lt;br/&gt;netcoreapp2.2&lt;/p&gt;

&lt;p&gt;这里为了方便，利用Keras的API减少所需的代码。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import tensorflow as tf
mnist = tf.keras.datasets.mnist

(x_train, y_train),(x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0

model = tf.keras.models.Sequential([
  tf.keras.layers.Flatten(input_shape=(28, 28)),
  tf.keras.layers.Dense(512, activation=tf.nn.relu),
  tf.keras.layers.Dropout(0.2),
  tf.keras.layers.Dense(10, activation=tf.nn.softmax)
])
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

model.fit(x_train, y_train, epochs=5)
model.evaluate(x_test, y_test)
model.save('model.h5')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到的模型精度在98%以上，不错的结果。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201905/991496-20190521212614243-1004925958.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;加载已训练的模型，用某一测试数据验证结果。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;with CustomObjectScope({'GlorotUniform': glorot_uniform()}):
    model = load_model('model.h5')

    data = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.027450980392156862, 0.09411764705882353, 0.5019607843137255, 0.5450980392156862, 0.5411764705882353, 0.7490196078431373, 0.7058823529411765, 0.9921568627450981, 0.7490196078431373, 0.5411764705882353, 0.18823529411764706, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.16862745098039217, 0.1843137254901961, 0.47058823529411764, 0.7294117647058823, 0.9882352941176471, 0.9882352941176471, 0.9921568627450981, 0.9882352941176471, 0.9882352941176471, 0.9882352941176471, 0.9882352941176471, 0.9921568627450981, 0.9882352941176471, 0.8901960784313725, 0.11372549019607843, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07450980392156863, 0.6431372549019608, 0.9647058823529412, 0.9921568627450981, 0.9882352941176471, 0.9882352941176471, 0.8901960784313725, 0.7176470588235294, 0.7215686274509804, 0.6352941176470588, 0.27058823529411763, 0.27058823529411763, 0.27058823529411763, 0.30980392156862746, 0.8901960784313725, 0.9882352941176471, 0.17647058823529413, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.27450980392156865, 0.9882352941176471, 0.9882352941176471, 0.9921568627450981, 0.9215686274509803, 0.30196078431372547, 0.11372549019607843, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03529411764705882, 0.7607843137254902, 0.8901960784313725, 0.11372549019607843, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.027450980392156862, 0.2549019607843137, 0.5372549019607843, 0.788235294117647, 0.6823529411764706, 0.12549019607843137, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.7098039215686275, 0.9882352941176471, 0.7176470588235294, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03529411764705882, 0.5019607843137255,
            1.0, 0.9764705882352941, 0.45098039215686275, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4470588235294118, 0.9882352941176471, 0.9921568627450981, 0.5176470588235295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5254901960784314, 0.9411764705882353, 0.9882352941176471, 0.47843137254901963, 0.09803921568627451, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03529411764705882, 0.6509803921568628, 0.9411764705882353, 0.9882352941176471, 0.6588235294117647, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.20784313725490197, 0.7098039215686275, 0.9882352941176471, 0.9882352941176471, 0.4549019607843137, 0.00784313725490196, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.027450980392156862, 0.25882352941176473, 0.9529411764705882, 1.0, 0.9764705882352941, 0.24705882352941178, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.7294117647058823, 0.9882352941176471, 0.9882352941176471, 0.8549019607843137, 0.29411764705882354, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.19215686274509805, 0.8941176470588236, 0.9882352941176471, 0.9882352941176471, 0.8666666666666667, 0.12549019607843137, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5333333333333333, 0.9137254901960784, 0.9882352941176471, 0.8901960784313725, 0.4666666666666667, 0.09803921568627451, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.12549019607843137, 0.8235294117647058, 0.9803921568627451, 0.9921568627450981, 0.9058823529411765, 0.18823529411764706, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.34901960784313724, 0.8705882352941177, 0.9921568627450981, 0.9921568627450981, 0.6196078431372549, 0.0, 0.0, 0.0, 0.043137254901960784, 0.13333333333333333, 0.4627450980392157, 0.027450980392156862, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6313725490196078, 0.9882352941176471, 0.9882352941176471, 0.41568627450980394, 0.0, 0.03529411764705882, 0.1843137254901961, 0.34901960784313724, 0.796078431372549, 0.9921568627450981, 0.9568627450980393, 0.2196078431372549, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6313725490196078, 0.9882352941176471,
            0.9882352941176471, 0.7450980392156863, 0.7254901960784313, 0.7725490196078432, 0.9882352941176471, 0.9882352941176471, 0.8666666666666667, 0.6784313725490196, 0.2196078431372549, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.47058823529411764, 0.9882352941176471, 0.9882352941176471, 0.9882352941176471, 0.9921568627450981, 0.9882352941176471, 0.9882352941176471, 0.9882352941176471, 0.3764705882352941, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0196078431372549, 0.21176470588235294, 0.5372549019607843, 0.5372549019607843, 0.7450980392156863, 0.5372549019607843, 0.21176470588235294, 0.08627450980392157, 0.00784313725490196, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

    pred = model.predict(np.array(data).reshape(1, 28, 28))
    print(pred.argmax())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行以上脚本得到的结果为2。&lt;/p&gt;
&lt;p&gt;可以将结果更形象地显示出来。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;plt.imshow(np.array(data).reshape(28, 28), cmap='Greys')
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201905/991496-20190521213558824-98084796.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Keras保存的文件格式是h5，并不能直接被ML.NET调用，所以需要先转换成pb格式。&lt;/p&gt;
&lt;p&gt;方法是使用开源脚本——&lt;a href=&quot;https://github.com/amir-abdi/keras_to_tensorflow&quot;&gt;keras_to_tensorflow&lt;/a&gt;，直接调用如下命令即可完成转换。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;python keras_to_tensorflow.py 
    --input_model=&quot;path/to/keras/model.h5&quot; 
    --output_model=&quot;path/to/save/model.pb&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在ML.NET中调用已训练的模型可分为这样几步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;建立MLContext&lt;/li&gt;
&lt;li&gt;加载模型文件&lt;/li&gt;
&lt;li&gt;创建IDataView对象，用作Fit方法的传入参数&lt;/li&gt;
&lt;li&gt;建立模型管道，这里是TensorFlowEstimator对象&lt;/li&gt;
&lt;li&gt;调用Fit方法，获得TensorFlowTransformer对象&lt;/li&gt;
&lt;li&gt;构建预测引擎，其输入与输出对象对应模型中的输入层与输出层&lt;/li&gt;
&lt;li&gt;执行预测方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所有代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        var mlContext = new MLContext();
        var tensorFlowModel = mlContext.Model.LoadTensorFlowModel(@&quot;D:\workspace\tensorflow\saved_model.pb&quot;);
        //var schema = tensorFlowModel.GetModelSchema();
        var data = GetTensorData();
        var idv = mlContext.Data.LoadFromEnumerable(data);

        var pipeline = tensorFlowModel.ScoreTensorFlowModel(
            new[] { &quot;dense_1/Softmax&quot; }, new[] { &quot;flatten_input&quot; }, addBatchDimensionInput: true);

        var model = pipeline.Fit(idv);

        var engine = mlContext.Model.CreatePredictionEngine&amp;lt;TensorData, OutputScores&amp;gt;(model);
        var result = engine.Predict(data[0]);
        var maxValue = result.Output.Max();
        var maxIndex = result.Output.ToList().IndexOf(maxValue);
        Console.WriteLine(maxIndex);
    }

    private static TensorData[] GetTensorData()
    {
        var data = new double[] {
            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.027450980392156862, 0.09411764705882353, 0.5019607843137255, 0.5450980392156862, 0.5411764705882353, 0.7490196078431373, 0.7058823529411765, 0.9921568627450981, 0.7490196078431373, 0.5411764705882353, 0.18823529411764706, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.16862745098039217, 0.1843137254901961, 0.47058823529411764, 0.7294117647058823, 0.9882352941176471, 0.9882352941176471, 0.9921568627450981, 0.9882352941176471, 0.9882352941176471, 0.9882352941176471, 0.9882352941176471, 0.9921568627450981, 0.9882352941176471, 0.8901960784313725, 0.11372549019607843, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.07450980392156863, 0.6431372549019608, 0.9647058823529412, 0.9921568627450981, 0.9882352941176471, 0.9882352941176471, 0.8901960784313725, 0.7176470588235294, 0.7215686274509804, 0.6352941176470588, 0.27058823529411763, 0.27058823529411763, 0.27058823529411763, 0.30980392156862746, 0.8901960784313725, 0.9882352941176471, 0.17647058823529413, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.27450980392156865, 0.9882352941176471, 0.9882352941176471, 0.9921568627450981, 0.9215686274509803, 0.30196078431372547, 0.11372549019607843, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03529411764705882, 0.7607843137254902, 0.8901960784313725, 0.11372549019607843, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.027450980392156862, 0.2549019607843137, 0.5372549019607843, 0.788235294117647, 0.6823529411764706, 0.12549019607843137, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.7098039215686275, 0.9882352941176471, 0.7176470588235294, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03529411764705882, 0.5019607843137255,
1.0, 0.9764705882352941, 0.45098039215686275, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4470588235294118, 0.9882352941176471, 0.9921568627450981, 0.5176470588235295, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5254901960784314, 0.9411764705882353, 0.9882352941176471, 0.47843137254901963, 0.09803921568627451, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03529411764705882, 0.6509803921568628, 0.9411764705882353, 0.9882352941176471, 0.6588235294117647, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.20784313725490197, 0.7098039215686275, 0.9882352941176471, 0.9882352941176471, 0.4549019607843137, 0.00784313725490196, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.027450980392156862, 0.25882352941176473, 0.9529411764705882, 1.0, 0.9764705882352941, 0.24705882352941178, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.7294117647058823, 0.9882352941176471, 0.9882352941176471, 0.8549019607843137, 0.29411764705882354, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.19215686274509805, 0.8941176470588236, 0.9882352941176471, 0.9882352941176471, 0.8666666666666667, 0.12549019607843137, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5333333333333333, 0.9137254901960784, 0.9882352941176471, 0.8901960784313725, 0.4666666666666667, 0.09803921568627451, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.12549019607843137, 0.8235294117647058, 0.9803921568627451, 0.9921568627450981, 0.9058823529411765, 0.18823529411764706, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.34901960784313724, 0.8705882352941177, 0.9921568627450981, 0.9921568627450981, 0.6196078431372549, 0.0, 0.0, 0.0, 0.043137254901960784, 0.13333333333333333, 0.4627450980392157, 0.027450980392156862, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6313725490196078, 0.9882352941176471, 0.9882352941176471, 0.41568627450980394, 0.0, 0.03529411764705882, 0.1843137254901961, 0.34901960784313724, 0.796078431372549, 0.9921568627450981, 0.9568627450980393, 0.2196078431372549, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6313725490196078, 0.9882352941176471,
0.9882352941176471, 0.7450980392156863, 0.7254901960784313, 0.7725490196078432, 0.9882352941176471, 0.9882352941176471, 0.8666666666666667, 0.6784313725490196, 0.2196078431372549, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.47058823529411764, 0.9882352941176471, 0.9882352941176471, 0.9882352941176471, 0.9921568627450981, 0.9882352941176471, 0.9882352941176471, 0.9882352941176471, 0.3764705882352941, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0196078431372549, 0.21176470588235294, 0.5372549019607843, 0.5372549019607843, 0.7450980392156863, 0.5372549019607843, 0.21176470588235294, 0.08627450980392157, 0.00784313725490196, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
        return new TensorData[] { new TensorData() { Input = data.Select(x=&amp;gt;(float)x).ToArray() }};
    }
}

public class TensorData
{
    [ColumnName(&quot;flatten_input&quot;)]
    [VectorType(28, 28)]
    public float[] Input { get; set; }
}

class OutputScores
{
    [ColumnName(&quot;dense_1/Softmax&quot;)]
    [VectorType(10)]
    public float[] Output { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不清楚模型中的网络结构，可以用TensorFlowModel的GetModelSchema方法获悉详细的情况。&lt;/p&gt;
&lt;p&gt;调试代码，可以看到结果数组中index为2时，概率最大，所以可以认为最终的预测结果为2。与python脚本的执行结果是一致的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201905/991496-20190521220224743-1032454339.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 14:18:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>ML.NET在不久前发行了1.0版本，在考虑这一新轮子的实际用途时，最先想到的是其能否调用已有的模型，特别是最被广泛使用的Tensorflow模型。于是在查找了不少资料后，有了本篇示例。希望可以有抛砖</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10902431.html</dc:identifier>
</item>
<item>
<title>RabbitMQ最佳实践 - 无知者云</title>
<link>http://www.cnblogs.com/davenkin/p/rabbitmq-best-practices.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davenkin/p/rabbitmq-best-practices.html</guid>
<description>&lt;p&gt;在使用消息机制时，我们通常需要考虑以下几个问题:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;消息不能丢失&lt;/li&gt;
&lt;li&gt;保证消息一定能投递到目的地&lt;/li&gt;
&lt;li&gt;保证业务处理和消息发送/消费的一致性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文以RabbitMQ为例，讨论如何解决以上问题。&lt;/p&gt;
&lt;h3 id=&quot;消息持久化&quot;&gt;消息持久化&lt;/h3&gt;
&lt;p&gt;如果希望RabbitMQ重启之后消息不丢失，那么需要对以下3种实体均配置持久化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;exchange&lt;/li&gt;
&lt;li&gt;queue&lt;/li&gt;
&lt;li&gt;message&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;声明exchange时设置持久化（&lt;code&gt;durable = true&lt;/code&gt;）并且不自动删除(autoDelete = false)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean durable = true;
boolean autoDelete = false;
channel.exchangeDeclare(&quot;dlx&quot;, TOPIC, durable, autoDelete, null)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明queue时设置持久化（&lt;code&gt;durable = true&lt;/code&gt;）并且不自动删除(autoDelete = false)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean durable = true;
boolean autoDelete = false;
channel.queueDeclare(&quot;order-summary-queue&quot;, durable, false, autoDelete, queueArguments);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发送消息时通过设置&lt;code&gt;deliveryMode=2&lt;/code&gt;持久化消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
                    .contentType(&quot;application/json&quot;)
                    .deliveryMode(2)
                    .priority(0)
                    .build();
channel.basicPublish(&quot;order&quot;, &quot;order.created&quot;, false, properties, &quot;sample-data&quot;.getBytes())&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;发送确认&quot;&gt;发送确认&lt;/h3&gt;
&lt;p&gt;有时，业务处理成功，消息也发了，但是我们并不知道消息是否成功到达了rabbitmq，如果由于网络等原因导致业务成功而消息发送失败，那么发送方将出现不一致的问题，此时可以使用rabbitmq的发送确认功能，即要求rabbitmq显式告知我们消息是否已成功发送。&lt;/p&gt;
&lt;p&gt;首先需要在channel上设置&lt;code&gt;ConfirmListener&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;channel.addConfirmListener(new ConfirmListener() {
                public void handleAck(long seqNo, boolean multiple) {
                    if (multiple) {
                        logger.info(seqNo + &quot;号及其以前的所有消息发送成功，当消息发送成功后执行相应逻辑，比如标记事件为已发送或者删除原来事件&quot;);
                    } else {
                        logger.info(seqNo + &quot;号发送成功，当消息发送成功后执行相应逻辑，比如标记事件为已发送或者删除原来事件&quot;);
                    }
                }

                public void handleNack(long seqNo, boolean multiple) {
                    if (multiple) {
                        logger.info(seqNo + &quot;号及其以前的所有消息发送失败，当消息发送失败后执行相应逻辑，比如重试或者标记事件发送失败&quot;);
                    } else {
                        logger.info(seqNo + &quot;号发送失败，当消息发送失败后执行相应逻辑，比如重试或者标记事件发送失败&quot;);

                    }
                }
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在发送消息直线需要开启发送确认模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//开启发送者确认
channel.confirmSelect();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后发送消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;channel.basicPublish(&quot;order&quot;, &quot;order.created&quot;, false, properties, &quot;sample-data&quot;.getBytes());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当消息正常投递时，rabbitmq客户端将异步调用&lt;code&gt;handleAck()&lt;/code&gt;表示消息已经成功投递，此时程序可以自行处理投递成功之后的逻辑，比如在数据库中将消息设置为&lt;code&gt;已发送&lt;/code&gt;。当消息投递出现异常时，&lt;code&gt;handleNack()&lt;/code&gt;将被调用。&lt;/p&gt;
&lt;p&gt;通常来讲，发送端只需要保证消息能够发送到exchange即可，而无需关注消息是否被正确地投递到了某个queue，这个是rabbitmq和消息的接收方需要考虑的事情。基于此，如果rabbitmq找不到任何需要投递的queue，那么rabbitmq依然会ack给发送方，此时发送方可以认为消息已经正确投递，而不好用关系消息没有queue接收的问题。但是，对于rabbitmq而言，这种消息是需要记录下来的，否则rabbitmq将直接丢弃该消息。此时可以为exchange设置&lt;code&gt;alternate-exchange&lt;/code&gt;，即表示rabbitmq将把无法投递到任何queue的消息发送到&lt;code&gt;alternate-exchange&lt;/code&gt;指定的exchange中，通常来说可以设置一个死信交换（DLX）。&lt;/p&gt;
&lt;p&gt;事实上，对于exchange存在但是却找不到任何接收queue时，如果发送是设置了&lt;code&gt;mandatory=true&lt;/code&gt;，那么在消息被ack前将return给客户端，此时客户端可以创建一个&lt;code&gt;ReturnListener&lt;/code&gt;用于接收返回的消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;channel.addReturnListener(new ReturnListener() {
                @Override
                public void handleReturn(int replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, byte[] body) throws IOException {
                    logger.warn(&quot;消息无法正确投递，已返回。&quot;);
                }
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是需要注意的是，在return之后，消息依然会被ack而不是nack，还不如不设置madatory呢，因此return有时并不见得有用。&lt;/p&gt;
&lt;p&gt;需要注意的是，在发送消息时如果exchange不存在，rabbitmq直接丢弃该消息，并且不会ack或者nack操作，但是在Spring中，会nack。&lt;/p&gt;
&lt;p&gt;综合起来，要完成发送方确认，需要做以下几个点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置ConfirmListener&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;confirmSelect()&lt;/code&gt;开启&lt;/li&gt;
&lt;li&gt;为exchange设置&lt;code&gt;alternate-exchange&lt;/code&gt;到DLX&lt;/li&gt;
&lt;li&gt;发送时没有必要设置mandotory&lt;/li&gt;
&lt;li&gt;发送方将消息记录在数据库中，收到ack时在数据库中标记消息为&lt;code&gt;已发送&lt;/code&gt;状态&lt;/li&gt;
&lt;li&gt;如果收到reject或者由于网络原因没有收到ack，那么消息状态不会改变，下次发送时再次发送，此时可能导致消息重复，解决重复问题请参考“保证至少一次投递，并且消费端幂”小节。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;手动消费确认&quot;&gt;手动消费确认&lt;/h3&gt;
&lt;p&gt;有时，消息被正确投递到消费方，但是消费方处理失败，那么便会出现消费方的不一致问题。比如&lt;code&gt;订单已创建&lt;/code&gt;的消息发送到用户积分子系统中用于增加用户积分，但是积分消费法处理却都失败了，用户就会问：我购买了东西为什么积分并没有增加呢？&lt;/p&gt;
&lt;p&gt;要解决这个问题，需要引入消费方确认，即只有消息被成功处理之后才告知rabbitmq以ack，否则告知rabbitmq以nack，此时的处理流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;接收消息，不作ack，处理消息成功则ack，不成功nack&lt;/li&gt;
&lt;li&gt;对于nack的消息，可以配置rabbitmq要么重新投递，要么直接扔掉，要么传到死信交换（DLX）&lt;/li&gt;
&lt;li&gt;如果处理成功，但是由于网络等问题导致确认（无论是ack还是nack）不成功，那么rabbitmq会重新投递消息，但是此时由于消息已经成功，重新投递便导致了消费重复的消息，此时请参考“保证至少一次投递，并且消费端幂”小节。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在rabbitmq中，消息默认是字段ack的，即消息到达消费方立即ack，而不管消费方业务处理是否成功，为此可以开启手动确认模式，即有消费方自行决定何时应该ack，通过设置&lt;code&gt;autoAck=false&lt;/code&gt;开启手动确认模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        boolean autoAck = false;
        channel.basicConsume(&quot;order-summary-queue&quot;, autoAck,
                new DefaultConsumer(channel) {
                    @Override
                    public void handleDelivery(String consumerTag,
                                               Envelope envelope,
                                               AMQP.BasicProperties properties,
                                               byte[] body)
                            throws IOException {
                        long deliveryTag = envelope.getDeliveryTag();
                        if (success()) {
                            logger.info(&quot;成功消费消息&quot; + deliveryTag);
                            channel.basicAck(deliveryTag, false);
                        } else {
                            if (!envelope.isRedeliver()) {
                                logger.warn(&quot;首次消费消息&quot; + deliveryTag + &quot;不成功，尝试重试&quot;);
                                boolean requeue = true;
                                channel.basicNack(deliveryTag, false, requeue);
                            } else {
                                logger.warn(&quot;第二次消费消息&quot; + deliveryTag + &quot;不成功，扔到DLX&quot;);
                                boolean requeue = false;
                                channel.basicNack(deliveryTag, false, requeue);
                            }
                        }
                    }
                });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在&lt;code&gt;autoAck=false&lt;/code&gt;情况下，通过业务处理的是否成功(&lt;code&gt;success()&lt;/code&gt;)来判断应该ack还是nack。&lt;/p&gt;
&lt;p&gt;另外，为了避免消息反复requeue的情况，如果消息第一次消费不成功，则在nack时设置&lt;code&gt;requeue=true&lt;/code&gt;，表示告知rabbitmq将reject的消息重新投递，如果第二次消费依然不成功，那么nack时设置&lt;code&gt;requeue=false&lt;/code&gt;，告知rabbitmq不要重新投递了，此时rabbitmq将根据自己的配置要么直接扔掉消息，要么将消息发送到DLX中，具体配置请参考“设置死信交换（DLX）和死信队列（DLQ）”。&lt;/p&gt;
&lt;h3 id=&quot;保证至少一次投递并且消费端幂等&quot;&gt;保证至少一次投递，并且消费端幂等&lt;/h3&gt;
&lt;p&gt;通常来说，程序中会先完成写数据库的操作，然后发送消息，此时一个重要的点是保证这两者的一致性，即一旦数据库保存成功消息必须也能够发送成功。要保证发送发一致性，一种做法是使用全局事务，即将数据库操作和消息发送放到一个事务中，比如JTA，但是全局事务是很重的，并且rabbitmq目前并不支持全局事务。&lt;/p&gt;
&lt;p&gt;要解决发送发的一致性问题，可以实现将消息保存到数据库的事件表中，此时业务处理的数据库操作和保存消息到数据库属于同一个本地数据库事务，那么到此可以保证业务处理和消息产生的原子性，然后有一个异步的后台任务从数据库的事件表中一次读取未发送的消息发送至rabbitmq，发送成功后更新消息的状态为&lt;code&gt;已发布&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然而，此时我们依然无法保证发送消息和更新消息状态之间的原子性，因为可能发生消息发送成功但是数据库状态更新不成功的情况，为了解决这种极端情况，可以多次重试消息发送，步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;读取时间表中未发送消息，发送到rabbitmq&lt;/li&gt;
&lt;li&gt;如果发送成功，事件表中消息状态也更新成功，皆大欢喜&lt;/li&gt;
&lt;li&gt;如果消息发送不成功，那么消息状态也不作改变，下次重试&lt;/li&gt;
&lt;li&gt;如果消息发送成功而状态更新不成功，下次重试&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不断重试，总有一个能够达到发送消息和状态更新的原子性。&lt;/p&gt;
&lt;p&gt;那么问题也来了：rabbitmq中可能出现多条重复消息，此时消费端就懵了。为了解决这个问题，消费方应该设计为幂等的，即对相同消息的多次消费与单次消费结果相同。有些消费方的业务逻辑本身便是幂等的，而对于本身不幂等的消费方，需要在数据库中记录已经被正确消费的消息，当重复消息来时，判断该消息是否已经被消费，如果没有则执行消费逻辑，如果已经消费则直接忽略。此时消费方的处理步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;接收到消息，判断消息是否已经消费，如果是，则直接忽略，此时已然需要做消费成功确认&lt;/li&gt;
&lt;li&gt;如果消息还未被消费，则处理业务逻辑，记录消息，业务逻辑本身和记录消息在同一个数据库事务中，如果都成功，则皆大欢喜；如果失败，那么消费方业务回滚，消息也不记录，此时reject消息，等下次重发&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;设置消息的ttl和消息队列的max-length&quot;&gt;设置消息的TTL和消息队列的max-length&lt;/h3&gt;
&lt;p&gt;为了保证消息的时效性，可以设置队列中消息的TTL(&lt;code&gt;x-message-ttl&lt;/code&gt;)，而为了保证消息队列不至于太大而影响性能，可以设置队列的最大消息数(&lt;code&gt;x-max-length&lt;/code&gt;)。在创建队列时设置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ImmutableMap&amp;lt;String, Object&amp;gt; orderSummaryQueueArguments = of(
                    &quot;x-max-length&quot;,
                    300,
                    &quot;x-message-ttl&quot;,
                    24 * 60 * 60 * 1000);
channel.queueDeclare(&quot;order-summary-queue&quot;, true, false, false, orderSummaryQueueArguments);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置死信交换dlx和死信队列dlq&quot;&gt;设置死信交换（DLX）和死信队列（DLQ）&lt;/h3&gt;
&lt;p&gt;对于无法投递的消息，我们需要将其记录下来便于后续跟踪排查，此时可以将这样的消息放入DLX和DLQ中。默认情况下，queue中被抛弃的消息将被直接丢掉，但是可以通过设置queue的&lt;code&gt;x-dead-letter-exchange&lt;/code&gt;参数，将被抛弃的消息发送到&lt;code&gt;x-dead-letter-exchange&lt;/code&gt;做指定的exchange中，这样的exchange成为DLX。&lt;/p&gt;
&lt;p&gt;设置了&lt;code&gt;x-dead-letter-exchange&lt;/code&gt;之后，在以下三种情况下消息将被扔到DLX中：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消费方nack时指定了&lt;code&gt;requeue=false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;消息的TTL已到&lt;/li&gt;
&lt;li&gt;消息队列的max-length已到&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在声明queue时定义&lt;code&gt;x-dead-letter-exchange&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ImmutableMap&amp;lt;String, Object&amp;gt; orderNotificationQueueArguments = of(&quot;x-dead-letter-exchange&quot;, &quot;dlx&quot;);
channel.queueDeclare(&quot;order-notification-queue&quot;, true, false, false, orderNotificationQueueArguments);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;设置DLQ为lazy，并且没有TTL，并且没有max-length&lt;br/&gt;在以下3种情况下，消息会被投递到DLX中：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意的是，在发送消息时，当已经达到queue的上限，而当queue定义为x-overflow=reject-publish时，rabbitmq将nack。当有多个queue同时绑定到exchange时，如果有些queue设置了reject-publish，而有些却没有，那么依然会nack，这对发送方来说不好处理。因此，还是那句话，发送方只需要保证正确地投递到了exchange即可，而不用关系exchange后面有哪些queue。&lt;/p&gt;
&lt;h3 id=&quot;设置prefetch-count&quot;&gt;设置Prefetch count&lt;/h3&gt;
&lt;p&gt;Prefetch count表示消费方一次性从rabbitmq读取的消息数量，如果设置过大，那么消费方可能始终处于高负荷运转状态，而如果太小又会增加网络开销，通常设置为20-50。另外，有时为了保证多个消费方均衡地分摊消息处理任务，通常设置prefetch count为1。&lt;/p&gt;
&lt;h3 id=&quot;异常处理&quot;&gt;异常处理&lt;/h3&gt;
&lt;p&gt;在以上设置的情况下，我们来看看当各种异常发生时，rabbitmq是如何运作的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;broker不可达：直接抛出异常；&lt;/li&gt;
&lt;li&gt;发送方自己始终发送不出去：消息状态始终处于“未发送”，不会破坏一致性，但是对于事件表中累计太多的事件需要关注；&lt;/li&gt;
&lt;li&gt;exchange不存在：消息被丢掉，rabbitmq不会ack，消息状态始终处于“未发送”，下次将重新发送，不会破坏一致性，但是当exchange持续不存在下去，那么事件表中事件也会累计太多；&lt;/li&gt;
&lt;li&gt;exchange存在但是没有接受queue：消息将被ack并标记为“已发送”，但由于设置了alternative exchange为dlx，那么消息将发送到dlx对应的dlq中保存以便后续处理；&lt;/li&gt;
&lt;li&gt;consumer不在线，而累积消息太多：消息一致性没有问题，但是当累计到了max-length上限，消息队列头部的消息将被放置dlq中以便后续处理；&lt;/li&gt;
&lt;li&gt;consumer临时性失败：通过redelivered判断是否为重复投递，如果是，则nack并且requeue=false，表示如果重复投递的一次的消息如果再失败，那么直接扔到dlx中，也即消息最多重复投递一次；&lt;/li&gt;
&lt;li&gt;consumer始终失败：所有消息均被投入dlq以便后续处理，此时可能需要关注dlq的长度是否太长。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;路由策略&quot;&gt;路由策略&lt;/h3&gt;
&lt;p&gt;系统中往往会发布多种类型的消息，在发送时有几种路由策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有类型的消息都发送到同一个exchange中&lt;/li&gt;
&lt;li&gt;每种类型的消息都单独配置一个exchange&lt;/li&gt;
&lt;li&gt;对消息类型进行归类，同一类型的消息对应一个exchange&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;笔者建议采用最后一种，并且结合DDD中的聚合划分，路由策略建议如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;每一个聚合根下发布的所有类型的事件对应一个exchange，exchange设置为topic，queue可以配置接收某一种类型的事件，也可以配置接收所有某种聚合相关的事件，还可以配置接收所有事件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;案例&quot;&gt;案例&lt;/h3&gt;
&lt;p&gt;假设有个订单(Order)系统，用户下单后需要向用户发送短信通知，而所有对订单的数据显示采用了CQRS架构，即将订单的读模型和写模型分离，即所有订单的更新都通过事件发到rabbitmq，然后专门有个consumer接收这些消息用于更新订单的读模型。&lt;/p&gt;
&lt;p&gt;订单相关有两个事件：order.created和order.updated，所有与订单相关的事件都发布到同一个 topic exchange中，exchange名为“order&quot;，设置短信通知queue（order-notification-queue）只接收order.created消息，因为只有订单在新建时才会发出通知，即order-notification-queue的routing key为&lt;code&gt;order.created&lt;/code&gt;，设置读模型的queue（order-summary-queue）接收所有与Order相关的消息，即配置order-summary-queue的routing key为&lt;code&gt;order.#&lt;/code&gt;，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.ecommerce.order.spike.rabbitmq;

import com.ecommerce.order.common.logging.AutoNamingLoggerFactory;
import com.google.common.collect.ImmutableMap;
import com.rabbitmq.client.*;
import org.slf4j.Logger;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

import static com.google.common.collect.ImmutableMap.of;
import static com.rabbitmq.client.BuiltinExchangeType.TOPIC;

public class RabbitMQSender {
    private static final Logger logger = AutoNamingLoggerFactory.getLogger();

    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;localhost&quot;);
        factory.setUsername(&quot;rabbitmq-user&quot;);
        factory.setPassword(&quot;rabbitmq-password&quot;);
        factory.setVirtualHost(&quot;/&quot;);
        factory.setPort(5672);

        try (Connection conn = factory.newConnection(); Channel channel = conn.createChannel();) {
            //设置死信交换,Topic类型，持久化
            channel.exchangeDeclare(&quot;dlx&quot;, TOPIC, true, false, null);

            //设置死信队列，持久化，lazy型
            channel.queueDeclare(&quot;dlq&quot;, true, false, false, of(&quot;x-queue-mode&quot;, &quot;lazy&quot;));

            //接收所有发给dlx的消息，另外可以定义其他queue接收指定类型的消息
            channel.queueBind(&quot;dlq&quot;, &quot;dlx&quot;, &quot;#&quot;);


            //定义与order相关的事件exchange，如果无法路由，则路由到死信交换dlx
            channel.exchangeDeclare(&quot;order&quot;, TOPIC, true, false, of(&quot;alternate-exchange&quot;, &quot;dlx&quot;));


            //定义用于异步更新order读模型的queue，设置死信交换为dlx，队列满(x-overflow)时将头部消息发到dlx
            //定义queue的最大消息数(x-max-length)为300，满后发到dlx，另外定义消息的存活时间(x-message-ttl)为1天，1天后发送到dlx
            ImmutableMap&amp;lt;String, Object&amp;gt; orderSummaryQueueArguments = of(&quot;x-dead-letter-exchange&quot;,
                    &quot;dlx&quot;,
                    &quot;x-overflow&quot;,
                    &quot;drop-head&quot;,
                    &quot;x-max-length&quot;,
                    300,
                    &quot;x-message-ttl&quot;,
                    24 * 60 * 60 * 1000);
            channel.queueDeclare(&quot;order-summary-queue&quot;, true, false, false, orderSummaryQueueArguments);
            channel.queueBind(&quot;order-summary-queue&quot;, &quot;order&quot;, &quot;order.#&quot;);


            //定义用于order创建时向用户发出通知的queue，设置死信交换为dlx
            ImmutableMap&amp;lt;String, Object&amp;gt; orderNotificationQueueArguments = of(&quot;x-dead-letter-exchange&quot;,
                    &quot;dlx&quot;,
                    &quot;x-overflow&quot;,
                    &quot;drop-head&quot;,
                    &quot;x-max-length&quot;,
                    300,
                    &quot;x-message-ttl&quot;,
                    24 * 60 * 60 * 1000);
            channel.queueDeclare(&quot;order-notification-queue&quot;, true, false, false, orderNotificationQueueArguments);
            channel.queueBind(&quot;order-notification-queue&quot;, &quot;order&quot;, &quot;order.created&quot;);


            //设置发送端确认
            channel.addConfirmListener(new ConfirmListener() {
                public void handleAck(long seqNo, boolean multiple) {
                    if (multiple) {
                        logger.info(seqNo + &quot;号及其以前的所有消息发送成功，当消息发送成功后执行相应逻辑，比如标记事件为已发送或者删除原来事件&quot;);
                    } else {
                        logger.info(seqNo + &quot;号发送成功，当消息发送成功后执行相应逻辑，比如标记事件为已发送或者删除原来事件&quot;);

                    }
                }

                public void handleNack(long seqNo, boolean multiple) {
                    if (multiple) {
                        logger.info(seqNo + &quot;号及其以前的所有消息发送失败，当消息发送失败后执行相应逻辑，比如重试或者标记事件发送失败&quot;);
                    } else {
                        logger.info(seqNo + &quot;号发送失败，当消息发送失败后执行相应逻辑，比如重试或者标记事件发送失败&quot;);

                    }
                }
            });

            //开启发送者确认
            channel.confirmSelect();

            //设置消息持久化
            AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
                    .contentType(&quot;application/json&quot;)
                    .deliveryMode(2)
                    .priority(0)
                    .build();


            //发送时没有必要设置mandatory，因为无法路由的消息会记录在dlq中
            //达到queue的上限时，queue头部消息将被放入dlx中
            try {
                channel.basicPublish(&quot;order&quot;, &quot;order.created&quot;, false, properties, &quot;create order data&quot;.getBytes());
                channel.basicPublish(&quot;order&quot;, &quot;order.updated&quot;, false, properties, &quot;update order data&quot;.getBytes());
            } catch (IOException e) {
                e.printStackTrace();
            }
            Thread.sleep(5000);
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上，我们发送了一条order.created消息和一条order.updated消息，基于routing key设置，两条消息都会到达order-summary-queue，但是只有order.created消息到达了order-notification-queue：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5262621-37fecb7ede68e741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;所有消息都到达了order-summary-queue，但是只有order.created消息到达了order-notification-queue&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在consumer端，开启手动ack，并且对于处理失败的场景，只允许重新投递一次，否则扔到DLX中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.ecommerce.order.spike.rabbitmq;

import com.ecommerce.order.common.logging.AutoNamingLoggerFactory;
import com.rabbitmq.client.*;
import org.slf4j.Logger;

import java.io.IOException;
import java.util.Random;
import java.util.concurrent.TimeoutException;

public class RabbitMQReceiver {
    private static final Logger logger = AutoNamingLoggerFactory.getLogger();

    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException {
        ConnectionFactory factory = new ConnectionFactory();
        factory.setHost(&quot;localhost&quot;);
        factory.setUsername(&quot;rabbitmq-user&quot;);
        factory.setPassword(&quot;rabbitmq-password&quot;);
        factory.setVirtualHost(&quot;/&quot;);
        factory.setPort(5672);

        Connection conn = factory.newConnection();
        Channel channel = conn.createChannel();
        channel.basicQos(1, true);

        boolean autoAck = false;
        channel.basicConsume(&quot;order-summary-queue&quot;, autoAck,
                new DefaultConsumer(channel) {
                    @Override
                    public void handleDelivery(String consumerTag,
                                               Envelope envelope,
                                               AMQP.BasicProperties properties,
                                               byte[] body)
                            throws IOException {
                        long deliveryTag = envelope.getDeliveryTag();

                        //用Random来模拟有时处理成功有时处理失败的场景
                        if (new Random().nextBoolean()) {
                            logger.info(&quot;成功消费消息&quot; + deliveryTag);
                            channel.basicAck(deliveryTag, false);
                        } else {
                            if (!envelope.isRedeliver()) {
                                logger.warn(&quot;首次消费消息&quot; + deliveryTag + &quot;不成功，尝试重试&quot;);
                                channel.basicNack(deliveryTag, false, true);
                            } else {
                                logger.warn(&quot;第二次消费消息&quot; + deliveryTag + &quot;不成功，扔到DLX&quot;);
                                channel.basicNack(deliveryTag, false, false);
                            }
                        }
                    }
                });
    }
}

&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 21 May 2019 14:11:00 +0000</pubDate>
<dc:creator>无知者云</dc:creator>
<og:description>在使用消息机制时，我们通常需要考虑以下几个问题: 消息不能丢失 保证消息一定能投递到目的地 保证业务处理和消息发送/消费的一致性 本文以RabbitMQ为例，讨论如何解决以上问题。 消息持久化 如果希</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/davenkin/p/rabbitmq-best-practices.html</dc:identifier>
</item>
<item>
<title>Android 从零编写一个带标签 TagTextView - 南尘</title>
<link>http://www.cnblogs.com/liushilin/p/10902454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liushilin/p/10902454.html</guid>
<description>&lt;p&gt;最近公司的项目升级到了 9.x，随之而来的就是一大波的更新，其中有个比较明显的改变就是很多板块都出了一个带标签的设计图，如下：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-5e4b79ae3fc5da00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-28c02d01fb147887.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;怎么实现&quot;&gt;怎么实现&lt;/h3&gt;
&lt;p&gt;看到这个，大多数小伙伴都能想到这就是一个简单的图文混排，不由得会想到鸿洋大佬的图文并排控件 &lt;a href=&quot;https://github.com/hongyangAndroid/MixtureTextView&quot;&gt;MixtureTextView&lt;/a&gt;，或者自己写一个也不麻烦，只需要利用 shape 背景文件结合 &lt;code&gt;SpannableString&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;确实如此，利用 &lt;code&gt;SpannableString&lt;/code&gt; 确实是最方便快捷的方式，但稍不注意这里可能会踩坑。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;private fun convertViewToBitmap(view: View): Bitmap {
    view.isDrawingCacheEnabled = true
    view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED))
    view.layout(0, 0, view.measuredWidth, view.measuredHeight)
    view.buildDrawingCache()
    val bitmap = view.drawingCache
    view.isDrawingCacheEnabled = false
    view.destroyDrawingCache()
    return bitmap
}

fun setTagText(style: Int, content: String) {
    val view = LayoutInflater.from(context).inflate(R.layout.layout_codoon_tag_textview, null)
    val tagView = view.findViewById&amp;lt;CommonShapeButton&amp;gt;(R.id.tvName)
    val tag = when (style) {
        STYLE_NONE -&amp;gt; {
            &quot;&quot;
        }
        STYLE_CODOON -&amp;gt; {
            tagView.setStrokeColor(R.color.tag_color_codoon.toColorRes())
            tagView.setTextColor(R.color.tag_color_codoon.toColorRes())
            &quot;自营&quot;
        }
        STYLE_JD -&amp;gt; {
            tagView.setStrokeColor(R.color.tag_color_jd.toColorRes())
            tagView.setTextColor(R.color.tag_color_jd.toColorRes())
            &quot;京东&quot;
        }
        STYLE_TM -&amp;gt; {
            tagView.setStrokeColor(R.color.tag_color_tm.toColorRes())
            tagView.setTextColor(R.color.tag_color_tm.toColorRes())
            &quot;天猫&quot;
        }
        STYLE_PDD -&amp;gt; {
            tagView.setStrokeColor(R.color.tag_color_pdd.toColorRes())
            tagView.setTextColor(R.color.tag_color_pdd.toColorRes())
            &quot;拼多多&quot;
        }
        STYLE_TB -&amp;gt; {
            tagView.setStrokeColor(R.color.tag_color_tb.toColorRes())
            tagView.setTextColor(R.color.tag_color_tb.toColorRes())
            &quot;淘宝&quot;
        }
        else -&amp;gt; {
            &quot;&quot;
        }
    }
    val spannableString = SpannableString(&quot;$tag$content&quot;)
    val bitmap = convertViewToBitmap(view)
    val drawable = BitmapDrawable(resources, bitmap)
    drawable.setBounds(0, 0, tagView.width, tagView.height)
    spannableString.setSpan(CenterImageSpan(drawable), 0, tag.length, Spannable.SPAN_INCLUSIVE_INCLUSIVE)
    text = spannableString
    gravity = Gravity.CENTER_VERTICAL
}

companion object {
    const val STYLE_NONE = 0
    const val STYLE_JD = 1
    const val STYLE_TB = 2
    const val STYLE_CODOON = 3
    const val STYLE_PDD = 4
    const val STYLE_TM = 5
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;xml 文件的样式就不必在这里贴了，很简单，就是一个带 shape 背景的 TextView，不过由于 shape 文件的极难维护性，在我们的项目中统一采用的是自定义 View 来实现这些圆角等效果。&lt;/p&gt;
&lt;blockquote readability=&quot;1.7567567567568&quot;&gt;
&lt;p&gt;详细参考作者 blog：&lt;a href=&quot;https://xiaozhuanlan.com/topic/3205781694&quot;&gt;Android 项目中 shape 标签的整理和思考&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;圆角 shape 等效果不是我们在这里主要讨论的东西，我们来看这个代码，思路也是很清晰简洁：首先利用 &lt;code&gt;LayoutInflater&lt;/code&gt; 返回一个 &lt;code&gt;View&lt;/code&gt;，然后对这个 &lt;code&gt;View&lt;/code&gt; 经过一系列判断逻辑确认里面的显示文案和描边颜色等处理。然后通过 &lt;code&gt;View&lt;/code&gt; 的 &lt;code&gt;buildDrawingCache()&lt;/code&gt; 的方法生成一个 Bitmap 供 &lt;code&gt;SpannableString&lt;/code&gt; 使用，然后再把 &lt;code&gt;spannableString&lt;/code&gt; 设置给 &lt;code&gt;textView&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h3 id=&quot;一些注意点&quot;&gt;一些注意点&lt;/h3&gt;
&lt;p&gt;其中有个细节需要注意的是，利用 &lt;code&gt;LayoutInflater&lt;/code&gt; 生成的 &lt;code&gt;View&lt;/code&gt; 并没有经过 &lt;code&gt;measure()&lt;/code&gt; 和 &lt;code&gt;layout()&lt;/code&gt; 方法的洗礼，所以一定没对它的 &lt;code&gt;width&lt;/code&gt; 和 &lt;code&gt;height&lt;/code&gt; 等属性赋值。&lt;/p&gt;
&lt;p&gt;所以我们在 &lt;code&gt;buildDrawingCache()&lt;/code&gt; 前做了至关重要的两步操作：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED))
view.layout(0, 0, view.measuredWidth, view.measuredHeight)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从 &lt;code&gt;buildDrawingCache()&lt;/code&gt; 源码中我们可以看到，这个方法并不是一定会返回到正确的 &lt;code&gt;Bitmap&lt;/code&gt;，在我们的 &lt;code&gt;View&lt;/code&gt; 的 &lt;code&gt;CacheSize&lt;/code&gt; 大小超过了某写设备的默认值的时候，可能会返回 null。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;系统给我了我们的默认最大的 &lt;code&gt;DrawingCacheSize&lt;/code&gt; 为屏幕宽高乘积的 4 倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于我们这里的 View 是极小的，所以暂时没有出现返回 null 的情况。&lt;/p&gt;
&lt;p&gt;尽管上面的代码经过测试，基本上能在大部分机型上满足需求。但本着被标记 &lt;code&gt;@Deprecated&lt;/code&gt; 的过时方法，我们坚决不用的思想，我们需要对生成 &lt;code&gt;Bitmap&lt;/code&gt; 的方法进行小范围改造。&lt;/p&gt;
&lt;p&gt;在最新的 SDK 中，我们发现 &lt;code&gt;View&lt;/code&gt; 的 &lt;code&gt;buildDrawingCache()&lt;/code&gt; 等一系列方法都已经被标记了 &lt;code&gt;@Deprecated&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * &amp;lt;p&amp;gt;Calling this method is equivalent to calling &amp;lt;code&amp;gt;buildDrawingCache(false)&amp;lt;/code&amp;gt;.&amp;lt;/p&amp;gt;
 *
 * @see #buildDrawingCache(boolean)
 *
 * @deprecated The view drawing cache was largely made obsolete with the introduction of
 * hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache
 * layers are largely unnecessary and can easily result in a net loss in performance due to the
 * cost of creating and updating the layer. In the rare cases where caching layers are useful,
 * such as for alpha animations, {@link #setLayerType(int, Paint)} handles this with hardware
 * rendering. For software-rendered snapshots of a small part of the View hierarchy or
 * individual Views it is recommended to create a {@link Canvas} from either a {@link Bitmap} or
 * {@link android.graphics.Picture} and call {@link #draw(Canvas)} on the View. However these
 * software-rendered usages are discouraged and have compatibility issues with hardware-only
 * rendering features such as {@link android.graphics.Bitmap.Config#HARDWARE Config.HARDWARE}
 * bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback
 * reports or unit testing the {@link PixelCopy} API is recommended.
 */
@Deprecated 
public void buildDrawingCache() {
    buildDrawingCache(false);
}       &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从官方注释中我们发现，&lt;strong&gt;使用视图渲染已经过时，硬件加速后中间缓存很多程度上都是不必要的，而且很容易导致性能的净损失。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以我们采用 &lt;code&gt;Canvas&lt;/code&gt; 进行简单改造一下：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;private fun convertViewToBitmap(view: View): Bitmap? {
    view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED))
    view.layout(0, 0, view.measuredWidth, view.measuredHeight)
    val bitmap = Bitmap.createBitmap(view.measuredWidth, view.measuredHeight, Bitmap.Config.ARGB_4444)
    val canvas = Canvas(bitmap)
    canvas.drawColor(Color.WHITE)
    view.draw(canvas)
    return bitmap
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;突如其来的崩溃&quot;&gt;突如其来的崩溃&lt;/h3&gt;
&lt;p&gt;perfect，但很不幸，在上 4.x 某手机上测试的时候，发生了一个空指针崩溃。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3994917-cdf2996bff53f732.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;一看日志，发现我们在执行 &lt;code&gt;view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED))&lt;/code&gt; 这句代码的时候抛出了系统层源码的 bug。&lt;/p&gt;
&lt;p&gt;进入源码发现在 &lt;code&gt;RelativeLayout&lt;/code&gt; 的 &lt;code&gt;onMeasure()&lt;/code&gt; 中有这样一段代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (isWrapContentWidth) {
    // Width already has left padding in it since it was calculated by looking at
    // the right of each child view
    width += mPaddingRight;

    if (mLayoutParams != null &amp;amp;&amp;amp; mLayoutParams.width &amp;gt;= 0) {
        width = Math.max(width, mLayoutParams.width);
    }

    width = Math.max(width, getSuggestedMinimumWidth());
    width = resolveSize(width, widthMeasureSpec);
    // ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来没有任何问题，但对比 4.3 的源码，发现了一点端倪。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if (mLayoutParams.width &amp;gt;= 0) {
      width = Math.max(width, mLayoutParams.width);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来空指针报的是这个 &lt;code&gt;layoutParams&lt;/code&gt;。&lt;br/&gt;再看看我们 &lt;code&gt;inflate()&lt;/code&gt; 的代码。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;val view = LayoutInflater.from(context).inflate(R.layout.layout_codoon_tag_textview, null)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对任何一位 Android 开发来讲，都是最熟悉的代码了，意思很简单，从 xml 中实例化 &lt;code&gt;View&lt;/code&gt; 视图，但是父视图为 null，所以从 xml 文件实例化的 &lt;code&gt;View&lt;/code&gt; 视图没办法 &lt;code&gt;attach&lt;/code&gt; 到 &lt;code&gt;View&lt;/code&gt; 层次树中，所以导致了 &lt;code&gt;layoutParams&lt;/code&gt; 这个参数为 null。&lt;br/&gt;既然找到了原因，那么解决方案也就非常简单了。&lt;br/&gt;只需要在 &lt;code&gt;inflate()&lt;/code&gt; 后，再设置一下 &lt;code&gt;params&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;view.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，基本已经实现，主要逻辑代码为：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;/**
 * 电商专用的 TagTextView
 * 后面可以拓展直接设置颜色和样式的其他风格
 *
 * Author: nanchen
 * Email: liusl@codoon.com
 * Date: 2019/5/7 10:43
 */
class CodoonTagTextView @JvmOverloads constructor(
        context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0
) : AppCompatTextView(context, attrs, defStyleAttr) {

    private var tagTvSize: Float = 0f

    init {
        val array = context.obtainStyledAttributes(attrs, R.styleable.CodoonTagTextView)
        val style = array.getInt(R.styleable.CodoonTagTextView_codoon_tag_style, 0)
        val content = array.getString(R.styleable.CodoonTagTextView_codoon_tag_content)
        tagTvSize = array.getDimension(R.styleable.CodoonTagTextView_codoon_tag_tv_size, 0f)
        content?.apply {
            setTagText(style, this)
        }
        array.recycle()
    }

    private fun convertViewToBitmap(view: View): Bitmap? {
//        view.isDrawingCacheEnabled = true
        view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED))
        view.layout(0, 0, view.measuredWidth, view.measuredHeight)
//        view.buildDrawingCache()
//        val bitmap = view.drawingCache
//        view.isDrawingCacheEnabled = false
//        view.destroyDrawingCache()
        val bitmap = Bitmap.createBitmap(view.measuredWidth, view.measuredHeight, Bitmap.Config.ARGB_4444)
        val canvas = Canvas(bitmap)
        canvas.drawColor(Color.WHITE)
        view.draw(canvas)
        return bitmap
    }

    fun setTagText(style: Int, content: String) {
        val view = LayoutInflater.from(context).inflate(R.layout.layout_codoon_tag_textview, null)
        view.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        val tagView = view.findViewById&amp;lt;CommonShapeButton&amp;gt;(R.id.tvName)
        val tag = when (style) {
            STYLE_NONE -&amp;gt; {
                &quot;&quot;
            }
            STYLE_CODOON -&amp;gt; {
                tagView.setStrokeColor(R.color.tag_color_codoon.toColorRes())
                tagView.setTextColor(R.color.tag_color_codoon.toColorRes())
                &quot;自营&quot;
            }
            STYLE_JD -&amp;gt; {
                tagView.setStrokeColor(R.color.tag_color_jd.toColorRes())
                tagView.setTextColor(R.color.tag_color_jd.toColorRes())
                &quot;京东&quot;
            }
            STYLE_TM -&amp;gt; {
                tagView.setStrokeColor(R.color.tag_color_tm.toColorRes())
                tagView.setTextColor(R.color.tag_color_tm.toColorRes())
                &quot;天猫&quot;
            }
            STYLE_PDD -&amp;gt; {
                tagView.setStrokeColor(R.color.tag_color_pdd.toColorRes())
                tagView.setTextColor(R.color.tag_color_pdd.toColorRes())
                &quot;拼多多&quot;
            }
            STYLE_TB -&amp;gt; {
                tagView.setStrokeColor(R.color.tag_color_tb.toColorRes())
                tagView.setTextColor(R.color.tag_color_tb.toColorRes())
                &quot;淘宝&quot;
            }
            else -&amp;gt; {
                &quot;&quot;
            }
        }
        if (tag.isNotEmpty()) {
            tagView.text = tag
            if (tagTvSize != 0f) {
                tagView.textSize = tagTvSize.toDpF()
            }
//            if (tagHeight != 0f) {
//                val params = tagView.layoutParams
//                params.height = tagHeight.toInt()
//                tagView.layoutParams = params
//            }
        }
        val spannableString = SpannableString(&quot;$tag$content&quot;)
        val bitmap = convertViewToBitmap(view)
        bitmap?.apply {
            val drawable = BitmapDrawable(resources, bitmap)
            drawable.setBounds(0, 0, tagView.width, tagView.height)
            spannableString.setSpan(CenterImageSpan(drawable), 0, tag.length, Spannable.SPAN_INCLUSIVE_INCLUSIVE)
        }
        text = spannableString
        gravity = Gravity.CENTER_VERTICAL
    }

    companion object {
        const val STYLE_NONE = 0    // 不加
        const val STYLE_JD = 1      // 京东
        const val STYLE_TB = 2      // 淘宝
        const val STYLE_CODOON = 3  // 自营
        const val STYLE_PDD = 4     // 拼多多
        const val STYLE_TM = 5      // 天猫
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 21 May 2019 13:23:00 +0000</pubDate>
<dc:creator>南尘</dc:creator>
<og:description>最近公司的项目升级到了 9.x，随之而来的就是一大波的更新，其中有个比较明显的改变就是很多板块都出了一个带标签的设计图，如下： 怎么实现 看到这个，大多数小伙伴都能想到这就是一个简单的图文混排，不由得</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liushilin/p/10902454.html</dc:identifier>
</item>
<item>
<title>[Inside HotSpot] Serial垃圾回收器Full GC - kelthuzadx</title>
<link>http://www.cnblogs.com/kelthuzadx/p/10902388.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kelthuzadx/p/10902388.html</guid>
<description>&lt;h2 id=&quot;serial垃圾回收器full-gc&quot;&gt;0. Serial垃圾回收器Full GC&lt;/h2&gt;
&lt;p&gt;Serial垃圾回收器的Full GC使用标记-压缩(Mark-Compact)进行垃圾回收，该算法基于Donald E. Knuth提出的Lisp2算法，它会把所有存活对象滑动到空间的一端，所以也叫sliding compact。Full GC始于&lt;code&gt;gc/serial/tenuredGeneration&lt;/code&gt;的TenuredGeneration::collect，它会在GC前后记录一些日志，真正的标记压缩算法发生在GenMarkSweep::invoke_at_safepoint，我们可以使用&lt;code&gt;-Xlog:gc*&lt;/code&gt;得到该算法的流程：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt; Heap address: 0x00000000f9c00000, size: 100 MB, Compressed Oops mode: 32-bit
 GC(0) Pause Young (Allocation Failure)
 GC(1) Pause Full (Allocation Failure)
 GC(1) Phase 1: Mark live objects
 GC(1) Phase 1: Mark live objects 1.136ms
 GC(1) Phase 2: Compute new object addresses
 GC(1) Phase 2: Compute new object addresses 0.170ms
 GC(1) Phase 3: Adjust pointers
 GC(1) Phase 3: Adjust pointers 0.435ms
 GC(1) Phase 4: Move objects
 GC(1) Phase 4: Move objects 0.208ms
 GC(1) Pause Full (Allocation Failure) 40M-&amp;gt;0M(96M) 2.102ms
 GC(0) DefNew: 2621K-&amp;gt;0K(36864K)
 GC(0) Tenured: 40960K-&amp;gt;795K(61440K)
 GC(0) Metaspace: 562K-&amp;gt;562K(1056768K)
 GC(0) Pause Young (Allocation Failure) 42M-&amp;gt;0M(96M) 3.711ms
 GC(0) User=0.00s Sys=0.00s Real=0.00s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;标记-压缩分为四个阶段（如果是fastdebug版jvm，可以使用&lt;code&gt;-Xlog:gc*=trace&lt;/code&gt;得到更为详细的日志，不过可能详细过头了...），这篇文章将围绕四个阶段展开。&lt;/p&gt;
&lt;h2 id=&quot;阶段1标记存活对象&quot;&gt;1. 阶段1：标记存活对象&lt;/h2&gt;
&lt;p&gt;第一阶段对应GC日志的&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt; GC(1) Phase 1: Mark live objects&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JVM在&lt;code&gt;process_string_table_roots()&lt;/code&gt;和&lt;code&gt;process_roots()&lt;/code&gt;中会遍历所有类型的GC Root，然后使用&lt;code&gt;XX::oops_do(root_closure)&lt;/code&gt;从该GC Root出发标记所有存活对象。&lt;code&gt;XX&lt;/code&gt;表示GC Root类型，&lt;code&gt;root_closure&lt;/code&gt;表示&lt;strong&gt;标记存活对象&lt;/strong&gt;的方法(闭包)。GC模块有很多闭包(closure)，它们代表的是一段代码、一种行为。root_closure就是一个&lt;code&gt;MarkSweep::FollowRootClosure&lt;/code&gt;闭包。这个闭包很强大，给它一个对象，就能标记这个对象，迭代标记对象的成员，以及对象所在的栈的所有对象及其成员：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// hotspot\share\gc\serial\markSweep.cpp
void MarkSweep::FollowRootClosure::do_oop(oop* p)       { follow_root(p); }

template &amp;lt;class T&amp;gt; inline void MarkSweep::follow_root(T* p) {
  // 如果引用指向的对象不为空且未标记
  T heap_oop = RawAccess&amp;lt;&amp;gt;::oop_load(p);
  if (!CompressedOops::is_null(heap_oop)) {
    oop obj = CompressedOops::decode_not_null(heap_oop);
    if (!obj-&amp;gt;mark_raw()-&amp;gt;is_marked()) {
      mark_object(obj);   // 标记对象
      follow_object(obj); // 标记对象的成员 
    }
  }
  follow_stack();       // 标记引用所在栈
}

// 如果对象是数组对象则标记数组，否则标记对象的成员
inline void MarkSweep::follow_object(oop obj) {
  if (obj-&amp;gt;is_objArray()) {
    MarkSweep::follow_array((objArrayOop)obj);
  } else {
    obj-&amp;gt;oop_iterate(&amp;amp;mark_and_push_closure);
  }
}

// 标记引用所在的整个栈
void MarkSweep::follow_stack() {
  do {
    // 如果待标记栈不为空则逐个标记
    while (!_marking_stack.is_empty()) {
      oop obj = _marking_stack.pop();
      follow_object(obj);
    }
    // 如果对象数组栈不为空则逐个标记
    if (!_objarray_stack.is_empty()) {
      ObjArrayTask task = _objarray_stack.pop();
      follow_array_chunk(objArrayOop(task.obj()), task.index());
    }
  } while (!_marking_stack.is_empty() || !_objarray_stack.is_empty());
}

// 标记数组的类型的Class和数组成员，比如String[] p = new String[2]
// 对p标记会同时标记java.lang.Class，p[1],p[2]
inline void MarkSweep::follow_array(objArrayOop array) {
  MarkSweep::follow_klass(array-&amp;gt;klass());
  if (array-&amp;gt;length() &amp;gt; 0) {
    MarkSweep::push_objarray(array, 0);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190521210730121-2048306145.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190521210738451-1103426347.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然走到这里了不如看看JVM是如何标记对象的：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;inline void MarkSweep::mark_object(oop obj) {
  // 获取对象的mark word
  markOop mark = obj-&amp;gt;mark_raw();
  // 设置gc标记
  obj-&amp;gt;set_mark_raw(markOopDesc::prototype()-&amp;gt;set_marked());
  // 垃圾回收器视情况保留对象的gc标志
  if (mark-&amp;gt;must_be_preserved(obj)) {
    preserve_mark(obj, mark);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对象的mark work有32bits或者64bits，取决于CPU架构和UseCompressedOops：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// hotspot\share\oops\markOop.hpp
32 位mark lword：
          hash:25 ------------&amp;gt;| age:4    biased_lock:1 lock:2 (normal object)
          JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
          size:32 ------------------------------------------&amp;gt;| (CMS free block)
          PromotedObject*:29 ----------&amp;gt;| promo_bits:3 -----&amp;gt;| (CMS promoted object)

最后的lock2位有不同含义：
          [ptr             | 00]  locked             ptr指向栈上真正的对象头
          [header      | 0 | 01]  unlocked           普通对象头
          [ptr             | 10]  monitor            膨胀锁
          [ptr             | 11]  marked             GC标记&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来垃圾回收的标记就是对每个对象mark word最后两位置为11，可是如果最后两位用于其他用途怎么办？比如这个对象的最后两位表示膨胀锁，那GC就不能对它进行标记了，所以垃圾回收器还需要视情况在额外区域保留对象的mark word（PreservedMark）。回到之前的话题，GC Root有很多，有的是我们耳熟能详的，有的则是略微少见：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有已加载的类(&lt;code&gt;ClassLoaderDataGraph::roots_cld_do&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;所有Java线程当前栈帧的引用和虚拟机内部线程(&lt;code&gt;Threads::possibly_parallel_oops_do&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;JVM内部使用的引用(&lt;code&gt;Universe::oopds_do&lt;/code&gt;和&lt;code&gt;SystemDictionary::oops_do&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;JNI handles(&lt;code&gt;JNIHandles::oops_do&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;所有synchronized锁住的对象引用(&lt;code&gt;ObjectSynchronizer::oops_do&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;java.lang.management对象(&lt;code&gt;Management::oops_do&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;JVMTI导出(&lt;code&gt;JvmtiExport::oops_do&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;AOT代码的堆(&lt;code&gt;AOTLoader::oops_do&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;code cache(&lt;code&gt;CodeCache::blobs_do&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;String常量池(&lt;code&gt;StringTable::oops_do&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;它们都包含可进行标记的引用，会视情况进行单线程标记或者并发标记，JVM会使用CAS(Atomic::cmpxchg)自旋锁等待标记任务。如果任务全部完成，即标记线程和完成计数相等，就结束阻塞。&lt;/p&gt;
&lt;p&gt;当对象标记完成后jvm还会使用&lt;code&gt;ref_processor()-&amp;gt;process_discovered_references()&lt;/code&gt;对弱引用，软引用，虚引用，final引用根据他们的Java语义做特殊处理，不过与算法本身没有太大关系，有兴趣的请自行了解。&lt;/p&gt;
&lt;h2 id=&quot;阶段2计算对象新地址&quot;&gt;2. 阶段2：计算对象新地址&lt;/h2&gt;
&lt;p&gt;就算对象新地址的思想是：从地址空间开始扫描，如果cur_obj指针指向已经GC标记过的对象，则将该对象的新地址设置为compact_top，然后compact_top推进，cur_obj推进，直至cur_obj到达地址空间结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190521210802751-854205962.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计算新地址伪代码如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 扫描堆空间
while(cur_obj&amp;lt;space_end){
  if(cur_obj-&amp;gt;is_gc_marked()){
    // 如果cur_Obj当前指向已标记过的对象，就计算新的地址
    int object_size += cur_obj-&amp;gt;size();
    cur_obj-&amp;gt;new_address = compact_top;
    compact_top = cur_obj;
    cur_obj += object_size;
  }else{
    // 否则快速跳过未标记的连续空间
    while(cur_obj&amp;lt;space_end &amp;amp;&amp;amp;!cur_obj-&amp;gt;is_gc_marked()){
      cur_obj += cur_obj-&amp;gt;size();
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了上面的认识，对应到HotSpot实现也比较简单了。计算对象新地址的代码位于CompactibleSpace::scan_and_forward:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// hotspot\share\gc\shared\space.inline.hpp
template &amp;lt;class SpaceType&amp;gt;
inline void CompactibleSpace::scan_and_forward(SpaceType* space, CompactPoint* cp) {
  space-&amp;gt;set_compaction_top(space-&amp;gt;bottom());

  if (cp-&amp;gt;space == NULL) {
    cp-&amp;gt;space = cp-&amp;gt;gen-&amp;gt;first_compaction_space();
    cp-&amp;gt;threshold = cp-&amp;gt;space-&amp;gt;initialize_threshold();
    cp-&amp;gt;space-&amp;gt;set_compaction_top(cp-&amp;gt;space-&amp;gt;bottom());
  }
  // compact_top为对象新地址的起始
  HeapWord* compact_top = cp-&amp;gt;space-&amp;gt;compaction_top(); 
  DeadSpacer dead_spacer(space);
  //最后一个标记对象
  HeapWord*  end_of_live = space-&amp;gt;bottom(); 
  // 第一个未标记对象
  HeapWord*  first_dead = NULL;

  const intx interval = PrefetchScanIntervalInBytes;

  // 扫描指针
  HeapWord* cur_obj = space-&amp;gt;bottom();
  // 扫描终点
  HeapWord* scan_limit = space-&amp;gt;scan_limit();

  // 扫描老年代
  while (cur_obj &amp;lt; scan_limit) {
    // 如果cur_obj指向已标记对象
    if (space-&amp;gt;scanned_block_is_obj(cur_obj) &amp;amp;&amp;amp; oop(cur_obj)-&amp;gt;is_gc_marked()) {
      Prefetch::write(cur_obj, interval);
      size_t size = space-&amp;gt;scanned_block_size(cur_obj);
      // 给cur_obj指向的对象设置新地址，并前移compact_top
      compact_top = cp-&amp;gt;space-&amp;gt;forward(oop(cur_obj), size, cp, compact_top);
      // cur_obj指针前移
      cur_obj += size;
      // 修改最后存活对象指针地址
      end_of_live = cur_obj;
    } else {
      // 如果cur_obj指向未标记对象，则获取这片（可能连续包含未标记对象的）空间的大小
      HeapWord* end = cur_obj;
      do {
        Prefetch::write(end, interval);
        end += space-&amp;gt;scanned_block_size(end);
      } while (end &amp;lt; scan_limit &amp;amp;&amp;amp; (!space-&amp;gt;scanned_block_is_obj(end) || !oop(end)-&amp;gt;is_gc_marked()));

      // 如果需要减少对象移动频率
      if (cur_obj == compact_top &amp;amp;&amp;amp; dead_spacer.insert_deadspace(cur_obj, end)) {
        oop obj = oop(cur_obj);
        compact_top = cp-&amp;gt;space-&amp;gt;forward(obj, obj-&amp;gt;size(), cp, compact_top);
        end_of_live = end;
      } else {
        // 否则跳过未存活对象
        *(HeapWord**)cur_obj = end;
        // 如果first_dead为空则将这片空间设置为第一个未存活对象
        if (first_dead == NULL) {
          first_dead = cur_obj;
        }
      }
      // cur_obj指针快速前移
      cur_obj = end;
    }
  }

  if (first_dead != NULL) {
    space-&amp;gt;_first_dead = first_dead;
  } else {
    space-&amp;gt;_first_dead = end_of_live;
  }
  cp-&amp;gt;space-&amp;gt;set_compaction_top(compact_top);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190521210820841-18403443.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190521210828296-1682148257.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190521210837597-380482165.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果对象需要移动，&lt;code&gt;cp-&amp;gt;space-&amp;gt;forward()&lt;/code&gt;会将新地址放入对象的mark word里面。计算对象新地址里面有个小技巧，比如当扫描到一片未存活对象的时候，它把第一个未存活对象设置为该片区域的结尾，这样下一次扫描到第一个对象可以直接跳到区域尾，节约时间。&lt;/p&gt;
&lt;h2 id=&quot;阶段3调整对象指针&quot;&gt;3. 阶段3：调整对象指针&lt;/h2&gt;
&lt;p&gt;第二阶段设置了所有对象的新地址，但是没有改变对象的相对地址和GC Root。比如GC Root指向对象A，B，C，这时候A、B、C都有新地址A',B',C'，GC Root应该相应调整为指向A',B',C':&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190521210851150-1802104594.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三阶段就是干这件事的。还记得第一阶段GC Root的标记行为吗？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;JVM在&lt;code&gt;process_string_table_roots()&lt;/code&gt;和&lt;code&gt;process_roots()&lt;/code&gt;中会遍历所有类型的GC Root，然后使用&lt;code&gt;XX::oops_do(root_closure)&lt;/code&gt;从该GC Root出发标记所有存活对象。&lt;code&gt;XX&lt;/code&gt;表示GC Root类型，&lt;code&gt;root_closure&lt;/code&gt;表示&lt;strong&gt;标记存活对象&lt;/strong&gt;的方法（闭包）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第三阶段和第一阶段一样，只是第一阶段传递的root_closure表示&lt;strong&gt;标记存活对象&lt;/strong&gt;的闭包(&lt;code&gt;FollowRootClosure&lt;/code&gt;)，第三阶段传递的root_closure表示&lt;strong&gt;调整对象指针&lt;/strong&gt;的闭包&lt;code&gt;AdjustPointerClosure&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// hotspot\share\gc\serial\markSweep.inline.hpp
inline void AdjustPointerClosure::do_oop(oop* p)       { do_oop_work(p); }
template &amp;lt;typename T&amp;gt;
void AdjustPointerClosure::do_oop_work(T* p)           { MarkSweep::adjust_pointer(p); }

template &amp;lt;class T&amp;gt; inline void MarkSweep::adjust_pointer(T* p) {
  T heap_oop = RawAccess&amp;lt;&amp;gt;::oop_load(p);
  if (!CompressedOops::is_null(heap_oop)) {
    // 从地址p处得到对象
    oop obj = CompressedOops::decode_not_null(heap_oop);
    // 从对象mark word中得到新对象地址
    oop new_obj = oop(obj-&amp;gt;mark_raw()-&amp;gt;decode_pointer());
    if (new_obj != NULL) {
      // 将地址p处设置为新对象地址
      RawAccess&amp;lt;IS_NOT_NULL&amp;gt;::oop_store(p, new_obj);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AdjustPointerClosure&lt;/code&gt;闭包会遍历所有GC Root然后调整对象指针，注意，这里和第一阶段有个重要不同是第一阶段传递的&lt;code&gt;FollowRootClosure&lt;/code&gt;闭包会从GC Root出发标记所有可达对象，但是&lt;code&gt;AdjustPointerClosure&lt;/code&gt;闭包只会标记GC Root出发直接可达的对象，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190521210909580-258251419.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从对象出发寻找可达其他对象这一步是使用的另一个闭包&lt;code&gt;GenAdjustPointersClosure&lt;/code&gt;，它会调用CompactibleSpace::scan_and_adjust_pointers遍历整个堆空间然后调整存活对象的指针：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//hotspot\share\gc\shared\space.inline.hpp
template &amp;lt;class SpaceType&amp;gt;
inline void CompactibleSpace::scan_and_adjust_pointers(SpaceType* space) {
  // 扫描指针
  HeapWord* cur_obj = space-&amp;gt;bottom();
  // 最后一个标记对象
  HeapWord* const end_of_live = space-&amp;gt;_end_of_live;
  // 第一个未标记对象
  HeapWord* const first_dead = space-&amp;gt;_first_dead; 
  const intx interval = PrefetchScanIntervalInBytes;

  // 扫描老年代
  while (cur_obj &amp;lt; end_of_live) {
    Prefetch::write(cur_obj, interval);
    // 如果扫描指针指向的对象是存活对象
    if (cur_obj &amp;lt; first_dead || oop(cur_obj)-&amp;gt;is_gc_marked()) {
      // 调整该对象指针，调整方法和AdjustPointerClosure所用一样
      size_t size = MarkSweep::adjust_pointers(oop(cur_obj));
      size = space-&amp;gt;adjust_obj_size(size);
      // 指针前移
      cur_obj += size;
    } else {
      // 否则扫描指针指向未存活对象，设置扫描指针为下一个存活对象，加速前移
      cur_obj = *(HeapWord**)cur_obj;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;阶段4移动对象&quot;&gt;4. 阶段4：移动对象&lt;/h2&gt;
&lt;p&gt;第四阶段传递&lt;code&gt;GenCompactClosure&lt;/code&gt;闭包，该闭包负责对象的移动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190521210922840-277699845.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;移动的代码位于CompactibleSpace::scan_and_compact：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//hotspot\share\gc\shared\space.inline.hpp
template &amp;lt;class SpaceType&amp;gt;
inline void CompactibleSpace::scan_and_compact(SpaceType* space) {
  verify_up_to_first_dead(space);
  // 老年代起始位置
  HeapWord* const bottom = space-&amp;gt;bottom();
  // 最后一个标记对象
  HeapWord* const end_of_live = space-&amp;gt;_end_of_live;

  // 如果该区域所有对象都存活，或者没有任何对象，或者没有任何存活对象
  // 就不需要进行移动
  if (space-&amp;gt;_first_dead == end_of_live &amp;amp;&amp;amp; (bottom == end_of_live || !oop(bottom)-&amp;gt;is_gc_marked())) {
    clear_empty_region(space);
    return;
  }

  const intx scan_interval = PrefetchScanIntervalInBytes;
  const intx copy_interval = PrefetchCopyIntervalInBytes;

  // 设置扫描指针cur_obj为空间底部
  HeapWord* cur_obj = bottom;
  // 跳到第一个存活的对象
  if (space-&amp;gt;_first_dead &amp;gt; cur_obj &amp;amp;&amp;amp; !oop(cur_obj)-&amp;gt;is_gc_marked()) {
    cur_obj = *(HeapWord**)(space-&amp;gt;_first_dead);
  }

  // 从空间开始到最后一个存活对象为截止进行扫描
  while (cur_obj &amp;lt; end_of_live) {
    // 如果cur_obj执行的对象未标记
    if (!oop(cur_obj)-&amp;gt;is_gc_marked()) {
      // 扫描指针快速移动至下一个存活的对象（死对象的第一个word
      // 存放了下一个存活对象的地址，这样就可以快速移动）
      cur_obj = *(HeapWord**)cur_obj;
    } else {
      Prefetch::read(cur_obj, scan_interval);

      size_t size = space-&amp;gt;obj_size(cur_obj);
      // 获取对象将要被移动到的新地址
      HeapWord* compaction_top = (HeapWord*)oop(cur_obj)-&amp;gt;forwardee();
      Prefetch::write(compaction_top, copy_interval);

      // 移动对象，并初始化对象的mark word
      Copy::aligned_conjoint_words(cur_obj, compaction_top, size);
      oop(compaction_top)-&amp;gt;init_mark_raw();

      // 扫描指针前移
      cur_obj += size;
    }
  }

  clear_empty_region(space);
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 21 May 2019 13:10:00 +0000</pubDate>
<dc:creator>kelthuzadx</dc:creator>
<og:description>0. Serial垃圾回收器Full GC Serial垃圾回收器的Full GC使用标记 压缩(Mark Compact)进行垃圾回收，该算法基于Donald E. Knuth提出的Lisp2算法，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kelthuzadx/p/10902388.html</dc:identifier>
</item>
<item>
<title>SQL Server 2016 + AlwaysOn 无域集群 - JervisCui</title>
<link>http://www.cnblogs.com/jerviscui/p/10895095.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerviscui/p/10895095.html</guid>
<description>&lt;p&gt;[========]&lt;/p&gt;
&lt;h2 id=&quot;alwayson&quot;&gt;AlwaysOn&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/sql/database-engine/availability-groups/windows/overview-of-always-on-availability-groups-sql-server?view=sql-server-2017&quot;&gt;AlwaysOn 可用性组概述 (SQL Server)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;搭建-wsfc&quot;&gt;搭建 WSFC&lt;/h3&gt;
&lt;h4 id=&quot;配置计算机的-dns-后缀&quot;&gt;配置计算机的 DNS 后缀&lt;/h4&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置计算机的 DNS 后缀，注意在同个工作组&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201325241-1015708050.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201342557-1260845058.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201353602-421219425.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201400441-448529152.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每个节点的机器都要做域名解析，修改 host 文件&lt;code&gt;C:\Windows\System32\drivers\etc&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201412771-1506612591.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;安装故障转移集群&quot;&gt;安装故障转移集群&lt;/h4&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;节点服务器添加&lt;strong&gt;故障转移群集&lt;/strong&gt;功能&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201451468-163572355.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待安装完成&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;验证集群&quot;&gt;验证集群&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;打开故障转移集群管理工具&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201525265-2036894827.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;点击验证配置&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201541883-1242236771.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;添加集群节点&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201558193-195235517.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;运行所有测试&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201610118-1458454382.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;可以点击查看验证报告，勾选&lt;strong&gt;立即使用经过验证的节点创建集群&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201629704-772839886.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;创建集群&quot;&gt;创建集群&lt;/h4&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置集群的管理名称和管理IP&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201655286-1100486984.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待配置完成&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201709298-1828684967.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以查看集群报告，稍后配置文件共享见证&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;创建文件共享见证&quot;&gt;创建文件共享见证&lt;/h4&gt;
&lt;p&gt;由于我们是两个节点的故障转移集群，所以需要加上共享文件夹，如果是奇数节点，这一步是不需要做的！&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置集群仲裁&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201807763-560940966.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;选择文件共享见证&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201824112-622819878.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201850084-1076701858.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在集群节点之外的一台服务器上创建共享文件夹&lt;code&gt;\\XIANGMU4TEST01\share&lt;/code&gt;，并设置 Everyone 完全控制的权限&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;配置-alwayson&quot;&gt;配置 AlwaysOn&lt;/h3&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;开启 AlwaysOn&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201926748-422278196.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521201943731-40546096.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;需要重启 SQL Server 服务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;检查，如果 AlwaysOn 启用成功，在服务器属性里可以看到启用HADR为True&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521202012224-77365938.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521202030162-941523340.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;查看各节点的投票数&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT * FROM  sys.dm_hadr_cluster_members;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521202047783-1930327119.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;查看 cluster&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT * FROM SYS.[dm_hadr_cluster]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521202107910-729495009.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;新建可用性组&quot;&gt;新建可用性组&lt;/h4&gt;
&lt;p&gt;但是既然节点没有加入AD，那么久不能用域认证，只能用证书认证，因此需要创建证书和端点。在配置可用性组前各节点进行证书认证信任。&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改 SQL 服务登陆账号为本机管理员账号&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521202910135-450783021.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521202919320-522212837.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;创建证书，两个节点都要创建证书，注意修改证书名称&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;--节点二：创建主密钥/证书，备份证书。
USE master;
GO
CREATE MASTER KEY ENCRYPTION BY PASSWORD = 'AAA111aaa';
GO
CREATE CERTIFICATE Cert_server228
WITH SUBJECT = 'Cert_server228',
START_DATE = '2017-01-01',EXPIRY_DATE = '2099-12-30';
GO
BACKUP CERTIFICATE Cert_server228
TO FILE = 'C:\Storage\Cert_server228.cer';
GO&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;备份证书的文件夹要先创建好，并且赋予权限&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将创建好的证书放到另一台节点服务器，并加入证书&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;--节点二：创建其他节点证书
USE master;
GO
CREATE CERTIFICATE Cert_server227
FROM FILE = 'C:\Storage\Cert_server227.cer';
GO&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;证书创建好后如下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521202951390-613583747.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;重新创建端点，授权账号设置为本机管理员账号，验证方式使用上面创建的证书&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;--节点：创建端点
CREATE ENDPOINT [testag_endpoint]
    AUTHORIZATION [POSTEST2-2016\Administrator]
    STATE=STARTED
    AS TCP (LISTENER_PORT = 5023, LISTENER_IP = ALL)
    FOR DATA_MIRRORING
    (ROLE = ALL,AUTHENTICATION = CERTIFICATE Cert_server228, ENCRYPTION = REQUIRED ALGORITHM AES)
GO&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果存在已有的端点，则需要将已有端点删除&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203033005-1931544777.png&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在主节点服务器操作新建可用性组。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203049739-818445202.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;设置可用性组名称，建议勾选数据库级别运行状况检测。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203105040-1777105700.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;在之前的 AlwaysOn 2012 和 2014 中，如果实例健康出现问题，将触发故障转移。如果有一个数据库有问题，只要实例OK，可用性组就不会故障转移。&lt;/li&gt;
&lt;li&gt;在 AlwaysOn 2016 中，勾选之后，不论是一个实例有问题，还是一个或多个数据库有问题，都会发生故障转移。&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;选择数据库，要求数据库已经进行了完整备份&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203129553-132365465.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;添加副本节点，并勾选自动故障转移，设置辅助副本为可读副本&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203234603-1317077651.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;将端点 URL 设置为 IP 方式，这里端点会显示为我们上面创建的端点，登陆账号为我们上面设置的账号&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203401816-456347963.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;“备份首选项”和“侦听器”不需要设置，保持默认就行，可用性侦听器我们后面再添加，可以直接点击“下一步”&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;数据同步这里建议使用&lt;strong&gt;完整的数据库和日志备份&lt;/strong&gt;的方式更方便，需要有一个共享文件夹，并且节点服务器要有相同的数据库文件目录结构&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;等待可用性组创建成功&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203534982-2105051714.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建成功后数据库状态显示为已同步&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203556746-306747600.png&quot;/&gt;&lt;br/&gt;故障转移集群会显示拥有一个群集角色&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203611734-1068450836.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203624572-270461480.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;显示面板可以查看集群信息&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203643041-1338057141.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;创建侦听器&quot;&gt;创建侦听器&lt;/h4&gt;
&lt;p&gt;一个侦听器包括虚拟IP地址、虚拟网络名称、端口号三个元素，一旦创建成功，虚拟网络名称会注册到DNS中，同时为可用性组资源添加IP地址资源和网络名称资源。用户就可以使用此名称来连接到可用性组中。&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;添加侦听器&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203740420-634299996.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择使用静态 IP&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203800984-1903803649.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建成功后，在故障转移集群管理器里的角色节点，可以看到客户端访问名称和 IP 地址&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203815344-301546518.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;连接数据库时使用侦听器的地址&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521203836702-332833665.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;可读副本的负载均衡&quot;&gt;可读副本的负载均衡&lt;/h3&gt;
&lt;p&gt;SQL Server 2016 支持多个只读副本负载分担只读操作。&lt;/p&gt;
&lt;p&gt;右键一个可用性副本可以查看副本的只读性设置：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521204539399-359636235.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;主角色中的连接&quot;&gt;主角色中的连接&lt;/h4&gt;
&lt;p&gt;主角色中支持的连接访问类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;允许所有连接（ALL）：主数据库同时允许读写连接和只读连接。这是主角色的默认行为。&lt;/li&gt;
&lt;li&gt;仅允许读/写连接（READ_WRITE）：允许 &lt;code&gt;ApplicationIntent=ReadWrite&lt;/code&gt; 或未设置连接条件的连接。不允许 &lt;code&gt;ApplicationIntent=ReadOnly&lt;/code&gt; 的连接。仅允许读写连接可帮助防止客户错误地将读意向工作负荷连接到主副本。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;修改脚本：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;USE [master]
GO
ALTER AVAILABILITY GROUP [posTestAg]
MODIFY REPLICA ON N'POSTEST1-2016\POSTEST' WITH (PRIMARY_ROLE(ALLOW_CONNECTIONS = READ_WRITE))
GO&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;可读辅助副本&quot;&gt;可读辅助副本&lt;/h4&gt;
&lt;p&gt;辅助角色支持的连接访问类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无连接（NO）：不允许任何用户连接。辅助数据库不可用于读访问。这是辅助角色中的默认行为。&lt;/li&gt;
&lt;li&gt;仅读意向连接（READ_ONLY）：辅助数据库仅接受连接参数 &lt;code&gt;ApplicationIntent=ReadOnly&lt;/code&gt; 的连接，其它的连接方式无法连接。&lt;/li&gt;
&lt;li&gt;允许任何只读连接（ALL）：辅助数据库全部可用于读访问连接。此选项允许较低版本的客户端进行连接。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;修改脚本：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;USE [master]
GO
ALTER AVAILABILITY GROUP [posTestAg]
MODIFY REPLICA ON N'POSTEST1-2016\POSTEST' WITH (SECONDARY_ROLE(ALLOW_CONNECTIONS = READ_ONLY))
GO&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;设置数据库实例监听端口&quot;&gt;设置数据库实例监听端口&lt;/h4&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Sql Server 配置管理工具找到数据库实例的网络配置，&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521204750036-1171134416.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;右键 TCP/IP，默认配置的是动态端口&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521204800118-184850753.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;这里修改为固定端口 1433&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521204824244-1550235176.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后需要重启 Sql Server 服务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;配置可用性组只读路由&quot;&gt;配置可用性组只读路由&lt;/h4&gt;
&lt;p&gt;执行下面 sql 获取可用性组名称：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select name,* from  sys.availability_groups&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行下面 sql 获取要配置的可用性副本名称（服务器实例）：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select replica_server_name,* from sys.availability_replicas&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;为可用性副本（服务器实例）配置只读路由 URL，路由地址可以填 IP 或者计算机名，端口填数据库实例绑定的 TCP/IP 端口。&lt;br/&gt;执行脚本：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;USE [master]
GO
ALTER AVAILABILITY GROUP [posTestAg]
MODIFY REPLICA ON N'POSTEST1-2016\POSTEST' WITH (SECONDARY_ROLE(READ_ONLY_ROUTING_URL = N'TCP://10.98.98.227:1433'))
GO
ALTER AVAILABILITY GROUP [posTestAg]
MODIFY REPLICA ON N'POSTEST2-2016\POSTEST' WITH (SECONDARY_ROLE(READ_ONLY_ROUTING_URL = N'TCP://10.98.98.228:1433'))
GO&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以右键可用性组选择属性，通过 UI 方式更改&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521204907028-168942071.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个自动转移副本配置只读路由列表&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;USE [master]
GO
ALTER AVAILABILITY GROUP [posTestAg]
MODIFY REPLICA ON
N'POSTEST1-2016\POSTEST' WITH
(PRIMARY_ROLE (READ_ONLY_ROUTING_LIST=(('POSTEST2-2016\POSTEST'),'POSTEST1-2016\POSTEST')));
GO
ALTER AVAILABILITY GROUP [posTestAg]
MODIFY REPLICA ON
N'POSTEST2-2016\POSTEST' WITH
(PRIMARY_ROLE (READ_ONLY_ROUTING_LIST=(('POSTEST1-2016\POSTEST'),'POSTEST2-2016\POSTEST')));
GO&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用“()”对只读路由列表进行分组，&lt;br/&gt;List 1: 'POSTEST1-2016\POSTEST'&lt;br/&gt;List 2: 'POSTEST2-2016\POSTEST'&lt;br/&gt;按如下方式工作：&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;路由到第一个列表中的副本，如果第一个列表存在多个副本，则对读取连接进行轮询分发。&lt;/li&gt;
&lt;li&gt;如果第一列表中任一副本不可用了，路由将继续到第一个列表中的其他可用副本。&lt;/li&gt;
&lt;li&gt;如果第一个列表中的所有副本都不可访问，将会路由到下一个列表&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果第一个列表中的任一副本可用，将会恢复路由到第一个列表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;测试只读路由效果，sqlcmd 使用 Readonly 指定为只读连接，&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;sqlcmd -S 10.98.98.231 -K Readonly -d test -Q &quot;select @@servername&quot; -e&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只读连接被连接到辅助副本&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521204943546-812438357.png&quot;/&gt;&lt;br/&gt;使用 SSMS 或者 EF 等需要在连接字符串设置参数&lt;code&gt;ApplicationIntent=ReadOnly&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/541263/201905/541263-20190521205004153-1311010582.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;br/&gt;想要使用辅助副本负载读操作，必须要在连接字符串中配置为只读连接，然后在程序中指定使用只读连接进行数据库读取操作，AlwaysOn 自身不能自动负载均衡。&lt;/p&gt;
&lt;h4 id=&quot;配置账号&quot;&gt;配置账号&lt;/h4&gt;
&lt;p&gt;为每个数据库节点配置登陆账号，然后通过监听器使用该账号登陆数据库。&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;主副本创建登陆账号 satest&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;查看主库上该账号的 sid 为库名&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT * FROM [test]..sysusers&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在副本数据库上创建对应账号，其中 sid对应的值是主库上所查到的sid的值&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE LOGIN [satest] WITH PASSWORD=N'xxxxxxx',
SID =0x99AD266AFD26F841B3E49EF9633B0D4B, DEFAULT_DATABASE=[test],
 CHECK_EXPIRATION=OFF, CHECK_POLICY=OFF&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用故障转移&quot;&gt;使用故障转移&lt;/h3&gt;
&lt;p&gt;建议使用 SSMS 中 AlwaysOn 进行手动故障转移。&lt;/p&gt;
</description>
<pubDate>Tue, 21 May 2019 12:53:00 +0000</pubDate>
<dc:creator>JervisCui</dc:creator>
<og:description>[TOC] [========] AlwaysOn 'AlwaysOn 可用性组概述 (SQL Server)' 搭建 WSFC 配置计算机的 DNS 后缀 1. 配置计算机的 DNS 后缀，注意在同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jerviscui/p/10895095.html</dc:identifier>
</item>
</channel>
</rss>