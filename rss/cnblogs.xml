<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Git-常用命令 - 玉树临枫</title>
<link>http://www.cnblogs.com/yuanfy008/p/10151936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanfy008/p/10151936.html</guid>
<description>&lt;p&gt;      记录下git常用使用的场景，方便以后查阅。如有疑问欢迎指出。&amp;lt;后续会持续更新&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201812/690169-20181220195847993-2043927254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Workspace：工作区&lt;/li&gt;
&lt;li&gt;Index / Stage：暂存区&lt;/li&gt;
&lt;li&gt;Repository：仓库区（或本地仓库）&lt;/li&gt;
&lt;li&gt;Remote：远程仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;git status&lt;/strong&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;显示当前分支变更的文件 &lt;span&gt;&lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如下案例， 绿色表示已经添加暂存区，红色的表示改动的文件。&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201901/690169-20190110225900638-1760637889.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;394&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;git log　&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;显示当前分支的提交日志（这里是分页显示所有日志所以并不推荐使用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;git log -n&lt;/strong&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;显示当前分支的前n条日志。&lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201901/690169-20190110230146749-1735739144.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;144&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;git log --stat -n&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;显示当前分支前n条的详细日志（包括显示修改的哪些文件）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;git diff fileName　&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;显示工作区和暂存区的差异&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;git show&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;显示最近的提交记录，可以指定commitID&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;git branch&lt;/strong&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;显示本地分支 &lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201901/690169-20190110225817117-1904793272.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;48&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;strong&gt;git branch -r &lt;/strong&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;显示远程分支 &lt;span&gt;&lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201901/690169-20190110230222632-1843073917.png&quot; alt=&quot;&quot; width=&quot;526&quot; height=&quot;69&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;&lt;strong&gt;git branch -a　&lt;/strong&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;显示本地分支和远程分支（应该知道怎么区分本地分支和远程分支） &lt;span&gt;&amp;lt;推荐&amp;gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201901/690169-20190110230304242-285459947.png&quot; alt=&quot;&quot; width=&quot;522&quot; height=&quot;96&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;strong&gt;git branch -d/-D [branchName]&lt;/strong&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;删除本地分支（不要连同-r一起使用，否则会删除远程的分支）   &lt;span&gt;&amp;lt;推荐&amp;gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意：不要在当前分支删除当前分支&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201901/690169-20190110231112311-941225889.png&quot; alt=&quot;&quot; width=&quot;536&quot; height=&quot;80&quot;/&gt;&lt;/p&gt;
&lt;p&gt;-D ：表示强制删除&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201901/690169-20190110231226588-258821782.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;47&quot;/&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;git branch -m / -M  oldBranche newBranche &lt;/strong&gt;&lt;/td&gt;
&lt;td&gt; 移动/重命名分支和相应的reflog。请注意-m 与 -M 的区别&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;strong&gt;git checkout &lt;/strong&gt;&lt;strong&gt;[branchName]&lt;/strong&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/td&gt;
&lt;td&gt;切换到指定分支名称（前提：分支名称要存在）&lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;git checkout -b &lt;/strong&gt;&lt;strong&gt;[branchName]&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;切换并创建本地分支 &lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;git merge  &lt;/strong&gt;&lt;strong&gt;[branchName]&lt;/strong&gt;&lt;/strong&gt;　　　&lt;/strong&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;合并指定分支到当前分支 &lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;git merge  &lt;/strong&gt;&lt;strong&gt;--abort　　&lt;/strong&gt;&lt;/strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;放弃本次合并（在合并未提交的情况下使用） &lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;git push origin --delete [branchName]&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;删除远程指定分支     &lt;span&gt;慎用&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;18.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;git add [file1] [file2]...&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;添加指定文件至暂存区， 文件之间用空格隔开。&lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;git add [dir]&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;添加指定目录至暂存区（包括目录下所有文件）。&lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;git add .　&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;添加当前目录所有变动的文件至暂存区。&lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;git checkout [file1]&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;恢复暂存区的指定文件到工作区 &lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td&gt;&lt;strong&gt;git reset [file]&lt;/strong&gt;&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;重置暂存区的指定文件，与上一次commit保持一致,但工作区保持不变&lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201901/690169-20190110233445289-1154846703.png&quot; alt=&quot;&quot; width=&quot;612&quot; height=&quot;200&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;pom.xml已经在暂存区了，接下reset它。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201901/690169-20190110233555668-624225541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再重新查看后发现重新回到工作区。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201901/690169-20190110233621667-1068445695.png&quot; alt=&quot;&quot; width=&quot;608&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt; git reset --hard [commit]&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt; 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 　　 &lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;git cherry-pick [commit]&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;选择一个commit，合并进当前分支(其实可以指定多个commitid)   &lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;git rm [file1] [file2]&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;删除工作区的文件，并且将这次删除存至暂存区中 &lt;span&gt; &amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;git mv [file-original] [file-renamed] &lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;改名文件，并且将这个改名放入暂存区&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;git commit -m [message]&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;提交文件到本地仓库区 &lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;git push [remote] [branch] &lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;上传本地分支到远程仓库 &lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;git pull   [remote] [branch]&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;拉取远程分支代码与本地分支合并  &lt;span&gt;&amp;lt;推荐&amp;gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 15:47:00 +0000</pubDate>
<dc:creator>玉树临枫</dc:creator>
<og:description>一 前言 记录下git常用使用的场景，方便以后查阅。如有疑问欢迎指出。&lt;后续会持续更新&gt; 二 git工作流程图 Workspace：工作区 Index / Stage：暂存区 Reposi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanfy008/p/10151936.html</dc:identifier>
</item>
<item>
<title>时序数据库InfluxDB - 正版乔</title>
<link>http://www.cnblogs.com/qiaohaoforever/p/10252952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiaohaoforever/p/10252952.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在系统服务部署过后，线上运行服务的稳定性是系统好坏的重要体现，监控系统状态至关重要，经过调研了解，时序数据库influxDB在此方面表现优异。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;influxDB介绍&lt;/h3&gt;
&lt;p&gt;时间序列数据是以时间字段为每行数据的标示，比如股票市场的价格，环境中的温度，主机的CPU使用率等。但是又有什么数据是不包含timestamp的呢？几乎所有的数据都可以打上一个timestamp字段。时间序列数据更重要的一个属性是如何去查询它。在查询的时候，对于时间序列我们总是会带上一个时间范围去过滤数据。同时查询的结果里也总是会包含timestamp字段。&lt;br/&gt;InfluxDB 是一个开源分布式时序、事件和指标数据库。使用 Go 语言编写，无需外部依赖。其设计目标是实现分布式和水平伸缩扩展。&lt;br/&gt;它有三大特性：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Time Series （时间序列）：你可以使用与时间有关的相关函数（如最大，最小，求和等）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Metrics（度量）：你可以实时对大量数据进行计算&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Eevents（事件）：它支持任意的事件数据&lt;br/&gt;特点：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;schemaless(无结构)，可以是任意数量的列&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;min, max, sum, count, mean, median 一系列函数，方便统计&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Native HTTP API, 内置http支持，使用http读写&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Powerful Query Language 类似&lt;code&gt;sql&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;操作介绍&lt;/h3&gt;
&lt;p&gt;远程连接&lt;/p&gt;
&lt;table width=&quot;NaN&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td height=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td height=&quot;35&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;influx -host xx.xx.xx.xx -port xxxx(默认8086) -username xx -password xx -database xx&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;创建及使用数据库&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;table width=&quot;NaN&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td height=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td height=&quot;35&quot; readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create database &quot;test&quot;; --创建数据库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;show databases;  --查看数据库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;use test; --选取数据库&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;增删改查&lt;/p&gt;
&lt;table width=&quot;NaN&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td height=&quot;35&quot; readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td height=&quot;35&quot; readability=&quot;11&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;SHOW MEASUREMENTS  --查询当前数据库中含有的表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW FIELD KEYS --查看当前数据库所有表的字段&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW series from pay --查看key数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW TAG KEYS FROM &quot;pay&quot; --查看key中tag key值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW TAG VALUES FROM &quot;pay&quot; WITH KEY = &quot;merId&quot; --查看key中tag 指定key值对应的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW TAG VALUES FROM cpu WITH KEY IN (&quot;region&quot;, &quot;host&quot;) WHERE service = 'redis'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DROP SERIES FROM &amp;lt;measurement_name[,measurement_name]&amp;gt; WHERE &amp;lt;tag_key&amp;gt;='&amp;lt;tag_value&amp;gt;' --删除key&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW CONTINUOUS QUERIES   --查看连续执行命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW QUERIES  --查看最后执行命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;KILL QUERY &amp;lt;qid&amp;gt; --结束命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW RETENTION POLICIES ON mydb  --查看保留数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;查询数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT * FROM /.*/ LIMIT 1  --查询当前数据库下所有表的第一行记录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select * from pay  order by time desc limit 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select * from  db_name.&quot;POLICIES name&quot;.measurement_name --指定查询数据库下数据保留中的表数据 POLICIES name数据保留&lt;/span&gt;&lt;br/&gt;&lt;span&gt;删除数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;delete from &quot;query&quot; --删除表所有数据，则表就不存在了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;drop MEASUREMENT &quot;query&quot;   --删除表（注意会把数据保留删除使用delete不会）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DELETE FROM cpu&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DELETE FROM cpu WHERE time &amp;lt; '2000-01-01T00:00:00Z'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DELETE WHERE time &amp;lt; '2000-01-01T00:00:00Z'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DROP DATABASE “testDB” --删除数据库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DROP RETENTION POLICY &quot;dbbak&quot; ON mydb --删除保留数据为dbbak数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DROP SERIES from pay where tag_key='' --删除key中的tag&lt;/span&gt;&lt;p&gt;&lt;span&gt;SHOW SHARDS  --查看数据存储文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;DROP SHARD 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW SHARD GROUPS&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SHOW SUBSCRIPTIONS&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;6、数据保留命令&lt;/p&gt;
&lt;p&gt;查看保留期 &lt;code&gt;SHOW RETENTION POLICIES ON mydb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;修改保留期 &lt;code&gt;ALTER RETENTION POLICY default ON online DEFAULT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;删除保留期 &lt;code&gt;DROP RETENTION POLICY &amp;lt;retentionpolicy&amp;gt; ON &amp;lt;database&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;创建保留期 &lt;code&gt;REATE RETENTION POLICY &quot;rp_name&quot; ON &quot;db_name&quot; DURATION 30d REPLICATION 1 DEFAULT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rp_name&lt;/code&gt;：策略名&lt;/p&gt;
&lt;p&gt;&lt;code&gt;db_name&lt;/code&gt;：具体的数据库名&lt;/p&gt;
&lt;p&gt;&lt;code&gt;30d&lt;/code&gt;：保存30天，30天之前的数据将被删除&lt;/p&gt;
&lt;p&gt;它具有各种时间参数，比如：h（小时），w（星期）m minutes h hours d days w weeks INF infinite&lt;/p&gt;
&lt;p&gt;&lt;code&gt;REPLICATION 1&lt;/code&gt;：副本个数，这里填1就可以了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DEFAULT&lt;/code&gt;设为默认的策略&lt;/p&gt;

&lt;p&gt;目前，我们已经&lt;code&gt;influxdb&lt;/code&gt;+&lt;code&gt;grafana&lt;/code&gt;应用到数据库监控、Kafka数据流监控、服务页面数据统计监控等，炫酷的页面给你不一样的体验，试试吧！&lt;/p&gt;
关注微信公众号：&lt;strong&gt;正版乔&lt;/strong&gt;，和我一起探索日常的编程乐趣～
&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;一个学统计的程序员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢Coding&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢硬件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢树莓派&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢深度学习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢你&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Thu, 10 Jan 2019 15:25:00 +0000</pubDate>
<dc:creator>正版乔</dc:creator>
<og:description>在系统服务部署过后，线上运行服务的稳定性是系统好坏的重要体现，监控系统状态至关重要，经过调研了解，时序数据库influxDB在此方面表现优异。 influxDB介绍 时间序列数据是以时间字段为每行数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiaohaoforever/p/10252952.html</dc:identifier>
</item>
<item>
<title>前端常用技术概述--Less、typescript与webpack - 打伞的鱼l</title>
<link>http://www.cnblogs.com/hongxuquan/p/10252939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongxuquan/p/10252939.html</guid>
<description>&lt;blockquote readability=&quot;6.9241011984021&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;前言：讲起前端，我们就不能不讲CSS与Javascript，在这两种技术广泛应用的今天，他们的扩展也是层出不穷，css的扩展有Less、Sass、Stylus 等，js的超集有Typescript等。今天我们就简单来聊聊Less与Typescript以及静态模块打包器webpack。&lt;br/&gt;本节目标：本文为简单普及性知识，旨在让大家了解并初步学会怎么去用这三项技术，以及这三项技术在开发的过程中给我们带来的便利性与好处，挑起大家对这三项技术的兴趣，方便同学们课后去学习。&lt;br/&gt;本文借鉴了以下同学的文章，特此感谢。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 class=&quot;xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;一、Less&lt;/span&gt;&lt;/h2&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;1、什么是Less？&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;Less是基于CSS的一种扩展技术，包含变量、混合、函数、运算，可以简化CSS代码，降低维护成本。必须通过解析器将less文件转换为css文件供页面使用。Less让 CSS 更易维护、方便制作主题、扩充。Less 可以运行在 Node 或浏览器端。&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;http://lesscss.cn/&quot; target=&quot;_blank&quot;&gt;Less中文网&lt;/a&gt;。&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;2、为什么去用Less&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;我们在平常web开发过程中写css是否碰到如下的情形：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;.border{
        boder-radius:3px;
        -webkit-border-radius:3px;
        -moz-border-radius:3px;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;以上是设置boder的css，但是现在我们要将3px改成5px怎么办呢，我们就要一个个去改，如果多了我们就会很烦，还有可能漏掉一两个没改，在设置颜色中此类问题更为严重，优秀的程序员怎么可能容忍这样的情况呢，所以此时CSS的预编译技术就出现了。在Less中我们就可以把上述代码改写成如下：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;@borderSize:3px
.border{
        boder-radius:@borderSize;
        -webkit-border-radius:@borderSize;
        -moz-border-radius:@borderSize;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;上面就是Less的语法-变量的一种形式，如果我们此时要去改变border的大小我们只要改变borderSize的值即可。&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;3、Less语法概要&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;我们在这里简单的说几点less的语法使用。&lt;br/&gt;&amp;lt;1&amp;gt;、变量&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;//less写法
@color:#fff;
@classname: header;
.@classname{
        background-color:@color
}
//编译后的css
.header{
        background-color:#fff
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;从例子中我们就可以看到，变量不仅仅可以作为样式属性值：background-color: @color;，还可以作为类名：.@classname 表示的就是 .header，less编译时使用 @ 符号获取变量，仅仅将 @变量名 看成是一个字符串。这样我们就有很多应用场景了，可以让我们的代码减少了很多的重复性，也利于后期的修改与维护。&lt;br/&gt;&amp;lt;2&amp;gt;、混合&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;//css语法
#menu a {
    color: #111;
    border-top: dotted 1px black;
    border-bottom: solid 2px black;
}
#menu span {
    height: 16px;
    border-top: dotted 1px black;
    border-bottom: solid 2px black;
}
//less语法
.bordered {
    border-top: dotted 1px black;
    border-bottom: solid 2px black;
}

#menu a {
    color: #111;
    .bordered;
}

#menu span {
    height: 16px;
    .bordered;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;混合也是减少代码书写量的一个方法；&lt;/li&gt;
&lt;li&gt;混合的类名在定义的时候加上小括弧 ()，那么在转译成 css 文件时就不会出现；&lt;/li&gt;
&lt;li&gt;混合的类名在被调用的时候加上小括弧 ()和不加上小括弧 ()是一样的效果，看个人习惯&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;3&amp;gt;、函数&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;// less语法
.border-radius(@radius) {
  -webkit-border-radius: @radius;
     -moz-border-radius: @radius;
          border-radius: @radius;
}
#header {
  .border-radius(4px);
}
.button {
  .border-radius(6px);
}
//编译成css
#header {
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px;
}
.button {
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;可以看到，这里就用到了函数的概念，在 #header 和 .button 中分别传入不同的参数，结果也就生成不同的代码。&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;4、怎么去用Less&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;1&amp;gt;、浏览器用法&lt;br/&gt;我们先来讲一下浏览器用法：&lt;br/&gt;首先我们要先写好页面所需要的less文件，然后引入less.js即可。如下：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546779305779.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546779305779.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;Tips：注意你的less样式文件一定要在引入less.js前先引入。&lt;br/&gt;请在服务器环境下使用！本地直接打开可能会报错！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;当浏览器加载后less.js后文件，会去解析rel为stylesheet/less文件，并将转译后的内容生成style元素内嵌在HTML的head节点中，如下图：&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546779602154.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546779602154.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;此种方式缺点：耗性能，优点：简单开发时候无需一直预编译；&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;2&amp;gt;、服务端用法&lt;br/&gt;我们可以用nodejs将less文件编译成css，再引用css文件。&lt;br/&gt;上节课我们已经讲过了npm与nodejs的用法，接下来我们就演示一遍全局安装less：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;命令为 npm install -g less&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546779910071.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546779910071.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;br/&gt;这样我们就安装了less，我们也可以看less的编译器lessc的版本，那我们如何将一个less文件编译成一个css文件呢？&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546780584316.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546780584316.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;利用less编译器即可将指定的less文件编译成css到指定的目录底下。&lt;br/&gt;缺点：使用麻烦 优点：提高站点性能；

&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;本节旨在教会大家如何使用less以及less的基本语法，这里还有许多好用的语法没有讲到，比如内置函数、运算、神奇的import等等。less的语法与魅力请有兴趣的同学移步&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;http://lesscss.cn/&quot; target=&quot;_blank&quot;&gt;Less中文网&lt;/a&gt;或者本人将在未来写一篇有关Less的详细文章，敬请期待。&lt;/p&gt;

&lt;h2 class=&quot;xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;二、TypeScript&lt;/span&gt;&lt;/h2&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;1、什么是Typescript？&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。截止目前，Typescript已经发布了最新的3.1版本。&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;https://www.tslang.cn/&quot; target=&quot;_blank&quot;&gt;Typescript中文网&lt;/a&gt;;下图为Typescript与ES6、ES5的关系。Typescript包含了ES6与ES5,简而言之，我们可以在Typescript写ES6与ES5的语法。&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;enter description here&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546783020963.png&quot; alt=&quot;enter description here&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546783020963.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;2、为什么要去用Typescript？&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;1&amp;gt;、TypeScript的设计目的应该是解决JavaScript的“痛点”：弱类型和没有命名空间，导致很难模块化，不适合开发大型程序。另外它还提供了一些语法糖来帮助大家更方便地实践面向对象的编程。&lt;br/&gt;&amp;lt;2&amp;gt;、Typescript越来越在前端流行与广泛使用，在最新的TIOBE的编程语言排行榜中，成为最大的黑马，从第167名上升至49名，所以对于想要做好web的我们，了解并熟练掌握Typescript变得极为重要。&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;3、Typescript常用语法概要&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;我们接下来稍微介绍一下Typescript的常用语法：&lt;br/&gt;&amp;lt;1&amp;gt;、数据类型&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;布尔类型:boolean
数字类型:number
字符串类型:string
数组类型:array
元组类型:tuple
枚举类型:enum(新)
任意类型:any(新)
null和undefined
void类型(新)
never类型(新)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;Typescript为了使代码更加规范与更容易维护，新增了数据类型校验：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;//js代码,es5的正确写法
var flag=true;
flag=1;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;但是在Typescript这样写是错误的。写ts变量时必须指定数据类型。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;//ts写法
var flag:boolean=true;
flag=1;//直接报错。
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;2&amp;gt;、类&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;//ts语法
class person{
    name:string;
    constructor(name:string){
        this.name=name
    }
    getname():string{
        return this.name;
    };
    setname(name:string):void{
        this.name=name;
    }
}
var p= new person('张三');
alert( p.getname());
p.setname('李四');
alert(p.getname())
//编译后的js
var person = /** @class */ (function () {
    function person(name) {
        this.name = name;
    }
    person.prototype.getname = function () {
        return this.name;
    };
    ;
    person.prototype.setname = function (name) {
        this.name = name;
    };
    return person;
}());
var p = new person('张三');
alert(p.getname());
p.setname('李四');
alert(p.getname());
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;我们可以看到,其实Ts的类跟我们后端语言C#之类的非常相像。&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;4、如何使用Typescript&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;1&amp;gt;、安装Typescript&lt;br/&gt;浏览器不能直接识别Typescript文件，必须由编译器编译成JS才可以，Visual Studio 2017和Visual Studio 2015 Update 3默认包含了TypeScript。 如果你的Visual Studio还没有安装TypeScript，你可以下载它。&lt;br/&gt;既然我们讲到了npm，我们也可以用npm去安装Typescript。&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546782080526.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546782080526.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;如图，我们也可以去看Typescript的编译器的版本。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;2&amp;gt;、最简单的编译操作&lt;br/&gt;接下来我们来演示一下最简单的编译一个ts文件的操作。&lt;br/&gt;首先我们新建一个ts文件&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547042374061.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547042374061.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;然后使用 tsc tsdemo.ts命令编译成tsdemo.js文件，演示如下：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547042531228.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547042531228.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;3&amp;gt; 、配置配置文件&lt;br/&gt;我们如果要将一个Typescript文件（.ts文件）编译成一个js文件，那么每次都要去运行tsc命令是不是很烦呢，那如果要编译整个项目呢？有没有那种我们边写ts边生成js的方法呢？答案肯定是有的。接下来我们去配置配置文件。&lt;br/&gt;我们去运行tsc --init命令，在项目的根目录生成tsconfig.json的配置文件&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546783856530.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546783856530.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;如果一个目录下存在一个tsconfig.json文件，那么它意味着这个目录是TypeScript项目的根目录。 tsconfig.json文件中指定了用来编译这个项目的根文件和编译选项。 一个项目可以通过以下方式之一来编译：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不带任何输入文件的情况下调用tsc，编译器会从当前目录开始去查找tsconfig.json文件，逐级向上搜索父目录。&lt;/li&gt;
&lt;li&gt;不带任何输入文件的情况下调用tsc，且使用命令行参数--project（或-p）指定一个包含tsconfig.json文件的目录。&lt;/li&gt;
&lt;li&gt;当命令行上指定了输入文件时，tsconfig.json文件会被忽略。&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;接下来我们根据tsconfig.json文件与vscode来配置一个在编写ts文件时按保存可以时时编译成js文件的方法：&lt;br/&gt;首先，我们先在项目的根目录建一个ts文件：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820712430.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820712430.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;然后，我们去tsconfig.json配置要生成的js目录：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546821074744.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546821074744.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;接下来点击vs上方菜单的终端，点击运行任务，选择tsc-监视：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820802687.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820802687.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;此时终端会显示成这样，证明监视成功：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820860038.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820860038.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;我们在ts文件中写ts代码，按ctrl+s保存时，会自动在我们设置好的目录下生成js文件：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820992268.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546820992268.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;配置项的具体含义请移步官网的&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;https://www.tslang.cn/docs/handbook/tsconfig-json.html&quot; target=&quot;_blank&quot;&gt;Typescript配置项说明&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;TS的使用方法及简要语法就先介绍到这里，有兴趣的同学可以移步&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;https://www.tslang.cn/&quot; target=&quot;_blank&quot;&gt;Typescript的中文官网&lt;/a&gt;或者本来在未来将会写一篇有关typescript的详细文章，敬请期待。&lt;/p&gt;

&lt;h2 class=&quot;xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;三、webpack&lt;/span&gt;&lt;/h2&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;1、什么是webpack？&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;在当今的社会，作为 web 开发，会越来越意识到前端的重要性，随着 HTML5、 CSS3、 ES6 各种技术的发展，前端的开发越来越庞大。甚至有些应用就是单页面应用(SPA)，纯 JavaScript 开发，JavaScript 文件的管理也是一个问题。JavaScript 模块化编程，已经成为一个迫切的需求，这就出现了 JavaScript 的模块解决方案。webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js 文件、css 文件等）都看成模块，通过 loader（加载器）和 plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。&lt;br/&gt;总的来说就是如下图：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546868168518.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546868168518.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 class=&quot;xsj_heading_h4&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;2、如何使用webpack&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;1&amp;gt; 、安装webpack&lt;br/&gt;安装webpack首先必须要有nodejs的环境，我们用npm工具去安装webpack，命令为：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;npm install -g webpack
/*在webpack 3中，webpack本身和它的CLI以前都是在同一个包中，但在第4版中，他们已经将两者分开来更好地管理它们*/
npm install -g webpack-cli
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;安装完毕后我们查看版本如下图：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546868064591.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546868064591.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;&amp;lt;2&amp;gt; 、简单上手webpack&lt;br/&gt;接下来我们来做一个最简单的webpack的打包编译。&lt;br/&gt;我首先在vscode新建一个文件夹webpackDemo,新建一个hellowebpack.js的文件，写几句js代码&lt;br/&gt;接下来我们在这个目录下运行命令：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546869950896.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546869950896.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;从警告信息中我们就可以知道，我们没有设定mode，webpack分为开发模式和生产模式。我们看下这两种模式的编译&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546870319896.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546870319896.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546870366886.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546870366886.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;从图中我们也能看出来production编译出来的明显比较小。&lt;br/&gt;上面这种方法是全局去告诉webpack要编译哪个文件，那我们也可以用另外一种方法：&lt;br/&gt;我们先用 npm init -y 初始化项目，新建一个package.json文件。&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546872088375.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1546872088375.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;我们再用--save -dev安装局部本地依赖，此时package.json就会有安装依赖包的信息：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547043552619.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547043552619.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;这里面包含了项目的很多信息，记录项目的描述信息：项目作者、项目描述、项目依赖哪些包、插件配置信息等等。&lt;br/&gt;其中scripts对象是指定了运行脚本命令的npm命令行缩写&lt;br/&gt;我们将test改为build，用来简写webpack。注意此文件应放在src文件夹下，当webpack打包时会默认去此文件夹下找。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547047342757.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547047342757.png&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;此时我们去执行 npm run build命令，就能编译到dist文件夹下的main.js.&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547047540116.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547047540116.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;学会了这个简单的webpack打包，我们能不能让webpack自动帮我们创建html并将js引入进去呢？&lt;br/&gt;接下来我们来进行一下尝试。&lt;br/&gt;首先，我们先用npm init -y命令初始化项目。&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547130489110.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547130489110.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;然后再局部引入webpack与webpack-cli&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547130726254.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547130726254.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;之后我们在根目录创建一个webpack.config.js的配置文件，写入入口文件：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132297287.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132297287.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;那现在我们要让webpack帮我们创建html文件且引入js文件，就需要用到webpack的一个插件 【HtmlWebpackPlugin】，我们可以去官网查看此插件的用法，&lt;a class=&quot;xsj_link xsj_manu_link&quot; href=&quot;https://www.webpackjs.com/plugins/html-webpack-plugin/&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547131253662.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547131253662.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;我们局部安装此插件：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132378154.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132378154.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;并去webpack.config.js配置好此插件：&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132431818.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132431818.png&quot;/&gt;&lt;/span&gt;&lt;br/&gt;这里的HtmlWebpackPlugin()有一堆的参数，我们这里篇幅有限，只做简要的介绍，具体的更多功能请移步官网查看详解。&lt;br/&gt;此时我们再使用webpack --mode production 命令编译项目，webpack就会帮我们创建好html，并引入进去了。&lt;br/&gt;&lt;span class=&quot;story_inline_image&quot;&gt;&lt;img title=&quot;&quot; src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132685265.png&quot; alt=&quot;&quot; name=&quot;&quot; data-src=&quot;https://www.github.com/HXQ666/StoryWriterImg/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1547132685265.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;webpack简要的概述就讲到这里，还有兴趣的同学可以自行去官网学习，或者关注本博客，将会在未来推出更加详细的有关webpack的介绍。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;总结：本篇文章我们简要讲了Less、Typescript与模块打包器webpack，这三样技术在未来的web应用的开发绝对是一种不可阻挡的趋势。通过本篇文章的学习，我们已经能够初步的创建一个前端程序，并用webpack打包。这不管对于前端开发者还是全栈开发者，都是不可绕过的门槛，希望读者能继续深入学习，有疑问的可留言一起探讨学习。&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 15:23:00 +0000</pubDate>
<dc:creator>打伞的鱼l</dc:creator>
<og:description>前言：讲起前端，我们就不能不讲CSS与Javascript，在这两种技术广泛应用的今天，他们的扩展也是层出不穷，css的扩展有Less、Sass、Stylus 等，js的超集有Typescr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongxuquan/p/10252939.html</dc:identifier>
</item>
<item>
<title>Django视图层 - 伍萬磊</title>
<link>http://www.cnblogs.com/wanlei/p/10246952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanlei/p/10246952.html</guid>
<description>&lt;h2&gt;目录&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;一、HttpRequest对象&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;当一个页面被请求时，Django就会创建一个包含本次请求原信息的HttpRequest对象。&lt;br/&gt;Django会将这个对象自动传递给响应的视图函数，一般视图函数约定俗成地使用 request 参数承接这个对象。 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/1.11/ref/request-response/&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;autoid-2-1-0&quot;&gt;请求相关的常用值&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;&lt;strong&gt;path_info&lt;/strong&gt;      返回用户访问url，不包括域名&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;&lt;strong&gt;method         &lt;/strong&gt;请求中使用的HTTP方法的字符串表示，全大写表示。&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;&lt;strong&gt;GET              &lt;/strong&gt;包含所有HTTP  GET参数的类字典对象&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;&lt;strong&gt;POST            &lt;/strong&gt;包含所有HTTP POST参数的类字典对象&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;&lt;strong&gt;body             &lt;/strong&gt;请求体，byte类型 request.POST的数据就是从body里面提取到的&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f2852a6d-6fd7-468e-9b25-3b0934882645')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_f2852a6d-6fd7-468e-9b25-3b0934882645&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f2852a6d-6fd7-468e-9b25-3b0934882645&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f2852a6d-6fd7-468e-9b25-3b0934882645',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f2852a6d-6fd7-468e-9b25-3b0934882645&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;.HttpRequest.GET

　　一个类似于字典的对象，包含 HTTP GET 的所有参数。详情请参考 QueryDict 对象。

&lt;/span&gt;2&lt;span&gt;.HttpRequest.POST

　　一个类似于字典的对象，如果请求中包含表单数据，则将这些数据封装成 QueryDict 对象。

　　POST 请求可以带有空的 POST 字典 —— 如果通过 HTTP POST 方法发送一个表单，但是表单中没有任何的数据，QueryDict 对象依然会被创建。
   因此，不应该使用 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.POST  来检查使用的是否是POST 方法；应该使用 &lt;span&gt;if&lt;/span&gt; request.method == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
　　另外：如果使用 POST 上传文件的话，文件信息将包含在 FILES 属性中。
   
   注意：键值对的值是多个的时候,比如checkbox类型的input标签，select标签，需要用：
        request.POST.getlist(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hobby&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;3&lt;span&gt;.HttpRequest.body

　　一个字符串，代表请求报文的主体。在处理非 HTTP 形式的报文时非常有用，例如：二进制图片、XML,Json等。
　　但是，如果要处理表单数据的时候，推荐还是使用 HttpRequest.POST 。


&lt;/span&gt;4&lt;span&gt;.HttpRequest.path

　　一个字符串，表示请求的路径组件（不含域名）。
　　例如：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/music/bands/the_beatles/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

5&lt;span&gt;.HttpRequest.method

　　一个字符串，表示请求使用的HTTP 方法。必须使用大写。
　　例如：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;、&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;


6&lt;span&gt;.HttpRequest.encoding

　　一个字符串，表示提交的数据的编码方式（如果为 None 则表示使用 DEFAULT_CHARSET 的设置，默认为 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;）。
   这个属性是可写的，你可以修改它来修改访问表单数据使用的编码。
   接下来对属性的任何访问（例如从 GET 或 POST 中读取数据）将使用新的 encoding 值。
   如果你知道表单数据的编码不是 DEFAULT_CHARSET ，则使用它。


&lt;/span&gt;7&lt;span&gt;.HttpRequest.META

 　　一个标准的Python 字典，包含所有的HTTP 首部。具体的头部信息取决于客户端和服务器，下面是一些示例：
　　取值：

    CONTENT_LENGTH —— 请求的正文的长度（是一个字符串）。
    CONTENT_TYPE —— 请求的正文的MIME 类型。
    HTTP_ACCEPT —— 响应可接收的Content&lt;/span&gt;-&lt;span&gt;Type。
    HTTP_ACCEPT_ENCODING —— 响应可接收的编码。
    HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。
    HTTP_HOST —— 客服端发送的HTTP Host 头部。
    HTTP_REFERER —— Referring 页面。
    HTTP_USER_AGENT —— 客户端的user&lt;/span&gt;-&lt;span&gt;agent 字符串。
    QUERY_STRING —— 单个字符串形式的查询字符串（未解析过的形式）。
    REMOTE_ADDR —— 客户端的IP 地址。
    REMOTE_HOST —— 客户端的主机名。
    REMOTE_USER —— 服务器认证后的用户。
    REQUEST_METHOD —— 一个字符串，例如&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 或&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;。
    SERVER_NAME —— 服务器的主机名。
    SERVER_PORT —— 服务器的端口（是一个字符串）。
 　　从上面可以看到，除 CONTENT_LENGTH 和 CONTENT_TYPE 之外，请求中的任何 HTTP 首部转换为 META 的键时，
    都会将所有字母大写并将连接符替换为下划线最后加上 HTTP_  前缀。
    所以，一个叫做 X&lt;/span&gt;-&lt;span&gt;Bender 的头部将转换成 META 中的 HTTP_X_BENDER 键。

&lt;/span&gt;8&lt;span&gt;.HttpRequest.FILES

　　一个类似于字典的对象，包含所有的上传文件信息。
   FILES 中的每个键为&lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt; 中的name，值则为对应的数据。
　　注意，FILES 只有在请求的方法为POST 且提交的&lt;/span&gt;&amp;lt;form&amp;gt; 带有enctype=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multipart/form-data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 的情况下才会
   包含数据。否则，FILES 将为一个空的类似于字典的对象。


&lt;/span&gt;9&lt;span&gt;.HttpRequest.COOKIES

　　一个标准的Python 字典，包含所有的cookie。键和值都为字符串。



&lt;/span&gt;10&lt;span&gt;.HttpRequest.session

 　　一个既可读又可写的类似于字典的对象，表示当前的会话。只有当Django 启用会话的支持时才可用。
    完整的细节参见会话的文档。


&lt;/span&gt;11&lt;span&gt;.HttpRequest.user(用户认证组件下使用)

　　一个 AUTH_USER_MODEL 类型的对象，表示当前登录的用户。

　　如果用户当前没有登录，user 将设置为 django.contrib.auth.models.AnonymousUser 的一个实例。你可以通过 is_authenticated() 区分它们。

    例如：

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; request.user.is_authenticated():
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Do something for logged-in users.&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Do something for anonymous users.&lt;/span&gt;
&lt;span&gt;

     　　user 只有当Django 启用 AuthenticationMiddleware 中间件时才可用。

     &lt;/span&gt;-------------------------------------------------------------------------------------&lt;span&gt;

    匿名用户
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; models.AnonymousUser

    django.contrib.auth.models.AnonymousUser 类实现了django.contrib.auth.models.User 接口，但具有下面几个不同点：

    id 永远为None。
    username 永远为空字符串。
    get_username() 永远返回空字符串。
    is_staff 和 is_superuser 永远为False。
    is_active 永远为 False。
    groups 和 user_permissions 永远为空。
    is_anonymous() 返回True 而不是False。
    is_authenticated() 返回False 而不是True。
    set_password()、check_password()、save() 和delete() 引发 NotImplementedError。
    New &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; Django 1.8&lt;span&gt;:
    新增 AnonymousUser.get_username() 以更好地模拟 django.contrib.auth.models.User。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;request相关属性&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;常用方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;method:请求方式
GET:get请求的参数(post请求,也可以携带参数)
POST:post请求的参数(本质是从bdoy中取出来,放到里面了)
COOKIES
META:字典(放着好多东西,前端传过来的,一定能从其中拿出来)
body:post提交的数据
path:请求的路径,不带参数
request.get_full_path() 请求路径,带参数
session
user
FILES
encoding:编码格式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c4ffa771-483b-41b4-ac30-82a27d045d2e')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_c4ffa771-483b-41b4-ac30-82a27d045d2e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c4ffa771-483b-41b4-ac30-82a27d045d2e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c4ffa771-483b-41b4-ac30-82a27d045d2e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c4ffa771-483b-41b4-ac30-82a27d045d2e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
1.HttpRequest.get_full_path()

　　返回 path，如果可以将加上查询字符串。

　　例如：&quot;/music/bands/the_beatles/?print=true&quot;
　　注意和path的区别：http://127.0.0.1:8001/order/?name=lqz&amp;amp;age=10

2.HttpRequest.is_ajax()

　　如果请求是通过XMLHttpRequest 发起的，则返回True，方法是检查 HTTP_X_REQUESTED_WITH 相应的首部是否是字符串'XMLHttpRequest'。

　　大部分现代的 JavaScript 库都会发送这个头部。如果你编写自己的 XMLHttpRequest 调用（在浏览器端），你必须手工设置这个值来让 is_ajax() 可以工作。

　　如果一个响应需要根据请求是否是通过AJAX 发起的，并且你正在使用某种形式的缓存例如Django 的 cache middleware，
   你应该使用 vary_on_headers('HTTP_X_REQUESTED_WITH') 装饰你的视图以让响应能够正确地缓存。

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;二、HttpResponse对象&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;响应对象主要有三种形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4&gt;HttpResponse()&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;render()&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;redirect()&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HttpResponse()括号内直接跟一个具体的字符串作为响应体，比较直接很简单，所以这里主要介绍后面两种形式。&lt;/p&gt;
&lt;h3&gt;render()&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;render(request, template_name[, context]）
 
结合一个给定的模板和一个给定的上下文字典，并返回一个渲染后的 HttpResponse 对象。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre readability=&quot;6&quot;&gt;
参数：
     request： 用于生成响应的请求对象。

     template_name：要使用的模板的完整名称，可选的参数

     context：添加到模板上下文的一个字典。默认是一个空字典。如果字典中的某个值是可调用的，视图将在渲染模板之前调用它。&lt;p&gt;render方法就是将一个模板页面中的模板语法进行渲染，最终渲染成一个html页面作为响应体。
&lt;/p&gt;&lt;/pre&gt;
&lt;h3&gt;redirect()&lt;/h3&gt;
&lt;p&gt;传递要重定向的一个硬编码的URL&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
def my_view(request):
    ...
    return redirect('/some/url/')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以是一个完整的URL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
def my_view(request):
    ...
    return redirect('http://www.baidu.com/')　
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_7d464ac1-4d95-4190-8cf9-a4a4372dad78&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt; &lt;span class=&quot;cnblogs_code_collapse&quot;&gt;重定向301和302的区别&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;三、JsonResponse&lt;/h2&gt;
&lt;p&gt;向前端返回一个&lt;span&gt;json格式字符串&lt;/span&gt;的两种方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_a92abf24-d80a-48fa-a4ab-73c226349f1d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt; &lt;span class=&quot;cnblogs_code_collapse&quot;&gt;两种方式&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;转列表格式:指定safe=False&lt;br/&gt;中文字符问题:json_dumps_params={'ensure_ascii':False}&lt;/p&gt;
&lt;h2&gt;四、CBV和FBV&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CBV基于类的视图(Class base view)和FBV基于函数的视图（Function base view）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; View
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AddPublish(View):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; dispatch(self, request, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(request)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(kwargs)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以写类似装饰器的东西，在前后加代码&lt;/span&gt;
        obj=super().dispatch(request, *args, **&lt;span&gt;kwargs) 总的分发方法
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self,request):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; post(self,request):
        request
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HttpResponse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;在路由层:类名加as_view后一定要加括号&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
re_path(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^myclass/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,views.MyClass.as_view()),
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、简单文件上传&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;file_name&lt;/span&gt;=request.FILES.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).name
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.core.files.uploadedfile &lt;span&gt;import&lt;/span&gt;&lt;span&gt; InMemoryUploadedFile
with open(file_name,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)as f:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; request.FILES.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).chunks():
        f.write(i)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    -form表单默认提交的编码方式是enctype=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        -前端:如果要form表单上传文件,必须指定编码方式为:multipart/form-&lt;span&gt;data
        &lt;/span&gt;-&lt;span&gt;后端:
            file&lt;/span&gt;=request.FILES.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myfile&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            with open(file.name,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; file:
                    f.write(line)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;注意&lt;/h3&gt;
&lt;p&gt;前端提交数据编码格式:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-multipart/form-&lt;span&gt;data(上传文件)
&lt;/span&gt;-application/x-www-form-urlencoded(默认编码)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 10 Jan 2019 15:12:00 +0000</pubDate>
<dc:creator>伍萬磊</dc:creator>
<og:description>目录 一 HttpRequest对象 二 HttpResponse对象 三 JsonResponse 四 CBV和FBV 五 简单文件上传 一、HttpRequest对象 当一个页面被请求时，Djan</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanlei/p/10246952.html</dc:identifier>
</item>
<item>
<title>springboot配置druid连接池 - Brl</title>
<link>http://www.cnblogs.com/-brl/p/10252890.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-brl/p/10252890.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Druid的简介&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Druid首先是一个数据库连接池。Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource。Druid已经在阿里巴巴部署了超过600个应用，经过一年多生产环境大规模部署的严苛考验。Druid是阿里巴巴开发的号称为监控而生的数据库连接池！&lt;/p&gt;
&lt;p&gt;Druid的功能&lt;/p&gt;
&lt;p&gt;1、替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。&lt;/p&gt;
&lt;p&gt;2、可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。&lt;/p&gt;
&lt;p&gt;3、数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver和DruidDataSource都支持PasswordCallback。&lt;/p&gt;
&lt;p&gt;4、SQL执行日志，Druid提供了不同的LogFilter，能够支持Common-Logging、Log4j和JdkLog，你可以按需要选择相应的LogFilter，监控你应用的数据库访问情况。&lt;/p&gt;
&lt;p&gt;5、扩展JDBC，如果你要对JDBC层有编程的需求，可以通过Druid提供的Filter机制，很方便编写JDBC层的扩展插件。&lt;/p&gt;
&lt;p&gt;所以Druid可以：&lt;br/&gt;1、充当数据库连接池。&lt;br/&gt;2、可以监控数据库访问性能&lt;br/&gt;3、获得SQL执行日志&lt;/p&gt;
&lt;p&gt;在spring boot基础上开始配置：&lt;/p&gt;
&lt;p&gt;1.引入当前最新的版本，这里我们使用的maven&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;druid&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.1.12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.新建一个配置类，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
@Configuration&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在项目启动时可以初始化配置&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DruidConfiguration {
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServletRegistrationBean staViewServlet(){
        ServletRegistrationBean servletRegistrationBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ServletRegistrationBean(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StatViewServlet(),
                &lt;/span&gt;&quot;/druid/*&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;白名单为空允许任何ip访问&lt;/span&gt;
        servletRegistrationBean.addInitParameter(&quot;allow&quot;,&quot;127.0.0.1&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ip黑名单(存在共同时，deny优先于allow)：如果满足deny的即提示：Sorry you are not permitted...&lt;/span&gt;
        servletRegistrationBean.addInitParameter(&quot;deny&quot;,&quot;127.0.0.2&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;登录查看信息的账号密码&lt;/span&gt;
        servletRegistrationBean.addInitParameter(&quot;loginUsername&quot;,&quot;druid&quot;&lt;span&gt;);
        servletRegistrationBean.addInitParameter(&lt;/span&gt;&quot;loginPassword&quot;,&quot;druid&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否能够重置数据&lt;/span&gt;
        servletRegistrationBean.addInitParameter(&quot;resetEnable&quot;,&quot;true&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; servletRegistrationBean;
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FilterRegistrationBean statFilter(){
        FilterRegistrationBean filterRegistrationBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FilterRegistrationBean(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebStatFilter());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加过滤规则&lt;/span&gt;
        filterRegistrationBean.addUrlPatterns(&quot;/*&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加不需要忽略的格式信息&lt;/span&gt;
        filterRegistrationBean.addInitParameter(&quot;exclusions&quot;,&quot;*.js,*.gif,*.jpn,*.png,*.css,*.ico,/druid/*&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; filterRegistrationBean;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置数据库的基本连接信息&lt;/span&gt;
&lt;span&gt;    @Bean
    @Primary
    @ConfigurationProperties(prefix &lt;/span&gt;= &quot;spring.datasource&quot;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在application.properties中读取配置信息注入到DruidDataSource里&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DataSource dataSource(){
        DruidDataSource druidDataSource &lt;/span&gt;=  DataSourceBuilder.create().type(DruidDataSource.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).build();
        druidDataSource.setInitialSize(&lt;/span&gt;3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化物理连接的数量&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            druidDataSource.addFilters(&lt;/span&gt;&quot;stat,wall&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;stat是sql监控，wall是防火墙(如果不添加则监控无效)，不能添加log4j不然会出错&lt;/span&gt;
        } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; druidDataSource;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在application.properties中添加如下配置信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring.datasource.type=com.alibaba.druid.pool.DruidDataSource

spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/mrbshiro?characterEncoding=UTF-8
spring.datasource.username=root
spring.datasource.password=123456&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这些配置会自动注入到我们上面的&lt;span&gt;DruidDataSource实列里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样就可以访问projectUrl/druid进行登录了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1210597/201901/1210597-20190110230447775-1471056137.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 10 Jan 2019 15:05:00 +0000</pubDate>
<dc:creator>Brl</dc:creator>
<og:description>Druid的简介Druid首先是一个数据库连接池。Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-brl/p/10252890.html</dc:identifier>
</item>
<item>
<title>ContOS安装配置MySQL，redis - 温而新</title>
<link>http://www.cnblogs.com/peng104/p/10252869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peng104/p/10252869.html</guid>
<description>&lt;h2&gt;一，说明&lt;/h2&gt;
&lt;p&gt;MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。&lt;br/&gt;开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。&lt;/p&gt;
&lt;p&gt;也就是说MySQL即将要收费&lt;br/&gt;MariaDB是完全兼容MySQL的，包括API和命令行，使之能轻松成为MySQL的代替品。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1132884/201807/1132884-20180725121524048-1657176768.png&quot; alt=&quot;&quot; width=&quot;474&quot; height=&quot;192&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Red Hat Enterprise Linux/CentOS 7.0 发行版已将默认的数据库从 MySQL 切换到 MariaDB。&lt;/p&gt;
&lt;h2&gt;二，添加 MariaDB yum 仓库&lt;/h2&gt;
&lt;p&gt;当前环境：阿里云的yum源&lt;/p&gt;
&lt;p&gt;直接 yum install mariadb 发现版本特别低，还是5.5版本的，官方已经推出10.1版本了&lt;/p&gt;
&lt;p&gt;按照程序员的尿性，当然是下载官方最新版啦~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 首先在 RHEL/CentOS 和 Fedora 操作系统中添加 MariaDB 的 YUM 配置文件 MariaDB.repo 文件。&lt;/span&gt;
&lt;span&gt;mkdir mariadb.repo

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 然后编辑创建mariadb.repo仓库文件&lt;/span&gt;
vi /etc/yum.repos.d/&lt;span&gt;MariaDB.repo

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 再输入 i 进入编辑模式，添加repo仓库配置&lt;/span&gt;
&lt;span&gt;[mariadb]
name &lt;/span&gt;=&lt;span&gt; MariaDB
baseurl &lt;/span&gt;= http://yum.mariadb.org/10.1/centos7-&lt;span&gt;amd64
gpgkey&lt;/span&gt;=https://yum.mariadb.org/RPM-GPG-KEY-&lt;span&gt;MariaDB
gpgcheck&lt;/span&gt;=1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里吐槽一波~官方服务器在国外，下载忒慢了！！&lt;/p&gt;
&lt;h2&gt;三，安装MariaDB&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当 MariaDB 仓库地址添加好后，你可以通过下面的一行命令轻松安装 MariaDB。&lt;/span&gt;
yum install MariaDB-server MariaDB-client -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;启动MariaDB相关命令&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
systemctl start mariadb  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动MariaDB&lt;/span&gt;
&lt;span&gt;
systemctl stop mariadb  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;停止MariaDB&lt;/span&gt;
&lt;span&gt;
systemctl restart mariadb  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;重启MariaDB&lt;/span&gt;
&lt;span&gt;
systemctl enable mariadb  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置开机启动&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四，初始化MariaDB&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
在确认 MariaDB 数据库软件程序安装完毕并成功启动后请不要立即使用。为了确保数据 库的安全性和正常运转，需要先对数据库程序进行初始化操作。这个初始化操作涉及下面 5&lt;span&gt; 个 步骤。
➢ 设置 root 管理员在数据库中的密码值(注意，该密码并非 root 管理员在系统中的密 码，这里的密码值默认应该为空，可直接按回车键)。
➢ 设置 root 管理员在数据库中的专有密码。
➢ 随后删除匿名账户，并使用 root 管理员从远程登录数据库，以确保数据库上运行的业
务的安全性。
➢ 删除默认的测试数据库，取消测试数据库的一系列访问权限。
➢ 刷新授权列表，让初始化的设定立即生效。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意： &lt;/strong&gt;确保mariadb服务器启动后，执行命令初始化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql_secure_installation
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就是一路 Y 到底了。你也可以按照自己的需求进行配置 如：&lt;/p&gt;
&lt;p&gt;　　出现 Disallow root login remotely? [Y/n]  --&amp;gt; 禁止root用户从远程登录， 可以选&amp;lt;n&amp;gt;呀 !&lt;/p&gt;
&lt;h2&gt;五，设置MariaDB支持中文&lt;/h2&gt;
&lt;p&gt;MariaDB跟MySQL一样，数据库格式是拉丁文的，比支持中文&lt;/p&gt;
&lt;p&gt;我们得把它的数据格式改成 utf-8&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开配置文件&lt;/span&gt;
vim /etc/&lt;span&gt;my.cnf

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先 dG 清空文件夹。没清空就按 g 回到首行， 再 dG 清空&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 再按 i 进入编辑模式 复制如下代码&lt;/span&gt;
&lt;span&gt;[mysqld]
character&lt;/span&gt;-set-server=&lt;span&gt;utf8
collation&lt;/span&gt;-server=&lt;span&gt;utf8_general_ci
log&lt;/span&gt;-error=/var/log/&lt;span&gt;mysqld.log
datadir&lt;/span&gt;=/var/lib/&lt;span&gt;mysql
socket&lt;/span&gt;=/var/lib/mysql/&lt;span&gt;mysql.sock
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Disabling symbolic-links is recommended to prevent assorted security risks&lt;/span&gt;
symbolic-links=&lt;span&gt;0
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Settings user and group are ignored when systemd is used.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; If you need to run mysqld under a different user or group,&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; customize your systemd unit file for mariadb according to the&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; instructions in http://fedoraproject.org/wiki/Systemd&lt;/span&gt;
&lt;span&gt;[client]
default&lt;/span&gt;-character-set=&lt;span&gt;utf8
[mysql]
default&lt;/span&gt;-character-set=&lt;span&gt;utf8
[mysqld_safe]
log&lt;/span&gt;-error=/var/log/mariadb/&lt;span&gt;mariadb.log
pid&lt;/span&gt;-file=/var/run/mariadb/&lt;span&gt;mariadb.pid

&lt;/span&gt;&lt;span&gt;#
#&lt;/span&gt;&lt;span&gt; include all files from the config directory&lt;/span&gt;&lt;span&gt;
#
&lt;/span&gt;!includedir /etc/&lt;span&gt;my.cnf.d

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最后 按 Esc 键，进入命令模式， :wq! 保存强制退出&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就怕你忘记vim怎么操作了， 所以步骤都在里面了！贴心吧~&lt;/p&gt;
&lt;h2&gt;六，登录&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;登录前先重启数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl restart mariadb 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql -uroot -p  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 你没看错，这条就是登录命令&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 登录后&lt;/span&gt;
MariaDB [(none)]&amp;gt; \s  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看编码设置&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其它命令跟MySQl都一模一样&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/peng104/p/9746032.html&quot; target=&quot;_blank&quot;&gt;不懂就去看我这篇MySQL的博客吧&lt;/a&gt;&lt;/p&gt;


&lt;h2&gt;一，yum安装&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;前提得配置好阿里云yum源，epel源&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;查看是否有redis包&lt;/span&gt;
&lt;span&gt;yum list redis
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;安装redis&lt;/span&gt;
yum install redis -&lt;span&gt;y
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;安装好，启动redis&lt;/span&gt;
systemctl start redis
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没配置源的也还有两个方案：&lt;/p&gt;
&lt;p&gt;方案一：&lt;a href=&quot;https://www.cnblogs.com/peng104/p/10246886.html&quot; target=&quot;_blank&quot;&gt;去看我上篇博客，配置国内源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;方案二：继续往下看 ⬇&lt;/p&gt;
&lt;h3&gt;检查redis是否工作&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
redis-cli    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;redis 客户端工具&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;进入交互式环境后，执行ping，返回pong表示安装成功&lt;/span&gt;
127.0.0.1:6379&amp;gt;&lt;span&gt; ping
PONG&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二，源码编译安装redis&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.下载redis源码， 可以 cd /opt 下载到此目录&lt;/span&gt;
wget http://download.redis.io/releases/redis-4.0.10&lt;span&gt;.tar.gz

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.解压缩&lt;/span&gt;
tar -zxf redis-4.0.10&lt;span&gt;.tar.gz

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.切换redis源码目录&lt;/span&gt;
cd redis-4.0.10

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.编译源文件&lt;/span&gt;
make &amp;amp;&amp;amp;&lt;span&gt; make install 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.启动redis服务端&lt;/span&gt;
./redis-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;redis可执行文件的说明&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
./redis-benchmark  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于进行redis性能测试的工具&lt;/span&gt;
./redis-check-dump  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;用于修复出问题的dump.rdb文件&lt;/span&gt;
./redis-cli  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis的客户端&lt;/span&gt;
./redis-server  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis的服务端&lt;/span&gt;
./redis-check-aof  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于修复出问题的AOF文件&lt;/span&gt;
./redis-sentinel  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于集群管理&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况下，redis-server会以非daemon的方式来运行，且默认服务端口为6379。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;到这里，redis就可以正常运行啦~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是关于安全方面的~&lt;/p&gt;
&lt;h2&gt;三，切换redis端口&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目的：&lt;/strong&gt;由于redis端口默认都是 6379，黑客可以利用这一点侵入你服务器，所以得换一个让它们想不到得端口来运行 redis&lt;/p&gt;
&lt;p&gt;再一个就是配置了redis以后，启动redis-server服务端得时候就不会默认挂载在哪里了， 它会在后台运行服务端， 你就可以不需要另外切换窗口去运行客户端了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1. 先切换到目标目录&lt;/span&gt;
cd /opt/redis-4.0.10/

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 创建文件&lt;/span&gt;
touch redis-6380&lt;span&gt;.conf

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3. 创建文件夹&lt;/span&gt;
mkdir 6380

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4. 打开第一个文件&lt;/span&gt;
vi /opt/redis-4.0.10/redis-6380&lt;span&gt;.conf
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5. 按 i 进入编辑默认，复制下面代码&lt;/span&gt;
port 6380  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行在6380的redis数据库实例&lt;/span&gt;
daemonize yes  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 后台运行redis &lt;/span&gt;
pidfile /opt/redis-4.0.10/6380/redis.pid  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存放redis pid的文件&lt;/span&gt;
loglevel notice  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 日志等级&lt;/span&gt;
logfile &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/opt/redis-4.0.10/6380/redis.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定redis日志文件的生成目录&lt;/span&gt;
dir /opt/redis-4.0.10/6380  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 指定redis数据文件夹的目录&lt;/span&gt;
protected-&lt;span&gt;mode yes
requirepass   &lt;/span&gt;123  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置redis的密码，密码自己改&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 然后 按 Esc 键，进入命令模式，输入 :wq! 保存并强制退出&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 为了兼容性，复制得时候还是把注释删了把！！！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你也可以根据自己的需求配置文件路径~&lt;/p&gt;
&lt;h3&gt;此时启动redis服务端命令就变成这样了&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-server   redis-6380.conf 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;启动客户端命令也变了&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
redis-cli  -p 6380  -a 123
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -p  设置redis链接的端口&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -a  显示的填写密码&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 或者&lt;/span&gt;
redis-cli  -p 6380&lt;span&gt;
auth  &lt;/span&gt;123
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 启动以后ping以下， 没显示PONG，就说明没链接成功&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 14:57:00 +0000</pubDate>
<dc:creator>温而新</dc:creator>
<og:description>MySQL（MariaDB） 一，说明 MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MyS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peng104/p/10252869.html</dc:identifier>
</item>
<item>
<title>8. 造成HashMap非线程安全的原因 - 程序员私房菜</title>
<link>http://www.cnblogs.com/eson15/p/10252838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eson15/p/10252838.html</guid>
<description>&lt;p&gt;在前面我的一篇总结（&lt;a href=&quot;https://www.cnblogs.com/eson15/p/10235528.html&quot;&gt;6. 线程范围内共享数据&lt;/a&gt;）文章中提到，为了数据能在线程范围内使用，我用了 HashMap 来存储不同线程中的数据，key 为当前线程，value 为当前线程中的数据。我取的时候根据当前线程名从 HashMap 中取即可。&lt;/p&gt;
&lt;p&gt;因为当初学习 HashMap 和 HashTable 源码的时候，知道 HashTable 是线程安全的，因为里面的方法使用了 synchronized 进行同步，但是 HashMap 没有，所以 HashMap 是非线程安全的。&lt;/p&gt;
&lt;p&gt;在上面提到的例子中，我想反正不用修改 HashMap，只需要从中取值即可，所以不会有线程安全问题，但是我忽略了一个步骤：我得先把不同线程的数据存到 HashMap 中吧，这个存就可能出现问题，虽然我存的时候 key 使用了不同的线程名字，理论上来说是不会冲突的，但是这种设计或者思想本来就不够严谨。我后来仔细推敲了下，重新温习了下 HashMap 的源码，再加上网上查的一些资料，在这里总结一下 HashMap 到底什么时候可能出现线程安全问题。&lt;/p&gt;
&lt;p&gt;我们知道 HashMap 底层是一个 Entry 数组，当发生 hash 冲突的时候，HashMap 是采用链表的方式来解决的，在对应的数组位置存放链表的头结点。对链表而言，新加入的节点会从头结点加入。javadoc 中有一段关于 HashMap 的描述：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;此实现不是同步的。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedMap 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问，如下所示：&lt;br/&gt;&lt;code&gt;Map m = Collections.synchronizedMap(new HashMap(...));&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出，解决 HashMap 线程安全问题的方法很简单，下面我简单分析一下可能会出现线程问题的一些地方。&lt;/p&gt;
&lt;h2 id=&quot;向hashmap中插入数据的时候&quot;&gt;1. 向HashMap中插入数据的时候&lt;/h2&gt;
&lt;p&gt;在 HashMap 做 put 操作的时候会调用到以下的方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//向HashMap中添加Entry
void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &amp;gt;= threshold) &amp;amp;&amp;amp; (null != table[bucketIndex])) {
        resize(2 * table.length); //扩容2倍
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}
//创建一个Entry
void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry&amp;lt;K,V&amp;gt; e = table[bucketIndex];//先把table中该位置原来的Entry保存
    //在table中该位置新建一个Entry，将原来的Entry挂到该Entry的next
    table[bucketIndex] = new Entry&amp;lt;&amp;gt;(hash, key, value, e);
    //所以table中的每个位置永远只保存一个最新加进来的Entry，其他Entry是一个挂一个，这样挂上去的
    size++;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在假如 A 线程和 B 线程同时进入 addEntry，然后计算出了相同的哈希值对应了相同的数组位置，因为此时该位置还没数据，然后对同一个数组位置调用 createEntry，两个线程会同时得到现在的头结点，然后 A 写入新的头结点之后，B 也写入新的头结点，那 B 的写入操作就会覆盖A的写入操作造成 A 的写入操作丢失。&lt;/p&gt;
&lt;h2 id=&quot;hashmap扩容的时候&quot;&gt;2. HashMap扩容的时候&lt;/h2&gt;
&lt;p&gt;还是上面那个 addEntry 方法中，有个扩容的操作，这个操作会新生成一个新的容量的数组，然后对原数组的所有键值对重新进行计算和写入新的数组，之后指向新生成的数组。来看一下扩容的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//用新的容量来给table扩容  
void resize(int newCapacity) {  
    Entry[] oldTable = table; //保存old table  
    int oldCapacity = oldTable.length; //保存old capacity  
    // 如果旧的容量已经是系统默认最大容量了，那么将阈值设置成整形的最大值，退出    
    if (oldCapacity == MAXIMUM_CAPACITY) {  
        threshold = Integer.MAX_VALUE;  
        return;  
    }  
  
    //根据新的容量新建一个table  
    Entry[] newTable = new Entry[newCapacity];  
    //将table转换成newTable  
    transfer(newTable, initHashSeedAsNeeded(newCapacity));  
    table = newTable;  
    //设置阈值  
    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);  
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么问题来了，当多个线程同时进来，检测到总数量超过门限值的时候就会同时调用 resize操作，各自生成新的数组并 rehash 后赋给该 map 底层的数组 table，结果最终只有最后一个线程生成的新数组被赋给 table 变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的 table 作为原始数组，这样也会有问题。所以在扩容操作的时候也有可能会引起一些并发的问题。&lt;/p&gt;
&lt;h2 id=&quot;删除hashmap中数据的时候&quot;&gt;3. 删除HashMap中数据的时候&lt;/h2&gt;
&lt;p&gt;删除键值对的源代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//根据指定的key删除Entry，返回对应的value  
public V remove(Object key) {  
    Entry&amp;lt;K,V&amp;gt; e = removeEntryForKey(key);  
    return (e == null ? null : e.value);  
}  
  
//根据指定的key，删除Entry,并返回对应的value  
final Entry&amp;lt;K,V&amp;gt; removeEntryForKey(Object key) {  
    if (size == 0) {  
        return null;  
    }  
    int hash = (key == null) ? 0 : hash(key);  
    int i = indexFor(hash, table.length);  
    Entry&amp;lt;K,V&amp;gt; prev = table[i];  
    Entry&amp;lt;K,V&amp;gt; e = prev;  
  
    while (e != null) {  
        Entry&amp;lt;K,V&amp;gt; next = e.next;  
        Object k;  
        if (e.hash == hash &amp;amp;&amp;amp;  
            ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))) {  
            modCount++;  
            size--;  
            if (prev == e) //如果删除的是table中的第一项的引用  
                table[i] = next;//直接将第一项中的next的引用存入table[i]中  
            else  
                prev.next = next; //否则将table[i]中当前Entry的前一个Entry中的next置为当前Entry的next  
            e.recordRemoval(this);  
            return e;  
        }  
        prev = e;  
        e = next;  
    }  
  
    return e;  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除这一块可能会出现两种线程安全问题，第一种是一个线程判断得到了指定的数组位置i并进入了循环，此时，另一个线程也在同样的位置已经删掉了i位置的那个数据了，然后第一个线程那边就没了。但是删除的话，没了倒问题不大。&lt;/p&gt;
&lt;p&gt;再看另一种情况，当多个线程同时操作同一个数组位置的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写会到该数组位置去，其实写回的时候可能其他的线程已经就把这个位置给修改过了，就会覆盖其他线程的修改。&lt;/p&gt;
&lt;p&gt;其他地方还有很多可能会出现线程安全问题，我就不一一列举了，总之 HashMap 是非线程安全的，在高并发的场合使用的话，要用 Collections.synchronizedMap 进行包装一下，或者直接使用 ConcurrentHashMap 都行。&lt;/p&gt;
&lt;p&gt;关于 HashMap 的线程非安全性，就总结这么多，如有问题，欢迎交流，我们一同进步~&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 14:49:00 +0000</pubDate>
<dc:creator>程序员私房菜</dc:creator>
<og:description>在前面我的一篇总结（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eson15/p/10252838.html</dc:identifier>
</item>
<item>
<title>记一次程序员半路撂挑子，老板带警察进公司抓人的经历 - 锋哥程序十年</title>
<link>http://www.cnblogs.com/bianchengniuren/p/10252487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bianchengniuren/p/10252487.html</guid>
<description>&lt;p&gt;有人的地方就有江湖，有江湖的地方就有套路。我十二年的程序员生涯，经历了职场上的种种奇葩事。今天就通过一件真实的案例，告诉你一个道理： 把公司当做家，老板在场时口头上说说好了，可千万别当真。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;核心员工，锋芒毕露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2010年的时候，我加盟一家创业公司。带我的师父王哥是从华为出来的，技术非常厉害。当时公司的架构从上到下是，老板——&amp;gt;技术总监——&amp;gt;软件经理——&amp;gt;我师傅——&amp;gt;我。我师父王哥在公司几乎扮演全能战士的职位。有些软件经理不懂的问题，都会找他去讨论，是一个深得老板信任的员工。老板很看重他，同时他也很拼，经常为公司加班到深夜。就因为我师父当时表现的太抢眼，所以为后面的事情埋下了伏笔。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;引入竞争，受到排挤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;木秀于林，风必摧之。在公司表现太抢眼的人，往往都落得个被排挤的下场。员工一旦表现的比领导出色，就要知道收敛，在研发团队也不例外。&lt;/p&gt;
&lt;p&gt;软件经理看到王哥的技术过于厉害，长此下去团队不好管理，于是决定引入另外一个厉害的角色大A。大A属于B公司的技术大拿，技术也非常厉害。大A和王哥相比，虽然技术上处于下风，但是他懂得察言观色，见风使舵，是个厉害的狠角色。&lt;/p&gt;
&lt;p&gt;软件经理有大A撑腰，在老板面前对王哥很多的想法进行打压，王哥心里不爽。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;骑驴找马，另谋高就&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;王哥意识到这样下去不是办法。一方面公司加班非常辛苦，另一方面自己很多技术上的建议不受待见，无从发挥。于是王哥萌生退意，开始留意新的工作机会。软件经理见王哥加班没有以前积极了，颇有微词，经常在老板面前说王哥的坏话。王哥在公司的处境和地位越来越边缘化。&lt;/p&gt;
&lt;p&gt;终于，有公司向王哥抛来了橄榄枝，王哥果断提出离职。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;核心成员，不可或缺&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;王哥要走了。软件经理慌了。之前很多技术难点都是王哥一手搞定的，现在离职的话，留下一大堆烂摊子。大A虽然说也是个技术高手，但是刚来公司没多久，很多东西并不能全部接手过来搞。于是软件经理和老板一轮轮的找王哥“谈心”，各种承诺好处。但是王哥岂是职场菜鸟？坚决不留。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;老板怒了，报警抓人&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然在99%的程序员眼里，老板都是个傻逼。但事实并非如此，没有两把刷子，老板岂能称之为老板？软的不行，就来硬的。老板这个时候彻查王哥在职期间的邮件系统记录，发现王哥曾经把公司的一段代码外发给别人。&lt;/p&gt;
&lt;p&gt;一小部分代码，虽然不能对公司造成多大的影响，可能也是王哥的无意为之。但事情的大小，由人说了算。王哥这个行为，已经触犯到了法律，竟然把公司的“核心代码”外发他人！老板“果断”报警，警察冲进公司，当着所有同事的面把王哥带走。证据确凿，王哥无法抵赖。我当时真为王哥捏了一把汗。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;讲和，王哥留下戴罪立功&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;技术总监老K一直将事情看在眼里，平时也没有多说话，现在终于轮到他登场了。老K深知老板的心思，同时不想自己的得力干将身陷牢狱之灾，于是提出做中间的和事佬。一方面找到王哥说明厉害，劝他留下来戴罪立功。同时找到老板，让老板放王哥一马。&lt;/p&gt;
&lt;p&gt;王哥没有其他的路子，只能示弱，主动向老板承认错误。老板也顺水推舟，答应放王哥一马，只是要求王哥留下来继续做项目。&lt;/p&gt;
&lt;p&gt;最终，已经都和我们吃过道别晚宴的王哥，又留在了公司。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;王哥这次成功化险为夷，其实已经是不幸中的万幸。如果王哥没有了利用价值，老板决心置王哥于死地，后果将不堪设想。程序员在公司里平时更应该谨言慎行，不要留下把柄，更不能触犯法律。如果真的把公司当做自己的家，大大咧咧的，迟早吃亏的是自己。 职场如战场，我也经常在我的《编程牛人》公众号和大家分享我这十二年程序员的经验，如果有问题欢迎找我讨论。&lt;/p&gt;
</description>
<pubDate>Thu, 10 Jan 2019 14:47:00 +0000</pubDate>
<dc:creator>锋哥程序十年</dc:creator>
<og:description>有人的地方就有江湖，有江湖的地方就有套路。我十二年的程序员生涯，经历了职场上的种种奇葩事。今天就通过一件真实的案例，告诉你一个道理： 把公司当做家，老板在场时口头上说说好了，可千万别当真。 核心员工，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bianchengniuren/p/10252487.html</dc:identifier>
</item>
<item>
<title>进程、线程、协程和GIL（二） - 宋讼颂</title>
<link>http://www.cnblogs.com/ss-py/p/10238067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ss-py/p/10238067.html</guid>
<description>&lt;p&gt;　　　　上一篇博客讲了进程、线程、协程和GIL的基本概念，这篇我们来说说在以下三点：&lt;/p&gt;
&lt;p&gt;　　1&amp;gt; python中使用threading库来创建线程的两种方式&lt;/p&gt;
&lt;p&gt;　　2&amp;gt; 使用Event对消来判断线程是否已启动&lt;/p&gt;
&lt;p&gt;　　3&amp;gt; 使用Semaphore和BoundedSemaphore两个类分别来控制线程的并发数以及二者之间的区别。&lt;/p&gt;
&lt;p&gt;　　如果想要了解基本概念，请移步我的上一篇博客：&lt;a href=&quot;https://www.cnblogs.com/ss-py/p/10236125.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/ss-py/p/10236125.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正文：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;利用threading库来在创建一个线程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是： %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (name))
    
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    t &lt;/span&gt;= Thread(target=run, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;线程1号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
    t.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：　　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252647/201901/1252647-20190108161408937-1625417804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　首先，创建一个Thread线程，并用target=run来指定这个线程需要执行那个run方法，然后将run方法所需的参数以args参数的形式传递过去，&lt;/p&gt;
&lt;p&gt;　　请注意，args所传的参数是一个元组（tuple）类型，因此即使元组中只有一个参数，也要在这个参数后再加一个逗号，如 args=('线程1号',)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252647/201901/1252647-20190108160659552-1696559442.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　而且，当我们创建一个线程对象后，这个线程并不会立即执行，除非调用它的star()方法，当调用star()方法后，这个线程会调用你使用target传给他的函数，&lt;/p&gt;
&lt;p&gt;　　并将args中的参数传递给这个函数。&lt;/p&gt;
&lt;p&gt;　　Python中的线程会在一个单独的系统级线程中执行（如一个POSIX线程或一个Windows线程），这些线程全部由操作系统进行管理，线程一旦启动，&lt;/p&gt;
&lt;p&gt;　　它将独立运行直至目标函数运行结束。&lt;/p&gt;
&lt;p&gt;　　我们可以调用is_alive()方法来进行判断该线程是否在运行（is_alive()方法返回True或者False）：&lt;/p&gt;
&lt;p&gt;　　我们知道，进程是依赖于线程来执行的，所以当我们的py文件在执行时，我们可以理解为有一个主线程在执行，当我们创建一个子线程时，就相当于当前程序一共有两个线程在执行。当子线程被创建后，主线程和子线程就独立运行，相互并不影响。&lt;/p&gt;
&lt;p&gt;　　代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(name):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     time.sleep(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是： %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (name))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     t = Thread(target=run, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;子线程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    t.start()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是主线程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252647/201901/1252647-20190108164406384-573438392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在代码的第9行，创建了一个线程t，让它来执行run()方法，这时，程序中就有了两个线程同时存在、各自独立运行，默认的，主线程是不会等待子线程的运算结果的，所以主线程继续向下执行，打印L“我是主线程”，而子线程在调用run()方法时sleep了两秒钟，之后才打印出“我是子线程”&lt;/p&gt;
&lt;p&gt;　　当然，我们可以手动的调用join()方法来让主线程等待子线程运行结束后再向下执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(name):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     time.sleep(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是： %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (name))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     t = Thread(target=run, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;子线程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    t.start()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    t.join()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是主线程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252647/201901/1252647-20190108165133873-1399930757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这时，程序在进行到第十行后，主线程就卡住了，它在等待子线程运行结束，档子线程运行结束后，主线程才会继续向下运行，直至程序退出。&lt;/p&gt;
&lt;p&gt;　　但是，但是，无论主线程等不等待子线程，Python解释器都会等待所有的线程都终止后才会退出。也就是说，无论主线程等不等待子线程，这个程序最终都&lt;/p&gt;
&lt;p&gt;　　会运行两秒多，因为子线程sleep了两秒。&lt;/p&gt;
&lt;p&gt;　　所以，当遇到需要长时间运行的线程或者是需要一直在后台运行的线程时，可以将其设置为后台线程（守护线程）daemon=True，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
t = Thread(target=run, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;子线程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,), daemon=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;守护线程&lt;/span&gt;，顾名思义是守护主线程的线程，他们是依赖于主线程而存在的，当主线程执行结束后，守护线程会被立即注销，无论该线程是否执行结束。&lt;/p&gt;
&lt;p&gt;　　当然，我们也可以利用join()来使主线程等待主线程。&lt;/p&gt;
&lt;p&gt;　　使用threading库来创建线程还有一种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; CreateThread(Thread):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        super().&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是子线程！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

t &lt;/span&gt;=&lt;span&gt; CreateThread()
t.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在开始t = Thread(target=run, args=('子线程',)）这种方式调用方法时子线程调用的run方法的这个方法名是我随便起的，实际上叫什么都行，&lt;/p&gt;
&lt;p&gt;　　但是以继承Thread类方式实现线程时，线程调用的方法名必须是run() 这个是程序写死的。&lt;/p&gt;

&lt;p&gt; 　　&lt;span&gt;使用Event对象判断线程是否已经启动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　threading库中的Event对象包含一个可由线程来设置的信号标志，它允许线程等待某些事件的发生。&lt;/p&gt;
&lt;p&gt;　　初始状态时，event对象中的信号标志被设置为假，如果有一个线程等待event对象，且这个event对象的标志为假，那么这个线程就会一直阻塞，直到该标志为真。如果将一个event对象的标志设置为真，他将唤醒所有等待这个标志的线程，如果一个线程等待一个被设置为真得Event对象，那么它将忽略这个事件，继续向下执行。　　&lt;/p&gt;
&lt;p&gt;　　Event (事件) 定义了一个全局的标志Flag，如果Flag为False，当程序执行event.wait()时就会阻塞，当Flag为True时，程序执行event.wait()时便不会阻塞：&lt;/p&gt;
&lt;p&gt;　　event.set():  将标志Flag设置为True， 并通知所有因等待该标志而处于阻塞状态的线程恢复运行。&lt;/p&gt;
&lt;p&gt;　　event.clear(): 将标志Flag设置为False&lt;/p&gt;
&lt;p&gt;　　event.wait():  判断当前标志状态，如果是True则立即返回，否则线程继续阻塞。&lt;/p&gt;
&lt;p&gt;　　event.isSet(): 获取标志Flag状态： 返回True或者False&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Thread, Event
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(num, start_evt):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; int(num) &amp;gt;10&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        start_evt.set()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        start_evt.clear()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; start_evt =&lt;span&gt; Event()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     num = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入数字&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     t = Thread(target=run, args=&lt;span&gt;(num, start_evt,))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    t.start()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     start_evt.wait()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 主线程获取Event对象的标志状态，若为True，则主线程继续执行，否则，主线程阻塞&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主线程继续执行！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上边这段代码：当输入的数字大于10时，将标志设置为True，主程序继续执行，当小于或者等于10时，将标志设为False（默认为False），主线程阻塞。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252647/201901/1252647-20190108181723778-722776515.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1252647/201901/1252647-20190108181738775-1554930142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　值得注意的是：当Event对象的标志被设置为True时，他会唤醒所有等待他的线程，如果只想唤醒某一个线程，最好使用信号量。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;信号量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　信号量，说白了就是一个计数器，用来控制线程的并发数，每次有线程获得信号量的时候（即acquire()）计数器－1，释放信号量时候(release())计数器＋1，计数器为0的时候其它线程就被阻塞无法获得信号量&lt;/p&gt;
&lt;p&gt;　　acquire()   # 设置一个信号量&lt;/p&gt;
&lt;p&gt;　　release()   # 释放一个信号量&lt;/p&gt;
&lt;p&gt;　　python中有两个类实现了信号量：（Semaphore和BoundedSemaphore）&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;Semaphore和BoundedSemaphore的相同之处&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　　　通过： threading.Semaphore(3) 或者 threading.BoundedSemaphore(3) 来设置初始值为3的计数器&lt;/p&gt;
&lt;p&gt;　　　　执行acquire() 计数器-1，执行release() 计数器+1，当计数器为0时，其他线程均无法再获得信号量从而阻塞&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading

&lt;span&gt;se &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= threading.BoundedSemaphore(3)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
    se.acquire()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;信号量被设置&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
    se.release()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;信号量被释放了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252647/201901/1252647-20190109233257682-1644242273.png&quot; alt=&quot;&quot;/&gt;   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading

&lt;span&gt;se &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= threading.Semaphore(3)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(5&lt;span&gt;):
    se.acquire()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;信号量被设置&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
    se.release()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;信号量被释放了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252647/201901/1252647-20190109233459991-213815389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，无论我们用那个类创建信号量，当计数器被减为0时，其他线程均会阻塞。&lt;/p&gt;
&lt;p&gt;　　这个功能经常被用来&lt;span&gt;控制线程的并发数&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　没有设置信号量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading

num &lt;/span&gt;= 3

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run():
    time.sleep(&lt;/span&gt;2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(time.time())

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    t_list &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(20&lt;span&gt;):
        t &lt;/span&gt;= threading.Thread(target=&lt;span&gt;run)
        t_list.append(t)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; t_list:
        i.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果：20个线程几乎在同时执行，，如果主机在执行IO密集型任务时执行这种程序时，主机有可能会宕机，&lt;/p&gt;
&lt;p&gt;　　但是在设置了信号量时，我们可以来控制同一时间同时运行的线程数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading

num &lt;/span&gt;= 3

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run():
    se.acquire()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加信号量&lt;/span&gt;
    time.sleep(2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(time.time())
    se.release()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  释放一个信号量&lt;/span&gt;


&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    t_list &lt;/span&gt;=&lt;span&gt; []
    se &lt;/span&gt;= threading.Semaphore(5)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置一个大小为5的计数器(同一时间，最多允许5个线程在运行)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
　　 # se = threading.BoundedSemaphore(5) 
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(20&lt;span&gt;):
        t &lt;/span&gt;= threading.Thread(target=&lt;span&gt;run)
        t_list.append(t)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; t_list:
        i.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这时，我们给程序加上信号量，控制它在同一时间内，最多只有5个线程在运行。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;两者之间的差异性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　当计数器达到设定好的上线时，BoundedSemaphore就无法进行release()操作了，Semaphore没有这个限制，它会抛出异常。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading


&lt;span&gt;se &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= threading.Semaphore(3)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将计数器值减为0&lt;/span&gt;
    se.acquire(3&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(5):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将计数器值加至5&lt;/span&gt;
&lt;span&gt;    se.release()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;信号量被释放了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252647/201901/1252647-20190109234854711-1700862514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading


se &lt;/span&gt;= threading.BoundedSemaphore(3&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将计数器值减为0&lt;/span&gt;
    se.acquire(3&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(5):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将计数器值加至5&lt;/span&gt;
&lt;span&gt;    se.release()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;信号量被释放了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252647/201901/1252647-20190109235000541-863711781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　抛异常了：信号量被释放太多次。。。&lt;/p&gt;
&lt;p&gt; 　　好了，这篇文章的就先写到这里，下一篇文章我会讲解关于线程间通信、线程加锁等问题&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　想了解更多关于Python、爬虫的信息，欢迎关注我的个人微信公众号：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252647/201901/1252647-20190110222713285-738127007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




</description>
<pubDate>Thu, 10 Jan 2019 14:28:00 +0000</pubDate>
<dc:creator>宋讼颂</dc:creator>
<og:description>上一篇博客讲了进程、线程、协程和GIL的基本概念，这篇我们来说说在以下三点： 1&gt; python中使用threading库来创建线程的两种方式 2&gt; 使用Event对消来判断线程是否已启动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ss-py/p/10238067.html</dc:identifier>
</item>
<item>
<title>学以致用:Python爬取廖大Python教程制作pdf - morethink</title>
<link>http://www.cnblogs.com/morethink/p/10252532.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/morethink/p/10252532.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/python-tutorial-pdf.jpeg&quot; title=&quot;python-tutorial-pdf&quot; alt=&quot;python-tutorial-pdf&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我学了廖大的Python教程后，感觉总得做点什么，正好自己想随时查阅，于是就开始有了制作PDF这个想法。&lt;/p&gt;
&lt;p&gt;想要把教程变成PDF有三步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先生成空html，爬取每一篇教程放进一个新生成的div，这样就生成了包含所有教程的html文件(&lt;code&gt;BeautifulSoup&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;将html转换成pdf(&lt;code&gt;wkhtmltopdf&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;由于廖大是写教程的，反爬做的比较好，在爬取的过程中还需要代理ip(&lt;code&gt;免费 or 付费&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote readability=&quot;8.4661016949153&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/&quot;&gt;Beautiful Soup&lt;/a&gt; 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;pip3 install BeautifulSoup4&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;开始使用&quot;&gt;开始使用&lt;/h2&gt;
&lt;p&gt;将一段文档传入 &lt;code&gt;BeautifulSoup&lt;/code&gt; 的构造方法,就能得到一个文档的对象, 可以传入一段字符串或一个文件句柄.&lt;/p&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from bs4 import BeautifulSoup
soup = BeautifulSoup(open(&quot;index.html&quot;))
soup = BeautifulSoup(&quot;&amp;lt;html&amp;gt;data&amp;lt;/html&amp;gt;&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先,文档被转换成Unicode,并且HTML的实例都被转换成Unicode编码.&lt;/li&gt;
&lt;li&gt;然后,Beautiful Soup选择最合适的解析器来解析这段文档,如果手动指定解析器那么Beautiful Soup会选择指定的解析器来解析文档.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;对象的种类&quot;&gt;对象的种类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Beautiful Soup&lt;/code&gt; 将复杂 &lt;code&gt;HTML&lt;/code&gt; 文档转换成一个复杂的树形结构,每个节点都是 &lt;code&gt;Python&lt;/code&gt; 对象,所有对象可以归纳为 4 种: &lt;code&gt;Tag , NavigableString , BeautifulSoup , Comment .&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Tag&lt;/code&gt;：通俗点讲就是 &lt;code&gt;HTML&lt;/code&gt; 中的一个个标签，类似 &lt;code&gt;div，p&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NavigableString&lt;/code&gt;：获取标签内部的文字，如，&lt;code&gt;soup.p.string&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeautifulSoup&lt;/code&gt;：表示一个文档的全部内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Comment：Comment&lt;/code&gt; 对象是一个特殊类型的 &lt;code&gt;NavigableString&lt;/code&gt; 对象，其输出的内容不包括注释符号.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;tag&quot;&gt;Tag&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Tag&lt;/code&gt;就是&lt;code&gt;html&lt;/code&gt;中的一个标签，用&lt;code&gt;BeautifulSoup&lt;/code&gt;就能解析出来&lt;code&gt;Tag&lt;/code&gt;的具体内容，具体的格式为&lt;code&gt;soup.name&lt;/code&gt;,其中&lt;code&gt;name&lt;/code&gt;是&lt;code&gt;html&lt;/code&gt;下的标签，具体实例如下：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;print soup.title&lt;/code&gt;输出&lt;code&gt;title&lt;/code&gt;标签下的内容，包括此标签，这个将会输出&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;print soup.head&lt;/code&gt;输出&lt;code&gt;head&lt;/code&gt;标签下的内容&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;如果 Tag 对象要获取的标签有多个的话，它只会返回所以内容中第一个符合要求的标签&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;tag-属性&quot;&gt;Tag 属性&lt;/h3&gt;
&lt;p&gt;每个 &lt;code&gt;Tag&lt;/code&gt; 有两个重要的属性 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;attrs&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;name&lt;/code&gt;：对于&lt;code&gt;Tag&lt;/code&gt;，它的&lt;code&gt;name&lt;/code&gt;就是其本身，如&lt;code&gt;soup.p.name&lt;/code&gt;就是&lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;attrs&lt;/code&gt;是一个字典类型的，对应的是属性-值，如&lt;code&gt;print soup.p.attrs&lt;/code&gt;,输出的就是&lt;code&gt;{'class': ['title'], 'name': 'dromouse'}&lt;/code&gt;,当然你也可以得到具体的值，如&lt;code&gt;print soup.p.attrs['class']&lt;/code&gt;,输出的就是&lt;code&gt;[title]&lt;/code&gt;是一个列表的类型，因为一个属性可能对应多个值,当然你也可以通过get方法得到属性的，如：&lt;code&gt;print soup.p.get('class')&lt;/code&gt;。还可以直接使用&lt;code&gt;print soup.p['class']&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;get&quot;&gt;get&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;get&lt;/code&gt;方法用于得到标签下的属性值，注意这是一个重要的方法，在许多场合都能用到，比如你要得到&lt;code&gt;&amp;lt;img src=&quot;#&quot;&amp;gt;&lt;/code&gt;标签下的图像&lt;code&gt;url&lt;/code&gt;,那么就可以用&lt;code&gt;soup.img.get('src')&lt;/code&gt;,具体解析如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 得到第一个p标签下的src属性
print soup.p.get(&quot;class&quot;)   &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;string&quot;&gt;string&lt;/h3&gt;
&lt;p&gt;得到标签下的文本内容，只有在此标签下没有子标签，或者只有一个子标签的情况下才能返回其中的内容，否则返回的是&lt;code&gt;None&lt;/code&gt;具体实例如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 在上面的一段文本中p标签没有子标签，因此能够正确返回文本的内容
print soup.p.string
# 这里得到的就是None,因为这里的html中有很多的子标签
print soup.html.string  &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;get_text&quot;&gt;&lt;code&gt;get_text()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;可以获得一个标签中的所有文本内容，包括子孙节点的内容，这是最常用的方法&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;搜索文档树&quot;&gt;搜索文档树&lt;/h2&gt;
&lt;p&gt;BeautifulSoup 主要用来遍历子节点及子节点的属性，通过&lt;code&gt;Tag&lt;/code&gt;取属性的方式只能获得当前文档中的第一个 tag，例如，&lt;code&gt;soup.p&lt;/code&gt;。如果想要得到所有的&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 标签,或是通过名字得到比一个 tag 更多的内容的时候,就需要用到 find_all()&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;find_all(name, attrs, recursive, text, **kwargs )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;find_all是用于搜索节点中所有符合过滤条件的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;name参数&lt;/strong&gt;：是Tag的名字，如p,div,title&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# 1. 节点名
print(soup.find_all('p'))
# 2. 正则表达式
print(soup.find_all(re.compile('^p')))
# 3. 列表  
print(soup.find_all(['p', 'a']))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外 attrs 参数可以也作为过滤条件来获取内容，而 limit 参数是限制返回的条数。&lt;/p&gt;
&lt;h2 id=&quot;css-选择器&quot;&gt;CSS 选择器&lt;/h2&gt;
&lt;p&gt;以 CSS 语法为匹配标准找到 Tag。同样也是使用到一个函数，该函数为&lt;code&gt;select()&lt;/code&gt;，返回类型是 list。它的具体用法如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 1. 通过 tag 标签查找
print(soup.select(head))
# 2. 通过 id 查找
print(soup.select('#link1'))
# 3. 通过 class 查找
print(soup.select('.sister'))
# 4. 通过属性查找
print(soup.select('p[name=dromouse]'))
# 5. 组合查找
print(soup.select(&quot;body p&quot;))&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;wkhtmltopdf主要用于HTML生成PDF。&lt;/li&gt;
&lt;li&gt;pdfkit是基于wkhtmltopdf的python封装，支持URL，本地文件，文本内容到PDF的转换，其最终还是调用wkhtmltopdf命令。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;安装-1&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;先安装wkhtmltopdf，再安装pdfkit。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;https://wkhtmltopdf.org/downloads.html&lt;/li&gt;
&lt;li&gt;pdfkit&lt;br/&gt;&lt;code&gt;shell pip3 install pdfkit&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;转换urlfilestring&quot;&gt;转换url/file/string&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pdfkit

pdfkit.from_url('http://google.com', 'out.pdf')
pdfkit.from_file('index.html', 'out.pdf')
pdfkit.from_string('Hello!', 'out.pdf')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;转换url或者文件名列表&quot;&gt;转换url或者文件名列表&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pdfkit.from_url(['google.com', 'baidu.com'], 'out.pdf')
pdfkit.from_file(['file1.html', 'file2.html'], 'out.pdf')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;转换打开文件&quot;&gt;转换打开文件&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;with open('file.html') as f:
    pdfkit.from_file(f, 'out.pdf')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义设置&quot;&gt;自定义设置&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;options = {
    'page-size': 'Letter',
    'margin-top': '0.75in',
    'margin-right': '0.75in',
    'margin-bottom': '0.75in',
    'margin-left': '0.75in',
    'encoding': &quot;UTF-8&quot;,
    'custom-header' : [
        ('Accept-Encoding', 'gzip')
    ]
    'cookie': [
        ('cookie-name1', 'cookie-value1'),
        ('cookie-name2', 'cookie-value2'),
    ],
    'no-outline': None,
    'outline-depth': 10,
}

pdfkit.from_url('http://google.com', 'out.pdf', options=options)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;爬取十几篇教程之后触发了这个错误：&lt;br/&gt;&lt;img src=&quot;https://images.morethink.cn/a7fa858c35a52d0bd1ed89a611546ef1.png&quot; title=&quot;503&quot; alt=&quot;503&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看来廖大的反爬虫做的很好，于是只好使用代理ip了，尝试了免费的&lt;a href=&quot;https://www.xicidaili.com/&quot;&gt;西刺免费代理&lt;/a&gt;后，最后选择了付费的 &lt;a href=&quot;https://center.abuyun.com&quot;&gt;阿布云&lt;/a&gt; ，感觉响应速度和稳定性还OK。&lt;/p&gt;

&lt;p&gt;运行过程截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.morethink.cn/ad8217afdd1d38c665a1a0341ade499e.png&quot; title=&quot;运行过程&quot; alt=&quot;运行过程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成的效果图：&lt;br/&gt;&lt;img src=&quot;https://images.morethink.cn/3b24e8815b5e9ac26184a3f1ab96bd1d.png&quot; title=&quot;效果图&quot; alt=&quot;效果图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;import time
import pdfkit
import requests
from bs4 import BeautifulSoup


# 使用 阿布云代理 
# 可以选择不使用或是其他代理
def get_soup(target_url):
    proxy_host = &quot;http-dyn.abuyun.com&quot;
    proxy_port = &quot;9020&quot;
    proxy_user = &quot;你的用户&quot;
    proxy_pass = &quot;你的密码&quot;
    proxy_meta = &quot;http://%(user)s:%(pass)s@%(host)s:%(port)s&quot; % {
        &quot;host&quot;: proxy_host,
        &quot;port&quot;: proxy_port,
        &quot;user&quot;: proxy_user,
        &quot;pass&quot;: proxy_pass,
    }

    proxies = {
        &quot;http&quot;: proxy_meta,
        &quot;https&quot;: proxy_meta,
    }
    headers = {'User-Agent':
                   'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'}
    flag = True
    while flag:
        try:
            resp = requests.get(target_url, proxies=proxies, headers=headers)
            flag = False
        except Exception as e:
            print(e)
            time.sleep(0.4)

    soup = BeautifulSoup(resp.text, 'html.parser')
    return soup


def get_toc(url):
    soup = get_soup(url)
    toc = soup.select(&quot;#x-wiki-index a&quot;)
    print(toc[0]['href'])
    return toc


# ⬇️教程html
def download_html(url, depth):
    soup = get_soup(url)
    # 处理目录
    if int(depth) &amp;lt;= 1:
        depth = '1'
    elif int(depth) &amp;gt;= 2:
        depth = '2'
    title = soup.select(&quot;.x-content h4&quot;)[0]
    new_title = BeautifulSoup('&amp;lt;h' + depth + '&amp;gt;' + title.string + '&amp;lt;/h' + depth + '&amp;gt;', 'html.parser')
    print(new_title)
    # 加载图片
    images = soup.find_all('img')
    for x in images:
        x['src'] = x['data-src']

    div_content = soup.find('div', class_='x-wiki-content')
    return new_title, div_content


def convert_pdf(template):
    html_file = &quot;python-tutorial-pdf.html&quot;
    with open(html_file, mode=&quot;w&quot;, encoding=&quot;utf8&quot;) as code:
        code.write(str(template))
    pdfkit.from_file(html_file, 'python-tutorial-pdf.pdf')


if __name__ == '__main__':
    # html 模板
    template = BeautifulSoup(
        '&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&quot;en&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.liaoxuefeng.com/cdn/static/themes/default/css/all.css?v=bc43d83&quot;&amp;gt; &amp;lt;script src=&quot;https://cdn.liaoxuefeng.com/cdn/static/themes/default/js/all.js?v=bc43d83&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;',
        'html.parser')
    # 教程目录
    toc = get_toc('https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000')
    for i, x in enumerate(toc):
        url = 'https://www.liaoxuefeng.com' + x['href']
        # ⬇️教程html
        content = download_html(url, x.parent['depth'])
        # 往template添加新的教程
        new_div = template.new_tag('div', id=i)
        template.body.insert(3 + i, new_div)
        new_div.insert(3, content[0])
        new_div.insert(3, content[1])
        time.sleep(0.4)
    convert_pdf(template)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参考文档&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://beautifulsoup.readthedocs.io/zh_CN/latest/&quot;&gt;Beautiful Soup 文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/4d65857ffe5e&quot;&gt;HTML 转 PDF 之 wkhtmltopdf 工具精讲&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 10 Jan 2019 13:38:00 +0000</pubDate>
<dc:creator>morethink</dc:creator>
<og:description>当我学了廖大的Python教程后，感觉总得做点什么，正好自己想随时查阅，于是就开始有了制作PDF这个想法。 想要把教程变成PDF有三步： 1. 先生成空html，爬取每一篇教程放进一个新生成的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/morethink/p/10252532.html</dc:identifier>
</item>
</channel>
</rss>