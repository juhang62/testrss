<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ELK(elasticsearch+kibana+logstash)搜索引擎(二)： elasticsearch基础教程 - waen</title>
<link>http://www.cnblogs.com/buggeerWang/p/10714181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buggeerWang/p/10714181.html</guid>
<description>&lt;p&gt;　　首先elasticsearch目前的结构为 /index/type/id  id对应的就是存储的文档ID，elasticsearch一般将数据以JSON格式存储。我们可以将elasticsearch和关系型数据库进行比较，index相当于关系型数据库中的database，type相当于table，而id就相当于表中的主键，elasticsearch中一个文档存储的一个json则能视为是关系型数据库中一张表的一行数据，而ID就是他的主键，在理解了es的存储结构后我们就可以对elasticsearch的一些基本使用进行了解了。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;　　elasticsearch在导入数据到索引时会按照固定的模板去导入数据，模板中可以设置字段的数据类型，以及设置数据的分词策略，&lt;span&gt;注意es会在数据导入时就对数据做分词，然后在搜索数据的时候，会按照存入时的分词策略查询数据&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{&lt;/span&gt;&quot;settings&quot;&lt;span&gt;:{
         &lt;/span&gt;&quot;analysis&quot;&lt;span&gt; : {
            &lt;/span&gt;&quot;analyzer&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;ik&quot;&lt;span&gt; : {
                    &lt;/span&gt;&quot;tokenizer&quot; : &quot;ik_max_word&quot;&lt;span&gt;
                }
            }
        },
        &lt;/span&gt;&quot;index&quot;&lt;span&gt; : {
            &lt;/span&gt;&quot;analysis.analyzer.default.type&quot;: &quot;ik_max_word&quot;&lt;span&gt;
        }
    },
  &lt;/span&gt;&quot;mappings&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;doc&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;dynamic&quot;: &quot;false&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;properties&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;brand&quot;&lt;span&gt;: {
          &lt;/span&gt;&quot;type&quot;: &quot;string&quot;&lt;span&gt;,
          &lt;/span&gt;&quot;analyzer&quot;: &quot;ik_max_word&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;product_name&quot;&lt;span&gt;: {
          &lt;/span&gt;&quot;type&quot;: &quot;string&quot;&lt;span&gt;,
          &lt;/span&gt;&quot;analyzer&quot;: &quot;ik_max_word&quot;&lt;span&gt;
        }
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于分词，elasticsearch中默认的标准分词器基本只能将一句话只能分成一个个的字，所以我们要用到ik分词器，切记版本问题。&lt;/p&gt;
&lt;p&gt;下载地址》》：&lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-ik&quot; target=&quot;_blank&quot;&gt;https://github.com/medcl/elasticsearch-analysis-ik&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载完成直接解压到es的pulgin目录下就行，ik分词器默认有两种分词方式：&lt;/p&gt;
&lt;p&gt;　　(1) ik_max_word，该模式的分词策略为最大化词汇搜索，既会递归整个词条，将词条中所有的语句列出，允许重复。&lt;/p&gt;
&lt;p&gt;　　(2) ik_smart，该策略不允许词汇重复，词条中如果有没有匹配到词典的字直接忽略&lt;/p&gt;
&lt;p&gt;关于ik分词器这里就不再详细叙述了，有一些关于词典的知识请大家自行百度，这里只对elasticsearch重点讲述！&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;①query组件&lt;/h3&gt;
&lt;p&gt;好了，到了正式介绍es的时候，搜索引擎不用多说搜索肯定是最重要的一点，下面给出一个最简单的例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415225434094-732675817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　首先看到 红色箭头1 ，整个语句意思从前至后 分别为 GET 方式对es请求， /catalogue 为请求的索引地址，可以具体到/type甚至id，/_search代表发起查询请求，而后面的则是请求的json体，毫无疑问json体是搜索的关键也是今天的主要讲解内容。&lt;/p&gt;
&lt;p&gt;       再看到红色剪头2，es中所有的查询都要包含在query组件中，query后面则跟着一个JSON，JSON的内容也就是红色剪头3，match_all代表无条件的查询即搜索所有，同样的还有match代表有条件的查询，查询条件放在match后面的json中，记住整个查询体都按照json格式来写。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415230118052-236538067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上队商品名进行查询，查出所有名字包含洗衣粉的商品，搜索结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415230453594-2080574300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到返回hits的其实是个json数组，每个json中包含着该数据的index、type、id以及匹配的分数_score以及数据_source&lt;/p&gt;
&lt;p&gt;好了，这样就介绍完了最基本的单条件搜索&lt;/p&gt;
&lt;h3&gt;②bool组件&lt;/h3&gt;
&lt;p&gt;上面是单条件查询，那么多条件怎么查询呢，可以看到如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415231110293-1210019448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到直接在query里面是不能进行多条件查找的，这里需要用到bool组件&lt;/p&gt;
&lt;p&gt;使用bool组件进行复杂的查询：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415231357478-934982852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到使用bool组件后多条件搜索就没有报错，那么bool的结构是怎么样呢？&lt;/p&gt;
&lt;p&gt;bool表达式包含三个jsonArray：&lt;/p&gt;
&lt;p&gt;　　（1）must 包含了所有必须匹配的条件，如果有一项不匹配则排除，类似于逻辑且&lt;/p&gt;
&lt;p&gt;　　  (2)  should包含的条件必须满足至少一个，类似于逻辑或&lt;/p&gt;
&lt;p&gt;　　（3）must_not 包含了所有排除的条件，类似于逻辑非&lt;/p&gt;
&lt;p&gt;整个结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;query&quot;&lt;span&gt;:{
        &lt;/span&gt;&quot;bool&quot;&lt;span&gt;:{
            &lt;/span&gt;&quot;must&quot;&lt;span&gt;:[],
            &lt;/span&gt;&quot;should&quot;&lt;span&gt;:[],
            &lt;/span&gt;&quot;must_not&quot;&lt;span&gt;:[]
        }
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且bool直接多重嵌套使用，所以想做出复杂的搜索功能，可以在bool上多下功夫&lt;/p&gt;
&lt;p&gt;还有如上图中的range范围控制，和size查询的大小就不细说，看图应该就明白了&lt;/p&gt;
&lt;h3&gt;③分页查询&lt;/h3&gt;
&lt;p&gt;这里再讲一下es中怎么做到分页查询&lt;/p&gt;
&lt;p&gt;es中和size并列还有from属性，size是一次查询的数量，from则是从第几个开始查，搭配使用即可达到分页查询的目的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415232558595-1747113964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;④排序&lt;/h3&gt;
&lt;p&gt;es中可以使用sort对数据进行排序，sort为一个jsonArray，可以按照多个字段对数据进行排序，说明一下，如果不使用sort排序，es则默认按照_score匹配分数进行降序排序，&lt;span&gt;当使用sort并且sort中没有_score时，_score会变成null从而达到排除按照_score排序&lt;span&gt;，按照多个条件进行排序时，按照jsonArray中json的排序顺序进行先排和后排，关于升序降序学过数据库的童鞋应该很清楚！什么？没学过数据库？那你现在还不去学数据库？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594654/201904/1594654-20190415233026593-1820814579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此elasticsearch基础教程结束，后面将为大家带来elasticsearch的进阶教程和ELK架构实现电商搜索引擎&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:40:00 +0000</pubDate>
<dc:creator>waen</dc:creator>
<og:description>1.elasticsearch的结构 首先elasticsearch目前的结构为 /index/type/id id对应的就是存储的文档ID，elasticsearch一般将数据以JSON格式存储。我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/buggeerWang/p/10714181.html</dc:identifier>
</item>
<item>
<title>React + TypeScript：元素引用的传递 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/react_typescript_forwardref.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/react_typescript_forwardref.html</guid>
<description>&lt;p&gt;React 中需要操作元素时，可通过 &lt;code&gt;findDOMNode()&lt;/code&gt; 或通过 &lt;code&gt;createRef()&lt;/code&gt; 创建对元素的引用来实现。前者官方不推荐，所以这里讨论后者及其与 TypeScript 结合时如何工作。&lt;/p&gt;
&lt;h2&gt;React 中的元素引用&lt;/h2&gt;
&lt;p&gt;正常的组件中，可通过创建对元素的引用来获取到某元素然后进行相应操作。比如元素加载后将焦点定位到输入框。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;Component&lt;/span&gt; {
  &lt;span class=&quot;pl-en&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;props&lt;/span&gt;){
    &lt;span class=&quot;pl-c1&quot;&gt;super&lt;/span&gt;(props);
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createRef&lt;/span&gt;();
  }

  &lt;span class=&quot;pl-en&quot;&gt;componentDidMount&lt;/span&gt;(){
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;current&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;focus&lt;/span&gt;()
  }

  &lt;span class=&quot;pl-en&quot;&gt;render&lt;/span&gt;() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;div className&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;App&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;input type&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; ref&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;{&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;}&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建对元素的引用是通过 &lt;code&gt;React.createRef()&lt;/code&gt; 方法完成的。使用的时候，通过其返回对象身上的 &lt;code&gt;current&lt;/code&gt; 属性可访问到绑定引用的元素。&lt;/p&gt;
&lt;p&gt;React 内部对引用的 &lt;code&gt;current&lt;/code&gt; 赋值更新发生在 &lt;code&gt;componentDidMount&lt;/code&gt; 或 &lt;code&gt;componentDidUpdate&lt;/code&gt; 生命周期之前，即存在使用的时候引用未初始化完成的情况，所以 &lt;code&gt;current&lt;/code&gt; 不一定有值。好的做法是使用前先判空。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;current&lt;/span&gt;){
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;current&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;focus&lt;/span&gt;()
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的示例中，之所以不用判空是因为我们在 &lt;code&gt;componentDidMount&lt;/code&gt; 生命周期中使用，此时元素已经加载到页面，所以可以放心使用。&lt;/p&gt;
&lt;h2&gt;组件中引用的传递&lt;/h2&gt;
&lt;p&gt;对于原生 DOM 元素可以像上面那样创建引用，但对于自己写的组件，则需要使用 &lt;code&gt;forwardRef()&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;p&gt;假如你写了个按钮组件，想要实现像上面那样，让使用者可通过传递一个 &lt;code&gt;ref&lt;/code&gt; 属性来获取到组件中原生的这个 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 元素以进行相应的操作。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;button.jsx&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;FancyInput&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;props&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;input type&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; className&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;fancy-input&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加 ref 支持后的按钮组件：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;button.jsx&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;FancyInput&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;forwardRef&lt;/span&gt;((&lt;span class=&quot;pl-smi&quot;&gt;props&lt;/span&gt;, &lt;span class=&quot;pl-smi&quot;&gt;ref&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;input type&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; ref&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;{ref} className&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;fancy-input&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;forwardRef&lt;/code&gt; 接收一个函数，函数的入参中第一个是组件的 props，第二个便是外部传递进来的 ref 引用。通过将这个引用在组件中绑定到相应的原生 DOM 元素上，实现了外部直接引用到组件内部元素的目的，所以叫 &lt;code&gt;forwardRef&lt;/code&gt;（传递引用）。&lt;/p&gt;
&lt;p&gt;使用上面创建的 &lt;code&gt;FancyInput&lt;/code&gt;，在组件加载后使其获得焦点：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
class App extends Component {
  constructor(props) {
    super(props);
    this.inputRef = React.createRef();
  }

  componentDidMount() {
    if (this.inputRef.current) {
      this.inputRef.current.focus();
    }
  }

  render() {
    return (
      &amp;lt;div className=&quot;App&quot;&amp;gt;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;        &amp;lt;input type=&quot;text&quot; ref={this.inputRef}/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;        &amp;lt;FancyInput ref={this.inputRef} /&amp;gt;&lt;/span&gt;
      &amp;lt;/div&amp;gt;
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;TypeScript 中传递引用&lt;/h2&gt;
&lt;p&gt;先看正常情况下，对原生 DOM 元素的引用。还是上面的示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;Component&lt;/span&gt;&amp;lt;{}, {}&amp;gt; {
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; inputRef &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createRef&lt;/span&gt;();

  componentDidMount() {
    &lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/**&lt;/span&gt; 🚨 Object is possibly 'null' &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;current&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;focus&lt;/span&gt;();
  }

  render() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;App&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
        {&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; 🚨 Type '{}' is missing the following properties from type 'HTMLInputElement':... &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;}
        &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;{this.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;} &lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;像上面那样创建并使用存在两个问题。&lt;/p&gt;
&lt;p&gt;一个是提示我们的引用无法赋值到 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 的 &lt;code&gt;ref&lt;/code&gt; 属性上，类型不兼容。引用需要与它真实所指代的元素类型相符，这正是 TypeScript 类型检查为我们添加的约束。这个约束的好处是，我们在使用引用的时候，就知道这个引用真实的元素类型，TypeScript 会自动提示可用的方法和属性，同时防止调用该元素身上没有的属性和方法。这里修正的方法很简单，如果 hover 或 &lt;kbd&gt;F12&lt;/kbd&gt; 查看 &lt;code&gt;React.createRef()&lt;/code&gt; 的方法签名，会发现它是个泛型方法，支持传递类型参数。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; createRef&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;()&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;RefObject&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以上面创建引用时，显式指定它的类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt; private inputRef = React.createRef();&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt; private inputRef = React.createRef&amp;lt;HTMLInputElement&amp;gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二个问题是即使在 &lt;code&gt;componentDidMount&lt;/code&gt; 生命周期中使用，TypeScript 仍然提示 &lt;code&gt;current&lt;/code&gt; 的值有可能为空。上面讨论过，其实此时我们知道它不可能为空的。但因为 TypeScript 无法理解 &lt;code&gt;componentDidMount&lt;/code&gt;，所以它不知道此时引用其实是可以安全使用的。解决办法当然是加上判空的逻辑。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
  componentDidMount() {
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    if(this.inputRef.current){&lt;/span&gt;
      this.inputRef.current.focus();
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;    }&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可通过变量后添加 &lt;code&gt;!&lt;/code&gt; 操作符告诉 TypeScript 该变量此时非空。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-diff&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
  componentDidMount() {
&lt;span class=&quot;pl-md&quot;&gt;&lt;span class=&quot;pl-md&quot;&gt;-&lt;/span&gt;      this.inputRef.current.focus();&lt;/span&gt;
&lt;span class=&quot;pl-mi1&quot;&gt;&lt;span class=&quot;pl-mi1&quot;&gt;+&lt;/span&gt;      this.inputRef.current!.focus();&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修复后完整的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;Component&lt;/span&gt;&amp;lt;{}, {}&amp;gt; {
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; inputRef &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createRef&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;HTMLInputElement&lt;/span&gt;&amp;gt;();

  componentDidMount() {
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;focus&lt;/span&gt;();
  }

  render() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;App&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;{this.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;} &lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;React + TypeScript 组件引用的传递&lt;/h2&gt;
&lt;p&gt;继续到组件的情况，当需要引用的元素在另一个组件内部时，还是通过 &lt;code&gt;React.forwardRef()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这是该方法的签名：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; forwardRef&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;, &lt;span class=&quot;pl-en&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; {}&amp;gt;(&lt;span class=&quot;pl-v&quot;&gt;Component&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;RefForwardingComponent&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;, &lt;span class=&quot;pl-en&quot;&gt;P&lt;/span&gt;&amp;gt;)&lt;span class=&quot;pl-k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;ForwardRefExoticComponent&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;PropsWithoutRef&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;P&lt;/span&gt;&amp;gt; &lt;span class=&quot;pl-k&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;RefAttributes&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;T&lt;/span&gt;&amp;gt;&amp;gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，方法接收两个类型参数，&lt;code&gt;T&lt;/code&gt; 为需要引用的元素类型，我们示例中是 &lt;code&gt;HTMLInputElement&lt;/code&gt;，&lt;code&gt;P&lt;/code&gt; 为组件的 props 类型。&lt;/p&gt;
&lt;p&gt;所以添加引用传递后，&lt;code&gt;FancyInput&lt;/code&gt; 组件在 TypeScript 中的版本应该长这样：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;const&lt;/span&gt;&lt;/span&gt; FancyInput &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;forwardRef&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;HTMLInputElement&lt;/span&gt;, {}&amp;gt;((&lt;span class=&quot;pl-v&quot;&gt;props&lt;/span&gt;, &lt;span class=&quot;pl-v&quot;&gt;ref&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;=&amp;gt;&lt;/span&gt; {
  &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &amp;lt;&lt;span class=&quot;pl-en&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;text&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;ref&lt;/span&gt;={&lt;span class=&quot;pl-en&quot;&gt;ref&lt;/span&gt;} &lt;span class=&quot;pl-en&quot;&gt;className&lt;/span&gt;=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;fancy-input&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; /&amp;gt;;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用组件：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-ts&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;pl-e&quot;&gt;Component&lt;/span&gt;&amp;lt;{}, {}&amp;gt; {
  &lt;span class=&quot;pl-k&quot;&gt;private&lt;/span&gt; inputRef &lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;createRef&lt;/span&gt;&amp;lt;&lt;span class=&quot;pl-en&quot;&gt;HTMLInputElement&lt;/span&gt;&amp;gt;();

  componentDidMount() {
    &lt;span class=&quot;pl-c1&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;!&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;focus&lt;/span&gt;();
  }

  render() {
    &lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; (
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;className&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;App&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;FancyInput&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;{this.&lt;span class=&quot;pl-smi&quot;&gt;inputRef&lt;/span&gt;} &lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;
    );
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:32:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>React 中需要操作元素时，可通过 findDOMNode() 或通过 createRef() 创建对元素的引用来实现。前者官方不推荐，所以这里讨论后者及其与 TypeScript 结合时如何工作。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/react_typescript_forwardref.html</dc:identifier>
</item>
<item>
<title>Java8新特性之一：Lambda表达式 - 无恨之都</title>
<link>http://www.cnblogs.com/wuhenzhidu/p/lambda.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhenzhidu/p/lambda.html</guid>
<description>&lt;p&gt;　　Java8是自java5之后最重大的一次更新，它给JAVA语言带来了很多新的特性（包括编译器、类库、工具类、JVM等），其中最重要的升级是它给我们带来了Lambda表达式和Stream API。&lt;/p&gt;
&lt;h2&gt;1、什么是Lambda表达式？&lt;/h2&gt;
&lt;p&gt;　　Lambda是一个匿名函数，可以理解为是一段可以传递的代码，可以将代码像传递参数、传递数据一样进行传输。使用Lambda表达式，可以写出更加紧凑、更加简洁、更加灵活的代码。&lt;/p&gt;
&lt;h2&gt;2、使用Lambda的限制条件&lt;/h2&gt;
&lt;p&gt;　　Lambda并不是任何地方都可以使用，Lambda表达式需要“函数式接口”的支持。&lt;/p&gt;
&lt;h2&gt;3、什么是函数式接口？&lt;/h2&gt;
&lt;p&gt;　　接口中只有一个抽象方法的接口，称为函数式接口，可以用@FunctionalInterface修饰一下，这里需要注意的是：未使用 @FunctionalInterfaces注解的接口未必就不是函数式接口，一个接口是不是函数式接口的条件只有一条，即接口中只有一个抽象方法的接口（Object类中的方法不算）。而使用@FunctionalInterface注解修饰了的接口就一定是函数式接口，添加@FunctionalInterface注解可以帮助我们检查是否是函数式接口。&lt;/p&gt;
&lt;p&gt;JDK中常见的函数式接口有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Callable&amp;lt;V&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     V call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下接口中虽然有两个方法，但因hashCode()是Object类中的方法，因此该接口也是函数式接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; FuncInterface {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomething();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; hashCode();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Object类中的方法&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;4、Lambda表达式示例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　需求一：开启一个线程，在线程中打印出&quot;Hello World&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　未使用Lambda表达式时的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LambdaTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                System.out.println(&quot;Hello World&quot;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        thread.start();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用Lambda时的写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LambdaTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; System.out.println(&quot;Hello World&quot;));
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　需求二：模拟一个计算器，使其可以进行简单的加、减、乘操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　（1）、计算器操作函数式接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Calculator&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    T operation(T t1,T t2);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）具体操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CalculatorTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Integer operator(Integer v1,Integer v2,Calculator&amp;lt;Integer&amp;gt;&lt;span&gt; calculator) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; calculator.operation(v1,v2);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer add(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(x,y) -&amp;gt; x +&lt;span&gt; y);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer subtr(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(x,y) -&amp;gt; x -&lt;span&gt; y);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer multi(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(x,y) -&amp;gt; x *&lt;span&gt; y);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         CalculatorTest calculatorTest = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CalculatorTest();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加法&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         Integer add = calculatorTest.add(1,2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 减法&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         Integer sub = calculatorTest.subtr(100,82&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 乘法&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         Integer multi = calculatorTest.multi(5,3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        System.out.println(add);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        System.out.println(sub);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        System.out.println(multi);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;

&lt;p&gt;　　从这需求一中，我们可以看出，使用Lambda比使用匿名内部类代码更加简洁，同时，也可以理解为什么Lambda必须需要函数式接口的支持。我们假设Runnable中有两个方法，那么，“() -&amp;gt; System.out.println(Thread.currentThread().getName())”应该去找哪个方法去实现？&lt;/p&gt;
&lt;p&gt;　　从需求二的例子中，我们可以更加理解“一段可以传递的代码”这句话的含义。对数据的操作方法定义在Calculator接口中，而加、减、乘的具体实现代码在各自的方法中，并将这些实现作为参数传递给CalculatorTest类的operator()方法，最终返回操作结果。&lt;/p&gt;
&lt;h2&gt;5、Lambda表达式的语法&lt;/h2&gt;
&lt;h3&gt;5.1 Lambda表达式的语法结构&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(参数列表，对应的是接口中对应的抽象方法的参数列表) -&amp;gt; {对抽象方法的实现}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Lambda表达式语法分在3个部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;左边的参数列表，对应的是函数式接口中抽象方法的参数列表；&lt;/li&gt;
&lt;li&gt;中间的符号:-&amp;gt;,为固定写法; &lt;/li&gt;
&lt;li&gt;右边大括号内对函数接口抽象方法的实现。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　Lambda表达式的在具体场景下可以有简略写法。&lt;/p&gt;
&lt;h3&gt;5.2 语法格式一：无参数，无返回值&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Runnable runnable = () -&amp;gt; {System.out.println(&quot;Hello World&quot;&lt;span&gt;);} 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Runnable runnable = () -&amp;gt; System.out.println(&quot;Hello World&quot;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 简写形式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时，如果右边的代码简单，只有一行代码时，{}可以省略。&lt;/p&gt;
&lt;h3&gt;5.2 语法格式二：有一个参数，无返回值&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CalculatorTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print(Consumer&amp;lt;String&amp;gt;&lt;span&gt; msg) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        System.out.println(msg);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doPrint(String msg) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         print((str) -&amp;gt;&lt;span&gt; System.out.println(msg));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         print(str -&amp;gt; System.out.println(msg));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 简写&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时，左边的()可以省略。&lt;/p&gt;
&lt;h3&gt;5.3 语法格式三：Lambda体内只有一条语句，且有返回值，return可省略&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer subtr(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(x,y) -&amp;gt; x -&lt;span&gt; y);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.4 语法格式四：有两个以上参数，且Lambda体中有多条语句&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer add(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(x,y) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             System.out.println(&quot;进行加法运算&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.5 语法格式五：Lambda表达式的数据类型可以省略不写&lt;/h3&gt;
&lt;p&gt;　　JVM编译器通过上下文可以推断出数据类型，但要注意的是，当多个参数时，要么都写，要么都不写，不能有的写，有的不写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer subtr(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(Integer x,y) -&amp;gt; x - y);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 错误&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer subtr(Integer v1,Integer v2) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; operator(v1,v2,(x,y) -&amp;gt; x - y);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正确&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6、Java8四大内置核心函数式接口&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 Consumer&amp;lt;T&amp;gt;&lt;span&gt; : 消费型接口（无返回值，有去无回）
         &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; accept(T t);
 Supplier&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; : 供给型接口
         T get();
         
 Function&lt;/span&gt;&amp;lt;T,R&amp;gt;&lt;span&gt; : 函数型接口
        R apply(T t);
        
 Predicate&lt;/span&gt;&amp;lt;T&amp;gt;&lt;span&gt; : 断言型接口
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; test(T t);
        
四大核心接口的&lt;/span&gt;--&amp;gt;扩展子接口
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.Getter;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.Setter;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.Consumer;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.Function;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.Predicate;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.Supplier;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@Getter
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;@Setter
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;User{&quot; +
&lt;span&gt;18&lt;/span&gt;                 &quot;username='&quot; + username + '\'' +
&lt;span&gt;19&lt;/span&gt;                 &quot;, age=&quot; + age +
&lt;span&gt;20&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerInterface {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * 打印user信息
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print(User user,Consumer&amp;lt;User&amp;gt;&lt;span&gt; userConsumer) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        userConsumer.accept(user);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;     * 返回一个user
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; User getUser(Supplier&amp;lt;User&amp;gt;&lt;span&gt; userSupplier) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; userSupplier.get();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;     * 转换一个user
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; User transformUser(User user,Function&amp;lt;User,User&amp;gt;&lt;span&gt; function) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; function.apply(user);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;     * 检验User是否合法
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; checkUser(User user, Predicate&amp;lt;User&amp;gt;&lt;span&gt; predicate) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; predicate.test(user);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;         User userObj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         userObj.setUsername(&quot;西门吹雪&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         userObj.setAge(22&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试Consumer&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;         InnerInterface mainInst = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InnerInterface();
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         mainInst.print(userObj,user -&amp;gt;&lt;span&gt; System.out.println(user));
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试Supplier&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; User user1 = mainInst.getUser(() -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             user.setUsername(&quot;叶孤城&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             user.setAge(22&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        System.out.println(user1);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         
&lt;span&gt;73&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将西门吹雪的年龄改为25&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; User user2 = mainInst.transformUser(userObj, (user -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             user.setAge(25&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;        }));
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;        System.out.println(user2);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; 
&lt;span&gt;80&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断User是否是西门吹雪&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; checkUser = mainInst.checkUser(userObj, (user -&amp;gt; user.getUsername().equals(&quot;西门吹雪&quot;&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;        System.out.println(checkUser);
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
User{username='西门吹雪', age=22&lt;span&gt;}
User{username&lt;/span&gt;='叶孤城', age=22&lt;span&gt;}
User{username&lt;/span&gt;='西门吹雪', age=25&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　以上四大核心内置接口是我们日常开发中经常要用到的，同时，它们还有一些变种，如：&lt;/p&gt;
&lt;p&gt;　　BiConsumer，Consumer的增强版，接受两个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; BiConsumer&amp;lt;T, U&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; accept(T t, U u);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　BiFunction类似，Function的增强版，接受两个参数，返回一个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; BiFunction&amp;lt;T, U, R&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    R apply(T t, U u);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;default&lt;/span&gt; &amp;lt;V&amp;gt; BiFunction&amp;lt;T, U, V&amp;gt; andThen(Function&amp;lt;? &lt;span&gt;super&lt;/span&gt; R, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; after) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        Objects.requireNonNull(after);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (T t, U u) -&amp;gt;&lt;span&gt; after.apply(apply(t, u));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其他的类似，这些函数式接口都在java.util.function包下，读者可去这个包下去查询。&lt;/p&gt;

</description>
<pubDate>Mon, 15 Apr 2019 15:32:00 +0000</pubDate>
<dc:creator>无恨之都</dc:creator>
<og:description>Java8是自java5之后最重大的一次更新，它给JAVA语言带来了很多新的特性（包括编译器、类库、工具类、JVM等），其中最重要的升级是它给我们带来了Lambda表达式和Stream API。 1、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhenzhidu/p/lambda.html</dc:identifier>
</item>
<item>
<title>云服务器内，nginx安装部署，Xshell，Xftp安装 - 梦里一米七八</title>
<link>http://www.cnblogs.com/qq946487854/p/10714105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq946487854/p/10714105.html</guid>
<description>&lt;hr/&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;三丰云云服务器，安装nginx&lt;/li&gt;
&lt;li&gt;nginx部署&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;在宝塔面板，添加Nginx安装，一般进来会默认推荐安装几款软件，mysql等，暂时可以后面再装，先把nginx装上去，去感受将前端页面放到网址端口的feeling！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1503301/201904/1503301-20190415232430407-1146395271.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nginx新增配置&lt;br/&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;配置代码域名暂时不用配注意的是root的路径一定要准确&quot;&gt;1. 配置代码（域名暂时不用配，注意的是root的路径一定要准确）&lt;/h3&gt;
&lt;p&gt;如果是能进入nginx，但是404，那就是nginx路径没找到；&lt;br/&gt;如果是502，那就是木有开启nginx&lt;/p&gt;
&lt;pre class=&quot;config&quot;&gt;
&lt;code&gt; server {
     listen       9999;
#   server_name  test.com;
    root  ..\first-test-vue\dist;
    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|js|css)$ {
        add_header Cache-Control no-store;
    } 
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   html;
        } 
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Xshell安装&lt;/li&gt;
&lt;li&gt;Xftp安装&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;需要用到上次收到操作系统短信里的&quot;&gt;1. 需要用到上次收到操作系统短信里的&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;操作系统密码&lt;/li&gt;
&lt;li&gt;号码默认是root，ip是云服务器ip&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;xftp文件传输&quot;&gt;2. Xftp文件传输&lt;/h3&gt;
&lt;p&gt;直接找到本地项目路径，拖动到你想要放的操作系统路径里，然后稍微改动nginx路径。（我改的端口是9999）&lt;/p&gt;
&lt;p&gt;然后，你在外网，搜索ip：9999（ip是你云服务器ip）&lt;br/&gt;就可以看到页面效果了&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;不过我写的确实是好水啊。。。。不喜勿喷，我也是纯当总结的，谢谢大佬们，还有我觉得博客园的markdown好像和作业部落的cmd markdown不是很像，应该是吧！&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:25:00 +0000</pubDate>
<dc:creator>梦里一米七八</dc:creator>
<og:description>云服务器内，nginx安装部署，Xshell，Xftp安装</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qq946487854/p/10714105.html</dc:identifier>
</item>
<item>
<title>详解Java中的final关键字 - Heriam</title>
<link>http://www.cnblogs.com/cciejh/p/final-in-java.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cciejh/p/final-in-java.html</guid>
<description>&lt;p&gt;本文原文地址：&lt;a href=&quot;https://jiang-hao.com/articles/2019/coding-java-final-keyword.html&quot; class=&quot;uri&quot;&gt;https://jiang-hao.com/articles/2019/coding-java-final-keyword.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;final-简介2&quot;&gt;final 简介&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;final&lt;/em&gt;关键字可用于多个场景，且在不同场景具有不同的作用。首先，&lt;em&gt;final&lt;/em&gt;是一个&lt;a href=&quot;https://www.geeksforgeeks.org/access-and-non-access-modifiers-in-java/&quot;&gt;非访问修饰符&lt;/a&gt;，&lt;strong&gt;仅&lt;/strong&gt;适用&lt;strong&gt;于变量，方法或类&lt;/strong&gt;。下面是使用final的不同场景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Heriam/images/master/in-article/final-keyword.png&quot; alt=&quot;java中的final关键字&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这张图可以概括成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当&lt;em&gt;final&lt;/em&gt;修饰&lt;strong&gt;变量&lt;/strong&gt;时，被修饰的变量必须被初始化(赋值)，且后续不能修改其值，实质上是常量；&lt;/li&gt;
&lt;li&gt;当&lt;em&gt;final&lt;/em&gt;修饰&lt;strong&gt;方法&lt;/strong&gt;时，被修饰的方法无法被所在类的子类重写（覆写）；&lt;/li&gt;
&lt;li&gt;当&lt;em&gt;final&lt;/em&gt;修饰&lt;strong&gt;类&lt;/strong&gt;时，被修饰的类不能被继承，并且&lt;em&gt;final&lt;/em&gt;类中的所有成员方法都会被隐式地指定为&lt;em&gt;final&lt;/em&gt;方法，但成员变量则不会变。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;final-修饰变量&quot;&gt;final 修饰变量&lt;/h3&gt;
&lt;p&gt;当使用&lt;em&gt;final&lt;/em&gt;关键字声明类成员变量或局部变量后，其值不能被再次修改；也经常和&lt;em&gt;static&lt;/em&gt;关键字一起，作为&lt;strong&gt;类常量&lt;/strong&gt;使用。很多时候会容易把&lt;em&gt;static&lt;/em&gt;和&lt;em&gt;final&lt;/em&gt;关键字混淆，&lt;u&gt;&lt;em&gt;static&lt;/em&gt;作用于成员变量用来表示只保存一份副本，而&lt;em&gt;final&lt;/em&gt;的作用是用来保证变量不可变&lt;/u&gt;。如果&lt;em&gt;final&lt;/em&gt;变量是引用，这意味着该变量不能重新绑定到引用另一个对象，但是可以更改该引用变量指向的对象的内部状态，即可以从&lt;a href=&quot;https://www.geeksforgeeks.org/final-arrays-in-java/&quot;&gt;&lt;em&gt;final&lt;/em&gt;数组&lt;/a&gt;或&lt;em&gt;final&lt;/em&gt;集合中添加或删除元素。最好用全部大写来表示&lt;em&gt;final&lt;/em&gt;变量，使用下划线来分隔单词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//一个final成员常量
final int THRESHOLD = 5;
//一个空的final成员常量
final int THRESHOLD;
//一个静态final类常量
static final double PI = 3.141592653589793;
//一个空的静态final类常量
static final double PI;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;初始化final变量&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;我们必须初始化一个&lt;em&gt;final&lt;/em&gt;变量，否则编译器将抛出编译时错误。&lt;em&gt;final&lt;/em&gt;变量只能通过&lt;a href=&quot;https://www.geeksforgeeks.org/g-fact-26-the-initializer-block-in-java/&quot;&gt;初始化器&lt;/a&gt;或赋值语句初始化一次。初始化&lt;em&gt;final&lt;/em&gt;变量有三种方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以在声明它时初始化&lt;em&gt;final&lt;/em&gt;变量。这种方法是最常见的。如果在声明时&lt;strong&gt;未&lt;/strong&gt;初始化，则该变量称为&lt;strong&gt;空&lt;em&gt;final&lt;/em&gt;变量&lt;/strong&gt;。下面是初始化空&lt;em&gt;final&lt;/em&gt;变量的两种方法。&lt;/li&gt;
&lt;li&gt;可以在&lt;a href=&quot;https://www.geeksforgeeks.org/instance-initialization-block-iib-java/&quot;&gt;instance-initializer块&lt;/a&gt; 或内部构造函数中&lt;a href=&quot;https://www.geeksforgeeks.org/instance-initialization-block-iib-java/&quot;&gt;初始化&lt;/a&gt;空的&lt;em&gt;final&lt;/em&gt;变量。如果您的类中有多个构造函数，则必须在所有构造函数中初始化它，否则将抛出编译时错误。&lt;/li&gt;
&lt;li&gt;可以在&lt;a href=&quot;https://www.geeksforgeeks.org/g-fact-79/&quot;&gt;静态块&lt;/a&gt;内初始化空的&lt;em&gt;final&lt;/em&gt;静态变量。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里注意有一个很普遍的误区。&lt;u&gt;很多人会认为static修饰的final常量必须在声明时就进行初始化，否则会报错。但其实则不然，我们可以先使用&lt;em&gt;static final&lt;/em&gt;关键字声明一个类常量，然后再在&lt;a href=&quot;https://www.geeksforgeeks.org/g-fact-79/&quot;&gt;静态块&lt;/a&gt;内初始化空的&lt;em&gt;final&lt;/em&gt;静态变量。&lt;/u&gt;让我们通过一个例子看上面初始化&lt;em&gt;final&lt;/em&gt;变量的不同方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Java program to demonstrate different 
// ways of initializing a final variable 
  
class Gfg  
{ 
    // a final variable direct initialize 
    // 直接赋值
    final int THRESHOLD = 5; 
      
    // a blank final variable 
    // 空final变量
    final int CAPACITY; 
      
    // another blank final variable 
    final int  MINIMUM; 
      
    // a final static variable PI direct initialize 
    // 直接赋值的静态final变量
    static final double PI = 3.141592653589793; 
      
    // a  blank final static variable 
    // 空的静态final变量，此处并不会报错，因为在下方的静态代码块内对其进行了初始化
    static final double EULERCONSTANT; 
      
    // instance initializer block for initializing CAPACITY 
    // 用来赋值空final变量的实例初始化块
    { 
        CAPACITY = 25; 
    } 
      
    // static initializer block for initializing EULERCONSTANT
    // 用来赋值空final变量的静态初始化块
    static{ 
        EULERCONSTANT = 2.3; 
    } 
      
    // constructor for initializing MINIMUM 
    // Note that if there are more than one 
    // constructor, you must initialize MINIMUM 
    // in them also 
    // 构造函数内初始化空final变量；注意如果有多个
    // 构造函数时，必须在每个中都初始化该final变量
    public GFG()  
    { 
        MINIMUM = -1; 
    } 
          
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;何时使用&lt;em&gt;final&lt;/em&gt;变量：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;普通变量和&lt;em&gt;final&lt;/em&gt;变量之间的唯一区别是我们可以将值重新赋值给普通变量；但是对于&lt;em&gt;final&lt;/em&gt;变量，一旦赋值，我们就不能改变&lt;em&gt;final&lt;/em&gt;变量的值。因此，&lt;em&gt;final&lt;/em&gt;变量必须仅用于我们希望在整个程序执行期间保持不变的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;final&lt;/em&gt;引用变量：&lt;/strong&gt;&lt;br/&gt;当&lt;em&gt;final&lt;/em&gt;变量是对象的引用时，则此变量称为&lt;em&gt;final&lt;/em&gt;引用变量。例如，&lt;em&gt;final&lt;/em&gt;的&lt;em&gt;StringBuffer&lt;/em&gt;变量：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final StringBuffer sb;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;final&lt;/em&gt;变量无法重新赋值。但是对于&lt;em&gt;final&lt;/em&gt;的引用变量，可以更改该引用变量指向的对象的内部状态。请注意，这不是重新赋值。&lt;em&gt;final的&lt;/em&gt;这个属性称为&lt;em&gt;非传递性&lt;/em&gt;。要了解对象内部状态的含义，请参阅下面的示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Java program to demonstrate  
// reference final variable 
  
class Gfg 
{ 
    public static void main(String[] args)  
    { 
        // a final reference variable sb 
        final StringBuilder sb = new StringBuilder(&quot;Geeks&quot;); 
          
        System.out.println(sb); 
          
        // changing internal state of object 
        // reference by final reference variable sb 
        // 更改final变量sb引用的对象的内部状态
        sb.append(&quot;ForGeeks&quot;); 
          
        System.out.println(sb); 
    }     
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Geeks
GeeksForGeeks&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;非传递&lt;/em&gt;属性也适用于数组，因为在Java中&lt;a href=&quot;https://www.geeksforgeeks.org/arrays-in-java/&quot;&gt;数组也是对象&lt;/a&gt;。带有&lt;em&gt;final&lt;/em&gt;关键字的数组也称为&lt;a href=&quot;https://www.geeksforgeeks.org/final-arrays-in-java/&quot;&gt;&lt;em&gt;final&lt;/em&gt;数组&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意 ：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如上所述，&lt;em&gt;final&lt;/em&gt;变量不能重新赋值，这样做会抛出编译时错误。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   // Java program to demonstrate re-assigning 
   // final variable will throw compile-time error 
   
   class Gfg 
   { 
     static final int CAPACITY = 4; 
   
     public static void main(String args[]) 
     { 
       // re-assigning final variable 
       // will throw compile-time error 
       CAPACITY = 5; 
     } 
   } &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   Compiler Error: cannot assign a value to final variable CAPACITY&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;当在方法/构造函数/块中创建&lt;em&gt;final&lt;/em&gt;变量时，它被称为局部&lt;em&gt;final&lt;/em&gt;变量，并且必须在创建它的位置初始化一次。参见下面的局部&lt;em&gt;final&lt;/em&gt;变量程序：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   // Java program to demonstrate 
   // local final variable 
   
   // The following program compiles and runs fine 
   
   class Gfg 
   { 
    public static void main(String args[]) 
    { 
        // local final variable 
        final int i; 
        i = 20; 
        System.out.println(i); 
    } 
   } &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   20&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;注意C ++ &lt;em&gt;const&lt;/em&gt;变量和Java &lt;em&gt;final&lt;/em&gt;变量之间的区别。声明时，必须为C ++中的const变量赋值。对于Java中的&lt;em&gt;final&lt;/em&gt;变量，正如我们在上面的示例中所看到的那样，可以稍后赋值，但只能赋值一次。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;final&lt;/em&gt;在&lt;a href=&quot;https://www.geeksforgeeks.org/for-each-loop-in-java/&quot;&gt;foreach循环&lt;/a&gt;中：在foreach语句中使用&lt;em&gt;final&lt;/em&gt;声明存储循环元素的变量是合法的。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  // Java program to demonstrate final 
  // with for-each statement 

  class Gfg 
  { 
    public static void main(String[] args) 
    { 
      int arr[] = {1, 2, 3}; 

      // final with for-each statement 
      // legal statement 
      for (final int i : arr) 
        System.out.print(i + &quot; &quot;); 
    }    
  } &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 2 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;由于i变量在循环的每次迭代时超出范围，因此实际上每次迭代都重新声明，允许使用相同的标记（即i）来表示多个变量。&lt;/p&gt;
&lt;h3 id=&quot;final-修饰类&quot;&gt;final 修饰类&lt;/h3&gt;
&lt;p&gt;当使用&lt;em&gt;final&lt;/em&gt;关键字声明一个类时，它被称为&lt;em&gt;final&lt;/em&gt;类。被声明为&lt;em&gt;final&lt;/em&gt;的类不能被扩展（继承）。&lt;em&gt;final&lt;/em&gt;类有两种用途：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个是彻底防止被&lt;a href=&quot;https://www.geeksforgeeks.org/inheritance-in-java/&quot;&gt;继承&lt;/a&gt;，因为&lt;em&gt;final&lt;/em&gt;类不能被扩展。例如，所有&lt;a href=&quot;https://www.geeksforgeeks.org/wrapper-classes-java/&quot;&gt;包装类&lt;/a&gt;如&lt;a href=&quot;https://www.geeksforgeeks.org/java-lang-integer-class-java/&quot;&gt;Integer&lt;/a&gt;，&lt;a href=&quot;https://www.geeksforgeeks.org/java-lang-float-class-in-java/&quot;&gt;Float&lt;/a&gt;等都是&lt;em&gt;final&lt;/em&gt;类。我们无法扩展它们。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;final&lt;/em&gt;类的另一个用途是&lt;a href=&quot;https://www.geeksforgeeks.org/create-immutable-class-java/&quot;&gt;创建一个&lt;/a&gt;类似于&lt;a href=&quot;https://www.geeksforgeeks.org/string-class-in-java/&quot;&gt;String&lt;/a&gt;类的不可变类。只有将一个类定义成为&lt;em&gt;final&lt;/em&gt;类，才能使其不可变。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  final class A
  {
       // methods and fields
  }
  // 下面的这个类B想要扩展类A是非法的
  class B extends A 
  { 
      // COMPILE-ERROR! Can't subclass A
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java支持把class定义成&lt;em&gt;final&lt;/em&gt;，似乎违背了面向对象编程的基本原则，但在另一方面，封闭的类也保证了该类的所有方法都是固定不变的，不会有子类的覆盖方法需要去动态加载。这给编译器做优化时提供了更多的可能，最好的例子是String，它就是&lt;em&gt;final&lt;/em&gt;类，Java编译器就可以把字符串常量（那些包含在双引号中的内容）直接变成String对象，同时对运算符&quot;+&quot;的操作直接优化成新的常量，因为final修饰保证了不会有子类对拼接操作返回不同的值。&lt;br/&gt;对于所有不同的类定义一顶层类(全局或包可见)、嵌套类(内部类或静态嵌套类)都可以用final来修饰。但是一般来说final多用来修饰在被定义成全局(public)的类上，因为对于非全局类，访问修饰符已经将他们限制了它们的也可见性，想要继承这些类已经很困难，就不用再加一层final限制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;final&lt;/em&gt;与匿名内部类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;匿名类(Anonymous Class)虽然说同样不能被继承，但它们并没有被编译器限制成final。另外要提到的是，网上有许多地方都说因为使用内部类，会有两个地方必须需要使用 &lt;em&gt;final&lt;/em&gt; 修饰符：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在内部类的方法使用到方法中定义的局部变量，则该局部变量需要添加 &lt;em&gt;final&lt;/em&gt; 修饰符&lt;/li&gt;
&lt;li&gt;在内部类的方法形参使用到外部传过来的变量，则形参需要添加 &lt;em&gt;final&lt;/em&gt; 修饰符&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;原因大多是说当我们创建匿名内部类的那个方法调用运行完毕之后，因为局部变量的生命周期和方法的生命周期是一样的，当方法弹栈，&lt;strong&gt;这个局部变量就会消亡了，但内部类对象可能还存在。&lt;/strong&gt; 此时就会出现一种情况，就是我们调用这个内部类对象去访问一个不存在的局部变量，就可能会出现空指针异常。而此时需要使用 &lt;em&gt;final&lt;/em&gt; 在类加载的时候进入常量池，即使方法弹栈，常量池的常量还在，也可以继续使用，JVM 会持续维护这个引用在回调方法中的生命周期。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;但是 JDK 1.8 取消了对匿名内部类引用的局部变量 &lt;em&gt;final&lt;/em&gt; 修饰的检查&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对此，&lt;a href=&quot;https://www.jianshu.com/u/7e0d004ed427&quot;&gt;theonlin&lt;/a&gt;专门通过实验做出了总结：其实局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数。外部类中的方法中的变量或参数只是方法的局部变量，这些变量或参数的作用域只在这个方法内部有效，所以方法中被 &lt;em&gt;final&lt;/em&gt;的变量的仅仅作用是表明这个变量将作为内部类构造器参数，&lt;strong&gt;其实&lt;em&gt;final&lt;/em&gt;不加也可以，加了可能还会占用内存空间，影响 GC&lt;/strong&gt;。最后结论就是，需要使用 final 去持续维护这个引用在回调方法中的生命周期这种说法应该是错误的，也没必要。&lt;/p&gt;
&lt;h3 id=&quot;final-修饰方法&quot;&gt;final 修饰方法&lt;/h3&gt;
&lt;p&gt;下面这段话摘自《Java编程思想》第四版第143页：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用&lt;em&gt;final&lt;/em&gt;方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当使用&lt;em&gt;final&lt;/em&gt;关键字声明方法时，它被称为&lt;em&gt;final&lt;/em&gt;方法。&lt;em&gt;final&lt;/em&gt;方法无法被&lt;a href=&quot;https://www.geeksforgeeks.org/overriding-in-java/&quot;&gt;覆盖&lt;/a&gt;（重写）。比如&lt;a href=&quot;https://www.geeksforgeeks.org/object-class-in-java/&quot;&gt;Object类&lt;/a&gt;，它的一些方法就被声明成为了&lt;em&gt;final&lt;/em&gt;。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为&lt;em&gt;final&lt;/em&gt;。以下代码片段说明了用&lt;em&gt;final&lt;/em&gt;关键字修饰方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class A 
{
    // 父类的ml方法被使用了final关键字修饰
    final void m1() 
    {
        System.out.println(&quot;This is a final method.&quot;);
    }
}

class B extends A 
{
    // 此处会报错，子类B尝试重写父类A的被final修饰的ml方法
    @override
    void m1()
    { 
        // COMPILE-ERROR! Can't override.
        System.out.println(&quot;Illegal!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而关于高效，是因为在java早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的调用都转化为内嵌调用（内联）。大概就是，如果是内嵌调用，虚拟机不再执行正常的方法调用（参数压栈，跳转到方法处执行，再调回，处理栈参数，处理返回值），而是直接将方法展开，以方法体中的实际代码替代原来的方法调用。这样减少了方法调用的开销。所以有一些程序员认为：&lt;strong&gt;除非有足够的理由使用多态性，否则应该将所有的方法都用 final 修饰。这样的认识未免有些偏激&lt;/strong&gt;，因为在最近的java设计中，虚拟机（特别是hotspot技术）可以自己去根据具体情况自动优化选择是否进行内联，只不过使用了&lt;em&gt;final&lt;/em&gt;关键字的话可以显示地影响编译器对被修饰的代码进行内联优化。所以请切记，对于Java虚拟机来说编译器在编译期间会自动进行内联优化，这是由编译器决定的，对于开发人员来说，一定要设计好时空复杂度的平衡，不要滥用final。&lt;/p&gt;
&lt;p&gt;注1：类的&lt;em&gt;private&lt;/em&gt;方法会隐式地被指定为&lt;em&gt;final&lt;/em&gt;方法，也就同样无法被重写。可以对private方法添加final修饰符，但并没有添加任何额外意义。&lt;/p&gt;
&lt;p&gt;注2：在java中，你永远不会看到同时使用&lt;a href=&quot;https://www.geeksforgeeks.org/final-keyword-java/&quot;&gt;&lt;em&gt;final&lt;/em&gt;&lt;/a&gt;和&lt;em&gt;abstract&lt;/em&gt;关键字声明的类或方法。对于类，&lt;em&gt;final&lt;/em&gt;用于防止&lt;a href=&quot;https://www.geeksforgeeks.org/inheritance-in-java/&quot;&gt;继承&lt;/a&gt;，而抽象类反而需要依赖于它们的子类来完成实现。在修饰方法时，&lt;em&gt;final&lt;/em&gt;用于防止被&lt;a href=&quot;https://www.geeksforgeeks.org/overriding-in-java/&quot;&gt;覆盖&lt;/a&gt;，而抽象方法反而需要在子类中被重写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有关&lt;em&gt;final&lt;/em&gt;方法和&lt;em&gt;final&lt;/em&gt;类的更多示例和行为&lt;/strong&gt;，请参阅&lt;a href=&quot;https://www.geeksforgeeks.org/using-final-with-inheritance-in-java/&quot;&gt;使用final继承&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;final-优化编码的艺术&quot;&gt;final 优化编码的艺术&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;final&lt;/em&gt;关键字在效率上的作用主要可以总结为以下三点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存：&lt;em&gt;final&lt;/em&gt;配合&lt;em&gt;static&lt;/em&gt;关键字提高了代码性能，JVM和Java应用都会缓存&lt;em&gt;final&lt;/em&gt;变量。&lt;/li&gt;
&lt;li&gt;同步：&lt;em&gt;final&lt;/em&gt;变量或对象是只读的，可以安全的在多线程环境下进行共享，而不需要额外的同步开销。&lt;/li&gt;
&lt;li&gt;内联：使用&lt;em&gt;final&lt;/em&gt;关键字，JVM会&lt;strong&gt;显式地&lt;/strong&gt;主动对方法、变量及类进行内联优化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多关于&lt;em&gt;final&lt;/em&gt;关键字对代码的优化总结以及注意点可以参考IBM的&lt;a href=&quot;https://www.ibm.com/developerworks/library/j-jtp1029/index.html&quot;&gt;《Is that your final answer?》&lt;/a&gt;这篇文章。&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:23:00 +0000</pubDate>
<dc:creator>Heriam</dc:creator>
<og:description>本文原文地址： 'https://jiang hao.com/articles/2019/coding java final keyword.html' [^1] final 简介[^2] final</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cciejh/p/final-in-java.html</dc:identifier>
</item>
<item>
<title>【译】.NET Core 3.0 Preview 3中关于ASP.NET Core的更新内容 - 艾心❤</title>
<link>http://www.cnblogs.com/edison0621/p/10714069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edison0621/p/10714069.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-3/&quot;&gt;.NET Core 3.0 Preview 3已经推出&lt;/a&gt;，它包含了一系列关于ASP.NET Core的新的更新。&lt;/p&gt;
&lt;p&gt;下面是该预览版的更新列表：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Razor组件改进:
&lt;ul&gt;&lt;li&gt;单项目模板 &lt;/li&gt;
&lt;li&gt;新的Razer扩展&lt;/li&gt;
&lt;li&gt;Endpoint路由集成&lt;/li&gt;
&lt;li&gt;预呈现&lt;/li&gt;
&lt;li&gt;Razor类库中的Razor组件&lt;/li&gt;
&lt;li&gt;改进事件处理 &lt;/li&gt;
&lt;li&gt;Forms &amp;amp; validation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;运行时编译&lt;/li&gt;
&lt;li&gt;Worker服务模板&lt;/li&gt;
&lt;li&gt;gRPC模板&lt;/li&gt;
&lt;li&gt;Angular模板已更新为Angular 7&lt;/li&gt;
&lt;li&gt;SPA认证 &lt;/li&gt;
&lt;li&gt;SignalR与Endpoint路由集成&lt;/li&gt;
&lt;li&gt;SignalR Java客户端支持长轮询&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他详细信息和已知问题，请参阅&lt;a href=&quot;https://aka.ms/netcore3releasenotes&quot;&gt;发行说明&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;要在.NET Core 3.0 Preview 3中开始使用ASP.NET Core，&lt;a href=&quot;https://aka.ms/netcore3download&quot;&gt;请安装.NET Core 3.0 Preview 3 SDK&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您使用的是Visual Studio，则还需要&lt;a href=&quot;https://visualstudio.com/preview&quot;&gt;安装Visual Studio 2019的最新预览版&lt;/a&gt;【译者注：目前VS2019正式版已经发布，直接安装正式版即可】。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注意：要在Visual Studio 2019中使用.NET Core 3.0预览版，需要启用选项以使用.NET Core SDK预览版，方法是通过【&lt;em&gt;工具&amp;gt;选项&amp;gt;项目和解决方案&amp;gt; .NET Core&amp;gt;使用.NET Core SDK预览版&lt;/em&gt;】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将现有的ASP.NET Core应用程序升级到.NET Core 3.0 Preview 3，请按照&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30&quot;&gt;ASP.NET Core文档中&lt;/a&gt;的&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/migration/22-to-30&quot;&gt;迁移步骤进行操作&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另请参阅ASP.NET Core 3.0 中的&lt;a href=&quot;https://github.com/aspnet/announcements/issues?utf8=%E2%9C%93&amp;amp;q=is%3Aissue+label%3A3.0.0+label%3A%22Breaking+change%22&quot;&gt;重大更改&lt;/a&gt;的完整列表。&lt;/p&gt;

&lt;p&gt;在前面的预览中，我们介绍了Razor组件，这是一种用ASP.NET核心构建交互式客户端Web UI的新方法。本节将会介绍我们在该预览更新中对Razor组件所做的各种改进。&lt;/p&gt;
&lt;h2&gt;单项目模板&lt;/h2&gt;
&lt;p&gt;Razor组件项目模板现在是单个项目，而不是同一解决方案中的两个项目。所编写的Razor组件位于托管它们的ASP.NET Core应用程序中。同一个ASP.NET Core项目可以包含Razor组件、页面和视图。Razor组件模板与其他ASP.NET Core Web应用程序模板一样，默认情况下也启用了HTTPS。&lt;/p&gt;
&lt;h2&gt;新的Razer扩展&lt;/h2&gt;
&lt;p&gt;Razor组件使用Razor语法编写，但编译方式与Razor页面和视图不同。为了明确哪些Razor文件应该编译为Razor组件，我们引入了一个新的文件扩展名：.razor。在Razor组件模板中，所有组件文件现在都使用.razor扩展名。Razor页面和视图仍然使用.cshtml扩展名。&lt;/p&gt;
&lt;p&gt;只要使用_RazorComponentInclude MSBuild属性将这些文件标识为Razor组件文件，Razor组件仍然可以使用.cshtml文件扩展名来创建。例如，该版本中的Razor组件模板指定Components文件夹下的所有.cshtml文件为Razor组件。&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;_RazorComponentInclude&amp;gt;Components\**\*.cshtml&amp;lt;/_RazorComponentInclude&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意，这个版本中的.razor文件有很多限制。有关已知问题和可用解决方案的列表，请参考发布说明。&lt;/p&gt;
&lt;h2&gt;Endpoint路由集成&lt;/h2&gt;
&lt;p&gt;Razor组件现在已经集成到了ASP.NET Core中新的Endpoint路由系统。要在应用程序中启用Razor组件支持，需要在路由配置中使用MapComponentHub&amp;lt;TComponent&amp;gt;。&lt;/p&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;app.UseRouting(routes =&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    routes.MapRazorPages();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;    routes.MapComponentHub&amp;lt;App&amp;gt;(&lt;span class=&quot;str&quot;&gt;&quot;app&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;p&gt;这会将应用程序配置以接受交互式Razor组件的传入连接，并指定根组件App应该在匹配选择器App的DOM元素中呈现。&lt;/p&gt;
&lt;h2&gt;预呈现&lt;/h2&gt;
&lt;p&gt;默认情况下，Razor组件项目模板执行服务端预渲染。也就是说当用户浏览您的应用程序时，服务器将对您的Razor组件执行初始化渲染，并将结果作为纯静态HTML传递给浏览器。然后，浏览器将通过SignalR重新连接到服务器，并将Razor组件切换为完全交互的模式。这两个阶段的交付是有益的，因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它提高了站点的感知能力，因为用户界面可以更快地出现，而无需等待进行任何WebSocket连接，甚至运行任何客户端脚本。这对连接速度较慢的用户有着更大的影响，如2G/3G手机。&lt;/li&gt;
&lt;li&gt;它可以让搜索引擎很容易的搜索到你的应用程序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于使用更快连接的用户（如内网用户），此功能的影响较小，因为无论如何用户界面都应该立即出现。&lt;/p&gt;
&lt;p&gt;设置预渲染，Razor组件项目模板不会有静态HTML文件。取而代之的是单个Razor页面/Pages/Index.cshtml，使用Html.RenderComponentAsync&amp;lt;TComponent&amp;gt;() HTML帮助器预呈现应用程序内容。该页面还引用components.server.js脚本，在预呈现和下载内容后设置SignalR 连接。由于这是一个Razor页面，像环境标签助手这样的功能就可以工作了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Index.cshtml&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;@page &quot;{*clientPath}&quot;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;!&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;DOCTYPE&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;    ...
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;@(await Html.RenderComponentAsync&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;App&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;())&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;=&quot;_framework/components.server.js&quot;&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;html&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了应用程序加载速度更快之外，还可以在浏览器开发工具中查看下载的HTML源代码，从而可以看到预渲染正在进行。Razor组件在HTML中是完全呈现的。&lt;/p&gt;
&lt;h2&gt;Razor类库中的Razor组件&lt;/h2&gt;
&lt;p&gt;现在可以将Razor组件添加到Razor类库中，并使用Razor组件从ASP.NET核心项目引用它们。&lt;/p&gt;
&lt;p&gt;在Razer类库中创建可重用的Razer组件：&lt;/p&gt;
&lt;p&gt;1、创建Razer组件应用程序&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;dotnet &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; razorcomponents -o RazorComponentsApp1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、创建Razer类库&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;dotnet &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; razorclasslib -o RazorClassLib1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、添加&lt;em&gt;Component1.razor&lt;/em&gt;文件到Razer类库&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Component1.razor&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;h1&amp;gt;Component1&amp;lt;/h1&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;&amp;lt;p&amp;gt;@message&amp;lt;/p&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;@functions {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; message = &lt;span class=&quot;str&quot;&gt;&quot;Hello from a Razor Class Library&quot;&lt;/span&gt;!;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1、使用Razor组件从ASP.NET Core应用程序引用Razor类库&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;dotnet add RazorComponentsApp1 reference RazorClassLib1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Razor组件应用程序中，使用@addTagHelper指令从Razor类库导入所有组件，然后在应用程序中使用component1&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Index.razor&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;@page &lt;span class=&quot;str&quot;&gt;&quot;/&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;@addTagHelper *, RazorClassLib1
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;Welcome to your &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; app.
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;&amp;lt;Component1 /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：在此版本中，Razer类库与Blazor应用程序并不兼容。另外，Razor类库还不支持静态资源。如果要在库中创建可与Blazor和Razor组件应用程序共享的组件，仍然需要使用Blazor类库。这写问题会在未来的更新中解决。&lt;/p&gt;
&lt;h2&gt;改进事件处理&lt;/h2&gt;
&lt;p&gt;新的eventcallback和eventcallback&amp;lt;&amp;gt;类型使得定义组件回调更加简单。例如，考虑以下两个组件：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;MyButton.razor&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;button onclick=&lt;span class=&quot;str&quot;&gt;&quot;@OnClick&quot;&lt;/span&gt;&amp;gt;Click here and see what happens!&amp;lt;/button&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;@functions {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;    [Parameter] EventCallback&amp;lt;UIMouseEventArgs&amp;gt; OnClick { get; set; }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;UsesMyButton.razor&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;div&amp;gt;@text&amp;lt;/div&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;&amp;lt;MyButton OnClick=&lt;span class=&quot;str&quot;&gt;&quot;ShowMessage&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;@function {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; text;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; ShowMessage(UIMouseEventArgs e)
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;        text = &lt;span class=&quot;str&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;onclick回调的类型是EventCallback&amp;lt;UIMouseEventArgs&amp;gt;（取代Action&amp;lt;UIMouseEventArgs&amp;gt;），MyButton直接传递给onclick事件处理程序。编译器处理将委托转换为EventCallback的过程，并将执行其他一些操作，以确保呈现过程具有足够的信息来呈现正确的目标组件。因此，不需要在ShowMessage事件处理程序中显式调用StateHasChanged。编译器处理将委托转换为EventCallback的过程，并将执行其他一些操作，以确保渲染过程具有足够的信息来渲染正确的目标组件。因此，不需要在ShowMessage事件处理程序中显式调用StateHasChanged。&lt;/p&gt;
&lt;p&gt;通过使用EventCallback&amp;lt;&amp;gt;类型的OnClick处理程序可以是异步的，而不需要对MyButton进行任何其他代码的修改。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;UsesMyButton.razor&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;div&amp;gt;@text&amp;lt;/div&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;&amp;lt;MyButton OnClick=&lt;span class=&quot;str&quot;&gt;&quot;ShowMessageAsync&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;@function {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; text;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    async Task ShowMessageAsync(UIMouseEventArgs e)
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;        await Task.Yield(); 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;        text = &lt;span class=&quot;str&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们建议在为事件处理和绑定定义组件参数时使用EventCallback and EventCallback&amp;lt;T&amp;gt;。尽可能使用EventCallback&amp;lt;&amp;gt;，因为它是强类型的并且可以向组件的用户提供更好的反馈。当没有传递给回调函数的值时，也使用EventCallback。&lt;/p&gt;
&lt;h2&gt;Forms&amp;amp;validation&lt;/h2&gt;
&lt;p&gt;此预览版本添加了用于处理表单和验证的内置组件和基础结构。&lt;/p&gt;
&lt;p&gt;使用. net进行客户端web开发的一个好处是能够在客户端和服务器之间共享相同的实现逻辑。验证逻辑是一个很好的逻辑。Razor组件中的新的Forms&amp;amp;validation支持包括使用数据注解处理验证的支持，或者可以插入你喜欢的验证系统。&lt;/p&gt;
&lt;p&gt;例如，以下Person类型使用数据注解定义验证逻辑：&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Person
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    [Required(ErrorMessage = &lt;span class=&quot;str&quot;&gt;&quot;Enter a name&quot;&lt;/span&gt;)]
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;    [StringLength(10, ErrorMessage = &lt;span class=&quot;str&quot;&gt;&quot;That name is too long&quot;&lt;/span&gt;)]
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; Name { get; set; }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;    [Range(0, 200, ErrorMessage = &lt;span class=&quot;str&quot;&gt;&quot;Nobody is that old&quot;&lt;/span&gt;)]
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;int&lt;/span&gt; AgeInYears { get; set; }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;    [Required]
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;    [Range(&lt;span class=&quot;kwrd&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;kwrd&quot;&gt;bool&lt;/span&gt;), &lt;span class=&quot;str&quot;&gt;&quot;true&quot;&lt;/span&gt;, &lt;span class=&quot;str&quot;&gt;&quot;true&quot;&lt;/span&gt;, ErrorMessage = &lt;span class=&quot;str&quot;&gt;&quot;Must accept terms&quot;&lt;/span&gt;)]
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;bool&lt;/span&gt; AcceptsTerms { get; set; }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下是如何基于&lt;code&gt;Person&lt;/code&gt;模型锁创建的验证表单：&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;EditForm Model=&lt;span class=&quot;str&quot;&gt;&quot;@person&quot;&lt;/span&gt; OnValidSubmit=&lt;span class=&quot;str&quot;&gt;&quot;@HandleValidSubmit&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;    &amp;lt;DataAnnotationsValidator /&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    &amp;lt;ValidationSummary /&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;    &amp;lt;p &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;str&quot;&gt;&quot;name&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;        Name: &amp;lt;InputText bind-Value=&lt;span class=&quot;str&quot;&gt;&quot;@person.Name&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;    &amp;lt;/p&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    &amp;lt;p &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;str&quot;&gt;&quot;age&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;        Age (years): &amp;lt;InputNumber bind-Value=&lt;span class=&quot;str&quot;&gt;&quot;@person.AgeInYears&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;    &amp;lt;/p&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;    &amp;lt;p &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;str&quot;&gt;&quot;accepts-terms&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;        Accepts terms: &amp;lt;InputCheckbox bind-Value=&lt;span class=&quot;str&quot;&gt;&quot;@person.AcceptsTerms&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;    &amp;lt;/p&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  14:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  15:  &lt;/span&gt;    &amp;lt;button type=&lt;span class=&quot;str&quot;&gt;&quot;submit&quot;&lt;/span&gt;&amp;gt;Submit&amp;lt;/button&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  16:  &lt;/span&gt;&amp;lt;/EditForm&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  17:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  18:  &lt;/span&gt;@functions {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  19:  &lt;/span&gt;    Person person = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; Person();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  20:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  21:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; HandleValidSubmit()
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  22:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  23:  &lt;/span&gt;        Console.WriteLine(&lt;span class=&quot;str&quot;&gt;&quot;OnValidSubmit&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  24:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  25:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果将此表单添加到应用程序中，并运行它，你将获得一个基本表单，该表单在字段更改和表单提交时自动进行字段输入值的验证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/razor-components-validating-form.png&quot; alt=&quot;Validating form&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里发生了很多事情，让我们把它一个一个地分解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个表单是使用新的EditForm组件定义的。EditForm将EditContext设置为一个级联相关的值，该值用于跟踪关于编辑过程的元数据(例如，已修改的内容、当前验证消息等)。EditForm还为有效和无效提交(OnValidSubmit、OnInvalidSubmit)提供了合适的事件。如果想自己触发验证，也可以直接使用OnSubmit。&lt;/li&gt;
&lt;li&gt;DataAnnotationsValidator组件使用数据注解，以验证支持附加到级联的EditContext。 使用数据注释启用验证支持需要显式调用，但我们正在考虑将其作为默认行为，但随后你可以覆盖它。&lt;/li&gt;
&lt;li&gt;每个表单字段都是使用一组内置的输入组件（InputText, InputNumber, InputCheckbox, InputSelect等）定义的。这些组件提供默认行为，用于在编辑时验证并更改它们的CSS类以反映字段状态。其中一些具有有用的分析逻辑（例如，InputDate和InputNumber将不可解析的值注册为验证错误，这样可以优雅地处理它们）。相关字段还支持目标字段的可空性（例如，int？）。&lt;/li&gt;
&lt;li&gt;ValidationMessage组件显示特定字段的验证消息。&lt;/li&gt;
&lt;li&gt;ValidationSummary组件汇总所有验证消息（类似于验证摘要标记助手）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;内置的输入组件存在一些限制，我们希望在将来的更新中改进这些限制。例如，目前不能在生成输入标记上指定任意属性。将来，我们计划启用组件的所有额外属性。现在，您需要构建自己的组件子类来处理这些情况。&lt;/p&gt;
&lt;h2&gt;运行时验证&lt;/h2&gt;
&lt;p&gt;对运行时编译的支持已从.NET Core 3.0中的ASP.NET核心共享框架中删除，但现在可以通过向应用程序添加包的方式来启用它。&lt;/p&gt;
&lt;p&gt;启用运行时编译：&lt;/p&gt;
&lt;p&gt;添加Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&amp;lt;PackageReference Include=&lt;span class=&quot;str&quot;&gt;&quot;Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation&quot;&lt;/span&gt; Version=&lt;span class=&quot;str&quot;&gt;&quot;3.0.0-preview3-19153-02&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Startup.ConfigureServices添加对AddRazorRuntimeCompilation的调用&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;services.AddMvc().AddRazorRuntimeCompilation();
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Worker服务模板&lt;/h2&gt;
&lt;p&gt;在preview3中，我们引入了一个名为“Worker Service”的新模板。此模板被设计为运行长时间运行的后台进程的起点，就像您可能作为Windows服务或Linux守护进程运行一样。例如，从消息队列生成/消费消息，或者监视要处理的文件。它旨在支持ASP.NET Core的生产力功能，如日志记录，DI，配置等，而不承载任何Web依赖项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/worker-service.png&quot; alt=&quot;å·¥äººæœåŠ¡&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在接下来的几天里，我们将发布一些博客文章，提供更多关于使用Worker模板入门的练习。我们将有一些专门官微Windows/SystemD服务发布、在ACI/AKS上运行以及作为WebJob运行的文章。&lt;/p&gt;
&lt;h2&gt;提醒&lt;/h2&gt;
&lt;p&gt;虽然其目的是使工作模板默认情况下不依赖于web技术，但在preview3中它仍然使用web SDK，并在您选择“ASP.NET Core WebApplication”之后显示出来。&lt;/p&gt;
&lt;h2&gt;Angular模板更新到了Angular 7&lt;/h2&gt;
&lt;p&gt;Angular模板更新到了Angular 7。在 .NET Core 3.0 发布稳定版本之前，我们预计会更新到Angular 8。&lt;/p&gt;
&lt;h2&gt;SPA身份认证&lt;/h2&gt;
&lt;p&gt;这个版本，在Angular和React模板中引入了对身份验证的支持。在本节中，我们将展示如何创建一个新的Angular或React模板，该模板允许我们对用户进行身份验证并访问受保护的API资源。&lt;/p&gt;
&lt;p&gt;我们对用户身份验证和授权的支持是由IdentityServer在后台提供的，我们构建了一些扩展来简化我们特定场景的配置体验。&lt;/p&gt;
&lt;p&gt;注意：在本文中，我们展示了对Angular的身份验证支持，但在React模板中提供了相同的功能。&lt;/p&gt;
&lt;h2&gt;创建新的Angular应用程序&lt;/h2&gt;
&lt;p&gt;要创建一一个新的支持身份验证的Angular应用程序，我们需要调用以下命令:&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;dotnet &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; angular -au Individual
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个命令创建一个新的ASP.NET Core应用程序和托管的客户端Angular应用程序。ASP.NET Core应用程序包括已配置的Identity Server实例，可是让Angular应用程序很方面的对用户进行身份验证，并针对ASP.NET Core应用程序中的受保护资源发送HTTP请求。&lt;/p&gt;
&lt;p&gt;Angular模块所构建的身份验证和授权支持，可以导入到您的应用程序中，并提供一套组件和服务来增强主应用程序模块的功能。&lt;/p&gt;
&lt;h2&gt;运行该应用程序&lt;/h2&gt;
&lt;p&gt;要运行应用程序，只需执行以下命令，然后用浏览器打开控制台上显示的URL：&lt;/p&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;dotnet run
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;Hosting environment: Development
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;Content root path: C:\angularapp
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;Now listening on: https:&lt;span class=&quot;rem&quot;&gt;//localhost:5001&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;Now listening on: http:&lt;span class=&quot;rem&quot;&gt;//localhost:5000&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;Application started. Press Ctrl+C to shut down.
&lt;/pre&gt;
&lt;p class=&quot;csharpcode&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;csharpcode&quot;&gt;&lt;span&gt;&lt;strong&gt;运行结果如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/spa-auth-index.png&quot; alt=&quot;SPAæŒ‡æ•°&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们打开应用程序时，我们会看到常用的Home、Counter和Fetch数据菜单选项以及两个新选项:Register和Login。如果单击Register，我们将被发送到默认的认证界面(在运行迁移和更新数据库之后)，在那里我们可以注册为新用户。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/spa-auth-register.png&quot; alt=&quot;SPA register&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注册为新用户后，我们将被重定向回应用程序，在那里我们可以看到我们成功地通过了身份验证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/spa-logged-in.png&quot; alt=&quot;SPA logged in&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;调用经过身份验证的API&lt;/h2&gt;
&lt;p&gt;如果我们点击获取数据，我们可以看到天气预报数据列表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/spa-fetch-data.png&quot; alt=&quot;SPA fetch data&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;保护现有的API&lt;/h2&gt;
&lt;p&gt;要保护服务器上的API，只需要在要保护的控制器或操作上使用[Authorize]属性。&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;[Authorize]
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;[Route(&lt;span class=&quot;str&quot;&gt;&quot;api/[controller]&quot;&lt;/span&gt;)]
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; SampleDataController : Controller
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;...
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;客户端路径认证&lt;/h2&gt;
&lt;p&gt;为了在Angular应用程序访问页面时，要求对用户进行身份验证，我们将[AuthorizeGuard]应用到正在配置的路由上。&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;import { ApiAuthorizationModule } from &lt;span class=&quot;str&quot;&gt;'src/api-authorization/api-authorization.module'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;import { AuthorizeGuard } from &lt;span class=&quot;str&quot;&gt;'src/api-authorization/authorize.guard'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;import { AuthorizeInterceptor } from &lt;span class=&quot;str&quot;&gt;'src/api-authorization/authorize.interceptor'&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;@NgModule({
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;  declarations: [
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;    AppComponent,
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    NavMenuComponent,
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;    HomeComponent,
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;    CounterComponent,
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;    FetchDataComponent
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;  ],
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;  imports: [
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  14:  &lt;/span&gt;    BrowserModule.withServerTransition({ appId: &lt;span class=&quot;str&quot;&gt;'ng-cli-universal'&lt;/span&gt; }),
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  15:  &lt;/span&gt;    HttpClientModule,
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  16:  &lt;/span&gt;    FormsModule,
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  17:  &lt;/span&gt;    ApiAuthorizationModule,
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  18:  &lt;/span&gt;    RouterModule.forRoot([
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  19:  &lt;/span&gt;      { path: &lt;span class=&quot;str&quot;&gt;''&lt;/span&gt;, component: HomeComponent, pathMatch: &lt;span class=&quot;str&quot;&gt;'full'&lt;/span&gt; },
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  20:  &lt;/span&gt;      { path: &lt;span class=&quot;str&quot;&gt;'counter'&lt;/span&gt;, component: CounterComponent },
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  21:  &lt;/span&gt;      { path: &lt;span class=&quot;str&quot;&gt;'fetch-data'&lt;/span&gt;, component: FetchDataComponent, canActivate: [AuthorizeGuard] },
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  22:  &lt;/span&gt;    ])
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  23:  &lt;/span&gt;  ],
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  24:  &lt;/span&gt;  providers: [
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  25:  &lt;/span&gt;    { provide: HTTP_INTERCEPTORS, useClass: AuthorizeInterceptor, multi: &lt;span class=&quot;kwrd&quot;&gt;true&lt;/span&gt; }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  26:  &lt;/span&gt;  ],
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  27:  &lt;/span&gt;  bootstrap: [AppComponent]
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  28:  &lt;/span&gt;})
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  29:  &lt;/span&gt;export &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; AppModule { }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;带有SignalR Hubs的Endpoint路由&lt;/h2&gt;
&lt;p&gt;在preview3中，我们将SignalR hubs连接到最近发布的新端点路由特性中。SignalR hub连线之前已经明确完成:&lt;/p&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;app.UseSignalR(routes =&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    routes.MapHub&amp;lt;ChatHub&amp;gt;(&lt;span class=&quot;str&quot;&gt;&quot;hubs/chat&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;});
&lt;/pre&gt;
&lt;p&gt;这意味着开发人员需要在启动期间将控制器、Razor页面和hubs连接到不同的位置，从而产生一系列几乎相同的路由片段:&lt;/p&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;app.UseSignalR(routes =&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    routes.MapHub&amp;lt;ChatHub&amp;gt;(&lt;span class=&quot;str&quot;&gt;&quot;hubs/chat&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;});
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;app.UseRouting(routes =&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    routes.MapRazorPages();
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;});
&lt;/pre&gt;
&lt;p&gt;现在，SignalR hub也可以通过endpoint路由进行路由分发，因此您可以在ASP.NET Core中一站式地路由几乎所有内容。&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;app.UseRouting(routes =&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    routes.MapRazorPages();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;    routes.MapHub&amp;lt;ChatHub&amp;gt;(&lt;span class=&quot;str&quot;&gt;&quot;hubs/chat&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;});
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Java SignalR客户端的长轮询&lt;/h2&gt;
&lt;p&gt;我们向Java客户端添加了长轮询支持，这使它能够在不支持WebSockets的环境中建立连接。这也使您能够在客户端应用程序中专门选择长轮询传输。&lt;/p&gt;
&lt;h2&gt;gRPC 模板&lt;/h2&gt;
&lt;p&gt;这个预览版引入了一个用ASP.NET Core构建的gRPC服务的新模板。NET Core使用一个新的gRPC框架，我们正在与谷歌合作构建。&lt;/p&gt;
&lt;p&gt;gRPC是一个流行的RPC(远程过程调用)框架，它为API开发提供了一种固定的契约优先方法。它使用HTTP/2进行传输，协议缓冲区作为接口描述语言，并提供诸如身份验证、双向流和流控制、取消和超时等功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/grpc-service.png&quot; alt=&quot;gRPC template&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些模板创建了两个项目:一个是托管于ASP. NET Core中的gRPC服务，以及一个用于测试它的控制台应用程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://devblogs.microsoft.com/aspnet/wp-content/uploads/sites/16/2019/03/grpc-templatepng.png&quot; alt=&quot;gRPC solution&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是第一个为ASP.NET Core公开发布的gRPC预览，并没有实现gRPC的所有功能，但是我们正在努力使ASP.NET Core提供所提供得最佳的gRPC体验成为可能。请尝试一下，并在GitHub上的&lt;a href=&quot;https://github.com/grpc/grpc-dotnet/issues&quot;&gt;grpc/grpc-dotnet&lt;/a&gt;上给我们反馈。&lt;/p&gt;
&lt;p&gt;未来将会有更详细地讨论ASP.NET Core使用gRPC的博客文章，请继续关注。&lt;/p&gt;
&lt;h2&gt;反馈&lt;/h2&gt;
&lt;p&gt;我们希望您喜欢这个预览版的ASP.NET Core中的新功能！请通过在Github上提交问题让我们知道你的想法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;原文地址：&lt;a href=&quot;https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-core-3-0-preview-3/&quot;&gt;https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-core-3-0-preview-3/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:23:00 +0000</pubDate>
<dc:creator>艾心❤</dc:creator>
<og:description>.NET Core 3.0 Preview 3已经推出，它包含了一系列关于ASP.NET Core的新的更新。 下面是该预览版的更新列表： Razor组件改进: 单项目模板 新的Razer扩展 End</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edison0621/p/10714069.html</dc:identifier>
</item>
<item>
<title>[Python]可变类型，默认参数与学弟的困惑 - Magic激流</title>
<link>http://www.cnblogs.com/magicxyx/p/10714072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/magicxyx/p/10714072.html</guid>
<description>&lt;p&gt;    十天前一个夜阑人静、月明星稀的夜晚，我和我的朋友们正在学校东门的小餐馆里吃着方圆3里内最美味的牛蛙，唱着最好听的歌儿，畅聊人生的意义。突然，我的手机一震，气氛瞬间就安静下来，看着牛蛙碗里三双贪婪的筷子，我犹豫了：不——我的肉…但是本着不让人久等的原则，我不舍地放下了筷子。点亮屏幕，我的眉头不禁紧锁，事情好像并不简单…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231907398-1894288055.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    什么，还上升到了去医院的程度？现在的年轻人怎么了，怎么那么不注意安全，嗨，真是一届不如一届了，不过也好，没受伤就好…正当我沉浸在我自己的瞎想时，一张图片紧接着医院那条发了过来…嗯？好熟悉的图！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231907759-479849751.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    嗯…，这不是PyCharm嘛…原来是Python…啊不，我的牛蛙…当我还在想这会是个啥问题时，学弟发出了追问三连：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231908038-162091257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    我是谁？我从哪里来？我的牛蛙怎么没了？&lt;/p&gt;
&lt;p&gt;    右手无意思地点开了那张承载着学弟追问三连的图，我倒要看看，什么问题耽误了我吃肉的最佳时机。&lt;/p&gt;
&lt;p&gt;    忽略学弟那莫名其妙的文件命名，以及那三位数的行数，学弟的问题由六行代码引出：&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;def&lt;/strong&gt;&lt;span&gt; li_si(a,ls=[]):  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    ls.append(a)  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; ls  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;span&gt;(li_si(7))  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;span&gt;(li_si(15))  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;span&gt;(li_si(45,[1,5,7]))  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;span&gt;(li_si(78))  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个函数，两个参数，其中一个是默认的空列表，函数里，列表对第一个参数执行append操作，返回列表。&lt;/p&gt;
&lt;p&gt;四个print()，每个print()的参数是一个函数调用，第一二四个函数调用只有一个参数，第二个参数使用的默认值。&lt;/p&gt;
&lt;p&gt;这会有啥问题？结果是显而易见的嘛。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231908229-1635706225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看来学弟进度有点慢啊。这么基础的知识，怎么会扯上这么多，什么&quot;局部变量&quot;，什么&quot;全局变量&quot;，还有&quot;参数&quot;之类，引得我嘴角上扬，感觉空气中充满了快活的空气。&lt;/p&gt;
&lt;p&gt;我夹起了一块牛蛙肉，真香。&lt;/p&gt;
&lt;p&gt;瞄了一眼程序的输出结果，瞳孔瞬间放大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231908514-288225711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;          不好，有诈！我仿佛听到一声惊雷，右手一抖，我的牛蛙掉到了大白菜汤里，啊，牛蛙，你还是想回家啊。&lt;/p&gt;
&lt;p&gt;          哈哈，顾不得牛蛙了，看来学弟提了一个好问题，C语言里那一套规则似乎不起作用了。&lt;/p&gt;
&lt;p&gt;          放下筷子，虔诚的拿起了可以打开未知世界大门的手机，思绪进入计算机世界，这几行代码在执行时，到底发生了什么。&lt;/p&gt;

&lt;p&gt;    当编译器遇到一个函数调用时，它产生代码传递参数并调用函数。C语言里所有的参数均以&quot;传值调用&quot;方式传递，而对于数组参数，传递的则是常量指针(数组)的拷贝。每次函数调用时，被调用的函数都有自己独有的栈空间，里面存储了函数的参数、局部变量等信息，函数返回后，栈空间被释放。&lt;/p&gt;
&lt;p&gt;    而Python的解释器是用C写的，Python里的list底层就是C语言的可变数组，就是一个指针。&lt;/p&gt;
&lt;p&gt;    基于这种认知，我设想的运行结果应该是，第一二四个函数使用的默认参数list，每次调用时，默认参数都回有一个值，这个值是不确定的(后面会提到，在Python里，可变类型竟然还真是确定的)，所以每次调用时默认参数都(应该)指向空的数组，结果应该就是返回只有a一个元素的列表。&lt;/p&gt;
&lt;p&gt;    但是现在运行结果显示，这三次函数调用时似乎指向了同一个列表，这就奇怪了。&lt;/p&gt;

&lt;p&gt;    本身应该是局部变量的参数，运行时却有了全局变量的效果(我终于还是提到了学弟问的那几个词…)，看着代码，我有了这样几个猜测…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231908789-62724600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;猜想1：&lt;/strong&gt; 学弟这几行代码所在行数为106-112，有没有可能在之前的代码中，ls已经被定义过了，所以在后面的代码中，全局的ls覆盖了局部的ls，造成了这种参数全局的效果。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;猜想2：&lt;/strong&gt; 现在我也好奇当时我为嘛会想到这个…这解释器怎么可能会跨行优化这种…可能是被牛蛙冲昏了头脑。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;猜想3：&lt;/strong&gt; 这个我做过实验，对同一个函数多次调用，每次函数局部变量的地址都相同。所以我怀疑，默认参数所在内存区域的值，一直没被修改，所以每次都一样。不过这样就有了一个悖论，第三次函数调用没有使用默认的参数，内存区域的值理应被修改，但是第四次调用时又回到了前两种情况。&lt;/p&gt;

&lt;p&gt;    回到学校后，终于有机会能实际跑跑这奇怪的代码了，毕竟脑子不能编译、解释代码，还是要上机。&lt;/p&gt;
&lt;p&gt;    首先，直接跑这7行代码，看看结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231909105-525244822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    嗯，和学弟的结果一样，可以排除含有全局变量的情况1了。&lt;/p&gt;
&lt;p&gt;    看看每次函数调用时默认参数的值与地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231909400-566365870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    这结果部分地验证了猜想3，每次使用默认参数时都指向了同一个地址。&lt;/p&gt;
&lt;p&gt;换一下，默认参数改为一个数字，这不会还指同一块吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231909848-1945319331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    嗯…还指向同一块，难不成这个默认参数的值放常量池了，怎么老是指一个地儿…啊，对象，突然想起一句话，&quot;Python里万物皆为对象&quot;，这么想来，每一个数字都有自己单独的地址了。嗯，实验一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231910159-168305863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    果然，都是对象。面向对象的特性爬出了书本，以这样一种方式在我的面前刷了一波存在感。&lt;/p&gt;
&lt;p&gt;    因此，默认的参数ls，指向的也是同一个列表对象。而想要该变量指向新的列表的话，就得重新赋值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201904/1219242-20190415231910432-1798449804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    重新赋值后，就得到了预期的结果。&lt;/p&gt;

&lt;p&gt;    Python的内建标准类型有一种分类标准是分为可变类型与不可变类型：&lt;/p&gt;
&lt;p&gt;    变量保存的实际都是对象的引用，所以在给一个不可变类型(比如int)的变量a赋新值的时候，实际上是在内存中新建了一个对象，并讲a指向这个对象，然后将原对象的引用计数-1。&lt;/p&gt;
&lt;p&gt;    所以当函数参数是默认列表时，它始终指向同一个对象，除非重新赋值，否则它并不会重新创建一个新列表。也就是说，多次调用函数执行append操作，实际上是对同一个对象进行操作。&lt;/p&gt;


&lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/Simon-xm/p/4299655.html?tdsourcetag=s_pctim_aiomsg&quot;&gt;Python——可变类型与不可变类型（即为什么函数默认参数要用元组而非列表）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    &lt;a href=&quot;http://baijiahao.baidu.com/s?id=1602330535408996217&amp;amp;wfr=spider&amp;amp;for=pc&amp;amp;tdsourcetag=s_pctim_aiomsg&amp;amp;qq-pf-to=pcqq.c2c&quot;&gt;python之函数默认参数及注意点&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:19:00 +0000</pubDate>
<dc:creator>Magic激流</dc:creator>
<og:description>一、学弟的困惑 十天前一个夜阑人静、月明星稀的夜晚，我和我的朋友们正在学校东门的小餐馆里吃着方圆3里内最美味的牛蛙，唱着最好听的歌儿，畅聊人生的意义。突然，我的手机一震，气氛瞬间就安静下来，看着牛蛙碗</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/magicxyx/p/10714072.html</dc:identifier>
</item>
<item>
<title>给KVM添加新的磁盘 - Repetition_Maximum</title>
<link>http://www.cnblogs.com/meizy/p/10714073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/meizy/p/10714073.html</guid>
<description>&lt;h2&gt;两种方案&lt;/h2&gt;
&lt;h3&gt;1 添加虚拟磁盘文件&lt;/h3&gt;
&lt;h3&gt;2 添加物理磁盘&lt;/h3&gt;
&lt;h2&gt;硬件配置：&lt;/h2&gt;
&lt;p&gt;物理主机（宿主机）：foundation&lt;/p&gt;
&lt;p&gt;物理主机磁盘情况：&lt;/p&gt;
&lt;p&gt;我们有三块物理磁盘，sda、sdb和sdc（这里都是SATA盘）。在给KVM添加物理硬盘前我们需要提前给物理硬盘分区。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1599050/201904/1599050-20190415230230437-731970923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;KVM虚拟机：server&lt;/p&gt;
&lt;p&gt;当前KVM虚拟机磁盘情况&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1599050/201904/1599050-20190415230301642-784484884.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;需求：&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1 /var/lib/libvirt/images/目录是我们KVM磁盘镜像集中管理的位置，我们需要在/var/lib/libvirt/images/下给server虚拟机创建名为server-vdc.qcow2的磁盘文件，大小为10G，作为server的sdc磁盘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 将物理主机foundation的物理磁盘/dev/sdb作为server的/dev/sda磁盘。如下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1599050/201904/1599050-20190415230420022-762180309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1 添加虚拟磁盘文件的方式给KVM虚拟机添加磁盘&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;使用qemu-img create -f qcow2 /var/lib/libvirt/images/server-vdc.qcow2 10G创建磁盘文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此处的虚拟磁盘文件位置在/var/lib/libvirt/images/下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1599050/201904/1599050-20190415230539927-256139470.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后我们使用virsh来加载磁盘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&amp;lt;disk type='file' device='disk'&amp;gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &amp;lt;driver name='qemu' type='qcow2' cache='none'/&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &amp;lt;source file='/var/lib/libvirt/images/server-vdc.qcow2'/&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &amp;lt;target dev='vdc' bus='virtio'/&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &amp;lt;address type='pci' domain='0x0000' bus='0x00' slot='0x08' function='0x0'/&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &amp;lt;/disk&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1599050/201904/1599050-20190415230631507-1904623901.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;然后保存并退出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1599050/201904/1599050-20190415231022537-831297371.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;2 添加物理磁盘到KVM虚拟机&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;直接使用virsh工具来添加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &amp;lt;disk type='block' device='disk'&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &amp;lt;driver name='qemu' type='raw' cache='none' io='native'/&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &amp;lt;source dev='/dev/sdb1'/&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &amp;lt;target dev='sda' bus='sata'/&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &amp;lt;address type='drive' controller='0' bus='0' target='0' unit='0'/&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &amp;lt;/disk&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1599050/201904/1599050-20190415231112788-27397588.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后保存并退出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1599050/201904/1599050-20190415231157007-1184885586.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;验证&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;重启虚拟机验证是否添加成功&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;列出server中的磁盘，我们能够明显看到多出了下面几个磁盘设备，暂时还没有分区。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1599050/201904/1599050-20190415231255567-473845308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;贴一张server没有添加磁盘前的图好作对比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1599050/201904/1599050-20190415231320717-1676250507.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;我们试着分别给/dev/sda和/dev/vdc磁盘设备创建分区&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;可以顺利创建分区，如下两图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给/dev/sda创建大小为10G的主分区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1599050/201904/1599050-20190415231405397-1235472905.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;给/dev/vdc创建大小为10G的主分区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1599050/201904/1599050-20190415231418077-1410187156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;成功！&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;创建分区后我们再列出磁盘，可以看到如下的结果。到此我们给KVM成功添加了磁盘。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1599050/201904/1599050-20190415231625121-1400945858.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;以上为个人的理解，如果有描述不当的地方还请大家指出，欢迎大家一起学习交流。&lt;/p&gt;

</description>
<pubDate>Mon, 15 Apr 2019 15:19:00 +0000</pubDate>
<dc:creator>Repetition_Maximum</dc:creator>
<og:description>给KVM添加新的磁盘 两种方案 1 添加虚拟磁盘文件 2 添加物理磁盘 硬件配置： 物理主机（宿主机）：foundation 物理主机磁盘情况： 我们有三块物理磁盘，sda、sdb和sdc（这里都是S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/meizy/p/10714073.html</dc:identifier>
</item>
<item>
<title>解决方案：如何防止数据重复插入？ - www.bysocket.com</title>
<link>http://www.cnblogs.com/Alandre/p/10714048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Alandre/p/10714048.html</guid>
<description>&lt;p&gt;摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为啥要解决数据重复插入？&lt;/li&gt;
&lt;li&gt;解决方案实战&lt;/li&gt;
&lt;li&gt;可落地小总结&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题起源，微信小程序抽风 wx.request() 重复请求服务器提交数据。后端服务也很简单，伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;SignLogService {
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;saveSignLog&lt;span class=&quot;hljs-params&quot;&gt;(SignLogDO log) {
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现数据库会存在重复数据行，提交时间一模一样。但业务需求是不能有多余的 log 出现，这明显是个问题。&lt;/p&gt;
&lt;p&gt;问题是，重复请求导致的数据重复插入。这问题造成的后果很明显：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据冗余，可能不单单多一条&lt;/li&gt;
&lt;li&gt;有些业务需求不能有多余数据，造成服务问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;问题如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2019/04/1-1.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决方式：如何将 同请求 A，不执行插入，而是读取前一个请求插入的数据并返回。解决后流程应该如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2019/04/2-1.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.单库单表解决方案&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;唯一索引 + 唯一字段&lt;/li&gt;
&lt;li&gt;幂等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面说的那种业务场景：sign_log 表会有 user_id、sign_id、sign_time 等。那么每次签到，每个人每天只有一条签到记录。&lt;/p&gt;
&lt;p&gt;数据库层采取唯一索引的形式，保证数据记录唯一性。即 UNIQUE 约束，UNIQUE 约束唯一标识数据库表中的每条记录。另外，user_id,sign_id,sign_time 三个组合适唯一字段。创表的伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;CREATE TABLE &lt;span class=&quot;hljs-title&quot;&gt;sign_log
&lt;span class=&quot;hljs-params&quot;&gt;(
id &lt;span class=&quot;hljs-keyword&quot;&gt;int NOT NULL,
user_id &lt;span class=&quot;hljs-keyword&quot;&gt;int NOT NULL,
sign_id &lt;span class=&quot;hljs-keyword&quot;&gt;int,
sign_time &lt;span class=&quot;hljs-keyword&quot;&gt;int,
CONSTRAINT unique_sign_log UNIQUE (user_id,sign_id,sign_time)
)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重点是 &lt;code&gt;CONSTRAINT unique_sign_log UNIQUE (user_id,sign_id,sign_time)&lt;/code&gt;。有个小问题，数据量大的时候，每条记录都会有对应的唯一索引，比较耗资源。那么这样就行了吗？&lt;/p&gt;
&lt;p&gt;答案是不行，服务不够健壮。第一个请求插入成功，第二个请求直接报错，Java 服务会抛出 &lt;code&gt;DuplicateKeyException&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;简单的幂等写法操作即可，伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;SignLogService {
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public SingLogDO &lt;span class=&quot;hljs-title&quot;&gt;saveSignLog&lt;span class=&quot;hljs-params&quot;&gt;(SignLogDO log) {
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;的确，流量不是很大，也不算很高并发。重复写问题，这样处理即可。那大流量、高并发场景咋搞&lt;/p&gt;
&lt;h2&gt;2.分库分表解决方案&lt;/h2&gt;
&lt;p&gt;流量大了后，单库单表会演变成分库分表。那么基于单表的唯一索引形式，在碰到分表就无法保证呢，插入的地方可能是两个分表 A1 和 A2。&lt;/p&gt;
&lt;p&gt;解决思路：将数据的唯一性条件放到其他存储，并进行锁控制&lt;/p&gt;
&lt;p&gt;还是上面的例子，每天，每次签到，每个人只有一条签到记录。那么使用分布式锁 Redis 的解决方案。大致伪代码如下：&lt;/p&gt;
&lt;h3&gt;a.加锁&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;/&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;lockKey 最简单的是 user_id + sign_id + sign_time&lt;/li&gt;
&lt;li&gt;expireTime 设置为一天&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;b.解锁&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;/&gt;
&lt;/pre&gt;
&lt;h3&gt;c.幂等代码加强&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;SignLogService {
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public SingLogDO &lt;span class=&quot;hljs-title&quot;&gt;saveSignLog&lt;span class=&quot;hljs-params&quot;&gt;(SignLogDO log) {

        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方案还是不是很成熟，大家参考下即可。&lt;/p&gt;

&lt;p&gt;解决方案实战中，了解具体术。归纳如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;幂等：保证多次同意请求后结果一致&lt;/li&gt;
&lt;li&gt;并发控制：单表唯一索引、分布式多表分布式锁&lt;/li&gt;
&lt;li&gt;降级兜底方案：分布式锁锁失效 – 考虑乐观锁兜底&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;重复插入方案： http://www.bysocket.com/archives/2266&lt;/li&gt;
&lt;li&gt;《阿里巴巴 Java 开发手册》&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;以下专题教程也许您会有兴趣&lt;/h2&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2017/01/qrcode_for_gh_cd421e7eb7d6_430.jpg&quot; alt=&quot;&quot; width=&quot;224&quot; height=&quot;224&quot;/&gt; &lt;br/&gt;（关注微信公众号，领取 Java 精选干货学习资料）&lt;/div&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:13:00 +0000</pubDate>
<dc:creator>www.bysocket.com</dc:creator>
<og:description>摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！ 目录 一、为啥要解决数据重复插入？ 问题起源，微信小程序抽风</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Alandre/p/10714048.html</dc:identifier>
</item>
<item>
<title>iOS面试题：你一般是如何优化你的APP的? - G_猿员</title>
<link>http://www.cnblogs.com/zhuzi12345/p/10714046.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuzi12345/p/10714046.html</guid>
<description>&lt;p&gt;一、首页启动速度&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动过程中做的事情越少越好（尽可能将多个接口合并）&lt;/li&gt;
&lt;li&gt;不在UI线程上作耗时的操作（数据的处理在子线程进行，处理完通知主线程刷新）&lt;/li&gt;
&lt;li&gt;在合适的时机开始后台任务（例如在用户指引节目就可以开始准备加载的数据）&lt;/li&gt;
&lt;li&gt;尽量减小包的大小&lt;/li&gt;
&lt;li&gt;优化方法：
&lt;ul&gt;&lt;li&gt;量化启动时间&lt;/li&gt;
&lt;li&gt;启动速度模块化&lt;/li&gt;
&lt;li&gt;辅助工具（友盟，听云，Flurry）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二、页面浏览速度&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;json的处理（iOS 自带的NSJSONSerialization，Jsonkit，SBJson）&lt;/li&gt;
&lt;li&gt;数据的分页（后端数据多的话，就要分页返回，例如网易新闻，或者 微博记录）&lt;/li&gt;
&lt;li&gt;数据压缩（大数据也可以压缩返回，减少流量，加快反应速度）&lt;/li&gt;
&lt;li&gt;内容缓存（例如网易新闻的最新新闻列表都是要缓存到本地，从本地加载，可以缓存到内存，或者数据库，根据情况而定）&lt;/li&gt;
&lt;li&gt;延时加载tab（比如app有5个tab，可以先加载第一个要显示的tab，其他的在显示时候加载，按需加载）&lt;/li&gt;
&lt;li&gt;算法的优化（核心算法的优化，例如有些app 有个 联系人姓名用汉语拼音的首字母排序）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三、操作流畅度优化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Tableview 优化（tableview cell的加载优化）&lt;/li&gt;
&lt;li&gt;ViewController加载优化（不同view之间的跳转，可以提前准备好数据）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;四、数据库的优化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据库设计上面的重构&lt;/li&gt;
&lt;li&gt;查询语句的优化&lt;/li&gt;
&lt;li&gt;分库分表（数据太多的时候，可以分不同的表或者库）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;五、服务器端和客户端的交互优化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端尽量减少请求&lt;/li&gt;
&lt;li&gt;服务端尽量做多的逻辑处理&lt;/li&gt;
&lt;li&gt;服务器端和客户端采取推拉结合的方式（可以利用一些同步机制）&lt;/li&gt;
&lt;li&gt;通信协议的优化。（减少报文的大小）&lt;/li&gt;
&lt;li&gt;电量使用优化（尽量不要使用后台运行）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;六、非技术性能优化&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;产品设计的逻辑性（产品的设计一定要符合逻辑，或者逻辑尽量简单，否则会让程序员抓狂，有时候用了好大力气，才可以完成一个小小的逻辑设计问题）&lt;/li&gt;
&lt;li&gt;界面交互的规范（每个模块的界面的交互尽量统一，符合操作习惯）&lt;/li&gt;
&lt;li&gt;代码规范（这个可以隐形带来app 性能的提高，比如 用if else 还是switch ，或者是用！还是 ＝＝）&lt;/li&gt;
&lt;li&gt;code review（坚持code Review 持续重构代码。减少代码的逻辑复杂度）&lt;/li&gt;
&lt;li&gt;日常交流（经常分享一些代码，或者逻辑处理中的坑）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;***&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更多：&lt;a href=&quot;https://www.jianshu.com/p/c4ec36af8dad&quot; target=&quot;_blank&quot;&gt;iOS面试题大全&lt;/a&gt;（附答案）&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Apr 2019 15:12:00 +0000</pubDate>
<dc:creator>G_猿员</dc:creator>
<og:description>一、首页启动速度 启动过程中做的事情越少越好（尽可能将多个接口合并） 不在UI线程上作耗时的操作（数据的处理在子线程进行，处理完通知主线程刷新） 在合适的时机开始后台任务（例如在用户指引节目就可以开始</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuzi12345/p/10714046.html</dc:identifier>
</item>
</channel>
</rss>