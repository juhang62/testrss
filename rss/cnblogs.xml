<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>通过实现25个数组方法来理解及高效使用数组方法 - 努力的阿洋</title>
<link>http://www.cnblogs.com/yubingyang/p/11561334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yubingyang/p/11561334.html</guid>
<description>&lt;p&gt;通过实现25个数组方法来理解及高效使用数组方法(长文,建议收藏) 为了保证的可读性，本文采用意译而非直译。 想阅读更多优质文章请猛戳GitHub博客,一年百来篇优质文章等着你！ 要在给定数组上使用方法，只需要通过[].方法名即可，这些方法都定义在 Array.prototype 对象上。在这里，咱们先不使用这些相，反，咱们将从简单的方法开始定义自己的版本，并在这些版本的基础上进行构建。 没有比把东西拆开再重新组装起来更好的学习方法了。注意，当咱们的实现自己的方法时，不要覆盖现有的方法，因为有的库需要它们，并且这样也方便比较咱们自己的方法与原始方法的差异。 所以不要这样命名咱们自定义的方法： Array.prototype.map = function map() { // implementation }; 复制代码 最好这样命名： function map(array) { // implementation } 复制代码 咱们也可以通过使用class关键字并扩展Array构造函数来实现咱们的方法，如下所示： class OwnArray extends Array { public constructor(...args) { super(...args); } public map() { // implementation return this; } } 复制代码 唯一的区别是，我们不使用数组参数，而是使用this关键字。 但是，我觉得 class 方式带来不必要的混乱，所以咱们采用第一种方法。 有了这个，咱们先从实现最简单的方法 forEach 开始！ 集合类 .forEach Array.prototype.forEach 方法对数组的每个元素执行一次提供的函数，而且不会改变原数组。 [1, 2, 3, 4, 5].forEach(value =&amp;gt; console.log(value)); 复制代码 实现 function forEach(array, callback) { const { length } = array; for (let index = 0; index &amp;lt; length; index += 1) { const value = array[index]; callback(value, index, array) } } 复制代码 咱们遍历数组并为每个元素执行回调。这里需要注意的一点是，该方法没有返回什么，所以默认返回undefined。 方法涟 使用数组方法的好处是可以将操作链接在一起。考虑以下代码： function getTodosWithCategory(todos, category) { return todos .filter(todo =&amp;gt; todo.category === category) .map(todo =&amp;gt; normalizeTodo(todo)); } 复制代码 这种方式，咱们就不必将map的执行结果保存到变量中，代码会更简洁。 不幸的是，forEach没有返回原数组，这意味着咱们不能做下面的事情 // 无法工作 function getTodosWithCategory(todos, category) { return todos .filter(todo =&amp;gt; todo.category === category) .forEach((value) =&amp;gt; console.log(value)) .map(todo =&amp;gt; normalizeTodo(todo)); } 复制代码 帮助函数 （打印信息） 接着实现一个简单的函数，它能更好地解释每个方法的功能:接受什么作为输入，返回什么，以及它是否对数组进行了修改。 function logOperation(operationName, array, callback) { const input = [...array]; const result = callback(array); console.log({ operation: operationName, arrayBefore: input, arrayAfter: array, mutates: mutatesArray(input, array), // shallow check result, }); } 复制代码 其中 mutatesArray 方法用来判断是否更改了原数组，如果有修改刚返回 true，否则返回 false。当然大伙有好的想法可以在评论提出呦。 function mutatesArray(firstArray, secondArray) { if (firstArray.length !== secondArray.length) { return true; } for (let index = 0; index &amp;lt; firstArray.length; index += 1) { if (firstArray[index] !== secondArray[index]) { return true; } } return false; } 复制代码 然后使用logOperation来测试咱们前面自己实现的 forEach方法。 logOperation('forEach', [1, 2, 3, 4, 5], array =&amp;gt; forEach(array, value =&amp;gt; console.log(value))); 复制代码 打印结果： { operation: 'forEach', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: undefined } 复制代码 .map map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 实现 function map(array, callback) { const result = []; const { length } = array; for (let index = 0; index &amp;lt; length; index +=1) { const value = array[index]; result[index] = callback(value, index, array); } return result; } 复制代码 提供给方法的回调函数接受旧值作为参数，并返回一个新值，然后将其保存在新数组中的相同索引下，这里用变量 result 表示。 这里需要注意的是，咱们返回了一个新的数组，不修改旧的。 测试 logOperation('map', [1, 2, 3, 4, 5], array =&amp;gt; map(array, value =&amp;gt; value + 5)); 复制代码 打印结果： { operation: 'map', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: [ 6, 7, 8, 9, 10 ] } 复制代码 .filter Array.prototype.filter 过滤回调返回为false的值，每个值都保存在一个新的数组中，然后返回。 [1, 2, 3, 4, 5].filter(number =&amp;gt; number &amp;gt;= 3); // -&amp;gt; [3, 4, 5] 复制代码 实现 function push(array, ...values) { const { length: arrayLength } = array; const { length: valuesLength } = values; for (let index = 0; index &amp;lt; valuesLength; index += 1) { array[arrayLength + index] = values[index]; } return array.length; } -------------------------------------------------- function filter(array, callback) { const result = []; const { length } = array; for (let index = 0; index &amp;lt; length; index += 1) { const value = array[index]; if (callback(value, index, array)) { push(result, value); } } return result; } 复制代码 获取每个值并检查所提供的回调函数是否返回true或false，然后将该值添加到新创建的数组中，或者适当地丢弃它。 注意，这里对result 数组使用push方法，而不是将值保存在传入数组中放置的相同索引中。这样，result就不会因为丢弃的值而有空槽。 测试 logOperation('filter', [1, 2, 3, 4, 5], array =&amp;gt; filter(array, value =&amp;gt; value &amp;gt;= 2)); 复制代码 运行： { operation: 'filter', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: [ 2, 3, 4, 5 ] } 复制代码 .reduce reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduce() 方法接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce() 的数组。 确切地说，如何计算该值是需要在回调中指定的。来看呓使用reduce的一个简单的例子：对一组数字求和： [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].reduce((sum, number) =&amp;gt; { return sum + number; }, 0) // -&amp;gt; 55 复制代码 注意这里的回调接受两个参数:sum和number。第一个参数总是前一个迭代返回的结果，第二个参数在遍历中的当前数组元素。 这里，当咱们对数组进行迭代时，sum包含到循环当前索引的所有数字的和因为每次迭代咱们都将数组的当前值添加到sum中。 实现 function reduce(array, callback, initValue) { const { length } = array; let acc = initValue; let startAtIndex = 0; if (initValue === undefined) { acc = array[0]; startAtIndex = 0; } for (let index = startAtIndex; index &amp;lt; length; index += 1) { const value = array[index]; acc = callback(acc, value, index, array) } return acc; } 复制代码 咱们创建了两个变量acc和startAtIndex，并用它们的默认值初始化它们，分别是参数initValue和0。 然后，检查initValue是否是undefined。如果是，则必须将数组的第一个值设置为初值，为了不重复计算初始元素，将startAtIndex设置为1。 每次迭代，reduce方法都将回调的结果保存在累加器(acc)中，然后在下一个迭代中使用。对于第一次迭代，acc被设置为initValue或array[0]。 测试 logOperation('reduce', [1, 2, 3, 4, 5], array =&amp;gt; reduce(array, (sum, number) =&amp;gt; sum + number, 0)); 复制代码 运行： { operation: 'reduce', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: 15 } 复制代码 检索类 有什么操作比搜索特定值更常见?这里有一些方法可以帮助我们。 .findIndex findIndex帮助咱们找到数组中给定值的索引。 [1, 2, 3, 4, 5, 6, 7].findIndex(value =&amp;gt; value === 5); // 4 复制代码 findIndex方法对数组中的每个数组索引0..length-1（包括）执行一次callback函数，直到找到一个callback函数返回真实值（强制为true）的值。如果找到这样的元素，findIndex会立即返回该元素的索引。如果回调从不返回真值，或者数组的length为0，则findIndex返回-1。 实现 function findIndex(array, callback) { const { length } = array; for (let index = 0; index &amp;lt; length; index += 1) { const value = array[index]; if (callback(value, index, array)) { return index; } } return -1; } 复制代码 测试 logOperation('findIndex', [1, 2, 3, 4, 5], array =&amp;gt; findIndex(array, number =&amp;gt; number === 3)); 复制代码 运行： { operation: 'findIndex', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: 2 } 复制代码 .find find与findIndex的唯一区别在于，它返回的是实际值，而不是索引。实际工作中，咱们可以重用已经实现的findIndex。 [1, 2, 3, 4, 5, 6, 7].find(value =&amp;gt; value === 5); // 5 复制代码 实现 function find(array, callback) { const index = findIndex(array, callback); if (index === -1) { return undefined; } return array[index]; } 复制代码 测试 logOperation('find', [1, 2, 3, 4, 5], array =&amp;gt; find(array, number =&amp;gt; number === 3)); 复制代码 运行 { operation: 'find', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: 3 } 复制代码 .indexOf indexOf是获取给定值索引的另一种方法。然而，这一次，咱们将实际值作为参数而不是函数传递。同样，为了简化实现，可以使用前面实现的findIndex [3, 2, 3].indexOf(3); // -&amp;gt; 0 复制代码 实现 function indexOf(array, searchedValue) { return findIndex(array, value =&amp;gt; value === searchedValue) } 复制代码 测试 logOperation('indexOf', [1, 2, 3, 4, 5], array =&amp;gt; indexOf(array, 3)); 复制代码 执行结果 { operation: 'indexOf', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: 2 } 复制代码 .lastIndexOf lastIndexOf的工作方式与indexOf相同，lastIndexOf() 方法返回指定元素在数组中的最后一个的索引，如果不存在则返回 -1。 [3, 2, 3].lastIndexOf(3); // -&amp;gt; 2 复制代码 实现 function lastIndexOf(array, searchedValue) { for (let index = array.length - 1; index &amp;gt; -1; index -= 1 ){ const value = array[index]; if (value === searchedValue) { return index; } } return -1; } 复制代码 代码基本与findIndex类似，但是没有执行回调，而是比较value和searchedValue。如果比较结果为 true，则返回索引,如果找不到值，返回-1。 测试 logOperation('lastIndexOf', [1, 2, 3, 4, 5, 3], array =&amp;gt; lastIndexOf(array, 3)); 复制代码 执行结果 { operation: 'lastIndexOf', arrayBefore: [ 1, 2, 3, 4, 5, 3 ], arrayAfter: [ 1, 2, 3, 4, 5, 3 ], mutates: false, result: 5 } 复制代码 .every every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试，它返回一个布尔值。 [1, 2, 3].every(value =&amp;gt; Number.isInteger(value)); // -&amp;gt; true 复制代码 咱们可以将every 方法看作一个等价于逻辑与的数组。 实现 function every(array, callback){ const { length } = array; for (let index = 0; index &amp;lt; length; index += 1) { const value = array[index]; if (!callback(value, index, array)) { return false; } } return true; } 复制代码 咱们为每个值执行回调。如果在任何时候返回false，则退出循环，整个方法返回false。如果循环终止而没有进入到if语句里面(说明条件都成立)，则方法返回true。 测试 logOperation('every', [1, 2, 3, 4, 5], array =&amp;gt; every(array, number =&amp;gt; Number.isInteger(number))); 复制代码 执行结果 { operation: 'every', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: true } 复制代码 .some some 方法与 every 刚好相反，即只要其中一个为true 就会返回true。与every 方法类似，咱们可以将some 方法看作一个等价于逻辑或数组。 [1, 2, 3, 4, 5].some(number =&amp;gt; number === 5); // -&amp;gt; true 复制代码 实现 function some(array, callback) { const { length } = array; for (let index = 0; index &amp;lt; length; index += 1) { const value = array[index]; if (callback(value, index, array)) { return true; } } return false; } 复制代码 咱们为每个值执行回调。如果在任何时候返回true，则退出循环，整个方法返回true。如果循环终止而没有进入到if语句里面(说明条件都不成立)，则方法返回false。 测试 logOperation('some', [1, 2, 3, 4, 5], array =&amp;gt; some(array, number =&amp;gt; number === 5)); 复制代码 执行结果 { operation: 'some', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: true } 复制代码 .includes includes方法的工作方式类似于 some 方法，但是includes不用回调，而是提供一个参数值来比较元素。 [1, 2, 3].includes(3); // -&amp;gt; true 复制代码 实现 function includes(array, searchedValue){ return some(array, value =&amp;gt; value === searchedValue) } 复制代码 测试 logOperation('includes', [1, 2, 3, 4, 5], array =&amp;gt; includes(array, 5)); 复制代码 执行结果 { operation: 'includes', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: true } 复制代码 拼接、附加和反转数组 .concat concat() 方法用于合并两个或多个数组，此方法不会更改现有数组，而是返回一个新数组。 [1, 2, 3].concat([4, 5], 6, [7, 8]) // -&amp;gt; [1, 2, 3, 4, 5, 6, 7, 8] 复制代码 实现 function concat(array, ...values) { const result = [...array]; const { length } = values; for (let index = 0; index &amp;lt; length; index += 1) { const value = values[index]; if (Array.isArray(value)) { push(result, ...value); } else { push(result, value); } } return result; } 复制代码 concat将数组作为第一个参数，并将未指定个数的值作为第二个参数，这些值可以是数组，也可以是其他类型的值。 首先，通过复制传入的数组创建 result 数组。然后，遍历 values ，检查该值是否是数组。如果是，则使用push函数将其值附加到结果数组中。 push(result, value) 只会向数组追加为一个元素。相反，通过使用展开操作符push(result，…value) 将数组的所有值附加到result 数组中。在某种程度上，咱们把数组扁平了一层。 测试 logOperation('concat', [1, 2, 3, 4, 5], array =&amp;gt; concat(array, 1, 2, [3, 4])); 复制代码 执行结果 { operation: 'concat', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: [ 1, 2, 3, 4, 5, 1, 2, 3, 4 ] } 复制代码 .join join() 方法用于把数组中的所有元素放入一个字符串，元素是通过指定的分隔符进行分隔的。 ['Brian', 'Matt', 'Kate'].join(', ') // -&amp;gt; Brian, Matt, Kate 复制代码 实现 function join(array, joinWith) { return reduce( array, (result, current, index) =&amp;gt; { if (index === 0) { return current; } return `${result}${joinWith}${current}`; }, '' ) } 复制代码 reduce的回调是神奇之处:reduce遍历所提供的数组并将结果字符串拼接在一起，在数组的值之间放置所需的分隔符(作为joinWith传递)。 array[0]值需要一些特殊的处理，因为此时result是一个空字符串，而且咱们也不希望分隔符(joinWith)位于第一个元素前面。 测试 logOperation('join', [1, 2, 3, 4, 5], array =&amp;gt; join(array, ', ')); 复制代码 执行结果 { operation: 'join', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: '1, 2, 3, 4, 5' } 复制代码 .reverse reverse() 方法将数组中元素的位置颠倒，并返回该数组，该方法会改变原数组。 实现 function reverse(array) { const result = [] const lastIndex = array.length - 1; for (let index = lastIndex; index &amp;gt; -1; index -= 1) { const value = array[index]; result[lastIndex - index ] = value } return result; } 复制代码 其思路很简单:首先，定义一个空数组，并将数组的最后一个索引保存为变量(lastIndex)。接着反过来遍历数组，将每个值保存在结果result 中的(lastIndex - index)位置，然后返回result数组。 测试 logOperation('reverse', [1, 2, 3, 4, 5], array =&amp;gt; reverse(array)); 复制代码 执行结果 { operation: 'reverse', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: [ 5, 4, 3, 2, 1 ] } 复制代码 添加、删除和追加值 .shift shift() 方法从数组中删除第一个元素，并返回该元素的值，此方法更改数组的长度。 [1, 2, 3].shift(); // -&amp;gt; 1 复制代码 实现 function shift(array) { const { length } = array; const firstValue = array[0]; for (let index = 1; index &amp;gt; length; index += 1) { const value = array[index]; array[index - 1] = value; } array.length = length - 1; return firstValue; } 复制代码 首先保存数组的原始长度及其初始值，然后遍历数组并将每个值向下移动一个索引。完成遍历后，更新数组的长度并返回初始值。 测试 logOperation('shift', [1, 2, 3, 4, 5], array =&amp;gt; shift(array)); 复制代码 执行结果 { operation: 'shift', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 2, 3, 4, 5 ], mutates: true, result: 1 } 复制代码 .unshift unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。 [2, 3, 4].unshift(1); // -&amp;gt; [1, 2, 3, 4] 复制代码 实现 function unshift(array, ...values) { const mergedArrays = concat(values, ...array); const { length: mergedArraysLength } = mergedArrays; for (let index = 0; index &amp;lt; mergedArraysLength; index += 1) { const value = mergedArrays[index]; array[index] = value; } return array.length; } 复制代码 首先将需要加入数组值(作为参数传递的单个值)和数组拼接起来。这里需要注意的是，values 放在第一位的，也就是放置在原始数组的前面。 然后保存这个新数组的长度并遍历它，将它的值保存在原始数组中，并覆盖开始时的值。 测试 logOperation('unshift', [1, 2, 3, 4, 5], array =&amp;gt; unshift(array, 0)); 执行结果 { operation: 'unshift', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 0, 1, 2, 3, 4, 5 ], mutates: true, result: 6 } 复制代码 .slice slice() 复制代码 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）原始数组不会被改变。 slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）。 [1, 2, 3, 4, 5, 6, 7].slice(3, 6); // -&amp;gt; [4, 5, 6] 复制代码 实现 (简单实现) function slice(array, startIndex = 0, endIndex = array.length) { const result = []; for (let index = startIndex; index &amp;lt; endIndex; index += 1) { const value = array[index]; if (index &amp;lt; array.length) { push(result, value); } } return result; } 复制代码 咱们遍历数组从startIndex到endIndex，并将每个值放入result。这里使用了这里的默认参数，这样当没有传递参数时，slice方法只创建数组的副本。 注意:if语句确保只在原始数组中存在给定索引下的值时才加入 result 中。 测试 logOperation('slice', [1, 2, 3, 4, 5], array =&amp;gt; slice(array, 1, 3)); 复制代码 执行结果 { operation: 'slice', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4, 5 ], mutates: false, result: [ 2, 3 ] } 复制代码 .splice splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。 首先，指定起始索引，然后指定要删除多少个值，其余的参数是要插入的值。 const arr = [1, 2, 3, 4, 5]; // 从位置0开始，删除2个元素后插入 3, 4, 5 arr.splice(0, 2, 3, 4, 5); arr // -&amp;gt; [3, 4, 5, 3, 4, 5] 复制代码 实现 function splice( array, insertAtIndex, removeNumberOfElements, ...values) { const firstPart = slice(array, 0, insertAtIndex); const secondPart = slice(array, insertAtIndex + removeNumberOfElements); const removedElements = slice( array, insertAtIndex, insertAtIndex + removeNumberOfElements ); const joinedParts = firstPart.concat(values, secondPart); const { length: joinedPartsLength } = joinedParts; for (let index = 0; index &amp;lt; joinedPartsLength; index += 1) { array[index] = joinedParts[index]; } array.length = joinedPartsLength; return removedElements; } 复制代码 其思路是在insertAtIndex和insertAtIndex + removeNumberOfElements上进行两次切割。这样，将原始数组切成三段。第一部分(firstPart)和第三部分(secondPart)加个插入的元素组成为最后数组的内容。 测试 logOperation('splice', [1, 2, 3, 4, 5], array =&amp;gt; splice(array, 1, 3)); 复制代码 执行结果 { operation: 'splice', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 5 ], mutates: true, result: [ 2, 3, 4 ] } 复制代码 .pop pop()方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。 实现 function pop(array) { const value = array[array.length - 1]; array.length = array.length - 1; return value; } 复制代码 首先，将数组的最后一个值保存在一个变量中。然后只需将数组的长度减少1，从而删除最后一个值。 测试 logOperation('pop', [1, 2, 3, 4, 5], array =&amp;gt; pop(array)); 复制代码 执行结果 { operation: 'pop', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4 ], mutates: true, result: 5 } 复制代码 .push push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。 [1, 2, 3, 4].push(5); // -&amp;gt; [1, 2, 3, 4, 5] 复制代码 实现 function push(array, ...values) { const { length: arrayLength } = array; const { length: valuesLength } = values; for (let index = 0; index &amp;lt; valuesLength; index += 1) { array[arrayLength + index] = values[index]; } return array.length; } 复制代码 首先，我们保存原始数组的长度，以及在它们各自的变量中要添加的值。然后，遍历提供的值并将它们添加到原始数组中。 测试 logOperation('push', [1, 2, 3, 4, 5], array =&amp;gt; push(array, 6, 7)); 复制代码 执行结果 { operation: 'push', arrayBefore: [ 1, 2, 3, 4, 5 ], arrayAfter: [ 1, 2, 3, 4,5, 6, 7 ], mutates: true, result: 7 } 复制代码 .fill 当咱们想用一个占位符值填充一个空数组时，可以使用fill方法。如果想创建一个指定数量的null元素数组，可以这样做: [...Array(5)].fill(null) // -&amp;gt; [null, null, null, null, null] 复制代码 实现 function fill(array, value, startIndex = 0, endIndex = array.length) { for (let index = startIndex; index &amp;lt; endIndex; index += 1) { array[index] = value; } return array; } 复制代码 fill方法真正做的是替换指定索引范围内的数组的值。如果没有提供范围，该方法将替换所有数组的值。 测试 logOperation(&quot;fill&quot;, [...new Array(5)], array =&amp;gt; fill(array, 0)); 复制代码 执行结果 { operation: 'fill', arrayBefore: [ undefined, undefined, undefined, undefined, undefined ], arrayAfter: [ 0, 0, 0, 0, 0 ], mutates: true, result: [ 0, 0, 0, 0, 0 ] } 复制代码 扁平类 有时咱们的数组会变嵌套两到三层，咱们想要将它们扁，也就是减少嵌套的程度。例如，想将所有值都放到顶层。为咱们提供帮助有两个新特性:flat和flatMap 方法。 .flat flat方法通过可指定深度值来减少嵌套的深度。 [1, 2, 3, [4, 5, [6, 7, [8]]]].flat(1); // -&amp;gt; [1, 2, 3, 4, 5, [6, 7, [8]]] 复制代码 因为展开的深度值是1，所以只有第一级数组是被扁平，其余的保持不变。 [1, 2, 3, [4, 5]].flat(1) // -&amp;gt; [1, 2, 3, 4, 5] 复制代码 实现 function flat(array, depth = 0) { if (depth &amp;lt; 1 || !Array.isArray(array)) { return array; } return reduce( array, (result, current) =&amp;gt; { return concat(result, flat(current, depth - 1)); }, [], ); } 复制代码 首先，我们检查depth参数是否小于1。如果是，那就意味着没有什么要扁平的，咱们应该简单地返回数组。 其次，咱们检查数组参数是否属于数组类型，因为如果它不是，那么扁化就没有意义了，所以只返回这个参数。 咱们们使用了之前实现的reduce函数。从一个空数组开始，然后取数组的每个值并将其扁平。 注意，我们调用带有(depth - 1)的flat函数。每次调用时，都递减depth参数，以免造成无限循环。扁平化完成后，将返回值来回加到result数组中。 测试 logOperation('flat', [1, 2, 3, [4, 5, [6]]], array =&amp;gt; flat(array, 2)); 复制代码 执行结果 { operation: 'flat', arrayBefore: [ 1, 2, 3, [ 4, 5, [Array] ] ], arrayAfter: [ 1, 2, 3, [ 4, 5, [Array] ] ], mutates: false, result: [ 1, 2, 3, 4, 5, 6 ] } 复制代码 .flatMap flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。 在上面的map方法中，对于每个值，只返回一个值。这样，一个包含三个元素的数组在映射之后仍然有三个元素。使用flatMap，在提供的回调函数中，可以返回一个数组，这个数组稍后将被扁平。 [1, 2, 3].flatMap(value =&amp;gt; [value, value, value]); // [1, 1, 1, 2, 2, 2, 3, 3, 3] 复制代码 每个返回的数组都是扁平的，我们得到的不是一个嵌套了三个数组的数组，而是一个包含9个元素的数组。 实现 function flatMap(array, callback) { return flat(map(array, callback), 1); } 复制代码 首先使用map，然后将数组的结果数组扁平化一层。 测试 logOperation('flatMap', [1, 2, 3], array =&amp;gt; flatMap(array, number =&amp;gt; [number, number])); 复制代码 执行结果 { operation: 'flatMap', arrayBefore: [ 1, 2, 3 ], arrayAfter: [ 1, 2, 3 ], mutates: false, result: [ 1, 1, 2, 2, 3, 3 ] } 复制代码 generator 类 最后三种方法的特殊之处在于它们返回生成器的方式。如果你不熟悉生成器，请跳过它们，因为你可能不会很快使用它们。 .values values方法返回一个生成器，该生成器生成数组的值。 const valuesGenerator = values([1, 2, 3, 4, 5]); valuesGenerator.next(); // { value: 1, done: false } 复制代码 实现 function values(array) { const { length } = array; function* createGenerator() { for (let index = 0; index &amp;lt; length; index += 1) { const value = array[index]; yield value; } } return createGenerator(); } 复制代码 首先，咱们定义createGenerator函数。在其中，咱们遍历数组并生成每个值。 .keys keys方法返回一个生成器，该生成器生成数组的索引。 const keysGenerator = keys([1, 2, 3, 4, 5]); keysGenerator.next(); // { value: 0, done: false } 复制代码 实现 function keys(array) { function* createGenerator() { const { length } = array; for (let index = 0; index &amp;lt; length; index += 1) { yield index; } } return createGenerator(); } 复制代码 实现完全相同，但这一次，生成的是索引，而不是值。 .entries entry方法返回生成键值对的生成器。 const entriesGenerator = entries([1, 2, 3, 4, 5]); entriesGenerator.next(); // { value: [0, 1], done: false } 复制代码 实现 function entries(array) { const { length } = array; function* createGenerator() { for (let index = 0; index &amp;lt; length; index += 1) { const value = array[index]; yield [index, value]; } } return createGenerator(); } 复制代码 同样的实现，但现在咱们将索引和值结合起来，并在数组中生成它们。 总结 高效使用数组的方法是成为一名优秀开发人员的基础。了解他们内部工作的复杂性是我所知道的最好的方法。 代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 Fundebug。 原文：dev.to/bnevilleone…&lt;/p&gt;



</description>
<pubDate>Sat, 21 Sep 2019 00:49:00 +0000</pubDate>
<dc:creator>努力的阿洋</dc:creator>
<og:description>通过实现25个数组方法来理解及高效使用数组方法(长文,建议收藏) 为了保证的可读性，本文采用意译而非直译。 想阅读更多优质文章请猛戳GitHub博客,一年百来篇优质文章等着你！ 要在给定数组上使用方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yubingyang/p/11561334.html</dc:identifier>
</item>
<item>
<title>jsp学习：jsp学习阶段性总结2019.9.21 - 清均qj</title>
<link>http://www.cnblogs.com/qjqj0-0/p/11561327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qjqj0-0/p/11561327.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;Jsp学习
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;jsp语法格式：
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; 脚本程序：&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt; 代码片段 &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; jsp声明：&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;! declaration; [ declaration; ]&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; ... &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; 表达式：&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; 表达式 &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; jsp注释：&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 该部分注释在网页中不会被显示&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; jsp指令：&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ directive attribute&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; jsp行为：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jsp:action_name &lt;/span&gt;&lt;span&gt;attribute&lt;/span&gt;&lt;span&gt;=&quot;value&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; request.getParameter(“account”) &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;使用上面一条语句可以在表单中获取name为account的元素值，也就是account的具体值。
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;例：（学会在jsp页面使用java语句）
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; account &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; request.getParameter(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;account&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt; password &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; request.getParameter(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(account.equals(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qingjun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt;password.equals(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) { &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;   
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jsp:forward &lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;=&quot;ForwardTest_Success.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jsp:forward&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt; } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; { &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jsp:forward &lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;=&quot;ForwardTest_Fail.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jsp:forward&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt; } &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;forward是跳转页面用的组件
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;page指令：
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;&lt;span&gt; language，contentType，import 属性用的多，import引入的多个java类包用逗号隔开
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;被插入的jsp页面page中的contentType属性和本jsp文件必须保持一致。
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;Include指令标记和动作标记的区别：
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;Include指令标记：一起编译执行，一个servlet。通过file属性指定文件，不支持表达式。包含被包含文件一起编译，不能有重名的方法或变量。
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;动作标记：
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;Include动作标记：该标识执行时，程序会请求转发到被包含页面，将执行结果输出到浏览器中，然后返回页面继续执行后面。通过page属性指定文件，支持表达式。不一起编译，可以有重名的方法或变量。
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;%@ include file=&quot;Date.jsp&quot; %&amp;gt;include指令标记&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; include动作标记，将要引入文件的url写成属性内容 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jsp:include &lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;=&quot;Date.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jsp:include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;对应jsptest的pagetest01.jsp
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;Forword动作标记：转向另一个页面，原页面停止执行，浏览器栏显示的仍然是原jsp页面的url。
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;Forward_CheckLogin.jsp&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;account&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;登录&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;转向
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt; account &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; request.getParameter(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;account&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt; password &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; request.getParameter(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(account.equals(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qingjun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt;password.equals(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jsp:forward &lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;=&quot;ForwardTest_Success.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jsp:param &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;123456&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;qwe&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jsp:param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jsp:forward&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt; } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; { &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jsp:forward &lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;=&quot;ForwardTest_Fail.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jsp:forward&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt; } &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;对应jsptest的forward系列，forward动作标记在forward_checklogin.jsp中用到
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;request内置对象：
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;request在接受信息前用request.setCharacterEncoding(“UTF-8”);设置编码方式。
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt; request.setCharacterEncoding(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt; name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; request.getParameter(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt; password &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; request.getParameter(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;out.println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;name);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;out.println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;密码：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;password);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;对应jsptest的request系列，request内置对象在request.jsp中用到
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;response内置对象：
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;动态响应：response.setContentType(&quot;application/msword;charset=utf-8&quot;);//把当前页面设置成word文档的形式，教程教的比较片面？我感觉response很多功能都没讲吧。
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;将当前页面保存为word文档吗
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;yes&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt; str&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;request.getParameter(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (str&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;    str&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(str.equals(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;    response.setContentType(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/msword;charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;重定向：response.sendRedirect(&quot;ResponseTest2.jsp&quot;);//重定向到ResponseTest2.jsp
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;Response.jsp&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;提交&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;提交到：
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;request.setCharacterEncoding(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;request.getParameter(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取到了name
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(name&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;||name.length()&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;    response.sendRedirect(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ResponseTest2.jsp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重定向到ResponseTest2.jsp
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 欢迎&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; name &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;希望以后再用到这些东西我看笔记能懂怎么写
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;对应jsptest的response系列，response内置对象在response.jsp和responsetest.jsp中用到。
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;session内置对象：
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;tomcat服务器使用session内置对象来记录有关连接的信息。从一个客户打开浏览器连接到服务器，到客户关闭浏览器离开这个服务器结束，被称为一个会话。session对象在第一个页面装载时自动创建，完成会话管理。
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;  
&lt;span&gt; 99&lt;/span&gt; 第一次打开tomcat，session对象建立，关闭网页，但tomcat还开着，那么session对象还存在，直到关闭tomcat服务器，刚开始我以为这和application内置对象生命周期是一样的，但当我设定session.setMaxInactiveInterval(5)之后它只能存在5s了，希望在今后的学习中继续了解session内置对象。session可用函数见eclipse里我的练习。session.setMaxInactiveInterval(5);这个函数只能放在&lt;span&gt;&amp;lt;%&lt;/span&gt;  &lt;span&gt;%&amp;gt;&lt;/span&gt;中，我把他放到&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;  &lt;span&gt;%&amp;gt;&lt;/span&gt;&lt;span&gt;里面就报错了。如下：
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;严重: Servlet.service() for servlet [jsp] in context with path [/Jsptest] threw exception [Unable to compile class for JSP: 
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;An error occurred at line: [18] in the jsp file: [/SessionTest.jsp]
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;The method print(boolean) in the type JspWriter is not applicable for the arguments (void)
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;严重：servlet [jsp]的Servlet.service（）在路径[/ Jsptest]的上下文中引发了异常[无法为JSP编译类：
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;在jsp文件中的第[18]行发生错误：[/SessionTest.jsp]
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;JspWriter类型中的方法print（boolean）不适用于参数（void）
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;我只是粗浅的了解了一些session的特性，session的应用还没学到。希望今后能继续学习这方面的内容。只恨自己学的太慢，学的太少。
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;session的一些方法：
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;session.getCreationTime()；
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;session.setAttribute(&quot;username&quot;, &quot;qingjun&quot;);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;session.getAttribute(&quot;username&quot;)；
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;session.getId()；
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;session.setMaxInactiveInterval(5);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;对应jsptest的session系列。
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;application内置对象：
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;&amp;amp;nbsp&lt;/span&gt;&lt;span&gt;在html中表示空格
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;用户共有的一个application对象，所有操作都是对一个application进行操作，服务器启动生成application对象，服务器停止注销该对象。
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;application.setAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qingjun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;application.setAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;application.setAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E-mail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;daaijibu@163.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt; 用户名：&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; application.getAttribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt; &lt;span&gt;application中的属性：
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;
&lt;span&gt;125&lt;/span&gt; &lt;span&gt;Enumeration attributes;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个枚举类型的变量
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;attributes &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; application.getAttributeNames();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将application中的全部属性的枚举集合类赋给attributes
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (attributes.hasMoreElements()) {   
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;    out.println(attributes.nextElement()&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp;&amp;amp;nbsp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历attributes，输出application的全部属性 &lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;nbsp是空格的意思
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt; &lt;span&gt;对应jsptest的ApplicationTest.jsp。
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;out内置对象：主要用来处理缓存区中的信息。这个很常用，直接上代码
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;&amp;lt;%&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt; &lt;span&gt;out.println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;若逢新雪初霁，满月当空，下面平铺着皓影，上面流转着亮银，&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;out.flush();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将缓存区内容输出，如果不加这一句，上面那句话就输出不出来
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;out.clearBuffer(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将缓存区中的内容清除
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;out.println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;而你带着笑向我步来，月色与雪色之间，你是第三种绝色。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;139&lt;/span&gt; &lt;span&gt;对应jsptest的OutTest.jsp。
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;param内置对象：
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jsp:forward &lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;=&quot;ForwardTest_Success.jsp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jsp:param &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;123456&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;qwe&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jsp:param&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jsp:forward&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt; &lt;span&gt;是个jsp:forward里面一层的对象，可以顺带把参数传到page中的页面。
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; 对应jsptest的Forward_CheckLogin.jsp.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 一个简单的jsp学习总结，加油继续学习，希望你每天都是不一样的自己。&lt;/p&gt;
&lt;p&gt;然后不要懒惰，天气凉下来了，思绪也冷静下来专注于己，不断成长吧。&lt;/p&gt;
&lt;p&gt;为了凑够150个字，分享一个我近两年喜爱的钢琴师，听他的曲子是永远听不腻的，每次听都会有新的感受。&lt;br/&gt;罗伯托·卡恰帕利亚（Roberto Cacciapaglia）&lt;br/&gt;罗伯托·卡恰帕利亚出生于米兰，毕业于米兰朱塞佩·威尔第音乐学院，在作曲专业之外，还学习了指挥和电子音乐。在任职于米兰的意大利国家电视台期间，与比萨的国家研究理事会合作，同时学习音乐软件运用。&lt;br/&gt;作为艺术家，他不仅专注于古典音乐，作品还渗透了多种不同的音乐风格和类型，融合了先锋主义、摇滚语言、计算机音乐、实验性音乐、电子音乐以及具有概念性和普遍艺术性的音乐元素。作为作曲家和钢琴家，他是国际舞台上创新音乐领域的关键人物，他的作品将电子实验音乐与古典传统融合在一起。多年来，罗伯托·卡恰帕利亚一直在研究声音的力量，寻求通过深度的情感接触表达出超越边界的音乐。&lt;/p&gt;

</description>
<pubDate>Sat, 21 Sep 2019 00:46:00 +0000</pubDate>
<dc:creator>清均qj</dc:creator>
<og:description>一个简单的jsp学习总结，加油继续学习，希望你每天都是不一样的自己。 然后不要懒惰，天气凉下来了，思绪也冷静下来专注于己，不断成长吧。 为了凑够150个字，分享一个我近两年喜爱的钢琴师，听他的曲子是永</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qjqj0-0/p/11561327.html</dc:identifier>
</item>
<item>
<title>Elasticsearch(8) --- 聚合查询(Metric聚合) - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11556764.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11556764.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;在Mysql中，我们可以获取一组数据的 &lt;strong&gt;最大值(Max)&lt;/strong&gt;、&lt;strong&gt;最小值(Min)&lt;/strong&gt;。同样我们能够对这组数据进行 &lt;strong&gt;分组(Group)&lt;/strong&gt;。那么对于Elasticsearch中&lt;/p&gt;
&lt;p&gt;我们也可以实现同样的功能，聚合有关资料官方文档内容较多，这里大概分3篇或者4篇博客写这个有关Elasticsearch聚合。&lt;/p&gt;
&lt;p&gt;官方对聚合有四个关键字: &lt;code&gt;Metric(指标）&lt;/code&gt;、&lt;code&gt;Bucketing(桶）&lt;/code&gt;、&lt;code&gt;Matrix(矩阵）&lt;/code&gt;、&lt;code&gt;Pipeline(管道）&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一聚合概念&quot;&gt;&lt;span&gt;一、聚合概念&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;es聚合分析是什么&quot;&gt;1. ES聚合分析是什么？&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt; Elasticsearch除全文检索功能外提供的针对Elasticsearch数据做统计分析的功能。它的实时性高,所有的计算结果都是即时返回。&lt;br/&gt;Elasticsearch将聚合分析主要分为如下4类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Metric(指标):   指标分析类型，如计算最大值、最小值、平均值等等 （对桶内的文档进行聚合分析的操作）
Bucket(桶):     分桶类型，类似SQL中的GROUP BY语法 （满足特定条件的文档的集合）
Pipeline(管道): 管道分析类型，基于上一级的聚合分析结果进行在分析
Matrix(矩阵):   矩阵分析类型（聚合是一种面向数值型的聚合，用于计算一组文档字段中的统计信息）&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;es聚合分析查询的写法&quot;&gt;2.ES聚合分析查询的写法&lt;/h4&gt;
&lt;p&gt;在查询请求体中以aggregations节点按如下语法定义聚合分析：&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;&quot;aggregations&quot; : {
    &quot;&amp;lt;aggregation_name&amp;gt;&quot; : {                                 &amp;lt;!--聚合的名字 --&amp;gt;
        &quot;&amp;lt;aggregation_type&amp;gt;&quot; : {                               &amp;lt;!--聚合的类型 --&amp;gt;
            &amp;lt;aggregation_body&amp;gt;                                 &amp;lt;!--聚合体：对哪些字段进行聚合 --&amp;gt;
        }
        [,&quot;meta&quot; : {  [&amp;lt;meta_data_body&amp;gt;] } ]?               &amp;lt;!--元 --&amp;gt;
        [,&quot;aggregations&quot; : { [&amp;lt;sub_aggregation&amp;gt;]+ } ]?   &amp;lt;!--在聚合里面在定义子聚合 --&amp;gt;
    }
    [,&quot;&amp;lt;aggregation_name_2&amp;gt;&quot; : { ... } ]*                     &amp;lt;!--聚合的名字 --&amp;gt;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt;：&lt;strong&gt;aggregations 也可简写为 aggs&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;指标metric和-桶bucket&quot;&gt;3、指标（metric）和 桶（bucket）&lt;/h4&gt;
&lt;p&gt;虽然Elasticsearch有四种聚合方式，但在一般实际开发中，用到的比较多的就是Metric和Bucket。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1） 桶（bucket）　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　a、简单来说桶就是满足特定条件的文档的集合。&lt;/p&gt;
&lt;p&gt;　　b、当聚合开始被执行，每个文档里面的值通过计算来决定符合哪个桶的条件，如果匹配到，文档将放入相应的桶并接着开始聚合操作。&lt;/p&gt;
&lt;p&gt;　　c、桶也可以被嵌套在其他桶里面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）指标（metric）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　a、桶能让我们划分文档到有意义的集合，但是最终我们需要的是对这些桶内的文档进行一些指标的计算。分桶是一种达到目的地的手段：它提供了一种给文档分组的方法来让&lt;/p&gt;
&lt;p&gt;我们可以计算感兴趣的指标。&lt;/p&gt;
&lt;p&gt;　　b、大多数指标是简单的数学运算（如：最小值、平均值、最大值、汇总），这些是通过文档的值来计算的。&lt;/p&gt;
&lt;h2 id=&quot;二指标metric详解&quot;&gt;&lt;span&gt;二、指标（Metric）详解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;官网&lt;/code&gt;: 指标聚合官网文档：&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics.html&quot;&gt;Metric&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Metric聚合分析分为单值分析和多值分析两类：&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;#1、单值分析，只输出一个分析结果
min,max,avg,sum,cardinality
#2、多值分析，输出多个分析结果
stats,extended_stats,percentile,percentile_rank,top hits&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;avg平均值&quot;&gt;1、Avg(平均值)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;计算从聚合文档中提取的数值的平均值。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;POST /exams/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;avg_grade&quot; : { &quot;avg&quot; : { &quot;field&quot; : &quot;grade&quot; } }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;max最大值&quot;&gt;2、Max(最大值)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;计算从聚合文档中提取的数值的最大值。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;POST /sales/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;max_price&quot; : { &quot;max&quot; : { &quot;field&quot; : &quot;price&quot; } }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;min最小值&quot;&gt;3、Min(最小值)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;计算从聚合文档中提取的数值的最小值。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;POST /sales/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;min_price&quot; : { &quot;min&quot; : { &quot;field&quot; : &quot;price&quot; } }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;sum总和&quot;&gt;4、Sum(总和)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;计算从聚合文档中提取的数值的总和。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;POST /sales/_search?size=0
{
    &quot;query&quot; : {
        &quot;constant_score&quot; : {
            &quot;filter&quot; : {
                &quot;match&quot; : { &quot;type&quot; : &quot;hat&quot; }
            }
        }
    },
    &quot;aggs&quot; : {
        &quot;hat_prices&quot; : { &quot;sum&quot; : { &quot;field&quot; : &quot;price&quot; } }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;cardinality唯一值&quot;&gt;5、 Cardinality(唯一值)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;cardinality 求唯一值，即不重复的字段有多少（相当于mysql中的distinct）&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;POST /sales/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;type_count&quot; : {
            &quot;cardinality&quot; : {
                &quot;field&quot; : &quot;type&quot;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;stats&quot;&gt;6、Stats&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;stats 统计，请求后会直接显示多种聚合结果&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;POST /exams/_search?size=0
{
    &quot;aggs&quot; : {
        &quot;grades_stats&quot; : { &quot;stats&quot; : { &quot;field&quot; : &quot;grade&quot; } }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    ...
    &quot;aggregations&quot;: {
        &quot;grades_stats&quot;: {
            &quot;count&quot;: 2,
            &quot;min&quot;: 50.0,
            &quot;max&quot;: 100.0,
            &quot;avg&quot;: 75.0,
            &quot;sum&quot;: 150.0
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;percentiles&quot;&gt;7、Percentiles&lt;/h4&gt;
&lt;p&gt;对指定字段的值按从小到大累计每个值对应的文档数的占比，返回指定占比比例对应的值。&lt;/p&gt;
&lt;p&gt;1）&lt;code&gt;默认取百分比&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认按照[ 1, 5, 25, 50, 75, 95, 99 ]来统计&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;GET latency/_search
{
    &quot;size&quot;: 0,
    &quot;aggs&quot; : {
        &quot;load_time_outlier&quot; : {
            &quot;percentiles&quot; : {
                &quot;field&quot; : &quot;load_time&quot; 
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果可以理解为：占比为50%的文档的age值 &amp;lt;= 445，或反过来：age&amp;lt;=445的文档数占总命中文档数的50%&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    ...
   &quot;aggregations&quot;: {
      &quot;load_time_outlier&quot;: {
         &quot;values&quot; : {
            &quot;1.0&quot;: 5.0,
            &quot;5.0&quot;: 25.0,
            &quot;25.0&quot;: 165.0,
            &quot;50.0&quot;: 445.0,
            &quot;75.0&quot;: 725.0,
            &quot;95.0&quot;: 945.0,
            &quot;99.0&quot;: 985.0
         }
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）&lt;code&gt;指定分位值&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;GET latency/_search
{
    &quot;size&quot;: 0,
    &quot;aggs&quot; : {
        &quot;load_time_outlier&quot; : {
            &quot;percentiles&quot; : {
                &quot;field&quot; : &quot;load_time&quot;,
                &quot;percents&quot; : [95, 99, 99.9] 
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3) &lt;code&gt;Keyed Response&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，keyed标志设置为true，它将唯一的字符串键与每个存储桶相关联，并将范围作为哈希而不是数组返回。&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;GET latency/_search
{
    &quot;size&quot;: 0,
    &quot;aggs&quot;: {
        &quot;load_time_outlier&quot;: {
            &quot;percentiles&quot;: {
                &quot;field&quot;: &quot;load_time&quot;,
                &quot;keyed&quot;: false
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    ...
    &quot;aggregations&quot;: {
        &quot;load_time_outlier&quot;: {
            &quot;values&quot;: [
                {
                    &quot;key&quot;: 1.0,
                    &quot;value&quot;: 5.0
                },
                {
                    &quot;key&quot;: 5.0,
                    &quot;value&quot;: 25.0
                },
                {
                    &quot;key&quot;: 25.0,
                    &quot;value&quot;: 165.0
                },
                {
                    &quot;key&quot;: 50.0,
                    &quot;value&quot;: 445.0
                },
                {
                    &quot;key&quot;: 75.0,
                    &quot;value&quot;: 725.0
                },
                {
                    &quot;key&quot;: 95.0,
                    &quot;value&quot;: 945.0
                },
                {
                    &quot;key&quot;: 99.0,
                    &quot;value&quot;: 985.0
                }
            ]
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;percentile-ranks&quot;&gt;8、 Percentile Ranks&lt;/h4&gt;
&lt;p&gt;上面是通过百分比求文档值，这里通过文档值求百分比。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET latency/_search
{
    &quot;size&quot;: 0,
    &quot;aggs&quot; : {
        &quot;load_time_ranks&quot; : {
            &quot;percentile_ranks&quot; : {
                &quot;field&quot; : &quot;load_time&quot;, 
                &quot;values&quot; : [500, 600]
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;{
    ...
   &quot;aggregations&quot;: {
      &quot;load_time_ranks&quot;: {
         &quot;values&quot; : {
            &quot;500.0&quot;: 55.1,
            &quot;600.0&quot;: 64.0
         }
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;结果说明&lt;/code&gt;：时间小于500的文档占比为55.1%，时间小于600的文档占比为64%，&lt;/p&gt;
&lt;h4 id=&quot;top-hits&quot;&gt;9、Top Hits&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;一般用于分桶后获取该桶内匹配前n的文档列表&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;POST /sales/_search?size=0
{
    &quot;aggs&quot;: {
        &quot;top_tags&quot;: {
            &quot;terms&quot;: {
                &quot;field&quot;: &quot;type&quot;,  #根据type进行分组 每组显示前3个文档
                &quot;size&quot;: 3
            },
            &quot;aggs&quot;: {
                &quot;top_sales_hits&quot;: {
                    &quot;top_hits&quot;: {
                        &quot;sort&quot;: [
                            {
                                &quot;date&quot;: { 
                                    &quot;order&quot;: &quot;desc&quot;  #按照时间进行倒叙排序
                                }
                            }
                        ],
                        &quot;_source&quot;: {
                            &quot;includes&quot;: [ &quot;date&quot;, &quot;price&quot; ] #只显示文档指定字段
                        },
                        &quot;size&quot; : 1
                    }
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;三示例&quot;&gt;&lt;span&gt;三、示例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;下面会针对上面官方文档的例子进行举例说明。&lt;/p&gt;
&lt;h4 id=&quot;添加测试数据&quot;&gt;1、添加测试数据&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1）创建索引&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;DELETE /employees
PUT /employees/
{
  &quot;mappings&quot; : {
      &quot;properties&quot; : {
        &quot;age&quot; : {
          &quot;type&quot; : &quot;integer&quot;
        },
        &quot;gender&quot; : {
          &quot;type&quot; : &quot;keyword&quot;
        },
        &quot;job&quot; : {
          &quot;type&quot; : &quot;text&quot;,
          &quot;fields&quot; : {
            &quot;keyword&quot; : {
              &quot;type&quot; : &quot;keyword&quot;,
              &quot;ignore_above&quot; : 50
            }
          }
        },
        &quot;name&quot; : {
          &quot;type&quot; : &quot;keyword&quot;
        },
        &quot;salary&quot; : {
          &quot;type&quot; : &quot;integer&quot;
        }
      }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2)添加数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加10条数据，每条数据包含：&lt;strong&gt;姓名、年龄、工作、性别、薪资&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT /employees/_bulk
{ &quot;index&quot; : {  &quot;_id&quot; : &quot;1&quot; } }
{ &quot;name&quot; : &quot;Emma&quot;,&quot;age&quot;:32,&quot;job&quot;:&quot;Product Manager&quot;,&quot;gender&quot;:&quot;female&quot;,&quot;salary&quot;:35000 }
{ &quot;index&quot; : {  &quot;_id&quot; : &quot;2&quot; } }
{ &quot;name&quot; : &quot;Underwood&quot;,&quot;age&quot;:41,&quot;job&quot;:&quot;Dev Manager&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;: 50000}
{ &quot;index&quot; : {  &quot;_id&quot; : &quot;3&quot; } }
{ &quot;name&quot; : &quot;Tran&quot;,&quot;age&quot;:25,&quot;job&quot;:&quot;Web Designer&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;:18000 }
{ &quot;index&quot; : {  &quot;_id&quot; : &quot;4&quot; } }
{ &quot;name&quot; : &quot;Rivera&quot;,&quot;age&quot;:26,&quot;job&quot;:&quot;Web Designer&quot;,&quot;gender&quot;:&quot;female&quot;,&quot;salary&quot;: 22000}
{ &quot;index&quot; : {  &quot;_id&quot; : &quot;5&quot; } }
{ &quot;name&quot; : &quot;Rose&quot;,&quot;age&quot;:25,&quot;job&quot;:&quot;QA&quot;,&quot;gender&quot;:&quot;female&quot;,&quot;salary&quot;:18000 }
{ &quot;index&quot; : {  &quot;_id&quot; : &quot;6&quot; } }
{ &quot;name&quot; : &quot;Lucy&quot;,&quot;age&quot;:31,&quot;job&quot;:&quot;QA&quot;,&quot;gender&quot;:&quot;female&quot;,&quot;salary&quot;: 25000}
{ &quot;index&quot; : {  &quot;_id&quot; : &quot;7&quot; } }
{ &quot;name&quot; : &quot;Byrd&quot;,&quot;age&quot;:27,&quot;job&quot;:&quot;QA&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;:20000 }
{ &quot;index&quot; : {  &quot;_id&quot; : &quot;8&quot; } }
{ &quot;name&quot; : &quot;Foster&quot;,&quot;age&quot;:27,&quot;job&quot;:&quot;Java Programmer&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;: 20000}
{ &quot;index&quot; : {  &quot;_id&quot; : &quot;9&quot; } }
{ &quot;name&quot; : &quot;Gregory&quot;,&quot;age&quot;:32,&quot;job&quot;:&quot;Java Programmer&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;:22000 }
{ &quot;index&quot; : {  &quot;_id&quot; : &quot;10&quot; } }
{ &quot;name&quot; : &quot;Bryant&quot;,&quot;age&quot;:20,&quot;job&quot;:&quot;Java Programmer&quot;,&quot;gender&quot;:&quot;male&quot;,&quot;salary&quot;: 9000}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;求薪资最低值&quot;&gt;2、求薪资最低值&lt;/h4&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;POST employees/_search
{
  &quot;size&quot;: 0,
  &quot;aggs&quot;: {
    &quot;min_salary&quot;: {
      &quot;min&quot;: {
        &quot;field&quot;:&quot;salary&quot;
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190920135849524-1090582927.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;找到最低最高和平均工资&quot;&gt;3、找到最低、最高和平均工资&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;POST employees/_search
{
  &quot;size&quot;: 0,
  &quot;aggs&quot;: {
    &quot;max_salary&quot;: {
      &quot;max&quot;: {
        &quot;field&quot;: &quot;salary&quot;
      }
    },
    &quot;min_salary&quot;: {
      &quot;min&quot;: {
        &quot;field&quot;: &quot;salary&quot;
      }
    },
    &quot;avg_salary&quot;: {
      &quot;avg&quot;: {
        &quot;field&quot;: &quot;salary&quot;
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;一个聚合输出多值&quot;&gt;4、一个聚合，输出多值&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;POST employees/_search
{
  &quot;size&quot;: 0,
  &quot;aggs&quot;: {
    &quot;stats_salary&quot;: {
      &quot;stats&quot;: {
        &quot;field&quot;:&quot;salary&quot;
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190920135901853-1110092954.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;求一共有多少工作类型&quot;&gt;5、求一共有多少工作类型&lt;/h4&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST employees/_search
{
  &quot;size&quot;: 0,
  &quot;aggs&quot;: {
    &quot;cardinate&quot;: {
      &quot;cardinality&quot;: {
        &quot;field&quot;: &quot;job.keyword&quot;
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190920135911775-1864659529.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; 我们需要把job的类型为&lt;code&gt;keyword&lt;/code&gt;类型，这样就不会分词，把它当成一个整体。&lt;/p&gt;
&lt;h4 id=&quot;查看中位数的薪资&quot;&gt;6、查看中位数的薪资&lt;/h4&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST employees/_search
{
    &quot;size&quot;: 0,
    &quot;aggs&quot;: {
        &quot;load_time_outlier&quot;: {
            &quot;percentiles&quot;: {
                &quot;field&quot;: &quot;salary&quot;,
                 &quot;percents&quot; : [50, 99],
                &quot;keyed&quot;: false
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190920135923173-2123362530.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现这些工作的中位数是：21000元。&lt;/p&gt;
&lt;h4 id=&quot;取每个工作类型薪资最高的数据&quot;&gt;7、取每个工作类型薪资最高的数据&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;多层嵌套&lt;/code&gt; 根据工作类型分桶，然后按照性别分桶，计算每个桶中工资的最高的薪资。&lt;/p&gt;
&lt;pre class=&quot;makefile&quot;&gt;
&lt;code&gt;POST employees/_search
{
  &quot;size&quot;: 0,
  &quot;aggs&quot;: {
    &quot;Job_gender_stats&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;job.keyword&quot;
      },
      &quot;aggs&quot;: {
        &quot;gender_stats&quot;: {
          &quot;terms&quot;: {
            &quot;field&quot;: &quot;gender&quot;
          },
          &quot;aggs&quot;: {
            &quot;salary_stats&quot;: {
              &quot;max&quot;: {
                &quot;field&quot;: &quot;salary&quot;
              }
            }
          }
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201909/1090617-20190920135932983-1106986911.png&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、Elasticsearch核心技术与实战---阮一鸣(eBay Pronto平台技术负责人&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html&quot;&gt;ES7.3版官方聚合查询API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.cnblogs.com/cnjavahome/p/9164078.html&quot;&gt;Elasticsearch 聚合分析&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 我相信，无论今后的道路多么坎坷，只要抓住今天，迟早会在奋斗中尝到人生的甘甜。抓住人生中的一分一秒，胜过虚度中的一月一年！(12）&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Sat, 21 Sep 2019 00:46:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>Elasticsearch(8) 聚合查询(Metric聚合) 在Mysql中，我们可以获取一组数据的 最大值(Max) 、 最小值(Min) 。同样我们能够对这组数据进行 分组(Group) 。那么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11556764.html</dc:identifier>
</item>
<item>
<title>Go微服务全链路跟踪详解 - 倚天码农</title>
<link>http://www.cnblogs.com/code-craftsman/p/11561306.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/code-craftsman/p/11561306.html</guid>
<description>&lt;p&gt;在微服务架构中，调用链是漫长而复杂的，要了解其中的每个环节及其性能，你需要全链路跟踪。 它的原理很简单，你可以在每个请求开始时生成一个唯一的ID，并将其传递到整个调用链。 该ID称为&lt;a href=&quot;https://hilton.org.uk/blog/microservices-correlation-id&quot;&gt;CorrelationID&lt;/a&gt;¹，你可以用它来跟踪整个请求并获得各个调用环节的性能指标。简单来说有两个问题需要解决。第一，如何在应用程序内部传递ID; 第二，当你需要调用另一个微服务时，如何通过网络传递ID。&lt;/p&gt;
&lt;h2 id=&quot;什么是opentracing&quot;&gt;什么是OpenTracing?&lt;/h2&gt;
&lt;p&gt;现在有许多开源的分布式跟踪库可供选择，其中最受欢迎的库可能是&lt;a href=&quot;https://zipkin.io/&quot;&gt;Zipkin&lt;/a&gt;²和&lt;a href=&quot;https://www.jaegertracing.io/&quot;&gt;Jaeger&lt;/a&gt;³。 选择哪个是一个令人头疼的问题，因为你现在可以选择最受欢迎的一个，但是如果以后有一个更好的出现呢？&lt;a href=&quot;https://opentracing.io/docs/getting-started/&quot;&gt;OpenTracing&lt;/a&gt;⁴可以帮你解决这个问题。它建立了一套跟踪库的通用接口，这样你的程序只需要调用这些接口而不被具体的跟踪库绑定，将来可以切换到不同的跟踪库而无需更改代码。Zipkin和Jaeger都支持OpenTracing。&lt;/p&gt;
&lt;h2 id=&quot;如何跟踪服务器端点server-endpoints&quot;&gt;如何跟踪服务器端点(server endpoints)?&lt;/h2&gt;
&lt;p&gt;在下面的程序中我使用“Zipkin”作为跟踪库，用“OpenTracing”作为通用跟踪接口。 跟踪系统中通常有四个组件，下面我用Zipkin作为示例：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;recorder(记录器)：记录跟踪数据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Reporter (or collecting agent)(报告器或收集代理)：从记录器收集数据并将数据发送到UI程序&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Tracer：生成跟踪数据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;UI：负责在图形UI中显示跟踪数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1805487/201909/1805487-20190921081644111-611259249.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是Zipkin的组件图，你可以在&lt;a href=&quot;https://zipkin.io/pages/architecture.html&quot;&gt;Zipkin Architecture&lt;/a&gt;中找到它。&lt;/p&gt;
&lt;p&gt;有两种不同类型的跟踪，一种是进程内跟踪（in-process），另一种是跨进程跟踪（cross-process）。 我们将首先讨论跨进程跟踪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端程序:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们将用一个简单的gRPC程序作为示例，它分成客户端和服务器端代码。 我们想跟踪一个完整的服务请求，它从客户端到服务端并从服务端返回。 以下是在客户端创建新跟踪器的代码。它首先创建“HTTP Collector”(the agent)用来收集跟踪数据并将其发送到“Zipkin” UI， “endpointUrl”是“Zipkin” UI的URL。 其次，它创建了一个记录器(recorder)来记录端点上的信息，“hostUrl”是gRPC(客户端)呼叫的URL。第三，它用我们新建的记录器创建了一个新的跟踪器(tracer)。 最后，它为“OpenTracing”设置了“GlobalTracer”，这样你可以在程序中的任何地方访问它。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;const (
    endpoint_url = &quot;http://localhost:9411/api/v1/spans&quot;
    host_url = &quot;localhost:5051&quot;
    service_name_cache_client = &quot;cache service client&quot;
    service_name_call_get = &quot;callGet&quot;
)

func newTracer () (opentracing.Tracer, zipkintracer.Collector, error) {
    collector, err := openzipkin.NewHTTPCollector(endpoint_url)
    if err != nil {
        return nil, nil, err
    }
    recorder :=openzipkin.NewRecorder(collector, true, host_url, service_name_cache_client)
    tracer, err := openzipkin.NewTracer(
        recorder,
        openzipkin.ClientServerSameSpan(true))

    if err != nil {
        return nil,nil,err
    }
    opentracing.SetGlobalTracer(tracer)

    return tracer,collector, nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是gRPC客户端代码。 它首先调用上面提到的函数“newTrace()”来创建跟踪器，然后，它创建一个包含跟踪器的gRPC调用连接。接下来，它使用新建的gRPC连接创建缓存服务(Cache service)的gRPC客户端。 最后，它通过gRPC客户端来调用缓存服务的“Get”函数。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;key:=&quot;123&quot;
    tracer, collector, err :=newTracer()
    if err != nil {
        panic(err)
    }
    defer collector.Close()
    connection, err := grpc.Dial(host_url,
        grpc.WithInsecure(), grpc.WithUnaryInterceptor(otgrpc.OpenTracingClientInterceptor(tracer, otgrpc.LogPayloads())),
        )
    if err != nil {
        panic(err)
    }
    defer connection.Close()
    client := pb.NewCacheServiceClient(connection)
    value, err := callGet(key, client)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Trace 和 Span:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在OpenTracing中，一个重要的概念是“trace”，它表示从头到尾的一个请求的调用链，它的标识符是“traceID”。 一个“trace”包含有许多跨度(span)，每个跨度捕获调用链内的一个工作单元，并由“spanId”标识。 每个跨度具有一个父跨度，并且一个“trace”的所有跨度形成有向无环图(DAG)。 以下是跨度之间的关系图。 你可以从&lt;a href=&quot;https://opentracing.io/specification/&quot;&gt;The OpenTracing Semantic Specification&lt;/a&gt;中找到它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1805487/201909/1805487-20190921081644372-100238741.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是函数“callGet”的代码，它调用了gRPC服务端的“Get&quot;函数。 在函数的开头，OpenTracing为这个函数调用开启了一个新的span，整个函数结束后，它也结束了这个span。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;
const service_name_call_get = &quot;callGet&quot;

func callGet(key string, c pb.CacheServiceClient) ( []byte, error) {
    span := opentracing.StartSpan(service_name_call_get)
    defer span.Finish()
    time.Sleep(5*time.Millisecond)
    // Put root span in context so it will be used in our calls to the client.
    ctx := opentracing.ContextWithSpan(context.Background(), span)
    //ctx := context.Background()
    getReq:=&amp;amp;pb.GetReq{Key:key}
    getResp, err :=c.Get(ctx, getReq )
    value := getResp.Value
    return value, err
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;服务端代码:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是服务端代码，它与客户端代码类似，它调用了“newTracer()”(与客户端“newTracer()”函数几乎相同)来创建跟踪器。然后，它创建了一个“OpenTracingServerInterceptor”，其中包含跟踪器。 最后，它使用我们刚创建的拦截器(Interceptor)创建了gRPC服务器。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;connection, err := net.Listen(network, host_url)
    if err != nil {
        panic(err)
    }
    tracer,err  := newTracer()
    if err != nil {
        panic(err)
    }
    opts := []grpc.ServerOption{
        grpc.UnaryInterceptor(
            otgrpc.OpenTracingServerInterceptor(tracer,otgrpc.LogPayloads()),
        ),
    }
    srv := grpc.NewServer(opts...)
    cs := initCache()
    pb.RegisterCacheServiceServer(srv, cs)

    err = srv.Serve(connection)
    if err != nil {
        panic(err)
    } else {
        fmt.Println(&quot;server listening on port 5051&quot;)
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是运行上述代码后在Zipkin中看到的跟踪和跨度的图片。 在服务器端，我们不需要在函数内部编写任何代码来生成span，我们需要做的就是创建跟踪器（tracer），服务器拦截器自动为我们生成span。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1805487/201909/1805487-20190921081644634-839821467.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;怎样跟踪函数内部&quot;&gt;怎样跟踪函数内部?&lt;/h2&gt;
&lt;p&gt;上面的图片没有告诉我们函数内部的跟踪细节， 我们需要编写一些代码来获得它。&lt;/p&gt;
&lt;p&gt;以下是服务器端“get”函数，我们在其中添加了跟踪代码。 它首先从上下文获取跨度(span)，然后创建一个新的子跨度并使用我们刚刚获得的跨度作为父跨度。 接下来，它执行一些操作(例如数据库查询)，然后结束(mysqlSpan.Finish())子跨度。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;const service_name_db_query_user = &quot;db query user&quot;

func (c *CacheService) Get(ctx context.Context, req *pb.GetReq) (*pb.GetResp, error) {
    time.Sleep(5*time.Millisecond)
    if parent := opentracing.SpanFromContext(ctx); parent != nil {
        pctx := parent.Context()
        if tracer := opentracing.GlobalTracer(); tracer != nil {
            mysqlSpan := tracer.StartSpan(service_name_db_query_user, opentracing.ChildOf(pctx))
            defer mysqlSpan.Finish()
            //do some operations
            time.Sleep(time.Millisecond * 10)
        }
    }
    key := req.GetKey()
    value := c.storage[key]
    fmt.Println(&quot;get called with return of value: &quot;, value)
    resp := &amp;amp;pb.GetResp{Value: value}
    return resp, nil

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是它运行后的图片。 现在它在服务器端有一个新的跨度“db query user”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1805487/201909/1805487-20190921081644874-602026304.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是zipkin中的跟踪数据。 你可以看到客户端从8.016ms开始，服务端也在同一时间启动。 服务器端完成需要大约16ms。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1805487/201909/1805487-20190921081645106-2145075820.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;怎样跟踪数据库&quot;&gt;怎样跟踪数据库?&lt;/h2&gt;
&lt;p&gt;怎样才能跟踪数据库内部的操作？首先，数据库驱动程序需要支持跟踪，另外你需要将跟踪器(tracer)传递到数据库函数中。如果数据库驱动程序不支持跟踪怎么办？现在已经有几个开源驱动程序封装器(Wrapper)，它们可以封装任何数据库驱动程序并使其支持跟踪。其中一个是&lt;a href=&quot;https://github.com/ExpansiveWorlds/instrumentedsql&quot;&gt;instrumentedsql&lt;/a&gt;⁷(另外两个是&lt;a href=&quot;https://github.com/luna-duclos/instrumentedsql&quot;&gt;luna-duclos/instrumentedsql&lt;/a&gt;⁸和&lt;a href=&quot;https://github.com/opencensus-integrations/ocsql/blob/master/driver.go&quot;&gt;ocsql/driver.go&lt;/a&gt;⁹)。我简要地看了一下他们的代码，他们的原理基本相同。它们都为底层数据库的每个函数创建了一个封装(Wrapper)，并在每个数据库操作之前启动一个新的跨度，并在操作完成后结束跨度。但是所有这些都只封装了“database/sql”接口，这就意味着NoSQL数据库没有办法使用他们。如果你找不到支持你需要的NoSQL数据库（例如MongoDB)的OpenTracing的驱动程序，你可能需要自己编写一个封装(Wrapper),它并不困难。&lt;/p&gt;
&lt;p&gt;一个问题是“如果我使用OpenTracing和Zipkin而数据库驱动程序使用Openeracing和Jaeger，那会有问题吗？&quot;这其实不会发生。我上面提到的大部分封装都支持OpenTracing。在使用封装时，你需要注册封装了的SQL驱动程序，其中包含跟踪器。在SQL驱动程序内部，所有跟踪函数都只调用了OpenTracing的接口，因此它们甚至不知道底层实现是Zipkin还是Jaeger。现在使用OpenTarcing的好处终于体现出来了。在应用程序中创建全局跟踪器时(Global tracer)，你需要决定是使用Zipkin还是Jaeger，但这之后，应用程序或第三方库中的每个函数都只调用OpenTracing接口，已经与具体的跟踪库(Zipkin或Jaeger)没关系了。&lt;/p&gt;
&lt;h2 id=&quot;怎样跟踪服务调用&quot;&gt;怎样跟踪服务调用?&lt;/h2&gt;
&lt;p&gt;假设我们需要在gRPC服务中调用另外一个微服务(例如RESTFul服务)，该如何跟踪？&lt;/p&gt;
&lt;p&gt;简单来说就是使用HTTP头作为媒介（Carrier）来传递跟踪信息(traceID)。无论微服务是gRPC还是RESTFul，它们都使用HTTP协议。如果是消息队列(Message Queue)，则将跟踪信息(traceID)放入消息报头中。(&lt;a href=&quot;https://github.com/openzipkin/b3-propagation&quot;&gt;Zipkin B3-propogation&lt;/a&gt;有“single header”和“multiple header”有两种不同类型的跟踪信息，但JMS仅支持“single header”)&lt;/p&gt;
&lt;p&gt;一个重要的概念是“跟踪上下文(trace context)”，它定义了传播跟踪所需的所有信息，例如traceID，parentId(父spanId)等。有关详细信息，请阅读&lt;a href=&quot;https://www.w3.org/TR/trace-context/&quot;&gt;跟踪上下文(trace context)&lt;/a&gt;¹⁰。&lt;/p&gt;
&lt;p&gt;OpenTracing提供了两个处理“跟踪上下文(trace context)”的函数：“extract(format，carrier)”和“inject(SpanContext，format，carrier)”。 “extarct()”从媒介（通常是HTTP头）获取跟踪上下文。 “inject”将跟踪上下文放入媒介，来保证跟踪链的连续性。以下是我从Zipkin获取的&lt;a href=&quot;https://github.com/openzipkin/b3-propagation&quot;&gt;b3-propagation&lt;/a&gt;图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1805487/201909/1805487-20190921081645325-314181799.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是为什么我们没有在上面的例子中调用这些函数呢？让我们再来回顾一下代码。在客户端，在创建gRPC客户端连接时，我们调用了一个为“OpenTracingClientInterceptor”的函数。 以下是“OpenTracingClientInterceptor”的部分代码，我从&lt;a href=&quot;http://github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc&quot;&gt;otgrpc&lt;/a&gt;¹¹包中的“client.go”中得到了它。它已经从&lt;a href=&quot;https://blog.golang.org/context&quot;&gt;Go context&lt;/a&gt;¹²获取了跟踪上下文并将其注入HTTP头，因此我们不再需要再次调用“inject”函数。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func OpenTracingClientInterceptor(tracer opentracing.Tracer, optFuncs ...Option) 
  grpc.UnaryClientInterceptor {
    ...
    ctx = injectSpanContext(ctx, tracer, clientSpan)
    ...
  }
  
  func injectSpanContext(ctx context.Context, tracer opentracing.Tracer, clientSpan opentracing.Span) 
    context.Context {
      md, ok := metadata.FromOutgoingContext(ctx)
      if !ok {
        md = metadata.New(nil)
      } else {
        md = md.Copy()
      }
      mdWriter := metadataReaderWriter{md}
      err := tracer.Inject(clientSpan.Context(), opentracing.HTTPHeaders, mdWriter)
      // We have no better place to record an error than the Span itself :-/
      if err != nil {
        clientSpan.LogFields(log.String(&quot;event&quot;, &quot;Tracer.Inject() failed&quot;), log.Error(err))
      }
      return metadata.NewOutgoingContext(ctx, md)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在服务器端，我们还调用了一个函数“otgrpc.OpenTracingServerInterceptor”，其代码类似于客户端的“OpenTracingClientInterceptor”。它不是调用“inject”写入跟踪上下文，而是从HTTP头中提取（extract）跟踪上下文并将其放入Go上下文（Go context）中。 这就是我们不需要再次手动调用“extract（）”的原因。 我们可以直接从Go上下文中提取跟踪上下文（opentracing.SpanFromContext（ctx））。 但对于其他基于HTTP的服务（如RESTFul服务）， 情况就并非如此，因此我们需要写代码从服务器端的HTTP头中提取跟踪上下文。 当然，您也可以使用拦截器或过滤器。&lt;/p&gt;
&lt;h2 id=&quot;跟踪库之间的互兼容性&quot;&gt;跟踪库之间的互兼容性&lt;/h2&gt;
&lt;p&gt;你也许会问“如果我的程序使用Zipkin和OpenTracing而需要调用的第三方微服务使用OpenTracing与Jaeger，它们会兼容吗？&quot;它看起来于我们之前询问的数据库问题类似，但实际上很不相同。对于数据库，因为应用程序和数据库在同一个进程中，它们可以共享相同的全局跟踪器，因此更容易解决。对于微服务，这种方式将不兼容。因为OpenTracing只标准化了跟踪接口，它没有标准化跟踪上下文。万维网联盟(W3C)正在制定&lt;a href=&quot;https://w3c.github.io/trace-context/&quot;&gt;跟踪上下文(trace context)&lt;/a&gt;¹⁰的标准，并于2019-08-09年发布了候选推荐标准。OpenTracing没有规定跟踪上下文的格式，而是把决定权留给了实现它的跟踪库。结果每个库都选择了自己独有的的格式。例如，Zipkin使用“X-B3-TraceId”作为跟踪ID，Jaeger使用“uber-trace-id”，因此使用OpenTracing并不意味着不同的跟踪库可以进行跨网互操作。 对于“Jaeger”来说有一个好处是你可以选择使用“&lt;a href=&quot;https://github.com/jaegertracing/jaeger-client-go/tree/master/zipkin&quot;&gt;Zipkin兼容性功能&lt;/a&gt;&quot;¹³来生成Zipkin跟踪上下文， 这样就可以与Zipkin相互兼容了。对于其他情况，你需要自己进行手动格式转换(在“inject”和“extract”之间)。&lt;/p&gt;
&lt;h2 id=&quot;全链路跟踪设计&quot;&gt;全链路跟踪设计&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;尽量少写代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个好的全链路跟踪系统不需要用户编写很多跟踪代码。最理想的情况是你不需要任何代码，让框架或库负责处理它，当然这比较困难。 全链路跟踪分成三个跟踪级别：&lt;/p&gt;
&lt;p&gt;跨进程跟踪是最简单的。你可以编写拦截器或过滤器来跟踪每个请求，它只需要编写极少的编码。数据库跟踪也比较简单。如果使用我们上面讨论过的封装器(Wrapper)，你只需要注册SQL驱动程序封装器(Wrapper)并将go-context(里面有跟踪上下文) 传入数据库函数。你可以使用依赖注入(Dependency Injection)这样就可以用比较少的代码来完成此操作。&lt;/p&gt;
&lt;p&gt;进程内跟踪是最困难的，因为你必须为每个单独的函数编写跟踪代码。现在还没有一个很好的方法，可以编写一个通用的函数来跟踪应用程序中的每个函数(拦截器不是一个好选择，因为它需要每个函数的参数和返回都必须是一个泛型类型(interface {}))。幸运的是，对于大多数人来说，前两个级别的跟踪应该已经足够了。&lt;/p&gt;
&lt;p&gt;有些人可能会使用服务网格(service mesh)来实现分布式跟踪，例如&lt;a href=&quot;https://istio.io/&quot;&gt;Istio&lt;/a&gt;或&lt;a href=&quot;https://linkerd.io/&quot;&gt;Linkerd&lt;/a&gt;。它确实是一个好主意，跟踪最好由基础架构实现，而不是将业务逻辑代码与跟踪代码混在一起，不过你将遇到我们刚才谈到的同样问题。服务网格只负责跨进程跟踪，函数内部或数据库跟踪任然需要你来编写代码。不过一些服务网格可以通过提供与流行跟踪库的集成，来简化不同跟踪库跨网跟踪时的的上下文格式转换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跟踪设计:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;精心设计的跨度(span)，服务名称(service name)，标签(tag)能充分发挥全链路跟踪的作用，并使之简单易用。有关信息请阅读&lt;a href=&quot;https://github.com/opentracing/specification/blob/master/semantic_conventions.md&quot;&gt;语义约定(Semantic Conventions)&lt;/a&gt;¹⁴。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将Trace ID记录到日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将跟踪与日志记录集成是一个常见的需求，最重要的是将跟踪ID记录到整个调用链的日志消息中。 目前OpenTracing不提供访问traceID的方法。 你可以将“OpenTracing.SpanContext”转换为特定跟踪库的“SpanContext”(Zipkin和Jaeger都可以通过“SpanContext”访问traceID)或将“OpenTracing.SpanContext”转换为字符串并解析它以获取traceID。转换为字符串更好，因为它不会破坏程序的依赖关系。 幸运的是不久的将来你就不需要它了，因为OpenTracing将提供访问traceID的方法，请阅读&lt;a href=&quot;https://github.com/opentracing/specification/blob/master/rfc/trace_identifiers.md&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;opentracing-和-opencensus&quot;&gt;OpenTracing 和 OpenCensus&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://opencensus.io/&quot;&gt;OpenCensus&lt;/a&gt;¹⁵不是另一个通用跟踪接口，它是一组库，可以用来与其他跟踪库集成以完成跟踪功能，因此它经常与OpenTracing进行比较。 那么它与OpenTracing兼容吗？答案是否定的。 因此，在选择跟踪接口时(不论是OpenTracing还是OpenCensus)需要小心，以确保你需要调用的其他库支持它。 一个好消息是，你不需要在将来做出选择，因为它们会&lt;a href=&quot;https://medium.com/opentracing/merging-opentracing-and-opencensus-f0fe9c7ca6f0&quot;&gt;将项目合并为一个&lt;/a&gt;¹⁶。&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论:&lt;/h2&gt;
&lt;p&gt;全链路跟踪包括不同的场景，例如在函数内部跟踪，数据库跟踪和跨进程跟踪。 每个场景都有不同的问题和解决方案。如果你想设计更好的跟踪解决方案或为你的应用选择最适合的跟踪工具或库，那你需要对每种情况都有清晰的了解。&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码:&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jfeng45/grpcservice&quot;&gt;完整源码的github链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;索引&quot;&gt;索引:&lt;/h2&gt;
&lt;p&gt;[1]Correlation IDs for microservices architectures&lt;br/&gt;&lt;a href=&quot;https://hilton.org.uk/blog/microservices-correlation-id&quot; class=&quot;uri&quot;&gt;https://hilton.org.uk/blog/microservices-correlation-id&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]Zipkin&lt;br/&gt;&lt;a href=&quot;https://zipkin.io/&quot;&gt;https://zipkin.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3]Jaeger: open source, end-to-end distributed tracing&lt;br/&gt;&lt;a href=&quot;https://www.jaegertracing.io/&quot;&gt;https://www.jaegertracing.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4]OpenTracing&lt;br/&gt;&lt;a href=&quot;https://opentracing.io/docs/getting-started/&quot;&gt;https://opentracing.io/docs/getting-started&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5]Zipkin Architecture&lt;br/&gt;&lt;a href=&quot;https://zipkin.io/pages/architecture.html&quot; class=&quot;uri&quot;&gt;https://zipkin.io/pages/architecture.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[6]The OpenTracing Semantic Specification&lt;br/&gt;&lt;a href=&quot;https://opentracing.io/specification/&quot; class=&quot;uri&quot;&gt;https://opentracing.io/specification/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[7]instrumentedsql&lt;br/&gt;&lt;a href=&quot;https://github.com/ExpansiveWorlds/instrumentedsql&quot; class=&quot;uri&quot;&gt;https://github.com/ExpansiveWorlds/instrumentedsql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[8]luna-duclos/instrumentedsql&lt;br/&gt;&lt;a href=&quot;https://github.com/luna-duclos/instrumentedsql&quot; class=&quot;uri&quot;&gt;https://github.com/luna-duclos/instrumentedsql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[9]ocsql/driver.go&lt;br/&gt;&lt;a href=&quot;https://github.com/opencensus-integrations/ocsql/blob/master/driver.go&quot; class=&quot;uri&quot;&gt;https://github.com/opencensus-integrations/ocsql/blob/master/driver.go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[10]Trace Context&lt;br/&gt;&lt;a href=&quot;https://www.w3.org/TR/trace-context/&quot; class=&quot;uri&quot;&gt;https://www.w3.org/TR/trace-context/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[11]otgrpc&lt;br/&gt;&lt;a href=&quot;http://github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc&quot; class=&quot;uri&quot;&gt;http://github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[12]Go Concurrency Patterns: Context&lt;br/&gt;&lt;a href=&quot;https://blog.golang.org/context&quot; class=&quot;uri&quot;&gt;https://blog.golang.org/context&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[13]Zipkin compatibility features&lt;br/&gt;&lt;a href=&quot;https://github.com/jaegertracing/jaeger-client-go/tree/master/zipkin&quot; class=&quot;uri&quot;&gt;https://github.com/jaegertracing/jaeger-client-go/tree/master/zipkin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[14]Semantic Conventions&lt;br/&gt;&lt;a href=&quot;https://github.com/opentracing/specification/blob/master/semantic_conventions.md&quot; class=&quot;uri&quot;&gt;https://github.com/opentracing/specification/blob/master/semantic_conventions.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[15]OpenCensus&lt;br/&gt;&lt;a href=&quot;https://opencensus.io/&quot; class=&quot;uri&quot;&gt;https://opencensus.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[16]merge the project into one&lt;br/&gt;&lt;a href=&quot;https://medium.com/opentracing/merging-opentracing-and-opencensus-f0fe9c7ca6f0&quot; class=&quot;uri&quot;&gt;https://medium.com/opentracing/merging-opentracing-and-opencensus-f0fe9c7ca6f0&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Sep 2019 00:17:00 +0000</pubDate>
<dc:creator>倚天码农</dc:creator>
<og:description>在微服务架构中，调用链是漫长而复杂的，要了解其中的每个环节及其性能，你需要全链路跟踪。 它的原理很简单，你可以在每个请求开始时生成一个唯一的ID，并将其传递到整个调用链。 该ID称为Correlati</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/code-craftsman/p/11561306.html</dc:identifier>
</item>
<item>
<title>Charles 修改请求/compose和Compose New - 叫我朱哥</title>
<link>http://www.cnblogs.com/broszhu/p/11561214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/broszhu/p/11561214.html</guid>
<description>&lt;p&gt;本文参考：&lt;a href=&quot;https://www.axihe.com/tools/charles/tools/compose.html&quot;&gt;撰写工具/compose和Compose New&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;撰写工具/compose和Compose New&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;compose 是在原有的请求基础上，修改；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/charles_proxy_compose.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以写各种状态；&lt;/strong&gt;&lt;br/&gt;– URL：&lt;br/&gt;– Method：&lt;br/&gt;– GET&lt;br/&gt;– POST&lt;br/&gt;– PUT&lt;br/&gt;– DELETE&lt;br/&gt;– HEAD&lt;br/&gt;– TRACE&lt;br/&gt;– Content type：&lt;br/&gt;– application/x-www-form-urlencoded&lt;br/&gt;– multipart/form-data; boundary=********&lt;br/&gt;– text/plain&lt;br/&gt;– text/xml&lt;br/&gt;– text/json&lt;br/&gt;– text/javascript&lt;br/&gt;– Protocol version：&lt;br/&gt;– HTTP/1.0&lt;br/&gt;– HTTP/1.1&lt;br/&gt;– HTTP/2.0&lt;/p&gt;
&lt;p&gt;这个发送后，该编辑还继续存在，你可以再次修改的；&lt;/p&gt;
&lt;p&gt;书写的时候，问上上会出现一个书写笔的标记，代表这个文件是可以书写的；&lt;/p&gt;
&lt;p&gt;其实在文件上右键更方便，&lt;br/&gt;本文参考:&lt;a href=&quot;https://www.axihe.com/&quot; class=&quot;uri&quot;&gt;https://www.axihe.com/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Sep 2019 17:19:00 +0000</pubDate>
<dc:creator>叫我朱哥</dc:creator>
<og:description>本文参考： '撰写工具/compose和Compose New' 撰写工具/compose和Compose New compose 是在原有的请求基础上，修改； 可以写各种状态； – URL： – M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/broszhu/p/11561214.html</dc:identifier>
</item>
<item>
<title>charles DNS欺骗 - 叫我朱哥</title>
<link>http://www.cnblogs.com/broszhu/p/11561208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/broszhu/p/11561208.html</guid>
<description>&lt;p&gt;本文参考：&lt;a href=&quot;https://www.axihe.com/tools/charles/tools/dns-spoofing.html&quot;&gt;charles DNS欺骗&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DNS欺骗/DNS Spoofing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;功能：通过将您自己的主机名指定给远程地址映射来欺骗DNS查找&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/charles_proxy_dns.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般的开发流程中，在上线之前都需要在测试环境中先行进行验证，而此时手机客户端请求的域名是不太容易改变的，可以通过设置dns方式把域名转发到测试机上，具体设置Tools-&amp;gt;DNS Spoofing Settings&lt;/p&gt;
&lt;p&gt;比如要把所有包含xxxxxx.com的域名转到10.0.0.71的服务器上，其实用修改HOST的方式是可以解决的；&lt;br/&gt;&lt;strong&gt;下面是官方文档上的介绍&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;DNS Spoofing工具使您能够通过将您自己的主机名指定给远程地址映射来欺骗DNS查找。 当请求通过Charles时，您的DNS映射将优先。&lt;/p&gt;
&lt;p&gt;在DNS更改之前，DNS Spoofing可用于测试虚拟托管网站，因为您的浏览器将会像DNS更改一样运行。&lt;/p&gt;
&lt;p&gt;DNS更改通常需要长达24小时才能生效，并且没有DNS欺骗，DNS变更生效后，网站将会变得非常困难。&lt;/p&gt;
&lt;p&gt;您可以将主机名映射到IP地址或另一个主机名，这些名称将由Charles在DNS中查找以查找其IP地址。&lt;/p&gt;
&lt;p&gt;主机名可能包含通配符。&lt;/p&gt;
&lt;p&gt;本文参考:&lt;a href=&quot;https://www.axihe.com/&quot; class=&quot;uri&quot;&gt;https://www.axihe.com/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Sep 2019 17:14:00 +0000</pubDate>
<dc:creator>叫我朱哥</dc:creator>
<og:description>本文参考： 'charles DNS欺骗' DNS欺骗/DNS Spoofing 功能：通过将您自己的主机名指定给远程地址映射来欺骗DNS查找 一般的开发流程中，在上线之前都需要在测试环境中先行进行验</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/broszhu/p/11561208.html</dc:identifier>
</item>
<item>
<title>charles 映射到本地文件/文件夹 - 叫我朱哥</title>
<link>http://www.cnblogs.com/broszhu/p/11561202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/broszhu/p/11561202.html</guid>
<description>&lt;p&gt;本文参考：&lt;a href=&quot;https://www.axihe.com/tools/charles/tools/map-local.html&quot;&gt;charles 映射到本地文件/文件夹&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地映射/Map Local Settings&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;功能：把需要请求网络的文件映射为请求本地文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/charles_proxy_tool_map_local.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地映射工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本地映射工具使您能够使用本地文件，就好比他是你访问的目标网站一部分一样,流程是，客户端获取资源文件的时候，可以向服务器正常发起资源请求，但在charles就已经被截断了，并且把当前的资源请求重定向到你设置的备注；&lt;/p&gt;
&lt;p&gt;假设你需要用到 &lt;a href=&quot;https://zhubangbang.com/ssl/blog/img/logo.png&quot; class=&quot;uri&quot;&gt;https://zhubangbang.com/ssl/blog/img/logo.png&lt;/a&gt; 这个文件；&lt;/p&gt;
&lt;p&gt;客户端会正常的向服务器发起请求，但charles把这个资截断，&lt;/p&gt;
&lt;p&gt;并返回了 C:\Users\Administrator\Desktop\charles_app\ssl\blog\img\logo.png这个文件给客户端；&lt;/p&gt;
&lt;p&gt;这样你实际看到的是C盘下面这些的文件，并不是真正的文件；&lt;/p&gt;
&lt;p&gt;根据这个原理，您可以在本地开发您的文件，然后刷新浏览器即可看到效果，本地文件的内容将返回给客户端，就像它是正常的远程响应一样。&lt;/p&gt;
&lt;p&gt;（如果不清楚原理可以看下&lt;a href=&quot;https://www.cnblogs.com/tools/charles/charles/tutorial.html&quot;&gt;charles使用方法&lt;/a&gt;中的实现原理介绍）&lt;/p&gt;
&lt;p&gt;本地映射可以大大加快开发和测试的效率，否则您将不得不将文件上传到网站来测试结果。使用Map Local，您可以在开发环境中安全地测试。&lt;/p&gt;
&lt;p&gt;如下图，我把自己博客的2张图片映射到本地的；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/charles_proxy_tool_map_local02.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本地映射后，方便线上调试，我此时可以在本机上随便修改（不借助测试机），但是并不影响真正的用户去使用；&lt;/p&gt;
&lt;p&gt;如果您是个人开发者，类似我这样本机写好后，直接发布到线上的，那么推荐你可以试试这种开发，避免了频繁发布和修改的繁琐事；等修改满意后，直接发到线上，和你测试的时候一样的效果，不会影响别的用户，虽然也没有几个人来看 – -、；&lt;br/&gt;&lt;strong&gt;动态文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;动态文件（如包含服务器端脚本的文件）不会由Map Local执行，因此如果文件中有任何脚本将脚本返回到浏览器（可能不是预期的结果）。&lt;br/&gt;如果您希望使用动态文件，就像它们是远程网站的一部分一样，请参阅“&lt;a href=&quot;https://www.cnblogs.com/tools/charles/tools/map-remote.html&quot;&gt;&lt;strong&gt;远程映射&lt;/strong&gt;&lt;/a&gt;”工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么实现的&lt;/strong&gt;&lt;br/&gt;当请求与Map Local映射匹配时，它会检查与该路径匹配的本地文件。它不包括查询字符串，如果有一个。如果所请求的文件在本地找到，则作为响应返回，就像从远程站点加载一样，因此对客户端是有欺骗性的。如果请求的文件在本地找不到，你也不用担心，请求会像平常一样由网站提供,返回给你真正的服务器数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果您正在更改测试css，swf或图片 JS，您可以将这些文件类型映射到本地网站的开发副本，以便您可以浏览具有所有开发资产的实时网站。创建从live.com/*.css到本地开发副本的根的映射，以及其他文件类型的类似映射。或者，您可以根据需要映射整个目录或单个文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/charles_proxy_tool_map_local2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面图片，我是把 x.xxx.com 全部映射到某个文件夹下的；*是通配符，表示这个域名下的所有资源；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;位置匹配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个位置匹配可能包含协议，主机，端口和路径模式，以匹配特定的URL。位置可能包括通配符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地映射&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本地映射包含一个位置匹配和本地目录，从该目录尝试提供匹配。&lt;br/&gt;使用相对路径在本地目录中搜索文件。&lt;/p&gt;
&lt;p&gt;相对路径是匹配路径部分之后剩下的请求位置的一部分;&lt;br/&gt;本地映射可以区分大小写;&lt;br/&gt;本文参考:&lt;a href=&quot;https://www.axihe.com/&quot; class=&quot;uri&quot;&gt;https://www.axihe.com/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Sep 2019 17:03:00 +0000</pubDate>
<dc:creator>叫我朱哥</dc:creator>
<og:description>本文参考： 'charles 映射到本地文件/文件夹' 本地映射/Map Local Settings 功能：把需要请求网络的文件映射为请求本地文件 本地映射工具 本地映射工具使您能够使用本地文件，就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/broszhu/p/11561202.html</dc:identifier>
</item>
<item>
<title>charles 远程映射到URL地址 - 叫我朱哥</title>
<link>http://www.cnblogs.com/broszhu/p/11561197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/broszhu/p/11561197.html</guid>
<description>&lt;p&gt;本文参考：&lt;a href=&quot;https://www.axihe.com/tools/charles/tools/map-remote.html&quot;&gt;charles 映射到远程URL地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;远程映射/Map Remote Settings&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;功能：把你要请求的地址，映射到一个远程地址；相当于把你的请求地址修改了；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;远程映射工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;远程映射工具根据配置的映射更改请求位置，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/proxy_tool_map_remote.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以便从新位置“可见的”地提供响应，就像原始请求一样。&lt;br/&gt;此映射使您能够从B站点提供A站点的全部或部分(A是原始的目标，B是你远程映射的地方)。&lt;/p&gt;
&lt;p&gt;例如，你可以做下面的操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;您可以把 xk72.com/charles/ 映射到 localhost/charlesdev/ 来为xk72.com提供一个子目录，&lt;/li&gt;
&lt;li&gt;或者把xk72.com/*.php 这种指定后缀的所有文件映射到localhost/charlesdev/。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;使用建议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果您想开发某个网站，并且已经有了开发环境的网站，并希望把刚更新的某些文件应用到线上网站，测试下效果如何，则“远程映射”将非常有用。&lt;/p&gt;
&lt;p&gt;例如，您可能把测试环境的css和images目录下的文件更新了。可以把live.com/css/映射到 dev.com/css/或把live.com/*.css这样的映射到dev.com。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;映射类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;您可以将目录映射到目录，如xk72.com/charles/ 映射到 localhost/charlesdev/&lt;/li&gt;
&lt;li&gt;您可以将文件映射到文件，如xk72.com/charles/download.php 映射到 abc.com/testing/test.html&lt;/li&gt;
&lt;li&gt;您可以将目录与文件模式映射到目录，如xk72.com/charles/*.php 到localhost/charlesdev/&lt;/li&gt;
&lt;li&gt;如果在目标映射中未指定路径，则URL的路径部分将不会更改。如果要映射到根目录，请在目标路径字段中已/结尾。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;个人觉得，其实没有必要这么做，如果想达到同样的效果也可以通过修改本地HOST的方式来实现&lt;/strong&gt;；当然如果你通过修改host的方式，可能也非常容易，不过这可能需要借助一个host管理神器  switchhosts&lt;/p&gt;
&lt;p&gt;虽然不推荐远程映射，但是非常推荐用”本地映射”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地映射&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另请参阅本地映射工具，可以把网络上的某些请求文件映射到本地文件，这样你就不用把文件丢到测试环境上去，直接刷新浏览器就可以查看最新效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;locations匹配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个位置匹配可能包含协议，主机，端口和路径模式，以匹配特定的URL。位置可能包括通配符。&lt;br/&gt;本文参考:&lt;a href=&quot;https://www.axihe.com/&quot; class=&quot;uri&quot;&gt;https://www.axihe.com/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Sep 2019 16:59:00 +0000</pubDate>
<dc:creator>叫我朱哥</dc:creator>
<og:description>本文参考： 'charles 映射到远程URL地址' 远程映射/Map Remote Settings 功能：把你要请求的地址，映射到一个远程地址；相当于把你的请求地址修改了； 远程映射工具 远程映射</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/broszhu/p/11561197.html</dc:identifier>
</item>
<item>
<title>charles 镜像工具 - 叫我朱哥</title>
<link>http://www.cnblogs.com/broszhu/p/11561193.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/broszhu/p/11561193.html</guid>
<description>&lt;p&gt;本文参考：&lt;a href=&quot;https://www.axihe.com/tools/charles/tools/mirror.html&quot;&gt;charles 镜像工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;镜像工具会在你浏览指定网站时，把抓取到的文件克隆一份，并保存在你指定的路径下；&lt;/p&gt;
&lt;p&gt;注意：如果你配置是www.aaa.com; 那么只会抓这个域名下的文件，这个域名如果引用了123.abc.com的外部资源(如前端CSS,JS等)，引用的外部资源并不会被保存；&lt;/p&gt;
&lt;p&gt;charles一般用于捕获确定的资源；如果你想把别人的整站clone下来，推荐用httrack这个工具，charles在clone网站上做的并不好，可以说是非常垃圾的战五渣。&lt;/p&gt;
&lt;p&gt;但储存目标的少量文件还是没问题的；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/image-8.png&quot; title=&quot;image&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/image-9.png&quot; title=&quot;image&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存文件的路径会与你浏览网站的目录结构相同，并且charles会为主机名创建一个根目录。文件名从URL导出并转换为适合的数据进行保存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际中的应用&lt;/strong&gt;：你可以把访问的数据缓存下来，让app在没有server的时候，通过map Local 映射到你抓取到的文件，这样app也能继续跑;&lt;/p&gt;
&lt;p&gt;你也可以用镜像工具保存网站内容后，通过map Local 映射到你抓取到的文件；通过修改文件，达到本地的线上调试的功能(你调试的内容因为用的资源都是本机的，所以并不会真正的影响到线上文件的)；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查询字符串包含在文件名中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果收到相同URL的两个响应，则后面一个文件会覆盖前面的同名文件，因此您保存是镜像中的最新数据。&lt;br/&gt;镜像工具在数据通过Charles时就开始储存了，因此不受模拟慢速设置的限制影响(慢网速只是对你本地的前端看到效果有影响，但是真正速度还是实际速度)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所选HOST&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该工具可以针对每个请求启用，也可以仅对选定的host启用。&lt;br/&gt;当然，如果你设置host的时候，所写的资源，路径等都可以用模式匹配。星号”*”和”?”都是可以用的;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;替代方法（右键save）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在使用“镜像”工具之后，您也可以右键单击charles目录中的一个节点（文件/文件夹），在捕获记录后将所有抓取结果保存本地，这会配置镜像更具更加简单，而且避免一些垃圾文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.axihe.com/img/charles/image-10.png&quot; title=&quot;image&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;唯一的区别就是镜像工具不受录制设置中设置的录制限制，而后来的保存响应是有限的，可能在模拟慢速的时候存在丢失数据的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可能会遇到的坑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果镜像工具启用了，它将导致任何压缩或编码的响应被解码。&lt;/p&gt;
&lt;p&gt;因此，如果服务器提供了一份压缩后的响应，那么在被传递给客户端之前，它将被Charles解压缩（charles相当于是客户端和服务端之间的一个过滤器,任何请求和响应都会经过charles）；&lt;br/&gt;即时返回了一份解压缩后的文件，一般也不会有任何影响的；&lt;br/&gt;但如果您已经构建了自己的客户端，或者你本身就是想要那种压缩的响应，那么此时你是得不到的；&lt;br/&gt;本文参考:&lt;a href=&quot;https://www.axihe.com/&quot; class=&quot;uri&quot;&gt;https://www.axihe.com/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Sep 2019 16:55:00 +0000</pubDate>
<dc:creator>叫我朱哥</dc:creator>
<og:description>本文参考： 'charles 镜像工具' 镜像工具会在你浏览指定网站时，把抓取到的文件克隆一份，并保存在你指定的路径下； 注意：如果你配置是www.aaa.com; 那么只会抓这个域名下的文件，这个域</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/broszhu/p/11561193.html</dc:identifier>
</item>
<item>
<title>以商品超卖为例讲解Redis分布式锁 - 风尘博客</title>
<link>http://www.cnblogs.com/vandusty/p/11561160.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vandusty/p/11561160.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本案例主要讲解&lt;code&gt;Redis&lt;/code&gt;实现分布式锁的两种实现方式：&lt;code&gt;Jedis&lt;/code&gt;实现、&lt;code&gt;Redisson&lt;/code&gt;实现。网上关于这方面讲解太多了，Van自认为文笔没他们好，还是用示例代码说明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;该方案只考虑&lt;code&gt;Redis&lt;/code&gt;单机部署的场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;加锁&quot;&gt;1.1 加锁&lt;/h2&gt;
&lt;h3 id=&quot;原理&quot;&gt;1.1.1 原理&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;jedis.set(String key, String value, String nxxx, String expx, int time)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;key&lt;/code&gt;: 使用&lt;code&gt;key&lt;/code&gt;来当锁，因为&lt;code&gt;key&lt;/code&gt;是唯一的;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt;: 我传的是唯一值（&lt;code&gt;UUID&lt;/code&gt;），很多童鞋可能不明白，有&lt;code&gt;key&lt;/code&gt;作为锁不就够了吗，为什么还要用到&lt;code&gt;value&lt;/code&gt;？原因是分布式锁要满足&lt;strong&gt;解铃还须系铃人&lt;/strong&gt;：通过给&lt;code&gt;value&lt;/code&gt;赋值为&lt;code&gt;requestId&lt;/code&gt;，我们就知道这把锁是哪个请求加的了，在解锁的时候要验证&lt;code&gt;value&lt;/code&gt;值，不能误解锁;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nxxx&lt;/code&gt;: 这个参数我填的是&lt;code&gt;NX&lt;/code&gt;，意思是&lt;code&gt;SET IF NOT EXIST&lt;/code&gt;，即当&lt;code&gt;key&lt;/code&gt;不存在时，我们进行&lt;code&gt;set&lt;/code&gt;操作；若&lt;code&gt;key&lt;/code&gt;已经存在，则不做任何操作；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expx&lt;/code&gt;: 这个参数我传的是&lt;code&gt;PX&lt;/code&gt;，意思是我们要给这个&lt;code&gt;key&lt;/code&gt;加一个过期的设置，具体时间由第五个参数决定;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;time&lt;/code&gt;: 与第四个参数相呼应，代表&lt;code&gt;key&lt;/code&gt;的过期时间。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;小结&quot;&gt;1.1.2 小结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;set()&lt;/code&gt;加入了&lt;code&gt;NX&lt;/code&gt;参数，可以保证如果已有&lt;code&gt;key&lt;/code&gt;存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性;&lt;/li&gt;
&lt;li&gt;其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即&lt;code&gt;key&lt;/code&gt;被删除），不会发生死锁;&lt;/li&gt;
&lt;li&gt;最后，因为我们将&lt;code&gt;value&lt;/code&gt;赋值为&lt;code&gt;requestId&lt;/code&gt;，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;释放锁&quot;&gt;1.2 释放锁&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;释放锁时需要验证&lt;code&gt;value&lt;/code&gt;值，也就是说我们在获取锁的时候需要设置一个&lt;code&gt;value&lt;/code&gt;，不能直接用&lt;code&gt;del key&lt;/code&gt;这种粗暴的方式，因为直接&lt;code&gt;del key&lt;/code&gt;任何客户端都可以进行解锁了，所以解锁时，我们需要判断锁是否是自己的(基于&lt;code&gt;value&lt;/code&gt;值来判断)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;首先,写了一个简单&lt;code&gt;Lua&lt;/code&gt;脚本代码,作用是：获取锁对应的&lt;code&gt;value&lt;/code&gt;值，检查是否与&lt;code&gt;requestId&lt;/code&gt;相等，如果相等则删除锁（解锁）;&lt;/li&gt;
&lt;li&gt;然后,将&lt;code&gt;Lua&lt;/code&gt;代码传到&lt;code&gt;jedis.eval()&lt;/code&gt;方法里，并使参数&lt;code&gt;KEYS[1]&lt;/code&gt;赋值为&lt;code&gt;lockKey&lt;/code&gt;，&lt;code&gt;ARGV[1]&lt;/code&gt;赋值为&lt;code&gt;requestId&lt;/code&gt;。&lt;code&gt;eval()&lt;/code&gt;方法是将&lt;code&gt;Lua&lt;/code&gt;代码交给Redis服务端执行。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;案例家庭多人领取奖励的场景&quot;&gt;1.3 案例（家庭多人领取奖励的场景）&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里放出的是关键代码，详细可运行的代码可至文末地址下载示例代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;准备&quot;&gt;1.3.1 准备&lt;/h3&gt;
&lt;p&gt;该案例模拟家庭内多人通过领取一个奖励，但是只能有一个人能领取成功，不能重复领取（之前做过奖励模块的需求）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;family_reward_record&lt;/code&gt;表&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `family_reward_record` (
  `id` bigint(10) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `family_id` bigint(20) NOT NULL DEFAULT '0' COMMENT '商品名称',
  `reward_type` int(10) NOT NULL DEFAULT '1' COMMENT '商品库存数量',
  `state` int(1) NOT NULL DEFAULT '0' COMMENT '商品状态',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '入库时间',
  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=270 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='家庭领取奖励表（家庭内多人只能有一个人能领取成功，不能重复领取）';&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;application.yml&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;spring:
  datasource:
    url: jdbc:mysql://47.98.178.84:3306/dev
    username: dev
    password: password
    driver-class-name: com.mysql.jdbc.Driver
  redis:
    host: 47.98.178.84
    port: 6379
    password: password
    timeout: 2000
# mybatis
mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: cn.van.mybatis.demo.entity&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;核心实现&quot;&gt;1.3.2 核心实现&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Jedis 单机配置类 - &lt;code&gt;RedisConfig.java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class RedisConfig extends CachingConfigurerSupport {
    @Value(&quot;${spring.redis.host}&quot;)
    private String host;
    @Value(&quot;${spring.redis.port}&quot;)
    private int port;
    @Value(&quot;${spring.redis.password}&quot;)
    private String password;
    @Value(&quot;${spring.redis.timeout}&quot;)
    private int timeout;

    @Bean
    public JedisPool redisPoolFactory() {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        if (StringUtils.isEmpty(password)) {
            return new JedisPool(jedisPoolConfig, host, port, timeout);
        }
        return new JedisPool(jedisPoolConfig, host, port, timeout, password);
    }

    @Bean(name = &quot;redisTemplate&quot;)
    public RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate = new RedisTemplate();
        redisTemplate.setConnectionFactory(redisConnectionFactory);

        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, Visibility.ANY);
        objectMapper.enableDefaultTyping(DefaultTyping.NON_FINAL);

        Jackson2JsonRedisSerializer&amp;lt;Object&amp;gt; jsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        jsonRedisSerializer.setObjectMapper(objectMapper);
        redisTemplate.setDefaultSerializer(jsonRedisSerializer);

        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;分布式锁工具类 - &lt;code&gt;RedisDistributedLock.java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class RedisDistributedLock {
    /**
     * 成功获取锁标示
     */
    private static final String LOCK_SUCCESS = &quot;OK&quot;;
    /**
     * 成功解锁标示
     */
    private static final Long RELEASE_SUCCESS = 1L;

    @Autowired
    private JedisPool jedisPool;

    /**
     * redis 数据存储过期时间
     */
    final int expireTime = 500;

    /**
     * 尝试获取分布式锁
     * @param lockKey 锁
     * @param lockValue 请求标识
     * @return 是否获取成功
     */
    public boolean tryLock(String lockKey, String lockValue) {
        Jedis jedis = null;
        try{
            jedis = jedisPool.getResource();
            String result = jedis.set(lockKey, lockValue, &quot;NX&quot;, &quot;PX&quot;, expireTime);
            if (LOCK_SUCCESS.equals(result)) {
                return true;
            }
        } finally {
            if(jedis != null){
                jedis.close();
            }
        }
        return false;
    }

    /**
     * 释放分布式锁
     * @param lockKey 锁
     * @param lockValue 请求标识
     * @return 是否释放成功
     */
    public boolean unLock(String lockKey, String lockValue) {
        Jedis jedis = null;
        try {
            jedis = jedisPool.getResource();
            String script = &quot;if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end&quot;;
            Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(lockValue));
            if (RELEASE_SUCCESS.equals(result)) {
                return true;
            }
        } finally {
            if(jedis != null){
                jedis.close();
            }
        }
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;不加锁时：模拟 &lt;code&gt;familyId = 1&lt;/code&gt; 的家庭同时领取奖励&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public HttpResult receiveAward() {
    Long familyId = 1L;
    Map&amp;lt;String, Object&amp;gt; params = new HashMap&amp;lt;String, Object&amp;gt;(16);
    params.put(&quot;familyId&quot;, familyId);
    params.put(&quot;rewardType&quot;, 1);
    int count = familyRewardRecordMapper.selectCountByFamilyIdAndRewardType(params);
    if (count == 0) {
        FamilyRewardRecordDO recordDO = new FamilyRewardRecordDO(familyId,1,0,LocalDateTime.now());
        int num = familyRewardRecordMapper.insert(recordDO);
        if (num == 1) {
            return HttpResult.success();
        }
        return HttpResult.failure(-1, &quot;记录插入失败&quot;);
    }
    return HttpResult.success(&quot;该记录已存在&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;加锁的实现：模拟 &lt;code&gt;familyId = 2&lt;/code&gt; 的家庭同时领取奖励&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public HttpResult receiveAwardLock() {
    Long familyId = 2L;
    Map&amp;lt;String, Object&amp;gt; params = new HashMap&amp;lt;String, Object&amp;gt;(16);
    params.put(&quot;familyId&quot;, familyId);
    params.put(&quot;rewardType&quot;, 1);
    int count = familyRewardRecordMapper.selectCountByFamilyIdAndRewardType(params);
    if (count == 0) {
        // 没有记录则创建领取记录
        FamilyRewardRecordDO recordDO = new FamilyRewardRecordDO(familyId,1,0,LocalDateTime.now());
        // 分布式锁的key(familyId + rewardType)
        String lockKey = recordDO.getFamilyId() + &quot;_&quot; + recordDO.getRewardType();
        // 分布式锁的value(唯一值)
        String lockValue = createUUID();
        boolean lockStatus = redisLock.tryLock(lockKey, lockValue);
        // 锁被占用
        if (!lockStatus) {
            log.info(&quot;锁已经占用了&quot;);
            return HttpResult.failure(-1,&quot;失败&quot;);
        }
        // 不管多个请求，加锁之后，只会有一个请求能拿到锁，进行插入操作
        log.info(&quot;拿到了锁，当前时刻:{}&quot;,System.currentTimeMillis());

        int num = familyRewardRecordMapper.insert(recordDO);
        if (num != 1) {
            log.info(&quot;数据插入失败！&quot;);
            return HttpResult.failure(-1, &quot;数据插入失败！&quot;);
        }
        log.info(&quot;数据插入成功！准备解锁...&quot;);
        boolean unLockState = redisLock.unLock(lockKey,lockValue);
        if (!unLockState) {
            log.info(&quot;解锁失败！&quot;);
            return HttpResult.failure(-1, &quot;解锁失败！&quot;);
        }
        log.info(&quot;解锁成功！&quot;);
        return HttpResult.success();
    }
    log.info(&quot;该记录已存在&quot;);
    return HttpResult.success(&quot;该记录已存在&quot;);
}
private String createUUID() {
    UUID uuid = UUID.randomUUID();
    String str = uuid.toString().replace(&quot;-&quot;, &quot;_&quot;);
    return str;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;1.3.3 测试&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我采用的是&lt;code&gt;JMeter&lt;/code&gt;工具进行测试，加锁和不加锁的情况都设置成：五次并发请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;不加锁&quot;&gt;1.3.3.1 不加锁&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 家庭成员领取奖励（不加锁）
 * @return
 */
@PostMapping(&quot;/receiveAward&quot;)
public HttpResult receiveAward() {
    return redisLockService.receiveAward();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1768363/201909/1768363-20190921003122718-538370650.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;加锁-1&quot;&gt;1.3.3.2 加锁&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 家庭成员领取奖励（加锁）
 * @return
 */
@PostMapping(&quot;/receiveAwardLock&quot;)
public HttpResult receiveAwardLock() {
    return redisLockService.receiveAwardLock();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1768363/201909/1768363-20190921003139539-506781512.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过对比，说明分布式锁起作用了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;小结-1&quot;&gt;1.4 小结&lt;/h2&gt;
&lt;p&gt;我上家使用的就是这种加锁方式，看上去很OK，实际上在&lt;code&gt;Redis&lt;/code&gt;集群的时候会出现问题，比如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt;客户端在&lt;code&gt;Redis&lt;/code&gt;的&lt;code&gt;master&lt;/code&gt;节点上拿到了锁，但是这个加锁的&lt;code&gt;key&lt;/code&gt;还没有同步到&lt;code&gt;slave&lt;/code&gt;节点，&lt;code&gt;master&lt;/code&gt;故障，发生故障转移，一个&lt;code&gt;slave&lt;/code&gt;节点升级为&lt;code&gt;master&lt;/code&gt;节点，&lt;code&gt;B&lt;/code&gt;客户端也可以获取同个&lt;code&gt;key&lt;/code&gt;的锁，但客户端&lt;code&gt;A&lt;/code&gt;也已经拿到锁了，这就导致多个客户端都拿到锁。&lt;/p&gt;
&lt;p&gt;正因为如此，&lt;code&gt;Redis&lt;/code&gt;作者&lt;code&gt;antirez&lt;/code&gt;基于分布式环境下提出了一种更高级的分布式锁的实现方式：&lt;code&gt;Redlock&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;原理-1&quot;&gt;2.1 原理&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;antirez&lt;/code&gt;提出的&lt;code&gt;Redlock&lt;/code&gt;算法大概是这样的：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Redis&lt;/code&gt;的分布式环境中，我们假设有&lt;code&gt;N&lt;/code&gt;个&lt;code&gt;Redis master&lt;/code&gt;。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。我们确保将在&lt;code&gt;N&lt;/code&gt;个实例上使用与在&lt;code&gt;Redis&lt;/code&gt;单实例下相同方法获取和释放锁。现在我们假设有&lt;code&gt;5&lt;/code&gt;个&lt;code&gt;Redis master&lt;/code&gt;节点，同时我们需要在&lt;code&gt;5&lt;/code&gt;台服务器上面运行这些&lt;code&gt;Redis&lt;/code&gt;实例，这样保证他们不会同时都宕掉。&lt;/p&gt;
&lt;h3 id=&quot;加锁-2&quot;&gt;2.1.1 加锁&lt;/h3&gt;
&lt;p&gt;为了取到锁，客户端应该执行以下操作(&lt;code&gt;RedLock&lt;/code&gt;算法加锁步骤):&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取当前&lt;code&gt;Unix&lt;/code&gt;时间，以毫秒为单位;&lt;/li&gt;
&lt;li&gt;依次尝试从&lt;code&gt;5&lt;/code&gt;个实例，使用相同的&lt;code&gt;key&lt;/code&gt;和具有唯一性的&lt;code&gt;value&lt;/code&gt;（例如&lt;code&gt;UUID&lt;/code&gt;）获取锁。当向&lt;code&gt;Redis&lt;/code&gt;请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为&lt;code&gt;10&lt;/code&gt;秒，则超时时间应该在&lt;code&gt;5-50&lt;/code&gt;毫秒之间。这样可以避免服务器端&lt;code&gt;Redis&lt;/code&gt;已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个&lt;code&gt;Redis&lt;/code&gt;实例请求获取锁;&lt;/li&gt;
&lt;li&gt;客户端使用当前时间减去开始获取锁时间（步骤&lt;code&gt;1&lt;/code&gt;记录的时间）就得到获取锁使用的时间。当且仅当从大多数（&lt;code&gt;N/2+1&lt;/code&gt;，这里是&lt;code&gt;3&lt;/code&gt;个节点）的&lt;code&gt;Redis&lt;/code&gt;节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功;&lt;/li&gt;
&lt;li&gt;如果取到了锁，&lt;code&gt;key&lt;/code&gt;的真正有效时间等于有效时间减去获取锁所使用的时间（步骤&lt;code&gt;3&lt;/code&gt;计算的结果）。&lt;/li&gt;
&lt;li&gt;如果因为某些原因，获取锁失败（没有在至少&lt;code&gt;N/2+1&lt;/code&gt;个&lt;code&gt;Redis&lt;/code&gt;实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的&lt;code&gt;Redis&lt;/code&gt;实例上进行解锁（即便某些&lt;code&gt;Redis&lt;/code&gt;实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;解锁&quot;&gt;2.1.2 解锁&lt;/h3&gt;
&lt;p&gt;向所有的&lt;code&gt;Redis&lt;/code&gt;实例发送释放锁命令即可，不用关心之前有没有从&lt;code&gt;Redis&lt;/code&gt;实例成功获取到锁.&lt;/p&gt;
&lt;h2 id=&quot;案例商品超卖为例&quot;&gt;2.2 案例（商品超卖为例）&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这部分以最常见的案例：抢购时的商品超卖（库存数减少为负数）为例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;准备-1&quot;&gt;2.2.1 准备&lt;/h3&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `good` (
                      `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',
                      `good_name` varchar(255) NOT NULL COMMENT '商品名称',
                      `good_counts` int(255) NOT NULL COMMENT '商品库存',
                      `create_time` timestamp NOT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
                      PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT='商品表';
-- 插入两条测试数据
INSERT INTO `good` VALUES (1, '哇哈哈', 5, '2019-09-20 17:39:04');
INSERT INTO `good` VALUES (2, '卫龙', 5, '2019-09-20 17:39:06');&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;配置文件跟上面一样&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;核心实现-1&quot;&gt;2.2.2 核心实现&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Redisson&lt;/code&gt; 配置类 &lt;code&gt;RedissonConfig.java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;2.5&quot;&gt;
&lt;p&gt;我这里配置的是单机，更多配置详见&lt;a href=&quot;https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95&quot;&gt;https://github.com/redisson/redisson/wiki/配置&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class RedissonConfig {

    @Value(&quot;${spring.redis.host}&quot;)
    private String host;
    @Value(&quot;${spring.redis.port}&quot;)
    private String port;
    @Value(&quot;${spring.redis.password}&quot;)
    private String password;

    /**
     * RedissonClient,单机模式
     * @return
     * @throws IOException
     */
    @Bean
    public RedissonClient redissonSentinel() {
        //支持单机，主从，哨兵，集群等模式,此为单机模式
        
        Config config = new Config();
        config.useSingleServer()
                .setAddress(&quot;redis://&quot; + host + &quot;:&quot; + port)
                .setPassword(password);
        return Redisson.create(config);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;不加锁时&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public HttpResult saleGoods(){
    // 以指定goodId = 1：哇哈哈为例
    Long goodId = 1L;
    GoodDO goodDO = goodMapper.selectByPrimaryKey(goodId);
    int goodStock = goodDO.getGoodCounts();
    if (goodStock &amp;gt;= 1) {
        goodMapper.saleOneGood(goodId);
    }
    return HttpResult.success();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public HttpResult saleGoodsLock(){
    // 以指定goodId = 2：卫龙为例
    Long goodId = 2L;
    GoodDO goodDO = goodMapper.selectByPrimaryKey(goodId);
    int goodStock = goodDO.getGoodCounts();
    String key = goodDO.getGoodName();
    log.info(&quot;{}剩余总库存,{}件&quot;, key,goodStock);
    // 将商品的实时库存放在redis 中，便于读取
    stringRedisTemplate.opsForValue().set(key, Integer.toString(goodStock));
    // redisson 锁 的key
    String lockKey = goodDO.getId() +&quot;_&quot; + key;
    RLock lock = redissonClient.getLock(lockKey);
    // 设置60秒自动释放锁  （默认是30秒自动过期）
    lock.lock(60, TimeUnit.SECONDS);
    // 此步开始，串行销售
    int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(key));
    // 如果缓存中库存量大于1，可以继续销售
    if (stock &amp;gt;= 1) {
        goodDO.setGoodCounts(stock - 1);
        int num = goodMapper.saleOneGood(goodId);
        if (num == 1) {
            // 减库存成功，将缓存同步
            stringRedisTemplate.opsForValue().set(key,Integer.toString((stock-1)));
        }
        log.info(&quot;{},当前库存,{}件&quot;, key,stock);
    }
    lock.unlock();
    return HttpResult.success();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试-1&quot;&gt;2.3 测试&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;采用的是&lt;code&gt;JMeter&lt;/code&gt;工具进行测试，初始化的时候两个商品的库存设置都是：&lt;code&gt;5&lt;/code&gt;;所以这里加锁和不加锁的情况都设置成：十次并发请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;不加锁-1&quot;&gt;2.3.1 不加锁&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 售卖商品(不加锁)
 * @return
 */
@PostMapping(&quot;/saleGoods&quot;)
public HttpResult saleGoods() {
    return redisLockService.saleGoods();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1768363/201909/1768363-20190921003201368-449269146.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;加锁-3&quot;&gt;2.3.2 加锁&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 售卖商品(加锁)
 * @return
 */
@PostMapping(&quot;/saleGoodsLock&quot;)
public HttpResult saleGoodsLock() {
    return redisLockService.saleGoodsLock();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1768363/201909/1768363-20190921003215809-937525192.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;小结-2&quot;&gt;2.3.3 小结&lt;/h3&gt;
&lt;p&gt;通过&lt;code&gt;2.3.1&lt;/code&gt;和&lt;code&gt;2.3.2&lt;/code&gt;的结果对比很明显：前者出现了超卖情况，库存数卖到了&lt;code&gt;-5&lt;/code&gt;，这是决不允许的；而加了锁的情况后，库存只会减少到&lt;code&gt;0&lt;/code&gt;，便不再销售。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;再次说明：以上代码不全，如需尝试，请前往Van 的 Github 查看完整示例代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一种基于&lt;code&gt;Redis&lt;/code&gt;的分布式锁并不适合用于生产环境。&lt;code&gt;Redisson&lt;/code&gt; 可用于生产环境。当然，分布式的选择还有&lt;code&gt;Zookeeper&lt;/code&gt;的选项，Van后续会整理出来供大家参考。&lt;/p&gt;
&lt;h2 id=&quot;示例源码地址&quot;&gt;3.1 示例源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vanDusty/SpringBoot-Home/tree/master/springboot-demo-lock/redis-lock&quot; class=&quot;uri&quot;&gt;https://github.com/vanDusty/SpringBoot-Home/tree/master/springboot-demo-lock/redis-lock&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;技术交流&quot;&gt;3.2 技术交流&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.dustyblog.cn/&quot;&gt;风尘博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/user/5d5ea68e6fb9a06afa328f56/posts&quot;&gt;风尘博客-掘金&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_42036952&quot;&gt;风尘博客-CSDN&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 20 Sep 2019 16:34:00 +0000</pubDate>
<dc:creator>风尘博客</dc:creator>
<og:description>本案例主要讲解 实现分布式锁的两种实现方式： 实现、 实现。网上关于这方面讲解太多了，Van自认为文笔没他们好，还是用示例代码说明。 一、 实现 该方案只考虑 单机部署的场景 1.1 加锁 1.1.1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vandusty/p/11561160.html</dc:identifier>
</item>
</channel>
</rss>