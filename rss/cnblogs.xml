<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>神经网络(一)神经网络基础知识 - ChetTlittlebread</title>
<link>http://www.cnblogs.com/ChetTlittilebread/p/10296752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ChetTlittilebread/p/10296752.html</guid>
<description>&lt;h3 id=&quot;人工神经元模型&quot;&gt;1.人工神经元模型&lt;/h3&gt;
&lt;h4 id=&quot;神经元信息处理过程的简化概况&quot;&gt;神经元信息处理过程的简化概况：&lt;/h4&gt;
&lt;p&gt;1.每个神经元都是一个多输入单输出的信息处理单元&lt;br/&gt;2.神经元输入分为兴奋性输入和抑制性输入两种类型(即有正负)&lt;br/&gt;3.神经元具有空间整合性和阈值特性&lt;br/&gt;4.神经元输入与输出间有固定的时滞，主要取决于突触延搁&lt;br/&gt;5.忽略时间整合作用和不应期&lt;br/&gt;6.神经元本身是非时变的即突触时延和突触强度是常数&lt;/p&gt;
&lt;h4 id=&quot;神经元的数学模型&quot;&gt;神经元的数学模型&lt;/h4&gt;
&lt;p&gt;令&lt;span class=&quot;math inline&quot;&gt;\(x_i(t)\)&lt;/span&gt;表示t时刻神经元j接受的来自神经元i的输入信息，&lt;span class=&quot;math inline&quot;&gt;\(o_j(t)\)&lt;/span&gt;表示t时刻神经元j的输出信息，则&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(o_j(t)=f\{[\sum_{i+1}^{n}w_{ij}x_i(t-\tau_{ij})]-T_j\}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\tau_{ij}\)&lt;/span&gt;输入输出间的突触时延&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(T_j\)&lt;/span&gt;神经元j的阈值&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(w_{ij}\)&lt;/span&gt;神经元i到j的突触连接系数或权重值&lt;/p&gt;
&lt;p&gt;输入总和常常称为神经元在t时刻的净输入&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(net'_j(t)=\sum_{i=1}^{n}w_{ij}x_{i}(t)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(net'_j(t)=W_j^TX\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(W_j=(w_{1j},w_{2j},...,w_{nj})^T\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(X=(x_1,x_2,...,x_n)^T\)&lt;/span&gt;&lt;br/&gt;令&lt;span class=&quot;math inline&quot;&gt;\(x_0=-1,w_{0j}=T_j\)&lt;/span&gt;有&lt;span class=&quot;math inline&quot;&gt;\(net'_j-T_j=net_j=\sum_{i=0}^nw_{ij}x{i}=W^T_jX\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;综上，神经元模型可简化为&lt;span class=&quot;math inline&quot;&gt;\(o_j=f(net_j)=f(W_j^TX)\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;人工神经网络模型&quot;&gt;2.人工神经网络模型&lt;/h3&gt;
&lt;h4 id=&quot;hebb学习&quot;&gt;1.Hebb学习&lt;/h4&gt;
&lt;p&gt;是一种&lt;strong&gt;纯前馈&lt;/strong&gt;、&lt;strong&gt;无监督学习&lt;/strong&gt;&lt;br/&gt;学习信号简单地等于神经元的输出&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(r=f(W_j^TX)\)&lt;/span&gt;&lt;br/&gt;权向量调整公式&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_j=\eta f(W_j^TX)X\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta w_{ij}=\eta f(W_j^TX)X=\eta o_jx_i\)&lt;/span&gt;&lt;br/&gt;Hebb学习规则要求预先设置权饱和值 防止输入输出无约束增长&lt;br/&gt;此外，还要求权值初始化对&lt;span class=&quot;math inline&quot;&gt;\(W_j(0)\)&lt;/span&gt;赋予零附近的小随机数&lt;/p&gt;
&lt;p&gt;例如T=0，&lt;span class=&quot;math inline&quot;&gt;\(\eta=1,X^1=(1,-2,1.5,0)^T,X^2=(1,-0.5,-2,-1.5)^T,X^3=(0,1,-1,1.5)^T,W(0)=(1,-1,0,0.5)\)&lt;/span&gt;转移函数为sgn函数&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import torch as t

def sgn(x):
    if x[0]&amp;gt;=0: return 1
    else: return -1

w_0 = t.Tensor([[1,-1,0,0.5]])
eta = 1
x = []
x.append(t.Tensor([[1],[-2],[1.5],[0]]))
x.append(t.Tensor([[1],[-0.5],[-2],[-1.5]]))
x.append(t.Tensor([[0],[1],[-1],[1.5]]))

for i in x:
    net = w_0.mm(i)
    print(net)
    w_0 = w_0+eta*sgn(net)*i.t()
    print(w_0)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;tensor([[3.]])
tensor([[ 2.0000, -3.0000,  1.5000,  0.5000]])
tensor([[-0.2500]])
tensor([[ 1.0000, -2.5000,  3.5000,  2.0000]])
tensor([[-3.]])
tensor([[ 1.0000, -3.5000,  4.5000,  0.5000]])&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;percepton学习规则&quot;&gt;2.Percepton学习规则&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(r=d_j-o_j\)&lt;/span&gt;&lt;br/&gt;$o_j=f(W^T_jX)=sgn(W^T_jX)= \begin {cases} 1 &amp;amp; W^T_jX\ge0 \ -1 &amp;amp; W^T_jX&amp;lt;0 \end {cases} $&lt;br/&gt;权值调整公式为&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_j=\eta [d_j-sgn(W_j^TX)]X\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta w_{ij}=\eta [d_j-sgn(W_j^TX)]x_i\)&lt;/span&gt;&lt;br/&gt;在有误差的情况下由于&lt;span class=&quot;math inline&quot;&gt;\(d_j,sgn\)&lt;/span&gt;取值为{-1,1}，权值调整公式可简化为&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_j=\pm 2 \eta X\)&lt;/span&gt;&lt;br/&gt;只适用于二进制神经元 是一种有监督学习&lt;/p&gt;
&lt;h4 id=&quot;delta学习规则&quot;&gt;3.&lt;span class=&quot;math inline&quot;&gt;\(\delta\)&lt;/span&gt;学习规则&lt;/h4&gt;
&lt;p&gt;学习信号规定为&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(r=[d_j-f(W_j^TX)]f'(W_j^TX)=(d_j-o_j)f'(net_j)\)&lt;/span&gt;&lt;br/&gt;要求转移函数可导，只适用于有监督学习中定义的连续转移函数&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_j=\eta (d_j-o_j)f'(net_j)X\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta w_{ij}=\eta (d_j-o_j)f'(net_j)x_i\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如&lt;span class=&quot;math inline&quot;&gt;\(w_0=T,x_0=-1,\eta = 0.1,X^1=(-1,1,-2,0)^T,X^2=(-1,0,1.5,-0.5)^T,X^3=(-1,-1,1,0.5)^T,d^1=-1,d^2=-1,d^3=1,W(0)=(0.5,1,-1,0)^T\)&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import torch as t
import math

def f(x):
    return (1-math.e**(-x))/(1+math.e**(-x))

def f_d(x):
    return (1-f(x)**2)/2

w_0 = t.Tensor([[0.5,1,-1,0]])
eta = 0.1
x = []
x.append(t.Tensor([[-1],[1],[-2],[0]]))
x.append(t.Tensor([[-1],[0],[1.5],[-0.5]]))
x.append(t.Tensor([[-1],[-1],[1],[0.5]]))

d = []
d.append(-1)
d.append(-1)
d.append(1)

for i,j in zip(x,d):
    net = w_0.mm(i)
    o=f(net)
    w_0=w_0+eta*(j-o)*f_d(net)*i.t()
    print(w_0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;tensor([[ 0.5259,  0.9741, -0.9482,  0.0000]])
tensor([[ 0.5314,  0.9741, -0.9563,  0.0027]])
tensor([[ 0.5046,  0.9474, -0.9296,  0.0161]])&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;lms学习规则&quot;&gt;4.LMS学习规则&lt;/h4&gt;
&lt;p&gt;学习信号定义为&lt;span class=&quot;math inline&quot;&gt;\(r=d_j-W_j^TX\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_j=\eta (d_j-W_j^TX)X\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta w_{ij}=\eta (d_j-W_j^TX)x_j\)&lt;/span&gt;&lt;br/&gt;可以看做&lt;span class=&quot;math inline&quot;&gt;\(\delta\)&lt;/span&gt;学习的特例&lt;br/&gt;有监督学习 权值可初始化为任意值&lt;/p&gt;
&lt;h4 id=&quot;correlation学习规则&quot;&gt;5.Correlation学习规则&lt;/h4&gt;
&lt;p&gt;学习信号为&lt;span class=&quot;math inline&quot;&gt;\(r=d_j\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_j = \eta d_jX\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta w_{ij} = \eta d_j x_i\)&lt;/span&gt;&lt;br/&gt;有监督学习 要求权值初始化为0&lt;/p&gt;
&lt;h4 id=&quot;winner-take-all学习规则&quot;&gt;6.Winner-Take-All学习规则&lt;/h4&gt;
&lt;p&gt;只有响应最大的神经元有权利调整权向量&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(W_j^{T_*}X=max(W_i^TX)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_{j^*}=\alpha (X-W_{j^*})\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha \in (0,1]\)&lt;/span&gt;为一个小的学习常数&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;3.小结&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/ChetTlittilebread/1387300/o_1.png&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 15:50:00 +0000</pubDate>
<dc:creator>ChetTlittlebread</dc:creator>
<og:description>1.人工神经元模型 神经元信息处理过程的简化概况： 1.每个神经元都是一个多输入单输出的信息处理单元 2.神经元输入分为兴奋性输入和抑制性输入两种类型(即有正负) 3.神经元具有空间整合性和阈值特性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ChetTlittilebread/p/10296752.html</dc:identifier>
</item>
<item>
<title>【原创】《从0开始学RocketMQ》—单机搭建 - 琳茹的技术轮子</title>
<link>http://www.cnblogs.com/mengyi/p/10296620.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengyi/p/10296620.html</guid>
<description>&lt;h3 id=&quot;htoc&quot;&gt;内容目录&lt;/h3&gt;
&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;1. RocketMQ是什么？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;2. 下载并解压&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;3. 启动NameServer&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;4. 启动 Broker&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;5. 关闭消息队列&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;toc&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;h1rocketmq&quot;&gt;1. RocketMQ是什么？&lt;/h3&gt;
&lt;p&gt;RocketMQ是一种消息队列。何为消息队列？即数据结构中一种“先进先出”的数据结构。在微服务中，分布式消息队列可以解决什么问题？应用解耦、流量削峰、消息分发、保证最终一致性、方便动态扩容等。&lt;/p&gt;
&lt;p&gt;RocketMQ中不可不知的四个角色：Producer（消息生产者）、Consumer（消息消费者）、Broker（消息暂存者）、NameServer（消息协调者）。由这四个角色的作用可知，启动 RocketMQ 时，应该先启动 NameServer，然后再启动 Broker，后续需要发送消息就用 Producer，需要接收消息就用 Consumer。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;h2&quot;&gt;2. 下载并解压&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
cd /usr/&lt;span&gt;local
wget &lt;/span&gt;-c http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.shu.edu.cn/apache/rocketmq/4.3.2/rocketmq-all-4.3.2-bin-release.zip&lt;/span&gt;
unzip rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release.zip -&lt;span&gt;d .
cd rocketmq&lt;/span&gt;-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-&lt;span&gt;release
ls
[root@&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-&lt;span&gt;release]# ls
benchmark  bin  conf  lib  LICENSE  NOTICE  README.md&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;h3nameserver&quot;&gt;3. 启动NameServer&lt;/h3&gt;
&lt;p&gt;启动&lt;code&gt;NameServer：nohup sh bin/mqnamesrv &amp;amp;&lt;/code&gt;，然而发现不能正常启动，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup sh bin/mqnamesrv &amp;amp;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;32673&lt;/span&gt;&lt;span&gt;
[root@&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup: ignoring input and appending output to ‘nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;’

[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]+  Exit &lt;span&gt;1&lt;/span&gt;                  nohup sh bin/mqnamesrv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看nohup.out：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# cat nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt; 
ERROR: Please &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; the JAVA_HOME variable &lt;span&gt;in&lt;/span&gt; your environment, We need java(x64)! !!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可是，本机明明已经安装jdk并且已经配置了 JAVA_HOME 环境变量呀：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# java -&lt;span&gt;version
java version &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.8.0_171&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
Java(TM) SE Runtime Environment (build &lt;/span&gt;&lt;span&gt;1.8&lt;/span&gt;.0_171-&lt;span&gt;b11)
Java HotSpot(TM) &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;-Bit Server VM (build &lt;span&gt;25.171&lt;/span&gt;-b11, mixed mode)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;环境变量设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#####################java env###############
JAVA_HOME&lt;/span&gt;=/opt/jdk1.&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.0_171
CLASSPATH&lt;/span&gt;=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/&lt;span&gt;dt.jar 
PATH&lt;/span&gt;=$JAVA_HOME/bin:$HOME/bin:$HOME/.local/bin:$PATH
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看 runserver.sh 脚本，发现有这么三行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[ ! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; JAVA_HOME=$HOME/jdk/&lt;span&gt;java
[ &lt;/span&gt;! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; JAVA_HOME=/usr/&lt;span&gt;java
[ &lt;/span&gt;! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; error_exit &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please set the JAVA_HOME variable in your environment, We need java(x64)!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将其注释之，继续往下看，发现下面两行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export JAVA_HOME
export JAVA&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嗯，果断修改 JAVA_HOME 的值如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
export JAVA_HOME=/opt/jdk1.&lt;span&gt;8&lt;/span&gt;.0_171
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次启动 NameServer ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup sh bin/mqnamesrv &amp;amp;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;31098&lt;/span&gt;&lt;span&gt;
[root@&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup: ignoring input and appending output to ‘nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;’

[root@&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-&lt;span&gt;release]# ls
benchmark  bin  conf  lib  LICENSE  nohup.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;  NOTICE  README.md
[root@&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]#  cat nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt; 
Java HotSpot(TM) &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;-Bit Server VM warning: Using the DefNew young collector with the CMS collector &lt;span&gt;is&lt;/span&gt; deprecated and will likely be removed &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a future release
Java HotSpot(TM) &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;-Bit Server VM warning: UseCMSCompactAtFullCollection &lt;span&gt;is&lt;/span&gt; deprecated and will likely be removed &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a future release.
The Name Server boot success. serializeType&lt;/span&gt;=JSON
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处可以看到 NameServer 已成功启动，查看 NameServer 日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# tail -f ~/logs/rocketmqlogs/&lt;span&gt;namesrv.log 
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt; INFO main - tls.client.certPath = &lt;span&gt;null&lt;/span&gt;
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt; INFO main - tls.client.authServer = &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt; INFO main - tls.client.trustCertPath = &lt;span&gt;null&lt;/span&gt;
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt; INFO main -&lt;span&gt; Using OpenSSL provider
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; INFO main - SSLContext created &lt;span&gt;for&lt;/span&gt;&lt;span&gt; server
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; INFO NettyEventExecutor -&lt;span&gt; NettyEventExecutor service started
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; INFO FileWatchService -&lt;span&gt; FileWatchService service started
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; INFO main - The Name Server boot success. serializeType=&lt;span&gt;JSON
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; INFO NSScheduledThread1 - --------------------------------------------------------
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; INFO NSScheduledThread1 - configTable SIZE: &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;NameServer 启动成功&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;h4broker&quot;&gt;4. 启动 Broker&lt;/h3&gt;
&lt;p&gt;启动&lt;code&gt;Broker：nohup sh bin/mqbroker -n localhost:9876&amp;amp;&lt;/code&gt;，然而发现不能正常启动，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup sh bin/mqbroker -n localhost:&lt;span&gt;9876&lt;/span&gt;&amp;amp;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;28571&lt;/span&gt;&lt;span&gt;
[root@&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup: ignoring input and appending output to ‘nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;’

[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]+  Exit &lt;span&gt;1&lt;/span&gt;                  nohup sh bin/mqbroker -n localhost:&lt;span&gt;9876&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看nohup.out，发现里面多了这么几行错误信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Java HotSpot(TM) &lt;span&gt;64&lt;/span&gt;-Bit Server VM warning: INFO: os::commit_memory(&lt;span&gt;0x00000005c0000000&lt;/span&gt;, &lt;span&gt;8589934592&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;) failed; error=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cannot allocate memory&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (errno=&lt;span&gt;12&lt;/span&gt;&lt;span&gt;)
#
# There &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; insufficient memory &lt;span&gt;for&lt;/span&gt; the Java Runtime Environment to &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;.
# Native memory allocation (mmap) failed to map &lt;/span&gt;&lt;span&gt;8589934592&lt;/span&gt; bytes &lt;span&gt;for&lt;/span&gt;&lt;span&gt; committing reserved memory.
# An error report file with more information &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; saved &lt;span&gt;as&lt;/span&gt;&lt;span&gt;:
# &lt;/span&gt;/usr/local/rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release/hs_err_pid28580.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遂，查看 hs_err_pid28580.log：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# tail -1000f /usr/local/rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release/&lt;span&gt;hs_err_pid28580.log
#
# There &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; insufficient memory &lt;span&gt;for&lt;/span&gt; the Java Runtime Environment to &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;.
# Native memory allocation (mmap) failed to map &lt;/span&gt;&lt;span&gt;8589934592&lt;/span&gt; bytes &lt;span&gt;for&lt;/span&gt;&lt;span&gt; committing reserved memory.
# Possible reasons:
#   The system &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt; of physical RAM or swap space
#   In &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt; bit mode, the process size limit was hit
# Possible solutions:
#   Reduce memory load on the system
#   Increase physical memory or swap space
#   Check &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; swap backing store &lt;span&gt;is&lt;/span&gt;&lt;span&gt; full
#   Use &lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bit Java on a &lt;span&gt;64&lt;/span&gt;&lt;span&gt; bit OS
#   Decrease Java heap size (&lt;/span&gt;-Xmx/-&lt;span&gt;Xms)
#   Decrease number of Java threads
#   Decrease Java thread stack sizes (&lt;/span&gt;-&lt;span&gt;Xss)
#   Set larger code cache with &lt;/span&gt;-XX:ReservedCodeCacheSize=&lt;span&gt;
# This output file may be truncated or incomplete.
#
#  Out of Memory Error (os_linux.cpp:&lt;/span&gt;&lt;span&gt;2640&lt;/span&gt;), pid=&lt;span&gt;28580&lt;/span&gt;, tid=&lt;span&gt;0x00007fbc93a6c700&lt;/span&gt;&lt;span&gt;
#
# JRE version:  (&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;.0_171-&lt;span&gt;b11) (build )
# Java VM: Java HotSpot(TM) &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;-Bit Server VM (&lt;span&gt;25.171&lt;/span&gt;-b11 mixed mode linux-&lt;span&gt;amd64 compressed oops)
# Failed to write core dump. Core dumps have been disabled. To enable core dumping, &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ulimit -c unlimited&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; before starting Java again
........
VM Arguments:
jvm_args: &lt;/span&gt;-Xms8g -Xmx8g -Xmn4g -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=&lt;span&gt;25&lt;/span&gt; -XX:InitiatingHeapOccupancyPercent=&lt;span&gt;30&lt;/span&gt; -XX:SoftRefLRUPolicyMSPerMB=&lt;span&gt;0&lt;/span&gt; -XX:SurvivorRatio=&lt;span&gt;8&lt;/span&gt; -verbose:gc -Xloggc:/dev/shm/mq_gc_%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintAdaptiveSizePolicy -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=&lt;span&gt;5&lt;/span&gt; -XX:GCLogFileSize=30m -XX:-OmitStackTraceInFastThrow -XX:+AlwaysPreTouch -XX:MaxDirectMemorySize=15g -XX:-UseLargePages -XX:-UseBiasedLocking -Djava.ext.dirs=/opt/jdk1.&lt;span&gt;8&lt;/span&gt;.0_171/jre/lib/ext:/usr/local/rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release/bin/../&lt;span&gt;lib 
java_command: org.apache.rocketmq.broker.BrokerStartup &lt;/span&gt;-n localhost:&lt;span&gt;9876&lt;/span&gt;&lt;span&gt;
java_class_path (initial): .:&lt;/span&gt;/usr/local/rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release/bin/../conf:.:/opt/jdk1.&lt;span&gt;8&lt;/span&gt;.0_171/lib/tools.jar:/opt/jdk1.&lt;span&gt;8&lt;/span&gt;.0_171/lib/&lt;span&gt;dt.jar
Launcher Type: SUN_STANDARD
......&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大概意思呢，就是说，启动broker时内存不足，为什么内存不足呢？因为启动时候指定了JVM最大可用内存和最小可用内存均为8G，年轻代大小为2G。&lt;br/&gt;查看Broker启动脚本，发现果然指定了这三个jvm启动参数，然后意外发现对于JAVA_HOME的设置，runbroker.sh与runserver.sh是一样一样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[ ! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; JAVA_HOME=$HOME/jdk/&lt;span&gt;java
[ &lt;/span&gt;! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; JAVA_HOME=/usr/&lt;span&gt;java
[ &lt;/span&gt;! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; error_exit &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please set the JAVA_HOME variable in your environment, We need java(x64)!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

export JAVA_HOME
export JAVA&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
export BASE_DIR&lt;/span&gt;=$(dirname $&lt;span&gt;0&lt;/span&gt;)/&lt;span&gt;..
export CLASSPATH&lt;/span&gt;=.:${BASE_DIR}/&lt;span&gt;conf:${CLASSPATH}

#&lt;/span&gt;===========================================================================================&lt;span&gt;
# JVM Configuration
#&lt;/span&gt;===========================================================================================&lt;span&gt;
JAVA_OPT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${JAVA_OPT} -server -Xms8g -Xmx8g -Xmn4g&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遂，修改启动脚本中JAVA_HOME的设置以及JVM启动脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#[ ! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; JAVA_HOME=$HOME/jdk/&lt;span&gt;java
#[ &lt;/span&gt;! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; JAVA_HOME=/usr/&lt;span&gt;java
#[ &lt;/span&gt;! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; error_exit &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please set the JAVA_HOME variable in your environment, We need java(x64)!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

export JAVA_HOME&lt;/span&gt;=/opt/jdk1.&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.0_171
export JAVA&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
export BASE_DIR&lt;/span&gt;=$(dirname $&lt;span&gt;0&lt;/span&gt;)/&lt;span&gt;..
export CLASSPATH&lt;/span&gt;=.:${BASE_DIR}/&lt;span&gt;conf:${CLASSPATH}

#&lt;/span&gt;===========================================================================================&lt;span&gt;
# JVM Configuration
#&lt;/span&gt;===========================================================================================&lt;span&gt;
JAVA_OPT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次启动Broker：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup sh bin/mqbroker -n localhost:&lt;span&gt;9876&lt;/span&gt;&amp;amp;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;29092&lt;/span&gt;&lt;span&gt;
[root@&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup: ignoring input and appending output to ‘nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;’

[root@&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# cat nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt; 
Java HotSpot(TM) &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;-Bit Server VM warning: INFO: os::commit_memory(&lt;span&gt;0x00000005c0000000&lt;/span&gt;, &lt;span&gt;8589934592&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;) failed; error=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cannot allocate memory&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (errno=&lt;span&gt;12&lt;/span&gt;&lt;span&gt;)
#
# There &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; insufficient memory &lt;span&gt;for&lt;/span&gt; the Java Runtime Environment to &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;.
# Native memory allocation (mmap) failed to map &lt;/span&gt;&lt;span&gt;8589934592&lt;/span&gt; bytes &lt;span&gt;for&lt;/span&gt;&lt;span&gt; committing reserved memory.
# An error report file with more information &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; saved &lt;span&gt;as&lt;/span&gt;&lt;span&gt;:
# &lt;/span&gt;/usr/local/rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release/&lt;span&gt;hs_err_pid28580.log
The broker[&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt;, &lt;span&gt;39.107&lt;/span&gt;.&lt;span&gt;153.215&lt;/span&gt;:&lt;span&gt;10911&lt;/span&gt;] boot success. serializeType=JSON and name server &lt;span&gt;is&lt;/span&gt; localhost:&lt;span&gt;9876&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处可以看到Broker已启动成功，查看Broker日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# tail -1000f ~/logs/rocketmqlogs/&lt;span&gt;broker.log 
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt; INFO main - rocketmqHome=/usr/local/rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-&lt;span&gt;release
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt; INFO main - namesrvAddr=localhost:&lt;span&gt;9876&lt;/span&gt;&lt;span&gt;
......
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt; INFO FileWatchService -&lt;span&gt; FileWatchService service started
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt; INFO PullRequestHoldService -&lt;span&gt; PullRequestHoldService service started
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt; INFO brokerOutApi_thread_1 - register broker to name server localhost:&lt;span&gt;9876&lt;/span&gt;&lt;span&gt; OK
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt; INFO main - Start transaction service!
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt; INFO main - The broker[&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt;, &lt;span&gt;39.107&lt;/span&gt;.&lt;span&gt;157.89&lt;/span&gt;:&lt;span&gt;10911&lt;/span&gt;] boot success. serializeType=JSON and name server &lt;span&gt;is&lt;/span&gt; localhost:&lt;span&gt;9876&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;h5&quot;&gt;5. 关闭消息队列&lt;/h3&gt;
&lt;p&gt;关闭 Broker：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# sh bin/&lt;span&gt;mqshutdown broker
The mqbroker(&lt;/span&gt;&lt;span&gt;29099&lt;/span&gt;) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; running...
Send shutdown request to mqbroker(&lt;/span&gt;&lt;span&gt;29099&lt;/span&gt;) OK
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关闭 NameServer：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# sh bin/&lt;span&gt;mqshutdown namesrv
The mqnamesrv(&lt;/span&gt;&lt;span&gt;14283&lt;/span&gt;) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; running...
Send shutdown request to mqnamesrv(&lt;/span&gt;&lt;span&gt;14283&lt;/span&gt;) OK
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 20 Jan 2019 15:45:00 +0000</pubDate>
<dc:creator>琳茹的技术轮子</dc:creator>
<og:description>内容目录 1. RocketMQ是什么？ 2. 下载并解压 3. 启动NameServer 4. 启动 Broker 5. 关闭消息队列 1. RocketMQ是什么？ RocketMQ是一种消息队列</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mengyi/p/10296620.html</dc:identifier>
</item>
<item>
<title>【swupdate文档 五】从可信的来源更新镜像 - zqb-all</title>
<link>http://www.cnblogs.com/zqb-all/p/10296719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zqb-all/p/10296719.html</guid>
<description>&lt;p&gt;现在越来越重要的是，设备不仅要能安全地进行更新操作，&lt;br/&gt;而且要能够验证发送的图像是否来自一个已知的源， 并且没有嵌入恶意软件。&lt;/p&gt;
&lt;p&gt;为了实现这个目标，SWUpdate必须验证传入的镜像。&lt;br/&gt;有几种方法可以做到这一点。&lt;br/&gt;这里有一些问题，完整的复合镜像需要签名吗?还是只是它的某些部分需要?&lt;/p&gt;
&lt;p&gt;不同做法的优缺点将在下一章中描述。&lt;/p&gt;
&lt;h2 id=&quot;对复合镜像进行签名&quot;&gt;对复合镜像进行签名&lt;/h2&gt;
&lt;p&gt;一个直接了当的做法是对整个复合镜像进行签名。但是。这样做有一些严重&lt;br/&gt;的缺点。这会导致无法在加载完整个复合镜像之前对镜像进行验证。&lt;br/&gt;这意味着，校验需要在安装了镜像之后才进行，而不是在实际写入设备&lt;br/&gt;之前就能进行。&lt;br/&gt;这会导致，如果校验失败，需要对已经安装好的镜像做一些取消安装的操作，&lt;br/&gt;这种取消安装的操作，在碰到掉电时，可能会导致一些不希望保留的数据被保留在设备上。&lt;/p&gt;
&lt;h2 id=&quot;对子镜像进行签名&quot;&gt;对子镜像进行签名&lt;/h2&gt;
&lt;p&gt;如果每个子图像都签名了，验证就可以在操作相应的硬件之前完成。&lt;br/&gt;只有签名正确的镜像会被实际安装。&lt;br/&gt;不过这样存在一个问题，子镜像没有跟sw-descrription文件中的发布描述绑定到一起。&lt;br/&gt;即使sw-description也做了签名，即使对sw-description进行了签名，攻击者也可以&lt;br/&gt;将签名子镜像们混合在一起，生成可以安装的新的复合镜像，因为所有子镜像都可通过验证。&lt;/p&gt;
&lt;h2 id=&quot;对sw-description进行签名并与哈希验证相结合&quot;&gt;对sw-description进行签名并与哈希验证相结合&lt;/h2&gt;
&lt;p&gt;为了避免所描述的缺点，SWUpdate将签名的sw-description与每个子镜像的哈希验证结合起来。&lt;br/&gt;这意味着只有经过验证的源代码生成的sw-description才能被安装程序接受。&lt;br/&gt;而sw-description包含每个子镜像的哈希值，可验证每个交付的子镜像确实属于本次发布。&lt;/p&gt;
&lt;h2 id=&quot;算法的选择&quot;&gt;算法的选择&lt;/h2&gt;
&lt;p&gt;可以通过menuconfig选择签名和验证sw-descrription文件的算法。&lt;br/&gt;目前，实现了以下机制:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RSA 公钥/私钥。 私钥属于编译系统，而公钥需要被安装到设备上。&lt;/li&gt;
&lt;li&gt;使用证书的CMS&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;密钥或证书使用&quot;-k&quot;参数传递给SWUpdate。&lt;/p&gt;
&lt;h2 id=&quot;生成密钥证书的工具&quot;&gt;生成密钥/证书的工具&lt;/h2&gt;
&lt;p&gt;openssl 工具用于生成密钥。这是OpenSSL项目的一部分。完整的文档可以 在&lt;br/&gt;&lt;a href=&quot;https://www.openssl.org/docs/manmaster/man1/openssl.html&quot;&gt;openSSL 网站&lt;/a&gt;&lt;br/&gt;上找到&lt;/p&gt;
&lt;h2 id=&quot;使用-rsa-pkcs1.5&quot;&gt;使用 RSA PKCS#1.5&lt;/h2&gt;
&lt;h3 id=&quot;生成私钥和公钥&quot;&gt;生成私钥和公钥&lt;/h3&gt;
&lt;p&gt;首先，需要生成私钥&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl genrsa -aes256 -out priv.pem&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要一个密码。可以从文件中去获取这个密码 - 当然，&lt;br/&gt;这个密码文件必须保护好，防止被入侵。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl genrsa -aes256 -passout file:passout -out priv.pem&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用如下命令，从私钥导出公钥:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl rsa -in priv.pem -out public.pem -outform PEM -pubout&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&quot;public.pem&quot; 包含了适用于swupdate的格式的密钥。&lt;br/&gt;该文件可以通过-k参数在命令行传递给swupdate。&lt;/p&gt;
&lt;h3 id=&quot;如何使用rsa进行签名&quot;&gt;如何使用RSA进行签名&lt;/h3&gt;
&lt;p&gt;对镜像进行签名非常简单:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl dgst -sha256 -sign priv.pem sw-description &amp;gt; sw-description.sig&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;与证书和cms一起使用&quot;&gt;与证书和CMS一起使用&lt;/h2&gt;
&lt;h3 id=&quot;生成自签名证书&quot;&gt;生成自签名证书&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;openssl req -x509 -newkey rsa:4096 -nodes -keyout mycert.key.pem \
    -out mycert.cert.pem -subj &quot;/O=SWUpdate /CN=target&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有关参数的更多信息，请参阅文档。 &quot;mycert.key.pem&quot; 包含了私钥，用于签名。&lt;br/&gt;它 &lt;em&gt;不能&lt;/em&gt; 被部署到目标设备上。&lt;/p&gt;
&lt;p&gt;目标设备上必须安装有 &quot;mycert.cert.pem&quot; - 这将被SWUpdate用于完成校验。&lt;/p&gt;
&lt;h3 id=&quot;使用pki颁发的证书&quot;&gt;使用PKI颁发的证书&lt;/h3&gt;
&lt;p&gt;也可以使用PKI签发的代码签名证书。&lt;br/&gt;不过，SWUpdate是使用OpenSSL库来处理CMS签名的，该库要求在签名证书上设置以下属性:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;keyUsage=digitalSignature
extendedKeyUsage=emailProtection&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不能满足此要求，也可以完全禁用签名证书密钥检查。 这是由&lt;br/&gt;CONFIG_CMS_IGNORE_CERTIFICATE_PURPOSE 配置选项控制的。&lt;/p&gt;
&lt;h3 id=&quot;如何用cms签名&quot;&gt;如何用CMS签名&lt;/h3&gt;
&lt;p&gt;对镜像进行签名，跟前一种情况一样很简单:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl cms -sign -in  sw-description -out sw-description.sig -signer mycert.cert.pem \
        -inkey mycert.key.pem -outform DER -nosmimecap -binary&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;构建签名的swu镜像&quot;&gt;构建签名的SWU镜像&lt;/h2&gt;
&lt;p&gt;有两个文件，sw-description和它的签名sw-description.sig。&lt;br/&gt;签名文件必须紧跟在描述文件后面。&lt;/p&gt;
&lt;p&gt;sw-description中的每个图像必须具有 &quot;sha256&quot; 属性，&lt;br/&gt;即镜像的sha256校验和。如果有一个镜像不具有sha256属性，&lt;br/&gt;则整个复合镜像的的校验结果会是未通过，SWUpdate在开始安装之前会停止并报错。&lt;/p&gt;
&lt;p&gt;创建签名镜像的简单脚本可以是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash

MODE=&quot;RSA&quot;
PRODUCT_NAME=&quot;myproduct&quot;
CONTAINER_VER=&quot;1.0&quot;
IMAGES=&quot;rootfs kernel&quot;
FILES=&quot;sw-description sw-description.sig $IMAGES&quot;

#if you use RSA
if [ x&quot;$MODE&quot; == &quot;xRSA&quot; ]; then
    openssl dgst -sha256 -sign priv.pem sw-description &amp;gt; sw-description.sig
else
    openssl cms -sign -in  sw-description -out sw-description.sig -signer mycert.cert.pem \
        -inkey mycert.key.pem -outform DER -nosmimecap -binary
fi
for i in $FILES;do
        echo $i;done | cpio -ov -H crc &amp;gt;  ${PRODUCT_NAME}_${CONTAINER_VER}.swu&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;签名镜像的sw-description示例&quot;&gt;签名镜像的sw-description示例&lt;/h2&gt;
&lt;p&gt;本例应用于Beaglebone，安装Yocto images:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;software =
{
        version = &quot;0.1.0&quot;;

        hardware-compatibility: [ &quot;revC&quot;];

        images: (
                {
                    filename = &quot;core-image-full-cmdline-beaglebone.ext3&quot;;
                    device = &quot;/dev/mmcblk0p2&quot;;
                    type = &quot;raw&quot;;
                    sha256 = &quot;43cdedde429d1ee379a7d91e3e7c4b0b9ff952543a91a55bb2221e5c72cb342b&quot;;
                }
        );
        scripts: (
                {
                    filename = &quot;test.lua&quot;;
                    type = &quot;lua&quot;;
                    sha256 = &quot;f53e0b271af4c2896f56a6adffa79a1ffa3e373c9ac96e00c4cfc577b9bea5f1&quot;;
                 }
        );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对签名镜像运行swupdate&quot;&gt;对签名镜像运行SWUpdate&lt;/h2&gt;
&lt;p&gt;验证是通过在SWUpdate的配置中设置CONFIG_SIGNED_IMAGES激活的。&lt;br/&gt;一旦激活，SWUpdate将始终检查复合图像。&lt;br/&gt;出于安全原因，不可能在运行时禁用检查。&lt;br/&gt;-k参数(公钥文件)是必须的，如果公钥没有传递，程序将终止运行。&lt;/p&gt;
&lt;p&gt;本文地址 &lt;a href=&quot;https://www.cnblogs.com/zqb-all/p/10296719.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zqb-all/p/10296719.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译自 swupdate 文档 &lt;a href=&quot;https://sbabic.github.io/swupdate/signed_images.html&quot; class=&quot;uri&quot;&gt;https://sbabic.github.io/swupdate/signed_images.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有更新会在github上发布 &lt;a href=&quot;https://zqb-all.github.io/swupdate/signed_images.html&quot; class=&quot;uri&quot;&gt;https://zqb-all.github.io/swupdate/signed_images.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 15:42:00 +0000</pubDate>
<dc:creator>zqb-all</dc:creator>
<og:description>从可信的来源更新镜像 ==================== 现在越来越重要的是，设备不仅要能安全地进行更新操作， 而且要能够验证发送的图像是否来自一个已知的源， 并且没有嵌入恶意软件。 为了实现这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zqb-all/p/10296719.html</dc:identifier>
</item>
<item>
<title>两小时入门Docker - 温而新</title>
<link>http://www.cnblogs.com/peng104/p/10296717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peng104/p/10296717.html</guid>
<description>&lt;h2&gt;Docker是什么?&lt;/h2&gt;
&lt;p&gt;Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。&lt;br/&gt;Docker 使用 Google 公司推出的 Go 语言 进行开发实现。&lt;br/&gt;docker是linux容器的一种封装，提供简单易用的容器使用接口。它是最流行的Linux容器解决方案。&lt;br/&gt;docker的接口相当简单，用户可以方便的创建、销毁容器。&lt;br/&gt;docker将应用程序与程序的依赖，打包在一个文件里面。运行这个文件就会生成一个虚拟容器。&lt;br/&gt;程序运行在虚拟容器里，如同在真实物理机上运行一样，有了docker，就不用担心环境问题了。&lt;/p&gt;
&lt;h2&gt;应用场景&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;web应用的自动化打包和发布&lt;/li&gt;
&lt;li&gt;自动化测试和持续集成、发布&lt;/li&gt;
&lt;li&gt;在服务型环境中部署和调整数据库或其他应用&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;区别&lt;/h2&gt;
&lt;p&gt;1，物理机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1392643/201901/1392643-20190120201550499-1654279132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二，虚拟机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1392643/201901/1392643-20190120201624596-1171496358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三，docker容器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1392643/201901/1392643-20190120201703123-269664938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Docker的三大概念及优势&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;镜像　　image&lt;/li&gt;
&lt;li&gt;容器　　container&lt;/li&gt;
&lt;li&gt;仓库　　repository&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4db2d003-f404-4e8b-9a17-72f39b281391')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_4db2d003-f404-4e8b-9a17-72f39b281391&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4db2d003-f404-4e8b-9a17-72f39b281391&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4db2d003-f404-4e8b-9a17-72f39b281391',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4db2d003-f404-4e8b-9a17-72f39b281391&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1. 更高效的利用系统资源&lt;/span&gt;
&lt;span&gt;由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统 资源的利用率更高。
无论是应用执行速度、内存损耗或者文件存储速度，都要比传 统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运 行更多数量的应用。
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 更快速的启动时间&lt;/span&gt;
&lt;span&gt;传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接 运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启 动时间。大大的节约了开发、测试、部署的时间。
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3. 一致的运行环境&lt;/span&gt;
&lt;span&gt;开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环 境不一致，导致有些 bug 并未在开发过程中被发现。
而 Docker 的镜像提供了除内 核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码 在我机器上没问题啊” 这类问题。
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4. 持续交付和部署&lt;/span&gt;
&lt;span&gt;对开发和运维(DevOps)人员来说，最希望的就是一次创建或配置，可以在任意 地方正常运行。
使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员 可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系 统进行集成测试，
而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery&lt;/span&gt;/&lt;span&gt;Deployment) 系统进行自动部署。
而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环 境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5. 更轻松的迁移&lt;/span&gt;
&lt;span&gt;由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在 很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运 行结果是一致的。
因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一 个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;docker容器的优势&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;系统环境：docker最低支持centos7且在64位平台上，内核版本在3.10以上&lt;/p&gt;
&lt;p&gt;版本：社区版，企业版（包含了一些收费服务）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-after-using-the-convenience-script&quot; target=&quot;_blank&quot;&gt;官方版安装教程（英文）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博主版安装教程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 安装docker&lt;/span&gt;
&lt;span&gt;yum install docker
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动docker &lt;/span&gt;
systemctl start/&lt;span&gt;status docker 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看docker启动状态&lt;/span&gt;
docker version 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;配置加速器&lt;/h3&gt;
&lt;p&gt;简介：&lt;span class=&quot;external-link&quot;&gt;DaoCloud 加速器 是广受欢迎的 Docker 工具，解决了国内用户访问 Docker Hub 缓慢的问题。DaoCloud 加速器结合国内的 CDN 服务与协议层优化，成倍的提升了下载速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.daocloud.io/mirror#accelerator-doc&quot; target=&quot;_blank&quot;&gt;DaoCloud官网&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一条命令加速（记得重启docker）&lt;/span&gt;
curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://95822026.m.daocloud.io
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5dd6baa8-332c-4440-86f6-c70a2c563c7f')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_5dd6baa8-332c-4440-86f6-c70a2c563c7f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5dd6baa8-332c-4440-86f6-c70a2c563c7f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5dd6baa8-332c-4440-86f6-c70a2c563c7f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5dd6baa8-332c-4440-86f6-c70a2c563c7f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Usage:
docker [OPTIONS] COMMAND [arg...]

       docker daemon [ &lt;/span&gt;--help |&lt;span&gt; ... ]

       docker [ &lt;/span&gt;--help | -v | --&lt;span&gt;version ]

 

A
self&lt;/span&gt;-sufficient runtime &lt;span&gt;for&lt;/span&gt;&lt;span&gt; containers.

 

Options:

 

  &lt;/span&gt;--config=~/.docker              Location of client config files  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;客户端配置文件的位置&lt;/span&gt;

  -D, --debug=false               Enable debug mode  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;启用Debug调试模式&lt;/span&gt;

  -H, --host=[]                   Daemon socket(s) to connect to  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;守护进程的套接字（Socket）连接&lt;/span&gt;

  -h, --help=false                Print usage  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印使用&lt;/span&gt;

  -l, --log-level=info            Set the logging level  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置日志级别&lt;/span&gt;

  --tls=false                     Use TLS; implied by--tlsverify  &lt;span&gt;#
&lt;/span&gt;
  --tlscacert=~/.docker/ca.pem    Trust certs signed only by this CA  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;信任证书签名CA&lt;/span&gt;

  --tlscert=~/.docker/cert.pem    Path to TLS certificate file  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;TLS证书文件路径&lt;/span&gt;

  --tlskey=~/.docker/key.pem      Path to TLS key file  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;TLS密钥文件路径&lt;/span&gt;

  --tlsverify=false               Use TLS &lt;span&gt;and&lt;/span&gt; verify the remote  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用TLS验证远程&lt;/span&gt;

  -v, --version=false             Print version information &lt;span&gt;and&lt;/span&gt; quit  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印版本信息并退出&lt;/span&gt;
&lt;span&gt;
 

Commands:

    attach    Attach to a running container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;当前shell下attach连接指定运行镜像&lt;/span&gt;
&lt;span&gt;
    build     Build an image &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; a Dockerfile  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过Dockerfile定制镜像&lt;/span&gt;
&lt;span&gt;
    commit    Create a new image &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; a container&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s changes  #提交当前容器为新的镜像&lt;/span&gt;
&lt;span&gt;
    cp    Copy files&lt;/span&gt;/folders &lt;span&gt;from&lt;/span&gt; a container to a HOSTDIR &lt;span&gt;or&lt;/span&gt; to STDOUT  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从容器中拷贝指定文件或者目录到宿主机中&lt;/span&gt;
&lt;span&gt;
    create    Create a new container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个新的容器，同run 但不启动容器&lt;/span&gt;
&lt;span&gt;
    diff    Inspect changes on a container&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s filesystem  #查看docker容器变化&lt;/span&gt;
&lt;span&gt;
    events    Get real time events &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; the server&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从docker服务获取容器实时事件&lt;/span&gt;

    &lt;span&gt;exec&lt;/span&gt;    Run a command &lt;span&gt;in&lt;/span&gt; a running container&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在已存在的容器上运行命令&lt;/span&gt;
&lt;span&gt;
    export    Export a container&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s filesystem as a tar archive  #导出容器的内容流作为一个tar归档文件(对应import)&lt;/span&gt;
&lt;span&gt;
    history    Show the history of an image  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;展示一个镜像形成历史&lt;/span&gt;
&lt;span&gt;
    images    List images  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;列出系统当前镜像&lt;/span&gt;

    &lt;span&gt;import&lt;/span&gt;    Import the contents &lt;span&gt;from&lt;/span&gt; a tarball to create a filesystem image  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从tar包中的内容创建一个新的文件系统映像(对应export)&lt;/span&gt;
&lt;span&gt;
    info    Display system&lt;/span&gt;-wide information  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示系统相关信息&lt;/span&gt;
&lt;span&gt;
    inspect    Return low&lt;/span&gt;-level information on a container &lt;span&gt;or&lt;/span&gt; image  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看容器详细信息&lt;/span&gt;
&lt;span&gt;
    kill    Kill a running container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;kill指定docker容器&lt;/span&gt;
&lt;span&gt;
    load    Load an image &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; a tar archive &lt;span&gt;or&lt;/span&gt; STDIN  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从一个tar包中加载一个镜像(对应save)&lt;/span&gt;
&lt;span&gt;
    login    Register &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; log &lt;span&gt;in&lt;/span&gt; to a Docker registry&lt;span&gt;#&lt;/span&gt;&lt;span&gt;注册或者登陆一个docker源服务器&lt;/span&gt;
&lt;span&gt;
    logout    Log out &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; a Docker registry  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从当前Docker registry退出&lt;/span&gt;
&lt;span&gt;
    logs    Fetch the logs of a container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出当前容器日志信息&lt;/span&gt;
&lt;span&gt;
    pause    Pause all processes within a container&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;暂停容器&lt;/span&gt;
&lt;span&gt;
    port    List port mappings &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; a specific mapping &lt;span&gt;for&lt;/span&gt; the CONTAINER  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看映射端口对应的容器内部源端口&lt;/span&gt;
&lt;span&gt;
    ps    List containers  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;列出容器列表&lt;/span&gt;
&lt;span&gt;
    pull    Pull an image &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; a repository &lt;span&gt;from&lt;/span&gt; a registry  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从docker镜像源服务器拉取指定镜像或者库镜像&lt;/span&gt;
&lt;span&gt;
    push    Push an image &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; a repository to a registry  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;推送指定镜像或者库镜像至docker源服务器&lt;/span&gt;
&lt;span&gt;
    rename    Rename a container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;重命名容器&lt;/span&gt;
&lt;span&gt;
    restart    Restart a running container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;重启运行的容器&lt;/span&gt;
&lt;span&gt;
    rm    Remove one &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; more containers  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;移除一个或者多个容器&lt;/span&gt;
&lt;span&gt;
    rmi    Remove one &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; more images  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;移除一个或多个镜像(无容器使用该镜像才可以删除，否则需要删除相关容器才可以继续或者-f强制删除)&lt;/span&gt;
&lt;span&gt;
    run    Run a command &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; a new container  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个新的容器并运行一个命令&lt;/span&gt;
&lt;span&gt;
    save    Save an image(s) to a tar archive&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存一个镜像为一个tar包(对应load)&lt;/span&gt;
&lt;span&gt;
    search    Search the Docker Hub &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; images  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在docker&lt;/span&gt;
&lt;span&gt;hub中搜索镜像

    start    Start one &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; more stopped containers&lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动容器&lt;/span&gt;
&lt;span&gt;
    stats    Display a live stream of container(s) resource usage statistics  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;统计容器使用资源&lt;/span&gt;
&lt;span&gt;
    stop    Stop a running container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;停止容器&lt;/span&gt;
&lt;span&gt;
    tag         Tag an image into a repository  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;给源中镜像打标签&lt;/span&gt;
&lt;span&gt;
    top       Display the running processes of a container &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看容器中运行的进程信息&lt;/span&gt;
&lt;span&gt;
    unpause    Unpause all processes within a container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;取消暂停容器&lt;/span&gt;
&lt;span&gt;
    version    Show the Docker version information&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看容器版本号&lt;/span&gt;
&lt;span&gt;
    wait         Block until a container stops, then &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; its exit code  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;截取容器停止时的退出状态值&lt;/span&gt;
&lt;span&gt;
 

Run &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;docker COMMAND --help&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; more information on a command.  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;运行docker命令在帮助可以获取更多信息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;docker --help（中文注解）&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
docker search  hello-docker  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 搜索hello-docker的镜像&lt;/span&gt;
docker search centos &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 搜索centos镜像&lt;/span&gt;
docker pull hello-docker &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取centos镜像&lt;/span&gt;
docker run  hello-world   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;运行一个docker镜像，产生一个容器实例（也可以通过镜像id前三位运行）&lt;/span&gt;
docker image ls  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看本地所有镜像&lt;/span&gt;
docker images  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看docker镜像&lt;/span&gt;
docker image rmi hello-docker &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除centos镜像&lt;/span&gt;
docker ps  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;列出正在运行的容器（如果创建容器中没有进程正在运行，容器就会立即停止）&lt;/span&gt;
docker ps -a  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 列出所有运行过的容器记录&lt;/span&gt;
docker save centos &amp;gt; /opt/centos.tar.gz  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导出docker镜像至本地&lt;/span&gt;
docker load &amp;lt; /opt/centos.tar.gz   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入本地镜像到docker镜像库&lt;/span&gt;
docker stop  `docker ps -aq`  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 停止所有正在运行的容器&lt;/span&gt;
docker  rm `docker ps -aq`    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一次性删除所有容器记录&lt;/span&gt;
docker rmi  `docker images -aq`   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一次性删除所有本地的镜像记录&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;启动容器的两种方式&lt;/h2&gt;
&lt;p&gt;容器是运行应用程序的，所以必须得先有一个操作系统为基础&lt;br/&gt;&lt;strong&gt;1. 基于镜像新建一个容器并启动&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1. 后台运行一个docker&lt;/span&gt;
docker run -d centos /bin/sh -c &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;while true;do echo 正在运行; sleep 1;done&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -d  后台运行容器&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; /bin/sh  指定使用centos的bash解释器&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -c 运行一段shell命令&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &quot;while true;do echo 正在运行; sleep 1;done&quot;  在linux后台，每秒中打印一次正在运行&lt;/span&gt;
docker ps  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查容器进程&lt;/span&gt;
docker  logs  -f  容器id/名称  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不间断打印容器的日志信息 &lt;/span&gt;
docker stop centos  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 停止容器&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 启动一个bash终端,允许用户进行交互&lt;/span&gt;
docker run --name mydocker -it centos /bin/&lt;span&gt;bash  
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; --name  给容器定义一个名称&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -i  让容器的标准输入保持打开&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -t 让Docker分配一个伪终端,并绑定到容器的标准输入上&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; /bin/bash 指定docker容器，用shell解释器交互&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当利用docker run来创建容器时，Docker在后台运行的步骤如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e1c74e51-f9f5-4cff-ace3-99a0d66971f0')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e1c74e51-f9f5-4cff-ace3-99a0d66971f0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e1c74e51-f9f5-4cff-ace3-99a0d66971f0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e1c74e51-f9f5-4cff-ace3-99a0d66971f0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e1c74e51-f9f5-4cff-ace3-99a0d66971f0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1. 检查本地是否存在指定的镜像，不存在就从公有仓库下载&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 利用镜像创建并启动一个容器&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3. 分配一个文件系统，并在只读的镜像层外面挂在一层可读写层&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4. 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5. 从地址池配置一个ip地址给容器&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6. 执行用户指定的应用程序&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 7. 执行完毕后容器被终止&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;运行步骤&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. 将一个终止状态(stopped)的容器重新启动&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; docker ps -a  # 先查询记录&lt;/span&gt;
&lt;span&gt;CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS                    NAMES
ee92fcf6f32d        centos              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;              4 days ago          Exited (137) 3&lt;span&gt; days ago                                kickass_raman

[root@localhost &lt;/span&gt;~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; docker start ee9  # 再启动这个容器&lt;/span&gt;
&lt;span&gt;ee9

[root@localhost &lt;/span&gt;~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; docker exec -it  ee9 /bin/bash  # 进入容器交互式界面&lt;/span&gt;
[root@ee92fcf6f32d /]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;   # 注意看用户名，已经变成容器用户名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;提交创建自定义镜像&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.我们进入交互式的centos容器中，发现没有vim命令&lt;/span&gt;
    docker run -&lt;span&gt;it centos
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.在当前容器中，安装一个vim&lt;/span&gt;
    yum install -&lt;span&gt;y vim
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.安装好vim之后，exit退出容器&lt;/span&gt;
&lt;span&gt;    exit
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.查看刚才安装好vim的容器记录&lt;/span&gt;
    docker container ls -&lt;span&gt;a
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.提交这个容器，创建新的image&lt;/span&gt;
    docker commit 059fdea031ba chaoyu/centos-&lt;span&gt;vim
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6.查看镜像文件&lt;/span&gt;
&lt;span&gt;    docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
chaoyu&lt;/span&gt;/centos-vim   latest              fd2685ae25fe        5 minutes ago       348MB
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;外部访问容器&lt;/h2&gt;
&lt;p&gt;容器中可以运行网络应用，但是要让外部也可以访问这些应用，可以通过-p或-P参数指定端口映射。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
docker run -d -P training/&lt;span&gt;webapp python app.py
  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -P 参数会随机映射端口到容器开放的网络端口&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查映射的端口&lt;/span&gt;
docker ps -&lt;span&gt;l
CONTAINER ID        IMAGE               COMMAND             CREATED            STATUS              PORTS                     NAMES
cfd632821d7a        training&lt;/span&gt;/webapp     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python app.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;     21 seconds ago      Up 20 seconds       0.0.0.0:32768-&amp;gt;5000/&lt;span&gt;tcp   brave_fermi
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;宿主机ip:32768 映射容器的5000端口&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看容器日志信息&lt;/span&gt;
docker logs -f cfd  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; #不间断显示log&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 也可以通过-p参数指定映射端口&lt;/span&gt;
docker run -d -p 9000:5000 training/webapp python app.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开浏览器访问服务器的9000端口， 内容显示 Hello world！表示正常启动&lt;/p&gt;
&lt;p&gt;(如果访问失败的话，检查自己的防火墙，以及云服务器的安全组)&lt;/p&gt;

&lt;p&gt;镜像是容器的基础，每次执行docker run的时候都会指定哪个镜像作为容器运行的基础。我们之前的例子都是使用来自docker hub的镜像，直接使用这些镜像只能满足一定的需求，当镜像无法满足我们的需求时，就得自定制这些镜像。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 镜像的定制就是定制每一层所添加的配置、文件。如果可以吧每一层修改、安装、构建、操作的命令都写入到一个脚本，用脚本来构建、定制镜像，这个脚本就是dockerfile。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令 构建一层，因此每一条指令的内容，就是描述该层应当如何构建。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3a37a7d2-e0c8-4721-b67e-8f23b9919ba0')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3a37a7d2-e0c8-4721-b67e-8f23b9919ba0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3a37a7d2-e0c8-4721-b67e-8f23b9919ba0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3a37a7d2-e0c8-4721-b67e-8f23b9919ba0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3a37a7d2-e0c8-4721-b67e-8f23b9919ba0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
FROM scratch &lt;span&gt;#&lt;/span&gt;&lt;span&gt;制作base image 基础镜像，尽量使用官方的image作为base image&lt;/span&gt;
FROM centos &lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用base image&lt;/span&gt;
FROM ubuntu:14.04 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;带有tag的base image&lt;/span&gt;
&lt;span&gt;
LABEL version&lt;/span&gt;=“1.0” &lt;span&gt;#&lt;/span&gt;&lt;span&gt;容器元信息，帮助信息，Metadata，类似于代码注释&lt;/span&gt;
LABEL maintainer=“yc_uuu@163.com&lt;span&gt;&quot;
&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对于复杂的RUN命令，避免无用的分层，多条命令用反斜线换行，合成一条命令！&lt;/span&gt;
RUN yum update &amp;amp;&amp;amp; yum install -&lt;span&gt;y vim \
    Python&lt;/span&gt;-dev &lt;span&gt;#&lt;/span&gt;&lt;span&gt;反斜线换行&lt;/span&gt;
RUN /bin/bash -c &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;source $HOME/.bashrc;echo $HOME”&lt;/span&gt;
&lt;span&gt;
WORKDIR &lt;/span&gt;/root &lt;span&gt;#&lt;/span&gt;&lt;span&gt;相当于linux的cd命令，改变目录，尽量使用绝对路径！！！不要用RUN cd&lt;/span&gt;
WORKDIR /test &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果没有就自动创建&lt;/span&gt;
WORKDIR demo &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 再进入demo文件夹&lt;/span&gt;
RUN pwd     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印结果应该是/test/demo&lt;/span&gt;
&lt;span&gt;
ADD &lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;span&gt; COPY 
ADD hello &lt;/span&gt;/  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把本地文件添加到镜像中，吧本地的hello可执行文件拷贝到镜像的/目录&lt;/span&gt;
ADD test.tar.gz /  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加到根目录并解压&lt;/span&gt;
&lt;span&gt;
WORKDIR &lt;/span&gt;/&lt;span&gt;root
ADD hello test&lt;/span&gt;/  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进入/root/ 添加hello可执行命令到test目录下，也就是/root/test/hello 一个绝对路径&lt;/span&gt;
COPY hello test/  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等同于上述ADD效果&lt;/span&gt;
&lt;span&gt;
ADD与COPY
   &lt;/span&gt;-&lt;span&gt; 优先使用COPY命令
    &lt;/span&gt;-&lt;span&gt;ADD除了COPY功能还有解压功能
添加远程文件&lt;/span&gt;/&lt;span&gt;目录使用curl或wget

ENV &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 环境变量，尽可能使用ENV增加可维护性&lt;/span&gt;
ENV MYSQL_VERSION 5.6 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置一个mysql常量&lt;/span&gt;
RUN yum install -y mysql-server=“${MYSQL_VERSION}” 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;参数详解&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('60016d61-f52d-47a7-ab7b-fc59441f4e38')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_60016d61-f52d-47a7-ab7b-fc59441f4e38&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_60016d61-f52d-47a7-ab7b-fc59441f4e38&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('60016d61-f52d-47a7-ab7b-fc59441f4e38',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_60016d61-f52d-47a7-ab7b-fc59441f4e38&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
VOLUME &lt;span&gt;and&lt;/span&gt;&lt;span&gt; EXPOSE 
存储和网络

RUN &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; CMD &lt;span&gt;and&lt;/span&gt;&lt;span&gt; ENTRYPOINT
RUN：执行命令并创建新的Image Layer
CMD：设置容器启动后默认执行的命令和参数
ENTRYPOINT：设置容器启动时运行的命令

Shell格式和Exec格式
RUN yum install &lt;/span&gt;-&lt;span&gt;y vim
CMD echo ”hello docker”
ENTRYPOINT echo “hello docker”

Exec格式
RUN [“apt&lt;/span&gt;-get”,”install”,”-&lt;span&gt;y”,”vim”]
CMD [“&lt;/span&gt;/bin/&lt;span&gt;echo”,”hello docker”]
ENTRYPOINT [“&lt;/span&gt;/bin/&lt;span&gt;echo”,”hello docker”]


通过shell格式去运行命令，会读取$name指令，而exec格式是仅仅的执行一个命令，而不是shell指令
cat Dockerfile
    FROM centos
    ENV name Docker
    ENTRYPOINT [“&lt;/span&gt;/bin/echo”,”hello $name”]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这个仅仅是执行echo命令，读取不了shell变量&lt;/span&gt;
    ENTRYPOINT  [“/bin/bash”,”-c”,”echo hello $name&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;
CMD
容器启动时默认执行的命令
如果docker run指定了其他命令(docker run &lt;/span&gt;-it [image] /bin/&lt;span&gt;bash )，CMD命令被忽略
如果定义多个CMD，只有最后一个执行

ENTRYPOINT
让容器以应用程序或服务形式运行
不会被忽略，一定会执行
最佳实践：写一个shell脚本作为entrypoint
COPY docker&lt;/span&gt;-entrypoint.sh /usr/local/&lt;span&gt;bin
ENTRYPOINT [“docker&lt;/span&gt;-&lt;span&gt;entrypoint.sh]
EXPOSE &lt;/span&gt;27017&lt;span&gt;
CMD [“mongod”]

[root@master home]&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; more Dockerfile&lt;/span&gt;
&lt;span&gt;FROm centos
ENV name Docker
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;CMD [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello $name&quot;]&lt;/span&gt;
ENTRYPOINT [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;echo hello $name”]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;进阶知识(了解)&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;1，docker hub共有镜像发布&lt;/h2&gt;
&lt;p&gt;docker提供了一个类似于github的仓库docker hub,&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot;&gt;官方网站&lt;/a&gt;（需注册使用）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注册docker id后，在linux中登录dockerhub&lt;/span&gt;
&lt;span&gt;    docker login

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意要保证image的tag是账户名，如果镜像名字不对，需要改一下tag&lt;/span&gt;
    docker tag chaoyu/centos-vim peng104/centos-&lt;span&gt;vim
&lt;/span&gt;&lt;span&gt;    #&lt;/span&gt;&lt;span&gt; 语法是：  docker tag   仓库名   peng104/仓库名&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 推送docker image到dockerhub&lt;/span&gt;
    docker push peng104/centps-cmd-&lt;span&gt;exec&lt;/span&gt;&lt;span&gt;:latest

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去dockerhub中检查镜像&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 先删除本地镜像，然后再测试下载pull 镜像文件&lt;/span&gt;
    docker pull peng104/centos-entrypoint-&lt;span&gt;exec&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2，私有仓库&lt;/h2&gt;
&lt;p&gt;docker hub 是公开的，其他人也是可以下载，并不安全，因此还可以使用docker registry官方提供的私有仓库&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/repository/registry.html&quot; target=&quot;_blank&quot;&gt;用法详解点我&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.下载一个docker官方私有仓库镜像&lt;/span&gt;
&lt;span&gt;    docker pull registry
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.运行一个docker私有容器仓库&lt;/span&gt;
docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/&lt;span&gt;registry  registry
    &lt;/span&gt;-&lt;span&gt;d 后台运行 
    &lt;/span&gt;-&lt;span&gt;p  端口映射 宿主机的5000:容器内的5000
    &lt;/span&gt;-v  数据卷挂载  宿主机的 /opt/data/registry :/var/lib/&lt;span&gt;registry 
    registry  镜像名
    &lt;/span&gt;/var/lib/&lt;span&gt;registry  存放私有仓库位置
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 3.修改docker的配置文件，让他支持http方式，上传私有镜像&lt;/span&gt;
    vim /etc/docker/&lt;span&gt;daemon.json 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入如下内容&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;registry-mirrors&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://f1361db2.m.daocloud.io&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insecure-registries&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.37:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    }
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.修改docker的服务配置文件&lt;/span&gt;
    vim /lib/systemd/system/&lt;span&gt;docker.service
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 找到[service]这一代码区域块，写入如下参数&lt;/span&gt;
&lt;span&gt;    [Service]
    EnvironmentFile&lt;/span&gt;=-/etc/docker/&lt;span&gt;daemon.json
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.重新加载docker服务&lt;/span&gt;
    systemctl daemon-&lt;span&gt;reload
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6.重启docker服务&lt;/span&gt;
&lt;span&gt;    systemctl restart docker
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意:重启docker服务，所有的容器都会挂掉&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 7.修改本地镜像的tag标记，往自己的私有仓库推送&lt;/span&gt;
    docker tag docker.io/peng104/hello-world-docker 192.168.11.37:5000/peng-&lt;span&gt;hello
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 浏览器访问http://192.168.119.10:5000/v2/_catalog查看仓库&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 8.下载私有仓库的镜像&lt;/span&gt;
    docker pull 192.168.11.37:5000/peng-hello
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编写dockerfile，构建自己的镜像，运行flask程序。&lt;/p&gt;
&lt;p&gt;确保app.py和dockerfile在同一个目录！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.准备好app.py的flask程序&lt;/span&gt;
    [root@localhost ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cat app.py&lt;/span&gt;
    &lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Flask
    app&lt;/span&gt;=Flask(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
    @app.route(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hello():
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello docker&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        app.run(host&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,port=8080&lt;span&gt;)
    [root@master home]&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ls&lt;/span&gt;
&lt;span&gt;    app.py  Dockerfile

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.编写dockerfile&lt;/span&gt;
    [root@localhost ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cat Dockerfile&lt;/span&gt;
    FROM python:2.7&lt;span&gt;
    LABEL maintainer&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;温而新&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    RUN pip install flask
    COPY app.py &lt;/span&gt;/app/&lt;span&gt;
    WORKDIR &lt;/span&gt;/&lt;span&gt;app
    EXPOSE &lt;/span&gt;8080&lt;span&gt;
    CMD [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.构建镜像image,找到当前目录的Dockerfile，开始构建&lt;/span&gt;
    docker build -t peng104/flask-hello-&lt;span&gt;docker .

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.查看创建好的images&lt;/span&gt;
&lt;span&gt;    docker image ls

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.启动此flask-hello-docker容器，映射一个端口供外部访问&lt;/span&gt;
    docker run -d -p 8080:8080 peng104/flask-hello-&lt;span&gt;docker

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6.检查运行的容器&lt;/span&gt;
&lt;span&gt;    docker container ls

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 7.推送这个镜像到私有仓库&lt;/span&gt;
    docker tag  peng104/flask-hello-docker   192.168.11.37:5000/peng-&lt;span&gt;flaskweb
    docker push &lt;/span&gt;192.168.11.37:5000/peng-flaskweb
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 20 Jan 2019 15:38:00 +0000</pubDate>
<dc:creator>温而新</dc:creator>
<og:description>引入 Docker是什么? Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，于 2013 年 3 月以 Apache 2.0 授权协议</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peng104/p/10296717.html</dc:identifier>
</item>
<item>
<title>EF6学习笔记十五：调试EF框架源码 - 张四海</title>
<link>http://www.cnblogs.com/jinshan-go/p/10296665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinshan-go/p/10296665.html</guid>
<description>&lt;h3&gt;&lt;span&gt;要专业系统地学习EF推荐《你必须掌握的Entity Framework 6.x与Core 2.0》。这本书作者（汪鹏，Jeffcky）的博客：https://www.cnblogs.com/CreateMyself/&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;今天继续学习EF，但是看来看去，实在是感觉不爽啊，因为你不知道源码里面到底是什么回事，我只能去猜去想象，要是有源码给我看几个单词也好啊。&lt;/p&gt;
&lt;p&gt;百度吧。还是找到几篇博客，看上去不是很难弄。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/michaellfx/p/3806857.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/michaellfx/p/3806857.html&lt;/a&gt;&lt;/p&gt;


&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120224201840-705678298.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;创建自己的控制台项目，引入两个程序集，并且控制台程序添加对这两个程序集的引用， 把这两个程序集的强签名去掉，重新生成解决方案&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120224329499-1137382309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120225220939-1824444693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里要注意，我们只引入了EntityFramework和EntityFramework.SqlServer,如果我们想要用数据迁移是不行的，可能要还要引入其他的程序集，我做了，没有成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，我们只能自己手动地去创建数据，并且数据模型的配置也要写，并且你要保证你的配置和手写的数据库是完全匹配的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以在另一个项目中把数据模型、配置都写好，测试没问题，拿到这个项目中复制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我的三个model&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_b01bf791-48e3-40d3-b1d9-f141cff7af60&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b01bf791-48e3-40d3-b1d9-f141cff7af60&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b01bf791-48e3-40d3-b1d9-f141cff7af60&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  基类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseEntity()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Id =&lt;span&gt; Guid.NewGuid().ToString();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.AddTime =&lt;span&gt; DateTime.Now;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime AddTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  产品类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Order : BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; OrderNO { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Description { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; ICollection&amp;lt;Product&amp;gt; Products { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  产品类&lt;/span&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product : BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Unit { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FK_OrderId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Order Order { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;配置如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7132b832-d74b-4e4a-baa4-64c4f09f4153&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7132b832-d74b-4e4a-baa4-64c4f09f4153&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7132b832-d74b-4e4a-baa4-64c4f09f4153&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EFDbContext:DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; EFDbContext():&lt;span&gt;base&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name=ConnectionStr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        {

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Order&amp;gt; Orders { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Product&amp;gt; Products { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity&lt;/span&gt;&amp;lt;Order&amp;gt;().ToTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tb_Orders&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .HasKey(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.Id)
                .HasMany(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.Products)
                .WithRequired(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.Order)
                .HasForeignKey(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.FK_OrderId);

            modelBuilder.Entity&lt;/span&gt;&amp;lt;Product&amp;gt;().ToTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tb_Products&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .HasKey(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.Id);

            modelBuilder.Conventions.Remove&lt;/span&gt;&amp;lt;PluralizingTableNameConvention&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(modelBuilder);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;查询数据，打印看看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_6a52ddc9-d5b9-458f-ae30-5adf51abd512&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6a52ddc9-d5b9-458f-ae30-5adf51abd512&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6a52ddc9-d5b9-458f-ae30-5adf51abd512&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  忽略循环引用&lt;/span&gt;
            JsonSerializerSettings &lt;span&gt;set&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonSerializerSettings();
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;.ReferenceLoopHandling =&lt;span&gt; ReferenceLoopHandling.Ignore;

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (EFDbContext2 ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFDbContext2())
            {
                ctx.Database.Log &lt;/span&gt;=&lt;span&gt; Console.WriteLine;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; ctx.Products.ToList();
                Console.WriteLine(JsonConvert.SerializeObject(res,&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;));
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;报错，找不到程序集&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120225515440-128019734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们把源码中的这里改成null&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120225717860-421302589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;app.config配置文件中也改一下,pulicKeyToken改成null&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_1624e3c2-fe5d-47e9-96a0-e3716f4a0964&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1624e3c2-fe5d-47e9-96a0-e3716f4a0964&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1624e3c2-fe5d-47e9-96a0-e3716f4a0964&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ?&amp;gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;configSections&amp;gt;
    &amp;lt;!-- For more information on Entity Framework configuration, visit http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;go.microsoft.com/fwlink/?LinkID=237468 --&amp;gt;&lt;/span&gt;
    &amp;lt;section name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;entityFramework&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; requirePermission=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/configSections&amp;gt;
  &amp;lt;connectionStrings&amp;gt;
    &amp;lt;add name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionStr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; connectionString=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data Source=LAPTOP-G81QJ856\SQLEXPRESS;Initial Catalog=_201901202.EFDbContext;Integrated Security=True&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; providerName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Data.SqlClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/add&amp;gt;
  &amp;lt;/connectionStrings&amp;gt;
    &amp;lt;startup&amp;gt; 
        &amp;lt;supportedRuntime version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v4.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; sku=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.NETFramework,Version=v4.6.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;/startup&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 然后打印数据，出来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120225940304-1342203888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里要注意一个问题，EFDbContext中要一次性写好，不能运行了项目，再对EFDbContext进行改动，这样他会说你的文件改动要执行数据迁移，更新数据库。但是我们刚刚就强调了，只是引入了两个程序集，无法提供数据迁移的功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120230218188-239129525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我开始就是这样，EFDbContext中的配置没有写，可能是EF无法匹配到数据库，一直进行它的默认连接，即使我给他指定了连接字符串（我要求他连接到_201901202.EFDbContext这个数据库，但是我的配置和数据不匹配，他就连接默认数据库：命名空间+上下文类名）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120230446815-658022957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我改好EFDbContext,以为这下终于万无一失，但是他说&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-1&quot;&gt;支持“EFDbContext”上下文的模型发生了更改。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;考虑使用代码优先迁移来更新数据库。可是我迁移用不了啊！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120230733938-384588883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我又写了一个EFDbContext2,把代码复制过来，这样终于行了，连接到指定的数据源了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120231023508-211198470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 20 Jan 2019 15:20:00 +0000</pubDate>
<dc:creator>张四海</dc:creator>
<og:description>要专业系统地学习EF推荐《你必须掌握的Entity Framework 6.x与Core 2.0》。这本书作者（汪鹏，Jeffcky）的博客：https://www.cnblogs.com/Creat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinshan-go/p/10296665.html</dc:identifier>
</item>
<item>
<title>Deep Learning中的Large Batch Training相关理论与实践 - DeepLearningStack</title>
<link>http://www.cnblogs.com/deep-learning-stacks/p/10296637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deep-learning-stacks/p/10296637.html</guid>
<description>&lt;div data-type=&quot;p&quot; readability=&quot;5.6629213483146&quot;&gt;[作者：&lt;a href=&quot;https://www.cnblogs.com/deep-learning-stacks&quot; target=&quot;_blank&quot;&gt;DeepLearningStack&lt;/a&gt;，阿里巴巴算法工程师，开源TensorFlow Contributor]&lt;/div&gt;
&lt;p&gt;在分布式训练时，提高计算通信占比是提高计算加速比的有效手段，当网络通信优化到一定程度时，只有通过增加每个worker上的batch size来提升计算量，进而提高计算通信占比。然而一直以来Deep Learning模型在训练时对Batch Size的选择都是异常敏感的，通常的经验是Large Batch Size会使收敛性变差，而相对小一点的Batch Size才能收敛的更好。当前学术界和工业界已经有一些论文来论证Large Batch Size对收敛性的影响，甚至提出了一些如何使用Large Batch去提高收敛性的方法，本文将对这些论文的重点和脉络做一个梳理。&lt;/p&gt;

&lt;p&gt;Large Batch Training是目前学术界和工业界研究的热点，其理论发展非常迅速。但由于非凸优化和Deep Learning的理论研究本身还处于并将长期处于初级阶段，所以即使存在各种各样的理论解释和证明，Large Batch Training相关的理论也尚未得到彻底的解释。为了能够让读者能够更容易理解Large Batch Training当前的学术发展，也为了让论文的阅读更有脉络，我们把学术界中的相关论文按照观点的提出顺序作为梳理如下。下面列出的每篇论文后面都有其要点，便于读者阅读时有个大概的感觉。因为本篇主要梳理Large Batch Training的理论部分，所以会对重点的论文进行分析解释。&lt;/p&gt;

&lt;div data-type=&quot;p&quot;&gt;
&lt;ul&gt;&lt;li&gt;《&lt;a href=&quot;https://arxiv.org/pdf/1706.02677.pdf&quot; target=&quot;_blank&quot;&gt;Accurate, Large Minibatch SGD:Training ImageNet in 1 Hour&lt;/a&gt;》：这是FaceBook提出的一篇极具争议性的论文，从实践上来说它的的复现难度也是比较大的。该论文从实践的角度出发，在ResNet上提出了一种针对Large batch training的训练方法，即learning rate scaling rule。当batch size相对于baseline增加N倍时，learning rate也要相应的增加N倍，但也指出batch size的提升有一个upper bound，超过这个值，泛化性依然会变得很差。这篇论文对learning rate scaling rule有一些公式推导，但并不本质，更多的是做了较强的假设。总体来说，这是一篇实验做得比较solid，但理论基础并不丰满的实践论文。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div data-type=&quot;p&quot;&gt;
&lt;ul&gt;&lt;li&gt;《&lt;a href=&quot;https://arxiv.org/pdf/1710.06451.pdf&quot; target=&quot;_blank&quot;&gt;A BAYESIAN PERSPECTIVE ON GENERALIZATION AND STOCHASTIC GRADIENT DESCENT&lt;/a&gt;》：这是Google发在ICLR 2018上的一篇理论和实验都比较完善的论文。因为在ResNet上已经有了Learning Rate Scaling Rule的成功经验，因此该论文从贝叶斯的角度解释了泛化性和SGD。论文的核心观点是指出了Batch Training相对于Full Batch Training来说引入了Noise，而Noise具有波动的效果，这在论文里被称为Flucturate，它可以在更新时在一定程度上偏离Sharp Minima，从而进入Broad Minima，进而有了较好的泛化性，所以Noise起了较大的作用。进一步的，论文中将SGD的更新公式进行进行分析，等价为一个微分方程的定积分结果，通过将SGD更新公式与微分方程进行等价，导出了Flucturate的表达式，确定了影响其值的变动因素，即和Learning Rate与Batch size有关。若把Flucturate看做常量，那么Learning Rate与Batch Size可以近似看做是线性关系，这与论文2中的Learning Rate Scaling Rule一致。总体来说，这篇论文数学理论相对丰满的解释了Learning Rate Scaling Rule。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div data-type=&quot;p&quot;&gt;
&lt;ul&gt;&lt;li&gt;《&lt;a href=&quot;https://arxiv.org/pdf/1711.00489.pdf&quot; target=&quot;_blank&quot;&gt;Don't Decay the Learning Rate, Increase the Batch Size&lt;/a&gt;》：这是Google发在ICLR 2018上的第二篇论文，这篇论文的实验和结论非常简单，但是理论基础依然来自于论文3，所以阅读此篇论文之前一定要精度论文3。该论文从推导出的Mini Batch SGD的Flucturate公式出发，提出了一种使用Large Batch Training的加速方法。因为在一个完整的模型训练过程中，通常会随着轮数的增加而适当对Learning Rate做Decay。通过论文3中给出的公式，即Flucturate固定时，Learning Rate与Batch Size成正比关系，引发了思考：究竟是Learning Rate本身需要Decay才能使训练过程继续，还是Learning Rate的Decay间接影响了Noise的Flucturate才能使训练过程继续？通过实验验证，真正影响训练过程的本质是Noise的Flucturate。因此我们考虑到Learning Rate与Batch Size的正比例关系，我们可以固定Learning Rate不变，而将Batch Size增加N倍来缩小Noise的Flucturate。定时增加Batch Size不但可以维持原有方式的Flucturate，还可以加速训练过程，减少Update的更新频次，增加计算通信占比，提高加速比。总体来说，该论文基于论文3为理论基础，提出了一种逐渐增加Batch Size提高计算加速比和收敛加速比的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;可以按顺序梳理成以下几个方面&lt;/p&gt;
&lt;h2 data-type=&quot;p&quot;&gt;理论基础&lt;/h2&gt;
&lt;ul&gt;&lt;li data-type=&quot;p&quot;&gt;从贝叶斯理论角度出发，论证Broad Minima相对于Sharp Minima具有更好的泛化性&lt;/li&gt;
&lt;li data-type=&quot;p&quot;&gt;用贝叶斯理论解释泛化性是有效的&lt;/li&gt;
&lt;li data-type=&quot;p&quot;&gt;贝叶斯理论与SGD&lt;/li&gt;
&lt;li data-type=&quot;p&quot;&gt;随机偏微分方程的与Scaling Rule的推导&lt;/li&gt;
&lt;/ul&gt;&lt;h2 data-type=&quot;p&quot;&gt;优化方法&lt;/h2&gt;
&lt;ul&gt;&lt;li data-type=&quot;p&quot;&gt;使用Large Batch Training提高训练速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理论基础来自于论文《A BAYESIAN PERSPECTIVE ON GENERALIZATION AND STOCHASTIC GRADIENT DESCENT》，这里只对重点内容进行记录。&lt;/p&gt;
&lt;h2 id=&quot;4d8esf&quot; data-type=&quot;h&quot;&gt;从贝叶斯理论角度出发，论证broad minima相对于sharp minima具有更好的泛化性&lt;/h2&gt;
&lt;h3&gt;内容&lt;/h3&gt;
&lt;p&gt;这部分公式较多，但确实是贝叶斯的理论基础，所以尽量以简单的形式展现出来。首先假设某模型M只有一个参数w，训练样本为x，Label为y，那么可以跟据贝叶斯公式直接写出下面的等式&lt;/p&gt;
&lt;div data-type=&quot;p&quot; readability=&quot;9&quot;&gt;其中等号右面分母上的第一项可以看做似然函数
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523431713301-2cb45408-bef2-4bfe-ab84-b3a6ab8c1a59.png&quot; data-width=&quot;487&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523431713301-2cb45408-bef2-4bfe-ab84-b3a6ab8c1a59.png&quot; alt=&quot;&quot; width=&quot;487&quot;/&gt;&lt;/div&gt;
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523432233804-5c54a7ab-c68e-4eb9-8e00-37d77318e909.png&quot; data-width=&quot;354&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523432233804-5c54a7ab-c68e-4eb9-8e00-37d77318e909.png&quot; alt=&quot;&quot; width=&quot;354&quot;/&gt;&lt;/div&gt;
一般情况下，我们对模型参数的分布会做高斯假设&lt;/div&gt;
&lt;div data-type=&quot;p&quot;&gt;
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523432208323-8d318ac3-7c8d-4bad-ac07-255c2635f056.png&quot; data-width=&quot;248&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523432208323-8d318ac3-7c8d-4bad-ac07-255c2635f056.png&quot; alt=&quot;&quot; width=&quot;248&quot;/&gt;&lt;/div&gt;
所以有&lt;/div&gt;

&lt;div data-type=&quot;p&quot;&gt;
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523435738321-dbe47b4f-b61f-4e52-a670-4ea021d51029.png&quot; data-width=&quot;459&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523435738321-dbe47b4f-b61f-4e52-a670-4ea021d51029.png&quot; alt=&quot;&quot; width=&quot;459&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;分析方法相同，不再赘述。&lt;/p&gt;
&lt;h3 data-type=&quot;p&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;这一部分作者从贝叶斯理论出发，从公式上推导出了Occam Razor的结论，并且论证了落入Sharp Minima的模型泛化性较差的原因，同时也得出了正则项对Sharp Minima具有惩罚作用。&lt;/p&gt;
&lt;h2 id=&quot;kk69hg&quot; data-type=&quot;h&quot;&gt;用贝叶斯理论解释泛化性是有效的&lt;/h2&gt;
&lt;h3 data-type=&quot;p&quot;&gt;内容&lt;/h3&gt;
&lt;p&gt;这里作者借鉴了论文《Understanding deep learning requires rethinking generalization》中的实验来从贝叶斯理论解释泛化性，与ICLR 2017的这篇Best Paper使用的Deep Learning Model不同，作者使用了最简单的线性模型进行实验，原因是线性模型在计算Bayesian Evidence的时候比Deep Learning简单很多。具体的实验配置可以参考论文，这里直接给出图表。&lt;/p&gt;
&lt;div data-type=&quot;p&quot;&gt;&lt;span data-type=&quot;ranges&quot;&gt;&lt;span data-type=&quot;ranges&quot;&gt;注：Bayesian Evidence实际上是Log Bayesian Evidence，对上面的结果取了对数。&lt;/span&gt;&lt;/span&gt;
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523437709435-73bb13eb-9029-4e1d-944b-60ef7dfe07ff.png&quot; data-width=&quot;748&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523437709435-73bb13eb-9029-4e1d-944b-60ef7dfe07ff.png&quot; alt=&quot;&quot; width=&quot;748&quot;/&gt;&lt;/div&gt;
&lt;span data-type=&quot;ranges&quot;&gt;这个实验主要是为了证明Bayesian Evidence的曲线和Test Cross Entropy的变化趋势是一致的，并且也复现了《Understanding deep learning requires rethinking generalization》中呢Deep Learning Model的结果。&lt;/span&gt;&lt;/div&gt;
&lt;h3 data-type=&quot;p&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;这一节中的实验证明，使用贝叶斯理论解释泛化性是有效的，并且得出了预期一致的结果。&lt;/p&gt;
&lt;h2 id=&quot;hsn0qi&quot; data-type=&quot;h&quot;&gt;贝叶斯理论与SGD&lt;/h2&gt;
&lt;h3&gt;内容&lt;/h3&gt;
&lt;p&gt;&lt;span data-type=&quot;ranges&quot;&gt;在得出Bayesian Evidence和泛化性是强相关关系的结论之后，作者再次对SGD产生了思考。因为无论是Large Batch还是Small Batch，他们都是Full Batch的近似结果，所以都会引入Noise。作者认为造成不同Batch Size产生不同泛化性的根本原因是Noise的Flucturate程度。一定程度的Noise可以逃离Sharp Minima，带领模型进入Bayesian Evidence较大的区域，即Broad Minima区域；而Batch Size越大，Noise的Flucturate就越小，就很容易陷入Sharp Minima。（这部分的公式推导在这里先不给出，因为这不是这篇文章的重点，有兴趣的同学可以关注这篇论文的附录A）这说明SGD的更新规则本身就带有了一些正则化效果，这个正则化的效果很大程度上来自于SGD本身引入的Noise。这与ICLR 2017 Best Paper《Understanding deep learning requires rethinking generalization》观察到的现象和得出的结论一致，该篇文章中主要思考的一个问题是，SGD在训练完全部样本之后，为什么不是记住所有的样本，而是还学到了一些泛化性？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;回到这篇论文，作者认定一定存在一个最佳Batch Size，这个Batch Size既没有使模型进入Sharp Minima区域，又有一定的复杂性，使之让当前的模型效果最好。于是做了不同的实验，得到以下结果。&lt;/p&gt;
&lt;div data-type=&quot;p&quot; readability=&quot;9&quot;&gt;
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523439122070-282f28ae-cea9-40c8-98f0-007565acb5a5.png&quot; data-width=&quot;748&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523439122070-282f28ae-cea9-40c8-98f0-007565acb5a5.png&quot; alt=&quot;&quot; width=&quot;748&quot;/&gt;&lt;/div&gt;
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523439167467-0d10edf2-0e82-4478-b3cf-3559d5800953.png&quot; data-width=&quot;748&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523439167467-0d10edf2-0e82-4478-b3cf-3559d5800953.png&quot; alt=&quot;&quot; width=&quot;748&quot;/&gt;&lt;/div&gt;
这些实验其实就是验证不同Batch Size训练出的模型在test集上的表现，并说明存在一个最佳的Batch Size，使用它训练出的模型，其泛化性优于其他Batch Size训练出的模型。&lt;/div&gt;
&lt;h3 data-type=&quot;p&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;这一部分从对贝叶斯与泛化性的思考入手，进而尝试解释SGD的特点，从而试图验证不同Batch Size对泛化性的影响。Batch Size的选取可以看成是Depth(Sharp)和Breadth(Broad)的Trade off，所以存在一个最佳的Batch Size，在其他超参数固定时使模型达到最好的泛化效果。&lt;/p&gt;
&lt;h2 id=&quot;pmf4gn&quot; data-type=&quot;h&quot;&gt;随机偏微分方程的与scaling rule的推导&lt;/h2&gt;
&lt;h3 data-type=&quot;p&quot;&gt;内容&lt;/h3&gt;
&lt;p&gt;因为Batch Size的选取，从贝叶斯角度去理解，实际上就是Depth和Breadth的Trade off。所以可以更进一步的对SGD引入的Noise进行分析，进一步去探究这个Noise带来的Flucturate与哪些因素相关，这就需要和随机偏微分方程建立联系了。&lt;/p&gt;
&lt;div data-type=&quot;p&quot; readability=&quot;7&quot;&gt;首先，将SGD的update公式进行改写。
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523439830188-d789bda9-a191-4452-ae41-cf085929d5d1.png&quot; data-width=&quot;478&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523439830188-d789bda9-a191-4452-ae41-cf085929d5d1.png&quot; alt=&quot;&quot; width=&quot;478&quot;/&gt;&lt;/div&gt;
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523440055233-aeb426bf-d824-4635-a73b-10ce0ddc988a.png&quot; data-width=&quot;182&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523440055233-aeb426bf-d824-4635-a73b-10ce0ddc988a.png&quot; alt=&quot;&quot; width=&quot;182&quot;/&gt;&lt;/div&gt;
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523440317811-27ef34d2-1b45-4bcb-a41d-0401160f989e.png&quot; data-width=&quot;180&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523440317811-27ef34d2-1b45-4bcb-a41d-0401160f989e.png&quot; alt=&quot;&quot; width=&quot;180&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div data-type=&quot;p&quot;&gt;&lt;span data-type=&quot;ranges&quot;&gt;&lt;span data-type=&quot;ranges&quot;&gt;所以，我们得到了相当重要的结论，这是在一定程度上能够解释Learning Rate Scaling Rule的结论。&lt;/span&gt;&lt;/span&gt;
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523441940070-efa44701-25ac-434e-bd1a-b3daab9faa31.png&quot; data-width=&quot;204&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523441940070-efa44701-25ac-434e-bd1a-b3daab9faa31.png&quot; alt=&quot;&quot; width=&quot;204&quot;/&gt;&lt;/div&gt;
&lt;span data-type=&quot;ranges&quot;&gt;所以，我们得到了结论，SGD引入了一些Noise，这个Noise具有一定的Flucturate，它的大小是和Batch Size成反比，与Learning Rate成正比。&lt;/span&gt;&lt;/div&gt;
&lt;h3 data-type=&quot;p&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;这一节使用偏微分方程和SGD的更新规则，经过一系列的数学推导，得到了SGD引入的Noise对更新过程的Flucturation大小与Batch size和Learning rate的关系。这是这篇论文十分重要的结论，也是Learning Rate Scaling Rule的理论基石。&lt;/p&gt;
&lt;h2 id=&quot;332zsm&quot; data-type=&quot;h&quot;&gt;理论总结&lt;/h2&gt;
&lt;p&gt;至此，理论基础部分梳理完毕，虽然公式较多较为复杂，但是结论却非常简单。作者从贝叶斯理论的角度出发，推导出了Occam Razor的形式表达，并从公式上论证了Sharp Minima相对于Broad Minima泛化性差的原因。而后又验证了Bayesian Evidence和模型泛化性一致的结论，进而从贝叶斯理论的角度对SGD的更新过程进行了猜测：SGD会引入Noise，而正是Noise的Flucturate帮助模型在更新过程中逃离Sharp Minima，进入更高的Bayesian Evidence区域，即Broad Minima，所以指出Batch Size的选择实际上是Noise Flucturate的调整，本质上是Sharp Minima和Broad Minima的Trade off。最后作者通过将SGD更新公式进行改写，并联合偏微分方程，得出了Noise的Fluctruate的形式表达，它Batch Size成反比，和Learning Rate成正比。&lt;/p&gt;
&lt;p&gt;之前FAIR发表的论文《Accurate, Large Minibatch SGD:Training ImageNet in 1 Hour》中提出了Learning Rate Scaling Rule在ResNet上具有很好的效果，该论文在实验上做的比较充分，但是在理论上并没有特别Solid，而Google的这篇论文可以作为它的理论基石之一。&lt;/p&gt;

&lt;p&gt;优化方法来自论文《Don't Decay the Learning Rate, Increase the Batch Size》，这篇论文在理解完前一篇论文之后会显得非常简单，完全是一篇实验性论文，实验做得较为充分，这里只会对重要内容做个简单的梳理。&lt;/p&gt;
&lt;h2 id=&quot;lcskqf&quot; data-type=&quot;h&quot;&gt;理论基础公式&lt;/h2&gt;
&lt;div data-type=&quot;p&quot; readability=&quot;9&quot;&gt;对于SGD来说，Flucturation形式表达为
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523441940070-efa44701-25ac-434e-bd1a-b3daab9faa31.png&quot; data-width=&quot;204&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523441940070-efa44701-25ac-434e-bd1a-b3daab9faa31.png&quot; alt=&quot;&quot; width=&quot;204&quot;/&gt;&lt;/div&gt;
对于Momentum-SGD来说，形式表达为(公式推导来自于langvein动力学)
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523443026811-231d78fe-e5c7-4c4e-b972-47b84ba65b93.png&quot; data-width=&quot;224&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523443026811-231d78fe-e5c7-4c4e-b972-47b84ba65b93.png&quot; alt=&quot;&quot; width=&quot;224&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;1t7san&quot; data-type=&quot;h&quot;&gt;Large batch training的优化原理&lt;/h2&gt;
&lt;div data-type=&quot;p&quot; readability=&quot;10&quot;&gt;无论是SGD还是Momentum-SGD，我们都可以发现g与Batch Size成反比，与Learning Rate成正比，而在一般的Deep Learning Model训练过程中，会在固定轮数对Learning Rate做Decay，这个过程让作者引发了思考，究竟在训练过程中，泛化性的提升是由于Learning Rate做Decay导致的，还是g发生变化导致的？如果是后者，那么定时增加Batch Size也应该会达到同样的效果，因此作者做了几组实验。
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523443289679-48bc1978-0319-48d3-b5f6-d10fc16c080e.png&quot; data-width=&quot;748&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523443289679-48bc1978-0319-48d3-b5f6-d10fc16c080e.png&quot; alt=&quot;&quot; width=&quot;748&quot;/&gt;&lt;/div&gt;
&lt;span data-type=&quot;ranges&quot;&gt;作者做了三组实验，一组是标准的对Learning Rate做Decay，一组是固定Rearning Rate不变，在原来发生Learning Rate Decay的轮数将Batch Size扩大N倍（N是Learning Rate Decay的Factor，即与Learning Rate的Decay为相同力度）。另一组是二者的结合Hybrid，即先Learning Rate Decay，后变化Batch Size。实验证明三者的泛化性曲线相同，所以证明了Learning Rate Decay实际上是对g做了Scale down。然而增加Batch Size不但可以达到同样的效果，还能提高计算通信占比，并且在整体训练过程中减少Update的次数，这是Increase Batch Size Training的优化点。&lt;/span&gt;&lt;/div&gt;
&lt;h2 id=&quot;a71mgv&quot; data-type=&quot;h&quot;&gt;关于Momentum-SGD&lt;/h2&gt;
&lt;p&gt;在Momentum-SGD的flucturation形式表达中，我们还看到了momentum的作用，即增加m的值可以增加g的值。但是实验证明，增加m同时扩大batch size得到的泛化性相对于改变learning rate和batch size要差一些。这是因为提高momentum会使Momentum-SGD中的accumulator需要更多的轮数才能到达稳定的状态，而在到达稳定状态之前，update的scale是会被supressed的，作者在论文附录中论证了这一观点，这里不再详细赘述。后续的实验也证明了这一点。&lt;/p&gt;
&lt;div data-type=&quot;p&quot;&gt;
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523444304026-8e0775f5-3a28-4529-8b24-4623a8c5680e.png&quot; data-width=&quot;579&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523444304026-8e0775f5-3a28-4529-8b24-4623a8c5680e.png&quot; alt=&quot;&quot; width=&quot;579&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;srdyqi&quot; data-type=&quot;h&quot;&gt;更大Batch Size和消除Warm Up&lt;/h2&gt;
&lt;p&gt;在论文《Accurate, Large Minibatch SGD:Training ImageNet in 1 Hour》中，作者实验的最大Batch Size为8192。然而在这篇论文中，作者使用更大的初始Batch Size（最大尝试到65536）对ImageNet进行训练，并且在固定的轮数对Noise做Decay（增加Batch Size）。作者消去了Warm Up的过程，但是引入了Mometum的超参调优，当使用更大Batch Size时，不仅调整初始Learning Rate，还增加m值来进一步放大Noise，帮助训练过程逃离Sharp Minima。实验效果如下。&lt;/p&gt;
&lt;div data-type=&quot;p&quot;&gt;
&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;left&quot; data-src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523444722347-9354dbde-4270-4e45-85c0-a01c054e1510.png&quot; data-width=&quot;748&quot;&gt;&lt;img src=&quot;https://cdn.yuque.com/lark/2018/png/38749/1523444722347-9354dbde-4270-4e45-85c0-a01c054e1510.png&quot; alt=&quot;&quot; width=&quot;748&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;aqk4zb&quot; data-type=&quot;h&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;此篇论文更像是《A BAYESIAN PERSPECTIVE ON GENERALIZATION AND STOCHASTIC GRADIENT DESCENT》工作的延续，以该篇论证的理论基础出发，得出了一种提高训练计算加速比和收敛加速比的方法。结论和实验比较简单，但背后的数学推导较为复杂。&lt;/p&gt;

&lt;p&gt;工业界的分布式算力提升对Large Batch Training提出了需求，因为增加Batch Size显然是提高计算通信占比的最佳方式，所以Large Batch Training固有的收敛性问题就成为了学术界研究的重点方向。本文通过梳理近些年来学术界对Large Batch Training的论文研究，从理论角度阐述了Large Batch Training造成收敛性较差的原因——容易陷入Broad Minima。而Google发表的论文从贝叶斯角度给出了另外的解释——不同Batch Size训练引入的Noise不同造成Fluctuate也不同，最终导致收敛性的不同。为了验证这一观点，Google又从实践角度给出了验证——通过固定Learning Rate，逐步增大Batch Size来稳定Fluctuate，达到使用大Batch Size加速训练的目的。截止到目前，这些理论方面的论证和解释依然处于蓬勃发展之中，未来还会有更深入研究在学术界中出现。&lt;/p&gt;

</description>
<pubDate>Sun, 20 Jan 2019 15:12:00 +0000</pubDate>
<dc:creator>DeepLearningStack</dc:creator>
<og:description>背景 [作者：DeepLearningStack，阿里巴巴算法工程师，开源TensorFlow Contributor] 在分布式训练时，提高计算通信占比是提高计算加速比的有效手段，当网络通信优化到一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/deep-learning-stacks/p/10296637.html</dc:identifier>
</item>
<item>
<title>关于Python中包裹传参和解包裹的理解 - HeZhengfa</title>
<link>http://www.cnblogs.com/HeZhengfa/p/10296508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HeZhengfa/p/10296508.html</guid>
<description>&lt;h3&gt;1.包裹传参&lt;/h3&gt;
&lt;p&gt;首先思考一个问题：为什么要有包裹传参？原因包括但不仅限于以下两点：①不确定参数的个数。②希望函数定义的更加松散灵活&lt;/p&gt;
&lt;p&gt;包裹传参分两种：包裹位置传参和包裹关键字传参。先看包裹位置传参：&lt;/p&gt;
&lt;p&gt;在这里，如果先说定义肯定有些晦涩难懂，我们直接看下面这个例子吧！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; package_position(*&lt;span&gt;all_arguments):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(all_arguments))
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(all_arguments)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里定义了一个函数package_position(),其传入参数与一般的参数不一样，前面有一个*号，表明这是一个包裹，接下来调用的时候如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; package_position(1, 4, 6&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; package_position(5, 6, 7, 1, 2, 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么打印的结果呢，是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371094/201901/1371094-20190120220506453-1152311596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据函数的定义，我们知道，打印的第一行是传入的参数的类型（即type)，根据打印结果，我们知道这是一个tuple，即元祖类型。也就是说，当我们在调用这个方法的时候，传入的参数1，4，6，最后全部包在一起，封装成一个tuple，传递给函数内部。打印的第二行，就是该元祖的内容。然后，根据打印结果的第二行，我们可以知道，这就是我们在调用时传入的1，4，6。&lt;/p&gt;
&lt;p&gt;总结一下：在调用package_position()时，所有的数据都根据先后顺序，收集到一个元祖，在函数内部，我们可以通过元祖来读取传入的数据，这就是包裹位置传参。&lt;/p&gt;
&lt;p&gt;再来看看什么时包裹关键字传参：&lt;/p&gt;
&lt;p&gt;有了以上包裹位置传参，那么包裹关键字传参就不多说了，还是直接看例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; package_keyword(**&lt;span&gt;all_arguments):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(all_arguments))
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(all_arguments)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; package_keyword(a = 1, b = 9&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; package_keyword(m = 2, n = 1, c = 11)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与上面一个例子类似，当函数调用时，所有参数会收集到一个数据容器里。只不过，在包裹关键字传递的时候，，数据容器不再是一个元祖，而时一个字典。每个关键字形式的参数调用，都会成为字典的一个元素。参数名为元素的键，而数据成为元素的值。字典all_arguments收集了所有的参数，把数据传递给函数使用。为了提醒，参数all_arguments是包裹关键字传递所有的字典，因此在all_arguments前加**。打印结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371094/201901/1371094-20190120223212687-436517013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.解包裹&lt;/h3&gt;
&lt;p&gt; 除了用于函数定义，*和**还可用于函数调用。这时候，两者是为了实现一种叫作解包裹（unpacking）的语法。解包裹允许我们把一个数据容器传递给函数，再自动地分解为各个参数。需要注意的是，包裹传参和解包裹并不是相反操作，而是两个相对独立的功能（但给人的感觉就是两个相反的操作）。下面是解包裹的一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; unpackage(a, b, c):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a, b, c)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; args = (1, 3, 4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; unpackage(*&lt;span&gt;args)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; args = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:2, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:3&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; unpackage(**args)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据上面的代码，估计读者也大概知道了关于解包裹的概念。我们调用函数时传递的是一个元祖，按照基本传参的方式，一个元祖是无法和三个参数对应上的。但我们通过在args前加上*符号，来提醒Python，我想把元祖拆成三个元素，每一个元素对应函数的一个位置参数。于是，元祖的三个元素分别赋予了三个参数。&lt;/p&gt;
&lt;p&gt;相应的，词典也可用于解包裹（上述代码第7，8行）。在传递词典args时，让词典的每个键值对作为一个关键字传递给函数。&lt;/p&gt;

</description>
<pubDate>Sun, 20 Jan 2019 14:41:00 +0000</pubDate>
<dc:creator>HeZhengfa</dc:creator>
<og:description>1.包裹传参 首先思考一个问题：为什么要有包裹传参？原因包括但不仅限于以下两点：①不确定参数的个数。②希望函数定义的更加松散灵活 包裹传参分两种：包裹位置传参和包裹关键字传参。先看包裹位置传参： 在这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HeZhengfa/p/10296508.html</dc:identifier>
</item>
<item>
<title>SpringBoot(二十五)整合Redis之@Cacheable、@CachePut、@CacheEvict的应用 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/cacheable.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/cacheable.html</guid>
<description>&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;29.797592997812&quot;&gt;
&lt;blockquote readability=&quot;7.3347921225383&quot;&gt;
&lt;p&gt;在上一篇文章(&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://www.cnblogs.com/toutou/p/spring_boot_redis.html&quot; target=&quot;_blank&quot;&gt;《SpringBoot(二十四)整合Redis》&lt;/a&gt;)中，已经实现了Spring Boot对Redis的整合，既然已经讲到Cache了，今天就介绍介绍缓存注解。各家互联网产品现在数据量越来越大，其快速增长造成网络拥塞和服务器超载，导致客户访问延迟增大，服务质量日益显现出来。缓存技术被认为是减轻服务器负载、降低网络拥塞、增强可扩展性的有效途径之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;概念介绍&lt;/h2&gt;
&lt;p&gt; Spring为我们提供了几个注解来支持Spring Cache。其核心主要是@Cacheable和@CacheEvict。使用@Cacheable标记的方法在执行后Spring Cache将缓存其返回结果，而使用@CacheEvict标记的方法会在方法执行前或者执行后移除Spring Cache中的某些元素。下面我们将来详细介绍一下Spring基于注解对Cache的支持所提供的几个注解。&lt;/p&gt;
&lt;p&gt;Spring Cache常见概念介绍&lt;/p&gt;
&lt;div&gt;
&lt;table class=&quot;cnblogs_toutou&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Cache&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CacheManager&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;缓存管理器，管理各种缓存（cache）组件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@Cacheable&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;主要针对方法配置，能够根据方法的请求参数对其进行缓存&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@CacheEvict&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;清空缓存&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;@CachePut&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;保证方法被调用，又希望结果被缓存。&lt;br/&gt;与@Cacheable区别在于是否每次都调用方法，常用于更新&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@EnableCaching&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;开启基于注解的缓存&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;keyGenerator&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;缓存数据时key生成策略&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;serialize&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;缓存数据时value序列化策略&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;@CacheConfig&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;统一配置本类的缓存注解的属性&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;注解(@Cacheable/@CachePut/@CacheEvict)的主要参数&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;example&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;19&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;缓存的名称，在 spring 配置文件中定义，必须指定至少一个&lt;/td&gt;
&lt;td&gt;e.g.&lt;br/&gt;@Cacheable(value=”mycache”) 或者&lt;br/&gt;@Cacheable(value={”cache1”,”cache2”}&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;key&lt;/td&gt;
&lt;td&gt;缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，&lt;br/&gt;如果不指定，则缺省按照方法的所有参数进行组合&lt;/td&gt;
&lt;td&gt;e.g.&lt;br/&gt;@Cacheable(value=”testcache”,key=”#id”)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;condition&lt;/td&gt;
&lt;td&gt;缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，&lt;br/&gt;只有为 true 才进行缓存/清除缓存&lt;/td&gt;
&lt;td&gt;e.g.@Cacheable(value=”testcache”,condition=”#userName.length()&amp;gt;2”)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;unless&lt;/td&gt;
&lt;td&gt;否定缓存。当条件结果为TRUE时，就不会缓存。&lt;/td&gt;
&lt;td&gt;e.g.@Cacheable(value=”testcache”,unless=”#userName.length()&amp;gt;2”)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;allEntries&lt;br/&gt;(@CacheEvict )&lt;/td&gt;
&lt;td&gt;是否清空所有缓存内容，缺省为 false，如果指定为 true，&lt;br/&gt;则方法调用后将立即清空所有缓存&lt;/td&gt;
&lt;td&gt;e.g.&lt;br/&gt;@CachEvict(value=”testcache”,allEntries=true)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;beforeInvocation&lt;br/&gt;(@CacheEvict)&lt;/td&gt;
&lt;td&gt;是否在方法执行前就清空，缺省为 false，如果指定为 true，&lt;br/&gt;则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法&lt;br/&gt;执行抛出异常，则不会清空缓存&lt;/td&gt;
&lt;td&gt;e.g.&lt;br/&gt;@CachEvict(value=”testcache”，beforeInvocation=true)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;准备工作&lt;/h2&gt;
&lt;p&gt;1.1 引入依赖pom.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-cache&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;激活启动类注解@EnableCaching&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201901/506684-20190118174940819-1501106755.png&quot; alt=&quot;SpringBoot(二十五)整合Redis之@Cacheable、@CachePut、@CacheEvict的应用&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;实战演练&lt;/h2&gt;
&lt;p&gt;2.1 添加service层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.demo.pojo.UserDetails;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by toutou on 2019/1/20.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; CacheService {
    UserDetails getUserDetailsByUid(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; uid);

    UserDetails updateUserInfo(UserDetails userDetails);

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; delUserInfoById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; uid);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.demo.dao.UserDetailsMapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.demo.pojo.UserDetails;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.CacheEvict;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.CachePut;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cache.annotation.Cacheable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by toutou on 2019/1/20.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CacheServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CacheService{

    @Autowired
    UserDetailsMapper userDetailsMapper;

    @Override
    @Cacheable(value &lt;/span&gt;= &quot;user_details&quot;, key = &quot;#uid&quot;, unless=&quot;#result == null&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserDetails getUserDetailsByUid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; uid){
        System.out.println(&lt;/span&gt;&quot; Cacheable 有请求过来了&quot;&lt;span&gt;);
        UserDetails userDetails &lt;/span&gt;=&lt;span&gt; userDetailsMapper.getUserDetailsByUid(uid);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userDetails;
    }

    @Override
    @CachePut(value &lt;/span&gt;= &quot;user_details&quot;, key = &quot;#user.id&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserDetails updateUserInfo(UserDetails user){
        System.out.println(&lt;/span&gt;&quot; CachePut 有请求过来了&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(userDetailsMapper.updateByPrimaryKeySelective(user) &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里也可以直接在updateByPrimaryKeySelective的方法里，修改后直接查询出该记录返回UserDetails实例，看需求。&lt;/span&gt;
            user =&lt;span&gt; userDetailsMapper.getUserDetailsByUid(user.getId());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    @Override
    @CacheEvict(value &lt;/span&gt;= &quot;user_details&quot;, key = &quot;#uid&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; delUserInfoById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; uid){
        System.out.println(&lt;/span&gt;&quot; CacheEvict 有请求过来了&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userDetailsMapper.deleteByPrimaryKey(uid);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;unless=&quot;#result == null&quot;&lt;/code&gt;是指当查询为空时，不缓存，默认是空也会缓存。&lt;/p&gt;
&lt;p&gt;2.2 添加CacheController&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.demo.pojo.UserDetails;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.demo.service.CacheService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.extern.slf4j.Slf4j;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by toutou on 2019/1/20.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
@Slf4j
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CacheController {

    @Autowired
    CacheService cacheService;

    @RequestMapping(value &lt;/span&gt;= &quot;/cache/getuserbyid&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserDetails getUserDetailsByUid(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; uid){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cacheService.getUserDetailsByUid(uid);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            System.out.println(e.toString());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    @RequestMapping(value &lt;/span&gt;= &quot;/cache/updateuserinfo&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; updateUserInfo(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; uid, String city){
        UserDetails userDetails &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserDetails();
        userDetails.setId(uid);
        userDetails.setCity(city);
        userDetails &lt;/span&gt;=&lt;span&gt; cacheService.updateUserInfo(userDetails);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; userDetails == &lt;span&gt;null&lt;/span&gt; ? 0&lt;span&gt; : userDetails.getUid();
    }

    @RequestMapping(value &lt;/span&gt;= &quot;/cache/deluserinfobyid&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; delUserInfoById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; uid){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cacheService.delUserInfoById(uid);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.3 实现Serializable接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201901/506684-20190118175043998-1615468791.png&quot; alt=&quot;SpringBoot(二十五)整合Redis之@Cacheable、@CachePut、@CacheEvict的应用&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_3&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;效果展示&lt;/h2&gt;
&lt;p&gt;3.1 Cacheable效果&lt;/p&gt;
&lt;p&gt;当我们本地请求http://localhost:8081/cache/getuserbyid?uid=5接口时，可以看到控制台输出&lt;code&gt;Cacheable 有请求过来了&lt;/code&gt;,而后续再次请求该接口时，不会再输出&lt;code&gt;Cacheable 有请求过来了&lt;/code&gt;，这是因为直接走了缓存机制了，CacheServiceImpl的方法不再被调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201901/506684-20190118175051640-1712759876.png&quot; alt=&quot;SpringBoot(二十五)整合Redis之@Cacheable、@CachePut、@CacheEvict的应用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过Redis可以看到，&lt;code&gt;user_details::5&lt;/code&gt;的记录已被创建。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201901/506684-20190118175057057-1764658083.png&quot; alt=&quot;SpringBoot(二十五)整合Redis之@Cacheable、@CachePut、@CacheEvict的应用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.2 CachePut效果&lt;/p&gt;
&lt;p&gt;当我们本地请求http://localhost:8081/cache/updateuserinfo?uid=5&amp;amp;city=首都 接口时，将更新数据库和Redis中对应的字段值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201901/506684-20190118175102584-1469234033.png&quot; alt=&quot;SpringBoot(二十五)整合Redis之@Cacheable、@CachePut、@CacheEvict的应用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查询接口，更新成功。控制台再次输出&lt;code&gt;Cacheable 有请求过来了&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201901/506684-20190118175108399-528622334.png&quot; alt=&quot;SpringBoot(二十五)整合Redis之@Cacheable、@CachePut、@CacheEvict的应用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.3 CacheEvict效果&lt;/p&gt;
&lt;p&gt;当我们本地请求http://localhost:8081/cache/deluserinfobyid?uid=5 接口时，将删除数据中和Redis中的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201901/506684-20190118175114446-292578496.png&quot; alt=&quot;SpringBoot(二十五)整合Redis之@Cacheable、@CachePut、@CacheEvict的应用&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_4&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;博客总结&lt;/h2&gt;
&lt;blockquote readability=&quot;4.7333333333333&quot;&gt;
&lt;p&gt;Redis和@Cacheable、@CachePut、@CacheEvict结合使用，效果挺好，结合这篇和上篇文章(&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://www.cnblogs.com/toutou/p/spring_boot_redis.html&quot; target=&quot;_blank&quot;&gt;《SpringBoot(二十四)整合Redis》&lt;/a&gt;)，可以尝试着结合使用试试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://github.com/toutouge/javademo/tree/master/hellospringboot&quot; target=&quot;_blank&quot;&gt;https://github.com/toutouge/javademo/tree/master/hellospringboot&lt;/a&gt;&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 20 Jan 2019 14:16:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>在上一篇文章(《SpringBoot(二十四)整合Redis》)中，已经实现了Spring Boot对Redis的整合，既然已经讲到Cache了，今天就介绍介绍缓存注解。各家互联网产品现在数据量越来越</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/cacheable.html</dc:identifier>
</item>
<item>
<title>only_full_group_by问题而引发的对group by的深入思考 - 翎野</title>
<link>http://www.cnblogs.com/lingyejun/p/10296279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lingyejun/p/10296279.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近在项目中使用mysql的group by进行分组查询的场景比较多，其中一次遇到了一个问题，即在开发环境执行一个如下sql时是正确且可执行的，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
select a,b,max(c) from test_tbl group by a
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;但是放到了测试环境就会报如下的错误。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column 'your_tbl...' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;因为开发环境和测试环境所使用的mysql数据库的版本不一样，开发环境使用的时候5.6.x而测试环境使用的是5.7.x，而在Mysql的5.7.x版本中默认是开启&lt;em&gt;&lt;code&gt;sql_mode = only_full_group_by&lt;/code&gt;&lt;/em&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;而在这个模式下，我们使用分组查询时，出现在select字段后面的只能是group by后面的分组字段，或使用聚合函数包裹着的字段。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在上面的sql中，字段b既不是group by里面的分组字段，也没有被聚合函数包裹着。5.7以下的版本不进行检查，而5.7以上的版本进行了&lt;em&gt;&lt;code&gt;sql_mode=only_full_group_by&lt;/code&gt;&lt;/em&gt;的检查，所以会出现以上的问题，当然解决方法也很简单，将b也纳入到分组字段中即可。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;虽然在工作中会频繁的使用到group by进行分组查询，但自己对数据分组这个概念一直很模糊，这次就借着这个机会，通过一个简单的示例来帮助大家在脑海中建立起来数据分组这个抽象概念。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们创建一张如下的数据表&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
CREATE TABLE `product` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',
  `product_name` varchar(100) NOT NULL COMMENT '商品名称',
  `brand_name` varchar(100) DEFAULT NULL COMMENT '品牌名称',
  `category_name` varchar(100) NOT NULL COMMENT '商品分类',
  `price` decimal(10,4) NOT NULL COMMENT '价格'
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COMMENT='测试用的商品表';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;表中有如下数据&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
mysql&amp;gt; select * from product;
+----+---------------+------------+---------------+-------+
| id | product_name  | brand_name | category_name | price |
+----+---------------+------------+---------------+-------+
|  1 | XiaoMi6X      | XiaoMi     | 手机          | 2999  |
|  2 | XiaoAi        | Lenovo     | 电脑          | 8999  |
|  3 | HUAWEI K1     | HUAWEI     | 手机          | 1999  |
|  4 | iPhone X      | iPhone     | 手机          | 9999  |
|  5 | MacBook Pro   | Mac        | 电脑          | 13999 |
|  6 | iPhone XMAX   | iPhone     | 手机          | 10999 |
|  7 | HUAWEI Mate20 | HUAWEI     | 手机          | 2999  |
+----+---------------+------------+---------------+-------+
7 rows in set
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;articleHeader3&quot;&gt;一个最高价&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们使用group by按照品牌类目(category_name)进行分组，并获取该分组中的最高价格。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
mysql&amp;gt; select category_name,max(price) from product group by category_name;
+---------------+------------+
| category_name | max(price) |
+---------------+------------+
| 手机          | 10999      |
| 电脑          | 13999      |
+---------------+------------+
2 rows in set
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个简单的分组sql相信也难不倒大家，那么让我们来看看这个分组查询语句是如何取到最终结果的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;过程：&lt;/strong&gt;如下图所示，首先从数据集中筛选出来类目为手机的所有记录（以蓝色线框标明）和类目为电脑的所有记录（以红色线框标明）并将这些记录归集到一起，那么分组之后就出现了以不同类目进行划分的两个数据集，然后再从各自的数据集中选出最高的价格便可得到最终的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189489/201901/1189489-20190120213015992-1627112723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;articleHeader4&quot;&gt;一个最低价&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;再举一个例子，我们用品牌名称brand_name进行分组，并使用聚合函数算出该品牌下的最低价格。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
mysql&amp;gt; select brand_name,min(price) from product group by brand_name;
+------------+------------+
| brand_name | min(price) |
+------------+------------+
| HUAWEI     | 1999       |
| iPhone     | 9999       |
| Lenovo     | 8999       |
| Mac        | 13999      |
| XiaoMi     | 2999       |
+------------+------------+
5 rows in set
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;过程：&lt;/strong&gt;如下图所示，从数据集中按照品牌名称brand_name进行分组，然后按照品牌名称就筛选出了一共五组品牌，然后再从各自品牌中选出最低价格便可得到最终结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189489/201901/1189489-20190120213032040-508578152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;取经归来后，愈发的觉得无论生活还是技术都应该持有一种脱离表层、向往深层的探索追求精神，在这个过程中我会不断的总结分享，与诸君共勉！&lt;/span&gt;　&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 13:57:00 +0000</pubDate>
<dc:creator>翎野</dc:creator>
<og:description>问题背景 最近在项目中使用mysql的group by进行分组查询的场景比较多，其中一次遇到了一个问题，即在开发环境执行一个如下sql时是正确且可执行的， 但是放到了测试环境就会报如下的错误。 解决办</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lingyejun/p/10296279.html</dc:identifier>
</item>
<item>
<title>Python generator和yield介绍 - alpha_panda</title>
<link>http://www.cnblogs.com/yssjun/p/10236126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yssjun/p/10236126.html</guid>
<description>&lt;p&gt;Python生成器(generator)并不是一个晦涩难懂的概念。相比于MetaClass和Closure等概念，其较为容易理解和掌握。但相对于程序结构：顺序、循环和分支而言其又不是特别的直观。无论学习任何的东西，概念都是非常重要的。正确树立并掌握一些基础的概念是灵活和合理运用的前提，本文将以一种通俗易懂的方式介绍一下generator和yield表达式。&lt;/p&gt;
&lt;h3&gt;1. Iterator与Iterable&lt;/h3&gt;
&lt;p&gt;首先明白两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Iterator(迭代器)是可迭代对象;&lt;/li&gt;
&lt;li&gt;可迭代对象并不一定是Iterator;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;比较常见的数据类型list、tuple、dict等都是可迭代的，属于collections.Iterable类型；&lt;/p&gt;
&lt;p&gt;迭代器不仅可迭代还可以被内置函数next调用，属于collections.Iterator类型；&lt;/p&gt;
&lt;p&gt;迭代器是特殊的可迭代对象，是可迭代对象的一个子集。&lt;/p&gt;
&lt;p&gt;将要介绍的gererator(生成器)是types.GeneratorType类型，也是collections.Iterator类型。&lt;/p&gt;
&lt;p&gt;也就是说生成器是迭代器，可被next调用，也可迭代。&lt;/p&gt;
&lt;p&gt;三者的包含关系：（可迭代（迭代器（生成器）））&lt;/p&gt;
&lt;h3&gt;2. Python生成器&lt;/h3&gt;
&lt;p&gt;python有两种类型的生成器：生成器表达式和生成器函数。&lt;/p&gt;
&lt;p&gt;由于生成器可迭代并且是iterator，因此可以通过for和next进行遍历。&lt;/p&gt;
&lt;h4&gt;2.1 生成器表达式&lt;/h4&gt;
&lt;p&gt;把列表生成式的[]改成()便得到生成器表达式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; gen = (i + i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; xrange(10&lt;span&gt;))
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; gen
&lt;/span&gt;&amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x0000000003A2DAB0&amp;gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; type(gen)
&lt;/span&gt;&amp;lt;type &lt;span&gt;'&lt;/span&gt;&lt;span&gt;generator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; isinstance(gen, types.GeneratorType) &lt;span&gt;and&lt;/span&gt; isinstance(gen, collections.Iterator) &lt;span&gt;and&lt;/span&gt;&lt;span&gt; isinstance(gen, collections.Iterable)
True
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2 生成器函数&lt;/h4&gt;
&lt;p&gt;python函数定义中有关键字yield，该函数便是一个生成器函数，函数调用返回的是一个generator.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; yield_func():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; xrange(3&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; i
gen_func &lt;/span&gt;=&lt;span&gt; yield_func()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; yield_val &lt;span&gt;in&lt;/span&gt;&lt;span&gt; gen_func:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; yield_val
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成器函数每次执行到yield便会返回，但与普通函数不同的是yield返回时会保留当前函数的执行状态，再次被调用时可以从中断的地方继续执行。&lt;/p&gt;
&lt;h4&gt;2.3 next与send&lt;/h4&gt;
&lt;p&gt;通过for和next可以遍历生成器，而send则可以用于向生成器函数发送消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; yield_func():
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; xrange(1, 3&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         x = &lt;span&gt;yield&lt;/span&gt;&lt;span&gt; i
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;yield_func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,x
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; gen_func =&lt;span&gt; yield_func()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;iter result: %d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; next(gen_func)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;iter result: %d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % gen_func.send(100)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
iter result: 1&lt;span&gt;
yield_func &lt;/span&gt;100&lt;span&gt;
iter result: &lt;/span&gt;2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单分析一下执行过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;line_no 5 调用生成器函数yield_func得到函数生成器gen_func；&lt;/li&gt;
&lt;li&gt;line_no 6 使用next调用gen_func，此时才真正的开始执行yield_func定义的代码；&lt;/li&gt;
&lt;li&gt;line_no 3 执行到yield i，函数yield_func暂停执行并返回当前i的值1.&lt;/li&gt;
&lt;li&gt;line_no 6 next(gen_func)得到函数yield_func执行到yield i返回的值1，输出结果iter result: 1；&lt;/li&gt;
&lt;li&gt;line_no 7 执行gen_func.send(100);&lt;/li&gt;
&lt;li&gt;line_no 3 函数yield_func继续执行，并将调用者send的值100赋值给x;&lt;/li&gt;
&lt;li&gt;line_no 4 输出调用者send接收到的值；&lt;/li&gt;
&lt;li&gt;line_no 3 执行到yield i，函数yield_func暂停执行并返回当前i的值2.&lt;/li&gt;
&lt;li&gt;line_no 7 执行gen_func.send(100)得到函数yield_func运行到yield i返回的值2，输出结果iter result: 2；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果在上面代码后面再加一行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;iter result: %d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % next(gen_func)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
iter result: 1&lt;span&gt;
yield_func &lt;/span&gt;100&lt;span&gt;
iter result: &lt;/span&gt;2&lt;span&gt;
yield_func None
File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;G:\Cnblogs\Alpha Panda\Main.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 22, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
    &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;iter result: %d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; next(gen_func)
StopIteration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; yield_func只会产生2个yield，但是我们迭代调用了3次，会抛出异常StopIteration。&lt;/p&gt;
&lt;p&gt;next和send均会触发生成器函数的执行，使用for遍历生成器函数时不要用send。原因后面解释。&lt;/p&gt;
&lt;h4&gt;2.4 生成器返回值&lt;/h4&gt;
&lt;p&gt;使用了yield的函数严格来讲已经不是一个函数，而是一个生成器。因此函数中yield和return是不能同时出现的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SyntaxError: 'return' with argument inside generator&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生成器只能通过yield将每次调用的结果返回给调用者。&lt;/p&gt;
&lt;h4&gt;2.5 可迭代对象转成迭代器&lt;/h4&gt;
&lt;p&gt;list、tuple、dict等可迭代但不是迭代器的对象可通过内置函数iter转化为iterator，便可以通过next进行遍历；&lt;/p&gt;
&lt;p&gt;这样的好处是可以统一使用next遍历所有的可迭代对象；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
tup = (1,2,3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ele &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tup:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; ele + ele
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码等价于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
tup_iterator =&lt;span&gt; iter(tup)&lt;br/&gt;&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        ele &lt;/span&gt;=&lt;span&gt; next(tup_iterator)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopIteration:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt; ele + ele
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;for循环使用next遍历一个迭代器，混合使用send可能会导致混乱的遍历流程。&lt;/p&gt;
&lt;p&gt;其实到这里生成器相关的概念基本已经介绍完成了，自己动手过一遍应该能弄明白了。为了更加深刻的体会生成器，下面我们在往前走一步。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. range与xrange&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在Python 2中这两个比较常用，看一下两者的区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;range为一个内置函数，xrange是一个类；&lt;/li&gt;
&lt;li&gt;前者返回一个list，后者返回一个可迭代对象；&lt;/li&gt;
&lt;li&gt;后者遍历操作快于前者，且占用更少内存；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 这里xrange有点类似于上面介绍的生成器表达式，虽然xrange返回的并不是生成器，但两者均返回并不包含全部结果可迭代对象。&lt;/p&gt;
&lt;h4&gt;3.1 自定义xrange的Iterator版本&lt;/h4&gt;
&lt;p&gt;作为一个iterator:&lt;/p&gt;
&lt;blockquote readability=&quot;6.5922330097087&quot;&gt;
&lt;p&gt;The iterator objects themselves are required to support the following two methods, which together form the &lt;em class=&quot;dfn&quot;&gt;iterator protocol&lt;/em&gt;:&lt;/p&gt;
&lt;dl class=&quot;method&quot; readability=&quot;-0.95366795366795&quot;&gt;&lt;dt id=&quot;iterator.__iter__&quot;&gt;&lt;code class=&quot;descclassname&quot;&gt;iterator.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;__iter__&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;span class=&quot;sig-paren&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/dt&gt;
&lt;dd readability=&quot;0.94979079497908&quot;&gt;
&lt;p&gt;Return the iterator object itself. This is required to allow both containers and iterators to be used with the &lt;a class=&quot;reference internal&quot;&gt;&lt;code class=&quot;xref std std-keyword docutils literal&quot;&gt;for&lt;/code&gt;&lt;/a&gt; and &lt;a class=&quot;reference internal&quot;&gt;&lt;code class=&quot;xref std std-keyword docutils literal&quot;&gt;in&lt;/code&gt;&lt;/a&gt; statements. This method corresponds to the &lt;a class=&quot;reference internal&quot; title=&quot;PyTypeObject.tp_iter&quot;&gt;&lt;code class=&quot;xref c c-member docutils literal&quot;&gt;tp_iter&lt;/code&gt;&lt;/a&gt; slot of the type structure for Python objects in the Python/C API.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;&lt;dl class=&quot;method&quot; readability=&quot;-0.44827586206897&quot;&gt;&lt;dt id=&quot;iterator.next&quot;&gt;&lt;code class=&quot;descclassname&quot;&gt;iterator.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;next&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;span class=&quot;sig-paren&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/dt&gt;
&lt;dd readability=&quot;1.7777777777778&quot;&gt;
&lt;p&gt;Return the next item from the container. If there are no further items, raise the &lt;a class=&quot;reference internal&quot; title=&quot;exceptions.StopIteration&quot;&gt;&lt;code class=&quot;xref py py-exc docutils literal&quot;&gt;StopIteration&lt;/code&gt;&lt;/a&gt; exception. This method corresponds to the &lt;a class=&quot;reference internal&quot; title=&quot;PyTypeObject.tp_iternext&quot;&gt;&lt;code class=&quot;xref c c-member docutils literal&quot;&gt;tp_iternext&lt;/code&gt;&lt;/a&gt; slot of the type structure for Python objects in the Python/C API.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;&lt;/blockquote&gt;
&lt;p&gt;下面我们自定义class my_xrange:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; my_xrange(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, start, stop = None, step = 1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 仅仅为了演示，假设start, stop 和 step 均为正整数 &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         self._start = 0 &lt;span&gt;if&lt;/span&gt; stop &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;else&lt;/span&gt;&lt;span&gt; start
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         self._stop = start &lt;span&gt;if&lt;/span&gt; stop &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;else&lt;/span&gt;&lt;span&gt; stop
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self._step =&lt;span&gt; step
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self._cur_val =&lt;span&gt; self._start
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; next(self):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self._start &amp;lt;= self._cur_val &amp;lt;&lt;span&gt; self._stop:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             cur_val =&lt;span&gt; self._cur_val
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             self._cur_val +=&lt;span&gt; self._step
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cur_val
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;raise&lt;/span&gt; StopIteration
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; collections
myxrange &lt;/span&gt;= my_xrange(0, 10, 3&lt;span&gt;)
res &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; val &lt;span&gt;in&lt;/span&gt;&lt;span&gt; myxrange:
    res.append(val)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; res == range(0, 10, 3&lt;span&gt;)　　　&lt;span&gt;# True
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; isinstance(myxrange, collections.Iterator)　　&lt;span&gt;# True&lt;br/&gt;&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; isinstance(myxrange, types.GeneratorType)　　&lt;span&gt;# False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.2 使用函数生成器&lt;/h4&gt;
&lt;p&gt;下面使用函数生成器定义一个generator版的xrange。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; xrange_func(start, stop, step = 1&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; 仅仅为了演示，假设start, stop 和 step 均为正整数 &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    cur_val &lt;/span&gt;=&lt;span&gt; start
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; start &amp;lt;= cur_val &lt;span&gt;and&lt;/span&gt; cur_val &amp;lt;&lt;span&gt; stop:
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; cur_val
        cur_val &lt;/span&gt;+= step
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
isinstance(myxrange, collections.Iterator) &lt;span&gt;and&lt;/span&gt; isinstance(myxrange, types.GeneratorType) is True
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面两个自定义xrange版本的例子，均说明生成器以及迭代器保留数列生成过程的状态，每次只计算一个值并返回。这样只要占用很少的内存即可表示一个很大的序列。&lt;/p&gt;
&lt;h3&gt;4. 应用&lt;/h3&gt;
&lt;p&gt;不管是迭代器还是生成器，对于有大量有规律的数据产生并需要遍历访问的情景均适用，占用内存少而且遍历的速度快。其中一个较为经典的应用为斐波那契数列(Fibonacci sequence)。&lt;/p&gt;
&lt;p&gt;这里以os.walk遍历目录为例来说明yield的应用。如果我们需要遍历一个根目录下的所有文件并根据需要进行增删改查。可能会遇到下列的问题：&lt;/p&gt;
&lt;p&gt;预先遍历且缓存结果，但是目录下文件可能很多，而且会动态改变；如果不缓存，多个地方可能会频繁的需要访问这一结果导致效率低下。&lt;/p&gt;
&lt;p&gt; 这时候可以使用yield定义一个生成器函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_all_dir_files(target_dir):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; root, dirs, files &lt;span&gt;in&lt;/span&gt;&lt;span&gt; os.walk(target_dir):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt;&lt;span&gt; files:
            file_path &lt;/span&gt;=&lt;span&gt; os.path.join(root, file)
            &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; os.path.realpath(file_path)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; file_factory(file):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; do something &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

target_dir &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
all_files &lt;/span&gt;=&lt;span&gt; get_all_dir_files(target_dir)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt;&lt;span&gt; all_files:
    file_factory(file)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  限于篇幅，就先介绍到这里，希望本文能让你对生成器有一个新的认识。&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 13:45:00 +0000</pubDate>
<dc:creator>alpha_panda</dc:creator>
<og:description>Python生成器(generator)并不是一个晦涩难懂的概念。相比于MetaClass和Closure等概念，其较为容易理解和掌握。但相对于程序结构：顺序、循环和分支而言其又不是特别的直观。无论学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yssjun/p/10236126.html</dc:identifier>
</item>
</channel>
</rss>