<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core应用基本编程模式[1]：管道式的请求处理 - Artech</title>
<link>http://www.cnblogs.com/artech/p/asp-net-core-program-model-1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/asp-net-core-program-model-1.html</guid>
<description>&lt;p&gt;HTTP协议自身的特性决定了任何一个Web应用的工作模式都是监听、接收并处理HTTP请求，并且最终对请求予以响应。HTTP请求处理是管道式设计典型的应用场景：可以根据具体的需求构建一个管道，接收的HTTP请求像水一样流入这个管道，组成这个管道的各个环节依次对其做相应的处理。虽然ASP.NET Core的请求处理管道从设计上来讲是非常简单的，但是具体的实现则涉及很多细节，为了使读者对此有深刻的理解，需要从编程的角度先了解ASP.NET Core管道式的请求处理方式。[本文节选自《ASP.NET Core 3框架揭秘》第11章, 更多关于ASP.NET Core的文章请点&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-3.html&quot;&gt;这里&lt;/a&gt;]&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;目录&lt;br/&gt;一、两个承载体系&lt;br/&gt;二、请求处理管道&lt;br/&gt;三、中间件&lt;br/&gt;    RequestDelegate&lt;br/&gt;     Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&lt;br/&gt;     Run方法的本质   &lt;br/&gt;四、定义强类型中间件&lt;br/&gt;五、按照约定定义中间件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ASP.NET Core框架目前存在两个承载（Hosting）系统。ASP.NET Core最初提供了一个以IWebHostBuilder/IWebHost为核心的承载系统，其目的很单纯，就是通过下图所示的形式承载以服务器和中间件管道构建的Web应用。ASP.NET Core 3依然支持这样的应用承载方式，但是本系列不会涉及这种“过时”的承载方式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084540656-1417229936.png&quot;&gt;&lt;img width=&quot;379&quot; height=&quot;117&quot; title=&quot;1&quot; alt=&quot;1&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084541105-694635059.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了承载Web应用本身，我们还有针对后台服务的承载需求，为此微软推出了以IHostBuilder/IHost为核心的承载系统，我们在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-09-01.html&quot;&gt;服务承载系统&lt;/a&gt;》中已经对该系统做了详细的介绍。实际上，Web应用本身就是一个长时间运行的后台服务，我们完全可以定义一个承载服务，从而将Web应用承载于这个系统中。如下图所示，这个用来承载ASP.NET Core应用的承载服务类型为GenericWebHostService，这是一个实现了IHostedService接口的内部类型。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084541542-1723943724.png&quot;&gt;&lt;img width=&quot;377&quot; height=&quot;184&quot; title=&quot;2&quot; alt=&quot;2&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084541919-1282346185.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IHostBuilder接口上定义了很多方法（其中很多是扩展方法），这些方法的目的主要包括以下两点：第一，为创建的IHost对象及承载的服务在依赖注入框架中注册相应的服务；第二，为服务承载和应用提供相应的配置。其实IWebHostBuilder接口同样定义了一系列方法，除了这里涉及的两点，支撑ASP.NET Core应用的中间件也是由IWebHostBuilder注册的。&lt;/p&gt;
&lt;p&gt;即使采用基于IHostBuilder/IHost的承载系统，我们依然会使用IWebHostBuilder接口。虽然我们不再使用IWebHostBuilder的宿主构建功能，但是定义在IWebHostBuilder上的其他API都是可以使用的。具体来说，可以调用定义在IHostBuilder接口和IWebHostBuilder接口的方法（大部分为扩展方法）来注册依赖服务与初始化配置系统，两者最终会合并在一起。利用IWebHostBuilder接口注册的中间件会提供给GenericWebHostService，用于构建ASP.NET Core请求处理管道。&lt;/p&gt;
&lt;p&gt;在基于IHostBuilder/IHost的承载系统中复用IWebHostBuilder的目的是通过如下所示的ConfigureWebHost扩展方法达成的，GenericWebHostService服务也是在这个方法中被注册的。ConfigureWebHostDefaults扩展方法则会在此基础上做一些默认设置（如KestrelServer），后续章节的实例演示基本上会使用这个方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GenericHostWebHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder ConfigureWebHost(&lt;span&gt;this&lt;/span&gt; IHostBuilder builder, Action&amp;lt;IWebHostBuilder&amp;gt;&lt;span&gt; configure);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GenericHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostBuilder ConfigureWebHostDefaults(&lt;span&gt;this&lt;/span&gt; IHostBuilder builder, Action&amp;lt;IWebHostBuilder&amp;gt;&lt;span&gt; configure);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对IWebHostBuilder接口的复用导致很多功能都具有两种编程方式，虽然这样可以最大限度地复用和兼容定义在IWebHostBuilder接口上众多的应用编程接口，但笔者并不喜欢这样略显混乱的编程模式，这一点在下一个版本中也许会得到改变。&lt;/p&gt;

&lt;p&gt;下面创建一个最简单的Hello World程序。这个程序由如下所示的几行代码组成。运行这个程序之后，一个名为KestrelServer的服务器将会启动并绑定到本机上的5000端口进行请求监听。针对所有接收到的请求，我们都会采用“Hello World”字符串作为响应的主体内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder()
            .ConfigureWebHost(builder &lt;/span&gt;=&amp;gt; builder.Configure(app =&amp;gt; app.Run(context =&amp;gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))))
            .Build()
            .Run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从如上所示的代码片段可以看出，我们利用《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-09-01.html&quot;&gt;服务承载系统&lt;/a&gt;》介绍的承载系统来承载一个ASP.NET Core应用。在调用Host类型的静态方法CreateDefaultBuilder创建了一个IHostBuilder对象之后，我们调用它的ConfigureWebHost方法对ASP.NET Core应用的请求处理管道进行定制。HTTP请求处理流程始于对请求的监听与接收，终于对请求的响应，这两项工作均由同一个对象来完成，我们称之为服务器（Server）。ASP.NET Core请求处理管道必须有一个服务器，它是整个管道的“龙头”。在演示程序中，我们调用IWebHostBuilder接口的UseKestrel扩展方法为后续构建的管道注册了一个名为KestrelServer的服务器。&lt;/p&gt;
&lt;p&gt;当承载服务GenericWebHostService被启动之后，定制的请求处理管道会被构建出来，管道的服务器随后会绑定到一个预设的端口（如KestrelServer默认采用5000作为监听端口）开始监听请求。HTTP请求一旦抵达，服务器会将其标准化，并分发给管道后续的节点，我们将位于服务器之后的节点称为中间件（Middleware）。&lt;/p&gt;
&lt;p&gt;每个中间件都具有各自独立的功能，如专门实现路由功能的中间件、专门实施用户认证和授权的中间件。所谓的管道定制主要体现在根据具体需求选择对应的中间件来构建最终的管道。在演示程序中，我们调用IWebHostBuilder接口的Configure方法注册了一个中间件，用于响应“Hello World”字符串。具体来说，这个用来注册中间件的Configure方法具有一个类型为Action&amp;lt;IApplicationBuilder&amp;gt;的参数，我们提供的中间件就注册到提供的IApplicationBuilder对象上。由服务器和中间件组成的请求处理管道如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084542476-1334893339.png&quot;&gt;&lt;img width=&quot;343&quot; height=&quot;140&quot; title=&quot;3&quot; alt=&quot;3&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084542781-1500852843.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;建立在ASP.NET Core之上的应用基本上是根据某个框架开发的。一般来说，开发框架本身就是通过某一个或者多个中间件构建起来的。以ASP.NET Core MVC开发框架为例，它借助“路由”中间件实现了请求与Action之间的映射，并在此基础之上实现了激活（Controller）、执行（Action）及呈现（View）等一系列功能。应用程序可以视为某个中间件的一部分，如果一定要将它独立出来，由服务器、中间件和应用组成的管道如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084543095-304305819.png&quot;&gt;&lt;img width=&quot;338&quot; height=&quot;155&quot; title=&quot;4&quot; alt=&quot;4&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084543454-431128232.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ASP.NET Core的请求处理管道由一个服务器和一组中间件组成，位于“龙头”的服务器负责请求的监听、接收、分发和最终的响应，而针对该请求的处理则由后续的中间件来完成。如果读者希望对请求处理管道具有深刻的认识，就需要对中间件有一定程度的了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RequestDelegate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从概念上可以将请求处理管道理解为“请求消息”和“响应消息”流通的管道，服务器将接收的请求消息从一端流入管道并由相应的中间件进行处理，生成的响应消息反向流入管道，经过相应中间件处理后由服务器分发给请求者。但从实现的角度来讲，管道中流通的并不是所谓的请求消息与响应消息，而是一个针对当前请求创建的上下文。这个上下文被抽象成如下这个HttpContext类型，我们利用HttpContext不仅可以获取针对当前请求的所有信息，还可以直接完成针对当前请求的所有响应工作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; HttpRequest    Request { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; HttpResponse     Response { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既然流入管道的只有一个共享的HttpContext上下文，那么一个Func&amp;lt;HttpContext,Task&amp;gt;对象就可以表示处理HttpContext的操作，或者用于处理HTTP请求的处理器。由于这个委托对象非常重要，所以ASP.NET Core专门定义了如下这个名为RequestDelegate的委托类型。既然有这样一个专门的委托对象来表示“针对请求的处理”，那么中间件是否能够通过该委托对象来表示？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; Task RequestDelegate(HttpContext context);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上，组成请求处理管道的中间件可以表示为一个类型为Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;的委托对象，但初学者很难理解这一点，所以下面对此进行简单的解释。由于RequestDelegate可以表示一个HTTP请求处理器，所以由一个或者多个中间件组成的管道最终也体现为一个RequestDelegate对象。对于下图所示的中间件Foo来说，后续中间件（Bar和Baz）组成的管道体现为一个RequestDelegate对象，该对象会作为中间件Foo输入，中间件Foo借助这个委托对象将当前HttpContext分发给后续管道做进一步处理。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084543780-264306130.png&quot;&gt;&lt;img width=&quot;334&quot; height=&quot;214&quot; title=&quot;5&quot; alt=&quot;5&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084544121-1138712643.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表示中间件的Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;对象的输出依然是一个RequestDelegate对象，该对象表示将当前中间件与后续管道进行“对接”之后构成的新管道。对于表示中间件Foo的委托对象来说，返回的RequestDelegate对象体现的就是由Foo、Bar和Baz组成的请求处理管道。&lt;/p&gt;
&lt;p&gt;既然原始的中间件是通过一个Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;对象表示的，就可以直接注册这样一个对象作为中间件。中间件的注册可以通过调用IWebHostBuilder接口的Configure扩展方法来完成，该方法的参数是一个Action&amp;lt;IApplicationBuilder&amp;gt;类型的委托对象，可以通过调用IApplicationBuilder接口的Use方法将表示中间件的Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;对象添加到当前中间件链条上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder Configure(&lt;span&gt;this&lt;/span&gt; IWebHostBuilder hostBuilder, ction&amp;lt;IApplicationBuilder&amp;gt;&lt;span&gt; configureApp);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IApplicationBuilder
{
    IApplicationBuilder Use(Func&lt;/span&gt;&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&lt;span&gt; middleware);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在如下所示的代码片段中，我们创建了两个Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;对象，它们会在响应中写入两个字符串（“Hello”和“World！”）。在针对IWebHostBuilder接口的Configure方法的调用中，可以调用IApplicationBuilder接口的Use方法将这两个委托对象注册为中间件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; RequestDelegate Middleware1(RequestDelegate next) =&amp;gt; &lt;span&gt;async&lt;/span&gt; context =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
        };
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; RequestDelegate Middleware2(RequestDelegate next) =&amp;gt; &lt;span&gt;async&lt;/span&gt; context =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        };

        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt; builder.Configure(app =&amp;gt;&lt;span&gt; app
            .Use(Middleware1)
            .Use(Middleware2)))
        .Build()
        .Run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于我们注册了如上所示的两个中间件，所以它们会按照注册的顺序对分发给它们的请求进行处理。运行该程序后，如果利用浏览器对监听地址（“http://localhost:5000”）发送请求，那么两个中间件写入的字符串会以下图所示的形式呈现出来。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084544459-487983554.png&quot;&gt;&lt;img width=&quot;365&quot; height=&quot;175&quot; title=&quot;6&quot; alt=&quot;6&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084544842-970877953.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然可以直接采用原始的Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;对象来定义中间件，但是在大部分情况下，我们依然倾向于将自定义的中间件定义成一个具体的类型。至于中间件类型的定义，ASP.NET Core提供了如下两种不同的形式可供选择。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;强类型定义：自定义的中间件类型显式实现预定义的IMiddleware接口，并在实现的方法中完成针对请求的处理。&lt;/li&gt;
&lt;li&gt;基于约定的定义：不需要实现任何接口或者继承某个基类，只需要按照预定义的约定来定义中间件类型。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Run方法的本质&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在演示的Hello World应用中，我们调用IApplicationBuilder接口的Run扩展方法注册了一个RequestDelegate对象来处理请求，实际上，该方法仅仅是按照如下方式注册了一个中间件。由于注册的中间件并不会将请求分发给后续的中间件，如果调用IApplicationBuilder接口的Run方法后又注册了其他的中间件，后续中间件的注册将毫无意义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RunExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Run(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IApplicationBuilder app, RequestDelegate handler)
    &lt;/span&gt;=&amp;gt; app.Use(_ =&amp;gt;&lt;span&gt; handler);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果采用强类型的中间件类型定义方式，只需要实现如下这个IMiddleware接口，该接口定义了唯一的InvokeAsync方法，用于实现中间件针对请求的处理。这个InvokeAsync方法定义了两个参数：第一个参数是代表当前请求上下文的HttpContext对象，第二个参数是代表后续中间件组成的管道的RequestDelegate对象，如果当前中间件最终需要将请求分发给后续中间件进行处理，只需要调用这个委托对象即可，否则应用针对请求的处理就到此为止。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IMiddleware
{
    Task InvokeAsync(HttpContext context, RequestDelegate next);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在如下所示的代码片段中，我们定义了一个实现了IMiddleware接口的StringContentMiddleware中间件类型，在实现的InvokeAsync方法中，它将构造函数中指定的字符串作为响应的内容。由于中间件最终是采用依赖注入的方式来提供的，所以需要预先对它们进行服务注册，针对StringContentMiddleware的服务注册是通过调用IHostBuilder接口的ConfigureServices方法完成的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {            
        Host.CreateDefaultBuilder()
            .ConfigureServices(svcs &lt;/span&gt;=&amp;gt; svcs.AddSingleton(&lt;span&gt;new&lt;/span&gt; StringContentMiddleware(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))
            .ConfigureWebHost(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .Configure(app &lt;/span&gt;=&amp;gt; app.UseMiddleware&amp;lt;StringContentMiddleware&amp;gt;&lt;span&gt;()))
        .Build()
        .Run();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StringContentMiddleware : IMiddleware
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _contents;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; StringContentMiddleware(&lt;span&gt;string&lt;/span&gt; contents) =&amp;gt; _contents =&lt;span&gt; contents;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task InvokeAsync(HttpContext context, RequestDelegate next) =&amp;gt;&lt;span&gt; context.Response.WriteAsync(_contents);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;针对中间件自身的注册则体现在针对IWebHostBuilder接口的Configure方法的调用上，最终通过调用IApplicationBuilder接口的UseMiddleware&amp;lt;TMiddleware&amp;gt;方法来注册中间件类型。如下面的代码片段所示，在注册中间件类型时，可以以泛型参数的形式来指定中间件类型，也可以调用另一个非泛型的方法重载，直接通过Type类型的参数来指定中间件类型。值得注意的是，这两个方法均提供了一个参数params，它是为针对“基于约定的中间件”注册设计的，当我们注册一个实现了IMiddleware接口的强类型中间件的时候是不能指定该参数的。启动该程序后利用浏览器访问监听地址，依然可以得到上图所示的输出结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseMiddlewareExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseMiddleware&amp;lt;TMiddleware&amp;gt;(&lt;span&gt;this&lt;/span&gt; IApplicationBuilder app, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseMiddleware(&lt;span&gt;this&lt;/span&gt; IApplicationBuilder app, Type middleware, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] args);    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可能我们已经习惯了通过实现某个接口或者继承某个抽象类的扩展方式，但是这种方式有时显得约束过重，不够灵活，所以可以采用另一种基于约定的中间件类型定义方式。这种定义方式比较自由，因为它并不需要实现某个预定义的接口或者继承某个基类，而只需要遵循一些约定即可。自定义中间件类型的约定主要体现在如下几个方面。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;中间件类型需要有一个有效的公共实例构造函数，该构造函数要求必须包含一个RequestDelegate类型的参数，当前中间件利用这个委托对象实现针对后续中间件的请求分发。构造函数不仅可以包含任意其他参数，对于RequestDelegate参数出现的位置也不做任何约束。&lt;/li&gt;
&lt;li&gt;针对请求的处理实现在返回类型为Task的InvokeAsync方法或者Invoke方法中，它们的第一个参数表示当前请求上下文的HttpContext对象。对于后续的参数，虽然约定并未对此做限制，但是由于这些参数最终由依赖注入框架提供，所以相应的服务注册必须存在。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;采用这种方式定义的中间件类型同样是调用前面介绍的UseMiddleware方法和UseMiddleware&amp;lt;TMiddleware&amp;gt;方法进行注册的。由于这两个方法会利用依赖注入框架来提供指定类型的中间件对象，所以它会利用注册的服务来提供传入构造函数的参数。如果构造函数的参数没有对应的服务注册，就必须在调用这个方法的时候显式指定。&lt;/p&gt;
&lt;p&gt;在如下所示的代码片段中，我们定义了一个名为StringContentMiddleware的中间件类型，在执行这个中间件时，它会将预先指定的字符串作为响应内容。StringContentMiddleware的构造函数具有两个额外的参数：contents表示响应内容，forewardToNext则表示是否需要将请求分发给后续中间件进行处理。在调用UseMiddleware&amp;lt;TMiddleware&amp;gt;扩展方法对这个中间件进行注册时，我们显式指定了响应的内容，至于参数forewardToNext，我们之所以没有每次都显式指定，是因为这是一个具有默认值的参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder()
            .ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt; builder.Configure(app =&amp;gt;&lt;span&gt; app
                .UseMiddleware&lt;/span&gt;&amp;lt;StringContentMiddleware&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .UseMiddleware&lt;/span&gt;&amp;lt;StringContentMiddleware&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)))
        .Build()
        .Run();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StringContentMiddleware
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate     _next;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _contents;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; _forewardToNext;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; StringContentMiddleware(RequestDelegate next, &lt;span&gt;string&lt;/span&gt; contents, &lt;span&gt;bool&lt;/span&gt; forewardToNext = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            _next  &lt;/span&gt;=&lt;span&gt; next;
            _forewardToNext &lt;/span&gt;=&lt;span&gt; forewardToNext;
            _contents &lt;/span&gt;=&lt;span&gt; contents;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(HttpContext context)
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.Response.WriteAsync(_contents);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_forewardToNext)
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(context);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动该程序后，利用浏览器访问监听地址依然可以得到下图所示的输出结果。对于前面介绍的两个中间件，它们的不同之处除了体现在定义和注册方式上，还体现在自身生命周期的差异上。具体来说，强类型方式定义的中间件可以注册为任意生命周期模式的服务，但是按照约定定义的中间件则总是一个Singleton服务。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084545295-1822135626.png&quot;&gt;&lt;img width=&quot;365&quot; height=&quot;172&quot; title=&quot;6&quot; alt=&quot;6&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201111084545662-2064693151.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-1.html&quot;&gt;ASP.NET Core编程模式[1]：管道式的请求处理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-2.html&quot;&gt;ASP.NET Core编程模式[2]：依赖注入的运用&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-3.html&quot;&gt;ASP.NET Core编程模式[3]：配置多种使用形式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-4.html&quot;&gt;ASP.NET Core编程模式[4]：基于承载环境的编程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-5.html&quot;&gt;ASP.NET Core编程模式[5]：如何放置你的初始化代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Nov 2020 00:46:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>目录一、两个承载体系 二、请求处理管道 三、中间件 RequestDelegate Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt; Run方法的本质 四、定义</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/asp-net-core-program-model-1.html</dc:identifier>
</item>
<item>
<title>C#设计模式-责任链模式(Chain of Responsibility Pattern)  - Tynam.Yang</title>
<link>http://www.cnblogs.com/tynam/p/13953789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tynam/p/13953789.html</guid>
<description>&lt;h2&gt;引子&lt;/h2&gt;
&lt;p&gt;一个事件需要经过多个对象处理是一个挺常见的场景，譬如采购审批流程，请假流程，软件开发中的异常处理流程，web请求处理流程等各种各样的流程，可以考虑使用责任链模式来实现。&lt;br/&gt;现在以请假流程为例，一般公司普通员工的请假流程简化如下：&lt;br/&gt;普通员工发起一个请假申请，当请假天数小于3天时只需要得到主管批准即可；当请假天数大于3天时，主管批准后还需要提交给经理审批，经理审批通过，若请假天数大于7天还需要进一步提交给总经理审批。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1359074/202011/1359074-20201110144250270-2048260562.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;283&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单的流程可以通过 if-else 即可实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Leave
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; leaveApproval(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; leaveDays)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (leaveDays &amp;lt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;项目经理审批&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (leaveDays &amp;lt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;部门经理审批&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (leaveDays &amp;lt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;总经理审批&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;审批困难&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这样的写法看起来简单，后续维护难度却是不少。可以看出代码臃肿且耦合度高。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;代码臃肿&lt;/strong&gt;：实际应用中的判定条件通常不是这么简单地判断，也许需要复杂的计算，也许需要查询数据库等等，这就会有很多额外的代码，如果判断条件再比较多，那么这个if…else…语句基本上就没法看了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;耦合度高&lt;/strong&gt;：如果我们想继续添加处理请求的类，那么就要继续添加else if判定条件；另外，这个条件判定的顺序也是写死的，如果想改变顺序，那么也只能修改这个条件语句。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在设计模式中提倡单一职责原则，如果项目组内再加一个组长，审批请假小于一天的呢？此时就会感觉 if-else 灵活性太差，修改代码后测试需要重新测试全部流程才能保证质量。&lt;br/&gt;既然已经清楚他的不足，则针对此业务逻辑可以稍作转换：如果满足条件1，则由 Handler1 来处理，不满足则向下传递；如果满足条件2，则由 Handler2 来处理，不满足则继续向下传递，以此类推，直到条件结束。其实改进的方法也很简单，就是把判定条件的部分放到处理类中，这就是责任连模式的原理。&lt;/p&gt;
&lt;h2&gt;定义&lt;/h2&gt;
&lt;p&gt;责任链模式属于行为类模式。使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。&lt;br/&gt;责任链模式把多个处理器串成链，然后让请求在链上传递：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1359074/202011/1359074-20201110144511419-1162169054.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;类图&lt;/h3&gt;
&lt;p&gt;从的定义可以看出涉及的对象只有处理者角色，但可以有多个处理者，这些处理者做的事情都是一样的，处理请求的方法，所以可以抽象出一个处理者角色进行代码复用。如下类图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1359074/202011/1359074-20201110144544577-818151102.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;角色&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Handler（抽象处理类）&lt;/strong&gt;：抽象处理类中主要包含一个指向下一处理类的成员变量nextHandler和一个处理请求的方法handRequest，handRequest方法的主要主要思想是，如果满足处理的条件，则有本处理类来进行处理，否则由nextHandler来处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ConcreteHandler（具体处理类）&lt;/strong&gt;：具体处理类主要是对具体的处理逻辑和处理的适用条件进行实现。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;实现&lt;/h2&gt;
&lt;p&gt;将上面的请假流程重新梳理，使用责任链模式进行实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 责任链模式
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            LeaveRequest leaveTwoDays &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; LeaveRequest(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grey1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            LeaveRequest leaveSixDays &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; LeaveRequest(&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grey2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            LeaveRequest leaveEightDays &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; LeaveRequest(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grey3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Approver PM &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Manager(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jon1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Approver DM &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DepartmentManager(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jon2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Approver GM &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; GeneralManager(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jon3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置责任链&lt;/span&gt;
            PM.NextApprover =&lt;span&gt; DM;
            DM.NextApprover &lt;/span&gt;=&lt;span&gt; GM;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理请求&lt;/span&gt;
&lt;span&gt;            PM.LeaveRequest(leaveTwoDays);
            PM.LeaveRequest(leaveSixDays);
            PM.LeaveRequest(leaveEightDays);
            Console.ReadLine();
        }
    }

        
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请假需求&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LeaveRequest
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Day { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; LeaveRequest(&lt;span&gt;int&lt;/span&gt; day, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Day =&lt;span&gt; day;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Name =&lt;span&gt; name;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 审批人&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Approver {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Approver NextApprover { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Approver(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Name =&lt;span&gt; name;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LeaveRequest(LeaveRequest requeset);
    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 项目经理&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Manager : Approver
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Manager(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(name) { }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LeaveRequest(LeaveRequest requeset)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (requeset.Day &amp;lt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;项目经理 {0} 审批 {1} 请假&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Name, requeset.Name);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                NextApprover.LeaveRequest(requeset);
            }
        }
    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 部门经理&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DepartmentManager : Approver
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DepartmentManager(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(name) { }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LeaveRequest(LeaveRequest requeset)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (requeset.Day &amp;lt; &lt;span&gt;7&lt;/span&gt;&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;部门经理 {0} 审批 {1} 请假&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Name, requeset.Name);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                NextApprover.LeaveRequest(requeset);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 总经理&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GeneralManager : Approver
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; GeneralManager(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(name) { }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; LeaveRequest(LeaveRequest requeset)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (requeset.Day &amp;lt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;总经理 {0} 审批 {1} 请假&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Name, requeset.Name);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;审批困难&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); ;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行一下：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;项目经理 jon1 审批 grey1 请假
部门经理 jon2 审批 grey2 请假
总经理 jon3 审批 grey3 请假&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LeaveRequest 类为请求请假。&lt;br/&gt;Approver 为处理人员。并且设置了三个处理人员，Manager、DepartmentManager、GeneralManager。&lt;br/&gt;设置的责任链为 Manager--&amp;gt;DepartmentManager--&amp;gt;GeneralManager。当发生请假请求时首先由Manager进行处理，处理不了转由DepartmentManager，如果DepartmentManager还是处理不了则继续向更好职位的人员GeneralManager进行提交，由更大权限的人进行处理。&lt;br/&gt;实现的功能和文章最初的 if...else 一样。但时可以看到使用责任链模式代码更清楚，请求发送者是发送者，接收者是接收者。&lt;/p&gt;
&lt;h3&gt;适用场景 &lt;/h3&gt;
&lt;p&gt;通过上面的定义、类图及示例可以考虑责任链模式适用的场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。&lt;/li&gt;
&lt;li&gt;代码中存在多个if-else语句的情况下，此时可以考虑使用责任链模式来对代码进行重构。&lt;/li&gt;
&lt;li&gt;可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;优缺点&lt;/h2&gt;
&lt;p&gt;通过上面的介绍很容易发现，责任链模式的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。&lt;/li&gt;
&lt;li&gt;增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。&lt;/li&gt;
&lt;li&gt;增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。&lt;/li&gt;
&lt;li&gt;责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。&lt;/li&gt;
&lt;li&gt;责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但也有缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。&lt;/li&gt;
&lt;li&gt;对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。&lt;/li&gt;
&lt;li&gt;职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;扩展&lt;/h2&gt;
&lt;p&gt;纯的责任链模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后 又将责任向下传递的情况。&lt;/li&gt;
&lt;li&gt;一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不纯的责任链模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;允许某个请求被一个具体处理者部分处理后再向下传递。&lt;/li&gt;
&lt;li&gt;或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求。&lt;/li&gt;
&lt;li&gt;而且一个请求可以最终不被任何处理者对象所接收。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;责任链模式其实就是一个灵活版的if…else…语句，将这些判定条件的语句放到了各个处理类中，非常灵活。&lt;br/&gt;责任链模式是一种把多个处理器组合在一起，依次处理请求的模式。&lt;br/&gt;责任链降低了请求端和接收端之间的耦合，使多个对象都有机会处理某个请求。&lt;br/&gt;责任链模式经常用在拦截、预处理请求等。&lt;br/&gt;与此同样也带来了风险，比如设置处理类前后关系时，一定要特别仔细，搞对处理类前后逻辑的条件判断关系，并且注意不要在链中出现循环引用的问题。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;p&gt;https://juejin.im/post/6844903702260629512&lt;br/&gt;https://www.w3cschool.cn/javadesignpattern/omas1ii2.html&lt;br/&gt;https://www.cnblogs.com/zhili/p/ChainOfResponsibity.html&lt;br/&gt;http://c.biancheng.net/view/1383.html&lt;br/&gt;https://www.liaoxuefeng.com/wiki/1252599548343744/1281319474561057&lt;/p&gt;

</description>
<pubDate>Wed, 11 Nov 2020 00:44:00 +0000</pubDate>
<dc:creator>Tynam.Yang</dc:creator>
<og:description>引子 一个事件需要经过多个对象处理是一个挺常见的场景，譬如采购审批流程，请假流程，软件开发中的异常处理流程，web请求处理流程等各种各样的流程，可以考虑使用责任链模式来实现。现在以请假流程为例，一般公</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tynam/p/13953789.html</dc:identifier>
</item>
<item>
<title>为什么重写 equals() 方法，一定要重写 hashCode() 呢？| HashMap - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13956932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13956932.html</guid>
<description>&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;微信搜索🔍「码农田小齐」，关注这个在纽约的程序媛，回复「01-05」可以获取计算机精选书籍、个人刷题笔记、大厂面经、面试资料等资源，么么哒～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们有一个假设：任何两个 object 的 hashCode 都是不同的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在这个条件下，有两个 object 是相等的，那如果不重写 hashCode()，算出来的哈希值都不一样，就会去到不同的 buckets 了，就迷失在茫茫人海中了，再也无法相认，就和 equals() 条件矛盾了，证毕。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;撒花～～🎉🎉🎉&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们再对这两个方法一探究竟：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 hashCode() 和 equals() 方法都是在 Object class 这个老祖宗里定义的，Object 是所有 Java 中的 class 的鼻祖，默认都是有的，甩不掉的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那既然是白给的，我们先来看看大礼包里有什么，谷歌 Object 的 Oracle 文档：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkktt8adnij30u00dqn1n.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这些方法都是可以直接拿来用的呢～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到 hashCode() 和 equals()，那么如果这个新的 class 里没有重写 (override) 这两个方法，就是默认继承 Object class 里的定义了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们点进去来看看 equals() 是怎么定义的：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkkttw8jvsj30u007uac2.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记笔记：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;equals()&lt;/code&gt; 方法就是比较这两个 references 是否指向了同一个 object.&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嗯？？？你在逗我吗？？那岂不是和 &lt;code&gt;==&lt;/code&gt; 一样了？？&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;补充：&lt;br/&gt;我们常用的比较大小的符号之 &lt;code&gt;==&lt;/code&gt;&lt;br/&gt;如果是 primitive type，那么 == 就是比较数值的大小；&lt;br/&gt;如果是 reference type，那么就比较的是这两个 reference 是否指向了同一个 object。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;再补充：&lt;br/&gt;Java 的数据类型可以分为两种：&lt;br/&gt;Primitive type 有且仅有8种：byte, short, int, long, float, double, char, boolean.&lt;br/&gt;其他都是 Reference type.&lt;br/&gt;所以虽然 Java 声称 “Everything is object”，但是还是有非 object 数据类型的存在的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我不信，我要去源码里看看它是怎么实现的。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkktu3venbj30fr0or45j.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;​&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈，还真是的，绕了这么半天，&lt;code&gt;equals()&lt;/code&gt; 就是用 &lt;code&gt;==&lt;/code&gt; 来实现的！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为什么还弄出来这么个方法呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：为了让你 override～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如一般来说我们比较字符串就是想比较这两个字符串的内容的，那么：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;str1 = “tianxiaoqi”;&lt;br/&gt;str2 =  &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; String(“tianxiaoqi”);&lt;p&gt;str1 == str2; &lt;br/&gt;str1.equals(str2); &lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 String 里是重写了 equals() 方法的：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkktukhfouj30gk0il0w3.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老祖宗留给你就是让你自己用的，如果你不用，那人家也提供了默认的方法，也是够意思了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，我们再去看 hashCode() 的介绍：&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkktuv1c91j30u006oq59.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那至于 hashCode() 返回的究竟是什么，和本文关联不太大，有兴趣的同学可以看参考，结论就是：&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;返回的并不一定是对象的（虚拟）内存地址，具体取决于运行时库和JVM的具体实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但无论是怎么实现的，都需要遵循文档上的约定，也就是对不同的 object 会返回&lt;strong&gt;唯一的哈希值&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说，&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;hashCode() 决定了 key 放在这个桶里的编号，也就是在数组里的 index；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;equals() 是用来比较两个 object 是否相同的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你喜欢这篇文章，记得给我点赞留言哦～你们的支持和认可，就是我创作的最大动力，我们下篇文章见！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是小齐，纽约程序媛，终生学习者，每天晚上 9 点，云自习室里不见不散！&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;更多干货文章见我的 Github: https://github.com/xiaoqi6666/NYCSDE&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 11 Nov 2020 00:36:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>微信搜索&amp;amp;#128269;「码农田小齐」，关注这个在纽约的程序媛，回复「01-05」可以获取计算机精选书籍、个人刷题笔记、大厂面经、面试资料等资源，么么哒～ 首先我们有一个假设：任何两个 ob</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13956932.html</dc:identifier>
</item>
<item>
<title>聊聊什么是慢查、如何监控？如何排查？ - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/13956914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/13956914.html</guid>
<description>&lt;p&gt;Hi，大家好！我是白日梦。&lt;/p&gt;
&lt;p&gt;今天我要跟你分享的话题是：“聊聊什么是慢查、如何监控？如何排查？”&lt;/p&gt;
&lt;h4 id=&quot;一、-推荐阅读方式&quot;&gt;一、 推荐阅读方式&lt;/h4&gt;
&lt;p&gt;首发地址：&lt;a href=&quot;https://mp.weixin.qq.com/s/tXTLMCiVpEnnmhUclYR19Q&quot;&gt;https://mp.weixin.qq.com/s/tXTLMCiVpEnnmhUclYR19Q&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用推荐阅读，有更好的阅读体验&lt;br/&gt;&lt;/p&gt;
&lt;h4 id=&quot;二、什么是慢查？&quot;&gt;二、什么是慢查？&lt;/h4&gt;
&lt;p&gt;慢查，顾名思义就是很慢的查询。SQL的执行总是有一个执行时间的，通过&lt;code&gt;long_query_time&lt;/code&gt;参数告诉MySQL，当SQL的执行时间超过该参数的指定值后就将这条SQL记录在慢查日志中。&lt;/p&gt;
&lt;p&gt;默认的&lt;code&gt;long_query_time&lt;/code&gt;默认值为10s&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202011/1496926-20201111055543420-659575281.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;三、怎么调整界定慢查的时间？&quot;&gt;三、怎么调整界定慢查的时间？&lt;/h4&gt;
&lt;p&gt;设置全局慢查时间为0.2秒。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202011/1496926-20201111055544949-1605463852.png&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注意：long_query_time属于dynamic类型的参数。意思是像上面这样在会话A中通过命令行的方式设置全局 long_query_time为0.2秒后，再打开一个新的会话B查看该变量会发现 long_query_time=0.2&lt;/p&gt;
&lt;p&gt;但是在会话A中查看session级别的long_query_time依然为默认的10s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;四、慢查日志像binlog那样是真实的日志文件吗？&quot;&gt;四、慢查日志像binlog那样是真实的日志文件吗？&lt;/h4&gt;
&lt;p&gt;在MySQL5.1之前确实慢查日志确实是以文件的形式存在。但是MySQL5.1之后MySQL允许我们可以将慢查日志放入一个数据表中，便于我们查看分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202011/1496926-20201111055545863-476050084.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在公司使用的一般都是5.6～5.7版本。当然即使5.1版本之后支持了将数据放入Table中，默认配置依然是File。&lt;/p&gt;
&lt;p&gt;当然你也可以通过下面的命令将慢查输出类型改成Table&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202011/1496926-20201111055546874-465949173.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;五、慢查有什么危害？&quot;&gt;五、慢查有什么危害？&lt;/h4&gt;
&lt;p&gt;研发同学都知道：对于Linux操作系统来说，一个进程能打开的Socket文件句柄是上限的。即使我们可以动态的调整它的大小，但是也做不到无限大。&lt;/p&gt;
&lt;p&gt;通过命令: 查看进程被限制的使用各种资源的量&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Copyulimit -a 

core file size: 进程崩溃是转储文件大小限制
man loaded memort 最大锁定内存大小
open file 能打开的文件句柄数
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大量的慢查占据MySQL连接（Linux操作系统会为每一条连接创建socket文件），慢查累积到一定程度还会导致正常的SQL得不到连接执行从而变成慢查SQL，最终有可能导致MySQL的连接全部被耗光而夯死。这就是生产级别的事故了。&lt;/p&gt;
&lt;h4 id=&quot;六、如何监控慢查？&quot;&gt;六、如何监控慢查？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;查看曾经执行完成的慢查&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你需要编写一个监控程序探测MySQL的慢查询。那完全可以探测分析MySQL的slow.log&lt;/p&gt;
&lt;p&gt;如果你还不知道slow.log在哪里，可以像下面这样定位到它。slow.log中记录的就是曾经执行过的慢查信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202011/1496926-20201111055547755-592323600.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是你可以尝试使用&lt;code&gt;select sleep(2);&lt;/code&gt;模拟一条慢查SQL&lt;/p&gt;
&lt;p&gt;然后去慢查sql中查看具体的慢查详情。 &lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202011/1496926-20201111055548546-642405184.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看正在进行的慢查SQL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我在A Session中发起SQL，select sleep(60);&lt;/p&gt;
&lt;p&gt;然后在B Session中通过下图的方式可以看到当前正在进行的慢查情况。大家在看的时候注意：Command的类型为Query&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202011/1496926-20201111055549600-1577367955.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;MySQL也为用户提供了一些原生的慢查工具。比如：查看执行时间最长的10条SQL&lt;/p&gt;
&lt;p&gt;mysqldumpslow -s a1 -n 10 mysql.slow_log&lt;/p&gt;
&lt;p&gt;了解即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;七、线上出慢查了如何处理？&quot;&gt;七、线上出慢查了如何处理？&lt;/h4&gt;
&lt;p&gt;首先你得知道通常情况下每个公司都有自己监控系统，或者是监控脚本，具体的监控逻辑就是上节讲述的思路。故一旦出现报警，DBA同学会在第一时间接到消息。&lt;/p&gt;
&lt;p&gt;DBA同学一般都会去联系业务同学，由业务同学去处理这个慢查。（相信已经工作的同学深有这个体会）&lt;/p&gt;
&lt;p&gt;有可能爆出慢查的这套数据库集群是由多个业务同时使用。所以如果慢查影响很严重，DBA同学会询问业务同学是否可以kill 慢查。坚决不能让MySQL夯死！但是kill的方式其实是治标不治本，而且只要kill，就难免会误伤用户的SQL。&lt;/p&gt;
&lt;p&gt;还是这样图：我们可以看到&lt;code&gt;select sleep(60);&lt;/code&gt;已经执行了56秒了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202011/1496926-20201111055550660-1644381907.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是可以使用 &lt;code&gt;kill 12&lt;/code&gt; 来断开它占用的连接。但是kill的方式其实是治标不治本，很可能你刚给它断连，它马上又建立连接了。而且只要kill，就难免会误伤用户的SQL。&lt;/p&gt;
&lt;p&gt;接下来就需要研发同学通过explain分析SQL&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过explain你可能会发现，SQL压根没走任何索引，而且现在表中的数据量巨大无比。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这时就得根据select的内容创建合适索引。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;当然，也可能是数据量太大了，即使走了索引依然超过了阈值。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种情况其实挺糟糕的，DBA同学能做的依然只能是kill这些出事的SQL。最好的解决方案其实是分表，比如将大表拆分成128张小表。如何来不急做分表，可能这条SQL面临被下线的风险。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;通过explain查看SQL执行计划中的key字段。如果发现优化器选择的Key和你预期的Key不一样。那显然是优化器选错了索引。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当你发现优化器选择的索引和你期望的索引不一致时，最快的解决方案是：&lt;code&gt;force index&lt;/code&gt; , 强制指定索引。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;  select a,b,c,d from table force index(keyX) where a between 1 and 9999;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你发现即使你使用了&lt;code&gt;force index&lt;/code&gt;之后，查询依然很慢。这就意味着，你得设计一个更好的索引。&lt;/p&gt;
&lt;p&gt;影响MySQL优化器选错索引的可能有很多。如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基数：&lt;/strong&gt;基数（cardinality）的统计是一个估算的结果，而且它也并不会实时的更新。所以这就可能出现一开始由于数据量小且没有代表性。导致基数很低。导致优化器选错了索引。针对这种情况，可以通过&lt;code&gt;analyze table t&lt;/code&gt; 重新计算统计信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扫描行数、排序&lt;/strong&gt;：更少的扫描行数意味着可能需要更少的磁盘IO，所以MySQL选择扫描行数少的key的可能性就更大。扫描行数并不是优化器选择索引的唯一依据，很可能出现你期望SQL走一个二级索引keyX，但是优化器偏偏走了主键索引。这是因为优化器考虑到了你select a,b,c,d from xxx;可能还有回表,IO代价也很高。&lt;/p&gt;
&lt;p&gt;如果你有order by语句需要mysql帮你做排序，那MySQL就更倾向选一个查询出来的数据本来就有序的索引。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;八、关注我&quot;&gt;八、关注我&lt;/h4&gt;
&lt;p&gt;为大家带来MySQL面试专题！本文是第二篇、全文110篇！&lt;/p&gt;
&lt;p&gt;以问答的方式，由浅入深的帮你应对各类MySQL面试题的狂轰滥炸！当然也不乏会分享一些高阶读写分离数据库中间件原理及落地的技术实现，为你揭开数据库中间件神秘的面纱！&lt;/p&gt;
&lt;p&gt;面试官都关注了！你还在犹豫什么呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202011/1496926-20201111055815817-112407140.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 11 Nov 2020 00:07:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>Hi，大家好！我是白日梦。 今天我要跟你分享的话题是：“聊聊什么是慢查、如何监控？如何排查？” 一、 推荐阅读方式 首发地址：https://mp.weixin.qq.com/s/tXTLMCiVpE</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/13956914.html</dc:identifier>
</item>
<item>
<title>数据治理方案技术调研 Atlas VS Datahub VS Amundsen - 独孤风</title>
<link>http://www.cnblogs.com/tree1123/p/13956910.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tree1123/p/13956910.html</guid>
<description>&lt;p&gt;数据治理意义重大，传统的数据治理采用文档的形式进行管理，已经无法满足大数据下的数据治理需要。而适合于Hadoop大数据生态体系的数据治理就非常的重要了。&lt;/p&gt;
&lt;p&gt;​ 大数据下的数据治理作为很多企业的一个巨大的难题，能找到的数据的解决方案并不多，但是好在近几年，很多公司已经进行了尝试并开源了出来，本文将详细分析这些数据发现平台，在国外已经有了十几种的实现方案。&lt;/p&gt;

&lt;h5 id=&quot;为什么需要一个数据发现平台？&quot;&gt;为什么需要一个数据发现平台？&lt;/h5&gt;
&lt;p&gt;在数据治理过程中，经常会遇到这些问题： 数据都存在哪？ 该如何使用这些数据？ 数据是做什么的？ 数据是如何创建的？ 数据是如何更新的？&lt;/p&gt;
&lt;p&gt;。。。。。&lt;/p&gt;
&lt;p&gt;数据发现平台的目的就是为了解决上面的问题，帮助更好的查找，理解和使用数据。&lt;/p&gt;
&lt;p&gt;比如Facebook的Nemo就使用了全文检索技术，这样可以快速的搜索到目标数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202011/1089984-20201111075340479-1243995638.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户浏览数据表时，如何快速的理解数据？ 一般的方式是把列名，数据类型，描述显示出来，如果用户有权限，还可以预览数据。&lt;/p&gt;
&lt;p&gt;下面是&lt;em&gt;Amundsen&lt;/em&gt;的数据列展示功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202011/1089984-20201111075348874-1734052644.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据ETL是一个大问题，特别是如何把这些展示出来更是非常难，其实数据的ETL是可以用数据的流向图表示的，很多平台都支持这种功能，比如 Databook，还有Metcat。&lt;/p&gt;
&lt;p&gt;Amundsen就和数据调度平台Airflow有着非常好的结合。&lt;/p&gt;

&lt;p&gt;下面一张表 对比一下各大平台对于上述功能的支持情况&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;搜索&lt;/th&gt;
&lt;th&gt;推荐&lt;/th&gt;
&lt;th&gt;表描述&lt;/th&gt;
&lt;th&gt;数据预览&lt;/th&gt;
&lt;th&gt;列统计&lt;/th&gt;
&lt;th&gt;占用指标&lt;/th&gt;
&lt;th&gt;权限&lt;/th&gt;
&lt;th&gt;排名&lt;/th&gt;
&lt;th&gt;数据血统&lt;/th&gt;
&lt;th&gt;改变通知&lt;/th&gt;
&lt;th&gt;开源&lt;/th&gt;
&lt;th&gt;文档&lt;/th&gt;
&lt;th&gt;支持数据源&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;14.5&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;Amundsen (Lyft)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;Todo&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;Hive, Redshift, Druid, RDBMS, Presto, Snowflake, etc.&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Datahub (LinkedIn)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;Hive, Kafka, RDBMS&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;Metacat (Netflix)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;Todo&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;Todo&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;Hive, RDS, Teradata, Redshift, S3, Cassandra&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;Atlas (Apache)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;HBase, Hive, Sqoop, Kafka, Storm&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Marquez (Wework）&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;S3, Kafka&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;Databook (Uber)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;Hive, Vertica, MySQL, Postgress, Cassandra&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Dataportal (Airbnb)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;Unknown&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Data Access Layer (Twitter)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;HDFS, Vertica, MySQL&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Lexikon (Spotify)&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;Unknown&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;这里介绍一下五个开源的解决方案&quot;&gt;这里介绍一下五个开源的解决方案&lt;/h5&gt;
&lt;h3 id=&quot;datahub-linkedin）&quot;&gt;DataHub (LinkedIn）&lt;/h3&gt;
&lt;p&gt;LinkedIn开源出来的，原来叫做WhereHows 。经过一段时间的发展datahub于2020年2月在Github开源&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/linkedin/datahub&quot;&gt;https://github.com/linkedin/datahub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202011/1089984-20201111075401207-1978828807.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以说是一个非常充满活力的项目，有着表结构，搜索，数据血统等功能，还有用户和组等功能。&lt;/p&gt;
&lt;p&gt;官方也提供了文档。开源版本支持Hive，Kafka和关系数据库中的元数据。&lt;/p&gt;
&lt;p&gt;所以Datahub的使用率还是非常高的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202011/1089984-20201111075413561-1405339912.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;amundsen-lyft）&quot;&gt;Amundsen (Lyft）&lt;/h3&gt;
&lt;p&gt;Lyft 于2019年4月开发了Amundsen，并与10月开源。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/amundsen-io/amundsen&quot;&gt;https://github.com/amundsen-io/amundsen&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202011/1089984-20201111075420818-443985358.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Amundsen提供了搜索与排名的功能，帮助更好的查找数据表。&lt;/p&gt;
&lt;p&gt;支持的数据源非常丰富，支持hive ，druid等超过15个数据源，而且还提供与任务调度airflow的融合，并提供了与superset等BI工具的集成方式。&lt;/p&gt;
&lt;p&gt;而数据血统的功能也正在开发之中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202011/1089984-20201111075427334-1828991195.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;metacat（netflix）&quot;&gt;Metacat（Netflix）&lt;/h3&gt;
&lt;p&gt;Netflix在2018年6月开源了Metacat。&lt;/p&gt;
&lt;p&gt;Metacat支持Hive，Teradata，Redshift，S3，Cassandra和RDS的集成。&lt;/p&gt;
&lt;p&gt;不过虽然Metacat开源，但是官方没有提供文档，资料也很少。&lt;/p&gt;
&lt;h3 id=&quot;marquez-wework）&quot;&gt;Marquez (WeWork）&lt;/h3&gt;
&lt;p&gt;Wework于2018年10月开源了Marquez&lt;/p&gt;
&lt;p&gt;Marquez也对Airflow有着很好的支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202011/1089984-20201111075434494-532143265.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到Marquez还在持续的更新中，保持关注。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202011/1089984-20201111075447300-115983386.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;apache-atlas（hortonworks）&quot;&gt;Apache Atlas（Hortonworks）&lt;/h3&gt;
&lt;p&gt;作为数据治理计划的一部分，Atlas于2015年7月开始在Hortonworks进行孵化。&lt;/p&gt;
&lt;p&gt;Atlas 1.0于2018年6月发布，当前版本是2.1。&lt;/p&gt;
&lt;p&gt;Atlas的主要目标是数据治理，支持与HBase，Hive和Kafka的集成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202011/1089984-20201111075454869-1618494130.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;github地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/apache/atlas&quot;&gt;https://github.com/apache/atlas&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202011/1089984-20201111075511576-176538785.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;丰富的文档&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202011/1089984-20201111075524562-1882811768.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先说一下笔者的选择，虽然对datahub和amundsen非常的感兴趣，最后还是选择了Atlas。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202011/1089984-20201111075540271-1339357143.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开源，文档的丰富程度，功能，这些在上文表格中都做了详细的对比，如何选择还是要考虑实际情况。&lt;/p&gt;
&lt;p&gt;开源的有五家： Amundsen Datahub Metacat Marquez Atlas&lt;/p&gt;
&lt;p&gt;有文档的有三家： Amundsen Datahub Atlas&lt;/p&gt;
&lt;p&gt;搜索功能较强 ： Amundsen&lt;/p&gt;
&lt;p&gt;有数据血统功能： Datahub Atlas&lt;/p&gt;
&lt;p&gt;考虑到项目的周期，实施性等情况，还是建议大家从Atlas入门，打开数据治理的探索之路。&lt;/p&gt;
&lt;p&gt;当然也有公司同时采用了Atlas和Amundsen，Atlas处理元数据管理，利用Amundsen强大的数据搜索能力来做数据搜索，这也是一种不错的选择。&lt;/p&gt;
&lt;p&gt;欢迎大家关注 “实时流式计算”&lt;/p&gt;
&lt;p&gt;未来， “实时流式计算” 将推出Atlas 2.1 部署与实践 系列文章，推开数据治理之门。&lt;/p&gt;
&lt;p&gt;更多Flink，Kafka等实时大数据分析相关技术博文，科技资讯，欢迎关注实时流式计算 公众号后台回复 “电子书” 下载300页Flink实战电子书&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1089984/202005/1089984-20200511083216576-1437389309.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Tue, 10 Nov 2020 23:57:00 +0000</pubDate>
<dc:creator>独孤风</dc:creator>
<og:description>数据治理意义重大，传统的数据治理采用文档的形式进行管理，已经无法满足大数据下的数据治理需要。而适合于Hadoop大数据生态体系的数据治理就非常的重要了。 ​	大数据下的数据治理作为很多企业的一个巨大的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tree1123/p/13956910.html</dc:identifier>
</item>
<item>
<title>.NET 5 和 C#9 /F#5 一起到来, 向实现 .NET 统一迈出了一大步 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/13956884.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/13956884.html</guid>
<description>&lt;p&gt;&lt;span&gt;经过一年多的开发，Microsoft 于北京时间&lt;/span&gt; &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/announcing-net-5-0/&quot;&gt;&lt;span&gt;11 月 11 日（星期三）发布了其 .NET 5&lt;/span&gt;&lt;/a&gt;&lt;span&gt;软件开发平台，强调平台的统一，并引入了 C# 9 和 F# 5 编程语言，新平台朝着桌面、Web、移动、云和 IoT 目标统一 .NET 开发体验的方向发展。.NET 5&lt;/span&gt;&lt;span&gt;被描述为 Microsoft .NET 统一之旅&lt;/span&gt;&lt;span&gt;中的第一个版本，它是为了使更多的开发人员群体能够将 .NET 框架代码和应用迁移到 .NET 5。该平台将来自 .NET Framework、.NET Core 和 Mono 的元素组合在一起，为所有现代 .NET 代码创建单个平台。工作已经完成，不过 Xamarin 开发人员还需要在一年内发布 .NET 6.0 时使用 .NET 平台。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202011/510-20201111064035767-967175224.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;900&quot; height=&quot;377&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202011/510-20201111064036716-1926481282.png&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202011/510-20201111064037410-596987368.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;900&quot; height=&quot;519&quot; title=&quot;e94b820a8a98aeed651c0bbbc0f687e&quot; alt=&quot;e94b820a8a98aeed651c0bbbc0f687e&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202011/510-20201111064038116-2030624618.png&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;.NET 5 可从&lt;/span&gt;&lt;a href=&quot;https://dotnet.microsoft.com/download/dotnet/5.0&quot;&gt;&lt;span&gt;dotnet.microsoft.com或&lt;/span&gt;&lt;/a&gt;&lt;span&gt;新发布的 Visual&lt;/span&gt; &lt;span&gt;Studio 2019 更新 16.8 得到&lt;/span&gt;&lt;span&gt;。.NET 5 中的其他关键功能包括：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Windows ARM64 支持。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Windows 桌面开发增强功能。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;改进了 JSON 序列化器 API。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;空的引用类型注释。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Web 和云原生。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;单个文件应用程序和较小的容器映像。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;性能提高，gRPC 性能据说超过 Go、C++ Java。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;全堆栈 .NET 应用与Blazor Web UI 框架，支持 Blazor 服务器和 Blazor WebAssembly，它支持 .NET Core框架库，并在 .NET 5 中跑的更快。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;新的模型是支持&lt;/span&gt;&lt;a href=&quot;https://github.com/dotnet/runtime/issues/35318&quot;&gt;&lt;span&gt;WinRT API&lt;/span&gt;&lt;/a&gt;&lt;span&gt;的特色，包括调用 API、在两个类型系统之间封送数据以及要跨类型系统或 ABI 边界处理相同的类型的统一。现有的 WinRT 互操作系统已从 .NET 运行时中删除。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202011/510-20201111064309197-184680713.png&quot;&gt;&lt;span&gt;&lt;img width=&quot;900&quot; height=&quot;512&quot; title=&quot;271cd7f7e369693d481125040e1f49d&quot; alt=&quot;271cd7f7e369693d481125040e1f49d&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202011/510-20201111064039583-891190986.png&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时，C# 9&lt;/span&gt;&lt;span&gt;侧重于程序简单性、面向数据的类和更多模式。&lt;/span&gt;&lt;span&gt;F# 5&lt;/span&gt;&lt;span&gt;是微软函数编程语言的升级，添加了插值字符串和打开类型声明。此外， NET 5 中的ASP.NET Core Web 开发平台还改进了 MVC 模型绑定、Azure AD 身份验证和 SignlR 集线器筛选器和并行集线器调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Microsoft 对 .NET 的愿景推荐采用 .NET 5 到 .NET 6&quot; Wave&quot;，该&quot;Wave&quot;包括单个 SDK、跨平台本机 UI 和云原生投资。计划要求每年 11 月发布主要 .NET 版本，所有其他版本都是长期支持版本。下一个 LTS 版本是 NET 6.0。将根据需要提供次要版本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;934&quot; height=&quot;526&quot; alt=&quot;Mid 300 1600x900&quot; src=&quot;https://papercallio-production.s3.amazonaws.com/uploads/event/logo/3656/mid_300_1600x900.png&quot;/&gt;&lt;/p&gt;

&lt;h5&gt;&lt;span&gt;.NET Conf 是由 .NET 社区和 Microsoft 共同组织的为期三天（2020 年 11 月 10 日- 12 日）的免费虚拟开发人员活动。今年.NET 5.0 将在 .NET Conf 2020 上推出！来庆祝一下，了解新版本.NET 。&lt;/span&gt;&lt;/h5&gt;
&lt;h5&gt;&lt;span&gt;.NET Conf 从一开始就是一个虚拟活动，今年还是10周年活动，在三天中，我们提供广泛的现场会议选择，以社区和 .NET 团队成员的演讲者为特色。在会议的第二天和第三天之间每天24小时进行直播，因此每个人都可以参与其中，无论他们的时区如何。详细内容参见&lt;/span&gt; &lt;a href=&quot;https://www.dotnetconf.net/agenda&quot;&gt;&lt;span&gt;https://www.dotnetconf.net/agenda&lt;/span&gt;&lt;/a&gt;&lt;/h5&gt;
</description>
<pubDate>Tue, 10 Nov 2020 22:41:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>经过一年多的开发，Microsoft 于北京时间 11 月 11 日（星期三）发布了其 .NET 5软件开发平台，强调平台的统一，并引入了 C# 9 和 F# 5 编程语言，新平台朝着桌面、Web、移</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/13956884.html</dc:identifier>
</item>
<item>
<title>3.2spring源码系列----循环依赖源码分析 - 盛开的太阳</title>
<link>http://www.cnblogs.com/ITPower/p/13956880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ITPower/p/13956880.html</guid>
<description>&lt;p&gt;首先,我们在&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/ITPower/p/13941844.html&quot;&gt;3.1 spring5源码系列--循环依赖 之 手写代码模拟spring循环依赖&lt;/a&gt; 中手写了循环依赖的实现. 这个实现就是模拟的spring的循环依赖. 目的是为了更容易理解spring源码.&lt;/p&gt;
&lt;p&gt;下面我们就进入正题, 看看spring的循环依赖源码.&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202011/1187916-20201110094447686-1057729527.png&quot; width=&quot;1200&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;目标很明确了, 就是要看看spring如何解决循环依赖的. &lt;/p&gt;
&lt;p&gt;代码入口是refresh()#finishBeanFactoryInitialization(beanFactory);&lt;/p&gt;

&lt;p&gt;调用方法beanFactory.preInstantiateSingletons();实例化剩余的单例bean. 为什么是剩余的?很显然我们在上面已经实例化一部分了.比如配置类, postProcessor等.&lt;/p&gt;
&lt;h2&gt;2.1 入口&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 1 &lt;span&gt;@Override
 2     public void&lt;span&gt; preInstantiateSingletons() throws BeansException {
 3         if&lt;span&gt; (logger.isTraceEnabled()) {
 4             logger.trace(&quot;Pre-instantiating singletons in &quot; + this&lt;span&gt;);
 5 &lt;span&gt;        }
 6 
 7 
 8         // 获取容器中所有bean定义的名字
 9         List&amp;lt;String&amp;gt; beanNames = new ArrayList&amp;lt;&amp;gt;(this&lt;span&gt;.beanDefinitionNames);
10 
11         // Trigger initialization of all non-lazy singleton beans...
12         /**
13          * &lt;strong&gt;第一步: 循环bean定义的name
&lt;/strong&gt;14          */
15         for&lt;span&gt; (String beanName : &lt;strong&gt;beanNames&lt;/strong&gt;) {
16             // 获取bean定义
17             RootBeanDefinition bd =&lt;span&gt; getMergedLocalBeanDefinition(beanName);
18             //&lt;strong&gt; 生产bean定义的条件:&lt;/strong&gt; 不是抽象的, 是单例的, 不是懒加载的. 符合这个标准的, 最后才会调用getBean()生产bean
19             if (!bd.isAbstract() &amp;amp;&amp;amp; bd.isSingleton() &amp;amp;&amp;amp; !&lt;span&gt;bd.isLazyInit()) {
20                 // 这里判断是不是工厂bean, 这里和BeanFactory不是一个意思, 判断当前这个bean是否实现了beanFactory的接口
21                 if&lt;span&gt; (isFactoryBean(beanName)) {
22                     Object bean = getBean(FACTORY_BEAN_PREFIX +&lt;span&gt; beanName);
23                     if&lt;span&gt; (bean instanceof FactoryBean) {
24                         final FactoryBean&amp;lt;?&amp;gt; factory = (FactoryBean&amp;lt;?&amp;gt;&lt;span&gt;) bean;
25 &lt;span&gt;                        boolean isEagerInit;
26                         if (System.getSecurityManager() != null &amp;amp;&amp;amp;&lt;span&gt; factory instanceof SmartFactoryBean) {
27                             isEagerInit = AccessController.doPrivileged((PrivilegedAction&amp;lt;Boolean&amp;gt;&lt;span&gt;)
28                                             ((SmartFactoryBean&amp;lt;?&amp;gt;&lt;span&gt;) factory)::isEagerInit,
29 &lt;span&gt;                                    getAccessControlContext());
30 &lt;span&gt;                        }
31                         else&lt;span&gt; {
32                             isEagerInit = (factory instanceof SmartFactoryBean &amp;amp;&amp;amp;
33                                     ((SmartFactoryBean&amp;lt;?&amp;gt;&lt;span&gt;) factory).isEagerInit());
34 &lt;span&gt;                        }
35                         if&lt;span&gt; (isEagerInit) {
36                             // 获取bean
37 &lt;span&gt;                            getBean(beanName);
38 &lt;span&gt;                        }
39 &lt;span&gt;                    }
40 &lt;span&gt;                }
41                 else&lt;span&gt; {&lt;br/&gt;　　　　　　　　　　　　　　&lt;strong&gt;// 第二步: 调用bean定义
&lt;/strong&gt;42 &lt;span&gt;                    getBean(beanName);
43 &lt;span&gt;                }
44 &lt;span&gt;            }
45 &lt;span&gt;        }
46 
47         // Trigger post-initialization callback for all applicable beans...
48         /**
49          * 循环bean定义的name
50          */
51         for&lt;span&gt; (String beanName : beanNames) {
52             // 从缓存中得到实例instance
53             Object singletonInstance =&lt;span&gt; getSingleton(beanName);
54             if&lt;span&gt; (singletonInstance instanceof SmartInitializingSingleton) {
55                 final SmartInitializingSingleton smartSingleton =&lt;span&gt; (SmartInitializingSingleton) singletonInstance;
56                 if (System.getSecurityManager() != null&lt;span&gt;) {
57                     AccessController.doPrivileged((PrivilegedAction&amp;lt;Object&amp;gt;) () -&amp;gt;&lt;span&gt; {
58 &lt;span&gt;                        smartSingleton.afterSingletonsInstantiated();
59                         return null&lt;span&gt;;
60 &lt;span&gt;                    }, getAccessControlContext());
61 &lt;span&gt;                }
62                 else&lt;span&gt; {
63 &lt;span&gt;                    smartSingleton.afterSingletonsInstantiated();
64 &lt;span&gt;                }
65 &lt;span&gt;            }
66 &lt;span&gt;        }
67     }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;首先, 循环bean定义, 这和我们模拟spring循环的第一步是一样的. &lt;/h4&gt;
&lt;h4&gt;第二步: 判断从BeanDefinitionMap中取出来的这个bean是否满足生产bean的条件&lt;/h4&gt;
&lt;p&gt;我们注意代码注释中, &lt;strong&gt;生产bean定义的条件:&lt;/strong&gt; 不是抽象的, 是单例的, 不是懒加载的. 符合这个标准的, 最后才会调用getBean()生产bean&lt;/p&gt;
&lt;h4&gt;然后:调用getBean()&lt;/h4&gt;
&lt;p&gt;到目前为止,我们完成了上图源码图的第一部分:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202011/1187916-20201111051548301-1907912992.png&quot; width=&quot;500&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2&gt; 2.2 创建bean前的准备工作&lt;/h2&gt;
&lt;p&gt;接下来看看getBean().doGetBean()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;96&quot;&gt;
&lt;pre&gt;
  1 protected &amp;lt;T&amp;gt; T doGetBean(final String name, @Nullable final Class&amp;lt;T&amp;gt;&lt;span&gt; requiredType,
  2 &lt;span&gt;            @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
  3 
  4         //&lt;strong&gt; 第一步: 转换bean name. 在这里传入进来的name可能是别名, 也有可能是工厂bean的name, 所以在这里进行一个转换&lt;/strong&gt;
  5         final String beanName =&lt;span&gt; transformedBeanName(name);
  6 &lt;span&gt;        Object bean;
  7 
  8         // Eagerly check singleton cache for manually registered singletons.
  9         //&lt;strong&gt; 第二步: 尝试去缓存中获取对象, 如果没有获取到就创建bean&lt;/strong&gt;
 10         Object sharedInstance =&lt;span&gt; getSingleton(beanName);
 11         if (sharedInstance != null &amp;amp;&amp;amp; args == null&lt;span&gt;) {
 12             if&lt;span&gt; (logger.isTraceEnabled()) {
 13                 //判断当前类是否是正在创建中
 14                 if&lt;span&gt; (isSingletonCurrentlyInCreation(beanName)) {
 15                     logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName +
 16                             &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;&lt;span&gt;);
 17 &lt;span&gt;                }
 18                 else&lt;span&gt; {
 19                     logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;&lt;span&gt;);
 20 &lt;span&gt;                }
 21 &lt;span&gt;            }
 22             bean = getObjectForBeanInstance(sharedInstance, name, beanName, null&lt;span&gt;);
 23 &lt;span&gt;        }
 24 
 25         else&lt;span&gt; {
 26             // Fail if we're already creating this bean instance:
 27             // We're assumably within a circular reference.
 28             /**
 29              * &lt;strong&gt;判断当前的bean是不是多例, 如果是这抛出异常
&lt;/strong&gt; 30              *
 31              * 判断当前这个bean是不是多例bean. 如果配置了@Scope(&quot;prototype&quot;) 就表示这是一个多例的bean
 32              * spring 只能解决单例对象的setter注入的循环依赖, 不能解决构造器注入
 33              *
 34              * 如果是多例的bean, 当前正在创建bean, 也会抛出异常---这也是循环依赖的问题
 35              */
 36             if&lt;span&gt; (isPrototypeCurrentlyInCreation(beanName)) {
 37                 throw new&lt;span&gt; BeanCurrentlyInCreationException(beanName);
 38 &lt;span&gt;            }
 39 
 40             /**
 41              * 下面这段代码是关于子父容器的, 只有spring mvc继承自spring, 才会有子父容器的问题.
 42              */
 43             // Check if bean definition exists in this factory.
 44             BeanFactory parentBeanFactory =&lt;span&gt; getParentBeanFactory();
 45             if (parentBeanFactory != null &amp;amp;&amp;amp; !&lt;span&gt;containsBeanDefinition(beanName)) {
 46                 // Not found -&amp;gt; check parent.
 47                 String nameToLookup =&lt;span&gt; originalBeanName(name);
 48                 if&lt;span&gt; (parentBeanFactory instanceof AbstractBeanFactory) {
 49                     return&lt;span&gt; ((AbstractBeanFactory) parentBeanFactory).doGetBean(
 50 &lt;span&gt;                            nameToLookup, requiredType, args, typeCheckOnly);
 51 &lt;span&gt;                }
 52                 else if (args != null&lt;span&gt;) {
 53                     // Delegation to parent with explicit args.
 54                     return&lt;span&gt; (T) parentBeanFactory.getBean(nameToLookup, args);
 55 &lt;span&gt;                }
 56                 else if (requiredType != null&lt;span&gt;) {
 57                     // No args -&amp;gt; delegate to standard getBean method.
 58                     return&lt;span&gt; parentBeanFactory.getBean(nameToLookup, requiredType);
 59 &lt;span&gt;                }
 60                 else&lt;span&gt; {
 61                     return&lt;span&gt; (T) parentBeanFactory.getBean(nameToLookup);
 62 &lt;span&gt;                }
 63 &lt;span&gt;            }
 64 
 65             /**
 66              * 方法参数typeCheckOnly是用来判断#getBean()方法时, 表示是否为仅仅进行类型检查,
 67              * 如果不仅仅做类型检查, 而是创建bean对象, 则需要调用#markBeanAsCreated(String name)
 68              *
 69              */
 70             if (!&lt;span&gt;typeCheckOnly) {
 71 &lt;span&gt;                markBeanAsCreated(beanName);
 72 &lt;span&gt;            }
 73 
 74             try&lt;span&gt; {
 75                 final RootBeanDefinition mbd =&lt;span&gt; getMergedLocalBeanDefinition(beanName);
 76 &lt;span&gt;                checkMergedBeanDefinition(mbd, beanName, args);
 77 
 78                 // Guarantee initialization of beans that the current bean depends on.
 79                 /**
 80                  * 现在有两个bean1, bean2 , 加载的时候调用的是bean1, bean2. 但如果我们想要bean2优先加载, 就使用@DependOn注解
 81                  * 用来解析带有dependOn注解的类
 82                  */
 83                 String[] dependsOn =&lt;span&gt; mbd.getDependsOn();
 84                 if (dependsOn != null&lt;span&gt;) {
 85                     for&lt;span&gt; (String dep : dependsOn) {
 86                         if&lt;span&gt; (isDependent(beanName, dep)) {
 87                             throw new&lt;span&gt; BeanCreationException(mbd.getResourceDescription(), beanName,
 88                                     &quot;Circular depends-on relationship between '&quot; + beanName + &quot;' and '&quot; + dep + &quot;'&quot;&lt;span&gt;);
 89 &lt;span&gt;                        }
 90 &lt;span&gt;                        registerDependentBean(dep, beanName);
 91                         try&lt;span&gt; {
 92 &lt;span&gt;                            getBean(dep);
 93 &lt;span&gt;                        }
 94                         catch&lt;span&gt; (NoSuchBeanDefinitionException ex) {
 95                             throw new&lt;span&gt; BeanCreationException(mbd.getResourceDescription(), beanName,
 96                                     &quot;'&quot; + beanName + &quot;' depends on missing bean '&quot; + dep + &quot;'&quot;&lt;span&gt;, ex);
 97 &lt;span&gt;                        }
 98 &lt;span&gt;                    }
 99 &lt;span&gt;                }
100 
101                 // Create bean instance.
102                 /**
103                  * &lt;strong&gt;第三步: 创建单例bean实例
&lt;/strong&gt;104                  */
105                 if (mbd.isSingleton()) { // 处理单例bean
106                     /**
107                      * 这里getSingleton()和上面的getSigleton不一样, 上面的是从一级缓存中拿.
108                      * 这个getSingleton()就办了一件事: 将bean设置为正在创建的状态. 这个状态很重要, 如果出现循环依赖, 发现bean正在创建, 就不会再创建了
109                      */
110                     sharedInstance = getSingleton(beanName, () -&amp;gt;&lt;span&gt; {
111                         try&lt;span&gt; {
112                             return&lt;span&gt; createBean(beanName, mbd, args);
113 &lt;span&gt;                        }
114                         catch&lt;span&gt; (BeansException ex) {
115                             // Explicitly remove instance from singleton cache: It might have been put there
116                             // eagerly by the creation process, to allow for circular reference resolution.
117                             // Also remove any beans that received a temporary reference to the bean.
118 &lt;span&gt;                            destroySingleton(beanName);
119                             throw&lt;span&gt; ex;
120 &lt;span&gt;                        }
121 &lt;span&gt;                    });
122                     // 得到bean实例对象
123                     bean =&lt;span&gt; getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
124 &lt;span&gt;                }
125 
126                 else if (mbd.isPrototype()) { // 处理多例bean
127                     // It's a prototype -&amp;gt; create a new instance.
128                     Object prototypeInstance = null&lt;span&gt;;
129                     try&lt;span&gt; {
130                         // 当前正在创建多例bean
131 &lt;span&gt;                        beforePrototypeCreation(beanName);
132                         // 执行创建bean
133                         prototypeInstance =&lt;span&gt; createBean(beanName, mbd, args);
134 &lt;span&gt;                    }
135                     finally&lt;span&gt; {
136 &lt;span&gt;                        afterPrototypeCreation(beanName);
137 &lt;span&gt;                    }
138                     // 获取bean实例对象
139                     bean =&lt;span&gt; getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
140 &lt;span&gt;                }
141 
142                 else { // 处理其他类型的bean
143                     String scopeName =&lt;span&gt; mbd.getScope();
144                     final Scope scope = this.scopes.get&lt;span&gt;(scopeName);
145                     if (scope == null&lt;span&gt;) {
146                         throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;&lt;span&gt;);
147 &lt;span&gt;                    }
148                     try&lt;span&gt; {
149                         Object scopedInstance = scope.get(beanName, () -&amp;gt;&lt;span&gt; {
150 &lt;span&gt;                            beforePrototypeCreation(beanName);
151                             try&lt;span&gt; {
152                                 return&lt;span&gt; createBean(beanName, mbd, args);
153 &lt;span&gt;                            }
154                             finally&lt;span&gt; {
155 &lt;span&gt;                                afterPrototypeCreation(beanName);
156 &lt;span&gt;                            }
157 &lt;span&gt;                        });
158                         bean =&lt;span&gt; getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
159 &lt;span&gt;                    }
160                     catch&lt;span&gt; (IllegalStateException ex) {
161                         throw new&lt;span&gt; BeanCreationException(beanName,
162                                 &quot;Scope '&quot; + scopeName + &quot;' is not active for the current thread; consider &quot; +
163                                 &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;&lt;span&gt;,
164 &lt;span&gt;                                ex);
165 &lt;span&gt;                    }
166 &lt;span&gt;                }
167 &lt;span&gt;            }
168             catch&lt;span&gt; (BeansException ex) {
169 &lt;span&gt;                cleanupAfterBeanCreationFailure(beanName);
170                 throw&lt;span&gt; ex;
171 &lt;span&gt;            }
172         } &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在这里, 首先从缓存中获取bean, 看缓存中是否已经存在了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 Object sharedInstance = getSingleton(beanName);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后, 如果缓存中已经存在了,那么久直接取出来. 代码如下: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
　　　　if (&lt;strong&gt;sharedInstance != null &amp;amp;&amp;amp; args == null&lt;/strong&gt;&lt;span&gt;) {
            if&lt;span&gt; (logger.isTraceEnabled()) {
                //判断当前bean是否是正在创建中(单例bean)
                if&lt;span&gt; (isSingletonCurrentlyInCreation(beanName)) {
                    logger.trace(&quot;Returning eagerly cached instance of singleton bean '&quot; + beanName +
                            &quot;' that is not fully initialized yet - a consequence of a circular reference&quot;&lt;span&gt;);
                }
                else&lt;span&gt; {
                    logger.trace(&quot;Returning cached instance of singleton bean '&quot; + beanName + &quot;'&quot;&lt;span&gt;);
                }
            }
            &lt;strong&gt;bean &lt;/strong&gt;&lt;strong&gt;= getObjectForBeanInstance(sharedInstance, name, beanName, null&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;);&lt;/strong&gt;
        }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是空, 就说明是第一次创建, 执行else的部分&lt;/p&gt;
&lt;h4&gt;首先, 判断是否是正在创建的多例bean, 如果是正在创建的多例bean, 就抛出异常,&lt;/h4&gt;
&lt;p&gt;　　已经是正在创建了, 说明这至少是第二次了, 这里处理的是单例bean的循环依赖, 不处理多例bean的循环依赖, 所以抛出异常&lt;/p&gt;
&lt;p&gt;　　对应的代码是这一句&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
// Fail if we're already creating this bean instance:
 27             // We're assumably within a circular reference.
 28             /**
 29              * 判断当前的bean是不是多例, 如果是这抛出异常
 30              *
 31              * 判断当前这个bean是不是多例bean. 如果配置了@Scope(&quot;prototype&quot;) 就表示这是一个多例的bean
 32              * spring 只能解决单例对象的setter注入的循环依赖, 不能解决构造器注入
 33              *
 34              * 如果是多例的bean, 当前正在创建bean, 也会抛出异常---这也是循环依赖的问题
 35              */
 36             if&lt;span&gt; (isPrototypeCurrentlyInCreation(beanName)) {
 37                 throw new&lt;span&gt; BeanCurrentlyInCreationException(beanName);
 38             }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么, 接下来就是首次创建bean. 首次创建的bean有三种情况:&lt;/p&gt;
&lt;p&gt;　　第一种, 这个bean是单例的.&lt;/p&gt;
&lt;p&gt;　　第二种, 这个bean是多例的.&lt;/p&gt;
&lt;p&gt;　　第三种. 其他类型&lt;/p&gt;
&lt;p&gt;对应的代码就是这一块. 有行号, 可以和上面一一对应上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
// Create bean instance.
102                 /**
103                  * &lt;strong&gt;第三步: 创建单例bean实例&lt;/strong&gt;
104                  */
105                 &lt;strong&gt;if (mbd.isSingleton()) { // 处理单例bean&lt;/strong&gt;
106                     /**
107                      * 这里getSingleton()和上面的getSigleton不一样, 上面的是从一级缓存中拿.
108                      * 这个getSingleton()就办了一件事: 将bean设置为正在创建的状态. 这个状态很重要, 如果出现循环依赖, 发现bean正在创建, 就不会再创建了
109                      */
110                     sharedInstance = getSingleton(beanName, () -&amp;gt;&lt;span&gt; {
111                         try&lt;span&gt; {
112                             return&lt;span&gt; createBean(beanName, mbd, args);
113&lt;span&gt;                         }
114                         catch&lt;span&gt; (BeansException ex) {
115                             // Explicitly remove instance from singleton cache: It might have been put there
116                             // eagerly by the creation process, to allow for circular reference resolution.
117                             // Also remove any beans that received a temporary reference to the bean.
118&lt;span&gt;                             destroySingleton(beanName);
119                             throw&lt;span&gt; ex;
120&lt;span&gt;                         }
121&lt;span&gt;                     });
122                     // 得到bean实例对象
123                     bean =&lt;span&gt; getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
124&lt;span&gt;                 }
125 
126                 &lt;strong&gt;else if (mbd.isPrototype()) { // 处理多例bean&lt;/strong&gt;
127                     // It's a prototype -&amp;gt; create a new instance.
128                     Object prototypeInstance = null&lt;span&gt;;
129                     try&lt;span&gt; {
130                         // 当前正在创建多例bean
131&lt;span&gt;                         beforePrototypeCreation(beanName);
132                         // 执行创建bean
133                         prototypeInstance =&lt;span&gt; createBean(beanName, mbd, args);
134&lt;span&gt;                     }
135                     finally&lt;span&gt; {
136&lt;span&gt;                         afterPrototypeCreation(beanName);
137&lt;span&gt;                     }
138                     // 获取bean实例对象
139                     bean =&lt;span&gt; getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
140&lt;span&gt;                 }
141 
142                 &lt;strong&gt;else { // 处理其他类型的bean&lt;/strong&gt;
143                     String scopeName =&lt;span&gt; mbd.getScope();
144                     final Scope scope = this.scopes.get&lt;span&gt;(scopeName);
145                     if (scope == null&lt;span&gt;) {
146                         throw new IllegalStateException(&quot;No Scope registered for scope name '&quot; + scopeName + &quot;'&quot;&lt;span&gt;);
147&lt;span&gt;                     }
148                     try&lt;span&gt; {
149                         Object scopedInstance = scope.get(beanName, () -&amp;gt;&lt;span&gt; {
150&lt;span&gt;                             beforePrototypeCreation(beanName);
151                             try&lt;span&gt; {
152                                 return&lt;span&gt; createBean(beanName, mbd, args);
153&lt;span&gt;                             }
154                             finally&lt;span&gt; {
155&lt;span&gt;                                 afterPrototypeCreation(beanName);
156&lt;span&gt;                             }
157&lt;span&gt;                         });
158                         bean =&lt;span&gt; getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
159&lt;span&gt;                     }
160                     catch&lt;span&gt; (IllegalStateException ex) {
161                         throw new&lt;span&gt; BeanCreationException(beanName,
162                                 &quot;Scope '&quot; + scopeName + &quot;' is not active for the current thread; consider &quot; +
163                                 &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;&lt;span&gt;,
164&lt;span&gt;                                 ex);
165&lt;span&gt;                     }
166                 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们的重点研究对象是单例bean. 所以,重点看单例bean的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
105                &lt;strong&gt; if (mbd.isSingleton()) { // 处理单例bean&lt;/strong&gt;
106                     /**
107                      * 这里getSingleton()和上面的getSigleton不一样, 上面的是从一级缓存中拿.
108                      * 这个getSingleton()就办了一件事: 将bean设置为正在创建的状态. 这个状态很重要, 如果出现循环依赖, 发现bean正在创建, 就不会再创建了
109                      */
110                     sharedInstance = &lt;strong&gt;getSingleton(beanName, () -&amp;gt; {
111                         try {
112                             return createBean(beanName, mbd, args);
113                         }
114                         catch (BeansException ex) {
115                             // Explicitly remove instance from singleton cache: It might have been put there
116                             // eagerly by the creation process, to allow for circular reference resolution.
117                             // Also remove any beans that received a temporary reference to the bean.
118                             destroySingleton(beanName);
119                             throw ex;
120                         }
121                     });
&lt;/strong&gt;122                     // 得到bean实例对象
123                     bean =&lt;span&gt; getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
124                 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的重点是调用了getSingleton(beanName, FactoryObject); FactoryObject是一个接口. 定义了一个钩子方法getObject(). &lt;/p&gt;
&lt;p&gt;这个接口在这里这是进行了定义, 并不会执行. 什么时候执行呢? 后面调用的时候执行. &lt;/p&gt;
&lt;p&gt;下面来看看getSingleton()方法, 钩子方法也是在这里被调用的.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
 1 public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt;&lt;span&gt; singletonFactory) {
 2         Assert.notNull(beanName, &quot;Bean name must not be null&quot;&lt;span&gt;);
 3         synchronized (this&lt;span&gt;.singletonObjects) {
 4             &lt;strong&gt;// 第一步: 从一级缓存中获取单例对象&lt;/strong&gt;
 5             Object singletonObject = this.singletonObjects.get&lt;span&gt;(beanName);
 6             if (singletonObject == null&lt;span&gt;) {
 7                 if (this&lt;span&gt;.singletonsCurrentlyInDestruction) {
 8                     throw new&lt;span&gt; BeanCreationNotAllowedException(beanName,
 9                             &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +
10                             &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;&lt;span&gt;);
11 &lt;span&gt;                }
12                 if&lt;span&gt; (logger.isDebugEnabled()) {
13                     logger.debug(&quot;Creating shared instance of singleton bean '&quot; + beanName + &quot;'&quot;&lt;span&gt;);
14 &lt;span&gt;                }
15                 &lt;strong&gt;// 第二步: 将bean添加到singletonsCurrentlyInCreation中, 表示bean正在创建&lt;/strong&gt;
16 &lt;span&gt;                beforeSingletonCreation(beanName);
17                 boolean newSingleton = false&lt;span&gt;;
18                 boolean recordSuppressedExceptions = (this.suppressedExceptions == null&lt;span&gt;);
19                 if&lt;span&gt; (recordSuppressedExceptions) {
20                     this.suppressedExceptions = new LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;();
21 &lt;span&gt;                }
22                 try&lt;span&gt; {
23                     &lt;strong&gt;// 第三步: 这里调用getObject()钩子方法, 就会回调匿名函数, 调用singletonFactory的createBean()&lt;/strong&gt;
24                     singletonObject =&lt;span&gt; singletonFactory.getObject();
25                     newSingleton = true&lt;span&gt;;
26 &lt;span&gt;                }
27                 catch&lt;span&gt; (IllegalStateException ex) {
28                     // Has the singleton object implicitly appeared in the meantime -&amp;gt;
29                     // if yes, proceed with it since the exception indicates that state.
30                     singletonObject = this.singletonObjects.get&lt;span&gt;(beanName);
31                     if (singletonObject == null&lt;span&gt;) {
32                         throw&lt;span&gt; ex;
33 &lt;span&gt;                    }
34 &lt;span&gt;                }
35                 catch&lt;span&gt; (BeanCreationException ex) {
36                     if&lt;span&gt; (recordSuppressedExceptions) {
37                         for (Exception suppressedException : this&lt;span&gt;.suppressedExceptions) {
38 &lt;span&gt;                            ex.addRelatedCause(suppressedException);
39 &lt;span&gt;                        }
40 &lt;span&gt;                    }
41                     throw&lt;span&gt; ex;
42 &lt;span&gt;                }
43                 finally&lt;span&gt; {
44                     if&lt;span&gt; (recordSuppressedExceptions) {
45                         this.suppressedExceptions = null&lt;span&gt;;
46 &lt;span&gt;                    }
47 &lt;span&gt;                    afterSingletonCreation(beanName);
48 &lt;span&gt;                }
49                 if&lt;span&gt; (newSingleton) {
50 &lt;span&gt;                    addSingleton(beanName, singletonObject);
51 &lt;span&gt;                }
52 &lt;span&gt;            }
53             return&lt;span&gt; singletonObject;
54 &lt;span&gt;        }
55     }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里是调用getBean().&lt;/p&gt;
&lt;p&gt;第一步: 去一级缓存中取成熟的单例bean. 如果拿到了, 就直接返回. 如果没拿到. 那么执行创建. &lt;/p&gt;
&lt;p&gt;第二步: 在创建之前, 先把这个bean放入到正在创建的单例bean集合中. 标记这个bean正在创建中&lt;/p&gt;
&lt;p&gt;第三步: 就是调用钩子方法getObject()了. 这个方法的方法体是在上面定义的. 其内容是去创建实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
　　　　　　　　　　　　sharedInstance = getSingleton(beanName, () -&amp;gt;&lt;span&gt; {
                        try&lt;span&gt; {
                            // 这里定义了一个钩子函数. 此时只是定义, 并不执行. 在真正需要创建bean的地方才会执行
                           &lt;strong&gt; return&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; createBean(beanName, mbd, args);&lt;/strong&gt;
                        }
                        catch&lt;span&gt; (BeansException ex) {
                            // Explicitly remove instance from singleton cache: It might have been put there
                            // eagerly by the creation process, to allow for circular reference resolution.
                            // Also remove any beans that received a temporary reference to the bean.
&lt;span&gt;                            destroySingleton(beanName);
                            throw&lt;span&gt; ex;
                        }
                    });&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的代码逻辑是完成了创建之前的逻辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202011/1187916-20201111053809239-1924124340.png&quot; width=&quot;700&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.3 创建bean &lt;/h2&gt;
&lt;p&gt;下面看看创建bean的过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
　　　　protected&lt;span&gt; Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
            throws BeanCreationException {

        // Instantiate the bean.
        BeanWrapper instanceWrapper = null&lt;span&gt;;
        if&lt;span&gt; (mbd.isSingleton()) {
            instanceWrapper = this&lt;span&gt;.factoryBeanInstanceCache.remove(beanName);
        }
        if (instanceWrapper == null&lt;span&gt;) {
            /**
             *&lt;strong&gt; 第一步: 实例化&lt;/strong&gt;
             * 这里面的调用链非常深, 后面再看
             * bean实例化有两种方式
             * 1. 使用反射:  使用反射也有两种方式,
             *         a. 通过无参构造函数 (默认的方式)
             *             从beanDefinition中可以得到beanClass,
             *             ClassName = BeanDefinition.beanClass
             *             Class clazz = Class.forName(ClassName);
             *             clazz.newInstance();
             *             这样就可以实例化bean了
             *
             *         b. 通过有参函数.
             *            ClassName = BeanDefinition.beanClass
             *             Class clazz = Class.forName(ClassName);
             *             Constractor con = class.getConstractor(args....)
             *             con.newInstance();
             *
             * 2. 使用工厂
             *         我们使用@Bean的方式, 就是使用的工厂模式, 自己控制实例化过程
             *
             */&lt;span&gt;
            instanceWrapper =&lt;span&gt; createBeanInstance(beanName, mbd, args);
        }
        // 这里使用了装饰器的设计模式
        final Object bean =&lt;span&gt; instanceWrapper.getWrappedInstance();
        Class&amp;lt;?&amp;gt; beanType =&lt;span&gt; instanceWrapper.getWrappedClass();
        if (beanType != NullBean.class&lt;span&gt;) {
            mbd.resolvedTargetType =&lt;span&gt; beanType;
        }

        // Allow post-processors to modify the merged bean definition.
        // 允许后置处理器修改已经合并的beanDefinition
&lt;span&gt;        synchronized (mbd.postProcessingLock) {
            if (!&lt;span&gt;mbd.postProcessed) {
                try&lt;span&gt; {
                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                }
                catch&lt;span&gt; (Throwable ex) {
                    throw new&lt;span&gt; BeanCreationException(mbd.getResourceDescription(), beanName,
                            &quot;Post-processing of merged bean definition failed&quot;&lt;span&gt;, ex);
                }
                mbd.postProcessed = true&lt;span&gt;;
            }
        }

        /**
         * 缓存单例bean到三级缓存中, 以防止循环依赖
         * 判断是否是早期引用的bean, 如果是, 则允许提前暴露引用&lt;br/&gt;　　　　　*
         * &lt;strong&gt;判断是否能够早起暴露的条件&lt;/strong&gt;
         *     1. 是单例
         *     2. 允许循环依赖
         *     3. 正在创建的bean
         */&lt;span&gt;
        boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp;&lt;span&gt;
                isSingletonCurrentlyInCreation(beanName));
        if&lt;span&gt; (earlySingletonExposure) {
            if&lt;span&gt; (logger.isTraceEnabled()) {
                logger.trace(&quot;Eagerly caching bean '&quot; + beanName +
                        &quot;' to allow for resolving potential circular references&quot;&lt;span&gt;);
            }
            // 把我们的早期对象包装成一个singletonFactory对象, 该对象提供了getObject()方法, 把静态的bean放到三级缓存中去了.
            addSingletonFactory(beanName, () -&amp;gt;&lt;span&gt; getEarlyBeanReference(beanName, mbd, bean));
        }

        // Initialize the bean instance.
        Object exposedObject =&lt;span&gt; bean;
        try&lt;span&gt; {
            // 第二步:填充属性, 给属性赋值(调用set方法)  这里也是调用的后置处理器
&lt;span&gt;            populateBean(beanName, mbd, instanceWrapper);
            // 第三步: 初始化.
            exposedObject =&lt;span&gt; initializeBean(beanName, exposedObject, mbd);
        }
        catch&lt;span&gt; (Throwable ex) {
            if (ex instanceof BeanCreationException &amp;amp;&amp;amp;&lt;span&gt; beanName.equals(((BeanCreationException) ex).getBeanName())) {
                throw&lt;span&gt; (BeanCreationException) ex;
            }
            else&lt;span&gt; {
                throw new&lt;span&gt; BeanCreationException(
                        mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;&lt;span&gt;, ex);
            }
        }

        /**
         * 初始化完成以后, 判断是否是早期的对象
         * 是循环依赖. 才会走进这里来
          */
        if&lt;span&gt; (earlySingletonExposure) {
            // 去缓存中获取到我们的对象 由于传递的allowEarlyReference是false, 要求只能在一级二级缓存中取
            // 正常的普通的bean(不存在循环依赖的bean) 创建的过程中, 不会把三级缓存提升到二级缓存中.
            Object earlySingletonReference = getSingleton(beanName, false&lt;span&gt;);
            if (earlySingletonReference != null&lt;span&gt;) {
                if (exposedObject ==&lt;span&gt; bean) {
                    exposedObject =&lt;span&gt; earlySingletonReference;
                }
                else if (!this.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp;&lt;span&gt; hasDependentBean(beanName)) {
                    String[] dependentBeans =&lt;span&gt; getDependentBeans(beanName);
                    Set&amp;lt;String&amp;gt; actualDependentBeans = new LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;(dependentBeans.length);
                    for&lt;span&gt; (String dependentBean : dependentBeans) {
                        if (!&lt;span&gt;removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                            actualDependentBeans.add(dependentBean);
                        }
                    }
                    if (!&lt;span&gt;actualDependentBeans.isEmpty()) {
                        throw new&lt;span&gt; BeanCurrentlyInCreationException(beanName,
                                &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; +&lt;span&gt;
                                StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                                &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                                &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                                &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                                &quot;'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.&quot;&lt;span&gt;);
                    }
                }
            }
        }

        // Register bean as disposable.
        try&lt;span&gt; {
            registerDisposableBeanIfNecessary(beanName, bean, mbd);
        }
        catch&lt;span&gt; (BeanDefinitionValidationException ex) {
            throw new&lt;span&gt; BeanCreationException(
                    mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;&lt;span&gt;, ex);
        }

        return&lt;span&gt; exposedObject;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先, 实例化bean, 实例化的方式有两种. 一种是通过反射, 另一种是通过动态代理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
/**
             * &lt;strong&gt;第一步: 实例化&lt;/strong&gt;
             * 这里面的调用链非常深, 后面再看
             * &lt;strong&gt;bean实例化有两种方式&lt;/strong&gt;
             * &lt;strong&gt;1. 使用反射&lt;/strong&gt;:  使用反射也有两种方式,
             *         a. 通过无参构造函数 (默认的方式)
             *             从beanDefinition中可以得到beanClass,
             *             ClassName = BeanDefinition.beanClass
             *             Class clazz = Class.forName(ClassName);
             *             clazz.newInstance();
             *             这样就可以实例化bean了
             *
             *         b. 通过有参函数.
             *            ClassName = BeanDefinition.beanClass
             *             Class clazz = Class.forName(ClassName);
             *             Constractor con = class.getConstractor(args....)
             *             con.newInstance();
             *
             * &lt;strong&gt;2. 使用工厂&lt;/strong&gt;
             *         我们使用@Bean的方式, 就是使用的工厂模式, 自己控制实例化过程
             *
             */&lt;span&gt;
            instanceWrapper = createBeanInstance(beanName, mbd, args);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;判断是否是早期暴露的bean. 满足早期暴露的bean的三个条件是&lt;/p&gt;
&lt;p&gt;1. 是单例的&lt;/p&gt;
&lt;p&gt;2. 允许循环依赖&lt;/p&gt;
&lt;p&gt;3. bean已经是处在正在创建中的行列了.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        /*&lt;strong&gt; 判断是否能够早起暴露的条件&lt;/strong&gt;
         *     1. 是单例
         *     2. 允许循环依赖
         *     3. 正在创建的bean
         */&lt;span&gt;
        boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp;&lt;span&gt;
                isSingletonCurrentlyInCreation(beanName));    &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;创建bean的第二步: 属性赋值&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
// 第二步:填充属性, 给属性赋值(调用set方法)  这里也是调用的后置处理器
populateBean(beanName, mbd, instanceWrapper);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里会判断, 是否带有@Autowired的属性. 分为两种一种是Name,一种是Type&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
@SuppressWarnings(&quot;deprecation&quot;)  // for postProcessPropertyValues
    protected void&lt;span&gt; populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
        if (bw == null&lt;span&gt;) {
            if&lt;span&gt; (mbd.hasPropertyValues()) {
                throw new&lt;span&gt; BeanCreationException(
                        mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;&lt;span&gt;);
            }
            else&lt;span&gt; {
                // Skip property population phase for null instance.
                return&lt;span&gt;;
            }
        }

        // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
        // state of the bean before properties are set. This can be used, for example,
        // to support styles of field injection.
        if (!mbd.isSynthetic() &amp;amp;&amp;amp;&lt;span&gt; hasInstantiationAwareBeanPostProcessors()) {
            for&lt;span&gt; (BeanPostProcessor bp : getBeanPostProcessors()) {
                if&lt;span&gt; (bp instanceof InstantiationAwareBeanPostProcessor) {
                    InstantiationAwareBeanPostProcessor ibp =&lt;span&gt; (InstantiationAwareBeanPostProcessor) bp;
                    if (!&lt;span&gt;ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
                        return&lt;span&gt;;
                    }
                }
            }
        }

        PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null&lt;span&gt;);

        // 判断属性是否有Autowired注解
        int resolvedAutowireMode =&lt;span&gt; mbd.getResolvedAutowireMode();
        &lt;strong&gt;// Autowired是根据名字或者根据类型
        if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode ==&lt;span&gt; AUTOWIRE_BY_TYPE) {
            MutablePropertyValues newPvs = new&lt;span&gt; MutablePropertyValues(pvs);
            // Add property values based on autowire by name if applicable.
            if (resolvedAutowireMode ==&lt;span&gt; AUTOWIRE_BY_NAME) {
                autowireByName(beanName, mbd, bw, newPvs);
            }
            // Add property values based on autowire by type if applicable.
            if (resolvedAutowireMode ==&lt;span&gt; AUTOWIRE_BY_TYPE) {
                autowireByType(beanName, mbd, bw, newPvs);
            }
            pvs =&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; newPvs;
        }&lt;/strong&gt;

        ......&lt;span&gt;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果按照名字注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
　　protected void&lt;span&gt;&lt;strong&gt; autowireByName&lt;/strong&gt;(
            String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {

        String[] propertyNames =&lt;span&gt; unsatisfiedNonSimpleProperties(mbd, bw);
        for&lt;span&gt; (String propertyName : propertyNames) {
            if&lt;span&gt; (containsBean(propertyName)) {
                &lt;strong&gt;// 调用getBean
                Object bean =&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; getBean(propertyName);&lt;/strong&gt;
                pvs.add(propertyName, bean);
                registerDependentBean(propertyName, beanName);
                if&lt;span&gt; (logger.isTraceEnabled()) {
                    logger.trace(&quot;Added autowiring by name from bean name '&quot; + beanName +
                            &quot;' via property '&quot; + propertyName + &quot;' to bean named '&quot; + propertyName + &quot;'&quot;&lt;span&gt;);
                }
            }
            else&lt;span&gt; {
                if&lt;span&gt; (logger.isTraceEnabled()) {
                    logger.trace(&quot;Not autowiring property '&quot; + propertyName + &quot;' of bean '&quot; + beanName +
                            &quot;' by name: no matching bean found&quot;&lt;span&gt;);
                }
            }
        }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会再次调用getBean方法. 构建bean. 这是就有可能出现循环依赖了. &lt;/p&gt;
&lt;p&gt;按类型注入也是一样的. &lt;/p&gt;
&lt;p&gt;只是解析bean的方式不同.&lt;/p&gt;

&lt;h4&gt;创建bean的第三步: 初始化&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 // 第三步: 初始化.
 exposedObject = initializeBean(beanName, exposedObject, mbd);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在初始化bean的时候, 会调用很多的aware. 还会调用init-method方法. 以及bean的后置处理器.&lt;/p&gt;

&lt;h4&gt;第四步:删除实例化和静态方法在缓存中的数据&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
　　 　　/**
         * 初始化完成以后, 判断是否是早期的对象
         * 是循环依赖. 才会走进这里来
          */
        if&lt;span&gt; (earlySingletonExposure) {
            // 去缓存中获取到我们的对象 由于传递的allowEarlyReference是false, 要求只能在一级二级缓存中取
            // 正常的普通的bean(不存在循环依赖的bean) 创建的过程中, 不会把三级缓存提升到二级缓存中.
            Object earlySingletonReference = getSingleton(beanName, false&lt;span&gt;);
            if (earlySingletonReference != null&lt;span&gt;) {
                if (exposedObject ==&lt;span&gt; bean) {
                    exposedObject =&lt;span&gt; earlySingletonReference;
                }
                else if (!this.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp;&lt;span&gt; hasDependentBean(beanName)) {
                    String[] dependentBeans =&lt;span&gt; getDependentBeans(beanName);
                    Set&amp;lt;String&amp;gt; actualDependentBeans = new LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;(dependentBeans.length);
                    for&lt;span&gt; (String dependentBean : dependentBeans) {
                        if (!&lt;span&gt;&lt;strong&gt;removeSingletonIfCreatedForTypeCheckOnly&lt;/strong&gt;(dependentBean)) {
                            actualDependentBeans.add(dependentBean);
                        }
                    }
                    if (!&lt;span&gt;actualDependentBeans.isEmpty()) {
                        throw new&lt;span&gt; BeanCurrentlyInCreationException(beanName,
                                &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; +&lt;span&gt;
                                StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                                &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                                &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                                &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                                &quot;'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.&quot;&lt;span&gt;);
                    }
                }
            }
        }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;strong&gt;removeSingletonIfCreatedForTypeCheckOnly调用方法, 删除缓存.&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;这既是getBean()整个的过程. 中间还有很多细节, 没有往里面深入的看, 因为spring代码非常的深, 看的太深就忘了我们的目标了. 结合之前手写的spring循环依赖的思想看, 还是可以看得懂的. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202011/1187916-20201111062047951-814604419.png&quot; width=&quot;700&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;问题1： 为什么需要二级缓存和三级缓存？&lt;/h2&gt;
&lt;p&gt;二级缓存用来存放早期的bean， 也就是没有被属性赋值和初始化的bean&lt;br/&gt;三级缓存的主要作用是用来解耦. 解耦后异步调用， 三级缓存中保存的是钩子方法，也就是一个接口。在使用的时候调用bean的后置处理器&lt;/p&gt;

&lt;h2&gt;问题2：有没有解决构造函数的循环依赖&lt;/h2&gt;
&lt;p&gt;答案是没有. 因为构造函数是在实例化的时候构建的. 这个时候bean都还没有创建, 所以没有办法处理循环依赖.如果出现构造函数的循环依赖, 是会直接报错的..&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;问题3：有没有解决多例下的循环依赖&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;也是没有的, 因为我们会判断, 如果是多例, 那么会抛出异常&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 1             /**
 2              * 第二步: 判断当前bean是否是正在创建中的多例bean, 如果是就抛出异常
 3              *
 4              * 2. 判断当前这个bean是不是多例bean. 如果配置了@Scope(&quot;prototype&quot;) 就表示这是一个多例的bean
 5              * spring 只能解决单例对象的setter注入的循环依赖, 不能解决构造器注入
 6              *
 7              * 如果是多例的bean, 当前正在创建bean, 也会抛出异常---这也是循环依赖的问题
 8              */
 9             if&lt;span&gt; (isPrototypeCurrentlyInCreation(beanName)) {
10                 throw new&lt;span&gt; BeanCurrentlyInCreationException(beanName);
11             }          &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 10 Nov 2020 22:27:00 +0000</pubDate>
<dc:creator>盛开的太阳</dc:creator>
<og:description>首先,我们在3.1 spring5源码系列--循环依赖 之 手写代码模拟spring循环依赖&amp;#160;中手写了循环依赖的实现. 这个实现就是模拟的spring的循环依赖. 目的是为了更容易理解spr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ITPower/p/13956880.html</dc:identifier>
</item>
<item>
<title>谈谈对不同I/O模型的理解 (阻塞/非阻塞IO，同步/异步IO) - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/13938877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/13938877.html</guid>
<description>&lt;p&gt;　　最近通过对ucore操作系统的学习，让我打开了操作系统内核这一黑盒子，与之前所学知识结合起来，解答了长久以来困扰我的关于I/O的一些问题。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1. 为什么redis能以单工作线程处理高达几万的并发请求？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. 什么是I/O多路复用？为什么redis、nginx、nodeJS以及netty等以高性能著称的服务器其底层都利用了I/O多路复用技术？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3. 非阻塞I/O为什么会流行起来，在许多场景下取代了传统的阻塞I/O？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4. 非阻塞I/O真的是银弹吗？为什么即使在为海量用户提供服务的，追求高性能的互联网公司中依然有那么多的服务器在传统的阻塞IO模型下工作？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　5. 什么是协程？为什么Go语言这么受欢迎？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在这篇博客中，将介绍不同层面、不同I/O模型的原理，并尝试着给出我对上述问题的回答。如果你也或多或少的对上述问题感到疑惑，希望这篇博客能为你提供帮助。&lt;/p&gt;
&lt;p&gt;　　I/O模型和硬件、操作系统内核息息相关，博客中会涉及到诸如&lt;strong&gt;保护模式、中断、特权级、进程/线程、上下文切换、系统调用&lt;/strong&gt;等关于操作系统、硬件相关的概念。由于计算机中的知识是按照层次组织起来的，如果对这些相对底层的概念不是很了解的话可能会影响对整体内容的理解。可以参考一下我关于操作系统、硬件学习相关的博客：&lt;a href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/category/1623497.html%20%20&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;x86汇编学习&lt;/strong&gt;&lt;/a&gt;、&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/category/1754747.html&quot; target=&quot;_blank&quot;&gt;操作系统学习(持续更新中)&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　软件的功能总是构建在硬件上的，计算机中的I/O本质上是CPU/内存与外设(网卡、磁盘等)进行数据的单向或双向传输。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　从外设读入数据到CPU/内存称作Input输入，从CPU/内存中写出数据到外设称作Output输出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　要想理解软件层次上的不同I/O模型，必须先对其基于的硬件I/O模型有一个基本的认识。硬件I/O模型大致可以分为三种：&lt;strong&gt;程序控制I/O、中断驱动I/O、使用DMA的I/O&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;程序控制I/O：&lt;/h2&gt;
&lt;p&gt;　　程序控制I/O模型中，通过指令控制CPU不断的轮询外设是否就绪，当硬件就绪时一点一点的反复读/写数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　从CPU的角度来说，程序控制I/O模型是同步、阻塞的(同步指的是I/O操作依然是处于程序指令控制，由CPU主导的；阻塞指的是在发起I/O后CPU必须持续轮询完成状态，无法执行别的指令)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序控制I/O的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　硬件结构简单，编写对应程序也简单。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序控制I/O的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　十分消耗CPU，持续的轮训令宝贵的CPU资源无谓的浪费在了等待I/O完成的过程中，导致CPU利用率不高。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;中断驱动I/O：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;为了解决上述程序控制I/O模型对CPU资源利用率不高的问题，计算机硬件的设计者令CPU拥有了处理中断的功能。&lt;/p&gt;
&lt;p&gt;　　在中断驱动I/O模型中，CPU发起对外设的I/O请求后，就直接去执行别的指令了。当硬件处理完I/O请求后，通过中断异步的通知CPU。接到读取完成中断通知后，CPU负责将数据从外设缓冲区中写入内存；接到写出完成中断通知后，CPU需要将内存中后续的数据接着写出交给外设处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　从CPU的角度来说，中断驱动I/O模型是同步、非阻塞的(同步指的是I/O操作依然是处于程序指令控制，由CPU主导的；非阻塞指的是在发起I/O后CPU不会停下等待，而是可以执行别的指令)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中断驱动I/O的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　由于I/O总是相对耗时的，比起通过程序控制I/O模型下CPU不停的轮训。在等待硬件I/O完成的过程中CPU可以解放出来执行另外的命令，大大提高了I/O密集程序的CPU利用率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;中断驱动I/O的缺点：&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　受制于硬件缓冲区的大小，一次硬件I/O可以处理的数据是相对有限的。在处理一次大数据的I/O请求中，CPU需要被反复的中断，而处理读写中断事件本身也是有一定开销的。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;使用DMA的I/O：&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;为了解决中断驱动I/O模型中，大数据量的I/O传输使得CPU需要反复处理中断的缺陷，计算机硬件的设计者提出了基于DMA模式的I/O(&lt;strong&gt;DMA Direct Memory Access 直接存储器访问&lt;/strong&gt;)。DMA也是一种处理器芯片，和CPU一样也可以访问内存和外设，但DMA芯片是被设计来专门处理I/O数据传输的，因此其成本相对CPU较低。&lt;/p&gt;
&lt;p&gt;　　在使用DMA的I/O模型中，CPU与DMA芯片交互，指定需要读/写的数据块大小和需要进行I/O数据的目的内存地址后，便异步的处理别的指令了。由DMA与外设硬件进行交互，一次大数据量的I/O需要DMA反复的与外设进行交互，当DMA完成了整体数据块的I/O后(&lt;strong&gt;完整的将数据读入到内存或是完整的将某一内存块的数据写出到外设&lt;/strong&gt;)，再发起DMA中断通知CPU。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　从CPU的角度来说，使用DMA的I/O模型是异步、非阻塞的(异步指的是整个I/O操作并不是由CPU主导，而是由DMA芯片与外设交互完成的；非阻塞指的是在发起I/O后CPU不会停下等待，而是可以执行别的指令)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用DMA的I/O优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　比起外设硬件中断通知，对于一次完整的大数据内存与外设间的I/O，CPU只需要处理一次中断。CPU的利用效率相对来说是最高的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;使用DMA的I/O&lt;/strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. 引入DMA芯片令硬件结构变复杂，成本较高。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. 由于DMA芯片的引入，使得DMA和CPU并发的对内存进行操作，在拥有高速缓存的CPU中，&lt;a href=&quot;https://www.cnblogs.com/xiaoxiongcanguan/p/13184801.html&quot; target=&quot;_blank&quot;&gt;引入了高速缓存与内存不一致的问题&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　总的来说，自DMA技术被发明以来，由于其极大减少了CPU在I/O时的性能损耗，已经成为了绝大多数通用计算机的硬件标配。随着技术的发展又出现了更先进的&lt;strong&gt;通道I/O方式&lt;/strong&gt;，相当于并发的DMA，允许并发的处理涉及多个不同内存区域、外设硬件的I/O操作。&lt;/p&gt;

&lt;p&gt;　　介绍完硬件的I/O模型后，下面介绍这篇博客的重点：操作系统I/O模型。&lt;/p&gt;
&lt;p&gt;　　操作系统帮我们屏蔽了诸多硬件外设的差异，为应用程序的开发者提供了友好、统一的服务。为了避免应用程序破坏操作系统内核，CPU提供了保护模式机制，使得应用程序无法直接访问被操作系统管理起来的外设，而必须通过内核提供的&lt;strong&gt;系统调用&lt;/strong&gt;间接的访问外设。关于操作系统I/O模型的讨论针对的就是应用程序与内核之间进行I/O交互的系统调用模型。&lt;/p&gt;
&lt;p&gt;'　　&lt;strong&gt;操作系统内核提供的I/O模型大致可以分为几种：同步阻塞I/O、同步非阻塞I/O、同步I/O多路复用、异步非阻塞I/O（信号驱动I/O用的比较少，就不在这里展开了）。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;同步阻塞I/O(Blocking I/O BIO)&lt;/h2&gt;
&lt;p&gt;　　我们已经知道，高效的硬件层面I/O模型对于CPU来说是异步的，但应用程序开发者总是希望在执行完I/O系统调用后能同步的返回，线性的执行后续逻辑(例如当磁盘读取的系统调用返回后，下一行代码中就能直接访问到所读出的数据)。但这与硬件层面耗时、异步的I/O模型相违背(程序控制I/O过于浪费CPU)，因此操作系统内核提供了基于同步、阻塞I/O的系统调用(BIO)来解决这一问题。&lt;/p&gt;
&lt;p&gt;　　举个例子：当线程通过基于BIO的系统调用进行磁盘读取时，内核会令当前线程进入阻塞态，让出CPU资源给其它并发的就绪态线程，以便更有效率的利用CPU。当DMA完成读取，异步的I/O中断到来时，内核会找到先前被阻塞的对应线程，将其唤醒进入就绪态。当这个就绪态的线程被内核CPU调度器选中再度获得CPU时，便能从对应的缓冲区结构中得到读取到的磁盘数据，程序同步的执行流便能顺利的向下执行了。(感觉好像线程卡在了那里不动，过了一会才执行下一行，且指定的缓冲区中已经有了所需的数据)&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;下面的伪代码示例中参考linux的设计，将不同的外设统一抽象为文件，通过文件描述符(file descriptor)来统一的访问。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BIO伪代码实例 :&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建TCP套接字并绑定端口8888，进行服务监听&lt;/span&gt;
listenfd = serverSocket(8888,&quot;tcp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; accept同步阻塞调用&lt;/span&gt;
    newfd =&lt;span&gt; accept(listenfd);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; read会阻塞，因此使用线程异步处理，避免阻塞accpet(一般使用线程池)&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt; thread(()-&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同步阻塞读取数据&lt;/span&gt;
        xxx =&lt;span&gt; read(newfd);
        ... dosomething
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭连接&lt;/span&gt;
&lt;span&gt;        close(newfd);
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;BIO模型的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　BIO的I/O模型由于同步、阻塞的特性，屏蔽了底层实质上异步的硬件交互方式，令程序员可以编写出简单易懂的线性程序逻辑。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BIO模型的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. BIO的同步、阻塞特性在简单易用的同时，也存在一些性能上的缺陷。由于BIO在等待I/O完成的时间中，线程虽然被阻塞不消耗CPU，但内核维护一个系统级线程本身也是有一定的开销(维护线程控制块、内核线程栈空间等等)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. 不同线程在调度时的上下文切换CPU开销较大，在如今大量用户、高并发的互联网时代越来越成为web服务器性能的瓶颈。线程上下文切换本身需要需要保存、恢复现场，同时还会清空CPU指令流水线，以及令高速缓存大量失效。&lt;/strong&gt;&lt;strong&gt;对于一个web服务器，如果使用BIO模型，服务器将至少需要1:1的维护同等数量的系统级线程(内核线程)，由于持续并发的网络数据交互，导致不同线程由于网络I/O的完成事件被内核反复的调度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　在著名的C10K问题的语境下，一台服务器需要同时维护1W个并发的tcp连接和对等的1W个系统级线程。量变引起质变，1W个系统级线程调度引起的上下文切换和100个系统级线程的调度开销完全不同，其将耗尽CPU资源，令整个系统卡死，崩溃。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BIO交互流程示意图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1506329/202011/1506329-20201110232740754-665496122.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;同步非阻塞I/O(NonBlocking I/O NIO)&lt;/h2&gt;
&lt;p&gt;　　BIO模型简单易用，但其阻塞内核线程的特性使得其已经不适用于需要处理大量(1K以上)并发网络连接场景的web服务器了。为此，操作系统内核提供了非阻塞特性的I/O系统调用，即&lt;strong&gt;NIO(NonBlocking-IO)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　针对BIO模型的缺陷，NIO模型的系统调用不会阻塞当前调用线程。但由于I/O本质上的耗时特性，无法立即得到I/O处理的结果，NIO的系统调用在I/O未完成时会返回特定标识，代表对应的I/O事件还未完成。因此需要应用程序按照一定的频率反复调用，以获取最新的IO状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NIO伪代码实例 :&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建TCP套接字并绑定端口8888，进行服务监听&lt;/span&gt;
listenfd = serverSocket(8888,&quot;tcp&quot;&lt;span&gt;);
clientFdSet &lt;/span&gt;=&lt;span&gt; empty_set();
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启事件监听循环
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; accept同步非阻塞调用,判断是否接收了新的连接&lt;/span&gt;
    newfd =&lt;span&gt; acceptNonBlock(listenfd);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(newfd !=&lt;span&gt; EMPTY){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果存在新连接将其加入监听连接集合&lt;/span&gt;
&lt;span&gt;        clientFdSet.add(newfd);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 申请一个1024字节的缓冲区&lt;/span&gt;
    buffer = &lt;span&gt;new&lt;/span&gt; buffer(1024&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(clientfd in clientFdSet){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 非阻塞read读&lt;/span&gt;
        num =&lt;span&gt; readNonBlock(clientfd,buffer);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(num &amp;gt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读缓冲区存在数据&lt;/span&gt;
            data =&lt;span&gt; buffer;
            ... dosomething
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(needClose(data)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭连接时，移除当前监听的连接&lt;/span&gt;
&lt;span&gt;                clientFdSet.remove(clientfd)；
            }
        }
        ... dosomething
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清空buffer&lt;/span&gt;
&lt;span&gt;        buffer.clear();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;NIO模型的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　NIO因为其非阻塞的特性，使得一个线程可以处理多个并发的网络I/O连接。在C10K问题的语境下，理论上可以通过一个线程处理这1W个并发连接(对于多核CPU，可以创建多个线程在每个CPU核心中分摊负载，提高性能)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NIO模型的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　NIO克服了BIO在高并发条件下的缺陷，但原始的NIO系统调用依然有着一定的性能问题。在上述伪代码示例中，每个文件描述符对应的I/O状态查询，都必须通过一次NIO系统调用才能完成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　由于操作系统内核利用CPU提供的保护模式机制，使内核运行在高特权级，而令用户程序运行在执行、访问受限的低特权级。这样设计的一个好处就是使得应用程序无法直接的访问硬件，而必须由操作系统提供的系统调用间接的访问硬件(网卡、磁盘甚至电源等)。执行系统调用时，需要令应用线程通过系统调用陷入内核(即提高应用程序的当前特权级CPL，使其能够访问受保护的硬件)，并在系统调用返回时恢复为低特权级，这样一个过程在硬件上是通过中断实现的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　通过中断实现系统调用的效率远低于应用程序本地的函数调用，因此原始的NIO模式下通过系统调用循环访问每个文件描述符I/O就绪状态的方式是低效的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NIO交互流程示意图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1506329/202011/1506329-20201110232810677-517961077.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;同步I/O多路复用(I/O Multiplexing)&lt;/h2&gt;
&lt;p&gt;　　为了解决上述NIO模型的系统调用中，一次事件循环遍历进行N次系统调用的缺陷。操作系统内核在NIO系统调用的基础上提供了I/O多路复用模型的系统调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　I/O多路复用相对于NIO模型的一个优化便是允许在一次I/O状态查询的系统调用中，一次传递复数个文件描述符进行批量的I/O状态查询。在一次事件循环中只需要进行一次I/O多路复用的系统调用就能得到所传递文件描述符集合的I/O状态，减少了原始NIO模型中不必要的系统调用开销。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　多路复用I/O模型大致可以分为三种实现(虽然不同操作系统在最终实现上略有不同，但原理是类似的，&lt;/strong&gt;&lt;strong&gt;示例代码以linux内核举例&lt;/strong&gt;)：select、poll、epoll。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;select多路复用器介绍&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　select I/O多路复用器允许应用程序传递需要监听事件变化的文件描述符集合，监听其读/写，接受连接等I/O事件的状态。&lt;/p&gt;
&lt;p&gt;　　select系统调用本身是&lt;strong&gt;同步、阻塞&lt;/strong&gt;的，当所传递的文件描述符集合中都没有就绪的I/O事件时，执行select系统调用的线程将会进入阻塞态，直到至少一个文件描述符对应的I/O事件就绪，则唤醒被select阻塞的线程(&lt;strong&gt;可以指定超时时间来强制唤醒并返回&lt;/strong&gt;)。唤醒后获得CPU的线程在select系统调用返回后可以遍历所传入的文件描述符集合，处理完成了I/O事件的文件描述符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;select伪代码示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建TCP套接字并绑定端口8888，进行服务监听&lt;/span&gt;
listenfd = serverSocket(8888,&quot;tcp&quot;&lt;span&gt;);
fdNum &lt;/span&gt;= 1&lt;span&gt;;
clientFdSet &lt;/span&gt;=&lt;span&gt; empty_set();
clientFdSet.add(listenfd);
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启事件监听循环
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; man 2 select(查看linux系统文档)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数nfds：一共需要监听的readfds、writefds、exceptfds中文件描述符个数+1
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数readfds/writefds/exceptfds： 需要监听读、写、异常事件的文件描述符集合
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数timeout：select是同步阻塞的，当timeout时间内都没有任何I/O事件就绪，则调用线程被唤醒并返回(ret=0)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         timeout为null代表永久阻塞
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回值ret：
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  1.返回大于0的整数，代表传入的readfds/writefds/exceptfds中共有ret个被激活(需要应用程序自己遍历)，
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    2.返回0，在阻塞超时前没有任何I/O事件就绪
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    3.返回-1，出现错误&lt;/span&gt;
&lt;span&gt;
    listenReadFd &lt;/span&gt;=&lt;span&gt; clientFdSet;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; select多路复用，一次传入需要监听事件的全量连接集合（超时时间1s）&lt;/span&gt;
    result = select(fdNum+1,listenReadFd,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;,timeval(&quot;1s&quot;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(result &amp;gt; 0&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果服务器监听连接存在读事件&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(IN_SET(listenfd,listenReadFd)){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收并建立连接&lt;/span&gt;
            newClientFd =&lt;span&gt; accept(listenfd);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入客户端连接集合&lt;/span&gt;
&lt;span&gt;            clientFdSet.add(newClientFd);&lt;br/&gt;　　　　　　　fdNum++;
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历整个需要监听的客户端连接集合&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(clientFd : clientFdSet){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前客户端连接存在读事件&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(IN_SET(clientFd,listenReadFd)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阻塞读取数据&lt;/span&gt;
                data =&lt;span&gt; read(clientfd);
                ... dosomething
                
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(needClose(data)){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭连接时，移除当前监听的连接&lt;/span&gt;
&lt;span&gt;                    clientFdSet.remove(clientfd)；&lt;br/&gt;　　　　　　　　　　　　fdNum--;
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;select的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. select多路复用避免了上述原始NIO模型中无谓的多次查询I/O状态的系统调用，将其聚合成集合，批量的进行监听并返回结果集。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. select实现相对简单，windows、linux等主流的操作系统都实现了select系统调用，跨平台的兼容性好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;select的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. 在事件循环中，每次select系统调用都需要从用户态全量的传递所需要监听的文件描述符集合，并且select返回后还需要全量遍历之前传入的文件描述符集合的状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. 出于性能的考量，内核设置了select所监听文件描述符集合元素的最大数量(一般为1024，可在内核启动时指定)，使得单次select所能监听的连接数受到了限制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3. 抛开性能的考虑，从接口设计的角度来看，select将系统调用的参数与返回值混合到了一起(返回值覆盖了参数)，增加了使用者理解的困难度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O多路复用交互示意图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1506329/202011/1506329-20201110232828269-1432108046.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;strong&gt;poll&lt;/strong&gt;&lt;strong&gt;多路复用器介绍&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　poll I/O多路复用器在使用上和select大同小异，也是通过传入指定的文件描述符集合以及指定内核监听对应文件描述符上的I/O事件集合，但在实现的细节上基于select做了一定的优化。&lt;/p&gt;
&lt;p&gt;　　和select一样，poll系统调用在没有任何就绪事件发生时也是&lt;strong&gt;同步、阻塞&lt;/strong&gt;的(&lt;strong&gt;可以指定超时时间强制唤醒并返回&lt;/strong&gt;)，当返回后要判断是否有就绪事件时，也一样需要全量的遍历整个返回的文件描述符集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;poll伪代码示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
// man 2 poll(查看linux系统文档)
// 和select不同将参数events和返回值revents分开了
struct pollfd {
               int   fd;         // file descriptor 对应的文件描述符 
               short events;     // requested events 需要监听的事件
               short revents;    // returned events 返回时，就绪的事件
           };

// 参数fds,要监听的poolfd数组集合
// 参数nfds，传入fds数组中需要监听的元素个数
// 参数timeout，阻塞的超时时间(传入-1代表永久阻塞)
int poll(struct pollfd *fds, nfds_t nfds, int timeout);

//events/revents是位图表示的
//revents &amp;amp; POLLIN == 1 存在就绪的读事件
//revents &amp;amp; POLLOUT == 1 存在就绪的写事件
//revents &amp;amp; POLLHUP == 1 存在对端断开连接或是通信完成事件
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建TCP套接字并绑定端口8888，进行服务监听&lt;/span&gt;
listenfd = serverSocket(&lt;span&gt;8888&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

MAX_LISTEN_SIZE &lt;/span&gt;= &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; pollfd fds[MAX_LISTEN_SIZE];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置服务器监听套接字(监听读事件)&lt;/span&gt;
fds[&lt;span&gt;0&lt;/span&gt;].fd =&lt;span&gt; listenfd;
fds[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].events =&lt;span&gt; POLLIN;
fds[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].revents = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 客户端连接数一开始为0&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; clientCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; poll同步阻塞调用(超时时间-1表示永久阻塞直到存在监听的就绪事件)&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; ret = poll(fds, clientCount + &lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; clientCount + &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(fds[i].fd == listenfd &amp;amp;&amp;amp; fds[i].revents &amp;amp;&lt;span&gt; POLLIN){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 服务器监听套接字读事件就绪，建立新连接&lt;/span&gt;
            clientCount++&lt;span&gt;；
            fds[clientCount].fd &lt;/span&gt;=&lt;span&gt; conn;
            fds[clientCount].events &lt;/span&gt;= POLLIN |&lt;span&gt; POLLRDHUP ;
            fds[clientCount].revents &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(fds[i].revents &amp;amp;&lt;span&gt; POLLIN){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其他链接可读,进行读取&lt;/span&gt;
&lt;span&gt;            read(fds[i].fd);
            ... doSomething
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(fds[i].revents &amp;amp;&lt;span&gt; POLLRDHUP){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听到客户端连接断开，移除该连接&lt;/span&gt;
            fds[i] =&lt;span&gt; fds[clientCount];
&lt;/span&gt;            i--&lt;span&gt;;
            clientCount&lt;/span&gt;--&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭该连接&lt;/span&gt;
&lt;span&gt;            close(fd);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;poll的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. poll解决了select系统调用受限于内核配置参数的限制问题，可以同时监听更多文件描述符的I/O状态(但不能超过内核限制当前进程所能拥有的最大文件描述符数目限制)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. 优化了接口设计，将参数与返回值的进行了分离。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;poll的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. poll优化了select，但在处理大量闲置连接时，即使真正产生I/O就绪事件的活跃文件描述符数量很少，依然免不了线性的遍历整个监听的文件描述符集合。每次调用时，需要全量的将整个感兴趣的文件描述符集合从用户态复制到内核态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. 由于select/poll都需要全量的传递参数以及遍历返回值，因此其时间复杂度为O(n)，即处理的开销随着并发连接数n的增加而增加，而无论并发连接本身活跃与否。但一般情况下即使并发连接数很多，大量连接都产生I/O就绪事件的情况并不多，更多的情况是1W的并发连接，可能只有几百个是处于活跃状态的，这种情况下select/poll的性能并不理想，还存在优化的空间。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;epoll多路复用器：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　epoll是linux系统中独有的，针对select/poll上述缺点进行改进的高性能I/O多路复用器。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;针对poll系统调用介绍中的第一个缺点：在每次事件循环时都需要从用户态全量传递整个需要监听的文件描述符集合&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　epoll在内核中分配内存空间用于缓存被监听的文件描述符集合。通过创建epoll的系统调用（epoll_create），在内核中维护了一个epoll结构，而在应用程序中只需要保留epoll结构的句柄就可对其进行访问(也是一个文件描述符)。可以动态的在epoll结构的内核空间中增加/删除/更新所要监听的文件描述符以及不同的监听事件（epoll_ctl），而不必每次都全量的传递需要监听的文件描述符集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　针对select/poll的第二个缺点：在系统调用返回后通过修改所监听文件描述符结构的状态，来标识文件描述符对应的I/O事件是否就绪。每次系统调用返回时，都需要全量的遍历整个监听文件描述符集合，而无论是否真的完成了I/O。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;epoll监听事件的系统调用完成后，只会将真正活跃的、完成了I/O事件的文件描述符返回，避免了全量的遍历。在并发的连接数很大，但闲置连接占比很高时，epoll的性能大大优于select/poll这两种I/O多路复用器。&lt;strong&gt;epoll的时间复杂度为O(m)，即处理的开销不随着并发连接n的增加而增加，而是仅仅和监控的活跃连接m相关；在某些情况下n远大于m，epoll的时间复杂度甚至可以认为近似的达到了O(1)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;通过epoll_wait系统调用，监听参数中传入对应epoll结构中关联的所有文件描述符的对应I/O状态。epoll_wait本身是同步、阻塞的(可以指定超时时间强制唤醒并返回)，当epoll_wait同步返回时，会返回处于活跃状态的完成I/O事件的文件描述符集合，避免了select/poll中的无效遍历。同时epoll使用了mmap机制，将内核中的维护的就绪文件描述符集合所在空间映射到了用户态，令应用程序与epoll的内核共享这一区域的内存，避免了epoll返回就绪文件描述符集合时的一次内存复制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;epoll伪代码示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
    epoll比较复杂，使用时大致依赖三个系统调用 (man 7 epoll)
    1. epoll_create 创建一个epoll结构,返回对应epoll的文件描述符 (man 2 epoll_create)
        int epoll_create();
    2. epoll_ctl 控制某一epoll结构(epfd)，向其增加/删除/更新(op)某一其它连接(fd)，监控其I/O事件(event) (man 2 epoll_ctl)
        op有三种合法值：EPOLL_CTL_ADD代表新增、EPOLL_CTL_MOD代表更新、EPOLL_CTL_DEL代表删除
        int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
    3. epoll_wait 令某一epoll同步阻塞的开始监听(epfd)，感兴趣的I/O事件(events),所监听fd的最大个数(maxevents)，指定阻塞超时时间(timeout) (man 2 epoll_wait)
        int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建TCP套接字并绑定端口8888，进行服务监听&lt;/span&gt;
listenfd = serverSocket(&lt;span&gt;8888&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个epoll结构&lt;/span&gt;
epollfd =&lt;span&gt; epoll_create();

ev &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; epoll_event();
ev.events &lt;/span&gt;= EPOLLIN; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读事件&lt;/span&gt;
ev.data.fd =&lt;span&gt; listenfd;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过epoll监听服务器端口读事件(新连接建立请求)&lt;/span&gt;
&lt;span&gt;epoll_ctl(epollfd,EPOLL_CTL_ADD,listenfd,ev)；

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最大监听1000个连接&lt;/span&gt;
MAX_EVENTS = &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
listenEvents &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt;[MAX_EVENTS];
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同步阻塞监听事件
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最多返回MAX_EVENTS个事件响应结果
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (超时时间1000ms，标识在超时时间内没有任何事件就绪则当前线程被唤醒，返回值nfd将为0)&lt;/span&gt;
    nfds = epoll_wait(epollfd, listenEvents, MAX_EVENTS, &lt;span&gt;1&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
        
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(n = &lt;span&gt;0&lt;/span&gt;; n &amp;lt; nfds; ++&lt;span&gt;n){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(events[n].data.fd ==&lt;span&gt; listenfd){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当发现服务器监听套接字存在可读事件，建立新的套接字连接&lt;/span&gt;
            clientfd =&lt;span&gt; accept(listenfd);

            ev.events &lt;/span&gt;= EPOLLIN |&lt;span&gt; EPOLLET;
            ev.data.fd &lt;/span&gt;=&lt;span&gt; clientfd;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建立的套接字连接也加入当前epoll的监听(监听读(EPOLLIN)/写(EPOLLET)事件)&lt;/span&gt;
&lt;span&gt;            epoll_ctl(epollfd,EPOLL_CTL_ADD,clientfd,ev);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则是其它连接的I/O事件就绪,进行对应的操作&lt;/span&gt;
&lt;span&gt;            ... do_something
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;epoll的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　epoll是目前性能最好的I/O多路复用器之一，具有I/O多路复用优点的情况下很好的解决了select/poll的缺陷。目前linux平台中，像nginx、redis、netty等高性能服务器都是首选epoll作为基础来实现网络I/O功能的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;epoll的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1. 常规情况下闲置连接占比很大，epoll的性能表现的很好。但是也有少部分场景中，绝大多数连接都是活跃的，那么其性能与select/poll这种基于位图、数组等简单结构的I/O多路复用器相比，就不那么有优势了。因为select/poll被诟病的一点就是通常情况下进行了无谓的全量检查，而当活跃连接数占比一直超过90%甚至更高时，就不再是浪费了;相反的，由于epoll内部结构比较复杂，在这种情况下其性能比select/poll还要低一点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. epoll是linux操作系统下独有的，使得基于epoll实现的应用程序的跨平台兼容性受到了一定影响。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;异步非阻塞I/O(Asynchronous I/O AIO)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;windows和linux都支持了select系统调用，但linux内核在之后又实现了epoll这一更高性能的I/O多路复用器来改进select。&lt;/p&gt;
&lt;p&gt;　　windows没有模仿linux，而是提供了被称为&lt;strong&gt;IOCP&lt;/strong&gt;(&lt;strong&gt;Input/Output Completion Port 输入输出完成端口&lt;/strong&gt;)的功能解决select性能的问题。IOCP采用异步非阻塞IO(AIO)的模型，其与epoll同步非阻塞IO的最大区别在于，epoll调用完成后，仅仅返回了就绪的文件描述符集合；而IOCP则在内核中自动的完成了epoll中原本应该由应用程序主动发起的I/O操作。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;举个例子，当监听到就绪事件开始读取某一网络连接的请求报文时，epoll依然需要通过程序主动的发起读取请求，将数据从内核中读入用户空间。而windows下的IOCP则是通过注册回调事件的方式工作，由内核自动的将数据放入指定的用户空间，当处理完毕后会调度激活注册的回调事件，被唤醒的线程能直接访问到所需要的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;这也是为什么BIO/NIO/IO多路复用被称为同步I/O，而IOCP被称为异步I/O的原因。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　同步I/O与异步I/O的主要区别就在于站在应用程序的视角看，真正读取/写入数据时是否是由应用程序主导的。如果需要用户程序主动发起最终的I/O请求就被称为同步I/O；而如果是内核自动完成I/O后通知用户程序，则被称为异步I/O。(可以类比在前面硬件I/O模型中，站在CPU视角的同步、异步I/O模型，只不过这里CPU变成了应用程序，而外设/DMA变成了操作系统内核)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AIO的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　AIO作为异步I/O，由内核自动的完成了底层一整套的I/O操作，应用程序在事件回调通知中能直接获取到所需数据。&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;内核中可以实现非常高效的调度、通知框架。&lt;/strong&gt;拥有前面NIO高性能的优点，又简化了应用程序的开发。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AIO的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　由内核全盘控制的全自动I/O虽然能够做到足够高效，但是在一些特定场景下性能并不一定能超过由应用程序主导的，经过深度优化的代码。像epoll在支持了和select/poll一样的水平触发I/O的同时，还支持了更加细致的边缘触发I/O，允许用户自主的决定当I/O就绪时，是否需要立即处理或是缓存起来等待稍后再处理。(就像java等支持自动内存垃圾回收的语言，即使其垃圾收集器经过持续的优化，在大多数情况下性能都很不错，但却依然无法达到和经过开发人员反复调优，手动回收内存的C、C++等语言实现的程序一样的性能)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1506329/202011/1506329-20201110213036357-434240070.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;（截图自《Unix网络编程 卷1》）&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;操作系统I/O模型小结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　1. 同步I/O包括了同步阻塞I/O和同步非阻塞I/O，而异步I/O中由于异步阻塞I/O模型没有太大价值，因此提到异步I/O(AIO)时，默认指的就是异步非阻塞I/O。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1506329/202011/1506329-20201110213141475-2103756105.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2. 在I/O多路复用器的工作中，当监听到对应文件描述符I/O事件就绪时，后续进行的读/写操作既可以是阻塞的，也可以是非阻塞的。如果是都以阻塞的方式进行读/写，虽然实现简单，但如果某一文件描述符需要读写的数据量很大时将耗时较多，可能会导致事件循环中的其它事件得不到及时处理。因此截图中的阻塞读写数据部分并不准确，需要辩证的看待。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;计算机技术的发展看似日新月异，但本质上有两类目标指引着其前进。一是尽可能的增强、压榨硬件的性能，提高机器效率；二是尽可能的通过持续的抽象、封装简化软件复杂度，提高程序员的开发效率。计算机软件的发展方向必须至少需要满足其中一种目标。&lt;/p&gt;
&lt;p&gt;　　从上面关于操作系统内核I/O模型的发展中可以看到，最初被广泛使用的是易理解、开发简单的BIO模型；但由于互联网时代的到来，web服务器系统面临着C10K问题，需要能支持海量的并发客户端连接，因此出现了包括NIO、I/O多路复用、AIO等技术，利用一个内核线程管理成百上千的并发连接，来解决BIO模型中一个内核线程对应一个网络连接的工作模式中，由于处理大量连接导致内核线程上下文频繁切换，造成CPU资源耗尽的问题。上述的第一条原则指引着内核I/O模型的发展，使得web服务器能够获得更大的连接服务吞吐量，提高了机器效率。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;但非阻塞I/O真的是完美无缺的吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;有着非阻塞I/O模型开发经验的程序员都知道，正是由于一个内核线程管理着成百上千个客户端连接，因此在整个线程的执行流中不能出现耗时、阻塞的操作(比如同步阻塞的数据库查询、rpc接口调用等)。如果这种操作不可避免，则需要单独使用另外的线程异步的处理，而不能阻塞当前的整个事件循环，否则将会导致其它连接的请求得不到及时的处理，造成饥饿。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　对于多数互联网分布式架构下处理业务逻辑的应用程序服务器来说，在一个网络请求服务中，可能需要频繁的访问数据库或者通过网络远程调用其它服务的接口。如果使用的是基于NIO模型进行工作的话，则要求rpc库以及数据库、中间件等连接的库是支持异步非阻塞的。如果由于同步阻塞库的存在，在每次接受连接进行服务时依然被迫通过另外的线程处理以避免阻塞，则NIO服务器的性能将退化到和使用传统的BIO模型一样的地步。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　所幸的是随着非阻塞I/O的逐渐流行，上述问题得到了很大的改善。&lt;/p&gt;
&lt;h2&gt;非阻塞I/O带来的新问题&lt;/h2&gt;
&lt;p&gt;　　异步非阻塞库改变了同步阻塞库下程序员习以为常的，线性的思维方式，在编码时被迫的以事件驱动的方式思考。逻辑上连贯的业务代码为了适应异步非阻塞的库程序，被迫分隔成多个独立片段嵌套在各个不同层次的回调函数中。对于复杂的业务而言，很容易出现嵌套为一层层的回调函数，形成臭名昭著的&lt;strong&gt;callback hell(回调地狱)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　最早被callback hell折磨的可能是客户端程序的开发人员，因为客户端程序需要时刻监听着用户操作事件的产生，通常以基于事件驱动的方式组织异步处理代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;callback hell伪代码示例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于互相之间有前后的数据依赖，按照顺序异步的调用A、B、C、D&lt;/span&gt;
A.dosomething((res)-&amp;gt;&lt;span&gt;{
    data &lt;/span&gt;=&lt;span&gt; res.xxx;
    B.dosomething(data,(res)&lt;/span&gt;-&amp;gt;&lt;span&gt;{
        data &lt;/span&gt;=&lt;span&gt; res.xxx;
        C.dosomething(data,(res)&lt;/span&gt;-&amp;gt;&lt;span&gt;{
            data &lt;/span&gt;=&lt;span&gt; res.xxx
            D.dosomething(data,(res)&lt;/span&gt;-&amp;gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 。。。 有依赖的同步业务越复杂，层次越深，就像一个无底洞&lt;/span&gt;
&lt;span&gt;            })
        })
    })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　异步非阻塞库的使用割裂了代码的连贯结构，使得程序变得难以理解、调试，这一缺陷在堆积着复杂晦涩业务逻辑的web应用程序服务器程序中显得难以忍受。这也是为什么如今web服务器仍然有很大一部分依然使用传统的同步阻塞的BIO模型进行开发的主要原因。通过分布式、集群的方式分摊大量并发的连接，而只在业务相对简单的API网关、消息队列等I/O密集型的中间件程序中NIO才被广泛使用(实在不行，业务服务器集群可以加机器，保证开发效率也同样重要)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　那么就没有什么办法既能够拥有非阻塞I/O支撑海量并发、高吞吐量的性能优势；又能够令程序员以同步方式思考、编写程序，以提高开发效率吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;解决办法当然是存在的，且相关技术依然在不断发展。上述计算机技术发展的第二个原则指导着这些技术发展，目的是为了简化代码复杂性，提高程序员的效率。&lt;/p&gt;
&lt;h3&gt;1. 优化语法、语言库以简化异步编程的难度&lt;/h3&gt;
&lt;p&gt;　　在函数式编程的领域，就一直有着诸多晦涩的“黑科技”(CPS变换、monad等)，能够简化callback hell，使得可以以几乎是同步的方式编写实质上是异步执行的代码。例如EcmaScript便在EcmaScript6、EcmaScript7中分别引入了promise和async/await来解决这一问题。&lt;/p&gt;
&lt;h3&gt;2. 在语言级别支持用户级线程(协程)&lt;/h3&gt;
&lt;p&gt;　　前面提到，传统的基于BIO模型的工作模式最大的优点在于可以同步的编写代码，遇到需要等待的耗时操作时能够被同步阻塞，使用起来简单易懂。但由于1：1的维护内核线程在处理海量连接时由于频繁的内核线程上下文切换而力不从心，催生了非阻塞I/O。&lt;/p&gt;
&lt;p&gt;　　而由于上述非阻塞I/O引起的代码复杂度的增加，计算机科学家们想到了很早之前就在操作系统概念中提出，但一直没有被广泛使用的另一种线程实现方式：用户级线程。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;用户级线程顾名思义，就是在用户级实现的线程，操作系统内核对其是无感知的。用户级线程在许多方面与大家所熟知的内核级线程相似，都有着自己独立的执行流，和进程中的其它线程共享内存空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　用户级线程与内核级线程最大的一个区别就在于由于操作系统对其无感知，因此无法对用户级线程进行基于中断的抢占式调度。要使得同一进程下的不同用户级线程能够协调工作，必须小心的编写执行逻辑，以互相之间主动让渡CPU的形式工作，否则将会导致一个用户级线程持续不断的占用CPU，而令其它用户级线程处于饥饿状态，因此用户级线程也被称为协程，即互相协作的线程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　用户级线程无论如何是基于至少一个内核线程/进程的，多个用户级线程可以挂载在一个内核线程/进程中被内核统一的调度管理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1506329/202011/1506329-20201109222607625-949196283.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;（截图自《现代操作系统》）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;协程可以在遇到I/O等耗时操作时选择主动的让出CPU，以实现同步阻塞的效果，令程序执行流转移到另一个协程中。由于多个协程可以复用一个内核线程，每个协程所占用的开销相对内核级线程来说非常小；且协程上下文切换时由于不需要陷入内核，其切换效率也远比内核线程的上下文切换高(开销近似于一个函数调用)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　最近很流行的Go语言就是由于其支持语言层面的协程而备受推崇。程序员可以利用一些语言层面提供的协程机制编写高效的web服务器程序(例如在语句中添加控制协程同步的关键字)。通过在编译后的最终代码中加入对应的协程调度指令，由协程调度器接手，控制协程同步时在耗时I/O操作发生时主动的让出CPU，并在处理完毕后能被调度回来接着执行。Go语言通过语言层面上对协程的支持，降低了编写正确、协调工作的协程代码的难度。&lt;/p&gt;
&lt;p&gt;　　Go编写的高性能web服务器如果运行在多核CPU的linux操作系统中，一般会创建m个内核线程和n个协程(m正比与CPU核心数，n远大于m且正比于并发连接数)，底层每个内核线程依然可以利用epoll IO多路复用器处理并发的网络连接，并将业务逻辑处理的任务转交给用户态的协程(gorountine)。每个协程可以在不同的内核线程(CPU核心)中被来回调度，以获得最大的CPU吞吐量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　使用协程，程序员在开发时能够编写同步阻塞的耗时I/O代码，又不用担心高并发情况下BIO模型中的性能问题。可以说协程兼顾了程序开发效率与机器执行效率，因此越来越多的语言也在语言层面或是在库函数中提供协程机制。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;3. 实现用户透明的协程&lt;/h3&gt;
&lt;p&gt;　　在通过虚拟机作为中间媒介，操作系统平台无关的语言中(比如java)，虚拟机作为应用程序与操作系统内核的中间层，可以对应用程序进行各方面的优化，令程序员可以轻松编写出高效的代码。&lt;/p&gt;
&lt;p&gt;　　有大牛在知乎的一篇回答中提到过，其曾经领导团队在阿里巴巴工作时在java中实现了透明的协程。但似乎没有和官方标准达成统一因此并没有对外开放。&lt;/p&gt;
&lt;p&gt;　　如果能够在虚拟机中提供高效、用户透明的协程机制，使得原本基于BIO多线程的服务器程序无需改造便自动的获得了支持海量并发的能力，那真是太强了Orz。&lt;/p&gt;

&lt;p&gt;　　通过对ucore操作系统源码级的研究学习，加深了我对操作系统原理书中各种抽象概念的理解，也渐渐理解了一些关于各种I/O模型的问题。&lt;/p&gt;
&lt;p&gt;　　一方面，通过对操作系统I/O模型的总结，使得我对于上层应用程序如java中的nio和netty中的非阻塞的编程风格有了更深的理解，不再像之前只习惯于BIO编程那样感到奇怪，而是觉得非常自然。另一方面，又意识到了自己还有太多的不足。&lt;/p&gt;
&lt;p&gt;　　站在操作系统I/O模型这一层面，向上看，依然对基于nio的各种中间件不太熟悉，不了解在具体实践中如何利用好NIO这一利器，写出鲁棒、高效的代码；向下看，由于ucore为了尽可能的简化实验课的难度，省略了很多的功能没有实现，导致我对于操作系统底层是如何实现网络协议栈、如何实现nio和io多路复用器的原理知之甚少，暂时只能将其当作黑盒子看待，很多地方可能理解的有偏差。令我在拓宽知识面的同时，感叹知道的越多就越感觉自己无知，但人总是要向前走的，在学习中希望尽量能做到知其然而知其所以然。通过对ucore操作系统的学习，使得我对于操作系统内核的学习不再感到恐惧，在认知学习概念中就是从恐惧区转为了学习区。以后有机会的话，可以通过研究早期的linux内核源码来解答我关于I/O模型底层实现的一系列问题。&lt;/p&gt;
&lt;p&gt;　　这篇博客是这一段时间来对操作系统学习的一个阶段性总结，直接或间接的回答了博客开头的几个问题，希望能帮到对操作系统、I/O模型感兴趣的人。这篇文章中还存在许多理解不到位的地方，请多多指教。&lt;/p&gt;
</description>
<pubDate>Tue, 10 Nov 2020 15:47:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>一、关于I/O模型的问题 最近通过对ucore操作系统的学习，让我打开了操作系统内核这一黑盒子，与之前所学知识结合起来，解答了长久以来困扰我的关于I/O的一些问题。 1. 为什么redis能以单工作线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoxiongcanguan/p/13938877.html</dc:identifier>
</item>
<item>
<title>TCP 三次握手和四次挥手图解（有限状态机） - huansky</title>
<link>http://www.cnblogs.com/huansky/p/13951567.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/13951567.html</guid>
<description>&lt;p&gt;传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793&lt;span class=&quot;sup--normal&quot; data-sup=&quot;1&quot; data-ctrmap=&quot;:1,&quot;&gt; 定义，是为了在不可靠的互联网络上提供可靠的端到端字节流而专门设计的一个传输协议。&lt;/span&gt; &lt;/p&gt;
&lt;p class=&quot;para&quot;&gt;互联网络与单个网络有很大的不同，因为互联网络的不同部分可能有截然不同的拓扑结构、带宽、延迟、数据包大小和其他参数。TCP 的设计目标是能够动态地适应互联网络的这些特性，而且具备面对各种故障时的健壮性。&lt;span class=&quot;sup--normal&quot; data-sup=&quot;2&quot; data-ctrmap=&quot;:2,&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;para&quot;&gt;应用层向 TCP 层发送用于网间传输的、用 8 位字节表示的数据流，然后 TCP 把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后 TCP 把结果包传给 IP 层，由它来通过网络将包传送给接收端实体的 TCP 层。TCP 为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（&lt;a href=&quot;https://baike.baidu.com/item/RTT&quot; target=&quot;_blank&quot;&gt;RTT&lt;/a&gt;）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP 用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。&lt;span class=&quot;sup--normal&quot; data-sup=&quot;3&quot; data-ctrmap=&quot;:3,&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/916005/202011/916005-20201109232949418-1911797331.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面对每个字段含义进行解释&lt;/p&gt;
&lt;ul readability=&quot;9&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;源、目标端口号字段&lt;/strong&gt;：占 16 比特 (2 字节)。TCP 协议通过使用”端口”来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。在服务器端，每种服务在”众所周知的端口”（Well-Know Port）为用户提供服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;顺序号字段&lt;/strong&gt;：占 32 比特。用来标识从 TCP 源端向 TCP 目标端发送的数据字节流，它表示在这个报文段中的第一个数据字节。在TCP传送的流中，每一个字节一个顺序号。e.g.如果一个 TCP 报文段的序号为 301，它携带了 100 字节的数据，就表示这 100 个字节的数据的字节序号范围是 [301, 400]，该报文段携带的第一个字节序号是 301，最后一个字节序号是 400。所以顺序号号确保了TCP传输的有序性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;确认号字段&lt;/strong&gt;：占 32 比特。只有 ACK 标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。比如建立连接时，SYN 报文的 ACK 标志位为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;头部长度字段&lt;/strong&gt;：占 4 比特。给出头部占 32 比特的数目。没有任何选项字段的 TCP 头部长度为 20 字节；最多可以有 60 字节的 TCP 头部。4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;标志位字段（U、A、P、R、S、F）&lt;/strong&gt;：占 6 比特。各比特的含义如下：窗口大小字段：占 16 比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;URG&lt;/strong&gt;：紧急指针标志，为 1 时表示紧急指针有效，为 0 则忽略紧急指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;ACK&lt;/strong&gt;：确认序号标志，为 1 时表示确认号有效，为 0 表示报文中不含确认信息，忽略确认号字段。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;PSH&lt;/strong&gt;：push 标志，为 1 表示是带有 push 标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;RST&lt;/strong&gt;：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;SYN&lt;/strong&gt;：同步序号，用于建立连接过程，在连接请求中，SYN = 1 和 ACK = 0 表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即 SYN = 1 和 ACK = 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;FIN&lt;/strong&gt;：finish 标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;紧急指针字段&lt;/strong&gt;：占 16 比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;&lt;strong&gt;选项和填充&lt;/strong&gt;：最常见的可选字段是最长报文大小，又称为 MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。&lt;/li&gt;
&lt;li class=&quot;_mce_tagged_br&quot;&gt;&lt;strong&gt;数据部分&lt;/strong&gt;：&lt;span lang=&quot;en-us&quot; xml:lang=&quot;en-us&quot;&gt; TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有&lt;span lang=&quot;en-us&quot; xml:lang=&quot;en-us&quot;&gt; TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP是一个面向连接的协议，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接，建立一条连接有以下过程。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;第一次握手：建立连接时，客户端发送 syn 包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=x+1），同时自己也发送一个 SYN 包（syn=y），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;第三次握手：客户端收到服务器的 SYN + ACK 包，向服务器发送确认包 ACK(ack=y+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP连接成功）状态，完成三次握手。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这三个报文段完成连接的建立，这个过程成为三次握手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/916005/202011/916005-20201110000506806-148773323.png&quot; alt=&quot;&quot; width=&quot;705&quot; height=&quot;333&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;SYN 攻击&lt;/h3&gt;
&lt;p&gt;在三次握手过程中，Server 发送 SYN-ACK 之后，收到 Client 的 ACK 之前的 TCP 连接称为半连接（half-open connect），此时 Server 处于 SYN_RCVD 状态，当收到 ACK 后，Server 转入 ESTABLISHED 状态。&lt;/p&gt;
&lt;p&gt;SYN 攻击就是 Client 在短时间内伪造大量不存在的 IP 地址，并向 Server 不断地发送 SYN 包，Server 回复确认包，并等待 Client 的确认，由于源地址是不存在的，因此，Server 需要不断重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，导致正常的 SYN 请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。&lt;/p&gt;
&lt;p&gt;SYN 攻击时一种典型的 DDOS 攻击，检测 SYN 攻击的方式非常简单，即当 Server 上有大量半连接状态且源 IP 地址是随机的，则可以断定遭到 SYN 攻击了。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当开放了一个 TCP 端口后，该端口就处于 Listening 状态，不停地监视发到该端口的 Syn 报文，&lt;/p&gt;
&lt;p&gt;一旦接收到 Client 发来的 Syn 报文，就需要为该请求分配一个 TCB（Transmission Control Block），并返回一个 SYN ACK 命令，立即转为 SYN-RECEIVED 即半开连接状态。&lt;/p&gt;
&lt;p&gt;通常一个 TCB 至少需要 280 个字节，在某些操作系统中 TCB 甚至需要 1300 个字节，而某些操作系统在 SOCK 的实现上最多可开启 512 个半开连接。&lt;/p&gt;
&lt;p&gt;消耗服务器资源主要是因为当 SYN 数据报文一到达，系统立即分配 TCB，从而占用了资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;收到 SYN 数据报文时不急于去分配TCB，而是先回应一个SYN ACK报文，并在一个专用HASH表（Cache）中保存这种半开连接信息，直到收到正确的回应ACK报文再分配TCB。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/916005/202011/916005-20201110000734271-1488793082.png&quot; alt=&quot;&quot; width=&quot;575&quot; height=&quot;369&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;11&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待1）状态。 TCP 规定，FIN报文段即使不携带数据，也要消耗一个序号。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP连接还没有释放，必须经过 2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入 CLOSED 状态。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/916005/202011/916005-20201110000354488-939164703.png&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;658&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;para&quot;&gt; &lt;/p&gt;
&lt;p&gt;上图是 TCP 的状态机。&lt;/p&gt;
&lt;ol readability=&quot;10&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;CLOSED：&lt;/strong&gt;状态时初始状态。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;LISTEN：&lt;/strong&gt;被动打开，服务器端的 状态变为 LISTEN (监听)。被动打开的概念：连接的一端的应用程序通知操作系统，希望建立一个传入的连接。这时候操作系统为连接的这一端建立一个连接。与之对应的是主动连接：应用程序通过主动打开请求来告诉操作系统建立一个连接。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SYNRECVD：&lt;/strong&gt;服务器端收到 SYN 后，状态为 SYN；发送 SYN ACK;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SYN_SENTY：&lt;/strong&gt;应用程序发送 SYN 后，状态为 SYN_SENT；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ESTABLISHED：&lt;/strong&gt;SYNRECVD 收到 ACK 后，状态为 ESTABLISHED； SYN_SENT 在收到 SYN ACK，发送 ACK，状态为 ESTABLISHED；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;CLOSE_WAIT：&lt;/strong&gt;服务器端在收到 FIN 后，发送 ACK，状态为 CLOSE_WAIT；如果此时服务器端还有数据需要发送，那么就发送，直到数据发送完毕；此时，服务器端发送FIN，状态变为 LAST_ACK;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;FIN_WAIT_1：&lt;/strong&gt;应用程序端发送 FIN，准备断开 TCP 连接；状态从 ESTABLISHED -&amp;gt; FIN_WAIT_1；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;FIN_WAIT_2：&lt;/strong&gt;应用程序端只收到服务器端得 ACK 信号，并没有收到FIN信号；说明服务器端还有数据传输，那么此时为半连接；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TIME_WAIT：&lt;/strong&gt;有两种方式进入该状态：&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;FIN_WAIT_1进入：&lt;/strong&gt;此时应用程序端口收到 FIN+ACK（而不是像 FIN_WAIT_2 那样只收到 ACK，说明数据已经发送完毕）并向服务器端口发送 ACK；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;FIN_WAIT_2进入：&lt;/strong&gt;此时应用程序端口收到了 FIN，然后向服务器端发送 ACK；TIME_WAIT 是为了实现 TCP 全双工连接的可靠性关闭，用来重发可能丢失的 ACK 报文；需要持续 2 个 MSL (最大报文生存时间)：假设应用程序端口在进入 TIME_WAIT后，2 个 MSL 时间内并没有收到FIN,说明应用程序最后发出的 ACK 已经收到了；否则，会在 2 个 MSL 内在此收到ACK报文；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;客户端应用程序的状态迁移图&lt;/h3&gt;
&lt;p&gt;客户端的状态可以用如下的流程来表示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
CLOSED -&amp;gt; SYN_SENT -&amp;gt; ESTABLISHED -&amp;gt; FIN_WAIT_1 -&amp;gt; FIN_WAIT_2 -&amp;gt; TIME_WAIT -&amp;gt; CLOSED
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上流程是在程序正常的情况下应该有的流程，从书中的图中可以看到，在建立连接时，当客户端收到 SYN 报文的 ACK 以后，客户端就打开了数据交互地连接。而结束连接则通常是客户端主动结束的，客户端结束应用程序以后，需要经历 FIN_WAIT_1，FIN_WAIT_2 等状态，这些状态的迁移就是前面提到的结束连接的四次握手。&lt;/p&gt;
&lt;h3&gt;服务器的状态迁移图&lt;/h3&gt;
&lt;p&gt;服务器的状态可以用如下的流程来表示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
CLOSED -&amp;gt; LISTEN -&amp;gt; SYN 收到 -&amp;gt; ESTABLISHED -&amp;gt; CLOSE_WAIT -&amp;gt; LAST_ACK -&amp;gt; CLOSED
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在建立连接的时候，服务器端是在第三次握手之后才进入数据交互状态，而关闭连接则是在关闭连接的第二次握手以后（注意不是第四次）。而关闭以后还要等待客户端给出最后的ACK 包才能进入初始的状态。&lt;/p&gt;
&lt;h3&gt;其他状态迁移&lt;/h3&gt;
&lt;p&gt;书中的图还有一些其他的状态迁移，这些状态迁移针对服务器和客户端两方面的总结如下&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;LISTEN -&amp;gt; SYN_SENT&lt;/strong&gt;，对于这个解释就很简单了，服务器有时候也要打开连接的嘛。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SYN_SENT -&amp;gt; SYN 收到&lt;/strong&gt;，服务器和客户端在 SYN_SENT 状态下如果收到 SYN 数据报，则都需要发送 SYN 的 ACK 数据报并把自己的状态调整到 SYN 收到状态，准备进入ESTABLISHED&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SYN_SENT -&amp;gt; CLOSED&lt;/strong&gt;，在发送超时的情况下，会返回到 CLOSED 状态。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SYN_收到 -&amp;gt; LISTEN&lt;/strong&gt;，如果受到 RST 包，会返回到 LISTEN 状态。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SYN_收到 -&amp;gt; FIN_WAIT_1&lt;/strong&gt;，这个迁移是说，可以不用到 ESTABLISHED 状态，而可以直接跳转到 FIN_WAIT_1 状态并等待关闭。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2 MSL 等待状态&lt;/h3&gt;
&lt;p&gt;书中给的图里面，有一个 TIME_WAIT 等待状态，这个状态又叫做 2 MSL 状态，说的是在 TIME_WAIT2 发送了最后一个 ACK 数据报以后，要进入 TIME_WAIT 状态，这个状态是防止最后一次握手的数据报没有传送到对方那里而准备的（注意这不是四次握手，这是第四次握手的保险状态）。这个状态在很大程度上保证了双方都可以正常结束，但是，问题也来了。&lt;/p&gt;
&lt;p&gt;由于插口的 2MSL 状态（插口是IP和端口对的意思，socket），使得应用程序在 2 MSL 时间内是无法再次使用同一个插口的，对于客户程序还好一些，但是对于服务程序，例如httpd，它总是要使用同一个端口来进行服务，而在 2 MSL 时间内，启动 httpd 就会出现错误（插口被使用）。为了避免这个错误，服务器给出了一个平静时间的概念，这是说在 2 MSL 时间内，虽然可以重新启动服务器，但是这个服务器还是要平静的等待 2 MSL 时间的过去才能进行下一次连接。&lt;/p&gt;
&lt;h3&gt;FIN_WAIT_2 状态&lt;/h3&gt;
&lt;p&gt;这就是著名的半关闭的状态了，这是在关闭连接时，客户端和服务器两次握手之后的状态。在这个状态下，应用程序还有接受数据的能力，但是已经无法发送数据，但是也有一种可能是，客户端一直处于 FIN_WAIT_2 状态，而服务器则一直处于 WAIT_CLOSE 状态，而直到应用层来决定关闭这个状态。&lt;/p&gt;
&lt;h3&gt;RST，同时打开和同时关闭&lt;/h3&gt;
&lt;p&gt;RST 是另一种关闭连接的方式，应用程序应该可以判断 RST 包的真实性，即是否为异常中止。而同时打开和同时关闭则是两种特殊的 TCP 状态，发生的概率很小。&lt;/p&gt;

&lt;h3&gt;【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？&lt;/h3&gt;
&lt;p&gt;答：因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉 Client 端，&quot;你发的 FIN 报文我收到了&quot;。只有等到我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步握手。&lt;/p&gt;
&lt;h3&gt;【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？&lt;/h3&gt;
&lt;p&gt;虽然按道理，四个报文都发送完毕，我们可以直接进入 CLOSE 状态了，但是我们必须假象网络是不可靠的，有可以最后一个 ACK 丢失。所以TIME_WAIT状态就是用来重发可能丢失的 ACK 报文。在 Client 发送出最后的 ACK 回复，但该 ACK 可能丢失。Server 如果没有收到 ACK，将不断重复发送 FIN 片段。所以 Client 不能立即关闭，它必须确认 Server 接收到了该ACK。Client 会在发送出ACK 之后进入到 TIME_WAIT 状态。Client 会设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到FIN，那么 Client 会重发 ACK 并再次等待2 MSL。所谓的 2 MSL 是两倍的 MSL(Maximum Segment Lifetime)。MSL 指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2 MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。&lt;/p&gt;
&lt;h3&gt;【问题3】为什么不能用两次握手进行连接？&lt;/h3&gt;
&lt;p&gt;3 次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。&lt;/p&gt;
&lt;p&gt;现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机 S 和 C 之间的通信，假定 C 给 S 发送一个连接请求分组，S 收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S 认为连接已经成功地建立了，可以开始发送数据分组。可是，C 在 S 的应答分组在传输中被丢失的情况下，将不知道 S 是否已准备好，不知道 S 建立什么样的序列号，C 甚至怀疑 S 是否收到自己的连接请求分组。在这种情况下，C 认为连接还未建立成功，将忽略 S 发来的任何数据分组，只等待连接确认应答分组。而 S 在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。&lt;/p&gt;
&lt;h3&gt;【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？&lt;/h3&gt;
&lt;p&gt;TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒钟发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接&lt;/p&gt;
&lt;h3&gt;参考文章&lt;/h3&gt;
&lt;p&gt;https://blog.csdn.net/whuslei/article/details/6667471&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/qq_38950316/article/details/81087809&lt;/p&gt;
&lt;p&gt;https://www.sohu.com/a/321838267_495675&lt;/p&gt;
&lt;p&gt;https://www.iteye.com/blog/uule-2213562&lt;/p&gt;
</description>
<pubDate>Tue, 10 Nov 2020 15:17:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793&amp;#160;定义，是为了在不可靠</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huansky/p/13951567.html</dc:identifier>
</item>
<item>
<title>【故障公告】Memcached 的“惹祸”，不知在为谁背锅 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/13956473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/13956473.html</guid>
<description>&lt;p&gt;在 .NET 5.0 背锅 、 Memcached 的惹祸 、缓存雪崩之后，我们没有找到问题的真正原因，我们知道没有找到根源的故障总是会再次光临的，不是在这周就是在下周，也许就在双11前后。就在今天双11的前一天晚上，在我们 20:30 进行常规发布的时候，它来了。。。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;88.88518231187&quot;&gt;
&lt;p&gt;在 &lt;a href=&quot;https://www.cnblogs.com/cmt/p/13820677.html&quot; target=&quot;_blank&quot;&gt;.NET 5.0 背锅&lt;/a&gt; 、 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/cmt/p/13889113.html&quot; target=&quot;_blank&quot;&gt;Memcached 的惹祸&lt;/a&gt; 、&lt;a href=&quot;https://www.cnblogs.com/cmt/p/13919666.html&quot; target=&quot;_blank&quot;&gt;缓存雪崩&lt;/a&gt;之后，我们没有找到问题的真正原因，我们知道没有找到根源的故障总是会再次光临的，不是在这周就是在下周，也许就在双11前后。&lt;/p&gt;
&lt;p&gt;就在今天双11的前一天晚上，在我们 20:30 进行常规发布的时候，它来了。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35695/202011/35695-20201110222338525-413430799.png&quot; width=&quot;696&quot; height=&quot;309&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原本平滑的 memcached 服务器 tcp 连接数走势曲线开始爬坡，博客站点大量的访问请求响应缓慢，每次都“惹祸”的 memcached 自然首当其冲地成为嫌疑的焦点。&lt;/p&gt;
&lt;p&gt;我们重启了所有 memcached 服务，tcp 连接数飞流直下三千尺地降了下来，但是降落之后却又开始新的一轮爬坡，故障没有恢复，网站访问速度依然缓慢。&lt;/p&gt;
&lt;p&gt;这时，我们突然醒悟，memcached 没有惹祸，问题不在 memcached ，问题可能在前方阵地（用阿里云服务器自建的kubernetes集群）的 pods 发生了 tcp 连接泄漏，立马赶赴前线。&lt;/p&gt;
&lt;p&gt;博客站点的多个 pod 处于 CrashLoopBackOff 状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
NAME                        READY   STATUS             RESTARTS   AGE   IP                NODE       
blog-web-6644bfd597-2fpd6   1/1     Running            0          48m   192.168.86.93     k8s-n20    
blog-web-6644bfd597-4cnc5   1/1     Running            0          49m   192.168.168.112   k8s-n6     
blog-web-6644bfd597-bqbmf   0/1     CrashLoopBackOff   11         49m   192.168.73.63     k8s-node10 
blog-web-6644bfd597-db8jk   0/1     Running            13         48m   192.168.107.238   k8s-node3  
blog-web-6644bfd597-dthtn   0/1     CrashLoopBackOff   13         49m   192.168.104.103   k8s-node11 
blog-web-6644bfd597-fxzml   1/1     Running            13         48m   192.168.195.224   k8s-node5  
blog-web-6644bfd597-qvgkf   1/1     Running            12         47m   192.168.89.229    k8s-n8     
blog-web-6644bfd597-slmp7   0/1     CrashLoopBackOff   13         49m   192.168.201.126   k8s-n14    
blog-web-6644bfd597-txg5h   0/1     CrashLoopBackOff   13         45m   192.168.42.57     k8s-n13    
blog-web-6644bfd597-wc57c   0/1     Running            13         47m   192.168.254.167   k8s-n7     
blog-web-6644bfd597-xt5hc   0/1     CrashLoopBackOff   11         47m   192.168.228.53    k8s-n9     
blog-web-6644bfd597-zz564   1/1     Running            0          47m   192.168.118.27    k8s-n4  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;怀疑造成 tcp 连接泄漏可能是这些处于 CrashLoopBackOff 状态的 pod ，于是将 pod 全部强制删除，在删除后过了一段时间，memcached 服务器 tcp 连接数从爬坡状态回归平滑状态，故障就恢复了。&lt;/p&gt;
&lt;p&gt;查看 k8s 集群 node 服务器的 tcp 连接情况，在故障期间，node 服务器的 tcp 连接数上蹿下跳，大量 tcp 连接无法建立。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/35695/202011/35695-20201110230255213-808673792.png&quot; width=&quot;596&quot; height=&quot;309&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到目前我们还是没有找到问题的根源，但我们知道了 memcached 没有惹祸，memcached 是在背锅，但不知道在为谁背锅。&lt;/p&gt;
&lt;p&gt;非常抱歉，今天 20:35~21:35 左右博客站点发生的故障给您带来麻烦了，请您谅解。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 10 Nov 2020 15:15:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>在 .NET 5.0 背锅 、 Memcached 的惹祸 、缓存雪崩之后，我们没有找到问题的真正原因，我们知道没有找到根源的故障总是会再次光临的，不是在这周就是在下周，也许就在双11前后。就在今天双</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cmt/p/13956473.html</dc:identifier>
</item>
</channel>
</rss>