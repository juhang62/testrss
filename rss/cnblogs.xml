<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>充气娃娃什么感觉？Python告诉你 - 猪哥66</title>
<link>http://www.cnblogs.com/pig66/p/11165583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pig66/p/11165583.html</guid>
<description>&lt;p&gt;上期为大家介绍了requests库的基本信息以及使用requests库爬取某东的商品页，收到了很多同学的反馈说期待猪哥的更新，猪哥感到非常开心，今天就带大家来玩一把刺激的！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1599951/201907/1599951-20190710175845718-2082517336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;一、需求背景&lt;/h2&gt;
&lt;p&gt;在实际开发过程中，在我们动手开发之前，都是由产品经理为我们（测试、前端、后端、项目经理等）先讲解一下需求，我们了解了需求之后，才开始一起来讨论技术方案。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709161527742.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我们自己实现一些小功能时同样需要讨论需求，也就是告诉别人我们为什么要做这个东西？或者我们想利用这款产品解决什么问题。&lt;/p&gt;
&lt;p&gt;我们常常看到一些有关充气娃娃的表情包和图片或新闻，但是这种东西很少会像一些小视频一些相互交流，大家可能都是偷摸玩耍。所以猪哥相信其实大部分同学并没有亲身体验过充气娃娃到底是什么感觉（包括猪哥），所以猪哥很好奇究竟是什么一种体验？真的如传言中那样爽吗？&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019070916155547.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;二、功能描述&lt;/h2&gt;
&lt;p&gt;基于很多人没有体验过充气娃娃是什么感觉，但是又很好奇，所以希望通过&lt;strong&gt;爬虫+数据分析&lt;/strong&gt;的方式直观而真是的告诉大家（下图为成品图）。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190710170342585.png?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;三、技术方案&lt;/h2&gt;
&lt;p&gt;为了实现上面的需求以及功能，我们来讨论下具体的技术实现方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分析某东评论数据请求&lt;/li&gt;
&lt;li&gt;使用requests库抓取某东的充气娃娃评论&lt;/li&gt;
&lt;li&gt;使用词云做数据展示&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;-&quot;&gt;四、技术实现&lt;/h2&gt;
&lt;p&gt;上篇文章中就给大家说过，今天我们以某东商品编号为：&lt;strong&gt;1263013576&lt;/strong&gt;的商品为对象，进行数据分析，我们来看看详细的技术实现步骤吧！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本教程只为学习交流，不得用于商用获利，后果自负！&lt;br/&gt;如有侵权或者对任何公司或个人造成不利影响，请告知删除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-url&quot;&gt;1.分析并获取评论接口的URL&lt;/h3&gt;
&lt;p&gt;第一步：打开某东的商品页，搜索你想研究的商品。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709173046883.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;第二步：我们在页面中鼠标右键选择检查（或F12）调出浏览器的调试窗口。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709173420637.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;第三步：调出浏览器后点击评论按钮使其加载数据，然后我们点击network查看数据。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709180639748.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;第四步：查找加载评论数据的请求url，我们可以使用某条评论中的一段话，然后在调试窗口中搜索。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709181623175.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709181841646.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;经过上面4步分析，我们就拿到了京东评论数据的接口：&lt;a href=&quot;https://sclub.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv4654&amp;amp;productId=1263013576&amp;amp;score=0&amp;amp;sortType=5&amp;amp;page=0&amp;amp;pageSize=10&amp;amp;isShadowSku=0&amp;amp;fold=1&quot;&gt;https://sclub.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv4654&amp;amp;productId=1263013576&amp;amp;score=0&amp;amp;sortType=5&amp;amp;page=0&amp;amp;pageSize=10&amp;amp;isShadowSku=0&amp;amp;fold=1&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;productPageComments：看这个名字就知道是产品页评论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-&quot;&gt;2.爬取评论数据&lt;/h3&gt;
&lt;p&gt;拿到评论数据接口url之后，我们就可以开始写代码抓取数据了。一般我们会先尝试抓取一条数据，成功之后，我们再去分析如何实现大量抓取。&lt;/p&gt;
&lt;p&gt;上一篇我们已经讲解了如何使用requests库发起http/s请求，我们来看看代码&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709183316160.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;但是在打印的结果中数据却是空？为何浏览器请求成功，而我们的代码却请求不到数据呢？难道我们遇到了反扒？这种情况下如何解决？&lt;/p&gt;
&lt;p&gt;大家在遇到这种情况时，回到浏览器的调试窗口，查看下浏览器发起的请求头，因为可能浏览器请求时携带了什么请求头参数而我们代码中没有。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709183838770.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;果然，我们在浏览器头中看到了有两个请求头&lt;strong&gt;Referer&lt;/strong&gt;和&lt;strong&gt;User-Agent&lt;/strong&gt;，那我们先把他们加到代码的请求头中，再试试！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709195835765.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-&quot;&gt;3.数据提取&lt;/h3&gt;
&lt;p&gt;我们对爬取的数据分析发现，此数据为jsonp跨域请求返回的json结果，所以我们只要把前面的&lt;code&gt;fetchJSON_comment98vv4646(&lt;/code&gt;和最后的&lt;code&gt;)&lt;/code&gt;去掉就拿到json数据了。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709210111511.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;将json数据复制到json格式化工具中或者在Chrome浏览器调试窗口点击&lt;code&gt;Preview&lt;/code&gt;也可以看到，json数据中有一个key为&lt;code&gt;comments&lt;/code&gt;的值便是我们想要的评论数据。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709211305943.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我们再对comments值进行分析发现是一个有多条数据的列表，而列表里的每一项就是每个评论对象，包含了评论的内容，时间，id，评价来源等等信息，而其中的&lt;code&gt;content&lt;/code&gt;字段便是我们在页面看到的用户评价内容。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709214011492.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;那我们来用代码将每个评价对象的&lt;code&gt;content&lt;/code&gt;字段提取并打印出来&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709214638446.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-&quot;&gt;4.数据保存&lt;/h3&gt;
&lt;p&gt;数据提取后我们需要将他们保存起来，一般保存数据的格式主要有：文件、数据库、内存这三大类。今天我们就将数据保存为txt文件格式，因为操作文件相对简单同时也能满足我们的后续数据分析的需求。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019070922422194.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;然后我们查看一下生成的文件内容是否正确&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190709224405446.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-&quot;&gt;5.批量爬取&lt;/h3&gt;
&lt;p&gt;再完成一页数据爬取、提取、保存之后，我们来研究一下如何批量抓取？&lt;/p&gt;
&lt;p&gt;做过web的同学可能知道，有一项功能是我们必须要做的，那便是分页。何为分页？为何要做分页？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们在浏览很多网页的时候常常看到“下一页”这样的字眼，其实这就是使用了分页技术，因为向用户展示数据时不可能把所有的数据一次性展示，所以采用分页技术，一页一页的展示出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们再回到最开始的加载评论数据的url：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://sclub.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv4654&amp;amp;productId=1263013576&amp;amp;score=0&amp;amp;sortType=5&amp;amp;page=0&amp;amp;pageSize=10&amp;amp;isShadowSku=0&amp;amp;fold=1&quot;&gt;https://sclub.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv4654&amp;amp;productId=1263013576&amp;amp;score=0&amp;amp;sortType=5&amp;amp;page=0&amp;amp;pageSize=10&amp;amp;isShadowSku=0&amp;amp;fold=1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以看到链接里面有两个参数&lt;strong&gt;page=0&amp;amp;pageSize=10&lt;/strong&gt;，page表示当前的页数，pageSize表示每页多少条，那这两个数据直接去数据库limit数据。&lt;/p&gt;
&lt;p&gt;老司机一眼便可以看出这就是分页的参数，但是有同学会说：如果我是老司机还干嘛看你的文章？所以&lt;strong&gt;我教大家如何来找到这个分页参数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;回到某东的商品页，我们将评价页面拉到最底下，发现有分页的按钮，然后我们在调试窗口清空之前的请求记录。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190710102802349.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;清空之前的请求记录之后，我们点击上图红框分页按钮的数字2，代表这第二页，然后复制第一条评价去调试窗口搜索，最后找到请求链接。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201907101034326.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;然后我们点击&lt;code&gt;Headers&lt;/code&gt;查看第二页请求数据的url&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190710103625997.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;然后我们比较第一页评价与第二页评价的url有何区别&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019071010423136.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这里也就验证了猪哥的猜想：page表示当前的页数，pageSize表示每页多少条。而且我们还能得出另一个结论：第一个page=0，第二页page=1 然后依次往后。有同学会问：为什么第一页不是1，而是0，因为在数据库中一般的都是从0开始计数，编程行业很多数组列表都是从0开始计数。&lt;/p&gt;
&lt;p&gt;好了，知道分页规律之后，我们只要在每次请求时将page参数递增不就可以批量抓取了吗？我们来写代码吧！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019071013522188.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;简单讲解一下做的改动：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对&lt;strong&gt;spider_comment&lt;/strong&gt;方法增加入参&lt;strong&gt;page&lt;/strong&gt;：页数，然后在url中增加占位符，这样就可以动态修改url，爬取指定的页数。&lt;/li&gt;
&lt;li&gt;增加一个&lt;strong&gt;batch_spider_comment&lt;/strong&gt;方法，循环调用&lt;strong&gt;spider_comment&lt;/strong&gt;方法，暂定爬取100页。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;batch_spider_comment&lt;/strong&gt;方法的for循环中设置了一个随机的休眠时间，意在模拟用户浏览，防止因为爬取太频繁被封ip。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;爬取完成之后检查成果&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190710135804482.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;6-&quot;&gt;6.数据清洗&lt;/h3&gt;
&lt;p&gt;数据成功保存之后我们需要对数据进行分词清洗，对于分词我们使用著名的分词库&lt;strong&gt;jieba&lt;/strong&gt;。&lt;br/&gt;首先是安装jieba库：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pip3 install jieba&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190710162711803.png?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;当然这里你还可以对一些介词等无效词进行剔除，这样可以避免无效数据。&lt;/p&gt;
&lt;h3 id=&quot;7-&quot;&gt;7.生成词云&lt;/h3&gt;
&lt;p&gt;生成云词我们需要用到&lt;code&gt;numpy&lt;/code&gt;、&lt;code&gt;matplotlib&lt;/code&gt;、&lt;code&gt;wordcloud&lt;/code&gt;、&lt;code&gt;Pillow&lt;/code&gt;这几个库，大家先自行下载。&lt;code&gt;matplotlib&lt;/code&gt;库用于图像处理，&lt;code&gt;wordcloud&lt;/code&gt;库用于生成词云。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190710153431257.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：font_path是选择字体的路径，如果不设置默认字体可能不支持中文，猪哥选择的是Mac系统自带的宋体字！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最终结果：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190710153743818.jpg?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我们来看看全代码：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190710162632490.png?&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;因考虑新手的友好性，文章篇幅较长，详细的介绍了从需求到技术分析、爬取数据、清洗数据、最后的分析数据。我们来总结一下本片文章学到的东西吧：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何分析并找出加载数据的url&lt;/li&gt;
&lt;li&gt;如何使用requests库的headers解决&lt;strong&gt;Referer&lt;/strong&gt;和&lt;strong&gt;User-Agent&lt;/strong&gt;反扒技术&lt;/li&gt;
&lt;li&gt;如何找出分页参数实现批量爬取&lt;/li&gt;
&lt;li&gt;数据的提取与保存到文件&lt;/li&gt;
&lt;li&gt;使用jieba库对数据分词清洗&lt;/li&gt;
&lt;li&gt;使用wordcloud生成指定形状的词云&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是一套完整的数据分析案例，希望大家能自己动手尝试，去探索更多有趣的案例，做个有趣的人～&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/pig6/jd_comment_spider&quot;&gt;https://github.com/pig6/jd_comment_spider&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181217213155258.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Thu, 11 Jul 2019 00:39:00 +0000</pubDate>
<dc:creator>猪哥66</dc:creator>
<og:description>上期为大家介绍了requests库的基本信息以及使用requests库爬取某东的商品页，收到了很多同学的反馈说期待猪哥的更新，猪哥感到非常开心，今天就带大家来玩一把刺激的！ 一、需求背景 在实际开发过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pig66/p/11165583.html</dc:identifier>
</item>
<item>
<title>Ng-Matero：基于 Angular Material 搭建的中后台管理框架 - 叙帝利</title>
<link>http://www.cnblogs.com/nzbin/p/11150811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nzbin/p/11150811.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/999445/201907/999445-20190710221640551-1395163144.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;目前市面上关于 Angular Material 的后台框架比较少，大多都是收费主题，而且都不太好用。&lt;/p&gt;
&lt;p&gt;很多人都说 Material 是一个面向 C 端的框架，其实在使用其它框架做管理系统的时候，我发现 Material 的组件基本已经够用了，其它不足的地方可以配合一些优秀的第三方库。另外，Material 的确是一个高质量的组件库，不管是设计思路还是使用方式，都近乎完美。&lt;/p&gt;
&lt;p&gt;经过一个多月的设计与思考，我开发了这款基于 Angular Material 的中后台管理框架，初期架构设计已经完成，在接下来的版本中会提供 schematics 支持及 vscode snippet 工具。同时，为了弥补 Material 的不足以及更好的发挥框架的优势，我创建了另外一个项目以扩展 Material 的组件库。&lt;/p&gt;
&lt;p&gt;因为目前还没有完善的文档，所以本篇文章会简单介绍一下框架的使用。&lt;/p&gt;
&lt;blockquote readability=&quot;1.8349514563107&quot;&gt;
&lt;p&gt;Github： &lt;a href=&quot;https://github.com/ng-matero/ng-matero&quot; class=&quot;uri&quot;&gt;https://github.com/ng-matero/ng-matero&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;预览地址： &lt;a href=&quot;https://ng-matero.github.io/ng-matero/&quot; class=&quot;uri&quot;&gt;https://ng-matero.github.io/ng-matero/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/999445/201907/999445-20190710232042127-170055947.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;目录结构&lt;/h2&gt;
&lt;p&gt;先看一下目录结构，这个目录结构遵循了 Angular 的最佳实践，尽量保证结构的规范化与合理性。&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;├── src
│   ├── app
│   │   ├── core                                # 核心模块
│   │   │   ├── interceptors                    # HTTP 拦截器
│   │   │   │   └── default.interceptor.ts      
│   │   │   ├── services
│   │   │   │   ├── settings.service.ts         # 页面布局配置
│   │   │   │   ├── menu.service.ts             # 菜单配置
│   │   │   │   └── startup.service.ts          # 初始化项目配置
│   │   │   └── core.module.ts                  # 核心模块文件
│   │   ├── routes
│   │   │   ├── **                              # 业务目录
│   │   │   ├── routes-routing.module.ts        # 业务路由注册口
│   │   │   └── routes.module.ts                # 业务路由模块
│   │   ├── shared                              # 共享模块
│   │   │   └── shared.module.ts                # 共享模块文件
│   │   ├── theme                               # 主题目录
│   │   │   ├── admin-layout                    # admin 布局
│   │   │   ├── auth-layout                     # 登陆注册布局
│   │   |   └── theme.module.ts                 # 主题模块
│   │   ├── app.component.ts                    # 根组件
│   │   └── app.module.ts                       # 根模块
│   │   └── material.module.ts                  # Material 组件模块
│   ├── assets                                  # 本地静态资源
│   ├── environments                            # 环境变量配置
│   ├── styles                                  # 样式目录
│   │   ├── component                           # 公用组件样式
│   │   ├── helpers                             # 工具类
│   │   ├── mixins                              # mixins
│   │   ├── plugins                             # 第三方库样式
│   │   ├── ** 
│   │   ├── theme                               # 主题核心样式
│   │   └── app.scss                            # 主题样式入口文件
└── └── style.scss                              # 样式主入口文件&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;响应式布局系统&quot;&gt;响应式布局系统&lt;/h2&gt;
&lt;p&gt;框架的响应式布局系统采用了 Angular 官方提供的 flex-layout，包含 flex 以及 grid，确实非常好用。&lt;/p&gt;
&lt;p&gt;但是关于列间距问题稍微有点坑，虽然 flex-layout 添加 &lt;code&gt;fxLayoutGap=&quot;10px grid&quot;&lt;/code&gt; 这样看似完美的方案，但是还是不太好用，除非每一个元素块都包含在 fxFlex 中。最终我还是使用业界比较普遍的 margin 负值的方式。需要在 fxLayout 上面添加 &lt;code&gt;.matero-row&lt;/code&gt;，在 fxFlex 上面添加 &lt;code&gt;.matero-col&lt;/code&gt;，当然这也不是必须的，在某些情况下使用 grid 方式可能更简单。&lt;/p&gt;
&lt;h2 id=&quot;配置布局&quot;&gt;配置布局&lt;/h2&gt;
&lt;p&gt;通过在 settings 服务中传入配置对象可以配置页面的布局，比如&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;// 配置选项接口
export interface Defaults {
  showHeader?: boolean;
  headerPos?: 'fixed' | 'static' | 'above';
  navPos?: 'side' | 'top';
  sidenavCollapsed?: boolean;
  sidenavOpened?: boolean;
  showUserPanel?: boolean;
  dir?: 'ltr' | 'rtl';
}

// 默认配置选项
const defaults: Defaults = {
  showHeader: true,
  headerPos: 'fixed',
  navPos: 'side',
  sidenavCollapsed: false,
  sidenavOpened: true,
  showUserPanel: true,
  dir: 'ltr',
};

// 设置布局，注入服务，初始化数据后可以执行如下方法
this.settings.setLayout(options)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前关于配置布局的设计还没有想好，后期可能会在根模块进行全局配置，个人觉得更好的方式还是直接调整 layout 的模板，不要使用上面这种配置方式。&lt;/p&gt;
&lt;h2 id=&quot;配置菜单&quot;&gt;配置菜单&lt;/h2&gt;
&lt;p&gt;以下是菜单的类型定义&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export interface Tag {
  color: string; // Background Color
  value: string;
}

export interface ChildrenItem {
  state: string;
  name: string;
  type: 'link' | 'sub' | 'extLink' | 'extTabLink';
  children?: ChildrenItem[];
}

export interface Menu {
  state: string;
  name: string;
  type: 'link' | 'sub' | 'extLink' | 'extTabLink';
  icon: string;
  label?: Tag;
  badge?: Tag;
  children?: ChildrenItem[];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;菜单服务会注入到根组件，通过 &lt;code&gt;getAll()&lt;/code&gt; 可以获取到全部菜单，同样是在初始化数据后通过 &lt;code&gt;set()&lt;/code&gt; 方法设置好菜单。以下是菜单的配置示例：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;menu&quot;:  [{
      &quot;state&quot;: &quot;dashboard&quot;,
      &quot;name&quot;: &quot;Dashboard&quot;,
      &quot;type&quot;: &quot;link&quot;,
      &quot;icon&quot;: &quot;dashboard&quot;,
      &quot;badge&quot;: {
        &quot;color&quot;: &quot;red-500&quot;,
        &quot;value&quot;: &quot;5&quot;
      }
    },
    {
      &quot;state&quot;: &quot;design&quot;,
      &quot;name&quot;: &quot;Design&quot;,
      &quot;type&quot;: &quot;sub&quot;,
      &quot;icon&quot;: &quot;color_lens&quot;,
      &quot;children&quot;: [{
          &quot;state&quot;: &quot;colors&quot;,
          &quot;name&quot;: &quot;Color System&quot;,
          &quot;type&quot;: &quot;link&quot;
        },
        {
          &quot;state&quot;: &quot;icons&quot;,
          &quot;name&quot;: &quot;Icons&quot;,
          &quot;type&quot;: &quot;link&quot;
        }
      ]
    },
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;颜色系统&quot;&gt;颜色系统&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/999445/201907/999445-20190710235022132-2118257866.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在预览页面，大家可以看到很丰富的颜色，而 Material 本身只有三种主色，通过颜色系统也可以很容易更换颜色。&lt;/p&gt;
&lt;p&gt;颜色系统是通过 Material 的官方色值用 sass 生成的，Material 的颜色定义如下，包括主体色系以及对应的对比色系：&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;red: {
    50: '#FFEBEE',
    100: '#FFCDD2',
    200: '#EF9A9A',
    300: '#E57373',
    400: '#EF5350',
    500: '#F44336',
    600: '#E53935',
    700: '#D32F2F',
    800: '#C62828',
    900: '#B71C1C',
    A100: '#FF8A80',
    A200: '#FF5252',
    A400: '#FF1744',
    A700: '#D50000',
    contrast: {
      50: 'dark',
      100: 'dark',
      200: 'dark',
      300: 'dark',
      400: 'light',
      500: 'light',
      600: 'light',
      700: 'light',
      800: 'light',
      900: 'light',
      A100: 'dark',
      A200: 'light',
      A400: 'light',
      A700: 'light',
    },
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以直接使用 class 添加颜色，比如背景色可以用 &lt;code&gt;.bg-red-500&lt;/code&gt;，文本色则是 &lt;code&gt;.text-red-500&lt;/code&gt;，与之对应的对比色可以是 &lt;code&gt;.text-light&lt;/code&gt;，&lt;code&gt;.text-dark&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;辅助类&quot;&gt;辅助类&lt;/h2&gt;
&lt;p&gt;Helper 编写延续了 &lt;a href=&quot;https://github.com/snack-ui/snack-helper&quot;&gt;snack-helper&lt;/a&gt; 的设计原则，非常简单，可以参见源码，在此不过多阐述，感兴趣的朋友可以阅读我之前写的文章 &lt;a href=&quot;https://www.cnblogs.com/nzbin/p/7746047.html&quot;&gt;如何编写通用的 Helper Class&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;开发计划&quot;&gt;开发计划&lt;/h2&gt;
&lt;p&gt;目前框架只完成了一期规划，后面的路还有很长，首先会支持 schematics，可以使用 &lt;code&gt;ng add&lt;/code&gt; 来添加项目，同时也会提供 vscode 工具包，最后还希望广大 ng 爱好者可以加入到项目中来，共建 ng 生态。&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jul 2019 23:34:00 +0000</pubDate>
<dc:creator>叙帝利</dc:creator>
<og:description>前言 目前市面上关于 Angular Material 的后台框架比较少，大多都是收费主题，而且都不太好用。 很多人都说 Material 是一个面向 C 端的框架，其实在使用其它框架做管理系统的时候</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nzbin/p/11150811.html</dc:identifier>
</item>
<item>
<title>又是一年的校招季，过来人给你讲几句肺腑之言 - 黄小斜</title>
<link>http://www.cnblogs.com/xll1025/p/11167413.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/11167413.html</guid>
<description>&lt;p&gt;阅读本文大概需要 10 分钟。&lt;/p&gt;

&lt;p&gt;转眼间又到了六月底。马上就要迎来新一年的秋季校园招聘了。这对很多即将毕业的，想要从事互联网行业的同学来说，都是非常重要的一段时间。&lt;/p&gt;
&lt;p&gt;在这期间，很多互联网公司将陆续开始校园招聘，招聘对于很多公司来说都是非常重要的，它是为公司储备优秀人才的一个重要的活动。那么互联网公司是如何选拔优秀的候选人呢？其实无非也就是通过几种方法。&lt;/p&gt;
&lt;p&gt;比如这些技术同学来说，考察的通常是他们的技术水准，基础知识以及算法能力，解决问题的能力，当然，公司也会对你的学习效率，工作的态度以及对以后职业的规划都会做一些评估。这些因素都将决定他们是否能够拿到这个offer。&lt;/p&gt;
&lt;p&gt;现在互联网公司这么多，大家参加校园招聘的热情也都特别高涨。那么作为一个学生，如何在这场校园招聘的大战中，幸存下来呢。或者说，如何能够在这场战争中，担任主角攻城拔寨呢。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;http://picturecdn.ejianmedia.com/92bd12202a094c968d93b2264f195a55.jpg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.77&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我觉得很重要的是几个点。作为一个学生，哪个是想明白公司需要你的是什么？其实对于技术同学来，是很容易就会明白的。因为他们的岗位要求上都会写明，需要你有什么样的知识，需要你有什么样的教育背景，什么样的项目，并且有什么成果。&lt;/p&gt;
&lt;p&gt;就拿研发工程师来说。如果你是Java研发，那你肯定是要对Java的技术知识非常熟悉，不同公司可能对这个熟悉程度的要求是不一样的。&lt;/p&gt;
&lt;p&gt;比如阿里可能要求你在家核心技术掌握的非常熟练，对于框架的源码，JDK的源码，都要有所了解，甚至你需要对分布式技术。以及些常用的后端技术，都要有所了解，甚至最好还要有所实践。&lt;/p&gt;
&lt;p&gt;如果你在基础上有所欠缺，或者是在算法上力不从心，你可能可以拿实习经历，项目经历去做一些补充，其实我的算法不算好，所以，我的几段实习经历，也能够很好的弥补这一劣势。&lt;/p&gt;
&lt;p&gt;讲完了公司考察你的基本点，接下来，我想要为一些同学解答一下，如何准备即将开始的校园招聘，我相信，大家其实心中都有一些答案，毕竟现在马上就要七月份了，提前批马上就要开始，如果你们还没有做好准备的话，其实是有点来不及了。&lt;/p&gt;
&lt;p&gt;我倒不是能给大家雪中送炭，只是想给你们锦上添花。第一件事情我要说的是。如何去准备你的简历？我相信你们早就已经有一份属于自己的简历了，并且可能已经修改过几次，也有过一些投递的一些经验，估计会觉得这个简历应该已经差不多了，对吧？&lt;/p&gt;
&lt;p&gt;其实简历是可以继续完善的，毕竟秋招的持续时间大概是从七月到九月，这样两个多月的时间，你的简历是可以一直在完善补充的。就比如你刚开始你先拿这个简历去投递一些小公司，看看人家给你的反馈，然后你可以再针对性的去进行一些修改。&lt;/p&gt;
&lt;p&gt;除此之外，你还可以丰富你的简历，比如您简历上可能没有博客没有GitHub，你可以利用这段时间完善一下这方面的一些空缺，或者你觉得做一些技术点，掌握程度的描述不够到位，你也可以再提炼一些内容。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;http://picturecdn.ejianmedia.com/2be2057d5d9c4a83b00e5935be714bbe.jpg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.668&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在不断的完善简历过程中，你会发现，其实你的面试内容大体都是由简历写的什么来决定的，面试官不会凭空捏造一些面试题。因为他这样子也要花很多的时间，面试官更希望的是你的简历上能够有一些比较出彩的内容，他就可以通过这些内容来提问一些问题，这样子他就会比较轻松。&lt;/p&gt;
&lt;p&gt;说完简历，接下来咱们聊一聊，面试的内容，我也说了，面试的内容很可能都是根据你的简历来决定的，比如你现在上学时，你对Java技术多么多么了解，对于某某样技术的实现多么了解，包括源码级别的实现，你都有所了解。&lt;/p&gt;
&lt;p&gt;这时候你就可以说，你在这方面比较擅长，一般面试的时候你会有一分钟自我介绍的时间，你可以在做自我介绍上说一些这样的话，然后面试官可能就会顺着你的思路继续往下问下去。&lt;/p&gt;
&lt;p&gt;这时候，你会发现，其实主动权是在你自己手上的。你在自我介绍里，把简历上一些你比较擅长的点说出来，这样子面试官就get到你的这些点，他也会按照这些方向来进行提问，这些方向的提问会让你觉得很自在。&lt;/p&gt;
&lt;p&gt;因为这些方向的知识基本上是你准备过的。你可以非常轻松的把这些内容讲好讲清楚，并且这些内容有哪些，有哪些曾经被问过的问题，你可以在接下来面对其他面试官的时候，得做一些其相应的准备，你会发现其实他们问的内容都差不多，能从你这个简历上发掘出来的信息也都差不多。&lt;/p&gt;
&lt;p&gt;所谓熟能生巧，就是这个道理。你不要每次自我介绍都换一种说法，换一换内容，这样子你就相当于每次都会被人家挖出新的问题了，所以你还不如用同样的自我介绍，面试官就大概率可以给你提出一些类似的问题，等你面试次数一多，你会发现这种规律是存在的，要擅长使用这种规律。&lt;/p&gt;
&lt;p&gt;面试说到底最难的我觉得还是算法题。很多人都在问，为什么互联网公司这么喜欢好算法题？原因很简单，这是因为算法题的区分度很大，算法题是真的能体现一个人的智商，一个人的解决问题的能力。但是真的有那么多的程序员都是高智商的人吗？&lt;/p&gt;
&lt;p&gt;我想这是否定的，大部分人都没有那么高的智商，都是平庸的，平凡的码农，你不能要求每个人都有那么高的智商去破解一些高难度的算法题，就好像是去，破解一些困难的数学竞赛题。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;http://picturecdn.ejianmedia.com/fb587172f6384dffb8fe6a177a6e39bd.jpg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.668&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这是同样的道理。那些在学校里经常参加竞赛的同学，可能也就是那些，能够解决算法难题的问题，但这些人毕竟还是少数，而其他绝大部分没有参加算法竞赛或者是数学竞赛的同学，他们仍然是有机会去破解这些题目的。&lt;/p&gt;
&lt;p&gt;因为这些题目，大部分的题型都是你曾经见过的。如果没有，那么说明你刷的题还不够多，你看到需要看两三遍的剑指offer，刷150到200道的LeetCode，并且能够亲自把这些代码写一遍，那么可能这就足够应付大部分的互联网公司的面试了。&lt;/p&gt;
&lt;p&gt;当然了，面试的算法和笔试的算法还是有一定的差距的，笔试题的算法难度会更加的恐怖。应该是地狱级别的反面是上访难度可能只是困难级别的。&lt;/p&gt;
&lt;p&gt;算法面试其实最重要的是思路，你需要告诉别人谁管这道题，你是怎么想的，你要哪些疑问，你可能会怎么样去解决它，如果刚好这道题你曾经有见过你就可以比较好的把这个代码写出来，如果你没有见过，那你可能写半天也写不出个所以然来，那只能大致的告诉面试官你的思路，然后比较简单的实现。&lt;/p&gt;
&lt;p&gt;嗯。说完了算法，如果这几轮面试你都能够脱颖而出的话，是你的技术能力已经得到了比较好的肯定。这时候通常去参加一下HR面试，我想也不会有太大的问题。其实上面的内容都是我去年参加校园招聘总结出来的一些内容，也包括我现在在工作中可能会知道到的一些内容，因为身边有很多人也是新人，然后他们也是经历了校园招聘后加入这个公司。&lt;/p&gt;
&lt;p&gt;可以说能进入互联网大公司的人身上，一定有一些比较出色的地方，要不然他们他们也不可能进到这家公司。我觉得吧，有信心进入互联网大企业的人。他们本身都是非常优秀的。所以，不存在说你很差，但是还能进大公司，或者说你很优秀，但是你却进不了大公司。&lt;/p&gt;
&lt;p&gt;接下来和你们聊一聊校园招聘里的一些坑。或者说是一些潜规则。在校园招聘里的一些坑指的就是，在求职面试过程中没有注意到的一些点，会对你的面试产生一些负面的影响。比如说面试官问你一个问题。如果你不懂，然后你直接就告诉他你不懂，这是一种缺乏思考的表现。或者他给你一个问题，你很快的就给出了结果，缺乏深入的思考，需要面试官多次提醒你你才知道你的问题在哪里。&lt;/p&gt;
&lt;p&gt;这样的情况其实是面试官不想看到的。又或者面试官给你做问题是缺少条件的。你需要自己去咨询面试官到底还有哪些内容，他是没有提供给你的。如果你没有这样去问，可能在这问题完全无法解决，这是考察你一个沟通的能力。&lt;/p&gt;
&lt;p&gt;还有一些潜规则呢主要指在面试流程上的潜规则，这个其实我是很有经验的。比如如果你参加了阿里巴巴的实习生招聘。你你就有那是记录会留在阿里那边，这会直接影响到你的秋季校园招聘，如果你通过了面试，但是没有去实习，你的记录可能会一直留到秋季校园招聘开始。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;http://picturecdn.ejianmedia.com/7d79dad3639349f6921935d1d48189c6.jpg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这会导致你无法参加休息的校园招聘内推。这是非常可怕的一件事情，我当时也遇到了这样的问题。这种的解决办法是我找到了阿里的一个主管，然后通过他进行了内推，和原部门进行流程交接，才最终成功参加了内推。&lt;/p&gt;
&lt;p&gt;校园招聘这些公司流程上的问题，其实是普遍存在于互联网各个行业的，比如说提前批会影响正式招聘。内推才能有机会面试，不内推就没有机会面试。这都是一些你无从考证的潜规则。又比如，每个公司你只能投递一个岗位，只能选择一个部门。&lt;/p&gt;
&lt;p&gt;但事实上，当很多部门没有招满人的时候，他们还是会给你一些机会让你去尝试。所以其实校园招聘对我们来说是一个非常巨大的工程。必须要做好各方面的准备，包括简历上的准备，技术基础的储备，以及对整个校园招聘的过程要有所了解。&lt;/p&gt;
&lt;p&gt;必须要明白。网申，内推，提前批，录取意向书，正式offer、正式录用的整个过程，你必须做好全方面的准备，才能做到不骄不躁，不慌不乱。说了这么多。其实就是想告诉大家，校园招聘对于学生来说是非常重要的。&lt;/p&gt;
&lt;p&gt;也许你的第一家公司会决定你接下来的人生轨迹，就像在不同大学一样，你所经历的事情。所能看到的东西，以及未来前途都会是非常不同的，可能这个影响是非常深远的。上了这么久的学，直接跨越到工作岗位一定是不习惯的，一定是会有阵痛的，但是你必须快速成长。特别是在互联网公司里，追求的就是快速、高效、迭代、极致，你必须遵守他们的游戏规则，才能在这个环境里生存下来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://picturecdn.ejianmedia.com/4934e3e4907b4345a6c1ec12707abb09.png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.04523809523809524&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;420&quot;/&gt;&lt;/p&gt;


&lt;p&gt;推荐阅读：&lt;/p&gt;

&lt;p&gt;一位资深Java的阿里系公司实战面试经验，套路还是面试官的多&lt;/p&gt;



&lt;p&gt;大龄码农的一天&lt;/p&gt;




&lt;p&gt;&lt;img src=&quot;http://picturecdn.ejianmedia.com/3ccce82de14c417eabba9a5daeceb015.png&quot; alt=&quot;&quot; data-ratio=&quot;0.6222222222222222&quot; data-type=&quot;png&quot; data-w=&quot;45&quot;/&gt;你点的每个好看，我都认真当成了喜欢&lt;/p&gt;

</description>
<pubDate>Wed, 10 Jul 2019 15:58:00 +0000</pubDate>
<dc:creator>黄小斜</dc:creator>
<og:description>阅读本文大概需要 10 分钟。 转眼间又到了六月底。马上就要迎来新一年的秋季校园招聘了。这对很多即将毕业的，想要从事互联网行业的同学来说，都是非常重要的一段时间。 在这期间，很多互联网公司将陆续开始校</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xll1025/p/11167413.html</dc:identifier>
</item>
<item>
<title>分布式事务(1)---2PC和3PC理论 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11167025.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11167025.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;&lt;strong&gt;分布式事物基本理论&lt;/strong&gt;:基本遵循CPA理论，采用柔性事物特征，软状态或者最终一致性特点保证分布式事物一致性问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式事物常见解决方案&lt;/strong&gt;:&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;2PC两段提交协议&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3PC三段提交协议(弥补两端提交协议缺点)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCC或者GTS(阿里)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;消息中间件最终一致性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;使用LCN解决分布式事物，理念“LCN并不生产事务,LCN只是本地事务的搬运工”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;一两阶段提交2pc&quot;&gt;&lt;span&gt;一、两阶段提交（2PC）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;两阶段提交又称&lt;strong&gt;2PC&lt;/strong&gt;,2PC是一个非常经典的&lt;code&gt;强一致、中心化的原子提交协议&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里所说的中心化是指协议中有两类节点：一个是中心化&lt;code&gt;协调者节点&lt;/code&gt;（coordinator）和&lt;code&gt;N个参与者节点&lt;/code&gt;（partcipant）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;两个阶段&lt;/code&gt;：第一阶段：&lt;strong&gt;投票阶段&lt;/strong&gt; 和第二阶段：&lt;strong&gt;提交/执行阶段&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;举例&lt;/code&gt; &lt;strong&gt;订单服务A&lt;/strong&gt;，需要调用 &lt;strong&gt;支付服务B&lt;/strong&gt; 去支付，支付成功则处理购物订单为待发货状态，否则就需要将购物订单处理为失败状态。&lt;/p&gt;
&lt;p&gt;那么看2PC阶段是如何处理的&lt;/p&gt;
&lt;h4 id=&quot;第一阶段投票阶段&quot;&gt;1、第一阶段：投票阶段&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201907/1090617-20190710222443794-591603727.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一阶段主要分为3步&lt;/p&gt;
&lt;p&gt;1）&lt;code&gt;事务询问&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;协调者&lt;/strong&gt; 向所有的 &lt;strong&gt;参与者&lt;/strong&gt; 发送&lt;strong&gt;事务预处理请求&lt;/strong&gt;，称之为&lt;strong&gt;Prepare&lt;/strong&gt;，并开始等待各 &lt;strong&gt;参与者&lt;/strong&gt; 的响应。&lt;/p&gt;
&lt;p&gt;2）&lt;code&gt;执行本地事务&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;各个 &lt;strong&gt;参与者&lt;/strong&gt; 节点执行本地事务操作,但在执行完成后并&lt;strong&gt;不会真正提交数据库本地事务&lt;/strong&gt;，而是先向 &lt;strong&gt;协调者&lt;/strong&gt; 报告说：“我这边可以处理了/我这边不能处理”。.&lt;/p&gt;
&lt;p&gt;3）&lt;code&gt;各参与者向协调者反馈事务询问的响应&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果 &lt;strong&gt;参与者&lt;/strong&gt; 成功执行了事务操作,那么就反馈给协调者 &lt;strong&gt;Yes&lt;/strong&gt; 响应,表示事务可以执行,如果没有 &lt;strong&gt;参与者&lt;/strong&gt; 成功执行事务,那么就反馈给协调者 &lt;strong&gt;No&lt;/strong&gt; 响应,表示事务不可以执行。&lt;/p&gt;
&lt;p&gt;第一阶段执行完后，会有两种可能。1、所有都返回Yes. 2、有一个或者多个返回No。&lt;/p&gt;
&lt;h4 id=&quot;第二阶段提交执行阶段成功流程&quot;&gt;2、第二阶段：提交/执行阶段（成功流程）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;成功条件&lt;/code&gt;：所有参与者都返回Yes。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201907/1090617-20190710222454275-1462865655.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二阶段主要分为两步&lt;/p&gt;
&lt;p&gt;​ 1)&lt;code&gt;所有的参与者反馈给协调者的信息都是Yes,那么就会执行事务提交&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;协调者&lt;/strong&gt; 向 &lt;strong&gt;所有参与者&lt;/strong&gt; 节点发出Commit请求.&lt;/p&gt;
&lt;p&gt;​ 2)&lt;code&gt;事务提交&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;参与者&lt;/strong&gt; 收到Commit请求之后,就会正式执行本地事务Commit操作,并在完成提交之后释放整个事务执行期间占用的事务资源。&lt;/p&gt;
&lt;h4 id=&quot;第二阶段提交执行阶段异常流程&quot;&gt;3、第二阶段：提交/执行阶段（异常流程）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;异常条件&lt;/code&gt;：任何一个 &lt;strong&gt;参与者&lt;/strong&gt; 向 &lt;strong&gt;协调者&lt;/strong&gt; 反馈了 &lt;strong&gt;No&lt;/strong&gt; 响应,或者等待超时之后,协调者尚未收到所有参与者的反馈响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201907/1090617-20190710222502868-1587526642.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;异常流程第二阶段也分为两步&lt;/p&gt;
&lt;p&gt;1)&lt;code&gt;发送回滚请求&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;协调者&lt;/strong&gt; 向所有参与者节点发出 &lt;strong&gt;RoollBack&lt;/strong&gt; 请求.&lt;/p&gt;
&lt;p&gt;​ 2)&lt;code&gt;事务回滚&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;参与者&lt;/strong&gt; 接收到RoollBack请求后,会回滚本地事务。&lt;/p&gt;
&lt;h4 id=&quot;pc缺点&quot;&gt;4、2PC缺点&lt;/h4&gt;
&lt;p&gt;通过上面的演示，很容易想到2pc所带来的缺陷&lt;/p&gt;
&lt;p&gt;1）&lt;code&gt;性能问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;无论是在第一阶段的过程中,还是在第二阶段,&lt;strong&gt;所有的参与者资源和协调者资源都是被锁住的&lt;/strong&gt;,只有当所有节点准备完毕，事务 &lt;strong&gt;协调者&lt;/strong&gt; 才会通知进行全局提交，&lt;strong&gt;参与者&lt;/strong&gt; 进行本地事务提交后才会释放资源。这样的&lt;strong&gt;过程会比较漫长，对性能影响比较大&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2）&lt;code&gt;单节点故障&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;strong&gt;协调者&lt;/strong&gt;的重要性，一旦 &lt;strong&gt;协调者&lt;/strong&gt; 发生故障。&lt;strong&gt;参与者&lt;/strong&gt; 会一直阻塞下去。尤其在第二阶段，&lt;strong&gt;协调者&lt;/strong&gt; 发生故障，那么所有的 &lt;strong&gt;参与者&lt;/strong&gt; 还都处于锁定事务资源的状态中，而无法继续完成事务操作。（虽然协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2PC出现单点问题的三种情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1)&lt;code&gt;协调者正常,参与者宕机&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​ 由于 &lt;strong&gt;协调者&lt;/strong&gt; 无法收集到所有 &lt;strong&gt;参与者&lt;/strong&gt; 的反馈，会陷入阻塞情况。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;解决方案&lt;/strong&gt;:引入超时机制,如果协调者在超过指定的时间还没有收到参与者的反馈,事务就失败,向所有节点发送终止事务请求。&lt;/p&gt;
&lt;p&gt;(2)&lt;code&gt;协调者宕机,参与者正常&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​ 无论处于哪个阶段，由于&lt;strong&gt;协调者宕机&lt;/strong&gt;，无法发送提交请求，所有处于执行了操作但是未提交状态的参与者都会陷入阻塞情况.&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;解决方案&lt;/strong&gt;:引入协调者备份,同时协调者需记录操作日志.当检测到协调者宕机一段时间后，协调者备份取代协调者，并读取操作日志，向所有参与者询问状态。&lt;/p&gt;
&lt;p&gt;(3)&lt;code&gt;协调者和参与者都宕机&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1) &lt;strong&gt;发生在第一阶段&lt;/strong&gt;： 因为第一阶段，所有参与者都没有真正执行commit，所以只需重新在剩余的参与者中重新选出一个协调者，新的协调者在重新执行第一阶段和第二阶段就可以了。&lt;/p&gt;
&lt;p&gt;2)&lt;strong&gt;发生在第二阶段 并且 挂了的参与者在挂掉之前没有收到协调者的指令&lt;/strong&gt;。也就是上面的第4步挂了，这是可能协调者还没有发送第4步就挂了。这种情形下，新的协调者重新执行第一阶段和第二阶段操作。&lt;/p&gt;
&lt;p&gt;3)&lt;strong&gt;发生在第二阶段 并且 有部分参与者已经执行完commit操作&lt;/strong&gt;。就好比这里订单服务A和支付服务B都收到&lt;strong&gt;协调者&lt;/strong&gt; 发送的commit信息，开始真正执行本地事务commit,但突发情况，Acommit成功，B确挂了。这个时候目前来讲数据是不一致的。虽然这个时候可以再通过手段让他和协调者通信，再想办法把数据搞成一致的，但是，这段时间内他的数据状态已经是不一致的了！ 2PC 无法解决这个问题。&lt;/p&gt;
&lt;h2 id=&quot;二三阶段提交3pc&quot;&gt;&lt;span&gt;二、三阶段提交(3PC)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;三阶段提交协议（3PC）主要是为了解决两阶段提交协议的阻塞问题，2pc存在的问题是当协作者崩溃时，参与者不能做出最后的选择。因此参与者可能在协作者恢复之前保持阻塞。三阶段提交（Three-phase commit），是二阶段提交（2PC）的改进版本。&lt;/p&gt;
&lt;p&gt;与两阶段提交不同的是，三阶段提交有两个改动点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、 引入超时机制。同时在协调者和参与者中都引入超时机制。
2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，除了引入超时机制之外，&lt;strong&gt;3PC把2PC的准备阶段再次一分为二&lt;/strong&gt;，这样三阶段提交就有&lt;code&gt;CanCommit&lt;/code&gt;、&lt;code&gt;PreCommit&lt;/code&gt;、&lt;code&gt;DoCommit&lt;/code&gt;三个阶段。&lt;/p&gt;
&lt;h4 id=&quot;cancommit阶段&quot;&gt;1、CanCommit阶段&lt;/h4&gt;
&lt;p&gt;之前2PC的一阶段是本地事务执行结束后，最后不Commit,等其它服务都执行结束并返回Yes，由协调者发生commit才真正执行commit。而这里的CanCommit指的是 &lt;strong&gt;尝试获取数据库锁&lt;/strong&gt; 如果可以，就返回Yes。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201907/1090617-20190710222512291-462809105.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这阶段主要分为2步&lt;/p&gt;
&lt;p&gt;&lt;code&gt;事务询问&lt;/code&gt; &lt;strong&gt;协调者&lt;/strong&gt; 向 &lt;strong&gt;参与者&lt;/strong&gt; 发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待 &lt;strong&gt;参与者&lt;/strong&gt; 的响应。&lt;br/&gt;&lt;code&gt;响应反馈&lt;/code&gt; &lt;strong&gt;参与者&lt;/strong&gt; 接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No&lt;/p&gt;
&lt;h4 id=&quot;precommit阶段&quot;&gt;2、PreCommit阶段&lt;/h4&gt;
&lt;p&gt;在阶段一中，如果所有的参与者都返回Yes的话，那么就会进入PreCommit阶段进行事务预提交。这里的&lt;strong&gt;PreCommit阶段&lt;/strong&gt; 跟上面的第一阶段是差不多的，只不过这里 &lt;strong&gt;协调者和参与者都引入了超时机制&lt;/strong&gt; （2PC中只有协调者可以超时，参与者没有超时机制）。&lt;/p&gt;
&lt;h4 id=&quot;docommit阶段&quot;&gt;3、DoCommit阶段&lt;/h4&gt;
&lt;p&gt;这里跟2pc的阶段二是差不多的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;总结&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;相比较2PC而言，3PC对于协调者（&lt;strong&gt;Coordinator&lt;/strong&gt;）和参与者（&lt;strong&gt;Partcipant&lt;/strong&gt;）都设置了超时时间，而2PC只有协调者才拥有超时机制。这解决了一个什么问题呢？&lt;/p&gt;
&lt;p&gt;这个优化点，主要是避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，&lt;/p&gt;
&lt;p&gt;自动进行本地commit从而进行释放资源。而这种机制也侧面降低了整个事务的阻塞时间和范围。&lt;/p&gt;
&lt;p&gt;另外，通过&lt;strong&gt;CanCommit、PreCommit、DoCommit&lt;/strong&gt;三个阶段的设计，相较于2PC而言，多设置了一个&lt;strong&gt;缓冲阶段&lt;/strong&gt;保证了在最后提交阶段之前各参与节点的状态是一致的。&lt;/p&gt;
&lt;p&gt;以上就是3PC相对于2PC的一个提高（相对缓解了2PC中的前两个问题），但是3PC依然没有完全解决数据不一致的问题。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://www.sohu.com/a/290897501_684445&quot;&gt;分布式事务：深入理解什么是2PC、3PC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.jianshu.com/p/0829d8abccdf&quot;&gt;分布式事务、3pc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.cnblogs.com/binyue/p/3678390.html&quot;&gt;对分布式事务及两阶段提交、三阶段提交的理解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://www.cnblogs.com/zcjcsl/p/7989792.html&quot;&gt;分布式理论基础：2PC和3PC&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（上将5）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 10 Jul 2019 14:43:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>分布式事务(1) 2PC和3PC理论 分布式事物基本理论 :基本遵循CPA理论，采用柔性事物特征，软状态或者最终一致性特点保证分布式事物一致性问题。 分布式事物常见解决方案 : 1. 2PC两段提交协</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11167025.html</dc:identifier>
</item>
<item>
<title>每天学点node系列-fs文件系统（续） - 一半水一半冰</title>
<link>http://www.cnblogs.com/jingh/p/11166625.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingh/p/11166625.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;理想如果不向现实做一点点屈服，那么理想也将归于尘土。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;创建目录&quot;&gt;创建目录&lt;/h2&gt;
&lt;h3 id=&quot;异步创建目录&quot;&gt;异步创建目录&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;path&amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
options &amp;lt;Object&amp;gt; | &amp;lt;integer&amp;gt;
  - recursive &amp;lt;boolean&amp;gt; 默认值: false。
  - mode &amp;lt;integer&amp;gt; Windows 上不支持。默认值: 0o777。
callback &amp;lt;Function&amp;gt;
  - err &amp;lt;Error&amp;gt;&amp;lt;/Error&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// fs.mkdir(path[, mode], callback)
var fs = require('fs')
fs.mkdir('sub', function(err){
    if(err) throw err
    console.log('创建目录成功')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
创建目录成功&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;同步创建目录&quot;&gt;同步创建目录&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;path&amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
  - options &amp;lt;Object&amp;gt; | &amp;lt;integer&amp;gt;
  - recursive &amp;lt;boolean&amp;gt; 默认值: false。
mode &amp;lt;integer&amp;gt; Windows 上不支持。默认值: 0o777。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// fs.mkdirSync(path[, mode])
var fs = require('fs')
try{
    fs.mkdirSync('rock')
    console.log('创建目录成功')
}catch(e){
    throw e
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
创建目录成功&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;读取目录&quot;&gt;读取目录&lt;/h2&gt;
&lt;h3 id=&quot;异步读取目录&quot;&gt;异步读取目录&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;path&amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
options &amp;lt;string&amp;gt; | &amp;lt;Object&amp;gt;
  - encoding &amp;lt;string&amp;gt; 默认值: 'utf8'。
  - withFileTypes &amp;lt;boolean&amp;gt; 默认值: false。
callback &amp;lt;Function&amp;gt;
  - err &amp;lt;Error&amp;gt;
  - files &amp;lt;string[]&amp;gt; | &amp;lt;Buffer[]&amp;gt; | &amp;lt;fs.Dirent[]&amp;gt;&amp;lt;/Error&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意： files 是目录中的文件名的数组（不包括 '.' 和 '..'）&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let fs = require('fs')
fs.readdir('./sub', 'utf8', (err, files) =&amp;gt; {
    if (err) console.log(err)
    console.log(files)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
[ '1.css', 'index.html' ]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;同步读取目录&quot;&gt;同步读取目录&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;path &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
options &amp;lt;string&amp;gt; | &amp;lt;Object&amp;gt;
  - encoding &amp;lt;string&amp;gt; 默认值: 'utf8'。设置为 'buffer'，则返回的文件名是 Buffer 对象。
  - withFileTypes &amp;lt;boolean&amp;gt; 默认值: false。 设置为 true，则返回的结果将包含 fs.Dirent 对象。
返回: &amp;lt;string[]&amp;gt; | &amp;lt;Buffer[]&amp;gt; | &amp;lt;fs.Dirent[]&amp;gt;&amp;lt;/boolean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let fs = require('fs')
try {
    let result = fs.readdirSync('./sub', 'utf8')
    console.log(result)
} catch (error) {
    console.log(error)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
[ '1.css', 'index.html' ]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;遍历目录&quot;&gt;遍历目录&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs')
var path = require('path')
var getFilesInDir = function (dir) {
    var results = [path.resolve(dir)]
    var files = fs.readdirSync(dir, 'utf8')
    files.forEach(function (file) {
        file = path.resolve(dir, file)
        var stats = fs.statSync(file)
        if (stats.isFile()) {
            results.push(file)
        } else if (stats.isDirectory()) {
            results = results.concat(getFilesInDir(file))
        }
    })
    return results
}
var files = getFilesInDir('./api');
console.log(files);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：fs.readdirSync()只会读一层，所以需要判断文件类型是否目录，如果是，则进行递归遍历。&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
[ 'C:\\Users\\Administrator\\Desktop\\api',
  'C:\\Users\\Administrator\\Desktop\\api\\config.1.json',
  'C:\\Users\\Administrator\\Desktop\\api\\config.json',
  'C:\\Users\\Administrator\\Desktop\\api\\config16.json',
  'C:\\Users\\Administrator\\Desktop\\api\\integral-consumpte'
...&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改权限&quot;&gt;修改权限&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;path &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
mode &amp;lt;integer&amp;gt;
callback &amp;lt;Function&amp;gt;
  - err &amp;lt;Error&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs')
fs.chmod('1.txt', '777', function (err) {
    if (err) {
        console.log(err)
    } else {
        console.log(&quot;change done&quot;)
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;同步修改所有者&quot;&gt;同步修改所有者&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;path &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
mode &amp;lt;integer&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs')
fs.chmodSync('./1.txt', '777')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;访问权限检测&quot;&gt;访问/权限检测&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;path&amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
    mode &amp;lt;integer&amp;gt; 默认值: fs.constants.F_OK。
    callback &amp;lt;Function&amp;gt;
  - err &amp;lt;Error&amp;gt;&amp;lt;/Error&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;
const fs = require('fs')
const file = '1.txt';
// 检查当前目录中是否存在该文件。
fs.access(file, fs.constants.F_OK, (err) =&amp;gt; {
    console.log(`${file} ${err ? '不存在' : '存在'}`);
});
// 检查文件是否可读。
fs.access(file, fs.constants.R_OK, (err) =&amp;gt; {
    console.log(`${file} ${err ? '不可读' : '可读'}`);
});
// 检查文件是否可写。
fs.access(file, fs.constants.W_OK, (err) =&amp;gt; {
    console.log(`${file} ${err ? '不可写' : '可写'}`);
});
// 检查当前目录中是否存在该文件，以及该文件是否可写。
fs.access(file, fs.constants.F_OK | fs.constants.W_OK, (err) =&amp;gt; {
if (err) {
    console.error(
        `${file} ${err.code === 'ENOENT' ? '不存在' : '只可读'}`);
    } else {
        console.log(`${file} 存在，且它是可写的`);
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$ node 1.js
1.txt 存在
1.txt 可读
1.txt 可写
1.txt 存在，且它是可写的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不建议在调用 fs.open()、 fs.readFile() 或 fs.writeFile() 之前使用 fs.access() 检查文件的可访问性。 这样做会引入竞态条件，因为其他进程可能会在两个调用之间更改文件的状态。 相反，应该直接打开、读取或写入文件，如果文件无法访问则处理引发的错误。&lt;/p&gt;
&lt;h3 id=&quot;写入不推荐&quot;&gt;写入（不推荐）&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;
const fs = require('fs')
const file = '1.txt'
fs.access(file, (err) =&amp;gt; {
    if (!err) {
        console.error(`${file} 已存在`)
        return
    }
    fs.open(file, 'wx', (err, fd) =&amp;gt; {
        if (err) throw err
        writeMyData(fd)
    })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;写入推荐&quot;&gt;写入（推荐）&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const fs = require('fs')
fs.open('1.txt', 'wx', (err, fd) =&amp;gt; {
    if (err) {
        if (err.code === 'EEXIST') {
            console.error('1.txt 已存在')
            return
        }
        throw err
    }
    writeMyData(fd)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;同步访问权限检测&quot;&gt;同步访问/权限检测&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;path&amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
mode &amp;lt;integer&amp;gt; 默认值: fs.constants.F_OK。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意： 如果可访问性检查失败，则抛出 Error。 否则，该方法将返回 undefined。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;try {
    fs.accessSync('./1.txt', fs.constants.R_OK | fs.constants.W_OK)
    console.log('可以读写')
} catch (err) {
    console.error('无权访问')
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;删除目录&quot;&gt;删除目录&lt;/h2&gt;
&lt;h3 id=&quot;异步删除目录&quot;&gt;异步删除目录&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;path&amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;
callback &amp;lt;Function&amp;gt;
  - err &amp;lt;Error&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：在文件（而不是目录）上使用 fs.rmdir() 会导致在 Windows 上出现 ENOENT 错误、在 POSIX 上出现 ENOTDIR 错误。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs')

fs.rmdir('./rock', function(err){
    if(err) throw err
    console.log('目录删除成功')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;同步删除目录&quot;&gt;同步删除目录&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;path &amp;lt;string&amp;gt; | &amp;lt;Buffer&amp;gt; | &amp;lt;URL&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs')
fs.rmdirSync('./rock')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实用场景&quot;&gt;实用场景&lt;/h2&gt;
&lt;h3 id=&quot;文件锁&quot;&gt;文件锁&lt;/h3&gt;
&lt;p&gt;使用独占标记创建锁文件&lt;/p&gt;
&lt;p&gt;fs模块为所有需要打开文件的方法提供了一个x标记。这告诉操作系统这个文件应该以独占模式打开（O_EXCL）。当使用这个方法时，若这个文件存在，文件不能被打开。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;文件数据库&quot;&gt;文件数据库&lt;/h3&gt;
&lt;p&gt;策略是不断的追加记录，在处理的时候不断的覆盖原始记录。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var fs = require('fs')
var EventEmitter = require('events').EventEmitter
var Database = function (path) {
    this.path = path
    // 数据库key/value映射表
    this._records = Object.create(null)
    this._writeStream = fs.createWriteStream(this.path, {
        encoding: 'utf8',
        flags: 'a'
    })
    this._load()
}
// 继承自EventEmitter，让它有可以监听事件、传递事件的功能
Database.prototype = Object.create(EventEmitter.prototype)
Database.prototype._load = function () {
    var stream = fs.createReadStream(this.path, { encoding: 'utf8' })
    var database = this
    var data = ''
    // 当输入流准备好时触发
    stream.on('readable', function () {
        data += stream.read()
        // 每一行是一组数据
        var records = data.split('\n')
        data = records.pop()
        for (var i = 0; i &amp;lt; records.length; i++) {
            try {
                var record = JSON.parse(records[i])
                if (record.value == null) {
                    delete database._records[record.key]
                } else {
                    database._records[record.key] = record.value
                }
            } catch (e) {
                database.emit('error', 'found invalid record:', records[i])
            }
        }
    })
    // 流处理完后发送load事件给消费者
    stream.on('end', function () {
        database.emit('load')
    })
}
let database = new Database('./sub/a.txt')
database._writeStream.write('beep')&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 10 Jul 2019 13:27:00 +0000</pubDate>
<dc:creator>一半水一半冰</dc:creator>
<og:description>理想如果不向现实做一点点屈服，那么理想也将归于尘土。 创建目录 异步创建目录 执行结果： 同步创建目录 执行结果： 读取目录 异步读取目录 注意： files 是目录中的文件名的数组（不包括 '.' </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jingh/p/11166625.html</dc:identifier>
</item>
<item>
<title>SQLServer性能优化之---数据库级日记监控 - 鲲逸鹏</title>
<link>http://www.cnblogs.com/dotnetcrazy/p/11166516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnetcrazy/p/11166516.html</guid>
<description>&lt;p&gt;上节回顾：&lt;a href=&quot;https://www.cnblogs.com/dotnetcrazy/p/11029323.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/dotnetcrazy/p/11029323.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;sqlserver监控&quot;&gt;4.6.6.SQLServer监控&lt;/h3&gt;
&lt;p&gt;脚本示意：&lt;a href=&quot;https://github.com/lotapp/BaseCode/tree/master/database/SQL/SQLServer&quot; class=&quot;uri&quot;&gt;https://github.com/lotapp/BaseCode/tree/master/database/SQL/SQLServer&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：这些脚本都是我以前用SQLServer手写的，参考即可（现在用MySQL，下次也整理一下）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前写SQLServer监控系列文章因为换环境断篇了，只是简单演示了下基础功能，现在准备写&lt;code&gt;MySQL&lt;/code&gt;监控相关内容了，于是补了下：&lt;/p&gt;
&lt;blockquote readability=&quot;0.17821782178218&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/dunitian/p/6022967.html&quot;&gt;SQLServer性能优化之---数据库级日记监控&lt;/a&gt;&lt;/strong&gt;：&lt;a href=&quot;https://www.cnblogs.com/dunitian/p/6022967.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/dunitian/p/6022967.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在说监控前你可以先看下&lt;a href=&quot;https://mp.weixin.qq.com/s/WWdDSNj_19RVCZJMGxhMWA&quot;&gt;数据库发邮件&lt;/a&gt;：&lt;a href=&quot;https://www.cnblogs.com/dunitian/p/6022826.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/dunitian/p/6022826.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;应用：&lt;strong&gt;一般就是设置个定时任务，把耗时SQL信息或者错误信息通过邮件的方式及时预警&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好处就太多了，eg：客户出错如果是数据库层面，那瞬间就可以场景重放（PS：等客户找会降低业绩）&lt;/p&gt;
&lt;p&gt;以往都是程序的&lt;code&gt;try&lt;/code&gt;+&lt;code&gt;catch&lt;/code&gt;来捕获错误，但数据库定时任务之类的出错程序是捕获不到的，所以就需要数据库层面的监控了&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：开发的时候通过&lt;code&gt;SQLServer Profiler&lt;/code&gt;来监控&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先说说本质吧：SQLServer2012的XEVENT机制已经完善，eg：常用的扩展事件&lt;strong&gt;&lt;code&gt;error_reported&lt;/code&gt;就可以在错误的时候通过邮件来通知管理员了&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：扩展事件性能较高，而且比较轻量级&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PS：&lt;strong&gt;SQLServer的监控大体思路三步走：&lt;code&gt;发邮件&lt;/code&gt;，&lt;code&gt;事件监控&lt;/code&gt;，&lt;code&gt;定时执行&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;发送邮件&quot;&gt;4.6.6.1 发送邮件&lt;/h4&gt;
&lt;p&gt;这个之前讲过，这边就再说下SQL的方式：&lt;/p&gt;
&lt;h5 id=&quot;配置发件人邮箱&quot;&gt;1.配置发件人邮箱&lt;/h5&gt;
&lt;p&gt;这个配置一次即可，&lt;strong&gt;以后使用就可以直接通过配置名发邮件&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;--开启发邮件功能
exec sp_configure 'show advanced options',1
reconfigure with override
go
exec sp_configure 'database mail xps',1
reconfigure with override
go

--创建邮件帐户信息
exec msdb.dbo.sysmail_add_account_sp
  @account_name ='dunitian',                     -- 邮件帐户名称
  @email_address ='xxx@163.com',                 -- 发件人邮件地址
  @display_name ='SQLServer2014_192.168.36.250', -- 发件人姓名
  @MAILSERVER_NAME = 'smtp.163.com',             -- 邮件服务器地址
  @PORT =25,                                     -- 邮件服务器端口
  @USERNAME = 'xxx@163.com',                     -- 用户名
  @PASSWORD = '邮件密码或授权码'                 -- 密码（授权码）
GO

--数据库配置文件
exec msdb.dbo.sysmail_add_profile_sp
  @profile_name = 'SQLServer_DotNetCrazy',       -- 配置名称
  @description = '数据库邮件配置文件'            -- 配置描述
go

--用户和邮件配置文件相关联
exec msdb.dbo.sysmail_add_profileaccount_sp
  @profile_name = 'SQLServer_DotNetCrazy',     -- 配置名称
  @account_name = 'dunitian',                  -- 邮件帐户名称
  @sequence_number = 1                         -- account 在 profile 中顺序（默认是1）
go
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;发生预警邮箱&quot;&gt;2.发生预警邮箱&lt;/h5&gt;
&lt;p&gt;同样我只演示SQL的方式，图形化的方式可以看我以前写的文章：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 发邮件测试
exec msdb.dbo.sp_send_dbmail
@profile_name = 'SQLServer_DotNetCrazy',         --配置名称
@recipients = 'xxx@qq.com',                   --收件邮箱
@body_format = 'HTML',                         --内容格式
@subject = '文章标题',                         --文章标题
@body = '邮件内容&amp;lt;br/&amp;gt;&amp;lt;h2&amp;gt;This is Test&amp;lt;/h2&amp;gt;...' --邮件内容&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201907/1127869-20190710092137832-648681692.png&quot; alt=&quot;06-10/1.mail.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;邮件查询相关&quot;&gt;3.邮件查询相关&lt;/h5&gt;
&lt;p&gt;主要用途其实就是出错排查：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 查询相关
select * from msdb.dbo.sysmail_allitems     --查看所有邮件消息
select * from msdb.dbo.sysmail_mailitems    --查看邮件消息（更多列）

select * from msdb.dbo.sysmail_sentitems    --查看已发送的消息
select * from msdb.dbo.sysmail_faileditems  --失败状态的消息
select * from msdb.dbo.sysmail_unsentitems  --看未发送的消息

select * from msdb.dbo.sysmail_event_log    --查看记录日记&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;监控实现&quot;&gt;4.6.6.2.监控实现&lt;/h4&gt;
&lt;p&gt;会了邮件的发送，那下面就是监控了&lt;/p&gt;
&lt;h5 id=&quot;图形化演示&quot;&gt;1.图形化演示&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;不推荐使用图形化的方式，但可以来理解扩展事件的监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.新建一个会话向导（熟悉后可以直接新建会话）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190709113824963-184950117.png&quot; alt=&quot;1.新建会话向导.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190709113839093-2043533499.png&quot; alt=&quot;1.新建会话向导2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.设置需要捕获的扩展事件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190709113847118-1849537509.png&quot; alt=&quot;2.设置需要捕获的扩展事件.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.这边捕获的全局字段和左边SQL是一样的（截图全太麻烦了，所以偷个懒，后面会说怎么生成左边的核心SQL）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190710202014593-1923871035.png&quot; alt=&quot;3.捕获的全局字段.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.自己根据服务器性能设置一个合理的值（IO、内存、CPU）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190709114107562-436697123.png&quot; alt=&quot;4.设置.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.生成核心SQL（我们图形化的目的就是生成核心SQL，后面可以根据这个SQL自己扩展）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190709114159568-1118574816.png&quot; alt=&quot;5.生成核心SQL.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.核心代码如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190709114233197-2051660041.png&quot; alt=&quot;6.核心代码.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.启动会话后一个简单的扩展事件监控就有了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190709114247514-105984255.png&quot; alt=&quot;7.启动会话.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8.SQLServer提供了查看方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190709114556607-442089908.png&quot; alt=&quot;8.查看.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9.日志可以自己查下&lt;code&gt;xxx\Microsoft SQL Server\MSSQL12.MSSQLSERVER\MSSQL\Log&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190709114642900-1128124868.png&quot; alt=&quot;9.日志.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h5 id=&quot;sql的方式&quot;&gt;2.SQL的方式&lt;/h5&gt;
&lt;p&gt;上面只是过家家，主要目的就是让大家知道核心SQL是怎么来的，凭什么这么写&lt;/p&gt;
&lt;p&gt;下面就来个制定化监控：&lt;/p&gt;
&lt;p&gt;先截图演示下各个核心点，然后贴一个我封装的存储过程附件&lt;/p&gt;
&lt;p&gt;1.扩展事件相关的核心代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190710202909085-194543718.png&quot; alt=&quot;1.扩展事件相关的核心代码.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.内存中数据存储到临时表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190710203015566-1779795363.png&quot; alt=&quot;2.内存中数据存储到临时表.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.临时表中的数据存储到自己建立的表中&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我抛一个课后小问给大家：为什么先存储在临时表中？（提示：效率）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190710203218702-372682658.png&quot; alt=&quot;3.临时表中的数据存储到自己建立的表中.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.发送监控提醒的邮件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190710203500003-1349896179.png&quot; alt=&quot;4.发送监控提醒的邮件.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.看看数据库层面多了什么：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190710204033110-148118196.png&quot; alt=&quot;5.看看数据库层面.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.来个测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190710204128374-1279485990.png&quot; alt=&quot;6.测试.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.效果（可以自己美化）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/658978/201907/658978-20190710204254347-869855125.png&quot; alt=&quot;7.效果.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;sql附录&quot;&gt;SQL附录&lt;/h5&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 切换到需要监控的数据库
USE [dotnetcrazy]
GO

--收集服务器上逻辑错误的信息
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
GO

-- 自定义的错误信息表
IF OBJECT_ID('log_error_message') IS NULL
BEGIN
    CREATE TABLE [dbo].[log_error_message]
    (
    [login_message_id] [uniqueidentifier] NULL CONSTRAINT [DF__PerfLogic__Login__7ACA4E21] DEFAULT (newid()),
    [start_time] [datetime] NULL,
    [database_name] [nvarchar] (128) COLLATE Chinese_PRC_CI_AS NULL,
    [message] [nvarchar] (max) COLLATE Chinese_PRC_CI_AS NULL,
    [sql_text] [nvarchar] (max) COLLATE Chinese_PRC_CI_AS NULL,
    [alltext] [nvarchar] (max) COLLATE Chinese_PRC_CI_AS NULL,
    -- [worker_address] [nvarchar] (1000) COLLATE Chinese_PRC_CI_AS NULL,
    [username] [nvarchar] (1000) COLLATE Chinese_PRC_CI_AS NULL,
    [client_hostname] [nvarchar] (1000) COLLATE Chinese_PRC_CI_AS NULL,
    [client_app_name] [nvarchar] (1000) COLLATE Chinese_PRC_CI_AS NULL
    ) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
END
GO

-- 创建存储过程
CREATE PROCEDURE [dbo].[event_error_monitor]
AS
    IF NOT EXISTS( SELECT 1 FROM sys.dm_xe_sessions dxs(NOLOCK) WHERE name = 'event_error_monitor') -- 不存在就创建EVENT
        -- 创建扩展事件，并把数据放入内存中
        BEGIN
            CREATE EVENT session event_error_monitor on server
            ADD EVENT sqlserver.error_reported -- error_reported扩展事件
            (
            ACTION -- 返回结果
            (
            sqlserver.session_id, -- 会话id
            sqlserver.plan_handle, -- 计划句柄，可用于检索图形计划
            sqlserver.tsql_stack, -- T-SQ堆栈信息
            package0.callstack, -- 当前调用堆栈
            sqlserver.sql_text, -- 遇到错误的SQL查询
            sqlserver.username, -- 用户名
            sqlserver.client_app_name, -- 客户端应用程序名称
            sqlserver.client_hostname, -- 客户端主机名
            -- sqlos.worker_address, -- 当前任务执行时间
            sqlserver.database_name -- 当前数据库名称
            )
            WHERE severity &amp;gt;= 11 AND Severity &amp;lt;=16 -- 指定用户级错误
            )
            ADD TARGET package0.ring_buffer -- 临时放入内存中
            WITH (max_dispatch_latency=1seconds)

            -- 启动监控事件
            ALTER EVENT SESSION event_error_monitor on server state = START
        END
    ELSE
        -- 存储过程已经存在就把数据插入表中
        BEGIN
            -- 将内存中已经收集到的错误信息转存到临时表中（方便处理）
            SELECT
                DATEADD(hh,
                        DATEDIFF(hh, GETUTCDATE(), CURRENT_TIMESTAMP),
                        n.value('(event/@timestamp)[1]', 'datetime2')) AS [timestamp],
                n.value('(event/action[@name=&quot;database_name&quot;]/value)[1]', 'nvarchar(128)') AS [database_name],
                n.value('(event/action[@name=&quot;sql_text&quot;]/value)[1]', 'nvarchar(max)') AS [sql_text],
                n.value('(event/data[@name=&quot;message&quot;]/value)[1]', 'nvarchar(max)') AS [message],
                n.value('(event/action[@name=&quot;username&quot;]/value)[1]', 'nvarchar(max)') AS [username],
                n.value('(event/action[@name=&quot;client_hostname&quot;]/value)[1]', 'nvarchar(max)') AS [client_hostname],
                n.value('(event/action[@name=&quot;client_app_name&quot;]/value)[1]', 'nvarchar(max)') AS [client_app_name],
                n.value('(event/action[@name=&quot;tsql_stack&quot;]/value/frames/frame/@handle)[1]', 'varchar(max)') AS [tsql_stack],
                n.value('(event/action[@name=&quot;tsql_stack&quot;]/value/frames/frame/@offsetStart)[1]', 'int') AS [statement_start_offset],
                n.value('(event/action[@name=&quot;tsql_stack&quot;]/value/frames/frame/@offsetEnd)[1]', 'int') AS [statement_end_offset]
            into #error_monitor -- 临时表
            FROM
            (    SELECT td.query('.') as n
                FROM
                (
                    SELECT CAST(target_data AS XML) as target_data
                    FROM sys.dm_xe_sessions AS s
                    JOIN sys.dm_xe_session_targets AS t
                        ON t.event_session_address = s.address
                    WHERE s.name = 'event_error_monitor'
                    --AND t.target_name = 'ring_buffer'
                ) AS sub
                CROSS APPLY target_data.nodes('RingBufferTarget/event') AS q(td)
            ) as TAB

            -- 把数据存储到自己新建的表中（有SQL语句的直接插入到表中）
            INSERT INTO log_error_message(start_time,database_name,message,sql_text,alltext,username,client_hostname,client_app_name)
            SELECT TIMESTAMP,database_name,[message],sql_text,'',username,client_hostname,client_app_name
            FROM #error_monitor as a
            WHERE a.sql_text != '' --AND client_app_name !='Microsoft SQL Server Management Studio - 查询'
            AND a.MESSAGE NOT LIKE '找不到会话句柄%' AND a.MESSAGE NOT LIKE '%SqlQueryNotification%' --排除server broker
            AND a.MESSAGE NOT LIKE '远程服务已删除%'

            -- 插入应用执行信息（没有SQL的语句通过句柄查询下SQL）
            INSERT INTO log_error_message(start_time,database_name,message,sql_text,alltext,username,client_hostname,client_app_name)
            SELECT TIMESTAMP,database_name,[message],
            SUBSTRING(qt.text,a.statement_start_offset/2+1,
                        (case when a.statement_end_offset = -1
                        then DATALENGTH(qt.text)
                        else a.statement_end_offset end -a.statement_start_offset)/2 + 1) sql_text,qt.text alltext,
            username,client_hostname,client_app_name
            FROM #error_monitor as a
            CROSS APPLY sys.dm_exec_sql_text(CONVERT(VARBINARY(max),a.tsql_stack,1)) qt -- 通过句柄查询具体的SQL语句
            WHERE a.sql_text IS NULL AND tsql_stack != '' --AND client_app_name = '.Net SqlClient Data Provider'

            DROP TABLE #error_monitor -- 删除临时表

            --重启清空
            ALTER EVENT SESSION event_error_monitor ON SERVER STATE = STOP
            ALTER EVENT SESSION event_error_monitor on server state = START
        END

    -- 美化版预警邮箱
    DECLARE @body_html VARCHAR(max)
    set @body_html = '&amp;lt;table style=&quot;width:100%&quot; cellspacing=&quot;0&quot;&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td colspan=&quot;6&quot; align=&quot;center&quot; style=&quot;font-weight:bold;color:red&quot;&amp;gt;数据库错误监控&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;'
    set @body_html = @body_html + '&amp;lt;tr style=&quot;text-align: left;&quot;&amp;gt;&amp;lt;th&amp;gt;运行时间&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;数据库&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;发生错误的SQL语句&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;消息&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;用户名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;应用&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;应用程序名&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;'
    -- 格式处理（没内容就空格填充）
    select @body_html = @body_html + '&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;'
        + case (isnull(start_time, '')) when '' then '&amp;amp;nbsp;' else convert(varchar(20), start_time, 120) end + '&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;'
        + case (isnull(database_name, '')) when '' then '&amp;amp;nbsp;' else database_name end + '&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;'
        + case (isnull(sql_text, '')) when '' then '&amp;amp;nbsp;' else sql_text end + '&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;'
        + case (isnull(message, '')) when '' then '&amp;amp;nbsp;' else message end + '&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;'
        + case (isnull(username, '')) when '' then '&amp;amp;nbsp;' else username end + '&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;'
        + case (isnull(client_hostname, '')) when '' then '&amp;amp;nbsp;' else client_hostname end + '&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;'
        + case (isnull(client_app_name, '')) when '' then '&amp;amp;nbsp;' else client_app_name end + '&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;'
    from (
             select start_time, database_name,sql_text, message, username, client_hostname, client_app_name
             from [dbo].[log_error_message]
             where start_time &amp;gt;= dateadd(hh,-2,getdate()) -- 当前时间 - 定时任务的时间间隔（2h）
               and client_app_name != 'Microsoft SQL Server Management Studio - 查询' -- and client_hostname in('')
         ) as temp_message
    set @body_html= @body_html+'&amp;lt;/table&amp;gt;'

    -- 发送警告邮件
    exec msdb.dbo.sp_send_dbmail
    @profile_name = 'SQLServer_DotNetCrazy',         --配置名称
    @recipients = 'xxxxx@qq.com',                  --收件邮箱
    @body_format = 'HTML',                           --内容格式
    @subject = '数据库监控通知',                       --文章标题
    @body = @body_html --邮件内容
go
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下节预估：定时任务、完整版监控&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PS：估计先得更八字的文章（拖太久）然后更完SQLServer更MySQL，等MySQL监控更完会说下备份与恢复，接着我们开架构篇（MyCat系列先不讲放在Redis和爬虫系列的后面）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;晚点在下面补上&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jul 2019 13:07:00 +0000</pubDate>
<dc:creator>鲲逸鹏</dc:creator>
<og:description>上节回顾： 4.6.6.SQLServer监控 脚本示意： PS：这些脚本都是我以前用SQLServer手写的，参考即可（现在用MySQL，下次也整理一下） 之前写SQLServer监控系列文章因为换</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dotnetcrazy/p/11166516.html</dc:identifier>
</item>
<item>
<title>使用SSH+SFTP操作终端全解析，告别XShell - 薛勤</title>
<link>http://www.cnblogs.com/yueshutong/p/11166377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/11166377.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;1.前言&lt;/h2&gt;
&lt;p&gt;在Windows系统下操作远程服务器的方式很多，比如XShell+XFTP组合，亦或是PuTTY+WinSCP组合，但在Mac系统下登陆远程服务器，并没有这些工具供我们使用。相比较而言，在Mac下更多的是依赖终端输入SSH命令登陆远程服务器。&lt;/p&gt;
&lt;p&gt;使用SSH命令行的好处就是可以近距离接触底层，用的越多，用的越溜，对SSH的原理就越了解。相反，使用现成的SSH工具（PuTTY、XShell），我们其实并不会有涉及使用ssh命令的机会，对大多数人而言，怕是只知道最基本的&lt;code&gt;ssh root@ip&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;本文将带大家了解ssh的原理与使用技巧，帮助更多终端爱好者更方便更随心所欲的使用终端。&lt;/p&gt;
&lt;h2 id=&quot;ssh是什么&quot;&gt;2.SSH是什么&lt;/h2&gt;
&lt;p&gt;SSH服务其实是一个守护进程(demon)，系统后台会监听客户端的连接，ssh服务端的进程名为sshd，负责实时监听客户端的请求(IP 22端口)，包括公共秘钥等交换等信息。SSH服务端由2部分组成： openssh(提供ssh服务)、openssl(提供加密的程序)。&lt;/p&gt;
&lt;h2 id=&quot;对称加密和非对称加密&quot;&gt;3.对称加密和非对称加密&lt;/h2&gt;
&lt;p&gt;在学习SSH的工作机制之前，我们需要了解对称加密和非对称加密的原理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对称加密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓对称加密，是采用对称密码编码技术的加密措施，它的特点是文件加密和解密都是使用相同的密钥。&lt;/p&gt;
&lt;p&gt;这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比DES的加密性好，而且对计算机功能要求也没有那么高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非对称加密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。&lt;/p&gt;
&lt;p&gt;公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。&lt;/p&gt;
&lt;p&gt;因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。&lt;/p&gt;
&lt;h2 id=&quot;ssh如何工作&quot;&gt;3.SSH如何工作&lt;/h2&gt;
&lt;p&gt;了解了对称加密和非对称加密是什么之后，再来了解SSH如何使用非对称加密技术，大致流程如下：&lt;/p&gt;
&lt;p&gt;在服务器启动的时候会产生一个密钥(也就是768bit公钥)，本地的ssh客户端发送连接请求到ssh服务器，服务器检查连接点客户端发送的数据和IP地址，确认合法后发送密钥(768bits公钥)给客户端，此时客户端将本地私钥(256bit)和服务器的公钥(768bit)结合成密钥对key(1024bit)，发回给服务器端，服务端利用自己的私钥解密，读取出客户端的本地私钥，建立连接通过key-pair数据传输，在此之后，服务端与客户端就愉快的使用客户端私钥进行沟通。&lt;/p&gt;
&lt;h2 id=&quot;ssh命令详解&quot;&gt;3.SSH命令详解&lt;/h2&gt;
&lt;p&gt;SSH命令最简单的用法只需要指定用户名和主机名参数即可，主机名可以是 IP 地址或者域名。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh root@192.168.0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;指定端口号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SSH 默认连接到目标主机的 22 端口上，我们可以使用 -p 选项指定端口号。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh -p 22 root@192.168.0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;追加命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 SSH 在远程主机执行一条命令并显示到本地，然后继续本地工作，只需要直接连接并在后面加上要执行的命令。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh -p 22 root@192.168.0.1 ls -l&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;图形界面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在远程主机运行一个图形界面的程序，只需使用SSH的-X选项，然后主机就会开启 X11转发功能。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh -X 22 root@192.168.0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;绑定源地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的客户端有多于两个以上的 IP 地址，你就不可能分得清楚在使用哪一个 IP 连接到 SSH 服务器。为了解决这种情况，我们可以使用 -b 选项来指定一个IP 地址。这个 IP 将会被使用做建立连接的源地址。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh -b 192.168.0.200 root@192.168.0.103&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对所有数据请求压缩&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 -C 选项，所有通过 SSH 发送或接收的数据将会被压缩，并且仍然是加密的。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh -C root@192.168.0.103&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;打开调试模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为某些原因，我们想要追踪调试我们建立的 SSH 连接情况。SSH 提供的 -v 选项参数正是为此而设的。其可以看到在哪个环节出了问题。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh -v root@192.168.0.103&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ssh免密登陆&quot;&gt;4.SSH免密登陆&lt;/h2&gt;
&lt;p&gt;通过SSH命令登陆远程服务器需要手动的每次输入密码，解决这个问题其实非常简单，通过 ssh-keygen 生成本地公钥和私钥，将公钥Copy到远程服务器就可以。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.构建 SSH 密钥对&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 ssh-keygen -t +算法名，现在大多数都使用 RSA 或者 DSA 算法。&lt;/p&gt;
&lt;p&gt;如果你在安装Git时已经做过此步骤，那么忽略这一步即可。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh-keygen -t rsa&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.拷贝本地公钥给远程服务器&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh-copy-id root@192.168.25.110 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以通过参数 -i 指定公钥文件&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh-copy-id -i id_dsa.pub omd@192.168.25.110&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.查看是否已经添加了对应主机的密钥&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 -F 选项&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh-keygen -F 192.168.0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.删除主机密钥&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用-R选项，也可以在 ~/.ssh/known_hosts 文件中手动删除&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ssh-keygen -R 192.168.0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何配置-ssh&quot;&gt;5.如何配置 SSH&lt;/h2&gt;
&lt;p&gt;SSH 的配置文件在 /etc/ssh/sshd_config 中，你可以看到端口号，空闲超时时间等配置项。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cat /etc/ssh/sshd_config&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;/etc/ssh/sshd_config 配置文件详细说明&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;#############1. 关于 SSH Server 的整体设定##############
#Port 22    
##port用来设置sshd监听的端口，为了安全起见，建议更改默认的22端口为5位以上陌生端口
#Protocol 2,1
Protocol 2
##设置协议版本为SSH1或SSH2，SSH1存在漏洞与缺陷，选择SSH2
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress用来设置sshd服务器绑定的IP地址
##监听的主机适配卡，举个例子来说，如果您有两个 IP， 分别是 192.168.0.11 及 192.168.2.20 ，那么只想要
###开放 192.168.0.11 时，就可以设置为：ListenAddress 192.168.0.11
####表示只监听来自 192.168.0.11 这个 IP 的SSH联机。如果不使用设定的话，则预设所有接口均接受 SSH

#############2. 说明主机的 Private Key 放置的档案##########　　　　　　　　　　　　　　　　　
#ListenAddress ::
##HostKey用来设置服务器秘钥文件的路径
# HostKey for protocol version 1
#HostKey /etc/ssh/ssh_host_key
##设置SSH version 1 使用的私钥

# HostKeys for protocol version 2
#HostKey /etc/ssh/ssh_host_rsa_key
##设置SSH version 2 使用的 RSA 私钥

#HostKey /etc/ssh/ssh_host_dsa_key
##设置SSH version 2 使用的 DSA 私钥


#Compression yes　　　　　　
##设置是否可以使用压缩指令

# Lifetime and size of ephemeral version 1 server key
#KeyRegenerationInterval 1h
##KeyRegenerationInterval用来设置多长时间后系统自动重新生成服务器的秘钥，
###（如果使用密钥）。重新生成秘钥是为了防止利用盗用的密钥解密被截获的信息。

#ServerKeyBits 768
##ServerKeyBits用来定义服务器密钥的长度
###指定临时服务器密钥的长度。仅用于SSH-1。默认值是 768(位)。最小值是 512 。


# Logging
# obsoletes QuietMode and FascistLogging
#SyslogFacility AUTH
SyslogFacility AUTHPRIV
##SyslogFacility用来设定在记录来自sshd的消息的时候，是否给出“facility code”

#LogLevel INFO
##LogLevel用来设定sshd日志消息的级别


#################3.安全认证方面的设定################
#############3.1、有关安全登录的设定###############
# Authentication:
##限制用户必须在指定的时限内认证成功，0 表示无限制。默认值是 120 秒。

#LoginGraceTime 2m
##LoginGraceTime用来设定如果用户登录失败，在切断连接前服务器需要等待的时间，单位为妙

#PermitRootLogin yes
##PermitRootLogin用来设置能不能直接以超级用户ssh登录，root远程登录Linux很危险，建议注销或设置为no

#StrictModes yes
##StrictModes用来设置ssh在接收登录请求之前是否检查用户根目录和rhosts文件的权限和所有权，建议开启
###建议使用默认值&quot;yes&quot;来预防可能出现的低级错误。

#RSAAuthentication yes
##RSAAuthentication用来设置是否开启RSA密钥验证，只针对SSH1

#PubkeyAuthentication yes
##PubkeyAuthentication用来设置是否开启公钥验证，如果使用公钥验证的方式登录时，则设置为yes

#AuthorizedKeysFile     .ssh/authorized_keys
##AuthorizedKeysFile用来设置公钥验证文件的路径，与PubkeyAuthentication配合使用,默认值是&quot;.ssh/authorized_keys&quot;。
###该指令中可以使用下列根据连接时的实际情况进行展开的符号： %% 表示'%'、%h 表示用户的主目录、%u 表示该用户的用户名
####经过扩展之后的值必须要么是绝对路径，要么是相对于用户主目录的相对路径。

 
#############3.2、安全验证的设定###############
# For this to work you will also need host keys in /etc/ssh/ssh_known_hosts
#RhostsRSAAuthentication no
##是否使用强可信主机认证(通过检查远程主机名和关联的用户名进行认证)。仅用于SSH-1。
###这是通过在RSA认证成功后再检查 ~/.rhosts 或 /etc/hosts.equiv 进行认证的。出于安全考虑，建议使用默认值&quot;no&quot;。

# similar for protocol version 2
#HostbasedAuthentication no
##这个指令与 RhostsRSAAuthentication 类似，但是仅可以用于SSH-2。

# Change to yes if you don't trust ~/.ssh/known_hosts for
# RhostsRSAAuthentication and HostbasedAuthentication

#IgnoreUserKnownHosts no
##IgnoreUserKnownHosts用来设置ssh在进行RhostsRSAAuthentication安全验证时是否忽略用户的“/$HOME/.ssh/known_hosts”文件
# Don't read the user's ~/.rhosts and ~/.shosts files

#IgnoreRhosts yes
##IgnoreRhosts用来设置验证的时候是否使用“~/.rhosts”和“~/.shosts”文件

# To disable tunneled clear text passwords, change to no here!
#PasswordAuthentication yes
##PasswordAuthentication用来设置是否开启密码验证机制，如果用密码登录系统，则设置yes

#PermitEmptyPasswords no
#PermitEmptyPasswords用来设置是否允许用口令为空的账号登录系统，设置no

#PasswordAuthentication yes
##是否允许使用基于密码的认证。默认为&quot;yes&quot;。
PasswordAuthentication yes

# Change to no to disable s/key passwords
##设置禁用s/key密码
#ChallengeResponseAuthentication yes
##ChallengeResponseAuthentication 是否允许质疑-应答(challenge-response)认证
ChallengeResponseAuthentication no


########3.3、与 Kerberos 有关的参数设定，指定是否允许基于Kerberos的用户认证########
#Kerberos options
#KerberosAuthentication no
##是否要求用户为PasswdAuthentication提供的密码必须通过Kerberos KDC认证，要使用Kerberos认证，
###服务器必须提供一个可以校验KDC identity的Kerberos servtab。默认值为no

#KerberosOrLocalPasswd yes
##如果Kerberos密码认证失败，那么该密码还将要通过其他的的认证机制，如/etc/passwd
###在启用此项后，如果无法通过Kerberos验证，则密码的正确性将由本地的机制来决定，如/etc/passwd，默认为yes

#KerberosTicketCleanup yes
##设置是否在用户退出登录是自动销毁用户的ticket

#KerberosGetAFSToken no
##如果使用AFS并且该用户有一个Kerberos 5 TGT,那么开启该指令后，
###将会在访问用户的家目录前尝试获取一个AFS token,并尝试传送 AFS token 给 Server 端，默认为no

 

####3.4、与 GSSAPI 有关的参数设定，指定是否允许基于GSSAPI的用户认证，仅适用于SSH2####
##GSSAPI 是一套类似 Kerberos 5 的通用网络安全系统接口。
###如果你拥有一套 GSSAPI库，就可以通过 tcp 连接直接建立 cvs 连接，由 GSSAPI 进行安全鉴别。

# GSSAPI options
#GSSAPIAuthentication no
##GSSAPIAuthentication 指定是否允许基于GSSAPI的用户认证，默认为no

GSSAPIAuthentication yes
#GSSAPICleanupCredentials yes
##GSSAPICleanupCredentials 设置是否在用户退出登录是自动销毁用户的凭证缓存
GSSAPICleanupCredentials yes

# Set this to 'yes' to enable PAM authentication, account processing,
# and session processing. If this is enabled, PAM authentication will
# be allowed through the ChallengeResponseAuthentication mechanism.
# Depending on your PAM configuration, this may bypass the setting of
# PasswordAuthentication, PermitEmptyPasswords, and
# &quot;PermitRootLogin without-password&quot;. If you just want the PAM account and
# session checks to run without PAM authentication, then enable this but set
# ChallengeResponseAuthentication=no
#UsePAM no
##设置是否通过PAM验证
UsePAM yes

# Accept locale-related environment variables
##AcceptEnv 指定客户端发送的哪些环境变量将会被传递到会话环境中。
###[注意]只有SSH-2协议支持环境变量的传递。指令的值是空格分隔的变量名列表(其中可以使用'*'和'?'作为通配符)。
####也可以使用多个 AcceptEnv 达到同样的目的。需要注意的是，有些环境变量可能会被用于绕过禁止用户使用的环境变量。
#####由于这个原因，该指令应当小心使用。默认是不传递任何环境变量。

AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES
AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT
AcceptEnv LC_IDENTIFICATION LC_ALL
AllowTcpForwarding yes

##AllowTcpForwarding设置是否允许允许tcp端口转发，保护其他的tcp连接

#GatewayPorts no
##GatewayPorts 设置是否允许远程客户端使用本地主机的端口转发功能，出于安全考虑，建议禁止

 
#############3.5、X-Window下使用的相关设定###############

#X11Forwarding no
##X11Forwarding 用来设置是否允许X11转发
X11Forwarding yes

#X11DisplayOffset 10
##指定X11 转发的第一个可用的显示区(display)数字。默认值是 10 。
###可以用于防止 sshd 占用了真实的 X11 服务器显示区，从而发生混淆。
X11DisplayOffset 10

#X11UseLocalhost yes

 

#################3.6、登入后的相关设定#################

#PrintMotd yes
##PrintMotd用来设置sshd是否在用户登录时显示“/etc/motd”中的信息，可以选在在“/etc/motd”中加入警告的信息

#PrintLastLog yes
#PrintLastLog 是否显示上次登录信息

#TCPKeepAlive yes
##TCPKeepAlive 是否持续连接，设置yes可以防止死连接
###一般而言，如果设定这项目的话，那么 SSH Server 会传送 KeepAlive 的讯息给 Client 端，以确保两者的联机正常！
####这种消息可以检测到死连接、连接不当关闭、客户端崩溃等异常。在这个情况下，任何一端死掉后， SSH 可以立刻知道，而不会有僵尸程序的发生！

#UseLogin no
##UseLogin 设置是否在交互式会话的登录过程中使用。默认值是&quot;no&quot;。
###如果开启此指令，那么X11Forwarding 将会被禁止，因为login不知道如何处理 xauth cookies 。
####需要注意的是，在SSH底下本来就不接受 login 这个程序的登入，如果指UsePrivilegeSeparation ，那么它将在认证完成后被禁用。
UserLogin no　　　　　　　

#UsePrivilegeSeparation yes
##UsePrivilegeSeparation 设置使用者的权限
#PermitUserEnvironment no
#Compression delayed
#ClientAliveInterval 0
#ClientAliveCountMax 3
#ShowPatchLevel no

#UseDNS yes
##UseDNS是否使用dns反向解析

#PidFile /var/run/sshd.pid

#MaxStartups 10
##MaxStartups 设置同时允许几个尚未登入的联机，当用户连上ssh但并未输入密码即为所谓的联机，
###在这个联机中，为了保护主机，所以需要设置最大值，预设为10个，而已经建立联机的不计算入内，
####所以一般5个即可，这个设置可以防止恶意对服务器进行连接

#MaxAuthTries 6
##MaxAuthTries 用来设置最大失败尝试登陆次数为6，合理设置辞职，可以防止攻击者穷举登录服务器
#PermitTunnel no

 

############3.7、开放禁止用户设定############

#AllowUsers&amp;lt;用户名1&amp;gt; &amp;lt;用户名2&amp;gt; &amp;lt;用户名3&amp;gt; ...
##指定允许通过远程访问的用户，多个用户以空格隔开

#AllowGroups&amp;lt;组名1&amp;gt; &amp;lt;组名2&amp;gt; &amp;lt;组名3&amp;gt; ...
##指定允许通过远程访问的组，多个组以空格隔开。当多个用户需要通过ssh登录系统时，可将所有用户加入一个组中。

#DenyUsers&amp;lt;用户名1&amp;gt; &amp;lt;用户名2&amp;gt; &amp;lt;用户名3&amp;gt; ...
##指定禁止通过远程访问的用户，多个用户以空格隔开

#DenyGroups&amp;lt;组名1&amp;gt; &amp;lt;组名2&amp;gt; &amp;lt;组名3&amp;gt; ...
##指定禁止通过远程访问的组，多个组以空格隔开。

# no default banner path
#Banner /some/path

# override default of no subsystems
Subsystem       sftp    /usr/libexec/openssh/sftp-server
ClientAliveInterval 3600
ClientAliveCountMax 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;sftp是什么&quot;&gt;6.SFTP是什么&lt;/h2&gt;
&lt;p&gt;SFTP是Secure FileTransferProtocol的缩写，安全文件传送协议。&lt;/p&gt;
&lt;p&gt;SFTP和FTP是两种协议，它们是不同的，sftp是ssh内含的协议，只要sshd服务器启动了，它就可用，它本身没有单独的守护进程，更不需要ftp服务器启动。&lt;/p&gt;
&lt;p&gt;SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要求更高时，可以使用SFTP代替FTP。&lt;/p&gt;
&lt;h2 id=&quot;sftp登陆&quot;&gt;7.SFTP登陆&lt;/h2&gt;
&lt;p&gt;使用sftp登陆远程服务器，可以&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sftp root@192.168.0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以指定端口号&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;sftp -oPort=22 root@192.168.0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用sftp进行文件上传下载&quot;&gt;8.使用SFTP进行文件上传下载&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;下载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;get [-afPpRr] remote [local] &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载远程文件到本地目录&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;get /tmp/test.c ~/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载远程文件夹到本地目录&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;get -r /tmp/test.c ~/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;上传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;put [-afPpRr] local [remote]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上传本地文件到远程文件夹&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;put ~/test.c /tmp/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上传本地文件夹到远程目录（会上传本地文件夹下的所有文件）&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;put ~/test /tmp/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;更多sftp命令&quot;&gt;9.更多SFTP命令&lt;/h2&gt;
&lt;p&gt;输入 help 或 ? 命令可以查看sftp支持的命令操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sftp&amp;gt; help
Available commands:
bye                                退出sftp
exit                               退出sftp
quit                               退出sftp
cd path                            将远程目录更改为'path'
chgrp grp path                     将文件'path'的组更改为'grp'
chmod mode path                    将文件'path'的权限更改为'mode'
chown own path                     将文件'path'的所有者更改为'own'
df [-hi] [path]                    显示当前目录的统计信息或包含'path'的文件系统
get [-afPpRr] remote [local]       下载文件
reget [-fPpRr] remote [local]      恢复下载文件
reput [-fPpRr] [local] remote      恢复上传文件
help                               显示此帮助文本
lcd path                           将本地目录更改为'path'
lls [ls-options [path]]            显示本地目录列表
lmkdir path                        创建本地目录
ln [-s] oldpath newpath            链接远程文件（-s用于符号链接）
lpwd                               打印本地工作目录
ls [-1afhlnrSt] [path]             显示远程目录列表
lumask umask                       将本地umask设置为'umask'
mkdir path                         创建远程目录
progress                           切换进度表的显示
put [-afPpRr] local [remote]       上传文件
pwd                                显示远程工作目录
rename oldpath newpath             重命名远程文件
rm path                            删除远程文件
rmdir path                         删除远程目录
symlink oldpath newpath            符号链接远程文件
version                            显示SFTP版本
!command                           在本地shell中执行'command'
!                                  转到本地shell，输入exit可退出并返回到sftp
?                                  显示此帮助文本&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;执行本地命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们想在进入sftp会话环境下执行本地命令怎么办？只需要在本地命令之前加叹号!即可，示例如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;!ls&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，你可以输入 &lt;code&gt;!&lt;/code&gt; 命令转为本地shell会话，退出本地会话输入 &lt;code&gt;exit&lt;/code&gt; 即可返回到原sftp会话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除文件和目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除远程文件&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;rm path&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除远程目录（rmdir只能删除空目录）&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;rmdir path  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：不可以设置参数，如 -rf。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;退出会话&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是在 ssh 还是 sftp，都可以使用 &lt;code&gt;exit&lt;/code&gt; 退出当前会话，sftp 还可以使用 &lt;code&gt;quit&lt;/code&gt; 、&lt;code&gt;bye&lt;/code&gt; 命令退出。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;10.结语&lt;/h2&gt;
&lt;p&gt;相信本文足以可以让你解决使用终端过程中碰到的绝大多数问题了。&lt;/p&gt;
&lt;p&gt;我是薛勤，咱们下期见！关注我，带你领略更多编程技能！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参考：https://www.cnblogs.com/ftl1012/p/ssh.html&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 10 Jul 2019 12:46:00 +0000</pubDate>
<dc:creator>薛勤</dc:creator>
<og:description>1.前言 在Windows系统下操作远程服务器的方式很多，比如XShell+XFTP组合，亦或是PuTTY+WinSCP组合，但在Mac系统下登陆远程服务器，并没有这些工具供我们使用。相比较而言，在M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yueshutong/p/11166377.html</dc:identifier>
</item>
<item>
<title>浅入深出Vue：子组件与数据传递 - 若羽。</title>
<link>http://www.cnblogs.com/By-ruoyu/p/11165969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/By-ruoyu/p/11165969.html</guid>
<description>&lt;p&gt;上一篇了解了&lt;strong&gt;组件&lt;/strong&gt;的概念及在使用中需要注意的地方。在面对单个组件逻辑复杂需要拆分时，难免会遇到父子组件之间数据传递的问题。那么我们来了解一下在父子组件之间进行数据传递时需要遵循哪些约定，以及要注意哪些问题。&lt;/p&gt;
&lt;h2 id=&quot;如何传递&quot;&gt;如何传递&lt;/h2&gt;
&lt;p&gt;父组件向子组件在进行传递时，使用的是 &lt;code&gt;prop&lt;/code&gt;特性进行传递。&lt;/p&gt;
&lt;h3 id=&quot;约定&quot;&gt;约定&lt;/h3&gt;
&lt;p&gt;老规矩， 在使用前我们首先了解应该怎么使用，有哪些约束条件：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;子组件的 &lt;code&gt;props&lt;/code&gt;中定义要传递的变量名&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;变量名同组件的命名规范&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;父组件传值时，需要使用&lt;strong&gt;短横线分隔命名&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用 &lt;code&gt;v-bind&lt;/code&gt;进行传值&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;首先在子组件中定义：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// Child.vue

export default {
    name: 'child'
    props: ['teamList']
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用了&lt;strong&gt;驼峰命名&lt;/strong&gt;，在传值时需注意要转换成&lt;strong&gt;短横线分隔命名&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们定义了一个 &lt;code&gt;teamList&lt;/code&gt;的变量，此时我们就可以在这个组件中通过 &lt;code&gt;this&lt;/code&gt;使用这个变量了（同 &lt;code&gt;data&lt;/code&gt;中的数据）。&lt;/p&gt;
&lt;h3 id=&quot;传值&quot;&gt;传值&lt;/h3&gt;
&lt;p&gt;在父组件中进行传值：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;child v-bind:teamList=&quot;teamList&quot;&amp;gt;&amp;lt;/child&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;父组件中使用 &lt;code&gt;v-bind&lt;/code&gt;即可将数据传递下去了。&lt;/p&gt;
&lt;p&gt;向子组件传递数据就是这么简单，本质上和 &lt;code&gt;data&lt;/code&gt;一样，只是这里单独使用 &lt;code&gt;prop&lt;/code&gt;特性将其区分开来。&lt;/p&gt;
&lt;p&gt;需要注意的时：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;通过 &lt;code&gt;prop&lt;/code&gt;特性传递下去的数组是 “单向”绑定的，父组件对数组的更新会影响到子组件。因此并不建议子组件对 &lt;code&gt;prop&lt;/code&gt;特性中的值进行修改&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Js中在传递对象和数组时传递的时引用！因此：当子组件修改父组件传递下来的对象/数组时会影响到父组件中的状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个特性有利有弊，在某些情况下可以通过这种类似 &lt;code&gt;hack&lt;/code&gt;的方式来进行处理。&lt;/p&gt;
&lt;h2 id=&quot;子组件反向传递&quot;&gt;子组件反向传递&lt;/h2&gt;
&lt;p&gt;上面说到了，并不建议在子组件中修改 &lt;code&gt;props&lt;/code&gt;中的数据。那么当需要向父组件进行某种&lt;strong&gt;反馈&lt;/strong&gt;时怎么办呢？&lt;/p&gt;
&lt;p&gt;假设现在我们有一个登录弹出框的组件，通过子组件的方式调用了，当我们登录成功时该如何&lt;strong&gt;通知&lt;/strong&gt;父组件做出相应的反应呢？&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通过自定义事件，子组件调用 &lt;code&gt;this.$emit('事件名', 参数)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用 &lt;code&gt;v-model&lt;/code&gt; 、组件中 &lt;code&gt;model&lt;/code&gt;选项与 &lt;code&gt;input&lt;/code&gt;事件模拟成 &lt;code&gt;input&lt;/code&gt;控件，对父组件中的值进行更新&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;.sync&lt;/code&gt;修饰符进行 “双向绑定”&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里只介绍第一种方式，因为后两种方式若羽也没用过几次 o(╯□╰)o&lt;/p&gt;
&lt;h3 id=&quot;emit使用约定&quot;&gt;emit使用约定&lt;/h3&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;事件名的命名规范同组件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;父组件在绑定子组件上的自定义事件时，必须&lt;strong&gt;完全匹配&lt;/strong&gt;事件名，这里不像组件与子组件中使用时是使用的&lt;strong&gt;短横线分隔命名&lt;/strong&gt;，而是&lt;strong&gt;完全匹配&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;约定较少，主要注意使用时是和组件不同的，名称需要完全匹配。&lt;/p&gt;
&lt;h3 id=&quot;emit使用&quot;&gt;emit使用&lt;/h3&gt;
&lt;p&gt;首先我们在子组件中定义事件,说是定义，不如说是调用。因为是子组件直接在某段逻辑中调用的&lt;code&gt;emit&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// child.vue

export default {
    methods: {
        submit() {
            this.$emit('submitForm', this.data)
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们定义了调用的自定义事件名称为 &lt;code&gt;submitForm&lt;/code&gt;，那么在父组件中使用：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!-- parent.vue --&amp;gt;

&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;child v-on:submitForm=&quot;submit&quot;&amp;gt;&amp;lt;/child&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
    methods: {
        submit(data) {
            // 处理逻辑
        }
    }
}
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这里在使用时， &lt;code&gt;v-on&lt;/code&gt;绑定的事件名称是 &lt;code&gt;submitForm&lt;/code&gt;而不是 &lt;code&gt;submit-form&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这一点需要注意。&lt;/p&gt;
&lt;h2 id=&quot;写在后面&quot;&gt;写在后面&lt;/h2&gt;
&lt;p&gt;这一篇内容较少，因为接下来的入门篇将会用项目实践来更好的演示它们的用法。同时，初学之时也不太建议在用法多样性上关注太多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在实践中学习、成长&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jul 2019 11:22:00 +0000</pubDate>
<dc:creator>若羽。</dc:creator>
<og:description>上一篇了解了 组件 的概念及在使用中需要注意的地方。在面对单个组件逻辑复杂需要拆分时，难免会遇到父子组件之间数据传递的问题。那么我们来了解一下在父子组件之间进行数据传递时需要遵循哪些约定，以及要注意哪</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/By-ruoyu/p/11165969.html</dc:identifier>
</item>
<item>
<title>深入理解Java内存模型JMM与volatile关键字 - Tu9oh0st</title>
<link>http://www.cnblogs.com/Tu9oh0st/p/11165905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tu9oh0st/p/11165905.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1330447/201907/1330447-20190710190510439-960754042.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Java线程内存模型跟CPU缓存模型类似，是基于CPU缓存模型来建立的，Java线程内存模型是标准化的，屏蔽掉了底层不同计算机的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1330447/201907/1330447-20190710190519082-1027896959.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;编写代码来分析&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class VolatileVisibilityTest {
    private static boolean initFlag = false;

    public static void main(String[] args) throws InterruptedException {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;等待数据准备..&quot;);
                while (!initFlag){

                }
                System.out.println(&quot;============数据准备完毕，执行程序逻辑&quot;);
            }
        }).start();
        Thread.sleep(2000);
        
        new Thread(new Runnable() {
            @Override
            public void run() {
                prepareData();
            }
        }).start();
    }

    public static void prepareData(){
 ![](https://img2018.cnblogs.com/blog/1330447/201907/1330447-20190710190530342-1378616179.png)

       System.out.println(&quot;数据准备中..&quot;);
        initFlag = true;
        System.out.println(&quot;数据准备完毕!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行程序，打印结果&lt;/p&gt;
&lt;p&gt;并未出现&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;code&gt;============数据准备完毕，执行程序逻辑&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;这段结果&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;第一个线程给了initFlag为false，第二个执行了prepareData()所以initFlag为true，但是第一个线程中的flag还是为false。&lt;/p&gt;
&lt;p&gt;如果给initFlag加个&lt;code&gt;volatile&lt;/code&gt;关键字：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class VolatileVisibilityTest {
    private static volatile boolean initFlag = false;

    public static void main(String[] args) throws InterruptedException {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;等待数据准备..&quot;);
                while (!initFlag){

                }
                System.out.println(&quot;============数据准备完毕，执行程序逻辑&quot;);
            }
        }).start();
        Thread.sleep(2000);

        new Thread(new Runnable() {
            @Override
            public void run() {
                prepareData();
            }
        }).start();
    }
    public static void prepareData(){
        System.out.println(&quot;数据准备中..&quot;);
        initFlag = true;
        System.out.println(&quot;数据准备完毕!&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行程序，返回结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1330447/201907/1330447-20190710190542024-2145839778.png&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;read（读取）：从主内存读取数据&lt;/li&gt;
&lt;li&gt;load（载入）：将主内存读取到的数据写入工作内存&lt;/li&gt;
&lt;li&gt;use（使用）：从工作内存读取数据来计算&lt;/li&gt;
&lt;li&gt;assign（赋值）：将计算好的值重新赋值到工作内存中&lt;/li&gt;
&lt;li&gt;strore（存储）：将工作内存数据写入主内存&lt;/li&gt;
&lt;li&gt;write（写入）：将store过去的变量值赋值给主内存中的变量&lt;/li&gt;
&lt;li&gt;lock（锁定）：将主内存变量枷锁，表示为线程独占状态&lt;/li&gt;
&lt;li&gt;unlock（解锁）：将主内存变量解锁，解锁后其他线程可以锁定该变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;整个过程如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1330447/201907/1330447-20190710190549576-67586004.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1330447/201907/1330447-20190710190557995-181367658.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1330447/201907/1330447-20190710190607279-1401266505.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1330447/201907/1330447-20190710190618838-1180801256.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IDEA这样设置&lt;/p&gt;
&lt;p&gt;显式出的结果，其中volatile修饰的汇编代码如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;0x000000000349eaff: &lt;code&gt;lock&lt;/code&gt; add dword ptr [rsp],0h ;*putstatic initFlag&lt;br/&gt;; - com.tugohost.concurrent.VolatileVisibilityTest::prepareData@9 (line 31)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;&lt;li&gt;并发编程三大特性：可见性，原子性，有序性&lt;/li&gt;
&lt;li&gt;Volatile保证可见性与有序性，但是不保证原子性，保证原子性需要借助synchronized这样的锁机制。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 10 Jul 2019 11:06:00 +0000</pubDate>
<dc:creator>Tu9oh0st</dc:creator>
<og:description>深入理解Java内存模型JMM与volatile关键字 多核并发缓存架构 Java内存模型 Java线程内存模型跟CPU缓存模型类似，是基于CPU缓存模型来建立的，Java线程内存模型是标准化的，屏蔽</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tu9oh0st/p/11165905.html</dc:identifier>
</item>
<item>
<title>工作日志，多租户模式下的数据备份和迁移 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/11156954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/11156954.html</guid>
<description>&lt;p&gt;工作日志，多租户模式下的数据备份和迁移&lt;/p&gt;
&lt;p&gt;记录和分享一篇工作中遇到的奇难杂症。目前做的项目是多租户模式。一套系统管理多个项目，用户登录不同的项目加载不同的数据。除了一些系统初始化的配置表外，各项目之间数据相互独立。前期选择了共享数据表的隔离方案，为后期的数据迁移挖了一个大坑。这里记录填坑的思路。可能不优雅，仅供参考。&lt;/p&gt;
&lt;h2 id=&quot;多租户&quot;&gt;多租户&lt;/h2&gt;
&lt;p&gt;多租户是一种软件架构，在同一台（组）服务器上运行单个实例，能为多个租户提供服务。以实际例子说明，一套能源监控系统，可以为A产业园提供服务，也可以为B产业园提供服务。A的管理员登录能源监控系统只会看到A产业园相关的数据。同样的道理，B产业园也是一样。多住户模式最重要的就是数据之间的独立。其最大的局限性在于对租户定制化开发困难很大。适合通用的业务场景。&lt;/p&gt;
&lt;h3 id=&quot;数据隔离方案&quot;&gt;数据隔离方案&lt;/h3&gt;
&lt;h4 id=&quot;独立数据库&quot;&gt;独立数据库&lt;/h4&gt;
&lt;p&gt;顾名思义，一个租户独享一个数据库，其隔离级别最强，数据安全性最高，数据的备份和恢复最方便。对数据独立性要求很高，数据的扩张性要求较多的租户可以考虑使用。或者钱给的多也可以考虑。毕竟该模式下的硬件成本较高。代码成本较低，Hibernate已经提供DATABASE的实现。&lt;/p&gt;
&lt;h4 id=&quot;共享数据库独立-schema&quot;&gt;共享数据库、独立 Schema&lt;/h4&gt;
&lt;p&gt;多个租户共有一个数据库，每个租户拥有属于自己的Schema（Schema表示数据库对象集合，它包含：表，视图，存储过程，索引等等对象）。其隔离级别较强，数据安全性较高，数据的备份和恢复较为麻烦。数据库出了问题会影响到所有租户。Hibernate也提供SCHEMA的实现。&lt;/p&gt;
&lt;h4 id=&quot;共享数据库共享-schema共享数据表&quot;&gt;共享数据库、共享 Schema、共享数据表&lt;/h4&gt;
&lt;p&gt;多个租户共享一个数据库，一个Schema，一张数据表。各租户之间通过字段区分。其隔离级别最低，数据安全性最低，数据的备份和恢复最麻烦（让我哭一分钟😭）。若一张表出现问题会影响到所有租户。其代码工作量也是最多，因为Hibernate（5.0.3版本）并没有支持DISCRIMINATOR模式，目前还只是计划支持。其模式最大的好处就是用最少的服务器支持最多的租户。&lt;/p&gt;
&lt;h2 id=&quot;业务场景&quot;&gt;业务场景&lt;/h2&gt;
&lt;p&gt;在我们的能源管理的系统中，多个租户就是多个项目。将需要数据独立的数据表通过ProjectID区分。而一些系统初始化的配置表则可以数据共享。怎么用尽可能少的代码来管理每个租户呢？这里提出我个人的思路。&lt;/p&gt;
&lt;h3 id=&quot;多租户的实现&quot;&gt;多租户的实现&lt;/h3&gt;
&lt;p&gt;第一步：用户登录时获取当前项目，并保存到上下文中。&lt;/p&gt;
&lt;p&gt;第二步：通过EntityListeners注解监听，在实体被创建时将当前项目ID保存到数据库中。&lt;/p&gt;
&lt;p&gt;第三步：通过自定义拦截器，拦截需要数据隔离的sql语句，重新拼接查询条件。&lt;/p&gt;
&lt;p&gt;将当前项目保存到上下文中，不同的安全框架实现的方法也有所不同，实现的方式也多种多样，这里就不贴出代码。&lt;/p&gt;
&lt;p&gt;通过EntityListeners注解可以对实体属性变化的跟踪，它提供了保存前，保存后，更新前，更新后，删除前，删除后等状态，就像是拦截器一样。这里我们可以用到&lt;code&gt;PrePersist&lt;/code&gt; 在保存前将项目ID赋值&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;@MappedSuperclass
@EntityListeners(ProjectIdListener::class)
@Poko
class TenantModel: AuditModel() {
    var projectId: String? = null
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;class ProjectIdListener {

    @PrePersist
    fun setProjectId(resultObj: Any) {
        try {
            val projectIdProperty = resultObj::class.java.superclass.getDeclaredField(&quot;projectId&quot;)
            if (projectIdProperty.type == String::class.java) {
                projectIdProperty.isAccessible = true
                projectIdProperty.set(resultObj, ContextUtils.getCurrentProjectId())
            } else {
            }
        } catch (ex: Exception) {
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自定义SQL拦截器，通过实现StatementInspector接口，实现inspect方法即可。不同的业务逻辑，实现的逻辑也不一样，这里就不贴代码了。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;一）、以上是kotlin代码，IDEA支持Kotlin和Java代码的互转。&lt;/p&gt;
&lt;p&gt;二）、需要数据隔离的实体，继承TenantModel类即可，没有继承的实体默认为数据共享。&lt;/p&gt;
&lt;p&gt;三）、ContextUtils是自定义获取上下文的工具类。&lt;/p&gt;
&lt;h2 id=&quot;数据备份&quot;&gt;数据备份&lt;/h2&gt;
&lt;h4 id=&quot;业务分析&quot;&gt;业务分析&lt;/h4&gt;
&lt;p&gt;到了文章的重点。数据的备份目的是数据迁移和数据的还原。友好的备份格式可以为数据迁移减少很多工作量。刚开始觉得这个需求很简单，MySQL的数据备份做过很多次，也很简单。但数据备份不仅仅是数据恢复，还有数据迁移的功能（A项目下的数据备份后，可以导入的B项目下）。这下就有意思了。我们理一理：&lt;/p&gt;
&lt;p&gt;一）、数据备份是数据隔离的。A项目数据备份，只能备份A项目下的数据。&lt;/p&gt;
&lt;p&gt;二）、备份的数据用于数据恢复。&lt;/p&gt;
&lt;p&gt;三）、备份的数据用于数据迁移，之前存在的关联数据要重新绑定关联关系。&lt;/p&gt;
&lt;p&gt;四）、数据恢复和迁移过程中，注意重复导入和事务问题。&lt;/p&gt;
&lt;p&gt;针对上面的分析，一般都有会三种解决思路：&lt;/p&gt;
&lt;p&gt;一）、用MySQL自带的命令导入和导出。&lt;/p&gt;
&lt;p&gt;二）、找已经做好的轮子。（如果有，请麻烦告知一下）&lt;/p&gt;
&lt;p&gt;三）、自己实现将数据转为JSON数据，再由JSON数据导入的功能。&lt;/p&gt;
&lt;p&gt;因为需求三和需求四的特殊性，MySQL自带的命令很难满足，也没有合适的轮子。只能自己实现，这样做也更放心点。&lt;/p&gt;
&lt;h4 id=&quot;实现流程&quot;&gt;实现流程&lt;/h4&gt;
&lt;p&gt;第一步：确定表的顺序。项目之间数据迁移后，需要重新绑定表的关联关系，优先导入导出没有外键关联的表。&lt;/p&gt;
&lt;p&gt;第二步：遍历每张表，将数据转成JSON格式数据一行行写入到文本文件中。&lt;/p&gt;
&lt;p&gt;导出数据伪代码：&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun exportSystemData(request: HttpServletRequest, response: HttpServletResponse) {
    // 校验权限
    checkAuthority(&quot;导出系统数据&quot;)
    // 获取当前项目
    val currentProjectId = ContextUtils.getCurrentProjectId()
    val systemFilePath = &quot;${attachmentPath}system${File.separator}$currentProjectId&quot;
    val file = File(systemFilePath)
    if (!file.exists()) {
        file.mkdirs()
    }
    // 获取数据独立的表名（方便查询）和类名的全路径（方便反射）
    val moreProjectEntityMap = CommonUtils.getMoreProjectEntity()
    moreProjectEntityMap.remove(CommonUtils.toUnderline(SystemLog::class.simpleName))
    moreProjectEntityMap.remove(CommonUtils.toUnderline(AlarmRecord::class.simpleName))
    // 生成文件
    moreProjectEntityMap.forEach { entry -&amp;gt;
        var tableFile: FileWriter? = null
        try {
            tableFile = FileWriter(File(systemFilePath, &quot;${entry.key}.txt&quot;))
            dataManagementService.findAll(Class.forName(entry.value)).forEach {
                tableFile.write(&quot;${JSONObject.toJSONString(it)} \n&quot;)
            }
        } catch (e: Exception) {
            e.printStackTrace()
        } finally {
            tableFile?.let {
                it.flush()
                it.close()
            }
        }
    }
    // 压缩成一个文件
    fileUtil.zip(systemFilePath)
    file.listFiles().forEach { it.delete() }
    fileUtil.downloadAttachment(&quot;$systemFilePath.zip&quot;, response)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据迁移&quot;&gt;数据迁移&lt;/h2&gt;
&lt;h4 id=&quot;业务分析-1&quot;&gt;业务分析&lt;/h4&gt;
&lt;p&gt;备份后的数据有两个用途。第一是数据还原；最重要的是数据迁移。将A项目中的配置导入到B项目中，可以提高用户的效率。数据还原最简单，这里重点介绍数据迁移的思路（可能不太合理）&lt;/p&gt;
&lt;p&gt;数据迁移最麻烦的就是新创建后的数据如何重新绑定主外表的关系。其次就是如果导入过程中失败，事务的处理问题。为了处理这两个问题，我选择新增一张表维护新旧ID的迁移记录。每次导入成功后就在表中保存数据。这样可以避免重复导入的情况。也为新数据重新绑定主外关系做准备。&lt;/p&gt;
&lt;h4 id=&quot;实现步骤&quot;&gt;实现步骤&lt;/h4&gt;
&lt;p&gt;第一步：解压上传后的文件，并按照指定的排序顺序读取解压后的文件。&lt;/p&gt;
&lt;p&gt;第二步：一行行读取数据，通过反射将JSON格式字符串转为对象。遍历对象的值将旧ID根据数据迁移记录替换成迁移后的新ID。&lt;/p&gt;
&lt;p&gt;第三步：检擦数据迁移记录表中是否已经存在迁移记录，若没有则插入数据并记录日志。&lt;/p&gt;
&lt;p&gt;第四步：若数据迁移记录表中已经存在记录，则更新数据。&lt;/p&gt;
&lt;p&gt;第五步：读取第二行数据，重复执行。&lt;/p&gt;
&lt;p&gt;数据恢复伪代码&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;fun importSystemData(file: MultipartFile, request: HttpServletRequest) {
    checkAuthority(&quot;导入系统数据&quot;)
    val currentProjectId = ContextUtils.getCurrentProjectId()
    val systemFilePath = &quot;${attachmentPath}system&quot;
    val tempFile = File(systemFilePath, file.originalFilename)
    val fileOutputStream = FileOutputStream(tempFile)
    fileOutputStream.write(file.bytes)
    fileOutputStream.close()
    // 获取排序后迁移表
    val moreProjectEntityMap = CommonUtils.getMoreProjectEntity()
    moreProjectEntityMap.remove(CommonUtils.toUnderline(SystemLog::class.simpleName))
    val files: MutableMap&amp;lt;String, File&amp;gt; = mutableMapOf()
    fileUtil.unzip(tempFile.absoluteFile, systemFilePath, &quot;&quot;).forEach {
        files[it!!.nameWithoutExtension] = it
    }
    val dataTransferHistories = dataTransferHistoryRepository.findByProjectId(currentProjectId).toMutableList()
    try {
        moreProjectEntityMap.keys.forEach {  fileName -&amp;gt;
            val tableFile = files.getOrDefault(fileName, null) ?: return@forEach
            val entity = Class.forName(moreProjectEntityMap[fileName])
            tableFile.forEachLine { dataStr -&amp;gt;
                val data = JSONObject.parseObject(dataStr, entity)
//              获取对象所有属性
                val fieldMap = CommonUtils.getEntityAllField(data)
//              获取数据迁移的旧ID
                val id = fieldMap[&quot;id&quot;]!!.get(data) as String
                val dataTransferHistory = dataTransferHistories.find { it.oldId == id }
//              重新绑定迁移数据后的id
                handleEntityData(data, fieldMap, moreProjectEntityMap.values.toList(), dataTransferHistories)
                fieldMap[&quot;projectId&quot;]!!.set(data, currentProjectId)
                if (null == dataTransferHistory || null == dataManagementService.getByIdElseNull(dataTransferHistory.newId, entity)) {
                    val saved = dataManagementService.create(data, entity)
//                  绑定旧ID和新ID的关系
                    val savedId = CommonUtils.getEntityAllField(saved)[&quot;id&quot;]!!.get(saved) as String
                    if (null == dataTransferHistory) {
                        dataTransferHistories.add(DataTransferHistory(id, savedId, currentProjectId, fileName))
                    }
                } else {
                    fieldMap[&quot;id&quot;]!!.set(data, dataTransferHistory.newId)
                    dataManagementService.update(data, entity)
                }
            }
        }
    } catch (e: Exception) {
        e.printStackTrace()
        throw IllegalArgumentException(&quot;数据导入失败&quot;)
    } finally {
        tempFile.delete()
        files.values.forEach { it.delete() }
        recordDataTransferHistory(dataTransferHistories)
    }
}

// 记录数据迁移
private fun recordDataTransferHistory(dataTransferHistories: MutableList&amp;lt;DataTransferHistory&amp;gt;) {
    dataTransferHistoryRepository.saveAll(dataTransferHistories)
}

// 重新绑定主外关系表
fun handleEntityData(sourceClass: Any, fieldMap: MutableMap&amp;lt;String, Field&amp;gt;, classPaths: List&amp;lt;String&amp;gt;, dataTransferHistories: MutableList&amp;lt;DataTransferHistory&amp;gt;) {
    val currentProjectId = ContextUtils.getCurrentProjectId()
    fieldMap.values.forEach { field -&amp;gt;
        val classPath = field.type.toString().split(&quot; &quot;).last()
        // 一对多或多对多关系
        if (classPath == &quot;java.util.List&quot;) {
            val listValue = field.get(sourceClass) as List&amp;lt;*&amp;gt;
            listValue.forEach { listObj -&amp;gt;
                listObj?.let { changeOldRelId4NewData(it, dataTransferHistories, currentProjectId) }
            }
        }
        // 一对一或多对一关系
        if (classPaths.contains(classPath)) {
            val value = field.get(sourceClass)?: return@forEach
            changeOldRelId4NewData(value, dataTransferHistories, currentProjectId)
        }
        // 字符串ID关联
        if (classPath == &quot;java.lang.String&quot; &amp;amp;&amp;amp; null != field.get(sourceClass)) {
            var oldId = field.get(sourceClass).toString()
            dataTransferHistories.forEach {
                oldId = oldId.replace(it.oldId, it.newId)
            }
            field.set(sourceClass, oldId)
        }
    }
}

fun changeOldRelId4NewData(data: Any, dataTransferHistories: MutableList&amp;lt;DataTransferHistory&amp;gt;, currentProjectId: String) {
    val fieldMap = CommonUtils.getEntityAllField(data)
    fieldMap.values.forEach { field -&amp;gt;
        if (field.type.toString().contains(&quot;java.lang.String&quot;) &amp;amp;&amp;amp; null != field.get(data)) {
            var oldId = field.get(data).toString()
            dataTransferHistories.forEach {
                oldId = oldId.replace(it.oldId, it.newId)
            }
            field.set(data, oldId)
        }
    }
    fieldMap[&quot;projectId&quot;]!!.set(data, currentProjectId)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;/**
 * 数据迁移记录表
 */
@Entity
@Table(uniqueConstraints = [UniqueConstraint(columnNames = [&quot;oldId&quot;, &quot;projectId&quot;])])
data class DataTransferHistory (

        var oldId: String = &quot;&quot;,
        var newId: String = &quot;&quot;,
        var projectId: String = &quot;&quot;,
        var tableName: String = &quot;&quot;,
        var createTime: Instant = Instant.now(),
        @Id
        @GenericGenerator(name = &quot;idGenerator&quot;, strategy = &quot;uuid&quot;)
        @GeneratedValue(generator = &quot;idGenerator&quot;)
        var id: String = &quot;&quot;

)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里就结束了，以上思路仅供参考。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;一）、数据备份需要项目独立&lt;br/&gt;二）、通过项目ID 区分备份的数据是用来数据还原还是数据迁移&lt;br/&gt;三）、数据迁移过程中需要考虑数据重复导入的问题&lt;br/&gt;四）、数据迁移过程中需要重新绑定主外键的关联&lt;br/&gt;五）、第三和第四点可以通过记录数据迁移表做辅助&lt;br/&gt;六）、数据迁移过程尽量避免删除操作。避免对其他项目造成影响。&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jul 2019 10:30:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<og:description>工作日志，多租户模式下的数据备份和迁移 记录和分享一篇工作中遇到的奇难杂症。目前做的项目是多租户模式。一套系统管理多个项目，用户登录不同的项目加载不同的数据。除了一些系统初始化的配置表外，各项目之间数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itdragon/p/11156954.html</dc:identifier>
</item>
</channel>
</rss>