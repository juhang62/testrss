<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>vue的表单编辑删除，保存取消功能 - 梦里一米七八</title>
<link>http://www.cnblogs.com/qq946487854/p/10404268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq946487854/p/10404268.html</guid>
<description>&lt;p&gt;        过年回来第一篇博客，可能说的不是很清楚，而且心情可能也不是特别的high，虽然今天是元宵，我还在办公室11.30在加班，但就是想把写过的代码记下来，怕以后可能真的忘了。（心将塞未塞，欲塞未满）&lt;/p&gt;
&lt;h2&gt;                                        VUE+ElementUI 的表单编辑，删除，保存，取消功能&lt;/h2&gt;
&lt;p&gt;VUE的表单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &amp;lt;el-form :label-position=&quot;labelPosition&quot; label-width=&quot;120px&quot; &lt;span&gt;:model=&quot;form&quot; ref=&quot;form&quot;&lt;/span&gt;&amp;gt;
          &amp;lt;el-form-item label=&quot;商品名称&quot; required&amp;gt;
            &amp;lt;el-input v-model=&quot;form.name&quot; autocomplete=&quot;off&quot;&amp;gt;&amp;lt;/el-input&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
          &amp;lt;el-form-item label=&quot;商品数量&quot; required&amp;gt;
            &amp;lt;el-input v-model=&quot;form.number&quot; autocomplete=&quot;off&quot;&amp;gt;&amp;lt;/el-input&amp;gt;
          &amp;lt;/el-form-item&amp;gt;
        &amp;lt;/el-form&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，表单还有下拉选择框，radio表单等，在下面这个ElementUI官方组件&lt;/p&gt;
&lt;p&gt;http://element-cn.eleme.io/#/zh-CN/component/form&lt;/p&gt;
&lt;p&gt;比较重要的是是标红的那两个属性，然后下面的data返回的数据时，要在form里把model里的两个值，写进去。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      labelPosition: &lt;/span&gt;'right'&lt;span&gt;,
      form: {
               name: &lt;/span&gt;''&lt;span&gt;,
               number: &lt;/span&gt;''&lt;span&gt;
               }
             }
           }                                    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而不能把写成空，form： {}&lt;/p&gt;
&lt;p&gt;这样的写法，数据传过来的时候，会接收不到数据，需要name和number占位，你才能把数据传过来。&lt;/p&gt;
&lt;p&gt;然后是编辑，删除功能&lt;/p&gt;
&lt;p&gt;先是编辑，删除按钮的绑定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;el-table-&lt;span&gt;column
          prop&lt;/span&gt;=&quot;option&quot;&lt;span&gt;
          label&lt;/span&gt;=&quot;操作&quot;&lt;span&gt;
          style&lt;/span&gt;=&quot;width:250px&quot;&amp;gt;
          &amp;lt;template slot-scope=&quot;scope&quot;&amp;gt;
            &amp;lt;el-&lt;span&gt;button
              size&lt;/span&gt;=&quot;mini&quot;&lt;span&gt;
              type&lt;/span&gt;=&quot;info&quot;&lt;span&gt;
              @click&lt;/span&gt;=&quot;handleEdit(scope.$index,scope.row)&quot;&amp;gt;&lt;span&gt;编辑
            &lt;/span&gt;&amp;lt;/el-button&amp;gt;
            &amp;lt;el-&lt;span&gt;button
              size&lt;/span&gt;=&quot;mini&quot;&lt;span&gt;
              type&lt;/span&gt;=&quot;danger&quot;&lt;span&gt;
              @click&lt;/span&gt;=&quot;handleDelete(scope.$index,scope.row)&quot;&amp;gt;&lt;span&gt;删除
            &lt;/span&gt;&amp;lt;/el-button&amp;gt;
          &amp;lt;/template&amp;gt;
 &amp;lt;/el-table-column&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编辑函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; handleEdit (index, row) {
      console.log(index, row)
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.idx =&lt;span&gt; index
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.editarr =&lt;span&gt; row.number
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.editVisible = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    },
 handleDelete (index, row) {
      console.log(index, row)
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.idx =&lt;span&gt; index
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.msg =&lt;span&gt; row
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.delarr.push(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msg.number)
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.delVisible = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后data里，要把editVisible: false 和delVisible: false 放进return里去&lt;/p&gt;
&lt;p&gt;至于index和row两个参数，是下标和行数据&lt;/p&gt;
&lt;p&gt;接下来，写dialog编辑框&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;el-dialog title=&quot;编辑商品&quot;&lt;span&gt;
           :visible.sync=&quot;edit&quot;
           @close=&quot;closingDiag&quot;&lt;/span&gt;&lt;span&gt;
           width&lt;/span&gt;=&quot;80%&quot;&amp;gt;
      &amp;lt;el-form :label-position=&quot;labelPosition&quot; label-width=&quot;120px&quot; :model=&quot;form&quot; ref=&quot;form&quot;&amp;gt;
        &amp;lt;el-form-item label=&quot;商品名称&quot; prop=&quot;name&quot; required&amp;gt;
          &amp;lt;el-input v-model=&quot;form.name&quot; autocomplete=&quot;off&quot;&amp;gt;&amp;lt;/el-input&amp;gt;
        &amp;lt;/el-form-item&amp;gt;
        &amp;lt;el-form-item label=&quot;单品价&quot; prop=&quot;one&quot; required&amp;gt;
          &amp;lt;el-input v-model=&quot;form.one&quot; autocomplete=&quot;off&quot;&amp;gt;&amp;lt;/el-input&amp;gt;
        &amp;lt;/el-form-item&amp;gt;
      &amp;lt;/el-form&amp;gt;
  &amp;lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&amp;gt;
    &amp;lt;el-button type=&quot;danger&quot; @click=&quot;resetForm('form')&quot;&amp;gt;取消&amp;lt;/el-button&amp;gt;
    &amp;lt;el-button type=&quot;primary&quot; @click=&quot;editDo&quot;&amp;gt;保存&amp;lt;/el-button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/el-dialog&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除框&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;el-dialog title=&quot;提示&quot; :visible.sync=&quot;delVisible&quot; width=&quot;300px&quot; center&amp;gt;
      &amp;lt;div class=&quot;del-dialog-cnt&quot;&amp;gt;删除不可恢复，是否确定删除？&amp;lt;/div&amp;gt;
      &amp;lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&amp;gt;
        &amp;lt;el-button @click=&quot;delVisible = false&quot;&amp;gt;取消&amp;lt;/el-button&amp;gt;
        &amp;lt;el-button type=&quot;primary&quot; @click=&quot;deleteRow&quot;&amp;gt;确定&amp;lt;/el-button&amp;gt;
      &amp;lt;/span&amp;gt;
 &amp;lt;/el-dialog&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我这边用的，是把编辑dialog放在另一个组件，通过组件导进来。&lt;/p&gt;
&lt;p&gt;就需要在新的edit.vue的data里，edit:false&lt;/p&gt;
&lt;p&gt;关闭模态框&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 closingDiag: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$emit('close-edit', &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取消功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
resetForm: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (formName) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.editVisible = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$refs.form.resetFields();
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  editDo () {
      let formData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FormData();
      formData.append(&lt;/span&gt;'name', &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.form.name)
      formData.append(&lt;/span&gt;'number', &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.form.number)
      let config &lt;/span&gt;= {headers: {'Content-Type': 'multipart/form-data'&lt;span&gt;}}
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$http.post('/man/edit', formData, config).then((response) =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$message({
          type: &lt;/span&gt;'success'&lt;span&gt;,
          message: &lt;/span&gt;'保存成功!'&lt;span&gt;
        })
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$emit('close-edit', &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
      }, (error) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'error'&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$message.error('保存失败' +&lt;span&gt; error.res.data.msg)
      })
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;噢对了，还有个最重要的一点，要写props（内置属性）,watch（监听才能弹窗）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;props: {
    &lt;/span&gt;'editVisible'&lt;span&gt;: Boolean
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; watch: {
    editVisible: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.manedit = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.editVisible
      console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.manedit)
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.showEdit()
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后显示编辑弹窗&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 showEdit: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$http.post('/manedit', {params: {number: &lt;span&gt;this&lt;/span&gt;.editarr}}).then(res =&amp;gt;&lt;span&gt; {
        console.log(res)
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.form)
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.form.name =&lt;span&gt; res.data.data.name
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.form.number =&lt;span&gt; res.data.data.number
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.form.style =&lt;span&gt; res.data.data.style
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.form)
      }, (res) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'获取信息失败' +&lt;span&gt; res)
      })
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;突然感觉写的有点乱乱的，但这些是真的都要写的，有不懂的可以在下面提问，或者去其他博客搜搜，感觉我应该写两个博客分开写，不然根本讲不清楚。。。。算了，我继续说，那既然你写的是组件，那肯定原来的主页面也要引用，如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;edit :edit-visible=&quot;editVisible&quot; @close-edit=&quot;editVisible = false&quot;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入组件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import edit from './edit.vue'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    components: {
            edit
                       }
                         }         &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;确定删除的功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; deleteRow () {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$http.post('delete', {params: {delarr: &lt;span&gt;this&lt;/span&gt;.delarr}}).then((res) =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$message({
          type: &lt;/span&gt;'success'&lt;span&gt;,
          message: &lt;/span&gt;'删除成功!'&lt;span&gt;
        })
      }, (error) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$message.error('删除失败' +&lt;span&gt; error.res.data.msg)
      })
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.delVisible = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有我用到了批量删除功能，但是这里就不写了，因为篇幅太长了，但是我看的链接可以分享给你们&lt;/p&gt;
&lt;p&gt;https://my.oschina.net/u/3763385/blog/1928536&lt;/p&gt;
&lt;p&gt;还有mock.js写假数据的链接，以后的博客我会再写，我自己找的链接知识&lt;/p&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/30354374&lt;/p&gt;
&lt;p&gt;或者双击实现表格内单元格编辑的功能&lt;/p&gt;
&lt;p&gt;https://jsfiddle.net/bgfxv3eu/&lt;/p&gt;
&lt;p&gt;你也可以用JS实现编辑框。&lt;/p&gt;
&lt;p&gt;某大神的代码：&lt;/p&gt;
&lt;p&gt;然后，在&amp;lt;el-table&amp;gt;标签里加上这个@dblclick=&quot;tableDbEdit&quot;，功能是下面，注意的是功能那里别写参数，功能那里再写参数，不然会报错&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  tableDbEdit (row, column, cell, event) {
      console.log(row, column, cell, event)
      event.target.innerHTML &lt;/span&gt;= ''&lt;span&gt;
      let cellInput &lt;/span&gt;= document.createElement('input'&lt;span&gt;)
      cellInput.value &lt;/span&gt;= ''&lt;span&gt;
      cellInput.setAttribute(&lt;/span&gt;'type', 'text'&lt;span&gt;)
      cellInput.style.width &lt;/span&gt;= '80%'&lt;span&gt;
      cell.appendChild(cellInput)
      cellInput.onblur &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        cell.removeChild(cellInput)
        event.target.innerHTML &lt;/span&gt;=&lt;span&gt; cellInput.value
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，我也就讲这么多 ，知识有点多 ，但基本都是零零碎碎我百度总结，然后再测试写出来的，因为我现在写的VUE的ERP系统。&lt;/p&gt;
&lt;p&gt;加油，近些天我会慢慢越写越多的&lt;/p&gt;
&lt;p&gt;元宵快乐啊大家！哦不对，写完这篇博客已经2019-2-20-0:26了，那就祝大家晚安好梦，夜梦吉祥哈！&lt;/p&gt;
&lt;p&gt;（实习近两个月，学的还是挺多的，加油加油加加油！）&lt;/p&gt;

</description>
<pubDate>Tue, 19 Feb 2019 16:28:00 +0000</pubDate>
<dc:creator>梦里一米七八</dc:creator>
<og:description>vue+elementui的编辑，删除，保存，取消</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qq946487854/p/10404268.html</dc:identifier>
</item>
<item>
<title>.Net Core in Docker - 在容器内编译发布并运行 - Agile.Zhou</title>
<link>http://www.cnblogs.com/kklldog/p/core_in_docker.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kklldog/p/core_in_docker.html</guid>
<description>&lt;p&gt;Docker可以说是现在微服务，DevOps的基础，咱们.Net Core自然也得上Docker。.Net Core发布到Docker容器的教程网上也有不少，但是今天还是想来写一写。&lt;br/&gt;你搜.Net core程序发布到Docker网上一般常见的有两种方案：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;1、在本地编译成Dll文件后通过SCP命令或者WinSCP等工具上传到服务器上，然后构建Docker镜像再运行容器。该方案跟传统的发布很像，麻烦的地方是每次都要打开相关工具往服务器上复制文件。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;2、在服务端直接通过Git获取最新源代码后编译成Dll然后构建Docker镜像再运行容器。该方案免去了往服务器复制文件这步操作，但是服务器环境需要安装.Net Core SDK 来编译源代码。&lt;br/&gt;&lt;strong&gt;自从用了Docker简直懒的不能自理，我既不想手工复制文件到服务器，也不想在服务器装.Net Core环境。显然只要Docker镜像包含.Net Core SDK环境就可以在Docker内帮我们编译代码然后运行，这样连我们的服务器都不用装啥.Net Core的环境拉。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;在docker内编译发布.net-core程序并运行&quot;&gt;在Docker内编译发布.Net Core程序并运行&lt;/h2&gt;
&lt;h3 id=&quot;新建一个asp.net-core-mvc项目&quot;&gt;新建一个Asp.net Core MVC项目&lt;/h3&gt;
我们使用一个Asp.net Core MVC程序来演示如何发布到Docker并运行。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_20190219.jpg&quot; alt=&quot;新建项目&quot;/&gt;&lt;br/&gt;&lt;em&gt;使用vs新建一个Asp.net core mvc项目&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;  public class HomeController : Controller
    {
        public IActionResult Index()
        {
            return Content($&quot;Core for docker , {DateTime.Now} , verson 2&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;修改HomeController下的index Action，直接输出一段文字&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
            WebHost.CreateDefaultBuilder(args)
            .UseKestrel(op =&amp;gt;
            {
                op.ListenAnyIP(5000);
            })
            .UseStartup&amp;lt;Startup&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;修改Program下的CreateWebHostBuilder方法，让Kestrel监听5000端口&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_201902192.jpg&quot;/&gt;&lt;br/&gt;&lt;em&gt;本地运行一下试试&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;推送源码到代码仓库&quot;&gt;推送源码到代码仓库&lt;/h3&gt;
&lt;p&gt;把我们的代码推送到对应的Git仓库，方便我们从部署服务器上直接拉取最新的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;X:\workspace\CoreForDocker&amp;gt;git remote add origin https://gitee.com/kklldog/CoreForDocker.git

X:\workspace\CoreForDocker&amp;gt;git push -u origin master
Username for 'https://gitee.com': xxx@gmail.com
Password for 'https://xxx@gmail.com@gitee.com':
Counting objects: 88, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (83/83), done.
Writing objects: 100% (88/88), 527.07 KiB | 2.43 MiB/s, done.
Total 88 (delta 7), reused 0 (delta 0)
remote: Powered By Gitee.com
To https://gitee.com/kklldog/CoreForDocker.git
 * [new branch]      master -&amp;gt; master
Branch 'master' set up to track remote branch 'master' from 'origin'.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加dockerfile文件&quot;&gt;添加Dockerfile文件&lt;/h3&gt;
&lt;p&gt;在CoreForDocker下新增一个Dockerfile文件，注意没有任何扩展名。我们需要基于microsoft/dotnet:latest这个镜像构建一个新的镜像。并且在构建的过程中直接对源码进行编译并发布。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM microsoft/dotnet:latest
WORKDIR /app
COPY /. /app
RUN dotnet restore
RUN dotnet publish -o /out -c Release
EXPOSE 5000
ENTRYPOINT [&quot;dotnet&quot;, &quot;/out/CoreForDocker.dll&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大概解释下Dockerfile的意思：&lt;br/&gt;&lt;strong&gt;FROM microsoft/dotnet:latest&lt;/strong&gt;:&lt;em&gt;使用dotnet的最新镜像，这个镜像其实对应的应该就是2.2-sdk这个镜像，里面包含了dotnet-core 2.2 sdk&lt;/em&gt;&lt;br/&gt;&lt;strong&gt;WORKDIR /app&lt;/strong&gt;:&lt;em&gt;指定工作目录为app&lt;/em&gt;&lt;br/&gt;&lt;strong&gt;COPY /. /app&lt;/strong&gt;：&lt;em&gt;复制宿主机当前目录的内容到容器的app文件夹&lt;/em&gt;&lt;br/&gt;&lt;strong&gt;RUN dotnet restore&lt;/strong&gt;:&lt;em&gt;还原nuget包&lt;/em&gt;&lt;br/&gt;&lt;strong&gt;RUN dotnet publish -o /out -c Release&lt;/strong&gt;：&lt;em&gt;编译并发布程序集到容器的out目录&lt;/em&gt;&lt;br/&gt;&lt;strong&gt;EXPOSE 5000&lt;/strong&gt;:&lt;em&gt;暴露5000端口&lt;/em&gt;&lt;br/&gt;&lt;strong&gt;ENTRYPOINT [&quot;dotnet&quot;, &quot;/out/CoreForDocker.dll&quot;]&lt;/strong&gt;:&lt;em&gt;容器启动的时候执行dotnet命令，参数为/out/CoreForDocker.dll&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_201902196.jpg&quot;/&gt;&lt;br/&gt;&lt;em&gt;Dockerfile的文件属性设置为始终复制&lt;/em&gt;&lt;br/&gt;新建好Dockerfile后git push到代码仓库。&lt;/p&gt;
&lt;h3 id=&quot;在服务器上构建docker镜像&quot;&gt;在服务器上构建Docker镜像&lt;/h3&gt;
&lt;p&gt;这里以Ubuntu为例，ssh登录到服务器后使用git clone命令拉取源代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://gitee.com/kklldog/CoreForDocker.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入源码目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd CodeForDocker\CodeForDocker&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用docker build命令构建新的镜像，注意不要忘记最后一个'.'&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker build -t image_code4docker .&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行容器&quot;&gt;运行容器&lt;/h3&gt;
&lt;p&gt;如果以上步骤都没有报错，那么恭喜你镜像已经构建成功了，我们可以使用此镜像运行Docker容器了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d --name code4docker -p 5000:5000 -v /ect/localtime:/ect/localtime image_core4docker&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;使用image_core4docker镜像运行一个名为core4docker的容器，绑定宿主机的5000到容器的5000口。其中需要注意的是-v参数映射宿主机的/ect/localtime文件夹到容器的/ect/localtime文件夹，因为经过实践发现容器中的时区有可能跟宿主机不一致，需要映射宿主机的/ect/localtime让容器的时区跟宿主机保持一致。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_20190219160556.png&quot;/&gt;&lt;br/&gt;&lt;em&gt;访问一下服务器的5000端口，发现能够正确返回数据表示我们的Asp.net Core程序在容器中运行成功了&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;以后当我们对源码进行修改，并提交后，我们只需在服务器上拉取最新的代码然后使用docker build，docker run命令来再次生成镜像并运行容器。但是手工输入docker build，docker run的命令好像也很麻烦，参数又那么多，太烦了。&lt;/p&gt;
&lt;h3 id=&quot;使用shell脚本简化操作&quot;&gt;使用shell脚本简化操作&lt;/h3&gt;
&lt;p&gt;为了偷懒不想敲那么长的命令，我们可以构建一个脚本，把命令一次性写好，以后只要运行一次脚本就可以了。&lt;br/&gt;使用vim新建一个publish.sh的文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim publish.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;键盘上按i进入编辑模式，输入以下内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd CoreForDocker/CoreForDocker
git pull
docker stop core4docker
docker rm core4docker
docker rmi image_core4docker
docker build -t image_core4docker .
docker run --name core4docker -d -p 5000:5000 -v /etc/localtime:/etc/localtime image_core4docker
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;以上命令，不光有新建镜像跟运行容器的命令，还有移除原来的容器跟镜像的命令&lt;/em&gt;&lt;br/&gt;按ecs进入命令模式，退出保存&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;:wq&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们模拟修改一下源代码，并提交到代码仓库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public IActionResult Index()
    {
        return Content($&quot;Core for docker , {DateTime.Now} , version 2&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;再次修改homecontroller的index action，输出内容上新增一个version&lt;/em&gt;&lt;br/&gt;ssh登录到服务器，运行publish.sh文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/bin/bash publish.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_TIM%E5%9B%BE%E7%89%8720190219162655.png&quot;/&gt;&lt;br/&gt;&lt;em&gt;跑完之后我们再次访问下服务器的5000口，数据返回正确，表示服务器上跑的已经是最新的程序了&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;通过以上演示我们基本了解如何通过git跟docker配合在Ubuntu服务器上不安装.Net Core SDK来发布.Net Core 程序到容器中运行，并且通过shell脚本的方式再次简化发布。但是尽管这样每次发布都需要ssh到服务器上然后运行脚本，特别是开发环境可能经常需要发布，还是觉得麻烦。有没有什么办法让我们push代码后服务器自动就开始部署最新的代码的到容器中运行了呢？&lt;br/&gt;后面我会介绍下如何通过jenkins跟webhook来做CICD。&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 16:12:00 +0000</pubDate>
<dc:creator>Agile.Zhou</dc:creator>
<og:description>Docker可以说是现在微服务，DevOps的基础，咱们.Net Core自然也得上Docker。.Net Core发布到Docker容器的教程网上也有不少，但是今天还是想来写一写。 你搜.Net c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kklldog/p/core_in_docker.html</dc:identifier>
</item>
<item>
<title>十大排序算法，看这篇就够了(附完整代码/动图/优质文章) - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/10404197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/10404197.html</guid>
<description>&lt;h3 id=&quot;说明&quot;&gt;说明&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;十大排序算法&lt;/strong&gt;可以说是每个程序员都必须得掌握的了，花了一天的时间把代码实现且整理了一下，为了方便大家学习，我把它整理成一篇文章，每种算法会有简单的&lt;strong&gt;算法思想描述&lt;/strong&gt;，为了方便大家理解，我还找来了&lt;strong&gt;动图演示&lt;/strong&gt;；这还不够，我还附上了对应的&lt;strong&gt;优质文章&lt;/strong&gt;，看完不懂你来砍我，觉得不错就给我来个&lt;strong&gt;好看&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;术语铺垫&quot;&gt;术语铺垫&lt;/h3&gt;
&lt;p&gt;有些人可能不知道什么是稳定排序、原地排序、时间复杂度、空间复杂度，我这里先简单解释一下：&lt;/p&gt;
&lt;p&gt;1、稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序。&lt;/p&gt;
&lt;p&gt;2、非稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序。&lt;/p&gt;
&lt;p&gt;3、原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。&lt;/p&gt;
&lt;p&gt;4、非原地排序：需要利用额外的数组来辅助排序。&lt;/p&gt;
&lt;p&gt;5、时间复杂度：一个算法执行所消耗的时间。&lt;/p&gt;
&lt;p&gt;6、空间复杂度：运行完一个算法所需的内存大小。&lt;/p&gt;
&lt;h3 id=&quot;十大排序讲解顺序&quot;&gt;十大排序讲解顺序&lt;/h3&gt;
&lt;p&gt;为了方便大家查找，我这里弄一个伪目录，没有跳转功能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;选择排序&lt;/li&gt;
&lt;li&gt;插入排序&lt;/li&gt;
&lt;li&gt;冒泡排序
&lt;ul&gt;&lt;li&gt;非优化版本&lt;/li&gt;
&lt;li&gt;优化版本&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;li&gt;归并排序
&lt;ul&gt;&lt;li&gt;递归式归并排序&lt;/li&gt;
&lt;li&gt;非递归式归并排序&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;基数排序
&lt;ul&gt;&lt;li&gt;非优化版本&lt;/li&gt;
&lt;li&gt;优化版本&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;桶排序&lt;/li&gt;
&lt;li&gt;基数排序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码说明：&lt;/strong&gt;代码我自己写的，并且都是经过好几组数据测试通过，应该没啥问题，如有错，还请反馈下，谢谢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图片说明：&lt;/strong&gt;图片和动画都是在百度搜索的，如有侵权，还望联系我删除，谢谢&lt;/p&gt;
&lt;h3 id=&quot;选择排序&quot;&gt;选择排序&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;过程简单描述：&lt;/strong&gt;&lt;br/&gt;首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为&lt;strong&gt;选择排序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为方便理解我还准备了动图：&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/19/1690433d91bdf5b6?w=100&amp;amp;h=371&amp;amp;f=gif&amp;amp;s=42218&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还是不懂的话我还给你准备了优质的文章讲解：&lt;a href=&quot;https://mp.weixin.qq.com/s/KaPFukstz-0B89KLv49dUw&quot;&gt;选择排序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SelectSort {
    public static int[] selectSort(int[] a) {
        int n = a.length;
        for (int i = 0; i &amp;lt; n - 1; i++) {
            int min = i;
            for (int j = i + 1; j &amp;lt; n; j++) {
                if(a[min] &amp;gt; a[j]) min = j;
            }
            //交换
            int temp = a[i];
            a[i] = a[min];
            a[min] = temp;
        }
        return a;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;性质：1、时间复杂度：O(n2) 2、空间复杂度：O(1) 3、非稳定排序 4、原地排序&lt;/p&gt;
&lt;h3 id=&quot;插入排序&quot;&gt;插入排序&lt;/h3&gt;
&lt;p&gt;我们在玩打牌的时候，你是怎么整理那些牌的呢？一种简单的方法就是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。当我们给无序数组做排序的时候，为了要插入元素，我们需要腾出空间，将其余所有元素在插入之前都向右移动一位，这种算法我们称之为&lt;strong&gt;插入排序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过程简单描述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、从数组第2个元素开始抽取元素。&lt;/p&gt;
&lt;p&gt;2、把它与左边第一个元素比较，如果左边第一个元素比它大，则继续与左边第二个元素比较下去，直到遇到不比它大的元素，然后插到这个元素的右边。&lt;/p&gt;
&lt;p&gt;3、继续选取第3，4，....n个元素,重复步骤 2 ，选择适当的位置插入。&lt;/p&gt;
&lt;p&gt;为方便理解我还准备了动图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168f1097f8c35152?w=828&amp;amp;h=509&amp;amp;f=gif&amp;amp;s=181172&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还是不懂的话我还给你准备了优质的文章讲解：&lt;a href=&quot;https://mp.weixin.qq.com/s/VNvGXsTpGgzUhQlRJ1GsTA&quot;&gt;插入排序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InsertSort {
    public static int[] insertSort(int[] arr) {
        if(arr == null || arr.length &amp;lt; 2)
            return arr;

        int n = arr.length;
        for (int i = 1; i &amp;lt; n; i++) {
            int temp = arr[i];
            int k = i - 1;
            while(k &amp;gt;= 0 &amp;amp;&amp;amp; arr[k] &amp;gt; temp)
                k--;
            //腾出位置插进去,要插的位置是 k + 1;
            for(int j = i ; j &amp;gt; k + 1; j--)
                arr[j] = arr[j-1];
            //插进去
            arr[k+1] = temp;
        }
        return arr;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;性质：1、时间复杂度：O(n2) 2、空间复杂度：O(1) 3、稳定排序 4、原地排序&lt;/p&gt;
&lt;h3 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h3&gt;
&lt;p&gt;1、把第一个元素与第二个元素比较，如果第一个比第二个大，则交换他们的位置。接着继续比较第二个与第三个元素，如果第二个比第三个大，则交换他们的位置....&lt;/p&gt;
&lt;p&gt;我们对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样一趟比较交换下来之后，排在最右的元素就会是最大的数。&lt;/p&gt;
&lt;p&gt;除去最右的元素，我们对剩余的元素做同样的工作，如此重复下去，直到排序完成。&lt;/p&gt;
&lt;p&gt;为方便理解我还准备了动图：&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168f10a1a9a15d47?w=801&amp;amp;h=315&amp;amp;f=gif&amp;amp;s=160821&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还是不懂的话我还给你准备了优质的文章讲解：&lt;a href=&quot;https://mp.weixin.qq.com/s/6mzB4X5D8AY9F20c_mlQFQ&quot;&gt;冒泡排序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BubbleSort {
    public static int[] bubbleSort(int[] arr) {
        if (arr == null || arr.length &amp;lt; 2) {
            return arr;
        }
        int n = arr.length;
        for (int i = 0; i &amp;lt; n; i++) {
            for (int j = 0; j &amp;lt; n -i - 1; j++) {
                if (arr[j + 1] &amp;lt; arr[j]) {
                    int t = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = t;
                }
            }
        }
        return arr;
    }
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;性质：1、时间复杂度：O(n2) 2、空间复杂度：O(1) 3、稳定排序 4、原地排序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化一下冒泡排序的算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假如从开始的第一对到结尾的最后一对，相邻的元素之间都没有发生交换的操作，这意味着右边的元素总是大于等于左边的元素，此时的数组已经是有序的了，我们无需再对剩余的元素重复比较下去了。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BubbleSort {
    public static int[] bubbleSort(int[] arr) {
        if (arr == null || arr.length &amp;lt; 2) {
            return arr;
        }
        int n = arr.length;
        for (int i = 0; i &amp;lt; n; i++) {
            boolean flag = true;
            for (int j = 0; j &amp;lt; n -i - 1; j++) {
                if (arr[j + 1] &amp;lt; arr[j]) {
                    flag = false;
                    int t = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = t;
                }
            }
            //一趟下来是否发生位置交换
            if(false)
                break;
        }
        return arr;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;希尔排序&quot;&gt;希尔排序&lt;/h3&gt;
&lt;p&gt;希尔排序可以说是&lt;strong&gt;插入排序&lt;/strong&gt;的一种变种。无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n - 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。&lt;/p&gt;
&lt;p&gt;希尔排序就是为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序。&lt;/p&gt;
&lt;p&gt;希尔排序的思想是采用插入排序的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。&lt;/p&gt;
&lt;p&gt;为方便理解我还准备了图片：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168f0a68c61a9d87?w=1494&amp;amp;h=1558&amp;amp;f=png&amp;amp;s=454239&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还是不懂的话我还给你准备了优质的文章讲解：&lt;a href=&quot;https://mp.weixin.qq.com/s/4kJdzLB7qO1sES2FEW0Low&quot;&gt;希尔排序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ShellSort {
    public static int[] shellSort(int arr[]) {
        if (arr == null || arr.length &amp;lt; 2) return arr;
        int n = arr.length;
        // 对每组间隔为 h的分组进行排序，刚开始 h = n / 2;
        for (int h = n / 2; h &amp;gt; 0; h /= 2) {
            //对各个局部分组进行插入排序
            for (int i = h; i &amp;lt; n; i++) {
                // 将arr[i] 插入到所在分组的正确位置上
                insertI(arr, h, i);
            }
     }
     return arr;
    }

    /**
     * 将arr[i]插入到所在分组的正确位置上
     * arr[i]] 所在的分组为 ... arr[i-2*h],arr[i-h], arr[i+h] ...
     */
    private static void insertI(int[] arr, int h, int i) {
        int temp = arr[i];
        int k;
        for (k = i - h; k &amp;gt; 0 &amp;amp;&amp;amp; temp &amp;lt; arr[k]; k -= h) {
            arr[k + h] = arr[k];
        }
        arr[k + h] = temp;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，&lt;strong&gt;对各个分组进行插入的时候并不是先对一个组排序完了再来对另一个组排序，而是轮流对每个组进行排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;性质：1、时间复杂度：O(nlogn) 2、空间复杂度：O(1) 3、非稳定排序 4、原地排序&lt;/p&gt;
&lt;h3 id=&quot;归并排序&quot;&gt;归并排序&lt;/h3&gt;
&lt;p&gt;将一个大的无序数组有序，我们可以把大的数组分成两个，然后对这两个数组分别进行排序，之后在把这两个数组合并成一个有序的数组。由于两个小的数组都是有序的，所以在合并的时候是很快的。&lt;/p&gt;
&lt;p&gt;通过递归的方式将大的数组一直分割，直到数组的大小为 1，此时只有一个元素，那么该数组就是有序的了，之后再把两个数组大小为1的合并成一个大小为2的，再把两个大小为2的合并成4的 ..... 直到全部小的数组合并起来。&lt;/p&gt;
&lt;p&gt;为方便理解我还准备了动图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168f10889079af19?w=300&amp;amp;h=180&amp;amp;f=gif&amp;amp;s=99504&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还是不懂的话我还给你准备了优质的文章讲解：&lt;a href=&quot;https://mp.weixin.qq.com/s/YNF-6vY5m2Q_kEXJbep5NQ&quot;&gt;归并排序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MergeSort {
    // 归并排序
    public static int[] mergeSort(int[] arr, int left, int right) {
        // 如果 left == right，表示数组只有一个元素，则不用递归排序
        if (left &amp;lt; right) {
            // 把大的数组分隔成两个数组
            int mid = (left + right) / 2;
            // 对左半部分进行排序
            arr = sort(arr, left, mid);
            // 对右半部分进行排序
            arr = sort(arr, mid + 1, right);
            //进行合并
            merge(arr, left, mid, right);
        }
        return arr;
    }

    // 合并函数，把两个有序的数组合并起来
    // arr[left..mif]表示一个数组，arr[mid+1 .. right]表示一个数组
    private static void merge(int[] arr, int left, int mid, int right) {
        //先用一个临时数组把他们合并汇总起来
        int[] a = new int[right - left + 1];
        int i = left;
        int j = mid + 1;
        int k = 0;
        while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) {
            if (arr[i] &amp;lt; arr[j]) {
                a[k++] = arr[i++];
            } else {
                a[k++] = arr[j++];
            }
        }
        while(i &amp;lt;= mid) a[k++] = arr[i++];
        while(j &amp;lt;= right) a[k++] = arr[j++];
        // 把临时数组复制到原数组
        for (i = 0; i &amp;lt; k; i++) {
            arr[left++] = a[i];
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;性质：1、时间复杂度：O(nlogn) 2、空间复杂度：O(n) 3、稳定排序 4、非原地排序&lt;/p&gt;
&lt;p&gt;然而面试官要你写个&lt;strong&gt;非递归式&lt;/strong&gt;的归并排序怎么办？别怕，我这还撸了个非递归式的归并排序，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MergeSort {
    // 非递归式的归并排序
    public static int[] mergeSort(int[] arr) {
        int n = arr.length;
        // 子数组的大小分别为1，2，4，8...
        // 刚开始合并的数组大小是1，接着是2，接着4....
        for (int i = 1; i &amp;lt; n; i += i) {
            //进行数组进行划分
            int left = 0;
            int mid = left + i - 1;
            int right = mid + i;
            //进行合并，对数组大小为 i 的数组进行两两合并
            while (right &amp;lt; n) {
                // 合并函数和递归式的合并函数一样
                merge(arr, left, mid, right);
                left = right + 1;
                mid = left + i - 1;
                right = mid + i;
            }
            // 还有一些被遗漏的数组没合并，千万别忘了
            // 因为不可能每个字数组的大小都刚好为 i
            if (left &amp;lt; n &amp;amp;&amp;amp; mid &amp;lt; n) {
                merge(arr, left, mid, n - 1);
            }
        }
        return arr;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;快速排序&quot;&gt;快速排序&lt;/h3&gt;
&lt;p&gt;我们从数组中选择一个元素，我们把这个元素称之为&lt;strong&gt;中轴元素&lt;/strong&gt;吧，然后把数组中所有小于中轴元素的元素放在其左边，所有大于或等于中轴元素的元素放在其右边，显然，此时中轴元素所处的位置的是&lt;strong&gt;有序的&lt;/strong&gt;。也就是说，我们无需再移动中轴元素的位置。&lt;/p&gt;
&lt;p&gt;从中轴元素那里开始把大的数组切割成两个小的数组(两个数组都不包含中轴元素)，接着我们通过递归的方式，让中轴元素左边的数组和右边的数组也重复同样的操作，直到数组的大小为1，此时每个元素都处于&lt;strong&gt;有序的位置&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为方便理解我还准备了动图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168f0e697158a4b9?w=811&amp;amp;h=252&amp;amp;f=gif&amp;amp;s=335061&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还是不懂的话我还给你准备了优质的文章讲解：&lt;a href=&quot;https://mp.weixin.qq.com/s/N9dGTUWip-sLJzH3HMb8Aw&quot;&gt;不要在问我快速排序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class QuickSort {
    public static int[] quickSort(int[] arr, int left, int right) {
        if (left &amp;lt; right) {
            //获取中轴元素所处的位置
            int mid = partition(arr, left, right);
            //进行分割
            arr = sort(arr, left, mid - 1);
            arr = sort(arr, mid + 1, right);
        }
        return arr;
    }

    private static int partition(int[] arr, int left, int right) {
        //选取中轴元素
        int pivot = arr[left];
        int i = left + 1;
        int j = right;
        while (true) {
            // 向右找到第一个小于等于 pivot 的元素位置
            while (i &amp;lt;= j &amp;amp;&amp;amp; arr[i] &amp;lt;= pivot) i++;
            // 向左找到第一个大于等于 pivot 的元素位置
            while(i &amp;lt;= j &amp;amp;&amp;amp; arr[j] &amp;gt;= pivot ) j--;
            if(i &amp;gt;= j)
                break;
            //交换两个元素的位置，使得左边的元素不大于pivot,右边的不小于pivot
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        arr[left] = arr[j];
        // 使中轴元素处于有序的位置
        arr[j] = pivot;
        return j;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;性质：1、时间复杂度：O(nlogn) 2、空间复杂度：O(logn) 3、非稳定排序 4、原地排序&lt;/p&gt;
&lt;h3 id=&quot;堆排序&quot;&gt;堆排序&lt;/h3&gt;
&lt;p&gt;堆的特点就是堆顶的元素是一个&lt;strong&gt;最值&lt;/strong&gt;，大顶堆的堆顶是最大值，小顶堆则是最小值。&lt;/p&gt;
&lt;p&gt;堆排序就是把堆顶的元素与最后一个元素交换，交换之后破坏了堆的特性，我们再把堆中剩余的元素再次构成一个大顶堆，然后再把堆顶元素与最后第二个元素交换....如此往复下去，等到剩余的元素只有一个的时候，此时的数组就是有序的了。&lt;/p&gt;
&lt;p&gt;为方便理解我还准备了动图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168f106c7a6a89d3?w=600&amp;amp;h=600&amp;amp;f=gif&amp;amp;s=60757&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还是不懂的话我还给你准备了优质的文章讲解：&lt;a href=&quot;https://mp.weixin.qq.com/s/m1pt_M-YAp-kjHbbP1lzSA&quot;&gt;堆排序是什么鬼？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Head {
    // 堆排序
    public static int[] headSort(int[] arr) {
        int n = arr.length;
        //构建大顶堆
        for (int i = (n - 2) / 2; i &amp;gt;= 0; i--) {
            downAdjust(arr, i, n - 1);
        }
        //进行堆排序
        for (int i = n - 1; i &amp;gt;= 1; i--) {
            // 把堆顶元素与最后一个元素交换
            int temp = arr[i];
            arr[i] = arr[0];
            arr[0] = temp;
            // 把打乱的堆进行调整，恢复堆的特性
            downAdjust(arr, 0, i - 1);
        }
        return arr;
    }
    
        //下沉操作
    public static void downAdjust(int[] arr, int parent, int n) {
        //临时保存要下沉的元素
        int temp = arr[parent];
        //定位左孩子节点的位置
        int child = 2 * parent + 1;
        //开始下沉
        while (child &amp;lt;= n) {
            // 如果右孩子节点比左孩子大，则定位到右孩子
            if(child + 1 &amp;lt;= n &amp;amp;&amp;amp; arr[child] &amp;lt; arr[child + 1])
                child++;
            // 如果孩子节点小于或等于父节点，则下沉结束
            if (arr[child] &amp;lt;= temp ) break;
            // 父节点进行下沉
            arr[parent] = arr[child];
            parent = child;
            child = 2 * parent + 1;
        }
        arr[parent] = temp;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;性质：1、时间复杂度：O(nlogn) 2、空间复杂度：O(1) 3、非稳定排序 4、原地排序&lt;/p&gt;
&lt;h3 id=&quot;计数排序&quot;&gt;计数排序&lt;/h3&gt;
&lt;p&gt;计数排序是一种适合于最大值和最小值的差值不是不是很大的排序。&lt;/p&gt;
&lt;p&gt;基本思想：就是把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] = m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。&lt;/p&gt;
&lt;p&gt;为方便理解我还准备了动图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168f0eed3a6418f5?w=1012&amp;amp;h=557&amp;amp;f=gif&amp;amp;s=270753&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还是不懂的话我还给你准备了优质的文章讲解：&lt;a href=&quot;https://mp.weixin.qq.com/s/bIQnEL2eIehQtpTKrkc7uw&quot;&gt;什么是计数排序？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Counting {
    public static int[] countSort(int[] arr) {
        if(arr == null || arr.length &amp;lt; 2) return arr;

        int n = arr.length;
        int max = arr[0];
        // 寻找数组的最大值
        for (int i = 1; i &amp;lt; n; i++) {
            if(max &amp;lt; arr[i])
                max = arr[i];
        }
        //创建大小为max的临时数组
        int[] temp = new int[max + 1];
        //统计元素i出现的次数
        for (int i = 0; i &amp;lt; n; i++) {
            temp[arr[i]]++;
        }
        int k = 0;
        //把临时数组统计好的数据汇总到原数组
        for (int i = 0; i &amp;lt;= max; i++) {
            for (int j = temp[i]; j &amp;gt; 0; j--) {
                arr[k++] = i;
            }
        }
        return arr;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;性质：1、时间复杂度：O(n+k) 2、空间复杂度：O(k) 3、稳定排序 4、非原地排序&lt;/p&gt;
&lt;p&gt;注：K表示临时数组的大小，下同&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化一下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的代码中，我们是根据 max 的大小来创建对应大小的数组，假如原数组只有10个元素，并且最小值为 min = 10000，最大值为 max = 10005，那我们创建 10005 + 1 大小的数组不是很吃亏，最大值与最小值的差值为 5，所以我们创建大小为6的临时数组就可以了。&lt;/p&gt;
&lt;p&gt;也就是说，我们创建的临时数组大小 (max - min + 1)就可以了，然后在把 min作为偏移量。优化之后的代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Counting {
    public static int[] sort(int[] arr) {
        if(arr == null || arr.length &amp;lt; 2) return arr;

        int n = arr.length;
        int min = arr[0];
        int max = arr[0];
        // 寻找数组的最大值与最小值
        for (int i = 1; i &amp;lt; n; i++) {
            if(max &amp;lt; arr[i])
                max = arr[i];
            if(min &amp;gt; arr[i])
                min = arr[i];
        }
        int d = max - min + 1;
        //创建大小为max的临时数组
        int[] temp = new int[d];
        //统计元素i出现的次数
        for (int i = 0; i &amp;lt; n; i++) {
            temp[arr[i] - min]++;
        }
        int k = 0;
        //把临时数组统计好的数据汇总到原数组
        for (int i = 0; i &amp;lt; d; i++) {
            for (int j = temp[i]; j &amp;gt; 0; j--) {
                arr[k++] = i + min;
            }
        }
        return arr;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;桶排序&quot;&gt;桶排序&lt;/h3&gt;
&lt;p&gt;桶排序就是把最大值和最小值之间的数进行瓜分，例如分成 10 个区间，10个区间对应10个桶，我们把各元素放到对应区间的桶中去，再对每个桶中的数进行排序，可以采用归并排序，也可以采用快速排序之类的。&lt;/p&gt;
&lt;p&gt;之后每个桶里面的数据就是有序的了，我们在进行合并汇总。&lt;/p&gt;
&lt;p&gt;为方便理解我还准备了图片：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168f1005d15c08ba?w=435&amp;amp;h=298&amp;amp;f=png&amp;amp;s=38943&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还是不懂的话我还给你准备了优质的文章讲解：&lt;a href=&quot;https://mp.weixin.qq.com/s/j3ki5PBeQdeABjmEyWvbuA&quot;&gt;什么是桶排序？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class BucketSort {
    public static int[] BucketSort(int[] arr) {
        if(arr == null || arr.length &amp;lt; 2) return arr;

        int n = arr.length;
        int max = arr[0];
        int min = arr[0];
        // 寻找数组的最大值与最小值
        for (int i = 1; i &amp;lt; n; i++) {
            if(min &amp;gt; arr[i])
                min = arr[i];
            if(max &amp;lt; arr[i])
                max = arr[i];
        }
        //和优化版本的计数排序一样，弄一个大小为 min 的偏移值
        int d = max - min;
        //创建 d / 5 + 1 个桶，第 i 桶存放  5*i ~ 5*i+5-1范围的数
        int bucketNum = d / 5 + 1;
        ArrayList&amp;lt;LinkedList&amp;lt;Integer&amp;gt;&amp;gt; bucketList = new ArrayList&amp;lt;&amp;gt;(bucketNum);
        //初始化桶
        for (int i = 0; i &amp;lt; bucketNum; i++) {
            bucketList.add(new LinkedList&amp;lt;Integer&amp;gt;());
        }
        //遍历原数组，将每个元素放入桶中
        for (int i = 0; i &amp;lt; n; i++) {
            bucketList.get((arr[i]-min)/d).add(arr[i] - min);
        }
        //对桶内的元素进行排序，我这里采用系统自带的排序工具
        for (int i = 0; i &amp;lt; bucketNum; i++) {
            Collections.sort(bucketList.get(i));
        }
        //把每个桶排序好的数据进行合并汇总放回原数组
        int k = 0;
        for (int i = 0; i &amp;lt; bucketNum; i++) {
            for (Integer t : bucketList.get(i)) {
                arr[k++] = t + min;
            }
        }
        return arr;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;性质：1、时间复杂度：O(n+k) 2、空间复杂度：O(n+k) 3、稳定排序 4、非原地排序&lt;/p&gt;
&lt;p&gt;注：k 表示桶的个数，下同&lt;/p&gt;
&lt;h3 id=&quot;基数排序&quot;&gt;基数排序&lt;/h3&gt;
&lt;p&gt;基数排序的排序思路是这样的：先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小......&lt;/p&gt;
&lt;p&gt;排到最后，就是一组有序的元素了。不过，他在以某位数进行排序的时候，是用“桶”来排序的。&lt;/p&gt;
&lt;p&gt;由于某位数（个位/十位....，不是一整个数）的大小范围为0-9，所以我们需要10个桶，然后把具有相同数值的数放进同一个桶里，之后再把桶里的数按照0号桶到9号桶的顺序取出来，这样一趟下来，按照某位数的排序就完成了&lt;/p&gt;
&lt;p&gt;为方便理解我还准备了动图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168f103c7c0ad917?w=1012&amp;amp;h=574&amp;amp;f=gif&amp;amp;s=199096&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还是不懂的话我还给你准备了优质的文章讲解：&lt;a href=&quot;https://mp.weixin.qq.com/s/sBKAlUYQb0ziReLWsdAylQ&quot;&gt;为什么说O(n)复杂度的基数排序没有快速排序快？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RadioSort {

    public static int[] radioSort(int[] arr) {
        if(arr == null || arr.length &amp;lt; 2) return arr;

        int n = arr.length;
        int max = arr[0];
        // 找出最大值
        for (int i = 1; i &amp;lt; n; i++) {
            if(max &amp;lt; arr[i]) max = arr[i];
        }
        // 计算最大值是几位数
        int num = 1;
        while (max / 10 &amp;gt; 0) {
            num++;
            max = max / 10;
        }
        // 创建10个桶
        ArrayList&amp;lt;LinkedList&amp;lt;Integer&amp;gt;&amp;gt; bucketList = new ArrayList&amp;lt;&amp;gt;(10);
        //初始化桶
        for (int i = 0; i &amp;lt; 10; i++) {
            bucketList.add(new LinkedList&amp;lt;Integer&amp;gt;());
        }
        // 进行每一趟的排序，从个位数开始排
        for (int i = 1; i &amp;lt;= num; i++) {
            for (int j = 0; j &amp;lt; n; j++) {
                // 获取每个数最后第 i 位是数组
                int radio = (arr[j] / (int)Math.pow(10,i-1)) % 10;
                //放进对应的桶里
                bucketList.get(radio).add(arr[j]);
            }
            //合并放回原数组
            int k = 0;
            for (int j = 0; j &amp;lt; 10; j++) {
                for (Integer t : bucketList.get(j)) {
                    arr[k++] = t;
                }
                //取出来合并了之后把桶清光数据
                bucketList.get(j).clear();
            }
        }
        return arr;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;性质：1、时间复杂度：O(kn) 2、空间复杂度：O(n+k) 3、稳定排序 4、非原地排序&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;用一张图汇总了10大排序算法的性质&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/15/168f1118c4a26b1e?w=966&amp;amp;h=588&amp;amp;f=png&amp;amp;s=370063&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你是复习/学习十大排序算法，一定要自己不看示例代码手动实现一遍，一定要自己不看示例代码手动实现一遍，一定要自己不看示例代码手动实现一遍。&lt;/p&gt;
&lt;p&gt;这波整理，留下&lt;strong&gt;点赞&lt;/strong&gt; + 鼓励我一下？&lt;/p&gt;
&lt;p&gt;最后推广下我的公众号：&lt;strong&gt;苦逼的码农&lt;/strong&gt;，文章都会首发于我的公众号，期待各路英雄的关注交流。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxNzg0MDc1Mg==&amp;amp;mid=2247485098&amp;amp;idx=1&amp;amp;sn=d4fa7edfa4fdc7f4960620fac9b743c2&amp;amp;chksm=f9934cb5cee4c5a33be86743d467d6a6de0a733ee9f083bb1d7febede79835758e2212d3d55b&amp;amp;token=1526394195&amp;amp;lang=zh_CN#rd&quot;&gt;2018原创文章汇总&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 16:01:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>说明 十大排序算法 可以说是每个程序员都必须得掌握的了，花了一天的时间把代码实现且整理了一下，为了方便大家学习，我把它整理成一篇文章，每种算法会有简单的 算法思想描述 ，为了方便大家理解，我还找来了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/10404197.html</dc:identifier>
</item>
<item>
<title>Java——多态浅析 - SakuraOne</title>
<link>http://www.cnblogs.com/myworld7/p/10404149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myworld7/p/10404149.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在面向对象程序设计语言中，多态是继数据抽象和继承之后的第三种基本特性。多态的含义是什么，有什么作用以及在Java中是怎么实现的？下面将做介绍。&lt;/p&gt;
&lt;h2 id=&quot;什么是多态&quot;&gt;什么是多态&lt;/h2&gt;
&lt;p&gt;简单点说就是“一个接口，多种实现”，不同类对同一操作体现出不同效果。设想有一个性质，&lt;strong&gt;一个引用变量所指向的确切类型和该引用变量调用的方法是哪个类中的，这个两个问题在编译期间是不确定的，在程序运行期间才可确定&lt;/strong&gt;。于是，一份代码就可以适用于多个不同的类，只要这份代码中有一个引用变量可以指向这些不同的类的对象。&lt;strong&gt;在程序运行期间，就可以动态选择多个不同的对象或者多个不同的方法运行，这就是多态性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;也可以简单的使用Java核心卷中的一句话说：一个引用变量可以指示多种实际类型的现象被称为多态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要什么样的引用变量才可以指向多种不同类的对象呢？那就需要是基类引用变量。这就涉及到&lt;code&gt;向上转型&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;向上转型&quot;&gt;向上转型&lt;/h3&gt;
&lt;p&gt;简单一句话就是：基类（父类）引用指向子类对象。取这个术语属于也是有历史原因的，以传统的类继承图的绘制方法为基础：将根置于页面的顶端，然后逐渐向下。&lt;/p&gt;
&lt;p&gt;为什么基类引用就可以指向子类对象呢？&lt;/p&gt;
&lt;p&gt;这可以以生活中的一个例子来说，狗是对所有品种狗的统称，具体的品种又有哈士奇，拉布拉多犬等。假设我们在路上遇见了一只不知道名字的狗（比如牧羊犬），我们也许会说：那儿有一只狗。此时，我们就做了向上转型，以狗指向了具体的牧羊犬。以范围较大的基类引用去指向范围小的子类。这是以生活中的例子解释，在语言层面其实也可以说明：子类是继承基类而来，所以基类中的所有方法子类也有，可以发送给基类的消息同样也可以发送给子类。使用基类引用也就可以指向子类对象调用这些方法。&lt;/p&gt;
&lt;p&gt;可以使用基类引用指向子类对象，那么可不可以使用子类引用指向基类对象呢？&lt;/p&gt;
&lt;p&gt;是可以的，这就叫做向下转型，但是这存在风险。因为子类中可能会有新增方法，而基类中是没有这些方法的，若是调用这些方法就会抛出&lt;code&gt;ClassCastException&lt;/code&gt;异常。&lt;/p&gt;
&lt;p&gt;介绍了什么是多态，那么就了解它的作用有什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多态的作用&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;多态的一个好处就是可以实现统一管理，需要注意父类不能调用子类特有的方法即父类中没有的方法子类有的方法，若要调用需要向下转型。&lt;/p&gt;
&lt;h2 id=&quot;多态如何实现&quot;&gt;多态如何实现&lt;/h2&gt;
&lt;p&gt;Java中实现多态的三个要求为：&lt;/p&gt;
&lt;p&gt;可以看一个简单的多态例子&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Animal{
    public void eat() { System.out.println(&quot;吃东西&quot;); }
}

class Dog extends Animal{
    public void eat() { System.out.println(&quot;吃狗粮&quot;);}
}

class Cat extends Animal{
    public void eat() { System.out.println(&quot;吃小鱼干&quot;);}
}

public class PloyTest {
    //使用父类引用指向子类对象 调用子类中被重写的方法
    public static void printEatingFood(Animal a) { a.eat();}
    
    public static void main(String[] args) {
        printEatingFood(new Dog());
        printEatingFood(new Cat());
    }
}
/*
output:
吃狗粮
吃小鱼干
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们传入Dog对象时，a.eat()调用的是Dog类中被重写的eat方法；传入Cat对象时，a.eat()调用的是Cat类中被重写的方法。程序在运行过程中，依据我们传入的对象自动地为我们寻找到正确的方法调用。这就是多态技术的实现依据：动态绑定。&lt;/p&gt;
&lt;h3 id=&quot;动态绑定&quot;&gt;动态绑定&lt;/h3&gt;
&lt;p&gt;《Java编程思想》上这样说：运行时父类引用根据其指向的对象，绑定到相应的对象方法上。&lt;/p&gt;
&lt;p&gt;那么这个过程的具体实现是怎样的呢？《Java核心技术卷1》上是这样解释的解释：&lt;/p&gt;
&lt;p&gt;先是要清楚调用对象方法的过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;（&lt;strong&gt;搜索过程&lt;/strong&gt;）编译器查看对象的声明类型和方法名。可能会有同名的重载方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;若是调用x.f(param)&lt;/p&gt;
&lt;p&gt;获得当前类和超类中为public的名为f的方法，即获可能被调用的候选方法&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;（&lt;strong&gt;匹配过程&lt;/strong&gt;）然后，编译器查看调用方法时提供的参数类型，与候选方法进行匹配，此过程也就是重载解析。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;完全匹配，则选择调用该方法，这其中还会存在类型转换，所以过程会比较复杂。最后若是没有找到匹配的，编译器则会报错。&lt;/p&gt;
&lt;p&gt;​ -------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态绑定：&lt;/strong&gt;&lt;br/&gt;若方法是private, static, final或者构造器，那么编译器会知道调用哪个方法，这种方式为静态绑定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态绑定：&lt;/strong&gt;&lt;br/&gt;依赖于隐式参数的实际类型，在运行时才可以确定调用方法，则为动态绑定。&lt;br/&gt;当程序运行，并且采用动态绑定调用方法时，虚拟机会调用与x所引用对象的实际类型最合适的那个类的方法。并且为了避免每次搜索浪费时间，虚拟机会为每个类创建一个方法表。其中包含所有方法的签名和实际调用的方法（包括继承来方法）。&lt;/p&gt;
&lt;h2 id=&quot;一些陷阱和建议&quot;&gt;一些陷阱和建议&lt;/h2&gt;
&lt;h3 id=&quot;域和静态方法&quot;&gt;域和静态方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;我们需要注意只有普通方法调用才可以是多态的，对域的访问将在编译时期进行解析&lt;/strong&gt;。如下面这个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Super{
    public int field = 0;
    public int getField() { return field;}
}

class Sub extends Super{
    public int field = 1;
    public int getField() { return field;}
    public int getSuperField() { return super.getField();}
}

public class FieldAccess {
    public static void main(String[] args) {
        Super sup = new Sub();
        System.out.println(&quot;sup.field=&quot;+sup.field+&quot; sup.getField()=&quot;+sup.getField());
        
        Sub sub = new Sub();
        System.out.println(&quot;sub.getField=&quot;+sub.field+&quot; sub.getField()=&quot;+sub.getField()+
                &quot; sub.getSuperField()=&quot;+sub.getSuperField());
    }
}
/*
output:
sup.field=0 sup.getField()=1
sub.getField=1 sub.getField()=1 sub.getSuperField()=0
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用父类Super的引用sup指向子类Sub类对象，输出域，发现是父类的值。因此，域的访问是编译器解析，不是多态的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果某个方法是静态的，它的行为也不具有多态性&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class StaticSuper{
    public static String staticGet() {
        return &quot;Base staticGet()&quot;;
    }
    
    public String dynamicGet(){
        return &quot;Base dynamicGet()&quot;;
    }
}

class StaticSub extends StaticSuper{
    public static String staticGet() {
        return &quot;Derived staticGet()&quot;;
    }
    
    public String dynamicGet() {
        return &quot;Derived dynamicGet()&quot;;
    }
}

public class OverloadingTest {
    public static void main(String[] args) {
        StaticSuper sup = new StaticSub();  //向上转型
        System.out.println(sup.staticGet());
        System.out.println(sup.dynamicGet());
    }
}
/*
output:
Base staticGet()
Derived dynamicGet()
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由输出可以看出，静态方法是不具有多态性的。静态方法是与类，而非与单个的对象相关联的。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;简要介绍了对于多态的理解，其中存在的不足，希望各位看官不吝赐教。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;《Java编程思想》第四版&lt;/p&gt;
&lt;p&gt;《Java核心技术卷1》第九版&lt;/p&gt;
&lt;p&gt;Java多态性理解，好处及精典实例：&lt;a href=&quot;https://blog.csdn.net/Jian_Yun_Rui/article/details/52937791&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/Jian_Yun_Rui/article/details/52937791&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 15:49:00 +0000</pubDate>
<dc:creator>SakuraOne</dc:creator>
<og:description>前言 在面向对象程序设计语言中，多态是继数据抽象和继承之后的第三种基本特性。多态的含义是什么，有什么作用以及在Java中是怎么实现的？下面将做介绍。 什么是多态 简单点说就是“一个接口，多种实现”，不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myworld7/p/10404149.html</dc:identifier>
</item>
<item>
<title>【设计模式+原型理解】第一章：使用Javascript来巧妙实现经典的设计模式 - 彭胜光</title>
<link>http://www.cnblogs.com/pengshengguang/p/10403690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengshengguang/p/10403690.html</guid>
<description>&lt;p&gt;    刚开始学习设计模式之前，我是没想说要学习设计模式的，我只是因为想学习JS中的原型prototype知识，一开始我想&lt;strong&gt;JS中为什么要存在原型这个东西？&lt;/strong&gt;于是慢慢&lt;strong&gt;通过原型而接触到设计模式&lt;/strong&gt;，后来发现我这个过程是非常正确的，&lt;strong&gt;即先学习设计模式，然后在剖析原型及其原理&lt;/strong&gt;。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    我一开始，都是通过针对原型的知识点去看去学，发现还是理解不了，就算理解了原型，可以说只是停留在表面的知道，你并不懂得如何运用原型？后来，&lt;strong&gt;我通过用设计模式的角度去理解原型prototype，我才焕然大悟&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;    但是在这一篇章里面，并没有说到原型、原型模式，因为如果你要进入设计模式的角度去理解原型，你就必须得了解一下用JS来实现单例模式、工厂模式和构造函数模式，看看Javascript是如果巧妙地实现各种设计模式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;    【单例模式】&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var person1 = {
    &quot;name&quot;: &quot;psg&quot;,
    &quot;age&quot;: 24  
};
var person2 = {
    &quot;name&quot;: &quot;fsf&quot;,
    &quot;age&quot;: 22
};
console.log(person1.name); // -&amp;gt;page
console.log(person1.age); // -&amp;gt;24
console.log(person2 .name); // -&amp;gt;fsf
console.log(person2 .age); // -&amp;gt;22
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;    上面的person1与person2都不是基本数据类型，都是对象数据类型，&lt;strong&gt;对象数据类型的作用&lt;/strong&gt;：把描述同一个事物（同一个对象）的属性和方法放在一个内存空间下，起到了分组的作用（例如person1与person2，都是两个独立开来的栈内存，里面的属性和方法互不影响） -&amp;gt; 于是，我们把这种分组编写代码的模式叫做“单例模式”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;    -&amp;gt; 在“单例模式”中，我们叫person1、person2叫做命名空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    单例模式是一种项目开发中经常使用的模式，因为项目中我们可以使用单例模式进行“&lt;strong&gt;模块化&lt;/strong&gt;”开发。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;命名空间的作用&lt;/strong&gt;，看下面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// searchRender 是一个命名空间
var searchRender = {
    change: function() {
        this.clickEvent(); //这里this你暂时看不出来是谁，因为只有执行的时候，才知道
    }  ,
    clickEvent: function() {

    }
};
// 但是想要使用searchRender里面的change方法，你必须如下调用
serachRender.clickEvent();
// 所以change方法里面的this，只能是searchRender
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    如果你学的比较深入，看上面的代码你就能看出命名空间的作用是什么了，就是能灵活运用this。&lt;/p&gt;
&lt;p&gt;    这里使用this的好处：&lt;strong&gt;当命名空间改名字的时候，你并不用改里面的调用者，因为this就代表命名空间。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    总结&lt;/p&gt;
&lt;p&gt;    -&amp;gt;&lt;strong&gt;单例模式解决了分组的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    -&amp;gt;但是单例模式的弊端也很明显，因为他仍然是手工作业模式，效率比较低，于是“&lt;strong&gt;工厂模式&lt;/strong&gt;”就站出来解决了这个问题，因为工厂模式可以&lt;strong&gt;&lt;span&gt;批量生产&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;   【工厂模式】&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function createJsPerson(name, age) {
    var obj = {};
    obj.name = name;
    obj.age = age;
    obj.writeJs = function() {
        console.log(&quot;My name is &quot; + this.name + &quot;, i can write js.&quot;);
    };
    return obj;
}
var p1 = createJsPerson(&quot;psg&quot;, 24);
var p2 = createJsPerson(&quot;fsf&quot;, 22)
p1.writeJs(); // -&amp;gt;My name is psg, i can write js.
p2.writeJs(); // -&amp;gt;My name is fsf, i can write js.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    这样写，可以减少重复代码的产出，你只需要写好公共的代码，把他放进一个方法里面，然后通过接受不同的参数，可以创建不同的对象，效率比单例模式高多了！&lt;/p&gt;
&lt;p&gt;    接下来，讲一下“构造函数模式”，它的样子跟“工厂模式”&lt;strong&gt;非常相似&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;【构造函数模式】&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function CreateJsPerson(name, age) {
    // var obj = {};
    this.name = name;
    this.age = age;
    this.writeJs = function() {
        console.log(&quot;My name is &quot; + this.name + &quot;, i can write js.&quot;);
    }
    // return obj;
}
var p = new CreateJsPerson(&quot;psg&quot;, 24);
p.writeJs();  // -&amp;gt; My name is psg, i can write js.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    看到没有，CreateJsPerson这个方法，&lt;strong&gt;&lt;span data-darkreader-inline-color=&quot;&quot;&gt;根本不会像工厂模式那样最后返回给你一个对象，它不需要，因为当你通过使用new关键字，浏览器会在后台中自己新建一个对象，然后通过this来指向该新建对象，最后自动默认返回一个对象给你&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;-&amp;gt;其实我们有时也会不经意用到使用构造函数模式新进实例，例如创建一个数组&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
// 创建一个数组
var ary = []; // 字面量方式
var arry = new Array(); // 实例创建的方式-》构造函数模式执行的方式
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;    &lt;strong&gt;-&amp;gt;知识点一： 构造函数模式和工厂模式的区别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;1）执行的时候&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;普通函数执行&lt;/strong&gt; -&amp;gt; createJsPerson() -&amp;gt; 这时候，createJsPerson是一个普通函数名&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;构造函数模式&lt;/strong&gt; -&amp;gt; new CreateJsPerson() -&amp;gt; 通过new执行后，CreateJsPerson就是一个类 -&amp;gt; 开头大写是因为约定了，大写开头的函数就是表示一个类&lt;/p&gt;
&lt;p&gt;                               new  出来的返回值（p），就是CreateJsPerson这个类的一个实例&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;2）在函数执行的时候&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;相同点&lt;/strong&gt; -&amp;gt; 都是形成私有作用域，然后形参赋值 -&amp;gt; 预解释 -&amp;gt; 代码从上到下执行(类和普通函数一样，它也有普通函数的一面)&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;不同点&lt;/strong&gt; -&amp;gt; 在代码执行之前， 不用自己再手动创建对象，浏览器会默认的创建一个对象数据类型的值（类的实例），并作为函数返回值自动返回。&lt;/p&gt;

&lt;p&gt;     &lt;strong&gt;-&amp;gt;知识点二： 构造函数也是函数数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    在JS中，所有类都是函数数据类型，createJsPerson是函数数据类型， new CreateJsPerson也是函数数据类型，CreateJsPerson它通过new执行变成了一类，但它本身也是一个普通的函数。&lt;/p&gt;
&lt;p&gt;    但是，JS中所有类的实例都是对象数据类型。&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt; -&amp;gt;知识点三： 如果给构造函数里面添加私有变量，它返回值（实例）会存在此变量吗？&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
unction Fn() {
    var num = 10;
}
var obj = new Fn;
console.log(num); // -&amp;gt; undefined
console.log(obj.num); // -&amp;gt; undefined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    上面例子可以看出，这里的num只是函数私有作用域里面的一个私有变量，它跟实例没有任何关系。&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt; -&amp;gt;知识点四： 如果给构造函数直接返回一个对象，或者直接返回一个基本数据类型，那个实例到底还是不是浏览器默认返回的实例呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    1）手动添加自动返回基本数据类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function Fn() {
    var num = 10;
    return 100; // 代码无效
}
var f1 = new Fn;
console.log(f1); // -&amp;gt; Object，这个Object就是空的，也是浏览器默认返回的对象
// 也就是说，return 100 这句代码无效
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    2）手动添加自动返回对象数据类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function Fn() {
    var num = 10;
    return {name: 'psg'}; // 代码有效
}
var f1 = new Fn;
console.log(f1); // -&amp;gt; Object，这个Object就是 {name: 'psg'}
// 也就是说，强制返回的手动添加的实例对象，完全KO覆盖掉浏览器默认返回的实例对象
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    总结上面两点在构造函数模式当中，浏览器会默认把我们的实例返回（返回的是一个对象数据类型的值）&lt;br/&gt;    // 但是如果我们手动返回值，分两种情况&lt;br/&gt;           // ******情况一，返回的是一个基本数据类型的值，当前实例不变&lt;br/&gt;           // 例如： return 100&lt;br/&gt;           // 那么浏览器返回的值仍然是浏览器默认创建的对象&lt;br/&gt;           // ******情况二，返回的是一个引用数据类型的值，当前实例会被自己返回的值覆盖掉&lt;br/&gt;           // 例如： return {name: &quot;psg&quot;}&lt;br/&gt;           // 那么原先浏览器返回的默认值，将会被自己的手动创建返回的对象给覆盖掉。注意，一定要是对象哦&lt;/p&gt;
&lt;pre data-darkreader-inline-bgcolor=&quot;&quot; data-darkreader-inline-color=&quot;&quot;&gt;
&lt;span data-darkreader-inline-color=&quot;&quot;&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;     &lt;strong&gt;-&amp;gt;知识点五： 检测某一个实例是否属于这个类 -&amp;gt; instanceof&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;下面这个例子很有意思！&lt;/strong&gt;！结合了知识点四。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function Fn() {
    var num = 10;
    // return 100
    return {name: 'psg'}
}
var f1 = new Fn;
console.log(f1 instanceof Fn); // -&amp;gt;false , 因为f1不是浏览器创建的默认实例
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    &lt;strong&gt; -&amp;gt;知识点六：检测某个属性是否属于某个实例，检测某个属性是否为该对象的公有属性？&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
function Fn1() {
    this.x = 100;
    this.getX = function() {
        console.log(this.x);
    }
}
var fun1 = new Fn1;
var fun2 = new Fn1;
console.log(fun1.getX() === fun2.getX());
// -&amp;gt; fun1和fun2都是Fn1这个类的实例，都拥有x和getX这两个属性，但是这两个属性是各自私有的属性
// 但是如何检测某一个属性是否属于某一个实例
// in： 检测某一个属性是否属于某一个实例，不管是私有属性还是公有属性，用in都是用来检测这个属性是否属于这个对象
console.log(&quot;getX&quot; in fun1); // -&amp;gt; true

// hasOwnProperty: 用来检测某个属性是否为这个对象的私有属性，这个方法只能检测私有的属性
console.log(fun1.hasOwnProperty(&quot;getX&quot;)); // -&amp;gt; true

// 思考，检测某一个属性是否为该对象的“公有属性”，自己写一个 hasPubProperty

function hasPubProperty(obj, attr) {
    // 首先保证它是一个对象的属性，并且不是私有属性，那就肯定就是公有属性了
    return ((attr in obj) &amp;amp;&amp;amp; !obj.hasOwnProperty(attr));
}

console.log(hasPubProperty(fun1, &quot;getX&quot;)); // -&amp;gt; false;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    这一章，主要讲了单例模式、工厂模式和构造函数模式，同时也因为工厂模式与构造函数模式代码上非常相似，但是实现原理完全不相同，所以也讲了构造函数模式实例化对象的原理过程，以及他们两的区别。&lt;/p&gt;
&lt;p&gt;    下一章 的&lt;strong&gt;《【设计模式+原型理解】第二章：JS中为什么要存在原型prototype这个东西？》&lt;/strong&gt;会讲到原型模式，准确来说是基于构造函数模式的原型模式，因为只有讲到构造函数模式，你才知道构造函数的优缺点，原型模式就是为了解决并改进构造函数的。&lt;/p&gt;
&lt;p&gt;    待续....&lt;/p&gt;

</description>
<pubDate>Tue, 19 Feb 2019 15:45:00 +0000</pubDate>
<dc:creator>彭胜光</dc:creator>
<og:description>刚开始学习设计模式之前，我是没想说要学习设计模式的，我只是因为想学习JS中的原型prototype知识，一开始我想JS中为什么要存在原型这个东西？于是慢慢通过原型而接触到设计模式，后来发现我这个过程是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pengshengguang/p/10403690.html</dc:identifier>
</item>
<item>
<title>SLAM+语音机器人DIY系列：（四）差分底盘设计——2.stm32主控软件设计 - 小虎哥哥爱学习</title>
<link>http://www.cnblogs.com/hiram-zhang/p/10403822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hiram-zhang/p/10403822.html</guid>
<description>&lt;p&gt;&lt;span&gt;运动底盘是移动机器人的重要组成部分，不像激光雷达、IMU、麦克风、音响、摄像头这些通用部件可以直接买到，很难买到通用的底盘。一方面是因为底盘的尺寸结构和参数是要与具体机器人匹配的；另一方面是因为底盘包含软硬件整套解决方案，是很多机器人公司的核心技术，一般不会随便公开。出于强烈的求知欲与学习热情，我想自己DIY一整套&lt;span&gt;两轮差分底盘&lt;/span&gt;，并且将完整的设计过程公开出去供大家学习。说干就干，本章节主要内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.stm32主控硬件设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.stm32主控软件设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.底盘通信协议&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.底盘ROS驱动开发&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.底盘PID控制参数整定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.底盘里程计标&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;上一节搭建好了底盘的&lt;/span&gt;stm32&lt;span&gt;主控硬件，现在就来说说怎么开发配套的&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;软件。关于建立&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;工程、使用&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;开发库、&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;软件调试方法等基础知识就不多说了，有需要的可以查阅相关资料学习，我觉得&lt;/span&gt;&lt;a href=&quot;http://www.openedv.com/&quot;&gt;&lt;span&gt;http://www.openedv.com&lt;/span&gt;&lt;/a&gt;&lt;span&gt;《正点原子》的开发资料写的还可以。我就直接从底盘控制的项目入手，直接进行项目中各个功能需求开始分析讲解，如图&lt;/span&gt;11&lt;span&gt;，是我的底盘控制&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;工程项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219223840131-90996817.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;11&lt;span&gt;）底盘控制&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;工程项目&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.1.&lt;span&gt;电机控制                &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;电机控制分为两个部分（电机转向控制、电机转速控制），这些都集成在了电机驱动芯片&lt;/span&gt;TB6612FNG&lt;span&gt;里面，所以只需要用单片机的&lt;/span&gt;&lt;span&gt;IO&lt;/span&gt;&lt;span&gt;口产生控制转向的高低电平和控制转速的&lt;/span&gt;&lt;span&gt;PWM&lt;/span&gt;&lt;span&gt;波就能实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，初始化&lt;/span&gt;IO&lt;span&gt;口作为输出脚，用于产生高低电平输出来控制转向，实例代码如图&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219224045542-1305035799.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;12&lt;span&gt;）电机转向控制&lt;/span&gt;&lt;span&gt;IO&lt;/span&gt;&lt;span&gt;口初始化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后，用通用定时器&lt;/span&gt;TIM4&lt;span&gt;的通道&lt;/span&gt;&lt;span&gt;CH1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;CH2&lt;/span&gt;&lt;span&gt;分别产生两路&lt;/span&gt;&lt;span&gt;PWM&lt;/span&gt;&lt;span&gt;输出用于两个电机的转速控制，定时器默认引脚分配如图&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219224147782-1482840505.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;13&lt;span&gt;）&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;定时器通道默认引脚分配&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初始化通用定时器&lt;/span&gt;TIM4&lt;span&gt;的通道&lt;/span&gt;&lt;span&gt;CH1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;CH2&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;PWM&lt;/span&gt;&lt;span&gt;输出，实例代码如&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219224251591-576317140.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;14&lt;span&gt;）电机转速控制&lt;/span&gt;&lt;span&gt;IO&lt;/span&gt;&lt;span&gt;口初始化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，将电机转向和速度控制的操作封装在一个函数中，便于其它地方调用，实例代码如图&lt;/span&gt;15&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219224348640-66937201.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;15&lt;span&gt;）电机转向和速度控制封装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 align=&quot;justify&quot;&gt;&lt;span&gt;2.2.&lt;span&gt;编码器数据读取           &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;编码器对底盘来说至关重要，一方面底盘通过编码器的反馈进行&lt;/span&gt;PID&lt;span&gt;闭环速度控制，另一方面底盘通过编码器进行航迹推演得到里程计用于后续的定位与导航等高级算法中。这里用到的编码器是正交编码器，所以直接使用通用定时器的输入捕获中的编码器模式来读取编码器。采用通用定时器&lt;/span&gt;&lt;span&gt;TIM2&lt;/span&gt;&lt;span&gt;的通道&lt;/span&gt;&lt;span&gt;CH1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;CH2&lt;/span&gt;&lt;span&gt;捕获&lt;/span&gt;&lt;span&gt;encoder1&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;相和&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;相脉冲，采用通用定时器&lt;/span&gt;&lt;span&gt;TIM3&lt;/span&gt;&lt;span&gt;的通道&lt;/span&gt;&lt;span&gt;CH1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;CH2&lt;/span&gt;&lt;span&gt;捕获&lt;/span&gt;&lt;span&gt;encoder2&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;相和&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;相脉冲。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;先初始化&lt;/span&gt;TIM2&lt;span&gt;作为编码器&lt;/span&gt;&lt;span&gt;encoder1&lt;/span&gt;&lt;span&gt;的捕获，实例代码如图&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219225012510-1485248446.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;16&lt;span&gt;）初始化&lt;/span&gt;&lt;span&gt;TIM2&lt;/span&gt;&lt;span&gt;作为编码器&lt;/span&gt;&lt;span&gt;encoder1&lt;/span&gt;&lt;span&gt;的捕获&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;然后，将读取编码器计数值的操作封装在一个函数中，便于其它地方调用，实例代码如图&lt;/span&gt;17&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219225355067-1799512936.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;17&lt;span&gt;）读取编码器&lt;/span&gt;&lt;span&gt;encoder1&lt;/span&gt;&lt;span&gt;计数值封装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，编写&lt;/span&gt;TIM2&lt;span&gt;计数溢出时的中断处理函数，实例代码如图&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219225449521-1365626348.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;18&lt;span&gt;）&lt;/span&gt;&lt;span&gt;TIM2&lt;/span&gt;&lt;span&gt;计数溢出中断处理函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理可得&lt;/span&gt;TIM3&lt;span&gt;捕获&lt;/span&gt;&lt;span&gt;encoder2&lt;/span&gt;&lt;span&gt;的代码实现，这里就不在赘述了。&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;justify&quot;&gt;&lt;span&gt;2.3.&lt;span&gt;串口数据收发            &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;串口&lt;/span&gt;2&lt;span&gt;是数据接口，负责接收上位机发送过来的控制指令，同时将编码器值返回给上位机；串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;debug&lt;/span&gt;&lt;span&gt;接口，负责接收上位机发送过来的版本信息请求、&lt;/span&gt;&lt;span&gt;PIDm&lt;/span&gt;&lt;span&gt;默认值恢复、&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;值设定等调试指令，同时将程序中的&lt;/span&gt;&lt;span&gt;debug&lt;/span&gt;&lt;span&gt;打印信息返回给上位机。但是在底盘正常工作时，只需要连接串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;；串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;是预留出来给有需要自己动手修改&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;参数使用的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;首先，配置串口&lt;/span&gt;1&lt;span&gt;，先对串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;的输出进行&lt;/span&gt;&lt;span&gt;printf&lt;/span&gt;&lt;span&gt;函数打印支持，实例代码如图&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219225745273-280586997.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;19&lt;span&gt;）串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;的输出进行&lt;/span&gt;&lt;span&gt;printf&lt;/span&gt;&lt;span&gt;函数打印支持&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;然后，初始化串口&lt;/span&gt;1&lt;span&gt;，实例代码如图&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219225932746-1773228303.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;20&lt;span&gt;）初始化串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，编写串口&lt;/span&gt;1&lt;span&gt;接收中断处理函数，此函数主要进行对上位机发过来的数据进行协议解析，实例代码如图&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219230022609-1926741224.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;21&lt;span&gt;）串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;接收中断处理函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来，介绍串口&lt;/span&gt;2&lt;span&gt;，初始化串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，实例代码如图&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219230129539-934639601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;22&lt;span&gt;）初始化串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后，将串口&lt;/span&gt;2&lt;span&gt;发送数据的操作封装到函数中，便于其它地方调用，实例代码如图&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219230216692-153454569.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;23&lt;span&gt;）串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;发送数据封装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，编写串口&lt;/span&gt;2&lt;span&gt;接收中断处理函数，此函数主要进行对上位机发过来的数据进行协议解析，实例代码如图&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219230332778-64772980.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;24&lt;span&gt;）串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;接收中断处理函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里，串口有&lt;/span&gt;1&lt;span&gt;和串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;的数据发送与接收都编写好了，依据我们定义的&lt;/span&gt;&lt;span&gt;usart2&lt;/span&gt;&lt;span&gt;数据通信协议和&lt;/span&gt;&lt;span&gt;usart1&lt;/span&gt;&lt;span&gt;调试通信协议，上位机就可以编写对应的程序来跟底盘的串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;和串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;进行通信了。关于通信协议的具体内容，将在后续做展开。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.4.&lt;span&gt;电机速度&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;控制         &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我在底盘中采用的是增量型&lt;/span&gt;PID&lt;span&gt;算法，编程涉及到的数学表达式有&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个，分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;e(k) = target_value - current_value&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;delta_u(k) = Kp*[e(k)-e(k-1)] + Ki*e(k) + Kd*[e(k)-2*e(k-1)+e(k-2)]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;u(k) = u(k-1) + delta_u(k)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将这&lt;/span&gt;3&lt;span&gt;个数学表达式封装到函数中，便于其它地方调用，实例代码如图&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219230607634-1414638330.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;25&lt;span&gt;）串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;接收中断处理函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;电机&lt;/span&gt;1&lt;span&gt;与电机&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;采用同样的&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;算法，所以电机&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;算法代码实现就不赘述了。关于&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;参数的整定方法，将在后续做展开。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.5.&lt;span&gt;周期性控制           &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;通过上面的讲解，各个模块的驱动代码都准备就绪了，现在需要产生一个周期性的过程，在里面实现编码器计数值采样、&lt;/span&gt;PID&lt;span&gt;控制等具体实现。这里采用定时器&lt;/span&gt;&lt;span&gt;TIM1&lt;/span&gt;&lt;span&gt;产生一个周期性的中断，在中断处理函数中实现各模块的具体操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，配置定时器&lt;/span&gt;TIM1&lt;span&gt;，实例代码如图&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219230825074-1969727839.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;26&lt;span&gt;）配置定时器&lt;/span&gt;&lt;span&gt;TIM1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后，编写中断处理函数，实例代码如图&lt;/span&gt;27&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219231153468-1585582961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;27&lt;span&gt;）&lt;/span&gt;&lt;span&gt;TIM1&lt;/span&gt;&lt;span&gt;中断处理函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2.6.stm32&lt;span&gt;主控软件整体框图&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;通过上面的讲解，对底盘控制的&lt;/span&gt;stm32&lt;span&gt;程序实现有了一定的了解，接下来就来做一个总结。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来看看&lt;/span&gt;main()&lt;span&gt;函数实现，如图&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219231331226-1210325130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;28&lt;span&gt;）&lt;/span&gt;&lt;span&gt;main()&lt;/span&gt;&lt;span&gt;函数实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;结合上面&lt;/span&gt;TIM1&lt;span&gt;中断处理函数，不难发现，整个&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;程序的执行过程：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;a.&lt;span&gt;在&lt;/span&gt;&lt;span&gt;main()&lt;/span&gt;&lt;span&gt;函数中初始化各个模块；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;b.TIM1&lt;span&gt;中断处理函数周期性的读取编码器值、反馈获取的编码值、&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;控制；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;c.&lt;span&gt;剩下的就是串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;和串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;的通信交互。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;具体&lt;/span&gt;stm32&lt;span&gt;主控软件整体框图如图&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219231437207-647232679.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;29&lt;span&gt;）&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;主控软件整体框图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;需要说明的是，在周期性循环体中，要首先读取编码器的值，来保证严格的等间隔采样。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 15:19:00 +0000</pubDate>
<dc:creator>小虎哥哥爱学习</dc:creator>
<og:description>摘要 运动底盘是移动机器人的重要组成部分，不像激光雷达、IMU、麦克风、音响、摄像头这些通用部件可以直接买到，很难买到通用的底盘。一方面是因为底盘的尺寸结构和参数是要与具体机器人匹配的；另一方面是因为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hiram-zhang/p/10403822.html</dc:identifier>
</item>
<item>
<title>爸爸又给Spring MVC生了个弟弟叫Spring WebFlux - 李新杰</title>
<link>http://www.cnblogs.com/lixinjie/p/a-brother-of-spring-mvc-is-spring-webflux.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/a-brother-of-spring-mvc-is-spring-webflux.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;情景引入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;很早之前，Java就火起来了，是因为它善于开发和处理网络方面的应用。&lt;/p&gt;&lt;p&gt;Java有一个爱好，就是喜欢制定规范标准，但自己又不善于去实现。&lt;/p&gt;&lt;p&gt;反倒是一些服务提供商使用它的规范标准来制造应用服务器而赚的盆满钵满。&lt;/p&gt;&lt;p&gt;企业用户因要使用这些应用服务器而向提供商支付高额费用，而且也不是特别好用。&lt;/p&gt;&lt;p&gt;一个青年才俊为了打破这种局面而奔走呼号、奋发图强。&lt;br/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自我介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;显然，这个青年才俊就是后来的Spring。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;因企业应用大都和web相关，而Java的web标准中较核心的一部分其实就是JavaEE里的Servlet。&lt;/p&gt;&lt;p&gt;Spring和Servlet“相亲相爱”一番后，我就来到了这个世界。我的全名叫Spring MVC，这里的Spring既是我的姓也是我的“爸爸”，那Servlet就是我的“妈妈”了，大家叫我MVC就行了。&lt;/p&gt;&lt;p&gt;那个年代社会很落后，条件也不好，好歹我们要求也不高，求个温饱就行了。&lt;/p&gt;&lt;p&gt;所以我的妈妈Servlet和她的闺蜜Filter天生就是同步阻塞的，包括她们同事HttpServletRequest的getParameter，getPart等这些方法也都是阻塞的。&lt;/p&gt;&lt;p&gt;虽然我的爸爸Spring给了我23条染色体来进行改良，但不要忘了我还从Servlet妈妈那里继承了23条，所以我也是同步阻塞的。不过我的“长相”已经好看很多了，因为Spring爸爸知道，在以后的日子里，除了拼实力之外，颜值也是非常重要的。&lt;/p&gt;&lt;p&gt;因为我妈妈Servlet是一个规范，我爸爸Spring是一个框架，所以我跟他们一样，都是无法自己独立运行的。&lt;/p&gt;&lt;p&gt;所以在我们要运行的时候，必须要寻找一个特殊的“家”，通常称它为Servlet容器，比如tomcat就算非常知名的一个。&lt;/p&gt;&lt;p&gt;Servlet容器熟知我极有可能阻塞当前执行线程，所以专门量身打造。它给我准备了一个非常大的线程池，里面有好多线程。每过来一个请求，它就扔给我一个线程，说自己玩去吧，随便“折腾”。&lt;/p&gt;&lt;p&gt;好在那时美国那个叫乔布斯的家伙被自己的公司赶出去在外面“流浪”，Servlet容器为我量身打造的这种方法完全能够胜任日常，关键还非常的简单。&lt;/p&gt;&lt;p&gt;这种小富即安的日子就这样往前过着。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;兄弟出生&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;生命不息，变化不止。随着乔布斯推出iphone，智能机瞬间大火，全民进入移动互联网时代。激增的网民数量，给现有软件架构带来极大的挑战。&lt;/p&gt;&lt;p&gt;一般来说，社会越发达，分工越精细，对单一工种的要求就越高。&lt;/p&gt;&lt;p&gt;软件也是如此，在传统“大块头”软件表现的越来越格格不入的时候，微服务就如一丝春风吹了进来。&lt;/p&gt;&lt;p&gt;按它的指导原则，将大软件按某种方式拆分为一个个小工程。小工程规模小，便于管理，而且机动性也好，功能聚合性更好。它承受的并发应该更高。&lt;/p&gt;&lt;p&gt;有人觉得与微服务比起来，过去使用的web服务器如tomcat略显笨重，不够轻量级。也有人说tomcat内部一个请求一个线程这种阻塞执行方式消耗太多线程，不太容易支撑超高并发。&lt;/p&gt;&lt;p&gt;无论怎么说，简而言之一句话，一个全新的时代已经到来。&lt;/p&gt;&lt;p&gt;此时我们需要一个更加轻量级web应用，它使用更少的硬件资源和线程，反而更容易处理高并发。那么它一定是异步非阻塞的。&lt;/p&gt;&lt;p&gt;这样的使命自然落到了响应式编程的范畴上了。所以我的爸爸Spring审时度势，在5.0之后就赶紧把我推出来了。&lt;/p&gt;&lt;p&gt;没错，我就是Spring WebFlux，这里的Spring既是我的姓也是我爸爸。大家可以叫我WebFlux。初来乍到，好多人都对我不熟悉，请容许我介绍一番。&lt;/p&gt;&lt;p&gt;首先这个响应式究竟是什么意思呢？响应式这个术语，指的是一个编程模型，它是围绕着对变化的反映来构建的。&lt;/p&gt;&lt;p&gt;如网络组件用来响应I/O事件，UI控制器用来响应鼠标事件等等。按照这种意识的话，非阻塞就是响应式的，对操作完成或数据可用通知事件的响应方式。&lt;/p&gt;&lt;p&gt;另外一个关于响应式的机制是非阻塞后压。在命令式代码中，同步阻塞调用带有自然的后压迫使调用者等待。&lt;/p&gt;&lt;p&gt;在异步代码中，它变得非常重要，用来控制事件的速率，以至于不让一个快速的事件源压垮它的响应者。就是响应者能够控制事件源发射事件的快慢。&lt;/p&gt;&lt;p&gt;因为响应式编程是非阻塞的，所以我也是非阻塞的，因此我通常运行在非阻塞web服务器上，如Netty，Undertow等。&lt;/p&gt;&lt;p&gt;因为我不会阻塞线程的执行，所以使用一个小的固定数量的线程池（event loop workers）来处理请求。典型地，线程数与CPU的核数相同。&lt;/p&gt;&lt;p&gt;这里还要感谢我的姥爷Java 8，他老人家引入了lambda表达式造就了函数式编程API。这对于非阻塞应用和连续式API来说是一个非常棒的东西，允许以声明的方式把异步逻辑组合起来。&lt;/p&gt;&lt;p&gt;我感觉我的爸爸Spring已经超越了一个框架，成为一个平台了。所以他自己并没有亲自去实现响应式处理，而是为我选择Reactor作为响应式库。&lt;/p&gt;&lt;p&gt;Reactor提供Flux和Mono类型，拥有丰富的操作符，支持非阻塞后压，使用函数式API来组合异步逻辑。并且Reactor强烈聚焦于Java服务器端。它在开发时就已经与爸爸Spring亲密协作了。&lt;/p&gt;&lt;p&gt;爸爸说，我也支持其它的库如RxJava，但看样子似乎让我更爱Reactor一些。&lt;/p&gt;&lt;p&gt;这就是我，WebFlux，一个集天时地利于一身的幸运儿。但你是不是已经晕晕的啦，没关系，慢慢来。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;包罗万象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我想，大家都看出了我爸爸Spring的野心，他不仅要成为一个平台，还要建起自己的生态系统，竖起壁垒。&lt;/p&gt;&lt;p&gt;所以他的核心事业就是进行抽象，组合和装配，进而包罗万象。说的掉渣一些，就是哪个技术好，就给它整合进来。&lt;/p&gt;&lt;p&gt;为了抹平底层不同web服务器的差异，我爸爸抽象了一个最低级别的契约接口，HttpHandler，用于响应式HTTP请求的处理。&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;Mono&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.Void&lt;/span&gt;&amp;gt; &lt;span class=&quot;&quot;&gt;handle&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerHttpRequest&lt;/span&gt; &lt;span class=&quot;&quot;&gt;request&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;ServerHttpResponse&lt;/span&gt; &lt;span class=&quot;&quot;&gt;response&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;它是一个通用的接口，要横跨不同的运行时。它是有意设计成最小化的，只有一个方法，主要唯一目的就是在不同的HTTP服务器API上面成为一个最小化的抽象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果想用Netty服务器的话，就基于Netty实现一下，同理也可以基于Undertow实现一下，等等，只要以后有了新的服务器，都可以加进来的。&lt;/p&gt;&lt;p&gt;显而易见，HttpHandler的目标是抽象出来对不同HTTP服务器的使用，说白了就是为了和底层服务器对接。但由于太偏底层，不利用上层代码使用。&lt;/p&gt;&lt;p&gt;为此，我的爸爸又抽象出一个稍微高一点级别的契约接口，WebHandler，用于Web请求处理。很明显，WebHandler的目标是提供web应用中广泛使用的通用特性，如Session、表单数据和附件等等，也是为了更容易和上层代码对接。&lt;/p&gt;&lt;p&gt;很自然的，WebHandler是构建于HttpHandler之上的，换句话说WebHander的处理会通过一个适配器HttpWebHandlerAdapter最终代理给HttpHandler来执行。&lt;/p&gt;&lt;p&gt;WebHandler接口也只有一个方法：&lt;br/&gt;&lt;/p&gt;

&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;Mono&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.Void&lt;/span&gt;&amp;gt; &lt;span class=&quot;&quot;&gt;handle&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerWebExchange&lt;/span&gt; &lt;span class=&quot;&quot;&gt;exchange&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;参数类型是ServerWebExchange，可以这样理解，你发一个请求，给你一个响应，相当于用请求交换了一个响应，而且是在服务器端交换的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;其实，整个web请求的处理过程是一个链式的，最后才是一个WebHandler，它前面可以插入多个错误处理器，WebExceptionHandler，多个过滤器，WebFilter。&lt;/p&gt;&lt;p&gt;这是错误处理器接口：&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;Mono&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.Void&lt;/span&gt;&amp;gt; &lt;span class=&quot;&quot;&gt;handle&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerWebExchange&lt;/span&gt; &lt;span class=&quot;&quot;&gt;exchange&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.Throwable&lt;/span&gt; &lt;span class=&quot;&quot;&gt;ex&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;这是过滤器接口：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;Mono&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.Void&lt;/span&gt;&amp;gt; &lt;span class=&quot;&quot;&gt;filter&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerWebExchange&lt;/span&gt; &lt;span class=&quot;&quot;&gt;exchange&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;WebFilterChain&lt;/span&gt; &lt;span class=&quot;&quot;&gt;chain&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;可见，我的爸爸Spring的抽象能力非常强，对下抽象一个接口，抹平了不同服务器的差异。对上抽象一个接口，可以用于支撑不同的编程模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;都有哪些编程模型呢，请继续往下看吧。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;皮囊之下&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面我在介绍自己的时候使用了美颜，所以诸位很难看清我的“真面目”，下面就来进行一下自我剖析，看看真实的我。&lt;/p&gt;&lt;p&gt;我包含一个轻量级函数式编程模型，函数被用来参与处理请求，它是相对于基于注解编程模型的另一种选择，这种编程模型叫做函数式端点，functional endpoints，是构建于上面提到的WebHandler之上的。&lt;/p&gt;&lt;p&gt;我是使用HandlerFunction来处理一个HTTP请求的，这是一个函数式接口，也称处理函数：&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;@FunctionalInterface&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;&quot;&gt;HandlerFunction&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;&quot;&gt;ServerResponse&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;reactor.core.publisher.&lt;span class=&quot;&quot;&gt;Mono&amp;lt;T&amp;gt; &lt;span class=&quot;&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(ServerRequest request)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;带有一个ServerRequest参数，返回一个Mono&amp;lt;ServerResponse&amp;gt;，其中request和response对象都是不可变的，HandlerFunction就等价于Controller中的@RequestMapping标记的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;实际当中，请求很多，处理函数也很多，如何知道一个请求过来后，该由哪个处理函数去处理呢？&lt;/p&gt;&lt;p&gt;这自然要用到我的另一个函数式接口RouterFunction来搞定，称为路由函数：&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;@FunctionalInterface&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;&quot;&gt;RouterFunction&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;&quot;&gt;ServerResponse&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;reactor.core.publisher.Mono&amp;lt;HandlerFunction&amp;lt;T&amp;gt;&amp;gt; route(ServerRequest request);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;带有一个ServerRequest参数，返回一个Mono&amp;lt;HandlerFunction&amp;gt;。就是它把一个请求路由到一个HandlerFunction的，当路由函数匹配时，就返回一个处理函数，否则返回一个空的Mono。RouterFunction等价于@RequestMapping注解，但主要不同的是路由函数提供的不仅是数据，还有行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下面通过一些示例，来更加直观的帮助大家认识这两个函数式接口。&lt;/p&gt;&lt;p&gt;因处理函数是函数式接口，所以可以直接用一个lambda表达式来处理请求，如下：&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;HandlerFunction&amp;lt;ServerResponse&amp;gt; handler = &lt;span class=&quot;&quot;&gt;request&lt;/span&gt; -&amp;gt; &lt;span class=&quot;&quot;&gt;Response&lt;/span&gt;.ok().body(&lt;span class=&quot;&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;这就表示当任何一个请求过来时，都返回Hello World作为响应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在实际应用中，处理逻辑一般都很复杂，肯定不是一个lambda表达式能搞定的，此时希望把处理方法专门写到一个类里，就叫处理器类，和MVC里的Controller差不多一回事。&lt;/p&gt;&lt;p&gt;下面就是一个Person的处理器类：&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;4&quot;&gt;&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;&quot;&gt;PersonHandler&lt;/span&gt; {&lt;p&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt; &lt;span class=&quot;&quot;&gt;listPeople&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerRequest request&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt; &lt;span class=&quot;&quot;&gt;createPerson&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerRequest request&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt; &lt;span class=&quot;&quot;&gt;getPerson&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerRequest request&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;此时就可以通过处理函数，引用这些处理器方法了，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;4&quot;&gt;&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;6&quot;&gt;PersonHandler handler = &lt;span class=&quot;&quot;&gt;new&lt;/span&gt; PersonHandler();&lt;p&gt;HandlerFunction&amp;lt;ServerResponse&amp;gt; &lt;span class=&quot;&quot;&gt;list&lt;/span&gt; = handler::listPeople;&lt;/p&gt;&lt;p&gt;HandlerFunction&amp;lt;ServerResponse&amp;gt; create = handler::createPerson;&lt;/p&gt;&lt;p&gt;HandlerFunction&amp;lt;ServerResponse&amp;gt; get = handler::getPerson;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;要想使请求能够正确被路由，首先要定义好路由函数，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;6&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;RouterFunction&amp;lt;ServerResponse&amp;gt; route = RouterFunctions.route()&lt;br/&gt;.&lt;span class=&quot;&quot;&gt;GET&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;/person/{id}&quot;&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;get&lt;/span&gt;)&lt;br/&gt;.&lt;span class=&quot;&quot;&gt;GET&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;/person&quot;&lt;/span&gt;, list)&lt;br/&gt;.POST(&lt;span class=&quot;&quot;&gt;&quot;/person&quot;&lt;/span&gt;, create)&lt;br/&gt;.build();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;它表示当以GET方法请求/person/{id}时，最终会由getPerson方法处理。当以GET方法请求/person时，最后会由listPeople方法处理。同理，以POST方法请求/person时，会由createPerson方法处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;可见，一个路由函数可以包含多个路由规则，实际当中，可以定义多个路由函数，这些路由函数可以组合在一起。&lt;/p&gt;&lt;p&gt;路由函数是按顺序计算的，如果第一个路由不匹配，计算第二个，等等。因此，把更加具体的路由放到通用路由前面是非常有意义的。注意这和基于注解的不同。&lt;/p&gt;&lt;p&gt;怎么样，关掉滤镜的我是不是更加真实了。我相信你也看明白了，至少要记住，这是基于函数式的一种编程模型，叫做函数式端点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;雨露均沾&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;像我这样的幸运儿，你们一定以为Spring爸爸对我非常溺爱吧，告诉你，确实是这样的。不过考虑到大家伙一路走来对Spring的不离不弃，爸爸也设身处地为你们着想。&lt;/p&gt;&lt;p&gt;为此，我除了支持函数式端点这种编程模型之外，还支持一种编程模型叫基于注解的控制器，annotated controllers，没错，就是MVC里的那个。&lt;/p&gt;&lt;p&gt;话说的再白一些，就是大家已经非常熟悉的Spring MVC那套东西，我百分之百的完全支持，妥妥的，放心使用。&lt;/p&gt;&lt;p&gt;但是，并不是所有的控制器方法参数都支持响应式类型，只有一些支持，如WebSession，java.security.Principal，@RequestBody，HttpEntity&amp;lt;B&amp;gt;，@RequestPart等。&lt;/p&gt;&lt;p&gt;下面看一个示例：&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;5&quot;&gt;&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;&quot;&gt;@PostMapping(&lt;span class=&quot;&quot;&gt;&quot;/&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; String handle(&lt;span class=&quot;&quot;&gt;@RequestBody&lt;/span&gt; Mono&amp;lt;MultiValueMap&amp;lt;String, Part&amp;gt;&amp;gt; parts) { &lt;br/&gt;&lt;span class=&quot;&quot;&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;&quot;&gt;@PostMapping(&lt;span class=&quot;&quot;&gt;&quot;/&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; String handle(&lt;span class=&quot;&quot;&gt;@RequestBody&lt;/span&gt; Flux&amp;lt;Part&amp;gt; parts) { &lt;br/&gt;&lt;span class=&quot;&quot;&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;@PostMapping(&lt;span class=&quot;&quot;&gt;&quot;/accounts&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; void handle(&lt;span class=&quot;&quot;&gt;@RequestBody&lt;/span&gt; Mono&amp;lt;Account&amp;gt; account) {&lt;br/&gt;&lt;span class=&quot;&quot;&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;不过对于控制器方法的所有返回值，都是支持响应式类型的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;各有千秋&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Spring MVC和Spring WebFlux可以一起使用，从设计上讲，它们互为继续、互为一致。&lt;/p&gt;&lt;p&gt;它们的关系，请看下图，既有共同的部分，也有互相独立的部分。&lt;br/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201902/76066-20190219222515699-1633837851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;Spring MVC的特点就是，它是命令式编程，代码非常容易写，也好理解和调试。但是它是同步的，会有人觉得它性能不好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;但是我要说的是，响应式和非阻塞通常来讲也不会使应用运行的更快。相反，非阻塞方式要求做更多的事情，而且还会稍微增加一些必要的处理时间。也就是说，还可能稍稍变慢一点，what，那为啥还要用它呢？&lt;/p&gt;&lt;p&gt;响应式和非阻塞的关键好处是，在使用很少固定数目的线程和较少的内存情况下的扩展能力。&lt;/p&gt;&lt;p&gt;这使应用在负载下更有适应能力，因为它们以一个更加具有可预见性的方式在扩展。&lt;/p&gt;&lt;p&gt;为了能够观察到这些好处，你需要有一些延迟才行，比如一个既不可靠且速度又慢的网络I/O，这才是响应式开始展示它强劲的地方，带来的差异（惊喜）可能是巨大的哦。&lt;/p&gt;&lt;p&gt;其实技术无好坏，各有各的适用场景罢了。&lt;br/&gt;&lt;/p&gt;



&lt;p&gt;（完）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;编程新说&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr data-width=&quot;80%&quot;/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;用独特的视角说技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201901/76066-20190124185847216-1263582225.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 14:31:00 +0000</pubDate>
<dc:creator>李新杰</dc:creator>
<og:description>情景引入 很早之前，Java就火起来了，是因为它善于开发和处理网络方面的应用。 Java有一个爱好，就是喜欢制定规范标准，但自己又不善于去实现。 反倒是一些服务提供商使用它的规范标准来制造应用服务器而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lixinjie/p/a-brother-of-spring-mvc-is-spring-webflux.html</dc:identifier>
</item>
<item>
<title>Angular6.x学习笔记——内容投影, ViewChild和ContentChild - 半路独行</title>
<link>http://www.cnblogs.com/banluduxing/p/10394387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/banluduxing/p/10394387.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;内容投影&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1为什么需要内容投影?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个事物的出现,必然存在它所能解决的问题,让我们先从问题出发吧:&lt;/p&gt;
&lt;p&gt;大家应该都知道,在html规范里面,它定义了非常多的标签,在这些标签里面,相同标签之间的嵌套,不同标签之间的嵌套,是十分常见,并且可行&lt;/p&gt;
&lt;p&gt;同时,在Angular里面,我们可以通过自定义标签的方式引用组件,那么这里的标签能否像原生的html标签一样,来嵌入html标签,或者嵌套其他组件标签呢?&lt;/p&gt;
&lt;p&gt;于是就引入我们今天的主要问题,用一个详细的例子来描述吧:&lt;/p&gt;
&lt;p&gt;假设存在父组件Content,和它下面2个子组件PartA和PartB,自定义标签分别为:&amp;lt;app-content&amp;gt;,&amp;lt;app-content-part-a&amp;gt;,&amp;lt;app-content-part-b&amp;gt;,如果想在父组件的视图里面,完成下面的内容,是否可行呢?&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; content.component.html &lt;p&gt;1&lt;/p&gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Content&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;app-content-part-a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;PartA--start&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;app-content-part-b&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;app-content-part-b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;PartA--end&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;app-content-part-a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样是不行的,其结果只会显示自定义的组件&amp;lt;app-content-part-a&amp;gt;自身的内容,因为自定义组件标签会忽略嵌套其中的html原生标签或者其他的自定义组件标签,从而使它们无法产生任何效果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2如何使用内容投影?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述问题通过内容投影则能够解决,那么如何使用内容投影呢?&lt;/p&gt;
&lt;p&gt;只需要在组件PartA的视图里面做一些改动,内容如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; part-a.component.html&lt;p&gt;1&lt;/p&gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-content &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;h1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-content&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-content &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;app-content-part-b&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-content&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-content &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;span&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-content&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过这样的修改,上述想要实现的效果就可以达到&lt;/p&gt;
&lt;p&gt;那么内容投影是如何工作的呢?&lt;/p&gt;
&lt;p&gt;首先通过angular里面的一个指令ng-content,实现占位,再通过select,达到选择器的作用,这样在组件生命周期过程,初始渲染投影内容的时候,就能够将对应的内容投影到特定的位置,这就是内容投影工作的简单描述&lt;/p&gt;
&lt;p&gt;组件里面嵌套组件,之间的通讯问题可以参考&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/banluduxing/p/9290569.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;组件间的通讯&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ContentChild和ViewChild   &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;                                                                              &lt;/p&gt;
&lt;p&gt;首先做个简单的介绍:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ContentChild&lt;/strong&gt;:与内容子节点有关,操作投影进来的内容;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ViewChild&lt;/strong&gt;:与视图子节点有关,操作自身的视图内容;&lt;/p&gt;
&lt;p&gt;在上一部分,我们通过内容投影,让自定义的组件标签能够嵌入html标签或自定义组件标签,那么它如何操作投影进来的内容呢?&lt;/p&gt;
&lt;p&gt;还是以上述内容为例,从实际的问题出发:假设嵌入的自定义组件标签&amp;lt;app-content-part-b&amp;gt;里面声明了一个方法func(),那么如何在&amp;lt;app-content-part-a&amp;gt;里面去操作这个方法呢?&lt;br/&gt;上面说过,ContentChild是操作投影进来的内容,那么在这里我们也可以通过它解决问题,在组件PartA内,通过ContentChild获取投影进来的组件PartB,并对它进行操作(部分代码在上一部分已经贴出,这一部分不予重复),代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; part-b.component.ts&lt;p&gt;1&lt;/p&gt;&lt;/span&gt; import { Component, OnInit,Output} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@angular/core&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@Component({
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   selector: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;app-content-part-b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   templateUrl: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./part-b.component.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   styleUrls: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./part-b.component.scss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; export &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PartBComponent implements OnInit {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  constructor() { }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  ngOnInit() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; func():&lt;span&gt;void&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;    console.log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PartB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  } 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; part-a.component.ts&lt;p&gt;1&lt;/p&gt;&lt;/span&gt; import { Component, OnInit, ContentChild } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@angular/core&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; import { PartBComponent } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../part-b/part-b.component&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@Component({
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   selector: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;app-content-part-a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   templateUrl: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./part-a.component.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   styleUrls: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./part-a.component.scss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; export &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PartAComponent implements OnInit {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;@ContentChild(PartBComponent) PartB:PartBComponent
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;  constructor() { }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  ngOnInit() {}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   ngAfterContentInit(): &lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.PartB.func();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意一点:在组件的生命周期里面,有一个钩子ngAfterContentInit()是与投影内容初始化有关,所以我们有关投影的内容操作尽量放在它初始化完成之后进行&lt;/p&gt;
&lt;p&gt; 如果理解了ContentChild的用法,那么ViewChild几乎没有理解难度,他们的差异不大,所不同的是:&lt;/p&gt;
&lt;p&gt;  1ViewChild是操作视图本身存在的节点,而不是投影进来的内容&lt;/p&gt;
&lt;p&gt;  2ngAfterContentInit()对应的是ngAfterViewInit()(视图节点初始化是在投影内容初始化之后)&lt;/p&gt;
&lt;p&gt;其他没有什么不同,这里我就不再赘述&lt;/p&gt;
&lt;p&gt; ContentChild和ViewChild还存在复数的形式,即ContentChildren和ViewChildren,它们取到的是节点的一个集合,其他的没有什么区别&lt;/p&gt;
&lt;p&gt;写法如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; import { Component, OnInit, ContentChild,ContentChildren ,QueryList } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@angular/core&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; import { PartBComponent } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../part-b/part-b.component&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@Component({
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   selector: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;app-content-part-a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   templateUrl: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./part-a.component.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   styleUrls: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./part-a.component.scss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; export &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PartAComponent implements OnInit {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;@ContentChildren(PartBComponent)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; PartBs: QueryList&amp;lt;PartBComponent&amp;gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  constructor() { }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  ngOnInit() {}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码中PartBs是组件PartB的一个集合,这就是复数的用法,ViewChildren不再赘述&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;内容投影是一个比较容易理解而又实用的东西,再加上ContentChild的使用,使得我们不仅可以把内容投影进去,还能够加以操作&lt;/p&gt;

&lt;p&gt;学习参考资源(大漠穷秋):&lt;a href=&quot;http://www.ngfans.net/topic/12/post/2&quot; target=&quot;_blank&quot;&gt;http://www.ngfans.net/topic/12/post/2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出自:博客园-半路独行&lt;/p&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://www.cnblogs.com/banluduxing/p/10394387.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/banluduxing/p/10394387.html&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/banluduxing/p/9290208.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文出自于&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 菜鸟的Xamarin.Forms前行之路——各种报错问题解决方法合集(不定时更新)&quot; href=&quot;http://www.cnblogs.com/banluduxing&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/banluduxing&lt;/a&gt; 转载请注明出处。&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 14:16:00 +0000</pubDate>
<dc:creator>半路独行</dc:creator>
<og:description>内容投影 1为什么需要内容投影? 一个事物的出现,必然存在它所能解决的问题,让我们先从问题出发吧: 大家应该都知道,在html规范里面,它定义了非常多的标签,在这些标签里面,相同标签之间的嵌套,不同标</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/banluduxing/p/10394387.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Gateway中异常处理 - 只喝牛奶的杀手</title>
<link>http://www.cnblogs.com/viaiu/p/10403557.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viaiu/p/10403557.html</guid>
<description>&lt;p&gt; 最近我们的项目在考虑使用Gateway，考虑使用Spring Cloud Gateway，发现网关的异常处理和spring boot 单体应用异常处理还是有很大区别的。让我们来回顾一下异常。&lt;/p&gt;
&lt;p&gt;关于异常是拿来干什么的，很多人老程序员认为就是拿来我们Debug的时候排错的，当然这一点确实是异常机制非常大的一个好处，但异常机制包含着更多的意义。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;关注业务实现&lt;/strong&gt;。异常机制使得业务代码与异常处理代码可以分开，你可以将一些你调用数据库操作的代码写在一个方法里而只需要在方法上加上throw DB相关的异常。至于如何处理它，你可以在调用该方法的时候处理或者甚至选择不处理，而不是直接在该方法内部添加上if判断如果数据库操作错误该如何办，这样业务代码会非常混乱。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统一异常处理&lt;/strong&gt;。与上一点有所联系。我当前所在项目的实践是，自定义业务类异常，在Controller或Service中抛出，让后使用Spring提供的异常接口统一处理我们自己在内部抛出的异常。这样一个异常处理架构就非常明了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序的健壮性&lt;/strong&gt;。如果没有异常机制，那么来了个对空对象的某方法调用怎么办呢？直接让程序挂掉？这令人无法接受，当然，我们自己平时写的一些小的东西确实是这样，没有处理它，让后程序挂了。但在web框架中，可以利用异常处理机制捕获该异常并将错误信息传递给我们然后继续处理下个请求。所以异常对于健壮性是非常有帮助的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;异常处理（又称为错误处理）功能提供了处理程序运行时出现的任何意外或异常情况的方法。异常处理使用 try、catch 和 finally 关键字来尝试可能未成功的操作，处理失败，以及在事后清理资源。异常根据意义成三种：业务、系统、代码异常，不同的异常采用不同的处理方式。具体的什么样的异常怎么处理就不说了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/810680/201902/810680-20190219213503621-560199857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红线和绿线代表两条异常路径&lt;/p&gt;
&lt;p&gt;1，红线代表：请求到Gateway发生异常，可能由于后端app在启动或者是没启动&lt;/p&gt;
&lt;p&gt;2，绿线代表：请求到Gateway转发到后端app，后端app发生异常，然后Gateway转发后端异常到前端&lt;/p&gt;
&lt;p&gt;红线肯定是走Gateway自定义异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/810680/201902/810680-20190219214205865-413677260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个类的代码如下（参考：http://cxytiandi.com/blog/detail/20548）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @EnableConfigurationProperties({ServerProperties.&lt;span&gt;class&lt;/span&gt;, ResourceProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExceptionHandlerConfiguration {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ServerProperties serverProperties;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ApplicationContext applicationContext;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ResourceProperties resourceProperties;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;ViewResolver&amp;gt;&lt;span&gt; viewResolvers;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ServerCodecConfigurer serverCodecConfigurer;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ExceptionHandlerConfiguration(ServerProperties serverProperties,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                                         ResourceProperties resourceProperties,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                                          ObjectProvider&amp;lt;List&amp;lt;ViewResolver&amp;gt;&amp;gt;&lt;span&gt; viewResolversProvider,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                                         ServerCodecConfigurer serverCodecConfigurer,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                                         ApplicationContext applicationContext) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.serverProperties =&lt;span&gt; serverProperties;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.applicationContext =&lt;span&gt; applicationContext;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.resourceProperties =&lt;span&gt; resourceProperties;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.viewResolvers =&lt;span&gt; viewResolversProvider.getIfAvailable(Collections::emptyList);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.serverCodecConfigurer =&lt;span&gt; serverCodecConfigurer;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    @Order(Ordered.HIGHEST_PRECEDENCE)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ErrorWebExceptionHandler errorWebExceptionHandler(ErrorAttributes errorAttributes) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         JsonExceptionHandler exceptionHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonExceptionHandler(
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                errorAttributes,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourceProperties,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serverProperties.getError(),
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.applicationContext);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         exceptionHandler.setViewResolvers(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.viewResolvers);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         exceptionHandler.setMessageWriters(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serverCodecConfigurer.getWriters());
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         exceptionHandler.setMessageReaders(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serverCodecConfigurer.getReaders());
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; exceptionHandler;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JsonExceptionHandler &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; DefaultErrorWebExceptionHandler {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(JsonExceptionHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; JsonExceptionHandler(ErrorAttributes errorAttributes, ResourceProperties resourceProperties,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                                ErrorProperties errorProperties, ApplicationContext applicationContext) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(errorAttributes, resourceProperties, errorProperties, applicationContext);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;         * 获取异常属性
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; getErrorAttributes(ServerRequest request, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; includeStackTrace) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; code =&lt;span&gt; HttpStatus.INTERNAL_SERVER_ERROR.value();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             Throwable error = &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getError(request);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (error &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; org.springframework.cloud.gateway.support.NotFoundException) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 code =&lt;span&gt; HttpStatus.NOT_FOUND.value();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; response(code, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.buildMessage(request, error));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;         * 指定响应处理方法为JSON处理的方法
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; errorAttributes
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; RouterFunction&amp;lt;ServerResponse&amp;gt;&lt;span&gt; getRoutingFunction(ErrorAttributes errorAttributes) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; RouterFunctions.route(RequestPredicates.all(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;::renderErrorResponse);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;         * 根据code获取对应的HttpStatus
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; errorAttributes
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; HttpStatus getHttpStatus(Map&amp;lt;String, Object&amp;gt;&lt;span&gt; errorAttributes) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; statusCode = (&lt;span&gt;int&lt;/span&gt;) errorAttributes.get(&quot;code&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; HttpStatus.valueOf(statusCode);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;         * 构建异常信息
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; ex
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String buildMessage(ServerRequest request, Throwable ex) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             StringBuilder message = &lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;Failed to handle request [&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            message.append(request.methodName());
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             message.append(&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            message.append(request.uri());
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             message.append(&quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ex != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 message.append(&quot;: &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                message.append(ex.getMessage());
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; message.toString();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;         * 构建返回的JSON数据格式
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; status        状态码
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; errorMessage  异常信息
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; response(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; status, String errorMessage) {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             Map&amp;lt;String, Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;             map.put(&quot;code&quot;&lt;span&gt;, status);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             map.put(&quot;message&quot;&lt;span&gt;, errorMessage);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;             map.put(&quot;data&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;            logger.error(map.toString());
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;        }&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;绿线代表Gateway转发异常&lt;/p&gt;
&lt;p&gt;转发的异常，肯定是springboot单体中处理的，至于spring单体中的异常是怎么处理的呢？肯定是用@ControllerAdvice去做。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     @ExceptionHandler(value = Exception.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @ResponseBody
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AppResponse exceptionHandler(HttpServletRequest request, Exception e) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         String ip =&lt;span&gt; RequestUtil.getIpAddress(request);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         logger.info(&quot;调用者IP：&quot; +&lt;span&gt; ip);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         String errorMessage = String.format(&quot;Url:[%s]%n{%s}&quot;&lt;span&gt;, request.getRequestURL().toString(), e.getMessage());
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        logger.error(errorMessage, e);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; AppResponse.error(HttpStatus.INTERNAL_SERVER_ERROR.value(), e.getMessage());
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里基本上可以了，大家不要试着去用Gateway去捕获后端异常，回到最初的起点，API 网关（API Gateway）主要负责服务请求路由、组合及协议转换，异常同样也是一样，Gateway只负责转发单体应用的异常，不要试图Gateway捕获后端服务异常，然后再输出给前端。感谢猿天地的一句惊醒梦中人！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/810680/201902/810680-20190219215930541-480230897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 14:02:00 +0000</pubDate>
<dc:creator>只喝牛奶的杀手</dc:creator>
<og:description>最近我们的项目在考虑使用Gateway，考虑使用Spring Cloud Gateway，发现网关的异常处理和spring boot 单体应用异常处理还是有很大区别的。让我们来回顾一下异常。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viaiu/p/10403557.html</dc:identifier>
</item>
<item>
<title>彻底搞清楚浏览器渲染过程 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/10403622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/10403622.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在分析浏览器的渲染过程之前，我们先了解一下什么是进程和线程：&lt;/p&gt;
&lt;p&gt;（1）什么是进程？&lt;/p&gt;
&lt;p&gt;进程是CPU进行资源分配的基本单位&lt;/p&gt;
&lt;p&gt;（2）什么是线程？&lt;/p&gt;
&lt;p&gt;线程是CPU调度的最小单位，是建立在进程的基础上运行的单位，共享进程的内存空间。&lt;/p&gt;
&lt;p&gt;那么我们可以得出结论：&lt;/p&gt;
&lt;p&gt;1、进程是会占用系统资源；2、一个进程内可以存在一个或者多个线程，这就是单线程和多线程；3、无论是单线程还是多线程都是在一个进程内。&lt;/p&gt;
&lt;p&gt;博客首发地址（sau交流学习社区）：&lt;a href=&quot;https://www.mwcxs.top/page/567.html&quot; target=&quot;_blank&quot;&gt;https://www.mwcxs.top/page/567.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、多进程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/1/30kENgQ3YAc7yhpMVHg9kMEbob.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中可知：&lt;/p&gt;
&lt;p&gt;1、浏览器是多进程&lt;/p&gt;
&lt;p&gt;2、不同类型的标签页都会开启一个新的进程&lt;/p&gt;
&lt;p&gt;3、相同类型的标签页是会合并到一个进程&lt;/p&gt;
&lt;p&gt;上图中浏览器的各个进程的主要作用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、浏览器进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）负责管理各个标签页的创建和销毁&lt;/p&gt;
&lt;p&gt;（2）负责浏览器的页面显示和功能（前进，后退，收藏等）&lt;/p&gt;
&lt;p&gt;（3）负责资源的管理与下载&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、第三方插件进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）负责每个第三方插件的使用，每个第三方插件使用时候都会创建一个对应的进程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、GPU进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）负责3D绘制和硬件加速&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、浏览器渲染进程&lt;/strong&gt;（咱们这回主要分析的）&lt;/p&gt;
&lt;p&gt;1、浏览器内核，主要负责HTML，CSS，JS等文件的解析和执行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、浏览器内核&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器内核就是&lt;strong&gt;浏览器渲染进程&lt;/strong&gt;，从接收下载文件后再到呈现整个页面的过程，由浏览器渲染进程负责，主要流程如下：&lt;/p&gt;
&lt;p&gt;1、解析HTML文件和CSS文件，加载图片等资源文件，渲染成用户看到的页面&lt;/p&gt;
&lt;p&gt;2、执行解析js文件脚本代码&lt;/p&gt;
&lt;p&gt;这里主要讲浏览器页面渲染过程，js脚本解析执行过程，可以看这篇文章：&lt;span&gt;&lt;a href=&quot;https://www.mwcxs.top/page/564.html&quot; target=&quot;_blank&quot;&gt;Javascript引擎执行的过程的理解--执行阶段&lt;/a&gt; ，所以本文的js解析的内容会省略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在该过程中浏览器渲染进程会开启多个线程协作完成，主要的线程以及作用如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、GUI渲染线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）负责解析HTML文件构建DOM树，解析CSS，结合DOM树渲染成RenderObject树，然后布局和绘制页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）当RenderObject树需要更新&lt;strong&gt;样式属性&lt;/strong&gt;时，即发生&lt;strong&gt;重绘&lt;/strong&gt;（Repaint）；当RenderObject树中的&lt;strong&gt;元素规则尺寸，布局或显示隐藏&lt;/strong&gt;等发生变化，即发生&lt;strong&gt;回流&lt;/strong&gt;（reflow）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、JS引擎线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、时间出发线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、定时器触发线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、异步Http请求线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：&lt;strong&gt;GUI渲染线程与JS引擎线程是相互排斥的，因为JS引擎线程在执行的过程中可能会发生重绘和回流，&lt;/strong&gt;所以GUI渲染线程执行时候，JS引擎线程会被挂起，等待GUI渲染线程执行完毕之后，JS引擎线程执行时候同理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1GUI渲染线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先看一张图，图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/1/30KeF3LDuZQNL1dtoFDGB1Wcje.jpg&quot; alt=&quot;timg&quot;/&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我们主要分析GUI渲染线程执行的详细过程：&lt;/p&gt;
&lt;p&gt;1、解析HTML文件，构建DOM树，同时浏览器主进程负责下载CSS文件&lt;/p&gt;
&lt;p&gt;2、CSS文件下载完成，解析CSS文件成树形的数据结构，然后结合DOM树合并成RenderObject树&lt;/p&gt;
&lt;p&gt;3、布局RenderObject树，负责RenderObject树中的元素的尺寸，位置等计算&lt;/p&gt;
&lt;p&gt;4、绘制RenderObject树，绘制页面的像素信息&lt;/p&gt;
&lt;p&gt;5、浏览器主进程将默认的图层和复合图层交给GPU进程，GPU进程再将各个图层合成（conposite），最后显示出页面&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1、默认图层指的是出于普通文档流的元素&lt;/p&gt;
&lt;p&gt;2、复合图层一般指的使用动画执行或者&amp;lt;video&amp;gt;&amp;lt;iframe&amp;gt;&amp;lt;canvas&amp;gt;&amp;lt;webgl&amp;gt;等元素，也可以使用z-index将层级高的元素变成复合图层，使用复合图层可以进行硬件加速，其原理是避免了默认图层的重绘和回流，想了解更深入介意自行研究&lt;/p&gt;

&lt;p&gt;了解GUI渲染线程的执行过程，我们可以根据原理进行渲染优化：&lt;/p&gt;
&lt;p&gt;1、尽可能早的提前引入css文件，例如在头部引入css文件。&lt;/p&gt;
&lt;p&gt;2、尽可能早的加载css文件中的引入的资源，例如自定义字体文件，可以使用预加载，在link标签中加入rel=“preload” as = “font”该元素属性，不会造成渲染阻塞。&lt;/p&gt;
&lt;p&gt;3、在DOM和CSS渲染之后加载js文件，例如在尾部加载js文件，或者使用该元素属性defer和async，进行js问价异步加载，但是不同的浏览器会有兼容性问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要是介绍浏览器的渲染过程，但是没有分析js脚本文件解析过程。&lt;/p&gt;
&lt;p&gt;（一）浏览器渲染进程包含1、解析HTML文件和CSS文件，加载图片等资源文件，渲染成用户看到的页面；2、执行解析js文件脚本代码。&lt;/p&gt;
&lt;p&gt;（二）整个过程浏览器会开启多个线程协作完成，包括：GUI渲染线程，JS引擎线程，事件触发线程，定时器触发线程，异步HTTP请求线程。&lt;/p&gt;
&lt;p&gt;（三）其中GUI渲染线程和JS引擎线程是相互排斥的，因为JS引擎线程在执行的时候有可能会发生重绘和回流。&lt;/p&gt;

</description>
<pubDate>Tue, 19 Feb 2019 13:57:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>一、概述 在分析浏览器的渲染过程之前，我们先了解一下什么是进程和线程： （1）什么是进程？ 进程是CPU进行资源分配的基本单位 （2）什么是线程？ 线程是CPU调度的最小单位，是建立在进程的基础上运行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/10403622.html</dc:identifier>
</item>
</channel>
</rss>