<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Boot整合Spring Batch - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/10838744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/10838744.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　Spring Batch是处理大量数据操作的一个框架，主要用来读取大量数据，然后进行一定的处理后输出指定的形式。比如我们可以将csv文件中的数据（数据量几百万甚至几千万都是没问题的）批处理插入保存到数据库中，就可以使用该框架，但是不管是数据资料还是网上资料，我看到很少有这样的详细讲解。所以本片博文的主要目的边讲解的同时边实战（其中的代码都是经过实践的）。同样地先从Spring Boot对Batch框架的支持说起，最后一步一步进行代码实践！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;

&lt;h3&gt;1、Spring Batch框架的组成部分&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1）JobRepository：用来注册Job容器，设置数据库相关属性。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2）JobLauncher：用来启动Job的接口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3）Job：我们要实际执行的任务，包含一个或多个&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　4）Step：即步骤，包括：ItemReader-&amp;gt;ItemProcessor-&amp;gt;ItemWriter&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　5）ItemReader：用来读取数据，做实体类与数据字段之间的映射。比如读取csv文件中的人员数据，之后对应实体person的字段做mapper&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　6）ItemProcessor：用来处理数据的接口，同时可以做数据校验（设置校验器，使用JSR-303(hibernate-validator)注解），比如将中文性别男/女，转为M/F。同时校验年龄字段是否符合要求等&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　7）ItemWriter：用来输出数据的接口，设置数据库源。编写预处理SQL插入语句&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上七个组成部分，只需要在配置类中逐一注册即可，同时配置类需要开启@EnableBatchProcessing注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@EnableBatchProcessing &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启批处理的支持&lt;/span&gt;
@Import(DruidDBConfig.&lt;span&gt;class&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注入datasource&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CsvBatchConfig {
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、批处理流程图&lt;/h3&gt;
&lt;p&gt;如下流程图即可以解释在配置类中为什么需要这么定义，具体请看实战部分的代码。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201905/1352849-20190509145057653-369261159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;1、添加依赖&lt;/h3&gt;
&lt;p&gt;1）spring batch依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;  spring batch &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-batch&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）校验器依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; hibernate validator &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.hibernate&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hibernate-validator&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6.0.7.Final&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3）mysql+druid依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; mysql connector&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.1.35&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; alibaba dataSource &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;druid&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.1.12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4）test测试依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、application.yml配置&lt;/h3&gt;
&lt;p&gt;当job发布开始执行任务时，spring batch会自动生成相关的batch开头的表。这些表一开始是不存在的！需要在application配置文件中做相关的设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201905/1352849-20190509150408907-104253959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# batch
  batch:
    job:
      # 默认自动执行定义的Job(true)，改为false，需要jobLaucher.run执行
      enabled: false
    # spring batch在数据库里面创建默认的数据表，如果不是always则会提示相关表不存在
    initialize-schema: always
    # 设置batch表的前缀
#    table-prefix: csv-batch&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、数据源配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  datasource:
    username: root
    password: 1234
    url: jdbc:mysql://127.0.0.1:3306/db_base?useSSL=false&lt;/span&gt;&lt;span&gt;&amp;amp;serverTimezone&lt;/span&gt;=UTC&lt;span&gt;&amp;amp;characterEncoding&lt;/span&gt;&lt;span&gt;=utf8
    driver-class-name: com.mysql.jdbc.Driver&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注册DBConfig配置类：之后通过import导入batch配置类中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('418aa281-e7cf-42df-8b9b-eebc62f22058')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_418aa281-e7cf-42df-8b9b-eebc62f22058&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_418aa281-e7cf-42df-8b9b-eebc62f22058&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('418aa281-e7cf-42df-8b9b-eebc62f22058',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_418aa281-e7cf-42df-8b9b-eebc62f22058&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jian
 * @dete 2019/4/20
 * @description 自定义DataSource
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DruidDBConfig {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(DruidDBConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    @Value(&lt;/span&gt;&quot;${spring.datasource.url}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String dbUrl;

    @Value(&lt;/span&gt;&quot;${spring.datasource.username}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;

    @Value(&lt;/span&gt;&quot;${spring.datasource.password}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;

    @Value(&lt;/span&gt;&quot;${spring.datasource.driver-class-name}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String driverClassName;

   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; @Value(&quot;${spring.datasource.initialSize}&quot;)
    private int initialSize;

    @Value(&quot;${spring.datasource.minIdle}&quot;)
    private int minIdle;

    @Value(&quot;${spring.datasource.maxActive}&quot;)
    private int maxActive;

    @Value(&quot;${spring.datasource.maxWait}&quot;)
    private int maxWait;

    @Value(&quot;${spring.datasource.timeBetweenEvictionRunsMillis}&quot;)
    private int timeBetweenEvictionRunsMillis;

    @Value(&quot;${spring.datasource.minEvictableIdleTimeMillis}&quot;)
    private int minEvictableIdleTimeMillis;

    @Value(&quot;${spring.datasource.validationQuery}&quot;)
    private String validationQuery;

    @Value(&quot;${spring.datasource.testWhileIdle}&quot;)
    private boolean testWhileIdle;

    @Value(&quot;${spring.datasource.testOnBorrow}&quot;)
    private boolean testOnBorrow;

    @Value(&quot;${spring.datasource.testOnReturn}&quot;)
    private boolean testOnReturn;

    @Value(&quot;${spring.datasource.poolPreparedStatements}&quot;)
    private boolean poolPreparedStatements;

    @Value(&quot;${spring.datasource.maxPoolPreparedStatementPerConnectionSize}&quot;)
    private int maxPoolPreparedStatementPerConnectionSize;

    @Value(&quot;${spring.datasource.filters}&quot;)
    private String filters;

    @Value(&quot;{spring.datasource.connectionProperties}&quot;)
    private String connectionProperties;&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    @Bean
    @Primary  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 被注入的优先级最高&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DataSource dataSource() {
        DruidDataSource dataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DruidDataSource();
        logger.info(&lt;/span&gt;&quot;--------&amp;gt;dataSource[url=&quot;+dbUrl+&quot; ,username=&quot;+username+&quot;]&quot;&lt;span&gt;);
        dataSource.setUrl(dbUrl);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setDriverClassName(driverClassName);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  //configuration
        datasource.setInitialSize(initialSize);
        datasource.setMinIdle(minIdle);
        datasource.setMaxActive(maxActive);
        datasource.setMaxWait(maxWait);
        datasource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
        datasource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        datasource.setValidationQuery(validationQuery);
        datasource.setTestWhileIdle(testWhileIdle);
        datasource.setTestOnBorrow(testOnBorrow);
        datasource.setTestOnReturn(testOnReturn);
        datasource.setPoolPreparedStatements(poolPreparedStatements);
        datasource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize);
        try {
            datasource.setFilters(filters);
        } catch (SQLException e) {
            logger.error(&quot;druid configuration initialization filter&quot;, e);
        }
        datasource.setConnectionProperties(connectionProperties);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataSource;
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServletRegistrationBean druidServletRegistrationBean() {
        ServletRegistrationBean servletRegistrationBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletRegistrationBean();
        servletRegistrationBean.setServlet(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StatViewServlet());
        servletRegistrationBean.addUrlMappings(&lt;/span&gt;&quot;/druid/*&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; servletRegistrationBean;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 注册DruidFilter拦截
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FilterRegistrationBean duridFilterRegistrationBean() {
        FilterRegistrationBean filterRegistrationBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FilterRegistrationBean();
        filterRegistrationBean.setFilter(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebStatFilter());
        Map&lt;/span&gt;&amp;lt;String, String&amp;gt; initParams = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置忽略请求&lt;/span&gt;
        initParams.put(&quot;exclusions&quot;, &quot;*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*&quot;&lt;span&gt;);
        filterRegistrationBean.setInitParameters(initParams);
        filterRegistrationBean.addUrlPatterns(&lt;/span&gt;&quot;/*&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; filterRegistrationBean;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;4、编写batch配置类&lt;/h3&gt;
&lt;p&gt;在配置类中，注册Spring Batch的各个组成部分即可，其中部分说明已在代码中注释.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('40ef025e-4aa5-4038-b872-36cb97e74bfd')&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_40ef025e-4aa5-4038-b872-36cb97e74bfd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_40ef025e-4aa5-4038-b872-36cb97e74bfd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('40ef025e-4aa5-4038-b872-36cb97e74bfd',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_40ef025e-4aa5-4038-b872-36cb97e74bfd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jian
 * @date 2019/4/28
 * @description spring batch cvs文件批处理配置需要注入Spring Batch以下组成部分
 * spring batch组成：
 * 1）JobRepository 注册job的容器
 * 2）JonLauncher 用来启动job的接口
 * 3）Job 实际执行的任务，包含一个或多个Step
 * 4）Step Step步骤包括ItemReader、ItemProcessor和ItemWrite
 * 5）ItemReader 读取数据的接口
 * 6）ItemProcessor 处理数据的接口
 * 7）ItemWrite 输出数据的接口
 *
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
@EnableBatchProcessing &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启批处理的支持&lt;/span&gt;
@Import(DruidDBConfig.&lt;span&gt;class&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注入datasource&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CsvBatchConfig {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(CsvBatchConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * ItemReader定义：读取文件数据+entirty映射
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ItemReader&amp;lt;Person&amp;gt;&lt;span&gt; reader(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用FlatFileItemReader去读cvs文件，一行即一条数据&lt;/span&gt;
        FlatFileItemReader&amp;lt;Person&amp;gt; reader = &lt;span&gt;new&lt;/span&gt; FlatFileItemReader&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置文件处在路径&lt;/span&gt;
        reader.setResource(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;person.csv&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; entity与csv数据做映射&lt;/span&gt;
        reader.setLineMapper(&lt;span&gt;new&lt;/span&gt; DefaultLineMapper&amp;lt;Person&amp;gt;&lt;span&gt;() {
            {
                setLineTokenizer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DelimitedLineTokenizer() {
                    {
                        setNames(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String[]{&quot;id&quot;, &quot;name&quot;, &quot;age&quot;, &quot;gender&quot;&lt;span&gt;});
                    }
                });
                setFieldSetMapper(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; BeanWrapperFieldSetMapper&amp;lt;Person&amp;gt;&lt;span&gt;() {
                    {
                        setTargetType(Person.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                    }
                });
            }
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; reader;
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 注册ItemProcessor: 处理数据+校验数据
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ItemProcessor&amp;lt;Person, Person&amp;gt;&lt;span&gt; processor(){
        CvsItemProcessor cvsItemProcessor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CvsItemProcessor();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置校验器&lt;/span&gt;
&lt;span&gt;        cvsItemProcessor.setValidator(csvBeanValidator());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cvsItemProcessor;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 注册校验器
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CsvBeanValidator csvBeanValidator(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CsvBeanValidator&amp;lt;Person&amp;gt;&lt;span&gt;();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * ItemWriter定义：指定datasource，设置批量插入sql语句，写入数据库
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; dataSource
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ItemWriter&amp;lt;Person&amp;gt;&lt;span&gt; writer(DataSource dataSource){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用jdbcBcatchItemWrite写数据到数据库中&lt;/span&gt;
        JdbcBatchItemWriter&amp;lt;Person&amp;gt; writer = &lt;span&gt;new&lt;/span&gt; JdbcBatchItemWriter&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置有参数的sql语句&lt;/span&gt;
        writer.setItemSqlParameterSourceProvider(&lt;span&gt;new&lt;/span&gt; BeanPropertyItemSqlParameterSourceProvider&amp;lt;Person&amp;gt;&lt;span&gt;());
        String sql &lt;/span&gt;= &quot;insert into person values(:id,:name,:age,:gender)&quot;&lt;span&gt;;
        writer.setSql(sql);
        writer.setDataSource(dataSource);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; writer;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * JobRepository定义：设置数据库，注册Job容器
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; dataSource
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; transactionManager
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; JobRepository cvsJobRepository(DataSource dataSource, PlatformTransactionManager transactionManager) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        JobRepositoryFactoryBean jobRepositoryFactoryBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JobRepositoryFactoryBean();
        jobRepositoryFactoryBean.setDatabaseType(&lt;/span&gt;&quot;mysql&quot;&lt;span&gt;);
        jobRepositoryFactoryBean.setTransactionManager(transactionManager);
        jobRepositoryFactoryBean.setDataSource(dataSource);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jobRepositoryFactoryBean.getObject();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * jobLauncher定义：
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; dataSource
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; transactionManager
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SimpleJobLauncher csvJobLauncher(DataSource dataSource, PlatformTransactionManager transactionManager) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        SimpleJobLauncher jobLauncher &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleJobLauncher();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置jobRepository&lt;/span&gt;
&lt;span&gt;        jobLauncher.setJobRepository(cvsJobRepository(dataSource, transactionManager));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jobLauncher;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 定义job
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; jobs
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; step
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Job importJob(JobBuilderFactory jobs, Step step){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; jobs.get(&quot;importCsvJob&quot;&lt;span&gt;)
                .incrementer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RunIdIncrementer())
                .flow(step)
                .end()
                .listener(csvJobListener())
                .build();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 注册job监听器
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CsvJobListener csvJobListener(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CsvJobListener();
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * step定义：步骤包括ItemReader-&amp;gt;ItemProcessor-&amp;gt;ItemWriter 即读取数据-&amp;gt;处理校验数据-&amp;gt;写入数据
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; stepBuilderFactory
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; reader
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; writer
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; processor
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Step step(StepBuilderFactory stepBuilderFactory, ItemReader&amp;lt;Person&amp;gt;&lt;span&gt; reader,
                     ItemWriter&lt;/span&gt;&amp;lt;Person&amp;gt; writer, ItemProcessor&amp;lt;Person, Person&amp;gt;&lt;span&gt; processor){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stepBuilderFactory
                .get(&lt;/span&gt;&quot;step&quot;&lt;span&gt;)
                .&lt;/span&gt;&amp;lt;Person, Person&amp;gt;chunk(65000) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Chunk的机制(即每次读取一条数据，再处理一条数据，累积到一定数量后再一次性交给writer进行写入操作)&lt;/span&gt;
&lt;span&gt;                .reader(reader)
                .processor(processor)
                .writer(writer)
                .build();

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;5、定义处理器&lt;/h3&gt;
&lt;p&gt;只需要实现ItemProcessor接口，重写process方法，输入的参数是从ItemReader读取到的数据，返回的数据给ItemWriter&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jian
 * @date 2019/4/28
 * @description
 * CSV文件数据处理及校验
 * 只需要实现ItemProcessor接口，重写process方法，输入的参数是从ItemReader读取到的数据，返回的数据给ItemWriter
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CvsItemProcessor &lt;span&gt;extends&lt;/span&gt; ValidatingItemProcessor&amp;lt;Person&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(CvsItemProcessor.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Person process(Person item) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ValidationException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行super.process()才能调用自定义的校验器&lt;/span&gt;
        logger.info(&quot;processor start validating...&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.process(item);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据处理，比如将中文性别设置为M/F&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&quot;男&quot;&lt;span&gt;.equals(item.getGender())) {
            item.setGender(&lt;/span&gt;&quot;M&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            item.setGender(&lt;/span&gt;&quot;F&quot;&lt;span&gt;);
        }
        logger.info(&lt;/span&gt;&quot;processor end validating...&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; item;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6、定义校验器&lt;/h3&gt;
&lt;p&gt;定义校验器：使用JSR-303(hibernate-validator)注解，来校验ItemReader读取到的数据是否满足要求。如不满足则不会进行接下来的批处理任务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('200b6b27-319b-412d-919f-3267795def97')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_200b6b27-319b-412d-919f-3267795def97&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_200b6b27-319b-412d-919f-3267795def97&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('200b6b27-319b-412d-919f-3267795def97',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_200b6b27-319b-412d-919f-3267795def97&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jian
 * @date 2019/4/28
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt;
 * @description 定义校验器：使用JSR-303(hibernate-validator)注解，来校验ItemReader读取到的数据是否满足要求。
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CsvBeanValidator&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt; Validator&amp;lt;T&amp;gt;&lt;span&gt;, InitializingBean {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; javax.validation.Validator validator;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 进行JSR-303的Validator的初始化
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterPropertiesSet() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        ValidatorFactory validatorFactory &lt;/span&gt;=&lt;span&gt; Validation.buildDefaultValidatorFactory();
        validator &lt;/span&gt;=&lt;span&gt; validatorFactory.usingContext().getValidator();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用validator方法检验数据
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ValidationException
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; validate(T value) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ValidationException {
        Set&lt;/span&gt;&amp;lt;ConstraintViolation&amp;lt;T&amp;gt;&amp;gt; constraintViolations =&lt;span&gt; validator.validate(value);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (constraintViolations.size() &amp;gt; 0&lt;span&gt;) {
            StringBuilder message &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (ConstraintViolation&amp;lt;T&amp;gt;&lt;span&gt; constraintViolation: constraintViolations) {
                message.append(constraintViolation.getMessage() &lt;/span&gt;+ &quot;\n&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValidationException(message.toString());
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;7、定义监听器：&lt;/h3&gt;
&lt;p&gt;监听Job执行情况，则定义一个类实现JobExecutorListener，并定义Job的Bean上绑定该监听器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; jian
 * @date 2019/4/28
 * @description
 * 监听Job执行情况，则定义一个类实现JobExecutorListener，并定义Job的Bean上绑定该监听器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CsvJobListener &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; JobExecutionListener {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = LoggerFactory.getLogger(CsvJobListener.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; startTime;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; endTime;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeJob(JobExecution jobExecution) {
        startTime &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
        logger.info(&lt;/span&gt;&quot;job process start...&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterJob(JobExecution jobExecution) {
        endTime &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
        logger.info(&lt;/span&gt;&quot;job process end...&quot;&lt;span&gt;);
        logger.info(&lt;/span&gt;&quot;elapsed time: &quot; + (endTime - startTime) + &quot;ms&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;1、person.csv文件&lt;/h3&gt;
&lt;p&gt;csv文件时以逗号为分隔的数据表示字段，回车表示一行（条）数据记录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
1,Zhangsan,21&lt;span&gt;,男
&lt;/span&gt;2,Lisi,22&lt;span&gt;,女
&lt;/span&gt;3,Wangwu,23&lt;span&gt;,男
&lt;/span&gt;4,Zhaoliu,24&lt;span&gt;,男
&lt;/span&gt;5,Zhouqi,25,女
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;放在resources下，在ItemReader中读取的该路径即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201905/1352849-20190509151040677-216373897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、person实体&lt;/h3&gt;
&lt;p&gt;person.csv中的字段与之对应，并在该实体中可以添加校验注解，如@Size表示该字段的长度范围，如果超过规定。则会被校验检测到，批处理将不会进行！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1272ea88-0de0-4663-837c-bda3b080af55')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_1272ea88-0de0-4663-837c-bda3b080af55&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1272ea88-0de0-4663-837c-bda3b080af55&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1272ea88-0de0-4663-837c-bda3b080af55',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1272ea88-0de0-4663-837c-bda3b080af55&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String id;
    @Size(min &lt;/span&gt;= 2, max = 8&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String gender;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(String id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getGender() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; gender;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setGender(String gender) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.gender =&lt;span&gt; gender;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Person{&quot; +
                &quot;id='&quot; + id + '\'' +
                &quot;, name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, gender='&quot; + gender + '\'' +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;3、数据表&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `person` (
  `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `name` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `age` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `gender` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;latin1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一开始表是没有数据的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201905/1352849-20190509151947698-983575510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4、测试类&lt;/h3&gt;
&lt;p&gt;需要注入发布器，与job任务。同时可以使用后置参数灵活处理，最后调用JobLauncher.run方法执行批处理任务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
@RunWith(SpringRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@SpringBootTest
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BatchTest {

    @Autowired
    SimpleJobLauncher jobLauncher;

    @Autowired
    Job importJob;

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后置参数：使用JobParameters中绑定参数&lt;/span&gt;
        JobParameters jobParameters = &lt;span&gt;new&lt;/span&gt; JobParametersBuilder().addLong(&quot;time&quot;&lt;span&gt;, System.currentTimeMillis())
                .toJobParameters();
        jobLauncher.run(importJob, jobParameters);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5、测试结果&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
....&lt;br/&gt;2019-05-09 15:23:39.576  INFO 18296 --- [           main] com.lijian.test.BatchTest                : Started BatchTest in 6.214 seconds (JVM running &lt;span&gt;for&lt;/span&gt; 7.185&lt;span&gt;)
&lt;/span&gt;2019-05-09 15:23:39.939  INFO 18296 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : Job: [FlowJob: [name=importCsvJob]] launched with the following parameters: [{time=1557386619763&lt;span&gt;}]
&lt;/span&gt;2019-05-09 15:23:39.982  INFO 18296 ---&lt;span&gt; [           main] com.lijian.config.batch.CsvJobListener   : job process start...
&lt;/span&gt;2019-05-09 15:23:40.048  INFO 18296 ---&lt;span&gt; [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [step]
&lt;/span&gt;2019-05-09 15:23:40.214  INFO 18296 ---&lt;span&gt; [           main] c.lijian.config.batch.CvsItemProcessor   : processor start validating...
&lt;/span&gt;2019-05-09 15:23:40.282  INFO 18296 ---&lt;span&gt; [           main] c.lijian.config.batch.CvsItemProcessor   : processor end validating...
&lt;/span&gt;2019-05-09 15:23:40.283  INFO 18296 ---&lt;span&gt; [           main] c.lijian.config.batch.CvsItemProcessor   : processor start validating...
&lt;/span&gt;2019-05-09 15:23:40.283  INFO 18296 ---&lt;span&gt; [           main] c.lijian.config.batch.CvsItemProcessor   : processor end validating...
&lt;/span&gt;2019-05-09 15:23:40.283  INFO 18296 ---&lt;span&gt; [           main] c.lijian.config.batch.CvsItemProcessor   : processor start validating...
&lt;/span&gt;2019-05-09 15:23:40.283  INFO 18296 ---&lt;span&gt; [           main] c.lijian.config.batch.CvsItemProcessor   : processor end validating...
&lt;/span&gt;2019-05-09 15:23:40.283  INFO 18296 ---&lt;span&gt; [           main] c.lijian.config.batch.CvsItemProcessor   : processor start validating...
&lt;/span&gt;2019-05-09 15:23:40.283  INFO 18296 ---&lt;span&gt; [           main] c.lijian.config.batch.CvsItemProcessor   : processor end validating...
&lt;/span&gt;2019-05-09 15:23:40.283  INFO 18296 ---&lt;span&gt; [           main] c.lijian.config.batch.CvsItemProcessor   : processor start validating...
&lt;/span&gt;2019-05-09 15:23:40.284  INFO 18296 ---&lt;span&gt; [           main] c.lijian.config.batch.CvsItemProcessor   : processor end validating...
&lt;/span&gt;2019-05-09 15:23:40.525  INFO 18296 ---&lt;span&gt; [           main] com.lijian.config.batch.CsvJobListener   : job process end...
&lt;/span&gt;2019-05-09 15:23:40.526  INFO 18296 ---&lt;span&gt; [           main] com.lijian.config.batch.CsvJobListener   : elapsed time: 543ms
&lt;/span&gt;2019-05-09 15:23:40.548  INFO 18296 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : Job: [FlowJob: [name=importCsvJob]] completed with the following parameters: [{time=1557386619763&lt;span&gt;}] and the following status: [COMPLETED]
&lt;/span&gt;2019-05-09 15:23:40.564  INFO 18296 --- [       Thread-5] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} closed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看表中数据： &lt;span class=&quot;cnblogs_code&quot;&gt;select * from person;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201905/1352849-20190509152601155-880594872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若继续插入数据，并且测试校验器是否生效，则将person.csv更改为如下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
6,springbatch,24&lt;span&gt;,男
&lt;/span&gt;7,springboot,23,女
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于实体类中JSR校验注解对name长度范围进行了检验，即添加了 &lt;span class=&quot;cnblogs_code&quot;&gt;@Size(min=2, max=8)&lt;/span&gt; 的注解。故会报错显示校验不通过，批处理将不会进行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;...
Started BatchTest in &lt;/span&gt;5.494 seconds (JVM running &lt;span&gt;for&lt;/span&gt; 6.41&lt;span&gt;)
&lt;/span&gt;2019-05-09 15:30:02.147  INFO 20368 --- [           main] o.s.b.c.l.support.SimpleJobLauncher      : Job: [FlowJob: [name=importCsvJob]] launched with the following parameters: [{time=1557387001499&lt;span&gt;}]
&lt;/span&gt;2019-05-09 15:30:02.247  INFO 20368 ---&lt;span&gt; [           main] com.lijian.config.batch.CsvJobListener   : job process start...
&lt;/span&gt;2019-05-09 15:30:02.503  INFO 20368 ---&lt;span&gt; [           main] o.s.batch.core.job.SimpleStepHandler     : Executing step: [step]
&lt;/span&gt;2019-05-09 15:30:02.683  INFO 20368 ---&lt;span&gt; [           main] c.lijian.config.batch.CvsItemProcessor   : processor start validating...
&lt;/span&gt;2019-05-09 15:30:02.761 ERROR 20368 ---&lt;span&gt; [           main] o.s.batch.core.step.AbstractStep         : Encountered an error executing step step in job importCsvJob

org.springframework.batch.item.validator.ValidationException: size must be between &lt;/span&gt;2 and 8&lt;span&gt;
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 09 May 2019 07:41:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<og:description>引言 Spring Batch是处理大量数据操作的一个框架，主要用来读取大量数据，然后进行一定的处理后输出指定的形式。比如我们可以将csv文件中的数据（数据量几百万甚至几千万都是没问题的）批处理插入保</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/10838744.html</dc:identifier>
</item>
<item>
<title>Go语言调度器之调度main goroutine（14） - 爱写程序的阿波张</title>
<link>http://www.cnblogs.com/abozhang/p/10838719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abozhang/p/10838719.html</guid>
<description>&lt;p&gt;本文是《Go语言调度器源代码情景分析》系列的第14篇，也是第二章的第4小节。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;上一节我们通过分析main goroutine的创建详细讨论了goroutine的创建及初始化流程，这一节我们接着来分析调度器如何把main goroutine调度到CPU上去运行。本节需要重点关注的问题有：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何保存g0的调度信息？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;schedule函数有什么重要作用？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;gogo函数如何完成从g0到main goroutine的切换？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着前一节继续分析代码，从newproc返回到rt0_go，继续往下执行mstart。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/proc.go : 1153&lt;/em&gt; &lt;/p&gt;
&lt;div lang=&quot;go&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func mstart() {
        _g_ := getg() //_g_ = g0

        //对于启动过程来说，g0的stack.lo早已完成初始化，所以onStack = false
        osStack := _g_.stack.lo == 0
        if osStack {
                // Initialize stack bounds from system stack.
                // Cgo may have left stack size in stack.hi.
                // minit may update the stack bounds.
                size := _g_.stack.hi
                if size == 0 {
                        size = 8192 * sys.StackGuardMultiplier
                }
                _g_.stack.hi = uintptr(noescape(unsafe.Pointer(&amp;amp;size)))
                _g_.stack.lo = _g_.stack.hi - size + 1024
        }
        // Initialize stack guards so that we can start calling
        // both Go and C functions with stack growth prologues.
        _g_.stackguard0 = _g_.stack.lo + _StackGuard
        _g_.stackguard1 = _g_.stackguard0
    
        mstart1()

        // Exit this thread.
        if GOOS == &quot;windows&quot; || GOOS == &quot;solaris&quot; || GOOS == &quot;plan9&quot; || GOOS == &quot;darwin&quot; || GOOS == &quot;aix&quot; {
                // Window, Solaris, Darwin, AIX and Plan 9 always system-allocate
                // the stack, but put it in _g_.stack before mstart,
                // so the logic above hasn't set osStack yet.
                osStack = true
        }
        mexit(osStack)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;mstart函数本身没啥说的，它继续调用mstart1函数。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/proc.go : 1184&lt;/em&gt; &lt;/p&gt;
&lt;div lang=&quot;go&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func mstart1() {
        _g_ := getg()  //启动过程时 _g_ = m0的g0

        if _g_ != _g_.m.g0 {
                throw(&quot;bad runtime·mstart&quot;)
        }

        // Record the caller for use as the top of stack in mcall and
        // for terminating the thread.
        // We're never coming back to mstart1 after we call schedule,
        // so other calls can reuse the current frame.
        //getcallerpc()获取mstart1执行完的返回地址
        //getcallersp()获取调用mstart1时的栈顶地址
        save(getcallerpc(), getcallersp())
        asminit()  //在AMD64 Linux平台中，这个函数什么也没做，是个空函数
        minit()    //与信号相关的初始化，目前不需要关心

        // Install signal handlers; after minit so that minit can
        // prepare the thread to be able to handle the signals.
        if _g_.m == &amp;amp;m0 { //启动时_g_.m是m0，所以会执行下面的mstartm0函数
                mstartm0() //也是信号相关的初始化，现在我们不关注
        }

        if fn := _g_.m.mstartfn; fn != nil { //初始化过程中fn == nil
                fn()
        }

        if _g_.m != &amp;amp;m0 {// m0已经绑定了allp[0]，不是m0的话还没有p，所以需要获取一个p
                acquirep(_g_.m.nextp.ptr())
                _g_.m.nextp = 0
        }
    
        //schedule函数永远不会返回
        schedule()
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;mstart1首先调用save函数来保存g0的调度信息，&lt;strong&gt;save这一行代码非常重要，是我们理解调度循环的关键点之一&lt;/strong&gt;。这里首先需要注意的是代码中的getcallerpc()返回的是mstart调用mstart1时被call指令压栈的返回地址，getcallersp()函数返回的是调用mstart1函数之前mstart函数的栈顶地址，其次需要看看save函数到底做了哪些重要工作。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/proc.go : 2733&lt;/em&gt; &lt;/p&gt;
&lt;div lang=&quot;go&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// save updates getg().sched to refer to pc and sp so that a following
// gogo will restore pc and sp.
//
// save must not have write barriers because invoking a write barrier
// can clobber getg().sched.
//
//go:nosplit
//go:nowritebarrierrec
func save(pc, sp uintptr) {
        _g_ := getg()

        _g_.sched.pc = pc //再次运行时的指令地址
        _g_.sched.sp = sp //再次运行时到栈顶
        _g_.sched.lr = 0
        _g_.sched.ret = 0
        _g_.sched.g = guintptr(unsafe.Pointer(_g_))
        // We need to ensure ctxt is zero, but can't have a write
        // barrier here. However, it should always already be zero.
        // Assert that.
        if _g_.sched.ctxt != nil {
                badctxt()
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看到，save函数保存了调度相关的所有信息，包括最为重要的当前正在运行的g的下一条指令的地址和栈顶地址，不管是对g0还是其它goroutine来说这些信息在调度过程中都是必不可少的，我们会在后面的调度分析中看到调度器是如何利用这些信息来完成调度的。代码执行完save函数之后g0的状态如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1671650/201905/1671650-20190509152704722-1766773488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，g0.sched.sp指向了mstart1函数执行完成后的返回地址，该地址保存在了mstart函数的栈帧之中；g0.sched.pc指向的是mstart函数中调用mstart1函数之后的 if 语句。&lt;/p&gt;
&lt;p&gt;为什么g0已经执行到mstart1这个函数了而且还会继续调用其它函数，但g0的调度信息中的pc和sp却要设置在mstart函数中？难道下次切换到g0时要从mstart函数中的 if 语句继续执行？可是从mstart函数可以看到，if语句之后就要退出线程了！这看起来很奇怪，不过随着分析的进行，我们会看到这里为什么要这么做。&lt;/p&gt;
&lt;p&gt;继续分析代码，save函数执行完成后，返回到mstart1继续其它跟m相关的一些初始化，完成这些初始化后则调用调度系统的核心函数schedule()完成goroutine的调度，之所以说它是核心，原因在于每次调度goroutine都是从schedule函数开始的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/proc.go : 2469&lt;/em&gt;&lt;/p&gt;
&lt;div lang=&quot;go&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// One round of scheduler: find a runnable goroutine and execute it.
// Never returns.
func schedule() {
        _g_ := getg()  //_g_ = 每个工作线程m对应的g0，初始化时是m0的g0

        //......

        var gp *g
        
        //......
    
        if gp == nil {
                // Check the global runnable queue once in a while to ensure fairness.
                // Otherwise two goroutines can completely occupy the local runqueue
                // by constantly respawning each other.
                //为了保证调度的公平性，每进行61次调度就需要优先从全局运行队列中获取goroutine，
                //因为如果只调度本地队列中的g，那么全局运行队列中的goroutine将得不到运行
                if _g_.m.p.ptr().schedtick%61 == 0 &amp;amp;&amp;amp; sched.runqsize &amp;gt; 0 {
                        lock(&amp;amp;sched.lock) //所有工作线程都能访问全局运行队列，所以需要加锁
                        gp = globrunqget(_g_.m.p.ptr(), 1) //从全局运行队列中获取1个goroutine
                        unlock(&amp;amp;sched.lock)
                }
        }
        if gp == nil {
        //从与m关联的p的本地运行队列中获取goroutine
                gp, inheritTime = runqget(_g_.m.p.ptr())
                if gp != nil &amp;amp;&amp;amp; _g_.m.spinning {
                        throw(&quot;schedule: spinning with local work&quot;)
                }
        }
        if gp == nil {
        //如果从本地运行队列和全局运行队列都没有找到需要运行的goroutine，
        //则调用findrunnable函数从其它工作线程的运行队列中偷取，如果偷取不到，则当前工作线程进入睡眠，
        //直到获取到需要运行的goroutine之后findrunnable函数才会返回。
                gp, inheritTime = findrunnable() // blocks until work is available
        }

        //跟启动无关的代码.....

        //当前运行的是runtime的代码，函数调用栈使用的是g0的栈空间
        //调用execte切换到gp的代码和栈空间去运行
        execute(gp, inheritTime)  
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;schedule函数通过调用globrunqget()和runqget()函数分别从全局运行队列和当前工作线程的本地运行队列中选取下一个需要运行的goroutine，如果这两个队列都没有需要运行的goroutine则通过findrunnalbe()函数从其它p的运行队列中盗取goroutine，一旦找到下一个需要运行的goroutine，则调用excute函数从g0切换到该goroutine去运行。对于我们这个场景来说，前面的启动流程已经创建好第一个goroutine并放入了当前工作线程的本地运行队列，所以这里会通过runqget把目前唯一的一个goroutine取出来，至于具体是如何取出来的，我们将在第三章讨论调度策略时再回头来详细分析globrunqget()，runqget()和findrunnable()这三个函数的实现流程，现在我们先来分析execute函数是如何把从运行队列中找出来的goroutine调度到CPU上运行的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;runtime/proc.go : 2136&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div lang=&quot;go&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// Schedules gp to run on the current M.
// If inheritTime is true, gp inherits the remaining time in the
// current time slice. Otherwise, it starts a new time slice.
// Never returns.
//
// Write barriers are allowed because this is called immediately after
// acquiring a P in several places.
//
//go:yeswritebarrierrec
func execute(gp *g, inheritTime bool) {
        _g_ := getg() //g0

        //设置待运行g的状态为_Grunning
        casgstatus(gp, _Grunnable, _Grunning)
        
        //......
    
        //把g和m关联起来
        _g_.m.curg = gp 
        gp.m = _g_.m

        //......

        //gogo完成从g0到gp真正的切换
        gogo(&amp;amp;gp.sched)
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;execute函数的第一个参数gp即是需要调度起来运行的goroutine，这里首先把gp的状态从_Grunnable修改为_Grunning，然后把gp和m关联起来，这样通过m就可以找到当前工作线程正在执行哪个goroutine，反之亦然。&lt;/p&gt;
&lt;p&gt;完成gp运行前的准备工作之后，execute调用gogo函数完成从g0到gp的的切换：CPU执行权的转让以及栈的切换。&lt;/p&gt;
&lt;p&gt;gogo函数也是通过汇编语言编写的，这里之所以需要使用汇编，是因为goroutine的调度涉及不同执行流之间的切换，前面我们在讨论操作系统切换线程时已经看到过，执行流的切换从本质上来说就是CPU寄存器以及函数调用栈的切换，然而不管是go还是c这种高级语言都无法精确控制CPU寄存器的修改，因而高级语言在这里也就无能为力了，只能依靠汇编指令来达成目的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/asm_amd64.s : 251&lt;/em&gt;&lt;/p&gt;
&lt;div lang=&quot;assembly&quot; readability=&quot;15&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# func gogo(buf *gobuf)
# restore state from Gobuf&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; longjmp&lt;/span&gt;
TEXT runtime·gogo(SB), NOSPLIT, $&lt;span&gt;16&lt;/span&gt;-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
    #buf = &amp;amp;gp.sched
    MOVQ    buf+&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;(FP), BX        # BX = buf
    
    #gobuf-&amp;gt;g --&amp;gt; dx register
    MOVQ    gobuf_g(BX), DX  # DX = gp.sched.g
    
    #下面这行代码没有实质作用，检查gp.sched.g是否是nil，如果是nil进程会crash死掉
    MOVQ    &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;(DX), CX        # make sure g != nil
    
    get_tls(CX) 
    
    #把要运行的g的指针放入线程本地存储，这样后面的代码就可以通过线程本地存储
    #获取到当前正在执行的goroutine的g结构体对象，从而找到与之关联的m和p
    MOVQ    DX, g(CX)
    
    #把CPU的SP寄存器设置为sched.sp，完成了栈的切换
    MOVQ    gobuf_sp(BX), SP    # restore SP
    
    #下面三条同样是恢复调度上下文到CPU相关寄存器
    MOVQ    gobuf_ret(BX), AX
    MOVQ    gobuf_ctxt(BX), DX
    MOVQ    gobuf_bp(BX), BP
    
    #清空sched的值，因为我们已把相关值放入CPU对应的寄存器了，不再需要，这样做可以少gc的工作量
    MOVQ    $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, gobuf_sp(BX)    # clear to help garbage collector
    MOVQ    $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, gobuf_ret(BX)
    MOVQ    $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, gobuf_ctxt(BX)
    MOVQ    $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, gobuf_bp(BX)
    
    #把sched.pc值放入BX寄存器
    MOVQ    gobuf_pc(BX), BX
    
    #JMP把BX寄存器的包含的地址值放入CPU的IP寄存器，于是，CPU跳转到该地址继续执行指令，
    &lt;/span&gt;&lt;span&gt;JMP&lt;/span&gt;    BX
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;gogo函数的这段汇编代码短小而强悍，虽然笔者已经在代码中做了详细的注释，但为了完全搞清楚它的工作原理，我们有必要再对这些指令进行逐条分析：&lt;/p&gt;
&lt;p&gt;execute函数在调用gogo时把gp的sched成员的地址作为实参（型参buf）传递了过来，该参数位于FP寄存器所指的位置，所以第1条指令 &lt;/p&gt;
&lt;div lang=&quot;assembly&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MOVQ    buf+&lt;span&gt;0&lt;/span&gt;(FP), BX        # &amp;amp;gp.sched --&amp;gt; BX
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;把buf的值也就是gp.sched的地址放在了BX寄存器之中，这样便于后面的指令依靠BX寄存器来存取gp.sched的成员。sched成员保存了调度相关的信息，上一节我们已经看到，main goroutine创建时已经把这些信息设置好了。&lt;/p&gt;
&lt;p&gt;第2条指令 &lt;/p&gt;
&lt;div lang=&quot;assembly&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MOVQ    gobuf_g(BX), DX  # gp.sched.g --&amp;gt; DX
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;把gp.sched.g读取到DX寄存器，注意这条指令的源操作数是间接寻址，如果读者对间接寻址不熟悉的话可以参考预备知识汇编语言部分。&lt;/p&gt;
&lt;p&gt;第3条指令 &lt;/p&gt;
&lt;div lang=&quot;assembly&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MOVQ    &lt;span&gt;0&lt;/span&gt;(DX), CX        # make sure g != nil
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;的作用在于检查gp.sched.g是否为nil，如果为nil指针的话，这条指令会导致程序死掉，有读者可能会有疑问，为什么要让它死掉啊，原因在于这个gp.sched.g是由go runtime代码负责设置的，按道理说不可能为nil，如果为nil，一定是程序逻辑写得有问题，所以需要把这个bug暴露出来，而不是把它隐藏起来。&lt;/p&gt;
&lt;p&gt;第4条和第5条指令&lt;/p&gt;
&lt;div lang=&quot;assembly&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;get_tls(CX) 
#把DX值也就是需要运行的goroutine的指针写入线程本地存储之中
#运行这条指令之前，线程本地存储存放的是g0的地址
MOVQ    DX, g(CX)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;把DX寄存器的值也就是gp.sched.g(这是一个指向g的指针)写入线程本地存储之中，这样后面的代码就可以通过线程本地存储获取到当前正在执行的goroutine的g结构体对象，从而找到与之关联的m和p。&lt;/p&gt;
&lt;p&gt;第6条指令&lt;/p&gt;
&lt;div lang=&quot;assembly&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MOVQ    gobuf_sp(BX), SP    # restore SP
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;设置CPU的栈顶寄存器SP为gp.sched.sp，这条指令完成了栈的切换，从g0的栈切换到了gp的栈。&lt;/p&gt;
&lt;p&gt;第7～13条指令&lt;/p&gt;
&lt;div lang=&quot;assembly&quot; readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#下面三条同样是恢复调度上下文到CPU相关寄存器
    MOVQ    gobuf_ret(BX), AX #系统调用的返回值放入AX寄存器
    MOVQ    gobuf_ctxt(BX), DX
    MOVQ    gobuf_bp(BX), BP
    
    #清空gp.sched中不再需要的值，因为我们已把相关值放入CPU对应的寄存器了，不再需要，这样做可以少gc的工作量
    MOVQ    $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, gobuf_sp(BX)    // clear to help garbage collector
    MOVQ    $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, gobuf_ret(BX)
    MOVQ    $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, gobuf_ctxt(BX)
    MOVQ    $&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, gobuf_bp(BX)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;一是根据gp.sched其它字段设置CPU相关寄存器，可以看到这里恢复了CPU的栈基地址寄存器BP，二是把gp.sched中已经不需要的成员设置为0，这样可以减少gc的工作量。&lt;/p&gt;
&lt;p&gt;第14条指令 &lt;/p&gt;
&lt;div lang=&quot;assembly&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
MOVQ    gobuf_pc(BX), BX
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;把gp.sched.pc的值读取到BX寄存器，这个pc值是gp这个goroutine马上需要执行的第一条指令的地址，对于我们这个场景来说它现在就是runtime.main函数的第一条指令，现在这条指令的地址就放在BX寄存器里面。最后一条指令&lt;/p&gt;

&lt;p&gt;这里的JMP BX指令把BX寄存器里面的指令地址放入CPU的rip寄存器，于是，CPU就会跳转到该地址继续执行属于gp这个goroutine的代码，这样就完成了goroutine的切换。&lt;/p&gt;
&lt;p&gt;总结一下这15条指令，其实就只做了两件事：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;把gp.sched的成员恢复到CPU的寄存器完成状态以及栈的切换；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;跳转到gp.sched.pc所指的指令地址（runtime.main）处执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;现在已经从g0切换到了gp这个goroutine，对于我们这个场景来说，gp还是第一次被调度起来运行，它的入口函数是runtime.main，所以接下来CPU就开始执行runtime.main函数：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/proc.go : 109&lt;/em&gt;&lt;/p&gt;
&lt;div lang=&quot;go&quot; readability=&quot;10&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// The main goroutine.
func main() {
        g := getg()  // g = main goroutine，不再是g0了

        // ......

        // Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.
        // Using decimal instead of binary GB and MB because
        // they look nicer in the stack overflow failure message.
        if sys.PtrSize == 8 { //64位系统上每个goroutine的栈最大可达1G
                maxstacksize = 1000000000
        } else {
                maxstacksize = 250000000
        }

        // Allow newproc to start new Ms.
        mainStarted = true

    if GOARCH != &quot;wasm&quot; { // no threads on wasm yet, so no sysmon
        //现在执行的是main goroutine，所以使用的是main goroutine的栈，需要切换到g0栈去执行newm()
                systemstack(func() {
            //创建监控线程，该线程独立于调度器，不需要跟p关联即可运行
                        newm(sysmon, nil)
                })
        }
    
    //......

    //调用runtime包的初始化函数，由编译器实现
        runtime_init() // must be before defer

        // Record when the world started.
        runtimeInitTime = nanotime()

        gcenable()  //开启垃圾回收器

        //......

        //main 包的初始化函数，也是由编译器实现，会递归的调用我们import进来的包的初始化函数
        fn := main_init // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime
        fn()

        //......
    
        //调用main.main函数
        fn = main_main // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime
        fn()
    
        //......

        //进入系统调用，退出进程，可以看出main goroutine并未返回，而是直接进入系统调用退出进程了
        exit(0)
    
        //保护性代码，如果exit意外返回，下面的代码也会让该进程crash死掉
        for {
                var x *int32
                *x = 0
        }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;runtime.main函数主要工作流程如下：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;启动一个sysmon系统监控线程，该线程负责整个程序的gc、抢占调度以及netpoll等功能的监控，在抢占调度一章我们再继续分析sysmon是如何协助完成goroutine的抢占调度的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行runtime包的初始化；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行main包以及main包import的所有包的初始化；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行main.main函数；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从main.main函数返回后调用exit系统调用退出进程；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从上述流程可以看出，runtime.main执行完main包的main函数之后就直接调用exit系统调用结束进程了，它并没有返回到调用它的函数（还记得是从哪里开始执行的runtime.main吗？），其实runtime.main是main goroutine的入口函数，并不是直接被调用的，而是在schedule()-&amp;gt;execute()-&amp;gt;gogo()这个调用链的gogo函数中用汇编代码直接跳转过来的，所以从这个角度来说，goroutine确实不应该返回，没有地方可返回啊！可是从前面的分析中我们得知，在创建goroutine的时候已经在其栈上放好了一个返回地址，伪造成goexit函数调用了goroutine的入口函数，这里怎么没有用到这个返回地址啊？其实那是为非main goroutine准备的，非main goroutine执行完成后就会返回到goexit继续执行，而main goroutine执行完成后整个进程就结束了，这是main goroutine与其它goroutine的一个区别。&lt;/p&gt;
&lt;p&gt;总结一下从g0切换到main goroutine的流程：&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;保存g0的调度信息，主要是保存CPU栈顶寄存器SP到g0.sched.sp成员之中；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调用schedule函数寻找需要运行的goroutine，我们这个场景找到的是main goroutine;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;调用gogo函数首先从g0栈切换到main goroutine的栈，然后从main goroutine的g结构体对象之中取出sched.pc的值并使用JMP指令跳转到该地址去执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;main goroutine执行完毕直接调用exit系统调用退出进程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下一节我们将用例子来分析非main goroutine的退出。&lt;/p&gt;
</description>
<pubDate>Thu, 09 May 2019 07:29:00 +0000</pubDate>
<dc:creator>爱写程序的阿波张</dc:creator>
<og:description>本文是《Go语言调度器源代码情景分析》系列的第14篇，也是第二章的第4小节。 上一节我们通过分析main goroutine的创建详细讨论了goroutine的创建及初始化流程，这一节我们接着来分析调</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/abozhang/p/10838719.html</dc:identifier>
</item>
<item>
<title>RabbitMQ系列之---初识RabbitMQ - Marksmanbat</title>
<link>http://www.cnblogs.com/-Marksman/p/10838693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-Marksman/p/10838693.html</guid>
<description>&lt;h2 id=&quot;为什么要使用rabbitmq&quot;&gt;为什么要使用RabbitMQ？&lt;/h2&gt;
&lt;h3 id=&quot;消息队列的作用&quot;&gt;消息队列的作用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;异步调用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统解耦&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;削峰限流&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息通讯&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;消息队列的缺点&quot;&gt;消息队列的缺点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;系统可用性降低&lt;/li&gt;
&lt;li&gt;系统稳定性降低&lt;/li&gt;
&lt;li&gt;分布式一致性问题（可靠消息最终一致性的分布式事务方案解决）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;rabbitmq的优势&quot;&gt;RabbitMQ的优势&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;支持高并发、高吞吐、性能好&lt;/li&gt;
&lt;li&gt;有完善的后台管理界面&lt;/li&gt;
&lt;li&gt;它还支持集群化、高可用部署架构、消息高可靠支持&lt;/li&gt;
&lt;li&gt;RabbitMQ的开源社区很活跃，较高频率的迭代版本，来修复发现的bug以及进行各种优化&lt;/li&gt;
&lt;li&gt;最重要的是它是开源免费的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;rabbitmq的缺点&quot;&gt;RabbitMQ的缺点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;它是基于erlang语言开发的，所以导致较为难以分析里面的源码，也较难进行深层次的源码定制和改造，毕竟需要较为扎实的erlang语言功底才可以。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;核心概念&quot;&gt;核心概念&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Server&lt;/strong&gt;：又称Broker，接受客户端的连接，实现AMQP实体服务；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Connection&lt;/strong&gt;：连接，应用程序与Broker的网络连接；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Channel&lt;/strong&gt;：网络通道，也称信道，几乎所有的通道都在Channel中进行的，Channel是进行消息读写的通道。客户端可建立多个Channel，每个Channel代表一个会话任务；是建立在“真实的”TCP连接内的虚拟连接。AMQP命令都是通过信道发送出去的。那么我们为什么需要信道呢？为什么不直接通过TCP连接发送AMQP命令呢？因为操作系统建立和销毁TCP会话是非常昂贵的开销，而且操作系统只能建立数量不多的TCP连接，很快就达到性能瓶颈，无法满足高性能的需求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Message&lt;/strong&gt;：消息，服务器和应用程序之间传送的数据，由Properties和Body组成。Properties可以对消息进行修饰，比如消息的优先级、等高级特性；Body则就是消息体的内容；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Virtual host&lt;/strong&gt;：虚拟地址，用于进行逻辑隔离，最上层的消息路由，并非物理概念。一个Virtual Host里面有若干个Exchange和Queue，同一个Virtual Host里面不能有相同名称的Exchange或者Queue；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Exchange&lt;/strong&gt;：交换机，接收消息，根据路由键转发消息到绑定的队列；&lt;br/&gt;交换机的类型：direct：直连，fanout：广播，headers：以...开头，topic：主题&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ZFpPnoSFYWAvKVlEpYnS3w&quot;&gt;参考：Spring Boot RabbitMQ 四种交换器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Binding&lt;/strong&gt;：Exchange和Queue之间的虚拟连接，binding中可以包含routing key；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Routing Key&lt;/strong&gt;：一个路由规则，虚拟机可用它来确定如何路由一个特定的消息；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Queue&lt;/strong&gt;：也称为Message Queue，消息队列，保存消息并将它们转发给消费者。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;几种交换机&quot;&gt;几种交换机&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Direct&lt;/strong&gt;：直连交换机&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Marksman/m4602sas626enrrclrdwwgf6/RabbitMQ-direct%E4%BA%A4%E6%8D%A2%E6%9C%BA.jpg&quot; alt=&quot;RabbitMQ-direct交换机.jpg-13.4kB&quot;/&gt;&lt;br/&gt;所有发送到Direct Exchange的消息被转发到RouteKey中指定的Queue&lt;br/&gt;注意：Direct模式可以直接使用RabbitMQ自带的Exchange：default，并&lt;strong&gt;以队列名作为路由键&lt;/strong&gt;。 Exchange，所以不需要将Exchange进行任何绑定(binding)操作，消息传递时，RouteKey必须完全匹配才会被队列接收，否则该消息会被抛弃。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Producer4DirectExchange {
    public static void main(String[] args) throws IOException, TimeoutException {
        ...
        Channel channel = connection.createChannel();
        
        String exchangeName = &quot;test_direct_exchange&quot;;
        String routingKey = &quot;test.direct&quot;;
        String msg = &quot;Hello World RabbitMQ 4 Direct Exchange Message...&quot;;

        channel.basicPublish(exchangeName, routingKey, null, msg.getBytes());
        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Consumer4DirectExchange {
    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException {
       ...
        Channel channel = connection.createChannel();

        String exchangeName = &quot;test_direct_exchange&quot;;
        String exchangeType = &quot;direct&quot;;
        String queueName = &quot;test_direct_queue&quot;;
        String routingKey = &quot;test.direct&quot;;
        
        // 声明交换机
        channel.exchangeDeclare(exchangeName, exchangeType, true, false, false, null);
        // 声明队列
        channel.queueDeclare(queueName, false, false, false, null);
        // 交换机与队列绑定
        channel.queueBind(queueName, exchangeName, routingKey);

        QueueingConsumer queueingConsumer = new QueueingConsumer(channel);

        channel.basicConsume(queueName,true,queueingConsumer);

        while (true) {
            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();
            String msg = new String(delivery.getBody());
            System.out.println(&quot;收到消息： &quot; + msg);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Topic&lt;/strong&gt;：主题交换机&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Marksman/nbw3mejf8v7eplt7spiyrjkb/RabbitMQ-topic%E4%BA%A4%E6%8D%A2%E6%9C%BA.jpg&quot; alt=&quot;RabbitMQ-topic交换机.jpg-16.4kB&quot;/&gt;&lt;br/&gt;所有发送到Topic Exchange的消息被转发到所有关心RouteKey中指定的Queue上，Exchange将RouteKey和某个Topic进行模糊匹配，此时队列需要绑定一个Topic。&lt;br/&gt;注意：可以使用通配符进行模糊匹配&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;&quot;#&quot; 匹配一个或多个词
&quot;*&quot; 匹配一个词
&quot;.&quot; 是单词的分隔符

例如：
&quot;log.#&quot;：能够匹配到&quot;log.info.oa
&quot;log.*&quot;：只会匹配到&quot;log.error&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Producer4TopicExchange {
    public static void main(String[] args) throws IOException, TimeoutException {
        ...
        Channel channel = connection.createChannel();

        String exchangeName = &quot;test_topic_exchange&quot;;
        String routingKey1 = &quot;user.save&quot;;
        String routingKey2 = &quot;user.update&quot;;
        String routingKey3 = &quot;user.delete.ok&quot;;

        String msg = &quot;Hello World RabbitMQ 4 Topic Exchange Message...&quot;;

        channel.basicPublish(exchangeName, routingKey1, null, msg.getBytes());
        channel.basicPublish(exchangeName, routingKey2, null, msg.getBytes());
        channel.basicPublish(exchangeName, routingKey3, null, msg.getBytes());
        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Consumer4TopicExchange {
    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException {
        ...
        Channel channel = connection.createChannel();

        String exchangeName = &quot;test_topic_exchange&quot;;
        String exchangeType = &quot;topic&quot;;
        String queueName = &quot;test_topic_queue&quot;;
        String routingKey = &quot;user.*&quot;;

        channel.exchangeDeclare(exchangeName, exchangeType, true, false, null);
        channel.queueDeclare(queueName, false, false, false, null);
        channel.queueBind(queueName, exchangeName, routingKey);

        QueueingConsumer queueingConsumer = new QueueingConsumer(channel);

        channel.basicConsume(queueName, true, queueingConsumer);

        while (true) {
            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();
            String msg = new String(delivery.getBody());
            System.out.println(&quot;收到消息： &quot; + msg);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Fanout Exchange&lt;/strong&gt;：广播交换机&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/Marksman/ko1equ1fup0l19boir2oofq3/RabbitMQ-fanout%E4%BA%A4%E6%8D%A2%E6%9C%BA.jpg&quot; alt=&quot;RabbitMQ-fanout交换机.jpg-17kB&quot;/&gt;&lt;br/&gt;不处理路由键，只需要简单的将队列绑定到交换机；&lt;br/&gt;发送到交换机的消息都会被转发到与该交换机绑定的所有队列上；&lt;br/&gt;Fanout交换机转发消息是最快的。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Producer4FanoutExchange {
    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException {
        ...
        Channel channel = connection.createChannel();

        String exchangeName = &quot;test_fanout_exchange&quot;;
        String routingKey = &quot;&quot;;

        String msg = &quot;Hello World RabbitMQ 4 Fanout Exchange Message...&quot;;

        channel.basicPublish(exchangeName, routingKey, null, msg.getBytes());
        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Consumer4FanoutExchange {

    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException {
        ...
        Channel channel = connection.createChannel();

        String exchangeName = &quot;test_fanout_exchange&quot;;
        String exchangeType = &quot;fanout&quot;;
        String queueName = &quot;test_fanout_queue&quot;;
        String routingKey = &quot;&quot;;

        channel.exchangeDeclare(exchangeName, exchangeType, true, false, null);
        channel.queueDeclare(queueName, false, false, false, null);
        channel.queueBind(queueName, exchangeName, routingKey);

        QueueingConsumer queueingConsumer = new QueueingConsumer(channel);

        channel.basicConsume(queueName, true, queueingConsumer);

        while (true) {
            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();
            String msg = new String(delivery.getBody());
            System.out.println(&quot;收到消息： &quot; + msg);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5c190f02518825046c2f6a5c&quot;&gt;石杉大神消息中间件系列文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://coding.imooc.com/class/262.html&quot;&gt;慕课网《RabbitMQ消息中间件技术精讲》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;书《RabbitMQ实战-高效部署分布式消息队列》&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 09 May 2019 07:29:00 +0000</pubDate>
<dc:creator>Marksmanbat</dc:creator>
<og:description>为什么要使用RabbitMQ？ 消息队列的作用 异步调用 系统解耦 削峰限流 消息通讯 消息队列的缺点 系统可用性降低 系统稳定性降低 分布式一致性问题（可靠消息最终一致性的分布式事务方案解决） Ra</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-Marksman/p/10838693.html</dc:identifier>
</item>
<item>
<title>使用Django开发简单接口：文章增删改查 - 秦无殇</title>
<link>http://www.cnblogs.com/webDepOfQWS/p/10693152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/webDepOfQWS/p/10693152.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;一些准备工作&quot;&gt;1、一些准备工作&lt;/h2&gt;
&lt;h3 id=&quot;安装django&quot;&gt;安装django&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;pip install django&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建django项目&quot;&gt;创建django项目&lt;/h3&gt;
&lt;p&gt;进入项目代码存放目录执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;django-admin.py startproject blog_demo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入blog_demo，运行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python3.6 manage.py runserver 9000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在浏览器地址栏打开：http://127.0.0.1:9000/ 如果出现以下画面，则说明服务器正在运行&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201905/631850-20190508223935341-1428774129.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建博客应用app&quot;&gt;创建博客应用（app）&lt;/h3&gt;
&lt;p&gt;django中每一个app可以看作是一个模块，以app为单位，结构清晰，方便管理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python3.6 manage.py startapp blog_api&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用开发工具打开项目blog_demo，其结构如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201905/631850-20190508224836347-362332429.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;models.py&quot;&gt;2、models.py&lt;/h2&gt;
&lt;p&gt;编写模型层代码，以下语句相当于创建了两张表：User，Article&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class User(models.Model):
    id = models.AutoField(primary_key=True)
    uname = models.CharField(max_length=50)
    upwd = models.CharField(max_length=100)
    #active inactive
    status = models.CharField(max_length=10)

class Article(models.Model):
    id = models.AutoField(primary_key=True)
    title = models.CharField(max_length=50)
    content = models.TextField()
    #deleted alive
    status = models.CharField(max_length=10)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建表结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python3.6  manage.py migrate
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;settings.py文件INSTALLED_APPS处新增app：blog_api&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'blog_api'
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让django知道模型有了变化：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python3.6 manage.py makemigrations blog_api
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次创建表结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python3.6  manage.py migrate
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;django-admin&quot;&gt;3、django admin&lt;/h2&gt;
&lt;h3 id=&quot;登录&quot;&gt;登录&lt;/h3&gt;
&lt;p&gt;在浏览器控制台输入：http://127.0.0.1:9000/admin/login/?next=/admin/&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201905/631850-20190508232419942-2067395675.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建超级用户&quot;&gt;创建超级用户&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;stephen@stephen-K55VD:~/IdeaProjects/blog_demo$ python3.6 manage.py  createsuperuser 
Username (leave blank to use 'stephen'): admin
Email address: 
Password: 
Password (again): 
This password is too common.
Bypass password validation and create user anyway? [y/N]: y
Superuser created successfully.

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;邮件地址可以不填，注册成功后即可登录。使用admin后台来管理模型需要先注册，修改blog_api/admin.py代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#导入模型User,Article
from blog_api.models import User,Article

admin.site.register(User)
admin.site.register(Article)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;刷新admin后台，就可以看到刚刚注册的模型了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201905/631850-20190508233229736-976918708.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;修改urls.py&quot;&gt;4、修改urls.py&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;from  blog_api.views import add_article,modify_article
urlpatterns = [
    path('admin/', admin.site.urls),
    path('articles/',add_article),
    path('articles/&amp;lt;int:art_id&amp;gt;',modify_article)
]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;新增文章接口&quot;&gt;5、新增文章接口&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;from django.http import HttpResponse,JsonResponse
from blog_api.models import User,Article
import json

#新增文章
def add_article(request):
    if request.method == &quot;POST&quot;:
        req = json.loads(request.body)
        print (req)
        key_flag = req.get(&quot;title&quot;) and req.get(&quot;content&quot;) and len(req)==2
        #判断请求体是否正确
        if key_flag:
            title = req[&quot;title&quot;]
            content = req[&quot;content&quot;]
            #title返回的是一个list
            title_exist = Article.objects.filter(title=title)
            #判断是否存在同名title
            if len(title_exist) != 0:
                return JsonResponse({&quot;status&quot;:&quot;BS.400&quot;,&quot;msg&quot;:&quot;title aleady exist,fail to publish.&quot;})

            '''插入数据'''
            add_art = Article(title=title,content=content,status=&quot;alive&quot;)
            add_art.save()
            return JsonResponse({&quot;status&quot;:&quot;BS.200&quot;,&quot;msg&quot;:&quot;publish article sucess.&quot;})
        else:
            return  JsonResponse({&quot;status&quot;:&quot;BS.400&quot;,&quot;message&quot;:&quot;please check param.&quot;})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用postman工具调用接口，运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201905/631850-20190509022153888-571920570.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;查询文章接口&quot;&gt;6、查询文章接口&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#查询所有文章和状态
    if request.method == &quot;GET&quot;:
        articles = {}
        query_art = Article.objects.all()
        for title in query_art:
            articles[title.title] = title.status
        return JsonResponse({&quot;status&quot;:&quot;BS.200&quot;,&quot;all_titles&quot;:articles,&quot;msg&quot;:&quot;query articles sucess.&quot;})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201905/631850-20190509040916376-217476422.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;修改文章接口&quot;&gt;7、修改文章接口&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#修改文章
def modify_article(request,art_id):
    if request.method == &quot;POST&quot;:
        req = json.loads(request.body)
        try:
            art = Article.objects.get(id=art_id)
            key_flag = req.get(&quot;title&quot;) and req.get(&quot;content&quot;) and len(req)==2
            if key_flag:
                title = req[&quot;title&quot;]
                content = req[&quot;content&quot;]
                title_exist = Article.objects.filter(title=title)
                if len(title_exist) &amp;gt; 1:
                    return JsonResponse({&quot;status&quot;:&quot;BS.400&quot;,&quot;msg&quot;:&quot;title aleady exist.&quot;})
                '''更新数据'''
                old_art = Article.objects.get(id=art_id)
                old_art.title = title
                old_art.content = content
                old_art.save()
                return JsonResponse({&quot;status&quot;:&quot;BS.200&quot;,&quot;msg&quot;:&quot;modify article sucess.&quot;})
        except Article.DoesNotExist:
            return  JsonResponse({&quot;status&quot;:&quot;BS.300&quot;,&quot;msg&quot;:&quot;article is not exists,fail to modify.&quot;})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201905/631850-20190509040512245-1521103674.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;删除文章接口&quot;&gt;8、删除文章接口&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#删除文章
    if request.method == &quot;DELETE&quot;:
        try:
            art = Article.objects.get(id=art_id)
            art_id = art.id
            art.delete()
            return JsonResponse({&quot;status&quot;:&quot;BS.200&quot;,&quot;msg&quot;:&quot;delete article sucess.&quot;})
        except Article.DoesNotExist:
            return JsonResponse({&quot;status&quot;:&quot;BS.300&quot;,&quot;msg&quot;:&quot;article is not exists,fail to delete.&quot;})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201905/631850-20190509022349018-999901226.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;鉴权&quot;&gt;9、鉴权&lt;/h2&gt;
&lt;p&gt;四个简单的接口已经可以运行了，但是在发请求之前没有进行鉴权，毫无安全性可言。下面来实现简单的认证机制。需要用到内建模块hashlib，hashlib提供了常见的摘要算法，如MD5，SHA1等。&lt;/p&gt;
&lt;h3 id=&quot;鉴权接口&quot;&gt;鉴权接口&lt;/h3&gt;
&lt;p&gt;新增一个专门用于鉴权的接口。在urls.py中添加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; path(&quot;auth/&quot;,get_token)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在views.py前面新增函数get_token(request)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import hashlib

#获取token
def get_token(request):
    req = json.loads(request.body)
    uname = req[&quot;username&quot;]
    upwd = req[&quot;password&quot;]
    if request.method == &quot;POST&quot;:
        try:
            tmppwd =User.objects.get(uname=uname).upwd
            if upwd == tmppwd:
                md5 = hashlib.md5()
                #把密码变成一个长度固定的字符串
                md5.update(upwd.encode(&quot;utf-8&quot;))
                return JsonResponse({&quot;status&quot;:&quot;BS.201&quot;,&quot;X-Token&quot;:md5.hexdigest()})
            else:
                return JsonResponse({&quot;status&quot;:&quot;BS.401&quot;,&quot;msg&quot;:&quot;username or password may wrong.&quot;})

        except User.DoesNotExist:
            return JsonResponse({&quot;status&quot;:&quot;BS.500&quot;,&quot;msg&quot;:&quot;username is not exist.&quot;})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;登录django admin在blog_api下的User表新增一条记录。运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201905/631850-20190509034012397-1217945638.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;用户认证&quot;&gt;用户认证&lt;/h3&gt;
&lt;p&gt;request.META.get(“header key”) 用于获取header的信息。注意的是header key必须增加前缀HTTP，同时大写，中划先会转成下划线，例如你的key为X-Token，那么应该写成request.META.get(&quot;HTTP_X_TOKEN&quot;)，修改views.py在get_token后面加上如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#认证动作
def user_auth(request):

    token = request.META.get(&quot;HTTP_X_TOKEN&quot;,b'')
    print (token)
    if token:
        #暂时先写上auth接口返回的数据
        if token==&quot;0a6db4e59c7fff2b2b94a297e2e5632e&quot;:
            return &quot;auth_sucess&quot;
        else:
            return &quot;auth_fail&quot;
    else:
        return  &quot;auth_fail&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在接口中调用user_auth函数，以发布文章接口为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#新增文章
def add_article(request):
    auth_res = user_auth(request)
    if auth_res == &quot;auth_fail&quot;:
        return JsonResponse({&quot;status&quot;:&quot;BS.401&quot;,&quot;msg&quot;:&quot;user auth failed.&quot;})
    else:
        if request.method == &quot;POST&quot;:
            req = json.loads(request.body)
            print (req)
            .......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次使用postman工具调用新增文章接口，Header中没有X-Token或X-Token错误时的运行结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201905/631850-20190509034853622-1629721671.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 May 2019 06:32:00 +0000</pubDate>
<dc:creator>秦无殇</dc:creator>
<og:description>使用Django框架开发简单的文章增删改查接口，为接口添加认证机制。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/webDepOfQWS/p/10693152.html</dc:identifier>
</item>
<item>
<title>Flutter 1.5 发布，正式成为全平台 UI 框架！ - 承香墨影</title>
<link>http://www.cnblogs.com/plokmju/p/flutter_web.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/plokmju/p/flutter_web.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9a8967e736208?w=640&amp;amp;h=100&amp;amp;f=jpeg&amp;amp;s=9025&quot; alt=&quot;006tNc79ly1fyuhpu6m8zj30hs02st8x.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9a8967e666e69?w=720&amp;amp;h=370&amp;amp;f=png&amp;amp;s=27716&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一.-序&quot;&gt;一. 序&lt;/h2&gt;
&lt;p&gt;在 Google I/O 2019 上，Dart 团队宣布推出新的 Flutter 稳定版本 1.5，这是 Flutter 迄今为止最大的一次版本发布。&lt;/p&gt;
&lt;p&gt;伴随着 Flutter 1.5 的发布，同期也宣布发布 Flutter for Web 的 Preview 版本，正式开启了 Flutter 的全平台 UI 框架之路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9a8967e5f58b7?w=815&amp;amp;h=376&amp;amp;f=png&amp;amp;s=61119&quot;/&gt;&lt;/p&gt;
&lt;p&gt;早在年初发布的 Flutter 2019 Roadmap 中，就有提到，会在今年支持移动设备之外的平台，对 Web 的支持，算是完成了一个新的里程碑吧。&lt;/p&gt;
&lt;h2 id=&quot;二.-flutter-for-web&quot;&gt;二. Flutter for Web&lt;/h2&gt;
&lt;p&gt;Flutter 之所以能够在移动平台上运行，主要是依赖的 Flutter Engine，就是 Flutter 所依赖的运行环境。这就导致在移动平台，只要你使用了 Flutter，哪怕只用混合开发的模式写了一个页面，这也将为你的 App 增大大约 4MB 的体积。&lt;/p&gt;
&lt;p&gt;而 Flutter for Web，完全是一种全新的模式，它可以将 Dart 编写的现有 Flutter 代码，编译成可嵌入浏览器并部署到任何 Web 服务器的代码。&lt;/p&gt;
&lt;p&gt;编译后的代码，完全是基于 HTML、CSS 和 JavaScript 这些标准的 Web 技术，所以它也不需要任何浏览器插件的支持。&lt;/p&gt;
&lt;p&gt;早期微软的 Silverlight 和 Adobe 的 Flash 都证明了，一切需要插件才能支持的 Web 应用，都是纸老虎，最终都会被基础的 HTML 技术所替代。&lt;/p&gt;
&lt;p&gt;我想这也是 Flutter for Web 选择这种支持方式的一个考量因素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9a8967e91c722?w=1137&amp;amp;h=465&amp;amp;f=png&amp;amp;s=56076&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加 Web 支持，涉及在标准 API 之上，实现 Flutter 的核心绘图层，结合使用 DOM、Canvas 和 CSS，Flutter for Web 能够实现在现代浏览器中提供便携的、高质量和高性能的用户体验。&lt;/p&gt;
&lt;p&gt;Flutter for Web 很大程度上，归功于 Chrome、Firefox 和 Safari 等现代浏览器的快速发展，这些浏览器提供了基础的硬件加速的图形、动画和文本以及 JavaScript 的快速执行。&lt;/p&gt;
&lt;p&gt;随着 Flutter for Web 的发布，Flutter 正式成为一个全平台的 UI 框架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9a8967eb647ab?w=1600&amp;amp;h=895&amp;amp;f=png&amp;amp;s=125549&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Flutter 最初的设想，也并不是想作为一个 HTML 的替代品，而是想基于 Flutter 能够快速构建出全平台的所支持的，图形丰富、交互流程的应用。&lt;/p&gt;
&lt;p&gt;在 Google I/O 上，也展示了最近刷屏的 KENKEN 益智游戏（文末有地址），该游戏在 Android、iOS、Web、Mac 和 Chrome 上，运行的都是相同的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9a8a56f627ec5?w=728&amp;amp;h=424&amp;amp;f=gif&amp;amp;s=2033382&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Flutter for Web 还只是一个 Preview 版本，还有很多不足和被限制的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;限制：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Flutter_web 的插件还不完善，暂时只提供了最基础的 &lt;code&gt;dart:html&lt;/code&gt;、&lt;code&gt;dart:js&lt;/code&gt;、&lt;code&gt;dart:svg&lt;/code&gt;、&lt;code&gt;dart:indexed_db&lt;/code&gt;，可以通过他们访问绝大多数浏览器的 API。&lt;/li&gt;
&lt;li&gt;并非所有的 Flutter 都在 Flutter_web 上实现了。&lt;/li&gt;
&lt;li&gt;Flutter_web 编译还很慢。&lt;/li&gt;
&lt;li&gt;在桌面浏览器上运行，还有一些不足，大部分是基于移动应用的操作特性，而没有对桌面系统的操作习惯进行特殊的优化。&lt;/li&gt;
&lt;li&gt;开发流程目前仅支持 Chrome。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;更多细节，可以直接上 Github 上查看。&lt;/p&gt;
&lt;h2 id=&quot;三.-小结&quot;&gt;三. 小结&lt;/h2&gt;
&lt;p&gt;自此 Flutter 就不再是一个单纯的移动框架，而是一个多平台框架，通过它，可以快速的构建应用，更快的触达用户。&lt;/p&gt;
&lt;p&gt;坦率的讲，Flutter 这一年的发展以及推广效果都是惊人的，据公开的消息来看，不少一线大厂已经在一些生产项目上，尝试使用 Flutter，虽然尝试的大多都并不是主力项目，但这背后一定也少不了 Google 的推广，Google 本身对 Flutter 的期望也很大，短期应该不会凉。&lt;/p&gt;
&lt;p&gt;不过框架这个东西，有兴趣看看就好了，毕竟铁打的基础，流水的 API，不要花太多的精力沉迷在框架中，把编程的基础技术学好才是正道。如果真到了公司想尝试 Flutter 的地步，专门花一周两周突击一下，肯定能上手。&lt;/p&gt;
&lt;p&gt;本文对你有帮助吗？&lt;strong&gt;留言、点赞、转发&lt;/strong&gt;是最大的支持，谢谢！&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;公众号后台回复成长『&lt;strong&gt;成长&lt;/strong&gt;』，将会得到我准备的学习资料，也能回复『&lt;strong&gt;加群&lt;/strong&gt;』，一起学习进步；你还能回复『&lt;strong&gt;提问&lt;/strong&gt;』，向我发起提问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9a8967ee90ba2?w=1000&amp;amp;h=400&amp;amp;f=jpeg&amp;amp;s=27637&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 May 2019 06:11:00 +0000</pubDate>
<dc:creator>承香墨影</dc:creator>
<og:description>一. 序 在 Google I/O 2019 上，Dart 团队宣布推出新的 Flutter 稳定版本 1.5，这是 Flutter 迄今为止最大的一次版本发布。 伴随着 Flutter 1.5 的发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/plokmju/p/flutter_web.html</dc:identifier>
</item>
<item>
<title>python 协程与go协程的区别 - 从零开始的程序员生活</title>
<link>http://www.cnblogs.com/lgjbky/p/10838035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lgjbky/p/10838035.html</guid>
<description>&lt;h3 id=&quot;进程线程和协程&quot;&gt;进程、线程和协程&lt;/h3&gt;
&lt;h4 id=&quot;进程的定义&quot;&gt;进程的定义：&lt;/h4&gt;
&lt;p&gt;进程，是计算机中已运行程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序的真正运行实例。&lt;/p&gt;
&lt;h4 id=&quot;线程的定义&quot;&gt;线程的定义：&lt;/h4&gt;
&lt;p&gt;操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。&lt;/p&gt;
&lt;h4 id=&quot;进程和线程的关系&quot;&gt;进程和线程的关系：&lt;/h4&gt;
&lt;p&gt;一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。&lt;br/&gt;CPU的最小调度单元是线程不是进程，所以单进程多线程也可以利用多核CPU.&lt;/p&gt;
&lt;h4 id=&quot;协程的定义&quot;&gt;协程的定义：&lt;/h4&gt;
&lt;p&gt;协程通过在线程中实现调度，避免了陷入内核级别的上下文切换造成的性能损失，进而突破了线程在IO上的性能瓶颈。&lt;/p&gt;
&lt;h4 id=&quot;协程和线程的关系&quot;&gt;协程和线程的关系&lt;/h4&gt;
&lt;p&gt;协程是在语言层面实现对线程的调度，避免了内核级别的上下文消耗。&lt;/p&gt;
&lt;h4 id=&quot;python协程与调度&quot;&gt;python协程与调度&lt;/h4&gt;
&lt;p&gt;Python的协程源于yield指令。yield有两个功能:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;yield item用于产出一个值，反馈给next()的调用方。&lt;/li&gt;
&lt;li&gt;作出让步，暂停执行生成器，让调用方继续工作，直到需要使用另一个值时再调用next()。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import asyncio
import datetime

async def display_date():
    loop = asyncio.get_running_loop()
    end_time = loop.time() + 5.0
    while True:
        print(datetime.datetime.now())
        if (loop.time() + 1.0) &amp;gt;= end_time:
            break
        await asyncio.sleep(1)

asyncio.run(display_date())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;协程是对线程的调度，yield类似惰性求值方式可以视为一种流程控制工具，&lt;br/&gt;实现协作式多任务,在Python3.5正式引入了 Async/Await表达式，使得协程正式在语言层面得到支持和优化，大大简化之前的yield写法。&lt;br/&gt;线程是内核进行抢占式的调度的，这样就确保了每个线程都有执行的机会。&lt;br/&gt;而 coroutine 运行在同一个线程中，由语言的运行时中的 EventLoop（事件循环）来进行调度。&lt;br/&gt;和大多数语言一样，在 Python 中，协程的调度是非抢占式的，也就是说一个协程必须主动让出执行机会，其他协程才有机会运行。&lt;br/&gt;让出执行的关键字就是 await。也就是说一个协程如果阻塞了，持续不让出 CPU，那么整个线程就卡住了，没有任何并发。&lt;/p&gt;
&lt;p&gt;PS: 作为服务端，event loop最核心的就是IO多路复用技术，所有来自客户端的请求都由IO多路复用函数来处理;作为客户端，&lt;br/&gt;event loop的核心在于利用Future对象延迟执行，并使用send函数激发协程,挂起,等待服务端处理完成返回后再调用CallBack函数继续下面的流程&lt;/p&gt;
&lt;h4 id=&quot;go的协程是天生在语言层面支持和python类似都是采用了关键字而go语言使用了go这个关键字可能是想表明协程是go语言中最重要的特性&quot;&gt;Go的协程是天生在语言层面支持，和Python类似都是采用了关键字，而Go语言使用了go这个关键字，可能是想表明协程是Go语言中最重要的特性。&lt;/h4&gt;
&lt;p&gt;go协程之间的通信，Go采用了channel关键字。&lt;/p&gt;
&lt;p&gt;Go实现了两种并发形式:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多线程共享内存。如Java或者C++等在多线程中共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问.&lt;/li&gt;
&lt;li&gt;Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Go的CSP并发模型实现：M, P, G : [&lt;a href=&quot;https://www.cnblogs.com/sunsky303/p/9115530.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/sunsky303/p/9115530.html&lt;/a&gt;]&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
)

//Go 协程（goroutines）和协程（coroutines）
//Go 协程意味着并行（或者可以以并行的方式部署），协程一般来说不是这样的
//Go 协程通过通道来通信；协程通过让出和恢复操作来通信

// 进程退出时不会等待并发任务结束，可用通道（channel）阻塞，然后发出退出信号
func main() {
    jobs := make(chan int)
    done := make(chan bool) // 结束标志

    go func() {
        for {
            j, more := &amp;lt;-jobs //  利用more这个值来判断通道是否关闭，如果关闭了，那么more的值为false，并且通知给通道done
            fmt.Println(&quot;-----&amp;gt;:&quot;, j, more)
            if more {
                fmt.Println(&quot;received job&quot;, j)
            } else {
                fmt.Println(&quot;end received jobs&quot;)
                done &amp;lt;- true
                return
            }
        }
    }()

    go func() {
        for j := 1; j &amp;lt;= 3; j++ {
            jobs &amp;lt;- j
            fmt.Println(&quot;sent job&quot;, j)
        }
        close(jobs) // 写完最后的数据,紧接着就close掉
        fmt.Println(&quot;close(jobs)&quot;)
    }()

    fmt.Println(&quot;sent all jobs&quot;)
    &amp;lt;-done // 让main等待全部协程完成工作
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;通过在函数调用前使用关键字 go，我们即可让该函数以 goroutine 方式执行。goroutine 是一种 比线程更加轻盈、更省资源的协程。&lt;br/&gt;Go 语言通过系统的线程来多路派遣这些函数的执行，使得 每个用 go 关键字执行的函数可以运行成为一个单位协程。&lt;br/&gt;当一个协程阻塞的时候，调度器就会自 动把其他协程安排到另外的线程中去执行，从而实现了程序无等待并行化运行。&lt;br/&gt;而且调度的开销非常小，一颗 CPU 调度的规模不下于每秒百万次，这使得我们能够创建大量的 goroutine，&lt;br/&gt;从而可以很轻松地编写高并发程序，达到我们想要的目的。 ---- 某书&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;协程的4种状态&quot;&gt;协程的4种状态&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Pending&lt;/li&gt;
&lt;li&gt;Running&lt;/li&gt;
&lt;li&gt;Done&lt;/li&gt;
&lt;li&gt;Cacelled&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;和系统线程之间的映射关系&quot;&gt;和系统线程之间的映射关系&lt;/h4&gt;
&lt;p&gt;go的协程本质上还是系统的线程调用，而Python中的协程是eventloop模型实现，所以虽然都叫协程，但并不是一个东西.&lt;br/&gt;Python 中的协程是严格的 1:N 关系，也就是一个线程对应了多个协程。虽然可以实现异步I/O，但是不能有效利用多核(GIL)。&lt;br/&gt;而 Go 中是 M:N 的关系，也就是 N 个协程会映射分配到 M 个线程上，这样带来了两点好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多个线程能分配到不同核心上,CPU 密集的应用使用 goroutine 也会获得加速.&lt;/li&gt;
&lt;li&gt;即使有少量阻塞的操作，也只会阻塞某个 worker 线程，而不会把整个程序阻塞。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS: Go中很少提及线程或进程,也就是因为上面的原因.&lt;/p&gt;
&lt;h4 id=&quot;两种协程对比&quot;&gt;两种协程对比:&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;async是非抢占式的,一旦开始采用 async 函数，那么你整个程序都必须是 async 的，不然总会有阻塞的地方(一遇阻塞对于没有实现异步特性的库就无法主动让调度器调度其他协程了)，也就是说 async 具有传染性。&lt;/li&gt;
&lt;li&gt;Python 整个异步编程生态的问题，之前标准库和各种第三方库的阻塞性函数都不能用了，requests 不能用了，redis.py 不能用了，甚至 open 函数都不能用了。所以 Python 协程的最大问题不是不好用，而是生态环境不好。&lt;/li&gt;
&lt;li&gt;goroutine 是 go 与生俱来的特性，所以几乎所有库都是可以直接用的，避免了 Python 中需要把所有库重写一遍的问题。&lt;/li&gt;
&lt;li&gt;Goroutine 中不需要显式使用 await 交出控制权，但是 Go 也不会严格按照时间片去调度 goroutine，而是会在可能阻塞的地方插入调度。Goroutine 的调度可以看做是半抢占式的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS: python异步库列表 [&lt;a href=&quot;https://github.com/timofurrer/awesome-asyncio&quot; class=&quot;uri&quot;&gt;https://github.com/timofurrer/awesome-asyncio&lt;/a&gt;]&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Do not communicate by sharing memory; instead, share memory by communicating.(不要以共享内存的方式来通信，相反，要通过通信来共享内存) -- CSP并发模型&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;扩展与总结&quot;&gt;扩展与总结&lt;/h4&gt;
&lt;p&gt;erlang和golang都是采用了CSP(Communicating Sequential Processes)模式(Python中的协程是eventloop模型)&lt;br/&gt;但是erlang是基于进程的消息通信，go是基于goroutine和channel的通信。&lt;br/&gt;Python和Go都引入了消息调度系统模型，来避免锁的影响和进程/线程开销大的问题。&lt;br/&gt;协程从本质上来说是一种用户态的线程，不需要系统来执行抢占式调度，而是在语言层面实现线程的调度。&lt;br/&gt;因为协程不再使用共享内存/数据，而是使用通信来共享内存/锁，因为在一个超级大系统里具有无数的锁，&lt;br/&gt;共享变量等等会使得整个系统变得无比的臃肿，而通过消息机制来交流，可以使得每个并发的单元都成为一个独立的个体，&lt;br/&gt;拥有自己的变量，单元之间变量并不共享，对于单元的输入输出只有消息。&lt;br/&gt;开发者只需要关心在一个并发单元的输入与输出的影响，而不需要再考虑类似于修改共享内存/数据对其它程序的影响。&lt;/p&gt;
</description>
<pubDate>Thu, 09 May 2019 05:53:00 +0000</pubDate>
<dc:creator>从零开始的程序员生活</dc:creator>
<og:description>进程、线程和协程 进程的定义： 进程，是计算机中已运行程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序的真正运行实例。 线程的定义： 操作系统能够进行运算调度的最小单位。它被包含在进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lgjbky/p/10838035.html</dc:identifier>
</item>
<item>
<title>五分钟搞定 HTTPS 配置，二哥手把手教 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/10838023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/10838023.html</guid>
<description>&lt;h3 id=&quot;h01freesslcn&quot;&gt;01、关于 FreeSSL.cn&lt;/h3&gt;
&lt;p&gt;FreeSSL.cn 是一个免费提供 HTTPS 证书申请、HTTPS 证书管理和 HTTPS 证书到期提醒服务的网站，旨在推进 HTTPS 证书的普及与应用，简化证书申请的流程。&lt;/p&gt;
&lt;p&gt;当然了，我看重的不是免费，而是 FreeSSL 使用起来非常人性化。我是一个计算机常识非常薄弱的程序员（羞愧一下），但通过 FreeSSL，我竟然可以独自完成 Tomcat 的 HTTPS 配置！&lt;/p&gt;
&lt;p&gt;很多年以前，公司要做华夏银行的接口对接，需要 HTTPS 访问，大概花了 3000 块买的证书，最后证书还有问题，HTTPS 也没搞定。总之，坑的很！&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9b200d2d271cf?w=711&amp;amp;h=504&amp;amp;f=png&amp;amp;s=29239&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FreeSSL.cn 有很大的不同，申请非常便捷，优点很多，值得推荐一波。毕竟再也不用邮件、电话各种联系了（也许时代进步了）。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;100% 永久免费；这要感谢 Let's Encrypt 与 TrustAsia 提供的免费 SSL 证书。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在 HTTPS 证书到期前，FreeSSL.cn 会及时地提醒更换证书，免费的服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;私钥不在网络中传播，确保 HTTPS 证书的安全。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h02freessl&quot;&gt;02、使用 FreeSSL 申请证书&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;，填写域名，点击「创建免费的 SSL 证书」&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9b200d8f2b300?w=713&amp;amp;h=614&amp;amp;f=png&amp;amp;s=195705&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;，填写邮箱，点击「创建」&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9b200d2d70dca?w=573&amp;amp;h=441&amp;amp;f=png&amp;amp;s=141063&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;证书类型&lt;/strong&gt;默认为 RSA&lt;/p&gt;
&lt;p&gt;RSA 和 ECC 有什么区别呢？可以通过下面几段文字了解一下。&lt;/p&gt;
&lt;p&gt;HTTPS 通过 TLS 层和证书机制提供了内容加密、身份认证和数据完整性三大功能，可以有效防止数据被监听或篡改，还能抵御 MITM（中间人）攻击。TLS 在实施加密过程中，需要用到非对称密钥交换和对称内容加密两大算法。&lt;/p&gt;
&lt;p&gt;对称内容加密强度非常高，加解密速度也很快，只是无法安全地生成和保管密钥。在 TLS 协议中，应用数据都是经过对称加密后传输的，传输中所使用的对称密钥，则是在握手阶段通过非对称密钥交换而来。常见的 AES-GCM、ChaCha20-Poly1305，都是对称加密算法。&lt;/p&gt;
&lt;p&gt;非对称密钥交换能在不安全的数据通道中，产生只有通信双方才知道的对称加密密钥。目前最常用的密钥交换算法有 RSA 和 ECDHE：&lt;strong&gt;RSA&lt;/strong&gt; 历史悠久，支持度好，但不支持 PFS（Perfect Forward Secrecy）；而 ECDHE 是使用了 &lt;strong&gt;ECC&lt;/strong&gt;（椭圆曲线）的 DH（Diffie-Hellman）算法，计算速度快，支持 PFS。&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;验证类型&lt;/strong&gt;默认为 DNS&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DNS&lt;/strong&gt; 和&lt;strong&gt;文件验证&lt;/strong&gt;有什么区别呢？我们再来一起了解下。&lt;/p&gt;
&lt;p&gt;首先，我们需要明白一点，CA（Certificate Authority，证书颁发机构） 需要验证我们是否拥有该域名，这样才给我们颁发证书。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件验证&lt;/strong&gt;（HTTP）：CA 将通过访问特定 URL 地址来验证我们是否拥有域名的所有权。因此，我们需要下载给定的验证文件，并上传到您的服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DNS 验证&lt;/strong&gt;：CA 将通过查询 DNS 的 TXT 记录来确定我们对该域名的所有权。我们只需要在域名管理平台将生成的 TXT 记录名与记录值添加到该域名下，等待大约 1 分钟即可验证成功。&lt;/p&gt;
&lt;p&gt;所以，如果对服务器操作方便的话，可以选择文件验证；如果对域名的服务器操作比较方便的话，可以选择 DNS 验证。如果两个都方便的话，请随意选啦。&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;CSR生成&lt;/strong&gt;默认为离线生成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离线生成&lt;/strong&gt;、&lt;strong&gt;浏览器生成&lt;/strong&gt; 和 &lt;strong&gt;我有 CSR&lt;/strong&gt; 又有什么区别呢？来，我们继续了解一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;离线生成&lt;/strong&gt; &lt;sup&gt;推荐!!!&lt;/sup&gt;：私钥在本地加密存储，更安全；公钥自动合成，支持常见证书格式转换，方便部署；支持部分 WebServer 的一键部署，非常便捷。&lt;/p&gt;
&lt;p&gt;离线生成的时候，需要先安装 KeyManager，可以提供安全便捷的 SSL 证书申请和管理。下载地址如下：&lt;br/&gt;https://keymanager.org/&lt;/p&gt;
&lt;p&gt;Windows 的话，安装的时候要选择“以管理员身份运行”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器生成&lt;/strong&gt;：在浏览器支持 &lt;code&gt;Web Cryptography&lt;/code&gt; 的情况下，会使用浏览器根据用户的信息生成 CSR 文件。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Web Cryptography，网络密码学，用于在 Web 应用程序中执行基本加密操作的 JavaScript API。很多浏览器并不支持&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;我有 CSR&lt;/strong&gt;：可以粘贴自己的 CSR，然后创建。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;，选择离线生成，打开 KeyManager&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9b200d2e62a72?w=1150&amp;amp;h=750&amp;amp;f=png&amp;amp;s=20560&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填写密码后点击「开始」，稍等片刻，出现如下界面。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9b200d918c961?w=1150&amp;amp;h=750&amp;amp;f=png&amp;amp;s=65343&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步&lt;/strong&gt;，返回浏览器，点击「下一步」，出现如下界面。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9b200fb8cf8df?w=718&amp;amp;h=650&amp;amp;f=png&amp;amp;s=49208&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五步&lt;/strong&gt;，下载文件，并上传至服务器指定目录下。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9b200fc63d485?w=351&amp;amp;h=61&amp;amp;f=png&amp;amp;s=2207&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第六步&lt;/strong&gt;，点击「验证」，通过后，出现以下界面。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9b20125ac55d9?w=720&amp;amp;h=601&amp;amp;f=png&amp;amp;s=15303&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第七步&lt;/strong&gt;，点击「保存到KeyManager」，可以看到证书状态变成了已颁发。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9b20118551106?w=956&amp;amp;h=171&amp;amp;f=png&amp;amp;s=17147&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;h03tomcatjks&quot;&gt;03、为 Tomcat 配置 jks 格式证书&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;，导出证书。假如服务器选择的 Tomcat，需要导出 Java keystone （简拼为 jks）格式的证书。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9b2011cfab8d0?w=960&amp;amp;h=390&amp;amp;f=png&amp;amp;s=26896&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：私钥的密码在配置 Tomcat 的时候用到。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9b201326a2a10?w=365&amp;amp;h=393&amp;amp;f=png&amp;amp;s=3762&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;，上传证书至服务器。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9b201493bb10a?w=150&amp;amp;h=37&amp;amp;f=png&amp;amp;s=932&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;，配置 Tomcat 的 server.xml。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt; &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;Connector &lt;span class=&quot;hljs-attr&quot;&gt;port=&lt;span class=&quot;hljs-string&quot;&gt;&quot;81&quot; &lt;span class=&quot;hljs-attr&quot;&gt;protocol=&lt;span class=&quot;hljs-string&quot;&gt;&quot;HTTP/1.1&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;maxThreads=&lt;span class=&quot;hljs-string&quot;&gt;&quot;250&quot; &lt;span class=&quot;hljs-attr&quot;&gt;maxHttpHeaderSize=&lt;span class=&quot;hljs-string&quot;&gt;&quot;8192&quot; &lt;span class=&quot;hljs-attr&quot;&gt;acceptCount=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;connectionTimeout=&lt;span class=&quot;hljs-string&quot;&gt;&quot;60000&quot; &lt;span class=&quot;hljs-attr&quot;&gt;keepAliveTimeout=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200000&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;redirectPort=&lt;span class=&quot;hljs-string&quot;&gt;&quot;8443&quot;            &lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;useBodyEncodingForURI=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot; &lt;span class=&quot;hljs-attr&quot;&gt;URIEncoding=&lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-8&quot;  &lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;compression=&lt;span class=&quot;hljs-string&quot;&gt;&quot;on&quot; &lt;span class=&quot;hljs-attr&quot;&gt;compressionMinSize=&lt;span class=&quot;hljs-string&quot;&gt;&quot;2048&quot; &lt;span class=&quot;hljs-attr&quot;&gt;noCompressionUserAgents=&lt;span class=&quot;hljs-string&quot;&gt;&quot;gozilla, traviata&quot;   &lt;br/&gt;&lt;span class=&quot;hljs-attr&quot; readability=&quot;8&quot;&gt;compressableMimeType=&lt;span class=&quot;hljs-string&quot; readability=&quot;16&quot;&gt;&quot;text/html,text/xml,application/xml,application/json,text/javascript,application/javascript,text/css,text/plain,text/json,image/png,image/gif&quot;/&amp;gt;&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;Connector&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;protocol=&lt;span class=&quot;hljs-string&quot;&gt;&quot;org.apache.coyote.http11.Http11NioProtocol&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;port=&lt;span class=&quot;hljs-string&quot;&gt;&quot;443&quot; &lt;span class=&quot;hljs-attr&quot;&gt;maxThreads=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;scheme=&lt;span class=&quot;hljs-string&quot;&gt;&quot;https&quot; &lt;span class=&quot;hljs-attr&quot;&gt;secure=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot; &lt;span class=&quot;hljs-attr&quot;&gt;SSLEnabled=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;keystoreFile=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/home/backup/qingmiaokeji.cn.jks&quot; &lt;span class=&quot;hljs-attr&quot;&gt;keystorePass=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Chenmo&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;clientAuth=&lt;span class=&quot;hljs-string&quot;&gt;&quot;false&quot; &lt;span class=&quot;hljs-attr&quot;&gt;sslProtocol=&lt;span class=&quot;hljs-string&quot;&gt;&quot;TLS&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;useBodyEncodingForURI=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot; &lt;span class=&quot;hljs-attr&quot;&gt;URIEncoding=&lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-8&quot;  &lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;compression=&lt;span class=&quot;hljs-string&quot;&gt;&quot;on&quot; &lt;span class=&quot;hljs-attr&quot;&gt;compressionMinSize=&lt;span class=&quot;hljs-string&quot;&gt;&quot;2048&quot; &lt;span class=&quot;hljs-attr&quot;&gt;noCompressionUserAgents=&lt;span class=&quot;hljs-string&quot;&gt;&quot;gozilla, traviata&quot;   &lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;compressableMimeType=&lt;span class=&quot;hljs-string&quot;&gt;&quot;text/html,text/xml,application/xml,application/json,text/javascript,application/javascript,text/css,text/plain,text/json,image/png,image/gif&quot;&lt;br/&gt;/&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 keystorePass 为导出证书时私钥的加密密码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步&lt;/strong&gt;，重启 Tomcat，并在浏览器地址栏中输入 &lt;code&gt;https://qingmiaokeji.cn/&lt;/code&gt; 进行测试。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2019/5/9/16a9b2015b5c91ee?w=505&amp;amp;h=417&amp;amp;f=png&amp;amp;s=57271&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意到没，浏览器地址栏前面有一个绿色的安全锁，这说明 HTTPS 配置成功了！好了，为自己鼓个掌！&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;04、最后&lt;/h3&gt;
&lt;p&gt;你有没有订个五分钟的时间沙漏？如果超过五分钟 HTTPS 还没有配置成功，你过来揍我！&lt;/p&gt;

</description>
<pubDate>Thu, 09 May 2019 05:50:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>01、关于 FreeSSL.cn FreeSSL.cn 是一个免费提供 HTTPS 证书申请、HTTPS 证书管理和 HTTPS 证书到期提醒服务的网站，旨在推进 HTTPS 证书的普及与应用，简化证</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qing-gee/p/10838023.html</dc:identifier>
</item>
<item>
<title>记一次自动恢复的支付故障 - 猿界汪汪队</title>
<link>http://www.cnblogs.com/donlianli/p/10837869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/donlianli/p/10837869.html</guid>
<description>&lt;p&gt;&lt;strong&gt;故障描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为一个老牌OTA公司，公司早些年订单主要来源是PC网站和呼叫中心。我在入职公司大约半年后，遇到一次非常诡异的故障。有一天早上，大概也是这个季节，阳光明媚，程序猿刚起床，洗洗涮涮，准备去迎接初恋般的工作日，却突然收到一大堆报警，线上消息队列大量积压；当然，我还是一如既往的非常勤奋地在9点之前就到公司的；但是作为一名新员工，环视四周，组内其他员工都还没到公司，运维也都在路上，故障就这样突然降临了。我赶紧开机登录堡垒机，连接线上机器，tail 错误日志。但是线上10几个系统，我看了好几个系统，都没有发现有什么错误，这就尴尬了。但是统计消息队列，超过好几千的消息待消费。我当时就在想，这些消息都是什么鬼。截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190509130346004-1929350731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图一&lt;/p&gt;
&lt;p&gt;看到这里，你一定会问数量为604和881个的消息是做什么？知道这些消息的逻辑不就解决问题了么？话说当时我也是这么想的，可是当时我作为一名新人，才开始接触业务不到3个月，还完全没有这么深的业务积累（这个时候知道业务是多么重要）。&lt;/p&gt;
&lt;p&gt;既然系统看不到任何错误，我也没有什么办法了，当时因为刚入职没多久，还有点寄希望于领导来解决。转眼间半个小时已经过去，故障仍然没有恢复，从业务反馈来看，微信支付宝等支付方式不受影响。受影响的只是信用卡支付（其实当时信用卡量占比挺高）和分销支付（后来了解到，其实这两种模式都是信用卡支付模式）。领导还在堵车，运维也只是到了几个小兵，我找运维把几个机器的stack打印了一下，也没有发现什么问题；运维也陆续到岗，运维准备出大招，重启系统。但是就在此时，突然系统自动恢复了。所有积压的消息自动被消费，信用卡支付也可以了。好，系统竟然有自我修复功能，佩服；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;故障原因分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后来，经过一番努力，还是找到一点蛛丝马迹，我发现系统的一个消费消息的定时任务，在故障期间一直在报错，因为是高可用的job机制，4台机器，只有抢占到锁的服务器才能获取到访问数据库消息权利，所以报错信息比较分散，4台机器都有。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190509130424288-1633352569.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图二&lt;/p&gt;

&lt;p&gt;可以判定，这个sql一直异常导致job根本无法获取到消息，而另外的生产者又不断的往队列放消息，进而导致消息积压。两个系统关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190509130432439-515739895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图三&lt;/p&gt;

&lt;p&gt;虽然故障总结了，但是我们心里也不踏实，如何找到系统故障的根本原因，以防止以后再次出现这种故障呢？&lt;/p&gt;
&lt;p&gt;方法有两种：&lt;/p&gt;
&lt;p&gt;1、去查代码，所有跟这个表相关的sql，都需要仔细review一下，但是你也不一定能查到原因，因为这个场景肯定是不好复现的，要不然早就发现这个问题了。&lt;/p&gt;
&lt;p&gt;2、借助外力，从DB层面查导致这个sql无法执行成功的原因；&lt;/p&gt;

&lt;p&gt;方法1看似简单，其实非常不可行。首先，虽然跟这个表相关的sql，只有几十个，但是都是正常的sql，没有使用for update锁死表的sql。也没有存在未关闭的事务，因为事务是通过AOP配置的；&lt;/p&gt;
&lt;p&gt;所以只能寄希望于方法2了，让DBA去查；&lt;/p&gt;
&lt;p&gt;好歹我们的DBA足够给力，只用了1天多的时间就查出来了。&lt;/p&gt;
&lt;p&gt;DBA回复如下：&lt;/p&gt;
&lt;p&gt;1、有事务没有及时提交，且连接也没有关闭，导致该事务一直处于开启状态并持有锁，后续update操作是全表扫描，因此会有锁等待。&lt;/p&gt;
&lt;p&gt;2、最后该连接后续一直没有操作，达到空闲超时3600秒（我们的故障时间正好也是1小时）后被mysql server断开，锁才被释放。（mysql设置：wait_timeout = 3600）&lt;/p&gt;
&lt;p&gt;最牛B的是DBA贴出了没有提交事务的SQL；sql我就不贴出来了，我们根据DBA提供的线索，找到了代码的问题；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;故障根本原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后来我们查看代码，如上面DBA所说，消息没有被消费处理，是因为有一个mysql客户端，即我们的支付应用程序，在进行快捷支付的时候，向队列插入一条记录，然后在事务中向第三方发起了调用。使用的是&lt;strong&gt;httpclient&lt;/strong&gt;工具发起的调用，但是设置超时时，只设置了连接超时时间(connectionTimeout)为30秒，没有设置响应超时时间（&lt;strong&gt;soTimeout&lt;/strong&gt;）,这样当出现网络问题时，程序就会一直等第三方响应，然后事务也一直没有提交。而在job程序中，需要将这个queue的所有记录给更新，但是又取不到表锁（见图三），就不断的报lock wait timeout的错误；其实对使用spring AOP框架的研发，很容易犯这种错误。我们从 https://tech.meituan.com/2018/04/19/trade-high-availability-in-action.html 这篇总结里面的1.5段也能看出，美团支付也在这块也栽过坑；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190509130445548-680717727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图四&lt;/p&gt;

&lt;p&gt;到这里，其实故障原因已经很清楚了，我们在代码层面也确实查到了问题。因为DBA提供的sql中，连insert sql的主机名也列了出来，并且现场没有被破坏，我们使用jstack应该还能找到正在等待的线程才对；于是在时隔故障2天后，我们又让运维把那台机器的jvm stack给打印了一下，果然发现等待的线程仍然存在&lt;img src=&quot;https://res.wx.qq.com/mpres/htmledition/images/icon/common/emotion_panel/emoji_wx/2_05.png&quot; alt=&quot;&quot; data-ratio=&quot;1&quot; data-w=&quot;20&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;堆栈如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190509130454708-590328829.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图五&lt;/p&gt;

&lt;p&gt;与之对应的代码，我就不贴了；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、临时解决方法，将响应超时时间设置上，但这无法根除问题，只是降低再次出现问题的概率；&lt;/p&gt;
&lt;p&gt;2、长久解决方案，修改框架，使用编程式事务，将所有远程调用从事务中剥离出来。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;知识点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、事务，spring AOP&lt;/p&gt;
&lt;p&gt;2、httpclient，超时设置&lt;/p&gt;

&lt;p&gt;    求关注&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201905/544558-20190509130502429-492260826.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 09 May 2019 05:02:00 +0000</pubDate>
<dc:creator>猿界汪汪队</dc:creator>
<og:description>故障描述 作为一个老牌OTA公司，公司早些年订单主要来源是PC网站和呼叫中心。我在入职公司大约半年后，遇到一次非常诡异的故障。有一天早上，大概也是这个季节，阳光明媚，程序猿刚起床，洗洗涮涮，准备去迎接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/donlianli/p/10837869.html</dc:identifier>
</item>
<item>
<title>【译文】领域模型的五个特征 - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10836592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10836592.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.petrikainulainen.net/software-development/design/thefive-characteristics-of-a-good-domain-model/&quot; target=&quot;_blank&quot;&gt;查看原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我在这篇博客文章中，我试图给领域模型下一个非常合适的定义，我发现我的这些定义都不太妥当，不过，我们还是可以先来看一下wiki百科对领域驱动模型下的定义&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;问题解决和软件工程中的领域模型可以被认为是感兴趣的领域（通常称为问题领域）的概念模型，其描述了各种实体，它们的属性和关系，以及控制完整性的约束。包含该问题域的模型元素。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;听起来很重要？&lt;/span&gt;&lt;span&gt;换句话说，领域模型是每个应用程序的重要组成部分，它是现实世界概念的表示。&lt;/span&gt;&lt;span&gt;但是，如何区分好的领域模型和坏的模型呢？由于了解领域模型，你也需要了解问题域，因此&lt;/span&gt;&lt;span&gt;对于这个问题，并没有明确的答案。在这篇文章中，我打算通过介绍领域模型的五个特征来简化这个问题的理解难度。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我认为，一个好的领域模型，他应具备以下基本特征：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确的对&lt;/strong&gt;问题域进行建模&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;一个好的领域模型不一定是来自现实世界的精确副本，但它必须以所需的准确度对问题域进行建模。&lt;/span&gt;&lt;span&gt;这意味着它必须仅包含与解决给定问题相关的信息。&lt;/span&gt;&lt;span&gt;必须从域模型中排除不必要的信息，即使它存在于现实世界中。不过，仅仅&lt;/span&gt;&lt;span&gt;包含正确的实体依然不够，这些实体之间关系也得正确&lt;/span&gt;&lt;span&gt;。在你使用这个标准判断一个领域模型之前，你应当了解从问题域中发现的知识，这绝非易事。 &lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;使用正确的统一语言&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;由于领域模型是问题域的表示，因此必须正确地命名其元素、&lt;/span&gt;&lt;span&gt;必须确保无论是客户或承包商都使用同一种语言（统一语言）。统一语言&lt;/span&gt;&lt;span&gt;很重要，因为它可以最大限度地减少误解的可能性，而这些额外的误解可能降低向客户提供产品的质量。&lt;/span&gt;&lt;span&gt;验证分析的域模型是否满足此要求非常简单，如果一个领域模型中的元素命名准确恰当，那么客户显然能无碍的理解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;领域应拥有和表达与当前问题域相关的完整信息。&lt;/strong&gt;&lt;span&gt;一个好的领域模型控制对其信息所做的更改。&lt;/span&gt;&lt;span&gt;因此它应该提供操作其内容的方法，并禁止对其控制下的信息进行所有其他更改。&lt;/span&gt;&lt;span&gt;仅为领域模型的信息提供单个访问点有两个主要优点：它减少了重复代码并保护了领域模型的完整性。&lt;/span&gt;&lt;span&gt;因此，遵循此个方法将导致职责清晰且更不容易出错的代码，这应该是每个软件工程师的目标。&lt;/span&gt;&lt;/span&gt;此外，如果您需要仅基于领域模型且没有其他依赖关系的信息，则应将提供此信息的方法放在域模型中。这种方法遵循&lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot; target=&quot;_blank&quot;&gt;关注点分离&lt;/a&gt;原则，它将通过阐明软件的体系结构来提高代码质量。遵循这些方法也将帮助您避免称为&lt;a href=&quot;http://martinfowler.com/bliki/AnemicDomainModel.html&quot; target=&quot;_blank&quot;&gt;贫血领域模型&lt;/a&gt;的反模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提供内置的日志记录支持&lt;/strong&gt;&lt;span&gt;&lt;span&gt;。领域模型应该提供获取实体的内容序列化成字符串的方法，并把对象的内容写入到日志消息&lt;/span&gt;&lt;span&gt;通常很有用。你&lt;/span&gt;&lt;span&gt;不必手动构造日志消息，只需将有问题的对象输出到日志文件中，就足以让你了解到相关的操作过程。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;良好的单元测试覆盖&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;良好领域模型的这种特征是显而易见的（至少对于专业人士而言），但我已经了解到假设可能是危险的。&lt;/span&gt;&lt;span&gt;这就是为什么我想写下关于单元测试域模型的几句话的原因。&lt;/span&gt;&lt;span&gt;虽然我知道精确的指导方针可能很危险，但我认为在这种情况下，可以为任何领域模型的单元测试提供准确的指导。&lt;/span&gt;&lt;span&gt;您必须简单地测试每个方法（不包括getter或setter方法）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过本文作者描述了一个设计优良的领域模型的五个特征。通过&lt;/span&gt;&lt;span&gt;这篇博文可以帮助读者辨识领域模型的优劣性，并为设计领域驱动模型提供一些提示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;PS：如果从头开始设计领域模型，往往会认为需要一个领域驱动设计的操作说明，因此作者推荐大家阅读 为Eric Evans的《&lt;a href=&quot;http://www.amazon.co.uk/Domain-driven-Design-Tackling-Complexity-Software/dp/0321125215&quot; target=&quot;_blank&quot;&gt;Domain-Driven Design&lt;/a&gt;》，这是一本有关领域驱动设计的史诗级巨作，值得每一位开发者阅读。 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 May 2019 04:58:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>查看原文 我在这篇博客文章中，我试图给领域模型下一个非常合适的定义，我发现我的这些定义都不太妥当，不过，我们还是可以先来看一下wiki百科对领域驱动模型下的定义： 问题解决和软件工程中的领域模型可以被</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10836592.html</dc:identifier>
</item>
<item>
<title>容器HEALTHCHECK指令对接ASP.NET Core健康检查特性 - Julian_酱</title>
<link>http://www.cnblogs.com/mi12205599/p/10837804.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mi12205599/p/10837804.html</guid>
<description>&lt;h2 id=&quot;2397-1557132350116&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201905/587720-20190509124635287-60642894.gif&quot; alt=&quot;&quot;/&gt; 写在前面&lt;/h2&gt;
&lt;p&gt;         HealthCheck 不仅是对应用程序内运行情况、数据流通情况进行检查， 还包括应用程序对外部服务或依赖资源的健康检查。&lt;/p&gt;
&lt;p&gt;健康检查通常是以&lt;strong&gt;暴露应用程序的HTTP端点的形式&lt;/strong&gt; 实施，可用于配置健康探测的的场景有 ：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;容器或负载均衡时 探测应用的状态， 例如：容器探测到应用unhealthy可&lt;em&gt;终止后续的滚动部署&lt;/em&gt;或者&lt;em&gt;重启容器&lt;/em&gt;；负载均衡器探测到实例healthyunt能将请求路由到健康的运行实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对应用程序种依赖的第三方服务进行健康探测，比如redis、database、外部服务接口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;内存、硬盘、网络等物理依赖资源的探测&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HealthCheck提供一种 &lt;strong&gt;告知外部应用运行状态的机制&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;容器HEALTHCHECK指令&lt;/h2&gt;
&lt;p&gt;　　一般情况下我们很容易知道容器正在运行[running]， 但容器作为相对独立的应用执行环境，有时候并不知道容器是否以预期的方式正确运作[working]&lt;/p&gt;
&lt;p&gt;Dockerfile/ docker-compose.yml文件提供的 HEALTHCHECK指令提供了&lt;strong&gt;探测容器正确工作的轮询机制&lt;/strong&gt;，轮询内容可由应用自身决定。&lt;/p&gt;
&lt;p&gt;该指令定义轮询参数interval、探测超时参数timeout、 重试参数retries 进行不间断探测容器：&lt;/p&gt;
&lt;div readability=&quot;78.720445062587&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// 通过在容器内运行shell命令来探测容器健康状态， 命令返回值0表示容器healthy， 命令返回值1表示unhealthy&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
EALTHCHECK [OPTIONS] CMD command  &lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于容器内Web应用，自然而然会想到使用暴露HTTP端点的方式去探测，并将error response认定为unhealthy&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// 容器每隔5min请求应用程序的http://localhost（重试3次），成功响应则返回0，错误响应则返回1&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
HEALTHCHECK --interval=5m --timeout=3s --retries=&lt;span&gt;3&lt;/span&gt; CMD curl -f &lt;span&gt;&lt;span&gt;http://localhost：5000/healthz&lt;/span&gt; || exit 1&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们会将渐进式演示 &lt;strong&gt;使用Docker平台的HEALTHCHECK指令对接 ASP.NET Core程序的健康检查能力&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201905/587720-20190509155625360-1628917888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201905/587720-20190509122254701-897743225.gif&quot; alt=&quot;&quot;/&gt; ASP.NET Core 实现HealthCheck&lt;/h3&gt;
&lt;p&gt;  ASPNET Core在2.2版本内置了健康检查的能力， 使用的是一个HealthCheck Middleware， 该中间件是一个终端中间件，满足该路径的url请求，将会被该中间件处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    services.AddHealthChecks();
}
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseHealthChecks(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/healthcheck&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  请求/healthcheck端点， 程序会进行健康检查逻辑并响应输出， 默认的行为:&lt;/p&gt;
&lt;p&gt;     ① 对healthy、degraded状态返回200 OK 响应码； 对于unhealthy返回503 Service Unavailable 响应码&lt;/p&gt;
&lt;p&gt;     ② 响应体只会包含简单的&lt;a href=&quot;https://docs.microsoft.com/dotnet/api/microsoft.extensions.diagnostics.healthchecks.healthstatus&quot;&gt;HealthStatus&lt;/a&gt;枚举字符串&lt;/p&gt;
&lt;p&gt;     ③ 将每次健康检查的结果写入HealthReport对象。&lt;/p&gt;
&lt;p&gt;   作为企业级项目，存在对Web项目物理资源和服务依赖的健康检查需求， 这里我们为避免重复造轮子，引入了开源的力量。&lt;/p&gt;

&lt;h3&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201905/587720-20190509122254701-897743225.gif&quot; alt=&quot;&quot;/&gt; 开源社区对HealthCheck的支持&lt;/h3&gt;
&lt;blockquote readability=&quot;6.0120967741935&quot;&gt;
&lt;p&gt;　开源的企业级&lt;a href=&quot;https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks&quot;&gt;AspNetCore.Diagnostics.HealthChecks&lt;/a&gt;系列组件，该系列组件支持多种物理资源和服务依赖的健康检查，支持报告推送，支持友好的检查报告UI（支持后台轮训检查）、支持webhook通知。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;下面的步骤演示了对web程序HTTP请求、Redis、Sqlite等服务进行健康检查的端点配置&lt;/p&gt;
&lt;p&gt;    ① 引入AspNetCore.HealthChecks.Redis 、 AspNetCore.HealthChecks.Sqlite nuget库&lt;/p&gt;
&lt;p&gt;    ② startup中配置并启用健康检查&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以下代码截取自 Startup.ConfigureServices方法，对swagger服务地址、redis、sqlte进行健康检查&lt;/span&gt;
services.AddHealthChecks().AddAsyncCheck(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;async&lt;/span&gt; () =&amp;gt;&lt;span&gt;
                      {
                        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (HttpClient client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient())
                        {
                            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                            {
                                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response = &lt;span&gt;await&lt;/span&gt; client.GetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000/swagger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;response.IsSuccessStatusCode)
                                {
                                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Url not responding with 200 OK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                                }
                            }
                            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
                            {
                                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.FromResult(HealthCheckResult.Unhealthy());
                            }
                        }
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.FromResult(HealthCheckResult.Healthy());
                    })
                    .AddSqlite(
                        sqliteConnectionString: Configuration.GetConnectionString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sqlite&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                        healthQuery: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select count(*) as count from ProfileUsageCounters;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sqlite&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        failureStatus: HealthStatus.Degraded,
                        tags: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sqlite&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sqlite&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                     )
                    .AddRedis(Configuration.GetConnectionString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, HealthStatus.Unhealthy, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; })
                    .Services
                    .AddMvc();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以下代码截取自Startup.Configure方法： 启用/healthz作为检查端点&lt;/span&gt;
 app.UseHealthChecks(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/healthz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).UseMvcWithDefaultRoute();    //  &lt;span&gt;这里仍然只会响应 &lt;strong&gt;200/503状态码+简单的HealthStatus枚举值&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    　小技巧：你也可以使用UseHealthChecks()扩展方法修改默认的响应输出， 这里我们可引入HealthChecks.UI.Client nuget package输出更加详细的的HealthReport&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  app.UseHealthChecks(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/healthz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HealthCheckOptions()
                {
                    Predicate &lt;/span&gt;= _ =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    ResponseWriter &lt;/span&gt;=&lt;span&gt;&lt;span&gt;  UIResponseWriter.WriteHealthCheckUIResponse  &lt;span&gt;// 该响应输出是一个json，包含所有检查项的详细检查结果&lt;/span&gt;&lt;/span&gt;
                });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;注意&lt;/h4&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;   　上文配置的HEALTHCHECK 指令： &lt;/p&gt;
&lt;p&gt;&lt;em&gt;       HEALTHCHECK --interval=5m --timeout=3s --retries=3 CMD curl -f &lt;span&gt;http://localhost:5000/healthz&lt;/span&gt; || exit 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;strong&gt;      &lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;并不关注响应体输出&lt;/strong&gt;，依然对于success response 返回0， error response返回1。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;  &lt;strong&gt;  &lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201905/587720-20190509122254701-897743225.gif&quot; alt=&quot;&quot;/&gt; 测试容器的HEALTHCHECK输出&lt;/h3&gt;
&lt;p&gt;　　  使用docker ps命令可查看容器的状态， 通过docker inspect [container_id] 查看容器HealthCheck的输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                  PORTS                NAMES
0111ea10581f        eqidmanager_proxy   &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nginx -g 'daemon ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;24&lt;/span&gt; hours ago        Up &lt;span&gt;24&lt;/span&gt; hours             &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;-&amp;gt;&lt;span&gt;80&lt;/span&gt;/&lt;span&gt;tcp   eqidmanager_proxy_1
8e96a0e8b993        eqidmanager_app     &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet EqidManage...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;24&lt;/span&gt; hours ago        Up &lt;span&gt;24&lt;/span&gt; hours (healthy)   &lt;span&gt;80&lt;/span&gt;/tcp               eqidmanager_app_1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 容器在启动的时候是starting， 一旦监测到成功的响应状态码，将会转换为healthy 并将会持续间隔轮询检查。&lt;/p&gt;

&lt;h3&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201905/587720-20190509123409891-1289635740.gif&quot; alt=&quot;&quot;/&gt;附加知识点&lt;/h3&gt;
&lt;p&gt;　　 抛开Docker的HEALTHCHECK指令、负载均衡器的轮询机制不谈，我们的Web自身也可以进行 轮询健康检查并给出告警。&lt;/p&gt;
&lt;p&gt;就我们上面的Web 实例来说，我们只对外提供的是一个 /healthcheck 检查端点，引入HealthChecks.UI.dll 将会在前端生成友好的HealthReport 界面， 该库支持后台轮询检查、支持webhook 通知。&lt;/p&gt;
&lt;p&gt;这里就不展开说明，自行前往&lt;a href=&quot;https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks&quot;&gt;AspNetCore.Diagnostics.HealthChecks&lt;/a&gt;查看响应文档，效果如下：&lt;/p&gt;
&lt;div readability=&quot;11.805825242718&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201905/587720-20190509123339925-2033164458.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;至此，本文内容完毕:&lt;/p&gt;
&lt;p&gt;   -  使用ASP.NETCore 框架实现一个稍复杂的HealthCheck端点 &lt;span&gt;/healthz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    - 使用docker的HEALTHCHECK 指令对接Web程序健康检查端点（该能力是实现&lt;strong&gt;容器自愈&lt;/strong&gt;的基础， 请关注后续博文）。&lt;/p&gt;

&lt;div id=&quot;MySignature&quot;&gt;
&lt;div readability=&quot;8.2578347578348&quot;&gt;

&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;感谢您的认真阅读，如有问题请大胆斧正，如果您觉得本文对你有用，不妨帮忙点个&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201902/587720-20190214132632297-2118004512.png&quot; alt=&quot;&quot;/&gt;或加关注。&lt;/p&gt;
&lt;p&gt;本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置注明本文的&lt;strong&gt;作者及原文链接&lt;/strong&gt;，否则保留追究法律责任的权利。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Thu, 09 May 2019 04:58:00 +0000</pubDate>
<dc:creator>Julian_酱</dc:creator>
<og:description>写在前面 HealthCheck 不仅是对应用程序内运行情况、数据流通情况进行检查， 还包括应用程序对外部服务或依赖资源的健康检查。 健康检查通常是以暴露应用程序的HTTP端点的形式 实施，可用于配置</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mi12205599/p/10837804.html</dc:identifier>
</item>
</channel>
</rss>