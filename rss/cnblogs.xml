<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>前端开发掌握nginx常用功能之rewrite - wonyun</title>
<link>http://www.cnblogs.com/wonyun/p/10355574.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wonyun/p/10355574.html</guid>
<description>&lt;p&gt;上一篇博文对nginx最常用功能的server及location的匹配规则进行了讲解，这也是nginx实现控制访问和反向代理的基础。掌握请求的匹配规则算是对nginx有了入门，但是这些往往还是不能满足实际的需求场景，例如请求url重写、重定向等等，这都需要对请求的&lt;code&gt;path&lt;/code&gt;进行修改操作的，匹配规则是不能独自完成实际需求的，这就需要掌握nginx的另一个常用功能rewrite，下面就来说说这个常用功能。&lt;/p&gt;
&lt;h2 id=&quot;rewrite规则&quot;&gt;Rewrite规则&lt;/h2&gt;
&lt;p&gt;rewrite功能就是，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。&lt;br/&gt;rewrite只能放在&lt;code&gt;server{}&lt;/code&gt;, &lt;code&gt;location{}&lt;/code&gt;, &lt;code&gt;if{}&lt;/code&gt; 中，并且只能对域名后边传递的参数外的字符串起作用，例如 &lt;a href=&quot;http://baidu.com/a/we/index.php?id=1&amp;amp;u=str&quot; class=&quot;uri&quot;&gt;http://baidu.com/a/we/index.php?id=1&amp;amp;u=str&lt;/a&gt; 只对/a/we/index.php重写。语法：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;rewrite regex replacement [flag];&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用proxy_pass反向代理。&lt;/p&gt;
&lt;p&gt;表面上看rewrite和location功能有点像，都能实现跳转，主要区别在于rewrite是在同一域名内更改获取资源的路径，而location是对一类路径做控制访问或反向代理，可以proxy_pass到其他机器。很多情况下rewrite也会写在location里，它们的执行顺序是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行server块的rewrite指令&lt;/li&gt;
&lt;li&gt;执行location匹配&lt;/li&gt;
&lt;li&gt;执行选定的location中的rewrite指令&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件；&lt;strong&gt;循环超过10次，则返回500 Internal Server Error错误。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;flag标志位&quot;&gt;2.1 flag标志位&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;last&lt;/code&gt; : 停止执行当前&lt;code&gt;ngx_http_rewrite_module&lt;/code&gt;的指令集，但是会继续走一遍请求匹配对应server或者location；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;break&lt;/code&gt; : 停止执行当前&lt;code&gt;ngx_http_rewrite_module&lt;/code&gt;的指令集，请求就此完成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redirect&lt;/code&gt; : 返回302临时重定向，地址栏会显示跳转后的地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;permanent&lt;/code&gt; : 返回301永久重定向，地址栏会显示跳转后的地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为301和302不能简单的只返回状态码，还必须有重定向的URL，这就是return指令无法返回301,302的原因了。&lt;/p&gt;
&lt;p&gt;对于上面的flag，有几点需要强调一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;last&lt;/code&gt;与&lt;code&gt;break&lt;/code&gt;对url的重写不会改变地址栏的地址&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说，nginx虽然对请求url进行了重写，但是地址栏不会有任何明显的改变，仍然显示nginx重写前的地址；这与&lt;code&gt;redirect&lt;/code&gt;和&lt;code&gt;permanent&lt;/code&gt;不同。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;last&lt;/code&gt;与&lt;code&gt;break&lt;/code&gt;的处理策略不同&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二者都会终止当前&lt;code&gt;ngx_http_rewrite_module&lt;/code&gt;的指令集的执行，但是 &lt;code&gt;last&lt;/code&gt; 立即发起新一轮的 请求匹配 而 &lt;code&gt;break&lt;/code&gt; 则不会。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;redirect&lt;/code&gt;和&lt;code&gt;permanent&lt;/code&gt;会终止后续nginx指令的执行&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;nginx在rewrite遇到flag是二者时，后续的指令是不会执行的。&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;server {
    listen 8080;
    location = /test {
        break;
        return 200 $request_uri;
        proxy_pass http://127.0.0.1:8080/other;
    }
    location / {
        return 200 $request_uri;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面例子中，我们访问 &lt;strong&gt;curl 127.0.0.1:8080/test&lt;/strong&gt;，会发现，&lt;strong&gt;return 200 $request_uri&lt;/strong&gt;语句没有执行，而&lt;code&gt;proxy_pass&lt;/code&gt;指令被执行了。这是因为：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;return&lt;/code&gt;指令属于ngx_http_proxy_module模块，它会被break终止掉；而rewrite模块它是ngx_http_proxy_module的指令，不会被&lt;code&gt;break&lt;/code&gt;给中断掉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;if指令与全局变量&quot;&gt;2.2 if指令与全局变量&lt;/h3&gt;
&lt;p&gt;if判断指令&lt;br/&gt;语法为&lt;code&gt;if(condition){...}&lt;/code&gt; ，对给定的条件condition进行判断。如果为真，大括号内的rewrite指令将被执行，if条件(conditon)可以是如下任何内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当表达式只是一个变量时，如果值为空或任何以0开头的字符串都会当做false&lt;/li&gt;
&lt;li&gt;直接比较变量和内容时，使用&lt;code&gt;=&lt;/code&gt;或&lt;code&gt;!=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt;正则表达式匹配，&lt;code&gt;~*&lt;/code&gt;不区分大小写的匹配，&lt;code&gt;!~&lt;/code&gt;区分大小写的不匹配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;-f&lt;/code&gt;和&lt;code&gt;!-f&lt;/code&gt;用来判断是否存在文件&lt;br/&gt;&lt;code&gt;-d&lt;/code&gt;和&lt;code&gt;!-d&lt;/code&gt;用来判断是否存在目录&lt;br/&gt;&lt;code&gt;-e&lt;/code&gt;和&lt;code&gt;!-e&lt;/code&gt;用来判断是否存在文件或目录&lt;br/&gt;&lt;code&gt;-x&lt;/code&gt;和&lt;code&gt;!-x&lt;/code&gt;用来判断文件是否可执行&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;ngnix&quot;&gt;
&lt;code&gt;if ($http_user_agent ~ MSIE) {
    rewrite ^(.*)$ /msie/$1 break;
} //如果UA包含&quot;MSIE&quot;，rewrite请求到/msid/目录下

if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) {
    set $id $1;
 } //如果cookie匹配正则，设置变量$id等于正则引用部分

if ($request_method = POST) {
    return 405;
} //如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302

if ($slow) {
    limit_rate 10k;
} //限速，$slow可以通过 set 指令设置

if (!-f $request_filename){
    break;
    proxy_pass  http://127.0.0.1;
} //如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查

if ($args ~ post=140){
    rewrite ^ http://example.com/ permanent;
} //如果query string中包含&quot;post=140&quot;，永久重定向到example.com

location ~* \.(gif|jpg|png|swf|flv)$ {
    valid_referers none blocked www.jefflei.com www.leizhenfang.com;
    if ($invalid_referer) {
        return 404;
    } //防盗链
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;全局变量&quot;&gt;全局变量&lt;/h4&gt;
&lt;p&gt;下面是可以用作if判断的全局变量:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;$args&lt;/code&gt; ： #这个变量等于请求行中的参数，同$query_string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$content_length&lt;/code&gt; ： 请求头中的Content-length字段。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$content_type&lt;/code&gt; ： 请求头中的Content-Type字段。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$document_root&lt;/code&gt; ： 当前请求在root指令中指定的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$host&lt;/code&gt; ： 请求主机头字段，否则为服务器名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$http_user_agent&lt;/code&gt; ： 客户端agent信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$http_cookie&lt;/code&gt; ： 客户端cookie信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$limit_rate&lt;/code&gt; ： 这个变量可以限制连接速率。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$request_method&lt;/code&gt; ： 客户端请求的动作，通常为GET或POST。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$remote_addr&lt;/code&gt; ： 客户端的IP地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$remote_port&lt;/code&gt; ： 客户端的端口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$remote_user&lt;/code&gt; ： 已经经过Auth Basic Module验证的用户名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$request_filename&lt;/code&gt; ： 当前请求的文件路径，由root或alias指令与URI请求生成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$scheme&lt;/code&gt; ： HTTP方法（如http，https）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$server_protocol&lt;/code&gt; ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$server_addr&lt;/code&gt; ： 服务器地址，在完成一次系统调用后可以确定这个值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$server_name&lt;/code&gt; ： 服务器名称。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$server_port&lt;/code&gt; ： 请求到达服务器的端口号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$request_uri&lt;/code&gt; ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$uri&lt;/code&gt; ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$document_uri&lt;/code&gt; ： 与$uri相同。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;例：http://localhost:88/test1/test2/test.php
$host：localhost
$server_port：88
$request_uri：http://localhost:88/test1/test2/test.php
$document_uri：/test1/test2/test.php
$document_root：/var/www/html
$request_filename：/var/www/html/test1/test2/test.php
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;常用正则&quot;&gt;2.3 常用正则&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;.&lt;/code&gt; ： 匹配除换行符以外的任意字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; ： 重复0次或1次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; ： 重复1次或更多次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; ： 重复0次或更多次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\d&lt;/code&gt; ：匹配数字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; ： 匹配字符串的开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; ： 匹配字符串的结束&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n}&lt;/code&gt; ： 重复n次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,}&lt;/code&gt; ： 重复n次或更多次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[c]&lt;/code&gt; ： 匹配单个字符c&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[a-z]&lt;/code&gt; ： 匹配a-z小写字母的任意一个&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;小括号&lt;code&gt;()&lt;/code&gt;之间匹配的内容，可以在后面通过&lt;code&gt;$1&lt;/code&gt;来引用，&lt;code&gt;$2&lt;/code&gt;表示的是前面第二个()里的内容。正则里面容易让人困惑的是&lt;code&gt;\&lt;/code&gt;转义特殊字符。&lt;/p&gt;
&lt;h3 id=&quot;rewrite实例&quot;&gt;2.4 rewrite实例&lt;/h3&gt;
&lt;p&gt;例1：&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;http {
    # 定义image日志格式
    log_format imagelog '[$time_local] ' $image_file ' ' $image_type ' ' $body_bytes_sent ' ' $status;
    # 开启重写日志
    rewrite_log on;

    server {
        root /home/www;

        location / {
                # 重写规则信息
                error_log logs/rewrite.log notice;
                # 注意这里要用‘’单引号引起来，避免{}
                rewrite '^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$' /data?file=$3.$4;
                # 注意不能在上面这条规则后面加上“last”参数，否则下面的set指令不会执行
                set $image_file $3;
                set $image_type $4;
        }

        location /data {
                # 指定针对图片的日志格式，来分析图片类型和大小
                access_log logs/images.log mian;
                root /data/images;
                # 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最后一个url里
                try_files /$arg_file /image404.html;
        }
        location = /image404.html {
                # 图片不存在返回特定的信息
                return 404 &quot;image not found\n&quot;;
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对形如&lt;code&gt;/images/ef/uh7b3/test.png&lt;/code&gt;的请求，重写到&lt;code&gt;/data?file=test.png&lt;/code&gt;，于是匹配到&lt;code&gt;location /data&lt;/code&gt;，先看&lt;code&gt;/data/images/test.png&lt;/code&gt;文件存不存在，如果存在则正常响应，如果不存在则重写tryfiles到新的image404 location，直接返回404状态码。&lt;/p&gt;
&lt;p&gt;例2：&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;rewrite ^/images/(.*)_(\d+)x(\d+)\.(png|jpg|gif)$ /resizer/$1.$4?width=$2&amp;amp;height=$3? last;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对形如&lt;code&gt;/images/bla_500x400.jpg&lt;/code&gt;的文件请求，重写到&lt;code&gt;/resizer/bla.jpg?width=500&amp;amp;height=400&lt;/code&gt;地址，并会继续尝试匹配location。&lt;/p&gt;
&lt;p&gt;例3：&lt;br/&gt;见 &lt;a href=&quot;http://seanlook.com/2015/05/28/nginx-ssl/&quot;&gt;ssl部分页面加密&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;rewrite需要注意的问题&quot;&gt;2.5 rewrite需要注意的问题&lt;/h3&gt;
&lt;p&gt;上面说过，rewrite的指令规则为：&lt;code&gt;rewrite regex replacement [flag];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;rewrite指令用指定的regex来匹配请求的uri，若匹配成功则用replacement来重写请求uri。这里需要注意的replacement字符串的内容：&lt;/p&gt;
&lt;p&gt;1、 &lt;strong&gt;若replacement以&lt;code&gt;http://&lt;/code&gt;、&lt;code&gt;https://&lt;/code&gt;或者&lt;code&gt;$scheme&lt;/code&gt;开头，则告诉nginx这是重定向操作(flag默认为redirect)，nginx则停止处理后续内容，并直接重定向返回给客户端。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;location / {
    # 当匹配 正则表达式 /test/(.*)时 请求将被临时重定向到 http://www.baidu.com/$1
    # flag默认为redirect
    rewrite /test/(.*) https://www.baidu.com/$1;
    return 200 ’ok'; # 此处没有机会执行
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、&lt;strong&gt;replacement非以上三种情况开头，则就是简单的url重写&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;location / {
    # 当匹配 正则表达式 /test/(.*)时 请求将被临时重定向到 www.baidu.com/$1
    # flag无值则rewrite会顺序执行
    rewrite /test/(.*) www.baidu.com/$1;
    return 200 ’ok'; # 此处因为rewrite顺序执行而得到执行机会
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于上面两种情况，还需要特别留意一个redirect端口的问题，先上一个例子：&lt;/p&gt;
&lt;pre class=&quot;nginx&quot;&gt;
&lt;code&gt;## server.com机器上nginx的配置如下：
server {
    listen 8000;
    location /test1/ {
    rewrite /test1/index.html http://server1.com/demo/test1 redirect;
    }
    location /test2/ {
    rewrite /test2/index.html /demo/test2 redirect;
        proxy_pass http://192.168.1.3:8000;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当访问&lt;strong&gt;&lt;a href=&quot;http://server.com/test1/index.html&quot; class=&quot;uri&quot;&gt;http://server.com/test1/index.html&lt;/a&gt;&lt;/strong&gt;时，会命中/test1的location规则，访问server1.com对应内容一直失败，发现重定向后响应头的&lt;code&gt;Location&lt;/code&gt;字段值为&lt;strong&gt;&lt;a href=&quot;http://server1.com:8000/demo/test1&quot; class=&quot;uri&quot;&gt;http://server1.com:8000/demo/test1&lt;/a&gt;&lt;/strong&gt;，带有8000端口，我们并没有配置，表现的比较诡异？&lt;/p&gt;
&lt;p&gt;访问&lt;strong&gt;&lt;a href=&quot;http://server.com/test2/index.html&quot; class=&quot;uri&quot;&gt;http://server.com/test2/index.html&lt;/a&gt;&lt;/strong&gt;时，命中/test2的location规则，同样访问失败，但是访问的重定向后响应头&lt;code&gt;Location&lt;/code&gt;字段值为&lt;strong&gt;&lt;a href=&quot;http://server.com:8000/demo/test2&quot; class=&quot;uri&quot;&gt;http://server.com:8000/demo/test2&lt;/a&gt;&lt;/strong&gt;，其带有server.com的server_name和8000的端口，更加诡异？&lt;/p&gt;
&lt;p&gt;看到上面的现象，疑惑重重；其实这跟nginx的&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#server_name_in_redirect&quot;&gt;&lt;code&gt;server_name_in_redirect&lt;/code&gt;&lt;/a&gt;和&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#port_in_redirect&quot;&gt;&lt;code&gt;port_in_redirect&lt;/code&gt;&lt;/a&gt;指令有关:&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在绝对路径中，&lt;code&gt;server_name_in_redirect&lt;/code&gt; 和&lt;code&gt;port_in_redirect&lt;/code&gt; 指令表示是否将server块中的 server_name 和 listen 的端口作为redirect用, 重定向的完整url地址根据&lt;code&gt;$scheme&lt;/code&gt;跟&lt;code&gt;server_name_in_redirect&lt;/code&gt;和&lt;code&gt;port_in_redirect&lt;/code&gt;来确定的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在绝对路径中，&lt;code&gt;server_name_in_redirect&lt;/code&gt;默认是禁用的，而&lt;code&gt;port_in_redirect&lt;/code&gt;是默认启用的。对于带有&lt;code&gt;$scheme&lt;/code&gt;重定向的绝对路径，nginx会从replacement中获取指定的server_name和port来进行重定向：&lt;/p&gt;
&lt;p&gt;第一种，若replacement带请求协议http(s)，而其中没有指定port的话，nginx会默认取当前server的listen端口作为重定向的端口。这是上面访问&lt;strong&gt;&lt;a href=&quot;http://server.com/test1/index.html&quot; class=&quot;uri&quot;&gt;http://server.com/test1/index.html&lt;/a&gt;&lt;/strong&gt;时重定向到&lt;strong&gt;&lt;a href=&quot;http://server.com:8000/demo/test2&quot; class=&quot;uri&quot;&gt;http://server.com:8000/demo/test2&lt;/a&gt;&lt;/strong&gt;时会携带8000的原因。&lt;/p&gt;
&lt;p&gt;第二种，若replacement不带请求协议http(s)，而是相对本地服务器的绝对地址的话，如上面访问&lt;strong&gt;&lt;a href=&quot;http://server.com/test2/index.html&quot; class=&quot;uri&quot;&gt;http://server.com/test2/index.html&lt;/a&gt;&lt;/strong&gt;的情况，此时&lt;code&gt;server_name_in_redirect&lt;/code&gt;由于禁用它会去请求的host来作为server_name，取当前server的listen端口作为重定向的端口，最终重定向到&lt;strong&gt;&lt;a href=&quot;http://server.com:8000/demo/test2&quot; class=&quot;uri&quot;&gt;http://server.com:8000/demo/test2&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;或许你会问，访问&lt;strong&gt;&lt;a href=&quot;http://server.com/test2/index.html&quot; class=&quot;uri&quot;&gt;http://server.com/test2/index.html&lt;/a&gt;&lt;/strong&gt;为什么不会重定向到&lt;strong&gt;&lt;a href=&quot;http://192.168.1.3:8000/demo/test2&quot; class=&quot;uri&quot;&gt;http://192.168.1.3:8000/demo/test2&lt;/a&gt;&lt;/strong&gt;上？这是因为rewrite的redirect flag会终止后续指令的执行，所以其后的&lt;code&gt;proxy_pass&lt;/code&gt;指令不会执行。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
</description>
<pubDate>Thu, 07 Feb 2019 16:28:00 +0000</pubDate>
<dc:creator>wonyun</dc:creator>
<og:description>上一篇博文对nginx最常用功能的server及location的匹配规则进行了讲解，这也是nginx实现控制访问和反向代理的基础。掌握请求的匹配规则算是对nginx有了入门，但是这些往往还是不能满足</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wonyun/p/10355574.html</dc:identifier>
</item>
<item>
<title>MyDAL - 组件适用范围说明 - Meng.NET</title>
<link>http://www.cnblogs.com/Meng-NET/p/10355760.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Meng-NET/p/10355760.html</guid>
<description>&lt;p&gt;&lt;strong&gt;索引：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/Meng-NET/p/8963476.html&quot; target=&quot;_blank&quot;&gt;目录索引&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.组件特性简介:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.MSIL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　底层代码采用 System.Reflection.Emit.Lightweight 类库使用 IL 的方式处理 Model 组装,性能刚刚的~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　大量使用 System.Linq.Expressions 方式,强类型,对程序员编码非常友好~&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.借鉴&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　本人精通 MyBatis / CtripDAL / Dapper / EntityFramework Core 四个 ORM 框架,所以大量借鉴它们的优点~~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二.工程项目-适用范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　MyDAL.dll 目前编译目标是 .Net Standard 2.0.3 ,可以在以下&lt;strong&gt;工程项目&lt;/strong&gt;中引用并使用:&lt;/p&gt;
&lt;p&gt;　　　　.Net Framework 4.6.1 +&lt;/p&gt;
&lt;p&gt;　　　　.Net Core 2.0 +&lt;/p&gt;
&lt;p&gt;　　　　Mono 5.4 +&lt;/p&gt;
&lt;p&gt;　　　　Xamarin.ios 10.14 +&lt;/p&gt;
&lt;p&gt;　　　　Xamarin.Mac 3.8 +&lt;/p&gt;
&lt;p&gt;　　　　Xamarin.Android 8.0 +&lt;/p&gt;
&lt;p&gt;　　　　UWP 10. 0. 16299 +&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三.操作系统-适用范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由于 .Net Standard 的跨平台开发特性,你可以在以下&lt;strong&gt;操作系统&lt;/strong&gt;中部署及运行:&lt;/p&gt;
&lt;p&gt;　　　　Windows 7 SP1 +  (x64, x86) &lt;/p&gt;
&lt;p&gt;　　　　Windows 10 +  (x64, x86)&lt;/p&gt;
&lt;p&gt;　　　　Windows Server 2008 R2 SP1 +  (x64, x86)&lt;/p&gt;
&lt;p&gt;　　　　Redhat Linux(包含 Cent OS Linux) 7.3 +  (x64)&lt;/p&gt;
&lt;p&gt;　　　　Fedora Linux 25 +  (x64)&lt;/p&gt;
&lt;p&gt;　　　　Debian Linux(包含 DeepIn Linux) 8.7 +  (x64)&lt;/p&gt;
&lt;p&gt;　　　　Ubuntu Linux 14.04 +  (x64, arm32[社区版])&lt;/p&gt;
&lt;p&gt;　　　　OpenSUSE Linux 42.2 +  (x64)&lt;/p&gt;
&lt;p&gt;　　　　Mac OS X 10.12 +  (x64)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四.OS核心-测试覆盖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　1.WinNT(Windows)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　基于 windows 10 测试覆盖&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.Linux(Ubuntu)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　基于 ubuntu 18.10 测试覆盖&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.Unix(iOS)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　基于 ios 12.1.3 测试覆盖&lt;/p&gt;



&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　2019-02-07 23:53 周四&lt;/p&gt;

</description>
<pubDate>Thu, 07 Feb 2019 15:53:00 +0000</pubDate>
<dc:creator>Meng.NET</dc:creator>
<og:description>索引： 目录索引 一.组件特性简介: 1.MSIL 底层代码采用 System.Reflection.Emit.Lightweight 类库使用 IL 的方式处理 Model 组装,性能刚刚的~ 2.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Meng-NET/p/10355760.html</dc:identifier>
</item>
<item>
<title>CentOS7.x的DNS服务的基础配置 - Alien)</title>
<link>http://www.cnblogs.com/alienbug/p/10355735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alienbug/p/10355735.html</guid>
<description>&lt;p&gt;一、bind服务器安装&lt;/p&gt;
&lt;p&gt;　　bind:开源、稳定、应用广泛的DNS服务。bind的软件包名bind,服务名称named.&lt;/p&gt;
&lt;p&gt;　　查看是否安装bind, 安装bind包：　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　rpm -qa bind&lt;br/&gt;　　yum&lt;/span&gt; -y &lt;span&gt;install&lt;/span&gt; bind
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　bind服务主要配置文件：&lt;/p&gt;
&lt;p&gt;　　　　　　/etc/named.conf　　//主配置文件&lt;/p&gt;
&lt;p&gt;　　　　　　/etx/named.rfc1912.zones　　//区域配置文件&lt;/p&gt;
&lt;p&gt;　　　　　　/var/named/       //&lt;/p&gt;
&lt;p&gt;二、基本配置&lt;/p&gt;
&lt;p&gt;　　修改named.conf文件： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;options {
        listen-on-port 53 {any;};   //监听地址，监听端口53&lt;br/&gt;　　　　　directory       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/var/named&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;    //bind数据库文件zone文件
  　　　　allow-file {any;};    //权限的加密控制,允许那些主机查询&lt;/span&gt;&lt;span&gt;
        recursion yes;      //是否允许进行递归查询&lt;/span&gt;&lt;span&gt;

logging {　　　　　　　　　　　　　　　//服务日志选项
        channel default_debug {
                &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data/named.run&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;   
                severity dynamic;         
        };
};

zone &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; IN {　　　　//根域解析
        type hint;
        &lt;/span&gt;&lt;span&gt;file&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;named.ca&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;    
};&lt;br/&gt;zone &quot;test.com&quot; IN {   //test.com的解析   &lt;br/&gt;　　　　 type master;&lt;br/&gt;　　　　 file &quot;test.zone&quot;;     //test.com的zone文件&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;span&gt;zone &quot;43.168.192.in-appr.arpa&quot; IN {   //test.com逆向解析&lt;br/&gt;　　　　 type master;&lt;br/&gt;　　　　 file &quot;test.ptr&quot;;       //test.com逆向解析zone文件&lt;br/&gt;};
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/named.rfc1912.zones&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;　　//zone配置文件
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/named.root.key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;     //根域的key文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　/var/named/test.zone和/var/named/test.ptr文件可以通过/var/named/empty 拷贝得到&lt;/p&gt;
&lt;p&gt;　　　　 cp -p /var/named/empty  /var/named/test.zone     //通过加-p将源文件的权限也复制过来&lt;/p&gt;
&lt;p&gt;　　　　zone配置文件的属组要为named组，  chgrp named   /var/named/test.zone&lt;/p&gt;
&lt;p&gt;　　修改test.zone文件：（正向解析）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$TTL 3H
test.com.        IN SOA  test.com.  zh.&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;&lt;span&gt;.com. (
                                        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum

test.com.        IN NS dns.test.com.
dns     IN A    &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;43.100&lt;/span&gt;&lt;span&gt;
www     IN A    &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;43.100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　第一行 ：  $TTL  3H  --dns失效时间，单位秒&lt;/p&gt;
&lt;p&gt;　　　　第二行 ：   启始记录    解析的域名   解析到test.com.   管理员邮箱（zone文件内@表示该域名）  &lt;/p&gt;
&lt;p&gt;　　　　中间5行不需要修改&lt;/p&gt;
&lt;p&gt;　　　　第八行 ：  NS记录      test.com. 用dns.test.com.服务器来解析&lt;/p&gt;
&lt;p&gt;　　　　第九行 ：  A记录     dns.test.com. 的IP&lt;/p&gt;
&lt;p&gt;　　　　第十行 ：  A记录      www.test.com. 的IP   &lt;/p&gt;
&lt;p&gt;　　修改/var/named/test.ptr文件：（反向解析）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$TTL 1D
@       IN SOA  dns.test.com.  rname.invalid. (
                                        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;       ; serial
                                        1D      ; refresh
                                        1H      ; retry
                                        1W      ; expire
                                        3H )    ; minimum
@       NS      dns.test.com.      //ns记录 
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;     PTR     dns.test.com.      //  dns.test.com.服务器的IP
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     PTR     www.test.com.      //  192.168.43.100对应的域名记录
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动服务：&lt;/p&gt;
&lt;p&gt;　　　　systemctl  start named    //启动服务&lt;/p&gt;
&lt;p&gt;　　　　systemctl restart named   //重启服务&lt;/p&gt;
&lt;p&gt;　　注意防火墙和SELinux是否配置了相应的规则，也可以关闭防火墙和SELinux   &lt;/p&gt;
&lt;p&gt;　　　　systemctl stop firewalld &lt;/p&gt;
&lt;p&gt;　　　    setenforce  0   &lt;/p&gt;
&lt;p&gt;三、DNS客户端&lt;/p&gt;
&lt;p&gt;　　修改本机dns，修改网络配置文件的dns地址&lt;/p&gt;
&lt;p&gt;　　　　/etc/sysconfig/network-scripts/ifcfg-ens33 &lt;/p&gt;
&lt;p&gt;　　　　或修改/etc/resolv.conf&lt;/p&gt;
&lt;p&gt;　　dns客户端：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1564466/201902/1564466-20190207231317755-2048838666.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;190&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;　　dig正向解析 dig @192.168.43.100 www.test.com  dig反向解析在-x  ：dig -x 192.168.43.100&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG &lt;span&gt;9.9&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-RedHat-&lt;span&gt;9.9&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-&lt;span&gt;72&lt;/span&gt;.el7 &amp;lt;&amp;lt;&amp;gt;&amp;gt; @&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;43.100&lt;/span&gt;&lt;span&gt; www.test.com
; (&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; server found)
;; global options: &lt;/span&gt;+&lt;span&gt;cmd
;; Got answer:
;; &lt;/span&gt;-&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, &lt;span&gt;id&lt;/span&gt;: &lt;span&gt;55522&lt;/span&gt;&lt;span&gt;
;; flags: qr aa rd ra; QUERY: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, ANSWER: &lt;span&gt;2&lt;/span&gt;, AUTHORITY: &lt;span&gt;1&lt;/span&gt;, ADDITIONAL: &lt;span&gt;2&lt;/span&gt;&lt;span&gt;

;; OPT PSEUDOSECTION:
; EDNS: version: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, flags:; udp: &lt;span&gt;4096&lt;/span&gt;&lt;span&gt;
;; QUESTION SECTION:
;www.test.com.                   IN      A

;; ANSWER SECTION:
www.test.com.            &lt;/span&gt;&lt;span&gt;10800&lt;/span&gt;   IN      A       &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;43.100&lt;/span&gt;&lt;span&gt;

;; AUTHORITY SECTION:
test.com.                &lt;/span&gt;&lt;span&gt;10800&lt;/span&gt;&lt;span&gt;   IN      NS      dns.test.com.

;; ADDITIONAL SECTION:
dns.test.com.            &lt;/span&gt;&lt;span&gt;10800&lt;/span&gt;   IN      A       &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;43.100&lt;/span&gt;&lt;span&gt;

;; Query &lt;/span&gt;&lt;span&gt;time&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;&lt;span&gt; msec
;; SERVER: &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;43.100&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt;(&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;43.100&lt;/span&gt;&lt;span&gt;)
;; WHEN: 四 2月 &lt;/span&gt;&lt;span&gt;07&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:&lt;span&gt;43&lt;/span&gt; CST &lt;span&gt;2019&lt;/span&gt;&lt;span&gt;
;; MSG SIZE  rcvd: &lt;/span&gt;&lt;span&gt;106&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;若转载请保留出处：https://www.cnblogs.com/alienbug/&lt;/p&gt;

</description>
<pubDate>Thu, 07 Feb 2019 15:30:00 +0000</pubDate>
<dc:creator>Alien)</dc:creator>
<og:description>一、bind服务器安装 bind:开源、稳定、应用广泛的DNS服务。bind的软件包名bind,服务名称named. 查看是否安装bind, 安装bind包： bind服务主要配置文件： /etc/n</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/alienbug/p/10355735.html</dc:identifier>
</item>
<item>
<title>SqlServer中的系统数据库 - 千金不如一默</title>
<link>http://www.cnblogs.com/jixiaosa/p/10355731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jixiaosa/p/10355731.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;SqlServer中的系统数据库有五个，平时写代码不太关注，今天一时兴起研究了一下。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. master&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;记录SQL Server系统的所有系统级信息,例如：登陆账户信息、链接服务器和系统配置设置、记录其他所有数据库的存在、数据文件的位置、SQL Server的初始化信息等。如果master数据库不可用，则无法启动SQL Server。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.msdb&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用于SQL Server代理计划警报和作业。数据库定时执行某些操作、数据库邮件等。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.model&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;用作SQL Server实例上创建的所有数据库的模板。对model 数据库进行的修改（如数据库大小、排序规则、恢复模式和其他数据库选项）将应用于以后创建的所有数据库。在model数据库中创建一张表，则以后每次创建数据库的时候都会有默认的一张同样的表。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.tempdb&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个工作空间，用于保存临时对象或中间结果集。一个全局资源，可供连接到 SQL Server 实例的所有用户使用。每次启动 SQL Server 时都会重新创建 tempdb.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.resource&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个只读数据库，包含 SQL Server 包括的系统对象。系统对象在物理上保留在 Resource 数据库中，但在逻辑上显示在每个数据库的 sys 架构中。Resource 数据库的物理文件名为 mssqlsystemresource.mdf 和 mssqlsystemresource.ldf。这些文件位于 &amp;lt;驱动器&amp;gt;:\Program Files\Microsoft SQL Server\MSSQL10_50.&amp;lt;instance_name&amp;gt;\MSSQL\Binn\ 中。每个 SQL Server 实例都具有一个（也是唯一的一个）关联的 mssqlsystemresource.mdf 文件，并且实例间不共享此文件&lt;/p&gt;
</description>
<pubDate>Thu, 07 Feb 2019 15:26:00 +0000</pubDate>
<dc:creator>千金不如一默</dc:creator>
<og:description>SqlServer中的系统数据库有五个，平时写代码不太关注，今天一时兴起研究了一下。 1. master 记录SQL Server系统的所有系统级信息,例如：登陆账户信息、链接服务器和系统配置设置、记</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jixiaosa/p/10355731.html</dc:identifier>
</item>
<item>
<title>win10安装ubuntu16.04双系统 - Apple_Coco</title>
<link>http://www.cnblogs.com/SystemCall/p/10353426.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SystemCall/p/10353426.html</guid>
<description>&lt;p&gt;前话：因为感兴趣吧也是专业需要，所以自学了U盘重装系统以及在win10的情况下安装Ubuntu16.04双系统。借此博客，记录下我安装Ubuntu的过程，方便日后回忆。&lt;/p&gt;
&lt;p&gt;正因如此，本篇博客会写的十分简略，如有不便请见谅。&lt;/p&gt;

&lt;p&gt;如果你是一位新手，推荐一位大神的博客。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.cnblogs.com/Duane/p/5424218.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;补充知识点：关于磁盘使用GUID格式分区和MBR格式分区&lt;/h2&gt;
&lt;p&gt;当你使用DiskGenius分区工具快速分区时，会让你选择要哪一种分区格式，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531199/201902/1531199-20190207211934422-793952938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两种分区类型有一个很重要的区别就是GUID对应电脑的UEFI启动模式，MBR对应的是Legacy启动模式。&lt;/p&gt;
&lt;p&gt;举一个栗子，如果你的系统盘（C盘）所在磁盘是GUID分区类型的，但是电脑的启动方式却又是Legacy，这样的话，当你启动电脑时，会出现Invalid Partition Table（无效分区表）。&lt;/p&gt;
&lt;p&gt;如果想要进入系统，必须将Legacy改为UEFI。&lt;/p&gt;

&lt;p&gt;在多次安装双系统失败后，我自己感觉出来一个规律：&lt;/p&gt;
&lt;p&gt;磁盘使用GUID分区类型，在安装双系统的时候会更加方便。而且安装成功后，会默认使用Ubuntu引导Windows，这样子就不需要使用easyBCD或者refind工具。&lt;/p&gt;

&lt;h2&gt;下面是我的安装Ubuntu的过程，在此之前我说一下我BIOS里的配置：&lt;/h2&gt;
&lt;p&gt;安全模式和快速启动要设置为disable，启动方式设置为 仅UEFI。U盘启动方式设置为enable&lt;/p&gt;

&lt;h2&gt;第一步：压缩出一块空闲的区域用于Ubuntu系统，原则上越大越好，推荐100GB以上&lt;/h2&gt;
&lt;p&gt;注意：该块区域所在磁盘的类型需为GUID类型&lt;/p&gt;
&lt;h2&gt;第二步：制作Ubuntu16.04的启动盘&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
链接：https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pan.baidu.com/s/1WIepLY_os8m1puZBwDfyrA &lt;/span&gt;
提取码：1lnq 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;网盘里面是rufusU盘制作工具和Ubuntu镜像，制作启动盘的设置如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531199/201902/1531199-20190207224118463-1805548407.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开始确定确定即可（如果U盘里有重要资料，记着提前做好备份）&lt;/p&gt;
&lt;h2&gt; 第三步：安装Ubuntu&lt;/h2&gt;
&lt;p&gt;插上U盘，重启电脑，进入U盘启动盘。正常情况下便能看到install ubuntu的选项，选择该选项。&lt;/p&gt;
&lt;p&gt;在下图界面，“安装Ubuntu时下载更新”无需勾选，因为会增加安装时间，安装完成后也可以进行软件更新。&lt;/p&gt;
&lt;p&gt;第二个选项可勾可不勾。可能是我安装时的网络不好，勾选第二个选项选择 继续 需要等待很长时间，看个人情况吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531199/201902/1531199-20190207225207541-1032858258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择安装类型选择其它选项，然后继续。&lt;/p&gt;
&lt;p&gt;在接下来的界面里，先选中第一步分配出来的空闲区域，点击下面的加号，进行Ubuntu分区&lt;/p&gt;
&lt;p&gt;以100G的空闲空间为例，具体分区情况如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/boot&lt;/strong&gt; 分区:  ------ 300MB。逻辑分区，空间起始位置，Ext4日志文件系统&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/&lt;/strong&gt; 分区　------ 35GB。逻辑分区，空间起始位置，Ext4日志文件系统&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;swap(&lt;/strong&gt;&lt;strong&gt;交换空间&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt; :　------ 4GB。逻辑分区，空间起始位置，用于：交换空间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/home &lt;/strong&gt;分区　------ 剩下的空间都给它好了。逻辑分区，空间起始位置，Ext4日志文件系统&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&quot;安装启动引导器的设备&quot;选择/boot对应的分区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;检查无误后点击现在安装，点击继续...&lt;/p&gt;
&lt;p&gt;后面默认即可。安装过程看网速如何，慢的话估计要安装很久，推荐深夜安装，睡一觉就安装好了。&lt;/p&gt;
&lt;h2&gt;最后一步：如果你是按照我的步骤走的（都是UEFI启动方式），那么在重启电脑后你会惊喜的发现是通过Ubuntu去引导启动的，你可以选择是进入Windows系统或是Ubuntu系统，双系统安装大功告成。&lt;/h2&gt;

&lt;p&gt;后话：如果重启之后会发现，没有Ubuntu的选择项，依旧直接进入Windows。你可能需要EasyBCD或是refind软件了。&lt;/p&gt;
&lt;p&gt;EasyBCD在我最前面推荐的博客中有使用方法。refind推荐下面的博客，亲测可用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;tshare365.com/archives/1774.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-------------End--------------&lt;/p&gt;

</description>
<pubDate>Thu, 07 Feb 2019 15:22:00 +0000</pubDate>
<dc:creator>Apple_Coco</dc:creator>
<og:description>前话：因为感兴趣吧也是专业需要，所以自学了U盘重装系统以及在win10的情况下安装Ubuntu16.04双系统。借此博客，记录下我安装Ubuntu的过程，方便日后回忆。 正因如此，本篇博客会写的十分简</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SystemCall/p/10353426.html</dc:identifier>
</item>
<item>
<title>【杂谈】一个简易的静态网页服务器 - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/10355514.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/10355514.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　上一篇随笔&lt;span&gt;&lt;strong&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/longfurcat/p/10353786.html&quot;&gt;【杂谈】一个回车下去，浏览器做了什么？&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;讲了浏览器的处理，这里再用一个例子讲解一下，也不算讲解，算是梳理一下服务端处理浏览器请求的过程。当然实际过程要比这复杂多了。下文的例子，其实就是《How Tomcat Works》这本书的第一个例子，感兴趣的可以去看这本书。不过书上的例子有问题，我下文中会提到。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：此项目不需要用tomcat，纯Java底层代码写就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;程序有三个类HttpServer，Request，Response。&lt;/p&gt;
&lt;p&gt;HttpServer  =&amp;gt; 负责监听socket连接，创建Request、Response对象&lt;/p&gt;
&lt;p&gt;Request =&amp;gt; 用于获取请求信息的URI（利用Socket的InputStream），这里URI就是静态网页文件的相对路径&lt;/p&gt;
&lt;p&gt;Response =&amp;gt; 用于发送响应数据报（利用Request获取请求信息，利用OutputStream写出数据）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序包图&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201902/1313132-20190207210449576-257703372.png&quot; alt=&quot;&quot; width=&quot;267&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;完整代码&lt;/h2&gt;
&lt;p&gt;由于贴完整代码都会使篇幅略显过长，所以下面都折叠起来了，看客可以逐个展开查看。&lt;/p&gt;
&lt;p&gt;HttpServer.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_53fd51d6-b6ba-4555-a260-c7ecec23615f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_53fd51d6-b6ba-4555-a260-c7ecec23615f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_53fd51d6-b6ba-4555-a260-c7ecec23615f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.wze.ex01.pyrmont;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.ServerSocket;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.Socket;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpServer {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String WEB_ROOT = System.getProperty(&quot;user.dir&quot;) + File.separator + &quot;webroot&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SHUTDOWN_COMMAND = &quot;/SHUTDOWN&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; shutdown = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(WEB_ROOT);
        HttpServer server &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpServer();
        server.await();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; await() {
        ServerSocket serverSocket &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; port = 8080&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;之所以要绑定监听的IP地址，是因为一个电脑可能有多个网卡&lt;/span&gt;
            serverSocket = &lt;span&gt;new&lt;/span&gt; ServerSocket(port, 1, InetAddress.getByName(&quot;127.0.0.1&quot;&lt;span&gt;));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果绑定失败，那么这个程序也就没有运行下去的必要了。&lt;/span&gt;
            System.exit(1&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;shutdown) {
            Socket socket &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            InputStream input  &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            OutputStream output &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收一个请求，处理完毕后关闭连接&lt;/span&gt;
                socket =&lt;span&gt; serverSocket.accept();
                input &lt;/span&gt;=&lt;span&gt; socket.getInputStream();
                output &lt;/span&gt;=&lt;span&gt; socket.getOutputStream();
                Request request &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Request(input);
                request.parse();
                Response response &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Response(output);
                response.setRequest(request);
                response.sendStaticResource();
                socket.close();
                shutdown &lt;/span&gt;=&lt;span&gt; request.getUri().equals(SHUTDOWN_COMMAND);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                e.printStackTrace();
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Request.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_1810850c-b40b-4c8c-bf50-49f5ced25928&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1810850c-b40b-4c8c-bf50-49f5ced25928&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1810850c-b40b-4c8c-bf50-49f5ced25928&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.wze.ex01.pyrmont;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Request {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; InputStream input;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String uri;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Request(InputStream input) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.input =&lt;span&gt; input;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; parse() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;之所以是大小是2048，是因为请求行的大小一般就是2048&lt;/span&gt;
        StringBuffer request = &lt;span&gt;new&lt;/span&gt; StringBuffer(2048&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[2048&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            i &lt;/span&gt;= input.read(buffer); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读入数据到buffer，并返回请求行的实际长度&lt;/span&gt;
        } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
            i &lt;/span&gt;= -1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; i; j++&lt;span&gt;) {
            request.append((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)buffer[j]);
        }
        System.out.println(request.toString());
        uri &lt;/span&gt;= parseUri(request.toString()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从请求行中把uri取出来&lt;/span&gt;
&lt;span&gt;        System.out.println(uri);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取请求行中的uri
     *
     * 请求行格式：Method URI Version
     * 用空格做分隔符
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; requestString
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String parseUri(String requestString) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index1, index2;
        index1 &lt;/span&gt;= requestString.indexOf(' '&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(index1 != -1&lt;span&gt;) {
            index2 &lt;/span&gt;= requestString.indexOf(' ', index1+1&lt;span&gt;);
            System.out.println(index1 &lt;/span&gt;+ &quot; &quot; +&lt;span&gt; index2);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(index2 &amp;gt;&lt;span&gt; index1)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; requestString.substring(index1 + 1&lt;span&gt;, index2);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUri() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; uri;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;Response.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_17927976-7773-4595-ad93-69136f7c0e60&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_17927976-7773-4595-ad93-69136f7c0e60&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_17927976-7773-4595-ad93-69136f7c0e60&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.wze.ex01.pyrmont;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStream;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Response {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BUFFER_SIZE = 1024&lt;span&gt;;
    Request request;
    OutputStream output;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Response(OutputStream output) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.output =&lt;span&gt; output;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRequest(Request request) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.request =&lt;span&gt; request;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sendStaticResource() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[BUFFER_SIZE];
        FileInputStream fis &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取用户请求文件的实际路径&lt;/span&gt;
            File file = &lt;span&gt;new&lt;/span&gt; File(HttpServer.WEB_ROOT +&lt;span&gt; request.getUri());
            System.out.println(file);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(file.exists()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果文件存在，则读取到缓冲数组，再利用socket的outputstream写出数据&lt;/span&gt;
                &lt;span&gt;long&lt;/span&gt; contentLength =&lt;span&gt; file.length();
                String successMessage &lt;/span&gt;= &quot;HTTP/1.1 200 success\r\n&quot; +
                        &quot;Content-Type:text/html\r\n&quot; +
                        &quot;Content-Length:&quot;+contentLength +&quot;\r\n&quot; +
                        &quot;\r\n&quot;&lt;span&gt;;
                output.write(successMessage.getBytes());
                fis &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(file);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次最多读写1024字节，直到全部读完&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; ch = fis.read(bytes, 0&lt;span&gt;, BUFFER_SIZE);
                System.out.println(ch);
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(ch != -1&lt;span&gt;) {
                    output.write(bytes, &lt;/span&gt;0&lt;span&gt;, ch);
                    ch &lt;/span&gt;= fis.read(bytes, 0&lt;span&gt;, BUFFER_SIZE);
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                String errorMessage &lt;/span&gt;= &quot;HTTP/1.1 404 File Not Found\r\n&quot; +
                        &quot;Content-Type:text/html\r\n&quot; +
                        &quot;Content-Length:23\r\n&quot; +
                        &quot;\r\n&quot; +
                        &quot;&amp;lt;h1&amp;gt;File Not Found&amp;lt;/h1&amp;gt;&quot;&lt;span&gt;;
                output.write(errorMessage.getBytes());
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            System.out.println(e.toString());
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(fis != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                fis.close();
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;运行效果&lt;/h2&gt;
&lt;p&gt;运行HttpServer的主方法，然后在浏览器地址栏键入localhost:8080/index.html，你就可以在浏览器看见网页内容了。到这一步就相当于实现了一个apache服务器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201902/1313132-20190207212520677-1901716819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：index.html是你自己创建的，你随便写点内容。我是只在body里面写了hello。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;代码解析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Request对象中缓冲大小为什么是2048？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为大多数浏览器请求行最大长度就是2048字节，所以读取2048字节，里面必然完全包含了请求行的数据。这也是parameter传参长度限制的原因，因为parameter在URI中，而URI又是组成请求行的元素之一。&lt;/p&gt;
&lt;p&gt;注：HTTP请求报文的请求行由三部分组成，请求方法，URI，协议版本，且这三个参数用空格隔开。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前面说的例子有问题在哪里？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的例子是正常的，不过书本里面少了一部分，那就是响应头的编写，如果没有发送响应头给浏览器，它无法识别发送给它的数据是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Content-Length在上文中起什么作用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;细心的朋友会发现，我在响应头中添加了Content-Length的头信息，指明了文件的长度，也就是字节数。有了这个头信息，浏览器就可以知道什么时候数据接收完成。这跟浏览器的加载提示有关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么让别人也能访问到这个网页？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的电脑有公网IP的话，那你要做的只是把程序跑起来挂着，然后开放端口。开放端口是什么意思？默认情况下，防火墙会为了安全，其他电脑是不能随便访问本机的端口（例外，80端口是默认开启的）。开启的方法就是进入防火墙设置进站规则，开放8080端口。&lt;/p&gt;
&lt;h2&gt;感悟&lt;/h2&gt;
&lt;p&gt;　　其实涉及到网络通信，底层传递的就是一堆字节，而&quot;&lt;strong&gt;协议&lt;/strong&gt;&quot;从一个角度来说，其实就是双方共同遵守的数据格式，它指明从哪里到哪里的字节数据表示的是什么，应用程序根据这些进行处理。想来，其实这些东西在上《计算机网络》的时候都讲到了，只是当时没有现在这种感觉吧。&lt;/p&gt;
</description>
<pubDate>Thu, 07 Feb 2019 13:55:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>前言 上一篇随笔【杂谈】一个回车下去，浏览器做了什么？讲了浏览器的处理，这里再用一个例子讲解一下，也不算讲解，算是梳理一下服务端处理浏览器请求的过程。当然实际过程要比这复杂多了。下文的例子，其实就是《</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/10355514.html</dc:identifier>
</item>
<item>
<title>线程概念简介 什么是线程 多线程上篇（七） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10354612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10354612.html</guid>
<description>&lt;p&gt;&lt;span&gt;试图用它来提高系统内程序并发执行的程度，从而可进一步提高系统的吞吐量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简言之，进程的概念，使之能够并发执行多道程序，线程的概念让你更好地并发执行程序，一个是能不能的问题，一个是更好的问题。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;线程与进程对比&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;线程概念的发展&lt;/span&gt;&lt;/h4&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207115055122-1624122855.png&quot;&gt;&lt;img title=&quot;image_5c5bab07_4fdf&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207115055589-964903690.png&quot; alt=&quot;image_5c5bab07_4fdf&quot; width=&quot;599&quot; height=&quot;234&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;进程概念提出的目的就是为了多道程序并发执行，并发过程中必然意味着不断地进程调度任务切换，但是他又是资源分配的独立单位，也就是说他要背着资源来回跑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;办公室内，每个人都有一台电脑，电脑就是资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后大家经常需要不断地变换座位位置（比如大家都是哪里需要去哪里，客服缺人了，销售就顶一个过去）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个人都抱着自己的电脑来回的换位置方便？还是大家只是人员走动，电脑就使用那个位置的电脑方便？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;进程也是有些类似的道理&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;你带着这么多资源来回切换调度，必然会带来更多的时&amp;amp;&amp;amp;空开销&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以创建了线程的概念&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;程序运行时所需的资源和程序的调度进行解耦&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程仍旧负责资源的独立分配，但是线程作为调度运行的独立单位，仅仅携带自身运行的必备的一丁点资源。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;对比&lt;/span&gt;&lt;/h4&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;线程具有许多传统进程所具有的特征，所以又称为轻型进程(Light-Weight Process)或进程元&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相应地把传统进程称为重型进程(Heavy-Weight Process)，传统进程相当于只有一个线程的任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在引入了线程的操作系统中，通常一个进程都拥有若干个线程，至少也有一个线程。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207115055836-1381517068.png&quot;&gt;&lt;img title=&quot;image_5c5bab07_3789&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207115056083-1643554322.png&quot; alt=&quot;image_5c5bab07_3789&quot; width=&quot;392&quot; height=&quot;169&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;并发性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;传统的OS系统，进程之间可以并发执行，引入线程概念的OS，不仅仅进程间可以并发执行，一个进程中的线程也可以并发执行，不同进程中的线程也可以并发执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;独立性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同一进程中的多个线程独立性比不同进程间的独立性差很多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个进程都是独立的地址空间和资源，同一进程下多线程他们共享进程下的资源，而且通常他们往往是用来相互合作的，每个线程都可以访问所在进程的所有地址空间，比如一个线程打开的文件，可以被其他线程读写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;调度性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;传统OS，进程作为资源分配和调度分派的基本单位，进程是可以独立运行的基本单位，不过进程调度切换时空开销大&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引入线程的OS，线程是运行调度和分派的基本单位，线程才是独立运行的基本单位，线程切换时，仅仅需要保存和设置少量寄存器内容，代价远远小于进程切换，不过需要注意是同一个进程内线程切换不会进程切换，但是不同进程中的线程进程切换，仍旧会导致进程切换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;拥有资源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程拥有资源，并且作为系统中拥有资源的独立基本单位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程自身不拥有系统资源，仅仅拥有一点必不可少的，独立运行需要的资源，比如线程中的TCB。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了自身的丁点儿资源外，共享所属进程的资源，同一个进程下所有线程，拥有相同的地址空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;多处理器支持&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;传统进程（或者说单线程进程）只能运行于一个处理机上，不管有多少个处理机；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是对于多线程进程，就可以将一个进程中的多个线程分配到多个处理机上，并行运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简言之，多线程可以让多核CPU充分发挥性能并行运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统开销&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程和线程的创建撤销，系统都要为止分配和回收资源，比如内存空间、IO设备等，进程和线程的上下文切换，系统也都需要付出一定的时空开销。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，线程相关的开销明显小于进程。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;线程简介&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;各线程之间也是存在资源共享和相互合作的，线程在运行时也是间断的，轮转切换的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程也是有运行状态的，这一点与进程并没有本质区别，最主要的状态也是就绪、执行、阻塞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程的控制核心信息保存在PCB中，线程也有对应的组成---TCB，所有用于控制和管理线程的信息都保存在TCB中&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207115056412-884835669.png&quot;&gt;&lt;img title=&quot;image_5c5bab07_4ef4&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207115056813-1467503596.png&quot; alt=&quot;image_5c5bab07_4ef4&quot; width=&quot;613&quot; height=&quot;328&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;线程尽管是另外一种完全不同的事物，但是毕竟是从进程的概念演化而来，也是操作系统对程序运行抽象的一部分，所以，线程必然与进程有着很多的相似点&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;线程实现&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;线程的实现主要有三种形式&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;内核支持&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用户级线程&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;另外就是二者的组合&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/897393/201902/897393-20190207203231676-260615211.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从上面的分析中可以看得出来，内核支持和用户级都有各自明显的缺点和优点。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;有些操作系统把用户级线程和内核支持线程两种方式进行组合，提供了组合方式ULT/KST 线程。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在组合方式线程系统中， 内核支持多KST线程的建立、调度和管理，同时，也允许用户应用程序建立、调度和管理用户级线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一些内核支持线程对应多个用户级线程，程序员可按应用需要和机器配置对内核支持线程数目进行调整，以达到较好的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;组合方式线程中，同一个进程内的多个线程可以同时在多处理器上并行执行，而且在阻塞一个线程时，并不需要将整个进程阻塞。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，组合方式多线程机制能够结合 KST和 ULT两者的优点，并克服了其各自的不足。 &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;线程的同步与通信&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关于进程的同步与通信的相关逻辑原理，对于进程的同步与通信绝大多数都是适用的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对于这些原理，多线程OS也提供了多种同步机制，如互斥锁、条件变量、计数信号量以及多读、单写锁等。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;信号量机制&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;进程中的信号量机制完全适合多线程同步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据用法分为两种&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;私用信号量(private samephore)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;公用信号量(public semaphort)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;系统运行中，有多个进程，进程中又有多个线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是为了同一进程中多个线程同步设置的信号量，&lt;span&gt;量属于特&lt;/span&gt;&lt;span&gt;定的进程所有，这就叫做私用，OS并不知道私用信号量的存在。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果是为了不同进程或者不同进程中的线程之间而设置的，就叫做公用。&lt;/span&gt;&lt;span&gt;其数据结构是存放在受&lt;/span&gt;&lt;span&gt;保护的系统存储区中，由OS为它分配空间并进行管理，故也称为系统信号量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;互斥锁(mutex)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;互斥锁是一种比较简单的、用于实现线程间对资源互斥访问的机制&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;互斥锁可以有两种状态&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;开锁(unlock)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;关锁(lock)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;当一个线程需要读/写一个共享数据段时，需要对mutex进行上锁，离开时需要解锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上锁时，首先校验 mutex 的状态，如果它已处于关锁状态，则试图访问该数据段的线程将被阻塞；如果 mutex处于开锁状态，则将 mutex 上锁后便去读/写该数据段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程完成操作后，必须将 mutex 解锁，同时还需要将阻塞在该互斥锁上的一个线程唤醒，其它的线程仍被阻塞在等待mutex打开的队列上。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;另外，为了减少线程被阻塞的机会，在有的系统中还提供了一种用于 mutex 上的操作命令 Trylock。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;顾名思义，并不会因为无法进入而阻塞，&lt;span&gt;若 mutex 处于上锁状态，则 Trylock 并不会&lt;/span&gt;&lt;span&gt;阻塞该线程，而只是返回一个指示操作失败的状态码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;条件变量&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在许多情况下，只利用 mutex 来实现互斥访问可能会引起死锁，比如A线程请求资源顺序为R1，R2，B线程请求资源顺序为R2，R1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果A对mutex 1上锁成功进入临界区后，需要获取R2的锁mutex 2，可是此时B获得了资源R2，对mutex 2已经上锁，此时，A等待mutex 2 B等待mutex 1，形成了死锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说，锁，应该是仅仅用于在条件成立时进行操作时的一个同步保障，而不能在整个过程中都依靠锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以借助于条件变量，就是条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每一个条件变量通常都与一个互斥锁一起使用，&lt;span&gt;单纯的互斥锁用于短期锁定，主要是用来保证对临界区的互斥进入。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;而条&lt;/span&gt;&lt;span&gt;件变量则用于线程的长期等待，直至所等待的资源成为可用的资源。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;申请&lt;/span&gt;&lt;/h4&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;Lock mutex                  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;while (条件状态不满足) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        wait(condition variable)；//释放锁，线程挂起等待，直到条件满足通知；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;临界区其他操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;unlock mutex; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;释放&lt;/span&gt;&lt;/h4&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;Lock mutex&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一些操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;unlock mutex；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wakeup(condition variable)；&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;简言之，借助于条件变量用于控制长时间的等待，锁用于控制对资源的同步。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;本文对线程进行了非常简单的介绍，线程之于进程在很多的方面有着极其类似的逻辑，尤其是从调度的视角看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;毕竟线程就是对进程中关于调度部分的独立抽象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要能够理解进程和线程的目的就能够很好地理解他们相似的原因，因为都是操作系统对于程序运行的抽象描述，线程是进程的更加细粒度的掌控。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在换句话说就是操作系统的角度对程序的执行抽象为：“资源的分配”“调度”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最初这两个概念都是加诸于进程这个概念上，后续为了更加高效将两个概念进行了拆分，就是这样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说，对于原先介绍的进程的相关概念中关于调度部分的绝大多数理论，都是适用于线程概念的&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 07 Feb 2019 12:35:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>线程的概念是操作系统对于程序运行的进一步划分，将资源分配与任务调度进一步细化，进而提升系统的性能，所以多线程本质的核心仍旧是并发（并行）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10354612.html</dc:identifier>
</item>
<item>
<title>RabbitMQ (十) 队列的参数详解 - 热敷哥</title>
<link>http://www.cnblogs.com/refuge/p/10354579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/refuge/p/10354579.html</guid>
<description>&lt;p&gt;代码中,我们通常这样声明一个队列:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明队列&lt;/span&gt;
&lt;span&gt;                    channel.QueueDeclare
                    (
                        queue: QueueName, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列名称&lt;/span&gt;
                        durable: &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列是否持久化.false:队列在内存中,服务器挂掉后,队列就没了;true:服务器重启后,队列将会重新生成.注意:只是队列持久化,不代表队列中的消息持久化!!!!&lt;/span&gt;
                        exclusive: &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列是否专属,专属的范围针对的是连接,也就是说,一个连接下面的多个信道是可见的.对于其他连接时不可见的.连接断开后,该队列会被删除.注意,不是信道断开,是连接断开.并且,就算设置成了持久化,也会删除.&lt;/span&gt;
                        autoDelete: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有消费者了,是否自动删除 &lt;span&gt;(感觉自己没操作对,这个参数一直没试验成功)&lt;/span&gt;&lt;/span&gt;
                        arguments: &lt;span&gt;null&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列的配置&lt;/span&gt;
                    );
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于第5个参数: &lt;span&gt;arguments&lt;/span&gt; ,&lt;/p&gt;
&lt;p&gt;它的类型是一个键值对集合 : &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207113744593-820180903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;它到底有哪些key呢?&lt;/p&gt;
&lt;p&gt;我们可以通过 RabbitMQ 的管理页面看到:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207111543065-298992455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一共10个,鼠标点击&quot;?&quot;,可以看到官方给出的解释.&lt;/p&gt;


&lt;p&gt;官方 : How long a message published to a queue can live before it is discarded (milliseconds). (Sets the &quot;x-message-ttl&quot; argument.) &lt;/p&gt;
&lt;p&gt;翻译 : 一个队列中的消息,在被丢弃之前能够存活多少毫秒.( key 为 &quot;x-message-ttl&quot;).通俗讲就是,队列中的消息的生存周期,单位毫秒.&lt;/p&gt;
&lt;p&gt;测试 :&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Dictionary&lt;/span&gt;&lt;span&gt;&amp;lt;string, object&amp;gt; arguments = new Dictionary&amp;lt;string, object&amp;gt; { &lt;span&gt;{ &quot;x-message-ttl&quot;, 10000&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; }&lt;/span&gt; };
            Producer.Send(arguments);
            Console.ReadKey();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Producer
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; QueueName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_queue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Send(IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; arguments)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IConnection connection =&lt;span&gt; ConnectionHelper.GetConnection())
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IModel channel =&lt;span&gt; connection.CreateModel())
            {
                channel.QueueDeclare(QueueName, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, arguments);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                channel.BasicPublish(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;, QueueName, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Encoding.Default.GetBytes(msg));
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now} : send {msg}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们从管理页面该队列的消息概述中可以看出,这条消息只存活了10秒钟.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207130235298-1596873067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为了加以对比,我还另外创建了一个没有声明任何参数的队列:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207130523734-1700361234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,测试的这条队列的特征(Features)一栏中,被打上了&quot;TTL&quot;标签.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里有个非常重要的知识点需要注意!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;队列一旦声明,参数将无法更改,添加,删除,也就是说,对上述&quot;test_queue&quot;队列进行如下操作都会抛出异常:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;0&quot;&gt;&lt;strong&gt;修改该队列的 &quot;x-message-ttl&quot; 参数为 &quot;20000&quot; 毫秒 : &lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; { { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-message-ttl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;20000&lt;/span&gt; } };
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;strong&gt;&lt;em&gt;&lt;em&gt;试图通过传入 null 来删除该队列的所有已设置的参数 : &lt;/em&gt;&lt;/em&gt;&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments = &lt;span&gt;null&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;&lt;strong&gt;试图添加新的参数 :&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
            Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; { { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-message-ttl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;&lt;span&gt; } };
            arguments.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-expires&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;12345&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;通通不行!!!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要改变一个队列的参数,只有两种办法:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;删除该队列,重新创建;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;换个名字,创建一个新的队列.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;官方 : How long a queue can be unused for before it is automatically deleted (milliseconds).(Sets the &quot;x-expires&quot; argument.) &lt;/p&gt;
&lt;p&gt;翻译 : 队列多长时间(毫秒)没有被使用(访问)就会被删除.换个说法就是,当队列在指定的时间内没有被使用(访问)就会被删除.&lt;/p&gt;
&lt;p&gt;测试 : &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
            {
                {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-message-ttl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;},&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列中的消息存活期为 10 秒&lt;/span&gt;
                &lt;span&gt;{ &quot;x-expires&quot;, 20000}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列的存活期 20 秒&lt;/span&gt;
&lt;span&gt;            };
            Producer.Send(arguments);
            Console.ReadKey();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到,队列特征一栏中,多了一个&quot;Exp&quot;标签&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207154937187-1156023801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然,10秒后,消息会被删除,20秒后,队列被删除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是,如果我们同时创建一个消费者,监听该队列,如下:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; QueueName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_queue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Receive()
        {
            IConnection connection &lt;/span&gt;=&lt;span&gt; ConnectionHelper.GetConnection();
            IModel channel &lt;/span&gt;=&lt;span&gt; connection.CreateModel();
&lt;span&gt;            EventingBasicConsumer consumer &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new EventingBasicConsumer(channel);
            consumer.Received += (s, e) =&amp;gt;
            {
                byte[] bytes = e.Body;
                string str = Encoding.Default.GetString(bytes);
                Console.WriteLine(&quot;consumer receive : &quot; +&lt;/span&gt;&lt;span&gt;&lt;span&gt; str);
            };&lt;/span&gt;
            channel.BasicConsume(QueueName, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, consumer);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
            {
                {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-message-ttl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;},&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列中的消息存活期为 10 秒&lt;/span&gt;
                &lt;span&gt;{ &quot;x-expires&quot;, 20000}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列的存活期 20 秒&lt;/span&gt;
&lt;span&gt;            };
            Producer.Send(arguments);
            &lt;span&gt;Consumer.Receive();&lt;/span&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个消费者监听该队列&lt;/span&gt;
&lt;span&gt;            Console.ReadKey();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;那该队列永远不会被删除.因为虽然它里面没有消息,但一直有消费者在使用(访问)它,所以它不会被删除.&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;官方 : How many (ready) messages a queue can contain before it starts to drop them from its head.(Sets the &quot;x-max-length&quot; argument.) &lt;/p&gt;
&lt;p&gt;翻译 : 队列可以容纳的消息的最大&lt;span&gt;条数&lt;/span&gt;,超过这个条数,队列头部的消息将会被丢弃.&lt;/p&gt;
&lt;p&gt;测试 : 我们设置队列最多只能容纳 1 条消息,然后一次性发送10条,发送完毕后,创建一个消费者去消费,部分代码如下:&lt;/p&gt;
&lt;h3&gt;生产者&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i;
                    channel.BasicPublish(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;, QueueName, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Encoding.Default.GetBytes(msg));
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now} : send {msg}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
            {
                {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-message-ttl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;},&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列中的消息存活期为 10 秒&lt;/span&gt;
                { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-expires&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;20000&lt;/span&gt;},&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列的存活期 20 秒&lt;/span&gt;
                &lt;span&gt;{&quot;x-max-length&quot;,1 }&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列中的消息的最大条数为 1 条,超过1条,则遵循队列的&quot;先进先出(丢)&quot;原则.&lt;/span&gt;
&lt;span&gt;            };
            Producer.Send(arguments);
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
            Consumer.Receive();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个消费者监听该队列&lt;/span&gt;
&lt;span&gt;            Console.ReadKey();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207140220824-183717459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到,消费者消费到的是&quot;hello world 9&quot;, &quot;hello world 0&quot; - &quot;hello world 8&quot;都被队列丢弃了.&lt;/p&gt;
&lt;p&gt;标签如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207140347921-2009374923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;官方 : Total body size for ready messages a queue can contain before it starts to drop them from its head.(Sets the &quot;x-max-length-bytes&quot; argument.) &lt;/p&gt;
&lt;p&gt;翻译 : 队列可以容纳的消息的最大&lt;span&gt;字节数&lt;/span&gt;,超过这个字节数,队列头部的消息将会被丢弃.&lt;/p&gt;
&lt;p&gt;测试 : 我们首先设置队列最多只能容纳12个字节.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
            Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
            {
                {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-message-ttl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;},&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列中的消息存活期为 10 秒&lt;/span&gt;
                { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-expires&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;20000&lt;/span&gt;},&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列的存活期 20 秒&lt;/span&gt;
                &lt;span&gt;{&quot;x-max-length-bytes&quot;,12 }&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列中的消息的最大字节数&lt;/span&gt;
            };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来要分两种情况了:&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;一&lt;/span&gt;.发送一条 15个字节的消息&lt;/span&gt;:&quot;新年快乐啊&quot;(我们采用UTF8编码,1个汉字占3个字节),发送完毕后,创建一个消费者去消费.(当然,消费者也要用UTF8来接收)&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;string&lt;/span&gt; msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新年快乐啊&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                channel.BasicPublish(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;, QueueName, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Encoding.&lt;span&gt;UTF8&lt;/span&gt;.GetBytes(msg));
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now} : send {msg}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207141932531-1482010933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到,消费者并没有收到消息.说明整条消息都被丢弃了,而不是想象中的只丢弃&quot;新年快乐&quot; ,剩个&quot;啊&quot;.&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;二&lt;/span&gt;.连续发送2条累计15个字节的消息. &lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
                channel.BasicPublish(&lt;span&gt;&quot;&quot;&lt;/span&gt;, QueueName, &lt;span&gt;null&lt;/span&gt;, Encoding.UTF8.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新年快乐&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                channel.BasicPublish(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;, QueueName, &lt;span&gt;null&lt;/span&gt;, Encoding.UTF8.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;啊&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now} : 消息发送完毕 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207142313395-692827175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到, 消费者收到了&quot;啊&quot;.&lt;/p&gt;
&lt;p&gt;队列标签如下 :&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207142414957-2114630901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;官方 : Sets the queue overflow behaviour. This determines what happens to messages when the maximum length of a queue is reached. Valid values are &lt;code&gt;drop-head&lt;/code&gt; or &lt;code&gt;reject-publish&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;翻译 : 队列中的消息溢出时,如何处理这些消息.要么丢弃队列头部的消息,要么拒绝接收后面生产者发送过来的所有消息.( 从上面两个参数的测试中可以看出,&quot;drop-head&quot; 应该是默认行为) ,官方只给了 value,没给 key . key 为 &quot;x-overflow&quot;.&lt;/p&gt;
&lt;p&gt;测试 : 沿用  Max length 参数解释中的示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
            {&lt;/span&gt;
                {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-max-length&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt; },&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列中的消息的最大条数为 1 条,超过1条,则遵循队列的&quot;先进先出(丢)&quot;原则.         &lt;/span&gt;
                &lt;span&gt;{&quot;x-overflow&quot;,&quot;reject-publish&quot; },&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列中的消息溢出后,该队列的行为:&quot;拒绝接收&quot;(所有消息)&lt;/span&gt;
&lt;span&gt;            };
            Producer.Send(arguments);
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
            Consumer.Receive();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个消费者监听该队列&lt;/span&gt;
&lt;span&gt;            Console.ReadKey();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207144214503-1248563377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到,这次消费者消费的是&quot; hello world 0&quot; ,不再是 &quot;hello world 9&quot; 了,因为生产者发送的&quot;hello world 1&quot; - &quot;hello world 9&quot;被队列拒绝了.&lt;/p&gt;
&lt;p&gt;标签如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207144304933-867180101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;官方 : Optional name of an exchange to which messages will be republished if they are &lt;span&gt;rejected&lt;/span&gt; or expire.(Sets the &quot;x-dead-letter-exchange&quot; argument.) &lt;/p&gt;
&lt;p&gt;翻译 : 该参数值为一个(死信)交换机的名称,当队列中的消息的生存期到了,或者因长度限制&lt;span&gt;被丢弃&lt;/span&gt;时,消息会被推送到(&lt;span&gt;绑定到&lt;/span&gt;)这台交换机(&lt;span&gt;的队列中&lt;/span&gt;),而不是直接丢掉. &lt;/p&gt;
&lt;p&gt;对于这个参数,有两点需要特别注意:&lt;/p&gt;
&lt;h2&gt;一.前面的文章中提到过:&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207155606704-698967655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以,在测试前,我们需要创建一个队列,并绑定到该交换机.当然,交换机也需要提前创建好.&lt;/p&gt;
&lt;p&gt;为了方便,我们在管理页面创建交换机和队列,并完成&quot;绑定&quot;动作.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;创建交换机&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1.先选择&quot;Exchanges&quot;标签&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207155942043-786883625.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;2.点击&quot;Add a new exchange&quot;标签.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207160028429-475397068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里又要注意了,交换机类型我们要选择&quot;fanout&quot;模式.这种模式下,交换机会将生产者发送的消息分发到所有绑定到它的队列.细心的朋友应该能看出来为什么.&lt;/p&gt;
&lt;p&gt;因为这个参数只是传入了交换机的名称,没有传入&quot;Routing Key&quot;.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;创建队列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;创建一个新队列 : &quot;test_dead_letter_queue&quot; ,图就不上了,开篇就已经提到了.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;绑定交换机&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;有两种方式:&lt;/p&gt;
&lt;p&gt;1.在交换机详情页面输入要绑定的队列.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207161126589-1019995080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.在队列详情页面输入要绑定的交换机.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207161141679-1257382021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上述工作都完成后,我们开始正式测试该参数.&lt;/p&gt;
&lt;p&gt;我们设置队列可以容纳的消息最多1条,多的拒绝接收.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
            {&lt;/span&gt;
                {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-max-length&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt; },&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列中的消息的最大条数为 1 条,超过1条,则遵循队列的&quot;先进先出(丢)&quot;原则.&lt;/span&gt;&lt;span&gt;&lt;span&gt;
                {&quot;x-overflow&quot;,&quot;reject-publish&quot; },&lt;/span&gt;&lt;span&gt;//设置队列中的消息溢出后,队列的行为:&quot;拒绝接收&quot;(任何消息)&lt;/span&gt;&lt;/span&gt;
                &lt;span&gt;{&quot;x-dead-letter-exchange&quot;,&quot;test_dead_letter_exchange&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt; }&lt;/span&gt;,&lt;/span&gt;
&lt;span&gt;            };
            Producer.Send(arguments);
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
            Consumer.Receive();&lt;/span&gt;
&lt;span&gt;            Console.ReadKey();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;生产者的代码我们沿用 Max length 参数解释中的代码.&lt;/p&gt;
&lt;p&gt;运行后,我们去看后台.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207161625555-457986740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咦!?&quot;test_dead_letter_queue&quot;队列怎么一条消息都没有呢?&lt;/p&gt;
&lt;p&gt;为什么交换机没有把 &quot;test_queue&quot; 丢弃的9条消息推送到该队列呢?&lt;/p&gt;
&lt;p&gt;这是什么情况?&lt;/p&gt;
&lt;p&gt;这就是这个参数第2个需要注意的点了.&lt;/p&gt;
&lt;h2&gt;二.我们再读一次官方对该参数的解释:&lt;/h2&gt;
&lt;p&gt;Optional name of an exchange to which messages will be republished if they are &lt;span&gt;rejected &lt;/span&gt;or expire.&lt;/p&gt;
&lt;p&gt;个人觉得,官方这里用 &lt;span&gt;rejected&lt;/span&gt; 不是太准确,当然,也可能是我理解得还不够深入,再加上英语太差.&lt;/p&gt;
&lt;p&gt;为什么这么说呢?&lt;/p&gt;
&lt;p&gt;我最开始的理解是 : 被&lt;span&gt;拒绝&lt;span&gt;或&lt;/span&gt;&lt;/span&gt;到期的消息会被推送到新的交换机,所以我在参数中传入了  {&quot;x-overflow&quot;,&quot;reject-publish&quot; } &lt;/p&gt;
&lt;p&gt;我认为队列拒绝的这9条消息,就应该被交换机推送到绑定到它的队列去!&lt;/p&gt;
&lt;p&gt;实际上,官方用词 &quot;&lt;span&gt;rejected&lt;/span&gt;&quot; 应该被翻译成 : &lt;span&gt;&quot;丢弃&quot;或者&quot;抛弃&quot;,&lt;span&gt;而不是&quot;&lt;span&gt;拒绝&lt;/span&gt;&quot;,也就是说,这里的 rejected 和 expire 是队列里面的消息的状态.而不是队列的动作.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当我们注释掉 {&quot;x-overflow&quot;,&quot;reject-publish&quot; } ,改用默认的  &quot;drop-head&quot; 行为时,运行一切正常:&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207162843730-1932721235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;关于到期( expire )的测试,这里就不上图了.&lt;/p&gt;
&lt;p&gt;这个参数的标签是 : DLX&lt;/p&gt;



&lt;p&gt;官方 : Optional replacement routing key to use when a message is dead-lettered. If this is not set, the message's original routing key will be used.(Sets the &quot;x-dead-letter-routing-key&quot; argument.) &lt;/p&gt;
&lt;p&gt;翻译 : 略......&lt;/p&gt;
&lt;p&gt;测试 : &lt;/p&gt;
&lt;p&gt;我们先删除上述 &quot;Dead letter exchange&quot; 参数解释中创建的交换机及队列.&lt;/p&gt;
&lt;p&gt;然后重新创建交换机 &quot;test_dead_letter_exchange&quot;,并将其类型设置为&quot;direct&quot;.(很多帖子叫它&quot;直连模式&quot;或者&quot;路由模式&quot;,叫&quot;topic&quot;为&quot;主题模式&quot;,但我更新喜欢叫&quot;direct&quot;为&quot;精确匹配模式&quot;,叫&quot;topic&quot;为&quot;模糊匹配模式&quot;,感觉好理解一些)&lt;/p&gt;
&lt;p&gt;接着重新创建两个队列 &quot;test_dead_letter_queue1&quot; 和 &quot;test_dead_letter_queue2&quot;,并将它们绑定到新的交换机.绑定的时候,将队列&quot;test_dead_letter_queue1&quot;的路由键设置为&quot;test&quot;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207171646181-855222920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
            {&lt;/span&gt;
                {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-max-length&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt; },&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置队列中的消息的最大条数为 1 条,超过1条,则遵循队列的&quot;先进先出(丢)&quot;原则.&lt;/span&gt;
                {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-dead-letter-exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_dead_letter_exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                &lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;x-dead-letter-routing-key&quot;,&quot;test&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt; },&lt;/span&gt;
            };
            Producer.Send(arguments);&lt;/span&gt;
&lt;span&gt;            Console.ReadKey();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果及标签:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207172157316-1397342960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;官方 : Maximum number of priority levels for the queue to support; if not set, the queue will not support message priorities.(Sets the &quot;x-max-priority&quot; argument.) &lt;/p&gt;
&lt;p&gt;翻译 : 设置该队列中的消息的优先级最大值.发布消息的时候,可以指定消息的优先级,优先级高的先被消费.如果没有设置该参数,那么该队列不支持消息优先级功能.也就是说,就算发布消息的时候传入了优先级的值,也不会起什么作用.&lt;/p&gt;
&lt;p&gt;测试 : &lt;/p&gt;
&lt;h3&gt;生产者&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Producer
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; QueueName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_queue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Send(IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; arguments)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造消息的属性&lt;/span&gt;
           &lt;span&gt; RabbitMQ.Client.Framing.BasicProperties pros = new RabbitMQ.Client.Framing.BasicProperties();

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IConnection connection =&lt;span&gt; ConnectionHelper.GetConnection())
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IModel channel =&lt;span&gt; connection.CreateModel())
            {
                channel.QueueDeclare(QueueName, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, arguments);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;byte &lt;/span&gt;i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i;
                   &lt;span&gt; pros.Priority &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; i;&lt;/span&gt;
                    channel.BasicPublish(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;, QueueName, &lt;span&gt;pros&lt;/span&gt;, Encoding.Default.GetBytes(msg));
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now} : send {msg}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码表明,&quot;hello world 0-9&quot; 的优先级为 9 - 0.&lt;/p&gt;
&lt;p&gt;需要注意的是,优先级属性的类型为 byte.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
            {&lt;/span&gt;
                &lt;span&gt;{&quot;x-max-priority&quot;,255&lt;/span&gt;&lt;span&gt;&lt;span&gt; },&lt;/span&gt;
            };
            Producer.Send(arguments);
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
            Consumer.Receive();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个消费者监听该队列&lt;/span&gt;
&lt;span&gt;            Console.ReadKey();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207174342248-1124476133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;问题又来了,如果声明队列时,优先级最大值设置的是 5 ,那么这10条消息的消费顺序应该是怎样的呢?我们直接看结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207174534965-33088683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个有点意思......&lt;/p&gt;
&lt;p&gt;该参数的标签为 : Pri&lt;/p&gt;



&lt;p&gt;官方 : Set the queue into lazy mode, keeping as many messages as possible on disk to reduce RAM usage; if not set, the queue will keep an in-memory cache to deliver messages as fast as possible.(Sets the &quot;x-queue-mode&quot; argument.) &lt;/p&gt;
&lt;p&gt;翻译 : 设置队列为懒人模式.该模式下的队列会先将交换机推送过来的消息(尽可能多的)保存在磁盘上,以减少内存的占用.当消费者开始消费的时候才加载到内存中;如果没有设置懒人模式,队列则会直接利用内存缓存,以最快的速度传递消息.&lt;/p&gt;
&lt;p&gt;测试 : 使用简单队列公平分发测试.&lt;/p&gt;
&lt;h3&gt;生产者&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Producer
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; QueueName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_queue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Send(IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; arguments)
        {&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (IConnection connection =&lt;span&gt; ConnectionHelper.GetConnection())
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IModel channel =&lt;span&gt; connection.CreateModel())
            {
                channel.QueueDeclare(QueueName, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, arguments);
                channel.BasicQos(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;byte&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i;&lt;/span&gt;
                    channel.BasicPublish(&lt;span&gt;&quot;&quot;&lt;/span&gt;, QueueName, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Encoding.Default.GetBytes(msg));
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now} : send {msg}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }&lt;/span&gt;
&lt;span&gt;            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;消费者&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; QueueName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_queue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Receive()
        {
            IConnection connection &lt;/span&gt;=&lt;span&gt; ConnectionHelper.GetConnection();
            IModel channel &lt;/span&gt;=&lt;span&gt; connection.CreateModel();
            EventingBasicConsumer consumer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventingBasicConsumer(channel);
            consumer.Received &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes =&lt;span&gt; e.Body;
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str =&lt;span&gt; Encoding.Default.GetString(bytes);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;consumer receive : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str);
                channel.BasicAck(e.DeliveryTag, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);&lt;span&gt;//5秒确认一条消息&lt;/span&gt;
            };&lt;/span&gt;
            channel.BasicConsume(QueueName, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, consumer);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;控制台&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; arguments = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
            {&lt;/span&gt;
                &lt;span&gt;{&quot;x-queue-mode&quot;,&quot;lazy&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt; },&lt;/span&gt;
            };
            Producer.Send(arguments);
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);
            Consumer.Receive();&lt;/span&gt;&lt;span&gt;//生产者消息发送完毕10秒后再创建消费者&lt;/span&gt;
&lt;span&gt;            Console.ReadKey();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;当10条消息发送完毕后,我们看管理后台的队列详情:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207194633775-141354325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以非常清楚看到,内存中是没有任何消息的.总数和已准备都是130B.&lt;/p&gt;
&lt;p&gt;130B怎么来的? &quot;hello world 0&quot; 一共13个字节,一共10条,13*10=130.&lt;/p&gt;
&lt;p&gt;10秒后,消费者创建,并开始消费.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190207195054082-901017656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参数的标签为 : Args (这个标签有点特别...)&lt;/p&gt;
&lt;p&gt;其实关于懒人模式和默认模式还有很多细节,各自的优缺点等.比如上面的例子,我故意让生产者一次性发了10条消息到队列,并且队列每次只传递一条到消费者,但是消费者开始消费的时候,队列就一次性把10条消息都读取到了内存.&lt;/p&gt;
&lt;p&gt;再比如,持久化的消息与非持久化的消息,结合懒人模式等等.&lt;/p&gt;
&lt;p&gt;还有默认模式和懒人模式的效率,性能比较等.&lt;/p&gt;
&lt;p&gt;估计需要单独写个帖子了.&lt;/p&gt;


&lt;p&gt;终于写到最后一个参数了&lt;/p&gt;

&lt;p&gt;官方 : Set the queue into master location mode, determining the rule by which the queue master is located when declared on a cluster of nodes.(Sets the &quot;x-queue-master-locator&quot; argument.) &lt;/p&gt;
&lt;p&gt;集群相关设置,暂时放一边去!&lt;/p&gt;

</description>
<pubDate>Thu, 07 Feb 2019 12:14:00 +0000</pubDate>
<dc:creator>热敷哥</dc:creator>
<og:description>代码中,我们通常这样声明一个队列: 对于第5个参数: arguments , 它的类型是一个键值对集合 : 它到底有哪些key呢? 我们可以通过 RabbitMQ 的管理页面看到: 一共10个,鼠标点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/refuge/p/10354579.html</dc:identifier>
</item>
<item>
<title>你那么喜欢看”干货“，是因为你根本不想下功夫。 - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/10355396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/10355396.html</guid>
<description>&lt;p&gt;　　&lt;img id=&quot;currentImg&quot; class=&quot;currentImg&quot; title=&quot;点击查看源网页&quot; src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1549550182692&amp;amp;di=67a1a6f33492316685d9a0bde1c0f70e&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fi0.hdslb.com%2Fbfs%2Farticle%2F688c683c90ed9d6e7f949aa4936204770d614d13.png&quot; alt=&quot;&quot; width=&quot;1051.0623441397&quot; height=&quot;682&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有位博友问我，能不能分享一些关于XXX技术或者经验。我特别害怕被问到这样的问题，因为我并不是一个喜欢总结方法论的人。我只能这么给你说，要不断的写，写博客特别勤苦野特别需要勤奋！很多常人看不见的努力你必须下的到。但这样的说法不会让人满意，总觉得我在保留自己的技巧。害怕让别人超过自己而回答的模棱两可。&lt;/p&gt;
&lt;p&gt;　　可事实上来说，我认识的博友是什么样的呢，他们白天上班，晚上写博客也是经常的事。在地铁上或回家的路上用手机写。回来用笔记本写。不断的看书，疯狂的学习。他们没有多少人看什么干货或者技巧。就是疯狂的学习。我的好朋友他就说过一句话：”我独自一人在北京，无亲无故，身无所长，唯一擅长的就是喜欢分享，看过很多技术的书，键入过很多文字与代码。把所有不安和失业的痛苦放在博客里“。他说他活到了自己想要的样子。&lt;/p&gt;
&lt;p&gt;　　很多人想要所谓的干货，也就是总结出来的1234，但如果这个世界的成功都是通过1234，那么还有你什么事？&lt;/p&gt;
&lt;p&gt;　　你那么喜欢看”干货“，是因为你根本不想下功夫。&lt;/p&gt;
&lt;p&gt;　　你想要的成功，无非是急功近利一夜成名，但凡不能让你速成的内容，你都会不满意，我不知道我说的对不对，反正我原来就是这样，导致我现在。。。&lt;/p&gt;
&lt;p&gt;　　你看不起励志名言，其实是因为你就算被打了鸡血，依然对眼下的事情一头雾水，但却完全不想自己研究寻找。&lt;/p&gt;
&lt;p&gt;　　大部分人空有一颗想成功的心，但没有助自己走向成功的自律。曾有一个朋友说自己在招助理，很多人报名，每个人都把自己说得特别有干劲，特别吃苦耐劳，都指望着跟着大咖共同致富。但每次做点什么事情，不是说自己今天太累了做不完了，就是这么晚了现在要睡觉了，或者不会做找不到了直接推回给领导，不到一个礼拜，朋友就崩溃的问我现在招人怎么这么难，大家是不是都不缺钱？这位朋友一个月大概能赚几十万，大概很多人来靠近他只是想看看有什么机会让自己也变富有，结果发现没什么速成法则，还累得够呛吧。&lt;/p&gt;
&lt;p&gt;　　你太像从别人的成功案例中找到一些能够让自己成功的捷径，是因为你从来看不到别人的成功都是经过无数次的煎熬和失败，并从中猝练的最终结果，你看到只是光芒四射的那一刻，而背后熬过的勤劳是你不想让自己走的。&lt;/p&gt;
&lt;p&gt;　　有一位大佬给我说，他在网上开了一个.NET技术课程，一共几节课，上完课之后就有几个人找他退费，理由就是没有干货。我这位朋友在这方面还是非常成功也很资深，一个成功的人，绝对不是因为所谓的1234几句话就能达到了，很多人认为，我来听你的课。就是为了干货，你不能让我立地成佛，立刻成功，那就是没用！都是扯淡！&lt;/p&gt;
&lt;p&gt;　　现在还有很多标题党的文章，也就是所谓的干货，比如说”三分钟学会熔断降级“，当然这事我也干过。我周围也有很多像我这样的人，用上班后的时间写个博客，为了提高访问量，就写了标题和内容不符合的随笔。其实这些文章根本就没有一些实际有用的内容，最主要的就是听过他们的简单分享，能够让读者知道他们”坚持‘下来了&lt;/p&gt;
&lt;p&gt;　　看过这样的一句话，大意就是，一个人的成功都是建立在让自己痛苦和煎熬的自律之上。大部分人有着成功的心，但是没有自律，其实学习就是依靠着惯性还有自律，这非常的简单，拥有了强大的惯性，你如果想停都停不下来，不信你可以每天刷3次牙，然后坚持28天试一试，我相信你会有个大白牙停不下来的。&lt;/p&gt;
&lt;p&gt;　　说白了，成功的方法很简单，不是因为1234的干货和秘籍，只有坚持努力，努力坚持，当然大部分人是无法让自己到这种程度的苦功的，所有大部分的人都在追求干货和捷径的路上，少部分人已经越来越快的奔向成功了。你看的越多，越追不上。&lt;/p&gt;
</description>
<pubDate>Thu, 07 Feb 2019 11:54:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>有位博友问我，能不能分享一些关于XXX技术或者经验。我特别害怕被问到这样的问题，因为我并不是一个喜欢总结方法论的人。我只能这么给你说，要不断的写，写博客特别勤苦野特别需要勤奋！很多常人看不见的努力你必</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/10355396.html</dc:identifier>
</item>
<item>
<title>（原创）不过如此的 DFS 深度优先遍历 - compassion‘s</title>
<link>http://www.cnblogs.com/yx1999/p/10354950.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yx1999/p/10354950.html</guid>
<description>&lt;p&gt;&lt;span&gt;DFS算法用于遍历图结构，旨在遍历每一个结点，顾名思义，这种方法把遍历的重点放在深度上，什么意思呢？就是在访问过的结点做标记的前提下，一条路走到天黑，我们都知道当每一个结点都有很多分支，那么我们的小人就沿着每一个结点走，定一个标准，比如优先走右手边的路，然后在到达下一个结点前先敲敲门，当一个结点的所有门都被敲了个遍都标记过，那么就走回头路，再重复敲门，直到返回起点，这样的方式我们叫做 DFS 深度优先遍历，本文以图结构讲解，例子取自《大话数据结构》。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598426/201902/1598426-20190207151849555-1965480989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如我刚才所讲，从A点出发，将路径画出来就是以下效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1598426/201902/1598426-20190207151945066-873398939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实线是走过的路程，虚线就是我们的小人敲门然后发现标记过的一个过程，大家可以寄几模拟一哈。一句话总结就是：&lt;/p&gt;
&lt;h2&gt;从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发 深度优先遍历图结构，直至图中所有和 v 有路径相通的顶点都被访问到。&lt;/h2&gt;
&lt;p&gt;结构定义代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;char&lt;/span&gt;&lt;span&gt; VertexType;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; EdgeType;

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; MAXVEX 10
&lt;span&gt;#define&lt;/span&gt; INFINITY 65535&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; boolean;
boolean visited[MAXVEX];

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt;
{
    VertexType vexs[MAXVEX];
    EdgeType arc[MAXVEX][MAXVEX];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; numVertexes,numEdges;
}MGraph;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;邻接矩阵创建：&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; CreateMGraph(MGraph *&lt;span&gt;G)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j,k;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入顶点数和边数（空格隔开）\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;G-&amp;gt;numVertexes,&amp;amp;G-&amp;gt;&lt;span&gt;numEdges);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请依次输入每个顶点的内容：\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;;i &amp;lt; G-&amp;gt;numVertexes;i++&lt;span&gt;)
    {
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;G-&amp;gt;&lt;span&gt;vexs[i]);
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;;i &amp;lt; G-&amp;gt;numVertexes;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j = &lt;span&gt;0&lt;/span&gt;;j &amp;lt; G-&amp;gt;numVertexes;j++&lt;span&gt;)
        {
            G&lt;/span&gt;-&amp;gt;arc[i][j] =&lt;span&gt; INFINITY;
        }
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(k = &lt;span&gt;0&lt;/span&gt;;k &amp;lt; G-&amp;gt;numEdges;k++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入边（vi,vj）上的下标i，下标j：\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;i,&amp;amp;&lt;span&gt;j);
        G&lt;/span&gt;-&amp;gt;arc[i][j] = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        G&lt;/span&gt;-&amp;gt;arc[j][i] = G-&amp;gt;&lt;span&gt;arc[i][j];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;DFS算法&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; DFS(MGraph G,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) //深度优先递归算法
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;
    visited[i] &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,G.vexs[i]);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j = &lt;span&gt;0&lt;/span&gt;;j &amp;lt; G.numVertexes;j++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(G.arc[i][j] == &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;visited[j])
            DFS(G,j);
    }
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; DFStraverse(MGraph G)  //深度遍历
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;;i &amp;lt; G.numVertexes;i++&lt;span&gt;)
    visited[i] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;;i &amp;lt; G.numVertexes;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;visited[i])
            DFS(G,i);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;这种方法比较好理解在于使用循环进入函数再递归，可以保证以邻接矩阵为储存单位的每一个格子都被遍历到，且做好标注，那么用邻接矩阵的DFS算法时间复杂度可以想见是 O（n²），嵌套两重循环，&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;我们来看下一种实现方式，这次我们使用的是邻接单链表&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;结构定义：&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;int&lt;/span&gt;&lt;span&gt; boolean;
boolean visited[MAXVEX];

typedef &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; VertexType;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; EdgeType;

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; MAXVEX 10
&lt;span&gt;#define&lt;/span&gt; INFINITY 65535&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; EdgeNode //边表结构点
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; adjvex;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; EdgeNode *&lt;span&gt;next;
}EdgeNode;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; VertexNode //顶点表结构点
{
    VertexType data;
    EdgeNode &lt;/span&gt;*&lt;span&gt;firstedge;
}VertexNode,AdjList[MAXVEX];

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; //总表结构
{
    AdjList adjList;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; numVertexes,numEdges;
}GraphAdjList;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;比邻接矩阵复杂一点，但是其结构只有三种，总表、定点表和边表&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;创建：&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; CreateALGraph(GraphAdjList *&lt;span&gt;G)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j,k;
    EdgeNode &lt;/span&gt;*&lt;span&gt;e;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入顶点数和边数（空格隔开）\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;G-&amp;gt;numVertexes,&amp;amp;G-&amp;gt;&lt;span&gt;numEdges);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;;i &amp;lt; G-&amp;gt;numVertexes;i++&lt;span&gt;)
    {
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;G-&amp;gt;&lt;span&gt;adjList[i].data);
        G&lt;/span&gt;-&amp;gt;adjList[i].firstedge =&lt;span&gt; NULL;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(k = &lt;span&gt;0&lt;/span&gt;;k &amp;lt; G-&amp;gt;numVertexes;k++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入边（vi,vj）上的下标i，下标j：\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;i,&amp;amp;&lt;span&gt;j);
        e &lt;/span&gt;= (EdgeNode*)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(EdgeNode));
        e&lt;/span&gt;-&amp;gt;adjvex=&lt;span&gt;i;
        e&lt;/span&gt;-&amp;gt;next =&lt;span&gt; adjList[j].firstedge;
        adjList[j].firstedge &lt;/span&gt;=&lt;span&gt; e;
        
        e &lt;/span&gt;= (EdgeNode*)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(EdgeNode));
        e&lt;/span&gt;-&amp;gt;adjvex=&lt;span&gt;j;
        e&lt;/span&gt;-&amp;gt;next =&lt;span&gt; adjList[i].firstedge;
        adjList[i].firstedge &lt;/span&gt;=&lt;span&gt; e;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;DFS算法实现：&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; DFS(GraphAdjList GL,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i)
{
    EdgeNode &lt;/span&gt;*&lt;span&gt;p;
    visited[i] &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,GL-&amp;gt;&lt;span&gt;adjList[i].data);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(p)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!visited[p-&amp;gt;&lt;span&gt;adjvex])
            DFS(GL,p&lt;/span&gt;-&amp;gt;&lt;span&gt;adjvex);
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; DFStraverse(GraphAdjList GL)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;;i &amp;lt; GL-&amp;gt;numVertexes;i++&lt;span&gt;)
    visited[i] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;;i &amp;lt; GL-&amp;gt;numVertexes;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;visited[i])
            DFS(GL,i);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;利用邻接表的方式能够实现相同效果的遍历，同时这种方法的算法时间复杂度为 O（n+e）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Feb 2019 08:59:00 +0000</pubDate>
<dc:creator>compassion‘s</dc:creator>
<og:description>数据结构 DFS 深度优先算法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yx1999/p/10354950.html</dc:identifier>
</item>
</channel>
</rss>