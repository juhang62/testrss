<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>堆和优先队列 - Java伴我余生</title>
<link>http://www.cnblogs.com/reminis/p/12633099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reminis/p/12633099.html</guid>
<description>&lt;h3 id=&quot;什么是优先队列？&quot;&gt;什么是优先队列？&lt;/h3&gt;
&lt;p&gt;  我们在&lt;a href=&quot;https://www.cnblogs.com/reminis/p/12586248.html&quot; target=&quot;_blank&quot;&gt;常见的线性结构&lt;/a&gt;中,已经知道什么是普通队列了，普通队列就是一种“先进先出，后进后出”的数据结构，即普通队列的出队顺序和入队顺序是一样的，但我们的优先队列，它的出队顺序和入队顺序无关，它的出队顺序是和优先级相关的，当然这个优先级我们可以自己定义。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么使用优先队列？&quot;&gt;为什么使用优先队列？&lt;/h3&gt;
&lt;p&gt;  举一个生活中的例子，就是医院里需要做手术的病人，医院不会根据哪个病人先来就先送去手术室，而是会根据病人生命危险的程度来决定应该谁先进入手术室。再说一个计算机中的例子，例如在操作系统中，进行任务的调度，在我们现在的操作系统中，会同时执行多个任务，操作系统需要为这个多个任务分配计算机资源，包括分配CPU时间片，具体去分配资源的时候，操作系统就要看各个任务的优先级，去&lt;span&gt;动态的选择优先级最高的任务执行&lt;/span&gt;。注意&lt;span&gt;动态&lt;/span&gt;这个关键词，如果我的任务数量是固定的，那么其实我们是不需要制造新的数据结构来处理这个问题，我们就只有这N个任务，那我们直接按照优先级排一个序，然后从高序到低序去执行就行了，这个过程我们需要的是一个排序算法，而不是一个优先队列。但是通常实际情况，我们是不知道要处理多少个任务的。就比如当我们的任务中心处理掉一个请求后，然后又来了很多新的请求，我们不能一开始就确定我们的任务处理中心要处理多少个请求，这就是动态的意思。&lt;/p&gt;&lt;p&gt;  优先队列本质上也是一种队列，和我们在&lt;a href=&quot;https://www.cnblogs.com/reminis/p/12586248.html&quot; target=&quot;_blank&quot;&gt;常见的线性结构&lt;/a&gt;中定义的队列接口是一样的，只不过在具体实现时有所不同。我们可以实现优先队列可以通过普通的线性结构来实现，既不管你是通过数组实现还是链表实现，你会发现在入队时的时间复杂度为O(1)，但是在出队时的时间复杂度却为O(n),因为使用顺序结构实现的优先队列在进行出队操作时，我们需要先遍历这个这个优先队列，找到优先级最高的元素时再进行出队；当然我们也可以使用顺序线性结构实现优先队列，这样我们就可以在出队时让时间复杂度为O(1)，但是在入队时，我们的时间复杂度就为O(n)了，因为我们每次在向优先队列中添加新元素时，都需要对优先队列中所有元素的优先级进行对比，然后添加到按优先级排序中的位置。有没什么办法让我们实现的优先队列的出队和入队操作效率都很高呢？这就是本文要讲的另外一种数据结构了，我们可以通过堆来实现优先队列，&lt;span&gt;堆也是一种树结构。&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;实现方式&lt;/th&gt;
&lt;th&gt;入队操作&lt;/th&gt;
&lt;th&gt;出队操作&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;普通线性结构&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;顺序线性结构&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;堆&lt;/td&gt;
&lt;td&gt;O(logn)&lt;/td&gt;
&lt;td&gt;O(logn)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  堆也是一种树，本文主要说的是二叉堆，&lt;span&gt;二叉堆是一棵完全二叉树&lt;/span&gt;。什么是完全二叉树呢？完全二叉树就是把元素按照数的形状一层一层的放，直到放完为止，即把元素顺序排成树的形状。堆也是一棵平衡二叉树，因为完全二叉树一定是平衡二叉树，什么是平衡二叉树？即对于整棵树来说，最大深度和最小深度的差值不能大于1，因此平衡二叉树一定不会退化成链表。&lt;/p&gt;&lt;p&gt;  二叉堆的性质：堆中某个节点的值总是不大于其父节点的值，本文讲的是最大堆，即根节点的值是最大的，相应地也可以定义最小堆。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200405100600725-483007163.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  基于完全二叉树的性质，我们可以使用数组来存储二叉堆中的元素：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200405103605899-236421803.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们也可以在索引为零的位置存储二叉堆的根节点，不过此时当前节点的父亲节点、左孩子节点和右孩子节点的索引关系就会发生如下改变：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200405104108600-1055789775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何创建一个二叉最大堆？&quot;&gt;如何创建一个二叉最大堆？&lt;/h3&gt;
&lt;p&gt;  当我们使用数组表示最大堆时，我们可以使用在&lt;a href=&quot;https://www.cnblogs.com/reminis/p/12586248.html&quot; target=&quot;_blank&quot;&gt;常见的线性结构&lt;/a&gt;中自定义的动态数组，这样我们在向堆中添加和删除元素时，我们就可以动态地改变数组的容量，不需要考虑数组容量的问题了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 基于二叉最大堆的性质：堆中某个节点的值总是不大于其父节点的值
 * @param &amp;lt;E&amp;gt; 二叉最大堆中的元素必须要具有可比较性
 */
public class MaxHeap&amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt; {

    //使用的是我们的自定义动态数组
    private Array&amp;lt;E&amp;gt; data;

    //有参构造--用户指定堆的大小
    public MaxHeap(int capacity){
        data = new Array&amp;lt;E&amp;gt;(capacity);
    }

    //无参构造
    public MaxHeap(){
        //这里我们就使用动态数组的默认大小
        data = new Array&amp;lt;E&amp;gt;();
    }

    //返回堆中元素的个数
    public int getSize(){
        return data.getSize();
    }

    //返回一个布尔值，判断堆是否为空
    public boolean isEmpty(){
        return data.isEmpty();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据我们之前再说使用数组存储二叉堆时，二叉堆中的节点与数组中的索引的关系用具体代码表示，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 返回完全二叉树的数组表示中，一个索引所表示的元素的父亲节点的索引
    private int parent(int index){
        //如果为根节点，由于根节点没有父亲节点，则抛出异常
        if(index == 0)
            throw new IllegalArgumentException(&quot;index-0 doesn't have parent.&quot;);
        return (index - 1) / 2;
    }

    // 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引
    private int leftChild(int index){
        return index * 2 + 1;
    }

    // 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引
    private int rightChild(int index){
        return index * 2 + 2;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何向堆中添加元素？&quot;&gt;如何向堆中添加元素？&lt;/h3&gt;
&lt;p&gt;当我们新添加的元素大于父亲节点时，就不满足二叉最大堆的性质，我们就需要交换这两个元素的位置，待添加元素与其父亲节点交换位置的过程就叫做上浮（Sift Up）,如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200405112135923-1301010030.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt; 具体代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //向堆中添加元素
    public void add(E e){
        //把元素存储到动态数组中
        data.addLast(e);
        //data.getSize()-1 是待添加元素在动态数组中的索引
        siftUp(data.getSize()-1);
    }

    private void siftUp(int index) {
        //比较当前元素的父亲节点 data.get(parent(index)的值与带添加元素的值大小
        //如果待添加元素的父亲节点的值小于带添加元素，则需要交换位置
        while (index&amp;gt;0 &amp;amp;&amp;amp; data.get(parent(index)).compareTo(data.get(index)) &amp;lt;0 ){
            //在我们的动态数组中新增一个两个索引位置元素交换的方法
            data.swap(index,parent(index));
            //交换索引的值，进行下一轮循环比较
            index = parent(index);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我们的动态数组Array中新增一个两个索引位置元素交换的方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void swap(int index, int parent) {
        //判断索引合法性
        if (index&amp;lt;0 || index&amp;gt;= size || parent&amp;lt;0 ||parent&amp;gt;=size){
            throw new IllegalArgumentException(&quot;Index is illegal.&quot;);
        }

        //交换两个元素的位置
        E t = data[index];
        data[index] = data[parent];
        data[parent] = t;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何从堆中取出元素？&quot;&gt;如何从堆中取出元素？&lt;/h3&gt;
&lt;p&gt;  从堆中取出元素和sift down：取出队中最大的元素，因为我们只是取出堆顶的元素，即根节点，把根节点元素取出后，我们的堆就变成了两个子树，我们现在需要把堆中最后的一个元素放在堆顶，即作为二叉树的根节点，我们的数组也删除这个元素，但此时又不满足堆的性质了，我们就需要对根节点进行下沉（sift down）,需要和他元素值最大的那个孩子互换位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200405120007197-2094293579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //取出堆中最大元素
    public E extractMax(){
        E res = findMax();
        //交换最大元素和堆中最后一个元素的位置
        data.swap(0,data.getSize()-1);
        //删除堆中最后一个元素
        data.removeLast();
        siftDown(0);
        return res;
    }

    private void siftDown(int index) {
        //即判断左孩子节点不为空
        while (leftChild(index) &amp;lt; data.getSize()){
            //获取左孩子节点的索引
            int childIndex = leftChild(index);
            //childIndex+1 即为右孩子的索引
            if (childIndex+1 &amp;lt; data.getSize() &amp;amp;&amp;amp; 
                    //在右孩子不为空的情况下，比较右孩子和左孩子的大小
                    data.get(childIndex+1).compareTo(data.get(childIndex))&amp;gt; 0 ){
                childIndex ++;//即data[childIndex] 是 leftChild 和 rightChild 中的最大值
            }
            if (data.get(index).compareTo(data.get(childIndex)) &amp;gt;= 0){
                break;
            }
            data.swap(index,childIndex);
            index = childIndex;
        }
    }

    //二叉最大堆中最大的元素就是堆顶的元素，在数组中对应索引为零的元素
    private E findMax() {
        if(data.getSize() == 0)
            throw new IllegalArgumentException(&quot;Can not findMax when heap is empty.&quot;);
        return data.get(0);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面就让我们来对于二叉堆的添加和删除操作进行测试，该测试代码实现了对数据的降序排序，测试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {

        int n = 1000000;

        //测试自定义的最大堆
        MaxHeap&amp;lt;Integer&amp;gt; maxHeap = new MaxHeap&amp;lt;Integer&amp;gt;();
        Random random = new Random();
        for(int i = 0 ; i &amp;lt; n ; i ++)
            //向我们的最大堆中添加100万个随机整数
            maxHeap.add(random.nextInt(Integer.MAX_VALUE));

        int[] arr = new int[n];
        for(int i = 0 ; i &amp;lt; n ; i ++)
            //从最大堆中取出堆顶的元素，放入arr数组中
            arr[i] = maxHeap.extractMax();

        for(int i = 1 ; i &amp;lt; n ; i ++)
            //如果arr数组的前一个元素的值小于后一个元素的值，则说明我们实现的二叉堆有问题
            if(arr[i-1] &amp;lt; arr[i])
                throw new IllegalArgumentException(&quot;Error&quot;);

        System.out.println(&quot;Test MaxHeap completed.&quot;);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;时间复杂度分析：由于我们的二叉堆是一颗完全二叉树，所以它的add()和extractMax()的时间复杂度都是O(log n)。&lt;br/&gt;下面再让我们来看看二叉堆的其他操作：&lt;br/&gt;replace:取出最大元素后，放入一个新的元素，即是替换的意思。&lt;br/&gt;实现思路一：我们可以先extractMax(),然后在进行add()，两次O(log n)操作。&lt;br/&gt;实现思路二：我们可以直接将堆顶元素替换以后Sift Down，一次O(log n)操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //replace:将堆顶元素替换以后Sift Down
    public E replace(E e){
        E maxValue = findMax();
        data.set(0,e);
        siftDown(0);
        return maxValue;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Heapify:将任意数组整理成堆的形状&lt;br/&gt;  对于任意一个数组，我们可以先看成一个完全二叉树，从最后一个非叶子节点计算，倒着从后向前不断 地进行sift down(下层操作)，直到第一个非叶子节点&lt;br/&gt;如何获取最后一个非叶子节点的索引？就是最后一个节点的父亲节点，如果是从0开始索引，则最后一个非叶子节点的索引为（i-1）/2，如果是从1开始索引，则父节点索引为i/2。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200405125051165-394546570.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;Heapify的算法复杂度：将n个元素逐个插入一个空堆中，时间复杂为O(nlogn)，在进行heapify的过程，时间复杂度为O(n).&lt;br/&gt;在heapify代码实现之前，我们需要在实现的动态数组中添加一个构造器，该构造器可以将传入的数组转为动态数组。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public Array(E[] arr){
        data = (E[])new Object[arr.length];
        for (int i=0; i&amp;lt;arr.length; i++){
            data[i] = arr[i];
        }
        size = arr.length;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我们的最大堆中实现Heapify操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //从第一个非叶子节点进行下沉操作，直到根节点
    public MaxHeap(E[] arr){
        data = new Array&amp;lt;E&amp;gt;(arr);
        for (int i=parent(arr.length-1); i&amp;gt;=0; i--){
            siftDown(i);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面据让我们来对是否使用heapify进行测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private static double testHeap(Integer[] testData, boolean isHeapify){

        long startTime = System.nanoTime();

        MaxHeap&amp;lt;Integer&amp;gt; maxHeap;
        if(isHeapify)
            maxHeap = new MaxHeap&amp;lt;Integer&amp;gt;(testData);
        else{
            maxHeap = new MaxHeap&amp;lt;Integer&amp;gt;();
            for(int num: testData)
                maxHeap.add(num);
        }

        int[] arr = new int[testData.length];
        for(int i = 0 ; i &amp;lt; testData.length ; i ++)
            arr[i] = maxHeap.extractMax();

        for(int i = 1 ; i &amp;lt; testData.length ; i ++)
            if(arr[i-1] &amp;lt; arr[i])
                throw new IllegalArgumentException(&quot;Error&quot;);
        System.out.println(&quot;Test MaxHeap completed.&quot;);

        long endTime = System.nanoTime();

        return (endTime - startTime) / 1000000000.0;
    }

    public static void main(String[] args) {

        int n = 1000000;

        Random random = new Random();
        Integer[] testData = new Integer[n];
        for(int i = 0 ; i &amp;lt; n ; i ++)
            testData[i] = random.nextInt(Integer.MAX_VALUE);

        //不使用heapify
        double time1 = testHeap(testData, false);
        System.out.println(&quot;Without heapify: &quot; + time1 + &quot; s&quot;);

        //使用heapify
        double time2 = testHeap(testData, true);
        System.out.println(&quot;With heapify: &quot; + time2 + &quot; s&quot;);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从测试代码的运行结果可以看出，对与100万个整数这种数据量来说，O(nlogn)和O(n)这两种时间复杂度所花费的时间差不多：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200405131604764-738095181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;基于堆实现优先队列&quot;&gt;基于堆实现优先队列&lt;/h3&gt;
&lt;p&gt;这里是基于自定义的最大堆进行实现的优先队列，元素值越大，优先级越高，具体代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PriorityQueue&amp;lt;E extends Comparable&amp;lt;E&amp;gt;&amp;gt; implements Queue&amp;lt;E&amp;gt;  {

    private MaxHeap&amp;lt;E&amp;gt; maxHeap;

    //无参构造 -- 初始化最大堆
    public PriorityQueue() {
        this.maxHeap = new MaxHeap&amp;lt;E&amp;gt;();
    }

    @Override
    public int getSize() {
        return maxHeap.getSize();
    }

    @Override
    public boolean isEmpty() {
        return maxHeap.isEmpty();
    }

    @Override
    public void enqueue(E e) {
        maxHeap.add(e);
    }

    //出队是优先级高的先出去，这里是元素值越大，优先级越高
    @Override
    public E dequeue() {
        return maxHeap.extractMax();
    }

    @Override
    public E getFront() {
        return maxHeap.findMax();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;优先队列的经典问题&quot;&gt;优先队列的经典问题&lt;/h3&gt;
&lt;p&gt;在100 0000个元素中选出前100名？这个问题相当于是在N个元素中选出前M个元素的一种特殊情况，我们来看下leetcode官网上的347号问题：题目描述如下图&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202004/1975191-20200405133315617-887633795.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;现在让我们使用自己实现的优先队列列来解决的这个问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //定义我们优先队列的出队规则
    private class Freq implements Comparable&amp;lt;Freq&amp;gt;{
        //e代表元素 freq代表出现的频次
        public int e, freq;

        public Freq(int e, int freq){
            this.e = e;
            this.freq = freq;
        }

        @Override
        public int compareTo(Freq another){
            //频次高的先出队
            if(this.freq &amp;lt; another.freq)
                return 1;
            else if(this.freq &amp;gt; another.freq)
                return -1;
            else
                return 0;
        }
    }

    public List&amp;lt;Integer&amp;gt; topKFrequent(int[] nums, int k) {
        //使用map来存储这个数，以及这个数出现的频次
        TreeMap&amp;lt;Integer,Integer&amp;gt; map = new TreeMap&amp;lt;Integer, Integer&amp;gt;();
        for (int num : nums) {
            //如果map中已经存在num，则对num的频次加一
            if (map.containsKey(num)){
                map.put(num,map.get(num) + 1);
            }else {
                map.put(num,1);
            }
        }

        PriorityQueue&amp;lt;Freq&amp;gt; pq = new PriorityQueue&amp;lt;Freq&amp;gt;();
        for (Integer key : map.keySet()) {
            //若优先队列中的元素小于K
            if (pq.getSize() &amp;lt; k){
                pq.enqueue(new Freq(key,map.get(key)));
            }else if(map.get(key) &amp;gt; pq.getFront().freq){
                pq.dequeue();
                pq.enqueue(new Freq(key, map.get(key)));
            }
        }

        List&amp;lt;Integer&amp;gt; res = new LinkedList&amp;lt;Integer&amp;gt;();
        while(!pq.isEmpty())
            res.add(pq.dequeue().e);
        return res;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们也可以使用Java类库提供的优先队列来解决这个问题，需要注意的是，Java类库中提供的优先队列是基于最小堆实现的，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public List&amp;lt;Integer&amp;gt; topKFrequent(int[] nums, int k) {

        TreeMap&amp;lt;Integer, Integer&amp;gt; map = new TreeMap&amp;lt;&amp;gt;();
        for(int num: nums){
            if(map.containsKey(num))
                map.put(num, map.get(num) + 1);
            else
                map.put(num, 1);
        }

        PriorityQueue&amp;lt;Integer&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(
                //这里使用lambda表达式实现了优先队列的优先级规则
                (a, b) -&amp;gt; map.get(a) - map.get(b)
        );
        for(int key: map.keySet()){
            if(pq.size() &amp;lt; k)
                pq.add(key);
            else if(map.get(key) &amp;gt; map.get(pq.peek())){
                pq.remove();
                pq.add(key);
            }
        }

        LinkedList&amp;lt;Integer&amp;gt; res = new LinkedList&amp;lt;&amp;gt;();
        while(!pq.isEmpty())
            res.add(pq.remove());
        return res;
    }
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 06 Apr 2020 00:38:00 +0000</pubDate>
<dc:creator>Java伴我余生</dc:creator>
<og:description>什么是优先队列？ 我们在常见的线性结构中,已经知道什么是普通队列了，普通队列就是一种“先进先出，后进后出”的数据结构，即普通队列的出队顺序和入队顺序是一样的，但我们的优先队列，它的出队顺序和入队顺序无</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/reminis/p/12633099.html</dc:identifier>
</item>
<item>
<title>LeetCode47， 全排列进阶，如果有重复元素怎么办？ - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12640513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12640513.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天是&lt;strong&gt;LeetCode第28篇&lt;/strong&gt;，依然是全排列的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对全排列不熟悉或者是最近关注的同学可以看一下上一篇文章：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMTM5OTM2NA==&amp;amp;mid=2247484998&amp;amp;idx=2&amp;amp;sn=9d45f27594d80f2fc8c2c281fa2ae4cc&amp;amp;chksm=f9dafb6dcead727bd608fd73f4f1f86cb6f3d0c3feb4a6c9ae38185ef7599a8f194d76a33f5e&amp;amp;scene=21#wechat_redirect&quot;&gt;LeetCode46 回溯算法求全排列，这次是真全排列&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LeetCode就是喜欢这样，把类似的问题放在一起，让你刷的时候一起刷，从而更加深刻地理解。今天的问题同样是全排列，不过稍稍不同的是，我们有一个限制条件不一样，&lt;strong&gt;给定的元素当中可能存在重复&lt;/strong&gt;。但是元素存在重复，我们并不想最后的结果也出现重复，这个时候应该怎么办？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，比如我们有一个排列是[1, 2, 2].&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的所有排列是[1, 2, 2], [2, 1, 2], [2, 2, 1]，但是注意，在之前的做法当中，我们把所有的元素看成是unique的，但是现在这个条件被破坏了。显然我们需要在实现全排列的基础上解决这个问题。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;无脑解决&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决的方法有两种，第一种是&lt;strong&gt;无脑解决&lt;/strong&gt;。是的你没有看错，因为我们分析一下就会发现&lt;strong&gt;next_permutation&lt;/strong&gt;循环的方法在这题当中仍然奏效，原因也很简单，因为我们每次用next_permutation求得字典序+1的下一个排列的时候，显然已经去除了重复元素的情况。为什么？因为同样元素换位置字典序是不会变化的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如下图当中，我们更换两个2的顺序，整个序列的字典序是没有变化的，要使得字典序变化一定要交换不同的元素。所以这个解法是可行的。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/6/1714ce457b72572f?w=1582&amp;amp;h=664&amp;amp;f=jpeg&amp;amp;s=24618&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;next_permutation是返回当前序列&lt;strong&gt;字典序+1&lt;/strong&gt;的序列的算法，这个算法在之前的文章当中出现过，所以我就不赘述它的原理了，如果你不记得或者是忘记了的话，可以点击下方的链接回顾一下：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMTM5OTM2NA==&amp;amp;mid=2247484662&amp;amp;idx=1&amp;amp;sn=92f6f8ded2e1fa4e61e2cceeb13cf451&amp;amp;chksm=f9daf9ddcead70cb9877b585a38bc0d87a6769b5de06549abb64779d150b8b5fa62b3574c439&amp;amp;scene=21#wechat_redirect&quot;&gt;LeetCode 31：递归、回溯、八皇后、全排列一篇文章全讲清楚&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个解法和上一题的最后一个解法完全一样，连改动都不需要，我们直接把代码copy过来把函数名匹配上就可以提交了。这也是我说这道题无脑的原因。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;11&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get_next&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, nums: List[int])&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;&lt;br/&gt;Do not return anything, modify nums in-place instead.&lt;br/&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;n = len(nums)&lt;br/&gt;pos = n - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(n&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; nums[i] &amp;gt; nums[i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;]:&lt;br/&gt;pos = i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(n&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;, pos, &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; nums[i] &amp;gt; nums[pos]:&lt;br/&gt;nums[i], nums[pos] = nums[pos], nums[i]&lt;br/&gt;nums[pos+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:] = nums[n:pos:&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;permuteUnique&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, nums: List[int])&lt;/span&gt; -&amp;gt; List[List[int]]:&lt;/span&gt;&lt;br/&gt;ret = []&lt;br/&gt;nums = sorted(nums)&lt;br/&gt;ret.append(nums.copy())&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; self.get_next(nums):&lt;br/&gt;ret.append(nums.copy())&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ret&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;回溯法&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然重复之前的工作并不能让我们变得更强，所以我们还是要回到正解上来。在之前的文章我们知道，生成全排列的&lt;strong&gt;通常做法是使用回溯法&lt;/strong&gt;。那么如果使用回溯法我们怎么解决重复元素的问题呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是老惯例，我们要解决问题，首先来&lt;strong&gt;分析问题&lt;/strong&gt;，我们知道重复的元素会干扰全排列生成的算法，那么它为什么会干扰，是怎么干扰的？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在回溯法当中，我们是顺序遍历位置，然后枚举放置的元素。于是我们大概可以想出两种可能导致重复的情况。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看情况1，情况1很简单，就是&lt;strong&gt;同一个位置放入同样元素&lt;/strong&gt;的情况。比如我们原数组当中有两个4，我们在放置的过程当中放入第一个4和第二个4的情况是一样的。显然这就重复了，我们可以参考下下图，我们给当下所有的选择编号，选择2和选择3是等价的，两者只能选一个。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/6/1714ce4591a28c82?w=1644&amp;amp;h=1056&amp;amp;f=jpeg&amp;amp;s=68051&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二种情况也比较容易想明白，还是同样的例子，我们给数组当中的两个4编号，一个编号是&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=4_1&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;，一个是&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=4_2&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;，我们会发现对于两个位置，我们&lt;strong&gt;先放第一个再放第二个和先放第二个再放第一个是重复的&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/6/1714ce45d41bc34b?w=1574&amp;amp;h=892&amp;amp;f=jpeg&amp;amp;s=43939&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表面上来看情况是这两种，但是如果深入分析会发现这两种情况其实说的是一回事，结果出现重复都是由于全排列的时候元素出现&lt;strong&gt;不稳定&lt;/strong&gt;造成的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的“&lt;strong&gt;稳定&lt;/strong&gt;“其实是一个排序算法当中的术语，我们经常会讨论某一个排序算法是稳定的，某一个不是。这个稳定是什么意思呢，其实就是指的&lt;strong&gt;元素的相对顺序&lt;/strong&gt;。比如在上面这张图当中的两个4，如果在排序的结果当中，后面一个4有可能出现在第一个4的前面，那么就说明这个算法是不稳定的，同样，如果不会出现这样的情况，那么可以说这个算法是稳定的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，如果我们能保证执行全排列的时候元素的稳定性，那么这个问题就解决了。表面上看这似乎是一个优化问题，其实不然，考察的是稳定性这个概念。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果能想到稳定性这点，离解决已经很近了。我们要保证稳定性，也就是说对于当前元素，我们需要保证前面的同元素已经放置了，那么&lt;strong&gt;在一个排列中，相同元素的摆放位置应该是递增的&lt;/strong&gt;。我们用map记录每一个元素最后一次摆放的位置，控制它在往下递归的过程当中递增即可。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如当数组当中有两个4的时候，第一个4如果还没有摆放，那么第二个4也不能摆。但是由于我们在判断要不要摆放第二个4的时候，并不知道前面是否还有其他的4，所以我们只能倒过来，&lt;strong&gt;判断在摆放第一个4的时候，是不是已经放过了后面的4&lt;/strong&gt;，如果是的话，那么这个操作不能执行。用语言描述这个逻辑有点绕，我们来看下图就明白了：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/6/1714ce45927797e7?w=1542&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=54115&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们摆放了第一个4之后，map[4] = 4，记录的是摆放的4的下标，当我们枚举放置第一个4的时候，发现已经放置的4下标大于当前，说明非法，放置了会引起重复。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个问题是当我们回溯的时候，&lt;strong&gt;需要重置map里的值&lt;/strong&gt;，比如：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/6/1714ce459d5f9948?w=1632&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=61541&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一次递归当中，我们放置了两个4，放了第二个4之后，map[4] = 4，当我们回溯弹出第二个4的时候，这个时候的map[4]应该是多少？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案不难，应该是1，也就是第一个4的下标。所以我们在递归的时候，在更新map之前，&lt;strong&gt;需要记录一下之前的值&lt;/strong&gt;，方便回溯的时候恢复。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们整理一下，思路可以得到代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, nums, n, i, states, cur, ret, flag)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i == n:&lt;br/&gt;ret.append(cur.copy())&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; p &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(n):                &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; flag[p] &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; (nums[p] &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; states &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; states[nums[p]] &amp;gt;= p):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;&lt;br/&gt;cur.append(nums[p])&lt;br/&gt;tmp, states[nums[p]] = states[nums[p]] &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; nums[p] &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; states &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;, p&lt;br/&gt;flag[p] = &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;&lt;br/&gt;self.dfs(nums, n, i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, states, cur, ret, flag)&lt;br/&gt;cur.pop()&lt;br/&gt;flag[p] = &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;&lt;br/&gt;states[nums[p]] = tmp &lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;permuteUnique&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, nums: List[int])&lt;/span&gt; -&amp;gt; List[List[int]]:&lt;/span&gt;&lt;br/&gt;ret = []&lt;br/&gt;n = len(nums)&lt;br/&gt;flag = [&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(n)]&lt;br/&gt;self.dfs(nums, n, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, {}, [], ret, flag)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ret&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;改进&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个方法其实有点复杂，理解起来&lt;strong&gt;有很多细节&lt;/strong&gt;，一个比较蛋疼的点就是我们用了map去记录了位置，由于要更新map，所以还需要记录之前的值，还需要判断元素不在map当中的情况。并且map的查找存在开销，那么我们能不能不用map呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在想怎么不用map的替代方案之前，我们需要先搞清楚，我们为什么要使用map？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题问的并不是一个充分问题，而是一个必要问题，&lt;strong&gt;不是用map解决了什么问题，而是我们为什么只能用map不可呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为map是一个容器，它能存储数据。对于一个元素t来说，我们并不知道它在数组nums当中之前出现的位置是哪里，我们也并不知道这些之前出现的t有没有被放入当前的排列里。我们用map记录下t的下标，本质原因是这个。map只是我们实现这个功能的手段，不是目的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们如果不想使用map，必须&lt;strong&gt;要保证能够知道每一个元素的摆放位置&lt;/strong&gt;才可以。要做到这点其实并不难，我们只需要对nums排序就好了。排序之后，所有相同的元素都会挨在一起。那么，对于位置p来说，我们只需要判断如果nums[p-1] 等于 nums[p]的话，必须要flag[p-1]等于true，也就是说对于元素v来说，它前面一位如果是v必须要放置好，才能放置当前的v，否则就是非法的。这样每一个v都限制前一个v，就保证了所有的v不会起冲突。这是一种&lt;strong&gt;链式限制&lt;/strong&gt;的思想。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种方法，我们就可以抛弃掉map的使用，进而极大地提升效率。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想清楚了原理之后，代码非常简单：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;9&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, nums, n, i, cur, ret, flag)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i == n:&lt;br/&gt;ret.append(cur.copy())&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; p &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(n):                &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; flag[p] &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; (p &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; nums[p&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;] == nums[p] &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; flag[p&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;]):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;&lt;br/&gt;cur.append(nums[p])&lt;br/&gt;flag[p] = &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;&lt;br/&gt;self.dfs(nums, n, i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, cur, ret, flag)&lt;br/&gt;cur.pop()&lt;br/&gt;flag[p] = &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;permuteUnique&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, nums: List[int])&lt;/span&gt; -&amp;gt; List[List[int]]:&lt;/span&gt;&lt;br/&gt;ret = []&lt;br/&gt;n = len(nums)&lt;br/&gt;nums = sorted(nums)&lt;br/&gt;flag = [&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(n)]&lt;br/&gt;self.dfs(nums, n, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, [], ret, flag)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ret&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看，我们&lt;strong&gt;只需要排序&lt;/strong&gt;，也不需要引入新的数据结构，就可以完美地解决这个问题。其实很多时候，解决问题的途径有很多种，能不能想到更好的解法除了取决于能力之外，更重要的还是对问题的理解。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题也是一个&lt;strong&gt;Medium&lt;/strong&gt;的问题，总体来说难度并不大。如果可以不看标程，独立通过这道题，就说明对全排列这个问题的思考已经比较到位了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章就是这些，如果觉得有所收获，请顺手点个&lt;strong&gt;关注或者转发&lt;/strong&gt;吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Apr 2020 00:31:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是LeetCode第28篇，依然是全排列的问题。 如果对全排列不熟悉或者是最近关注的同学可以看一下上一篇文章： LeetCode46</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12640513.html</dc:identifier>
</item>
<item>
<title>5分钟看懂微服务架构下的Consul 特性及搭建 - Jlion</title>
<link>http://www.cnblogs.com/jlion/p/12629934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlion/p/12629934.html</guid>
<description>&lt;!--[if IE]&gt;
    &lt;div class=&quot;unsupported-browser&quot;&gt;
        &amp;#35813;&amp;#39029;&amp;#38754;&amp;#19981;&amp;#25903;&amp;#25345; Internet Explorer &amp;#27983;&amp;#35272;&amp;#22120;&amp;#65292;&amp;#24314;&amp;#35758;&amp;#20351;&amp;#29992;
        &lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/&quot;&gt;Google Chrome&lt;/a&gt;,
        &lt;a href=&quot;https://www.mozilla.org/zh-CN/firefox/&quot;&gt;Firefox&lt;/a&gt; &amp;#25110;
        &lt;a href=&quot;https://www.microsoftedgeinsider.com/zh-CN/&quot;&gt;Microsoft Edge&lt;/a&gt;
    &lt;/div&gt;
&lt;![endif]--&gt;
    &lt;div class=&quot;center-container &quot;&gt;
        &lt;div class=&quot;center-body card  h-sm-100&quot;&gt;
            &lt;div class=&quot;card-body&quot;&gt;
                


&lt;div class=&quot;login-top text-center&quot;&gt;
    &lt;span class=&quot;login-title&quot;&gt;博客园用户登录&lt;/span&gt;
    &lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;
        &lt;svg class=&quot;login-sign&quot;&gt;&lt;use xlink:href=&quot;#icon-login-sign&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;
    &lt;p&gt;代码改变世界&lt;/p&gt;
&lt;/div&gt;
&lt;form id=&quot;loginForm&quot; method=&quot;post&quot; onsubmit=&quot;return false&quot;&gt;
    
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;1&quot; class=&quot;form-control&quot; placeholder=&quot;登录用户名 / 邮箱&quot; autofocus=&quot;&quot; type=&quot;text&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入登录用户名&quot; id=&quot;LoginName&quot; name=&quot;LoginName&quot; value=&quot;&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;LoginName&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/forgotloginname&quot;&gt;忘记登录用户名&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;2&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入密码&quot; id=&quot;Password&quot; name=&quot;Password&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;Password&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/resetpassword&quot;&gt;忘记密码&lt;/a&gt;
        &lt;/div&gt;
        &lt;p&gt;
            &lt;input tabindex=&quot;3&quot; type=&quot;checkbox&quot; id=&quot;IsRemember&quot; name=&quot;IsRemember&quot; value=&quot;true&quot; class=&quot;custom-control-input&quot;/&gt;&lt;label class=&quot;custom-control-label&quot; for=&quot;IsRemember&quot;&gt;记住我&lt;/label&gt;
        &lt;/p&gt;

        &lt;button tabindex=&quot;4&quot; id=&quot;submitBtn&quot; type=&quot;submit&quot; class=&quot;btn-login btn btn-primary btn-sm ladda-button px-4&quot; data-style=&quot;slide-down&quot;&gt;
            &lt;span class=&quot;ladda-label&quot;&gt;登录&lt;/span&gt;
        &lt;/button&gt;
        &lt;div class=&quot;login-footer&quot;&gt;
            &lt;div class=&quot;ajax-error-box&quot;&gt;
                
            &lt;/div&gt;
            &lt;span&gt;没有账户，&lt;a href=&quot;https://account.cnblogs.com/signup&quot;&gt;立即注册&lt;/a&gt;&lt;/span&gt;
        &lt;/div&gt;
    
&lt;input name=&quot;__RequestVerificationToken&quot; type=&quot;hidden&quot; value=&quot;CfDJ8Nf-Z6tqUPlNrwu2nvfTJEiq37kyy6wu9X2cj3KYbQTjPs_2TZUaSVNhpby0so4EuWYueKLglmzY7u_FaLL_mTKxWja7gw4K1O1UoFutKVh1Z6rGQqoTQHy0Ny2Om34_4G38mVI32WTTnCUyiu-p6Bw&quot;/&gt;&lt;/form&gt;

&lt;input type=&quot;hidden&quot; id=&quot;PublicKey&quot; name=&quot;PublicKey&quot; value=&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCp0wHYbg/NOPO3nzMD3dndwS0MccuMeXCHgVlGOoYyFwLdS24Im2e7YyhB0wrUsyYf0/nhzCzBK8ZC9eCWqd0aHbdgOQT6CuFQBMjbyGYvlVYU2ZP7kG9Ft6YV6oc9ambuO7nPZh+bvXH0zDKfi02prknrScAKC0XhadTHT3Al0QIDAQAB&quot;/&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    </description>
<pubDate>Sun, 05 Apr 2020 23:20:00 +0000</pubDate>
<dc:creator>Jlion</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com/signin?ReturnUrl=https://www.cnblogs.com/jlion/p/12629934.html</dc:identifier>
</item>
<item>
<title>使用Spring管理数据库事务 - 小鱼吃猫</title>
<link>http://www.cnblogs.com/Lyn4ever/p/12640311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lyn4ever/p/12640311.html</guid>
<description>&lt;p&gt;在整个JavaWeb项目开发中，事务是用来开发可靠性网络应用程序的最关键部分。当应用程序与后端资源进行交互时，就会用到事务，这里的后端资源包括数据库、MQ、ERP等。而数据库事务是最常见的类型，而我们常说的事务也就是狭义上的与关系型数据库交互的事务。 事务主要分为本地事务和全局事务。全局事务又称分布式事务，本地事务就是当应用程序连接单个数据库资源时的事务，也是本文化主要讨论的内容。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;123.72991287512&quot;&gt;
&lt;p&gt;在整个JavaWeb项目开发中，事务是用来开发可靠性网络应用程序的最关键部分。当应用程序与后端资源进行交互时，就会用到事务，这里的后端资源包括数据库、MQ、ERP等。而数据库事务是最常见的类型，而我们常说的事务也就是狭义上的与关系型数据库交互的事务。&lt;/p&gt;
&lt;p&gt;事务主要分为本地事务和全局事务。全局事务又称分布式事务，本地事务就是当应用程序连接单个数据库资源时的事务，也是本文化主要讨论的内容。&lt;/p&gt;
&lt;h2 id=&quot;一、事务的一些基本概念&quot;&gt;一、事务的一些基本概念&lt;/h2&gt;
&lt;h4 id=&quot;事务的属性（acid）：&quot;&gt;事务的属性（ACID）：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;原子性&lt;/li&gt;
&lt;li&gt;一致性&lt;/li&gt;
&lt;li&gt;隔离性&lt;/li&gt;
&lt;li&gt;持久性&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;白话事务&quot;&gt;白话“事务”&lt;/h4&gt;
&lt;p&gt;事务有三个状态（或者说是过程）：&lt;strong&gt;开始、提交、回滚&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设有这么一个场景：张三和李四各有100元，有一天，张三要给李四转10元。&lt;/p&gt;
&lt;p&gt;相当于目前的微信转账，张三给李四发了10元的转账。有以下三种状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200405223244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上边这个例子有一处不恰当的地方就是，就算李四没有操作这10元时，张三已经少了10元，这一点和事务有出入 ，我们就假装如果李四不接收或者退回这10元，张三的微信钱包里还有100元。但是在微信中有那么多的人相互转账，每一次转账就是一个事务，我们就要把这些事务进行隔离，但是它有不同的隔离级别（见下）&lt;/p&gt;
&lt;h4 id=&quot;事务的隔离级别&quot;&gt;事务的隔离级别&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;举例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DEFAULT&lt;/td&gt;
&lt;td&gt;底层数据库存储的默认隔离级别&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;READ_UNCOMMITTED&lt;/td&gt;
&lt;td&gt;最低的隔离级别，可以说它并不是事务，因为它允许其他事务来读取未来提交的数据&lt;/td&gt;
&lt;td&gt;上边的例子中，就算李四没有收这10元，其他人也能读取到李四多了10元。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;READ_COMMITTED&lt;/td&gt;
&lt;td&gt;大多数数据库的默认级别，它确保其他事务可以读取其他事务已经提交的数据&lt;/td&gt;
&lt;td&gt;只有当李四对这10元进行操作(接收或者退回)时，别人才能看到这两个的余额变化。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;REPEATABLE_READ&lt;/td&gt;
&lt;td&gt;比上一个更为严格，它确保在选择了数据后，如果其他事务对这个数据进行了更改，就可以选择新的数据。&lt;/td&gt;
&lt;td&gt;上边的是在转账过程中，就算别人给张三又转了10元，在这个事务提交前，张三一直认为自己只有100元。但是这个类型中，张三在转账过程中，可以查到自己有110元&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;SERIALIZABLE&lt;/td&gt;
&lt;td&gt;可序列化，是最严格最可靠的隔离级别，让所有事务一个接着一个地运行&lt;/td&gt;
&lt;td&gt;系统让每个人转账事务一个一个地执行，就不会有任何错误了（当然，这里的事务不单单指转账这一个事务）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;事务的传播类型&quot;&gt;事务的传播类型&lt;/h4&gt;
&lt;p&gt;也就是当前事务开始的机制和时间，相当于这么多的人之间的微信转账应该怎么进行&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;传播类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;PROPAGATION_REQUIRED&lt;/td&gt;
&lt;td&gt;如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中；&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PROPAGATION_SUPPORTS&lt;/td&gt;
&lt;td&gt;支持当前事务，如果当前没有事务，就以非事务方式执行；&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PROPAGATION_MANDATORY&lt;/td&gt;
&lt;td&gt;使用当前的事务，如果当前没有事务，就抛出异常；&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PROPAGATION_REQUIRES_NEW&lt;/td&gt;
&lt;td&gt;新建事务，如果当前存在事务，把当前事务挂起；&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;PROPAGATION_NOT_SUPPORTED&lt;/td&gt;
&lt;td&gt;以非事务方式执行操作，如果当前存在事务，就把当前事务挂起；&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PROPAGATION_NEVER&lt;/td&gt;
&lt;td&gt;以非事务方式执行，如果当前存在事务，则抛出异常；&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;PEOPAGATION_NESTED&lt;/td&gt;
&lt;td&gt;如果当前存在事务，则在潜逃事务内执行。如果当前没有事务，则执行PROPAGATION_REQUIRED列斯的操作；&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;二、spring中解决事务问题&quot;&gt;二、Spring中解决事务问题&lt;/h2&gt;
&lt;p&gt;在Spring中解决事务问题有两种：&lt;strong&gt;声明式事务&lt;/strong&gt;和&lt;strong&gt;编程式事务&lt;/strong&gt;（不建议使用）&lt;/p&gt;
&lt;p&gt;Spring中支持事务的最底层接口是&lt;code&gt;PlatformTransactionManager&lt;/code&gt;，而我们使用的只能它的子类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface PlatformTransactionManager {
    //获取事务状态
    TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException;
        //提交
    void commit(TransactionStatus var1) throws TransactionException;
        //回滚
    void rollback(TransactionStatus var1) throws TransactionException;
}       
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个接口中主要用了TransactionDefinition和TransactionStatus两个类。有兴趣的可以看一下。下边这是它的子类图，我们这里使用的是DataSourceTransactionManager作为事务管理类，不管使用何种方式，PlatformTransactionManager这个接口的子类一定要有。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200406000705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-声明式事务&quot;&gt;1. 声明式事务&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;使用注解&lt;/p&gt;
&lt;p&gt;配置文件如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--引入公共的配置文件--&amp;gt;
&amp;lt;import resource=&quot;application-context.xml&quot;/&amp;gt;

&amp;lt;!--Spring提供的事务管理器--&amp;gt;
&amp;lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
    &amp;lt;constructor-arg ref=&quot;dataSource&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!--
    开启事务注解
    这里有个小技巧，如果你的事务管理bean名不是transactionManager
    就要给这个标签配置transaction-manager来指定
    --&amp;gt;
&amp;lt;tx:annotation-driven/&amp;gt;

&amp;lt;!--    配置spring扫描注解注入service类--&amp;gt;
&amp;lt;context:component-scan base-package=&quot;cn.lyn4ever.service&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 然后在类或方法上加上这个@Transactional注解就可以&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Transactional
public void insertOne(){
    Store store  =new Store();
    store.setTitle(&quot;华为P30&quot;);
    storeMapper.insertOne(store);

    int j = 10/0;//指定报错，让事务回滚
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用AOP配置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用aop的话，我们只需要进行配置，可以对我们写的业务代码无任何侵入。如果对AOP知识不是很了解，可以参考我之前的AOP系列教程&lt;a href=&quot;https://github.com/Lyn4ever29/RequireSpring&quot;&gt;Spring学习笔记&lt;/a&gt;，AOP的配置也有多种，这里就直接使用aop名称空间了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;import resource=&quot;application-context.xml&quot;/&amp;gt;

&amp;lt;!--Spring提供的事务管理器--&amp;gt;
&amp;lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
    &amp;lt;constructor-arg ref=&quot;dataSource&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;tx:advice id=&quot;txAdvice&quot;&amp;gt;
    &amp;lt;tx:attributes&amp;gt;
        &amp;lt;!-- 对单独方法配置属性--&amp;gt;
        &amp;lt;tx:method name=&quot;insert*&quot; rollback-for=&quot;java.lang.Exception&quot;/&amp;gt;
        &amp;lt;tx:method name=&quot;*&quot;/&amp;gt;
    &amp;lt;/tx:attributes&amp;gt;
&amp;lt;/tx:advice&amp;gt;

&amp;lt;aop:config&amp;gt;
    &amp;lt;aop:pointcut id=&quot;serviceTrans&quot; expression=&quot;execution(* cn.lyn4ever.serviceaop.*.*(..))&quot;/&amp;gt;
    &amp;lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;serviceTrans&quot;/&amp;gt;
&amp;lt;/aop:config&amp;gt;

&amp;lt;!--    配置spring扫描注解注入service类--&amp;gt;
&amp;lt;context:component-scan base-package=&quot;cn.lyn4ever.serviceaop&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;以上两种方式的对比：
&lt;ul&gt;&lt;li&gt;使用注解能更加细粒度地进行控制，因为并不是所有service方法都需要事务。而使用AOP使用的面向切面编程，所以可以大批量的进行控制，而一般都是在service层进入切入的。&lt;/li&gt;
&lt;li&gt;使用注解的话，配置简单，AOP的配置稍微复杂点儿。&lt;/li&gt;
&lt;li&gt;如果是新项目的话，建议从一开始就使用注解式开发。如果是更改之前没有用过事务（一般成熟的程序员不会这么干）的项目，或者无法修改源代码的情况下，建设使用AOP。&lt;/li&gt;
&lt;li&gt;个人经验，建议使用注解开发，能灵活的配置每一个方法及类。使用AOP的话，有时候调试起来不太方便，如果你的调试内容跨越了一个service方法，会进入aop通知方法，很麻烦。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2--编程式事务&quot;&gt;2. 编程式事务&lt;/h3&gt;
&lt;p&gt;顾名思义，就是将事务的操作直接写在业务代码中，这样做最简单，但是最不建议。有两种方式，一种就是将PlatformTransactionManager的实例注入到bean中，使用它。另一种就是使用Spring为我们提供的TransactionTemplate。这里直接使用第二种，这时，我们只需要使用Spring注入注入transactionManager和这两个类，但是为了不和之前的配置混淆，我直接new这两个对象了，也就是说，使用编程式事务，只需要这两个对象就够了，不需要其他任何有关事务的配置，只需要一个数据源&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Autowired
private DataSource dataSource;

@Test
public void fun() {
    DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();
    //设置数据源，这个数据源的bean是由Spring提供的
    transactionManager.setDataSource(dataSource);
    TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);
    transactionTemplate.execute(txStatus -&amp;gt; {
        Store store = new Store();
        store.setTitle(&quot;小米11&quot;);
        storeMapper.insertOne(store);
        //制造错误，让事务回滚
        int i = 10 / 0;
        return null;
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关注微信公众号“小鱼与Java”，回复Spring获取代码地址和更多学习资料&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lyn4ever.gitee.io/img/wx/gzh2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 05 Apr 2020 17:48:00 +0000</pubDate>
<dc:creator>小鱼吃猫</dc:creator>
<og:description>在整个JavaWeb项目开发中，事务是用来开发可靠性网络应用程序的最关键部分。当应用程序与后端资源进行交互时，就会用到事务，这里的后端资源包括数据库、MQ、ERP等。而数据库事务是最常见的类型，而我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Lyn4ever/p/12640311.html</dc:identifier>
</item>
<item>
<title>不可被忽视的操作系统（ FreeRTOS ）【1】 - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/12638655.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/12638655.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200405191742962-36461804.png&quot; alt=&quot;&quot; width=&quot;243&quot; height=&quot;157&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 把大多数人每个星期的双休过过成了奢侈的节假日放假，把每天23点后定义为自己的自由时间，应该如何去思考这个问题 ？&lt;/p&gt;
&lt;p&gt;双休的两天里，不！是放假的两天里，终于有较长的时间好好的学习一下一直断断续续的FreeRTOS了，本来打算一天加一个晚上结束战斗，最后还是高估了自己。FreeRTOS之所以能被这么多人使用，其必定是复杂多变的，笔者总结了其中的一些常用函数，其中参考的是正点原子的系列教程以及ESP32 IDF 4.0 关于FreeRTOS的数据手册和官方API手册。&lt;/p&gt;
&lt;h2&gt; 认识FreeRTOS&lt;/h2&gt;
&lt;p&gt;● FreeRTOS开源免费&lt;/p&gt;
&lt;p&gt;●FreeRTOS已经被越来越多的使用&lt;/p&gt;
&lt;p&gt;● 操作系统，开发时方便实现多任务调度&lt;/p&gt;
&lt;p&gt;● FreeRTOS的内核支持抢占式,合作式和时间片调度&lt;/p&gt;
&lt;p&gt;● 提供了一个用于低功耗的Tickless模式&lt;/p&gt;
&lt;p&gt;●  高效的软件定时器&lt;/p&gt;
&lt;p&gt;● 强大的跟踪执行功能&lt;/p&gt;
&lt;p&gt;●堆栈溢出检测功能&lt;/p&gt;
&lt;p&gt;● 任务数量不限&lt;/p&gt;
&lt;p&gt;●FreeRTOS系统简单、小巧、易用,通常情况下内核占用4k-9k字节的空间&lt;/p&gt;
&lt;p&gt;●高可移植性,代码主要C语言编写&lt;/p&gt;
&lt;p&gt;●任务与任务、任务与中断之间可以使用任务通知、消息队列、二值信号量、数值型信号量、递归互斥信号量和互斥信号量进行通信和同步&lt;/p&gt;
&lt;p&gt;Freerots是一个迷你的实时操作系统内核。作为一个轻量级的操作系统，功能包括：任务管理、时间管理、信号量、消息队列、内存管理、记录功能、软件定时器、协程等，可基本满足较小系统的需求。FreeRTOS操作系统是完全免费的操作系统，具有源码公开、可移植、可裁剪、调度策略灵活的特点。&lt;/p&gt;
&lt;p&gt;FreeRTOS,可以分为两部分Free和RTOS, Free就是免费的、自由的、不受约束的意思, RTOS全称是Real Time Operating System,中文名就是实时操作系统。可以看出FreeROTS就是一个免费的RTOS类系统。这里要注意, RTOS不是指某一个确定的系统,而是指一类系统。比如uC/os, FreeRTOS, RTX, RT-Thread等这些都是RTOS类操作系统。操作系统允许多个任务同时运行,这个叫做多任务,实际上,一个处理器核心在某一时刻只能运行一个任务。操作系统中任务调度器的责任就是决定在某一时刻究竟运行哪个任务,任务调度在各个任务之间的切换非常快!这就给人们造成了同一时刻有多个任务同时运行的错觉。操作系统的分类方式可以由任务调度器的工作方式决定,比如有的操作系统给每个任务分配同样的运行时间,时间到了就轮到下一个任务, Unix操作系统就是这样的。RTOS的任务调度器被设计为可预测的,而这正是嵌入式实时操作系统所需要的,实时环境中要求操作系统必须对某一个事件做出实时的响应,因此系统任务调度器的行为必须是可预测的。像FreeRTOS这种传统的RTOS类操作系统是由用户给每个任务分配一个任务优先级,任务调度器就可以根据此优先级来决定下一刻应该运行哪个任务。FreeRTOS是RTOS系统的一种, FreeRTOS十分的小巧,可以在资源有限的微控制器中运行,当然了, FreeRTOS不仅局限于在微控制器中使用。但从文件数量上来看FreeRTOS要比uC/OSII和uC/OSII小的多。&lt;/p&gt;
&lt;h2&gt;嵌入式系统比较&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;前后台系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们经常在嵌入式开发是都是在main函数里一个while(1)循环，再加上一些中断函数，可以认为其是一个单任务系统，也称之为前后台系统，其前台的意思是中断，后台的意思是main函数里的while(1)循环。&lt;/p&gt;
&lt;p&gt;有以下特点：&lt;/p&gt;
&lt;p&gt;l  简单，消耗资源少&lt;/p&gt;
&lt;p&gt;l  任务排队执行，无优先级区分&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RTOS&lt;/strong&gt;&lt;strong&gt;系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多任务实现将一个大的功能分成每一小块，每一小块分别由每一个任务进行管理，多任务并不是同时执行多个任务，本质上CPU在某一时间段只能被一个任务占用，但因为每个任务所占用的时间很短，所以看上去就像同一时间段执行了多个任务。&lt;/p&gt;
&lt;p&gt;有以下特点：&lt;/p&gt;
&lt;p&gt;l  消耗资源较大&lt;/p&gt;
&lt;p&gt;l  通过任务优先级管控，优先级高的任务可以随时打断低任务，功能实时性高&lt;/p&gt;
&lt;h2&gt;ESP32中的FreeRTOS&lt;/h2&gt;
&lt;p&gt;本章将围绕ESP32中的FreeRTOS实现展开&lt;/p&gt;
&lt;p&gt;原始的FreeRTOS设计为在单个内核上运行。但是ESP32是双核，包含协议CPU（称为CPU 0或PRO_CPU）和应用程序CPU（称为CPU 1或APP_CPU）。这两个内核实际上是相同的，并且共享相同的内存。这允许两个内核在它们之间交替运行任务。&lt;/p&gt;
&lt;p&gt;ESP32中关于任务大小使用的是字节为单位。但标准的FreeRTOS使用的是字，在标准中创建任务时如果堆栈为16位宽，而usStackDepth为100，则将分配200字节（16位=2个字节，2*100=200个字节）用作任务的堆栈。再举一个例子，如果堆栈为32位宽，而usStackDepth为400，则将分配1600个字节（32位=4个字节，4*400=1600个字节）用作任务的堆栈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字:在计算机中，一串数码作为一个整体来处理或运算的，称为一个计算机字，简称字。&lt;/p&gt;
&lt;p&gt;字节:是指一小组相邻的二进制数码。通常是8位作为一个字节。它是构成信息的一个小单位，并作为一个整体来参加操作，比字小，是构成字的单位。&lt;/p&gt;
&lt;p&gt;2、所代表的含义不同：&lt;/p&gt;
&lt;p&gt;计算机内存中，最小的存储单位是“位（bit）”，8个“位”构成一个“字节（byte）”.&lt;/p&gt;
&lt;p&gt;通常若干个字节组成一个“字”。&lt;/p&gt;
&lt;h2&gt;任务&lt;/h2&gt;
&lt;p&gt;l  任务使用无限制，可创建任务数量无最大值&lt;/p&gt;
&lt;p&gt;l  任务支持优先级，一个优先级下可以有多个任务，取值0到（configMAX_PRIORITIES – 1），其中configMAX_PRIORITIES在FreeRTOSConfig.h中定义,ESP32中为25, 数字越高优先级越高。&lt;/p&gt;
&lt;p&gt;l  每个任务维护自己的堆栈（用于任务被抢占后存储上下文），从而导致更高的RAM使用率&lt;/p&gt;
&lt;p&gt;l  任务实现函数必须是无返回值void类型的，其内部是通常是一个无限循环，如while(1)&lt;/p&gt;
&lt;p&gt;l  任务实现循环中需要有能引起任务调度的内容，通常是延时函数，如vTaskDelay（），也可以是其他只要能让FreeRTOS发生任务切换的API函数都可以,比如请求信号量、队列等,甚至直接调用任务调度器。只不过最常用的就是FreeRTOS的延时函数。&lt;/p&gt;
&lt;p&gt;l  任务函数一般不允许跳出循环,如果一定要跳出循环的话在跳出循环以后一定要调用函数vTaskDelete(NULL);删除此任务以释放内存&lt;/p&gt;
&lt;p&gt;l  任务状态：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个任务正在运行时,那么就说这个任务处于运行态,处于运行态的任务就是当前正在使用处理器的任务。如果使用的是单核处理器的话那么不管在任何时刻永远都只有一个任务处于运行态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;就绪态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;处于就绪态的任务是那些已经准备就绪(这些任务没有被阻塞或者挂起),可以运行的任务,但是处于就绪态的任务还没有运行,因为有一个同优先级或者更高优先级的任务正在运行!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个任务当前正在等待某个外部事件的话就说它处于阻塞态,比如说如果某个任务调用了函数vTaskDela（）的话就会进入阻塞态,直到延时周期完成。任务在等待队列、信号量、事件组、通知或互斥信号量的时候也会进入阻塞态。任务进入阻塞态会有一个超时时间,当超过这个超时时间任务就会退出阻塞态,即使所等待的事件还没有来临!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;挂起态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;暂停任务，像阻塞态一样,任务进入挂起态以后也不能被调度器调用进入运行态,但是进入挂起态的任务没有超时时间。任务进入和退出挂起态通过调用函数vTaskSuspend（）和xTaskResume（）。&lt;/p&gt;
&lt;p&gt;l  任务堆栈用于存储任务被打断时的上下文，以便任务再次被运行时恢复现场&lt;/p&gt;
&lt;p&gt;l  任务创建成功将返回pdPASS，一般创建失败的原因是系统堆内存不足&lt;/p&gt;
&lt;p&gt;l  ISR是中断可调用函数的标识&lt;/p&gt;
&lt;p&gt;l  任务调度：&lt;/p&gt;
&lt;p&gt;FreeRTOS如果在单核CPU上运行的话，那就决定了运行时只能有一个任务获得执行。任务调度其实就是任务切换的意思，能引起任务调度的函数有：&lt;/p&gt;
&lt;p&gt;vTaskDelay()延时，任务的延时就是让任务进入阻塞状态，交出cpu的使用权。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;创建任务&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在FreeRTOS实现内部，任务使用两个内存块。第一个块用于保存任务的数据结构。任务将第二个块用作其堆栈。如果使用xTaskCreate（）创建任务，则两个内存块将自动在xTaskCreate（）函数内部动态分配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pvTaskCode：指向任务的实现方法，该方法通常是一个无限循环，如果要退出的话必须使用vTaskDelete(NULL);删除此任务以释放内存&lt;/p&gt;
&lt;p&gt;constpcName：任务名称，该名称方便输出一下调试信息，configMAX_TASK_NAME_LEN（ESP32中是16）定义的最大长度-默认为16。&lt;/p&gt;
&lt;p&gt;usStackDepth：指定为字节数的任务堆栈的大小。请注意，这与原始FreeRTOS不同。&lt;/p&gt;
&lt;p&gt;constpvParameters：任务参数&lt;/p&gt;
&lt;p&gt;uxPriority：任务优先级，0到（configMAX_PRIORITIES – 1），其中configMAX_PRIORITIES在FreeRTOSConfig.h中定义, 当前ESP32SDK中该值为（ #define configMAX_PRIORITIES  ( 25 ) ）低优先级数字表示低优先级任务，同一优先级下将进行轮询执行，可以使用taskYIELD()尽快让出CPU使用权。&lt;/p&gt;
&lt;p&gt;constpvCreatedTask: 用于传回可引用创建的任务的句柄,方便后续操控任务，可以设置为NULL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果成功创建任务并将其添加到就绪列表，则为pdPASS，否则，在文件projdefs.h中定义的错误代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; BaseType_t xTaskCreate(TaskFunction_t pvTaskCode, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *constpcName, &lt;span&gt;const&lt;/span&gt; uint32_t usStackDepth, &lt;span&gt;void&lt;/span&gt; *constpvParameters, UBaseType_t uxPriority, TaskHandle_t *constpvCreatedTask)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;小试牛刀&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序总共有三个循环输出随机数：&lt;/p&gt;
&lt;p&gt;1.主循环，可获取的资源大&lt;/p&gt;
&lt;p&gt;2.任务0循环，可获取的资源被创建任务函数时限制&lt;/p&gt;
&lt;p&gt;3.任务1循环，可获取的资源被创建任务函数时限制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200405220305067-214855564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bootloader_random.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机数相关&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/FreeRTOS.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freertos相关&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/task.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务0处理函数&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Task_Run_0(){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    uint32_t ranv=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         ranv=esp_random();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取一个随机值,正负数&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】随机数输出：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ranv);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         vTaskDelay(&lt;span&gt;1000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时1S&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;   vTaskDelete(NULL);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务1处理函数&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Task_Run_1(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;datas){
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;    uint32_t ranv=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;    &lt;span&gt;char&lt;/span&gt; *strdata=(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;)datas;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         ranv=esp_random();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取一个随机值,正负数&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】随机数输出：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,strdata,ranv);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         vTaskDelay(&lt;span&gt;1000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时1S&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;   vTaskDelete(NULL);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--------------DONGIXAODONG FreeRTOS-----------------\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;未启用RF获取随机值&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     bootloader_random_enable();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启随机值获取
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动任务0，简化
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数，名字，字节大小，参数，优先级[0,25-1](最高优先为configMAX_PRIORITIES – 1),任务句柄&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     BaseType_t t0res=xTaskCreate(Task_Run_0,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DONG Task_Run_0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;,NULL,&lt;span&gt;16&lt;/span&gt;&lt;span&gt;,NULL);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(t0res==&lt;span&gt;pdPASS){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0启动成功....\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动任务1，标准&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     TaskHandle_t xHandle1 =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数，名字，字节大小，参数，优先级[0,25-1](最高优先为configMAX_PRIORITIES – 1),任务句柄&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     BaseType_t t1res=xTaskCreate(Task_Run_1,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DONG Task_Run_1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;,(&lt;span&gt;void&lt;/span&gt; *)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;16&lt;/span&gt;,&amp;amp;&lt;span&gt;xHandle1);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(t1res==&lt;span&gt;pdPASS){
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务1启动成功....\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     uint32_t ranv=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         ranv=esp_random();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取一个随机值,正负数&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【main】随机数输出：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ranv);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         vTaskDelay(&lt;span&gt;1000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时1S&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;获取当前任务的句柄&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;p&gt;调用该函数的任务的任务句柄&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
TaskHandle_t xTaskGetCurrentTaskHandle()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;挂起（暂停）任务调度器：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;FreeRTOS如果在单核CPU上运行的话，那就决定了运行时只能有一个任务获得执行。任务调度其实就是任务切换的意思&lt;/p&gt;
&lt;p&gt;关闭和开启任务调度器是为了某一个任务在操作过程中不被其它任务打断效果&lt;/p&gt;
&lt;p&gt;任务挂起函数被调用几次便要恢复几次，因为其内部有一个挂起计数，支持嵌套操作&lt;/p&gt;
&lt;p&gt;在不禁用中断的情况下挂起调度程序。&lt;/p&gt;
&lt;p&gt;调度程序挂起时不会发生上下文切换。&lt;/p&gt;
&lt;p&gt;调用vTaskSuspendAll（）之后，调用任务将继续执行，而不会被交换出来，直到对xTaskResumeAll（）进行了调用。&lt;/p&gt;
&lt;p&gt;挂起调度程序时，不得调用可能导致上下文切换的API函数（例如vTaskDelayUntil（），xQueueSend（）等）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; vTaskSuspendAll（ ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;恢复挂起（暂停）的任务调度器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 关闭和开启任务调度器是为了某一个任务在操作过程中不被其它任务打断效果&lt;/p&gt;
&lt;p&gt;通过调用vTaskSuspendAll（）挂起后恢复调度程序活动。&lt;/p&gt;
&lt;p&gt;xTaskResumeAll（）仅恢复调度程序。它不会取消暂停先前通过调用vTaskSuspend（）而暂停的任务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t xTaskResumeAll（ ）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;小试牛刀（挂起和恢复任务调度器）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; vTask1(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt; pvParameters)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务代码在这里。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在某一时刻，任务需要执行长时间的操作
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;它不想换出来,并不希望被高优先级的任务打断&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;           &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;它不能使用：
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            taskENTER_CRITICAL ()/taskEXIT_CRITICAL()的长度
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            因为操作可能会导致中断被错过
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;           &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;防止实时内核交换任务。&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;          vTaskSuspendAll ();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里开始做你想做的不会被打断的工作
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这段时间里，中断仍然会发生
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;时间内核滴答计数将被维护。
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;工作完成后
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新启动内核，我们想要强制
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上下文切换——但是如果恢复调度器是没有意义的
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经导致了上下文切换。&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;xTaskResumeAll ())
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;          {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                taskYIELD ();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;强制切换一次上下文，让高优先级的抢占&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;删除任务&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;必须将INCLUDE_vTaskDelete定义为1才能使用此功能&lt;/p&gt;
&lt;p&gt;从RTOS实时内核的管理中删除任务。&lt;/p&gt;
&lt;p&gt;要删除的任务将从所有准备就绪，阻止，暂停和事件列表中删除&lt;/p&gt;
&lt;p&gt; 参数：&lt;/p&gt;
&lt;p&gt;任务句柄，将删除指定任务，如果传递值为NULL,则删除调用任务删除的当前任务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; vTaskDelete(TaskHandle_txTaskToDelete)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;延时&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;将任务延迟给定的滴答数。&lt;/p&gt;
&lt;p&gt;任务保持阻塞的实际时间取决于滴答率。常数portTICK_PERIOD_MS可用于根据滴答速率计算实时时间-分辨率为一个滴答周期。&lt;/p&gt;
&lt;p&gt;vTaskDelay（）指定相对于调用vTaskDelay（）的时间，任务希望解除阻塞的时间。例如，将阻止时间段指定为100个滴答声将导致任务在调用vTaskDelay（）之后取消阻止100个滴答声。因此，vTaskDelay（）不能提供一种控制周期性任务频率的好方法，因为通过代码的路径以及其他任务和中断活动将影响vTaskDelay（）的调用频率，从而影响时间接下来执行任务的位置。请参阅vTaskDelayUntil（），了解旨在简化固定频率执行的替代API函数。它通过指定调用任务应解除阻止的绝对时间（而不是相对时间）来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法1相对延时函数 vTaskDelay：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;必须将INCLUDE_vTaskDelay定义为1，此功能才可用。&lt;/p&gt;
&lt;p&gt;参数：xTicksToDelay：调用任务应阻塞的时间（以滴答周期为单位）&lt;/p&gt;
&lt;p&gt;vTaskDelay函数传递的参数是延时几个息屏节拍，查看系统时钟，系统时钟是1KHZ,那么系统延时一个节拍就是1MS&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vTaskDelay(&lt;span&gt;1000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时1000ms=1S&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;方法2绝对延时函数vTaskDelayUntil：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;必须将INCLUDE_vTaskDelayUntil定义为1，此功能才可用。&lt;/p&gt;
&lt;p&gt;TickType_t xLastWakeTime是类似用来记录开始时间的句柄&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
TickType_t xLastWakeTime =&lt;span&gt; xTaskGetTickCount();
vTaskDelayUntil( &lt;/span&gt;&amp;amp;xLastWakeTime, (&lt;span&gt;1000&lt;/span&gt; / portTICK_PERIOD_MS); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时1000ms=1S&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;两个比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vTaskDelayUntil与vTaskDelay（）不同：vTaskDelay（）将导致任务从调用vTaskDelay（）时起以指定的滴答数阻塞。因此，很难单独使用vTaskDelay（）来生成固定的执行频率，因为任务开始执行与调用vTaskDelay（）的任务之间的时间可能不固定[该任务可能采用不同的路径，尽管调用之间的代码不同，或者每次执行时可能被打断或抢占不同的次数]。vTaskDelay（）指定相对于调用该函数的时间的唤醒时间，而vTaskDelayUntil（）指定其希望解除阻止的绝对（精确）时间。&lt;/p&gt;
&lt;p&gt;xTicksToDelay延时只是交出CPU时间比如说20MS，但是它没计算这个任务本身运行消耗的时间和其它中间环节耗用的时间，获取在执行时被高优先级打断可能，因此它的延时是个大概值，具有不确定性；第2个就不一样了，你可以把它想像成一个时钟，比方说它记录了下上次延时的时候是9.30分钟，你再次延时30分钟，那么它在10：00就是准时切换成本次任务，所以说它是比较精准的延时。&lt;a href=&quot;https://bbs.21ic.com/icview-412527-1-1.html&quot;&gt;https://bbs.21ic.com/icview-412527-1-1.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;设置任务优先级&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;必须将INCLUDE_vTaskPrioritySet定义为1才能使用此功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;参数1：任务句柄&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数2：新的优先级，与创建任务时的【uxPriority】类似&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt; 获取任务优先级&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 必须将INCLUDE_uxTaskPriorityGet定义为1才能使用此功能&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;任务句柄，将指定获取某个任务的优先级，如果传递值为NULL,则获取调用该函数的当前任务的优先级值&lt;/p&gt;
&lt;p&gt;任务中使用函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
UBaseType_t uxTaskPriorityGet（TaskHandle_t xTask ）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;中断服务中使用函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
UBaseType_t uxTaskPriorityGetFromISR（TaskHandle_t xTask ）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;小试牛刀&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;------
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动任务2，标准&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     TaskHandle_t xHandle2 =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数，名字，字节大小，参数，优先级[0,25-1](最高优先为configMAX_PRIORITIES – 1),任务句柄&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     BaseType_t t2res=xTaskCreate(Task_Run_2,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DONG Task_Run_2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;,(&lt;span&gt;void&lt;/span&gt; *)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&amp;amp;&lt;span&gt;xHandle2);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(t2res==&lt;span&gt;pdPASS){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务2启动成功....\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     UBaseType_t t2pri=uxTaskPriorityGet(xHandle2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取任务2的优先级，输出5&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     UBaseType_t thispri=uxTaskPriorityGet(NULL);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取main函数的优先级，输出1&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t2任务的优先级为：%d,当前任务(main)的优先级为：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,t2pri,thispri);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         vTaskDelay(&lt;span&gt;1000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时1S&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;查询任务状态&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;必须将INCLUDE_eTaskGetState定义为1才能使用此功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值：&lt;/strong&gt; enum 枚举类型&lt;/p&gt;
&lt;p&gt;eNoAction= 0，/*运行态，任务正在查询自身的状态，所以必须运行。* /&lt;/p&gt;
&lt;p&gt;eReady, / * 就绪态，被查询的任务在已读或暂挂的就绪列表中。* /&lt;/p&gt;
&lt;p&gt;eBlocked, / * 阻塞态，被查询的任务处于阻塞状态。* /&lt;/p&gt;
&lt;p&gt;eSuspended, / *挂起态，被查询的任务处于挂起状态，或者处于阻塞状态，超时时间为无限。* /&lt;/p&gt;
&lt;p&gt;edeleted / * !&amp;lt;正在查询的任务已被删除，但其TCB尚未被释放。* /&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;-----------
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动任务2，标准&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     TaskHandle_t xHandle2 =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数，名字，字节大小，参数，优先级[0,25-1](最高优先为configMAX_PRIORITIES – 1),任务句柄&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     BaseType_t t2res=xTaskCreate(Task_Run_2,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DONG Task_Run_2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;,(&lt;span&gt;void&lt;/span&gt; *)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&amp;amp;&lt;span&gt;xHandle2);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(t2res==&lt;span&gt;pdPASS){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务2启动成功....\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     eTaskState t2_sta=&lt;span&gt;eTaskGetState(xHandle2);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t2任务的运行状态：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,t2_sta);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出 2&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         vTaskDelay(&lt;span&gt;1000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时1S&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;暂停（挂起）任务&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;必须将INCLUDE_vTaskSuspend定义为1，此功能才可用。&lt;/p&gt;
&lt;p&gt;然后暂停后如同播放音乐是按下了暂停键，当恢复时将会从暂停处再次开始执行，并不会重新开始于while循环外，所以暂停是会保留上下文的。&lt;/p&gt;
&lt;p&gt;暂停任务后，无论其优先级如何，任务将永远不会获得任何微控制器处理时间。&lt;/p&gt;
&lt;p&gt;对vTaskSuspend的调用不是累积性的-即，在同一任务上两次或两次以上调用vTaskSuspend（）仍然只需要对vTaskResume（）进行一次调用即可准备挂起的任务。&lt;/p&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;任务句柄，如果是NULL,则表示挂起调用该函数的任务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; vTaskSuspend( TaskHandle_t xTaskToSuspend )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;恢复暂停（挂起）的任务&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;必须将INCLUDE_vTaskSuspend定义为1，此功能才可用。&lt;/p&gt;
&lt;p&gt;通过一次调用vTaskResume（），已被一个或多个vTaskSuspend（）调用暂停的任务将可以再次运行&lt;/p&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;任务句柄，如果是NULL,则表示挂起调用该函数的任务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; vTaskResume( TaskHandle_t xTaskToResume )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;中断服务中恢复暂停（挂起）的任务&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;必须将INCLUDE_xTaskResumeFromISR定义为1，此功能才可用。&lt;/p&gt;
&lt;p&gt;通过一次调用xTaskResumeFromISR（），已被一个或多个vTaskSuspend（）调用暂停的任务将可以再次运行。&lt;/p&gt;
&lt;p&gt;如果在挂起任务之前中断可能到达，则xTaskResumeFromISR（）不应用于将任务与中断同步-因为这可能导致中断丢失。使用信号量作为同步机制可以避免这种情况的发生。&lt;/p&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;p&gt;如果继续执行任务，则为pdTRUE，这将导致上下文切换，否则为pdFALSE。ISR使用它来确定在ISR之后是否可能需要上下文切换。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;获取任务系统总数量&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;实时内核当前正在管理的任务数。这包括所有准备就绪，已阻止和已暂停的任务。空闲任务已删除但尚未释放的任务也将包括在计数中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
UBaseType_t tasknum=&lt;span&gt;uxTaskGetNumberOfTasks();
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;系统任务总数量：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,tasknum);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;获取任务的名称&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;必须将FreeRTOSConfig.h中的INCLUDE_pcTaskGetTaskName设置为1，pcTaskGetTaskName（）才可用&lt;/p&gt;
&lt;p&gt;返回任务创建时给的的任务名称&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;任务句柄，传递NULL表示当前调用函数任务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
{&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; *main_task=&lt;span&gt; pcTaskGetTaskName(NULL);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前任务的名称是：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,main_task);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前任务的名称是：main&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;获取系统时间计数器值&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;返回调用调用vTaskStartScheduler（）以来的滴答计数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务中使用&lt;/span&gt;
TickType_t xTaskGetTickCount( &lt;span&gt;void&lt;/span&gt;&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断服务函数使用&lt;/span&gt;
TickType_t xTaskGetTickCountFromISR( &lt;span&gt;void&lt;/span&gt; )
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;小试牛刀&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200405224131118-1030383013.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/FreeRTOS.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freertos相关&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/task.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务0处理函数&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Task_Run_0(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      TickType_t counts=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         counts=&lt;span&gt;xTaskGetTickCount();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】系统任务计数器值：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,counts);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         vTaskDelay(&lt;span&gt;3000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时1S&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--------------DONGIXAODONG FreeRTOS-----------------\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动任务0，简化
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数，名字，字节大小，参数，优先级[0,25-1](最高优先为configMAX_PRIORITIES – 1),任务句柄&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     BaseType_t t0res=xTaskCreate(Task_Run_0,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DONG Task_Run_0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;,NULL,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,NULL);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(t0res==&lt;span&gt;pdPASS){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0启动成功....\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;    TickType_t counts=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         counts=&lt;span&gt;xTaskGetTickCount();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】系统任务计数器值：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,counts);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         vTaskDelay(&lt;span&gt;1000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时1S&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;MsoNormal&quot;&gt;&lt;span&gt;任务堆栈使用的高水位线中断服务&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;要使此功能可用，必须在&lt;span lang=&quot;EN-US&quot;&gt;FreeRTOSConfig.h&lt;/span&gt;中将&lt;span lang=&quot;EN-US&quot;&gt;INCLUDE_uxTaskGetStackHighWaterMark&lt;/span&gt;设置为&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;自任务开始以来，高水位标记是已存在的最小可用堆栈空间，后面将会保留最高使用率（以字节为单位，而不是原始&lt;span lang=&quot;EN-US&quot;&gt;FreeRTOS&lt;/span&gt;中的单词）。返回的数字越小，任务越接近其堆栈溢出。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;参数：&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;与要检查的堆栈关联的任务的句柄。将&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;xTask&lt;/span&gt;&lt;span&gt;设置为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;NULL&lt;/span&gt;&lt;span&gt;可检查调用任务的堆栈。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;返回：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;自创建&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;xTask&lt;/span&gt;&lt;span&gt;引用的任务以来，可用堆栈空间最小值（以字节为单位，而不是原始&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;FreeRTOS&lt;/span&gt;&lt;span&gt;中的字数）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;MsoNormal&quot;&gt;&lt;span&gt;获取系统中的所有任务信息&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;必须在&lt;span lang=&quot;EN-US&quot;&gt;FreeRTOSConfig.h&lt;/span&gt;中将&lt;span lang=&quot;EN-US&quot;&gt;configUSE_TRACE_FACILITY&lt;/span&gt;定义为&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;，才能使&lt;span lang=&quot;EN-US&quot;&gt;uxTaskGetSystemState&lt;/span&gt;（）可用。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;uxTaskGetSystemState&lt;/span&gt;（）为系统中的每个任务填充&lt;span lang=&quot;EN-US&quot;&gt;TaskStatus_t&lt;/span&gt;结构。&lt;span lang=&quot;EN-US&quot;&gt;TaskStatus_t&lt;/span&gt;结构包含任务句柄的成员，任务名称，任务优先级，任务状态以及任务消耗的运行时间总量。有关完整的成员列表，请参见此文件中的&lt;span lang=&quot;EN-US&quot;&gt;TaskStatus_t&lt;/span&gt;结构定义。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;注意：此功能仅用于调试用途，因为其使用会导致调度程序长时间处于挂起状态。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;参数：&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;pxTaskStatusArray&lt;/span&gt;：指向&lt;span lang=&quot;EN-US&quot;&gt;TaskStatus_t&lt;/span&gt;结构数组的指针。对于受&lt;span lang=&quot;EN-US&quot;&gt;RTOS&lt;/span&gt;控制的每个任务，该数组必须至少包含一个&lt;span lang=&quot;EN-US&quot;&gt;TaskStatus_t&lt;/span&gt;结构。可以使用&lt;span lang=&quot;EN-US&quot;&gt;uxTaskGetNumberOfTasks&lt;/span&gt;（）&lt;span lang=&quot;EN-US&quot;&gt;API&lt;/span&gt;函数来确定&lt;span lang=&quot;EN-US&quot;&gt;RTOS&lt;/span&gt;控制下的任务数。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;uxArraySize&lt;/span&gt;：&lt;span lang=&quot;EN-US&quot;&gt;pxTaskStatusArray&lt;/span&gt;参数指向的数组的大小。该大小指定为数组中的索引数，或者数组中包含的&lt;span lang=&quot;EN-US&quot;&gt;TaskStatus_t&lt;/span&gt;结构数，而不是数组中的字节数。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;pulTotalRunTime&lt;/span&gt;：如果在&lt;span lang=&quot;EN-US&quot;&gt;FreeRTOSConfig.h&lt;/span&gt;中将&lt;span lang=&quot;EN-US&quot;&gt;configGENERATE_RUN_TIME_STATS&lt;/span&gt;设置为&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;，则&lt;span lang=&quot;EN-US&quot;&gt;* pulTotalRunTime&lt;/span&gt;由&lt;span lang=&quot;EN-US&quot;&gt;uxTaskGetSystemState&lt;/span&gt;（）设置为总运行时间（由运行时间统计时钟定义，请参见&lt;span lang=&quot;EN-US&quot;&gt;http://www.freertos.org/rtos-run-&lt;/span&gt;自目标启动以来。&lt;span lang=&quot;EN-US&quot;&gt;time-stats.html&lt;/span&gt;）。可以将&lt;span lang=&quot;EN-US&quot;&gt;pulTotalRunTime&lt;/span&gt;设置为&lt;span lang=&quot;EN-US&quot;&gt;NULL&lt;/span&gt;以省略总运行时间信息。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;返回：&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;uxTaskGetSystemState&lt;/span&gt;（）填充的&lt;span lang=&quot;EN-US&quot;&gt;TaskStatus_t&lt;/span&gt;结构的数量。该值应等于&lt;span lang=&quot;EN-US&quot;&gt;uxTaskGetNumberOfTasks&lt;/span&gt;（）&lt;span lang=&quot;EN-US&quot;&gt;API&lt;/span&gt;函数返回的数字，但如果&lt;span lang=&quot;EN-US&quot;&gt;uxArraySize&lt;/span&gt;参数中传递的值太小，则该数字将为零。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;任务信息结构体&lt;span lang=&quot;EN-US&quot;&gt;TaskStatus_t&lt;/span&gt;：&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;TaskHandle_t xHandle;/ * !&amp;lt;&lt;/span&gt;结构中其余信息所涉及的任务的句柄。&lt;span lang=&quot;EN-US&quot;&gt;* /&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;const char * pcTaskName;/ * !&amp;lt;&lt;/span&gt;指向任务名称的指针。如果任务被删除，则此值无效，因为该结构已被填充&lt;span lang=&quot;EN-US&quot;&gt;!*/ /*lint !e971&lt;/span&gt;不合格的字符类型只允许用于字符串和单个字符。&lt;span lang=&quot;EN-US&quot;&gt;* /&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;UBaseType_t xTaskNumber;/ * !&amp;lt;&lt;/span&gt;任务编号，越小表示越早被创建&lt;span lang=&quot;EN-US&quot;&gt;* /&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;eTaskState eCurrentState;/ * !&amp;lt;&lt;/span&gt;结构被填充时任务存在的状态。&lt;span lang=&quot;EN-US&quot;&gt;* /&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;UBaseType_t uxCurrentPriority;/ * !&amp;lt;&lt;/span&gt;结构被填充时任务运行的优先级&lt;span lang=&quot;EN-US&quot;&gt;(&lt;/span&gt;可能是继承的&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;。&lt;span lang=&quot;EN-US&quot;&gt;* /&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;UBaseType_t uxBasePriority;/ * !&amp;lt;&lt;/span&gt;如果继承了任务当前的优先级，任务将返回的优先级，以避免在获取互斥锁时发生无界的优先级反转。只有在&lt;span lang=&quot;EN-US&quot;&gt;FreeRTOSConfig.h&lt;/span&gt;中将&lt;span lang=&quot;EN-US&quot;&gt;configUSE_MUTEXES&lt;/span&gt;定义为&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;时才有效。&lt;span lang=&quot;EN-US&quot;&gt;* /&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;uint32_t ulRunTimeCounter;/ * !&amp;lt;&lt;/span&gt;到目前为止分配给任务的总运行时间，由运行时统计时钟定义。见&lt;span lang=&quot;EN-US&quot;&gt;http://www.freertos.org/rtos-run-time-stats.html&lt;/span&gt;。只有在&lt;span lang=&quot;EN-US&quot;&gt;FreeRTOSConfig.h&lt;/span&gt;中将&lt;span lang=&quot;EN-US&quot;&gt;configGENERATE_RUN_TIME_STATS&lt;/span&gt;定义为&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;时才有效。&lt;span lang=&quot;EN-US&quot;&gt;* /&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;StackType_t * pxStackBase;/ * !&amp;lt;&lt;/span&gt;指向任务堆栈区域的最低地址。&lt;span lang=&quot;EN-US&quot;&gt;* /&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;uint32_t usStackHighWaterMark;/ * !&amp;lt;&lt;/span&gt;自任务创建以来为该任务保留的最小堆栈空间量。该值越接近于零，任务就越接近溢出其堆栈。&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
UBaseType_t uxTaskGetSystemState( TaskStatus_t * &lt;span&gt;const&lt;/span&gt; pxTaskStatusArray, &lt;span&gt;const&lt;/span&gt; UBaseType_t uxArraySize, uint32_t * &lt;span&gt;const&lt;/span&gt; pulTotalRunTime )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;小试牛刀&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;configUSE_TRACE_FACILITY定义为1&lt;/p&gt;
&lt;p&gt;configUSE_MUTEXES定义为1&lt;/p&gt;
&lt;p&gt;configGENERATE_RUN_TIME_STATS定义为0，所以下面输出的时间是无效的&lt;/p&gt;
&lt;p&gt;//输出值：任务名称，优先级，运行时间，系统运行时间&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200405224653202-412036446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DONG Task_Run_0我创建的任务&lt;/p&gt;
&lt;p&gt;Main主函数任务&lt;/p&gt;
&lt;p&gt;Tmr Svc  定时器任务&lt;/p&gt;
&lt;p&gt;IDLE1 空闲任务&lt;/p&gt;
&lt;p&gt;IDLE0 空闲任务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/FreeRTOS.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freertos相关&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/task.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有任务并显示
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;configUSE_TRACE_FACILITY 设置为1&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show_task()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;volatile&lt;/span&gt; UBaseType_t uxArraySize, x;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储任务数量,x为for循环所使用的变量&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;      uint32_t ulTotalRunTime;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;运行时间存储
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取系统的任务数量&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;      uxArraySize =&lt;span&gt; uxTaskGetNumberOfTasks();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;申请内存空间以存储用户信息&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;      TaskStatus_t * pxTaskStatusArray = pvPortMalloc( uxArraySize * &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;( TaskStatus_t ) );
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果申请成功&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt;( pxTaskStatusArray !=&lt;span&gt; NULL )
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始获取所有任务信息，参数（任务信息存储空间，获取的任务数量，存储系统运行时间），返回值为数量&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;           uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &amp;amp;&lt;span&gt;ulTotalRunTime );
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环获取的任务数量输出&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;           &lt;span&gt;for&lt;/span&gt;( x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; uxArraySize; x++&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;          {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出值：任务名称，优先级，运行时间，系统运行时间&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\t\t%d\t\t%d\t\t%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].uxCurrentPriority, pxTaskStatusArray[ x ].ulRunTimeCounter, ulTotalRunTime );
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不再需要该数组，释放它所消耗的内存。&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;          vPortFree( pxTaskStatusArray );
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务0处理函数&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Task_Run_0(){
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;      show_task();&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/任务查询&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;      &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】创建任务\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         vTaskDelay(&lt;span&gt;3000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时1S&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--------------DONGIXAODONG FreeRTOS-----------------\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动任务0，简化
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数，名字，字节大小，参数，优先级[0,25-1](最高优先为configMAX_PRIORITIES – 1),任务句柄&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     BaseType_t t0res=xTaskCreate(Task_Run_0,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DONG Task_Run_0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;,NULL,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,NULL);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(t0res==&lt;span&gt;pdPASS){
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0启动成功....\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     
&lt;span&gt;53&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】主任务\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         vTaskDelay(&lt;span&gt;1000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时1S&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;列出所有任务的一些信息&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;为了使此功能可用，必须将configUSE_TRACE_FACILITY和configUSE_STATS_FORMATTING_FUNCTIONS都定义为1&lt;/p&gt;
&lt;p&gt;列出所有当前任务，以及它们的当前状态和堆栈使用率高水位标记。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;此功能将在其持续时间内禁用中断。它不适合正常的应用程序运行时使用，而是作为调试辅助。&lt;/p&gt;
&lt;p&gt;任务报告为已阻止（'B'），就绪（'R'），已删除（'D'）或已暂停（'S'）。&lt;/p&gt;
&lt;p&gt;vTaskList（）调用uxTaskGetSystemState（），然后将uxTaskGetSystemState（）输出的一部分格式化为人类可读的表，以显示任务名称，状态和堆栈使用情况。&lt;/p&gt;
&lt;p&gt;建议生产系统直接调用uxTaskGetSystemState（）以获得对原始统计数据的访问，而不是通过调用vTaskList（）间接进行。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;pcWriteBuffer：一个缓冲区，上面提到的详细信息将以ASCII形式写入其中。假定此缓冲区足够大以包含生成的报告。每个任务大约40个字节就足够了。&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;任务名称、任务状态、任务优先级、任务堆栈历史最小剩余量、任务编号（越先开启值越低）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
void vTaskList（ &lt;span&gt;char&lt;/span&gt; * pcWriteBuffer ）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;小试牛刀&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出：名称、状态、优先级、历史最小剩余堆栈、任务编号&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200405224853184-381515438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt; reslist[&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;];
vTaskList(reslist);
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取任务详情：\r\n%s\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,reslist);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;获取任务运行时间百分比&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;configGENERATE_RUN_TIME_STATS和configUSE_STATS_FORMATTING_FUNCTIONS需要设置为1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; vTaskGetRunTimeStats( &lt;span&gt;char&lt;/span&gt; *pcWriteBuffer )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;小试牛刀&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;//输出任务名称，运行时间，所占系统运行时间比例&lt;/p&gt;
&lt;p&gt;IDLE1 空闲任务&lt;/p&gt;
&lt;p&gt;IDLE0 空闲任务&lt;/p&gt;
&lt;p&gt;空闲任务运行时间占比越大越好，如果有某个任务所暂用运行时间百分比大的话，需要考虑将任务拆分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200405225003904-1271037105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt; reslist[&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;];
vTaskGetRunTimeStats(reslist);
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取任务运行时间：\r\n%s\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,reslist);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;消息队列&lt;/h2&gt;
&lt;p&gt;头文件：freertos / include / freertos / queue.h&lt;/p&gt;
&lt;p&gt;队列是为了任务与任务、任务与中断之间的通信而准备的,可以在任务与任务、任务与中断之间传递消息,队列中可以存储有限的、大小固定的数据项目。任务与任务、任务与中断之间要交流的数据保存在队列中,叫做队列项目。队列所能保存的最大数据项目数量叫做队列的长度,创建队列的时候会指定数据项目的大小和队列的长度。由于队列用来传递消息的,所以也称为消息队列。FreeRTOS中的信号量的也是依据队列实现的!所以有必要深入的了解FreeRTOS的队列。&lt;/p&gt;
&lt;p&gt;队列通常时先进先出的，也可以设置为先进后出，FreeRTOS中队列通常传递的是内容，而不是指针&lt;/p&gt;
&lt;p&gt;入队：&lt;/p&gt;
&lt;p&gt;队列中没有消息，可以设置为不等待立即返回，等待指定时间节拍、一直等待有空位&lt;/p&gt;
&lt;p&gt;出队：&lt;/p&gt;
&lt;p&gt;队列满了会阻塞，可以设置为不等待立即返回、等待指定的时间节拍、一直等待有消息为止&lt;/p&gt;
&lt;h3 class=&quot;MsoNormal&quot;&gt;&lt;span&gt;队列创建&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;创建一个新的队列实例。这将分配新队列所需的存储，并返回该队列的句柄。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;参数：&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;uxQueueLength&lt;/span&gt; 队列可以存储的条数，队列可以包含的最大项目数。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;unsigned int uxItemSize&lt;/span&gt; 队列中每条的最大存储字节，队列中每个项目所需的字节数。项目按副本而不是引用排队，因此这是将为每个过账项目复制的字节数。队列中的每个项目都必须具有相同的大小。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;返回：&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;如果创建成功则返回队列句柄，无法创建则返回&lt;span lang=&quot;EN-US&quot;&gt;0&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
QueueHandle_t  xQueueCreate( uxQueueLength, uxItemSize )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;发送消息到队列中&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;将项目发布到队列中。该项目按副本而不是参考排队。不得从中断服务程序中调用此函数。有关在ISR中可以使用的替代方法，请参见xQueueSendFromISR（）&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xQueue：要发布项目的队列的句柄。&lt;/p&gt;
&lt;p&gt;pvItemToQueue：内容，指向要放在队列中的项目的指针。创建队列时已定义了队列将要容纳的项目大小，因此，这许多字节将从pvItemToQueue复制到队列存储区域。&lt;/p&gt;
&lt;p&gt;xTicksToWait：如果任务已满，则该任务应阻止等待队列上的可用空间的最长时间。如果将其设置为0并且队列已满，则呼叫将立即返回。时间以滴答周期定义，因此如果需要，应使用常数portTICK_PERIOD_MS转换为实时。portMAX_DELAY表示一直等待&lt;/p&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;p&gt;如果项目已成功发布，则为pdTRUE，否则为errQUEUE_FULL。&lt;/p&gt;
&lt;p&gt;官方手册建议使用函数如下：&lt;/p&gt;
&lt;p&gt;发送消息到队列头：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
BaseType_t  xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送消息到队列尾&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
BaseType_t  xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送到消息队列尾&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
BaseType_t  xQueueSend( xQueue, pvItemToQueue, xTicksToWait )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面三个函数本质上调用了xQueueGenericSend&lt;/p&gt;
&lt;p&gt;其最后一个参数：&lt;/p&gt;
&lt;p&gt;xCopyPosition：可以使用值queueSEND_TO_BACK将项目放置在队列的后面，或将queueSEND_TO_FRONT放置在队列的前面（对于高优先级消息）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )

&lt;span&gt;#define&lt;/span&gt; xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )

&lt;span&gt;#define&lt;/span&gt; xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;发送消息到队列中（复写）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;仅用于长度为1的队列-因此队列为空或已满。&lt;/p&gt;
&lt;p&gt;将项目发布到队列中。如果队列已满，则覆盖队列中保存的值。该项目按副本而不是参考排队。&lt;/p&gt;
&lt;p&gt;不得从中断服务程序中调用此函数。有关可以在ISR中使用的替代方法，请参见xQueueOverwriteFromISR（）。&lt;/p&gt;
&lt;p&gt;xQueueOverwrite（）是一个宏，它调用xQueueGenericSend（），因此具有与xQueueSendToFront（）相同的返回值。但是，pdPASS是唯一可以返回的值，因为即使队列已满，xQueueOverwrite（）也会写入队列&lt;/p&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;xQueue：将数据发送到的队列的句柄。&lt;/p&gt;
&lt;p&gt;pvItemToQueue：指向要放在队列中的项目的指针。创建队列时已定义了队列将要容纳的项目大小，因此，这许多字节将从pvItemToQueue复制到队列存储区域。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t  xQueueOverwrite（ xQueue，pvItemToQueue ）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其本质调用的函数为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; xQueueOverwrite( xQueue, pvItemToQueue ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;中断服务函数中发消息到队列&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;将项目发布到队列中。在中断服务程序中可以安全地使用此功能。&lt;/p&gt;
&lt;p&gt;项目通过复制而不是引用进行排队，因此最好仅将小项目排队，尤其是从ISR调用时。在大多数情况下，最好存储一个指向正在排队的项目的指针。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xQueue：要发布项目的队列的句柄&lt;/p&gt;
&lt;p&gt;pvItemToQueue：内容，指向要放在队列中的项目的指针。创建队列时已定义了队列将要容纳的项目大小，因此，这许多字节将从pvItemToQueue复制到队列存储区域。&lt;/p&gt;
&lt;p&gt;pxHigherPriorityTaskWoken：判断是否需要手动切换上下文，如果发送到队列导致任务取消阻止，并且未阻止的任务的优先级高于当前运行的任务，则xQueueGenericSendFromISR（）会将* pxHigherPriorityTaskWoken设置为pdTRUE。如果xQueueGenericSendFromISR（）将此值设置为pdTRUE，则应在退出中断之前请求上下文切换taskYIELD ();。&lt;/p&gt;
&lt;p&gt;发送消息到队列头&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
BaseType_t  xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送消息到队列尾&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
BaseType_t  xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送到消息队列尾&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
BaseType_t  xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面三个函数本质上调用了xQueueGenericSendFromISR&lt;/p&gt;
&lt;p&gt;其最后一个参数&lt;/p&gt;
&lt;p&gt;xCopyPosition：可以使用值queueSEND_TO_BACK将项目放置在队列的后面，或将queueSEND_TO_FRONT放置在队列的前面（对于高优先级消息）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )

&lt;span&gt;#define&lt;/span&gt; xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )

&lt;span&gt;#define&lt;/span&gt; xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;中断服务函数中发消息到队列（复写）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;可以在中断服务程序（ISR）中使用的xQueueOverwrite（）版本。&lt;/p&gt;
&lt;p&gt;仅用于可容纳单个项目的队列-因此队列为空或已满。&lt;/p&gt;
&lt;p&gt;将项目发布到队列中。如果队列已满，则覆盖队列中保存的值。该项目按副本而不是参考排队。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xQueue：要发布项目的队列的句柄&lt;/p&gt;
&lt;p&gt;pvItemToQueue：指向要放在队列中的项目的指针。创建队列时已定义了队列将要容纳的项目大小，因此，这许多字节将从pvItemToQueue复制到队列存储区域。&lt;/p&gt;
&lt;p&gt;pxHigherPriorityTaskWoken：如果发送到队列导致任务取消阻止，并且未阻止的任务的优先级高于当前运行的任务，则xQueueOverwriteFromISR（）会将* pxHigherPriorityTaskWoken设置为pdTRUE。如果xQueueOverwriteFromISR（）将此值设置为pdTRUE，则应在退出中断之前请求上下文切换。&lt;/p&gt;
&lt;p&gt;返回&lt;/p&gt;
&lt;p&gt;QueueOverwriteFromISR（）是一个调用xQueueGenericSendFromISR（）的宏，因此其返回值与xQueueSendToFrontFromISR（）相同。但是，pdPASS是唯一可以返回的值，因为即使队列已满，xQueueOverwriteFromISR（）也会写入队列。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
BaseType_t  xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本质调用函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt; 获取消息队列消息&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;从队列中接收项目。该项目以副本形式接收，因此必须提供足够大小的缓冲区。创建队列时定义了复制到缓冲区中的字节数。&lt;/p&gt;
&lt;p&gt;不得在中断服务程序中使用此功能。另请参见xQueueReceiveFromISR。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xQueue：要从中接收项目的队列的句柄。&lt;/p&gt;
&lt;p&gt;pvBuffer：指向将接收到的项目复制到的缓冲区的指针。&lt;/p&gt;
&lt;p&gt;xTicksToWait：如果队列在调用时为空，则任务应等待等待接收项目的最长时间。时间以滴答周期定义，因此如果需要，应使用常数portTICK_PERIOD_MS转换为实时。如果队列为空并且xTicksToWait为0，则xQueueGenericReceive（）将立即返回。portMAX_DELAY表示一直等待&lt;/p&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;p&gt;如果从队列成功接收到项目，则为pdTRUE，否则为pdFALSE。&lt;/p&gt;
&lt;p&gt;仅仅取出消息队列中的内容，不删除已经取出的消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
BaseType_t xQueuePeek( xQueue, pvBuffer, xTicksToWait )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取出并删除接收的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
BaseType_t  xQueueReceive( xQueue, pvBuffer, xTicksToWait )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面两个函数本质上调用了xQueueReceiveFromISR&lt;/p&gt;
&lt;p&gt;其最后一个参数&lt;/p&gt;
&lt;p&gt;xJustPeek：当设置为true时，从队列接收的项目实际上并未从队列中删除-意味着对xQueueReceive（）的后续调用将返回相同的项目。设置为false时，将从队列中接收的项目也将从队列中删除。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; xQueuePeek( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdTRUE )

&lt;span&gt;#define&lt;/span&gt; xQueueReceive( xQueue, pvBuffer, xTicksToWait ) xQueueGenericReceive( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), pdFALSE )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;中断服务函数中获取队列消息&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;  xQueuePeekFromISR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以从中断服务程序（ISR）&lt;/p&gt;
&lt;p&gt;仅仅取出消息队列中的内容，不删除已经取出的内容（项目）&lt;/p&gt;
&lt;p&gt;xQueue：要从中接收项目的队列的句柄。&lt;/p&gt;
&lt;p&gt;pvBuffer：指向将接收到的项目复制到的缓冲区的指针&lt;/p&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;p&gt;如果从队列成功接收到项目，则为pdTRUE，否则为pdFALSE。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t xQueuePeekFromISR（QueueHandle_t xQueue，&lt;span&gt;void&lt;/span&gt; * &lt;span&gt;const&lt;/span&gt; pvBuffer ）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;xQueueReceiveFromISR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以从中断服务程序（ISR）取出并删除接收的内容（项目）&lt;/p&gt;
&lt;p&gt;参数&lt;/p&gt;
&lt;p&gt;xQueue：要从中接收项目的队列的句柄。&lt;/p&gt;
&lt;p&gt;pvBuffer：指向将接收到的项目复制到的缓冲区的指针。&lt;/p&gt;
&lt;p&gt;pxHigherPriorityTaskWoken：任务可能等待队列中的可用空间被阻塞。如果xQueueReceiveFromISR使此类任务解除阻止，则* pxTaskWoken将设置为pdTRUE，否则* pxTaskWoken将保持不变。如果值为pdTRUE，则应在退出中断之前请求上下文切换taskYIELD ();。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;此函数比xQueuePeekFromISR多一个参数，是因为如果取出队列数据后，删除该项目可能会使得触发优先级高的任务停止阻塞，所以要查看返回值启动任务切换&lt;/p&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;p&gt;如果从队列成功接收到项目，则为pdTRUE，否则为pdFALSE。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
BaseType_t xQueueReceiveFromISR（QueueHandle_t xQueue，&lt;span&gt;void&lt;/span&gt; * &lt;span&gt;const&lt;/span&gt; pvBuffer，BaseType_t * &lt;span&gt;const&lt;/span&gt; pxHigherPriorityTaskWoken ）
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;获取存储在队列中的消息数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;xQueue：查询队列的句柄&lt;/p&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;p&gt;队列中可用的消息数，未取出的消息数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
UBaseType_t uxQueueMessagesWaiting( &lt;span&gt;const&lt;/span&gt; QueueHandle_t xQueue )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;获取队列的剩余可用条数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;返回队列中可用的可用空间数。这等于如果没有删除任何项目，则在队列变满之前可以发送到队列的项目数&lt;br/&gt;参数：&lt;br/&gt;xQueue：查询队列的句柄&lt;br/&gt;返回：&lt;br/&gt;队列中剩余可用条数（最大为创建任务时的uxQueueLength 值，其表示队列可以存储的条数，队列可以包含的最大项目数。）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
UBaseType_t uxQueueSpacesAvailable( &lt;span&gt;const&lt;/span&gt; QueueHandle_t xQueue )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;队列删除&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;删除队列-释放分配用于存储放置在队列中的项目的所有内存。&lt;/p&gt;
&lt;p&gt;参数：要删除的队列的句柄&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; vQueueDelete( QueueHandle_t xQueue )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;重置队列&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;将队列重置回其原始的空状态。如果成功重置队列，则返回pdPASS。如果无法重置队列，则返回pdFAIL，因为队列上有阻塞的任务正在等待从队列接收或发送到队列，因此无法重置队列。&lt;/p&gt;
&lt;p&gt;参数：xQueue：要重置的队列&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BaseType_t xQueueReset( xQueue )
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;小试牛刀（队列）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202004/1485202-20200405234611876-1223380879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/FreeRTOS.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freertos相关&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/task.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;freertos/queue.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义队列消息，不一定是结构体&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; myMsg
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     uint32_t d_id;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;char&lt;/span&gt; d_msg[&lt;span&gt;50&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储消息队列句柄&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;QueueHandle_t Dong_uint32_Queue, Dong_myMsg_Queue;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建消息队列&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dong_creat_queue()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建能够存储10个uint32_t的队列&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;      Dong_uint32_Queue = xQueueCreate( &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;( uint32_t ) );
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt;( Dong_uint32_Queue == &lt;span&gt;0&lt;/span&gt;&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dong_uint32_Queue 队列创建失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个能够包含10个指向myMsg结构的队列。
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处传递的是结构体，并不是结构体指针&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;      Dong_myMsg_Queue = xQueueCreate( &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; myMsg) );
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;      &lt;span&gt;if&lt;/span&gt;( Dong_myMsg_Queue == &lt;span&gt;0&lt;/span&gt;&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Dong_myMsg_Queue 队列创建失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务0处理函数&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Task_Run_0(){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;      uint32_t resi=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;      &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; myMsg resmymsg;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;      &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n【%s】////////开始接收/////////\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         xQueueReceive(Dong_uint32_Queue,&amp;amp;&lt;span&gt;resi,portMAX_DELAY);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】获取到Dong_uint32_Queue内容：%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,resi);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         xQueueReceive(Dong_myMsg_Queue,&amp;amp;&lt;span&gt;resmymsg,portMAX_DELAY);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】获取到Dong_myMsg_Queue内容：%d(%s)\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,resmymsg.d_id,resmymsg.d_msg);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n【%s】////////完成接收/////////\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主函数，优先级为1&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; app_main()
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--------------DONGIXAODONG FreeRTOS-----------------\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建消息队列&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    dong_creat_queue();
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动任务0，简化
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数，名字，字节大小，参数，优先级[0,16](16最优先),任务句柄&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     BaseType_t t0res=xTaskCreate(Task_Run_0,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DONG Task_Run_0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;,NULL,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,NULL);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(t0res==&lt;span&gt;pdPASS){
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;任务0启动成功....\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;    BaseType_t res=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;    uint32_t i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;    &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; myMsg mymsg;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;赋值&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;           i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;           mymsg.d_id=&lt;span&gt;i;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;           sprintf(mymsg.d_msg,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongxiaodong%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,i);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出发送标志&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n【%s】*****开始发送*******\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送队列1&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt;           res= xQueueGenericSend( Dong_uint32_Queue, ( &lt;span&gt;void&lt;/span&gt; * ) &amp;amp;i,( TickType_t ) &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,queueSEND_TO_BACK );
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt;(res ==&lt;span&gt; pdPASS )
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;          {
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】Dong_uint32_Queue 发送成功\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送队列2&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt;           res= xQueueGenericSend( Dong_myMsg_Queue, ( &lt;span&gt;void&lt;/span&gt; * ) &amp;amp;mymsg, ( TickType_t ) &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, queueSEND_TO_BACK );
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt;(res ==&lt;span&gt; pdPASS )
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;          {
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;                printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】Dong_myMsg_Queue 发送成功\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; 
&lt;span&gt;89&lt;/span&gt;           printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n【%s】*****结束发送*******\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; 
&lt;span&gt;91&lt;/span&gt;           vTaskDelay(&lt;span&gt;3000&lt;/span&gt; / portTICK_PERIOD_MS);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时3S&lt;/span&gt;
&lt;span&gt;92&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;因篇幅问题，剩下相关笔记将于下一篇文章进行总结，剩下部分包括：&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;信号量&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;计时器&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;事件组&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;h3 class=&quot;_mce_tagged_br&quot;&gt;&lt;strong&gt;&lt;span&gt;任务通知&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhidao.baidu.com/question/7412988.html&quot;&gt;https://zhidao.baidu.com/question/7412988.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://www.freertos.org/&quot;&gt;https://www.freertos.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ESP32文档：&lt;a href=&quot;https://docs.espressif.com/projects/esp-idf/en/v4.0/api-reference/system/freertos.html&quot;&gt;https://docs.espressif.com/projects/esp-idf/en/v4.0/api-reference/system/freertos.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正点原子&lt;/p&gt;
</description>
<pubDate>Sun, 05 Apr 2020 16:56:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>把大多数人每个星期的双休过过成了奢侈的节假日放假，把每天23点后定义为自己的自由时间，应该如何去思考这个问题 ？ 双休的两天里，不！是放假的两天里，终于有较长的时间好好的学习一下一直断断续续的Free</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dongxiaodong/p/12638655.html</dc:identifier>
</item>
<item>
<title>Prism 源码解读7-导航 - 杜金锋</title>
<link>http://www.cnblogs.com/lovexinyi/p/12640108.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovexinyi/p/12640108.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Prism提供了一个非常强大的功能导航，导航的意思就是指定对应的View显示。这个导航的强大之处有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以设置导航前后的动作&lt;/li&gt;
&lt;li&gt;可以指定View实例的生命周期，可以是否导航到新的View实例&lt;/li&gt;
&lt;li&gt;提供了确认导航接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000637632-690027267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;导航前后均有相应的事件通知&lt;/li&gt;
&lt;li&gt;提供了回退前进的导航功能&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;导航&quot;&gt;导航&lt;/h2&gt;
&lt;p&gt;直接看代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000626352-1033163922.png&quot; alt=&quot;1586101856797&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000626383-762316846.png&quot; alt=&quot;1586101868352&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到直接通过RequstNavigate来请求，参数是View的TypeName&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000626384-1979015239.png&quot; alt=&quot;1586101921254&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转到了Region.RequestNavigate里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000626385-599869801.png&quot; alt=&quot;1586101954617&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这边出现了NavigationService，几乎所有的导航功能都是在这个服务中实现的，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000626384-721979010.png&quot; alt=&quot;1586102614643&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000626384-1258463890.png&quot; alt=&quot;1586101993357&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000626384-533630853.png&quot; alt=&quot;1586102012245&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这边将导航的一些信息封装成NavigationContext,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000626408-175311131.png&quot; alt=&quot;1586102044383&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这出现了第一个功能，实现ICon'firm'NavigationRequest接口，确认导航。&lt;/p&gt;
&lt;p&gt;最后来到了最重要的函数ExecuteNavigation&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000626412-1411393303.png&quot; alt=&quot;1586102124583&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个函数每一行都很重要，每一行都是一个功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000626421-750942260.png&quot; alt=&quot;1586102153448&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用OnNavigateFrom,可以在导航前做一些操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000626422-16049822.png&quot; alt=&quot;1586102182080&quot;/&gt;&lt;/p&gt;
&lt;p&gt;获取导航内容，先从Region的View中找，没找到就到容器中找，然后添加到Region的View。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000626426-1333540151.png&quot; alt=&quot;1586102280441&quot;/&gt;&lt;/p&gt;
&lt;p&gt;激活界面&lt;/p&gt;
&lt;p&gt;创建条目，保存条目，主要用来进行前进后退&lt;/p&gt;
&lt;p&gt;触发导航完成事件。&lt;/p&gt;
&lt;p&gt;整个导航功能的顺序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1078802/202004/1078802-20200406000704969-1976947998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Prism提供的这个导航功能非常强大，但是代码却不复杂，通过一些简单的接口，实现了非常强大的功能。&lt;/p&gt;
</description>
<pubDate>Sun, 05 Apr 2020 16:09:00 +0000</pubDate>
<dc:creator>杜金锋</dc:creator>
<og:description>介绍 Prism提供了一个非常强大的功能导航，导航的意思就是指定对应的View显示。这个导航的强大之处有： 可以设置导航前后的动作 可以指定View实例的生命周期，可以是否导航到新的View实例 提供</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lovexinyi/p/12640108.html</dc:identifier>
</item>
<item>
<title>一文读懂什么是CA证书 - 撒欢</title>
<link>http://www.cnblogs.com/frisk/p/12628159.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/frisk/p/12628159.html</guid>
<description>&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;//&lt;/span&gt;&lt;span&gt;单纯使用公私钥进行加解密，会存在公钥被替换伪造的风险，无法判断公钥是否属于服务提供商。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;//&lt;/span&gt;&lt;span&gt;所以，公钥需要通过&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;机构的认证。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;//CA&lt;/span&gt;&lt;span&gt;机构用自己的私钥，对服务提供商的相关信息及公钥进行加密生成数字证书。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;//&lt;/span&gt;&lt;span&gt;在进行安全连接的时候，服务提供商将证书一同发给用户。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;//&lt;/span&gt;&lt;span&gt;用户收到证书后，从他的&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;认证机构下载证书&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;公钥，验证服务提供商证书的合法性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;//最后，从证书中提取服务商提供的公钥，加、解密信息进行通信。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;名词解释：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt;CA&lt;/span&gt;: Certificate Authority&lt;/span&gt;&lt;span&gt;，证书中心&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;证书授权中心&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;&lt;span&gt;电子认证服务机构，负责管理和签发证书的，受公众信任足够权威的第三方机构，检查证书持有者身份的合法性，并签发证书，以防证书被伪造或篡改。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt;CA&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;证书&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;: CA&lt;/span&gt;颁发的证书&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt; 或数字证书，包含证书拥有者的身份信息，&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;机构签名，公钥等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;证书编码：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt;DER&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;编码&lt;/span&gt;，二进制&lt;span lang=&quot;EN-US&quot;&gt;DER&lt;/span&gt;编码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt;PEM&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;编码&lt;/span&gt;，用于&lt;span lang=&quot;EN-US&quot;&gt;ASCII(BASE64)&lt;/span&gt;编码，文件由&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;&quot;-----BEGIN&quot;&lt;/span&gt;开始，&lt;span lang=&quot;EN-US&quot;&gt;&quot;-----END&quot;&lt;/span&gt;&lt;span&gt;结束。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;证书文件后缀：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt;.pem&lt;/span&gt;(openssl&lt;/span&gt;&lt;span&gt;默认，&lt;span lang=&quot;EN-US&quot;&gt;PEM&lt;/span&gt;编码的文件&lt;span lang=&quot;EN-US&quot;&gt;) &lt;span&gt;.crt&lt;/span&gt;(Unix&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;/&lt;span&gt;Linux&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，&lt;span lang=&quot;EN-US&quot;&gt;DER&lt;/span&gt;或&lt;span lang=&quot;EN-US&quot;&gt;PEM&lt;/span&gt;编码都可以&lt;span lang=&quot;EN-US&quot;&gt;) &lt;span&gt;.cer&lt;/span&gt;(windows&lt;/span&gt;，二进制&lt;span lang=&quot;EN-US&quot;&gt;)&lt;span&gt; &lt;/span&gt; &lt;span&gt;.der&lt;/span&gt;(&lt;/span&gt;二进制&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;秘钥文件：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt;.key&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;服务器证书申请文件&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;证书签名请求文件：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt;.req&lt;span&gt; &lt;/span&gt; .csr&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用&lt;span lang=&quot;EN-US&quot;&gt;openssl&lt;/span&gt;模拟秘钥证书的生成过程&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;  &lt;span&gt;openssl x509工具主要用于输出证书信息, 签署证书请求文件、自签署、转换证书格式等。它就像是一个完整的小型的CA工具箱。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;  1&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;&lt;span&gt;生成&lt;/span&gt;服务器私钥&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;1.1&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;需要经常输入密码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;openssl genrsa -des3 -out server_private.key 2048&lt;/span&gt; &lt;span&gt;会有输入密码的要求&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;1.2&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;去除密码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;openssl rsa -in server_private.key -out server_private.key&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;1.3&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;无密码证书秘钥：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;openssl genrsa -out server_private.key 2048&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt;//1.4.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;生成公钥&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt; //openssl rsa -in server_private.key -pubout -out server_public.key&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt; &lt;span&gt;2&lt;/span&gt;.&lt;/span&gt;生成 服务器证书申请文件&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;&lt;span&gt;证书签名请求文件 &lt;span lang=&quot;EN-US&quot;&gt;.req:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;2.1&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;span&gt;openssl req -new -key server_private.key -out server.req&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span&gt;会让输入&lt;span lang=&quot;EN-US&quot;&gt;Country Name&lt;/span&gt; 填 &lt;span lang=&quot;EN-US&quot;&gt;CN; Common Name&lt;/span&gt; 填 &lt;span lang=&quot;EN-US&quot;&gt;ip&lt;/span&gt; 也可以不填。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt; #&lt;/span&gt;&lt;span&gt;查看&lt;span lang=&quot;EN-US&quot;&gt;server.req&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;2.2&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;span&gt;openssl req -in server.req -text&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;生成&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;私钥：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;3.1&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;span&gt;openssl genrsa -out ca_private.key 2048&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt; &lt;span&gt;4&lt;/span&gt;.&lt;/span&gt;生成 &lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;证书申请文件&lt;span lang=&quot;EN-US&quot;&gt;/&lt;/span&gt;&lt;span&gt;证书签名请求文件 &lt;span lang=&quot;EN-US&quot;&gt;.req:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;4.1&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;span&gt;openssl req -new -key ca_private.key&lt;span&gt; &lt;/span&gt; -out ca_request.req&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt; #&lt;/span&gt;&lt;span&gt;查看&lt;span lang=&quot;EN-US&quot;&gt;ca_request.req&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;4.2&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;span&gt;openssl req -in ca_request.req -text&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;5&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;创建&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;证书，用来给服务器的证书签名&lt;span lang=&quot;EN-US&quot;&gt;:(&lt;/span&gt;这个证书请求本来应由更高级的&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;用它的&lt;span lang=&quot;EN-US&quot;&gt;private key&lt;/span&gt;对这个证书请求进行签发，由于此时模拟的&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;是 &lt;span lang=&quot;EN-US&quot;&gt;root CA&lt;/span&gt;，没有更高级的&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;了，所以要进行自签发，用 自己的&lt;span lang=&quot;EN-US&quot;&gt;private key&lt;/span&gt; 对 自己的证书请求 进行签发。&lt;span lang=&quot;EN-US&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;5.1&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;span&gt;openssl x509 -req -in ca_request.req -signkey ca_private.key -days 365 -out ca.pem&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt; #&lt;/span&gt;&lt;span&gt;查看证书&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;5.2&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;span&gt;openssl x509 -in ca.pem -noout -text&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;6&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.CA&lt;/span&gt;&lt;span&gt;用自己的&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;证书&lt;span lang=&quot;EN-US&quot;&gt;ca.pem&lt;/span&gt; 和 私钥&lt;span lang=&quot;EN-US&quot;&gt;ca_private.key&lt;/span&gt; 为 &lt;span lang=&quot;EN-US&quot;&gt;server.req&lt;/span&gt; 文件签名，生成服务器证书，：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;6.1&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;span&gt;openssl x509 -req -in server.req -CA ca.pem -CAkey ca_private.key -days 365 -CAcreateserial -out server.pem&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt; #&lt;/span&gt;&lt;span&gt;查看证书&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;6.2&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;span&gt;openssl x509 -in server.pem -noout -text&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt; #&lt;/span&gt;&lt;span&gt;查看公钥&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;6.3&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;span&gt;openssl x509 -in server.pem -noout -pubkey&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;7&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;查看服务器证书的&lt;span lang=&quot;EN-US&quot;&gt;modulus&lt;/span&gt;和服务器私钥的&lt;span lang=&quot;EN-US&quot;&gt;modulus&lt;/span&gt;，应该一样：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;7.1&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;span&gt;openssl x509 -in server.pem -noout -modulus&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;7.2&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;span&gt;openssl rsa -in server_private.key -noout -modulus&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;8&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;用户访问&lt;span lang=&quot;EN-US&quot;&gt;https&lt;/span&gt;网站，服务器会用&lt;span lang=&quot;EN-US&quot;&gt;private key&lt;/span&gt;加密数据传输，同时会把证书传给用户，里面有&lt;span lang=&quot;EN-US&quot;&gt;public key&lt;/span&gt;信息，用于解密数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;用户使用公钥机密的时候，要确认此公钥是否是服务商的，是否是受信任的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;用户从服务商证书中发现，其证书是由某&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;签发的，从&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;官网下载他的证书，发现它由 更高级&lt;span lang=&quot;EN-US&quot;&gt;CA&lt;/span&gt;签发 或者 是&lt;span lang=&quot;EN-US&quot;&gt;root&lt;/span&gt;证书，自签发的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;这时就可以一级一级的验证证书的合法性，最终确认服务商的证书是否被信任。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;验证后就可以使用公钥解密信息，进行通信。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;openssl verify -CAfile ca.pem server.pem&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;9&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;. ls&lt;/span&gt; &lt;span&gt;出现以下文件：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt; ca.pem&lt;span&gt; &lt;/span&gt; ca_private.key&lt;span&gt; &lt;/span&gt; ca_request.req&lt;span&gt; &lt;/span&gt; ca.srl&lt;span&gt; &lt;/span&gt; server.pem&lt;span&gt; &lt;/span&gt; server_private.key&lt;span&gt; &lt;/span&gt; server.req&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;10&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;从证书导出公钥&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;openssl x509 -in server.pem -noout -pubkey -out server_public.key&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;11&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;使用公钥加密，私钥解密&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;openssl rsautl -encrypt -in test.txt -inkey server_public.key -pubin -out test_encrypt.txt&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt; openssl rsautl -decrypt -in test_encrypt.txt -inkey server_private.key -out test_decrypt.txt&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;12&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;不想浏览器发出警告，就导入&lt;span lang=&quot;EN-US&quot;&gt;ca.pem&lt;/span&gt;文件&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;13&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;查看证书内容：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt; &lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;13.1&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;打印出证书的内容：&lt;span lang=&quot;EN-US&quot;&gt;openssl x509 -in server.pem -noout -text&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;13.2&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;打印出证书的系列号：&lt;span lang=&quot;EN-US&quot;&gt;openssl x509 -in server.pem -noout -serial&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;13.3&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;打印出证书的拥有者名字：&lt;span lang=&quot;EN-US&quot;&gt;openssl x509 -in server.pem -noout -subject&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;13.4&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;以&lt;span lang=&quot;EN-US&quot;&gt;RFC2253&lt;/span&gt;规定的格式打印出证书的拥有者名字：&lt;span lang=&quot;EN-US&quot;&gt;openssl x509 -in server.pem -noout -subject -nameopt RFC2253&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;13.5&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;打印出证书的&lt;span lang=&quot;EN-US&quot;&gt;MD5&lt;/span&gt;特征参数：&lt;span lang=&quot;EN-US&quot;&gt;openssl x509 -in server.pem -noout -fingerprint&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;13.6&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;打印出证书有效期：&lt;span lang=&quot;EN-US&quot;&gt;openssl x509 -in server.pem -noout -dates&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;13.7&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;打印出证书公钥：&lt;span lang=&quot;EN-US&quot;&gt;openssl x509 -in server.pem -noout -pubkey&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;14&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;证书秘钥要使用相同的编码格式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;15&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt;&lt;span&gt;证书格式转换&lt;span lang=&quot;EN-US&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;  &lt;/span&gt; PEM&lt;/span&gt;&lt;span&gt;转&lt;span lang=&quot;EN-US&quot;&gt;DER&lt;/span&gt;格式：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;openssl x509 -inform pem -in server.pem -outform der -out server.der&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt;   &lt;/span&gt; DER&lt;/span&gt;&lt;span&gt;转&lt;span lang=&quot;EN-US&quot;&gt;PEM&lt;/span&gt;格式：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;openssl x509 -inform der -in server.der -outform pem -out server.pem0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 05 Apr 2020 15:50:00 +0000</pubDate>
<dc:creator>撒欢</dc:creator>
<og:description>Normal 0 7.8 磅 0 2 false false false EN-US ZH-CN X-NONE //单纯使用公私钥进行加解密，会存在公钥被替换伪造的风险，无法判断公钥是否属于服务提供商</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/frisk/p/12628159.html</dc:identifier>
</item>
<item>
<title>Spring的IOC容器学习笔记 - 清风紫雪</title>
<link>http://www.cnblogs.com/xiaofengzai/p/12640003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaofengzai/p/12640003.html</guid>
<description>&lt;p&gt;&lt;span&gt;（一）Spring的IOC学习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在applicationContext.xml来配置bean，通过该接口，在主程序中，可以指定初始化的对象，不需要在进行赋值操作，直接在xml里配置好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来分享的是bean配置的多种方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①通过类的id获取bean&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Spring&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;18&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;男&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在主函数中，通过容器里的id来获取bean对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ApplicationContext aContext=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
user beanUser&lt;/span&gt;=(user)aContext.getBean(&quot;user&quot;&lt;span&gt;);
beanUser.print();&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出该对象的信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202004/1717524-20200405230742053-1026608956.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; ②通过类型获取bean，缺点是只能是一个该类型的bean对象，如果有多个则会出错，多个可以通过id的方式来进行获取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如上面的user对象，在主函数中可以这样获取：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ApplicationContext aContext=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
user beanUser&lt;/span&gt;=aContext.getBean(user.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
beanUser.print();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到的结果和上面的一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、给bean的属性赋值多种操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①直接通过&amp;lt;property name=&quot;name&quot; value=&quot;Spring&quot;&amp;gt;&amp;lt;/property&amp;gt;利用name，value的方式进行赋值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②通过构造器进行赋值，前提在bean类中有该构造函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;user03&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;小明&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;18&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sex&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;男&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;还可以直接省略name属性：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 省略name属性 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;user04&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;校花&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;女&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过索引值指定参数位置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;book&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.atguigu.spring.bean.Book&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
           &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;= &quot;10010&quot;&lt;/span&gt;&lt;span&gt; index &lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
           &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;= &quot;Book01&quot;&lt;/span&gt;&lt;span&gt; index &lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
           &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;= &quot;Author01&quot;&lt;/span&gt;&lt;span&gt; index &lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
           &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;= &quot;20.2&quot;&lt;/span&gt;&lt;span&gt; index &lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
     &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过类型不同区分重载的构造器&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;book&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.atguigu.spring.bean.Book&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;= &quot;10010&quot;&lt;/span&gt;&lt;span&gt; index &lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Integer&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
      &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;= &quot;Book01&quot;&lt;/span&gt;&lt;span&gt; index &lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;java.lang.String&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
      &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;= &quot;Author01&quot;&lt;/span&gt;&lt;span&gt; index &lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;java.lang.String&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
      &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;= &quot;20.2&quot;&lt;/span&gt;&lt;span&gt; index &lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Double&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;p名称空间：为了简化XML文件的配置，越来越多的XML文件采用属性而非子元素配置信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要导入：xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean 
    &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;studentSuper&quot;&lt;/span&gt;&lt;span&gt; 
    class&lt;/span&gt;&lt;span&gt;=&quot;com.atguigu.helloworld.bean.Student&quot;&lt;/span&gt;&lt;span&gt;
    p:studentId&lt;/span&gt;&lt;span&gt;=&quot;2002&quot;&lt;/span&gt;&lt;span&gt; p:stuName&lt;/span&gt;&lt;span&gt;=&quot;Jerry2016&quot;&lt;/span&gt;&lt;span&gt; p:age&lt;/span&gt;&lt;span&gt;=&quot;18&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;三、内部bean对象以及引用对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过&amp;lt;null/&amp;gt;指定空元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引用对象的使用：ref=“引用外部对象的id”&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;car01&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.car&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;宝马&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;蓝白色&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;30000&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;user05&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; ref引用的是外部的bean &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;car01&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;内部bean对象：相当于car=new car(),car对象在user对象里&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;car01&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.car&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;宝马&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;蓝白色&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;30000&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;user05&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 相当于car=new car() 引用内部bean &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.car&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;自行车&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;四、集合属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①List和map&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;List集合里包括：一个自定义的对象，一个引用对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　配置java.util.List类型的属性，需要指定&amp;lt;list&amp;gt;标签，在标签里包含一些元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这些标签可以通过&amp;lt;value&amp;gt;指定简单的常量值，通过&amp;lt;ref&amp;gt;指定对其他Bean的引用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过&amp;lt;bean&amp;gt;指定内置bean定义。通过&amp;lt;null/&amp;gt;指定空元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Map集合里包括：2个value，一个引用，一个自定义对象，都对应着不同的key值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&amp;lt;map&amp;gt;标签里可以使用多个&amp;lt;entry&amp;gt;作为子标签。每个条目包含一个键和一个值。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　必须在&amp;lt;key&amp;gt;标签里定义键。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　因为键和值的类型没有限制，所以可以自由地为它们指定&amp;lt;value&amp;gt;、&amp;lt;ref&amp;gt;、&amp;lt;bean&amp;gt;或&amp;lt;null/&amp;gt;元素。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　可以将Map的键和值作为&amp;lt;entry&amp;gt;的属性定义：简单常量使用key和value来定义；bean引用通过key-ref和value-ref属性定义。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;refbook&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.Book&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;西厢记&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;user06&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;books&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; list标签体中添加每一个元素 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean  &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.Book&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;西游记&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;author&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;吴承恩&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;price&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;80&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;refbook&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;maps&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key01&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;张三&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key02&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;18&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key03&quot;&lt;/span&gt;&lt;span&gt; value-ref&lt;/span&gt;&lt;span&gt;=&quot;refbook&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key04&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.car&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;宝马&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在主函数中，输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
user beanUser2=(user)aContext.getBean(&quot;user06&quot;&lt;span&gt;);
        System.out.println(beanUser2.books);
        System.out.println(beanUser2.maps);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1717524/202004/1717524-20200405233054016-1540477505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;span&gt;②Properties&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&amp;lt;props&amp;gt;定义java.util.Properties，该标签使用多个&amp;lt;prop&amp;gt;作为子标签。每个&amp;lt;prop&amp;gt;标签必须定义key属性&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.atguigu.spring.bean.DataSource&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;properties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;userName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jdbc:mysql:///test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;driverClass&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.mysql.jdbc.Driver&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;③集合类型的bean&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果只能将集合对象配置在某个bean内部，则这个集合的配置将不能重用。我们需要将集合bean的配置拿到外面，供其他bean引用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置集合类型的bean需要引入util名称空间：xmlns:util=&quot;http://www.springframework.org/schema/util&quot;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;util:map &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;myMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key01&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;张三&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key02&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;18&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key03&quot;&lt;/span&gt;&lt;span&gt; value-ref&lt;/span&gt;&lt;span&gt;=&quot;refbook&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key04&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.car&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;宝马&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;util:map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;util:list &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;myList&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.Book&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;myMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;util:list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;五、级联属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;含义：可以控制属性的属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以改变user07下的car的price属性，如果car为引用对象，那么引用对象也会被修改&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 级联属性可以控制属性的属性 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;user07&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.author.bean.user&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;car01&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;car.price&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;900000&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;--------------这就是今天分享的bean的配置操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;明天学习：利用工厂来创建bean&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 05 Apr 2020 15:43:00 +0000</pubDate>
<dc:creator>清风紫雪</dc:creator>
<og:description>（一）Spring的IOC学习 在applicationContext.xml来配置bean，通过该接口，在主程序中，可以指定初始化的对象，不需要在进行赋值操作，直接在xml里配置好。 接下来分享的是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaofengzai/p/12640003.html</dc:identifier>
</item>
<item>
<title>Salesforce LWC学习(十五) Async 以及 Picklist 公用方法的实现 - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/12639564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/12639564.html</guid>
<description>&lt;p&gt;本篇参考：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zero-zyq/p/6251173.html&quot;&gt;salesforce 零基础学习（六十二）获取sObject中类型为Picklist的field values(含record type)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.reference_wire_adapters_picklist_values&quot;&gt;https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.reference_wire_adapters_picklist_values&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.reference_wire_adapters_picklist_values_record&quot;&gt;https://developer.salesforce.com/docs/component-library/documentation/en/lwc/lwc.reference_wire_adapters_picklist_values_record&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Salesforce lwc中给我们提供了很多优秀的wire adapter使我们的开发更加便捷，比如&lt;span&gt;getPicklistValues以及&lt;/span&gt;&lt;code class=&quot; language-javascript&quot;&gt;getPicklistValuesByRecordType &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot; language-javascript&quot;&gt;可以实现获取某个字段或者某个record type所有picklist类型字段的 picklist values。这个组件在便捷的同时又让我们心生哀怨，因为他不是所有的对象都支持，针对常用对象 Account / Opportunity / Contact 或者自定义对象等可以直接使用，方便快捷，但是针对一些对象则不支持，比如 Event &amp;amp; Task。 所以当项目中使用到 Event &amp;amp; Task 进行自定义开发需要获取某个或者某些字段的 picklist values的值时，如果需求不变，我们进行 hard code，将所有的 label-value键值对使用 {label,value}的map进行封装，此种需求只是针对不经常修改的场景。如果需求不明确，或者需要指定的record type显示指定的picklist values，而 record type配置的 picklist values又可以实时变动的场景来说简直是灾难的，所以有了这篇的针对 LwC公用的方法的实现思路。代码并不完善，思路仅供参考。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;思路分析：&lt;/p&gt;
&lt;p&gt;1. 后台如何构建，需要满足哪些场景；&lt;/p&gt;
&lt;p&gt;2. 前台如何搭建，如何做成公用组件使大部分的场景都可以简单引用便可以使用。&lt;/p&gt;
&lt;p&gt;伴随着这两个问题进行了考虑。&lt;/p&gt;
&lt;p&gt;1） 针对后台搭建，暂时满足两个场景&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;针对一个表可以获取到所有的 Picklist类型字段的所有的 Picklist值；&lt;/li&gt;
&lt;li&gt;针对一个表的某个字段(可包含 record type)获取对应的Picklist值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2）针对前台的搭建，因为需要从后台获取数据，需要保证数据获取支持异步处理，即数据处理完进行picklist 数据赋值。&lt;/p&gt;
&lt;p&gt;思路分析以后进行功能的构建，本篇参考以前写过的一篇文章，这里 PicklistDescriber代码便不在放出，直接引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一. 后台搭建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CommonUtilsController：因为Salesforce目前没有针对 包含 record type对应的 Picklist values的特别好的获取方法，所以我们根据以前的XML解析模式进行获取包含record type的场景。 很多人可能会说Salesforce支持了通过user interface方式获取，只需要一个callout就可以获取到包含record type对应的picklist字段对应的values。这种方式其实和wire adapter原理一样，只是针对一部分object，而不是针对所有的object，考虑到组件的共用性，所以放弃了那种方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; without sharing &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CommonUtilsController {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String,Schema.SObjectType&amp;gt; globalDescribeMap =&lt;span&gt; Schema.getGlobalDescribe();

    @AuraEnabled(cacheable&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String,Map&amp;lt;String,String&amp;gt;&amp;gt;&lt;span&gt; getPicklistMapByObject(String objectName) {
        Map&lt;/span&gt;&amp;lt;String,Map&amp;lt;String,String&amp;gt;&amp;gt; resultMap = &lt;span&gt;new&lt;/span&gt; Map&amp;lt;String, Map&amp;lt;String,String&amp;gt;&amp;gt;&lt;span&gt;();
        Schema.DescribeSObjectResult objectResult &lt;/span&gt;=&lt;span&gt; getDescribeObjectResult(objectName);
        Map&lt;/span&gt;&amp;lt;String,SObjectField&amp;gt; fieldsMap =&lt;span&gt; objectResult.fields.getMap();
        Map&lt;/span&gt;&amp;lt;String,Schema.DescribeFieldResult&amp;gt; picklistName2DescribeFieldMap = &lt;span&gt;new&lt;/span&gt; Map&amp;lt;String,Schema.DescribeFieldResult&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String fieldName : fieldsMap.keySet()) {
            SObjectField objField &lt;/span&gt;=&lt;span&gt; fieldsMap.get(fieldName);
            Schema.DescribeFieldResult fieldResult &lt;/span&gt;=&lt;span&gt; objField.getDescribe();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(fieldResult.getType() ==&lt;span&gt; Schema.DisplayType.Picklist) {
                picklistName2DescribeFieldMap.put(fieldName,fieldResult);
            }
        }
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;picklistName2DescribeFieldMap.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String fieldName : picklistName2DescribeFieldMap.keySet()) {
                Schema.DescribeFieldResult fieldResult &lt;/span&gt;=&lt;span&gt; picklistName2DescribeFieldMap.get(fieldName);
                List&lt;/span&gt;&amp;lt;Schema.PicklistEntry&amp;gt; picklistEntries =&lt;span&gt; fieldResult.getPicklistValues();
                Map&lt;/span&gt;&amp;lt;String,String&amp;gt; fieldValue2LabelMap = &lt;span&gt;new&lt;/span&gt; Map&amp;lt;String,String&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Schema.PicklistEntry picklistEntry : picklistEntries) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(picklistEntry.isActive()) {
                        fieldValue2LabelMap.put(picklistEntry.getValue(),picklistEntry.getLabel());
                    }
                }
                resultMap.put(fieldName,fieldValue2LabelMap);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultMap;
    }

    @AuraEnabled(cacheable&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String,String&amp;gt;&lt;span&gt; getPicklistMapByObjectAndField(String objectName,String field,String recordTypeDevelopName) {
        Map&lt;/span&gt;&amp;lt;String,String&amp;gt; resultMap = &lt;span&gt;new&lt;/span&gt; Map&amp;lt;String,String&amp;gt;&lt;span&gt;();
        Schema.DescribeSObjectResult objectResult &lt;/span&gt;=&lt;span&gt; getDescribeObjectResult(objectName);
        Map&lt;/span&gt;&amp;lt;String,SObjectField&amp;gt; fieldsMap =&lt;span&gt; objectResult.fields.getMap();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(fieldsMap.containsKey(field)) {
            SObjectField objField &lt;/span&gt;=&lt;span&gt; fieldsMap.get(field);
            Schema.DescribeFieldResult fieldResult &lt;/span&gt;=&lt;span&gt; objField.getDescribe();
            List&lt;/span&gt;&amp;lt;Schema.PicklistEntry&amp;gt; picklistEntries =&lt;span&gt; fieldResult.getPicklistValues();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Schema.PicklistEntry picklistEntry : picklistEntries) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(picklistEntry.isActive()) {
                    resultMap.put(picklistEntry.getValue(),picklistEntry.getLabel());
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(String.isNotBlank(recordTypeDevelopName)) {
                List&lt;/span&gt;&amp;lt;String&amp;gt; picklistValueWithRecordTypeList =&lt;span&gt; PicklistDescriber.describe(objectName,recordTypeDevelopName,field);
                Map&lt;/span&gt;&amp;lt;String,String&amp;gt; resultForRecordTypeMap = &lt;span&gt;new&lt;/span&gt; Map&amp;lt;String,String&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String picklistValue : picklistValueWithRecordTypeList) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(resultMap.containsKey(picklistValue)) {
                        resultForRecordTypeMap.put(picklistValue,resultMap.get(picklistValue));
                    }
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultForRecordTypeMap;
            }
            
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultMap;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Schema.DescribeSObjectResult getDescribeObjectResult(String objectName) {
        Schema.SObjectType objectType &lt;/span&gt;=&lt;span&gt; globalDescribeMap.get(objectName);
        Schema.DescribeSObjectResult objectResult &lt;/span&gt;=&lt;span&gt; objectType.getDescribe();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; objectResult;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后台就这样搭建完成，暴露了两个方法：getPicklistMapByObject &amp;amp; getPicklistMapByObjectAndField。第一个方法用来获取一个表的所有 Picklist类型字段的label api name对，key为api name，value为picklist的label。我们以 Account表为例，返回的结构类似如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/910966/202004/910966-20200405224554189-73497052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 第二个方法用来获取某个指定object指定字段的 picklist values的获取，有record type则传递，如果不需要record type则传递 null或者不传递即可。针对结果集来说则没有外层的field api name，直接就是 picklist 字段的 api value -&amp;gt; label，这里不做截图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二. 前台搭建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里需要分成两步， 第一步是做一个公用组件来实现 传递相关参数获取指定的我们想得到的结果集。&lt;/p&gt;
&lt;p&gt;picklistUtils.js：封装了两个公用函数，getAllPicklist用于获取object所有的picklist 类型字段的结果集；getFieldPicklistMap用于通过object &amp;amp; field [record type developer name]来获取指定字段的结果集。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
import getPicklistMapByObject from '@salesforce/apex/CommonUtilsController.getPicklistMapByObject'&lt;span&gt;;
import getPicklistMapByObjectAndField from &lt;/span&gt;'@salesforce/apex/CommonUtilsController.getPicklistMapByObjectAndField'&lt;span&gt;;

const getAllPicklist &lt;/span&gt;= (objectAPIName) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;let resultMap = new Map();&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getPicklistMapByObject({objectName:objectAPIName})
            .then(result &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
            })
            .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(error =&amp;gt;&lt;span&gt;{
               console.log(error);
            });
};

const getFieldPicklistMap &lt;/span&gt;= (objectAPIName, fieldAPIName, recordTypeDevelopName) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getPicklistMapByObjectAndField({objectName:objectAPIName,field:fieldAPIName,recordTypeDevelopName:recordTypeDevelopName})
    .then(result &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    })
    .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(error =&amp;gt;&lt;span&gt;{
       console.log(error);
    });
}

export {getAllPicklist,getFieldPicklistMap};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们将代码赋值粘贴到vs code里面，我们会发现他有一个提示： This may be converted to an async function.为什么会有这样的提示呢？是因为我们这个从后台进行结果集获取，此步骤不是实时的，而是一个异步的操作，所以他提示了将会将这个转换成了一个异步的函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/910966/202004/910966-20200405225839167-520043168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这样的解释可能过于干燥，什么是异步的？异步怎么处理呢？这里放一个链接用来更好的理解：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function&lt;/a&gt;。当我们声明了异步函数，调用源调用它时需要使用await去共同使用，从而实现结果集返回时可以正常的接收以及处理。&lt;/p&gt;
&lt;p&gt;AccountPicklistComponent.js：公共组件搞定以后我们写一个组件进行测试，下面的组件只试验了获取所有picklist类型字段的测试，其他的方法感兴趣的自行测试。&lt;/p&gt;
&lt;p&gt;这里的代码有几个关键点需要注意：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;头部需要引入我们需要用到的函数，这里引用的是：import {getAllPicklist} from 'c/picklistUtils';&lt;/li&gt;
&lt;li&gt;我们将生命周期函数connectedCallback使用async声明成了一个异步函数，因为这里我们需要有调用异步的函数使用await，所以方法声明async；&lt;/li&gt;
&lt;li&gt;针对异步的函数接受结果集需要使用await，否则获取的结果集变成了同步操作获取的便是null，只有通过await进行标识才可以正常返回；&lt;/li&gt;
&lt;li&gt;结果集接受操作需要使用临时变量，最后将临时变量赋值给我们需要展示前台的变量，不用临时变量赋值不会进行渲染，因为是异步的操作，没法reactive。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div readability=&quot;20.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
import { LightningElement,track } from 'lwc'&lt;span&gt;;
import {getAllPicklist} from &lt;/span&gt;'c/picklistUtils'&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; class AccountPicklistComponent extends LightningElement {
    @track industryList &lt;/span&gt;=&lt;span&gt; [];

    @track typeList &lt;/span&gt;=&lt;span&gt; [];

    @track accountSourceList &lt;/span&gt;=&lt;span&gt; [];

    @track ratingList &lt;/span&gt;=&lt;span&gt; [];

    async connectedCallback() {
        const result &lt;/span&gt;= await getAllPicklist('Account'&lt;span&gt;);
        console.log(&lt;/span&gt;'total result : ' +&lt;span&gt; JSON.stringify(result));
        let typeTempList &lt;/span&gt;=&lt;span&gt; [];
        let industryTempList &lt;/span&gt;=&lt;span&gt; [];
        let accountSourceTempList &lt;/span&gt;=&lt;span&gt; [];
        let ratingTempList &lt;/span&gt;=&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result) {
            
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result.hasOwnProperty(key)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Filtering the data in the loop&lt;/span&gt;
                
                &lt;span&gt;if&lt;/span&gt;(key === 'type'&lt;span&gt;) {
                    let typeResult &lt;/span&gt;=&lt;span&gt; result[key];
                    console.log(&lt;/span&gt;'type result : ' +&lt;span&gt; JSON.stringify(typeResult));
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let typeValue &lt;span&gt;in&lt;/span&gt;&lt;span&gt; typeResult) {
                        typeTempList.push({label:typeResult[typeValue],value:typeValue});
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(key === 'industry'&lt;span&gt;) {
                    let industryResult &lt;/span&gt;=&lt;span&gt; result[key];
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let industryValue &lt;span&gt;in&lt;/span&gt;&lt;span&gt; industryResult) {
                        industryTempList.push({label:industryResult[industryValue],value:industryValue});
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(key === 'accountsource'&lt;span&gt;) {
                    let accountSourceResult &lt;/span&gt;=&lt;span&gt; result[key];
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let accountSourceValue &lt;span&gt;in&lt;/span&gt;&lt;span&gt; accountSourceResult) {
                        accountSourceTempList.push({label:accountSourceResult[accountSourceValue],value:accountSourceValue});
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(key === 'rating'&lt;span&gt;) {
                    let ratingResult &lt;/span&gt;=&lt;span&gt; result[key];
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let ratingValue &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ratingResult) {
                        ratingTempList.push({label:ratingResult[ratingValue],value:ratingValue});
                    }
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.typeList =&lt;span&gt; typeTempList;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.industryList =&lt;span&gt; industryTempList;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountSourceList =&lt;span&gt; accountSourceTempList;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ratingList =&lt;span&gt; ratingTempList;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;accountPicklistComponent.html：用来展示相关字段的select option&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-card&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-layout &lt;/span&gt;&lt;span&gt;multiple-rows&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-layout-item &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-combobox 
                &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;industry&quot;&lt;/span&gt;&lt;span&gt;
                label&lt;/span&gt;&lt;span&gt;=&quot;industry&quot;&lt;/span&gt;&lt;span&gt;
                options&lt;/span&gt;&lt;span&gt;={industryList}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-combobox&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-layout-item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-layout-item &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-combobox 
                &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;type&quot;&lt;/span&gt;&lt;span&gt;
                label&lt;/span&gt;&lt;span&gt;=&quot;type&quot;&lt;/span&gt;&lt;span&gt;
                options&lt;/span&gt;&lt;span&gt;={typeList}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-combobox&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-layout-item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-layout-item &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-combobox 
                &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;accountSource&quot;&lt;/span&gt;&lt;span&gt;
                label&lt;/span&gt;&lt;span&gt;=&quot;Account Source&quot;&lt;/span&gt;&lt;span&gt;
                options&lt;/span&gt;&lt;span&gt;={accountSourceList}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-combobox&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-layout-item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-layout-item &lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;=&quot;6&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning-combobox 
                &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;rating&quot;&lt;/span&gt;&lt;span&gt;
                label&lt;/span&gt;&lt;span&gt;=&quot;rating&quot;&lt;/span&gt;&lt;span&gt;
                options&lt;/span&gt;&lt;span&gt;={ratingList}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-combobox&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-layout-item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-layout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning-card&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果展示：&lt;/strong&gt;这个表的相关字段的picklist值便可以动态取出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/910966/202004/910966-20200405231126792-1549403496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;篇中只是根据某种需求去分析思考并进行代码的编写。代码并没有进行优化以及异常处理。篇中有错误地方还请指出，有不懂欢迎留言。有更好的方式欢迎沟通。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 05 Apr 2020 15:16:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<og:description>本篇参考：salesforce 零基础学习（六十二）获取sObject中类型为Picklist的field values(含record type) https://developer.salesfo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zero-zyq/p/12639564.html</dc:identifier>
</item>
<item>
<title>类的使用（类和对象，构造函数和析构函数） - Danzel♂</title>
<link>http://www.cnblogs.com/Danzel-Aria233/p/12639755.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Danzel-Aria233/p/12639755.html</guid>
<description>&lt;p&gt;最近c艹在学类与对象&lt;/p&gt;
&lt;p&gt;擅长划水的我并没有听课，害，所以东西有点云里雾里，&lt;/p&gt;
&lt;p&gt;所以写下这一篇博客来理解一下。&lt;/p&gt;

&lt;p&gt;类的使用就像是封装一类的东西，定义为一个类&lt;/p&gt;
&lt;p&gt;定义的地方和结构体其实还是有点相似的。&lt;/p&gt;
&lt;p&gt;这东西在算法里面用的感觉不多，&lt;/p&gt;
&lt;p&gt;以前也没接触过，&lt;/p&gt;
&lt;p&gt;现在发现实际运用还是很有意思的。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;首先是&lt;span&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Clock{
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
         &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; showtime();
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; settime(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c);  
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
         &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hour,minute,second;
     &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
        
};    
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
class 类的名称{
     public://外部接口
        公有成员  
     private：
         私有成员
    protected：
          保护型成员
};
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt; public是外部接口，公有成员，就是所有部分都可以去调用的，就是整个程序的Clock形式的class类都可以调用；&lt;/p&gt;
&lt;p&gt;而private是私有成员，只能允许内部的成员进行使用和调动，外部无法调用。&lt;/p&gt;
&lt;p&gt;简单来说就是，假如定义了Clock c；c.公有成员()是合法的，而c.私有成员()是无效的。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;成员函数的&lt;span&gt;实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Clock::showtime(){
      cout&lt;/span&gt;&amp;lt;&amp;lt;hour&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;minute&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;second&amp;lt;&amp;lt;&lt;span&gt;endl;  
}
/*
返回值 类名::函数成员名（参数表）
{
函数体
}&lt;br/&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 内联成员函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有两种声明方式&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 构造函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   　　&lt;/strong&gt;&lt;/span&gt;构造函数是在类创建之初自己生成的，默认的&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　还是以clock为例子来说明一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Clock{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
      Clock(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt; c);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数&lt;/span&gt;
      Clock(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数&lt;/span&gt;
           hour=&lt;span&gt;0&lt;/span&gt;;minute=&lt;span&gt;0&lt;/span&gt;;second=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; showtime();
      &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; settime(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hour,minute,second;
};

Clock::Clock(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c){
     hour&lt;/span&gt;=a,minute=b,second=&lt;span&gt;c;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他成员函数略&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
     Clock c1(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用了  有参数  的构造函数&lt;/span&gt;
     Clock c2;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用了  无参数  的构造函数
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他略&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ps：如果类里面没有无参数构造函数的那一句话，则 Clock c2是会报错的；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;复制构造函数/拷贝构造函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; 类名{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;：
    类名（形参表）；      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数&lt;/span&gt;
    类名（类名 &amp;amp;对象名）；&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拷贝构造函数&lt;/span&gt;
&lt;span&gt;    ......
}；

类名::类名（类名 &lt;/span&gt;&amp;amp;对象名）{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拷贝构造函数的实现&lt;/span&gt;
&lt;span&gt;   函数体
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;拷贝构造函数有3种调用方式：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（暂时未梳理，先空出来）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;析构函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;析构函数和构造函数都是直接默认存在的&lt;/p&gt;
&lt;p&gt;析构函数的进行清理的，完成对象被删除前的清理工作；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Clock{
      .....
      &lt;/span&gt;~Clock();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;析构函数&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;析构函数不接受任何参数&lt;/li&gt;
&lt;li&gt;被删除前是会自动清理的，~clock析构函数可以用在需要提前清理的时候   （感觉和return  break类似）&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;以一个体型来尽量用到所用的以上知识&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;例4-3&lt;br/&gt;一个圆形游泳池周围需要建圆形过道&lt;br/&gt;在圆形过道外围围上栅栏&lt;br/&gt;栅栏价格为35元/米&lt;br/&gt;过道的建造价格为20元/平方米&lt;br/&gt;过道的宽度为3米&lt;br/&gt;游泳池半径由键盘输入&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
例4-3
一个圆形游泳池周围需要建圆形过道
在圆形过道外围围上栅栏
栅栏价格为35元/米
过道的建造价格为20元/平方米
过道的宽度为3米
游泳池半径由键盘输入 
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; 
#include&lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstring&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cmath&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;algorithm&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;queue&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;utility&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stack&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstdlib&amp;gt;
&lt;span&gt;#define&lt;/span&gt; ll long long
&lt;span&gt;#define&lt;/span&gt; inf 0x3fffffff
&lt;span&gt;#define&lt;/span&gt; pi 3.1415926535
&lt;span&gt;#define&lt;/span&gt; concrete_price 20
&lt;span&gt;#define&lt;/span&gt; fence_price 35
&lt;span&gt;#define&lt;/span&gt; length 3
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; price{                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;类的定义 用来解决费用 &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;:                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有数据成员（仅供内部调用 &lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt;&lt;span&gt; cir,area;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;:                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;外部接口  or  公有成员 &lt;/span&gt;
        price(&lt;span&gt;double&lt;/span&gt; c,&lt;span&gt;double&lt;/span&gt; a){            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内联构造函数隐式声明 &lt;/span&gt;
            cir=c,area=&lt;span&gt;a;
        }
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; buy_concrete();
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; buy_fence(){                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内联成员函数隐式声明 &lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; area*&lt;span&gt;concrete_price;
        }
};

inline &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; price::buy_concrete(){        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内联成员函数显式声明 &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; cir*&lt;span&gt;fence_price;
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; circle{                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;类的定义 用来解决面积和周长 &lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; radius;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; real_area(){                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有成员函数 计算实际面积 &lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; r=&lt;span&gt;radius;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; R=radius+&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; s1=pi*r*&lt;span&gt;r;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; s2=pi*R*&lt;span&gt;R;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; s2-&lt;span&gt;s1;
        }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        circle(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; r);                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数 &lt;/span&gt;
        circle(){                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数   初始化私有成员的值 &lt;/span&gt;
            radius=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        circle(circle &lt;/span&gt;&amp;amp;C);                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拷贝构造函数 or 复制构造函数 &lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt;&lt;span&gt; make_circumference();
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; make_area();
        &lt;/span&gt;~circle(){};                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;析构函数  （后面跟着的 {} 不能少） 用于删除数据，做清理工作 &lt;/span&gt;
&lt;span&gt;};

circle::circle(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; r){                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数的实现 &lt;/span&gt;
    radius=&lt;span&gt;r;
}

circle::circle(circle &lt;/span&gt;&amp;amp;C){                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拷贝构造函数的实现 &lt;/span&gt;
    radius=&lt;span&gt;C.radius;
}

&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; circle::make_circumference(){        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;成员函数的实现 &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;*pi*(radius+&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; circle::make_area(){                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;成员函数的实现 &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; real_area();
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; r;
    cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;r;
    circle Circle(r);                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数初始化半径的值 &lt;/span&gt;
    circle c1=Circle;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拷贝构造函数的调用来初始化值 &lt;/span&gt;
    circle c2;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数直接初始化为0 &lt;/span&gt;
    
    &lt;span&gt;double&lt;/span&gt; c_a=&lt;span&gt;c1.make_area();
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; c_c=&lt;span&gt;c1.make_circumference();
    cout&lt;/span&gt;&amp;lt;&amp;lt;c_c*fence_price&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;c_a*&lt;span&gt;concrete_price;
    
    
    price ans(c_c,c_a);                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化构造函数的值 &lt;/span&gt;
    cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;栅栏价格：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;ans.buy_fence()&amp;lt;&amp;lt;&lt;span&gt;endl;
    cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;过道价格：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;ans.buy_concrete()&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来需要学习类的组合&lt;/p&gt;
&lt;p&gt;先预习吧，害&lt;/p&gt;

</description>
<pubDate>Sun, 05 Apr 2020 14:56:00 +0000</pubDate>
<dc:creator>Danzel♂</dc:creator>
<og:description>最近c艹在学类与对象 擅长划水的我并没有听课，害，所以东西有点云里雾里， 所以写下这一篇博客来理解一下。 类的使用就像是封装一类的东西，定义为一个类 定义的地方和结构体其实还是有点相似的。 这东西在算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Danzel-Aria233/p/12639755.html</dc:identifier>
</item>
</channel>
</rss>