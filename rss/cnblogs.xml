<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Kubernetes搭建过程中使用k8s.gcr.io、quay.io、docker.io的镜像加速 - 虾敏四把刀</title>
<link>http://www.cnblogs.com/flhs/p/12383895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flhs/p/12383895.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;因为众所周知的原因，在使用Kubernetes和docker的时候会出现一些镜像无法拉取或者速度较慢的情况，错误信息类似以下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ERROR ImagePull]: failed to pull image k8s.gcr.io/kube-proxy:v1.17.3: output: Error response from daemon ...&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Failed to pull image &quot;quay.io/coreos/flannel:v0.11.0-amd64&quot;: rpc error: code = Unknown desc = net/http: request canceled ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过使用镜像站拉取，再 docker tag 原地址。&lt;/p&gt;
&lt;h4 id=&quot;k8s.gcr.io-镜像加速&quot;&gt;k8s.gcr.io 镜像加速&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 使用Azure中国镜像
-&amp;gt; [root@kube0.vm] [~] docker pull gcr.azk8s.cn/google-containers/kube-proxy:v1.17.3
-&amp;gt; [root@kube0.vm] [~] docker tag gcr.azk8s.cn/google-containers/kube-proxy:v1.17.3 k8s.gcr.io/kube-proxy:v1.17.3&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;quay.io-镜像加速&quot;&gt;quay.io 镜像加速&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 使用Azure中国镜像
-&amp;gt; [root@kube0.vm] [~] docker pull quay.azk8s.cn/coreos/flannel:v0.11.0-amd64
-&amp;gt; [root@kube0.vm] [~] docker tag quay.azk8s.cn/coreos/flannel:v0.11.0-amd64 quay.io/coreos/flannel:v0.11.0-amd64&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;docker.io-镜像加速docker-tag-同上&quot;&gt;docker.io 镜像加速（docker tag 同上）&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 使用Azure中国镜像

// docker pull nginx:latest  使用下面代替
-&amp;gt; [root@kube0.vm] [~] docker pull dockerhub.azk8s.cn/library/nginx:latest

// docker pull aaa/bbb:ccc  使用下面代替
-&amp;gt; [root@kube0.vm] [~] docker pull dockerhub.azk8s.cn/aaa/bbb:ccc &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在docker配置文件中配置加速器&quot;&gt;在Docker配置文件中配置加速器&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;-&amp;gt; [root@kube0.vm] [~] vi /etc/docker/daemon.json  

//添加以下内容
{
     &quot;registry-mirrors&quot;: [&quot;https://hub-mirror.c.163.com&quot;]
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 01 Mar 2020 00:18:00 +0000</pubDate>
<dc:creator>虾敏四把刀</dc:creator>
<og:description>前言 因为众所周知的原因，在使用Kubernetes和docker的时候会出现一些镜像无法拉取或者速度较慢的情况，错误信息类似以下： 可以通过使用镜像站拉取，再 docker tag 原地址。 k8s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flhs/p/12383895.html</dc:identifier>
</item>
<item>
<title>实现一个简单的解释器（1） - Xlgd</title>
<link>http://www.cnblogs.com/Xlgd/p/12387570.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Xlgd/p/12387570.html</guid>
<description>&lt;p&gt;译自：&lt;a href=&quot;https://ruslanspivak.com/lsbasi-part1/&quot; class=&quot;uri&quot;&gt;https://ruslanspivak.com/lsbasi-part1/&lt;/a&gt;&lt;br/&gt;（已获作者授权）&lt;/p&gt;
&lt;p&gt;“如果你不知道编译器的工作方式，那么你将不知道计算机的工作方式。如果你不能100％确定是否知道编译器的工作方式，那么你将不知道它们的工作方式。”&lt;br/&gt;——史蒂夫·耶格&lt;/p&gt;
&lt;p&gt;无论你是新手还是经验丰富的软件开发人员，如果你不知道编译器和解释器的工作方式，那么你也不知道计算机的工作方式，就是这么简单。&lt;br/&gt;那么，你知道编译器和解释器如何工作吗？ 你是否100％确定知道它们的工作原理？ 如果没有的话：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/202002/1133903-20200229232542582-1237341162.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者，如果你确实不知道，并且你为此感到不安的话：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/202002/1133903-20200229232719705-575068268.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;别担心。如果你坚持不懈地学习本系列文章，并与我一起实现解释器和编译器，你将最终了解它们是如何工作的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/202002/1133903-20200229233050368-145605949.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你为什么要学习解释器和编译器？我会给你三个理由。&lt;/p&gt;
&lt;p&gt;1、要编写解释器或编译器，你必须具有很多需要结合使用的技能。编写解释器或编译器将帮助你提高这些技能，并成为更好的软件开发人员。同样，你学到的技能对于编写任何软件（不仅仅是解释器或编译器）都很有用。&lt;br/&gt;2、你想知道计算机如何工作。通常解释器和编译器看起来像魔术，你不应该对这种魔术感到满意。你想揭露实现解释器和编译器的过程的神秘性，了解它们的工作方式并控制一切。&lt;br/&gt;3、你要创建自己的编程语言或特定于某一领域的语言。如果创建一个，则你还需要为其创建解释器或编译器。最近，人们对新的编程语言重新产生了兴趣。你几乎可以每天看到一种新的编程语言：Elixir，Go和Rust等。&lt;/p&gt;
&lt;p&gt;好的，但是解释器和编译器是什么？&lt;/p&gt;
&lt;p&gt;解释器或编译器的目标是将某种高级语言的源程序转换为其他形式。很模糊，不是吗？请耐心等待，在本系列的后面部分，你将确切地了解源程序被翻译成什么。&lt;/p&gt;
&lt;p&gt;此时，你可能还想知道解释器和编译器之间的区别是什么。就本系列而言，如果我们将源程序翻译成机器语言，则它是编译器。如果我们在不先将其翻译成机器语言的情况下处理和执行源程序，则它就是解释器。看起来像这样：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/202002/1133903-20200229233107063-1049465746.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我希望到现在为止，你已经确信要学习并实现解释器和编译器。&lt;/p&gt;
&lt;p&gt;你和我将为Pascal这门编程语言的大部分子集实现一个简单的解释器。在本系列的最后，你将拥有一个可运行的Pascal解释器和一个源代码调试器，例如Python的pdb。&lt;/p&gt;
&lt;p&gt;你可能会问，为什么是Pascal？一方面，这不是我在本系列中提出的一种组合语言：它是一种真正的编程语言，具有许多重要的语言构造，还有一些古老但有用的CS书籍在其示例中使用Pascal编程语言（我了解，这不是选择我们选择实现Pascal解释器的主要理由，但我认为学习一门非主流的编程语言也是很好的:)&lt;/p&gt;
&lt;p&gt;这是Pascal中阶乘函数的示例，你将能够使用自己的解释器对这段程序进行解释，并使用我们实现的交互式源代码调试器进行调试：&lt;/p&gt;
&lt;pre class=&quot;pascal&quot;&gt;
&lt;code&gt;program factorial;

function factorial(n: integer): longint;
begin
    if n = 0 then
        factorial := 1
    else
        factorial := n * factorial(n - 1);
end;

var
    n: integer;

begin
    for n := 0 to 16 do
        writeln(n, '! = ', factorial(n));
end.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们这里将使用Python来实现Pascal解释器，你也可以使用任何所需的语言，因为实现解释器的思路并不局限于任何特定的编程语言。&lt;br/&gt;好吧，让我们开始吧，预备，准备，开始！&lt;/p&gt;
&lt;p&gt;我们的首次尝试是编写简单的算术表达式解释器（也称为计算器），今天的目标很容易：使你的计算器能够处理个位数字的加法，比如3+5。 这是你的解释器的源代码：&lt;/p&gt;
&lt;pre class=&quot;pascal&quot;&gt;
&lt;code&gt;# Token types
#
# EOF (end-of-file) token is used to indicate that
# there is no more input left for lexical analysis
INTEGER, PLUS, EOF = 'INTEGER', 'PLUS', 'EOF'


class Token(object):
    def __init__(self, type, value):
        # token type: INTEGER, PLUS, or EOF
        self.type = type
        # token value: 0, 1, 2. 3, 4, 5, 6, 7, 8, 9, '+', or None
        self.value = value

    def __str__(self):
        &quot;&quot;&quot;String representation of the class instance.

        Examples:
            Token(INTEGER, 3)
            Token(PLUS '+')
        &quot;&quot;&quot;
        return 'Token({type}, {value})'.format(
            type=self.type,
            value=repr(self.value)
        )

    def __repr__(self):
        return self.__str__()


class Interpreter(object):
    def __init__(self, text):
        # client string input, e.g. &quot;3+5&quot;
        self.text = text
        # self.pos is an index into self.text
        self.pos = 0
        # current token instance
        self.current_token = None

    def error(self):
        raise Exception('Error parsing input')

    def get_next_token(self):
        &quot;&quot;&quot;Lexical analyzer (also known as scanner or tokenizer)

        This method is responsible for breaking a sentence
        apart into tokens. One token at a time.
        &quot;&quot;&quot;
        text = self.text

        # is self.pos index past the end of the self.text ?
        # if so, then return EOF token because there is no more
        # input left to convert into tokens
        if self.pos &amp;gt; len(text) - 1:
            return Token(EOF, None)

        # get a character at the position self.pos and decide
        # what token to create based on the single character
        current_char = text[self.pos]

        # if the character is a digit then convert it to
        # integer, create an INTEGER token, increment self.pos
        # index to point to the next character after the digit,
        # and return the INTEGER token
        if current_char.isdigit():
            token = Token(INTEGER, int(current_char))
            self.pos += 1
            return token

        if current_char == '+':
            token = Token(PLUS, current_char)
            self.pos += 1
            return token

        self.error()

    def eat(self, token_type):
        # compare the current token type with the passed token
        # type and if they match then &quot;eat&quot; the current token
        # and assign the next token to the self.current_token,
        # otherwise raise an exception.
        if self.current_token.type == token_type:
            self.current_token = self.get_next_token()
        else:
            self.error()

    def expr(self):
        &quot;&quot;&quot;expr -&amp;gt; INTEGER PLUS INTEGER&quot;&quot;&quot;
        # set current token to the first token taken from the input
        self.current_token = self.get_next_token()

        # we expect the current token to be a single-digit integer
        left = self.current_token
        self.eat(INTEGER)

        # we expect the current token to be a '+' token
        op = self.current_token
        self.eat(PLUS)

        # we expect the current token to be a single-digit integer
        right = self.current_token
        self.eat(INTEGER)
        # after the above call the self.current_token is set to
        # EOF token

        # at this point INTEGER PLUS INTEGER sequence of tokens
        # has been successfully found and the method can just
        # return the result of adding two integers, thus
        # effectively interpreting client input
        result = left.value + right.value
        return result


def main():
    while True:
        try:
            # To run under Python3 replace 'raw_input' call
            # with 'input'
            text = raw_input('calc&amp;gt; ')
        except EOFError:
            break
        if not text:
            continue
        interpreter = Interpreter(text)
        result = interpreter.expr()
        print(result)


if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将以上代码保存为calc1.py，或直接从&lt;a href=&quot;https://github.com/rspivak/lsbasi/blob/master/part1/calc1.py&quot;&gt;GitHub&lt;/a&gt;下载。 在开始深入地研究代码之前，请在命令行上运行并查看其运行情况。&lt;br/&gt;这是我的笔记本电脑上的一个运行效果（如果你使用的是Python3，则需要用input来替换raw_input）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ python calc1.py
calc&amp;gt; 3+4
7
calc&amp;gt; 3+5
8
calc&amp;gt; 3+9
12
calc&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了使你的简单计算器正常工作而不会引发异常，你的输入需要遵循某些规则：&lt;/p&gt;
&lt;p&gt;1、输入中仅允许一位数的整数&lt;br/&gt;2、目前唯一支持的算术运算是加法&lt;br/&gt;3、输入中的任何地方都不允许有空格&lt;br/&gt;这些限制是使计算器简单化所必需的。不用担心，你很快就会使它变得非常复杂。&lt;/p&gt;
&lt;p&gt;好的，现在让我们深入了解一下解释器的工作原理以及它如何计算算术表达式。&lt;/p&gt;
&lt;p&gt;在命令行上输入表达式3+5时，解释器将获得字符串&quot;3+5&quot;。为了使解释器真正理解如何处理该字符串，首先需要将输入&quot;3+5&quot;分解为Token。Token是具有类型和值的对象。例如，对于字符&quot;3&quot;，Token的类型将是INTEGER，而对应的值将是整数3。&lt;/p&gt;
&lt;p&gt;将输入字符串分解为Token的过程称为词法分析(lexical analysis)。因此，你的解释器需要做的第一步是读取字输入字符并将其转换为Token流。解释器执行此操作的部分称为词法分析器(lexical analyzer)，简称lexer。你可能还会遇到其他的名称，例如 scanner或者tokenizer，它们的含义都一样：解释器或编译器中将字符输入转换为Token流的部分。&lt;/p&gt;
&lt;p&gt;Interpreter类的get_next_token函数是词法分析器。每次调用它时，都会从字符输入中获得下一个Token。让我们仔细看看这个函数，看看它如何完成将字符转换为Token。字符输入存储在text变量中，pos变量是该字符输入的索引（将字符串视为字符数组）。 pos最初设置为0，并指向字符&quot;3&quot;。函数首先检查字符是否为数字，如果是数字，则递增pos并返回类型为INTEGER、值为整数3的Token：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/202003/1133903-20200301001000636-329080407.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;pos现在指向文本中的&quot;+&quot;字符。下次调用该函数时，它将测试pos所指的字符是否为数字，然后测试该字符是否为加号，然后该函数递增pos并返回一个新创建的Token，其类型为PLUS，值为&quot;+&quot;：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/202003/1133903-20200301001526803-1491662602.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;pos现在指向字符&quot;5&quot;。当再次调用get_next_token函数时，将检查它是否为数字，以便递增pos并返回一个新的Token，其类型为INTEGER，值为5：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/202003/1133903-20200301001657603-836197474.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在pos索引已超过字符串&quot;3+5&quot;的末尾，如果再调用get_next_token函数的话，将返回一个类型为EOF的Token：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/202003/1133903-20200301001823792-584222816.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;试试看，亲自看看计算器的词法分析器如何工作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from calc1 import Interpreter
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; interpreter = Interpreter('3+5')
&amp;gt;&amp;gt;&amp;gt; interpreter.get_next_token()
Token(INTEGER, 3)
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; interpreter.get_next_token()
Token(PLUS, '+')
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; interpreter.get_next_token()
Token(INTEGER, 5)
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; interpreter.get_next_token()
Token(EOF, None)
&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，既然解释器现在可以访问由输入字符组成的Token流，那么解释器就需要对其进行处理：它需要在从Token流中查找结构，解释器希望在Token流中找到以下结构：&lt;br/&gt;INTEGER-&amp;gt; PLUS-&amp;gt; INTEGER&lt;br/&gt;也就是说，它尝试查找Token序列：先是一个整数，后面跟加号，最后再跟一个整数。&lt;/p&gt;
&lt;p&gt;负责查找和解释该结构的函数为expr。它验证Token序列是否与预期的Token序列相对应，即INTEGER-&amp;gt; PLUS-&amp;gt; INTEGER。成功确认结构后，它会通过将PLUS左右两侧的Token的值相加来生成结果，从而成功解释了传递给解释器的算术表达式。&lt;/p&gt;
&lt;p&gt;expr函数本身使用辅助函数eat来验证传递给eat函数的Token类型是否与当前正在处理的Token类型一致，在确保类型一致后，eat函数将获取下一个Token并将其分配给current_token变量，从而有效地“消耗”已经验证过的Token并在Token流中推进pos向前，如果Token流中的结构与预期的INTEGER PLUS INTEGER 序列不对应，那么eat函数将引发异常。&lt;/p&gt;
&lt;p&gt;让我们来回顾一下解释器为解析算术表达式所做的事情：&lt;/p&gt;
&lt;p&gt;1、解释器接受输入字符串，例如&quot;3+5&quot;&lt;br/&gt;2、解释器调用expr函数以在词法分析器get_next_token返回的Token流中找到预期的结构。它尝试查找的结构的形式为INTEGER PLUS INTEGER。查找到结构后，它就将输入字符解释为把两个类型为INTEGER的Token的值加起来，也就是将两个整数3和5相加。&lt;/p&gt;
&lt;p&gt;恭喜你！刚刚学习了如何构实现你的第一个解释器！&lt;/p&gt;
&lt;p&gt;现在该做练习了：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133903/202003/1133903-20200301003428579-1404383954.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、修改代码以允许输入中包含多位数的整数，例如&quot;12+3&quot;&lt;br/&gt;2、添加一种跳过空格的方法，以便计算器可以处理带有&quot;12 + 3&quot;之类带有空格的字符输入&lt;br/&gt;3、修改代码，使计算器能够处理减法，例如&quot;7-5&quot;&lt;/p&gt;
&lt;p&gt;最后再来复习回忆一下：&lt;/p&gt;
&lt;p&gt;1、什么是解释器？&lt;br/&gt;2、什么是编译器？&lt;br/&gt;3、解释器和编译器有什么区别？&lt;br/&gt;4、什么是Token？&lt;br/&gt;5、将输入分解为Token的过程的名称是什么？&lt;br/&gt;6、词法分析调用解释器的部分是什么？&lt;/p&gt;
&lt;p&gt;今天到这就结束了，在下一篇文章中，我们将扩展计算器以处理更多的算术表达式，敬请关注。&lt;/p&gt;
&lt;p&gt;PS：&lt;br/&gt;这也是我第一次翻译技术文章，如有错误和不恰当的地方，希望大家能及时批评指正，谢谢！&lt;/p&gt;
</description>
<pubDate>Sat, 29 Feb 2020 17:05:00 +0000</pubDate>
<dc:creator>Xlgd</dc:creator>
<og:description>译自：https://ruslanspivak.com/lsbasi part1/ （已获作者授权） “如果你不知道编译器的工作方式，那么你将不知道计算机的工作方式。如果你不能100％确定是否知道编译</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Xlgd/p/12387570.html</dc:identifier>
</item>
<item>
<title>EventBus 及一些思考 - 公子姓王</title>
<link>http://www.cnblogs.com/jamesvoid/p/12387602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jamesvoid/p/12387602.html</guid>
<description>&lt;p&gt;EventBus 是 Android 开发的一种常用框架,其解耦的思维令人赞叹&lt;/p&gt;
&lt;p&gt;从特性上来讲,其与 Android SDK中的BroadcastReceiver很像,二者都是注册,发送事件,反注册,都可以定义事件的优先级,且都支持粘性(sticky)事件,只是EventBus 使用起来简单得多,而且不能跨进程&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Android SDK其实也有一个不能跨进程的BroadcastReceiver机制——LocalBroadcastManager,其发送和接受的广播只能在本进程,相比传统的 registerBroadcastReceiver,其有着更高的安全性,与EventBus的相似度也更高&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于 EventBus 基础,请参考:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/greenrobot/EventBus&quot;&gt;EventBus&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5a3a0caa518825258b742968&quot;&gt;使用教程&lt;/a&gt; &lt;a href=&quot;https://juejin.im/post/5a3b8fe15188252103346d1b&quot;&gt;高级用法&lt;/a&gt; &lt;a href=&quot;https://juejin.im/post/5a3e19c26fb9a0452207b6b5&quot;&gt;源码解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里结合源码,记录几个在 EventBus 学习和使用中值得思考和注意的地方:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注册&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;哪些方法会被注册 ?&lt;/li&gt;
&lt;li&gt;多次注册同一对象会如何?&lt;/li&gt;
&lt;li&gt;注册对象没有被 Subscribe 注解的方法会如何 ?&lt;/li&gt;
&lt;li&gt;注册对象时父类中被 Subscribe 注解的方法会被注册吗?&lt;/li&gt;
&lt;li&gt;如果 子类B 重写了 父类A 的方法 fun,注册子类B 的对象会发生什么?调用时会调用哪个类的方法?&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上述问题,我们需要分析 register方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void register(Object subscriber) {
    Class&amp;lt;?&amp;gt; subscriberClass = subscriber.getClass();
    // 1. 找 subscriber 中被需要被注册的方法
    List&amp;lt;SubscriberMethod&amp;gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
    synchronized (this) {
        // 2. 注册这些方法
        for (SubscriberMethod subscriberMethod : subscriberMethods) {
            subscribe(subscriber, subscriberMethod);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先来看上面代码第一点;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;SubscriberMethod&amp;gt; findSubscriberMethods(Class&amp;lt;?&amp;gt; subscriberClass) {
    // 缓存中取
    List&amp;lt;SubscriberMethod&amp;gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);
    if (subscriberMethods != null) {
        return subscriberMethods;
    }
    if (ignoreGeneratedIndex) {
        // 通过反射去找
        subscriberMethods = findUsingReflection(subscriberClass);
    } else {
        // 通过 Subscriber Index 去找,这里如果没找到,也会通过反射去找
        subscriberMethods = findUsingInfo(subscriberClass);
    }
    // 如果没有 找到被 Subscribe 注解的方法,抛出异常  ———— 问题 3
    if (subscriberMethods.isEmpty()) {
        throw new EventBusException(&quot;Subscriber &quot; + subscriberClass
                + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);
    } else {
        METHOD_CACHE.put(subscriberClass, subscriberMethods);
        return subscriberMethods;
    }
}

// 继续分析注册方法的查找过程findUsingReflection
private List&amp;lt;SubscriberMethod&amp;gt; findUsingReflection(Class&amp;lt;?&amp;gt; subscriberClass) {
    FindState findState = prepareFindState();
    findState.initForSubscriber(subscriberClass);
    while (findState.clazz != null) {
        findUsingReflectionInSingleClass(findState);
        // 继续去 subscriberClass 的父类中找,但是这里有异常情况(几乎不会发生),往下看 ———— 问题 4
        findState.moveToSuperclass();
    }
    return getMethodsAndRelease(findState);
}
// findState.moveToSuperclass();
void moveToSuperclass() {
    if (skipSuperClasses) { // 异常情况,至于在哪里设置该标志位呢,继续往下看
        clazz = null;
    }
    // ...
}

// 继续分析注册方法的查找过程 findUsingReflectionInSingleClass
private void findUsingReflectionInSingleClass(FindState findState) {
    Method[] methods;
    // 先通过getDeclaredMethods查找,再通过getMethods查找
    try {
        methods = findState.clazz.getDeclaredMethods();
    } catch (Throwable th) {
        methods = findState.clazz.getMethods();
        // ...
        // 问题 4 的异常情况,在 getDeclaredMethods 发生异常时,跳过父类的注册方法查找
        findState.skipSuperClasses = true;
    }
    for (Method method : methods) {
        int modifiers = method.getModifiers();
        if ((modifiers &amp;amp; Modifier.PUBLIC) != 0 &amp;amp;&amp;amp; (modifiers &amp;amp; MODIFIERS_IGNORE) == 0) {
            Class&amp;lt;?&amp;gt;[] parameterTypes = method.getParameterTypes();
            if (parameterTypes.length == 1) {
                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                if (subscribeAnnotation != null) {
                    Class&amp;lt;?&amp;gt; eventType = parameterTypes[0];
                    if (findState.checkAdd(method, eventType)) {
                        // 方法被注册的条件: public,被 Subscribe 注解,参数列表只有1个参数(也就是事件类型) ———— 问题 1
                        ThreadMode threadMode = subscribeAnnotation.threadMode();
                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                    }
                }
            } else if (strictMethodVerification &amp;amp;&amp;amp; method.isAnnotationPresent(Subscribe.class)) {
                // 在设置了 strictMethodVerification 时,如果 Subscribe 注解的方法参数个数不是 1,抛出异常,默认 strictMethodVerification标志是false,可以通过 EventBusBuilder 设置
                String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();
                throw new EventBusException(&quot;@Subscribe method &quot; + methodName +
                        &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);
            }
        } else if (strictMethodVerification &amp;amp;&amp;amp; method.isAnnotationPresent(Subscribe.class)) {
            // 在设置了 strictMethodVerification 时,如果被 Subscribe 注解的方法不是 public,抛出异常
            String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();
            throw new EventBusException(methodName +
                    &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看 register方法中的第2 点:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
    Class&amp;lt;?&amp;gt; eventType = subscriberMethod.eventType;
    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
    CopyOnWriteArrayList&amp;lt;Subscription&amp;gt; subscriptions = subscriptionsByEventType.get(eventType);
    if (subscriptions == null) {
        subscriptions = new CopyOnWriteArrayList&amp;lt;&amp;gt;();
        subscriptionsByEventType.put(eventType, subscriptions);
    } else {
        // 已经注册过了该 subscriber,再次注册抛出异常  ———— 问题 2
        if (subscriptions.contains(newSubscription)) {
            throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;
                    + eventType);
        }
    }
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述问题 5 ,代码中没写,但是其实在回答问题 4 时已经回答了,在寻找注册方法时,会注册父类的合格的方法,那么在post 调用时,调用的是哪个方法呢,EventBus 通过反射调用方法,自然也就是实现类的方法;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件触发&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;post时,如果没有找到 eventType 对应的注册方法会如何?&lt;/li&gt;
&lt;li&gt;事件的 eventType 调用时符合多态吗?&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
    Class&amp;lt;?&amp;gt; eventClass = event.getClass();
    boolean subscriptionFound = false;
    // 设置了 eventInheritance 标志,查找 eventType 的 父类 和 父接口 的对应的事件类型,eventInheritance 标志默认为 true  ———— 问题 2
    if (eventInheritance) {
        List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; eventTypes = lookupAllEventTypes(eventClass);
        int countTypes = eventTypes.size();
        for (int h = 0; h &amp;lt; countTypes; h++) {
            Class&amp;lt;?&amp;gt; clazz = eventTypes.get(h);
            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
        }
    } else {
        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
    }
    if (!subscriptionFound) {
        // 没有找到对应 eventType 的注册方法,先打个日志
        if (logNoSubscriberMessages) {
            logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass);
        }
        // 如果设置了 sendNoSubscriberEvent 标志,post 一个 NoSubscriberEvent 事件  ———— 问题 1
        if (sendNoSubscriberEvent &amp;amp;&amp;amp; eventClass != NoSubscriberEvent.class &amp;amp;&amp;amp;
                eventClass != SubscriberExceptionEvent.class) {
            post(new NoSubscriberEvent(this, event));
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;反注册&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;多次反注册同一对象,或者反注册一个未被注册过的对象会如何?&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public synchronized void unregister(Object subscriber) {
    List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; subscribedTypes = typesBySubscriber.get(subscriber);
    if (subscribedTypes != null) {
        for (Class&amp;lt;?&amp;gt; eventType : subscribedTypes) {
            unsubscribeByEventType(subscriber, eventType);
        }
        typesBySubscriber.remove(subscriber);
    } else {
        // 没找到,就打了个日志  ———— 问题 1
        logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 29 Feb 2020 16:58:00 +0000</pubDate>
<dc:creator>公子姓王</dc:creator>
<og:description>EventBus 是 Android 开发的一种常用框架,其解耦的思维令人赞叹 从特性上来讲,其与 Android SDK中的BroadcastReceiver很像,二者都是注册,发送事件,反注册,都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jamesvoid/p/12387602.html</dc:identifier>
</item>
<item>
<title>微服务SpringBoot总结 - 深海收破烂</title>
<link>http://www.cnblogs.com/itboxue/p/12387398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itboxue/p/12387398.html</guid>
<description>&lt;p&gt;什么是SpringBoot&lt;br/&gt;SpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品&lt;br/&gt;官方介绍：&lt;br/&gt;Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can &quot;just run&quot;. We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.&lt;br/&gt;我们通常把Spring Boot称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注于业务而非配置。&lt;/p&gt;
&lt;p&gt;为什么要学习SpringBoot&lt;br/&gt;java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因主要是两点：&lt;/p&gt;
&lt;p&gt;复杂的配置&lt;br/&gt;项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。&lt;br/&gt;混乱的依赖管理&lt;br/&gt;项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这也是件棘手的问题。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。&lt;br/&gt;而SpringBoot让这一切成为过去！&lt;/p&gt;
&lt;p&gt;SpringBoot的特点&lt;br/&gt;Spring Boot 主要特征是：&lt;/p&gt;
&lt;p&gt;创建独立的spring应用程序&lt;br/&gt;直接内嵌tomcat、jetty和undertow（不需要打包成war包部署）&lt;br/&gt;提供了固定化的“starter”配置，以简化构建配置&lt;br/&gt;尽可能的自动配置spring和第三方库&lt;br/&gt;提供产品级的功能，如：安全指标、运行状况监测和外部化配置等&lt;br/&gt;绝对不会生成代码，并且不需要XML配置&lt;br/&gt;总之，Spring Boot为所有 Spring 的开发者提供一个开箱即用的、非常快速的、广泛接受的入门体验&lt;br/&gt;更多细节，大家可以到官网查看。&lt;/p&gt;
&lt;p&gt;SpringBoot快速入门&lt;br/&gt;方式一：Maven 构建项目&lt;br/&gt;1、访问 http://start.spring.io/&lt;br/&gt;2、选择构建工具 Maven Project、Java、Spring Boot 版本 2.1.3 以及一些工程基本信息，可参考下图所示：&lt;/p&gt;
&lt;p&gt;3、点击 Generate Project 下载项目压缩包&lt;br/&gt;4、解压后，使用 Idea 导入项目，File -&amp;gt; New -&amp;gt; Model from Existing Source… -&amp;gt; 选择解压后的文件夹 -&amp;gt; OK，选择 Maven 一路 Next，OK done!&lt;br/&gt;5、如果使用的是 Eclipse，Import -&amp;gt; Existing Maven Projects -&amp;gt; Next -&amp;gt; 选择解压后的文件夹 -&amp;gt; Finsh，OK done!&lt;/p&gt;
&lt;p&gt;方式二：Idea 构建项目&lt;br/&gt;1、环境要求：&lt;/p&gt;
&lt;p&gt;2、Idea 创建一个空的demo工程，然后在工程中创建moduel（maven跳过骨架）&lt;br/&gt;3、引入依赖：SpringBoot如何帮助我们管理依赖？&lt;br/&gt;SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可&lt;/p&gt;
&lt;p&gt;添加父工程&lt;br/&gt;&amp;lt;parent&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;2.0.2.RELEASE&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/parent&amp;gt;&lt;br/&gt;添加启动器&lt;br/&gt;为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。spring-boot-starter-parent工程将依赖关系声明为一个或者多个启动器，我们可以根据项目需求引入相应的启动器，因为我们是web项目，这里我们引入web启动器：&lt;br/&gt;&amp;lt;dependencies&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;/dependencies&amp;gt;&lt;br/&gt;这个时候，我们会发现项目中多出了大量的依赖，这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。&lt;/p&gt;
&lt;p&gt;完整的POM&lt;br/&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;br/&gt;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;br/&gt;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;&lt;br/&gt;&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;groupId&amp;gt;com.ityang.springboot&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;ityang-springboot&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;parent&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;2.0.2.RELEASE&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/parent&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;dependencies&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;/dependencies&amp;gt;&lt;br/&gt;&amp;lt;/project&amp;gt;&lt;/p&gt;&lt;p&gt;4、添加全局的启动类：如果单独的写在一个个Controller里面，无法启动多个Controller，每个main方法都监听8080端口。所以单独写出做一些框架配置&lt;/p&gt;
&lt;p&gt;@EnableAutoConfiguration&lt;br/&gt;@ComponentScan&lt;br/&gt;public class Application {&lt;br/&gt;public static void main(String[] args) {&lt;br/&gt;SpringApplication.run(Application.class, args);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;5、编写HelloController&lt;/p&gt;
&lt;p&gt;@RestController&lt;br/&gt;public class HelloController {&lt;br/&gt;@GetMapping(&quot;show&quot;)&lt;br/&gt;public String test(){&lt;br/&gt;return &quot;hello Spring Boot!&quot;;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;6、访问localhost:8080/show，测试&lt;/p&gt;
&lt;p&gt;spingboot建议的目录结果如下（root package结构：com.example.myproject）&lt;/p&gt;
&lt;p&gt;com&lt;br/&gt;+- example&lt;br/&gt;+- myproject&lt;br/&gt;+- Application.java&lt;br/&gt;|&lt;br/&gt;+- domain&lt;br/&gt;| +- Customer.java&lt;br/&gt;| +- CustomerRepository.java&lt;br/&gt;|&lt;br/&gt;+- service&lt;br/&gt;| +- CustomerService.java&lt;br/&gt;|&lt;br/&gt;+- controller&lt;br/&gt;| +- CustomerController.java&lt;br/&gt;|&lt;br/&gt;注解分析&lt;br/&gt;1、@EnableAutoConfiguration&lt;br/&gt;注解说明：开启spring应用程序的自动配置，SpringBoot基于你所添加的依赖和你自己定义的bean，试图去猜测并配置你想要的配置。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！&lt;/p&gt;
&lt;p&gt;2、@ComponentScan&lt;br/&gt;注解说明：配置组件扫描的指令。提供了类似与&amp;lt;context:component-scan&amp;gt;标签的作用，通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包。&lt;br/&gt;我们的@ComponentScan注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。一般启动类会放在一个比较浅的包目录中。&lt;/p&gt;
&lt;p&gt;3、@SpringBootApplication&lt;br/&gt;它其实是一个组合注解，这里重点的注解有3个：&lt;/p&gt;
&lt;p&gt;@SpringBootConfiguration&lt;br/&gt;@EnableAutoConfiguration：开启自动配置&lt;br/&gt;@ComponentScan：开启注解扫描&lt;br/&gt;4、@SpringBootConfiguration&lt;br/&gt;通过查看注解的源码，发现在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。&lt;/p&gt;
</description>
<pubDate>Sat, 29 Feb 2020 15:54:00 +0000</pubDate>
<dc:creator>深海收破烂</dc:creator>
<og:description>什么是SpringBootSpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品官方介绍：Spring Boot makes i</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itboxue/p/12387398.html</dc:identifier>
</item>
<item>
<title>Flask权限管理 - Yabea</title>
<link>http://www.cnblogs.com/ybjourney/p/12387322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybjourney/p/12387322.html</guid>
<description>&lt;p&gt;本文介绍了Flask权限管理的原理，并进行了具体实例开发与测试。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;181.0667355677&quot;&gt;
&lt;p&gt;权限管理是一个很常见的功能模块，本文基于RBAC模型针对于多用户，多角色，多权限的场景，介绍一种Flask权限管理方案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Flask系列文章&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/10125532.html&quot;&gt;Flask开发初探&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/12004002.html&quot;&gt;WSGI到底是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/11717347.html&quot;&gt;Flask源码分析一：服务启动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/11789983.html&quot;&gt;Flask路由内部实现原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/12014120.html&quot;&gt;Flask容器化部署原理与实现&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本文将在开发初探的代码基础上进行重构。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;在本文所述场景中，具体的权限管理是：权限和角色关联，给用户添加角色，用户即拥有角色的权限，也就是基于角色的权限控制。当然，若需要基于用户的权限控制也是可以的，只需要修改下相关数据结构即可。&lt;/p&gt;
&lt;p&gt;具体的权限验证采用了位运算，将权限值用十六进制表示，每个角色拥有一个权限总值，当判断该角色是否有特定权限时：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;In [1]: permission = 0X02

In [2]: permissions = 0X0D

In [3]: print((permissions &amp;amp; permission) == permission)
False

In [4]: permissions = 0X07

In [5]: print((permissions &amp;amp; permission) == permission)
True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回值为True表示拥有该权限，False为没有该权限，原理与位运算的原理有关。&lt;/p&gt;
&lt;p&gt;0x07 = 0x01 + 0x02 + 0x04&lt;/p&gt;
&lt;p&gt;转换为二进制数值可以看做是：0111 = 0001 + 0010 + 0100&lt;/p&gt;
&lt;p&gt;按照位运算，运算符&amp;amp;（按位与）相应位都为1，则该位为1，否则为0，那么权限总值和权限值执行按位与运算，结果恒为权限值时才能得出拥有该权限。&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;h3 id=&quot;创建&quot;&gt;创建&lt;/h3&gt;
&lt;p&gt;首先，针对以上场景，我们创建数据表。&lt;/p&gt;
&lt;h4 id=&quot;用户&quot;&gt;用户&lt;/h4&gt;
&lt;p&gt;创建用户表，保存用户信息和对应的角色：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class User(db.Model):
    &quot;&quot;&quot;
    用户表
    &quot;&quot;&quot;
    __tablename__ = &quot;user&quot;
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), unique=True)
    email = db.Column(db.String(128))
    password = db.Column(db.String(128))
    role_id = db.Column(db.Integer)

    def __init__(self, name, email, password):
        self.name = name
        self.email = email
        self.password = bcrypt_sha256.encrypt(str(password))&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;权限&quot;&gt;权限&lt;/h4&gt;
&lt;p&gt;创建权限类，赋予每种操作权限值，这里举例用户管理和更新权限：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Permissions:
    &quot;&quot;&quot;
    权限类
    &quot;&quot;&quot;
    USER_MANAGE = 0X01
    UPDATE_PERMISSION = 0x02&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;角色&quot;&gt;角色&lt;/h4&gt;
&lt;p&gt;需要创建角色表结构，我们暂定两种角色：普通用户和管理员，并初始化角色和权限。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Role(db.Model):
    &quot;&quot;&quot;
    角色表
    &quot;&quot;&quot;
    __tablename__ = &quot;role&quot;
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(128), unique=True, commit=&quot;角色名&quot;)
    permissions = db.Column(db.Integer, commit=&quot;权限总值&quot;)

    @staticmethod
    def init_role():
        role_name_list = ['user', 'admin']
        roles_permission_map = {
            'user': [Permissions.USER_MANAGE],
            'admin': [Permissions.USER_MANAGE, Permissions.UPDATE_PERMISSION]
        }
        try:
            for role_name in role_name_list:
                role = Role.query.filter_by(name=role_name).first()
                if not role:
                    role = Role(name=role_name)
                role.reset_permissions()
                for permission in roles_permission_map[role_name]:
                    role.add_permission(permission)
                db.session.add(role)
            db.session.commit()
        except:
            db.session.rollback()
        db.session.close()

    def reset_permissions(self):
        self.permissions = 0

    def has_permission(self, permission):
        return self.permissions &amp;amp; permission == permission
    
    def add_permission(self, permission):
        if not self.has_permission(permission):
            self.permissions += permission&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随着应用更新，权限值会不断增加，角色对应的权限值随之增大，为了保证每次更新同步到表，可以在flask应用初始化时添加：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Role.init_role()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样，我们就赋予了每个角色其拥有的权限值。&lt;/p&gt;
&lt;p&gt;重启应用，可以看到role表：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/771535/202002/771535-20200229233727954-1404112442.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;鉴权&quot;&gt;鉴权&lt;/h3&gt;
&lt;p&gt;前期数据准备妥当了，接下来就是鉴权。&lt;/p&gt;
&lt;p&gt;为了保证访问的安全性，需要对接口和权限进行关联绑定，我尝试过两种方案：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 装饰器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;封装装饰器，对接口视图函数进行装饰，装饰器传入权限值作为参数，在装饰器中根据用户角色的权限和权限值进行对比，判断该用户是否有该接口的访问权限。&lt;/p&gt;
&lt;p&gt;刚开始我是用这种方式的，小型应用接口不多的场景下使用还好，但随着应用愈来愈复杂，赋权操作就有点繁琐。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 接口赋权&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是我在装饰器之后想到的一种方式，在大型应用接口比较多的情况下比较推荐，而且这种方式耦合度低，易于扩展。&lt;/p&gt;
&lt;p&gt;具体操作：首先，将接口地址和权限关联，接口比较多的话，推荐用蓝图，基本上保证一个蓝图中的接口是一个权限，这样操作会简单一些，然后，在应用初始化时将接口地址和权限入库，这样可以保证每次重启应用后数据都是最新的，最后，当用户登录时，会根据用户角色和请求的地址判断其是否有权限访问。&lt;/p&gt;
&lt;p&gt;以上两种方式，今天以装饰器鉴权举例说明。&lt;/p&gt;
&lt;p&gt;首先，创建鉴权装饰器：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from functools import wraps
from flask import session, abort
from app.models import db, Users, Role

Permission_code = [0X01, 0X02]


def permission_can(current_user, permission):
    &quot;&quot;&quot;
    检测用户是否有特定权限
    :param current_user
    :param permission
    :return:
    &quot;&quot;&quot;
    role_id = current_user.role_id
    role = db.session.query(Role).filter_by(id=role_id).first()
    return (role.permissions &amp;amp; permission) == permission


def permission_required(permission):
    &quot;&quot;&quot;
    权限认证装饰器
    :param permission:
    :return:
    &quot;&quot;&quot;
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            try:
                current_user = Users.query.filter_by(id=session.get('user_id')).first()
                
                if not current_user and permission_can(current_user, permission):
                    abort(403)
                return f(*args, **kwargs)
            except:
                abort(403)
        return decorated_function
    return decorator&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，用到了flask session，获取当前登录用户的user_id，根据当前用户的角色判断其是否拥有该权限permission。&lt;/p&gt;
&lt;p&gt;然后在视图函数上添加该装饰器，就可以鉴权了。举例用户管理功能：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@user.route('/user-manage', methods=['POST', 'GET'])
@permission_required(Permissions.USER_MANAGE)
def user_manage():
    &quot;&quot;&quot;
    用户管理
    :return:
    &quot;&quot;&quot;
    if request.method == 'POST':
        # 处理...
        ret_data = dict(code=0, ret_msg='user manage')
    else:
        # 数据处理 ...
        ret_data = dict(code=0, ret_msg='user list')
    return jsonify(ret_data)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，分别构造请求，访问接口测试：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests

session = requests.Session()

# login
login_url = 'http://0.0.0.0:9001/login'
login_data = dict(user='test', pwd='pwd')
login_request = session.post(login_url, json=login_data)
print(login_request.json())

# user_manage
user_manage_url = 'http://0.0.0.0:9001/user-manage'
login_request = session.post(user_manage_url)
print(login_request.json())

# permission_manege
permission_manage_url = 'http://0.0.0.0:9001/permission-manage'
login_request = session.post(permission_manage_url)
print(login_request.json())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体代码见 &lt;a href=&quot;https://github.com/Yabea/learn_flask&quot;&gt;my github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 29 Feb 2020 15:32:00 +0000</pubDate>
<dc:creator>Yabea</dc:creator>
<og:description>本文介绍了Flask权限管理的原理，并进行了具体实例开发与测试。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ybjourney/p/12387322.html</dc:identifier>
</item>
<item>
<title>阿里云ESC学生服务器搭建springboot项目生产环境（Mysql+JDK)不需要上传安装包 - 意必固我</title>
<link>http://www.cnblogs.com/liruilong/p/12386384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liruilong/p/12386384.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　嗯，之前服务器被挖矿的病毒弄的登录不进去了，所以联系了阿里云客服，提交工单，最后建议重置，所以我就重置了，之后只能在装一次了&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　嗯，学习经验，docker如果懂的不是太多，不要随便云部署，都给别人挖矿了。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Mysql安装：中间有选择输入 y 即可：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载mysql源安装包：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229203349269-1545874348.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; 安装MySQL源：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;yum localinstall mysql57-community-release-el7-8.noarch.rpm&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229203453527-1046881019.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 检测是否安装完成:&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;yum repolist enabled | grep &quot;mysql.*-community.*&quot;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229203653376-1603134158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 安装mysql:&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;yum install mysql-community-server&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;设置开启启动mysql服务:&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;systemctl enable mysqld&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;启动MySQL服务：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;systemctl restart mysqld&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;查看MySQL初始密码：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;grep 'A temporary password' /var/log/mysqld.log&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229210236447-509958836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;以初始密码状态登录：登录进去必须先修改密码，但是因为这里有限制（复杂密码），所以我们以初始密码作为修改的密码。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;mysql -u root -p&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;修改密码：这里以初始密码修改为修改密码，然后在设置密码强度等级后在修改密码：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;SET PASSWORD = PASSWORD(',pi&amp;gt;lapeF8E#') &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; ALTER USER USER() IDENTIFIED &lt;span class=&quot;hljs-keyword&quot;&gt;BY ',pi&amp;gt;lapeF8E#'&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;




&lt;blockquote&gt;

&lt;/blockquote&gt;



&lt;p&gt; &lt;span&gt;首先需要设置密码的验证强度等级，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置 validate_password_policy 的全局参数为 LOW 即可，修改之后只验证长度。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;set global validate_password_policy=LOW;&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;设置密码长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前密码长度为 8 ，如果不介意的话就不用修改了，按照通用的来讲，设置为 6 位的密码，设置 validate_password_length 的全局参数为 6 即可，&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;s&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;et global&lt;/em&gt; &lt;em&gt;validate&lt;/em&gt;&lt;em&gt;_password_len&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;gth=6;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229213453746-225810517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;现在可以为 mysql 设置简单密码了&lt;/span&gt;&lt;span&gt;，只要满足六位的长度即可，&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;span&gt;ALTER USER 'root'@'localhost' IDENTIFIED BY '123456'; &lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229213627239-402481989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 退出去在登录一次：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229214542455-690347583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;设置mysql能够远程访问:&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;em id=&quot;__mceDel&quot;&gt;登录进MySQL：mysql -uroot -p密码&lt;br/&gt;增加一个用户给予访问权限：&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;em id=&quot;__mceDel&quot;&gt;grant all privileges on *.* to '用户名'@'ip地址' identified by '密码' with grant option; //可将ip改为%%,表示开启所有的&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229220550083-233733297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;这里如果简单密码不行的话，把密码验证强度等级在修改一下。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;关于 mysql 密码策略相关参数；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1）、validate_password_length  固定密码的总长度；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2）、validate_password_dictionary_file 指定密码验证的文件路径；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3）、validate_password_mixed_case_count  整个密码中至少要包含大/小写字母的总个数；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4）、validate_password_number_count  整个密码中至少要包含阿拉伯数字的个数；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5）、validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;关于 validate_password_policy 的取值：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0/LOW：只验证长度；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1/MEDIUM：验证长度、数字、大小写、特殊字符；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6）、validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;————————————————&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;JDK 安装&lt;strong&gt;中间有选择输入 y 即可：&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入以下命令，查看可用的jdk软件包列表：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum search java | grep -i --color JDK&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229215248499-933298428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;安装jdk1.8&lt;/span&gt;&lt;/span&gt;&lt;span&gt;yum install java-1.8.0-openjdk-devel.x86_64&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229215306674-1078177276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 环境变量配置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置全局使用让系统上的所有用户使用java(openjdk) ,则要进行下面的操作：&lt;/span&gt;&lt;span&gt;&lt;code class=&quot;language-html hljs xml&quot;&gt;vim /etc/profile  里添加一下代码 之后保存&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.71-2.b15.el7_2.x86_64&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export PATH=$PATH:$JAVA_HOME/bin&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229215420674-1738303906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 让设置生效：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;source /etc/profile&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229215628322-860314061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;之后使用连接工具连接mysql，导入表数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229230111249-1049064687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;把项目传上去（这putty里使用工具需要下载pscp）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229230158221-431014889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;简单部署：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt; java -jar hros-0.0.1-SNAPSHOT.jar&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229230256650-1462788076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 访问：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424271/202002/1424271-20200229230337457-818738422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 嗯嗯，这样就OK，欢迎留言讨论。&lt;/p&gt;
</description>
<pubDate>Sat, 29 Feb 2020 15:28:00 +0000</pubDate>
<dc:creator>意必固我</dc:creator>
<og:description>嗯，之前服务器被挖矿的病毒弄的登录不进去了，所以联系了阿里云客服，提交工单，最后建议重置，所以我就重置了，之后只能在装一次了 嗯，学习经验，docker如果懂的不是太多，不要随便云部署，都给别人挖矿了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liruilong/p/12386384.html</dc:identifier>
</item>
<item>
<title>【原创】从零开始搭建Electron+Vue+Webpack项目框架（五）预加载和Electron自动更新 - 罗知晏</title>
<link>http://www.cnblogs.com/kakayang/p/12386918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kakayang/p/12386918.html</guid>
<description>&lt;p&gt;&lt;strong&gt;导航：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kakayang/p/11753948.html&quot;&gt;（一）Electron跑起来&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/kakayang/p/11766273.html&quot;&gt;（二）从零搭建Vue全家桶+webpack项目框架&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/kakayang/p/12084993.html&quot;&gt;（三）Electron+Vue+Webpack，联合调试整个项目&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/kakayang/p/12165742.html&quot;&gt;（四）Electron配置润色&lt;/a&gt;&lt;br/&gt;（五）预加载及自动更新&lt;br/&gt;（六）构建、发布整个项目（包括client和web）（未完待续）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt;到目前为止，我们的项目已经具备了PC客户端该有的一些基础功能和调试环境，但是总感觉缺了灵魂，那就是结合实际项目、实际业务的细节处理，缺着吧。。。这篇文章就介绍一下预加载和自动更新，文字功底有限，如有介绍的不清楚的地方，欢迎留言指正，或者跳过文字，直接去看代码，项目完整代码：&lt;a href=&quot;https://github.com/luohao8023/electron-vue-template&quot; target=&quot;_blank&quot;&gt;https://github.com/luohao8023/electron-vue-template&lt;/a&gt;，随博客更新。&lt;/p&gt;
&lt;p&gt;一、预加载&lt;/p&gt;
&lt;p&gt;1、什么是预加载？什么场景能用到？　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
preload String (可选) -在页面运行其他脚本之前预先加载指定的脚本 无论页面是否集成Node, 此脚本都可以访问所有Node API 脚本路径为文件的绝对路径。 当 node integration 关闭时, 预加载的脚本将从全局范围重新引入node的全局引用标志。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;摘自electron官网的一段介绍，&lt;a href=&quot;https://www.electronjs.org/docs/api/browser-window&quot; target=&quot;_blank&quot;&gt;https://www.electronjs.org/docs/api/browser-window&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;preload是BrowserWindow类的参数webPreferences的一个可选配置项，我们解读一下官网的介绍：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在页面运行其他脚本之前预先加载的指定的脚本：&lt;/strong&gt;首先是个js文件没错了，再看加载时机，&lt;span&gt;在页面运行其他脚本之前预先加载&lt;/span&gt;，这个页面不是普通的某个h5页面，而是指某个渲染进程（需要预加载js的渲染进程，因为渲染进程可能有多个，每个就是一个窗口），我们new一个BrowserWindow，打开了一个窗口，就是启动了一个渲染进程，如果我们不给这个窗口指定页面，那它就是空白的，如果指定了页面，那么窗口就会加载这个页面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    const win = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrowserWindow({
        width: &lt;/span&gt;800&lt;span&gt;,
        height: &lt;/span&gt;600&lt;span&gt;
    });
    win.loadURL(&lt;/span&gt;'https://www.baidu.com');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面代码，我们创建了一个窗口，然后加载百度首页，而preload脚本的加载时机就是窗口创建后，百度首页加载之前。如果有人问，如果不调用loadURL方法，不加载页面，preload脚本会加载吗？答案是会，但有什么用呢？你起个壳子不给人家看页面是什么鬼？不管这些，重要的是我们理解这个加载时机就好了；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无论页面是否集成Node，此脚本都可以访问所有Node API：&lt;/strong&gt;首先要说明的一点是，Electron5.x以上版本，默认无法在渲染进程中访问Node API，如需使用，需要预先配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    const win = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrowserWindow({
        width: &lt;/span&gt;800&lt;span&gt;,
        height: &lt;/span&gt;600&lt;span&gt;,
        webPreferences: {
            nodeIntegration: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后还要清楚一点，preload脚本是运行在渲染进程中的，可以仔细考虑一下。再有一点就是，preload脚本中可以访问window对象（渲染进程其实就是起了个浏览器壳子），preload脚本运行在渲染进程，提前于页面和其他所有js的加载，又能访问Node API；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脚本文件路径为绝对路径，当node integration关闭时，预加载的脚本将从全局范围重新引入node的全局引用标志：&lt;/strong&gt;结合前面两点理解就好了。&lt;/p&gt;
&lt;p&gt;那么，到底什么是预加载？用白话定义一下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;某一个渲染进程，在页面加载之前加载一个本地脚本，这个脚本能访问所有Node API、能访问window对象。用法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    const win = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrowserWindow({
        width: &lt;/span&gt;800&lt;span&gt;,
        height: &lt;/span&gt;600&lt;span&gt;,
        webPreferences: {
            preload: path.join(__dirname, &lt;/span&gt;'preload.js'&lt;span&gt;)
        }
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;理解应该差不多了，但什么场景能用到这玩意儿呢？按正常的逻辑来想，主进程启动后启动渲染进程，渲染进程加载页面就完事儿了，哪会用到这个preolad呢？&lt;/p&gt;
&lt;p&gt;想一下，如果我们有以下场景：&lt;/p&gt;
&lt;p&gt;a、如果我们启动了一个窗口（渲染进程），加载了一个线上的页面，本地没有页面文件，但要做一些错误处理，比如网络错误，页面加载失败，然后在页面空白但时候插入一些元素；&lt;/p&gt;
&lt;p&gt;b、如果我们的一套代码部署在web端和客户端，需要用一个变量判断是在web端还是客户端；&lt;/p&gt;
&lt;p&gt;...........&lt;/p&gt;
&lt;p&gt;感觉举的例子好勉强啊，不要见怪，就是大概这么个意思，没准哪天就遇到了非preload解决不了的问题呢，毕竟这玩意儿还是有它的特殊之处的；&lt;/p&gt;
&lt;p&gt;上面两个场景如果用preload来解决的话，思路是利用prelaod中能访问window对象的特点，比如b，代码中可以用window.isClient来判断是否在客户端，默认为false，然后在preload中把window.isClient设置为true，而对于部署在web端的代码来说，这个值就是false。&lt;/p&gt;
&lt;p&gt;2、怎么用？&lt;/p&gt;
&lt;p&gt;上面说了怎么引用preload脚本，现在说一下怎么写，下面开始xxoo乱写乱画了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问electron对象&lt;/span&gt;
&lt;span&gt;const {
    remote,
    ipcRenderer
} &lt;/span&gt;= require('electron'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问node模块&lt;/span&gt;
const fs = require('fs'&lt;span&gt;);
const path &lt;/span&gt;= require('path'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问window对象&lt;/span&gt;
window.isClient = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
window.sayHello &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;'hello'&lt;span&gt;);
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 操作dom&lt;/span&gt;
const div = document.createElement('div'&lt;span&gt;);
div.innerText &lt;/span&gt;= 'I am a div'&lt;span&gt;;
document.body.appendChild(div);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果preoad里面逻辑比较复杂，有可能还要用webpack打包一下，单独拎出来打包就行了，webpack单文件打包，注意targer要&quot;electron-renderer&quot;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
Tip:  preload 打包配置
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
const path&lt;/span&gt;=require('path'&lt;span&gt;);
const { dependencies } &lt;/span&gt;= require('../package.json'&lt;span&gt;);
module.exports &lt;/span&gt;=&lt;span&gt; {
    mode:process.env.NODE_ENV,
    entry: {
        preload:[&lt;/span&gt;'./src/preload/index.js'&lt;span&gt;]
    },
    output: {
        path: path.join(__dirname, &lt;/span&gt;'../app/'&lt;span&gt;),
        libraryTarget: &lt;/span&gt;'commonjs2'&lt;span&gt;,
        filename: &lt;/span&gt;'./[name].js'&lt;span&gt;
    },
    optimization: {
        runtimeChunk: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        minimize: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    },
    node: {
        fs: &lt;/span&gt;'empty'&lt;span&gt;,
        __dirname:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    },
    module: {
        rules: [
            {
                test: &lt;/span&gt;/\.js$/&lt;span&gt;,
                loader: &lt;/span&gt;'babel-loader'&lt;span&gt;,
                exclude: &lt;/span&gt;/node_modules/&lt;span&gt;
            }
        ]
    },
    externals: [
        ...Object.keys(dependencies &lt;/span&gt;||&lt;span&gt; {})
    ],
    resolve: {
        extensions: [&lt;/span&gt;'.js'&lt;span&gt;],
        alias: {
            &lt;/span&gt;'@': path.resolve(__dirname, &quot;../src&quot;&lt;span&gt;),
            &lt;/span&gt;'@public': path.resolve(__dirname, &quot;../public&quot;&lt;span&gt;)
        }
    },
    plugins:[],
    target:&lt;/span&gt;&quot;electron-renderer&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我相信，总会遇到使用preload就能迎刃而解的问题。&lt;/p&gt;
&lt;p&gt;二、自动更新&lt;/p&gt;
&lt;p&gt;我们都知道，electron其实是封了个chrome内核，抛开壳子不说，里面运行的其实就是我们的h5页面，而就算我们跑了个空项目，没有任何内容，打包后的安装包也得30M左右，我们希望自己的程序有自动更新功能，但是更新机制是怎样的呢？&lt;/p&gt;
&lt;p&gt;如果我们只改动了页面某一处的文本，却要用户更新整个安装包，那显然太不合理了，一是体验不好，二是我们的流量啊......&lt;/p&gt;
&lt;p&gt;基于这种考虑，加上electron主进程和渲染进程的划分，那我们可以考虑如下更新机制：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主进程有改动时，那没的说，用户需要更新整个客户端（当然有精力有条件的可以做动态更新，官方好像是说支持，主要是我不会）；渲染进程有改动时，我们只需要把h5包下载到本地然后加载就行了，当然这需要我们打包的时候能把h5包区分出来，在更新后能打开对应版本的h5包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我们称主进程的更新为大版本更新，渲染进程的更新为小版本更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、打包配置修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么突然扯到打包配置修改了呢，因为牵扯到小版本的更新，那我们打包的时候就得把这个“小版本”给打出来，不然更新个🔨。因为下面还有一篇文章是专门介绍这个Electron-vue项目的打包，所以这里呢就只讲一下怎么把小版本的压缩包给打出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;修改build.js，思路是：使用webpack打包主进程、打包preload、打包渲染进程，得到可执行文件目录app，然后引入electrin-builder对app目录进行打包，产生一个安装包，然后把渲染进程的文件压缩并标记版本号。&lt;/span&gt;这里我们只拣和本节相关的说，就是打包渲染进程和压缩小版本文件，为什么能拆出来说呢，当然是分模块封装的好处啦，各个进程的打包逻辑封装一下拆出来，能随意组合还能复用，否则一个又臭又长的打包脚本文件，很难维护。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体代码就不贴出来了，太占篇幅，也没什么用，可以到&lt;a href=&quot;https://github.com/luohao8023/electron-vue-template&quot; target=&quot;_blank&quot;&gt;https://github.com/luohao8023/electron-vue-template&lt;/a&gt;看完整代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、增加启动页，启动页显示欢迎语等，在这里检查更新&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里我们暂且叫它检查更新页，这个检查更新页是个独立的渲染进程，用户打开程序时首先显示检查更新窗口，但是这个窗口也不一定显示检查更新字样，偷偷的检查就行了，有新版本就提示更新，没有新版本就显示欢迎语。&lt;/p&gt;
&lt;p&gt;这儿的逻辑是单独拆分出来的，不能是自动更新的时候把自动更新逻辑本身也给更新了，容易乱套。&lt;/p&gt;
&lt;p&gt;修改主进程代码，程序启动时首先启动自动更新窗口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
app.on('ready', () =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册快捷键打开控制台事件&lt;/span&gt;
    shortcut.register('Command+Control+Alt+F5'&lt;span&gt;);
    mainWindow &lt;/span&gt;=&lt;span&gt; updateWin.create();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后注册监听事件，因为自动更新窗口逻辑完成之后需要呼起主窗口，需要主进程来调度：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动主窗体&lt;/span&gt;
ipcMain.on('create-main',(event,arg) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; h5页面指向指定版本&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; global.wwwroot.path = arg.newVersionPath ? arg.newVersionPath : __dirname;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if (arg.version) setVal('version','smallVersion', arg.version);&lt;/span&gt;
&lt;span&gt;    indexWin.create();
    mainWindow.destroy();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自动更新窗口只需专注于更新逻辑就行了，逻辑结束后呼起主窗口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新逻辑看下面伪代码&lt;/span&gt;
        const v1 =&lt;span&gt; getOnlineVersion();
        const v2 &lt;/span&gt;=&lt;span&gt; getLocalVersion();
        const needUpdate &lt;/span&gt;=&lt;span&gt; checkVersion(v1, v2);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (needUpdate) {
            downloadVersion();
        }
        
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.runMain();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在呼起主窗口的同时给主窗口传递参数，并告知主窗口有没有更新版本，以及主窗口需要加载哪个小版本的包，而主窗口在loadURL时也要做下改动：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    let wwwroot = global.wwwroot.path ?&lt;span&gt; global.wwwroot.path : __dirname;
    let filePath &lt;/span&gt;= url.pathToFileURL(path.join(wwwroot, 'index.html')).href;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而wwwrot就是当前小版本包的根路径，由主进程来维护，自动更新小版本后会修改这个值，以告诉主进程加载哪个版本。&lt;/p&gt;
&lt;p&gt;好了，啰嗦了一大堆，好多地方没贴代码，感觉贴了代码的话，篇幅就不受控制了，还是去github看完整项目吧，自动更新这一块是伪代码，只实现了渲染进程的切换（即自动更新窗口呼起主窗口），具体的更新逻辑实现起来的话还要拿线上版本去比较，这个还是留给大家在实际项目中去调试吧，就是上面这个思路。&lt;/p&gt;
&lt;p&gt;好啦，有什么问题可以留言交流，也可以直接去看代码&lt;a href=&quot;https://github.com/luohao8023/electron-vue-template&quot; target=&quot;_blank&quot;&gt;https://github.com/luohao8023/electron-vue-template&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Sat, 29 Feb 2020 15:14:00 +0000</pubDate>
<dc:creator>罗知晏</dc:creator>
<og:description>导航： （一）Electron跑起来（二）从零搭建Vue全家桶+webpack项目框架（三）Electron+Vue+Webpack，联合调试整个项目（四）Electron配置润色（五）预加载及自动更</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kakayang/p/12386918.html</dc:identifier>
</item>
<item>
<title>19年的项目分享，也相当于是一年间的项目总结吧 - 小熊的进阶之路</title>
<link>http://www.cnblogs.com/xiaoxiong2015/p/12386911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiong2015/p/12386911.html</guid>
<description>&lt;div id=&quot;header&quot; readability=&quot;2.4339622641509&quot;&gt;
&lt;div id=&quot;blogTitle&quot;&gt;&lt;a id=&quot;lnkBlogLogo&quot; href=&quot;https://www.cnblogs.com/xiaoxiong2015/&quot;&gt;&lt;img id=&quot;blogLogo&quot; src=&quot;https://www.cnblogs.com/skins/custom/images/logo.gif&quot; alt=&quot;返回主页&quot;/&gt;&lt;/a&gt; 

&lt;/div&gt;
&lt;div id=&quot;navigator&quot; readability=&quot;3.5&quot;&gt;
&lt;ul id=&quot;navList&quot;&gt;&lt;li&gt;&lt;a id=&quot;blog_nav_sitehome&quot; class=&quot;menu&quot; href=&quot;https://www.cnblogs.com/&quot;&gt;博客园&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;blog_nav_myhome&quot; class=&quot;menu&quot; href=&quot;https://www.cnblogs.com/xiaoxiong2015/&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;blog_nav_newpost&quot; class=&quot;menu&quot; href=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot;&gt;新随笔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;blog_nav_contact&quot; class=&quot;menu&quot; href=&quot;https://msg.cnblogs.com/send/%E5%B0%8F%E7%86%8A%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF&quot;&gt;联系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;blog_nav_rss&quot; class=&quot;menu&quot; href=&quot;https://www.cnblogs.com/xiaoxiong2015/rss/&quot;&gt;订阅&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a id=&quot;blog_nav_admin&quot; class=&quot;menu&quot; href=&quot;https://i.cnblogs.com/&quot;&gt;管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span id=&quot;stats_post_count&quot;&gt;随笔 - 3 &lt;/span&gt; &lt;span id=&quot;stats_article_count&quot;&gt;文章 - 0 &lt;/span&gt; &lt;span id=&quot;stats-comment_count&quot;&gt;评论 - 0&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot;&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1913261/202003/1913261-20200301005629663-377402276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1913261/202002/1913261-20200229230456487-440188067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1913261/202002/1913261-20200229230606811-547044811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1913261/202002/1913261-20200229230633115-577199351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1913261/202002/1913261-20200229230703373-207347675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1913261/202002/1913261-20200229231050752-950484391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1913261/202002/1913261-20200229230843098-1627614425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1913261/202003/1913261-20200301005515132-911400675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1913261/202002/1913261-20200229230922955-586280769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1913261/202002/1913261-20200229231002534-1146469548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;


&lt;div id=&quot;blog_post_info_block&quot;&gt;



&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;postDesc&quot;&gt;posted @ &lt;span id=&quot;post-date&quot;&gt;2020-02-29 23:12&lt;/span&gt;  &lt;a href=&quot;https://www.cnblogs.com/xiaoxiong2015/&quot;&gt;小熊的进阶之路&lt;/a&gt;  阅读(&lt;span id=&quot;post_view_count&quot;&gt;...&lt;/span&gt;)  评论(&lt;span id=&quot;post_comment_count&quot;&gt;...&lt;/span&gt;)  &lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=12386911&quot; rel=&quot;nofollow&quot;&gt;编辑&lt;/a&gt;  &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;AddToWz(12386911);return false;&quot;&gt;收藏&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id=&quot;comment_form&quot; class=&quot;commentform&quot;&gt;

&lt;div id=&quot;comment_nav&quot;&gt;&lt;span id=&quot;span_refresh_tips&quot;/&gt;&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;return RefreshCommentList();&quot; id=&quot;lnk_RefreshComments&quot; runat=&quot;server&quot; clientidmode=&quot;Static&quot;&gt;刷新评论&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaoxiong2015/p/12386911.html#&quot; onclick=&quot;return RefreshPage();&quot;&gt;刷新页面&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaoxiong2015/p/12386911.html#top&quot;&gt;返回顶部&lt;/a&gt;&lt;/div&gt;




&lt;div id=&quot;cnblogs_c1&quot; class=&quot;c_ad_block&quot;&gt;

&lt;/div&gt;

&lt;div id=&quot;cnblogs_c2&quot; class=&quot;c_ad_block&quot;&gt;

&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;sideBar&quot;&gt;
&lt;div id=&quot;sideBarMain&quot;&gt;


&lt;div id=&quot;leftcontentcontainer&quot;&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Copyright © 2020 小熊的进阶之路&lt;br/&gt;&lt;span id=&quot;poweredby&quot;&gt;Powered by .NET Core on Kubernetes&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Feb 2020 15:12:00 +0000</pubDate>
<dc:creator>小熊的进阶之路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoxiong2015/p/12386911.html</dc:identifier>
</item>
<item>
<title>北邮机试真题2010 - 疯狂的葡萄</title>
<link>http://www.cnblogs.com/han-zh/p/12386824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/han-zh/p/12386824.html</guid>
<description>&lt;p&gt;&lt;em&gt;写在前面：本人能力有限，以下代码完全为本人自己A出，如有不足之处还请广大网友指点。&lt;/em&gt;&lt;/p&gt;

&lt;h2 class=&quot;subject-item-title&quot;&gt;题目1描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/d93db01c2ee44e8a9237d63842aca8aa?tpId=67&amp;amp;&amp;amp;tqId=29646&amp;amp;rp=3&amp;amp;ru=/activity/oj&amp;amp;qru=/ta/bupt-kaoyan/question-ranking&quot; target=&quot;_blank&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;subject-describe&quot; readability=&quot;13.882132834425&quot;&gt;
&lt;p&gt;输入数组长度 n 输入数组      a[1...n] 输入查找个数m 输入查找数字b[1...m]   输出 YES or NO  查找有则YES 否则NO 。&lt;/p&gt;
&lt;h2&gt;输入描述:&lt;/h2&gt;
&lt;pre&gt;
输入有多组数据。
每组输入n，然后输入n个整数，再输入m，然后再输入m个整数（1&amp;lt;=m,n&amp;lt;=100）。
&lt;/pre&gt;
&lt;h2&gt;输出描述:&lt;/h2&gt;
&lt;pre&gt;
如果在n个数组中输出YES否则输出NO。
&lt;/pre&gt;
&lt;div class=&quot;question-oi&quot;&gt;
&lt;p&gt;示例1&lt;/p&gt;
&lt;div class=&quot;question-oi-bd&quot;&gt;
&lt;div class=&quot;question-oi-mod&quot;&gt;
&lt;h2&gt;输入&lt;/h2&gt;
&lt;div class=&quot;question-oi-cont&quot;&gt;
&lt;pre&gt;
5
1 5 2 4 3
3
2 5 6
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;question-oi-mod&quot;&gt;
&lt;h2&gt;输出&lt;/h2&gt;
&lt;div class=&quot;question-oi-cont&quot; readability=&quot;13.319732937685&quot;&gt;
&lt;pre&gt;
YES
YES
NO&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n)!=&lt;span&gt;EOF){
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; buf1[n];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;){
            scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;buf1[i]);
            
        }
        
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;m);
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; buf2[m];
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;m ;i++&lt;span&gt;){
            scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;buf2[i]);
            
        }
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;m;i++&lt;span&gt;){
            
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;n;j++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(buf2[i]==&lt;span&gt;buf1[j]){
                    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YES\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(j==n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
                    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NO\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            }
        }        
        
        
    }
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;subject-item-title&quot;&gt; &lt;/h2&gt;
&lt;h2 class=&quot;subject-item-title&quot;&gt;题目2描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/204dfa6fcbc8478f993d23f693189ffd?tpId=67&amp;amp;&amp;amp;tqId=29637&amp;amp;rp=3&amp;amp;ru=/activity/oj&amp;amp;qru=/ta/bupt-kaoyan/question-ranking&quot; target=&quot;_blank&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;subject-describe&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;查找一个数组的第K小的数，注意同样大小算一样大。 如  2 1 3 4 5 2 第三小数为3。&lt;/p&gt;
&lt;h2&gt;输入描述:&lt;/h2&gt;
&lt;pre&gt;
输入有多组数据。
每组输入n，然后输入n个整数(1&amp;lt;=n&amp;lt;=1000)，再输入k。
&lt;/pre&gt;
&lt;h2&gt;输出描述:&lt;/h2&gt;
&lt;pre&gt;
输出第k小的整数。
&lt;/pre&gt;
&lt;div class=&quot;question-oi&quot;&gt;
&lt;p&gt;示例1&lt;/p&gt;
&lt;div class=&quot;question-oi-bd&quot;&gt;
&lt;div class=&quot;question-oi-mod&quot;&gt;
&lt;h2&gt;输入&lt;/h2&gt;
&lt;div class=&quot;question-oi-cont&quot;&gt;
&lt;p&gt;6 2 1 3 5 2 2 3&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;algorithm&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstring&amp;gt;

&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; mark[&lt;span&gt;10001&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num[&lt;span&gt;10001&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n)!=&lt;span&gt;EOF){
    memset(mark,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(mark));
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; t;
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;t);
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(mark[t]==&lt;span&gt;false&lt;/span&gt;&lt;span&gt;){
            mark[t]&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            num[size&lt;/span&gt;++]=&lt;span&gt;t;
        }
        
        
    }        
    
    sort(num,num&lt;/span&gt;+&lt;span&gt;size);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; m;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;m);
    
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,num[m-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);    
        
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;subject-item-title&quot;&gt;题目3描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/82442ee76977479e8ab4b88dfadfca9f?tpId=67&amp;amp;&amp;amp;tqId=29640&amp;amp;rp=1&amp;amp;ru=/activity/oj&amp;amp;qru=/ta/bupt-kaoyan/question-ranking&quot; target=&quot;_blank&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;subject-describe&quot; readability=&quot;14.944875459371&quot;&gt;
&lt;p&gt;牌只有1到9，手里拿着已经排好序的牌a，对方出牌b，用程序判断手中牌是否能够压过对方出牌。  规则：出牌牌型有5种   [1]一张 如4 则5...9可压过 [2]两张 如44 则55，66，77，...，99可压过 [3]三张 如444 规则如[2] [4]四张 如4444 规则如[2] [5]五张 牌型只有12345 23456 34567 45678 56789五个，后面的比前面的均大。&lt;/p&gt;
&lt;h2&gt;输入描述:&lt;/h2&gt;
&lt;pre&gt;
输入有多组数据。
每组输入两个字符串(字符串大小不超过100)a，b。a字符串代表手中牌，b字符串代表出的牌。
&lt;/pre&gt;
&lt;h2&gt;输出描述:&lt;/h2&gt;
&lt;pre&gt;
压过输出YES 否则NO。
&lt;/pre&gt;
&lt;div class=&quot;question-oi&quot;&gt;
&lt;p&gt;示例1&lt;/p&gt;
&lt;div class=&quot;question-oi-bd&quot;&gt;
&lt;div class=&quot;question-oi-mod&quot;&gt;
&lt;h2&gt;输入&lt;/h2&gt;
&lt;div class=&quot;question-oi-cont&quot;&gt;
&lt;pre&gt;
12233445566677
33
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;question-oi-mod&quot;&gt;
&lt;h2&gt;输出&lt;/h2&gt;
&lt;div class=&quot;question-oi-cont&quot; readability=&quot;12.437742114001&quot;&gt;
&lt;pre&gt;
YES
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;

&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;  buf[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; s1, cp;

    cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;s1;    
    cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;cp;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;)
        buf[i]&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;s1.size();i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; t=s1[i]-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        buf[t]&lt;/span&gt;++&lt;span&gt;;
        
    }
    
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; t=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (cp.size()){
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:{
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;s1.size();i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s1[i]&amp;gt;cp[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]){
            
                    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YES\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    t&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }    
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:{
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cp[&lt;span&gt;0&lt;/span&gt;]&amp;lt;i+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;amp;&amp;amp;buf[i]&amp;gt;=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;){
            
                    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YES\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    t&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
            
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;:{
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cp[&lt;span&gt;0&lt;/span&gt;]&amp;lt;i+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;amp;&amp;amp;buf[i]&amp;gt;=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;){
            
                    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YES\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    t&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
            
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;:{
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cp[&lt;span&gt;0&lt;/span&gt;]&amp;lt;i+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;amp;&amp;amp;buf[i]&amp;gt;=&lt;span&gt;4&lt;/span&gt;&lt;span&gt;){
            
                    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YES\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    t&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;:{
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;&lt;span&gt;6&lt;/span&gt;;i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cp[&lt;span&gt;0&lt;/span&gt;]&amp;lt;i+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;amp;&amp;amp;buf[i]&amp;gt;=&lt;span&gt;1&lt;/span&gt;&amp;amp;&amp;amp;buf[i+&lt;span&gt;1&lt;/span&gt;]&amp;gt;=&lt;span&gt;1&lt;/span&gt;&amp;amp;&amp;amp;buf[i+&lt;span&gt;2&lt;/span&gt;]&amp;gt;=&lt;span&gt;1&lt;/span&gt;&amp;amp;&amp;amp;buf[i+&lt;span&gt;3&lt;/span&gt;]&amp;gt;=&lt;span&gt;1&lt;/span&gt;&amp;amp;&amp;amp;buf[i+&lt;span&gt;4&lt;/span&gt;]&amp;gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
            
                    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YES\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    t&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
            
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t==&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NO\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;subject-item-title&quot;&gt;题目4描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/9a10d5e7d99c45e2a462644d46c428e4&quot; target=&quot;_blank&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;subject-describe&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;有一棵树，输出某一深度的所有节点，有则输出这些节点，无则输出EMPTY。该树是完全二叉树。&lt;/p&gt;
&lt;h2&gt;输入描述:&lt;/h2&gt;
&lt;pre&gt;
输入有多组数据。
每组输入一个n(1&amp;lt;=n&amp;lt;=1000)，然后将树中的这n个节点依次输入，再输入一个d代表深度。
&lt;/pre&gt;
&lt;h2&gt;输出描述:&lt;/h2&gt;
&lt;pre&gt;
输出该树中第d层得所有节点，节点间用空格隔开，最后一个节点后没有空格。
&lt;/pre&gt;
&lt;div class=&quot;question-oi&quot;&gt;
&lt;p&gt;示例1&lt;/p&gt;
&lt;div class=&quot;question-oi-bd&quot;&gt;
&lt;div class=&quot;question-oi-mod&quot;&gt;
&lt;h2&gt;输入&lt;/h2&gt;
&lt;div class=&quot;question-oi-cont&quot;&gt;
&lt;pre&gt;
4
1 2 3 4
2
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;question-oi-mod&quot;&gt;
&lt;h2&gt;输出&lt;/h2&gt;
&lt;div class=&quot;question-oi-cont&quot; readability=&quot;12.5&quot;&gt;
&lt;pre&gt;
2 3
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstring&amp;gt;

&lt;span&gt;int&lt;/span&gt; buf1[&lt;span&gt;1001&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fun(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; q){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(q==&lt;span&gt;0&lt;/span&gt;)&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ans=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;q;i++&lt;span&gt;){
        ans&lt;/span&gt;*=&lt;span&gt;x;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n)!=&lt;span&gt;EOF){
        
        memset(buf1,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf1));
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;){
            scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;buf1[i]);
            
        }
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; d,t;
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;d);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i=fun(&lt;span&gt;2&lt;/span&gt;,d-&lt;span&gt;1&lt;/span&gt;)-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        t&lt;/span&gt;=fun(&lt;span&gt;2&lt;/span&gt;,d)-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(;i&amp;lt;t&amp;amp;&amp;amp;buf1[i]!=&lt;span&gt;0&lt;/span&gt;;i++&lt;span&gt;){
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,buf1[i]);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i+&lt;span&gt;1&lt;/span&gt;&amp;lt;=t&amp;amp;&amp;amp;buf1[i+&lt;span&gt;1&lt;/span&gt;]!=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n&amp;lt;i)printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EMPTY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 29 Feb 2020 15:07:00 +0000</pubDate>
<dc:creator>疯狂的葡萄</dc:creator>
<og:description>写在前面：本人能力有限，以下代码完全为本人自己A出，如有不足之处还请广大网友指点。 网研院 题目1描述 牛客网 输入数组长度 n 输入数组 a[1...n] 输入查找个数m 输入查找数字b[1...m</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/han-zh/p/12386824.html</dc:identifier>
</item>
<item>
<title>c++中的函数重载、函数重写、函数重定义 - PRO_Z</title>
<link>http://www.cnblogs.com/nbk-zyc/p/12356271.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nbk-zyc/p/12356271.html</guid>
<description>&lt;h2&gt;目录&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/nbk-zyc/p/12356271.html#tag1&quot;&gt;　　一、函数重载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/nbk-zyc/p/12356271.html#tag2&quot;&gt;　　二、函数重写&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/nbk-zyc/p/12356271.html#tag3&quot;&gt;　　三、函数重定义&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;为了更加深刻的理解 函数重载、重写、重定义，我们可以带着如下这两个问题去思考：&lt;/p&gt;
&lt;p&gt;1、子类中是否可以定义父类中的同名成员？为什么？&lt;/p&gt;
&lt;p&gt;　　可以，因为子类与父类的命名空间不同；&lt;/p&gt;
&lt;p&gt;2、子类中定义的函数是否可以重载父类中的同名函数？&lt;/p&gt;
&lt;p&gt;　　不可以，因为函数重载必须在同一个作用域中。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;一、函数重载（Function Overloading）　&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;1、什么是函数重载&lt;/h3&gt;
&lt;p&gt;　　在&lt;span&gt;同一个类中（同一个作用域中/在类的内部）&lt;/span&gt;，存在一组&lt;span&gt;函数名相同，函数的参数列表不同（参数的个数、类型、顺序&lt;/span&gt;），函数有无 virtual 关键字都可以，我们把这组函数称为函数重载。&lt;/p&gt;
&lt;h3&gt;2、为什么使用函数重载（函数重载的好处）&lt;/h3&gt;
&lt;p&gt;　　由于函数重载可以&lt;span&gt;在同一个作用域内，使用同一个函数名 命名一组功能相似的函数&lt;/span&gt;，这样做&lt;span&gt;减少了函数名的数量，避免了程序员因给函数名命名所带来的烦恼&lt;/span&gt;，从而提高程序的开发的效率。&lt;/p&gt;
&lt;h3&gt;3、函数重载的条件&lt;/h3&gt;
&lt;p&gt;　　1. 必须在同一作用域下&lt;/p&gt;
&lt;p&gt;　　2. 函数名相同但是参数列表不同&lt;/p&gt;
&lt;p&gt;　　3. 返回值的类型不会影响重载&lt;/p&gt;
&lt;p&gt;　　4.&lt;span&gt; const属性相同&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4、函数重载的原理（本质：c++编译器对同名函数进行重命名）&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;编译器在编译.cpp文件中&lt;/span&gt;当前使用的作用域里的&lt;span&gt;同名函数&lt;/span&gt;时，根据&lt;span&gt;函数形参的类型和顺序&lt;/span&gt;会对&lt;span&gt;函数进行重命名&lt;/span&gt;（不同的编译器在编译时对函数的重命名标准不一样）；&lt;/p&gt;
&lt;p&gt;　　但是总的来说，他们都&lt;span&gt;把文件中的同一个函数名进行了重命名&lt;/span&gt;；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在vs编译器中：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　根据返回值类型（不起决定性作用）+形参类型和顺序（起决定性作用）的规则重命名并记录在&lt;span&gt;map文件&lt;/span&gt;中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在linux g++ 编译器中：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　根据函数名字的字符数+形参类型和顺序的规则重命名记录在&lt;span&gt;符号表&lt;/span&gt;中；从而产生不同的函数名，当外面的函数被调用时，便是根据这个记录的结果去寻找符合要求的函数名,进行调用；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;为什么c语言不能实现函数重载？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　编译器在编译.c文件时，只会给函数进行简单的重命名；&lt;/p&gt;
&lt;p&gt;　　具体的方法是给函数名之前加上”_”；所以加入两个函数名相同的函数在编译之后的函数名也照样相同；调用者会因为不知道到底调用那个而出错；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('15aaa2e0-4f5f-4eb0-9012-60dd6259ea90')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_15aaa2e0-4f5f-4eb0-9012-60dd6259ea90&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_15aaa2e0-4f5f-4eb0-9012-60dd6259ea90&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('15aaa2e0-4f5f-4eb0-9012-60dd6259ea90',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_15aaa2e0-4f5f-4eb0-9012-60dd6259ea90&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Add(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Add(&lt;span&gt;float&lt;/span&gt; a, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testFunc()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     Add(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     Add(&lt;span&gt;20.0f&lt;/span&gt;, &lt;span&gt;30.0f&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    testFunc();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;案例分析&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;1.  将上述代码保存到.c文件中&lt;/p&gt;
&lt;p&gt;　　若上述代码用c编译器编译，由于c语言中无函数重载，所以，在程序运行时出错。&lt;/p&gt;
&lt;p&gt;　　出错原因：因为在c语言中，&lt;span&gt;c编译器只是在函数名的前面加下划线进行简单的重命名&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;　　为了验证结果，将上述的代码稍作修改（ float Add(float a, float b) -&amp;gt; float Add1(float a, float b) ）。然后用 vs Debug模式编译.c文件，之后在.map文件中就可以看到结果。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1438401/202002/1438401-20200226180252443-690885446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在vs中，map文件生成的步骤设置：工程名右击—&amp;gt;属性—-&amp;gt;配置属性—-&amp;gt;链接器—–&amp;gt;调试—-&amp;gt;生成映射文件—&amp;gt;选择是;&lt;/p&gt;
&lt;p&gt;2.  将上述代码保存到.cpp文件中&lt;/p&gt;
&lt;p&gt;　　若上述代码用c++编译器编译，由于c++语言支持函数重载，所以程序正常运行；但是，在不同c++编译器之间对函数重载的机制也是不一样，接下来分别用vs 和 g++介绍。&lt;/p&gt;
&lt;p&gt;（1）用 vs Debug模式编译.cpp文件，之后就可以在map文件中看到如下结果，&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1438401/202002/1438401-20200226181642403-582017102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　// ‘？’表示名称开始，‘？’后边是函数名；“@@YA”表示参数表开始，后边的3个字符分别表示返回值类型，两个参数类型；“@Z”表示名称结束。&lt;/p&gt;
&lt;p&gt;（2）在Ubuntu下测试（需要安装g++编译器），执行以下指令：&lt;/p&gt;
&lt;p&gt;　　1）g++ test.cpp   &lt;/p&gt;
&lt;p&gt;　　2）objdump a.out -t &amp;gt; test.out    // -t是表示生成符号表，最后是将生成的符号表用重定向符号放在test.out文件。&lt;/p&gt;
&lt;p&gt;　　3）vi test.out&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1438401/202002/1438401-20200226183029095-1421246319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开test.out文件，就会发现，&lt;code&gt;整形数相加的函数Add(int a,int b)&lt;/code&gt;生成的符号表中，Add函数名被记录为_Z3Addii。&lt;/p&gt;
&lt;p&gt;　　其中，_Z表示符号表名称开始, 3代表函数名的字符个数，ii代表参数列表顺序中2个形参的类型；&lt;/p&gt;
&lt;p&gt;综述，无论使用何种编译器，在.cpp文件中，虽然两个函数的函数名一样，但是他们在符号表中生成的名称不一样，所以是可以编译通过的。&lt;/p&gt;&lt;p&gt;由上述分析可知，c编译器 与 c++编译器  对函数的重命名规则不一样；那么，&lt;span&gt;&lt;span&gt;在c++中如何确保将一段c代码以c编译器的方式被编译呢&lt;/span&gt;&lt;/span&gt;？---- 使用 &lt;span&gt;extern&lt;/span&gt; 关键字&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('58a38eff-6e77-44ae-82a7-8a863d506754')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_58a38eff-6e77-44ae-82a7-8a863d506754&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_58a38eff-6e77-44ae-82a7-8a863d506754&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('58a38eff-6e77-44ae-82a7-8a863d506754',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_58a38eff-6e77-44ae-82a7-8a863d506754&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用方式1&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; C-Style Compilation&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用方式2
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;__cplusplus 是 c++ 编译器内置的标准宏定义
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;__cplusplus 的意义：确保C代码以统一的C方式被编译成目标文件&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#ifdef __cplusplus
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; C-Style Compilation&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#ifdef __cplusplus
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;extern &quot;C&quot; 的使用方式&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 参考链接：&lt;a href=&quot;https://blog.csdn.net/qq_37791134/article/details/81502017&quot;&gt;https://blog.csdn.net/qq_37791134/article/details/81502017&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/gogogo_sky/article/details/71189499&quot;&gt;https://blog.csdn.net/gogogo_sky/article/details/71189499&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/fantian_/article/details/80719144&quot;&gt;https://blog.csdn.net/fantian_/article/details/80719144&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;5、函数重载的结论&lt;/h3&gt;
&lt;div readability=&quot;98&quot;&gt;
&lt;p&gt;　　1. 函数重载的本质：多个不同的函数；&lt;/p&gt;
&lt;p&gt;　　2. 函数名和参数列表是唯一的标识；&lt;/p&gt;
&lt;p&gt;　　3. &lt;span&gt;函数重载必须发生在同一个作用域中；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　4. c++编译器 和 c编译器 对函数重命名的规则不同；&lt;/p&gt;
&lt;p&gt;　　5. 编译器决定符号表中函数名被编译后的最终目标名；&lt;/p&gt;
&lt;p&gt;　　　　c++ 编译器 将函数名和参数列表编译成目标名；&lt;/p&gt;
&lt;p&gt;　　　　c 编译器将函数名编译成目标名；&lt;/p&gt;
&lt;p&gt;　　6. 函数重载是在编译期间根据参数类型和个数决定函数调用&lt;/p&gt;
&lt;p&gt;　　7. 函数重载是一种静态多态；&lt;/p&gt;
&lt;p&gt;　　（1）多态：用同一个东西表示不同的形态；&lt;/p&gt;
&lt;p&gt;　　（2）多态分为：静态多态（编译时的多态）、动态多态（运行时的多态）；&lt;/p&gt;
&lt;h3&gt;6、编译器调用函数重载的规则&lt;/h3&gt;
&lt;p&gt;　　1. 将所有同名函数作为候选者；&lt;/p&gt;
&lt;p&gt;　　2. 尝试寻找可行的候选者函数&lt;/p&gt;
&lt;p&gt;　　（1）精确匹配实参；&lt;/p&gt;
&lt;p&gt;　　（2）通过默认参数能够匹配实参；&lt;/p&gt;
&lt;p&gt;　　（3）通过默认类型转换匹配实参；&lt;/p&gt;
&lt;p&gt;　　3. 匹配失败&lt;/p&gt;
&lt;p&gt;　　（1）最终寻找的候选函数不唯一，则出现二义性，编译失败；&lt;/p&gt;
&lt;p&gt;　　（2）无法匹配所有的候选函数，函数没定义，编译失败；&lt;/p&gt;
&lt;h3&gt;7、函数重载与默认参数&lt;/h3&gt;
&lt;p&gt;　　当函数重载遇到默认参数时，就会发生二义性；&lt;/p&gt;
&lt;p&gt;　　代码如下：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4d57cf6e-68fb-48e2-a7eb-a5a05ef57db8')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_4d57cf6e-68fb-48e2-a7eb-a5a05ef57db8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4d57cf6e-68fb-48e2-a7eb-a5a05ef57db8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4d57cf6e-68fb-48e2-a7eb-a5a05ef57db8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4d57cf6e-68fb-48e2-a7eb-a5a05ef57db8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; func(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b, &lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; func(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    A a;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     a.func(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 二义性出现&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;函数重载的二义性案例&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;8、函数重载 与 函数指针&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　将重载函数名赋值给函数指针时，&lt;/p&gt;
&lt;p&gt;　　1. 根据重载规则挑选与函数指针参数列表一致的候选者；&lt;/p&gt;
&lt;p&gt;　　2. 严格匹配候选者的函数类型与函数指针的函数类型；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('798e129a-f7af-4093-b3ce-3e2d6af6e6bf')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_798e129a-f7af-4093-b3ce-3e2d6af6e6bf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_798e129a-f7af-4093-b3ce-3e2d6af6e6bf&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('798e129a-f7af-4093-b3ce-3e2d6af6e6bf',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_798e129a-f7af-4093-b3ce-3e2d6af6e6bf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; func(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; func(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; func(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; s)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; strlen(s);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; typedef &lt;span&gt;int&lt;/span&gt;(*PFUNC)(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     PFUNC p =&lt;span&gt; func;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         
&lt;span&gt;28&lt;/span&gt;     c = p(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);   
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     
&lt;span&gt;30&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; c = 1&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;函数重载与函数指针&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;二、函数重写（也称为覆盖， Function override）&lt;/h2&gt;
&lt;h3&gt;1、什么是函数重写&lt;/h3&gt;
&lt;p&gt;　　函数重写分为 虚函数重写（会发生多态） 与 非虚函数重写（重定义的一种形式）； &lt;/p&gt;
&lt;p&gt;　　函数重写：也叫做覆盖。子类重新定义父类中有&lt;strong&gt;&lt;span&gt;相同返回值、名称&lt;/span&gt;&lt;/strong&gt;和&lt;span&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/span&gt;的&lt;span&gt;虚函数&lt;/span&gt;。函数特征相同。但是具体实现不同，主要是在继承关系中出现的 。&lt;/p&gt;
&lt;p&gt;　　注：&lt;span&gt;一般而言，函数重写 就是 虚函数重写，为的是实现多态调用； &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2、函数重写的条件&lt;/h3&gt;
&lt;p&gt;　　1. 函数的返回类型、方法名、参数列表完全相同；&lt;/p&gt;
&lt;p&gt;　　2. 必须发生在不同的作用域中（基类与派生类中）；&lt;/p&gt;
&lt;p&gt;　　3. 基类中有 virtual 关键字声明，派生类中可有可无，不能有 static （虚函数重写）；&lt;/p&gt;
&lt;h3&gt;3、函数重写的意义&lt;/h3&gt;
&lt;p&gt;　　在面向对象的继承关系中，我们了解到子类可以拥有父类中的所有属性与行为；但是，有时父类中提供的方法并不能满足现有的需求，所以，我们必须在子类中重写父类中已有的方法，来满足当前的需求。&lt;/p&gt;

&lt;h2&gt;三、函数重定义（也称为隐藏，Function redefining）&lt;/h2&gt;
&lt;h3&gt;1、什么是函数重定义&lt;/h3&gt;
&lt;p&gt;　　子类重新定义父类中有&lt;strong&gt;相同名称&lt;/strong&gt;的函数 ( 不包括虚函数重写 ) 。&lt;/p&gt;
&lt;h3&gt;2、重定义的表现形式&lt;/h3&gt;
&lt;p&gt;　　1. 必须发生在不同的作用域中（基类与派生类中）；&lt;/p&gt;
&lt;p&gt;　　2. 函数名相同；&lt;/p&gt;
&lt;p&gt;　　3. 返回值可以不同；&lt;/p&gt;
&lt;p&gt;　　4. 参数列表不同，此时，无论基类中的同名函数有无 virtual 关键字，基类中的同名函数都会被隐藏。&lt;/p&gt;
&lt;p&gt;　　5. 参数列表相同，此时，基类中的同名函数没有 virtual 关键字，则基类中的同名函数将会被隐藏 --- 非虚函数重写 。&lt;/p&gt;
&lt;h3&gt;3、关于同名覆盖的结论（&lt;span&gt;归纳：基类与派生类中存在同名成员；--- 同名覆盖&lt;/span&gt;）&lt;/h3&gt;
&lt;p&gt;　　1. 子类将隐藏父类中的同名成员；&lt;/p&gt;
&lt;p&gt;　　2. 父类中的同名成员依然存在于子类中；&lt;/p&gt;
&lt;p&gt;　　3. 可以通过作用域分辨符(::)访问被隐藏的父类中的同名成员；&lt;/p&gt;
&lt;p&gt;　　4. 不可以直接通过子类对象访问父类成员；&lt;/p&gt;
&lt;p&gt;　　　注：同名覆盖规则适用于类的成员变量与成员函数；&lt;/p&gt;
&lt;p&gt;　　相关代码展示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('87dfb5a4-5c5b-470f-9a42-b1d8c8615758')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_87dfb5a4-5c5b-470f-9a42-b1d8c8615758&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_87dfb5a4-5c5b-470f-9a42-b1d8c8615758&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('87dfb5a4-5c5b-470f-9a42-b1d8c8615758',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_87dfb5a4-5c5b-470f-9a42-b1d8c8615758&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parent
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mi;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    Parent()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Parent() : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;mi &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Child : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Parent
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mi;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    Child()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Child() : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;mi &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    Child c;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     
&lt;span&gt;32&lt;/span&gt;     c.mi = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         
&lt;span&gt;34&lt;/span&gt;     c.Parent::mi = &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     
&lt;span&gt;36&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;c.mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;c.mi &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c.mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c.mi &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     
&lt;span&gt;39&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;c.Parent::mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;c.Parent::mi &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c.Parent::mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c.Parent::mi &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;* Parent() : &amp;amp;mi = 0x7ffe98191450
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;* Child() : &amp;amp;mi = 0x7ffe98191454
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;* &amp;amp;c.mi = 0x7ffe98191454
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;* c.mi = 100
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;* &amp;amp;c.Parent::mi = 0x7ffe98191450
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;* c.Parent::mi = 1000
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;同名成员变量案例&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('305dd7e2-2b4e-4f92-a44d-f90ce9293df0')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_305dd7e2-2b4e-4f92-a44d-f90ce9293df0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_305dd7e2-2b4e-4f92-a44d-f90ce9293df0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('305dd7e2-2b4e-4f92-a44d-f90ce9293df0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_305dd7e2-2b4e-4f92-a44d-f90ce9293df0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parent
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mi;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         mi +=&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         mi += (a +&lt;span&gt; b);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Child : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Parent
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mi;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         mi +=&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         mi += (a +&lt;span&gt; b);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; z)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         mi += (x + y +&lt;span&gt; z);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    Child c;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     
&lt;span&gt;47&lt;/span&gt;     c.mi = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;        
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     c.Parent::mi = &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     
&lt;span&gt;50&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c.mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c.mi &amp;lt;&amp;lt;&lt;span&gt; endl;    
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c.Parent::mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c.Parent::mi &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     
&lt;span&gt;53&lt;/span&gt;     c.add(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     c.add(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     c.add(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     c.Parent::add(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     c.Parent::add(&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     
&lt;span&gt;59&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c.mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c.mi &amp;lt;&amp;lt;&lt;span&gt; endl;    
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c.Parent::mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c.Parent::mi &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     
&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;* c.mi = 100
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;* c.Parent::mi = 1000
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;* c.mi = 121
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;* c.Parent::mi = 1033
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;重定义案例&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;
&lt;div onclick=&quot;cnblogs_code_show('9895dabe-c7d6-4ccc-858a-5922c83629b6')&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ff592838-d302-4f8b-b8cc-3095b0e45058')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_ff592838-d302-4f8b-b8cc-3095b0e45058&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ff592838-d302-4f8b-b8cc-3095b0e45058&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ff592838-d302-4f8b-b8cc-3095b0e45058',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ff592838-d302-4f8b-b8cc-3095b0e45058&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parent
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mi;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         mi +=&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Child : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Parent
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mi;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         mi +=&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         mi += (a +&lt;span&gt; b);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    Child c;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     Parent &amp;amp;p = c;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父类引用指向子类对象，多态发生&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     
&lt;span&gt;38&lt;/span&gt;     c.mi = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;     
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     c.Parent::mi = &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     
&lt;span&gt;41&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c.mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c.mi &amp;lt;&amp;lt;&lt;span&gt; endl;   
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c.Parent::mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c.Parent::mi &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     
&lt;span&gt;44&lt;/span&gt;     c.add(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     c.add(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     p.add(&lt;span&gt;100&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际调用的是子类中 add(int v) 函数&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     c.Parent::add(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;      
&lt;span&gt;49&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c.mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c.mi &amp;lt;&amp;lt; endl;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; c.mi = 1 + 2 + 3 + 100&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c.Parent::mi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c.Parent::mi &amp;lt;&amp;lt; endl; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; c.Parent::mi = 1000 + 10&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;* c.mi = 100
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;* c.Parent::mi = 1000
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;* c.mi = 206
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;* c.Parent::mi = 1010
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;重写案例&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9895dabe-c7d6-4ccc-858a-5922c83629b6')&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1438401/202002/1438401-20200227123120980-1107242471.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;本节总结：&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;1、 重载 必须在 一个类之间, 而 重写、重定义 是在 2个类 之间&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;2、 重载是在 编译期间 根据参数类型和个数决定函数调用; 多态（虚函数重写）是在 运行期间 根据具体对象的类型决定函数调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、 发生重写、重定义后，遵循 &lt;span&gt;同名覆盖&lt;/span&gt; 规则；&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Sat, 29 Feb 2020 14:51:00 +0000</pubDate>
<dc:creator>PRO_Z</dc:creator>
<og:description>目录 一、函数重载 二、函数重写 三、函数重定义 为了更加深刻的理解 函数重载、重写、重定义，我们可以带着如下这两个问题去思考： 1、子类中是否可以定义父类中的同名成员？为什么？ 可以，因为子类与父类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nbk-zyc/p/12356271.html</dc:identifier>
</item>
</channel>
</rss>