<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【JVM故事】一个Java字节码文件的诞生记 - 编程新说(李新杰)</title>
<link>http://www.cnblogs.com/lixinjie/p/a-birth-process-of-a-java-bytecode-file.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/a-birth-process-of-a-java-bytecode-file.html</guid>
<description>&lt;p&gt;&lt;span&gt;万字长文，完全虚构。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（&lt;span&gt;一&lt;/span&gt;）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;组里来了个实习生，李大胖面完之后，觉得水平一般，但还是留了下来，为什么呢？&lt;/span&gt;&lt;span&gt;各自猜去吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;李大胖也在心里开导自己，学生嘛，不能要求太高，只要肯上进，慢慢来。&lt;/span&gt;&lt;span&gt;就称呼为小白吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白每天来的很早，走的很晚，都在用功学习，时不时也向别人请教。&lt;/span&gt;&lt;span&gt;只是好像天资差了点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;都快一周了，才能写些“简单”的代码，一个注解，一个接口，一个类，都来看看吧：&lt;/span&gt;&lt;/p&gt;
&lt;pre readability=&quot;14&quot;&gt;
&lt;code readability=&quot;22&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; Health {&lt;p&gt;&lt;span&gt;String &lt;span&gt;name&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span&gt;String &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setName&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt;&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;getColor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setColor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; color)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Health&lt;/span&gt;(name = &lt;span&gt;&quot;健康水果&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Apple&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Fruit&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;&lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; color;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; weight = &lt;span&gt;0.5&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; name;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setName&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getColor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; color;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setColor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; color)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;this&lt;/span&gt;.color = color;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;weight&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; weight;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;weight&lt;/span&gt;&lt;span&gt;(&lt;span&gt;double&lt;/span&gt; weight)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;this&lt;/span&gt;.weight = weight;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;与周围人比起来，小白进步很慢，也许是自己不够聪明，也许是自己不适合干这个，小白好像有点动摇了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这几天，小白明显没有一开始那么上进了，似乎有点想放弃，这不，趴在桌子上竟然睡着了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（二）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;在梦中，小白来到一个奇怪又略显阴森的地方，眼前有一个破旧的小房子，从残缺不全的门缝里折射出几束光线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白有些害怕，但还是镇定了下，深呼吸几口，径直朝着小房子走去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白推开门，屋里没有人。&lt;/span&gt;&lt;span&gt;只有一个“机器”在桌子旁大口大口“吃着”东西，背后也不时的“拉出”一些东西。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白很好奇，就凑了上去，准备仔细打量一番。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“你要干嘛，别影响我工作”。&lt;/span&gt;&lt;span&gt;突然冒出一句话，把小白吓了一大跳，慌忙后退三步，妈呀，心都快蹦出来了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“你是谁呀？&lt;/span&gt;&lt;span&gt;”，惊慌中小白说了句话。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“我是编译器”，哦，原来这个机器还会说话，小白这才缓了过来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“编译器”，小白好像听说过，但一时又想不起，于是猜测到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“网上评论留言里说的小编是不是就是你啊”？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“你才是呢”，编译器白了一眼，没好声气的说到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要不是看在长得还行的份上，早就把你赶走了，编译器心想。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“哦，我想起来了，编译器嘛，就是编译代码的那个东西”，小白恍然大悟到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“请注意你的言词，我不是个东西，哦，不对，我是个东西，哦，好像也不对，我。&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;我。&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;”，编译器自己也快晕了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器一脸的无奈，遇上这样的人，今天我认栽了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白才不管呢，心想，今天我竟然见到了编译器，我得好好请教请教他。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那编译器会帮助她吗？&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（三）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;小白再次走上前来，定睛一看，才看清楚，编译器吃的是Java源码，拉的是class（字节码）文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;咦，为啥这个代码这么熟悉呢，不就是我刚刚写的那些。&lt;/span&gt;&lt;span&gt;“停，停，快停下来了”。&lt;/span&gt;&lt;span&gt;编译器被小白叫停了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“你又要干嘛啊”？&lt;/span&gt;&lt;span&gt;编译器到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“嘻嘻，这个代码是我写的，我想看看它是怎么被编译的”，小白到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器看了看这个代码，这么“简单”，她绝对是个菜鸟。&lt;/span&gt;&lt;span&gt;哎，算了，还是让她看看吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过编译器又到，“整个编译过程是非常复杂的，想要搞清楚里面的门道是不可能的，今天也就只能看个热闹了”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“编译后的内容都是二进制数据，再通俗点说，就是一个长长的字节数组（byte[]）”，编译器继续说，“通常把它写入文件，就是class文件了”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“但这不是必须的，也可以通过网络传到其它地方，或者保存在内存中，用完之后就丢弃”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“哇，还可以这样”，小白有些惊讶。&lt;/span&gt;&lt;span&gt;编译器心想，你是山沟里出来的，没见过世面，大惊小怪。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;继续到，“从数据结构上讲，数组就是一段连续的空间，是‘没有结构’的，就像一个线段一样，唯一能做的就是按索引访问”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白到，“编译后的内容一定很繁多，都放到一个数组里面，怎么知道什么东西都在哪呢？&lt;/span&gt;&lt;span&gt;不都乱套了嘛”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器觉得小白慢慢上道了，心里有一丝安慰，至少自己的讲解不会完全白费。&lt;/span&gt;&lt;span&gt;于是继续到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“所以JVM的那些大牛们早就设计好了字节码的格式，而且还把它们放入到了一个字节数组里面”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白很好奇到，“那是怎么实现的呢”？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“其实也没有太高深的内容，既然数组是按位置的，那就规定好所有内容的先后顺序，一个接一个往数组里放呗”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“如果内容的长度是固定（即定长）的，那最简单，直接放入即可”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“如果内容长度是不固定（即变长）的，也很简单，在内容前用一到两个字节存一下内容的长度不就OK了”。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（四）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;“字节码的前4个字节必须是一个固定的数字，它的十进制是3405691582，大部分人更熟悉的是它的十六进制，0xCAFEBABE”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“通常称之为魔术数字（Magic），它主要是用来区分文件类型的”，编译器到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“扩展名（俗称后缀名）不是用来区分文件类型的吗”？&lt;/span&gt;&lt;span&gt;小白说到，“如.java是Java文件，.class是字节码文件”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“扩展名确实可以区分，但大部分是给操作系统用的，或给人看到。&lt;/span&gt;&lt;span&gt;如我们看到.mp3时知道是音频、.mp4是知道是视频、.txt是文本文件”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“操作系统可以用扩展名来关联打开它的软件，比如.docx就会用word来打开，而不会用文本文件”。&lt;/span&gt;&lt;span&gt;编译器继续到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“还有一个问题就是扩展名可以很容易被修改，比如把一个.java手动改为.class，此时让JVM来加载这个假的class文件会怎样呢”？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“那JVM先读取开头4个字节，发现它不是刚刚提到的那个魔数，说明它不是合法的class文件，就直接抛异常呗”，小白说到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“很好，真是孺子可教”，编译器说道，“不过还有一个问题，不知你是否注意到？&lt;/span&gt;&lt;span&gt;4个字节对应Java的int类型，int类型的最大值是2147483647”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“但是魔数的值已经超过了int的最大值，那怎么放得下呢，难道不会溢出吗”？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“确实啊，我怎么没发现呢，那它到底是怎么放的呢”？&lt;/span&gt;&lt;span&gt;小白到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“其实说穿了不值得一提，JVM是把它当作无符号数对待的。&lt;/span&gt;&lt;span&gt;而Java是作为有符号数对待的。&lt;/span&gt;&lt;span&gt;无符号数的最大值基本上是有符号数最大值的两倍”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“接下来的4个字节是版本号，不同版本的字节码格式可能会略有差异，其次在运行时会校验，如JDK8编译后的字节码是不能放到JDK7上运行的”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“这4个字节中的前2个是次（minor）版本，后2个是主（major）版本”。&lt;/span&gt;&lt;span&gt;编译器继续到，“比如我现在用的JDK版本是1.8.0_211，那次版本就是0，主版本就是52”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“所以前8个字节的内容是，0xCAFEBABE，0，52，它们并不是源代码里的内容”。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;Magic&lt;/span&gt;&lt;span&gt; [getMagic()=0xcafebabe]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;MinorVersion&lt;/span&gt;&lt;span&gt; [getVersion()=0]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;MajorVersion&lt;/span&gt;&lt;span&gt; [getVersion()=52]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（五）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;当编译器读到源码中的public class的时候，然后就就去查看一个表格，如下图：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143355672-283362109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;自顾自的说着，“public对应的是ACC_PUBLIC，值为0x0001，class默认就是，然后又读ACC_SUPER的值0x0020”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“最后把它俩合起来（按位或操作），0x0001 | 0x0020 =&amp;gt; 0x0021，然后把这个值存起来，这就是这个类的访问控制标志”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白这次算是开了眼界了，只是还有一事不明，“这个ACC_SUPER是个什么鬼”？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器解释到，“这是历史遗留问题，它原本表达在调用父类方法时会特殊处理，不过现在已经不再管它了，直接忽略”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着读到了Apple，它是类名。&lt;/span&gt;&lt;span&gt;编译器首先要获取类的全名，org.cnt.java.Apple。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后对它稍微转换一下形式，变成了，org/cnt/java/Apple，“这就是类名在字节码中的表示”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器发现这个Apple类没有显式继承父类，表明它继承自Object类，于是也获取它的全名，java/lang/Object。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着读到了implements Fruit，说明该类实现了Fruit接口，也获取全名，org/cnt/java/Fruit。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白说到，“这些比较容易理解，全名中把点号（.）替换为正斜线（/）肯定也是历史原因了。&lt;/span&gt;&lt;span&gt;但是这些信息如何存到数组里呢”？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“把点号替换为正斜线确实是历史原因”，编译器继续到，“这些字符串虽然都是类名或接口名，但本质还是字符串，类名、接口名只是赋予它的意义而已”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“除此之外，像字段名、方法名也都是字符串，同理，字段名、方法名也是赋予它的意义。&lt;/span&gt;&lt;span&gt;所以字符串是一种基本的数据，需要得到支持”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“除了字符串之外，还有整型数字，浮点数字，这些也是基本的数据，也需要得到支持”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，设计者们就设计出了以下几种类型，如图：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143408294-1221553458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;“左边是类型名称，方便理解，右边是对应的值，用于存储”，编译器继续到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“这里的Integer/Long/Float/Double和Utf8都是具体保存数据用的，表示整型数/浮点数和字符串。&lt;/span&gt;&lt;span&gt;其它的类型大都是对字符串的引用，并赋予它一定的意义”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“所以类名首先被存储为一个字符串，也就是Utf8，它的值对应的是1”。&lt;/span&gt;&lt;span&gt;编译器接着到，“由于字符串是一个变长的，所以就先用两个字节存储字符串的长度，接着跟上具体的字符串内容”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以字符串的结构就是这样，如图：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143420343-241855182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;“类名字符串的存储数据为，1、18、org/cnt/java/Apple。&lt;/span&gt;&lt;span&gt;第一个字节为1，表明是Utf8类型，第2、3两个字节存储18，表示字符串长度是18，接着存储真正的字符串。&lt;/span&gt;&lt;span&gt;所以共用去1 + 2 + 18 =&amp;gt; 21个字节”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“父类名字符串存储为，1、16、java/lang/Object。&lt;/span&gt;&lt;span&gt;共用去19个字节”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“接口名字符串存储为，1、18、org/cnt/java/Fruit。&lt;/span&gt;&lt;span&gt;共用去21个字节”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白听的不住点头，编译器喘口气，继续讲解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“字符串存好后，就该赋予它们意义了，在后续的操作中肯定涉及到对这些字符串的引用，所以还要给每个字符串分配一个编号”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如Apple为#2，即2号，Object为#4，Fruit为#6。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“由于这三个字符串都是类名或接口名，按照设计规定应该使用Class表示，对应的值为7，然后再指定一个字符串的编号即可”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此类或接口的表示如下图：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143435999-48093477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;“先用1个字节指明是类（接口），然后再用2个字节存储一个字符串的编号。&lt;/span&gt;&lt;span&gt;整体意思很直白，就是把这个编号的字符串当作类名或接口名”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“类就表示为，7、#2。&lt;/span&gt;&lt;span&gt;7表示是Class，#2表示类名称那个字符串的存储编号。&lt;/span&gt;&lt;span&gt;共用去3个字节”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“父类就表示，7、#4。&lt;/span&gt;&lt;span&gt;共用去3个字节。&lt;/span&gt;&lt;span&gt;接口就表示为，7、#6。&lt;/span&gt;&lt;span&gt;共用去3个字节”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实这三个Class也分别给它们一个编号，方便别的地方再引用它们。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（六）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;“其实上面这些内容都是常量，它们都位于常量池中，它们的编号就是自己在常量池中的索引”。&lt;/span&gt;&lt;span&gt;编译器说到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“常量池很多人都知道，起码至少是听说过。&lt;/span&gt;&lt;span&gt;但绝大多数人对它并不十分熟悉，因为很少有人见过它”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器继续到，“今天你可算是来着了”，说着就把小白写的类编译后生成的常量池摆到了桌子上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“这是什么东西啊，这么多，又很奇怪”，小白说到，这也是她第一次见。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ConstantPoolCount [getCount()=&lt;span&gt;46&lt;/span&gt;]&lt;br/&gt;ConstantPool [&lt;br/&gt;&lt;span&gt;#0&lt;/span&gt; = null&lt;br/&gt;&lt;span&gt;#1&lt;/span&gt; = ConstantClass [getNameIndex()=&lt;span&gt;2&lt;/span&gt;, getTag()=&lt;span&gt;7&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#2&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;18&lt;/span&gt;, getString()=org/cnt/java/Apple, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#3&lt;/span&gt; = ConstantClass [getNameIndex()=&lt;span&gt;4&lt;/span&gt;, getTag()=&lt;span&gt;7&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#4&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;16&lt;/span&gt;, getString()=java/lang/&lt;span&gt;Object&lt;/span&gt;, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#5&lt;/span&gt; = ConstantClass [getNameIndex()=&lt;span&gt;6&lt;/span&gt;, getTag()=&lt;span&gt;7&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#6&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;18&lt;/span&gt;, getString()=org/cnt/java/Fruit, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#7&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;4&lt;/span&gt;, getString()=&lt;span&gt;name&lt;/span&gt;, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#8&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;18&lt;/span&gt;, getString()=Ljava/lang/&lt;span&gt;String&lt;/span&gt;;, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#9&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;5&lt;/span&gt;, getString()=color, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#10&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;1&lt;/span&gt;, getString()=I, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#11&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;6&lt;/span&gt;, getString()=weight, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#12&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;1&lt;/span&gt;, getString()=D, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#13&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;6&lt;/span&gt;, getString()=&amp;lt;init&amp;gt;, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#14&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;3&lt;/span&gt;, getString()=()V, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#15&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;4&lt;/span&gt;, getString()=Code, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#16&lt;/span&gt; = ConstantMethodRef [getClassIndex()=&lt;span&gt;3&lt;/span&gt;, getNameAndTypeIndex()=&lt;span&gt;17&lt;/span&gt;, getTag()=&lt;span&gt;10&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#17&lt;/span&gt; = ConstantNameAndType [getNameIndex()=&lt;span&gt;13&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;14&lt;/span&gt;, getTag()=&lt;span&gt;12&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#18&lt;/span&gt; = ConstantDouble [getDouble()=&lt;span&gt;0.5&lt;/span&gt;, getTag()=&lt;span&gt;6&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#19&lt;/span&gt; = null&lt;br/&gt;&lt;span&gt;#20&lt;/span&gt; = ConstantFieldRef [getClassIndex()=&lt;span&gt;1&lt;/span&gt;, getNameAndTypeIndex()=&lt;span&gt;21&lt;/span&gt;, getTag()=&lt;span&gt;9&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#21&lt;/span&gt; = ConstantNameAndType [getNameIndex()=&lt;span&gt;11&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;12&lt;/span&gt;, getTag()=&lt;span&gt;12&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#22&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;15&lt;/span&gt;, getString()=LineNumberTable, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#23&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;18&lt;/span&gt;, getString()=LocalVariableTable, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#24&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;4&lt;/span&gt;, getString()=this, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#25&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;20&lt;/span&gt;, getString()=Lorg/cnt/java/Apple;, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#26&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;7&lt;/span&gt;, getString()=getName, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#27&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;20&lt;/span&gt;, getString()=()Ljava/lang/&lt;span&gt;String&lt;/span&gt;;, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#28&lt;/span&gt; = ConstantFieldRef [getClassIndex()=&lt;span&gt;1&lt;/span&gt;, getNameAndTypeIndex()=&lt;span&gt;29&lt;/span&gt;, getTag()=&lt;span&gt;9&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#29&lt;/span&gt; = ConstantNameAndType [getNameIndex()=&lt;span&gt;7&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;8&lt;/span&gt;, getTag()=&lt;span&gt;12&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#30&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;7&lt;/span&gt;, getString()=setName, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#31&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;21&lt;/span&gt;, getString()=(Ljava/lang/&lt;span&gt;String&lt;/span&gt;;)V, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#32&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;16&lt;/span&gt;, getString()=MethodParameters, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#33&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;8&lt;/span&gt;, getString()=getColor, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#34&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;3&lt;/span&gt;, getString()=()I, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#35&lt;/span&gt; = ConstantFieldRef [getClassIndex()=&lt;span&gt;1&lt;/span&gt;, getNameAndTypeIndex()=&lt;span&gt;36&lt;/span&gt;, getTag()=&lt;span&gt;9&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#36&lt;/span&gt; = ConstantNameAndType [getNameIndex()=&lt;span&gt;9&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;10&lt;/span&gt;, getTag()=&lt;span&gt;12&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#37&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;8&lt;/span&gt;, getString()=setColor, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#38&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;4&lt;/span&gt;, getString()=(I)V, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#39&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;3&lt;/span&gt;, getString()=()D, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#40&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;4&lt;/span&gt;, getString()=(D)V, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#41&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;10&lt;/span&gt;, getString()=SourceFile, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#42&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;10&lt;/span&gt;, getString()=Apple.java, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#43&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;25&lt;/span&gt;, getString()=RuntimeVisibleAnnotations, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#44&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;21&lt;/span&gt;, getString()=Lorg/cnt/java/Health;, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;#45&lt;/span&gt; = ConstantUtf8 [getLength()=&lt;span&gt;12&lt;/span&gt;, getString()=健康水果, getTag()=&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;“在常量池前面会用2个字节来存储常量池的大小，需要记住的是，这个大小不一定就是池中常量的个数。&lt;/span&gt;&lt;span&gt;但它减去1一定是最大的索引”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“因为，常量池中为0的位置（#0）永远不使用，还有Long和Double类型一个常量占2个连续索引（没错，又是历史原因），实际只是用了第1个索引，第2个索引永远空着（参见#18、#19）”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器继续到，“#0是特殊的，用来表示‘没有’的意思，其它地方如果想表达没有的话，可以指向它。&lt;/span&gt;&lt;span&gt;如Object是没有父类的，所以它的父类指向#0，即没有”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“所以常量都是从#1开始。&lt;/span&gt;&lt;span&gt;可以看看#1到#6的内容，就是刚刚上面讲的”。&lt;/span&gt;&lt;span&gt;编译器说到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“真是学到不少知识啊”，小白说到，“关于常量池能不能再多讲点”？&lt;/span&gt;&lt;span&gt;编译器只好继续讲。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（七）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;“常量池就是一个容器，它里面放了各种各样的所有信息，并且为每个信息分配一个编号（即索引），如果想要在其它地方使用这些信息，直接使用这个编号就行了”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器继续到，“这个常量池在一些语言中也被称为‘符号表’，通过编号来使用的这种方式也被称为‘符号引用’”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相信很多爱学习的同学对符号表和符号引用这两个词都很熟悉，不管之前是不是真懂，至少现在应该是真的搞懂了。&lt;/span&gt;&lt;span&gt;因为你已经看到了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“采用这种常量池和常量引用方式的好处其实很多，就说个最容易想到的，就是重复利用，节省空间，便于管理”。&lt;/span&gt;&lt;span&gt;编译器继续说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“比如一个类里有10个方法，每个方法里都定义一个length的局部变量，那么length这个名字就会出现在常量池里面，且只会出现一次，那10个方法都是对它的引用而已”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“如果有一个方法的名字也叫length的话，那也是对同一个常量的引用，因为这个length常量只是个字符串数据而已，本身没有明确含义，它的含义来自于引用它的常量”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“哦，原来如此”，小白开悟到，“‘符号表、符号引用’这些‘高大上’的叫法，不过就是根据索引去列表里获取元素罢了”，哈哈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器看到小白这么开心，就准备抛出一个问题，“打压”一下她。&lt;/span&gt;&lt;span&gt;于是说到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“常量池看上去和数组/列表非常相似，都是容器且都是基于索引访问的。&lt;/span&gt;&lt;span&gt;为啥常量池只被称为符号表，而不是符号数组或符号列表呢”？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白自然回答不上来。&lt;/span&gt;&lt;span&gt;编译器继续说，“表的英文单词是Table。&lt;/span&gt;&lt;span&gt;它和数组/列表的唯一区别就是，数组/列表里的元素长度都是固定的。&lt;/span&gt;&lt;span&gt;表里的元素长度是不固定的”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“常量池中的好几种常量的长度都是变长的，所以自然是表了”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白点了点头，心里想，这编译器就是厉害，我这辈子看来都无法达到他的高度了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器继续说到，“字节码的前8个字节存储魔数和版本，接着的2个（9和10）字节存储常量池的大小，后面接着（从11开始）就是整个常量池的内容了”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“之所以把常量池放这么靠前，是因为后面的所有内容都要依赖它、引用它”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;紧跟在常量池之后的就是这个类的基本信息，如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“首先用2个字节存储上面已经计算好的访问控制标志，即0x0021”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“然后用2个字节存储这个类在常量池中的索引，就是#1”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“然后用2个字节存储该类的父类在常量池中的索引，就是#3”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“由于接口可以有多个，所以再用2个字节存储接口的个数，因为只实现了1个接口，所以就存储数字1”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“接着存储所有接口在常量池中的索引，每个接口用2个字节。&lt;/span&gt;&lt;span&gt;因为只实现了1个接口，所以存储的索引就是#5”。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;AccessFlags&lt;/span&gt;&lt;span&gt; [getAccessFlags()=0x21, getAccessFlagsString()=[ACC_PUBLIC, ACC_SUPER]]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ThisClass&lt;/span&gt;&lt;span&gt; [getClassIndex()=1, getClassName()=org/cnt/java/Apple]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SuperClass&lt;/span&gt;&lt;span&gt; [getClassIndex()=3, getClassName()=java/lang/Object]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;InterfacesCount&lt;/span&gt;&lt;span&gt; [getCount()=1]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Interfaces&lt;/span&gt;&lt;span&gt; [getClassIndexes()=[5], getClassNames()=[org/cnt/java/Fruit]]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（八）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;编译器继续到，“接下来该读取字段信息了”。&lt;/span&gt;&lt;span&gt;当读到private时，就去下面这张表里找：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143507064-1143149045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;找到ACC_PRIVATE，把它的值0x0002保存以下，这就是该字段的访问控制标志。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着读到的是String，这是字段的类型，然后会把这个String类型存入常量池，对应的索引是#8。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到是一个Utf8，说明是字符串，内容是 Ljava/lang/String; ，以大写L开头，已分号;结尾，中间是类型全名，这是在字节码中表示类（对象）类型的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着读到的是name，这是字段名称，也是个字符串，同样也把它放入常量池，对应的索引是#7。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器说到，“现在一个字段的信息已经读取完毕，按照相同的方式把剩余的两个字段也读取完毕”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“那字段的信息又该怎么存储呢”？&lt;/span&gt;&lt;span&gt;小白问到。&lt;/span&gt;&lt;span&gt;“不要着急嘛”，编译器说着就拿出了字段的存储格式：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143529919-1026227885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;首先2个字节是访问控制标志，接着2个字节是字段名称在常量池中的索引，接着2个字节是字段描述（即类型）在常量池中的索引。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着2个字节就是属性个数，然后就是具体的属性信息了。&lt;/span&gt;&lt;span&gt;例如字段上标有注解的话，这个注解信息就会放入属性信息里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器继续说到，“属性信息是字节码中比较复杂的内容，这里就不说太多了”。&lt;/span&gt;&lt;span&gt;接着就可以按格式整理数据了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为一个类的字段可以有多个，所以先用2个字节存储一下字段数目，本类有3个字段，所以就存储个3。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一个字段，0x0002、#7、#8、0。&lt;/span&gt;&lt;span&gt;共用去8个字节，因为自动没有属性内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二个字段，0x0002、#9、#10、0。&lt;/span&gt;&lt;span&gt;共用去8个字节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二个字段，0x0002、#11、#12、0。&lt;/span&gt;&lt;span&gt;共用去8个字节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器接着说，“所以存储这3个字段信息共用去2 + 8 + 8 + 8 =&amp;gt; 26个字节”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白说到，“我现在基本已经搞明白套路了。&lt;/span&gt;&lt;span&gt;其实有些东西没有想象中的那么复杂啊”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“复杂的东西还是有的，我们现在先不考虑”，编译器说到，“还有一个问题，不知你发现了没有”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;字段color的类型是int，但是在常量池中却变为大写字母I，同样weight的类型是double，常量池中却是大写字母D。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白说到，“我来猜测一下吧，int、double是Java中的数据类型，I、D是与之对应的在JVM中的表示形式。&lt;/span&gt;&lt;span&gt;对吧”？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“算你聪明”，编译器说到，“其实Java和JVM之间关于类型这块有一个映射表”，如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143543764-1867582125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;有两个需要注意。&lt;/span&gt;&lt;span&gt;“第一点上面已经说过了，就是类都会映射成LClassName;这种形式，如Object映射为Ljava/lang/Object;”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二点是数组，“数组在Java中用一对中括号（[]）表示，在JVM中只用左中括号（[）表示。&lt;/span&gt;&lt;span&gt;也就是[]映射为[”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“多维数组也一样，[][][]映射为[[[”。&lt;/span&gt;&lt;span&gt;然后还有类型，“Java是把类型放到前面，JVM是把类型放到后面”。&lt;/span&gt;&lt;span&gt;如double[]映射为[D。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“double[][][]映射为[[[D”。&lt;/span&gt;&lt;span&gt;同理，“String[]映射为[Ljava/lang/String;，Object[][]映射为[[Ljava/lang/Object;”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“我似乎又明白了一些，Java有自己的规范，字节码也有自己的规范，它们之间的映射关系早都已经定义好了”。&lt;/span&gt;&lt;span&gt;小白继续到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“只要按照这种映射关系，就能把Java源码给转换为字节码。&lt;/span&gt;&lt;span&gt;是吧”？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“粗略来说，可以这么理解，其实这就是编译了，但一定要清楚，真正的编译是非常复杂的一个事情”，编译器到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白说到，“字段完了之后，肯定该方法了，就交给我吧，让我也试试”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“年轻人啊，就是生猛，你来试试吧”。&lt;/span&gt;&lt;span&gt;编译器说到。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FieldsCount [getCount()=&lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;Fields [&lt;br/&gt;&lt;span&gt;#0&lt;/span&gt; = FieldInfo [getAccessFlags()=FieldAccessFlags [getAccessFlags()=&lt;span&gt;0&lt;/span&gt;x2, getAccessFlagsString()=[ACC_PRIVATE]], getNameIndex()=&lt;span&gt;7&lt;/span&gt;, getName()=&lt;span&gt;name&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;8&lt;/span&gt;, getDescriptor()=Ljava/lang/&lt;span&gt;String&lt;/span&gt;;, getAttributesCount()=&lt;span&gt;0&lt;/span&gt;, getAttributes()=[]]&lt;br/&gt;&lt;span&gt;#1&lt;/span&gt; = FieldInfo [getAccessFlags()=FieldAccessFlags [getAccessFlags()=&lt;span&gt;0&lt;/span&gt;x2, getAccessFlagsString()=[ACC_PRIVATE]], getNameIndex()=&lt;span&gt;9&lt;/span&gt;, getName()=color, getDescriptorIndex()=&lt;span&gt;10&lt;/span&gt;, getDescriptor()=I, getAttributesCount()=&lt;span&gt;0&lt;/span&gt;, getAttributes()=[]]&lt;br/&gt;&lt;span&gt;#2&lt;/span&gt; = FieldInfo [getAccessFlags()=FieldAccessFlags [getAccessFlags()=&lt;span&gt;0&lt;/span&gt;x2, getAccessFlagsString()=[ACC_PRIVATE]], getNameIndex()=&lt;span&gt;11&lt;/span&gt;, getName()=weight, getDescriptorIndex()=&lt;span&gt;12&lt;/span&gt;, getDescriptor()=D, getAttributesCount()=&lt;span&gt;0&lt;/span&gt;, getAttributes()=[]]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（九）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;小白说，“方法呢肯定也有自己的格式，你把它找出来我看看”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“好好，我这就找”，编译器苦笑到。&lt;/span&gt;&lt;span&gt;我堂堂一个编译器，今天竟然成了小白的助手，惭愧啊。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说着编译器就找到了，于是放到了桌子上：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143600877-443098320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;“咦，怎么和字段的一模一样”，小白到。&lt;/span&gt;&lt;span&gt;那这就更简单了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先是访问控制标志，接着是方法名称索引，然后是方法描述索引，最后是和方法关联的属性。&lt;/span&gt;&lt;span&gt;于是照猫画虎，小白就开始了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先读到public关键字，这是个访问控制修饰符，肯定也有一张表和它对应，可以找到这个关键字对应的数值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还没等小白开口，编译器就赶紧把表找出来了：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143636833-80337228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;小白继续，ACC_PUBLIC对应的值是0x0001，就把这个值先保存起来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后是方法的名字，getName，是一个字符串，照例把它存入常量池，并且有一个索引，就是#26。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着该方法的描述了，小白认为方法和字段是不同的，除了有返回类型之外，还有参数呢，这该咋整呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是就问编译器，“方法的描述应该也有格式吧”？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“你越来越聪明了”，编译器说到，“其实也很简单，我来简单说下吧”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“在Java中如果把访问控制符、方法名、参数名、方法体都去掉，其实就剩下‘方法签名’了”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如，没有入参没有返回值的，就是这个样子，void()。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;返回值为String，入参为int，double，String的，其实就是这样个子，String(int, double, String)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“这个方法签名其实就是在Java中对方法的描述，在字节码中和它差不多，就是把返回类型放到后面，把参数间的逗号去掉”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此void()映射为()V，这里要注意的是void对应的是大写字母V。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;String(int, double, String)映射为(IDLjava/lang/String;)Ljava/lang/String;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“不难，不难”，小白说到，于是又继续开始了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白按照这种格式，把刚刚的那个方法描述也存入了常量池，得到的索引就是#27。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白按这个套路把6个方法都整理好了，接下来该按格式把数据写入字节数组了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编程新说注：&lt;/span&gt;&lt;span&gt;方法的代码对应的是JVM的指令，这里就忽略不谈了，后续可能会单独再说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器提醒小白说，“你是不是还漏掉了一个方法啊”？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白又看了一遍Java源码，仔细数了数，是6个呀，没错啊。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器说到，你在学习时有没有见过这样一句话，“当类没有定义构造函数时，编译器会为它生成一个默认的无参构造函数”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白连忙点头，“嗯嗯嗯，见过的”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“这就是了”，编译器说道，“不过需要注意的是，在字节码中构造方法的名字都是&amp;lt;init&amp;gt;，返回类型都是V”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“这也是规定的吧”，小白说到，编译器点了点头。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器又说到，“其实还有方法的参数信息，如参数位置，参数类型，参数名称，参数的访问控制标志等”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“这些信息都是放在方法格式里最后的属性信息中的，咱们也暂时不说它们了”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编程新说注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在JDK7及以前，字节码中不包含方法的参数名。&lt;/span&gt;&lt;span&gt;因为JVM执行指令时，参数是按位置传入的，所以参数名对代码的执行没有用处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于越来越多的框架采用按方法参数名进行数值绑定，Java也只好在JDK8时加入了对参数名的支持。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过需要设置一下编译器的–parameters参数，这样才能把方法参数名也放入字节码中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看看常量池中的#32是“MethodParameters”字符串，说明字节码中已经包含参数名了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常量池中#7、#9、#11三个字符串就是参数名，同时也是字段名，这就是复用的好处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编程新说注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;方法的格式和字段的格式完全一样，就不再演示写入过程了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此这个类共有7个方法。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MethodsCount [getCount()=&lt;span&gt;7&lt;/span&gt;]&lt;br/&gt;Methods [&lt;br/&gt;&lt;span&gt;#0&lt;/span&gt; = MethodInfo [getAccessFlags()=MethodAccessFlags [getAccessFlags()=&lt;span&gt;0&lt;/span&gt;x1, getAccessFlagsString()=[ACC_PUBLIC]], getNameIndex()=&lt;span&gt;13&lt;/span&gt;, getName()=&amp;lt;init&amp;gt;, getDescriptorIndex()=&lt;span&gt;14&lt;/span&gt;, getDescriptor()=()V, getAttributesCount()=&lt;span&gt;1&lt;/span&gt;, getAttributes()=[Code [getMaxStack()=&lt;span&gt;3&lt;/span&gt;, getMaxLocals()=&lt;span&gt;1&lt;/span&gt;, getCodeLength()=&lt;span&gt;12&lt;/span&gt;, getJvmCode()=JvmCode [getCode()=&lt;span&gt;12&lt;/span&gt;], getExceptionTableLength()=&lt;span&gt;0&lt;/span&gt;, getExceptionTables()=[], getAttributesCount()=&lt;span&gt;2&lt;/span&gt;, getAttributes()=[LineNumberTable [getLineNumTableLength()=&lt;span&gt;3&lt;/span&gt;, getLineNumTables()=[LineNumTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLineNumber()=&lt;span&gt;8&lt;/span&gt;], LineNumTable [getStartPc()=&lt;span&gt;4&lt;/span&gt;, getLineNumber()=&lt;span&gt;12&lt;/span&gt;], LineNumTable [getStartPc()=&lt;span&gt;11&lt;/span&gt;, getLineNumber()=&lt;span&gt;8&lt;/span&gt;]]], LocalVariableTable [getLocalVarTableLength()=&lt;span&gt;1&lt;/span&gt;, getLocalVarTables()=[LocalVarTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLength()=&lt;span&gt;12&lt;/span&gt;, getNameIndex()=&lt;span&gt;24&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;25&lt;/span&gt;, getIndex()=&lt;span&gt;0&lt;/span&gt;]]]]]]]&lt;br/&gt;&lt;span&gt;#1&lt;/span&gt; = MethodInfo [getAccessFlags()=MethodAccessFlags [getAccessFlags()=&lt;span&gt;0&lt;/span&gt;x1, getAccessFlagsString()=[ACC_PUBLIC]], getNameIndex()=&lt;span&gt;26&lt;/span&gt;, getName()=getName, getDescriptorIndex()=&lt;span&gt;27&lt;/span&gt;, getDescriptor()=()Ljava/lang/&lt;span&gt;String&lt;/span&gt;;, getAttributesCount()=&lt;span&gt;1&lt;/span&gt;, getAttributes()=[Code [getMaxStack()=&lt;span&gt;1&lt;/span&gt;, getMaxLocals()=&lt;span&gt;1&lt;/span&gt;, getCodeLength()=&lt;span&gt;5&lt;/span&gt;, getJvmCode()=JvmCode [getCode()=&lt;span&gt;5&lt;/span&gt;], getExceptionTableLength()=&lt;span&gt;0&lt;/span&gt;, getExceptionTables()=[], getAttributesCount()=&lt;span&gt;2&lt;/span&gt;, getAttributes()=[LineNumberTable [getLineNumTableLength()=&lt;span&gt;1&lt;/span&gt;, getLineNumTables()=[LineNumTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLineNumber()=&lt;span&gt;16&lt;/span&gt;]]], LocalVariableTable [getLocalVarTableLength()=&lt;span&gt;1&lt;/span&gt;, getLocalVarTables()=[LocalVarTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLength()=&lt;span&gt;5&lt;/span&gt;, getNameIndex()=&lt;span&gt;24&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;25&lt;/span&gt;, getIndex()=&lt;span&gt;0&lt;/span&gt;]]]]]]]&lt;br/&gt;&lt;span&gt;#2&lt;/span&gt; = MethodInfo [getAccessFlags()=MethodAccessFlags [getAccessFlags()=&lt;span&gt;0&lt;/span&gt;x1, getAccessFlagsString()=[ACC_PUBLIC]], getNameIndex()=&lt;span&gt;30&lt;/span&gt;, getName()=setName, getDescriptorIndex()=&lt;span&gt;31&lt;/span&gt;, getDescriptor()=(Ljava/lang/&lt;span&gt;String&lt;/span&gt;;)V, getAttributesCount()=&lt;span&gt;2&lt;/span&gt;, getAttributes()=[Code [getMaxStack()=&lt;span&gt;2&lt;/span&gt;, getMaxLocals()=&lt;span&gt;2&lt;/span&gt;, getCodeLength()=&lt;span&gt;6&lt;/span&gt;, getJvmCode()=JvmCode [getCode()=&lt;span&gt;6&lt;/span&gt;], getExceptionTableLength()=&lt;span&gt;0&lt;/span&gt;, getExceptionTables()=[], getAttributesCount()=&lt;span&gt;2&lt;/span&gt;, getAttributes()=[LineNumberTable [getLineNumTableLength()=&lt;span&gt;2&lt;/span&gt;, getLineNumTables()=[LineNumTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLineNumber()=&lt;span&gt;21&lt;/span&gt;], LineNumTable [getStartPc()=&lt;span&gt;5&lt;/span&gt;, getLineNumber()=&lt;span&gt;22&lt;/span&gt;]]], LocalVariableTable [getLocalVarTableLength()=&lt;span&gt;2&lt;/span&gt;, getLocalVarTables()=[LocalVarTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLength()=&lt;span&gt;6&lt;/span&gt;, getNameIndex()=&lt;span&gt;24&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;25&lt;/span&gt;, getIndex()=&lt;span&gt;0&lt;/span&gt;], LocalVarTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLength()=&lt;span&gt;6&lt;/span&gt;, getNameIndex()=&lt;span&gt;7&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;8&lt;/span&gt;, getIndex()=&lt;span&gt;1&lt;/span&gt;]]]]], MethodParameters [getParametersCount()=&lt;span&gt;1&lt;/span&gt;, getParameters()=[Parameter [getNameIndex()=&lt;span&gt;7&lt;/span&gt;, getAccessFlags()=&lt;span&gt;0&lt;/span&gt;x0]]]]]&lt;br/&gt;&lt;span&gt;#3&lt;/span&gt; = MethodInfo [getAccessFlags()=MethodAccessFlags [getAccessFlags()=&lt;span&gt;0&lt;/span&gt;x1, getAccessFlagsString()=[ACC_PUBLIC]], getNameIndex()=&lt;span&gt;33&lt;/span&gt;, getName()=getColor, getDescriptorIndex()=&lt;span&gt;34&lt;/span&gt;, getDescriptor()=()I, getAttributesCount()=&lt;span&gt;1&lt;/span&gt;, getAttributes()=[Code [getMaxStack()=&lt;span&gt;1&lt;/span&gt;, getMaxLocals()=&lt;span&gt;1&lt;/span&gt;, getCodeLength()=&lt;span&gt;5&lt;/span&gt;, getJvmCode()=JvmCode [getCode()=&lt;span&gt;5&lt;/span&gt;], getExceptionTableLength()=&lt;span&gt;0&lt;/span&gt;, getExceptionTables()=[], getAttributesCount()=&lt;span&gt;2&lt;/span&gt;, getAttributes()=[LineNumberTable [getLineNumTableLength()=&lt;span&gt;1&lt;/span&gt;, getLineNumTables()=[LineNumTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLineNumber()=&lt;span&gt;26&lt;/span&gt;]]], LocalVariableTable [getLocalVarTableLength()=&lt;span&gt;1&lt;/span&gt;, getLocalVarTables()=[LocalVarTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLength()=&lt;span&gt;5&lt;/span&gt;, getNameIndex()=&lt;span&gt;24&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;25&lt;/span&gt;, getIndex()=&lt;span&gt;0&lt;/span&gt;]]]]]]]&lt;br/&gt;&lt;span&gt;#4&lt;/span&gt; = MethodInfo [getAccessFlags()=MethodAccessFlags [getAccessFlags()=&lt;span&gt;0&lt;/span&gt;x1, getAccessFlagsString()=[ACC_PUBLIC]], getNameIndex()=&lt;span&gt;37&lt;/span&gt;, getName()=setColor, getDescriptorIndex()=&lt;span&gt;38&lt;/span&gt;, getDescriptor()=(I)V, getAttributesCount()=&lt;span&gt;2&lt;/span&gt;, getAttributes()=[Code [getMaxStack()=&lt;span&gt;2&lt;/span&gt;, getMaxLocals()=&lt;span&gt;2&lt;/span&gt;, getCodeLength()=&lt;span&gt;6&lt;/span&gt;, getJvmCode()=JvmCode [getCode()=&lt;span&gt;6&lt;/span&gt;], getExceptionTableLength()=&lt;span&gt;0&lt;/span&gt;, getExceptionTables()=[], getAttributesCount()=&lt;span&gt;2&lt;/span&gt;, getAttributes()=[LineNumberTable [getLineNumTableLength()=&lt;span&gt;2&lt;/span&gt;, getLineNumTables()=[LineNumTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLineNumber()=&lt;span&gt;31&lt;/span&gt;], LineNumTable [getStartPc()=&lt;span&gt;5&lt;/span&gt;, getLineNumber()=&lt;span&gt;32&lt;/span&gt;]]], LocalVariableTable [getLocalVarTableLength()=&lt;span&gt;2&lt;/span&gt;, getLocalVarTables()=[LocalVarTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLength()=&lt;span&gt;6&lt;/span&gt;, getNameIndex()=&lt;span&gt;24&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;25&lt;/span&gt;, getIndex()=&lt;span&gt;0&lt;/span&gt;], LocalVarTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLength()=&lt;span&gt;6&lt;/span&gt;, getNameIndex()=&lt;span&gt;9&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;10&lt;/span&gt;, getIndex()=&lt;span&gt;1&lt;/span&gt;]]]]], MethodParameters [getParametersCount()=&lt;span&gt;1&lt;/span&gt;, getParameters()=[Parameter [getNameIndex()=&lt;span&gt;9&lt;/span&gt;, getAccessFlags()=&lt;span&gt;0&lt;/span&gt;x0]]]]]&lt;br/&gt;&lt;span&gt;#5&lt;/span&gt; = MethodInfo [getAccessFlags()=MethodAccessFlags [getAccessFlags()=&lt;span&gt;0&lt;/span&gt;x1, getAccessFlagsString()=[ACC_PUBLIC]], getNameIndex()=&lt;span&gt;11&lt;/span&gt;, getName()=weight, getDescriptorIndex()=&lt;span&gt;39&lt;/span&gt;, getDescriptor()=()D, getAttributesCount()=&lt;span&gt;1&lt;/span&gt;, getAttributes()=[Code [getMaxStack()=&lt;span&gt;2&lt;/span&gt;, getMaxLocals()=&lt;span&gt;1&lt;/span&gt;, getCodeLength()=&lt;span&gt;5&lt;/span&gt;, getJvmCode()=JvmCode [getCode()=&lt;span&gt;5&lt;/span&gt;], getExceptionTableLength()=&lt;span&gt;0&lt;/span&gt;, getExceptionTables()=[], getAttributesCount()=&lt;span&gt;2&lt;/span&gt;, getAttributes()=[LineNumberTable [getLineNumTableLength()=&lt;span&gt;1&lt;/span&gt;, getLineNumTables()=[LineNumTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLineNumber()=&lt;span&gt;35&lt;/span&gt;]]], LocalVariableTable [getLocalVarTableLength()=&lt;span&gt;1&lt;/span&gt;, getLocalVarTables()=[LocalVarTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLength()=&lt;span&gt;5&lt;/span&gt;, getNameIndex()=&lt;span&gt;24&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;25&lt;/span&gt;, getIndex()=&lt;span&gt;0&lt;/span&gt;]]]]]]]&lt;br/&gt;&lt;span&gt;#6&lt;/span&gt; = MethodInfo [getAccessFlags()=MethodAccessFlags [getAccessFlags()=&lt;span&gt;0&lt;/span&gt;x1, getAccessFlagsString()=[ACC_PUBLIC]], getNameIndex()=&lt;span&gt;11&lt;/span&gt;, getName()=weight, getDescriptorIndex()=&lt;span&gt;40&lt;/span&gt;, getDescriptor()=(D)V, getAttributesCount()=&lt;span&gt;2&lt;/span&gt;, getAttributes()=[Code [getMaxStack()=&lt;span&gt;3&lt;/span&gt;, getMaxLocals()=&lt;span&gt;3&lt;/span&gt;, getCodeLength()=&lt;span&gt;6&lt;/span&gt;, getJvmCode()=JvmCode [getCode()=&lt;span&gt;6&lt;/span&gt;], getExceptionTableLength()=&lt;span&gt;0&lt;/span&gt;, getExceptionTables()=[], getAttributesCount()=&lt;span&gt;2&lt;/span&gt;, getAttributes()=[LineNumberTable [getLineNumTableLength()=&lt;span&gt;2&lt;/span&gt;, getLineNumTables()=[LineNumTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLineNumber()=&lt;span&gt;39&lt;/span&gt;], LineNumTable [getStartPc()=&lt;span&gt;5&lt;/span&gt;, getLineNumber()=&lt;span&gt;40&lt;/span&gt;]]], LocalVariableTable [getLocalVarTableLength()=&lt;span&gt;2&lt;/span&gt;, getLocalVarTables()=[LocalVarTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLength()=&lt;span&gt;6&lt;/span&gt;, getNameIndex()=&lt;span&gt;24&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;25&lt;/span&gt;, getIndex()=&lt;span&gt;0&lt;/span&gt;], LocalVarTable [getStartPc()=&lt;span&gt;0&lt;/span&gt;, getLength()=&lt;span&gt;6&lt;/span&gt;, getNameIndex()=&lt;span&gt;11&lt;/span&gt;, getDescriptorIndex()=&lt;span&gt;12&lt;/span&gt;, getIndex()=&lt;span&gt;1&lt;/span&gt;]]]]], MethodParameters [getParametersCount()=&lt;span&gt;1&lt;/span&gt;, getParameters()=[Parameter [getNameIndex()=&lt;span&gt;11&lt;/span&gt;, getAccessFlags()=&lt;span&gt;0&lt;/span&gt;x0]]]]]&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;编程新说注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;方法部分的输出内容很多，是因为包含了方法体的代码的信息。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（十）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;“真是后生可畏啊”，编译器感慨到。&lt;/span&gt;&lt;span&gt;“小白竟然也能按照套路去在做点事情了”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过编译器并不自危，因为最核心的内容是，可执行代码如何转换为JVM指令集中的指令，这可是“压箱底”的干货，可不能随便告诉别人，长得再好看也不行。&lt;/span&gt;&lt;span&gt;哈哈，O(∩_∩)O。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着编译器拿出一个完整的字节码文件格式图给小白看：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143656302-366859570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;小白看完后说，“和刚刚讲的一样，只是最后也有这个属性信息啊”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译器说，“属性信息是字节码文件中非常复杂的内容，可以暂时不管用了”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面已经说了，至少注解的相关内容是放在属性信息里的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那就看看你写的这个类的属性信息都是什么吧：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;AttributesCount&lt;/span&gt; [getCount()=&lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;Attributes [&lt;br/&gt;&lt;span&gt;#0 = SourceFile [getSourcefileIndex()=42]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#1 = RuntimeVisibleAnnotations [getNumAnnotations()=1, getAnnotations()=[Annotation [getTypeIndex()=44, getNumElementValuePairs()=1, getElementValuePairs()=[ElementValuePair [getElementNameIndex()=7, getElementValue()=ElementValue [getTag()=ElementValueTag [getTagChar()=s], getUnion()=ElementValueUnion [getConstValueIndex()=45]]]]]]]&lt;/span&gt;&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;编译器继续说，共有2条属性信息，第一条是源代码文件的名字，在常量池中的#42。&lt;/span&gt;&lt;span&gt;其实就是Apple.java了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二条是运行时可见的注解信息，本类共有1个注解，注解类型是常量池中的#44。&lt;/span&gt;&lt;span&gt;其实就是Lorg/cnt/java/Health;了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该注解共显式设置了1对属性值。&lt;/span&gt;&lt;span&gt;属性名称是常量池中的#7，就是name了，类型是小写的s，表示String类型，属性值是#45，也就是“健康水果”了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图中的这些类型，都是可以用于注解属性的类型：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143708246-394126206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;最后，编译器打印出一行信息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-----bytes=1085-----&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白说，“这是什么意思”？“这是编译后产生的字节码的总长度，是1085个字节”，编译器到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小白刚想表达对编译器的感谢，忽然闻到一阵香味，而且是肉香。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;PS&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：最后几句话就不写了，请你来补充完整吧，嘻嘻。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 热门文章集锦 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484219&amp;amp;idx=1&amp;amp;sn=e6c39138e44ce8f0c91aba4873fb42cd&amp;amp;chksm=fc3338cbcb44b1dde7ae372ed66b40bdf4f755d711008810eb837a8f78d884f00956ae7ce7a7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;毕业10年，我有话说&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483949&amp;amp;idx=1&amp;amp;sn=200c9ac4f8e4e877b0b253d45205712a&amp;amp;chksm=fc3339ddcb44b0cb5ac2957dbed41b2f9e11fbba14967d00f97012806a9d6af364b0f8135eee&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何面试别人List相关知识的，深度有点长文&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483989&amp;amp;idx=1&amp;amp;sn=cf9ce5c3f7981c16b71047b868b1c1ab&amp;amp;chksm=fc3339a5cb44b0b3df524ce684e8cd76ab6d15a2ccf26ec2425ecbcdd26bc777b95a06994189&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;我是如何在毕业不久只用1年就升为开发组长的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483994&amp;amp;idx=1&amp;amp;sn=fb09e943331e89abcb99d8304ea6b677&amp;amp;chksm=fc3339aacb44b0bc2a120c79efebb46a43ce5b4d3148992d86b2841a89bb46bf5d8863e065ea&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;爸爸又给Spring MVC生了个弟弟叫Spring WebFlux&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484017&amp;amp;idx=1&amp;amp;sn=a2055640b142fc4cfa5a9901d22ec57f&amp;amp;chksm=fc333981cb44b09782c196da25dc613b38a9ede52de073bfaaaef6214a9deb294b6527091892&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Spring事务时“套路”对方的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484029&amp;amp;idx=1&amp;amp;sn=44b05473af37fe008bb9659a35d1a9de&amp;amp;chksm=fc33398dcb44b09bbd25a7e14e7100419988479fbeb4bda7787f1b93dd932ec699dfd793df04&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】Spring事务面试考点吐血整理（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484158&amp;amp;idx=1&amp;amp;sn=1ca952ba9166c5ccf0e3f40622335fc5&amp;amp;chksm=fc33390ecb44b01898bb2500ba61a15e38487a23f5c0405d738cc4c272cd705d2dbbf1a3f8e7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Redis相关知识时“软怼”他的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484164&amp;amp;idx=1&amp;amp;sn=390d911b19812d22aebd3f0f6522004c&amp;amp;chksm=fc3338f4cb44b1e20bc2344474586934a2b148f92eefdaecf134d57af10f64310579e196904a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】吃透了这些Redis知识点，面试官一定觉得你很NB（干货 | 建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484184&amp;amp;idx=1&amp;amp;sn=37007efde0cc93e48c55a133dc9cc8d4&amp;amp;chksm=fc3338e8cb44b1fea0ed4af7f01de658e8a1bc7f573cb5bde2701d9b09ba14747139d2bcea39&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果你这样回答“什么是线程安全”，面试官都会对你刮目相看（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484195&amp;amp;idx=1&amp;amp;sn=95c3acdaeb0f6a1d61f152550c3d2669&amp;amp;chksm=fc3338d3cb44b1c55f6046f6280da863d3514cca3ce50ef29e2d53b0eafe2b7efef062c51c27&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO讲的这么清楚的好文章（快快珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484201&amp;amp;idx=1&amp;amp;sn=7cf45aff64eecdff58d2acea8fb7c9fa&amp;amp;chksm=fc3338d9cb44b1cfc6b5c797a005c91ed19b0dd06587fdfb2e7b553e2b03104a145380a7a990&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】一篇文章帮你彻底搞清楚“I/O多路复用”和“异步I/O”的前世今生（深度好文，建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484206&amp;amp;idx=1&amp;amp;sn=9547fdad111ac1a8ac9311cb9e76b9dc&amp;amp;chksm=fc3338decb44b1c89aee789e80e32989ea43232321397cc265c99b1d0ce4057e6563bc00a3d3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果把线程当作一个人来对待，所有问题都瞬间明白了&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484214&amp;amp;idx=1&amp;amp;sn=0f677e8b0d61b5a5317a274cc8b33cbc&amp;amp;chksm=fc3338c6cb44b1d06aa20533aafb0b7b709b3bd88dbf6af6b8f3cb91288e4afc585ecb77489a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java多线程通关———基础知识挑战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：帝国的基石&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是工作超过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;10年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的码农，现在任架构师。喜欢研究技术，崇尚简单快乐。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;追求以通俗易懂的语言解说技术，希望所有的读者都能看懂并记住。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;下面是公众号的二维码，欢迎关注！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215143717617-1522503453.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
</description>
<pubDate>Fri, 05 Jun 2020 00:29:00 +0000</pubDate>
<dc:creator>编程新说(李新杰)</dc:creator>
<og:description>万字长文，完全虚构。 （一） 组里来了个实习生，李大胖面完之后，觉得水平一般，但还是留了下来，为什么呢？各自猜去吧。李大胖也在心里开导自己，学生嘛，不能要求太高，只要肯上进，慢慢来。就称呼为小白吧。小</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixinjie/p/a-birth-process-of-a-java-bytecode-file.html</dc:identifier>
</item>
<item>
<title>Mac 制作 Linux 启动盘 - Sitoi</title>
<link>http://www.cnblogs.com/sitoi/p/13047622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sitoi/p/13047622.html</guid>
<description>&lt;blockquote readability=&quot;1.9444444444444&quot;&gt;
&lt;p&gt;本文原始地址：&lt;a href=&quot;https://sitoi.cn/posts/28583.html&quot;&gt;https://sitoi.cn/posts/28583.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;前期准备&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;一个 Mac 电脑&lt;/li&gt;
&lt;li&gt;一个 U 盘（8GB 以上）&lt;/li&gt;
&lt;li&gt;下载好 Linux 系统镜像（iso 文件）&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;具体步骤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;挂载 U 盘&lt;/li&gt;
&lt;li&gt;解挂 U 盘&lt;/li&gt;
&lt;li&gt;写系统镜像到 U 盘&lt;/li&gt;
&lt;li&gt;完成&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;一、挂载-u-盘&quot;&gt;一、挂载 U 盘&lt;/h2&gt;
&lt;p&gt;首先插入 U 盘，打开终端输入下面的命令查看 U 盘是否已经 mount 到系统，或者在 Finder 下也可以看到 U 盘被识别了，如下图所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;diskutil list
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Sitoi/cdn/img/mac-u-linux/diskutil_list.png&quot; alt=&quot;diskutil unmountDisk&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、解挂-u-盘&quot;&gt;二、解挂 U 盘&lt;/h2&gt;
&lt;p&gt;使用 unmount 命令 解除挂载，命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;diskutil unmountDisk /dev/disk3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Sitoi/cdn/img/mac-u-linux/diskutil_unmountDisk.png&quot; alt=&quot;diskutil unmountDisk&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就有了一个已经插入但是 unmount 的 U 盘了，这时候你在 Finder 下看不到这个U盘了，但是用 &lt;code&gt;diskutil list&lt;/code&gt; 命令还可以看到。&lt;/p&gt;
&lt;h2 id=&quot;三、写系统镜像到-u-盘&quot;&gt;三、写系统镜像到 U 盘&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;  sudo dd if=/Users/shitao/Downloads/CentOS-7-x86_64-DVD-2003.iso of=/dev/disk3 bs=1m
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;if=&lt;/code&gt; 后面是 Linux ios 文件的的路径&lt;/p&gt;
&lt;p&gt;&lt;code&gt;of=&lt;/code&gt; 后面的是 U 盘的名称&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bs&lt;/code&gt; 表示写入块大小，可以设置为 2m，但不要太大&lt;/p&gt;
&lt;p&gt;Tips：因为是 sudo 所以需要输入密码，输入后按回车即可。&lt;/p&gt;
&lt;h2 id=&quot;四、完成&quot;&gt;四、完成&lt;/h2&gt;
&lt;p&gt;等待几分钟，见到如下输出就表示已经成功完成了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;4560+0 records in
4560+0 records out
4781506560 bytes transferred in 291.165911 secs (16421931 bytes/sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Sitoi/cdn/img/mac-u-linux/sudo_dd_if_of_bs.png&quot; alt=&quot;输出结果&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Jun 2020 00:11:00 +0000</pubDate>
<dc:creator>Sitoi</dc:creator>
<og:description>本文原始地址：https://sitoi.cn/posts/28583.html 前期准备 一个 Mac 电脑 一个 U 盘（8GB 以上） 下载好 Linux 系统镜像（iso 文件） 具体步骤 挂</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sitoi/p/13047622.html</dc:identifier>
</item>
<item>
<title>我去，这么简单的条件表达式竟然也有这么多坑 - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/13047617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/13047617.html</guid>
<description>&lt;p&gt;最近，小黑哥在一个业务改造中，使用三目运算符重构了业务代码，没想到测试的时候竟然发生 NPE 的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200605080535253-1710539836.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重构代码非常简单，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 方法返回参数类型为 Integer
//  private Integer code;
SimpleObj simpleObj = new SimpleObj();
// 其他业务逻辑
if (simpleObj == null) {
    return -1;
} else {
    return simpleObj.getCode();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段 if 判断，小黑哥看到的时候，感觉很是繁琐，于是使用条件表达式重构了一把，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 方法返回参数类型为 Integer
SimpleObj simpleObj = new SimpleObj();
// 其他业务逻辑
return simpleObj == null ? -1 : simpleObj.getCode();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试的时候，第四行代码抛出了空指针，这里代码很简单，显然只有 &lt;code&gt;simpleObj#getCode&lt;/code&gt;才有可能发生 NPE 问题。&lt;/p&gt;
&lt;p&gt;但是我明明为 &lt;code&gt;simpleObj&lt;/code&gt;做过判空判断，&lt;code&gt;simpleObj&lt;/code&gt; 对象肯定不是 null，那么只有 &lt;code&gt;simpleObj#getCode&lt;/code&gt; 返回为 null。但是我的代码并没有对这个方法返回值做任何操作，为何会触发 NPE？&lt;/p&gt;
&lt;p&gt;难道是又是自动拆箱导致的 NPE 问题？&lt;/p&gt;
&lt;p&gt;在解答这个问题之前，我们首先复习一下条件表达式。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;点赞再看，养成习惯。微信搜索『程序通事』，关注查看最新文章~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三目运算符&quot;&gt;三目运算符&lt;/h2&gt;
&lt;p&gt;三目运算符，官方英文名称:&lt;strong&gt;Conditional Operator ? :&lt;/strong&gt;,又叫条件表达式，本文不纠结名称，统一使用条件表达式。&lt;/p&gt;
&lt;p&gt;条件表达式的基本用法非常简单，它由三个操作数的运算符构成，形式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;表达式 1&amp;gt;？&amp;lt;表达式 2&amp;gt;:&amp;lt;表达式 3&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;条件表达式的计算从左往右计算，首先需要计算计算表达式 1 ，其结果类型必须为 &lt;code&gt;Boolean&lt;/code&gt; 或 &lt;code&gt;boolean&lt;/code&gt;，否则发生编译错误。&lt;/p&gt;
&lt;p&gt;当表达式 1 的结果为 &lt;code&gt;true&lt;/code&gt;，将会执行表达式 2，否则将会执行表达式 3。&lt;/p&gt;
&lt;p&gt;表达式 2 与表达式 3 最后的类型必须得有返回结果，即不能为是 &lt;code&gt;void&lt;/code&gt;，若为 &lt;code&gt;void&lt;/code&gt; ，编译时将会报错。&lt;/p&gt;
&lt;p&gt;最后需要注意的是，表达式 2 与表达式 3 不会被同时执行，两者只有一个会被执行。&lt;/p&gt;
&lt;h2 id=&quot;踩坑案例&quot;&gt;踩坑案例&lt;/h2&gt;
&lt;p&gt;了解完三目运算符的基本原理，我们简化一下开头例子，复现一下三目运算符使用过程的一些坑。假设我们的例子简化成如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean flag = true; //设置成true，保证表达式 2 被执行
int simpleInt = 66;
Integer nullInteger = null;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;案例-1&quot;&gt;案例 1&lt;/h3&gt;
&lt;p&gt;第一个案例我们根据如下计算 &lt;code&gt;result&lt;/code&gt; 的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int result = flag ? nullInteger : simpleInt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个案例为开头的例子的简化版本，运算上述代码，将会发生 NPE 的。&lt;/p&gt;
&lt;p&gt;为什么会发发生 NPE 呢？&lt;/p&gt;
&lt;p&gt;这里可以给大家一个小技巧，当我们从代码上没办法找到答案时，我们可以试试查看一下编译之后字节码，或许是 Java 编译之后增加某些东西，从而导致问题。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;javap -s -c class&lt;/code&gt; 查看 class 文件字节码，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200605080535531-1713275564.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到字节码中加入一个拆箱操作，而这个拆箱只有可能发生在 &lt;code&gt;nullInteger&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么为什么 Java 编译器在编译时会对表达式进行拆箱？难道所有数字类型的包装类型都会进行拆箱吗？&lt;/p&gt;
&lt;p&gt;条件表达式表达式发生自动拆箱，其实官方在 「The Java Language Specification（简称：JLS）」&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.25&quot;&gt;15.25 节&lt;/a&gt;中做出一些规定，部分内容如下：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;JDK7 规范&lt;/p&gt;
&lt;p&gt;If the second and third operands have the same type (which may be the null type), then that is the type of the conditional expression.&lt;/p&gt;
&lt;p&gt;If one of the second and third operands is of primitive type T, and the type of the other is the result of applying boxing conversion (§5.1.7) to T, then the type of the conditional expression is T.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用大白话讲，如果表达式 2 与表达式 3 类型相同，那么这个不用任何转换，条件表达式表达式结果当然与表达式 2，3 类型一致。&lt;/p&gt;
&lt;p&gt;当表达 2 或表达式 3 其中任一一个是基本数据类型，比如 &lt;code&gt;int&lt;/code&gt;，而另一个表达式类型为包装类型，比如 &lt;code&gt;Integer&lt;/code&gt;，那么条件表达式表达式结果类型将会为基本数据类型，即 &lt;code&gt;int&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ps：有没有疑问？为什么不规定最后结果类型都为包装类那？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是 Java 语言层面一种规范，但是这个规范如果强制让程序员执行，想必平常使用三目运算符将会比较麻烦。所以面对这种情况， Java 在编译器在编译过程加入自动拆箱进制。&lt;/p&gt;
&lt;p&gt;所以上述代码可以等同于下述代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int result = flag ? nullInteger.intValue() : simpleInt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们一开始的代码如上所示，那么这里错误点其实就很明显了。&lt;/p&gt;
&lt;h3 id=&quot;案例-2&quot;&gt;案例 2&lt;/h3&gt;
&lt;p&gt;接下来我们在第一个案例基础上修改一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean flag = true; //设置成true，保证表达式 2 被执行
int simpleInt = 66;
Integer nullInteger = null;
Integer objInteger = Integer.valueOf(88);

int result = flag ? nullInteger : objInteger;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上述代码，依然会发生 NPE 的问题。当然这次问题发生点与上一个案例不一样，但是错误原因却是一样，还是因为自动拆箱机制导致。&lt;/p&gt;
&lt;p&gt;这一次表达式 2 与表达式 3 都为包装类 &lt;code&gt;Integer&lt;/code&gt;，所以条件表达式的最后结果类型也会是 &lt;code&gt;Integer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是由于 &lt;code&gt;result&lt;/code&gt;是 int 基本数据类型，好家伙，数据类型不一致，编译器将会对条件表达式的结果进行自动拆箱。由于结果为 &lt;code&gt;null&lt;/code&gt;，自动拆箱将报错了。&lt;/p&gt;
&lt;p&gt;上述代码等同为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int result = (flag ? nullInteger : objInteger).intValue();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;案例-3&quot;&gt;案例 3&lt;/h3&gt;
&lt;p&gt;我们再稍微改造一下案例 1 的例子，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean flag = true; //设置成true，保证表达式 2 被执行
int simpleInt = 66;
Integer nullInteger = null;
Integer result = flag ? nullInteger : simpleInt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;案例 3 与案例 1 右边部分完全相同，只不过左边部分的类型不一样，一个为基本数据类型 &lt;code&gt;int&lt;/code&gt;，一个为 &lt;code&gt;Integer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;按照案例 1 的分析，这个也会发生 NPE 问题，原因与案例 1 一样。&lt;/p&gt;
&lt;p&gt;这个之所以拿出来，其实想说下，上述条件表达式的结果为 &lt;code&gt;int&lt;/code&gt; 类型，而左边类型为 &lt;code&gt;Integer&lt;/code&gt;，所以这里将会发生自动装箱操作，将 &lt;code&gt;int&lt;/code&gt;类型转化为 &lt;code&gt;Integer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;上述代码等同为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Integer result = Integer.valueOf(flag ? nullInteger.intValue() : simpleInt);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;案例-4&quot;&gt;案例 4&lt;/h3&gt;
&lt;p&gt;最后一个案例，与上面案例都不一样，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean flag = true; //设置成true，保证表达式 2 被执行
Integer nullInteger = null;
Long objLong = Long.valueOf(88l);

Object result = flag ? nullInteger : objLong;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上述代码，依然将会发生 NPE 的问题。&lt;/p&gt;
&lt;p&gt;这个案例表达式 2 与表达式 3 类型不一样，一个为 &lt;code&gt;Integer&lt;/code&gt;，一个为 &lt;code&gt;Long&lt;/code&gt;，但是这两个类型都是 &lt;code&gt;Number&lt;/code&gt;的子类。&lt;/p&gt;
&lt;p&gt;面对上述情况，JLS 规定：&lt;/p&gt;
&lt;blockquote readability=&quot;10.190635451505&quot;&gt;
&lt;p&gt;Otherwise, binary numeric promotion (&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.6.2&quot;&gt;§5.6.2&lt;/a&gt;) is applied to the operand types, and the type of the conditional expression is the promoted type of the second and third operands.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note that binary numeric promotion performs value set conversion (&lt;/em&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.13&quot;&gt;§5.1.13&lt;/a&gt;&lt;em&gt;) and may perform unboxing conversion (&lt;/em&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.8&quot;&gt;§5.1.8&lt;/a&gt;&lt;em&gt;).&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大白话讲，当表达式 2 与表达式 3 类型不一致，但是都为数字类型时，低范围类型将会自动转为高范围数据类型，即向上转型。这个过程将会发生自动拆箱。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Java 中向上转型并不需要添加任何转化，但是向下转换必须强制添加类型转换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述代码转化比较麻烦，我们先从字节码上来看：&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200605080535795-443197143.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一步，将 &lt;code&gt;nullInteger&lt;/code&gt;拆箱。&lt;/p&gt;
&lt;p&gt;第二步，将上一步的值转为 &lt;code&gt;long&lt;/code&gt; 类型，即 &lt;code&gt;(long)nullInteger.intValue()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第三步，由于表达式 2 变成了基本数据类型，表达式 3 为包装类型，根据案例 1 讲到的规则，包装类型需要转为基本数据类型，所以表达式 3 发生了拆箱。&lt;/p&gt;
&lt;p&gt;第四步，由于条件表达式最后的结果类型为基本数据类型：&lt;code&gt;long&lt;/code&gt;，但是左边类型为 &lt;code&gt;Object&lt;/code&gt;，这里就需要把 &lt;code&gt;long&lt;/code&gt; 类型装箱转为包装类型。&lt;/p&gt;
&lt;p&gt;所以最后代码等同于：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Object result = Long.valueOf(flag ? (long)nullInteger.intValue() : objLong.longValue());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;看完上述四个案例，想必大家应该会有种感受，没想到这么简单的条件表达式，既然暗藏这么多「杀机」。&lt;/p&gt;
&lt;p&gt;不过大家也不用过度害怕，不使用条件表达式。只要我们在开发过程重点注意包装类型的自动拆箱问题就好了，另外也要注意条件表达式的计算结果再赋值的时候自动拆箱引发的 NPE 的问题。&lt;/p&gt;
&lt;p&gt;最好大家在开发过程中，都遵守一定的规范，即保持表达式 2 与表达式 3 的类型一致，不让 Java 编译器有自动拆箱的机会。&lt;/p&gt;
&lt;p&gt;建议大家没事经常看下阿里出品的『Java 开发手册』，在最新的「泰山版」就增加条件表达式的这一节规范。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ps:公号消息回复:『开发手册』，获取最新版的 Java 开发手册。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202006/1419561-20200605080536049-13663485.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后一定要做好的单元测试，不要惯性思维，觉得这么简单的一个东西，看起来根本不可能出错的。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Java 开发手册-泰山版&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.aliyun.com/article/758784&quot;&gt;《Java 开发手册》解读：三目运算符为何会导致 NPE？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 05 Jun 2020 00:06:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>最近，小黑哥在一个业务改造中，使用三目运算符重构了业务代码，没想到测试的时候竟然发生 NPE 的问题。 重构代码非常简单，代码如下： // 方法返回参数类型为 Integer // private I</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/13047617.html</dc:identifier>
</item>
<item>
<title>使用Nginx防止IP地址被恶意解析 - noneplus</title>
<link>http://www.cnblogs.com/noneplus/p/13047609.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noneplus/p/13047609.html</guid>
<description>&lt;!--[if IE]&gt;
    &lt;div class=&quot;unsupported-browser&quot;&gt;
        &amp;#35813;&amp;#39029;&amp;#38754;&amp;#19981;&amp;#25903;&amp;#25345; Internet Explorer &amp;#27983;&amp;#35272;&amp;#22120;&amp;#65292;&amp;#24314;&amp;#35758;&amp;#20351;&amp;#29992;
        &lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/&quot;&gt;Google Chrome&lt;/a&gt;,
        &lt;a href=&quot;https://www.mozilla.org/zh-CN/firefox/&quot;&gt;Firefox&lt;/a&gt; &amp;#25110;
        &lt;a href=&quot;https://www.microsoftedgeinsider.com/zh-CN/&quot;&gt;Microsoft Edge&lt;/a&gt;
    &lt;/div&gt;
&lt;![endif]--&gt;
    &lt;div class=&quot;center-container &quot;&gt;
        &lt;div class=&quot;center-body card  h-sm-100&quot;&gt;
            &lt;div class=&quot;card-body&quot;&gt;
                


&lt;div class=&quot;login-top text-center&quot;&gt;
    &lt;span class=&quot;login-title&quot;&gt;博客园用户登录&lt;/span&gt;
    &lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;
        &lt;svg class=&quot;login-sign&quot;&gt;&lt;use xlink:href=&quot;#icon-login-sign&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;
    &lt;p&gt;代码改变世界&lt;/p&gt;
&lt;/div&gt;
&lt;form id=&quot;loginForm&quot; method=&quot;post&quot; onsubmit=&quot;return false&quot;&gt;
    
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;1&quot; class=&quot;form-control&quot; placeholder=&quot;登录用户名 / 邮箱&quot; autofocus=&quot;&quot; type=&quot;text&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入登录用户名&quot; id=&quot;LoginName&quot; name=&quot;LoginName&quot; value=&quot;&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;LoginName&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/forgotloginname&quot;&gt;忘记登录用户名&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;2&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入密码&quot; id=&quot;Password&quot; name=&quot;Password&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;Password&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/resetpassword&quot;&gt;忘记密码&lt;/a&gt;
        &lt;/div&gt;
        &lt;p&gt;
            &lt;input tabindex=&quot;3&quot; type=&quot;checkbox&quot; id=&quot;IsRemember&quot; name=&quot;IsRemember&quot; value=&quot;true&quot; class=&quot;custom-control-input&quot;/&gt;&lt;label class=&quot;custom-control-label&quot; for=&quot;IsRemember&quot;&gt;记住我&lt;/label&gt;
        &lt;/p&gt;

        &lt;button tabindex=&quot;4&quot; id=&quot;submitBtn&quot; type=&quot;submit&quot; class=&quot;btn-login btn btn-primary btn-sm ladda-button px-4&quot; data-style=&quot;slide-down&quot;&gt;
            &lt;span class=&quot;ladda-label&quot;&gt;登录&lt;/span&gt;
        &lt;/button&gt;
        &lt;div class=&quot;login-footer&quot;&gt;
            &lt;div class=&quot;ajax-error-box&quot;&gt;
                
            &lt;/div&gt;
            &lt;span&gt;没有账户，&lt;a href=&quot;https://account.cnblogs.com/signup&quot;&gt;立即注册&lt;/a&gt;&lt;/span&gt;
        &lt;/div&gt;
    
&lt;input name=&quot;__RequestVerificationToken&quot; type=&quot;hidden&quot; value=&quot;CfDJ8B9DwO68dQFBg9xIizKsC6QqQ0I7-Xxs9NafBhzNDjCdi0d7EbQTRUUOau8Uz28N1hlhJyIwDCUqqGya2MSfE2V9ES8CyjbP7aSDSZ3l-6Oy4hD2c_MkLXB1NX640uQ4UPNNm7IlxnoKzmSFPGsx17U&quot;/&gt;&lt;/form&gt;

&lt;input type=&quot;hidden&quot; id=&quot;PublicKey&quot; name=&quot;PublicKey&quot; value=&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCp0wHYbg/NOPO3nzMD3dndwS0MccuMeXCHgVlGOoYyFwLdS24Im2e7YyhB0wrUsyYf0/nhzCzBK8ZC9eCWqd0aHbdgOQT6CuFQBMjbyGYvlVYU2ZP7kG9Ft6YV6oc9ambuO7nPZh+bvXH0zDKfi02prknrScAKC0XhadTHT3Al0QIDAQAB&quot;/&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    </description>
<pubDate>Thu, 04 Jun 2020 23:57:00 +0000</pubDate>
<dc:creator>noneplus</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fnoneplus%2Fp%2F13047609.html</dc:identifier>
</item>
<item>
<title>世界上最著名的操作系统是用什么语言编写的？ - Coding十日谈</title>
<link>http://www.cnblogs.com/jfzhu/p/13047607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jfzhu/p/13047607.html</guid>
<description>&lt;!--[if IE]&gt;
    &lt;div class=&quot;unsupported-browser&quot;&gt;
        &amp;#35813;&amp;#39029;&amp;#38754;&amp;#19981;&amp;#25903;&amp;#25345; Internet Explorer &amp;#27983;&amp;#35272;&amp;#22120;&amp;#65292;&amp;#24314;&amp;#35758;&amp;#20351;&amp;#29992;
        &lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/&quot;&gt;Google Chrome&lt;/a&gt;,
        &lt;a href=&quot;https://www.mozilla.org/zh-CN/firefox/&quot;&gt;Firefox&lt;/a&gt; &amp;#25110;
        &lt;a href=&quot;https://www.microsoftedgeinsider.com/zh-CN/&quot;&gt;Microsoft Edge&lt;/a&gt;
    &lt;/div&gt;
&lt;![endif]--&gt;
    &lt;div class=&quot;center-container &quot;&gt;
        &lt;div class=&quot;center-body card  h-sm-100&quot;&gt;
            &lt;div class=&quot;card-body&quot;&gt;
                


&lt;div class=&quot;login-top text-center&quot;&gt;
    &lt;span class=&quot;login-title&quot;&gt;博客园用户登录&lt;/span&gt;
    &lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;
        &lt;svg class=&quot;login-sign&quot;&gt;&lt;use xlink:href=&quot;#icon-login-sign&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;
    &lt;p&gt;代码改变世界&lt;/p&gt;
&lt;/div&gt;
&lt;form id=&quot;loginForm&quot; method=&quot;post&quot; onsubmit=&quot;return false&quot;&gt;
    
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;1&quot; class=&quot;form-control&quot; placeholder=&quot;登录用户名 / 邮箱&quot; autofocus=&quot;&quot; type=&quot;text&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入登录用户名&quot; id=&quot;LoginName&quot; name=&quot;LoginName&quot; value=&quot;&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;LoginName&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/forgotloginname&quot;&gt;忘记登录用户名&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;2&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入密码&quot; id=&quot;Password&quot; name=&quot;Password&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;Password&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/resetpassword&quot;&gt;忘记密码&lt;/a&gt;
        &lt;/div&gt;
        &lt;p&gt;
            &lt;input tabindex=&quot;3&quot; type=&quot;checkbox&quot; id=&quot;IsRemember&quot; name=&quot;IsRemember&quot; value=&quot;true&quot; class=&quot;custom-control-input&quot;/&gt;&lt;label class=&quot;custom-control-label&quot; for=&quot;IsRemember&quot;&gt;记住我&lt;/label&gt;
        &lt;/p&gt;

        &lt;button tabindex=&quot;4&quot; id=&quot;submitBtn&quot; type=&quot;submit&quot; class=&quot;btn-login btn btn-primary btn-sm ladda-button px-4&quot; data-style=&quot;slide-down&quot;&gt;
            &lt;span class=&quot;ladda-label&quot;&gt;登录&lt;/span&gt;
        &lt;/button&gt;
        &lt;div class=&quot;login-footer&quot;&gt;
            &lt;div class=&quot;ajax-error-box&quot;&gt;
                
            &lt;/div&gt;
            &lt;span&gt;没有账户，&lt;a href=&quot;https://account.cnblogs.com/signup&quot;&gt;立即注册&lt;/a&gt;&lt;/span&gt;
        &lt;/div&gt;
    
&lt;input name=&quot;__RequestVerificationToken&quot; type=&quot;hidden&quot; value=&quot;CfDJ8B9DwO68dQFBg9xIizKsC6SOeS53hbC-AMOzjYrzRj-lojFNNbGguh5h72-4b-F0HbXR7kPOesbvRoLgqbWLXeb4INFHTcM9HzH37WePtjKiPZ2252bksTW4QVRDrhxndjqdIDxQPttBb4q4l9FfjRA&quot;/&gt;&lt;/form&gt;

&lt;input type=&quot;hidden&quot; id=&quot;PublicKey&quot; name=&quot;PublicKey&quot; value=&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCp0wHYbg/NOPO3nzMD3dndwS0MccuMeXCHgVlGOoYyFwLdS24Im2e7YyhB0wrUsyYf0/nhzCzBK8ZC9eCWqd0aHbdgOQT6CuFQBMjbyGYvlVYU2ZP7kG9Ft6YV6oc9ambuO7nPZh+bvXH0zDKfi02prknrScAKC0XhadTHT3Al0QIDAQAB&quot;/&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    </description>
<pubDate>Thu, 04 Jun 2020 23:56:00 +0000</pubDate>
<dc:creator>Coding十日谈</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fjfzhu%2Fp%2F13047607.html</dc:identifier>
</item>
<item>
<title>Elasticsearch系列---生产集群部署(下) - 清茶豆奶</title>
<link>http://www.cnblogs.com/huangying2124/p/13047567.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangying2124/p/13047567.html</guid>
<description>&lt;h3 id=&quot;概要&quot;&gt;概要&lt;/h3&gt;
&lt;p&gt;本篇继续讲解Elasticsearch集群部署的细节问题&lt;/p&gt;
&lt;h3 id=&quot;集群重启问题&quot;&gt;集群重启问题&lt;/h3&gt;
&lt;p&gt;如果我们的Elasticsearch集群做了一些离线的维护操作时，如扩容磁盘，升级版本等，需要对集群进行启动，节点数较多时，从第一个节点开始启动，到最后一个节点启动完成，耗时可能较长，有时候还可能出现某几个节点因故障无法启动，排查问题、修复故障后才能加入到集群中，此时集群会干什么呢？&lt;/p&gt;
&lt;p&gt;假设10个节点的集群，每个节点有1个shard，升级后重启节点，结果有3台节点因故障未能启动，需要耗费时间排查故障，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/db1333d5-6722-4730-b3f1-e6da4cd9118e.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个过程步骤如下：&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;集群已完成master选举(node6)，master发现未加入集群的node1、node2、node3包含的shard丢失，便立即发出shard恢复的指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在线的7台node，将其中一个replica shard升级为primary shard，并且进行为这些primary shard复制足够的replica shard。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行shard rebalance操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;故障的3台节点已排除，启动成功后加入集群。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这3台节点发现自己的shard已经在集群中的其他节点上了，便删除本地的shard数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;master发现新的3台node没有shard数据，重新执行一次shard rebalance操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个过程可以发现，多做了四次IO操作，shard复制，shard首次移动，shard本地删除，shard再次移动，这样凭空造成大量的IO压力，如果数据量是TB级别的，那费时费力不讨好。&lt;/p&gt;
&lt;p&gt;出现此类问题的原因是节点启动的间隔时间不能确定，并且节点越多，这个问题越容易出现，如果可以设置集群等待多少个节点启动后，再决定是否对shard进行移动，这样IO压力就能小很多。&lt;/p&gt;
&lt;p&gt;针对这个问题，我们有下面几个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;gateway.recover_after_nodes：集群必须要有多少个节点时，才开始做shard恢复操作。&lt;/li&gt;
&lt;li&gt;gateway.expected_nodes: 集群应该有多少个节点&lt;/li&gt;
&lt;li&gt;gateway.recover_after_time: 集群启动后等待的shard恢复时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如上面的案例，我们可以这样设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;gateway.recover_after_nodes: 8
gateway.expected_nodes: 10
gateway.recover_after_time: 5m
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这三个参数的含义：集群总共有10个节点，必须要有8个节点加入集群时，才允许执行shard恢复操作，如果10个节点未全部启动成功，最长的等待时间为5分钟。&lt;/p&gt;
&lt;p&gt;这几个参数的值可以根据实际的集群规模来设置，并且只能在&lt;code&gt;elasticsearch.yml&lt;/code&gt;文件里设置，没有动态修改的入口。&lt;/p&gt;
&lt;p&gt;上面的参数设置合理的情况，集群启动是没有shard移动的现象，这样集群启动的时候就可以由之前的几小时，变成几秒钟。&lt;/p&gt;
&lt;h3 id=&quot;jvm和thread-pool设置&quot;&gt;JVM和Thread Pool设置&lt;/h3&gt;
&lt;p&gt;一提到JVM的调优，大家都有手痒的感觉，好几百个JVM参数，说不定开启了正确的按钮，从此ES踏上高性能、高吞吐量的道路。现实情况可能是我们想多了，ES的大部分参数是经过反复论证的，基本上不用咱们太操心。&lt;/p&gt;
&lt;h4 id=&quot;jvm-gc&quot;&gt;JVM GC&lt;/h4&gt;
&lt;p&gt;Elasticsearch默认使用的垃圾回收器是CMS。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;## GC configuration
-XX:+UseConcMarkSweepGC
-XX:CMSInitiatingOccupancyFraction=75
-XX:+UseCMSInitiatingOccupancyOnly
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CMS回收器是并发式的回收器，能够跟应用程序工作线程并发工作，最大程度减少垃圾回收时的服务停顿时间。&lt;/p&gt;
&lt;p&gt;CMS还是会有两个停顿阶段，同时在回收特别大的heap时也会有一些问题。尽管有一些缺点，但是CMS对于要求低延时请求响应的软件来说，还是最佳的垃圾回收器，因此官方的推荐就是使用CMS垃圾回收器。&lt;/p&gt;
&lt;p&gt;有一种最新的垃圾回收器叫做G1。G1回收器可以比CMS提供更少的回收停顿时间，而且能够这对大heap有更好的回收表现。它会将heap划分为多个region，然后自动预测哪个region会有最多可以回收的空间。通过回收那些region，就可以最小化停顿时长，而且可以针对大heap进行回收。&lt;/p&gt;
&lt;p&gt;听起来还挺好的，只是G1还是比较年轻的一种垃圾回收器，而且经常会发现一些新的bug，这些bug可能会导致jvm挂掉。稳定起见，暂时不用G1，等G1成熟后ES官方推荐后再用不迟。&lt;/p&gt;
&lt;h4 id=&quot;线程池&quot;&gt;线程池&lt;/h4&gt;
&lt;p&gt;我们开发Java应用系统时，对系统调优的一个常见手段就是调整线程池，但在ES中,默认的threadpool设置是非常合理的，对于所有的threadpool来说，除了搜索的线程池，都是线程数量设置的跟cpu core一样多的。如果我们有8个cpu core，那么就可以并行运行8个线程。那么对于大部分的线程池来说，分配8个线程就是最合理的数量。&lt;/p&gt;
&lt;p&gt;搜索会有一个更加大的threadpool，线程数量一般被配置为：cpu core * 3 / 2 + 1。&lt;/p&gt;
&lt;p&gt;Elasticsearch的线程池分成两种：接受请求的线程和处理磁盘IO操作的线程，前面那种由ES管理，后一种由Lucene管理，它们之间会进行协作，ES的线程不会因为IO操作而block住，所以ES的线程设置跟CPU核数一样或略大于CPU核数即可。&lt;/p&gt;
&lt;p&gt;服务器的计算能力是非常有限的，线程池的数量过大会导致上下文频繁切换，更费资源，如果threadpool大小设置为50，100，甚至500，会导致CPU资源利用率很低，性能反而下降。&lt;/p&gt;
&lt;p&gt;只需要记住：用默认的线程池，如果真要修改，以CPU核数为准。&lt;/p&gt;
&lt;h3 id=&quot;heap内存设置最佳实践&quot;&gt;heap内存设置最佳实践&lt;/h3&gt;
&lt;p&gt;Elasticsearch默认的jvm heap内存大小是2G，如果是研发环境，我会改成512MB，但在生产环境2GB有点少。&lt;/p&gt;
&lt;p&gt;在config/jvm.options文件下，可以看到heap的设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;# Xms represents the initial size of total heap space
# Xmx represents the maximum size of total heap space

-Xms2g
-Xmx2g
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;分配规则&quot;&gt;分配规则&lt;/h4&gt;
&lt;p&gt;Elasticsearch使用内存主要有两个大户：jvm heap和lucene，前者ES用来存放很多数据结构来提供更快的操作性能，后者使用os cache缓存索引文件，包括倒排索引、正排索引，os cache内存是否充足，直接影响查询检索的性能。&lt;/p&gt;
&lt;p&gt;一般的分配规则是：jvm heap占用小于一半的内存，剩下的全归lucene使用。&lt;/p&gt;
&lt;p&gt;如果单台机器总内存64GB，那么heap顶格内存分配为32GB，因为32GB内存以下，jvm会使用compressed oops来解决object pointer耗费过大空间的问题，超过32GB后，jvm的compressed oops功能关闭，这样就只能使用64位的object pointer，会耗费更多的空间，过大的object pointer还会在cpu，main memory和LLC、L1等多级缓存间移动数据的时候，吃掉更多的带宽。最终的结果可能是50GB内存的效果和32GB一样，白白浪费了十几GB内存。&lt;/p&gt;
&lt;p&gt;这里涉及到jvm的object pointer指针压缩技术，有兴趣可以单独了解一下。&lt;/p&gt;
&lt;p&gt;如果单台机器总内存小于64GB，一般heap分配为总内存的一半即可，具体要看预估的数据量是多少。&lt;/p&gt;
&lt;p&gt;如果使用超级机器，1TB内存的那种，官网不建议上那么牛逼的机器，建议分配4-32GB内存给heap，其他的全部用来做os cache，这样数据量全部缓存在内存中，不落盘查询，性能杠杠滴。&lt;/p&gt;
&lt;h4 id=&quot;最佳实践建议&quot;&gt;最佳实践建议&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;将heap的最小值和最大值设置为一样大。&lt;/li&gt;
&lt;li&gt;elasticsearch jvm heap设置得越大，就有越多的内存用来进行缓存，但是过大的jvm heap可能会导致长时间的gc停顿。&lt;/li&gt;
&lt;li&gt;jvm heap size的最大值不要超过物理内存的50%，才能给lucene的file system cache留下足够的内存。&lt;/li&gt;
&lt;li&gt;jvm heap size设置不要超过32GB，否则jvm无法启用compressed oops，将对象指针进行压缩，确认日志里有&lt;code&gt;[node-1] heap size [1007.3mb], compressed ordinary object pointers [true]&lt;/code&gt; 字样出现。&lt;/li&gt;
&lt;li&gt;最佳实践数据：heap size设置的小于zero-based compressed ooops，也就是26GB，但是有时也可以是30GB。通过-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompressedOopsMode开启对应，确认有&lt;code&gt;heap address: 0x00000000e0000000, size: 27648 MB, Compressed Oops mode: 32-bit&lt;/code&gt;字样，而不是&lt;code&gt;heap address: 0x00000000f4000000, size: 28672 MB, Compressed Oops with base: 0x00000000f3ff0000&lt;/code&gt;字样。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;swapping问题&quot;&gt;swapping问题&lt;/h4&gt;
&lt;p&gt;部署Elasticsearch的服务尽可能关闭到swap，如果内存缓存到磁盘上，那查询效率会由微秒级降到毫秒级，会造成性能急剧下降的隐患。&lt;/p&gt;
&lt;p&gt;关闭办法:&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Linux系统执行 &lt;code&gt;swapoff -a&lt;/code&gt; 关闭swap，或在/etc/fstab文件中配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;elasticsearch.yml中可以设置：&lt;code&gt;bootstrap.mlockall: true&lt;/code&gt; 锁住自己的内存不被swap到磁盘上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用命令 &lt;code&gt;GET _nodes?filter_path=**.mlockall&lt;/code&gt; 可以查看是否开启mlockall&lt;br/&gt;响应信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;nodes&quot;: {
    &quot;A1s1uus7TpuDSiT4xFLOoQ&quot;: {
      &quot;process&quot;: {
        &quot;mlockall&quot;: true
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;elasticsearch启动的几个问题&quot;&gt;Elasticsearch启动的几个问题&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;root用户启动实例的问题&lt;br/&gt;如果你用root用户启动Elasticsearch的实例，将得到如下的错误提示：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root
        at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:140) ~[elasticsearch-6.3.1.jar:6.3.1]
        at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:127) ~[elasticsearch-6.3.1.jar:6.3.1]
        at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) ~[elasticsearch-6.3.1.jar:6.3.1]
        at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:124) ~[elasticsearch-cli-6.3.1.jar:6.3.1]
        at org.elasticsearch.cli.Command.main(Command.java:90) ~[elasticsearch-cli-6.3.1.jar:6.3.1]
        at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:93) ~[elasticsearch-6.3.1.jar:6.3.1]
        at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:86) ~[elasticsearch-6.3.1.jar:6.3.1]
Caused by: java.lang.RuntimeException: can not run elasticsearch as root
        at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:104) ~[elasticsearch-6.3.1.jar:6.3.1]
        at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:171) ~[elasticsearch-6.3.1.jar:6.3.1]
        at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:326) ~[elasticsearch-6.3.1.jar:6.3.1]
        at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:136) ~[elasticsearch-6.3.1.jar:6.3.1]
        ... 6 more
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无它，建立一个用户，专门用来启动Elasticsearch的，如esuser，相应的系统目录和数据存储目录都赋予esuser账户为归属者。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;启动时提示elasticsearch process is too low，并且无法启动成功&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;完整的提示信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]
memory locking requested for elasticsearch process but memory is not locked
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决办法：设置系统参数，命令行中的esuser为建立的Linux用户。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[root@elasticsearch01 bin]# vi /etc/security/limits.conf

# 在文件最后添加
esuser hard nofile 65536
esuser soft nofile 65536
esuser soft memlock unlimited
esuser hard memlock unlimited
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置完成后，可以通过命令查看结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;# 请求命令
GET _nodes/stats/process?filter_path=**.max_file_descriptors

# 响应结果
{
  &quot;nodes&quot;: {
    &quot;A1s1uus7TpuDSiT4xFLOoQ&quot;: {
      &quot;process&quot;: {
        &quot;max_file_descriptors&quot;: 65536
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;提示vm.max_map_count [65530] is too low错误，无法启动实例&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;完整的提示信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决办法：添加&lt;code&gt;vm.max_map_count&lt;/code&gt;配置项&lt;/p&gt;
&lt;p&gt;临时设置：&lt;code&gt;sysctl -w vm.max_map_count=262144&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;永久修改：修改&lt;code&gt;vim /etc/sysctl.conf&lt;/code&gt;文件，添加&lt;code&gt;vm.max_map_count&lt;/code&gt;设置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[root@elasticsearch01 bin]# vim /etc/sysctl.conf

# 在文件最后添加
vm.max_map_count=262144

# 执行命令
[root@elasticsearch01 bin]# sysctl -p
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;elasticsearch实例启停&quot;&gt;Elasticsearch实例启停&lt;/h3&gt;
&lt;p&gt;实例一般使用后台启动的方式，在ES的bin目录下执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[esuser@elasticsearch01 bin]$ nohup ./elasticsearch &amp;amp;
[1] 15544
[esuser@elasticsearch01 bin]$ nohup: 忽略输入并把输出追加到&quot;nohup.out&quot;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个elasticsearch没有stop参数，停止时使用&lt;code&gt;kill pid&lt;/code&gt;命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[esuser@elasticsearch01 bin]$ jps | grep Elasticsearch
15544 Elasticsearch
[esuser@elasticsearch01 bin]$ kill -SIGTERM 15544
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发送一个SIGTERM信号给elasticsearch进程，可以优雅的关闭实例。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本篇接着上篇的内容，讲解了集群重启时要注意的问题，JVM Heap设置的最佳实践，以及Elasticsearch实例启动时常见的问题解决办法，最后是Elasticsearch优雅关闭的命令。&lt;/p&gt;
&lt;p&gt;专注Java高并发、分布式架构，更多技术干货分享与心得，请关注公众号：Java架构社区&lt;br/&gt;可以扫左边二维码添加好友，邀请你加入Java架构社区微信群共同探讨技术&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1834889/202003/1834889-20200303074927076-1724862603.jpg&quot; alt=&quot;Java架构社区&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Jun 2020 23:05:00 +0000</pubDate>
<dc:creator>清茶豆奶</dc:creator>
<og:description>概要 本篇继续讲解Elasticsearch集群部署的细节问题 集群重启问题 如果我们的Elasticsearch集群做了一些离线的维护操作时，如扩容磁盘，升级版本等，需要对集群进行启动，节点数较多时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangying2124/p/13047567.html</dc:identifier>
</item>
<item>
<title>哦，Vendor - 赐我白日梦</title>
<link>http://www.cnblogs.com/ZhuChangwu/p/13047550.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhuChangwu/p/13047550.html</guid>
<description>&lt;p&gt;vendor踩坑笔记：&lt;/p&gt;
&lt;p&gt;接过公司里面X平台golang部分的后端后，需要新添加一个业务功能，美滋滋~ 拿过项目一顿写之后后遇到事了。&lt;/p&gt;
&lt;p&gt;报错的描述如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496926/202006/1496926-20200605054911652-1901496128.png&quot; alt=&quot;image-20200604202529966&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报错的大意说：方法的入参类型不匹配，我们不能把 &lt;code&gt;Assignment2/vendor/github.com/...&lt;/code&gt; 当作&lt;code&gt;github.com/...&lt;/code&gt; 类型来使用。&lt;/p&gt;
&lt;p&gt;出现的这个错误的原因就项目中使用的 beego的Controller使用了vendor进行管理，于是在这个包前多了个前缀 &lt;code&gt;项目名/vendor/xxx&lt;/code&gt;。但是呢，这个函数需要的是纯粹的beego的controller，加上这个前缀之后反到是不认识了。于是就出现了上面的错误。&lt;/p&gt;
&lt;p&gt;查阅资料后了解：vendor是在GOPATH的管理之下的，大白话说：如果我们的项目在GOPATH目录下，那么项目中需要的依赖信息优先从vendor中获取。你看，我上面的报错就属于这个情况，我以为我在使用 github/astaxie/beego/controller ， 而实际优先导入了 项目名/vendor/github/astaxie/beego/controller&lt;/p&gt;
&lt;p&gt;当时我是如何解决的呢？&lt;/p&gt;
&lt;p&gt;不是说优先导入vendor中的代码吗？好，我把你删除，你不就使用我本地的依赖了？（纯洁的微笑～）&lt;/p&gt;
&lt;p&gt;事实证明，确实如此，删除vendor中的依赖后，一切归于平静，继续开发～&lt;/p&gt;
&lt;p&gt;但是我提交代码让组里的大佬CR时，大佬发现vendor被我改了～～～，这才知道，项目之所以使用vendor管理项目就是为了让项目中的依赖可以跟着项目迁移，这样部署项目时不再去很多不同的地方拉取依赖，因为依赖都在项目里面。&lt;/p&gt;
&lt;p&gt;所以删除vendor中的依赖并不是万全之策，可以删掉现在的vendor，重新用vendor初始化一下，让项目中的依赖重新让vendor管理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt; # 下载govendor
 go get -u -v github.com/kardianos/govendor
 
 # 在当前目录中执行如下命令进行初始化，将依赖加入vendor统一管理
 govendor init
 govendor add +e
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 04 Jun 2020 21:49:00 +0000</pubDate>
<dc:creator>赐我白日梦</dc:creator>
<og:description>vendor踩坑笔记： 接过公司里面X平台golang部分的后端后，需要新添加一个业务功能，美滋滋~ 拿过项目一顿写之后后遇到事了。 报错的描述如下： 报错的大意说：方法的入参类型不匹配，我们不能把</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhuChangwu/p/13047550.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core Blazor Webassembly 之 路由 - Agile.Zhou</title>
<link>http://www.cnblogs.com/kklldog/p/blazor-wasm-router.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kklldog/p/blazor-wasm-router.html</guid>
<description>&lt;p&gt;web最精妙的设计就是通过url把多个页面串联起来，并且可以互相跳转。我们开发系统的时候总是需要使用路由来实现页面间的跳转。传统的web开发主要是使用a标签或者是服务端redirect来跳转。那今天来看看Blazor是如何进行路由的。&lt;/p&gt;
&lt;h2 id=&quot;使用page指定组件的路由path&quot;&gt;使用@page指定组件的路由path&lt;/h2&gt;
&lt;p&gt;我们可以在Blazor里给每个组件指定一个path，当路由匹配的时候会显示这个组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/page/a&quot;

 &amp;lt;h2&amp;gt;
     PAGE A
 &amp;lt;/h2&amp;gt;

@code {
 
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问/page/a 看到Page A页面被渲染出来了。&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/06/04/t00kCt.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：如果是在浏览器里敲入url按回车切换页面，会发生一次http请求，然后重新渲染blazor应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用a标签进行页面跳转&quot;&gt;使用a标签进行页面跳转&lt;/h2&gt;
&lt;p&gt;a标签作为超链接是我们web开发最常用的跳转方式，blazor同样支持。&lt;br/&gt;新建Page B&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/page/b&quot;

 &amp;lt;h2&amp;gt;
     PAGE B
 &amp;lt;/h2&amp;gt;

@code {
 
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Page A页面添加一个a标签进行跳转：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/page/a&quot;

 &amp;lt;h2&amp;gt;
     PAGE A
 &amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;
    &amp;lt;a href=&quot;/page/b&quot;&amp;gt;Page B&amp;lt;/a&amp;gt;
&amp;lt;/p&amp;gt;

@code {
 
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下试试：&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/06/04/t0DOCn.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：使用a连接在页面间进行跳转不会发生http请求到后台，页面是直接在前端渲染出来的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;通过路由传参&quot;&gt;通过路由传参&lt;/h2&gt;
&lt;p&gt;通过http的url进行页面间传参是我们web开发的常规操作。下面我们演示下如何从Page A传递一个参数到Page B。我们预设Page A里面有个UserName需要传递到Page B，并且显示出来。&lt;/p&gt;
&lt;h3 id=&quot;通过path传参&quot;&gt;通过path传参&lt;/h3&gt;
&lt;p&gt;通过url传参一般有两种方式，一种是直接把参数组合在path里，比如“/page/b/小明”这样。&lt;/p&gt;
&lt;p&gt;修改Page A：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/page/a&quot;

 &amp;lt;h2&amp;gt;
     PAGE A
 &amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;
    &amp;lt;a href=&quot;/page/b/@userName&quot;&amp;gt;Page B&amp;lt;/a&amp;gt;
&amp;lt;/p&amp;gt;

@code {
    private string userName = &quot;小明&quot;;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过把userName组合到path上传递给Page B。&lt;/p&gt;
&lt;p&gt;修改Page B：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/page/b/{userName}&quot;

 &amp;lt;h2&amp;gt;
     PAGE B
 &amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;
    userName: @userName
&amp;lt;/p&amp;gt;

@code {
    [Parameter]
    public string userName { get; set; }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Page B 使用一个“/page/b/{userName}” pattern来匹配userName,并且userName需要标记[Parameter]并且设置为public。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/06/04/t0cPL6.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;通过querystring传参&quot;&gt;通过QueryString传参&lt;/h3&gt;
&lt;p&gt;除了把参数直接拼接在path里，我们还习惯通过QueryString方式传递，比如“/page/b?username=小明”。&lt;/p&gt;
&lt;p&gt;修改Page A：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/page/a&quot;

&amp;lt;h2&amp;gt;
    PAGE A
&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;
    &amp;lt;a href=&quot;/page/b?username=@userName&quot;&amp;gt;Page B&amp;lt;/a&amp;gt;
&amp;lt;/p&amp;gt;

@code {
    private string userName = &quot;小明&quot;;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先安装一个工具库：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package Microsoft.AspNetCore.WebUtilities -Version 2.2.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改Page B：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/page/b&quot;

&amp;lt;h2&amp;gt;
    PAGE B
&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;
    userName: @UserName
&amp;lt;/p&amp;gt;

@using Microsoft.AspNetCore.WebUtilities;

@inject NavigationManager NavigationManager;

@code {
    [Parameter]
    public string UserName { get; set; }


    protected override void OnInitialized()
    {
        var uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        QueryHelpers.ParseQuery(uri.Query).TryGetValue(&quot;username&quot;, out Microsoft.Extensions.Primitives.StringValues userName);
        Console.WriteLine(NavigationManager.Uri);
        UserName = userName.ToString();
        Console.WriteLine(UserName);

        base.OnInitialized();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;页面获取QueryString的传参比较麻烦，Blazor并没有进行封装。所以我们需要通过QueryHelpers.ParseQuery方法手工把QueryString格式化成字典形式，然后获取对应的参数。QueryHelpers类存在Microsoft.AspNetCore.WebUtilities这个库里，需要通过nuget安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/06/05/tDEWZQ.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;navlink&quot;&gt;NavLink&lt;/h2&gt;
&lt;p&gt;NavLink是个导航组件，它其实就是封装了a标签。当选中的时候，也就是当前的url跟它的href一致的时候，会自动在class上加上active类，所以可以用来控制选中的样式。默认的3个导航菜单就是用的NavLink。&lt;/p&gt;
&lt;p&gt;比如导航到counter的NavLink：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   &amp;lt;NavLink class=&quot;nav-link&quot; href=&quot;counter&quot;&amp;gt;
                &amp;lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; Counter
    &amp;lt;/NavLink&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后翻译成html：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;a href=&quot;counter&quot; class=&quot;nav-link active&quot;&amp;gt;
                &amp;lt;span class=&quot;oi oi-plus&quot; aria-hidden=&quot;true&quot;&amp;gt;&amp;lt;/span&amp;gt; Counter
&amp;lt;/a&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;navigationmanager&quot;&gt;NavigationManager&lt;/h2&gt;
&lt;p&gt;有的时候我们可能需要在代码里进行导航，如果是JavaScript我们会用window.location来切换页面，Blazor为我们提供了相应的封装：NavigationManager。使用NavigationManager可以通过代码直接进行页面间的跳转。我们在Page A页面放个按钮然后通过按钮的点击事件进行跳转：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/page/a&quot;

&amp;lt;h2&amp;gt;
    PAGE A
&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;
   &amp;lt;button @onclick=&quot;GoToB&quot;&amp;gt;
       go to B
   &amp;lt;/button&amp;gt;
&amp;lt;/p&amp;gt;

@inject NavigationManager NavigationManager
@code {

    private void GoToB()
    {
        NavigationManager.NavigateTo(&quot;/page/b?username=小猫&quot;);
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改Page A的代码，注入NavigationManager对象，通过NavigationManager.NavigateTo方法进行跳转。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/06/05/tDZAXT.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;扩张back方法&quot;&gt;扩张Back方法&lt;/h3&gt;
&lt;p&gt;Blazor封装的NavigationManager咋一看以为跟WPF的NavigationService一样，我想当然的觉得里面肯定有个Back方法可以进行后退。但是查了一番发现还真的没有，这就比较尴尬了，没办法只能使用JavaScript来实现了。&lt;/p&gt;
&lt;p&gt;为了方便我们给NavigationManager直接写个扩展方法吧。&lt;br/&gt;首先修改Program把IServiceCollection暴露出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class Program
    {
        public static IServiceCollection Services;

        public static async Task Main(string[] args)
        {
            var builder = WebAssemblyHostBuilder.CreateDefault(args);
            builder.RootComponents.Add&amp;lt;App&amp;gt;(&quot;app&quot;);

            builder.Services.AddTransient(sp =&amp;gt; new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) });
            Services = builder.Services;

            await builder.Build().RunAsync();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扩展类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public static class Ext
    {
        public static void Back(this NavigationManager navigation)
        {
            var jsruntime = Program.Services.BuildServiceProvider().GetService&amp;lt;IJSRuntime&amp;gt;();
            jsruntime.InvokeVoidAsync(&quot;history.back&quot;);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个扩展方法很简单，从DI容器里获取IJSRuntime的实例对象，通过它去调用JavaScript的history.back方法。&lt;/p&gt;
&lt;p&gt;修改Page B：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/page/b&quot;

&amp;lt;h2&amp;gt;
    PAGE B
&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;
    userName: @UserName
&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;
    &amp;lt;button @onclick=&quot;GoBack&quot;&amp;gt;
        Go back
    &amp;lt;/button&amp;gt;
&amp;lt;/p&amp;gt;

@using Microsoft.AspNetCore.WebUtilities;

@inject NavigationManager NavigationManager;

@code {
    [Parameter]
    public string UserName { get; set; }


    protected override void OnInitialized()
    {
        var uri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        QueryHelpers.ParseQuery(uri.Query).TryGetValue(&quot;username&quot;, out Microsoft.Extensions.Primitives.StringValues userName);
        Console.WriteLine(NavigationManager.Uri);
        UserName = userName.ToString();
        Console.WriteLine(UserName);

        base.OnInitialized();
    }

    private void GoBack()
    {
        NavigationManager.Back();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Page B页面上添加一个按钮，点击调用NavigationManager.Back方法就能回到上一页。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/06/05/tDefde.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;到此Blazor路由的内容学习的差不多了，整体上没有什么特别的，就是NavigationManager只有前进方法没有后退是比较让我震惊的。&lt;/p&gt;
&lt;p&gt;相关内容：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kklldog/p/blazor-wasm-databind.html&quot;&gt;ASP.NET Core Blazor Webassembly 之 数据绑定&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/kklldog/p/blazor-webassembly-component.html&quot;&gt;ASP.NET Core Blazor Webassembly 之 组件&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/kklldog/p/try-blazorwebassembly.html&quot;&gt;ASP.NET Core Blazor 初探之 Blazor WebAssembly&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/kklldog/p/blazor-server.html&quot;&gt;ASP.NET Core Blazor 初探之 Blazor Server&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Jun 2020 17:04:00 +0000</pubDate>
<dc:creator>Agile.Zhou</dc:creator>
<og:description>web最精妙的设计就是通过url把多个页面串联起来，并且可以互相跳转。我们开发系统的时候总是需要使用路由来实现页面间的跳转。传统的web开发主要是使用a标签或者是服务端redirect来跳转。那今天来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kklldog/p/blazor-wasm-router.html</dc:identifier>
</item>
<item>
<title>Python之Flask框架二 - 白加黑呀</title>
<link>http://www.cnblogs.com/congyiwei/p/13047425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/congyiwei/p/13047425.html</guid>
<description>&lt;p&gt;今天接着上一篇继续写一篇关于flask的随笔。&lt;/p&gt;
&lt;p&gt;本文大纲：&lt;/p&gt;
&lt;p&gt;1、获取请求参数&lt;/p&gt;
&lt;p&gt;2、一个函数处理多个请求方式&lt;/p&gt;
&lt;p&gt;3、重定向&lt;/p&gt;
&lt;p&gt;4、错误响应&lt;/p&gt;
&lt;p&gt;5、全局错误处理&lt;/p&gt;
&lt;p&gt;6、返回json格式数据&lt;/p&gt;
&lt;p&gt;7、自定义返回内容状态码&lt;/p&gt;
&lt;h2&gt;一、request获取请求参数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
from flask import Flask, request

app = Flask(__name__)


@app.route(&quot;/&quot;)
def index():
    a = request
    #get请求
    get_data = request.args
    #form 表单
    form_data = request.form
    #json header{application/json}
    json_data = request.json
    #file
    file_data = request.files
    #同时获取args和form
    data = request.value
    method = request.method
    return a


if __name__ == '__main__':
    app.run(debug=True)
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;二、一个函数处理多个请求方式&lt;/h2&gt;
&lt;p&gt;只需要在app.route()中定义method访问方式，并且在函数中进行相应的处理即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@app.route(&quot;/all_projects&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])
def all_projects():
    if request.method == &quot;GET&quot;:
        return &quot;get&quot;
    elif request.method == &quot;POST&quot;:
        return &quot;post&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、redirect重定向&lt;/h2&gt;
&lt;p&gt;redirect()中传入一个参数就可以实现重定向，那就是传入url，在实际操作中我们一般会使用url_for这个方法，传入端点即可。&lt;/p&gt;
&lt;p&gt;端点：Url和视图函数的绑定关系，默认路由的名称，也就是这个路径绑定的函数名，可以在app.route()中传入endpoint关键字参数进行自定义端点名称。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
from flask import Flask,redirect, url_for
&lt;/pre&gt;
&lt;pre&gt;
app = Flask(__name__)
&lt;/pre&gt;
&lt;pre&gt;
&lt;br/&gt;@app.route(&quot;/&quot;)
def index():
    if request.args.get(&quot;username&quot;) is None:
        return redirect(&quot;/login&quot;)
        return redirect(url_for('login'))
    return &quot;hello&quot;&lt;/pre&gt;
&lt;pre&gt;
@app.route(&quot;/login&quot;)&lt;br/&gt;def login():&lt;br/&gt;return &quot;login&quot;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#后面加参数，请求的时候会自动带上这个参数
return redirect(url_for('login', username=&quot;baijiahei&quot;))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四、错误响应abort()&lt;/h2&gt;
&lt;p&gt;在一些我们可以预知的错误请求时，可以手动给出异常响应，使用时在abort()传入响应码即可，逻辑运行到这里会自动中断，在abort()中自定义了很多错误响应只需要传入响应码，就可以直接使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@app.route(&quot;/&quot;)
def index():
    if request.args.get(&quot;username&quot;) is None:
        abort(401))
    return &quot;hello&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、全局错误处理&lt;/h2&gt;
&lt;p&gt;有一些我们不可预知的错误，比如404，500（服务器正在维护）等情况，我们需要对用户给出友好提示，需要做全局错误处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@app.errorhandler(500)
def server_error(error):
    return render_template(&quot;error_500.html&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用app.errorhandler() 传入响应状态码，当出现这个错误时，会执行下方函数，在函数中我们需要一个参数来接受错误信息。&lt;/p&gt;
&lt;p&gt;注意：当我们定义了@app.errorhandler()之后，使用abort()时传入的响应码如果已经被定义了，则会调用，而不会继续使用abort()内置方法&lt;/p&gt;
&lt;h2&gt;六、返回json类型数据&lt;/h2&gt;
&lt;p&gt;这里使用了flask中的jsonify&lt;/p&gt;
&lt;p&gt;当我们使用了jsonify时，返回的 &lt;code class=&quot;python language-python&quot;&gt;Content&lt;span class=&quot;token operator&quot;&gt;-Type&lt;span class=&quot;token punctuation&quot;&gt;: application&lt;span class=&quot;token operator&quot;&gt;/json,使用方法很简单传入一个json格式的数据即可&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
from flask import Flask， jsonify

import json

app = Flask(__name__)


@app.route(&quot;/login&quot;)
def login():
    return jsonify(json.dumps({&quot;code&quot;: &quot;1&quot;}))
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;七、自定义返回内容状态码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
from flask import Flask, make_response, jsonify

app = Flask(__name__)


@app.route(&quot;/&quot;)
def index():
    # 构造一个响应头信息  返回值， 响应码， 响应头信息{}，放在字典中 状态码或者响应头可以单个不加
    # return json.dumps({&quot;username&quot;: &quot;白加黑&quot;}), 201, {&quot;content-type&quot;: &quot;application/json&quot;}
    # make_response 第二种形式       r  response()
    # r = make_response(json.dumps({&quot;username&quot;: &quot;白加黑&quot;}), {&quot;content-type&quot;: &quot;application/json&quot;})
    # r.status = &quot;203&quot;
    # r.content_type = &quot;text/plain&quot;
    # r.headers =
    # r.content_type =
    # r.mimetype =
    r = jsonify({&quot;username&quot;: &quot;白加黑&quot;})
    # 修改状态码
    r.status = &quot;202&quot;
    return r
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 04 Jun 2020 16:33:00 +0000</pubDate>
<dc:creator>白加黑呀</dc:creator>
<og:description>今天接着上一篇继续写一篇关于flask的随笔。 本文大纲： 1、获取请求参数 2、一个函数处理多个请求方式 3、重定向 4、错误响应 5、全局错误处理 6、返回json格式数据 7、自定义返回内容状态</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/congyiwei/p/13047425.html</dc:identifier>
</item>
<item>
<title>【Spring注解驱动开发】聊聊Spring注解驱动开发那些事儿！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13047333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13047333.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;今天，面了一个工作5年的小伙伴，面试结果不理想啊！也不是我说，工作5年了，问多线程的知识：就只知道继承Thread类和实现Runnable接口！问Java集合，竟然说HashMap是线程安全的！问MySQL的MyISAM存储引擎和InnoDB存储引擎的区别，竟然说成是MyISAM存储引擎支持事务，InnoDB不支持！问Spring就只知道IOC和AOP的概念，深一点就不知道了！再问项目。。。哎，算了，不说了！&lt;/p&gt;
&lt;p&gt;大家对于设计模式、高并发和Java8新特性，不了解的，就去看我的专栏吧！今天，我们来聊聊关于Spring注解驱动开发的那些事儿，也算是Spring专栏的开篇吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于spring&quot;&gt;关于Spring&lt;/h2&gt;
&lt;p&gt;说起Spring，绝对是Java开发领域的佼佼者，试问，做Java开发的有谁不知道Spring？做Java开发的又有谁没用过Spring?又有哪家公司在Java Web项目中没使用过Spring？就算有，那也应该很少吧！所以，骚年，如果你选择了Java开发这条不归路，你就必须牢牢掌握Spring！&lt;/p&gt;
&lt;h2 id=&quot;spring注解驱动&quot;&gt;Spring注解驱动&lt;/h2&gt;
&lt;p&gt;如果小伙伴们还在用Spring的基础框架，例如：Spring、SpringMVC、MyBatis，也就是传说中的SSM，来整合开发的时候，可能会大量的写配置文件。那么，在SpringBoot和SpringCloud兴起之后，Spring的注解驱动就用的非常多了！其中，会用到非常多的注解。为了能够更加深刻的理解这些注解的原理，更好的使用这些注解提高我们的工作效率。这里，我结合实际工作中使用Spring的一些经验，向大家分享下如何使用Spring的注解来提高我们的工作效率，以及注解背后的工作原理到底是什么！&lt;/p&gt;
&lt;h2 id=&quot;专栏安排&quot;&gt;专栏安排&lt;/h2&gt;
&lt;p&gt;不知道怎么安排这个专栏，反正想了很久，无意间看到一张脑图，哈哈，没错，可以按照它来（文末会给出这张图）。那我就把整个专栏分成三个大的部分吧，分别是：容器、扩展原理和Web。&lt;/p&gt;
&lt;h3 id=&quot;容器&quot;&gt;容器&lt;/h3&gt;
&lt;p&gt;容器作为整个专栏的第一大部分，内容包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AnnotationConfigApplicationContext&lt;/li&gt;
&lt;li&gt;组件添加&lt;/li&gt;
&lt;li&gt;组件赋值&lt;/li&gt;
&lt;li&gt;组件注入&lt;/li&gt;
&lt;li&gt;AOP&lt;/li&gt;
&lt;li&gt;声明式事务&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;扩展原理&quot;&gt;扩展原理&lt;/h3&gt;
&lt;p&gt;扩展原理作为整个专栏的第二大部分，内容包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BeanFactoryPostProcessor&lt;/li&gt;
&lt;li&gt;BeanDefinitionRegistryPostProcessor&lt;/li&gt;
&lt;li&gt;ApplicationListener&lt;/li&gt;
&lt;li&gt;Spring容器创建过程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这部分，我们一起来研究Spring的底层源码和运行流程，对于很多小伙伴来说，这部分的内容相当枯燥，甚至有种身体被掏空的感觉（哈哈），但是，这部分的内容一定要掌握，这也是普通程序员进阶成为高级程序员的必经之路。&lt;/p&gt;
&lt;p&gt;这部分内容对于深度学习Spring框架，起着非常重要的作用。小伙伴们在看这部分的文章时，一定要根据文章自己多动手调试Spring源码，这样对于Spring的理解才能更加深刻。&lt;/p&gt;
&lt;h3 id=&quot;web&quot;&gt;Web&lt;/h3&gt;
&lt;p&gt;Web作为整个专栏的第三大部分，内容包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;servlet3.0&lt;/li&gt;
&lt;li&gt;异步请求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这部分，其实就是SpringMVC，这个部分中，我们会重点来说异步请求。&lt;/p&gt;
&lt;p&gt;整个专栏的规划有一定深度，建议小伙伴们提前学习了解下Spring的基础知识，最好是对Spring和SpringMVC框架有过一定的使用经验，如果是事先了解过Spring和SpringMVC的源码，那就太好了，这样学习起来可以达到事半功倍的效果。&lt;/p&gt;
&lt;p&gt;暂时就说这么多吧，今天算是开篇了，小伙伴们有啥想说的，都可以私聊我！&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习Spring注解驱动开发。公众号回复“spring注解”关键字，领取Spring注解驱动开发核心知识图，让Spring注解驱动开发不再迷茫。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，附上Spring注解驱动开发核心知识图，祝大家在学习Spring注解驱动开发时少走弯路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1729473/202006/1729473-20200605000243595-700419751.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Jun 2020 16:03:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 今天，面了一个工作5年的小伙伴，面试结果不理想啊！也不是我说，工作5年了，问多线程的知识：就只知道继承Thread类和实现Runnable接口！问Java集合，竟然说HashMap是线程安全</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13047333.html</dc:identifier>
</item>
</channel>
</rss>