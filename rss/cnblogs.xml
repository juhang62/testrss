<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title> 第 15 篇：接口的单元测试 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13499563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13499563.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200813230332309-2111470875.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;strong&gt;HelloGitHub-&lt;a href=&quot;https://www.zmrenwu.com&quot;&gt;追梦人物&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个完整的项目，无论是个人的还是公司的，自动化的单元测试是必不可少，否则以后任何的功能改动将成为你的灾难。&lt;/p&gt;
&lt;p&gt;假设你正在维护公司的一个项目，这个项目已经开发了几十个 API 接口，但是没有任何的单元测试。现在你的 leader 让你去修改几个接口并实现一些新的功能，你接到需求后高效地完成了开发任务，然后手动测试了一遍改动的接口和新实现的功能，确保没有任何问题后，满心欢喜地提交了代码。&lt;/p&gt;
&lt;p&gt;代码上线后出了 BUG，分析原因发现原来是新的改动导致某个旧 API 接口出了问题，因为上线前只对改动的接口做了测试，所以未能发现这个问题。你的 leader 批评了你，你因为事故记了过，年终只能拿个 3.25，非常凄惨。&lt;/p&gt;
&lt;p&gt;但是如果我们有全面的单元测试，上述情况就有很大概率避免。只需要在代码发布前运行一遍单元测试，受影响的功能立即就会报错，这样就能在代码部署前发现问题，从而避免线上事故。&lt;/p&gt;
&lt;p&gt;当然以上故事纯属虚构，说这么多只是希望大家在开发时养成良好的习惯，&lt;strong&gt;一是写优雅的代码，二是一定要测试自己写的代码&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;单元测试回顾&quot;&gt;单元测试回顾&lt;/h2&gt;
&lt;p&gt;在上一部教程 &lt;a href=&quot;https://www.zmrenwu.com/courses/hellodjango-blog-tutorial/&quot;&gt;Django博客教程（第二版）&lt;/a&gt; 的 &lt;a href=&quot;https://www.zmrenwu.com/courses/hellodjango-blog-tutorial/materials/87/&quot;&gt;单元测试：测试 blog 应用&lt;/a&gt;、&lt;a href=&quot;https://www.zmrenwu.com/courses/hellodjango-blog-tutorial/materials/88/&quot;&gt;单元测试：测试评论应用&lt;/a&gt;、&lt;a href=&quot;https://www.zmrenwu.com/courses/hellodjango-blog-tutorial/materials/89/&quot;&gt;Coverage.py 统计测试覆盖率&lt;/a&gt; 中，我们详细讲解了 django 单元测试框架的使用方式。这里我们再对 djnago 的测试框架做一个回顾整体回顾，至于如何编写和运行测试，后面将会进行详细的讲解，如果想对 django 的单元测试做更基础的了解，推荐回去看看关于测试的 3 篇教程以及 django 的官方文档。&lt;/p&gt;
&lt;p&gt;下面是 djnago 单元测试框架的一些要点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;django 的单元测试框架基于 Python 的 unittest 测试框架。&lt;/li&gt;
&lt;li&gt;django 提供了多个 XXTestCase 类，这些类均直接或者间接继承自 &lt;code&gt;unittest.TestCase&lt;/code&gt; 类，因为 django 的单元测试框架是基于 unittest 的，所以编写的测试用例类也都需要直接或者间接继承 &lt;code&gt;unittest.TestCase&lt;/code&gt;。通常情况我们都是继承 django 提供的 XXTestCase，因为这些类针对 django 定制了更多的功能特性。&lt;/li&gt;
&lt;li&gt;默认情况下，测试代码需要放在 django 应用的下的 tests.py 文件或者 tests 包里，django 会自动发现 tests 包中以 test 开头的模块（例如 test_models.py、test_views.py），然后执行测试用例类中命名以 test 开头的方法。&lt;/li&gt;
&lt;li&gt;python manage.py test 命令可以运行单元测试。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;梳理需要测试的接口&quot;&gt;梳理需要测试的接口&lt;/h2&gt;
&lt;p&gt;接下来我们就为博客的 API 接口来编写单元测试。对 API 接口来说，我们主要关心的就是：&lt;strong&gt;对特定的请求返回正确的响应&lt;/strong&gt;。我们先来梳理一下需要测试的接口和功能点。&lt;/p&gt;
&lt;p&gt;博客主要的接口都集中在 &lt;code&gt;PostViewSet&lt;/code&gt; 和 &lt;code&gt;CommentViewSet&lt;/code&gt; 两个视图集中。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;CommentViewSet&lt;/code&gt; 视图集的接口比较简单，就是创建评论。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;PostViewSet&lt;/code&gt; 视图集的接口则包含了文章列表、文章详情、评论列表、归档日期列表等。对于文章列表接口，还可以通过查询参数对请求的文章列表资源进行过滤，获取全部文章的一个子集。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;CommentViewSet&lt;/code&gt; 只有一个接口，功能比较简单，我们首先以它为例来讲解单元测试的编写方式。&lt;/p&gt;
&lt;p&gt;测试接口的一般步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获得接口的 URL。&lt;/li&gt;
&lt;li&gt;向接口发送请求。&lt;/li&gt;
&lt;li&gt;检查响应的 HTTP 状态码、返回的数据等是否符合预期。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们以测试创建评论的代码 &lt;code&gt;test_create_valid_comment&lt;/code&gt; 为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# filename=&quot;comments/tests/test_api.py
from django.apps import apps
from django.contrib.auth.models import User
from rest_framework import status
from rest_framework.reverse import reverse
from rest_framework.test import APITestCase

from blog.models import Category, Post
from comments.models import Comment


class CommentViewSetTestCase(APITestCase):
    def setUp(self):
        self.url = reverse(&quot;v1:comment-list&quot;)
        # 断开 haystack 的 signal，测试生成的文章无需生成索引
        apps.get_app_config(&quot;haystack&quot;).signal_processor.teardown()
        user = User.objects.create_superuser(
            username=&quot;admin&quot;, email=&quot;admin@hellogithub.com&quot;, password=&quot;admin&quot;
        )
        cate = Category.objects.create(name=&quot;测试&quot;)
        self.post = Post.objects.create(
            title=&quot;测试标题&quot;, body=&quot;测试内容&quot;, category=cate, author=user,
        )

    def test_create_valid_comment(self):
        data = {
            &quot;name&quot;: &quot;user&quot;,
            &quot;email&quot;: &quot;user@example.com&quot;,
            &quot;text&quot;: &quot;test comment text&quot;,
            &quot;post&quot;: self.post.pk,
        }
        response = self.client.post(self.url, data)
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)

        comment = Comment.objects.first()
        self.assertEqual(comment.name, data[&quot;name&quot;])
        self.assertEqual(comment.email, data[&quot;email&quot;])
        self.assertEqual(comment.text, data[&quot;text&quot;])
        self.assertEqual(comment.post, self.post)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，接口的 URL 地址为：&lt;code&gt;reverse(&quot;v1:comment-list&quot;)&lt;/code&gt;。&lt;code&gt;reverse&lt;/code&gt; 函数通过视图函数名来解析对应的 URL，视图函数名的格式为：&lt;code&gt;&quot;&amp;lt;namespace&amp;gt;:&amp;lt;basename&amp;gt;-&amp;lt;action name&amp;gt;&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;其中 namespace 是 &lt;code&gt;include&lt;/code&gt; 函数指定的 &lt;code&gt;namespace&lt;/code&gt; 参数值，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;path(&quot;api/v1/&quot;, include((router.urls, &quot;api&quot;), namespace=&quot;v1&quot;))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;basename 是 router 在 &lt;code&gt;register&lt;/code&gt; 视图集时指定的参数 basename 的值，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;router.register(r&quot;posts&quot;, blog.views.PostViewSet, basename=&quot;post&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;action name 是 action 装饰器指定的 &lt;code&gt;url_name&lt;/code&gt; 参数的值，或者默认的 list、retrieve、create、update、delete 标准 action 名，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# filename=&quot;blog/views.py
@action(
        methods=[&quot;GET&quot;], detail=False, url_path=&quot;archive/dates&quot;, url_name=&quot;archive-date&quot;
)
def list_archive_dates(self, request, *args, **kwargs):
        pass
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，&lt;code&gt;reverse(&quot;v1:comment-list&quot;)&lt;/code&gt; 将被解析为 /api/v1/comments/。&lt;/p&gt;
&lt;p&gt;接着我们向这个 URL 发送 POST 请求：&lt;code&gt;response = self.client.post(self.url, data)&lt;/code&gt;，因为继承自 django-reset-framework 提供的测试类 &lt;code&gt;APITestCase&lt;/code&gt;，因此可以直接通过 &lt;code&gt;self.client&lt;/code&gt; 来发送请求，其中 &lt;code&gt;self.client&lt;/code&gt; 是 django-rest-framework 提供的 &lt;code&gt;APIClient&lt;/code&gt; 的一个实例，专门用来发送 HTTP 测试请求。&lt;/p&gt;
&lt;p&gt;最后就是对请求的响应结果 &lt;code&gt;response&lt;/code&gt; 做检查。创建评论成功后返回的状态码应该是 201，接口返回的数据在 &lt;code&gt;response.data&lt;/code&gt; 属性中，我们对接口返回的状态码和部分数据进行了断言，确保符合预期的结果。&lt;/p&gt;
&lt;p&gt;当然以上是评论创建成功的情况，我们测试时不能只测试正常情况，更要关注边界情况和异常情况，我们再来增加一个评论数据格式不正确导致创建失败的测试案例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# filename=&quot;comments/tests/test_api.py
def test_create_invalid_comment(self):
    invalid_data = {
        &quot;name&quot;: &quot;user&quot;,
        &quot;email&quot;: &quot;user@example.com&quot;,
        &quot;text&quot;: &quot;test comment text&quot;,
        &quot;post&quot;: 999,
    }
    response = self.client.post(self.url, invalid_data)
    self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
    self.assertEqual(Comment.objects.count(), 0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;套路还是一样的，第一步向接口发请求，然后对预期返回的响应结果进行断言。这里由于评论数据不正确（关联的 id 为 999 的 post 不存在），因此预期返回的状态码是 400，同时数据库中不应该有创建的评论。&lt;/p&gt;
&lt;h2 id=&quot;测试-postviewset&quot;&gt;测试 PostViewSet&lt;/h2&gt;
&lt;p&gt;尽管 &lt;code&gt;PostViewSet&lt;/code&gt; 包含的接口比较多，但是每个接口测试的套路和上面讲的是一样的，依葫芦画瓢就行了。因为 &lt;code&gt;PostViewSet&lt;/code&gt; 测试代码较多，这里仅把各个测试案例对应的方法列出来，具体的测试逻辑省略掉。如需了解详细可查看 GitHub 上项目的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# filename=&quot;blog/tests/test_api.py
from datetime import datetime

from django.apps import apps
from django.contrib.auth.models import User
from django.core.cache import cache
from django.urls import reverse
from django.utils.timezone import utc
from rest_framework import status
from rest_framework.test import APITestCase

from blog.models import Category, Post, Tag
from blog.serializers import PostListSerializer, PostRetrieveSerializer
from comments.models import Comment
from comments.serializers import CommentSerializer


class PostViewSetTestCase(APITestCase):
    def setUp(self):
        # 断开 haystack 的 signal，测试生成的文章无需生成索引
        apps.get_app_config(&quot;haystack&quot;).signal_processor.teardown()
        # 清除缓存，防止限流
        cache.clear()

        # 设置博客数据
        # post3 category2 tag2 2020-08-01 comment1 comment2
        # post2 category1 tag1 2020-07-31
        # post1 category1 tag1 2020-07-10

    def test_list_post(self):
        &quot;&quot;&quot;
        这个方法测试文章列表接口，预期的响应状态码为 200，数据为文章列表序列化后的结果
        &quot;&quot;&quot;
        url = reverse(&quot;v1:post-list&quot;)

    def test_list_post_filter_by_category(self):
        &quot;&quot;&quot;
        这个方法测试获取某个分类下的文章列表接口，预期的响应状态码为 200，数据为文章列表序列化后的结果
        &quot;&quot;&quot;
        url = reverse(&quot;v1:post-list&quot;)
        

    def test_list_post_filter_by_tag(self):
        &quot;&quot;&quot;
        这个方法测试获取某个标签下的文章列表接口，预期的响应状态码为 200，数据为文章列表序列化后的结果
        &quot;&quot;&quot;
        url = reverse(&quot;v1:post-list&quot;)
        

    def test_list_post_filter_by_archive_date(self):
        &quot;&quot;&quot;
        这个方法测试获取归档日期下的文章列表接口，预期的响应状态码为 200，数据为文章列表序列化后的结果
        &quot;&quot;&quot;
        url = reverse(&quot;v1:post-list&quot;)
        

    def test_retrieve_post(self):
        &quot;&quot;&quot;
        这个方法测试获取单篇文章接口，预期的响应状态码为 200，数据为单篇文章序列化后的结果
        &quot;&quot;&quot;
        url = reverse(&quot;v1:post-detail&quot;, kwargs={&quot;pk&quot;: self.post1.pk})
        

    def test_retrieve_nonexistent_post(self):
        &quot;&quot;&quot;
        这个方法测试获取一篇不存在的文章，预期的响应状态码为 404
        &quot;&quot;&quot;
        url = reverse(&quot;v1:post-detail&quot;, kwargs={&quot;pk&quot;: 9999})
        

    def test_list_archive_dates(self):
        &quot;&quot;&quot;
        这个方法测试获取文章的归档日期列表接口
        &quot;&quot;&quot;
        url = reverse(&quot;v1:post-archive-date&quot;)
        

    def test_list_comments(self):
        &quot;&quot;&quot;
        这个方法测试获取某篇文章的评论列表接口，预期的响应状态码为 200，数据为评论列表序列化后的结果
        &quot;&quot;&quot;
        url = reverse(&quot;v1:post-comment&quot;, kwargs={&quot;pk&quot;: self.post3.pk})
        

    def test_list_nonexistent_post_comments(self):
        &quot;&quot;&quot;
        这个方法测试获取一篇不存在的文章的评论列表，预期的响应状态码为 404
        &quot;&quot;&quot;
        url = reverse(&quot;v1:post-comment&quot;, kwargs={&quot;pk&quot;: 9999})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们以 &lt;code&gt;test_list_post_filter_by_archive_date&lt;/code&gt; 为例做一个讲解，其它的测试案例代码逻辑大同小异。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# filename=&quot;blog/tests/test_api.py
def test_list_post_filter_by_archive_date(self):
    # 解析文章列表接口的 URL
    url = reverse(&quot;v1:post-list&quot;)
    
    # 发送请求，我们这里给 get 方法的第二个参数传入了一个字典，这个字典代表了 get 请求的查询参数。
    # 例如最终的请求的 URL 会被编码成：/posts/?created_year=2020&amp;amp;created_month=7
    response = self.client.get(url, {&quot;created_year&quot;: 2020, &quot;created_month&quot;: 7})
    self.assertEqual(response.status_code, status.HTTP_200_OK)
    
    # 如何检查返回的数据是否正确呢？对这个接口的请求，
    # 我们预期返回的结果是 post2 和 post1 这两篇发布于2020年7月的文章序列化后的数据。
    # 因此，我们使用 PostListSerializer 对这两篇文章进行了序列化，
    # 然后和返回的结果 response.data[&quot;results&quot;] 进行比较。
    serializer = PostListSerializer(instance=[self.post2, self.post1], many=True)
    self.assertEqual(response.data[&quot;results&quot;], serializer.data)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;运行测试&quot;&gt;运行测试&lt;/h2&gt;
&lt;p&gt;接下来运行测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;Linux/macOS&quot;
$ pipenv run coverage run manage.py test

&quot;Windows&quot;
...\&amp;gt; pipenv run coverage run manage.py test
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大部分测试都通过了，但是也有一个测试失败了，也就是说我们通过测试发现了一个 BUG：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;======================================================================
FAIL: test_list_archive_dates (blog.tests.test_api.PostViewSetTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;C:\Users\user\SpaceLocal\Workspace\G_Courses\HelloDjango\HelloDjango-rest-framework-tutorial\blog\tests\test_api.py&quot;, line 123, in test_list_archive_dates
    self.assertEqual(response.data, [&quot;2020-08&quot;, &quot;2020-07&quot;])
AssertionError: Lists differ: ['2020-08-01', '2020-07-01'] != ['2020-08', '2020-07']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;失败的是 &lt;code&gt;test_list_archive_dates&lt;/code&gt; 这个测试案例，文章归档日期接口返回的数据不符合我们的预期，我们预期得到 yyyy-mm 格式的日期列表，但接口返回的是 yyyy-mm-dd，这是我们之前开发时没有发现的，通过测试将问题暴露了，这也从一定程度上印证了我们之前强调的测试的作用。&lt;/p&gt;
&lt;p&gt;既然已经发现了问题，就来修复它。我相信修复这个 bug 对你来说应该已经是轻而易举的事了，因此留作练习吧，这里不再讲解。&lt;/p&gt;
&lt;p&gt;重新运行一遍测试，得到 ok 的状态。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ran 55 tests in 8.997s&lt;/p&gt;
&lt;p&gt;OK&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明全部测试通过。&lt;/p&gt;
&lt;h2 id=&quot;检查测试覆盖率&quot;&gt;检查测试覆盖率&lt;/h2&gt;
&lt;p&gt;以上测试充分了吗？单凭肉眼自然很难发现，&lt;a href=&quot;https://www.zmrenwu.com/courses/hellodjango-blog-tutorial/materials/89/&quot;&gt;Coverage.py 统计测试覆盖率&lt;/a&gt; 中我们配置了 Coverage.py 并介绍了它的用法，直接运行下面的命令就可以查看代码的测试覆盖程度：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;Linux/macOS&quot;
$ pipenv run coverage report

&quot;Windows&quot;
...\&amp;gt; pipenv run coverage report
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;覆盖结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Name                  Stmts   Miss Branch BrPart  Cover   Missing
-----------------------------------------------------------------
blog\serializers.py      46      5      0      0    89%   82-86
blog\utils.py            21      2      4      1    88%   29-&amp;gt;30, 30-31
blog\views.py           119      5      4      0    94%   191, 200, 218-225
comments\views.py        25      1      2      0    96%   59
-----------------------------------------------------------------
TOTAL                  1009     13     34      1    98%
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到测试覆盖率整体达到了 98%，但是仍有 4 个文件部分代码未被测试，命令行中只给出了未被测试覆盖的代码行号（Missing 列），不是很直观，运行下面的命令可以生成一个 HTML 报告，可视化地查看未被测试覆盖的代码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;Linux/macOS&quot;
$ pipenv run coverage html

&quot;Windows&quot;
...\&amp;gt; pipenv run coverage html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令执行后会在项目根目录生成一个 htmlcov 文件夹，用浏览器打开里面的 index.html 页面就可以查看测试覆盖情况的详细报告了。&lt;/p&gt;
&lt;p&gt;HTML 报告页面示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200813230832993-752460975.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;未覆盖的代码通过红色高亮背景标出，非常直观。可以看到 blog/views.py 中 &lt;code&gt;CategoryViewSet&lt;/code&gt; 和 &lt;code&gt;TagViewSet&lt;/code&gt; 未进行测试，按照上面介绍的测试方法补充测试就可以啦。这两个视图集都非常的简单，测试的任务就留作练习了。&lt;/p&gt;
&lt;h2 id=&quot;补充测试&quot;&gt;补充测试&lt;/h2&gt;
&lt;p&gt;blog/serializers.py 中的 &lt;code&gt;HighlightedCharField&lt;/code&gt; 未测试，还有 blog/utils.py 中新增的 &lt;code&gt;UpdatedAtKeyBit&lt;/code&gt; 未测试，我们编写相应的测试案例。&lt;/p&gt;
&lt;h3 id=&quot;测试-updatedatkeybit&quot;&gt;测试 UpdatedAtKeyBit&lt;/h3&gt;
&lt;p&gt;UpdatedAtKeyBit 就只有一个 &lt;code&gt;get_data&lt;/code&gt; 方法，这个方法预期的逻辑是：从缓存中取得以 &lt;code&gt;self.key&lt;/code&gt; 为键的缓存值（缓存被设置时的时间），如果缓存未命中，就取当前时间，并将这个时间写入缓存。&lt;/p&gt;
&lt;p&gt;将预期的逻辑写成测试代码如下，需要注意的一点是因为这个辅助类不涉及 django 数据库方面的操作，因此我们直接继承自更为简单的 &lt;code&gt;unittest.TestCase&lt;/code&gt;，这可以提升测试速度：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# filename=&quot;blog/tests/test_utils.py
import unittest
from datetime import datetime

from django.core.cache import cache

from ..utils import Highlighter, UpdatedAtKeyBit

class UpdatedAtKeyBitTestCase(unittest.TestCase):
    def test_get_data(self):
        # 未缓存的情况
        key_bit = UpdatedAtKeyBit()
        data = key_bit.get_data()
        self.assertEqual(data, str(cache.get(key_bit.key)))

        # 已缓存的情况
        cache.clear()
        now = datetime.utcnow()
        now_str = str(now)
        cache.set(key_bit.key, now)
        self.assertEqual(key_bit.get_data(), now_str)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试-highlightedcharfield&quot;&gt;测试 HighlightedCharField&lt;/h3&gt;
&lt;p&gt;我们在讲解自定义系列化字段的时候讲过，序列化字段通过调用 &lt;code&gt;to_representation&lt;/code&gt; 方法，将传入的值进行序列化。&lt;code&gt;HighlightedCharField&lt;/code&gt; 的预期逻辑就是调用 &lt;code&gt;to_representation&lt;/code&gt; 方法后将传入的值进行高亮处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HighlightedCharField&lt;/code&gt; 涉及到一些高级操作，主要是因为 &lt;code&gt;to_representation&lt;/code&gt; 方法中涉及到对 HTTP 请求request 的操作。正常的视图函数调用时，视图函数会接收到传入的 request 参数，然后 django-rest-framework 会将 request 传给序列化器（Serializer）的 &lt;code&gt;_context&lt;/code&gt; 属性，序列化器中的任何序列化字段均可以通过直接访问 &lt;code&gt;context&lt;/code&gt; 属性而间接访问到 &lt;code&gt;_context&lt;/code&gt; 属性，从而拿到 request 对象。&lt;/p&gt;
&lt;p&gt;但是在单元测试中，可能没有这样的视图函数调用，因此 &lt;code&gt;_context&lt;/code&gt; 的设置并不会自动进行，需要我们模拟视图函数调用时的行为，手动进行设置。主要包括 2 点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构造 HTTP 请求对象 request。&lt;/li&gt;
&lt;li&gt;设置 _context 属性的值。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体的代码如下，详细讲解请看相关代码行的注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# filename=&quot;blog/tests/test_serializer.py
import unittest

from blog.serializers import HighlightedCharField
from django.test import RequestFactory
from rest_framework.request import Request


class HighlightedCharFieldTestCase(unittest.TestCase):
    def test_to_representation(self):
        field = HighlightedCharField()
        # RequestFactory 专门用来构造 request 对象。
        # 这个 RequestFactory 生成的 request 代表了一个对 URL / 访问的 get 请求，
        # 并包含 URL 参数 text=关键词。
        # 请求访问的完整 URL 就是 /?text=关键词
        request = RequestFactory().get(&quot;/&quot;, {&quot;text&quot;: &quot;关键词&quot;})
        
        # django-rest-framework 对 django 内置的 request 进行了包装，
        # 因此这里要手动使用 drf 提供的 Request 类对 django 的 request 进行一层包装。
        drf_request = Request(request=request)
        
        # 设置 HighlightedCharField 实例 _context 属性的值，这样在其内部就可以通过
        # self.context[&quot;request&quot;] 拿到请求对象 request
        setattr(field, &quot;_context&quot;, {&quot;request&quot;: drf_request})
        document = &quot;无关文本关键词无关文本，其他别的关键词别的无关的词。&quot;
        result = field.to_representation(document)
        expected = (
            '无关文本&amp;lt;span class=&quot;highlighted&quot;&amp;gt;关键词&amp;lt;/span&amp;gt;无关文本，'
            '其他别的&amp;lt;span class=&quot;highlighted&quot;&amp;gt;关键词&amp;lt;/span&amp;gt;别的无关的词。'
        )
        self.assertEqual(result, expected)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行一遍测试覆盖率的检查命令，这次得到的测试覆盖率就是 100% 了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Name    Stmts   Miss Branch BrPart  Cover   Missing
---------------------------------------------------
---------------------------------------------------
TOTAL    1047      0     32      0   100%
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，需要提醒一点的是，测试覆盖率 100% 并不能说明程序就没有 BUG 了。线上可能出现各种奇奇怪怪的问题，这些问题可能并没有写成测试案例，所以也就没有测试到。但无论如何，目前我们已经进行了较为充分的测试，就可以考虑发布一个版本了。如果以后再线上遇到什么问题，或者想到了新的测试案例，可以随时补充进单元测试，以后程序出 BUG 的几率就会越来越低了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200813230159561-969610802.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号加入我们&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Aug 2020 00:32:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub-追梦人物 一个完整的项目，无论是个人的还是公司的，自动化的单元测试是必不可少，否则以后任何的功能改动将成为你的灾难。 假设你正在维护公司的一个项目，这个项目已经开发了几十</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13499563.html</dc:identifier>
</item>
<item>
<title>初识ABP vNext（2）：ABP启动模板 - xhznl</title>
<link>http://www.cnblogs.com/xhznl/p/13497071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhznl/p/13497071.html</guid>
<description>&lt;p&gt;上一篇介绍了ABP的一些基础知识，本篇继续介绍ABP的启动模板。使用ABP CLI命令就可以得到这个启动模板，其中包含了一些基础功能模块，你可以基于这个模板来快速开发。&lt;/p&gt;

&lt;p&gt;首先ABP CLI的安装以及基本指令这些就不说了，官网上写的很清楚。目前ABP的前端部分只支持ASP.NET Core MVC / Razor Pages和Angular，移动端支持React Native。&lt;/p&gt;
&lt;p&gt;初学者建议跟着官网https://docs.abp.io/zh-Hans/abp/latest/Tutorials/Part-1?UI=MVC这个指引做一遍，体验一下ABP开发的基本流程，虽然ABP开发流程几乎都标准化了，照着官网的流程编写代码就能完成一个功能的开发，但是这个过程有些繁琐，容易出错。这里推荐一个开源项目：&lt;a href=&quot;https://github.com/EasyAbp/AbpHelper.GUI%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AAABP%E5%B8%AE%E5%8A%A9%E5%B7%A5%E5%85%B7%EF%BC%8C%E4%BD%A0%E5%8F%AA%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BD%93%EF%BC%8C%E5%89%A9%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%83%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%B8%AE%E4%BD%A0%E7%94%9F%E6%88%90%E3%80%82%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%98%AFhttps://github.com/EasyAbp%E4%B8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AD%90%E9%A1%B9%E7%9B%AE%EF%BC%8CEasyAbp%E6%98%AF%E5%9B%BD%E5%86%85ABP%E7%88%B1%E5%A5%BD%E8%80%85%E5%88%9B%E5%BB%BA%E7%9A%84%EF%BC%8C%E9%87%8C%E9%9D%A2%E8%BF%98%E6%9C%89%E5%BE%88%E5%A4%9A%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%85%B3%E6%B3%A8%E4%B8%80%E4%B8%8B%E3%80%82%E3%80%82%E3%80%82&quot;&gt;https://github.com/EasyAbp/AbpHelper.GUI，这是一个ABP帮助工具，你只需要创建一个实体，剩下的代码它都可以帮你生成。这个项目是https://github.com/EasyAbp下的一个子项目，EasyAbp是国内ABP爱好者创建的，里面还有很多开箱即用的模块，可以关注一下。。。&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;abphelper&quot;&gt;AbpHelper&lt;/h2&gt;
&lt;p&gt;使用AbpHelper来完成官网的例子非常容易，首先创建项目解决方案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200808172208668-117306134.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200808172259139-1144630104.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AbpHelper提供了图形化配置，自动帮我们执行ABP CLI指令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200808173003735-727456081.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行完成后，打开解决方案，先启动Acme.BookStore.DbMigrator项目来初始化数据库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200808173402021-1502894791.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200808173329310-1112891760.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200808173506095-726154508.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就可以启动Acme.BookStore.Web项目，这是APB启动模板的默认界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200808174015503-514476808.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，在Acme.BookStore.Domain项目中创建Book实体，我直接从官网上复制代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Book : AuditedAggregateRoot&amp;lt;Guid&amp;gt;
{
    public string Name { get; set; }

    public BookType Type { get; set; }

    public DateTime PublishDate { get; set; }

    public float Price { get; set; }

    protected Book()
    {
    }
    public Book(Guid id, string name, BookType type, DateTime publishDate, float price)
        : base(id)
    {
        Name = name;
        Type = type;
        PublishDate = publishDate;
        Price = price;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Acme.BookStore.Domain.Shared项目中添加枚举类BookType：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public enum BookType
{
    Undefined,
    Adventure,
    Biography,
    Dystopia,
    Fantastic,
    Horror,
    Science,
    ScienceFiction,
    Poetry
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次使用需要安装一下AbpHelper CLI：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200808174709856-692014386.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择Generate CRUD，填入实体名称和解决方案路径，然后Execute即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200808223929839-1900603445.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成代码时可能会报这个错（如果没装ef tools）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200809122533017-1199719100.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时安装一下ef tools就好了，&lt;code&gt;dotnet tool install -g dotnet-ef&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200809122703623-1534963738.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码生成完后，运行Acme.BookStore.Web项目：&lt;/p&gt;
&lt;p&gt;使用默认用户 admin/1q2w3E* 登录系统，给admin角色分配BookStore相关权限：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200809142215488-1866268604.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就可以看到book菜单了，包括基本的增删改查界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200809142402665-1762942163.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此就完成了一个基本功能的开发，AbpHelper确实很方便，他还有CLI版本，直接命令行操作。&lt;/p&gt;
&lt;h2 id=&quot;模块安装&quot;&gt;模块安装&lt;/h2&gt;
&lt;p&gt;ABP的模块化可以实现插件式的开发，你可以预先构建一些通用的模块，比如日志模块，用户模块等等，当你以后需要时就可以直接安装到项目中。有一些由ABP社区开发和维护的开源免费的应用程序模块，我们可以直接使用；比如我要使用官方的Blogging模块，Blogging是用于创建精美的博客。&lt;/p&gt;
&lt;p&gt;同样使用AbpHelper来安装：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200809173458658-1627766935.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装过程出了点小问题，提示找不到DbContext。。。不过没关系，自己执行一下迁移命令就行。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200809222058906-744846658.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Acme.BookStore.Web项目设为启动项，默认项目为Acme.BookStore.EntityFrameworkCore.DbMigrations，然后执行：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Add-Migration AddedBlogging&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Update-DataBase&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200809222800652-1157485564.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来再次运行Acme.BookStore.Web项目，为admin角色配置博客相关的权限：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200809192431041-540693524.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就就可以看到博客的相关功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200809223056171-1206249551.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Swagger：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/610959/202008/610959-20200809224947937-578664104.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，这些模块不一定完全符合你的要求，你可能需要稍作修改，ABP也允许你扩展实体，重写服务包括重写用户界面，你可以很方便的修改。这些后面再介绍，包括如何去开发这种模块。。。&lt;/p&gt;

&lt;p&gt;EasyAbp上也有很多开源模块，地址是：&lt;a href=&quot;https://github.com/EasyAbp/EasyAbpGuide%EF%BC%8C%E7%9B%AE%E5%89%8D%E8%BF%99%E4%BA%9B%E6%A8%A1%E5%9D%97%E7%9A%84UI%E9%83%A8%E5%88%86%E9%83%BD%E5%8F%AA%E6%94%AF%E6%8C%81MVC/Razor&quot;&gt;https://github.com/EasyAbp/EasyAbpGuide，目前这些模块的UI部分都只支持MVC/Razor&lt;/a&gt; Pages，不支持Angular之类的。。。当然模块不一定非要UI，一些Framework级别的模块就不需要UI。基础部分就写到这里，主要还是需要认真看下官网，然后自己动手练习一下。下一篇将进入vue+ABP实战部分。&lt;/p&gt;
</description>
<pubDate>Fri, 14 Aug 2020 00:25:00 +0000</pubDate>
<dc:creator>xhznl</dc:creator>
<og:description>前言 上一篇介绍了ABP的一些基础知识，本篇继续介绍ABP的启动模板。使用ABP CLI命令就可以得到这个启动模板，其中包含了一些基础功能模块，你可以基于这个模板来快速开发。 开始 首先ABP CLI</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhznl/p/13497071.html</dc:identifier>
</item>
<item>
<title>C++最好的图形库是什么？ - Coding十日谈</title>
<link>http://www.cnblogs.com/jfzhu/p/13500079.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jfzhu/p/13500079.html</guid>
<description>
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074312506-1941898473.jpg&quot; alt=&quot;&quot; width=&quot;725&quot; height=&quot;362&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文字数：1660，阅读时长大约：15分钟&lt;/p&gt;

&lt;p&gt;世界上的GUI库多如牛毛，有的开源，有的收费，有的可以做手机app开发，有的可以做桌面应用，有的只能用在某个系统，有的支持跨平台。基于不同的编程语言，人们又开发出不同的图形框架，比如Java有AWT、Swing；C#有WinForm和WPF；C++有MFC、QT、wxWidgets等。在C++的库中，QT凭借对跨平台的支持、简单易用、开发效率高等特性，成为最受欢迎的GUI库之一。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;一、Qt是什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p align=&quot;justify&quot;&gt;引用百度百科一句话概括：“Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;justify&quot;&gt;Qt支持市场上常用的操作系统，并且开发出的图形界面非常优美。它是完全面向对象的，容易扩展，允许真正的组件编程。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;二、平台支持&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;Qt不仅支持桌面系统，还支持手机和嵌入式的应用。桌面系统包括Windows、Unix、Linux、Mac，手机系统支持安卓和iOS等。和Java不同的是，它没有运行在额外的一层虚拟机上，而是针对不同的系统提供了相应的套件和编译器。Qt的跨平台支持使得它对不同平台的开发部署更为简单。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;三、使用Qt开发的应用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;使用Qt开发的应用很多，比较著名的有Linux的桌面环境KDE、WPS、Skype、VirtualBox虚拟机、谷歌地图、VLC播放器等等，其中KDE已经是Linux的主流桌面应用之一。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;四、Qt的优点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;使用Qt开发有很多优点，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;跨平台支持：如果你希望程序运行在多个平台下，同时又降低开发成本，Qt是很好的选择&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;简单易学：封装好，几行简单的代码就可以开发出简单的程序，不需要对操作系统底层有太多了解&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;资料丰富：网络上有很多的资料，社区氛围好，可以得到很多帮助&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;界面漂亮：Qt很容易开发出比较炫酷的效果，而MFC、wxWidgets等就比较麻烦&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;独立安装：不像Java需要安装虚拟机，C#需要.net，Qt会编译成本地代码，不需要额外库的支持&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为Qt的种种优势，它在市场上的份额越来越高，得到很多公司的青睐。下面列举了猎聘上一些Qt工程师的职位，月薪基本上在2万-3万之间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074333670-1116033790.png&quot; alt=&quot;&quot; width=&quot;318&quot; height=&quot;306&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;五、Qt的发展史与版本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;Qt几经辗转，被很多公司收购过，换了很多东家：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1991年由挪威的一家计算机公司Trolltech（奇趣科技）开发&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;1996年进入商业领域，成为Linux KDE的基础&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;2008年奇趣科技被芬兰巨头诺基亚收购&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;2012年诺基亚濒临破产，Qt出售给了芬兰的一家IT公司Digia&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;Qt的版本：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Qt 1 - 3都是由奇趣科技开发的&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;诺基亚开发了Qt 4版本&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;Digia开发了Qt 5，但是Qt 5对 Qt 4不兼容&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt;另外Qt有商业版和免费版。两者的代码都是一致的，但商业版可以得到售后服务，比如培训和技术支持。免费版需要遵从LGPL协议，简单说，你需要开放所有使用了LGPL协议的代码，所以使用免费版Qt进行商业开发的同学要注意商业纠纷的风险。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;六、Qt的下载与安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;(1)下载&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;Qt有在线安装包和离线安装包。在线安装包的使用体验不是很好，经常会卡顿在99%的进度不能继续，所以推荐大家使用离线安装包。安装包的下载可以使用以下两个网站：&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;a href=&quot;http://www.qtcn.org/bbs/read-htm-tid-1075.html&quot; target=&quot;_blank&quot;&gt;http://www.qtcn.org/bbs/read-htm-tid-1075.html&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;a href=&quot;https://www.qt.io/offline-installerst&quot; target=&quot;_blank&quot;&gt;https://www.qt.io/offline-installerst&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;比如下载Windows下的Qt 5.14的离线安装包可以选择下面这个链接：&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074427771-1600706131.png&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;411&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;（2）安装&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;下载好后，前面基本一直点击下一步就可以了：&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074438777-447881676.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;393&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074453766-1638028631.png&quot; alt=&quot;&quot; width=&quot;355&quot; height=&quot;391&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;这一步要注册Qt账户，需要一个邮箱地址，可以按提示操作&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074506066-1337193866.png&quot; alt=&quot;&quot; width=&quot;355&quot; height=&quot;390&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074520598-937228216.png&quot; alt=&quot;&quot; width=&quot;355&quot; height=&quot;391&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074549811-1918245355.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;391&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;指定安装路径&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074621183-1053947815.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;392&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;下面需要选择套件，这些套件都包含专属的编译器。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;MSVC是Desktop Qt MSVC的套件，需要安装Visual Studio相对应的版本&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;MinGW是Desktop Qt MinGW的套件。MinGW是Minimalist GNU for Windows的缩写，是在Windows平台上使用的GNU工具集导入库的集合，这个集合包括了C编译器gcc，C++编译器g++，和调试器gdb等工具。如果不使用Visual Studio，可以选择这个套件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;UWP是针对Win 10以后UWP程序的套件&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;Android，如果需要开发安卓app，需要勾选这个套件&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;Sources可以下载Qt的源代码&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;Qt的其他组件，比如Qt Charts、Qt Quick 3D等，可以根据需要选择，注意括号里写着（Deprecated）的套件是为了兼容老版本，如果是开发新程序不用选择&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;Developer and Desinger Tools里面Qt Creator是一定要选的，如果使用Qt Creator开发，MinGW也要勾选上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074638874-1020855216.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;接下来都点击下一步就可以了&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074734175-796943866.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;395&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074750489-240403059.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;396&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074811901-632286879.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;393&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;接下来开始安装&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814074829724-538901238.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;392&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;安装成功&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814080428563-1772984689.png&quot; alt=&quot;&quot; width=&quot;355&quot; height=&quot;391&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;七、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Qt有着良好的跨平台支持、界面优美、简单易用、学习资料丰富等优点，和其他的GUI框架相比受到开发者们的广泛欢迎，因此想要从事图形界面开发的同学可以考虑学习Qt。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/13467226.html&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Linux快速搭建C/C++开发环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/13456119.html&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;一篇文章快速搞懂什么是GitHub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12928138.html&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;虚拟机安装 Linux 最完整攻略&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12912897.html&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;Vi 和 Vim 的使用&lt;/a&gt;&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;获取知识干货、增加面试经验、了解职场人生&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;欢迎关注微信公众号&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202008/442200-20200814080554957-753514664.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 14 Aug 2020 00:08:00 +0000</pubDate>
<dc:creator>Coding十日谈</dc:creator>
<og:description>本文字数：1660，阅读时长大约：15分钟 世界上的GUI库多如牛毛，有的开源，有的收费，有的可以做手机app开发，有的可以做桌面应用，有的只能用在某个系统，有的支持跨平台。基于不同的编程语言，人们又</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jfzhu/p/13500079.html</dc:identifier>
</item>
<item>
<title>精讲RestTemplate第7篇-自定义请求失败异常处理 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13500053.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13500053.html</guid>
<description>&lt;p&gt;本文是精讲RestTemplate第7篇，前篇的blog访问地址如下：&lt;/p&gt;
&lt;h2 id=&quot;一、异常现象&quot;&gt;一、异常现象&lt;/h2&gt;
&lt;p&gt;在使用RestTemplate进行远程接口服务调用的时候，当请求的服务出现异常：超时、服务不存在等情况的时候（响应状态非200、而是400、500HTTP状态码），就会抛出如下异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200814071356568-1069199008.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该异常我是模拟出来的，将正确的请求服务地址由“/posts/1”改成“/postss/1”。服务不存在所以抛出404异常。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
public void testEntity() {
   String url = &quot;http://jsonplaceholder.typicode.com/postss/1&quot;;
   ResponseEntity&amp;lt;String&amp;gt; responseEntity
               = restTemplate.getForEntity(url, String.class);  //这行抛出异常
   //下面两行代码执行不到
   HttpStatus statusCode = responseEntity.getStatusCode(); // 获取响应码
   System.out.println(&quot;HTTP 响应状态：&quot; + statusCode);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;异常抛出之后，程序后面的代码就执行不到了，无法进行后面的代码执行。实际的业务开发中，有的时候我们更期望的结果是：不管你服务端是超时了还是服务不存在，我们都应该获得最终的请求结果（HTTP请求结果状态400、500），而不是获得一个抛出的异常。&lt;/p&gt;
&lt;h2 id=&quot;二、源码解析-默认实现&quot;&gt;二、源码解析-默认实现&lt;/h2&gt;
&lt;p&gt;首先我要说一个结论：RestTemplate请求结果异常是可以自定义处理的。在开始进行自定义的异常处理逻辑之前，我们有必要看一下异常处理的默认实现。也就是：为什么会产生上面小节提到的现象？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ResponseErrorHandler是RestTemplate请求结果的异常处理器接口
&lt;ul&gt;&lt;li&gt;接口的第一个方法hasError用于判断HttpResponse是否是异常响应（通过状态码）&lt;/li&gt;
&lt;li&gt;接口的第二个方法handleError用于处理异常响应结果（非200状态码段）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;DefaultResponseErrorHandler是ResponseErrorHandler的默认实现&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以我们就来看看DefaultResponseErrorHandler是如何来处理异常响应的？从HttpResponse解析出Http StatusCode，如果状态码StatusCode为null，就抛出UnknownHttpStatusCodeException异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200814071356877-1926354092.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果StatusCode存在，则解析出StatusCode的series，也就是状态码段（除了200段，其他全是异常状态码）,解析规则是StatusCode/100取整。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public enum Series {

   INFORMATIONAL(1),  // 1xx/100
   SUCCESSFUL(2),  // 2xx/100
   REDIRECTION(3), // 3xx/100
   CLIENT_ERROR(4), // 4xx/100   ,客户端异常
   SERVER_ERROR(5); // 5xx/100 ，服务端异常
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进一步针对客户端异常和服务端异常进行处理，处理的方法是抛出HttpClientErrorException。也就是第一小节出现的异常的原因&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200814071357392-336603051.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、resttemplate自定义异常处理&quot;&gt;三、RestTemplate自定义异常处理&lt;/h2&gt;
&lt;p&gt;所以我们要实现自定义异常，实现ResponseErrorHandler 接口就可以。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyRestErrorHandler implements ResponseErrorHandler {

    /**
     * 判断返回结果response是否是异常结果
     * 主要是去检查response 的HTTP Status
     * 仿造DefaultResponseErrorHandler实现即可
     */
    @Override
    public boolean hasError(ClientHttpResponse response) throws IOException {
        int rawStatusCode = response.getRawStatusCode();
        HttpStatus statusCode = HttpStatus.resolve(rawStatusCode);
        return (statusCode != null ? statusCode.isError(): hasError(rawStatusCode));
    }

    protected boolean hasError(int unknownStatusCode) {
        HttpStatus.Series series = HttpStatus.Series.resolve(unknownStatusCode);
        return (series == HttpStatus.Series.CLIENT_ERROR || series == HttpStatus.Series.SERVER_ERROR);
    }
 
    @Override
    public void handleError(ClientHttpResponse response) throws IOException {
        // 里面可以实现你自己遇到了Error进行合理的处理
        //TODO 将接口请求的异常信息持久化
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将MyRestErrorHandler 在RestTemplate实例化的时候进行注册。参考： &lt;a href=&quot;http://www.zimug.com/java/spring/%e7%b2%be%e8%ae%b2resttemplate%e7%ac%ac1%e7%af%87-%e5%9c%a8spring%e6%88%96%e9%9d%9espring%e7%8e%af%e5%a2%83%e4%b8%8b%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8/.html&quot;&gt;《精讲RestTemplate第1篇-在Spring或非Spring环境下如何使用》&lt;/a&gt; 和 &lt;a href=&quot;http://www.zimug.com/java/spring/%e7%b2%be%e8%ae%b2resttemplate%e7%ac%ac2%e7%af%87-%e5%a4%9a%e7%a7%8d%e5%ba%95%e5%b1%82http%e5%ae%a2%e6%88%b7%e7%ab%af%e7%b1%bb%e5%ba%93%e7%9a%84%e5%88%87%e6%8d%a2/.html&quot;&gt;《精讲RestTemplate第2篇-多种底层HTTP客户端类库的切换》&lt;/a&gt; 进行实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200814071357641-1046215111.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时再去执行第一小节中的示例代码，就不会抛出异常。而是得到一个HTTP Status 404的结果。我们可以根据这个结果，在程序中继续向下执行代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200814071357799-92504658.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Aug 2020 23:14:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本文是精讲RestTemplate第7篇，前篇的blog访问地址如下： 精讲RestTemplate第1篇-在Spring或非Spring环境下如何使用 精讲RestTemplate第2篇-多种底层H</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13500053.html</dc:identifier>
</item>
<item>
<title>Golang gRPC学习(03): grpc官方示例程序route_guide简析 - 九卷</title>
<link>http://www.cnblogs.com/jiujuan/p/13499903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiujuan/p/13499903.html</guid>
<description>&lt;p&gt;代码主要来源于grpc的官方examples代码：&lt;br/&gt;&lt;a href=&quot;https://github.com/grpc/grpc-go/tree/master/examples/route_guide&quot;&gt;route_guide&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/grpc/grpc-go/tree/master/examples/route_guide&quot;&gt;https://github.com/grpc/grpc-go/tree/master/examples/route_guide&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务定义-routeguide&quot;&gt;服务定义 RouteGuide&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;service RouteGuide {
  // A simple RPC.
  //
  // Obtains the feature at a given position.
  //
  // A feature with an empty name is returned if there's no feature at the given
  // position.
  rpc GetFeature(Point) returns (Feature) {}
  
  // A server-to-client streaming RPC.
  //
  // Obtains the Features available within the given Rectangle.  Results are
  // streamed rather than returned at once (e.g. in a response message with a
  // repeated field), as the rectangle may cover a large area and contain a
  // huge number of features.
  rpc ListFeatures(Rectangle) returns (stream Feature) {}
  
  // A client-to-server streaming RPC.
  //
  // Accepts a stream of Points on a route being traversed, returning a
  // RouteSummary when traversal is completed.
  rpc RecordRoute(stream Point) returns (RouteSummary) {}
  
  // A Bidirectional streaming RPC.
  //
  // Accepts a stream of RouteNotes sent while a route is being traversed,
  // while receiving other RouteNotes (e.g. from other users).
  rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;从定义里看：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rpc GetFeature(Point) returns (Feature) ： 定义最简单的RPC服务&lt;/p&gt;
&lt;p&gt;rpc ListFeatures(Rectangle) returns (stream Feature)： 带有 stream 的RPC服务，返回是stream&lt;/p&gt;
&lt;p&gt;rpc RecordRoute(stream Point) returns (RouteSummary)：带有 stream 的RPC服务，客户端是stream&lt;/p&gt;
&lt;p&gt;rpc RouteChat(stream RouteNote) returns (stream RouteNote)：2端都是stream的RPC服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rpc服务其他参数定义：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;message Point {
  int32 latitude = 1;
  int32 longitude = 2;
}

message Rectangle {
  // One corner of the rectangle.
  Point lo = 1;
  // The other corner of the rectangle.
  Point hi = 2;
}

message Feature {
  // The name of the feature.
  string name = 1;
  // The point where the feature is detected.
  Point location = 2;
}

message RouteNote {
  // The location from which the message is sent.
  Point location = 1;
  // The message to be sent.
  string message = 2;
}

message RouteSummary {
  // The number of points received.
  int32 point_count = 1;
  // The number of known features passed while traversing the route.
  int32 feature_count = 2;
  // The distance covered in metres.
  int32 distance = 3;
  // The duration of the traversal in seconds.
  int32 elapsed_time = 4;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;route_guidepbgo&quot;&gt;route_guide.pb.go&lt;/h2&gt;
&lt;p&gt;route_guide.pb.go，这个文件是干嘛的？&lt;br/&gt;这个是grpc自动生成的文件，里面有序列化，反序列化，执行是函数。&lt;/p&gt;
&lt;p&gt;先看看里面的接口，其中里面有2个主要接口：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.RouteGuideClient interface&lt;/li&gt;
&lt;li&gt;2.RouteGuideServer interface&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1.RouteGuideClient interface定义&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type RouteGuideClient interface {
    GetFeature(ctx context.Context, in *Point, opts ...grpc.CallOption) (*Feature, error)

    ListFeatures(ctx context.Context, in *Rectangle, opts ...grpc.CallOption) (RouteGuide_ListFeaturesClient, error)

    RecordRoute(ctx context.Context, opts ...grpc.CallOption) (RouteGuide_RecordRouteClient, error)

    RouteChat(ctx context.Context, opts ...grpc.CallOption) (RouteGuide_RouteChatClient, error)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仔细看看，这里面定义的一些方法，都是route_guide.proto文件里的service RouteGuide里的rpc方法，而且是一一对应的。&lt;br/&gt;这个就是client需要操作的方法，是grpc自动生成的。客户端请求这些方法来调用服务。&lt;/p&gt;
&lt;p&gt;从这里可以看出，grpc把proto中定义的服务映射为了一个interface，里面包含service中定义的rpc方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.RouteGuideServer interface&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type RouteGuideServer interface {
    GetFeature(context.Context, *Point) (*Feature, error)

    ListFeatures(*Rectangle, RouteGuide_ListFeaturesServer) error

    RecordRoute(RouteGuide_RecordRouteServer) error
 
    RouteChat(RouteGuide_RouteChatServer) error
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个也是与route_guide.proto文件里的service RouteGuide里的rpc方法是一一对应的。&lt;br/&gt;同理，这里跟上面的RouteGuideClient一样，把service映射成了interface。&lt;/p&gt;
&lt;h2 id=&quot;客户端请求clientgo&quot;&gt;客户端请求client.go&lt;/h2&gt;
&lt;p&gt;看看3个用stream发送数据的函数，客户端用stream，服务端用stream，2端都用stream，&lt;/p&gt;
&lt;h3 id=&quot;listfeaturesrectangle-returns-stream-feature-方法&quot;&gt;ListFeatures(Rectangle) returns (stream Feature) 方法&lt;/h3&gt;
&lt;p&gt;我们先看看 rpc ListFeatures(Rectangle) returns (stream Feature) {} 这个rpc方法，它返回的是一个 stream，在 &lt;code&gt;client.go&lt;/code&gt; 文件里它是用 &lt;code&gt;printFeatures()&lt;/code&gt; 这个函数来表示的，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// printFeatures lists all the features within the given bounding Rectangle.
func printFeatures(client pb.RouteGuideClient, rect *pb.Rectangle) {
    log.Printf(&quot;Looking for features within %v&quot;, rect)
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    //这里调用 ListFeatures(), rpc定义的方法，返回一个stream
    stream, err := client.ListFeatures(ctx, rect) 
    if err != nil {
        log.Fatalf(&quot;%v.ListFeatures(_) = _, %v&quot;, client, err)
    }
    
    for {//for循环不断的接收数据
        feature, err := stream.Recv()
        if err == io.EOF {
            break
        }
        if err != nil {
            log.Fatalf(&quot;%v.ListFeatures(_) = _, %v&quot;, client, err)
        }
        log.Println(feature)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;recordroutestream-point-returns-routesummary&quot;&gt;RecordRoute(stream Point) returns (RouteSummary)&lt;/h3&gt;
&lt;p&gt;这个 rpc RecordRoute(stream Point) returns (RouteSummary) 方法，通过stream发送消息，在 &lt;code&gt;client.go&lt;/code&gt; 文件里是 &lt;code&gt;runRecordRoute()&lt;/code&gt; 方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func runRecordRoute(client pb.RouteGuideClient) {
    // Create a random number of random points
    r := rand.New(rand.NewSource(time.Now().UnixNano()))
    pointCount := int(r.Int31n(100)) + 2 // Traverse at least two points
    var points []*pb.Point
    for i := 0; i &amp;lt; pointCount; i++ {
        points = append(points, randomPoint(r))
    }
    log.Printf(&quot;Traversing %d points.&quot;, len(points))
    
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    // 调用RecordRoute() 方法
    stream, err := client.RecordRoute(ctx)
    if err != nil {
        log.Fatalf(&quot;%v.RecordRoute(_) = _, %v&quot;, client, err)
    }
    for _, point := range points {
        // stream.Send() stream方式发送数据
        if err := stream.Send(point); err != nil {
            log.Fatalf(&quot;%v.Send(%v) = %v&quot;, stream, point, err)
        }
    }
    // 关闭
    reply, err := stream.CloseAndRecv()
    if err != nil {
        log.Fatalf(&quot;%v.CloseAndRecv() got error %v, want %v&quot;, stream, err, nil)
    }
    log.Printf(&quot;Route summary: %v&quot;, reply)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;routechatstream-routenote-returns-stream-routenote&quot;&gt;RouteChat(stream RouteNote) returns (stream RouteNote)&lt;/h3&gt;
&lt;p&gt;这个是 rpc RouteChat(stream RouteNote) returns (stream RouteNote)，2端都是操作stream，在 &lt;code&gt;client.go&lt;/code&gt; 里面 &lt;code&gt;runRouteChat()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func runRouteChat(client pb.RouteGuideClient) {
    notes := []*pb.RouteNote{
        {Location: &amp;amp;pb.Point{Latitude: 0, Longitude: 1}, Message: &quot;First message&quot;},
        {Location: &amp;amp;pb.Point{Latitude: 0, Longitude: 2}, Message: &quot;Second message&quot;},
        {Location: &amp;amp;pb.Point{Latitude: 0, Longitude: 3}, Message: &quot;Third message&quot;},
        {Location: &amp;amp;pb.Point{Latitude: 0, Longitude: 1}, Message: &quot;Fourth message&quot;},
        {Location: &amp;amp;pb.Point{Latitude: 0, Longitude: 2}, Message: &quot;Fifth message&quot;},
        {Location: &amp;amp;pb.Point{Latitude: 0, Longitude: 3}, Message: &quot;Sixth message&quot;},
    }
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    stream, err := client.RouteChat(ctx)
    if err != nil {
        log.Fatalf(&quot;%v.RouteChat(_) = _, %v&quot;, client, err)
    }
    waitc := make(chan struct{})
    go func() { //开一个协程来执行接收的动作
        for {
            in, err := stream.Recv() //stream方式接收
            if err == io.EOF {
                // read done.
                close(waitc) //读取完成close掉chan，给外面的waitc发送一个结束的信号表示协程工作已完成
                return
            }
            if err != nil {
                log.Fatalf(&quot;Failed to receive a note : %v&quot;, err)
            }
            log.Printf(&quot;Got message %s at point(%d, %d)&quot;, in.Message, in.Location.Latitude, in.Location.Longitude)
        }
    }()
    
    // 在main协程里面 strem 发送数据
    for _, note := range notes {
        if err := stream.Send(note); err != nil {
            log.Fatalf(&quot;Failed to send a note: %v&quot;, err)
        }
    }
    
    stream.CloseSend() // 关闭stream
    &amp;lt;-waitc //stream 接收完成通知退出协程，main协程也结束运行
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;服务端servergo&quot;&gt;服务端server.go&lt;/h2&gt;
&lt;p&gt;定义了一个struct，routeGuideServer struct，然后是操作这个struct，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type routeGuideServer struct {
    pb.UnimplementedRouteGuideServer
    savedFeatures []*pb.Feature // read-only after initialized
    mu         sync.Mutex // protects routeNotes
    routeNotes map[string][]*pb.RouteNote
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;rpc-getfeature&quot;&gt;rpc GetFeature()&lt;/h3&gt;
&lt;p&gt;这个rpc方法，客户端和服务端都不是stream方式发送，获取，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (s *routeGuideServer) GetFeature(ctx context.Context, point *pb.Point) (*pb.Feature, error) {
    for _, feature := range s.savedFeatures {
        if proto.Equal(feature.Location, point) {
            return feature, nil
        }
    }
    // No feature was found, return an unnamed feature
    return &amp;amp;pb.Feature{Location: point}, nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;里面有一个比较的函数 proto.Equal(a, b Message) bool，在 &lt;code&gt;protobuf/proto/equal.go&lt;/code&gt; 里，比较2值是否相等。&lt;/p&gt;
&lt;h3 id=&quot;rpc-listfeatures&quot;&gt;rpc ListFeatures()&lt;/h3&gt;
&lt;p&gt;rpc ListFeatures(Rectangle) returns (stream Feature)&lt;/p&gt;
&lt;p&gt;这个rpc方法返回是一个stream，也就是服务端发送是stream方式发送，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (s *routeGuideServer) ListFeatures(rect *pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer) error {
    for _, feature := range s.savedFeatures {
        if inRange(feature.Location, rect) {
           //stream 方式发送
            if err := stream.Send(feature); err != nil {
                return err
            }
        }
    }
    return nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;rpc-recordroute&quot;&gt;rpc RecordRoute&lt;/h3&gt;
&lt;p&gt;rpc RecordRoute(stream Point) returns (RouteSummary)&lt;/p&gt;
&lt;p&gt;客户端发送（请求服务端）的数据是一个stream，那服务端server接收肯定也要用stream，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (s *routeGuideServer) RecordRoute(stream pb.RouteGuide_RecordRouteServer) error {
    var pointCount, featureCount, distance int32
    var lastPoint *pb.Point
    startTime := time.Now()
    for {
        point, err := stream.Recv() //接收stream
        if err == io.EOF {
            endTime := time.Now()
            return stream.SendAndClose(&amp;amp;pb.RouteSummary{
                PointCount:   pointCount,
                FeatureCount: featureCount,
                Distance:     distance,
                ElapsedTime:  int32(endTime.Sub(startTime).Seconds()),
            })
        }
        if err != nil {
            return err
        }
        pointCount++
        for _, feature := range s.savedFeatures {
            if proto.Equal(feature.Location, point) {
                featureCount++
            }
        }
        if lastPoint != nil {
            distance += calcDistance(lastPoint, point)
        }
        lastPoint = point
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RecordRoute 函数的参数 &lt;code&gt;pb.RouteGuide_RecordRouteServer&lt;/code&gt; 是什么？&lt;br/&gt;它在 route_guide.pg.go 定义的是一个 interface，里面有SendAndClose(), Recv() 方法，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type RouteGuide_RecordRouteServer interface {
    SendAndClose(*RouteSummary) error
    Recv() (*Point, error)
    grpc.ServerStream
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;rpc-routechat&quot;&gt;rpc RouteChat&lt;/h3&gt;
&lt;p&gt;rpc RouteChat(stream RouteNote) returns (stream RouteNote)&lt;/p&gt;
&lt;p&gt;这个rpc方法，客户端和服务端都是stream发送，接收，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (s *routeGuideServer) RouteChat(stream pb.RouteGuide_RouteChatServer) error {
    for {
        in, err := stream.Recv() // stream接收
        if err == io.EOF {
            return nil
        }
        if err != nil {
            return err
        }
        key := serialize(in.Location)
        s.mu.Lock()
        s.routeNotes[key] = append(s.routeNotes[key], in)
        // Note: this copy prevents blocking other clients while serving this one.
        // We don't need to do a deep copy, because elements in the slice are
        // insert-only and never modified.
        rn := make([]*pb.RouteNote, len(s.routeNotes[key]))
        copy(rn, s.routeNotes[key])
        s.mu.Unlock()
        for _, note := range rn {
            if err := stream.Send(note); err != nil { //stream发送
                return err
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;newserver&quot;&gt;newServer&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// 运行服务端函数，返回一个struct，这个struct又实现了interface，
//所以main函数里可以直接调用 pb.RegisterRouteGuideServer(grpcServer, newServer())
func newServer() *routeGuideServer {
    s := &amp;amp;routeGuideServer{routeNotes: make(map[string][]*pb.RouteNote)}
    s.loadFeatures(*jsonDBFile)
    return s
}

func main() {
    flag.Parse()
    lis, err := net.Listen(&quot;tcp&quot;, fmt.Sprintf(&quot;localhost:%d&quot;, *port))
    if err != nil {
        log.Fatalf(&quot;failed to listen: %v&quot;, err)
    }
    var opts []grpc.ServerOption
    if *tls {
        if *certFile == &quot;&quot; {
            *certFile = testdata.Path(&quot;server1.pem&quot;)
        }
        if *keyFile == &quot;&quot; {
            *keyFile = testdata.Path(&quot;server1.key&quot;)
        }
        creds, err := credentials.NewServerTLSFromFile(*certFile, *keyFile)
        if err != nil {
            log.Fatalf(&quot;Failed to generate credentials %v&quot;, err)
        }
        opts = []grpc.ServerOption{grpc.Creds(creds)}
    }
    grpcServer := grpc.NewServer(opts...)
    pb.RegisterRouteGuideServer(grpcServer, newServer())
    grpcServer.Serve(lis)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;服务端一些辅助函数&quot;&gt;服务端一些辅助函数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;server.go&lt;/code&gt; 文件里面还有一些辅助函数：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.loadFeatures&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// 加载json形式的 features 数据，经纬度，名称
func (s *routeGuideServer) loadFeatures(filePath string)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面这种格式的数据，跟 &lt;code&gt;route_guide.proto&lt;/code&gt; 里 &lt;code&gt;message Feature&lt;/code&gt; 数据定义一致&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
&quot;location&quot;: {
        &quot;latitude&quot;: 407838351,
        &quot;longitude&quot;: -746143763
    },
    &quot;name&quot;: &quot;Patriots Path, Mendham, NJ 07945, USA&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.toRadians&lt;/strong&gt;&lt;br/&gt;计算弧度&lt;/p&gt;
&lt;p&gt;3.calcDistance&lt;br/&gt;计算距离&lt;/p&gt;
&lt;p&gt;4.inRange&lt;br/&gt;在范围内&lt;/p&gt;
&lt;p&gt;5.serialize&lt;br/&gt;序列化&lt;/p&gt;
&lt;h2 id=&quot;grpc-系列代码地址：&quot;&gt;&lt;strong&gt;gRPC 系列代码地址：&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 13 Aug 2020 17:08:00 +0000</pubDate>
<dc:creator>九卷</dc:creator>
<og:description>代码主要来源于grpc的官方examples代码： route_guide https://github.com/grpc/grpc-go/tree/master/examples/route_gui</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiujuan/p/13499903.html</dc:identifier>
</item>
<item>
<title>虚拟化技术之kvm基础 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13499801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13499801.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_200314035758kvm.png&quot; class=&quot;desc_img&quot;/&gt; kvm是Linux内核中的一个模块，而对于用户要操作Linux内核中的模块所提供的功能，必须在用户空间装上一个用户空间软件，通过系统调用的方式去操作；QEMU就是kvm在用户空间的管理功能，有点类似iptalbes是netfilter的管理工具；上面架构图上kvm的主要作用是提供 CPU 和内存的虚级化，以及客户机的 I/O拦截，Guest的部分I/O被KVM拦截后，交给QEMU处理；QEMU通过修改过的被KVM虚机使用的QEMU代码，运行在用户空间，提供硬件I/O虚拟化，通过IOCTL/dev/kvm设备和KVM交互，但是，KVM本身不执行任何硬件模拟，需要用户空间程序通过 /dev/kvm 接口设置一个客户机虚拟服务器的地址空间，向它提供模拟I/O，并将它的视频显示映射回宿主的显示屏&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;137.16254876463&quot;&gt;
&lt;p&gt;　　一、KVM简介&lt;/p&gt;
&lt;p&gt;　　KVM的全称是kernel base virtual machine（基于内核的虚拟机）是一个开源的系统虚拟化模块，自Linux 2.6.20之后集成在Linux的各个主要发行版本中。它使用Linux自身的调度器进行管理，所以相对于Xen，其核心源码很少。KVM已成为学术界的主流VMM之一。KVM的虚拟化需要硬件支持（如Inter VT技术或者AMD V技术)，是基于硬件的完全虚拟化。而Xen早期则是基于软件模拟的Para-Virtualization，新版本则是基于硬件支持的完全虚拟化。但Xen本身有自己的进程调度器，存储管理模块等，所以代码较为庞大。IBM文档：&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-using-kvm/&quot; target=&quot;_blank&quot;&gt;https://www.ibm.com/developerworks/cn/linux/l-using-kvm/&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;　　kvm架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200813221212956-1959742575.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：kvm是Linux内核中的一个模块，而对于用户要操作Linux内核中的模块所提供的功能，必须在用户空间装上一个用户空间软件，通过系统调用的方式去操作；QEMU就是kvm在用户空间的管理功能，有点类似iptalbes是netfilter的管理工具；上面架构图上kvm的主要作用是提供 CPU 和内存的虚级化，以及客户机的 I/O拦截，Guest的部分I/O被KVM拦截后，交给QEMU处理；QEMU通过修改过的被KVM虚机使用的QEMU代码，运行在用户空间，提供硬件I/O虚拟化，通过IOCTL/dev/kvm设备和KVM交互，但是，KVM本身不执行任何硬件模拟，需要用户空间程序通过 /dev/kvm 接口设置一个客户机虚拟服务器的地址空间，向它提供模拟I/O，并将它的视频显示映射回宿主的显示屏。&lt;/p&gt;
&lt;p&gt;　　二、KVM宿主机环境准备&lt;/p&gt;
&lt;p&gt;　　在使用KVM时，宿主机必须在硬件上支持虚拟化功能，如Inter VT技术或者AMD V技术；&lt;/p&gt;
&lt;p&gt;　　检查宿主机是否支持虚拟化功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# grep -E &quot;vmx|svm&quot; /proc/cpuinfo 
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：如上在宿主机上执行grep -E &quot;vmx|svm&quot; /proc/cpuinfo，如果没有过滤到任何有关vmx或者svm相关字符，那么说明该主机不支持虚拟化功能；&lt;/p&gt;
&lt;p&gt;　　在vmware workstation宿主机上开启虚拟化功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200813223430303-598432090.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：运行的虚拟机，必须要先关机，然后找到对应的虚拟机右键--&amp;gt;设置--&amp;gt;处理器--&amp;gt;把虚拟化inter VT-x/EPT或AMD-V/RVI(V)这一项打勾，然后点击确定开启虚拟机即可；&lt;/p&gt;
&lt;p&gt;　　验证：现在开启了虚拟化inter VT-x/EPT或AMD-V/RVI(V)，看看宿主机上是否能够过滤到vmx或svm的字符？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200813224911859-1443362060.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：如果硬件是inter 处理器过滤出来的是vmx，如果是AMD的过滤出来是svm；两者只要有一种即可；&lt;/p&gt;
&lt;p&gt;　　检查内核是否装载kvm模块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200813225241935-521585959.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：如果使用lsmod 没有过滤到kvm字样，说明宿主机没有装载该模块，装载方法modpro kvm即可；到此宿主机上的环境就检查完毕；接下来安装kvm用户空间管理工具；&lt;/p&gt;
&lt;p&gt;　　安装kvm在用户空间的管理工具&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# yum install qemu-kvm qemu-kvm-tools libvirt virt-manager virt-install 
Loaded plugins: fastestmirror
base                                                                               | 3.6 kB  00:00:00     
docker-ce-stable                                                                   | 3.5 kB  00:00:00     
epel                                                                               | 4.7 kB  00:00:00     
extras                                                                             | 2.9 kB  00:00:00     
updates                                                                            | 2.9 kB  00:00:00     
(1/2): epel/x86_64/updateinfo                                                      | 1.0 MB  00:00:00     
(2/2): epel/x86_64/primary_db                                                      | 6.9 MB  00:00:01     
Determining fastest mirrors
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package libvirt.x86_64 0:4.5.0-33.el7_8.1 will be installed
--&amp;gt; Processing Dependency: libvirt-libs = 4.5.0-33.el7_8.1 for package: libvirt-4.5.0-33.el7_8.1.x86_64
--&amp;gt; Processing Dependency: libvirt-daemon-driver-storage = 4.5.0-33.el7_8.1 for package: libvirt-4.5.0-33.el7_8.1.x86_64
--&amp;gt; Processing Dependency: libvirt-daemon-driver-secret = 4.5.0-33.el7_8.1 for package: libvirt-4.5.0-33.el7_8.1.x86_64
……省略部分内容……
 libxml2                                   x86_64     2.9.1-6.el7.4                     base        668 k
 pciutils-libs                             x86_64     3.5.1-3.el7                       base         46 k
 policycoreutils                           x86_64     2.5-34.el7                        base        917 k
 python-gobject-base                       x86_64     3.22.0-1.el7_4.1                  base        294 k
 selinux-policy-targeted                   noarch     3.13.1-266.el7_8.1                updates     7.0 M

Transaction Summary
==========================================================================================================
Install  5 Packages (+213 Dependent packages)
Upgrade  1 Package  (+ 16 Dependent packages)

Total download size: 95 M
Is this ok [y/d/N]: y
Downloading packages:
Delta RPMs disabled because /usr/bin/applydeltarpm not installed.
(1/235): at-spi2-core-2.28.0-1.el7.x86_64.rpm                                      | 158 kB  00:00:00     
(2/235): at-spi2-atk-2.26.2-1.el7.x86_64.rpm                                       |  81 kB  00:00:00     
(3/235): autogen-libopts-5.18-5.el7.x86_64.rpm                                     |  66 kB  00:00:00     
(4/235): boost-iostreams-1.53.0-28.el7.x86_64.rpm                                  |  61 kB  00:00:00     
(5/235): adwaita-cursor-theme-3.28.0-1.el7.noarch.rpm                              | 641 kB  00:00:00     
(6/235): augeas-libs-1.4.0-9.el7_8.1.x86_64.rpm                                    | 357 kB  00:00:00     
……省略部分内容……
  xkeyboard-config.noarch 0:2.24-1.el7                                                                    
  xml-common.noarch 0:0.6.3-39.el7                                                                        
  xorg-x11-server-utils.x86_64 0:7.7-20.el7                                                               
  xorg-x11-xauth.x86_64 1:1.0.9-1.el7                                                                     
  xorg-x11-xinit.x86_64 0:1.3.4-2.el7                                                                     
  yajl.x86_64 0:2.0.4-4.el7                                                                               

Updated:
  selinux-policy.noarch 0:3.13.1-266.el7_8.1                                                              

Dependency Updated:
  cyrus-sasl-lib.x86_64 0:2.1.26-23.el7             device-mapper.x86_64 7:1.02.164-7.el7_8.2             
  device-mapper-libs.x86_64 7:1.02.164-7.el7_8.2    freetype.x86_64 0:2.8-14.el7                          
  glib2.x86_64 0:2.56.1-5.el7                       libdrm.x86_64 0:2.4.97-2.el7                          
  libselinux.x86_64 0:2.5-15.el7                    libselinux-python.x86_64 0:2.5-15.el7                 
  libselinux-utils.x86_64 0:2.5-15.el7              libsemanage.x86_64 0:2.5-14.el7                       
  libsepol.x86_64 0:2.5-10.el7                      libxml2.x86_64 0:2.9.1-6.el7.4                        
  pciutils-libs.x86_64 0:3.5.1-3.el7                policycoreutils.x86_64 0:2.5-34.el7                   
  python-gobject-base.x86_64 0:3.22.0-1.el7_4.1     selinux-policy-targeted.noarch 0:3.13.1-266.el7_8.1   

Complete!
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动libvirtd&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:9a:db:d6 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.41/24 brd 192.168.0.255 scope global ens33
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe9a:dbd6/64 scope link 
       valid_lft forever preferred_lft forever
[root@node1 ~]# systemctl start libvirtd.service 
[root@node1 ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:9a:db:d6 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.41/24 brd 192.168.0.255 scope global ens33
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe9a:dbd6/64 scope link 
       valid_lft forever preferred_lft forever
3: virbr0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN qlen 1000
    link/ether 52:54:00:45:06:15 brd ff:ff:ff:ff:ff:ff
    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0
       valid_lft forever preferred_lft forever
4: virbr0-nic: &amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN qlen 1000
    link/ether 52:54:00:45:06:15 brd ff:ff:ff:ff:ff:ff
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：libvitrd是C/S架构，它是用于管理虚拟化平台的开源的API，后台程序和管理工具。它可以用于管理KVM、Xen、VMware ESX，QEMU和其他虚拟化技术；启动libvirtd后，它会在宿主机上创建virbr0-nic和virbr0两张网卡，其中virbr0是一个NAT网桥，virbr0-nic就桥接到virbr0上，默认virbr0的地址是192.168.122.1/24，如下所示；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200813232917589-1511531601.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　三、基于virtual manager管理工具创建虚拟机&lt;/p&gt;
&lt;p&gt;　　开启vrit-manager&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200813234446411-1023819138.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：要想使用virt-manager，必须要使用支持X11协议的转发的远程工具，windows上可以使用专业版本的xshell和mobaxterm软件；Linux上需要安装桌面即可；如果是mac 需要安装XQuartz；如上连接宿主机，然后执行virt-manager命令，就可以打开virtual manager图形管理工具；&lt;/p&gt;
&lt;p&gt;　　上传镜像到宿主机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200813235920765-1249421479.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建虚拟机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200813235822321-2030379916.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200814000013614-1616917592.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200814000044866-346405598.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200814000132728-498261.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200814000200544-1780323743.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200814000243477-486539311.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200814000327937-375441996.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这个根据自己需求来定义虚拟机的内存和cpu；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200814000444055-750120226.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这步是选择磁盘，如果没有提前在宿主机上创建好磁盘，可以直接在这里选择创建，如果创建的有磁盘，则这里选择即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200814000907335-1230544893.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：这一步是确定我们虚拟机的确认单和网络的选择，如果有多个网络，可以选择其中一种即可，然后点击finsh；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200814001049839-1768000098.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：到这一步就是安装操作系统了，安装完毕后，重启我们就完成了虚拟机的创建；后续步骤这里就不过多阐述了；安装windows的步骤和上面一模一样；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200814003647483-1888862731.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：安装好系统以后，我们就可以在这个界面上进行管理虚拟机，这里需要注意一点，如果宿主机没有打开核心转发功能，虚拟机是不能够正常上网的；到此基于virt-manager安装虚拟机就完成了；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 13 Aug 2020 16:57:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>一、KVM简介 KVM的全称是kernel base virtual machine（基于内核的虚拟机）是一个开源的系统虚拟化模块，自Linux 2.6.20之后集成在Linux的各个主要发行版本中。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13499801.html</dc:identifier>
</item>
<item>
<title>Spring Boot 教程 - MyBatis-Plus - Butterfly-Tri</title>
<link>http://www.cnblogs.com/Butterfly-Tri/p/13499564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Butterfly-Tri/p/13499564.html</guid>
<description>&lt;h2 id=&quot;1-mybatis-plus简介&quot;&gt;1. Mybatis-Plus简介&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/baomidou/mybatis-plus&quot;&gt;MyBatis-Plus&lt;/a&gt;（简称 MP）是一个 &lt;a href=&quot;http://www.mybatis.org/mybatis-3/&quot;&gt;MyBatis&lt;/a&gt; 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么说Mybatis-Plus是Mybatis的增强？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;mybatis作为一款轻量级的持久层框架实现了比较简单的操作数据库的能力，但是它是一个半ORM(对象关系映射)的持久层框架，因为它需要我们在XML文件中写SQL语句，不能完全专注于业务逻辑，即是它后来做了一些改进，有了逆向工程，有了example类，但依旧改变不了他是一个半ORM框架的事实。MyBatis-Plus作为mybatis的增强版，极大改善了mybatis的尴尬处境(其实并不尴尬，我还是非常喜欢用mybatis的)。&lt;/p&gt;
&lt;p&gt;接下来进入正题了，Mybatis-plus框架他在Mybatis原有的基础之上增加了一系列的简单易用的javaAPI，非常的好用和牛逼，国人开发，必须要使劲的吹一下😁。Mybatis-Plus官方有这么一句话：&lt;strong&gt;为简化开发而生&lt;/strong&gt;。这句话我觉得非常的好，的确，简化了我们的开发，官方还有这么三句话：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;润物无声&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;效率至上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只需简单配置，即可快速进行 CRUD 操作，从而节省大量时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;丰富功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;热加载、代码生成、分页、性能分析等功能一应俱全。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的这三句话其实就是Mybatis-plus的特点，他的确没有改变mybatis的功能，只在它的基础之上进行了一些增强，不需要example类，提供了Wrapper类，还提供了很多简单的api操作数据库。话不多说直接撸代码。对于他的底层实现，我不说大家都知道，动态代理咯，具体实现大家可以自行查阅相关资料，在这个系列中只带领大家学习和基本使用，各位大佬们如果觉得博主写的还算不错，给个关注呗，奥利给！&lt;/p&gt;
&lt;h2 id=&quot;2-mybatis-plus的使用&quot;&gt;2. Mybatis-Plus的使用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;2.1 引入依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;pom.xml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--springboot父工程--&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.2.2.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;!--mybatis-plus组件--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.3.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--spring-web组件--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--mysql数据库连接驱动--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.0.18&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--lombok组件--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.18.10&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.2 配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;application.yml&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;butterflytri:
  databaseurl-port: 127.0.0.1:3306 # 数据库端口
  database-name: student_db # 数据库名
server:
  port: 8080 # 应用端口
  servlet:
    context-path: /butterflytri # 应用映射
spring:
  application:
    name: mybatis-plus # 应用名称
  datasource:
    url: jdbc:mysql://${butterflytri.databaseurl-port}/${butterflytri.database-name}?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useJDBCCompliantTimezoneShift=true&amp;amp;useLegacyDatetimeCode=false&amp;amp;serverTimezone=UTC
    driver-class-name: com.mysql.jdbc.Driver
    username: root
    password: root
mybatis-plus: # mybatis-plus配置
  mapper-locations: classpath:com/butterflytri/mapper/*Mapper.xml # mapper映射包扫描
  type-aliases-package: com.butterflytri.entity # entity别名
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mybatis-plus只需要这么一个配置文件就可以了，不需要其他的，官方也说了，只增强mybatis不修改它，所以我只会演示plus部分，即增强优化的部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3 正式代码部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们看下启动类：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MybatisPlusApplication.java&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.butterflytri;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * @author: WJF
 * @date: 2020/6/23
 * @description: MybatisPlusApplication
 */
@SpringBootApplication
/**
 * xmlMapper包扫描，与yml中效果相同。
 */
@MapperScan(&quot;com/butterflytri/mapper&quot;)
public class MybatisPlusApplication {

    public static void main(String[] args) {
        SpringApplication.run(MybatisPlusApplication.class);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动类中就写了一个Mapper的包扫描，说过的Mybatis-Plus只增强Mybatis，不改变它，所以写Xml也是完全欧克的。&lt;/p&gt;
&lt;p&gt;然后我们看实体类和数据库字段的映射关系，先上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.butterflytri.entity;

import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.io.Serializable;

/**
 * @author: WJF
 * @date: 2020/5/16
 * @description: Student
 */

@ToString
@Getter
@Setter
/**
 * '@TableName'：此注解将表名和实体类映射起来，不写则默认以实体类名为表名进行数据库操作。
 * '@TableId'：此注解将声明的实体属性作为数据库表的主键字段，还有很多主键实现策咯，查看注解属性{@link TableId#type()}。
 * '@TableField'：此注解将表字段(非主键)和实体类属性映射起来，不写则默认以实体类属性名为表字段名进行数据库操作。
 */
@TableName(&quot;t_student&quot;)
public class Student implements Serializable {

    @TableId(&quot;ID&quot;)
    private Long id;

    @TableField(&quot;STUDENT_NAME&quot;)
    private String studentName;

    @TableField(&quot;STUDENT_NO&quot;)
    private String studentNo;

    @TableField(&quot;SEX&quot;)
    private String sex;

    @TableField(&quot;AGE&quot;)
    private Integer age;

    @TableField(&quot;CLASS&quot;)
    private String clazz;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实体类和表名的映射就是如此的简单，如果实体类类名和表名一样，字段名和属性名一样就不用写这些注解。&lt;/p&gt;
&lt;p&gt;接下来我们看下Mapper层代码，这里继承了BaseMapper接口，就已经获取了基本的增删改查方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.butterflytri.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.butterflytri.entity.Student;
import org.apache.ibatis.annotations.Mapper;

import java.util.List;

/**
 * @author: WJF
 * @date: 2020/5/16
 * @description: StudentMapper
 */

/**
 * 此处'StudentMapper'继承了'BaseMapper&amp;lt;T&amp;gt;'接口，就拥有了mybatis-plus提供的公共基础的CRUD方法。
 */
@Mapper
public interface StudentMapper extends BaseMapper&amp;lt;Student&amp;gt; {

    /**
     * 查询所有学生信息
     * @return List&amp;lt;Student&amp;gt;
     */
    List&amp;lt;Student&amp;gt; findAll();

    /**
     * 通过id查询学生信息
     * @param id：学生id
     * @return Student
     */
    Student findOne(Long id);

    /**
     * 通过学号查询学生信息
     * @param studentNo：学生学号
     * @return Student
     */
    Student findByStudentNo(String studentNo);


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们看看service层代码：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StudentService&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.butterflytri.service;

import com.butterflytri.entity.Student;

import java.util.List;

/**
 * @author: WJF
 * @date: 2020/6/23
 * @description: StudentService
 */

public interface StudentService {

    /**
     * 通过id查询某个学生的信息(BaseMapper&amp;lt;T&amp;gt;中的方法)
     * @param id: 学生id
     * @return Student
     */
    public Student selectById(Long id);

    /**
     * 通过id查询某个学生的信息(通过xmlMapper实现)
     * @param id: 学生id
     * @return Student
     */
    public Student findById(Long id);

    /**
     * 保存一个学生对象(BaseMapper&amp;lt;T&amp;gt;中的方法)
     * @param student
     */
    public void insert(Student student);

    /**
     * 查询性别为sex，年龄大于age的学生(普通的Wrapper)
     * @param sex: 性别
     * @param age: 年龄
     * @return 学生list
     */
    public List&amp;lt;Student&amp;gt; findByWrapper(String sex, Integer age);

    /**
     * 查询性别为sex，年龄大于age的学生(Lambda形式的Wrapper)
     * @param sex: 性别
     * @param age: 年龄
     * @return 学生list
     */
    public List&amp;lt;Student&amp;gt; findByWrapperLambda(String sex, Integer age);

    /**
     * 更新学生信息(Wrapper形式)
     * @param student: 需要更新的学生实体
     */
    public void updateByWrapper(Student student);

    /**
     * 更新学生信息(BaseMapper&amp;lt;T&amp;gt;中的方法)
     * @param student: 需要更新的学生实体
     */
    public void updateById(Student student);

    /**
     * 更新学生信息(Lambda形式的Wrapper)
     * @param student: 需要更新的学生实体
     */
    public void updateByWrapperLambda(Student student);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;StudentServiceImpl&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.butterflytri.service.impl;

import com.baomidou.mybatisplus.core.conditions.Wrapper;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;
import com.baomidou.mybatisplus.core.toolkit.Wrappers;
import com.butterflytri.entity.Student;
import com.butterflytri.mapper.StudentMapper;
import com.butterflytri.service.StudentService;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.util.List;

/**
 * @author: WJF
 * @date: 2020/6/23
 * @description: StudentServiceImpl
 */
@Service
public class StudentServiceImpl implements StudentService {

    @Resource
    private StudentMapper studentMapper;

    @Override
    public Student selectById(Long id) {
        return studentMapper.selectById(id);
    }

    @Override
    public Student findById(Long id) {
        return studentMapper.findOne(id);
    }

    @Override
    public void insert(Student student) {
        studentMapper.insert(student);
    }

    @Override
    public List&amp;lt;Student&amp;gt; findByWrapper(String sex, Integer age) {
        QueryWrapper&amp;lt;Student&amp;gt; queryWrapper = new QueryWrapper&amp;lt;&amp;gt;();
        queryWrapper.eq(&quot;SEX&quot;, sex);
        queryWrapper.gt(&quot;AGE&quot;, age);
        return studentMapper.selectList(queryWrapper);
    }

    @Override
    public List&amp;lt;Student&amp;gt; findByWrapperLambda(String sex, Integer age) {
        LambdaQueryWrapper&amp;lt;Student&amp;gt; queryWrapper = Wrappers.&amp;lt;Student&amp;gt;lambdaQuery().eq(Student::getSex, sex).gt(Student::getAge, age);
        return studentMapper.selectList(queryWrapper);
    }

    @Override
    public void updateByWrapper(Student student) {
        UpdateWrapper&amp;lt;Student&amp;gt; updateWrapper = new UpdateWrapper&amp;lt;&amp;gt;();
        updateWrapper.set(&quot;ID&quot;, student.getId());
        studentMapper.update(student, updateWrapper);
    }

    @Override
    public void updateById(Student student) {
        studentMapper.updateById(student);
    }

    @Override
    public void updateByWrapperLambda(Student student) {
        LambdaUpdateWrapper&amp;lt;Student&amp;gt; updateWrapper = Wrappers.&amp;lt;Student&amp;gt;lambdaUpdate().set(Student::getId, student.getId());
        studentMapper.update(student, updateWrapper);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;service层的方法都很简单，有通过刚刚继承的BaseMapper中的方法，但是我们还看到了一个类叫Wrapper，这个类是条件构造器，可以通过这个类实现比较复杂的查询，有直接通过字段名称去查询的，也有通过属性和字段名映射的lambda方式去查询数据库，总之就是很简单，也很好理解这些API，但是请记住，Wrapper很重，不是一个轻量级的东西，不要将这个对象在服务间进行传递，效率很低。请将条件放在DTO中传递到service层代码中，在service代码中创建Wrapper类进行查询。&lt;/p&gt;
&lt;p&gt;CRUD的结果我就不展示了。然后附上Mybatis-Plus官网地址：&lt;a href=&quot;https://mybatis.plus/&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-项目地址&quot;&gt;3. 项目地址&lt;/h2&gt;
&lt;p&gt;本项目传送门：&lt;/p&gt;
&lt;p&gt;此教程会一直更新下去，觉得博主写的可以的话，关注一下，也可以更方便下次来学习。&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Thu, 13 Aug 2020 15:03:00 +0000</pubDate>
<dc:creator>Butterfly-Tri</dc:creator>
<og:description>1. Mybatis-Plus简介 MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 为什么说Myba</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Butterfly-Tri/p/13499564.html</dc:identifier>
</item>
<item>
<title>【Spring注解驱动开发】你还不会使用@Resource和@Inject注解？那你就out了！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13499393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13499393.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;7.8907721280603&quot;&gt;
&lt;p&gt;我在 &lt;strong&gt;冰河技术&lt;/strong&gt; 微信公众号中发表的《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MzE1NTIzNA==&amp;amp;mid=2247486002&amp;amp;idx=1&amp;amp;sn=9e42ec6586363d6ab1e61beb14ee3322&amp;amp;chksm=cee515fff9929ce951a597f0cdb0bb04a615aef1287cac954645cdfd551518c0169350cd846e&amp;amp;token=1511192793&amp;amp;lang=zh_CN#rd&quot;&gt;【Spring注解驱动开发】使用@Autowired@Qualifier@Primary三大注解自动装配组件，你会了吗？&lt;/a&gt;》一文中，介绍了如何使用@Autowired、@Qualifier和@Primary注解自动装配Spring组件。那除了这三个注解以外，还有没有其他的注解可以自动装配组件呢？那必须有啊！今天，我们就一起说说@Resource注解和@Inject注解。&lt;/p&gt;
&lt;p&gt;关注 &lt;strong&gt;冰河技术&lt;/strong&gt; 微信公众号，回复 “Spring注解”关键字领取源码工程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;resource注解&quot;&gt;@Resource注解&lt;/h2&gt;
&lt;p&gt;@Resource（这个注解属于J2EE的，JSR250），默认安照名称进行装配，名称可以通过name属性进行指定， 如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。&lt;/p&gt;
&lt;p&gt;@Resource注解的源码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package javax.annotation;
import java.lang.annotation.*;
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.*;
@Target({TYPE, FIELD, METHOD})
@Retention(RUNTIME)
public @interface Resource {
    String name() default &quot;&quot;;
    String lookup() default &quot;&quot;;
    Class&amp;lt;?&amp;gt; type() default java.lang.Object.class;
    enum AuthenticationType {
            CONTAINER,
            APPLICATION
    }
    AuthenticationType authenticationType() default AuthenticationType.CONTAINER;
    boolean shareable() default true;
    String mappedName() default &quot;&quot;;
    String description() default &quot;&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;inject注解&quot;&gt;@Inject注解&lt;/h2&gt;
&lt;p&gt;@Inject注解（JSR330）默认是根据参数名去寻找bean注入，支持spring的@Primary注解优先注入，@Inject注解可以增加@Named注解指定注入的bean。&lt;/p&gt;
&lt;p&gt;@Inject注解的源码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package javax.inject;
import java.lang.annotation.Target;
import java.lang.annotation.Retention;
import java.lang.annotation.Documented;
import static java.lang.annotation.RetentionPolicy.RUNTIME;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
@Target({ METHOD, CONSTRUCTOR, FIELD })
@Retention(RUNTIME)
@Documented
public @interface Inject {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：要想使用@Inject注解，需要在项目的pom.xml文件中添加如下依赖。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.inject&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javax.inject&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;项目案例&quot;&gt;项目案例&lt;/h2&gt;
&lt;h3 id=&quot;测试resource注解&quot;&gt;测试@Resource注解&lt;/h3&gt;
&lt;p&gt;首先，我们将项目中的PersonService类标注在personDao字段上的@Autowired注解和@Qualifier注解注释掉，然后添加@Resource注解，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//@Qualifier(&quot;personDao&quot;)
//@Autowired(required = false)
@Resource
private PersonDao personDao;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们运行AutowiredTest类的testAutowired01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PersonService{personDao=PersonDao{remark='1'}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，使用@Resource注解也能够自动装配组件，只不过此时自动装配的是remark为1的personDao。而不是我们在AutowiredConfig类中配置的优先装配的remark为2的personDao。AutowiredConfig类中配置的remark为2的personDao如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Primary
@Bean(&quot;personDao2&quot;)
public PersonDao personDao(){
    PersonDao personDao = new PersonDao();
    personDao.setRemark(&quot;2&quot;);
    return personDao;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在使用@Resource注解时，可以通过@Resource注解的name属性显示指定要装配的组件的名称。例如，我们要想装配remark为2的personDao，只需要为@Resource注解添加 &lt;code&gt;name=&quot;personDao2&quot;&lt;/code&gt;属性即可。如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//@Qualifier(&quot;personDao&quot;)
//@Autowired(required = false)
@Resource(name = &quot;personDao2&quot;)
private PersonDao personDao;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们再次运行AutowiredTest类的testAutowired01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PersonService{personDao=PersonDao{remark='2'}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，此时输出了remark为2的personDao，说明@Resource注解可以通过name属性显示指定要装配的bean。&lt;/p&gt;
&lt;h3 id=&quot;测试inject注解&quot;&gt;测试@Inject注解&lt;/h3&gt;
&lt;p&gt;在PersonService类中，将@Resource注解注释掉，添加@Inject注解，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//@Qualifier(&quot;personDao&quot;)
//@Autowired(required = false)
//@Resource(name = &quot;personDao2&quot;)
@Inject
private PersonDao personDao;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改完毕后，我们运行AutowiredTest类的testAutowired01()方法，输出的结果信息如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;PersonService{personDao=PersonDao{remark='2'}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，使用@Inject注解默认输出的是remark为2的personDao。这是因为@Inject注解和@Autowired注解一样，默认优先装配使用了@Primary注解标注的组件。&lt;/p&gt;
&lt;h2 id=&quot;resource和inject注解与autowired注解的区别&quot;&gt;@Resource和@Inject注解与@Autowired注解的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;不同点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Autowired是spring专有注解，@Resource是java中&lt;strong&gt;JSR250中的规范&lt;/strong&gt;，@Inject是java中&lt;strong&gt;JSR330中的规范&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;@Autowired支持参数required=false，@Resource，@Inject都不支持&lt;/li&gt;
&lt;li&gt;@Autowired，和@Inject支持@Primary注解优先注入，@Resource不支持&lt;/li&gt;
&lt;li&gt;@Autowired通过@Qualifier指定注入特定bean,@Resource可以通过参数name指定注入bean，@Inject需要@Named注解指定注入bean&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;相同点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;三种注解都可以实现bean的注入。&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，后台回复 “&lt;strong&gt;设计模式&lt;/strong&gt;” 关键字领取《&lt;strong&gt;深入浅出Java 23种设计模式&lt;/strong&gt;》PDF文档。回复“&lt;strong&gt;Java8&lt;/strong&gt;”关键字领取《&lt;strong&gt;Java8新特性教程&lt;/strong&gt;》PDF文档。回复“&lt;strong&gt;限流&lt;/strong&gt;”关键字获取《&lt;strong&gt;亿级流量下的分布式限流解决方案&lt;/strong&gt;》PDF文档，三本PDF均是由冰河原创并整理的超硬核教程，面试必备！！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，今天就聊到这儿吧！别忘了点个赞，给个在看和转发，让更多的人看到，一起学习，一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你觉得冰河写的还不错，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200716220443647.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Aug 2020 14:41:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 我在 冰河技术 微信公众号中发表的《【Spring注解驱动开发】使用@Autowired@Qualifier@Primary三大注解自动装配组件，你会了吗？》一文中，介绍了如何使用@Auto</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13499393.html</dc:identifier>
</item>
<item>
<title>一口气搞懂「文件系统」，就靠这 25 张图了 - 小林coding</title>
<link>http://www.cnblogs.com/xiaolincoding/p/13499209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaolincoding/p/13499209.html</guid>
<description>&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%AF%8F%E6%97%A5%E8%8B%B1%E8%AF%AD8-9.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;hr/&gt;&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;不多 BB，直接上「硬菜」。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E6%8F%90%E7%BA%B2.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;hr/&gt;&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;文件系统的基本组成&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。&lt;/p&gt;
&lt;p&gt;文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。&lt;/p&gt;
&lt;p&gt;Linux 最经典的一句话是：「&lt;strong&gt;一切皆文件&lt;/strong&gt;」，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。&lt;/p&gt;
&lt;p&gt;Linux 文件系统会为每个文件分配两个数据结构：&lt;strong&gt;索引节点（&lt;em&gt;index node&lt;/em&gt;）和目录项（&lt;em&gt;directory entry&lt;/em&gt;）&lt;/strong&gt;，它们主要用来记录文件的元信息和目录层次结构。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;索引节点，也就是 &lt;em&gt;inode&lt;/em&gt;，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、&lt;strong&gt;数据在磁盘的位置&lt;/strong&gt;等等。索引节点是文件的&lt;strong&gt;唯一&lt;/strong&gt;标识，它们之间一一对应，也同样都会被存储在硬盘中，所以&lt;strong&gt;索引节点同样占用磁盘空间&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;目录项，也就是 &lt;em&gt;dentry&lt;/em&gt;，用来记录文件的名字、&lt;strong&gt;索引节点指针&lt;/strong&gt;以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，&lt;strong&gt;目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。&lt;/p&gt;
&lt;p&gt;注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;目录项和目录是一个东西吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。&lt;/p&gt;
&lt;p&gt;如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。&lt;/p&gt;
&lt;p&gt;注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那文件数据是如何存储在磁盘的呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;磁盘读写的最小单位是&lt;strong&gt;扇区&lt;/strong&gt;，扇区的大小只有 &lt;code&gt;512B&lt;/code&gt; 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。&lt;/p&gt;
&lt;p&gt;所以，文件系统把多个扇区组成了一个&lt;strong&gt;逻辑块&lt;/strong&gt;，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 &lt;code&gt;4KB&lt;/code&gt;，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。&lt;/p&gt;
&lt;p&gt;以上就是索引节点、目录项以及文件数据的关系，下面这个图就很好的展示了它们之间的关系：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%9B%AE%E5%BD%95%E9%A1%B9+%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9+%E8%B6%85%E7%BA%A7%E5%9D%97+%E6%95%B0%E6%8D%AE%E5%9D%97%20(1).png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中。&lt;/p&gt;
&lt;p&gt;另外，磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;超级块&lt;/em&gt;，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;索引节点区&lt;/em&gt;，用来存储索引节点；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;数据块区&lt;/em&gt;，用来存储文件或目录数据；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;超级块：当文件系统挂载时进入内存；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;索引节点区：当文件被访问时进入内存；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;虚拟文件系统&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;文件系统的种类众多，而操作系统希望&lt;strong&gt;对用户提供一个统一的接口&lt;/strong&gt;，于是在用户层与文件系统层引入了中间层，这个中间层就称为&lt;strong&gt;虚拟文件系统（&lt;em&gt;Virtual File System，VFS&lt;/em&gt;）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。&lt;/p&gt;
&lt;p&gt;在 Linux 文件系统中，用户空间、系统调用、虚拟机文件系统、缓存、文件系统以及存储之间的关系如下图：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;Linux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;磁盘的文件系统&lt;/em&gt;，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;内存的文件系统&lt;/em&gt;，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 &lt;code&gt;/proc&lt;/code&gt; 和 &lt;code&gt;/sys&lt;/code&gt; 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据数据。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;网络的文件系统&lt;/em&gt;，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h-4&quot;&gt;&lt;span&gt;文件的使用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们从用户角度来看文件的话，就是我们要怎么使用文件？首先，我们得通过系统调用来打开一个文件。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%86%99%E5%88%B0%E7%A3%81%E7%9B%98%E8%BF%87%E7%A8%8B.png&quot; alt=&quot;write 的过程&quot; title=&quot;write 的过程&quot;/&gt;write 的过程
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;fd = open(name, flag); # 打开文件&lt;br/&gt;...&lt;br/&gt;write(fd,...);         # 写数据&lt;br/&gt;...&lt;br/&gt;close(fd);             # 关闭文件&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面简单的代码是读取一个文件的过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先用 &lt;code&gt;open&lt;/code&gt; 系统调用打开文件，&lt;code&gt;open&lt;/code&gt; 的参数中包含文件的路径名和文件名。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;write&lt;/code&gt; 写数据，其中 &lt;code&gt;write&lt;/code&gt; 使用 &lt;code&gt;open&lt;/code&gt; 所返回的&lt;strong&gt;文件描述符&lt;/strong&gt;，并不使用文件名作为参数。&lt;/li&gt;
&lt;li&gt;使用完文件后，要用 &lt;code&gt;close&lt;/code&gt; 系统调用关闭文件，避免资源的泄露。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「&lt;strong&gt;文件描述符&lt;/strong&gt;」，所以说文件描述符是打开文件的标识。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E8%A1%A8.png&quot; alt=&quot;打开文件表&quot; title=&quot;打开文件表&quot;/&gt;打开文件表
&lt;p&gt;操作系统在打开文件表中维护着打开文件的状态和信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在用户视角里，文件就是一个持久化的数据结构，但操作系统并不会关心你想存在磁盘上的任何的数据结构，操作系统的视角是如何把文件数据和磁盘块对应起来。&lt;/p&gt;
&lt;p&gt;所以，用户和操作系统对文件的读写操作是有差异的，用户习惯以字节的方式读写文件，而操作系统则是以数据块来读写文件，那屏蔽掉这种差异的工作就是文件系统了。&lt;/p&gt;
&lt;p&gt;我们来分别看一下，读文件和写文件的过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以说，&lt;strong&gt;文件系统的基本操作单位是数据块&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h-5&quot;&gt;&lt;span&gt;文件的存储&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;连续空间存放方式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;非连续空间存放方式&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，非连续空间存放方式又可以分为「链表方式」和「索引方式」。&lt;/p&gt;
&lt;p&gt;不同的存储方式，有各自的特点，重点是要分析它们的存储效率和读写性能，接下来分别对每种存储方式说一下。&lt;/p&gt;
&lt;h4 id=&quot;h-6&quot;&gt;&lt;span&gt;连续空间存放方式&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;连续空间存放方式顾名思义，&lt;strong&gt;文件存放在磁盘「连续的」物理空间中&lt;/strong&gt;。这种模式下，文件的数据都是紧密相连，&lt;strong&gt;读写效率很高&lt;/strong&gt;，因为一次磁盘寻道就可以读出整个文件。&lt;/p&gt;
&lt;p&gt;使用连续存放的方式有一个前提，必须先知道一个文件的大小，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;文件头里需要指定「起始块的位置」和「长度」&lt;/strong&gt;，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间。&lt;/p&gt;
&lt;p&gt;注意，此处说的文件头，就类似于 Linux 的 inode。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F.png&quot; alt=&quot;连续空间存放方式&quot; title=&quot;连续空间存放方式&quot;/&gt;连续空间存放方式
&lt;p&gt;连续空间存放的方式虽然读写效率高，&lt;strong&gt;但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如下图，如果文件 B 被删除，磁盘上就留下一块空缺，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺，但却小于空缺大小之和，则虽然磁盘上有足够的空缺，但该文件还是不能存放。当然了，我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87.png&quot; alt=&quot;磁盘碎片&quot; title=&quot;磁盘碎片&quot;/&gt;磁盘碎片
&lt;p&gt;另外一个缺陷是文件长度扩展不方便，例如上图中的文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是挪动的方式，前面也说了，这种方式效率是非常低的。&lt;/p&gt;
&lt;p&gt;那么有没有更好的方式来解决上面的问题呢？答案当然有，既然连续空间存放的方式不太行，那么我们就改变存放的方式，使用非连续空间存放方式来解决这些缺陷。&lt;/p&gt;
&lt;h4 id=&quot;h-7&quot;&gt;&lt;span&gt;非连续空间存放方式&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;非连续空间存放方式分为「链表方式」和「索引方式」。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们先来看看链表的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链表的方式存放是&lt;strong&gt;离散的，不用连续的&lt;/strong&gt;，于是就可以&lt;strong&gt;消除磁盘碎片&lt;/strong&gt;，可大大提高磁盘空间的利用率，同时&lt;strong&gt;文件的长度可以动态扩展&lt;/strong&gt;。根据实现的方式的不同，链表可分为「&lt;strong&gt;隐式链表&lt;/strong&gt;」和「&lt;strong&gt;显式链接&lt;/strong&gt;」两种形式。&lt;/p&gt;
&lt;p&gt;文件要以「&lt;strong&gt;隐式链表&lt;/strong&gt;」的方式存放的话，&lt;strong&gt;实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置&lt;/strong&gt;，这样一个数据块连着一个数据块，从链头开是就可以顺着指针找到所有的数据块，所以存放的方式可以是不连续的。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E9%93%BE%E8%A1%A8%E6%96%B9%E5%BC%8F.png&quot; alt=&quot;隐式链表&quot; title=&quot;隐式链表&quot;/&gt;隐式链表
&lt;p&gt;隐式链表的存放方式的&lt;strong&gt;缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间&lt;/strong&gt;。隐式链接分配的&lt;strong&gt;稳定性较差&lt;/strong&gt;，系统在运行过程中由于软件或者硬件错误&lt;strong&gt;导致链表中的指针丢失或损坏，会导致文件数据的丢失。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足。那么，这种实现方式是「&lt;strong&gt;显式链接&lt;/strong&gt;」，它指&lt;strong&gt;把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中&lt;/strong&gt;，该表在整个磁盘仅设置一张，&lt;strong&gt;每个表项中存放链接指针，指向下一个数据块号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于显式链接的工作方式，我们举个例子，文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，文件 B 依次使用了磁盘块 6、3、11 和 14 。利用下图中的表，可以从第 4 块开始，顺着链走到最后，找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找出文件 B 的全部磁盘块。最后，这两个链都以一个不属于有效磁盘编号的特殊标记（如 -1 ）结束。内存中的这样一个表格称为&lt;strong&gt;文件分配表（&lt;em&gt;File Allocation Table，FAT&lt;/em&gt;）&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E8%A1%A8.png&quot; alt=&quot;显式链接&quot; title=&quot;显式链接&quot;/&gt;显式链接
&lt;p&gt;由于查找记录的过程是在内存中进行的，因而不仅显著地&lt;strong&gt;提高了检索速度&lt;/strong&gt;，而且&lt;strong&gt;大大减少了访问磁盘的次数&lt;/strong&gt;。但也正是整个表都存放在内存中的关系，它的主要的缺点是&lt;strong&gt;不适用于大磁盘&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如，对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 2 亿项，每一项对应于这 2 亿个磁盘块中的一个块，每项如果需要 4 个字节，那这张表要占用 800MB 内存，很显然 FAT 方案对于大磁盘而言不太合适。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;接下来，我们来看看索引的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问（FAT除外），索引的方式可以解决这个问题。&lt;/p&gt;
&lt;p&gt;索引的实现是为每个文件创建一个「&lt;strong&gt;索引数据块&lt;/strong&gt;」，里面存放的是&lt;strong&gt;指向文件数据块的指针列表&lt;/strong&gt;，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。&lt;/p&gt;
&lt;p&gt;另外，&lt;strong&gt;文件头需要包含指向「索引数据块」的指针&lt;/strong&gt;，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。&lt;/p&gt;
&lt;p&gt;创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.png&quot; alt=&quot;索引的方式&quot; title=&quot;索引的方式&quot;/&gt;索引的方式
&lt;p&gt;索引的方式优点在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;文件的创建、增大、缩小很方便；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不会有碎片的问题；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持顺序读写和随机读写；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以缺陷之一就是存储索引带来的开销。&lt;/p&gt;
&lt;p&gt;如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过组合的方式，来处理大文件的存。&lt;/p&gt;
&lt;p&gt;先来看看链表 + 索引的组合，这种组合称为「&lt;strong&gt;链式索引块&lt;/strong&gt;」，它的实现方式是&lt;strong&gt;在索引数据块留出一个存放下一个索引数据块的指针&lt;/strong&gt;，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%93%BE%E5%BC%8F%E7%B4%A2%E5%BC%95%E5%9D%97.png&quot; alt=&quot;链式索引块&quot; title=&quot;链式索引块&quot;/&gt;链式索引块
&lt;p&gt;还有另外一种组合方式是索引 + 索引的方式，这种组合称为「&lt;strong&gt;多级索引块&lt;/strong&gt;」，实现方式是&lt;strong&gt;通过一个索引块来存放多个索引数据块&lt;/strong&gt;，一层套一层索引，像极了俄罗斯套娃是吧。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%9D%97.png&quot; alt=&quot;多级索引块&quot; title=&quot;多级索引块&quot;/&gt;多级索引块
&lt;h4 id=&quot;hunix&quot;&gt;&lt;span&gt;Unix 文件的实现方式&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我们先把前面提到的文件实现方式，做个比较：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;那早期 Unix 文件系统是组合了前面的文件存放方式的优点，如下图：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Unix%20%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95.png&quot; alt=&quot;早期 Unix 文件系统&quot; title=&quot;早期 Unix 文件系统&quot;/&gt;早期 Unix 文件系统
&lt;p&gt;它是根据文件的大小，存放的方式会有所变化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果前面两种方式都不够存放大文件，则采用二级间接索引方式；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果二级间接索引也不够存放大文件，这采用三级间接索引方式；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么，文件头（&lt;em&gt;Inode&lt;/em&gt;）就需要包含 13 个指针：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;10 个指向数据块的指针；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;第 11 个指向索引块的指针；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;第 12 个指向二级索引块的指针；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;第 13 个指向三级索引块的指针；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，这种方式能很灵活地支持小文件和大文件的存放：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;对于小文件使用直接查找的方式可减少索引数据块的开销；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个方案就用在了 Linux Ext 2/3 文件系统里，虽然解决大文件的存储，但是对于大文件的访问，需要大量的查询，效率比较低。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，Ext 4 做了一定的改变，具体怎么解决的，本文就不展开了。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h-8&quot;&gt;&lt;span&gt;空闲空间管理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;前面说到的文件的存储是针对已经被占用的数据块组织和管理，接下来的问题是，如果我要保存一个数据块，我应该放在硬盘上的哪个位置呢？难道需要将所有的块扫描一遍，找个空的地方随便放吗？&lt;/p&gt;
&lt;p&gt;那这种方式效率就太低了，所以针对磁盘的空闲空间也是要引入管理的机制，接下来介绍几种常见的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;空闲表法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;空闲链表法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;位图法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h-9&quot;&gt;&lt;span&gt;空闲表法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。如下图：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95.png&quot; alt=&quot;空闲表法&quot; title=&quot;空闲表法&quot;/&gt;空闲表法
&lt;p&gt;当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。&lt;/p&gt;
&lt;p&gt;这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。&lt;/p&gt;
&lt;h4 id=&quot;h-10&quot;&gt;&lt;span&gt;空闲链表法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%A9%BA%E9%97%B2%E5%9D%97%E9%93%BE%E8%A1%A8.png&quot; alt=&quot;空闲链表法&quot; title=&quot;空闲链表法&quot;/&gt;空闲链表法
&lt;p&gt;当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。&lt;/p&gt;
&lt;p&gt;这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I/O 操作，同时数据块的指针消耗了一定的存储空间。&lt;/p&gt;
&lt;p&gt;空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。&lt;/p&gt;
&lt;h4 id=&quot;h-11&quot;&gt;&lt;span&gt;位图法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。&lt;/p&gt;
&lt;p&gt;当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs r&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1111110011111110001110110111111100111&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h-12&quot;&gt;&lt;span&gt;文件系统的结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;前面提到 Linux 是用位图的方式管理空闲空间，用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配，但仔细计算一下还是有问题的。&lt;/p&gt;
&lt;p&gt;数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 &lt;code&gt;4 * 1024 * 8 = 2^15&lt;/code&gt; 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 &lt;code&gt;2^15 * 4 * 1024 = 2^27&lt;/code&gt; 个 byte，也就是 128M。&lt;/p&gt;
&lt;p&gt;也就是说按照上面的结构，如果采用「一个块的位图 + 一系列的块」，外加「一个块的 inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。&lt;/p&gt;
&lt;p&gt;在 Linux 文件系统，把这个结构称为一个&lt;strong&gt;块组&lt;/strong&gt;，那么有 N 多的块组，就能够表示 N 大的文件。&lt;/p&gt;
&lt;p&gt;下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%9D%97%E7%BB%84.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;超级块&lt;/em&gt;，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;块组描述符&lt;/em&gt;，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;数据位图和 inode 位图&lt;/em&gt;， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;inode 列表&lt;/em&gt;，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;数据块&lt;/em&gt;，包含文件的有用数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你可以会发现每个块组里有很多重复的信息，比如&lt;strong&gt;超级块和块组描述符表，这两个都是全局信息，而且非常的重要&lt;/strong&gt;，这么做是有两个原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不过，Ext2 的后续版本采用了稀疏技术。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h-13&quot;&gt;&lt;span&gt;目录的存储&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在前面，我们知道了一个普通文件是如何存储的，但还有一个特殊的文件，经常用到的目录，它是如何保存的呢？&lt;/p&gt;
&lt;p&gt;基于 Linux 一切皆文件的设计思想，目录其实也是个文件，你甚至可以通过 &lt;code&gt;vim&lt;/code&gt; 打开它，它也有 inode，inode 里面也是指向一些块。&lt;/p&gt;
&lt;p&gt;和普通文件不同的是，&lt;strong&gt;普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在目录文件的块中，最简单的保存格式就是&lt;strong&gt;列表&lt;/strong&gt;，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。&lt;/p&gt;
&lt;p&gt;列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%9B%AE%E5%BD%95%E5%93%88%E5%B8%8C%E8%A1%A8.png&quot; alt=&quot;目录格式哈希表&quot; title=&quot;目录格式哈希表&quot;/&gt;目录格式哈希表
&lt;p&gt;通常，第一项是「&lt;code&gt;.&lt;/code&gt;」，表示当前目录，第二项是「&lt;code&gt;..&lt;/code&gt;」，表示上一级目录，接下来就是一项一项的文件名和 inode。&lt;/p&gt;
&lt;p&gt;如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。&lt;/p&gt;
&lt;p&gt;于是，保存目录的格式改成&lt;strong&gt;哈希表&lt;/strong&gt;，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。&lt;/p&gt;
&lt;p&gt;Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。&lt;/p&gt;
&lt;p&gt;目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;h-14&quot;&gt;&lt;span&gt;软链接和硬链接&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过&lt;strong&gt;硬链接（&lt;em&gt;Hard Link&lt;/em&gt;）&lt;/strong&gt; 和&lt;strong&gt;软链接（&lt;em&gt;Symbolic Link&lt;/em&gt;）&lt;/strong&gt; 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。&lt;/p&gt;
&lt;p&gt;硬链接是&lt;strong&gt;多个目录项中的「索引节点」指向一个文件&lt;/strong&gt;，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以&lt;strong&gt;硬链接是不可用于跨文件系统的&lt;/strong&gt;。由于多个目录项都是指向一个 inode，那么&lt;strong&gt;只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E9%93%BE%E6%8E%A5-2.png&quot; alt=&quot;硬链接&quot; title=&quot;硬链接&quot;/&gt;硬链接
&lt;p&gt;软链接相当于重新创建一个文件，这个文件有&lt;strong&gt;独立的 inode&lt;/strong&gt;，但是这个&lt;strong&gt;文件的内容是另外一个文件的路径&lt;/strong&gt;，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以&lt;strong&gt;软链接是可以跨文件系统的&lt;/strong&gt;，甚至&lt;strong&gt;目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%BD%AF%E9%93%BE%E6%8E%A5.png&quot; alt=&quot;软链接&quot; title=&quot;软链接&quot;/&gt;软链接
&lt;hr/&gt;&lt;h3 id=&quot;hio&quot;&gt;&lt;span&gt;文件 I/O&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;缓冲与非缓冲 I/O&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;直接与非直接 I/O&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;阻塞与非阻塞 I/O VS 同步与异步 I/O&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，分别对这些分类讨论讨论。&lt;/p&gt;
&lt;h4 id=&quot;hio-1&quot;&gt;&lt;span&gt;缓冲与非缓冲 I/O&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;文件操作的标准库是可以实现数据的缓存，那么&lt;strong&gt;根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里所说的「缓冲」特指标准库内部实现的缓冲。&lt;/p&gt;
&lt;p&gt;比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。&lt;/p&gt;
&lt;h4 id=&quot;hio-2&quot;&gt;&lt;span&gt;直接与非直接 I/O&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我们都知道磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。&lt;/p&gt;
&lt;p&gt;那么，&lt;strong&gt;根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你在使用文件操作类的系统调用函数时，指定了 &lt;code&gt;O_DIRECT&lt;/code&gt; 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果用了非直接 I/O 进行写数据操作，内核什么情况下才会把缓存数据写入到磁盘？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下几种场景会触发内核缓存的数据写入磁盘：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在调用 &lt;code&gt;write&lt;/code&gt; 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；&lt;/li&gt;
&lt;li&gt;用户主动调用 &lt;code&gt;sync&lt;/code&gt;，内核缓存会刷到磁盘上；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;hiovsio&quot;&gt;&lt;span&gt;阻塞与非阻塞 I/O VS 同步与异步 I/O&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;为什么把阻塞 / 非阻塞与同步与异步放一起说的呢？因为它们确实非常相似，也非常容易混淆，不过它们之间的关系还是有点微妙的。&lt;/p&gt;
&lt;p&gt;先来看看&lt;strong&gt;阻塞 I/O&lt;/strong&gt;，当用户程序执行 &lt;code&gt;read&lt;/code&gt; ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，&lt;code&gt;read&lt;/code&gt; 才会返回。&lt;/p&gt;
&lt;p&gt;注意，&lt;strong&gt;阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程&lt;/strong&gt;。过程如下图：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%98%BB%E5%A1%9E%20I_O.png&quot; alt=&quot;阻塞 I/O&quot; title=&quot;阻塞 I/O&quot;/&gt;阻塞 I/O
&lt;p&gt;知道了阻塞 I/O ，来看看&lt;strong&gt;非阻塞 I/O&lt;/strong&gt;，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，&lt;code&gt;read&lt;/code&gt; 调用才可以获取到结果。过程如下图：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%9D%9E%E9%98%BB%E5%A1%9E%20I_O%20.png&quot; alt=&quot;非阻塞 I/O&quot; title=&quot;非阻塞 I/O&quot;/&gt;非阻塞 I/O
&lt;p&gt;注意，&lt;strong&gt;这里最后一次 read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个例子，访问管道或 socket 时，如果设置了 &lt;code&gt;O_NONBLOCK&lt;/code&gt; 标志，那么就表示使用的是非阻塞 I/O 的方式访问，而不做任何设置的话，默认是阻塞 I/O。&lt;/p&gt;
&lt;p&gt;应用程序每次轮询内核的 I/O 是否准备好，感觉有点傻乎乎，因为轮询的过程中，应用程序啥也做不了，只是在循环。&lt;/p&gt;
&lt;p&gt;为了解决这种傻乎乎轮询方式，于是 &lt;strong&gt;I/O 多路复用&lt;/strong&gt;技术就出来了，如 select、poll，它是通过 I/O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。&lt;/p&gt;
&lt;p&gt;这个做法大大改善了应用进程对 CPU 的利用率，在没有被通知的情况下，应用进程可以使用 CPU 做其他的事情。&lt;/p&gt;
&lt;p&gt;下图是使用 select I/O 多路复用过程。注意，&lt;code&gt;read&lt;/code&gt; 获取数据的过程（数据从内核态拷贝到用户态的过程），也是一个&lt;strong&gt;同步的过程&lt;/strong&gt;，需要等待：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%9F%BA%E4%BA%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%20I_O%20%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png&quot; alt=&quot;I/O 多路复用&quot; title=&quot;I/O 多路复用&quot;/&gt;I/O 多路复用
&lt;p&gt;实际上，无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用&lt;strong&gt;都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而真正的&lt;strong&gt;异步 I/O&lt;/strong&gt; 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。&lt;/p&gt;
&lt;p&gt;当我们发起 &lt;code&gt;aio_read&lt;/code&gt; 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。过程如下图：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%BC%82%E6%AD%A5%20I_O.png&quot; alt=&quot;异步 I/O&quot; title=&quot;异步 I/O&quot;/&gt;异步 I/O
&lt;p&gt;下面这张图，总结了以上几种 I/O 模型：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5VS%E5%BC%82%E6%AD%A5IO.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;在前面我们知道了，I/O 是分为两个过程的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;数据准备的过程&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据从内核空间拷贝到用户进程缓冲区的过程&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。&lt;/p&gt;
&lt;p&gt;异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用故事去理解这几种 I/O 模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个你去饭堂吃饭的例子，你好比用户程序，饭堂好比操作系统。&lt;/p&gt;
&lt;p&gt;阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。&lt;/p&gt;
&lt;p&gt;非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。&lt;/p&gt;
&lt;p&gt;基于非阻塞的 I/O 多路复用好比，你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，等做好了再通知你，于是等啊等（&lt;code&gt;select&lt;/code&gt; 调用中），过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。&lt;/p&gt;
&lt;p&gt;异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h-15&quot;&gt;&lt;span&gt;迟到理由&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;是的，小林依然迟到了，因为最近发生了一件非常倒霉的事情，我之前使用的图床挂掉了……&lt;/p&gt;
&lt;p&gt;这就导致我所有文章的图片都挂了，好在大部分博客平台都会转存图片，所以微信公众号、CSDN、知乎等平台都正常，但我的本地文章笔记和博客园平台的图片都挂掉了，在博客园还有个读者私信提醒我的文章图片挂了，他很喜欢小林文章，希望早点恢图片，太感动了。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E5%85%B6%E4%BB%96/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E8%AF%BB%E8%80%85%E7%95%99%E8%A8%80.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;这就是白嫖免费图床的下场，本打算换阿里云图床，但阿里云图床是按访问流量收费的，如果有人搞你，那直接刷爆你的钱包，想想都可怕，小林穷搞不起搞不起。&lt;/p&gt;
&lt;p&gt;后来，询问了一位朋友 guide 哥，他说可以使用 GitHub 作为图床，用开源工具 Picgo 关联 GitHub 上传图片，再通过 jsdelivr CDN 加速访问，这一套组合很完美，于是我就采用了此方案搭建了自己的图床，依旧继续白嫖，我就不信 GitHub 也挂！&lt;/p&gt;
&lt;p&gt;图床虽然搞定了，最糟糕的事情才开始，我要把以前近 &lt;code&gt;500&lt;/code&gt; 张的图片重新保存（以前有的图片丢了）和分类，并一个一个上传到 Github，接着还得把图片的新地址改到本地文章，这工作量简直要命，到现在我也才搞定了操作系统篇的图片，网络篇的图片还有 2/3 没弄完，瞬间后悔自己画那么多图。&lt;/p&gt;
&lt;p&gt;唉，发完这篇文章，小林还得继续恢复图片……&lt;/p&gt;
&lt;p&gt;最近，我都在 B 站学习操作系统，但有时候是想看操作系统，但奈何 B 站首页推送太丰富，看着看着半天就过去了，甚至还花了一天时间专门看一个 UP 主解说「火影忍者」动漫全集，于是就这么忘了文章的事情，哈哈哈。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaolincoder/ImageHost/%E5%85%B6%E4%BB%96/B%E7%AB%99%E4%B8%80%E5%8F%A3%E6%B0%94%E7%81%AB%E5%BD%B1.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;不过，确实很过瘾，&lt;strong&gt;毕竟偷的了忙中闲，方能人上人嘛。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好了，&lt;strong&gt;小林是专为大家图解的工具人，我们下次见！&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h6 id=&quot;h-16&quot;&gt;&lt;span&gt;好文推荐&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/MnIcTR0KKpgnSoA3xaPUSA&quot;&gt;凉了！张三同学没答好「进程间通信」，被面试官挂了….&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/yPH0kK0aVM43oNj7vukOCQ&quot;&gt;万粉福利，300 页图解网络 PDF 打包送你&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Aug 2020 14:08:00 +0000</pubDate>
<dc:creator>小林coding</dc:creator>
<og:description>前言 不多 BB，直接上「硬菜」。 正文 文件系统的基本组成 文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaolincoding/p/13499209.html</dc:identifier>
</item>
<item>
<title>旧 WCF 项目迁移到 asp.net core + gRPC 的尝试 - 顺风椰子皮</title>
<link>http://www.cnblogs.com/BenAndWang/p/13499067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BenAndWang/p/13499067.html</guid>
<description>&lt;p&gt;一个月前，公司的运行WCF的windows服务器down掉了，由于 AWS 没有通知，没有能&lt;strong&gt;第一时间&lt;/strong&gt;发现问题。&lt;br/&gt;所以，客户提出将WCF服务由C#改为JAVA，在Linux上面运行；一方面，AWS对Linux有较多的监控措施，另一方面，假如出现问题，可以设置自动重启等服务。&lt;/p&gt;

&lt;p&gt;目前WCF服务，主要提供windows桌面软件的&lt;strong&gt;数据接口&lt;/strong&gt;，应该有五六年的历史了。我进入公司后，WCF服务的代码，一直由我一个人来维护。存在很多&lt;strong&gt;历史遗留问题&lt;/strong&gt;，也有&lt;strong&gt;不同版本&lt;/strong&gt;的共存。&lt;/p&gt;
&lt;p&gt;如果java重写的话，其中的业务逻辑代码，难免会出现各种各样的bug，增加开发和测试的工作量。听说，要移植到linux服务上后，第一时间想到的就是&lt;strong&gt;跨平台&lt;/strong&gt;的 &lt;code&gt;.net core&lt;/code&gt; 。&lt;br/&gt;.net core 经过了四年的发展，到目前的 3.1 LST版本，已经是&lt;strong&gt;非常成熟&lt;/strong&gt;的跨平台解决方案了。&lt;/p&gt;
&lt;p&gt;之后，我就在网上查找，有没有WCF的.net core 版本，查询到的信息总结如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Core WCF不打算做WCF到.NET Core的100％兼容的移植；&lt;/li&gt;
&lt;li&gt;对于新应用程序，WCF这种SOAP技术不建议使用；&lt;/li&gt;
&lt;li&gt;对于老的应用程序，建议将这些保留在.NET Framework上；&lt;/li&gt;
&lt;li&gt;如果您真的想将一个旧的应用程序迁移到.NET Core并且想继续使用WCF和WF， 社区的开源项目也是可以的，但是上生产的时间表就要到了2020年.NET 5；&lt;/li&gt;
&lt;li&gt;开源社区，也强烈建议目前不要用于生产环境。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;很遗憾，想不改动代码就迁移到 Linux 上面，基本是不可能的了。&lt;br/&gt;我的最理想情况，&lt;strong&gt;尽量少的手写代码&lt;/strong&gt;，最好可以像WCF一样，&lt;strong&gt;自动生成&lt;/strong&gt;代理类，&lt;strong&gt;像访问本地代码&lt;/strong&gt;一样，来调用接口。之后，就发现了asp.net core + gRPC这种形式。&lt;/p&gt;
&lt;h2 id=&quot;了解grpc&quot;&gt;了解gRPC&lt;/h2&gt;
&lt;p&gt;gRPC 的好处非常多：&lt;code&gt;高性能&lt;/code&gt;，&lt;code&gt;传输数据小&lt;/code&gt;，支持&lt;code&gt;多语言&lt;/code&gt;的&lt;strong&gt;生成工具&lt;/strong&gt;，&lt;code&gt;使用HTTP2协议&lt;/code&gt;，这些好处网上都有大量详细的介绍，本文不做赘述。&lt;br/&gt;其实我最看重的部分还是：客户端和服务端代码，都可以通过一个 &lt;code&gt;proto&lt;/code&gt; 协议文件来&lt;strong&gt;自动生成&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而微软官方，也建议用 ASP.NET Core gRPC。 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/&quot;&gt;《适用于 WCF 开发人员的 ASP.NET Core gRPC》&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;grpc-的-proto-文件&quot;&gt;gRPC 的 proto 文件&lt;/h3&gt;
&lt;p&gt;为了了解 proto 文件的写法，硬着头皮看谷歌英文文档， proto3 勉强了解大概。&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3&quot;&gt;《Language Guide (proto3)》&lt;/a&gt;，下面列出一些，我在使用过程中的经验总结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个RPC服务必须&lt;strong&gt;有且仅有&lt;/strong&gt;&lt;code&gt;一个入参&lt;/code&gt;和&lt;code&gt;一个出参&lt;/code&gt;；假如不需要的话，可以设置为空的对象&lt;code&gt;google.protobuf.Empty&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基本类型&lt;/strong&gt;( string, int32 等)&lt;strong&gt;不能作为PRC服务的参数&lt;/strong&gt;，可使用谷歌提供的封装对象，如：&lt;code&gt;google.protobuf.StringValue&lt;/code&gt;，&lt;code&gt;google.protobuf.Int32Value&lt;/code&gt; 详见 &lt;code&gt;google/protobuf/wrappers.proto&lt;/code&gt;文件；&lt;/li&gt;
&lt;li&gt;proto3 &lt;strong&gt;不允许null值&lt;/strong&gt;，这是由于 Protobuf 二进制序列化，&lt;strong&gt;空和null不能区分&lt;/strong&gt;，利用&lt;code&gt;google.protobuf.StringValue&lt;/code&gt; 则可以实现null值；同第2点；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string name=1;&lt;/code&gt;这个数字必须写，用作 Protobuf 二进制序列化，并且常用的属性最好放在前12；PS: 太不习惯了，总以为是在赋值操作；&lt;/li&gt;
&lt;li&gt;枚举类型必须从0开始，即：&lt;code&gt;enum Weekday {Sunday=0;Monday=2;}&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;时间类型&lt;code&gt;google.protobuf.Timestamp&lt;/code&gt;，必须是 UTC 时间；&lt;/li&gt;
&lt;li&gt;消息体 message 不能继承，可多层嵌套，可以导入 import；&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-proto&quot;&gt;// 我的例子
syntax = &quot;proto3&quot;;

option csharp_namespace = &quot;GrpcServiceTest.Protos&quot;;

import &quot;Protos/ClientInfoModel.proto&quot;;
import &quot;google/protobuf/timestamp.proto&quot;;
import &quot;google/protobuf/wrappers.proto&quot;;

package UserManagement;
service UserManagement {
    rpc UserReset(google.protobuf.Empty) returns (google.protobuf.Empty);
    rpc UserLogin(LoginRequestV2) returns(LoginResponseV2);
}

message LoginRequestV2 {
    string UserName = 1;
    string Password = 2;
}

message LoginResponseV2 {
    int32 TAG = 1;
    string Message = 2;
    UserModelV2 UserInfo = 3;

    message UserModelV2 {
        int64 UserID = 1;
        string UserName = 2;
        google.protobuf.StringValue Address = 3;
        google.protobuf.Timestamp LastLoginTime = 4;
        repeated PrivGroupPluginModelV2 PrivGroupPlugins = 5;
        bool IsDeleted = 6;

        message PrivGroupPluginModelV2{
        int64 Id=1;
        google.protobuf.Timestamp CreateDateTime=2;
        google.protobuf.Timestamp ModifyDateTime=3;
        int64 PluginId=4;
        int64 PrivGroupPluginID=5;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;根据-proto-生成代码&quot;&gt;根据 proto 生成代码&lt;/h3&gt;
&lt;p&gt;用vs2019，选择&lt;code&gt;gRPC Service&lt;/code&gt;项目模板，创建项目。它会自动加上nuget包&lt;code&gt;Grpc.AspNetCore&lt;/code&gt;。如果没有的话，则需要自己安装nuget包：&lt;code&gt;Grpc.core&lt;/code&gt;、&lt;code&gt;Google.Protobuf&lt;/code&gt;、&lt;code&gt;Grpc.Tools&lt;/code&gt;。&lt;br/&gt;由 proto 文件生成代码有两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过vs右键 proto文件，选择 属性&lt;code&gt;Property&lt;/code&gt;，选择&lt;code&gt;Build Action&lt;/code&gt;中的&lt;code&gt;Protobuf complier&lt;/code&gt;，会看到 &lt;code&gt;gRPC Stub Classes&lt;/code&gt;，有三个选项 Server Only ， Clent Only 和 Both 按需选择；&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/286936/202008/286936-20200813214459351-1152613827.jpg&quot; alt=&quot;VS生成&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;编辑项目文件 csproj，编辑 Protobuf 属性，这种方法还可以使用&lt;code&gt;路径宏&lt;/code&gt;，&lt;code&gt;通配符&lt;/code&gt;等，相当方便，&lt;strong&gt;强烈推荐&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;ItemGroup&amp;gt;
    &amp;lt;Protobuf Include=&quot;Protos/*.proto&quot; OutputDir=&quot;%(ProjectDir)ServerGrpc&quot; GrpcServices=&quot;Server&quot; /&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/286936/202008/286936-20200813214527226-764636028.jpg&quot; alt=&quot;vs生成展示&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;aspnet-core-31&quot;&gt;asp.net core 3.1&lt;/h2&gt;
&lt;p&gt;现在，恰好赶上了net core 3.1的这个 &lt;strong&gt;LST版本&lt;/strong&gt; ( long-term-support )的发布，而 NET Core 3.0 生命周期终结于 2020年3月3日，下个大一统版本 NET 5 ，正式版本还要等到明年。至于为什么没有 NET 4.0版本，官方解释，为了避免于 .NET Framework 4.X 产生歧义。&lt;/p&gt;
&lt;p&gt;一步步的按照官方文档的指引，跟着做就可以了。&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/grpc/aspnetcore?view=aspnetcore-3.1&amp;amp;tabs=visual-studio&quot;&gt;《使用 ASP.NET Core 的 gRPC 服务》&lt;/a&gt;，&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-3.1&amp;amp;tabs=visual-studio&quot;&gt;《教程：在 ASP.NET Core 中创建 gRPC 客户端和服务器》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仔细回想了一下，这部分确实没有什么值得说的，&lt;strong&gt;官方文档已经非常的详细了&lt;/strong&gt;。唯一不同的感受就是，net core 需要什么功能的话，需要通过nuget来安装；这点与 net framework 大有不同，framework 更像是，一次帮你全部装好。&lt;/p&gt;
&lt;h2 id=&quot;entity-framework-core&quot;&gt;Entity Framework Core&lt;/h2&gt;
&lt;p&gt;旧的WCF项目，数据库访问使用的是 Entity Framework + Linq + MySql。需要安装的 Nuget 包：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;MySql.Data.EntityFrameworkCore&lt;/code&gt; Mysql的EF核心库；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Microsoft.EntityFrameworkCore.Proxies&lt;/code&gt; &lt;a href=&quot;https://docs.microsoft.com/en-us/ef/core/querying/related-data#lazy-loading&quot;&gt;《Lazy loading》&lt;/a&gt; 懒加载的插件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Microsoft.EntityFrameworkCore.Design&lt;/code&gt; 和 &lt;code&gt;Microsoft.EntityFrameworkCore.Tools&lt;/code&gt; 这两个插件，用于生成代码；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，还需要下载安装 &lt;a href=&quot;https://dev.mysql.com/downloads/connector/net/&quot;&gt;mysql-connector-net-8.0.21.msi&lt;/a&gt; 来访问数据库。其中有一个 &lt;code&gt;Scaffold-DbContext&lt;/code&gt; 的&lt;a href=&quot;https://bugs.mysql.com/bug.php?id=99419&quot;&gt;bug 99419&lt;/a&gt; TINYINT(1) 转化为 byte，而不是预期的 bool。这个问题将会在 8.0.22 版本中修复，目前只能手动修改。&lt;br/&gt;EF当然是 &lt;code&gt;Database First&lt;/code&gt; 了，生成EF代码需要在&lt;code&gt;Package Manager Console&lt;/code&gt;用到 &lt;a href=&quot;https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/powershell#scaffold-dbcontext&quot;&gt;Scaffold-DbContext&lt;/a&gt; 命令，有三点需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Start up&lt;/code&gt; 启始项目一定要是引用它的项目，并且编译成功的；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Default project&lt;/code&gt; 生成后，代码存放的项目；&lt;/li&gt;
&lt;li&gt;如果生成失败，提示：“Your startup project 'XXXX' doesn't reference Microsoft.EntityFrameworkCore.Design. This package is required for the Entity Framework Core Tools to work. Ensure your startup project is correct, install the package, and try again.”。编辑项目文件 csproj 移除 &lt;code&gt;&amp;lt;PrivateAssets&amp;gt;All&amp;lt;/PrivateAssets&amp;gt;&lt;/code&gt; 从 &quot;Microsoft.EntityFrameworkCore.Design&quot;和&quot;Microsoft.EntityFrameworkCore.Tools&quot;中；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/286936/202008/286936-20200813214556503-1359460009.jpg&quot; alt=&quot;EF remove PrivateAssets&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我的命令： &lt;code&gt;Scaffold-DbContext -Connection &quot;server=10.50.40.50;port=3306;user=myuser;password=123456;database=dbname&quot; -Provider MySql.Data.EntityFrameworkCore -OutputDir &quot;EFModel&quot; -ContextDir &quot;Context&quot; -Project &quot;DataAccess&quot; -Context &quot;BaseEntities&quot; -UseDatabaseNames -Force&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其他建议：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Library类库最好是 &lt;code&gt;netstandard&lt;/code&gt; 方便移植；&lt;/li&gt;
&lt;li&gt;新建一个类来继承&lt;code&gt;BaseEntities&lt;/code&gt;，覆盖 &lt;code&gt;OnConfiguring&lt;/code&gt; 方法，可配置的数据库连接字符串；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Entities : BaseEntities
{
    private static string _lstDBString;

    public static void SetDefaultDBString(string _dbString)
    {
        if (string.IsNullOrEmpty(_lstDBString))
        {
            _lstDBString = _dbString;
        }
    }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        if (!optionsBuilder.IsConfigured)
        {
            optionsBuilder.UseLazyLoadingProxies().UseMySQL(_lstDBString);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;最好采用 asp.net core 的框架注入；鉴于项目的原因，假如强行采用的话，改动比较大，只好放弃；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void ConfigureServices(IServiceCollection services)
{
    string _dbString = Configuration.GetConnectionString(&quot;LstDatabase&quot;);
    services.AddDbContext&amp;lt;DataAccess.Context.Entities&amp;gt;(
        options =&amp;gt; options.UseLazyLoadingProxies().UseMySQL(_dbString));
    services.AddGrpc();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;数据库链接字符串有多种存放的方式，有更加安全的方式；而我采用简单方式存放在 &lt;code&gt;appsettings.json&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;ConnectionStrings&quot;: {
        &quot;LstDatabase&quot;: &quot;server=127.0.0.1;port=3306;user=myuser;password=123456;database=dbname&quot;
    },
    &quot;log4net&quot;: &quot;log4net.config&quot;,
    &quot;Logging&quot;: {
        &quot;LogLevel&quot;: {
            &quot;Default&quot;: &quot;Information&quot;,
            &quot;Microsoft&quot;: &quot;Warning&quot;,
            &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;
        }
    },
    &quot;AllowedHosts&quot;: &quot;*&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;部署到-ubuntu&quot;&gt;部署到 Ubuntu&lt;/h2&gt;
&lt;p&gt;生产环境运行的服务器是 &lt;code&gt;Ubuntu 14.04.6 LTS&lt;/code&gt;，在&lt;a href=&quot;https://wiki.ubuntu.com/Releases&quot;&gt;《ubuntu Releases wiki》&lt;/a&gt;上描述，14版本在去年已经停止了标准支持，而 .net core 的 runtime 最低支持也是 &lt;code&gt;Ubuntu 16.04.6 LTS&lt;/code&gt;，只好选择最新的版本&lt;code&gt;Ubuntu 20.04.1 LTS&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;安装Ubuntu Server系统小插曲：IT支持部门的同事，帮忙&lt;strong&gt;重装了两遍系统&lt;/strong&gt;，一次14.04桌面版，一次20.04服务器版；安装20版本后，发现&lt;strong&gt;网卡没有启用&lt;/strong&gt;，主机后面网线的灯都没有亮起来。&lt;br/&gt;由于我和他都不熟悉Ubuntu系统，网上查找办法，然后用手机拍照，再来服务器上尝试，搞了好一会儿，才连上网络，SSH也居然没有启用😥。可能 Ubuntu 还是比较适合做桌面系统吧。&lt;/p&gt;
&lt;p&gt;然后参考 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/core/install/linux-ubuntu&quot;&gt;《在 Ubuntu 上安装 .NET Core SDK 或 .NET Core 运行时》&lt;/a&gt;，安装 net core的环境，最初用的是 &lt;code&gt;aspnetcore-runtime&lt;/code&gt; ，在测试的时候发现，gRPC需要 HTTPS。折腾了半天的 HTTPS，一会儿需要签名，一会儿还要生成密钥，一会儿还要放到指定的位置，可信任的证书还要去还要折腾😓😵。折腾了半天，&lt;strong&gt;脑壳一团浆糊&lt;/strong&gt;。只好又安装了 &lt;code&gt;dotnet-sdk&lt;/code&gt;，这个是自带开发的证书，反正是将就用把。&lt;/p&gt;
&lt;p&gt;剩下的就比较简单了，编译发布asp.net core，打包上传到服务器，然后运行&lt;code&gt;dotnet GrpcServiceLST.dll --urls &quot;http://*:5000;http://*:5001&quot;&lt;/code&gt;。打开浏览器测试访问，没毛病。&lt;/p&gt;
&lt;h2 id=&quot;客户端的编写&quot;&gt;客户端的编写&lt;/h2&gt;
&lt;p&gt;在编写windows客户端的时候，遇到个问题：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/grpc/clientfactory?view=aspnetcore-3.1&quot;&gt;《.NET Core 中的 gRPC 客户端工厂集成》&lt;/a&gt;推荐的插件 &lt;code&gt;Grpc.Net.ClientFactory&lt;/code&gt; 只能适用于 net core，而大部分客户的 windows7 系统不会安装 net core；如果想在 net framework 上使用 gRPC的话，只能&lt;strong&gt;用原生的方法来自己实现&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用 proto 文件生成代码的方法，与上面的一致，只需要把 &lt;code&gt;Server Only&lt;/code&gt; 改为 &lt;code&gt;Client Only&lt;/code&gt; ；代码部分要注意，部署的 HTTPS 是不受信任的，需要额外处理一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// net core 3.1
private void button2_Click(object sender, EventArgs e)
{
    // 取消不受信任
    var httpHandler = new HttpClientHandler();
    httpHandler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator;
    var channel = GrpcChannel.ForAddress(&quot;https://10.50.40.237:5001&quot;, new GrpcChannelOptions { HttpHandler = httpHandler });
    var client = new UserManagement.UserManagementClient(channel);
    var _param = new GrpcServiceLST.Protos.LoginRequestV2()
    {
        UserName = &quot;user&quot;,
        Password = &quot;123456&quot;
    };
    var reply = client.UserLoginOSDShadowEx(_param);
    MessageBox.Show(&quot;net core login: &quot; + reply.Message);
}

/// framework 4.0
private void button1_Click(object sender, EventArgs e)
{
    var channel = new Channel(&quot;10.50.40.237:5000&quot;, ChannelCredentials.Insecure);
    var client = new UserManagement.UserManagementClient(channel);
    var _param = new GrpcServiceLST.Protos.LoginRequestV2()
    {
        UserName = &quot;user&quot;,
        Password = &quot;123456&quot;
    };
    var _reply = client.UserLoginOSDShadowEx(_param);
    MessageBox.Show(&quot;framework login:&quot; + _reply.Message);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过测试发现，net core &lt;strong&gt;不支持 http 的访问&lt;/strong&gt;； net framework 的原生版本，只能访问 http 端口 5000 ，&lt;strong&gt;不能访问 https 端口 5001&lt;/strong&gt; ，不能用 http 或者 https 这样的前缀(如: &lt;code&gt;http://10.50.40.237:5000&lt;/code&gt;)，&lt;strong&gt;localhost这种域名也无法解析&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th&gt;HTTP&lt;/th&gt;
&lt;th&gt;HTTPS&lt;/th&gt;
&lt;th&gt;域名&lt;/th&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;net core&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;framework&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;最最要命的是，在 win7 系统上，安装了 net core ，使用 Grpc.Net.ClientFactory 居然也不可以访问。在github上面找到了答案， &lt;strong&gt;win7 不会支持 http2&lt;/strong&gt; ，并且 win7 微软已经在2020 年1 月14 日停止提供支持。&lt;/p&gt;
&lt;blockquote readability=&quot;6.7307692307692&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/grpc/grpc-dotnet/issues/416#issuecomment-545596712&quot;&gt;issues&lt;/a&gt; : ASP.NET Core uses the operating system for HTTP/2 TLS support. macOS may support hosting servers with HTTP/2 TLS in the future, Windows 7 will not.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这次WCF升级到 asp.net core + gRPC，迁移到 Linux 的部分，方案虽然可以运行。但是要&lt;strong&gt;放弃 win7 用户是不太可能的&lt;/strong&gt;，只好放弃 gRPC这种方案。&lt;/p&gt;
&lt;p&gt;幸运的是，放弃 gPRC 的那一刻，我突然意识到，&lt;strong&gt;为什么不用 web api&lt;/strong&gt; ，REST Full 的方式也满足，逻辑部分的代码尽量不变。下一篇介绍，WCF 迁移到 asp.net core web api ，到目前为止，这个方案是我最为满意的。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Aug 2020 13:48:00 +0000</pubDate>
<dc:creator>顺风椰子皮</dc:creator>
<og:description>一个月前，公司的运行WCF的windows服务器down掉了，由于 AWS 没有通知，没有能第一时间发现问题。 所以，客户提出将WCF服务由C#改为JAVA，在Linux上面运行；一方面，AWS对Li</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/BenAndWang/p/13499067.html</dc:identifier>
</item>
</channel>
</rss>