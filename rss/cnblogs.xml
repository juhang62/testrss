<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Asp.Net Core 轻松学-多线程之Task快速上手 - Ron.liang</title>
<link>http://www.cnblogs.com/viter/p/10201228.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viter/p/10201228.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;    Task是从 .NET Framework 4 开始引入的一项基于队列的异步任务（TAP）模式，从 .NET Framework 4.5 开始，任何使用 async/await 进行修饰的方法，都会被认为是一个异步方法；实际上，这些异步方法都是基于队列的线程任务，从你开始使用 Task 去运行一段代码的时候，实际上就相当于开启了一个线程，默认情况下，这个线程数由线程池 ThreadPool 进行管理的。&lt;/p&gt;
&lt;h2 id=&quot;task-的使用方法&quot;&gt;1. Task 的使用方法&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Task 的使用用方法非常简单，一行代码就可以开始一个异步任务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;最简单的使用方式&quot;&gt;1.1 最简单的使用方式&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;       static void EasyTask()
        {
            // 执行一个无返回值的任务
            Task.Run(() =&amp;gt;
            {
                Console.WriteLine(&quot;runing...&quot;);
            });

            // 执行一个返回 int 类型结果的任务
            Task.Run&amp;lt;int&amp;gt;(() =&amp;gt;
            {
                return new Random().Next();
            });

            // 声明一个任务，仅声明，不执行
            Task t = new Task(() =&amp;gt;
            {
                Console.WriteLine(&quot;&quot;);
            });
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;上面的代码看起来非常简单，只需要一行代码就完成了一个异步任务线程，先不要去深究其背后的原理，对于新手来说，先解决能用，再去了解为什么可以这样使用，不然，一开始就失去了学习的信心&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用-taskfactory-工厂开始异步任务&quot;&gt;2.1 使用 TaskFactory 工厂开始异步任务&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        static void Factory()
        {
            List&amp;lt;Task&amp;lt;int&amp;gt;&amp;gt; tasks = new List&amp;lt;Task&amp;lt;int&amp;gt;&amp;gt;();
            TaskFactory factory = new TaskFactory();
            tasks.Add(factory.StartNew&amp;lt;int&amp;gt;(() =&amp;gt;
           {
               return 1;
           }));
            tasks.Add(factory.StartNew&amp;lt;int&amp;gt;(() =&amp;gt;
            {
                return 2;
            }));

            foreach (var t in tasks)
            {
                Console.WriteLine(&quot;Task:{0}&quot;, t.Result);
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;上面的代码使用 TaskFactory 创建并运行了两个异步任务，同时把这两个任务加入了任务列表 tasks 中，然后立即迭代此 tasks 获取异步任务的执行结果，使用 TaskFactory 工厂类，可以创建一组人物，然后依次执行它们&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;执行上面的代码输出结果如下&quot;&gt;2.3 执行上面的代码，输出结果如下&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201812/26882-20181231010646219-893833364.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;处理-task-中的异常&quot;&gt;3. 处理 Task 中的异常&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;异步任务中发生异常会导致任务抛出 TaskCancelException 的异常，仅表示任务退出，程序应当捕获该异常；然后，立即调用 Task 进行状态判断，获取内部异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;模拟抛出异常&quot;&gt;3.1 模拟抛出异常&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;        static void SimpleTask()
        {
            var task = Task.Run(() =&amp;gt;
            {
                Console.WriteLine(&quot;SimpleTask&quot;);
                Task.Delay(1000).Wait();
                throw new Exception(&quot;SimpleTask Error&quot;);
            });
            try
            {
                task.Wait();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
             if (task.IsCompletedSuccessfully)
            {
                Console.WriteLine(&quot;IsCompleted&quot;);
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;上面的代码模拟了 Task 内部发生的异常，并捕获了异常，通常情况下，推荐使用 Task 的任务状态判断以进行下一步的任务处理（如果需要），如果仅仅是简单的执行一个异步任务，直接捕获异常即可，这里使用了状态判断，如果任务已完成，则打印一则消息：IsCompleted；很明显，在上面的代码中，此 “IsCompleted” 消息并不会被打印到控制台&lt;br/&gt;注意，这里使用了 task.IsCompletedSuccessfully 而不是 task.IsCompleted，这两者的区别在于，前者只有在任务正常执行完成，无异常，无中途退出指令的情况下才会表示已完成，而 task.IsCompleted 则仅仅表示“任务完成”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;执行程序输出结果&quot;&gt;3.2 执行程序，输出结果&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201812/26882-20181231010607871-110373468.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;同步上下文&quot;&gt;4. 同步上下文&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在 WinForm/WPF 应用程序中，也常常需要在 UI 上开辟异步任务，通常情况下，窗体控件仅允许创建其的线程访问，在没有 Task 的时代，处理异步上下文到同步上下文是一件非常复杂的事情，在 Task 出现以后，提供了 TaskScheduler 任务调度器，让我们可以非常方便的在异步线程中访问 UI 线程的资源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;获取当前线程上下文对象&quot;&gt;4.1 获取当前线程上下文对象&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt; static void TaskSynchronizationContext()
        {
            var UISyncContext = TaskScheduler.FromCurrentSynchronizationContext();

            var t1 = Task.Factory.StartNew&amp;lt;int&amp;gt;(() =&amp;gt;
               {
                   return 1;
               });
            t1.ContinueWith((atnt) =&amp;gt;
            {
                // 从这里访问 UI 线程的资源
                Console.WriteLine(&quot;从这里访问 UI 线程的资源&quot;);

            }, UISyncContext);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;从上面的代码可以发现，仅仅需要调用 TaskScheduler.FromCurrentSynchronizationContext() 获得当前线程的同步上下文，然后在执行异步任务的时候传入，即可访问当前线程创建的 UI 资源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;task-的运行方式&quot;&gt;5. Task 的运行方式&lt;/h2&gt;
&lt;h5 id=&quot;基于-threadpool-线程池的方式&quot;&gt;5.1 基于 ThreadPool 线程池的方式&lt;/h5&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;一个异步任务总是处于队列中，任务队列基于先进先出的原则，最新进入队列的任务总是最先被执行；但是，在多线程的环境下，最先执行并不意味着最先结束，意识到这一点很重要，每个任务可调度的资源和处理的进度决定了任务的完成时间。&lt;br/&gt;默认情况下，所有的任务都使用 ThreadPool 的资源，当你开启一个 Task 的时候，实际上，是由 ThreadPool 分配了一个线程，ThreadPool 的上限取决于很多方面的因素，例如虚拟内存的大小，当 Task 开启的数量超过ThreadPool 的上限的时候，Task 将进入排队状态，可以手动设置 ThreadPool 的大小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;        static void SetThreadPool()
        {
            var available = ThreadPool.SetMaxThreads(8, 16);
            Console.WriteLine(&quot;Result:{0}&quot;, available);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;上面的代码表示设置当前程序可使用的线程池大小，但是，SetMaxThreads 的值不应该小于托管服务器的 CPU 核心数量，否则，变量 available 的值将显示为 false，表示未成功设置线程池上限&lt;br/&gt;注意：ThreadPool 上的所有线程都是后台线程，也就是说，其IsBackground属性是true，在托管程序退出后，ThreadPool 也将会退出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;长时间运行于后台的任务&quot;&gt;5.2 长时间运行于后台的任务&lt;/h5&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在创建 Task 的时候，我们可能需要做一些长时间运行的业务，这个时候如果使用默认的 ThreadPool 资源，在并发状态下，这是不合适的，因为该任务总是长时间的占用线程池中的资源，导致线程池数量受限，这种情况下，可以在创建任务的时候使用指定 TaskCreationOptions.LongRunning 方式创建 Task&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt; static void LongTask()
        {
            Task.Factory.StartNew(() =&amp;gt;
            {
                Console.WriteLine(&quot;LongRunning Task&quot;);
            }, TaskCreationOptions.LongRunning);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;上面的代码看起来和创建普通的 Task 任务并没有多大的区别，唯一不同的是，在参数中传入了 TaskCreationOptions.LongRunning，指定这个是一个 LongRunning 类型的任务，当TaskFactory 收到这样一个类型的任务时，将会为这个任务开辟一个独立的线程，而不是从 ThreadPool 中创建&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;有条件的-task&quot;&gt;6. 有条件的 Task&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Task 内部提供多种多样的基于队列的链式任务管理方法，通过使用这些快捷方式，可以让异步队列有序的执行，比如ContinueWith()，ContinueWhenAll()，ContinueWhenAny(),WaitAll()，WaitAny()，WhenAll(),WhenAny()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;使用演示&quot;&gt;6.1 使用演示&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt; static void WithTask()
        {
            var order1 = Task.Run(() =&amp;gt;
            {
                Console.WriteLine(&quot;Order 1&quot;);
            });

            // 匿名委托将等待 order1 执行完成后执行，并将 order1 对象作为参数传入
            order1.ContinueWith((task) =&amp;gt;
            {
                Console.WriteLine(&quot;Order 1 Is Completed&quot;);
            });

            var t1 = Task.Run(() =&amp;gt; { Task.Delay(1500).Wait(); Console.WriteLine(&quot;t1&quot;); });
            var t2 = Task.Run(() =&amp;gt; { Task.Delay(2000).Wait(); Console.WriteLine(&quot;t2&quot;); });
            var t3 = Task.Run(() =&amp;gt; { Task.Delay(3000).Wait(); Console.WriteLine(&quot;t3&quot;); });
            Task.WaitAll(t1, t2, t3);
            // t1,t2,t3 完成后输出下面的消息
            Console.WriteLine(&quot;t1,t2,t3 Is Complete&quot;);

            var t4 = Task.Run(() =&amp;gt; { Task.Delay(1500).Wait(); Console.WriteLine(&quot;t4&quot;); });
            var t5 = Task.Run(() =&amp;gt; { Task.Delay(2000).Wait(); Console.WriteLine(&quot;t5&quot;); });
            var t6 = Task.Run(() =&amp;gt; { Task.Delay(3000).Wait(); Console.WriteLine(&quot;t6&quot;); });
            Task.WaitAny(t4, t5, t6);
            // 当任意任务完成时，输出下面的消息，目前按延迟时间计算，在 t4 完成后立即输出下面的信息
            Console.WriteLine(&quot;t4,t5,t6 Is Complete&quot;);

            var t7 = Task.Run(() =&amp;gt; { Task.Delay(1500).Wait(); Console.WriteLine(&quot;t7&quot;); });
            var t8 = Task.Run(() =&amp;gt; { Task.Delay(2000).Wait(); Console.WriteLine(&quot;t8&quot;); });
            var t9 = Task.Run(() =&amp;gt; { Task.Delay(3000).Wait(); Console.WriteLine(&quot;t9&quot;); });
            var whenAll = Task.WhenAll(t7, t8, t9);
            // WhenAll 不会等待，所以这里必须显示指定等待
            whenAll.Wait();
            // 当所有任务完成时，输出下面的消息
            Console.WriteLine(&quot;t7,t8,t9 Is Complete&quot;);

            var t10 = Task.Run(() =&amp;gt; { Task.Delay(1500).Wait(); Console.WriteLine(&quot;t10&quot;); });
            var t11 = Task.Run(() =&amp;gt; { Task.Delay(2000).Wait(); Console.WriteLine(&quot;t11&quot;); });
            var t12 = Task.Run(() =&amp;gt; { Task.Delay(3000).Wait(); Console.WriteLine(&quot;t12&quot;); });
            var whenAny = Task.WhenAll(t10, t11, t12);
            // whenAny 不会等待，所以这里必须显示指定等待
            whenAny.Wait();
            // 当任意任务完成时，输出下面的消息，目前按延迟时间计算，在 t10 完成后立即输出下面的信息
            Console.WriteLine(&quot;t10,t11,t12 Is Complete&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;执行上面的代码输出结果如下-1&quot;&gt;6.2 执行上面的代码，输出结果如下&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201812/26882-20181231010628856-951248355.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;值得注意的是，当调用 WhenAll 方法时，会返回执行任务的状态，此状态是所有任务的统一状态，如果执行了 3 个任务，而其中一个出错，则返回任务状态表示为：Faulted，如果任意任务被取消，则状态为：Canceled；&lt;br/&gt;当调用 WhenAny() 方法时，表示任意任务完成即可表示完成，此时，会返回最先完成的任务信息&lt;br/&gt;注意：WhenAll 和 WhenAny 方法正常执行，无异常，无取消，则所返回的完成状态表示为：RanToCompletion&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本章简要介绍了基于队列的异步任务（TAP）使用方式&lt;/li&gt;
&lt;li&gt;介绍了TAP 运行的方式、以及异常处理&lt;/li&gt;
&lt;li&gt;同时还介绍了如何使用 UI 线程同步上下文对象，以及有条件使用 TAP 的各种方法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;示例代码下载&quot;&gt;示例代码下载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/viter/Ron.TaskDemo.zip&quot; class=&quot;uri&quot;&gt;https://files.cnblogs.com/files/viter/Ron.TaskDemo.zip&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 30 Dec 2018 17:11:00 +0000</pubDate>
<dc:creator>Ron.liang</dc:creator>
<og:description>前言     Task是从 .NET Framework 4 开始引入的一项基于队列的异步任务（TAP）模式，从 .NET Framework 4.5 开始，任</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viter/p/10201228.html</dc:identifier>
</item>
<item>
<title>【原】无脑操作：ElasticSearch学习笔记（01） - {name:&quot;代码屠夫&quot;}</title>
<link>http://www.cnblogs.com/iflytek/p/10192632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iflytek/p/10192632.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;开篇来自于经典的“保安的哲学三问”（你是谁，在哪儿，要干嘛）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题一、ElasticSearch是什么？有什么用处？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答：截至2018年12月28日，从ElasticSearch官网（&lt;a href=&quot;https://www.elastic.co/cn/products&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.elastic.co/cn/products&lt;/span&gt;&lt;/a&gt;）上，得知：ElasticSearch是基于 JSON 的分布式搜索和分析引擎，专为实现水平扩展、高可靠性和管理便捷性而设计。&lt;/span&gt;&lt;span&gt;用于搜索、分析和存储您的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题二、ElasticSearch的由来？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答：大约在2010年，一个叫Shay Banon的待业工程师跟随他的新婚妻子来到伦敦，他的妻子想在伦敦学习做一名厨师。而他在伦敦寻找工作的期间，接触到了Lucene的早期版本，他想为自己的妻子开发一个方便搜索菜谱的应用。直接使用Lucene构建搜索会有很多的坑以及重复性的工作，所以Shay便在Lucene的基础上不断进行抽象来让Java程序嵌入搜索变得更容易一些，经过一段时间的打磨，就诞生了他的第一个开源作品，他给自己的这个作品起了个名字，叫 “Compass”，中文即“指南针”的意思。之后，Shay找到了一份新工作，新工作是处在一个高性能分布式的开发环境中。他在工作中渐渐发现，越来越需要一个易用的高性能、实时、分布式搜索服务，于是他决定重写Compass，将它从一个库打造成了一个独立的server，并将其改名为Elasticsearch。Elasticsearch发布的第一个版本是在2010年的二月份，从那之后，Elasticsearch便成了Github上最受人瞩目的项目之一，并且很快就有超过300名开发者加入进来贡献了自己的代码。后来Shay和另一位合伙人成立了公司专注打造Elasticsearch，他们对Elasticsearch进行了一些商业化的包装和支持。但是，Elasticsearch承诺，永远都将是开源并且免费的。不过悲剧的是，Shay承诺为妻子开发的菜谱搜索应用，到现在还没做出来……（划重点：ElasticSearch基于Lucene）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题三、ElasticSearch有什么功能？有什么优势？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答：截至2018年12月28日，从ElasticSearch官网（&lt;a href=&quot;https://www.elastic.co/cn/products/elasticsearch&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.elastic.co/cn/products/elasticsearch&lt;/span&gt;&lt;/a&gt;）上，得知：Elasticsearch 是一个分布式、Restful风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。&lt;/span&gt;&lt;span&gt;具备存储、查询和分析功能。具备速度、可扩展性、弹性、灵活性、操作友好、客户端库丰富等优势，是开源的、分布式、基于 Restful API、支持 PB 甚至更高数量级的搜索引擎工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、ElasticSearch的安装及结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ElasticSearch支持Windows安装，直接到官网的下载页面（&lt;a href=&quot;https://www.elastic.co/cn/downloads/elasticsearch&quot; target=&quot;_blank&quot;&gt;https://www.elastic.co/cn/downloads/elasticsearch&lt;/a&gt;）下载即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，如果使用ELK全家桶，官方建议ElasticSearch、Logstash、Kibana三个产品选择同一版本号。截至2018年12月28日，ElasticSearch的最新版本是6.5.4。本篇笔记使用的是6.5.0。下载后放在D:\ELK目录下。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/438252/201812/438252-20181228232526384-1791699445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bin：elasticsearch的启动脚本等&lt;/span&gt;&lt;br/&gt;&lt;span&gt;config：配置文件目录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;data：当前节点的分片数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;lib：运行依赖的jar包&lt;/span&gt;&lt;br/&gt;&lt;span&gt;logs：日志文件目录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;modules：模块库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;plugins：插件目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、ElasticSearch的运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Windows版本的Elasticsearch运行还是很简单的，直接在bin目录下，找到elasticsearch.bat这个批处理文件，双击运行就可以了。当然也可以通过命令行窗口进入到该目录下，输入elasticsearch回车进行执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出现如下信息说明Elasticsearch已经启动起来了，并且运行在本机的9200端口上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/438252/201812/438252-20181228234635235-1467113988.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在浏览器的地址栏中输入：localhost:9200，如果能看到如下信息，说明启动成功&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
{
  &quot;name&quot; : &quot;HanF71F&quot;,
  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,
  &quot;cluster_uuid&quot; : &quot;kYp2rOofTwWN1-kj7Qjw_A&quot;,
  &quot;version&quot; : {
    &quot;number&quot; : &quot;6.5.0&quot;,
    &quot;build_flavor&quot; : &quot;default&quot;,
    &quot;build_type&quot; : &quot;zip&quot;,
    &quot;build_hash&quot; : &quot;816e6f6&quot;,
    &quot;build_date&quot; : &quot;2018-11-09T18:58:36.352602Z&quot;,
    &quot;build_snapshot&quot; : false,
    &quot;lucene_version&quot; : &quot;7.5.0&quot;,
    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,
    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;
  },
  &quot;tagline&quot; : &quot;You Know, for Search&quot;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;cluster_name: ElasticSearch配置的集群名称，默认是elasticsearch，es服务会通过广播方式自动连接在同一网段下的es服务，通过多播方式进行通信，同一网段下可以有多个集群，通过集群名称这个属性来区分不同的集群。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cluster_uuid：ElasticSearch配置的集群唯一编号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;build_flavor：编译特点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;lucene_version：ElasticSearch基于lucene的，lucene的版本号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、ElasticSearch的工具&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 结合Chrome浏览器的ElasticSearchHead插件使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载名为chromeFOR.COM_elasticsearch-head_v0.1.3.crx的Chrome插件，安装后，在Chrome浏览器的右上角点击Elastic Search Head这个图标即可使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/438252/201812/438252-20181229213533742-641254148.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 结合Kibana工具使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;个人觉得Kibana是和ElasticSearch结合是很好的，毕竟都是一家的产品。Windows下的Kibana使用也很简单，直接下载同ElasticSearch一样版本的Kibana（&lt;a href=&quot;https://www.elastic.co/downloads/kibana&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.elastic.co/downloads/kibana&lt;/span&gt;&lt;/a&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/438252/201812/438252-20181229004502513-1252644363.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接在bin目录下，找到kibana.bat这个批处理文件，双击运行就可以了。当然也可以通过命令行窗口进入到该目录下，输入kibana回车进行执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出现如下信息说明Kibana已经启动起来了，并且运行在本机的5601端口上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/438252/201812/438252-20181229005834864-1860316964.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在浏览器的地址栏中输入：localhost:5601，如果能看到如下信息，说明Kibana启动成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/438252/201812/438252-20181229153144426-1666348280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、 ElasticSearch的基本术语&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将ElasticSearch和关系型数据库做一个类比&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;关系型数据库&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;⇒&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;数据库(Database)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;⇒&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;表(Table)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;⇒&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;行(Rows)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;⇒&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;列(Columns)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;ElasticSearch&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;⇒&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;索引(Index)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;⇒&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;类型(Type)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;⇒&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;文档(Docments)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;⇒&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;字段(Fields)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;&lt;span&gt;一个ElasticSearch集群可以包含多个索引(数据库)，一个索引中可以包含多个类型(表)，一个类型中可以包含多个文档(行)，一个文档中可以包含多个字段(列)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elasticsearch可以理解为是面向文档型数据库。数据用JSON作为文档序列化的格式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① Near Realtime（NRT）：近实时的意思，表示从写入数据到数据可以被搜索有一个小延迟（大概1秒）；基于es执行搜索和分析可以达到秒级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② Cluster：集群，包含多个节点，每个节点属于哪个集群是通过配置（集群名称，默认是elasticsearch）来决定的，对于中小型应用来说，开始阶段常常一个集群对应一个节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③ Node：节点，集群中的一个节点，节点也有一个名称（默认是随机分配的），在执行运维管理操作时节点名称很重要，默认节点会加入一个名称为“elasticsearch”的集群，如果直接启动一堆节点，那么它们会自动组成一个elasticsearch集群，当然一个节点也可以组成一个elasticsearch集群。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④ Document&amp;amp;field：文档，es中的最小数据单元，一个document可以是一条客户数据，一条商品分类数据，一条订单数据，通常用JSON数据结构表示，每个index下的type中，都可以去存储多个document。一个document里面有多个field，每个field就是一个数据字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;⑤ Index：索引，包含一堆有相似结构的文档数据，比如可以有一个客户索引，商品分类索引，订单索引，索引有一个名称。一个index包含很多document，一个index就代表了一类类似的或者相同的document。比如说建立一个product index，商品索引，里面可能就存放了所有的商品数据，所有的商品document。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;⑥ Type：类型，每个索引里都可以有一个或多个type，type是index中的一个逻辑数据分类，一个type下的document，都有相同的field，比如博客系统，有一个索引，可以定义用户数据type，博客数据type，评论数据type。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;⑦ Shard：单台机器无法存储大量数据，es可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。有了shard就可以横向扩展，存储更多数据，让搜索和分析等操作分布到多台服务器上去执行，提升吞吐量和性能。每个shard都是一个lucene index。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;⑧ Replica：任何一个服务器随时可能故障或宕机，此时shard可能就会丢失，因此可以为每个shard创建多个replica副本。replica可以在shard故障时提供备用服务，保证数据不丢失，多个replica还可以提升搜索操作的吞吐量和性能。primary shard（建立索引时一次设置，不能修改，默认5个），replica shard（随时修改数量，默认1个），默认每个索引10个shard，5个primary shard，5个replica shard，最小的高可用配置，是2台服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、ElasticSearch的基本使用（CRUD）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先对Restful风格的动作有一个了解：GET（查询操作），POST（新增/修改操作），PUT（修改操作），DELETE（删除操作）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下列命令均在Kibana的DevTools中执行，DevTools中输入关键字有相应的提示，很不错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 检查集群的健康状况&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
GET /_cat/health?v
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent
1546176515 13:28:35  elasticsearch green           1         1      1   1    0    0        0             0                  -                100.0%&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;② 查看集群中所有的索引&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
GET /_cat/indices?v
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;health status index     uuid                   pri rep docs.count docs.deleted store.size pri.store.size
green  open   .kibana_1 qqZcESKyTvCWJjF7ToyUWw   1   0          1            0      5.1kb          5.1kb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; ③ 创建索引（可以使用ElasticSearchHead插件的图形化创建方式，也可以手写命令）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
PUT /study_elasticsearch?pretty
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#! Deprecation: the default number of shards will change from [5] to [1] in 7.0.0; if you wish to continue using the default of [5] shards, &lt;br/&gt;you must manage this on the create index request or with an index template
{
  &quot;acknowledged&quot; : true,
  &quot;shards_acknowledged&quot; : true,
  &quot;index&quot; : &quot;study_elasticsearch&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;创建后再次执行查看索引的命令，可以看到这时有两个索引存在了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
GET /_cat/indices?v
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;health status index               uuid                   pri rep docs.count docs.deleted store.size pri.store.size
green  open   .kibana_1           qqZcESKyTvCWJjF7ToyUWw   1   0          1            0      5.1kb          5.1kb
yellow open   study_elasticsearch P1yCgFQiS1Si2Nc0IlZflA   5   1          0            0      1.1kb          1.1kb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;④ 删除索引&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
DELETE /study_elasticsearch?pretty
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;acknowledged&quot; : true
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;删除后再次执行查看索引的命令，可以看到这时剩一个索引存在了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
GET /_cat/indices?v
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;health status index     uuid                   pri rep docs.count docs.deleted store.size pri.store.size
green  open   .kibana_1 qqZcESKyTvCWJjF7ToyUWw   1   0          1            0      5.1kb          5.1kb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;⑤ 新增文档&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT /study_elasticsearch/person/1
{
  &quot;name&quot; : &quot;zhang yang&quot;,
  &quot;age&quot; : 21,
  &quot;job&quot; : &quot;boss&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;error&quot;: {
    &quot;root_cause&quot;: [
      {
        &quot;type&quot;: &quot;cluster_block_exception&quot;,
        &quot;reason&quot;: &quot;blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];&quot;
      }
    ],
    &quot;type&quot;: &quot;cluster_block_exception&quot;,
    &quot;reason&quot;: &quot;blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];&quot;
  },
  &quot;status&quot;: 403
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从错误信息清晰的看到是索引只读的提示，所以考虑放开索引的只读设置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT _settings
{
  &quot;index&quot;: {
    &quot;blocks&quot;: {
      &quot;read_only_allow_delete&quot;: &quot;false&quot;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;acknowledged&quot; : true
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再次尝试新增文档&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT /study_elasticsearch/person/1
{
  &quot;name&quot; : &quot;zhang yang&quot;,
  &quot;age&quot; : 21,
  &quot;job&quot; : &quot;boss&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 1,
  &quot;result&quot; : &quot;created&quot;,
  &quot;_shards&quot; : {
    &quot;total&quot; : 2,
    &quot;successful&quot; : 1,
    &quot;failed&quot; : 0
  },
  &quot;_seq_no&quot; : 0,
  &quot;_primary_term&quot; : 1
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT /study_elasticsearch/person/2
{
  &quot;name&quot; : &quot;zhang xiong jia&quot;,
  &quot;age&quot; : 20,
  &quot;job&quot; : &quot;employee&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;2&quot;,
  &quot;_version&quot; : 1,
  &quot;result&quot; : &quot;created&quot;,
  &quot;_shards&quot; : {
    &quot;total&quot; : 2,
    &quot;successful&quot; : 1,
    &quot;failed&quot; : 0
  },
  &quot;_seq_no&quot; : 0,
  &quot;_primary_term&quot; : 1
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT /study_elasticsearch/person/3
{
  &quot;name&quot; : &quot;wu qing qing&quot;,
  &quot;age&quot; : 22,
  &quot;job&quot; : &quot;manager&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;3&quot;,
  &quot;_version&quot; : 1,
  &quot;result&quot; : &quot;created&quot;,
  &quot;_shards&quot; : {
    &quot;total&quot; : 2,
    &quot;successful&quot; : 1,
    &quot;failed&quot; : 0
  },
  &quot;_seq_no&quot; : 0,
  &quot;_primary_term&quot; : 1
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意，此时的文档版本version为1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;⑥ 查询文档数量&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /study_elasticsearch/person/_count
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;count&quot; : 3,
  &quot;_shards&quot; : {
    &quot;total&quot; : 5,
    &quot;successful&quot; : 5,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;⑦ 查询文档（不加任何查询条件，本篇用的都是Search Lite API的写法）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /study_elasticsearch/person/_search
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;took&quot; : 2,
  &quot;timed_out&quot; : false,
  &quot;_shards&quot; : {
    &quot;total&quot; : 5,
    &quot;successful&quot; : 5,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  },
  &quot;hits&quot; : {
    &quot;total&quot; : 3,
    &quot;max_score&quot; : 1.0,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;study_elasticsearch&quot;,
        &quot;_type&quot; : &quot;person&quot;,
        &quot;_id&quot; : &quot;2&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;zhang xiong jia&quot;,
          &quot;age&quot; : 20,
          &quot;job&quot; : &quot;employee&quot;
        }
      },
      {
        &quot;_index&quot; : &quot;study_elasticsearch&quot;,
        &quot;_type&quot; : &quot;person&quot;,
        &quot;_id&quot; : &quot;1&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;zhang yang&quot;,
          &quot;age&quot; : 21,
          &quot;job&quot; : &quot;boss&quot;
        }
      },
      {
        &quot;_index&quot; : &quot;study_elasticsearch&quot;,
        &quot;_type&quot; : &quot;person&quot;,
        &quot;_id&quot; : &quot;3&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;wu qing qing&quot;,
          &quot;age&quot; : 22,
          &quot;job&quot; : &quot;manager&quot;
        }
      }
    ]
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：对某个索引（Index）下某个类型（Type）没加任何条件的查询，结果默认会展示出前20条文档（Documents）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;⑧ 查询文档（带查询条件，本篇用的都是Search Lite API的写法）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接通过id获取文档：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /study_elasticsearch/person/1
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 1,
  &quot;found&quot; : true,
  &quot;_source&quot; : {
    &quot;name&quot; : &quot;zhang yang&quot;,
    &quot;age&quot; : 21,
    &quot;job&quot; : &quot;boss&quot;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过查询字段的值获取文档：（按age赋值22查询，找到了吴局）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /study_elasticsearch/person/_search?q=age:22
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;took&quot; : 10,
  &quot;timed_out&quot; : false,
  &quot;_shards&quot; : {
    &quot;total&quot; : 5,
    &quot;successful&quot; : 5,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  },
  &quot;hits&quot; : {
    &quot;total&quot; : 1,
    &quot;max_score&quot; : 1.0,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;study_elasticsearch&quot;,
        &quot;_type&quot; : &quot;person&quot;,
        &quot;_id&quot; : &quot;3&quot;,
        &quot;_score&quot; : 1.0,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;wu qing qing&quot;,
          &quot;age&quot; : 22,
          &quot;job&quot; : &quot;manager&quot;
        }
      }
    ]
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过查询字段的值获取文档：（按name赋值zhang查询，找到了名字中有zhang的大小张行长）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /study_elasticsearch/person/_search?q=name:zhang
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;took&quot; : 3,
  &quot;timed_out&quot; : false,
  &quot;_shards&quot; : {
    &quot;total&quot; : 5,
    &quot;successful&quot; : 5,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  },
  &quot;hits&quot; : {
    &quot;total&quot; : 2,
    &quot;max_score&quot; : 0.2876821,
    &quot;hits&quot; : [
      {
        &quot;_index&quot; : &quot;study_elasticsearch&quot;,
        &quot;_type&quot; : &quot;person&quot;,
        &quot;_id&quot; : &quot;2&quot;,
        &quot;_score&quot; : 0.2876821,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;zhang xiong jia&quot;,
          &quot;age&quot; : 20,
          &quot;job&quot; : &quot;employee&quot;
        }
      },
      {
        &quot;_index&quot; : &quot;study_elasticsearch&quot;,
        &quot;_type&quot; : &quot;person&quot;,
        &quot;_id&quot; : &quot;1&quot;,
        &quot;_score&quot; : 0.2876821,
        &quot;_source&quot; : {
          &quot;name&quot; : &quot;zhang yang&quot;,
          &quot;age&quot; : 21,
          &quot;job&quot; : &quot;boss&quot;
        }
      }
    ]
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;⑨ 更新文档（替换）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT /study_elasticsearch/person/1
{
  &quot;name&quot; : &quot;hong zi jun&quot;,
  &quot;age&quot; : 21,
  &quot;job&quot; : &quot;CEO&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 2,
  &quot;result&quot; : &quot;updated&quot;,
  &quot;_shards&quot; : {
    &quot;total&quot; : 2,
    &quot;successful&quot; : 1,
    &quot;failed&quot; : 0
  },
  &quot;_seq_no&quot; : 1,
  &quot;_primary_term&quot; : 1
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：此时id为1的这条文档的版本version变成了2，文档的内容也变成了洪行长&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /study_elasticsearch/person/1
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 2,
  &quot;found&quot; : true,
  &quot;_source&quot; : {
    &quot;name&quot; : &quot;hong zi jun&quot;,
    &quot;age&quot; : 21,
    &quot;job&quot; : &quot;CEO&quot;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这种替换的方式做更新，需要替换的内容和原先的内容字段一致，如果不一致就会用替换内容替换掉原先的内容&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT /study_elasticsearch/person/1
{
  &quot;name&quot; : &quot;ye yu&quot;,
  &quot;gender&quot; : &quot;female&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 3,
  &quot;result&quot; : &quot;updated&quot;,
  &quot;_shards&quot; : {
    &quot;total&quot; : 2,
    &quot;successful&quot; : 1,
    &quot;failed&quot; : 0
  },
  &quot;_seq_no&quot; : 2,
  &quot;_primary_term&quot; : 1
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再次查询，发现person的字段和内容均发生了变化，变成叶阿姨了。显然，这种替换方式的缺点在于全量替换了，不想替换的也被替换了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /study_elasticsearch/person/1
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 3,
  &quot;found&quot; : true,
  &quot;_source&quot; : {
    &quot;name&quot; : &quot;ye yu&quot;,
    &quot;gender&quot; : &quot;female&quot;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;⑩ 更新文档（更新）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先把id为1的数据替换回去&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT /study_elasticsearch/person/1
{
  &quot;name&quot; : &quot;zhang yang&quot;,
  &quot;age&quot; : 21,
  &quot;job&quot; : &quot;boss&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 4,
  &quot;result&quot; : &quot;updated&quot;,
  &quot;_shards&quot; : {
    &quot;total&quot; : 2,
    &quot;successful&quot; : 1,
    &quot;failed&quot; : 0
  },
  &quot;_seq_no&quot; : 3,
  &quot;_primary_term&quot; : 1
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /study_elasticsearch/person/1
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 4,
  &quot;found&quot; : true,
  &quot;_source&quot; : {
    &quot;name&quot; : &quot;zhang yang&quot;,
    &quot;age&quot; : 21,
    &quot;job&quot; : &quot;boss&quot;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用POST结合_update做更新&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /study_elasticsearch/person/1/_update
{
  &quot;doc&quot; : {
    &quot;job&quot; : &quot;CTO&quot;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 5,
  &quot;result&quot; : &quot;noop&quot;,
  &quot;_shards&quot; : {
    &quot;total&quot; : 0,
    &quot;successful&quot; : 0,
    &quot;failed&quot; : 0
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再查询一下，发现id为1的文档的job字段发生了改变，其他的字段及内容没有变化&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /study_elasticsearch/person/1
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 5,
  &quot;found&quot; : true,
  &quot;_source&quot; : {
    &quot;name&quot; : &quot;zhang yang&quot;,
    &quot;age&quot; : 21,
    &quot;job&quot; : &quot;CTO&quot;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;⑪ 删除文档&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
DELETE /study_elasticsearch/person/1
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;_version&quot; : 6,
  &quot;result&quot; : &quot;deleted&quot;,
  &quot;_shards&quot; : {
    &quot;total&quot; : 2,
    &quot;successful&quot; : 1,
    &quot;failed&quot; : 0
  },
  &quot;_seq_no&quot; : 5,
  &quot;_primary_term&quot; : 1
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再查询一下，找不到该条文档了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /study_elasticsearch/person/1
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_index&quot; : &quot;study_elasticsearch&quot;,
  &quot;_type&quot; : &quot;person&quot;,
  &quot;_id&quot; : &quot;1&quot;,
  &quot;found&quot; : false
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果是想删除所有的文档，可以如下操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;POST /study_elasticsearch/person/_delete_by_query
{
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;took&quot; : 42,
  &quot;timed_out&quot; : false,
  &quot;total&quot; : 2,
  &quot;deleted&quot; : 2,
  &quot;batches&quot; : 1,
  &quot;version_conflicts&quot; : 0,
  &quot;noops&quot; : 0,
  &quot;retries&quot; : {
    &quot;bulk&quot; : 0,
    &quot;search&quot; : 0
  },
  &quot;throttled_millis&quot; : 0,
  &quot;requests_per_second&quot; : -1.0,
  &quot;throttled_until_millis&quot; : 0,
  &quot;failures&quot; : [ ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再查询一下，发现没有数据了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
GET /study_elasticsearch/person/_search
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;took&quot; : 0,
  &quot;timed_out&quot; : false,
  &quot;_shards&quot; : {
    &quot;total&quot; : 5,
    &quot;successful&quot; : 5,
    &quot;skipped&quot; : 0,
    &quot;failed&quot; : 0
  },
  &quot;hits&quot; : {
    &quot;total&quot; : 0,
    &quot;max_score&quot; : null,
    &quot;hits&quot; : [ ]
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，最简单基本的操作就讲完了，是不是特别无脑啊(*^_^*)&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 30 Dec 2018 16:00:00 +0000</pubDate>
<dc:creator>{name:&amp;quot;代码屠夫&amp;quot;}</dc:creator>
<og:description>开篇来自于经典的“保安的哲学三问”（你是谁，在哪儿，要干嘛） 问题一、ElasticSearch是什么？有什么用处？ 答：截至2018年12月28日，从ElasticSearch官网（https://</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iflytek/p/10192632.html</dc:identifier>
</item>
<item>
<title>项目优化小计 - 流离</title>
<link>http://www.cnblogs.com/hefilwz/p/10201078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hefilwz/p/10201078.html</guid>
<description>&lt;p&gt;最近对一个老项目进行优化升级&lt;/p&gt;
&lt;p&gt;项目简介：&lt;/p&gt;
&lt;p&gt;通过预设的模型，结合部品属性、历史销量，预测未来十二个月的销量。&lt;/p&gt;
&lt;p&gt;现状：&lt;/p&gt;
&lt;p&gt;1、老项目已在使用，数据库和应用服务器都采用的很好的服务器，每次计算5W个品种，30个模型，耗时5小时。&lt;/p&gt;
&lt;p&gt;2、因为某些原因，项目推广时只能使用个人电脑（2核4线程，数据库为远程连接），而又需要对所有部品进行试算，单机环境下几天还没有算完，马上要到交付客户时间点了。&lt;/p&gt;
&lt;p&gt;经过调研，&lt;/p&gt;
&lt;p&gt;1、该项目代码结构清晰&lt;/p&gt;
&lt;p&gt;2、分层较多且类库命名容易使人在理解上产生混淆，不利于运维。&lt;/p&gt;
&lt;p&gt;3、最重要的一点，单线程串行计算，效率低下，个人电脑下单品种需要大概1分钟。&lt;/p&gt;
&lt;p&gt;优化过程：&lt;/p&gt;
&lt;p&gt;1、因为试算结果的交付时间特别紧迫，而对项目内部模型处理一知半解，未能很好的查到系统瓶颈，一时不好对项目代码进行处理，因此直接简单的使用Orleans进行封装，采用多台电脑分布式计算，先在客户要求的时间内计算一版结果应对项目推广。&lt;/p&gt;
&lt;p&gt;2、通过上述处理，前期推广完成，并采集了自定义的一些日志，结合代码分析，得出结论：模型计算非常快，数据读取较慢，而数据保存从一开始的很快到特别慢且会发生失败。另外，代码分析结果为线程资源完全未利用上、数据库操作无批量。&lt;/p&gt;
&lt;p&gt;     制定优化策略为，利用生产者-消费者模式批量读取数据、批量消费数据，并将线程资源利用上，若仍然不达标，再考虑分布式处理。&lt;/p&gt;
&lt;p&gt;3、落地处理&lt;/p&gt;
&lt;p&gt;     3.1 将模型参数加载、模型计算和模型保存三块分开为三部分，每部分建立多个线程并行处理，并利用BlockingQueue和信号量进行线程同步，然后设定生产者数据容量上限参数、生产者每批读取品种数参数、触发生产者数据读取的阈值（在消费线程消费到该值时触发新数据读取）、各部分线程数参数、批量数据保存量参数。 这期间，既要防止线程空转、控制内存占用，又要尽可能提升各部分的效率。&lt;/p&gt;
&lt;p&gt;     3.2 对于数据的批量保存，对四种方式进行了对比&lt;/p&gt;
&lt;p&gt;             使用Begin End块批处理多行SQL文本（SQL 文本大小和缓存区大小难以控制）&lt;/p&gt;
&lt;p&gt;             使用ODP Bulk导入DataTable（只支持单表内部事务操作，失败时回滚会耗费更长时间）&lt;/p&gt;
&lt;p&gt;             使用Command BIndByName进行参数数组批量操作（对网络要求高，网络不稳定时容易失败，但是支持整体事务）&lt;/p&gt;
&lt;p&gt;             使用async方式异步操作SQL（如果使用await，那么和串行在整体时间耗费上区别不大）&lt;/p&gt;
&lt;p&gt;       最终，考虑最终环境是内网连接，采用了Command BIndByName进行参数数组批量操作，并进行了多批次完整品种测算，无异常发生。&lt;/p&gt;
&lt;p&gt;      3.3 分布式作为最后一个优化点，考虑采用Orleans或者自建，鉴于实际情况，暂未实现。&lt;/p&gt;
&lt;p&gt;  经过优化，全部品种在单机的测算完成时间稳定在30分钟左右，已然达标。&lt;/p&gt;
&lt;p&gt;  这其中的运行环境影响：客户端请求量特别小、 应用服务器的CPU及内存的要求不高、数据库IO和网络IO要求高。&lt;/p&gt;

</description>
<pubDate>Sun, 30 Dec 2018 15:41:00 +0000</pubDate>
<dc:creator>流离</dc:creator>
<og:description>最近对一个老项目进行优化升级 项目简介： 通过预设的模型，结合部品属性、历史销量，预测未来十二个月的销量。 现状： 1、老项目已在使用，数据库和应用服务器都采用的很好的服务器，每次计算5W个品种，30</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hefilwz/p/10201078.html</dc:identifier>
</item>
<item>
<title>Django之路由层 - W的一天</title>
<link>http://www.cnblogs.com/12345huangchun/p/10201112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/12345huangchun/p/10201112.html</guid>
<description>&lt;h3&gt;　　url配置就像Django所支撑网站的目录。它的本质是url与要被该url调用的视图函数之间的映射表；通过这个映射表可以告知Django，对于客户端发来的某个url该执行那些代码。&lt;/h3&gt;
&lt;h2&gt;　　一、简单的路由配置&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path,re_path
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; app01 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views
urlpatterns &lt;/span&gt;=&lt;span&gt; [
    re_path(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^articles/2003/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.special_case_2003),&lt;br/&gt;　　&lt;span&gt;path('articles/2003/',views.special_case_2003),       这一句和上一句的效果一样，path自动加上了开头^和结尾&amp;amp;&lt;/span&gt;
    re_path(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^articles/([0-9]{4})/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.year_archive),
    re_path(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^articles/([0-9]{4})/([0-9]{2})/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.month_archive),     带（）就是分组，只要分组的数据就可以作为位置参数传给视图函数
    re_path(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.article_detail),&lt;br/&gt;　　
]&lt;br/&gt;re.path()相当于要自己写正则来匹配url，如果发过来的url的能匹配上，那就执行相对应的views；&lt;br/&gt;不需要添加一个前导的反斜杠，因为你不用写，它会自动给你加上一个/，如果你写了一个前导的反斜杠，匹配的时候就会成了两个反斜杠，这样会报错的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
 一些请求的例子：

/articles/2005/03/ 请求将匹配列表中的第三个模式。Django 将调用函数views.month_archive(request, '2005', '03')。
/articles/2005/3/ 不匹配任何URL 模式，因为列表中的第三个模式要求月份应该是两个数字。
/articles/2003/ 将匹配列表中的第一个模式不是第二个，因为模式按顺序匹配，第一个会首先测试是否匹配。请像这样自由插入一些特殊的情况来探测匹配的次序。
/articles/2003 不匹配任何一个模式，因为每个模式要求URL 以一个反斜线结尾。
/articles/2003/03/03/ 将匹配最后一个模式。Django 将调用函数views.article_detail(request, '2003', '03', '03')。
   
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;　　二、有名分组&lt;/h2&gt;
&lt;p&gt;　　上面我们说了，带（）就是进行了分组，就会作为位置参数传给视图函数，视图函数也要以位置来区分每个数据，当数据很庞大时，就会混乱；其实我们在正则里面可以给分组的取个名字，如果分组的有名字了就会以关键字参数的形式传给视图函数，此时视图函数就要以每组的名字来接收数据，顺序都是无所谓的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path,re_path

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; app01 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    re_path(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^articles/2003/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.special_case_2003),
    re_path(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^articles/(?P&amp;lt;year&amp;gt;[0-9]{4})/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.year_archive),
    re_path(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^articles/(?P&amp;lt;year&amp;gt;[0-9]{4})/(?P&amp;lt;month&amp;gt;[0-9]{2})/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.month_archive),
    re_path(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^articles/(?P&amp;lt;year&amp;gt;[0-9]{4})/(?P&amp;lt;month&amp;gt;[0-9]{2})/(?P&amp;lt;day&amp;gt;[0-9]{2})/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.article_detail),
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''请求的例子&lt;/span&gt;&lt;span&gt;
    /articles/2005/03/ 请求将调用views.month_archive(request, year='2005', month='03')函数，而不是views.month_archive(request, '2005', '03')。
    /articles/2003/03/03/ 请求将调用函数views.article_detail(request, year='2003', month='03', day='03')。

    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;　　三、分发&lt;/h2&gt;
&lt;p&gt;　　我们知道哈，在每个应用中有views，models，相当于说每个应用有自己的视图文件和模板文件，但没有自己单独的url，在整个项目里面有一个共同的urls，也就就是说大家共用一个urls，其实这样解耦不好，其实我们可以自己为每一个应用加上一个url，再做一个分发就行了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
At any point, your urlpatterns can “include” other URLconf modules. This
essentially “roots” a set of URLs below other ones.

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path,re_path,include
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; app01 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views

urlpatterns &lt;/span&gt;=&lt;span&gt; [
   re_path(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^admin/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, admin.site.urls),
   re_path(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^blog/&amp;amp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, include(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;blog.urls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),       blog就是一个应用，当请求路径为/blog/时，先到全局的urls中找，找到blog.urls,相当于找到了blog应用下的urls，从此，我们就可以把每个应用的路由配置写在自己的urls中
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;　　四、反向解析&lt;/h2&gt;
&lt;p&gt;　　反向解析是挺难理解的。在HTML文件中的a标签需要写一个路径，还有form表单中也是，其实我们不需要直接把路径写上去，可以用一个代号，这样写的好处在于：如果要求我们把HTML中的路径改了，那我们是不是一个一个的把所有的都该了，如果有无数多个，那我们就得该无数次，这样效率太低，但我们用反向解析就一下解决了。&lt;/p&gt;
&lt;p&gt;　　在需要url的地方，对于不同层级，Django提供不同的工具用于url反查：&lt;/p&gt;
&lt;p&gt;　　1，在模板中，使用url模板标签&lt;/p&gt;
&lt;p&gt;　　2，在python代码中，使用from django.urls import reverse&lt;/p&gt;
&lt;p&gt;urls.py:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.conf.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; url

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; . &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
    re_path(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^articles/([0-9]{4})/$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, views.year_archive, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;news-year-archive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在HTML文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;{% url 'news-year-archive' 2012 %}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2012 Archive&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% for yearvar in year_list %}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;{% url 'news-year-archive' yearvar %}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ yearvar }} Archive&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
{% endfor %}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;python逻辑中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reverse
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.http &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HttpResponse，redirect

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; redirect_to_year(request):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
    year = 2006
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; redirect(reverse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;news-year-archive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 同redirect(&quot;/path/&quot;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 30 Dec 2018 15:34:00 +0000</pubDate>
<dc:creator>W的一天</dc:creator>
<og:description>url配置就像Django所支撑网站的目录。它的本质是url与要被该url调用的视图函数之间的映射表；通过这个映射表可以告知Django，对于客户端发来的某个url该执行那些代码。 一、简单的路由配置</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/12345huangchun/p/10201112.html</dc:identifier>
</item>
<item>
<title>Oracle SQL调优记录 - javahih</title>
<link>http://www.cnblogs.com/mzq123/p/10201044.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10201044.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;@&lt;/p&gt;
&lt;h3 id=&quot;一前言&quot;&gt;一、前言&lt;/h3&gt;
&lt;p&gt;本博客只记录工作中的一次oracle sql调优记录，因为数据量过多导致的查询缓慢，一方面是因为业务太过繁杂，关联了太多表。面对复杂的业务场景，确实有些情况是需要关联很多表的。当然有些情况是可以将业务实现放在Java代码里，有些情况可以不要关联很多表。&lt;/p&gt;
&lt;h3 id=&quot;二注意点&quot;&gt;二、注意点&lt;/h3&gt;
&lt;p&gt;对于SQL调优，不要马上就说加索引什么的，加索引不一定就能解决问题的，加错索引，反而会导致查询变慢，&lt;strong&gt;注意加索引的同时也会影响数据库写数据的速度。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;三oracle执行计划&quot;&gt;三、Oracle执行计划&lt;/h3&gt;
&lt;p&gt;对于SQL调优，可以通过Oracle的执行计划来分析。oracle的执行计划确实是对sql进行分析的一种很好的方法。&lt;/p&gt;
&lt;p&gt;下面介绍一下oracle的执行计划。&lt;br/&gt;oracle要使用执行计划的sql为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;explain plan for select 1 from 表格&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过如果是使用PLSQL的话，那就可以使用PLSQL提供的查询执行计划了，PLSQL安装有问题可以参数我以前写的博客：https://blog.csdn.net/u014427391/article/details/56479085&lt;br/&gt;打开PLSQL&lt;br/&gt;工具 -&amp;gt; 首选项 -&amp;gt; 窗口类型 -&amp;gt; 计划窗口 ，在这里加入执行计划需要的参数&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181230222716463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MjczOTE=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找个SQL，用PLSQL执行一下，这是plsql的简单使用&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181230223148866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MjczOTE=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;解释一下这些参数的意思:&lt;br/&gt;基数(Rows)：Oracle估计的当前步骤的返回结果集行数&lt;/p&gt;
&lt;p&gt;字节(Bytes)：执行SQL对应步骤返回的字节数&lt;/p&gt;
&lt;p&gt;耗费(COST)、CPU耗费：Oracle估计的该步骤的执行耗费和CPU耗费&lt;/p&gt;
&lt;p&gt;时间(Time)：Oracle估计的执行sql对于步骤需要的时间&lt;/p&gt;
&lt;p&gt;表访问的几种方法：&lt;br/&gt;TABLE ACCESS FULL(全表扫描)&lt;br/&gt;TABLE ACCESS BY ROWID(通过ROWID的表存取)&lt;br/&gt;TABLE ACCESS BY INDEX SCAN(索引扫描)&lt;br/&gt;...&lt;/p&gt;
&lt;p&gt;oracle执行计划其实就是看一下那些表是按索引扫描的，通过加一些索引实现，TABLE ACCESS BY INDEX SCAN(索引扫描)。&lt;br/&gt;下面给出一篇很详细介绍oracle执行计划的博客&lt;br/&gt;https://www.cnblogs.com/Dreamer-1/p/6076440.html&lt;/p&gt;
&lt;h3 id=&quot;四调优记录&quot;&gt;四、调优记录&lt;/h3&gt;
&lt;h4 id=&quot;强制索引&quot;&gt;4.1 强制索引&lt;/h4&gt;
&lt;p&gt;在加一些索引的过程，有时候会遇到索引失效的情况，这时候可以加强制索引试试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;强制索引
/*+ index(表名别名 索引名称)*/ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如select *from 表格 a，然后加了个索引i，那么就是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*+ index(a i)*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;基数反馈机制&quot;&gt;4.2 基数反馈机制&lt;/h4&gt;
&lt;p&gt;之前同事有遇到一种加了索引还是不起效的情况，后来听他说是是一种基数反馈机制导致的，解决方法是在sql加上，意思是关了基数反馈机制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;基数反馈机制
/*+ opt_param('_optimizer_use_feedback','false')*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select /*+ opt_param('_optimizer_use_feedback','false')*/ a from 表格 &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;oracle开窗函数&quot;&gt;4.3 oracle开窗函数&lt;/h4&gt;
&lt;p&gt;用oracle开窗函数替换group by，oracle的group by有时候是很耗查询的，今天遇到一个sql查询很慢的问题，用oracle开窗函数进行替换group by提高速度。当然这些都是根据实践业务场景来调优的。我遇到的业务场景是适合的。因为关联的表数据量很大。&lt;br/&gt;原来SQL，简单写一下，举个例子，实际的业务场景不是这么简单的sql&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select max(to_number(aa.seq))
            from t_info aa
            where aa.id = ?
                    group by aa.seq&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改造sql：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select seq from (select aa.seq,
                               row_number() over(partition by aa.seq order by aa.date desc nulls last)rn
                          from t_info aa
                       ) where rn=1 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后推荐一本oracle调优书籍《收获，不止SQL优化》一书&lt;/p&gt;
</description>
<pubDate>Sun, 30 Dec 2018 15:05:00 +0000</pubDate>
<dc:creator>javahih</dc:creator>
<og:description>@[toc] 一、前言 本博客只记录工作中的一次oracle sql调优记录，因为数据量过多导致的查询缓慢，一方面是因为业务太过繁杂，关联了太多表。面对复杂的业务场景，确实有些情况是需要关联很多表的。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10201044.html</dc:identifier>
</item>
<item>
<title>Spring Boot 之使用 Json 详解 - 静默虚空</title>
<link>http://www.cnblogs.com/jingmoxukong/p/10200916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingmoxukong/p/10200916.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;h3 id=&quot;spring-boot-支持的-json-库&quot;&gt;Spring Boot 支持的 Json 库&lt;/h3&gt;
&lt;p&gt;Spring Boot 支持三种 Json 库：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Gson&lt;/li&gt;
&lt;li&gt;Jackson&lt;/li&gt;
&lt;li&gt;JSON-B&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Jackson 是 Spring Boot 官方推荐的默认库。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot 提供了 Jackson 的自动配置，Jackson 是 &lt;code&gt;spring-boot-starter-json&lt;/code&gt; 的一部分。当 Jackson 在类路径上时，会自动配置 ObjectMapper bean。&lt;/p&gt;
&lt;p&gt;Spring Boot 提供了 Gson 的自动配置。当 Gson 在 classpath 上时，会自动配置 Gson bean。提供了几个 &lt;code&gt;spring.gson.*&lt;/code&gt; 配置属性来自定义配置。为了获得更多控制，可以使用一个或多个 &lt;code&gt;GsonBuilderCustomizer&lt;/code&gt; bean。&lt;/p&gt;
&lt;p&gt;Spring Boot 提供了 JSON-B 的自动配置。当 JSON-B API 在 classpath 上时，将自动配置 Jsonb bean。首选的 JSON-B 实现是 Apache Johnzon，它提供了依赖关系管理。&lt;/p&gt;
&lt;h3 id=&quot;spring-web-中的序列化反序列化&quot;&gt;Spring Web 中的序列化、反序列化&lt;/h3&gt;
&lt;p&gt;以下注解都是 &lt;code&gt;spring-web&lt;/code&gt; 中提供的支持。&lt;/p&gt;
&lt;h4 id=&quot;responsebody&quot;&gt;&lt;code&gt;@ResponseBody&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;@Responsebody&lt;/code&gt; 注解用于将 Controller 的方法返回的对象，通过适当的 &lt;code&gt;HttpMessageConverter&lt;/code&gt; 转换为指定格式后，写入到 HTTP Response 对象的 body 数据区。一般在异步获取数据时使用。通常是在使用 &lt;code&gt;@RequestMapping&lt;/code&gt; 后，返回值通常解析为跳转路径，加上 @Responsebody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP 响应正文中。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ResponseBody
@RequestMapping(name = &quot;/getInfo&quot;, method = RequestMethod.GET)
public InfoDTO getInfo() {
    return new InfoDTO();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;requestbody&quot;&gt;&lt;code&gt;@RequestBody&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;@RequestBody 注解用于读取 HTTP Request 请求的 body 部分数据，使用系统默认配置的 &lt;code&gt;HttpMessageConverter&lt;/code&gt; 进行解析，然后把相应的数据绑定到要返回的对象上；再把 &lt;code&gt;HttpMessageConverter&lt;/code&gt; 返回的对象数据绑定到 controller 中方法的参数上。&lt;/p&gt;
&lt;p&gt;request 的 body 部分的数据编码格式由 header 部分的 &lt;code&gt;Content-Type&lt;/code&gt; 指定。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(name = &quot;/postInfo&quot;, method = RequestMethod.POST)
public void postInfo(@RequestBody InfoDTO infoDTO) {
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;restcontroller&quot;&gt;&lt;code&gt;@RestController&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;Spring 4 以前：&lt;/p&gt;
&lt;p&gt;如果需要返回到指定页面，则需要用 &lt;code&gt;@Controller&lt;/code&gt; 配合视图解析器 &lt;code&gt;InternalResourceViewResolver&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果需要返回 JSON，XML 或自定义 mediaType 内容到页面，则需要在对应的方法上加上 &lt;code&gt;@ResponseBody&lt;/code&gt; 注解。&lt;/p&gt;
&lt;p&gt;Spring 4 以后，新增了 &lt;code&gt;@RestController&lt;/code&gt; 注解：&lt;/p&gt;
&lt;p&gt;它相当于 &lt;code&gt;@Controller&lt;/code&gt; + &lt;code&gt;@RequestBody&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果使用 &lt;code&gt;@RestController&lt;/code&gt; 注解 Controller，则 Controller 中的方法无法返回 jsp 页面，或者 html，配置的视图解析器 &lt;code&gt;InternalResourceViewResolver&lt;/code&gt; 将不起作用，直接返回内容。&lt;/p&gt;
&lt;h2 id=&quot;指定类的-json-序列化反序列化&quot;&gt;指定类的 Json 序列化、反序列化&lt;/h2&gt;
&lt;p&gt;如果使用 Jackson 序列化和反序列化 JSON 数据，您可能需要编写自己的 &lt;code&gt;JsonSerializer&lt;/code&gt; 和 &lt;code&gt;JsonDeserializer&lt;/code&gt; 类。自定义序列化程序通常通过模块向 Jackson 注册，但 Spring Boot 提供了另一种 &lt;code&gt;@JsonComponent&lt;/code&gt; 注释，可以更容易地直接注册 Spring Beans。&lt;/p&gt;
&lt;p&gt;您可以直接在 &lt;code&gt;JsonSerializer&lt;/code&gt; 或 &lt;code&gt;JsonDeserializer&lt;/code&gt; 实现上使用 &lt;code&gt;@JsonComponent&lt;/code&gt; 注释。您还可以在包含序列化程序/反序列化程序作为内部类的类上使用它，如以下示例所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.*;
import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import org.springframework.boot.jackson.*;

@JsonComponent
public class Example {

    public static class Serializer extends JsonSerializer&amp;lt;SomeObject&amp;gt; {
        // ...
    }

    public static class Deserializer extends JsonDeserializer&amp;lt;SomeObject&amp;gt; {
        // ...
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt; 中的所有 &lt;code&gt;@JsonComponent&lt;/code&gt; bean 都会自动注册到 Jackson。因为 &lt;code&gt;@JsonComponent&lt;/code&gt; 是使用 &lt;code&gt;@Component&lt;/code&gt; 进行元注释的，所以通常的组件扫描规则适用。&lt;/p&gt;
&lt;p&gt;Spring Boot 还提供了 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java&quot;&gt;&lt;code&gt;JsonObjectSerializer&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java&quot;&gt;&lt;code&gt;JsonObjectDeserializer&lt;/code&gt;&lt;/a&gt; 基类，它们在序列化对象时提供了标准 Jackson 版本的有用替代方法。有关详细信息，请参阅 Javadoc 中的 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/jackson/JsonObjectSerializer.html&quot;&gt;&lt;code&gt;JsonObjectSerializer&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/jackson/JsonObjectDeserializer.html&quot;&gt;&lt;code&gt;JsonObjectDeserializer&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;jsontest&quot;&gt;@JsonTest&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;@JsonTest&lt;/code&gt; 可以很方便的在 Spring Boot 中测试序列化、反序列化。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;@JsonTest&lt;/code&gt; 相当于使用以下自动配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration org.springframework.boot.test.autoconfigure.json.JsonTestersAutoConfiguration&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@JsonTest&lt;/code&gt; 使用示例：&lt;/p&gt;
&lt;p&gt;想试试完整示例，可以参考：&lt;a href=&quot;https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/web/sbe-web-json&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@JsonTest
@RunWith(SpringRunner.class)
public class SimpleJsonTest {

    private final Logger log = LoggerFactory.getLogger(this.getClass());

    @Autowired
    private JacksonTester&amp;lt;InfoDTO&amp;gt; json;

    @Test
    public void testSerialize() throws Exception {
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        InfoDTO infoDTO = new InfoDTO(&quot;JSON测试应用&quot;, &quot;1.0.0&quot;, sdf.parse(&quot;2019-01-01 12:00:00&quot;));
        JsonContent&amp;lt;InfoDTO&amp;gt; jsonContent = json.write(infoDTO);
        log.info(&quot;json content: {}&quot;, jsonContent.getJson());
        // 或者使用基于JSON path的校验
        assertThat(jsonContent).hasJsonPathStringValue(&quot;@.appName&quot;);
        assertThat(jsonContent).extractingJsonPathStringValue(&quot;@.appName&quot;).isEqualTo(&quot;JSON测试应用&quot;);
        assertThat(jsonContent).hasJsonPathStringValue(&quot;@.version&quot;);
        assertThat(jsonContent).extractingJsonPathStringValue(&quot;@.version&quot;).isEqualTo(&quot;1.0.0&quot;);
        assertThat(jsonContent).hasJsonPathStringValue(&quot;@.date&quot;);
        assertThat(jsonContent).extractingJsonPathStringValue(&quot;@.date&quot;).isEqualTo(&quot;2019-01-01 12:00:00&quot;);
    }

    @Test
    public void testDeserialize() throws Exception {
        String content = &quot;{\&quot;appName\&quot;:\&quot;JSON测试应用\&quot;,\&quot;version\&quot;:\&quot;1.0.0\&quot;,\&quot;date\&quot;:\&quot;2019-01-01\&quot;}&quot;;
        InfoDTO actual = json.parseObject(content);
        assertThat(actual.getAppName()).isEqualTo(&quot;JSON测试应用&quot;);
        assertThat(actual.getVersion()).isEqualTo(&quot;1.0.0&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-boot-中的-json-配置&quot;&gt;Spring Boot 中的 json 配置&lt;/h2&gt;
&lt;h3 id=&quot;jackson-配置&quot;&gt;Jackson 配置&lt;/h3&gt;
&lt;p&gt;当 Spring Boot 的 json 库为 jackson 时，可以使用以下配置属性（对应 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jackson/JacksonProperties.java&quot;&gt;&lt;code&gt;JacksonProperties&lt;/code&gt;&lt;/a&gt; 类）：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring.jackson.date-format= # Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.
spring.jackson.default-property-inclusion= # Controls the inclusion of properties during serialization. Configured with one of the values in Jackson's JsonInclude.Include enumeration.
spring.jackson.deserialization.*= # Jackson on/off features that affect the way Java objects are deserialized.
spring.jackson.generator.*= # Jackson on/off features for generators.
spring.jackson.joda-date-time-format= # Joda date time format string. If not configured, &quot;date-format&quot; is used as a fallback if it is configured with a format string.
spring.jackson.locale= # Locale used for formatting.
spring.jackson.mapper.*= # Jackson general purpose on/off features.
spring.jackson.parser.*= # Jackson on/off features for parsers.
spring.jackson.property-naming-strategy= # One of the constants on Jackson's PropertyNamingStrategy. Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.
spring.jackson.serialization.*= # Jackson on/off features that affect the way Java objects are serialized.
spring.jackson.time-zone= #  Time zone used when formatting dates. For instance, &quot;America/Los_Angeles&quot; or &quot;GMT+10&quot;.
spring.jackson.visibility.*= # Jackson visibility thresholds that can be used to limit which methods (and fields) are auto-detected.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gson-配置&quot;&gt;GSON 配置&lt;/h3&gt;
&lt;p&gt;当 Spring Boot 的 json 库为 gson 时，可以使用以下配置属性（对应 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/gson/GsonProperties.java&quot;&gt;&lt;code&gt;GsonProperties&lt;/code&gt;&lt;/a&gt; 类）：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;spring.gson.date-format= # Format to use when serializing Date objects.
spring.gson.disable-html-escaping= # Whether to disable the escaping of HTML characters such as '&amp;lt;', '&amp;gt;', etc.
spring.gson.disable-inner-class-serialization= # Whether to exclude inner classes during serialization.
spring.gson.enable-complex-map-key-serialization= # Whether to enable serialization of complex map keys (i.e. non-primitives).
spring.gson.exclude-fields-without-expose-annotation= # Whether to exclude all fields from consideration for serialization or deserialization that do not have the &quot;Expose&quot; annotation.
spring.gson.field-naming-policy= # Naming policy that should be applied to an object's field during serialization and deserialization.
spring.gson.generate-non-executable-json= # Whether to generate non executable JSON by prefixing the output with some special text.
spring.gson.lenient= # Whether to be lenient about parsing JSON that doesn't conform to RFC 4627.
spring.gson.long-serialization-policy= # Serialization policy for Long and long types.
spring.gson.pretty-printing= # Whether to output serialized JSON that fits in a page for pretty printing.
spring.gson.serialize-nulls= # Whether to serialize null fields.&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spring-boot-中使用-fastjson&quot;&gt;Spring Boot 中使用 Fastjson&lt;/h2&gt;
&lt;p&gt;国内很多的 Java 程序员更喜欢使用阿里的 fastjson 作为 json lib。那么，如何在 Spring Boot 中将其替换默认的 jackson 库呢？&lt;/p&gt;
&lt;p&gt;你需要做如下处理：&lt;/p&gt;
&lt;p&gt;（1）引入 fastjson jar 包：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.54&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）实现 WebMvcConfigurer 接口，自定义 &lt;code&gt;configureMessageConverters&lt;/code&gt; 接口。如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    private final Logger log = LoggerFactory.getLogger(this.getClass());

    /**
     * 自定义消息转换器
     * @param converters
     */
    @Override
    public void configureMessageConverters(List&amp;lt;HttpMessageConverter&amp;lt;?&amp;gt;&amp;gt; converters) {
        // 清除默认 Json 转换器
        converters.removeIf(converter -&amp;gt; converter instanceof MappingJackson2HttpMessageConverter);

        // 配置 FastJson
        FastJsonConfig config = new FastJsonConfig();
        config.setSerializerFeatures(SerializerFeature.QuoteFieldNames, SerializerFeature.WriteEnumUsingToString,
            SerializerFeature.WriteMapNullValue, SerializerFeature.WriteDateUseDateFormat,
            SerializerFeature.DisableCircularReferenceDetect);

        // 添加 FastJsonHttpMessageConverter
        FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();
        fastJsonHttpMessageConverter.setFastJsonConfig(config);
        List&amp;lt;MediaType&amp;gt; fastMediaTypes = new ArrayList&amp;lt;&amp;gt;();
        fastMediaTypes.add(MediaType.APPLICATION_JSON_UTF8);
        fastJsonHttpMessageConverter.setSupportedMediaTypes(fastMediaTypes);
        converters.add(fastJsonHttpMessageConverter);

        // 添加 StringHttpMessageConverter，解决中文乱码问题
        StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter(Charset.forName(&quot;UTF-8&quot;));
        converters.add(stringHttpMessageConverter);
    }

    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;示例源码&quot;&gt;示例源码&lt;/h2&gt;
&lt;p&gt;完整示例：&lt;a href=&quot;https://github.com/dunwu/spring-boot-tutorial/tree/master/codes/web/sbe-web-json&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;引申和引用&quot;&gt;引申和引用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;引申&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 30 Dec 2018 14:23:00 +0000</pubDate>
<dc:creator>静默虚空</dc:creator>
<og:description>Spring Boot 之使用 Json 详解 &lt;! TOC depthFrom:2 depthTo:3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jingmoxukong/p/10200916.html</dc:identifier>
</item>
<item>
<title>前端——CSS - 学霸初养成</title>
<link>http://www.cnblogs.com/V587Chinese/p/10200801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/V587Chinese/p/10200801.html</guid>
<description>&lt;p&gt;&lt;span&gt;CSS是英文Cascading Style Sheets的缩写,称为层叠样式表，用于对页面进行美化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;存在方式有三种：元素内联、页面嵌入和外部导入，比较三种方式的优缺点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语法：style = &quot;key1:value1;key2:value2;&quot;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在标签中使用 style=&quot;xx:xxx;&quot;（任何一个标签都可以使用style属性来编写样式）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在页面中嵌入 &amp;lt; style type=&quot;text/css&quot; href=&quot;css文件路径&quot; rel=&quot;stylesheet&quot;&amp;gt; &amp;lt;/style &amp;gt; 块(rel可省略)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;导入外部css文件&amp;lt;style&amp;gt; @important&quot;yangshi.css&quot;  &amp;lt;/style&amp;gt; 引号内路径是url的格式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;导入式会在网页装载完后再装载CSS文件，嵌入式在网页主体装载前装载CSS文件，因此显示出来的网页一开始就是带样式效果的，不会像导入式先显示无样式网页再显示有样式网页。这是页面嵌入方式的优点。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;必要性：美工会对页面的色彩搭配和图片的美化负责，开发人员则必须知道是如何实现的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;CSS选择器（编写CSS样式）&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;选择器指的是，在&amp;lt;head&amp;gt;标签中的&amp;lt;style&amp;gt;标签中编写样式（或在CSS文件中编写），在&amp;lt;body&amp;gt;内的标签来选择已经写好的样式，提高了重用率，减轻了body中的代码臃肿。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;一、基本选择器&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;　　 &lt;span&gt;1.id选择器(不建议用)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　&lt;span&gt;样式编写以#开头，标签选择用id属性，每个标签使用的id都不能相同（唯一配对）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　#名称{   ........   }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&amp;lt;标签 id=&quot;名称&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　2.标签选择器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　如下所示，将所有div标签设置成此样式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　div{  ……  }&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　3.class样式选择器(最常用)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　样式编写以 . 开头，可以使用相同的设置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　.名称{   ........   }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　&amp;lt;标签 class=&quot;名称&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　4.通用选择器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　使用*选择所有元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　*{color:black}&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;二、组合选择器&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;　　&lt;span&gt;1.并集选择器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　并列关系，用逗号隔开&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　.c1,.c2,div{   ………   }  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&amp;lt;!-- class=&quot;c1&quot; 或 class=&quot;c2&quot; 或 所有div标签都能应用此设置--&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　2.层级选择器（后代选择器，常用）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　　样式的选择具有层级关系，类似于目录(用空格隔开)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　span div{  ………  }   &amp;lt;!--所有span标签内的div标签应用此设置--&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　.c1 div{   ………   }    &amp;lt;!--应用c1的标签内的div标签应用此设置--&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　.c1 .c2{   ………   }    &amp;lt;!--应用c1的标签内的标签才能应用此设置--&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
div&amp;gt;p{ …… }           儿子选择器：从div的子标签中找到p标签，设置样式
div + p{ ....... }    毗邻选择器：匹配所有紧邻div元素之后的同级p元素
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;三、属性选择器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;先做一遍筛选，对筛选出来的标签根据属性再做筛选，并设置该样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　格式：标签名 [ 属性 = &quot;值&quot; ]{ …编写的样式… }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如：input[name=&quot;alex&quot;]{width:10px;height:20px;}            &amp;lt;!-- 先筛选出来所有input标签，再筛选出来属性name为alex的标签，设置样式 --&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　.c1[type=&quot;password&quot;]{height:40px;width:30px;}        &amp;lt;!-- 先筛选出来所有应用c1样式的标签，再筛选属性type为password的标签，设置样式 --&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
E[att]         匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如“[cheacked]”。以下同。）   p[title] { color:#f00; }
E[att=val]     匹配所有att属性等于“val”的E元素                                 input[type=”text”] { background-color:#f00; }
E[att~=val]    匹配所有att属性具有多个空格分隔的值、其中一个值等于“val”的E元素      td[class~=”name”] { color:#f00; }
E[attr^=val]    匹配属性值以指定值开头的每个元素                     div[class^=&quot;test&quot;]{background:#ffff00;}
E[attr$=val]    匹配属性值以指定值结尾的每个元素                     div[class$=&quot;test&quot;]{background:#ffff00;}
E[attr*=val]    匹配属性值中包含指定值的每个元素                     div[class*=&quot;test&quot;]{background:#ffff00;}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;四、伪类选择器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; CSS伪类是用来给选择器添加一些特殊效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a:link{ ... }         没有访问的超链接的样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a:visited{ ... }　 访问过的额超链接的样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a:hover{ ... }      鼠标悬浮在标签上方的样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a:active{ ... }      鼠标点击瞬间的样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　input:focus{ ... } input输入框获取焦点时的样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　:before{ ... }       在元素内容前面插入新内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　:after{ ... }　　　在元素内容后面插入新内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　:first-letter{ ... }  为文本首字母设置特殊样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在定义a标签样式时，因为浏览器按照就近原则来解释css，定义的顺序不同，显示的效果就不同。&lt;strong&gt;正确的顺序是：&lt;/strong&gt;a:link 、a:visited 、a:hover 、a:active&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;style type=&quot;text/css&quot;&amp;gt;
    a:link{
        color: red;
    }
    a:visited {
        color: blue;
    }
    a:hover {
        color: green;
    }
    a:active {
        color: yellow;
    }
    p:before{content:&quot;hello&quot;;color:red}
    p:after{ content:&quot;hello&quot;；color:red}
&amp;lt;/style&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;a href=&quot;01-hello-world.html&quot;&amp;gt;hello-world&amp;lt;/a&amp;gt;
    &amp;lt;p&amp;gt;你好&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;伪类标签还可以这样用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;head&amp;gt;
    /*当鼠标移动到应用menu样式的标签上时，它下面应用b的标签应用一下样式*/
        .pg-head .menu:hover .b{
            color: red;
        }
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;a class=&quot;menu&quot;&amp;gt;&amp;lt;span class=&quot;b&quot;&amp;gt;1024&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：必须是&amp;lt;a&amp;gt;标签内的子标签才可以应用，如果改成&amp;lt;a class=&quot;menu b&quot;&amp;gt;，企图将以上样式应用于自己本身是无法实现的&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;五、CSS优先级和继承&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;　　&lt;span&gt;CSS优先级：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　应用的优先级，按照选择器的权重规则来决定。当权重相同时，按照就近原则：style内联 &amp;gt; 书写距离近 &amp;gt; 书写距离远。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
内联样式权重为     1000
ID选择器权重为     100
class选择器权重为  10
元素选择器权重为    1
权重计算永不进位
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;head&amp;gt;
    &amp;lt;style&amp;gt;
        .c1{
        background:red;
        color:white;
        }
        .c2{
        background:black;
        font-size:58px;
        color:black;
        }
    .h1 .h_logo{
        display:inline-block;
        font-size:2.7rem;
        line-height:50px;
        color:red;
    }
    #i1{
        color:black;
    }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;c1 c2&quot; style=&quot;color:green&quot;&amp;gt;wooohoo&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;h1&quot;&amp;gt;
        &amp;lt;div id=&quot;i1&quot; class=&quot;h_logo&quot;&amp;gt;nihao&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;!-- c1和c2权重相同 color属性根据就近原则被应用绿色，background属性被应用黑色 --&amp;gt;
&amp;lt;!-- h_logo权重为20，i1权重为100，color应用黑色 --&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;　　CSS的继承&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;继承是CSS的一个主要特征，它是依赖于祖先-后代的关系的。继承是一种机制，它允许样式不仅可以应用于某个特定的元素，还可以应用于它的后代。例如body中定义了字体颜色，它也会应用到字标签的文本中。然而CSS继承性的权重是非常低的，是比普通元素的权重还要低的0。因此任何显示申明的规则都可以覆盖其继承样式。　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外，CSS继承也是有限制的，有一些属性不能被继承，如：border，margin，padding，background等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;另外：&lt;/strong&gt;!important 声明方式强制样式生效，不推荐使用，因为大量使用 !inportant 的代码是无法维护的。如果!important声明冲突，则比较优先权。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;基本样式&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;标签大小&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　高度：          height&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　宽度：          width&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最小宽度：   min-width   &amp;lt;!--当浏览器窗口缩小到一定程度时，可能会导致页面混乱，设置最小宽度可以避免这个问题--&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;字体文本&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　字体：         font-famliy: &quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;, &quot;Arial&quot;;     如果系统不支持第一个字体，会尝试下一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　文本大小：   font-size：20px / 50% / 1rem；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　字体粗细：   font-weight         取值：normal(默认值)，bold粗体(700)，bolder(更粗)，lighter(更细)，设置具体值(100-900)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　字体颜色：   color                    取值：①十六进制值：＃FF0000；②颜色名称：red；③RGB值：rgb(255,0,0)；④RGBA值：rgba(255,0,0,0.5)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　水平对齐：　text-align            取值：left(默认)，right，center，justify(两端对齐)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　行高：　       line-height         可以调整水平居中：标签多高，这里就要设置多高&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　垂直对齐：   vertical-align  设置元素的垂直对齐方式，只对行内元素有效。常用值：top，text-top，bottom，text-bottom，middle，像素值，百分比。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　文字装饰：　text-decoration    取值：none(默认)，underline(文本下划线)，overline(文本上划线)，line-through(穿过文本的一条线)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　字体的风格：font-sytle              取值：normal，italic(斜体)，oblique(倾斜)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首行缩进：　text-ident　　　   取值：像素值，百分比。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　字符间距：   letter-spacing　　取值：normal，像素值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　字间距：　　word-spacing　　取值：normal，像素值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　控制文本大小写：text-transform  取值：none(默认)，capitalize(单词首字母大写)，uppercase(全部大写)，lowercase(全部小写)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　文本阴影效果：text-shadow     取值：h(必需)水平阴影的位置，v(必需)垂直阴影的位置，blur模糊的距离，color阴影的颜色。例：text-shadow: 1px 3px 5px #FF0000;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　换行：　　　word-break          取值：normal(浏览器默认的换行规则)，break-all(允许在单词内换行)，keep-all(只能在半角空格或字符处换行)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　word-wrap　　　 取值：normal(浏览器默认的换行规则)，break-word(允许长单词或url地址内部换行)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　浏览器默认换行规则：中文自动换行，英文数字以单词为最小单位(空格间隔)自动换行，如果一连串字符没有空格，浏览器认为它是一个单词不予换行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于RGB(A)色彩模式：rgba(red,green,blue,alpha) ，其中alpha取值0~1，表示透明度。red，green，blue三个参数取值0~255，也可用百分比。色彩模式与RGB相同（通过对红绿蓝三个颜色通道的变化和他们相互之间的叠加来得到各式各样的颜色。（0，0，0）表示黑色，（255，255，255）表示白色）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;背景  background&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　background 分为以下几类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　background-color              背景颜色设置为红色 如：background-color:red;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　background-image            设置背景图片 如：background-image::url(&quot;image/4.jpg&quot;); &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　background-size　　　　　设置背景图片的尺寸，有三类可选的值：宽高（px值或百分比，1或2个值）、cover、contain。如：background-size:10px 10px;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　background-repeat            如果设置了背景图片，这个属性则可以设置重复平铺。默认是no-repeat不平铺。还可以设置repeat表示背景图片横向纵向都平铺。 repeat-x表示只在横向平铺，repeat-y表示只在纵向平铺。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　background-position         设置背景图片的起始位置。如：background-position：center | right bottom | top center | left bottom | 10% 20% | 50px 60px 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　background-origin             规定background-position属性相对什么来定位。值：padding-box | border-box | content-box ，分别表示相对于内边距框定位、相对边框定位、相对内容框定位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　background-clip　　　　　规定背景的绘制区域，值：border-box | padding-box | content-box ，分别表示背景被剪裁到边框、内边距框，内容框。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　background-scroll　　　　规定背景图像是否固定或随页面滚动。 值：scroll(默认)随着滚动，fixed图像不会移动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果将背景图片加在body上，要设置body的高度，否则无法撑起背景图片。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span data-mce-=&quot;&quot;&gt;边框  border&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;　　样式：border: 宽度 样式 颜色  。样式中：dotted表示点线，dashed表示虚线，solid表示实线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;　　如：border：2px dotted red;  &amp;lt;!-- 2像素宽度，虚线，红色 --&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;　　可以拆分成：border-width :2px；border-style :dotted；border-color :red；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;　　border-radius:50% &amp;lt;!--可将图片变成圆形(如果长宽一致)，数值可以是百分比或像素值，两者效果不完全一样--&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span data-mce-=&quot;&quot;&gt;列表属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;　　针对ul，ol的设置，list-style 是一个简写属性，包括了list-style-type，list-style-position，list-style-image&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;　　list-style-type：设置列表项标记的类型。none(无标记)，disc(默认，实心圆)，circle(空心圆)，square(方块)，decimal(数字)......等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;　　list-style-position：设置在何处放置列表项标记。inside(放在文本内)，outside(默认值，放在文本的左侧)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;　　list-style-image：使用图像来替换列表项的标记。（请始终规定一个list-style-type属性以防图像不可用）URL(图像的路径)，none(默认，无图像)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;display&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　 可以将标签设为行内或块级属性。设置 inline 为行内，设置 block 为块级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果设置 inline-block 则同时具有：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　inline的属性：默认自己有多少空间占多少空间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　block的属性：可以设置高度，宽度，边距      （ 行内标签不能设置高度和宽度，而块级标签可以）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　值为none，则隐藏标签，不显示也不占据页面空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　※ inline-block的间隙&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
    &amp;lt;style&amp;gt;
        a{
            display: inline-block;
            background-color: #2459a2;
            width: 100px;
            height: 100px;
        }
    &amp;lt;/style&amp;gt;

&amp;lt;a&amp;gt;111&amp;lt;/a&amp;gt;
&amp;lt;a&amp;gt;222&amp;lt;/a&amp;gt;
&amp;lt;a&amp;gt;333&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;(1) 我们可以通过margin:-3px来解决，但是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.我们布局肯定很多元素，不可能每个都添加margin负这样维护成本太大了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.我们线上代码如果压缩，那么我们就不存在哪个4px的问题了，那么我们的margin负就回造成布局混乱！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2)我们可以给几个标签加一个父级div，然后：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
div{word-spacing: -5px;}　　设置字间距
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;visibility &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　该属性可设置元素是否可见，与display：none不同的是，visibility：hidden会不可见，但占据页面空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　值：visible 默认值，可见的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　hidden 隐藏&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;内边距和外边距（margin padding）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1354918/201809/1354918-20180906174415708-1075479306.png&quot; alt=&quot;&quot; width=&quot;222&quot; height=&quot;187&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1354918/201809/1354918-20180906174555586-217953860.jpg&quot; alt=&quot;&quot; width=&quot;296&quot; height=&quot;186&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;span&gt;&lt;strong&gt;外边距 margin&lt;/strong&gt;    用于控制元素与元素之间的距离。当margin值增加时，与父标签上左右距离增加，标签本身的大小被强制变化。但如果单独设置某一边距时，标签大小不会变化（margin-top 上边距，margin-left 左边距，margin-right 右边距，margin-bottom 下边距。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;内边距 padding &lt;/strong&gt; 用于控制内容与边框的距离。当padding值增加时，将会改变本身的大小（padding-top，padding-left，padding-right，padding-bottom是常用的方法）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　※ 重要：&lt;/strong&gt;当指定一个标签的宽高度时，设置的只是&lt;strong&gt;内容区&lt;/strong&gt;的大小。实际标签的大小，还要加上边距和边框。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
margin:10px 5px 15px 20px;-----------上 右 下 左
margin:10px 5px 15px;----------------上 右左 下
margin:10px 5px;---------------------上下  右左
margin:10px;    ---------------------上右下左
常用： margin: 0 auto; 表示与父标签上边距为0，左右居中。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面的例子中的元素的总宽度为300px：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
width:250px;
padding:10px;
border:5px solid gray;
margin:10px;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 &lt;span&gt;&lt;strong&gt;※ 思考：&lt;/strong&gt;边框在默认情况下会定位于浏览器窗口的左上角，但是并没有紧贴着浏览器的窗口的边框，这是因为body本身也是一个盒子（外层还有html），在默认情况下，body距离html会有若干像素的margin，具体数值因各个浏览器不尽相同，所以body中的盒子不会紧贴浏览器窗口的边框了，解决方法：body{ margin:0; }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;※ 思考：&lt;/strong&gt;边界重叠（margin collapse）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　外边距的重叠只产生在普通流文档的上下外边距之间，这个看起来有点奇怪的规则，其实有其现实意义。设想，当我们上下排列一系列规则的块级元素（如段     落P）时，那么块元素之间因为外边距重叠的存在，段落之间就不会产生双倍的距离。又比如停车场。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　兄弟div：上面div的margin-bottom和下面div的margin-top会塌陷，也就是会取上下两者margin里最大值作为显示值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　父子div：如果父标签没有设置内边距padding、边框border、文本内容inline content。子标签与父标签之间将不会体现外边距(即使设置)，字标签的margin将会一直向上找，直到找到某个标签有padding、border、inline content中的任何一个，将外边距体现在这里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot; style=&quot;padding: 0px&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;

        body{
            margin: 0px;
        }

        .div1{
            background-color: aqua;
            width: 300px;
            height: 300px;
        }
        .div2{
            background-color: blueviolet;
            width: 100px;
            height: 100px;
            margin: 20px;

        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;div style=&quot;width: 300px;height: 300px&quot;&amp;gt;&amp;lt;/div&amp;gt;

       &amp;lt;div class=&quot;div1&quot;&amp;gt;
           &amp;lt;div class=&quot;div2&quot;&amp;gt;&amp;lt;/div&amp;gt;
           &amp;lt;div class=&quot;div2&quot;&amp;gt;&amp;lt;/div&amp;gt;
       &amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;解决方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
父子div： 1.父标签设置透明边框    border:1px solid transparent;
            2.父标签设置内边距   padding:1px;
            3.在父标签内加文本内容
            4.给父标签设置overflow:hidden
兄弟div：1.float浮动      2.display:inline-block
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;浮动 float&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;　　首先了解块级元素和行内元素在文档流中的排列方式&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;block块级元素：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　block元素独占一行，每个块级元素会各自新起一行，默认块级元素宽度会填满父标签宽度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　block元素可以设置宽高、内外边距。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;inline行内元素：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　行内元素不会独占一行，多个行内元素会共同存在一行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　不能设置宽高，可以设置水平方向padding、margin，不能设置垂直方向padding、margin。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;文档流，&lt;/strong&gt;指的是元素排版布局过程中，元素会自动从左向右，从上到下的流式排列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;脱离文档流，&lt;/strong&gt;也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;只有绝对定位position：absolute/fixed和浮动float才会脱离文档流。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;　　部分无视和完全无视的区别？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　需要注意的是，使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围(可以说是部分无视)。而对于使用absolute position脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它。(可以说是完全无视)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　浮动的表现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      定义：浮动的框可以向左或向右浮动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的标准流中，所以文档的普通流中的浮动框之后的块框表现得就像浮动框不存在一样。（float只对块级元素起作用）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意 当初float被设计的时候就是用来完成文本环绕的效果，所以文本不会被挡住，这是float的特性，即float是一种不彻底的脱离文档流方式。&lt;/strong&gt;无论多么复杂的布局，其基本出发点均是：“&lt;strong&gt;如何在一行显示多个div元素&lt;/strong&gt;”。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;清除浮动 clear&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;  语法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       clear : none | left | right | both&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       取值：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       none  :  默认值。允许两边都可以有浮动对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       left   :  不允许左边有浮动对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       right  :  不允许右边有浮动对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       both  :  不允许有浮动对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的定义非常容易理解，但是读者实际使用时可能会发现不是这么回事。 定义没有错，只不过它描述的太模糊，让我们不知所措。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;案例：先写一个&amp;lt;div&amp;gt;大方块背景灰色，里面有三个小方块&amp;lt;div&amp;gt;从左到右背景分别是红、绿、蓝。如果不浮动，三个方块分别占三行。现在给三个小方块都加上样式 float:left; 它们会依次从左到右排列，并且共占一行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1354918/201808/1354918-20180802171358933-141920802.jpg&quot; alt=&quot;&quot; width=&quot;207&quot; height=&quot;79&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我现在想要使红色方块右边的方块清除掉，按照我们的想法就是给红色设置 clear:right; 然而却并没有任何效果。正确的用法是给绿色设置 clear:left;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1354918/201808/1354918-20180802171440072-780965603.jpg&quot; alt=&quot;&quot; width=&quot;201&quot; height=&quot;81&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;所以一定要牢记：对于CSS的清除浮动规则，只能影响使用清除元素的本身，不能影响其它元素。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们明白了如何用，那它的独特之处在哪里？如果现在有需求：要求绿色不浮动，它的上下都有标签要浮动，怎么实现呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果直接删除绿色的float:left;代码，会发现，绿色被蓝色覆盖了。是因为块级标签一旦浮动，会脱离标准流，位于标准流的上层。解决办法是，在删除绿色的float代码后加上clear:left;即可。看上去三个方块一次纵向排列，好像没有设置什么属性，实际上红色和蓝色可以和其他标签浮动堆叠，绿色不可以。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一个场景非常实用：在刚才的示例基础上，把灰色块的高度设置删掉，界面上灰色会消失，此时的需求是：使父标签包裹住所有子标签。怎么做呢？   只需要在父标签内最底部再写一个&amp;lt;div&amp;gt;标签，样式设置 clear:both; 即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1354918/201808/1354918-20180802172318896-2005055192.jpg&quot; alt=&quot;&quot; width=&quot;206&quot; height=&quot;69&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;父标签紧紧包裹住字标签且不需要设置父标签高度（清除浮动）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
    &amp;lt;div style=&quot;width:500px;background:#b0b0b0;&quot;&amp;gt;
        &amp;lt;div style=&quot;width:80px;height:80px;float:left;background:red;&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div style=&quot;width:80px;height:80px;float:left;background:green;clear:left&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div style=&quot;width:80px;height:80px;float:left;background:#2b2ba8;&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div style=&quot;clear:both&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;清除浮动方式2（推荐）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
.clearfix:after {             &amp;lt;----在类名为“clearfix”的元素内最后面加入内容； 
content: &quot;.&quot;;                 &amp;lt;----内容为“.”就是一个英文的句号而已。也可以不写。 
display: block;               &amp;lt;----加入的这个元素转换为块级元素。 
clear: both;                  &amp;lt;----清除左右两边浮动。 
visibility: hidden;           &amp;lt;----可见度设为隐藏。注意它和display:none;是有区别的。visibility:hidden;仍然占据空间，只是看不到而已； 
line-height: 0;               &amp;lt;----行高为0； 
height: 0;                    &amp;lt;----高度为0； 
font-size:0;                  &amp;lt;----字体大小为0； 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;整段代码就相当于在浮动元素后面跟了个宽高为0的空div，然后设定它clear:both来达到清除浮动的效果。之所以用它，是因为我们不必在html文件中写入大量无意义的空标签，又能清除浮动。 话说回来，第一种方式的代码不利于维护。 只要在需要清浮动的元素中添加 clearfix 类名就好了。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;div class=&quot;head clearfix&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;清除浮动方式3：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
overflow:hidden;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;overflow：&lt;/strong&gt;hidden的含义是超出的部分要裁切隐藏，float的元素虽然不在普通流中，但是他是浮动在普通流之上的，可以把普通流元素+浮动元素想象成一个立方体。如果没有明确设定包含容器高度的情况下，它要计算内容的全部高度才能确定在什么位置hidden，这样浮动元素的高度就要被计算进去。这样包含容器就会被撑开，清除浮动。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;位置 position&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　可以设置标签的位置，经常与top、right、left、bottom联用。一旦设置position属性，此标签将变成上一层覆盖下一层。position的值分两类：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;fixed                            固定在屏幕的某个位置（滑动滚轮，相对屏幕的位置不会动）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;relative + absolute      固定在相对于父标签的某个位置（单独设置relative没有任何效果，一般与absolute嵌套使用）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;思考：当position为 relative + absolute时，它与margin系列的区别是什么？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1. margin是基于父标签调整位置，依赖于父标签；position是基于整个页面调整位置（单独absolute），当然也可以基于父标签调整。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2. 用margin，如果两个同级标签位置不够占，其中一个会将另一个挤到下一行，永远属于同一个图层。而如果设置position，它会分层，覆盖下一层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;在设置position时需要注意：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1.&lt;strong&gt; 一旦设置position后，必须设置位置&lt;/strong&gt;（top,left,right,bottom）&lt;strong&gt;,否则根本无法显示标签。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2. 如果出现分多层，&lt;strong&gt;可以使用 z-index&lt;/strong&gt; &lt;strong&gt;来设置层级顺序&lt;/strong&gt;，数值越大层级越高。设置该 z-index 的标签会覆盖没设置的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3. 若要&lt;strong&gt;将position:fixed的标签居中&lt;/strong&gt;，则应top:50%;left:50%;且上边距为 -(标签高度)÷2 ; 左边距为 -(标签宽度)÷2;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;透明度 opacity&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　opacity的值在[0,1]区间内，0为完全透明，1为完全不透明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在使用过程中，我们的需求可能是想要将背景做透明处理，但设置opacity后此标签内的所有内容也一并被设置了透明度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在这里提供两种解决办法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1. 为标签添加一个绝对定位的子标签，设置大小和该元素一样，把opacity设置加在绝对定位标签上作为遮罩，z-index设置到最底部，达到效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2. 使用CSS属性rgba。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试代码，效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;div style=&quot;width:150px;height:100px;float:left;&quot;&amp;gt;&amp;lt;div&amp;gt;没有设置透明度&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;width:150px;height:100px;float:left;margin-left:10px;opacity:0.5;&quot;&amp;gt;&amp;lt;div&amp;gt;用opacity设置透明度&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;width:150px;height:100px;float:left;margin-left:10px;&quot;&amp;gt;&amp;lt;div&amp;gt;用rgba设置透明度&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1354918/201808/1354918-20180811195406497-906714694.jpg&quot; alt=&quot;&quot; width=&quot;323&quot; height=&quot;66&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;overflow 限制显示区域&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　规定当内容溢出元素框时发生的事情。值：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　visible：默认值，内容会溢出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　hidden：超出范围的内容不可见。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　auto：如果超出范围，会有滚动条。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　scroll：无论是否有需要，都会有滚动条。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当父标签内的&amp;lt;img&amp;gt;图片大于父标签，若想将其限制，不能超过父标签的范围。有两种解决思路：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;transition 渐变（过渡效果）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　transition属性可以产生过渡效果，通常在用户将鼠标悬浮到元素上时发生。transition是一个简写属性，可以拆分为四个：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　transition-property：选定哪些CSS属性获得过度效果。值：none，all，名称（多个属性用逗号隔开）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　transition-duration：完成过渡效果花费的时间（s或ms），默认值是0。&lt;strong&gt;注意：&lt;/strong&gt;请始终设置此属性，否则默认为0，不会产生效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　trainsition-timing-funciton：规定过渡效果的速度曲线（随着时间来改变其速度）。取值：linear（匀速），ease（始末慢，中间快），ease-in（逐渐变快），ease-out（逐渐变慢），ease-in-out（始末慢，中间快，不清楚和ease的区别）。cubic-bezier(n,n,n,n)。每个值都位于0~1之间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　trainsition-delay：规定过渡效果开始之前需要等待的时间（s或ms）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　简写为：transition：属性，花费时间，速度曲线函数，开始时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;※ 注意1：&lt;/strong&gt;如果属性没有定义值，却在:hover中定义，是不会产生过度效果的，即使在transition-property中特别指定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;※ 注意2：&lt;/strong&gt;如果在简写模式中对第一个值写入多个属性，只对最后一个产生过渡效果。解决方法：在其下面单独写transition-property即可。如果想要对不同的属性设定不同的过度时间，写法与上相同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例：　transition：all 0.4s linear 0s；本博客文章标题&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
h1{
    width: 500px;
    height:50px;
    color:black;
    cursor:pointer;
    transition: all 0.4s linear 0s;
    /*transition: color 0.4s linear 0s;*/
    /*transition-property: width,color;*/
    background-color: #9d9d9d;
}
h1:hover{
    color:#F60;
    margin-left: 20px;
    width: 1000px;
    /*height: 300px;*/
}

&amp;lt;h1&amp;gt;这是标题&amp;lt;/h1&amp;gt;
通过单独解除注释来了解【注意1】和【注意2】
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;cursor 光标形状&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　cursor属性定义了鼠标放在标签范围内时所用的光标形状。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　常用值：pointer (一只手)，wait (表示程序正忙)，text (文本)，auto (默认)，no-drop、not-allowed（禁止样式）。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;box-shadow 阴影效果&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　该属性可以给框添加一个或多个阴影，类似于text-shadow。主要值：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　h-shadow：必需。水平阴影的位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　v-shadow：必需。垂直阴影的位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　blur：可选。模糊距离。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　spread：可选。阴影的尺寸。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　color：可选。阴影颜色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果添加多个阴影，用逗号分隔。如：box-shadow：2px 2px 3px black，5px 2px 1px red;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;transform 2D/3D转换&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　该属性允许我们向元素应用2D/3D转换，可进行旋转、缩放或倾斜。该属性的用法非常之多，这里只介绍两个2D方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　scale(x,y) 2D缩放转换：值：数字。可以是一个数字，也可以是两个。例：transform：scale(1.5);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　rotate()   2D旋转：值：旋转角度。正值顺时针旋转，负值逆时针旋转。例：transform：rotate(6deg);&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;初学者可能会遇到的问题：&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.CSS重用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;css样式可以放在&amp;lt;head&amp;gt;标签中，也可以放在css文件中，link标签引入即可。在编写样式时，如果样式c1和c2中有相同的部分，或者有在其他地方被大量使用的部分，可以将这部分提取出来再写个c样式。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.改变浏览器窗口大小，原本的页面混乱&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;要注意：&lt;/strong&gt;除个个别情况，必需设定固定宽度，一般都将宽度设置成百分比&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3.在IE浏览器中可能会出现：用&amp;lt;a&amp;gt;标签包裹的&amp;lt;img&amp;gt;图片显示出来会有蓝色边框。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;解决办法：样式设置：border:0;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4.&amp;lt;input&amp;gt;标签用户输入的内容若想提交到后台，必须用&amp;lt;form&amp;gt;标签包裹&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;5.图标&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Font Awesome&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;http://www.fontawesome.com.cn/&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;阿里巴巴矢量图库&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;http://www.iconfont.cn/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.elegantthemes.com/blog/resources/elegant-icon-font&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;ICONFINDER&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;https://www.iconfinder.com/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://www.logoyuan.com/&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt; 6.如何使子元素相对于父元素居中？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这里有两个使用的方法：①父元素position:relative，子元素position:absoulte;margin:auto;四边的距离都为0。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
    &amp;lt;style&amp;gt;
        .parent-center {
            /* 将position设置为absolute，使元素有可能相对于浏览器窗口定位 */
            position: absolute;
            /* 将margin设置为auto，使浏览器自动推算元素外边距 */
            margin: auto;
            /* 将上下左右边距（相对于父元素边缘）全设为0，使浏览器推算出的外边距上下、左右对应相等
               可以设置任何其他相等的值，但如果父元素小到不能容下任意一个方向的两侧边距，元素也将不居中，所以推荐设为0 */
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
        }
        div.parent {
            position: relative;
            /* 父元素可以有绝对或相对大小，也可以仅由其内容决定其大小 */
            width: 50%;
            height: 200px;
            background-color: aquamarine;
        }

        div.child {
            /* 使用这种方法的元素必须有绝对或相对大小，否则浏览器推算出的margin将为0，元素将被拉伸，以适应父元素大小和四个边距值 */
            width: 30%;
            height: 100px;
            background-color: antiquewhite;
        }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;parent&quot;&amp;gt;
        &amp;lt;div class=&quot;parent-center child&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;②弹性盒布局&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
    &amp;lt;style&amp;gt;
        div.parent {
            /* 启用弹性盒布局 */
            display: flex;
            /* 使子元素水平居中 */
            justify-content: center;
            /* 使子元素垂直居中 */
            align-items: center;
            width: 50%;
            height: 200px;
            background-color: aquamarine;
        }
        div.child {
            width: 30%;
            height: 100px;
            background-color: antiquewhite;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;parent&quot;&amp;gt;
        &amp;lt;div class=&quot;child&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 30 Dec 2018 14:13:00 +0000</pubDate>
<dc:creator>学霸初养成</dc:creator>
<og:description>CSS CSS是英文Cascading Style Sheets的缩写,称为层叠样式表，用于对页面进行美化。 存在方式有三种：元素内联、页面嵌入和外部导入，比较三种方式的优缺点。 语法：style =</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/V587Chinese/p/10200801.html</dc:identifier>
</item>
<item>
<title>2018 年终总结 - 霖哲煌</title>
<link>http://www.cnblogs.com/linzhehuang/p/10200853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linzhehuang/p/10200853.html</guid>
<description>&lt;p&gt;今年，想说的和总结的其实挺多的，但奈何不善写作，卯足劲才憋出这篇总结（文笔不好，所以文章语言会很生硬且没有衔接感）。&lt;/p&gt;

&lt;p&gt;对待技术方面，一直以来的观点是“不要过分执迷技术，应该学习的是技术背后的东西”，但总觉得措词怪异。直到今年，看到下面阮一峰老师博客里的这段话，才明白应该这样去表述。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;实施细节并不是知识，而是操作步骤。如果技术栈发生变更，实施细节就会毫无用处。但是，你又不能不学习它，不知道实施细节，就没法做出项目。我觉得，程序员应该要警惕，不要落入实施细节的陷阱，不要把全部精力花在实施细节上面，然后以为自己学到了真正的知识。对待各种语言和工具，正确的态度应该是&quot;进得去，出得来&quot;，既要了解足够的细节，也要能够站在宏观的角度看待它，探寻底层到底是怎么实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;2.1428571428571&quot;&gt;
&lt;p&gt;摘自阮一峰博客&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/10/weekly-issue-28.html&quot;&gt;《每周分享第 28 期》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总而言之，就是要以宏观角度来看待实施细节，才能学到真正的知识。下文阐述的内容，是今年的经历、想法与思考，这些让我对这个观点有了更深刻地感触。&lt;/p&gt;

&lt;p&gt;今年暑假留在了学校，导师布置了个项目，并充当提出需求的客户和前期设计的分析师，团队四个人参与整个项目的生命周期。由于没有经验及技术不成熟，整个过程是边学习摸索着边推进。但暑期结束了也没大进展，因而项目只能被搁置了。不过从此次经历中学习到了很多知识，同时也总结了项目推进失败的教训。&lt;/p&gt;
&lt;h2 id=&quot;转变开发方式&quot;&gt;转变开发方式&lt;/h2&gt;
&lt;p&gt;项目开始前，导师给我们讲述许多关于软件开发的问题，其中提到了“基于领域驱动”的软件设计模式。同以往课设项目围绕着“数据库”进行开发不同，基于领域驱动的开发注重领域的知识，领域模型更加符合自然系统，而围绕数据库开发只会将重心偏移到数据的设计和处理。&lt;/p&gt;
&lt;p&gt;可惜的是，早先没有基于领域驱动开发软件的经验，以至于暑假项目上的前期分析还是以往的方式。下半年拜读《领域驱动设计》后，对软件开发方式有了不同理解与体会，同时也将该开发方式应用在一门课设上。&lt;/p&gt;
&lt;h2 id=&quot;项目失败的教训&quot;&gt;项目失败的教训&lt;/h2&gt;
&lt;p&gt;此次项目失败有技术原因也有工程上的问题，但主要还是败在工程问题上。&lt;/p&gt;
&lt;p&gt;在项目架构选择上，犯了很大的错误，选择过于激进的微服务架构。由于项目的复杂程度，还不至于使用该架构，导致对项目的划分粒度过细，就像是为了微服务而微服务。而且这导致了维护成本变高，由于划分过细，修改一处就得重新改写其它关联的部分，当然这也与前期设计不当脱不了关系。最后，由于种种问题放弃了还不熟悉的微服务架构，转而使用传统的单块架构。&lt;/p&gt;
&lt;p&gt;此次项目，采用了前后端分离的开发方式，但前后端测试成了问题。最开始使用原始的手工测试，测试非常耗时间，而且有时候难以判断错误发生在哪一端。于是，后来采用了替身测试，前端使用 Mock.js 框架模拟接收到的数据，而后端使用 JUnit 框架模拟发送的请求。虽然解决了前后端测试问题，但开发中接口的统一，就只能靠传递定义接口文档实现。&lt;/p&gt;

&lt;p&gt;这个项目的后端用到了 Spring 框架，前端用到 Vue.js 框架，这两个框架都十分优秀且其设计思想耐人寻味。&lt;/p&gt;
&lt;h2 id=&quot;模块解耦&quot;&gt;模块解耦&lt;/h2&gt;
&lt;p&gt;首先，非常欣赏 Spring 框架解决软件复杂性的思想，而且让我了解到原来模块可以这么解耦。&lt;/p&gt;
&lt;p&gt;Spring 框架通过依赖注入来解决模块间高耦合的问题，框架负责代码模块的依赖，就像是代码模块的粘合剂。且其低侵入的特性，使得编写代码时基本无需考虑框架的存在。&lt;/p&gt;
&lt;h2 id=&quot;数据驱动视图&quot;&gt;数据驱动视图&lt;/h2&gt;
&lt;p&gt;大一也曾接触过 Vue.js 框架，老师让我用其做个登录演示页面，于是花了两天阅读了官方文档，草草做了个演示。当时只觉得其写法很奇怪及别扭，并没有过多的思考。&lt;/p&gt;
&lt;p&gt;上半年做 Oracle 数据库课设时，用手动修改 DOM 来实现视图变化，但当项目变得复杂时，代码也会变得非常难维护。而 Vue.js 框架的优秀之处在于，让数据驱动视图的变化，从而不需要手动修改 DOM ，降低了数据与视图关联的复杂性。&lt;/p&gt;

&lt;p&gt;由于项目需要，又重新接触了前端。虽然清楚前端这几年发展迅速，但当真正接触时，更是惊叹其巨大变化。&lt;/p&gt;
&lt;h2 id=&quot;学习成本变高&quot;&gt;学习成本变高&lt;/h2&gt;
&lt;p&gt;现在编写前端工程，不仅需要掌握最基本的 HTML 标记语言、CSS 样式表和 JavaScript 脚本语言，还得搭建 Node.js 环境及会使用依赖包管理工具 NPM，同时会配置使用例如 Webpack 之类的构建工具。&lt;/p&gt;
&lt;p&gt;掌握了上面这些，还得学习一个热门的框架，例如我使用的 Vue.js 还有基于此的前端界面库 ElementUI 。学习这些内容的成本是很高的，而且上面提到内容，还只是整个“大前端”的冰山一角。&lt;/p&gt;
&lt;h2 id=&quot;前端工程化&quot;&gt;前端工程化&lt;/h2&gt;
&lt;p&gt;前端的学习成本随着其发展不断增加，而前端发展的同时也使其复杂性增加，于是就有了“前端工程化”一说。前端工程化同软件工程为了解决软件复杂性一样，首要任务是为了解决前端的复杂性。&lt;/p&gt;
&lt;p&gt;前端工程化涉及诸多方面的内容，由于篇幅有限，只阐述我认为的核心内容。首先一个是，强调前端工程进行组件化开发，同模块化用于封装隔离不同，组件化更强调复用，一个很好的例子便是 Vue.js 的模板文件。还有便是规范化的开发，项目需要考虑语言规范、编码规范、项目结构规范等等方面，而这些也有利于团队的开发与维护。&lt;/p&gt;

&lt;p&gt;今年算起，入门也大概有六七年头了吧，现在自己的境遇是涉猎广但深度不够，所以计划明年着重研究大数据计算方面。同时，希望明年 ACM 比赛能有个好成绩，不会像今年一样只是去走个过场。还有，继续练好自己的写作水平。&lt;/p&gt;
</description>
<pubDate>Sun, 30 Dec 2018 14:06:00 +0000</pubDate>
<dc:creator>霖哲煌</dc:creator>
<og:description>前言 今年，想说的和总结的其实挺多的，但奈何不善写作，卯足劲才憋出这篇总结（文笔不好，所以文章语言会很生硬且没有衔接感）。 对待技术 对待技术方面，一直以来的观点是“不要过分执迷技术，应该学习的是技术</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linzhehuang/p/10200853.html</dc:identifier>
</item>
<item>
<title>Spring类型转换（Converter） - baka-sky</title>
<link>http://www.cnblogs.com/baka-sky/p/10200845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baka-sky/p/10200845.html</guid>
<description>&lt;h3 id=&quot;spring的类型转换&quot;&gt;Spring的类型转换&lt;/h3&gt;
&lt;p&gt;以前在面试中就有被问到关于spring数据绑定方面的问题，当时对它一直只是朦朦胧胧的概念，最近稍微闲下来有时间看了一下其中数据转换相关的内容，把相应的内容做个记录。&lt;/p&gt;
&lt;p&gt;下面先说明如何去用，然后再放一下个人看参数绑定源码的一些笔记，可能由于实力不够，有些地方说的不是很正确，如果有纰漏还请各位指出。&lt;/p&gt;
&lt;h3 id=&quot;conversionservice&quot;&gt;ConversionService&lt;/h3&gt;
&lt;p&gt;原生的Java是有一个可以提供数据转换功能的工具——&lt;code&gt;PropertyEditor&lt;/code&gt;。但是它的功能有限，它只能将字符串转换为一个Java对象。在web项目中，如果只看与前端交互的那一部分，这个功能的确已经足够了。但是在后台项目内部可就得重新想办法了。&lt;/p&gt;
&lt;p&gt;Spring针对这个问题设计了Converter模块，它位于&lt;code&gt;org.springframework.core.converter&lt;/code&gt;包中。该模块足以替代原生的&lt;code&gt;PropertyEditor&lt;/code&gt;，但是spring选择了同时支持两者，在Spring MVC处理参数绑定时就用到了。&lt;/p&gt;
&lt;p&gt;该模块的核心是&lt;code&gt;ConversionService&lt;/code&gt;接口，内容如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ConversionService {

    boolean canConvert(@Nullable Class&amp;lt;?&amp;gt; sourceType, Class&amp;lt;?&amp;gt; targetType);

    boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType);

    @Nullable
    &amp;lt;T&amp;gt; T convert(@Nullable Object source, Class&amp;lt;T&amp;gt; targetType);

    @Nullable
    Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接口里的方法定义的还是比较直观的，见名知意。其中的&lt;code&gt;TypeDescriptor&lt;/code&gt;是spring自己定义的类，它提供了获取类型更多信息的便捷方法。比如是否含有注解、是否实现map接口、获取map的key与value的TypeDescriptor等等。&lt;/p&gt;
&lt;p&gt;由此可见，converter模块不仅支持任意类型之间的转换，而且能更简单地获得更多的类型信息从而做出更细致的类型转换。&lt;/p&gt;
&lt;h3 id=&quot;转换器&quot;&gt;转换器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ConversionService&lt;/code&gt;只是个Service，对于每个类型转换的操作，它并不是最终的操作者，它会将相应操作交给对应类型的转换器。而在实际项目中，由于业务复杂，对类型转换的要求也不一样，因此spring提供了几个接口来方便自定义转换器。&lt;/p&gt;
&lt;h4 id=&quot;converters-t&quot;&gt;Converter&amp;lt;S, T&amp;gt;&lt;/h4&gt;
&lt;p&gt;接口定义如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface Converter&amp;lt;S, T&amp;gt; {
    @Nullable
    T convert(S var1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该接口非常简单，只定义了一个转换方法，两个泛型参数则是需要转换的两个类型。在单独处理两个类型的转换时这是首选，即一对一，但是倘若有同一父类（或接口）的类型需要进行类型转化，为每个类型都写一个Converter显然是十分不理智的。对于这种情况，spring提供了一个&lt;code&gt;ConverterFactory&lt;/code&gt;接口。&lt;/p&gt;
&lt;h4 id=&quot;converterfactorys-r&quot;&gt;ConverterFactory&amp;lt;S, R&amp;gt;&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ConverterFactory&amp;lt;S, R&amp;gt; {
    &amp;lt;T extends R&amp;gt; Converter&amp;lt;S, T&amp;gt; getConverter(Class&amp;lt;T&amp;gt; var1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，该工厂方法可以生产从S类型到T类型的转换器，而T类型必定继承或实现R类型，我们可以形象地称为“一对多”，因此该接口更适合实现需要转换为同一类型的转换器。&lt;/p&gt;
&lt;p&gt;对于大部分需求上面两个接口其实已经足够了（至少我感觉是），但是不是还没用到&lt;code&gt;TypeDescriptor&lt;/code&gt;吗？如果要实现更为复杂的转换功能的话，spring提供了拥有&lt;code&gt;TypeDescriptor&lt;/code&gt;参数的&lt;code&gt;GenericConverter&lt;/code&gt;接口。&lt;/p&gt;
&lt;h4 id=&quot;genericconverter&quot;&gt;GenericConverter&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface GenericConverter {
    
    @Nullable
    Set&amp;lt;ConvertiblePair&amp;gt; getConvertibleTypes();

    @Nullable
    Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

    final class ConvertiblePair {

        private final Class&amp;lt;?&amp;gt; sourceType;

        private final Class&amp;lt;?&amp;gt; targetType;

        public ConvertiblePair(Class&amp;lt;?&amp;gt; sourceType, Class&amp;lt;?&amp;gt; targetType) {
            Assert.notNull(sourceType, &quot;Source type must not be null&quot;);
            Assert.notNull(targetType, &quot;Target type must not be null&quot;);
            this.sourceType = sourceType;
            this.targetType = targetType;
        }

        public Class&amp;lt;?&amp;gt; getSourceType() {
            return this.sourceType;
        }

        public Class&amp;lt;?&amp;gt; getTargetType() {
            return this.targetType;
        }
        
        // 省去了一些Override方法
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;GenericConverter&lt;/code&gt;中拥有一个内部类&lt;code&gt;ConvertiblePair&lt;/code&gt;，这个内部类的作用只是封装转换的源类型与目标类型。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;GenericConverter&lt;/code&gt;，&lt;code&gt;getConvertibleTypes&lt;/code&gt;方法就返回这个转换器支持的转换类型（一对一，一对多，多对多都可以满足），&lt;code&gt;convert&lt;/code&gt;方法和以前一样是负责处理具体的转换逻辑。&lt;/p&gt;
&lt;p&gt;而且，如果你觉得对于一个转换器来说只通过判断源类型和目标类型是否一致来决定是否支持转换还不够，Spring还提供了另一个接口&lt;code&gt;ConditionalGenericConverter&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;conditionalgenericconverter&quot;&gt;ConditionalGenericConverter&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ConditionalConverter {

   boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);

}

public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ConditionalGenericConverter&lt;/code&gt;接口继承了&lt;code&gt;GenericConverter&lt;/code&gt;和&lt;code&gt;ConditionalConverter&lt;/code&gt;接口，在&lt;code&gt;matches&lt;/code&gt;方法中就可以在源类型与目标类型已经匹配的基础上再进行判断是否支持转换。&lt;/p&gt;
&lt;p&gt;Spring官方实现&lt;code&gt;ConditionalGenericConverter&lt;/code&gt;接口的转换器大多用来处理有集合或数组参与的转换，这其中的&lt;code&gt;matches&lt;/code&gt;方法就用来判断集合或数组中的元素是否能够成功转换。而且因为&lt;code&gt;GenericConverter&lt;/code&gt;与&lt;code&gt;ConditionalGenericConverter&lt;/code&gt;接口功能太类似，索性就直接实现&lt;code&gt;ConditionalGenericConverter&lt;/code&gt;接口了。&lt;/p&gt;
&lt;h4 id=&quot;如何使用&quot;&gt;如何使用&lt;/h4&gt;
&lt;p&gt;那么如何使用转换器呢，Spring要求我们要把所有需要使用转换器注册到&lt;code&gt;ConversionService&lt;/code&gt;，这样Spring在遇到类型转换的情况时，会去&lt;code&gt;ConversionService&lt;/code&gt;中寻找支持的转换器，进行必要的格式转换。&lt;/p&gt;
&lt;p&gt;支持转换器注册的接口为&lt;code&gt;ConverterRegistry&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ConverterRegistry {

    void addConverter(Converter&amp;lt;?, ?&amp;gt; converter);

    &amp;lt;S, T&amp;gt; void addConverter(Class&amp;lt;S&amp;gt; sourceType, Class&amp;lt;T&amp;gt; targetType, Converter&amp;lt;? super S, ? extends T&amp;gt; converter);

    void addConverter(GenericConverter converter);

    void addConverterFactory(ConverterFactory&amp;lt;?, ?&amp;gt; factory);

    void removeConvertible(Class&amp;lt;?&amp;gt; sourceType, Class&amp;lt;?&amp;gt; targetType);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但我们使用的是另一个继承了&lt;code&gt;ConversionService&lt;/code&gt;和&lt;code&gt;ConverterRegistry&lt;/code&gt;的接口&lt;code&gt;ConfigurableConversionService&lt;/code&gt;，通过这个接口，就可以注册自定义的转换器了。&lt;/p&gt;
&lt;h3 id=&quot;格式化&quot;&gt;格式化&lt;/h3&gt;
&lt;p&gt;转换器提供的功能是一个类型到另一个类型的单向转换，而在web项目中，有些数据是需要经常做双向转换，最常见的就是日期时间了。将请求中一定格式的字符串转换为日期类型，而在返回的相应中将日期类型再做指定格式的格式化，Spring中提供的工具就是&lt;code&gt;Formatter&lt;/code&gt;接口。&lt;/p&gt;
&lt;h4 id=&quot;formattert&quot;&gt;Formatter&amp;lt;T&amp;gt;&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface Printer&amp;lt;T&amp;gt; {
    String print(T object, Locale locale);
}

@FunctionalInterface
public interface Parser&amp;lt;T&amp;gt; {
    T parse(String text, Locale locale) throws ParseException;
}

public interface Formatter&amp;lt;T&amp;gt; extends Printer&amp;lt;T&amp;gt;, Parser&amp;lt;T&amp;gt; {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Formatter&lt;/code&gt;接口中拥有两个方法，一个是解析字符串的&lt;code&gt;parse&lt;/code&gt;，一个是将字符串格式化的&lt;code&gt;print&lt;/code&gt;，两个方法都拥有&lt;code&gt;Locale&lt;/code&gt;类型的参数，因此还可根据地区来做出相应的定制。&lt;/p&gt;
&lt;p&gt;那么如何使用&lt;code&gt;Formatter&lt;/code&gt;呢？由于注解的出现，大量需要在xml中的配置项都直接换为注解的方式，&lt;code&gt;Formatter&lt;/code&gt;也是，Spring提供了&lt;code&gt;AnnotationFormatterFactory&lt;/code&gt;这个接口。&lt;/p&gt;
&lt;h4 id=&quot;annotationformatterfactorya-extends-annotation&quot;&gt;AnnotationFormatterFactory&amp;lt;A extends Annotation&amp;gt;&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface AnnotationFormatterFactory&amp;lt;A extends Annotation&amp;gt; {

    Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; getFieldTypes();

    Printer&amp;lt;?&amp;gt; getPrinter(A annotation, Class&amp;lt;?&amp;gt; fieldType);

    Parser&amp;lt;?&amp;gt; getParser(A annotation, Class&amp;lt;?&amp;gt; fieldType);
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;getFieldTypes&lt;/code&gt;方法返回的是当这些类型有A注解的时候我才会做格式化操作，&lt;code&gt;getPrinter&lt;/code&gt;方法和&lt;code&gt;getParser&lt;/code&gt;则分别获取相应的对象，我们也可以直接将&lt;code&gt;Formatter&lt;/code&gt;对象返回。&lt;/p&gt;
&lt;h4 id=&quot;如何使用-1&quot;&gt;如何使用&lt;/h4&gt;
&lt;p&gt;格式化的操作，本质上来说也是类型转换，即String =&amp;gt; ? 和? =&amp;gt; String。因此Spring将转换器与格式化同质化，在代码实现中，&lt;code&gt;Formatter&lt;/code&gt;也是被转换为相应的Printer转换器和Parser转换器，那么，&lt;code&gt;Formatter&lt;/code&gt;也就可以注册到&lt;code&gt;ConversionService&lt;/code&gt;中了。&lt;/p&gt;
&lt;p&gt;可以注册&lt;code&gt;Formatter&lt;/code&gt;的接口为&lt;code&gt;FormatterRegistry&lt;/code&gt;，该接口继承自&lt;code&gt;ConverterRegistry&lt;/code&gt;，将它与&lt;code&gt;ConversionService&lt;/code&gt;一起实现的类是&lt;code&gt;FormattingConversionService&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface FormatterRegistry extends ConverterRegistry {

    void addFormatter(Formatter&amp;lt;?&amp;gt; formatter);

    void addFormatterForFieldType(Class&amp;lt;?&amp;gt; fieldType, Formatter&amp;lt;?&amp;gt; formatter);

    void addFormatterForFieldType(Class&amp;lt;?&amp;gt; fieldType, Printer&amp;lt;?&amp;gt; printer, Parser&amp;lt;?&amp;gt; parser);

    void addFormatterForFieldAnnotation(AnnotationFormatterFactory&amp;lt;? extends Annotation&amp;gt; annotationFormatterFactory);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;令人非常遗憾的是，除了通过&lt;code&gt;ConversionService&lt;/code&gt;的&lt;code&gt;convert&lt;/code&gt;直接使用，&lt;code&gt;Formatter&lt;/code&gt;的&lt;code&gt;print&lt;/code&gt;方法通过框架使用的条件比较特殊，它需要spring标签的支持才能做到在页面上的格式化，&lt;code&gt;parse&lt;/code&gt;只需要在相应字段上打上注解即可。&lt;/p&gt;
&lt;h3 id=&quot;写写代码&quot;&gt;写写代码&lt;/h3&gt;
&lt;p&gt;说了这么多，自然还是来点代码更实在。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;Converter&lt;/code&gt;和&lt;code&gt;ConverterFactory&lt;/code&gt;以及&lt;code&gt;Formatter&lt;/code&gt;，使用在SpringMVC的参数绑定上的机会会更多，所以直接在web项目里写。而&lt;code&gt;ConditionalGenericConverter&lt;/code&gt;接口官方实现的例子已经很丰富了，至少我没想到什么新的需求，想要看代码的话可以直接去看官方的源码（比如&lt;code&gt;ArrayToCollectionConverter&lt;/code&gt;），我就不自己写了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下代码基于SpringBoot 2.1.1，对应的SpringMVC为5.1.3，使用了lombok&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;test&quot;)
public class TestController {
    @GetMapping(&quot;/index&quot;)
    public UserEntity test(UserEntity user) {
        return user;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addFormatters(FormatterRegistry registry) {
        // 为webMVC注册转换器
        registry.addConverter(new String2StatusEnumConverter());
        registry.addConverterFactory(new String2EnumConverterFactory());
        registry.addFormatterForFieldAnnotation(new GenderFormatterFactory());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
@Component
public class UserEntity {

    private String username;
    private String password;

    // 加上注解的含义为使用枚举的name字段进行枚举的格式化，可改为id
    @GenderEnumFormat(&quot;name&quot;)
    private GenderEnum gender;

    private StatusEnum status;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface EnumInterface {
    Integer getId();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Getter
@AllArgsConstructor
public enum GenderEnum implements EnumInterface {

    MALE(0, &quot;男&quot;),
    FEMALE(1, &quot;女&quot;),
    ;

    private Integer id;
    private String name;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Getter
@AllArgsConstructor
public enum StatusEnum implements EnumInterface {
    ON(1, &quot;启用&quot;),
    OFF(0, &quot;停用&quot;),
    ;

    private Integer id;
    private String name;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * String to StatusEnum 的转换器
 */
public class String2StatusEnumConverter implements Converter&amp;lt;String, StatusEnum&amp;gt; {

    @Override
    public StatusEnum convert(String s) {
        // 注意，这里是通过id匹配
        for (StatusEnum e : StatusEnum.values()) {
            if (e.getId().equals(Integer.valueOf(s))) {
                return e;
            }
        }
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * String to EnumInterface 的转换器工厂
 */
public class String2EnumConverterFactory implements ConverterFactory&amp;lt;String, EnumInterface&amp;gt; {

    @Override
    public &amp;lt;T extends EnumInterface&amp;gt; Converter&amp;lt;String, T&amp;gt; getConverter(Class&amp;lt;T&amp;gt; targetType) {
        return new String2Enum&amp;lt;&amp;gt;(targetType);
    }

    /**
     * 转换器
     */
    private class String2Enum&amp;lt;T extends EnumInterface&amp;gt; implements Converter&amp;lt;String, T&amp;gt; {

        private final Class&amp;lt;T&amp;gt; targetType;

        private String2Enum(Class&amp;lt;T&amp;gt; targetType) {
            this.targetType = targetType;
        }

        @Override
        public T convert(String source) {
            for (T enumConstant : targetType.getEnumConstants()) {
                if (enumConstant.getId().toString().equals(source)) {
                    return enumConstant;
                }
            }
            return null;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 将打上注解的GenderEnum通过特定的字段转换为枚举
 */
@Target({ElementType.TYPE, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface GenderEnumFormat {
    String value();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class GenderFormatterFactory implements AnnotationFormatterFactory&amp;lt;GenderEnumFormat&amp;gt; {
    @Override
    public Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; getFieldTypes() {
        return Collections.singleton(GenderEnum.class);
    }

    @Override
    public Printer&amp;lt;?&amp;gt; getPrinter(GenderEnumFormat annotation, Class&amp;lt;?&amp;gt; fieldType) {
        return new GenderFormatter(annotation.value());
    }

    @Override
    public Parser&amp;lt;?&amp;gt; getParser(GenderEnumFormat annotation, Class&amp;lt;?&amp;gt; fieldType) {
        return new GenderFormatter(annotation.value());
    }

    final class GenderFormatter implements Formatter&amp;lt;GenderEnum&amp;gt; {
        private final String fieldName;
        private Method getter;

        private GenderFormatter(String fieldName) {
            this.fieldName = fieldName;
        }

        @Override
        public GenderEnum parse(String text, Locale locale) throws ParseException {
            if (getter == null) {
                try {
                    getter = GenderEnum.class.getMethod(&quot;get&quot; + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1));
                } catch (NoSuchMethodException e) {
                    throw new ParseException(e.getMessage(), 0);
                }
            }
            for (GenderEnum e : GenderEnum.values()) {
                try {
                    if (getter.invoke(e).equals(text)) {
                        return e;
                    }
                } catch (IllegalAccessException | InvocationTargetException e1) {
                    throw new ParseException(e1.getMessage(), 0);
                }
            }
            throw new ParseException(&quot;输入参数有误，不存在这样的枚举值：&quot; + text, 0);
        }

        @Override
        public String print(GenderEnum object, Locale locale) {
            try {
                // 这里应该也判断一下getter是否为null然后选择进行初始化，但是因为print方法没有效果所以也懒得写了
                return getter.invoke(object).toString();
            } catch (IllegalAccessException | InvocationTargetException e) {
                return e.getMessage();
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;源码笔记&quot;&gt;源码笔记&lt;/h3&gt;
&lt;p&gt;之前一直说类型转换在Spring MVC的参数绑定中有用到，下面就放一下本人的一些笔记。由于实力问题有些地方也有些懵逼，也欢迎大家交流。&lt;/p&gt;
&lt;p&gt;（看源码的时候突然遇到IDEA无法下载源码，搜出来的结果大致都是说更换maven版本，懒得更改就直接用maven命令下载源码了：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mvn dependency:sources -DincludeArtifactIds=spring-webmvc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不加参数的话会默认下载全部的源码）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class InvocableHandlerMethod extends HandlerMethod {
        // ...
        protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
            if (ObjectUtils.isEmpty(this.getMethodParameters())) {
                return EMPTY_ARGS;
            } else {
                // 得到处理方法的方法参数
                MethodParameter[] parameters = this.getMethodParameters();
                Object[] args = new Object[parameters.length];

                for (int i = 0; i &amp;lt; parameters.length; ++i) {
                    MethodParameter parameter = parameters[i];
                    // 初始化，之后可以调用MethodParameter对象的getParameterName方法
                    parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
                    // 如果providedArgs包含当前参数的类型就赋值
                    args[i] = findProvidedArgument(parameter, providedArgs);
                    if (args[i] == null) {
                        // resolvers包含了所有的参数解析器（HandlerMethodArgumentResolver的实现类，常见的比如RequestParamMethodArgumentResolver，PathVariableMethodArgumentResolver等，就是在参数前加的注解的处理类，有对应的注解的话就会用对应的解析器去处理参数绑定，如果没有注解的话通常会和有ModelAttribute注解一样使用ServletModelAttributeMethodProcessor，具体判断在每个实现类的supportsParameter方法里）
                        if (!this.resolvers.supportsParameter(parameter)) {
                            throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;));
                        }

                        try {
                            // 使用解析器开始解析参数
                            args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
                        } catch (Exception var10) {
                            if (this.logger.isDebugEnabled()) {
                                String error = var10.getMessage();
                                if (error != null &amp;amp;&amp;amp; !error.contains(parameter.getExecutable().toGenericString())) {
                                    this.logger.debug(formatArgumentError(parameter, error));
                                }
                            }

                            throw var10;
                        }
                    }
                }

                return args;
            }
        }
        // ...
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractNamedValueMethodArgumentResolver implements HandlerMethodArgumentResolver {
    // ...
    public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
                                        NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
        // 获取paramter的信息，NamedValueInfo包含参数的名称、是否必填、默认值,其实就是该参数在RequestParam注解中的配置
        NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);
        // 如果parameter是Optional类型，那么就产生一个指向相同参数对象但嵌套等级（nestingLevel）+1的MethodParameter
        MethodParameter nestedParameter = parameter.nestedIfOptional();
        // 先后解析配置项与SPEL表达式（即${}、#{}）
        Object resolvedName = resolveStringValue(namedValueInfo.name);
        if (resolvedName == null) {
            throw new IllegalArgumentException(
                    &quot;Specified name must not resolve to null: [&quot; + namedValueInfo.name + &quot;]&quot;);
        }
        // 从请求（request）中获取对应名称的数据，如果非上传文件，就相当于servlet中的request.getParameter()，另外如果有多个符合name的值会返回String[]
        Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);
        if (arg == null) {
            if (namedValueInfo.defaultValue != null) {
                // 请求中没有这个参数并且有默认值就将解析defaultValue后值的设为参数
                arg = resolveStringValue(namedValueInfo.defaultValue);
            } else if (namedValueInfo.required &amp;amp;&amp;amp; !nestedParameter.isOptional()) {
                // 参数必填且方法的类型要求不是Optional的话抛异常
                handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);
            }
            // 处理null值。如果参数类型（或者被Optional包裹的类型）是Boolean会转换成false，而如果参数类型是基本类型的话会抛出异常（因为基本类型值不能为null）
            arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());
        } else if (&quot;&quot;.equals(arg) &amp;amp;&amp;amp; namedValueInfo.defaultValue != null) {
            // 如果有默认值将会把空字符串处理为默认值
            arg = resolveStringValue(namedValueInfo.defaultValue);
        }

        if (binderFactory != null) {
            // biner中有conversionService的实例，而conversionService中就包含着全部可用的转换器。
            WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);
            try {
                // 开始真正的类型转换
                arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);
            } catch (ConversionNotSupportedException ex) {
                throw new MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(),
                        namedValueInfo.name, parameter, ex.getCause());
            } catch (TypeMismatchException ex) {
                throw new MethodArgumentTypeMismatchException(arg, ex.getRequiredType(),
                        namedValueInfo.name, parameter, ex.getCause());

            }
        }

        // 钩子方法，重写这个方法的暂时只有PathVariableMethodArgumentResolver
        handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);

        return arg;
    }
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class TypeConverterDelegate {
    // ...

    /**
     * Convert the value to the required type (if necessary from a String),
     * for the specified property.
     *
     * @param propertyName   name of the property
     * @param oldValue       the previous value, if available (may be {@code null})
     * @param newValue       the proposed new value
     * @param requiredType   the type we must convert to
     *                       (or {@code null} if not known, for example in case of a collection element)
     * @param typeDescriptor the descriptor for the target property or field
     * @return the new value, possibly the result of type conversion
     * @throws IllegalArgumentException if type conversion failed
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Nullable
    public &amp;lt;T&amp;gt; T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue,
                                    @Nullable Class&amp;lt;T&amp;gt; requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {
        // 在当前的流程中propertyName、oldValue为null，newValue为前台传过来的真实参数值，requiredType为处理方法要求的类型，typeDescriptor为要求类型的描述封装类

        // Custom editor for this type?
        PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);

        ConversionFailedException conversionAttemptEx = null;

        // No custom editor but custom ConversionService specified?
        ConversionService conversionService = this.propertyEditorRegistry.getConversionService();
        if (editor == null &amp;amp;&amp;amp; conversionService != null &amp;amp;&amp;amp; newValue != null &amp;amp;&amp;amp; typeDescriptor != null) {
            // 上述条件成立
            // 在现在的逻辑里sourceTypeDesc必然为String的TypeDescriptor
            TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);
            if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {
                // 可以转换
                // canConvert实际上是尝试获取符合条件的GenericConverter，如果有就说明可以转换
                // 对于String -&amp;gt; Integer的转换，会先将String类型拆为 [String,Serializable,Comparable,CharSequence,Object]的类型层，Integer同样拆为自己的类型层，之后先后遍历每个类型来准确判断是否存在可以转换的转换器
                try {
                    // 最终会调用到自定义的转换器
                    return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);
                } catch (ConversionFailedException ex) {
                    // fallback to default conversion logic below
                    // 转换失败，暂存异常，将会执行默认的转换逻辑
                    conversionAttemptEx = ex;
                }
            }
        }
        // 因为spring自带了很多常见类型的转换器，大部分都可以通过上面的转换器完成。
        // 程序运行到这里没有结束的话很可能说明类型是没有定义转换器的自定义类型或者参数格式真的不正确

        Object convertedValue = newValue;

        // Value not of required type?
        if (editor != null || (requiredType != null &amp;amp;&amp;amp; !ClassUtils.isAssignableValue(requiredType, convertedValue))) {
            // 最后的条件为 当newValue不是requiredType的实例
            if (typeDescriptor != null &amp;amp;&amp;amp; requiredType != null &amp;amp;&amp;amp; Collection.class.isAssignableFrom(requiredType) &amp;amp;&amp;amp;
                    convertedValue instanceof String) {
                // isAssignableFrom用来判断Collection是否为requiredType的父类或者接口，或者二者是否为同一类型或接口
                TypeDescriptor elementTypeDesc = typeDescriptor.getElementTypeDescriptor();
                if (elementTypeDesc != null) {
                    Class&amp;lt;?&amp;gt; elementType = elementTypeDesc.getType();
                    if (Class.class == elementType || Enum.class.isAssignableFrom(elementType)) {
                        // 相当于convertedValue.split(&quot;,&quot;)
                        convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);
                    }
                }
            }
            if (editor == null) {
                editor = findDefaultEditor(requiredType);
            }
            // 使用默认的editor进行转换，不过默认的editor的转换有可能与期望的不一致。（比如 &quot;1,2,3,4&quot; -&amp;gt; ArrayList&amp;lt;String&amp;gt;{&quot;1,2,3,4&quot;}，结果是只有一个元素的list）
            convertedValue = doConvertValue(oldValue, convertedValue, requiredType, editor);
        }

        boolean standardConversion = false;

        // 加下来会根据requiredType来做出相应的转换
        if (requiredType != null) {
            // Try to apply some standard type conversion rules if appropriate.

            if (convertedValue != null) {
                if (Object.class == requiredType) {
                    // requiredType是Object
                    return (T) convertedValue;
                } else if (requiredType.isArray()) {
                    // requiredType是数组
                    // Array required -&amp;gt; apply appropriate conversion of elements.
                    if (convertedValue instanceof String &amp;amp;&amp;amp; Enum.class.isAssignableFrom(requiredType.getComponentType())) {
                        convertedValue = StringUtils.commaDelimitedListToStringArray((String) convertedValue);
                    }
                    return (T) convertToTypedArray(convertedValue, propertyName, requiredType.getComponentType());
                } else if (convertedValue instanceof Collection) {
                    // 将convertedValue转换为集合，内部对每个元素调用了convertIfNecessary（即本方法）
                    // Convert elements to target type, if determined.
                    convertedValue = convertToTypedCollection(
                            (Collection&amp;lt;?&amp;gt;) convertedValue, propertyName, requiredType, typeDescriptor);
                    standardConversion = true;
                } else if (convertedValue instanceof Map) {
                    // 将convertedValue转换为Map
                    // Convert keys and values to respective target type, if determined.
                    convertedValue = convertToTypedMap(
                            (Map&amp;lt;?, ?&amp;gt;) convertedValue, propertyName, requiredType, typeDescriptor);
                    standardConversion = true;
                }
                if (convertedValue.getClass().isArray() &amp;amp;&amp;amp; Array.getLength(convertedValue) == 1) {
                    convertedValue = Array.get(convertedValue, 0);
                    standardConversion = true;
                }
                if (String.class == requiredType &amp;amp;&amp;amp; ClassUtils.isPrimitiveOrWrapper(convertedValue.getClass())) {
                    // We can stringify any primitive value...
                    return (T) convertedValue.toString();
                } else if (convertedValue instanceof String &amp;amp;&amp;amp; !requiredType.isInstance(convertedValue)) {
                    if (conversionAttemptEx == null &amp;amp;&amp;amp; !requiredType.isInterface() &amp;amp;&amp;amp; !requiredType.isEnum()) {
                        try {
                            Constructor&amp;lt;T&amp;gt; strCtor = requiredType.getConstructor(String.class);
                            return BeanUtils.instantiateClass(strCtor, convertedValue);
                        } catch (NoSuchMethodException ex) {
                            // proceed with field lookup
                            if (logger.isTraceEnabled()) {
                                logger.trace(&quot;No String constructor found on type [&quot; + requiredType.getName() + &quot;]&quot;, ex);
                            }
                        } catch (Exception ex) {
                            if (logger.isDebugEnabled()) {
                                logger.debug(&quot;Construction via String failed for type [&quot; + requiredType.getName() + &quot;]&quot;, ex);
                            }
                        }
                    }
                    String trimmedValue = ((String) convertedValue).trim();
                    if (requiredType.isEnum() &amp;amp;&amp;amp; trimmedValue.isEmpty()) {
                        // It's an empty enum identifier: reset the enum value to null.
                        return null;
                    }
                    // 尝试转换为枚举
                    convertedValue = attemptToConvertStringToEnum(requiredType, trimmedValue, convertedValue);
                    standardConversion = true;
                } else if (convertedValue instanceof Number &amp;amp;&amp;amp; Number.class.isAssignableFrom(requiredType)) {
                    convertedValue = NumberUtils.convertNumberToTargetClass(
                            (Number) convertedValue, (Class&amp;lt;Number&amp;gt;) requiredType);
                    standardConversion = true;
                }
            } else {
                // convertedValue == null
                if (requiredType == Optional.class) {
                    convertedValue = Optional.empty();
                }
            }

            if (!ClassUtils.isAssignableValue(requiredType, convertedValue)) {
                if (conversionAttemptEx != null) {
                    // Original exception from former ConversionService call above...
                    throw conversionAttemptEx;
                } else if (conversionService != null &amp;amp;&amp;amp; typeDescriptor != null) {
                    // ConversionService not tried before, probably custom editor found
                    // but editor couldn't produce the required type...
                    TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);
                    if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {
                        return (T) conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);
                    }
                }

                // Definitely doesn't match: throw IllegalArgumentException/IllegalStateException
                StringBuilder msg = new StringBuilder();
                msg.append(&quot;Cannot convert value of type '&quot;).append(ClassUtils.getDescriptiveType(newValue));
                msg.append(&quot;' to required type '&quot;).append(ClassUtils.getQualifiedName(requiredType)).append(&quot;'&quot;);
                if (propertyName != null) {
                    msg.append(&quot; for property '&quot;).append(propertyName).append(&quot;'&quot;);
                }
                if (editor != null) {
                    msg.append(&quot;: PropertyEditor [&quot;).append(editor.getClass().getName()).append(
                            &quot;] returned inappropriate value of type '&quot;).append(
                            ClassUtils.getDescriptiveType(convertedValue)).append(&quot;'&quot;);
                    throw new IllegalArgumentException(msg.toString());
                } else {
                    msg.append(&quot;: no matching editors or conversion strategy found&quot;);
                    throw new IllegalStateException(msg.toString());
                }
            }
        }

        if (conversionAttemptEx != null) {
            if (editor == null &amp;amp;&amp;amp; !standardConversion &amp;amp;&amp;amp; requiredType != null &amp;amp;&amp;amp; Object.class != requiredType) {
                throw conversionAttemptEx;
            }
            logger.debug(&quot;Original ConversionService attempt failed - ignored since &quot; +
                    &quot;PropertyEditor based conversion eventually succeeded&quot;, conversionAttemptEx);
        }

        return (T) convertedValue;
    }
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;看源码虽然很费时间，但是的确是能学到很多东西的，而且也能发现很多以前不知道的事情（比如RequestParam注解的name和defaultName参数是可以嵌套引用配置文件中的内容，也可以写SPEL表达式），但其中还是有一些地方不是很清楚。&lt;/p&gt;
&lt;p&gt;虽说现在项目都直接使用JSON做前后端交互，大部分类型转换的任务都交给了JSON序列化框架，但是参数绑定这里还是值得看一看，等到需要用的时候就可以直接拿出来用。&lt;/p&gt;
</description>
<pubDate>Sun, 30 Dec 2018 13:59:00 +0000</pubDate>
<dc:creator>baka-sky</dc:creator>
<og:description>Spring的类型转换 以前在面试中就有被问到关于spring数据绑定方面的问题，当时对它一直只是朦朦胧胧的概念，最近稍微闲下来有时间看了一下其中数据转换相关的内容，把相应的内容做个记录。 下面先说明</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baka-sky/p/10200845.html</dc:identifier>
</item>
<item>
<title>多线程编程的初步形象化理解 - 立志改变世界的nobody</title>
<link>http://www.cnblogs.com/wenmingCode/p/10200784.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenmingCode/p/10200784.html</guid>
<description>&lt;p&gt;近日在学习Java的并发编程，接触到一些新的概念，开始比较晦涩，就想到用一个例子来生动地解释一下，或许可以帮助到初学者来理解。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;并发编程&lt;/span&gt;，与顺序编程相反相成。并发指的是，有多个程序同时处于开始执行和执行完毕的状态之间。线程，是分配CPU时间的最小单位，用以驱动程序块的执行。进程，是运行在它自己的地址空间内的自包容的程序。&lt;/p&gt;
&lt;p&gt;说人话，用&lt;span&gt;比喻&lt;/span&gt;来理解这个问题：&lt;/p&gt;
&lt;p&gt;我们用马来代指线程，用马厩来代指线程池，用牧马人来代指CPU。&lt;/p&gt;
&lt;p&gt;作为一匹马，可以执行拉车、拉磨、耕地、载人等各种任务，但是必须要有人来指挥管理才能正常执行。人可以给同一匹马分配多个任务，也可以分配单个甚至不分配任务：相当于每一个线程都有自己的任务Runnable序列。每一匹马会将车从头拉到尾、或者把一担谷子在磨盘上磨完再执行下一个任务：线程总是把一个任务队列中的一个任务完成，才执行下一个任务。人需要照顾管理所有正在执行任务的马，只有人在场，马才能正常工作，否则它们都会偷懒，除非有多个牧马人来管理——每一个时刻只有一个线程被CPU执行，其他线程就被挂起，除非有多个CPU。每当来了新任务，人要么将这个任务放到一匹马的任务序列中，要么从马厩中另外拉一匹马出来执行这个任务：从线程池取出线程执行任务。&lt;/p&gt;
&lt;p&gt;当没有任务时，马厩被暂时解散，马厩里的马都放归牧场：线程池被shutdown。新来了任务，人就从牧场上赶马进入马厩：生成线程池。赶马进马厩的时候，你可以一开始就确定好赶几匹马进来，比如5匹马——&lt;span&gt;Ececutors.newFixedThreadPool(5) &lt;span&gt;，或者只要一匹马——&lt;span&gt;Executor.newSingleThreadExecutor()&lt;span&gt;。假如开始不知道要几匹马，就用&lt;span&gt;Executor.newCachedThreadPool()&lt;/span&gt;来为你服务，当然这要增加CPU开销——你得时刻准备着去牧场找马。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;进程&lt;/span&gt;，就是一个完整的、封闭的任务。比如，用马拉车是一个任务，用马把小麦拉到磨坊、再拉磨给小麦磨成面粉、再把磨好的面粉拉到集市上卖掉也是一个任务。前者用一匹马比较简单，因为只要套一次车，换马的话要套车、解套再套到另外一匹马身上，所以这种任务常常用一个线程就能很好地解决。后者，则需要好几匹马来做，所以用多个线程来驱动会更好。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;锁&lt;/span&gt;，是用来保证对象在一个进程对它的访问结束之前，专属于此线程的工具。比如，一包小麦被马拉到磨坊去，只有拉到了，磨坊里的马才能拉磨磨面粉；也只有磨面粉完成了，面粉才能被拉到集市上出售。如果没有锁，可能会出现石磨空转、小麦和面粉混合在一个袋子里的情况。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程间的通信&lt;/span&gt;，是为了相互通知情况。比如，一匹马把小麦拉到磨坊了，铃铛会响，告知磨坊的马可以拉磨了——用notify或者notifyAll来告知正在wait的线程可以尝试采取动作了。&lt;/p&gt;

&lt;p&gt;用这个比喻简单地描述了一下多线程编程的一些基本概念，比喻可能不太恰当，欢迎大家交流。&lt;/p&gt;
</description>
<pubDate>Sun, 30 Dec 2018 13:38:00 +0000</pubDate>
<dc:creator>立志改变世界的nobody</dc:creator>
<og:description>近日在学习Java的并发编程，接触到一些新的概念，开始比较晦涩，就想到用一个例子来生动地解释一下，或许可以帮助到初学者来理解。 并发编程，与顺序编程相反相成。并发指的是，有多个程序同时处于开始执行和执</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenmingCode/p/10200784.html</dc:identifier>
</item>
</channel>
</rss>