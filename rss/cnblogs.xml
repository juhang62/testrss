<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Jumpserver简介,部署使用 - you-men</title>
<link>http://www.cnblogs.com/you-men/p/13939724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/you-men/p/13939724.html</guid>
<description>&lt;h4 id=&quot;jumpserver简介&quot;&gt;Jumpserver简介&lt;/h4&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Jumpserver 是一款使用 Python, Django 开发的开源跳板机系统, 为亏联网企业提供了认证，授权，审计，自动化运维等功能，基于ssh协议来管理，客户端无需安装agent。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;jumpserver功能特点&quot;&gt;jumpserver功能特点&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
        1. 完全开源，GPL授权
        2. Python编写，容易二开
        3. 实现了跳板机基本功能，身份认证、访问控制、授权、审计、批量操作等。
        4. 集成了Ansible，批量命令等
        5. 支持WebTerminal
        6. Bootstrap编写，界面美观
        7. 自动收集硬件信息
        8. 录像回放
        9. 命令搜索
        10. 实时监控
        11. 批量上传下载
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;主要组件&quot;&gt;主要组件&lt;/h5&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;JumpServer 为管理后台, 管理员可以通过 Web 页面进行资产管理、用户管理、资产授权等操作, 用户可以通过 Web 页面进行资产登录, 文件管理等操作&lt;/p&gt;
&lt;p&gt;1.koko 为 SSH Server 和 Web Terminal Server 。用户可以使用自己的账户通过 SSH 或者 Web Terminal 访问 SSH 协议和 Telnet 协议资产&lt;/p&gt;
&lt;p&gt;2.Luna 为 Web Terminal Server 前端页面, 用户使用 Web Terminal 方式登录所需要的组件&lt;/p&gt;
&lt;p&gt;3.Guacamole 为 RDP 协议和 VNC 协议资产组件, 用户可以通过 Web Terminal 来连接 RDP 协议和 VNC 协议资产 (暂时只能通过 Web Terminal 来访问)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;部署&quot;&gt;部署&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;安装jumpserver 3.0版本，相对于jumpserver 2.0版本，在新的版本3.0中取消了LDAP授权，取而代之的是ssh进行推送；界面也有所变化，功能更完善，安装更简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;初始化&quot;&gt;初始化&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/env bash
# Author: ZhouJian
# Mail: 18621048481@163.com
# Time: 2019-9-3
# Describe: CentOS 7 Initialization Script
clear
echo -ne &quot;\\033[0;33m&quot;
cat&amp;lt;&amp;lt;EOT
                                  _oo0oo_
                                 088888880
                                 88&quot; . &quot;88
                                 (| -_- |)
                                  0\\ = /0
                               ___/'---'\\___
                             .' \\\\\\\\|     |// '.
                            / \\\\\\\\|||  :  |||// \\\\
                           /_ ||||| -:- |||||- \\\\
                          |   | \\\\\\\\\\\\  -  /// |   |
                          | \\_|  ''\\---/''  |_/ |
                          \\  .-\\__  '-'  __/-.  /
                        ___'. .'  /--.--\\  '. .'___
                     .&quot;&quot; '&amp;lt;  '.___\\_&amp;lt;|&amp;gt;_/___.' &amp;gt;'  &quot;&quot;.
                    | | : '-  \\'.;'\\ _ /';.'/ - ' : | |
                    \\  \\ '_.   \\_ __\\ /__ _/   .-' /  /
                ====='-.____'.___ \\_____/___.-'____.-'=====
                                  '=---='
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                建议系统                    CentOS7
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
EOT
echo -ne &quot;\\033[m&quot;

init_hostname() {
while read -p &quot;请输入您想设定的主机名：&quot; name
do
        if [ -z &quot;$name&quot; ];then
                echo -e &quot;\033[31m 您没有输入内容，请重新输入 \033[0m&quot;
                continue
        fi
        read -p &quot;您确认使用该主机名吗？[y/n]: &quot; var

        if [ $var == 'y' -o $var == 'yes' ];then
                hostnamectl set-hostname $name
                break
        fi
done
}


init_security() {
systemctl stop firewalld
systemctl disable firewalld &amp;amp;&amp;gt;/dev/null
setenforce 0
sed -i '/^SELINUX=/ s/enforcing/disabled/'  /etc/selinux/config
sed -i '/^GSSAPIAu/ s/yes/no/' /etc/ssh/sshd_config
sed -i '/^#UseDNS/ {s/^#//;s/yes/no/}' /etc/ssh/sshd_config
systemctl enable sshd crond &amp;amp;&amp;gt; /dev/null
echo -e &quot;\033[32m [安全配置] ==&amp;gt; OK \033[0m&quot;
}

init_yumsource() {
if [ ! -d /etc/yum.repos.d/backup ];then
        mkdir /etc/yum.repos.d/backup
fi
mv /etc/yum.repos.d/* /etc/yum.repos.d/backup 2&amp;gt;/dev/null

if ! ping -c 2 baidu.com &amp;amp;&amp;gt;/dev/null     
then
        echo &quot;您无法上外网，不能配置yum源&quot;
        exit    
fi
        curl -o /etc/yum.repos.d/163.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo &amp;amp;&amp;gt;/dev/null 
        curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo &amp;amp;&amp;gt;/dev/null
timedatectl set-timezone Asia/Shanghai
echo &quot;nameserver 114.114.114.114&quot; &amp;gt; /etc/resolv.conf
echo &quot;nameserver 8.8.8.8&quot; &amp;gt;&amp;gt; /etc/resolv.conf
chattr +i /etc/resolv.conf

echo -e &quot;\033[32m [YUM　Source] ==&amp;gt; OK \033[0m&quot;
}

init_install_package() {
echo -e &quot;\033[32m 安装系统需要的软件，请稍等~ ~ ~ \033[0m&quot;
yum -y install lsof tree wget vim  bash-completion lftp bind-utils  &amp;amp;&amp;gt;/dev/null 
yum -y install atop htop nethogs net-tools libcurl-devel libxml2-devel openssl-devel unzip  psmisc ntpdate nslookup &amp;amp;&amp;gt;/dev/null 
echo -e &quot;\033[32m [安装常用工具] ==&amp;gt; OK \033[0m&quot;
}

init_kernel_parameter() {
cat &amp;gt; /etc/sysctl.conf &amp;lt;&amp;lt;EOF
fs.file-max = 999999
kernel.sysrq = 0
kernel.core_uses_pid = 1
kernel.msgmnb = 65536
kernel.msgmax = 65536
kernel.shmmax = 68719476736
kernel.shmall = 4294967296
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
net.ipv4.icmp_echo_ignore_broadcasts = 1
net.ipv4.icmp_ignore_bogus_error_responses = 1
net.ipv4.ip_forward = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.default.accept_source_route = 0
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_tw_buckets = 6000
net.ipv4.tcp_sack = 1
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_rmem = 4096 87380 4194304
net.ipv4.tcp_wmem = 4096 16384 4194304
net.ipv4.tcp_max_orphans = 3276800
net.ipv4.tcp_max_syn_backlog = 262144
net.ipv4.tcp_timestamps = 0
net.ipv4.tcp_synack_retries = 1
net.ipv4.tcp_syn_retries = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_mem = 94500000 915000000 927000000
net.ipv4.tcp_fin_timeout = 1
net.ipv4.tcp_keepalive_time = 30
net.ipv4.ip_local_port_range = 1024 65000
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.default.secure_redirects = 0
net.core.wmem_default = 8388608
net.core.rmem_default = 8388608
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.core.netdev_max_backlog = 262144
vm.swappiness = 10
EOF
sysctl -p /etc/sysctl.conf &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
echo -e &quot;\033[32m [内核 优化] ==&amp;gt; OK \033[0m&quot;
}

# **************************************************
init_system_limit() {
cat &amp;gt;&amp;gt; /etc/security/limits.conf &amp;lt;&amp;lt;EOF
* soft nproc 65530
* hard nproc 65530
* soft nofile 65530
* hard nofile 65530
EOF
ulimit -n 65535
ulimit -u 20480
echo -e &quot;\033[32m [ulimits 配置] ==&amp;gt; OK \033[0m&quot;
cat &amp;gt;&amp;gt; /etc/profile &amp;lt;&amp;lt;EOF
export HISTTIMEFORMAT=&quot;%Y-%m-%d %H:%M:%S &quot;
EOF
source /etc/profile
}

main() {
init_hostname
init_security
init_yumsource
init_install_package
init_kernel_parameter
init_system_limit
}
main
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;修改字符集&quot;&gt;修改字符集&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;localedef -c -f UTF-8 -i zh_CN zh_CN.UTF-8
export LC_ALL=zh_CN.UTF-8
echo 'LANG=&quot;zh_CN.UTF-8&quot;' &amp;gt; /etc/locale.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;安装基础包和依赖&quot;&gt;安装基础包和依赖&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;yum -y install wget vim lrzsz xz gcc git epel-release python-pip python-devel mysql-devel automake autoconf sqlite-devel zlib-devel openssl-devel sshpass readline-devel


yum -y install python36 python36-devel

cd /opt
python3.6 -m venv py3
source /opt/py3/bin/activate
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;安装jumpserver&quot;&gt;安装Jumpserver&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;git clone --depth=1 https://github.com/jumpserver/jumpserver.git

cd /opt/jumpserver/requirements
yum -y install $(cat rpm_requirements.txt)
pip install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/
  
  
pip install --upgrade pip setuptools
pip install -r requirements.txt  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;安装redis&quot;&gt;安装redis&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;(py3) [root@kvm-47 requirements]#  yum -y install redis
(py3) [root@kvm-47 requirements]# systemctl enable redis &amp;amp;&amp;amp; systemctl start redis
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;安装mysql&quot;&gt;安装Mysql&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;(py3) [root@kvm-47 requirements]#  yum -y install mariadb mariadb-devel mariadb-server
(py3) [root@kvm-47 requirements]# systemctl enable mariadb &amp;amp;&amp;amp;  systemctl start mariadb
(py3) [root@kvm-47 jumpserver]# mysqladmin -u root password 'ZHOUjian.20'

(py3) [root@kvm-47 jumpserver]# DB_PASSWORD=`cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 24`
(py3) [root@kvm-47 jumpserver]# echo $DB_PASSWORD
hDh4XtVKUxsRUPwYdEFznKTK
(py3) [root@kvm-47 jumpserver]# mysql -uroot -pZHOUjian.20 -e &quot;create database jumpserver default charset 'utf8'; grant all on jumpserver.* to 'jumpserver'@'127.0.0.1' identified by '$DB_PASSWORD'; flush privileges;&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置jumpserver&quot;&gt;配置jumpserver&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;(py3) [root@kvm-47 requirements]# cd /opt/jumpserver/
(py3) [root@kvm-47 jumpserver]# ls
apps                docs           logs          run_server.py
config_example.yml  entrypoint.sh  README_EN.md  tmp
data                jms            README.md     utils
Dockerfile          LICENSE        requirements  Vagrantfile

(py3) [root@kvm-47 jumpserver]# cp config_example.yml config.yml


SECRET_KEY=`cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 50`   
echo &quot;SECRET_KEY=$SECRET_KEY&quot; &amp;gt;&amp;gt; ~/.bashrc
BOOTSTRAP_TOKEN=`cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 16` 
echo &quot;BOOTSTRAP_TOKEN=$BOOTSTRAP_TOKEN&quot; &amp;gt;&amp;gt; ~/.bashrc
sed -i &quot;s/SECRET_KEY:/SECRET_KEY: $SECRET_KEY/g&quot; /opt/jumpserver/config.yml
sed -i &quot;s/BOOTSTRAP_TOKEN:/BOOTSTRAP_TOKEN: $BOOTSTRAP_TOKEN/g&quot; /opt/jumpserver/config.yml
sed -i &quot;s/# DEBUG: true/DEBUG: false/g&quot; /opt/jumpserver/config.yml
sed -i &quot;s/# LOG_LEVEL: DEBUG/LOG_LEVEL: ERROR/g&quot; /opt/jumpserver/config.yml
sed -i &quot;s/# SESSION_EXPIRE_AT_BROWSER_CLOSE: false/SESSION_EXPIRE_AT_BROWSER_CLOSE: true/g&quot; /opt/jumpserver/config.yml
sed -i &quot;s/DB_PASSWORD: /DB_PASSWORD: $DB_PASSWORD/g&quot; /opt/jumpserver/config.yml
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;启动关闭jumpservere&quot;&gt;启动关闭jumpservere&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;(py3) [root@kvm-47 jumpserver]# cd /opt/jumpserver/
(py3) [root@kvm-47 jumpserver]# ./jms start all -d
(py3) [root@kvm-47 jumpserver]# ./jms stop
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;部署coco&quot;&gt;部署coco&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;支持终端管理,默认port为2222&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;手动部署&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;cd /opt
git clone --depth=1 https://github.com/jumpserver/coco.git 
cd /opt/coco/requirements

pip install --upgrade pip
pip install -r requirements.txt
yum -y install $(cat rpm_requirements.txt)
pip install --upgrade pip setuptools==45.2.0
pip install -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/

cd /opt/coco
cp config_example.yml config.yml
sed -i &quot;s/BOOTSTRAP_TOKEN: &amp;lt;PleasgeChangeSameWithJumpserver&amp;gt;/BOOTSTRAP_TOKEN: $BOOTSTRAP_TOKEN/g&quot; /opt/coco/config.yml
sed -i &quot;s/# LOG_LEVEL: INFO/LOG_LEVEL: ERROR/g&quot; /opt/coco/config.yml
./cocod start -d
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;部署luna&quot;&gt;部署luna&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;与nginx结合支持Web Terminal前端&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;cd /opt
wget https://github.com/jumpserver/luna/releases/download/1.4.10/luna.tar.gz
tar xf luna.tar.gz  
chown -R root:root luna
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置nginx&quot;&gt;配置nginx&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;vi /etc/yum.repos.d/nginx.repo
[nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=1
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
yum install -y nginx
yum makecache fast
systemctl enable nginx
rm -rf /etc/nginx/conf.d/default.conf


cd /etc/nginx/
sed -i '/^ *#/d'  nginx.conf
sed -ri '/^[[:space:]]*(#|$)/d'  nginx.conf



server {
    listen 80;
    client_max_body_size 100m;  # 录像及文件上传大小限制
    location /luna/ {
        try_files $uri / /index.html;
        alias /opt/luna/;  # luna 路径, 如果修改安装目录, 此处需要修改
    }
    location /media/ {
        add_header Content-Encoding gzip;
        root /opt/jumpserver/data/;  # 录像位置, 如果修改安装目录, 此处需要修改
    }

    location /static/ {
        root /opt/jumpserver/data/;  # 静态资源, 如果修改安装目录, 此处需要修改
    }

    location /socket.io/ {
        proxy_pass       http://localhost:5000/socket.io/;
        proxy_buffering off;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &quot;upgrade&quot;;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        access_log off;
    }

    location /coco/ {
        proxy_pass       http://localhost:5000/coco/;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        access_log off;
    }

    location /guacamole/ {
        proxy_pass       http://localhost:8081/;
        proxy_buffering off;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $http_connection;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        access_log off;
    }

    location / {
        proxy_pass http://localhost:8080;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;登录测试&quot;&gt;登录测试&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 检查应用是否已经正常运行
# 服务全部启动后, 访问 jumpserver 服务器 nginx 代理的 80 端口, 不要通过8080端口访问
# 默认账号: admin 密码: admin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201107040739067-959919122.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Nov 2020 20:08:00 +0000</pubDate>
<dc:creator>you-men</dc:creator>
<og:description>Jumpserver简介 Jumpserver 是一款使用 Python, Django 开发的开源跳板机系统, 为亏联网企业提供了认证，授权，审计，自动化运维等功能，基于ssh协议来管理，客户端无需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/you-men/p/13939724.html</dc:identifier>
</item>
<item>
<title>sort回调的简单模拟 - 小z同学</title>
<link>http://www.cnblogs.com/zzzz76/p/13939695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzzz76/p/13939695.html</guid>
<description>&lt;p&gt;本来是准备讲CPP中的std::sort，但因为最近Java用得多，不知怎么的便习惯性走Java角度看问题了，所以这篇文章看起来估计会有点奇怪...&lt;/p&gt;
&lt;h2 id=&quot;一、简单模拟sort回调&quot;&gt;一、简单模拟sort回调&lt;/h2&gt;
&lt;p&gt;std::sort函数本质上是一个静态回调函数，在回调中属于非常基本的操作，这里就不细讲，我们可以尝试进行模拟实现。&lt;/p&gt;
&lt;p&gt;顺序图以及相应代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/1039974/202011/1039974-20201107005927546-133336409.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1039974/202011/1039974-20201107005927546-133336409.png&quot; width=&quot;40%&quot; height=&quot;40%&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;main.cpp&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &quot;main.h&quot;

typedef struct Student {
    int high;
    int weigh;
    int age;
} Student;

// 排序函数可以自行实现
bool cmp(Student s1, Student s2) {
    return s1.high &amp;lt; s2.high;
}

int main() {
    Student s1 = {1, 2, 3};
    Student s2 = {3, 1, 2};

    mysort(s1, s2, cmp);
    printf(&quot;%d %d %d\n&quot;, s1.high, s1.weigh, s1.age);
    printf(&quot;%d %d %d\n&quot;, s2.high, s2.weigh, s2.age);


    return EXIT_SUCCESS;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;main.h&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#ifndef CPROJECT_MAIN_H
#define CPROJECT_MAIN_H

// sort函数的简单仿写，此处仅实现一次交换
template&amp;lt;typename RandomAccessor, typename FUNC&amp;gt;
void mysort(RandomAccessor&amp;amp; first, RandomAccessor&amp;amp; second, FUNC cmp) {
    if (!cmp(first, second)) {
        RandomAccessor temp = first;
        first = second;
        second = temp;
    }
}

#endif //CPROJECT_MAIN_H
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、存在的问题&quot;&gt;二、存在的问题&lt;/h2&gt;
&lt;p&gt;那么静态的回调会产生生什么缺点呢？&lt;/p&gt;
&lt;p&gt;如果sort函数用的多，我们会发现，在面向对象的调用中，一旦回调方法cmp需要调用对象中的某个成员时，由于cmp本身是静态的，它将无法完成调用。&lt;/p&gt;
&lt;h2 id=&quot;三、关于改进&quot;&gt;三、关于改进&lt;/h2&gt;
&lt;p&gt;所以我们可以产生一种重写sort的想法：在调用方建立内部类，并给予内部类调用外部类的权限。然后将内部类的实例传递给sort，并回调内部类中cmp方法，如此一来sort便可以很好的基于对象成员完成比较。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/1039974/202011/1039974-20201107005942956-1548388455.png&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1039974/202011/1039974-20201107005942956-1548388455.png&quot; width=&quot;40%&quot; height=&quot;40%&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我相信lambda表达式也是基于这个原理实现的。&lt;/p&gt;
</description>
<pubDate>Fri, 06 Nov 2020 17:23:00 +0000</pubDate>
<dc:creator>小z同学</dc:creator>
<og:description>本来是准备讲CPP中的std::sort，但因为最近Java用得多，不知怎么的便习惯性走Java角度看问题了，所以这篇文章看起来估计会有点奇怪... 一、简单模拟sort回调 std::sort函数本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzzz76/p/13939695.html</dc:identifier>
</item>
<item>
<title>Verilog小总结 - BUAA-YiFei</title>
<link>http://www.cnblogs.com/BUAA-YiFei/p/13939329.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BUAA-YiFei/p/13939329.html</guid>
<description>&lt;h2 id=&quot;基础&quot;&gt;基础&lt;/h2&gt;
&lt;h3 id=&quot;assign&quot;&gt;assign&lt;/h3&gt;
&lt;p&gt;assign作为一个组合逻辑常用的语句，可认为是将电线连接起来，当然它能做的不仅仅是将一个输入直接输出，它能把输入信号进行逻辑运算后再输出。&lt;strong&gt;当assign左右两边位宽不相等时，将自动进行零扩展或截断以匹配左边的位宽。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;eg：&lt;img src=&quot;https://hdlbits.01xz.net/mw/images/3/3a/Wiredecl2.png&quot; alt=&quot;Wiredecl2.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;module top_module (
        input a,
        input b,
        input c,
        input d,
        output out,
        output out_n );
        wire w1, w2;            // Declare two wires (named w1 and w2)
        assign w1 = a&amp;amp;b;    // First AND gate
        assign w2 = c&amp;amp;d;    // Second AND gate
        assign out = w1|w2;     // OR gate: Feeds both 'out' and the NOT gate
        assign out_n = ~out;    // NOT gate
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;vectors&quot;&gt;Vectors&lt;/h3&gt;
&lt;h4 id=&quot;声明向量&quot;&gt;声明向量&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;type [upper：lower] vector_name;&lt;/code&gt;&lt;br/&gt;&lt;code&gt;type&lt;/code&gt;指定向量的数据类型，通常是&lt;code&gt;wire&lt;/code&gt;或&lt;code&gt;reg&lt;/code&gt;。如果要声明输入或输出端口，则该类型还可以另外包括端口类型（例如，&lt;code&gt;input&lt;/code&gt;或&lt;code&gt;output&lt;/code&gt;）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;wire [7:0] w;         // 8-bit wire
reg  [4:1] x;         // 4-bit reg
output reg [0:0] y;   // 1-bit reg that is also an output port (this is still a vector)
input wire [3:-2] z;  // 6-bit wire input (negative ranges are allowed)
output [3:0] a;       // 4-bit output wire. Type is 'wire' unless specified otherwise.
wire [0:7] b;         // 8-bit wire where b[0] is the most-significant bit.
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;部分选择&quot;&gt;部分选择&lt;/h4&gt;
&lt;p&gt;使用向量名称访问整个向量，但是当assign左右两边位宽不相等时，将自动进行零扩展或截断以匹配左边的位宽。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;vector_name[up:low]&lt;/code&gt;的形式获取部分向量，注意方向应与定义的一致，如定义了一个&lt;code&gt;a[3:0]&lt;/code&gt;,那么不能反向获取&lt;code&gt;a[0:3]&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;矢量运算&quot;&gt;矢量运算&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;~&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按位取反&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按位与&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按位或&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按位异或&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;^~&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按位同或&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注意：除了&lt;code&gt;~&lt;/code&gt;外均为双目运算符；若进行双目运算时左右两个操作数位数不一样，位数少的将在相应的高位用0扩展。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;逻辑运算&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;逻辑运算会将整个向量视为布尔值（真=非零，假=零），并且产生1位输出，如有&lt;code&gt;input [2:0] a&lt;/code&gt;和&lt;code&gt;input [2:0] b&lt;/code&gt; 那么他们的逻辑或运算即为&lt;code&gt;assign out = a || b;&lt;/code&gt;，a和b均视为一个布尔值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缩减运算&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对一个向量的每一位进行位操作，如有&lt;code&gt;a[2:0]&lt;/code&gt;，那么&lt;code&gt;b=&amp;amp;a&lt;/code&gt;相当于&lt;code&gt;b=(a[0]&amp;amp;a[1])&amp;amp;a[2]&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;矢量串联&quot;&gt;矢量串联&lt;/h4&gt;
&lt;p&gt;串联运算符&lt;code&gt;{a,b,c}&lt;/code&gt;用来将小向量串联起来创建一个更大的向量。&lt;strong&gt;串联中不允许使用不定尺寸的常量。&lt;/strong&gt;如&lt;code&gt;{1,2,3}&lt;/code&gt;是非法的，因为Verilog不知道他们的位宽。&lt;/p&gt;
&lt;p&gt;还可以用&lt;code&gt;{n{vec}}&lt;/code&gt;的形式来复制向量，如&lt;code&gt;{6{a}}&lt;/code&gt;和&lt;code&gt;{a,a,a,a,a,a}&lt;/code&gt;是一样的，同时注意两组大括号都是必须的，即&lt;code&gt;{1'b1,6{1'b0}}&lt;/code&gt;是非法的，因为其中的&lt;code&gt;6{1'b0}&lt;/code&gt;少了一组大括号，正确的写法是&lt;code&gt;{1'b1,{6{1'b0}}}&lt;/code&gt;。这其实比较好理解，串联运算符&lt;code&gt;{a,b,c}&lt;/code&gt;中的abc均为一个向量，&lt;code&gt;{n{vec}}&lt;/code&gt;也代表了一个向量，因此&lt;code&gt;{a,b,{n{c}}}&lt;/code&gt;也是一个向量&lt;/p&gt;
&lt;h3 id=&quot;模块&quot;&gt;模块&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;mod_name instance_name (signal_name1,signal_name2,signal_name3);//by position&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mod_name instance_name (.port_name1(signal_name1),.port_name2(signal_name2),.port_name3(signal_name3));//by name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以理解为一个函数,注意括号内的是外部连接到模块的信号。&lt;/p&gt;
&lt;h3 id=&quot;always块&quot;&gt;always块&lt;/h3&gt;
&lt;h4 id=&quot;组合逻辑&quot;&gt;组合逻辑&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;always @(*)&lt;/code&gt;可以类似于&lt;code&gt;assign&lt;/code&gt;的效果，当右方有变量发生改变时，左边输出随之立即改变。&lt;code&gt;assign out1 = a &amp;amp; b | c ^ d;&lt;/code&gt; 和&lt;code&gt;always @(*) out2 = a &amp;amp; b | c ^ d;&lt;/code&gt;是一样的&lt;/p&gt;
&lt;h4 id=&quot;时序逻辑&quot;&gt;时序逻辑&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;同步与异步复位&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;//同步复位
always @(posedge clk) begin
    if(reset == 1) begin
        //reset
    end
end
//异步复位
always @(posedge clk,posedge areset) begin
    if(areset == 1) begin
        //reset
    end
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;阻塞赋值非阻塞赋值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，我们在组合逻辑的always块中使用阻塞赋值（&lt;code&gt;x = y;&lt;/code&gt;）;在时序逻辑的always块中使用非阻塞赋值（&lt;code&gt;x &amp;lt;= y;&lt;/code&gt;）&lt;/p&gt;
&lt;h3 id=&quot;case&quot;&gt;case&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;always @(*) begin     //这是一个组合逻辑
    case (in)
      1'b1: begin 
               out = 1'b1;  
            end
      1'b0: out = 1'b0;
      default: out = 1'bx;
    endcase //一定记得写endcase
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意&lt;strong&gt;一定要写endcase&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外还有case的好兄弟casez，他可以匹配形如&lt;code&gt;4'bzzz1&lt;/code&gt;的向量，z表示无关位。&lt;/p&gt;
&lt;p&gt;eg：&lt;a href=&quot;https://hdlbits.01xz.net/wiki/Always_casez&quot;&gt;优先编码器&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;module top_module (
    input [7:0] in,
    output reg [2:0] pos  );
    always @(*) begin
        casez (in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default: pos =0;
        endcase
    end   
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;for&quot;&gt;for&lt;/h3&gt;
&lt;h4 id=&quot;组合for循环&quot;&gt;组合for循环&lt;/h4&gt;
&lt;p&gt;与C语言的用法类似。&lt;/p&gt;
&lt;p&gt;eg：&lt;a href=&quot;https://hdlbits.01xz.net/wiki/Popcount255&quot;&gt;人口计数器&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;module top_module (
        input [254:0] in,
        output reg [7:0] out
);
    always @(*) begin   //组合逻辑always块
                out = 0;        //一定要初始化为0
                for (int i=0;i&amp;lt;255;i++)
                        out = out + in[i];
        end
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;生成for循环&quot;&gt;生成for循环&lt;/h4&gt;
&lt;p&gt;当对矢量中多个位进行重复操作时，或进行多个模块的实例化引用的重复操作时，可使用生成块简化程序。写法如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;    genvar i;//只能用genvar作为循环变量
    generate
        for (i=1;i&amp;lt;99;i=i+1) begin: add_loop//这个名字是必须的
            mod_name instance_name(......);//括号里写由i推出的信号
        end
    endgenerate
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;eg:&lt;a href=&quot;https://hdlbits.01xz.net/wiki/Bcdadd100&quot;&gt;Bcdadd100&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    genvar i;
    wire [99:0]cout1;
    bcd_fadd mod1(a[3:0],b[3:0],cin,cout1[0],sum[3:0]);
    generate
        for (i=1;i&amp;lt;99;i=i+1) begin: addloop
            bcd_fadd mod2(a[(4*i+3):(4*i)],b[(4*i+3):(4*i)],cout1[i-1],cout1[i],sum[(4*i+3):(4*i)]);
        end
    endgenerate
    bcd_fadd mod3(a[399:396],b[399:396],cout1[98],cout,sum[399:396]);
endmodule
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;状态机写法&quot;&gt;状态机写法&lt;/h2&gt;
&lt;h3 id=&quot;moore型&quot;&gt;Moore型&lt;/h3&gt;
&lt;p&gt;三段式写法：使用一个state用于存当前状态，使用一个next_state用于存下一状态。第一段用于写状态转换逻辑，第二段用于状态转移，第三段用于输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;    reg state, next_state;

        //第一段：
        always @(*) begin    //一个组合逻辑always块，用于写状态转换逻辑，当in改变时，next_state将立即改变。
        case(state)
            A: next_state = f(in)//关于in的函数
            B: next_state = f(in)
            ...    
        endcase
    end
                
        //第二段（异步）：
    always @(posedge clk, posedge areset) begin    
        if(areset == 1) begin
            state &amp;lt;= 0;//reset
        end
        else state &amp;lt;= next_state;
    end
        //第二段（同步）：
    always @(posedge clk) begin   
        if(reset == 1) begin
            state &amp;lt;= 0;//reset
        end
        else state &amp;lt;= next_state;
    end
            
    //第三段（assign法）
            assign out = (state == ...);//判断state
        //第三段（组合逻辑always块法）
    always@(*) begin
        case (state)
            A: {out3,out2,out1} = 3'b111;
            B: {out3,out2,out1} = 3'b110;//对每一种状态输出
            ...
        endcase
    end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mealy型&quot;&gt;Mealy型&lt;/h3&gt;
&lt;p&gt;仅仅第三段发生了改变，可使用&lt;code&gt;{state,in}&lt;/code&gt;来做输出判断。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-verilog&quot;&gt;    //第三段（assign法）
    assign out = f(state,in);//关于state和in的函数
    //第三段（组合逻辑always块法）
    always@(*) begin
        case ({state,in})
            4'b0000: {out3,out2,out1} = 3'b111;
            4'b0001: {out3,out2,out1} = 3'b110;//对每一种state与in做输出
            ...
    end
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(希望明天P1能过呜呜呜&lt;/p&gt;
</description>
<pubDate>Fri, 06 Nov 2020 14:34:00 +0000</pubDate>
<dc:creator>BUAA-YiFei</dc:creator>
<og:description>Verilog小总结 基础 assign assign作为一个组合逻辑常用的语句，可认为是将电线连接起来，当然它能做的不仅仅是将一个输入直接输出，它能把输入信号进行逻辑运算后再输出。当assign左右</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/BUAA-YiFei/p/13939329.html</dc:identifier>
</item>
<item>
<title>动态规划入门——动态规划与数据结构的结合，在树上做DP - RioTian</title>
<link>http://www.cnblogs.com/RioTian/p/13939316.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RioTian/p/13939316.html</guid>
<description>&lt;p&gt;本文由&lt;code&gt;TechFlow&lt;/code&gt;原创，本博文仅作为知识点学习，不会用于任何商业用途！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;今天我们来看一个有趣的问题，通过这个有趣的问题，我们来了解一下在&lt;strong&gt;树形结构&lt;/strong&gt;当中做动态规划的方法。&lt;/p&gt;
&lt;p&gt;这个问题题意很简单，给定一棵树，并不一定是二叉树，树上的&lt;strong&gt;树枝带有权重&lt;/strong&gt;，可以看成是长度。要求树上最长的链路的长度是多少？&lt;/p&gt;
&lt;p&gt;比如我们随手画一棵树，可能丑了点，勿怪：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201106222619.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果让我们用肉眼来看，稍微尝试一下就能找到答案，最长的路径应该是下图当中红色的这条：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201106222622.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是如果让我们用算法来算，应该怎么办呢？&lt;/p&gt;
&lt;p&gt;这道题其实有一个非常巧妙的办法，我们先不讲，先来看看动态规划怎么解决这个问题。&lt;/p&gt;
&lt;h2 id=&quot;树形dp&quot;&gt;树形DP&lt;/h2&gt;
&lt;p&gt;动态规划并不只是可以在数组当中运行，实际上只要满足动态规划的&lt;strong&gt;状态转移的条件和无后效性&lt;/strong&gt;就可以使用动态规划，无论在什么数据结构当中。树上也是一样的，明白了这点之后，就只剩下了两个问题，第一个是状态是什么，第二个问题是状态之间怎么转移？&lt;/p&gt;
&lt;p&gt;在之前的背包问题当中，状态就是背包当前用的体积，转移呢就是我们新拿一个物品的决策。但是这一次我们要在树上进行动态规划，相对来说状态和对应的转移会隐蔽一些。没有关系，我会从头开始整理思路，一点一点将推导和思考的过程讲解清楚。&lt;/p&gt;
&lt;p&gt;首先，我们都知道，状态之间转移其实&lt;strong&gt;本质上是一个由局部计算整体的过程&lt;/strong&gt;。我们通过相对容易的子状态进行转移，得到整体的结果。这个是动态规划的精髓，某种程度上来说它和分治法也比较接近，都存在大问题和小问题之间逻辑上的关系。所以当我们面临一个大问题一筹莫展的时候，可以借鉴一下分治法，思考一下从小问题入手。&lt;/p&gt;
&lt;p&gt;所以，我们从小到大，由微观到宏观，来看看最简单的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201106222626.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况很明显，链路只有一条，所以长度自然是5 + 6 = 11，这显然也是最长的长度。这种情况都没有问题，下面我们来把情况稍微再变得复杂一些，我们在树上多加入一层：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201106222630.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张图稍微复杂了一些，但是路径也不难找到，应该是&lt;strong&gt;E-B-F-H&lt;/strong&gt;。路径的总长度为12：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201106222633.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是如果我们变更一下路径长度呢，比如我们把FG和FH的路径加长，会得到什么结果呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201106222636.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然这种情况下答案就变了，FGH是最长的。&lt;/p&gt;
&lt;p&gt;举这个例子只为了说明一个很简单的问题，即&lt;strong&gt;对于一棵树而言它上面的最长路径并不一定经过根节点&lt;/strong&gt;。比如刚才的例子当中，如果路径必须要经过B的话，最长只能构造出4+2+16=22的长度，但是如果可以不用经过B的话，可以得到最长的长度是31。&lt;/p&gt;
&lt;p&gt;得出这个结论看似好像没有用，但其实对于我们理清思路很有帮助。既然我们不能保证最长路径一定会经过树根，所以我们就不能直接转移答案。那我们应该怎么办呢？&lt;/p&gt;
&lt;p&gt;回答这个问题光想是不够的，依然需要我们来观察问题和深入思考。&lt;/p&gt;
&lt;h2 id=&quot;转移过程&quot;&gt;转移过程&lt;/h2&gt;
&lt;p&gt;我们再观察一下下面这两张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201106222640.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201106222716.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有没有发现什么规律？&lt;/p&gt;
&lt;p&gt;由于我们的数据结构就是树形的，所以这个最长路径不管它连通的哪两个节点，&lt;strong&gt;一定可以保证，它会经过某一棵子树的根节点&lt;/strong&gt;。不要小看这个不起眼的结论，实际上它非常重要。有了这个结论之后，我们将整条路径在根节点处切开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201106222645.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;切开之后我们&lt;strong&gt;得到了两条通往叶子节点的链路&lt;/strong&gt;，问题来了，根节点通往叶子节点的链路有很多条，为什么是这两条呢？&lt;/p&gt;
&lt;p&gt;很简单，因为这两条链路最长。所以这样&lt;strong&gt;加起来之后就可以保证得到的链路最长&lt;/strong&gt;。这两条链路都是从叶子节点通往A的，所以我们得到的最长链路就是以A为根节点的子树的最长路径。&lt;/p&gt;
&lt;p&gt;我们前面的分析说了，最长路径是不能转移的，但是&lt;strong&gt;到叶子的最长距离是可以转移的&lt;/strong&gt;。我们举个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201106222649.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;F到叶子的最长距离显然就是5和6中较大的那个，B稍微复杂一些，D和E都是叶子节点，这个容易理解。它还有一个子节点F，对于F来说它并不是叶子节点，但是我们前面算到了F到叶子节点的最长距离是6，所以B通过F到叶子节点的最长距离就是2 + 6 = 8。这样我们就得到了状态转移方程，不过我们转移的不是要求的答案而是&lt;strong&gt;从当前节点到叶子节点的最长距离和次长距离&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为只有最长距离是不够的，因为我们要将根节点的最长距离加上次长距离得到经过根节点的最长路径，由于我们之前说过，所有的路径必然经过某棵子树的根节点。这个想明白了是废话，但是这个条件的确很重要。既然所有的链路都至少经过某一个子树的根节点，那么我们&lt;strong&gt;算出所有子树经过根节点的最长路径&lt;/strong&gt;，其中最长的那个不就是答案么？&lt;/p&gt;
&lt;p&gt;下面我们演示一下这个过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201106222653.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图当中用&lt;strong&gt;粉色笔标出的就是转移的过程&lt;/strong&gt;，对于叶子节点来说最长距离和次长距离都是0，主要的转移过程发生在中间节点上。&lt;/p&gt;
&lt;p&gt;转移的过程也很容易想通，对于中间节点i，我们遍历它所有的子节点j，然后维护最大值和次大值，我们写下状态转移方程：&lt;/p&gt;
&lt;p&gt;状态转移想明白了，剩下的就是编码的问题了。可能在树上尤其是递归的时候做状态转移有些违反我们的直觉，但实际上并不难，我们写出代码来看下，我们首先来看建树的这个部分。为了简化操作，我们可以&lt;strong&gt;把树上所有的节点序号看成是int&lt;/strong&gt;，对于每一个节点，都会有一个数组存储所有与这个节点连接的边，包括父亲节点。&lt;/p&gt;
&lt;p&gt;由于我们只关注树上的链路的长度，并不关心树的结构，树建好了之后，&lt;strong&gt;不管以哪一个点为整体的树根结果都是一样的&lt;/strong&gt;。所以我们随便找一个节点作为整棵树的根节点进行递归即可。强调一下，这个是一个很重要的性质，因为本质上来说，树是一个无向无环全连通图。所以不管以哪个节点为根节点都可以连通整棵子树。&lt;/p&gt;
&lt;p&gt;我们创建一个类来存储节点的信息，包括id和两个最长以及次长的长度。我们来看下代码，应该比你们想的要简单得多。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Node(object):
    def __init__(self, id):
        self.id = id
        # 以当前节点为根节点的子树到叶子节点的最长链路
        self.max1 = 0
        # 到叶子节点的次长链路
        self.max2 = 0
        # 与当前节点相连的边
        self.edges = []

    # 添加新边
    def add_edge(self, v, l):
        self.edges.append((v, l))


# 创建数组，存储所有的节点
nodes = [Node(id) for id in range(12)]

edges = [(0, 1, 3), (0, 2, 1), (1, 3, 1), (1, 4, 4), (1, 5, 2), (5, 6, 5), (5, 7, 6), (2, 8, 7), (7, 9, 2), (7, 10, 8)]

# 创建边
for edge in edges:
    u, v, l = edge
    nodes[u].add_edge(v, l)
    nodes[v].add_edge(u, l)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们只是为了传达思路，所以省去了许多面向对象的代码，但是对于我们理解题目思路来说应该是够了。&lt;/p&gt;
&lt;p&gt;下面，我们来看树上做动态规划的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def dfs(u, f, ans):
    nodeu = nodes[u]
    # 遍历节点u所有的边
    for edge in nodes[u].edges:
        v, l = edge
        # 注意，这其中包括了父节点的边
        # 所以我们要判断v是不是父节点的id
        if v == f:
            continue
        # 递归，更新答案
        ans = max(ans, dfs(v, u, ans))
        nodev = nodes[v]
        # 转移最大值和次大值
        if nodev.max1 + l &amp;gt; nodeu.max1:
            nodeu.max1 = nodev.max1 + l
        elif nodev.max1 + l &amp;gt; nodeu.max2:
            nodeu.max2 = nodev.max1 + l
    # 返回当前最优解
    return max(ans, nodeu.max1 + nodeu.max2)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来很复杂的树形DP，其实代码也就只有十来行，是不是简单得有些出人意料呢？&lt;/p&gt;
&lt;p&gt;但是还是老生常谈的话题，这十几行代码看起来简单，但是其中的细节还是有一些的，尤其是涉及到了递归操作。对于递归不是特别熟悉的同学可能会有些吃力，建议可以根据之前的图手动在纸上验算一下，相信会有更深刻的认识。&lt;/p&gt;
&lt;h2 id=&quot;另一种做法&quot;&gt;另一种做法&lt;/h2&gt;
&lt;p&gt;文章还没完，我们还有一个小彩蛋。其实这道题还有另外一种做法，这种做法&lt;strong&gt;非常机智&lt;/strong&gt;，也一样介绍给大家。&lt;/p&gt;
&lt;p&gt;之前我们说了，由于树记录的是节点的连通状态，所以不管以哪个节点为根节点，都不会影响整棵树当中路径的长度以及结构。既然如此，如果我们富有想象力的话，我们把一棵树压扁，是不是可以看成是一串连在一起的绳子或者木棍？&lt;/p&gt;
&lt;p&gt;我们来看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201106222657.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们&lt;strong&gt;把C点向B点靠近&lt;/strong&gt;，并不会影响树的结构，毕竟这是一个抽象出来的架构，我们并不关注树上树枝之间的夹角。我们可以想象成我们&lt;strong&gt;拎起了A点&lt;/strong&gt;，其他的几点由于重力的作用下垂，最后就会被拉成一条直线。&lt;/p&gt;
&lt;p&gt;比如上图当中，我们拎起了A点，BCD都垂下。这个时候位于最下方的点是D点。那么我们再拎起D点，最下方的点就成了C点，那么DC之间的距离就是树上的最长链路：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201106222702.webp&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们把整个过程梳理一下，首先我们随便选了一个点作为树根，然后找出了距离它最远的点。第二次，我们选择这个最远的点作为树根，再次找到最远的点。这两个最远点之间的距离就是答案。&lt;/p&gt;
&lt;p&gt;这种做法非常直观，但是我也想不到可以严谨证明的方法，有思路的小伙伴可以在后台给我留言。如果有些想不通的小伙伴可以自己试着用几根绳子连在一起，然后拎起来做个实验。看看这样拎两次得到的两个点，是不是树上距离最远的两个点。&lt;/p&gt;
&lt;p&gt;最后，我们来看下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def dfs(u, f, dis, max_dis, nd):
    nodeu = nodes[u]
    for edge in nodes[u].edges:
        v, l = edge
        if v == f:
            continue
        nodev = nodes[v]
        # 更新最大距离，以及最大距离的点
        if dis + l &amp;gt; max_dis:
            max_dis, nd = dis+l, nodev
        # 递归
        _max, _nd = dfs(v, u, dis+l, max_dis, nd)
        # 如果递归得到的距离更大，则更新
        if _max &amp;gt; max_dis:
            max_dis, nd = _max, _nd
    # 返回
    return max_dis, nd

# 第一次递归，获取距离最大的节点
_, nd = dfs(0, -1, 0, 0, None)
# 第二次递归，获取最大距离
dis, _ = dfs(nd.id, -1, 0, 0, None)
print(dis)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，这道有趣的题目就算是讲解完了，不知道文中的两种做法大家都学会了吗？第一次看可能会觉得有些蒙，问题很多这是正常的，但&lt;strong&gt;核心的原理并不难&lt;/strong&gt;，画出图来好好演算一下，一定可以得到正确的结果。&lt;/p&gt;
</description>
<pubDate>Fri, 06 Nov 2020 14:29:00 +0000</pubDate>
<dc:creator>RioTian</dc:creator>
<og:description>本文由TechFlow原创，本博文仅作为知识点学习，不会用于任何商业用途！ 今天我们来看一个有趣的问题，通过这个有趣的问题，我们来了解一下在树形结构当中做动态规划的方法。 这个问题题意很简单，给定一棵</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RioTian/p/13939316.html</dc:identifier>
</item>
<item>
<title>MySQL全面瓦解6：查询的基本操作 - 翁智华</title>
<link>http://www.cnblogs.com/wzh2010/p/13843015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wzh2010/p/13843015.html</guid>
<description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;提到查询，就回到我们第四篇的SQL语言分类了，DQL(Data QueryLanguage)，也就是数据查询语言，实际就是从数据库中获取数据的一种命令方式。我们给数据库发送一个查询语句的命令，数据库按需返回相应的数据。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; column_name1,column_name2,... &lt;span&gt;from&lt;/span&gt; tname;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SQL 中不区分大小写，select语句中不区分大小写，SELECT和select、FROM和from效果一样。&lt;/p&gt;
&lt;p&gt;查询的结果放在一个表格中，表格的第1行称为列头，第2行开始是数据，类属于一个二维数组。&lt;/p&gt;
&lt;h4&gt;查询单个字段&lt;/h4&gt;
&lt;p&gt;配置字段名称，格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;column_name1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;tname&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt;&lt;span&gt; use test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Database changed
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; name &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user3;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; +-------+
&lt;span&gt; 6&lt;/span&gt; | name  |
&lt;span&gt; 7&lt;/span&gt; +-------+
&lt;span&gt; 8&lt;/span&gt; | brand |
&lt;span&gt; 9&lt;/span&gt; | sol     |
&lt;span&gt;10&lt;/span&gt; +-------+
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;查询多个字段&lt;/h4&gt;
&lt;p&gt;多个字段使用逗号隔开，语法格式如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;column_name1,column_name2&lt;/span&gt;,... &lt;span&gt;from&lt;/span&gt; &lt;span&gt;tname&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt;&lt;span&gt; use test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Database changed
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; id,age,name &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user3;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; +----+-----+-------+
&lt;span&gt; 6&lt;/span&gt; | id | age | name  |
&lt;span&gt; 7&lt;/span&gt; +----+-----+-------+
&lt;span&gt; 8&lt;/span&gt; |  &lt;span&gt;1&lt;/span&gt; |  &lt;span&gt;20&lt;/span&gt; | brand |
&lt;span&gt; 9&lt;/span&gt; |  &lt;span&gt;2&lt;/span&gt; |  &lt;span&gt;22&lt;/span&gt; | sol   |
&lt;span&gt;10&lt;/span&gt; +----+-----+-------+
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;查询所有字段&lt;/h4&gt;
&lt;p&gt;使用*号通配符来表示，语法格式如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tname;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt;&lt;span&gt; use test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Database changed
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user3;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; +----+-----+-------+
&lt;span&gt; 6&lt;/span&gt; | id | age | name  |
&lt;span&gt; 7&lt;/span&gt; +----+-----+-------+
&lt;span&gt; 8&lt;/span&gt; |  &lt;span&gt;1&lt;/span&gt; |  &lt;span&gt;20&lt;/span&gt; | brand |
&lt;span&gt; 9&lt;/span&gt; |  &lt;span&gt;2&lt;/span&gt; |  &lt;span&gt;22&lt;/span&gt; | sol   |
&lt;span&gt;10&lt;/span&gt; +----+-----+-------+
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;span&gt;常量的查询&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;对于常量值的查询，可以不来源于表，格式如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; const1,const2,const3;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;brand&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; +-----+-------+-----+
&lt;span&gt;3&lt;/span&gt; | &lt;span&gt;100&lt;/span&gt; | brand | &lt;span&gt;1.5&lt;/span&gt; |
&lt;span&gt;4&lt;/span&gt; +-----+-------+-----+
&lt;span&gt;5&lt;/span&gt; | &lt;span&gt;100&lt;/span&gt; | brand | &lt;span&gt;1.5&lt;/span&gt; |
&lt;span&gt;6&lt;/span&gt; +-----+-------+-----+
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;span&gt;表达式的查询&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;sql的加减乘除等等表达式的查询，格式如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; expression1,expression2,...；
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;*&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;17&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;17&lt;/span&gt;%&lt;span&gt;2&lt;/span&gt;,(&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;3&lt;/span&gt;)*&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;&amp;gt;&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;=&lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; +-----+-----+-----+------+------+---------+-----+-----+
&lt;span&gt;3&lt;/span&gt; | &lt;span&gt;1&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt; | &lt;span&gt;1&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt; | &lt;span&gt;1&lt;/span&gt;*&lt;span&gt;7&lt;/span&gt; | &lt;span&gt;17&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt; | &lt;span&gt;17&lt;/span&gt;%&lt;span&gt;2&lt;/span&gt; | (&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;3&lt;/span&gt;)*&lt;span&gt;5&lt;/span&gt; | &lt;span&gt;8&lt;/span&gt;&amp;gt;&lt;span&gt;5&lt;/span&gt; | &lt;span&gt;7&lt;/span&gt;=&lt;span&gt;4&lt;/span&gt; |
&lt;span&gt;4&lt;/span&gt; +-----+-----+-----+------+------+---------+-----+-----+
&lt;span&gt;5&lt;/span&gt; |   &lt;span&gt;3&lt;/span&gt; |  -&lt;span&gt;1&lt;/span&gt; |   &lt;span&gt;7&lt;/span&gt; | &lt;span&gt;8.5&lt;/span&gt;  |    &lt;span&gt;1&lt;/span&gt; |      &lt;span&gt;25&lt;/span&gt; |   &lt;span&gt;1&lt;/span&gt; |   &lt;span&gt;0&lt;/span&gt; |
&lt;span&gt;6&lt;/span&gt; +-----+-----+-----+------+------+---------+-----+-----+
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;函数的查询&lt;/h4&gt;
&lt;p&gt;可以在查询中加上各种类型的系统函数或者用户自定义函数，来简化一些较复杂的查询过程。格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; func1,func2,func3,...;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; abs(-&lt;span&gt;6&lt;/span&gt;),round(&lt;span&gt;5.7&lt;/span&gt;),length(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;brand&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),now();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; +---------+------------+-----------------+---------------------+
&lt;span&gt;3&lt;/span&gt; | abs(-&lt;span&gt;6&lt;/span&gt;) | round(&lt;span&gt;5.7&lt;/span&gt;) | length(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;brand&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) | now()               |
&lt;span&gt;4&lt;/span&gt; +---------+------------+-----------------+---------------------+
&lt;span&gt;5&lt;/span&gt; |       &lt;span&gt;6&lt;/span&gt; | &lt;span&gt;6&lt;/span&gt;          |               &lt;span&gt;5&lt;/span&gt; | &lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;11&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;07&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt; |
&lt;span&gt;6&lt;/span&gt; +---------+------------+-----------------+---------------------+
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;表和字段的查询&lt;/h4&gt;
&lt;p&gt;查询列名都会以列的定义名称显示，这样显示的时候查看不方便，还容易暴露数据库的信息给业务，为了增强脚本可阅读性，我们经常使用字段别名。&lt;/p&gt;
&lt;p&gt;设置表的别名更主要的还是在于书写查询语句时候的便利，并避免多表查询时的字段混淆。格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; talias.column_name1 col1,talias.column_name2 col2 &lt;span&gt;from&lt;/span&gt;  tname [&lt;span&gt;as&lt;/span&gt;] talias;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt;&lt;span&gt; use test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Database changed
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; u.id &lt;span&gt;as&lt;/span&gt; 主键,u.age &lt;span&gt;as&lt;/span&gt; 年龄,u.name &lt;span&gt;as&lt;/span&gt; 名称 &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user3 u;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; +------+------+-------+
&lt;span&gt; 6&lt;/span&gt; | 主键 | 年龄 | 名称  |
&lt;span&gt; 7&lt;/span&gt; +------+------+-------+
&lt;span&gt; 8&lt;/span&gt; |    &lt;span&gt;1&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | brand |
&lt;span&gt; 9&lt;/span&gt; |    &lt;span&gt;2&lt;/span&gt; |   &lt;span&gt;22&lt;/span&gt; | sol   |
&lt;span&gt;10&lt;/span&gt; +------+------+-------+
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;混合查询&lt;/h4&gt;
&lt;p&gt;查询具体表的字段是可以跟表达式，常量等混合在一起的，这样才能应付复杂的业务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;中国2020人口普查&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; 标题,u.id &lt;span&gt;as&lt;/span&gt; 主键,u.age &lt;span&gt;as&lt;/span&gt; 年龄,u.name &lt;span&gt;as&lt;/span&gt; 名称,now() &lt;span&gt;as&lt;/span&gt; 查询时间,&lt;span&gt;2020&lt;/span&gt;*rand() &lt;span&gt;as&lt;/span&gt; 随机数 &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user3 u;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; +------------------+------+------+-------+---------------------+--------------------+
&lt;span&gt;3&lt;/span&gt; | 标题             | 主键 | 年龄 | 名称  | 查询时间            | 随机数             |
&lt;span&gt;4&lt;/span&gt; +------------------+------+------+-------+---------------------+--------------------+
&lt;span&gt;5&lt;/span&gt; | 中国2020人口普查 |    &lt;span&gt;1&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | brand | &lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;11&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;39&lt;/span&gt; | &lt;span&gt;1236.3585094328582&lt;/span&gt; |
&lt;span&gt;6&lt;/span&gt; | 中国2020人口普查 |    &lt;span&gt;2&lt;/span&gt; |   &lt;span&gt;22&lt;/span&gt; | sol   | &lt;span&gt;2020&lt;/span&gt;-&lt;span&gt;11&lt;/span&gt;-&lt;span&gt;06&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;23&lt;/span&gt;:&lt;span&gt;39&lt;/span&gt; | &lt;span&gt;344.21752367561453&lt;/span&gt; |
&lt;span&gt;7&lt;/span&gt; +------------------+------+------+-------+---------------------+--------------------+
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1、本片只是查询的基础篇，后续会引出 查询的过滤条件、排序、分页、分组、正则匹配过滤，以及复杂查询的性能优化等等。&lt;/p&gt;
&lt;p&gt;2、查询数据的时候，应遵循应需而查，查询需要的字段即可，切勿随意的使用*，数据量大的时候性能差距就明显了。&lt;/p&gt;
</description>
<pubDate>Fri, 06 Nov 2020 13:32:00 +0000</pubDate>
<dc:creator>翁智华</dc:creator>
<og:description>概述 提到查询，就回到我们第四篇的SQL语言分类了，DQL(Data QueryLanguage)，也就是数据查询语言，实际就是从数据库中获取数据的一种命令方式。我们给数据库发送一个查询语句的命令，数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wzh2010/p/13843015.html</dc:identifier>
</item>
<item>
<title>【应用程序见解 Application Insights】Application  Insights 使用 Application Maps 构建请求链路视图 - 路边两盏灯</title>
<link>http://www.cnblogs.com/lulight/p/13938752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lulight/p/13938752.html</guid>
<description>&lt;h2&gt;Applicaotn  Insigths 使用 Application Maps 构建请求链路视图 &lt;/h2&gt;
&lt;p&gt;构建系统时，请求的逻辑操作大多数情况下都需要在不同的服务，或接口中完成整个请求链路。一个请求可以经历多个组件，极有可能出现客户端请求站点1，站点1请求站点2, … 站点N才是最终处理数据然后依次返回。&lt;/p&gt;
&lt;p&gt;在这样的情况，如果有一个直观的视图来展示请求在每一个站点上的状态（&lt;span&gt;成功&lt;/span&gt;，&lt;span&gt;失败&lt;/span&gt;），当问题发生时，非常有帮助定位问题发生的地点。借助Azure 应用程序见解(Application Insights)中的遥测关联建立的Application Maps就能实现&lt;/p&gt;
&lt;h4&gt;效果展示&lt;/h4&gt;
&lt;h4&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2127802/202011/2127802-20201106200434687-1148220517.gif&quot; width=&quot;980&quot; height=&quot;520&quot; loading=&quot;lazy&quot;/&gt;&lt;/h4&gt;
&lt;h2&gt;实现原理&lt;/h2&gt;
&lt;p&gt;Application Insights定义了用于分配遥测关联的数据模型，每个传出操作（例如，对另一个组件的 HTTP 调用）是由依赖项遥测表示的。 依赖项遥测也定义了自身的全局独一无二的 id，此依赖项调用发起的请求遥测将此 id 用作其 operation_parentId。通过operation_Id、operation_parentId 和 request.id，即可以生成分布式逻辑操作的视图 (这些字段也定义了遥测调用的因果关系顺序)。&lt;/p&gt;
&lt;h2&gt;实例构建Application Maps&lt;/h2&gt;
&lt;p&gt;在实例中，这一个请求进行了4段转发。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一段：&lt;/span&gt;本地代码访问APIM(test01.azure-api.cn),&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二段：&lt;/span&gt;APIM访问站点1(lbphptest.chinacloudsites.cn)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三段：&lt;/span&gt;站点1访问站点2(lbjavatest.chinacloudsites.cn)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四段：&lt;/span&gt;站点2访问最终处理请求的Azure Function(Http Trigger)( functionapp120201013155425.chinacloudsites.cn).&lt;/p&gt;
&lt;h3&gt;准备条件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;创建Application Insights (lbphptest202011050549)&lt;/li&gt;
&lt;li&gt;创建APIM(test01)&lt;/li&gt;
&lt;li&gt;创建两个App Service (lbphptest 和lbjavatest)&lt;/li&gt;
&lt;li&gt;创建一个Azure Function(functionapp120201013155425)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;注&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;：如不熟悉如何创建以上资源，可以导航到文末的参考资料部分&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;步骤一：在Azure Funciton中启用并关联Application Insights服务&lt;/h3&gt;
&lt;p&gt;进入Azure Funciton门户，选择Application Insights功能，根据页面提示选择已创建好的Application Insights (lbphptest202011050549).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2127802/202011/2127802-20201106201003618-937390368.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建的Function为默认的HttpTrigger模式，测试目的，代码可以不需任何修改。参考下图获取到Function的URL，用于下一步在站点2中调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2127802/202011/2127802-20201106201030043-2021015499.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;步骤二：在站点2（lbjavatest）中启用并关联Application Insights服务，并部署代码请求Azure Function&lt;/h3&gt;
&lt;p&gt;进入站点2的门户页面，在Application Insights目录中根据提示Enable Application Insights并选择相同的Application Insights。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2127802/202011/2127802-20201106201059063-297096949.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;部署代码调用步骤一中的Azure Function&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Level 3&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[Action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Fun([FromQuery] &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (HttpClient httpClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient())
            {
                &lt;/span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; url = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://functionapp120201013155425.chinacloudsites.cn/api/HttpTrigger1?name={name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;
                HttpRequestMessage httpRequest &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpRequestMessage(HttpMethod.Get, url);
                httpRequest.Headers.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Accept&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json, text/plain, */*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response =&lt;span&gt; httpClient.SendAsync(httpRequest).Result;
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; responseContent =&lt;span&gt; response.Content.ReadAsStringAsync().Result;

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseContent;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;步骤三：在站点1（lbphptest）中启用并关联Application Insights服务，并部署代码请求站点2&lt;/h3&gt;
&lt;p&gt;进入站点1的门户页面，在Application Insights目录中根据提示Enable Application Insights并选择相同的Application Insights。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2127802/202011/2127802-20201106201201407-1050860310.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;部署代码调用步骤二中的站点2的URL，代码与访问Azure Function相似。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Level 2&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[Action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FunSub([FromQuery] &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (HttpClient httpClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient())
            {
                &lt;/span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; url = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://lbjavatest.chinacloudsites.cn/WeatherForecast/fun?name={name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;;&lt;/span&gt;
                HttpRequestMessage httpRequest &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpRequestMessage(HttpMethod.Get, url);
                httpRequest.Headers.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Accept&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json, text/plain, */*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response =&lt;span&gt; httpClient.SendAsync(httpRequest).Result;
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; responseContent =&lt;span&gt; response.Content.ReadAsStringAsync().Result;

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseContent;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;步骤四：在APIM中启用并关联Application Insights服务, 并设置API访问站点1&lt;/h3&gt;
&lt;p&gt;进入APIM的门户页面，在Application Insights目录中添加相同的Application Insights。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2127802/202011/2127802-20201106201246591-2082778842.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在APIM配置API访问站点1（lbphptest）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击“Add API” 按钮&lt;/li&gt;
&lt;li&gt;选择从App Service中创建&lt;/li&gt;
&lt;li&gt;选择站点1(lbphptest)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2127802/202011/2127802-20201106201348186-879286672.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在接口中添加操作一个新操作，访问站点1中的接口&lt;strong&gt;/weatherforecast/funsub?name={name}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2127802/202011/2127802-20201106201418236-918319290.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;步骤五：在ASP.NET Core代码中添加Application Insights SDK并配置连接字符串，在接口中访问APIM.&lt;/h3&gt;
&lt;p&gt;在本地代码中添加Application Insights SDK&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2127802/202011/2127802-20201106201445735-1840394237.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置连接字符串(字符串中Application Insights的Overview页面复制)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Warning&quot;,
      &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;
    }
  },
  &quot;ApplicationInsights&quot;: {
    &lt;span&gt;&quot;ConnectionString&quot;: &quot;InstrumentationKey=xxx-xxx-xxx-xxx-xxxxx;EndpointSuffix=applicationinsights.azure.cn;IngestionEndpoint=https://chinaeast2-0.in.applicationinsights.azure.cn/&quot;&lt;/span&gt;
  },
  &quot;AllowedHosts&quot;: &quot;*&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动本地程序，并通过在浏览器中访问 &lt;em&gt;&lt;span&gt;https://localhost:44323/weatherforecast/Funsubfornt?name=test from local -- apim -- app 1 – app 2 -- function&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看最终效果图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2127802/202011/2127802-20201106201719578-1285522974.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  【END】&lt;/p&gt;

&lt;h3&gt;参考文档：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在 Azure 门户中创建第一个函数&lt;/strong&gt;： &lt;a href=&quot;https://docs.azure.cn/zh-cn/azure-functions/functions-create-first-azure-function&quot; target=&quot;_blank&quot;&gt;https://docs.azure.cn/zh-cn/azure-functions/functions-create-first-azure-function&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用于 ASP.NET Core 应用程序的 Application Insights&lt;/strong&gt; ： &lt;a href=&quot;https://docs.azure.cn/zh-cn/azure-monitor/app/asp-net-core&quot; target=&quot;_blank&quot;&gt;https://docs.azure.cn/zh-cn/azure-monitor/app/asp-net-core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于 API 管理&lt;/strong&gt;： &lt;a href=&quot;https://docs.azure.cn/zh-cn/api-management/api-management-key-concepts&quot; target=&quot;_blank&quot;&gt;https://docs.azure.cn/zh-cn/api-management/api-management-key-concepts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 Azure 中创建 ASP.NET Core Web 应用&lt;/strong&gt;： &lt;a href=&quot;https://docs.azure.cn/zh-cn/app-service/quickstart-dotnetcore?pivots=platform-linux&quot; target=&quot;_blank&quot;&gt;https://docs.azure.cn/zh-cn/app-service/quickstart-dotnetcore?pivots=platform-linux&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 06 Nov 2020 12:23:00 +0000</pubDate>
<dc:creator>路边两盏灯</dc:creator>
<og:description>Applicaotn Insigths 使用 Application Maps 构建请求链路视图 构建系统时，请求的逻辑操作大多数情况下都需要在不同的服务，或接口中完成整个请求链路。一个请求可以经历多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lulight/p/13938752.html</dc:identifier>
</item>
<item>
<title>nacos、ribbon和feign的简明教程 - bbird2018</title>
<link>http://www.cnblogs.com/bbird/p/13938566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bbird/p/13938566.html</guid>
<description>&lt;h2 id=&quot;为什么需要nacos？&quot;&gt;为什么需要nacos？&lt;/h2&gt;
&lt;p&gt;在微服务架构中，微服务之间经常要相互通信和调用，而且一个服务往往存在多个实例来降低负荷或保证高可用。我们假定A服务要调用B服务，最简单的方式把B服务的地址和端口保存在A服务的配置文件中。然后通过http请求去完成B服务的调用。但是B服务可能有好多个实例，而且可能会随着业务的需求随时的扩展或者停用掉一些实例，这个时候B服务的地址和端口可能会经常发生改变。如果记录在配置文件就多有不便。而且在众多的B服务中，可能有一些服务会出现各种问题坏掉，我们可能还需要写一个心跳检测，看看是不是所有的服务都正常运行，及时地剔除掉那些不能用的服务。如果完备稳定的实现这些功能，是一个不小的工作量。还好凡是有困难的地方总有前人造轮子。而Nacos就是来解决这样问题的轮子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/476198/202011/476198-20201106192610272-298522659.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，通过简单的配置和注解，所有的微服务都把自己信息登记到Nacos server中去。在需要调用的时候，通过登记到Nacos server的名字就可以完成微服务间的调用。比如有以前通过访问 &lt;a href=&quot;http://12.3.3.5:8090/service&quot;&gt;http://12.3.3.5:8090/service&lt;/a&gt; 来访问微服务的，变成了http://provider/service 的方式来访问，把服务与端口地址解耦。&lt;/p&gt;
&lt;h2 id=&quot;如何使用nacos&quot;&gt;如何使用Nacos&lt;/h2&gt;
&lt;h3 id=&quot;nacos-server的启动&quot;&gt;Nacos server的启动&lt;/h3&gt;
&lt;p&gt;Nacos使用非常的简单。从Nacos官网下载release包，linux\mac下面执行&lt;code&gt;sh startup.sh -m standalone&lt;/code&gt;,windows下面执行&lt;code&gt;startup.cmd -m standalone&lt;/code&gt; 然后就可以完成Nacosserver的启动。&lt;/p&gt;
&lt;h3 id=&quot;在微服务中使用nacos做服务注册和发现&quot;&gt;在微服务中使用Nacos做服务注册和发现&lt;/h3&gt;
&lt;p&gt;通过maven架包使用Nacos发现服务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-discovery&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.2.3.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在配置文件中简单配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;spring:
    application:
        name: provider  #这个很重要，是注册到Nacos中调用的服务的名称
    cloud:
        nacos:
        discovery:
            server-addr: 127.0.0.1:8848 #配置Nacos的服务地址
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在启动类上增加注解@EnableDiscoveryClient&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@EnableDiscoveryClient 
public class ProviderApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProviderApplication.class, args);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过简单的几步就可以完成了把微服务注册到了Nacos Server。怎么样很简单吧。当然Nacos除了做服务注册和发现外，还可以做配置中心，使用方法大同小异。更多丰富的操作参考官方文档 &lt;a href=&quot;https://nacos.io/zh-cn/docs/what-is-nacos.html&quot;&gt;Nacos官方网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务的调用&quot;&gt;服务的调用&lt;/h2&gt;
&lt;p&gt;如果要通过http://provider/service的方式去调用微服务，还需要构造http请求，请求回来的结果还要做json解析等等一系列繁杂的工作。而Ribbon就用来解决这个问题的。在springcloud.alibaba的nacos发现服务的Maven包中，已经包含了ribbon.我们通过简单的几行代码，就可以完成微服务的调用。&lt;/p&gt;
&lt;p&gt;假定在provider服务中有这么一段代码，我们要调用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//例子来自Nacos官网
    @RequestMapping(value = &quot;/echo/{string}&quot;,method = RequestMethod.GET)
    public String echo(@PathVariable String string)
    {
        return &quot;Hello Nacos Discover&quot; + string;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只需要实例化一个RestTemplate&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean
    public RestTemplate restTemplate()
    {
        return new RestTemplate();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以再想要调用的地方来通过下面的代码来非常简单地调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String result = restTemplate.getForObject(&quot;http://provider/echo/&quot;+str,String.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;负载均衡的问题&quot;&gt;负载均衡的问题&lt;/h2&gt;
&lt;p&gt;前面讲到，在微服务环境中常常同一个服务会有N多实例，我们不希望所有的调用都跑到一个实例上去，这个时候就需要用到负载均衡。我们只需要在启动来加上 @LoadBalanced 注解。在配置文件的spring.application.name相同的应用会被认为是同一个微服务，然后转发可以通过ribbon内置的策略路由到不同的provider中去。&lt;/p&gt;
&lt;p&gt;如果我们期望有的provider的优先级比别的优先级高一些，可以再provider的配置文件中调节不同的权重。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;spring:
  cloud:
    nacos:
      discovery:
        weight: 1 #配置权重
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用feign&quot;&gt;使用Feign&lt;/h2&gt;
&lt;p&gt;通过上面的方法，已经把微服务之间的相互调用变得非常的简单了。但是还不够，Feign可以让调用更加简单。&lt;/p&gt;
&lt;h3 id=&quot;引用maven包&quot;&gt;引用maven包&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.2.5.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们针对要调用的provider定义一个接口，接口的方法为要调用的方法名，参数和调用参数同名。@FeignClient 注解中name为微服务的名称。复杂一些的方法调用可能需要在接口中配合@RequestMapping指定具体的路由规则，然后就可以通过该接口直接调用微服务方法，是不是更加清晰简单呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FeignClient(name = &quot;provider&quot;)
@Service
public interface TestService {
    String echo(String serviceName);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TestController {
    private final RestTemplate restTemplate;
    @Autowired
    private TestService testService;

    @GetMapping(&quot;/echo2/{str}&quot;)
    public String echo2(@PathVariable String str)
    {
        return testService.echo(str);
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 06 Nov 2020 11:27:00 +0000</pubDate>
<dc:creator>bbird2018</dc:creator>
<og:description>nacos简明教程 为什么需要nacos？ 在微服务架构中，微服务之间经常要相互通信和调用，而且一个服务往往存在多个实例来降低负荷或保证高可用。我们假定A服务要调用B服务，最简单的方式把B服务的地址和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bbird/p/13938566.html</dc:identifier>
</item>
<item>
<title>Markdown tricks - GZ^</title>
<link>http://www.cnblogs.com/guangzan/p/13937364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guangzan/p/13937364.html</guid>
<description>&lt;h2 id=&quot;编辑排版&quot;&gt;编辑排版&lt;/h2&gt;
&lt;p&gt;仅仅了解 Markdown 语法还不够，知道这些 &lt;mark&gt;排版技巧&lt;/mark&gt; 增色您的文章内容。&lt;/p&gt;
&lt;h3 id=&quot;空格和空行&quot;&gt;空格和空行&lt;/h3&gt;
&lt;p&gt;留白，从艺术角度上说，留白就是以“空白”为载体进而&lt;u&gt;渲染出美的意境&lt;/u&gt;的艺术。从应用角度上说，留白更多指一种&lt;u&gt;简单、安闲&lt;/u&gt;的理念。在 Markdown 中善于使用空格和空行使文章阅读起来更加自然。&lt;/p&gt;
&lt;p&gt;善用空格即在中英文混排或者中文和阿拉伯数字混排时时，在英文或阿拉伯数字前后各插入一个空格。同样建议在中文和行内代码混排时，在行内代码前后各加一个空格。需要注意的是，若英文、阿拉伯数字或行内代码紧邻中文全角标点，则其与标点之间&lt;s&gt;加空格&lt;/s&gt;(不加空格)。&lt;/p&gt;
&lt;p&gt;善用空行即在段落与段落之间插入一条空行。下面是一段示例。&lt;/p&gt;
&lt;p&gt;John Gruber 在 2004 年创造了 Markdown 语言。很多人认为 &lt;code&gt;Markdown&lt;/code&gt; 能够提升生产力。&lt;a href=&quot;https://www.markdownguide.org/&quot;&gt;Markdown Guide&lt;/a&gt; 是一个免费的开源参考指南，它解释了如何使用 Markdown，这是一种简单易用的标记语言，您可以用它来格式化几乎任何文档。&lt;/p&gt;
&lt;blockquote readability=&quot;5.7560975609756&quot;&gt;
&lt;p&gt;如果您正在使用 vscode 作为 markdown 编辑器，我推荐使用 vscode 扩展 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=halfcrazy.pangu&quot;&gt;pandu&lt;/a&gt; 来自动插入左右空格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;图文混排&quot;&gt;图文混排&lt;/h3&gt;
&lt;p&gt;您可能看见过这样的文章排版，一侧是图片，另一侧是一个段落。&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/745037/1604656599366-5478b70a-ca5d-4d80-82cc-bd4e64591eec.png#align=left&amp;amp;display=inline&amp;amp;height=146&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=146&amp;amp;originWidth=751&amp;amp;size=70454&amp;amp;status=done&amp;amp;style=none&amp;amp;width=751&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;这在 markdown 中实现起来并不困难，使用 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签来贴图，然后指定它的 &lt;code&gt;align&lt;/code&gt; 属性为 &lt;code&gt;left&lt;/code&gt; 或者 &lt;code&gt;right&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;img align=&quot;left&quot; src=&quot;https://vuejs.org/images/logo.png&quot; /&amp;gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Corporis error ipsam voluptatibus eius dolore maxime aperiam eveniet, autem
laborum exercitationem recusandae nostrum, soluta praesentium vel sapiente. Natus, nobis molestiae. Repellat?
&lt;/code&gt;
&lt;/pre&gt;
&lt;img align=&quot;left&quot; src=&quot;https://vuejs.org/images/logo.png&quot;/&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Corporis error ipsam voluptatibus eius dolore maxime aperiam eveniet, autem laborum exercitationem recusandae nostrum, soluta praesentium vel sapiente. Natus, nobis molestiae. Repellat?
&lt;h3 id=&quot;代码块折叠&quot;&gt;代码块折叠&lt;/h3&gt;
&lt;p&gt;在博客园的 TinyMCE 中您可以轻松插入能够折叠的代码块，好在 Markdown 可以使用 HTML 的标签功能。H5 提供了 &lt;code&gt;&amp;lt;details&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;summary&amp;gt;&lt;/code&gt; 标签，使用它们很容易在 Markdown 中实现代码块折叠。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;details&amp;gt;
    &amp;lt;summary&amp;gt;post-signature.js&amp;lt;/summary&amp;gt;

```javascript 
// 构建随笔签名
import { pageName } from '@tools'
import { getBlogname, getCurrentPostUrl } from '@cnblog'
import { postSignatureConfig } from '@config/plugins'

const containerId = 'post-signature'

/**
* 构建容器
*/
const buildContainer = () =&amp;gt; {
    const author = getBlogname()
    const href = getCurrentPostUrl()
    const el = `&amp;lt;div id='${containerId}'&amp;gt;
                    &amp;lt;p&amp;gt;本文作者：${author}&amp;lt;/p&amp;gt;
                    &amp;lt;p&amp;gt;本文链接：${href}&amp;lt;/p&amp;gt;
                &amp;lt;/div&amp;gt;`
    $('#cnblogs_post_body').append(el)
}

/**
* 构建版权信息
* @param {Boolean} enableLicense
* @param {String} licenseName
* @param {String} licenseLink
*/
const buildLicense = (
    enableLicense,
    licenseName,
    licenseLink,
) =&amp;gt; {
    if (!enableLicense) return
    const agreement = licenseName.length
        ? licenseName
        : '知识共享署名-非商业性使用-禁止演绎 2.5 中国大陆'
    const el = `&amp;lt;p&amp;gt;版权声明：本作品采用${agreement}&amp;lt;a href='${licenseLink}'&amp;gt;许可协议&amp;lt;/a&amp;gt;进行许可。&amp;lt;/p&amp;gt;`
    $(`#${containerId}`).append(el)
}

/**
* 构建自定义内容
* @param {Array} content
*/
function buildContent(content) {
    let el = ''
    for (let i = 0; i &amp;lt; content.length; i++) {
        el += '&amp;lt;p&amp;gt;' + content[i] + '&amp;lt;/p&amp;gt;'
    }
    $(`#${containerId}`).append(el)
}

export default devOptions =&amp;gt; {
    const {
        enable,
        enableLicense,
        content,
        licenseName,
        licenseLink,
    } = postSignatureConfig(devOptions)
    if (!enable) return
    if (pageName() !== 'post') return
    buildContainer()
    buildLicense(enableLicense, licenseName, licenseLink)
    buildContent(content)
}
```
&amp;lt;/details&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;details readability=&quot;14&quot;&gt;post-signature.js
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// 构建随笔签名
import { pageName } from '@tools'
import { getBlogname, getCurrentPostUrl } from '@cnblog'
import { postSignatureConfig } from '@config/plugins'
const containerId = 'post-signature'
/**
 * 构建容器
 */
const buildContainer = () =&amp;gt; {
    const author = getBlogname()
    const href = getCurrentPostUrl()
    const el = `&amp;lt;div id='${containerId}'&amp;gt;
                    &amp;lt;p&amp;gt;本文作者：${author}&amp;lt;/p&amp;gt;
                    &amp;lt;p&amp;gt;本文链接：${href}&amp;lt;/p&amp;gt;
                &amp;lt;/div&amp;gt;`
    $('#cnblogs_post_body').append(el)
}
/**
 * 构建版权信息
 * @param {Boolean} enableLicense
 * @param {String} licenseName
 * @param {String} licenseLink
 */
const buildLicense = (enableLicense, licenseName, licenseLink) =&amp;gt; {
    if (!enableLicense) return
    const agreement = licenseName.length ? licenseName : '知识共享署名-非商业性使用-禁止演绎 2.5 中国大陆'
    const el = `&amp;lt;p&amp;gt;版权声明：本作品采用${agreement}&amp;lt;a href='${licenseLink}'&amp;gt;许可协议&amp;lt;/a&amp;gt;进行许可。&amp;lt;/p&amp;gt;`
    $(`#${containerId}`).append(el)
}
/**
 * 构建自定义内容
 * @param {Array} content
 */
function buildContent(content) {
    let el = ''
    for (let i = 0; i &amp;lt; content.length; i++) {
        el += '&amp;lt;p&amp;gt;' + content[i] + '&amp;lt;/p&amp;gt;'
    }
    $(`#${containerId}`).append(el)
}
export default devOptions =&amp;gt; {
    const { enable, enableLicense, content, licenseName, licenseLink } = postSignatureConfig(devOptions)
    if (!enable) return
    if (pageName() !== 'post') return
    buildContainer()
    buildLicense(enableLicense, licenseName, licenseLink)
    buildContent(content)
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/details&gt;&lt;p&gt;您甚至可以折叠任何内容，只需要将 &lt;code&gt;&amp;lt;summary&amp;gt;&lt;/code&gt;  标签之间的内容替换为其他要折叠的内容。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;请注意，在 &lt;code&gt;&amp;lt;summary&amp;gt;&lt;/code&gt;  标签之间的内容上下各保留一条空行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;引用块&quot;&gt;引用块&lt;/h3&gt;
&lt;p&gt;在 Markdown 中一般通过 &lt;code&gt;&amp;gt;&lt;/code&gt;  来声明一个 Markdown 引用块：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这是一个引用块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但它们的样式都是固定的，我们常常需要一些带有提示信息的引用块，像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/745037/1604657982597-f2a41d59-fbaa-4619-afac-f4b02de675fc.png#align=left&amp;amp;display=inline&amp;amp;height=548&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=548&amp;amp;originWidth=834&amp;amp;size=28692&amp;amp;status=done&amp;amp;style=none&amp;amp;width=834&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Markdown 中借助 HTML 和 CSS 也能实现这一点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div style=&quot;background-color: var(--md-blockquote-bg); padding: 8px; border-left: 6px solid rgba(251, 114, 153, 1); border-top-color: rgba(251, 114, 153, 1); border-right-color: rgba(251, 114, 153, 1); border-bottom-color: rgba(251, 114, 153, 1); box-sizing: border-box; overflow: hidden; margin-bottom: 10px&quot;&amp;gt;
        《战争与和平》一八一二年，俄、法两国再度交战，安德烈·保尔康斯基在战役中身受重伤，而俄军节节败退，眼见莫斯科将陷于敌人之手了。罗斯托夫将原本用来搬运家产的马车，改去运送伤兵，娜达莎方能于伤兵中发现将要死去的安德烈·保尔康斯基。她向他谢罪并热诚看护他，但一切都是徒劳了，安德烈·保尔康斯基仍然逃不过死亡之神而去世了。
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background-color: var(--md-blockquote-bg); padding: 8px; border-left: 6px solid rgba(66, 185, 131, 1); border-top-color: rgba(66, 185, 131, 1); border-right-color: rgba(66, 185, 131, 1); border-bottom-color: rgba(66, 185, 131, 1); box-sizing: border-box; overflow: hidden; margin-bottom: 10px&quot;&amp;gt;
        《巴黎圣母院
        》丑聋人卡西莫多被巴黎圣母院的神父克罗德收养，做撞钟人，外表正经的克罗德神父自从遇见美丽的吉普赛少女拉·爱斯梅拉达后，被其美色所诱而神魂颠倒，指使卡西莫多强行掳走爱斯梅拉达，途中被福比斯骑兵上尉队长所救，爱斯梅拉达因而爱上了福比斯。
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background-color: var(--md-blockquote-bg); padding: 8px; border-left: 6px solid rgba(22, 135, 250, 1); border-top-color: rgba(22, 135, 250, 1); border-right-color: rgba(22, 135, 250, 1); border-bottom-color: rgba(22, 135, 250, 1); box-sizing: border-box; overflow: hidden; margin-bottom: 10px&quot;&amp;gt;
        《童年》讲了小主人公高尔基（阿廖沙）在父亲去世后，随母亲寄住在外祖父家中度过的岁月。其间，他得到外祖母的疼爱、呵护，受到外祖母所讲述的优美童话的熏陶，同时也亲眼目睹两个舅舅为争夺家产而争吵打架以及在生活琐事中表现出来的自私、贪婪。高尔基（阿廖沙）就是在这种“令人窒息的、充满可怕景象的狭小天地里”度过了自己的童年。
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background-color: var(--md-blockquote-bg); padding: 8px; border-left: 6px solid rgba(255, 182, 193, 1); border-top-color: rgba(255, 182, 193, 1); border-right-color: rgba(255, 182, 193, 1); border-bottom-color: rgba(255, 182, 193, 1); box-sizing: border-box; overflow: hidden; margin-bottom: 10px&quot;&amp;gt;
        《呼啸山庄》一个爱到极致的男人，做出了疯狂的行为。他用“爱”杀人，却也用爱自杀。凯瑟琳生前死后，他都活在痛苦里。凯瑟琳弥留之际，他还用说话去刺伤她。但是，希斯克力夫承受的却是两份伤痛，他自己的和凯瑟琳的。
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;padding: 8px 16px; background-color: var(--md-blockquote-bg); border-radius: 4px; border-left: 5px solid rgba(80, 191, 255, 1); margin: 20px 0&quot;
 &quot;=&quot;&quot;&amp;gt;
《红与黑》是19世纪法国乃至欧洲文学的一座丰碑。小说围绕主人公于连的个人奋斗及两次爱情经历的描写，揭示了复辟王朝时期的波澜的阶级大博斗，反映了政治黑暗、教会腐败，贵族反动和资产阶级利欲熏心的广阔生活画面。于连的两次爱情动机都是以爱情占有为出发点最终要达到自己的政治目的。
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background-color: rgba(255, 99, 71, 0.1); padding: 8px; border-left: 3px solid rgba(255, 20, 147, 1); border-top-color: rgba(255, 20, 147, 1); border-right-color: rgba(255, 20, 147, 1); border-bottom-color: rgba(255, 20, 147, 1); box-sizing: border-box; overflow: hidden; margin-bottom: 10px&quot;&amp;gt;
        《安娜·卡列尼娜》是俄国著名作家列夫·托尔斯泰的代表作品。本书通过女主人公安娜的追求爱情悲剧，和列文在农村面临危机而进行的改革与探索这两条线索，描绘了俄国从莫斯科到外省乡村广阔而丰富多彩的图景，先后描写了150多个人物，是一部社会百科全书式的作品。
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;background-color: var(--md-blockquote-bg); padding: 8px; border-left: 3px solid rgba(0, 0, 0, 1); border-top-color: rgba(0, 0, 0, 1); border-right-color: rgba(0, 0, 0, 1); border-bottom-color: rgba(0, 0, 0, 1); box-sizing: border-box; overflow: hidden; margin-bottom: 10px&quot;&amp;gt;
        《飘》所讲述的是一个以美国南北战争为背景的爱情故事。小说的主人公思嘉·奥哈拉是美国佐治亚州一位富足且颇有地位的种植园主的女儿。父亲杰拉尔德是爱尔兰的移民。刚到佐治亚州时，杰拉尔德身无分文，靠赌博赢得了塔罗庄园的所有权。于是就开始在这块红色的土地上创业，编织着他的美国之梦。
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;border-radius: 15px; background-color: rgba(251, 114, 153, 0.2); padding: 8px; border: 1px solid rgba(251, 114, 153, 1); box-sizing: border-box; overflow: hidden; margin-bottom: 10px&quot;&amp;gt;
        《约翰·克利斯朵夫》（Jean-Christophe）是一部通过主人公一生经历去反映现实社会一系列矛盾冲突，宣扬人道主义和英雄主义的长篇小说。小说描写了主人公奋斗的一生，从儿时音乐才能的觉醒、到青年时代对权贵的蔑视和反抗、再到成年后在事业上的追求和成功、最后达到精神宁静的崇高境界
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;border-radius: 15px; background-color: rgba(0, 128, 128, 0.1); padding: 8px; border: 1px solid rgba(0, 250, 154, 1); box-sizing: border-box; overflow: hidden; margin-bottom: 10px&quot;&amp;gt;
        《安娜·卡列尼娜》是俄国著名作家列夫·托尔斯泰的代表作品。本书通过女主人公安娜的追求爱情悲剧，和列文在农村面临危机而进行的改革与探索这两条线索，描绘了俄国从莫斯科到外省乡村广阔而丰富多彩的图景，先后描写了150多个人物，是一部社会百科全书式的作品。
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;border-radius: 15px; background-color: rgba(30, 144, 255, 0.1); padding: 8px; border: 1px solid rgba(135, 206, 250, 1); box-sizing: border-box; overflow: hidden; margin-bottom: 10px&quot;&amp;gt;
        高尔基原名阿列克塞·马克西莫维奇·彼什科夫，于1868年3月28日出生在伏尔加河畔的尼日尼·诺夫戈罗德(即今高尔基城)，父亲是细木工。他4岁丧父，随母亲寄居外祖父家，10岁时外祖父因遭火灾而破产，他便被抛到“人间”，开始了自谋生路的流浪生涯。16岁到喀山，原想上大学，结果喀山的贫民窟和码头成了他的“社会大学”。在那里，他接触了进步青年的革命团体。
&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;《战争与和平》一八一二年，俄、法两国再度交战，安德烈·保尔康斯基在战役中身受重伤，而俄军节节败退，眼见莫斯科将陷于敌人之手了。罗斯托夫将原本用来搬运家产的马车，改去运送伤兵，娜达莎方能于伤兵中发现将要死去的安德烈·保尔康斯基。她向他谢罪并热诚看护他，但一切都是徒劳了，安德烈·保尔康斯基仍然逃不过死亡之神而去世了。&lt;/p&gt;
&lt;p&gt;《巴黎圣母院 》丑聋人卡西莫多被巴黎圣母院的神父克罗德收养，做撞钟人，外表正经的克罗德神父自从遇见美丽的吉普赛少女拉·爱斯梅拉达后，被其美色所诱而神魂颠倒，指使卡西莫多强行掳走爱斯梅拉达，途中被福比斯骑兵上尉队长所救，爱斯梅拉达因而爱上了福比斯。&lt;/p&gt;
&lt;p&gt;《童年》讲了小主人公高尔基（阿廖沙）在父亲去世后，随母亲寄住在外祖父家中度过的岁月。其间，他得到外祖母的疼爱、呵护，受到外祖母所讲述的优美童话的熏陶，同时也亲眼目睹两个舅舅为争夺家产而争吵打架以及在生活琐事中表现出来的自私、贪婪。高尔基（阿廖沙）就是在这种“令人窒息的、充满可怕景象的狭小天地里”度过了自己的童年。&lt;/p&gt;
&lt;p&gt;《呼啸山庄》一个爱到极致的男人，做出了疯狂的行为。他用“爱”杀人，却也用爱自杀。凯瑟琳生前死后，他都活在痛苦里。凯瑟琳弥留之际，他还用说话去刺伤她。但是，希斯克力夫承受的却是两份伤痛，他自己的和凯瑟琳的。&lt;/p&gt;
&lt;p&gt;《红与黑》是19世纪法国乃至欧洲文学的一座丰碑。小说围绕主人公于连的个人奋斗及两次爱情经历的描写，揭示了复辟王朝时期的波澜的阶级大博斗，反映了政治黑暗、教会腐败，贵族反动和资产阶级利欲熏心的广阔生活画面。于连的两次爱情动机都是以爱情占有为出发点最终要达到自己的政治目的。&lt;/p&gt;
&lt;p&gt;《安娜·卡列尼娜》是俄国著名作家列夫·托尔斯泰的代表作品。本书通过女主人公安娜的追求爱情悲剧，和列文在农村面临危机而进行的改革与探索这两条线索，描绘了俄国从莫斯科到外省乡村广阔而丰富多彩的图景，先后描写了150多个人物，是一部社会百科全书式的作品。&lt;/p&gt;
&lt;p&gt;《飘》所讲述的是一个以美国南北战争为背景的爱情故事。小说的主人公思嘉·奥哈拉是美国佐治亚州一位富足且颇有地位的种植园主的女儿。父亲杰拉尔德是爱尔兰的移民。刚到佐治亚州时，杰拉尔德身无分文，靠赌博赢得了塔罗庄园的所有权。于是就开始在这块红色的土地上创业，编织着他的美国之梦。&lt;/p&gt;
&lt;p&gt;《约翰·克利斯朵夫》（Jean-Christophe）是一部通过主人公一生经历去反映现实社会一系列矛盾冲突，宣扬人道主义和英雄主义的长篇小说。小说描写了主人公奋斗的一生，从儿时音乐才能的觉醒、到青年时代对权贵的蔑视和反抗、再到成年后在事业上的追求和成功、最后达到精神宁静的崇高境界&lt;/p&gt;
&lt;p&gt;《安娜·卡列尼娜》是俄国著名作家列夫·托尔斯泰的代表作品。本书通过女主人公安娜的追求爱情悲剧，和列文在农村面临危机而进行的改革与探索这两条线索，描绘了俄国从莫斯科到外省乡村广阔而丰富多彩的图景，先后描写了150多个人物，是一部社会百科全书式的作品。&lt;/p&gt;
&lt;p&gt;高尔基原名阿列克塞·马克西莫维奇·彼什科夫，于1868年3月28日出生在伏尔加河畔的尼日尼·诺夫戈罗德(即今高尔基城)，父亲是细木工。他4岁丧父，随母亲寄居外祖父家，10岁时外祖父因遭火灾而破产，他便被抛到“人间”，开始了自谋生路的流浪生涯。16岁到喀山，原想上大学，结果喀山的贫民窟和码头成了他的“社会大学”。在那里，他接触了进步青年的革命团体。&lt;/p&gt;
&lt;h2 id=&quot;工具&quot;&gt;工具&lt;/h2&gt;
&lt;p&gt;我选择语雀作为主力工具。&lt;/p&gt;
&lt;h3 id=&quot;插入图片&quot;&gt;插入图片&lt;/h3&gt;
&lt;p&gt;使用语雀插入图片非常简单，&lt;kbd&gt;Crtl&lt;/kbd&gt;+ &lt;kbd&gt;c&lt;/kbd&gt; 复制图片，&lt;kbd&gt;Crtl&lt;/kbd&gt; + &lt;kbd&gt;v&lt;/kbd&gt; 直接将图片粘贴到内容，就会自动帮您上传到语雀的服务器。或者您也可以使用工具栏的插图图片按钮，选择本地图片插入。我通常使用 windows 自带的截图工具（快捷键：&lt;kbd&gt;win&lt;/kbd&gt;+ &lt;kbd&gt;shift&lt;/kbd&gt;+&lt;kbd&gt;s&lt;/kbd&gt;）截图并粘贴，因为该截图工具会自动帮您把图片复制到剪切板。在 mac 下也有相似的解决方案。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/gif/745037/1604651748114-d2f66e6d-f3c1-47e2-bf20-505d967564ff.gif#align=left&amp;amp;display=inline&amp;amp;height=282&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=Video_2020-11-06_163206.gif&amp;amp;originHeight=282&amp;amp;originWidth=640&amp;amp;size=1753415&amp;amp;status=done&amp;amp;style=none&amp;amp;width=640&quot; alt=&quot;Video_2020-11-06_163206.gif&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;插入表格&quot;&gt;插入表格&lt;/h3&gt;
&lt;p&gt;在 markdown 中插入表格是十分繁琐的，但在语雀中十分容易：点击插入按钮，滑动鼠标选择需要的表格拥有的行数和列数，即可自动帮您生成。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/gif/745037/1604652194203-4bfaafde-0739-45f4-89ea-2f4e01e59fc3.gif#align=left&amp;amp;display=inline&amp;amp;height=480&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=Video_2020-11-06_163953.gif&amp;amp;originHeight=480&amp;amp;originWidth=509&amp;amp;size=2001308&amp;amp;status=done&amp;amp;style=none&amp;amp;width=509&quot; alt=&quot;Video_2020-11-06_163953.gif&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;您还可以在编辑表格的过程中随时增删列和行以及设置表格内容的对齐方式等。&lt;/p&gt;
&lt;h3 id=&quot;插入公式&quot;&gt;插入公式&lt;/h3&gt;
&lt;p&gt;数学公式对于一些人群是刚需，语雀支持插入 LaTeX 公式。重要的一点是，您的文章要发布的平台可能不支持渲染 markdown 数学公式。语雀支持在导出 markdown 时勾选导出 LaTeX 公式为图片。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2020/png/745037/1604652657472-6825c238-c2c1-4220-a278-fe617ecdc81d.png#align=left&amp;amp;display=inline&amp;amp;height=364&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=364&amp;amp;originWidth=639&amp;amp;size=19428&amp;amp;status=done&amp;amp;style=none&amp;amp;width=639&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;制作思维导图&quot;&gt;制作思维导图&lt;/h3&gt;
&lt;p&gt;通常，将张思维导图嵌入 markdown 可能需要以下步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开思维导图制作工具 xmind wps etc.&lt;/li&gt;
&lt;li&gt;开始制作思维导图&lt;/li&gt;
&lt;li&gt;将成图用截图或者导出为图片&lt;/li&gt;
&lt;li&gt;将图片上传到图床获得图片链接&lt;/li&gt;
&lt;li&gt;使用 markdown 语法插入图片&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用语雀只需要：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;直接在 markdown 中制作思维导图&lt;/li&gt;
&lt;li&gt;导出时自动转为图片&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果想插入流程图也是同样轻而易举。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;导出&quot;&gt;导出&lt;/h3&gt;
&lt;p&gt;语雀能够一键导出内容为 Markdown 源代码，无缝衔接到其他社区，我只将内容发布到博客园，目前没发现什么问题。您可以通过我的 &lt;a href=&quot;https://www.yuque.com/login?platform=wechat&amp;amp;inviteToken=d97efa6c62973d671ad88d38b9b4d9c9b62201921c22c6bfc60ec5889295e00d&quot;&gt;邀请链接&lt;/a&gt; 加入语雀或者直接 &lt;a href=&quot;https://www.yuque.com/&quot;&gt;加入&lt;/a&gt;。谢谢阅读！🎉&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://www.markdownguide.org/&quot;&gt;Markdown Guid&lt;/a&gt;&lt;br/&gt;[2] &lt;a href=&quot;https://zhuanlan.zhihu.com/p/69376149&quot;&gt;会用 Markdown 还不够，还得知道排版规范&lt;/a&gt;&lt;br/&gt;[3] &lt;a href=&quot;https://baike.baidu.com/item/%E7%95%99%E7%99%BD/59051&quot;&gt;百度百科-留白&lt;/a&gt;&lt;br/&gt;[4] &lt;a href=&quot;https://baike.baidu.com/item/markdown&quot;&gt;百度百科-Markdown&lt;/a&gt;&lt;br/&gt;[5] &lt;a href=&quot;https://www.makeuseof.com/tag/create-markdown-table/&quot;&gt;How to Create a Markdown Table&lt;/a&gt;&lt;br/&gt;[6] &lt;a href=&quot;https://www.cnblogs.com/bingziweb/p/13828856.html&quot;&gt;Markdown 引用块样式这位小伙伴写的 👍&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Nov 2020 11:19:00 +0000</pubDate>
<dc:creator>GZ^</dc:creator>
<og:description>编辑排版 仅仅了解 Markdown 语法还不够，知道这些 排版技巧 增色您的文章内容。 空格和空行 留白，从艺术角度上说，留白就是以“空白”为载体进而渲染出美的意境的艺术。从应用角度上说，留白更多指</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guangzan/p/13937364.html</dc:identifier>
</item>
<item>
<title>前端未来趋势之原生API：Web Components - ESnail</title>
<link>http://www.cnblogs.com/EnSnail/p/13938504.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EnSnail/p/13938504.html</guid>
<description>&lt;p&gt;&lt;strong&gt;声明：未经允许，不得转载。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Web Components 现世很久了，所以你可能听说过，甚至学习过，非常了解了。但是没关系，可以再重温一下，温故知新。&lt;/p&gt;
&lt;h2 id=&quot;浏览器原生能力越来越强。&quot;&gt;浏览器原生能力越来越强。&lt;/h2&gt;
&lt;h3 id=&quot;js&quot;&gt;js&lt;/h3&gt;
&lt;p&gt;曾经的 &lt;code&gt;JQuery&lt;/code&gt;，是前端入门必学的技能，是前端项目必用的一个库。它的强大之处在于简化了 &lt;code&gt;dom 操作&lt;/code&gt;(强大的选择器) 和 &lt;code&gt;ajax&lt;/code&gt;(异步) 操作。&lt;/p&gt;
&lt;p&gt;现在原生 api &lt;code&gt;querySelector()&lt;/code&gt;、&lt;code&gt;querySelectorAll()&lt;/code&gt;、&lt;code&gt;classList&lt;/code&gt; 等的出现已经大大的弱化了 dom 操作, &lt;code&gt;fetch&lt;/code&gt;、基于 &lt;code&gt;promise&lt;/code&gt; 的 &lt;code&gt;axios&lt;/code&gt; 已经完全替代了 &lt;code&gt;ajax&lt;/code&gt;, 甚至更好用了，&lt;code&gt;async-await&lt;/code&gt; 是真的好用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nefe/You-Dont-Need-jQuery/blob/master/README.zh-CN.md#css--style&quot;&gt;You-Dont-Need-jQuery&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;css&quot;&gt;css&lt;/h3&gt;
&lt;p&gt;css 预处理器(如 &lt;code&gt;scss&lt;/code&gt;、&lt;code&gt;less&lt;/code&gt;) 是项目工程化处理 css 的不二选择。它的强大之处是支持&lt;strong&gt;变量&lt;/strong&gt;、&lt;strong&gt;样式规则嵌套&lt;/strong&gt;、&lt;strong&gt;函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;现在 css 已经支持变量&lt;code&gt;(--var)&lt;/code&gt;了, 样式规则嵌套也在计划之中，函数嘛 &lt;code&gt;calc()&lt;/code&gt; 也非常强大，还支持 &lt;code&gt;attr()&lt;/code&gt; 的使用，还有 &lt;code&gt;css-module&lt;/code&gt; 模块化。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/75team/w3c/blob/master/articles/20180712_anjia_%E4%B8%8D%E7%94%A8%E9%A2%84%E7%BC%96%E8%AF%91%EF%BC%8CCSS%E7%9B%B4%E6%8E%A5%E5%86%99%E5%B5%8C%E5%A5%97%E7%9A%84%E6%97%A5%E5%AD%90%E5%B0%B1%E8%A6%81%E5%88%B0%E4%BA%86.md&quot;&gt;不用预编译，CSS直接写嵌套的日子就要到了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://drafts.csswg.org/css-nesting/&quot;&gt;w3c样式规则嵌套 css-nesting-module&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以前要制作酷炫复杂的 css 样式及动画，必须借助 css 预处理器的变量、函数或者js才行，现在用 (&lt;code&gt;css-doodle&lt;/code&gt;)[&lt;a href=&quot;https://css-doodle.com/&quot;&gt;https://css-doodle.com/&lt;/a&gt;] 技术，实现的更酷、更炫。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codepen.io/yuanchuan/collections/popular/&quot;&gt;css-doodle作品集&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;web-components-组件化&quot;&gt;web components 组件化&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Web Components&lt;/code&gt; 可以创建可复用的组件，未来的某一天抛弃现在所谓的框架和库，直接使用原生 API 或者是使用基于 Web Components 标准的框架和库进行开发，你觉得可能吗？我觉得是可能的。&lt;/p&gt;
&lt;h4 id=&quot;vue-lit&quot;&gt;vue-lit&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yyx990803/vue-lit&quot;&gt;vue-lit&lt;/a&gt;，描述如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Proof of concept mini custom elements framework powered by @vue/reactivity and lit-html.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;描述用到了 custom elements，而且浏览器控制台 elements 的 DOM 结构中也含有 shadow-root。而 custom element 和 shadow DOM 是 web components 的重要组成。具体看下面 demo，&lt;/p&gt;
&lt;p&gt;说明：本文文档示例，都是可以直接复杂到一个 html 文档的 body 中，然后直接在浏览中打开预览效果的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;my-component /&amp;gt;
  
  &amp;lt;script type=&quot;module&quot;&amp;gt;
    import {
      defineComponent,
      reactive,
      html,
      onMounted
    } from 'https://unpkg.com/@vue/lit@0.0.2';

    defineComponent('my-component', () =&amp;gt; {
      const state = reactive({
        text: 'Hello World',
      });
      
      function onClick() {
        alert('cliked!');
      }

      onMounted(() =&amp;gt; {
        console.log('mounted');
      });

      return () =&amp;gt; html`
        &amp;lt;p&amp;gt;
          &amp;lt;button @click=${onClick}&amp;gt;Click me&amp;lt;/button&amp;gt;
          ${state.text}
        &amp;lt;/p&amp;gt;
      `;
    })
  &amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/806524/202011/806524-20201106185830770-38495963.png&quot; width=&quot;500&quot;/&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/yyx990803/vue-lit/blob/master/index.js&quot;&gt;源码解读&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// lit-html 模板，提供 html 模板(简单js表达式及事件绑定)、render 渲染能力
import { render } from 'https://unpkg.com/lit-html?module'
// reactivity 是vue3.0的核心，shallowReactive 浅响应，effect 可以理解为 watch，提供属性响应及部分生命周期处理
import {
  shallowReactive,
  effect
} from 'https://unpkg.com/@vue/reactivity/dist/reactivity.esm-browser.js'

let currentInstance

export function defineComponent(name, propDefs, factory) {
  if (typeof propDefs === 'function') {
    factory = propDefs
    propDefs = []
  }
  
  // 自定义元素 custom element，原生 API
  customElements.define(
    name,
    class extends HTMLElement {
      // 设置需要监听的属性
      static get observedAttributes() {
        return propDefs
      }
      constructor() {
        super()
        // 属性接入 vue 的响应式
        const props = (this._props = shallowReactive({}))

        currentInstance = this
        // lit-html 的 html 生成的模板
        const template = factory.call(this, props)
        currentInstance = null

        // bm onBeforeMount
        this._bm &amp;amp;&amp;amp; this._bm.forEach((cb) =&amp;gt; cb())
        // shadowRoot，closed 表示不可以直接通过 js 获取到定义的 customElement 操作 shadowRoot
        const root = this.attachShadow({ mode: 'closed' })

        let isMounted = false
        effect(() =&amp;gt; {
          if (isMounted) {
            // _bu, onBeforeUpdate
            this._bu &amp;amp;&amp;amp; this._bu.forEach((cb) =&amp;gt; cb())
          }

          // 将 template 内容挂载到 shadowRoot 上
          render(template(), root)

          if (isMounted) {
            // _u，onUpdated
            this._u &amp;amp;&amp;amp; this._u.forEach((cb) =&amp;gt; cb())
          } else {
            isMounted = true
          }
        })
      }
      // 首次挂载到 dom 上后的回调，onMounted
      connectedCallback() {
        this._m &amp;amp;&amp;amp; this._m.forEach((cb) =&amp;gt; cb())
      }
      // 卸载， onUnmounted
      disconnectedCallback() {
        this._um &amp;amp;&amp;amp; this._um.forEach((cb) =&amp;gt; cb())
      }
      // 属性监听
      attributeChangedCallback(name, oldValue, newValue) {
        this._props[name] = newValue
      }
    }
  )
}

function createLifecycleMethod(name) {
  return (cb) =&amp;gt; {
    if (currentInstance) {
      ;(currentInstance[name] || (currentInstance[name] = [])).push(cb)
    }
  }
}

export const onBeforeMount = createLifecycleMethod('_bm')
export const onMounted = createLifecycleMethod('_m')
export const onBeforeUpdate = createLifecycleMethod('_bu')
export const onUpdated = createLifecycleMethod('_u')
export const onUnmounted = createLifecycleMethod('_um')

export * from 'https://unpkg.com/lit-html?module'
export * from 'https://unpkg.com/@vue/reactivity/dist/reactivity.esm-browser.js'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/reactive.ts&quot;&gt;shallowReactive 源码&lt;/a&gt;，函数注释已经表达的很清楚了，only the root level properties are reactive。对象只有根属性响应，换言之即，浅响应，和浅拷贝类似。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
export function shallowReactive&amp;lt;T extends object&amp;gt;(target: T): T {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers
  )
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/effect.ts&quot;&gt;effect 源码&lt;/a&gt;，粗略的可以看到里面有 dep 依赖，还有 oldValue、newValue 处理。&lt;/p&gt;
&lt;p&gt;通过分析，vue-lit 应该是将 vue3.0 的响应式和 web components 做的一个尝试。用 &lt;code&gt;lit-html&lt;/code&gt; 的原因时因为支持模板支持简单js表达式及事件绑定（原生template目前只有slot插槽）&lt;/p&gt;
&lt;h4 id=&quot;css-doodle&quot;&gt;css-doodle&lt;/h4&gt;
&lt;p&gt;实际上，前面介绍的 css-doodle 也是一个 web component。是浏览器原生就支持的。&lt;/p&gt;
&lt;p&gt;示例：&lt;a href=&quot;https://codepen.io/yuanchuan/pen/YRvMwK&quot;&gt;艺术背景图&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;script src=&quot;https://unpkg.com/css-doodle@0.8.5/css-doodle.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

  &amp;lt;css-doodle&amp;gt;
    :doodle { 
      @grid: 1x300 / 100vw 40vmin; 
      overflow: hidden;
      background: linear-gradient(rgba(63, 81, 181, .11), #673AB7);
    }

    align-self: flex-end;
    --h: @r(10, 80, .1);
    @random(.1) { --h: @r(85, 102, .1) }

    @size: 1px calc(var(--h) * 1%);
    background: linear-gradient(transparent, rgba(255, 255, 255, .4), transparent);
    background-size: .5px 100%;
    transform-origin: center 100%;
    transform: translate(@r(-2vmin, 2vmin, .01), 10%) rotate(@r(-2deg, 2deg, .01));
    
    :after {
      content: '';
      position: absolute;
      top: 0;
      @size: calc(2px * var(--h));
      transform: translateY(-50%) scale(.14);
      background: radial-gradient(@p(#ff03929e, #673ab752, #fffa) @r(40%), transparent 50%) 50% 50% / @r(100%) @lr() no-repeat;
    }
  &amp;lt;/css-doodle&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dom 结构：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/806524/202011/806524-20201106185345365-1650950044.png&quot; width=&quot;500&quot;/&gt;&lt;h4 id=&quot;input、select-等内建-html-元素&quot;&gt;input、select 等内建 html 元素&lt;/h4&gt;
&lt;p&gt;input、select 也是 web component。但是是内建的，默认看不到 shadowRoot 结构，需要打开浏览器控制台的设置，勾选&lt;code&gt;Show user agent shadow DOM&lt;/code&gt;，才可以在控制台&lt;code&gt;elements&lt;/code&gt;中看到其结构。&lt;/p&gt;
&lt;p&gt;设置&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/806524/202011/806524-20201106185308038-1544610581.png&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;&lt;p&gt;dom 结构&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/806524/202011/806524-20201106185245094-144365554.png&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;web-components-组件化由-3-部分组成。&quot;&gt;web components 组件化由 3 部分组成。&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Custom elements（自定义元素）&lt;/strong&gt;：一组JavaScript API，允许您定义custom elements及其行为，然后可以在您的用户界面中按照需要使用它们。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shadow DOM（影子DOM）&lt;/strong&gt;：一组JavaScript API，用于将封装的“影子”DOM树附加到元素（与主文档DOM分开呈现）并控制其关联的功能。通过这种方式，您可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTML templates（HTML模板）&lt;/strong&gt;： &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 元素使您可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;custom-elements&quot;&gt;Custom elements&lt;/h3&gt;
&lt;p&gt;用户可以使用 &lt;code&gt;customElements.define&lt;/code&gt; 自定义 html 元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;customElements.define(elementName, class[, extendElement]);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;elementName: 名称不能是单个单词，必须用&lt;strong&gt;短横线&lt;/strong&gt;分隔。&lt;/li&gt;
&lt;li&gt;class: 用以定义元素行为的类，包含生命周期。&lt;/li&gt;
&lt;li&gt;extendElement: 可选参数，一个包含 &lt;code&gt;extends&lt;/code&gt; 属性的配置对象，指定创建元素继承哪个内置 HTML 元素&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据定义，得出有两种 custom element:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Autonomous custom elements: 独立元素，不继承内建的HTML元素。和 html 元素一样使用，例如&lt;code&gt;&amp;lt;custom-info&amp;gt;&amp;lt;/custom-info&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Customized built-in elements: 继承内建的HTML元素。使用先写出内建html元素便签，通过 &lt;strong&gt;is&lt;/strong&gt; 属性指定 custom element 名称，例如&lt;code&gt;&amp;lt;p is=&quot;custom-info&quot;&amp;gt;&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有生命周期：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;connectedCallback：当 custom element首次被插入文档DOM时，被调用。&lt;/li&gt;
&lt;li&gt;disconnectedCallback：当 custom element从文档DOM中删除时，被调用。&lt;/li&gt;
&lt;li&gt;adoptedCallback：当 custom element被移动到新的文档时，被调用。&lt;/li&gt;
&lt;li&gt;attributeChangedCallback: 当 custom element增加、删除、修改自身属性时，被调用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：独立元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;button onclick=&quot;changeInfo()&quot;&amp;gt;更改内容&amp;lt;/button&amp;gt;
  &amp;lt;custom-info text=&quot;hello world&quot;&amp;gt;&amp;lt;/custom-info&amp;gt;

  &amp;lt;script&amp;gt;
    // Create a class for the element
    class CustomInfo extends HTMLElement {
      // 必须加这个属性监听，返回需要监听的属性，才能触发 attributeChangedCallback 回调
      static get observedAttributes() {
        return ['text'];
      }

      constructor() {
        // Always call super first in constructor
        super();

        // Create a shadow root
        const shadow = this.attachShadow({mode: 'open'});
        // Create p
        const info = document.createElement('p');
        info.setAttribute('class', 'info');

        // Create some CSS to apply to the shadow dom
        const style = document.createElement('style');
        console.log(style.isConnected);

        style.textContent = `
          .info {
            color: red;
          }
        `;

        // Attach the created elements to the shadow dom
        shadow.appendChild(style);
        console.log(style.isConnected);
        shadow.appendChild(info);
      }

      connectedCallback () {
        // 赋值
        this.shadowRoot.querySelector('.info').textContent = this.getAttribute('text')
      }

      attributeChangedCallback(name, oldValue, newValue) {
        // TODO
        console.log(name, oldValue, newValue)
        this.shadowRoot.querySelector('.info').textContent = newValue
      }
    }

    // Define the new element
    customElements.define('custom-info', CustomInfo);

    function changeInfo() {
      document.querySelector('custom-info').setAttribute('text', 'custom element')
    }
  &amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：继承元素&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;p is=&quot;custom-info&quot; text=&quot;hello world&quot;&amp;gt;&amp;lt;/p&amp;gt;

  &amp;lt;script&amp;gt;
    // Create a class for the element，extend p element
    class CustomInfo extends HTMLParagraphElement {
      constructor() {

        super();

        const shadow = this.attachShadow({mode: 'open'});
        const info = document.createElement('span');
        info.setAttribute('class', 'info');

        const style = document.createElement('style');
        console.log(style.isConnected);

        style.textContent = `
          .info {
            color: red;
          }
        `;

        shadow.appendChild(style);
        console.log(style.isConnected);
        shadow.appendChild(info);
      }

      connectedCallback () {
        this.shadowRoot.querySelector('.info').textContent = this.getAttribute('text')
      }
    }

    // Define the new element, extend p element
    customElements.define('custom-info', CustomInfo, {extends: 'p'});
  &amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多，请参考：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements&quot;&gt;Custom elements&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;shadow-dom&quot;&gt;Shadow DOM&lt;/h3&gt;
&lt;p&gt;Web components 的重要功能是封装——可以将标记结构、样式和行为隐藏起来，并与页面上的其他代码相隔离，保证不同的部分不会混在一起，使代码更加干净、整洁。Shadow DOM 接口是关键所在，它可以将一个隐藏的、独立的 DOM 附加到一个元素上。&lt;/p&gt;
&lt;p&gt;附加到哪个元素上，和定义 custom element 时有关，如果是独立元素，附加到 document body 上；如果是继承元素，则附加到继承元素上。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/806524/202011/806524-20201106190244687-229075633.png&quot; width=&quot;400&quot;/&gt;&lt;p&gt;可以和操作普通 DOM 一样，利用 API 操作 Shoadow DOM。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;let shadow = elementRef.attachShadow({mode: 'open'});
let shadow = elementRef.attachShadow({mode: 'closed'});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;open&lt;/code&gt; 表示可以通过页面内的 JavaScript 方法来获取 Shadow DOM，如'document.querySelector('custom-info').shadowRoot'。反之，获取不到。&lt;/p&gt;
&lt;p&gt;更多，请参考：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM&quot;&gt;Shadow DOM&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;html-templates&quot;&gt;HTML templates&lt;/h3&gt;
&lt;p&gt;template 和 slot 元素可以创建出非常灵活的 shadow DOM 模板，来填充 custom element。 对于重复使用的 html 结构，可以起到简化作用，非常有意义。&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- 显示 default text --&amp;gt;
  &amp;lt;custom-info&amp;gt;&amp;lt;/custom-info&amp;gt;

  &amp;lt;!-- 显示 template info --&amp;gt;
  &amp;lt;custom-info&amp;gt;
    &amp;lt;span slot=&quot;info&quot;&amp;gt;template info&amp;lt;/span&amp;gt;
  &amp;lt;/custom-info&amp;gt;

  &amp;lt;template id=&quot;custom-info&quot;&amp;gt;
    &amp;lt;style&amp;gt;
      p {
        color: red;
      }
    &amp;lt;/style&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;slot name=&quot;info&quot;&amp;gt;default text&amp;lt;/slot&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;/template&amp;gt;

  &amp;lt;script&amp;gt;
    class CustomInfo extends HTMLElement {
      constructor() {
        super();

        const shadowRoot = this.attachShadow({mode: 'open'});

        const customInfoTpCon = document.querySelector('#custom-info').content;
        
        shadowRoot.appendChild(customInfoTpCon.cloneNode(true));
      }
    }

    customElements.define('custom-info', CustomInfo);
  &amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多，请参考：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_templates_and_slots&quot;&gt;HTML templates and slots&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;web-components-示例&quot;&gt;web components 示例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://wc-todo.firebaseapp.com/native/&quot;&gt;web component todolist&lt;/a&gt;&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/806524/202011/806524-20201106184900901-6260.png&quot; width=&quot;400&quot;/&gt;&lt;p&gt;&lt;a href=&quot;https://wc-todo.firebaseapp.com/&quot;&gt;其他库 todolist 大比拼&lt;/a&gt;&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/806524/202011/806524-20201106184722065-742687185.png&quot; width=&quot;700&quot;/&gt;&lt;p&gt;看图，结果不言而喻。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;浏览器原生能力正在变得很强大。web component 值得拥抱一下。虽然 template 还不是很完善（不支持表达式），但这也只是白板上的一个黑点。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/axuebin/articles/issues/41&quot;&gt;尤大 3 天前发在 GitHub 上的 vue-lit 是啥？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Web_Components&quot;&gt;Web Components&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/shprink/web-components-todo&quot;&gt;web-components-todo&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 06 Nov 2020 11:05:00 +0000</pubDate>
<dc:creator>ESnail</dc:creator>
<og:description>声明：未经允许，不得转载。 Web Components 现世很久了，所以你可能听说过，甚至学习过，非常了解了。但是没关系，可以再重温一下，温故知新。 浏览器原生能力越来越强。 js 曾经的 JQue</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/EnSnail/p/13938504.html</dc:identifier>
</item>
<item>
<title>Java基础系列-单例的7种写法 - 唯一浩哥</title>
<link>http://www.cnblogs.com/V1haoge/p/10755322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/V1haoge/p/10755322.html</guid>
<description>&lt;p&gt;原创文章，转载请标注出处：&lt;a href=&quot;https://www.cnblogs.com/V1haoge/p/10755322.html&quot;&gt;https://www.cnblogs.com/V1haoge/p/10755322.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;Java中单例有7种写法，这个是在面试中经常被问到的内容，而且有时候还要求手写单例实现方式。所以我们有必要认真的了解一下这七种写法。&lt;/p&gt;
&lt;h2 id=&quot;二、七种实现&quot;&gt;二、七种实现&lt;/h2&gt;
&lt;h3 id=&quot;21-懒汉式线程不安全&quot;&gt;2.1 懒汉式——线程不安全&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SingletonOne {
    public static SingletonOne singleton;
    private SingletonOne() {}
    public static SingletonOne getSingleton() {
        if (singleton == null)
            return new SingletonOne();
        return singleton;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;懒汉式实现了懒加载，但是线程不安全，基本不会使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;22-懒汉式线程安全&quot;&gt;2.2 懒汉式——线程安全&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SingletonTwo {
    public static SingletonTwo singleton;
    private SingletonTwo() {}
    public static synchronized SingletonTwo getSingleton() {
        if (singleton == null)
            return new SingletonTwo();
        return singleton;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在第一种的基础上加了个synchronized，保证线程安全，同时实现了懒加载，只是效率不高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;23-饿汉式&quot;&gt;2.3 饿汉式&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SingletonThree {
    public static SingletonThree singleton = new SingletonThree();
    private SingletonThree () { }
    public static SingletonThree getSingleton() {
        return singleton;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;由于实例优先提供，不存在线程安全问题，但是没有实现懒加载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;24-饿汉式变种&quot;&gt;2.4 饿汉式——变种&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SingletonFour {
    public static SingletonFour singleton;
    static {
        singleton = new SingletonFour();
    }
    private SingletonFour () { }
    public static SingletonFour getSingleton() {
        return singleton;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实和之前的一样，仅仅是将单例的创建挪到了静态块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;25-静态内部类式&quot;&gt;2.5 静态内部类式&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SingletonFive {
    private static class SingletonHolder {
        private static SingletonFive singleton = new SingletonFive();
    }
    private SingletonFive () {}
    public static final SingletonFive getSingleton(){
        return SingletonHolder.singleton;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;静态内部类保证了懒加载，单例实例优先提供又保证了线程安全性，较实用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;26-枚举式&quot;&gt;2.6 枚举式&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public enum SingletonSix {
    SINGLETON;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;枚举的天然特性保证了单例，天然的私有构造器，天然的线程安全性，未被大规模使用的原因是枚举出现的有点晚。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;27-双重校验锁式&quot;&gt;2.7 双重校验锁式&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SingletonSeven {
    private static volatile SingletonSeven singleton;
    private SingletonSeven() {}
    public static SingletonSeven getSingleton(){
        if (singleton == null) {
            synchronized (SingletonSeven.class) {
                if (singleton == null)
                    return new SingletonSeven();

            }
        }
        return singleton;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;volatile的使用，为了防止暴露一个未初始化的不完整单例实例；&lt;/li&gt;
&lt;li&gt;双重判空校验，第一个判断避免了频繁的加锁，第二个判断可以拦住多余的创建实例的线程；&lt;/li&gt;
&lt;li&gt;加锁，保证了线程安全（只有一个实例）&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;这种实现方式是经常出现在面试题中的，而且经常会要求手写。&lt;/p&gt;
&lt;h2 id=&quot;三、总结&quot;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;上面罗列的7种设计模式中第1种线程不安全，可以排除在外，第3、4种其实是一种，这样下来其实可以简化为5种方式：懒汉、饿汉、静态内部类、枚举、双重校验锁。&lt;/p&gt;
</description>
<pubDate>Fri, 06 Nov 2020 10:49:00 +0000</pubDate>
<dc:creator>唯一浩哥</dc:creator>
<og:description>原创文章，转载请标注出处：https://www.cnblogs.com/V1haoge/p/10755322.html 一、概述 Java中单例有7种写法，这个是在面试中经常被问到的内容，而且有时候</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/V1haoge/p/10755322.html</dc:identifier>
</item>
</channel>
</rss>