<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ArrayList源码剖析与代码实测 - Yuasin</title>
<link>http://www.cnblogs.com/Yuasin/p/13638287.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yuasin/p/13638287.html</guid>
<description>&lt;ul&gt;&lt;li&gt;写本篇博客的目的在于让自己能够更加了解Java的容器与实现，能够掌握源代码的一些实现与思想，选择从ArrayList入手是因为ArrayList相对来说是实现较为简单的容器，底层实现依赖与数组，将ArrayList整理清楚便于之后理解实现更复杂的容器和线程安全容器&lt;/li&gt;
&lt;li&gt;不同JDK的源码实现会有区别，本篇博客基于OpenJdk14进行源码分析&lt;/li&gt;
&lt;li&gt;本篇博客除了剖析源码以外还将讨论Java中的fail-fast机制&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;继承关系&quot;&gt;继承关系&lt;/h2&gt;
&lt;img src=&quot;https://gitee.com/Yuasin/blog-image/raw/master/img/image-20200908180018052.png&quot; alt=&quot;image-20200908180018052&quot;/&gt;&lt;ul&gt;&lt;li&gt;ArrayList实现List接口，而继承的AbstractList类也实现了List接口，为什么要实现两次List接口呢？详见：&lt;a href=&quot;https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete&quot;&gt;https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;List接口定义了方法，但不进行实现（JDK1.8后接口可以实现default方法，List类中就有体现），我们要实现自己特定的列表时，不需要通过实现List接口去重写所有方法，AbstractList抽象类替我们实现了很多通用的方法，我们只要继承AbstractList并根据需求修改部分即可&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;从构造函数开始&quot;&gt;从构造函数开始&lt;/h2&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用一个容器当然要从容器的构造开始，ArrayList重载了三种构造函数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;日常中最常使用的是无参数构造函数，使用另一个ArrayList来构造新的ArrayList在诸如回溯算法中也很常见。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public ArrayList()
public ArrayList(int initialCapacity)
public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) 
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;无参构造函数中将&lt;code&gt;elementData&lt;/code&gt; 赋值为&lt;code&gt;DEFAULTCAPACITY_EMPTY_ELEMENTDATA&lt;/code&gt;（即空数组），其中&lt;code&gt;elementData&lt;/code&gt;就是ArrayList存放元素的真实位置。也可以在初始化时将容器容量确定为传入的int参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//类中定义的变量
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
transient Object[] elementData; // non-private to simplify nested class access，如果是私有变量，在内部类中获取会比较麻烦

//无参构造
public ArrayList() {
  this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
//初始化容量构造
public ArrayList(int initialCapacity) {
  if (initialCapacity &amp;gt; 0) {
    this.elementData = new Object[initialCapacity];
  } else if (initialCapacity == 0) {
    this.elementData = EMPTY_ELEMENTDATA;
  } else {
    throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                       initialCapacity);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果使用已有容器来构造ArrayList，则新的容器必须实现Collection接口，且其中的泛型 ? 需要是ArrayList泛型参数E的子类（或相同）。由于每个容器的&lt;code&gt;toArray()&lt;/code&gt;方法实现可能不同，返回值不一定为&lt;code&gt;Object[]&lt;/code&gt;，即&lt;code&gt;elementData&lt;/code&gt;的类型会发生变化（例子见ClassTypeTest.java）。所以需要进行类型判断，若&lt;code&gt;elementData.getClass() != Object[].class&lt;/code&gt;则使用Arrays工具类中的copyOf方法将&lt;code&gt;elementData&lt;/code&gt;的类型改回。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public ArrayList(Collection&amp;lt;? extends E&amp;gt; c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // defend against c.toArray (incorrectly) not returning Object[]
            // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//ClassTypeTest.java
public class ClassTypeTest {
    public class Person{ }
    public class Student extends Person{ }
    public static void main(String[] args) {
        Person[] p = new Student[5];
        System.out.println(p.getClass());
    }
}
//output:
//class [LClassTypeTest$Student;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;从add方法深入--数组的扩容&quot;&gt;从add方法深入 / 数组的扩容&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;容器的本质无非是替我们保管一些我们需要储存的数据（基本数据类型、对象），我们可以往容器里加入，也可以从容器里获取，也可以删除容器内元素。使用容器而不是数组是因为数组对于我们使用来说过于不便利&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无法动态改变数组大小&lt;/li&gt;
&lt;li&gt;数组元素删除和插入需要移动整个数组&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;ArrayList容器底层是基于数组实现，但是我们使用的时候却不需要关心数组越界的问题，是因为ArrayList实现了数组的动态扩容，从add方法出发查看ArrayList是怎么实现的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/Yuasin/blog-image/raw/master/img/ArrayList%E6%BA%90%E7%A0%81.jpg&quot; alt=&quot;ArrayList源码&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以看到add方法的调用链如上，ArrayList提供了两个add方法，可以直接往列表尾部添加，或者是在指定位置添加。&lt;code&gt;elementData&lt;/code&gt;数组扩容操作开始于 add方法，当grow()返回扩容后的数组，add方法在这个数组上进行添加（插入）操作。在add方法中看到的modCount变量涉及 Java 的 fail-fast 机制，将在本文后面进行讲解&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//size是ArrayList实际添加的元素的数量，elementData.length为ArrayList能最多容纳多少元素的容量
//通过代码可以看出，当size==elementData.length时，容器无法再放入元素，所以此时需要一个新的、更大的elementData数组
private int size;

public boolean add(E e) {
        modCount++;
        add(e, elementData, size);
        return true;
    }
private void add(E e, Object[] elementData, int s) {
        if (s == elementData.length)
            elementData = grow();
        elementData[s] = e;
        size = s + 1;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当扩容发生时，要求容器需要至少能多放置 &lt;code&gt;minCapacity&lt;/code&gt; 个元素（即容量比原来至少大&lt;code&gt;minCapacity&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static final int DEFAULT_CAPACITY = 10;

private Object[] grow() {
  return grow(size + 1);
}
private Object[] grow(int minCapacity) {
        int oldCapacity = elementData.length;
        if (oldCapacity &amp;gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            int newCapacity = ArraysSupport.newLength(oldCapacity,
                    minCapacity - oldCapacity, /* minimum growth */
                    oldCapacity &amp;gt;&amp;gt; 1           /* preferred growth */);
            return elementData = Arrays.copyOf(elementData, newCapacity);
        } else { 
                        // 当oldCapacity==0 || elementData==DEFAULTCAPACITY_EMPTY_ELEMENTDATA 时进入该分支
                // 即容器使用无参构造函数 或 new ArrayList(0)等情况时进入
                // elementData数组大小被扩容为 10
            return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通常情况下&lt;code&gt;prefGrowth=oldCapacity/2&lt;/code&gt;，由此处可看出&lt;strong&gt;大部分情况下扩容后的数组大小为原数组的1.5倍&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;扩容后的数组大小为原来的1.5倍，可能存在越界情况，此处使用 &lt;code&gt;newLength - MAX_ARRAY_LENGTH &amp;lt;= 0&lt;/code&gt; 进行判断，不能使用 &lt;code&gt;newLength &amp;lt;= MAX_ARRAY_LENGTH&lt;/code&gt; 进行判断，如果 &lt;code&gt;newLength&lt;/code&gt; 超过 2147483647 ，会溢出为负值，此时&lt;code&gt;newLength&lt;/code&gt;依旧小于&lt;code&gt;MAX_ARRAY_LENGTH&lt;/code&gt;。而用&lt;code&gt;newLength - MAX_ARRAY_LENGTH &amp;lt;= 0&lt;/code&gt; 则是相当于将&lt;code&gt;newLength&lt;/code&gt;这个数字在“int环”上向左移动了&lt;code&gt;MAX_ARRAY_LENGTH&lt;/code&gt;位，若这个数字此时为负数（即落在绿色区域），则直接返回当前&lt;code&gt;newLength&lt;/code&gt;，否则进入hugeLength方法。&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://gitee.com/Yuasin/blog-image/raw/master/img/Integer.jpg&quot; alt=&quot;Integer&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;在hugeLength中，当老容量已经达到 2147483647 时，需求的最小新容量加一则溢出，此时抛出异常&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static final int MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;

public static int newLength(int oldLength, int minGrowth, int prefGrowth) {
  // assert oldLength &amp;gt;= 0
  // assert minGrowth &amp;gt; 0

  int newLength = Math.max(minGrowth, prefGrowth) + oldLength;
  //!!! 判断数组大小是否超过int值允许的大小 
  if (newLength - MAX_ARRAY_LENGTH &amp;lt;= 0) {
    return newLength;
  }
  return hugeLength(oldLength, minGrowth);
}

private static int hugeLength(int oldLength, int minGrowth) {
  int minLength = oldLength + minGrowth;
  if (minLength &amp;lt; 0) { // overflow
    throw new OutOfMemoryError(&quot;Required array length too large&quot;);
  }
  if (minLength &amp;lt;= MAX_ARRAY_LENGTH) {
    return MAX_ARRAY_LENGTH;
  }
  return Integer.MAX_VALUE;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;除了add方法，还有&lt;code&gt;public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c)&lt;/code&gt;方法以及它的重载&lt;code&gt;public boolean addAll(int index, Collection&amp;lt;? extends E&amp;gt; c)&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;其他的删查改方法&quot;&gt;其他的删查改方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;因为是基于数组的容器，其他一些删查改的方法都比较简单，基本上就是在数组上操作，此处就不一一展开&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//删除元素：
public E remove(int index) 
public boolean remove(Object o)
public boolean removeAll(Collection&amp;lt;?&amp;gt; c)
boolean removeIf(Predicate&amp;lt;? super E&amp;gt; filter, int i, final int end)
public void clear()

//修改元素：
public E set(int index, E element)
public void replaceAll(UnaryOperator&amp;lt;E&amp;gt; operator)

//查询/获得元素：
public E get(int index)
public int indexOf(Object o) 
public List&amp;lt;E&amp;gt; subList(int fromIndex, int toIndex)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;modcount与fail-fast机制&quot;&gt;modCount与fail-fast机制&lt;/h2&gt;
&lt;p&gt;根据官方文档的描述，ArrayList是一个非线程安全的容器，两个线程可以同时对一个ArrayList进行读、写操作。通常来说对封装了ArrayList的类进行了同步操作后就能确保线程安全。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt; If multiple threads access an &lt;code&gt;ArrayList&lt;/code&gt; instance concurrently, and at least one of the threads modifies the list structurally, it &lt;em&gt;must&lt;/em&gt; be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements,or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，ArrayList实现中也通过fail-fast确保了不正确的多线程操作会尽快的抛出错误，防止Bug隐藏在程序中直到未来的某一天被发现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;fail-fast机制的实现依赖变量 &lt;code&gt;modCount&lt;/code&gt;，该变量在ArrayList执行结构性的修改（structural modification）时会 +1，如add、remove、clear等改变容器size的方法，而在set方法中不自增变量（但令人迷惑的是replaceAll和sort方法却会修改&lt;code&gt;modCount&lt;/code&gt;的值，总结来说不应该依赖modCount实现的fail-fast机制）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//java.util.AbstractList.java
protected transient int modCount = 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;equals方法就使用到了fail-fast，将&lt;code&gt;modCount&lt;/code&gt;赋值给一个&lt;code&gt;expectedModCount&lt;/code&gt;变量，在对两个容器内的元素一一进行完比较判断后得出两个对象是否相等的判断，但在返回判断之前要问一个问题，在对比判断的过程中当前这个ArrayList(this)有没有被其他人（线程）动过？所以加了一个&lt;code&gt;checkForComodification&lt;/code&gt;方法进行判断，如果&lt;code&gt;modCount&lt;/code&gt;与原先不同则代表该ArrayList经过改动，则equals的判断结果并不可信，抛出&lt;code&gt;throw new ConcurrentModificationException()&lt;/code&gt;异常&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//java.util.ArrayList.java
public boolean equals(Object o) {
        if (o == this) {
            return true;
        }

        if (!(o instanceof List)) {
            return false;
        }

        final int expectedModCount = modCount;
        // ArrayList can be subclassed and given arbitrary behavior, but we can
        // still deal with the common case where o is ArrayList precisely
        boolean equal = (o.getClass() == ArrayList.class)
            ? equalsArrayList((ArrayList&amp;lt;?&amp;gt;) o)
            : equalsRange((List&amp;lt;?&amp;gt;) o, 0, size);

        checkForComodification(expectedModCount);
        return equal;
}

private void checkForComodification(final int expectedModCount) {
  if (modCount != expectedModCount) {
    throw new ConcurrentModificationException();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我使用代码模拟了在使用迭代器的情况下&lt;code&gt;throw new ConcurrentModificationException()&lt;/code&gt;的抛出&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class failFastTest_02 {
    
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        int changeIndex = 5;
        for(int i=0;i&amp;lt;10;i++){
            list.add(i);
        }

        Iterator iterator = list.iterator();

        //反射获取expectedModCount
        Field field = iterator.getClass().getDeclaredField(&quot;expectedModCount&quot;);
        field.setAccessible(true);

        //反射获取modCount
        Class&amp;lt;?&amp;gt; l = list.getClass();
        l = l.getSuperclass();
        Field fieldList = l.getDeclaredField(&quot;modCount&quot;);
        fieldList.setAccessible(true);

        while(iterator.hasNext()){
            if(changeIndex==0){
                list.add(-42);
            }
            System.out.println(&quot;Value of expectedModCount:&quot; + field.get(iterator));
            System.out.println(&quot;Value of modCount:&quot; + fieldList.get(list));
            System.out.println(&quot;iterator get element in list  &quot;+ iterator.next());
            changeIndex--;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;getClass()&lt;/strong&gt;方法来获取类的定义信息,通过定义信息再调用&lt;strong&gt;getFields()&lt;/strong&gt;方法来获取类的所有公共属性,或者调用&lt;strong&gt;getDeclaredFields()&lt;/strong&gt;方法来获取类的所有属性,包括公共,保护,私有,默认的方法。但是这里有一点要注意的是这个方法只能获取&lt;strong&gt;当前类&lt;/strong&gt;里面显示定义的属性,不能获取到&lt;strong&gt;父类或者父类的父类及更高层次&lt;/strong&gt;的属性的。使用&lt;strong&gt;Class.getSuperClass()&lt;/strong&gt;获取父类后再获取父类的属性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以看到，在迭代器初始化后，迭代器中的&lt;code&gt;expectedModCount&lt;/code&gt;不会因为ArrayList方法对列表的修改而改变，在这之后对于该列表（ArrayList）的结构性修改都会导致异常的抛出，这确保了迭代器不会出错（迭代器使用 &lt;code&gt;cursor&lt;/code&gt;维护状态，当外界的结构变化时 &lt;code&gt;size&lt;/code&gt;改变，不使用fail-fast &lt;code&gt;public boolean hasNext() {return cursor != size;}&lt;/code&gt;可能会产生错误结果），如果想在使用迭代器时修改列表，应该使用迭代器自带的方法。上述代码报错如下。&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://gitee.com/Yuasin/blog-image/raw/master/img/image-20200909223232857.png&quot; alt=&quot;image-20200909223232857&quot;/&gt;&lt;ul&gt;&lt;li&gt;插一句题外话， &lt;code&gt;cursor&lt;/code&gt;顾名思义跟光标一样，读取一个元素后要将光标向后移动一格，删除一个元素则是将光标前的一个元素删除，此时光标随之退后一格。当然，ArrayList迭代器不能一直退格（remove），必须要先能读取一个元素然后才能将其删除&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;ArrayList底层基于数组实现，元素存放在&lt;code&gt;elementData&lt;/code&gt;数组中，使用无参构造函数时，加入第一个元素后&lt;code&gt;elementData&lt;/code&gt;数组大小为10。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new ArrayList&amp;lt;&amp;gt;().size()&lt;/code&gt;为列表储存真实元素个数，不为列表容量&lt;/li&gt;
&lt;li&gt;正常情况下每次扩容后，容量为原先的1.5倍&lt;/li&gt;
&lt;li&gt;ArrayList中还有内部类Itr、ListItr、SubList、ArrayListSpliterator，其中Itr、ListItr为迭代器，SubList是一个很神奇的实现，方便某些ArrayList方法的使用，对于SubList的非结构性修改会映射到ArrayList上。关于这几个内部类的内容，或许之后还会在该博客内继续更新&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;fail-fast相关：&lt;a href=&quot;https://www.cnblogs.com/goody9807/p/6432904.html&quot;&gt;https://www.cnblogs.com/goody9807/p/6432904.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;a href=&quot;https://baijiahao.baidu.com/s?id=1638201147057831295&amp;amp;wfr=spider&amp;amp;for=pc&quot;&gt;https://baijiahao.baidu.com/s?id=1638201147057831295&amp;amp;wfr=spider&amp;amp;for=pc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内部类访问外部类私有变量：&lt;a href=&quot;https://blog.csdn.net/qq_33330687/article/details/77915345&quot;&gt;https://blog.csdn.net/qq_33330687/article/details/77915345&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 09 Sep 2020 15:44:00 +0000</pubDate>
<dc:creator>Yuasin</dc:creator>
<og:description>ArrayList源码剖析与代码实测（基于OpenJdk14） 写本篇博客的目的在于让自己能够更加了解Java的容器与实现，能够掌握源代码的一些实现与思想，选择从ArrayList入手是因为Array</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yuasin/p/13638287.html</dc:identifier>
</item>
<item>
<title>vue父子组件状态同步的最佳方式 - 木瓜太香</title>
<link>http://www.cnblogs.com/o00o/p/13642978.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/o00o/p/13642978.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;哈喽！大家好！我是木瓜太香，一位老牌儿前端工程师，平时我们在使用 vue 开发的时候，可能会遇到需要父组件与子组件某个状态需要同步的情况，通常这个是因为我们封装组件的时候有一个相同的状态外面要用，里面也要用，今天我们就来看看怎么优雅的解决这个问题吧!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般来说我们实现这个功能，只需要父组件通过 &lt;code&gt;props&lt;/code&gt; 传递给子组件就好了，但是理想很丰满，现实很骨感，如果我们直接在子组件更改传进来的 &lt;code&gt;props&lt;/code&gt; ，不出意外浏览器会给你一坨大红色的报错，因为在 vue 中我们的数据流动是自上而下的，而子组件直接更改父组件传来的 &lt;code&gt;props&lt;/code&gt; 则是自下而上的数据流动，这是 vue 不允许的。&lt;/p&gt;
&lt;p&gt;所以通常我们的解决办法是，父组件通过 props 传入状态给子组件，子组件通过 props 来初始化另外一个内部的状态，子组件每次更改状态之后都通知父组件，然后由父组件来更改自己的状态，其实就是 props on emit 的应用，接下来我们来上代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父组件 Father.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
        &amp;lt;div class=&quot;father&quot;&amp;gt;
        &amp;lt;h1&amp;gt;父组件维护的状态：{{food}}&amp;lt;/h1&amp;gt;
        &amp;lt;son :food=&quot;food&quot; @update:food=&quot;f =&amp;gt; food = f&quot;&amp;gt;&amp;lt;/son&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;子组件 Son.vue&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
        &amp;lt;div class=&quot;son&quot;&amp;gt;
        &amp;lt;h2&amp;gt;子组件中维护的状态：{{innerFood}}&amp;lt;/h2&amp;gt;
        &amp;lt;button @click=&quot;innerFood = '100斤牛肉'&quot;&amp;gt;点击更改子组件状态&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
        export default {
        data () {
          return {
              innerFood: this.food
          }  
        },
        props: {
            food: String
        },
        watch: {
            innerFood (nv) {
                this.$emit(&quot;update:food&quot;,nv)
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我们上述的写法，其实是维护了父子组件中的不同的两个状态，我们做的工作只是将这两个状态同步了，这种写法没有任何问题，其实对于子组件的部分我们也可以通过 computed 来实现，下面我们来看一看另一种子组件内维护同步状态的方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子组件 Son.vue 的另一种写法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
        &amp;lt;div class=&quot;son&quot;&amp;gt;
        &amp;lt;h2&amp;gt;子组件中维护的状态：{{innerFood}}&amp;lt;/h2&amp;gt;
        &amp;lt;button @click=&quot;innerFood = '100斤牛肉'&quot;&amp;gt;点击更改子组件状态&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
        export default {
        props: {
            food: String
        },
        computed: {
            innerFood: {
                get () {
                    return this.food
                },
                set (nv) {
                    this.$emit(&quot;update:food&quot;,nv)
                }
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，两种写法我们都已经演示完毕，现在我们来优化一下父组件中的写法。&lt;/p&gt;
&lt;p&gt;父组件中可以看到我们之前在上面绑定了一个 &lt;code&gt;update:food&lt;/code&gt; 事件，并且使用箭头函数做了一个赋值，其实这里我们可以稍微优化一下，不要箭头函数直接赋值，因为我们触发的是自定义事件，而我们触发的时候给的第一个参数就是新值，我们可以直接通过 &lt;code&gt;$event&lt;/code&gt; 拿到这个值，所以可以写成如下形式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化后的父组件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
        &amp;lt;div class=&quot;father&quot;&amp;gt;
        &amp;lt;h1&amp;gt;父组件维护的状态：{{food}}&amp;lt;/h1&amp;gt;
        &amp;lt;son :food=&quot;food&quot; @update:food=&quot;food = $event&quot;&amp;gt;&amp;lt;/son&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里你以为就结束了？其实我们还可以更近一步，只要满足我们以上的事件命名方式，我们实际上可以使用 &lt;code&gt;sync&lt;/code&gt; 修饰符代替事件的绑定，也就是我们不用写事件绑定了，但是子组件内部的事件触发依然不能少，最终优化的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vue&quot;&gt;&amp;lt;template&amp;gt;
        &amp;lt;div class=&quot;father&quot;&amp;gt;
        &amp;lt;h1&amp;gt;父组件维护的状态：{{food}}&amp;lt;/h1&amp;gt;
        &amp;lt;son :food.sync=&quot;food&quot;&amp;gt;&amp;lt;/son&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此我们就真的完成了父子组件的同步，当然在子组件中维护一个状态不一定是必须的，如果我们只用父组件传给我们的 &lt;code&gt;props&lt;/code&gt; 做展示，而子组件没有对这个 &lt;code&gt;props&lt;/code&gt; 直接更改的行为，那么我们就不用在子组件创建另外一个状态，我们子组件想改他的时候只需要在合适的时机提交合适的事件即可，但是有一种情况我们不得不在子组件中创建另一个状态，就是我们父组件传入的状态在子组件中用于 v-model 这种双向数据绑定的功能时，由于 v-model 会自动更改值所以直接填入从父组件接受的 props 就不合适了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有前端问题需要讨论的可以加我的qun:237871108。也可以通过哔哩哔哩搜索木瓜太香找到我。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 09 Sep 2020 15:27:00 +0000</pubDate>
<dc:creator>木瓜太香</dc:creator>
<og:description>哈喽！大家好！我是木瓜太香，一位老牌儿前端工程师，平时我们在使用 vue 开发的时候，可能会遇到需要父组件与子组件某个状态需要同步的情况，通常这个是因为我们封装组件的时候有一个相同的状态外面要用，里面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/o00o/p/13642978.html</dc:identifier>
</item>
<item>
<title>在Linux命令行里与其他用户通信 - 良许Linux</title>
<link>http://www.cnblogs.com/yychuyu/p/13642310.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yychuyu/p/13642310.html</guid>
<description>&lt;p&gt;大家好，我是良许&lt;/p&gt;
&lt;p&gt;在 Linux 命令行里向其他用户发送信息很简单，很多命令都可以做到这点，麻烦的是你需要从众多命令中挑选一个合适的命令来使用。因此，我挑选了四种常用的 Linux 用户通信命令分享给大家并为你们讲解这四种命令是如何工作的。&lt;/p&gt;
&lt;h4 id=&quot;wall&quot;&gt;wall&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;wall&lt;/code&gt; 命令（意为 &lt;strong&gt;write all&lt;/strong&gt; ）允许你向所有在系统已登录的用户发送信息。 任何用户都可以使用 &lt;code&gt;wall&lt;/code&gt; 命令，但 &lt;code&gt;wall&lt;/code&gt; 命令通常是系统管理员用来向用户发送公告通知的（比如服务器将关闭维护）。&lt;/p&gt;
&lt;p&gt;一个系统管理员可能会发送如下信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ wall The system will be going down in 15 minutes to address a serious problem
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，所有已登录的用户都能看到类似这样的通知：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Broadcast message from admin@dragonfly (pts/0) (Thu Mar  5 08:56:42 2020):

The system is going down in 15 minutes to address a serious problem
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你要发送的信息里有单引号，就需要用双引号将要发送的信息括起来，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ wall &quot;Don't forget to save your work before logging off&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例所示的命令里，最外层的引号在信息传送时不会显示出来，但如果没有最外层的引号，这条命令执行时会一直等待一个和句中单引号配对的引号以结束句子。&lt;/p&gt;
&lt;h4 id=&quot;mesg&quot;&gt;mesg&lt;/h4&gt;
&lt;p&gt;如果因为某些原因你想拒绝某位用户发送来的信息，就可以使用 &lt;code&gt;mesg&lt;/code&gt; 命令。该命令使用时应携带参数 &lt;code&gt;n&lt;/code&gt; 或者 &lt;code&gt;y&lt;/code&gt;，分别表示拒绝或接受某用户来信，其用例如下（ alvin 为用户名）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ mesg n alvin
$ mesg y alvin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得注意的是，使用 &lt;code&gt;mesg&lt;/code&gt; 命令屏蔽用户后，被屏蔽的用户并不会收到自己已被屏蔽的通知，也就是说，被屏蔽的用户并不会知道自己已经被屏蔽了。&lt;/p&gt;
&lt;p&gt;你也可以使用这个命令来接受或屏蔽所有用户的通信，只需把用户名参数省略掉即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ mesg y
$ mesg n
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;write&quot;&gt;write&lt;/h4&gt;
&lt;p&gt;另一个可以直接发送文本信息而不需要转换成电邮的命令是 &lt;code&gt;write&lt;/code&gt;。这个命令能被用于和特定用户的通信中，比如你要向用户名为 &lt;code&gt;alvin&lt;/code&gt; 的用户发送信息，可以用如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ write alvin
Are you still at your desk?
I need to talk with you right away.
^C
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写完发送信息后按 &lt;code&gt;ctrl+C&lt;/code&gt; 退出。这个命令允许你传送信息，但不是开启一个双工通道，它仅仅只能用于送出信息。如果接收用户在不止一个终端上登录，你能选择一个你想传输的终端或者依靠系统选择一个耗时最少的终端传输，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ write alvin#1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你被用户 &lt;code&gt;alvin&lt;/code&gt; 屏蔽了，你会看到如下提示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ write alvin
write: alvin has messages disabled
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;talk--ytalk&quot;&gt;talk / ytalk&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;talk&lt;/code&gt; 和 &lt;code&gt;ytalk&lt;/code&gt; 命令让你可以和一个或多个用户建立交互通信，其中 &lt;code&gt;talk&lt;/code&gt; 命令只允许你和一个用户建立交互通信。&lt;code&gt;talk&lt;/code&gt; 与 &lt;code&gt;ytalk&lt;/code&gt; 命令都会启动一个双版面的窗口，通信的每一方都可以在窗口的上部版面输入信息并在下部版面看到回应信息。&lt;/p&gt;
&lt;p&gt;被请求加入通信的一方可以通过输入 &lt;code&gt;talk&lt;/code&gt; 并在其后跟上通信发起方的用户名即可回应通信，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Message from Talk_Daemon@dragonfly at 10:10 ...
talk: connection requested by alvin@127.0.0.1.
talk: respond with:  talk alvin@127.0.0.1

$ talk alvin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得注意的是，当系统既安装了 &lt;code&gt;talk&lt;/code&gt; 也安装了 &lt;code&gt;ytalk&lt;/code&gt; 时， &lt;code&gt;talk&lt;/code&gt; 命令默认会与 &lt;code&gt;ytalk&lt;/code&gt; 命令相关联，所以当你输入 &lt;code&gt;talk alvin&lt;/code&gt; 后，系统实际上执行的是 &lt;code&gt;ytalk alvin&lt;/code&gt; 。由于我的系统两个命令都安装了，所以执行以上命令后看到的输出实际上是 &lt;code&gt;ytalk alvin&lt;/code&gt; 的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;----------------------------= YTalk version 3.3.0 =--------------------------
Is the report ready?

-------------------------------= root@lxlinux =----------------------------
Just finished it
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上为用户 &lt;code&gt;alvin&lt;/code&gt; 看到的窗口信息，而通信另一方的 &lt;code&gt;root&lt;/code&gt; 看到的窗口内容则是反过来的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;----------------------------= YTalk version 3.3.0 =--------------------------
Just finished it

-------------------------------= alvin@lxlinux =----------------------------
Is the report ready?
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，这个命令也用 &lt;code&gt;ctrl+C&lt;/code&gt; 来终止。&lt;/p&gt;
&lt;p&gt;要用此命令和其他系统的用户通信则需要加上 &lt;code&gt;-h&lt;/code&gt; 的参数，参数值为主机名或IP地址。其用例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ talk -h 192.168.0.11 alvin
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;Linux 系统有很多可用于向已登录的用户发送信息的命令，这些命令在某些情景中是非常有用的，比如用 &lt;code&gt;wall&lt;/code&gt; 广播信息，用 &lt;code&gt;talk&lt;/code&gt; 进行两用户间的交互式会谈，它们都可以让用户快速地交换信息，学会使用这些常用的命令可以让用户间通信更加方便，提高了沟通的效率。&lt;/p&gt;
&lt;p&gt;最后希望本文的内容对你的工作有所帮助，如果你还对这些命令有任何疑问，请留言告诉我呗！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;公众号：良许Linux&lt;/p&gt;
&lt;img src=&quot;https://pic.downk.cc/item/5e618d2f98271cb2b8f65fe8.jpg&quot;/&gt;&lt;h3 id=&quot;有收获？希望老铁们来个三连击，给更多的人看到这篇文章&quot;&gt;有收获？希望老铁们来个三连击，给更多的人看到这篇文章&lt;/h3&gt;
</description>
<pubDate>Wed, 09 Sep 2020 13:55:00 +0000</pubDate>
<dc:creator>良许Linux</dc:creator>
<og:description>大家好，我是良许 在 Linux 命令行里向其他用户发送信息很简单，很多命令都可以做到这点，麻烦的是你需要从众多命令中挑选一个合适的命令来使用。因此，我挑选了四种常用的 Linux 用户通信命令分享给</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yychuyu/p/13642310.html</dc:identifier>
</item>
<item>
<title>hadoop不能互相访问和linux防火墙守护进程 - YY_pdd</title>
<link>http://www.cnblogs.com/yypdd/p/hadoop-question.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yypdd/p/hadoop-question.html</guid>
<description>&lt;p&gt;hadoop集群出错，首要检测手段jps查看Java的进程，注意是否有异常，如果有应该多加关注。缺点：对于某些问题Java进程不会及时体现出来，所以这个操作应该要经常使用，在大规模集群里面肯定要使用自动化脚本进行相应管理，在大数据方面有进阶的zookeeper框架可以管理整个集群。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;134.69531690803&quot;&gt;
&lt;p&gt;前言——作为装过几次集群的菜鸟，对于hadoop集群的安装还是比较有心得的：只要配置文件够好，集群配置就非常容易，否则也容易出现莫名其妙的问题！总结了一份3台机器搭建较完好的集群的一份&lt;a title=&quot;hadoop配置文件&quot; href=&quot;https://www.cnblogs.com/yypdd/p/hadoop-etc.html&quot; target=&quot;_blank&quot;&gt;配置文件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在我将集群配置文件，防火墙（自以为）、集群时间、Java环境变量等等都搞定的情况下，竟然还是出了问题。&lt;/p&gt;
&lt;p&gt;现象是访问不了yarn的web端口。&lt;/p&gt;
&lt;p&gt;因为我在机器上搭过好几次集群，可能存在版本不一样的情况，所以我先用bin/hadoop version查看了hadoop各个节点对应的hadoop版本，发现一样（在其它场景中，我犯过这样的错误）；&lt;/p&gt;
&lt;p&gt;jps查看Java进程是首要的测试手段，但是没发现明显异常；&lt;/p&gt;
&lt;p&gt;然后经典操作：看日志，英语能对大佬来说可能是锦上添花，但对菜鸟来说就是落井下石，不过在logs目录下隐隐发现一个问题，yarn所在机器的logs日志没有其它2个几个节点的日志，再看里面文件里面内容并没有明显的报错信息。&lt;/p&gt;
&lt;p&gt;然后看日志、调网络搞了一晚上最终发现了一个十分明显的问题，在非yarn机器上的机器日志里面显示一直尝试与yarn进程进行连接却一直失败，由此使用网络工具确定了是yarn所在节点自身的问题，使用curl -I查看虚拟机互相访问的情况（没有装浏览器），也是发现yarn主机能自己访问8088端口，但集群里面其它节点却访问不了改节点的8088端口，netstat -ntpl查看网络端口情况发现一切正常。耗了一段时间后，错误信息已经比较明显是yarn主机的网络问题。&lt;/p&gt;
&lt;p&gt;是不是防火墙问题？但是在最开始就已经使用systemctl disable firewall关了linux（centos7）的防火墙，并且用systemctl status firewall查看了几遍的防火墙并且一直都显示没有这个模块。&lt;/p&gt;
&lt;p&gt;灵机一动，根据最近学习的linux知识，linux的服务守护进程daemon基本都是以d结尾的，然而这里使用却是firewall，少了个d。但是就醍醐一般的使用systemctl status firewalld查看yarn主机的防火墙状态，结果果然是active，一抹绿色优点扎眼。&lt;/p&gt;
&lt;p&gt;systemctl disable firewalld关闭防火墙自启动，systemctl stop firewalld关闭防火墙，然后删除集群的data和logs信息，重新bin/hadoop namenode -format格式化namenode，重启集群，再jps看集群状态，windows浏览器访问yarn的8088端口，终于一切正常了。&lt;/p&gt;
&lt;p&gt;1这次出错集群的访问状态很多地方都有较明显的问题，但是因为没经验所以get不到重点，所以空耗了许久。防火墙问题主要还是linux操作不规范和不熟悉，结果导致了一直以为自己执行正确的代码关闭了防火墙，最开始手熟使用firewalld，执行正确，结果反而让自己觉得firewall（错觉）也是正确的，机器尚且可能硬件出错，更何况人呢。执行复杂操作时（集群统一执行某操作）自动化脚本时第一选择，当然脚本因为权限、环境变量等问题也有可能发生问题，不过也还有测试自动化脚本。&lt;/p&gt;
&lt;p&gt;本次错误应该是在三台机器关闭防火墙，第一次成功了，但第二、三次却失败了，但因为对linux操作不熟悉，以为是成功了。这种疲劳错误，应该多使用脚本避免人的疲劳误差。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：以上记载个人犯错过程，以下对hadoop及linux做一些总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、hadoop集群出错，首要检测手段jps查看Java的进程，注意是否有异常，如果有应该多加关注。缺点：对于某些问题Java进程不会及时体现出来，所以这个操作应该要经常使用，在大规模集群里面肯定要使用自动化脚本进行相应管理，在大数据方面有进阶的zookeeper框架可以管理整个集群。&lt;/p&gt;
&lt;p&gt;2、根据jps结果、bug的具体现象分析，bug是哪个类型的，如网络问题、配置问题、硬件问题（HA解决）等。&lt;/p&gt;
&lt;p&gt;3、配置问题：查看集群的所有配置是否一致，hadoop框架本身的版本、hadoop及linux网络的配置文件、集群时间、namenode与datanode生成的版本信息是否一致、data与logs文件是否有隐藏的一些问题等。&lt;/p&gt;
&lt;p&gt;4、网络问题：&lt;/p&gt;
&lt;p&gt;　　4.1、windows主机网络是否与虚拟机网络相连，可以使用ping命令，这个比较基础，但也不得不查。&lt;/p&gt;
&lt;p&gt;　　4.2、对于服务器（没有浏览器）web端口进行访问，可以使用curl -I测试8088端口；ping命令不能测试端口，可以使用端口对应的工具（比如ssh登陆对应22号），或者使用专业的端口扫描工具进行测试。&lt;/p&gt;
&lt;p&gt;　　4.3、关闭防火墙，centos7 systemctl disable firewalld关闭防火墙，centos7使用systemctl工具进行管理，其它linux版本应该使用对应的管理工具关闭防火墙。&lt;/p&gt;
&lt;p&gt;　　4.4、使用netstat -nptl查看linux系统的端口信息，ip:端口，监听ip上面的端口；0.0.0.0ipv4,::::ipv6，监听本机所有ip的端口；需要开放的端口注意不要监听127.0.0.1，监听了loopback本地环回地址，则只能本地访问。&lt;/p&gt;
&lt;p&gt;5、硬件问题：集群HA可以用secondarynamenode复制元数据实现大部分（会丢失数据）；主备模式则可以根据安全需求增加集群的安全性，代价是数据冗余大。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 09 Sep 2020 13:05:00 +0000</pubDate>
<dc:creator>YY_pdd</dc:creator>
<og:description>hadoop集群出错，首要检测手段jps查看Java的进程，注意是否有异常，如果有应该多加关注。缺点：对于某些问题Java进程不会及时体现出来，所以这个操作应该要经常使用，在大规模集群里面肯定要使用自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yypdd/p/hadoop-question.html</dc:identifier>
</item>
<item>
<title>Azure Storage 系列（四）在.Net 上使用Table Storage  - Grant_Allen</title>
<link>http://www.cnblogs.com/AllenMaster/p/13629556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AllenMaster/p/13629556.html</guid>
<description>&lt;h2&gt;一，引言&lt;/h2&gt;
&lt;p&gt;　　今天我们就不多说废话了，直接进入正题，Azure Table Storage。开始内容之前，我们先介绍一下Azure Table Storage.&lt;/p&gt;
&lt;p&gt;　　1，什么是Azure Table Storage&lt;/p&gt;
&lt;p&gt;　　答：Azure Table Storage 是存储结构化的 NoSql 数据的服务，&lt;span data-ttu-id=&quot;d6354-104&quot;&gt;通过无架构设计提供键/属性存储。 &lt;span data-ttu-id=&quot;d6354-105&quot;&gt;因为表存储无架构，因此可以很容易地随着应用程序需求的发展使数据适应存储。 &lt;span data-ttu-id=&quot;d6354-106&quot;&gt;对于许多类型的应用程序来说，访问表存储数据速度快且经济高效，在数据量相似的情况下，其成本通常比传统 SQL 要低（官方解释）。简单来说，Azure  Table Srorage 可以直接将实体，实体对象存入表结构中，和一般的关系型数据库的 Table 很像，包含了列名和行数据，但是它不能提供像SQL中 inner join 方法，也是不能管理 Foreign Key。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;--------------------我是分割线--------------------&lt;/p&gt;
&lt;p&gt;Azure Blob Storage 存储系列：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/AllenMaster/p/13589170.html&quot; target=&quot;_blank&quot;&gt;1，Azure Storage 系列（一）入门简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/AllenMaster/p/13598502.html&quot; target=&quot;_blank&quot;&gt;2，Azure Storage 系列（二） .NET Core Web 项目中操作 Blob 存储&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/AllenMaster/p/13625108.html&quot; target=&quot;_blank&quot;&gt;3，Azure Storage 系列（三）Blob 参数设置说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/AllenMaster/p/13629556.html&quot; target=&quot;_blank&quot;&gt;4，Azure Storage 系列（四）在.Net 上使用Table Storage &lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;二，正文&lt;/h2&gt;
&lt;h3&gt;1，添加对 Table Storage 的 “增，删，改，查” 方法&lt;/h3&gt;
&lt;h4&gt;1.1，安装 Azure.TableStorage 相关的 Nuget 包，&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200908175401747-2106588280.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NuGet：WindowsAzure.Storage（&lt;span&gt;此包已被启用，推荐使用 “&lt;strong&gt;Microsoft.Azure.Cosmos.Table&lt;/strong&gt;”，今天作为演示，就暂时使用当前已经遗弃的包&lt;/span&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Install-Package WindowsAzure.Storage -Version 9.3.3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从9.4.0版本开始，此库已分为多个部分并被替换。大家可以通过当前链接进行查看当前库的状态：&lt;a href=&quot;https://www.nuget.org/packages/WindowsAzure.Storage&quot;&gt;https://www.nuget.org/packages/WindowsAzure.Storage&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;1.2，创建 ITableService 接口，和 TableService 实现类，以及新增相应的对 Table 操作的方法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt; 添加Table数据操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task AddEntity(UserInfo user)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cloudTableClient =&lt;span&gt; _cloudStorageClient.CreateCloudTableClient();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cloudTable = cloudTableClient.GetTableReference(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;USERINFO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.CreateIfNotExistsAsync();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tableOperation =&lt;span&gt; TableOperation.Insert(user);
    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.ExecuteAsync(tableOperation);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;批量添加 Table 表数据&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task BatchAddEntities(List&amp;lt;UserInfo&amp;gt;&lt;span&gt; users)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cloudTableClient =&lt;span&gt; _cloudStorageClient.CreateCloudTableClient();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cloudTable = cloudTableClient.GetTableReference(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;USERINFO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.CreateIfNotExistsAsync();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tableBatchOperation = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TableBatchOperation();
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (UserInfo item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; users)
    {
         tableBatchOperation.Insert(item);
    }

    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.ExecuteBatchAsync(tableBatchOperation);
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;修改 Table 表数据&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task UpdateEntity(UserInfo user)
{
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cloudTableClient =&lt;span&gt; _cloudStorageClient.CreateCloudTableClient();
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cloudTable = cloudTableClient.GetTableReference(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;USERINFO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; queryOperation = TableOperation.Retrieve&amp;lt;UserInfo&amp;gt;&lt;span&gt;(user.PartitionKey, user.RowKey);

   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tableResult = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.ExecuteAsync(queryOperation);
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tableResult.Result &lt;span&gt;is&lt;/span&gt;&lt;span&gt; UserInfo userInfo)
   {
        user.ETag &lt;/span&gt;=&lt;span&gt; userInfo.ETag;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deleteOperation =&lt;span&gt; TableOperation.Replace(user);
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.ExecuteAsync(deleteOperation);
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;查询Table 表数据&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; IAsyncEnumerable&amp;lt;UserInfo&amp;gt; QueryUsers(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; filter)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cloudTableClient =&lt;span&gt; _cloudStorageClient.CreateCloudTableClient();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cloudTable = cloudTableClient.GetTableReference(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;USERINFO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    TableQuery&lt;/span&gt;&amp;lt;UserInfo&amp;gt; query = &lt;span&gt;new&lt;/span&gt; TableQuery&amp;lt;UserInfo&amp;gt;&lt;span&gt;().Where(filter);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; users = &lt;span&gt;await&lt;/span&gt; cloudTable.ExecuteQuerySegmentedAsync&amp;lt;UserInfo&amp;gt;(query, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; users)
    {
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; item;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;删除 Table 表数据&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task DeleteEntity(UserInfo user)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cloudTableClient =&lt;span&gt; _cloudStorageClient.CreateCloudTableClient();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cloudTable = cloudTableClient.GetTableReference(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;USERINFO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; queryOperation = TableOperation.Retrieve&amp;lt;UserInfo&amp;gt;&lt;span&gt;(user.PartitionKey, user.RowKey);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tableResult = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.ExecuteAsync(queryOperation);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tableResult.Result &lt;span&gt;is&lt;/span&gt;&lt;span&gt; UserInfo userInfo)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deleteOperation =&lt;span&gt; TableOperation.Delete(userInfo);
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.ExecuteAsync(deleteOperation);
     }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;删除 Table 表&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task DeleteTable(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; tableName)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cloudTableClient =&lt;span&gt; _cloudStorageClient.CreateCloudTableClient();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cloudTable =&lt;span&gt; cloudTableClient.GetTableReference(tableName);
    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.DeleteIfExistsAsync();
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.3，添加对 TableService ,CloudStorageAccount 的注入&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
services.AddSingleton(x =&amp;gt; &lt;span&gt;new&lt;/span&gt; CloudStorageAccount(&lt;span&gt;new&lt;/span&gt; StorageCredentials(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cnbateblogaccount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FU01h022mn1JjONp+ta0DAXOO7ThK3diYhsdsdm0Hpg891n9nycsTLGZF83nJpGvTIZvsdsdVCVFhGOfV0wndOOQ==&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
services.AddSingleton&lt;/span&gt;&amp;lt;ITableService, TableService&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('85d44caf-346b-43a0-aea9-d6f03306674a')&quot; readability=&quot;34&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_85d44caf-346b-43a0-aea9-d6f03306674a&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_85d44caf-346b-43a0-aea9-d6f03306674a&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_85d44caf-346b-43a0-aea9-d6f03306674a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TableService : ITableService
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; CloudStorageAccount _cloudStorageClient;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TableService(CloudStorageAccount cloudStorageClient)
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;             _cloudStorageClient =&lt;span&gt; cloudStorageClient;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 01，添加表数据+async Task AddEntity(UserInfo user)
&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 添加表数据
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;user&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;用户数据&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task AddEntity(UserInfo user)
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cloudTableClient =&lt;span&gt; _cloudStorageClient.CreateCloudTableClient();
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cloudTable = cloudTableClient.GetTableReference(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;USERINFO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.CreateIfNotExistsAsync();
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; tableOperation =&lt;span&gt; TableOperation.Insert(user);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.ExecuteAsync(tableOperation);
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 02，批量添加用户表数据+async Task BatchAddEntities(List&amp;lt;UserInfo&amp;gt; users)
&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 批量添加用户表数据
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;users&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;用户数据&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task BatchAddEntities(List&amp;lt;UserInfo&amp;gt;&lt;span&gt; users)
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cloudTableClient =&lt;span&gt; _cloudStorageClient.CreateCloudTableClient();
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cloudTable = cloudTableClient.GetTableReference(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;USERINFO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.CreateIfNotExistsAsync();
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; tableBatchOperation = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TableBatchOperation();
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (UserInfo item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; users)
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;                tableBatchOperation.Insert(item);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.ExecuteBatchAsync(tableBatchOperation);
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 03，删除表操作根据表名+async Task DeleteTable(string tableName)
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除表操作根据表名
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;tableName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表命&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task DeleteTable(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; tableName)
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cloudTableClient =&lt;span&gt; _cloudStorageClient.CreateCloudTableClient();
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cloudTable =&lt;span&gt; cloudTableClient.GetTableReference(tableName);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.DeleteIfExistsAsync();
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 04，删除用户数据根据用户条件+async Task DeleteEntity(UserInfo user)
&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 删除用户数据根据用户条件
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;user&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;用户条件&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task DeleteEntity(UserInfo user)
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cloudTableClient =&lt;span&gt; _cloudStorageClient.CreateCloudTableClient();
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cloudTable = cloudTableClient.GetTableReference(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;USERINFO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; queryOperation = TableOperation.Retrieve&amp;lt;UserInfo&amp;gt;&lt;span&gt;(user.PartitionKey, user.RowKey);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; tableResult = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.ExecuteAsync(queryOperation);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (tableResult.Result &lt;span&gt;is&lt;/span&gt;&lt;span&gt; UserInfo userInfo)
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; deleteOperation =&lt;span&gt; TableOperation.Delete(userInfo);
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                 &lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.ExecuteAsync(deleteOperation);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 05，查询用户根据条件+async IAsyncEnumerable&amp;lt;UserInfo&amp;gt; QueryUsers(string filter)
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 查询用户根据条件
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filter&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;条件&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; IAsyncEnumerable&amp;lt;UserInfo&amp;gt; QueryUsers(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; filter)
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cloudTableClient =&lt;span&gt; _cloudStorageClient.CreateCloudTableClient();
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cloudTable = cloudTableClient.GetTableReference(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;USERINFO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt;             TableQuery&amp;lt;UserInfo&amp;gt; query = &lt;span&gt;new&lt;/span&gt; TableQuery&amp;lt;UserInfo&amp;gt;&lt;span&gt;().Where(filter);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; users = &lt;span&gt;await&lt;/span&gt; cloudTable.ExecuteQuerySegmentedAsync&amp;lt;UserInfo&amp;gt;(query, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; users)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 06，更新用户表数据根据新的用户数据+async Task UpdateEntity(UserInfo user)
&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 更新用户表数据根据新的用户数据
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;user&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;新用户数据&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task UpdateEntity(UserInfo user)
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cloudTableClient =&lt;span&gt; _cloudStorageClient.CreateCloudTableClient();
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cloudTable = cloudTableClient.GetTableReference(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;USERINFO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; queryOperation = TableOperation.Retrieve&amp;lt;UserInfo&amp;gt;&lt;span&gt;(user.PartitionKey, user.RowKey);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; tableResult = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.ExecuteAsync(queryOperation);
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (tableResult.Result &lt;span&gt;is&lt;/span&gt;&lt;span&gt; UserInfo userInfo)
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;                 user.ETag =&lt;span&gt; userInfo.ETag;
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; deleteOperation =&lt;span&gt; TableOperation.Replace(user);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                 &lt;span&gt;await&lt;/span&gt;&lt;span&gt; cloudTable.ExecuteAsync(deleteOperation);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;        } 
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TableService.cs&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('93f0d88e-35cb-4e92-ab03-af70ed1c1ff6')&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_93f0d88e-35cb-4e92-ab03-af70ed1c1ff6&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_93f0d88e-35cb-4e92-ab03-af70ed1c1ff6&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_93f0d88e-35cb-4e92-ab03-af70ed1c1ff6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ITableService
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        Task AddEntity(UserInfo user);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         Task BatchAddEntities(List&amp;lt;UserInfo&amp;gt;&lt;span&gt; users);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         IAsyncEnumerable&amp;lt;UserInfo&amp;gt; QueryUsers(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; filter);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        Task UpdateEntity(UserInfo user);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        Task DeleteEntity(UserInfo user);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         Task DeleteTable(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; tableName);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ITableService.cs&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f5b41107-94b3-4905-be71-b30583333198')&quot; readability=&quot;41&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_f5b41107-94b3-4905-be71-b30583333198&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_f5b41107-94b3-4905-be71-b30583333198&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f5b41107-94b3-4905-be71-b30583333198&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Table&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TableExplorerController : Controller
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ITableService _tableService;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TableExplorerController(ITableService tableService)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;._tableService =&lt;span&gt; tableService;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         [HttpPost(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AddUser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt;&lt;span&gt; AddEntity([FromBody]UserInfo user)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt; _tableService.AddEntity(&lt;span&gt;new&lt;/span&gt; UserInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;610124199012223650&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) { Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;135012689@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TelNum = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;13000000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         [HttpPost(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AddBatchUser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt; AddEntities([FromBody]List&amp;lt;UserInfo&amp;gt;&lt;span&gt; users)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             List&amp;lt;UserInfo&amp;gt; userList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;UserInfo&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             userList.Add(&lt;span&gt;new&lt;/span&gt; UserInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lisi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;610124199012223651&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) { Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1350126740@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TelNum = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;13000000001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             userList.Add(&lt;span&gt;new&lt;/span&gt; UserInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lisi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;610124199012223652&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) { Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1350126741@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TelNum = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;13000000002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             userList.Add(&lt;span&gt;new&lt;/span&gt; UserInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lisi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;610124199012223653&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) { Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1350126742@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TelNum = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;13000000003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _tableService.BatchAddEntities(userList);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Users&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult QueryUsers()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; filter = TableQuery.CombineFilters(TableQuery.GenerateFilterCondition(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PartitionKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, QueryComparisons.Equal, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), TableOperators.And, TableQuery.GenerateFilterCondition(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RowKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, QueryComparisons.Equal, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;610124199012223650&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(_tableService.QueryUsers(filter));
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;         [HttpPut(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpdateUser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt;&lt;span&gt; UpdateUser([FromBody]UserInfo user)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt; _tableService.UpdateEntity(&lt;span&gt;new&lt;/span&gt; UserInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;610124199012223650&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) { Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;135012689@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, TelNum = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15000000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         [HttpDelete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DeleteEntity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt;&lt;span&gt; DeleteEntity([FromBody]UserInfo user)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt; _tableService.DeleteEntity(&lt;span&gt;new&lt;/span&gt; UserInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lisi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;610124199012223651&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;         [HttpDelete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{tableName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt; DeleteTable(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; tableName)
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _tableService.DeleteTable(tableName);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok();
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;TableExplorerController.cs&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d765b7ea-6b48-4545-b4b3-6028752e09b3')&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_d765b7ea-6b48-4545-b4b3-6028752e09b3&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_d765b7ea-6b48-4545-b4b3-6028752e09b3&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d765b7ea-6b48-4545-b4b3-6028752e09b3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInfo:TableEntity
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserInfo()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; UserInfo(&lt;span&gt;string&lt;/span&gt; userName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; IdCardNum)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.PartitionKey =&lt;span&gt; userName;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.RowKey =&lt;span&gt; IdCardNum;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Email { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TelNum { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;UserInfo.cs&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;2，运行项目，通过接口方式调用是否可以对 Table 表数据进行操作&lt;/h3&gt;
&lt;h4&gt;2.1 添加用户数据&lt;/h4&gt;
&lt;p&gt;我们在 postman 中调用添加用户表数据接口（控制器中默认构造了用户信息，所以我这边没有在Body中添加参数）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200908183048727-42164122.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，在Azure Portal 上已经创建出一个叫 “USERINFO” 的表信息（注意，大家不要疑惑，可以看看上面添加用户的Service方法，我这里有两行代码）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; cloudTable = cloudTableClient.GetTableReference(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;USERINFO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; cloudTable.CreateIfNotExistsAsync();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取 “USERINFO” 表的引用实例，如果当前实例不存储就创建 “USERINFO” 表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200908183539161-622532892.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们看看 &quot;USERINFO&quot; 表中刚刚添加进去的数据，这时候我们就要借助 VS 的 &quot;Cloud Expoere“ 的工具了&lt;/p&gt;
&lt;p&gt;VS 点击 ”视图=》Cloud Expoere“&lt;/p&gt;
&lt;p&gt;点击当前 ”账号管理“ 找到与之对应的自己的Azure 订阅相关联的账号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200908184338624-1973422635.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 ”cnbateblogaccount“ 的 Azure Storage 账号，找到刚刚创建好的 ”USERINFO“ Azure Table，右键点击”打开“&lt;/p&gt;
&lt;p&gt;我们可以看到添加到 ”USERINFO“ 表中的数据 （注意，Timestamp字段的时间问题，这里是因为Azure Table Storage 采用的是标准时间，换算到中国时间 就得在原有时间基础上+8）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200908184809740-1095236206.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 2.2 批量添加用户数据&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;注意：批量添加 Table 数据的话，这些批量数据的 “&lt;strong&gt;PartitionKey&lt;/strong&gt;” 必须是相同的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909103255773-1376680036.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输入批量添加用户数据的链接，点击 “Send”&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909101019849-709355604.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 我们继续回到 VS 的Cloud Explorer 查看 “USERINFO” Table 的表信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909102217359-227796179.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;额外话题，刚才提到批量添加 Table 表数据，有提到这些数据的 “&lt;strong&gt;&lt;span&gt;&lt;span&gt;PartitionKey&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;” 必须一致。Azure Table Storage 对批处理操作做了一些限制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1，单个批处理中的所有实体必须具有相同的分区键&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2，单个批处理操作只能包含100个实体。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3，查询用户数据&lt;/h4&gt;
&lt;p&gt;注意，我这里使用两个查询条件联合进行查询，分别是 “&lt;strong&gt;PartitionKey&lt;/strong&gt;” 和 “&lt;strong&gt;RowKey&lt;/strong&gt;” 作为查询的 Key，通过 “&lt;strong&gt;Partition&lt;/strong&gt;” 等于 “zhangsan” 和 “&lt;strong&gt;RowKey&lt;/strong&gt;” 等于 “610124199012113650” &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909111520016-34460090.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入查询用户表数据接口，点击 “Send” 进行调用接口&lt;/p&gt;
&lt;p&gt;同时，我们可以看到将查询条件对应的数据查询出来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909113837522-745128564.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 4，更新表数据&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;注意，目前的更新操作时根据 “&lt;strong&gt;PartitionKey&lt;/strong&gt;” 和 “&lt;/span&gt;&lt;strong&gt;&lt;span&gt;RowKey&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;” 进行检索数据，将新的用户数据进行替换操作，记得将旧的表数据中的 “&lt;strong&gt;ETag&lt;/strong&gt;”&lt;/span&gt; &lt;span&gt;也要进行赋值到新的对象中，再执行替换操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909202131104-1022266401.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，我们此时更新操作主要更新的是 “TelNum” 字段&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909202306186-404747736.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 输入查询用户表数据接口，点击 “Send” 进行调用接口，返回状态码 200&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909203454438-2060486706.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时我们再刷新 Table 中的数据，成功的 &lt;strong&gt;PartitionKey&lt;/strong&gt; 等于 “zhangsan”，&lt;strong&gt;RowKey&lt;/strong&gt; 等于 “610124199012223650” 的数据的 TelNum 从 13000000000 改为 “15000000000”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909203630617-1957115036.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;5，删除 Table 表数据&lt;/h4&gt;
&lt;p&gt;我们尝试删除 “&lt;strong&gt;PartitionKey”&lt;/strong&gt; 等于 “&lt;strong&gt;lisi&lt;/strong&gt;”，“&lt;strong&gt;RowKey”&lt;/strong&gt; 等于 “&lt;strong&gt;610124199012223651&lt;/strong&gt;”的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909204418507-1022281884.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 也是根据条件先查询到当前数据，再判断是否存储，如果存在 就执行删除操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909204441311-583320244.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 postman 输入删除实体操作的接口链接，然后点击 “Sand”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909204717191-1048489521.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 接下来，我们继续查看当前 Table 中的数据，以及没有  “&lt;strong&gt;PartitionKey”&lt;/strong&gt; 等于 “&lt;strong&gt;lisi&lt;/strong&gt;”，“&lt;strong&gt;RowKey”&lt;/strong&gt; 等于 “&lt;strong&gt;610124199012223651&lt;/strong&gt;”的数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909204840385-2008927117.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;6，删除 Table 表&lt;/h4&gt;
&lt;p&gt;接下来，我们就要将整个 &quot;&lt;strong&gt;SUERINFO&lt;/strong&gt;&quot; 表删除的操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909205251373-240747117.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 继续在 postman 上调用删除 Table 操作的接口地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909204951260-815581200.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前 Table Storage 已经找不到 “USERINFO” 的 Table 信息了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909205119354-472280659.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 我们再上Azue Portal 上找一找，看看是否把 “USERINFO” 表删除了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202009/1996262-20200909205401174-1242013451.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应的 cnbatebogaccount 存储账户下的 Tables 中已经没有了任何表了&lt;/p&gt;
&lt;p&gt;OK，今天的分享到此结束，撒花🎉🎉🎉🎉🎉🎉！&lt;/p&gt;
&lt;h2&gt;三，结尾&lt;/h2&gt;
&lt;p&gt;　　今天，我们通过代码（已遗弃的类库）演示了一下如何操作 Tables 数据，已经创建/删除 Table，下一篇继续讲解 Table 是如果进行操作的，但是会换一套微软推荐的 “&lt;strong&gt;Microsoft.Azure.Cosmos.Table&lt;/strong&gt;”，我们也要跟上微软的脚步，与时俱进。&lt;/p&gt;
&lt;p&gt;github：&lt;a href=&quot;https://github.com/yunqian44/Azure.Storage.git&quot; target=&quot;_blank&quot;&gt;https://github.com/yunqian44/Azure.Storage.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/AllenMaster&quot; target=&quot;_blank&quot;&gt;Allen&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;版权：转载请在文章明显位置注明作者及出处。如发现错误，欢迎批评指正。&lt;/p&gt;
</description>
<pubDate>Wed, 09 Sep 2020 13:04:00 +0000</pubDate>
<dc:creator>Grant_Allen</dc:creator>
<og:description>一，引言 今天我们就不多说废话了，直接进入正题，Azure Table Storage。开始内容之前，我们先介绍一下Azure Table Storage. 1，什么是Azure Table Stor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AllenMaster/p/13629556.html</dc:identifier>
</item>
<item>
<title>教师节快乐，全网最全编程学习网站汇总来了，还不赶快收藏 - 三分恶</title>
<link>http://www.cnblogs.com/three-fighter/p/13641835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/three-fighter/p/13641835.html</guid>
<description>&lt;p&gt;教师节快乐！&lt;/p&gt;&lt;p&gt;程序员是一个需要不断学习的职业。幸运的是，在这个互联网时代，知识就在那里，等着我们去获取。&lt;/p&gt;
&lt;p&gt;作为一个“收藏从未停止，学习从未开始”的博主，秉承着好东西不能独享的态度，把收藏的学习网站整理分享出来，希望大家不要学我，一定要好好学习，天天进步，升职加薪😂。&lt;/p&gt;
&lt;p&gt;好了，下面开始上货，由于博主是个Java程序员，所以部分内容会偏向Java全栈。&lt;/p&gt;
&lt;p&gt;首先列出一些在线教程网站，这些在线教程网站通常都比较适合入门，可以作为开发学习路上的第一个阶梯，也可以作为工作中的在线文档。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;1、how2jcn&quot;&gt;1、how2j.cn&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://how2j.cn/&quot;&gt;how2j.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：一个Java全栈开发教程网站，内容全面，简洁易懂，非常适合入门。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906100351664.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;2、w3cschool&quot;&gt;2、w3cschool&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.w3cschool.cn/&quot;&gt;w3cschool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：前端和脚本语言为主的在线教程网站，前端的内容非常不错。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906154643424.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3、菜鸟教程&quot;&gt;3、菜鸟教程&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.runoob.com/&quot;&gt;菜鸟教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：和w3cschool类似的在线教程网站，前端学习看这两个网站就够了。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906155023511.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4、易百教程&quot;&gt;4、易百教程&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.yiibai.com/&quot;&gt;易百教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：内容比较全面的在线教程网站。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906155358890.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5、码农教程&quot;&gt;5、码农教程&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;http://www.manongjc.com/&quot;&gt;码农教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：大量IT编程入门教程(JAVA, PHP, JAVASCRIPT, C, C++, HTML, CSS等)。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906155658701.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;6、简单教程&quot;&gt;6、简单教程&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.twle.cn/&quot;&gt;简单教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：大量IT编程入门教程(前端、移动端、Java、.net等)。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906155919677.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;7、break易站&quot;&gt;7、Break易站&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.breakyizhan.com/&quot;&gt;Break易站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：比较多的编程教程(Java、前端、服务端部署等)。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020090616023888.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;8、c语言中文网&quot;&gt;8、C语言中文网&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;http://c.biancheng.net/&quot;&gt;C语言中文网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：以C语言为主，也包含数据结构、C++、Linux等。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906160734733.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;9、并发编程网&quot;&gt;9、并发编程网&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;http://ifeve.com/&quot;&gt;并发编程网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：比较不错的技术网站，以Java为主，关注并发、NIO、JVM、框架等方面的内容。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906161059875.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;10、jenkovcom&quot;&gt;10、jenkov.com&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;http://tutorials.jenkov.com/&quot;&gt;jenkov.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：一个国外的技术网站，提供了非常不错的Java教程。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906201904599.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;11、baeldungcom&quot;&gt;11、baeldung.com&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.baeldung.com/&quot;&gt;baeldung.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：也是一个国外的技术网站，提供了非常不错的Java教程。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906202026767.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的在线教程网站以文字性内容为主，同样收藏了一些以视频为主的一些网站，相比较而言，更容易上手，当然，也更加耗时间。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;1、b站&quot;&gt;1、B站&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.bilibili.com/&quot;&gt;bilibili&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：没错，bilibili也可以用来学习，除了番剧、鬼畜之外，b站同样有非常多的高质量的编程教学视频，搜索就行了。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906161859105.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、慕课网&quot;&gt;2、慕课网&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.imooc.com/&quot;&gt;慕课网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：比较不错的编程视频教学网站，可以找到比较体系的东西，当然，有些内容要花钱就是了。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906162157598.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3、中国大学mooc&quot;&gt;3、中国大学MOOC&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.icourse163.org/&quot;&gt;中国大学MOOC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：有很多名校的课程，当然不止CS。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906162441400.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4、网易云课堂&quot;&gt;4、网易云课堂&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://study.163.com/?from=study&quot;&gt;网易云课堂&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：有一些计算机编程方面的视频教程。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906162549323.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5、实验楼&quot;&gt;5、实验楼&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.lanqiao.cn/courses/&quot;&gt;实验楼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：IT技术课程网站。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906162842770.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;6、我要自学网&quot;&gt;6、我要自学网&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：（敏感词，自行百度）&lt;/li&gt;
&lt;li&gt;简       介：比较多的自学教程，有程序设计内容的分类。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906163302496.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;7、大学生自学网&quot;&gt;7、大学生自学网&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;http://v.dxsbb.com/jisuanji/&quot;&gt;大学生自学网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：有一些计算机软件的大学课程。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906163436115.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;8、极客学院&quot;&gt;8、极客学院&lt;/h2&gt;
&lt;ul readability=&quot;-0.904&quot;&gt;&lt;li readability=&quot;-0.65714285714286&quot;&gt;
&lt;p&gt;地       址：&lt;a href=&quot;https://www.jikexueyuan.com/&quot;&gt;极客学院&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;简       介：IT编程课程网站，付费内容居多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推荐指数：⭐⭐&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906163758382.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;学习编程，有些书是必须要看的，例如博主是学Java的，《Java编程思想》、《Java核心技术》等等一些经典书籍是不可绕过的。实体书就不多说了，某宝、某东等等电商平台都能买到。如果是想做一些笔记或者不方便携带纸质书的时候，电子书是个不错的选择。（有条件请支持实体书）&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;1、图灵社区&quot;&gt;1、图灵社区&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.ituring.com.cn/&quot;&gt;图灵社区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：书籍比较全面的图书社区，电子书的价格是纸质书的一半。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906164643244.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、博文视点&quot;&gt;2、博文视点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;http://www.broadview.com.cn/book?tab=ebook&quot;&gt;博文视点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：博文视点也是有一些好书的。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906165034411.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3、书栈网&quot;&gt;3、书栈网&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.bookstack.cn/&quot;&gt;书栈网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：电子书门类比较全，支持在线查看和下载。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906165218572.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4、脚本之家&quot;&gt;4、脚本之家&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.jb51.net/&quot;&gt;脚本之家&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：脚本之家电子书区有不少电子书，需要关注公众号。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906165657276.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5、java知识分享网&quot;&gt;5、Java知识分享网&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;http://www.java1234.com/&quot;&gt;Java知识分享网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：如网站名字，主要分享Java知识，电子书一般不会挂太久，删的比较快。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906165931627.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;6、码农之家&quot;&gt;6、码农之家&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.xz577.com/&quot;&gt;码农之家&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：比较多的电子书，下载需要关注公众号。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906170142259.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;7、绿色资源网&quot;&gt;7、绿色资源网&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;http://www.downcc.com/&quot;&gt;绿色资源网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：以软件下载为主，也有不少编程电子书，搜索就行了。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906170432390.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;8、鸠摩搜书&quot;&gt;8、鸠摩搜书&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.jiumodiary.com/&quot;&gt;鸠摩搜书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：比较不错的图书搜索引擎。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906170948680.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;9、计算机书籍控&quot;&gt;9、计算机书籍控&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;http://bestcbooks.com/&quot;&gt;计算机书籍控&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：有数百本编程电子书。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906171125731.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;10、淘链客&quot;&gt;10、淘链客&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;http://www.toplinks.cc/s/&quot;&gt;淘链客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：可以搜索电子书下载链接。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906171324297.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;11、hello-girl&quot;&gt;11、hello girl&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.jqhtml.com/down/category/resources&quot;&gt;hello girl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：有不少电子书资源的网站。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906171503982.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;12、工联信息网&quot;&gt;12、工联信息网&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.glxxw2018.com/study/index.html&quot;&gt;工联信息网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：有很多优质的技术资料。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906171644890.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;13、it熊猫&quot;&gt;13、it熊猫&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://itpanda.net/book/&quot;&gt;it熊猫&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：有数百本技术书籍。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906171806489.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;14、极客图书&quot;&gt;14、极客图书&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://jikbook.com/&quot;&gt;极客图书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：可观的技术书籍资源。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020090617204252.png?x#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;15、搬书匠&quot;&gt;15、搬书匠&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;http://www.banshujiang.cn/&quot;&gt;搬书匠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：可观的技术书籍资源。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906172204885.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;16、ai-books&quot;&gt;16、ai books&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.aibooks.cc/&quot;&gt;ai books&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：比较多的开发技术图书。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906172413741.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;17、爱分享电子书&quot;&gt;17、爱分享电子书&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;http://www.ishare1.cn/&quot;&gt;爱分享电子书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：比较多的计算机、软件书籍。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;img src=&quot;https://img-blog.csdnimg.cn/2020090617253627.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;有条件请支持正规渠道实体书籍！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;毫无疑问，一项技术，最权威的文档一定是它的官方文档，所有的教程、书籍都是直接或者间接在官方相关文档的基础上完成。所以，编程学习，后面最好还是要看官网的。当然，官网大部分都是英文——其实配合一些翻译插件，没有想象中的那么难。&lt;/p&gt;
&lt;h2 id=&quot;1、java&quot;&gt;1、Java&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.java.com/zh_CN/&quot;&gt;Java|Oracle&lt;/a&gt; 、&lt;a href=&quot;https://docs.oracle.com/en/java/javase/index.html&quot;&gt;Java官方API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：这个不需要多介绍，Java官网和Java官方API。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906174054549.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906174227733.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、spring&quot;&gt;2、Spring&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://spring.io/&quot;&gt;Spring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：毫无疑问Spring已经成为Java EE事实上的标准。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906174543676.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3、mysql&quot;&gt;3、MySQL&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.mysql.com/&quot;&gt;MySQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：MySQL官网&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906180850544.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;4、mybatis&quot;&gt;4、MyBatis&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://mybatis.org/mybatis-3/zh/index.html&quot;&gt;mybatis中文文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：国内最流行的Java持久层框架，而且幸运的是，MyBatis文档是有中文版的。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906181340178.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5、vuejs&quot;&gt;5、Vue.js&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://cn.vuejs.org/&quot;&gt;Vue.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：国内最流行的前端SOP框架，Vue.js的文档是中文的。😀&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906181546491.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;6、linux&quot;&gt;6、Linux&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.linux.org/&quot;&gt;Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：后端程序员必会的Linux.&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906181851934.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;7、git&quot;&gt;7、Git&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：版本管理推荐用Git，同样有中文版本的文档。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906182103467.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;8、dubbo&quot;&gt;8、Dubbo&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;http://dubbo.apache.org/zh-cn/&quot;&gt;Dubbo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：一款高性能的Java RPC框架，国内用的还是比较广泛，源于阿里，中文文档是有的。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906182249751.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;9、redis&quot;&gt;9、Redis&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://redis.io/&quot;&gt;Redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：最流行的No SQL数据库。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906182606184.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;了解技术动态、解决各种问题都会用到技术博客。有些优质博主同样创作了一些比较优秀的技术教程。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;1、csdn&quot;&gt;1、csdn&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.csdn.net/&quot;&gt;csdn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：最大的中文技术博客社区，内容最多，SEO做的也不错。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906192259494.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;2、博客园&quot;&gt;2、博客园&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;博客园&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：老牌中文技术博客社区，博客质量比较高，商业化气息也比较淡，之前广为诟病的UI风格也在今年进行了改进，自定义主题也让能让博客百花争艳。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906193241318.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3、掘金&quot;&gt;3、掘金&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://juejin.im/&quot;&gt;掘金&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：UI做的最漂亮的中文技术博客社区，内容以前端和面试居多。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906193508150.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4、简书&quot;&gt;4、简书&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.jianshu.com/&quot;&gt;简书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：并不是纯粹的技术博客社区，很多伤春悲秋的东西。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906193705882.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5、思否&quot;&gt;5、思否&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://segmentfault.com/&quot;&gt;思否&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：包含博客、问答的技术社区。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020090619403934.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;6、开源中国&quot;&gt;6、开源中国&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址：&lt;a href=&quot;https://www.oschina.net/?nocache=1569208099203&quot;&gt;开源中国&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：一个技术博客社区。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906194318330.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;7、51ctocom&quot;&gt;7、51CTO.COM&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://www.51cto.com/&quot;&gt;51CTO.COM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：一个IT技术网站。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020090619453768.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;8、v2ex&quot;&gt;8、V2EX&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://www.v2ex.com/?__cf_chl_jschl_tk__=5907c8972b8fb4c992ca2fa25691e818655aaf69-1599392474-0-ASUvqJYLbkuGxfJ5UcumZuXQc2jf51HFxeuIenm_s9cHQ7PRR4j0l63judhWZhOspvBySd2QIWUyFwXjIAoVl1wocvi2b_FD8OudyQSsvm5BhDuEzBUcWEY1iG80HloeAPs2RQcyHsKQAGXn_GiLunq8mt4dMw0N7En1W0TEtcl1a2SoVIfqb2Z4fT5gLyv4SHnQibJGzMe6JdgV3YgHHIeIaKbtne0wmmA-z3drahWkp1WQZICo_9cJeij0ns1BR9H6lrwoO48QsDxMhDSUjB_5NdmTeagZo35CiNbaW1YsIVW3DQoYHH-wgipLEIERdhpC-dZylgLqCKhBEfxmw-s&quot;&gt;V2EX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：逼格很高，只支持谷歌邮箱登录。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906194721173.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;9、腾讯云社区&quot;&gt;9、腾讯云社区&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://cloud.tencent.com/developer&quot;&gt;腾讯云社区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：腾讯云的开发者社区。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906194911223.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;10、阿里云社区&quot;&gt;10、阿里云社区&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://yq.aliyun.com/?spm=a2c4e.11157919.headermainnav.1.4408f204iW6Tmu&quot;&gt;阿里云社区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：阿里云的开发者社区。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906195034137.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;11、开发者头条&quot;&gt;11、开发者头条&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://toutiao.io/&quot;&gt;开发者头条&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：一个程序员分享平台。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906195633946.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;12、gitchat&quot;&gt;12、GitChat&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址:&lt;a href=&quot;https://gitbook.cn/&quot;&gt;GitChat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：一个技术博客社区&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906200240645.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;13、知乎&quot;&gt;13、知乎&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://www.zhihu.com/&quot;&gt;知乎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：知乎是个综合性的问答社区，但是聚集的程序员也比较多，有一些高质量的问答和专栏。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906213359710.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面介绍了一些国内的博客社区，事实上，放眼看世界也很重要，毕竟我们用的技术大部分都来自国外。当然，其实更加建议想办法访问谷歌，个人觉得一个谷歌足矣。&lt;/p&gt;
&lt;h2 id=&quot;1、stack-overflow&quot;&gt;1、Stack Overflow&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://stackoverflow.com/&quot;&gt;Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：全球最活跃的程序员技术问答交流社区，有人说程序员的所有问题都能在上面找到答案。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906201000458.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;2、devio&quot;&gt;2、dev.io&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://dev.to/&quot;&gt;dev.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：可以说是掘金的国外版。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020090620122180.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3、dzone&quot;&gt;3、DZone&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://dzone.com/&quot;&gt;DZone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：DZone.com是世界上最大的在线社区之一。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906201449821.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4、bytes&quot;&gt;4、Bytes&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://bytes.com/&quot;&gt;Bytes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：一个面向开发人员和IT专业人员的交流社区。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906202209636.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;5、google-developers&quot;&gt;5、Google Developers&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://developers.google.com/&quot;&gt;Google Developers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：google开发社区。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906202428780.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面列出的博客都是比较大型、综合的博客社区，实际上还有很多比较优质某个技术分类的博客、大厂技术博客、小而美的个人博客。这些博客可能也会发布到各大博客社区，但是这些博客网站风格不一，各有个性，也是很值得单独拿出来看的。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;1、美团技术团队&quot;&gt;1、美团技术团队&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://tech.meituan.com/&quot;&gt;美团技术团队&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：美团技术团队的博客，干货满满。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906203308946.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、阮一峰的网络日志&quot;&gt;2、阮一峰的网络日志&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;http://www.ruanyifeng.com/blog/&quot;&gt;阮一峰的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：大神阮一峰，博客风格真正做到深入浅出。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020090620373546.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;3、spring-boot中文导航&quot;&gt;3、Spring Boot中文导航&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;http://springboot.fun/&quot;&gt;Spring Boot中文导航&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：汇总了一些比较优秀的Spring Boot博客、开源作品等。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906204015619.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;4、spring-cloud中文导航&quot;&gt;4、Spring Cloud中文导航&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;http://springcloud.fun/&quot;&gt;Spring Cloud中文导航&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：汇总了一些比较优秀的Spring Cloud 博客、开源作品等。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906204546205.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上面两个索引里已经有了一些比较优秀的个人博主的相关博客地址，所以里面出现的个人博客，后面就不再列出了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br/&gt;&lt;h2 id=&quot;5、web前端导航&quot;&gt;5、Web前端导航&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;http://www.alloyteam.com/nav/&quot;&gt;Web前端导航&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：比较全的Web前端导航，包括 团队组织 、开发社区 、 前端门户、框架类库 等等网站的导航。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906205105194.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;6、spring-for-all&quot;&gt;6、Spring For All&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;http://www.spring4all.com/&quot;&gt;Spring For All&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：目标是做最专业的的民间Sptng组织。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906205533746.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;7、廖雪峰的官方网站&quot;&gt;7、廖雪峰的官方网站&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://www.liaoxuefeng.com/&quot;&gt;廖雪峰的官方网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：廖雪峰老师的网站，有一些不错的入门教程。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906210008122.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;8、bugstack&quot;&gt;8、bugstack&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://bugstack.cn/&quot;&gt;bugstack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：博主是京东架构师，产出非常丰富，包括框架、源码、设计模式等。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020090621022112.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;9、java技术驿站&quot;&gt;9、Java技术驿站&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;http://cmsblogs.com/&quot;&gt;Java技术驿站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：有很多不错的Java系列文章。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906210426576.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;10、酷壳&quot;&gt;10、酷壳&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://coolshell.cn/&quot;&gt;酷壳&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：可以了解陈皓，是个很有个性的人。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906210632853.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;11、床长人工智能教程&quot;&gt;11、床长人工智能教程&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://www.captainbed.net/blog-neo/&quot;&gt;床长人工智能教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：不搞人工智能也可以看看，写的很有意思的教程，可以作为科普看看。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906210822123.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;12、五分钟学算法&quot;&gt;12、五分钟学算法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://www.cxyxiaowu.com/&quot;&gt;五分钟学算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：有一些非常不错的数据结构、算法相关的内容。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906211122877.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;13、犬小哈教程网&quot;&gt;13、犬小哈教程网&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://www.exception.site/&quot;&gt;犬小哈教程网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：一些哈士奇的技术问答漫画很有意思。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906211427929.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;15、原创技术大联盟&quot;&gt;15、原创技术大联盟&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;http://techblog.pub/&quot;&gt;原创技术大联盟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：优秀的技术博主实在太多了，列不完，也看不完，这里有一个导航页，有上百个优秀博主的博客链接，感兴趣的按需去找吧。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906212002662.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在学习的过程中，可以学习开源社区的优秀项目，也可以把自己的项目发布到开源社区。&lt;/p&gt;
&lt;h2 id=&quot;1、github&quot;&gt;1、GitHub&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://github.com&quot;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：全球最大开源社区，被戏称为全球最大同性交友网站。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906212800846.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、码云&quot;&gt;2、码云&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://gitee.com/&quot;&gt;码云&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：可以看做GitHub的国内版，GitHub虽好，但GitHub服务器在美国，网络方面main一直是个问题，这种情况下，码云是个不错的替代者。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906213052871.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h2 id=&quot;1、leetcode&quot;&gt;1、LeetCode&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://leetcode-cn.com&quot;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：经典的刷题网站，主要是算法题。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906213914404.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、lintcode&quot;&gt;2、LintCode&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://www.lintcode.com/&quot;&gt;LintCode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：和LeetCode类似&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200906214354681.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3、牛客网&quot;&gt;3、牛客网&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;地       址: &lt;a href=&quot;https://www.nowcoder.com/&quot;&gt;牛客网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;简       介：一个联网求职学习交流社区。&lt;/li&gt;
&lt;li&gt;推荐指数：⭐⭐⭐⭐&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020090621453615.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后说一些题外话，本来想写一些关于运动健康的网站，毕竟程序员还是要注意保养自己。但是确实没发现特别好的运动健康类网站。倒是APP比如keep，公众号戴夫健身，当然如果有程序员朋友愿意投身搏击类运动，那就更欢迎了——格斗真的很减压（不能打产品经理和测试，还不能打沙袋），推荐关注 HBE欧式泰拳。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 09 Sep 2020 12:58:00 +0000</pubDate>
<dc:creator>三分恶</dc:creator>
<og:description>教师节快乐！ 程序员是一个需要不断学习的职业。幸运的是，在这个互联网时代，知识就在那里，等着我们去获取。 作为一个“收藏从未停止，学习从未开始”的博主，秉承着好东西不能独享的态度，把收藏的学习网站整理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/three-fighter/p/13641835.html</dc:identifier>
</item>
<item>
<title>[业界方案] 用SOFATracer学习分布式追踪系统Opentracing - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/13641637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/13641637.html</guid>
<description>&lt;p&gt;SOFA是蚂蚁金服自主研发的金融级分布式中间件，包含了构建金融级云原生架构所需的各个组件，SOFATracer 是其中用于分布式系统调用跟踪的组件。 笔者之前有过zipkin的经验，希望扩展到Opentracing，于是在学习SOFATracer官方博客结合源码的基础上总结出此文，与大家分享。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;777.74971110989&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;SOFA是蚂蚁金服自主研发的金融级分布式中间件，包含了构建金融级云原生架构所需的各个组件，SOFATracer 是其中用于分布式系统调用跟踪的组件。&lt;/p&gt;
&lt;p&gt;笔者之前有过zipkin的经验，希望扩展到Opentracing，于是在学习SOFATracer官方博客结合源码的基础上总结出此文，与大家分享。&lt;/p&gt;
&lt;h2 id=&quot;0x01-缘由--问题&quot;&gt;0x01 缘由 &amp;amp; 问题&lt;/h2&gt;
&lt;h3 id=&quot;11-选择&quot;&gt;1.1 选择&lt;/h3&gt;
&lt;p&gt;为什么选择了从SOFATracer入手来学习？理由很简单：有大公司背书（是在金融场景里锤炼出来的最佳实践），有开发者和社区整理的官方博客，有直播，示例简便易调试，为什么不研究使用呢？&lt;/p&gt;
&lt;h3 id=&quot;12-问题&quot;&gt;1.2 问题&lt;/h3&gt;
&lt;p&gt;让我们用问题来引导阅读。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spanId是怎么生成的，有什么规则?&lt;/li&gt;
&lt;li&gt;traceId是怎么生成的，有什么规则？&lt;/li&gt;
&lt;li&gt;客户端哪里生成的Span？&lt;/li&gt;
&lt;li&gt;ParentSpan 从哪儿来？&lt;/li&gt;
&lt;li&gt;ChildSpan由ParentSpan创建，什么时候创建？&lt;/li&gt;
&lt;li&gt;Trace信息怎么传递？&lt;/li&gt;
&lt;li&gt;服务器接收到请求之后做什么？&lt;/li&gt;
&lt;li&gt;SpanContext在服务器端怎么处理？&lt;/li&gt;
&lt;li&gt;链路信息如何搜集？&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;13-本文讨论范围&quot;&gt;1.3 本文讨论范围&lt;/h3&gt;
&lt;p&gt;全链路跟踪分成三个跟踪级别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;跨进程跟踪 (cross-process)(调用另一个微服务)&lt;/li&gt;
&lt;li&gt;数据库跟踪&lt;/li&gt;
&lt;li&gt;进程内部的跟踪 (in-process)(在一个函数内部的跟踪)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;u&gt;本文只讨论 跨进程跟踪 (cross-process)&lt;/u&gt;，因为跨进程跟踪是最简单的 ，容易上手^_^。对于跨进程跟踪，你可以编写拦截器或过滤器来跟踪每个请求，它只需要编写极少的代码。&lt;/p&gt;
&lt;h2 id=&quot;0x02-背景知识&quot;&gt;0x02 背景知识&lt;/h2&gt;
&lt;h3 id=&quot;21-趋势和挑战&quot;&gt;2.1 趋势和挑战&lt;/h3&gt;
&lt;p&gt;容器、Serverless 编程方式的诞生极大提升了软件交付与部署的效率。在架构的演化过程中，可以看到两个变化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用架构开始从单体系统逐步转变为微服务，其中的业务逻辑随之而来就会变成微服务之间的调用与请求。&lt;/li&gt;
&lt;li&gt;资源角度来看，传统服务器这个物理单位也逐渐淡化，变成了看不见摸不到的虚拟资源模式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从以上两个变化可以看到这种弹性、标准化的架构背后，原先运维与诊断的需求也变得越来越复杂。如何理清服务依赖调用关系、如何在这样的环境下快速 &lt;code&gt;debug&lt;/code&gt;、追踪服务处理耗时、查找服务性能瓶颈、合理对服务的容量评估都变成一个棘手的事情。&lt;/p&gt;
&lt;h3 id=&quot;22-可观察性（observability）&quot;&gt;2.2 可观察性（Observability）&lt;/h3&gt;
&lt;p&gt;为了应对这些问题，可观察性(&lt;code&gt;Observability&lt;/code&gt;) 这个概念被引入软件领域。传统的监控和报警主要关注系统的异常情况和失败因素，&lt;u&gt;可观察性更关注的是从系统自身出发，去展现系统的运行状况，更像是一种对系统的自我审视&lt;/u&gt;。一个可观察的系统中更关注应用本身的状态，而不是所处的机器或者网络这样的间接证据。我们希望直接得到应用当前的吞吐和延迟信息，为了达到这个目的，我们就需要合理主动暴露更多应用运行信息。在当前的应用开发环境下，面对复杂系统我们的关注将逐渐由点 到 点线面体的结合，这能让我们更好的理解系统，不仅知道What，更能回答Why。&lt;/p&gt;
&lt;p&gt;可观察性目前主要包含以下三大支柱：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;日志(&lt;code&gt;Logging&lt;/code&gt;) : &lt;code&gt;Logging&lt;/code&gt; 主要记录一些离散的事件，应用往往通过将定义好格式的日志信息输出到文件，然后用日志收集程序收集起来用于分析和聚合。虽然可以用时间将所有日志点事件串联起来，但是却很难展示完整的调用关系路径；&lt;/li&gt;
&lt;li&gt;度量(&lt;code&gt;Metrics&lt;/code&gt;) :&lt;code&gt;Metric&lt;/code&gt; 往往是一些聚合的信息，相比 &lt;code&gt;Logging&lt;/code&gt; 丧失了一些具体信息，但是占用的空间要比完整日志小的多，可以用于监控和报警，在这方面 Prometheus 已经基本上成为了事实上的标准；&lt;/li&gt;
&lt;li&gt;分布式追踪(&lt;code&gt;Tracing&lt;/code&gt;) : &lt;code&gt;Tracing&lt;/code&gt; 介于 &lt;code&gt;Logging&lt;/code&gt; 和 &lt;code&gt;Metric&lt;/code&gt; 之间， 以请求的维度来串联服务间的调用关系并记录调用耗时，即保留了必要的信息，又将分散的日志事件通过 Span 串联，帮助我们更好的理解系统的行为、辅助调试和排查性能问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三大支柱有如下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Metric的特点是，它是可累加的。具有原子性，每个都是一个逻辑计量单元，或者一个时间段内的柱状图。 例如：队列的当前深度可以被定义为一个计量单元，在写入或读取时被更新统计； 输入HTTP请求的数量可以被定义为一个计数器，用于简单累加；请求的执行时间可以被定义为一个柱状图，在指定时间片上更新和统计汇总。&lt;/li&gt;
&lt;li&gt;Logging的特点是，它描述一些离散的（不连续的）事件。 例如：应用通过一个滚动的文件输出debug或error信息，并通过日志收集系统，存储到Elasticsearch中；审批明细信息通过Kafka，存储到数据库（BigTable）中； 又或者，特定请求的元数据信息，从服务请求中剥离出来，发送给一个异常收集服务，如NewRelic。&lt;/li&gt;
&lt;li&gt;Tracing的最大特点就是，它在单次请求的范围内处理信息。 任何的数据、元数据信息都被绑定到系统中的单个事务上。 例如：一次调用远程服务的RPC执行过程；一次实际的SQL查询语句；一次HTTP请求的业务性ID。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;23-tracing&quot;&gt;2.3 Tracing&lt;/h3&gt;
&lt;p&gt;分布式追踪，也称为分布式请求追踪，是一种用于分析和监视应用程序的方法，特别是那些使用微服务体系结构构建的应用程序；分布式追踪有助于查明故障发生的位置以及导致性能低下的原因，开发人员可以使用分布式跟踪来帮助调试和优化他们的代码，IT和DevOps团队可以使用分布式追踪来监视应用程序。&lt;/p&gt;
&lt;h4 id=&quot;231-tracing-的诞生&quot;&gt;2.3.1 Tracing 的诞生&lt;/h4&gt;
&lt;p&gt;Tracing 是在90年代就已出现的技术。但真正让该领域流行起来的还是源于 Google 的一篇论文”Dapper, a Large-Scale Distributed Systems Tracing Infrastructure”，而另一篇论文”Uncertainty in Aggregate Estimates from Sampled Distributed Traces”中则包含关于采样的更详细分析。论文发表后一批优秀的 Tracing 软件孕育而生。&lt;/p&gt;
&lt;h4 id=&quot;232-tracing的功能&quot;&gt;2.3.2 Tracing的功能&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;故障定位——可以看到请求的完整路径，相比离散的日志，更方便定位问题(由于真实线上环境会设置采样率，可以利用debug开关实现对特定请求的全采样)；&lt;/li&gt;
&lt;li&gt;依赖梳理——基于调用关系生成服务依赖图；&lt;/li&gt;
&lt;li&gt;性能分析和优化——可以方便的记录统计系统链路上不同处理单元的耗时占用和占比；&lt;/li&gt;
&lt;li&gt;容量规划与评估；&lt;/li&gt;
&lt;li&gt;配合&lt;code&gt;Logging&lt;/code&gt;和&lt;code&gt;Metric&lt;/code&gt;强化监控和报警。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;24-opentracing&quot;&gt;2.4 OpenTracing&lt;/h3&gt;
&lt;p&gt;&lt;u&gt;为了解决不同的分布式追踪系统 API 不兼容的问题，出现了OpenTracing&lt;/u&gt;。OpenTracing旨在标准化Trace数据结构和格式，其目的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不同语言开发的Trace客户端的互操作性。Java/.Net/PHP/Python/NodeJs等语言开发的客户端，只要遵循OpenTracing标准，就都可以对接OpenTracing兼容的监控后端。&lt;/li&gt;
&lt;li&gt;Tracing监控后端的互操作性。只要遵循OpenTracing标准，企业可以根据需要替换具体的Tracing监控后端产品，比如从Zipkin替换成Jaeger/CAT/Skywalking等后端。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OpenTracing不是一个标准，OpenTracing API提供了一个标准的、与供应商无关的框架，是对分布式链路中涉及到的一些列操作的高度抽象集合。这意味着如果开发者想要尝试一种不同的分布式追踪系统，开发者只需要简单地修改Tracer配置即可，而不需要替换整个分布式追踪系统。&lt;/p&gt;
&lt;h2 id=&quot;0x03-opentracing-数据模型&quot;&gt;0x03 OpenTracing 数据模型&lt;/h2&gt;
&lt;p&gt;大多数分布式追踪系统的思想模型都来自Google's Dapper论文，&lt;strong&gt;OpenTracing&lt;/strong&gt;也使用相似的&lt;strong&gt;术语&lt;/strong&gt;。有几个基本概念我们需要提前了解清楚：&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Trace(追踪) ：&lt;u&gt;在广义上，一个trace代表了一个事务或者流程在（分布式）系统中的执行过程&lt;/u&gt;。在OpenTracing标准中，trace是多个span组成的一个有向无环图（DAG），每一个span代表trace中被命名并计时的连续性的执行片段。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Span(跨度) ：&lt;u&gt;一个span代表系统中具有开始时间和执行时长的逻辑运行单元，即应用中的一个逻辑操作&lt;/u&gt;。span之间通过嵌套或者顺序排列建立逻辑因果关系。一个span可以被理解为一次方法调用，一个程序块的调用，或者一次RPC/数据库访问，只要是一个具有完整时间周期的程序访问，都可以被认为是一个span。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Logs ：每个span可以进行多次Logs操作，每一次Logs操作，都需要一个带时间戳的时间名称，以及可选的任意大小的存储结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Tags ：每个span可以有多个键值对（key ：value）形式的Tags，Tags是没有时间戳的，支持简单的对span进行注解和补充。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;SpanContext ：&lt;code&gt;SpanContext&lt;/code&gt;更像是一个“概念”，而不是通用 OpenTracing 层的有用功能。在创建&lt;code&gt;Span&lt;/code&gt;、向传输协议&lt;code&gt;Inject&lt;/code&gt;（注入）和从传输协议中&lt;code&gt;Extract&lt;/code&gt;（提取）调用链信息时，&lt;code&gt;SpanContext&lt;/code&gt;发挥着重要作用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;31-span&quot;&gt;3.1 Span&lt;/h3&gt;
&lt;p&gt;表示分布式调用链条中的一个调用单元，他的边界包含一个请求进到服务内部再由某种途径（http/dubbo等）从当前服务出去。&lt;/p&gt;
&lt;p&gt;一个span一般会记录这个调用单元内部的一些信息，例如每个&lt;code&gt;Span&lt;/code&gt;包含的操作名称、开始和结束时间、附加额外信息的&lt;code&gt;Span Tag&lt;/code&gt;、可用于记录&lt;code&gt;Span&lt;/code&gt;内特殊事件&lt;code&gt;Span Log&lt;/code&gt;、用于传递&lt;code&gt;Span&lt;/code&gt;上下文的&lt;code&gt;SpanContext&lt;/code&gt;和定义&lt;code&gt;Span&lt;/code&gt;之间关系的&lt;code&gt;References&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Operation 的 名字(An operation name)&lt;/li&gt;
&lt;li&gt;开始时间 (A start timestamp)&lt;/li&gt;
&lt;li&gt;结束时间 (A finish timestamp)&lt;/li&gt;
&lt;li&gt;标签信息 ：0个或多个以 keys：values 为形式组成的 &lt;strong&gt;Span Tags&lt;/strong&gt;。 key 必须是 string， values 则可以是 strings， bool，numeric types&lt;/li&gt;
&lt;li&gt;日志信息 ：0个或多个 &lt;strong&gt;Span logs&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个 &lt;strong&gt;SpanContext&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过 &lt;strong&gt;SpanContext&lt;/strong&gt; 可以指向 0个 或者多个 因果相关的 &lt;strong&gt;Span&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;32-tracer&quot;&gt;3.2 Tracer&lt;/h3&gt;
&lt;p&gt;Trace 描述在分布式系统中的一次&quot;事务&quot;。&lt;strong&gt;一个trace是由若干span组成的有向无环图&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tracer&lt;/strong&gt; 用于创建Span，并理解如何跨进程边界注入(序列化)和提取(反序列化)Span。它有以下的职责：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;建立和开启一个span&lt;/li&gt;
&lt;li&gt;从某种媒介中提取/注入一个spanContext&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;用图论的观点来看的话，traces 可以被认为是 spans 的 DAG。也就是说，多个 spans 形成的 DAG 是一个 Traces。&lt;/p&gt;
&lt;p&gt;举例来说，下图是一个由八个 Spans 形成的一个 Trace。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;单个 Trace 中 Span 之间的因果关系


        [Span A]  ←←←(the root span)
            |
     +------+------+
     |             |
 [Span B]      [Span C] ←←←(Span C is a `ChildOf` Span A)
     |             |
 [Span D]      +---+-------+
               |           |
           [Span E]    [Span F] &amp;gt;&amp;gt;&amp;gt; [Span G] &amp;gt;&amp;gt;&amp;gt; [Span H]
                                       ↑
                                       ↑
                                       ↑
                         (Span G `FollowsFrom` Span F)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;某些时候， 用时间顺序来具象化更让人理解。下面就是一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;单个 Trace 中 Spans 之间的时间关系

––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&amp;gt; time

 [Span A···················································]
   [Span B··············································]
      [Span D··········································]
    [Span C········································]
         [Span E·······]        [Span F··] [Span G··] [Span H··]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33-references-between-spans&quot;&gt;3.3 References between Spans&lt;/h3&gt;
&lt;p&gt;一个span可以和一个或者多个span间存在因果关系。OpenTracing定义了两种关系：ChildOf 和 FollowsFrom。这两种引用类型代表了子节点和父节点间的直接因果关系。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ChildOf&lt;/code&gt; 将成为当前 Span 的 child，而 &lt;code&gt;FollowsFrom&lt;/code&gt;则会成为 parent。 这两种关系为 &lt;strong&gt;child span&lt;/strong&gt; 和 &lt;strong&gt;parent span&lt;/strong&gt; 建立了直接因果关系。&lt;/p&gt;
&lt;h3 id=&quot;34-spancontext&quot;&gt;3.4 SpanContext&lt;/h3&gt;
&lt;p&gt;表示一个span对应的上下文，span和spanContext基本上是一一对应的关系，这个SpanContext可以通过某些媒介和方式传递给调用链的下游来做一些处理（例如子Span的id生成、信息的继承打印日志等等）。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;上下文存储的是一些需要跨越边界的（传播跟踪所需的）一些信息&lt;/u&gt;，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spanId ：当前这个span的id&lt;/li&gt;
&lt;li&gt;traceId ：这个span所属的traceId(也就是这次调用链的唯一id)。
&lt;ul&gt;&lt;li&gt;&lt;code&gt;trace_id&lt;/code&gt;和 &lt;code&gt;span_id&lt;/code&gt; 用以区分&lt;code&gt;Trace&lt;/code&gt;中的&lt;code&gt;Span&lt;/code&gt;；任何 OpenTraceing 实现相关的状态（比如 trace 和 span id）都需要被一个跨进程的 &lt;strong&gt;Span&lt;/strong&gt; 所联系。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;baggage ：其他的能过跨越多个调用单元的信息，即跨进程的 key value 对。&lt;code&gt;Baggage Items&lt;/code&gt; 和 &lt;code&gt;Span Tag&lt;/code&gt; 结构相同，唯一的区别是：&lt;code&gt;Span Tag&lt;/code&gt;只在当前&lt;code&gt;Span&lt;/code&gt;中存在，并不在整个&lt;code&gt;trace&lt;/code&gt;中传递，而&lt;code&gt;Baggage Items&lt;/code&gt; 会随调用链传递。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;SpanContext&lt;/code&gt;数据结构简化版如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;SpanContext:
- trace_id: &quot;abc123&quot;
- span_id: &quot;xyz789
- Baggage Items:
        - special_id: &quot;vsid1738&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在跨界(跨服务或者协议）传输过程中实现调用关系的传递和关联，需要能够将 &lt;code&gt;SpanContext&lt;/code&gt; 向下游介质注入，并在下游传输介质中提取 &lt;code&gt;SpanContext&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;往往可以使用协议本身提供的类似&lt;code&gt;HTTP Headers&lt;/code&gt;的机制实现这样的信息传递，像&lt;code&gt;Kafka&lt;/code&gt;这样的消息中间件也有提供实现这样功能的&lt;code&gt;Headers&lt;/code&gt;机制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OpenTracing&lt;/code&gt; 实现，可以使用 api 中提供的 Tracer.Inject(...) 和 Tracer.Extract(...) 方便的实现 &lt;code&gt;SpanContext&lt;/code&gt;的注入和提取。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“extarct()”从媒介（通常是HTTP头）获取跟踪上下文。&lt;/li&gt;
&lt;li&gt;“inject()”将跟踪上下文放入媒介，来保证跟踪链的连续性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;35-carrier&quot;&gt;3.5 Carrier&lt;/h3&gt;
&lt;p&gt;Carrier 表示的是一个承载spanContext的媒介，比方说在http调用场景中会有HttpCarrier，在dubbo调用场景中也会有对应的DubboCarrier。&lt;/p&gt;
&lt;h3 id=&quot;36-formatter&quot;&gt;3.6 Formatter&lt;/h3&gt;
&lt;p&gt;这个接口负责了具体场景中序列化反序列化上下文的具体逻辑，例如在HttpCarrier使用中通常就会有一个对应的HttpFormatter。Tracer的注入和提取就是委托给了Formatter。&lt;/p&gt;
&lt;h3 id=&quot;37-scopemanager&quot;&gt;3.7 ScopeManager&lt;/h3&gt;
&lt;p&gt;这个类是0.30版本之后新加入的组件，这个组件的作用是能够通过它获取当前线程中启用的Span信息，并且可以启用一些处于未启用状态的span。在一些场景中，我们在一个线程中可能同时建立多个span，但是同一时间同一线程只会有一个span在启用，其他的span可能处在下列的状态中：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;等待子span完成&lt;/li&gt;
&lt;li&gt;等待某种阻塞方法&lt;/li&gt;
&lt;li&gt;创建但是并未开始&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;38-reporter&quot;&gt;3.8 Reporter&lt;/h3&gt;
&lt;p&gt;除了上述组件之外，在实现一个分布式全链路监控框架的时候，还需要有一个reporter组件，通过它来打印或者上报一些关键链路信息(例如span创建和结束)，只有把这些信息进行处理之后我们才能对全链路信息进行可视化和真正的监控。&lt;/p&gt;
&lt;h2 id=&quot;0x04-sofatracer&quot;&gt;0x04 SOFATracer&lt;/h2&gt;
&lt;p&gt;SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 traceId 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的。这些日志可用于故障的快速发现，服务治理等。&lt;/p&gt;
&lt;p&gt;SOFATracer 团队已经为我们搭建了一个完整的 Tracer 框架内核，包括数据模型、编码器、跨进程透传 traceId、采样、日志落盘与上报等核心机制，并提供了扩展 API 及基于开源组件实现的部分插件，为我们基于该框架打造自己的 Tracer 平台提供了极大便利。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;SOFATracer 目前并没有提供数据采集器和 UI 展示的功能&lt;/u&gt;；主要有两个方面的考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SOFATracer 作为 SOFA 体系中一个非常轻量的组件，意在将 span 数据以日志的方式落到磁盘，以便于用户能够更加灵活的来处理这些数据&lt;/li&gt;
&lt;li&gt;UI 展示方面，SOFATracer 本身基于 OpenTracing 规范实现，在模型上与开源的一些产品可以实现无缝对接，在一定程度上可以弥补本身在链路可视化方面的不足。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此在上报模型上，SOFATracer 提供了日志输出和外部上报的扩展，方便接入方能够足够灵活的方式来处理上报的数据。通过SOFARPC + SOFATracer + zipKin 可以快速搭建一套完整的链路追踪系统，包括埋点、收集、分析展示等。 收集和分析主要是借用zipKin的能力。&lt;/p&gt;
&lt;p&gt;目前 SOFATracer 已经支持了对以下开源组件的埋点支持：Spring MVC、RestTemplate、HttpClient、OkHttp3、JDBC、Dubbo(2.6⁄2.7)、SOFARPC、Redis、MongoDB、Spring Message、Spring Cloud Stream (基于 Spring Message 的埋点)、RocketMQ、Spring Cloud FeignClient、Hystrix。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Opentracing&lt;/code&gt; 中将所有核心的组件都声明为接口，例如 &lt;code&gt;Tracer&lt;/code&gt;、&lt;code&gt;Span&lt;/code&gt;、&lt;code&gt;SpanContext&lt;/code&gt;、&lt;code&gt;Format&lt;/code&gt;（高版本中还包括 &lt;code&gt;Scope&lt;/code&gt; 和 &lt;code&gt;ScopeManager&lt;/code&gt;）等。&lt;strong&gt;&lt;code&gt;SOFATracer&lt;/code&gt; 使用的版本是 0.22.0&lt;/strong&gt; ，主要是对 &lt;code&gt;Tracer&lt;/code&gt;、&lt;code&gt;Span&lt;/code&gt;、&lt;code&gt;SpanContext&lt;/code&gt; 三个概念模型的实现。下面就针对几个组件结合 &lt;code&gt;SOFATracer&lt;/code&gt; 来分析。&lt;/p&gt;
&lt;h3 id=&quot;41-tracer--sofatracer&quot;&gt;4.1 Tracer &amp;amp; SofaTracer&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Tracer&lt;/code&gt; 是一个简单、广义的接口，它的作用就是构建 &lt;code&gt;span&lt;/code&gt; 和传输 &lt;code&gt;span&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SofaTracer&lt;/code&gt; 实现了 &lt;code&gt;io.opentracing.Tracer&lt;/code&gt; 接口，并扩展了采样、数据上报等能力。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SofaTracer implements Tracer {
    public static final String ROOT_SPAN_ID = &quot;0&quot;;
    private final String tracerType;
    private final Reporter clientReporter;
    private final Reporter serverReporter;
    private final Map&amp;lt;String, Object&amp;gt; tracerTags = new ConcurrentHashMap();
    private final Sampler sampler;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42-span--sofatracerspan&quot;&gt;4.2 Span &amp;amp; SofaTracerSpan&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Span&lt;/code&gt; 是一个跨度单元，在实际的应用过程中，&lt;code&gt;Span&lt;/code&gt; 就是一个完整的数据包，其包含的就是当前节点所需要上报的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SofaTracerSpan&lt;/code&gt; 实现了 &lt;code&gt;io.opentracing.Span&lt;/code&gt; 接口，并扩展了对 &lt;code&gt;Reference&lt;/code&gt;、&lt;code&gt;tags&lt;/code&gt;、线程异步处理以及插件扩展中所必须的 &lt;code&gt;logType&lt;/code&gt;和产生当前 &lt;code&gt;span&lt;/code&gt;的 &lt;code&gt;Tracer&lt;/code&gt;类型等处理的能力。&lt;/p&gt;
&lt;p&gt;每个span 包含两个重要的信息 span id（当前模块的span id）和 span parent ID（上一个调用模块的span id），通过这两个信息可以定位一个span 在调用链的位置。 这些属于核心信息，&lt;u&gt;存储在&lt;code&gt;SpanContext&lt;/code&gt;中&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SofaTracerSpan implements Span {
    public static final char                                ARRAY_SEPARATOR      = '|';
    private final SofaTracer                                sofaTracer;
    private final List&amp;lt;SofaTracerSpanReferenceRelationship&amp;gt; spanReferences;
    /** tags for String  */
    private final Map&amp;lt;String, String&amp;gt;                       tagsWithStr          = new LinkedHashMap&amp;lt;&amp;gt;();
    /** tags for Boolean */
    private final Map&amp;lt;String, Boolean&amp;gt;                      tagsWithBool         = new LinkedHashMap&amp;lt;&amp;gt;();
    /** tags for Number  */
    private final Map&amp;lt;String, Number&amp;gt;                       tagsWithNumber       = new LinkedHashMap&amp;lt;&amp;gt;();
    private final List&amp;lt;LogData&amp;gt;                             logs                 = new LinkedList&amp;lt;&amp;gt;();
    private String                                          operationName        = StringUtils.EMPTY_STRING;
    private final SofaTracerSpanContext                     sofaTracerSpanContext;
    private long                                            startTime;
    private long                                            endTime              = -1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;u&gt;在SOFARPC中分为 ClientSpan 和ServerSpan。&lt;/u&gt; ClientSpan记录从客户端发送请求给服务端，到接受到服务端响应结果的过程。ServerSpan是服务端收到客户端时间 到 发送响应结果给客户端的这段过程。&lt;/p&gt;
&lt;h3 id=&quot;43-spancontext--sofatracerspancontext&quot;&gt;4.3 SpanContext &amp;amp; SofaTracerSpanContext&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SpanContext&lt;/code&gt; 对于 &lt;code&gt;OpenTracing&lt;/code&gt; 实现是至关重要的，通过 &lt;code&gt;SpanContext&lt;/code&gt; 可以实现跨进程的链路透传，并且可以通过 &lt;code&gt;SpanContext&lt;/code&gt; 中携带的信息将整个链路串联起来。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;官方文档中有这样一句话：“在 &lt;code&gt;OpenTracing&lt;/code&gt; 中，我们强迫 &lt;code&gt;SpanContext&lt;/code&gt; 实例成为不可变的，以避免 &lt;code&gt;Span&lt;/code&gt; 在&lt;code&gt;finish&lt;/code&gt; 和 &lt;code&gt;reference&lt;/code&gt; 操作时会有复杂的生命周期问题。” 这里是可以理解的，如果 &lt;code&gt;SpanContext&lt;/code&gt; 在透传过程中发生了变化，比如改了 &lt;code&gt;tracerId&lt;/code&gt;，那么就可能导致链路出现断缺。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;SofaTracerSpanContext&lt;/code&gt; 实现了 &lt;code&gt;SpanContext&lt;/code&gt; 接口，扩展了构建 &lt;code&gt;SpanContext&lt;/code&gt;、序列化 &lt;code&gt;baggageItems&lt;/code&gt; 以及&lt;code&gt;SpanContext&lt;/code&gt;等新的能力。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface SofaTraceContext {
    void push(SofaTracerSpan var1);
    SofaTracerSpan getCurrentSpan();
    SofaTracerSpan pop();
    int getThreadLocalSpanSize();
    void clear();
    boolean isEmpty();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;431-传递trace信息&quot;&gt;4.3.1 传递Trace信息&lt;/h4&gt;
&lt;p&gt;本小节回答了 &lt;u&gt;Trace信息怎么传递？&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;OpenTracing之中是通过SpanContext来传递Trace信息。&lt;/p&gt;
&lt;p&gt;SpanContext存储的是一些需要跨越边界的一些信息，比如trace Id，span id，Baggage。这些信息会不同组件根据自己的特点序列化进行传递，比如序列化到 http header 之中再进行传递。然后通过这个 SpanContext 所携带的信息将当前节点关联到整个 Tracer 链路中去。&lt;/p&gt;
&lt;p&gt;简单来说就是使用HTTP头作为媒介（Carrier）来传递跟踪信息（traceID）。无论微服务是gRPC还是RESTFul，它们都使用HTTP协议。如果是消息队列（Message Queue），则将跟踪信息（traceID）放入消息报头中。&lt;/p&gt;
&lt;p&gt;SofaTracerSpanContext 类就包括并且实现了 “一些需要跨越边界的一些信息” 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SofaTracerSpanContext implements SpanContext {

    //spanId separator
    public static final String        RPC_ID_SEPARATOR       = &quot;.&quot;;

    //======= The following is the key for serializing data ========================

    private static final String       TRACE_ID_KET           = &quot;tcid&quot;;

    private static final String       SPAN_ID_KET            = &quot;spid&quot;;

    private static final String       PARENT_SPAN_ID_KET     = &quot;pspid&quot;;

    private static final String       SAMPLE_KET             = &quot;sample&quot;;

    /**
     * The serialization system transparently passes the prefix of the attribute key
     */
    private static final String       SYS_BAGGAGE_PREFIX_KEY = &quot;_sys_&quot;;

    private String                    traceId                = StringUtils.EMPTY_STRING;

    private String                    spanId                 = StringUtils.EMPTY_STRING;

    private String                    parentId               = StringUtils.EMPTY_STRING;

    /**
     * Default will not be sampled
     */
    private boolean                   isSampled              = false;

    /**
     * The system transparently transmits data,
     * mainly refers to the transparent transmission data of the system dimension.
     * Note that this field cannot be used for transparent transmission of business.
     */
    private final Map&amp;lt;String, String&amp;gt; sysBaggage             = new ConcurrentHashMap&amp;lt;String, String&amp;gt;();

    /**
     * Transparent transmission of data, mainly refers to the transparent transmission data of the business
     */
    private final Map&amp;lt;String, String&amp;gt; bizBaggage             = new ConcurrentHashMap&amp;lt;String, String&amp;gt;();

    /**
     * sub-context counter
     */
    private AtomicInteger             childContextIndex      = new AtomicInteger(0);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;432-线程存储&quot;&gt;4.3.2 线程存储&lt;/h4&gt;
&lt;p&gt;在链路环节每个节点中，SpanContext 都是线程相关，具体都存储在线程ThreadLocal之中。&lt;/p&gt;
&lt;p&gt;实现是 SofaTracerThreadLocalTraceContext 函数。我们可以看到使用了 ThreadLocal，这是因为Context是和线程上下文相关的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SofaTracerThreadLocalTraceContext implements SofaTraceContext {
    private final ThreadLocal&amp;lt;SofaTracerSpan&amp;gt; threadLocal = new ThreadLocal();

    public void push(SofaTracerSpan span) {
        if (span != null) {
            this.threadLocal.set(span);
        }
    }

    public SofaTracerSpan getCurrentSpan() throws EmptyStackException {
        return this.isEmpty() ? null : (SofaTracerSpan)this.threadLocal.get();
    }

    public SofaTracerSpan pop() throws EmptyStackException {
        if (this.isEmpty()) {
            return null;
        } else {
            SofaTracerSpan sofaTracerSpan = (SofaTracerSpan)this.threadLocal.get();
            this.clear();
            return sofaTracerSpan;
        }
    }

    public int getThreadLocalSpanSize() {
        SofaTracerSpan sofaTracerSpan = (SofaTracerSpan)this.threadLocal.get();
        return sofaTracerSpan == null ? 0 : 1;
    }

    public boolean isEmpty() {
        SofaTracerSpan sofaTracerSpan = (SofaTracerSpan)this.threadLocal.get();
        return sofaTracerSpan == null;
    }

    public void clear() {
        this.threadLocal.remove();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;44-reporter&quot;&gt;4.4 Reporter&lt;/h3&gt;
&lt;p&gt;日志落盘又分为摘要日志落盘 和 统计日志落盘；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;摘要日志是每一次调用均会落地磁盘的日志；&lt;/li&gt;
&lt;li&gt;统计日志是每隔一定时间间隔进行统计输出的日志。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数据上报是 SofaTracer 基于 OpenTracing Tracer 接口扩展实现出来的功能；Reporter 实例作为 SofaTracer 的属性存在，在构造 SofaTracer 实例时，会初始化 Reporter 实例。&lt;/p&gt;
&lt;p&gt;Reporter 接口的设计中除了核心的上报功能外，还提供了获取 Reporter 类型的能力，这个是因为 SOFATracer 目前提供的埋点机制方案需要依赖这个实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Reporter {
    String REMOTE_REPORTER = &quot;REMOTE_REPORTER&quot;;
    String COMPOSITE_REPORTER = &quot;COMPOSITE_REPORTER&quot;;

    //获取 Reporter 实例类型
    String getReporterType();
    //输出 span
    void report(SofaTracerSpan span);
    //关闭输出 span 的能力
    void close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Reporter 的实现类有两个，SofaTracerCompositeDigestReporterImpl 和 DiskReporterImpl ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SofaTracerCompositeDigestReporterImpl：组合摘要日志上报实现，上报时会遍历当前 SofaTracerCompositeDigestReporterImpl 中所有的 Reporter ，逐一执行 report 操作；可供外部用户扩展使用。&lt;/li&gt;
&lt;li&gt;DiskReporterImpl：数据落磁盘的核心实现类，也是目前 SOFATracer 中默认使用的上报器。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0x05-示例代码&quot;&gt;0x05 示例代码&lt;/h2&gt;
&lt;h3 id=&quot;51-resttemplate&quot;&gt;5.1 RestTemplate&lt;/h3&gt;
&lt;p&gt;我们使用的是 RestTemplate 示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.sofa.alipay.tracer.plugins.rest.SofaTracerRestTemplateBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.http.ResponseEntity;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.web.client.AsyncRestTemplate;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
public class RestTemplateDemoApplication {
    private static Logger logger = LoggerFactory.getLogger(RestTemplateDemoApplication.class);

    public static void main(String[] args) throws Exception {
        SpringApplication.run(RestTemplateDemoApplication.class, args);
        RestTemplate restTemplate = SofaTracerRestTemplateBuilder.buildRestTemplate();
        ResponseEntity&amp;lt;String&amp;gt; responseEntity = restTemplate.getForEntity(
            &quot;http://localhost:8801/rest&quot;, String.class);
        logger.info(&quot;Response is {}&quot;, responseEntity.getBody());

        AsyncRestTemplate asyncRestTemplate = SofaTracerRestTemplateBuilder
            .buildAsyncRestTemplate();
        ListenableFuture&amp;lt;ResponseEntity&amp;lt;String&amp;gt;&amp;gt; forEntity = asyncRestTemplate.getForEntity(
            &quot;http://localhost:8801/asyncrest&quot;, String.class);
        //async
        logger.info(&quot;Async Response is {}&quot;, forEntity.get().getBody());

        logger.info(&quot;test finish .......&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x06-启动&quot;&gt;0x06 启动&lt;/h2&gt;
&lt;p&gt;这里首先要提一下SOFATracer 的埋点机制，不同组件有不同的应用场景和扩展点，因此对插件的实现也要因地制宜，SOFATracer 埋点方式一般是通过 Filter、Interceptor 机制实现的。所以下面我们提到的Client启动 / Server 启动就主要是创建了 Filter、Interceptor 机制。&lt;/p&gt;
&lt;p&gt;我们就以 RestTemplate 为例看看SofaTracer的启动。&lt;/p&gt;
&lt;h3 id=&quot;61-spring-spi&quot;&gt;6.1 Spring SPI&lt;/h3&gt;
&lt;p&gt;代码中只用到 SofaTracerRestTemplateBuilder，&lt;u&gt;怎么就能够做到一个完整的链路跟踪&lt;/u&gt;？原来机密在pom.xml文件之中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alipay.sofa&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;tracer-sofa-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在tracer-sofa-boot-starter 的 spring.factories 文件中，定义了很多类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.alipay.sofa.tracer.boot.configuration.SofaTracerAutoConfiguration,\
com.alipay.sofa.tracer.boot.springmvc.configuration.OpenTracingSpringMvcAutoConfiguration,\
com.alipay.sofa.tracer.boot.zipkin.configuration.ZipkinSofaTracerAutoConfiguration,\
com.alipay.sofa.tracer.boot.datasource.configuration.SofaTracerDataSourceAutoConfiguration,\
com.alipay.sofa.tracer.boot.springcloud.configuration.SofaTracerFeignClientAutoConfiguration,\
com.alipay.sofa.tracer.boot.flexible.configuration.TracerAnnotationConfiguration,\
com.alipay.sofa.tracer.boot.resttemplate.SofaTracerRestTemplateConfiguration
org.springframework.context.ApplicationListener=com.alipay.sofa.tracer.boot.listener.SofaTracerConfigurationListener
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring Boot中有一种非常解耦的扩展机制：Spring Factories。这种扩展机制实际上是仿照Java中的SPI扩展机制来实现的。&lt;/p&gt;
&lt;p&gt;SPI的全名为Service Provider Interface，这是一种服务发现机制，为某个接口寻找服务实现。可以让模块装配时候可以动态指明服务。有点类似IOC的思想，就是将装配的控制权移到程序之外。&lt;/p&gt;
&lt;p&gt;Spring Factories是在META-INF/spring.factories文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。这种自定义的SPI机制是Spring Boot Starter实现的基础。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;对于 SpringBoot 工程来说，引入 tracer-sofa-boot-starter 之后，&lt;/u&gt;&lt;u&gt;Spring程序直接读取了 tracer-sofa-boot-starter 的 spring.factories 文件中的类并且实例化。用户就可以在程序中直接使用很多SOFA的功能&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;以Reporter为例。自动配置类 SofaTracerAutoConfiguration 会将当前所有 SpanReportListener 类型的 bean 实例保存到 SpanReportListenerHolder 的 List 对象中。而SpanReportListener 类型的 Bean 会在 ZipkinSofaTracerAutoConfiguration 自动配置类中注入到当前 Ioc 容器中。这样 invokeReportListeners 被调用时，就可以拿到 zipkin 的上报类，从而就可以实现上报。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;对于非 SpringBoot 应用的上报支持，本质上是需要实例化 ZipkinSofaTracerSpanRemoteReporter 对象，并将此对象放在 SpanReportListenerHolder 的 List 对象中&lt;/u&gt;。所以 SOFATracer 在 zipkin 插件中提供了一个ZipkinReportRegisterBean，并通过实现 Spring 提供的 bean 生命周期接口 InitializingBean，在ZipkinReportRegisterBean 初始化之后构建一个 ZipkinSofaTracerSpanRemoteReporter 实例，并交给SpanReportListenerHolder 类管理。&lt;/p&gt;
&lt;h3 id=&quot;62-client启动&quot;&gt;6.2 Client启动&lt;/h3&gt;
&lt;p&gt;这部分代码是 SofaTracerRestTemplateConfiguration。主要作用是生成一个 RestTemplateInterceptor。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;RestTemplateInterceptor 的作用是在请求之前可以先一步做处理&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;首先 SofaTracerRestTemplateConfiguration 的作用是生成一个 SofaTracerRestTemplateEnhance。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@ConditionalOnWebApplication
@ConditionalOnProperty(prefix = &quot;com.alipay.sofa.tracer.resttemplate&quot;, value = &quot;enable&quot;, matchIfMissing = true)
public class SofaTracerRestTemplateConfiguration {

    @Bean
    public SofaTracerRestTemplateBeanPostProcessor sofaTracerRestTemplateBeanPostProcessor() {
        return new SofaTracerRestTemplateBeanPostProcessor(sofaTracerRestTemplateEnhance());
    }

    @Bean
    public SofaTracerRestTemplateEnhance sofaTracerRestTemplateEnhance() {
        return new SofaTracerRestTemplateEnhance();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次，SofaTracerRestTemplateEnhance 会生成一个 RestTemplateInterceptor，&lt;u&gt;这样就可以在请求之前做处理&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SofaTracerRestTemplateEnhance {

    private final RestTemplateInterceptor restTemplateInterceptor;

    public SofaTracerRestTemplateEnhance() {
        AbstractTracer restTemplateTracer = SofaTracerRestTemplateBuilder.getRestTemplateTracer();
        this.restTemplateInterceptor = new RestTemplateInterceptor(restTemplateTracer);
    }

    public void enhanceRestTemplateWithSofaTracer(RestTemplate restTemplate) {
        // check interceptor
        if (checkRestTemplateInterceptor(restTemplate)) {
            return;
        }
        List&amp;lt;ClientHttpRequestInterceptor&amp;gt; interceptors = new ArrayList&amp;lt;&amp;gt;(
            restTemplate.getInterceptors());
        interceptors.add(0, this.restTemplateInterceptor);
        restTemplate.setInterceptors(interceptors);
    }

    private boolean checkRestTemplateInterceptor(RestTemplate restTemplate) {
        for (ClientHttpRequestInterceptor interceptor : restTemplate.getInterceptors()) {
            if (interceptor instanceof RestTemplateInterceptor) {
                return true;
            }
        }
        return false;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;63-服务端启动&quot;&gt;6.3 服务端启动&lt;/h3&gt;
&lt;p&gt;这部分代码是 OpenTracingSpringMvcAutoConfiguration。主要作用是注册了 SpringMvcSofaTracerFilter。&lt;u&gt;Spring Filter 用来对某个 Servlet 程序进行拦截处理时，它可以决定是否将请求继续传递给 Servlet 程序，以及对请求和响应消息是否进行修改&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@EnableConfigurationProperties({ OpenTracingSpringMvcProperties.class, SofaTracerProperties.class })
@ConditionalOnWebApplication
@ConditionalOnProperty(prefix = &quot;com.alipay.sofa.tracer.springmvc&quot;, value = &quot;enable&quot;, matchIfMissing = true)
@AutoConfigureAfter(SofaTracerAutoConfiguration.class)
public class OpenTracingSpringMvcAutoConfiguration {

    @Autowired
    private OpenTracingSpringMvcProperties openTracingSpringProperties;

    @Configuration
    @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
    public class SpringMvcDelegatingFilterProxyConfiguration {
        @Bean
        public FilterRegistrationBean springMvcDelegatingFilterProxy() {
            FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();
            SpringMvcSofaTracerFilter filter = new SpringMvcSofaTracerFilter();
            filterRegistrationBean.setFilter(filter);
            List&amp;lt;String&amp;gt; urlPatterns = openTracingSpringProperties.getUrlPatterns();
            if (urlPatterns == null || urlPatterns.size() &amp;lt;= 0) {
                filterRegistrationBean.addUrlPatterns(&quot;/*&quot;);
            } else {
                filterRegistrationBean.setUrlPatterns(urlPatterns);
            }
            filterRegistrationBean.setName(filter.getFilterName());
            filterRegistrationBean.setAsyncSupported(true);
            filterRegistrationBean.setOrder(openTracingSpringProperties.getFilterOrder());
            return filterRegistrationBean;
        }
    }

    @Configuration
    @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
    public class WebfluxSofaTracerFilterConfiguration {
        @Bean
        @Order(Ordered.HIGHEST_PRECEDENCE + 10)
        public WebFilter webfluxSofaTracerFilter() {
            return new WebfluxSofaTracerFilter();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x07-sofatracer-的插件埋点机制&quot;&gt;0x07 SOFATracer 的插件埋点机制&lt;/h2&gt;
&lt;p&gt;对一个应用的跟踪要关注的无非就是 &lt;code&gt;客户端---&amp;gt;web 层---&amp;gt;rpc 服务---&amp;gt;dao 后端存储、cache 缓存、消息队列 mq 等这些基础组件&lt;/code&gt;。SOFATracer 插件的作用实际上也就是对不同组件进行埋点，以便基于这些组件采集应用的链路数据。&lt;/p&gt;
&lt;p&gt;不同组件有不同的应用场景和扩展点，因此对插件的实现也要因地制宜，SOFATracer 埋点方式一般是通过 Filter、Interceptor 机制实现的。&lt;/p&gt;
&lt;h3 id=&quot;71-组件扩展入口之-filter-or-interceptor&quot;&gt;7.1 组件扩展入口之 Filter or Interceptor&lt;/h3&gt;
&lt;p&gt;SOFATracer 目前已实现的插件中，像 SpringMVC 插件是基于 Filter 进行埋点的，httpclient、resttemplate 等是基于 Interceptor 机制进行埋点的。在实现插件时，要根据不同插件的特性和扩展点来选择具体的埋点方式。正所谓条条大路通罗马，不管怎么实现埋点，都是依赖 SOFATracer 自身 API 的扩展机制来实现。&lt;/p&gt;
&lt;p&gt;SOFATracer 中所有的插件均需要实现自己的 Tracer 实例，如 SpringMVC 的 SpringMvcTracer 、HttpClient 的 HttpClientTracer 等。&lt;/p&gt;
&lt;p&gt;AbstractTracer 是 SOFATracer 用于插件扩展使用的一个抽象类，根据插件类型不同，又可以分为 clientTracer 和 serverTracer，分别对应于 AbstractClientTracer 和 AbstractServerTracer；再通过 AbstractClientTracer 和 AbstractServerTracer 衍生出具体的组件 Tracer 实现，比如上图中提到的 HttpClientTracer 、RestTemplateTracer 、SpringMvcTracer 等插件 Tracer 实现。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;如何确定一个组件是 client 端还是 server 端呢？就是看当前组件是请求的发起方还是请求的接受方&lt;/u&gt;，如果是请求发起方则一般是 client 端，如果是请求接收方则是 server 端。那么对于 RPC 来说，即是请求的发起方也是请求的接受方，因此这里实现了 AbstractTracer 类。&lt;/p&gt;
&lt;h3 id=&quot;72-插件扩展基本思路总结&quot;&gt;7.2 插件扩展基本思路总结&lt;/h3&gt;
&lt;p&gt;对于一个组件来说，一次处理过程一般是产生一个 Span；这个 Span 的生命周期是从接收到请求到返回响应这段过程。&lt;/p&gt;
&lt;p&gt;但是这里需要考虑的问题是如何与上下游链路关联起来呢？在 Opentracing 规范中，可以在 Tracer 中 extract 出一个跨进程传递的 SpanContext 。然后通过这个 SpanContext 所携带的信息将当前节点关联到整个 Tracer 链路中去，当然有提取（extract）就会有对应的注入（inject）。&lt;/p&gt;
&lt;p&gt;链路的构建一般是 client------server------client------server 这种模式的，那这里就很清楚了，就是会在 client 端进行注入（inject），然后再 server 端进行提取（extract），反复进行，然后一直传递下去。&lt;/p&gt;
&lt;p&gt;在拿到 SpanContext 之后，此时当前的 Span 就可以关联到这条链路中了，那么剩余的事情就是收集当前组件的一些数据；整个过程大概分为以下几个阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从请求中提取 spanContext&lt;/li&gt;
&lt;li&gt;构建 Span，并将当前 Span 存入当前 tracer上下文中（SofaTraceContext.push(Span)） 。&lt;/li&gt;
&lt;li&gt;设置一些信息到 Span 中&lt;/li&gt;
&lt;li&gt;返回响应&lt;/li&gt;
&lt;li&gt;Span 结束&amp;amp;上报&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;73-标准-servlet-规范埋点原理&quot;&gt;7.3 标准 Servlet 规范埋点原理&lt;/h3&gt;
&lt;p&gt;SOFATracer 支持对标准 Servlet 规范的 Web MVC 埋点，包括普通的 Servlet 和 Spring MVC 等，基本原理就是基于 Servelt 规范所提供的 javax.servlet.Filter 过滤器接口扩展实现。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;过滤器位于 Client 和 Web 应用程序之间，用于检查和修改两者之间流过的请求和响应信息。在请求到达 Servlet 之前，过滤器截获请求。在响应送给客户端之前，过滤器截获响应。多个过滤器形成一个 FilterChain，FilterChain 中不同过滤器的先后顺序由部署文件 web.xml 中过滤器映射的顺序决定。最先截获客户端请求的过滤器将最后截获 Servlet 的响应信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Web 应用程序一般作为请求的接收方，在 SOFATracer 中应用是作为 Server 存在的，其在解析 SpanContext 时所对应的事件为 sr (server receive)。&lt;/p&gt;
&lt;p&gt;SOFATracer 在 sofa-tracer-springmvc-plugin 插件中解析及产生 Span 的过程大致如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Servlet Filter 拦截到 request 请求；&lt;/li&gt;
&lt;li&gt;从请求中解析 SpanContext；&lt;/li&gt;
&lt;li&gt;通过 SpanContext 构建当前 MVC 的 Span；&lt;/li&gt;
&lt;li&gt;给当前 Span 设置 tag、log；&lt;/li&gt;
&lt;li&gt;在 Filter 处理的最后，结束 Span；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;74-http-客户端埋点原理&quot;&gt;7.4 HTTP 客户端埋点原理&lt;/h3&gt;
&lt;p&gt;HTTP 客户端埋点包括 HttpClient、OkHttp、RestTemplate 等，此类埋点一般都是基于拦截器机制来实现的，如 HttpClient 使用的 HttpRequestInterceptor、HttpResponseInterceptor；OkHttp 使用的 okhttp3.Interceptor；RestTemplate 使用的 ClientHttpRequestInterceptor。&lt;/p&gt;
&lt;p&gt;以 OkHttp 为例，简单分析下 HTTP 客户端埋点的实现原理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public Response intercept(Chain chain) throws IOException {
    // 获取请求
    Request request = chain.request();
    // 解析出 SpanContext ，然后构建 Span
    SofaTracerSpan sofaTracerSpan = okHttpTracer.clientSend(request.method());
    // 发起具体的调用
    Response response = chain.proceed(appendOkHttpRequestSpanTags(request, sofaTracerSpan));
    // 结束 span
    okHttpTracer.clientReceive(String.valueOf(response.code()));
    return response;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x08-请求总体过程&quot;&gt;0x08 请求总体过程&lt;/h2&gt;
&lt;p&gt;在 SOFATracer 中将请求大致分为以下几个过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端发送请求 clientSend cs&lt;/li&gt;
&lt;li&gt;服务端接受请求 serverReceive sr&lt;/li&gt;
&lt;li&gt;服务端返回结果 serverSend ss&lt;/li&gt;
&lt;li&gt;客户端接受结果 clientReceive cr&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;无论是哪个插件，在请求处理周期内都可以从上述几个阶段中找到对应的处理方法。因此，SOFATracer 对这几个阶段处理进行了封装。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;在SOFA这里，四个阶段实际上会产生两个 Span&lt;/u&gt;，第一个 Span 的起点是 cs，到 cr 结束；第二个 Span 是从 sr 开始，到 ss 结束。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;clientSend // 客户端发送请求，也就是 cs 阶段，会产生一个 Span。
    serverReceive // 服务端接收请求 sr 阶段，产生了一个 Span 。
    ...
    serverSend
clientReceive   
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从时间序列上看，如下图所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;     Client                             Server

+--------------+     Request        +--------------+
| Client Send  | +----------------&amp;gt; |Server Receive|
+------+-------+                    +------+-------+
       |                                   |
       |                                   v
       |                            +------+--------+
       |                            |Server Business|
       |                            +------+--------+
       |                                   |
       |                                   |
       v                                   v
+------+--------+    Response       +------+-------+
|Client Receive | &amp;lt;---------------+ |Server Send   |
+------+--------+                   +------+-------+
       |                                   |
       |                                   |
       v                                   v
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;81-traceid&quot;&gt;8.1 TraceID&lt;/h3&gt;
&lt;p&gt;产生trace ID 是在 客户端发送请求 clientSend cs 这个阶段，即，此 ID 一般由集群中第一个处理请求的系统产生，并在分布式调用下通过网络传递到下一个被请求系统。就是 AbstractTracer # clientSend 函数。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;调用 buildSpan 构建一个 SofaTracerSpan clientSpan，然后调用 start 函数建立一个 Span。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对 clientSpan 设置各种 Tag。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对 clientSpan 设置 log。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;把 clientSpan 设置进入SpanContext.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体产生traceId 的代码是在类 TraceIdGenerator 中。可以看到，TraceId 是由 ip，时间戳，递增序列，进程ID等构成，即traceId为服务器 IP + 产生 ID 时候的时间 + 自增序列 + 当前进程号，以此保证全局唯一性。这就回答了我们之前提过的问题：&lt;u&gt;traceId是怎么生成的，有什么规则？&lt;/u&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TraceIdGenerator {
    private static String IP_16 = &quot;ffffffff&quot;;
    private static AtomicInteger count = new AtomicInteger(1000);

    private static String getTraceId(String ip, long timestamp, int nextId) {
        StringBuilder appender = new StringBuilder(30);
        appender.append(ip).append(timestamp).append(nextId).append(TracerUtils.getPID());
        return appender.toString();
    }

    public static String generate() {
        return getTraceId(IP_16, System.currentTimeMillis(), getNextId());
    }

    private static String getIP_16(String ip) {
        String[] ips = ip.split(&quot;\\.&quot;);
        StringBuilder sb = new StringBuilder();
        String[] var3 = ips;
        int var4 = ips.length;

        for(int var5 = 0; var5 &amp;lt; var4; ++var5) {
            String column = var3[var5];
            String hex = Integer.toHexString(Integer.parseInt(column));
            if (hex.length() == 1) {
                sb.append('0').append(hex);
            } else {
                sb.append(hex);
            }
        }

        return sb.toString();
    }

    private static int getNextId() {
        int current;
        int next;
        do {
            current = count.get();
            next = current &amp;gt; 9000 ? 1000 : current + 1;
        } while(!count.compareAndSet(current, next));

        return next;
    }

    static {
        try {
            String ipAddress = TracerUtils.getInetAddress();
            if (ipAddress != null) {
                IP_16 = getIP_16(ipAddress);
            }
        } catch (Throwable var1) {
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;82-spanid&quot;&gt;8.2 SpanID&lt;/h3&gt;
&lt;p&gt;&lt;u&gt;有两个地方会生成SpanId : CS, SR&lt;/u&gt;。SOFARPC 和 Dapper不同，&lt;u&gt;spanId中已经包含了调用链上下文关系&lt;/u&gt;，包含parent spanId 的信息。比如 系统在处理一个请求的过程中依次调用了 B，C，D 三个系统，那么这三次调用的的 SpanId 分别是：0.1，0.2，0.3。如果 C 系统继续调用了 E，F 两个系统，那么这两次调用的 SpanId 分别是：0.2.1，0.2.2。&lt;/p&gt;
&lt;h4 id=&quot;821-client-send&quot;&gt;8.2.1 Client Send&lt;/h4&gt;
&lt;p&gt;接上面小节，在客户端发送请求 clientSend cs 这个阶段，就会构建Span，从而生成 SpanID。&lt;/p&gt;
&lt;h4 id=&quot;822-server-receive&quot;&gt;8.2.2 Server Receive&lt;/h4&gt;
&lt;p&gt;我们再以 Server Receive这个动作为例，可以看到在Server端 的 Span构建过程。&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SpringMvcSofaTracerFilter # doFilter 会从 Header 中提取 SofaTracerSpanContext。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用 SofaTracer # extract 提取SofaTracerSpanContext，这里用到了 SpringMvcHeadersCarrier。
&lt;ul&gt;&lt;li&gt;利用 RegistryExtractorInjector # extract 从 SpringMvcHeadersCarrier 中提取 SpanContext。
&lt;ul&gt;&lt;li&gt;利用 AbstractTextB3Formatter # extract 从 SpringMvcHeadersCarrier 中提取 SpanContext。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;AbstractTracer # serverReceive 会根据 SofaTracerSpanContext 进行后续操作，此时 SofaTracerSpanContext 如下：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;sofaTracerSpanContext = {SofaTracerSpanContext@6056} &quot;SofaTracerSpanContext{traceId='c0a80103159927161709310013925', spanId='0', parentId='', isSampled=true, bizBaggage={}, sysBaggage={}, childContextIndex=0}&quot;
 traceId = &quot;c0a80103159927161709310013925&quot;
 spanId = &quot;0&quot;
 parentId = &quot;&quot;
 isSampled = true
 sysBaggage = {ConcurrentHashMap@6060}  size = 0
 bizBaggage = {ConcurrentHashMap@6061}  size = 0
 childContextIndex = {AtomicInteger@6062} &quot;0&quot;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;从当前线程取出当前的SpanContext，然后提取serverSpan，此 serverSpan 可能为null，也可能有值。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;SofaTraceContext sofaTraceContext = SofaTraceContextHolder.getSofaTraceContext();
SofaTracerSpan serverSpan = sofaTraceContext.pop();
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果serverSpan为null，则生成一个新的 newSpan，然后调用 &lt;u&gt;&lt;strong&gt;setSpanId&lt;/strong&gt;&lt;/u&gt; 对传入的 SofaTracerSpanContext 参数进行设置新的 SpanId&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果serverSpan 不为 null，则 newSpan = serverSpan&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置log&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置Tag&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;把 newSpan 设置进入本地上下文。&lt;code&gt;sofaTraceContext.push(newSpan);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意，&lt;u&gt;&lt;strong&gt;在链路的后续环节中，traceId 和 spanId 都是存储在本地线程的 sofaTracerSpanContext 之中，不是在 Span 之中&lt;/strong&gt;&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;p&gt;首先，SpringMvcSofaTracerFilter # doFilter 会从 Header 中提取 SofaTracerSpanContext&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SpringMvcSofaTracerFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse,
                         FilterChain filterChain) {
            // 从header中提取Context
            SofaTracerSpanContext spanContext = getSpanContextFromRequest(request);
            // sr
            springMvcSpan = springMvcTracer.serverReceive(spanContext);      
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次，AbstractTracer # serverReceive 会根据 SofaTracerSpanContext 进行后续操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class AbstractTracer {
    public SofaTracerSpan serverReceive(SofaTracerSpanContext sofaTracerSpanContext) {
        SofaTracerSpan newSpan = null;
        SofaTraceContext sofaTraceContext = SofaTraceContextHolder.getSofaTraceContext();
        SofaTracerSpan serverSpan = sofaTraceContext.pop();
        try {
            if (serverSpan == null) {
                if (sofaTracerSpanContext == null) {
                    sofaTracerSpanContext = SofaTracerSpanContext.rootStart();
                    isCalculateSampled = true;
                } else {                                        
                sofaTracerSpanContext.setSpanId(sofaTracerSpanContext.nextChildContextId());
                }
                newSpan = this.genSeverSpanInstance(System.currentTimeMillis(),
                    StringUtils.EMPTY_STRING, sofaTracerSpanContext, null);
            } else {
                newSpan = serverSpan;
            }
        } 
    }    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，SpanID的构建规则相对简单，这就回答了我们之前提过的问题：&lt;u&gt;spanId是怎么生成的，有什么规则?&lt;/u&gt; 以及 &lt;u&gt;ParentSpan 从哪儿来？&lt;/u&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SofaTracerSpanContext implements SpanContext {
  private AtomicInteger childContextIndex = new AtomicInteger(0);

  public String nextChildContextId() {
    return this.spanId + RPC_ID_SEPARATOR + childContextIndex.incrementAndGet();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x09-client-发送&quot;&gt;0x09 Client 发送&lt;/h2&gt;
&lt;p&gt;本节我们看看RestTemplate是如何发送请求的。&lt;/p&gt;
&lt;p&gt;首先，打印出程序运行时候的Stack如下，这样大家可以先有一个大致的印象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;intercept:56, RestTemplateInterceptor (com.sofa.alipay.tracer.plugins.rest.interceptor)
execute:92, InterceptingClientHttpRequest$InterceptingRequestExecution (org.springframework.http.client)
executeInternal:76, InterceptingClientHttpRequest (org.springframework.http.client)
executeInternal:48, AbstractBufferingClientHttpRequest (org.springframework.http.client)
execute:53, AbstractClientHttpRequest (org.springframework.http.client)
doExecute:734, RestTemplate (org.springframework.web.client)
execute:669, RestTemplate (org.springframework.web.client)
getForEntity:337, RestTemplate (org.springframework.web.client)
main:40, RestTemplateDemoApplication (com.alipay.sofa.tracer.examples.rest)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 InterceptingClientHttpRequest # execute 此处代码中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class InterceptingClientHttpRequest extends AbstractBufferingClientHttpRequest {
    @Override
                public ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException {
                        if (this.iterator.hasNext()) {
                                ClientHttpRequestInterceptor nextInterceptor = this.iterator.next();
                                return nextInterceptor.intercept(request, body, this); // 这里进行拦截处理
                        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后是来到了 SOFA 的拦截器中，这里会做处理。&lt;/p&gt;
&lt;h3 id=&quot;91-生成span&quot;&gt;9.1 生成Span&lt;/h3&gt;
&lt;p&gt;具体实现代码是在 RestTemplateInterceptor # intercept函数。&lt;/p&gt;
&lt;p&gt;我们可以看到，RestTemplateInterceptor这里有一个成员变量 restTemplateTracer，具体处理就是在 restTemplateTracer 这里实现。可以看到这里包含了 clientSend 和 clientReceive 两个过程。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先生成一个Span。SofaTracerSpan sofaTracerSpan = restTemplateTracer.&lt;strong&gt;clientSend&lt;/strong&gt;(request.getMethod().name());&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;先从 SofaTraceContext 取出 serverSpan。如果本 client 就是 一个服务中间点（即 serverSpan 不为空），那么需要给新span设置父亲Span。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;调用 &lt;code&gt;clientSpan = (SofaTracerSpan)this.sofaTracer.buildSpan(operationName).asChildOf(serverSpan).start();&lt;/code&gt; 得到本身的 client Span。如果有 server Span，则本 Client Span 就是 Sever Span的 child。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设置父亲 &lt;code&gt;clientSpan.setParentSofaTracerSpan(serverSpan);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;然后调用 appendRestTemplateRequestSpanTags 来把Span放入Request的Header中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;给Span加入各种Tag，比如 app, url, method...&lt;/li&gt;
&lt;li&gt;进行Carrier处理&lt;code&gt;，injectCarrier(request, sofaTracerSpan);&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;调用 AbstractTextB3Formatter.inject 设置 traceId, spanId, parentId ....&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发送请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;u&gt;收到&lt;strong&gt;服务器返回&lt;/strong&gt;之后&lt;/u&gt;进一步处理。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从ThreadLocal中获取 sofaTraceContext&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从 SofaTracerSpan 中获取 currentSpan&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调用 appendRestTemplateResponseSpanTags 设置各种 Tag&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调用 restTemplateTracer.&lt;strong&gt;clientReceive&lt;/strong&gt;(resultCode); 处理&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;clientSpan = sofaTraceContext.pop(); 把之前的Span移除
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调用 clientReceiveTagFinish ，进而调用 clientSpan.finish();&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用 &lt;code&gt;SpanTracer.reportSpan&lt;/code&gt; 进行 Span 上报，其中Reporter 数据上报 reportSpan 或者链路跨度 SofaTracerSpan 启动调用采样器 sample 方法检查链路是否需要采样，获取采样状态 SamplingStatus 是否采样标识 isSampled。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果还有父亲Span，则需要再push 父亲 Span进入Context。&lt;code&gt;sofaTraceContext.push(clientSpan.getParentSofaTracerSpan());&lt;/code&gt; 以备后续处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RestTemplateInterceptor implements ClientHttpRequestInterceptor {

    protected AbstractTracer restTemplateTracer; // Sofa内部逻辑实现

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body,
                                        ClientHttpRequestExecution execution) throws IOException {
        SofaTracerSpan sofaTracerSpan = restTemplateTracer.clientSend(request.getMethod().name()); // 生成Span
        appendRestTemplateRequestSpanTags(request, sofaTracerSpan); //放入Header
        ClientHttpResponse response = null;
        Throwable t = null;
        try {
            return response = execution.execute(request, body); //发送请求
        } catch (IOException e) {
            t = e;
            throw e;
        } finally {
            SofaTraceContext sofaTraceContext = SofaTraceContextHolder.getSofaTraceContext();
            SofaTracerSpan currentSpan = sofaTraceContext.getCurrentSpan();
            String resultCode = SofaTracerConstant.RESULT_CODE_ERROR;
            // is get error
            if (t != null) {
                currentSpan.setTag(Tags.ERROR.getKey(), t.getMessage());
                // current thread name
                sofaTracerSpan.setTag(CommonSpanTags.CURRENT_THREAD_NAME, Thread.currentThread()
                    .getName());
            }
            if (response != null) {
                //tag append
                appendRestTemplateResponseSpanTags(response, currentSpan);
                //finish
                resultCode = String.valueOf(response.getStatusCode().value());
            }
            restTemplateTracer.clientReceive(resultCode);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;92-fomatter&quot;&gt;9.2 Fomatter&lt;/h3&gt;
&lt;p&gt;上文提到了发送时候会调用 AbstractTextB3Formatter.inject 设置 traceId, spanId, parentId。&lt;/p&gt;
&lt;p&gt;Fomatter 这个接口负责了具体场景中序列化/反序列化&lt;strong&gt;上下文&lt;/strong&gt;的具体逻辑，例如在HttpCarrier使用中通常就会有一个对应的HttpFormatter。Tracer的注入和提取就是委托给了Formatter。&lt;/p&gt;
&lt;p&gt;执行时候堆栈如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;inject:141, AbstractTextB3Formatter (com.alipay.common.tracer.core.registry)
inject:26, AbstractTextB3Formatter (com.alipay.common.tracer.core.registry)
inject:115, SofaTracer (com.alipay.common.tracer.core)
injectCarrier:146, RestTemplateInterceptor (com.sofa.alipay.tracer.plugins.rest.interceptor)
appendRestTemplateRequestSpanTags:141, RestTemplateInterceptor (com.sofa.alipay.tracer.plugins.rest.interceptor)
intercept:57, RestTemplateInterceptor (com.sofa.alipay.tracer.plugins.rest.interceptor)
execute:92, InterceptingClientHttpRequest$InterceptingRequestExecution (org.springframework.http.client)
executeInternal:76, InterceptingClientHttpRequest (org.springframework.http.client)
executeInternal:48, AbstractBufferingClientHttpRequest (org.springframework.http.client)
execute:53, AbstractClientHttpRequest (org.springframework.http.client)
doExecute:734, RestTemplate (org.springframework.web.client)
execute:669, RestTemplate (org.springframework.web.client)
getForEntity:337, RestTemplate (org.springframework.web.client)
main:40, RestTemplateDemoApplication (com.alipay.sofa.tracer.examples.rest)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OpenTracing提供了两个处理“跟踪上下文(trace context)”的函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“extract(format，carrier)”从媒介（通常是HTTP头）获取跟踪上下文。&lt;/li&gt;
&lt;li&gt;“inject(SpanContext，format，carrier)” 将跟踪上下文放入媒介，来保证跟踪链的连续性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;u&gt;Inject 和 extract 分别对应了序列化 和 反序列化&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class AbstractTextB3Formatter implements RegistryExtractorInjector&amp;lt;TextMap&amp;gt; {
    public static final String TRACE_ID_KEY_HEAD = &quot;X-B3-TraceId&quot;;
    public static final String SPAN_ID_KEY_HEAD = &quot;X-B3-SpanId&quot;;
    public static final String PARENT_SPAN_ID_KEY_HEAD = &quot;X-B3-ParentSpanId&quot;;
    public static final String SAMPLED_KEY_HEAD = &quot;X-B3-Sampled&quot;;
    static final String FLAGS_KEY_HEAD = &quot;X-B3-Flags&quot;;
    static final String BAGGAGE_KEY_PREFIX = &quot;baggage-&quot;;
    static final String BAGGAGE_SYS_KEY_PREFIX = &quot;baggage-sys-&quot;;

    public SofaTracerSpanContext extract(TextMap carrier) {
        if (carrier == null) {
            return SofaTracerSpanContext.rootStart();
        } else {
            String traceId = null;
            String spanId = null;
            String parentId = null;
            boolean sampled = false;
            boolean isGetSampled = false;
            Map&amp;lt;String, String&amp;gt; sysBaggage = new ConcurrentHashMap();
            Map&amp;lt;String, String&amp;gt; bizBaggage = new ConcurrentHashMap();
            Iterator var9 = carrier.iterator();

            while(var9.hasNext()) {
                Entry&amp;lt;String, String&amp;gt; entry = (Entry)var9.next();
                String key = (String)entry.getKey();
                if (!StringUtils.isBlank(key)) {
                    if (traceId == null &amp;amp;&amp;amp; &quot;X-B3-TraceId&quot;.equalsIgnoreCase(key)) {
                        traceId = this.decodedValue((String)entry.getValue());
                    }

                    if (spanId == null &amp;amp;&amp;amp; &quot;X-B3-SpanId&quot;.equalsIgnoreCase(key)) {
                        spanId = this.decodedValue((String)entry.getValue());
                    }

                    if (parentId == null &amp;amp;&amp;amp; &quot;X-B3-ParentSpanId&quot;.equalsIgnoreCase(key)) {
                        parentId = this.decodedValue((String)entry.getValue());
                    }

                    String keyTmp;
                    if (!isGetSampled &amp;amp;&amp;amp; &quot;X-B3-Sampled&quot;.equalsIgnoreCase(key)) {
                        keyTmp = this.decodedValue((String)entry.getValue());
                        if (&quot;1&quot;.equals(keyTmp)) {
                            sampled = true;
                        } else if (&quot;0&quot;.equals(keyTmp)) {
                            sampled = false;
                        } else {
                            sampled = Boolean.parseBoolean(keyTmp);
                        }

                        isGetSampled = true;
                    }

                    String valueTmp;
                    if (key.indexOf(&quot;baggage-sys-&quot;) == 0) {
                        keyTmp = StringUtils.unescapeEqualAndPercent(key).substring(&quot;baggage-sys-&quot;.length());
                        valueTmp = StringUtils.unescapeEqualAndPercent(this.decodedValue((String)entry.getValue()));
                        sysBaggage.put(keyTmp, valueTmp);
                    }

                    if (key.indexOf(&quot;baggage-&quot;) == 0) {
                        keyTmp = StringUtils.unescapeEqualAndPercent(key).substring(&quot;baggage-&quot;.length());
                        valueTmp = StringUtils.unescapeEqualAndPercent(this.decodedValue((String)entry.getValue()));
                        bizBaggage.put(keyTmp, valueTmp);
                    }
                }
            }

            if (traceId == null) {
                return SofaTracerSpanContext.rootStart();
            } else {
                if (spanId == null) {
                    spanId = &quot;0&quot;;
                }

                if (parentId == null) {
                    parentId = &quot;&quot;;
                }

                SofaTracerSpanContext sofaTracerSpanContext = new SofaTracerSpanContext(traceId, spanId, parentId, sampled);
                if (sysBaggage.size() &amp;gt; 0) {
                    sofaTracerSpanContext.addSysBaggage(sysBaggage);
                }

                if (bizBaggage.size() &amp;gt; 0) {
                    sofaTracerSpanContext.addBizBaggage(bizBaggage);
                }

                return sofaTracerSpanContext;
            }
        }
    }

    public void inject(SofaTracerSpanContext spanContext, TextMap carrier) {
        if (carrier != null &amp;amp;&amp;amp; spanContext != null) {
            carrier.put(&quot;X-B3-TraceId&quot;, this.encodedValue(spanContext.getTraceId()));
            carrier.put(&quot;X-B3-SpanId&quot;, this.encodedValue(spanContext.getSpanId()));
            carrier.put(&quot;X-B3-ParentSpanId&quot;, this.encodedValue(spanContext.getParentId()));
            carrier.put(&quot;X-B3-SpanId&quot;, this.encodedValue(spanContext.getSpanId()));
            carrier.put(&quot;X-B3-Sampled&quot;, this.encodedValue(String.valueOf(spanContext.isSampled())));
            Iterator var3 = spanContext.getSysBaggage().entrySet().iterator();

            Entry entry;
            String key;
            String value;
            while(var3.hasNext()) {
                entry = (Entry)var3.next();
                key = &quot;baggage-sys-&quot; + StringUtils.escapePercentEqualAnd((String)entry.getKey());
                value = this.encodedValue(StringUtils.escapePercentEqualAnd((String)entry.getValue()));
                carrier.put(key, value);
            }

            var3 = spanContext.getBizBaggage().entrySet().iterator();

            while(var3.hasNext()) {
                entry = (Entry)var3.next();
                key = &quot;baggage-&quot; + StringUtils.escapePercentEqualAnd((String)entry.getKey());
                value = this.encodedValue(StringUtils.escapePercentEqualAnd((String)entry.getValue()));
                carrier.put(key, value);
            }

        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过序列化之后，最后发送的Header如下，我们需要回忆下 spanContext 的概念。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;u&gt;上下文存储的是一些需要跨越边界的一些信息&lt;/u&gt;，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spanId ：当前这个span的id&lt;/li&gt;
&lt;li&gt;traceId ：这个span所属的traceId(也就是这次调用链的唯一id)。
&lt;ul&gt;&lt;li&gt;&lt;code&gt;trace_id&lt;/code&gt;和 &lt;code&gt;span_id&lt;/code&gt; 用以区分&lt;code&gt;Trace&lt;/code&gt;中的&lt;code&gt;Span&lt;/code&gt;；任何 OpenTraceing 实现相关的状态(比如 trace 和 span id）都需要被一个跨进程的 &lt;strong&gt;Span&lt;/strong&gt; 所联系。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;baggage ：其他的能过跨越多个调用单元的信息，即跨进程的 key value 对。&lt;code&gt;Baggage Items&lt;/code&gt; 和 &lt;code&gt;Span Tag&lt;/code&gt; 结构相同，唯一的区别是：&lt;code&gt;Span Tag&lt;/code&gt;只在当前&lt;code&gt;Span&lt;/code&gt;中存在，并不在整个&lt;code&gt;trace&lt;/code&gt;中传递，而&lt;code&gt;Baggage Items&lt;/code&gt; 会随调用链传递。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;可以看到，&lt;u&gt;spanContext 已经被分解并且序列化到 Header 之中&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;request = {InterceptingClientHttpRequest@5808} 
 requestFactory = {SimpleClientHttpRequestFactory@5922} 
 interceptors = {ArrayList@5923}  size = 1
 method = {HttpMethod@5924} &quot;GET&quot;
 uri = {URI@5925} &quot;http://localhost:8801/rest&quot;
 bufferedOutput = {ByteArrayOutputStream@5926} &quot;&quot;
 headers = {HttpHeaders@5918}  size = 6
  &quot;Accept&quot; -&amp;gt; {LinkedList@5938}  size = 1
  &quot;Content-Length&quot; -&amp;gt; {LinkedList@5940}  size = 1
  &quot;X-B3-TraceId&quot; -&amp;gt; {LinkedList@5942}  size = 1
   key = &quot;X-B3-TraceId&quot;
   value = {LinkedList@5942}  size = 1
    0 = &quot;c0a800031598690915258100115720&quot;
  &quot;X-B3-SpanId&quot; -&amp;gt; {LinkedList@5944}  size = 2
   key = &quot;X-B3-SpanId&quot;
   value = {LinkedList@5944}  size = 2
    0 = &quot;0&quot;
    1 = &quot;0&quot;
  &quot;X-B3-ParentSpanId&quot; -&amp;gt; {LinkedList@5946}  size = 1
  &quot;X-B3-Sampled&quot; -&amp;gt; {LinkedList@5948}  size = 1
 executed = false
body = {byte[0]@5810} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;93-report&quot;&gt;9.3 Report&lt;/h3&gt;
&lt;p&gt;发送的最后一步是 clientSpan.finish()。&lt;/p&gt;
&lt;p&gt;在 Opentracing 规范中提到，Span#finish 方法是 span 生命周期的最后一个执行方法，也就意味着一个 span 跨度即将结束。那么当一个 span 即将结束时，也是当前 span 具有最完整状态的时候。所以在 SOFATracer 中，数据上报的入口就是 Span#finish 方法，其调用堆栈如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;doReportStat:43, RestTemplateStatJsonReporter (com.sofa.alipay.tracer.plugins.rest)
reportStat:179, AbstractSofaTracerStatisticReporter (com.alipay.common.tracer.core.reporter.stat)
statisticReport:143, DiskReporterImpl (com.alipay.common.tracer.core.reporter.digest)
doReport:60, AbstractDiskReporter (com.alipay.common.tracer.core.reporter.digest)
report:51, AbstractReporter (com.alipay.common.tracer.core.reporter.facade)
reportSpan:141, SofaTracer (com.alipay.common.tracer.core)
finish:165, SofaTracerSpan (com.alipay.common.tracer.core.span)
finish:158, SofaTracerSpan (com.alipay.common.tracer.core.span)
clientReceiveTagFinish:176, AbstractTracer (com.alipay.common.tracer.core.tracer)
clientReceive:157, AbstractTracer (com.alipay.common.tracer.core.tracer)
intercept:82, RestTemplateInterceptor (com.sofa.alipay.tracer.plugins.rest.interceptor)
execute:92, InterceptingClientHttpRequest$InterceptingRequestExecution (org.springframework.http.client)
executeInternal:76, InterceptingClientHttpRequest (org.springframework.http.client)
executeInternal:48, AbstractBufferingClientHttpRequest (org.springframework.http.client)
execute:53, AbstractClientHttpRequest (org.springframework.http.client)
doExecute:734, RestTemplate (org.springframework.web.client)
execute:669, RestTemplate (org.springframework.web.client)
getForEntity:337, RestTemplate (org.springframework.web.client)
main:40, RestTemplateDemoApplication (com.alipay.sofa.tracer.examples.rest)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SOFATracer 本身提供了两种上报模式，一种是落到磁盘，另外一种是上报到zipkin。在实现细节上，SOFATracer 没有将这两种策略分开以提供独立的功能支持，而是将两种上报方式组合在了一起，并且在执行具体上报的流程中通过参数来调控是否执行具体的上报。&lt;/p&gt;
&lt;p&gt;此过程中涉及到了三个上报点，首先是上报到 &lt;code&gt;zipkin&lt;/code&gt;，后面是落盘；在日志记录方面，&lt;code&gt;SOFATracer&lt;/code&gt; 中为不同的组件均提供了独立的日志空间，除此之外，&lt;code&gt;SOFATracer&lt;/code&gt; 在链路数据采集时提供了两种不同的日志记录模式：摘要日志和统计日志，这对于后续构建一些如故障的快速发现、服务治理等管控端提供了强大的数据支撑。。&lt;/p&gt;
&lt;p&gt;比如 zipkin 对应上报是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ZipkinSofaTracerSpanRemoteReporter implements SpanReportListener, Flushable, Closeable {
    public void onSpanReport(SofaTracerSpan span) {
        //convert
        Span zipkinSpan = zipkinV2SpanAdapter.convertToZipkinSpan(span);
        this.delegate.report(zipkinSpan);
    }  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其会调用到 zipkin2.reporter.AsyncReporter 进行具体 report。&lt;/p&gt;
&lt;h3 id=&quot;94-采样计算&quot;&gt;9.4 采样计算&lt;/h3&gt;
&lt;p&gt;采样是对于整条链路来说的，也就是说从 RootSpan 被创建开始，就已经决定了当前链路数据是否会被记录了。在 SofaTracer 类中，Sapmler 实例作为成员变量存在，并且被设置为 final，也就是当构建好 SofaTracer 实例之后，采样策略就不会被改变。当 Sampler 采样器绑定到 SofaTracer 实例之后，SofaTracer 对于产生的 Span 数据的落盘行为都会依赖采样器的计算结果（针对某一条链路而言）。&lt;/p&gt;
&lt;h2 id=&quot;0x10-服务端接收&quot;&gt;0x10 服务端接收&lt;/h2&gt;
&lt;p&gt;类 SpringMvcSofaTracerFilter 完成了服务端接收相关工作。主要就是设置 SpanContext 和 Span。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SpringMvcSofaTracerFilter implements Filter {
    private SpringMvcTracer springMvcTracer;
   
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse,
                         FilterChain filterChain) {
       ......
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回忆下：在 client 端就是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将当前请求线程的产生的 traceId 相关信息 Inject 到 SpanContext。&lt;/li&gt;
&lt;li&gt;然后通过 Fomatter 将 SpanContext序列化到Header之中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;server 端则是 从请求的 Header 中 extract 出 spanContext，来还原本次请求线程的上下文。因为上下文是和所处理的线程相关，放入 ThreadLocal中。&lt;/p&gt;
&lt;p&gt;大致可以用如下图演示总体流程如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;   Client Span                                                Server Span
┌──────────────────┐                                       ┌──────────────────┐
│                  │                                       │                  │
│   TraceContext   │           Http Request Headers        │   TraceContext   │
│ ┌──────────────┐ │          ┌───────────────────┐        │ ┌──────────────┐ │
│ │ TraceId      │ │          │ X-B3-TraceId      │        │ │ TraceId      │ │
│ │              │ │          │                   │        │ │              │ │
│ │ ParentSpanId │ │ Inject   │ X-B3-ParentSpanId │Extract │ │ ParentSpanId │ │
│ │              ├─┼─────────&amp;gt;│                   ├────────┼&amp;gt;│              │ │
│ │ SpanId       │ │          │ X-B3-SpanId       │        │ │ SpanId       │ │
│ │              │ │          │                   │        │ │              │ │
│ │ Sampled      │ │          │ X-B3-Sampled      │        │ │ Sampled      │ │
│ └──────────────┘ │          └───────────────────┘        │ └──────────────┘ │
│                  │                                       │                  │
└──────────────────┘                                       └──────────────────┘
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就回答了之前的问题：&lt;u&gt;服务器接收到请求之后做什么？SpanContext在服务器端怎么处理？&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;SpringMvcSofaTracerFilter 这里有一个成员变量 SpringMvcTracer, 其是 Server Tracer，这里是逻辑所在。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SpringMvcTracer extends AbstractServerTracer {
    private static volatile SpringMvcTracer springMvcTracer = null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体 SpringMvcSofaTracerFilter 的 doFilter 的大致逻辑如下：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;调用 getSpanContextFromRequest 从 request 中获取 SpanContext，其中使用了 tracer.extract函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调用 &lt;strong&gt;serverReceive&lt;/strong&gt; 获取 Span&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Span 设置各种 setTag&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调用 this.springMvcTracer.&lt;strong&gt;serverSend&lt;/strong&gt;(String.valueOf(httpStatus)); 来 结束Span。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;函数代码具体如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SpringMvcSofaTracerFilter implements Filter {
    private SpringMvcTracer springMvcTracer;

    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) {
        if (this.springMvcTracer == null) {
            this.springMvcTracer = SpringMvcTracer.getSpringMvcTracerSingleton();
        }

        SofaTracerSpan springMvcSpan = null;
        long responseSize = -1L;
        int httpStatus = -1;

        try {
            HttpServletRequest request = (HttpServletRequest)servletRequest;
            HttpServletResponse response = (HttpServletResponse)servletResponse;
            SofaTracerSpanContext spanContext = this.getSpanContextFromRequest(request);
            springMvcSpan = this.springMvcTracer.serverReceive(spanContext);
            if (StringUtils.isBlank(this.appName)) {
                this.appName = SofaTracerConfiguration.getProperty(&quot;spring.application.name&quot;);
            }

            springMvcSpan.setOperationName(request.getRequestURL().toString());
            springMvcSpan.setTag(&quot;local.app&quot;, this.appName);
            springMvcSpan.setTag(&quot;request.url&quot;, request.getRequestURL().toString());
            springMvcSpan.setTag(&quot;method&quot;, request.getMethod());
            springMvcSpan.setTag(&quot;req.size.bytes&quot;, request.getContentLength());
            SpringMvcSofaTracerFilter.ResponseWrapper responseWrapper = new SpringMvcSofaTracerFilter.ResponseWrapper(response);
            filterChain.doFilter(servletRequest, responseWrapper);
            httpStatus = responseWrapper.getStatus();
            responseSize = (long)responseWrapper.getContentLength();
        } catch (Throwable var15) {
            httpStatus = 500;
            throw new RuntimeException(var15);
        } finally {
            if (springMvcSpan != null) {
                springMvcSpan.setTag(&quot;resp.size.bytes&quot;, responseSize);
                this.springMvcTracer.serverSend(String.valueOf(httpStatus));
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x11-问题解答&quot;&gt;0x11 问题解答&lt;/h2&gt;
&lt;p&gt;我们在最初提出的问题，现在都有了解答。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;traceId是怎么生成的，有什么规则？答案如下：
&lt;ul&gt;&lt;li&gt;在clientSend cs 这个阶段，建立Span时候，如果不存在 Parent context，则调用 createRootSpanContext 建立了 new root span context。此时会生成一个 traceId&lt;/li&gt;
&lt;li&gt;TraceId 是由 ip，时间戳，递增序列，进程ID等构成，具体可以参见 TraceIdGenerator 类。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;spanId是怎么生成的，有什么规则？答案如下：
&lt;ul&gt;&lt;li&gt;在 Server Receive 这个阶段，如果当前线程SpanContext中没有Span，则生成一个新的 newSpan，然后调用 &lt;u&gt;&lt;strong&gt;setSpanId&lt;/strong&gt;&lt;/u&gt; 对传入的 SofaTracerSpanContext 参数进行设置新的 SpanId。&lt;/li&gt;
&lt;li&gt;规则很简单，就是在之前Span ID基础上单调递增，参见 SofaTracerSpanContext #nextChildContextId。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;客户端哪里生成的Span？答案如下：
&lt;ul&gt;&lt;li&gt;在 客户端发送请求 clientSend cs 这个阶段，就是 AbstractTracer # clientSend 函数，调用 buildSpan 构建一个 SofaTracerSpan clientSpan，然后调用 start 函数建立一个 Span。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ParentSpan 从哪儿来？答案如下：
&lt;ul&gt;&lt;li&gt;在 clientSend 阶段，先从 SofaTraceContext 取出 serverSpan。如果本 client 就是 一个服务中间点（即 serverSpan 不为空），则 serverSpan 就是 parentSpan，那么需要给新span设置父亲Span。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ChildSpan由ParentSpan创建，那么什么时候创建？答案如下：
&lt;ul&gt;&lt;li&gt;接上面回答，如果存在 ParentSpan，则调用 &lt;code&gt;clientSpan = (SofaTracerSpan)this.sofaTracer.buildSpan(operationName).asChildOf(serverSpan).start();&lt;/code&gt; 得到本身的 client Span。&lt;/li&gt;
&lt;li&gt;即如果存在active span ，若存在则生成CHILD_OF关系的上下文， 如果不存在则createNewContext;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Trace信息怎么传递？答案如下：
&lt;ul&gt;&lt;li&gt;OpenTracing之中是通过SpanContext来传递Trace信息。&lt;/li&gt;
&lt;li&gt;SpanContext存储的是一些需要跨越边界的一些信息，比如trace Id，span id，Baggage。这些信息会不同组件根据自己的特点序列化进行传递，比如序列化到 http header 之中再进行传递。&lt;/li&gt;
&lt;li&gt;然后通过这个 SpanContext 所携带的信息将当前节点关联到整个 Tracer 链路中去&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;服务器接收到请求之后做什么？答案如下：
&lt;ul&gt;&lt;li&gt;server 端则是 从请求的 Header 中 extract 出 spanContext，来还原本次请求线程的上下文。因为上下文是和所处理的线程相关，放入 ThreadLocal中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SpanContext在服务器端怎么处理？答案见上面回答。&lt;/li&gt;
&lt;li&gt;链路信息如何搜集？答案如下：
&lt;ul&gt;&lt;li&gt;采样是对于整条链路来说的，也就是说从 RootSpan 被创建开始，就已经决定了当前链路数据是否会被记录了。&lt;/li&gt;
&lt;li&gt;在 SofaTracer 类中，Sapmler 实例作为成员变量存在，并且被设置为 final，也就是当构建好 SofaTracer 实例之后，采样策略就不会被改变。当 Sampler 采样器绑定到 SofaTracer 实例之后，SofaTracer 对于产生的 Span 数据的落盘行为都会依赖采样器的计算结果（针对某一条链路而言）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/83654617&quot;&gt;分布式追踪系统 -- Opentracing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yunqiinsight/article/details/80134045&quot;&gt;开放分布式追踪（OpenTracing）入门与 Jaeger 实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/7a08e7c1835c&quot;&gt;OpenTracing 语义说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/71024024&quot;&gt;分布式追踪系统概述及主流开源系统对比&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/41252484&quot;&gt;Skywalking分布式追踪与监控：起始篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/82cd923191fb&quot;&gt;分布式全链路监控 -- opentracing小试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/170290448&quot;&gt;opentracing实战&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/79419529&quot;&gt;Go微服务全链路跟踪详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://niyanchun.com/opentracing-java-library-tutorial-3.html&quot;&gt;OpenTracing Java Library教程(3)——跨服务传递SpanContext&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://niyanchun.com/opentracing-java-library-tutorial-1.html&quot;&gt;OpenTracing Java Library教程(1)——trace和span入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-tracer-overview/&quot;&gt;蚂蚁金服分布式链路跟踪组件 SOFATracer 总览|剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-tracer-unvarnished-transmission-slf4j-mdc/&quot;&gt;蚂蚁金服开源分布式链路跟踪组件 SOFATracer 链路透传原理与SLF4J MDC 的扩展能力剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-tracer-sampling-tracking-deep-dive/&quot;&gt;蚂蚁金服开源分布式链路跟踪组件 SOFATracer 采样策略和源码剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sofastack-guides/sofa-tracer-guides&quot;&gt;https://github.com/sofastack-guides/sofa-tracer-guides&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://opentracing.io/specification/&quot;&gt;The OpenTracing Semantic Specification&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-tracer-response-mechanism/&quot;&gt;蚂蚁金服分布式链路跟踪组件 SOFATracer 数据上报机制和源码剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-tracer-event-tracing-deep-dive/&quot;&gt;蚂蚁金服开源分布式链路跟踪组件 SOFATracer 埋点机制剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-channel-15-retrospect/&quot;&gt;分布式链路组件 SOFATracer 埋点机制解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-rpc-link-tracking/&quot;&gt;【剖析 | SOFARPC 框架】之 SOFARPC 链路追踪剖析&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 09 Sep 2020 12:39:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>SOFA是蚂蚁金服自主研发的金融级分布式中间件，包含了构建金融级云原生架构所需的各个组件，SOFATracer 是其中用于分布式系统调用跟踪的组件。 笔者之前有过zipkin的经验，希望扩展到Open</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/13641637.html</dc:identifier>
</item>
<item>
<title>dya49:django:wsgrief&amp;模板渲染Jinjia2&amp;django的MTV/MVC框架&amp;创建/启动一个django项目 - iR-Poke</title>
<link>http://www.cnblogs.com/libolun/p/13641643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/libolun/p/13641643.html</guid>
<description>&lt;h2&gt;目录&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/libolun/p/13641643.html#demo1&quot;&gt;1.自定义web框架wsgiref版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/libolun/p/13641643.html#demo2&quot;&gt;2.自定义web框架wsgiref版-优化版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/libolun/p/13641643.html#demo3&quot;&gt;3.模板渲染JinJa2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/libolun/p/13641643.html#demo4&quot;&gt;4.MTV和MVC框架&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/libolun/p/13641643.html#demo5&quot;&gt;5.django：下载安装&amp;amp;创建启动&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;自定义web框架wsgiref版&lt;/h2&gt;
&lt;h4&gt;1.wsgiref构建服务端&lt;/h4&gt;
&lt;p&gt;wsgiref本身就是个web框架，提供了一些固定的功能（请求和响应信息的封装)，&lt;/p&gt;
&lt;p&gt;有了wsgiref我们就不需要自己写原生的socket了&lt;/p&gt;
&lt;p&gt;也不需要咱们自己来完成请求信息的提取了&lt;/p&gt;
&lt;p&gt;整体结构和socketserver类似&lt;/p&gt;
&lt;h4&gt;2.登录函数逻辑&lt;/h4&gt;
&lt;p&gt;登录操作 进入页面为get请求 提交数据是post请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; login(environ):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 回复login.html&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; environ['QUERY_STRING'] --'username=chao'&lt;/span&gt;
    method = environ[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;REQUEST_METHOD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; method == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开login页面&lt;/span&gt;
        with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
            data &lt;/span&gt;=&lt;span&gt; f.read()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(environ)
        content_length &lt;/span&gt;= int(environ.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CONTENT_LENGTH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,0)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取'username=asdf&amp;amp;password=asdf的长度&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; environ['wsgi.input']是post对象，对象中内置了read方法，参数是长度，读出来的是字节流，再decode一下，得到字符串&lt;/span&gt;
        data = environ[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wsgi.input&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].read(content_length).decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; environ['wsgi.input']是post对象&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;post请求提交过来的数据&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请求数据为&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;请求数据为 b'username=asdf&amp;amp;password=asdf&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用parse_qs的原因:'username=asdf&amp;amp;password=asdf这个字符串把用户名和密码完全切割出来太麻烦&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; parse_qs可以将这个字符串格式化成我们需要的字典，这样的话取值非常方便&lt;/span&gt;
        data =&lt;span&gt; parse_qs(data)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;格式化之后的数据&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;格式化之后的数据 {'username': ['chao'], 'password': ['123']}&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过字典轻而易举获取post提交过来的用户名和密码&lt;/span&gt;
        uname = data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        pwd &lt;/span&gt;= data.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用check函数 检测用户名密码是否正确，返回一个是否成功状态status&lt;/span&gt;
        status =&lt;span&gt; check(uname,pwd)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 登录成功 跳转到html页面&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; status:
            data &lt;/span&gt;=&lt;span&gt; html(environ)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 登录失败 给一个错误提示&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gunduzi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.application函数逻辑（替代socket）&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; application(environ, start_response):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    :param environ: 是全部加工好的请求信息，加工成了一个字典，通过字典取值的方式就能拿到很多你想要拿到的信息
    :param start_response: 帮你封装响应信息的（响应行和响应头），注意下面的参数
    :return:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    path &lt;/span&gt;= environ[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PATH_INFO&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(environ)
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    urlpatterns = [
        ('/', html),
        ('/login', login),
        ('/vip.html', vip),
        ('/spa.ico', ico),
        ('/test.css', css),
        ('/test.js', js),
        ('/2.jpg', jpg),

    ]
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;　　 
    &lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; urlpatterns:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; url[0] ==&lt;span&gt; path:
            data &lt;/span&gt;= url[1&lt;span&gt;](environ)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;404 page not found&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 封装响应行和响应头的&lt;/span&gt;
    start_response(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;200 OK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),])

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(environ)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(environ['PATH_INFO'])  #输入地址127.0.0.1:8000，这个打印的是'/',输入的是127.0.0.1:8000/index，打印结果是'/index'&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [data]

httpd &lt;/span&gt;= make_server(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 8001&lt;span&gt;, application)
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
make_server的作用：
将请求信息处理成一个字典 
把 [data] 响应到html页面
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Serving HTTP on port 8001...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开始监听HTTP请求:&lt;/span&gt;
httpd.serve_forever()
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.创建数据库并插入数据&lt;/h4&gt;
&lt;p&gt;如果我们要做一个登陆注册的一个界面，肯定要输入用户名和密码，这时候肯定要涉及数据库的操作了&lt;/p&gt;
&lt;p&gt;so 我们在数据库中创建一些数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;database&lt;/span&gt;&lt;span&gt; db1;
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;use&lt;/span&gt;&lt;span&gt; db1;
&lt;/span&gt;&lt;span&gt;Database&lt;/span&gt;&lt;span&gt; changed
mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; userinfo(id &lt;span&gt;int&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; auto_increment,username &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;unique&lt;/span&gt;,password &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.23&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; userinfo(username,password) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chao&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;666&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sb1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; rows affected (&lt;span&gt;0.03&lt;/span&gt;&lt;span&gt; sec)
Records: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  Duplicates: &lt;span&gt;0&lt;/span&gt;  Warnings: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; userinfo;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+----------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; username &lt;span&gt;|&lt;/span&gt; password &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+----------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; chao     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;666&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; sb1      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;222&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+----------+----------+&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;5.pymysql连接数据库对数据库进行操作&lt;/h4&gt;
&lt;p&gt;数据创建好了，我们现在想要用python对数据库进行操作，所以需要pymysql来连接一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建表，插入数据&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; createtable():
    &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql
    conn &lt;/span&gt;=&lt;span&gt; pymysql.connect(
        host&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        port&lt;/span&gt;=3306&lt;span&gt;,
        user&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        password&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;666&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        database&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        charset&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    )
    cursor &lt;/span&gt;=&lt;span&gt; conn.cursor(pymysql.cursors.DictCursor)
    sql &lt;/span&gt;= &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        -- 创建表
        create table userinfo(id int primary key auto_increment,username char(20) not null unique,password char(20) not null);
        -- 插入数据
        insert into userinfo(username,password) values('chao','666'),('sb1','222');
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    cursor.execute(sql)
    conn.commit()
    cursor.close()
    conn.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;6.auth登录验证&lt;/h4&gt;
&lt;p&gt;现在有数据库了，我们就可以对用户名和密码进行验证了&lt;/p&gt;
&lt;p&gt;在auth函数中传入用户输入的用户名和密码，通过select查询结果确定用户名和面是否正确&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对用户名和密码进行验证&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; auth(username,password):
    &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql
    conn &lt;/span&gt;=&lt;span&gt; pymysql.connect(
        host&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        port&lt;/span&gt;=3306&lt;span&gt;,
        user&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        password&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        database&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        charset&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    )
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;userinfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,username,password)
    cursor &lt;/span&gt;=&lt;span&gt; conn.cursor(pymysql.cursors.DictCursor)
    sql &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from userinfo where username=%s and password=%s;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    res &lt;/span&gt;=&lt;span&gt; cursor.execute(sql, [username, password])
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; res:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; False
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;7.登录页面-login.html&lt;/h4&gt;
&lt;p&gt;在网页上，我们要看到一个用户名和密码的输入框，所以需要创建一个前端html文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;如果form表单里面的action什么值也没给，默认是往当前页面的url上提交你的数据，所以我们可以自己指定数据的提交路径&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;&amp;lt;form action=&quot;http://127.0.0.1:8080/auth/&quot; method=&quot;post&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;http://127.0.0.1:8080/auth/&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;get&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    用户名&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    密码 &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;8.登陆成功的跳转界面&lt;/h4&gt;
&lt;p&gt;登录成功后，有一个跳转页面，所以需要创建一个跳转页面的html文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        h1&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
            color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;宝贝儿，恭喜你登陆成功啦&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;自定义web框架wsgiref版-优化版&lt;/h2&gt;
&lt;h4&gt;&lt;strong&gt;优化版和上面的版本有什么不同？&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;对之前的版本进行优化，将不同的函数按照功能分别写到不同的文件和文件夹中&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;下面是文件的一个结构图：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1780189/202009/1780189-20200909194408130-7568678.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;关于上图的解释&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1.static用于存放一些静态文件&lt;/p&gt;
&lt;p&gt;　　包括css js icon jpg图片这种文件&lt;/p&gt;
&lt;p&gt;2.template存放前端html文件&lt;/p&gt;
&lt;p&gt;3.auth用来存放一些需要验证的函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; check(username, pwd):
    conn &lt;/span&gt;=&lt;span&gt; pymysql.connect(
        host&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;152.136.114.188&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        port&lt;/span&gt;=3306&lt;span&gt;,
        user&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        password&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        database&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        charset&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    )
    cursor &lt;/span&gt;=&lt;span&gt; conn.cursor()
    sql &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from userinfo where username=%s and password=%s;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    res &lt;/span&gt;=&lt;span&gt; cursor.execute(sql, [username, pwd])
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; res:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; False
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.manage.py是用来实现执行命令的函数&lt;/p&gt;
&lt;p&gt;这样我们在pycharm命令行中通过 python manage.py xxx就可以执行相关命令了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; UserInfo
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; wsgi &lt;span&gt;import&lt;/span&gt;&lt;span&gt; run

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
args &lt;/span&gt;=&lt;span&gt; sys.argv
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(args)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;['manage.py', 'migrate']&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(args[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; args[1] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;migrate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
   obj &lt;/span&gt;=&lt;span&gt; UserInfo()
   obj.create_model()
&lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; args[1] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;runserver&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
     ip &lt;/span&gt;= args[2&lt;span&gt;]
     port &lt;/span&gt;= int(args[3&lt;span&gt;])
     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ip,port)
     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(type(port))&lt;/span&gt;
&lt;span&gt;     run(ip, port)


 &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; python manage.py runserver 127.0.0.1 8001&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.models.py是和数据库相关的&lt;/p&gt;
&lt;p&gt;主要完成了用python连接mysql的相关配置信息以及python对mysql进行一些增删改查操作用的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInfo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; create_model(self):
        &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql

        conn &lt;/span&gt;=&lt;span&gt; pymysql.connect(
            host&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;152.136.114.188&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            port&lt;/span&gt;=3306&lt;span&gt;,
            user&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            password&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            database&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            charset&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        )
        cursor &lt;/span&gt;=&lt;span&gt; conn.cursor()

        sql &lt;/span&gt;= &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
            create table userinfo(id int primary key auto_increment, username char(10), password char(10));

        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        cursor.execute(sql)
        conn.commit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.urls.py是用来确定url路径的，并且通过访问相应的路径，可以执行和路径相关的函数(view)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; views
urlpatterns &lt;/span&gt;=&lt;span&gt; [

    (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/home&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.home),
    (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.login),
    (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/vip.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.vip),
    (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/favicon.ico&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.ico),
    (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test.css&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.css),
    (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test.js&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.js),
    (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/2.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.jpg),

]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.views.py是用来实现主要逻辑的，和项目内容逻辑相关的函数都写在这里面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; home(environ):

    msg &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chao&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hobby&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;女人&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ddj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;小电影&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]}
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; with open('./templates/index.html', 'rb') as f:&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     data = f.read()&lt;/span&gt;
    with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./templates/index.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
        data &lt;/span&gt;=&lt;span&gt; f.read()
    
    t &lt;/span&gt;=&lt;span&gt; Template(data)
    ret &lt;/span&gt;=&lt;span&gt; t.render(msg)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ret.encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8.wsgi.py是web框架的服务器， 它代替了socket&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urlpatterns
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; wsgiref.simple_server &lt;span&gt;import&lt;/span&gt;&lt;span&gt; make_server

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(ip, port):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print('xxxxxxxx')&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; application(environ, start_response):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        :param environ: 是全部加工好的请求信息，加工成了一个字典，通过字典取值的方式就能拿到很多你想要拿到的信息
        :param start_response: 帮你封装响应信息的（响应行和响应头），注意下面的参数
        :return:
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        path &lt;/span&gt;= environ[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PATH_INFO&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; url &lt;span&gt;in&lt;/span&gt;&lt;span&gt; urlpatterns:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; url[0] ==&lt;span&gt; path:
                data &lt;/span&gt;= url[1&lt;span&gt;](environ)
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            data &lt;/span&gt;= b&lt;span&gt;'&lt;/span&gt;&lt;span&gt;404 page not found&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;


        start_response(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;200 OK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), ])

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [data]

    httpd &lt;/span&gt;=&lt;span&gt; make_server(ip, port, application)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print('Serving HTTP on port 8001...')&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开始监听HTTP请求:&lt;/span&gt;
    httpd.serve_forever()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;模板渲染JinJa2&lt;/h2&gt;
&lt;p&gt;如果我们想实现一个动态页面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;之前使用的方法是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设以时间为例，在前端页面上显示时间戳（刷新就会显示当前时间戳）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么做到这件事呢？&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; html(environ):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.创建一个当前时间时间戳&lt;/span&gt;
    current_time =&lt;span&gt; str(time.time())

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.读出当前的html文件&lt;/span&gt;
    with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./templates/home.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
        data &lt;/span&gt;=&lt;span&gt; f.read()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.将文件中的xxoo替换为时间戳&lt;/span&gt;
    data = data.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxoo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, current_time).encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; data
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在home.html中，搞一个字符串xxoo，然后时间戳就能够替换上去了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 在html文件中，写一个标签，其中的内容有xxoo &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;皇家赌场--xxoo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://127.0.0.1:8002/vip.html&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;会员中心&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;2.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;c1&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;d1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实，这种行为从专业角度老说，叫做模板渲染&lt;/p&gt;
&lt;p&gt;这个过程其实就是HTML模板渲染数据&lt;/p&gt;
&lt;p&gt;本质上就是HTML内容中利用一些特殊的符号来替换要展示的数据。&lt;/p&gt;
&lt;p&gt;我这里用的特殊符号是我定义的&lt;/p&gt;
&lt;p&gt;其实模板渲染有个现成的工具：JinJa2&lt;/p&gt;
&lt;h4&gt;用JinJa2实现动态界面&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; jinja2 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Template


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    with open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
        data &lt;/span&gt;=&lt;span&gt; f.read()
    template &lt;/span&gt;= Template(data)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成模板文件&lt;/span&gt;
    ret = template.render({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;于谦&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hobby_list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;烫头&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;泡吧&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]})  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把数据填充到模板里面&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; [bytes(ret, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在JinJa2中 特殊符号就是{{  }} or {%  %}&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;zh-CN&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;x-ua-compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名：{{name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;爱好：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        {% for hobby in hobby_list %}
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{hobby}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        {% endfor %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面.py中的数据是我们手动写的&lt;/p&gt;
&lt;p&gt;当然我们也可以从数据库中获取数据，但是前提一定要配置用pymysql配置好数据库哦&lt;/p&gt;
&lt;h2&gt;MTV和MVC框架&lt;/h2&gt;
&lt;h4&gt;MVC框架&lt;/h4&gt;
&lt;p data-key=&quot;3327&quot;&gt;&lt;span data-key=&quot;3306&quot;&gt;　Web服务器开发领域里著名的MVC模式，所谓MVC就是把Web应用分为模型(M)，控制器(C)和视图(V)三层，他们之间以一种插件式的、松耦合的方式连接在一起，模型负责业务对象与数据库的映射(ORM)，视图负责与用户的交互(页面)，控制器接受用户的输入调用模型和视图完成用户的请求，其示意图如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;3327&quot;&gt;&lt;span data-key=&quot;3306&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/877318/201804/877318-20180418162558974-92667466.png&quot; alt=&quot;&quot; width=&quot;362&quot; height=&quot;326&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 data-key=&quot;3327&quot;&gt;&lt;span data-key=&quot;3306&quot;&gt;MTV框架&lt;/span&gt;&lt;/h4&gt;
&lt;p data-key=&quot;3331&quot;&gt;&lt;span data-key=&quot;3330&quot;&gt;　Django的MTV模式本质上和MVC是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同，Django的MTV分别是指：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li data-key=&quot;3338&quot;&gt;&lt;span data-key=&quot;3332&quot;&gt;&lt;span data-offset-key=&quot;3332-0&quot;&gt;M 代表模型（Model）： &lt;span data-offset-key=&quot;3332-1&quot;&gt;负责业务对象和数据库的关系映射(ORM)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li data-key=&quot;3349&quot;&gt;&lt;span data-key=&quot;3339&quot;&gt;&lt;span data-offset-key=&quot;3339-0&quot;&gt;T 代表模板 (Template)：&lt;span data-offset-key=&quot;3339-1&quot;&gt;负责如何把页面展示给用户(html)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li data-key=&quot;3352&quot;&gt;&lt;span data-key=&quot;3350&quot;&gt;&lt;span data-offset-key=&quot;3350-0&quot;&gt;V 代表视图（View）&lt;span data-offset-key=&quot;3350-1&quot;&gt;：   负责业务逻辑，并在适当时候调用Model和Template。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-key=&quot;3354&quot;&gt;&lt;span data-key=&quot;3353&quot;&gt;　　除了以上三层之外，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template，MTV的响应模式如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;3354&quot;&gt;&lt;span data-key=&quot;3353&quot;&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/877318/201804/877318-20180418162350672-193671507.png&quot; alt=&quot;&quot; width=&quot;808&quot; height=&quot;347&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-slate-fragment=&quot;JTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJkb2N1bWVudCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJibG9jayUyMiUyQyUyMmlzVm9pZCUyMiUzQWZhbHNlJTJDJTIydHlwZSUyMiUzQSUyMnBhcmFncmFwaCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIya2luZCUyMiUzQSUyMnRleHQlMjIlMkMlMjJyYW5nZXMlMjIlM0ElNUIlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU0JUI4JTgwJUU4JTg4JUFDJUU2JTk4JUFGJUU3JTk0JUE4JUU2JTg4JUI3JUU5JTgwJTlBJUU4JUJGJTg3JUU2JUI1JThGJUU4JUE3JTg4JUU1JTk5JUE4JUU1JTkwJTkxJUU2JTg4JTkxJUU0JUJCJUFDJUU3JTlBJTg0JUU2JTlDJThEJUU1JThBJUExJUU1JTk5JUE4JUU1JThGJTkxJUU4JUI1JUI3JUU0JUI4JTgwJUU0JUI4JUFBJUU4JUFGJUI3JUU2JUIxJTgyKHJlcXVlc3QpJUVGJUJDJThDJUU4JUJGJTk5JUU0JUI4JUFBJUU4JUFGJUI3JUU2JUIxJTgyJUU1JTlCJTlFJUU1JThFJUJCJUU4JUFFJUJGJUU5JTk3JUFFJUU4JUE3JTg2JUU1JTlCJUJFJUU1JTg3JUJEJUU2JTk1JUIwJUVGJUJDJThDJUVGJUJDJTg4JUU1JUE2JTgyJUU2JTlFJTlDJUU0JUI4JThEJUU2JUI2JTg5JUU1JThGJThBJUU1JTg4JUIwJUU2JTk1JUIwJUU2JThEJUFFJUU4JUIwJTgzJUU3JTk0JUE4JUVGJUJDJThDJUU5JTgyJUEzJUU0JUI5JTg4JUU4JUJGJTk5JUU0JUI4JUFBJUU2JTk3JUI2JUU1JTgwJTk5JUU4JUE3JTg2JUU1JTlCJUJFJUU1JTg3JUJEJUU2JTk1JUIwJUU4JUJGJTk0JUU1JTlCJTlFJUU0JUI4JTgwJUU0JUI4JUFBJUU2JUE4JUExJUU2JTlEJUJGJUU0JUI5JTlGJUU1JUIwJUIxJUU2JTk4JUFGJUU0JUI4JTgwJUU0JUI4JUFBJUU3JUJEJTkxJUU5JUExJUI1JUU3JUJCJTk5JUU3JTk0JUE4JUU2JTg4JUI3JUVGJUJDJTg5JUVGJUJDJThDJUU4JUE3JTg2JUU1JTlCJUJFJUU1JTg3JUJEJUU2JTk1JUIwJUU4JUIwJTgzJUU3JTk0JUE4JUU2JUE4JUExJUU1JTlFJThCJUVGJUJDJThDJUU2JUE4JUExJUU1JTlFJThCJUU1JThFJUJCJUU2JTk1JUIwJUU2JThEJUFFJUU1JUJBJTkzJUU2JTlGJUE1JUU2JTg5JUJFJUU2JTk1JUIwJUU2JThEJUFFJUVGJUJDJThDJUU3JTg0JUI2JUU1JTkwJThFJUU5JTgwJTkwJUU3JUJBJUE3JUU4JUJGJTk0JUU1JTlCJTlFJUVGJUJDJThDJUU4JUE3JTg2JUU1JTlCJUJFJUU1JTg3JUJEJUU2JTk1JUIwJUU2JThBJThBJUU4JUJGJTk0JUU1JTlCJTlFJUU3JTlBJTg0JUU2JTk1JUIwJUU2JThEJUFFJUU1JUExJUFCJUU1JTg1JTg1JUU1JTg4JUIwJUU2JUE4JUExJUU2JTlEJUJGJUU0JUI4JUFEJUU3JUE5JUJBJUU2JUEwJUJDJUU0JUI4JUFEJUVGJUJDJThDJUU2JTlDJTgwJUU1JTkwJThFJUU4JUJGJTk0JUU1JTlCJTlFJUU3JUJEJTkxJUU5JUExJUI1JUU3JUJCJTk5JUU3JTk0JUE4JUU2JTg4JUI3JUUzJTgwJTgyJTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlNUQlN0QlNUQlN0QlNUQlN0Q=&quot;&gt;　　一般是用户通过浏览器向我们的服务器发起一个请求(request)，这个请求回去访问视图函数，（如果不涉及到数据调用，那么这个时候视图函数返回一个模板也就是一个网页给用户），视图函数调用模型，模型去数据库查找数据，然后逐级返回，视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span data-slate-fragment=&quot;JTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJkb2N1bWVudCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIyZGF0YSUyMiUzQSU3QiU3RCUyQyUyMmtpbmQlMjIlM0ElMjJibG9jayUyMiUyQyUyMmlzVm9pZCUyMiUzQWZhbHNlJTJDJTIydHlwZSUyMiUzQSUyMnBhcmFncmFwaCUyMiUyQyUyMm5vZGVzJTIyJTNBJTVCJTdCJTIya2luZCUyMiUzQSUyMnRleHQlMjIlMkMlMjJyYW5nZXMlMjIlM0ElNUIlN0IlMjJraW5kJTIyJTNBJTIycmFuZ2UlMjIlMkMlMjJ0ZXh0JTIyJTNBJTIyJUU0JUI4JTgwJUU4JTg4JUFDJUU2JTk4JUFGJUU3JTk0JUE4JUU2JTg4JUI3JUU5JTgwJTlBJUU4JUJGJTg3JUU2JUI1JThGJUU4JUE3JTg4JUU1JTk5JUE4JUU1JTkwJTkxJUU2JTg4JTkxJUU0JUJCJUFDJUU3JTlBJTg0JUU2JTlDJThEJUU1JThBJUExJUU1JTk5JUE4JUU1JThGJTkxJUU4JUI1JUI3JUU0JUI4JTgwJUU0JUI4JUFBJUU4JUFGJUI3JUU2JUIxJTgyKHJlcXVlc3QpJUVGJUJDJThDJUU4JUJGJTk5JUU0JUI4JUFBJUU4JUFGJUI3JUU2JUIxJTgyJUU1JTlCJTlFJUU1JThFJUJCJUU4JUFFJUJGJUU5JTk3JUFFJUU4JUE3JTg2JUU1JTlCJUJFJUU1JTg3JUJEJUU2JTk1JUIwJUVGJUJDJThDJUVGJUJDJTg4JUU1JUE2JTgyJUU2JTlFJTlDJUU0JUI4JThEJUU2JUI2JTg5JUU1JThGJThBJUU1JTg4JUIwJUU2JTk1JUIwJUU2JThEJUFFJUU4JUIwJTgzJUU3JTk0JUE4JUVGJUJDJThDJUU5JTgyJUEzJUU0JUI5JTg4JUU4JUJGJTk5JUU0JUI4JUFBJUU2JTk3JUI2JUU1JTgwJTk5JUU4JUE3JTg2JUU1JTlCJUJFJUU1JTg3JUJEJUU2JTk1JUIwJUU4JUJGJTk0JUU1JTlCJTlFJUU0JUI4JTgwJUU0JUI4JUFBJUU2JUE4JUExJUU2JTlEJUJGJUU0JUI5JTlGJUU1JUIwJUIxJUU2JTk4JUFGJUU0JUI4JTgwJUU0JUI4JUFBJUU3JUJEJTkxJUU5JUExJUI1JUU3JUJCJTk5JUU3JTk0JUE4JUU2JTg4JUI3JUVGJUJDJTg5JUVGJUJDJThDJUU4JUE3JTg2JUU1JTlCJUJFJUU1JTg3JUJEJUU2JTk1JUIwJUU4JUIwJTgzJUU3JTk0JUE4JUU2JUE4JUExJUU1JTlFJThCJUVGJUJDJThDJUU2JUE4JUExJUU1JTlFJThCJUU1JThFJUJCJUU2JTk1JUIwJUU2JThEJUFFJUU1JUJBJTkzJUU2JTlGJUE1JUU2JTg5JUJFJUU2JTk1JUIwJUU2JThEJUFFJUVGJUJDJThDJUU3JTg0JUI2JUU1JTkwJThFJUU5JTgwJTkwJUU3JUJBJUE3JUU4JUJGJTk0JUU1JTlCJTlFJUVGJUJDJThDJUU4JUE3JTg2JUU1JTlCJUJFJUU1JTg3JUJEJUU2JTk1JUIwJUU2JThBJThBJUU4JUJGJTk0JUU1JTlCJTlFJUU3JTlBJTg0JUU2JTk1JUIwJUU2JThEJUFFJUU1JUExJUFCJUU1JTg1JTg1JUU1JTg4JUIwJUU2JUE4JUExJUU2JTlEJUJGJUU0JUI4JUFEJUU3JUE5JUJBJUU2JUEwJUJDJUU0JUI4JUFEJUVGJUJDJThDJUU2JTlDJTgwJUU1JTkwJThFJUU4JUJGJTk0JUU1JTlCJTlFJUU3JUJEJTkxJUU5JUExJUI1JUU3JUJCJTk5JUU3JTk0JUE4JUU2JTg4JUI3JUUzJTgwJTgyJTIyJTJDJTIybWFya3MlMjIlM0ElNUIlNUQlN0QlNUQlN0QlNUQlN0QlNUQlN0Q=&quot;&gt;django：下载安装&amp;amp;创建启动&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;1.下载django&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip3 install django==1.11.9
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.创建一个django的project&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
django-admin startproject mysite   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建了一个名为&quot;mysite&quot;的Django 项目：&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们执行完这条指令后 ，会出现如下一堆文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/877318/201607/877318-20160724114201404-1121087959.png&quot; alt=&quot;&quot; width=&quot;239&quot; height=&quot;181&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;strong&gt;这些文件的作用：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;p0&quot;&gt;manage.py ----- Django项目里面的工具，通过它可以调用django shell和数据库，启动关闭项目与项目交互等，不管你将框架分了几个文件，必然有一个启动文件，其实他们本身就是一个文件。&lt;/li&gt;
&lt;li class=&quot;p0&quot;&gt;settings.py ---- 包含了项目的默认设置，包括数据库信息，调试标志以及其他一些工作的变量。&lt;/li&gt;
&lt;li class=&quot;p0&quot;&gt;urls.py ----- 负责把URL模式映射到应用程序。&lt;/li&gt;
&lt;li class=&quot;p0&quot;&gt;wsgi.py ---- runserver命令就使用wsgiref模块做简单的web server，后面会看到renserver命令，所有与socket相关的内容都在这个文件里面了，目前不需要关注它。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;3.创建django APP应用&lt;/h4&gt;
&lt;p&gt;刚才我们只是创建了一个django项目，但是里面并没有之前所提到的models.py views.py这些文件&lt;/p&gt;
&lt;p&gt;这是因为我们只是创建了django项目，并没有创建一个django的app&lt;/p&gt;
&lt;p&gt;所以这个app需要我们执行一条指令去创建&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
python manage.py startapp blog2  &lt;span&gt;#创建一个django应用 &lt;/span&gt;&lt;span&gt;每个应用的目录下都有自己的views.py视图函数和models.py数据库操作相关的文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们执行完这条指令后，会发现文件夹多了几个文件&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2015.cnblogs.com/blog/877318/201607/877318-20160724114930826-472002646.png&quot; alt=&quot;&quot; width=&quot;197&quot; height=&quot;193&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们现在只需要看其中两个文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　models.py ：之前我们写的那个名为model的文件就是创建表用的，这个文件就是存放与该app(应用)相关的表结构的&lt;/p&gt;
&lt;p&gt;　　　　views.py    ：存放与该app相关的视图函数的&lt;/p&gt;
&lt;p&gt;　　　   其他的先不用管，以后会知道的&lt;/p&gt;
&lt;h4&gt;4.启动django项目&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
python manage.py runserver 8080   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; python manage.py runserver 127.0.0.1:8080，本机就不用写ip地址了 如果连端口都没写，默认是本机的8000端口&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们的django就启动起来了。当我们访问：http://127.0.0.1:8080/时就可以看到：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://images2015.cnblogs.com/blog/877318/201607/877318-20160724120547497-22629173.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;92&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是django里自己写的一个html文件，当看到这个页面就说明，我们的django启动成功了&lt;/p&gt;

</description>
<pubDate>Wed, 09 Sep 2020 12:37:00 +0000</pubDate>
<dc:creator>iR-Poke</dc:creator>
<og:description>目录 1.自定义web框架wsgiref版 2.自定义web框架wsgiref版-优化版 3.模板渲染JinJa2 4.MTV和MVC框架 5.django：下载安装&amp;amp;创建启动 自定义web框</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/libolun/p/13641643.html</dc:identifier>
</item>
<item>
<title>Kubernetes 存活、就绪探针 - 有态度的小码甲</title>
<link>http://www.cnblogs.com/JulianHuang/p/13641262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JulianHuang/p/13641262.html</guid>
<description>&lt;p&gt;在设计关键任务、高可用应用程序时，弹性是要考虑的最重要因素之一。&lt;/p&gt;
&lt;p&gt;当应用程序可以快速从故障中恢复时，它便具有弹性。&lt;/p&gt;
&lt;p&gt;云原生应用程序通常设计为使用微服务架构，其中每个组件都位于容器中。为了确保Kubernetes托管的应用程序高可用，在设计集群时需要遵循一些特定的模式，其中有“健康探测模式”。应用&lt;strong&gt;高可观察性原则&lt;/strong&gt;（HOP）可确保您的应用程序收到的每个请求都能及时找到响应。&lt;/p&gt;
&lt;h3 id=&quot;the-high-observability-principle-hop&quot;&gt;The High Observability Principle (HOP)&lt;/h3&gt;
&lt;p&gt;高可观察性原则是基于容器的应用程序设计原则之一。微服务体系要求每个服务不关心(也不应该关心)被调用方如何处理请求。&lt;br/&gt;&lt;strong&gt;HOP原则要求每个服务必须公开几个API端点，其意义在于揭示服务健康状态，Kubernetes调用这些端点，决定下一步的路由和负载平衡&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;设计良好的云原生程序应将日志事件记录到STDERR和STDOUT，由logstash、Fluent等日志摄取服务将这些日志运送到集中式监控（例如Prometheus）和日志聚合系统（例如ELK）。下图说明了云原生应用程序如何遵守健康状况探测模式和高可观察性原则。&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/11d27667-f7d1-47c9-8fab-e56e9bf29e43.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=dPE%252FcIjf3bcipbalhF4gASqkUdQ%253D&amp;amp;Expires=1599726252&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;how-to-apply-health-probe-pattern-in-kubernetes&quot;&gt;How to Apply Health Probe Pattern in Kubernetes?&lt;/h2&gt;
&lt;p&gt;我之前写过ASP.NetCore + Docker健康检查的原创:[web程序暴露http健康检查端点，平台轮询探测]，&lt;strong&gt;Kubernetes针对不同场合细化了探针，更为强大的是给出对应决策。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;liveness-probes&quot;&gt;Liveness Probes&lt;/h4&gt;
&lt;p&gt;使用[存活探针]判断什么时候重启容器。&lt;br/&gt;使用存活探针检查容器本身是否无响应、死锁， 有时候重启容器常常能解决此类问题。&lt;/p&gt;
&lt;p&gt;我们以kubernetes官方demo为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-exec
spec:
  containers:
  - name: liveness
    image: busybox
    args:
    - /bin/sh
    - -c
    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600
    livenessProbe:
      exec:
        command:
        - cat
        - /tmp/healthy
      initialDelaySeconds: 5   # 指示kubectl等待5s才执行首次探测
      periodSeconds: 5         # 间隔5秒轮询
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在第5秒kubectl开始首次liveness探测&lt;/li&gt;
&lt;li&gt;在30秒进行的每次探测均成功&lt;/li&gt;
&lt;li&gt;30s之后容器内文件被删除，之后间隔5s的探测会失败，根据liveness默认配置连续3次失败就会放弃探测，放弃探测意味着重启容器，故容器会在第45s重启&lt;/li&gt;
&lt;li&gt;重启之后又开始以上流程， 故可以看到此探针以重启的决策尝试修复应用问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个探针会体现到&lt;code&gt;kubectl get pod&lt;/code&gt;的&lt;code&gt;RESTARTS&lt;/code&gt;列&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/2235eb8a-2cb8-4cd3-9be1-8ab6c4de080a.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=pFMqX%252BuW03%252FJp7VVfipfH5%252BksZ8%253D&amp;amp;Expires=1599732989&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;readiness-probes&quot;&gt;Readiness Probes&lt;/h4&gt;
&lt;p&gt;使用[就绪探针]判断容器是否就绪，是否可以接受流量。&lt;br/&gt;Pod内所有容器ready，则该Pod被认为ready，当pod没有ready，将会从服务负载均衡中移除。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有些时候，应用程序临时不可用（加载大量数据或者依赖外部服务），这个时候，重启这个Pod无济于事，同时你也不希望请求被发送到该Pod&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面的应用强依赖mongodb，我们针对这些依赖项设置了readiness探针&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddHealthChecks()
    .AddCheck&amp;lt;MongoHealthCheck&amp;gt;(nameof(MongoHealthCheck), tags: new[] { &quot;readyz&quot; });
// ----------------------
app.UseHealthChecks(&quot;/readyz&quot;, new HealthCheckOptions
{
        Predicate = (check) =&amp;gt; check.Tags.Contains(&quot;readyz&quot;)
});                
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是探测Mongodb的连通性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  sealed class MongoHealthCheck : IHealthCheck
    {
        private readonly IMongoDatabase _defaultMongoDatabase;

        public MongoHealthCheck(IDefaultMongoDatabaseProvider defaultMongoDatabaseProvider)
        {
            _defaultMongoDatabase = defaultMongoDatabaseProvider.GetDatabase();
        }

        public async Task&amp;lt;HealthCheckResult&amp;gt; CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
        {
            var doc = await _defaultMongoDatabase.RunCommandAsync(
                new BsonDocumentCommand&amp;lt;BsonDocument&amp;gt;(
                    new BsonDocument() {
                        { &quot;ping&quot;, &quot;1&quot; }
                    }), 
                cancellationToken: cancellationToken);

            var ok = doc[&quot;ok&quot;].ToBoolean();

            if (ok)
            {
                return HealthCheckResult.Healthy(&quot;OK&quot;);
            }

            return HealthCheckResult.Unhealthy(&quot;NotOK&quot;);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于依赖项的探测，探测周期和超时时间可以设置的稍长一点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;readinessProbe:
  httpGet:
    path: /readyz
    port: 80
  initialDelaySeconds: 5
  periodSeconds: 60     # 60s探测一次
  timeoutSeconds: 30    # 每次探测30s超时，与应用建立与依赖项的连接超时时间一致
  failureThreshold: 3   # 连续3次探测失败,该Pod会被标记为`Unready`
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;startup-probes&quot;&gt;Startup Probes&lt;/h4&gt;
&lt;p&gt;使用[启动探针]判断容器应用是否已经启动。如果配置了这个探针，则该探针成功之前将会禁用存活和就绪探针。&lt;/p&gt;
&lt;h4 id=&quot;配置探针&quot;&gt;配置探针&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;initialDelaySeconds：容器启动，探针延后工作，默认是0s&lt;/li&gt;
&lt;li&gt;periodSeconds 探针探测周期，默认10s&lt;/li&gt;
&lt;li&gt;timeoutSeconds： 探针工作的超时时间，默认1s&lt;/li&gt;
&lt;li&gt;successThreshold： 连续几次探测成功，该探针被认为是成功的，默认1次&lt;/li&gt;
&lt;li&gt;failureThreshold： 连续几次探测失败，该探针被认为最终失败，对于livenes探针最终失败意味着重启，对于readiness探针意味着该pod Unready, 默认3次。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;强烈建议根据应用结构合理设置探针参数，避免不切实际的认定失败导致的频繁重启或 Unready&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;结论：&quot;&gt;结论：&lt;/h2&gt;
&lt;p&gt;Kubernetes生态这么庞大，为啥单独拎出k8s探针， 是因为k8s探针是与应用程序结构密切相关的机制。&lt;br/&gt;就使用方式看：&lt;/p&gt;
&lt;p&gt;存活探针：用于快速判断应用进程是否无响应，尝试重启修复；&lt;/p&gt;
&lt;p&gt;就绪探针：判断应用及依赖项是否就绪，是否可以分配流量，如果不能就标记Unready，从负载均衡器中移除该Pod&lt;/p&gt;
&lt;p&gt;Kubernetes存活、就绪探针可以极大地提高服务的健壮性和弹性，并提供出色的最终用户体验。&lt;/p&gt;
</description>
<pubDate>Wed, 09 Sep 2020 12:20:00 +0000</pubDate>
<dc:creator>有态度的小码甲</dc:creator>
<og:description>在设计关键任务、高可用应用程序时，弹性是要考虑的最重要因素之一。 当应用程序可以快速从故障中恢复时，它便具有弹性。 云原生应用程序通常设计为使用微服务架构，其中每个组件都位于容器中。为了确保Kuber</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JulianHuang/p/13641262.html</dc:identifier>
</item>
<item>
<title>人工智能中的“五大门派“ - Jack47</title>
<link>http://www.cnblogs.com/Jack47/p/five-tribles-in-ai.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jack47/p/five-tribles-in-ai.html</guid>
<description>&lt;p&gt;美国的佩德罗·多明戈斯写了一本书《The Master Algorithm》，中文名为《终极算法》。多明戈斯是华盛顿大学的终身教授，也是一位在机器学习领域具有20 年研究经历的资深科学家，一直致力于融合各种机器学习算法的优势，提出一种可以解决所有应用问题的通用算法，即终极算法。这本书也进入了16年比尔盖茨的推荐书单，书中介绍了人工智能中典型的几种“门派”。&lt;/p&gt;
&lt;p&gt;他提到平常我们的知识来自三个方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进化：存储在你的基因（🧬）中&lt;/li&gt;
&lt;li&gt;经验：存储在人的大脑神经元&lt;/li&gt;
&lt;li&gt;文化：从周边的人和事物中学习&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这三种方式，每一种都比前一种包含的信息量大，而且学习速度更快。但是如今出现了第四种学习方式：计算机。计算机能帮助我们发现一些知识。Yann LeCun，甚至说：“未来大部分知识都会被机器提取出来，也会存储在机器里”。可见未来机器学习会越来越重要。&lt;/p&gt;
&lt;p&gt;让计算机学习的方法大致有五种，而且每个领域有一个主算法。&lt;/p&gt;
&lt;h2 id=&quot;1-符号派&quot;&gt;1. 符号派&lt;/h2&gt;
&lt;p&gt;符号派的灵感来源于逻辑学、哲学。一定程度上来说，是最“计算机科学”的，他们的目标是填补已有知识中的空缺部分。他们的工作跟科学家的工作模式类似：做大量观察，然后提出假设来解释他们，通过后续的论证来看是合理的或者不合理的。&lt;/p&gt;
&lt;p&gt;自1955年 人工智能(Artificial Intelligence) 被正式提出以来，符号派就存在了，如上所述，都是基于规则的系统，丝毫没有“学习”的能力。&lt;/p&gt;
&lt;p&gt;这个门派的主打算法是反向推论(Inverse Reduction)：通过已经收集的数据来创建一些规则，然后用规则来推断将来要发生的事情。然而这个理论有个非常明显的缺陷，你知道在哪里吗？&lt;/p&gt;
&lt;h2 id=&quot;2-连接派&quot;&gt;2. 连接派&lt;/h2&gt;
&lt;p&gt;连接派是在上个世纪80年代涌现，灵感来源于模拟人脑：它通过模拟人脑的工作方式来让机器获得知识。人脑会存储数据，通过每天不断获取新的数据来积累学习。这些记忆的数据的权重各不相同，而且当再次被使用到时会被加强。&lt;/p&gt;
&lt;p&gt;这种算法的问题是人脑非常复杂，想要完整模拟出人脑算法还有非常长的路要走，需要依赖于基础学科的突破。&lt;/p&gt;
&lt;p&gt;链接派的主打算法是神经网络，其中的分支深度学习(Deep Learning)如今在图片和视频领域发展非常迅速，应用很广泛。有很多框架可以支持神经网络分析，包括 Pytorch，TensorFlow、Caffe 和 百度 Paddle 等。这些框架的工作原理都类似：通过迭代分析大量样例数据来使用分层的方式发掘数据中的特点，把结果从一层传递到下一层做下一步分析。每一层能从数据中解析出更复杂、抽象的特点。&lt;/p&gt;
&lt;p&gt;神经网络的问题之一是需要大量标注好的数据来训练算法，有一些场景下这是不可能做到的。其中用到的反向传播技术，被诟病的是找到的是“好”的方案而不是“最佳”方案，因为它找到的是局部而非全局最优解。&lt;/p&gt;
&lt;h2 id=&quot;3-进化派&quot;&gt;3. 进化派&lt;/h2&gt;
&lt;p&gt;一定程度上说进化是一个比人脑更大的学习算法，因为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它创造了人脑&lt;/li&gt;
&lt;li&gt;它创造了地球上其他生物形态&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以值得探究它到底是如何工作的，然后在计算机上实现它。&lt;/p&gt;
&lt;p&gt;进化派希望在计算机领域模拟出进化过程：让自然选择，适者生存，犹如达尔文观察到的那样。其过程是一次（一代）运行数以百万个不同的解决方案/算法，其中结果最好的方法保留到下一代。下一代里通过把上一代算法结合到一起来创建一个新的算法。这种每一代都有变化的方式会让我们一步步逼近解决问题的理想算法。&lt;/p&gt;
&lt;p&gt;进化派的主打算法是基因编程 (Genetic Programming)。这种算法的缺点是一个算法产生后，只能等待下一代时才能产出一个更好的算法。&lt;/p&gt;
&lt;h2 id=&quot;4-贝叶斯派&quot;&gt;4. 贝叶斯派&lt;/h2&gt;
&lt;p&gt;贝叶斯派来源于概率统计领域，想系统地减少不确定性。&lt;/p&gt;
&lt;p&gt;其实人类学习到的知识并不是一成不变的，它是不确定的在动态变化的。当我们从数据中推理出一些东西，是无法完全确定就是这样的。所以学习的方法变成通过使用概率来量化不确定性，当你看到了更多的证据，那不同假设的概率就在随之调整，证据越多的概率越高。其中方法之一就是大名鼎鼎的贝叶斯理论。&lt;/p&gt;
&lt;p&gt;好处是不需要大量的数据集，而且研究院也更容易理解和解释训练结果和机器决策过程，甚至可以调整结果。一些使用贝叶斯技术的试验在识别物体方面也有好的结果。&lt;/p&gt;
&lt;h2 id=&quot;5-类比派&quot;&gt;5. 类比派&lt;/h2&gt;
&lt;p&gt;这个学派主要源于心理学，使用的是最简单，最直观的方式：通过类比来推理。心理学中有大量证据表明人类就是这样做的：当你面对一个新问题，你会从已有的经验中找到与之类似的情况，然后把解决方法拿过来解决现有问题。&lt;/p&gt;
&lt;p&gt;主打算法是内核机器 (Kernel Machines)，比如支持向量机(Support Vector Machine)是其中算法之一，它是一种 Kernel 技巧，能把本来非线性的分隔问题影射到线性平面。&lt;/p&gt;
&lt;p&gt;其实除了上述五大门派，还有人在 ycombinator 上总结了机器学习里的&lt;a href=&quot;https://news.ycombinator.com/item?id=10951457&quot;&gt;其他各大门派&lt;/a&gt;。如果对这本书感兴趣，可以在youtube上看&lt;a href=&quot;https://www.youtube.com/watch?v=B8J4uefCQMc&quot;&gt;作者16年在Google的演讲&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;参考资料：&quot;&gt;参考资料：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=B8J4uefCQMc&quot;&gt;The Master Algorithm | Pedro Domingos Talks at Google&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@robinsonk2/an-overview-of-pedro-domingos-the-master-algorithm-84488a1c6fb8&quot;&gt;An Overview of Pedro Domingo’s The Master Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.wired.com/2017/02/ais-factions-get-feisty-really-theyre-team/&quot;&gt;AI's Factions Get Feisty. But Really, They’re All on the Same Team&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;欢迎关注我的微信公众账号，会在第一时间更新，博客园上只有部分文章会发布&quot;&gt;欢迎关注我的微信公众账号，会在第一时间更新，博客园上只有部分文章会发布&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://img2.tbcdn.cn/L1/461/1/5a0eff69de17d58383b72c9a78b3c28cd74b9d39&quot; alt=&quot;code&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 09 Sep 2020 12:11:00 +0000</pubDate>
<dc:creator>Jack47</dc:creator>
<og:description>跟武术中的门派类似，人工智能中也有几大门派</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jack47/p/five-tribles-in-ai.html</dc:identifier>
</item>
</channel>
</rss>