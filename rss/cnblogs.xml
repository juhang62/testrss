<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Alibaba Cluster Data 开放下载：270GB 数据揭秘你不知道的阿里巴巴数据中心 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10168748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10168748.html</guid>
<description>&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont680764.i0.68dfd099eV77bd&quot;&gt;打开一篇篇 IT 技术文章，你总能够看到“大规模”、“海量请求”这些字眼。如今，这些功能强大的互联网应用，都运行在大规模数据中心上，然而，对于大规模数据中心，你又了解多少呢？实际上，除了阅读一些科技文章之外，你很难得到更多关于数据中心的信息。数据中心每个机器的运行情况如何？这些机器上运行着什么样的应用？这些应用有有什么特点？对于这些问题，除了少数资深从业者之外，普通学生和企业的研究者很难了解其中细节。&lt;/p&gt;

&lt;p&gt;2015 年，我们尝试在阿里巴巴的数据中心，将延迟不敏感的批量离线计算任务和延迟敏感的在线服务部署到同一批机器上运行，让在线服务用不完的资源充分被离线使用以提高机器的整体利用率。经过 3 年多的试验论证、架构调整和资源隔离优化，目前这个方案已经走向大规模生产。我们通过混部技术将集群平均资源利用率从 10% 大幅度提高到 45%。另外，通过各种优化手段，可以让更多任务运行在数据中心，将“双11”平均每万笔交易成本下降了 17%，等等。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;张北.png | center | 600x307&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/168324/1545276157393-f2ef9b76-b2c8-477d-b014-55591e15ad59.png&quot; alt=&quot;张北.png | center | 600x307&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，实施了一系列优化手段之后的计算机集群究竟是什么样子？混部的情况究竟如何？除了文字性的介绍，直接发布数据能够更加拉近我们与学术研究、业界同行之间的距离。为了让有兴趣的学生以及相关研究人员，可以从数据上更加深入地理解大规模数据中心，我们特别发布了这份数据集。数据集中记录了某个生产集群中服务器以及运行任务的详细情况。在数据集中，你可以详细了解到我们是如何通过混部把资源利用率提高到 45%；我们每天到底运行了多少任务；以及业务的资源需求有什么特点，等等。如何使用这份数据集，完全取决于你的需要。&lt;/p&gt;

&lt;p&gt;刚刚发布的 Alibaba Cluster Data  V2018 包含 6 个文件，压缩后大小近 50GB（压缩前 270+GB），里面包含了 4000 台服务器、相应的在线应用容器和离线计算任务长达 8 天的运行情况，具体信息你可以在 GitHub 中找到。&lt;/p&gt;
&lt;p&gt;通过这份数据，你可以：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;了解当代先进数据中心的服务器以及任务运行特点；&lt;/li&gt;
&lt;li&gt;试验你的调度、运筹等各种任务管理和集群优化方面的各种算法并撰写论文；&lt;/li&gt;
&lt;li&gt;利用这份数据学习如何进行数据分析，揭示更多我们自己都未曾发现的规律。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;只看上面这几点，没有接触过类似数据的朋友，可能对于这份数据的用处还是没有概念，下面我举几个简单的例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;电商业务在白天和晚上面临的压力不同，我们如何在业务存在波峰波谷的情况下提高整体资源利用率？&lt;/li&gt;
&lt;li&gt;你知道我们最长的 DAG 有多少依赖吗？&lt;/li&gt;
&lt;li&gt;一个典型的容器存在时间是多久？&lt;/li&gt;
&lt;li&gt;一个计算型任务的典型存在时间是多少？一个 Task 的多个 Instance 理论上彼此很相似，但是它们运行的时间都一样吗？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上，学者们甚至可以用这些数据作出更加精彩地分析。&lt;/p&gt;
&lt;p&gt;2017年，我们曾开放的第一波数据（Alibaba Cluster Data  V2017），已经产生了多篇优秀的学术成果。以下是学者们在论文中引用数据（Alibaba Cluster Data  V2017）的例子，其中不乏被 OSDI 这样顶级学术会议收录的优秀文章。我们期待，未来你也能与我们共同分享你用这份数据产生的成果！&lt;/p&gt;
&lt;p&gt;&quot;LegoOS: A Disseminated, Distributed OS for Hardware Resource Disaggregation, Yizhou Shan, Yutong Huang, Yilun Chen, and Yiying Zhang, Purdue University. OSDI'18&quot; (Best paper award!)&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image | left&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/71100/1545143159999-dca7e03f-2437-4167-9866-1e3cc98002ec.png&quot; alt=&quot;image | left&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&quot;Imbalance in the Cloud: an Analysis on Alibaba Cluster Trace, Chengzhi Lu et al. BIGDATA 2017&quot;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image | left&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/71100/1545142923106-015dbde6-f099-46b9-a088-a7f3202eaa65.png&quot; alt=&quot;image | left&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image | left&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/71100/1545143203858-89941595-cdba-4deb-a182-be0dd379b975.png&quot; alt=&quot;image | left&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&quot;CharacterizingCo-located Datacenter Workloads: An Alibaba Case Study, Yue Cheng, Zheng Chai,Ali Anwar. APSys2018&quot;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image | left&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/71100/1545045184619-ea267343-5d27-4bac-8d5c-b0877765f5d5.png&quot; alt=&quot;image | left&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image | left&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/71100/1545045679125-b9ddd328-3a5c-47f9-8c0c-c04371f3f7bf.png&quot; alt=&quot;image | left&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image | left&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/71100/1545045683466-acf310eb-3442-4e3a-a4e8-e4ea34a1be8f.png&quot; alt=&quot;image | left&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&quot;The Elasticity and Plasticity in Semi-Containerized Co-locating Cloud Workload: aView from Alibaba Trace, Qixiao Liu and Zhibin Yu. SoCC2018&quot;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image | left&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/71100/1545143086358-1da3ca94-812c-475b-b9cc-7601f05aba98.png&quot; alt=&quot;image | left&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image | left&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/71100/1545143092762-ef5319f7-bb08-4f7f-94ce-7d091bc525a4.png&quot; alt=&quot;image | left&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image | left&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/71100/1545143097718-053c95bb-c274-4715-8887-764fd25764d5.png&quot; alt=&quot;image | left&quot;/&gt;&lt;/p&gt;

&lt;p&gt;新版本 V2018 与 V2017 存在两个最大的区别：&lt;/p&gt;
&lt;h4 id=&quot;4&quot;&gt;DAG 信息加入&lt;/h4&gt;
&lt;p&gt;我们加入了离线任务的 DAG 任务信息，据了解，这是目前来自实际生产环境最大的 DAG 数据。&lt;/p&gt;
&lt;p&gt;什么是 DAG？&lt;br/&gt;离线计算任务，例如 Map Reduce、Hadoop、Spark、Flink 中常用的任务，都是以有向无环图（Directed Acyclic Graph，DAG）的形式进行编排的，其中涉及到任务之间的并行、依赖等方面。下面是一个 DAG 的例子。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image | left&quot; src=&quot;https://cdn.nlark.com/lark/0/2018/png/71100/1545038431866-60608cbe-34d1-4385-b499-21f94c154382.png&quot; alt=&quot;image | left&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;5&quot;&gt;规模更大&lt;/h4&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont680764.i1.68dfd099eV77bd&quot;&gt;上一版数据包含了约 1300 台机器在约 24 小时的内容数据，而新版 Cluster Data V2018 中包括了 4000 台机器 8 天的数据。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/680764?utm_content=g_1000032807&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 07:16:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>打开一篇篇 IT 技术文章，你总能够看到“大规模”、“海量请求”这些字眼。如今，这些功能强大的互联网应用，都运行在大规模数据中心上，然而，对于大规模数据中心，你又了解多少呢？实际上，除了阅读一些科技文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10168748.html</dc:identifier>
</item>
<item>
<title>002.Open-Falcon Server部署及Agent监控 - 木二</title>
<link>http://www.cnblogs.com/itzgr/p/10168703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itzgr/p/10168703.html</guid>
<description>&lt;h2 align=&quot;left&quot;&gt;一 前期准备&lt;/h2&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;206&quot;/&gt;&lt;col width=&quot;206&quot;/&gt;&lt;col width=&quot;206&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;4143-1543903159565-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;节点&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;4143-1543903159565-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;IP&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;4143-1543903159565-cell-0-2&quot;&gt;
&lt;p&gt;&lt;span&gt;备注&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;4143-1543903159565-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;falcon&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;4143-1543903159565-cell-1-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;私网：172.24.10.95&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;临时公网：120.132.23.107&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;4143-1543903159565-cell-1-2&quot;&gt;
&lt;p&gt;&lt;span&gt;Open-Falcon服务端&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;4143-1543903159565-cell-2-0&quot;&gt;
&lt;p&gt;&lt;span&gt;node01&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;4143-1543903159565-cell-2-1&quot;&gt;
&lt;p&gt;&lt;span&gt;172.24.10.216&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;4143-1543903159565-cell-2-2&quot;&gt;
&lt;p&gt;&lt;span&gt;被监控端&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;安装git等依赖：yum -y install git telnet&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NTP配置；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SELinux及防火墙关闭。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：对于任何时序性要求高的服务，都建议部署NTP服务。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Open-Falcon，为前后端分离的架构，包含backend 和 frontend两部分：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;安装后端&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;安装前端&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;二 基础环境&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;2.1 安装redis&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# yum install -y redis
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.2 安装数据库&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# yum -y install mariadb mariadb-server
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.3 启动相关服务&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# systemctl start redis
&lt;span&gt;  2&lt;/span&gt; [root@falcon ~]# systemctl enable redis
&lt;span&gt;  3&lt;/span&gt; [root@falcon ~]# systemctl start mariadb
&lt;span&gt;  4&lt;/span&gt; [root@falcon ~]# systemctl enable mariadb
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.4 设置数据库安全性&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# mysql_secure_installation         #设置安全性，并设置数据库root密码
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.5 安装go语言&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# mkdir /gohome
&lt;span&gt;  2&lt;/span&gt; [root@falcon ~]# yum install -y epel-release
&lt;span&gt;  3&lt;/span&gt; [root@falcon ~]# yum install -y golang
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：若yum无法安装可通过以下方式采用二进制安装形式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# wget https://dl.google.com/go/go1.11.2.linux-amd64.tar.gz
&lt;span&gt;  2&lt;/span&gt; [root@falcon ~]# tar -C /usr/local/ -zxvf go1.11.2.linux-amd64.tar.gz
&lt;span&gt;  3&lt;/span&gt; [root@falcon ~]# echo 'export GOROOT=/usr/local/go' &amp;gt;&amp;gt; /etc/profile.d/go.sh
&lt;span&gt;  4&lt;/span&gt; [root@falcon ~]# echo 'export GOBIN=$GOROOT/bin' &amp;gt;&amp;gt; /etc/profile.d/go.sh
&lt;span&gt;  5&lt;/span&gt; [root@falcon ~]# echo 'export GOPKG=$GOROOT/pkg/tool/linux_amd64' &amp;gt;&amp;gt; /etc/profile.d/go.sh
&lt;span&gt;  6&lt;/span&gt; [root@falcon ~]# echo 'export GOARCH=amd64' &amp;gt;&amp;gt; /etc/profile.d/go.sh
&lt;span&gt;  7&lt;/span&gt; [root@falcon ~]# echo 'export GOOS=linux' &amp;gt;&amp;gt; /etc/profile.d/go.sh
&lt;span&gt;  8&lt;/span&gt; [root@falcon ~]# echo 'export GOPATH=/gohome' &amp;gt;&amp;gt; /etc/profile.d/go.sh
&lt;span&gt;  9&lt;/span&gt; [root@falcon ~]# echo 'export PATH=$PATH:$GOBIN:$GOPKG:$GOPATH/bin' &amp;gt;&amp;gt; /etc/profile.d/go.sh
&lt;span&gt; 10&lt;/span&gt; [root@falcon ~]# go version
&lt;span&gt; 11&lt;/span&gt; go version go1.11.2 linux/amd64
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.6 创建Falcon工作目录&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# mkdir -p $GOPATH/src/github.com/open-falcon
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.7 下载Falcon源码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# cd $GOPATH/src/github.com/open-falcon
&lt;span&gt;  2&lt;/span&gt; [root@falcon open-falcon]# git clone https://github.com/open-falcon/falcon-plus.git
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.8 初始化数据库&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon tmp]# cd $GOPATH/src/github.com/open-falcon/falcon-plus/scripts/mysql/db_schema
&lt;span&gt;  2&lt;/span&gt; [root@falcon db_schema]# mysql -h 127.0.0.1 -u root -p123456 &lt;span&gt;&amp;lt;&lt;/span&gt; 1_uic-db-schema.sql
&lt;span&gt;  3&lt;/span&gt; [root@falcon db_schema]# mysql -h 127.0.0.1 -u root -p123456 &lt;span&gt;&amp;lt;&lt;/span&gt; 2_portal-db-schema.sql
&lt;span&gt;  4&lt;/span&gt; [root@falcon db_schema]# mysql -h 127.0.0.1 -u root -p123456 &lt;span&gt;&amp;lt;&lt;/span&gt; 3_dashboard-db-schema.sql
&lt;span&gt;  5&lt;/span&gt; [root@falcon db_schema]# mysql -h 127.0.0.1 -u root -p123456 &lt;span&gt;&amp;lt;&lt;/span&gt; 4_graph-db-schema.sql
&lt;span&gt;  6&lt;/span&gt; [root@falcon db_schema]# mysql -h 127.0.0.1 -u root -p123456 &lt;span&gt;&amp;lt;&lt;/span&gt; 5_alarms-db-schema.sql
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.9 获取rrdtool工具包&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon db_schema]# cd $GOPATH/src/github.com/open-falcon/falcon-plus/
&lt;span&gt;  2&lt;/span&gt; [root@falcon falcon-plus]# go get github.com/open-falcon/rrdlite
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;2.10 编译及打包&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon falcon-plus]# make all
&lt;span&gt;  2&lt;/span&gt; [root@falcon falcon-plus]# make pack
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：编译打包完成后会生产&lt;span&gt;一个open-falcon-v0.2.1.tar.gz的压缩包，表示已经编译和打包完成；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;若编译异常也可以使用官方提供的已编译完成的包：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;https://github.com/open-falcon/falcon-plus/releases/download/v0.2.1/open-falcon-v0.2.1.tar.gz&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;三 部署后端&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;3.1 创建工作目录&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# export FALCON_HOME=/data/falcon
&lt;span&gt;  2&lt;/span&gt; [root@falcon ~]# export WORKSPACE=$FALCON_HOME/open-falcon
&lt;span&gt;  3&lt;/span&gt; [root@falcon ~]# mkdir -p $WORKSPACE
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;3.2 解压二进制包&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# cd $GOPATH/src/github.com/open-falcon/falcon-plus/
&lt;span&gt;  2&lt;/span&gt; [root@falcon falcon-plus]# tar -xzvf open-falcon-v0.2.1.tar.gz -C $WORKSPACE
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;3.2 修改配置文件&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;各模块配置文件路径如下：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;101&quot;/&gt;&lt;col width=&quot;311&quot;/&gt;&lt;col width=&quot;206&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;模块&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;配置文件所在路径&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-0-2&quot;&gt;
&lt;p&gt;&lt;span&gt;备注&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;aggregator  &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-1-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;/data/falcon/aggregator/config/cfg.json&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-1-2&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-2-0&quot;&gt;
&lt;p&gt;&lt;span&gt;graph&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-2-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;/data/falcon/graph/config/cfg.json&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-2-2&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-3-0&quot;&gt;
&lt;p&gt;&lt;span&gt;hbs&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-3-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;/data/falcon/hbs/config/cfg.json&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-3-2&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-4-0&quot;&gt;
&lt;p&gt;&lt;span&gt;nodata&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-4-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;/data/falcon/nodata/config/cfg.json&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-4-2&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-5-0&quot;&gt;
&lt;p&gt;&lt;span&gt;api&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-5-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;/data/falcon/api/config/cfg.json&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-5-2&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-6-0&quot;&gt;
&lt;p&gt;&lt;span&gt;alarm&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-6-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;/data/falcon/alarm/config/cfg.json&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; data-cell-id=&quot;9239-1543911227811-cell-6-2&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# cd $WORKSPACE
&lt;span&gt;  2&lt;/span&gt; [root@falcon open-falcon]# grep -Ilr 3306  ./ | xargs -n1 -- sed -i 's/root:/root:123456/g'
&lt;span&gt;  3&lt;/span&gt; [root@falcon open-falcon]# grep -Ir 3306 ./                     #确认修改
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：由于默认所有配置文件的数据库配置均为空，因此需要将所有配置文件中关于db的用户名和密码进行修改。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;3.3 启动后端模块&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# cd $WORKSPACE
&lt;span&gt;  2&lt;/span&gt; [root@falcon open-falcon]# ./open-falcon start          #启动所有后端模块
&lt;span&gt;  3&lt;/span&gt; [root@falcon open-falcon]# ./open-falcon check          #检查启动情况
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：更多命令使用方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; # ./open-falcon [start|stop|restart|check|monitor|reload] module
&lt;span&gt;  2&lt;/span&gt; # ./open-falcon start agent
&lt;span&gt;  3&lt;/span&gt; [root@falcon open-falcon]# ./open-falcon check
&lt;span&gt;  4&lt;/span&gt;         falcon-graph         UP           17148
&lt;span&gt;  5&lt;/span&gt;           falcon-hbs         UP           17165
&lt;span&gt;  6&lt;/span&gt;         falcon-judge         UP           17178
&lt;span&gt;  7&lt;/span&gt;      falcon-transfer         UP           17187
&lt;span&gt;  8&lt;/span&gt;        falcon-nodata         UP           17199
&lt;span&gt;  9&lt;/span&gt;    falcon-aggregator         UP           17209
&lt;span&gt; 10&lt;/span&gt;         falcon-agent         UP           17220
&lt;span&gt; 11&lt;/span&gt;       falcon-gateway         UP           17232
&lt;span&gt; 12&lt;/span&gt;           falcon-api         UP           17243
&lt;span&gt; 13&lt;/span&gt;         falcon-alarm         UP           17259
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;相关排查log见：$WorkDir/$moduleName/log/logs/xxx.log&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;四 部署前端&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;4.1 创建工作目录&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;见3.1。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.2 下载前端源码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# cd $WORKSPACE
&lt;span&gt;  2&lt;/span&gt; [root@falcon open-falcon]# git clone https://github.com/open-falcon/dashboard.git
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;4.3 安装依赖&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# yum install -y python-virtualenv
&lt;span&gt;  2&lt;/span&gt; [root@falcon ~]# yum install -y python-devel
&lt;span&gt;  3&lt;/span&gt; [root@falcon ~]# yum install -y openldap-devel
&lt;span&gt;  4&lt;/span&gt; [root@falcon ~]# yum install -y mariadb-devel
&lt;span&gt;  5&lt;/span&gt; [root@falcon ~]# yum groupinstall &quot;Development tools&quot; -y
&lt;span&gt;  6&lt;/span&gt; [root@falcon ~]# cd $WORKSPACE/dashboard/
&lt;span&gt;  7&lt;/span&gt; [root@falcon dashboard]# virtualenv ./env
&lt;span&gt;  8&lt;/span&gt; [root@falcon dashboard]# ./env/bin/pip install -r pip_requirements.txt -i https://pypi.douban.com/simple
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;4.4 初始化数据库&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;参考：2.8。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提示：由于前后端部署在同一节点，部署后端过程中已初始化数据库，4.4步骤可跳过。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.5 修改前端dashboard配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# vi /data/falcon/open-falcon/dashboard/rrd/config.py
&lt;span&gt;  2&lt;/span&gt; # portal database
&lt;span&gt;  3&lt;/span&gt; # TODO: read from api instead of db
&lt;span&gt;  4&lt;/span&gt; PORTAL_DB_HOST = os.environ.get(&quot;PORTAL_DB_HOST&quot;,&quot;127.0.0.1&quot;)
&lt;span&gt;  5&lt;/span&gt; PORTAL_DB_PORT = int(os.environ.get(&quot;PORTAL_DB_PORT&quot;,3306))
&lt;span&gt;  6&lt;/span&gt; PORTAL_DB_USER = os.environ.get(&quot;PORTAL_DB_USER&quot;,&quot;root&quot;)
&lt;span&gt;  7&lt;/span&gt; PORTAL_DB_PASS = os.environ.get(&quot;PORTAL_DB_PASS&quot;,&quot;123456&quot;)      #修改数据库密码
&lt;span&gt;  8&lt;/span&gt; PORTAL_DB_NAME = os.environ.get(&quot;PORTAL_DB_NAME&quot;,&quot;falcon_portal&quot;)
&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; # alarm database
&lt;span&gt; 11&lt;/span&gt; # TODO: read from api instead of db
&lt;span&gt; 12&lt;/span&gt; ALARM_DB_HOST = os.environ.get(&quot;ALARM_DB_HOST&quot;,&quot;127.0.0.1&quot;)
&lt;span&gt; 13&lt;/span&gt; ALARM_DB_PORT = int(os.environ.get(&quot;ALARM_DB_PORT&quot;,3306))
&lt;span&gt; 14&lt;/span&gt; ALARM_DB_USER = os.environ.get(&quot;ALARM_DB_USER&quot;,&quot;root&quot;)
&lt;span&gt; 15&lt;/span&gt; ALARM_DB_PASS = os.environ.get(&quot;ALARM_DB_PASS&quot;,&quot;123456&quot;)        #修改数据库密码
&lt;span&gt; 16&lt;/span&gt; ALARM_DB_NAME = os.environ.get(&quot;ALARM_DB_NAME&quot;,&quot;alarms&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：config.py配置文件解析：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;API_ADDR：表示后端api组件的地址，前后端部署在同一台时不需要修改。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.6 放通防火墙&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# firewall-cmd --add-port=8081/tcp --permanent
&lt;span&gt;  2&lt;/span&gt; [root@falcon ~]# firewall-cmd --reload
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;提示：若已关闭防火墙，则跳过此步骤。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.7 启动dashboard&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@falcon ~]# cd /data/falcon/open-falcon/dashboard/
&lt;span&gt;  2&lt;/span&gt; [root@falcon dashboard]# bash control start                     #以生产模式启动
&lt;span&gt;  3&lt;/span&gt; [root@falcon dashboard]# bash control tail                      #查看相关log
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;4.8 测试访问&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;浏览器访问Falcon服务端：http://120.132.23.107:8081&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181204204442464-1391922269.png&quot;&gt;&lt;img title=&quot;04&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181204204443015-339144740.png&quot; alt=&quot;04&quot; width=&quot;531&quot; height=&quot;357&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;五 dashboard管理&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;5.1 注册账号&lt;/h3&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181204204443347-1891676888.png&quot;&gt;&lt;img title=&quot;05&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181204204443815-1553903086.png&quot; alt=&quot;05&quot; width=&quot;404&quot; height=&quot;473&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;dashbord没有默认创建任何账号包括管理账号，需要通过页面进行注册账号。 想拥有管理全局的超级管理员账号，需要手动注册用户名为root的账号（第一个帐号名称为root的用户会被自动设置为超级管理员）。 超级管理员可以给普通用户分配权限管理。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;5.2 登录测试&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;使用5.1所注册账号进行登录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181204204444206-1409515023.png&quot;&gt;&lt;img title=&quot;06&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181204204444496-1515901729.png&quot; alt=&quot;06&quot; width=&quot;1352&quot; height=&quot;566&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;提示：注册账号能够被任何打开dashboard页面的人注册，所以当给相关的人注册完账号后，需要去关闭注册账号功能。只需要去修改api组件的配置文件cfg.json，将signup_disable配置项修改为true，重启api即可。当需要给人开账号的时候，再将配置选项改回去，用完再关掉即可。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;六 Agent独立安装&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;6.1 Agent简介&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;agent用于采集机器负载监控指标，比如cpu.idle、load.1min、disk.io.util等等，每隔60秒push给Transfer。agent与Transfer建立了长连接，数据发送速度比较快，agent提供了一个http接口/v1/push用于接收用户手工push的一些数据，然后通过长连接迅速转发给Transfer。&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;6.2 复制agent包&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;将Falcon服务端的Agent包复制至被监控端node01。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;30.095541401274&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@node01 ~]# mkdir -p /data/falcon/open-falcon/                #node01节点创建工作目录
&lt;span&gt;  2&lt;/span&gt; [root@falcon ~]# cd /data/falcon/open-falcon/
&lt;span&gt;  3&lt;/span&gt; [root@falcon open-falcon]# scp -r agent/ root@172.24.10.216:/data/falcon/open-falcon/
&lt;span&gt;  4&lt;/span&gt; [root@falcon open-falcon]# scp -r open-falcon  &lt;a&gt;root@172.24.10.216:/data/falcon/open-falcon/&lt;/a&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;6.3 修改agent配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@node01 ~]# vi /data/falcon/open-falcon/agent/config/cfg.json
&lt;span&gt;  2&lt;/span&gt; {
&lt;span&gt;  3&lt;/span&gt;     &quot;debug&quot;: true,              # 控制一些debug信息的输出，生产环境通常设置为false
&lt;span&gt;  4&lt;/span&gt;     &quot;hostname&quot;: &quot;&quot;,             # agent采集了数据发给transfer，endpoint就设置为了hostname，默认通过`hostname`获取，如果配置中配置了hostname，就用配置中的
&lt;span&gt;  5&lt;/span&gt;     &quot;ip&quot;: &quot;&quot;,           # agent与hbs心跳的时候会把自己的ip地址发给hbs，agent会自动探测本机ip，如果不想让agent自动探测，可以手工修改该配置
&lt;span&gt;  6&lt;/span&gt;     &quot;plugin&quot;: {
&lt;span&gt;  7&lt;/span&gt;         &quot;enabled&quot;: false,       # 默认不开启插件机制
&lt;span&gt;  8&lt;/span&gt;         &quot;dir&quot;: &quot;./plugin&quot;,      # 把放置插件脚本的git repo clone到这个目录
&lt;span&gt;  9&lt;/span&gt;         &quot;git&quot;: &quot;https://github.com/open-falcon/plugin.git&quot;,     # 放置插件脚本的git repo地址
&lt;span&gt; 10&lt;/span&gt;         &quot;logs&quot;: &quot;./logs&quot;        # 插件执行的log，如果插件执行有问题，可以去这个目录看log
&lt;span&gt; 11&lt;/span&gt;     },
&lt;span&gt; 12&lt;/span&gt;     &quot;heartbeat&quot;: {
&lt;span&gt; 13&lt;/span&gt;         &quot;enabled&quot;: true,        # 此处enabled要设置为true
&lt;span&gt; 14&lt;/span&gt;         &quot;addr&quot;: &quot;172.24.10.95:6030&quot;,    # hbs的地址，端口是hbs的rpc端口
&lt;span&gt; 15&lt;/span&gt;         &quot;interval&quot;: 60,                 # 心跳周期，单位是秒
&lt;span&gt; 16&lt;/span&gt;         &quot;timeout&quot;: 1000                 # 连接hbs的超时时间，单位是毫秒
&lt;span&gt; 17&lt;/span&gt;     },
&lt;span&gt; 18&lt;/span&gt;     &quot;transfer&quot;: {
&lt;span&gt; 19&lt;/span&gt;         &quot;enabled&quot;: true,
&lt;span&gt; 20&lt;/span&gt;         &quot;addrs&quot;: [
&lt;span&gt; 21&lt;/span&gt;             &quot;172.24.10.95:18433&quot;
&lt;span&gt; 22&lt;/span&gt;         ],                            # transfer的地址，端口是transfer的rpc端口, 可以支持写多个transfer的地址，agent会保证HA
&lt;span&gt; 23&lt;/span&gt;         &quot;interval&quot;: 60,       # 采集周期，单位是秒，即agent一分钟采集一次数据发给transfer
&lt;span&gt; 24&lt;/span&gt;         &quot;timeout&quot;: 1000       # 连接transfer的超时时间，单位是毫秒
&lt;span&gt; 25&lt;/span&gt;     },
&lt;span&gt; 26&lt;/span&gt;     &quot;http&quot;: {
&lt;span&gt; 27&lt;/span&gt;         &quot;enabled&quot;: true,              # 是否要监听http端口
&lt;span&gt; 28&lt;/span&gt;         &quot;listen&quot;: &quot;:1988&quot;,
&lt;span&gt; 29&lt;/span&gt;         &quot;backdoor&quot;: false
&lt;span&gt; 30&lt;/span&gt;     },
&lt;span&gt; 31&lt;/span&gt;     &quot;collector&quot;: {
&lt;span&gt; 32&lt;/span&gt;         &quot;ifacePrefix&quot;: [&quot;eth&quot;, &quot;em&quot;],   # 默认配置只会采集网卡名称前缀是eth、em的网卡流量，配置为空就会采集所有的，lo的也会采集。可以从/proc/net/dev看到各个网卡的流量信息
&lt;span&gt; 33&lt;/span&gt;         &quot;mountPoint&quot;: []
&lt;span&gt; 34&lt;/span&gt;     },
&lt;span&gt; 35&lt;/span&gt;     &quot;default_tags&quot;: {
&lt;span&gt; 36&lt;/span&gt;     },
&lt;span&gt; 37&lt;/span&gt;     &quot;ignore&quot;: {                          # 默认采集了200多个metric，可以通过ignore设置为不采集
&lt;span&gt; 38&lt;/span&gt;         &quot;cpu.busy&quot;: true,
&lt;span&gt; 39&lt;/span&gt;         &quot;df.bytes.free&quot;: true,
&lt;span&gt; 40&lt;/span&gt;         &quot;df.bytes.total&quot;: true,
&lt;span&gt; 41&lt;/span&gt;         &quot;df.bytes.used&quot;: true,
&lt;span&gt; 42&lt;/span&gt;         &quot;df.bytes.used.percent&quot;: true,
&lt;span&gt; 43&lt;/span&gt;         &quot;df.inodes.total&quot;: true,
&lt;span&gt; 44&lt;/span&gt;         &quot;df.inodes.free&quot;: true,
&lt;span&gt; 45&lt;/span&gt;         &quot;df.inodes.used&quot;: true,
&lt;span&gt; 46&lt;/span&gt;         &quot;df.inodes.used.percent&quot;: true,
&lt;span&gt; 47&lt;/span&gt;         &quot;mem.memtotal&quot;: true,
&lt;span&gt; 48&lt;/span&gt;         &quot;mem.memused&quot;: true,
&lt;span&gt; 49&lt;/span&gt;         &quot;mem.memused.percent&quot;: true,
&lt;span&gt; 50&lt;/span&gt;         &quot;mem.memfree&quot;: true,
&lt;span&gt; 51&lt;/span&gt;         &quot;mem.swaptotal&quot;: true,
&lt;span&gt; 52&lt;/span&gt;         &quot;mem.swapused&quot;: true,
&lt;span&gt; 53&lt;/span&gt;         &quot;mem.swapfree&quot;: true
&lt;span&gt; 54&lt;/span&gt;     }
&lt;span&gt; 55&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;6.4 启动Agent&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@node01 ~]# cd /data/falcon/open-falcon/
&lt;span&gt;  2&lt;/span&gt; [root@node01 open-falcon]# ./open-falcon start agent
&lt;span&gt;  3&lt;/span&gt; [root@node01 open-falcon]# ./open-falcon monitor agent          #查看运行日志
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;6.5 检查Agent&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; [root@node01 ~]# cd /data/falcon/open-falcon/agent/bin
&lt;span&gt;  2&lt;/span&gt; [root@node01 bin]# ./falcon-agent --check
&lt;span&gt;  3&lt;/span&gt; disk.io  ... ok
&lt;span&gt;  4&lt;/span&gt; memory   ... ok
&lt;span&gt;  5&lt;/span&gt; netstat  ... ok
&lt;span&gt;  6&lt;/span&gt; ss -s    ... ok
&lt;span&gt;  7&lt;/span&gt; kernel   ... ok
&lt;span&gt;  8&lt;/span&gt; net.if   ... ok
&lt;span&gt;  9&lt;/span&gt; loadavg  ... ok
&lt;span&gt; 10&lt;/span&gt; cpustat  ... ok
&lt;span&gt; 11&lt;/span&gt; du -bs   ... ok
&lt;span&gt; 12&lt;/span&gt; df.bytes ... ok
&lt;span&gt; 13&lt;/span&gt; ss -tln  ... ok
&lt;span&gt; 14&lt;/span&gt; ps aux   ... ok
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 align=&quot;left&quot;&gt;七 确认验证&lt;/h2&gt;
&lt;h3 align=&quot;left&quot;&gt;7.1 确认添加&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;浏览器访问Falcon服务端：http://120.132.23.107:8081&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181204204444969-1436153674.png&quot;&gt;&lt;img title=&quot;07&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181204204445250-637202385.png&quot; alt=&quot;07&quot; width=&quot;432&quot; height=&quot;589&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h3 align=&quot;left&quot;&gt;7.2 查看监控项&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;随机查看load.1 min的监控数据，确保所有监控正常。&lt;/span&gt;&lt;/p&gt;
&lt;div align=&quot;left&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181204204445727-1980142367.png&quot;&gt;&lt;img title=&quot;08&quot; src=&quot;https://img2018.cnblogs.com/blog/680719/201812/680719-20181204204446048-1086113484.png&quot; alt=&quot;08&quot; width=&quot;1370&quot; height=&quot;578&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;参考文档：https://www.cnblogs.com/straycats/p/7199209.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://blog.csdn.net/qq_27384769/article/details/79569776&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 07:11:00 +0000</pubDate>
<dc:creator>木二</dc:creator>
<og:description>一 前期准备 节点 IP 备注 falcon 私网：172.24.10.95 临时公网：120.132.23.107 Open-Falcon服务端 node01 172.24.10.216 被监控端</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itzgr/p/10168703.html</dc:identifier>
</item>
<item>
<title>Python3爬虫基础实战篇之机票数据采集 - 一杯闪光喵</title>
<link>http://www.cnblogs.com/lyxdw/p/10168690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyxdw/p/10168690.html</guid>
<description>&lt;h3&gt;项目:艺龙国内机票实时数据爬虫&lt;/h3&gt;
&lt;p&gt;使用模块：requests（请求模块），js2py（js执行模块），json（解析json），xpath（解析网页）。&lt;/p&gt;
&lt;p&gt;项目流程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分析网站数据来源。&lt;/li&gt;
&lt;li&gt;编写爬虫脚本。&lt;/li&gt;
&lt;li&gt;验证数据准确性。&lt;/li&gt;
&lt;li&gt;js逆向破解参数生成。 &lt;/li&gt;
&lt;li&gt;更换请求参数城市（飞机起飞城市和落地城市或日期）测试结果是否正常。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;1.分析网站数据来源&lt;/h3&gt;
&lt;p&gt; 进入艺龙机票列表搜索页，附上链接&lt;a href=&quot;http://flight.elong.com/flightsearch/list?departCity=bjs&amp;amp;arriveCity=sha&amp;amp;departdate=2018-12-24&quot; target=&quot;_blank&quot;&gt;http://flight.elong.com/flightsearch/list?departCity=bjs&amp;amp;arriveCity=sha&amp;amp;departdate=2018-12-2&lt;/a&gt;4,链接参数日期自行更改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224090326594-886542138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般情况数据为调用接口获得，或是在页面中嵌入，这里很明显是调用了接口。&lt;/p&gt;
&lt;p&gt;F12打开开发者工具（谷歌浏览器），选择network中的xhr，然后刷新页面或重新搜索，查看调用的接口。（这一步也可以使用抓包工具，推荐使用Fiddler，网上有许多汉化版的，看个人习惯吧。）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224091019863-1560981082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用了四个接口，点击接口查看返回结果，确定数据来源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224091523751-897761357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到出发机场，航空公司名称之类的英文，ok，就是这个了，点击进入Headers。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224092351350-381516630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224092302137-120831887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 数据来源已经确定，下面我们来构造爬虫请求接口。&lt;/p&gt;
&lt;h3&gt;2.编写爬虫脚本&lt;/h3&gt;
&lt;p&gt;快速上手requests模块,链接已备好　　&lt;a href=&quot;http://docs.python-requests.org/zh_CN/latest/user/quickstart.html&quot; target=&quot;_blank&quot;&gt;http://docs.python-requests.org/zh_CN/latest/user/quickstart.html&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直接上代码（提示：代码中的请求参数grabcode的值需要自己抓取，有时效性，过期无返回结果导致代码报错）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; requests &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入requests模块&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;请求链接&lt;/span&gt;
url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://flight.elong.com/search/ly/rest/list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;构造请求头 接口中请求头有的参数最好全写上,之后再了解这些请求头信息是干什么的,这里不做介绍&lt;/span&gt;
headers =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;请求参数&lt;/span&gt;
data =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&quot;departCode&quot;:&quot;bjs&quot;,&quot;arriveCityCode&quot;:&quot;sha&quot;,&quot;departDate&quot;:&quot;2018-12-24&quot;,&quot;searchType&quot;:&quot;0&quot;,&quot;classTypes&quot;:null,&quot;isBaby&quot;:0}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grabCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;6793819&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;发起请求&lt;/span&gt;
html = requests.post(url, headers=headers,data=&lt;span&gt;data).text
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(html)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224094519487-712360878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有返回结果并且有数据证明我们请求成功了，但是我们还得进一步验证数据准确性。&lt;/p&gt;
&lt;h3&gt;3.验证数据是否准确&lt;/h3&gt;
&lt;p&gt;使用json进一步提取关键数据如航班号，最低价等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; requests &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入requests模块&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; json     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入json&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;请求链接&lt;/span&gt;
url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://flight.elong.com/search/ly/rest/list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;构造请求头 接口中请求头有的参数最好全写上,之后再了解这些请求头信息是干什么的,这里不做介绍&lt;/span&gt;
headers =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;请求参数&lt;/span&gt;
data =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&quot;departCode&quot;:&quot;bjs&quot;,&quot;arriveCityCode&quot;:&quot;sha&quot;,&quot;departDate&quot;:&quot;2018-12-24&quot;,&quot;searchType&quot;:&quot;0&quot;,&quot;classTypes&quot;:null,&quot;isBaby&quot;:0}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grabCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9151048&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;发起请求&lt;/span&gt;
html = requests.post(url, headers=headers,data=&lt;span&gt;data).text
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;json.loads转化json为一个字典   然后我们可以用字典方法取键和值&lt;/span&gt;
html = json.loads(html)[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;flightSelections&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建结果列表&lt;/span&gt;
list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; html:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历所有航班&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; len(i[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Segments&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]) == 1:    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;只提取单程,多程排除&lt;/span&gt;
        flightnumber = i[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Segments&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][0][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FlightNumber&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
        price &lt;/span&gt;= i[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Segments&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][0][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;航班信息字典&lt;/span&gt;
        item =&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;flight&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: flightnumber,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: price,
        }

        list.append(item)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(list)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224111832413-1425862934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和网页价格对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224112116482-97259973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果正确，证明爬取成功。还没完，上面2,3过程提到grabCode参数的时效性，参数过期会导致接口无返回结果，json解析就会抛出异常。&lt;/p&gt;
&lt;h3&gt;4.js逆向分析加密请求参数grabCode的生成&lt;/h3&gt;
&lt;p&gt;接口请求参数中的加密参数都是有迹可循的，前端和后端必须使用相同的加密算法来保证参数的有效性。&lt;/p&gt;
&lt;p&gt;后端代码我们不可能看得到，所以就要从前端来分析，前端通过js调用接口，调用接口的写法有很多种方式，如原生js，ajax，jquery等。&lt;/p&gt;
&lt;h4&gt;查找调用接口js位置：&lt;/h4&gt;
&lt;p&gt;通过关键字grabCode，来查找js调用接口的位置。（这里也可以通过其他方法如请求方式Post来搜索位置）&lt;/p&gt;
&lt;p&gt;F12打开开发者工具，使用全局搜索search。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224132603033-987860256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 搜索参数名称grabCode&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224132800914-1099855297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到了，点击第一个搜索结果，进入查看js，点击左下角的图标格式化js。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224133040855-1677392380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用ctrl+f搜索grabCode的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224133224978-801469514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很清晰的可以看到这里就是使用了ajax调用list接口的方法url(接口地址),params(请求参数),methods(请求方式)。&lt;/p&gt;
&lt;p&gt;grabCode的值是调用了abcdefg函数。（下面我们可以用js断点调试来获取函数abcdefg的位置，或是按照刚才的方法使用全局搜索来查找也可以，调试更方便一点）&lt;/p&gt;
&lt;h4&gt;js断点调试：&lt;/h4&gt;
&lt;p&gt;如图，在grabCode调用方法的行标点击，变成蓝色，表示断点成功，然后刷新页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224134509208-573425103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;搜索结果正在加载被截断，进一步证实了参数生成就是调用函数abcdefg。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224134911541-313101705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个小图标的功能叫”逐语句执行“或者叫”逐步执行“，这是我个人理解的一个叫法，意思就是，每点击它一次，js语句就会往后执行一句，它还有一个快捷键，F10。&lt;/p&gt;
&lt;p&gt;我们点击一下，发现刚才断点的代码已被执行。鼠标箭头悬停在abcdefg函数上，点击方法可以直接跳过去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224135411612-555659028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224140804866-1198871262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图对abcdefg函数做了一个解析，了解生成过程，总结一下就是调用网页源代码中的id为tsd的元素的属性值value，替换字符串中的某个值，并调用eval把字符串执行。&lt;/p&gt;
&lt;p&gt;取消刚才的断点，在如图所示位置打上新断点，刷新页面。F10执行下一句。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224141430132-485482182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和网页源代码对比一下，ok，正确。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224141530317-2019830403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不难看出上面的value值实际为js代码，eval函数会执行这些js代码。&lt;/p&gt;
&lt;h4&gt;模拟参数生成过程：&lt;/h4&gt;
&lt;p&gt;我们来使用python模拟一下他的过程：1.获取网页id==“tsd”的属性value的值。2.替换字符使用replace(&quot;/\)\^-1/gm&quot;, &quot;)&amp;amp;-1&quot;)。3.执行js代码。&lt;/p&gt;
&lt;p&gt;复制value的值，可以去网页，也可以在js中复制（这里复制出来的格式会有错误，导致js不能执行成功，我们直接去网页抓取好了）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224142514400-1637476843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests,js2py
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree
url_list &lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://flight.elong.com/flightsearch/list?departCity=BJS&amp;amp;arriveCity=SHA&amp;amp;departdate=2018-12-24&amp;amp;backdate=&amp;amp;searchType=0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
html_list &lt;/span&gt;=&lt;span&gt; requests.get(url_list).text
html_list &lt;/span&gt;=&lt;span&gt; etree.HTML(html_list)
js &lt;/span&gt;= html_list.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//input[@id=&quot;tsd&quot;]/@value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
js &lt;/span&gt;= js.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/\)\^-1/gm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&amp;amp;-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
code &lt;/span&gt;=&lt;span&gt; js2py.eval_js(js)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(code)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再把这个封装成一个函数来供第二步进行调用，搜索url中的三字码和日期可以用一样的（防止出错）。&lt;/p&gt;
&lt;h3&gt;更换搜索参数城市三字码或日期测试代码是否能正常运行并返回航班及其价格&lt;/h3&gt;
&lt;p&gt;下面附上全部代码，仅供参考学习。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; requests &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入requests模块&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; json     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入json&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; js2py    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入js执行模块&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt; etree &lt;span&gt;#&lt;/span&gt;&lt;span&gt;xpath使用lxml的etree解析&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; ticket_api(a,b,c):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;请求链接&lt;/span&gt;
    url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://flight.elong.com/search/ly/rest/list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;构造请求头 接口中请求头有的参数最好全写上,之后再了解这些请求头信息是干什么的,这里不做介绍&lt;/span&gt;
    headers =&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    }
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;请求参数&lt;/span&gt;
    data =&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&quot;departCode&quot;:&quot;%s&quot;,&quot;arriveCityCode&quot;:&quot;%s&quot;,&quot;departDate&quot;:&quot;%s&quot;,&quot;searchType&quot;:&quot;0&quot;,&quot;classTypes&quot;:null,&quot;isBaby&quot;:0}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(a,b,c),
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;grabCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:grabCode(a,b,c),
    }
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;发起请求&lt;/span&gt;
    html = requests.post(url, headers=headers,data=&lt;span&gt;data).text
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;json.loads转化json为一个字典   然后我们可以用字典方法取键和值&lt;/span&gt;
    html = json.loads(html)[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;flightSelections&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建结果列表&lt;/span&gt;
    list =&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; html:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历所有航班&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; len(i[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Segments&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]) == 1:    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;只提取单程,多程排除&lt;/span&gt;
            flightnumber = i[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Segments&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][0][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FlightNumber&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
            price &lt;/span&gt;= i[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Segments&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][0][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;航班信息字典&lt;/span&gt;
            item =&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;flight&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: flightnumber,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: price,
            }

            list.append(item)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; grabCode(a,b,c):
    url_list &lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://flight.elong.com/flightsearch/list?departCity=%s&amp;amp;arriveCity=%s&amp;amp;departdate=%s&amp;amp;backdate=&amp;amp;searchType=0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(a,b,c)
    html_list &lt;/span&gt;=&lt;span&gt; requests.get(url_list).text
    html_list &lt;/span&gt;=&lt;span&gt; etree.HTML(html_list)
    js &lt;/span&gt;= html_list.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//input[@id=&quot;tsd&quot;]/@value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
    js &lt;/span&gt;= js.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/\)\^-1/gm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&amp;amp;-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    code &lt;/span&gt;=&lt;span&gt; js2py.eval_js(js)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; code

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    a &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bjs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    b &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;czx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;常州czx,上海sha&lt;/span&gt;
    c = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-12-24&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    ticket_api(a,b,c)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1364902/201812/1364902-20181224145314252-2132275790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到这一步，基本上算是完成了。&lt;/p&gt;

&lt;h3&gt;温馨提示&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如果您对本文有疑问，请在评论部分留言，我会在最短时间回复。&lt;/li&gt;
&lt;li&gt;如果本文帮助了您，也请评论关注，作为对我的一份鼓励。&lt;/li&gt;
&lt;li&gt;如果您感觉我写的有问题，也请批评指正，我会尽量修改。&lt;/li&gt;
&lt;li&gt;本文为原创，转载请注明出处。&lt;/li&gt;
&lt;li&gt;本文所有代码仅供学习参考，在爬取的同时考虑对方的服务器承受能力，适可而止。&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Mon, 24 Dec 2018 07:08:00 +0000</pubDate>
<dc:creator>一杯闪光喵</dc:creator>
<og:description>项目:艺龙国内机票实时数据爬虫 使用模块：requests（请求模块），js2py（js执行模块），json（解析json），xpath（解析网页）。 项目流程： 分析网站数据来源。 编写爬虫脚本。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyxdw/p/10168690.html</dc:identifier>
</item>
<item>
<title>海伦的2018 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/10139778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/10139778.html</guid>
<description>&lt;p&gt;小仙女只喝露珠，不吃饭，媛的2018，奋斗和生活两不误，👍👍👍，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201812/628084-20181218202047994-935726336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201812/628084-20181218202109987-372626815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201812/628084-20181218202139238-788045890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201812/628084-20181224144329536-952573809.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;h2&gt;精神胜利法式年度报告&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;最终成绩：及格&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;详细指标：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 完成了每个月读书的小指标的80%（杂七杂八的书全部完成目标，技术书籍阅读进度一言难尽。。。）&lt;/li&gt;
&lt;li&gt; 每年拿到两个证书小目标完成 80%（虽然大都靠运气飘过，还拿了一个获奖证书来凑数，但是马马虎虎就算是我完成了吧。。。至于年初瞄定的两个整数PMP和BEC高级，有缘再见！）&lt;/li&gt;
&lt;li&gt; 每天学点英语，差强人意，算是马马虎虎完成了60%（虽然就是每天读点英文小说，听点周边新闻，有的时候无耻到看英文电影都算上了。。。）&lt;/li&gt;
&lt;li&gt; 减肥三公斤的目标完成60%（虽然我又成功的长回来了，而且又变本加厉胖了一公斤。。。）&lt;/li&gt;
&lt;li&gt; 旅游计划，两次长途旅行，四次短途旅行，完成一塌糊涂，40%（至少团体活动去了西塘，杭州，上海周边。。。公司团队建设去了趟泰国。。。）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;偷偷放上她在苏州拙政园的照片。。。。会不会被打。。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201812/628084-20181221145804824-1283414342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 06:44:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<og:description>小仙女只喝露珠，不吃饭，媛的2018，奋斗和生活两不误，👍👍👍， 精神胜利法式年度报告 最终成绩：及格 详细指标： 完成了每个月读书的小指标的80%（杂</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/10139778.html</dc:identifier>
</item>
<item>
<title>看动画理解「链表」实现LRU缓存淘汰算法 - 五分钟学算法</title>
<link>http://www.cnblogs.com/fivestudy/p/10168320.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fivestudy/p/10168320.html</guid>
<description>&lt;p&gt;前几节学习了「链表」、「时间与空间复杂度」的概念，本节将结合「循环链表」、「双向链表」与 「用空间换时间的设计思想」来设计一个很有意思的缓存淘汰策略：LRU缓存淘汰算法。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;三种最常见的链表结构&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1940317-ecb5b0b31693f2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;三种最常见的链表结构&quot;/&gt;三种最常见的链表结构&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;循环链表的概念&lt;/h3&gt;
&lt;p&gt;如上图所示：单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。&lt;/p&gt;
&lt;p&gt;因此&lt;strong&gt;循环链表是一种特殊的单链表。&lt;/strong&gt;它跟单链表唯一的区别就在于尾结点。它像一个环一样首尾相连，所以叫作「循环链表」。&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;循环链表的特点&lt;/h3&gt;
&lt;p&gt;和单链表相比，循环链表的优点是从链尾到链头比较方便，当要处理的数据具有环型结构特点时，适合采用循环链表。&lt;/p&gt;
&lt;h3 id=&quot;h-2&quot;&gt;双向链表概念&lt;/h3&gt;
&lt;p&gt;双向链表也叫双链表，是链表的一种，它的链接方向是双向的，它的每个数据结点中都包含有两个指针，分别指向直接后继和直接前驱。&lt;/p&gt;
&lt;p&gt;所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。&lt;/p&gt;
&lt;p&gt;双向链表的数据结构中，会有两个比较重要的参数： &lt;code&gt;pre&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pre&lt;/code&gt; 指向前一个数据结构&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next&lt;/code&gt; 指向下一个数据结构&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img title=&quot;单链表与双链表的对比&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1940317-2292ce2e1fee06e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;单链表与双链表的对比&quot;/&gt;单链表与双链表的对比&lt;/p&gt;
&lt;h3 id=&quot;h-3&quot;&gt;双向链表的特点&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;与单链表对比，双链表需要多一个指针用于指向前驱节点，因此如果存储同样多的数据，双向链表要比单链表占用更多的内存空间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;双链表的插入和删除需要同时维护 next 和 prev 两个指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;双链表中的元素访问需要通过顺序访问，支持双向遍历，这就是双向链表操作的灵活性根本&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-4&quot;&gt;双向链表的基本操作&lt;/h3&gt;
&lt;h4 id=&quot;h1&quot;&gt;1.添加元素。&lt;/h4&gt;
&lt;p&gt;与单向链表相对比双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。&lt;/p&gt;
&lt;p&gt;双向链表的添加元素包括头插法和尾插法。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;头插法和尾插法&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1940317-878918a197ccaf31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;头插法和尾插法&quot;/&gt;头插法和尾插法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;头插法：&lt;/strong&gt;将链表的左边称为链表头部，右边称为链表尾部。头插法是将右边固定，每次新增的元素都在左边头部增加。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尾插法：&lt;/strong&gt;将链表的左边称为链表头部，右边称为链表尾部。尾插法是将左边固定，每次新增都在链表的右边最尾部。&lt;/p&gt;
&lt;h4 id=&quot;h2&quot;&gt;2.查询元素&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;查询元素&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1940317-e87f40b55bde4a4c.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;查询元素&quot;/&gt;查询元素&lt;/p&gt;
&lt;p&gt;双向链表的灵活处就是&lt;strong&gt;知道链表中的一个元素结构就可以向左或者向右开始遍历查找需要的元素结构&lt;/strong&gt;。因此对于一个有序链表，双向链表的按值查询的效率比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。&lt;/p&gt;
&lt;h4 id=&quot;h3&quot;&gt;3.删除元素&lt;/h4&gt;
&lt;p&gt;在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;删除元素&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181223102352.gif&quot; alt=&quot;删除元素&quot;/&gt;删除元素&lt;/p&gt;
&lt;p&gt;对于双向链表来说，双向链表中的结点已经保存了前驱结点的指针，删除时不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度。&lt;/p&gt;
&lt;h3 id=&quot;h-5&quot;&gt;双向循环链表&lt;/h3&gt;
&lt;p&gt;&lt;img title=&quot;双向循环链表&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181223103041.png&quot; alt=&quot;双向循环链表&quot;/&gt;双向循环链表&lt;/p&gt;
&lt;p&gt;如图所示，双向循环链表的概念很好理解：「双向链表」 + 「循环链表」的组合。&lt;/p&gt;
&lt;h3 id=&quot;h-6&quot;&gt;缓存淘汰策略&lt;/h3&gt;
&lt;p&gt;缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。&lt;/p&gt;
&lt;p&gt;缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。&lt;/p&gt;
&lt;p&gt;在各个语言的第三方框架中都大量使用到了 LRU 缓存策略。程序员小吴接触到的有Java中的 「 Mybatis 」，iOS中的 「YYCache」与「Lottie」等。&lt;/p&gt;
&lt;h4 id=&quot;hlru&quot;&gt;LRU缓存淘汰算法&lt;/h4&gt;
&lt;p&gt;LRU是最近最少使用策略的缩写，是根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;LRU概念&quot; src=&quot;https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181223111336.gif&quot; alt=&quot;LRU概念&quot;/&gt;LRU概念&lt;/p&gt;
&lt;h3 id=&quot;hlru-1&quot;&gt;链表实现LRU&lt;/h3&gt;
&lt;p&gt;将Cache的所有位置都用双链表连接起来，当一个位置被命中之后，通过调整链表的指向，将该位置调整到链表头的位置，新加入的Cache直接加到链表头中。&lt;/p&gt;
&lt;p&gt;这样，在多次进行Cache操作后，最近被命中的，就会被向链表头方向移动，而没有命中的，而想链表后面移动，链表尾则表示最近最少使用的Cache。&lt;/p&gt;
&lt;p&gt;当需要替换内容时候，链表的最后位置就是最少被命中的位置，我们只需要淘汰链表最后的部分即可。&lt;/p&gt;
&lt;h3 id=&quot;hlru-2&quot;&gt;链表实现LRU动画演示&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果此数据之前已经被缓存在链表中了，通过遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。&lt;/li&gt;
&lt;li&gt;如果此数据没有在缓存链表中，可以分为两种情况：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过动图可以发现，如果缓存空间足够大，那么存储的数据也就足够多，通过缓存中命中数据的概率就越大，也就提高了代码的执行速度。这就是&lt;strong&gt;空间换时间的设计思想&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于程序开发来说，时间复杂度和空间复杂度是可以相互转化的。说通俗一点，就是：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于执行的慢的程序，可以通过消耗内存（即构造新的数据结构）来进行优化；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;而消耗内存的程序，可以通过消耗时间来降低内存的消耗。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本篇文章的动画与动图花了较多时间与精力去处理，如果读者看完之后觉得有所收获，烦请点一下右下角的 「好看」。&lt;/p&gt;
&lt;p&gt;学习愉快：）&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 06:14:00 +0000</pubDate>
<dc:creator>五分钟学算法</dc:creator>
<og:description>前几节学习了「链表」、「时间与空间复杂度」的概念，本节将结合「循环链表」、「双向链表」与 「用空间换时间的设计思想」来设计一个很有意思的缓存淘汰策略：LRU缓存淘汰算法。 三种最常见的链表结构 循环链</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fivestudy/p/10168320.html</dc:identifier>
</item>
<item>
<title>python3高级知识--元类(metaclass)深度剖析 - W-D</title>
<link>http://www.cnblogs.com/wdliu/p/10168169.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wdliu/p/10168169.html</guid>
<description>&lt;h2&gt;一、简介&lt;/h2&gt;
&lt;p&gt;　　在面向对象的程序设计中类和对象是其重要角色，我们知道对象是由类实例化而来，那么类又是怎么生成的呢？答案是通过元类。本篇文章将介绍元类相关知识，并剖析元类生成类的过程，以及元类的使用等内容，希望能帮助到正在学习python的同仁。　&lt;/p&gt;
&lt;h2&gt;一、一切皆对象&lt;/h2&gt;
&lt;p&gt; 　　在python中有这样一句话“一切皆对象”，没错你所知道的dict、class、int、func等等都是对象，让我们来看以下一段代码来进行说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Author:wd&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(object):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(Foo.&lt;span&gt;__class__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(func.&lt;span&gt;__class__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(int.&lt;span&gt;__class__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(func.&lt;span&gt;__class__&lt;/span&gt;.&lt;span&gt;__class__&lt;/span&gt;&lt;span&gt;)

结果：
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 说明：__class__方法用于查看当前对象由哪个类生成的，正如结果所见其中Foo和int这些类(对象)都是由type创建，而函数则是由function类创建，而function类则也是由type创建，究其根本所有的这些类对象都是由type创建。这里的type就是python内置的元类，接下来谈谈type。&lt;/p&gt;
&lt;h2&gt;二、关于type&lt;/h2&gt;
&lt;p&gt; 　　上面我们谈到了所有的类(对象)都是由type生成，那么不妨我们看看type定义，以下是python3.6中内置type定义部分摘抄：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; type(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    type(object_or_name, bases, dict)
    type(object) -&amp;gt; the object's type
    type(name, bases, dict) -&amp;gt; a new type
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; mro(self): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; real signature unknown; restored from __doc__&lt;/span&gt;
        &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        mro() -&amp;gt; list
        return a type's method resolution order
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; []
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从描述信息中我们可以看到，type(object)-&amp;gt;返回对象type类型，也就是我们常常使用该方法判断一个对象的类型，而type(name, bases, dict) -&amp;gt; 返回一个新的类(对象)。&lt;/p&gt;
&lt;p&gt;让我们详细描述下这个语法： &lt;/p&gt;
&lt;div readability=&quot;86.901334729128&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
type(类名,该类所继承的父类元祖,该类对应的属性字典(k,v))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 利用该语法我们来穿件一个类(对象)Foo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Foo=type(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,(object,),{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(Foo)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(Foo.Name)

结果：
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
wd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 当然也可以实例化这个类(对象)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Foo=type(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,(object,),{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})

obj&lt;/span&gt;=&lt;span&gt;Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj.Name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(obj.&lt;span&gt;__class__&lt;/span&gt;&lt;span&gt;)

结果：
wd
&lt;/span&gt;&amp;lt;&lt;span&gt;__main__&lt;/span&gt;.Foo object at 0x104482438&amp;gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这样创建方式等价于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(object):
    Name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实上面的过程也就是我们使用class定义类生成的过程，而type就是python中的元类。&lt;/p&gt;
&lt;h2&gt;三、元类&lt;/h2&gt;
&lt;h3&gt; 什么是元类&lt;/h3&gt;
&lt;p&gt; 经过以上的介绍，说白了元类就是创建类的类，有点拗口，姑且把这里称为可以创建类对象的类。列如type就是元类的一种，其他的元类都是通过继承type或使用type生成的。通过元类我们可以控制一个类创建的过程，以及包括自己定制一些功能。 例如，下面动态的为类添加方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_name(self):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.name)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyType(type):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls, cls_name, bases, dict_attr):
        dict_attr[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;get_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = get_name  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将get_name 作为属性添加到类属性中&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; super(MyType, cls).&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls, cls_name, bases, dict_attr)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Foo(metaclass=&lt;span&gt;MyType):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        self.name &lt;/span&gt;=&lt;span&gt; name


obj &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
obj.get_name()&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用该方法&lt;/span&gt;
&lt;span&gt;结果：
wd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上示例说明：&lt;/p&gt;
&lt;p&gt;1.MyType是继承了type，也就是说继承了其所有的功能与特性，所以它也具有创建类的功能，所以它也是元类；&lt;/p&gt;
&lt;p&gt;2.类Foo中使用了metaclass关键字，表明该类由MyType进行创建。&lt;/p&gt;
&lt;p&gt;3.创建Foo类时候会先执行MyType的__new__方法(后续会这些方法进行更详细的说明)，并接受三个参数，cls_name, bases, dict_attr，在改方法中我们在类属性字典中添加了get_name属性，并将它与函数绑定，这样生成的类中就有了该方法。 &lt;/p&gt;
&lt;h3&gt; 使用元类&lt;/h3&gt;
&lt;p&gt; 　　了解类元类的作用，我们知道其主要目的就是为了当创建类时能够根据需求改变类，在以上的列子中我们介绍了使用方法，其中就像&lt;a href=&quot;https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python&quot;&gt;stackoverflow&lt;/a&gt;中关于对元类的使用建议一样，绝大多数的应用程序都非必需使用元类，并且使用它可能会对你的代码带来一定的复杂性，但是就元类的使用而言其实很简单，其场景在于：&lt;/p&gt;

&lt;p&gt;1.对创建的类进行校验(拦截)；&lt;/p&gt;
&lt;p&gt;2.修改类；&lt;/p&gt;
&lt;p&gt;3.为该类定制功能；&lt;/p&gt;
&lt;p&gt; 使用元类是时候经典类和新式类时候有些不同，新式类通过参数metaclass,经典类通过__metaclass__属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Foo(metaclass=MyType): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;新式类&lt;/span&gt;
    &lt;span&gt;pass&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt; Bar:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 经典类&lt;/span&gt;
    &lt;span&gt;__metaclass__&lt;/span&gt; =&lt;span&gt; MyType
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　在解释元类的时候有提到过，元类可以是type，也可以是继承type的类，当然还可以是函数，只要它是可调用的。但是有个必要的前提是该函数使用的是具有type功能的函数，否则生成的对象可能就不是你想要的(在后续的原理在进行讲解)。以下示例将给出使用函数作为元类来创建类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; class_creater(cls_name, bases, dict_attr):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; type(cls_name, bases, dict_attr)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Foo(metaclass=&lt;span&gt;class_creater):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        self.name&lt;/span&gt;=&lt;span&gt;name


obj&lt;/span&gt;=Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(obj.name) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;原理&lt;/h3&gt;
&lt;p&gt;当我们使用class定义类时候，它会执行以下步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取类名，以示例中class Foo为例,类名是Foo。&lt;/li&gt;
&lt;li&gt;获取父类，默认object，以元祖的形式，如(object,Foo)&lt;/li&gt;
&lt;li&gt;获取类的属性字典(也叫名称空间)&lt;/li&gt;
&lt;li&gt;将这三个参数传递给元类(也就是metaclass参数指定的类)，如果没有metaclass参数则使用type生成类。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在这几个步骤中，前三个步骤没有什么可说的，但是对于元类生成类的这一过程接下来我们将详细介绍。 &lt;/p&gt;
&lt;h3&gt; 元类创建类的过程&lt;/h3&gt;
&lt;p&gt;　　其实如果你对面向对象非常熟悉的话，其过程也是非常容易理解的，在介绍类生成的过程之前，我们需要对三个方法做充分的理解：__init__、__new__、__call__。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;__init__ :通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。触发方式为：类()&lt;/li&gt;
&lt;li&gt;__new__ :通常用于控制生成一个类实例的过程，依照Python官方文档的说法，__new__方法主要是当你继承一些不可变的时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。它是类级别的方法。&lt;/li&gt;
&lt;li&gt;__call__ :当类中有__call__方法存在时候，该类实列化的对象就是可调用的，触发方式为：对象()。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;并且一个类在实例化的过程中执行顺序是先执行__new__在执行__init__(这是重点),以下用一个示例来说明：&lt;/p&gt;
&lt;div readability=&quot;43&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is __init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is __new__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; object.&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is __call__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


obj&lt;/span&gt;=Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化&lt;/span&gt;
obj() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 触发__call__&lt;/span&gt;
&lt;span&gt;
结果：
this &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;
this &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;
this &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 有了这个知识，再来看看使用元类生成类，以下代码定义来一个元类继承来type，我们重写__new__和__init__方法(其实什么也没干)，为了说明类的生成过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyType(type):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, cls_name, bases, cls_attr):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mytype __init__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cls_name, bases)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls, cls_name, bases, cls_attr):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mytype __new__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cls_name, bases)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; super(MyType, cls).&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls, cls_name, bases, cls_attr)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Foo(metaclass=&lt;span&gt;MyType):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is __init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is __new__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; object.&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls)


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;line -------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
obj &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化&lt;/span&gt;
&lt;span&gt;

结果：
Mytype &lt;/span&gt;&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt; Foo ()
Mytype &lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt; Foo ()
line &lt;/span&gt;-------&lt;span&gt;
this &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;
this &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释说明：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;首先metaclass接受一个可调用的对象，而在这里该对象是一个类，也就是说会执行MyType(),并把cls_name,bases,cls_attr传递给MyType，这不就是MyType的示例化过程吗，所以你在结果中可以看到，分割线是在&quot;Mytype __new__”和“Mytype __init__”之后输出，接下来在看MyType。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;MyType元类的实例化过程和普通类一样，先执行自己__new__方法，在执行自己的__init__方法，在这里请注意__new__方法是控制MyType类生成的过程，而__init__则是实例化过程，用于生成类Foo。这样一来是不是对类的生成过程有了非常深刻的认识。 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这还不够清楚，在以上的示例中Foo即是类，也是对象，它是由元类实例化的对象，那它执行Foo(‘wd’)相当于是执行:对象(),即执行的是元类的__call__方法，那么在以上示例中我们在元类中加入__call__方法，看看在执行Foo(‘wd’)会不会调用__call__:&lt;/p&gt;
&lt;div readability=&quot;73&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyType(type):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, cls_name, bases, cls_attr):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mytype __init__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cls_name, bases)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls, cls_name, bases, cls_attr):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mytype __new__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cls_name, bases)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; super(MyType, cls).&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls, cls_name, bases, cls_attr)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mytype __call__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Foo(metaclass=&lt;span&gt;MyType):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is __init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is __new__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; object.&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is __call__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;before -------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
obj &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;after -------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj)
结果：
Mytype &lt;/span&gt;&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt; Foo ()
Mytype &lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt; Foo ()
before &lt;/span&gt;-------&lt;span&gt;
Mytype &lt;/span&gt;&lt;span&gt;__call__&lt;/span&gt;&lt;span&gt;
after &lt;/span&gt;-------&lt;span&gt;
None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　你会发现，当Foo实例化时候执行了元类的__call__,你从python的一切皆对象的方式来看，一切都是顺理成章的，因为这里的Foo其实是元类的对象，对象+()执行元类的__call__方法。请注意，在Foo进行实例化时候返回的对象是None，这是因为__call__方法返回的就是None，所以在没有必要的前提下最好不要随意重写元类的__call__方法，这会影响到类的实例化。__call__方法在元类中作用是控制类生成时的调用过程。&lt;/p&gt;
&lt;p&gt; 　　通过__call__方法我们能得出结果就是__call__方法返回什么，我们最后得到的实例就是什么。还是刚才栗子，我们让Foo实例化以后变成一个字符串：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyType(type):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, cls_name, bases, cls_attr):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mytype __init__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cls_name, bases)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls, cls_name, bases, cls_attr):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; super(MyType, cls).&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls, cls_name, bases, cls_attr)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is wd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt; Foo(metaclass=&lt;span&gt;MyType):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is __init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is __new__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; object.&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is __call__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)



obj &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(obj),obj)

结果：
Mytype &lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt; Foo ()
&lt;/span&gt;&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt; this &lt;span&gt;is&lt;/span&gt; wd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 既然__call__方法返回什么，我们实例化生成的对象就是什么，那么在正常的流程是返回的是Foo的对象，而Foo的对象是由Foo的__new__和Foo的__init__生成的，所以在__call__方法的内部又有先后调用了Foo类的__new__方法和__init__方法，如果我们重写元类的__call__方法，则应该调用对象的__new__和__init__，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyType(type):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, cls_name, bases, cls_attr):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mytype __init__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, cls_name, bases)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls, cls_name, bases, cls_attr):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; super(MyType, cls).&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls, cls_name, bases, cls_attr)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mytype __call__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, )
        obj &lt;/span&gt;= self.&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(self)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self, obj)
        self.&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;(obj, *args, **&lt;span&gt;kwargs)

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Foo(metaclass=&lt;span&gt;MyType):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; object.&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls)


obj &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj.name)
结果：
Mytype &lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt; Foo ()
Mytype &lt;/span&gt;&lt;span&gt;__call__&lt;/span&gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt; &amp;lt;&lt;span&gt;__main__&lt;/span&gt;.Foo object at 0x1100c9dd8&amp;gt;&lt;span&gt;
wd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　同样，当函数作为元类时候，metaclass关键字会调用其对应的函数生成类，如果这个函数返回的不是类，而是其他的对象，那么使用该函数定义的类就得到的就是该对象，这也就是为什么我说使用函数作为元类时候，需要有type功能，一个简单的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(cls_name, bases, dict_attr):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;this is wd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt; Foo(metaclass=&lt;span&gt;func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; object.&lt;span&gt;__new__&lt;/span&gt;&lt;span&gt;(cls)


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(Foo, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, type(Foo)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结果：this is wd | &amp;lt;class 'str'&amp;gt;&lt;/span&gt;
&lt;span&gt;
obj&lt;/span&gt;=Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;    现在说python一切皆对象可以说非常到位了，因为它们要不是类的对象，要不就是元类的对象，除了type。再者元类本身其实是复杂的，只是我们在对这元类生成类的这一过程做了深度的分析，所以在我们编写的程序中可能极少会用到元类，除非有特殊的需求，比如动态的生成类、修改类的一些东西等，当然你想让你的代码看来“复杂”也可以尝试使用。但是在有些情况下(如在文章中提到的几个场景中)使用元类能更巧妙的解决很多问题，不仅如此你会发现元类在很多开源框架中也有使用，例如django、flask，你也可以借鉴其中的场景对自己的程序进行优化改进。&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Mon, 24 Dec 2018 05:46:00 +0000</pubDate>
<dc:creator>W-D</dc:creator>
<og:description>一、简介 在面向对象的程序设计中类和对象是其重要角色，我们知道对象是由类实例化而来，那么类又是怎么生成的呢？答案是通过元类。本篇文章将介绍元类相关知识，并剖析元类生成类的过程，以及元类的使用等内容，希</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wdliu/p/10168169.html</dc:identifier>
</item>
<item>
<title>傻傻分不清的javascript运行机制 - 不做祖国的韭菜</title>
<link>http://www.cnblogs.com/kidflash/p/10168153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kidflash/p/10168153.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;学习到javascript的运行机制时，有几个概念经常出现在各种文章中且容易混淆。Execution Context(执行环境或执行上下文)，Context Stack (执行栈)，Variable Object(VO: 变量对象)，Active Object(AO: 活动对象)，LexicalEnvironment（词法环境），VariableEnvironment（变量环境）等，特别是 VO,AO以及LexicalEnvironment，VariableEnvironment的区别很多文章都没有涉及到。因此我查看了一些国内外的文章，结合自身理解写下了下面的笔记。虽然因为自身不足导致理解上的偏差，但是依然相信读完下文会对理解javascript的一些概念如变量提升，作用域和闭包有很大的帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-执行环境和执行栈&quot;&gt;一, 执行环境和执行栈&lt;/h3&gt;
&lt;p&gt;了解javascript的运行机制，首先必须掌握两个基本的概念。Execution Context(执行环境或执行上下文)和Context Stack (执行栈)&lt;/p&gt;
&lt;h4 id=&quot;何为执行环境执行上下文execution-context&quot;&gt;1. 何为执行环境(执行上下文)(Execution Context)&lt;/h4&gt;
&lt;p&gt;我们知道javascript是单线程语言，也就是同一时间只能执行一个任务。当javascript解释器初始化代码后，默认会进入全局的执行环境，之后每调用一个函数，javascript解释器会创建一个新的执行环境。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    var a = 1;                       // 1.初始化默认进入全局执行环境
    function b() {                   // 3.进入b 的执行环境
        function c() {               // 5. 进入c的执行环境
            ···
        }
        c()                          // 4.在b的执行环境里调用c， 创建c的执行环境
    }
    b()                              // 2. 调用b 创建 b 的执行环境&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行环境的分类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局执行环境：简单的理解，一个程序只有一个全局对象即window对象，全局对象所处的执行环境就是全局执行环境。&lt;/li&gt;
&lt;li&gt;函数执行环境：函数调用过程会创建函数的执行环境，因此每个程序可以有无数个函数执行环境。&lt;/li&gt;
&lt;li&gt;Eval执行环境：eval代码特定的环境。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;如何单线程运行context-stack&quot;&gt;2. 如何单线程运行(Context Stack)&lt;/h4&gt;
&lt;p&gt;从一个简单的例子开始讲起&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function foo(i) {
  if (i &amp;lt; 0) return;
  console.log('begin:' + i);
  foo(i - 1);
  console.log('end:' + i);
}
foo(2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如何存储代码运行时的执行环境(全局执行环境，函数执行环境)呢，答案是执行栈。而栈遵循的是先进后出的原理，javascript初始化完代码后，首先会创建全局执行环境并推入当前的执行栈，当调用一个函数时，javascript引擎会创建新的执行环境并推到当前执行栈的顶端，在新的执行环境中，如果继续发生一个新函数调用时，则继续创建新的执行环境并推到当前执行栈的顶端，直到再无新函数调用。最上方的函数执行完成后，它的执行环境便从当前栈中弹出，并将控制权移交到当前执行栈的下一个执行环境，直到全局执行环境。当程序或浏览器关闭时，全局环境也将退出并销毁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513438/201812/1513438-20181224134118896-1691306122.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此输出的结果为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;begin:2
begin:1
begin:0
end:0
end:1
end:2&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;如何创建执行环境&quot;&gt;3. 如何创建执行环境&lt;/h4&gt;
&lt;p&gt;我们现在知道每次调用函数时，javascript 引擎都会创建一个新的执行环境，而如何创建这一系列的执行环境呢，答案是执行器会分为两个阶段来完成， 分别是创建阶段和激活(执行)阶段。而即使步骤相同但是由于规范的不同，每个阶段执行的过程有很大的不同。&lt;/p&gt;
&lt;h5 id=&quot;es3-规范&quot;&gt;3.1 ES3 规范&lt;/h5&gt;
&lt;p&gt;创建阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.创建作用域链。&lt;/li&gt;
&lt;li&gt;2.创建变量对象VO(包括参数，函数，变量)。&lt;/li&gt;
&lt;li&gt;3.确定this的值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;激活/执行阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;完成变量分配，执行代码。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;es5-规范&quot;&gt;3.2 ES5 规范&lt;/h5&gt;
&lt;p&gt;创建阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.确定 this 的值。&lt;/li&gt;
&lt;li&gt;2.创建词法环境(LexicalEnvironment)。&lt;/li&gt;
&lt;li&gt;3.创建变量环境(VariableEnvironment)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;激活/执行阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;完成变量分配，执行代码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们从规范上可以知道，ES3和ES5在执行环境的创建阶段存在差异，当然他们都会在这个阶段确定this 的值&lt;br/&gt;(关于this 的指向问题我们以后会在专门的文章中分析各种this 的指向问题，这里便不做深究)。我们将围绕这两个规范不同点展开。尽管ES3的一些规范已经被抛弃，但是掌握ES3 创建执行环境的过程依然有助于我们理解javascript深层次的概念。&lt;/p&gt;
&lt;h3 id=&quot;二-variable-objectvo-变量对象active-objectao-活动对象&quot;&gt;二, Variable Object(VO: 变量对象)，Active Object(AO: 活动对象)&lt;/h3&gt;
&lt;h4 id=&quot;基本概念&quot;&gt;2.1 基本概念&lt;/h4&gt;
&lt;p&gt;VO 和 AO 是ES3规范中的概念，我们知道在创建过程的第二个阶段会创建变量对象，也就是VO，它是用来存放执行环境中可被访问但是不能被 delete 的函数标识符，形参，变量声明等，这个对象在js环境下是不可访问的。而AO 和VO之间区别就是AO 是一个激活的VO，仅此而已。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;变量对象（Variable) object）是说JS的执行上下文中都有个对象用来存放执行上下文中可被访问但是不能被delete的函数标示符、形参、变量声明等。它们会被挂在这个对象上，对象的属性对应它们的名字对象属性的值对应它们的值但这个对象是规范上或者说是引擎实现上的不可在JS环境中访问到活动对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;激活对象（Activation object）有了变量对象存每个上下文中的东西，但是它什么时候能被访问到呢？就是每进入一个执行上下文时，这个执行上下文儿中的变量对象就被激活，也就是该上下文中的函数标示符、形参、变量声明等就可以被访问到了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;执行细节&quot;&gt;2.2 执行细节&lt;/h4&gt;
&lt;p&gt;如何创建VO对象可以大致分为四步&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.创建arguments对象&lt;/li&gt;
&lt;li&gt;2.扫描上下文的函数声明(而非函数表达式),为发现的每一个函数，在变量对象上创建一个属性——确切的说是函数的名字——其有一个指向函数在内存中的引用。如果函数的名字已经存在，引用指针将被重写。&lt;/li&gt;
&lt;li&gt;3.扫描上下文的变量声明,为发现的每个变量声明，在变量对象上创建一个属性——就是变量的名字，并且将变量的值初始化为undefined。如果变量的名字已经在变量对象里存在，将不会进行任何操作并继续扫描。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意： 整个过程可以大概描述成： 函数的形参=&amp;gt;函数声明=&amp;gt;变量声明， 其中在创建函数声明时，如果名字存在，则会被重写，在创建变量时，如果变量名存在，则忽略不会进行任何操作。&lt;/p&gt;
&lt;p&gt;一个简单的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function foo(i) {
    var a = 'hello';
    var b = function privateB() {

    };
    function c() {

    }
}

foo(22);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行的伪代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 创建阶段
fooExecutionContext = {
    scopeChain: { ... },
    variableObject: {
        arguments: {
            0: 22,
            length: 1
        },
        i: 22,
        c: pointer to function c()
        a: undefined,
        b: undefined
    },
    this: { ... }
}
// 激活阶段
fooExecutionContext = {
    scopeChain: { ... },
    variableObject: {
        arguments: {
            0: 22,
            length: 1
        },
        i: 22,
        c: pointer to function c()
        a: 'hello',
        b: pointer to function privateB()
    },
    this: { ... }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三-lexicalenvironment词法环境variableenvironment变量环境&quot;&gt;三, LexicalEnvironment(词法环境)，VariableEnvironment（变量环境）&lt;/h3&gt;
&lt;h4 id=&quot;基本概念-1&quot;&gt;3.1 基本概念&lt;/h4&gt;
&lt;p&gt;词法环境和变量环境是ES5以后提到的概念，官方对词法环境的解释如下。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符与特定变量和函数的关联关系。词法环境由环境记录（environment record）和可能为空引用（null）的外部词法环境组成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的理解，词法环境是一个包含标识符变量映射的结构。（这里的标识符表示变量/函数的名称，变量是对实际对象【包括函数类型对象】或原始值的引用）。&lt;/p&gt;
&lt;p&gt;ES3的VO，AO为什么可以被抛弃？个人认为有两个原因，第一个是在创建过程中所执行的创建作用域链和创建变量对象(VO)都可以在创建词法环境的过程中完成。第二个是针对es6中存储函数声明和变量(let 和 const)以及存储变量(var)的绑定，可以通过两个不同的过程(词法环境，变量环境)区分开来。&lt;/p&gt;
&lt;h4 id=&quot;词法环境lexicalenvironment&quot;&gt;3.2 词法环境(lexicalEnvironment)&lt;/h4&gt;
&lt;p&gt;词法环境由两个部分组成&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;环境记录(enviroment record)，存储变量和函数声明&lt;/li&gt;
&lt;li&gt;对外部环境的引用(outer)，可以通过它访问外部词法环境&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对外部环境的引用关系到作用域链，之后再分析，我们先来看看环境记录的分类。&lt;/p&gt;
&lt;p&gt;环境记录分两部分&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;声明性环境记录(declarative environment records)： 存储变量、函数和参数, 但是主要用于函数 、catch词法环境。&lt;br/&gt;注意：函数环境下会存储arguments的值。而详细的过程可以参考VO 的执行细节，基本大同小异&lt;/li&gt;
&lt;li&gt;对象环境记录(object environment records), 主要用于with 和全局的词法环境&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;伪代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 全局环境
GlobalExectionContext = {  
// 词法环境
  LexicalEnvironment: {  
    EnvironmentRecord: {  
    
        ···
    }
    outer: &amp;lt;null&amp;gt;  
  }  
}
// 函数环境
FunctionExectionContext = {  
// 词法环境
  LexicalEnvironment: {  
    EnvironmentRecord: {  
        // 包含argument
        
    }
    outer: &amp;lt;Global or outer function environment reference&amp;gt;  
  }  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;变量环境objectenvironment&quot;&gt;3.3 变量环境(objectEnvironment)&lt;/h4&gt;
&lt;p&gt;变量环境也是个词法环境，主要的区别在于lexicalEnviroment用于存储函数声明和变量（ let 和 const ）绑定，而ObjectEnviroment仅用于存储变量（ var ）绑定。&lt;/p&gt;
&lt;h4 id=&quot;伪代码展示&quot;&gt;3.4 伪代码展示&lt;/h4&gt;
&lt;p&gt;ES5规范下的整个创建过程可以参考下方的伪代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = 20;  
const b = 30;  
var c;

function d(e, f) {  
 var g = 20;  
 return e * f * g;  
}

c = d(20, 30);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 全局环境
GlobalExectionContext = {

  this: &amp;lt;Global Object&amp;gt;,
    // 词法环境
  LexicalEnvironment: {  
    EnvironmentRecord: {  
      Type: &quot;Object&quot;,  // 环境记录分类： 对象环境记录
      a: &amp;lt; uninitialized &amp;gt;,  // 未初始化
      b: &amp;lt; uninitialized &amp;gt;,  
      d: &amp;lt; func &amp;gt;  
    }  
    outer: &amp;lt;null&amp;gt;  
  },

  VariableEnvironment: {  
    EnvironmentRecord: {  
      Type: &quot;Object&quot;,  // 环境记录分类： 对象环境记录
      c: undefined,  // undefined
    }  
    outer: &amp;lt;null&amp;gt;  
  }  
}
// 函数环境
FunctionExectionContext = {  
   
  this: &amp;lt;Global Object&amp;gt;,

  LexicalEnvironment: {  
    EnvironmentRecord: {  
      Type: &quot;Declarative&quot;,  // 环境记录分类： 声明环境记录
      Arguments: {0: 20, 1: 30, length: 2},  // 函数环境下，环境记录比全局环境下的环境记录多了argument对象
    },  
    outer: &amp;lt;GlobalLexicalEnvironment&amp;gt;  
  },

  VariableEnvironment: {  
    EnvironmentRecord: {  
      Type: &quot;Declarative&quot;,  // 环境记录分类： 声明环境记录
      g: undefined  
    },  
    outer: &amp;lt;GlobalLexicalEnvironment&amp;gt;  
  }  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四作用域链&quot;&gt;四,作用域链&lt;/h3&gt;
&lt;p&gt;前面讲创建过程中，我们留下了一个伏笔，ES3规范中有创建作用域链的过程，而ES5中在创建词法环境或变量环境的过程中，也有生成外部环境的引用的过程。那这个过程有什么作用呢。我们通过一个简单的例子来说明。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function one() {

    var a = 1;
    two();

    function two() {

        var b = 2;
        three();

        function three() {

            var c = 3;
            alert(a + b + c); // 6

        }

    }

}

one();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当执行到three 的执行环境时，此时 a和b 都不在c 的变量内，因此作用域链则起到了引用外部执行环境变量的作用。ES3中创建的作用域链如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513438/201812/1513438-20181224134138844-1122856326.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当解释器执行alert(a + b + c)，他首先会找自身执行环境下是否有a这个变量的存在，如果不存在，则通过查看作用域链，判断a是否在上一个执行环境内部。它检查是否a存在于内部，若找不到，则沿着作用域链往上一个执行环境找，直到找到，或者到顶级的全局作用域。同理ES6规范中也可以这样分析。&lt;/p&gt;
&lt;p&gt;因此这会引入一个javascript一个重要的概念，闭包。从上面对执行环境的解释我们可以这样理解，闭包就是内部环境通过作用域链访问到上层环境的变量。因此也存在无法进行变量回收的问题，只要函数的作用域链在，变量的值便因为闭包无法被回收。&lt;/p&gt;
&lt;p&gt;注意： 此作用域链和原型链的作用域链不是同一个概念。&lt;/p&gt;
&lt;h3 id=&quot;五-小结&quot;&gt;五, 小结&lt;/h3&gt;
&lt;p&gt;通过对javascript运行机制的介绍，对一些javasript高级概念有了更深的认识，特别是对一些云里雾里的概念区别有了更深刻的认识。不同规范下，不同概念的解释更有利于深挖javascript底层的执行思想。我相信这是理解javascipt语言最重要的一步。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote readability=&quot;2.6262626262626&quot;&gt;
&lt;p&gt;本文为博主原创文章，转载请注明出处 &lt;a href=&quot;https://juejin.im/post/5c20526b6fb9a049b7805ff9&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5c20526b6fb9a049b7805ff9&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 24 Dec 2018 05:43:00 +0000</pubDate>
<dc:creator>不做祖国的韭菜</dc:creator>
<og:description>学习到javascript的运行机制时，有几个概念经常出现在各种文章中且容易混淆。Execution Context(执行环境或执行上下文)，Context Stack (执行栈)，Variable</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kidflash/p/10168153.html</dc:identifier>
</item>
<item>
<title>Apache Ignite 学习笔记(四): Ignite缓存冗余备份策略 - Dinoroar</title>
<link>http://www.cnblogs.com/peppapigdaddy/p/10095906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peppapigdaddy/p/10095906.html</guid>
<description>&lt;p&gt;Ignite的数据网格是围绕着基于内存的分布式key/value存储能力打造的。当初技术选型的时候，决定用Ignite也是因为虽然同样是key/value存储，它有着和其他key/value存储系统不同的特性。根据官网的介绍，Ignite在设计之初，就是为了能方便的水平扩展而设计的。Ignite将数据分片，每个节点只存储数据的一部分，这样每当有新节点加入时，整个集群可以存储更多的数据。为了提高可用性，Ignite也支持用不同的策略对数据分片进行冗余备份，这样保证数据不会因为集群中一两个节点失效而丢失。另外，和其他key/value缓存系统最大的不同是，Ignite支持用SQL语句对缓存数据进行查询。正是由于有对SQL 99的支持，我们甚至可以把Ignite当做一个分布式内存数据库来使用。&lt;/p&gt;
&lt;p&gt;从这篇文章开始，我们先聚焦在Ignite提供的数据网格服务上，看看同样是基于key/value存储，Ignite的key/value缓存又提供了哪些能力。&lt;/p&gt;
&lt;h2 id=&quot;消失的数据&quot;&gt;消失的数据&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;在介绍Ignite不同的缓存冗余备份模式之前，我们先用上一篇文章的代码来模拟一下在默认配置下，如果Ignite集群中有节点失效，我们的数据是否还完整有效。我们在同一台虚拟机按以下的顺序分别启动server和client实例:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;启动一个server实例，该实例会创建一个“TEST”缓存并写入三条缓存数据。&lt;/li&gt;
&lt;li&gt;再启动一个server实例，该实例会自动加入之前启动的server节点，组成一个Ignite集群。因为该实例创建的缓存名字和写入的缓存数据都一样，所以&quot;TEST&quot;缓存里的数据保持不变。&lt;/li&gt;
&lt;li&gt;启动一个client实例，查询“TEST”缓存里的数据，此时该client应该可以查询到三条之前写入的缓存数据：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;Montreal is in Quebec   
Edmonton is in Alberta   
Markham is in Ontario   
Toronto is in null   &lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;关闭一个server实例，再启动一个client实例做查询，此时我们会发现某些缓存数据消失了。比如在我的环境里，就查不到Markham这条数据了：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;Montreal is in Quebec   
Edmonton is in Alberta   
Markham is in null   
Toronto is in null   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为Ignite将缓存数据分片存储的，即同一缓存中的不同数据存到不同的server节点上，Ignite通过一个哈希算法计算出某个数据分片所属的节点。除了原生的哈希算法，用户也可实现自己的哈希算法来决定数据分片对应的节点。在上面的步骤1中，缓存数据全部存在仅有的唯一一个server实例中。在步骤2中，当有新的server实例加入集群，Ignite通过默认的哈希算法决定哪部分的数据分片应该存到新加入的server实例中，然后将数据在两个实例间重新平衡分布。由于我们采用的是默认的配置，所以每个数据分片只有一份拷贝，这就是为什么当我们关了一个server实例后会发生数据丢失的情况。因此，为了保证数据的高可用，我们必须调整数据分片拷贝的数量。接下来，我们就来看看Ignite提供了哪些对数据分片进行冗余备份的策略，以便用户根据实际需求在性能和数据高可用性之间做选择。&lt;/p&gt;
&lt;h2 id=&quot;ignite缓存数据分片冗余策略&quot;&gt;Ignite缓存数据分片冗余策略&lt;/h2&gt;
&lt;hr/&gt;&lt;h3 id=&quot;local模式&quot;&gt;Local模式&lt;/h3&gt;
&lt;p&gt;我们先从简单的模式说起，Local模式，顾名思义就是缓存的所有数据只保存在本地节点，数据不会分布到其他节点上，也就没有数据分片和数据拷贝这么一说。Local模式的最大好处是它的轻量化，因为没有了数据分片和冗余备份的负担,其非常适合于数据只读模式和需要定期刷新的场景，也适合于作为一个read-through的缓存。除了数据分布不同，采用local模式的缓存和分布式缓存有着相同的功能，比如数据自动清除，过期失效，磁盘交换，数据查询以及事务等特性。&lt;/p&gt;
&lt;h3 id=&quot;replicated模式&quot;&gt;Replicated模式&lt;/h3&gt;
&lt;p&gt;Replicated模式下，缓存数据虽然被均分为多个数据分片，但每个节点上都有该缓存的全部数据分片。下面这张官网图很好的展示了replicated模式的数据分布：&lt;br/&gt;&lt;img src=&quot;https://github.com/codyke/blogs/raw/master/ignite%20study/ignite_study_4/replicated_catche.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在replicated模式下，缓存数据被平分为4个数据分片A、B、C、D。在节点1(JVM1)上有分片A的primary拷贝和B、C、D的backup拷贝。在节点2(JVM2)上有分片C的primary拷贝和A、B、D的backup拷贝。节点3(JVM3)和节点4(JVM4)的情况也类似。关于数据分片的primary和backup拷贝的概念我们在下一篇介绍，这里只要记住当primary拷贝失效了，Ignite可以用backup拷贝恢复数据，保证了数据的高可靠性。所以在replicated模式下，每个节点其实有缓存的所有数据分片拷贝，即便集群里其他节点都失效，Ignite还是可以通过仅存的一个节点提供数据读写服务&lt;/p&gt;
&lt;h3 id=&quot;partitioned模式&quot;&gt;Partitioned模式&lt;/h3&gt;
&lt;p&gt;Partition模式下，缓存数据被均分为多个数据分片，数据分片的拷贝均等的分布在集群的某些节点上。换句话说，和replicated模式最大的不同就是，一个节点上没有全部的缓存数据分片拷贝。让我们借用官网的图来解释一下partitioned模式：&lt;br/&gt;&lt;img src=&quot;https://github.com/codyke/blogs/raw/master/ignite%20study/ignite_study_4/partitioned_cache.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，在partitioned模式下，缓存数据被平分为4个数据分片A、B、C、D，每个数据分片有一份primary拷贝和backup拷贝，所以每个节点只保存两个数据分片的拷贝，比如节点1(JVM1)有分片A的primary分片和分片B的backup分片，节点2(JVM2)有分片C的primary分片和分片A的backup分片。Backup拷贝的数量是用户可配置的，如果配置为0时，代表着一个数据分片没有副本，一旦某个节点挂了，数据就会丢失。如果配置为(集群节点数量-1)，代表着集群的每个节点上都有一份该数据分片的拷贝，这就相当于一种特殊的replicated模式。拷贝数量越多，代表数据约可靠，但也会带来额外的开销，所以我们还是要根据实际的场景和需求来调整拷贝数量。&lt;/p&gt;
&lt;h3 id=&quot;replicated-v.s.-partitioned&quot;&gt;Replicated V.S. Partitioned&lt;/h3&gt;
&lt;p&gt;让我们简单的比较下两种模式的优缺点以及它们适合的场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，从数据的可靠性来说当然是replicated模式占优势，毕竟每个节点都有缓存的所有数据分片，只要集群中有一个节点还能工作，就能从该节点恢复数据。而partitioned模式下，数据的可靠性是和backup数量N相关的，在partitioned模式下，一旦有N+1个节点失效，集群就有可能出现丢失数据的情况。&lt;/li&gt;
&lt;li&gt;其次，从扩展性上看，是partitioned模式优于replicated模式。因为每个节点需要有所有数据分片的拷贝，在replicated模式下，集群所能容纳的数据大小是受单个节点的内存和硬盘(如果启用了Ignite原生的持久化功能)限制的，即便新增节点，也不能提高集群的数据容量。反观partitioned模式，新增加一个节点就可以给集群增加更多的存储能力，容纳更多的数据。&lt;/li&gt;
&lt;li&gt;再次，从读写性能上看，replicated模式适合多读少写的场景，因为每写一份数据，就要同步到集群中所有的节点上，如果节点数量多了，同步的开销还是很可观的。对于读数据，因为每个节点上都有缓存数据的拷贝，所以在replicated模式下的读可以充分利用所有节点的带宽，提供更好的读性能。而Partitioned模式更适合多写少读的场景，因为写数据时需要同步的节点数量要少，所以写性能更好。对于读场景，因为一份数据的拷贝只在集群的几台节点上，所以读性能势必会受影响。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;配置缓存replicatedpartitioned模式&quot;&gt;配置缓存Replicated/Partitioned模式&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;好了，在了解完Ignite缓存不同的数据分片冗余策略后，让我们通过一个实际的例子看看如何在代码或是xml配置文件中配置不同的数据分片冗余策略。我们在上一篇文章的server节点代码上进行改造，大部分逻辑都保持不变，重点注意一下第26行~34行加入的新代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class IgniteCacheOpModeExample {
    public static void main(String[] args) {
        Ignite ignite;
        // 创建一个TEST缓存并写入一些数据, key是城市的名字,value是省的名字
        IgniteCache&amp;lt;String, String&amp;gt; cityProvinceCache;

        if(args.length == 1 &amp;amp;&amp;amp; !args[0].isEmpty())
        {
            //如果启动时指定了配置文件,则用指定的配置文件
            System.out.println(&quot;Use &quot; + args[0] + &quot; to start.&quot;);
            ignite = Ignition.start(args[0]);
            //配置文件中,我们将缓存设置为partitioned模式,backup数量为1
            cityProvinceCache = ignite.getOrCreateCache(&quot;TEST&quot;);
        }
        else
        {
            //如果启动时没指定配置文件,则生成一个配置文件
            System.out.println(&quot;Create an IgniteConfiguration to start.&quot;);
            TcpDiscoverySpi spi = new TcpDiscoverySpi();
            TcpDiscoveryMulticastIpFinder ipFinder = new TcpDiscoveryMulticastIpFinder();
            ipFinder.setMulticastGroup(&quot;224.0.0.251&quot;);
            spi.setIpFinder(ipFinder);
            IgniteConfiguration cfg = new IgniteConfiguration();
            cfg.setDiscoverySpi(spi);
            ignite = Ignition.start(cfg);
            CacheConfiguration&amp;lt;String, String&amp;gt; cacheCfg = new CacheConfiguration(&quot;TEST&quot;);
            // 如果不用配置文件启动,缓存模式被设置为replicated
            cacheCfg.setCacheMode(CacheMode.REPLICATED);
            /* 下面的配置将&quot;TEST&quot;缓存设为partitioned模式,并且设置了backup数量为1,这样保证即使有一个node出现
                故障的情况下,缓存数据还是完整可用的
            cacheCfg.setCacheMode(CacheMode.PARTITIONED);
            cacheCfg.setBackups(1);
             */
            cityProvinceCache = ignite.getOrCreateCache(cacheCfg);
        }

        cityProvinceCache.put(&quot;Edmonton&quot;, &quot;Alberta&quot;);
        cityProvinceCache.put(&quot;Markham&quot;, &quot;Ontario&quot;);
        cityProvinceCache.put(&quot;Montreal&quot;, &quot;Quebec&quot;);

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在调用ignite.getOrCreateCache()函数之前，我们为&quot;TEST&quot;先生成一个CacheConfiguration，然后调用setCacheMode()将其模式设置为REPLICATED模式(在29~33行被注释掉的代码中，是如何设置PARTITIONED模式以及backups数量的代码)，最后再交由Ignite根据configuration生成&quot;TEST&quot;缓存。 当然，和上一篇一样，也可以通过XML文件来配置缓存模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;grid.cfg&quot; class=&quot;org.apache.ignite.configuration.IgniteConfiguration&quot;&amp;gt;
        &amp;lt;property name=&quot;discoverySpi&quot;&amp;gt;
            &amp;lt;bean class=&quot;org.apache.ignite.spi.discovery.tcp.TcpDiscoverySpi&quot;&amp;gt;
                &amp;lt;property name=&quot;ipFinder&quot;&amp;gt;
                    &amp;lt;bean class=&quot;org.apache.ignite.spi.discovery.tcp.ipfinder.multicast.TcpDiscoveryMulticastIpFinder&quot;&amp;gt;
                        &amp;lt;property name=&quot;multicastGroup&quot; value=&quot;224.0.0.251&quot;/&amp;gt;
                    &amp;lt;/bean&amp;gt;
                &amp;lt;/property&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;cacheConfiguration&quot;&amp;gt;
            &amp;lt;bean class=&quot;org.apache.ignite.configuration.CacheConfiguration&quot;&amp;gt;
                &amp;lt;!-- 设置缓存名字. --&amp;gt;
                &amp;lt;property name=&quot;name&quot; value=&quot;TEST&quot;/&amp;gt;
                &amp;lt;!-- 设置缓存模式. --&amp;gt;
                &amp;lt;property name=&quot;cacheMode&quot; value=&quot;PARTITIONED&quot;/&amp;gt;
                &amp;lt;property name=&quot;backups&quot; value=&quot;1&quot;/&amp;gt;
                &amp;lt;!-- 下面将缓存设置为replicated模式 --&amp;gt;
                &amp;lt;!--property name=&quot;cacheMode&quot; value=&quot;REPLICATED&quot;/--&amp;gt;

            &amp;lt;/bean&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在XML文件中，我们加入了cacheConfiguration的配置，为了和代码里创建的缓存名字保持一致，配置里也使用了&quot;TEST&quot;作为缓存名字，&quot;cacheMode&quot;设为PARTITIONED，&quot;backups&quot;值设为了1(每个数据分片除了primay拷贝外，还有额外的一份backup拷贝，即缓存可以允许有一个节点故障而保证缓存数据的完整性)。&lt;/p&gt;
&lt;p&gt;更新了代码和配置文件后，server节点如果制定了XML配置文件启动，生成的缓存为带一个backup的PARTITIONED模式，如果不用XML配置文件，则生成的缓存为REPLICATED模式。无论用哪种方式启动server节点，我们再重复这篇文章开头的那个实验，就会发现即使在一个节点失效的情况下，client节点还是可以访问到缓存中的所有数据，不会再出现丢数据的情况了。在实际使用过程中，正确的配置缓存的冗余模式直接影响到Ignite集群数据的高可用性。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;这篇文章我们介绍了Ignite集群中数据分片的不同冗余策略，在实际的使用过程中，不同的策略会直接影响集群中数据的高可用性和读写性能，所以理解不同的策略的优缺点，是使用好Ignite数据网格集群的第一步。 &lt;strong&gt;这篇文章里用到的例子的完整代码和maven工程可以在&lt;a href=&quot;https://gitlab.com/codyke/ignite-blog-example-codes/tree/master/ignite-cache-operation-mode-example&quot;&gt;这里&lt;/a&gt;找到。 Server对应的xml配置文件在src/main/resources目录下。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下一篇，我们将继续了解一下Ignite针对不同的冗余策略提供的功能，比如数据分片由于节点失效出现丢失时的行为，primary拷贝和backup拷贝之前的同步等。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 05:39:00 +0000</pubDate>
<dc:creator>Dinoroar</dc:creator>
<og:description>Ignite将缓存数据分片存储在不同的集群节点上，并且提供了不同的数据分片冗余策略，本篇文章介绍了不同的冗余策略会如何影响数据的可用性以及读写性能。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peppapigdaddy/p/10095906.html</dc:identifier>
</item>
<item>
<title>大话推荐系统 - seshine</title>
<link>http://www.cnblogs.com/seshine/p/10168051.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/seshine/p/10168051.html</guid>
<description>&lt;p&gt;继上一次发原创到现在已经有相当一段时间了，刚进入新公司不久，主要在熟悉业务和整理规划，加上目前负责搜索和推荐两块业务，较之前稍微忙些，所以属于比较低产的状态，当然马云大大说了：“优秀的人大多都是从自己身上找问题”，为了赶上优秀人群的脚步，我也好好反省自己，重要的事情心中默念三遍：是我太懒了！是我太懒了！是我太懒了！&lt;/p&gt;

&lt;p&gt;好了，言归正传～&lt;/p&gt;
&lt;p&gt;今天主要跟大家聊聊&lt;strong&gt;推荐系统&lt;/strong&gt;，可能有部分同学不是很了解推荐系统到底是如何推荐的，不用担心，先给大家介绍几个推荐系统的应用场景&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;（1）购物类app：首页底部“为您推荐/猜您喜欢”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   场景：用户打开首页浏览时，用户在没有具体目的逛（有具体目的一般通过搜索分发了），这时给用户进行推荐，用户在逛的过程中发现和自己兴趣可能相关的物品，可以直接进行查看；从展示层面来看，推荐的是商品，用户看到喜欢的商品可以直接点击进入到详情页，极大缩短用户购买路径（相对于卖场入口来说）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qicfKEuU8mONCl5VmmGfHufMaAVyUWFpIEs0K6BDbcd5zpwNFozBiaLIBRpnpsKy1GMkLfoMzV4slmABfYtTCVpg/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;346&quot; height=&quot;616&quot; data-ratio=&quot;1.7786666666666666&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;

&lt;p&gt;京东首页推荐feed流&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qicfKEuU8mOPusLBJc0rba0cgbcc12K4Czicjs3YSRZKeH3Sf8yvJvI9W50NMwVHEQaKKCxmjaYnczhqz10SEpbw/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;383&quot; height=&quot;681&quot; data-ratio=&quot;1.7786666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;

&lt;p&gt;天猫首页推荐feed流&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）购物类app：购物车底部“为您推荐/猜您喜欢”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;场景：用户进入到购物车后，准备下单或只是查看购物车（先看到想买的先收入到购物车，然后最后结账之间的这段时间中会偶尔进来看看），这时底部的推荐则是推荐和购物车里商品相关的商品或者用户有较大可能购买的商品&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此处敲黑板（重点）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首页的推荐和购物车里的推荐商品看似形式一样，但是这两处的场景细分后会发现很不一样  &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;  首页需要对用户行为进行更大范围的推荐，用户在首页的目的可能是多种多样，所以用户的浏览、收藏、搜索查看等都可以作为用户的行为特征，进而进行推荐&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;  购物车页，用户在查看时，目的会更清晰些，带有下单或者查看购物车物品等目的，这时推荐如果范围过粗则可能增加用户的浏览成本，效率过低，故这里可以针对一些用户类似购买或下单的行为进行推荐，如购买、复购次数高（当然复购是有些条件和细分，这个在以后的文章再进行详细描述），同时也可以从另一个角度进行推荐，如和购物车相关的商品&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qicfKEuU8mOPusLBJc0rba0cgbcc12K4C9bWaNcj7frLr5VUQ3xxNcygRayktCOcd95SD1iaeQMdsADrkRzLgSFw/640?wx_fmt=jpeg&quot; alt=&quot;&quot; width=&quot;442&quot; height=&quot;740&quot; data-ratio=&quot;1.6733333333333333&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;

&lt;p&gt;京东购物车推荐feed流&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qicfKEuU8mONCl5VmmGfHufMaAVyUWFpIey2cOWHGl57ZjszmsYLXqibBu0ibEATRP60pIsfmSWDSI4UnV2jQ0SAw/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;434&quot; height=&quot;726&quot; data-ratio=&quot;1.6737089201877935&quot; data-type=&quot;png&quot; data-w=&quot;852&quot;/&gt;&lt;/p&gt;

&lt;p&gt;天猫购物车推荐feed流&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;（3）内容类app：知乎首页推荐&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;场景：用户在首页浏览内容，需要更符合用户兴趣点的内容，减少无关内容的曝光&lt;/p&gt;
&lt;p&gt;知乎app首页默认打开现实“推荐”，而不是“关注”等其他tab，说明从平台角度来说，认为推荐要比关注等其他tab更加重要，那么如何衡量重要这个角度呢，可能有以下几点：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;触达&lt;/strong&gt;：平台可以在“推荐”中非常自然的发表平台想让用户看到的内容（如图中第一条内容（没有特别明显特征）：《2018，年度盘点》），而其他tab中平台触达则不是这么自然&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;自信&lt;/strong&gt;：平台有自信，相信推荐的内容要比用户关注的内容更符合用户的兴趣点，“关注”下的内容不像“推荐”下具有多重维度的商品召回、筛选、过滤以及排序，而“推荐”下的内容则是基于对用户数据的分析，做到比你更懂你&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;多样&lt;/strong&gt;：推荐的角度更加多样，在保证内容相关性的基础上，可以做到更加多样，更加新颖&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qicfKEuU8mOPusLBJc0rba0cgbcc12K4CpWvp8yBApngDiap2icb418Z8hNZpha8jaOGwlJzJmZBwdiaxZCSPHloqw/640?wx_fmt=jpeg&quot; alt=&quot;&quot; width=&quot;404&quot; height=&quot;676&quot; data-ratio=&quot;1.6746666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;

&lt;p&gt;知乎首页推荐feed流&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;（4）内容类app：推荐关注人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;场景：人类是具有社会社交属性的生物，人类之间的彼此的关联关系是社会中最重要的关系之一，你关注的一个话题或者内容，和你关注同一个话题或内容的人和有可能和你最近关注的领域具有一定的重合，或者你朋友认识的人很有可能是你认识的人等等&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qicfKEuU8mONCl5VmmGfHufMaAVyUWFpISYAmcdc1qDL0qZIkbjVY18xX9WqxuGh0icYvFTNOeribBhU91gmGoO1w/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;379&quot; height=&quot;633&quot; data-ratio=&quot;1.6693333333333333&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
&lt;p&gt;知乎“发现知友”&lt;/p&gt;
&lt;p&gt;基于我关注的人的关注进行推荐&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qicfKEuU8mONCl5VmmGfHufMaAVyUWFpILRzF9aBfLBFXslDYqtD8Y6S4vsKMjmVMJe1VpnwXp2RF7MNUpAHJxA/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;379&quot; height=&quot;634&quot; data-ratio=&quot;1.672&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;

&lt;p&gt;QQ“新好友”&lt;/p&gt;
&lt;p&gt;基于我好友的好友进行推荐&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）视频类app：抖音推荐&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;场景：用户打开应用户，直接看到推荐内容，同时提供非常简单的操作，降低用户对视频反馈成本，同时降低用户注意力分散，让用户打开后不用选择，直接看到内容，提升沉浸式体验，这里推荐也从多个角度进行推荐，地理位置（可能通过地理标签形式实现，如喜欢过的一个视频具有典型的地区特征，那么会推送和该地区相关的其他内容），兴趣点（如点赞，分享等），热点内容（火爆）等等&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qicfKEuU8mONCl5VmmGfHufMaAVyUWFpInGZ7ZvSrKaWxXFIHgDTzTn6u6WdH5iaZs1iacedK92XVnWSNPrUUvb8Q/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;633&quot; data-ratio=&quot;1.7786666666666666&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;

&lt;p&gt;抖音首页推荐视频feed流&lt;/p&gt;

&lt;p&gt;说完了场景，是不是感觉到其实我们和推荐系统并不遥远，甚至天天接触，那么我们再来讲讲推荐引擎的架构，来看看推荐系统是如何给用户进行推荐的（如下图）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qicfKEuU8mONCl5VmmGfHufMaAVyUWFpIrrI4ibPB9wMmadI7GjcNDyemOFicLZjMIXhgL0HOve3QU9YwZClLvnkg/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.564176245210728&quot; data-type=&quot;png&quot; data-w=&quot;2088&quot;/&gt;&lt;/p&gt;

&lt;p&gt;推荐引擎架构图&lt;/p&gt;

&lt;p&gt;推荐引擎构成主要由四部分构成（书上是三部分，自己扩充了一些），如图所示（左侧为召回&amp;amp;打分，右侧为排序&amp;amp;Rerank）：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;召回&lt;/strong&gt;：从所有物品集中选择出符合要求的物品集，明确物品界限&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;打分&lt;/strong&gt;：对召回的物品集从各角度（多维度）进行评判打分，多维度赋予不同的权重，给物品打上不同的分数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;排序&lt;/strong&gt;：对打分了的物品进行排序，根据分数高低进行排序，输出初始的推荐结果&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Rerank&lt;/strong&gt;：根据用户的反馈（如收藏、喜欢等）以及物品的属性（如新品等）对物品再进行一轮分数加成，最后得到新的得分，根据新的得分进行排序，输出最终的推荐结果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;图中对应了四部分（ABCD）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：用户特征提取&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qicfKEuU8mONCl5VmmGfHufMaAVyUWFpIDtl3Xyibngo4EJqc5EmahTdCluSIRMjp4GE74XRfELFwofRXmQnWNhA/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;488&quot; height=&quot;252&quot; data-ratio=&quot;0.5177514792899408&quot; data-type=&quot;png&quot; data-w=&quot;676&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对用户行为进行分析提取，选取用户行为中最能代表用户意图的行为，搭建特征工程，用户的特征不是一尘不变的，需要定期更新和维护，用户行为具有&lt;/p&gt;
&lt;p&gt;（1）行为重复性（如多次购买，多次分享等）&lt;/p&gt;
&lt;p&gt;（2）时间递减性（近期浏览比早期浏览更能代表用户近期关注点）&lt;/p&gt;
&lt;p&gt;（3）行为程度性（购买比浏览要更重要）&lt;/p&gt;
&lt;p&gt;（4）行为多样性（用户行为非常多，如何选择是决定推荐效果的关键因素）&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;B：特征-物品关联构造&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qicfKEuU8mONCl5VmmGfHufMaAVyUWFpIdt6U5ZtJBEPYAh5jFuiax5KQlDz0RUAkctLiaNxPjRCZangDqtBoyC8Q/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;546&quot; height=&quot;345&quot; data-ratio=&quot;0.6320474777448071&quot; data-type=&quot;png&quot; data-w=&quot;674&quot;/&gt;&lt;/p&gt;

&lt;p&gt;用户对应的特征提取后，形成特征向量，接下来就是构造特征相关的物品列表&lt;/p&gt;
&lt;p&gt;用户对应的不同行为，产生了一系列行为物品集（一个行为对应的物品，如浏览这个行为，对应的物品集就是浏览了哪些商品），这就是相关表&lt;/p&gt;
&lt;p&gt;图中的“候选物品集”即一开始确定的物品边界（如推荐商品必须是可购买的，不能是下架或者无货状态的）&lt;/p&gt;
&lt;p&gt;在候选物品集基础上，结合用户特征向量和相关表数据，确定好特征物品-相关推荐物品集，同时给物品按照特征对物品影响的重要程度来对物品打分&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C：排序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qicfKEuU8mONCl5VmmGfHufMaAVyUWFpI3uqqZbJJWTGdMWmcRPqnjugM3w4V66iayZvGLiajmibib1BiaKqhxdOV9fw/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;629&quot; height=&quot;327&quot; data-ratio=&quot;0.518840579710145&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;

&lt;p&gt;针对打分好的物品按照得分高低进行排序，得到初始的推荐结果&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;D：Rerank&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qicfKEuU8mONCl5VmmGfHufMaAVyUWFpIHicKRIPfkEpeJTn6REGibe2YF3MnutQbfJ3VTsSa6uc3ArdDUHSCG6Vw/640?wx_fmt=png&quot; alt=&quot;&quot; width=&quot;613&quot; height=&quot;343&quot; data-ratio=&quot;0.5603644646924829&quot; data-type=&quot;png&quot; data-w=&quot;878&quot;/&gt;&lt;/p&gt;

&lt;p&gt;根据用户对物品的反馈（如收藏、喜欢、不感兴趣、退货等）和物品的属性（物品所在地区、物品上线时间、是否是耐用品等）给初始的推荐结果进行再一轮的分数加成（如用户评价五星的商品，给该物品的分数提权加分），最后得到最新得分结果，按照得分高低，得到最终的推荐结果&lt;/p&gt;

&lt;p&gt;随着用户需求更加多样化，更加个性化，传统推荐（千人一面/千人十面）逐步转型成个性化推荐（千人千面），凭借对数据的分析，用户行为特征提取，特征-物品的关联，再根据用户反馈等来确定最后的推荐结果&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 05:15:00 +0000</pubDate>
<dc:creator>seshine</dc:creator>
<og:description>继上一次发原创到现在已经有相当一段时间了，刚进入新公司不久，主要在熟悉业务和整理规划，加上目前负责搜索和推荐两块业务，较之前稍微忙些，所以属于比较低产的状态，当然马云大大说了：“优秀的人大多都是从自己</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/seshine/p/10168051.html</dc:identifier>
</item>
<item>
<title>java反射+注解实现Entity类与Dto类相互转换 - Mr_Precious</title>
<link>http://www.cnblogs.com/scale-lai/p/10164634.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/scale-lai/p/10164634.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;strong&gt;序言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;近期在工作中管理代码时发现，在项目中从Dao层到Service层数据传递中通过大量的get(),set()方法去一个一个的去拿值去赋值，导致代码篇幅过长，对此甚是讨厌，并且严重消耗开发时间。起初找过些关于这块的资料，现在大部分都是Entity类和Dto类的属性名相同的前提下，利用反射实现，太局限了，如果要改成同名，按目前项目的程度去整改工作量太大，不现实。后面看了Spring注解的实现，然后结合找到反射实现资料，突想奇发尝试着用自定义注解+反射方式的去实现，事实证明这方法是可行的。故分享至此，希望能帮到大家。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;整体实现三步骤：1.自定义注解 2.工具类方法实现反射 3.使用（测试）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.自定义注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; import java.lang.annotation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; @Target({ElementType.FIELD,ElementType.TYPE}) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Target 注解的使用域，FIELD表示使用在属性上面，TYPE表示使用在类上面&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; @Retention(RetentionPolicy.RUNTIME) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Retention 设置注解的生命周期 ，这里定义为RetentionPolicy.RUNTIME 非常关键&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; @interface RelMapper {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义属性&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     String value() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     String type() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; value : status(标记属性值为Y/N的属性) / date(标记属性类型为时间) &lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自定义属性，大家可以根据自己项目中的需求增加不同的属性。&lt;/p&gt;
&lt;p&gt; 2.工具类方法实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import java.lang.reflect.Field;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import java.sql.Timestamp;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import java.util.Date;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import org.apache.commons.lang.StringUtils;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import com.ctccbs.common.annotation.RelMapper;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RelationMapperUtils {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * Entity and Dto Mapper  
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * @param entry
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * @param dto
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * @param enToDto  
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     *             ture  : Entity To Dto (defult)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     *             false : Dto To Entry
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     *     Rule: 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     *         实现相互转换前提: Dto field name(dto和entry的field name相同并且 类上有@RelMapper) 或 field的@RelMapper(value=&quot;Entity field name&quot;) 满足其一即可转换  
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * @return
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * @throws Exception
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object entryAndDtoMapper(Object entity, Object dto) throws Exception{
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; EnAndDtoMapper(entity, dto,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object entryAndDtoMapper(Object entity, Object dto,boolean enToDto) throws Exception{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; EnAndDtoMapper(entity, dto,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;last version &lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object EnAndDtoMapper(Object entry, Object dto,boolean enToDto) throws Exception{
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(enToDto == &lt;span&gt;true&lt;/span&gt; ? entry == &lt;span&gt;null&lt;/span&gt; : dto == &lt;span&gt;null&lt;/span&gt;){ &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;}
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         Class&amp;lt;? extends Object&amp;gt; entryclazz = entry.getClass();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取entity类&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         Class&amp;lt;? extends Object&amp;gt; dtoclazz = dto.getClass();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取dto类&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         boolean dtoExistAnno = dtoclazz.isAnnotationPresent(RelMapper.&lt;span&gt;class&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断类上面是否有自定义注解&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         Field [] dtofds = dtoclazz.getDeclaredFields();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dto fields &lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         Field [] entryfds = entryclazz.getDeclaredFields();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;entity fields&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         Method entrys[] = entryclazz.getDeclaredMethods();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;entity methods&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         Method dtos[] = dtoclazz.getDeclaredMethods();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dto methods&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         String mName,fieldName,dtoFieldType=&lt;span&gt;null&lt;/span&gt;,entFieldType=&lt;span&gt;null&lt;/span&gt;,dtoMapName = &lt;span&gt;null&lt;/span&gt;,dtoFieldName =&lt;span&gt;null&lt;/span&gt;;Object value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(Method m : (enToDto ? dtos : entrys)) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当 enToDto=true 此时是Entity转为Dto，遍历dto的属性&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;((mName=m.getName()).startsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只进set方法&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                 fieldName = mName.toLowerCase().charAt(&lt;span&gt;3&lt;/span&gt;) + mName.substring(&lt;span&gt;4&lt;/span&gt;,mName.length());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过set方法获得dto的属性名&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                tohere:
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field fd: dtofds) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     fd.setAccessible(&lt;span&gt;true&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;setAccessible是启用和禁用访问安全检查的开关&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(fd.isAnnotationPresent(RelMapper.&lt;span&gt;class&lt;/span&gt;)||dtoExistAnno){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断field上注解或类上面注解是否存在
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取与Entity属性相匹配的映射值(两种情况：1.该field上注解的value值(Entity的field name 和Dto 的field name 不同)  2.该field本身(本身则是Entity的field name 和Dto 的field name 相同))&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                         dtoMapName = fd.isAnnotationPresent(RelMapper.&lt;span&gt;class&lt;/span&gt;) ? (fd.getAnnotation(RelMapper.&lt;span&gt;class&lt;/span&gt;).value().toString().equals(&lt;span&gt;&quot;&quot;&lt;/span&gt;)?fd.getName().toString():fd.getAnnotation(RelMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).value().toString()):fd.getName().toString();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;(((enToDto ?&lt;span&gt; fd.getName() : dtoMapName)).toString().equals(fieldName)) { 
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                             dtoFieldType = fd.getGenericType().toString().substring(fd.getGenericType().toString().lastIndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取dto属性的类型(如 private String field 结果 = String)&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;                             &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field fe : entryfds) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                                 fe.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt;(fe.getName().toString().equals(enToDto ? dtoMapName : fieldName) ) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历Entity类的属性与dto属性注解中的value值匹配&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;                                     entFieldType = fe.getGenericType().toString().substring(fe.getGenericType().toString().lastIndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Entity类属性类型&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;                                     dtoFieldName = enToDto ?&lt;span&gt; dtoMapName : fd.getName().toString();
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt; tohere;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                                }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(dtoFieldName!= &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !dtoFieldName.equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt;(Method md : (enToDto ?&lt;span&gt; entrys : dtos)) {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;(md.getName().toUpperCase().equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;dtoFieldName.toUpperCase())){
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                             dtoFieldName = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;(md.invoke(enToDto ? entry : dto) == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;break&lt;/span&gt;;} &lt;span&gt;//&lt;/span&gt;&lt;span&gt;去空操作
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Entity类field 与Dto类field类型不一致通过TypeProcessor处理转换&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;                             value = (entFieldType.equals(dtoFieldType))? md.invoke(enToDto ? entry : dto) :TypeProcessor(entFieldType, dtoFieldType,md.invoke(enToDto ? entry : dto),enToDto ? &lt;span&gt;true&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                             m.invoke(enToDto ? dto : entry, value); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到field的值 通过invoke()赋值给要转换类的对应属性&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;                             value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;                             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; enToDto ?&lt;span&gt; dto : entry;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;     
&lt;span&gt;79&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;类型转换处理&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object TypeProcessor(String entFieldType,String dtoFieldType, Object obj,boolean enToDto) {
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(entFieldType.equals(dtoFieldType)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;         
&lt;span&gt;83&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;entFieldType.equals(dtoFieldType)) {
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(entFieldType) {
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; (enToDto)?&lt;span&gt;TypeConverter.dateToString((Date) obj):TypeConverter.stringToDate(obj.toString());
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Timestamp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; TypeConverter.timestampToTimestampString((Timestamp)obj);
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Integer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; (enToDto) ?&lt;span&gt; obj.toString() : Integer.parseInt((String)obj) ;
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt; &lt;span&gt;        }&lt;/span&gt;
&lt;span&gt;93&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
&lt;/span&gt;&lt;span&gt;94&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上面EnAndDtoMapper（）方法的实现是Entity和Dto之间互相转换结合在一起，enToDto = true 表示的是Entity转Dto实现，false则相反。&lt;/p&gt;
&lt;p&gt;3. 如何使用？&lt;/p&gt;
&lt;p&gt;　　1）Entity类 与 Dto类对应&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1558093/201812/1558093-20181224114411694-828259944.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Entity数据转成Dto数据集&lt;/span&gt;
        Person person =&lt;span&gt; dao.getPersonRecord();
        RelationMapperUtils.entryAndDtoMapper(person,&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PersonDto());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Dto数据转成Entity数据&lt;/span&gt;
        RelationMapperUtils.entryAndDtoMapper(&lt;span&gt;new&lt;/span&gt; Person(),personDto,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上便能自动实现数据的转换，大量减少get,set的代码，省事！！！ &lt;br/&gt;大家如果还有其他的需求都可以往方法中添加，来达到适合项目的需求，整体下来扩展性算还不错。&lt;/p&gt;
&lt;p&gt;希望对大家有所帮助，有不解或不足的代码欢迎点出。大家一起进步&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;最后，本博主是入博不久，会定期更新所学所感所获，希望各位爷喜欢，一起成长！！！喜欢的可以关注喔&lt;/p&gt;
&lt;p&gt;-------------------------------&lt;/p&gt;
&lt;p&gt;喜欢老夫的点波关注呗^ ^ ，Thank ! ! ! !&lt;/p&gt;

</description>
<pubDate>Mon, 24 Dec 2018 04:19:00 +0000</pubDate>
<dc:creator>Mr_Precious</dc:creator>
<og:description>序言 近期在工作中管理代码时发现，在项目中从Dao层到Service层数据传递中通过大量的get(),set()方法去一个一个的去拿值去赋值，导致代码篇幅过长，对此甚是讨厌，并且严重消耗开发时间。起初</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/scale-lai/p/10164634.html</dc:identifier>
</item>
</channel>
</rss>