<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>4.5万字手把手教你实现MySQL TB级数据存储！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/14257232.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/14257232.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;业界对系统的高可用有着基本的要求，简单的说，这些要求可以总结为如下所示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统架构中不存在单点问题。&lt;/li&gt;
&lt;li&gt;可以最大限度的保障服务的可用性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般情况下系统的高可用可以用几个9来评估。所谓的几个9就是系统可以保证对外提供的服务的时间达到总时间的百分比。例如如果需要达到99.99的高可用，则系统全年发生故障的总时间不能超过52分钟。&lt;/p&gt;
&lt;h2 id=&quot;系统高可用架构&quot;&gt;系统高可用架构&lt;/h2&gt;
&lt;p&gt;我们既然需要实现系统的高可用架构，那么，我们到底需要搭建一个什么样的系统架构呢？我们可以将需要搭建的系统架构简化成下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201124232619889.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;服务器规划&quot;&gt;服务器规划&lt;/h2&gt;
&lt;p&gt;由于我电脑资源有限，我这里在4台服务器上搭建高可用环境，大家可以按照本文将环境扩展到更多的服务器，搭建步骤都是一样的。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;IP地址&lt;/th&gt;
&lt;th&gt;安装的服务&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;binghe151&lt;/td&gt;
&lt;td&gt;192.168.175.151&lt;/td&gt;
&lt;td&gt;Mycat、Zookeeper、MySQL、HAProxy、Keepalived、Xinetd&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;binghe152&lt;/td&gt;
&lt;td&gt;192.168.175.152&lt;/td&gt;
&lt;td&gt;Zookeeper、MySQL&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;binghe153&lt;/td&gt;
&lt;td&gt;192.168.175.153&lt;/td&gt;
&lt;td&gt;Zookeeper、MySQL&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;binghe154&lt;/td&gt;
&lt;td&gt;192.168.175.154&lt;/td&gt;
&lt;td&gt;Mycat、MySQL、HAProxy、Keepalived、Xinetd&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;binghe155&lt;/td&gt;
&lt;td&gt;192.168.175.155&lt;/td&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：HAProxy和Keepalived最好和Mycat部署在同一台服务器上。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装mysql&quot;&gt;安装MySQL&lt;/h2&gt;
&lt;p&gt;小伙伴们可以关注【冰河技术】微信公众号，参考《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg4MjU0OTM1OA==&amp;amp;mid=2247489456&amp;amp;idx=1&amp;amp;sn=22435ebed07443ca7f990e8f28bdbfc3&amp;amp;chksm=cf55a0b1f82229a7cc92ef24ea59edb5abdc7db80f9e7f46fee3960fd6908aba27f9ec467c83&amp;amp;token=1473173499&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;MySQL之——源码编译MySQL8.x+升级gcc+升级cmake（亲测完整版）&lt;/a&gt;》&lt;/p&gt;
&lt;h2 id=&quot;安装jdk&quot;&gt;安装JDK&lt;/h2&gt;
&lt;p&gt;由于Mycat和Zookeeper的运行需要JDK环境的支持，所有我们需要在每台服务器上安装JDK环境。&lt;/p&gt;
&lt;p&gt;这里，我以在binghe151服务器上安装JDK为例，其他服务器的安装方式与在binghe151服务器上的安装方式相同。安装步骤如下所示。&lt;/p&gt;
&lt;p&gt;（1）到JDK官网下载JDK 1.8版本，JDK1.8的下载地址为：&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot; target=&quot;_blank&quot;&gt;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注：我下载的JDK安装包版本为：jdk-8u212-linux-x64.tar.gz，如果JDK版本已更新，大家下载对应的版本即可。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）将下载的jdk-8u212-linux-x64.tar.gz安装包上传到binghe151服务器的/usr/local/src目录下。&lt;/p&gt;
&lt;p&gt;（3）解压jdk-8u212-linux-x64.tar.gz文件，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;tar -zxvf jdk-8u212-linux-x64.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）将解压的jdk1.8.0_212目录移动到binghe151服务器下的/usr/local目录下，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mv jdk1.8.0_212/ /usr/local/src/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）配置JDK系统环境变量，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim /etc/profile
JAVA_HOME=/usr/local/jdk1.8.0_212
CLASS_PATH=.:$JAVA_HOME/lib
PATH=$JAVA_HOME/bin:$PATH
export JAVA_HOME CLASS_PATH PATH
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使系统环境变量生效，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;source /etc/profile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（6）查看JDK版本，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# java -version
java version &quot;1.8.0_212&quot;
Java(TM) SE Runtime Environment (build 1.8.0_212-b10)
Java HotSpot(TM) 64-Bit Server VM (build 25.212-b10, mixed mode)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示，正确输出了JDK的版本信息，说明JDK安装成功。&lt;/p&gt;
&lt;h2 id=&quot;安装mycat&quot;&gt;安装Mycat&lt;/h2&gt;
&lt;p&gt;下载Mycat 1.6.7.4 Release版本，解压到服务器的/usr/local/mycat目录下，并配置Mycat的系统环境变量，随后，配置Mycat的配置文件，Mycat的最终结果配置如下所示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;schema.xml&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&amp;gt;
&amp;lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&amp;gt;

        &amp;lt;schema name=&quot;shop&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;1000&quot;&amp;gt;
                &amp;lt;!--&amp;lt;table name=&quot;order_master&quot; primaryKey=&quot;order_id&quot; dataNode = &quot;ordb&quot;/&amp;gt;--&amp;gt;
                &amp;lt;table name=&quot;order_master&quot; primaryKey=&quot;order_id&quot; dataNode = &quot;orderdb01,orderdb02,orderdb03,orderdb04&quot; rule=&quot;order_master&quot; autoIncrement=&quot;true&quot;&amp;gt;
                        &amp;lt;childTable name=&quot;order_detail&quot; primaryKey=&quot;order_detail_id&quot; joinKey=&quot;order_id&quot; parentKey=&quot;order_id&quot; autoIncrement=&quot;true&quot;/&amp;gt;
                &amp;lt;/table&amp;gt;
                &amp;lt;table name=&quot;order_cart&quot; primaryKey=&quot;cart_id&quot; dataNode = &quot;ordb&quot;/&amp;gt;
                &amp;lt;table name=&quot;order_customer_addr&quot; primaryKey=&quot;customer_addr_id&quot; dataNode = &quot;ordb&quot;/&amp;gt;
                &amp;lt;table name=&quot;region_info&quot; primaryKey=&quot;region_id&quot; dataNode = &quot;ordb,prodb,custdb&quot; type=&quot;global&quot;/&amp;gt;
                &amp;lt;table name=&quot;serial&quot; primaryKey=&quot;id&quot; dataNode = &quot;ordb&quot;/&amp;gt;
                &amp;lt;table name=&quot;shipping_info&quot; primaryKey=&quot;ship_id&quot; dataNode = &quot;ordb&quot;/&amp;gt;
                &amp;lt;table name=&quot;warehouse_info&quot; primaryKey=&quot;w_id&quot; dataNode = &quot;ordb&quot;/&amp;gt;
                &amp;lt;table name=&quot;warehouse_proudct&quot; primaryKey=&quot;wp_id&quot; dataNode = &quot;ordb&quot;/&amp;gt;
                
                &amp;lt;table name=&quot;product_brand_info&quot; primaryKey=&quot;brand_id&quot; dataNode = &quot;prodb&quot;/&amp;gt;
                &amp;lt;table name=&quot;product_category&quot; primaryKey=&quot;category_id&quot; dataNode = &quot;prodb&quot;/&amp;gt;
                &amp;lt;table name=&quot;product_comment&quot; primaryKey=&quot;comment_id&quot; dataNode = &quot;prodb&quot;/&amp;gt;
                &amp;lt;table name=&quot;product_info&quot; primaryKey=&quot;product_id&quot; dataNode = &quot;prodb&quot;/&amp;gt;
                &amp;lt;table name=&quot;product_pic_info&quot; primaryKey=&quot;product_pic_id&quot; dataNode = &quot;prodb&quot;/&amp;gt;
                &amp;lt;table name=&quot;product_supplier_info&quot; primaryKey=&quot;supplier_id&quot; dataNode = &quot;prodb&quot;/&amp;gt;
                
                &amp;lt;table name=&quot;customer_balance_log&quot; primaryKey=&quot;balance_id&quot; dataNode = &quot;custdb&quot;/&amp;gt;
                &amp;lt;table name=&quot;customer_inf&quot; primaryKey=&quot;customer_inf_id&quot; dataNode = &quot;custdb&quot;/&amp;gt;
                &amp;lt;table name=&quot;customer_level_inf&quot; primaryKey=&quot;customer_level&quot; dataNode = &quot;custdb&quot;/&amp;gt;
                &amp;lt;table name=&quot;customer_login&quot; primaryKey=&quot;customer_id&quot; dataNode = &quot;custdb&quot;/&amp;gt;
                &amp;lt;table name=&quot;customer_login_log&quot; primaryKey=&quot;login_id&quot; dataNode = &quot;custdb&quot;/&amp;gt;
                &amp;lt;table name=&quot;customer_point_log&quot; primaryKey=&quot;point_id&quot; dataNode = &quot;custdb&quot;/&amp;gt;
                
        &amp;lt;/schema&amp;gt;
        
        &amp;lt;dataNode name=&quot;mycat&quot; dataHost=&quot;binghe151&quot; database=&quot;mycat&quot; /&amp;gt;
         
        &amp;lt;dataNode name=&quot;ordb&quot; dataHost=&quot;binghe152&quot; database=&quot;order_db&quot; /&amp;gt;
        &amp;lt;dataNode name=&quot;prodb&quot; dataHost=&quot;binghe153&quot; database=&quot;product_db&quot; /&amp;gt;
        &amp;lt;dataNode name=&quot;custdb&quot; dataHost=&quot;binghe154&quot; database=&quot;customer_db&quot; /&amp;gt;
        
        &amp;lt;dataNode name=&quot;orderdb01&quot; dataHost=&quot;binghe152&quot; database=&quot;orderdb01&quot; /&amp;gt;
        &amp;lt;dataNode name=&quot;orderdb02&quot; dataHost=&quot;binghe152&quot; database=&quot;orderdb02&quot; /&amp;gt;
        &amp;lt;dataNode name=&quot;orderdb03&quot; dataHost=&quot;binghe153&quot; database=&quot;orderdb03&quot; /&amp;gt;
        &amp;lt;dataNode name=&quot;orderdb04&quot; dataHost=&quot;binghe153&quot; database=&quot;orderdb04&quot; /&amp;gt;
        
        &amp;lt;dataHost name=&quot;binghe151&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot;
                          writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&amp;gt;
                &amp;lt;heartbeat&amp;gt;select user()&amp;lt;/heartbeat&amp;gt;
                &amp;lt;writeHost host=&quot;binghe51&quot; url=&quot;192.168.175.151:3306&quot; user=&quot;mycat&quot; password=&quot;mycat&quot;/&amp;gt;
        &amp;lt;/dataHost&amp;gt;
        
        &amp;lt;dataHost name=&quot;binghe152&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot;
                          writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&amp;gt;
                &amp;lt;heartbeat&amp;gt;select user()&amp;lt;/heartbeat&amp;gt;
                &amp;lt;writeHost host=&quot;binghe52&quot; url=&quot;192.168.175.152:3306&quot; user=&quot;mycat&quot; password=&quot;mycat&quot;/&amp;gt;
        &amp;lt;/dataHost&amp;gt;
        
        &amp;lt;dataHost name=&quot;binghe153&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot;
                          writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&amp;gt;
                &amp;lt;heartbeat&amp;gt;select user()&amp;lt;/heartbeat&amp;gt;
                &amp;lt;writeHost host=&quot;binghe53&quot; url=&quot;192.168.175.153:3306&quot; user=&quot;mycat&quot; password=&quot;mycat&quot;/&amp;gt;
        &amp;lt;/dataHost&amp;gt;
        
        &amp;lt;dataHost name=&quot;binghe154&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot;
                          writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&amp;gt;
                &amp;lt;heartbeat&amp;gt;select user()&amp;lt;/heartbeat&amp;gt;
                &amp;lt;writeHost host=&quot;binghe54&quot; url=&quot;192.168.175.154:3306&quot; user=&quot;mycat&quot; password=&quot;mycat&quot;/&amp;gt;
        &amp;lt;/dataHost&amp;gt;
        
&amp;lt;/mycat:schema&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;server.xml&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mycat:server SYSTEM &quot;server.dtd&quot;&amp;gt;
&amp;lt;mycat:server xmlns:mycat=&quot;http://io.mycat/&quot;&amp;gt;
        &amp;lt;system&amp;gt;
                &amp;lt;property name=&quot;useHandshakeV10&quot;&amp;gt;1&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;defaultSqlParser&quot;&amp;gt;druidparser&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;serverPort&quot;&amp;gt;3307&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;managerPort&quot;&amp;gt;3308&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;nonePasswordLogin&quot;&amp;gt;0&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;bindIp&quot;&amp;gt;0.0.0.0&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;charset&quot;&amp;gt;utf8mb4&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;frontWriteQueueSize&quot;&amp;gt;2048&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;txIsolation&quot;&amp;gt;2&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;processors&quot;&amp;gt;2&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;idleTimeout&quot;&amp;gt;1800000&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;sqlExecuteTimeout&quot;&amp;gt;300&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;useSqlStat&quot;&amp;gt;0&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;useGlobleTableCheck&quot;&amp;gt;0&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;sequenceHandlerType&quot;&amp;gt;1&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;defaultMaxLimit&quot;&amp;gt;1000&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;maxPacketSize&quot;&amp;gt;104857600&amp;lt;/property&amp;gt;
                
                &amp;lt;property name=&quot;sqlInterceptor&quot;&amp;gt;
                        io.mycat.server.interceptor.impl.StatisticsSqlInterceptor
                &amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;sqlInterceptorType&quot;&amp;gt;
                        UPDATE,DELETE,INSERT
                &amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;sqlInterceptorFile&quot;&amp;gt;/tmp/sql.txt&amp;lt;/property&amp;gt;
        &amp;lt;/system&amp;gt;
        
        &amp;lt;firewall&amp;gt;
                &amp;lt;whitehost&amp;gt;
                        &amp;lt;host user=&quot;mycat&quot; host=&quot;192.168.175.151&quot;&amp;gt;&amp;lt;/host&amp;gt;
                &amp;lt;/whitehost&amp;gt;
                &amp;lt;blacklist check=&quot;true&quot;&amp;gt;
                        &amp;lt;property name=&quot;noneBaseStatementAllow&quot;&amp;gt;true&amp;lt;/property&amp;gt;
                        &amp;lt;property name=&quot;deleteWhereNoneCheck&quot;&amp;gt;true&amp;lt;/property&amp;gt;
                &amp;lt;/blacklist&amp;gt;
        &amp;lt;/firewall&amp;gt;
        
        &amp;lt;user name=&quot;mycat&quot; defaultAccount=&quot;true&quot;&amp;gt;
                &amp;lt;property name=&quot;usingDecrypt&quot;&amp;gt;1&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;password&quot;&amp;gt;cTwf23RrpBCEmalp/nx0BAKenNhvNs2NSr9nYiMzHADeEDEfwVWlI6hBDccJjNBJqJxnunHFp5ae63PPnMfGYA==&amp;lt;/property&amp;gt;
                &amp;lt;property name=&quot;schemas&quot;&amp;gt;shop&amp;lt;/property&amp;gt;
        &amp;lt;/user&amp;gt;

&amp;lt;/mycat:server&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mycat:rule SYSTEM &quot;rule.dtd&quot;&amp;gt;
&amp;lt;mycat:rule xmlns:mycat=&quot;http://io.mycat/&quot;&amp;gt;
        &amp;lt;tableRule name=&quot;order_master&quot;&amp;gt;
                &amp;lt;rule&amp;gt;
                        &amp;lt;columns&amp;gt;customer_id&amp;lt;/columns&amp;gt;
                        &amp;lt;algorithm&amp;gt;mod-long&amp;lt;/algorithm&amp;gt;
                &amp;lt;/rule&amp;gt;
        &amp;lt;/tableRule&amp;gt;
        
        &amp;lt;function name=&quot;mod-long&quot; class=&quot;io.mycat.route.function.PartitionByMod&quot;&amp;gt;
                &amp;lt;property name=&quot;count&quot;&amp;gt;4&amp;lt;/property&amp;gt;
        &amp;lt;/function&amp;gt;
&amp;lt;/mycat:rule&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;sequence_db_conf.properties&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;#sequence stored in datanode
GLOBAL=mycat
ORDER_MASTER=mycat
ORDER_DETAIL=mycat
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于Mycat的配置，仅供大家参考，大家不一定非要按照我这里配置，根据自身业务需要配置即可。本文的重点是实现Mycat的高可用环境搭建。&lt;/p&gt;
&lt;p&gt;在MySQL中创建Mycat连接MySQL的账户，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE USER 'mycat'@'192.168.175.%' IDENTIFIED BY 'mycat';
ALTER USER 'mycat'@'192.168.175.%' IDENTIFIED WITH mysql_native_password BY 'mycat'; 
GRANT SELECT, INSERT, UPDATE, DELETE,EXECUTE  ON *.* TO 'mycat'@'192.168.175.%';
FLUSH PRIVILEGES;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装zookeeper集群&quot;&gt;安装Zookeeper集群&lt;/h2&gt;
&lt;p&gt;安装配置完JDK后，就需要搭建Zookeeper集群了，根据对服务器的规划，现将Zookeeper集群搭建在“binghe151”、“binghe152”、“binghe153”三台服务器上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.下载Zookeeper&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到Apache官网去下载Zookeeper的安装包，Zookeeper的安装包下载地址为：&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/&quot; target=&quot;_blank&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/&lt;/a&gt;。具体如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201124232546523.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以在binghe151服务器上执行如下命令直接下载zookeeper-3.5.5。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.5.5/apache-zookeeper-3.5.5-bin.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上述命令就可以直接把apache-zookeeper-3.5.5-bin.tar.gz安装包下载到binghe151服务器上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.安装并配置Zookeeper&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：（1）、（2）、（3）步都是在binghe152服务器上执行的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）解压Zookeeper安装包&lt;/p&gt;
&lt;p&gt;在binghe151服务器上执行如下命令，将Zookeeper解压到“/usr/local/”目录下，并将Zookeeper目录修改为zookeeper-3.5.5。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;tar -zxvf apache-zookeeper-3.5.5-bin.tar.gz
mv apache-zookeeper-3.5.5-bin zookeeper-3.5.5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）配置Zookeeper系统环境变量&lt;/p&gt;
&lt;p&gt;同样，需要在/etc/profile文件中配置Zookeeper系统环境变量，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ZOOKEEPER_HOME=/usr/local/zookeeper-3.5.5
PATH=$ZOOKEEPER_HOME/bin:$PATH
export ZOOKEEPER_HOME PATH
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结合之前配置的JDK系统环境变量，/etc/profile，总体配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;MYSQL_HOME=/usr/local/mysql
JAVA_HOME=/usr/local/jdk1.8.0_212
MYCAT_HOME=/usr/local/mycat
ZOOKEEPER_HOME=/usr/local/zookeeper-3.5.5
MPC_HOME=/usr/local/mpc-1.1.0
GMP_HOME=/usr/local/gmp-6.1.2
MPFR_HOME=/usr/local/mpfr-4.0.2
CLASS_PATH=.:$JAVA_HOME/lib
LD_LIBRARY_PATH=$MPC_LIB_HOME/lib:$GMP_HOME/lib:$MPFR_HOME/lib:$LD_LIBRARY_PATH
PATH=$MYSQL_HOME/bin:$JAVA_HOME/bin:$ZOOKEEPER_HOME/bin:$MYCAT_HOME/bin:$PATH
export JAVA_HOME ZOOKEEPER_HOME MYCAT_HOME CLASS_PATH MYSQL_HOME MPC_LIB_HOME GMP_HOME MPFR_HOME LD_LIBRARY_PATH PATH
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）配置Zookeeper&lt;/p&gt;
&lt;p&gt;首先，需要将&lt;code&gt;$ZOOKEEPER_HOME/conf&lt;/code&gt;（$ZOOKEEPER_HOME为Zookeeper的安装目录）目录下的zoo_sample.cfg文件修改为zoo.cfg文件。具体命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd /usr/local/zookeeper-3.5.5/conf/
mv zoo_sample.cfg zoo.cfg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来修改zoo.cfg文件，修改后的具体内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;tickTime=2000
initLimit=10
syncLimit=5
dataDir=/usr/local/zookeeper-3.5.5/data
dataLogDir=/usr/local/zookeeper-3.5.5/dataLog
clientPort=2181
server.1=binghe151:2888:3888
server.2=binghe152:2888:3888
server.3=binghe153:2888:3888
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Zookeeper的安装目录下创建data和dataLog两个文件夹。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mkdir -p /usr/local/zookeeper-3.5.5/data
mkdir -p /usr/local/zookeeper-3.5.5/dataLog
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切换到新建的data目录下，创建myid文件，具体内容为数字1，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd /usr/local/zookeeper-3.5.5/data
vim myid
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将数字1写入到文件myid。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.将Zookeeper和系统环境变量文件复制到其他服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：（1）、（2）步是在binghe151服务器上执行的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）复制Zookeeper到其他服务器&lt;/p&gt;
&lt;p&gt;根据对服务器的规划，现将Zookeeper复制到binghe152和binghe53服务器，具体执行操作如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;scp -r /usr/local/zookeeper-3.5.5/ binghe152:/usr/local/
scp -r /usr/local/zookeeper-3.5.5/ binghe153:/usr/local/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）复制系统环境变量文件到其他服务器&lt;/p&gt;
&lt;p&gt;根据对服务器的规划，现将系统环境变量文件/etc/profile复制到binghe152、binghe153服务器，具体执行操作如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;scp /etc/profile binghe152:/etc/
scp /etc/profile binghe153:/etc/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述操作可能会要求输入密码，根据提示输入密码即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.修改其他服务器上的myid文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改binghe152服务器上Zookeeper的myid文件内容为数字2，同时修改binghe153服务器上Zookeeper的myid文件内容为数字3。具体如下：&lt;/p&gt;
&lt;p&gt;在binghe152服务器上执行如下操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;echo &quot;2&quot; &amp;gt; /usr/local/zookeeper-3.5.5/data/myid
cat /usr/local/zookeeper-3.5.5/data/myid
2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在binghe153服务器上执行如下操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;echo &quot;3&quot; &amp;gt; /usr/local/zookeeper-3.5.5/data/myid
cat /usr/local/zookeeper-3.5.5/data/myid
3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.使环境变量生效&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分别在binghe151、binghe152、binghe153上执行如下操作，使系统环境变量生效。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;source /etc/profile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6.启动Zookeeper集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分别在binghe151、binghe152、binghe153上执行如下操作，启动Zookeeper集群。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;zkServer.sh start
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;7.查看Zookeeper集群的启动状态&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;binghe151服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# zkServer.sh status
ZooKeeper JMX enabled by default
Using config: /usr/local/zookeeper-3.5.5/bin/../conf/zoo.cfg
Client port found: 2181. Client address: localhost.
Mode: follower
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;binghe152服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe152 local]# zkServer.sh status
ZooKeeper JMX enabled by default
Using config: /usr/local/zookeeper-3.5.5/bin/../conf/zoo.cfg
Client port found: 2181. Client address: localhost.
Mode: leader
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;binghe153服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe153 ~]# zkServer.sh status
ZooKeeper JMX enabled by default
Using config: /usr/local/zookeeper-3.5.5/bin/../conf/zoo.cfg
Client port found: 2181. Client address: localhost.
Mode: follower
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，binghe151和binghe153服务器上的Zookeeper角色为follower，binghe152服务器上的Zookeeper角色为leader。&lt;/p&gt;
&lt;h2 id=&quot;初始化mycat配置到zookeeper集群&quot;&gt;初始化Mycat配置到Zookeeper集群&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：初始化Zookeeper中的数据，是在binghe151服务器上进行的，原因是之前我们已经在binghe151服务器上安装了Mycat。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.查看初始化脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Mycat安装目录下的bin目录中提供了一个init_zk_data.sh脚本文件，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# ll /usr/local/mycat/bin/
total 384
-rwxr-xr-x 1 root root   3658 Feb 26 17:10 dataMigrate.sh
-rwxr-xr-x 1 root root   1272 Feb 26 17:10 init_zk_data.sh
-rwxr-xr-x 1 root root  15701 Feb 28 20:51 mycat
-rwxr-xr-x 1 root root   2986 Feb 26 17:10 rehash.sh
-rwxr-xr-x 1 root root   2526 Feb 26 17:10 startup_nowrap.sh
-rwxr-xr-x 1 root root 140198 Feb 28 20:51 wrapper-linux-ppc-64
-rwxr-xr-x 1 root root  99401 Feb 28 20:51 wrapper-linux-x86-32
-rwxr-xr-x 1 root root 111027 Feb 28 20:51 wrapper-linux-x86-64
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;init_zk_data.sh脚本文件就是用来向Zookeeper中初始化Mycat的配置的，这个文件会通过读取Mycat安装目录下的conf目录下的配置文件，将其初始化到Zookeeper集群中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.复制Mycat配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，我们查看下Mycat安装目录下的conf目录下的文件信息，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# cd /usr/local/mycat/conf/
[root@binghe151 conf]# ll
total 108
-rwxrwxrwx 1 root root   92 Feb 26 17:10 autopartition-long.txt
-rwxrwxrwx 1 root root   51 Feb 26 17:10 auto-sharding-long.txt
-rwxrwxrwx 1 root root   67 Feb 26 17:10 auto-sharding-rang-mod.txt
-rwxrwxrwx 1 root root  340 Feb 26 17:10 cacheservice.properties
-rwxrwxrwx 1 root root 3338 Feb 26 17:10 dbseq.sql
-rwxrwxrwx 1 root root 3532 Feb 26 17:10 dbseq - utf8mb4.sql
-rw-r--r-- 1 root root   86 Mar  1 22:37 dnindex.properties
-rwxrwxrwx 1 root root  446 Feb 26 17:10 ehcache.xml
-rwxrwxrwx 1 root root 2454 Feb 26 17:10 index_to_charset.properties
-rwxrwxrwx 1 root root 1285 Feb 26 17:10 log4j2.xml
-rwxrwxrwx 1 root root  183 Feb 26 17:10 migrateTables.properties
-rwxrwxrwx 1 root root  271 Feb 26 17:10 myid.properties
-rwxrwxrwx 1 root root   16 Feb 26 17:10 partition-hash-int.txt
-rwxrwxrwx 1 root root  108 Feb 26 17:10 partition-range-mod.txt
-rwxrwxrwx 1 root root  988 Mar  1 16:59 rule.xml
-rwxrwxrwx 1 root root 3883 Mar  3 23:59 schema.xml
-rwxrwxrwx 1 root root  440 Feb 26 17:10 sequence_conf.properties
-rwxrwxrwx 1 root root   84 Mar  3 23:52 sequence_db_conf.properties
-rwxrwxrwx 1 root root   29 Feb 26 17:10 sequence_distributed_conf.properties
-rwxrwxrwx 1 root root   28 Feb 26 17:10 sequence_http_conf.properties
-rwxrwxrwx 1 root root   53 Feb 26 17:10 sequence_time_conf.properties
-rwxrwxrwx 1 root root 2420 Mar  4 15:14 server.xml
-rwxrwxrwx 1 root root   18 Feb 26 17:10 sharding-by-enum.txt
-rwxrwxrwx 1 root root 4251 Feb 28 20:51 wrapper.conf
drwxrwxrwx 2 root root 4096 Feb 28 21:17 zkconf
drwxrwxrwx 2 root root 4096 Feb 28 21:17 zkdownload
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，将Mycat安装目录下的conf目录下的schema.xml文件、server.xml文件、rule.xml文件和sequence_db_conf.properties文件复制到conf目录下的zkconf目录下，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cp schema.xml server.xml rule.xml sequence_db_conf.properties zkconf/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.将Mycat配置信息写入Zookeeper集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行init_zk_data.sh脚本文件，向Zookeeper集群中初始化配置信息，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 bin]# /usr/local/mycat/bin/init_zk_data.sh  
o2020-03-08 20:03:13 INFO JAVA_CMD=/usr/local/jdk1.8.0_212/bin/java
o2020-03-08 20:03:13 INFO Start to initialize /mycat of ZooKeeper
o2020-03-08 20:03:14 INFO Done
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据以上信息得知，Mycat向Zookeeper写入初始化配置信息成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.验证Mycat配置信息是否成功写入Mycat&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用Zookeeper的客户端命令zkCli.sh 登录Zookeeper来验证Mycat的配置信息是否成功写入Mycat。&lt;/p&gt;
&lt;p&gt;首先，登录Zookeeper，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# zkCli.sh 
Connecting to localhost:2181
###################此处省略N行输出######################
Welcome to ZooKeeper!

WATCHER::

WatchedEvent state:SyncConnected type:None path:null
[zk: localhost:2181(CONNECTED) 0] 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，在Zookeeper命令行查看mycat的信息，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[zk: localhost:2181(CONNECTED) 0] ls /
[mycat, zookeeper]
[zk: localhost:2181(CONNECTED) 1] ls /mycat
[mycat-cluster-1]
[zk: localhost:2181(CONNECTED) 2] ls /mycat/mycat-cluster-1
[cache, line, rules, schema, sequences, server]
[zk: localhost:2181(CONNECTED) 3] 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在/mycat/mycat-cluster-1下存在6个目录，接下来，查看下schema目录下的信息，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[zk: localhost:2181(CONNECTED) 3] ls /mycat/mycat-cluster-1/schema
[dataHost, dataNode, schema]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们查看下dataHost的配置，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[zk: localhost:2181(CONNECTED) 4] get /mycat/mycat-cluster-1/schema/dataHost
[{&quot;balance&quot;:1,&quot;maxCon&quot;:1000,&quot;minCon&quot;:10,&quot;name&quot;:&quot;binghe151&quot;,&quot;writeType&quot;:0,&quot;switchType&quot;:1,&quot;slaveThreshold&quot;:100,&quot;dbType&quot;:&quot;mysql&quot;,&quot;dbDriver&quot;:&quot;native&quot;,&quot;heartbeat&quot;:&quot;select user()&quot;,&quot;writeHost&quot;:[{&quot;host&quot;:&quot;binghe51&quot;,&quot;url&quot;:&quot;192.168.175.151:3306&quot;,&quot;password&quot;:&quot;root&quot;,&quot;user&quot;:&quot;root&quot;}]},{&quot;balance&quot;:1,&quot;maxCon&quot;:1000,&quot;minCon&quot;:10,&quot;name&quot;:&quot;binghe152&quot;,&quot;writeType&quot;:0,&quot;switchType&quot;:1,&quot;slaveThreshold&quot;:100,&quot;dbType&quot;:&quot;mysql&quot;,&quot;dbDriver&quot;:&quot;native&quot;,&quot;heartbeat&quot;:&quot;select user()&quot;,&quot;writeHost&quot;:[{&quot;host&quot;:&quot;binghe52&quot;,&quot;url&quot;:&quot;192.168.175.152:3306&quot;,&quot;password&quot;:&quot;root&quot;,&quot;user&quot;:&quot;root&quot;}]},{&quot;balance&quot;:1,&quot;maxCon&quot;:1000,&quot;minCon&quot;:10,&quot;name&quot;:&quot;binghe153&quot;,&quot;writeType&quot;:0,&quot;switchType&quot;:1,&quot;slaveThreshold&quot;:100,&quot;dbType&quot;:&quot;mysql&quot;,&quot;dbDriver&quot;:&quot;native&quot;,&quot;heartbeat&quot;:&quot;select user()&quot;,&quot;writeHost&quot;:[{&quot;host&quot;:&quot;binghe53&quot;,&quot;url&quot;:&quot;192.168.175.153:3306&quot;,&quot;password&quot;:&quot;root&quot;,&quot;user&quot;:&quot;root&quot;}]},{&quot;balance&quot;:1,&quot;maxCon&quot;:1000,&quot;minCon&quot;:10,&quot;name&quot;:&quot;binghe154&quot;,&quot;writeType&quot;:0,&quot;switchType&quot;:1,&quot;slaveThreshold&quot;:100,&quot;dbType&quot;:&quot;mysql&quot;,&quot;dbDriver&quot;:&quot;native&quot;,&quot;heartbeat&quot;:&quot;select user()&quot;,&quot;writeHost&quot;:[{&quot;host&quot;:&quot;binghe54&quot;,&quot;url&quot;:&quot;192.168.175.154:3306&quot;,&quot;password&quot;:&quot;root&quot;,&quot;user&quot;:&quot;root&quot;}]}]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的输出信息格式比较乱，但可以看出是Json格式的信息，我们可以将输出信息进行格式化，格式化后的结果如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;[
    {
        &quot;balance&quot;: 1,
        &quot;maxCon&quot;: 1000,
        &quot;minCon&quot;: 10,
        &quot;name&quot;: &quot;binghe151&quot;,
        &quot;writeType&quot;: 0,
        &quot;switchType&quot;: 1,
        &quot;slaveThreshold&quot;: 100,
        &quot;dbType&quot;: &quot;mysql&quot;,
        &quot;dbDriver&quot;: &quot;native&quot;,
        &quot;heartbeat&quot;: &quot;select user()&quot;,
        &quot;writeHost&quot;: [
            {
                &quot;host&quot;: &quot;binghe51&quot;,
                &quot;url&quot;: &quot;192.168.175.151:3306&quot;,
                &quot;password&quot;: &quot;root&quot;,
                &quot;user&quot;: &quot;root&quot;
            }
        ]
    },
    {
        &quot;balance&quot;: 1,
        &quot;maxCon&quot;: 1000,
        &quot;minCon&quot;: 10,
        &quot;name&quot;: &quot;binghe152&quot;,
        &quot;writeType&quot;: 0,
        &quot;switchType&quot;: 1,
        &quot;slaveThreshold&quot;: 100,
        &quot;dbType&quot;: &quot;mysql&quot;,
        &quot;dbDriver&quot;: &quot;native&quot;,
        &quot;heartbeat&quot;: &quot;select user()&quot;,
        &quot;writeHost&quot;: [
            {
                &quot;host&quot;: &quot;binghe52&quot;,
                &quot;url&quot;: &quot;192.168.175.152:3306&quot;,
                &quot;password&quot;: &quot;root&quot;,
                &quot;user&quot;: &quot;root&quot;
            }
        ]
    },
    {
        &quot;balance&quot;: 1,
        &quot;maxCon&quot;: 1000,
        &quot;minCon&quot;: 10,
        &quot;name&quot;: &quot;binghe153&quot;,
        &quot;writeType&quot;: 0,
        &quot;switchType&quot;: 1,
        &quot;slaveThreshold&quot;: 100,
        &quot;dbType&quot;: &quot;mysql&quot;,
        &quot;dbDriver&quot;: &quot;native&quot;,
        &quot;heartbeat&quot;: &quot;select user()&quot;,
        &quot;writeHost&quot;: [
            {
                &quot;host&quot;: &quot;binghe53&quot;,
                &quot;url&quot;: &quot;192.168.175.153:3306&quot;,
                &quot;password&quot;: &quot;root&quot;,
                &quot;user&quot;: &quot;root&quot;
            }
        ]
    },
    {
        &quot;balance&quot;: 1,
        &quot;maxCon&quot;: 1000,
        &quot;minCon&quot;: 10,
        &quot;name&quot;: &quot;binghe154&quot;,
        &quot;writeType&quot;: 0,
        &quot;switchType&quot;: 1,
        &quot;slaveThreshold&quot;: 100,
        &quot;dbType&quot;: &quot;mysql&quot;,
        &quot;dbDriver&quot;: &quot;native&quot;,
        &quot;heartbeat&quot;: &quot;select user()&quot;,
        &quot;writeHost&quot;: [
            {
                &quot;host&quot;: &quot;binghe54&quot;,
                &quot;url&quot;: &quot;192.168.175.154:3306&quot;,
                &quot;password&quot;: &quot;root&quot;,
                &quot;user&quot;: &quot;root&quot;
            }
        ]
    }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们在Mycat的schema.xml文件中配置的dataHost节点的信息，成功写入到Zookeeper中了。&lt;/p&gt;
&lt;p&gt;为了验证Mycat的配置信息，是否已经同步到Zookeeper的其他节点上，我们也可以在binghe152和binghe153服务器上登录Zookeeper，查看Mycat配置信息是否写入成功。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;binghe152服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe152 ~]# zkCli.sh 
Connecting to localhost:2181
#################省略N行输出信息################
[zk: localhost:2181(CONNECTED) 0] get /mycat/mycat-cluster-1/schema/dataHost
[{&quot;balance&quot;:1,&quot;maxCon&quot;:1000,&quot;minCon&quot;:10,&quot;name&quot;:&quot;binghe151&quot;,&quot;writeType&quot;:0,&quot;switchType&quot;:1,&quot;slaveThreshold&quot;:100,&quot;dbType&quot;:&quot;mysql&quot;,&quot;dbDriver&quot;:&quot;native&quot;,&quot;heartbeat&quot;:&quot;select user()&quot;,&quot;writeHost&quot;:[{&quot;host&quot;:&quot;binghe51&quot;,&quot;url&quot;:&quot;192.168.175.151:3306&quot;,&quot;password&quot;:&quot;root&quot;,&quot;user&quot;:&quot;root&quot;}]},{&quot;balance&quot;:1,&quot;maxCon&quot;:1000,&quot;minCon&quot;:10,&quot;name&quot;:&quot;binghe152&quot;,&quot;writeType&quot;:0,&quot;switchType&quot;:1,&quot;slaveThreshold&quot;:100,&quot;dbType&quot;:&quot;mysql&quot;,&quot;dbDriver&quot;:&quot;native&quot;,&quot;heartbeat&quot;:&quot;select user()&quot;,&quot;writeHost&quot;:[{&quot;host&quot;:&quot;binghe52&quot;,&quot;url&quot;:&quot;192.168.175.152:3306&quot;,&quot;password&quot;:&quot;root&quot;,&quot;user&quot;:&quot;root&quot;}]},{&quot;balance&quot;:1,&quot;maxCon&quot;:1000,&quot;minCon&quot;:10,&quot;name&quot;:&quot;binghe153&quot;,&quot;writeType&quot;:0,&quot;switchType&quot;:1,&quot;slaveThreshold&quot;:100,&quot;dbType&quot;:&quot;mysql&quot;,&quot;dbDriver&quot;:&quot;native&quot;,&quot;heartbeat&quot;:&quot;select user()&quot;,&quot;writeHost&quot;:[{&quot;host&quot;:&quot;binghe53&quot;,&quot;url&quot;:&quot;192.168.175.153:3306&quot;,&quot;password&quot;:&quot;root&quot;,&quot;user&quot;:&quot;root&quot;}]},{&quot;balance&quot;:1,&quot;maxCon&quot;:1000,&quot;minCon&quot;:10,&quot;name&quot;:&quot;binghe154&quot;,&quot;writeType&quot;:0,&quot;switchType&quot;:1,&quot;slaveThreshold&quot;:100,&quot;dbType&quot;:&quot;mysql&quot;,&quot;dbDriver&quot;:&quot;native&quot;,&quot;heartbeat&quot;:&quot;select user()&quot;,&quot;writeHost&quot;:[{&quot;host&quot;:&quot;binghe54&quot;,&quot;url&quot;:&quot;192.168.175.154:3306&quot;,&quot;password&quot;:&quot;root&quot;,&quot;user&quot;:&quot;root&quot;}]}]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，Mycat的配置信息成功同步到了binghe152服务器上的Zookeeper中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;binghe153服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe153 ~]# zkCli.sh 
Connecting to localhost:2181
#####################此处省略N行输出信息#####################
[zk: localhost:2181(CONNECTED) 0] get /mycat/mycat-cluster-1/schema/dataHost
[{&quot;balance&quot;:1,&quot;maxCon&quot;:1000,&quot;minCon&quot;:10,&quot;name&quot;:&quot;binghe151&quot;,&quot;writeType&quot;:0,&quot;switchType&quot;:1,&quot;slaveThreshold&quot;:100,&quot;dbType&quot;:&quot;mysql&quot;,&quot;dbDriver&quot;:&quot;native&quot;,&quot;heartbeat&quot;:&quot;select user()&quot;,&quot;writeHost&quot;:[{&quot;host&quot;:&quot;binghe51&quot;,&quot;url&quot;:&quot;192.168.175.151:3306&quot;,&quot;password&quot;:&quot;root&quot;,&quot;user&quot;:&quot;root&quot;}]},{&quot;balance&quot;:1,&quot;maxCon&quot;:1000,&quot;minCon&quot;:10,&quot;name&quot;:&quot;binghe152&quot;,&quot;writeType&quot;:0,&quot;switchType&quot;:1,&quot;slaveThreshold&quot;:100,&quot;dbType&quot;:&quot;mysql&quot;,&quot;dbDriver&quot;:&quot;native&quot;,&quot;heartbeat&quot;:&quot;select user()&quot;,&quot;writeHost&quot;:[{&quot;host&quot;:&quot;binghe52&quot;,&quot;url&quot;:&quot;192.168.175.152:3306&quot;,&quot;password&quot;:&quot;root&quot;,&quot;user&quot;:&quot;root&quot;}]},{&quot;balance&quot;:1,&quot;maxCon&quot;:1000,&quot;minCon&quot;:10,&quot;name&quot;:&quot;binghe153&quot;,&quot;writeType&quot;:0,&quot;switchType&quot;:1,&quot;slaveThreshold&quot;:100,&quot;dbType&quot;:&quot;mysql&quot;,&quot;dbDriver&quot;:&quot;native&quot;,&quot;heartbeat&quot;:&quot;select user()&quot;,&quot;writeHost&quot;:[{&quot;host&quot;:&quot;binghe53&quot;,&quot;url&quot;:&quot;192.168.175.153:3306&quot;,&quot;password&quot;:&quot;root&quot;,&quot;user&quot;:&quot;root&quot;}]},{&quot;balance&quot;:1,&quot;maxCon&quot;:1000,&quot;minCon&quot;:10,&quot;name&quot;:&quot;binghe154&quot;,&quot;writeType&quot;:0,&quot;switchType&quot;:1,&quot;slaveThreshold&quot;:100,&quot;dbType&quot;:&quot;mysql&quot;,&quot;dbDriver&quot;:&quot;native&quot;,&quot;heartbeat&quot;:&quot;select user()&quot;,&quot;writeHost&quot;:[{&quot;host&quot;:&quot;binghe54&quot;,&quot;url&quot;:&quot;192.168.175.154:3306&quot;,&quot;password&quot;:&quot;root&quot;,&quot;user&quot;:&quot;root&quot;}]}]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，Mycat的配置信息成功同步到了binghe153服务器上的Zookeeper中。&lt;/p&gt;
&lt;h2 id=&quot;配置mycat支持zookeeper启动&quot;&gt;配置Mycat支持Zookeeper启动&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.在binghe151服务器上配置Mycat&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在binghe151服务器上进入Mycat安装目录的conf目录下，查看文件信息，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# cd /usr/local/mycat/conf/
[root@binghe151 conf]# ll
total 108
-rwxrwxrwx 1 root root   92 Feb 26 17:10 autopartition-long.txt
-rwxrwxrwx 1 root root   51 Feb 26 17:10 auto-sharding-long.txt
-rwxrwxrwx 1 root root   67 Feb 26 17:10 auto-sharding-rang-mod.txt
-rwxrwxrwx 1 root root  340 Feb 26 17:10 cacheservice.properties
-rwxrwxrwx 1 root root 3338 Feb 26 17:10 dbseq.sql
-rwxrwxrwx 1 root root 3532 Feb 26 17:10 dbseq - utf8mb4.sql
-rw-r--r-- 1 root root   86 Mar  1 22:37 dnindex.properties
-rwxrwxrwx 1 root root  446 Feb 26 17:10 ehcache.xml
-rwxrwxrwx 1 root root 2454 Feb 26 17:10 index_to_charset.properties
-rwxrwxrwx 1 root root 1285 Feb 26 17:10 log4j2.xml
-rwxrwxrwx 1 root root  183 Feb 26 17:10 migrateTables.properties
-rwxrwxrwx 1 root root  271 Feb 26 17:10 myid.properties
-rwxrwxrwx 1 root root   16 Feb 26 17:10 partition-hash-int.txt
-rwxrwxrwx 1 root root  108 Feb 26 17:10 partition-range-mod.txt
-rwxrwxrwx 1 root root  988 Mar  1 16:59 rule.xml
-rwxrwxrwx 1 root root 3883 Mar  3 23:59 schema.xml
-rwxrwxrwx 1 root root  440 Feb 26 17:10 sequence_conf.properties
-rwxrwxrwx 1 root root   84 Mar  3 23:52 sequence_db_conf.properties
-rwxrwxrwx 1 root root   29 Feb 26 17:10 sequence_distributed_conf.properties
-rwxrwxrwx 1 root root   28 Feb 26 17:10 sequence_http_conf.properties
-rwxrwxrwx 1 root root   53 Feb 26 17:10 sequence_time_conf.properties
-rwxrwxrwx 1 root root 2420 Mar  4 15:14 server.xml
-rwxrwxrwx 1 root root   18 Feb 26 17:10 sharding-by-enum.txt
-rwxrwxrwx 1 root root 4251 Feb 28 20:51 wrapper.conf
drwxrwxrwx 2 root root 4096 Feb 28 21:17 zkconf
drwxrwxrwx 2 root root 4096 Feb 28 21:17 zkdownload
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在Mycat的conf目录下，存在一个myid.properties文件，接下来，使用vim编辑器编辑这个文件，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim myid.properties 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编辑后的myid.properties文件的内容如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;loadZk=true
zkURL=192.168.175.151:2181,192.168.175.152:2181,192.168.175.153:2181
clusterId=mycat-cluster-1
myid=mycat_151
clusterSize=2
clusterNodes=mycat_151,mycat_154
#server  booster  ;   booster install on db same server,will reset all minCon to 2
type=server
boosterDataHosts=dataHost1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中几个重要的参数说明如下所示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;loadZk：表示是否加载Zookeeper配置。true：是； false：否；&lt;/li&gt;
&lt;li&gt;zkURL：Zookeeper的连接地址，多个Zookeeper连接地址以逗号隔开；&lt;/li&gt;
&lt;li&gt;clusterId：当前Mycat集群的Id标识，此标识需要与Zookeeper中/mycat目录下的目录名称相同，如下所示。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[zk: localhost:2181(CONNECTED) 1] ls /mycat
[mycat-cluster-1]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;myid：当前Mycat节点的id，这里我的命名方式为mycat_前缀加上IP地址的最后三位；&lt;/li&gt;
&lt;li&gt;clusterSize：表示Mycat集群中的Mycat节点个数，这里，我们在binghe151和binghe154节点上部署Mycat，所以Mycat节点的个数为2。&lt;/li&gt;
&lt;li&gt;clusterNodes：Mycat集群中，所有的Mycat节点，此处的节点需要配置myid中配置的Mycat节点id，多个节点之前以逗号分隔。这里我配置的节点为：mycat_151,mycat_154。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2.在binghe154服务器上安装全新的Mycat&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在binghe154服务器上下载并安装和binghe151服务器上相同版本的Mycat，并将其解压到binghe154服务器上的/usr/local/mycat目录下。&lt;/p&gt;
&lt;p&gt;也可以在binghe151服务器上直接输入如下命令将Mycat的安装目录复制到binghe154服务器上。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# scp -r /usr/local/mycat binghe154:/usr/local
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：别忘了在binghe154服务器上配置Mycat的系统环境变量。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.修改binghe154服务器上的Mycat配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在binghe154服务器上修改Mycat安装目录下的conf目录中的myid.properties文件，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim /usr/local/mycat/conf/myid.properties
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改后的myid.properties文件的内容如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;loadZk=true
zkURL=192.168.175.151:2181,192.168.175.152:2181,192.168.175.153:2181
clusterId=mycat-cluster-1
myid=mycat_154
clusterSize=2
clusterNodes=mycat_151,mycat_154
#server  booster  ;   booster install on db same server,will reset all minCon to 2
type=server
boosterDataHosts=dataHost1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.重启Mycat&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分别重启binghe151服务器和binghe154服务器上的Mycat，如下所示。&lt;/p&gt;
&lt;p&gt;注意：先重启&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;binghe151服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# mycat restart
Stopping Mycat-server...
Stopped Mycat-server.
Starting Mycat-server...
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;binghe154服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe154 ~]# mycat restart
Stopping Mycat-server...
Stopped Mycat-server.
Starting Mycat-server...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在binghe151和binghe154服务器上分别查看Mycat的启动日志，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;STATUS | wrapper  | 2020/03/08 21:08:15 | &amp;lt;-- Wrapper Stopped
STATUS | wrapper  | 2020/03/08 21:08:15 | --&amp;gt; Wrapper Started as Daemon
STATUS | wrapper  | 2020/03/08 21:08:15 | Launching a JVM...
INFO   | jvm 1    | 2020/03/08 21:08:16 | Wrapper (Version 3.2.3) http://wrapper.tanukisoftware.org
INFO   | jvm 1    | 2020/03/08 21:08:16 |   Copyright 1999-2006 Tanuki Software, Inc.  All Rights Reserved.
INFO   | jvm 1    | 2020/03/08 21:08:16 | 
INFO   | jvm 1    | 2020/03/08 21:08:28 | MyCAT Server startup successfully. see logs in logs/mycat.log
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从日志的输出结果可以看出，Mycat重启成功。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;此时，先重启binghe151服务器上的Mycat，再重启binghe154服务器上的Mycat之后，我们会发现binghe154服务器上的Mycat的conf目录下的schema.xml、server.xml、rule.xml和sequence_db_conf.properties文件与binghe151服务器上Mycat的配置文件相同，这就是binghe154服务器上的Mycat从Zookeeper上读取配置文件的结果。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;以后，我们只需要修改Zookeeper中有关Mycat的配置，这些配置就会自动同步到Mycat中，这样可以保证多个Mycat节点的配置是一致的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置虚拟ip&quot;&gt;配置虚拟IP&lt;/h2&gt;
&lt;p&gt;分别在binghe151和binghe154服务器上配置虚拟IP，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ifconfig eth0:1 192.168.175.110 broadcast 192.168.175.255 netmask 255.255.255.0 up
route add -host 192.168.175.110 dev eth0:1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完虚拟IP的效果如下所示，以binghe151服务器为例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# ifconfig
eth0      Link encap:Ethernet  HWaddr 00:0C:29:10:A1:45  
          inet addr:192.168.175.151  Bcast:192.168.175.255  Mask:255.255.255.0
          inet6 addr: fe80::20c:29ff:fe10:a145/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:116766 errors:0 dropped:0 overruns:0 frame:0
          TX packets:85230 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:25559422 (24.3 MiB)  TX bytes:55997016 (53.4 MiB)

eth0:1    Link encap:Ethernet  HWaddr 00:0C:29:10:A1:45  
          inet addr:192.168.175.110  Bcast:192.168.175.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:51102 errors:0 dropped:0 overruns:0 frame:0
          TX packets:51102 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:2934009 (2.7 MiB)  TX bytes:2934009 (2.7 MiB)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;在命令行添加VIP后，当服务器重启后，VIP信息会消失，所以，最好是将创建VIP的命令写到一个脚本文件中，例如，将命令写到/usr/local/script/vip.sh文件中，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mkdir /usr/local/script
vim /usr/local/script/vip.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件的内容如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ifconfig eth0:1 192.168.175.110 broadcast 192.168.175.255 netmask 255.255.255.0 up
route add -host 192.168.175.110 dev eth0:1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，将/usr/local/script/vip.sh文件添加到服务器开机启动项中，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;echo /usr/local/script/vip.sh &amp;gt;&amp;gt; /etc/rc.d/rc.local
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置ip转发&quot;&gt;配置IP转发&lt;/h2&gt;
&lt;p&gt;在binghe151和binghe154服务器上配置系统内核IP转发功能，编辑/etc/sysctl.conf文件，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim /etc/sysctl.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到如下一行代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;net.ipv4.ip_forward = 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将其修改成如下所示的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;net.ipv4.ip_forward = 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存并退出vim编辑器，并运行如下命令使配置生效。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sysctl -p
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装并配置xinetd服务&quot;&gt;安装并配置xinetd服务&lt;/h2&gt;
&lt;p&gt;我们需要在安装HAProxy的服务器上，也就是在binghe151和binghe154服务器上安装xinetd服务来开启48700端口。&lt;/p&gt;
&lt;p&gt;（1）在服务器命令行执行如下命令安装xinetd服务，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;yum install xinetd -y
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）编辑/etc/xinetd.conf文件，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim /etc/xinetd.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查文件中是否存在如下配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;includedir /etc/xinetd.d
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果/etc/xinetd.conf文件中没有以上配置，则在/etc/xinetd.conf文件中添加以上配置；如果存在以上配置，则不用修改。&lt;/p&gt;
&lt;p&gt;（3）创建/etc/xinetd.d目录，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mkdir /etc/xinetd.d
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：如果/etc/xinetd.d目录已经存在，创建目录时会报如下错误。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mkdir: cannot create directory `/etc/xinetd.d': File exists
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家可不必理会此错误信息。&lt;/p&gt;
&lt;p&gt;（4）在/etc/xinetd.d目录下添加Mycat状态检测服务器的配置文件mycat_status，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;touch /etc/xinetd.d/mycat_status
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）编辑mycat_status文件，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim /etc/xinetd.d/mycat_status
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编辑后的mycat_status文件中的内容如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;service mycat_status
{
flags = REUSE
socket_type = stream
port = 48700
wait = no
user = root
server =/usr/local/bin/mycat_check.sh
log_on_failure += USERID
disable = no
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;部分xinetd配置参数说明如下所示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;socket_type：表示封包处理方式，Stream为TCP数据包。&lt;/li&gt;
&lt;li&gt;port：表示xinetd服务监听的端口号。&lt;/li&gt;
&lt;li&gt;wait：表示不需等待，即服务将以多线程的方式运行。&lt;/li&gt;
&lt;li&gt;user：运行xinted服务的用户。&lt;/li&gt;
&lt;li&gt;server：需要启动的服务脚本。&lt;/li&gt;
&lt;li&gt;log_on_failure：记录失败的日志内容。&lt;/li&gt;
&lt;li&gt;disable：需要启动xinted服务时，需要将此配置项设置为no。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（6）在/usr/local/bin目录下添加mycat_check.sh服务脚本，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;touch /usr/local/bin/mycat_check.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（7）编辑/usr/local/bin/mycat_check.sh文件，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim /usr/local/bin/mycat_check.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编辑后的文件内容如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
mycat=`/usr/local/mycat/bin/mycat status | grep 'not running' | wc -l`
if [ &quot;$mycat&quot; = &quot;0&quot; ]; then
/bin/echo -e &quot;HTTP/1.1 200 OK\r\n&quot;
else
/bin/echo -e &quot;HTTP/1.1 503 Service Unavailable\r\n&quot;
/usr/local/mycat/bin/mycat start
fi
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为mycat_check.sh文件赋予可执行权限，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;chmod a+x /usr/local/bin/mycat_check.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（8）编辑/etc/services文件，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim /etc/services
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在文件末尾添加如下所示的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mycat_status  48700/tcp        # mycat_status
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，端口号需要与在/etc/xinetd.d/mycat_status文件中配置的端口号相同。&lt;/p&gt;
&lt;p&gt;（9）重启xinetd服务，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;service xinetd restart
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（10）查看mycat_status服务是否成功启动，如下所示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;binghe151服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# netstat -antup|grep 48700
tcp    0   0 :::48700          :::*      LISTEN   2776/xinetd
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;binghe154服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe154 ~]# netstat -antup|grep 48700
tcp    0   0 :::48700          :::*      LISTEN   6654/xinetd
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示，两台服务器上的mycat_status服务器启动成功。&lt;/p&gt;
&lt;p&gt;至此，xinetd服务安装并配置成功，即Mycat状态检查服务安装成功。&lt;/p&gt;
&lt;h2 id=&quot;安装并配置haproxy&quot;&gt;安装并配置HAProxy&lt;/h2&gt;
&lt;p&gt;我们直接在binghe151和binghe154服务器上使用如下命令安装HAProxy。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;yum install haproxy -y
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完成后，我们需要对HAProxy进行配置，HAProxy的配置文件目录为/etc/haproxy，我们查看这个目录下的文件信息，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# ll /etc/haproxy/
total 4
-rw-r--r-- 1 root root 3142 Oct 21  2016 haproxy.cfg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现/etc/haproxy/目录下存在一个haproxy.cfg文件。接下来，我们就修改haproxy.cfg文件，修改后的haproxy.cfg文件的内容如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;global
    log         127.0.0.1 local2

    chroot      /var/lib/haproxy
    pidfile     /var/run/haproxy.pid
    maxconn     4000
    user        haproxy
    group       haproxy
    daemon
    stats socket /var/lib/haproxy/stats

defaults
    mode                    http
    log                     global
    option                  httplog
    option                  dontlognull
    option http-server-close
    option                  redispatch
    retries                 3
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    maxconn                 3000

listen  admin_status
      bind 0.0.0.0:48800
      stats uri /admin-status
      stats auth  admin:admin
listen    allmycat_service
      bind 0.0.0.0:3366
      mode tcp
      option tcplog
          option httpchk OPTIONS * HTTP/1.1\r\nHost:\ www
      balance    roundrobin
      server    mycat_151 192.168.175.151:3307 check port 48700 inter 5s rise 2 fall 3
      server    mycat_154 192.168.175.154:3307 check port 48700 inter 5s rise 2 fall 3
listen    allmycat_admin
      bind 0.0.0.0:3377
      mode tcp
      option tcplog
          option httpchk OPTIONS * HTTP/1.1\r\nHost:\ www
      balance    roundrobin
      server    mycat_151 192.168.175.151:3308 check port 48700 inter 5s rise 2 fall 3
      server    mycat_154 192.168.175.154:3308 check port 48700 inter 5s rise 2 fall 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，在binghe151服务器和binghe154服务器上启动HAProxy，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;haproxy -f /etc/haproxy/haproxy.cfg 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们使用mysql命令连接HAProxy监听的虚拟IP和端口来连接Mycat，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# mysql -umycat -pmycat -h192.168.175.110 -P3366 --default-auth=mysql_native_password  
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.6.29-mycat-1.6.7.4-release-20200228205020 MyCat Server (OpenCloudDB)

Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，连接Mycat成功。&lt;/p&gt;
&lt;h2 id=&quot;安装keepalived&quot;&gt;安装Keepalived&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.安装并配置Keepalived&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接在binghe151和binghe154服务器上输入如下命令安装Keepalived。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;yum install keepalived -y
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装成功后，会在/etc目录下生成一个keepalived目录，接下来，我们在/etc/keepalived目录下配置keepalived.conf文件，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim /etc/keepalived/keepalived.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;binghe151服务器配置&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;! Configuration Fileforkeepalived
vrrp_script chk_http_port {
  script &quot;/etc/keepalived/check_haproxy.sh&quot;
  interval 2
  weight 2
}
vrrp_instance VI_1 {
  state MASTER 
  interface eth0 
  virtual_router_id 51 
  priority 150 
  advert_int 1 
  authentication {
  auth_type PASS
  auth_pass 1111
}
track_script {
  chk_http_port
}
virtual_ipaddress { 
  192.168.175.110 dev eth0 scope global
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;binghe154服务器配置&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;! Configuration Fileforkeepalived
vrrp_script chk_http_port {
  script &quot;/etc/keepalived/check_haproxy.sh&quot;
  interval 2
  weight 2
}
vrrp_instance VI_1 {
  state SLAVE 
  interface eth0 
  virtual_router_id 51 
  priority 120
  advert_int 1 
  authentication {
  auth_type PASS
  auth_pass 1111
}
track_script {
  chk_http_port
}
virtual_ipaddress { 
  192.168.175.110 dev eth0 scope global
}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.编写检测HAProxy的脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，需要分别在binghe151和binghe154服务器上的/etc/keepalived目录下创建check_haproxy.sh脚本，脚本内容如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
STARTHAPROXY=&quot;/usr/sbin/haproxy -f /etc/haproxy/haproxy.cfg&quot;
STOPKEEPALIVED=&quot;/etc/init.d/keepalived stop&quot;
#STOPKEEPALIVED=&quot;/usr/bin/systemctl stop keepalived&quot;
LOGFILE=&quot;/var/log/keepalived-haproxy-state.log&quot;
echo &quot;[check_haproxy status]&quot; &amp;gt;&amp;gt; $LOGFILE
A=`ps -C haproxy --no-header |wc -l`
echo &quot;[check_haproxy status]&quot; &amp;gt;&amp;gt; $LOGFILE
date &amp;gt;&amp;gt; $LOGFILE
if [ $A -eq 0 ];then
   echo $STARTHAPROXY &amp;gt;&amp;gt; $LOGFILE
   $STARTHAPROXY &amp;gt;&amp;gt; $LOGFILE 2&amp;gt;&amp;amp;1
   sleep 5
fi
if [ `ps -C haproxy --no-header |wc -l` -eq 0 ];then
   exit 0
else
   exit 1
fi
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用如下命令为check_haproxy.sh脚本授予可执行权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;chmod a+x /etc/keepalived/check_haproxy.sh 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.启动Keepalived&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置完成后，我们就可以启动Keepalived了，分别在binghe151和binghe154服务器上启动Keepalived，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/etc/init.d/keepalived start
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看Keepalived是否启动成功，如下所示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;binghe151服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# ps -ef | grep keepalived
root       1221      1  0 20:06 ?        00:00:00 keepalived -D
root       1222   1221  0 20:06 ?        00:00:00 keepalived -D
root       1223   1221  0 20:06 ?        00:00:02 keepalived -D
root      93290   3787  0 21:42 pts/0    00:00:00 grep keepalived
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;binghe154服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe154 ~]# ps -ef | grep keepalived
root       1224      1  0 20:06 ?        00:00:00 keepalived -D
root       1225   1224  0 20:06 ?        00:00:00 keepalived -D
root       1226   1224  0 20:06 ?        00:00:02 keepalived -D
root      94636   3798  0 21:43 pts/0    00:00:00 grep keepalived
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，两台服务器上的Keepalived服务启动成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.验证Keepalived绑定的虚拟IP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们分别查看两台服务器上的Keepalived是否绑定了虚拟IP。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;binghe151服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:10:a1:45 brd ff:ff:ff:ff:ff:ff
    inet 192.168.175.151/24 brd 192.168.175.255 scope global eth0
    inet 192.168.175.110/32 scope global eth0
    inet 192.168.175.110/24 brd 192.168.175.255 scope global secondary eth0:1
    inet6 fe80::20c:29ff:fe10:a145/64 scope link 
       valid_lft forever preferred_lft forever
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到如下一行代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;inet 192.168.175.110/32 scope global eth0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明binghe151服务器上的Keepalived绑定了虚拟IP 192.168.175.110。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;binghe154服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe154 ~]# ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:50:56:22:2a:75 brd ff:ff:ff:ff:ff:ff
    inet 192.168.175.154/24 brd 192.168.175.255 scope global eth0
    inet 192.168.175.110/24 brd 192.168.175.255 scope global secondary eth0:1
    inet6 fe80::250:56ff:fe22:2a75/64 scope link 
       valid_lft forever preferred_lft forever
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到binghe154服务器上的Keepalived并没有绑定虚拟IP。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.测试虚拟IP的漂移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何测试虚拟IP的漂移呢？首先，我们停止binghe151服务器上的Keepalived，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/etc/init.d/keepalived stop
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，查看binghe154服务器上Keepalived绑定虚拟IP的情况，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe154 ~]# ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:50:56:22:2a:75 brd ff:ff:ff:ff:ff:ff
    inet 192.168.175.154/24 brd 192.168.175.255 scope global eth0
    inet 192.168.175.110/32 scope global eth0
    inet 192.168.175.110/24 brd 192.168.175.255 scope global secondary eth0:1
    inet6 fe80::250:56ff:fe22:2a75/64 scope link 
       valid_lft forever preferred_lft forever
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在输出的结果信息中，存在如下一行信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt; inet 192.168.175.110/32 scope global eth0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明binghe154服务器上的Keepalived绑定了虚拟IP 192.168.175.110，虚拟IP漂移到了binghe154服务器上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.binghe151服务器上的Keepalived抢占虚拟IP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们启动binghe151服务器上的Keepalived，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/etc/init.d/keepalived start
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功后，我们再次查看虚拟IP的绑定情况，如下所示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;binghe151服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe151 ~]# ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:10:a1:45 brd ff:ff:ff:ff:ff:ff
    inet 192.168.175.151/24 brd 192.168.175.255 scope global eth0
    inet 192.168.175.110/32 scope global eth0
    inet 192.168.175.110/24 brd 192.168.175.255 scope global secondary eth0:1
    inet6 fe80::20c:29ff:fe10:a145/64 scope link 
       valid_lft forever preferred_lft forever
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;binghe154服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe154 ~]# ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:50:56:22:2a:75 brd ff:ff:ff:ff:ff:ff
    inet 192.168.175.154/24 brd 192.168.175.255 scope global eth0
    inet 192.168.175.110/24 brd 192.168.175.255 scope global secondary eth0:1
    inet6 fe80::250:56ff:fe22:2a75/64 scope link 
       valid_lft forever preferred_lft forever
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于binghe151服务器上配置的Keepalived优先级要高于binghe154服务器上的Keepalived，所以，再次启动binghe151服务器上的Keepalived后，binghe151服务器上的Keepalived会抢占虚拟IP。&lt;/p&gt;
&lt;h2 id=&quot;配置mysql主从复制&quot;&gt;配置MySQL主从复制&lt;/h2&gt;
&lt;p&gt;这里，为了简单，&lt;strong&gt;我将binghe154和binghe155服务器上的MySQL配置成主从复制&lt;/strong&gt;，大家也可以根据实际情况，自行配置其他服务器上MySQL的主从复制（注意：我这里配置的是一主一从模式）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.编辑my.cnf文件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;binghe154服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;server_id = 154
log_bin = /data/mysql/log/bin_log/mysql-bin
binlog-ignore-db=mysql
binlog_format= mixed
sync_binlog=100
log_slave_updates = 1
binlog_cache_size=32m
max_binlog_cache_size=64m
max_binlog_size=512m
lower_case_table_names = 1
relay_log = /data/mysql/log/bin_log/relay-bin
relay_log_index = /data/mysql/log/bin_log/relay-bin.index
master_info_repository=TABLE
relay-log-info-repository=TABLE
relay-log-recovery
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;binghe155服务器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;server_id = 155
log_bin = /data/mysql/log/bin_log/mysql-bin
binlog-ignore-db=mysql
binlog_format= mixed
sync_binlog=100
log_slave_updates = 1
binlog_cache_size=32m
max_binlog_cache_size=64m
max_binlog_size=512m
lower_case_table_names = 1
relay_log = /data/mysql/log/bin_log/relay-bin
relay_log_index = /data/mysql/log/bin_log/relay-bin.index
master_info_repository=TABLE
relay-log-info-repository=TABLE
relay-log-recovery
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.同步两台服务器上MySQL的数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在binghe154服务器上只有一个customer_db数据库，我们使用mysqldump命令导出customer_db数据库，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@binghe154 ~]# mysqldump --master-data=2 --single-transaction -uroot -p --databases customer_db &amp;gt; binghe154.sql
Enter password: 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们查看binghe154.sql文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;more binghe154.sql
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在文件中，我们可以找到如下信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;CHANGE MASTER TO MASTER_LOG_FILE='mysql-bin.000042', MASTER_LOG_POS=995;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明当前MySQL的二进制日志文件为mysql-bin.000042，二进制日志文件的位置为995。&lt;/p&gt;
&lt;p&gt;接下来，我们将binghe154.sql文件复制到binghe155服务器上，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;scp binghe154.sql 192.168.175.155:/usr/local/src
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在binghe155服务器上，将binghe154.sql脚本导入到MySQL中，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mysql -uroot -p &amp;lt; /usr/local/src/binghe154.sql
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，完成了数据的初始化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.创建主从复制账号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在binghe154服务器的MySQL中，创建用于主从复制的MySQL账号，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; CREATE USER 'repl'@'192.168.175.%' IDENTIFIED BY 'repl123456';
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; ALTER USER 'repl'@'192.168.175.%' IDENTIFIED WITH mysql_native_password BY 'repl123456';                           
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.175.%';
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.配置复制链路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;登录binghe155服务器上的MySQL，并使用如下命令配置复制链路。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; change master to 
     &amp;gt; master_host='192.168.175.154',
     &amp;gt; master_port=3306,
     &amp;gt; master_user='repl',
     &amp;gt; master_password='repl123456',
     &amp;gt; MASTER_LOG_FILE='mysql-bin.000042',
     &amp;gt; MASTER_LOG_POS=995;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，MASTER_LOG_FILE='mysql-bin.000042', MASTER_LOG_POS=995 就是在binghe154.sql文件中找到的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.启动从库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在binghe155服务器的MySQL命令行启动从库，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; start slave;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看从库是否启动成功，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; SHOW slave STATUS \G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.175.151
                  Master_User: binghe152
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000007
          Read_Master_Log_Pos: 1360
               Relay_Log_File: relay-bin.000003
                Relay_Log_Pos: 322
        Relay_Master_Log_File: mysql-bin.000007
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
#################省略部分输出结果信息##################
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示Slave_IO_Running选项和Slave_SQL_Running选项的值均为Yes，说明MySQL主从复制环境搭建成功。&lt;/p&gt;
&lt;p&gt;最后，别忘了在binghe155服务器的MySQL中创建Mycat连接MySQL的用户，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE USER 'mycat'@'192.168.175.%' IDENTIFIED BY 'mycat';
ALTER USER 'mycat'@'192.168.175.%' IDENTIFIED WITH mysql_native_password BY 'mycat'; 
GRANT SELECT, INSERT, UPDATE, DELETE,EXECUTE  ON *.* TO 'mycat'@'192.168.175.%';
FLUSH PRIVILEGES;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置mycat读写分离&quot;&gt;配置Mycat读写分离&lt;/h2&gt;
&lt;p&gt;修改Mycatd的schema.xml文件，实现binghe154和binghe155服务器上的MySQL读写分离。在Mycat安装目录的conf/zkconf目录下，修改schema.xml文件，修改后的schema.xml文件如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&amp;gt;
&amp;lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&amp;gt;
    &amp;lt;schema name=&quot;shop&quot; checkSQLschema=&quot;true&quot; sqlMaxLimit=&quot;1000&quot;&amp;gt;
        &amp;lt;table name=&quot;order_master&quot; dataNode=&quot;orderdb01,orderdb02,orderdb03,orderdb04&quot; rule=&quot;order_master&quot; primaryKey=&quot;order_id&quot; autoIncrement=&quot;true&quot;&amp;gt;
            &amp;lt;childTable name=&quot;order_detail&quot; joinKey=&quot;order_id&quot; parentKey=&quot;order_id&quot; primaryKey=&quot;order_detail_id&quot; autoIncrement=&quot;true&quot;/&amp;gt;
        &amp;lt;/table&amp;gt;
        &amp;lt;table name=&quot;order_cart&quot; dataNode=&quot;ordb&quot; primaryKey=&quot;cart_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;order_customer_addr&quot; dataNode=&quot;ordb&quot; primaryKey=&quot;customer_addr_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;region_info&quot; dataNode=&quot;ordb,prodb,custdb&quot; primaryKey=&quot;region_id&quot; type=&quot;global&quot;/&amp;gt;
        &amp;lt;table name=&quot;serial&quot; dataNode=&quot;ordb&quot; primaryKey=&quot;id&quot;/&amp;gt;
        &amp;lt;table name=&quot;shipping_info&quot; dataNode=&quot;ordb&quot; primaryKey=&quot;ship_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;warehouse_info&quot; dataNode=&quot;ordb&quot; primaryKey=&quot;w_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;warehouse_proudct&quot; dataNode=&quot;ordb&quot; primaryKey=&quot;wp_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;product_brand_info&quot; dataNode=&quot;prodb&quot; primaryKey=&quot;brand_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;product_category&quot; dataNode=&quot;prodb&quot; primaryKey=&quot;category_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;product_comment&quot; dataNode=&quot;prodb&quot; primaryKey=&quot;comment_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;product_info&quot; dataNode=&quot;prodb&quot; primaryKey=&quot;product_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;product_pic_info&quot; dataNode=&quot;prodb&quot; primaryKey=&quot;product_pic_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;product_supplier_info&quot; dataNode=&quot;prodb&quot; primaryKey=&quot;supplier_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;customer_balance_log&quot; dataNode=&quot;custdb&quot; primaryKey=&quot;balance_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;customer_inf&quot; dataNode=&quot;custdb&quot; primaryKey=&quot;customer_inf_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;customer_level_inf&quot; dataNode=&quot;custdb&quot; primaryKey=&quot;customer_level&quot;/&amp;gt;
        &amp;lt;table name=&quot;customer_login&quot; dataNode=&quot;custdb&quot; primaryKey=&quot;customer_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;customer_login_log&quot; dataNode=&quot;custdb&quot; primaryKey=&quot;login_id&quot;/&amp;gt;
        &amp;lt;table name=&quot;customer_point_log&quot; dataNode=&quot;custdb&quot; primaryKey=&quot;point_id&quot;/&amp;gt;
    &amp;lt;/schema&amp;gt;
        
    &amp;lt;dataNode name=&quot;mycat&quot; dataHost=&quot;binghe151&quot; database=&quot;mycat&quot;/&amp;gt;
    &amp;lt;dataNode name=&quot;ordb&quot; dataHost=&quot;binghe152&quot; database=&quot;order_db&quot;/&amp;gt;
    &amp;lt;dataNode name=&quot;prodb&quot; dataHost=&quot;binghe153&quot; database=&quot;product_db&quot;/&amp;gt;
    &amp;lt;dataNode name=&quot;custdb&quot; dataHost=&quot;binghe154&quot; database=&quot;customer_db&quot;/&amp;gt;
    &amp;lt;dataNode name=&quot;orderdb01&quot; dataHost=&quot;binghe152&quot; database=&quot;orderdb01&quot;/&amp;gt;
    &amp;lt;dataNode name=&quot;orderdb02&quot; dataHost=&quot;binghe152&quot; database=&quot;orderdb02&quot;/&amp;gt;
    &amp;lt;dataNode name=&quot;orderdb03&quot; dataHost=&quot;binghe153&quot; database=&quot;orderdb03&quot;/&amp;gt;
    &amp;lt;dataNode name=&quot;orderdb04&quot; dataHost=&quot;binghe153&quot; database=&quot;orderdb04&quot;/&amp;gt;
        
    &amp;lt;dataHost balance=&quot;1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; name=&quot;binghe151&quot; writeType=&quot;0&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&amp;gt;
        &amp;lt;heartbeat&amp;gt;select user()&amp;lt;/heartbeat&amp;gt;
        &amp;lt;writeHost host=&quot;binghe51&quot; url=&quot;192.168.175.151:3306&quot; password=&quot;mycat&quot; user=&quot;mycat&quot;/&amp;gt;
    &amp;lt;/dataHost&amp;gt;
    &amp;lt;dataHost balance=&quot;1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; name=&quot;binghe152&quot; writeType=&quot;0&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&amp;gt;
        &amp;lt;heartbeat&amp;gt;select user()&amp;lt;/heartbeat&amp;gt;
        &amp;lt;writeHost host=&quot;binghe52&quot; url=&quot;192.168.175.152:3306&quot; password=&quot;mycat&quot; user=&quot;mycat&quot;/&amp;gt;
    &amp;lt;/dataHost&amp;gt;
    &amp;lt;dataHost balance=&quot;1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; name=&quot;binghe153&quot; writeType=&quot;0&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&amp;gt;
        &amp;lt;heartbeat&amp;gt;select user()&amp;lt;/heartbeat&amp;gt;
        &amp;lt;writeHost host=&quot;binghe53&quot; url=&quot;192.168.175.153:3306&quot; password=&quot;mycat&quot; user=&quot;mycat&quot;/&amp;gt;
    &amp;lt;/dataHost&amp;gt;
    &amp;lt;dataHost balance=&quot;1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; name=&quot;binghe154&quot; writeType=&quot;0&quot; switchTymycate=&quot;1&quot; slaveThreshold=&quot;100&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot;&amp;gt;
        &amp;lt;heartbeat&amp;gt;select user()&amp;lt;/heartbeat&amp;gt;
        &amp;lt;writeHost host=&quot;binghe54&quot; url=&quot;192.168.175.154:3306&quot; password=&quot;mycat&quot; user=&quot;mycat&quot;&amp;gt;
                        &amp;lt;readHost host=&quot;binghe55&quot;, url=&quot;192.168.175.155:3306&quot; user=&quot;mycat&quot; password=&quot;mycat&quot;/&amp;gt;
                &amp;lt;/writeHost&amp;gt;
         &amp;lt;writeHost host=&quot;binghe55&quot; url=&quot;192.168.175.155:3306&quot; password=&quot;mycat&quot; user=&quot;mycat&quot;/&amp;gt;
    &amp;lt;/dataHost&amp;gt;
&amp;lt;/mycat:schema&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存并退出vim编辑器，接下来，初始化Zookeeper中的数据，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/usr/local/mycat/bin/init_zk_data.sh 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述命令执行成功后，会自动将配置同步到binghe151和binghe154服务器上的Mycat的安装目录下的conf目录下的schema.xml中。&lt;/p&gt;
&lt;p&gt;接下来，分别启动binghe151和binghe154服务器上的Mycat服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mycat restart
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何访问高可用环境&quot;&gt;如何访问高可用环境&lt;/h2&gt;
&lt;p&gt;此时，整个高可用环境配置完成，上层应用连接高可用环境时，需要连接HAProxy监听的IP和端口。比如使用mysql命令连接高可用环境如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;[root@binghe151 ~]# mysql -umycat -pmycat -h192.168.175.110 -P3366 --default-auth=mysql_native_password
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 2
Server version: 5.6.29-mycat-1.6.7.4-release-20200228205020 MyCat Server (OpenCloudDB)

Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&amp;gt; show databases;
+----------+
| DATABASE |
+----------+
| shop     |
+----------+
1 row in set (0.10 sec)

mysql&amp;gt; use shop;
Database changed
mysql&amp;gt; show tables;
+-----------------------+
| Tables in shop        |
+-----------------------+
| customer_balance_log  |
| customer_inf          |
| customer_level_inf    |
| customer_login        |
| customer_login_log    |
| customer_point_log    |
| order_cart            |
| order_customer_addr   |
| order_detail          |
| order_master          |
| product_brand_info    |
| product_category      |
| product_comment       |
| product_info          |
| product_pic_info      |
| product_supplier_info |
| region_info           |
| serial                |
| shipping_info         |
| warehouse_info        |
| warehouse_proudct     |
+-----------------------+
21 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我只是对binghe154服务器上的MySQL扩展了读写分离环境，大家也可以根据实际情况对其他服务器的MySQL实现主从复制和读写分离，这样，整个高可用环境就实现了HAProxy的高可用、Mycat的高可用、MySQL的高可用、Zookeeper的高可用和Keepalived的高可用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好了，今天就到这儿吧，我是冰河，大家有啥问题可以在下方留言，也可以加我微信，一起交流技术，一起进阶，一起牛逼~~&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 Jan 2021 17:21:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 业界对系统的高可用有着基本的要求，简单的说，这些要求可以总结为如下所示。 系统架构中不存在单点问题。 可以最大限度的保障服务的可用性。 一般情况下系统的高可用可以用几个9来评估。所谓的几个9</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/14257232.html</dc:identifier>
</item>
<item>
<title>Liunx运维(十二)-Liunx系统常用内置命令 - Mrwhite86</title>
<link>http://www.cnblogs.com/mrwhite2020/p/14196689.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrwhite2020/p/14196689.html</guid>
<description>&lt;p&gt;文档目录：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q00&quot;&gt;一、Liunx内置命令概述&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q01&quot;&gt;二、LIunx常用内置命令实例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q1&quot;&gt;1、help查看内置命令帮助&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q2&quot;&gt;2、查看内置命令使用方法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q3&quot;&gt;3、&quot;:&quot; 占位符&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q4&quot;&gt;4、 &quot;.&quot; 与source&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q5&quot;&gt;5、条件测试&quot;[&quot;和test&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#a6&quot;&gt;6、命令别名alias和unalias&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q7&quot;&gt;7、后台任务相关bg/fg/jobs&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q8&quot;&gt;8、break跳出循环&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q9&quot;&gt;9、continue进入下一次循环&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q10&quot;&gt;10、eval将参数当作命令执行&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q11&quot;&gt;11、exit退出&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q12&quot;&gt;12、export查看或设置全局变量&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q13&quot;&gt;13、history查看命令历史记录&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q14&quot;&gt;14、read交互式赋值变量&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q14&quot;&gt;15、type判断命令类型&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q16&quot;&gt;16、umlit修改系统资源使用限制&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196689.html#q17&quot;&gt;17、unset清空变量&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;---------------------------------------分割线：正文--------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、Liunx内置命令概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内置命令在BASH解释器中，天生与其他普通的命令不同，系统启动成功时就在内存中。&lt;/p&gt;
&lt;p&gt;执行效率远远高于普通命令。&lt;/p&gt;
&lt;p&gt;而特殊的命令如：echo、pwd、kill等，既有内置命令版本，也有普通命令版本，用法一样，我们能在磁盘上找到他们的程序文件/bin/echo、/bin/pwd、/bin/kill，一般情况下，优先使用内置命令，除非显示的执行/bin/echo这种全路径命令&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、LIunx常用内置命令实例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、help查看内置命令帮助&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109175518245-1905218455.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;  2、查看内置命令使用方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;help help&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109175556016-1396030657.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; help cd&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109175634113-569081190.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 3、&quot;:&quot; 占位符&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;shell脚本中使用：作为占位符，防止报错&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、 &quot;.&quot; 与source&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &quot;.&quot; 与source常用于加载或执行shell脚本&lt;/p&gt;
&lt;p&gt;第一种执行方式：bash scrpt-name 或 sh scrpt-name执行方式：当没有可执行权限时经常使用的方法,此外，脚本没有解释器时也需要用到。&lt;/p&gt;
&lt;p&gt;第二种执行方式：source  scrpt-name 或  . scrpt-name执行方式：读入或加载指定的shell脚本，然后，依次执行指定的shell脚本中的所有脚本，可传递值到父脚本shell&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、条件测试&quot;[&quot;和test&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[]与test条件控制使用&lt;/p&gt;
&lt;p&gt;test -f file &amp;amp;&amp;amp; echo true || echo false #如果file文件存在并且是普通文件就是真，不存在输出false&lt;/p&gt;
&lt;p&gt;[ -f file ] &amp;amp;&amp;amp; echo 1 || echo 0 #文件存在，返回1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109202021372-1459226101.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 6、命令别名alias和unalias&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;alias #显示系统别名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109202143048-559000347.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; alias ens33='cat /etc/sysconfig/network-scripts/ifcfg-ens33' #设置ens33别名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109202720902-618685979.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; unalias ens33 #删除别名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109202823129-1511683069.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;7、后台任务相关bg/fg/jobs&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bg：将前台执行任务转入后台，或者将后台暂停的任务运行起来；fg命令和bg命令相反，它是将后台任务调到前台来执行；jobs命令可以用于查看后台任务列表&lt;/p&gt;
&lt;p&gt;jobs #查看任务列表&lt;/p&gt;
&lt;p&gt;bg # bg 1将第一个任务启动&lt;/p&gt;
&lt;p&gt;fg #将后台任务调入前台&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109204307674-565905693.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;nc -l 12345 &amp;amp; #直接使用&amp;amp;将任务放入后台，并且任务状态是运行的&lt;/p&gt;
&lt;p&gt;kill %1 #快速杀除后台任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109211745531-1327147552.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 8、break跳出循环&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109212146089-762092755.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 9、continue进入下一次循环&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109212411381-2117348123.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 10、eval将参数当作命令执行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;eval echo '`hostname -I`' #eval命令，单引号失效了，eval命令可以优先解析或执行单引号内的变量或命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109234555141-45227714.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 11、exit退出&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;exit #退出命令行，等价于logout，ctrl+d&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109234727758-565722798.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  退出脚本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109235006987-775156086.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 12、export查看或设置全局变量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;export -p #-p打印所有环境变量&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109235644192-589247799.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; export MYEVN=7 #设置全局变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109235853264-1199582768.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 13、history查看命令历史记录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;history | more #显示所有历史记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110001823119-1616241686.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; history 10 #查看最近n条的历史记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110001904321-1178485300.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; history -d  1019 #删除指定的历史记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110002127517-1825893358.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; history -c #清除所有命令的历史记录&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110002329472-2087913950.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 14、read交互式赋值变量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;read #等待输入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110002539828-10093053.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; read one #存储到$one变量内&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110002623886-549515397.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; read one two #接多个变量，输入时空格分割&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110002728311-993232651.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; read -p &quot;请输入你的年龄&quot; age #-p可以定义显示在命令行的提示语句&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110002901408-135751716.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; read -t 3 -p &quot;请输入你的年龄:&quot; age #-t指定等待超时的秒&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110003010938-1845846444.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; read -s -p &quot;请输入你的银行卡密码:&quot; pass  #-s关闭回显&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110003216887-495335851.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; read -n 3 -p &quot;max=3输入：&quot; num #-n设置输入的最大长度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110003331051-1171348183.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 15、type判断命令类型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;type ls #显示ls最主要的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110003443146-1671122680.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; type -t ls #精简显示命令类型为别名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110003517554-1981244462.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; type -a ls #显示所有相关信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110003546806-1473658178.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; type cd #显示内置命令类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110003633839-800286657.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 16、umlit修改系统资源使用限制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ulimit -a #显示当前所有系统资源使用限制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110003846860-1979155466.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面这些参数中，通常我们关注得比较多:&lt;/p&gt;
&lt;p&gt;open files: 一个进程可打开的最大文件数.&lt;/p&gt;
&lt;p&gt;max user processes: 系统允许创建的最大进程数量.&lt;/p&gt;
&lt;p&gt;通过 ps -efL|grep java |wc -l 查看目前java程序的进程数，如果超过限制需要修改&lt;/p&gt;
&lt;p&gt;ulimit -n #查看打开文件的最大数量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110004311473-27202046.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; ulimit -n 65535 #调整，但之当前窗口生效&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110004352505-1738720584.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; echo '* - nofile 65535' &amp;gt;&amp;gt; /etc/security/limits.conf #修改配置永久生效（重新登录窗口）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110005713788-429158886.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 17、unset清空变量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;unset MRWHITE MRSLU #将变量值清空&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210110005925105-791782861.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 09 Jan 2021 17:16:00 +0000</pubDate>
<dc:creator>Mrwhite86</dc:creator>
<og:description>文档目录： 一、Liunx内置命令概述 二、LIunx常用内置命令实例 1、help查看内置命令帮助2、查看内置命令使用方法3、&amp;quot;:&amp;quot; 占位符4、 &amp;quot;.&amp;quot; 与s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrwhite2020/p/14196689.html</dc:identifier>
</item>
<item>
<title>探索 .NET团队对API的设计流程 - SpringLeee</title>
<link>http://www.cnblogs.com/myshowtime/p/14257159.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myshowtime/p/14257159.html</guid>
<description>&lt;blockquote readability=&quot;2.4950495049505&quot;&gt;
&lt;p&gt;原文作者：steve gordon&lt;br/&gt;原文链接: &lt;a href=&quot;https://www.stevejgordon.co.uk/how-are-dotnet-apis-designed&quot; title=&quot;https://www.stevejgordon.co.uk/how-are-dotnet-apis-designed&quot; target=&quot;_blank&quot;&gt;https://www.stevejgordon.co.uk/how-are-dotnet-apis-designed&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这篇文章中，我想介绍一些我觉得非常有趣的东西，.NET 团队是如何设计API的？ 我们先来看下.NET团队面临的有哪些挑战，您正在设计一套API库，每天有数百万的开发人员在使用这些库，它们在世界各地运行在重要的应用程序上面，您要对其进行改进并添加新功能或增强功能，而且不能破坏数百万个现有应用程序，这确实让人头大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210110_121520.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我喜欢编写C＃代码，自己也写过很多API库，其中很多都是内部使用的库，而使用这个库的不到30人，即使这样，我仍然写了bug，那我得修啊，但我没有意识到所有的环境下这个库都是否可以使用， 以过去我的经验，我觉得设计公共API很困难。&lt;/p&gt;
&lt;p&gt;在本文的其余部分中，我将按照我的理解来解释.NET API设计过程，这些是我根据对这一过程进行了几年的观察而得出的自己的解释，团队所做的大部分工作都是公开发布的，因此可以从他们如何组织.NET Core（和.NET 5）的API设计中学到很多东西。&lt;/p&gt;
&lt;p&gt;为了使解释更具体，我将遵循最近的新库的设计，该库将作为.NET 5的.NET BCL（基类库）的一部分包括在内，比如，&lt;code&gt;System.Net.Http.Json&lt;/code&gt; 这个库优化了 HttpClient 处理Json，我今天不讲这个库如何使用，我们将专注于它是如何产生的。&lt;/p&gt;
&lt;h3 id=&quot;1设计阶段---design&quot;&gt;1.设计阶段 - Design&lt;/h3&gt;
&lt;p&gt;最开始，Immo Landwerth 发现在HttpClient中处理Json很麻烦，于是他在github提了一个json扩展的建议，里面包含了遇到了哪些问题，然后如何改进。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210109_105422.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用简单明了的术语，描述了这个设计如何变得更好，以及用户（开发人员）对该功能的使用体验，包括示例代码，表达了开发人员会在什么情况下使用这个API。&lt;/p&gt;
&lt;p&gt;在明确方案的情况下，接着继续介绍新的API的要求,它必须实现什么目标，在什么时间范围内？然后是设计本身，该设计包括建议的公共API，但是没有任何实现细节, 这包括设计引入的所有公共方法和类型。&lt;/p&gt;
&lt;h3 id=&quot;2net设计审查阶段---review&quot;&gt;2.NET设计审查阶段 - Review&lt;/h3&gt;
&lt;p&gt;.NET流程的下一个阶段是进行API设计审查, 这在Github上面进行，团队创建了一个 Issue，&lt;a href=&quot;https://github.com/dotnet/runtime/issues/32937&quot; title=&quot;https://github.com/dotnet/runtime/issues/32937&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/runtime/issues/32937&lt;/a&gt;, 大家都有权限看到，这是公开的，因此社区可以征询反馈和建议，我真的很喜欢这些.NET开放的氛围！&lt;/p&gt;
&lt;p&gt;API开始审查，在此会议上，.NET团队的核心专家汇聚一堂，评估方案并确保公共API适合目标框架，这是至关重要的一步，为了兼容性，设计中的错误或疏忽可能会持续很长时间，这意味着API决策需要彻底，团队也希望该API易于使用。&lt;/p&gt;
&lt;p&gt;在API审核期间，会有人代表提案，并说明拟议设计的目标和原因，然后，团队将对其进行讨论，并确定提案是否需要进一步的工作，然后再批准，在被认为可以接受之前，可以在多次设计评审中提出一个API。&lt;/p&gt;
&lt;p&gt;我真正欣赏团队的一点是，他们在YouTube上现场直播了这次会议，任何人都可以观看，尽管有时在会议期间聊天中留下的评论和反馈可能被认为是讨论的一部分，但这主要是一种仅查看的方法，在YouTube上，.NET Foundation 频道下的所有播放记录都可以去浏览。&lt;/p&gt;
&lt;p&gt;您可以在YouTube上查看HttpClient JSON扩展方法的设计的讨论，&lt;a href=&quot;https://www.youtube.com/watch?v=_AHbjIS8_0I&quot; title=&quot;https://www.youtube.com/watch?v=_AHbjIS8_0I&quot; target=&quot;_blank&quot;&gt;https://www.youtube.com/watch?v=_AHbjIS8_0I&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210109_112030.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我感兴趣的API有讨论的时候，我就会经常上去看这些，我发现听到讨论并观看.NET团队对设计框架的想法非常有趣，在此过程中必须考虑许多细微的差异，这里面包含了大量的.NET 方面的知识，通常会提出一些细微的实现细节行为，例如现有API的历史方面及其行为，可能观看这样一次会议，要花一两个小时， 但我还是建议您有空可以参加其中的一些会议，来真正欣赏.NET框架的设计。&lt;/p&gt;
&lt;p&gt;在审查期间，通常会使用GitHub Issue的标准做法, .NET的程序经理 Immo Landwerth 通常主持会议并在讨论过程中做笔记, 任何关注,反馈和更改都将记录为设计审查的输出。&lt;/p&gt;
&lt;h3 id=&quot;3-提交阶段---pr&quot;&gt;3. 提交阶段 - PR&lt;/h3&gt;
&lt;p&gt;一旦获得批准，开发人员开始写写写，来实现这个API，就像这个示例一样，可能某些工作已经试验完成，然后还将需要把一些更改的内容，记录到设计评审的反馈中。&lt;/p&gt;
&lt;p&gt;该功能的大部分工作由David Cantu完成，可以在GitHub上的拉取请求（PR）这里看到，&lt;a href=&quot;https://github.com/dotnet/runtime/pull/33459&quot; title=&quot;https://github.com/dotnet/runtime/pull/33459&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/runtime/pull/33459&lt;/a&gt; ， 同样的它在Github，公开透明，任何人都可以订阅通知，甚至发表评论。&lt;/p&gt;
&lt;p&gt;我建议开发人员应该很熟悉这个阶段，开发人员在git分支上完成了一些工作，一旦该工作完成并准备好考虑合并，就可以创建一个PR，一般可以直接合并到项目，但是出于质量考虑，其他开发人员通常会进行一个或多个代码审查，在Microsoft .NET世界中，这必须要考虑全面，因为不一致和性能问题可能是以后要解决的问题。&lt;/p&gt;
&lt;p&gt;在这个例子中（Json扩展库），我们可以看到很多评论，包扩多个有经验的专家，您将看到有关代码复杂性的详细反馈，这是我从提出和讨论的小项目中学到很多东西的地方，随着时间的推移，您可以观看PR，甚至可以查看较新的提交，这些提交可以解决反馈并解决任何问题。&lt;/p&gt;
&lt;h3 id=&quot;4合并发布---release&quot;&gt;4.合并发布 - Release&lt;/h3&gt;
&lt;p&gt;一旦所有的审阅者批准了这个PR,然后这些代码被合并到master分支中，因为.NET 运行时是一个非常复杂的库，里面有高级的构建过程，来处理这些新合并的代码。&lt;/p&gt;
&lt;p&gt;最终，新代码将出现在相关库的夜间版本中(nightly)，也可能被推送到MyGet或NuGet feed中以供预览使用和测试，对于本篇的示例，生成了一个新程序包，并在NuGet上作为预发布预览发布了该程序包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210110_121815.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;这个过程非常有趣，我们了解到了.NET 团队，最初由一个想法，再经过设计，审查，讨论，最终上线，这些都在Github进行，都是公开的，在这个过程中，我们可以学习非常全面的.NET的知识，因为微软的专家处理这些事情，考虑的非常全面和细致。&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;欢迎扫码关注我们的公众号 【全球技术精选】，专注国外优秀博客的翻译和开源项目分享，也可以添加QQ群 897216102&lt;/p&gt;
&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/wechat-logo2.png&quot;/&gt;</description>
<pubDate>Sat, 09 Jan 2021 16:21:00 +0000</pubDate>
<dc:creator>SpringLeee</dc:creator>
<og:description>原文作者：steve gordon 原文链接: https://www.stevejgordon.co.uk/how-are-dotnet-apis-designed 在这篇文章中，我想介绍一些我觉得</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myshowtime/p/14257159.html</dc:identifier>
</item>
<item>
<title>使用GitHub Actions自动编译部署hexo博客 - Fungit</title>
<link>http://www.cnblogs.com/Fungit/p/github-acionts-automatically-compile-deploy.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Fungit/p/github-acionts-automatically-compile-deploy.html</guid>
<description>&lt;p&gt;使用hexo博客也挺久的，最开始是本地hexo clean &amp;amp;&amp;amp; hexo g，最后hexo d推送到服务器。后来是本地hexo clean &amp;amp;&amp;amp; hexo g，最后将生成文件推送到GitHub，GitHub actions 推送到服务器。后来本地文件丢失，GitHub 仅仅存着编译好public文件夹内容，该丢失就丢失了。有GitHub actions何不直接把编译、部署都交给他，还能备份博客，本地也不用安装一堆环境，使用这个方法也有段时间了，记录下。为了方便建站和编写，还是本地建议安装hexo。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;145.1468298109&quot;&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;使用hexo博客也挺久的，最开始是本地hexo clean &amp;amp;&amp;amp; hexo g，最后hexo d推送到服务器。后来是本地hexo clean &amp;amp;&amp;amp; hexo g，最后将生成文件推送到GitHub，GitHub actions 推送到服务器。后来本地文件丢失，GitHub 仅仅存着编译好public文件夹内容，该丢失就丢失了。有GitHub actions何不直接把编译、部署都交给他，还能备份博客，本地也不用安装一堆环境，使用这个方法也有段时间了，记录下。为了方便建站和编写，还是本地建议安装hexo。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;一、初始配置&quot;&gt;一、初始配置&lt;/h3&gt;
&lt;h4 id=&quot;ssh密钥配置&quot;&gt;ssh密钥配置&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ps: 只有且使用一个密钥就不要看了&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;github配置&quot;&gt;github配置&lt;/h5&gt;
&lt;p&gt;建立私有仓库&lt;code&gt;fungit.org&lt;/code&gt; ，不要初始化仓库。&lt;/p&gt;
&lt;p&gt;本地生成两份ssh密钥，一份用来本地push到GitHub，一份GitHub actions用来推送到服务器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ssh-keygen -t rsa -b 4096 -f /c/Users/Administrator/Documents/ssh/fungit_blog_github
ssh-keygen -t rsa -b 4096 -f /c/Users/Administrator/Documents/ssh/github_to_server
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在GitHub私有仓库&lt;code&gt;fungit.org&lt;/code&gt;添加 Depoly key，把刚刚生成的fungit_blog_github.pub添加进去，勾选write权限，用来推送本地文件。&lt;/p&gt;
&lt;p&gt;添加一个Secret，把刚刚生成的github_to_server添加进去（注意是私钥）名为&lt;code&gt;GITHUB_TO_SERVER_KEY&lt;/code&gt;，用来GitHub actions推送到服务器。&lt;/p&gt;
&lt;h5 id=&quot;服务器配置&quot;&gt;服务器配置&lt;/h5&gt;
&lt;p&gt;新建git用户并配置密码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;useradd -m -s /bin/bash git 
passwd git
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将认证公钥加入git用户认证文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ssh-copy-id -i /c/Users/Administrator/Documents/ssh/github_to_server.pub git@ip -p 22222
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;-i: 指定文件&lt;/li&gt;
&lt;li&gt;-p: ssh连接端口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你也可以手动在/home/git 新建&lt;code&gt;.ssh/authorized_keys&lt;/code&gt; 文件，把github_to_server.pub添加到authorized_keys。&lt;code&gt;.ssh&lt;/code&gt;文件夹默认权限为700，authorized_keys文件默认权限是600。&lt;/p&gt;
&lt;h5 id=&quot;本地配置&quot;&gt;本地配置&lt;/h5&gt;
&lt;p&gt;安装hexo最新版本，最好安装git-scm， git bash挺好用的。&lt;/p&gt;
&lt;p&gt;本地配置多个ssh-key，需要手动配置使用指定的ssh密钥。使用git bash，新建&lt;code&gt;config&lt;/code&gt;文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim ~/.ssh/config
#添加以下内容
Host fungit.blog
    HostName github.com
        IdentityFile   C:\\Users\\Administrator\\.ssh\\fungit_blog_github
        PreferredAuthentications publickey
        IdentitiesOnly yes
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Host: 区分默认的github.com，仓库链接使用&lt;code&gt;fungit.blog&lt;/code&gt; 替换 &lt;code&gt;github.com&lt;/code&gt;推送时就会匹配IdentityFile对应的密钥文件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置hexo站点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hexo init fungit.org
cd fungit.org
rm -rf .git
git init
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连接私有仓库&lt;code&gt;fungit.org&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git remote -add origin git@fungit.blog:kroyoo/fungit.org.git
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;注意&lt;code&gt;git@github.com&lt;/code&gt;使用上面config配置的&lt;code&gt;git@fungit.blog&lt;/code&gt;替换。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试是否可以正常通信&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ ssh -T git@fungit.org
Hi fungit.org! You've successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;至此，ssh密钥配置完成，当然，如果本地只有使用一个默认密钥id_rsa，不用那么麻烦，直接新建站点连接仓库就行了。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;二、自动化部署&quot;&gt;二、自动化部署&lt;/h3&gt;
&lt;h4 id=&quot;本地配置-1&quot;&gt;本地配置&lt;/h4&gt;
&lt;p&gt;如果你是跟我一样不喜欢本地安装依赖，只需手动把依赖添加到&lt;code&gt;package.json&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我的&lt;code&gt;package.json&lt;/code&gt;文件参考：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
 ....
 ...
  &quot;dependencies&quot;: {
    &quot;hexo&quot;: &quot;^5.0.0&quot;,
    &quot;hexo-deployer-git&quot;: &quot;^2.1.0&quot;,
    &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;,
    &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;,
    &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;,
    &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;,
    &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;,
    &quot;hexo-renderer-jade&quot;: &quot;^0.5.0&quot;,
    &quot;hexo-renderer-marked&quot;: &quot;^3.0.0&quot;,
    &quot;hexo-renderer-stylus&quot;: &quot;^2.0.0&quot;,
    &quot;hexo-server&quot;: &quot;^2.0.0&quot;,
    &quot;hexo-wordcount&quot;: &quot;^6.0.1&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;github-actions配置&quot;&gt;GitHub Actions配置&lt;/h4&gt;
&lt;p&gt;不多说，先看yaml文件:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;name: Auto Deploy
on:
  watch:
    types: [started]
  push:
    branches:
      - main
jobs:
  build:
    runs-on: ubuntu-18.04
    if: github.event.repository.owner.id == github.event.sender.id
    steps:
      - name: Checkout source
        uses: actions/checkout@v2
        with:
          ref: main
      - name: Setup Node.js
        uses: actions/setup-node@v1
        with:
          node-version: '12'
      - name: Setup Hexo
        run: |
          git config --global user.email &quot;deploy@fungit.org&quot;
          git config --global user.name &quot;deploy&quot;
          npm install hexo-cli -g --no-audit
          npm install --no-audit

      - name: hexo clean and hexo g 
        run: |
          hexo clean
          hexo g

      - name: Deploy to Server
        uses: easingthemes/ssh-deploy@v2.1.5
        env:
            SSH_PRIVATE_KEY: ${{ secrets.GITHUB_TO_SERVER_KEY }}
            ARGS: &quot;-rltgoDzvO --delete&quot;
            SOURCE: &quot;public/&quot;
            REMOTE_HOST: ${{ secrets.SERVER_IP }}
            REMOTE_PORT:  ${{ secrets.SERVER_PORT }}
            REMOTE_USER:  ${{ secrets.SERVER_USER }}
            TARGET: ${{ secrets.REMOTE_TARGET }}

      - name: Deploy gh-pages
        env:
          ACTION_DEPLOY_KEY: ${{ secrets.HEXO_DEPLOY_KEY }}
        run: |
          rm -rf ~/.ssh
          mkdir -p ~/.ssh/
          echo 'fungit.org' &amp;gt; public/CNAME
          echo &quot;$ACTION_DEPLOY_KEY&quot; &amp;gt; ~/.ssh/id_rsa
          chmod 700 ~/.ssh
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan github.com &amp;gt;&amp;gt; ~/.ssh/known_hosts
          hexo deploy
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了方便，使用了&lt;code&gt;easingthemes/ssh-deploy@v2.1.5&lt;/code&gt;推送工具，详细可以去了解下。随便看看&lt;code&gt;peaceiris/actions-gh-pages@v3&lt;/code&gt;还有最后我推送到gh-pages分支的写法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SOURCE: 需要推送的目录，hexo生成在public。&lt;/li&gt;
&lt;li&gt;SSH_PRIVATE_KEY: ssh私钥、私钥。前面配置的GITHUB_TO_SERVER_KEY。&lt;/li&gt;
&lt;li&gt;TARGET: 服务器目录如/home/wwwroot/fungit.org&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;ps: 所需依赖最好放在&lt;code&gt;package.json&lt;/code&gt;里面，这样Vervel部署也方便。&lt;/strong&gt; 部署到ph-pages分支和连接vercel是为了以后服务器炸了、迁移方便切过去（懒，不想修）&lt;/p&gt;
&lt;p&gt;Vercel：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgs.fungit.org/2021/01/08/03dabad2211c2885bb284cb674e09bb7.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;GitHub Actions：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgs.fungit.org/2021/01/08/1a93fecec483802e8ca45ff24944294d.png&quot; alt=&quot;1a93fecec483802e8ca45ff24944294d.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者: Yeksha&lt;br/&gt;連結: &lt;a href=&quot;https://fungit.org/2021/github-acionts-automatically-compile-deploy/&quot; target=&quot;_blank&quot;&gt;https://fungit.org/2021/github-acionts-automatically-compile-deploy/&lt;/a&gt;&lt;br/&gt;來源: Fungit&lt;br/&gt;著作權歸作者所有。商業轉載請聯絡作者獲得授權，非商業轉載請註明出處。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 09 Jan 2021 15:56:00 +0000</pubDate>
<dc:creator>Fungit</dc:creator>
<og:description>使用hexo博客也挺久的，最开始是本地hexo clean &amp;&amp; hexo g，最后hexo d推送到服务器。后来是本地hexo clean &amp;&amp; hexo g，最后将生成文件推送到GitHub，Gi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Fungit/p/github-acionts-automatically-compile-deploy.html</dc:identifier>
</item>
<item>
<title>我的2020——从学生到打工人的转变 - James_Shangguan</title>
<link>http://www.cnblogs.com/sgh1023/p/14257095.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sgh1023/p/14257095.html</guid>
<description>&lt;p&gt;2021，终于来了！还记得2020年的愿望是什么？活着就好。哈哈，毕竟除了生死，都是小事。虽为小事，但也重要。这一年，我顺利毕业，离开了陪伴多年的校园，成功进入职场，开启了人生中一段崭新的旅程。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;134&quot;&gt;
&lt;p&gt;2021，终于来了！还记得2020年的愿望是什么？活着就好。哈哈，毕竟除了生死，都是小事。虽为小事，但也重要。这一年，我顺利毕业，离开了陪伴多年的校园，成功进入职场，开启了人生中一段崭新的旅程。&lt;/p&gt;

&lt;p&gt;如果有人要问2020年的主题是什么，那当然是疫情。我想多年之后，当我们再次回忆起2020年，首先想到的会是新冠肺炎疫情，就像说起2008，人们首先会想起北京奥运会和汶川地震。因为2020年的起点，是突如其来的新冠疫情，2020的结尾，也是没完没了的新冠疫情，可以说这一年的我们都笼罩在疫情的阴霾之中，挥之不去也无处遁逃。&lt;/p&gt;
&lt;p&gt;有影子的地方就有光，有灾难的地方就会诞生英雄。站在2021的起点，回望2020，那一个个奔忙而坚定的身影，那一张张疲惫却坚毅的面孔，是强大信念意志汇聚成一往无前的钢铁洪流，是无数血肉之躯筑起抵御疫情的新的长城。我永远不会忘记买着无座车票赶赴武汉的钟南山院士，不会忘记加急研制疫苗、以身试验的陈薇院士，不会忘记身患渐冻症仍蹒跚急行的张定宁院长，不会忘记从“造谣者”到“可敬的人”的李文亮医生，不会忘记那些来自全国各地的医疗团队和医护工作者，不会忘记每一个平凡的你们……你们都是英雄，都是最美的逆行者。有句话是这么说的，哪有什么岁月静好，只不过是有人替你负重前行，谢谢你们。&lt;/p&gt;
&lt;p&gt;虽然没能成为英雄与你们并肩作战，但我也在心中关注着疫情，默默支持着你们。2020年，我经历了人生中最长的假期、最长的在家的日子，没有之一。每天醒来手机推送的都是疫情的咨询，新闻联播里面都是疫情报告和动态，不知道从几何时，我也可以认真听完新闻联播的每个字，再也不是从前那个一听新闻联播就想换台的无知小孩了。足不出户，“闭门造车”，就这样一天天关注着疫情，等待着每一个振奋人心好消息的到来。我知道，是非时刻，老老实实在家待着，不给祖国和人民添乱，就是对抗疫事业最大的支持。因为研三实验室没有任务，秋招找到了一份还算满意的工作春招就没有再找，疫情原因也没办法回去公司实习，所以在家待了大概五个月，无忧无虑，每天睡到自然醒，不对，准确的说是除了睡觉，就是吃饭和玩游戏，也打了好几个赛季的王者。哈哈，简直太幸福，人生中这样的机会貌似再也不会有了吧？！&lt;/p&gt;

&lt;p&gt;害，快乐的时光总是过得飞快。三月份的某一天，接到了导师发的提交论文和论文查重的通知，这个突如其来的通知虽然谈不上晴天霹雳，但也算是打得我措手不及。凡事有因必有果，我自己种下的种子，我不怪谁，要怪只能怪寒假无限延长，我也玩嗨了没有停下来。我想没写完论文的也应该不是我一个人，因为和实验室同学平时打游戏聊起论文的事情，也都说没写呢。我问了下实验室有个和我情况差不多的同学，他也刚写一半，哈哈，毕竟也不是只有我一个人是这样。&lt;/p&gt;
&lt;p&gt;因为论文只写了不到一半这种危急情形，只能开启超级无敌的疯狂写论文的模式，而没有其他选择和退路。我记不清当天的天气，记不清当时列了几页纸的待做事项，记不清画了几页的草稿图，记不清当时翻阅了多少资料和文献，只记得我在电脑前面忙碌着，而钟表一圈圈转着，刚才还是日出，恍惚之间也是日落。还真是有时候不逼迫自己一把，永远不知道有多少潜力，认真起来有多么优秀。通过三个日夜的奋战，准确的说三天睡了差不多八小时，顺利提交毕业论文并通过查重。&lt;/p&gt;
&lt;p&gt;随后就是“云答辩”了，也是一切顺利，如愿通过。我会好好记住这个毕业答辩，因为特殊，所以念念不忘。2020的毕业生没有毕业照，也没有毕业典礼。校园生活，有开始而没有结束，算是一个不大不小的遗憾。这也是属于我学生时代最后的记忆。&lt;/p&gt;

&lt;p&gt;2020年11月，看到有关蛋壳公寓暴雷的新闻，我感觉这次自己还是蛮幸运的，可能我命中注定没有此劫。&lt;/p&gt;
&lt;p&gt;毕业之后首当其冲的就是租房，和朋友一起租的蛋壳。为什么会选择蛋壳呢？一个字，因为穷。在寸土寸金的首都北京，作为刚毕业的学生，也只能租得起蛋壳了，而且蛋壳免押金，优惠力度还是不错的（后来才知道自如也有类似的活动）。我朋友去年租的自如觉得有点贵，看了房子还可以，所以我俩一起入了蛋壳的坑。&lt;/p&gt;
&lt;p&gt;这个坑，真的不是一般的坑。因为蛋壳是我们租的小区的黑名单，居委会不给蛋壳的租户办理出入证，当然这个也是后知后觉，不然打死不租蛋壳。刚到北京的时候是六月份，也就是北京新发地疫情爆发的时候，小区开始查出入证。刚来的一段时间，查的不是很严，没有出入证还可以混进来。但是端午一过，情况急转直下，查的很严，每次都说忘记带或者在办了也已经行不通了。甚至某一天我室友直接被拦下了，因为没有出入证不让进小区，有民警、有居委会的大妈、还有一些蛋壳的租户在小区门口battle。battle的结果就是晚上先回去收拾东西，给一天的时间搬走。因为我俩都要上班，所以就连夜收拾东西，第二天一大早先把东西搬到了宾馆存放，然后去上班。晚上下班之后又搬到了蛋壳的安置房源里面。一天搬两次家，怎一个“累”字了得？住在蛋壳安置房源只是一个缓兵之计，后来我们从其他租户那里确认了房租和押金都可以退，也找好了其他的房子，所以就立刻远离了是非之地。&lt;/p&gt;
&lt;p&gt;虽然我没有成为本地蛋壳事件的受害者，但是看见一些同学都是蛋壳事件的受害者，真的是难受，他们面临着租来的房子不能住，还要还租金贷的困境。其实，从P2P，到共享单车，再到租金贷等，这种套路已经出现过很多次了，只要是有利可图，这种“空手套白狼”的套路就会换着花样来欺骗和收割弱势群体。而背后的狼更是吃人不吐骨头，甚至搞的受害者家破人亡。这些知名的公司本该更有担当，更有作为，却一次次让人寒心。造福人民，改变生活这种愿望不敢苛求，只希望你们求财可以取之有道，更不要害人性命。&lt;/p&gt;

&lt;p&gt;打工人，打工魂，打工都是人上人。这一年，我也变成了一名光荣的打工人，成为了一介码农，开始用力地搬砖，用力地活着。对于刚踏入职场的我们，首先面对的是集团和部门对于校招生的集训营。在这里大家年纪相仿，都是初来乍到的职场新人，有很多共同的话题，所以在集训营里面的四天三夜，是快乐而难忘的，大家嘻嘻哈哈，一起培训，一起吃饭，一起完成微电影和产品体验官，仿佛回到了似曾相识的校园生活。&lt;/p&gt;
&lt;p&gt;培训结束，工作回归平淡。需求、技改、双11大促备战、系统日常运维、安全漏洞修复、黑客马拉松……应有尽有。有完成一项工作的激动，有踩到坑里面好久没有跳出来的无奈，也有凌晨下班的“福报”，当然也忙里偷闲，参加了部门一年一度的运动会。&lt;/p&gt;
&lt;p&gt;我发现人有时候会很奇怪，上学的时候希望能够早点工作，而工作之后也会有不想上班的情绪，即使这种情况只是偶尔的。情绪归情绪，生活还要继续，不是富二代，谁又不是为了那几两碎银而慌慌张张呢？上班半年，有发工资的喜悦，也遭受过社会的残酷，身边优秀的人太多，无时不刻提醒着我要学习，要变得强大。&lt;/p&gt;
&lt;p&gt;这是一篇迟到的年终总结和回忆，因为我在等待一个神秘的结果，看来只能在《我的2021》中期待了。&lt;/p&gt;
&lt;p&gt;记得2020年最大的愿望是身体健康，顺利毕业，已经实现。2020年，实在是不容易，我想感谢伟大的祖国，感谢你永远将人民群众的生命安全和身体健康放在第一位；感谢英雄的人民，感谢我们共同书写了抗击疫情的人民史诗；感谢我的家人和朋友对我的关爱与陪伴；感谢我的导师和同学对我的指导和帮助；感谢我的领导和同事对我的指引和帮助……&lt;/p&gt;
&lt;p&gt;2021，我希望能够身体健康，不断提高技术能力，跟身边优秀的工程师看齐，还有就是升职加薪。也祝福各位2021，身体健康，一夜暴富，财富自由！未来可期，加油！&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 09 Jan 2021 15:54:00 +0000</pubDate>
<dc:creator>James_Shangguan</dc:creator>
<og:description>2021，终于来了！还记得2020年的愿望是什么？活着就好。哈哈，毕竟除了生死，都是小事。虽为小事，但也重要。这一年，我顺利毕业，离开了陪伴多年的校园，成功进入职场，开启了人生中一段崭新的旅程。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sgh1023/p/14257095.html</dc:identifier>
</item>
<item>
<title>CentOS-8.3.2011-x86_64 配置网络环境的几个方案以及问题处理方法 - Suozhiyuan</title>
<link>http://www.cnblogs.com/CooCoChoco/p/14256881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CooCoChoco/p/14256881.html</guid>
<description>&lt;h2&gt;1. 在安装前的环境配置中配置网络&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(&lt;/strong&gt;这种方式比较方便, 但长期使用不建议使用该种方式, 后期配置网络会比较麻烦, VMware生成的设置修改异常麻烦. 还是建议各位手动配置&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;可以通过 &lt;strong&gt;NETWORK &amp;amp; HOST NAME &lt;/strong&gt;进行网络配置, &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1872684/202101/1872684-20210109210742022-1697230703.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;373&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1872684/202101/1872684-20210110000859194-840390661.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;373&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里设置手动, 与VMware下的 VMnet8 好相符,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1872684/202101/1872684-20210110002927468-493624575.png&quot; alt=&quot;&quot; width=&quot;496&quot; height=&quot;370&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虚拟机的 地址\网关\掩码 获取方式:&lt;/p&gt;
&lt;p&gt;以虚拟机VMware, 并且使用的是 VMnet8 的 NAT 模式, 配置的 IP 必须与虚拟机 VMnet8网络 为同一网段, 如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1872684/202101/1872684-20210109215046860-917982929.png&quot; alt=&quot;&quot; width=&quot;302&quot; height=&quot;199&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1872684/202101/1872684-20210109215149525-149517444.png&quot; alt=&quot;&quot; width=&quot;875&quot; height=&quot;412&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果在安装的 &lt;strong&gt;CentOS&lt;/strong&gt; 之前的配置选项中没有进行用户和网络的配置选项, 那么你的系统是连不上网的, 那么就要进行一次配置, 方法如下&lt;/p&gt;

&lt;h2&gt;2. 手动配置网络环境&lt;/h2&gt;
&lt;h3&gt;2.1 自己使用的虚拟机网络配置&lt;/h3&gt;
&lt;p&gt;进入系统后默认会在home文件夹下的个人目录, 这时需要先进入到我们要修改的配置文件的目录, 如下:&lt;/p&gt;
&lt;p&gt;进入文件夹: etc/sysconfig/network-scripts/   找到 &lt;strong&gt;ifcfg-ens32&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[suozhiyuan@My-Linux-CentOS-&lt;span&gt;8&lt;/span&gt; ~]$ cd /　　　　　　　　　　　　　　　　　　　　# 进入主目录&lt;span&gt;
[suozhiyuan@My&lt;/span&gt;-Linux-CentOS-&lt;span&gt;8&lt;/span&gt; /]$ cd etc/sysconfig/network-scripts/　　 # 进入到相关目录&lt;span&gt;
[suozhiyuan@My&lt;/span&gt;-Linux-CentOS-&lt;span&gt;8&lt;/span&gt; network-scripts]$ ls -&lt;span&gt;laF　　　　　　　　　　# 查看当前文件夹下内容的详细信息
总用量 &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
drwxr&lt;/span&gt;-xr-x. &lt;span&gt;2&lt;/span&gt; root root   &lt;span&gt;25&lt;/span&gt; 1月   &lt;span&gt;9&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt; ./&lt;span&gt;
drwxr&lt;/span&gt;-xr-x. &lt;span&gt;6&lt;/span&gt; root root &lt;span&gt;4096&lt;/span&gt; 1月   &lt;span&gt;9&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt; ../
-rw-r--r--. &lt;span&gt;1&lt;/span&gt; &lt;span&gt;&lt;strong&gt;root&lt;/strong&gt; &lt;strong&gt;root &lt;/strong&gt; &lt;/span&gt;&lt;span&gt;280&lt;/span&gt; 1月   &lt;span&gt;9&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;06&lt;/span&gt; &lt;span&gt;&lt;strong&gt;ifcfg-&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;ens32&lt;/strong&gt;&lt;/span&gt;　　　　　　　　　　　 # 这个就是我们要配置的文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 root 用户登录修改IP地址, 之所以要用 &lt;span&gt;&lt;strong&gt;root&lt;/strong&gt;&lt;/span&gt; 用户是因为 &lt;strong&gt;&lt;span&gt;ifcfg-ens32&lt;/span&gt;&lt;/strong&gt; 文件为只读文件, 并且看上边的文件信息&lt;span&gt;&lt;strong&gt;它拥有 root 权限&lt;/strong&gt;&lt;/span&gt; , 普通用户无法对其进行保存操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[suozhiyuan@My-Linux-CentOS-&lt;span&gt;8&lt;/span&gt; network-&lt;span&gt;scripts]$ su　　　　　　　　# 切换超级用户
密码：　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　# 输入密码
[root@My&lt;/span&gt;-Linux-CentOS-&lt;span&gt;8&lt;/span&gt; network-scripts]# vim ifcfg-ens32 　　　# 编辑文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ifcfg-ens32&lt;/strong&gt; 文件内容如下：&lt;/p&gt;
&lt;p&gt;如果不会对Linux下文件进行编辑操作, 查看这篇: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
TYPE=&lt;span&gt;Ethernet　　　　　　 # 网络类型为以太网
PROXY_METHOD&lt;/span&gt;=&lt;span&gt;none
BROWSER_ONLY&lt;/span&gt;=&lt;span&gt;no
BOOTPROTO&lt;/span&gt;=&lt;span&gt;dhcp　　　　　　# IP地址获取方式, dhcp 为自动获取, 如果要手动获取这里就要修改为 static, 然后在下边手动配置一个IP
DEFROUTE&lt;/span&gt;=&lt;span&gt;yes
IPV4_FAILURE_FATAL&lt;/span&gt;=&lt;span&gt;no
IPV6INIT&lt;/span&gt;=&lt;span&gt;yes
IPV6_AUTOCONF&lt;/span&gt;=&lt;span&gt;yes
IPV6_DEFROUTE&lt;/span&gt;=&lt;span&gt;yes
IPV6_FAILURE_FATAL&lt;/span&gt;=&lt;span&gt;no
IPV6_ADDR_GEN_MODE&lt;/span&gt;=stable-&lt;span&gt;privacy　　　
NAME&lt;/span&gt;=&lt;span&gt;ens32　　　　　　　　# 网卡设备名
UUID&lt;/span&gt;=8633e5ee-2fc8-&lt;span&gt;4075&lt;/span&gt;-&lt;span&gt;8127&lt;/span&gt;-&lt;span&gt;133a54368449
DEVICE&lt;/span&gt;=&lt;span&gt;ens32　　　　　　 # 网卡设备名
ONBOOT&lt;/span&gt;=yes　　　　　　　 # 该网卡是否随网络服务启动(系统启动是否生效)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果 BOOTPROTO 配置为: &lt;/p&gt;
&lt;p&gt;　　BOOTPROTO=static&lt;/p&gt;
&lt;p&gt;那么就需要在下方配置: 固定IP \ 子网掩码 \ 本机出口网关口 \ 共有DNS, 这也是目前互联网上几乎是所有博客所描述的一种配置, 当然作为服务器使用静态IP是没错的&lt;/p&gt;
&lt;p&gt;如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
TYPE=&lt;span&gt;Ethernet
PROXY_METHOD&lt;/span&gt;=&lt;span&gt;none
BROWSER_ONLY&lt;/span&gt;=&lt;span&gt;no
BOOTPROTO&lt;/span&gt;=static　　　　　　# IP地址获取方式, dhcp 为自动获取, 如果要手动获取这里就要修改为 &lt;span&gt;static&lt;/span&gt;&lt;span&gt;, 然后在下边手动配置一个IP
DEFROUTE&lt;/span&gt;=&lt;span&gt;yes
IPV4_FAILURE_FATAL&lt;/span&gt;=&lt;span&gt;no
IPV6INIT&lt;/span&gt;=&lt;span&gt;yes
IPV6_AUTOCONF&lt;/span&gt;=&lt;span&gt;yes
IPV6_DEFROUTE&lt;/span&gt;=&lt;span&gt;yes
IPV6_FAILURE_FATAL&lt;/span&gt;=&lt;span&gt;no
IPV6_ADDR_GEN_MODE&lt;/span&gt;=stable-&lt;span&gt;privacy
NAME&lt;/span&gt;=&lt;span&gt;ens32
UUID&lt;/span&gt;=8633e5ee-2fc8-&lt;span&gt;4075&lt;/span&gt;-&lt;span&gt;8127&lt;/span&gt;-&lt;span&gt;133a54368449
DEVICE&lt;/span&gt;=&lt;span&gt;ens32
ONBOOT&lt;/span&gt;=yes　　　　　　　　　　# 这里为 yes&lt;p&gt;#以下内容便为新增项
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;　IPADDR=&lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.137.0&quot;  　&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;　GATEWAY=&lt;span class=&quot;hljs-string&quot;&gt;&quot;192.168.137.2&quot;   &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;hljs-ln-code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;　NETMASK=&lt;span class=&quot;hljs-string&quot;&gt;&quot;255.255.255.0&quot;   &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;IP配置注意项: &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你是使用的虚拟机, 比如VMware, 并且使用的是 VMnet8 的 NAT 模式, 这时 IPADDR 配置的 IP 必须与虚拟机 VMnet8网络 为同一网段, 如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1872684/202101/1872684-20210109215046860-917982929.png&quot; alt=&quot;&quot; width=&quot;302&quot; height=&quot;199&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1872684/202101/1872684-20210109215149525-149517444.png&quot; alt=&quot;&quot; width=&quot;875&quot; height=&quot;412&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;2.2 想要共享其他人使用的局域网虚拟机网络配置(可选):&lt;/h3&gt;
&lt;p&gt;如果你的虚拟机想要给同一局域网下的其他人使用, 你的虚拟机所选的网络环境便不可以选择 &lt;strong&gt;NAT&lt;/strong&gt; 模式, 你需要将其修改为桥接模式, 将虚拟机直接与交换机相连&lt;/p&gt;
&lt;p&gt;这里的网卡配置方式与上边个人虚拟机完全相同, 只需要将 VMware 的网络配置修改为桥接, 修改配置文件中相关的网络配置, 重启系统便可. &lt;/p&gt;

&lt;h3&gt;2.3 network 配置&lt;/h3&gt;
&lt;p&gt;/etc/sysconfig/network 文件里增加如下配置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;增加以下这一个配置便可: &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;NETWORKING=yes&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;Linux计算机中，/etc/sysconfig/network可配置文件定义了该计算机网络的基本属性，包括网络是否可用、是否允许IP包转发、丰机域名、网关地址、网关设备名等。&lt;/p&gt;
&lt;p&gt;系统需要网络支持，故/etc/sysconfig/network文件中的 NETWORKING 应该=yes。如果etc/sysconfig/network文件中的NETWORKING=no，表示系统禁止使用网络。&lt;/p&gt;
&lt;p&gt;其他配置(可选):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
RORWARD_IPV4=&lt;span&gt;yes
HOSTNAME&lt;/span&gt;=&lt;span&gt;deep.openarch.com &lt;br/&gt;GAREWAY&lt;/span&gt;=&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; 
GATEWAYDEV&lt;/span&gt;=&lt;span&gt; 
NETWORK&lt;/span&gt;=yes/&lt;span&gt;no　　　　 　　　　　　#　网络是否被配置； 
FORWARD_IPV4&lt;/span&gt;=yes/&lt;span&gt;no　 　　　　　　#　是否开启IP转发功能 
HOSTNAME&lt;/span&gt;=&lt;span&gt;hostname hostname　　　 #　表示服务器的主机名 
GAREWAY&lt;/span&gt;=gw-ip　　　　 　　　　　　 #　gw-&lt;span&gt;ip表示网络网关的IP地址 
GAREWAYDEV&lt;/span&gt;=gw-dev　　 　　　　　　#　gw-&lt;span&gt;dw表示网关的设备名，如：etho等 &lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.4 resolv.conf 配置&lt;/h3&gt;
&lt;p&gt;/etc/resolv.conf 它是DNS客户机配置文件，用于设置DNS服务器的IP地址及DNS域名，还包含了主机的域名搜索顺序。该文件是由域名解析 器（resolver，一个根据主机名解析IP地址的库）使用的配置文件。它的格式很简单，每行以一个关键字开头，后接一个或多个由空格隔开的参数。&lt;/p&gt;
&lt;p&gt;resolv.conf 的关键字主要有四个，分别是：&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;nameserver    # 定义DNS服务器的IP地址
domain        # 定义本地域名
search        # 定义域名的搜索列表
sortlist      # 对返回的域名进行排序&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;该配置下最主要是 &lt;strong&gt;nameserver&lt;/strong&gt; 关键字，如果没指定 &lt;strong&gt;nameserver&lt;/strong&gt; 就找不到 DNS 服务器，其它关键字是可选的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nameserver&lt;/strong&gt; 表示解析域名时使用该地址指定的主机为域名服务器。其中域名服务器是按照文件中出现的顺序来查询的,且只有当第一个 &lt;strong&gt;nameserver&lt;/strong&gt; 没有反应时才查询下面的 &lt;strong&gt;nameserver&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;nameserver &lt;span&gt;8.8&lt;/span&gt;.&lt;span&gt;8.8&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;domain　&lt;/strong&gt;(可选)　　声明主机的域名。很多程序用到它，如邮件系统；当为没有域名的主机进行DNS查询时，也要用到。如果没有域名，主机名将被使用，删除所有在第一个点( .)前面的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;search　&lt;/strong&gt;(可选)　　它的多个参数指明域名查询顺序。当要查询没有域名的主机，主机将在由search声明的域中分别查找。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sortlist　&lt;/strong&gt;(可选)　　允许将得到域名结果进行特定的排序。它的参数为网络/掩码对，允许任意的排列顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意: domain 和 search不能共存, 如果同时存在，后面出现的将会被使用。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;2.5 重启网络服务&lt;/h3&gt;
&lt;p&gt;配置完成后保存, 重启网卡&lt;/p&gt;
&lt;p&gt;重启方法: 由于 CentOS 各个版本中重启网卡的命令不一样, 需要确定你的系统版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
CentOS8 重启网卡命令: nmcli c reload +&lt;span&gt;网卡名

例：nmcli c reload ens32&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不成, 尝试以下命令:&lt;/p&gt;
&lt;p&gt;其中x为编号, 如 &lt;/p&gt;
&lt;pre&gt;
ifcfg-eth32
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
nmcli c reload ifcfg-&lt;span&gt;xxx    　　　　　　　　　　　　　　　　　 # 重载所有ifcfg或route到connection（不会立即生效）
nmcli c load /etc/sysconfig/network-scripts/ifcfg-&lt;span&gt;ethX    # 重载指定ifcfg或route到connection（不会立即生效）
nmcli c load /etc/sysconfig/network-scripts/route-&lt;span&gt;ethX    # 重载指定ifcfg或route到connection（不会立即生效）

# 立即生效 connection，有3种方法
nmcli c up ethX
nmcli d reapply ethX
nmcli d connect ethX&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果还不行, 就重启.&lt;/p&gt;

&lt;h2&gt;3.CentOS自带网络配置工具&lt;strong&gt;nmcli/nmtui&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;CentOS7中配置网络有个强大的图形化配置工具- nmcli和nmtui 。&lt;/p&gt;
&lt;h3&gt;3.1 用命令行方式配置网卡信息&lt;/h3&gt;
&lt;p&gt;nmcli：NetworkManageCommandLine Interface   #用命令行方式配置网卡信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# nmcli -&lt;span&gt;h

Usage: nmcli [OPTIONS] OBJECT { COMMAND &lt;/span&gt;|&lt;span&gt; help }  &lt;span&gt;#用法格式&lt;/span&gt;

OPTIONS
  &lt;/span&gt;-&lt;span&gt;t[erse]                                   terse output
  &lt;/span&gt;-&lt;span&gt;p[retty]                                  pretty output
  &lt;/span&gt;-m[ode] tabular|&lt;span&gt;multiline                  output mode
  &lt;/span&gt;-f[ields] &amp;lt;field1,field2,...&amp;gt;|all|&lt;span&gt;common   specify fields to output
  &lt;/span&gt;-e[scape] yes|no                           escape columns separators &lt;span&gt;in&lt;/span&gt;&lt;span&gt; values
  &lt;/span&gt;-n[ocheck]                                 don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t check nmcli and NetworkManager versions&lt;/span&gt;
  -a[sk]                                     ask &lt;span&gt;for&lt;/span&gt;&lt;span&gt; missing parameters
  &lt;/span&gt;-w[ait] &amp;lt;seconds&amp;gt;                          &lt;span&gt;set&lt;/span&gt; timeout waiting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; finishing operations  &lt;span&gt;#设置命令行超时退出时间
  &lt;/span&gt;&lt;/span&gt;-&lt;span&gt;v[ersion]                                 show program version    &lt;span&gt;#显示nmcli的版本信息
  &lt;/span&gt;&lt;/span&gt;-h[elp]                                    print &lt;span&gt;this&lt;/span&gt;&lt;span&gt; help   &lt;span&gt;#获取帮助&lt;/span&gt;

OBJECT
  g[eneral]       NetworkManager&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s general status and operations&lt;/span&gt;
&lt;span&gt;  n[etworking]    overall networking control
  r[adio]         NetworkManager radio switches
  c[onnection]    NetworkManager&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s connections&lt;/span&gt;
&lt;span&gt;  d[evice]        devices managed by NetworkManager   &lt;span&gt;#显示网卡设备信息&lt;/span&gt;
  a[gent]         NetworkManager secret agent or polkit agent 

[root@localhost &lt;/span&gt;~&lt;span&gt;]# nmcli d   &lt;span&gt;#显示网卡设备信息，查看要配置的网卡名称&lt;/span&gt;

[root@localhost &lt;/span&gt;~]# nmcli connection modify ethxx ipv4.method manual  ipv4.address &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;4.1&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;  ipv4.gateway &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;4.254&lt;/span&gt;  ipv4.dns &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;4.200&lt;/span&gt;&lt;span&gt; connection.autoconnect yes  &lt;span&gt;#method为manual设为手动，后面才能配ip，一套命令下来可以把获取地址方式、ip地址、掩码、网关、随机自连连接方式都设置好了&lt;/span&gt;

[root@localhost &lt;/span&gt;~]# nmcli connection up ethxx   &lt;span&gt;#激活刚才配置的网卡信息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.2 用文本界面的方式配置网卡信息&lt;/h3&gt;
&lt;p&gt;nmtui：NetworkManageTextUser Iterface   #用文本界面的方式配置网卡信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# nmtui   &lt;span&gt;#进入网卡配置文本界面,进入edit界面&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1872684/202101/1872684-20210110035342496-286753953.png&quot; alt=&quot;&quot; width=&quot;192&quot; height=&quot;252&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1872684/202101/1872684-20210110035406747-1698980169.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1872684/202101/1872684-20210110035428839-77953501.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;476&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 09 Jan 2021 14:49:00 +0000</pubDate>
<dc:creator>Suozhiyuan</dc:creator>
<og:description>1. 在安装前的环境配置中配置网络 (这种方式比较方便, 但长期使用不建议使用该种方式, 后期配置网络会比较麻烦, VMware生成的设置修改异常麻烦. 还是建议各位手动配置) 可以通过&amp;#160;N</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CooCoChoco/p/14256881.html</dc:identifier>
</item>
<item>
<title>.NET Core 中的日志与分布式链路追踪 - 痴者工良</title>
<link>http://www.cnblogs.com/whuanle/p/14256858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whuanle/p/14256858.html</guid>
<description>&lt;p&gt;程序记录的日志一般有两种作用，故障排查、显式程序运行状态，当程序发生故障时，我们可以通过日志定位问题，日志可以给我们留下排查故障的依据。很多时候，往往会认为日志记录非常简单，例如很多程序只是 &lt;code&gt;try-catch{}&lt;/code&gt;，直接输出到 &lt;code&gt;.txt&lt;/code&gt;，但是这些日志往往无法起到帮助定位问题的作用，甚至日志充斥了大量垃圾内容；日志内容全靠人眼一行行扫描，或者 &lt;code&gt;Ctrl+F&lt;/code&gt; 搜索，无法高效率审查日志；日志单纯输出到文本文件中，没有很好地管理日志。&lt;/p&gt;
&lt;p&gt;接下来，我们将一步步学习日志的编写技巧，以及 OpenTracing API 、Jaeger 分布式链路跟踪的相关知识。&lt;/p&gt;
&lt;h2 id=&quot;net-core-中的日志&quot;&gt;.NET Core 中的日志&lt;/h2&gt;
&lt;h3 id=&quot;控制台输出&quot;&gt;控制台输出&lt;/h3&gt;
&lt;p&gt;最简单的日志，就是控制台输出，利用 &lt;code&gt;Console.WriteLine()&lt;/code&gt; 函数直接输出信息。&lt;/p&gt;
&lt;p&gt;下面时一个简单的信息输出，当程序调用 &lt;code&gt;SayHello&lt;/code&gt; 函数时，&lt;code&gt;SayHello&lt;/code&gt; 会打印信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public class Hello
    {
        public void SayHello(string content)
        {
            var str = $&quot;Hello,{content}&quot;;
            Console.WriteLine(str);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Hello hello = new Hello();
            hello.SayHello(&quot;any one&quot;);
            Console.Read();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;非侵入式日志&quot;&gt;非侵入式日志&lt;/h3&gt;
&lt;p&gt;通过控制台，我们可以看到，为了记录日志，我们必须在函数内编写输入日志的代码，优缺点这些就不多说了，我们可以通过 AOP 框架，实现切面编程，同一记录日志。&lt;/p&gt;
&lt;p&gt;这里可以使用笔者开源的 CZGL.AOP 框架，Nuget 中可以搜索到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1315495/202101/1315495-20210109223916548-1323698678.png&quot; alt=&quot;czgl.aop&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编写统一的切入代码，这些代码将在函数被调用时执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Before&lt;/code&gt; 会在被代理的方法执行前或被代理的属性调用时生效，你可以通过 &lt;code&gt;AspectContext&lt;/code&gt; 上下文，获取、修改传递的参数。&lt;/p&gt;
&lt;p&gt;After 在方法执行后或属性调用时生效，你可以通过上下文获取、修改返回值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public class LogAttribute : ActionAttribute
    {
        public override void Before(AspectContext context)
        {
            Console.WriteLine($&quot;{context.MethodInfo.Name} 函数被执行前&quot;);
        }

        public override object After(AspectContext context)
        {
            Console.WriteLine($&quot;{context.MethodInfo.Name} 函数被执行后&quot;);
            return null;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改造 Hello 类，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    [Interceptor]
    public class Hello
    {
        [Log]
        public virtual void SayHello(string content)
        {
            var str = $&quot;Hello,{content}&quot;;
            Console.WriteLine(str);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后创建代理类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        static void Main(string[] args)
        {
            Hello hello = AopInterceptor.CreateProxyOfClass&amp;lt;Hello&amp;gt;();
            hello.SayHello(&quot;any one&quot;);
            Console.Read();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动程序，会输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SayHello 函数被执行前
Hello,any one
SayHello 函数被执行后
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你完全不需要担心 AOP 框架会给你的程序带来性能问题，因为 CZGL.AOP 框架采用 EMIT 编写，并且自带缓存，当一个类型被代理过，之后无需重复生成。&lt;/p&gt;
&lt;p&gt;CZGL.AOP 可以通过 .NET Core 自带的依赖注入框架和 Autofac 结合使用，自动代理 CI 容器中的服务。这样不需要 &lt;code&gt;AopInterceptor.CreateProxyOfClass&lt;/code&gt; 手动调用代理接口。&lt;/p&gt;
&lt;p&gt;CZGL.AOP 代码是开源的，可以参考笔者另一篇博文：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/whuanle/p/13160139.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/whuanle/p/13160139.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;microsoftextensionslogging&quot;&gt;&lt;code&gt;Microsoft.Extensions.Logging&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;有些公司无技术管理规范，不同的开发人员使用不同的日志框架，一个产品中可能有 &lt;code&gt;.txt&lt;/code&gt;、&lt;code&gt;NLog&lt;/code&gt;、&lt;code&gt;Serilog&lt;/code&gt;等，并且没有同一的封装。&lt;/p&gt;
&lt;p&gt;.NET Core 中的日志组件有很多，但是流行的日志框架基本都会实现 &lt;code&gt;Microsoft.Extensions.Logging.Abstractions&lt;/code&gt;，因此我们可以学习&lt;code&gt;Microsoft.Extensions.Logging&lt;/code&gt; 。&lt;code&gt;Microsoft.Extensions.Logging.Abstractions&lt;/code&gt; 是官方对日志组件的抽象，如果一个日志组件并不支持 &lt;code&gt;Microsoft.Extensions.Logging.Abstractions&lt;/code&gt; 那么这个组件很容易跟项目糅合的，后续难以模块化以及降低耦合程度。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Microsoft.Extensions.Logging&lt;/code&gt; 软件包中包含 Logging API ，这些 Logging API 不能独立运行。它与一个或多个日志记录提供程序一起使用，这些日志记录提供程序将日志存储或显示到特定输出，例如 Console, Debug, TraceListeners。&lt;/p&gt;
&lt;p&gt;下图是 .NET Core 中 Loggin API 的层次结构：&lt;/p&gt;
&lt;p&gt;图片来源：&lt;a href=&quot;https://www.tutorialsteacher.com/&quot; target=&quot;_blank&quot;&gt;https://www.tutorialsteacher.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1315495/202101/1315495-20210109224038744-1928737283.png&quot; alt=&quot;logginapi&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说实话，&lt;code&gt;Microsoft.Extensions.Logging&lt;/code&gt; 刚开始是学着很懵，配置感觉很复杂。因此，有一张清晰的结构图很重要，可以帮助大家理解里面的 Logging API。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1315495/202101/1315495-20210109224118160-1626631618.png&quot; alt=&quot;logging-api&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;iloggerfactory&quot;&gt;ILoggerFactory&lt;/h4&gt;
&lt;p&gt;.NET Core 中很多标准接口都实践了工厂模式的思想，ILoggerFactory 正是工厂模式的接口，而 LoggerFactory 是工厂模式的实现。&lt;/p&gt;
&lt;p&gt;其定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public interface ILoggerFactory : IDisposable
{
    ILogger CreateLogger(string categoryName);
    void AddProvider(ILoggerProvider provider);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ILoggerFactory 工厂接口的作用是创建一个 ILogger 类型的实例，即 &lt;code&gt;CreateLogger&lt;/code&gt; 接口。&lt;/p&gt;
&lt;h4 id=&quot;iloggerprovider&quot;&gt;ILoggerProvider&lt;/h4&gt;
&lt;p&gt;通过实现&lt;code&gt;ILoggerProvider&lt;/code&gt;接口可以创建自己的日志记录提供程序，表示可以创建 ILogger 实例的类型。&lt;/p&gt;
&lt;p&gt;其定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public interface ILoggerProvider : IDisposable
{
    ILogger CreateLogger(string categoryName);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;ilogger&quot;&gt;ILogger&lt;/h4&gt;
&lt;p&gt;ILogger 接口提供了将日志记录到基础存储的方法，其定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public interface ILogger
{
    void Log&amp;lt;TState&amp;gt;(LogLevel logLevel, 
                     EventId eventId, 
                     TState state, 
                     Exception exception, 
                     Func&amp;lt;TState, Exception, string&amp;gt; formatter);
    
    bool IsEnabled(LogLevel logLevel);
    IDisposable BeginScope&amp;lt;TState&amp;gt;(TState state);
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;logging-providers&quot;&gt;Logging Providers&lt;/h4&gt;
&lt;p&gt;logging providers 称为日志记录程序。&lt;/p&gt;
&lt;p&gt;Logging Providers 将日志显示或存储到特定介质，例如 console, debugging event, event log, trace listener 等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Microsoft.Extensions.Logging&lt;/code&gt; 提供了以下类型的 logging providers，我们可以通过 Nuget 获取。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Microsoft.Extensions.Logging.Console&lt;/li&gt;
&lt;li&gt;Microsoft.Extensions.Logging.AzureAppServices&lt;/li&gt;
&lt;li&gt;Microsoft.Extensions.Logging.Debug&lt;/li&gt;
&lt;li&gt;Microsoft.Extensions.Logging.EventLog&lt;/li&gt;
&lt;li&gt;Microsoft.Extensions.Logging.EventSource&lt;/li&gt;
&lt;li&gt;Microsoft.Extensions.Logging.TraceSource&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而 Serilog 则有 File、Console、Elasticsearch、Debug、MSSqlServer、Email等。&lt;/p&gt;
&lt;p&gt;这些日志提供程序有很多，我们不必细究；如果一个日志组件，不提供兼容 &lt;code&gt;Microsoft.Extensions.Logging&lt;/code&gt; 的实现，那么根本不应该引入他。&lt;/p&gt;
&lt;p&gt;实际上，很多程序是直接 &lt;code&gt;File.Write(&quot;Log.txt&quot;)&lt;/code&gt; ，这种产品质量能好到哪里去呢？&lt;/p&gt;
&lt;h4 id=&quot;怎么使用&quot;&gt;怎么使用&lt;/h4&gt;
&lt;p&gt;前面，介绍了 &lt;code&gt;Microsoft.Extensions.Logging&lt;/code&gt; 的组成，这里将学习如何使用 Logging Provider 输入日志。&lt;/p&gt;
&lt;p&gt;起码提到，它只是提供了一个 Logging API，因此为了输出日志，我们必须选择合适的 Logging Provider 程序，这里我们选择&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Microsoft.Extensions.Logging.Console&lt;/code&gt;，请在 Nuget 中引用这个包。&lt;/p&gt;
&lt;p&gt;下图是 Logging Provider 和 ConsoleLogger 结合使用的结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1315495/202101/1315495-20210109224216508-1837244362.png&quot; alt=&quot;console-logger&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从常规方法来弄，笔者发现，没法配置呀。。。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;            ConsoleLoggerProvider consoleLoggerProvider = new ConsoleLoggerProvider(
                new OptionsMonitor&amp;lt;ConsoleLoggerOptions&amp;gt;(
                    new OptionsFactory&amp;lt;ConsoleLoggerOptions&amp;gt;(
                        new IEnumerable&amp;lt;IConfigureOptions&amp;lt;TOptions&amp;gt;(... ... ...))));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以只能使用以下代码快速创建工厂：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;            using ILoggerFactory loggerFactory =
                LoggerFactory.Create(builder =&amp;gt;
                    builder.AddSimpleConsole(options =&amp;gt;
                    {
                        options.IncludeScopes = true;
                        options.SingleLine = true;
                        options.TimestampFormat = &quot;hh:mm:ss &quot;;
                    }));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;ILoggerFactory loggerFactory = LoggerFactory.Create(builder =&amp;gt; builder.AddConsole());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然工厂中可以添加其它日志提供程序，示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;            using ILoggerFactory loggerFactory =
                LoggerFactory.Create(builder =&amp;gt;
                    builder.AddSimpleConsole(...)
                    .AddFile(...)
                    .Add()...
                    );
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后获取 ILogger 实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  ILogger logger = loggerFactory.CreateLogger&amp;lt;Program&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;记录日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            logger.LogInformation(&quot;记录信息&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;日志等级&quot;&gt;日志等级&lt;/h4&gt;
&lt;p&gt;Logging API 中，规定了 7 种日志等级，其定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public enum LogLevel
{
  Debug = 1,
  Verbose = 2,
  Information = 3,
  Warning = 4,
  Error = 5,
  Critical = 6,
  None = int.MaxValue
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过 ILogger 中的函数，输出以下几种等级的日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;            logger.LogInformation(&quot;Logging information.&quot;);
            logger.LogCritical(&quot;Logging critical information.&quot;);
            logger.LogDebug(&quot;Logging debug information.&quot;);
            logger.LogError(&quot;Logging error information.&quot;);
            logger.LogTrace(&quot;Logging trace&quot;);
            logger.LogWarning(&quot;Logging warning.&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于 &lt;code&gt;Microsoft.Extensions.Logging&lt;/code&gt; 这里就不再赘述，读者可以等级以下链接，了解更多相关知识：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0#log-exceptions&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0#log-exceptions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tutorialsteacher.com/core/fundamentals-of-logging-in-dotnet-core&quot; target=&quot;_blank&quot;&gt;https://www.tutorialsteacher.com/core/fundamentals-of-logging-in-dotnet-core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/archive/msdn-magazine/2016/april/essential-net-logging-with-net-core&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/archive/msdn-magazine/2016/april/essential-net-logging-with-net-core&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;trace、debug&quot;&gt;Trace、Debug&lt;/h3&gt;
&lt;p&gt;Debug 、Trace 这两个类的命名空间为 &lt;code&gt;System.Diagnostics&lt;/code&gt;，Debug 、Trace 提供一组有助于调试代码的方法和属性。&lt;/p&gt;
&lt;p&gt;读者可以参考笔者的另一篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/whuanle/p/14141213.html#3&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/whuanle/p/14141213.html#3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;输出到控制台：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Trace.Listeners.Add(new TextWriterTraceListener(Console.Out));
Debug.WriteLine(&quot;信息&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;链路跟踪&quot;&gt;链路跟踪&lt;/h2&gt;
&lt;p&gt;链路追踪可以帮助开发者快速定位分布式应用架构下的性能瓶颈，提高微服务时代的开发诊断效率。&lt;/p&gt;
&lt;h3 id=&quot;opentracing&quot;&gt;OpenTracing&lt;/h3&gt;
&lt;p&gt;前面提到的 Trace 、Debug 是 .NET Core 中提供给开发者用于诊断程序和输出信息的 API，而接着提到的 trace 只 OpenTracing API 中的 链路跟踪(trace)。&lt;/p&gt;
&lt;p&gt;普通的日志记录有很大的缺点，就是每个方法记录一个日志，我们无法将一个流程中被调用的多个方法联系起来。当一个方法出现异常时，我们很难知道是哪个任务过程出现的异常。我们只能看到哪个方法出现错误，已经它的调用者。&lt;/p&gt;
&lt;p&gt;在 OpenTracing 中，Trace 是具有 Span(跨度) 的有向无环图。一个 Span 代表应用程序中完成某些工作的逻辑表示，每个 Span 都具有以下属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;操作名称&lt;/li&gt;
&lt;li&gt;开始时间&lt;/li&gt;
&lt;li&gt;结束时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了弄清楚，Trace 和 Span 是什么，OpenTracing 又是什么，请在 Nuget 中引入 &lt;code&gt;OpenTracing&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;编写 Hello 类如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public class Hello
    {
        private readonly ITracer _tracer;
        private readonly ILogger&amp;lt;Hello&amp;gt; _logger;
        public Hello(ITracer tracer, ILoggerFactory loggerFactory)
        {
            _tracer = tracer;
            _logger = loggerFactory.CreateLogger&amp;lt;Hello&amp;gt;();
        }

        public void SayHello(string content)
        {
            // 创建一个 Span 并开始
            var spanBuilder = _tracer.BuildSpan(&quot;say-hello&quot;);
            // -------------------------------
            var span = spanBuilder.Start(); // |
            var str = $&quot;Hello,{content}&quot;;   // |
            _logger.LogInformation(str);    // |
            span.Finish();                  // |
            // ---------------------------------
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动程序，并开始追踪：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        static void Main(string[] args)
        {
            using ILoggerFactory loggerFactory = LoggerFactory.Create(builder =&amp;gt; builder.AddConsole());

            Hello hello = new Hello(GlobalTracer.Instance, loggerFactory);
            hello.SayHello(&quot;This trace&quot;);
            Console.Read();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在以上过程中，我们使用了 OpenTracing API，下面是关于代码中一些元素的说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ITracer 是一个链路追踪实例，BuildSpan() 可以创建其中一个 Span；&lt;/li&gt;
&lt;li&gt;每个 ISpan 都有一个操作名称，例如 &lt;code&gt;say-hello&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;Start()&lt;/code&gt; 开始一个 Span；使用 &lt;code&gt;Finish()&lt;/code&gt; 结束一个 Span；&lt;/li&gt;
&lt;li&gt;跟踪程序会自动记录时间戳；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，我们运行上面的程序时，是没有出现别的信息以及 UI 界面，这是因为 &lt;code&gt;GlobalTracer.Instance&lt;/code&gt; 会返回一个无操作的 tracer。当我们定义一个 Tracer 时，可以观察到链路追踪的过程。&lt;/p&gt;
&lt;p&gt;在 Nuget 中，引入 &lt;code&gt;Jaeger&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在 Program 中，添加一个静态函数，这个函数返回了一个自定义的 Tracer：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;private static Tracer InitTracer(string serviceName, ILoggerFactory loggerFactory)
{
    var samplerConfiguration = new Configuration.SamplerConfiguration(loggerFactory)
        .WithType(ConstSampler.Type)
        .WithParam(1);

    var reporterConfiguration = new Configuration.ReporterConfiguration(loggerFactory)
        .WithLogSpans(true);

    return (Tracer)new Configuration(serviceName, loggerFactory)
        .WithSampler(samplerConfiguration)
        .WithReporter(reporterConfiguration)
        .GetTracer();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 Main 函数内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        static void Main(string[] args)
        {
            using ILoggerFactory loggerFactory = LoggerFactory.Create(builder =&amp;gt; builder.AddConsole());
            var tracer = InitTracer(&quot;hello-world&quot;, loggerFactory);
            Hello hello = new Hello(tracer, loggerFactory);
            hello.SayHello(&quot;This trace&quot;);
            Console.Read();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整代码：&lt;a href=&quot;https://gist.github.com/whuanle/b57fe79c9996988db0a9b812f403f00e&quot; target=&quot;_blank&quot;&gt;https://gist.github.com/whuanle/b57fe79c9996988db0a9b812f403f00e&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;上下文和跟踪功能&quot;&gt;上下文和跟踪功能&lt;/h3&gt;
&lt;p&gt;但是，日志直接输出 string 是很不友好的，这时，我们需要结构化日志。&lt;/p&gt;
&lt;p&gt;当然，ISpan 提供了结构化日志的方法，我们可以编写一个方法，用于格式化日志。&lt;/p&gt;
&lt;h4 id=&quot;跟踪单个功能&quot;&gt;跟踪单个功能&lt;/h4&gt;
&lt;p&gt;在 Hello 类中添加以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;private string FormatString(ISpan rootSpan, string helloTo)
{
    var span = _tracer.BuildSpan(&quot;format-string&quot;).Start();
    try
    {
        var helloString = $&quot;Hello, {helloTo}!&quot;;
        span.Log(new Dictionary&amp;lt;string, object&amp;gt;
        {
            [LogFields.Event] = &quot;string.Format&quot;,
            [&quot;value&quot;] = helloString
        });
        return helloString;
    }
    finally
    {
        span.Finish();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，我们还可以封装一个输出字符串信息的函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;private void PrintHello(ISpan rootSpan, string helloString)
{
    var span = _tracer.BuildSpan(&quot;print-hello&quot;).Start();
    try
    {
        _logger.LogInformation(helloString);
        span.Log(&quot;WriteLine&quot;);
    }
    finally
    {
        span.Finish();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 SayHello 方法改成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        public void SayHello(string content)
        {
            var spanBuilder = _tracer.BuildSpan(&quot;say-hello&quot;);
            var span = spanBuilder.Start();
            var str = FormatString(span, content);
            PrintHello(span,str);
            span.Finish();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改以上代码的原因是，不要在一个方法中糅合太多代码，可以尝试将一些代码复用，封装一个统一的代码。&lt;/p&gt;
&lt;p&gt;但是，原本我们只需要调用 SayHello 一个方法，这里一个方法会继续调用另外两个方法。原本是一个 Span，最后变成三个 Span。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;info: Jaeger.Configuration[0]
info: Jaeger.Reporters.LoggingReporter[0]
      Span reported: 77f1a24676a3ffe1:77f1a24676a3ffe1:0000000000000000:1 - format-string
info: ConsoleApp1.Hello[0]
      Hello, This trace!
info: Jaeger.Reporters.LoggingReporter[0]
      Span reported: cebd31b028a27882:cebd31b028a27882:0000000000000000:1 - print-hello
info: Jaeger.Reporters.LoggingReporter[0]
      Span reported: 44d89e11c8ef51d6:44d89e11c8ef51d6:0000000000000000:1 - say-hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：&lt;code&gt;0000000000000000&lt;/code&gt; 表示一个 Span 已经结束。&lt;/p&gt;
&lt;p&gt;优点：从代码上看，SayHello -&amp;gt; FormaString ,SayHello -&amp;gt; PrintHello，我们可以清晰知道调用链路；&lt;/p&gt;
&lt;p&gt;缺点：从输出来看，Span reported 不同，我们无法中输出中判断三个函数的因果关系；&lt;/p&gt;
&lt;p&gt;我们不可能时时刻刻都盯着代码来看，运维人员和实施人员也不可能拿着代码去对比以及查找代码逻辑。&lt;/p&gt;
&lt;h4 id=&quot;将多个跨度合并到一条轨迹中&quot;&gt;将多个跨度合并到一条轨迹中&lt;/h4&gt;
&lt;p&gt;ITracer 负责创建链路追踪，因此 ITracer 也提供了组合多个 Span 因果关系的 API。&lt;/p&gt;
&lt;p&gt;使用方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var rootSapn = _tracer.BuildSpan(&quot;say-hello&quot;);  // A
var span = _tracer.BuildSpan(&quot;format-string&quot;).AsChildOf(rootSpan).Start();      // B
// A -&amp;gt; B
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们创建了一个 rootSpan ，接着创建一个延续 rootSpan 的 &lt;code&gt;sapn&lt;/code&gt;，&lt;code&gt;rootSpan -&amp;gt; span&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;info: Jaeger.Reporters.LoggingReporter[0]
      Span reported: 2f2c7b36f4f6b0b9:3dab62151c641380:2f2c7b36f4f6b0b9:1 - format-string
info: ConsoleApp1.Hello[0]
      Hello, This trace!
info: Jaeger.Reporters.LoggingReporter[0]
      Span reported: 2f2c7b36f4f6b0b9:9824227a41539786:2f2c7b36f4f6b0b9:1 - print-hello
info: Jaeger.Reporters.LoggingReporter[0]
      Span reported: 2f2c7b36f4f6b0b9:2f2c7b36f4f6b0b9:0000000000000000:1 - say-hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Span reported: 2f2c7b36f4f6b0b9
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出顺序为执行完毕的顺序，say-hello 是最后才执行完成的。&lt;/p&gt;
&lt;h4 id=&quot;传播过程中的上下文&quot;&gt;传播过程中的上下文&lt;/h4&gt;
&lt;p&gt;从什么代码中，大家发现，代码比较麻烦，因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要将 Span 对象作为第一个参数传递给每个函数；&lt;/li&gt;
&lt;li&gt;每个函数中加上冗长的 &lt;code&gt;try-finally{}&lt;/code&gt; 确保能够完成 Span&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为此， OpenTracing API 提供了一种更好的方法，我们可以避免将 Span 作为参数传递给代码，可以统一自行调用 _tracer 即可。&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;FormatString&lt;/code&gt; 和 &lt;code&gt;PrintHello&lt;/code&gt; 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    private string FormatString(string helloTo)
    {
        using var scope = _tracer.BuildSpan(&quot;format-string&quot;).StartActive(true);
        var helloString = $&quot;Hello, {helloTo}!&quot;;
        scope.Span.Log(new Dictionary&amp;lt;string, object&amp;gt;
        {
            [LogFields.Event] = &quot;string.Format&quot;,
            [&quot;value&quot;] = helloString
        });
        return helloString;
    }

    private void PrintHello(string helloString)
    {
        using var scope = _tracer.BuildSpan(&quot;print-hello&quot;).StartActive(true);
        _logger.LogInformation(helloString);
        scope.Span.Log(new Dictionary&amp;lt;string, object&amp;gt;
        {
            [LogFields.Event] = &quot;WriteLine&quot;
        });
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 SayHello 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void SayHello(string helloTo)
{
            using var scope = _tracer.BuildSpan(&quot;say-hello&quot;).StartActive(true);
            scope.Span.SetTag(&quot;hello-to&quot;, helloTo);
            var helloString = FormatString(helloTo);
            PrintHello(helloString);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的代码，我们实现去掉了那些烦人的代码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;StartActive()&lt;/code&gt; 代替&lt;code&gt;Start()&lt;/code&gt;，通过将其存储在线程本地存储中来使 span 处于“活动”状态；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StartActive()&lt;/code&gt; 返回一个&lt;code&gt;IScope&lt;/code&gt;对象而不是一个对象&lt;code&gt;ISpan&lt;/code&gt;。IScope是当前活动范围的容器。我们通过访问活动跨度&lt;code&gt;scope.Span&lt;/code&gt;，一旦关闭了作用域，先前的作用域将成为当前作用域，从而重新激活当前线程中的先前活动范围；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IScope&lt;/code&gt; 继承 &lt;code&gt;IDisposable&lt;/code&gt;，它使我们可以使用&lt;code&gt;using&lt;/code&gt;语法；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StartActive(true)&lt;/code&gt;告诉Scope，一旦它被处理，它就应该完成它所代表的范围；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StartActive()&lt;/code&gt;自动创建 &lt;code&gt;ChildOf&lt;/code&gt; 对先前活动范围的引用，因此我们不必&lt;code&gt;AsChildOf()&lt;/code&gt;显式使用 builder 方法；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果运行此程序，我们将看到所有三个报告的跨度都具有相同的跟踪ID。&lt;/p&gt;
&lt;h2 id=&quot;分布式链路跟踪&quot;&gt;分布式链路跟踪&lt;/h2&gt;
&lt;h4 id=&quot;在不同进程中跟踪&quot;&gt;在不同进程中跟踪&lt;/h4&gt;
&lt;p&gt;微服务将多个程序分开部署，每个程序提供不同的功能。在前面，我们已经学会了 OpenTracing 链路跟踪。接下来，我们将把代码拆分，控制台程序将不再提供 FormatString 函数的实现，我们使用 一个 Web 程序来实现 FormatString 服务。&lt;/p&gt;
&lt;p&gt;创建一个 ASP.NET Core 应用程序，在模板中选择带有视图模型控制器的模板。&lt;/p&gt;
&lt;p&gt;添加一个 &lt;code&gt;FormatController&lt;/code&gt; 控制器在 Controllers 目录中，其代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using Microsoft.AspNetCore.Mvc;

namespace WebApplication1.Controllers
{
    [Route(&quot;api/[controller]&quot;)]
    public class FormatController : Controller
    {
        [HttpGet]
        public string Get()
        {
            return &quot;Hello!&quot;;
        }

        [HttpGet(&quot;{helloTo}&quot;, Name = &quot;GetFormat&quot;)]
        public string Get(string helloTo)
        {
            var formattedHelloString = $&quot;Hello, {helloTo}!&quot;;
            return formattedHelloString;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Web 应用将作为微服务中的其中一个服务，而这个服务只有一个 API ，这个 API 很简单，就是提供字符串的格式化。你也可以编写其它 API 来提供服务。&lt;/p&gt;
&lt;p&gt;将 Program 的 CreateHostBuilder 改一下，我们固定这个服务的 端口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&amp;gt;
                {
                    webBuilder.UseUrls(&quot;http://*:8081&quot;);
                    webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
                });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再到 &lt;code&gt;Startup&lt;/code&gt; 中删除 &lt;code&gt;app.UseHttpsRedirection();&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;修改之前控制台程序的代码，把 &lt;code&gt;FormatString&lt;/code&gt; 方法改成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        private string FormatString(string helloTo)
        {
            using (var scope = _tracer.BuildSpan(&quot;format-string&quot;).StartActive(true))
            {
                using WebClient webClient = new WebClient();
                var url = $&quot;http://localhost:8081/api/format/{helloTo}&quot;;
                var helloString = webClient.DownloadString(url);
                scope.Span.Log(new Dictionary&amp;lt;string, object&amp;gt;
                {
                    [LogFields.Event] = &quot;string.Format&quot;,
                    [&quot;value&quot;] = helloString
                });
                return helloString;
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动 Web 程序后，再启动 控制台程序。&lt;/p&gt;
&lt;p&gt;控制台程序输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;info: Jaeger.Reporters.LoggingReporter[0]
      Span reported: c587bd888e8f1c19:2e3273568e6e373b:c587bd888e8f1c19:1 - format-string
info: ConsoleApp1.Hello[0]
      Hello, This trace!
info: Jaeger.Reporters.LoggingReporter[0]
      Span reported: c587bd888e8f1c19:f0416a0130d58924:c587bd888e8f1c19:1 - print-hello
info: Jaeger.Reporters.LoggingReporter[0]
      Span reported: c587bd888e8f1c19:c587bd888e8f1c19:0000000000000000:1 - say-hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，我们可以将 Formating 改成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        private string FormatString(string helloTo)
        {
            using (var scope = _tracer.BuildSpan(&quot;format-string&quot;).StartActive(true))
            {
                using WebClient webClient = new WebClient();
                var url = $&quot;http://localhost:8081/api/format/{helloTo}&quot;;
                var helloString = webClient.DownloadString(url);
                var span = scope.Span
                    .SetTag(Tags.SpanKind, Tags.SpanKindClient)
                    .SetTag(Tags.HttpMethod, &quot;GET&quot;)
                    .SetTag(Tags.HttpUrl, url);

                var dictionary = new Dictionary&amp;lt;string, string&amp;gt;();
                _tracer.Inject(span.Context, BuiltinFormats.HttpHeaders, new TextMapInjectAdapter(dictionary));
                foreach (var entry in dictionary)
                    webClient.Headers.Add(entry.Key, entry.Value);
                return helloString;
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SetTag&lt;/code&gt; 可以设置标签，我们为本次请求到 Web 的 Span，设置一个标签，并且存储请求的 URL。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;                var span = scope.Span
                    .SetTag(Tags.SpanKind, Tags.SpanKindClient)
                    .SetTag(Tags.HttpMethod, &quot;GET&quot;)
                    .SetTag(Tags.HttpUrl, url);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;Inject&lt;/code&gt; 将上下文信息注入。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;                _tracer.Inject(span.Context, BuiltinFormats.HttpHeaders, new TextMapInjectAdapter(dictionary));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些配置规范，可以到 &lt;a href=&quot;https://github.com/opentracing/specification/blob/master/semantic_conventions.md&quot; target=&quot;_blank&quot;&gt;https://github.com/opentracing/specification/blob/master/semantic_conventions.md&lt;/a&gt; 了解。&lt;/p&gt;
&lt;h4 id=&quot;在-aspnet-core-中跟踪&quot;&gt;在 ASP.NET Core 中跟踪&lt;/h4&gt;
&lt;p&gt;在上面，我们实现了 Client 在不同进程的追踪，但是还没有实现在 Server 中跟踪，我们可以修改 Startup.cs 中的代码，将以下代码替换进去：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using Jaeger;
using Jaeger.Samplers;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using OpenTracing.Util;
using System;

namespace WebApplication1
{
    public class Startup
    {
        private static readonly ILoggerFactory loggerFactory = LoggerFactory.Create(builder =&amp;gt; builder.AddConsole());
        private static readonly Lazy&amp;lt;Tracer&amp;gt; Tracer = new Lazy&amp;lt;Tracer&amp;gt;(() =&amp;gt;
        {
            return InitTracer(&quot;webService&quot;, loggerFactory);
        });
        private static Tracer InitTracer(string serviceName, ILoggerFactory loggerFactory)
        {
            var samplerConfiguration = new Configuration.SamplerConfiguration(loggerFactory)
                .WithType(ConstSampler.Type)
                .WithParam(1);

            var reporterConfiguration = new Configuration.ReporterConfiguration(loggerFactory)
                .WithLogSpans(true);

            return (Tracer)new Configuration(serviceName, loggerFactory)
                .WithSampler(samplerConfiguration)
                .WithReporter(reporterConfiguration)
                .GetTracer();
        }
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();

            GlobalTracer.Register(Tracer.Value);
            services.AddOpenTracing();
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app)
        {
            app.UseRouting();
            app.UseEndpoints(endpoints =&amp;gt;
            {
                endpoints.MapControllerRoute(
                    name: &quot;default&quot;,
                    pattern: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
            });
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样不同的进程各种都可以实现追踪。&lt;/p&gt;
&lt;h3 id=&quot;opentracing-api-和-jaeger&quot;&gt;OpenTracing API 和 Jaeger&lt;/h3&gt;
&lt;p&gt;OpenTracing 是开放式分布式追踪规范，OpenTracing API 是一致，可表达，与供应商无关的API，用于分布式跟踪和上下文传播。&lt;/p&gt;
&lt;p&gt;Jaeger 是 Uber 开源的分布式跟踪系统。&lt;/p&gt;
&lt;p&gt;OpenTracing 的客户端库以及规范，可以到 Github 中查看：&lt;a href=&quot;https://github.com/opentracing/&quot; target=&quot;_blank&quot;&gt;https://github.com/opentracing/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;详细的介绍可以自行查阅资料。&lt;/p&gt;
&lt;p&gt;这里我们需要部署一个 Jaeger 实例，以供微服务以及事务跟踪学习需要。&lt;/p&gt;
&lt;p&gt;使用 Docker 部署很简单，只需要执行下面一条命令即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run -d -p 5775:5775/udp -p 16686:16686 -p 14250:14250 -p 14268:14268 jaegertracing/all-in-one:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问 16686 端口，即可看到 UI 界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1315495/202101/1315495-20210109224307467-2054331430.png&quot; alt=&quot;JaegerUI&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Jaeger 的端口作用如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Collector
14250 tcp  gRPC 发送 proto 格式数据
14268 http 直接接受客户端数据
14269 http 健康检查
Query
16686 http jaeger的UI前端
16687 http 健康检查
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们将学习如何通过代码，将数据上传到 Jaeger 中。&lt;/p&gt;
&lt;h3 id=&quot;链路追踪实践&quot;&gt;链路追踪实践&lt;/h3&gt;
&lt;p&gt;要注意，数据上传到 Jaeger ，上传的是 Span，是不会上传日志内容的。&lt;/p&gt;
&lt;p&gt;继续使用上面的控制台程序，Nuget 中添加 &lt;code&gt;Jaeger.Senders.Grpc&lt;/code&gt; 包。&lt;/p&gt;
&lt;p&gt;我们可以通过 UDP (6831端口)和 gRPC(14250) 端口将数据上传到 Jaeger 中，这里我们使用 gRPC。&lt;/p&gt;
&lt;p&gt;修改控制台程序的 &lt;code&gt;InitTracer&lt;/code&gt; 方法，其代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        private static Tracer InitTracer(string serviceName, ILoggerFactory loggerFactory)
        {
            Configuration.SenderConfiguration.DefaultSenderResolver = new SenderResolver(loggerFactory)
                .RegisterSenderFactory&amp;lt;GrpcSenderFactory&amp;gt;();

            var reporter = new RemoteReporter.Builder()
                .WithLoggerFactory(loggerFactory)
                .WithSender(new GrpcSender(&quot;180.102.130.181:14250&quot;, null, 0))
                .Build();

            var tracer = new Tracer.Builder(serviceName)
                .WithLoggerFactory(loggerFactory)
                .WithSampler(new ConstSampler(true))
                .WithReporter(reporter);

            return tracer.Build();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别启动 Web 和 控制台程序，然后打开 Jaeger 界面，在 ”Service“ 中选择 &lt;code&gt;hello-world&lt;/code&gt;，然后点击底下的 &lt;code&gt;Find Traces&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1315495/202101/1315495-20210109224355061-1657314976.png&quot; alt=&quot;search&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1315495/202101/1315495-20210109224434318-1778429724.png&quot; alt=&quot;hello-world&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过 Jaeger ，我们可以分析链路中函数的执行速度以及服务器性能情况。&lt;/p&gt;
</description>
<pubDate>Sat, 09 Jan 2021 14:46:00 +0000</pubDate>
<dc:creator>痴者工良</dc:creator>
<og:description>.NET Core 中的日志与分布式链路追踪 程序记录的日志一般有两种作用，故障排查、显式程序运行状态，当程序发生故障时，我们可以通过日志定位问题，日志可以给我们留下排查故障的依据。很多时候，往往会认</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whuanle/p/14256858.html</dc:identifier>
</item>
<item>
<title>使用lua+redis解决发多张券的并发问题 - gistmap</title>
<link>http://www.cnblogs.com/gistmap/p/14256794.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gistmap/p/14256794.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;公司有一个发券的接口有并发安全问题，下面列出这个问题和解决这个问题的方式。&lt;/p&gt;
&lt;h3 id=&quot;业务描述&quot;&gt;业务描述&lt;/h3&gt;
&lt;p&gt;这个接口的作用是给会员发多张券码。涉及到4张主体，分别是：用户，券，券码，用户领取记录。&lt;br/&gt;下面是改造前的伪代码。&lt;br/&gt;主要是因为查出券码那行存在并发安全问题，多个线程拿到同几个券码。以下都是基于&lt;strong&gt;如何让取券码变成原子的&lt;/strong&gt;去展开。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean sendCoupons(Long userId, Long couponId) {
    // 一堆校验
    // ...
    // 查出券码
    List&amp;lt;CouponCode&amp;gt; couponCodes = couponCodeService.findByCouponId(couponId, num);
    // batchUpdateStatus是一个被@Transactional(propagation = Propagation.REQUIRES_NEW)修饰的方法
    // 批量更新为已被领取状态
    couponCodeService.batchUpdateStatus(couponCods);
    // 发券
    // 发权益
    // 新增用户券码领取记录
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;改造过程&quot;&gt;改造过程&lt;/h3&gt;
&lt;p&gt;因为券码是多张，想用lua+redis的list结构去做弹出。为什么用这种方案是因为for update直接被否了。&lt;/p&gt;
&lt;p&gt;这是写的lua脚本。。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;local result = {}
for i=1,ARGV[1],1 do
    result[i] = redis.call(&quot;lpop&quot;, KEYS[1])
end
return table.contact(result , &quot;|&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是写的执行lua脚本的client。。其实主要的解决方法就是在redis的list里rpush（存）,lpop（取）取数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@Component
public class CouponCodeRedisQueueClient implements InitializingBean {

    /**
     * redis lua脚本文件路径
     */
    public static final String POP_COUPON_CODE_LUA_PATH = &quot;lua/pop-coupon-code.lua&quot;;
    public static final String SEPARATOR = &quot;|&quot;;

    private static final String COUPON_CODE_KEY_PATTERN = &quot;PROMOTION:COUPON_CODE_{0}&quot;;
    private String LUA_COUPON_CODE_SCRIPT;

    private String LUA_COUPON_CODE_SCRIPT_SHA;

    @Autowired
    private JedisTemplate jedisTemplate;

    @Override
    public void afterPropertiesSet() throws Exception {

        LUA_COUPON_CODE_SCRIPT = Resources.toString(Resources.getResource(POP_COUPON_CODE_LUA_PATH), Charsets.UTF_8);
        if (StringUtils.isNotBlank(LUA_COUPON_CODE_SCRIPT)) {

            LUA_COUPON_CODE_SCRIPT_SHA = jedisTemplate.execute(jedis -&amp;gt; {
                return jedis.scriptLoad(LUA_COUPON_CODE_SCRIPT);
            });
            log.info(&quot;redis lock script sha:{}&quot;, LUA_COUPON_CODE_SCRIPT_SHA);
        }

    }

    /**
     * 获取Code
     *
     * @param activityId
     * @param num
     * @return
     */
    public List&amp;lt;String&amp;gt; popCouponCode(Long activityId, String num , int retryNum) {
        if(retryNum == 0){
            log.error(&quot;reload lua script error , try limit times ,activityId:{}&quot;, activityId);
            return Collections.emptyList();
        }
        List&amp;lt;String&amp;gt; keys = Lists.newArrayList();
        String key = buildKey(String.valueOf(activityId));
        keys.add(key);
        List&amp;lt;String&amp;gt; args = Lists.newArrayList();
        args.add(num);

        try {
            Object result = jedisTemplate.execute(jedis -&amp;gt; {
                if (StringUtils.isNotBlank(LUA_COUPON_CODE_SCRIPT_SHA)) {
                    return jedis.evalsha(LUA_COUPON_CODE_SCRIPT_SHA, keys, args);
                } else {
                    return jedis.eval(LUA_COUPON_CODE_SCRIPT, keys, args);
                }
            });
            log.info(&quot;pop coupon code by lua script.result:{}&quot;, result);
            if (Objects.isNull(result)) {
                return Collections.emptyList();
            }
            return Splitter.on(SEPARATOR).splitToList(result.toString());
        } catch (JedisNoScriptException jnse) {
            log.error(&quot;no lua lock script found.try to reload it&quot;, jnse);
            reloadLuaScript();
            //加载后重新执行
            popCouponCode(activityId, num, --retryNum);
        } catch (Exception e) {
            log.error(&quot;failed to get a redis lock.key:{}&quot;, key, e);
        }
        return Collections.emptyList();
    }

    /**
     * 重新加载LUA脚本
     *
     * @throws Exception
     */
    public void reloadLuaScript() {
        synchronized (CouponCodeRedisQueueClient.class) {
            try {
                afterPropertiesSet();
            } catch (Exception e) {
                log.error(&quot;failed to reload redis lock lua script.retry load it.&quot;);
                reloadLuaScript();
            }
        }
    }

    /**
     * 构建Key
     *
     * @param activityId
     * @return
     */
    public String buildKey(String activityId) {
        return MessageFormat.format(COUPON_CODE_KEY_PATTERN, activityId);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然这种操作需要去提前把所有券的券码丢到redis里去，这里我们也碰到了一些问题（券码量比较大的情况下）。比如开始直接粗暴的用@PostConstruct去放入redis，导致项目启动需要很久很久。。这里就不展开了，说一下我们尝试的几种方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@PostConstruct注解&lt;/li&gt;
&lt;li&gt;CommandLineRunner接口&lt;/li&gt;
&lt;li&gt;redis的pipeline技术&lt;/li&gt;
&lt;li&gt;先保证每个卡券有一定量的券码在redis，再用定时任务定时（根据业务量）去补&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 09 Jan 2021 14:24:00 +0000</pubDate>
<dc:creator>gistmap</dc:creator>
<og:description>前言 公司有一个发券的接口有并发安全问题，下面列出这个问题和解决这个问题的方式。 业务描述 这个接口的作用是给会员发多张券码。涉及到4张主体，分别是：用户，券，券码，用户领取记录。 下面是改造前的伪代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gistmap/p/14256794.html</dc:identifier>
</item>
<item>
<title>命名&amp;可阅读的代码 - .NET西安</title>
<link>http://www.cnblogs.com/net-china/p/14256616.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/net-china/p/14256616.html</guid>
<description>&lt;p&gt;　　题外：昨天看了某知乎用户的回答颇为感慨，大意是说现在主流是框架程序员越来越多，原理、架构、底层方面的越来越少；依赖框架快速出活的程序员工作机会比较多，公司招聘的时候也比较受欢迎。&lt;/p&gt;
&lt;p&gt;　　不能说哪种优秀或者比较low。只要需要就必然有存在的价值，尤其是在快速迭代的今天，速度慢半拍可能就意味着淘汰。&lt;/p&gt;
&lt;p&gt;　　今天说命名可阅读的代码。&lt;/p&gt;


&lt;p&gt;　　写程序就像建造一栋高楼，包括方方面面，罗马不是一天建成的。软件开发领域，强调命名的重要性至今都不过时。代码开发阶段在大部分应用程序生命周期中占比都是很小的一个阶段，维护阶段是一个大头，后来的人员需要阅读你的代码&amp;lt;也可能包括未来的你&amp;gt;才能完成工作。很多时候，维护运营阶段阅读前人的代码，或者自己以前的代码会有一个感觉一个头两个大。&lt;/p&gt;
&lt;p&gt;　　什么是好的命名，没有固定答案，不过有一个原则就是：遵循团队或者项目的命名规范，如果团队或者项目还没有统一的命名规范，首先去创建她，然后贯彻到底。相信百分之九十九的组织都有自己的命名规范。&lt;/p&gt;
&lt;p&gt;　　关于注释也在存在争议，有的组织规定代码不能存在注释，有的组织要求必须写注释。优劣没有定论，不过好的命名可以是“自注释”，可以明确传达代码意图，描述逻辑。统一的命名规则可以使整个团队保持一致。&lt;/p&gt;


&lt;p&gt;　　1、名字完整准确的表达其所代表的的含义、名字反应实际问题、名字“足够长”、限定词放在名字最后、&lt;/p&gt;
&lt;p&gt;　　2、避免缩写或对缩写进行统一约定、使用约定对仗词&amp;lt;begin/end、min/max、up/down&amp;gt;等、使用有意义的循环下标&lt;/p&gt;
&lt;p&gt;　　3、命名规则能够区分类名、常量、枚举、变量&lt;/p&gt;
&lt;p&gt;　　以上简单罗列，更多实践，Google 一下。&lt;/p&gt;


&lt;p&gt;　　1、常见的多层结构中：业务逻辑层，IxxService、xxService  ；数据访问层，IxxDao  、xxDao 等，当然每个组织可能不一样&lt;/p&gt;
&lt;p&gt;　　2、模式语言 xxFactory 、xxObserver、xxSingleton 等&lt;/p&gt;
&lt;p&gt;　　3、.Net Framework 中API &lt;/p&gt;
&lt;p&gt;　　4、代码片段 　　 &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
string add;　　// person address
int a;　　// person age

string address;
int age;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　强调命名是一个古老的话题，但是从来都不过时。最后用一个问答，强调一下命名的重要性。&lt;/p&gt;
&lt;p&gt;　　问：如何写出可阅读的代码，自注释代码？ 答：遵循良好的命名实践。&lt;/p&gt;
&lt;p&gt;　　推荐阅读：&lt;/p&gt;
&lt;p&gt;　　1、《Code Complete》第11章 The Power Of Variable Names &lt;/p&gt;
&lt;p&gt;　　2、How To Write Unmaintainable Code : &lt;a href=&quot;https://github.com/Droogans/unmaintainable-code&quot;&gt;https://github.com/Droogans/unmaintainable-code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　3、阿里《Java 开发手册》 &lt;a href=&quot;https://github.com/alibaba/p3c&quot;&gt;https://github.com/alibaba/p3c&lt;/a&gt;&lt;/p&gt;


</description>
<pubDate>Sat, 09 Jan 2021 14:16:00 +0000</pubDate>
<dc:creator>.NET西安</dc:creator>
<og:description>一、前言 题外：昨天看了某知乎用户的回答颇为感慨，大意是说现在主流是框架程序员越来越多，原理、架构、底层方面的越来越少；依赖框架快速出活的程序员工作机会比较多，公司招聘的时候也比较受欢迎。 不能说哪种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/net-china/p/14256616.html</dc:identifier>
</item>
<item>
<title>手撕redis分布式锁，隔壁张小帅都看懂了！ - 程序员老猫</title>
<link>http://www.cnblogs.com/kdaddy/p/14256591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kdaddy/p/14256591.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;上一篇老猫和小伙伴们分享了为什么要使用分布式锁以及分布式锁的实现思路原理，目前我们主要采用第三方的组件作为分布式锁的工具。上一篇运用了Mysql中的select ...for update实现了分布式锁，但是我们说这种实现方式并不常用，因为当大并发量的时候，会给数据库带来比较大的压力。当然也有小伙伴给老猫留言说“ 在quartz的集群模式中，就是使用了基于mysql的分布式锁，select for update ”。没错，其实quartz的集群模式中，任务执行的节点个数是可预知的，而且没有那么大的量级，所以是没有问题的。但是如果像千万级别的并发秒杀场景的情况下，那么这种方案其实是不可行的。因为mysql操作是需要IO的，IO的速度比内存速度慢，因此mysql如果在那种场景下使用的话是会存在系统瓶颈的。所以本篇就和小伙伴们分享基于内存操作的比较常用的分布式锁——redis分布式锁。&lt;/p&gt;
&lt;h3 id=&quot;手撸redis分布式锁&quot;&gt;手撸Redis分布式锁&lt;/h3&gt;
&lt;h4 id=&quot;实现原理&quot;&gt;实现原理&lt;/h4&gt;
&lt;p&gt;redis分布式锁实现原理其实也是比较简单的，主要是依赖于redis的 set nx命令，我们来看一下完整的设置redis的命令：“Set resource_name my_random_value NX PX 30000”。看到这串命令，了解redis的小伙伴应该都看得懂这条命令是在redis中存入一个带有过期时间的值。具体上述设值语句解释如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;resource_name：资源名称，可以根据不同的业务区分不同的锁。(其实就是对应我们上一篇myql锁中的business_code)。&lt;/li&gt;
&lt;li&gt;my_random_value：随机值，每个线程的随机值都不相同，主要用于释放锁的时候用来校验。&lt;/li&gt;
&lt;li&gt;NX：key不存在的时候设置成功，key存在则设置不成功。&lt;/li&gt;
&lt;li&gt;PX：自动失效时间，如果出现异常情况，锁可以过期实现，因此达到了自动释放。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么为什么可以使用这个思路呢？其实很简单，主要就是利用了set nx的原子性，在多个线程并发执行时，只有一个线程可以设置成功，如果设置成功，那么就代表着获得了锁，就可以执行后续的业务。如果出现了异常，过了锁的有效期，锁会自动释放，释放锁主要采用了redis的delete命令，释放锁之前会校验当前redis存储的随机数，只有当前的随机数和存储的随机数一致的时候才允许释放。具体的redis的删除，我们可以通过lua脚本进行删除，具体Lua脚本如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
    return redis.call(&quot;del&quot;,KEYS[1])
else
    return 0
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们为什么要采用这种方式释放锁呢？其实使用这种方式释放锁可以避免删除别的客户端获取成功的锁 。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2200669/202101/2200669-20210109212811578-619703094.png&quot; alt=&quot;redis释放锁&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端A取得资源锁，但是紧接着被一个其他操作阻塞了，当客户端A运行完毕其他操作后要释放锁时，原来的锁早已超时并且被Redis自动释放，并且在这期间资源锁又被客户端B再次获取到。如果仅使用DEL命令将key删除，那么这种情况就会把客户端B的锁给删除掉。使用Lua脚本就不会存在这种情况，因为脚本仅会删除value等于客户端A的value的key（value相当于客户端的一个签名）（说明：其实这些例子在redis的官网都有介绍）。&lt;/p&gt;
&lt;h4 id=&quot;代码实现方式&quot;&gt;代码实现方式&lt;/h4&gt;
&lt;p&gt;老猫对redis锁机制进行了相关的抽取，并且封装成了工具类，核心工具类代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author kdaddy@163.com
 * @date 2021/1/7 22:36
 * 公众号“程序员老猫”
 */
@Service
public class RedisLockUtil {

    @Autowired
    private RedisTemplate redisTemplate;

    private String value = UUID.randomUUID().toString();

    public Boolean lock(String key){
        RedisCallback&amp;lt;Boolean&amp;gt; redisCallback = redisConnection -&amp;gt; {
            //表示set nx 存在key的话就不设置，不存在则设置
            RedisStringCommands.SetOption setOption = RedisStringCommands.SetOption.ifAbsent();
            //设置过期时间
            Expiration expiration = Expiration.seconds(30);
            byte[] redisKey = redisTemplate.getKeySerializer().serialize(key);
            byte[] redisValue = redisTemplate.getKeySerializer().serialize(value);
            Boolean result = redisConnection.set(redisKey,redisValue,expiration,setOption);
            return result;
        };
        //获取分布式锁
        Boolean lock = (Boolean)redisTemplate.execute(redisCallback);
        return lock;
    }
    //释放分布式锁
    public Boolean releaseLock(String key){
        String script = &quot;if redis.call(\&quot;get\&quot;,KEYS[1]) == ARGV[1] then\n&quot; +
                &quot;    return redis.call(\&quot;del\&quot;,KEYS[1])\n&quot; +
                &quot;else\n&quot; +
                &quot;    return 0\n&quot; +
                &quot;end&quot;;
        RedisScript&amp;lt;Boolean&amp;gt; redisScript = RedisScript.of(script,Boolean.class);
        List&amp;lt;String&amp;gt; keys = Arrays.asList(key);

        boolean result = (Boolean) redisTemplate.execute(redisScript,keys,value);
        return result;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然相关的业务代码，老猫还是使用了之前并发扣减库存的例子，在此相关的代码以及最终运行的结果也不一一进行举例。小伙伴们可以自行去老猫的github获取相关的示例源码信息，然后运行一下即可。github地址：&lt;a href=&quot;https://github.com/maoba/kd-distribute%E3%80%82%E4%BB%A3%E7%A0%81%E5%B7%B2%E7%BB%8F%E5%AE%8C%E6%88%90%E4%BA%86%E6%9B%B4%E6%96%B0%E3%80%82&quot; target=&quot;_blank&quot;&gt;https://github.com/maoba/kd-distribute。代码已经完成了更新。&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;redisson分布式锁&quot;&gt;Redisson分布式锁&lt;/h3&gt;
&lt;h4 id=&quot;介绍和使用&quot;&gt;介绍和使用&lt;/h4&gt;
&lt;p&gt;那么Redisson究竟为何物呢？Redisson 是架设在&lt;a href=&quot;http://redis.cn/&quot; target=&quot;_blank&quot;&gt;Redis&lt;/a&gt;基础上的一个Java驻内存数据网格（In-Memory Data Grid）。 充分的利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。 (摘自redisson官网：&lt;a href=&quot;https://redisson.org/&quot; target=&quot;_blank&quot;&gt;https://redisson.org/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;下面我们来看一下具体用redisson实现分布式锁实战，其实是相当简单的，redisson已经给我们进行了相关的封装，我们开箱即用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author kdaddy@163.com
 * @date 2021/1/9 14:23
 * @公众号“程序员老猫”
 */
public  Integer createOrder() throws Exception{
    log.info(&quot;进入了方法&quot;);
    Config config = new Config();
    config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;).setPassword(&quot;ktdaddy&quot;);
    RedissonClient redissonClient = Redisson.create(config);
    RLock rlock = redissonClient.getLock(ORDER_KEY);
    rlock.lock(30, TimeUnit.SECONDS);

    try {
        log.info(&quot;拿到了锁&quot;);
        //....具体可以参考老猫的github
        return order.getId();
    }catch (Exception e){
        e.printStackTrace();
    }finally {
        rlock.unlock();
    }
    return null;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;原理&quot;&gt;原理&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2200669/202101/2200669-20210109212838962-454073350.png&quot; alt=&quot;redisson简单架构&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;老猫上文中自己实现redis锁的时候用到了lua脚本，redisson实现的时候其实所有的指令都是通过lua脚本去实现的。上述为redisson的简单架构图，画的比较粗糙。老猫稍微作一下解释。上图中有个看门狗(watchdog)概念。其实这就是一个定时任务，在线程获取锁之后，它会每隔10s帮忙将key的超时时间设置为30s，这样就不会出现线程一直持有锁从而影响其他线程获取锁的问题。小伙伴们可以发现该功能其实就是set px，只是换成了定时任务去实现。当然看门狗的存在保证了出现死锁的情况下会自动释放。&lt;/p&gt;
&lt;p&gt;以上只是针对redisson做了一个简单的应用介绍，redisson其实是相当强大的，首先说配置，老猫上述连接redis的方式其实很简单，由于搭建的是单机redis，所以就使用了单机redis的连接方式，当然redisson还支持主从、哨兵、集群等等连接方式；当然锁的种类也相当丰富，以上老猫提供的是可重入锁的流程。其实还包括公平锁、联锁、红锁、读写锁等等，另外的redisson对分布式的容器、队列等等进行了特有的封装，包括分布式的Blocking Queue、分布式Map、分布式Set、分布式List等等。redisson的强大之处老猫在此不一一枚举，有兴趣的小伙伴可以深入研究一下。&lt;/p&gt;
&lt;h3 id=&quot;缺陷&quot;&gt;缺陷&lt;/h3&gt;
&lt;p&gt;redis锁可以比较完美地解决高并发的时候分布式系统的线程安全性的问题，但是这种锁机制也并不是完美的。在哨兵模式下，客户端对master节点加了锁，此时会异步复制给slave节点，此时如果master发生宕机，主备切换，slave变成了master。因为之前是异步复制，所以此时正好又有个线程来尝试加锁的时候，就会导致多个客户端对同一个分布式锁完成了加锁操作，这时候业务上会出现脏数据了。关于redis的相关知识，大家可以访问老猫之前的一些文章，包括redis的哨兵模式、持久化等等。&lt;/p&gt;
&lt;h3 id=&quot;写在最后&quot;&gt;写在最后&lt;/h3&gt;
&lt;p&gt;本篇主要和小伙伴们分享了redis锁，从老猫自己实现的乞丐版的redis锁到大牛实现的redisson。相信大家也会有一定的收货。其实关于分布式锁，出了redis锁之外还有基于zookeeper的实现。后续老猫会整理并且分享给大家，敬请期待。&lt;/p&gt;
&lt;p&gt;当然更多技术干货也欢迎大家搜索关注公众号“程序员老猫”&lt;/p&gt;
</description>
<pubDate>Sat, 09 Jan 2021 13:43:00 +0000</pubDate>
<dc:creator>程序员老猫</dc:creator>
<og:description>还不会用redis实现分布式锁？滴滴~快上车~</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kdaddy/p/14256591.html</dc:identifier>
</item>
</channel>
</rss>