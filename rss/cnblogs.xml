<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>乙方的烦恼---如何在乙方升级的情况下甲方不用升级？ - 一天不进步，就是退步</title>
<link>http://www.cnblogs.com/davidwang456/p/11601374.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davidwang456/p/11601374.html</guid>
<description>&lt;p&gt;&lt;strong&gt;故事背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自古以来，做买卖、特别是供大于求情况下，市场游戏总会出现乙方有求于甲方的现象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201909/486074-20190928064037724-2103680917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 在现在的市场经济机制下，甲方和乙方的地位更难平等，小王是深有体会。小王是一家软件外包公司的员工，他们为一家国企提供软件服务，最近小王比较烦，因需求变更，甲方大爷软件中引用的一个jar中的常量发生了变化，他们更新了jar包，但甲方只同意将新jar包替换掉旧的jar包，导致系统出现执行异常！甲方限令必须尽快找到问题并解决掉！&lt;/p&gt;
&lt;p&gt;为了防止公司信息泄露，我们模拟一下这个场景:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BinaryCompatibilityTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(DefineConstants.FIRST &lt;/span&gt;+ &quot; &quot; +&lt;span&gt;
                DefineConstants.SECOND &lt;/span&gt;+ &quot; &quot; +&lt;span&gt;
                DefineConstants.THIRD);
                }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中DefineConstants来自甲方对乙方的引用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.test.constants.Words;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefineConstants {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DefineConstants() { }; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uninstantiable&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String FIRST =&lt;span&gt; Words.FIRST;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SECOND =&lt;span&gt; Words.SECOND;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String THIRD =&lt;span&gt; Words.THIRD;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，Words是引用的公用jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201909/486074-20190928072856123-1847884415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 类实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.test.constants;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Words {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Words() {
    }; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uninstantiable&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String FIRST = &quot;the&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SECOND = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String THIRD = &quot;set&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;原先打印结果为&lt;/p&gt;
&lt;p&gt;the null set&lt;/p&gt;

&lt;p&gt;现在乙方小王修改了jar包后，代码变成了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.test.constants;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Words {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Words() {
    }; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uninstantiable&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String FIRST = &quot;physics&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SECOND = &quot;chemistry&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String THIRD = &quot;biology&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;他将重新打包后的jar包传给甲方，让甲方在tomcat上替换原来的jar包，结果运行后打印的结果却为：&lt;/p&gt;
&lt;p&gt;the chemistry set&lt;/p&gt;
&lt;p&gt;小王百思不得其解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201909/486074-20190928074034837-2027996077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 反复确认了jar包是否正确，都是最新的jar包。&lt;/p&gt;
&lt;p&gt;万般无奈之下只好请出被辞退的中老年技术大神&quot;老司机&quot;，并答应老司机1w/d的辛苦费。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201909/486074-20190928075217623-1651170036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 老司机了解了情况后，就找到了原因，通过jd-gui反编译了代码给小王看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/486074/201909/486074-20190928075750479-398311440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 替换了jar包后，DefineConstants并没有被重新编译，导致FIRST和THIRD的结果没有发生改变，&lt;/p&gt;
&lt;p&gt;但因SECOND本身为null，在编译期常量表达式(compile-time constant expression)[JLS15.28]的精确定义中找到。它的定义太长了，就不在这里写出来了，但是理解这&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;个程序的行为的关键是null 不是一个编译期常量表达式。&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;运行时就会执行新的结果：chemistry&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;解决办法是&lt;/p&gt;
&lt;p&gt;1. 需要重新编译DefineConstants后，替换到新的class&lt;/p&gt;
&lt;p&gt;2.重新编译整个项目的打包文件，提供新的包文件替换旧的打包文件&lt;/p&gt;
&lt;p&gt;第一个方案&lt;/p&gt;
&lt;p&gt;   优点： 线上改动小，影响小，速度快&lt;/p&gt;
&lt;p&gt;   缺点：只能解决当前问题，如果项目中还有别的地方引用这个变量，将还会出错。&lt;/p&gt;
&lt;p&gt;第二个方案&lt;/p&gt;
&lt;p&gt;   优点：从根本上解决问题&lt;/p&gt;
&lt;p&gt;   缺点：线上影响稍微大一些。&lt;/p&gt;

&lt;p&gt;小王入司刚两年，是个勤奋好学的家伙，项目搞定后请老司机吃饭喝酒，趁老司机酒醉，趁机问解决这个问题的诀窍，老司机喝迷糊后道出了本质：&lt;/p&gt;
&lt;p&gt;原来java考虑到升级的问题，有二进制兼容性规范，。。。。。。。。。&lt;/p&gt;
&lt;p&gt;因老司机喝的有点多，描述的不是很清楚，小王只记住了在jsl规范了有明确的描述：jsl 13章，&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se12/html/index.html&quot;&gt;https://docs.oracle.com/javase/specs/jls/se12/html/index.html&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;【1】&lt;a href=&quot;http://blog.sina.com.cn/s/blog_4c408e27010009ae.html&quot;&gt;http://blog.sina.com.cn/s/blog_4c408e27010009ae.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【2】java解惑&lt;/p&gt;
&lt;p&gt;【3】&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se12/html/index.html&quot;&gt;https://docs.oracle.com/javase/specs/jls/se12/html/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【4】&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se12/html/jls-15.html#jls-15.28&quot;&gt;https://docs.oracle.com/javase/specs/jls/se12/html/jls-15.html#jls-15.28&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Sep 2019 00:28:00 +0000</pubDate>
<dc:creator>一天不进步，就是退步</dc:creator>
<og:description>故事背景 自古以来，做买卖、特别是供大于求情况下，市场游戏总会出现乙方有求于甲方的现象。 在现在的市场经济机制下，甲方和乙方的地位更难平等，小王是深有体会。小王是一家软件外包公司的员工，他们为一家国企</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/davidwang456/p/11601374.html</dc:identifier>
</item>
<item>
<title>品Spring：负责bean定义注册的两个“排头兵” - 编程新说(李新杰)</title>
<link>http://www.cnblogs.com/lixinjie/p/taste-spring-007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/taste-spring-007.html</guid>
<description>&lt;p&gt;&lt;span&gt;别看Spring现在玩的这么花，其实它的“筹码”就两个，“&lt;/span&gt;&lt;span&gt;容器&lt;/span&gt;&lt;span&gt;”和“&lt;/span&gt;&lt;span&gt;bean定义&lt;/span&gt;&lt;span&gt;”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只有先把bean定义注册到容器里，后续的一切可能才有可能成为可能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以在进阶的路上如果要想走的顺畅些，彻底搞清楚bean定义注册的所有细节至关重要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;毕竟这是万里长征的第一步。&lt;/span&gt;&lt;span&gt;有句话怎么说来着，“勿在浮沙筑高台”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring步入注解和Java配置的时代也有些时日了。&lt;/span&gt;&lt;span&gt;而且也旗帜鲜明的表达了bean的注册方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这不，就是这个接口，&lt;/span&gt;&lt;span&gt;AnnotationConfigRegistry&lt;/span&gt;&lt;span&gt;，如下图01：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221646225-1865049562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;再来看下这个接口的名字，有三个单词组成，&lt;/span&gt;&lt;span&gt;Annotation&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Config&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Registry&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一个表示注解，第二个表示Java配置，第三个表示注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;合起来的意思可以理解为，&lt;/span&gt;&lt;span&gt;基于注解和Java配置的bean定义注册&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;当然，这是我猜的，哈哈哈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个很牛X的接口，理由见下图02：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221652533-901849401.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;纳尼，&lt;/span&gt;&lt;span&gt;所有的容器类都实现了它&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不管是web的、非web的，传统Spring的、SpringBoot的，响应式的、Servlet的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简直是老少通吃、妇孺皆宜啊。&lt;/span&gt;&lt;span&gt;淡定、淡定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个接口的两个方法非常&lt;strong&gt;简约&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个是直接把一个类（Class&amp;lt;?&amp;gt;）进行注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个是通过扫描指定的包（Package）里的类进行注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;请注意我刚刚使用了“简约”而没有使用“简单”，因为简约往往并不等于简单，反而更多时候等于难。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;讲了这么多，终于可以让今天的主角登场了，来来来，掌声响起来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就是这两个类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;AnnotatedBeanDefinitionReader&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ClassPathBeanDefinitionScanner&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一个类就是站在接口第一个方法register背后默默付出的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二个类就是负责搞定接口第二个方法scan后面所有事情的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面开始进行具体的讲解，&lt;/span&gt;&lt;span&gt;只需要知道都干了什么即可&lt;/span&gt;&lt;span&gt;，至于怎么干的，不需要了解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看第一个类，如下图03：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221659998-40651696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第一个字段类型是&lt;/span&gt;&lt;span&gt;BeanDefinitionRegistry&lt;/span&gt;&lt;span&gt;，这是容器（或bean factory）会实现的接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用于把一个BeanDefinition（bean定义）注册到容器中，看下它的这个方法，如下图04：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221705741-684850755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;编程新说注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：对“bean定义”这个概念不清楚的，可以在文末查看本系列《品Spring》文章的头几篇。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚刚应该看到在注册bean定义时需要一个bean名称（即beanName），因此该第二个字段发挥作用了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它就是&lt;/span&gt;&lt;span&gt;BeanNameGenerator&lt;/span&gt;&lt;span&gt;。例如，有一个类是UserController，它上面标了注解@Controller(&quot;user&quot;)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先它会把注解的value属性作为名称，此时就是user啦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果没有指定value属性，就像这样@Controller，此时就是类的短名称且首字母小写，即userController。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就是bean名称的生成策略，在实际开发中不就是这样的嘛。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三个字段是&lt;/span&gt;&lt;span&gt;ScopeMetadataResolver&lt;/span&gt;&lt;span&gt;，是来决定bean实例的范围（即&lt;/span&gt;&lt;span&gt;生命周期&lt;/span&gt;&lt;span&gt;）的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常见的生命周期有四种，&lt;/span&gt;&lt;span&gt;PROTOTYPE&lt;/span&gt;&lt;span&gt;（原型）、&lt;/span&gt;&lt;span&gt;SINGLETON&lt;/span&gt;&lt;span&gt;（单例）、&lt;/span&gt;&lt;span&gt;REQUEST&lt;/span&gt;&lt;span&gt;（请求）、&lt;/span&gt;&lt;span&gt;SESSION&lt;/span&gt;&lt;span&gt;（会话）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就是通过检查类上有没有&lt;/span&gt;&lt;span&gt;@Scope&lt;/span&gt;&lt;span&gt;这个注解。如果有的话，就按指定的走，没有的话，就按&lt;/span&gt;&lt;span&gt;单例&lt;/span&gt;&lt;span&gt;走。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四个字段是&lt;/span&gt;&lt;span&gt;ConditionEvaluator&lt;/span&gt;&lt;span&gt;，条件计算器，根据“&lt;/span&gt;&lt;span&gt;条件&lt;/span&gt;&lt;span&gt;”判断一个bean定义该不该被注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这可是SpringBoot自动配置（AutoConfiguration）的基石啊。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就是去检测类上有没有标&lt;/span&gt;&lt;span&gt;@Conditional&lt;/span&gt;&lt;span&gt;这个注解。如果没有的话，bean定义会被注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果有的话，需要再去计算具体的“条件”，然后才能确定bean定义到底要不要注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哎呀，注册一个bean定义好麻烦啊，喘口气，继续吧。嘿嘿。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面开始真正进入注册的方法，先看下方法的参数吧，如下图05：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221714334-1986224380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;方法共有5个参数，只有第一个是必须的，后面的都可以为空。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一个参数，annotatedClass，是Class&amp;lt;?&amp;gt;，表示要被注册的类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二个参数，instanceSupplier，是一个函数式接口，Supplier&amp;lt;T&amp;gt;，可以提供这个bean的实例对象，这样就不再需要通过反射调用构造函数了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三个参数，name，bean名称，如果传的话就不用再生成了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四个参数，qualifiers，是一组用作限定修饰符的注解，Class&amp;lt;? extends Annotation&amp;gt;[]。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第五个参数，definitionCustomizers，是一组可以自定义bean定义的接口，BeanDefinitionCustomizer。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整个处理过程分为九步，如下图06：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221720063-628620451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步&lt;/span&gt;&lt;span&gt;，先把类转变为bean定义，即把Class&amp;lt;?&amp;gt;转变为BeanDefinition。&lt;/span&gt;&lt;span&gt;具体是&lt;/span&gt;&lt;span&gt;AnnotatedGenericBeanDefinition&lt;/span&gt;&lt;span&gt;这个类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二步&lt;/span&gt;&lt;span&gt;，使用条件计算器来确定是否要注册这个bean定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三步&lt;/span&gt;&lt;span&gt;，确定这个bean的生命周期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四步&lt;/span&gt;&lt;span&gt;，确定这个bean的名称。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第五步&lt;/span&gt;&lt;span&gt;，处理定义的公共注解信息。&lt;/span&gt;&lt;span&gt;如下图07：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221726520-846542928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是&lt;/span&gt;&lt;span&gt;@Lazy&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;@Primary&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;@DependsOn&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;@Role&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;@Description&lt;/span&gt;&lt;span&gt;这五个注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从类上分别获取这些注解，然后从注解中读出需要的信息，再把这些信息设置到bean定义中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第六步&lt;/span&gt;&lt;span&gt;，处理限定修饰符，就是&lt;/span&gt;&lt;span&gt;@Primary&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;@Lazy&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;@Qualifier&lt;/span&gt;&lt;span&gt;这三个注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个几个注解是从方法参数传入的，上一步的注解是从类上读取的，它们不重复也不冲突。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编程新说注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：这些注解的含义和用法，这里就不说了，毕竟这是“追求深度”的文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第七步&lt;/span&gt;&lt;span&gt;，应用bean定义自定义器，对bean定义进行一些自定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第八步&lt;/span&gt;&lt;span&gt;，根据bean的生命周期，使用AOP技术为该bean定义生成代理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第九步&lt;/span&gt;&lt;span&gt;，把这个bean定义注册到容器中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就是一个bean定义的完整注册过程。妈呀，让我歇会儿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;编程新说注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：第二个类注册bean定义的整体逻辑和第一个类完全一样。只是获取bean定义的方式不同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面看第二个类，如下图08：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221734421-816935813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先可以看到，它扫描的都是jar包中的&lt;/span&gt;&lt;span&gt;.class&lt;/span&gt;&lt;span&gt;文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后还有两个&lt;/span&gt;&lt;span&gt;过滤器&lt;/span&gt;&lt;span&gt;集合，决定哪些被排除、哪些被包含。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，类中也给出了默认情况下包含的，如下图09：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221740752-1175694385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第一，&lt;/span&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;span&gt;注解以及用它定义的其它注解，如@Configuration等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二，JSR-250里面的&lt;/span&gt;&lt;span&gt;@javax.annotation.ManagedBean&lt;/span&gt;&lt;span&gt;注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三，JSR-330里面的&lt;/span&gt;&lt;span&gt;@javax.inject.Named&lt;/span&gt;&lt;span&gt;注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标了这三个注解的类都会被注册&lt;/span&gt;&lt;span&gt;，第一个注解是Spring的，后两个是Java的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;默认情况下，排除过滤器没有指定，也就是不进行任何显式的排除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体收集bean定义的过程，分为七步，如下图10：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221809144-458990726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步&lt;/span&gt;&lt;span&gt;，拼接资源路径，形式就是这样&lt;/span&gt;&lt;span&gt;classpath*:org/cnt/ts/**/*.class&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它表示搜索类路径下所有的jar包里，以org/cnt/ts开头的包及其子包里的所有.class文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二步&lt;/span&gt;&lt;span&gt;，找出上一步中的那些.class文件，并把它们转化为资源，即Resource类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三步&lt;/span&gt;&lt;span&gt;，使用ASM框架逐个读取这些资源（其实就是字节码文件啦）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四步&lt;/span&gt;&lt;span&gt;，应用过滤器和条件计算器，来确定这个bean定义是否要被注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图11：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221817428-1484134770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第五步&lt;/span&gt;&lt;span&gt;，使用从字节码中读出的内容来构建BeanDefinition，使用的是&lt;/span&gt;&lt;span&gt;ScannedGenericBeanDefinition&lt;/span&gt;&lt;span&gt;这个类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第六步&lt;/span&gt;&lt;span&gt;，确认下这个类是否符合要求，如下图12：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221824216-1810228441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一共有三项检查：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一，必须是独立的。&lt;/span&gt;&lt;span&gt;可以是&lt;/span&gt;&lt;span&gt;顶级类&lt;/span&gt;&lt;span&gt;（非内部类），可以是&lt;/span&gt;&lt;span&gt;静态内部类&lt;/span&gt;&lt;span&gt;（即static class）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二，必须是&lt;/span&gt;&lt;span&gt;具体的&lt;/span&gt;&lt;span&gt;，即非抽象的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三，如果类是抽象的，它必须包含一个标有&lt;/span&gt;&lt;span&gt;@Lookup&lt;/span&gt;&lt;span&gt;注解的方法，来指定一个具体的bean。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第七步&lt;/span&gt;&lt;span&gt;，收集好这个bean定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些bean定义抽取好后，剩下的处理就和第一个类一样了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图13：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201909/76066-20190925221831041-235531954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;也是确定生命周期，生成bean名称，处理定义的公共注解信息，根据生命周期生成代理，最后注册到容器中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后声明一点&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上两个类并不处理@Bean这个注解注册的bean定义，也不处理由@Import注解引入的bean定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哪谁处理呢？后续文章见。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 品Spring系列文章 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：帝国的基石&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484229&amp;amp;idx=1&amp;amp;sn=b552914c42963d06306d35f1d8332284&amp;amp;chksm=fc3338b5cb44b1a39d0762b2fd94d8870fcbc520b0713964d9a453d8466d781897707de8cd8f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：bean定义上梁山&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484244&amp;amp;idx=1&amp;amp;sn=d500b3ed748331687028b78d567222a8&amp;amp;chksm=fc3338a4cb44b1b23f5dd9bef1cc66950a1ded23151a05b38716f4ec46ff960cdda5d8022e8f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：实现bean定义时采用的“先进生产力”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484249&amp;amp;idx=1&amp;amp;sn=dfbdca65a2b64b0ac951f90b301e73a0&amp;amp;chksm=fc3338a9cb44b1bfafee072597430dae91d4dd8b4787e4af0896f9ce45b258fd5d3634169a5d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：注解终于“成功上位”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484259&amp;amp;idx=1&amp;amp;sn=791a5726b9b7bf41e4e64053cfbc7ffa&amp;amp;chksm=fc333893cb44b1851d2052423392551ca9188c4fc0a33f412ddda13af9e0dc6655966a668964&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：能工巧匠们对注解的“加持”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484301&amp;amp;idx=1&amp;amp;sn=a5557c4c285cb07a052238d3de2a2585&amp;amp;chksm=fc33387dcb44b16b487edee0ab4c755de394d19dd4a0acd2532af0e49e95eb7988628e93157b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot和Spring到底有没有本质的不同？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是工作超过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;10年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的码农，现在任架构师。喜欢研究技术，崇尚简单快乐。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;追求以通俗易懂的语言解说技术，希望所有的读者都能看懂并记住。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;下面是公众号和知识星球的二维码，欢迎关注！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419093441100-1622885471.jpg&quot; alt=&quot;&quot;/&gt;      &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://img2018.cnblogs.com/blog/76066/201904/76066-20190419132131137-250931220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 27 Sep 2019 22:39:00 +0000</pubDate>
<dc:creator>编程新说(李新杰)</dc:creator>
<og:description>别看Spring现在玩的这么花，其实它的“筹码”就两个，“容器”和“bean定义”。只有先把bean定义注册到容器里，后续的一切可能才有可能成为可能。所以在进阶的路上如果要想走的顺畅些，彻底搞清楚be</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixinjie/p/taste-spring-007.html</dc:identifier>
</item>
<item>
<title>C++ 编程技巧笔记记录（持续更新） - KillerAery</title>
<link>http://www.cnblogs.com/KillerAery/p/11601229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KillerAery/p/11601229.html</guid>
<description>&lt;p&gt;前言：C++是博大精深的语言，特性复杂得跟北京二环一样，继承乱得跟乱伦似的。&lt;/p&gt;
&lt;p&gt;不过它仍然是我最熟悉且必须用在游戏开发上的语言，这篇文章用于挑选出一些个人觉得重要的条款/经验/技巧进行记录总结。&lt;br/&gt;文章最后列出一些我看过的C++书籍/博客等，方便参考。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实以前也写过相同的笔记博文，现在用markdown”重置“一下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;h2 id=&quot;多态基类的析构函数应总是public-virtual否则应为protected&quot;&gt;1.多态基类的析构函数应总是public virtual,否则应为protected&lt;/h2&gt;
&lt;p&gt;当要释放多态基类指针指向的对象时，为了按正确顺序析构，必须得借助virtual从而先执行析构派生类再析构基类。&lt;br/&gt;当基类没有多态性质时，可将基类析构函数声明protected，并且也无需耗费使用virtual。&lt;/p&gt;
&lt;h2 id=&quot;编译器会隐式生成默认构造复制构造复制赋值析构c11移动构造c11移动赋值的inline函数&quot;&gt;2.编译器会隐式生成默认构造,复制构造,复制赋值,析构,(C++11)移动构造,(C++11)移动赋值的inline函数&lt;/h2&gt;
&lt;p&gt;当你在代码中用到以上函数时且没有声明该函数时，就会默认生成相应的函数。&lt;br/&gt;特殊的，当你声明了构造函数（无论有无参数），都不会隐式生成默认构造函数。&lt;br/&gt;不过隐式生成的函数比自己手写的函数（即使行为一样）效率要高，因为经过了编译器特殊优化。&lt;/p&gt;
&lt;p&gt;(c++11)当你需要显式禁用生成以上某个函数时,可在声明函数 = delete&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Type(const Type&amp;amp; t) = delete;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(c++11)当你需要显式默认生成以上某个函数时，可在声明函数 = default&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Type(Tpye &amp;amp;&amp;amp; t) = default;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;不要在析构函数抛出异常也尽量避免在构造函数抛出异常&quot;&gt;3.不要在析构函数抛出异常，也尽量避免在构造函数抛出异常&lt;/h2&gt;
&lt;p&gt;析构函数若抛出异常，可能会使析构函数过早结束，从而可能导致一些资源未能正确释放。&lt;br/&gt;构造函数若抛出异常，则无法调用析构函数，这可能导致异常发生前部分资源成功分配，却没能执行析构函数的正确释放行为。&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;不要偏特化模板函数而是选择重载函数&quot;&gt;1. 不要偏特化模板函数，而是选择重载函数。&lt;/h2&gt;
&lt;p&gt;编译器匹配函数时优先选择非模板函数（重载函数），再选择模板函数，最后再选择偏特化模板函数。&lt;br/&gt;当匹配到某个模板函数时，就不会再匹配选择其他模板函数，即使另一个模板函数旗下有更适合的偏特化函数。&lt;br/&gt;所以这很可能导致编译器没有选择你想要的偏特化模板函数。&lt;/p&gt;
&lt;h2 id=&quot;c11不要重载转发引用的函数否则使用其它替代方案&quot;&gt;2.(C++11)不要重载转发引用的函数，否则使用其它替代方案&lt;/h2&gt;
&lt;p&gt;转发引用的函数是C++中最贪婪的函数，容易让需要隐式转换的实参匹配到不希望的转发引用函数。（例如下面）&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;class T&amp;gt;
  void f(T&amp;amp;&amp;amp; value);

void f(int a);

//当使用f(long类型的参数)或者f(short类型的参数)，则不会匹配int版本而是匹配到转发引用的版本&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;替代方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;舍弃重载。换个函数名或者改成传递const T&amp;amp;形参。&lt;/li&gt;
&lt;li&gt;使用更复杂的标签分派或模板限制（不推荐）。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;&lt;h2 id=&quot;c11禁用某个函数时使用-delete而非private&quot;&gt;1.(C++11)禁用某个函数时，使用 = delete而非private&lt;/h2&gt;
&lt;p&gt;原因有4个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;private函数仍需要写定义（即使那是空的实现），&lt;/li&gt;
&lt;li&gt;派生类潜在覆盖禁用函数名的可能性，&lt;/li&gt;
&lt;li&gt;“=delete”语法比private语法更直观体现函数被禁用的特点，&lt;/li&gt;
&lt;li&gt;在编写非类函数的时候，无法提供private属性。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一般 = delete的类函数应为public，因为编译器先检测可访问性再检验禁用性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;c11lambda表达式一般是函数对象特殊地在无捕获时是函数指针&quot;&gt;2.(C++11)lambda表达式一般是函数对象。特殊地，在无捕获时是函数指针。&lt;/h2&gt;
&lt;p&gt;编译器编译lambda表达式时实际上都会对每个表达式生成一种函数对象类型，然后构造出函数对象出来。&lt;br/&gt;特殊地，lambda表达式在无任何捕获时，会被编译成函数，其表达式值为该函数指针（毕竟函数比函数对象更效率）。&lt;br/&gt;因此在一些老旧的C++API只接受函数指针而不接受std::function的时候，可以使用无捕获的lamdba表达式。&lt;/p&gt;
&lt;h2 id=&quot;c11尽可能使用lamada表达式代替stdbind&quot;&gt;3.(C++11)尽可能使用lamada表达式代替std::bind&lt;/h2&gt;
&lt;p&gt;直接举例说明，假设有如下Func函数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void Func(int a, float b)；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们让Func绑定上2.0f作为参数b，转化一个void(int a)的函数对象。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;std::function&amp;lt;void(int)&amp;gt; f;
float b = 2.0f;

//std::bind写法
f = std::bind(Func, std::placeholders::_1, b);
f(100);

//lambda表达式写法
f = [b](int a) {Func(a, b); };
f(100);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到使用std::bind会十分不美观不直观，还得注意占位符位置顺序。&lt;br/&gt;而使用lambda表达式可以让代码变得十分简洁优雅。&lt;/p&gt;
&lt;h2 id=&quot;c11使用lambda表达式时避免默认捕获模式&quot;&gt;4.(C++11)使用lambda表达式时，避免默认捕获模式&lt;/h2&gt;
&lt;p&gt;按引用默认捕获容易造成引用空悬，而显示的引用捕获更能容易提醒我们捕获的是哪个变量的引用，从而更容易理清该引用的生命周期。&lt;br/&gt;按值默认捕获容易让人误解lambda式是自洽的（即不依赖外部）。下面是一个典型例子：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void test() {
   static int a = 0;
   auto func = [=]() {
   return a + 2;
   };
   a++;
   int result = func();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于默认捕获，你以为a是以按值拷贝过去，所以期待result总会会是2。但是实际上你是调用了同一个作用域的静态变量，没有拷贝的行为。&lt;/p&gt;
&lt;p&gt;所以，无论是按值还是引用，都尽量指定变量，而不是用默认捕获。&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;检查new是否失败通常是无意义的&quot;&gt;1.检查new是否失败通常是无意义的。&lt;/h2&gt;
&lt;p&gt;new几乎总是成功的，现代大部分操作系统采取进程的惰式内存分配（即请求内存时不会立即分配内存，当使用时才慢慢吞吞分配）。&lt;br/&gt;所以当使用new时，通常不会立即分配内存，从而无法真正检测到是否内存将会耗尽。&lt;/p&gt;
&lt;h2 id=&quot;尽量避免多次new同一种轻量级类型而是先new一个大区域再分配多次&quot;&gt;2.尽量避免多次new同一种轻量级类型，而是先new一个大区域再分配多次。&lt;/h2&gt;
&lt;p&gt;每次new的时候，实际上还会额外分配出一个存放内存信息的区域，而多次分配内存给轻量级类型时，会造成臃肿的内存信息。&lt;br/&gt;而且在删除这些区域时，很容易造成很多块内存碎片，导致内存利用率不高。&lt;br/&gt;所以应当使用内存池的方式，先new一大块区域，再从区域分配内存给轻量级类型。&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;c11使用emplaceemplace_backemplace_front而不是insertpush_backpush_front&quot;&gt;1.(C++11)使用emplace/emplace_back/emplace_front而不是insert/push_back/push_front&lt;/h2&gt;
&lt;p&gt;emplace 最大的作用是避免产生不必要的临时变量，因为它可以直接在容器相应的位置根据参数来构造变量。&lt;br/&gt;而 insert / push_back / push_front 操作是会先通过参数构造一个临时变量，然后将临时变量移动到容器相应的位置。&lt;/p&gt;
&lt;h2 id=&quot;在遍历容器时删除迭代器需谨慎&quot;&gt;2.在遍历容器时删除迭代器需谨慎&lt;/h2&gt;
&lt;p&gt;顺序式容器删除迭代器会破坏本身和后面的迭代器，节点式容器删除迭代器会破坏本身，导致循环遍历崩溃（循环遍历依赖于容器原有的迭代器）。&lt;/p&gt;
&lt;p&gt;两个值得借鉴的正确做法：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto it = vec.begin();
while (it != vec.end()){
    if (...){
        // 顺序式容器的erase()会返回紧随被删除元素的下一个元素的有效迭代器
        it = vec.erase(it);
    }
    else{
        it++;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto it = list.begin();
while (it != list.end()){
    if (...) {
        t.erase(it++);
    }
    else {
        it++;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;容器的at会检查边界则不检查边界&quot;&gt;3.容器的at()会检查边界，[]则不检查边界&lt;/h2&gt;
&lt;p&gt;STL小细节。另外std::vector和std::bitset的[]提供的是值拷贝，而不是引用。&lt;/p&gt;
&lt;h2 id=&quot;sort的-比较操作符若两者相等则必须返还失败&quot;&gt;4.sort()的&amp;lt; 比较操作符，若两者相等则必须返还失败。&lt;/h2&gt;
&lt;p&gt;STL的sort算法基本是快排，是不稳定的排序。&lt;br/&gt;若比较的两者相等时返还成功，则不稳定排序容易出现死循环，从而导致程序崩溃。&lt;/p&gt;
&lt;h2 id=&quot;永远记住更低的时间复杂度并不意味着更高的效率&quot;&gt;5.永远记住，更低的时间复杂度并不意味着更高的效率&lt;/h2&gt;
&lt;p&gt;STL容器，特别是set,map，有着很多O(logN)的操作速度，但并不意味着是最佳选择，因为这种复杂度表示往往隐藏了常数很大的事实。&lt;/p&gt;
&lt;p&gt;例如说，集合的主流实现是基于红黑树，基于节点存储的，而每次插入/删除节点都意味着调用一次系统分配内存/释放内存函数。这相比vector等矢量容器所有操作仅一次系统分配内存（理想情况来说），实际上就慢了不少。&lt;/p&gt;
&lt;p&gt;此外，矢量容器对CPU缓存更加友好，遍历该种容器容易命中缓存，而节点式容器则相对容易命中失败。&lt;/p&gt;
&lt;p&gt;综合上述，如果要选择一个最适合的容器，那么不要过度信赖时间复杂度，除非你十分彻底的了解STL容器，或对各容器进行多次效率测试。&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;尽可能使用-i-而不是-i&quot;&gt;1.尽可能使用 ++i 而不是 i++&lt;/h2&gt;
&lt;p&gt;这个是老生常谈的C++经典问题，对于int/unsigned等内置类型时，++i与i++似乎在效率上没有区别。&lt;br/&gt;然而在使用迭代器或其他自定义类型时，i++往往还得创建一个额外的副本来用于返还值，而++i则直接返还它本身。&lt;/p&gt;
&lt;h2 id=&quot;在后期遇到性能瓶颈万不得已时才使用inline&quot;&gt;2.在后期遇到性能瓶颈，万不得已时才使用inline&lt;/h2&gt;
&lt;p&gt;现代编译器已经十分智能，很多时候该写成inline的函数编译器会自动帮你inline，不该inline的时候即使你显式写了inline编译器也有可能认为不该inline。&lt;br/&gt;也就是说显式的写出inline只是给编译器一个建议，它不一定会采纳。&lt;br/&gt;因此在开发时不用过早优化，过早考虑inline，而是遇到性能瓶颈时才考虑使用显式写出inline，不过大部分这时候你更应该考虑的是你写的算法效率。&lt;/p&gt;
&lt;h2 id=&quot;尽量不使用dynamic_cast并且禁用rtti&quot;&gt;3.尽量不使用dynamic_cast并且禁用RTTI&lt;/h2&gt;
&lt;p&gt;依靠dynamic_cast的代码往往可以用多态虚函数解决，而且多态虚函数更加优雅。因此，尽可能避免编写dynamic_cast。&lt;br/&gt;另外可以随之禁用与dynamic_cast相关的RTTI特性，禁用该特性可以提升程序效率（每个类少一些臃肿的RTTI信息）。&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;c11若保证异常不会抛出应使用noexpect异常规格否则不要声明异常规格&quot;&gt;1.(C++11)若保证异常不会抛出，应使用noexpect异常规格，否则不要声明异常规格。&lt;/h2&gt;
&lt;p&gt;无声明异常规格，意思是可能抛出任何异常。&lt;br/&gt;相比无声明异常规格的函数，noexpect函数能得到编译器的优化（发生异常时不必解开栈），且能清晰表示自己的无异常保证。&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;c17需要用到任意可变的类型时使用stdanystdvariant而不是union&quot;&gt;1.(C++17)需要用到任意可变的类型时，使用std::any，std::variant而不是union&lt;/h2&gt;
&lt;p&gt;union是从c继承来的特性，它的成员不可以是带构造函数，析构函数，自定义复制构造函数的c++类。&lt;br/&gt;因此最好不要使用union，而是用std::any或std::variant ，目前C++17已引入&amp;lt;any&amp;gt;库和&amp;lt;variant&amp;gt;库。&lt;/p&gt;
&lt;h2 id=&quot;c11auto只能推导出类型型别而decltype能够推导出声明型别&quot;&gt;2.(C++11)auto只能推导出类型型别，而decltype能够推导出声明型别&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int&amp;amp; value = 233;
auto a = value;//auto是int类型
decltype(auto) b = value; //decltype(auto)是int&amp;amp;类型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说auto的推导类型会抛弃引用性质，而decltype能够推导出完整的声明类型。&lt;/p&gt;
&lt;h2 id=&quot;c11使用nullptr而不是null或0&quot;&gt;3.(C++11)使用nullptr而不是NULL或0&lt;/h2&gt;
&lt;p&gt;NULL是C语言遗留的东西，是将宏定义成0的，容易造成指针和整数的二义性。&lt;br/&gt;而nullptr很好的避免了整数的性质。&lt;/p&gt;
&lt;h2 id=&quot;c11使用enum-class语法为枚举类型提供限定范围&quot;&gt;4.(C++11)使用enum class语法为枚举类型提供限定范围&lt;/h2&gt;
&lt;p&gt;C带来的enum语法是允许枚举类进行隐式转换的，潜在造成程序员不希望发生的转换。&lt;br/&gt;而C++11的enum class会阻止隐式转换，需要程序员显示转换&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;enum class Color{Red,Blue,Green};
Color color = Color::Red;
int i = static&amp;lt;int&amp;gt;(color);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;c11只要潜在编译期可计算的函数变量就使用constexpr&quot;&gt;5.(C++11)只要潜在编译期可计算的函数/变量，就使用constexpr&lt;/h2&gt;
&lt;p&gt;constexpr能让一些函数/变量在编译期就可计算，可减少运行期运算。（可视作模板元运算的美化语法）&lt;br/&gt;此外，constexpr如果接受的是运行期变量/参数，则会变成运行期计算。&lt;br/&gt;也就是说它既可用作编译期运算，也可运行期运算，语境作用域比非constexpr更广。&lt;/p&gt;

&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;《C++ Primer Plus》：当初入门C++语言的书籍。&lt;/li&gt;
&lt;li&gt;《C++程序设计语言（特别版）》：C++之父编写的入门教材，但实际上更应该算为介于入门与进阶之间的工具书（用于查询语法）。&lt;/li&gt;
&lt;li&gt;《Effective C++》：C++ 进阶书，深入理解与经验&lt;/li&gt;
&lt;li&gt;《More Effective C++》：C++ 进阶书，深入理解与经验&lt;/li&gt;
&lt;li&gt;《深度探索C++对象模型》：C++ 进阶书，深入理解&lt;/li&gt;
&lt;li&gt;《Expectional C++》：C++ 进阶书，深入理解与经验&lt;/li&gt;
&lt;li&gt;《高速上手 C++11/14/17》：C++11/14/17 入门书，介绍C++11/14/17各项新特性的基础用法，它目前只有电子版本： &lt;a href=&quot;https://github.com/changkun/modern-cpp-tutorial/blob/master/book/zh-cn/toc.md&quot; class=&quot;uri&quot;&gt;https://github.com/changkun/modern-cpp-tutorial/blob/master/book/zh-cn/toc.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Effective Modern C++》：C++11/14 进阶书，介绍C++11/14部分新特性的深入理解与经验。&lt;/li&gt;
&lt;li&gt;《游戏编程精粹 2》：游戏编程综合技术书，有部分章节讲C++的经验。&lt;/li&gt;
&lt;li&gt;《游戏编程精粹 3》：同上。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;C++是非常非常复杂的语言，看的这方面书越多就越觉得自己的无知（例如C++ Boost）。&lt;br/&gt;但是在学习C++的中途也必须认识到，C++是一门工具，不要过多钻C++语言的牛角尖。&lt;br/&gt;谨记：程序员是要成为工程师而不是语言学家。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Sep 2019 17:14:00 +0000</pubDate>
<dc:creator>KillerAery</dc:creator>
<og:description>前言：C++是博大精深的语言，特性复杂得跟北京二环一样，继承乱得跟乱伦似的。 不过它仍然是我最熟悉且必须用在游戏开发上的语言，这篇文章用于挑选出一些个人觉得重要的条款/经验/技巧进行记录总结。 文章最</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/KillerAery/p/11601229.html</dc:identifier>
</item>
<item>
<title>.NET Core使用NPOI导出复杂Word详解 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/11588531.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/11588531.html</guid>
<description>&lt;p&gt;　　最近使用NPOI做了个导出Word文档的功能，关于使用.NET Core 导出Word文档的方式有很多。最终我为什么选择了NPOI来实现了这个功能，首先是NPOI是一个开源，免费且容易上手的第三方框架（并且现在已支持.NET Core，GitHub源码地址：&lt;a href=&quot;https://github.com/tonyqus/npoi&quot;&gt;https://github.com/tonyqus/npoi&lt;/a&gt;）。因为之前使用NPOI导出Execl比较多，这次第一次使用NPOI 来导出Word文档还真没有什么头绪。首先看了下GItHub中的源码有一个简单Word导出的示例，然后在看了网上有很多关于NPOI导出Word文档的案例，发现一个特点网上的好像都差不多，对于我而言网上的这些案例完全能够实现我的这个功能，但是感觉看了网上这些案例对NPOI实例化段落，表格和设置相关样式不太清楚（可能是因为自己笨），并且假如使用网上的方法来实现我的功能的话代码量会比较大，而且感觉代码非常的冗余（我是一个追求代码简洁的人，怎么能够容忍这样的事情发生呢！），因此通过查阅了一些资料和自己的理解，把关于使用NPOI导出Word时所要涉及的一些段落，表格样式做了相关注释，和把段落和表格的创建实例，设置文字、字体、对齐方式都封装了起了（为了少写代码），文章末尾会附上一个完整的案例下载地址。&lt;/p&gt;&lt;p&gt;　　XWPFRun是段落的文本对象，先创建段落对象才能够在段落对象的基础上创建文本对象，并设置相关文本样式。&lt;/p&gt;&lt;div readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        ///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建word文档中的段落对象和设置段落文本的基本样式（字体大小，字体，字体颜色，字体对齐位置）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;document&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;document文档对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fillContent&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;段落第一个文本对象填充的内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;isBold&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否加粗&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fontSize&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;字体大小&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fontFamily&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;字体&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;paragraphAlign&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;段落排列（左对齐，居中，右对齐）&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; XWPFParagraph ParagraphInstanceSetting(XWPFDocument document, &lt;span&gt;string&lt;/span&gt; fillContent, &lt;span&gt;bool&lt;/span&gt; isBold, &lt;span&gt;int&lt;/span&gt; fontSize, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; fontFamily, ParagraphAlignment paragraphAlign,)
        {
            XWPFParagraph paragraph &lt;/span&gt;= document.CreateParagraph();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建段落对象&lt;/span&gt;
            paragraph.Alignment = paragraphAlign;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字显示位置,段落排列（左对齐，居中，右对齐）&lt;/span&gt;
&lt;span&gt;
            XWPFRun xwpfRun &lt;/span&gt;= paragraph.CreateRun();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建段落文本对象&lt;/span&gt;
            xwpfRun.IsBold = isBold;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字加粗&lt;/span&gt;
            xwpfRun.SetText(fillContent);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充内容&lt;/span&gt;
            xwpfRun.FontSize = fontSize;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置文字大小&lt;/span&gt;
            xwpfRun.SetFontFamily(fontFamily, FontCharRange.None); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置标题样式如：（微软雅黑，隶书，楷体）根据自己的需求而定&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; paragraph;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;256&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NPOI.OpenXmlFormats.Wordprocessing;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NPOI.XWPF.UserModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Export.Services
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NpoiWordExportService
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; IHostingEnvironment _environment;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; NpoiWordExportService(IHostingEnvironment iEnvironment)
        {
            _environment &lt;/span&gt;=&lt;span&gt; iEnvironment;
        }

        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 生成word

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;  生成word文档,并保存静态资源文件夹（wwwroot)下的SaveWordFile文件夹中
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;savePath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;保存路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; SaveWordFile(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; savePath)
        {
            savePath &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; currentDate = DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyyMMdd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; checkTime = DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy年MM月dd日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查时间
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文件到静态资源wwwroot,使用绝对路径路径&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; uploadPath = _environment.WebRootPath + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/SaveWordFile/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + currentDate + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;相当于HttpContext.Current.Server.MapPath(&quot;&quot;) &lt;/span&gt;

                &lt;span&gt;string&lt;/span&gt; workFileName = checkTime + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;追逐时光企业员工培训考核统计记录表&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; fileName = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, workFileName, System.Text.Encoding.UTF8);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Directory.Exists(uploadPath))
                {
                    Directory.CreateDirectory(uploadPath);
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过使用文件流，创建文件流对象，向文件流中写入内容，并保存为Word文档格式&lt;/span&gt;
                &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; stream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(Path.Combine(uploadPath, fileName), FileMode.Create, FileAccess.Write))
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建document文档对象对象实例&lt;/span&gt;
                    XWPFDocument document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XWPFDocument();

                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
                     *这里我通过设置公共的Word文档中SetParagraph（段落）实例创建和段落样式格式设置，大大减少了代码的冗余，
                     * 避免每使用一个段落而去创建一次段落实例和设置段落的基本样式
                     *(如下，ParagraphInstanceSetting为段落实例创建和样式设置，后面索引表示为当前是第几行段落,索引从0开始)
                     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本标题&lt;/span&gt;
                    document.SetParagraph(ParagraphInstanceSetting(document, workFileName, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;19&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宋体&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO:这里一行需要显示两个文本&lt;/span&gt;
                    document.SetParagraph(ParagraphInstanceSetting(document, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;编号：20190927101120445887&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宋体&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;true&lt;/span&gt;, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    检查时间：{checkTime}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);


                    document.SetParagraph(ParagraphInstanceSetting(document, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登记机关：企业员工监督检查机构&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宋体&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.LEFT), &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);


                    &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 文档第一个表格对象实例
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文档中的表格对象实例&lt;/span&gt;
                    XWPFTable firstXwpfTable = document.CreateTable(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示的行列数rows:3行,cols:4列&lt;/span&gt;
                    firstXwpfTable.Width = &lt;span&gt;5200&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总宽度&lt;/span&gt;
                    firstXwpfTable.SetColumnWidth(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1300&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置列宽 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    firstXwpfTable.SetColumnWidth(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1100&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置列宽 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    firstXwpfTable.SetColumnWidth(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1400&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置列宽 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    firstXwpfTable.SetColumnWidth(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1400&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置列宽 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Table 表格第一行展示...后面的都是一样，只改变GetRow中的行数&lt;/span&gt;
                    firstXwpfTable.GetRow(&lt;span&gt;0&lt;/span&gt;).GetCell(&lt;span&gt;0&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;企业名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
                    firstXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;).GetCell(&lt;span&gt;1&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;追逐时光&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
                    firstXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;).GetCell(&lt;span&gt;2&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;企业地址&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
                    firstXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;).GetCell(&lt;span&gt;3&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;湖南省-长沙市-岳麓区&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Table 表格第二行&lt;/span&gt;
                    firstXwpfTable.GetRow(&lt;span&gt;1&lt;/span&gt;).GetCell(&lt;span&gt;0&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;联系人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
                    firstXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;).GetCell(&lt;span&gt;1&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小明同学&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
                    firstXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;).GetCell(&lt;span&gt;2&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;联系方式&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
                    firstXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;).GetCell(&lt;span&gt;3&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;151****0456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));


                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Table 表格第三行&lt;/span&gt;
                    firstXwpfTable.GetRow(&lt;span&gt;2&lt;/span&gt;).GetCell(&lt;span&gt;0&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;企业许可证号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
                    firstXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;).GetCell(&lt;span&gt;1&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XXXXX-66666666&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
                    firstXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;).GetCell(&lt;span&gt;2&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;检查次数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
                    firstXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;).GetCell(&lt;span&gt;3&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;本年度检查8次&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));


                    firstXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;).MergeCells(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并3列&lt;/span&gt;
                    firstXwpfTable.GetRow(&lt;span&gt;3&lt;/span&gt;).GetCell(&lt;span&gt;0&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&quot;&lt;/span&gt;, ParagraphAlignment.LEFT, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));

                    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

                    &lt;span&gt;var&lt;/span&gt; checkPeopleNum = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查人数&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; totalScore = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总得分&lt;/span&gt;

                    &lt;span&gt;#region&lt;/span&gt; 文档第二个表格对象实例（遍历表格项）
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文档中的表格对象实例&lt;/span&gt;
                    XWPFTable secoedXwpfTable = document.CreateTable(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示的行列数rows:8行,cols:4列&lt;/span&gt;
                    secoedXwpfTable.Width = &lt;span&gt;5200&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总宽度&lt;/span&gt;
                    secoedXwpfTable.SetColumnWidth(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1300&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置列宽 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    secoedXwpfTable.SetColumnWidth(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1100&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置列宽 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    secoedXwpfTable.SetColumnWidth(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1400&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置列宽 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    secoedXwpfTable.SetColumnWidth(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1400&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置列宽 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历表格标题&lt;/span&gt;
                    secoedXwpfTable.GetRow(&lt;span&gt;0&lt;/span&gt;).GetCell(&lt;span&gt;0&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;员工姓名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
                    secoedXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;).GetCell(&lt;span&gt;1&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;性别&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
                    secoedXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;).GetCell(&lt;span&gt;2&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年龄&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
                    secoedXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;).GetCell(&lt;span&gt;3&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;综合评分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历四条数据&lt;/span&gt;
                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;)
                    {
                        secoedXwpfTable.GetRow(i).GetCell(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + i + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
                        secoedXwpfTable.GetRow(i).GetCell(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
                        secoedXwpfTable.GetRow(i).GetCell(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;20&lt;/span&gt; + i + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;岁&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
                        secoedXwpfTable.GetRow(i).GetCell(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, firstXwpfTable, &lt;span&gt;90&lt;/span&gt; + i + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;分&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));

                        checkPeopleNum&lt;/span&gt;++&lt;span&gt;;
                        totalScore &lt;/span&gt;+= &lt;span&gt;90&lt;/span&gt; +&lt;span&gt; i;
                    }

                    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

                    &lt;span&gt;#region&lt;/span&gt; 文档第三个表格对象实例
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文档中的表格对象实例&lt;/span&gt;
                    XWPFTable thirdXwpfTable = document.CreateTable(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示的行列数rows:5行,cols:4列&lt;/span&gt;
                    thirdXwpfTable.Width = &lt;span&gt;5200&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总宽度&lt;/span&gt;
                    thirdXwpfTable.SetColumnWidth(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1300&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置列宽 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    thirdXwpfTable.SetColumnWidth(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1100&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置列宽 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    thirdXwpfTable.SetColumnWidth(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1400&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置列宽 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    thirdXwpfTable.SetColumnWidth(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1400&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置列宽 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Table 表格第一行，后面的合并3列(注意关于表格中行合并问题，先合并，后填充内容)&lt;/span&gt;
                    thirdXwpfTable.GetRow(&lt;span&gt;0&lt;/span&gt;).MergeCells(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从第一列起,合并3列&lt;/span&gt;
                    thirdXwpfTable.GetRow(&lt;span&gt;0&lt;/span&gt;).GetCell(&lt;span&gt;0&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, thirdXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;检查内容: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                        $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;于{checkTime}下午检查了追逐时光企业员工培训考核并对员工的相关信息进行了相关统计，统计结果如下：                                                                                                                                                                                                                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
                        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-------------------------------------------------------------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;
                        $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;共对该企业（{checkPeopleNum}）人进行了培训考核，培训考核总得分为（{totalScore}）分。 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;&quot;&quot;&lt;/span&gt;, ParagraphAlignment.LEFT, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));


                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Table 表格第二行&lt;/span&gt;
                    thirdXwpfTable.GetRow(&lt;span&gt;1&lt;/span&gt;).GetCell(&lt;span&gt;0&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, thirdXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;检查结果: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
                    thirdXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;).MergeCells(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从第二列起，合并三列&lt;/span&gt;
                    thirdXwpfTable.GetRow(&lt;span&gt;1&lt;/span&gt;).GetCell(&lt;span&gt;1&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, thirdXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该企业非常优秀，坚持每天学习打卡，具有蓬勃向上的活力。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.LEFT, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Table 表格第三行&lt;/span&gt;
                    thirdXwpfTable.GetRow(&lt;span&gt;2&lt;/span&gt;).GetCell(&lt;span&gt;0&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, thirdXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;处理结果: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.CENTER, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
                    thirdXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;).MergeCells(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
                    thirdXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;).GetCell(&lt;span&gt;1&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, thirdXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;通过检查，评分为优秀！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.LEFT, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Table 表格第四行，后面的合并3列(注意关于表格中行合并问题，先合并，后填充内容),额外说明&lt;/span&gt;
                    thirdXwpfTable.GetRow(&lt;span&gt;3&lt;/span&gt;).MergeCells(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并3列&lt;/span&gt;
                    thirdXwpfTable.GetRow(&lt;span&gt;3&lt;/span&gt;).GetCell(&lt;span&gt;0&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, thirdXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;备注说明: 记住，坚持就是胜利，永远保持一种求知，好问的心理！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.LEFT, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Table 表格第五行&lt;/span&gt;
                    thirdXwpfTable.GetRow(&lt;span&gt;4&lt;/span&gt;).MergeCells(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                    thirdXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;).GetCell(&lt;span&gt;0&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, thirdXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;                                                                                                                                                                                                 检查人员签名：              年 月 日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.LEFT, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
                    thirdXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;).MergeCells(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

                    thirdXwpfTable.GetRow(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;).GetCell(&lt;span&gt;1&lt;/span&gt;).SetParagraph(SetTableParagraphInstanceSetting(document, thirdXwpfTable, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;                                                                                                                                                                                                 企业法人签名：              年 月 日&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ParagraphAlignment.LEFT, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));


                    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向文档流中写入内容，生成word&lt;/span&gt;
&lt;span&gt;                    document.Write(stream);

                    savePath &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/SaveWordFile/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + currentDate + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; fileName;

                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ignore&lt;/span&gt;
                savePath =&lt;span&gt; ex.Message;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }


        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建word文档中的段落对象和设置段落文本的基本样式（字体大小，字体，字体颜色，字体对齐位置）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;document&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;document文档对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fillContent&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;段落第一个文本对象填充的内容&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;isBold&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否加粗&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fontSize&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;字体大小&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fontFamily&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;字体&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;paragraphAlign&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;段落排列（左对齐，居中，右对齐）&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;isStatement&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否在同一段落创建第二个文本对象（解决同一段落里面需要填充两个或者多个文本值的情况，多个文本需要自己拓展，现在最多支持两个）&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;secondFillContent&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;第二次声明的文本对象填充的内容，样式与第一次的一致&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; XWPFParagraph ParagraphInstanceSetting(XWPFDocument document, &lt;span&gt;string&lt;/span&gt; fillContent, &lt;span&gt;bool&lt;/span&gt; isBold, &lt;span&gt;int&lt;/span&gt; fontSize, &lt;span&gt;string&lt;/span&gt; fontFamily, ParagraphAlignment paragraphAlign, &lt;span&gt;bool&lt;/span&gt; isStatement = &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt; secondFillContent = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            XWPFParagraph paragraph &lt;/span&gt;= document.CreateParagraph();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建段落对象&lt;/span&gt;
            paragraph.Alignment = paragraphAlign;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字显示位置,段落排列（左对齐，居中，右对齐）&lt;/span&gt;
&lt;span&gt;
            XWPFRun xwpfRun &lt;/span&gt;= paragraph.CreateRun();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建段落文本对象&lt;/span&gt;
            xwpfRun.IsBold = isBold;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字加粗&lt;/span&gt;
            xwpfRun.SetText(fillContent);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充内容&lt;/span&gt;
            xwpfRun.FontSize = fontSize;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置文字大小&lt;/span&gt;
            xwpfRun.SetFontFamily(fontFamily, FontCharRange.None); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置标题样式如：（微软雅黑，隶书，楷体）根据自己的需求而定&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isStatement)
            {
                XWPFRun secondxwpfRun &lt;/span&gt;= paragraph.CreateRun();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建段落文本对象&lt;/span&gt;
                secondxwpfRun.IsBold = isBold;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字加粗&lt;/span&gt;
                secondxwpfRun.SetText(secondFillContent);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充内容&lt;/span&gt;
                secondxwpfRun.FontSize = fontSize;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置文字大小&lt;/span&gt;
                secondxwpfRun.SetFontFamily(fontFamily, FontCharRange.None); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置标题样式如：（微软雅黑，隶书，楷体）根据自己的需求而定&lt;/span&gt;
&lt;span&gt;            }


            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; paragraph;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;  
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 创建Word文档中表格段落实例和设置表格段落文本的基本样式（字体大小，字体，字体颜色，字体对齐位置）
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;  
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;document&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;document文档对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;  
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;table&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表格对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;  
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fillContent&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;要填充的文字&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;  
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;paragraphAlign&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;段落排列（左对齐，居中，右对齐）&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;rowsHeight&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;设置文本位置（设置两行之间的行间），从而实现table的高度设置效果  &lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;isBold&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否加粗（true加粗，false不加粗）&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;fontSize&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;字体大小&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;  
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; XWPFParagraph SetTableParagraphInstanceSetting(XWPFDocument document, XWPFTable table, &lt;span&gt;string&lt;/span&gt; fillContent, ParagraphAlignment paragraphAlign, &lt;span&gt;int&lt;/span&gt; rowsHeight, &lt;span&gt;bool&lt;/span&gt; isBold, &lt;span&gt;int&lt;/span&gt; fontSize = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; para = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CT_P();
            XWPFParagraph paragraph &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; XWPFParagraph(para, table.Body);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建表格中的段落对象&lt;/span&gt;
            paragraph.Alignment = paragraphAlign;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文字显示位置,段落排列（左对齐，居中，右对齐）&lt;/span&gt;
&lt;span&gt;
            XWPFRun xwpfRun &lt;/span&gt;= paragraph.CreateRun();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建段落文本对象&lt;/span&gt;
&lt;span&gt;            xwpfRun.SetText(fillContent);
            xwpfRun.FontSize &lt;/span&gt;= fontSize;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体大小&lt;/span&gt;
            xwpfRun.IsBold = isBold;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否加粗&lt;/span&gt;
            xwpfRun.SetFontFamily(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宋体&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, FontCharRange.None);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置字体（如：微软雅黑,华文楷体,宋体）&lt;/span&gt;
            xwpfRun.SetTextPosition(rowsHeight);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置文本位置（设置两行之间的行间），从而实现table的高度设置效果 &lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; paragraph;
        }

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;


    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;　　写到最后我只想说我太难了，为了实现我想要的这个样式，通过不断的查阅资料，理解NPOI中的段落，文本基本属性。最终在我生成第22个word时，总算是达到了我要的效果。这里我将自己在网上查阅的一些资料和自己的实践心得分享给大家，希望能够帮到大家，别忘了给我star哟。&lt;/p&gt;</description>
<pubDate>Fri, 27 Sep 2019 16:36:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>前言： 最近使用NPOI做了个导出Word文档的功能，关于使用.NET Core 导出Word文档的方式有很多。最终我为什么选择了NPOI来实现了这个功能，首先是NPOI是一个开源，免费且容易上手的第</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/11588531.html</dc:identifier>
</item>
<item>
<title>7.Sentinel源码分析—Sentinel是怎么和控制台通信的？ - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/11601129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/11601129.html</guid>
<description>&lt;p&gt;这里会介绍：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Sentinel会使用多线程的方式实现一个类Reactor的IO模型&lt;/li&gt;
&lt;li&gt;Sentinel会使用心跳检测来观察控制台是否正常&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Sentinel源码解析系列：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11439993.html&quot;&gt;1.Sentinel源码分析—FlowRuleManager加载规则做了什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11451557.html&quot;&gt;2. Sentinel源码分析—Sentinel是如何进行流量统计的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11489128.html&quot;&gt;3. Sentinel源码分析— QPS流量控制是如何实现的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11517918.html&quot;&gt;4.Sentinel源码分析— Sentinel是如何做到降级的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11537947.html&quot;&gt;5.Sentinel源码分析—Sentinel如何实现自适应限流？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11569740.html&quot;&gt;6.Sentinel源码分析—Sentinel是如何动态加载配置限流的？&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;在看我的这篇文章之前大家可以先看一下官方的这篇文章：https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0。介绍了控制台怎么使用，以及客户端要怎么设置才能被收集数据。&lt;/p&gt;
&lt;p&gt;客户端会在InitExecutor调用doInit方法中与控制台建立通信，所以我们直接看doInit方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;InitExecutor#doInit&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void doInit() {
    //InitExecutor只会初始化一次，并且初始化失败会退出
    if (!initialized.compareAndSet(false, true)) {
        return;
    }
    try {
        //通过spi加载InitFunc子类
        ServiceLoader&amp;lt;InitFunc&amp;gt; loader = ServiceLoader.load(InitFunc.class);
        List&amp;lt;OrderWrapper&amp;gt; initList = new ArrayList&amp;lt;OrderWrapper&amp;gt;();
        for (InitFunc initFunc : loader) {
            RecordLog.info(&quot;[InitExecutor] Found init func: &quot; + initFunc.getClass().getCanonicalName());
            //给所有的initFunc排序，按@InitOrder从小到大进行排序
            //然后封装成OrderWrapper对象
            insertSorted(initList, initFunc);
        }
        for (OrderWrapper w : initList) {
            w.func.init();
            RecordLog.info(String.format(&quot;[InitExecutor] Executing %s with order %d&quot;,
                w.func.getClass().getCanonicalName(), w.order));
        }
    } catch (Exception ex) {
        RecordLog.warn(&quot;[InitExecutor] WARN: Initialization failed&quot;, ex);
        ex.printStackTrace();
    } catch (Error error) {
        RecordLog.warn(&quot;[InitExecutor] ERROR: Initialization failed with fatal error&quot;, error);
        error.printStackTrace();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为这里我们引入了&lt;code&gt;sentinel-transport-simple-http&lt;/code&gt;模块，所以使用spi加载InitFunc的子类的时候会加载三个子类实例，分别是：CommandCenterInitFunc、HeartbeatSenderInitFunc、MetricCallbackInit。&lt;br/&gt;然后会遍历loader，根据@InitOrder的大小进行排序，并封装成OrderWrapper放入到initList中。&lt;br/&gt;所以initList里面的对象顺序是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;CommandCenterInitFunc&lt;/li&gt;
&lt;li&gt;HeartbeatSenderInitFunc&lt;/li&gt;
&lt;li&gt;MetricCallbackInit&lt;br/&gt;然后遍历initList依次调用init方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以下面我们来看一下这三个实现类的init方法做了什么：&lt;/p&gt;
&lt;h4 id=&quot;commandcenterinitfunc&quot;&gt;CommandCenterInitFunc&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;CommandCenterInitFunc#init&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void init() throws Exception {
    //获取commandCenter对象
    CommandCenter commandCenter = CommandCenterProvider.getCommandCenter();

    if (commandCenter == null) {
        RecordLog.warn(&quot;[CommandCenterInitFunc] Cannot resolve CommandCenter&quot;);
        return;
    }
    //调用SimpleHttpCommandCenter的beforeStart方法
    //用来设置CommandHandler的实现类
    commandCenter.beforeStart();
    commandCenter.start();
    RecordLog.info(&quot;[CommandCenterInit] Starting command center: &quot;
            + commandCenter.getClass().getCanonicalName());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法里面的所有操作都是针对CommandCenter来进行的，所以我们先来看看CommandCenterProvider这个类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CommandCenterProvider&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static {
    //初始化commandCenter对象
    resolveInstance();
}

private static void resolveInstance() {
    //获取SpiOrder更大的子类实现类
    CommandCenter resolveCommandCenter = SpiLoader.loadHighestPriorityInstance(CommandCenter.class);

    if (resolveCommandCenter == null) {
        RecordLog.warn(&quot;[CommandCenterProvider] WARN: No existing CommandCenter found&quot;);
    } else {
        commandCenter = resolveCommandCenter;
        RecordLog.info(&quot;[CommandCenterProvider] CommandCenter resolved: &quot; + resolveCommandCenter.getClass()
            .getCanonicalName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CommandCenterProvider会在首次初始化的时候调用resolveInstance方法。在resolveInstance方法里面会调用&lt;code&gt;SpiLoader.loadHighestPriorityInstance&lt;/code&gt;来获取CommandCenter，这里获取的是SimpleHttpCommandCenter这个实例，loadHighestPriorityInstance方法具体的实现非常简单，我就不去分析了。&lt;br/&gt;然后将commandCenter赋值SimpleHttpCommandCenter实例。&lt;/p&gt;
&lt;p&gt;所以&lt;code&gt;CommandCenterProvider.getCommandCenter()&lt;/code&gt;方法返回的是SimpleHttpCommandCenter实例。&lt;/p&gt;
&lt;p&gt;然后调用SimpleHttpCommandCenter的beforeStart方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SimpleHttpCommandCenter#beforeStart&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void beforeStart() throws Exception {
    // Register handlers
    //调用CommandHandlerProvider的namedHandlers方法
    //获取CommandHandler的spi中设置的实现类
    Map&amp;lt;String, CommandHandler&amp;gt; handlers = CommandHandlerProvider.getInstance().namedHandlers();
    //将handlers中的数据设置到handlerMap中
    registerCommands(handlers);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法首先会调用CommandHandlerProvider的namedHandlers中获取所有的CommandHandler实现类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CommandHandlerProvider#namedHandlers&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final ServiceLoader&amp;lt;CommandHandler&amp;gt; serviceLoader = ServiceLoader.load(CommandHandler.class);

public Map&amp;lt;String, CommandHandler&amp;gt; namedHandlers() {
    Map&amp;lt;String, CommandHandler&amp;gt; map = new HashMap&amp;lt;String, CommandHandler&amp;gt;();
    for (CommandHandler handler : serviceLoader) {
        //获取实现类CommandMapping注解的name属性
        String name = parseCommandName(handler);
        if (!StringUtil.isEmpty(name)) {
            map.put(name, handler);
        }
    }
    return map;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类会通过spi先加载CommandHandler的实现类，然后将实现类按注解上面的name属性放入到map里面去。&lt;br/&gt;CommandHandler的实现类是用来和控制台进行交互的处理类，负责处理。&lt;br/&gt;这也是策略模式的一种应用，根据map里面的不同策略来做不同的处理，例如SendMetricCommandHandler是用来统计调用信息然后发送给控制台用的，ModifyRulesCommandHandler是用来做实时修改限流策略的处理的等等。&lt;/p&gt;
&lt;p&gt;然后我们再回到CommandCenterInitFunc中，继续往下走，调用&lt;code&gt;commandCenter.start()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SimpleHttpCommandCenter#start&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void start() throws Exception {
    //获取当前机器的cpu线程数
    int nThreads = Runtime.getRuntime().availableProcessors();
    //创建一个cpu线程数大小的固定线程池，用来做业务线程池用
    this.bizExecutor = new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,
        new ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(10),
        new NamedThreadFactory(&quot;sentinel-command-center-service-executor&quot;),
        new RejectedExecutionHandler() {
            @Override
            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
                CommandCenterLog.info(&quot;EventTask rejected&quot;);
                throw new RejectedExecutionException();
            }
        });

    Runnable serverInitTask = new Runnable() {
        int port;

        {
            try {
                //获取port
                port = Integer.parseInt(TransportConfig.getPort());
            } catch (Exception e) {
                port = DEFAULT_PORT;
            }
        }

        @Override
        public void run() {
            boolean success = false;
            //创建一个ServerSocket
            ServerSocket serverSocket = getServerSocketFromBasePort(port);

            if (serverSocket != null) {
                CommandCenterLog.info(&quot;[CommandCenter] Begin listening at port &quot; + serverSocket.getLocalPort());
                socketReference = serverSocket;
                executor.submit(new ServerThread(serverSocket));
                success = true;
                port = serverSocket.getLocalPort();
            } else {
                CommandCenterLog.info(&quot;[CommandCenter] chooses port fail, http command center will not work&quot;);
            }

            if (!success) {
                port = PORT_UNINITIALIZED;
            }

            TransportConfig.setRuntimePort(port);
            //关闭线程池
            executor.shutdown();
        }

    };

    new Thread(serverInitTask).start();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;这个方法会创建一个固定大小的业务线程池&lt;/li&gt;
&lt;li&gt;创建一个serverInitTask，里面负责建立serverSocket然后用executor去创建一个ServerThread异步执行serverSocket&lt;/li&gt;
&lt;li&gt;executor用完之后会在serverInitTask里面调用executor的shutdown方法去关闭线程池&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中executor是一个单线程的线程池：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private ExecutorService executor = Executors.newSingleThreadExecutor(
    new NamedThreadFactory(&quot;sentinel-command-center-executor&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ServerThread是SimpleHttpCommandCenter的内部类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void run() {
    while (true) {
        Socket socket = null;
        try {
              //建立连接
            socket = this.serverSocket.accept();
              //默认的超时时间是3s
            setSocketSoTimeout(socket);
            HttpEventTask eventTask = new HttpEventTask(socket);
            //使用业务线程异步处理
            bizExecutor.submit(eventTask);
        } catch (Exception e) {
            CommandCenterLog.info(&quot;Server error&quot;, e);
            if (socket != null) {
                try {
                    socket.close();
                } catch (Exception e1) {
                    CommandCenterLog.info(&quot;Error when closing an opened socket&quot;, e1);
                }
            }
            try {
                // In case of infinite log.
                Thread.sleep(10);
            } catch (InterruptedException e1) {
                // Indicates the task should stop.
                break;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;run方法会使用构造器传入的serverSocket建立连接后设置超时时间，封装成HttpEventTask类，然后使用上面创建的bizExecutor异步执行任务。&lt;/p&gt;
&lt;p&gt;HttpEventTask是Runnable的实现类，所以调用bizExecutor的submit的时候会调用其中的run方法使用socket与控制台进行交互。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HttpEventTask#run&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void run() {
          ....
        // Validate the target command.
        //获取commandName
        String commandName = HttpCommandUtils.getTarget(request);
        if (StringUtil.isBlank(commandName)) {
            badRequest(printWriter, &quot;Invalid command&quot;);
            return;
        }
        // Find the matching command handler.
        //根据commandName获取处理器名字
        CommandHandler&amp;lt;?&amp;gt; commandHandler = SimpleHttpCommandCenter.getHandler(commandName);
        if (commandHandler != null) {
            //调用处理器结果，然后返回给控制台
            CommandResponse&amp;lt;?&amp;gt; response = commandHandler.handle(request);
            handleResponse(response, printWriter, outputStream);
        }  
          ....
    } catch (Throwable e) {
        ....
    } finally {
        ....
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HttpEventTask的run方法很长，但是很多都是有关输入输出流的，我们不关心，所以省略。只需要知道会把request请求最后转换成一个控制台发过来的指令，然后通过SimpleHttpCommandCenter调用getHandler得到处理器，然后处理数据就行了。&lt;/p&gt;
&lt;p&gt;所以这个整个的处理流程就是：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201909/1204119-20190928001609570-379493113.png&quot;/&gt;&lt;br/&gt;通过这样的一个处理流程，然后实现了类似reactor的一个处理流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201909/1204119-20190928001637571-1800422911.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SimpleHttpCommandCenter#getHandler&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static CommandHandler getHandler(String commandName) {
    return handlerMap.get(commandName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;handlerMap里面的数据是通过前面我们分析的调用beforeStart方法设置进来的。&lt;/p&gt;
&lt;p&gt;然后通过commandName获取对应的控制台，例如：控制台发送过来metric指令，那么就会对应的调用SendMetricCommandHandler的handle方法来处理控制台的指令。&lt;/p&gt;
&lt;p&gt;我们来看看SendMetricCommandHandler是怎么处理返回统计数据的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SendMetricCommandHandler#handle&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public CommandResponse&amp;lt;String&amp;gt; handle(CommandRequest request) {
    // Note: not thread-safe.
    if (searcher == null) {
        synchronized (lock) {
            //获取应用名
            String appName = SentinelConfig.getAppName();
            if (appName == null) {
                appName = &quot;&quot;;
            }
            if (searcher == null) {
                //用来找metric文件，
                searcher = new MetricSearcher(MetricWriter.METRIC_BASE_DIR,
                    MetricWriter.formMetricFileName(appName, PidUtil.getPid()));
            }
        }
    }
    //获取请求的开始结束时间和最大的行数
    String startTimeStr = request.getParam(&quot;startTime&quot;);
    String endTimeStr = request.getParam(&quot;endTime&quot;);
    String maxLinesStr = request.getParam(&quot;maxLines&quot;);
    //用来确定资源
    String identity = request.getParam(&quot;identity&quot;);
    long startTime = -1;
    int maxLines = 6000;
    if (StringUtil.isNotBlank(startTimeStr)) {
        startTime = Long.parseLong(startTimeStr);
    } else {
        return CommandResponse.ofSuccess(&quot;&quot;);
    }
    List&amp;lt;MetricNode&amp;gt; list;
    try {
        // Find by end time if set.
        if (StringUtil.isNotBlank(endTimeStr)) {
            long endTime = Long.parseLong(endTimeStr);
            //根据开始结束时间找到统计数据
            list = searcher.findByTimeAndResource(startTime, endTime, identity);
        } else {
            if (StringUtil.isNotBlank(maxLinesStr)) {
                maxLines = Integer.parseInt(maxLinesStr);
            }
            maxLines = Math.min(maxLines, 12000);
            list = searcher.find(startTime, maxLines);
        }
    } catch (Exception ex) {
        return CommandResponse.ofFailure(new RuntimeException(&quot;Error when retrieving metrics&quot;, ex));
    }
    if (list == null) {
        list = new ArrayList&amp;lt;&amp;gt;();
    }
    //如果identity为空就加入CPU负载和系统负载
    if (StringUtil.isBlank(identity)) {
        addCpuUsageAndLoad(list);
    }
    StringBuilder sb = new StringBuilder();
    for (MetricNode node : list) {
        sb.append(node.toThinString()).append(&quot;\n&quot;);
    }
    return CommandResponse.ofSuccess(sb.toString());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11439993.html&quot;&gt;1.Sentinel源码分析—FlowRuleManager加载规则做了什么？&lt;/a&gt;里介绍了Metric统计信息会在MetricTimerListener的run方法中定时写入文件中去。&lt;/p&gt;
&lt;p&gt;所以handle方法里面主要是如何根据请求的开始结束时间，资源名来获取磁盘的文件，然后返回磁盘的统计信息，并记录一下当前的统计信息，防止重复发送统计数据到控制台。&lt;/p&gt;
&lt;h4 id=&quot;heartbeatsenderinitfunc&quot;&gt;HeartbeatSenderInitFunc&lt;/h4&gt;
&lt;p&gt;HeartbeatSenderInitFunc主要是用来做心跳线程使用的，定期的和控制台进行心跳连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HeartbeatSenderInitFunc#init&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void init() {
    //获取HeartbeatSender的实现类
    HeartbeatSender sender = HeartbeatSenderProvider.getHeartbeatSender();
    if (sender == null) {
        RecordLog.warn(&quot;[HeartbeatSenderInitFunc] WARN: No HeartbeatSender loaded&quot;);
        return;
    }
    //创建一个corepoolsize为2，maximumPoolSize为最大的线程池
    initSchedulerIfNeeded();
    //获取心跳间隔时间，默认10s
    long interval = retrieveInterval(sender);
    //设置间隔心跳时间
    setIntervalIfNotExists(interval);
    //开启一个定时任务，每隔interval时间发送一个心跳
    scheduleHeartbeatTask(sender, interval);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;首先会调用HeartbeatSenderProvider.getHeartbeatSender方法，里面会根据spi创建实例，返回一个SimpleHttpHeartbeatSender实例。&lt;/li&gt;
&lt;li&gt;调用initSchedulerIfNeeded方法创建一个corepoolsize为2的线程池&lt;/li&gt;
&lt;li&gt;获取心跳间隔时间，如果没有设置，那么是10s&lt;/li&gt;
&lt;li&gt;调用scheduleHeartbeatTask方法开启一个定时线程调用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们来看看scheduleHeartbeatTask方法：&lt;br/&gt;&lt;strong&gt;HeartbeatSenderInitFunc#scheduleHeartbeatTask&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void scheduleHeartbeatTask(/*@NonNull*/ final HeartbeatSender sender, /*@Valid*/ long interval) {
    pool.scheduleAtFixedRate(new Runnable() {
        @Override
        public void run() {
            try {
                sender.sendHeartbeat();
            } catch (Throwable e) {
                RecordLog.warn(&quot;[HeartbeatSender] Send heartbeat error&quot;, e);
            }
        }
    }, 5000, interval, TimeUnit.MILLISECONDS);
    RecordLog.info(&quot;[HeartbeatSenderInit] HeartbeatSender started: &quot;
        + sender.getClass().getCanonicalName());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认的情况，创建的这个定时任务会每隔10s调用一次SimpleHttpHeartbeatSender的sendHeartbeat方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SimpleHttpHeartbeatSender#sendHeartbeat&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean sendHeartbeat() throws Exception {
    if (TransportConfig.getRuntimePort() &amp;lt;= 0) {
        RecordLog.info(&quot;[SimpleHttpHeartbeatSender] Runtime port not initialized, won't send heartbeat&quot;);
        return false;
    }
    //获取控制台的ip和端口等信息
    InetSocketAddress addr = getAvailableAddress();
    if (addr == null) {
        return false;
    }
    //设置http调用的ip和端口，还有访问的url
    SimpleHttpRequest request = new SimpleHttpRequest(addr, HEARTBEAT_PATH);
    //获取版本号，端口等信息
    request.setParams(heartBeat.generateCurrentMessage());
    try {
        //发送post请求
        SimpleHttpResponse response = httpClient.post(request);
        if (response.getStatusCode() == OK_STATUS) {
            return true;
        }
    } catch (Exception e) {
        RecordLog.warn(&quot;[SimpleHttpHeartbeatSender] Failed to send heartbeat to &quot; + addr + &quot; : &quot;, e);
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个心跳检测的方法就写的很简单了，通过Dcsp.sentinel.dashboard.server预先设置好的ip和端口号发送post请求到控制台，然后检测是否返回200，如果是则说明控制台正常，否则进行异常处理。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Sep 2019 16:18:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>这里会介绍： 1. Sentinel会使用多线程的方式实现一个类Reactor的IO模型 2. Sentinel会使用心跳检测来观察控制台是否正常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/11601129.html</dc:identifier>
</item>
<item>
<title>用.NET做动态域名解析 - .NET骚操作</title>
<link>http://www.cnblogs.com/sdflysha/p/20190927-dotnet-dynamic-domain-resolution.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdflysha/p/20190927-dotnet-dynamic-domain-resolution.html</guid>
<description>&lt;p&gt;动态域名解析，或&lt;code&gt;DNSR&lt;/code&gt;，通常用于解析&lt;code&gt;IP&lt;/code&gt;地址经常变化的域名。电信网络提供了公网&lt;code&gt;IP&lt;/code&gt;，给广大程序员远程办公、内容分享等方面带来了极大的便利。但公网&lt;code&gt;IP&lt;/code&gt;是动态的，它会经常变化，因此通过&lt;code&gt;IP&lt;/code&gt;的方式访问非常不友好。因此就需要引入“花生壳”等动态域名解析工具，这类解析工具限制很多，如免费版只能使用指定的二级域名，解析的各类很少，域名数量有限制等等。&lt;/p&gt;
&lt;p&gt;还好我们有&lt;code&gt;.NET&lt;/code&gt;！&lt;small&gt;（和阿里云）&lt;/small&gt;通过简短的几行&lt;code&gt;.NET&lt;/code&gt;代码，即可轻松完成动态域名解析。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;第一步 知道自己的&lt;code&gt;IP&lt;/code&gt;地址&lt;/li&gt;
&lt;li&gt;第二步 更新&lt;code&gt;DNS&lt;/code&gt;的&lt;code&gt;IP&lt;/code&gt;解析值&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;获取自己的ip地址&quot;&gt;获取自己的&lt;code&gt;IP&lt;/code&gt;地址&lt;/h2&gt;
&lt;p&gt;现在网上有许多网站、服务或者&lt;code&gt;API&lt;/code&gt;可以快速获取自己的&lt;code&gt;IP&lt;/code&gt;地址，如随手在百度上可以找到&lt;a href=&quot;http://www.ip138.com/&quot; class=&quot;uri&quot;&gt;http://www.ip138.com/&lt;/a&gt;，国外还有&lt;a href=&quot;https://www.ipify.org/&quot; class=&quot;uri&quot;&gt;https://www.ipify.org/&lt;/a&gt;等服务，都挺好用。这些服务&lt;code&gt;.NET&lt;/code&gt;也可以做，只需几行简短的代码，然后部署到服务器上：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;async Task Main()
{
    await WebHost
        .CreateDefaultBuilder()
        .UseStartup&amp;lt;UserQuery&amp;gt;()
        .Build()
        .RunAsync();
}

public void ConfigureServices(IServiceCollection services) {}

public void Configure(IApplicationBuilder app) =&amp;gt; 
    app.Run(ctx =&amp;gt; ctx.Response.WriteAsync(ctx.Connection.RemoteIpAddress.ToString()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我已经将该代码部署到了服务器上，域名是：&lt;a href=&quot;https://echo-ip.starworks.cc&quot; class=&quot;uri&quot;&gt;https://echo-ip.starworks.cc&lt;/a&gt;，可供有需要的朋友测试。&lt;/p&gt;
&lt;h2 id=&quot;更新dns解析值&quot;&gt;更新&lt;code&gt;DNS&lt;/code&gt;解析值&lt;/h2&gt;
&lt;p&gt;各大域名网站都有自己的&lt;code&gt;DNS&lt;/code&gt;解析&lt;code&gt;API&lt;/code&gt;或者&lt;code&gt;SDK&lt;/code&gt;，阿里云也不例外，我可以通过几行简短的&lt;code&gt;C#&lt;/code&gt;代码即可更新&lt;code&gt;DNS&lt;/code&gt;解析值：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// 安装NuGet包：aliyun-net-sdk-alidns
string currentIp = new WebClient().DownloadString(&quot;https://echo-ip.starworks.cc/&quot;);
var client = new DefaultAcsClient(DefaultProfile.GetProfile(&quot;&quot;, Util.GetPassword(&quot;aliyun_dns_access_key&quot;), Util.GetPassword(&quot;aliyun_dns_secret_key&quot;)));
var domainRecords = client.GetAcsResponse(new DescribeDomainRecordsRequest 
{ 
    DomainName = &quot;starworks.cc&quot;, 
    RRKeyWord = &quot;cool&quot;, 
}).DomainRecords;

DescribeDomainRecordsResponse.DescribeDomainRecords_Record homeRecord = domainRecords.First(x =&amp;gt; x.RR == &quot;cool&quot;);
if (homeRecord._Value != currentIp)
{
    client.GetAcsResponse(new UpdateDomainRecordRequest
    {
        RecordId = homeRecord.RecordId,
        RR = homeRecord.RR,
        Type = homeRecord.Type,
        _Value = currentIp,
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后将该脚本添加到电脑的开机启动项，这样每次开机时，即可确保我的&lt;code&gt;cool.starworks.cc&lt;/code&gt;为最新的本地&lt;code&gt;IP&lt;/code&gt;了。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;阿里云的&lt;code&gt;SDK&lt;/code&gt;设计有点取巧了，客户端&lt;code&gt;DefaultAcsClient&lt;/code&gt;只有一个方法：&lt;code&gt;GetAcsResponse&amp;lt;T&amp;gt;(T request)&lt;/code&gt;，这样一来不太方便，可以调用哪些方法不能一目了然，二来还会让调用方感觉很迷惑，明明是更新操作，为什么要调用&lt;code&gt;Get&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;与此相比，腾讯云提供的&lt;code&gt;SDK&lt;/code&gt;就人性化很多，虽然我的域名绑定在阿里云上。😂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;不是80端口怎么办&quot;&gt;不是80端口怎么办？&lt;/h2&gt;
&lt;p&gt;默认是不允许&lt;code&gt;80&lt;/code&gt;/&lt;code&gt;443&lt;/code&gt;端口开放外网的，因此即使有动态域名绑定，以后发给客户时，网址里面也带一个长长的端口名，如：&lt;code&gt;https://cool.starworks.cc:44300&lt;/code&gt;。在&lt;code&gt;DNS&lt;/code&gt;记录类型中，有多种方式解决这个问题，可以指定为&lt;code&gt;SRV&lt;/code&gt;或者&lt;code&gt;显性URL&lt;/code&gt;、&lt;code&gt;隐性URL&lt;/code&gt;来解决这个问题：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201909/233608-20190928000412696-145504950.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个过程可以通过&lt;code&gt;C#&lt;/code&gt;代码完成，代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;client.GetAcsResponse(new AddDomainRecordRequest
{
    DomainName = &quot;starworks.cc&quot;, 
    RR = &quot;cool&quot;,
    Type = &quot;SRV&quot;,
    _Value = &quot;0 5 44403 home.starworks.cc&quot;,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一来，只需在浏览器中输入：&lt;a href=&quot;http://cool.starworks.cc%EF%BC%8C%E5%8D%B3%E5%8F%AF%E8%87%AA%E5%8A%A8%E6%98%BE%E7%A4%BA%E6%88%91http://home.starworks.cc:44403&quot; class=&quot;uri&quot;&gt;http://cool.starworks.cc，即可自动显示我http://home.starworks.cc:44403&lt;/a&gt; 的内容：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201909/233608-20190928000418649-890238123.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;文中的“祖传代码”链接如下，可随意下载使用，用&lt;code&gt;LINQPad&lt;/code&gt;打开：&lt;/p&gt;
&lt;p&gt;其中管理界面运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201909/233608-20190928000426208-408248517.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用时将我的&lt;code&gt;starworks.cc&lt;/code&gt;域名换成你的即可。&lt;/p&gt;
&lt;p&gt;说来其实我不太关心&lt;code&gt;.NET&lt;/code&gt;以后会发展成什么样子，相比之下，我更关心我立马能用&lt;code&gt;.NET&lt;/code&gt;做出什么来。&lt;code&gt;.NET Core 3.0&lt;/code&gt;已经发布，其新功能还没来得及细看，但&lt;code&gt;.NET&lt;/code&gt;当下能提供给我的想象力就已经非常丰富了，这可能就是我心中的“自由”：只要探索，总会有新的发现。&lt;/p&gt;
&lt;p&gt;喜欢的朋友请关注我的微信公众号：【DotNet骚操作】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201908/233608-20190825165420518-990227633.jpg&quot; alt=&quot;DotNet骚操作&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Sep 2019 16:06:00 +0000</pubDate>
<dc:creator>.NET骚操作</dc:creator>
<og:description>动态域名解析-.NET也能做！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdflysha/p/20190927-dotnet-dynamic-domain-resolution.html</dc:identifier>
</item>
<item>
<title>用call或bind实现bind() - 会开花的小胡杨</title>
<link>http://www.cnblogs.com/MelodysBlog/p/11601087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MelodysBlog/p/11601087.html</guid>
<description>&lt;p&gt;一、bind方法&lt;/p&gt;
&lt;p&gt;让我们看一下MDN上对bind方法的解释&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;&lt;strong&gt;　　　　bind()&lt;/strong&gt;&lt;/code&gt;方法创建一个新的函数，在&lt;code&gt;&lt;strong&gt;bind()&lt;/strong&gt;&lt;/code&gt;被调用时，这个新函数的&lt;code&gt;this&lt;/code&gt;被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 也就是说，bind（）方法会：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个新的函数（这也是它和call、apply不同的点）&lt;/li&gt;
&lt;li&gt;创建的函数接收bind的第二个及以后的参数作为自己的参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 那bind创建的这个新函数还有其他什么特性吗？&lt;/p&gt;
&lt;blockquote readability=&quot;5.8741258741259&quot;&gt;
&lt;p&gt;　　　　调用绑定函数时作为&lt;code&gt;this&lt;/code&gt;参数传递给目标函数的值。 如果使用&lt;a title=&quot;new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。&quot; href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt;运算符构造绑定函数，则忽略该值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 举个下面的例子：由bind创建的新函数bindFoo作为构造函数时，其创建的实例newBindFoo并不指向bindFoo绑定的obj，而是指向bindFoo。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{
    name:&lt;/span&gt;&quot;Melody&quot;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name=&quot;huyang&quot;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(tel){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name)
    console.log(tel)
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bindFoo=foo.bind(obj,&quot;110&quot;&lt;span&gt;)

bindFoo()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Melody&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; newbindFoo=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; bindFoo();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefinde&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;二、现在可以尝试用call实现bind啦&lt;/h3&gt;
&lt;p&gt;先实现前两个特性，用call模拟bind绑定this，并且对arguments进行分割处理实现其余参数传递&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
Function.prototype.bind2 = function (context) {
        var self = this;
        var args=Array.prototype.slice.call(arguments,1)//模拟bind时的传参
        return function () {
                var bindArgs=Array.prototype.slice(arguments)//模拟执行bind的返回函数时的传参
                self.apply(context,args.concat(bindArgs));//修改返回函数的this指向为context,并将bind时和执行bind的返回函数传入的参数concat后绑定给返回函数。
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改返回函数的作用域链，使其指向绑定函数，这样返回函数生成的实例就可以继承绑定函数的原型啦。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
Function.prototype.bind2 = function (context) {
        var self = this;
        var args=Array.prototype.slice.call(arguments,1)//模拟bind时的传参
        var foo=function() {
                var bindArgs=Array.prototype.slice(arguments)//模拟执行bind的返回函数时的传参
                self.apply(this instanceof self ? this : context, args.concat(bindArgs));
                // 由于下方修改返回函数的prototype为绑定函数的prototype，当返回函数作为构造函数使用时，实例this instanceof self必定为真（instanceof判断的底层原理实际上就是根据原型链判断的）
                // 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，this 指向绑定的 context
    
        }
        foo.prototype=this.prototype
        return foo
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的点：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　　　arguments只是具有length属性且可以通过index读取的类数组对象，并没有slice等数组方法，要想对arguments使用数组方法必须得将arguments转换为真正的数组。故，使用Array.prototype.slice.call(arguments)，对Array原型链中的slice方法调用call(或apply)，传入arguments作为其上下文，然后返回arguments转换后的数组。&lt;/p&gt;
&lt;/blockquote&gt;


</description>
<pubDate>Fri, 27 Sep 2019 16:04:00 +0000</pubDate>
<dc:creator>会开花的小胡杨</dc:creator>
<og:description>一、bind方法 让我们看一下MDN上对bind方法的解释 bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MelodysBlog/p/11601087.html</dc:identifier>
</item>
<item>
<title>Kubernetes的Secret对象使用 - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/11601049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/11601049.html</guid>
<description>&lt;p&gt;Secret可以把想要访问的加密数据，存放到Etcd中，然后Pod可以通过的Volume的方式，访问到Secret保存的信息 ，每当数据修改的时候，Pod挂载的Secret文件也会被修改，特别适合用来存放账户密码&lt;/p&gt;
&lt;h2 id=&quot;一创建secret对象&quot;&gt;一、创建Secret对象&lt;/h2&gt;
&lt;h3 id=&quot;通过文件创建&quot;&gt;1. 通过文件创建&lt;/h3&gt;
&lt;p&gt;生成两个文件，分别是username.txt和password.txt&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo &quot;chenqionghe&quot; &amp;gt; ./username.txt
echo &quot;111111&quot; &amp;gt; ./password.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl create secret generic user --from-file=./username.txt
kubectl create secret generic pass --from-file=./password.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过yaml创建&quot;&gt;2. 通过yaml创建&lt;/h3&gt;
&lt;p&gt;注意：值必须是base64转码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  user:  Y2hlbnFpb25naGUK
  pass: MTExMTExCg==&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl apply -f mysecret.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二获取secret对象&quot;&gt;二、获取secret对象&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;root@VM-0-8-ubuntu:/home/ubuntu/project-volume# kubectl get secrets
NAME TYPE DATA AGE
default-token-gqfrx kubernetes.io/service-account-token 3 20d
mysecret Opaque 2 1m
pass Opaque 1 6m
user Opaque 1 6m&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三通过pod使用secret示例&quot;&gt;三、通过pod使用secret示例&lt;/h2&gt;
&lt;p&gt;这里指定了volume是projected类型，引用的是secret的user和pass，挂载路径为/projected-volume&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: test-projected-volume 
spec:
  containers:
  - name: test-secret-volume
    image: busybox
    args:
    - sleep
    - &quot;86400&quot;
    volumeMounts:
    - name: mysql-cred
      mountPath: &quot;/projected-volume&quot;
      readOnly: true
  volumes:
  - name: mysql-cred
    projected:
      sources:
      - secret:
          name: user
      - secret:
          name: pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行创建&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl apply -f test-projected-volume.yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看pod已经创建出来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@VM-0-8-ubuntu:/home/ubuntu/project-volume# kubectl get pod
NAME READY STATUS RESTARTS AGE
test-projected-volume 1/1 Running 0 5m&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再进入pod内查看，看到文件已经存在，并且内容和设置的一样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@VM-0-8-ubuntu:/home/ubuntu/project-volume# kubectl exec -it test-projected-volume -- /bin/sh
/ # ls /projected-volume/
password.txt username.txt
/ # cat /projected-volume/username.txt
chenqionghe&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们修改一下username的secret文件，将chenqionghe修改为cqh（对应的base编码为Y3FoCg==）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl edit secret user&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apiVersion: v1
data:
  username.txt: Y3FoCg==
kind: Secret
metadata:
  creationTimestamp: 2019-09-27T09:14:00Z
  name: user
  namespace: default
  resourceVersion: &quot;2108808&quot;
  selfLink: /api/v1/namespaces/default/secrets/user
  uid: 24566f8f-e107-11e9-8c22-f242c645cfec
type: Opaque&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次查看pod中挂载的文件，已经发生变化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;root@VM-0-8-ubuntu:/home/ubuntu# kubectl exec -it test-projected-volume -- cat /projected-volume/username.txt
cqh&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 27 Sep 2019 15:53:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<og:description>Secret可以把想要访问的加密数据，存放到Etcd中，然后Pod可以通过的Volume的方式，访问到Secret保存的信息 ，每当数据修改的时候，Pod挂载的Secret文件也会被修改，特别适合用来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenqionghe/p/11601049.html</dc:identifier>
</item>
<item>
<title>OAuth2.0授权登录 - wwcom123</title>
<link>http://www.cnblogs.com/wwcom123/p/11600463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wwcom123/p/11600463.html</guid>
<description>&lt;p&gt;　　　&lt;span&gt;&lt;span&gt;最近工作中遇到了多系统间的授权登录，对OAuth2.0进行了学习研究，并总结备忘。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;【&lt;/strong&gt;场景】 &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;         我们登录一些论坛等网站的时候，如果不想单独注册该网站账号，可以选择用微信或QQ账号进行授权登录。 这样的第三方登录方式到底是怎么实现的呢？难道是腾讯把我们微信或QQ账号信息卖给了这些网站？很显然，腾讯是不会这么干的，这种登录方式的实现，其实就是使用的&lt;strong&gt;OAuth2.0&lt;/strong&gt;的授权登录方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 类似地，在公司内部，如果公司有多套不同的软件系统，例如公司内网的财务报销系统、考勤系统、报销系统、人事系统等，也可以实现一个员工账号就能授权访问所有系统，而不需要每个系统都开通单独的账号，设置独立的密码。这是通常所说的&lt;strong&gt;SSO单点登录，&lt;/strong&gt;而&lt;strong&gt;OAuth2.0是单点登录的实现方式之一&lt;/strong&gt;。&lt;/span&gt; &lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;【&lt;/strong&gt;定义】 &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;        OAuth2.0是一种允许第三方应用程序使用资源所有者的&lt;strong&gt;凭据&lt;/strong&gt;获得对资源有限访问权限的一种授权协议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       例如在上述例子中，通过微信登录论坛的过程，就相当于微信允许该论坛作为第三方应用程序在经过微信用户授权后，通过&lt;strong&gt;微信颁发的授权凭证&lt;/strong&gt;有限地访问用户的微信头像、手机号，性别等受限制的资源，从而来构建自身的登录逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　注：在OAuth2.0协议中，第三方应用程序获取的凭证并不等同于资源拥有者持有的用户名和密码，以上面例子来说，微信是不会直接将用户的用户名、密码等信息作为凭证返回给该论坛的。这种&lt;strong&gt;授权访问凭证&lt;/strong&gt;一般来说就是一个表示特定范围、生存周期和其访问权限的一个由字符串组成的访问令牌，也就是我们常说的&lt;strong&gt;token&lt;/strong&gt;。在这种模式下OAuth2.0协议中通过引入一个&lt;strong&gt;授权层&lt;/strong&gt;来将第三方应用程序与资源拥有者进行分离，而这个授权层也就是常说的“&lt;strong&gt;auth认证服务&lt;/strong&gt;/&lt;strong&gt;sso单点登录服务器&lt;/strong&gt;”。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　在OAuth2.0协议中定义了以下四个角色：&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　1）&lt;/strong&gt;&lt;strong&gt;resource owner（资源拥有者）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　即能够有权授予对保护资源访问权限的实体。例如我们使用通过微信账号登录论坛，而微信账号信息的实际拥有者就是微信用户，也被称为最终用户。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2）&lt;/strong&gt;&lt;strong&gt;resource server（资源服务器）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　承载受保护资源的服务器，能够接收使用访问令牌对受保护资源的请求并响应，它与授权服务器可以是同一服务器(下述的“简化模式”)，也可以是不同服务器(下述的“授权码模式”)。在上述例子中该角色就是微信服务器。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3）&lt;/strong&gt;&lt;strong&gt;client（客户端）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　代表资源所有者及其授权发出对受保护资源请求的应用程序。在上面的例子中的用户要注册的论坛就是该角色。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　4）&lt;/strong&gt;&lt;strong&gt;authorization server（授权服务器）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　认证服务器，即服务提供商专门用来处理认证授权的服务器。例如微信开放平台提供的认证服务的服务器。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;【&lt;/strong&gt;流程】 &lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　还是以微信授权登录举例，流程如下：&lt;/span&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1394267/201909/1394267-20190927222107080-1336196963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; 流程说明： &lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;首先微信用户点击豆瓣网论坛的微信授权登录按钮后，豆瓣网论坛会将请求通过&lt;strong&gt;URL重定向&lt;/strong&gt;的方式跳转至微信用户授权界面；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;此时微信用户实际上是在微信上进行身份认证，与豆瓣网论坛并无交互了，这一点非常类似于购物后，使用网银支付的场景；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;用户使用微信客户端扫描二维码认证或者输入用户名密码后，微信会验证用户身份信息的正确性，如正确，则认为用户确认授权微信登录豆瓣网论坛，此时会先生成一个&lt;strong&gt;临时凭证&lt;/strong&gt;，并携带此凭证通过用户浏览器将请求重定向回豆瓣网在第一次重定向时携带的&lt;strong&gt;callBackUrl&lt;/strong&gt;地址；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;之后用户浏览器会携带临时凭证访问豆瓣网服务，豆瓣网则&lt;strong&gt;通过此临时凭证再次调用微信授权接口，获取正式的访问凭据access_token&lt;/strong&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在豆瓣网获取到微信授权访问凭据access_token后，此时用户的授权基本上就完成了，后续豆瓣网要做的只是通过此token再访问微信提供的相关接口，获取微信允许授权开发的用户信息，如头像，昵称等，并据此完成自身的用户逻辑及用户登录会话逻辑。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;【模式】&lt;/strong&gt; &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　在上述流程中比较关键的动作是&lt;strong&gt;resource owner（资源拥有者，&lt;/strong&gt;用户&lt;strong&gt;）&lt;/strong&gt;怎么样才能给Client（豆瓣网论坛）授权，因为只有有了这个授权，Client角色才可以获取访问令牌（access_token），进而通过令牌访问其他资源接口。而&lt;/span&gt;&lt;span&gt;&lt;span&gt;关于客户端如何获得授权的问题，在OAuth2.0中定义了&lt;strong&gt;四种授权方式&lt;/strong&gt;，目前微信授权登录，使用的就是其中最常用的一种：“授权码模式”(authorization_code)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　OAuth2.0定义了四种授权模式，它们分别是：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;授权码模式（authorization code）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;简化模式（implicit）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;密码模式（resource owner password credentials）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;客户端模式（client credentials）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;strong&gt;四种模式对比说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;1.授权码模式（authorization code） &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;功能最完整、流程最严密的授权模式，安全性最高，也最为常用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　特点是通过客户端的后台服务器，与“服务提供商”的认证服务进行互动（如微信开放平台），如上述微信账号登录豆瓣网的流程就是授权码模式的实现&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　这种模式下授权代码并不是客户端直接从资源所有者获取，而是通过授权服务器（authorization server）作为中介来获取，授权认证的过程也是资源所有者直接通过授权服务器进行身份认证，避免了资源所有者身份凭证与客户端共享的可能，因此是十分安全的。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　2.简化模式（implicit grant type）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　简化模式是对授权码模式的简化，用于在浏览器中使用脚本语言如JS实现的客户端中，特点是不通过客户端应用程序的服务器，而是直接在浏览器中向认证服务器申请令牌，&lt;strong&gt;跳过了“授权码临时凭证”这个步骤&lt;/strong&gt;。其所有的步骤都在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。如果使用此种授权方式来实现微信登录豆瓣网论坛的过程流程示例如下：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1394267/201909/1394267-20190927225437965-1362841569.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　　　&lt;span&gt;可以看出，与授权码模式的不同之处在于：在第4步用户完成授权后，认&lt;strong&gt;证服务器是直接返回了access_token令牌&lt;/strong&gt;至用户浏览器端，而&lt;strong&gt;并没有先返回临时授权码code&lt;/strong&gt;，然后由客户端的后端服务去通过授权码再去获取access_token令牌，从而省去了一个跳转步骤，提高了交互效率。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是由于这种方式访问令牌access_token会在URL片段中进行传输，因此可能会导致访问令牌被其他未经授权的第三方截取，所以&lt;strong&gt;安全性上并不是那么的强壮&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;3.密码模式（resource owner password credentials）&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　在密码模式中，用户需要向客户端提供自己的用户名和密码，客户端使用这些信息向“服务提供商”索要授权。这相当于在豆瓣网中使用微信登录，我们需要在豆瓣网输入微信的用户名和密码，然后由豆瓣网使用我们的微信用户名和密码去向微信服务器获取授权信息。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这种模式一般用在用户对客户端高度信任的情况下，因为虽然协议规定客户端不得存储用户密码，但是实际上这一点并不是特别好强制约束。就像在豆瓣网输入了微信的用户名和密码，豆瓣网存储不存储我们并不是很清楚，所以安全性是非常低的。因此一般情况下是不会考虑使用这种模式进行授权的。公司内网之间相互信任的子系统间也许才有可能使用。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果使用此种授权方式来实现微信登录豆瓣网论坛的过程流程示例如下：&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1394267/201909/1394267-20190927224832274-1099438448.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　4.客户端模式（client credentials）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　客户端模式是指客户端以自己的名义，而不是以用户的名义，向“服务提供方”进行认证。严格地说，客户端模式并不属于OAuth2.0协议所要解决的问题。在这种模式下，用户并不需要对客户端授权，用户直接向客户端注册，客户端以自己的名义要&lt;/span&gt;&lt;span&gt;&lt;span&gt;求&lt;span&gt;“服务提供商”提供服务&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，其实不存在授权问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2014/bg2014051207.png&quot; alt=&quot;客户端模式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　步骤如下：&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　 (1)客户端向认证服务器进行身份认证，并要求一个&lt;strong&gt;access_token令牌&lt;/strong&gt;。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　 　　(2)认证服务器确认无误后，向客户端提供访问&lt;strong&gt;access_token令牌&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               　   (3)客户端后续携带&lt;strong&gt;access_token令牌&lt;/strong&gt;继续后续业务请求流程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt; 　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　步骤(1)中，客户端发出的HTTP请求，包含以下参数：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;grant_type：表示授权类型，此处的值固定为&quot;client_credentials&quot;，必选项。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;scope：表示权限范围，可选项。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;hljs yaml&quot;&gt;示例：
     &lt;span class=&quot;hljs-string&quot;&gt;POST &lt;span class=&quot;hljs-string&quot;&gt;/token &lt;span class=&quot;hljs-string&quot;&gt;HTTP/1.1
&lt;span class=&quot;hljs-attr&quot;&gt;     Host: &lt;span class=&quot;hljs-string&quot;&gt;server.example.com
&lt;span class=&quot;hljs-attr&quot;&gt;     Authorization: &lt;span class=&quot;hljs-string&quot;&gt;Basic &lt;span class=&quot;hljs-string&quot;&gt;czZCaGRSa3F0MzpnWDFmQmF0M2JW
&lt;span class=&quot;hljs-attr&quot;&gt;     Content-Type: &lt;span class=&quot;hljs-string&quot;&gt;application/x-www-form-urlencoded

     &lt;strong&gt;&lt;span class=&quot;hljs-string&quot;&gt;grant_type=client_credentials
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;　　认证服务器必须以某种方式，验证客户端身份。然后在&lt;/span&gt;&lt;span&gt;步骤(2)中，认证服务器向客户端提供访问&lt;strong&gt;access_token令牌&lt;/strong&gt;，下面是一个例子。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;hljs sql&quot;&gt;示例：
     HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     &lt;span class=&quot;hljs-keyword&quot;&gt;Cache-Control: &lt;span class=&quot;hljs-keyword&quot;&gt;no-&lt;span class=&quot;hljs-keyword&quot;&gt;store
     &lt;span class=&quot;hljs-keyword&quot;&gt;Pragma: &lt;span class=&quot;hljs-keyword&quot;&gt;no-&lt;span class=&quot;hljs-keyword&quot;&gt;cache

     {
       &lt;span class=&quot;hljs-string&quot;&gt;&lt;strong&gt;&quot;access_token&quot;&lt;/strong&gt;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;2YotnFZFEjr1zCsicMWpAA&quot;,
       &lt;span class=&quot;hljs-string&quot;&gt;&quot;iss&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;签发授权者&quot;,&lt;br/&gt;　　　　&quot;sub&quot;:&quot;服务使用者&quot;,&lt;br/&gt;　　　　&quot;aud&quot;:&quot;服务提供者&quot;,&lt;br/&gt;　　　　&quot;exp&quot;:&quot;过期时间&quot;,
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;iat&quot;:&lt;span class=&quot;hljs-number&quot;&gt;&quot;签发时间&quot;,
       &lt;span class=&quot;hljs-string&quot;&gt;&quot;other_custom_parameter&quot;:&lt;span class=&quot;hljs-string&quot;&gt;&quot;value&quot;
     }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;　　综上所述，虽然在OAuth2.0协议中定义了四种客户端授权认证模式，但是实际上大部分实际应用场景中使用的都是授权码（authorization code）的模式，如微信开放平台、微博开放平台等使用的基本都是授权码认证模式。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;【更新令牌】&lt;/h3&gt;
&lt;p&gt;　&lt;span&gt;　如果用户访问的时候，客户端的&quot;访问令牌&quot;已经过期，则需要使用&quot;更新令牌&quot;申请一个新的访问令牌。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端发出更新令牌的HTTP请求，包含以下参数：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;grant_type：表示使用的授权模式，此处的值固定为&quot;refresh_token&quot;，必选项。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;refresh_token：表示早前收到的更新令牌，必选项。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;hljs yaml&quot;&gt;示例：
     &lt;span class=&quot;hljs-string&quot;&gt;POST &lt;span class=&quot;hljs-string&quot;&gt;/token &lt;span class=&quot;hljs-string&quot;&gt;HTTP/1.1
&lt;span class=&quot;hljs-attr&quot;&gt;     Host: &lt;span class=&quot;hljs-string&quot;&gt;server.example.com
&lt;span class=&quot;hljs-attr&quot;&gt;     Authorization: &lt;span class=&quot;hljs-string&quot;&gt;Basic &lt;span class=&quot;hljs-string&quot;&gt;czZCaGRSa3F0MzpnWDFmQmF0M2JW
&lt;span class=&quot;hljs-attr&quot;&gt;     Content-Type: &lt;span class=&quot;hljs-string&quot;&gt;application/x-www-form-urlencoded

     &lt;span class=&quot;hljs-string&quot;&gt;&lt;strong&gt;grant_type=refresh_token&lt;/strong&gt;&amp;amp;&lt;strong&gt;refresh_token=&lt;/strong&gt;tGzv3JOkF0XG5Qx2TlKWIA&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Fri, 27 Sep 2019 15:24:00 +0000</pubDate>
<dc:creator>wwcom123</dc:creator>
<og:description>最近工作中遇到了多系统间的授权登录，对OAuth2.0进行了学习研究，并总结备忘。 【场景】 我们登录一些论坛等网站的时候，如果不想单独注册该网站账号，可以选择用微信或QQ账号进行授权登录。&amp;#160</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wwcom123/p/11600463.html</dc:identifier>
</item>
<item>
<title>opencv图像处理之常见滤波器 - sdu20112013</title>
<link>http://www.cnblogs.com/sdu20112013/p/11600436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/11600436.html</guid>
<description>&lt;h2 id=&quot;图像平滑&quot;&gt;图像平滑&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Smoothing, also called blurring, is a simple and frequently used image processing operation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;平滑,也叫模糊.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201909/583030-20190927210729375-1927464296.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本质就是把某点的像素值转换为其及其周围像素值的不同权重的叠加.h(k,l)即为卷积核，或者叫滤波器filter.&lt;/p&gt;
&lt;p&gt;有几种常见的filter&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Normalized Box Filter&lt;/li&gt;
&lt;li&gt;Gaussian Filter&lt;/li&gt;
&lt;li&gt;Median Filter&lt;/li&gt;
&lt;li&gt;Bilateral Filter&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;均值滤波&quot;&gt;均值滤波&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201909/583030-20190927210940858-695693774.png&quot;/&gt;&lt;br/&gt;权重矩阵如上.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;img2= cv2.blur(img,(5,5))&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8.9203539823009&quot;&gt;
&lt;p&gt;The call blur(src, dst, ksize, anchor, borderType) is equivalent to boxFilter(src, dst, src.type(), anchor, true, borderType).&lt;br/&gt;&lt;a href=&quot;https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37&quot; class=&quot;uri&quot;&gt;https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#ga8c45db9afe636703801b0b2e440fce37&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201909/583030-20190927210814588-200455053.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;高斯滤波&quot;&gt;高斯滤波&lt;/h2&gt;
&lt;p&gt;即假设某一位置的像素和其邻域像素符合高斯分布.具体的说的话,就是每一位置的像素的权重符合高斯分布.这样的话,给定一个高斯分布,及高斯核的大小,则可以计算出周边n个像素的权重值.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201909/583030-20190927220041155-1967351557.png&quot;/&gt;&lt;br/&gt;上图展示了一维度的高斯分布图和二维高斯分布的公式. 图像是2维度的.(即行维度和列维度确定一个像素点的位置).&lt;/p&gt;
&lt;p&gt;高斯滤波的具体计算过程.可以参考&lt;a href=&quot;https://blog.csdn.net/zr459927180/article/details/52400641&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/zr459927180/article/details/52400641&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;opencv中获取高斯核心的函数为getGaussianKernel,但是这个获取的一维的高斯核.对图像来说,以3*3邻域而言,我们应该得到一个3*3的权重矩阵.可以如下得到:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    kernal_x = cv2.getGaussianKernel(3,-1)
    kernal_y = cv2.getGaussianKernel(3,-1)
    kernal_filter = np.dot(kernal_x,kernal_y.T)
    print(kernal_filter)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[[0.0625 0.125  0.0625]
 [0.125  0.25   0.125 ]
 [0.0625 0.125  0.0625]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则中间元素的亮度值经高斯转换后为0.0625 x p(0,0) + 0.125 x p(0,1) + .... + 0.0625 x p(2,2),可以看到权重矩阵相加等于1.&lt;/p&gt;
&lt;p&gt;这里,我们举例用了3 x 3的高斯核,实际上并不限定高斯核一定要是正方形.&lt;/p&gt;
&lt;p&gt;回到cv的GaussianBlur(),&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201909/583030-20190927211103134-1379356949.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其参数sigmaX,sigmaY即x,y方向上的高斯分布的标准差.这样就可以求得不同方向上的高斯矩阵,再做矩阵乘法,即得到m x n的权重矩阵.进而求得高斯转换后的图像.&lt;/p&gt;
&lt;p&gt;我们知道&lt;a href=&quot;https://baike.baidu.com/item/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83/829892?fromtitle=%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83&amp;amp;fromid=10145793&amp;amp;fr=aladdin&quot;&gt;高斯分布(也叫正态分布)&lt;/a&gt;的特点为,标准差越大,分布越分散,标准差越小,分布越集中.所以调大GaussianBlur()中的sigmaX,sigmaY将使得图像中的每个像素更多地参考周边像素,即更为平滑或者说模糊.&lt;/p&gt;
&lt;p&gt;参见下图:(这张图选的不好,高斯模糊效果不明显,但还是可以看出图3更模糊一些)&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201909/583030-20190927214501247-431871482.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import cv2
import numpy as np
def test():
    imgname = &quot;/home/sc/opencv-3.4.3/samples/data/lena.jpg&quot;
    img = cv2.imread(imgname)

    img2 = img.copy()
    #img2 = cv2.blur(img,(5,5))
    img2 = cv2.GaussianBlur(img,(5,7),1)
    img3 = cv2.GaussianBlur(img,(5,7),100)

    kernal_x = cv2.getGaussianKernel(3,0)
    kernal_y = cv2.getGaussianKernel(3,0)
    kernal_filter = np.dot(kernal_x,kernal_y.T)
    print(kernal_filter)
    
    kernal_x = cv2.getGaussianKernel(3,5)
    kernal_y = cv2.getGaussianKernel(3,5)
    kernal_filter = np.dot(kernal_x,kernal_y.T)
    print(kernal_filter)
    
    #return

    cv2.imshow(&quot;origin&quot;,img)
    cv2.imshow(&quot;dst&quot;,img2)
    cv2.imshow(&quot;dst3&quot;,img3)

    k=cv2.waitKey()
    if k == 27:
        cv2.destroyAllWindows()
        
test()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201909/583030-20190927214537351-543464941.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从getGaussianKernel()的输出可以明显地看出来,标准差调大时,权重矩阵的变换.&lt;/p&gt;
&lt;h2 id=&quot;中值滤波&quot;&gt;中值滤波&lt;/h2&gt;
&lt;p&gt;即把像素值变为邻域像素值的中位数.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201909/583030-20190927222700927-1286929147.png&quot;/&gt;&lt;br/&gt;注意,kernal的大小必须为奇数.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import cv2
def test():
    imgname = &quot;/home/sc/opencv-3.4.3/samples/data/lena.jpg&quot;
    img = cv2.imread(imgname)

    dst = cv2.medianBlur(img, 1)
    dst2 = cv2.medianBlur(img, 11)
    
    cv2.imshow(&quot;origin&quot;,img)
    cv2.imshow(&quot;dst&quot;,dst)
    cv2.imshow(&quot;dst2&quot;,dst2)

    k=cv2.waitKey()
    if k == 27:
        cv2.destroyAllWindows()
test()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201909/583030-20190927222615528-1168063806.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;双边滤波&quot;&gt;双边滤波&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201909/583030-20190927223310936-45450904.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;双边滤波函数是 cv2.bilateralFilter() ，&lt;strong&gt;双边滤波能在保持边界清晰的情况下有效的去除噪音。但是这种操作与其他滤波器相比会比较慢&lt;/strong&gt;.我们已经知道高斯滤波器是求中心点邻近区域像素的高斯加权平均值。这种高斯滤波器只考虑像素之间的空间关系，而不会考虑像素值之间的关系（像素的相似度）。所以这种方法不会考虑一个像素是否位于边界。因此边界也会被模糊掉，而这不是我们想要的。&lt;/p&gt;
&lt;p&gt;双边滤波在&lt;strong&gt;同时使用空间高斯权重和灰度值相似性高斯权重&lt;/strong&gt;。空间高斯函数确保只有邻近区域的像素对中心点有影响，&lt;strong&gt;灰度值相似性高斯函数确保只有与中心像素灰度值相近的才会被用来做模糊运算&lt;/strong&gt;。所以这种方法会确保边界不会被模糊掉，因为边界处的灰度值变化比较大.&lt;/p&gt;
&lt;p&gt;简单滴说就是,在生成周边像素的权重矩阵时,如果发现旁边的像素值和当前的像素值差异很大,就只给差异很大的那个元素分配很小的权重,这样&quot;大的突变差异就被保留了&quot;.&lt;br/&gt;双边滤波的原理可以参考:&lt;a href=&quot;https://blog.csdn.net/shenziheng1/article/details/50838970&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/shenziheng1/article/details/50838970&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dst = cv2.bilateralFilter(img, 9, 75, 75)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201909/583030-20190927224642441-910058239.png&quot;/&gt;&lt;br/&gt;可以看到纹理被模糊掉了,但是边界还是很好地保留了.&lt;/p&gt;
&lt;p&gt;参考:参考:&amp;lt;&lt;a href=&quot;https://docs.opencv.org/master/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html&quot; class=&quot;uri&quot;&gt;https://docs.opencv.org/master/dc/dd3/tutorial_gausian_median_blur_bilateral_filter.html&lt;/a&gt; &amp;gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/shenziheng1/article/details/50838970&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/shenziheng1/article/details/50838970&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/GiffordY/article/details/91891920&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/GiffordY/article/details/91891920&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Sep 2019 14:55:00 +0000</pubDate>
<dc:creator>sdu20112013</dc:creator>
<og:description>图像平滑 Smoothing, also called blurring, is a simple and frequently used image processing operation. 平滑</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdu20112013/p/11600436.html</dc:identifier>
</item>
</channel>
</rss>