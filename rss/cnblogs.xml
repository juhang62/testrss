<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>上周热点回顾（1.20-1.26） - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/12235413.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/12235413.html</guid>
<description>[unable to retrieve full-text content]热点随笔： · 150行代码打造.net core生产力工具，你值得拥有 (billsking)· 裁员寒潮下，如何过冬 (渡码)· 【新书推荐】《ASP.NET Core微服务实战：在云环境中开发、测试和部署跨平台服务》 带你走近微服务开发 (张善友)· 【年终总结】马三京沪漂流记之2019年总结</description>
<pubDate>Mon, 27 Jan 2020 00:41:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>热点随笔： &amp;#183;&amp;#160;150行代码打造.net core生产力工具，你值得拥有&amp;#160;(billsking)&amp;#183;&amp;#160;裁员寒潮下，如何过冬&amp;#160;(渡码)&amp;#183</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cmt/p/12235413.html</dc:identifier>
</item>
<item>
<title>【python系统学习08】for循环知识点合集 - xing.org1^</title>
<link>http://www.cnblogs.com/padding1015/p/12235332.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/padding1015/p/12235332.html</guid>
<description>&lt;p&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;toc&quot; id=&quot;tocid_0&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#hfor-1&quot;&gt;for简介&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h&quot;&gt;代码格式&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-1&quot;&gt;语法格式&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-2&quot;&gt;可被迭代的数据类型&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-3&quot;&gt;列表&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-4&quot;&gt;字典&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-5&quot;&gt;字符串&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-6&quot;&gt;不可被迭代的数据类型&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-7&quot;&gt;整数&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-8&quot;&gt;浮点值&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-9&quot;&gt;布尔值&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-10&quot;&gt;空值&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-11&quot;&gt;整数转化为范围后可被迭代&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#hrangey&quot;&gt;range(y)&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#hrangexy&quot;&gt;range(x, y)&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#hrangexyi&quot;&gt;range(x, y, i)&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#hpeacelove&quot;&gt;Peace &amp;amp;&amp;amp; Love&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-12&quot;&gt;迭代列表时获取索引&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#hcontinue&quot;&gt;continue 跳过本次循环&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#hbreak&quot;&gt;break 跳出循环&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-13&quot;&gt;思考题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h1100&quot;&gt;创建一个从1到100的整数列表&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/padding1015/p/12235332.html#h-14&quot;&gt;九九乘法表&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;hfor-1&quot;&gt;&lt;span&gt;for简介&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;【循环】：就是依照某些我们编写的特定规则，重复的做一件事。&lt;/p&gt;
&lt;p&gt;当你需要重复的“搬砖”的时候，可以用for循环进行遍历，让机器循环的帮你去“搬砖”，彻底解放我们的双手。&lt;/p&gt;
&lt;p&gt;【遍历】：所谓遍历，就是一遍一遍的经历。放到程序中，就是让程序一遍又一遍的经历重跑同一段代码程序的场景。和循环一个意思。&lt;/p&gt;
&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;代码格式&lt;/span&gt;&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;nameList = [&lt;span class=&quot;hljs-string&quot;&gt;'小石头'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'xing.org1^'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'郭菊锋'&lt;/span&gt;]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; name &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; nameList:&lt;br/&gt;print(name) &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'else情况'&lt;/span&gt;) &lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'===for循环完毕==='&lt;/span&gt;)&lt;br/&gt;print(name) &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码中，我们定义了一个列表数据nameList，并且使用for循环，依次遍历将列表中的每一项都迭代出来。&lt;/p&gt;
&lt;p&gt;每次循环时，我们定义的变量name就会被重新赋值为nameList的对应元素，第1次循环name被赋值为第一个元素、第2次循环name又被赋值成第二个元素。以此类推，直到nameList被循环完成或者出现跳出循环的指令（下表）后就会停止。&lt;/p&gt;
&lt;p&gt;而停止循环后，&lt;strong&gt;变量name就是最后一个被赋值的元素&lt;/strong&gt;，这里为&lt;code&gt;郭菊锋&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;观察上述代码，for循环的语法格式也有一定的规律。&lt;/p&gt;
&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;语法格式&lt;/span&gt;&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; 元素变量 &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; 迭代对象:&lt;br/&gt;【&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;子句】在代码块中，位于【缩进】后边。&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;子句里的内容会被循环执行。&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;里边的内容都会被执行。在&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;循环完毕之后执行。&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-2&quot;&gt;&lt;span&gt;可被迭代的数据类型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;有哪些数据类型可以被for循环遍历呢？&lt;/p&gt;
&lt;p&gt;结论：列表、字典、字符串。用例子说明：&lt;/p&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;列表&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;for循环遍历列表数据，可以依次打印出列表中的每一项。&lt;/p&gt;
&lt;p&gt;打印循环的次数取决于列表中元素的个数。也就是列表的长度。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;nameList = [&lt;span class=&quot;hljs-string&quot;&gt;'小石头'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'xing.org1^'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'郭菊锋'&lt;/span&gt;]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; name &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; nameList:&lt;br/&gt;print(name) &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-4&quot;&gt;&lt;span&gt;字典&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;for循环遍历字典数据，可以依次打印出字典中的每一个键（key）名。&lt;/p&gt;
&lt;p&gt;我们可以在利用&lt;code&gt;字典名[key]&lt;/code&gt;的方式，获取key所对应的值。&lt;/p&gt;
&lt;p&gt;打印循环的次数取决于字典中键名key的个数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;dictName = {&lt;span class=&quot;hljs-string&quot;&gt;'name'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'小石头'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'nameEn'&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;'xing.org1^'&lt;/span&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; name &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; dictName:&lt;br/&gt;print(name) &lt;br/&gt;print(dictName[name]) &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-5&quot;&gt;&lt;span&gt;字符串&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;字符串也可以被for循环遍历，打印的将是每一个字符。&lt;/p&gt;
&lt;p&gt;打印循环的次数取决于字符串的字符个数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;strName = &lt;span class=&quot;hljs-string&quot;&gt;'xing.org1^'&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; s &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; strName:&lt;br/&gt;print(s)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-6&quot;&gt;&lt;span&gt;不可被迭代的数据类型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;整数、浮点数皆不可被迭代，如果强行遍历会发生错误：&lt;/p&gt;
&lt;h3 id=&quot;h-7&quot;&gt;&lt;span&gt;整数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;整数对象不是可迭代的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;numberValue = &lt;span class=&quot;hljs-number&quot;&gt;2020&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; num &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; numberValue: &lt;br/&gt;print(num)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-8&quot;&gt;&lt;span&gt;浮点值&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;浮点数对象不是可迭代的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;floatValue = &lt;span class=&quot;hljs-number&quot;&gt;1.23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; num &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; floatValue: &lt;br/&gt;print(num)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-9&quot;&gt;&lt;span&gt;布尔值&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;布尔对象不可迭代：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;boolVal = &lt;span class=&quot;hljs-keyword&quot;&gt;True&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; b &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; boolVal: &lt;br/&gt;print(b)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-10&quot;&gt;&lt;span&gt;空值&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;空值对象不可被迭代：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;noneVal = &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; n &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; noneVal: &lt;br/&gt;print(n)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-11&quot;&gt;&lt;span&gt;整数转化为范围后可被迭代&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;虽然直接for循环整数，会发生错误。&lt;/p&gt;
&lt;p&gt;但是如果我们利用&lt;code&gt;range&lt;/code&gt;函数，将整数转化为一个数字范围，再去进行for遍历，就可以了。&lt;/p&gt;
&lt;h3 id=&quot;hrangey&quot;&gt;&lt;span&gt;range(y)&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;numValue = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(numValue):&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'5的迭代：'&lt;/span&gt;, index)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察可知，&lt;strong&gt;range范围迭代时，从“0”开始&lt;/strong&gt;，且不包含“5”。&lt;/p&gt;
&lt;h3 id=&quot;hrangexy&quot;&gt;&lt;span&gt;range(x, y)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;从上边例子中可以看出来，&lt;strong&gt;若x不填则会默认从0开始。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果不想从0开始呢？&lt;strong&gt;我们可以指定从几开始。&lt;/strong&gt;代码上可以这么写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;rangeValue1 = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, rangeValue1): &lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'range：'&lt;/span&gt;, index)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到另一个&lt;strong&gt;规律，在range括号里，逗号前边的数字被迭代时是包含的，右边的不包含。即取逗号左边而不取右边的数字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以上例中，你如果想打印出“5”，那么括号最右边的数字你应该至少填写的比5大1。&lt;/p&gt;
&lt;h3 id=&quot;hrangexyi&quot;&gt;&lt;span&gt;range(x, y, i)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;x和y，跟上边例子一致。均是从x开始，到y但是不包括y的迭代。而&lt;strong&gt;i是interval的缩写。表示间隔&lt;/strong&gt;。既从x开始循环后，下一次的循环与上一次循环间隔多少。&lt;/p&gt;
&lt;p&gt;文字空洞，代码奉上：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;):&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'interval:'&lt;/span&gt;, index)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码和打印结果观察得知，依旧是从0开始循环打印。不过0打印完了以后，1、2不打印。从3开始又有打印。依次规律类推…&lt;/p&gt;
&lt;h3 id=&quot;hpeacelove&quot;&gt;&lt;span&gt;Peace &amp;amp;&amp;amp; Love&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;最后，尝尝人类复读机的力量吧&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;rangeValue2 = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(rangeValue2):&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'''&lt;br/&gt;病毒消失，病人痊愈。武汉加油，天佑中华！&lt;br/&gt;'''&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-12&quot;&gt;&lt;span&gt;迭代列表时获取索引&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们通过上边迭代列表和字典的代码中可以看出来，for后边的变量在迭代列表的时候是列表内的元素、迭代字典的时候则是字典里边的键名。&lt;/p&gt;
&lt;p&gt;那么如果我想迭代字典时，有个变量存放列表中各项所对应的偏移量（索引）呢？&lt;/p&gt;
&lt;p&gt;通过range函数的搭配，我们不仅可以迭代整数，还能迭代列表的索引。&lt;/p&gt;
&lt;p&gt;于是我就试了下边的写法，但是他报错了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;&lt;br/&gt;nameList = [&lt;span class=&quot;hljs-string&quot;&gt;'小石头'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'xing.org1^'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'郭菊锋'&lt;/span&gt;]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; name,index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; nameList: &lt;br/&gt;print(index) &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;错误内容&lt;code&gt;ValueError: too many values to unpack (expected 2)&lt;/code&gt;。表示了这里不应该有两个参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么我们想用索引来携带列表时该怎么写呢？&lt;/strong&gt;&lt;br/&gt;一开始我给自己写了一个bug：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;nameList = [&lt;span class=&quot;hljs-string&quot;&gt;'小石头'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'xing.org1^'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'郭菊锋'&lt;/span&gt;]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(nameList): &lt;br/&gt;print(index) &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;range内部只能接受整数。而列表转化不成整数，出点类型错误。&lt;/p&gt;
&lt;p&gt;改正后，写法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;nameList = [&lt;span class=&quot;hljs-string&quot;&gt;'小石头'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'xing.org1^'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'郭菊锋'&lt;/span&gt;]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; index &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(len(nameList)):&lt;br/&gt;print(index) &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;思路是：先用len获取列表的长度，然后将计算的长度这个数字，放到range内部。&lt;/p&gt;
&lt;h2 id=&quot;hcontinue&quot;&gt;&lt;span&gt;continue 跳过本次循环&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;continue跳过本次循环，for循环跳过后继续执行下一次循环。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(i == &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'continue跳过循环'&lt;/span&gt;, i)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'有continue的for循环的else'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看打印结果得知，在满足i==3的条件之后，直接跳出了当次的循环没有打印3这个数字。而是进入到下次循环，打印出4后，循环完毕。&lt;/p&gt;
&lt;p&gt;然后执行了for后边的else语句。&lt;/p&gt;
&lt;h2 id=&quot;hbreak&quot;&gt;&lt;span&gt;break 跳出循环&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;break跳出循环，for循环不管是否完成将直接结束。甚至for后边的else都不会再执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;py language-py hljs python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(i == &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;):&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'break跳过循环'&lt;/span&gt;, i)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'有break的for循环的else'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看打印结果得知，在满足i==3的条件之后，直接跳出了循环。&lt;/p&gt;
&lt;p&gt;for循环后边的else都没执行。所以只打印了0、1、2。&lt;/p&gt;
&lt;h2 id=&quot;h-13&quot;&gt;&lt;span&gt;思考题&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h1100&quot;&gt;&lt;span&gt;创建一个从1到100的整数列表&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;用for循环打印1-100&lt;/p&gt;
&lt;h3 id=&quot;h-14&quot;&gt;&lt;span&gt;九九乘法表&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;用for循环打印一个九九乘法表。就是小学时候我们铅笔盒盖子内部上印刷的那种，表格形式的。&lt;br/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Jan 2020 17:37:00 +0000</pubDate>
<dc:creator>xing.org1^</dc:creator>
<og:description>当你需要重复的“搬砖”的时候，可以用for循环进行遍历，让机器循环的帮你去“搬砖”，彻底解放我们的双手。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/padding1015/p/12235332.html</dc:identifier>
</item>
<item>
<title>python常用内置模块-random模块 - 格桑_哈哈</title>
<link>http://www.cnblogs.com/xiaodan1040/p/12235316.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaodan1040/p/12235316.html</guid>
<description>&lt;h4 id=&quot;random模块用于生成随机数&quot;&gt;random模块：用于生成随机数&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;'''关于数据类型序列相关，参照https://www.cnblogs.com/yyds/p/6123692.html'''&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;random&quot;&gt;random()&lt;/h5&gt;
&lt;p&gt;随机获取0 到1 之间的浮点数，即 0.0 &amp;lt;= num &amp;lt; 1.0&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import random
# 使用random模块，必须导入

num = random.random()
print(num)  # 0.0 &amp;lt;= num &amp;lt; 1.0&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;randintm-n&quot;&gt;randint(m, n)&lt;/h5&gt;
&lt;p&gt;随机获取m 到n 之间的整数，即m &amp;lt;= num &amp;lt;= n&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;num = random.randint(2, 10)
print(num)  # 2 &amp;lt;= num &amp;lt;= 10， 注意：是整数&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;randrangestart-stop-step&quot;&gt;randrange(start, stop, [step])&lt;/h5&gt;
&lt;p&gt;随机获取start 到stop之间的整数，且步长为step，默认为1。即start &amp;lt;= num &amp;lt; stop&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;默认步长时，random.randrange(1, 5) 等价于 random.randint(1, 4)&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 默认步长
num = random.randrange(1, 5)
print(num)

# 设置步长为2
num_step = random.randrange(1, 10, 2)
# num_step的取值范围是：1到9之间的任意一个奇数
print(num_step)&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;shufflelist&quot;&gt;shuffle(list)&lt;/h5&gt;
&lt;p&gt;将列表中的元素顺序打乱，类似洗牌的操作(&lt;strong&gt;不确定是列表还是可迭代对象,有误请指正&lt;/strong&gt;)&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;code_list = ['l', 'd', 'e', 'a', 'w', 'e', 'n']
random.shuffle(code_list)  # 返回值为None，直接在原列表中操作
print(code_list)&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;choice&quot;&gt;choice()&lt;/h5&gt;
&lt;p&gt;从一个非空序列中随机取出一个元素返回&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;code_turple = ('l', 'd', 'e', 'a', 'w', 'e', 'n')
res = random.choice(code_turple)
print(res)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是一个获取随机验证码的小案例&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;'''
获取随机验证码小案例
chr(int(n))：用于将ASCⅡ码的数值转换成对应的字符，n的取值范围在0~255，返回值为字符串类型
ord(str('a'))：用于将单字符字符串转换成对应的ASCⅡ码，返回值为整型
在ASCⅡ码中，数值65-90：大写英文字符；数值97-122：小写英文字符
'''
def get_code(n):
    '''n:生成几位的验证码'''
    code = ''
    for line in range(n):
        # 随机获取任意一个小写字符的ASCⅡ码
        l_code = random.randint(97, 122)
        # 将ASCⅡ码转换成对应的字符
        l_code = chr(l_code)
        # 随机获取任意一个大写字符的ASCⅡ码
        u_code = random.randint(65, 90)
        # 将ASCⅡ码转换成对应的字符
        u_code = chr(u_code)
        # 随机获取任意一个0-9之间的数字
        n_code = random.randint(0, 9)
        # 将上述3个随机字符存储起来
        code_list = [l_code, u_code, n_code]
        # 从列表中任意取出一个
        random_code = random.choice(code_list)
        # 将字符拼接起来
        code += str(random_code)
    return code


print(get_code(5))&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 26 Jan 2020 17:03:00 +0000</pubDate>
<dc:creator>格桑_哈哈</dc:creator>
<og:description>random模块：用于生成随机数 random() 随机获取0 到1 之间的浮点数，即 0.0 &amp;lt;= num &amp;lt; 1.0 randint(m, n) 随机获取m 到n 之间的整数，即m &amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaodan1040/p/12235316.html</dc:identifier>
</item>
<item>
<title>Redis（五）：hash/hset/hget 命令源码解析 - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/12234983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/12234983.html</guid>
<description>&lt;p&gt;　　Redis作为nosql数据库，kv string型数据的支持是最基础的，但是如果仅有kv的操作，也不至于有redis的成功。（memcache就是个例子）&lt;/p&gt;
&lt;p&gt;　　Redis除了string, 还有hash,list,set,zset。&lt;/p&gt;
&lt;p&gt;　　所以，我们就来看看hash的相关操作实现吧。&lt;/p&gt;
&lt;p&gt;　　首先，我们从作用上理解hash存在的意义：Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。从另一个方面来说是，hash可以聚合很多类似的属性，这是string中难以实现的。&lt;/p&gt;
&lt;p&gt;所以，总体来说，hash的命令与string的命令差不太多。其操作手册如下：&lt;/p&gt;
&lt;blockquote readability=&quot;51&quot;&gt;
&lt;p&gt;1&amp;gt; hdel 命令：删除一个或多个哈希表字段&lt;br/&gt;格式：HDEL key field2 [field2]&lt;br/&gt;返回值：被成功删除字段的数量，不包括被忽略的字段。&lt;/p&gt;
&lt;p&gt;2&amp;gt; hexists 命令：查看哈希表 key 中，指定的字段是否存在&lt;br/&gt;格式：HEXISTS key field&lt;br/&gt;返回值：如果哈希表含有给定字段，返回 1 。 如果哈希表不含有给定字段，或 key 不存在，返回 0 。&lt;/p&gt;
&lt;p&gt;3&amp;gt; hget 命令：获取存储在哈希表中指定字段的值&lt;br/&gt;格式：HGET key field&lt;br/&gt;返回值：返回给定字段的值。如果给定的字段或 key 不存在时，返回 nil 。&lt;/p&gt;
&lt;p&gt;4&amp;gt; hgetall 命令：获取在哈希表中指定 key 的所有字段和值&lt;br/&gt;格式：HGETALL key&lt;br/&gt;返回值：以列表形式返回哈希表的字段及字段值。 若 key 不存在，返回空列表。&lt;/p&gt;
&lt;p&gt;5&amp;gt; hincrby 命令：为哈希表 key 中的指定字段的整数值加上增量 increment&lt;br/&gt;格式：HINCRBY key field increment&lt;br/&gt;返回值：执行 HINCRBY 命令之后，哈希表中字段的值。&lt;/p&gt;
&lt;p&gt;6&amp;gt; hincrbyfloat 命令：为哈希表 key 中的指定字段的浮点数值加上增量 increment&lt;br/&gt;格式：HINCRBYFLOAT key field increment&lt;br/&gt;返回值：执行 Hincrbyfloat 命令之后，哈希表中字段的值。&lt;/p&gt;
&lt;p&gt;7&amp;gt; hkeys 命令：获取所有哈希表中的字段&lt;br/&gt;格式：HKEYS key&lt;br/&gt;返回值：包含哈希表中所有字段的列表。 当 key 不存在时，返回一个空列表。&lt;/p&gt;
&lt;p&gt;8&amp;gt; hlen 命令：获取哈希表中字段的数量&lt;br/&gt;格式：HLEN key&lt;br/&gt;返回值：哈希表中字段的数量。 当 key 不存在时，返回 0 。&lt;/p&gt;
&lt;p&gt;9&amp;gt; hmget 命令：获取所有给定字段的值&lt;br/&gt;格式：HMGET key field1 [field2]&lt;br/&gt;返回值：一个包含多个给定字段关联值的表，表值的排列顺序和指定字段的请求顺序一样。&lt;/p&gt;
&lt;p&gt;10&amp;gt; hmset 命令：同时将多个 field-value (域-值)对设置到哈希表 key 中&lt;br/&gt;格式：HMSET key field1 value1 [field2 value2 ]&lt;br/&gt;返回值：如果命令执行成功，返回 OK 。&lt;/p&gt;
&lt;p&gt;11&amp;gt; hset 命令：将哈希表 key 中的字段 field 的值设为 value&lt;br/&gt;格式：HSET key field value&lt;br/&gt;返回值：如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 。&lt;/p&gt;
&lt;p&gt;12&amp;gt; hsetnx 命令：只有在字段 field 不存在时，设置哈希表字段的值&lt;br/&gt;格式：HSETNX key field value&lt;br/&gt;返回值：设置成功，返回 1 。 如果给定字段已经存在且没有操作被执行，返回 0 。&lt;/p&gt;
&lt;p&gt;13&amp;gt; hvals 命令：获取哈希表中所有值&lt;br/&gt;格式：HVALS key&lt;br/&gt;返回值：一个包含哈希表中所有值的表。 当 key 不存在时，返回一个空表。&lt;/p&gt;
&lt;p&gt;14&amp;gt; hscan 命令：迭代哈希表中的键值对&lt;br/&gt;格式：HSCAN key cursor [MATCH pattern] [COUNT count]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　其中，有的是单kv操作有的是指量操作，有的是写操作有的是读操作。从实现上看，大体上很多命令是类似的:&lt;/p&gt;
&lt;p&gt;　　比如： hset/hmset/hincrbyXXX 可以是一类的&lt;/p&gt;
&lt;p&gt;　　比如：hget/hgetall/hexists/hkeys/hmget 可以是一类&lt;/p&gt;
&lt;p&gt;　　注意：以上分法仅是为了让我们看清本质，对实际使用并无实际参考意义。&lt;/p&gt;

&lt;p&gt;所以，我们就挑几个方法来解析下 hash 的操作实现吧。&lt;/p&gt;

&lt;p&gt;零、hash数据结构&lt;/p&gt;
&lt;p&gt;　　hash相关的命令定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;200&quot;&gt;
&lt;pre&gt;
    {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hsetCommand,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wmF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hsetnx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hsetnxCommand,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wmF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hget&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hgetCommand,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hmset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hmsetCommand,-&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hmget&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hmgetCommand,-&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hincrby&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hincrbyCommand,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wmF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hincrbyfloat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hincrbyfloatCommand,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wmF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hdel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hdelCommand,-&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hlen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hlenCommand,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hstrlen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hstrlenCommand,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hkeys&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hkeysCommand,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hvals&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hvalsCommand,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hgetall&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hgetallCommand,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hexists&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hexistsCommand,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hscan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hscanCommand,-&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,NULL,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;},
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ziplist 数据结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; zlentry {
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; prevrawlensize, prevrawlen;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; lensize, len;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; headersize;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; encoding;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;p;
} zlentry;
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))
&lt;span&gt;#define&lt;/span&gt; ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))
&lt;span&gt;#define&lt;/span&gt; ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))
&lt;span&gt;#define&lt;/span&gt; ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
&lt;span&gt;#define&lt;/span&gt; ZIPLIST_END_SIZE        (sizeof(uint8_t))
&lt;span&gt;#define&lt;/span&gt; ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)
&lt;span&gt;#define&lt;/span&gt; ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))
&lt;span&gt;#define&lt;/span&gt; ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)
    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　hashtable 数据结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; dict {
    dictType &lt;/span&gt;*&lt;span&gt;type;
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;privdata;
    dictht ht[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; rehashidx; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; rehashing not in progress if rehashidx == -1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; iterators; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; number of iterators currently running &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
} dict;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; dictht {
    dictEntry &lt;/span&gt;**&lt;span&gt;table;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; size;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; sizemask;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; used;
} dictht;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; dictEntry {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;key;
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;val;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; dictEntry *&lt;span&gt;next;
} dictEntry;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一、hset 设置单个 field -&amp;gt; value&lt;/p&gt;
&lt;p&gt;　　“增删改查”中的“增改” 就是它了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;177&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c, set key field value&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; hsetCommand(client *&lt;span&gt;c) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; update;
    robj &lt;/span&gt;*&lt;span&gt;o;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 查找hash的key是否存在，不存在则新建一个，然后在其上进行数据操作&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((o = hashTypeLookupWriteOrCreate(c,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;])) == NULL) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 检查2-3个参数是否需要将简单版（ziplist）hash表转换为复杂的hash表，转换后的表通过 o-&amp;gt;ptr 体现&lt;/span&gt;
    hashTypeTryConversion(o,c-&amp;gt;argv,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. 添加kv到 o 的hash表中&lt;/span&gt;
    update = hashTypeSet(o,c-&amp;gt;argv[&lt;span&gt;2&lt;/span&gt;]-&amp;gt;ptr,c-&amp;gt;argv[&lt;span&gt;3&lt;/span&gt;]-&amp;gt;&lt;span&gt;ptr,HASH_SET_COPY);
    addReply(c, update &lt;/span&gt;?&lt;span&gt; shared.czero : shared.cone);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变更命令传播&lt;/span&gt;
    signalModifiedKey(c-&amp;gt;db,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
    notifyKeyspaceEvent(NOTIFY_HASH,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;],c-&amp;gt;db-&amp;gt;&lt;span&gt;id);
    server.dirty&lt;/span&gt;++&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 获取db外部的key, 即整体hash数据实例
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c&lt;/span&gt;
robj *hashTypeLookupWriteOrCreate(client *c, robj *&lt;span&gt;key) {
    robj &lt;/span&gt;*o = lookupKeyWrite(c-&amp;gt;&lt;span&gt;db,key);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o ==&lt;span&gt; NULL) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处创建的hashObject是以 ziplist 形式的&lt;/span&gt;
        o =&lt;span&gt; createHashObject();
        dbAdd(c&lt;/span&gt;-&amp;gt;&lt;span&gt;db,key,o);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不是hash类型的键已存在，不可覆盖，返回错误&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (o-&amp;gt;type !=&lt;span&gt; OBJ_HASH) {
            addReply(c,shared.wrongtypeerr);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; object.c, 创建hashObject, 以 ziplist 形式创建&lt;/span&gt;
robj *createHashObject(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *zl =&lt;span&gt; ziplistNew();
    robj &lt;/span&gt;*o =&lt;span&gt; createObject(OBJ_HASH, zl);
    o&lt;/span&gt;-&amp;gt;encoding =&lt;span&gt; OBJ_ENCODING_ZIPLIST;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist.c&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;createList() {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *zl =&lt;span&gt; ziplistNew();
    zl &lt;/span&gt;= ziplistPush(zl, (unsigned &lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;, ZIPLIST_TAIL);
    zl &lt;/span&gt;= ziplistPush(zl, (unsigned &lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;quux&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;, ZIPLIST_TAIL);
    zl &lt;/span&gt;= ziplistPush(zl, (unsigned &lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;, ZIPLIST_HEAD);
    zl &lt;/span&gt;= ziplistPush(zl, (unsigned &lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;, ZIPLIST_TAIL);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; zl;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 检查参数，是否需要将 ziplist 形式的hash表转换为真正的hash表&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Check the length of a number of objects to see if we need to convert a
 * ziplist to a real hash. Note that we only check string encoded objects
 * as their string length can be queried in constant time. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; hashTypeTryConversion(robj *o, robj **argv, &lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; end) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o-&amp;gt;encoding != OBJ_ENCODING_ZIPLIST) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = start; i &amp;lt;= end; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数大于设置的 hash_max_ziplist_value (默认: 64)时，会直接将 ziplist 转换为 ht
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; OBJ_ENCODING_RAW, OBJ_ENCODING_EMBSTR
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环检查参数，只要发生了一次转换就结束检查（没必要继续了）&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (sdsEncodedObject(argv[i]) &amp;amp;&amp;amp;&lt;span&gt;
            sdslen(argv[i]&lt;/span&gt;-&amp;gt;ptr) &amp;gt;&lt;span&gt; server.hash_max_ziplist_value)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个转换过程很有意思，我们深入看看&lt;/span&gt;
&lt;span&gt;            hashTypeConvert(o, OBJ_ENCODING_HT);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c, 转换编码方式 (如上, ziplist -&amp;gt; ht)&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; hashTypeConvert(robj *o, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; enc) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处我们只处理这种情况&lt;/span&gt;
&lt;span&gt;        hashTypeConvertZiplist(o, enc);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (o-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_HT) {
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Not implemented&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown hash encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c, 转换编码 ziplist 为目标 enc (实际只能是 OBJ_ENCODING_HT) &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; hashTypeConvertZiplist(robj *o, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; enc) {
    serverAssert(o&lt;/span&gt;-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (enc ==&lt;span&gt; OBJ_ENCODING_ZIPLIST) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Nothing to do... &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (enc ==&lt;span&gt; OBJ_ENCODING_HT) {
        hashTypeIterator &lt;/span&gt;*&lt;span&gt;hi;
        dict &lt;/span&gt;*&lt;span&gt;dict;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 迭代器创建&lt;/span&gt;
        hi =&lt;span&gt; hashTypeInitIterator(o);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个hash的数据结构就是一个 dict, 从这个级别来说, hash 与 db 是一个级别的&lt;/span&gt;
        dict = dictCreate(&amp;amp;&lt;span&gt;hashDictType, NULL);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次迭代 o, 赋值到 hi-&amp;gt;fptr, hi-&amp;gt;vptr
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次添加到 dict 中&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (hashTypeNext(hi) !=&lt;span&gt; C_ERR) {
            sds key, value;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从 hi-&amp;gt;fptr 中获取key
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从 hi-&amp;gt;vptr 中获取value&lt;/span&gt;
            key =&lt;span&gt; hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);
            value &lt;/span&gt;=&lt;span&gt; hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加到 dict 中&lt;/span&gt;
            ret =&lt;span&gt; dictAdd(dict, key, value);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret !=&lt;span&gt; DICT_OK) {
                serverLogHexDump(LL_WARNING,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ziplist with dup elements dump&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    o&lt;/span&gt;-&amp;gt;ptr,ziplistBlobLen(o-&amp;gt;&lt;span&gt;ptr));
                serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ziplist corruption detected&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放迭代器&lt;/span&gt;
&lt;span&gt;        hashTypeReleaseIterator(hi);
        zfree(o&lt;/span&gt;-&amp;gt;&lt;span&gt;ptr);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将变更反映到o对象上返回&lt;/span&gt;
        o-&amp;gt;encoding =&lt;span&gt; OBJ_ENCODING_HT;
        o&lt;/span&gt;-&amp;gt;ptr =&lt;span&gt; dict;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown hash encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.1. 迭代ziplist元素
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c, 迭代器&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Move to the next entry in the hash. Return C_OK when the next entry
 * could be found and C_ERR when the iterator reaches the end. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; hashTypeNext(hashTypeIterator *&lt;span&gt;hi) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hi-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST) {
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;zl;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *fptr, *&lt;span&gt;vptr;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次都是基于原始字符器进行计算偏移
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 迭代的是 fptr,vptr&lt;/span&gt;
        zl = hi-&amp;gt;subject-&amp;gt;&lt;span&gt;ptr;
        fptr &lt;/span&gt;= hi-&amp;gt;&lt;span&gt;fptr;
        vptr &lt;/span&gt;= hi-&amp;gt;&lt;span&gt;vptr;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一次查找时使用index查找，后续则使用 fptr,vptr 进行迭代&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (fptr ==&lt;span&gt; NULL) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Initialize cursor &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            serverAssert(vptr &lt;/span&gt;==&lt;span&gt; NULL);
            fptr &lt;/span&gt;= ziplistIndex(zl, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Advance cursor &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            serverAssert(vptr &lt;/span&gt;!=&lt;span&gt; NULL);
            fptr &lt;/span&gt;=&lt;span&gt; ziplistNext(zl, vptr);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fptr == NULL) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; C_ERR;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Grab pointer to the value (fptr points to the field) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        vptr &lt;/span&gt;=&lt;span&gt; ziplistNext(zl, fptr);
        serverAssert(vptr &lt;/span&gt;!=&lt;span&gt; NULL);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; fptr, vptr now point to the first or next pair &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        hi&lt;/span&gt;-&amp;gt;fptr =&lt;span&gt; fptr;
        hi&lt;/span&gt;-&amp;gt;vptr =&lt;span&gt; vptr;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (hi-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_HT) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((hi-&amp;gt;de = dictNext(hi-&amp;gt;di)) == NULL) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; C_ERR;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown hash encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; C_OK;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist.c, 查找 index 的元素&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Returns an offset to use for iterating with ziplistNext. When the given
 * index is negative, the list is traversed back to front. When the list
 * doesn't contain an element at the provided index, NULL is returned. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ziplistIndex(unsigned &lt;span&gt;char&lt;/span&gt; *zl, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;p;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; prevlensize, prevlen = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小于0时，反向查找&lt;/span&gt;
        index = (-index)-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        p &lt;/span&gt;=&lt;span&gt; ZIPLIST_ENTRY_TAIL(zl);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p[&lt;span&gt;0&lt;/span&gt;] !=&lt;span&gt; ZIP_END) {
            ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (prevlen &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; index--&lt;span&gt;) {
                p &lt;/span&gt;-=&lt;span&gt; prevlen;
                ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
            }
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        p &lt;/span&gt;=&lt;span&gt; ZIPLIST_ENTRY_HEAD(zl);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p[&lt;span&gt;0&lt;/span&gt;] != ZIP_END &amp;amp;&amp;amp; index--&lt;span&gt;) {
            p &lt;/span&gt;+=&lt;span&gt; zipRawEntryLength(p);
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 迭代完成还没找到元素 p[0]=ZIP_END
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; index 超出整体ziplist大小则遍历完成后 index&amp;gt;0&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; (p[&lt;span&gt;0&lt;/span&gt;] == ZIP_END || index &amp;gt; &lt;span&gt;0&lt;/span&gt;) ?&lt;span&gt; NULL : p;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist.c, 由 fptr,vptr 进行迭代元素&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Return pointer to next entry in ziplist.
 *
 * zl is the pointer to the ziplist
 * p is the pointer to the current element
 *
 * The element after 'p' is returned, otherwise NULL if we are at the end. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ziplistNext(unsigned &lt;span&gt;char&lt;/span&gt; *zl, unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;p) {
    ((&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) zl);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; &quot;p&quot; could be equal to ZIP_END, caused by ziplistDelete,
     * and we should return NULL. Otherwise, we should return NULL
     * when the *next* element is ZIP_END (there is no next entry). &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (p[&lt;span&gt;0&lt;/span&gt;] ==&lt;span&gt; ZIP_END) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前指针偏移当前元素长度（根据ziplist协议），即到下一元素指针位置&lt;/span&gt;
    p +=&lt;span&gt; zipRawEntryLength(p);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p[&lt;span&gt;0&lt;/span&gt;] ==&lt;span&gt; ZIP_END) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Return the total number of bytes used by the entry pointed to by 'p'. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt; zipRawEntryLength(unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;p) {
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; prevlensize, encoding, lensize, len;
    ZIP_DECODE_PREVLENSIZE(p, prevlensize);
    ZIP_DECODE_LENGTH(p &lt;/span&gt;+&lt;span&gt; prevlensize, encoding, lensize, len);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; prevlensize + lensize +&lt;span&gt; len;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.2. t_hash.c, 获取 hashTypeIterator 的具体值，写入 vstr, vlen 中&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Return the key or value at the current iterator position as a new
 * SDS string. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
sds hashTypeCurrentObjectNewSds(hashTypeIterator &lt;/span&gt;*hi, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; what) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;vstr;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; vlen;
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; vll;

    hashTypeCurrentObject(hi,what,&lt;/span&gt;&amp;amp;vstr,&amp;amp;vlen,&amp;amp;&lt;span&gt;vll);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (vstr) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sdsnewlen(vstr,vlen);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sdsfromlonglong(vll);
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Higher level function of hashTypeCurrent*() that returns the hash value
 * at current iterator position.
 *
 * The returned element is returned by reference in either *vstr and *vlen if
 * it's returned in string form, or stored in *vll if it's returned as
 * a number.
 *
 * If *vll is populated *vstr is set to NULL, so the caller
 * can always check the function return by checking the return value
 * type checking if vstr == NULL. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; hashTypeCurrentObject(hashTypeIterator *hi, &lt;span&gt;int&lt;/span&gt; what, unsigned &lt;span&gt;char&lt;/span&gt; **vstr, unsigned &lt;span&gt;int&lt;/span&gt; *vlen, &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; *&lt;span&gt;vll) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hi-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST) {
        &lt;/span&gt;*vstr =&lt;span&gt; NULL;
        hashTypeCurrentFromZiplist(hi, what, vstr, vlen, vll);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (hi-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_HT) {
        sds ele &lt;/span&gt;=&lt;span&gt; hashTypeCurrentFromHashTable(hi, what);
        &lt;/span&gt;*vstr = (unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;) ele;
        &lt;/span&gt;*vlen =&lt;span&gt; sdslen(ele);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown hash encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c, 从ziplist中获取某个 hashTypeIterator 的具体值，结果定稿 vstr, vlen&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Get the field or value at iterator cursor, for an iterator on a hash value
 * encoded as a ziplist. Prototype is similar to `hashTypeGetFromZiplist`. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; hashTypeCurrentFromZiplist(hashTypeIterator *hi, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; what,
                                unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; **&lt;span&gt;vstr,
                                unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;vlen,
                                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; *&lt;span&gt;vll)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;

    serverAssert(hi&lt;/span&gt;-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; OBJ_HASH_KEY 从 fptr 中获取, 否则从 vptr 中获取&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (what &amp;amp;&lt;span&gt; OBJ_HASH_KEY) {
        ret &lt;/span&gt;= ziplistGet(hi-&amp;gt;&lt;span&gt;fptr, vstr, vlen, vll);
        serverAssert(ret);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        ret &lt;/span&gt;= ziplistGet(hi-&amp;gt;&lt;span&gt;vptr, vstr, vlen, vll);
        serverAssert(ret);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist.c, &lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Get entry pointed to by 'p' and store in either '*sstr' or 'sval' depending
 * on the encoding of the entry. '*sstr' is always set to NULL to be able
 * to find out whether the string pointer or the integer value was set.
 * Return 0 if 'p' points to the end of the ziplist, 1 otherwise. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ziplistGet(unsigned &lt;span&gt;char&lt;/span&gt; *p, unsigned &lt;span&gt;char&lt;/span&gt; **sstr, unsigned &lt;span&gt;int&lt;/span&gt; *slen, &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; *&lt;span&gt;sval) {
    zlentry entry;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == NULL || p[&lt;span&gt;0&lt;/span&gt;] == ZIP_END) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sstr) *sstr =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按照ziplist的编码协议, 获取头部信息&lt;/span&gt;
    zipEntry(p, &amp;amp;&lt;span&gt;entry);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ZIP_IS_STR(entry.encoding)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sstr) {
            &lt;/span&gt;*slen =&lt;span&gt; entry.len;
            &lt;/span&gt;*sstr = p+&lt;span&gt;entry.headersize;
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sval) {
            &lt;/span&gt;*sval = zipLoadInteger(p+&lt;span&gt;entry.headersize,entry.encoding);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist.c, 解析原始字符串为 zlentry&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Return a struct with all information about an entry. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; zipEntry(unsigned &lt;span&gt;char&lt;/span&gt; *p, zlentry *&lt;span&gt;e) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按照ziplist的编码协议,依次读取 prevrawlensize, prevrawlen&lt;/span&gt;
    ZIP_DECODE_PREVLEN(p, e-&amp;gt;prevrawlensize, e-&amp;gt;&lt;span&gt;prevrawlen);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指向下一位置偏移，按照ziplist的编码协议,依次读取 encoding, lensize, len&lt;/span&gt;
    ZIP_DECODE_LENGTH(p + e-&amp;gt;prevrawlensize, e-&amp;gt;encoding, e-&amp;gt;lensize, e-&amp;gt;&lt;span&gt;len);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 除去header得到 body偏移&lt;/span&gt;
    e-&amp;gt;headersize = e-&amp;gt;prevrawlensize + e-&amp;gt;&lt;span&gt;lensize;
    e&lt;/span&gt;-&amp;gt;p =&lt;span&gt; p;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体header解析如下, 有兴趣的点开瞅瞅:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9b008fb7-64bc-4bb0-898f-7b2e0f40bef0')&quot; readability=&quot;42&quot;&gt;&lt;img id=&quot;code_img_closed_9b008fb7-64bc-4bb0-898f-7b2e0f40bef0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9b008fb7-64bc-4bb0-898f-7b2e0f40bef0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9b008fb7-64bc-4bb0-898f-7b2e0f40bef0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9b008fb7-64bc-4bb0-898f-7b2e0f40bef0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist.c&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Decode the length of the previous element, from the perspective of the entry
 * pointed to by 'ptr'. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析第1个字符为 prevlensize&lt;/span&gt;
&lt;span&gt;    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((prevlensize) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {                                                  \
        (prevlen) &lt;/span&gt;= (ptr)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];                                                  \
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((prevlensize) == &lt;span&gt;5&lt;/span&gt;&lt;span&gt;) {                                           \
        assert(&lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;((prevlensize)) == &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);                                    \
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当ptr[0]&amp;gt;254时，代表内容有点大，需要使用 5个字符保存上一字符长度&lt;/span&gt;
        memcpy(&amp;amp;(prevlen), ((&lt;span&gt;char&lt;/span&gt;*)(ptr)) + &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);                             \
        memrev32ifbe(&lt;/span&gt;&amp;amp;&lt;span&gt;prevlen);                                                \
    }                                                                          \
} &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Decode the number of bytes required to store the length of the previous
 * element, from the perspective of the entry pointed to by 'ptr'. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
    &lt;span&gt;if&lt;/span&gt; ((ptr)[&lt;span&gt;0&lt;/span&gt;] &amp;lt;&lt;span&gt; ZIP_BIGLEN) {                                               \
        (prevlensize) &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;                                                     \
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {                                                                   \
        (prevlensize) &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;                                                     \
    }                                                                          \
} &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Decode the length encoded in 'ptr'. The 'encoding' variable will hold the
 * entries encoding, the 'lensize' variable will hold the number of bytes
 * required to encode the entries length, and the 'len' variable will hold the
 * entries length. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do {                    \
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析第1个字符为 编码格式 &amp;amp;ZIP_STR_MASK=0xc0&lt;/span&gt;
&lt;span&gt;    ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((encoding) &amp;lt;&lt;span&gt; ZIP_STR_MASK) {                                           \
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0 &amp;lt;&amp;lt; 6 =0
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 具体解析如下代码,&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((encoding) ==&lt;span&gt; ZIP_STR_06B) {                                       \
            (lensize) &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;                                                     \
            (len) &lt;/span&gt;= (ptr)[&lt;span&gt;0&lt;/span&gt;] &amp;amp; &lt;span&gt;0x3f&lt;/span&gt;&lt;span&gt;;                                           \
        } 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1 &amp;lt;&amp;lt; 6 =64&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((encoding) ==&lt;span&gt; ZIP_STR_14B) {                                  \
            (lensize) &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;                                                     \
            (len) &lt;/span&gt;= (((ptr)[&lt;span&gt;0&lt;/span&gt;] &amp;amp; &lt;span&gt;0x3f&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;8&lt;/span&gt;) | (ptr)[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];                       \
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2 &amp;lt;&amp;lt; 6 =128&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (encoding ==&lt;span&gt; ZIP_STR_32B) {                                    \
            (lensize) &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;                                                     \
            (len) &lt;/span&gt;= ((ptr)[&lt;span&gt;1&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;) |&lt;span&gt;                                         \
                    ((ptr)[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;16&lt;/span&gt;) |&lt;span&gt;                                         \
                    ((ptr)[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] &amp;lt;&amp;lt;  &lt;span&gt;8&lt;/span&gt;) |&lt;span&gt;                                         \
                    ((ptr)[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]);                                                \
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {                                                               \
            assert(NULL);                                                      \
        }                                                                      \
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {                                                                   \
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 超过 0xc0 的长度了，直接使用 1,2,3,4 表示len&lt;/span&gt;
        (lensize) = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;                                                         \
        (len) &lt;/span&gt;=&lt;span&gt; zipIntSize(encoding);                                          \
    }                                                                          \
} &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Extract the encoding from the byte pointed by 'ptr' and set it into
 * 'encoding'. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; ZIP_ENTRY_ENCODING(ptr, encoding) do {  \&lt;span&gt;
    (encoding) &lt;/span&gt;= (ptr[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]); \
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((encoding) &amp;lt; ZIP_STR_MASK) (encoding) &amp;amp;=&lt;span&gt; ZIP_STR_MASK; \
} &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Different encoding/length possibilities &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; ZIP_STR_MASK 0xc0
&lt;span&gt;#define&lt;/span&gt; ZIP_INT_MASK 0x30
&lt;span&gt;#define&lt;/span&gt; ZIP_STR_06B (0 &amp;lt;&amp;lt; 6)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0x00&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; ZIP_STR_14B (1 &amp;lt;&amp;lt; 6)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0x40&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; ZIP_STR_32B (2 &amp;lt;&amp;lt; 6)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0x80&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; ZIP_INT_16B (0xc0 | 0&amp;lt;&amp;lt;4)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0xc0&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; ZIP_INT_32B (0xc0 | 1&amp;lt;&amp;lt;4)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0xd0&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; ZIP_INT_64B (0xc0 | 2&amp;lt;&amp;lt;4)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0xe0&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; ZIP_INT_24B (0xc0 | 3&amp;lt;&amp;lt;4)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0xf0&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; ZIP_INT_8B 0xfe                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0xfe&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　添加kv到对应的key实例中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;147&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. 添加kv到 hash表中, 稍微复杂
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c, 做变更到hash表中&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; hashTypeSet(robj *o, sds field, sds value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; flags) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; update = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 针对ziplist 的添加, 与 ht 编码的添加, 自然是分别处理&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (o-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST) {
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *zl, *fptr, *&lt;span&gt;vptr;

        zl &lt;/span&gt;= o-&amp;gt;&lt;span&gt;ptr;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到ziplist 的头节点指针&lt;/span&gt;
        fptr =&lt;span&gt; ziplistIndex(zl, ZIPLIST_HEAD);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fptr !=&lt;span&gt; NULL) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试查找该 field 对应的元素(从1开始)，如果找到则先删除原值，然后统一添加&lt;/span&gt;
            fptr = ziplistFind(fptr, (unsigned &lt;span&gt;char&lt;/span&gt;*)field, sdslen(field), &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fptr !=&lt;span&gt; NULL) {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Grab pointer to the value (fptr points to the field) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; value 不可以为null, 否则 ziplist 将无法工作&lt;/span&gt;
                vptr =&lt;span&gt; ziplistNext(zl, fptr);
                serverAssert(vptr &lt;/span&gt;!=&lt;span&gt; NULL);
                update &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Delete value &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先删除旧的 value, 再以插入的形式更新, 后续讲删除时再详解&lt;/span&gt;
                zl = ziplistDelete(zl, &amp;amp;&lt;span&gt;vptr);

                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Insert new value &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重点，将value添加到 ziplist 中&lt;/span&gt;
                zl = ziplistInsert(zl, vptr, (unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)value,
                        sdslen(value));
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有找到对应元素，则直接将元素添加到尾部即可&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;update) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Push new field/value pair onto the tail of the ziplist &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            zl &lt;/span&gt;= ziplistPush(zl, (unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)field, sdslen(field),
                    ZIPLIST_TAIL);
            zl &lt;/span&gt;= ziplistPush(zl, (unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)value, sdslen(value),
                    ZIPLIST_TAIL);
        }
        o&lt;/span&gt;-&amp;gt;ptr =&lt;span&gt; zl;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Check if the ziplist needs to be converted to a hash table &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 大于设置的阀值后，转换ziplist为ht(默认: 512)&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (hashTypeLength(o) &amp;gt;&lt;span&gt; server.hash_max_ziplist_entries)
            hashTypeConvert(o, OBJ_ENCODING_HT);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (o-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_HT) {
        dictEntry &lt;/span&gt;*de = dictFind(o-&amp;gt;&lt;span&gt;ptr,field);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (de) {
            sdsfree(dictGetVal(de));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flags &amp;amp;&lt;span&gt; HASH_SET_TAKE_VALUE) {
                dictGetVal(de) &lt;/span&gt;=&lt;span&gt; value;
                value &lt;/span&gt;=&lt;span&gt; NULL;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                dictGetVal(de) &lt;/span&gt;=&lt;span&gt; sdsdup(value);
            }
            update &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            sds f,v;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flags &amp;amp;&lt;span&gt; HASH_SET_TAKE_FIELD) {
                f &lt;/span&gt;=&lt;span&gt; field;
                field &lt;/span&gt;=&lt;span&gt; NULL;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                f &lt;/span&gt;=&lt;span&gt; sdsdup(field);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flags &amp;amp;&lt;span&gt; HASH_SET_TAKE_VALUE) {
                v &lt;/span&gt;=&lt;span&gt; value;
                value &lt;/span&gt;=&lt;span&gt; NULL;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                v &lt;/span&gt;=&lt;span&gt; sdsdup(value);
            }
            dictAdd(o&lt;/span&gt;-&amp;gt;&lt;span&gt;ptr,f,v);
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown hash encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Free SDS strings we did not referenced elsewhere if the flags
     * want this function to be responsible. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (flags &amp;amp; HASH_SET_TAKE_FIELD &amp;amp;&amp;amp;&lt;span&gt; field) sdsfree(field);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flags &amp;amp; HASH_SET_TAKE_VALUE &amp;amp;&amp;amp;&lt;span&gt; value) sdsfree(value);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; update;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.1. 使用ziplist进行保存 field -&amp;gt; value
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist.c, 查找某个 field 是否存在于ziplist中&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Find pointer to the entry equal to the specified entry. Skip 'skip' entries
 * between every comparison. Returns NULL when the field could not be found. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ziplistFind(unsigned &lt;span&gt;char&lt;/span&gt; *p, unsigned &lt;span&gt;char&lt;/span&gt; *vstr, unsigned &lt;span&gt;int&lt;/span&gt; vlen, unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; skip) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; skipcnt = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; vencoding = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; vll = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p[&lt;span&gt;0&lt;/span&gt;] !=&lt;span&gt; ZIP_END) {
        unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; prevlensize, encoding, lensize, len;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;q;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析整个字符串p的 prevlensize,encoding,lensize,len&lt;/span&gt;
&lt;span&gt;        ZIP_DECODE_PREVLENSIZE(p, prevlensize);
        ZIP_DECODE_LENGTH(p &lt;/span&gt;+&lt;span&gt; prevlensize, encoding, lensize, len);
        q &lt;/span&gt;= p + prevlensize +&lt;span&gt; lensize;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传入1, 代表要跳过一个元素, 比如: 查找key时,跳过1个v,然后继续迭代
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳过了n个元素后，再从此开始key的比对过程&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (skipcnt == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Compare current entry with specified entry &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 针对不同的编码使用不同的比较方式&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ZIP_IS_STR(encoding)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到相应的元素，直接返回 p 指针&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (len == vlen &amp;amp;&amp;amp; memcmp(q, vstr, vlen) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Find out if the searched field can be encoded. Note that
                 * we do it only the first time, once done vencoding is set
                 * to non-zero and vll is set to the integer value. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (vencoding == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!zipTryEncoding(vstr, vlen, &amp;amp;vll, &amp;amp;&lt;span&gt;vencoding)) {
                        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; If the entry can't be encoded we set it to
                         * UCHAR_MAX so that we don't retry again the next
                         * time. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                        vencoding &lt;/span&gt;=&lt;span&gt; UCHAR_MAX;
                    }
                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Must be non-zero by now &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    assert(vencoding);
                }

                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Compare current entry with specified entry, do it only
                 * if vencoding != UCHAR_MAX because if there is no encoding
                 * possible for the field it can't be a valid integer. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (vencoding !=&lt;span&gt; UCHAR_MAX) {
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; ll =&lt;span&gt; zipLoadInteger(q, encoding);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ll ==&lt;span&gt; vll) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
                    }
                }
            }

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Reset skip count &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找一次，跳过skip次&lt;/span&gt;
            skipcnt =&lt;span&gt; skip;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Skip entry &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            skipcnt&lt;/span&gt;--&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Move to next entry &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        p &lt;/span&gt;= q +&lt;span&gt; len;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist.c, 添加value到ziplist中
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; zl:ziplist实例, p:要插入的key字串, s:要插入的value字串, len:要插入的value的长度&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Insert an entry at &quot;p&quot;. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ziplistInsert(unsigned &lt;span&gt;char&lt;/span&gt; *zl, unsigned &lt;span&gt;char&lt;/span&gt; *p, unsigned &lt;span&gt;char&lt;/span&gt; *s, unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; slen) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; __ziplistInsert(zl,p,s,slen);
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Insert item at &quot;p&quot;. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *__ziplistInsert(unsigned &lt;span&gt;char&lt;/span&gt; *zl, unsigned &lt;span&gt;char&lt;/span&gt; *p, unsigned &lt;span&gt;char&lt;/span&gt; *s, unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; slen) {
    size_t curlen &lt;/span&gt;=&lt;span&gt; intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; prevlensize, prevlen = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    size_t offset;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nextdiff = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; encoding = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; value = &lt;span&gt;123456789&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; initialized to avoid warning. Using a value
                                    that is easy to see if for some reason
                                    we use it uninitialized. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    zlentry tail;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Find out prevlen for the entry that is inserted. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (p[&lt;span&gt;0&lt;/span&gt;] !=&lt;span&gt; ZIP_END) {
        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *ptail =&lt;span&gt; ZIPLIST_ENTRY_TAIL(zl);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ptail[&lt;span&gt;0&lt;/span&gt;] !=&lt;span&gt; ZIP_END) {
            prevlen &lt;/span&gt;=&lt;span&gt; zipRawEntryLength(ptail);
        }
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; See if the entry can be encoded &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (zipTryEncoding(s,slen,&amp;amp;value,&amp;amp;&lt;span&gt;encoding)) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 'encoding' is set to the appropriate integer encoding &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        reqlen &lt;/span&gt;=&lt;span&gt; zipIntSize(encoding);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 'encoding' is untouched, however zipEncodeLength will use the
         * string length to figure out how to encode it. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        reqlen &lt;/span&gt;=&lt;span&gt; slen;
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; We need space for both the length of the previous entry and
     * the length of the payload. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加上prevlen,encoding,slen 的长度，以计算value的存放位置&lt;/span&gt;
    reqlen +=&lt;span&gt; zipPrevEncodeLength(NULL,prevlen);
    reqlen &lt;/span&gt;+=&lt;span&gt; zipEncodeLength(NULL,encoding,slen);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; When the insert position is not equal to the tail, we need to
     * make sure that the next entry can hold this entry's length in
     * its prevlen field. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    nextdiff &lt;/span&gt;= (p[&lt;span&gt;0&lt;/span&gt;] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Store offset because a realloc may change the address of zl. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储当前偏移位置，以便在扩容之后，还能找到相应位置
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; p = p -zl + zl&lt;/span&gt;
    offset = p-&lt;span&gt;zl;
    zl &lt;/span&gt;= ziplistResize(zl,curlen+reqlen+&lt;span&gt;nextdiff);
    p &lt;/span&gt;= zl+&lt;span&gt;offset;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Apply memory move when necessary and update tail offset. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (p[&lt;span&gt;0&lt;/span&gt;] !=&lt;span&gt; ZIP_END) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Subtract one because of the ZIP_END bytes &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字符拷贝&lt;/span&gt;
        memmove(p+reqlen,p-nextdiff,curlen-offset-&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;nextdiff);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Encode this entry's raw length in the next entry. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        zipPrevEncodeLength(p&lt;/span&gt;+&lt;span&gt;reqlen,reqlen);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Update offset for tail &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        ZIPLIST_TAIL_OFFSET(zl) &lt;/span&gt;=&lt;span&gt;
            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))&lt;/span&gt;+&lt;span&gt;reqlen);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; When the tail contains more than one entry, we need to take
         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the
         * size of prevlen doesn't have an effect on the *tail* offset. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        zipEntry(p&lt;/span&gt;+reqlen, &amp;amp;&lt;span&gt;tail);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p[reqlen+tail.headersize+tail.len] !=&lt;span&gt; ZIP_END) {
            ZIPLIST_TAIL_OFFSET(zl) &lt;/span&gt;=&lt;span&gt;
                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))&lt;/span&gt;+&lt;span&gt;nextdiff);
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This element will be the new tail. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        ZIPLIST_TAIL_OFFSET(zl) &lt;/span&gt;= intrev32ifbe(p-&lt;span&gt;zl);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; When nextdiff != 0, the raw length of the next entry has changed, so
     * we need to cascade the update throughout the ziplist &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (nextdiff != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果本次更新后数据位置变化，则需要更新后续的元素位置&lt;/span&gt;
        offset = p-&lt;span&gt;zl;
        zl &lt;/span&gt;= __ziplistCascadeUpdate(zl,p+&lt;span&gt;reqlen);
        p &lt;/span&gt;= zl+&lt;span&gt;offset;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Write the entry &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 value 写入 p 中, 即写入了 ziplist 中&lt;/span&gt;
    p +=&lt;span&gt; zipPrevEncodeLength(p,prevlen);
    p &lt;/span&gt;+=&lt;span&gt; zipEncodeLength(p,encoding,slen);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ZIP_IS_STR(encoding)) {
        memcpy(p,s,slen);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        zipSaveInteger(p,value,encoding);
    }
    ZIPLIST_INCR_LENGTH(zl,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; zl;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 另外，如果没有旧的元素值时，直接在hash表的末尾添加对应的field-&amp;gt;value 即可
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist.c, 在尾部进行添加元素，没有许多的情况要考虑，但是代码完全复用 __ziplistInsert()&lt;/span&gt;
unsigned &lt;span&gt;char&lt;/span&gt; *ziplistPush(unsigned &lt;span&gt;char&lt;/span&gt; *zl, unsigned &lt;span&gt;char&lt;/span&gt; *s, unsigned &lt;span&gt;int&lt;/span&gt; slen, &lt;span&gt;int&lt;/span&gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt;) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;p;
    p &lt;/span&gt;= (&lt;span&gt;where&lt;/span&gt; == ZIPLIST_HEAD) ?&lt;span&gt; ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; __ziplistInsert(zl,p,s,slen);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　鉴于插入过程稍微复杂，咱们画个图重新理一下思路：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/830731/202001/830731-20200126222740900-688848834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　看起来没ziplist好像没那么简单呢，为啥还要搞这么复杂呢？其实以上代码，仅是在人看来复杂，对机器来说就是更多的移位计算操作，多消耗点cpu就换来了空间上的节省，是可以的。软件本身的复杂性带来了效益，是软件的价值体现，所以，并非所有的东西都是简单即美。&lt;/p&gt;
&lt;p&gt;　　接下来，我们来看一下使用 HT 的编码又如何存储field-&amp;gt;value呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.2. OBJ_ENCODING_HT 的 field -&amp;gt; value 的添加&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (o-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_HT) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hash 表中查找对应的 field&lt;/span&gt;
        dictEntry *de = dictFind(o-&amp;gt;&lt;span&gt;ptr,field);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (de) {
            sdsfree(dictGetVal(de));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hset 时使用 HASH_SET_COPY, 所以直接使用 sdsdup() 即可&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (flags &amp;amp;&lt;span&gt; HASH_SET_TAKE_VALUE) {
                dictGetVal(de) &lt;/span&gt;=&lt;span&gt; value;
                value &lt;/span&gt;=&lt;span&gt; NULL;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                dictGetVal(de) &lt;/span&gt;=&lt;span&gt; sdsdup(value);
            }
            update &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新增 field -&amp;gt; value&lt;/span&gt;
&lt;span&gt;            sds f,v;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flags &amp;amp;&lt;span&gt; HASH_SET_TAKE_FIELD) {
                f &lt;/span&gt;=&lt;span&gt; field;
                field &lt;/span&gt;=&lt;span&gt; NULL;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                f &lt;/span&gt;=&lt;span&gt; sdsdup(field);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flags &amp;amp;&lt;span&gt; HASH_SET_TAKE_VALUE) {
                v &lt;/span&gt;=&lt;span&gt; value;
                value &lt;/span&gt;=&lt;span&gt; NULL;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                v &lt;/span&gt;=&lt;span&gt; sdsdup(value);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加到 hash 表中，前些篇章讲解过，大概就是计算hash，放入v的过程&lt;/span&gt;
            dictAdd(o-&amp;gt;&lt;span&gt;ptr,f,v);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如此看来，OBJ_ENCODING_HT 的实现反而简单了哦。&lt;/p&gt;
&lt;p&gt;　　总结下 hash的插入过程，hash 初始创建时都是使用ziplist 进行容纳元素的，在特定情况下会触发 ziplist 为 ht 的编码方式, 比如:&lt;/p&gt;
&lt;p&gt;　　　　1. hset时自身的参数大于设置值(默认: 64)时直接转换 ziplist -&amp;gt; ht;&lt;/p&gt;
&lt;p&gt;　　　　2. hash表的元素数量大于设置值(默认: 512)时转换 ziplist -&amp;gt; ht;&lt;/p&gt;
&lt;p&gt;　　这么设计的原因是，元素较少且占用空间较小时，使用ziplist会节省空间，且时间消耗与hash表相关并不大，所以 ziplist 是优先的选择了。但是大量数据还是必须要使用hash表存储的。&lt;/p&gt;

&lt;p&gt;二、hmset 批量添加元素&lt;/p&gt;
&lt;p&gt;　　hset 和 hmset 在实现上基本如出一辙，所以简单瞅瞅就得了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c, hmset key f1 v1 f2 v2&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; hmsetCommand(client *&lt;span&gt;c) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    robj &lt;/span&gt;*&lt;span&gt;o;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数个数检查，必定是2n&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((c-&amp;gt;argc % &lt;span&gt;2&lt;/span&gt;) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        addReplyError(c,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wrong number of arguments for HMSET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入方式与 hset 一毛一样，差别在于批量插入时，会循环向 key-hash表中添加field-&amp;gt;value&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((o = hashTypeLookupWriteOrCreate(c,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;])) == NULL) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    hashTypeTryConversion(o,c&lt;/span&gt;-&amp;gt;argv,&lt;span&gt;2&lt;/span&gt;,c-&amp;gt;argc-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环insert&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt; c-&amp;gt;argc; i += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
        hashTypeSet(o,c&lt;/span&gt;-&amp;gt;argv[i]-&amp;gt;ptr,c-&amp;gt;argv[i+&lt;span&gt;1&lt;/span&gt;]-&amp;gt;&lt;span&gt;ptr,HASH_SET_COPY);
    }
    addReply(c, shared.ok);
    signalModifiedKey(c&lt;/span&gt;-&amp;gt;db,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
    notifyKeyspaceEvent(NOTIFY_HASH,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;],c-&amp;gt;db-&amp;gt;&lt;span&gt;id);
    server.dirty&lt;/span&gt;++&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;三、hget 获取某字段值&lt;/p&gt;
&lt;p&gt;　　这种命令的时间复杂度都是 O(1), 所以一般是简单至上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c    &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; hgetCommand(client *&lt;span&gt;c) {
    robj &lt;/span&gt;*&lt;span&gt;o;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找key, 不存在或者类型不一致则直接返回&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((o = lookupKeyReadOrReply(c,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;],shared.nullbulk)) == NULL ||&lt;span&gt;
        checkType(c,o,OBJ_HASH)) &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基于o, 返回 field 对应的元素值即可&lt;/span&gt;
    addHashFieldToReply(c, o, c-&amp;gt;argv[&lt;span&gt;2&lt;/span&gt;]-&amp;gt;&lt;span&gt;ptr);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addHashFieldToReply(client *c, robj *&lt;span&gt;o, sds field) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o ==&lt;span&gt; NULL) {
        addReply(c, shared.nullbulk);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST) {
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *vstr =&lt;span&gt; NULL;
        unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; vlen =&lt;span&gt; UINT_MAX;
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; vll =&lt;span&gt; LLONG_MAX;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基于 ziplist, &lt;/span&gt;
        ret = hashTypeGetFromZiplist(o, field, &amp;amp;vstr, &amp;amp;vlen, &amp;amp;&lt;span&gt;vll);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 响应为空&lt;/span&gt;
&lt;span&gt;            addReply(c, shared.nullbulk);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加到输出缓冲&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (vstr) {
                addReplyBulkCBuffer(c, vstr, vlen);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                addReplyBulkLongLong(c, vll);
            }
        }

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (o-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_HT) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hash 表类型则查找 hash 表即可&lt;/span&gt;
        sds value =&lt;span&gt; hashTypeGetFromHashTable(o, field);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加到输出缓冲&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (value ==&lt;span&gt; NULL)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 响应为空&lt;/span&gt;
&lt;span&gt;            addReply(c, shared.nullbulk);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            addReplyBulkCBuffer(c, value, sdslen(value));
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown hash encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c, 从 ziplist 中查找 field 值&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Get the value from a ziplist encoded hash, identified by field.
 * Returns -1 when the field cannot be found. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; hashTypeGetFromZiplist(robj *&lt;span&gt;o, sds field,
                           unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; **&lt;span&gt;vstr,
                           unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;vlen,
                           &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; *&lt;span&gt;vll)
{
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *zl, *fptr = NULL, *vptr =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;

    serverAssert(o&lt;/span&gt;-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST);

    zl &lt;/span&gt;= o-&amp;gt;&lt;span&gt;ptr;
    fptr &lt;/span&gt;=&lt;span&gt; ziplistIndex(zl, ZIPLIST_HEAD);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fptr !=&lt;span&gt; NULL) {
        fptr &lt;/span&gt;= ziplistFind(fptr, (unsigned &lt;span&gt;char&lt;/span&gt;*)field, sdslen(field), &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fptr !=&lt;span&gt; NULL) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Grab pointer to the value (fptr points to the field) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            vptr &lt;/span&gt;=&lt;span&gt; ziplistNext(zl, fptr);
            serverAssert(vptr &lt;/span&gt;!=&lt;span&gt; NULL);
        }
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (vptr !=&lt;span&gt; NULL) {
        ret &lt;/span&gt;=&lt;span&gt; ziplistGet(vptr, vstr, vlen, vll);
        serverAssert(ret);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c, 从hash表中查找 field 字段的值&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Get the value from a hash table encoded hash, identified by field.
 * Returns NULL when the field cannot be found, otherwise the SDS value
 * is returned. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
sds hashTypeGetFromHashTable(robj &lt;/span&gt;*&lt;span&gt;o, sds field) {
    dictEntry &lt;/span&gt;*&lt;span&gt;de;

    serverAssert(o&lt;/span&gt;-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_HT);

    de &lt;/span&gt;= dictFind(o-&amp;gt;&lt;span&gt;ptr, field);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (de == NULL) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dictGetVal(de);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;四、hmget 批量获取值&lt;/p&gt;
&lt;p&gt;　　与hget如出一辙。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; hmgetCommand(client *&lt;span&gt;c) {
    robj &lt;/span&gt;*&lt;span&gt;o;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Don't abort when the key cannot be found. Non-existing keys are empty
     * hashes, where HMGET should respond with a series of null bulks. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    o &lt;/span&gt;= lookupKeyRead(c-&amp;gt;db, c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o != NULL &amp;amp;&amp;amp; o-&amp;gt;type !=&lt;span&gt; OBJ_HASH) {
        addReply(c, shared.wrongtypeerr);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环输出值&lt;/span&gt;
    addReplyMultiBulkLen(c, c-&amp;gt;argc-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt; c-&amp;gt;argc; i++&lt;span&gt;) {
        addHashFieldToReply(c, o, c&lt;/span&gt;-&amp;gt;argv[i]-&amp;gt;&lt;span&gt;ptr);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;五、hgetall 获取所有hash的kv&lt;/p&gt;
&lt;p&gt;　　hgetall 和 hmget 方式稍微有点不一样，原因是为了让 hkeysCommand/hvalsCommand 进行复用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; hgetallCommand(client *&lt;span&gt;c) {
    genericHgetallCommand(c,OBJ_HASH_KEY&lt;/span&gt;|&lt;span&gt;OBJ_HASH_VALUE);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; genericHgetallCommand(client *c, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; flags) {
    robj &lt;/span&gt;*&lt;span&gt;o;
    hashTypeIterator &lt;/span&gt;*&lt;span&gt;hi;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; multiplier = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length, count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((o = lookupKeyReadOrReply(c,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;],shared.emptymultibulk)) ==&lt;span&gt; NULL
        &lt;/span&gt;|| checkType(c,o,OBJ_HASH)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flags &amp;amp; OBJ_HASH_KEY) multiplier++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flags &amp;amp; OBJ_HASH_VALUE) multiplier++&lt;span&gt;;

    length &lt;/span&gt;= hashTypeLength(o) *&lt;span&gt; multiplier;
    addReplyMultiBulkLen(c, length);

    hi &lt;/span&gt;=&lt;span&gt; hashTypeInitIterator(o);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (hashTypeNext(hi) !=&lt;span&gt; C_ERR) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flags &amp;amp;&lt;span&gt; OBJ_HASH_KEY) {
            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);
            count&lt;/span&gt;++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flags &amp;amp;&lt;span&gt; OBJ_HASH_VALUE) {
            addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);
            count&lt;/span&gt;++&lt;span&gt;;
        }
    }

    hashTypeReleaseIterator(hi);
    serverAssert(count &lt;/span&gt;==&lt;span&gt; length);
}
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; what) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hi-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST) {
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *vstr =&lt;span&gt; NULL;
        unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; vlen =&lt;span&gt; UINT_MAX;
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; vll =&lt;span&gt; LLONG_MAX;

        hashTypeCurrentFromZiplist(hi, what, &lt;/span&gt;&amp;amp;vstr, &amp;amp;vlen, &amp;amp;&lt;span&gt;vll);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (vstr)
            addReplyBulkCBuffer(c, vstr, vlen);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            addReplyBulkLongLong(c, vll);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (hi-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_HT) {
        sds value &lt;/span&gt;=&lt;span&gt; hashTypeCurrentFromHashTable(hi, what);
        addReplyBulkCBuffer(c, value, sdslen(value));
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown hash encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;六、hincrby 增加x某字段&lt;/p&gt;
&lt;p&gt;　　hincrby key field 1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c, &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; hincrbyCommand(client *&lt;span&gt;c) {
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; value, incr, oldvalue;
    robj &lt;/span&gt;*&lt;span&gt;o;
    sds &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;vstr;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; vlen;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析增加字段值到 incr 中&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (getLongLongFromObjectOrReply(c,c-&amp;gt;argv[&lt;span&gt;3&lt;/span&gt;],&amp;amp;incr,NULL) != C_OK) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取原值或者设置为0&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((o = hashTypeLookupWriteOrCreate(c,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;])) == NULL) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hashTypeGetValue(o,c-&amp;gt;argv[&lt;span&gt;2&lt;/span&gt;]-&amp;gt;ptr,&amp;amp;vstr,&amp;amp;vlen,&amp;amp;value) ==&lt;span&gt; C_OK) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (vstr) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (string2ll((&lt;span&gt;char&lt;/span&gt;*)vstr,vlen,&amp;amp;value) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                addReplyError(c,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hash value is not an integer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Else hashTypeGetValue() already stored it into &amp;amp;value &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        value &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    oldvalue &lt;/span&gt;=&lt;span&gt; value;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((incr &amp;lt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; oldvalue &amp;lt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; incr &amp;lt; (LLONG_MIN-oldvalue)) ||&lt;span&gt;
        (incr &lt;/span&gt;&amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; oldvalue &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; incr &amp;gt; (LLONG_MAX-&lt;span&gt;oldvalue))) {
        addReplyError(c,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;increment or decrement would overflow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将相加后的值重置设置回hash表中&lt;/span&gt;
    value +=&lt;span&gt; incr;
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; =&lt;span&gt; sdsfromlonglong(value);
    hashTypeSet(o,c&lt;/span&gt;-&amp;gt;argv[&lt;span&gt;2&lt;/span&gt;]-&amp;gt;ptr,&lt;span&gt;new&lt;/span&gt;&lt;span&gt;,HASH_SET_TAKE_VALUE);
    addReplyLongLong(c,value);
    signalModifiedKey(c&lt;/span&gt;-&amp;gt;db,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
    notifyKeyspaceEvent(NOTIFY_HASH,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hincrby&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;],c-&amp;gt;db-&amp;gt;&lt;span&gt;id);
    server.dirty&lt;/span&gt;++&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;七、hdel 删除某字段&lt;/p&gt;
&lt;p&gt;　　hdel key field&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_hash.c, &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; hdelCommand(client *&lt;span&gt;c) {
    robj &lt;/span&gt;*&lt;span&gt;o;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j, deleted = &lt;span&gt;0&lt;/span&gt;, keyremoved = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((o = lookupKeyWriteOrReply(c,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;],shared.czero)) == NULL ||&lt;span&gt;
        checkType(c,o,OBJ_HASH)) &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环删除给定字段列表&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;2&lt;/span&gt;; j &amp;lt; c-&amp;gt;argc; j++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hashTypeDelete(o,c-&amp;gt;argv[j]-&amp;gt;&lt;span&gt;ptr)) {
            deleted&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当没有任何元素后，直接将key删除&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (hashTypeLength(o) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                dbDelete(c&lt;/span&gt;-&amp;gt;db,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
                keyremoved &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (deleted) {
        signalModifiedKey(c&lt;/span&gt;-&amp;gt;db,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
        notifyKeyspaceEvent(NOTIFY_HASH,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hdel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;],c-&amp;gt;db-&amp;gt;&lt;span&gt;id);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (keyremoved)
            notifyKeyspaceEvent(NOTIFY_GENERIC,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;],
                                c&lt;/span&gt;-&amp;gt;db-&amp;gt;&lt;span&gt;id);
        server.dirty &lt;/span&gt;+=&lt;span&gt; deleted;
    }
    addReplyLongLong(c,deleted);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 具体删除 field, 同样区分编码类型，不同处理逻辑&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Delete an element from a hash.
 * Return 1 on deleted and 0 on not found. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; hashTypeDelete(robj *&lt;span&gt;o, sds field) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; deleted = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST) {
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *zl, *&lt;span&gt;fptr;

        zl &lt;/span&gt;= o-&amp;gt;&lt;span&gt;ptr;
        fptr &lt;/span&gt;=&lt;span&gt; ziplistIndex(zl, ZIPLIST_HEAD);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fptr !=&lt;span&gt; NULL) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist 删除，依次删除 field, value&lt;/span&gt;
            fptr = ziplistFind(fptr, (unsigned &lt;span&gt;char&lt;/span&gt;*)field, sdslen(field), &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fptr !=&lt;span&gt; NULL) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplistDelete 为原地删除，所以只要调用2次，即把kv删除&lt;/span&gt;
                zl = ziplistDelete(zl,&amp;amp;&lt;span&gt;fptr);
                zl &lt;/span&gt;= ziplistDelete(zl,&amp;amp;&lt;span&gt;fptr);
                o&lt;/span&gt;-&amp;gt;ptr =&lt;span&gt; zl;
                deleted &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            }
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (o-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_HT) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dictDelete((dict*)o-&amp;gt;ptr, field) ==&lt;span&gt; C_OK) {
            deleted &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Always check if the dictionary needs a resize after a delete. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; hash 删除的，可能需要进行缩容操作，这种处理方法相对特殊些&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (htNeedsResize(o-&amp;gt;ptr)) dictResize(o-&amp;gt;&lt;span&gt;ptr);
        }

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown hash encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; deleted;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; server.c, 是否需要进行 resize&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; htNeedsResize(dict *&lt;span&gt;dict) {
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; size, used;

    size &lt;/span&gt;=&lt;span&gt; dictSlots(dict);
    used &lt;/span&gt;=&lt;span&gt; dictSize(dict);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HASHTABLE_MIN_FILL=10, 即使用率小于 1/10 时，可以进行缩容操作了&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; (size &amp;amp;&amp;amp; used &amp;amp;&amp;amp; size &amp;gt; DICT_HT_INITIAL_SIZE &amp;amp;&amp;amp;&lt;span&gt;
            (used&lt;/span&gt;*&lt;span&gt;100&lt;/span&gt;/size &amp;lt;&lt;span&gt; HASHTABLE_MIN_FILL));
}
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，整个hash数据结构的解析算是完整了。总体来说，hash由两种数据结构承载，ziplist在小数据量时使用，稍微复杂，但对于昂贵的内存来说是值得的。hash表在数据量大时使用，容易理解。通过本文的讲解，相信可以验证了你对redis hash 的实现的猜想了。&lt;/p&gt;
</description>
<pubDate>Sun, 26 Jan 2020 14:34:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<og:description>Redis作为nosql数据库，kv string型数据的支持是最基础的，但是如果仅有kv的操作，也不至于有redis的成功。（memcache就是个例子） Redis除了string, 还有hash</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yougewe/p/12234983.html</dc:identifier>
</item>
<item>
<title>造轮子-toast组件的实现(下) - Ories</title>
<link>http://www.cnblogs.com/ories/p/12234961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ories/p/12234961.html</guid>
<description>&lt;p&gt;1.解决 toast 中传入 html 的问题，通过假的 slot 来实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// plugins.js
toast.$slots.default = [message]
// toast.vue
 &amp;lt;div v-html=&quot;$slots.default[0]&quot;&amp;gt;&amp;lt;/div&amp;gt;
// 使用
created() {
    this.$toast('&amp;lt;p&amp;gt;我是&amp;lt;strong&amp;gt;hi&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;',{})
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.在 toast 中加 html 是比较危险的一个动作，所以要加一个选项默认不开启。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// toast.vue
&amp;lt;slot v-if=&quot;!enableHtml&quot;&amp;gt;&amp;lt;/slot&amp;gt;
&amp;lt;div v-else v-html=&quot;$slots.default[0]&quot;&amp;gt;&amp;lt;/div&amp;gt;
// plugin.js，进行传递参数的改写
propsData:toastOptions
// 使用
created() {
  this.$toast('&amp;lt;p&amp;gt;我是&amp;lt;strong&amp;gt;hi&amp;lt;/strong&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;a href=&quot;http://qq.com&quot;&amp;gt;qq&amp;lt;/a&amp;gt;',{
    enableHtml: false
  })
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.flex-shrink的使用,flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.item {
  flex-shrink: &amp;lt;number&amp;gt;; /* default 1 */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。如果数值越大，缩小比例越大。&lt;/p&gt;
&lt;p&gt;4.line的高度问题，如果高度写了最小高度，那么子元素的height%就不生效了。用js去操作line的高度。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// toast.vue
&amp;lt;div class=&quot;toast&quot; ref=&quot;wrapper&quot;&amp;gt;
    &amp;lt;div class=&quot;line&quot; ref=&quot;line&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

mounted() {
  this.$nextTick(()=&amp;gt;{
    this.$refs.line.style.height = `${this.$refs.wrapper.getBoundingClientRect().height}px`
  })
}, // 这个计较太trick&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;debugger的技巧，如果眼睛观察到的是0，但是打印出来不是0，可能就是异步的问题。&lt;/p&gt;
&lt;p&gt;5.增加toast的位置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// toast.vue
props: {
  position: {
    type: String,
    default: 'top',
    validator(value){
      return ['top', 'bottom', 'middle'].indexOf(value) &amp;gt;= 0
    }
  }
},
computed:{
  toastClasses(){
    return {
      [`position-${this.position}`]:true
    }
  }
}
// 使用
this.$toast('你的智商需要充值', {
  position: 'bottom'
})
// plugin.js
export default {
  install(Vue, options){
    Vue.prototype.$toast = function (message, toastOptions) {
      let Constructor = Vue.extend(Toast)
      let toast = new Constructor({
        propsData:toastOptions // 在这里将position传进去
      })
      toast.$slots.default = [message]
      toast.$mount()
      document.body.appendChild(toast.$el)
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6.开始做如果已经有一个toast就把之前那个干掉，再出现。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先写一个函数&lt;/li&gt;
&lt;li&gt;给函数取一个名字&lt;/li&gt;
&lt;li&gt;把参数提出来&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;// plugin.js
import Toast from './toast'

let currentToast

export default {
  install(Vue, options){
    Vue.prototype.$toast = function (message, toastOptions) {
      if(currentToast){
        currentToast.close()
      }
      currentToast = createToast({Vue,message, propsData: toastOptions})
    }
  }
}

/* helpers */
function createToast ({Vue,message,propsData}){
  let Constructor = Vue.extend(Toast)
  let toast = new Constructor({propsData})
  toast.$slots.default = [message]
  toast.$mount()
  document.body.appendChild(toast.$el)
  return toast
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7.实现动画&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;声明一个动画，然后写到类上面&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;   @keyframes fade {
     0% {opacity: 0; transform: translateY(100%);}
     100% {opacity: 1;transform: translateY(0);}
   } 
   .toast {
     animation: fade 1s;
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;这里有个bug,我们在实现一次的时候是有问题的,如果toast被关闭了，我们不需要重复关闭，而我们写的是不管你之前的toast有没有关闭，只要有值的我们就关闭，那这样就会出现一个问题，点了关闭currentToast还是一个Toast并没有把它变成null，所以要加上一个回调告诉外面，我被关了不要重复关我，代码会多调一次close。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;  // toast.vue
  close() {
    this.$el.remove()
    this.$emit('close')
    this.$destroy()
  }
  // plugin.js
  export default {
    install(Vue, options){
      Vue.prototype.$toast = function (message, toastOptions) {
        if(currentToast){
          currentToast.close()
        }
        currentToast = createToast({Vue,message, propsData: toastOptions,onclose: ()=&amp;gt;{
            currentToast = null
          }
        }) // 加了这句话
      }
    }
  }

  /* helpers */
  function createToast ({Vue,message,propsData,onclose}){
    let Constructor = Vue.extend(Toast)
    let toast = new Constructor({propsData})
    toast.$slots.default = [message]
    toast.$mount()
    toast.$on('close',onclose) // 加了这句话
    document.body.appendChild(toast.$el)
    return toast
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;git相关的钩上，不想管的不用钩上&lt;/li&gt;
&lt;li&gt;回忆bug是如何产生的，默认样式是:transform:translateX(-50%),进入0%时候transform:translateY(100%),它们两会覆盖。有三个方案，解决。
&lt;ul&gt;&lt;li&gt;换一种方式去做居中，但是这种方法是最好的，很难想&lt;/li&gt;
&lt;li&gt;不要用css做动画&lt;/li&gt;
&lt;li&gt;做两个div外面一个居中，里面一个做动画&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为什么不写两个动画帧来控制居中，如果一段代码要背下来，那么一定是有问题的。&lt;/li&gt;
&lt;li&gt;优化三种动画，上下中是不一样的，通过css进行优化。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 26 Jan 2020 14:19:00 +0000</pubDate>
<dc:creator>Ories</dc:creator>
<og:description>前端开发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ories/p/12234961.html</dc:identifier>
</item>
<item>
<title>Dart语言学习( 一)  为什么学习Dart？ - 鸿鹄当高远</title>
<link>http://www.cnblogs.com/jukaiit/p/12234848.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jukaiit/p/12234848.html</guid>
<description>&lt;h2&gt;为什么学习Dart？&lt;/h2&gt;
&lt;p&gt;Google及全球的其他开发者，使用 Dart 开发了一系列高质量、 关键的 iOS、Android 和 web 应用。&lt;/p&gt;
&lt;p&gt;Dart 非常适合移动和 web 应用的开发。&lt;/p&gt;
&lt;h2 class=&quot;core-goals__first&quot;&gt;高效&lt;/h2&gt;
&lt;p&gt;Dart 语法清晰简洁，工具简单而强大。 输入检测可帮助您尽早识别细微错误。&lt;/p&gt;
&lt;h2&gt;快速&lt;/h2&gt;
&lt;p&gt;Dart 提供提前编译优化，以在移动设备和 web 上实现可预测的高性能和快速启动。&lt;/p&gt;
&lt;h2&gt;可移植&lt;/h2&gt;
&lt;p&gt;Dart 可以编译成 ARM 和 x86 代码，因此 Dart 移动应用程序可以在 iOS，Android 及 更高版本上实现本地运行。 对于 web 应用程序，Dart 可以转换为 JavaScript。&lt;/p&gt;
&lt;h2&gt;易学&lt;/h2&gt;
&lt;p&gt;Dart 是面向对象的编程语言，语法风格对于许多现有的开发人员来说都很熟悉。 如果您已经了解 C++，C＃ 或 Java ，那么使用 Dart 也就是分分钟的事情。&lt;/p&gt;
&lt;h2&gt;响应式&lt;/h2&gt;
&lt;p&gt;Dart 可以便捷的进行响应式编程。由于快速对象分配和&lt;a class=&quot;external&quot; href=&quot;https://medium.com/flutter-io/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30&quot;&gt;垃圾收集器&lt;/a&gt;的实现， 对于管理短期对象（比如 UI 小部件）， Dart 更加高效。 Dart 可以通过 &lt;a href=&quot;https://www.dartcn.com/guides/libraries/library-tour#future&quot;&gt;Future &lt;/a&gt;和 &lt;a href=&quot;https://www.dartcn.com/guides/libraries/library-tour#stream&quot;&gt;Stream &lt;/a&gt;的特性和API实现异步编程。&lt;/p&gt;
&lt;h2&gt;Dart &quot; hello world &quot;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Main程序入口&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(){
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制台打印&lt;/span&gt;
  print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 26 Jan 2020 13:15:00 +0000</pubDate>
<dc:creator>鸿鹄当高远</dc:creator>
<og:description>为什么学习Dart？ Google及全球的其他开发者，使用 Dart 开发了一系列高质量、 关键的 iOS、Android 和 web 应用。 Dart 非常适合移动和 web 应用的开发。 高效 D</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jukaiit/p/12234848.html</dc:identifier>
</item>
<item>
<title>性能优化之二：结构体类型的性能优化 - Snow~Forever</title>
<link>http://www.cnblogs.com/cc299/p/12234816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cc299/p/12234816.html</guid>
<description>&lt;p&gt;C#里结构体是值类型，其局部变量的空间分配在栈上。很多同学喜欢用它，是因为它的存储密度高、分配和回收成本非常低。&lt;/p&gt;
&lt;p&gt;但是前几天在查热点的时候，却碰到结构体的性能非常慢，甚至远低于把同样数据结构做成的引用类型。下文对这个问题做了些简化，方便大家理解。&lt;/p&gt;

&lt;p&gt;优化前的源代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结构体声明&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Point2D
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; X { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Y { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }   
    }

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; target = &lt;span&gt;new&lt;/span&gt; Point2D() { X = &lt;span&gt;99&lt;/span&gt;, Y = &lt;span&gt;100&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;热点语句，points 是一个有几百万元素的链表：&lt;/span&gt;
&lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; point2Ds)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (item.Equals(target))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;优化方法很简单，就是在Point2D的结构体声明中，加一个手写的Equals方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;优化后：&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Point2D
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; X { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Y { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Equals(Point2D obj)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj.X == &lt;span&gt;this&lt;/span&gt;.X &amp;amp;&amp;amp; obj.Y == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Y;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;构造一个有1千万元素的points。&lt;/p&gt;
&lt;p&gt;优化前的执行时间（单位：ms）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/808535/202001/808535-20200126201650209-109247240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;优化后的执行时间（单位：ms）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/808535/202001/808535-20200126201736192-1527523039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 前后提升差不多50%。&lt;/p&gt;

&lt;p&gt;查看IL可以发现，&lt;strong&gt;优化后&lt;/strong&gt;是调用的Point2D.Equals方法，也就是我们写的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/808535/202001/808535-20200126200022989-1894854304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 而&lt;strong&gt;优化前&lt;/strong&gt;的IL如下，是调用Object.Equals方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/808535/202001/808535-20200126200001392-895579567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，这两者有什么区别呢？&lt;/p&gt;
&lt;p&gt;可以查看一下struct的Equals方法。由于struct是值类型，它从ValueType继承来，因此Equals方法实际是执行的ValueType.Equals。&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://referencesource.microsoft.com/mscorlib/system/valuetype.cs.html&quot;&gt;https://referencesource.microsoft.com/mscorlib/system/valuetype.cs.html&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValueType {
 
        [System.Security.SecuritySafeCritical]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Equals (Object obj) {
            BCLDebug.Perf(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ValueType::Equals is not fast.  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;this&lt;/span&gt;.GetType().FullName+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; should override Equals(Object)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt;==&lt;span&gt;obj) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            RuntimeType thisType &lt;/span&gt;= (RuntimeType)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetType();
            RuntimeType thatType &lt;/span&gt;=&lt;span&gt; (RuntimeType)obj.GetType();
 
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (thatType!=&lt;span&gt;thisType) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
 
            Object thisObj &lt;/span&gt;= (Object)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
            Object thisResult, thatResult;
 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if there are no GC references in this object we can avoid reflection 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; and do a fast memcmp&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (CanCompareBits(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; FastEqualsCheck(thisObj, obj);
 
            FieldInfo[] thisFields &lt;/span&gt;= thisType.GetFields(BindingFlags.Instance | BindingFlags.Public |&lt;span&gt; BindingFlags.NonPublic);
 
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;thisFields.Length; i++&lt;span&gt;) {
                thisResult &lt;/span&gt;=&lt;span&gt; ((RtFieldInfo)thisFields[i]).UnsafeGetValue(thisObj);
                thatResult &lt;/span&gt;=&lt;span&gt; ((RtFieldInfo)thisFields[i]).UnsafeGetValue(obj);
                
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (thisResult == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (thatResult != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;thisResult.Equals(thatResult)) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
            }
 
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以发现，ValueType.Equals方法并不是直接比较的两者引用地址是否相等，而是&lt;strong&gt;递归遍历struct的每个字段&lt;/strong&gt;，判断它们是否相等。而在遍历struct字段时，使用了反射取值，这是很耗性能的。&lt;/p&gt;
&lt;p&gt;另外，由于其参数是Object类型，会把传入的struct做一次&lt;strong&gt;装箱&lt;/strong&gt;，这也是热点。&lt;/p&gt;
&lt;p&gt;而我们写的方法，是直接对比属性，而且传入参数是Point2D类型，也不用装箱，可以直接使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结一下&lt;/strong&gt;，在使用结构体的时候，避免装箱，重写Equals方法避免原Equals的反射。&lt;/p&gt;

&lt;p&gt;性能优化相关文章：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;微服务下，接口性能优化的一些总结&quot; href=&quot;https://www.cnblogs.com/cc299/p/11953682.html&quot; target=&quot;_blank&quot;&gt;微服务下，接口性能优化的一些总结&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 26 Jan 2020 13:01:00 +0000</pubDate>
<dc:creator>Snow~Forever</dc:creator>
<og:description>C#里结构体是值类型，其局部变量的空间分配在栈上。很多同学喜欢用它，是因为它的存储密度高、分配和回收成本非常低。 但是前几天在查热点的时候，却碰到结构体的性能非常慢，甚至远低于把同样数据结构做成的引用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cc299/p/12234816.html</dc:identifier>
</item>
<item>
<title>【自制操作系统05】开启内存分页机制 - 闪客sun</title>
<link>http://www.cnblogs.com/flashsun/p/12234807.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashsun/p/12234807.html</guid>
<description>&lt;p&gt;通过前四章的努力，我们成功将控制权转交给了 loader.asm 这个程序，并且从实模式跨越到了保护模式。第四章讲保护模式的时候我说过，这是我们操作系统的第一个精彩之处。但其实这只是针对之前我们进行的只是无意义的输出，以及硬盘的加载等工作。但到了这一章，之前一步步的努力进入到了保护模式，也只能说是做了很多苦力，其实很多代码都是固定的，给我们发挥的空间也不大。&lt;/p&gt;
&lt;p&gt;但是到了本章，可以说终于有能体现出我们设计能力的地方了。&lt;/p&gt;
&lt;h2 id=&quot;一实现分页要做哪些事&quot;&gt;一、实现分页要做哪些事&lt;/h2&gt;
&lt;p&gt;还是先直接简单说要做的事，再说为什么，实现&lt;strong&gt;分页&lt;/strong&gt;要做以下三件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在内存某位置写好&lt;strong&gt;页表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;页目录地址赋值给 &lt;strong&gt;cr3 寄存器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将 cr0 寄存器的 &lt;strong&gt;pg&lt;/strong&gt; 位置 1&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们对比下进入保护模式中实现&lt;strong&gt;段描述符&lt;/strong&gt;机制需要做的三件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在内存某位置写好&lt;strong&gt;段描述符表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;段描述符表地址赋值给 &lt;strong&gt;gdtr 寄存器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将 cr0 寄存器的 &lt;strong&gt;pe&lt;/strong&gt; 位置 1（这个其实是开启保护模式）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;你看，是否是非常相似呢？都是内存某位置准备xxx，把起始地址赋值给一个特定的寄存器，然后将另一个特殊寄存器的某位置 1 表示开启。所以上一章我说过，cpu 与操作系体打配合，这种模式运用得非常多。我们写操作系统的人不用管 cpu 的具体实现，只需要按照指定步骤操作即可，之后硬件会帮我们完成所需要的功能。&lt;/p&gt;
&lt;h2 id=&quot;二为什么要分页&quot;&gt;二、为什么要分页&lt;/h2&gt;
&lt;p&gt;说实话我也想不明白为什么要分页，主要是我说不上来为什么不是其他方式，所以这块我也只能跟着官方说的去理解了。&lt;/p&gt;
&lt;p&gt;如果只用段式管理的话，段大小不一致，且同一个程序逻辑地址和物理地址都是连续的。段大小不一致导致内存有大段有小段，也会留下一些&lt;strong&gt;内存碎片&lt;/strong&gt;，过大的段查不进来，过小的段插进去又会产生更小的碎片。同一个段内所有的程序地址都是连续的，这也导致不灵活，我们希望能有一套机制使得程序所用的&lt;strong&gt;逻辑地址连续，但实际映射到的物理地址并不连续&lt;/strong&gt;，增加这么一个层来解决这个问题。&lt;/p&gt;
&lt;p&gt;我们本讲只是准备一些必要的页表，然后开启页表机制。等到后面多任务的时候才能真正体会到页表的用处以及好处，所以我们姑且先简单理解下，至于具体的好处，其实有好多细节的，等以后用到的时候慢慢体会。&lt;/p&gt;
&lt;h2 id=&quot;三页表长什么样以及虚拟地址到物理地址的转换&quot;&gt;三、页表长什么样以及虚拟地址到物理地址的转换&lt;/h2&gt;
&lt;p&gt;我们可以类比段的转化，我们最初给的地址是 &lt;strong&gt;段选择子：段内偏移值&lt;/strong&gt;，在保护模式下，用段选择子去内存中的段描述符表中，找到段描述符，取出段基址，再+段内偏移地址，得到最终的物理地址。&lt;/p&gt;
&lt;p&gt;页的转化也是类似的，上一步通过段描述符得到的“物理地址”，再开启分页后叫做&lt;strong&gt;逻辑地址&lt;/strong&gt;。这个逻辑地址也是分成 &lt;strong&gt;前半部分：后半部分&lt;/strong&gt; 这种形式，用前半部分的值在页表中寻找并换出一个页地址（也可以理解成基址这个概念），然后再拼接上后半部分的值，得到最终的物理地址。&lt;/p&gt;
&lt;p&gt;只不过，现在的页表方案一般是&lt;strong&gt;二级页表&lt;/strong&gt;，第一级叫&lt;strong&gt;页目录表（PDE）&lt;/strong&gt;，第二级叫&lt;strong&gt;页表（PTE）&lt;/strong&gt;。然后这个逻辑地址就是被看成 &lt;strong&gt;高10位：中间10位：后12位&lt;/strong&gt;。高10位负责再页目录表中找到一个&lt;strong&gt;页目录项&lt;/strong&gt;，这个页目录项的值加上中间10位拼接后的地址去&lt;strong&gt;页表&lt;/strong&gt;中去寻找一个&lt;strong&gt;页表项&lt;/strong&gt;，这个页表项的值，再加上后12位，拼接后的地址就是最终的物理地址。&lt;/p&gt;
&lt;p&gt;12位可以表示 4K，所以也就是一个页可表示的内存大小为 4KB。10位可以表示 1K，所以页目录表中最多有 1024 个页目录项，一个页表中最多有 1024 个页表项，那最大可表示的内存范围就是 1024 * 1024 * 4KB = 4G。其实这也是废话，你可以仔细想想看，不论你分成几级页表，只要是通过这种方式寻址的，只要是一个 32 位的地址，总是可以表示 4G 大小的。只不过通过你的不同分法，可能导致页大小，页目录项数目，页表数目，以及假如你定了 n 级页表后的 n 级页表的页表项数目不同而已。&lt;/p&gt;
&lt;h4 id=&quot;页目录表和页表的数据结构&quot;&gt;页目录表和页表的数据结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/202001/1096103-20200126143205427-2103044126.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;虚拟地址到物理地址的转换&quot;&gt;虚拟地址到物理地址的转换&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/202001/1096103-20200126145222603-275541187.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四页表设计&quot;&gt;四、页表设计&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/202001/1096103-20200126144937053-1913483701.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;我们这样设计页表&quot;&gt;我们这样设计页表：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;页目录表的第 0 项和第 768 项，都对应紧接着的第一个页表，映射了低端 1M 的物理内存（0x00000-0x100000），也就是说逻辑地址的开端 1M 和 3G 以上的第一个 1M 地址，都对应这物理内存的地段 1M。&lt;/li&gt;
&lt;li&gt;页目录表的第 769~1022 项，分别往后对应 254 个页表，不过这些页表还没有写，先空着&lt;/li&gt;
&lt;li&gt;页目录表的第 1023 项，其地址指向该页目录表本身（也就是把页目录表当作页表去理解了），通过这种方式可以访问页目录表本身。（这块其实我也没理解为啥要这么搞，无非就是想用虚拟地址访问到这个页表本身嘛。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;为什么这样设计呢&quot;&gt;为什么这样设计呢？&lt;/h4&gt;
&lt;p&gt;因为我们分页之前的代码（loader）都在低端 1MB 范围内，所以开启分页之后的逻辑地址开始的 1M 也要一一对应上物理地址的开始 1M，所以有了第 0 个页目录项。第 768 个页目录项对应着逻辑地址 3G 以上的 4M（ 0xc0000000～0xc03fffff 不过我们页表只写了 256 项也就是规划了 1M），这是因为我们决定&lt;strong&gt;将操作系统内核写在 3G 以上的 1M 空间里&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们规划，虚拟地址的 0~3G 是用户空间，3~4G 是内核空间，所以我们提前把页目录表的第 769~1022 项建好，至于为什么以后再说。&lt;/p&gt;
&lt;h2 id=&quot;五上代码&quot;&gt;五、上代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;loader.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
;创建页表并初始化（页目录和页表）
PAGE_DIR_TABLE_POS equ 0x100000
call setup_page

;重新加载 gdt，因为已经变成了虚拟地址方式
sgdt [lgdt_value]
mov ebx,[lgdt_value+2]
or dword [ebx+0x18+4],0xc0000000
add dword [lgdt_value+2],0xc0000000
add esp,0xc0000000

;页目录表起始地址存入 cr3 寄存器
mov eax,PAGE_DIR_TABLE_POS
mov cr3,eax

;开启分页
mov eax,cr0
or eax,0x80000000
mov cr0,eax

;重新加载 gdt
lgdt [lgdt_value]

mov byte [gs:0x1e0],'p'
mov byte [gs:0x1e2],'a'
mov byte [gs:0x1e4],'g'
mov byte [gs:0x1e6],'e'
mov byte [gs:0x1ea],'o'
mov byte [gs:0x1ec],'n'

jmp $

setup_page:
;先把页目录占用的空间逐字清零
    mov ecx,4096
    mov esi,0
.clear_page_dir:
    mov byte [PAGE_DIR_TABLE_POS+esi],0
    inc esi
    loop .clear_page_dir
    
;开始创建页目录项（PDE）
.create_pde:
    mov eax,PAGE_DIR_TABLE_POS
    add eax,0x1000; 此时eax为第一个页表的位置及属性
    mov ebx,eax
    or eax,111b
    mov [PAGE_DIR_TABLE_POS],eax
    mov [PAGE_DIR_TABLE_POS+0xc00],eax
    sub eax,0x1000
    mov [PAGE_DIR_TABLE_POS+4*1023],eax

;开始创建页表项（PTE）
    mov ecx,256
    mov esi,0
    mov edx,111b
.create_pte:
    mov [ebx+esi*4],edx
    add edx,4096
    inc esi
    loop .create_pte
    
;创建内核其他页表的页目录项（PDE）
    mov eax,PAGE_DIR_TABLE_POS
    add eax,0x2000
    or eax,111b
    mov ebx,PAGE_DIR_TABLE_POS
    mov ecx,254
    mov esi,769
.create_kernel_pde:
    mov [ebx+esi*4],eax
    inc esi
    add eax,0x1000
    loop .create_kernel_pde
    ret
...&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;六运行&quot;&gt;六、运行&lt;/h2&gt;
&lt;p&gt;Makefile 仍然和上一章一样，所以直接执行 make brun&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1096103/202001/1096103-20200126201212712-853268663.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到分页开启后，成功在屏幕输出了 &lt;strong&gt;pageon&lt;/strong&gt; 字符串&lt;/p&gt;
&lt;h2 id=&quot;七学到这的一些感悟&quot;&gt;七、学到这的一些感悟&lt;/h2&gt;
&lt;p&gt;我之前写过一篇文章 &lt;a href=&quot;https://www.cnblogs.com/flashsun/p/9266343.html&quot;&gt;究竟什么是技术&lt;/a&gt;，还被好多人骂了。我文章里说的就是感觉现在做的事情（Java），以及好多好多所谓的技术，都只是应用而已，甚至觉得只有基础科学，只有研究质子中子电子，这些东西才算是真正的技术，其他的只是应用而已。&lt;/p&gt;
&lt;p&gt;不过现在我知道自己的问题所在了，因为我研究操作系统就是想做点真正的&lt;strong&gt;技术&lt;/strong&gt;。但现在看来，如果还延续当时的想法，像开启分页，进入保护模式，往显卡映射的内存写数据，这些都应该只叫做应用。因为这些的底层原理是 cpu 硬件电路的布线方式，我们的操作系统只是应用了它们，把一些操作封装起来再暴露给用户而已。&lt;/p&gt;
&lt;p&gt;但如果真这样深入下去，其实是没完没了的，你的求知欲又会深入到物理层面，这其实跟计算机技术已经相差甚远了。所以我现在觉得，把&lt;strong&gt;底层细节当作已知，在这上面建立一套完善的体系，这本身就是这一层的技术了&lt;/strong&gt;，每一层有每一层技术的复杂性，不能说越底层的才越接近技术，越接近真理。&lt;/p&gt;
&lt;p&gt;所以，你可以不断深入探索底层的技术，但大可不必对自己所研究层次的知识妄自菲薄。&lt;/p&gt;
&lt;h2 id=&quot;写在最后开源项目和课程规划&quot;&gt;写在最后：开源项目和课程规划&lt;/h2&gt;
&lt;p&gt;如果你对自制一个操作系统感兴趣，不妨跟随这个系列课程看下去，甚至加入我们，一起来开发。&lt;/p&gt;
&lt;h4 id=&quot;参考书籍&quot;&gt;参考书籍&lt;/h4&gt;
&lt;p&gt;《操作系统真相还原》这本书真的赞！强烈推荐&lt;/p&gt;
&lt;h4 id=&quot;项目开源&quot;&gt;项目开源&lt;/h4&gt;
&lt;blockquote readability=&quot;1.875&quot;&gt;
&lt;p&gt;项目开源地址：&lt;a href=&quot;https://gitee.com/sunym1993/flashos&quot; class=&quot;uri&quot;&gt;https://gitee.com/sunym1993/flashos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当你看到该文章时，代码可能已经比文章中的又多写了一些部分了。你可以通过提交记录历史来查看历史的代码，我会慢慢梳理提交历史以及项目说明文档，争取给每一课都准备一个可执行的代码。当然文章中的代码也是全的，采用复制粘贴的方式也是完全可以的。&lt;/p&gt;
&lt;p&gt;如果你有兴趣加入这个自制操作系统的大军，也可以在留言区留下您的联系方式，或者在 gitee 私信我您的联系方式。&lt;/p&gt;
&lt;h4 id=&quot;课程规划&quot;&gt;课程规划&lt;/h4&gt;
&lt;p&gt;本课程打算出系列课程，我写到哪觉得可以写成一篇文章了就写出来分享给大家，最终会完成一个功能全面的操作系统，我觉得这是最好的学习操作系统的方式了。所以中间遇到的各种坎也会写进去，如果你能持续跟进，跟着我一块写，必然会有很好的收货。即使没有，交个朋友也是好的哈哈。&lt;/p&gt;
&lt;p&gt;目前的系列包括&lt;/p&gt;
</description>
<pubDate>Sun, 26 Jan 2020 12:57:00 +0000</pubDate>
<dc:creator>闪客sun</dc:creator>
<og:description>通过前四章的努力，我们成功将控制权转交给了 loader.asm 这个程序，并且从实模式跨越到了保护模式。第四章讲保护模式的时候我说过，这是我们操作系统的第一个精彩之处。但其实这只是针对之前我们进行的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flashsun/p/12234807.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：ARM Cortex-M内核那些事（3.2）- 安全模块看特性(M23/33/35P) - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/12234795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/12234795.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是&lt;strong&gt;ARM Cortex-M功能模块&lt;/strong&gt;，不过侧重点是三款安全特性处理器。&lt;/p&gt;
&lt;p&gt;　　ARM Cortex-M处理器家族发展至今(2020)，已有8代产品，除了上一篇 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/www.cnblogs.com/henjay724/p/8408825.html&quot;&gt;《Cortex-M功能模块看差异》&lt;/a&gt; 介绍过的CM0/CM0+、CM1、CM3、CM4、CM7，还有主打安全特性的CM23、CM33、CM35P。&lt;/p&gt;
&lt;h3 id=&quot;cortex-m安全特性&quot;&gt;1.Cortex-M安全特性&lt;/h3&gt;
&lt;p&gt;　　近几年来， 物联网成为了嵌入式系统开发者们的热门话题。当你提及物联网，安全是每个人都十分关注的话题。嵌入式系统产品需要更好的方案来保证系统的安全。鉴于此，ARM发布了全新ARMv8-M架构，以及基于该架构的三款处理器ARM Cortex-M23/33/35P，引入了如下安全特性：&lt;/p&gt;
&lt;h4 id=&quot;trustzone&quot;&gt;1.1 TrustZone&lt;/h4&gt;
&lt;p&gt;　　ARMv8-M架构包含了一个叫做TrustZone的安全扩展，这项安全加密技术诞生于2004年，之后随着移动应用的普及在Cortex-A系列处理器上发扬光大。而在物联网的嵌入式领域中，一直都使用功耗比更加优秀的Cortex-M处理器并不具有此功能，直到现在Cortex-M23/33的出现，才将这种技术带到了物联网底层中。&lt;br/&gt;　　TrustZone导入了安全和非安全状态的正交划分，非安全状态的软件只能访问非安全状态的存储空间和外围设备，安全软件可以访问两种状态下的所有资源。TrustZone安全机制可以阻止黑客控制整个设备，限制了攻击的影响，还可以实现系统远程恢复。此外ARMv8-M架构也引入了堆栈边界检查和增强的MPU设计，促使额外安全措施的采用。&lt;/p&gt;
&lt;h4 id=&quot;anti-tampering&quot;&gt;1.2 Anti-tampering&lt;/h4&gt;
&lt;p&gt;　　物理攻击的定义可分为侵入式及非侵入式攻击等两大类，侵入式攻击需要拆除芯片封装，利用芯片层级的漏洞发动攻击，而非侵入式攻击，则如旁路攻击（Side-Channel Attacks，简称SCA），在距离芯片很近的情况下，侦测如芯片的耗电或在操作密码时放射出的电磁场等外洩的信息。这两种攻击的目标不外乎在装置植入恶意程序，或是取得内部敏感信息。&lt;br/&gt;　　ARM推出的全新Cortex-M35P，是Cortex-M产品线中首款具备防窜改以及防御物理攻击能力的处理器。Cortex-M35P搭载与SC000、SC300等SecurCore处理器相同的防窜改技术，可帮助嵌入式安全开发人员阻止物理篡改并实现更高级别的安全认证。&lt;/p&gt;
&lt;h3 id=&quot;cortex-m功能模块差异&quot;&gt;2.Cortex-M功能模块差异&lt;/h3&gt;
&lt;p&gt;　　由于CM23是CM0/CM0+的升级，CM33是CM3/CM4的升级，故我们仅针对性地比较原版与升级版内核。&lt;/p&gt;
&lt;h4 id=&quot;cm0-vs-cm23&quot;&gt;2.1 CM0+ vs CM23&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/Cortex-M23-chip-diagram-16.JPG&quot; alt=&quot;cortex-m23&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么CM23到底改进了什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ARMv8-M Baseline CPU内核&lt;/strong&gt;：ARM公司于2016年推出的内核。相比ARMv6-M新增了32-bit硬件除法器。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NVIC嵌套向量中断控制器&lt;/strong&gt;：最大支持240个外部中断，但保持4级抢占优先级（2bit）不变。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AHB5总线&lt;/strong&gt;：一条32bit AMBA-5标准的高性能system总线负责所有Flash、SRAM指令和数据存取。。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MPU存储器保护单元&lt;/strong&gt;：最大可将内存分为16*8个region。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调试模块&lt;/strong&gt;：最大4个硬件断点Breakpoint保持不变，数据监测点Watchpoint最大增为4个。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ETM跟踪单元&lt;/strong&gt;：ETM提供实时指令和数据跟踪。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Systick定时器&lt;/strong&gt;：定时器个数增大到2个。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;　　那么CM23到底增加了什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TrustZone软件安全特性&lt;/strong&gt;：，TrustZone导入了安全和非安全状态的正交划分，非安全状态的软件只能访问非安全状态的存储空间和外围设备，安全软件可以访问两种状态下的所有资源。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;cm4-vs-cm33&quot;&gt;2.2 CM4 vs CM33&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/Cortex-M33-chip-diagram-16.JPG&quot; alt=&quot;cortex-m33&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　前面比较完了CM0+与CM23，再来看看CM33比CM4增强在了哪里：&lt;/p&gt;
&lt;p&gt;　　那么CM33到底改进了什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ARMv8-M Mainline CPU内核&lt;/strong&gt;：ARM公司于2016年推出的内核。相比ARMv7E-M去除了指令分支预测。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NVIC嵌套向量中断控制器&lt;/strong&gt;：最大支持480个外部中断，但保持8-256级优先级（8bit）不变。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2x AHB5总线&lt;/strong&gt;：2条AHB5总线，其中AHB-P外设接口完成原来system总线功能, AHB-S从属接口负责外部总线控制器（如DMA）功能。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MPU存储器保护单元&lt;/strong&gt;：最大可将内存分为16*8个region。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Systick定时器&lt;/strong&gt;：定时器个数增大到2个。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;　　那么CM33到底增加了什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TrustZone软件安全特性&lt;/strong&gt;：TrustZone导入了安全和非安全状态的正交划分，非安全状态的软件只能访问非安全状态的存储空间和外围设备，安全软件可以访问两种状态下的所有资源。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;cm33-vs-cm35p&quot;&gt;2.3 CM33 vs CM35P&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/Cortex-M35P-chip-diagram-16.JPG&quot; alt=&quot;cortex-m35p&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　前面比较完了CM33与CM4，再来看看CM35P比CM33增强在了哪里：&lt;/p&gt;
&lt;p&gt;　　那么CM35P到底改进了什么？&lt;/p&gt;
&lt;p&gt;　　额，CM35P相比CM33并没有改进什么现有模块。&lt;/p&gt;
&lt;p&gt;　　那么CM35P到底增加了什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;I-Cache缓存区&lt;/strong&gt;：即是我们通常理解的L1 Cache，Cache大小为2-16KB。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anti-tampering物理安全特性&lt;/strong&gt;：具备抵御各种物理攻击的设计，能够透过嵌入式安全机制协助开发者防御物理窜改攻击，让产品取得更高层级的安全认证。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
<pubDate>Sun, 26 Jan 2020 12:47:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>ARM Cortex-M处理器家族发展至今(2020)，已有8代产品，除了之前介绍过的CM0/CM0+、CM1、CM3、CM4、CM7，还有主打安全特性的CM23、CM33、CM35P。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/12234795.html</dc:identifier>
</item>
<item>
<title>Nmap使用教程（进阶篇） - H4ck3R_XiX</title>
<link>http://www.cnblogs.com/H4ck3R-XiX/p/12234762.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/H4ck3R-XiX/p/12234762.html</guid>
<description>&lt;h6 id=&quot;什么是防火墙&quot;&gt;什么是防火墙？&lt;/h6&gt;
&lt;p&gt;防火墙是用来控制网络访问的软件或硬件。分为以下两类：1、基于主机的防火墙；2、基于网络的防火墙。&lt;br/&gt;&lt;span&gt;基于主机的防火墙&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是在单台主机上运行的软件，用来控制入站流量（从网络向主机）和出站流量（从主机向网络）。这些软件安装于操作系统之上，常见例子就是Linux上面的iptables和Windows上的Zone Alarm。&lt;br/&gt;&lt;span&gt;基于网络的防火墙&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这些可以是硬件设备或软件，或者硬件设备和软件相结合，用来保护来自于未受保护的入站通信。&lt;/p&gt;
&lt;p&gt;防火墙被安装在受保护和不受保护的网络之间，它们会查看所有的通信，并通过设置规则来控制入站和出站的通信。&lt;/p&gt;
&lt;h2 id=&quot;进阶扫描技术&quot;&gt;进阶扫描技术&lt;/h2&gt;
&lt;p&gt;参考链接：&lt;br/&gt;&lt;a href=&quot;https://nmap.org/book/idlescan.html&quot; class=&quot;uri&quot;&gt;https://nmap.org/book/idlescan.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.nmap.com.cn/doc/manual.shtm&quot; class=&quot;uri&quot;&gt;http://www.nmap.com.cn/doc/manual.shtm&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://seclists.org/nmap-dev/&quot; class=&quot;uri&quot;&gt;https://seclists.org/nmap-dev/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://svn.nmap.org/nmap/&quot; class=&quot;uri&quot;&gt;https://svn.nmap.org/nmap/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Jan 2020 12:34:00 +0000</pubDate>
<dc:creator>H4ck3R_XiX</dc:creator>
<og:description>nmap高级使用技巧,进行防火墙绕过，Web服务审计，Web应用程序渗透测试等。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/H4ck3R-XiX/p/12234762.html</dc:identifier>
</item>
</channel>
</rss>