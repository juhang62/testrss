<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>开源工具，从此告别产品原型文件，编写测试用例竟省了半小时！！！ - 久曲健</title>
<link>http://www.cnblogs.com/longronglang/p/14018198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longronglang/p/14018198.html</guid>
<description>&lt;p&gt;Hi， 盆友你好，我是测试君！与你共同进步的伙伴，祝大家变得更强！&lt;/p&gt;
&lt;p&gt;如果觉得文章还不错，还请给俺加个关注并转发！&lt;/p&gt;
&lt;p&gt;下面为大家分享一款高效率的工具PrototypeManager，先贴出源代码及工具地址，到时还请大家star一下哈。&lt;/p&gt;
&lt;h2 id=&quot;工具地址：&quot;&gt;工具地址：&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-url&quot;&gt;https://github.com/Musule/PrototypeManager
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一、工具用途&quot;&gt;一、工具用途&lt;/h2&gt;
&lt;p&gt;通过一个url地址就能查看产品原型文档，无需下载、解压、维护等一系列操作。&lt;/p&gt;
&lt;h2 id=&quot;二、工具诞生背景&quot;&gt;二、工具诞生背景&lt;/h2&gt;
&lt;p&gt;产品经理发布原型压缩包文件，一般通过QQ、钉钉、邮件发送出来，有的产品则是通过上传到外链平台，但容易造成公司需求设计方案外泄。&lt;/p&gt;
&lt;p&gt;另一个问题，如果遇到产品经理经常更新原型压缩包，那么开发、测试小伙伴就要同步去下载同步，本地打开wiki、下载、解压等一系列操作。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201122075132609-615871762.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个工具或许可以解决这个痛点！&lt;/p&gt;
&lt;p&gt;以后让产品经理把axure导出来的压缩包文件上传到“产品原型压缩包管理工具”，对外发布只要只要给一个url链接地址。&lt;/p&gt;
&lt;p&gt;即使频繁更新原型内容，只要名称链接一致，其他人都无需再做同步操作，只要浏览器打开url即可跳转原型页面。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201122075212622-1379658333.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201122075301214-395021945.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、功能介绍&quot;&gt;三、功能介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;新增分类&lt;/li&gt;
&lt;li&gt;删除分类&lt;/li&gt;
&lt;li&gt;编辑分类&lt;/li&gt;
&lt;li&gt;查询分类&lt;/li&gt;
&lt;li&gt;新增原型版本&lt;/li&gt;
&lt;li&gt;删除原型版本&lt;/li&gt;
&lt;li&gt;编辑原型版本&lt;/li&gt;
&lt;li&gt;查询原型版本&lt;/li&gt;
&lt;li&gt;新建管理员账号、菜单权限&lt;/li&gt;
&lt;li&gt;编辑管理员账号、菜单权限&lt;/li&gt;
&lt;li&gt;导出数据&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;1-新增分类&quot;&gt;1. 新增分类&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201122075330316-1295601607.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-新增原型&quot;&gt;2. 新增原型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201122075359383-813772150.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-新建管理员账号&quot;&gt;3. 新建管理员账号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201122075431844-1098424091.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-管理员登录&quot;&gt;4. 管理员登录&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201122075549725-242290879.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/718867/202011/718867-20201122075623954-600747778.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、闲聊一刻&quot;&gt;四、闲聊一刻&lt;/h2&gt;
&lt;p&gt;打工人，打工魂，打工都是人上人！！！&lt;/p&gt;
&lt;p&gt;这个最近挺火的，正好昨晚看到这个视频，不敢多说，全体打工人来接受洗礼，回见！&lt;/p&gt;

&lt;p&gt;来源：B站UP主 风中二- 侵删&lt;/p&gt;
&lt;p&gt;拒绝白嫖，记得在看|打卡支持 😜！&lt;/p&gt;
</description>
<pubDate>Sun, 22 Nov 2020 00:26:00 +0000</pubDate>
<dc:creator>久曲健</dc:creator>
<og:description>Hi， 盆友你好，我是测试君！与你共同进步的伙伴，祝大家变得更强！ 如果觉得文章还不错，还请给俺加个关注并转发！ 下面为大家分享一款高效率的工具PrototypeManager，先贴出源代码及工具地址</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/longronglang/p/14018198.html</dc:identifier>
</item>
<item>
<title>深入理解r2dbc-mysql - flydean</title>
<link>http://www.cnblogs.com/flydean/p/14018196.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/14018196.html</guid>
<description>&lt;p&gt;mysql应该是我们在日常工作中使用到的一个非常普遍的数据库，虽然mysql现在是oracle公司的，但是它是开源的，市场占有率还是非常高的。&lt;/p&gt;
&lt;p&gt;今天我们将会介绍r2dbc在mysql中的使用。&lt;/p&gt;

&lt;p&gt;要想使用r2dbc-mysql，我们需要添加如下的maven依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;dev.miku&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;r2dbc-mysql&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.8.2.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，如果你想使用snapshot版本的话，可以这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;dev.miku&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;r2dbc-mysql&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${r2dbc-mysql.version}.BUILD-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;repository&amp;gt;
    &amp;lt;id&amp;gt;sonatype-snapshots&amp;lt;/id&amp;gt;
    &amp;lt;name&amp;gt;SonaType Snapshots&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;https://oss.sonatype.org/content/repositories/snapshots&amp;lt;/url&amp;gt;
    &amp;lt;snapshots&amp;gt;
        &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
    &amp;lt;/snapshots&amp;gt;
&amp;lt;/repository&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;创建connectionFactory的代码实际上使用的r2dbc的标准接口，所以和之前讲到的h2的创建代码基本上是一样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// Notice: the query string must be URL encoded
ConnectionFactory connectionFactory = ConnectionFactories.get(
    &quot;r2dbcs:mysql://root:database-password-in-here@127.0.0.1:3306/r2dbc?&quot; +
    &quot;zeroDate=use_round&amp;amp;&quot; +
    &quot;sslMode=verify_identity&amp;amp;&quot; +
    &quot;useServerPrepareStatement=true&amp;amp;&quot; +
    &quot;tlsVersion=TLSv1.3%2CTLSv1.2%2CTLSv1.1&amp;amp;&quot; +
    &quot;sslCa=%2Fpath%2Fto%2Fmysql%2Fca.pem&amp;amp;&quot; +
    &quot;sslKey=%2Fpath%2Fto%2Fmysql%2Fclient-key.pem&amp;amp;&quot; +
    &quot;sslCert=%2Fpath%2Fto%2Fmysql%2Fclient-cert.pem&amp;amp;&quot; +
    &quot;sslKeyPassword=key-pem-password-in-here&quot;
)

// Creating a Mono using Project Reactor
Mono&amp;lt;Connection&amp;gt; connectionMono = Mono.from(connectionFactory.create());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不同的是ConnectionFactories传入的参数不同。&lt;/p&gt;
&lt;p&gt;我们也支持unix domain socket的格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// Minimum configuration for unix domain socket
ConnectionFactory connectionFactory = ConnectionFactories.get(&quot;r2dbc:mysql://root@unix?unixSocket=%2Fpath%2Fto%2Fmysql.sock&quot;)

Mono&amp;lt;Connection&amp;gt; connectionMono = Mono.from(connectionFactory.create());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，我们也支持从ConnectionFactoryOptions中创建ConnectionFactory：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ConnectionFactoryOptions options = ConnectionFactoryOptions.builder()
    .option(DRIVER, &quot;mysql&quot;)
    .option(HOST, &quot;127.0.0.1&quot;)
    .option(USER, &quot;root&quot;)
    .option(PORT, 3306)  // optional, default 3306
    .option(PASSWORD, &quot;database-password-in-here&quot;) // optional, default null, null means has no password
    .option(DATABASE, &quot;r2dbc&quot;) // optional, default null, null means not specifying the database
    .option(CONNECT_TIMEOUT, Duration.ofSeconds(3)) // optional, default null, null means no timeout
    .option(SSL, true) // optional, default sslMode is &quot;preferred&quot;, it will be ignore if sslMode is set
    .option(Option.valueOf(&quot;sslMode&quot;), &quot;verify_identity&quot;) // optional, default &quot;preferred&quot;
    .option(Option.valueOf(&quot;sslCa&quot;), &quot;/path/to/mysql/ca.pem&quot;) // required when sslMode is verify_ca or verify_identity, default null, null means has no server CA cert
    .option(Option.valueOf(&quot;sslCert&quot;), &quot;/path/to/mysql/client-cert.pem&quot;) // optional, default null, null means has no client cert
    .option(Option.valueOf(&quot;sslKey&quot;), &quot;/path/to/mysql/client-key.pem&quot;) // optional, default null, null means has no client key
    .option(Option.valueOf(&quot;sslKeyPassword&quot;), &quot;key-pem-password-in-here&quot;) // optional, default null, null means has no password for client key (i.e. &quot;sslKey&quot;)
    .option(Option.valueOf(&quot;tlsVersion&quot;), &quot;TLSv1.3,TLSv1.2,TLSv1.1&quot;) // optional, default is auto-selected by the server
    .option(Option.valueOf(&quot;sslHostnameVerifier&quot;), &quot;com.example.demo.MyVerifier&quot;) // optional, default is null, null means use standard verifier
    .option(Option.valueOf(&quot;sslContextBuilderCustomizer&quot;), &quot;com.example.demo.MyCustomizer&quot;) // optional, default is no-op customizer
    .option(Option.valueOf(&quot;zeroDate&quot;), &quot;use_null&quot;) // optional, default &quot;use_null&quot;
    .option(Option.valueOf(&quot;useServerPrepareStatement&quot;), true) // optional, default false
    .option(Option.valueOf(&quot;tcpKeepAlive&quot;), true) // optional, default false
    .option(Option.valueOf(&quot;tcpNoDelay&quot;), true) // optional, default false
    .option(Option.valueOf(&quot;autodetectExtensions&quot;), false) // optional, default false
    .build();
ConnectionFactory connectionFactory = ConnectionFactories.get(options);

// Creating a Mono using Project Reactor
Mono&amp;lt;Connection&amp;gt; connectionMono = Mono.from(connectionFactory.create());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者下面的unix domain socket格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// Minimum configuration for unix domain socket
ConnectionFactoryOptions options = ConnectionFactoryOptions.builder()
    .option(DRIVER, &quot;mysql&quot;)
    .option(Option.valueOf(&quot;unixSocket&quot;), &quot;/path/to/mysql.sock&quot;)
    .option(USER, &quot;root&quot;)
    .build();
ConnectionFactory connectionFactory = ConnectionFactories.get(options);

Mono&amp;lt;Connection&amp;gt; connectionMono = Mono.from(connectionFactory.create());
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;上面的例子中，我们使用的是通用的r2dbc api来创建connection，同样的，我们也可以使用特有的MySqlConnectionFactory来创建connection：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;MySqlConnectionConfiguration configuration = MySqlConnectionConfiguration.builder()
    .host(&quot;127.0.0.1&quot;)
    .user(&quot;root&quot;)
    .port(3306) // optional, default 3306
    .password(&quot;database-password-in-here&quot;) // optional, default null, null means has no password
    .database(&quot;r2dbc&quot;) // optional, default null, null means not specifying the database
    .serverZoneId(ZoneId.of(&quot;Continent/City&quot;)) // optional, default null, null means query server time zone when connection init
    .connectTimeout(Duration.ofSeconds(3)) // optional, default null, null means no timeout
    .sslMode(SslMode.VERIFY_IDENTITY) // optional, default SslMode.PREFERRED
    .sslCa(&quot;/path/to/mysql/ca.pem&quot;) // required when sslMode is VERIFY_CA or VERIFY_IDENTITY, default null, null means has no server CA cert
    .sslCert(&quot;/path/to/mysql/client-cert.pem&quot;) // optional, default has no client SSL certificate
    .sslKey(&quot;/path/to/mysql/client-key.pem&quot;) // optional, default has no client SSL key
    .sslKeyPassword(&quot;key-pem-password-in-here&quot;) // optional, default has no client SSL key password
    .tlsVersion(TlsVersions.TLS1_3, TlsVersions.TLS1_2, TlsVersions.TLS1_1) // optional, default is auto-selected by the server
    .sslHostnameVerifier(MyVerifier.INSTANCE) // optional, default is null, null means use standard verifier
    .sslContextBuilderCustomizer(MyCustomizer.INSTANCE) // optional, default is no-op customizer
    .zeroDateOption(ZeroDateOption.USE_NULL) // optional, default ZeroDateOption.USE_NULL
    .useServerPrepareStatement() // Use server-preparing statements, default use client-preparing statements
    .tcpKeepAlive(true) // optional, controls TCP Keep Alive, default is false
    .tcpNoDelay(true) // optional, controls TCP No Delay, default is false
    .autodetectExtensions(false) // optional, controls extension auto-detect, default is true
    .extendWith(MyExtension.INSTANCE) // optional, manual extend an extension into extensions, default using auto-detect
    .build();
ConnectionFactory connectionFactory = MySqlConnectionFactory.from(configuration);

// Creating a Mono using Project Reactor
Mono&amp;lt;Connection&amp;gt; connectionMono = Mono.from(connectionFactory.create());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者下面的unix domain socket方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// Minimum configuration for unix domain socket
MySqlConnectionConfiguration configuration = MySqlConnectionConfiguration.builder()
    .unixSocket(&quot;/path/to/mysql.sock&quot;)
    .user(&quot;root&quot;)
    .build();
ConnectionFactory connectionFactory = MySqlConnectionFactory.from(configuration);

Mono&amp;lt;Connection&amp;gt; connectionMono = Mono.from(connectionFactory.create());
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;首先看一个简单的不带参数的statement:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;connection.createStatement(&quot;INSERT INTO `person` (`first_name`, `last_name`) VALUES ('who', 'how')&quot;)
    .execute(); // return a Publisher include one Result
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后看一个带参数的statement:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;connection.createStatement(&quot;INSERT INTO `person` (`birth`, `nickname`, `show_name`) VALUES (?, ?name, ?name)&quot;)
    .bind(0, LocalDateTime.of(2019, 6, 25, 12, 12, 12))
    .bind(&quot;name&quot;, &quot;Some one&quot;) // Not one-to-one binding, call twice of native index-bindings, or call once of name-bindings.
    .add()
    .bind(0, LocalDateTime.of(2009, 6, 25, 12, 12, 12))
    .bind(1, &quot;My Nickname&quot;)
    .bind(2, &quot;Naming show&quot;)
    .returnGeneratedValues(&quot;generated_id&quot;)
    .execute(); // return a Publisher include two Results.
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意，如果参数是null的话，可以使用bindNull来进行null值的绑定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们看一个批量执行的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;connection.createBatch()
    .add(&quot;INSERT INTO `person` (`first_name`, `last_name`) VALUES ('who', 'how')&quot;)
    .add(&quot;UPDATE `earth` SET `count` = `count` + 1 WHERE `id` = 'human'&quot;)
    .execute(); // return a Publisher include two Results.
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我们看一个执行事务的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;connection.beginTransaction()
    .then(Mono.from(connection.createStatement(&quot;INSERT INTO `person` (`first_name`, `last_name`) VALUES ('who', 'how')&quot;).execute()))
    .flatMap(Result::getRowsUpdated)
    .thenMany(connection.createStatement(&quot;INSERT INTO `person` (`birth`, `nickname`, `show_name`) VALUES (?, ?name, ?name)&quot;)
        .bind(0, LocalDateTime.of(2019, 6, 25, 12, 12, 12))
        .bind(&quot;name&quot;, &quot;Some one&quot;)
        .add()
        .bind(0, LocalDateTime.of(2009, 6, 25, 12, 12, 12))
        .bind(1, &quot;My Nickname&quot;)
        .bind(2, &quot;Naming show&quot;)
        .returnGeneratedValues(&quot;generated_id&quot;)
        .execute())
    .flatMap(Result::getRowsUpdated)
    .then(connection.commitTransaction());
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;为了提升数据库的执行效率，减少建立连接的开销，一般数据库连接都会有连接池的概念，同样的r2dbc也有一个叫做r2dbc-pool的连接池。&lt;/p&gt;
&lt;p&gt;r2dbc-pool的依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;io.r2dbc&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;r2dbc-pool&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;${version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你想使用snapshot版本，也可以这样指定：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;io.r2dbc&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;r2dbc-pool&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;${version}.BUILD-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;repository&amp;gt;
  &amp;lt;id&amp;gt;spring-libs-snapshot&amp;lt;/id&amp;gt;
  &amp;lt;name&amp;gt;Spring Snapshot Repository&amp;lt;/name&amp;gt;
  &amp;lt;url&amp;gt;https://repo.spring.io/libs-snapshot&amp;lt;/url&amp;gt;
&amp;lt;/repository&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下怎么指定数据库连接池：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ConnectionFactory connectionFactory = ConnectionFactories.get(&quot;r2dbc:pool:&amp;lt;my-driver&amp;gt;://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;database&amp;gt;[?maxIdleTime=PT60S[&amp;amp;…]&quot;);

Publisher&amp;lt;? extends Connection&amp;gt; connectionPublisher = connectionFactory.create();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我们只需要在连接URL上面添加pool这个driver即可。&lt;/p&gt;
&lt;p&gt;同样的，我们也可以通过ConnectionFactoryOptions来创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ConnectionFactory connectionFactory = ConnectionFactories.get(ConnectionFactoryOptions.builder()
   .option(DRIVER, &quot;pool&quot;)
   .option(PROTOCOL, &quot;postgresql&quot;) // driver identifier, PROTOCOL is delegated as DRIVER by the pool.
   .option(HOST, &quot;…&quot;)
   .option(PORT, &quot;…&quot;) 
   .option(USER, &quot;…&quot;)
   .option(PASSWORD, &quot;…&quot;)
   .option(DATABASE, &quot;…&quot;)
   .build());

Publisher&amp;lt;? extends Connection&amp;gt; connectionPublisher = connectionFactory.create();

// Alternative: Creating a Mono using Project Reactor
Mono&amp;lt;Connection&amp;gt; connectionMono = Mono.from(connectionFactory.create());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后， 你也可以直接通过创建ConnectionPoolConfiguration来使用线程池：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ConnectionFactory connectionFactory = …;

ConnectionPoolConfiguration configuration = ConnectionPoolConfiguration.builder(connectionFactory)
   .maxIdleTime(Duration.ofMillis(1000))
   .maxSize(20)
   .build();

ConnectionPool pool = new ConnectionPool(configuration);
 

Mono&amp;lt;Connection&amp;gt; connectionMono = pool.create();

// later

Connection connection = …;
Mono&amp;lt;Void&amp;gt; release = connection.close(); // released the connection back to the pool

// application shutdown
pool.dispose();
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10.179310344828&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/r2dbc-mysql-in-depth/&quot;&gt;http://www.flydean.com/r2dbc-mysql-in-depth/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:「程序那些事」最通俗的解读，最深刻的干货，最简洁的教程，众多你不知道的小技巧等你来发现！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 22 Nov 2020 00:00:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 mysql应该是我们在日常工作中使用到的一个非常普遍的数据库，虽然mysql现在是oracle公司的，但是它是开源的，市场占有率还是非常高的。 今天我们将会介绍r2dbc在mysql中的使用。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/14018196.html</dc:identifier>
</item>
<item>
<title>5、Spring Boot缓存 - HOsystem</title>
<link>http://www.cnblogs.com/HOsystem/p/14017938.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HOsystem/p/14017938.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;package&lt;/strong&gt; com.hosystem.cache.service;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt; com.hosystem.cache.bean.Employee;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt; com.hosystem.cache.mapper.EmployeeMapper;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt; org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt; org.springframework.cache.annotation.*;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt; org.springframework.stereotype.Service;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@CacheConfig(cacheNames = &lt;strong&gt;&quot;emp&quot;&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;public class&lt;/strong&gt; EmployeeService {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    @Autowired&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    EmployeeMapper &lt;strong&gt;employeeMapper&lt;/strong&gt;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;em&gt;/**&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *  &lt;/em&gt;&lt;em&gt;将方法的运行结果进行缓存&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;em&gt;下次在调用相同的数据，直接从缓存中获取，不再调用方法&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *  CacheManager&lt;/em&gt;&lt;em&gt;管理多个&lt;/em&gt;&lt;em&gt;cache&lt;/em&gt;&lt;em&gt;组件，对缓存的真正&lt;/em&gt;&lt;em&gt;CRUD&lt;/em&gt;&lt;em&gt;操作在&lt;/em&gt;&lt;em&gt;Cache&lt;/em&gt;&lt;em&gt;组件中，每一个缓存组件有自己唯一一个名字&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*  &lt;/em&gt;&lt;em&gt;工作原理&lt;/em&gt;&lt;em&gt;:&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *      1.&lt;/em&gt;&lt;em&gt;自动配置类&lt;/em&gt;&lt;em&gt;:CacheAutoConfiguration&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *      2.&lt;/em&gt;&lt;em&gt;缓存配置类&lt;/em&gt;&lt;em&gt;:GenericCacheConfiguration&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;JCacheCacheConfiguration&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;EhCacheCacheConfiguration&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;HazelcastCacheConfiguration&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;InfinispanCacheConfiguration&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;CouchbaseCacheConfiguration&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;RedisCacheConfiguration&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;CaffeineCacheConfiguration&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;SimpleCacheConfiguration&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;NoOpCacheConfiguration&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *          org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *          org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *          org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *          org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *          org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *          org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *          org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *          org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *          org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *          org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *      3.&lt;/em&gt;&lt;em&gt;配置类默认生效&lt;/em&gt;&lt;em&gt;:SimpleCacheConfiguration&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *      4.&lt;/em&gt;&lt;em&gt;给容器中注册了一个&lt;/em&gt;&lt;em&gt;cacheManager:ConcurrentMapCacheManager&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *      5.&lt;/em&gt;&lt;em&gt;可以获取、创建&lt;/em&gt;&lt;em&gt;ConcurrentMapCache&lt;/em&gt;&lt;em&gt;类型的缓存组件&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;em&gt;它的作用是将数据保存在&lt;/em&gt;&lt;em&gt;ConcurrentMap&lt;/em&gt;&lt;em&gt;中&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *  &lt;/em&gt;&lt;strong&gt;&lt;em&gt;@Cacheable&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;运行流程&lt;/em&gt;&lt;em&gt;:&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *      1.&lt;/em&gt;&lt;em&gt;方法运行之前，先去查找&lt;/em&gt;&lt;em&gt;Cache(&lt;/em&gt;&lt;em&gt;缓存组件&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;&lt;em&gt;，按照&lt;/em&gt;&lt;em&gt;cacheNames&lt;/em&gt;&lt;em&gt;指定的名字获取&lt;/em&gt;&lt;em&gt;;(CacheManager&lt;/em&gt;&lt;em&gt;先获取相应的缓存&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;&lt;em&gt;第一次获取缓存如果没有该缓存则会自动创建&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*      2.&lt;/em&gt;&lt;em&gt;去&lt;/em&gt;&lt;em&gt;Cache&lt;/em&gt;&lt;em&gt;中查找缓存的内容，使用一个&lt;/em&gt;&lt;em&gt;key&lt;/em&gt;&lt;em&gt;，默认为方法的参数；&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*        (1).key&lt;/em&gt;&lt;em&gt;是按照某种策略生成的&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;em&gt;默认是使用&lt;/em&gt;&lt;em&gt;keyGenerator&lt;/em&gt;&lt;em&gt;生成的&lt;/em&gt;&lt;em&gt;,&lt;/em&gt;&lt;em&gt;默认使用&lt;/em&gt;&lt;em&gt;SimpleKeyGenerator&lt;/em&gt;&lt;em&gt;生成&lt;/em&gt;&lt;em&gt;key&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *        (2).&lt;/em&gt;&lt;em&gt;默认使用&lt;/em&gt;&lt;em&gt;SimpleKeyGenerator&lt;/em&gt;&lt;em&gt;生成&lt;/em&gt;&lt;em&gt;key&lt;/em&gt;&lt;em&gt;默认策略&lt;/em&gt;&lt;em&gt;:&lt;/em&gt;&lt;em&gt;若无参数&lt;/em&gt;&lt;em&gt;,key = new SimpleKey();|&lt;/em&gt;&lt;em&gt;如果有单个参数&lt;/em&gt;&lt;em&gt;,key=&lt;/em&gt;&lt;em&gt;参数值&lt;/em&gt;&lt;em&gt;;|&lt;/em&gt;&lt;em&gt;如果有多个参数&lt;/em&gt;&lt;em&gt;,key = new SimpleKey(params);&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *      3.&lt;/em&gt;&lt;em&gt;若为查找到缓存就调用方法&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*      4.&lt;/em&gt;&lt;em&gt;将方法返回的结果，放入缓存中&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*      &lt;/em&gt;&lt;strong&gt;&lt;em&gt;@Cacheable&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为&lt;/em&gt;&lt;em&gt;key&lt;/em&gt;&lt;em&gt;查找缓存，如果缓存不存在，则运行方法并将结果放入缓存&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*  &lt;/em&gt;&lt;em&gt;核心&lt;/em&gt;&lt;em&gt;:&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *      1.&lt;/em&gt;&lt;em&gt;使用&lt;/em&gt;&lt;em&gt;CacheManager[ConcurrentMapCacheManager]&lt;/em&gt;&lt;em&gt;按照名字获取&lt;/em&gt;&lt;em&gt;cache[ConcurrentHashMapCache]&lt;/em&gt;&lt;em&gt;组件&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*      2.key&lt;/em&gt;&lt;em&gt;使用&lt;/em&gt;&lt;em&gt;keyGenerator&lt;/em&gt;&lt;em&gt;生成&lt;/em&gt;&lt;em&gt;,&lt;/em&gt;&lt;em&gt;默认是&lt;/em&gt;&lt;em&gt;SimpleKeyGenerator&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *  &lt;/em&gt;&lt;em&gt;属性&lt;/em&gt;&lt;em&gt;:value&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;cacheNames&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;key&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;keyGenerator&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;cacheManager&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;cacheResolver&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;condition&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;unless&lt;/em&gt;&lt;em&gt;、&lt;/em&gt;&lt;em&gt;sync&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *      value/cacheNames:&lt;/em&gt;&lt;em&gt;指定缓存组件的名字&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*      key:&lt;/em&gt;&lt;em&gt;缓存数据使用的&lt;/em&gt;&lt;em&gt;key,&lt;/em&gt;&lt;em&gt;可以用它指定参数。默认是使用方法参数的值&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*          SpEL: #id:&lt;/em&gt;&lt;em&gt;参数&lt;/em&gt;&lt;em&gt;id&lt;/em&gt;&lt;em&gt;的值  &lt;/em&gt;&lt;em&gt;#a0 #p0 #root.args[0]&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *      keyGenerator:key&lt;/em&gt;&lt;em&gt;生成器&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;em&gt;可以指定&lt;/em&gt;&lt;em&gt;key&lt;/em&gt;&lt;em&gt;生成器组件&lt;/em&gt;&lt;em&gt;id;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *          &lt;/em&gt;&lt;em&gt;注：&lt;/em&gt;&lt;em&gt;keyGenerator&lt;/em&gt;&lt;em&gt;和&lt;/em&gt;&lt;em&gt;key&lt;/em&gt;&lt;em&gt;只能二选一&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*      cacheManager:&lt;/em&gt;&lt;em&gt;指定缓存管理器&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*      cacheResolver:&lt;/em&gt;&lt;em&gt;指定获取解析器&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*      condition:&lt;/em&gt;&lt;em&gt;指定符合条件情况下缓存&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*      unless&lt;/em&gt;&lt;em&gt;：否定缓存&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;em&gt;当&lt;/em&gt;&lt;em&gt;unless&lt;/em&gt;&lt;em&gt;指定条件为&lt;/em&gt;&lt;em&gt;true&lt;/em&gt;&lt;em&gt;时&lt;/em&gt;&lt;em&gt;,&lt;/em&gt;&lt;em&gt;方法返回值不会被缓存&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;em&gt;可以获取结果进行判断&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*      sync:&lt;/em&gt;&lt;em&gt;是否使用异步模式&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*/&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    //cacheNames = &quot;emp&quot;:&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    //condition = &quot;#id&amp;gt;0&quot;:&lt;/em&gt;&lt;em&gt;只有当&lt;/em&gt;&lt;em&gt;id&amp;gt;0&lt;/em&gt;&lt;em&gt;的时候再进行缓存&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;//condition = &quot;#a0&amp;gt;1&quot;:&lt;/em&gt;&lt;em&gt;只有当第一个参数&lt;/em&gt;&lt;em&gt;&amp;gt;1&lt;/em&gt;&lt;em&gt;时候才进行缓存&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;//unless = &quot;#result==null&quot;:&lt;/em&gt;&lt;em&gt;当返回结果为空时不进行缓存&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;//unless = &quot;#a0==2&quot;:&lt;/em&gt;&lt;em&gt;如果第一个参数的结果为&lt;/em&gt;&lt;em&gt;2&lt;/em&gt;&lt;em&gt;，则结果不缓存&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;//key = &quot;#root.methodName+'['+#id+']'&quot;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    //keyGenerator = &quot;myKeyGenerator&quot;:&lt;/em&gt;&lt;em&gt;自定义&lt;/em&gt;&lt;em&gt;key&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    &lt;/em&gt;@Cacheable(cacheNames = &lt;strong&gt;&quot;emp&quot;&lt;/strong&gt;&lt;em&gt;/*,condition = &quot;#a0&amp;gt;1&quot;,unless = &quot;#a0==2&quot;*/&lt;/em&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;public&lt;/strong&gt; Employee getEmp(Integer id){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        System.&lt;strong&gt;&lt;em&gt;out&lt;/em&gt;&lt;/strong&gt;.println(&lt;strong&gt;&quot;&lt;/strong&gt;&lt;strong&gt;查询&lt;/strong&gt;&lt;strong&gt;&quot;&lt;/strong&gt;+id+&lt;strong&gt;&quot;&lt;/strong&gt;&lt;strong&gt;号员工&lt;/strong&gt;&lt;strong&gt;&quot;&lt;/strong&gt;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        Employee emp = &lt;strong&gt;employeeMapper&lt;/strong&gt;.getEmpById(id);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;strong&gt;return&lt;/strong&gt; emp;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;em&gt;/**&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *  &lt;/em&gt;&lt;strong&gt;&lt;em&gt;@CachePut:&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;调用方法同时更新缓存数据&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;     &lt;/em&gt;&lt;/strong&gt;&lt;em&gt;*  &lt;/em&gt;&lt;em&gt;修改数据库某个数据 同时更新缓存&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *  &lt;/em&gt;&lt;em&gt;运行时间&lt;/em&gt;&lt;em&gt;:&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *    1.&lt;/em&gt;&lt;em&gt;先调用方法&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*    2.&lt;/em&gt;&lt;em&gt;将方法的结果缓存起来&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *  &lt;/em&gt;&lt;em&gt;测试步骤&lt;/em&gt;&lt;em&gt;:&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *    1.&lt;/em&gt;&lt;em&gt;查询&lt;/em&gt;&lt;em&gt;1&lt;/em&gt;&lt;em&gt;号员工&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;em&gt;查询到的结果会放在缓存中&lt;/em&gt; &lt;em&gt;key:1 value:lastName:&lt;/em&gt;&lt;em&gt;张三&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*    2.&lt;/em&gt;&lt;em&gt;查询结果照旧&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*    3.&lt;/em&gt;&lt;em&gt;更新&lt;/em&gt;&lt;em&gt;1&lt;/em&gt;&lt;em&gt;号员工信息&lt;/em&gt;&lt;em&gt;[emp?id=1&amp;amp;lastName=zhangs&amp;amp;gender=0];&lt;/em&gt;&lt;em&gt;将方法的返回值也放进缓存中&lt;/em&gt; &lt;em&gt;key:&lt;/em&gt;&lt;em&gt;传入的&lt;/em&gt;&lt;em&gt;employee&lt;/em&gt;&lt;em&gt;对象 值&lt;/em&gt;&lt;em&gt;:&lt;/em&gt;&lt;em&gt;返回的&lt;/em&gt;&lt;em&gt;employee&lt;/em&gt;&lt;em&gt;对象&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*    4.&lt;/em&gt;&lt;em&gt;查询&lt;/em&gt;&lt;em&gt;1&lt;/em&gt;&lt;em&gt;号员工&lt;/em&gt;&lt;em&gt;;&lt;/em&gt;&lt;em&gt;查询结果为未更新前的数据&lt;/em&gt;&lt;em&gt;[1&lt;/em&gt;&lt;em&gt;号员工的信息没有在缓存中更新&lt;/em&gt;&lt;em&gt;]&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *      key = &quot;#employee.id&quot;:&lt;/em&gt;&lt;em&gt;使用传入参数的员工&lt;/em&gt;&lt;em&gt;id&lt;/em&gt;&lt;em&gt;进行更新&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     &lt;/em&gt;&lt;em&gt;*      key = &quot;#result.id&quot;:&lt;/em&gt;&lt;em&gt;使用返回后的&lt;/em&gt;&lt;em&gt;id&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *      &lt;/em&gt;&lt;em&gt;注&lt;/em&gt;&lt;em&gt;:@Cacheable&lt;/em&gt;&lt;em&gt;的&lt;/em&gt;&lt;em&gt;key&lt;/em&gt;&lt;em&gt;是不能够使用&lt;/em&gt;&lt;em&gt;#result&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     */&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    &lt;/em&gt;@CachePut(value = &lt;strong&gt;&quot;emp&quot;&lt;/strong&gt;,key = &lt;strong&gt;&quot;#result.id&quot;&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;public&lt;/strong&gt; Employee updateEmp(Employee employee){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        System.&lt;strong&gt;&lt;em&gt;out&lt;/em&gt;&lt;/strong&gt;.println(&lt;strong&gt;&quot;update&quot;&lt;/strong&gt; + employee);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;strong&gt;employeeMapper&lt;/strong&gt;.updateEmp(employee);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;strong&gt;return&lt;/strong&gt; employee;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;em&gt;/**&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;     *  &lt;/em&gt;&lt;strong&gt;&lt;em&gt;@CacheEvict:&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;缓存清除&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;     &lt;/em&gt;&lt;/strong&gt;&lt;em&gt;*/&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    //key = &quot;#id&quot;:&lt;/em&gt;&lt;em&gt;指定&lt;/em&gt;&lt;em&gt;key&lt;/em&gt;&lt;em&gt;删除缓存&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;//allEntries = true:&lt;/em&gt;&lt;em&gt;删除缓存中所有数据 默认参数为&lt;/em&gt;&lt;em&gt;false&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    //beforeInvocation=false:&lt;/em&gt;&lt;em&gt;缓存的清除是否在方法之前执行 默认是&lt;/em&gt;&lt;em&gt;false&lt;/em&gt;&lt;em&gt;，即清除缓存操作在方法执行之后执行 如果方法出现异常缓存就不会清除&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    &lt;/em&gt;&lt;em&gt;//beforeInvocation = true:&lt;/em&gt;&lt;em&gt;清除缓存操作在方法执行之前执行 如果方法出现异常缓存也会清除&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;    &lt;/em&gt;@CacheEvict(value = &lt;strong&gt;&quot;emp&quot;&lt;/strong&gt;&lt;em&gt;/*,key = &quot;#id&quot;*//*,allEntries = true*/&lt;/em&gt;,beforeInvocation = &lt;strong&gt;true&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;public void&lt;/strong&gt; deleteEmp(Integer id){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        System.&lt;strong&gt;&lt;em&gt;out&lt;/em&gt;&lt;/strong&gt;.println(&lt;strong&gt;&quot;delete&quot;&lt;/strong&gt;+id);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;//        employeeMapper.deleteEmpById(id);&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;        &lt;/em&gt;&lt;strong&gt;int&lt;/strong&gt; i = 10/0;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    @Caching(&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        cacheable =  {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                @Cacheable(value=&lt;strong&gt;&quot;emp&quot;&lt;/strong&gt;,key=&lt;strong&gt;&quot;#lastName&quot;&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        },&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        put = {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;              @CachePut(value = &lt;strong&gt;&quot;emp&quot;&lt;/strong&gt;,key = &lt;strong&gt;&quot;#result.id&quot;&lt;/strong&gt;),&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;              @CachePut(value = &lt;strong&gt;&quot;emp&quot;&lt;/strong&gt;,key = &lt;strong&gt;&quot;#result.email&quot;&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;public&lt;/strong&gt; Employee getEmpByLastName(String lastName){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;strong&gt;return&lt;/strong&gt; &lt;strong&gt;employeeMapper&lt;/strong&gt;.getEmpByLastName(lastName);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Nov 2020 16:03:00 +0000</pubDate>
<dc:creator>HOsystem</dc:creator>
<og:description>1.JSR107 Java Caching定义了5个核心接口，分别是CachingProvider、CacheManager、Cache、Entry、Expiry。 CachingProvider：定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/HOsystem/p/14017938.html</dc:identifier>
</item>
<item>
<title>Springboot 完整搭建快速入门，必看！ - Java极客思维</title>
<link>http://www.cnblogs.com/xgx120413/p/14017901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xgx120413/p/14017901.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/6d6b71ed61ee45a6a3532e295012ec40.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;手把手教你Springboot微服务项目搭建快速入门，通过本文学习Springboot的搭建快速入门，掌握微服务大致的配置服务，后续将会继续将核心组件引入到项目中，欢迎关注，点赞，转发。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Springboot项目搭建将会从以下几个方面进行项目搭建快速入门&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/30a5a698aaff5184eb2746457c4e027f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一、项目创建&lt;/p&gt;
&lt;p&gt;新建Maven项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/0aff5fad4b81cb75eb28938ef93c31d8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/a49dbb737d39d5173532d0622bc2ea4c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/dbf6e5b7dd73fa6d684c7adaab17df26.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据上面操作即可完成项目搭建&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;二、pom.xml依赖添加&lt;/p&gt;
&lt;p&gt;接下来在pom.xml引入springboot相关依赖&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/3aa76c5a8a3b65f411d2769d21262cdb.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7309bdd733eb096d0584a169c69f3e27.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/25ec6b5c997915f2a9e4d8cd1353f1ad.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引入Springboot相关依赖，完成对项目的依赖配置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;三、新建数据库表&lt;/p&gt;
&lt;p&gt;首先建一张User数据库表&lt;/p&gt;
&lt;p&gt;1. 这里用navicat数据库链接工具&lt;/p&gt;
&lt;p&gt;2. 新建一个springboot数据库（可自行定义）&lt;/p&gt;
&lt;p&gt;3. 创建建表语句：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/72e9fbd0973fd1b5a31be59bd0a50abf.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;四、新建App.java项目启动类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/6368c78203c08d3a2dc2e01e2d47c542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;五、新建Controller&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/cd9c8db966363d4a3ca5dc35cada8373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;行App，在浏览器输入：localhost:8080/hello，发现“hello spring-boot”说明第一步部署成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7f5291e405e97b18745750aaec5bfb80.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;六、集成MyBatis&lt;/p&gt;
&lt;p&gt;1. 在pom.xml文件中引入mybatis 和 数据库（这里用mysql）的依赖&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b22548c7e5d7c7c3a2071cd82c201e5a.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成mapper&lt;/p&gt;
&lt;p&gt;1. 在resources目录下，新建一个application.properties（这里用properties，有兴趣小伙伴可以使用yml文件，这里名字只用application.properties，不要用其他，否则识别不出），增加如下内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/3f9f4aa6f87227c5dc6d046fbab789df.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 创建好对应的model、dao、mapping文件夹，准备MyBatis的生成文件generatorConfig.xml&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/2c6c3451304c07488b5a0aaacc808f48.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 在pom.xml文件里面引入generator的plugins&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/400bb1fdb14eed756cef0613175ee991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 运行generatorConfig.xml文件，生成对应的model、dao、mapping文件，运行方式如下：&lt;/p&gt;
&lt;p&gt;（用这种方式是避免开发人员找不到运行的方式）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e1d1075589a2a1021f9fd265c76d8824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5. 运行后，可以得到下图结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f95e639b35086e79edbfed204b90fa76.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;七、UserMapper.java文件中新增登陆方法：&lt;/p&gt;
&lt;p&gt;1. 新增登陆方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/8f18840c3052ea74331a3e09a96a51b0.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 对应UserMapping.xml文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/702742dad45f5c22a6b1a038c6af8261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;八、 新建service实现方法&lt;/p&gt;
&lt;p&gt;1. IUserService.java 接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/baf74a3ac8c6c79836c07c1d7fabcb05.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. UserServiceImpl.java实现类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/d628320c450c2a4e6b91a238cdb3afa6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. UserController.java类中增加login和register方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/a62339feb9d6fb710692eeb3930d9f05.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动App.java，并运行：&lt;/p&gt;
&lt;p&gt;在浏览器上输入：&lt;a href=&quot;http://localhost:8080/register?username=deer&amp;amp;passwd=123%EF%BC%8C%E6%98%BE%E7%A4%BA%5C%E2%80%9C%E6%B3%A8%E5%86%8C%E6%88%90%E5%8A%9F%5C%E2%80%9D&quot;&gt;localhost:8080/register?username=deer&amp;amp;password=123，显示“注册成功”&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在浏览器上输入：localhost:8080/login?username=deer&amp;amp;password=123，    显示“登陆成功”&lt;/p&gt;
&lt;p&gt;以上就完成了后台的Controller、Service、Dao之间的交互&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;九、实现事务支持&lt;/p&gt;
&lt;p&gt;修改IUserService接口，增加一个新增batchAdd方法，在UserServiceImpl增加相应实现类，在实现类中故意产生一个被0整除得异常&lt;/p&gt;
&lt;p&gt;1. IUserService.java接口中增加batchAdd抽象方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/bf5c77a80cf54f466b9da8fbd42ed5b9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. UserService.java类中实现batchAdd()方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/33a73f69e3b57fa537160feb3454cb13.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 重新运行App.java，在浏览器输入：&lt;/p&gt;
&lt;p&gt;localhost:8080/batchAdd?username=enjoy&amp;amp;password=123&lt;/p&gt;
&lt;p&gt;可以发现在浏览器上出现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/a014fc4f722ad73d342116fbc6b300f1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后检查数据库，发现表里面已经产生了一个错误的数据，产生了事务不一致问题。&lt;/p&gt;

&lt;p&gt;4. 添加事务支持：&lt;/p&gt;
&lt;p&gt;在batchAdd方法上增加@Transactional注解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/55cb7aafdf2e8f9bb6047fb5e64cd23b.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重启服务后，在浏览器上输入：localhost:8080/batchAdd?username=enjoy&amp;amp;password=123&lt;/p&gt;
&lt;p&gt;浏览器还会继续报错，但检查数据库，并没有新增数据，由此可知事务问题已经得到了解决&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;十、全局异常&lt;/p&gt;
&lt;p&gt;通过上面步骤，虽然已经解决了事务问题，但界面上出现这500错误，这对用户来说还是不友好。&lt;/p&gt;
&lt;p&gt;一般在企业里面对这些异常一般都会统一捕获，由一个专门的异常处理类来统一处理。&lt;/p&gt;
&lt;p&gt;1. 异常捕获&lt;/p&gt;
&lt;p&gt;新建全局异常处理类GlobalExceptionHandler.java类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/ddab2d2379eed03e488bbc92e13790f6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重启服务后，在浏览器上输入会出现异常的服务&lt;/p&gt;
&lt;p&gt;localhost:8080/batchAdd?username=enjoy&amp;amp;passwd=123&lt;/p&gt;

&lt;p&gt;界面返回：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/451e74b4ab649cc96acef102bc56b6ff.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. 404页面处理&lt;/p&gt;
&lt;p&gt;在浏览器上故意输错地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:8080/batchAddx?username=enjoy&amp;amp;passwd=123%EF%BC%8C%E5%90%8E%E7%AB%AF%E5%B9%B6%E6%B2%A1%E6%9C%89%E8%BF%99%E6%9C%8D%E5%8A%A1%EF%BC%8C%E8%99%BD%E7%84%B6%E5%B7%B2%E7%BB%8F%E5%81%9A%E4%BA%86%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7&quot;&gt;localhost:8080/batchAddx?username=enjoy&amp;amp;passwd=123，后端并没有这服务，虽然已经做了相关的异常捕获&lt;/a&gt;，但浏览器还是显示了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/73cccf8e02ce240de37c6a51f7b6a06b.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候返回页面非常的不友好，要做404异常处理（其他异常代码一样）。&lt;/p&gt;
&lt;p&gt;在配置这样错误页面的时候，以前是在WEB.XML中进行配置，而在这里，需要有个WebServerFactoryCustomizer的实例进行配置&lt;/p&gt;

&lt;p&gt;3. 在前面建立的GlobalExceptionHandler，新建一个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/590860cdcee53c38416ee6945c1a6256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 新建BaseController.java类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/52e33c54337f1826c507744d77d76a48.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重启服务，在浏览器上输入&lt;/p&gt;
&lt;p&gt;localhost:8080/batchAddx?username=enjoy&amp;amp;passwd=123&lt;/p&gt;
&lt;p&gt;此时，页面返回“404，没有找到页面！”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/1e6102408647912c01c5dbd225a9cb0b.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;十一、静态资源访问&lt;/p&gt;
&lt;p&gt;静态资源：js, css, html, 图片，音视频等&lt;/p&gt;
&lt;p&gt;静态资源路径：是指系统可以直接访问的路径，且路径下的所有文件均可被用户直接读取。&lt;/p&gt;
&lt;p&gt;Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则：&lt;/p&gt;
&lt;p&gt;/static&lt;/p&gt;
&lt;p&gt;/public&lt;/p&gt;
&lt;p&gt;/resources&lt;/p&gt;
&lt;p&gt;/META-INF/resources&lt;/p&gt;
&lt;p&gt;1. 在resources目录下面建立static文件夹，在文件夹里面任意放张图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/c3577d0dd9293b2928f46b22fee9b12f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在地址栏上输入localhost:8080/enjoy.jpg，可以看到图片&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;十二、前端页面&lt;/p&gt;
&lt;p&gt;1. 引擎模板&lt;/p&gt;
&lt;p&gt;SpringBoot 推荐使用模板引擎来渲染html，如果你不是历史遗留项目，一定不要使用JSP，常用的模板引擎很多，有freemark,thymeleaf等，其实都大同小异&lt;/p&gt;
&lt;p&gt;其中springboot 强烈推荐的是用thymeleaf&lt;/p&gt;
&lt;p&gt;pom文件种添加thymeleaf的支持：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/4f7fd7e9628ea41bd89c60dae06c284c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 新建Controller&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/9172723b996078cc059c516cfdbc5cfd.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Springboot默认的模板配置路径为：src/main/resources/templates&lt;/p&gt;
&lt;p&gt;在resources目录里面新建一个templates目录，在目录里面新建testThymeleaf.html文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/78794580b6e5da714ab7337e46cb3a1a.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在浏览器上输入：localhost:8080/tpl/themeleaf，可以看到页面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/171c1d1675066efe91cf76c536e6de15.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;十三、集成Swagger2 构建API文档&lt;/p&gt;
&lt;p&gt;1. Swagger2 的作用&lt;/p&gt;
&lt;p&gt;①. 随项目自动生成强大RESTful API文档，减少工作量&lt;/p&gt;
&lt;p&gt;②. API文档与代码整合在一起，便于同步更新API说明&lt;/p&gt;
&lt;p&gt;③. 页面测试功能来调试每个RESTful API&lt;/p&gt;

&lt;p&gt;修改pom文件，添加swagger2的相关依赖&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f6ccfed4f8e1a8f2341158ce48debafb.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. 新建一个swagger的配置类SwaggerConfig.java&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/dffef9f23da0bea565c7e2b30407f689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3. 新建Controller用于显示相关接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/3f2314b08823e0e1e10bf3776ccefff9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问：http://localhost:8080/swagger-ui.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/091a79c5cc538079f1ae5606abbb49a2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何使用呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/a6425efb6894887edb1527c512d41074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/0408fb0529eca6201504bbfd5f894327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f769fe00e57a52d0798e2e39ecbbca54.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是swagger2的配置和使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;十四、日志集成&lt;/p&gt;
&lt;p&gt;在springboot中默认使用的日志工具是logback,不过在提及具体的日志工具之前要提一个名词，这个名词就是slf4j(Simple Logging Facade For Java)&lt;/p&gt;

&lt;p&gt;百度百科解释&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/slf4j/6408868&quot;&gt;https://baike.baidu.com/item/slf4j/6408868&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;slf4j不是具体的日志解决方案，它有点类似于jdbc,使用了门面模式，是一个针对各类日志的抽象实现，既然是抽象的日志实现，在springboot中肯定不需要额外导入。&lt;/p&gt;

&lt;p&gt;注意：spring-boot-starter中就提供了对spring-boot-starter-logging的依赖&lt;/p&gt;
&lt;p&gt;在spring-boot-starter-logging中可以看到以及集成了slf4j与具体实现logback的默认支持&lt;/p&gt;

&lt;p&gt;1. 修改UserController&lt;/p&gt;
&lt;p&gt;import org.slf4j.Logger;&lt;/p&gt;
&lt;p&gt;import org.slf4j.LoggerFactory;&lt;/p&gt;
&lt;p&gt;private final Logger logger = LoggerFactory.getLogger(UserController.class);&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/10b2f2df37d0c3767b830f8301ca68a5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在浏览器上输入：localhost:8080/hello，可以看控制台日志的输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/9dc95eeb9518e5907a4d5c6ea14bc2c0.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. 日志级别&lt;/p&gt;
&lt;p&gt;修改controller 把日志的输出改成&lt;/p&gt;
&lt;p&gt;logger.debug(&quot;这个一个hello日志&quot;);&lt;/p&gt;

&lt;p&gt;这个时候重启，再调用，发现后台并不会有任何输出，这原因是日志级别在作祟&lt;/p&gt;

&lt;p&gt;默认情况下，Spring Boot 配置的是INFO 日志级别，也就是会输出INFO级别以上的日志(ERROR, WARN, INFO)。&lt;/p&gt;
&lt;p&gt;如果需要 Debug 级别的日志。在 src/main/resources/application.properties 中配置。&lt;/p&gt;
&lt;p&gt;debug=true&lt;/p&gt;
&lt;p&gt;此外，配置 logging.level.* 来具体输出哪些包的日志级别。&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;p&gt;logging.level.root=INFO&lt;/p&gt;
&lt;p&gt;logging.level.org.springframework.web=DEBUG&lt;/p&gt;
&lt;p&gt;logging.level.cn.cansluck.controller=DEBUG&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f2042e70183b454e9de1faf8747200d2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候，包括springframework.web以及cn.cansluck.controller的debug日志都可以输出来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/3b55e2905866e6c9d18cb22089e557b5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. 日志文件&lt;/p&gt;
&lt;p&gt;一般情况下，springboot日志只会输出到控制台，并不会写入到日志文件，但是，在一些正式环境的应用中，我们需要通过在 application.properites 文件中配置 logging.file 文件名称和 logging.path 文件路径，将日志输出到日志文件中。&lt;/p&gt;
&lt;p&gt;logging.path = /var/tmp&lt;/p&gt;
&lt;p&gt;logging.file = xxx.log&lt;/p&gt;
&lt;p&gt;logging.level.root = info&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;如果只配置 logging.path，在 /var/tmp文件夹生成一个日志文件为 spring.log。如果只配置 logging.file，会在项目的当前路径下生成一个 xxx.log 日志文件。&lt;/p&gt;
&lt;p&gt;这里有一个坑，logging.path 和logging.file都配置了，只会有logging.file生效，所以，如果要指定日志生成的具体位置使用logging.file 配置就好&lt;/p&gt;

&lt;p&gt;在application.properties中配置&lt;/p&gt;
&lt;p&gt;logging.file =D:\\log\\enjoy.log&lt;/p&gt;
&lt;p&gt;这样在F盘的相应位置出现日志文件&lt;/p&gt;

&lt;p&gt;3. log4j2&lt;/p&gt;
&lt;p&gt;在spring-boot-dependencies POMs中搜索spring-boot-starter-log4j2&lt;/p&gt;
&lt;p&gt;发现Spring boot父Pom中自己提供了这个依赖，于是我们加入如下jar依赖：&lt;/p&gt;

&lt;p&gt;修改pom.xml文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/dd3fb45acf20da1960007bde170bf9fe.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意: 由于默认使用logback在扩展log4j2之前先要把logback移除&lt;/p&gt;
&lt;p&gt;日志使用跟上面logback一样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7de07d84ede2a174a0f9ab027db78862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;十五、使用AOP统一日志处理&lt;/p&gt;
&lt;p&gt;为了防止在工作中经常在代码中加入大量的日志处理代码，在实际项目开发中，一般使用AOP统一完成日志处理工作&lt;/p&gt;

&lt;p&gt;1. 修改pom文件，引入springboot对aop的支持&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/25debcbdd295157252d35a5bdc27bf17.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. 新增AOP日志处理类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/274876c27746850117389480e2b856b3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过访问Controller可以从日志看到，AOP切面方法已经生效&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e41cb2985c398c69c1b3ebe68eaac4af.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/a2553e2db3ff36fd75af89b0411a659d.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;总结&lt;br/&gt;    本文通过图文形式，学习Springboot快速入门，包括项目创建、Springmvc集成、MyBatis集成配置、事务集成配置、全局异常配置、Swagger2集成配置、AOP统一日志处理，将整个流程大概介绍了一遍，让想了解和学习Springboot的小伙伴能够对整体流程有个大概了解，也希望能够利用自己空闲时间按照上面流程完整操作一遍，可以加深自己的理解和印象。如有疑问欢迎评论留言，小编会及时回复哦~喜欢的小伙伴动动手指点个赞、收藏吧！&lt;/p&gt;

&lt;p&gt;更多精彩敬请关注公众号&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/9b371f98aab211f53489c0bbd23fd8ba.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java极客思维&lt;/p&gt;
&lt;p&gt;微信扫一扫，关注公众号​&lt;/p&gt;
</description>
<pubDate>Sat, 21 Nov 2020 15:34:00 +0000</pubDate>
<dc:creator>Java极客思维</dc:creator>
<og:description>前言 手把手教你Springboot微服务项目搭建快速入门，通过本文学习Springboot的搭建快速入门，掌握微服务大致的配置服务，后续将会继续将核心组件引入到项目中，欢迎关注，点赞，转发。 Spr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xgx120413/p/14017901.html</dc:identifier>
</item>
<item>
<title>API的使用（3）Arrays 类，Math类，三大特性--继承 - 🍓🍓鲁阿艳🐾🐾</title>
<link>http://www.cnblogs.com/luayan/p/14017893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luayan/p/14017893.html</guid>
<description>&lt;h2 id=&quot;arrays类&quot;&gt;Arrays类&lt;/h2&gt;
&lt;h4 id=&quot;概述&quot;&gt;概述&lt;/h4&gt;
&lt;p&gt;  java.util.Arrays此时主要是用来操作数组，里面提供了很多的操作API的方法。如【排序】和【搜索】功能。其所有的方法均为静态方法，调用起来非常简单。&lt;/p&gt;
&lt;h4 id=&quot;操作数组的方法&quot;&gt;操作数组的方法&lt;/h4&gt;
&lt;h5 id=&quot;public-static-string-to-stringint-a返回指定数组内容的字符串表示形式。&quot;&gt;(public static String to String(int[] a):返回指定数组内容的字符串表示形式。&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args){
    //初始int类型的数组 动态初始化只指定长度，不指定内容，而静态初始化只指定内容，不指定长度，两者不能混合使用。
    int[] arr  = {12,34,5,26};
    //打印数组，输出内存地址值
    System.out.println(arr);//地址值
    
    //把数组内容转换成字符串
    String str = Arrays.toString(arr);
    //打印字符串 输出数组内容
    System.out.println(str);//[12,34,5,26] 内容顺序不变
   
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;public-static-void-sortint-arr对指定数组按照数字升序经行排序，从大到小&quot;&gt;public static void sort(int[] arr):对指定数组按照数字升序经行排序，从大到小&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2195823/202011/2195823-20201121225645023-117437722.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;练习：使用arrays相关的api方法&quot;&gt;练习：使用Arrays相关的API方法&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2195823/202011/2195823-20201121225748232-1148451054.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  public static intbinarySearch(int[] arr,int key):使用二分搜索法来搜索指定的int型数组，以获得指定的值，此时key指的是要搜索的值，而方法返回值声明的int值的是搜索值的是搜索对应的索引值&lt;br/&gt;排序之后的新的数组的索引值。&lt;/p&gt;
&lt;p&gt;  使用binarySearch()方法。搜索数组当中的元素时，数组必须时有序的【升序】，得到的索引值是排序之后的新的数组的索引值。&lt;/p&gt;
&lt;p&gt;如果没有找到对应的元素，得到的索引值是负值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2195823/202011/2195823-20201121230825922-1146314673.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;public-static-void-fillint-arrint-val将指定的int值分配给指定int型数组指定范围中的每个元素。&quot;&gt;public static void fill(int[] arr,int val):将指定的int值分配给指定int型数组指定范围中的每个元素。&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2195823/202011/2195823-20201121231102518-564990735.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;math类&quot;&gt;Math类&lt;/h2&gt;
&lt;h4 id=&quot;概述-2&quot;&gt;概述&lt;/h4&gt;
&lt;p&gt;  java.util.Math包含了用于执行基本数学运算的方法，如指数、幂次方、对数、平方根、三角函数等运算。里面的方法均是静态方法，并且也不需要创建对象，调用起来也是非常方便。&lt;/p&gt;
&lt;h4 id=&quot;基本运算的方法&quot;&gt;基本运算的方法&lt;/h4&gt;
&lt;h5 id=&quot;punlic-static-double-adsdouble-a返回double值的绝对值。&quot;&gt;punlic static double ads(double a):返回double值的绝对值。&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2195823/202011/2195823-20201121231706530-47604375.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;public-static-double-ceil-double-a返回值大于等于参数的最小整数。往上取整。&quot;&gt;public static double ceil (double a):返回值大于等于参数的最小整数。往上取整。&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2195823/202011/2195823-20201121232059104-952151008.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;public-static-double-floordouble-a返回小于等于参数的最大整数。往下取整。&quot;&gt;public static double floor(double a):返回小于等于参数的最大整数。往下取整。&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2195823/202011/2195823-20201121232127228-1361778589.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;public-static-long-rounddouble-a返回最接近参数的-long-类型值。相当于四舍五入&quot;&gt;public static long round(double a):返回最接近参数的 long 类型值。相当于四舍五入&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2195823/202011/2195823-20201121232217333-294923743.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;练习：使用mach相关的api-方法，计算--108到59之间的，绝对值大于6小于21的整数有多少个，分别是哪些数组&quot;&gt;练习：使用Mach相关的api 方法，计算 -10.8到5.9之间的，绝对值大于6小于2.1的整数有多少个，分别是哪些数组&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2195823/202011/2195823-20201121232253732-1404717920.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2195823/202011/2195823-20201121232310967-824258982.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;继承&quot;&gt;继承&lt;/h2&gt;
&lt;h3 id=&quot;概述-3&quot;&gt;概述&lt;/h3&gt;
&lt;p&gt;  如果多个类中存在相同的属性和行为时，将这些内容抽取到单独的一个类中，那么多个类就无需再定义这些属性和行为，只要去继承这个单独的类即可&lt;/p&gt;
&lt;p&gt;  其中，多个类称为子类，派生类，单独的那一个类称为父类、超类（superclass）、基承&lt;/p&gt;
&lt;p&gt;  继承描述的时事物之间的所属关系，这种关系是一种 is-a 的关系，在继承关系中，子类就是一个父类，也就是说子类个月被当作父类看待。&lt;/p&gt;
&lt;p&gt;例如：父类是员工，子类是讲师，那么“讲师就是一个员工”。关系：is-a&lt;/p&gt;
&lt;p&gt;一般情况下，父类更通用，子类更具体。我们可以通过继承，使多种事物形成一种关系体系。&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;  继承：就是子类继承父类的属性和行为，使得子类对象具有域父类具有相同的属性、相同的行为，子类可以之间访问父类中的【非私有】属性和行为。&lt;/p&gt;
&lt;h4 id=&quot;好处：&quot;&gt;好处：&lt;/h4&gt;
&lt;p&gt;​   1，可以提高代码的复用性，&lt;/p&gt;
&lt;p&gt;​   2，类与类之间可以产生一种关系，是【多态的前提】。&lt;/p&gt;
&lt;h4 id=&quot;继承的格式&quot;&gt;继承的格式&lt;/h4&gt;
&lt;p&gt;通过extend关键字,可以声明一个子类继承另一个父类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FuClass{
    //...
}
public class ZiClass extends FuClass{
    //...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2195823/202011/2195823-20201121232715383-717686873.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;继承后的特点----成员变量&quot;&gt;继承后的特点----成员变量&lt;/h3&gt;
&lt;p&gt;当类之间产生了关系后，其中各类中的常用变量有哪些影响？&lt;/p&gt;
&lt;p&gt;​  常用变量不重名&lt;/p&gt;
&lt;p&gt;​  如果子类父类中调用的成员变量名字不重名，这时的访问是没有任何影响的。代码演示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2195823/202011/2195823-20201121232853042-1065182908.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;成员变量重名&quot;&gt;成员变量重名&lt;/h5&gt;
&lt;p&gt;​  如果子类父类出现重名的成员方法，这时访问是有影响的，代码演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2195823/202011/2195823-20201121233001128-1744214253.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​  1、在父子类的继承关系当中，如果采用变量重名，则创建子类对象时，访问有两种方式：&lt;/p&gt;
&lt;p&gt;​  2、直接通过子类对象访问成员变量：等号左边是谁，就优先用谁，没有会向上找&lt;/p&gt;
&lt;p&gt;​  3、间接通过采用方法访问成员变量：该方法属于谁，就优先用谁，没有则就继续向上找&lt;/p&gt;
&lt;p&gt;​  子父类中出现了重名的采用变量时，在子类中想要访问父类中的非私有成员变量时，需要使用super 关键字，修饰父类从成员变量，类似于this 操作。&lt;/p&gt;
&lt;p&gt;使用格式：&lt;/p&gt;
&lt;p&gt;super.父类的成员变量&lt;/p&gt;
&lt;p&gt;子类方法中的代码需要修改&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Zi extends Fu {
    // 定义子类中的成员变量
    int num = 20;
    // 定义子类中的成员方法
    public void show() {
        // 访问父类中的成员变量 num
        System.out.println(&quot;父类中的成员变量num = &quot; + super.num);// 10
        // 访问子类中的成员变量 num
        System.out.println(&quot;子类中的成员变量num = &quot; + num);// 
    }  
}
// 结果展示
// 10
// 20
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​​  备注：Fu类中的成员变量是非私有的，子类中可以直接访问，若Fu类中的成员变量私有了，子类不能直接访问。通常编码时，我们遵循的是封装的原则，使用private关键字修饰成员变量，那么如何访问父类中的私有成员变量呢？可以借助于父类中的提供的公共的setXxx和getXxx方法。&lt;/p&gt;
</description>
<pubDate>Sat, 21 Nov 2020 15:33:00 +0000</pubDate>
<dc:creator>🍓🍓鲁阿艳🐾🐾</dc:creator>
<og:description>##Arrays类 ####概述 java.util.Arrays此时主要是用来操作数组，里面提供了很多的操作API的方法。如【排序】和【搜索】功能。其所有的方法均为静态方法，调用起来非常简单。 ##</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luayan/p/14017893.html</dc:identifier>
</item>
<item>
<title>Spark3.0.1各种集群模式搭建 - 七星6609</title>
<link>http://www.cnblogs.com/qixing/p/14017875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qixing/p/14017875.html</guid>
<description>&lt;p&gt;对于spark前来围观的小伙伴应该都有所了解，也是现在比较流行的计算框架，基本上是有点规模的公司标配，所以如果有时间也可以补一下短板。&lt;/p&gt;
&lt;p&gt;简单来说Spark作为准实时大数据计算引擎，Spark的运行需要依赖资源调度和任务管理，Spark自带了standalone模式资源调度和任务管理工具，运行在其他资源管理和任务调度平台上，如Yarn、Mesos、Kubernates容器等。&lt;/p&gt;
&lt;p&gt;spark的搭建和Hadoop差不多，稍微简单点，本文针对下面几种部署方式进行详细描述：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Local：多用于本地测试，如在eclipse，idea中写程序测试等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Standalone：Standalone是Spark自带的一个资源调度框架，它支持完全分布式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Yarn：Hadoop生态圈里面的一个资源调度框架，Spark也是可以基于Yarn来计算的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;了解一个框架最直接的方式首先要拿来玩玩，玩之前要先搭建，废话少说，进入正题，搭建spark集群。&lt;/p&gt;
&lt;p&gt;一、环境准备&lt;/p&gt;
&lt;p&gt;　　　搭建环境：CentOS7+jdk8+Hadoop2.10.1+Spark3.0.1&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;机器准备，由于已经搭建过Hadoop，spark集群也是使用相同集群（个人电脑资源有限），可以参照Hadoop搭建博客：&lt;a href=&quot;https://www.cnblogs.com/qixing/p/12252111.html&quot; target=&quot;_blank&quot;&gt;centos7中搭建hadoop2.10高可用集群&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;需要安装jdk1.8、Scala2.12.12、hadoop2.10.1、spark3.0.1，其中jdk1.8和Hadoop2.10也都已经安装完成，这里只介绍Scala和spark环境配置&lt;/li&gt;
&lt;li&gt;机器免密登录，也在Hadoop部署时做过，可以参照Hadoop搭建博客：&lt;a href=&quot;https://www.cnblogs.com/qixing/p/12252111.html&quot; target=&quot;_blank&quot;&gt;centos7中搭建hadoop2.10高可用集群&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;下载Scala2.12.12（&lt;a href=&quot;https://www.scala-lang.org/download/2.12.12.html&quot; target=&quot;_blank&quot;&gt;https://www.scala-lang.org/download/2.12.12.html&lt;/a&gt;）、下载spark3.0.1(&lt;a href=&quot;http://spark.apache.org/downloads.html&quot; target=&quot;_blank&quot;&gt;http://spark.apache.org/downloads.html&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;二、配置环境变量&lt;/p&gt;
&lt;p&gt;　　1.配置Scala环境　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
tar -zxvf scala-&lt;span&gt;2.12&lt;/span&gt;.&lt;span&gt;12&lt;/span&gt;.tgz -C /opt/soft/&lt;span&gt;
cd &lt;/span&gt;/opt/&lt;span&gt;soft
ln &lt;/span&gt;-s scala-&lt;span&gt;2.12&lt;/span&gt;.&lt;span&gt;12&lt;/span&gt; scala&lt;p&gt;vim /etc/profile&lt;br/&gt;添加环境变量
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;　#SCALA&lt;br/&gt;　export SCALA_HOME=/opt/soft/scala&lt;br/&gt;　export PATH=$PATH:$SCALA_HOME/bin&lt;/p&gt;
&lt;p&gt;　source /etc/profile&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;测试是否正常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121220059739-1718787706.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 正常&lt;/p&gt;
&lt;p&gt;　　2.配置spark环境变量&lt;/p&gt;
&lt;p&gt;　　由于各个部署方式都需要该步骤，在此单独配置，各个部署方式不再配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
tar -zxvf spark-3.0.1-bin-hadoop2.7.tgz -C /opt/&lt;span&gt;soft
cd &lt;/span&gt;/opt/&lt;span&gt;soft
ln &lt;/span&gt;-s spark-3.0.1-bin-hadoop2.7 spark
&lt;/pre&gt;
&lt;pre&gt;
vim /etc/profile&lt;br/&gt;添加环境变量
&lt;/pre&gt;
&lt;p&gt;　#spark&lt;br/&gt;　export SPARK_HOME=/opt/soft/spark&lt;br/&gt;　export PATH=$PATH:$SPARK_HOME/bin&lt;/p&gt;
&lt;p&gt;　source /etc/profile&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;三、搭建步骤&lt;/p&gt;
&lt;p&gt;　　1.本地Local模式&lt;/p&gt;
&lt;p&gt;　　 上述已经解压配置好spark环境变量，本地模式不需要配置其他配置文件，可以直接使用，很简单吧，先测试一下运行样例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /opt/soft/spark/bin&lt;p&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;run&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;example &lt;span class=&quot;typ&quot;&gt;SparkPi&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;lit&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121222248087-78312787.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以计算出结果&lt;/p&gt;
&lt;p&gt;　　测试spark-shell&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
spark-shell
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121222553964-1297492112.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 启动成功，说明Local模式部署成功&lt;/p&gt;
&lt;p&gt;　　2.Standalone模式&lt;/p&gt;
&lt;p&gt;　　1&amp;gt;修改Spark的配置文件&lt;code&gt;spark-env.sh&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /opt/soft/spark/&lt;span&gt;conf
cp spark&lt;/span&gt;-env.sh.template spark-&lt;span&gt;env.sh
vim spark&lt;/span&gt;-env.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 主节点机器名称
export SPARK_MASTER_HOST&lt;/span&gt;=&lt;span&gt;s141
# 默认端口号为7077
export SPARK_MASTER_PORT&lt;/span&gt;=&lt;span&gt;7077&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2&amp;gt;修改配置文件slaves（从节点配置）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /opt/soft/spark/&lt;span&gt;conf
cp slaves.template slaves
vim slaves&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除原有节点，添加从节点主机如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;s142
s143
s144
s145&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3&amp;gt;将spark目录发送到其他机器，可以使用scp一个一个机器复制，这里使用的是自己写的批量复制脚本xrsync.sh（&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/qixing/p/11431607.html&quot; target=&quot;_blank&quot;&gt;hadoop批量命令脚本xrsync.sh传输脚本&lt;/a&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
xrsync.sh spark-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;-bin-hadoop2.&lt;span&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121224701199-334604552.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　4&amp;gt;在各个机器中建立spark软连接，可以进入各个机器的/opt/soft目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 ln -s /opt/soft/spark-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;-bin-hadoop2.&lt;span&gt;7&lt;/span&gt; /opt/soft/spark
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里使用的是批量执行命令脚本xcall.sh（&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/qixing/p/11430867.html&quot; target=&quot;_blank&quot;&gt;hadoop批量命令脚本xcall.sh及jps找不到命令解决&lt;/a&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
xcall.sh ln -s /opt/soft/spark-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;-bin-hadoop2.&lt;span&gt;7&lt;/span&gt; /opt/soft/spark
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121225347722-1091094463.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　5&amp;gt;启动spark集群&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cd /opt/soft/spark/&lt;span&gt;sbin

可以单独启动master和slave
.&lt;/span&gt;/start-&lt;span&gt;master.sh
.&lt;/span&gt;/start-slaves.sh spark:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s141:7077&lt;/span&gt;
&lt;span&gt;
也可以一键启动master和slave
.&lt;/span&gt;/start-all.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121225926401-1045864136.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以看到master和worker进程已经启动成功&lt;/p&gt;
&lt;p&gt;　　6&amp;gt;查看集群资源页面(webUI:http://192.168.30.141:8080/)，如果8080端口查不到可以看一下master启动日志，可能是8081端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121230516992-162811635.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121230341895-226385713.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　7&amp;gt;进入集群shell验证&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /opt/soft/spark/bin&lt;br/&gt;./spark-shell –master spark:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s141:7077&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121230836623-2078160787.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 也是正常的，说明Standalone模式部署成功&lt;/p&gt;
&lt;p&gt;　　3.yarn集群模式&lt;/p&gt;
&lt;p&gt;　　1&amp;gt;修改配置文件spark-env.sh&lt;/p&gt;
&lt;p&gt;　　在Standalone模式下搭建yarn集群模式很简单，只需要在&lt;code&gt;spark-env.sh&lt;/code&gt;配置文件加入如下内容即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 添加hadoop的配置目录
export HADOOP_CONF_DIR&lt;/span&gt;=/opt/soft/hadoop/etc/hadoop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将spark-env.sh分发到各个机器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121231436037-1503248034.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　4&amp;gt;启动spark集群&lt;/p&gt;
&lt;p&gt;　　先启动Hadoop的yarn集群&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
start-yarn.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再启动spark集群，和Standalone模式一样有两种方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cd /opt/soft/spark/&lt;span&gt;sbin

可以单独启动master和slave
.&lt;/span&gt;/start-&lt;span&gt;master.sh
.&lt;/span&gt;/start-slaves.sh spark:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s141:7077&lt;/span&gt;
&lt;span&gt;
也可以一键启动master和slave
.&lt;/span&gt;/start-all.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121231916490-353276080.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　查看master和worker进程正常　&lt;/p&gt;
&lt;p&gt;　　5&amp;gt;查看集群资源页面(webUI:http://192.168.30.141:8080/)，如果8080端口查不到可以看一下master启动日志，可能是8081端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121230516992-162811635.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121230341895-226385713.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　6&amp;gt;进入集群shell验证&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /opt/soft/spark/bin&lt;br/&gt;./spark-shell –master yarn
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/480564/202011/480564-20201121232429616-114021085.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;启动也正常 &lt;/p&gt;

</description>
<pubDate>Sat, 21 Nov 2020 15:29:00 +0000</pubDate>
<dc:creator>七星6609</dc:creator>
<og:description>对于spark前来围观的小伙伴应该都有所了解，也是现在比较流行的计算框架，基本上是有点规模的公司标配，所以如果有时间也可以补一下短板。 简单来说Spark作为准实时大数据计算引擎，Spark的运行需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qixing/p/14017875.html</dc:identifier>
</item>
<item>
<title>Cisco思科模拟器路由器各个端口IP地址的配置及路由协议RIP的配置 入门详解 - 精简归纳 - JERRY_Z</title>
<link>http://www.cnblogs.com/JERRY-Z-J-R/p/14017855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JERRY-Z-J-R/p/14017855.html</guid>
<description>&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;JERRY_Z. ~ 2020 / 11 / 21&lt;br/&gt;转载请注明出处！❤️&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231253382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231317828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231405672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020112123141538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231511605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/202011212315250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231536438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231545524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231600334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231619186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231628206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231636949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231646226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231655135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231711653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/202011212317245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231736711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231744616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231757334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231804813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231812450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201121231819784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020112123182881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Rfc2lfR29k,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;mark&gt;&lt;em&gt;交流方式：&lt;/em&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;❤️ ❤️ ❤️&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QQ：&lt;/strong&gt; 1846334075&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WeChat：&lt;/strong&gt; zhoujirui54&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CSDN：&lt;/strong&gt;&lt;a href=&quot;https://blog.csdn.net/D_si_God&quot;&gt;https://blog.csdn.net/D_si_God&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cnblogs：&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/JERRY-Z-J-R/&quot;&gt;https://www.cnblogs.com/JERRY-Z-J-R/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GitHub：&lt;/strong&gt;&lt;a href=&quot;https://github.com/JERRY-Z-J-R&quot;&gt;https://github.com/JERRY-Z-J-R&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gitee：&lt;/strong&gt;&lt;a href=&quot;https://gitee.com/JERRY-Z-J-R&quot;&gt;https://gitee.com/JERRY-Z-J-R&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Nov 2020 15:20:00 +0000</pubDate>
<dc:creator>JERRY_Z</dc:creator>
<og:description>Cisco思科模拟器路由器各个端口IP地址的配置及路由协议RIP的配置 入门详解 - 精简归纳 JERRY_Z. ~ 2020 / 11 / 21 转载请注明出处！&amp;amp;lt;3 附: 交流方式：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JERRY-Z-J-R/p/14017855.html</dc:identifier>
</item>
<item>
<title>Vue-router插件使用 - 云崖先生</title>
<link>http://www.cnblogs.com/Yunya-Cnblogs/p/14017686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yunya-Cnblogs/p/14017686.html</guid>
<description>&lt;p&gt;　　 &lt;code&gt;Vue&lt;/code&gt;是单页面开发，即页面不刷新。&lt;/p&gt;
&lt;p&gt;　　 页面不刷新，而又要根据用户选择完成内容的更新该怎么做？&lt;code&gt;Vue&lt;/code&gt;中采用锚点来完成。&lt;/p&gt;
&lt;p&gt;　　 如访问&lt;code&gt;http://127.0.0.1#/index&lt;/code&gt;就是主页，而访问&lt;code&gt;http://127.0.0.1#/home&lt;/code&gt;就是家目录。&lt;/p&gt;
&lt;p&gt;　　 手动分析&lt;code&gt;url&lt;/code&gt;组成与处理视图的切换非常麻烦，所以&lt;code&gt;Vue&lt;/code&gt;提供插件&lt;code&gt;Vue-router&lt;/code&gt;，它能够根据用户在地址栏中输入的不同链接展示不同的内容，十分的方便。&lt;/p&gt;

&lt;p&gt;　　 打开&lt;code&gt;Vue.js&lt;/code&gt;官网，在生态系统中找到&lt;code&gt;vue-router&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201117151741748.png&quot; alt=&quot;image-20201117151741748&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 然后根据它的官方文档进行安装即可：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201117152118071.png&quot; alt=&quot;image-20201117152118071&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;a href=&quot;https://router.vuejs.org/zh/guide/#html&quot;&gt;文档链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　 使用&lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt;当作组件的显示容器。&lt;/p&gt;
&lt;p&gt;　　 使用&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt;与属性&lt;code&gt;to&lt;/code&gt;让&lt;code&gt;Vue&lt;/code&gt;切换显示的组件。&lt;/p&gt;
&lt;p&gt;　　 注意查看下图中&lt;code&gt;url&lt;/code&gt;的变化，它确实没有刷新。&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/vuerouter.gif&quot; alt=&quot;vuerouter&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;./vue-router.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    // 第一步：书写组件
    const index = {
        template: `
        &amp;lt;div&amp;gt;
            &amp;lt;h1&amp;gt;欢迎访问主页&amp;lt;/h1&amp;gt;
            &amp;lt;router-link to=&quot;/settings&quot;&amp;gt;设置&amp;lt;/router-link&amp;gt;
            &amp;lt;router-link to=&quot;/backend&quot;&amp;gt;后台&amp;lt;/router-link&amp;gt;
        &amp;lt;/div&amp;gt;
        `
    }

    const backend = {
        template: `
        &amp;lt;div&amp;gt;
            &amp;lt;h1&amp;gt;欢迎访问后台&amp;lt;/h1&amp;gt;
            &amp;lt;router-link to=&quot;/&quot;&amp;gt;访问主页&amp;lt;/router-link&amp;gt;
        &amp;lt;/div&amp;gt;
        `
    }

    const settings = {
        template: `
        &amp;lt;div&amp;gt;
            &amp;lt;h1&amp;gt;欢迎访问个人设置页面&amp;lt;/h1&amp;gt;
            &amp;lt;router-link to=&quot;/&quot;&amp;gt;访问主页&amp;lt;/router-link&amp;gt;
        &amp;lt;/div&amp;gt;
        `
    }

    // 第二步：配置路由
    // 根据资源请求来展示或隐藏对应的组件
    const routes = [
        // 主页，/
        {path: &quot;/&quot;, component: index},
        {path: &quot;/backend&quot;, component: backend},
        {path: &quot;/settings&quot;, component: settings},
    ]

    // 第三步：实例化路由对象
    // {routes:routes}
    const router = new VueRouter({routes,})

    // 第四步：根组件中添加路由信息
    // {router:router}
    const app = new Vue({
        el: &quot;#app&quot;,
        router,
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;参数传递&lt;/h2&gt;
&lt;p&gt;　　 在很多情况下，我们都需要用户的请求地址携带一些参数，然后通过这个参数再进行查询。&lt;/p&gt;
&lt;p&gt;　　 比如查询某一本书时，地址栏通常是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#/book/2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 而且很有可能在今后的&lt;code&gt;&amp;lt;router-link&amp;gt;&lt;/code&gt;以及&lt;code&gt;methods&lt;/code&gt;中都要使用这个参数，如何操作？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{path: &quot;/book/:id(\\d+)&quot;, component: book},  // 转义 \d+

我该如何从Template里拿到参数:{{ $route.params }}

我该如何从Methods里拿到参数:this.$route.params
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 示例如下：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/vuerouter%E5%8F%82%E6%95%B0.gif&quot; alt=&quot;vuerouter参数&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;./vue-router.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    // 第一步：书写组件
    const index = {
        template: `
          &amp;lt;div&amp;gt;
              &amp;lt;h1&amp;gt;主页&amp;lt;/h1&amp;gt;
              &amp;lt;input type=&quot;text&quot; v-model=&quot;book_id&quot; placeholder=&quot;输入要查询的图书编号&quot;&amp;gt;
              &amp;lt;router-link :to=&quot;'/book/'+book_id&quot;&amp;gt;查询图书&amp;lt;/router-link&amp;gt;
          &amp;lt;/div&amp;gt;
        `,
        data() {
            return {
                book_id: 0,
            };
        }
    }

    const book = {
        // 在模板以及方法中，你都可以拿到查询的参数
        template: `
          &amp;lt;div&amp;gt;
              &amp;lt;p&amp;gt;我该如何从Template里拿到参数:{{ $route.params }}&amp;lt;/p&amp;gt;
              &amp;lt;p&amp;gt;我该如何从Methods里拿到参数:{{ show() }}&amp;lt;/p&amp;gt;
              &amp;lt;p v-for=&quot;item in books&quot; v-if=&quot;item.id==$route.params.id&quot;&amp;gt;你查询的图书是：{{ item }}&amp;lt;/p&amp;gt;
          &amp;lt;/div&amp;gt;
        `,
        data() {
            return {
                books: [
                    {id: 1, name: &quot;红楼梦&quot;, author: &quot;曹雪芹&quot;, price: 199,},
                    {id: 2, name: &quot;西游记&quot;, author: &quot;吴承恩&quot;, price: 179,},
                    {id: 3, name: &quot;三国演义&quot;, author: &quot;罗贯中&quot;, price: 158,},
                    {id: 4, name: &quot;水浒传&quot;, author: &quot;施耐庵&quot;, price: 128,},
                ]
            }
        },
        methods:{
            show(){
                return this.$route.params
            }
        }
    }

    // 第二步：配置路由
    const routes = [
        // 主页，/
        {path: &quot;/&quot;, component: index},
        {path: &quot;/book/:id(\\d+)&quot;, component: book},  // 转义 \d+
    ]

    // 第三步：实例化路由对象
    // {routes:routes}
    const router = new VueRouter({routes,})

    // 第四步：根组件中添加路由信息
    // {router:router}
    const app = new Vue({
        el: &quot;#app&quot;,
        router,
    })
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;默认参数&lt;/h2&gt;
&lt;p&gt;　　 根据&lt;code&gt;RestAPI&lt;/code&gt;规范，如果没有携带参数则代表查询所有。&lt;/p&gt;
&lt;p&gt;　　 如果按照上面的示例，直接不带参数进行请求路由将匹配不上，所以我们还需要做一个查询所有的功能。&lt;/p&gt;
&lt;p&gt;　　 其实对上面路由进行改进即可，设置为默认参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{path: &quot;/book/:id?&quot;, component: book},  // ?代表可以有也可以没有
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 示例如下：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/vuerouter%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0.gif&quot; alt=&quot;vuerouter默认参数&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!--查询模板--&amp;gt;
&amp;lt;template id=&quot;result&quot;&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;table border=&quot;1&quot; :style=&quot;{borderCollapse:'collapse'}&quot;&amp;gt;
            &amp;lt;caption :style=&quot;{border:'1px solid #000',fontSize:'1.2rem'}&quot;&amp;gt;查询结果&amp;lt;/caption&amp;gt;
            &amp;lt;thead&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;th&amp;gt;编号&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;名称&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;作者&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;价格&amp;lt;/th&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;/thead&amp;gt;
            
            &amp;lt;!-- 查询一本 --&amp;gt;
            &amp;lt;tbody v-if=&quot;$route.params.id&quot;&amp;gt;
            &amp;lt;tr v-for=&quot;item in books&quot; v-if=&quot;item.id == $route.params.id&quot;&amp;gt;
                &amp;lt;td&amp;gt;{{ item.id }}&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;{{ item.name }}&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;{{ item.author }}&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;{{ item.price }}&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;/tbody&amp;gt;
            
            &amp;lt;!-- 查询所有 --&amp;gt;
            &amp;lt;tbody v-else&amp;gt;
            &amp;lt;tr v-for=&quot;item in books&quot;&amp;gt;
                &amp;lt;td&amp;gt;{{ item.id }}&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;{{ item.name }}&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;{{ item.author }}&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;{{ item.price }}&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
            &amp;lt;/tbody&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;./vue-router.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    // 第一步：书写组件
    const index = {
        template: `
          &amp;lt;div&amp;gt;
          &amp;lt;h1&amp;gt;主页&amp;lt;/h1&amp;gt;
          &amp;lt;input type=&quot;text&quot; v-model=&quot;book_id&quot; placeholder=&quot;输入要查询的图书编号&quot;&amp;gt;
          &amp;lt;router-link :to=&quot;'/book/'+book_id&quot;&amp;gt;查询单个图书&amp;lt;/router-link&amp;gt;
          &amp;lt;router-link to=&quot;/book/&quot;&amp;gt;查询所有图书&amp;lt;/router-link&amp;gt;
          &amp;lt;/div&amp;gt;
        `,
        data() {
            return {
                book_id: 0,
            };
        }
    }

    const book = {
        // 在模板以及方法中，你都可以拿到查询的参数
        template: `#result`,
        data() {
            return {
                books: [
                    {id: 1, name: &quot;红楼梦&quot;, author: &quot;曹雪芹&quot;, price: 199,},
                    {id: 2, name: &quot;西游记&quot;, author: &quot;吴承恩&quot;, price: 179,},
                    {id: 3, name: &quot;三国演义&quot;, author: &quot;罗贯中&quot;, price: 158,},
                    {id: 4, name: &quot;水浒传&quot;, author: &quot;施耐庵&quot;, price: 128,},
                ]
            }
        },
    }

    // 第二步：配置路由
    const routes = [
        // 主页，/
        {path: &quot;/&quot;, component: index},
        {path: &quot;/book/:id?&quot;, component: book},  // 转义 \d+，?可以有也可以没有
    ]

    // 第三步：实例化路由对象
    // {routes:routes}
    const router = new VueRouter({routes,})

    // 第四步：根组件中添加路由信息
    // {router:router}
    const app = new Vue({
        el: &quot;#app&quot;,
        router,
    })
    
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;路由name&lt;/h2&gt;
&lt;p&gt;　　 为每一个路由匹配规则添加&lt;code&gt;name&lt;/code&gt;属性，使其更方便的在模板以及&lt;code&gt;Js&lt;/code&gt;代码中进行跳转：&lt;/p&gt;
&lt;p&gt;　　 如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    const routes = [
        {path: &quot;/&quot;, component: index, name: &quot;index&quot;},
        {path: &quot;/book/:id?&quot;, component: book, name: &quot;query_book&quot;},
    ]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;router-link&lt;/h2&gt;
&lt;p&gt;　　 模板中使用&lt;code&gt;router-link&lt;/code&gt;与路由的别名&lt;code&gt;name&lt;/code&gt;进行跳转时，格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 有参数就传递，没有就不传递。注意在to前添加: --&amp;gt;
&amp;lt;router-link :to=&quot;{name:'query_book',params:{id:书籍编号}}&quot;&amp;gt;查询&amp;lt;/router-link&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;$route.push&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;Js&lt;/code&gt;代码中使用跳转时要用到&lt;code&gt;this.$router.push()&lt;/code&gt;这个方法，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 模板中的按钮
&amp;lt;button @click=&quot;func(书籍编号)&quot;&amp;gt;查看详情&amp;lt;/button&amp;gt;

// js
func(bookId){
        // 使用url拼接跳转
    let url = {path:&quot;/book/&quot;+bookId};
    // 使用别名进行跳转跳转：
    // {name:'book_query',params:{id:id}}
    this.$router.push(url);  // 使用$router.push(url)进行跳转
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;视图嵌套&lt;/h2&gt;
&lt;p&gt;　　 一个大的组件中可以包含很多小的组件。&lt;/p&gt;
&lt;p&gt;　　 如下所示，有一个&lt;code&gt;school&lt;/code&gt;组件，在&lt;code&gt;school&lt;/code&gt;组件中你可以查看到当前的&lt;code&gt;teacher&lt;/code&gt;和&lt;code&gt;classes&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　 当然&lt;code&gt;teacher&lt;/code&gt;与&lt;code&gt;classes&lt;/code&gt;也都是两个组件。&lt;/p&gt;
&lt;p&gt;　　 换而言之，我在&lt;code&gt;school&lt;/code&gt;组件中点击查看教师或者班级，我并不希望他跳转到新的页面而是在当前页面的其他位置进行显示其他组件就可以使用路由嵌套。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;
        &amp;lt;!-- 第一层，展示学校 --&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/div&amp;gt;

# 子组件中的关键代码
 &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
 
# 路由中的代码，第一层的路由匹配第一层的router-view，第二层的路由就在第二层的router-view中显示
 path: &quot;/school&quot;, component: school, name: &quot;school&quot;, children: [
     {path: &quot;/school/teacher&quot;, component: teacher, name: &quot;teacher&quot;},
     {path: &quot;/school/classes&quot;, component: classes, name: &quot;classes&quot;},
 ]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/vuerouter%E5%B5%8C%E5%A5%97.gif&quot; alt=&quot;vuerouter嵌套&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
        &amp;lt;!-- 第一层，展示学校 --&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/div&amp;gt;


&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;./vue-router.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    // 第一步：书写组件
    const school = {
        template: `
        &amp;lt;div&amp;gt;
            &amp;lt;h1&amp;gt;欢迎来到大肥羊学校&amp;lt;/h1&amp;gt;
            &amp;lt;router-link :to=&quot;{name:'classes'}&quot;&amp;gt;查看班级&amp;lt;/router-link&amp;gt;
            &amp;lt;router-link :to=&quot;{name:'teacher'}&quot;&amp;gt;查看老师&amp;lt;/router-link&amp;gt;
            &amp;lt;!-- 第二层，展示班级或者教师 --&amp;gt;
            &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
        &amp;lt;/div&amp;gt;
        `
    }

    const teacher = {
        template: `
          &amp;lt;div&amp;gt;
            &amp;lt;ul&amp;gt;
              &amp;lt;li v-for=&quot;item in teacherMessage&quot;&amp;gt;{{item.id}}-{{item.name}}&amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
          &amp;lt;/div&amp;gt;
        `,
        data() {
            return {
                teacherMessage: [
                    {id: 1, name: &quot;王老师&quot;,},
                    {id: 2, name: &quot;张老师&quot;,},
                    {id: 3, name: &quot;李老师&quot;,},
                ]
            }
        }
    }


    const classes = {
        template: `
          &amp;lt;div&amp;gt;
              &amp;lt;ul&amp;gt;
                &amp;lt;li v-for=&quot;item in classMessage&quot;&amp;gt;{{item.id}}-{{item.name}}&amp;lt;/li&amp;gt;
              &amp;lt;/ul&amp;gt;
          &amp;lt;/div&amp;gt;
        `,
        data() {
            return {
                classMessage: [
                    {id: 1, name: &quot;一年级一班&quot;,},
                    {id: 2, name: &quot;一年级二班&quot;,},
                    {id: 3, name: &quot;一年级三班&quot;,},
                ]
            }
        }
    }

    // 第二步：配置路由
    const routes = [
        {
            path: &quot;/school&quot;, component: school, name: &quot;school&quot;, children: [
                {path: &quot;/school/teacher&quot;, component: teacher, name: &quot;teacher&quot;},
                {path: &quot;/school/classes&quot;, component: classes, name: &quot;classes&quot;},
            ]
        },
    ]

    // 第三步：实例化路由对象
    // {routes:routes}
    const router = new VueRouter({routes,})

    // 第四步：根组件中添加路由信息
    // {router:router}
    const app = new Vue({
        el: &quot;#app&quot;,
        router,
    })

&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;嵌套的问题&lt;/h2&gt;
&lt;p&gt;　　 当页面发生变化，如&lt;code&gt;#school/classes&lt;/code&gt;跳转到&lt;code&gt;#school/teacher&lt;/code&gt;，&lt;code&gt;school&lt;/code&gt;组件将会产生复用。&lt;/p&gt;
&lt;p&gt;　　 这代表&lt;code&gt;school&lt;/code&gt;的组件声明周期钩子函数不会被重复调用，就可能造成数据更新不及时的问题。&lt;/p&gt;
&lt;p&gt;　　 举一个例子，上述示例中的&lt;code&gt;school&lt;/code&gt;欢迎语是&lt;strong&gt;欢迎来到大肥羊学校&lt;/strong&gt;，如果它是钩子函数&lt;code&gt;created()&lt;/code&gt;从后端获取的数据，在用户查看&lt;code&gt;#school/classes&lt;/code&gt;后跳转到&lt;code&gt;#school/teacher&lt;/code&gt;这个时间点中间后端数据发生了改变，变成了&lt;strong&gt;欢迎来到小肥羊学校&lt;/strong&gt;，由于组件复用问题不会再次执行&lt;code&gt;created()&lt;/code&gt;，则代表用户依旧看到的是欢迎来到&lt;strong&gt;大肥羊学校&lt;/strong&gt;。如下所示，我们只有手动更新标语才能执行更新，这显然是不符合常理的：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/vuerouter%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98.gif&quot; alt=&quot;vuerouter嵌套问题&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;

&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;./vue-router.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;

    // 假设是从后端抓取数据
    let schoolTitle = &quot;欢迎来到大肥羊学校&quot;;

    // 5s后发生改变
    setTimeout(() =&amp;gt; {
        schoolTitle = &quot;欢迎来到小肥羊学校&quot;;
    }, 5000);

    // 第一步：书写组件
    const school = {
        template: `
        &amp;lt;div&amp;gt;
            &amp;lt;h1&amp;gt;{{ title }}&amp;lt;/h1&amp;gt;
            &amp;lt;router-link :to=&quot;{name:'classes'}&quot;&amp;gt;查看班级&amp;lt;/router-link&amp;gt;
            &amp;lt;router-link :to=&quot;{name:'teacher'}&quot;&amp;gt;查看老师&amp;lt;/router-link&amp;gt;
            &amp;lt;p&amp;gt;&amp;lt;button @click=&quot;updateTitle&quot;&amp;gt;更新新的标语&amp;lt;/button&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
        &amp;lt;/div&amp;gt;
        `,
        data(){
            return {
                title : &quot;&quot;,
            }
        },
        created(){
            // 假设发送异步请求
            console.log(&quot;school钩子函数触发了...&quot;)
            this.title = schoolTitle;
        },
        methods:{
            updateTitle(){
                this.title = schoolTitle;
            }
        }
    }

    const teacher = {
        template: `
          &amp;lt;div&amp;gt;
            &amp;lt;h3&amp;gt;老师太多了，显示不过来...&amp;lt;/h3&amp;gt;
          &amp;lt;/div&amp;gt;
        `,
    }


    const classes = {
        template: `
          &amp;lt;div&amp;gt;
            &amp;lt;h3&amp;gt;班级太多了，显示不过来...&amp;lt;/h3&amp;gt;
          &amp;lt;/div&amp;gt;
        `,
    }

    // 第二步：配置路由
    const routes = [
        {
            path: &quot;/school&quot;, component: school, name: &quot;school&quot;, children: [
                {path: &quot;/school/teacher&quot;, component: teacher, name: &quot;teacher&quot;},
                {path: &quot;/school/classes&quot;, component: classes, name: &quot;classes&quot;},
            ]
        },
    ]

    // 第三步：实例化路由对象
    // {routes:routes}
    const router = new VueRouter({routes,})

    // 第四步：根组件中添加路由信息
    // {router:router}
    const app = new Vue({
        el: &quot;#app&quot;,
        router,
    })

&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;解决问题&lt;/h2&gt;
&lt;p&gt;　　 如果想解决组件复用钩子函数不执行的问题，我们可以使用&lt;code&gt;watch&lt;/code&gt;来监听&lt;code&gt;$route&lt;/code&gt;对象，也就是使用&lt;code&gt;watch&lt;/code&gt;来监听地址栏变化，当发生变化时就重新获取数据。&lt;/p&gt;
&lt;p&gt;　　 或者使用 2.2 中引入的 &lt;code&gt;beforeRouteUpdate&lt;/code&gt; &lt;a href=&quot;https://router.vuejs.org/zh/guide/advanced/navigation-guards.html&quot;&gt;导航守卫&lt;/a&gt;，解决思路如下图所示：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201117180236494.png&quot; alt=&quot;image-20201117180236494&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/vuerouter%E5%B5%8C%E5%A5%97%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.gif&quot; alt=&quot;vuerouter嵌套问题解决&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 代码如下，使用&lt;code&gt;watch&lt;/code&gt;进行解决：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    const school = {
                template:&quot;...&quot;,
        data(){
            return {
                title : &quot;&quot;,
            }
        },
        created(){
            // 假设发送异步请求
            this.getTitle();
        },
        methods:{
            getTitle(){
                // 从后端获取数据
                this.title = schoolTitle;
            }
        },
        watch:{
            $route(to,from){
                // to 要跳转的页面
                // from 从那个页面进行跳转
                this.getTitle();
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 使用导航守卫进行解决的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 第一步：书写组件
    const school = {
        template:&quot;...&quot;,
        data(){
            return {
                title : &quot;&quot;,
            }
        },
        created(){
            // 假设发送异步请求
            this.getTitle();
        },
        methods:{
            getTitle(){
                // 从后端获取数据
                this.title = schoolTitle;
            }
        },
        beforeRouteUpdate (to, from, next) {
            this.getTitle();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;命名视图&lt;/h2&gt;
&lt;p&gt;　　 命名视图就是说可以在一个页面上，使用多个&lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt;，相较于路由嵌套的层级关系，它是一种扁平化的设计。&lt;/p&gt;
&lt;p&gt;　　 如，头部导航栏，左侧菜单栏，右边内容块三个组件，都显示在一个页面上，就可以使用命名视图。&lt;/p&gt;
&lt;p&gt;　　 核心代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 根组件模板
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;!-- 这里只放个人主页 --&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
    &amp;lt;router-view name=&quot;menu&quot;&amp;gt;&amp;lt;/router-view&amp;gt;
    &amp;lt;router-view name=&quot;show&quot;&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/div&amp;gt;
   

# Js配置路由，/代表根目录。有三个视图，router-view
path: &quot;/&quot;, components: {
    default: header,  // 如果 view-router没有name属性，则用default
    menu: menu,
    show: show,
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20201117194355773.png&quot; alt=&quot;image-20201117194355773&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;style&amp;gt;
        *{
            padding: 0;
            margin: 0;
            box-sizing: border-box;
        }
        header{
            height: 45px;
            display: flex;
            justify-content: space-evenly;
            background-color: #ddd;
            align-items: center;
        }
        body&amp;gt;div&amp;gt;div:nth-child(2){
            display: inline-flex;
            width: 15%;
            border: 1px solid #ddd;
            height: 1000px;
        }
        menu&amp;gt;ul{
            list-style-type: none;
            display: inline-flex;
            flex-flow: column;
            
        }
        menu&amp;gt;ul&amp;gt;li{
            margin: 10px 0 0 10px;
        }
        body&amp;gt;div&amp;gt;div:last-child{
            display: inline-flex;
            justify-content: center;
            border: 1px solid #ddd;
            width: 70%;
            height: 1000px;
        }

    &amp;lt;/style&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;app&quot;&amp;gt;
        &amp;lt;!-- 这里只放个人主页 --&amp;gt;
        &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
        &amp;lt;router-view name=&quot;menu&quot;&amp;gt;&amp;lt;/router-view&amp;gt;
        &amp;lt;router-view name=&quot;show&quot;&amp;gt;&amp;lt;/router-view&amp;gt;
    &amp;lt;/div&amp;gt;
   
    &amp;lt;!-- 头部组件 --&amp;gt;
    &amp;lt;template id=&quot;header&quot;&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;header&amp;gt;&amp;lt;span&amp;gt;首页&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;新闻&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;关注&amp;lt;/span&amp;gt;&amp;lt;span&amp;gt;链接&amp;lt;/span&amp;gt;&amp;lt;/header&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/template&amp;gt;

    &amp;lt;!-- 左侧菜单 --&amp;gt;
    &amp;lt;template id=&quot;menu&quot;&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;menu&amp;gt;
                &amp;lt;ul&amp;gt;
                    &amp;lt;li&amp;gt;最新&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;最热&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;最多评论&amp;lt;/li&amp;gt;
                &amp;lt;/ul&amp;gt;
            &amp;lt;/menu&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/template&amp;gt;

    &amp;lt;!-- 内容区域 --&amp;gt;
    &amp;lt;template id=&quot;show&quot;&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;section&amp;gt;
                &amp;lt;h1&amp;gt;内容区域&amp;lt;/h1&amp;gt;
            &amp;lt;/section&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/template&amp;gt;

    &amp;lt;script src=&quot;vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;vue-router.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;

        // 第一步：书写组件
        const header = {
            template: &quot;#header&quot;,
        }

        const menu = {
            template: &quot;#menu&quot;,
        }

        const show = {
            template: &quot;#show&quot;,
        }

        // 第二步：配置路由
        const routes = [
            {
                // 当你访问主页时，有三个组件扁平显示
                path: &quot;/&quot;, components: {
                    default: header,  // 如果 view-router没有name属性，则用default
                    menu: menu,
                    show: show,
                }
            }

        ]

        // 第三步：实例化路由对象
        const router = new VueRouter({
            routes, // es6新语法
        })


        // 第四步：根组件中添加路由信息 
        const app = new Vue({
            el: &quot;#app&quot;,
            router,
        });

    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;redirect&lt;/h2&gt;
&lt;p&gt;　　 当你访问一个页面时，可以重定向至另一个页面，如下示例，使用&lt;code&gt;redirect&lt;/code&gt;进行重定向。&lt;/p&gt;
&lt;p&gt;　　 访问&lt;code&gt;/doc&lt;/code&gt;,重定向到&lt;code&gt;/help&lt;/code&gt;中。但是地址栏中显示的还是&lt;code&gt;/help&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const routes = [
    // 当用户访问doc时，将会跳转到help中，地址栏中显示是help
    { path: &quot;/help&quot;, component: help, name: &quot;help&quot;},
    { path: &quot;/doc&quot;, redirect: { name: &quot;help&quot; } }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;alias&lt;/h2&gt;
&lt;p&gt;　　 如果你使用&lt;code&gt;alias&lt;/code&gt;参数进行匹配，就方便许多了，并且地址栏中显示的是用户输入的值，但是当输入的路径不存在，则不会显示：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/Vue%E7%9A%84%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91alias%E5%8F%82%E6%95%B0.gif&quot; alt=&quot;Vue的路由重定向alias参数&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const routes = [
    // 用户输入在alias中的所有路径，都会交给help组件进行处理
    { path: &quot;/help&quot;, component: help, name: &quot;help&quot;, alias: [&quot;/doc&quot;, &quot;/doc.html&quot;, &quot;/help.html&quot;] },
]
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　 如果你的&lt;code&gt;url&lt;/code&gt;中不想有&lt;code&gt;#&lt;/code&gt;号的锚点，可开启&lt;strong&gt;history&lt;/strong&gt;模式。&lt;/p&gt;
&lt;p&gt;　　 同时你还需要在后端做相应的配置，参见官方文档：&lt;/p&gt;
&lt;p&gt;　　 &lt;a href=&quot;https://router.vuejs.org/zh/guide/essentials/history-mode.html&quot;&gt;点我&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　 相信现在你已经对单页面开发有所了解，单页面开发说白了就是根据&lt;code&gt;url&lt;/code&gt;请求的&lt;code&gt;#&lt;/code&gt;后的参数不停的更换要显示的组件。&lt;/p&gt;
&lt;p&gt;　　 所以我们可以为这一切换过程加上过渡动画，你可以在其他子组件模板中添加&lt;code&gt;&amp;lt;transition&amp;gt;&lt;/code&gt;标签，并自己书写&lt;code&gt;css&lt;/code&gt;类或者引用第三方库。&lt;/p&gt;
&lt;p&gt;　　 如下所示：&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/Vue%E7%9A%84%E8%B7%AF%E7%94%B1%E5%8A%A8%E7%94%BB.gif&quot; alt=&quot;Vue的路由动画&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 我这里是单独给每个子组件加的动画：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        // 书写组件
        const index = {
            template:
             `
            &amp;lt;transition enter-active-class=&quot;animate__animated  animate__bounce&quot;&amp;gt;
                &amp;lt;h1&amp;gt;wecome to index&amp;lt;/h1&amp;gt;
            &amp;lt;/transition&amp;gt;
            `,

        }

        const backend = {
            template:             `
            &amp;lt;transition enter-active-class=&quot;animate__animated  animate__bounce&quot;&amp;gt;
                &amp;lt;h1&amp;gt;wecome to backend&amp;lt;/h1&amp;gt;
            &amp;lt;/transition&amp;gt;
            `,
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 如想了解更多，请参考官方文档。&lt;/p&gt;
</description>
<pubDate>Sat, 21 Nov 2020 14:34:00 +0000</pubDate>
<dc:creator>云崖先生</dc:creator>
<og:description>单页面原理 Vue是单页面开发，即页面不刷新。 页面不刷新，而又要根据用户选择完成内容的更新该怎么做？Vue中采用锚点来完成。 如访问http://127.0.0.1#/index就是主页，而访问ht</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yunya-Cnblogs/p/14017686.html</dc:identifier>
</item>
<item>
<title>你以为你登峰造极，实际上可笑至极 - 帝莘</title>
<link>http://www.cnblogs.com/zaevn00001/p/14012292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaevn00001/p/14012292.html</guid>
<description>&lt;p&gt;只是我想不管我们身在何方，不管我们当下如何安逸舒坦，我们都要不忘初心，记住自己最初的梦想，不要在生活的迷雾中看不清方向，在该奋斗的年纪里一定不要追求得过且过，混一天算一天不是我们这个年纪该做的事情，要找到自己的薄弱点去提升自己，让自己每天进步一点点。只争朝夕，不负韶华，我们都可以守得云开见月明。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;146&quot;&gt;
&lt;h2 align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;你以为你登峰造极，实际上可笑至极&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;出品人：Slience&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1912367/202011/1912367-20201121222856829-136841437.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;span&gt;2020年11月20日，星期五，我像往常一样倒数着下班的剩余时间···&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　读了几篇鸡汤博文，突然意识到，2020年马上过去11/12了，接近终点了···&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　而我望着自己度过的这一年以及逐渐发福的身体，心想：我TMD的这一年干了点啥！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&quot;上班下班买菜做饭最后洗碗，琐碎的牵绊，滋长不断&quot;，我的生活就像嵩哥这句歌词描述的那样，简单而又平淡，每日机械性的重复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这一年不平常，新冠肺炎疫情突然降临在这颗蓝色的星球上，尽管国内已经控制的很好了，但是国外依旧没有遏制住的样子，随着冬季到来，这种影响可能还会进一步的扩大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我是幸运的，我的工作并没有受到疫情的影响，清闲的工作状态，每月还能按时领到微微过万的薪水，准时下班，几个月都遇不到一次加班，逢人谈起无不羡慕，而我，也在这种温室环境下潇洒自如着，有工作就忙会儿，没工作就看几篇博客，有时还会偷偷戴上耳机听着音乐看会儿电子书，哎呀，小说里的主人公真厉害，随随便便就成了亿万富翁，还有那么多美丽智慧的小姐姐环绕在身边···啧啧···&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从农村出来的我，年纪轻轻的，活在这所无论呆多久都会陌生感十足的大城市里，干着父母眼里体面的工作，发小也挺羡慕我的，他们从事着教师，护士一类的工作，每个月的薪资不到4000块，还又忙又累。而我，简直人生赢家，每天装扮着人模人样，往那一坐，喝几杯茶，逛逛网页，中午点个外卖吃，到点就下班了，这不就是很多人理想的生活状态么，我就这样轻轻松松做到了，哈，我想登峰造极也不为过吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可我，总觉得弄丢了什么，我一定弄丢了什么，我弄丢了学生时期的理想，我弄丢了自己真正的快乐。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　自打毕业踏入社会那天起，理想这个词仿佛消失了一样，没有人再去提起，有时想提也不知道和周边的谁去聊，它好像不曾来过。无意间打开了自己旧电脑上的一个txt文件，上面写着：你要永远记着，你18岁那年曾在星空下立誓，27岁之前，你要靠自己的能力攒够100万。呵呵，多么幼稚可笑的理想，今年我25了，可是距离100万的目标，我还有着近90万的距离，两年时间，我，可以么。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我从来不是一个安于现状的人，准确点说曾经的我不是一个满足现状的人，大学期间有幸当了四年的班长，在学校校长办公室里也坐到了学生助理总负责人的位置，这些历练养成了我勇往直前不惧一切的性格，在享受着那些学弟学妹小干事的推崇尊重以及其他班的学生干部的互捧下，我变得有些目空一切，不再和中学时期一样去耐着性子学些东西，反而得过且过，技术什么的一塌糊涂，毫不夸张的说，那时候的我，for循环都没用明白。而我也自食恶果，学习成绩中游水平，导致那次关键的考试少考了一名，就那一名，我失去了评选党员的资格，本来是全班最有希望入党的人，就这样把名额白白让给别人。入党是我大学最想完成的一件事，天时地利都具备，可是在硬实力成绩面前，我输了，我本以为我登峰造极，实际上我可笑至极。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后来我决定考研。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　是的，冷静下来的我决定考研，我知道我实战技术不行，敲代码能力跟屎一样都不夸张，当时的我实在领悟不明白代码这玩意，直接就业的话太迷茫了。反而考研是学数学(高数线代概率论)，英语，思想政治，一门专业课，书面知识做好，会解题就行，和实际技术操作基本没啥关系。我并不笨，我初中的成绩能达到班里前2名，全年级10名左右，只是大学的忙碌让我静不下心来去学习，后来忙碌的事情能推就推，我天天扎根在考研教室，图书馆中，终于我看到了希望，我模拟几次测试，我的分值都能妥妥的挺进我报的那个学校那个专业的往年院线，尽管我的考研目标院校是一所不错的985大学，但是我依旧相信我可以的，那些考上研究生的学长学姐也为我加油打气，说我可以的。迎来了考试的那天，我TMD的居然又考前焦虑了，整整两天上吐下泻，油盐未进，坐在考场上都晕晕乎乎，我就知道完蛋了。。唉，为啥说是又焦虑了呢，因为我中考高考都这样，导致我比目标分数少考四五十，，结果研究生考试又这样。。分数出来的那天，324分，比工科国家线265（具体260还是270来，我忘了）高了五六十分，虽然状态差，但还是过国家线了不少，然而，我报的那所985大学那个专业那年人数骤增，院线设在了340，我连去那复试的资格都没有。。唉，别人都觉得我行，我也就以为我行，我以为我登峰造极，实际上我可笑至极。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我可以去调剂读研，但我还是狠狠心放弃了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本身就是一个普通的二本大学出身，调剂读研也只能去个差不多水平的学校，和我最初想借着考研平台跻身985大学的愿望落差太大，我知道普通大学的研究生可能接触不到好的资源，那样的话我可能会再浑浑噩噩三年然后拿个研究生的学历，硬实力还是很难提升，再加上父母年纪大了，丫的，逼自己一把吧，我还年轻，我怕啥，不就是几行代码么。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其实考研后的第三天我去了济宁，虽然我是软件工程专业没错，但却是与惠普合作培养软件测试的，由于学校安排和专业性质，我要去济宁惠普那里待几个月(实际前后加起来就呆了一个多月)，在那里，就学习的java开发，那时候一方面跟着技术老师学技术，另一方面班主任(班主任是惠普的老师不是大学的班主任)还有助教给我们洗脑，希望我们学习完合作规定的学习内容后，还能留下来继续学习更深层次的知识，不过那就得额外收费了。我认真的学免费的规定课程，每天很晚才回去宿舍，终于我把javaEE和javaOOP的前些内容学明白了，原来for循环不过如此么。这里还有个小插曲，当时班主任给我们上职业规划课时让我们做了一份公司入职测试题，大体上判断你是什么性格的人，而我，测出来了老虎性格和猫头鹰性格并存的性格，整个班级唯一一个，事后，助教还找我谈话，语重心长的告诉我，说我不乏能力只是缺少技术硬实力，他们惠普课程多么好多么好，要不要考虑下留下来继续深造。。。我。。大姐是故意的吧，先捧我，我可是不经夸啊。这样在济宁惠普呆了快20天时，我们整个班级被分割了，想上自习的一类，想学普通课程的一类，想深造上收费课程的一类。而我，拉着我舍友，交了1000块的押金，同时我还替我舍友交了1000块押金，去上了收费课程，因为可以试听10天，最后不在这待押金是可以退的。大部分人选择自由自习，我成了唯二去上收费课程的人，同学都说我别被骗了，但是我就想好好学点技术，新的班级是各个学校交押金进来的人，除了我舍友其余我一概不认识，可是班主任却是我原来的班主任，我被班主任直接任命为新班级的班长，协调任课老师的工作。新的任课老师确实有两把刷子，也认真负责，果然交钱和不交钱就不一样，在那期间，我被任课老师逼着搭建了svn服务器，给全班建账号密码，我也开始接触多态，集合，异常，网络编程，反射。。最后网络编程和反射把我学蒙圈了，但是前面那些总算学明白了，遗憾的是试听课没学到框架。。最后过年回家，考研成绩下发，镇定思痛，约定好几个同样考研失利的小伙伴，整装进京。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我以为我可以拼出新天地，实际上却一步步磨掉锐气。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　初进京的我，意气风发，没有忘记理想两个字，我觉得我可以的，我的微信签名一直是:我只是不想把自己定格在那么渺小。可是现实只会啪啪打脸，刚毕业的我不会框架没有经验，有谁会在意？你以为你大学当过几年班长很了不起，其实那也只是过眼云烟，企业招的的是技术小伙不是班干部，他们想要技术人才创造价值而不是文秘干部吹牛打屁讲些大道理，我突然觉得，曾经的荣耀很可笑，我以为我曾经登峰造极，实际上可笑至极啊。于是埋藏起一切大学的荣耀，收起自己的锐气，谨言慎行沉默以待，观察多学。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后来才明白，其实过去都不是真正的可笑至极。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　时间线回到现在，我作为一名java开发工程师，无惧任何开发任务了，使用框架开发那都是小意思，逻辑力不弱的我无论遇到多么复杂的业务逻辑过程，也能迅速的在脑海中分析找到一套可以解决的代码方案，悠哉悠哉的工作渐渐地压缩我的视野，我的视野变窄了，我以为是我曾经的努力换取了今天的工作现状，我该享受这一切了，可是，真的应该这样么？我才25岁，本该吃苦奋斗的年纪却过着养老般的生活，我接触不到公司任何核心的资源，我的工作只是敲增删改查的代码，有时候一坐一整天完全不知道脑子里在想些什么，虽然我也在看一些技术型的博客，但是却没有实战的机会，时间一长又忘记了，公司的项目遇不到复杂的百万级高并发等场景，我好像除了增删改查什么也学不到了，我有些迷茫了，我的java学习之旅遇到瓶颈了，我的同班级的大学同学今年5月份勇敢跳槽，拿到了20K的可观薪资，而我呢，20K可望不可及啊。。然而，清闲的惬意日子让我不想动也不想突破，即使跳槽大厂我也清楚目前实力真心不够，我开始怀念以前意气风发的样子，我开始怀念那个追求理想的自己，我开始觉得那个虽然结果可笑至极但是不抛弃不放弃的精神头也很帅，我想我如今安于现状的样子才是真正的可笑至极吧，可我居然误以为我自己登峰造极了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可能这是我的悲哀，也是数以百万计同龄人工作者的悲哀，我们曾经年少轻狂，许下了一个又一个的愿望，也曾肩并肩的去畅谈梦想，那时的我们虽然没钱虽然稚嫩，可是我们有勇气有理想，我们不怕输不怕突破自己。那时深更熬夜不是为了打游戏，只是为了多做一道高数题多整理一份文档，那时天还没亮就早起也不是为了赶地铁，而是为了早早进入图书馆抢个好位置，那时的结局虽然是悲哀的，但是过程却是精彩的，是那么的振奋人心那么的充实。那时的感觉真好，完全不觉得27岁攒够100万是可笑的事情，只会为了目标在大大的黑夜里小小的努力着。那时候虽然失败了很多次，但我想在人生的回忆录里，那会是最成功的自己了，因为那时候的自己还有一颗勇敢的心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然，写到这里并不是鼓励大家去辞掉稳定的工作去放飞自我，相反，我特别支持认真工作的人，只是我想不管我们身在何方，不管我们当下如何安逸舒坦，我们都要不忘初心，记住自己最初的梦想，不要在生活的迷雾中看不清方向，在该奋斗的年纪里一定不要追求得过且过，混一天算一天不是我们这个年纪该做的事情，要找到自己的薄弱点去提升自己，让自己每天进步一点点。只争朝夕，不负韶华，我们都可以守得云开见月明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　到底什么是真正的登峰造极什么是真正的可笑至极，我们谁也无法定义，也没办法准确的给个标准，我只知道，当你每天做的事让你感觉到充实感觉到进步感觉到振奋，那便足够吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　你以为你登峰造极，实际上可笑至极。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了登峰造极，别怕可笑至极!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　加油，打工人！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1912367/202011/1912367-20201121223054519-691278670.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 21 Nov 2020 14:34:00 +0000</pubDate>
<dc:creator>帝莘</dc:creator>
<og:description>只是我想不管我们身在何方，不管我们当下如何安逸舒坦，我们都要不忘初心，记住自己最初的梦想，不要在生活的迷雾中看不清方向，在该奋斗的年纪里一定不要追求得过且过，混一天算一天不是我们这个年纪该做的事情，要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zaevn00001/p/14012292.html</dc:identifier>
</item>
<item>
<title>使用Actor模型管理Web Worker多线程 - JunpengZ</title>
<link>http://www.cnblogs.com/ihardcoder/p/14017685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ihardcoder/p/14017685.html</guid>
<description>&lt;p&gt;前端固有的编程思维是单线程，比如JavaScript语言的单线程、浏览器JS线程与UI线程互斥等等，Web Woker是HTML5新增的能力，为前端带来多线程能力。这篇文章简单记录一下搜狗地图WebGL引擎（下文简称WebGL引擎）使用Web Worker的一些实践方案，虽然这个项目最终夭折并且我也从搜狗离职了，但在开发WebGL引擎过程中的一些心得和实践还是值得写一写的。&lt;/p&gt;
&lt;p&gt;搜狗地图WebGL引擎使用Actor模型管理worker线程，所以这篇文章就围绕这一点展开，包括以下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;WebGL引擎为何要使用Web Worker以及对worker线程的需求定位&lt;/li&gt;
&lt;li&gt;Actor模型是什么以及为何它适用于Web Worker&lt;/li&gt;
&lt;li&gt;WebGL引擎的Actor模型+Web Worker的实践方案&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;webgl引擎对web-worker的需求定位&quot;&gt;WebGL引擎对Web Worker的需求定位&lt;/h3&gt;
&lt;p&gt;我们看到的电子地图实际上是由一个个网格拼合起来，这些网格叫做瓦片。根据瓦片的类型，地图可以分两种，一种是用静态图片配合css拼接，这种称为栅格地图；另一种是由WebGL将数据绘制为图形，这些数据便是真实的地理坐标，这种称为矢量地图。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这么说其实不太严谨，大多数电子地图使用的是墨卡托坐标，经过计算后转换为屏幕坐标，而不是真实的经纬度坐标，这个话题不属于本文的范畴，以后会单独讲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;栅格地图是位图拼接的，是非矢量的，缩放会失真，这是缺点；优点是性能好，因为不需要很多计算。而矢量地图恰好相反，需要非常庞大的计算量，而优点便是缩放不会失真，并且可以实现3D效果。&lt;/p&gt;
&lt;p&gt;传统的网站大多数用不到Web Worker或者对worker线程的要求比较轻，比如拉个数据啥的。Web Worker最佳的应用场景是计算密集类业务，而WebGL引擎在前端领域内可以说计算最密集的应用，体现在两方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据量庞大&lt;/li&gt;
&lt;li&gt;计算复杂且密集&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如下面这张图是Level 8的中国局部地图:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/595796/202011/595796-20201121223018882-953333921.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个红色的网格就是一个瓦片，瓦片中的数据其实是一个个坐标点以及POI信息（坐标、文案等），WebGL引擎的工作包括以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据当前视野计算瓦片坐标；&lt;/li&gt;
&lt;li&gt;从后台接口获取瓦片数据；&lt;/li&gt;
&lt;li&gt;渲染。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;WebGL的渲染管线比较复杂，除了基本的GPU渲染管线以外，在CPU层面也有很繁重的工作，比如数据治理、缓存、创建纹理、矩阵计算等等。后面我会专门写一篇渲染管线的介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看起来很简单，就跟「把大象关进冰箱」一样拢共分三步，但其实里面的逻辑和计算非常复杂，我会在后续的文章里一一剖析，这篇只挑选与worker线程相关的内容讲。Web Worker在其中的主要工作有以下几个：&lt;/p&gt;
&lt;ul readability=&quot;9.4759493670886&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;从接口获取瓦片数据&lt;/strong&gt;。这个比较简单，没啥好说的，说白了就是网络请求，稍微特殊的就是地图瓦片的数据比较大，请求耗时相对会长一点；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;将瓦片数据解析为绘制可用的数据&lt;/strong&gt;。瓦片数据可以简单理解为&lt;strong&gt;地理坐标+规则&lt;/strong&gt;，WebGL引擎需要将地理坐标转化为屏幕坐标，然后按照规则将其进一步转化为最终可绘制的数据。这些规则包括样式（颜色/线宽等）、图形类别（Polygon/Line/Point等）、权重等，其中权重是比较特殊的一种规则，代表图形的绘制优先级，高优先级的后绘制，这是因为WebGL的绘制过程中，后绘制的图形会遮盖同位置已有的图形。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;10.950090744102&quot;&gt;
&lt;p&gt;&lt;strong&gt;对POI进行定位计算&lt;/strong&gt;。这个整个地图引擎中最复杂的一套计算流程。瓦片中的POI原始数据仅仅是一个点的地理坐标和文本，其中文本需要对应创建一个2D canvas作为WebGL的纹理。WebGL引擎首先需要从style文件中获取到POI的图标，然后将文本换算为canvas的尺寸，计算出整个POI图形的尺寸。比如天津的POI图形是这样的：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/595796/202011/595796-20201121223037015-512343906.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它最终的尺寸是包括坐标红点图标+坐标文本（实际是canvas纹理）的尺寸。而这类还算比较简单的POI，因为周边几乎没有其他POI，更复杂的还需要根据冲突检测结果&lt;strong&gt;动态调整&lt;/strong&gt;文本与图标的相对位置，比如下图的两个POI，「微电子与纳电子学习」POI文本在图标的下方，『超导量子信息处理实验室』POI的文本就只能置于左侧、右侧或下方，否则会冲突。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/595796/202011/595796-20201121223047700-1148006297.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后一步是对视野内的所有POI进行冲突检测，剔除优先级低且位置与高优POI冲突的条目。这类计算在WebGIS业内有种通用的算法，叫做R树算法，JavaScript可用的开源工具推荐&lt;a href=&quot;https://github.com/mourner/rbush&quot;&gt;rbush&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;对文本进行定位计算&lt;/strong&gt;，比如道路的名称需要沿着道路线条布局如下图，这项工作量也比较复杂，后面我会单独写一篇。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/595796/202011/595796-20201121223100865-193850999.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综合以上的描述，WebGL对于worker线程的需求可以概括为两点：&lt;strong&gt;网络请求&lt;/strong&gt;和&lt;strong&gt;计算&lt;/strong&gt;。这两项工作交给worker线程之后，主线程便可以将资源集中在处理用户交互上，从而提高用户体验。&lt;/p&gt;
&lt;p&gt;上面说的都是前提和需求，接下来就讲一讲如何实践的，首先介绍今天另一位主角：Actor模型。&lt;/p&gt;
&lt;h3 id=&quot;actor模型是什么&quot;&gt;Actor模型是什么&lt;/h3&gt;
&lt;p&gt;Actor模型是一个为了解决并行计算问题的抽象概念，它并不是一个新词，诞生在40多年之前。大致背景是因为单核CPU无法突破性能瓶颈只能通过多核并行计算提高效率，Actor模型就是为了解决并行计算由共享可变状态引起的race condition、dead lock等问题，更多细节自己去&lt;a href=&quot;https://en.wikipedia.org/wiki/Actor_model&quot;&gt;Wiki&lt;/a&gt;查。&lt;/p&gt;
&lt;p&gt;在前端领域Actor模型并没有被广泛使用，因为在Web Worker出现之前，前端并没有并行计算的条件，Google在2018年的Chrome dev submit中介绍了使用&lt;a href=&quot;https://www.youtube.com/watch?v=Vg60lf92EkM&amp;amp;list=PLNYkxOF6rcIDjlCx1PcphPpmf43aKOAdF&amp;amp;index=17&amp;amp;t=0s&quot;&gt;Actor模型搭配Web Worker&lt;/a&gt;的一套简易架构，这才有更多前端开发者去关注Actor模型。&lt;/p&gt;
&lt;p&gt;Actor模型有以下几个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;轻量：每个Actor只负责自己的工作，没有副作用；&lt;/li&gt;
&lt;li&gt;没有共享状态：每个Actor的state都是private，不存在共享状态。理想情况下，每个Actor都运行在不同的线程，也不存在共享内存；&lt;/li&gt;
&lt;li&gt;借助message通信：每个Actor通过接收message分发任务，可以理解为每个message都会触发一个任务，因此可能产生任务排队，每个Actor维护一个private task queue，每个task执行结束后通过message向外传递信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上特点可以概括为下图所示的模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.coderbridge.com/img/techbridge/images/arvinh/actor-model.png&quot; alt=&quot;Actor Model&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了以上特点以外，Actor的操作也有限制，只允许以下三种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;向外传送message;&lt;/li&gt;
&lt;li&gt;根据接受到的message分发对应任务。Actor对于message对应的任务并没有限定为静态的，而是可以携带动态数据甚至函数，这样就大大地增强了Actor的可定制性；&lt;/li&gt;
&lt;li&gt;创建其他Actor。一个Actor对于它创建的其他Actor有管理员权限，可以定制其他Actor的某些行为。比如Actor A创建了Actor B，对于Actor B来说，Actor A就是Supervisor Actor。Actor A可以限制Actor B的行为，比如当Actor B崩溃以后发送一个message通知Actor A，这样Actor A就可以在接收到这个message时重启Actor B。这种机制跟PM2的重启机制很相似。通过这个特性也能看出来，Actor模型不仅适用于处理并行计算问题，同样适合分布式系统。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;再说说为何Actor模型适合用来管理Web Worker线程。&lt;/p&gt;
&lt;p&gt;前端使用Web Worker实现的多线程是一种主从（Master-Slave）模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;worker线程只具备有限的权限，不能操作DOM，从这个角度上来说，worker线程对于浏览器来说是线程安全的；&lt;/li&gt;
&lt;li&gt;worker线程与master线程（即JS主线程）之间通过postMessage通信；&lt;/li&gt;
&lt;li&gt;master线程通过发送message指定worker执行哪些行为，worker线程通过message返回结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Actor理论模型中并没有规定多线程使用哪种模式，但是Supervisor Actor的存在很适合主从多线程，所以与Web Worker的结合看上去非常合适。&lt;/p&gt;
&lt;p&gt;但在实现层面，不一定完全遵从Actor理论模型，往往需要具体场景做一些改造，下面就简单讲一讲WebGL引擎在Actor+Web Worker方面的具体实现方式。&lt;/p&gt;
&lt;h3 id=&quot;actor模型在webgl引擎渲染的实践应用&quot;&gt;Actor模型在WebGL引擎渲染的实践应用&lt;/h3&gt;
&lt;p&gt;WebGL引擎对于worker线程的管理是一种类似负载均衡的模式，在Actor模型的基础之上增加了一个Dispatcher用于统筹管理所有的Actor，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/595796/202011/595796-20201121223153855-1832732511.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个Actor的工作包括以下几个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;管理一个worker线程，负责向worker线程发送message和接收message的实质行为；&lt;/li&gt;
&lt;li&gt;维护一个私有任务队列，在线程被占用时将后续任务塞入队列，并且在线程空闲时自动取出队列中下个任务并执行；&lt;/li&gt;
&lt;li&gt;维护一个私有状态-private busy，代表线程是否被占用，同时向外部提供访问入口public busy，Dispacher可以通过busy状态在所有Actor之间进行负载均衡。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Actor的伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-typescript&quot;&gt;export default class Actor {
  private readonly _worker:Worker;
  private readonly _id:number;

  private _callbacks:KV&amp;lt;Function&amp;gt; = {};
  private _counter: number = 0;
  private _queue:MessageObject[]=[];
  private _busy:boolean=false;

  constructor(worker:Worker, id:number) {
    this._id=id;
    this._worker = worker;
    this.receive = this.receive.bind(this);
    this._worker.addEventListener('message', this.receive, false);
  }
  /**
   * 占用状态
   * @memberof Actor
   */
  get busy():boolean{
    return this._busy;
  }
  set busy(status:boolean){
    this._busy = status;
    // 解除占用状态后如果待执行队列不为空则执行队首任务
    if(!status&amp;amp;&amp;amp;this._queue.length){
      const {action,data,callback} = this._queue.shift();
      this.send(action,data,callback);
    }
  }
  /**
   * @memberof Actor
   */
  get worker():Worker{
    return this._worker;
  }
  /**
   * @private
   * @method _postMessage
   * @param message
   */
  private _postMessage(message) {
    this._worker.postMessage(message);
  }
  private _queueTask(action:WORKER_ACTION, data, callback?:Function){
    this._queue.push({action,data,callback});
  }
  public receive(message:TypePostMessage) {
    this.busy = false;
    const {id,data} = message.data;
    const callback = id?this._callbacks[id]:null;
    callback&amp;amp;&amp;amp;callback(data);
    delete this._callbacks[id];
  }
  public send(action:WORKER_ACTION, data, callback?:Function) {
    if(this.busy){
      this._queueTask(action,data,callback);
      return;
    }
    this.busy = true;
    const callbackId = `${this._id}-${action}-cb-${this._counter}`;
    if(callback){
      this._callbacks[callbackId] = callback;
      this._counter++;
    }
    this._postMessage({
      action,
      data,
      id: callbackId,
    });
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Dispatcher的工作比较简单，向上负责接收外层逻辑的调用命令，向下负责管理所有Actor的调度，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-typescript&quot;&gt;export default class Dispatcher {
  private readonly _actorsCount: number = 1;
  private _actors: Actor[]=[];

  constructor(count:number) {
    this._actorsCount = count;
    for (let i = 0; i &amp;lt; count; i++) {
      this._actors.push(new Actor(new IWorker(''),i));
    }
  }
  /**
   * @public
   * @method broadcast 广播指令
   * @param {WORKER_ACTION} action 指令名称
   * @param {Object} data 数据
   */
  public broadcast(action: WORKER_ACTION, data: any) {
    for(const actor of this._actors){
      actor.send(action, data);
    }
  }
  /**
   * @public
   * @method send 向单个worker发送动作指令
   * @param {WORKER_ACTION} action 指令名称
   * @param {Object} data 数据
   * @param {Function} [callback] 回调函数
   * @param {string} [workerId] 指定worker id
   */
  public send(action:WORKER_ACTION, data: any, callback?:Function,workerId?:string) {
    const actor = this._actors.filter(a=&amp;gt;!a.busy)[0];
    if(actor){
      actor.send(action, data, callback);
    }else{
      const randomId = Math.floor(Math.random()*this._actorsCount);
      this._actors[randomId].send(action,data,callback);
    }
  }
  /**
   * @public
   * @method clear 终止所有worker，清空actors
   */
  public clear() {
    for(const actor of this._actors){
      actor.worker.terminate();
    }
    this._actors = [];
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Dispatcher需要一个广播API，用来给所有Actor同步信息，比如将瓦片数据中的地理坐标转化为屏幕坐标需要用到屏幕的DPR，可以借助broadcast API将这个信息发送给所有Actor。&lt;/p&gt;
&lt;p&gt;另外，Dispatcher并没有接受Actor的message，而是以回调函数的模式为每次任务分配一个handler，Actor执行完任务之后会触发对应的handler。以一个典型的用户交互触发重绘的行为为例，整个流程如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/595796/202011/595796-20201121223206288-1319136608.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户操作地图改变地图视野（bound）之后会触发WebGL引擎的重绘行为；&lt;/li&gt;
&lt;li&gt;第一步是通过当前视野计算可见的瓦片坐标列表，如果需要新的瓦片则触发加载；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tile_pyramid.ts&lt;/code&gt;调用分发器&lt;code&gt;dispatcher.ts&lt;/code&gt;执行加载瓦片的任务；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatcher.ts&lt;/code&gt;首先会判断所有Actor中是否有被占用的，如果存在空闲Actor则直接将任务分配给它，如果没有空闲Actor则随机选择一个Actor执行任务，此时被选中的Actor会将任务塞入任务队列，排队执行。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;以上便是WebGL引擎的对于Actor+worker的具体实现模式，加入负载均衡概念之后可以更有效地解决线程被占用时的任务动态分配。因为此WebGL引擎是内部项目，不便将更细节的代码写出来，比如worker的具体任务，所以大家就将就看吧。&lt;/p&gt;
</description>
<pubDate>Sat, 21 Nov 2020 14:33:00 +0000</pubDate>
<dc:creator>JunpengZ</dc:creator>
<og:description>前端固有的编程思维是单线程，比如JavaScript语言的单线程、浏览器JS线程与UI线程互斥等等，Web Woker是HTML5新增的能力，为前端带来多线程能力。这篇文章简单记录一下搜狗地图WebG</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ihardcoder/p/14017685.html</dc:identifier>
</item>
</channel>
</rss>