<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一篇文章带你学会Linux三剑客之一:awk - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/10108717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/10108717.html</guid>
<description>&lt;p&gt;awk是一种用于处理文本、模式匹配的编程语言。与sed和grep，俗称Linux下的三剑客。学会 awk 等于你在 Linux 命令行里，又多了一种处理文本的选择。这篇文章重点教你如何使用，看完这篇文章，就大致知道如何使用了，力求简单使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;术语铺垫&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在awk的文本处理规则里，awk将文本文件视为由字段和记录组成的文本数据库。默认情况下，awk将每一行视为一个记录，也就是说记录的分隔符是\n，记录的分隔符可以通过内置变量RS更改。&lt;/p&gt;
&lt;p&gt;在每一个记录中，又把记录分为若干个字段，即记录由字段组成，而字段的默认分隔符为空格或制表符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、基础用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和我们平常使用的 Linux 命令一样， awk 也是遵循着某种格式来使用，格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 使用格式
awk 执行的事件 文件

# 例如：
[root@iamshuaidi ~]# awk '{print $0}' test.txt
my first language:Java
second languange:python
third language:C
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/strong&gt;其中，print 表示打印，$0 表示一整个记录，test.txt 表示一个文件。所以&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
awk '{print $0}' test.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表示把 test.txt 文件里面的每行记录都打印出来。&lt;/p&gt;

&lt;p&gt;刚才我们说，记录是由字段组成的，且字段的默认分隔符是空格或者制表符。下面我们打印每一个记录的第一个字段，如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 打印每一行的第一个字段
[root@iamshuaidi # awk '{print $1}' test.txt
my
second
third
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;$0 表示整个记录，不过 $1, $2, $3.....则表示整个记录中的第一个字段，第二个字段......。&lt;/p&gt;

&lt;p&gt;刚才我们说字段的默认分隔符是空格或者制表符这些，默认意味着我们可以自己显式着指定分隔符。下面我们用“：”来作为我们的分隔符吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 打印第二个字段
[root@iamshuaidi ~]# awk -F ':' '{print $2}' test.txt
Java
python
C
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面我们用参数 -F 指定了我们的分隔符，即如果想要指定字段的分隔符，可以用参数 -F 指定分隔符。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、条件限制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在打印文本的时候，我们可以指定一些条件。格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
awk 参数 条件 要执行的动作 文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如我们指定分隔符为“：”，条件为第二个字段为&quot;Java&quot;的记录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 打印第二个字段为&quot;Java&quot;的文本
[root@iamshuaidi ~]# awk -F ':''$2 == &quot;Java&quot; {print $2}' test.txt
Java
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印奇数行的的第二个字段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 打印奇数行的记录
[root@iamshuaidi ~]# awk -F ':' 'NR % 2 == 1 {print $2}' test.txt
Java
C
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，NR 是一个内置的变量，表示当前正在处理的记录，即当前的记录是第几个记录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、条件语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和我们平常的编程一样，awk 也提供了 if, else, while 等这些条件语句。&lt;/p&gt;
&lt;p&gt;例如，打印第二个及其之后的记录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
root@iamshuaidi ~]# awk '{if(NR &amp;gt; 1) print $2}' test.txt
languange:python
language:C
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，上面的字段分隔符是空格了，并且 if 语句是在“{}” 里指定的。&lt;/p&gt;
&lt;p&gt;再看一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 如果第一个字段大于“s&quot;,则打印第一个字段，否则打印第二个字段
[root@iamshuaidi ~]# awk '{if($1 &amp;lt; &quot;s&quot;) print $1; else print $2}' test.txt
my
languange:python
language:C
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面打印的是：如果第一个字段大于“s&quot;,则打印第一个字段，否则打印第二个字段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;awk 提供了一些内置函数来供我们使用，一下常用的函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
tolower()：字符转为小写。
toupper()：字符转为大写
length()：返回字符串长度。
substr()：返回子字符串。
sqrt()：平方根。
rand()：随机数。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如，我们要把打印的字段转化为大小&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 第一个字段转化为大写输出
[root@iamshuaidi ~]# awk '{print toupper($1)}' test.txt
MY
SECOND
THIRD
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;五、变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;刚才我们说 NR 是一个表示当前正在处理的记录是第几个记录的内置变量，常用的内置变量如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
NR：表示当前处理的是第几行
NF：表示当前行有多少个字段
FILENAME：当前文件名
FS：字段分隔符，默认是空格和制表符。
RS：行分隔符，用于分割每一行，默认是换行符。
OFS：输出字段的分隔符，用于打印时分隔字段，默认为空格。
ORS：输出记录的分隔符，用于打印时分隔记录，默认为换行符。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如我们要打印每一个记录的最后一个字段，就可以使用变量 NF 了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
root@iamshuaidi ~]# awk '{print $NF}' test.txt
language:Java
languange:python
language:C
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对了，刚才那个 NR 的变量也是挺好用的，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
# 标记当前是第几行，这样看起来好像比较舒服？
[root@iamshuaidi ~]# awk '{print NR &quot;. &quot;  $0}' test.txt
1. my first language:Java
2. second languange:python
3. third language:C
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;讲到这里就大致结束了，这篇文章算是入门文章，屏蔽了很多细节，大致介绍一下怎么使用，更多具体用法，可以根据自己想要实现的功能去查找相关函数哦。&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;个人公众号：【苦逼的码农】，分享各种技术干货&lt;/p&gt;
&lt;p&gt;为方便交流，创建了个qq交流群：822241847，用来分享一些学习资源，面试干货。&lt;br/&gt;欢迎你的加&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Wed, 12 Dec 2018 07:35:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>awk是一种用于处理文本、模式匹配的编程语言。与sed和grep，俗称Linux下的三剑客。学会 awk 等于你在 Linux 命令行里，又多了一种处理文本的选择。这篇文章重点教你如何使用，看完这篇文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/10108717.html</dc:identifier>
</item>
<item>
<title>java 8 新特性之日期-时间 API - Liant</title>
<link>http://www.cnblogs.com/liantdev/p/10108504.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liantdev/p/10108504.html</guid>
<description>&lt;h4 id=&quot;date-time-api简介&quot;&gt;Date-Time API简介&lt;/h4&gt;
&lt;p&gt;在Java8之前的版本中，我们处理时间类型常常使用的是java.util包下的Date类。但使用Date类却有诸多的弊端，如： java.util.Date 是非线程安全的，所有的日期类都是可变的；日期/时间类的定义并不一致，在java.util和java.sql的包下都含有Date类，在开发过程中极易出错； 日期类并不提供国际化，没有时区支持。为了解决以上问题，Java8在java.time 包下提供了很多新的 API，常用的类包括LocalDate、LocalTime、LocalDateTime，用以处理日期，时间，日期/时间等&lt;/p&gt;
&lt;h4 id=&quot;localdate类&quot;&gt;LocalDate类&lt;/h4&gt;
&lt;p&gt;LocalDate是一个不可变类，在不考虑时区的情况下可以对日期（不包括时间）进行各种操作，它的默认格式是yyyy-MM-dd&lt;br/&gt;&lt;strong&gt;获取当前日期以及年、月、日&lt;/strong&gt;&lt;br/&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//获取当前日期以及年、月、日
LocalDate localDate = LocalDate.now();
int year = localDate.getYear();
int month = localDate.getMonthValue();
int day = localDate.getDayOfMonth();
System.out.println(&quot;当前日期：&quot; + localDate);
System.out.println(&quot;年：&quot; + year + &quot;  月：&quot; + month + &quot;  日：&quot; + day);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当前日期：2018-12-12
年：2018  月：12  日：12&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;获取指定的日期&lt;/strong&gt;&lt;br/&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//获取指定的日期
LocalDate specifiedDay = LocalDate.of(2008, 8, 18);
System.out.println(&quot;指定日期：&quot; + specifiedDay);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;指定日期：2008-08-18&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;比较两个时间的先后顺序以及是否相等&lt;/strong&gt;&lt;br/&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LocalDate localDate = LocalDate.now();
LocalDate otherDate = LocalDate.of(2018, 11, 11);
        
//equals方法用于比较两个日期是否相等
if(localDate.equals(otherDate)) {
    System.out.println(&quot;localDate与otherDate相等！&quot;);
} else {
     //isAfter和isBefore方法用于比较两个日期前后顺序
     if(localDate.isAfter(otherDate)) {
         System.out.println(&quot;localDate晚于otherDate！&quot;);
     }
     if(localDate.isBefore(otherDate)) {
         System.out.println(&quot;localDate早于otherDate！&quot;);
     }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;localDate晚于otherDate！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对日期做加减运算&lt;/strong&gt;&lt;br/&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LocalDate localDate = LocalDate.now();
System.out.println(&quot;2年后日期：&quot; + localDate.plusYears(2));
System.out.println(&quot;6月后日期：&quot; + localDate.plusMonths(6));
System.out.println(&quot;3周后日期：&quot; + localDate.plusWeeks(3));
System.out.println(&quot;15天后日期：&quot; + localDate.plusDays(15));

System.out.println(&quot;2年前日期：&quot; + localDate.minusYears(2));
System.out.println(&quot;6月前日期：&quot; + localDate.minusMonths(6));
System.out.println(&quot;3周前日期：&quot; + localDate.minusWeeks(3));
System.out.println(&quot;15天前日期：&quot; + localDate.minusDays(15));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2年后日期：2020-12-12
6月后日期：2019-06-12
3周后日期：2019-01-02
15天后日期：2018-12-27

2年前日期：2016-12-12
6月前日期：2018-06-12
3周前日期：2018-11-21
15天前日期：2018-11-27&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;获取日期间隔的天数&lt;/strong&gt;&lt;br/&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//获取某年份的第N天的日期
LocalDate specialDay = LocalDate.ofYearDay(2018, 100);
System.out.println(&quot;2018年的第100天：&quot; + specialDay);
//获取两个日期的间隔天数
long intervalDay = localDate.toEpochDay() - specialDay.toEpochDay();
System.out.println(&quot;间隔天数： &quot; + intervalDay);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2018年的第100天：2018-04-10
间隔天数：246&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;localtime类&quot;&gt;LocalTime类&lt;/h4&gt;
&lt;p&gt;LocalTime与LocalDate一样，也是一个不可变的类，默认格式是hh:mm:ss.zzz，它提供了对时间的各种操作&lt;br/&gt;&lt;strong&gt;获取当前时间以及自定义时间&lt;/strong&gt;&lt;br/&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//获取当前时间、时、分、秒以及自定义时间
LocalTime localTime = LocalTime.now();
int hour = localTime.getHour();
int minute = localTime.getMinute();
int second = localTime.getSecond();
System.out.println(&quot;当前时间：&quot; + localTime);
System.out.println(&quot;时：&quot; + hour + &quot;  分：&quot; + minute + &quot;  秒：&quot; + second);

//获取自定义时间
LocalTime specifiedTime = LocalTime.of(15, 30, 45);
System.out.println(&quot;自定义时间：&quot; + specifiedTime);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当前时间：13:45:59.039
时：13  分：45  秒：59
自定义时间：15:30:45&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;比较两个时间的先后顺序&lt;/strong&gt;&lt;br/&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//equals方法比较两个时间是否相等
if(localTime.equals(specifiedTime)) {
    System.out.println(&quot;localTime与specifiedTime相等！&quot;);
} else {
    //isAfter、isBefore方法比较两个时间的先后顺序
    if(localTime.isAfter(specifiedTime)) {
        System.out.println(&quot;localTime晚于specifiedTime！&quot;);
    }
    if(localTime.isBefore(specifiedTime)) {
        System.out.println(&quot;localTime早于specifiedTime！&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;localTime早于specifiedTime！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对时间做加减运算&lt;/strong&gt;&lt;br/&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LocalTime localTime = LocalTime.now();
System.out.println(&quot;当前时间：&quot; + localTime);
System.out.println(&quot;2小时后时间：&quot; + localTime.plusHours(2));
System.out.println(&quot;30分钟后时间：&quot; + localTime.plusMinutes(30));
System.out.println(&quot;500秒后日时间：&quot; + localTime.plusSeconds(500));
        
System.out.println(&quot;2小时前时间：&quot; + localTime.minusHours(2));
System.out.println(&quot;30分钟前时间：&quot; + localTime.minusMinutes(30));
System.out.println(&quot;500秒前时间：&quot; + localTime.minusSeconds(500));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当前时间：14:10:15.666
2小时后时间：16:10:15.666
30分钟后时间：14:40:15.666
500秒后时间：14:18:35.666

2小时前时间：12:10:15.666
30分钟前时间：13:40:15.666
500秒前时间：14:01:55.666&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;localdatetime类&quot;&gt;LocalDateTime类&lt;/h4&gt;
&lt;p&gt;LocalDateTime是一个不可变的日期-时间对象，它既包含了日期同时又含有时间，默认格式是yyyy-MM-ddTHH-mm-ss.zzz&lt;br/&gt;&lt;strong&gt;获取当前日期时间以及自定义日期时间&lt;/strong&gt;&lt;br/&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; //获取当前的日期时间
LocalDateTime localDateTime = LocalDateTime.now();
System.out.println(&quot;当前的日期时间：&quot; + localDateTime);

//获取自定义的的日期时间
LocalDateTime specifiedDateTime = LocalDateTime.of(LocalDate.now(), LocalTime.now());
System.out.println(&quot;自定义的日期时间：&quot; + specifiedDateTime);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当前的日期时间：2018-12-12T14:31:00.163
自定义的日期时间：2018-12-12T14:31:00.164&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;转化为日期和时间&lt;/strong&gt;&lt;br/&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//转化为LocalDate和LocalTime
LocalDate localDate = localDateTime.toLocalDate();
LocalTime localTime = localDateTime.toLocalTime();
System.out.println(&quot;当前日期：&quot; + localDate);
System.out.println(&quot;当前时间：&quot; + localTime);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当前日期：2018-12-12
当前时间：14:31:00.163&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 12 Dec 2018 07:11:00 +0000</pubDate>
<dc:creator>Liant</dc:creator>
<og:description>Date Time API简介 在Java8之前的版本中，我们处理时间类型常常使用的是java.util包下的Date类。但使用Date类却有诸多的弊端，如： java.util.Date 是非线程安</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liantdev/p/10108504.html</dc:identifier>
</item>
<item>
<title>Dubbo下一站：Apache顶级项目 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10108495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10108495.html</guid>
<description>&lt;p&gt;&lt;img title=&quot;_2018_12_04_10_29_09&quot; src=&quot;https://yqfile.alicdn.com/1533ca3c248d38eee9102c7d3bdfb4cec92642b9.png&quot; alt=&quot;_2018_12_04_10_29_09&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;导读：&lt;/p&gt;
&lt;p&gt;近日，在Apache Dubbo开发者沙龙杭州站的活动中，阿里巴巴中间件技术专家曹胜利(展图)向开发者们分享了Dubbo2.7版本的规划。&lt;/p&gt;
&lt;p&gt;本文将为你探秘 Dubbo 2.7背后的思考和实现方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Dubbo 2.7 将围绕 异步支持优化、元数据改造，引入JDK8的特性、Netty4.0的特性以及MetricsAPI 5个方面提升服务调用和服务治理的效率，以及可扩展性，同时将修复社区提出的若干问题。&lt;/p&gt;
&lt;p&gt;据悉，2.7.x会作为Dubbo在Apache社区的毕业版本，Dubbo将有机会成为继RocketMQ后，来自阿里巴巴的又一个Apache顶级项目(TLP)。&lt;/p&gt;
&lt;h2 id=&quot;1&quot;&gt;优化对异步的支持&lt;/h2&gt;
&lt;p&gt;基于Dubbo实现全异步编程，是在2.7.0版本中对现有异步方式增强后新引入的功能。之前的版本对异步支持用起来不是很友好，存在若干问题，2.7版本将基于JDK8 中的CompletableFuture做出一些针对性的增强，同时新增了@Dubboasync的注解，通过这个注解可以生成异步化相关的代码。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;_2018_12_04_10_28_50&quot; src=&quot;https://yqfile.alicdn.com/3670f8276a8616be56178453fd1b6398ec114157.png&quot; alt=&quot;_2018_12_04_10_28_50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;» 2.6.x版本之前的异步方式&lt;/p&gt;
&lt;p&gt;在2.6.x及之前的版本提供了一定的异步编程能力，包括Consumer端异步调用、参数回调、事件通知等。但当前的异步方式存在以下问题：&lt;/p&gt;
&lt;p&gt;Future获取方式不够直接；&lt;/p&gt;
&lt;p&gt;Future接口无法实现自动回调，而自定义ResponseFuture虽支持回调但支持的异步场景有限，如不支持Future间的相互协调或组合等；&lt;/p&gt;
&lt;p&gt;不支持Provider端异步&lt;/p&gt;
&lt;p&gt;以Consumer端异步使用方式为例：&lt;/p&gt;
&lt;p&gt;1、定义一个普通的同步接口并声明支持异步调用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;interface &lt;span class=&quot;hljs-title&quot;&gt;FooService {
&lt;span class=&quot;hljs-function&quot;&gt;String &lt;span class=&quot;hljs-title&quot;&gt;findFoo(&lt;span class=&quot;hljs-params&quot;&gt;String name);}

&amp;lt;dubbo:reference id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;fooService&quot; &lt;span class=&quot;hljs-keyword&quot;&gt;interface=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.alibaba.foo.FooService&quot;&amp;gt;
  &amp;lt;dubbo:method name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;findFoo&quot; &lt;span class=&quot;hljs-keyword&quot;&gt;async=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot; /&amp;gt; &amp;lt;/dubbo:reference&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、通过RpcContext获取Future&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;从这个简单的示例我们可以体会到一些使用中的不便之处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;findFoo的同步接口，不能直接返回代表异步结果的Future，通过RpcContext进一步获取。&lt;/li&gt;
&lt;li&gt;Future只支持阻塞式的get()接口获取结果。&lt;/li&gt;
&lt;li&gt;通过获取内置的ResponseFuture接口，可以设置回调。但获取ResponseFuture的API使用不便，且仅支持设置回调其他异步场景均不支持，如多个Future协同工作的场景等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;» 2.7.0基于CompletableFuture的增强&lt;/p&gt;
&lt;p&gt;了解Java中Future演进历史的同学应该知道，Dubbo 2.6.x及之前版本中使用的Future是在Java 5中引入的，所以存在以上一些功能设计上的问题，而在Java 8中引入的CompletableFuture进一步丰富了Future接口，很好的解决了这些问题。&lt;/p&gt;
&lt;p&gt;Dubbo在2.7.0版本已经升级了对Java 8的支持，同时基于CompletableFuture对当前的异步功能进行了增强。&lt;/p&gt;
&lt;p&gt;1、支持直接定义返回CompletableFuture的服务接口。通过这种类型的接口，我们可以更自然的实现Consumer、Provider端的异步编程。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;interface &lt;span class=&quot;hljs-title&quot;&gt;AsyncService {
&lt;span class=&quot;hljs-function&quot;&gt;CompletableFuture&amp;lt;String&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;sayHello(&lt;span class=&quot;hljs-params&quot;&gt;String name);}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、如果你不想将接口的返回值定义为Future类型，或者存在定义好的同步类型接口，则可以额外定义一个异步接口并提供Future类型的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface &lt;span class=&quot;hljs-title&quot;&gt;GreetingsService {
&lt;span class=&quot;hljs-function&quot;&gt;String &lt;span class=&quot;hljs-title&quot;&gt;sayHi&lt;span class=&quot;hljs-params&quot;&gt;(String name);}

&lt;span class=&quot;hljs-meta&quot;&gt;@AsyncFor(GreetingsService.class)&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface &lt;span class=&quot;hljs-title&quot;&gt;GrettingServiceAsync &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;GreetingsService {
&lt;span class=&quot;hljs-function&quot;&gt;CompletableFuture&amp;lt;String&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;sayHiAsync&lt;span class=&quot;hljs-params&quot;&gt;(String name);}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，Provider可以只实现sayHi方法；而Consumer通过直接调用sayHiAsync可以拿到一个Future实例，Dubbo框架在Provider端会自动转换为对sayHi方法的调用。为每个同步方法提供一个异步方法定义会比较麻烦，更进一步的，利用Dubbo生态中的AnnotationProcessor实现，可以自动帮我们自动生成异步方法定义。&lt;/p&gt;
&lt;p&gt;3、同样的，如果你的原始接口定义不是Future类型的返回值，Provider端异步也提供了类似Servlet3.0里的Async Servlet的编程接口: RpcContext.startAsync()。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface &lt;span class=&quot;hljs-title&quot;&gt;AsyncService {
&lt;span class=&quot;hljs-function&quot;&gt;String &lt;span class=&quot;hljs-title&quot;&gt;sayHello&lt;span class=&quot;hljs-params&quot;&gt;(String name);}

&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;AsyncServiceImpl &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;AsyncService {
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;sayHello&lt;span class=&quot;hljs-params&quot;&gt;(String name) {
    &lt;span class=&quot;hljs-keyword&quot;&gt;final AsyncContext asyncContext = RpcContext.startAsync();
    &lt;span class=&quot;hljs-keyword&quot;&gt;new Thread(() -&amp;gt; {
        asyncContext.write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Hello &quot; + name + &lt;span class=&quot;hljs-string&quot;&gt;&quot;, response from provider.&quot;);
    }).start();
    &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;null;
}}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在方法体的开始RpcContext.startAsync()启动异步，并开启新线程异步的执行业务逻辑，在耗时操作完成后通过asyncContext.write将结果写回。&lt;/p&gt;
&lt;p&gt;4、RpcContext直接返回CompletableFuture&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;CompletableFuture&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;String&amp;gt; f = RpcContext.getContext().getCompletableFuture();
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上所有的增强，是在兼容已有异步编程的基础上进行的，因此基于2.6.x版本编写的异步程序不用做任何改造即可顺利运行。&lt;/p&gt;
&lt;h2 id=&quot;2&quot;&gt;元数据改造&lt;/h2&gt;
&lt;p&gt;元数据的改造主要是从适配微服务注册中心、配置中心分离的模型、减轻注册中心压力、提高服务治理能力和效率的角度来执行的。目前版本的Dubbo在注册中心的URL有数十个key/value的键值对，包含了一个服务的所有元数据。在大规模实践的基础上，我们逐渐发现这样组织的元数据存在一些问题：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;_2018_12_04_10_28_30&quot; src=&quot;https://yqfile.alicdn.com/614b1fbf2f78c9708674f4fcae2ffc15571a9074.png&quot; alt=&quot;_2018_12_04_10_28_30&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注册中心存储的URL过长：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;导致存储压力骤增，变更事件的推送效率明显下降；同时给订阅方带来了额外的计算压力，尤其是大规模场景下的内存，增长显著。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注册中心承担了过多服务治理配置的功能：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;负责初始配置的同步，同时负责存储各种运行期配置规则。这一方面加剧了注册中心的压力，另一方面配置规则的灵活性也受到了一定的限制，同时也无法利用一些更专业的微服务配置中心带来的强大功能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;属性的功能定位不清晰：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;methods, pid, owner看起来都是为服务查询服务而注册的属性，但当我们实际开发或操作服务管控系统时，却发现这样简陋的信息是很难满足查询治理需求的。我们更多的属性，需要更丰富的注册数据。以methods为例，虽然方法列表的内容已经很长了，但当我们要在OPS开发服务测试/mock功能时，却发现需要的方法签名等数据还是无法获取。&lt;/p&gt;
&lt;p&gt;概括以上问题，我们将URL中的元数据划分了三个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;元数据信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接口的完整定义：包含接口名，接口所含的方法，以及方法所含的出入参信息。对于服务测试和服务mock有非常重要的作用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行链路上数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要将参数从provider端传递给消费者端，让消费者端感知到的。如token，timeout等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务自持有配置&amp;amp;Ops需求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只有在provider端或者消费者端需要使用的，如executes, document等。&lt;/p&gt;
&lt;h2 id=&quot;3&quot;&gt;支持配置中心&lt;/h2&gt;
&lt;p&gt;配置中心是dubbo.properties的动态版本，支持的粒度包括全局的、应用级别的和服务级别的等维度。通过上面的元数据改造，配置中心支持，再加上原有的注册中心，Dubbo体系里就会存在：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;_2018_12_04_10_28_14&quot; src=&quot;https://yqfile.alicdn.com/e8b268d26ed6fc61b4856db355314d47ad389e9d.png&quot; alt=&quot;_2018_12_04_10_28_14&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注册中心：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;理想情况下，注册中心将只用于关键服务信息（核心链路）的同步，进一步减轻注册中心的存储压力，提高地址同步效率，同时缓解当前由于URL冗余在大规模推送时造成的Consumer端内存计算压力。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置中心：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;解决当前配置和地址信息耦合的问题，通过抽象动态配置层，让开发者可以对接微服务场景下更常用的、更专业的配置中心，如Nacos, Apollo, Consul, Etcd等；提供更灵活的、更丰富的配置规则，包括服务、应用不同粒度的配置，更丰富的路由规则，集中式管理的动态参数规则等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务查询治理中心（含元数据）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于纯粹的服务查询相关的数据，包括Consumer的服务订阅数据，往往都是注册后不可变的并且不需要节点间的同步，如当前URL可以看到的methods、owner等key以及所有的Consumer端URL。&lt;/p&gt;
&lt;p&gt;因此我们在2.7.0中引入了存储模块，专门用来存放这部分数据，这部分将会和新版本的Dubbo-ops密切整合，作为丰富的服务查询、测试等功能的数据基础，因此这部分的数据将会得到进一步的丰富。总体来说否开启此功能对用户将是可选的，并且实现上也将是可扩展的，如我们计划支持Redis, Zookeeper等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;路由规则&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Dubbo 提供了具有一定扩展性的路由规则，其中具有代表性的是条件路由和脚本路由。2.6.x及以下版本存在的问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;路由规则存储在注册中心&lt;/li&gt;
&lt;li&gt;只支持服务粒度的路由，应用级别无法定义路由规则&lt;/li&gt;
&lt;li&gt;支持路由缓存，但基本不具有扩展性&lt;/li&gt;
&lt;li&gt;一个服务或应用允许定义多条路由规则，服务治理无法管控&lt;/li&gt;
&lt;li&gt;实现上，每条规则生成一个Router实例并动态加载&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从问题出发我们重新设计，将原来的路由配置从注册中心迁往配置中心。明确了配置和服务发现的边界。新增了RouterChain，用于重构路由规则逻辑，新增应用级别路由，Tag路由优化等。针对服务级别的路由，精确到单个服务，避免了无法明确路由规则的问题。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;1542599027719_60a91cb5_f2b1_4a1b_9d60_137f77d79341_jpeg&quot; src=&quot;https://yqfile.alicdn.com/3fd2a7e1795bcc3c54e22aa19d30fed6dbe46040.jpeg&quot; alt=&quot;1542599027719_60a91cb5_f2b1_4a1b_9d60_137f77d79341_jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们简单概括下各个类的协作关系。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RegistryDirectory，包含完整的地址列表，直接对接注册中心，并动态接收注册中心地址变更。&lt;/li&gt;
&lt;li&gt;RouterChain，由Router组装成的列表，是路由动作的入口，接收传入的地址列表并将过滤后的地址列表返回给调用方，而具体的过滤动作则委托给Router执行&lt;/li&gt;
&lt;li&gt;Router，接收并解析路由规则，接收地址列表，根据路由规则完成过滤动作，并返回过滤后的地址列表。其本身也是一个ConfigurationListener，随时接收路由规则更新。&lt;/li&gt;
&lt;li&gt;ConfigurationListener，动态配置变更的回调接口&lt;/li&gt;
&lt;li&gt;DynamicConfiguration，动态配置SPI，支持的扩展实现包括Zookeeper、Apollo、Nacos等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Dubbo 将在近期正式发布2.7.0版本，恰值Dubbo宣布重启一周年。这一年，Dubbo 共发布了13个版本，社区共有24位PPMC/Committer，144位Contributor，在北京、上海、深圳、成都和杭州举办了5场开发者沙龙，但技术开源的道路并没有止境，我们欢迎更多的开发者们可以参与进来，并到Dubbo meetup来进行分享，一起建设Dubbo生态。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;_2018_12_04_10_29_24&quot; src=&quot;https://yqfile.alicdn.com/8acd1df845496d3f18639f57cbfa31d258166b60.png&quot; alt=&quot;_2018_12_04_10_29_24&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/675390?utm_content=g_1000030563&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Dec 2018 07:10:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>导读： 近日，在Apache Dubbo开发者沙龙杭州站的活动中，阿里巴巴中间件技术专家曹胜利(展图)向开发者们分享了Dubbo2.7版本的规划。 本文将为你探秘 Dubbo 2.7背后的思考和实现方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10108495.html</dc:identifier>
</item>
<item>
<title>iOS客户端图片智能裁剪 - KenshinCui</title>
<link>http://www.cnblogs.com/kenshincui/p/ios-tu-pian-zhi-neng-cai-jian.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenshincui/p/ios-tu-pian-zhi-neng-cai-jian.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/62046/201812/62046-20181212142028662-1159999300.jpg&quot; alt=&quot;SmartCrop_Logo&quot;/&gt;￼&lt;/p&gt;

&lt;p&gt;所谓智能裁剪其实就是按照指定尺寸裁剪或显示出包含图片核心特征的区域，目前很多智能裁剪都是在服务器端做的，在客户端需要访问时直接裁剪放到Redis或者提前裁剪好以备访问。但是找了一圈直接在iOS客户端进行裁剪的库还不多，或者使用成本比较高，不能即拿即用。但是有时候客户端可能并非直接从服务器端获取数据而是读取相册数据，不可能先把图片存放到服务器端裁剪然后再拿来用，考虑到这种场景也不再少数，因此就有必要思考一套客户端智能裁剪的方案。&lt;/p&gt;

&lt;p&gt;最近两天整理了之前开发一个软件过程中自己开发的一个客户端智能裁剪库供有需要的同学使用，当然后面有时间的话会整理开源。说是库本质就是一套算法而已，但是在编写这套算法期间也参考评估过很多已有或者想要使用而没有使用的解决方案。&lt;/p&gt;
&lt;p&gt;首先说一下目前在网上比较容易找到的一些库存在的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;没有iOS对应的版本，集成起来极其复杂，之前为了用一个不错的库甚至在iOS调用Python库&lt;/li&gt;
&lt;li&gt;速度慢，生成一张智能裁剪后的图片需要1s左右，不再可容忍范围之内&lt;/li&gt;
&lt;li&gt;人像识别不准确，图片中占比较小的人脸识别不出来，甚至有可能出现误识别（这个其实比识别不出来问题还大）&lt;/li&gt;
&lt;li&gt;基于专利收费算法实现（例如使用SRUF），不仅开发者使用起来要引用大量的库而且有收费风险&lt;/li&gt;
&lt;li&gt;集成比较麻烦，使用起来光配置环境就要摆弄半天，还不一定能成功&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，事实上在探索过程中也走了不少的弯路，遇到的问题要比上面多得多，包括有些算法只能裁剪横图，对于宽高比较小的竖图支持很差，又或者引入大量的库造成app本身大小直线上升等等。。。因此这也就是为什么自己要开发一个新的库&lt;strong&gt;SmartCrop.framework&lt;/strong&gt;而不是基于现有库来做的原因。&lt;/p&gt;
&lt;p&gt;那么&lt;strong&gt;SmartCrop.framework&lt;/strong&gt;智能裁剪库又有什么特点呢：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;跨平台，当然既然作为一个iOS开发者一定要包含iOS版本（尽管此文中只提供了iOS版本，不过其实这个库本身基于c++实现，天然具有跨平台特性，后续有时间也会整理其他平台的版本）&lt;/li&gt;
&lt;li&gt;速度快，几乎可以做到实时裁剪😆（当然这个比较理想，不过测试中本文提供的库对于裁剪1000px以上的大图iPhone X上已经可以做到0.1s以下，后续会持续优化）&lt;/li&gt;
&lt;li&gt;精准的人脸识别，基于神经网络进行识别，让人像识别更加精准迅速（尽管需要一个训练好的模型，不过模型本身并不大）&lt;/li&gt;
&lt;li&gt;免费、好用，没有专利之争、集成迅速，按照步骤一分钟之内完成&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，&lt;strong&gt;SmartCrop.framework&lt;/strong&gt;也并非完美，这个库本身基于OpenCV的c++算法实现，综合了很多算法实现了特征点检测，这也就是说App需要集成opencv2.framework。另外算法本身还有优化空间，特别是特征点检测中对于色差分辨不是特变明显的图片裁剪精准度会有下降，后面也会进一步优化，不过对比了几个线上已有的库来说精准度应该要比这些库提高不少，毕竟再好的智能裁剪也是基于某些特征，和人为的意识还有不少差别。&lt;/p&gt;

&lt;p&gt;这里选取了之前使用过的一个Python库作为对比，在iOS中运行10张1000px左右的图片裁剪需要15s左右，这也是之前app中使用的实际结果。当然这其中有间接调用Python的成本，以至于后来直接测试了它的Android版本，大概耗时10s。下面是10张图的裁剪结果对比，为了方便看出裁剪效果使用了横图裁剪成竖图的对比，而图片选择部分尽量包括了人像和非人像图片，视频中每组图有三张，分别是原图、第三方库裁剪后的效果、&lt;strong&gt;SmartCrop.framework&lt;/strong&gt;裁剪后的效果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XMzk2MDcyMDgzNg==.html?spm=a2hzp.8244740.0.0&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/62046/201812/62046-20181212155431020-1092348403.jpg&quot; alt=&quot;compareVideo&quot;/&gt;￼&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当然从视频不难看出，&lt;strong&gt;SmartCrop.framework&lt;/strong&gt;人像裁剪相当精准，第1、3、4中的人脸第三方库没有识别出来，在非人脸识别的图片中第6张树的裁剪不理想。当然&lt;strong&gt;SmartCrop.framework&lt;/strong&gt;也不是百分百完美，最后一张猫的图片裁剪效果不如第三方库，因为除了猫之外将右侧的树识别成了关键特征位置。当然也会发现第2张图片中两个库都识别出了多个人脸，也都在有限的宽度内裁剪除了两个人，但是位置不同，这个和裁剪策略和特征分析算法有关。&lt;/p&gt;

&lt;p&gt;引入&lt;strong&gt;SmartCrop.framework&lt;/strong&gt;只需要从这里下载&lt;a href=&quot;https://github.com/kenshincui/SmartCropLib&quot;&gt;SmartCropDemo&lt;/a&gt;，找到其中的&lt;strong&gt;SmartCrop.framework&lt;/strong&gt;直接将此库拖拽到自己的项目中，在Xcode的&lt;strong&gt;Embedded Binaries&lt;/strong&gt;中添加&lt;strong&gt;SmartCrop.framework&lt;/strong&gt;即可（或者Build Phase的Copy File中添加&lt;strong&gt;SmartCrop.framework&lt;/strong&gt;），然后在&lt;strong&gt;Linked Frameworks and Libraries&lt;/strong&gt;中添加&lt;strong&gt;libc++.tbd&lt;/strong&gt;，最后将opencv2.framework拖拽到项目中即可(注意由于github文件大小限制，这个库没有直接在code中提供，可以到&lt;a href=&quot;https://github.com/opencv/opencv/releases/download/3.4.4/opencv-3.4.4-ios-framework.zip&quot;&gt;这里&lt;/a&gt;直接下载解压使用)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SmartCrop.framework&lt;/strong&gt;在开发的过程中尽量的简化，通篇只有一个类&lt;strong&gt;SmartCropper&lt;/strong&gt;，此类也只有两个方法并且以ObjC静态方法出现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;+(UIImage *)cropImage:(UIImage *)image size:(CGSize)size;
+(CGRect)cropRectWithImage:(UIImage *)image size:(CGSize)size;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而通常情况下直接调用最上面的一个方法即可满足裁剪需求，那么为什么还要提供第二个API呢？原因是有些情况下并不想裁剪图片而只想找到图片的核心区域，&lt;strong&gt;SmartCrop.framework&lt;/strong&gt;也已经做好了。&lt;/p&gt;
&lt;p&gt;当然Swift中使用也仅仅需要一个bridge header而已，然后调用&lt;strong&gt;SmartCropper.cropImage(image, size:size)&lt;/strong&gt;即完成了所有裁剪操作。&lt;/p&gt;
&lt;p&gt;SmartCrop裁剪效果：&lt;/p&gt;
&lt;p&gt;原图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/62046/201812/62046-20181212153106755-1696924473.jpg&quot; alt=&quot;1sr&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;SmartCrop裁剪后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/62046/201812/62046-20181212153106860-1978569108.jpg&quot; alt=&quot;1dst&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;原图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/62046/201812/62046-20181212153107014-1681823987.jpg&quot; alt=&quot;2sr&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;SmartCrop裁剪后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/62046/201812/62046-20181212153107084-1088377665.jpg&quot; alt=&quot;2dst&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;原图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/62046/201812/62046-20181212153106890-1675425333.jpg&quot; alt=&quot;3sr&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;SmartCrop裁剪后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/62046/201812/62046-20181212153107027-1028332351.jpg&quot; alt=&quot;3dst&quot;/&gt;￼&lt;/p&gt;

&lt;p&gt;Demo界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/62046/201812/62046-20181212153107498-1694437311.jpg&quot; alt=&quot;DemoUI&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;为了验证性能做了一个上面提到的&lt;a href=&quot;https://github.com/kenshincui/SmartCropLib&quot;&gt;demo&lt;/a&gt;，在主界面选择&lt;strong&gt;Photo Library&lt;/strong&gt;可以实时预览相册中的图片智能裁剪后的效果，按住主界面可以对比原图；点击&lt;strong&gt;Browser&lt;/strong&gt;是对于前面提到的10张测试图的实时预览，可以从下面的展示效果看到几乎是实时生成的，没有太多卡顿，上面说的1000px以上的图片，低于0.1s可以完成裁剪应该不会太夸张，当然实际使用中不会每张图都实时显示实时生成，可以提前存储，加上预加载可以做到0卡顿效果。&lt;/p&gt;
&lt;p&gt;运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://v.youku.com/v_show/id_XMzk2MDcyMDgzNg==.html?spm=a2hzp.8244740.0.0&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/62046/201812/62046-20181212155431009-242391051.jpg&quot; alt=&quot;demoVideo&quot;/&gt;￼&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7.5392670157068&quot;&gt;
&lt;p&gt;还要说一下，&lt;strong&gt;SmartCrop.framework&lt;/strong&gt;本身基于OpenCV 3.4.4进行开发，理论上可以向下兼容几个版本，但是太旧的api可能无法使用，为了获得更稳定的效果建议直接使用3.4.4版本。另外文中所有演示图片来源于互联网，仅作为演示学习之用，如存在版权问题请联系本人（&lt;a href=&quot;mailto:kenshincui@hotmail.com&quot;&gt;kenshincui@hotmail.com&lt;/a&gt;），即刻下线。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 12 Dec 2018 07:08:00 +0000</pubDate>
<dc:creator>KenshinCui</dc:creator>
<og:description>￼概述所谓智能裁剪其实就是按照指定尺寸裁剪或显示出包含图片核心特征的区域，目前很多智能裁剪都是在服务器端做的，在客户端需要访问时直接裁剪放到Redis或者提前裁剪好以备访问。但是找了一圈直接在iOS客</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenshincui/p/ios-tu-pian-zhi-neng-cai-jian.html</dc:identifier>
</item>
<item>
<title>Spring Boot实现仿博客园发送通知邮件 - Goat-James</title>
<link>http://www.cnblogs.com/sgh1023/p/10108416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sgh1023/p/10108416.html</guid>
<description>&lt;p&gt;&lt;span&gt;邮件服务已经是基础性服务了 ，是网站的必备功能之一，当注册了某些网站的时候，邮箱里通常会收到一封注册成功通知邮件或者点击激活账号的邮件，博客园也是如此。本文使用Spring Boot，通过QQ邮箱来模仿博客园发送一封通知邮件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;博客园发送的“欢迎您加入博客园”的主题邮件如图所示。这种通知邮件，只有登录用户名在变化，其它邮件内容均不变，很适合用邮件模板来处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538609/201812/1538609-20181212133722681-510791467.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;模板可以实现显示与数据分离，将模板文件和数据通过模板引擎生成最终的HTML代码。&lt;/p&gt;
&lt;p&gt;Thymeleaf是一个适用于Web和独立环境的现代服务器端Java模板引擎，能够处理HTML，XML，JavaScript，CSS甚至纯文本。Thymeleaf由于使用了标签属性做为语法，模版页面直接用浏览器渲染，与其它模板引擎（比如Freemaker）相比，Thymeleaf最大的特点是能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个Web应用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Thymeleaf作为Spring官方推荐的模板引擎，Spring boot对Thymeleaf支持比较友好，配置简单，这里使用Thymeleaf作为模板引擎。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面正式开始实现仿博客园发送通知邮件。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1. pom.xml添加邮件和模板相关依赖&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-mail&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
             &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2. application.property配置邮箱和thymelea模板&lt;/h2&gt;
&lt;p&gt;我使用的是QQ邮箱，需要获得QQ邮箱的授权码。&lt;/p&gt;
&lt;p&gt;关于QQ邮箱生成授权码：进入QQ邮箱 --&amp;gt; 邮箱设置 --&amp;gt; 账户 --&amp;gt;  POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务 --&amp;gt; 生成授权码 --&amp;gt; 手机发送验证短信 --&amp;gt;得到授权码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
spring.mail.host=&lt;span&gt;smtp.qq.com
spring.mail.username&lt;/span&gt;=&lt;span&gt;QQ邮箱
spring.mail.password&lt;/span&gt;=&lt;span&gt;授权码
spring.mail.properties.mail.smtp.auth&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
spring.mail.properties.mail.smtp.starttls.enable&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;  
spring.mail.properties.mail.smtp.starttls.required&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;  

#thymelea模板配置
spring.thymeleaf.prefix&lt;/span&gt;=classpath:/templates/&lt;span&gt;
spring.thymeleaf.suffix&lt;/span&gt;=&lt;span&gt;.html
spring.thymeleaf.mode&lt;/span&gt;=&lt;span&gt;HTML
spring.thymeleaf.encoding&lt;/span&gt;=UTF-8&lt;span&gt;
spring.thymeleaf.servlet.content&lt;/span&gt;-type:text/&lt;span&gt;html
#热部署文件，页面不产生缓存，及时更新
spring.thymeleaf.cache&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
spring.resources.chain.strategy.content.enabled&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
spring.resources.chain.strategy.content.paths&lt;/span&gt;=&lt;span&gt;/**&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3. 编写Service及其实现&lt;/h2&gt;
&lt;p&gt;Service中有两个方法：&lt;/p&gt;
&lt;p&gt;sendSimpleMail用于发送简单的文本邮件，是一个比较基础的案例。&lt;/p&gt;
&lt;p&gt;sendHtmlMail用于发送HTML邮件，发送通知邮件用的就是这个方法。其实模板邮件也就是HTML邮件中的一个子类。&lt;/p&gt;
&lt;p&gt;MailService：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MailService {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendSimpleMail(String to, String subject, String  content);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendHtmlMail(String to, String subject, String  content);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MailServiceImpl：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MailServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MailService {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger =  LoggerFactory.getLogger(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass());

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JavaMailSender mailSender;

    @Value(&lt;/span&gt;&quot;${spring.mail.username}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String from;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendSimpleMail(String to, String subject, String  content) {
        SimpleMailMessage message &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleMailMessage();
        message.setFrom(from);
        message.setTo(to);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邮件接收者&lt;/span&gt;
        message.setSubject(subject);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邮件主题&lt;/span&gt;
        message.setText(content);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邮件内容&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            mailSender.send(message);
            logger.info(&lt;/span&gt;&quot;发送简单邮件成功！&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            logger.error(&lt;/span&gt;&quot;发送简单邮件时发生异常！&quot;&lt;span&gt;, e);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendHtmlMail(String to, String subject, String  content) {
        MimeMessage message &lt;/span&gt;=&lt;span&gt; mailSender.createMimeMessage();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true表示需要创建一个multipart message&lt;/span&gt;
            MimeMessageHelper helper = &lt;span&gt;new&lt;/span&gt;  MimeMessageHelper(message, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            helper.setFrom(from);
            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(content, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            mailSender.send(message);
            logger.info(&lt;/span&gt;&quot;发送HTML邮件成功！&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (MessagingException e) {
            logger.error(&lt;/span&gt;&quot;发送HTML邮件时发生异常！&quot;&lt;span&gt;, e);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4. 创建模板&lt;/h2&gt;
&lt;p&gt;在resorces/templates下创建emailTemplate.html模板，与模板配置中的spring.thymeleaf.prefix=classpath:/templates/对应，不然会找不到模板。&lt;/p&gt;
&lt;p&gt;关于Thymeleaf的使用这里简单介绍一下：&lt;/p&gt;
&lt;p&gt;引入命名空间：&amp;lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;。不同的约束文档中，可能会出现不同含义的相同标记名称，引入名称空间可以避免混淆和冲突。&lt;/p&gt;
&lt;p&gt;访问数据：#｛user.name｝&lt;/p&gt;
&lt;p&gt;访问变量：${today}  &lt;/p&gt;
&lt;p&gt;输出URL： &amp;lt;a href=&quot;#&quot; th:href=&quot;@{https://www.cnblogs.com}&quot;&amp;gt;博客园&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;更多详情的说明和规则请参见：&lt;a href=&quot;https://www.thymeleaf.org/documentation.html&quot; target=&quot;_blank&quot;&gt;Thymeleaf官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;emailTemplate.html：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;zh&quot;&lt;/span&gt;&lt;span&gt; xmlns:th&lt;/span&gt;&lt;span&gt;=&quot;http://www.thymeleaf.org&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;欢迎您加入博客园&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;您好，您在博客园的帐户激活成功，您的登录用户名是：&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span  &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;${username}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;。&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;--&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;博客园(
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;th:href&lt;/span&gt;&lt;span&gt;=&quot;@{https://www.cnblogs.com  }&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;www.cnblogs.com&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            ) - 开发者的网上家园&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;代码改变世界！&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5. JUnit单元测试&lt;/h2&gt;
&lt;p&gt;使用Junit进行单元测试，pom.xml中已经默认配置好了，需要编写测试类和测试方法。测试类以&lt;code&gt;xxxTest.java命名，测试方法上面加&lt;/code&gt;@Test注解就可以使用了。具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
@RunWith(SpringRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@SpringBootTest
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EmailTest {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MailService mailService;

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TemplateEngine templateEngine;

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testSendSimpleMail() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        mailService.sendSimpleMail(&lt;/span&gt;&quot;xxx@qq.com&quot;, &quot;测试发送简单文本邮件&quot;, &quot;测试发送简单文本邮件&quot;&lt;span&gt;);
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSendTemplateMail() {
        Context context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Context();
        context.setVariable(&lt;/span&gt;&quot;username&quot;, &quot;shangguanhao&quot;&lt;span&gt;);
        String emailContent &lt;/span&gt;= templateEngine.process(&quot;emailTemplate&quot;&lt;span&gt;, context);
        mailService.sendHtmlMail(&lt;/span&gt;&quot;xxx@qq.com&quot;, &quot;欢迎您加入博客园&quot;&lt;span&gt;, emailContent);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进行Junit测试，就可以发送一个简答的文本邮件和一个HTML的模板邮件，几乎和博客园的一模一样（如下图所示）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1538609/201812/1538609-20181212134759117-738859529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 12 Dec 2018 07:01:00 +0000</pubDate>
<dc:creator>Goat-James</dc:creator>
<og:description>邮件服务已经是基础性服务了 ，是网站的必备功能之一，当注册了某些网站的时候，邮箱里通常会收到一封注册成功通知邮件或者点击激活账号的邮件，博客园也是如此。本文使用Spring Boot 2，通过QQ邮箱</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sgh1023/p/10108416.html</dc:identifier>
</item>
<item>
<title>(5/24) 模块化：实现快速CSS文件打包 - 吴封斌技术博客</title>
<link>http://www.cnblogs.com/wfaceboss/p/10108057.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wfaceboss/p/10108057.html</guid>
<description>&lt;p&gt;写在前面：为了兼容，此处的webpack版本为3.6.0、webpack-dev-server版本为2.9.7、css-loader版本为2.0.0、style-loader版本为0.23.1，若在下列安装后运行出错，一般是版本问题，可以安装此处的指定版本来解决。&lt;/p&gt;

&lt;p&gt;webpack把多个文件打包到一个js里，可以减少http的请求数。要完成CSS打包之，需要完成对webpack.config.js文件里的Loaders配置项进行针对性的配置。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.1 Loaders&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Loaders是Webpack最重要的功能之一，他也是Webpack如此盛行的原因。通过使用不同的Loader，Webpack可以对不同的文件格式进行特定处理。&lt;/p&gt;
&lt;p&gt;Loaders使用例子：&lt;/p&gt;
&lt;p&gt;（1）分析JSON文件并把它转换为JavaScript文件；&lt;/p&gt;
&lt;p&gt;（2）以把ES6或者ES7的代码，转换成大多浏览器兼容的JS代码；&lt;/p&gt;
&lt;p&gt;（3）对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。&lt;/p&gt;
&lt;p&gt;（4）可以把SASS文件的写法转换成CSS，而不在使用其他转换工具等。&lt;/p&gt;
&lt;p&gt;注意：所有的Loaders都需要在npm中单独进行安装，并在webpack.config.js里进行配置，Loaders的配置项包括有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181212142504807-1677290873.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181212142803045-1379715124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 认识了Loaders相关信息之后，我们开始考虑如何打包CSS文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181212155246809-1135145213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt; 2.1 建立index.css文件&lt;/h2&gt;
&lt;p&gt;要打包css，首先得有个css文件，在/src目录下，我们建立一个css文件夹，在文件夹里建立index.css文件。代码内容如下。&lt;/p&gt;
&lt;p&gt;src/css/index.css：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;body{
    background&lt;/span&gt;-&lt;span&gt;color: #018eea;
    color: red;
    font&lt;/span&gt;-&lt;span&gt;size: 32px;
    text&lt;/span&gt;-&lt;span&gt;align: center;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;css文件建立完成后，将其引入到入口文件中，才能实现打包，此节中我们把它引入到entry.js中，在src目录下的entry.js文件首行加入以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import css from './css/index.css'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当css引入完成后，我们就可以开始使用loader来解析css文件了，此处的解析需要两个loader分别是style-loader和css-loader。&lt;/p&gt;
&lt;h2&gt;2.2 style-loader安装&lt;/h2&gt;
&lt;p&gt; style-loader是用来处理css文件中的url()，&lt;a href=&quot;https://www.npmjs.com/package/style-loader&quot; target=&quot;_blank&quot;&gt;style-loader在npm中网址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;采用npm install进行项目安装（若失败，采用cnpm安装）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install style-loader --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
--save-dev：表示将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。
&lt;/pre&gt;
&lt;h2&gt;2.3 css-loader安装&lt;/h2&gt;
&lt;p&gt;css-loader是用来将css插入到页面的style标签，&lt;a href=&quot;https://www.npmjs.com/package/css-loader&quot; target=&quot;_blank&quot;&gt;css-loader在npm中网址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;采用npm install进行项目安装（若失败，采用cnpm安装），npm install 会默认安装最新的版本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm  install --save-dev css-loader
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;两个loader都下载安装好后，我们就可以在webpack.config.js文件里进行loaders配置工作了。&lt;/p&gt;
&lt;h2&gt;2.4 loaders配置&lt;/h2&gt;
&lt;p&gt;修改webpack.config.js中module属性中的配置代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;module:{
        rules: [
            {
              test: &lt;/span&gt;/\.css$/&lt;span&gt;,
              use: [ &lt;/span&gt;'style-loader', 'css-loader'&lt;span&gt; ]
            }
          ]
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;loader的三种写法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种写法：直接用use。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;module:{
        rules: [
            {
              test: &lt;/span&gt;/\.css$/&lt;span&gt;,
              use: [ &lt;/span&gt;'style-loader', 'css-loader'&lt;span&gt; ]
            }
          ]
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第二种写法：把use换成loader。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;module:{
        rules:[
            {
                test:&lt;/span&gt;/\.css$/&lt;span&gt;,
                loader:[&lt;/span&gt;'style-loader','css-loader'&lt;span&gt;]
            }
        ]
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第三种写法：用use+loader的写法：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;module:{
        rules:[
            {
                test:&lt;/span&gt;/\.css$/&lt;span&gt;,
                use: [
                    {
                        loader: &lt;/span&gt;&quot;style-loader&quot;&lt;span&gt;
                    }, {
                        loader: &lt;/span&gt;&quot;css-loader&quot;&lt;span&gt;
                    }
                ]
            }
        ]
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 2.5 启动服务&lt;/h2&gt;
&lt;p&gt;在终端里输入 &lt;span&gt;&lt;code&gt;npm run server&lt;/code&gt; &lt;/span&gt;打开服务器，访问我们上节配置的本地服务端口（localhost:1818），可以看到效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181212145418965-1548487911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181212145436629-266623346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;附录此时项目目录结构：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181212145546309-2101351099.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Dec 2018 06:58:00 +0000</pubDate>
<dc:creator>吴封斌技术博客</dc:creator>
<og:description>写在前面：为了兼容，此处的webpack版本为3.6.0、webpack-dev-server版本为2.9.7、css-loader版本为2.0.0、style-loader版本为0.23.1，若在下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wfaceboss/p/10108057.html</dc:identifier>
</item>
<item>
<title>递归入门——错排及其应用 - Trirabbits三兔</title>
<link>http://www.cnblogs.com/trirabbits/p/10108373.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/trirabbits/p/10108373.html</guid>
<description>&lt;h2 id=&quot;一常见递归&quot;&gt;一、常见递归&lt;/h2&gt;
&lt;p&gt;​ 简单题：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2018&quot;&gt;&lt;strong&gt;母牛的故事&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2046&quot;&gt;&lt;strong&gt;骨牌铺方格&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2044&quot;&gt;&lt;strong&gt;一只小蜜蜂...&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;​ 中等题：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2045&quot;&gt;&lt;strong&gt;不容易系列之(3)—— LELE的RPG难题&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2047&quot;&gt;&lt;strong&gt;阿牛的EOF牛肉串&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;​ 较难题：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2048&quot;&gt;&lt;strong&gt;神、上帝以及老天爷&lt;/strong&gt;&lt;/a&gt;、&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2049&quot;&gt;&lt;strong&gt;不容易系列之(4)——考新郎&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;​ 变态题：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2050&quot;&gt;&lt;strong&gt;折线分割平面&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;​ 简单题，显而易见的规律；中等题，略加思考推出来的规律；较难题，深度思考（其实是我高中数学弱，不会错排😢😢😢）；变态题，我想不出来，看题解也没看懂的题。&lt;/p&gt;
&lt;h2 id=&quot;二递推公式斐波那契型&quot;&gt;二、递推公式：斐波那契型&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ F(n) = F(n-1) + F(n-2) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ 上述题目除了&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2050&quot;&gt;&lt;strong&gt;折线分割平面&lt;/strong&gt;&lt;/a&gt;之外，都是这个公式的变形。&lt;/p&gt;
&lt;p&gt;较难题需要用到错排，今天细讲错排。&lt;/p&gt;
&lt;h2 id=&quot;三错排公式的推导和应用&quot;&gt;三、错排公式的推导和应用&lt;/h2&gt;
&lt;p&gt;错排的定义：一段序列中一共有n个元素，那么可知这些元素一共有n!种排列方法。假如在进行排列时，原来所有的元素都不在原来的位置，那么称这个排列为错排。而错排数所指的就是在一段有n个元素的序列中，有多少种排列方式是错排。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ 递归关系：D(n)=(n-1)(D(n-1)+D(n-2)) 特别地有D(1)=0,D(2)=1； \\错排公式：D(n)=(n!)[(-1)^0/0!+(-1)^1/(1!)+(-1)^2/(2!) +(-1)^3/(3!)+......+(-1)^n/(n!)]； \\其中n!=n*(n-1)*(n-2)*......3*2*1 特别地有0!=1\quad 1!=1 \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;递推思想&quot;&gt;&lt;strong&gt;递推思想：&lt;/strong&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;​ &lt;strong&gt;一共分为两步&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;第一步&quot;&gt;第一步：&lt;/h5&gt;
&lt;p&gt;​ 错排（不能选择自己本来就在的位置）第一个元素，在n个位置中任选一个位置，有 n-1 种选法。&lt;/p&gt;
&lt;h5 id=&quot;第二步&quot;&gt;第二步：&lt;/h5&gt;
&lt;p&gt;​ 错排其余n-1个元素，也是需要分情况和种类的。因为这需要看第一步的结果，如果第一个元素落在第k个位置上，第二步就需要把k号元素进行错排，k号元素错排位置的不同将导致不同的情况会发生：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;①&lt;/strong&gt;.假设k号元素正好落在了第一个元素的位置，那么就可以将第一个元素和第k个元素完全剔除出去，因为相当于只是他们两者互换了位置，其他元素暂时还没有发生变动。留下来的n-2元素进行错排的话，那么我们就可以得到了D(n-2)种 的错排方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;②&lt;/strong&gt;.若k号元素不排到第一个元素的位置，我们可以暂时将现在排在k号位置的第一个元素剔除出去，生下来的就只包含k号元素和原来n-2个的元素了。这时，我们可以将原来的第一个元素的位置看做是现在k号元素的原本位置，因为k号元素不能够放在原来的位置上，所以就相当于是原来的n-2个元素和k共计n-1个元素进行完全的错排。那么一共就有D(n-1)种方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综上所述&lt;/strong&gt;:第二步得到D(n-1)+D(n-2)种方法，第一步是n-1种，由于是分步进行，所以结果为(n-1)*[D(n-1)+D(n-2)]种方法。&lt;/p&gt;
&lt;h2 id=&quot;四实战&quot;&gt;四、实战&lt;/h2&gt;
&lt;h3 id=&quot;神上帝以及老天爷&quot;&gt;①&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2048&quot;&gt;&lt;strong&gt;神、上帝以及老天爷&lt;/strong&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;​ 典型的错排题目&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2048&quot;&gt;&lt;strong&gt;神、上帝以及老天爷&lt;/strong&gt;&lt;/a&gt;，这道题的题意就是求所有的组合情况中错排所占的比例，题目要求的就是这个。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{（n-1)*[D(n-1)+D(n-2)]}{N!} \]&lt;/span&gt;&lt;br/&gt;下面就是AC代码了：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using namespace std;

int main()
{
    int t;
    int s;
    double a[20+5] = {0,0,1};   //错排的数组
    double b[20+5] = {2,2,2};   //全排的数组
    int i = 3;

    cin &amp;gt;&amp;gt; t;
    while(t--)
    {
        cin &amp;gt;&amp;gt; s;
        for( ; i &amp;lt;= s; i++)
        {
            a[i] = (i-1)*(a[i-1]+a[i-2]);   //错排
            b[i] = b[i-1]*i;                //全排
        }
        cout &amp;lt;&amp;lt; fixed &amp;lt;&amp;lt; setprecision(2) &amp;lt;&amp;lt; a[s]/b[s]*100 &amp;lt;&amp;lt; &quot;%&quot; &amp;lt;&amp;lt; endl;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;不容易系列之4考新郎&quot;&gt;②&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=2049&quot;&gt;&lt;strong&gt;不容易系列之(4)——考新郎&lt;/strong&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;​ 这道题的题意为在n对新人里面挑出m对新人来错排，那么实际让我们求得就是挑出m对新人的方法乘以m对新人的错排方法。就是下面这个公式。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ C_n ^m*(n-1)*[D(n-1)+D(n-2)] \]&lt;/span&gt;&lt;br/&gt;下面是AC代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

typedef long long ll;

using namespace std;

ll factorial(int n, int m)  //求组合数
{
    ll ans = 1;
    if(m &amp;lt; n-m)
        m = n-m;
    for(int i = m+1; i &amp;lt;= n; i++)
        ans *= i;
    for(int j = 1; j &amp;lt;= n - m; j++)
        ans /= j;
    return ans;
}

int main()
{
    int t;
    int n, m;
    ll a[20+5] = {0,0,1};
    int i = 3;
    int temp;

    cin &amp;gt;&amp;gt; t;
    while(t--)
    {
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
        if( n &amp;lt; m)
        {
            temp = n;
            n = m;
            m = temp;
        }
        for( ; i &amp;lt;= m; i++)     //错排
            a[i] = (i-1)*(a[i-1]+a[i-2]);
        cout &amp;lt;&amp;lt; factorial(n,m)*a[m] &amp;lt;&amp;lt; endl;//输出错排*组合数
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;求组合数代码（用阶乘不到20就超出long long的范围了）：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef long long ll;
ll factorial(int n, int m)  //求组合数
{
    ll ans = 1;
    if(m &amp;lt; n-m)
        m = n-m;
    for(int i = m+1; i &amp;lt;= n; i++)
        ans *= i;
    for(int j = 1; j &amp;lt;= n - m; j++)
        ans /= j;
    return ans;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 12 Dec 2018 06:56:00 +0000</pubDate>
<dc:creator>Trirabbits三兔</dc:creator>
<og:description>一、常见递归 ​ 简单题：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/trirabbits/p/10108373.html</dc:identifier>
</item>
<item>
<title>flutter 环境搭建 - shidaying</title>
<link>http://www.cnblogs.com/shidaying/p/10108184.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shidaying/p/10108184.html</guid>
<description>&lt;h2 id=&quot;安装flutter&quot;&gt;1.安装flutter&lt;/h2&gt;
&lt;h3 id=&quot;下载flutter-包&quot;&gt;1.1 下载flutter 包&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cd Documents
git clone  https://github.com/flutter/flutter.git
unzip ~/Documents/flutter_macos_v1.0.0-stable&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置全局环境变量&quot;&gt;1.2 设置全局环境变量&lt;/h3&gt;
&lt;p&gt;更改配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vi ~/.bash_profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上述文件末尾追加如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export PUB_HOSTED_URL=https://pub.flutter-io.cn
export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn
export PATH=~/Documents/flutter/bin:$PATH&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生效&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source ~/.bash_profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整的 .bash_profile 配置，包括安卓环境变量配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home  
export PATH=$JAVA_HOME/bin:$PATH
export CLASS_PATH=$JAVA_HOME/lib:$CLASS_PATH 
export ANDROID_HOME=~/Library/Android/sdk
export PATH=${PATH}:${ANDROID_HOME}/tools  
export PATH=${PATH}:${ANDROID_HOME}/platform-tools

export PUB_HOSTED_URL=https://pub.flutter-io.cn
export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn
export PATH=~/Documents/flutter/bin:$PATH&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;验证是否安装成功&quot;&gt;1.3验证是否安装成功&lt;/h3&gt;
&lt;p&gt;以下命令不报错，就成功了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flutter&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装插件&quot;&gt;2 安装插件&lt;/h2&gt;
&lt;p&gt;检查插件安装情况&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flutter doctor&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果可能如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/611735/201812/611735-20181212144759030-1866743970.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;缺少什么按照提示，跑一下上面提示的命令即可，有的时间可能较长&lt;/p&gt;
&lt;h2 id=&quot;android插件&quot;&gt;2.1 Android插件&lt;/h2&gt;
&lt;p&gt;安装android licences&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flutter doctor --android-licenses&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ios-插件&quot;&gt;2.2 iOS 插件&lt;/h2&gt;
&lt;p&gt;安装 libimobiledevice and ideviceinstaller&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;brew update
brew install --HEAD usbmuxd
brew link usbmuxd
brew install --HEAD libimobiledevice
brew install ideviceinstaller&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装 ios-deploy&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;brew install ios-deploy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;升级cocoapods&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;brew upgrade cocoapods
pod setup&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 12 Dec 2018 06:31:00 +0000</pubDate>
<dc:creator>shidaying</dc:creator>
<og:description>1.安装flutter 1.1 下载flutter 包 1.2 设置全局环境变量 更改配置文件 在上述文件末尾追加如下： 生效 完整的 .bash_profile 配置，包括安卓环境变量配置 1.3验</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shidaying/p/10108184.html</dc:identifier>
</item>
<item>
<title>Java语言快速实现简单MQ消息队列服务 - jimisun</title>
<link>http://www.cnblogs.com/jimisun/p/10108067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimisun/p/10108067.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;mq基础回顾&quot;&gt;MQ基础回顾&lt;/h2&gt;
&lt;p&gt;在上一篇&lt;a href=&quot;https://www.cnblogs.com/jimisun/p/10102425.html&quot;&gt;消息通讯之关于消息队列MQ必须了解的相关概念&lt;/a&gt;中 , 我们尽可能地详细的了解了一些关于&lt;code&gt;MQ (消息队列)&lt;/code&gt; 的相关概念,并且我们上一篇中提到一个最基本的&lt;code&gt;MQ通讯模型&lt;/code&gt;如下所示,所以本章节使用&lt;code&gt;JAVA&lt;/code&gt;语言自己动手来写一个MQ (类似ActiveMQ,RabbitMQ)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201812/1218060-20181211152325940-1104249917.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;主要角色&quot;&gt;主要角色&lt;/h2&gt;
&lt;p&gt;首先我们必须需要搞明白&lt;code&gt;MQ (消息队列)&lt;/code&gt; 中的三个基本角色&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Producer&lt;/code&gt; : 消息生产者,负责生产消息并发送到Broker&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Broker&lt;/code&gt; : 消息处理中心,负责接受消息,存储消息,转发消息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Consumer&lt;/code&gt; :消息消费者,负责消费消息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;整体架构如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218060/201812/1218060-20181212141958404-1530830689.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;自定义协议&quot;&gt;自定义协议&lt;/h2&gt;
&lt;p&gt;首先从上一篇中介绍了协议的相关信息,具体厂商的&lt;code&gt;MQ(消息队列)&lt;/code&gt;需要遵循某种协议或者自定义协议 , 消息的&lt;code&gt;生产者和消费者需要遵循其协议(约定)才能后成功地生产消息和生产消息&lt;/code&gt;,所以在这里我们自定义一个协议如下．&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;消息处理中心 : 如果接收到的信息包含&quot;SEND&quot;字符串,即视为生产者发送的消息,消息处理中心需要将此信息存储等待消费者消费&lt;/p&gt;
&lt;p&gt;消息处理中心 : 如果接受到的信息为CONSUME，既视为消费者发送消费请求，需要将存储的消息队列头部的信息转发给消费者，然后将此消息从队列中移除&lt;/p&gt;
&lt;p&gt;消息处理中心 : 如果消息处理中心存储的消息满3条仍然没有消费者进行消费,则不再接受生产者的生产请求&lt;/p&gt;
&lt;p&gt;消息生产者：需要遵循协议将生产的消息头部增加　＂SEND:＂ 表示生产消息&lt;/p&gt;
&lt;p&gt;消息消费者：需要遵循协议向消息处理中心发送　＂CONSUME＂字符串表示消费消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;流程顺序&quot;&gt;流程顺序&lt;/h2&gt;
&lt;h3 id=&quot;项目构建流程&quot;&gt;项目构建流程&lt;/h3&gt;
&lt;p&gt;下面将整个ＭＱ的构建流程过一遍&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建一个&lt;code&gt;Broker&lt;/code&gt;类，内部维护一个&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;队列，提供生产消息和消费消息的方法，&lt;code&gt;仅仅具备存储服务功能&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新建一个&lt;code&gt;BrokerServer&lt;/code&gt;类,将&lt;code&gt;Broker&lt;/code&gt;发布为服务到本地9999端口，监听本地9999端口的&lt;code&gt;Socket&lt;/code&gt;链接，在接受的信息中进行我们的协议校验, 这里&lt;code&gt;仅仅具备接受消息,校验协议,转发消息功能;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新建一个&lt;code&gt;MqClient&lt;/code&gt;类,此类提供与本地端口9999的Socket链接 , &lt;code&gt;仅仅具备生产消息和消费消息的方法&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;测试：新建两个&lt;code&gt;MyClient&lt;/code&gt;类对象，分别执行其生产方法和消费方法&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;具体使用流程&quot;&gt;具体使用流程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;生产消息：客户端执行生产消息方法，传入需要生产的信息，该信息需要遵循我们自定义的协议，消息处理中心服务在接受到消息会根据自定义的协议校验该消息是否合法，如果合法如果合法就会将该消息存储到Broker内部维护的&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;队列中．如果&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;队列没有达到我们协议中的最大长度将将消息添加到队列中，否则输出生产消息失败．&lt;/li&gt;
&lt;li&gt;消息消息：客户端执行消费消息方法，&lt;code&gt;Broker服务&lt;/code&gt;会校验请求的信息的信息是否等于&lt;code&gt;CONSUME&lt;/code&gt;，如果验证成功则从Broker内部维护的&lt;code&gt;ArrayBlockingQueue&lt;/code&gt;队列的&lt;code&gt;Poll&lt;/code&gt;出一个消息返回给客户端&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;代码演示&quot;&gt;代码演示&lt;/h2&gt;
&lt;h3 id=&quot;消息处理中心-broker&quot;&gt;消息处理中心 Broker&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 消息处理中心
 */
public class Broker {
    // 队列存储消息的最大数量
    private final static int MAX_SIZE = 3;

    // 保存消息数据的容器
    private static ArrayBlockingQueue&amp;lt;String&amp;gt; messageQueue = new ArrayBlockingQueue&amp;lt;String&amp;gt;(MAX_SIZE);

    // 生产消息
    public static void produce(String msg) {
        if (messageQueue.offer(msg)) {
            System.out.println(&quot;成功向消息处理中心投递消息：&quot; + msg + &quot;，当前暂存的消息数量是：&quot; + messageQueue.size());
        } else {
            System.out.println(&quot;消息处理中心内暂存的消息达到最大负荷，不能继续放入消息！&quot;);
        }
        System.out.println(&quot;=======================&quot;);
    }

    // 消费消息
    public static String consume() {
        String msg = messageQueue.poll();
        if (msg != null) {
            // 消费条件满足情况，从消息容器中取出一条消息
            System.out.println(&quot;已经消费消息：&quot; + msg + &quot;，当前暂存的消息数量是：&quot; + messageQueue.size());
        } else {
            System.out.println(&quot;消息处理中心内没有消息可供消费！&quot;);
        }
        System.out.println(&quot;=======================&quot;);

        return msg;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;消息处理中心服务-brokerserver&quot;&gt;消息处理中心服务 BrokerServer&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 用于启动消息处理中心
 */
public class BrokerServer implements Runnable {

    public static int SERVICE_PORT = 9999;

    private final Socket socket;

    public BrokerServer(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try (
                BufferedReader in = new BufferedReader(new InputStreamReader(
                        socket.getInputStream()));
                PrintWriter out = new PrintWriter(socket.getOutputStream())
        )
        {
            while (true) {
                String str = in.readLine();
                if (str == null) {
                    continue;
                }
                System.out.println(&quot;接收到原始数据：&quot; + str);

                if (str.equals(&quot;CONSUME&quot;)) { //CONSUME 表示要消费一条消息
                    //从消息队列中消费一条消息
                    String message = Broker.consume();
                    out.println(message);
                    out.flush();
                } else if (str.contains(&quot;SEND:&quot;)){
                    //接受到的请求包含SEND:字符串 表示生产消息放到消息队列中
                    Broker.produce(str);
                }else {
                    System.out.println(&quot;原始数据:&quot;+str+&quot;没有遵循协议,不提供相关服务&quot;);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception {
        ServerSocket server = new ServerSocket(SERVICE_PORT);
        while (true) {
            BrokerServer brokerServer = new BrokerServer(server.accept());
            new Thread(brokerServer).start();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;客户端-mqclient&quot;&gt;客户端 MqClient&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 访问消息队列的客户端
 */
public class MqClient {

    //生产消息
    public static void produce(String message) throws Exception {
        //本地的的BrokerServer.SERVICE_PORT 创建SOCKET
        Socket socket = new Socket(InetAddress.getLocalHost(), BrokerServer.SERVICE_PORT);
        try (
                PrintWriter out = new PrintWriter(socket.getOutputStream())
        ) {
            out.println(message);
            out.flush();
        }
    }

    //消费消息
    public static String consume() throws Exception {
        Socket socket = new Socket(InetAddress.getLocalHost(), BrokerServer.SERVICE_PORT);
        try (
                BufferedReader in = new BufferedReader(new InputStreamReader(
                        socket.getInputStream()));
                PrintWriter out = new PrintWriter(socket.getOutputStream())
        ) {
            //先向消息队列发送命令
            out.println(&quot;CONSUME&quot;);
            out.flush();

            //再从消息队列获取一条消息
            String message = in.readLine();

            return message;
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试mq&quot;&gt;测试MQ&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ProduceClient {

    public static void main(String[] args) throws Exception {
        MqClient client = new MqClient();

        client.produce(&quot;SEND:Hello World&quot;);
    }

}

public class ConsumeClient {

    public static void main(String[] args) throws Exception {
        MqClient client = new MqClient();
        String message = client.consume();

        System.out.println(&quot;获取的消息为：&quot; + message);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们多执行几次客户端的生产方法和消费方法就可以看到一个完整的MQ的通讯过程,下面是我执行了几次的一些日志&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;接收到原始数据：SEND:Hello World
成功向消息处理中心投递消息：SEND:Hello World，当前暂存的消息数量是：1
=======================
接收到原始数据：SEND:Hello World
成功向消息处理中心投递消息：SEND:Hello World，当前暂存的消息数量是：2
=======================
接收到原始数据：SEND:Hello World
成功向消息处理中心投递消息：SEND:Hello World，当前暂存的消息数量是：3
=======================
接收到原始数据：SEND:Hello World
消息处理中心内暂存的消息达到最大负荷，不能继续放入消息！
=======================
接收到原始数据：Hello World
原始数据:Hello World没有遵循协议,不提供相关服务

接收到原始数据：CONSUME
已经消费消息：SEND:Hello World，当前暂存的消息数量是：2
=======================
接收到原始数据：CONSUME
已经消费消息：SEND:Hello World，当前暂存的消息数量是：1
=======================
接收到原始数据：CONSUME
已经消费消息：SEND:Hello World，当前暂存的消息数量是：0
=======================
接收到原始数据：CONSUME
消息处理中心内没有消息可供消费！
=======================&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本章示例代码主要源自分布式消息中间件实践一书 , 这里我们自己使用Java语言写了一个MQ消息队列 , 通过这个消息队列我们对MQ中的几个角色 &lt;code&gt;&quot;生产者,消费者,消费处理中心,协议&quot;&lt;/code&gt;有了更深的理解 ; 那么下一章节我们就来一块学习具体厂商的MQ &lt;code&gt;RabbitMQ&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Dec 2018 06:21:00 +0000</pubDate>
<dc:creator>jimisun</dc:creator>
<og:description>[TOC] MQ基础回顾 在上一篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jimisun/p/10108067.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core 轻松学-被低估的过滤器 - Ron.liang</title>
<link>http://www.cnblogs.com/viter/p/10107886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viter/p/10107886.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;    过滤器，从我们开始开发 Asp.Net 应用程序开始，就一直伴随在我们左右；Asp.Net Core 提供多种类型的过滤器，以满足多种多样的业务应用场景；并且在 Asp.Net Core 本身，过滤器的应用也非常广泛；但是，在实际的业务场景中，大部分开发人员只使用到其中 1 到 2 种类型，当然，这其中大部分可能性是由于业务场景的适用性使然，本文尝试简单介绍 Asp.Net Core 中提供的各种过滤器，以及实际的应用场景，希望对您有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;1. 介绍&lt;/h2&gt;
&lt;h5 id=&quot;作用范围&quot;&gt;1.1 作用范围&lt;/h5&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;过滤器的作用范围&lt;br/&gt;每种不同的过滤器都有实际的作用范围，有一些全局过滤器还有作用域的限制，这取决于应用开发者在定义和初始化过滤器的时候的选择，每个过滤器本身处理任务的权限和功能都大不相同，但是他们都有一个共同点，就是通过特性标记的方式使用，比如以下代码，对一个 Action 使用了过滤器 CustomerActionFilter&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;        [CustomerActionFilter]
        public ActionResult&amp;lt;string&amp;gt; Get(int id)
        {
            return &quot;value&quot;;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;过滤器的工作原理&quot;&gt;1.2 过滤器的工作原理&lt;/h5&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;原理解释&lt;br/&gt;过滤器一般在 Asp.Net Core MVC 管道内运行，一般在操作执行之前（befor） 或者执行之后（after） 执行，以供开发者可以选择在不同的执行阶段介入处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;过滤器类型看下图&quot;&gt;1.3 过滤器类型，看下图&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201812/26882-20181212134217931-1470231037.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;类型介绍&lt;br/&gt;上图既是 Asp.Net Core 内置的各种过滤器类型，也是其执行优先级顺序，相同类型的过滤器还可以定义在某个阶段执行的顺序&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;授权过滤器 AuthorizeAttribute&lt;/li&gt;
&lt;li&gt;资源过滤器 IResourceFilter&lt;/li&gt;
&lt;li&gt;异常过滤器 IExceptionFilter&lt;/li&gt;
&lt;li&gt;操作过滤器 ActionFilterAttribute&lt;/li&gt;
&lt;li&gt;结果过滤器 IResultFilter&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;授权过滤器&quot;&gt;3. 授权过滤器&lt;/h2&gt;
&lt;p&gt;3.1 使用介绍&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在请求到达的时候最先执行，优先级最高，主要作用是提供用户请求权限过滤，对不满足权限的用户，可以在过滤器内执行拒绝操作，俗称“管道短路”&lt;br/&gt;*注意：该过滤器只有执行之前（befor），没有执行之后（after）的方法&lt;br/&gt;通常情况下，不需要自行编写过滤器，因为该过滤器在 Asp.Net Core 内部已经有了默认实现，我们需要做的就是配置授权策略或者实现自己的授权策略，然后由系统内置的授权过滤器调用授权策略即可&lt;br/&gt;必须将该过滤器内部可能出现的异常全部处理，因为在授权过滤器之前，没有任何组件能够捕获授权过滤器的异常，一旦授权管理器内部发生异常，该异常将直接输出到结果中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3.2 应用场景&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;授权管理器 AuthorizeAttribute 位于 命名空间 Microsoft.AspNetCore.Authorization 内，使用方式非常简单，查看以下代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    [Authorize]
    [Route(&quot;api/[controller]&quot;)]
    public class UserController : Controller
    {
        [AllowAnonymous]
        [HttpGet]
        public ActionResult&amp;lt;string&amp;gt; Get()
        {
            return &quot;default&quot;;
        }

        [HttpPost]
        public ActionResult&amp;lt;string&amp;gt; Post()
        {
            return &quot;default&quot;;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;UserController 被应用了 Authorize 特性进行标记，表示对该控制器内的任意操作执行授权验证；但是单独对 Get 操作进行了授权通过对标记，即 AllowAnonymous ，表示允许匿名访问&lt;br/&gt;这是非常常用的做法，在授权应用中，常常需要对部分操作进行单独的授权策略&lt;br/&gt;关于授权过滤器，先介绍到这里，下一篇单独对授权过滤器进行演示，因为关于这块的内容，要讲的实在是太多了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;资源过滤器&quot;&gt;4. 资源过滤器&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;但请求进入，通过授权过滤器后，接下来将执行资源过滤器（如果有定义），使用资源过滤器甚至可以改变绑定模型，还可以在资源过滤器中实现缓存以提高性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4.1 资源管理器实现自接口 IResourceFilter 或者 IAsyncResourceFilter，现在我们来实现一个资源过滤器，输出一行信息，看看执行顺序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class CustomerResourceFilter : Attribute, IResourceFilter
    {
        public void OnResourceExecuted(ResourceExecutedContext context)
        {
            Console.WriteLine(&quot;==== OnResourceExecuted&quot;);
        }

        public void OnResourceExecuting(ResourceExecutingContext context)
        {
            Console.WriteLine(&quot;==== OnResourceExecuting&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.2 对 HomeController 的操作应用该资源过滤器，看看对一个操作同时应用 CustomerActionFilter 和 CustomerResourceFilter ，他们的执行顺序是什么&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    public class HomeController : ControllerBase
    {
        [HttpGet]
        [CustomerActionFilter]
        [CustomerResourceFilter]
        public async Task&amp;lt;ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt;&amp;gt; Get()
        {
            return new string[] { &quot;value1&quot;, &quot;value2&quot; };
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.3 启动程序，访问 &lt;a href=&quot;http://localhost:5000/api/home%EF%BC%8C%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B&quot; class=&quot;uri&quot;&gt;http://localhost:5000/api/home，输出结果如下&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201812/26882-20181212134230041-505330882.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;可以看到，执行顺序和开篇的第一张图例一直，首先执行时资源过滤器的 OnResourceExecuting 方法，接着请求接入了 操作过滤器的 OnActionExecuting 方法，最后执行操作过滤器的 OnResultExecuting 方法，然后把请求交给资源过滤器的 OnResourceExecuted，最后返回到客户端&lt;br/&gt;所以，从执行顺序可以看出，资源管理器的执行优先级总是高于操作过滤器&lt;br/&gt;资源过滤器可以应用于控制器或者操作，然后基于其执行优先级的特点，开发员人员可以在资源过滤器中定义某些静态资源或者缓存直接将数据返回给客户端，并使其执行短路操作，减少后续管道请求步骤，以提高服务器响应性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;异常过滤器&quot;&gt;5. 异常过滤器&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在服务器向客户端写入响应内容之前，如果系统引发了异常，异常过滤器可以捕获该异常，该过滤器作用于全局范围，这也是最常用的过滤器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5.1 创建一个异常过滤器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class CustomerExceptionFilter : Attribute, IExceptionFilter
    {
        public void OnException(ExceptionContext context)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine(&quot;发生了异常：{0}&quot;, context.Exception.Message);
            Console.ForegroundColor = ConsoleColor.Gray;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.2 将 CustomerExceptionFilter 应用到 HomeController 上&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;请注意，HomeController 上还同时应用了资源过滤器；现在要做到就是在资源过滤器内部抛出异常，看看 CustomerExceptionFilter 是否可以捕获该异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class CustomerResourceFilter : Attribute, IResourceFilter
    {
        public void OnResourceExecuted(ResourceExecutedContext context)
        {
            Console.WriteLine(&quot;==== OnResourceExecuted&quot;);
        }

        public void OnResourceExecuting(ResourceExecutingContext context)
        {
            Console.WriteLine(&quot;==== OnResourceExecuting&quot;);
            throw new Exception(&quot;资源管理器发生了异常&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.3 运行程序，访问 &lt;a href=&quot;http://localhost:5000/api/home&quot; class=&quot;uri&quot;&gt;http://localhost:5000/api/home&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201812/26882-20181212134237231-2073343477.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;可以看到，系统抛出了异常；但是，异常过滤器 CustomerExceptionFilter 并没有捕获该异常，事实证明资源过滤器的执行优先级还是高于异常过滤器，现在我们尝试在操作内部引发异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    [Route(&quot;api/[controller]&quot;)]
    [ApiController]
    [CustomerResourceFilter]
    [CustomerExceptionFilter]
    public class HomeController : ControllerBase
    {
        // GET api/values
        [HttpGet]
        [CustomerActionFilter]
        public async Task&amp;lt;ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt;&amp;gt; Get()
        {
            throw new Exception(&quot;Get操作发生了异常&quot;);
            return new string[] { &quot;value1&quot;, &quot;value2&quot; };
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.4 再次启动程序，访问 &lt;a href=&quot;http://localhost:5000/api/home%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B&quot; class=&quot;uri&quot;&gt;http://localhost:5000/api/home，控制台输出结果如下&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201812/26882-20181212134243465-480919316.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.5 客户端得到了一个友好的返回值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201812/26882-20181212134254854-1081715607.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.6 这是因为我们在异常过滤器内部将异常进行了出来，并通过设置 context.ExceptionHandled = true 来标记表示异常已经被处理，然后输出友好信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class CustomerExceptionFilter : Attribute, IExceptionFilter
    {
        public void OnException(ExceptionContext context)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine(&quot;发生了异常：{0}&quot;, context.Exception.Message);
            Console.ForegroundColor = ConsoleColor.Gray;

            context.Result = new JsonResult(new { code = 500, message = context.Exception.Message });
            context.ExceptionHandled = true;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;异常过滤器的应用非常简单，你可以在其内部将异常写入日志，或者执行其它需要处理的逻辑&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;操作过滤器-actionfilterattribute-和-结果过滤器-iresultfilter&quot;&gt;6. 操作过滤器 ActionFilterAttribute 和 结果过滤器 IResultFilter&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;操作过滤器：当请求进入 API 接口的时候，操作过滤器提供了一个进入之前（before）和进入之后（after）介入功能，可以使用该过滤器对进入 API 的参数和结果进行干预&lt;/li&gt;
&lt;li&gt;结果过滤器：这个过滤器的作用和操作过滤器非常相似，主要其作用范围是有微小区别的，结果过滤器是在操作即将返回结果到客户端之前（before）或者之后（after）执行干预，比如你可以在返回结果之后（after）去渲染视图&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;6.1 之所以将这两个过滤器放在一起讲，是因为，这两个过滤器就像一对孪生兄弟一样，正所谓有始有终，首先来看操作过滤器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
    public abstract class ActionFilterAttribute : Attribute, IActionFilter, IFilterMetadata, IAsyncActionFilter, IResultFilter, IAsyncResultFilter, IOrderedFilter
    {
        protected ActionFilterAttribute();

        //
        public int Order { get; set; }

        //
        public virtual void OnActionExecuted(ActionExecutedContext context);
        //
        public virtual void OnActionExecuting(ActionExecutingContext context);
        //
        [AsyncStateMachine(typeof(&amp;lt;OnActionExecutionAsync&amp;gt;d__6))]
        public virtual Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next);
        //
        public virtual void OnResultExecuted(ResultExecutedContext context);
        //
        public virtual void OnResultExecuting(ResultExecutingContext context);
        //
        [AsyncStateMachine(typeof(&amp;lt;OnResultExecutionAsync&amp;gt;d__9))]
        public virtual Task OnResultExecutionAsync(ResultExecutingContext context, ResultExecutionDelegate next);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;操作过滤器包含 6 个基础方法，分别是执行前（before）执行后（after），写入结果前（before）写入后（after）&lt;br/&gt;为什么会这样呢，因为操作过滤器实现的接口中包含了结果过滤器的接口&lt;br/&gt;根据官方的提示，如果你需要重写 ActionFilterAttribute 的方法以处理自定义的业务逻辑，那么 OnActionExecutionAsync 这个异步方法不应该和 执行前（before）执行后（after）同时共存&lt;br/&gt;同样，写入结果前（before）写入后（after）和 OnResultExecutionAsync 也是一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;6.2 操作过滤器包含了 写入结果前（before）写入后（after）的方法，这使得我们可以不用去定义结果过滤器就可以实现对写入结果的管理&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当然，最好的做法是定义结果过滤器，这有助于业务分类，且逻辑清晰明了，但是如果你希望可以使用异步操作，很遗憾，结果过滤器不支持该方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;6.3 下面来看结果过滤的定义&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class CustomerResultFilter : Attribute, IResultFilter
    {
        public void OnResultExecuted(ResultExecutedContext context)
        {
            Console.WriteLine(&quot;OnResultExecuted&quot;);
        }

        public void OnResultExecuting(ResultExecutingContext context)
        {
            Console.WriteLine(&quot;OnResultExecuting&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;代码非常简单，就是实现接口 IResultFilter&lt;br/&gt;IResultFilter 的工作原理和操作过滤器的写入结果前（before）写入后（after）的方法执行一致，可以看到，他们两个方法和参数名称都是一致的，因为他们都是实现同一个接口 IResultFilter&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;6.4 利用结果过滤器实现对输出结果的干预&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;下面就简单在结果过滤器内部去对已经组织好的数据进行干预，HomeController.Get 方法本应该输出 一个数组，我们在Header 中增加一项输出：Author=From Ron.liang&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class CustomerResultFilter : Attribute, IResultFilter
    {
        public void OnResultExecuted(ResultExecutedContext context)
        {
            // ToDo
        }

        public void OnResultExecuting(ResultExecutingContext context)
        {
            // 干预结果
            context.HttpContext.Response.Headers.Add(&quot;Author&quot;, &quot;From Ron.liang&quot;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6.5 输出结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201812/26882-20181212134303936-1548167166.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在过滤器中使用依赖注入&quot;&gt;7.在过滤器中使用依赖注入&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在上面介绍的各种各样的过滤器中，有时候我们可能需要读取程序运行环境的信息，根据不同的环境做出不同的响应内容&lt;br/&gt;比如，上面的结果过滤器写入作者信息，可能我们只希望在开发环境输出，而在产品环境忽略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;7.1 使用 GetService，以支持依赖注入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        public void OnResultExecuting(ResultExecutingContext context)
        {
            var env = (IHostingEnvironment)context.HttpContext.RequestServices.GetService(typeof(IHostingEnvironment));

            Console.ForegroundColor = ConsoleColor.Blue;
            Console.WriteLine(&quot;OnResultExecuting,{0}&quot;, env.EnvironmentName);
            Console.ForegroundColor = ConsoleColor.Gray;

            // 干预结果
            if (env.IsDevelopment())
                context.HttpContext.Response.Headers.Add(&quot;Author&quot;, &quot;From Ron.liang&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上面的从 context.HttpContext.RequestServices.GetService(typeof(IHostingEnvironment)) 获取了环境变量，并判断在开发环境下为响应头添加内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;7.2 在过滤器中使用中间件&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Asp.Net Core 提供了一个功能，使得我们在过滤器中可以使用中间件，实际上，这两者的使用方式非常类似&lt;br/&gt;如果你希望这么做，可以定义一个包含 Configure(IApplicationBuilder applicationBuilder) 方法的类，在控制器或者操作中使用它&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;7.3 定义注册管理管道类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class RegisterManagerPipeline
    {
        public void Configure(IApplicationBuilder applicationBuilder)
        {
            CookieAuthenticationOptions options = new CookieAuthenticationOptions();

            applicationBuilder.UseCors(config =&amp;gt;
            {
                config.AllowAnyOrigin();
            });
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;RegisterManagerPipeline 定义了一个 Configure 方法，在该方法内部执行一个跨域设置，表示允许任何来源访问该站点；然后，我们在 UserController 中应用该管道&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    [Authorize]
    [Route(&quot;api/[controller]&quot;)]
    [MiddlewareFilter(typeof(RegisterManagerPipeline))]
    public class UserController : Controller
    {
        // GET: api/&amp;lt;controller&amp;gt;
        [AllowAnonymous]
        [HttpGet]
        public ActionResult&amp;lt;string&amp;gt; Get()
        {
            return &quot;default&quot;;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;应用方式非常简单，就像使用普通过滤器一样对控制器进行特性标记即可&lt;br/&gt;所不同的是，这里使用的是 MiddlewareFilter 进行注册 RegisterManagerPipeline&lt;br/&gt;管道式过滤器的优先级非常高，甚至比授权过滤器的优先级还高，在使用的时候需要特别注意应用场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;过滤器的执行顺序&quot;&gt;8. 过滤器的执行顺序&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;相同类型的过滤器其执行顺序可以使用 Order 字段进行指定，该值为一个 int32 类型，值越小表示优先级越高，该值只能作用于相同类型的过滤器&lt;br/&gt;比如，定义了两个 ActionFilter ，UserNameActionFilter,UserAgeActionFilter，分别制定其 Order 字段值为 10，5，那么 UserAgeActionFilter 将会在调用 ，UserNameActionFilter 之前执行&lt;br/&gt;但是，即使指定了 Order ，ActionFilter 的执行优先级也不会超越授权管理器 AuthorizeAttribute，这是设计上的不同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;8.1 Order 演示代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        [HttpPost]
        [UserNameActionFilter(Order = 10)]
        [UserAgeActionFilter(Order = 5)]
        public void Post([FromBody] UserModel value)
        {
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8.2 输出结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201812/26882-20181212134313271-801693837.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;上图输出的黄色部分文字清晰的说明了过滤器的执行顺序&lt;br/&gt;显示执行了资源过滤器，接着执行了 Order=5 的 UserAgeActionFilter ，最后执行了 Order=10 的 UserNameActionFilter 过滤器&lt;br/&gt;可以看到，虽然操作过滤器设置了 Order=5，但其执行优先级仍然不能超越授权过滤器，甚至无法超越资源过滤器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;本文简单介绍了 Asp.Net Core 下系统内置的各种各样的过滤器，分别是&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;授权过滤器 AuthorizeAttribute&lt;/li&gt;
&lt;li&gt;资源过滤器 IResourceFilter&lt;/li&gt;
&lt;li&gt;异常过滤器 IExceptionFilter&lt;/li&gt;
&lt;li&gt;操作过滤器 ActionFilterAttribute&lt;/li&gt;
&lt;li&gt;结果过滤器 IResultFilter&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;还通过一些简单说实例演示了过滤器的执行过程&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;最后介绍了如何在过滤器中使用中间件，以及对过滤器的执行顺序进行了详细的演示&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;演示代码下载&quot;&gt;演示代码下载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/viter/Ron.FilterDemo.zip&quot; class=&quot;uri&quot;&gt;https://files.cnblogs.com/files/viter/Ron.FilterDemo.zip&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Dec 2018 05:47:00 +0000</pubDate>
<dc:creator>Ron.liang</dc:creator>
<og:description>前言     过滤器，从我们开始开发 Asp.Net 应用程序开始，就一直伴随在我们左右；Asp.Net Core 提供多种类型的过滤器，以满足多种多样的业务应</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viter/p/10107886.html</dc:identifier>
</item>
</channel>
</rss>