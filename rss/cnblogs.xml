<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>动态储存方式和静态储存方式 - 巫师笔记</title>
<link>http://www.cnblogs.com/lvfengkun/p/10349385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvfengkun/p/10349385.html</guid>
<description>&lt;p&gt;变量从存在的时间（生存期）角度来分，可以分为动态储存方式和静态储存方式。&lt;/p&gt;
&lt;p&gt;所谓静态存储方式是指在程序运行开始时由系统分配固定的储存空间的方式。&lt;/p&gt;
&lt;p&gt;动态储存方式则是在程序运行期间根据需要进行动态的分配储存空间的方式。&lt;/p&gt;
&lt;p&gt;存储空间分为3部分：（1）程序区（2）静态存储区（3）动态存储区。&lt;/p&gt;
&lt;p&gt;在C语言中，每一个变量和函数都有两个属性：数据类型和数据的存储类别。&lt;/p&gt;
&lt;p&gt;对数据型（如整型，字符型等）：储存类别指的是数据在内存中的储存方式。具体包含四种：自动的（auto），静态的（static），寄存器的（register），外部的（extern）。根据变量的储存类别，可以知道变量的作用域和生存期。&lt;/p&gt;
&lt;p&gt;1、auto变量&lt;/p&gt;
&lt;p&gt;函数中的局部变量，如不专门声明为static储存类别，都是动态的分配存储空间（栈），数据存储在动态存储区中。&lt;/p&gt;
&lt;p&gt;函数中的形参和在函数中定义的变量（包括在复合语句中定义的变量），都属此类，在调用该函数时，系统会给它们分配存储空间，在函数调用结束时，自动释放这些存储空间。&lt;/p&gt;
&lt;p&gt;例：int f(int a) 　　/*定义为f函数，a为形参*/&lt;/p&gt;
&lt;p&gt;　　{&lt;/p&gt;
&lt;p&gt;　　　　auto int b,c=3;　　/*定义b,c为自动变量*/&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;关键字auto可以省略，auto不写则默认为“自动存储类别”。&lt;/p&gt;
&lt;p&gt;2、用stastic声明局部变量&lt;/p&gt;
&lt;p&gt;有时希望函数中的局部变量的值在函数调用结束后不消失，即存储单元不释放。&lt;/p&gt;
&lt;p&gt;这时就应指定局部变量为“静态局部变量”，用static进行声明。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdafx.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; f(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a)
{
    auto b&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
    b&lt;/span&gt;=b+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    c&lt;/span&gt;=c+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;(a+b+&lt;span&gt;c);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;3&lt;/span&gt;;i++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,f(a));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：(1）静态局部变量属于静态存储类别，在静态存储区内分配存储单元。在函数整个运行期间都不释放，而自动变量属于动态存储类别，占动态存储空间而不占静态存储空间，函数调用结束后释放。&lt;/p&gt;
&lt;p&gt;（2）对静态局部变量是在编译时赋初值的，即只赋初值一次，在程序运行时已有初值。&lt;/p&gt;
&lt;p&gt;（3）若在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符型变量），对自动变量来说，不赋初值则它的值是一个不确定的值。&lt;/p&gt;
&lt;p&gt;（4）虽然静态局部变量在函数调用结束后仍然存在，但其他函数是不能引用它的。&lt;/p&gt;
&lt;p&gt;例：输出从1到5的阶乘值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdafx.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; fac(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a)
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; f=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    f&lt;/span&gt;=f*&lt;span&gt;a;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(f);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i ;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=&lt;span&gt;5&lt;/span&gt;;i++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d!=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,i,fac(i));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、register变量&lt;/p&gt;
&lt;p&gt; 一般情况下，变量存放在内存中。&lt;/p&gt;
&lt;p&gt;但若一些变量使用过于频繁则会浪费很多时间（cpu处理数据与内存读取数据有时间差）。&lt;/p&gt;
&lt;p&gt;为提高程序执行效率，C语言允许将局部变量的值放在CPU寄存器中，需要时直接取出参加运算，不必再到内存中去存取。&lt;/p&gt;
&lt;p&gt;这种变量称为寄存器变量，用关键字register作声明。&lt;/p&gt;
&lt;p&gt;例：输出1到n阶乘的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdafx.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; fac(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i ,f=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
    {
        f&lt;/span&gt;*=&lt;span&gt;i;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(f);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,n;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;n);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d!=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,i,fac(i));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、用extern声明外部变量&lt;/p&gt;
&lt;p&gt;有时要用extern来声明外部变量，以扩展外部变量的作用域。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdafx.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; max(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; z;
    z&lt;/span&gt;=x&amp;gt;y?&lt;span&gt;x:y;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(z);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; A,B;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,max(A,B));
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; A=&lt;span&gt;13&lt;/span&gt;,B=&lt;span&gt;8&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实extern的作用就是告诉编译器读到AB时知道其为全局变量，其值可能在程序的任意一个地方。&lt;/p&gt;

</description>
<pubDate>Sat, 02 Feb 2019 15:36:00 +0000</pubDate>
<dc:creator>巫师笔记</dc:creator>
<og:description>变量从存在的时间（生存期）角度来分，可以分为动态储存方式和静态储存方式。 所谓静态存储方式是指在程序运行开始时由系统分配固定的储存空间的方式。 动态储存方式则是在程序运行期间根据需要进行动态的分配储存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvfengkun/p/10349385.html</dc:identifier>
</item>
<item>
<title>线性表 - 栗子姑娘</title>
<link>http://www.cnblogs.com/Chestnut-g/p/10326789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Chestnut-g/p/10326789.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线性表的定义和基本运算&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线性表的逻辑定义&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;(1) 线性表，Linear_List是最简单和最常用的一种数据结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2) 线性表是由n个数据元素（结点）a1,a2,...,an组成的&lt;span&gt;有限序列&lt;/span&gt;。类比数学中的数列概念。其中我们规定数组元素的个数n为该线性表的长度,size。当n为零时，称为空表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3) 非空的线性表通常记为：(a1,a2,a3,...,an)，其中ai（1&amp;lt;=i&amp;lt;=n）表示线性表的其中一个结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;(4) a1称为表的开始结点，无直接前驱，有一个直接后继a2; &lt;/span&gt;&lt;span&gt;an为表的终端结点，无直接后继，有一个直接前驱an-1; &lt;/span&gt;&lt;span&gt;其余元素ai(2&amp;lt;=i&amp;lt;=n-1)为内部元素，有前驱ai-1,后继ai+1;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结点与结点之间是线性的关系。故称之为线性表。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1487352/201902/1487352-20190202202326580-1614840116.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线性表的基本运算&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;(1) 置空表initlist(L)，构造一个空的线性表；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2) 求表长listLength(L),返回线性表的长度；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3) 取元素getNode(L,i),1&amp;lt;=i&amp;lt;=n;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4) 按值查找 LocateNode(L,x),返回第一个为X的结点的位置，若表中不存在则返回0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(5) 插入insert(L,i,x) 在L的i位置插入x，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(6) 删除delete(L,i) 删除表中的第i个元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线性表的顺序存储和基本元素的实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线性表的顺序存储&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;(1) 线性表的顺序存储指的是将线性表的数据元素按其&lt;span&gt;逻辑顺序&lt;/span&gt;依次存入一组&lt;span&gt;地址连续&lt;/span&gt;的存储单元中，用这种方式存储的线性表称为顺序表，例如数组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2) 假设每个结点的空间大小都一致，即数据类型一致，例如对于每个int来说，占用4个字节，32位。设每个结点的空间大小为d，那么，一般来说，线性表中第i个元素的存储位置为：&lt;strong&gt;&lt;span&gt;LOC(ai)=LOC(a1)+(i-1)*d&lt;/span&gt;&lt;/strong&gt;  (种树比喻)，其中ai的地址称为首地址或基地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3) 因为在顺序表中任何一个元素的地址都可以通过计算确定，所以可以做到&lt;span&gt;随机存储&lt;/span&gt;。举例内存的读取模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4) 因为在高级程序设计语言中，数组类型具有随机存取的特性，因此，通常用数组描述顺序表。除了存储线性表的结点外，还需要一个变量（size）来标识线性表的长度。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;顺序表上基本运算的实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;(1) 随机读取第i个元素，L[i]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2) 置空表，L.size=0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3) 插入insert(L,i,x) 在L的i位置插入x&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4) 删除delete(L,i) 删除表中的第i个元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(5) 倒置列表reverse(L)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;线性表的链式存储结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;顺序表的读取快，但是插入与删除缓慢，鉴于此，引申出链表&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;链表不可以随机读取，因为第i个元素的地址不能直接读取到&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;单链表（线性链表）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;(1) 存储ai时，除了保存ai本身，还存储了ai+1的地址信息，即C中的指针。包含了两部分信息的结点，含有原有数据的域为数据域，存储直接后继的为指针域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2) 采取这种存储方式的表为链表，其中每一个结点的存储结构为：[data][next]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3) 因为每一个结点只包含1个指针域，所以称为单链表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4) 因为第一个结点没有直接前趋，所以特地设立一个head存放第一个元素的地址，即头指针。而终端结点的指针域则为null。如果表中一个结点也没有，则head=NULL&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单链表上的运算&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;(1) 建立单链表：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;① &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;头插法：&lt;span&gt;（符合先进后出特点，是天生的链栈）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从一个空表开始，重复读入数据，生称新结点，将数据存到数据域中，然后将新结点的地址存到表头上。 插入顺序与链表顺序相反。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1487352/201902/1487352-20190202200905681-210339577.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;头插法步骤：&lt;/strong&gt;&lt;/span&gt;(如图黑线所示，即为链栈的插入结果)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）&lt;strong&gt;判断插入列表是否为空。即长度size？=0；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）&lt;strong&gt;读取当前head值。&lt;/strong&gt;已知&lt;span&gt;头指针head的当前值为null&lt;/span&gt;；head.next = null，元素data的自身地址为stu0，stu0. next = null；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）&lt;strong&gt;令头指针的值指向新元素的地址。&lt;/strong&gt;即&lt;span&gt;head.next = stu0；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当下一个元素进行插入时，循环上述步骤；即当size = 1时；head.next = stu0，stu1只识别头指针，将stu1.next = head.next，即stu1.next =  stu0；最后再将head.next = stu1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;② &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;尾插法：&lt;span&gt;（符合先进先出的特点，是天生的链队列）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将新结点插入到当前链表的表尾，需要一个尾部指针,rear,使其始终指向链表的尾结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1487352/201902/1487352-20190202200726095-1505549664.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;尾插法步骤：&lt;/strong&gt;&lt;/span&gt;(如图红线所示，即为链表的插入过程)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）与头插法相同，&lt;strong&gt;先判断表长size ？= 0&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）&lt;strong&gt;读取当前rear值。&lt;/strong&gt;当size = 0时，读取当前rear值为null；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）&lt;strong&gt;令尾指针rear指向新元素地址。&lt;/strong&gt;head.next = stu1; rear.next = stu1.next 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;需注意头指针head指向头元素后将不再变化，即head.next = stu1保持不变；尾插法只移动尾指针rear。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当下一个元素进行插入时，循环上述步骤；即当size = 1时； rear.next = stu1.next；stu2只识别尾指针rear，将rear.next = stu2，即stu1.next =  stu2；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后再将rear.next =stu2.next。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2) 查找运算：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 因为链表中的地址隐含在前趋中，所以必须从head开始查找&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 按结点序号查找&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③ 按结点值查找&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3) 插入运算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4) 删除运算&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;单循环列表：终端元素设置为a1的地址，可以从任意一个位置开始查找。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;双向链表：在指针域中加入前趋的地址，可以双向查找。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;结合以上的特点可以形成循环双向链表。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 02 Feb 2019 12:25:00 +0000</pubDate>
<dc:creator>栗子姑娘</dc:creator>
<og:description>线性表的定义和基本运算 线性表的逻辑定义 (1) 线性表，Linear_List是最简单和最常用的一种数据结构。 (2) 线性表是由n个数据元素（结点）a1,a2,...,an组成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Chestnut-g/p/10326789.html</dc:identifier>
</item>
<item>
<title>Linux系统多网卡环境下的路由配置 - varlemon</title>
<link>http://www.cnblogs.com/connect/p/linux-static-route.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/connect/p/linux-static-route.html</guid>
<description>&lt;h2 id=&quot;linux下路由配置命令&quot;&gt;Linux下路由配置命令&lt;/h2&gt;
&lt;h4 id=&quot;添加主机路由&quot;&gt;1. 添加主机路由&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;route add -host 192.168.1.11 dev eth0
route add -host 192.168.1.12 gw 192.168.1.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;添加网络路由&quot;&gt;2. 添加网络路由&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;route add -net 192.168.1.11 netmask 255.255.255.0 eth0
route add -net 192.168.1.11 netmask 255.255.255.0 gw 192.168.1.1
route add -net 192.168.1.0/24 eth0
route add -net 192.168.1.0/24 gw 192.168.1.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;添加默认网关&quot;&gt;3. 添加默认网关&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;route add default gw 192.168.1.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删除路由&quot;&gt;4. 删除路由&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;route del -host 192.168.1.11 dev eth0&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删除默认路由&quot;&gt;5. 删除默认路由&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;route del default gw 192.168.1.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;linux下配置永久路由的几种方式&quot;&gt;Linux下配置永久路由的几种方式&lt;/h2&gt;
&lt;h4 id=&quot;在etcrc.local里添加路由信息&quot;&gt;1. 在&lt;code&gt;/etc/rc.local&lt;/code&gt;里添加路由信息&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;route add -net 192.168.1.0/24 dev eth0
# 或者
route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;在etcsysconfignetwork里追加&quot;&gt;2. 在&lt;code&gt;/etc/sysconfig/network&lt;/code&gt;里追加&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;GATEWAY=[网关IP或者网关网卡名称]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;etcsysconfigstatic-routes&quot;&gt;3. &lt;code&gt;/etc/sysconfig/static-routes&lt;/code&gt;&lt;/h4&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;any net 192.168.1.0/24 gw 192.168.1.1
# 或者
any net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;开启ip转发&quot;&gt;4. 开启IP转发&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.临时开启&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;echo &quot;1&quot; &amp;gt; /proc/sys/net/ipv4/ip_forward&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.永久开启&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;vim /etc/sysctl.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;net.ipv4.ip_forward=1&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;实验配置双网卡主机同时使用内网和外网&quot;&gt;实验：配置双网卡主机同时使用内网和外网&lt;/h2&gt;
&lt;p&gt;本实验的背景是笔者在实践中遇到过的一个问题，本实验尽量还原当时的网络环境。仅当做一份笔记，同时分享给遇到此问题的同学。&lt;br/&gt;奈何我现在没有硬件呀(T＿T)...只能拿&lt;strong&gt;VMware Workstation&lt;/strong&gt;和&lt;strong&gt;eNSP&lt;/strong&gt;来模拟实验环境了。&lt;/p&gt;
&lt;h3 id=&quot;问题背景&quot;&gt;问题背景&lt;/h3&gt;
&lt;p&gt;如下图拓扑所示，如果去掉&lt;code&gt;client&lt;/code&gt;节点，&lt;strong&gt;内网&lt;/strong&gt;和&lt;strong&gt;外网&lt;/strong&gt;就是相互隔离的网络。&lt;/p&gt;
&lt;p&gt;但是实际情况是，&lt;code&gt;client&lt;/code&gt;节点既需要访问外网资源，又需要访问内网资源，而&lt;code&gt;client&lt;/code&gt;只能配置一条默认路由。如果将默认路由配置在外网网卡，&lt;code&gt;client&lt;/code&gt;可以访问&lt;code&gt;172.16.2.0/24&lt;/code&gt;网络的资源和外网的资源，但是其余内网资源将无法访问；如果将默认路由配置在内网网卡，&lt;code&gt;client&lt;/code&gt;虽然可以完全访问内网资源，但是却不能访问外网资源。&lt;br/&gt;怎么解决呢？&lt;/p&gt;
&lt;h3 id=&quot;实验环境&quot;&gt;实验环境&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;VMware Workstation Pro&lt;/li&gt;
&lt;li&gt;4台最小化安装的CentOS 7.3虚拟机&lt;/li&gt;
&lt;li&gt;华为eNSP模拟器&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;实验拓扑&quot;&gt;实验拓扑&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202143916520-1437377307.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;去掉&lt;code&gt;client&lt;/code&gt;节点，内网和外网是隔离的网络。&lt;br/&gt;外网网络为&lt;code&gt;10.0.0.0/16&lt;/code&gt;，代表运营商的接入网；&lt;br/&gt;内网网络为&lt;code&gt;172.16.0.0/16&lt;/code&gt;，代表内网部分（该部分为了安全，不允许对互联网的直接访问）。&lt;br/&gt;&lt;strong&gt;其中&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;client&lt;/code&gt;为双网卡的主机，两网卡网段分别为&lt;code&gt;10.0.0.0/16&lt;/code&gt;、&lt;code&gt;172.16.2.0/24&lt;/code&gt;；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server2&lt;/code&gt;为&lt;code&gt;172.16.2.0/24&lt;/code&gt;网段的服务器；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server3&lt;/code&gt;为&lt;code&gt;172.16.3.0/24&lt;/code&gt;网段的服务器；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server4&lt;/code&gt; 为&lt;code&gt;172.16.4.0/24&lt;/code&gt;网段的服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;网络规划&quot;&gt;网络规划&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IP分配&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;table readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;th&gt;节点名称&lt;/th&gt;
&lt;th&gt;IP地址&lt;/th&gt;
&lt;th&gt;子网掩码&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;client&lt;/td&gt;
&lt;td&gt;10.0.0.101&lt;/td&gt;
&lt;td&gt;255.255.0.0&lt;/td&gt;
&lt;td&gt;client的外网网卡&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;172.16.2.101&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;td&gt;client的内网网卡&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Server2&lt;/td&gt;
&lt;td&gt;172.16.2.11&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;td&gt;172.16.2.0/24网段的某台服务器&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Server3&lt;/td&gt;
&lt;td&gt;172.16.3.11&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;td&gt;172.16.3.0/24网段的某台服务器&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Server4&lt;/td&gt;
&lt;td&gt;172.16.4.11&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;td&gt;172.16.4.0/24网段的某台服务器&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;3&quot;&gt;内网路由器&lt;/td&gt;
&lt;td&gt;172.16.2.254&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;td&gt;172.16.2.0/24的网关&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;172.16.3.254&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;td&gt;172.16.3.0/24的网关&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;172.16.4.254&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;td&gt;172.16.4.0/24的网关&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;虚机网卡类型&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;运营商网络&lt;/td&gt;
&lt;td&gt;桥接&lt;/td&gt;
&lt;td&gt;10.0.0.0/16&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;VMnet2&lt;/td&gt;
&lt;td&gt;仅主机&lt;/td&gt;
&lt;td&gt;172.16.2.0/24&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;VMnet3&lt;/td&gt;
&lt;td&gt;仅主机&lt;/td&gt;
&lt;td&gt;172.16.3.0/24&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;VMnet4&lt;/td&gt;
&lt;td&gt;仅主机&lt;/td&gt;
&lt;td&gt;172.16.4.0/24&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;内网路由器如何实现呢？&lt;/strong&gt;&lt;br/&gt;VMnet2、VMnet3、VMnet4均为仅主机模式，那么常规情况下，只有其网络内的各计算机之间才可以通信，要怎样才能实现三个网络间的通信呢？&lt;br/&gt;答案是使用&lt;strong&gt;华为eNSP模拟器&lt;/strong&gt;中的&lt;strong&gt;Cloud&lt;/strong&gt;。使用Cloud设备可以将eNSP中的路由器和VMware虚拟机的网卡连接起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202143926739-770360127.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置内网环境&quot;&gt;配置内网环境&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;配置eNSP的路由器&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;G0/0/0&lt;/td&gt;
&lt;td&gt;172.16.2.254&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;G0/0/1&lt;/td&gt;
&lt;td&gt;172.16.3.254&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;G0/0/2&lt;/td&gt;
&lt;td&gt;172.16.4.254&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre class=&quot;conf&quot;&gt;
&lt;code&gt;&amp;lt;huawei&amp;gt;system-view
[huawei]int g0/0/0
[Huawei-GigabitEthernet0/0/0]ip address 172.16.2.254 255.255.255.0
[Huawei-GigabitEthernet0/0/0]quit
[huawei]int g0/0/1
[Huawei-GigabitEthernet0/0/1]ip address 172.16.3.254 255.255.255.0
[Huawei-GigabitEthernet0/0/1]quit
[huawei]int g0/0/2
[Huawei-GigabitEthernet0/0/2]ip address 172.16.4.254 255.255.255.0
[Huawei-GigabitEthernet0/0/2]quit
[huawei]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;修改虚机的IP地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;client&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ens33&lt;/td&gt;
&lt;td&gt;10.0.0.101&lt;/td&gt;
&lt;td&gt;255.255.0.0&lt;/td&gt;
&lt;td&gt;10.0.0.1&lt;/td&gt;
&lt;td&gt;外网网卡&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ens37&lt;/td&gt;
&lt;td&gt;172.16.2.101&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;内网网卡&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;server2&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ens33&lt;/td&gt;
&lt;td&gt;172.16.2.11&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;td&gt;172.16.2.254&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;server3&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ens33&lt;/td&gt;
&lt;td&gt;172.16.3.11&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;td&gt;172.16.3.254&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;server4&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ens33&lt;/td&gt;
&lt;td&gt;172.16.4.11&lt;/td&gt;
&lt;td&gt;255.255.255.0&lt;/td&gt;
&lt;td&gt;172.16.4.254&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;在server上搭建HTTP服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;server2&lt;/code&gt;为例：&lt;br/&gt;使用Python创建一个简单的HTTP服务&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;cd ~
echo &quot;server2&quot; &amp;gt; index.html
python -m SimpleHTTPServer 8080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202145354415-209974201.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;对照试验&quot;&gt;对照试验&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在&lt;code&gt;client&lt;/code&gt;上访问外网&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ping www.baidu.com -c 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202143940080-539828145.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在&lt;code&gt;client&lt;/code&gt;上访问&lt;code&gt;server2&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ping 172.16.2.11 -c 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202144018105-2138201273.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在&lt;code&gt;client&lt;/code&gt;上访问&lt;code&gt;server3&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ping 172.16.3.11 -c 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202144023072-1181923552.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在&lt;code&gt;client&lt;/code&gt;上访问&lt;code&gt;server4&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ping 172.16.4.11 -c 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202144029634-1382912862.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在对照试验中可以看到，在&lt;code&gt;client&lt;/code&gt;将默认网关配置在外网网卡的情况下，双网卡的&lt;code&gt;client&lt;/code&gt;可以正常访问外网和内网的&lt;code&gt;172.16.2.0/24&lt;/code&gt;部分，而&lt;code&gt;172.16.3.0/24&lt;/code&gt;和&lt;code&gt;172.16.4.0/24&lt;/code&gt;是不能访问到的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么&lt;code&gt;client&lt;/code&gt;能访问&lt;code&gt;172.16.2.0/24&lt;/code&gt;网络，而不能访问&lt;code&gt;172.16.0.0/16&lt;/code&gt;的其余网络呢？&lt;/strong&gt;&lt;br/&gt;因为&lt;code&gt;client&lt;/code&gt;位于&lt;code&gt;172.16.2.0/24&lt;/code&gt;网络内，在网络内进行通信，数据包不用发送至其他网络，当然默认网关也就不起作用了。&lt;br/&gt;而当&lt;code&gt;client&lt;/code&gt;与&lt;code&gt;172.16.0.0/16&lt;/code&gt;的其余网络通信时，&lt;code&gt;client&lt;/code&gt;的路由表没有记载发往目的地址的路径，所以&lt;code&gt;client&lt;/code&gt;只能傻傻的把数据包发送给默认网关，从此数据包和真正的目的地址就“南辕北辙”了。当然ping的结果就是网络不可达。&lt;/p&gt;
&lt;h3 id=&quot;路由配置&quot;&gt;路由配置&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;client&lt;/code&gt;上查看路由表&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;route&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202144037625-923014699.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;client&lt;/code&gt;上添加路由&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;route add -net 172.16.0.0/16 gw 172.16.2.254&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;永久配置，则在&lt;code&gt;/etc/rc.local&lt;/code&gt;里添加路由信息&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;route add -net 172.16.0.0/16 gw 172.16.2.254&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看路由表&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;route&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202144043445-1108099622.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实验结果&quot;&gt;实验结果&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;检测连通性&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ping www.baidu.com -c 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202144048979-1976391424.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ping 172.16.2.11 -c 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202144057122-973858867.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ping 172.16.3.11 -c 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202144102329-171677618.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ping 172.16.4.11 -c 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202144110768-503658917.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问内外网资源&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl http://www.baidu.com/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202144116424-1777917375.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl http://172.16.2.11:8080/index.html&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl http://172.16.3.11:8080/index.html&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl http://172.16.4.11:8080/index.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1222343/201902/1222343-20190202144121721-78532355.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决的办法很简单，就是1条命令而已。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;但是蕴藏在这条命令背后的原理、概念、理论，则需要我们进行深究！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;https://www.cnblogs.com/connect/p/linux-static-route.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/connect/p/linux-static-route.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 02 Feb 2019 12:04:00 +0000</pubDate>
<dc:creator>varlemon</dc:creator>
<og:description>Linux下多网卡环境下的路由配置。同时用一项实验来展示Linux双网卡主机经过配置，可以同时访问内网和外网的资源。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/connect/p/linux-static-route.html</dc:identifier>
</item>
<item>
<title>业务系统日志追踪 - Mr.yang.localhost</title>
<link>http://www.cnblogs.com/mr-yang-localhost/p/10348345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-yang-localhost/p/10348345.html</guid>
<description>&lt;h2&gt;1、遇到的问题&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;开发中常常会打印业务日志，这些日志在排查问题或跟踪调用流程时非常有用，很多业务日志并没有考虑排查问题时的便利性，看似都记录了日志，一旦出现了线上问题，排查起来特别麻烦，很多时候又不方便让用户重现问题，造成解决问题周期长甚至是无法解决问题；如果日志记录的好，可以根据关键字搜索得出一条调用链日志，顺着这个日志链条就可以看出程序的执行全过程了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2、如何记录日志&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;当然，应用、环境、ip、日志时间、日志级别、线程、输入输出参数…这些都是必要便于排错的日志信息就不多说了，重点说下如何记录跟踪一次调用流程的日志记录方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一种方法是：打印日志时候指明业务线，比如支付的流程里，所有步骤业务日志统一前缀 &quot;支付流程:userId:&quot;，那么排查问题时候就可以根据关键字和userId来快速得到某个userid在支付流程里的所有轨迹。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是这种方法有如下问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、所有log统一前缀实行起来不太容易&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、同一个userid的log可能会非常多，并不能按request来归类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、如果涉及到了公共方法调用（同时被多个业务流程调用），统一前缀很难实施&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一种方法是使用filter（&lt;a href=&quot;https://www.cnblogs.com/mr-yang-localhost/p/7784607.html#_label2&quot; target=&quot;_blank&quot;&gt;filter使用传送门&lt;/a&gt;）给每个request生成唯一标识，在log里带上这个标识，将一个request的log通过唯一标识串成一串。&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ed2caf46-7789-42b7-a43b-4b93a3122cc9')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_ed2caf46-7789-42b7-a43b-4b93a3122cc9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ed2caf46-7789-42b7-a43b-4b93a3122cc9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ed2caf46-7789-42b7-a43b-4b93a3122cc9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ed2caf46-7789-42b7-a43b-4b93a3122cc9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
@WebFilter(filterName = &quot;myFilter&quot;,urlPatterns = &quot;/*&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LogFilter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Filter {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init(FilterConfig filterConfig) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doFilter(ServletRequest request, ServletResponse response, FilterChain chain) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
        String replace &lt;/span&gt;= UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;&lt;span&gt;);
        LogHolder.setLogId(replace);
        LogUtil.info(&lt;/span&gt;&quot;thread:&quot;+Thread.currentThread().getName() + &quot;,uuid : &quot; + replace+&quot;,url:&quot;+&lt;span&gt;((HttpServletRequest) request).getRequestURI());
        chain.doFilter(request, response);
        LogHolder.remove();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy() {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;LogUtil：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Slf4j
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogUtil {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; info(String content, Object... args) {
        log.info(String.format(&lt;/span&gt;&quot;LogFlowId: %s , %s&quot;&lt;span&gt;, LogHolder.getLogId(), content), args);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; warn(String content, Object... args) {
        log.info(String.format(&lt;/span&gt;&quot;LogFlowId: %s , %s&quot;&lt;span&gt;, LogHolder.getLogId(), content), args);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; error(String content, Exception ex) {
        log.error(&lt;/span&gt;String.format(&quot;LogFlowId: %s , %s&quot;, LogHolder.getLogId(), content)&lt;span&gt;, ex); &lt;br/&gt;　　}&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;业务场景：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a5cda1a6-0aa7-49ac-9dd0-a6491150a087')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_a5cda1a6-0aa7-49ac-9dd0-a6491150a087&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a5cda1a6-0aa7-49ac-9dd0-a6491150a087&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a5cda1a6-0aa7-49ac-9dd0-a6491150a087',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a5cda1a6-0aa7-49ac-9dd0-a6491150a087&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    @RequestMapping(&quot;/log&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; writelog() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        LogUtil.info(&lt;/span&gt;&quot;request begin&quot;&lt;span&gt;);
        test();
        LogUtil.info(&lt;/span&gt;&quot;request end&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l =&lt;span&gt; System.currentTimeMillis();
        Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        LogUtil.info(&lt;/span&gt;&quot;操作耗时：&quot; + (System.currentTimeMillis() - l) + &quot; ms&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出日志如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201902/1042079-20190202163658900-294883165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以根据任意一步的logFlowId检索出整个request生命周期内的所有log。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一般的情况都可以实现，但是如果程序里使用了线程池会不会有线程复用的问题？来验证一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;业务代码修改如下：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a93b1bb6-78aa-48b5-9c50-c03f37816506')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_a93b1bb6-78aa-48b5-9c50-c03f37816506&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a93b1bb6-78aa-48b5-9c50-c03f37816506&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a93b1bb6-78aa-48b5-9c50-c03f37816506',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a93b1bb6-78aa-48b5-9c50-c03f37816506&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    @RequestMapping(&quot;/log&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writelog() {
        LogUtil.info(&lt;/span&gt;&quot;request begin&quot;&lt;span&gt;);
        ExecuterServiceUtil.run(() &lt;/span&gt;-&amp;gt;&lt;span&gt; test());
        LogUtil.info(&lt;/span&gt;&quot;request end&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; l =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        LogUtil.info(&lt;/span&gt;&quot;操作耗时：&quot; + (System.currentTimeMillis() - l) + &quot; ms&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201902/1042079-20190202164802952-1846012213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取不到设置在ThreadLocal里的logFlowId了，这是因为线程池重新开辟了子线程，子线程不能访问主线程设置的logFlowId，可以使用 InheritableThreadLocal 来解决问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改LogHolder为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9d31021a-b13f-44b0-a1a5-18800cee4bf2')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_9d31021a-b13f-44b0-a1a5-18800cee4bf2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9d31021a-b13f-44b0-a1a5-18800cee4bf2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9d31021a-b13f-44b0-a1a5-18800cee4bf2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9d31021a-b13f-44b0-a1a5-18800cee4bf2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogHolder {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LogHolder() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; LOG_ID = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getLogId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; LOG_ID.get();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setLogId(String logId) {
        LOG_ID.set(logId);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
        LOG_ID.remove();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;再次运行发现logFlowId有值了，但是却重复了，很明显是因为线程复用造成的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201902/1042079-20190202165446922-338825413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终解决办法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、获取主线程设置的logFlowId&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、执行前设置到子线程里&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、用完后清除子线程变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201902/1042079-20190202165739975-1940437663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出日志如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201902/1042079-20190202171107086-1896336304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是分布式应用跟踪，可以通过header透传方式，将logFlowId传入下一个应用里。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3、附录&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/yangyp8110/xx-dem/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E8%BF%BD%E8%B8%AA&quot; target=&quot;_blank&quot;&gt;demo&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 02 Feb 2019 09:23:00 +0000</pubDate>
<dc:creator>Mr.yang.localhost</dc:creator>
<og:description>1、遇到的问题 开发中常常会打印业务日志，这些日志在排查问题或跟踪调用流程时非常有用，很多业务日志并没有考虑排查问题时的便利性，看似都记录了日志，一旦出现了线上问题，排查起来特别麻烦，很多时候又不方便</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mr-yang-localhost/p/10348345.html</dc:identifier>
</item>
<item>
<title>Golang的sync.WaitGroup 实现逻辑和源码解析 - jiangz222</title>
<link>http://www.cnblogs.com/jiangz222/p/10348763.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangz222/p/10348763.html</guid>
<description>&lt;p&gt;在Golang中，WaitGroup主要用来做go Routine的等待，当启动多个go程序，通过waitgroup可以等待所有go程序结束后再执行后面的代码逻辑，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;func Main() {
    wg :&lt;/span&gt;=&lt;span&gt; sync.WaitGroup{}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++&lt;span&gt; {
        wg.Add(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        go func() {
            defer wg.Done()
            time.Sleep(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; *&lt;span&gt; time.Second)
        }()

    }
    wg.Wait() // 等待在此，等所有go func里都执行了Done()才会退出
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WaitGroup主要是三个方法，Add(int),Done()和Wait(), 其中Done()是调用了Add(-1)，推荐使用方法是，先统一Add，在goroutine里并发的Done，然后Wait&lt;/p&gt;
&lt;p&gt;WaitGroup主要维护了2个计数器，一个是请求计数器 v，一个是等待计数器 w，二者组成一个64bit的值，请求计数器占高32bit，等待计数器占低32bit。&lt;/p&gt;
&lt;p&gt;简单来说，当Add(n)执行时，请求计数器 v 就会加n，当Done()执行时，v 就会减1，可以想到，v 为0时就是结束，可以触发Wait()执行了，所谓的触发Wait()是通过信号量实现的。&lt;/p&gt;
&lt;p&gt;那么等待计数器拿来干嘛？是因为Wait()方法支持并发，每一次Wait()方法执行，等待计数器 w 就会加1，而等待v为0触发Wait()时，要根据w的数量发送w份的信号量，正确的触发所有的Wait()。&lt;/p&gt;
&lt;p&gt;同时，WaitGroup里还有对使用逻辑进行了严格的检查，比如Wait()一旦开始不能Add().&lt;/p&gt;
&lt;p&gt;下面是带注释的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
func (wg *WaitGroup) Add(delta &lt;span&gt;int&lt;/span&gt;&lt;span&gt;) {
    statep :&lt;/span&gt;=&lt;span&gt; wg.state()
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新statep，statep将在wait和add中通过原子操作一起使用&lt;/span&gt;
    state := atomic.AddUint64(statep, uint64(delta)&amp;lt;&amp;lt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)
    v :&lt;/span&gt;= int32(state &amp;gt;&amp;gt; &lt;span&gt;32&lt;/span&gt;&lt;span&gt;)
    w :&lt;/span&gt;=&lt;span&gt; uint32(state)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; v &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; {
        panic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sync: negative WaitGroup counter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; w != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; delta &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; v ==&lt;span&gt; int32(delta) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait不等于0说明已经执行了Wait，此时不容许Add&lt;/span&gt;
        panic(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sync: WaitGroup misuse: Add called concurrently with Wait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正常情况，Add会让v增加，Done会让v减少，如果没有全部Done掉，此处v总是会大于0的，直到v为0才往下走
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而w代表是有多少个goruntine在等待done的信号，wait中通过compareAndSwap对这个w进行加1&lt;/span&gt;
     &lt;span&gt;if&lt;/span&gt; v &amp;gt; &lt;span&gt;0&lt;/span&gt; || w == &lt;span&gt;0&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This goroutine has set counter to 0 when waiters &amp;gt; 0.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Now there can't be concurrent mutations of state:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - Adds must not happen concurrently with Wait,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - Wait does not increment waiters if it sees counter == 0.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Still do a cheap sanity check to detect WaitGroup misuse.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当v为0(Done掉了所有)或者w不为0(已经开始等待)才会到这里，但是在这个过程中又有一次Add，导致statep变化，panic&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; *statep !=&lt;span&gt; state {
        panic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sync: WaitGroup misuse: Add called concurrently with Wait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reset waiters count to 0.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将statep清0，在Wait中通过这个值来保护信号量发出后还对这个Waitgroup进行操作&lt;/span&gt;
    *statep = &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将信号量发出，触发wait结束&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; ; w != &lt;span&gt;0&lt;/span&gt;; w--&lt;span&gt; {
        runtime_Semrelease(&lt;/span&gt;&amp;amp;wg.sema, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Done decrements the WaitGroup counter by one.&lt;/span&gt;
func (wg *&lt;span&gt;WaitGroup) Done() {
    wg.Add(&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Wait blocks until the WaitGroup counter is zero.&lt;/span&gt;
func (wg *&lt;span&gt;WaitGroup) Wait() {
    statep :&lt;/span&gt;=&lt;span&gt; wg.state()
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; {
        state :&lt;/span&gt;=&lt;span&gt; atomic.LoadUint64(statep)
        v :&lt;/span&gt;= int32(state &amp;gt;&amp;gt; &lt;span&gt;32&lt;/span&gt;&lt;span&gt;)
        w :&lt;/span&gt;=&lt;span&gt; uint32(state)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; v == &lt;span&gt;0&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Counter is 0, no need to wait.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; race.Enabled {
                race.Enable()
                race.Acquire(&lt;/span&gt;&lt;span&gt;unsafe&lt;/span&gt;&lt;span&gt;.Pointer(wg))
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Increment waiters count.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果statep和state相等，则增加等待计数，同时进入if等待信号量
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处做CAS，主要是防止多个goroutine里进行Wait()操作，每有一个goroutine进行了wait，等待计数就加1
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果这里不相等，说明statep，在 从读出来 到 CAS比较 的这个时间区间内，被别的goroutine改写了，那么不进入if，回去再读一次，这样写避免用锁，更高效些&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; atomic.CompareAndSwapUint64(statep, state, state+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; race.Enabled &amp;amp;&amp;amp; w == &lt;span&gt;0&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Wait must be synchronized with the first Add.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Need to model this is as a write to race with the read in Add.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; As a consequence, can do the write only for the first waiter,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; otherwise concurrent Waits will race with each other.&lt;/span&gt;
                race.Write(&lt;span&gt;unsafe&lt;/span&gt;.Pointer(&amp;amp;&lt;span&gt;wg.sema))
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待信号量&lt;/span&gt;
            runtime_Semacquire(&amp;amp;&lt;span&gt;wg.sema)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 信号量来了，代表所有Add都已经Done&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; *statep != &lt;span&gt;0&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 走到这里，说明在所有Add都已经Done后，触发信号量后，又被执行了Add&lt;/span&gt;
                panic(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sync: WaitGroup is reused before previous Wait has returned&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 02 Feb 2019 09:04:00 +0000</pubDate>
<dc:creator>jiangz222</dc:creator>
<og:description>goalng waitgroup 源码 分析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiangz222/p/10348763.html</dc:identifier>
</item>
<item>
<title>正则的使用心得 - 快乐又疲惫的程序猿</title>
<link>http://www.cnblogs.com/Simple-and-complex/p/10348762.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Simple-and-complex/p/10348762.html</guid>
<description>&lt;p&gt;&lt;span&gt;以前使用正则是不会自己去学或者去了解怎么实现正则的语法的，感觉好难懂的样子，于是拖到现在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实正则不是我想象中的那么难，至少入门还是比较简单。我刚学习了一些比较简单的，谈谈我对正则的理解以及使用心得，希望能帮助大家&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、学习正则的话 ，正则手册必须看的，了解常用的字符含义，这样在学习或看或写的时候，才不会觉得（哇，这什么鬼啊，为什么这么多括号中括号大括号， 这一串串的真是是规则吗?会不会是别人乱写的。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、大致看了一下手册了之后，我觉得应该看一下关于正则教程的视频，图文音并茂，这样才更容易让人理解这是什么东西，然后跟着做一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、看了视频了解简单的正则简单的写法就可以写一下简单的规则了。比如说验证日期、价格、年龄等，这些都是项目比较常用的且简单的正则验证。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后我举一个简单的例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QQ号的验证：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、首先，要写验证的话，就必须了解你验证的这个有什么样子的规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QQ号是大多数人的青春，我相信绝大多数人都比较熟悉，那么它的规则估计并不是所有人都清除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，腾讯刚开始发布QQ号的时候是从1开始的，也就是世界上第一个QQ号是1。但是为了安全等等原因，腾讯收回了4位数及更少的QQ号码，只留下了10000开始的QQ号，&lt;/span&gt;&lt;span&gt;所以腾讯的QQ号最小是10000，最大位置，也就是说只要比10000大的数字都可以。再者，QQ号有了一个最小数，那是不是用QQ号&amp;gt;10000就是QQ号了呢？比如：QQ号&amp;gt;10000。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实不然，因为n个0加上10000+也是大于10000的，比如00010001，但是这个数字不是QQ号。所以第一个数字不能为0，这就是QQ号的所有规则了，是不是很简单。（不好意思，废话多了）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、写规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然我们知道了规则，就是开始写规则了，规则拆开写，三个规则，第一：QQ号必须是数字组成，第二：第一个数字不为0且是一位数，取值范围1-9，第三，QQ号位数至少是五位数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[1-9]：[]表示一个字符的一个范围，1-9表示只能取大于等于1，小于等于9的数字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[0-9]：因为第二个数字开始，数字就可以取值为0了，所以取值0-9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{4，}：{}表示长度，可取两个值，第一个是最小长度(必填，非负数)，第二个是最大长度(选填)，中间用逗号隔开，第二个不填表示无上限。QQ号为5位数，所以第一位后面需要至少有4个数字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后连起来就是[1-9][0-9]{4,}。如果只是验证某一个参数是不是QQ号，就需要规定什么时候开始什么时候结束，不然只要一串字符串里面连起来有符合规则的都会通过。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正则中 ^ 表示开始， $ 表示结束，为了验证某一个参数是不是QQ号，最后规则为： ^[1-9][0-9]{4,}$   ，表示这个参数里面必须以1-9的数字开头，以0-9的数字结尾，否则通不过验证。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后  \d 等价与  [0-9] ，规则也可以写成 ^[1-9]\d{4,}$&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：正则验证十分强大&lt;/strong&gt;，入门简单&lt;/span&gt;，适用于各种语言，多学一点，后面少苦恼一点。勤学苦练，终能成大事，希望各位一起学习、进步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我是刚入门不久的前端工程师，内容写的可能不是那么精简、清楚，我会慢慢改进&lt;/strong&gt;排版以及内容，希望各位多多指点，多多支持，谢谢&lt;/p&gt;
&lt;p&gt;（ps: 如果有刚加入前端这个行业的，比较迷茫的同学，欢迎进群交流，希望不嫌弃的同行或者大佬加群大家一起交流，相信未来会更好&lt;img src=&quot;https://img2018.cnblogs.com/blog/1502000/201902/1502000-20190202165557675-1973463027.png&quot; alt=&quot;&quot;/&gt;，群号：815957915）&lt;/p&gt;
</description>
<pubDate>Sat, 02 Feb 2019 09:02:00 +0000</pubDate>
<dc:creator>快乐又疲惫的程序猿</dc:creator>
<og:description>以前使用正则是不会自己去学或者去了解怎么实现正则的语法的，感觉好难懂的样子，于是拖到现在 其实正则不是我想象中的那么难，至少入门还是比较简单。我刚学习了一些比较简单的，谈谈我对正则的理解以及使用心得，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Simple-and-complex/p/10348762.html</dc:identifier>
</item>
<item>
<title>经典排序算法 — C#版本（中） - K战神</title>
<link>http://www.cnblogs.com/sunchong/p/10322321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunchong/p/10322321.html</guid>
<description>&lt;p&gt;归并排序比较适合大规模得数据排序，借鉴了分治思想。&lt;/p&gt;
&lt;h3&gt;归并排序原理&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201902/406456-20190201082832110-914999952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;自古以来，分久必合合久必分。&lt;/p&gt;
&lt;p&gt;我们可以这样理解归并排序，分-分到不能分为止，然后合并。&lt;/p&gt;
&lt;p&gt;使用递归将问题一点一点分解，最后进行合并。&lt;/p&gt;
&lt;h3&gt;分而治之 （merge_sort）&lt;/h3&gt;
&lt;p&gt;提到递推，我们使用地递推解决问题，首先要分析出递推公式、明确结束条件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;递推公式：

merge_sort(i...n)&lt;/span&gt;=merge( merge_sort(i...j), merge_sort(j+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;...n) )

结束条件：
i&lt;/span&gt;&amp;gt;=n
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 分久必合（merge）&lt;/h3&gt;
&lt;p&gt;将两个有序的数组进行合并，这样整个数组也就是排序好的数组了。&lt;/p&gt;
&lt;p&gt;那么怎么进行合并呢？-- (i...j) 和 (j+1...n) 重新排序后，重新放入原来的数组 (i...n) &lt;/p&gt;
&lt;p&gt;两组数组 &lt;strong&gt;&lt;span&gt;[3, 8, 9, 11]&lt;/span&gt; &lt;/strong&gt;  vs  &lt;strong&gt;&lt;span&gt;[1, 2, 5, 7]&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;两个游标      &lt;strong&gt;&lt;span&gt;蓝色         &lt;/span&gt;&lt;/strong&gt;和       &lt;strong&gt;&lt;span&gt;红色&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; 3&amp;gt;1，1小，1入新数组，红色游标后移一位，继续比较...&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201902/406456-20190201133126109-327181756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;  3&amp;gt;2，2小，2&lt;/strong&gt;入数组，红色游标后移一位&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201902/406456-20190201133640851-2036410973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  3&amp;lt;5，3小，3&lt;/strong&gt;入数组，蓝色游标后移一位&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201902/406456-20190201134051707-182259081.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8&amp;gt;5，5小，5&lt;/strong&gt;入数组，红色游标后移一位&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201902/406456-20190201134210580-1604987453.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8&amp;gt;7，7小，7&lt;/strong&gt;入数组，红色游标后移，右侧数组全部转移完毕&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201902/406456-20190201134306104-1995104282.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当有一组数组全部转移完毕，那么剩下的一组中的全部元素依次转入到新数组中，新数组正式成为一个有顺序的数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201902/406456-20190201134416860-28013919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过以上两点：递推公式和合并思想，我们使用代码实现一下：&lt;/p&gt;
&lt;p&gt;1、如下图：递归方式 进行分解，然后使用合并代码进行合并。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e1697ca5-180b-44ad-bd16-dd9d71f159c9')&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_e1697ca5-180b-44ad-bd16-dd9d71f159c9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e1697ca5-180b-44ad-bd16-dd9d71f159c9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e1697ca5-180b-44ad-bd16-dd9d71f159c9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e1697ca5-180b-44ad-bd16-dd9d71f159c9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;          &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 递归调用
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;a&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;原始数组&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;p&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;分割点&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;r&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;结束位置&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MergrSortInternally(&lt;span&gt;int&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt; p, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束条件&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p &amp;gt;=&lt;span&gt; r)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;切割点&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; q = p + (r - p) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分而治之&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            MergrSortInternally(a, p, q);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             MergrSortInternally(a, q + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, r);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并  A(a, p, q) 和  A(a, q + 1, r)          &lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            Merage(a, p, q, r);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201902/406456-20190202094701914-690791256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、我们再来看看合并逻辑&lt;/p&gt;
&lt;p&gt;     参数：原始数组，开始的地方，切割的地方，结束的地方&lt;/p&gt;
&lt;p&gt;     逻辑：两个切割数组的各自的游标&lt;/p&gt;
&lt;p&gt;               申请同样大小的临时数组&lt;/p&gt;
&lt;p&gt;　　　　 循环比较；小的入临时，游标后移；知道有一个数组空了为止&lt;/p&gt;
&lt;p&gt;                找到剩下不为空的那个数组，将剩余元素入临时&lt;/p&gt;
&lt;p&gt;                将临时数组，找到原始数组的对应为止进行覆盖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7769bce3-4233-438c-93b2-630179848d36')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_7769bce3-4233-438c-93b2-630179848d36&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7769bce3-4233-438c-93b2-630179848d36&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7769bce3-4233-438c-93b2-630179848d36',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7769bce3-4233-438c-93b2-630179848d36&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 合并
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;a&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;原始数组&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;p&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;起始点&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;q&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;切割点&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;r&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;结束点&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Merage(&lt;span&gt;int&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt; p, &lt;span&gt;int&lt;/span&gt; q, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; i 和 j = 两个数组的游标&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; j = q + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 临时数组的游标&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 临时数组&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;[] temp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[r - p + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小入队，直到其中一个空空如也为止&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (i &amp;lt;= q &amp;amp;&amp;amp; j &amp;lt;=&lt;span&gt; r)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (a[i] &amp;lt;=&lt;span&gt; a[j])
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     temp[k] =&lt;span&gt; a[i];
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     ++&lt;span&gt;k;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     ++&lt;span&gt;i;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     temp[k] =&lt;span&gt; a[j];
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     ++&lt;span&gt;k;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     ++&lt;span&gt;j;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到另一个不为空的，找到剩下的元素&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; start =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; end =&lt;span&gt; q;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (j &amp;lt;=&lt;span&gt; r)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 start =&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 end =&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 剩余数组拷贝到临时数组 temp&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (start &amp;lt;=&lt;span&gt; end)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 temp[k++] = a[start++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将temp覆盖到a[p...r]&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= r - p; ++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 a[p + i] =&lt;span&gt; temp[i];
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201902/406456-20190202101324775-849744159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201902/406456-20190202101330986-1660869252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 归并排序性能分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; Q：是不是稳定排序？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; A：是&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于这两组数组   A[p...q] 和   A[q+1...r] 来说&lt;/p&gt;
&lt;p&gt;代码中也是这样实现的，a[i]就是左侧数组，a[j]就是右侧数组，保证相等时左侧优先入队即可。注意 等号位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201902/406456-20190202101919095-1835835204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：是否是原地排序？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; A：当然不是&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为我们在合并代码时候，申请了同样大小的内存空间。&lt;/p&gt;
&lt;p&gt;但是对于这里的归并排序的空间复杂度又是多少呢？&lt;/p&gt;
&lt;p&gt;虽然牵扯到了递归，但是临时变量这里会在一个函数结束后栈会释放，所以&lt;strong&gt;空间复杂度是O(n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：时间复杂度又是多少呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; A：O(n log n)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们对 n 个元素的归并排序时间记作 T(n)，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分解函数分解两个子数组的时间是T(n/2)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合并函数时间复杂度是O(n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;T（1）=C;    n=1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T（n）=2*T（n/2）+ n; n&amp;gt;1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;T(n)  =  2*T(n/2)  +  n&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;         = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;         = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;         = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　  ......&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;　　  = 2^k * T(n/2^k) + k * n&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;T(n) &lt;/strong&gt; = 2^k * T(n/2^k) + k * n&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;当 T(n/2^k) = T（1）=&amp;gt; k = log2 n&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;即：T(n) = Cn + n log2 n  =&amp;gt; O(n log n)&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 02 Feb 2019 08:14:00 +0000</pubDate>
<dc:creator>K战神</dc:creator>
<og:description>归并排序比较适合大规模得数据排序，借鉴了分治思想。 归并排序原理 自古以来，分久必合合久必分。 我们可以这样理解归并排序，分-分到不能分为止，然后合并。 使用递归将问题一点一点分解，最后进行合并。 分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunchong/p/10322321.html</dc:identifier>
</item>
<item>
<title>DFS和BFS讲解及Leetcode刷题小结（2）（JAVA） - AdamLeeXi</title>
<link>http://www.cnblogs.com/handsomelixinan/p/10348610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/handsomelixinan/p/10348610.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一篇文章解决了DFS的问题，这次来解决BFS的问题就简单多了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DFS实现重要依赖于堆栈/递归 ，较为简单的解决了如何遍历所有元素，以及寻求“终点”的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，DFS虽然可以查找到到达路径，但是却找不到最短的路径，针对这一问题，给出了BFS(广度优先遍历)的算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，先给出BFS的基本过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597056/201902/1597056-20190202114742874-1421185014.png&quot; alt=&quot;&quot; width=&quot;341&quot; height=&quot;224&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597056/201902/1597056-20190202114759554-1661196250.png&quot; alt=&quot;&quot; width=&quot;341&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597056/201902/1597056-20190202114825232-412347442.png&quot; alt=&quot;&quot; width=&quot;341&quot; height=&quot;228&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1597056/201902/1597056-20190202114855594-49074478.png&quot; alt=&quot;&quot; width=&quot;341&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与DFS不同的是，这次不再是每个分叉路口一个一个走了，而是全部，同时遍历，直到找到终点，所对应的“层数”便是最短路径所需要的步数，BFS像是在剥洋葱，一层一层的拨开，最后到达终点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如何实现呢？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们利用队列来实现BFS，伪代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; BFS(Node root, Node target) {
    Queue&lt;/span&gt;&amp;lt;Node&amp;gt; queue;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 建立队列&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; step = 0;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 建立行动步数
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; initialize&lt;/span&gt;
&lt;span&gt;    add root to queue;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; BFS&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (queue is not empty) {
        step &lt;/span&gt;= step + 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录此时的队列大小&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; queue.size();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; ++&lt;span&gt;i) { //遍历队列中的元素，并将新元素加入到队列中
            Node cur &lt;/span&gt;=&lt;span&gt; the first node in queue;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; step &lt;span&gt;if&lt;/span&gt;&lt;span&gt; cur is target;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Node next : the neighbors of cur) {
                add next to queue;       //加入查找的方向
            }
            remove the first node from queue;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有找到目标返回-1&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;队列整体由两个循环构成：外层循环查看队列是否为空（为空表示元素已经遍历完毕），内层循环用于对当前节点的遍历，以及加入新节点，这里要注意：内层循环的次数size应为queue.size()赋予，而不能直接使用queue.size()，因为在内循环中会对队列进行操作，从而使得队列的长度不停变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内层循环代表着一层遍历“一层洋葱皮”，所以在外层遍历与内层遍历直接需要加入步数的记录，最后算法结束时对应步数就是最短路径。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面来看几道例题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#1  Number of Islands&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Given a 2d grid map of &lt;code&gt;'1'&lt;/code&gt;s (land) and &lt;code&gt;'0'&lt;/code&gt;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;Input:&lt;/strong&gt;
11110
11010
11000
00000

&lt;strong&gt;Output:&lt;/strong&gt; 1
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;Input:&lt;/strong&gt;
11000
11000
00100
00011

&lt;strong&gt;Output: &lt;/strong&gt;3
&lt;br/&gt;&lt;span&gt;仍然是那道找小岛的题目，下面来用BFS来进行求解：&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; numIslands(&lt;span&gt;char&lt;/span&gt;&lt;span&gt;[][] grid) {
        Queue&lt;/span&gt;&amp;lt;Integer&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();　　　　　　//建立队列
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = 0&lt;span&gt; ;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; grid.length ; i ++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = 0 ; j &amp;lt; grid[0].length ; j ++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(grid[i][j] == '1'&lt;span&gt;)
                {
                    bfs(i,j,queue,grid) ; 　　　　//使用BFS来进行遍历
                    num &lt;/span&gt;++&lt;span&gt; ;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num ;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bfs(&lt;span&gt;int&lt;/span&gt; p , &lt;span&gt;int&lt;/span&gt; q , Queue&amp;lt;Integer&amp;gt; queue,&lt;span&gt;char&lt;/span&gt;&lt;span&gt;[][] grid)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; m =&lt;span&gt; grid.length ;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = grid[0&lt;span&gt;].length ;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; t =&lt;span&gt; Math.max(m,n) ;　　　　　　　　　　//这里要使用一维队列来表示二维的数组，对原来的数组进行重新编码，为了避免译码的错误，&lt;br/&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//　这里求出二维数组行列的最大值
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; w = p*t +&lt;span&gt; q ; //对数组进行编码
        queue.offer(w) ;
        grid[p][q] &lt;/span&gt;= '0'&lt;span&gt; ;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;queue.isEmpty())
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; queue.poll() ;　　　　　　　　　　//由于所需要解决的问题不在于求最短路径，而在于遍历，使用没有记录步数
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = s/&lt;span&gt;t ;　　　　//对行进行译码
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = s%&lt;span&gt;t ;　　　　//对列进行译码
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i + 1 &amp;lt; m &amp;amp;&amp;amp; grid[i+1][j] != '0'&lt;span&gt;)　　　　//上
            {
                queue.offer((i&lt;/span&gt;+1)*t +&lt;span&gt; j);
                grid[i&lt;/span&gt;+1][j] = '0'&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i - 1 &amp;gt;= 0  &amp;amp;&amp;amp; grid[i-1][j] != '0'&lt;span&gt;)　　　　　　//下
            {
                queue.offer((i&lt;/span&gt;-1)*t +&lt;span&gt; j);
                grid[i&lt;/span&gt;-1][j] = '0'&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(j - 1 &amp;gt;= 0  &amp;amp;&amp;amp; grid[i][j-1] != '0'&lt;span&gt;)　　　　　　//左
            {
                queue.offer(i&lt;/span&gt;*t + j-1&lt;span&gt;);
                grid[i][j&lt;/span&gt;-1] = '0'&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(j + 1 &amp;lt; n &amp;amp;&amp;amp; grid[i][j+1] != '0'&lt;span&gt;)　　　　　　//右
            {
                queue.offer(i&lt;/span&gt;*t + j+1&lt;span&gt;);
                grid[i][j&lt;/span&gt;+1] = '0'&lt;span&gt;;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看到在遍历的问题上，BFS相对于DFS并没有什么优势，编写起来反而比较麻烦，因此，在遍历元素的问题上使用DFS比较好&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;#2 Open the Lock&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &lt;code&gt;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'&lt;/code&gt;. The wheels can rotate freely and wrap around: for example we can turn &lt;code&gt;'9'&lt;/code&gt; to be &lt;code&gt;'0'&lt;/code&gt;, or &lt;code&gt;'0'&lt;/code&gt; to be &lt;code&gt;'9'&lt;/code&gt;. Each move consists of turning one wheel one slot.&lt;/p&gt;
&lt;p&gt;The lock initially starts at &lt;code&gt;'0000'&lt;/code&gt;, a string representing the state of the 4 wheels.&lt;/p&gt;
&lt;p&gt;You are given a list of &lt;code&gt;deadends&lt;/code&gt; dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.&lt;/p&gt;
&lt;p&gt;Given a &lt;code&gt;target&lt;/code&gt; representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;Input:&lt;/strong&gt; deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;
&lt;strong&gt;Output:&lt;/strong&gt; 6
&lt;strong&gt;Explanation:&lt;/strong&gt;
A sequence of valid moves would be &quot;0000&quot; -&amp;gt; &quot;1000&quot; -&amp;gt; &quot;1100&quot; -&amp;gt; &quot;1200&quot; -&amp;gt; &quot;1201&quot; -&amp;gt; &quot;1202&quot; -&amp;gt; &quot;0202&quot;.
Note that a sequence like &quot;0000&quot; -&amp;gt; &quot;0001&quot; -&amp;gt; &quot;0002&quot; -&amp;gt; &quot;0102&quot; -&amp;gt; &quot;0202&quot; would be invalid,
because the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;.
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;Input:&lt;/strong&gt; deadends = [&quot;8888&quot;], target = &quot;0009&quot;
&lt;strong&gt;Output:&lt;/strong&gt; 1
&lt;strong&gt;Explanation:&lt;/strong&gt;
We can turn the last wheel in reverse to move from &quot;0000&quot; -&amp;gt; &quot;0009&quot;.
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;Input:&lt;/strong&gt; deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;
&lt;strong&gt;Output:&lt;/strong&gt; -1
&lt;strong&gt;Explanation:&lt;/strong&gt;
We can't reach the target without getting stuck.
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Example 4:&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;Input:&lt;/strong&gt; deadends = [&quot;0000&quot;], target = &quot;8888&quot;
&lt;strong&gt;Output:&lt;/strong&gt; -1
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;The length of &lt;code&gt;deadends&lt;/code&gt; will be in the range &lt;code&gt;[1, 500]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target&lt;/code&gt; will not be in the list &lt;code&gt;deadends&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Every string in &lt;code&gt;deadends&lt;/code&gt; and the string &lt;code&gt;target&lt;/code&gt; will be a string of 4 digits from the 10,000 possibilities &lt;code&gt;'0000'&lt;/code&gt; to &lt;code&gt;'9999'&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 这道问题要求找到最短的搜索路径，显然使用BFS比较好，代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; openLock(String[] deadends, String target) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(target == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt; ;
        Queue&lt;/span&gt;&amp;lt;String&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
        HashSet&lt;/span&gt;&amp;lt;String&amp;gt; set = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;String&amp;gt;&lt;span&gt;(Arrays.asList(deadends)); 　　　　//建立hashset来存储deadends和访问过的节点
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; times = -1&lt;span&gt; ;
        queue.offer(&lt;/span&gt;&quot;0000&quot;&lt;span&gt;) ;　　　　//将初始起点入队
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;queue.isEmpty())　　　　//开始遍历相邻的各个节点
        {
            times &lt;/span&gt;++&lt;span&gt; ;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; queue.size() ;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; t = 0 ; t &amp;lt; size ; t ++&lt;span&gt;)
            {
                String cur &lt;/span&gt;=&lt;span&gt; queue.poll();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(set.contains(cur)) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt; ;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cur.compareTo(target) == 0) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; times;
                set.add(cur) ;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; 4 ; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = -1 ; j &amp;lt; 2 ; j += 2&lt;span&gt;)　　　　//4个数位进行+，- 1运算，共有8个方向
                    {
                        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] temp =&lt;span&gt; cur.toCharArray();
                        temp[i] &lt;/span&gt;= (&lt;span&gt;char&lt;/span&gt;)((temp[i] - '0' + j + 10)%10 + '0'&lt;span&gt;); // 将字符转化为数字
                        queue.offer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(temp));
                    }
                }
            }
                     
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;#3  Perfect Squares&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Given a positive integer &lt;em&gt;n&lt;/em&gt;, find the least number of perfect square numbers (for example, &lt;code&gt;1, 4, 9, 16, ...&lt;/code&gt;) which sum to &lt;em&gt;n&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;Input:&lt;/strong&gt; &lt;em&gt;n&lt;/em&gt; = &lt;code&gt;12&lt;/code&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 3 
&lt;strong&gt;Explanation: &lt;/strong&gt;&lt;code&gt;12 = 4 + 4 + 4.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;Input:&lt;/strong&gt; &lt;em&gt;n&lt;/em&gt; = &lt;code&gt;13&lt;/code&gt;
&lt;strong&gt;Output:&lt;/strong&gt; 2
&lt;strong&gt;Explanation: &lt;/strong&gt;&lt;code&gt;13 = 4 + 9.&lt;/code&gt;&lt;br/&gt;&lt;span&gt;&lt;br/&gt;代码如下：&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; numSquares(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        Queue&lt;/span&gt;&amp;lt;Integer&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
        HashSet&lt;/span&gt;&amp;lt;Integer&amp;gt; set = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; res = 0&lt;span&gt; ;
        queue.offer(&lt;/span&gt;0&lt;span&gt;) ;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;queue.isEmpty())
        {
            res &lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; queue.size();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; size ; i ++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cur =&lt;span&gt; queue.poll() ;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = 1&lt;span&gt; ;
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(cur + j*j &amp;lt;=&lt;span&gt; n)　　　　　　//平方和小于目标数字的都是节点的相邻节点
                {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp = cur + j*&lt;span&gt;j ;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(temp == n) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res ;
                    j &lt;/span&gt;++&lt;span&gt; ;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(set.contains(temp)) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt; ;
                    queue.offer(temp) ;
                    set.add(temp) ;　　　　　　//set用作记录路径
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt; ;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 02 Feb 2019 08:00:00 +0000</pubDate>
<dc:creator>AdamLeeXi</dc:creator>
<og:description>上一篇文章解决了DFS的问题，这次来解决BFS的问题就简单多了 DFS实现重要依赖于堆栈/递归 ，较为简单的解决了如何遍历所有元素，以及寻求“终点”的问题。 但是，DFS虽然可以查找到到达路径，但是却</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/handsomelixinan/p/10348610.html</dc:identifier>
</item>
<item>
<title>装饰模式 - 女屌丝逆袭白富美案例 - 刷书小将</title>
<link>http://www.cnblogs.com/zh1996/p/10348516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zh1996/p/10348516.html</guid>
<description>&lt;p&gt;&lt;strong&gt;接下来用一个女屌丝变白富美的案例，来描述装饰模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、女孩接口&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，无论是女屌丝，还是白女孩、富女孩、美女孩，都是女孩。&lt;/p&gt;
&lt;p&gt;所以定义&lt;span&gt;&lt;strong&gt;女孩接口IGirl&lt;/strong&gt;&lt;/span&gt;如下，&lt;span&gt;&lt;strong&gt;其中show方法，就是女孩来展现自己现在的状态......&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IGirl {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、女屌丝登场&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;女屌丝：BaseGirl&lt;/span&gt;&lt;span&gt;。意思就是最基础、一无所有的女孩（女屌丝）。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;show方法实现了接口，女屌丝目前一无所有，只能说：我是女孩&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseGirl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IGirl {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseGirl() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;我是女孩&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、装饰类RichGirl：变富&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;女孩虽然出身贫困，但是有一颗难得的上进心，她工作努力、团结同事，终于在某公司当上了个小领导，&lt;/p&gt;
&lt;p&gt;从此迈入了小康生活。&lt;/p&gt;
&lt;p&gt;此时，show方法中，女孩骄傲地说：我富....&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RichGirl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IGirl {

    IGirl girl;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RichGirl(IGirl girl) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.girl =&lt;span&gt; girl;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基本功能&lt;/span&gt;
&lt;span&gt;        girl.show();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加装饰&lt;/span&gt;
        System.out.println(&quot;我富&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、装饰类WhiteGirl：变白&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;女孩自从变有钱后，开始慢慢随着主流开始&lt;strong&gt;&lt;span&gt;化妆&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了让自己皮肤变白，女孩买了好多化妆品。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时，show方法中，女孩高兴地说：我白....&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WhiteGirl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IGirl {

    IGirl girl;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WhiteGirl(IGirl girl) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.girl=&lt;span&gt;girl;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基本功能&lt;/span&gt;
&lt;span&gt;        girl.show();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加装饰&lt;/span&gt;
        System.out.println(&quot;我白&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、装饰类BeautifulGirl：变美&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;女孩现在是又白又富，高傲气质也自然而然的流露出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此时的show方法，女孩激动的说：我美...&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时，一个女屌丝不见了，一个白富美诞生了...故事也结束了...&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BeautifulGirl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IGirl {

    IGirl girl;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BeautifulGirl(IGirl girl) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.girl =&lt;span&gt; girl;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基本功能&lt;/span&gt;
&lt;span&gt;        girl.show();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加装饰&lt;/span&gt;
        System.out.println(&quot;我美&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、运行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流程很简单，首先创建一个朴素女孩（&lt;span&gt;&lt;strong&gt;gril对象&lt;/strong&gt;&lt;/span&gt;），她此时show，只会说：我是一个女孩&lt;/p&gt;
&lt;p&gt;经过三个装饰类（白、富、美）依次装饰，此时的女孩（&lt;strong&gt;&lt;span&gt;gril对象&lt;/span&gt;&lt;/strong&gt;），再次show的时候，已经是：我是一个女孩，我白，我富，我美&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建出一个朴素的女孩&lt;/span&gt;
        IGirl girl = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaseGirl();
        girl.show();

        System.out.println(&lt;/span&gt;&quot;\n-----------------------------------\n&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 女孩变白了&lt;/span&gt;
        girl = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WhiteGirl(girl);
        girl.show();

        System.out.println(&lt;/span&gt;&quot;\n-----------------------------------\n&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 女孩变有钱了&lt;/span&gt;
        girl = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RichGirl(girl);
        girl.show();

        System.out.println(&lt;/span&gt;&quot;\n-----------------------------------\n&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 女孩变漂亮了&lt;/span&gt;
        girl = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeautifulGirl(girl);
        girl.show();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;七、总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候，你说人会变的，其实人真的变了。&lt;/p&gt;
&lt;p&gt;每一次被装饰后得到的girl，已经不是以前的girl了。&lt;/p&gt;
&lt;p&gt;变白、换了一个人&lt;/p&gt;
&lt;p&gt;变富、换了一个人&lt;/p&gt;
&lt;p&gt;变美、换了一个人&lt;/p&gt;
&lt;p&gt;此时，我们也发现，每装饰一次，都是产生一个新的对象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;此模式非常类似于我们的字符串，A字符串：abc，如果在A前面装饰上123，那么产生的新字符串就是123abc，而老的abc仍然在内存中等待gc回收。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此这种设计模式缺点：大量创建对象，大量产生无用对象。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 02 Feb 2019 07:25:00 +0000</pubDate>
<dc:creator>刷书小将</dc:creator>
<og:description>接下来用一个女屌丝变白富美的案例，来描述装饰模式。 一、女孩接口 首先，无论是女屌丝，还是白女孩、富女孩、美女孩，都是女孩。 所以定义女孩接口IGirl如下，其中show方法，就是女孩来展现自己现在的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zh1996/p/10348516.html</dc:identifier>
</item>
<item>
<title>过年了，给亲朋好友解释「啥是程序员」 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/10348397.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/10348397.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;一年一度的春节又到了，作为程序员的你是怎么告诉亲朋好友自己日常到底是做什么工作的呢？&lt;/p&gt;
&lt;p&gt;程序员是一个&lt;strong&gt;新兴&lt;/strong&gt;的职业，我在上大学以前不了解程序员到底是做什么的，对编程语言也一窍不通，也不关心玩过的「游戏」和天天逛的「网站」究竟是怎么来的。&lt;/p&gt;
&lt;p&gt;当年加了计算机科学与技术专业的&lt;strong&gt;新生群&lt;/strong&gt;，听着师兄和师姐们在聊天，其中就聊到了「程序员」这份职业。当时脑海里第一反应想象的&lt;strong&gt;竟是&lt;/strong&gt;「复印机、打印机等办公」乱七八糟的东西&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb7941dc0c0?w=399&amp;amp;h=499&amp;amp;f=png&amp;amp;s=121439&quot; alt=&quot;复印机、打印机&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;外行人看程序员&quot;&gt;外行人看程序员&lt;/h2&gt;
&lt;p&gt;有的「初高中」同学知道我读了计算机专业，于是过来问我：计算机专业应该会组装电脑的吧，我想组装一台新电脑，能不能帮帮忙给点意见，比如电脑&lt;strong&gt;配置清单&lt;/strong&gt;什么的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb7936b38ae?w=623&amp;amp;h=512&amp;amp;f=png&amp;amp;s=298212&quot; alt=&quot;电脑配置清单&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在我大学期间我爸希望我&lt;strong&gt;多考&lt;/strong&gt;一些证书，比如有关「电气和会计」之类证书。他认为：只要证书多，那找工作肯定不成问题，工资也会比没有证书的人要高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb79281467f?w=596&amp;amp;h=501&amp;amp;f=png&amp;amp;s=214574&quot; alt=&quot;N多证书&quot;/&gt;&lt;/p&gt;
&lt;p&gt;临毕业了，跟同学出去吃宵夜，我当时正忙着找工作，同学也多问了一句：“你在找什么工作啊”。于是我说：”就IT呗，程序员了解不“。他说：”不懂啊，你&lt;strong&gt;会不会盗QQ、做游戏外挂&lt;/strong&gt;那些东西的啊？“。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb79551c567?w=596&amp;amp;h=501&amp;amp;f=png&amp;amp;s=117334&quot; alt=&quot;盗QQ&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前几天跟亲戚去吃饭，得知我年后要离开广州去杭州做软件相关的工作，几杯酒过后，深长意味告诉我：“还是做&lt;strong&gt;「行政」相关的工作有前途&lt;/strong&gt;，走那么远做软件有啥用啊，我来给你介绍去xxx工作”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb795b53bca?w=640&amp;amp;h=640&amp;amp;f=gif&amp;amp;s=101860&quot; alt=&quot;啥才是好工作！&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我这里想表达的是：老一辈的人大多不太了解互联网行业，认为行政、银行、老师、医生这些行业才是“正道”。我对这些行业都持有敬畏之心，并没有讽刺的意思。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;程序员喜欢自嘲&quot;&gt;程序员喜欢自嘲&lt;/h2&gt;
&lt;p&gt;外行人对程序员的误解，也有可能只是看到网上有很多关于程序员的言论，&lt;strong&gt;真以为&lt;/strong&gt;「大多数」程序员都那样。&lt;/p&gt;
&lt;p&gt;比如说程序员都爱穿格子衫：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb7942514f5?w=596&amp;amp;h=501&amp;amp;f=png&amp;amp;s=144618&quot; alt=&quot;程序员最爱格子衫&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序员没有女朋友：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb80e155985?w=440&amp;amp;h=485&amp;amp;f=gif&amp;amp;s=103527&quot; alt=&quot;程序员女朋友&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序员人傻话少死得快：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb8112abd00?w=240&amp;amp;h=240&amp;amp;f=gif&amp;amp;s=25124&quot; alt=&quot;人傻话少死得快&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实很多的言论都是程序员们在闲暇之余的时候「&lt;strong&gt;自嘲&lt;/strong&gt;」罢了。大多数程序员跟其他行业的人&lt;strong&gt;都一样&lt;/strong&gt;，并没有像网上说得那么玄乎。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;程序员在网上一般称自己为「码农」(编码的农民)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;程序员加班&quot;&gt;程序员加班&lt;/h2&gt;
&lt;p&gt;暂且不管关于程序员其他的言论，但对于互联网行业来说，加班的确是「&lt;strong&gt;普遍&lt;/strong&gt;」存在的现象，就在前阵子，「有赞」在年会上公开宣布996工作制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb81744404f?w=660&amp;amp;h=452&amp;amp;f=jpeg&amp;amp;s=57745&quot; alt=&quot;「有赞」在年会上公开宣布996工作制&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有人可能不知道996是什么意思，这里我解释一下：从早上9点工作至晚上9点，一周上六天班。简称996&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我在秋招跑了几个广州游戏公司的宣讲会，大多在宣讲会上明确公司需要「&lt;strong&gt;加班&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb819559fd4?w=654&amp;amp;h=649&amp;amp;f=gif&amp;amp;s=53750&quot; alt=&quot;经验都是加班出来的&quot;/&gt;&lt;/p&gt;
&lt;p&gt;「苏宁」之前也闹出一事&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb871712d76?w=442&amp;amp;h=496&amp;amp;f=png&amp;amp;s=37100&quot;/&gt;&lt;/p&gt;
&lt;p&gt;「华为」的狼性文化也是家喻户晓的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb83a9c30f6?w=442&amp;amp;h=496&amp;amp;f=png&amp;amp;s=143324&quot; alt=&quot;狼性文化&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;啥是编程语言&quot;&gt;啥是编程语言&lt;/h2&gt;
&lt;p&gt;基本大家能想到程序员能做的事，而程序员们几乎都不会&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb880c9b46b?w=681&amp;amp;h=582&amp;amp;f=png&amp;amp;s=129718&quot; alt=&quot;程序员要你有何用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个程序员都会有一门自己拿手的&lt;strong&gt;编程语言&lt;/strong&gt;，有的时候一门编程语言可以对应不同的「岗位」。(比如说，Java程序员、PHP程序员)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb885c0af9e?w=350&amp;amp;h=350&amp;amp;f=jpeg&amp;amp;s=27880&quot; alt=&quot;一大堆编程语言&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序员每天都是跟「计算机」打交道，让计算机干什么，计算机就会去干什么，很是听话&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb89feac5ce?w=399&amp;amp;h=499&amp;amp;f=png&amp;amp;s=45820&quot; alt=&quot;让计算机干什么，计算机就会去干什么&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那计算机咋能听懂程序员让它去干啥呀。有点计算机基础的同学可能会知道，计算机只认「&lt;strong&gt;二进制&lt;/strong&gt;」&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb8a0408a08?w=399&amp;amp;h=499&amp;amp;f=png&amp;amp;s=167379&quot; alt=&quot;计算机只认二进制&quot;/&gt;&lt;/p&gt;
&lt;p&gt;「二进制」：逢二进一。「十进制」：逢十进一&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb8b80b303f?w=492&amp;amp;h=499&amp;amp;f=png&amp;amp;s=24903&quot; alt=&quot;「二进制」：逢二进一&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里，大家可能都看不懂了。没事，我们继续往下看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb8c92cc9d3?w=492&amp;amp;h=499&amp;amp;f=png&amp;amp;s=132468&quot; alt=&quot;看不懂&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序员也是人，人与人的交流，「常用的语言」有阿拉伯语、汉语、英语、法语、俄语和西班牙语等，而不是啥「二进制」的东西。为了&lt;strong&gt;方便&lt;/strong&gt;，聪明的「程序员」企图让计算机去读懂「自然语言」。(能够让计算机去读懂阿拉伯语、汉语、英语、法语、俄语和西班牙语等这些语言)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb8e8188dea?w=555&amp;amp;h=497&amp;amp;f=png&amp;amp;s=47419&quot; alt=&quot;聪明的「程序员」企图让计算机去读懂「自然语言」&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以程序员们就搞出了一个「编译器」，编译器说白了就是能将这些「自然语言」&lt;strong&gt;翻译&lt;/strong&gt;成二进制，让计算机读得懂！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb8fb4d009e?w=717&amp;amp;h=496&amp;amp;f=png&amp;amp;s=34551&quot; alt=&quot;将自然语言翻译成二进制&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在计算机世界里，对任何事物都不含糊，说一就是一，说二就是二。想要让「自然语言」能够&lt;strong&gt;准确地&lt;/strong&gt;翻译成二进制，就必须定下相应的「&lt;strong&gt;规则&lt;/strong&gt;」。而使用不同的「规则」，就出现了不同的编程语言。因为大多数编程语言都是「&lt;strong&gt;外国人&lt;/strong&gt;」发明的，并且由于英语的「&lt;strong&gt;广泛性&lt;/strong&gt;」和「&lt;strong&gt;易用性&lt;/strong&gt;」。所以，绝大多数的编程语言都由「&lt;strong&gt;英文&lt;/strong&gt;」组成。&lt;/p&gt;
&lt;p&gt;(以下就是各种常见的编程语言，由于「&lt;strong&gt;规则&lt;/strong&gt;」不同，所以看起来都不一样。但所做的事都是相同的)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
print_r('点个好看、转发吧！');
var_dump('点个好看、转发吧！');
NSLog(@&quot;点个好看、转发吧！&quot;);
System.out.println(&quot;点个好看、转发吧！&quot;);
console.log(&quot;点个好看、转发吧！&quot;);
print(&quot;点个好看、转发吧！&quot;);
printf(&quot;点个好看、转发吧！&quot;);
cout &amp;lt;&amp;lt; &quot;点个好看、转发吧！&quot; &amp;lt;&amp;lt; endl;
Console.WriteLine(&quot;点个好看、转发吧！&quot;);
fmt.Println(&quot;点个好看、转发吧！&quot;);
Response.Write(&quot;点个好看、转发吧！&quot;);
alert(&quot;点个好看、转发吧！&quot;)
echo &quot;点个好看、转发吧！&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解释程序员干啥活&quot;&gt;解释程序员干啥活&lt;/h2&gt;
&lt;p&gt;别人问到我是做什么的，我往往会说“你平时用过的「微信」，「百度」这些软件啊，网站啊就是我们程序员做的”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb90b0305ba?w=399&amp;amp;h=499&amp;amp;f=png&amp;amp;s=75448&quot; alt=&quot;微信等有名软件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(一般到这里就不会继续往下问细节了，但还是遇到过继续问究竟是怎么做的)&lt;/p&gt;
&lt;p&gt;接下来，为了继续演示，我们可以掏出手机，打开微信：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb90dc24ef8?w=399&amp;amp;h=499&amp;amp;f=png&amp;amp;s=69179&quot; alt=&quot;掏出手机，打开微信&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“我们都是玩微信的人，要进入微信先得有个账户，所以要先注册“&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb9122da161?w=828&amp;amp;h=978&amp;amp;f=jpeg&amp;amp;s=91092&quot; alt=&quot;微信注册页面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“注册实际上就是把你的账号和密码「&lt;strong&gt;保存&lt;/strong&gt;」起来”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb91c41682b?w=694&amp;amp;h=509&amp;amp;f=png&amp;amp;s=27274&quot; alt=&quot;账号和密码「保存」起来&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“如果你注册成功了，那&lt;del&gt;小本本&lt;/del&gt;「数据库」就有你的账号和密码了。等你登录的时候，就去&lt;del&gt;小本本&lt;/del&gt;「数据库」查一下你输入的账号和密码是否&lt;strong&gt;匹配&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb92ec898b6?w=752&amp;amp;h=545&amp;amp;f=png&amp;amp;s=74112&quot; alt=&quot;登录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“看到这里，有没有觉得「程序员」真是容易当，不就把输入的数据记录下小本本，等用到的时候再查一下而已嘛。其实不然，就好比微信的注册页面，拿IOS系统来说，从&lt;code&gt;IOS 6&lt;/code&gt; 到现在的&lt;code&gt;IOS 12&lt;/code&gt;已经有6个版本了。Iphone手机屏幕的尺寸也一直在变，从&lt;code&gt;3.5&lt;/code&gt;英寸到现在的&lt;code&gt;6.5&lt;/code&gt;英寸。微信团队需要对不同的「版本」，不同的「屏幕大小」进行&lt;strong&gt;兼容&lt;/strong&gt;，让iPhone4s还是iPhoneXS Max都能用上微信。(起码在不同的手机上，看到的注册功能都是完整的，而不是东一块西一块不整齐的)”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb9497c0a4a?w=610&amp;amp;h=465&amp;amp;f=png&amp;amp;s=45683&quot; alt=&quot;兼容问题&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“还比如说，&lt;del&gt;小本本&lt;/del&gt;「数据库」记下的密码不能是你输入的「原始密码」。举个例子：某一天，一个在微信团队的小伙子拿到了存放账号和密码的&lt;del&gt;小本本&lt;/del&gt;「数据库」，把&lt;del&gt;小本本&lt;/del&gt;「数据库」的内容给&lt;strong&gt;公开&lt;/strong&gt;了。(或者说一个黑客把微信给攻破了，然后公开&lt;del&gt;小本本&lt;/del&gt;「数据库」)，&lt;strong&gt;那岂不是谁都可以上我的微信号了&lt;/strong&gt;？”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb93460fd74?w=717&amp;amp;h=600&amp;amp;f=png&amp;amp;s=137332&quot; alt=&quot;公开小本本的内容&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“程序员们当然可以考虑到这点，他们会这样做，将你输入的密码进行「&lt;strong&gt;加密&lt;/strong&gt;」存到&lt;del&gt;小本本&lt;/del&gt;「数据库」中。&lt;strong&gt;无论是谁&lt;/strong&gt;，拿到加密后的密码，都&lt;strong&gt;不能「反推」&lt;/strong&gt;你原始输入的密码。”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb96df3cd0d?w=543&amp;amp;h=539&amp;amp;f=png&amp;amp;s=36274&quot; alt=&quot;密码加密&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“所以，每次比对的都是加密后的密码”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb953950874?w=490&amp;amp;h=503&amp;amp;f=png&amp;amp;s=35939&quot; alt=&quot;比对的是加密后的密码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“当然啦，程序员考虑的远远不止这些。不管怎么样，每个程序员都希望自己写的东西「&lt;strong&gt;简单易用，受人喜欢&lt;/strong&gt;」”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb9726dc218?w=637&amp;amp;h=517&amp;amp;f=png&amp;amp;s=29474&quot; alt=&quot;其实我是一个软件工程师&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;文章首发公众号&lt;strong&gt;Java3y&lt;/strong&gt;：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247484732&amp;amp;idx=1&amp;amp;sn=2f478a802024b648a2814ff2bd77c6f9&amp;amp;chksm=ebd7443ddca0cd2bb28bf6f923a6d96a54b491790bfa18d98dea67c4172b2a0bc36d29ce89d1&amp;amp;token=1676899695&amp;amp;lang=zh_CN#rd&quot;&gt;过年了，给亲朋好友解释「啥是程序员」&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;乐于输出&lt;strong&gt;干货&lt;/strong&gt;的Java技术公众号：Java3y。公众号内有200多篇&lt;strong&gt;原创&lt;/strong&gt;技术文章、海量视频资源、精美脑图，不妨来&lt;strong&gt;关注&lt;/strong&gt;一下！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb97440ad09?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=21338&quot; alt=&quot;帅的人都关注了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;觉得我的文章写得不错，不妨点一下&lt;strong&gt;赞&lt;/strong&gt;！&lt;/p&gt;
</description>
<pubDate>Sat, 02 Feb 2019 06:30:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<og:description>前言 一年一度的春节又到了，作为程序员的你是怎么告诉亲朋好友自己日常到底是做什么工作的呢？ 程序员是一个 新兴 的职业，我在上大学以前不了解程序员到底是做什么的，对编程语言也一窍不通，也不关心玩过的「</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/10348397.html</dc:identifier>
</item>
</channel>
</rss>