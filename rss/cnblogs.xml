<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core 3.x 中间件流程与路由体系 - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/12561571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/12561571.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/986268/202003/986268-20200319201256617-2055828548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ASP.NET Core 中间件的配置方法可以分为以上三种，对应的Helper方法分别是：Run(), Use(), Map()。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Run()&lt;/strong&gt;，使用Run调用中间件的时候，会直接返回一个响应，所以后续的中间件将不会被执行了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use()&lt;/strong&gt;，它会对请求做一些工作或处理，例如添加一些请求的上下文数据，有时候甚至什么也不做，直接把请求交给下一个中间件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Map()&lt;/strong&gt;，它会把请求重新路由到其它的中间件路径上去。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际中呢，Use()这个helper方法用的最多。&lt;/p&gt;

&lt;h2&gt;Run()：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/986268/202003/986268-20200319201901325-718367745.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这是一个使用Run方法调用的中间件，Run方法会终止整个中间件管道，它应该返回某种类型的响应。&lt;/p&gt;

&lt;h2&gt;Use():&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/986268/202003/986268-20200319202235860-376495783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; Use看起来和Run差不多，但是多了一个next参数。next可以用来调用请求管道中的下一个中间件。而当前的中间件也可以自己返回响应，这就忽略掉了next调用。&lt;/p&gt;
&lt;p&gt;在next调用之前，我们可以写一些请求进来的逻辑，而在next调用之后，就相当于返回响应了，这时候也可以写一些逻辑。&lt;/p&gt;
&lt;p&gt;在本例中，我们下面还使用了Run方法注册了另一个中间件。因为中间件会按照它们注册的顺序进行调用，所以在第一个Use方法里执行next.Invoke()的时候，就会执行下面Run所调用的中间件。&lt;/p&gt;

&lt;h2&gt;Map()：&lt;/h2&gt;
&lt;h2&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/986268/202003/986268-20200319202959157-453700132.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;

&lt;p&gt; Map方法可以把请求路由到其它的中间件上面。&lt;/p&gt;
&lt;p&gt;在这里，如果请求的路径以/jump结尾，那么它所对应的handler方法，也就是HereIAm方法就会被调用，并返回一个响应。&lt;/p&gt;
&lt;p&gt;而如果请求的路径不是以/jump结尾，那么HereIAm方法和里面的中间件就不会被调用。&lt;/p&gt;

&lt;h2&gt;中间件Class&lt;/h2&gt;
&lt;p&gt;上面的例子，我都是使用的inline写法的中间件。&lt;/p&gt;
&lt;p&gt;而实际上，中间件通常是自成一个类。中间件的类需要类似这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/986268/202003/986268-20200319203618816-665073181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 自定义的中间件类需要由这几部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接受一个RequestDelegate类型的参数next的构造函数。&lt;/li&gt;
&lt;li&gt;按约定，还需要定义一个叫做Invoke的方法。该方法里会包含主要的业务逻辑，并且它会被请求管道所执行。Invoke方法可以忽略里面的_next调用，并返回一个响应；也可以调用_next.Invoke()把请求发送到管道的下一站。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/986268/202003/986268-20200328072214639-430639505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/986268/202003/986268-20200328072230763-725253256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;ASP.NET Core 3.x 使用了一套叫做 Endpoint Routing 的路由系统。这套路由系统在ASP.NET Core 2.2的时候就已经露面了。&lt;/p&gt;
&lt;p&gt;这套Endpoint Routing路由系统提供了更强大的功能和灵活性，以便能更好的处理请求。&lt;/p&gt;


&lt;p&gt;我们先回顾一下早期版本的ASP.NET Core的路由系统：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/986268/202003/986268-20200324195406509-256750359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;在早期的ASP.NET Core框架里，HTTP请求进入中间件管道，在管道的结尾处，有一个Router中间件，也就是路由中间件。这个路由中间件会把HTTP请求和路由数据发送给MVC的一个组件，它叫做MVC Router Handler。&lt;/p&gt;
&lt;p&gt;这个MVC 路由 Handler就会使用这些路由数据来决定哪个Controller的Action方法应该来负责处理这个请求。&lt;/p&gt;
&lt;p&gt;然后 Router中间件就会执行被选中的Action方法，并生成响应，而这个响应就会顺着中间件的管道原路返回。&lt;/p&gt;

&lt;h2&gt;问题出在哪？&lt;/h2&gt;
&lt;p&gt;为什么早期的这套路由系统被抛弃了？它有什么问题？&lt;/p&gt;
&lt;p&gt;第一个问题就是，在被MVC处理之前，其它的中间件不知道最后哪个Action方法会被选中来处理这个请求。这对像Authorization（授权），Cors这样的中间件会造成很大的困扰，因为他们不能提前知道该请求会被送往哪里。&lt;/p&gt;
&lt;p&gt;第二个问题就是，这套流程会把MVC和路由的职责紧密的耦合在一起，而实际MVC的本职工作应该仅仅就是生成响应。&lt;/p&gt;


&lt;p&gt;Endpoint routing 路由系统，它把MVC的路由功能抽象剥离出来，并放置到中间件管道里，从而解决了早期ASP.NET Core路由系统的那两个问题。&lt;/p&gt;
&lt;p&gt;而在Endpoint Routing 路由系统里，其实一共有两个中间件，它们的名称有点容易混淆，但是你只要记住他们的职责即可：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;Endpoint Routing 中间件&lt;/strong&gt;。它决定了在程序中注册的哪个Endpoint应该用来处理请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Endpoint&lt;/strong&gt; 中间件。它是用来执行选中的Endpoint，从而让其生成响应的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，Endpoint Routing的流程图大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/986268/202003/986268-20200324201335181-120213243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在这里，Endpoint Routing 中间件会分析进来的请求，并把它和在程序中注册的Endpoints进行比较。它会使用这些 Endpoints 上面的元数据来决定哪个是处理该请求的最佳人选。然后，这个选中的Endpoint 就会被赋给请求的对象，而其它后续的中间件就可以根据这个选中的Endpoint，来做一些自己的决策。在所有的中间件都执行完之后，这个被选中的Endpoint最终将被 Endpoint中间件所执行，而与之关联的Action方法就会被执行。&lt;/p&gt;


&lt;p&gt;Endpoint是这样的一些类，这些类包含一个请求的委托（Request Delegate）和其它的一些元数据，使用这些东西，Endpoint类可以生成一个响应。&lt;/p&gt;
&lt;p&gt;而在MVC的上下文中，这个请求委托就是一个包装类，它包装了一个方法，这个方法可以实例化一个Controller并执行选中的Action方法。&lt;/p&gt;
&lt;p&gt;Endpoint还包含元数据，这些元数据用来决定他们的请求委托是否应该用于当前的请求，还是另有其它用途。&lt;/p&gt;
&lt;p&gt;说起来可能有点迷糊，一会我们看看源码。&lt;/p&gt;


&lt;p&gt;之前我们见过，ASP.NET Core里面的Startup.cs里面有两个方法，分别是ConfigureServices()和Configure()，它们的职责就是注册应用的一些服务和构建中间件请求管道。&lt;/p&gt;
&lt;p&gt;而Startup.cs同时也是应用的路由以及Endpoint作为其它步骤的一分部进行注册的地方。&lt;/p&gt;
&lt;p&gt;看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/986268/202003/986268-20200325194858076-521941481.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 在ASP.NET Core应用程序启动的时候，一个叫做ControllerActionEndpointDataSource的类作为应用程序级别的服务被创建了。&lt;/p&gt;
&lt;p&gt;这个类里面有一个叫做CreateEndpoints()的方法，它会获取所有Controller的Action方法。&lt;/p&gt;
&lt;p&gt;然后针对每个Action方法，它会创建一个Endpoint实例。这些Endpoint实例就是包装了Controller和Action方法的执行的请求委托（Request Delegate）。&lt;/p&gt;

&lt;p&gt;ControllerActionEndpointDataSource里面包存储着在应用程序里注册的路由模板。&lt;/p&gt;
&lt;p&gt;而针对每个Endpoint，它要么与某个按约定的路由模板相关联，要么与某个Controller Action上的Attribute路由信息相关联。而这些路由在稍后就会被用来将Endpoint与进来的请求进行匹配。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/986268/202003/986268-20200325201645596-1615687171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;App启动那部分就不说了。&lt;/p&gt;
&lt;p&gt;第一个HTTP请求进来的时候，Endpoint Routing中间件就会把请求映射到一个Endpoint上。它会使用之App启动时创建好的EndpointDataSource，来遍历查找所有可用的Endpoint，并检查和它关联的路由以及元数据，来找到最匹配的Endpoint。&lt;/p&gt;
&lt;p&gt;一旦某个Endpoint实例被选中，它就会被附加在请求的对象上，这样它就可以被后续的中间件所使用了。&lt;/p&gt;
&lt;p&gt;最后在管道的尽头，当 Endpoint中间件运行的时候，它就会执行Endpoint所关联的请求委托。这个请求委托就会触发和实例化选中的Controller和Action方法，并产生响应。最后响应再从中间件管道原路返回。&lt;/p&gt;

</description>
<pubDate>Fri, 27 Mar 2020 23:24:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<og:description>中间件分类 ASP.NET Core 中间件的配置方法可以分为以上三种，对应的Helper方法分别是：Run(), Use(), Map()。 Run()，使用Run调用中间件的时候，会直接返回一个响</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cgzl/p/12561571.html</dc:identifier>
</item>
<item>
<title>identityserver4源码解析_3_认证接口 - holdengong</title>
<link>http://www.cnblogs.com/holdengong/p/12585466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/holdengong/p/12585466.html</guid>
<description>&lt;h2 id=&quot;五种认证方式&quot;&gt;五种认证方式&lt;/h2&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Authorization Code 授权码模式&lt;/strong&gt;：认证服务返回授权码，后端用clientid和密钥向认证服务证明身份，使用授权码换取id token 和/或 access token。本模式的好处是由后端请求token，不会将敏感信息暴露在浏览器。本模式允许使用refreshToken去维持长时间的登录状态。使用此模式的客户端必须有后端参与，能够保障客户端密钥的安全性。此模式从authorization接口获取授权码，从token接口获取令牌。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Implict 简化模式&lt;/strong&gt;：校验跳转URI验证客户端身份之后，直接发放token。通常用于纯客户端应用，如单页应用javascript客户端。因为没有后端参与，密钥存放在前端是不安全的。由于安全校验较宽松，本模式不允许使用refreshToken来长时间维持登录状态。本模式的所有token从authorization接口获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Hybrid 混合流程&lt;/strong&gt;：混合流程顾名思义组合使用了授权码模式+简化模式。前端请求授权服务器返回授权码+id_token，这样前端立刻可以使用用户的基本信息；后续请求后端使用授权码+客户端密钥获取access_token。本模式能够使用refreshToken来长时间维持登录状态。使用本模式必须有后端参与保证客户端密钥的安全性。混合模式极少使用，除非你的确需要使用它的某些特性（如一次请求获取授权码和用户资料），一般最常见的还是授权码模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Resource Owner Password Credential 用户名密码模式&lt;/strong&gt;：一般用于无用户交互场景，或者第三方对接（如对接微信登录，实际登录界面就变成了微信的界面，如果不希望让客户扫了微信之后再跑你们系统登录一遍，就可以在后端用此模式静默登录接上自家的sso即可）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Client Credential 客户端密钥模式&lt;/strong&gt;：仅需要约定密钥，仅用于完全信任的内部系统&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;认证方式特点对比&quot;&gt;认证方式特点对比&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特点&lt;/th&gt;
&lt;th&gt;授权码模式&lt;/th&gt;
&lt;th&gt;简化模式&lt;/th&gt;
&lt;th&gt;混合模式&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;所有token从Authorization接口返回&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;所有token从Token接口返回&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;所有tokens不暴露在浏览器&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;能够验证客户端密钥&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;能够使用刷新令牌&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;仅需一次请求&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;大部分请求由后端进行&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;可变&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;支持返回类型对比&quot;&gt;支持返回类型对比&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;返回类型&lt;/th&gt;
&lt;th&gt;认证模式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;code&lt;/td&gt;
&lt;td&gt;Authorization Code Flow&lt;/td&gt;
&lt;td&gt;仅返回授权码&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;id_token&lt;/td&gt;
&lt;td&gt;Implicit Flow&lt;/td&gt;
&lt;td&gt;返回身份令牌&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;id_token token&lt;/td&gt;
&lt;td&gt;Implicit Flow&lt;/td&gt;
&lt;td&gt;返回身份令牌、通行令牌&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;code id_token&lt;/td&gt;
&lt;td&gt;Hybrid Flow&lt;/td&gt;
&lt;td&gt;返回授权码、身份令牌&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;code token&lt;/td&gt;
&lt;td&gt;Hybrid Flow&lt;/td&gt;
&lt;td&gt;返回授权码、通行令牌&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;code id_token token&lt;/td&gt;
&lt;td&gt;Hybrid Flow&lt;/td&gt;
&lt;td&gt;返回授权码、身份令牌、通行令牌&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;授权码模式解析&quot;&gt;授权码模式解析&lt;/h2&gt;
&lt;p&gt;相对来说，授权码模式还是用的最多的，我们详细解读一下本模式的协议内容。&lt;/p&gt;
&lt;h3 id=&quot;授权时序图&quot;&gt;授权时序图&lt;/h3&gt;
&lt;p&gt;sequenceDiagram 用户-&amp;gt;&amp;gt;客户端: 请求受保护资源 客户端-&amp;gt;&amp;gt;认证服务: 准备入参，发起认证请求 认证服务-&amp;gt;&amp;gt;认证服务: 认证用户 认证服务-&amp;gt;&amp;gt;用户: 是否同意授权 认证服务-&amp;gt;&amp;gt;客户端: 发放授权码（前端进行） 客户端-&amp;gt;&amp;gt;认证服务: 使用授权码请求token（后端进行） 认证服务-&amp;gt;&amp;gt;认证服务: 校验客户端密钥，校验授权码 认证服务-&amp;gt;&amp;gt;客户端: 发放身份令牌、通行令牌（后端进行） 客户端-&amp;gt;&amp;gt;客户端: 校验身份令牌，获取用户标识&lt;/p&gt;
&lt;h3 id=&quot;认证请求&quot;&gt;认证请求&lt;/h3&gt;
&lt;p&gt;认证接口必须同时支持GET和POST两种请求方式。如果使用GET方法，客户端必须使用URI Query传递参数，如果使用POST方法，客户端必须使用Form传递参数。&lt;/p&gt;
&lt;h4 id=&quot;参数定义&quot;&gt;参数定义&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;scope&lt;/strong&gt;：授权范围，必填。必须包含openid。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;response_type&lt;/strong&gt;：返回类型，必填。定义了认证服务返回哪些参数。对于授权码模式，本参数只能是code。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;client_id&lt;/strong&gt;：客户端id，必填。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;redirect_uri&lt;/strong&gt;：跳转地址，必填。授权码生成之后，认证服务会带着授权码和其他参数回跳到此地址。此地址要求使用https。如果使用http，则客户端类型必须是confidential。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;state&lt;/strong&gt;：状态字段，推荐填写。一般用于客户端与认证服务比对此字段，来防跨站伪造攻击，同时state也可以存放状态信息，如发起认证时的页面地址，用于认证完成后回到原始页面。&lt;/li&gt;
&lt;li&gt;其他：略。上面五个是和OAuth2.0一样的参数，oidc还定义了一些扩展参数，用的很少，不是很懂，感兴趣的自己去看协议。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;请求报文示例&quot;&gt;请求报文示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;HTTP/1.1 302 Found
  Location: https://server.example.com/authorize?
    response_type=code
    &amp;amp;scope=openid%20profile%20email
    &amp;amp;client_id=s6BhdRkqt3
    &amp;amp;state=af0ifjsldkj
    &amp;amp;redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;认证请求校验&quot;&gt;认证请求校验&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;必填校验&lt;/li&gt;
&lt;li&gt;response_type必须为code&lt;/li&gt;
&lt;li&gt;scope必填，必须包含openid&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;认证终端用户&quot;&gt;认证终端用户&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;下面两种情况认证服务必须认证用户
&lt;ul&gt;&lt;li&gt;用户尚未认证&lt;/li&gt;
&lt;li&gt;认证请求包含参数prompt=login，即使用户已经认证过也需要重新认证&lt;/li&gt;
&lt;li&gt;认证请求包含参数prompt=none，然后用户尚未被认证，则需要返回错误信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;认证服务必须想办法防止过程中的跨站伪造攻击和点击劫持攻击。&lt;/p&gt;
&lt;h4 id=&quot;获取终端用户授权同意&quot;&gt;获取终端用户授权/同意&lt;/h4&gt;
&lt;p&gt;终端用户通过认证之后，认证服务必须与终端用户交互，询问用户是否同意对客户端的授权。&lt;/p&gt;
&lt;h3 id=&quot;认证响应&quot;&gt;认证响应&lt;/h3&gt;
&lt;h4 id=&quot;成功响应&quot;&gt;成功响应&lt;/h4&gt;
&lt;p&gt;使用 application/x-www-form-urlencoded格式返回结果&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt; HTTP/1.1 302 Found
  Location: https://client.example.org/cb?
    code=SplxlOBeZQQYbYS6WxSbIA
    &amp;amp;state=af0ifjsldkj
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;失败响应&quot;&gt;失败响应&lt;/h4&gt;
&lt;p&gt;错误代码包括这些&lt;br/&gt;oauth2.0定义的响应代码&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;invalid_request：非法请求，未提供必填参数，参数非法等情况&lt;/li&gt;
&lt;li&gt;unauthorized_client：客户端未授权&lt;/li&gt;
&lt;li&gt;access_denied：用户无权限&lt;/li&gt;
&lt;li&gt;unsupported_response_type&lt;/li&gt;
&lt;li&gt;invalid_scope：非法的scope参数&lt;/li&gt;
&lt;li&gt;server_error&lt;/li&gt;
&lt;li&gt;temporarily_unavailable&lt;br/&gt;另外oidc还扩展了一些响应代码，不常见，略&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;  HTTP/1.1 302 Found
  Location: https://client.example.org/cb?
    error=invalid_request
    &amp;amp;error_description=
      Unsupported%20response_type%20value
    &amp;amp;state=af0ifjsldkj
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;客户端校验授权码&quot;&gt;客户端校验授权码&lt;/h3&gt;
&lt;p&gt;协议规定客户端必须校验授权码的正确性&lt;/p&gt;

&lt;p&gt;从AuthorizeEndpoint的ProcessAsync方法作为入口开始认证接口的源码解析。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;判断请求方式是GET还是POST，获取入参，如果是其他请求方式415状态码&lt;/li&gt;
&lt;li&gt;从session中获取user&lt;/li&gt;
&lt;li&gt;入参和user作为入参，调用父类ProcessAuthorizeRequestAsync方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public override async Task&amp;lt;IEndpointResult&amp;gt; ProcessAsync(HttpContext context)
        {
            Logger.LogDebug(&quot;Start authorize request&quot;);

            NameValueCollection values;

            if (HttpMethods.IsGet(context.Request.Method))
            {
                values = context.Request.Query.AsNameValueCollection();
            }
            else if (HttpMethods.IsPost(context.Request.Method))
            {
                if (!context.Request.HasFormContentType)
                {
                    return new StatusCodeResult(HttpStatusCode.UnsupportedMediaType);
                }

                values = context.Request.Form.AsNameValueCollection();
            }
            else
            {
                return new StatusCodeResult(HttpStatusCode.MethodNotAllowed);
            }

            var user = await UserSession.GetUserAsync();
            var result = await ProcessAuthorizeRequestAsync(values, user, null);

            Logger.LogTrace(&quot;End authorize request. result type: {0}&quot;, result?.GetType().ToString() ?? &quot;-none-&quot;);

            return result;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;认证站点如果cookie中存在当前会话信息，则直接返回用户信息，否则调用cookie架构的认证方法，会跳转到登录页面。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public virtual async Task&amp;lt;ClaimsPrincipal&amp;gt; GetUserAsync()
{
    await AuthenticateAsync();

    return Principal;
}

protected virtual async Task AuthenticateAsync()
    {
        if (Principal == null || Properties == null)
        {
            var scheme = await GetCookieSchemeAsync();

            var handler = await Handlers.GetHandlerAsync(HttpContext, scheme);
            if (handler == null)
            {
                throw new InvalidOperationException($&quot;No authentication handler is configured to authenticate for the scheme: {scheme}&quot;);
            }

            var result = await handler.AuthenticateAsync();
            if (result != null &amp;amp;&amp;amp; result.Succeeded)
            {
                Principal = result.Principal;
                Properties = result.Properties;
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;认证请求处理流程大致分为三步&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AuthorizeRequestValidator校验所有参数&lt;/li&gt;
&lt;li&gt;认证接口consent入参为null，不需要处理用户交互判断&lt;/li&gt;
&lt;li&gt;生成返回报文&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; internal async Task&amp;lt;IEndpointResult&amp;gt; ProcessAuthorizeRequestAsync(NameValueCollection parameters, ClaimsPrincipal user, ConsentResponse consent)
{
    if (user != null)
    {
        Logger.LogDebug(&quot;User in authorize request: {subjectId}&quot;, user.GetSubjectId());
    }
    else
    {
        Logger.LogDebug(&quot;No user present in authorize request&quot;);
    }

    // validate request
    var result = await _validator.ValidateAsync(parameters, user);
    if (result.IsError)
    {
        return await CreateErrorResultAsync(
            &quot;Request validation failed&quot;,
            result.ValidatedRequest,
            result.Error,
            result.ErrorDescription);
    }

    var request = result.ValidatedRequest;
    LogRequest(request);

    // determine user interaction
    var interactionResult = await _interactionGenerator.ProcessInteractionAsync(request, consent);
    if (interactionResult.IsError)
    {
        return await CreateErrorResultAsync(&quot;Interaction generator error&quot;, request, interactionResult.Error, interactionResult.ErrorDescription, false);
    }
    if (interactionResult.IsLogin)
    {
        return new LoginPageResult(request);
    }
    if (interactionResult.IsConsent)
    {
        return new ConsentPageResult(request);
    }
    if (interactionResult.IsRedirect)
    {
        return new CustomRedirectResult(request, interactionResult.RedirectUrl);
    }

    var response = await _authorizeResponseGenerator.CreateResponseAsync(request);

    await RaiseResponseEventAsync(response);

    LogResponse(response);

    return new AuthorizeResult(response);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;生成返回信息&quot;&gt;生成返回信息&lt;/h2&gt;
&lt;p&gt;此处只有AuthorizationCode、Implicit、Hybrid三种授权类型的判断，用户名密码、客户端密钥模式不能使用authorize接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;  public virtual async Task&amp;lt;AuthorizeResponse&amp;gt; CreateResponseAsync(ValidatedAuthorizeRequest request)
{
    if (request.GrantType == GrantType.AuthorizationCode)
    {
        return await CreateCodeFlowResponseAsync(request);
    }
    if (request.GrantType == GrantType.Implicit)
    {
        return await CreateImplicitFlowResponseAsync(request);
    }
    if (request.GrantType == GrantType.Hybrid)
    {
        return await CreateHybridFlowResponseAsync(request);
    }

    Logger.LogError(&quot;Unsupported grant type: &quot; + request.GrantType);
    throw new InvalidOperationException(&quot;invalid grant type: &quot; + request.GrantType);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果state字段不为空，使用加密算法得到state的hash值&lt;/li&gt;
&lt;li&gt;构建AuthorizationCode对象，存放在store中，store是idsv4用于持久化的对象，默认实现存储在内存中，可以对可插拔服务进行注入替换，实现数据保存在在mysql、redis等流行存储中&lt;/li&gt;
&lt;li&gt;将授权码对象的id返回&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; protected virtual async Task&amp;lt;AuthorizeResponse&amp;gt; CreateCodeFlowResponseAsync(ValidatedAuthorizeRequest request)
{
    Logger.LogDebug(&quot;Creating Authorization Code Flow response.&quot;);

    var code = await CreateCodeAsync(request);
    var id = await AuthorizationCodeStore.StoreAuthorizationCodeAsync(code);

    var response = new AuthorizeResponse
    {
        Request = request,
        Code = id,
        SessionState = request.GenerateSessionStateValue()
    };

    return response;
}

protected virtual async Task&amp;lt;AuthorizationCode&amp;gt; CreateCodeAsync(ValidatedAuthorizeRequest request)
    {
        string stateHash = null;
        if (request.State.IsPresent())
        {
            var credential = await KeyMaterialService.GetSigningCredentialsAsync();
            if (credential == null)
            {
                throw new InvalidOperationException(&quot;No signing credential is configured.&quot;);
            }

            var algorithm = credential.Algorithm;
            stateHash = CryptoHelper.CreateHashClaimValue(request.State, algorithm);
        }

        var code = new AuthorizationCode
        {
            CreationTime = Clock.UtcNow.UtcDateTime,
            ClientId = request.Client.ClientId,
            Lifetime = request.Client.AuthorizationCodeLifetime,
            Subject = request.Subject,
            SessionId = request.SessionId,
            CodeChallenge = request.CodeChallenge.Sha256(),
            CodeChallengeMethod = request.CodeChallengeMethod,

            IsOpenId = request.IsOpenIdRequest,
            RequestedScopes = request.ValidatedScopes.GrantedResources.ToScopeNames(),
            RedirectUri = request.RedirectUri,
            Nonce = request.Nonce,
            StateHash = stateHash,

            WasConsentShown = request.WasConsentShown
        };

        return code;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;返回结果&quot;&gt;返回结果&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;如果ResponseMode等于Query或者Fragment，将授权码code及其他信息拼装到Uri，返回302重定向请求&lt;br/&gt;例子：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;302 https://mysite.com?code=xxxxx&amp;amp;state=xxx
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果是FormPost方式，会生成一段脚本返回到客户端。窗口加载会触发form表单提交，将code、state等信息包裹在隐藏字段里提交到配置的rediret_uri。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv='X-UA-Compatible' content='IE=edge' /&amp;gt;
    &amp;lt;base target='_self'/&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form method='post' action='https://mysite.com'&amp;gt;
        &amp;lt;input type='hidden' name='code' value='xxx' /&amp;gt;
        &amp;lt;input type='hidden' name='state' value='xxx' /&amp;gt;
        &amp;lt;noscript&amp;gt;
            &amp;lt;button&amp;gt;Click to continue&amp;lt;/button&amp;gt;
        &amp;lt;/noscript&amp;gt;
    &amp;lt;/form&amp;gt;
    &amp;lt;script&amp;gt;window.addEventListener('load', function(){document.forms[0].submit();});&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;private async Task RenderAuthorizeResponseAsync(HttpContext context)
{
    if (Response.Request.ResponseMode == OidcConstants.ResponseModes.Query ||
        Response.Request.ResponseMode == OidcConstants.ResponseModes.Fragment)
    {
        context.Response.SetNoCache();
        context.Response.Redirect(BuildRedirectUri());
    }
    else if (Response.Request.ResponseMode == OidcConstants.ResponseModes.FormPost)
    {
        context.Response.SetNoCache();
        AddSecurityHeaders(context);
        await context.Response.WriteHtmlAsync(GetFormPostHtml());
    }
    else
    {
        //_logger.LogError(&quot;Unsupported response mode.&quot;);
        throw new InvalidOperationException(&quot;Unsupported response mode&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端在回调地址接收code，即可向token接口换取token。&lt;/p&gt;
&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;简单看一下简化流程和混合流程是怎么创建返回报文的。&lt;/p&gt;
&lt;h3 id=&quot;简化流程生成返回报文&quot;&gt;简化流程生成返回报文&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如果返回类型包含token，生成通行令牌&lt;/li&gt;
&lt;li&gt;如果返回类型包含id_token，生成身份令牌&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看到，简化流程的所有token都是由authorization接口返回的，一次请求返回所有token。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;protected virtual async Task&amp;lt;AuthorizeResponse&amp;gt; CreateImplicitFlowResponseAsync(ValidatedAuthorizeRequest request, string authorizationCode = null)
    {
        Logger.LogDebug(&quot;Creating Implicit Flow response.&quot;);

        string accessTokenValue = null;
        int accessTokenLifetime = 0;

        var responseTypes = request.ResponseType.FromSpaceSeparatedString();

        if (responseTypes.Contains(OidcConstants.ResponseTypes.Token))
        {
            var tokenRequest = new TokenCreationRequest
            {
                Subject = request.Subject,
                Resources = request.ValidatedScopes.GrantedResources,

                ValidatedRequest = request
            };

            var accessToken = await TokenService.CreateAccessTokenAsync(tokenRequest);
            accessTokenLifetime = accessToken.Lifetime;

            accessTokenValue = await TokenService.CreateSecurityTokenAsync(accessToken);
        }

        string jwt = null;
        if (responseTypes.Contains(OidcConstants.ResponseTypes.IdToken))
        {
            string stateHash = null;
            if (request.State.IsPresent())
            {
                var credential = await KeyMaterialService.GetSigningCredentialsAsync();
                if (credential == null)
                {
                    throw new InvalidOperationException(&quot;No signing credential is configured.&quot;);
                }

                var algorithm = credential.Algorithm;
                stateHash = CryptoHelper.CreateHashClaimValue(request.State, algorithm);
            }

            var tokenRequest = new TokenCreationRequest
            {
                ValidatedRequest = request,
                Subject = request.Subject,
                Resources = request.ValidatedScopes.GrantedResources,
                Nonce = request.Raw.Get(OidcConstants.AuthorizeRequest.Nonce),
                IncludeAllIdentityClaims = !request.AccessTokenRequested,
                AccessTokenToHash = accessTokenValue,
                AuthorizationCodeToHash = authorizationCode,
                StateHash = stateHash
            };

            var idToken = await TokenService.CreateIdentityTokenAsync(tokenRequest);
            jwt = await TokenService.CreateSecurityTokenAsync(idToken);
        }

        var response = new AuthorizeResponse
        {
            Request = request,
            AccessToken = accessTokenValue,
            AccessTokenLifetime = accessTokenLifetime,
            IdentityToken = jwt,
            SessionState = request.GenerateSessionStateValue()
        };

        return response;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;混合流程生成返回报文&quot;&gt;混合流程生成返回报文&lt;/h3&gt;
&lt;p&gt;这段代码充分体现了它为啥叫混合流程，把生成授权码的方法调一遍，再把简化流程的方法调一遍，code和token可以一起返回。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;protected virtual async Task&amp;lt;AuthorizeResponse&amp;gt; CreateHybridFlowResponseAsync(ValidatedAuthorizeRequest request)
    {
        Logger.LogDebug(&quot;Creating Hybrid Flow response.&quot;);

        var code = await CreateCodeAsync(request);
        var id = await AuthorizationCodeStore.StoreAuthorizationCodeAsync(code);

        var response = await CreateImplicitFlowResponseAsync(request, id);
        response.Code = id;

        return response;
    }
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 27 Mar 2020 18:26:00 +0000</pubDate>
<dc:creator>holdengong</dc:creator>
<og:description>identityserver4</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/holdengong/p/12585466.html</dc:identifier>
</item>
<item>
<title>机器学习 - 命名实体识别之Hidden Markov Modelling - HappyPuppy</title>
<link>http://www.cnblogs.com/tangxiaobo199181/p/12585312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangxiaobo199181/p/12585312.html</guid>
<description>&lt;p&gt;命名实体识别在NLP的应用中也是非常广泛的，尤其是是information extraction的领域。Named Entity Recognition(NER) 的应用中，最常用的一种算法模型是隐式马可夫模型（Hidden Markov Modelling）- HMM。本节内容主要是通过介绍HMM的原理，以及应用HMM来做一个NER的实例演示。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;HMM原理解析&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在解释HMM的原理之前，先引用几个HMM的基本概念，第一个是就是隐式状态，在本文中用H表示； 第二个就是显式状态，在本文中用大写的英文字母O表示。咱们的HMM的中，就是根据咱们的显式状态O来计算隐式状态H的概率的问题，其中在HMM中有一个基本的前提条件，那就是每一个time step的隐式状态只跟它前一步的的隐式状态有关。具体是什么意思呢，大家看我下面的一幅图片,结合这幅图片来给大家解释&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287224/202003/1287224-20200327152451220-500863382.jpg&quot; alt=&quot;&quot; width=&quot;825&quot; height=&quot;464&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 首先observables是大家能直接得到的信息，例如一个句子“小李和王二在天津旅游”，这个就是一个observable的sequence，是咱们能够直接得到的信息；那么咱们如何才能够得到这句话背后所包含的隐式sequences呢？这就是咱们的HMM所要解决的问题了。从上图可以看出hidden states之间是通过transition matrix来连接的，这里咱们也可以很好的看出来每一步的hidden state仅仅是由前一步的hidden state来确定的；hidden state和observable之间是通过emission matrix来连接的，即在给定的hidden state的情况的，指向每一个observable的概率是多少。这么说的有点抽象，那么咱们通过下面的图片来展示这个transition matrix和emission matrix&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287224/202003/1287224-20200327223829126-1755093613.jpg&quot; alt=&quot;&quot; width=&quot;1045&quot; height=&quot;588&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 上面的图片展示了HMM所需要的一些matrix，咱们的一个个分析。首先initial matrix是咱们根据语义集中的每一条数据的第一个hidden state计算出来的；transition matrix是根据咱们训练的语言集中的所有的隐式状态的计算出来的，例如咱们统计出所有的H0-》H0和H0-》H1的个数，然后除以总数，得出的分别就是H0-》H0和H0-》H1的概率，同理得出其他的Transition Matrix的其他的概率。Emission Matrix也是根据咱们训练的语义集中的数据计算出来的，它的步骤是统计出所有H0-》O0，O1, O2,O3,O4的个数，然后除以总数，得到的就是H0这个hidden state分别对应的所有的显式状态的概率， 同理也可以计算出其他的emission matrix的值。这就是得出Initial Matrix, Transition Matrix, 和 Emission Matrix的方法和步骤。从咱们的语义集中得出了这些数据过后，咱们就通过Vertibi算法来根据observable sequence计算了咱们的Hidden state sequences。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;Vertibi 算法&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Vertibi算法是一种动态路径规划的算法，它能动态的规划处最优的路径。具体在咱们NER的应用中，它能够根据咱们的上面计算出来的Transition matrix, Initial Matrix和Emmsion Matrix来规划处咱们的最优的隐式状态的sequence， 其实这里就是寻找P（H0H1H2H3H4H5...........）最大值的一种方法，这里需要注意的一个点就是局部的最优并不一定能得出全局最优的结论，这是因为每一步的隐式状态的概率并不仅仅收到当前这一步的显式状态的影响，还受到它前一步的隐式状态的影响。下面咱们来用一个小实例来展示一下Vertibi的算法，为了方便，咱们只展示一步哈，请看下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287224/202003/1287224-20200328000036677-18026043.jpg&quot; alt=&quot;&quot; width=&quot;1054&quot; height=&quot;582&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;隐式马可夫算法和维特比算法的代码演示&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的部分都是分析隐式马可夫算法和维特比算法的原理，那么接下来咱们具体看看它们在NER中的应用以及实际的代码演示，这里我用一个在NLP中的实例来演示这两种算法。假设我们有一个语义集，咱们根据训练数据来计算好markov的matrix，然后应用维特比算法来抽取句子中的人名的信息出来。这在NLP中是一个非常常用的案例，那咱们首先来看看计算Initial maxtrix和Transition Matrix的代码部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算初始hidden state的概率和transition matrix&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; calculate_initial_and_transition_matrix(self):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; dictionary &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.text_corpus:
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i, tag &lt;span&gt;in&lt;/span&gt; enumerate(dictionary[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tags&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][:-1&lt;span&gt;]):
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i ==&lt;span&gt; 0:
                    self.pi[self.tag_index[tag]]&lt;/span&gt;+=1&lt;span&gt;
                current_tag &lt;/span&gt;=&lt;span&gt; self.tag_index[tag]
                next_tag &lt;/span&gt;= self.tag_index[dictionary[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tags&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][i+1&lt;span&gt;]]
                self.transition[current_tag, next_tag] &lt;/span&gt;+= 1&lt;span&gt;
        self.transition &lt;/span&gt;/= np.sum(self.transition, axis = 1, keepdims =&lt;span&gt; True)
        self.pi &lt;/span&gt;/=&lt;span&gt; np.sum(self.pi)
        self.pi[self.pi &lt;/span&gt;== 0] = 1e-8&lt;span&gt;
        self.transition[self.transition &lt;/span&gt;== 0] = 1e-8
        &lt;span&gt;return&lt;/span&gt; self.pi, self.transition
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其次咱们来看一下计算emission matrix的代码部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; calculate_emmision_matrix(self):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; dictionary &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.text_corpus:
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; word, tag &lt;span&gt;in&lt;/span&gt; zip(dictionary[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], dictionary[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tags&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]):
                self.emmision_matrix[self.tag_index[tag],self.dataloader.tokenizer.texts_to_sequences(word)[0][0]] &lt;/span&gt;+= 1&lt;span&gt;
        self.emmision_matrix &lt;/span&gt;/= np.sum(self.emmision_matrix, keepdims = True, axis= 1&lt;span&gt;)
        self.emmision_matrix[self.emmision_matrix &lt;/span&gt;== 0] = 1e-8
        &lt;span&gt;return&lt;/span&gt; self.emmision_matrix
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据咱们的训练数据咱们得出了这些matrix的值，根据这些matrix的值，咱们就可以根据输入的一句话（显式状态）来计算出这一句话中哪些字是人名（隐式状态）了，并且将这些人名信息提取出来了。这里咱们不用实际的手动的实现vertibi算法了，TensorFlow已经帮助咱们实现好了，咱们不需要再重复造轮子了，这里咱们需要引进一下TensorFlow probability这个框架了，具体的看下面的代码展示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow_probability as tfp
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

tfd &lt;/span&gt;=&lt;span&gt; tfp.distributions
initial_distribution &lt;/span&gt;= tfd.Categorical(probs=&lt;span&gt;pi)
transition_maxtrix &lt;/span&gt;= tfd.Categorical(probs=&lt;span&gt;transition)
observation_matrix &lt;/span&gt;= tfd.Categorical(probs =&lt;span&gt; emmision)


model &lt;/span&gt;= tfd.HiddenMarkovModel(initial_distribution=&lt;span&gt;initial_distribution,
                              transition_distribution&lt;/span&gt;=&lt;span&gt;transition_maxtrix,
                              observation_distribution&lt;/span&gt;=&lt;span&gt;observation_matrix,
                              num_steps&lt;/span&gt;=11&lt;span&gt;)


test_string &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小明和老王去河边钓鱼了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
temps &lt;/span&gt;= [data_handler.calculator.word_index[index] &lt;span&gt;for&lt;/span&gt; index &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list(test_string)]
tag_sequence &lt;/span&gt;= model.posterior_mode(observations=&lt;span&gt;temps)
reversed_tag_index &lt;/span&gt;= {value:key &lt;span&gt;for&lt;/span&gt; key,value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data_handler.calculator.tag_index.items()}
tags &lt;/span&gt;= [reversed_tag_index[index] &lt;span&gt;for&lt;/span&gt; index &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tag_sequence.numpy()]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(tags)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面就是根据咱们的matrix(initial_distribution, transition_matrix, observation_matrix)，还有显示状态（test_string），tfp根据vertibi算法帮助咱们计算出来隐式状态的sequence（tag_sequence）。这就是NER在NLP的应用中常用的一个实例。&lt;/p&gt;

</description>
<pubDate>Fri, 27 Mar 2020 16:19:00 +0000</pubDate>
<dc:creator>HappyPuppy</dc:creator>
<og:description>概述 命名实体识别在NLP的应用中也是非常广泛的，尤其是是information extraction的领域。Named Entity Recognition(NER) 的应用中，最常用的一种算法模型</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tangxiaobo199181/p/12585312.html</dc:identifier>
</item>
<item>
<title>WEB应用之httpd基础入门（三） - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12570900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12570900.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_200227040346apache-httpd.png&quot; class=&quot;desc_img&quot;/&gt; 我们在构造请求报文时，随便给了一个字串给Host请求首部，也是可以正常请求到主页的，这就说明host请求首部实质上只是用来区分不同虚拟主机，它不用来解析；之所以在host首部没有被匹配成功的情况下，它响应a主机的页面，这是因为a主机的配置在最上面，默认情况下host首部没有被任何虚拟主机匹配就会以最上面的虚拟主机响应；这里还需要注意一点的是，httpd2.2在使用FQDN虚拟主机时，需要使用到listen指令和namevirtualhost ip：port 指令来指定虚拟主机监听的ip和端口信息；httpd2.4则可以不用使用namevirtualhost这个指令来指定&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;159.5523848113&quot;&gt;
&lt;p&gt;　　前文我们聊到了httpd的路径别名、访问日志定义、basic认证配置，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12561236.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12561236.html&lt;/a&gt;；今天我们来聊一聊httpd的虚拟主机和状态页的配置，前边我们也提到了虚拟主机，所谓虚拟主机不外乎就是一个物理主机上存在多个虚拟站点；通常httpd的虚拟主机有三类，分别是基于ip的虚拟主机、基于端口的虚拟主机以及基于FQDN的虚拟主机；不难理解基于ip的虚拟主机就是以不同IP来区分不同的虚拟主机；基于端口的虚拟主机就是以不同端口区分不同的虚拟主机，基于fqdn的虚拟主机就是以不同用户请求报文中的host首部来区分的虚拟主机；接下来我们来看看httpd里怎么配置虚拟主机；&lt;/p&gt;
&lt;p&gt;　　1、虚拟主机&lt;/p&gt;
&lt;p&gt;　　httpd里虚拟主机的配置方法是由&amp;lt;virtualhost IP:PORT&amp;gt;  ……&amp;lt;/virtualhost&amp;gt;配置块来配置;其中httpd2.2在启用虚拟主机配置前需要将其中心主机禁用，禁用方法很简单，就是把中心主机里的documentroot指令注释即可；在httpd2.4中，我们就不需要去关闭中心主机，在配置了虚拟主机以后，中心主机自然失效，不需要人为手动注释；对于在中心主机里可配置的指令大多数都可以用于虚拟主机配置块中；用法和中心主机里配置几乎没有啥差别；&lt;/p&gt;
&lt;p&gt;　　示例：基于IP的虚拟主机实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327210300366-2133591169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上配置主要就是提供两个基于IP的虚拟主机，一个是192.168.0.98：80，一个是192.168.0.99：80的主机；我们在对应目录下创建好主页文件，重载配置文件，这两个虚拟主机就可以生效了；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test_node1-centos7 conf.d]# echo &quot;this is a_com page ip is 192.168.0.98&quot; &amp;gt; /vhost/www/html/a_com/index.html
[root@test_node1-centos7 conf.d]# echo &quot;this is b_com page ip is 192.168.0.99&quot; &amp;gt; /vhost/www/html/b_com/index.html
[root@test_node1-centos7 conf.d]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:4a:bd:74 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.99/24 brd 192.168.0.255 scope global ens33
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe4a:bd74/64 scope link 
       valid_lft forever preferred_lft forever
[root@test_node1-centos7 conf.d]# ip addr add 192.168.0.98/24 dev ens33
[root@test_node1-centos7 conf.d]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:4a:bd:74 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.99/24 brd 192.168.0.255 scope global ens33
       valid_lft forever preferred_lft forever
    inet 192.168.0.98/24 scope global secondary ens33
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe4a:bd74/64 scope link 
       valid_lft forever preferred_lft forever
[root@test_node1-centos7 conf.d]# httpd -t
Syntax OK
[root@test_node1-centos7 conf.d]# systemctl reload httpd
[root@test_node1-centos7 conf.d]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上配置主要是给两个虚拟站点提供对应的主页文件，然后在原有的网卡上面加了一个新的ip192.168.0.98,这样配置后，我们配置的虚拟主机就可以在浏览器上通过不同的ip地址访问，得到不同的主页响应；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327211257035-753903937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327211316017-1173632568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：可以看到我们以不同IP访问站点，得到的是不同虚拟主机给我们提供的主页文件，说明我们配置的基于IP地址的虚拟主机没有什么问题；同时我们也可以看这两个虚拟主机各自的访问日志文件；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327211511163-2121392616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：不同的站点，各自以不同的访问日志和错误日志分别记录着各自站点访问日志和错误日志信息；&lt;/p&gt;
&lt;p&gt;　　示例：基于端口的虚拟主机实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327211829931-1054221783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上配置在基于IP的虚拟主机配置上修改了下，两个虚拟主机都是基于192.168.0.99这个ip地址，分别监听在80和81两个端口上，我们访问192.168.0.99：80就会匹配到a主机，拿到a主机的主页响应，访问192.168.0.99：81就会拿到b主机的主页响应；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327212347280-1849417465.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：可以看到同一IP地址，访问不同的端口，就以不同的虚拟站点提供服务；&lt;/p&gt;
&lt;p&gt;　　示例：基于不同FQDN的虚拟主机实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327212616633-222587468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上配置两个虚拟主机都监听在192.168.0.99：80用户访问主要通过不同的host请求首部来区分；如下&lt;/p&gt;
&lt;p&gt;　　在重载配置前，我们先在windows上坐下host解析，模拟DNS解析，分别把www.a.com 和www.b.com 都解析成192.168.0.99&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327213009884-917171337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　提示：windows hosts解析文件在C:\Windows\system32\drivers\etc\ 名字为hosts文件，此文件语法同Linuxhosts文件语法相同，前边是ip地址 后面是主机名称或别名；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327213250732-1612836777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：到此我们就可以通过不同的解析名称来访问不同的虚拟站点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327213711928-1005129734.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：可以看到我们以不同解析名称来访问，得到不同的虚拟主机响应，其实这中间就是用户键入不同的host首部来区分不同的虚拟站点；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327214154085-644932469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327214227204-1706364182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：用户的host请求首部是可以是其他字串，它这个host首部是不会被解析的，通常情况下是我们在浏览器上键入什么字串，对应的host首部的值就是什么，只不过浏览器要把我们键入的字串去解析成IP然后把对应的请求发送到去对应ip地址的主机上；为了更好的理解这一过程请看下面；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327214702481-662521150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：我们在构造请求报文时，随便给了一个字串给Host请求首部，也是可以正常请求到主页的，这就说明host请求首部实质上只是用来区分不同虚拟主机，它不用来解析；之所以在host首部没有被匹配成功的情况下，它响应a主机的页面，这是因为a主机的配置在最上面，默认情况下host首部没有被任何虚拟主机匹配就会以最上面的虚拟主机响应；这里还需要注意一点的是，httpd2.2在使用FQDN虚拟主机时，需要使用到listen指令和namevirtualhost ip：port 指令来指定虚拟主机监听的ip和端口信息；httpd2.4则可以不用使用namevirtualhost这个指令来指定；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327225503851-118158238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上是httpd2.2基于FQDN的虚拟主机配置示例；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327225623024-1355731336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　2、status页面配置说明&lt;/p&gt;
&lt;p&gt;　　httpd的状态页面上由httpd的status_module模块实现，在配置使用状态页面信息，首先需要确认该模块是否装载，确认方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327230145527-1519037120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：httpd2.2和2.4的确认方法一样，如果能够列出status_module，说明该模块已经装载，如果没有被装载需要使用LoadModule  status_module  modules/mod_status.so 来装载即可；以上是httpd2.4确认结果，2.2的确认结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327230400210-1079354496.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt; 　　确认了模块装载了，接下来就是配置使用&lt;/p&gt;
&lt;p&gt;　　示例：httpd2.4配置status页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327231049890-1937490926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：状态页的配置主要是用location 来指定一个URI，然后在其下面配置sethandler 指令来指定匹配到的URI怎么处理，以上表示用server-status来处理，这里需要注意一点httpd的状态页面上status_module实现的，我们在配置使用必须是server-status来处理，不能上其他名称；还需要说明的是该location可以配置在任何虚拟主机以及中心主机都可以，他都表示用server-status来处理，说白了就是显示状态页；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327231926308-1229026872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：以上就是我们刚才配置的location 对应uri 响应的内容；当然以上信息是比较私密的信息，通常情况下我们只允许部分IP地址的主机查看，在httpd2.4上如果不是允许所有主机查看，只是部分主机查看，基于IP地址做访问控制的话，我们需要将其访问控制的权限指令写到&amp;lt;requireall&amp;gt; ……&amp;lt;/requireall&amp;gt;配置段中；&lt;/p&gt;
&lt;p&gt; 　　示例：httpd2.2状态页面配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327234029171-1816269577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：httpd2.2和httpd2.4状态页的配置没有本质的不同；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200327232911896-785231596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　提示：在httpd2.2的状态页上，要比httpd2.4信息少很多，从上面的提示看，它告诉我们如果要显示全面的状态信息，我们需要使用extendedstatus on指令，如果我们需要更加全面的信息，可以选择把该指定配置server配置段中；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 27 Mar 2020 15:51:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊到了httpd的路径别名、访问日志定义、basic认证配置，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/12561236.html；今天我们来聊一聊</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12570900.html</dc:identifier>
</item>
<item>
<title>K：剑指offer-56 题解 谁说数字电路的知识不能用到算法中？从次数统计到逻辑表达式的推导，一文包你全懂 - 林学徒</title>
<link>http://www.cnblogs.com/MyStringIsNotNull/p/12585218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MyStringIsNotNull/p/12585218.html</guid>
<description>&lt;p&gt;本题解从统计数字出现次数的解题方式开始讲起，再推导出逐位统计出现次数的解题方式，最终得出状态机解题方法，期望以循序渐进的方式得出最终代码的思想。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;156&quot;&gt;

&lt;p&gt;本题解整理了一位大佬在leetcode中的代码的方法，该博文致力于让所有人都能够能够看懂该方法。为此，本题解将从统计数字出现次数的解题方式开始讲起，再推导出逐位统计的解题方式，期望以循序渐进的方式得出最终代码的思想。&lt;/p&gt;

&lt;p&gt;二进制、位运算、真值表、逻辑表达式、状态机&lt;/p&gt;

&lt;p&gt;剑指offer 56 II. 数组中数字出现的次数 II&lt;/p&gt;
&lt;p&gt;在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br/&gt;输入：nums = [3,4,3,3]&lt;br/&gt;输出：4&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br/&gt;输入：nums = [9,1,7,9,7,9,7]&lt;br/&gt;输出：1&lt;/p&gt;

&lt;p&gt;对于数组nums，其只有一个数字出现了一次，其余数字均出现了三次，一种直观的想法是直接采用一个map统计各个字符出现的次数，最后再遍历map中的各个键值对，直到找到只出现了一次的数字。其代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public int singleNumber(int[] nums) {
        //统计各个数字出现的次数，键为数字，值为出现的次数
        Map&amp;lt;Integer,Integer&amp;gt; map =new HashMap&amp;lt;Integer,Integer&amp;gt;();
        for(int i:nums){
            if(!map.containsKey(i)){
                map.put(i,1);
                continue;
            }
            map.put(i,map.get(i)+1);
        }
        //遍历map中的键值对，查看值出现次数为1的键，即为答案
        int result = 0;
        for(Map.Entry&amp;lt;Integer,Integer&amp;gt; entry:map.entrySet()){
            if(entry.getValue()==1){
                result = entry.getKey();
                break;
            }
        }
        return result;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于该解题方法，其空间复杂度为O（n），时间复杂度为O（n），这显然不会是该题的最优解。&lt;/p&gt;
&lt;p&gt;在得出逐位运算的解题方式之前，我们需要研究下该数组中的数字用二进制的方式进行表示的特点。&lt;/p&gt;
&lt;p&gt;以题干给出的示例1为例，nums=[3,4,3,3]，将数组中各个数字采用二进制的方式写出，&lt;br/&gt;3 = （0011）2&lt;br/&gt;4 = （0100）2&lt;br/&gt;3 = （0011）2&lt;br/&gt;3 = （0011）2&lt;/p&gt;
&lt;p&gt;通过对数组中各个数的二进制表示形式逐位进行观察，我们可以发现，当数组中只出现一次的那个数字(用k表示)在二进制的对应位为0时，该对应位为1在数组各个数字中出现的总次数应当为&lt;strong&gt;3^n&lt;/strong&gt; ，当k的对应位为1时，该对应位为1在数组各个数字中出现的总次数应当为 &lt;strong&gt;3^n + 1&lt;/strong&gt;，为此，我们可以统计数字中的各个位中1出现的次数，当为3^n 次时，只出现一次的数字的对应位应当为0，当为3^n + 1次时，只出现一次的数字的对应位应当为1。由此，我们可以得到如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public int singleNumber(int[] nums) {
        if(nums==null||nums.length==0) return 0;
        int result = 0;
        for(int i = 0;i&amp;lt;32;i++){
            //统计该位1的出现次数情况
            int count = 0;
            int index = 1&amp;lt;&amp;lt;i;
            for(int j:nums){
                //该位与操作后的结果不为0，则表示该位为1的情况出现了
                if((index&amp;amp;j)!=0){
                    count++;
                }
            }
            //该位上出现1的次数mod3后为1，表示出现一次的数字该位为1
            if(count%3==1){
                result|=index;
            }
        }
        return result;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于该解题方法，其时间复杂度为O（n），空间复杂度为O（1）。在某种程度上，这是最优解了。但是，&lt;strong&gt;该题解仍有改进的空间&lt;/strong&gt;（其时间复杂度的常系数为32）。&lt;/p&gt;
&lt;p&gt;有了对数组中数字的各二进制位进行逐一统计分析出现次数的相关基础后，我们便可以推导出那个击败100%的答案的解法了。回顾上面的解题方法的分析部分，其需要我们对数字的二进制位逐位进行统计，对于int数据类型，我们需要遍历32次数组（int占4字节），以便统计出各个二进制位出现的次数。那我们有没有办法只遍历一次数组便得出答案呢？当然有，我们可以&lt;strong&gt;一次分析32bit的int的各个位在数组的各个数字中出现的次数&lt;/strong&gt;。在分析上面的代码我们可以发现，实际上，我们&lt;strong&gt;只需要记录对应位出现的次数为0、1、2次的情况&lt;/strong&gt;，当对应位出现次数为3的时候，我们便可以将该位出现的次数置为0,重新开始进行计数。由于int型中的各个二进制位出现的次数为3进制的，为此我们需要两个位来记录各个位出现的次数，由此我们需要引入两个变量a，b来统计对应位出现的次数。由ab两个变量组合起来来记录各个二进制位出现为1的情况。&lt;strong&gt;变量a表示高位的情况，变量b表示低位的情况&lt;/strong&gt;，而在遍历数组运算完成之后，遍历b的值便是答案。&lt;/p&gt;
&lt;p&gt;变量ab组合的各个二进制位组合的形式有如下三种，考虑进新引入的变量c的各二进制位的情况，我们可以得到如下真值表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1095776/202003/1095776-20200327234310742-115970887.jpg&quot; alt=&quot;真值表&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由以上真值表，我们便可得出变量a，b的逻辑表达式，其表示如下&lt;br/&gt;a = a’(!b’)(!c)+(!a’)b’c&lt;br/&gt;b = (!a’)b’(!c)+(!a’)(!b’)c = (!a’)[b’(!c)+(!b’)c] = (!a’)[b’^c]&lt;/p&gt;
&lt;p&gt;由此，我们可以得到如下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public int singleNumber(int[] nums) {
        //a对应位为1表示出现2次的记录，b对应位表示出现1次或0次的记录，ab共同组成该位出现的次数
        int a = 0,b =0;
        for(int i:nums){
            int temp = a;
            a = (~a&amp;amp;b&amp;amp;i)|(a&amp;amp;~b&amp;amp;~i);
            b = ~temp&amp;amp;(b^i);
        }
        return b;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，我们还能对a的逻辑表达式进行简化，先得到b的逻辑表达式，之后用b代替b’作为输入，由此可以简化a为&lt;br/&gt;a = (!a’)(!b)c+a’(!b)(!c) = (!b)[(!a’)c+a’(!c)] = (!b)[a’^c]&lt;/p&gt;
&lt;p&gt;由此，我们可以得到如下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public int singleNumber(int[] nums) {
        //a为对应位的1出现2次的记录，b为对应位出现1次的记录，ab共同组成该位出现的次数
        int a = 0,b =0;
        for(int i:nums){
            b = ~a&amp;amp;(b^i);
            a = ~b&amp;amp;(a^i);
        }
        return b;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们得到了最终的代码。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;这个是本人的公众号，致力于写出绝大部分人都能读懂的技术文章。欢迎相互交流，我们博采众长，共同进步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1095776/202003/1095776-20200327234200396-247368185.jpg&quot; alt=&quot;公众号二维码.jpg&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 27 Mar 2020 15:51:00 +0000</pubDate>
<dc:creator>林学徒</dc:creator>
<og:description>本题解从统计数字出现次数的解题方式开始讲起，再推导出逐位统计出现次数的解题方式，最终得出状态机解题方法，期望以循序渐进的方式得出最终代码的思想。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MyStringIsNotNull/p/12585218.html</dc:identifier>
</item>
<item>
<title>【docker Elasticsearch】Rest风格的分布式开源搜索和分析引擎Elasticsearch初体验 - lomtom</title>
<link>http://www.cnblogs.com/lomtom/p/12584956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lomtom/p/12584956.html</guid>
<description>&lt;p&gt;Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。 它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，这是通常没有预料到的。 它存在还因为原始数据如果只是躺在磁盘里面根本就毫无用处。&lt;/p&gt;
&lt;p&gt;Elasticsearch 不仅仅只是全文搜索，我们还将介绍结构化搜索、数据分析、复杂的人类语言处理、地理位置和对象间关联关系等。 我们还将探讨为了充分利用 Elasticsearch 的水平伸缩性，应当如何建立数据模型，以及在生产环境中如何配置和监控你的集群。&lt;/p&gt;
&lt;p&gt;Elasticsearch也使用Java开发并使用 Lucene 作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的 RESTful API 来隐藏 Lucene 的复杂性，从而让全文搜索变得简单。&lt;br/&gt;不过，Elasticsearch 不仅仅是 Lucene 和全文搜索，我们还能这样去描述它：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布式的实时文件存储，每个字段都被索引并可被搜索&lt;/li&gt;
&lt;li&gt;分布式的实时分析搜索引擎&lt;/li&gt;
&lt;li&gt;可以扩展到上百台服务器，处理PB级结构化或非结构化数据&lt;br/&gt;@

&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;一：安装elasticsearch&quot;&gt;一：安装elasticsearch&lt;/h2&gt;
&lt;h3 id=&quot;1、安装&quot;&gt;1、安装&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;1、搜索镜像
docker search Elasticsearch

 2、拉取镜像
docker pull elasticsearch:7.5.2

3、查看镜像
docker images

4、启动容器
docker run -d --name elaseticsearch -p 9200:9200 -p 9300:9300 -e ES_JAVA_POTS=&quot;-Xms256m -Xmx256m&quot;  -e &quot;discovery.type=single-node&quot;  [镜像id]

5、访问
http://localhost:9200

{
    &quot;name&quot;: &quot;ea92e317dcb0&quot;,
    &quot;cluster_name&quot;: &quot;docker-cluster&quot;,
    &quot;cluster_uuid&quot;: &quot;nN5sGE2FQuidchtltDxAhQ&quot;,
    &quot;version&quot;: {
        &quot;number&quot;: &quot;7.5.2&quot;,
        &quot;build_flavor&quot;: &quot;default&quot;,
        &quot;build_type&quot;: &quot;docker&quot;,
        &quot;build_hash&quot;: &quot;8bec50e1e0ad29dad5653712cf3bb580cd1afcdf&quot;,
        &quot;build_date&quot;: &quot;2020-01-15T12:11:52.313576Z&quot;,
        &quot;build_snapshot&quot;: false,
        &quot;lucene_version&quot;: &quot;8.3.0&quot;,
        &quot;minimum_wire_compatibility_version&quot;: &quot;6.8.0&quot;,
        &quot;minimum_index_compatibility_version&quot;: &quot;6.0.0-beta1&quot;
    },
    &quot;tagline&quot;: &quot;You Know, for Search&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2、问题&quot;&gt;2、问题&lt;/h3&gt;
&lt;p&gt;1、启动失败，docker内容器无故停止&lt;br/&gt;原因：elasticsearch初始占用内存大，开始占用两G，而我给docker只分配了1G，所以造成内存不够从而造成启失败，如果你电脑内存够大，你可以给你的docker分配大一点的内存，内存不够的同学，你可以在创建容器时加参数&lt;code&gt;-e ES_JAVA_POTS=&quot;-Xms256m -Xmx256m&quot;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;二：安装kibana&quot;&gt;二：安装kibana&lt;/h2&gt;
&lt;h3 id=&quot;1、安装-2&quot;&gt;1、安装&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;1、拉取镜像
docker pull kibana:7.5.2
注：最好与你的elasticsearch版本一致，以免出现问题

2、创建容器
docker run -d --name kibana  -p 5601:5601 [镜像id]

3、访问测试
访问地址：http://locahost:5601
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在调试很久之后，终于来到我渴望来到的界面。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323120116358.png#pic_center&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;他里面有一个测试：&lt;code&gt;http://localhost:9200/_search&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323122352248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、问题-2&quot;&gt;2、问题&lt;/h3&gt;
&lt;p&gt;1、访问kibana出现问题：&lt;code&gt;Kibana server is not ready yet&lt;/code&gt;，具体问题你需要看他的日志，使用&lt;code&gt;kitematic&lt;/code&gt;可以查看容器的日志。&lt;br/&gt;出现这个问题的可能性有很多，需要注意的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、确认你的elasticsearch是否启动，这没什么好说的&lt;/li&gt;
&lt;li&gt;2、确认你的elasticsearch版本是否与你的kibana版本是否一致，虽然我也没有测试，版本一致总归没有什么坏处。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323121645687.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;3、你最好把kibana与elasticsearch两个容器之间连接起来&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323120324913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;4、在进入容器后，你&lt;strong&gt;必须&lt;/strong&gt;修改&lt;code&gt;elasticsearch.hosts&lt;/code&gt;参数，它里面会有默认值为&lt;code&gt;http://elaseicsearch:9200&lt;/code&gt;,注意这里不能改为&lt;code&gt;http://localhost:9200&lt;/code&gt;,因为这样他会映射到你的容器内部。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323120524364.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;你需要在你的主机查看ip，输入&lt;code&gt;ipconfig&lt;/code&gt;，这里会有很多ip，请注意，这里只有一个才能连接，如果你不能确认是哪一个，请在你的kibana容器内部curl一下&lt;code&gt;http://ip:9200&lt;/code&gt;，出现elasticsearch信息的才是正确的。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323121241263.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据的操作无非就是增删改查四种对吧，接下来演示怎么实现这四种方法：&lt;/p&gt;
&lt;h2 id=&quot;一：添加数据&quot;&gt;一：添加数据&lt;/h2&gt;
&lt;p&gt;这时elasticsearch开发文档里的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PUT /megacorp/employee/1
{
    &quot;first_name&quot; : &quot;John&quot;,
    &quot;last_name&quot; :  &quot;Smith&quot;,
    &quot;age&quot; :        25,
    &quot;about&quot; :      &quot;I love to go rock climbing&quot;,
    &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]
}

PUT /megacorp/employee/2
{
    &quot;first_name&quot; :  &quot;Jane&quot;,
    &quot;last_name&quot; :   &quot;Smith&quot;,
    &quot;age&quot; :         32,
    &quot;about&quot; :       &quot;I like to collect rock albums&quot;,
    &quot;interests&quot;:  [ &quot;music&quot; ]
}

PUT /megacorp/employee/3
{
    &quot;first_name&quot; :  &quot;Douglas&quot;,
    &quot;last_name&quot; :   &quot;Fir&quot;,
    &quot;age&quot; :         35,
    &quot;about&quot;:        &quot;I like to build cabinets&quot;,
    &quot;interests&quot;:  [ &quot;forestry&quot; ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以1号员工为例：这里使用Postman工具：&lt;br/&gt;我们将请求切换为PUT请求，输入Url，在请求里面加上数据，点击发送，就会看到响应，&lt;br/&gt;注意，路径 /megacorp/employee/1 包含了三部分的信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;megacorp（索引名称）&lt;/li&gt;
&lt;li&gt;employee（类型名称）&lt;/li&gt;
&lt;li&gt;1（特定雇员的ID）&lt;br/&gt;请求体 —— JSON 文档 —— 包含了这位员工的所有详细信息，他的名字叫 John Smith ，今年 25 岁，喜欢攀岩。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323131027863.png?&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二：查看数据&quot;&gt;二：查看数据&lt;/h2&gt;
&lt;p&gt;目前我们已经在 Elasticsearch 中存储了一些数据， 接下来就能专注于实现应用的业务需求了。第一个需求是可以检索到单个雇员的数据。&lt;/p&gt;
&lt;p&gt;这在 Elasticsearch 中很简单。简单地执行 一个 HTTP GET 请求并指定文档的地址——索引库、类型和ID。 使用这三个信息可以返回原始的 JSON 文档：&lt;/p&gt;
&lt;h3 id=&quot;1、查询单个数据&quot;&gt;1、查询单个数据&lt;/h3&gt;
&lt;p&gt;同样的，我们只需要将索引名、类别名、id的形式以get的请求发送，就可以实现单个数据的查询。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /megacorp/employee/1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回结果包含了文档的一些元数据，以及 _source 属性，内容是 John Smith 雇员的原始 JSON 文档&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323132700272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、查询所有的数据&quot;&gt;2、查询所有的数据&lt;/h3&gt;
&lt;p&gt;一个 GET 是相当简单的，可以直接得到指定的文档。 现在尝试点儿稍微高级的功能，比如一个简单的搜索！&lt;/p&gt;
&lt;p&gt;第一个尝试的几乎是最简单的搜索了。我们使用下列请求来搜索所有雇员：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /megacorp/employee/_search
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323133209970.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;可以看到，我们仍然使用索引库 megacorp 以及类型 employee，但与指定一个文档 ID 不同，这次使用 _search 。返回结果包括了所有三个文档，放在数组 hits 中。一个搜索默认返回十条结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;took&quot;: 1,
    &quot;timed_out&quot;: false,
    &quot;_shards&quot;: {
        &quot;total&quot;: 1,
        &quot;successful&quot;: 1,
        &quot;skipped&quot;: 0,
        &quot;failed&quot;: 0
    },
    &quot;hits&quot;: {
        &quot;total&quot;: {
            &quot;value&quot;: 3,
            &quot;relation&quot;: &quot;eq&quot;
        },
        &quot;max_score&quot;: 1,
        &quot;hits&quot;: [
            {
                &quot;_index&quot;: &quot;megacorp&quot;,
                &quot;_type&quot;: &quot;employee&quot;,
                &quot;_id&quot;: &quot;1&quot;,
                &quot;_score&quot;: 1,
                &quot;_source&quot;: {
                    &quot;first_name&quot;: &quot;John&quot;,
                    &quot;last_name&quot;: &quot;Smith&quot;,
                    &quot;age&quot;: 25,
                    &quot;about&quot;: &quot;I love to go rock climbing&quot;,
                    &quot;interests&quot;: [
                        &quot;sports&quot;,
                        &quot;music&quot;
                    ]
                }
            },
            {
                &quot;_index&quot;: &quot;megacorp&quot;,
                &quot;_type&quot;: &quot;employee&quot;,
                &quot;_id&quot;: &quot;2&quot;,
                &quot;_score&quot;: 1,
                &quot;_source&quot;: {
                    &quot;first_name&quot;: &quot;Jane&quot;,
                    &quot;last_name&quot;: &quot;Smith&quot;,
                    &quot;age&quot;: 32,
                    &quot;about&quot;: &quot;I like to collect rock albums&quot;,
                    &quot;interests&quot;: [
                        &quot;music&quot;
                    ]
                }
            },
            {
                &quot;_index&quot;: &quot;megacorp&quot;,
                &quot;_type&quot;: &quot;employee&quot;,
                &quot;_id&quot;: &quot;3&quot;,
                &quot;_score&quot;: 1,
                &quot;_source&quot;: {
                    &quot;first_name&quot;: &quot;Douglas&quot;,
                    &quot;last_name&quot;: &quot;Fir&quot;,
                    &quot;age&quot;: 35,
                    &quot;about&quot;: &quot;I like to build cabinets&quot;,
                    &quot;interests&quot;: [
                        &quot;forestry&quot;
                    ]
                }
            }
        ]
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3、按条件查询&quot;&gt;3、按条件查询&lt;/h3&gt;
&lt;h4 id=&quot;①、get&quot;&gt;①、get&lt;/h4&gt;
&lt;p&gt;尝试下搜索姓氏为 &lt;code&gt;Smith&lt;/code&gt; 的雇员。、这个方法一般涉及到一个 查询字符串 （query-string） 搜索，因为我们可以通过一个URL参数来传递查询信息给搜索接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /megacorp/employee/_search?q=last_name:Smith
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020032313375298.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;可以看到我们将查询本身赋值给参数 q= 。返回结果给出了所有的 Smith，一共两条。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;took&quot;: 79,
    &quot;timed_out&quot;: false,
    &quot;_shards&quot;: {
        &quot;total&quot;: 1,
        &quot;successful&quot;: 1,
        &quot;skipped&quot;: 0,
        &quot;failed&quot;: 0
    },
    &quot;hits&quot;: {
        &quot;total&quot;: {
            &quot;value&quot;: 2,
            &quot;relation&quot;: &quot;eq&quot;
        },
        &quot;max_score&quot;: 0.47000363,
        &quot;hits&quot;: [
            {
                &quot;_index&quot;: &quot;megacorp&quot;,
                &quot;_type&quot;: &quot;employee&quot;,
                &quot;_id&quot;: &quot;1&quot;,
                &quot;_score&quot;: 0.47000363,
                &quot;_source&quot;: {
                    &quot;first_name&quot;: &quot;John&quot;,
                    &quot;last_name&quot;: &quot;Smith&quot;,
                    &quot;age&quot;: 25,
                    &quot;about&quot;: &quot;I love to go rock climbing&quot;,
                    &quot;interests&quot;: [
                        &quot;sports&quot;,
                        &quot;music&quot;
                    ]
                }
            },
            {
                &quot;_index&quot;: &quot;megacorp&quot;,
                &quot;_type&quot;: &quot;employee&quot;,
                &quot;_id&quot;: &quot;2&quot;,
                &quot;_score&quot;: 0.47000363,
                &quot;_source&quot;: {
                    &quot;first_name&quot;: &quot;Jane&quot;,
                    &quot;last_name&quot;: &quot;Smith&quot;,
                    &quot;age&quot;: 32,
                    &quot;about&quot;: &quot;I like to collect rock albums&quot;,
                    &quot;interests&quot;: [
                        &quot;music&quot;
                    ]
                }
            }
        ]
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;②：post请求&quot;&gt;②：post请求&lt;/h4&gt;
&lt;p&gt;官方文档介绍这是使用查询表达式搜索。&lt;/p&gt;
&lt;p&gt;Query-string 搜索通过命令非常方便地进行临时性的即席搜索 ，但它有自身的局限性（参见 轻量 搜索 ）。Elasticsearch 提供一个丰富灵活的查询语言叫做 查询表达式 ， 它支持构建更加复杂和健壮的查询。&lt;/p&gt;
&lt;p&gt;领域特定语言 （DSL）， 使用 JSON 构造了一个请求。我们可以像这样重写之前的查询所有名为 Smith 的搜索 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST /megacorp/employee/_search
{
    &quot;query&quot; : {
        &quot;match&quot; : {
            &quot;last_name&quot; : &quot;Smith&quot;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323134754497.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;官方文档给出的是get请求，我实在是不知道参数加在哪里，加在header里，没有任何效果，于是我改成了POST请求，请求成功，值得注意的是只有在有条件的时候才能查询成功。&lt;br/&gt;其中与get请求的不同是：不再使用 query-string 参数，而是一个请求体替代。这个请求使用 JSON 构造，并使用了一个 match 查询（属于查询类型之一）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JSON&quot;&gt;{
    &quot;took&quot;: 1,
    &quot;timed_out&quot;: false,
    &quot;_shards&quot;: {
        &quot;total&quot;: 1,
        &quot;successful&quot;: 1,
        &quot;skipped&quot;: 0,
        &quot;failed&quot;: 0
    },
    &quot;hits&quot;: {
        &quot;total&quot;: {
            &quot;value&quot;: 2,
            &quot;relation&quot;: &quot;eq&quot;
        },
        &quot;max_score&quot;: 0.47000363,
        &quot;hits&quot;: [
            {
                &quot;_index&quot;: &quot;megacorp&quot;,
                &quot;_type&quot;: &quot;employee&quot;,
                &quot;_id&quot;: &quot;1&quot;,
                &quot;_score&quot;: 0.47000363,
                &quot;_source&quot;: {
                    &quot;first_name&quot;: &quot;John&quot;,
                    &quot;last_name&quot;: &quot;Smith&quot;,
                    &quot;age&quot;: 25,
                    &quot;about&quot;: &quot;I love to go rock climbing&quot;,
                    &quot;interests&quot;: [
                        &quot;sports&quot;,
                        &quot;music&quot;
                    ]
                }
            },
            {
                &quot;_index&quot;: &quot;megacorp&quot;,
                &quot;_type&quot;: &quot;employee&quot;,
                &quot;_id&quot;: &quot;2&quot;,
                &quot;_score&quot;: 0.47000363,
                &quot;_source&quot;: {
                    &quot;first_name&quot;: &quot;Jane&quot;,
                    &quot;last_name&quot;: &quot;Smith&quot;,
                    &quot;age&quot;: 32,
                    &quot;about&quot;: &quot;I like to collect rock albums&quot;,
                    &quot;interests&quot;: [
                        &quot;music&quot;
                    ]
                }
            }
        ]
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4、查看数据是否存在&quot;&gt;4、查看数据是否存在&lt;/h3&gt;
&lt;p&gt;相对于其他集中请求，这时一种比较少见的请求方式，如果需要查看数据是否存在，将请求方式改为head即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HEAD  /megacorp/employee/1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发送请求后，你也许会疑问，咦，他也没有返回信息啊，那我怎么知道结果呢。别急，听我慢慢道来。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323141539794.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;根据图，我们可以看出，他的确没有返回结果，但是可以注意到，再右上角他会有一个状态码，当有这个信息时，他的状态码就是200，没有就返回404表示找不到。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323141736415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、修改数据&quot;&gt;三、修改数据&lt;/h2&gt;
&lt;p&gt;我们使用了GET和POST查询数据，使用PUT新增数据，根据官方给出的是修改数据还是用PUT，如果存在数据他就会更新数据，这样的模式确实与我们常见的请求使用方法略有不同。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PUT /megacorp/employee/1
{
    &quot;first_name&quot; : &quot;唐&quot;,
    &quot;last_name&quot; :  &quot;菜鸡&quot;,
    &quot;age&quot; :        21,
    &quot;about&quot; :      &quot;I love to go rock climbing&quot;,
    &quot;interests&quot;: [ &quot;movie&quot;, &quot;music&quot; ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发送该请求后，返回参数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;_index&quot;: &quot;megacorp&quot;,
    &quot;_type&quot;: &quot;employee&quot;,
    &quot;_id&quot;: &quot;1&quot;,
    &quot;_version&quot;: 2,
    &quot;result&quot;: &quot;updated&quot;,
    &quot;_shards&quot;: {
        &quot;total&quot;: 2,
        &quot;successful&quot;: 1,
        &quot;failed&quot;: 0
    },
    &quot;_seq_no&quot;: 3,
    &quot;_primary_term&quot;: 3
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们对比可以发现，主要有两处不同，看图你就会说，呀不对呀，明明有四处，那是因为之前插入第一条的时候还只有一条参数，现在有三条了，不许抬杠，不许抬杠，不许抬杠。&lt;br/&gt;不同：他的版本加一，返回状态为created变为updated。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200323140328857.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们再查询一次就会发现他的信息已经发现改变，这就是修改。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;_index&quot;: &quot;megacorp&quot;,
    &quot;_type&quot;: &quot;employee&quot;,
    &quot;_id&quot;: &quot;1&quot;,
    &quot;_version&quot;: 2,
    &quot;_seq_no&quot;: 3,
    &quot;_primary_term&quot;: 3,
    &quot;found&quot;: true,
    &quot;_source&quot;: {
        &quot;first_name&quot;: &quot;唐&quot;,
        &quot;last_name&quot;: &quot;菜鸡&quot;,
        &quot;age&quot;: 21,
        &quot;about&quot;: &quot;I love to go rock climbing&quot;,
        &quot;interests&quot;: [
            &quot;movie&quot;,
            &quot;music&quot;
        ]
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四：删除数据&quot;&gt;四：删除数据&lt;/h2&gt;
&lt;p&gt;根据前面，不用想我们也知道删除数据用的就是delete请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DELETE  /megacorp/employee/2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们删除二号员工，返回如下信息，result变为deleted。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;_index&quot;: &quot;megacorp&quot;,
    &quot;_type&quot;: &quot;employee&quot;,
    &quot;_id&quot;: &quot;2&quot;,
    &quot;_version&quot;: 2,
    &quot;result&quot;: &quot;deleted&quot;,
    &quot;_shards&quot;: {
        &quot;total&quot;: 2,
        &quot;successful&quot;: 1,
        &quot;failed&quot;: 0
    },
    &quot;_seq_no&quot;: 4,
    &quot;_primary_term&quot;: 3
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;当然，elasticsearch的功能不仅仅是如此，这些只是他的基本功能之一，更多请看他的开发文档。 &lt;a href=&quot;https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Mar 2020 14:58:00 +0000</pubDate>
<dc:creator>lomtom</dc:creator>
<og:description>概述： Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。 它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，这是通常没有预料到的。 它存在还因为原始数据如果只是躺在磁</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lomtom/p/12584956.html</dc:identifier>
</item>
<item>
<title>曹工说Spring Boot源码（25）-- Spring注解扫描的瑞士军刀，ASM + Java Instrumentation，顺便提提Jar包破解 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/12584861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/12584861.html</guid>
<description>&lt;p&gt;相关背景及资源：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12044199.html&quot;&gt;曹工说Spring Boot源码（1）-- Bean Definition到底是什么，附spring思维导图分享&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12051957.html&quot;&gt;曹工说Spring Boot源码（2）-- Bean Definition到底是什么，咱们对着接口，逐个方法讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12070377.html&quot;&gt;曹工说Spring Boot源码（3）-- 手动注册Bean Definition不比游戏好玩吗，我们来试一下&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12078673.html&quot;&gt;曹工说Spring Boot源码（4）-- 我是怎么自定义ApplicationContext，从json文件读取bean definition的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12093929.html&quot;&gt;曹工说Spring Boot源码（5）-- 怎么从properties文件读取bean&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12114604.html&quot;&gt;曹工说Spring Boot源码（6）-- Spring怎么从xml文件里解析bean的&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12151809.html&quot;&gt;曹工说Spring Boot源码（7）-- Spring解析xml文件，到底从中得到了什么（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12158935.html&quot;&gt;曹工说Spring Boot源码（8）-- Spring解析xml文件，到底从中得到了什么（util命名空间）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12189842.html&quot;&gt;曹工说Spring Boot源码（9）-- Spring解析xml文件，到底从中得到了什么（context命名空间上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12199334.html&quot;&gt;曹工说Spring Boot源码（10）-- Spring解析xml文件，到底从中得到了什么（context:annotation-config 解析）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12203743.html&quot;&gt;曹工说Spring Boot源码（11）-- context:component-scan，你真的会用吗（这次来说说它的奇技淫巧）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12214408.html&quot;&gt;曹工说Spring Boot源码（12）-- Spring解析xml文件，到底从中得到了什么（context:component-scan完整解析)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12228958.html&quot;&gt;曹工说Spring Boot源码（13）-- AspectJ的运行时织入（Load-Time-Weaving），基本内容是讲清楚了（附源码）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12283544.html&quot;&gt;曹工说Spring Boot源码（14）-- AspectJ的Load-Time-Weaving的两种实现方式细细讲解，以及怎么和Spring Instrumentation集成&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12288391.html&quot;&gt;曹工说Spring Boot源码（15）-- Spring从xml文件里到底得到了什么（context：load-time-weaver 完整解析）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12314954.html&quot;&gt;曹工说Spring Boot源码（16）-- Spring从xml文件里到底得到了什么（aop：config完整解析【上】）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12317612.html&quot;&gt;曹工说Spring Boot源码（17）-- Spring从xml文件里到底得到了什么（aop：config完整解析【中】）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12322587.html&quot;&gt;曹工说Spring Boot源码（18）-- Spring AOP源码分析三部曲，终于快讲完了 (aop：config完整解析【下】)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12359963.html&quot;&gt;曹工说Spring Boot源码（19）-- Spring 带给我们的工具利器，创建代理不用愁（ProxyFactory）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12375656.html&quot;&gt;曹工说Spring Boot源码（20）-- 码网恢恢，疏而不漏，如何记录Spring RedisTemplate每次操作日志&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12384356.html&quot;&gt;曹工说Spring Boot源码（21）-- 为了让大家理解Spring Aop利器ProxyFactory，我已经拼了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12418425.html&quot;&gt;曹工说Spring Boot源码（22）-- 你说我Spring Aop依赖AspectJ，我依赖它什么了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12535152.html&quot;&gt;曹工说Spring Boot源码（23）-- ASM又立功了，Spring原来是这么递归获取注解的元注解的&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12571217.html&quot;&gt;曹工说Spring Boot源码（24）-- Spring注解扫描的瑞士军刀，asm技术实战（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/ckl111/spring-boot-first-version-learn&quot;&gt;工程代码地址&lt;/a&gt; &lt;a href=&quot;https://www.processon.com/view/link/5deeefdee4b0e2c298aa5596&quot;&gt;思维导图地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;工程结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201912/519126-20191215144930717-1919774390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上一篇，我们讲了ASM基本的使用方法，具体包括：复制一个class、修改class版本号、增加一个field、去掉一个field/method等等；同时，我们也知道了怎么才能生成一个全新的class。&lt;/p&gt;
&lt;p&gt;但是，仅凭这点粗浅的知识，我们依然不太理解能干嘛，本篇会带大家实现简单的AOP功能，当然了，学完了之后，可能你像我一样，更困惑了，那说明你变强了。&lt;/p&gt;
&lt;p&gt;本篇的核心是，在JVM加载class的时候，去修改class，修改class的时候，加入我们的aop逻辑。JVM加载class的时候，去修改class，这项技术就是load-time-weaver，实现load-time-weaver有两种方式，这两种方式，核心差别在于修改class的时机不同。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种，定制classloader，在把字节码交给JVM去defineClass之前，去织入切面逻辑&lt;/li&gt;
&lt;li&gt;第二种，利用Java 官方提供的instrumentation机制，注册一个类转换器到 JVM。JVM在加载class的时候，就会传入class的原始字节码数组，回调我们的类转换器，我们类转换器中可以修改原始字节码，并将修改后的字节码数组返回回去，JVM就会用我们修改后的字节码去defineClass了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在直接开始前，声明本篇文章，是基于下面这篇文章中的代码demo，我自己稍做了修改，并附上源码（原文是贴了代码，但是没有直接提供代码地址，不贴心啊）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ArP0CtVZMB2oUYSdjr7RGw&quot;&gt;初探 Java agent&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;目标就是给下面的测试类，加上一点点切面功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.xunche.app;
public class HelloXunChe {
    public static void main(String[] args) throws InterruptedException {
        HelloXunChe helloXunChe = new HelloXunChe();
        helloXunChe.sayHi();
    }
    public void sayHi() throws InterruptedException {
        System.out.println(&quot;hi, xunche&quot;);
        sleep();
    }
    public void sleep() throws InterruptedException {
        Thread.sleep((long) (Math.random() * 200));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们希望，class在执行的时候，能够打印方法执行的耗时，也就是，最终的class，需要是下面这样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.xunche.app;
import org.xunche.agent.TimeHolder;
public class HelloXunChe {
    public HelloXunChe() {
    }
    public static void main(String[] args) throws InterruptedException {
        TimeHolder.start(args.getClass().getName() + &quot;.&quot; + &quot;main&quot;);
        // 业务逻辑开始
        HelloXunChe helloXunChe = new HelloXunChe();
        helloXunChe.sayHi();
        //业务逻辑结束
        HelloXunChe helloXunChe = args.getClass().getName() + &quot;.&quot; + &quot;main&quot;;
        System.out.println(helloXunChe + &quot;: &quot; + TimeHolder.cost(helloXunChe));
    }
    public void sayHi() throws InterruptedException {
        TimeHolder.start(this.getClass().getName() + &quot;.&quot; + &quot;sayHi&quot;);
        System.out.println(&quot;hi, xunche&quot;);
        // 业务逻辑开始
        this.sleep();
        //业务逻辑结束
        String var1 = this.getClass().getName() + &quot;.&quot; + &quot;sayHi&quot;;
        System.out.println(var1 + &quot;: &quot; + TimeHolder.cost(var1));
    }
    public void sleep() throws InterruptedException {
        TimeHolder.start(this.getClass().getName() + &quot;.&quot; + &quot;sleep&quot;);
        // 业务逻辑开始
        Thread.sleep((long)(Math.random() * 200.0D));
        //业务逻辑结束
        String var1 = this.getClass().getName() + &quot;.&quot; + &quot;sleep&quot;;
        System.out.println(var1 + &quot;: &quot; + TimeHolder.cost(var1));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，我们大概就是，要做下面的这样一个切面：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
protected void onMethodEnter() {
    //在方法入口处植入
    String className = getClass().getName();
    String s = className + &quot;.&quot; + methodName;
    TimeHolder.start(s);
}
@Override
protected void onMethodExit(int i) {
    //在方法出口植入
    String className = getClass().getName();
    String s = className + &quot;.&quot; + methodName;
    long cost = TimeHolder.cost(s);
    System.out.println(s + &quot;: &quot; + cost);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，习惯了动态代理的我们，看上面的代码可能会有点误解。上面的代码，不是在执行目标方法前，调用切面；而是：直接把切面代码嵌入了目标方法。&lt;/p&gt;
&lt;p&gt;想必大家都明确了要达成的目标了，下面说，怎么做。&lt;/p&gt;

&lt;p&gt;这部分，大家可以结合开头那个链接一起学习。&lt;/p&gt;
&lt;p&gt;首先，我请大家看看java命令行的选项。直接在cmd里敲java，出现如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200327211420348-254504187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看了和没看一样，那我们再看一张图，在大家破解某些java编写的软件时，可能会涉及到jar包破解，比如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200327211804917-1741007531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家可以使用jad这类反编译软件，打开jar包看下，看看里面是啥：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200327212007173-399106204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，里面有一个MANIFEST.MF文件，里面指定了Premain-Class这个key-value，从这个名字，大家可能知道了，我们平时运行java程序，都是运行main方法，这里来个premain，那这意思，就是在main方法前面插个队呗？&lt;/p&gt;
&lt;p&gt;你说的没有错，确实是插队了，拿上面的破解jar包举例，里面的Premain-Class方法，对应的Agent类，反编译后的代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200327212336147-726302164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;核心代码就是图里那一行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;java.lang.instrument.Instrumentation
public interface Instrumentation {
    /**
     * Registers the supplied transformer. All future class definitions
     * will be seen by the transformer, except definitions of classes upon which any
     * registered transformer is dependent.
     * The transformer is called when classes are loaded, when they are
     * {@linkplain #redefineClasses redefined}. and if &amp;lt;code&amp;gt;canRetransform&amp;lt;/code&amp;gt; is true,
     * when they are {@linkplain #retransformClasses retransformed}.
     * See {@link java.lang.instrument.ClassFileTransformer#transform
     * ClassFileTransformer.transform} for the order
     * of transform calls.
     * If a transformer throws
     * an exception during execution, the JVM will still call the other registered
     * transformers in order. The same transformer may be added more than once,
     * but it is strongly discouraged -- avoid this by creating a new instance of
     * transformer class.
     * &amp;lt;P&amp;gt;
     * This method is intended for use in instrumentation, as described in the
     * {@linkplain Instrumentation class specification}.
     *
     * @param transformer          the transformer to register
     * @param canRetransform       can this transformer's transformations be retransformed
     * @throws java.lang.NullPointerException if passed a &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt; transformer
     * @throws java.lang.UnsupportedOperationException if &amp;lt;code&amp;gt;canRetransform&amp;lt;/code&amp;gt;
     * is true and the current configuration of the JVM does not allow
     * retransformation ({@link #isRetransformClassesSupported} is false)
     * @since 1.6
     */
    void
    addTransformer(ClassFileTransformer transformer, boolean canRetransform);
    
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类，就是官方jdk提供的类，官方的本意呢，肯定是让大家，在加载class的时候，给大家提供一个机会，去修改class，比如，某个第三方jar包，我们需要修改，但是没有源码，就可以这么干；或者是一些要统一处理，不方便在应用中耦合的功能：比如埋点、性能监控、日志记录、安全监测等。&lt;/p&gt;
&lt;p&gt;说回这个方法，参数为ClassFileTransformer，这个接口，就一个方法，大家看看注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       /**
     * ...
     *
         * @param classfileBuffer       the input byte buffer in class file format - must not be modified
     *
     * @throws IllegalClassFormatException if the input does not represent a well-formed class file
     * @return  a well-formed class file buffer (the result of the transform),
                or &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt; if no transform is performed.
     * @see Instrumentation#redefineClasses
     */
    byte[]
    transform(  ClassLoader         loader,
                String              className,
                Class&amp;lt;?&amp;gt;            classBeingRedefined,
                ProtectionDomain    protectionDomain,
                byte[]              classfileBuffer)
        throws IllegalClassFormatException;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;classfileBuffer，就是原始class字节码数组，官方注释说：一定不能修改它&lt;/li&gt;
&lt;li&gt;返回的byte[]数组，注释：一个格式正确的class文件数组，或者null，表示没有进行转换&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;别的也不多说了，反正就是：jvm给你原始class，你自己修改，还jvm一个改后的class。&lt;/p&gt;
&lt;p&gt;所以，大家估计也能猜到破解的原理了，但我还是希望大家：有能力支持正版的话，还是要支持。&lt;/p&gt;
&lt;p&gt;接下来，我们回到我们的目标的实现上。&lt;/p&gt;

&lt;p&gt;完整代码：&lt;a href=&quot;https://gitee.com/ckl111/all-simple-demo-in-work/tree/master/java-agent-premain-demo&quot;&gt;https://gitee.com/ckl111/all-simple-demo-in-work/tree/master/java-agent-premain-demo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;增加类转换器&quot;&gt;增加类转换器&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.xunche.agent;
import org.objectweb.asm.*;
import org.objectweb.asm.commons.AdviceAdapter;

import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.Instrumentation;
import java.security.ProtectionDomain;

public class TimeAgentByJava {
    public static void premain(String args, Instrumentation instrumentation) {
        instrumentation.addTransformer(new TimeClassFileTransformer());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类转换器的详细代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static class TimeClassFileTransformer implements ClassFileTransformer {
        @Override
        public byte[] transform(ClassLoader loader, String className, Class&amp;lt;?&amp;gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {
            if (className.startsWith(&quot;java&quot;) || className.startsWith(&quot;jdk&quot;) || className.startsWith(&quot;javax&quot;) || className.startsWith(&quot;sun&quot;) || className.startsWith(&quot;com/sun&quot;)|| className.startsWith(&quot;org/xunche/agent&quot;)) {
                //return null或者执行异常会执行原来的字节码
                return null;
            }
            // 1
            System.out.println(&quot;loaded class: &quot; + className);
            ClassReader reader = new ClassReader(classfileBuffer);
            // 2
            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
            // 3
            reader.accept(new TimeClassVisitor(writer), ClassReader.EXPAND_FRAMES);
            // 4
            return writer.toByteArray();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;18.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;1处，将原始的类字节码加载到classReader中&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ClassReader reader = new ClassReader(classfileBuffer);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;30&quot;&gt;
&lt;p&gt;2处，将reader传给ClassWriter，这个我们没讲过，大概就是使用classreader中的东西，来构造ClassWriter；可以差不多理解为复制classreader的东西到ClassWriter中。&lt;/p&gt;
&lt;p&gt;大家可以看如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public ClassWriter(final ClassReader classReader, final int flags) {
    super(Opcodes.ASM6);
    symbolTable = new SymbolTable(this, classReader);
    ...
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里new了一个对象，SymbolTable。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;SymbolTable(final ClassWriter classWriter, final ClassReader classReader) {
    this.classWriter = classWriter;
    this.sourceClassReader = classReader;

    // Copy the constant pool binary content.
    byte[] inputBytes = classReader.b;
    int constantPoolOffset = classReader.getItem(1) - 1;
    int constantPoolLength = classReader.header - constantPoolOffset;
    constantPoolCount = classReader.getItemCount();
    constantPool = new ByteVector(constantPoolLength);
    constantPool.putByteArray(inputBytes, constantPoolOffset, constantPoolLength);
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家直接看上面的注释吧，&lt;code&gt;Copy the constant pool binary content&lt;/code&gt;。反正吧，基本可以理解为，classwriter拷贝了classreader中的一部分东西，应该不是全部。&lt;/p&gt;
&lt;p&gt;为什么不是全部，因为我试了下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void main(String[] args) throws IOException {
        ClassReader reader = new ClassReader(&quot;org.xunche.app.HelloXunChe&quot;);
        ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
        byte[] bytes = writer.toByteArray();

        File file = new File(
&quot;F:\\gitee-ckl\\all-simple-demo-in-work\\java-agent-premain-demo\\test-agent\\src\\main\\java\\org\\xunche\\app\\HelloXunChe.class&quot;);
        FileOutputStream fos = new FileOutputStream(file);
        fos.write(bytes);
        fos.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这样，出来的class文件，是破损的，格式不正确的，无法反编译。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;3处，使用TimeClassVisitor作为writer的中间商，此时，顺序变成了：&lt;/p&gt;
&lt;p&gt;classreader --&amp;gt; TimeClassVisitor --&amp;gt; classWriter&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;4处，返回writer的字节码，给jvm；jvm使用该字节码，去redefine一个class出来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;类转换器的具体实现&quot;&gt;类转换器的具体实现&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static class TimeClassVisitor extends ClassVisitor {
        public TimeClassVisitor(ClassVisitor classVisitor) {
            super(Opcodes.ASM6, classVisitor);
        }
        // 1
        @Override
        public MethodVisitor visitMethod(int methodAccess, String methodName, String methodDesc, String signature, String[] exceptions) {
            MethodVisitor methodVisitor = cv.visitMethod(methodAccess, methodName, methodDesc, signature, exceptions);
            // 2 
            return new TimeAdviceAdapter(Opcodes.ASM6, methodVisitor, methodAccess, methodName, methodDesc);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;1处，visitMethod方法，会返回一个MethodVisitor，ASM会拿着我们返回的methodVisitor，去访问当前这个方法&lt;/li&gt;
&lt;li&gt;2处，new了一个适配器，TimeAdviceAdapter。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200327220356649-590969868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们这里的TimeAdviceAdapter，主要是希望在方法执行前后做点事，类似于切面，所以继承了一个AdviceAdapter，这个AdviceAdaper，帮我们实现了MethodVisitor的全部方法，我们只需要覆写我们想要覆盖的方法即可。&lt;/p&gt;
&lt;p&gt;比如，AdviceAdaper，因为继承了MethodVisitor，其visitCode方法，会在访问方法体时被回调：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
  public void visitCode() {
    super.visitCode();
    // 1
    onMethodEnter();
  }
  //2 
  protected void onMethodEnter() {}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;1处，回调本来的onMethodEnter，是一个空实现，就是留给子类去重写的。&lt;/li&gt;
&lt;li&gt;2处，可以看到，空实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，我们最终的TimeAdviceAdaper，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static class TimeAdviceAdapter extends AdviceAdapter {
        private String methodName;
        protected TimeAdviceAdapter(int api, MethodVisitor methodVisitor, int methodAccess, String methodName, String methodDesc) {
            super(api, methodVisitor, methodAccess, methodName, methodDesc);
            this.methodName = methodName;
        }
        @Override
        protected void onMethodEnter() {
            //在方法入口处植入
            if (&quot;&amp;lt;init&amp;gt;&quot;.equals(methodName)|| &quot;&amp;lt;clinit&amp;gt;&quot;.equals(methodName)) {
                return;
            }
            String className = getClass().getName();
            String s = className + &quot;.&quot; + methodName;
            TimeHolder.start(s);
        }
        @Override
        protected void onMethodExit(int i) {
            //在方法出口植入
            if (&quot;&amp;lt;init&amp;gt;&quot;.equals(methodName) || &quot;&amp;lt;clinit&amp;gt;&quot;.equals(methodName)) {
                return;
            }
            String className = getClass().getName();
            String s = className + &quot;.&quot; + methodName;
            long cost = TimeHolder.cost(s);
            System.out.println(s + &quot;: &quot; + cost);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这份代码看着可还行？可惜啊，是假的，是错误的！写asm这么简单的话，那我要从梦里笑醒。&lt;/p&gt;
&lt;p&gt;为啥是假的，因为：真正的代码，是长下面这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200327221231165-1059191288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里，是不是想溜了，这都啥玩意，看不懂啊，不过不要着急，办法总比困难多。&lt;/p&gt;
&lt;h2 id=&quot;类转换器的真正实现方法&quot;&gt;类转换器的真正实现方法&lt;/h2&gt;
&lt;p&gt;我们先装个idea插件，叫：&lt;code&gt;asm-bytecode-outline&lt;/code&gt;。这个插件的作用，简而言之，就是帮你把java代码翻译成ASM的写法。在线装不了的，可以离线装：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10254-asm-bytecode-outline-2017&quot;&gt;asm-bytecode-outline&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;装好插件后，只要在我们的TimeAdviceAdapter类，点右键：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200327221612230-1097509083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就会生成我们需要的ASM代码，然后拷贝：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200327221749992-576552128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;什么时候拷贝结束呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;c:%5CUsers%5CADMINI~1%5CAppData%5CLocal%5CTemp%5C1585318732857.png&quot; alt=&quot;1585318732857&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本上，这样就可以了。&lt;/p&gt;
&lt;h2 id=&quot;填坑指南&quot;&gt;填坑指南&lt;/h2&gt;
&lt;p&gt;作为一个常年掉坑的人，我在这个坑里也摸爬了整整一天。&lt;/p&gt;
&lt;p&gt;大家可以看到，我们的java写的方法里，是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        @Override
        protected void onMethodEnter() {
            //在方法入口处植入
            if (&quot;&amp;lt;init&amp;gt;&quot;.equals(methodName)|| &quot;&amp;lt;clinit&amp;gt;&quot;.equals(methodName)) {
                return;
            }
            String className = getClass().getName();
            // 1.
            String s = className + &quot;.&quot; + methodName;
            TimeHolder.start(s);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;1处，访问了本地field，methodName&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，asm也帮我们贴心地生成了这样的语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mv.visitFieldInsn(Opcodes.GETFIELD, &quot;org/xunche/agent/TimeAgentByJava$TimeAdviceAdapter&quot;, &quot;methodName&quot;, &quot;Ljava/lang/String;&quot;);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来就像是说，访问org/xunche/agent/TimeAgentByJava$TimeAdviceAdapter类的methodName字段。&lt;/p&gt;
&lt;p&gt;但是，这是有问题的。因为，这段代码，最终aop切面会被插入到target：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class HelloXunChe {
    private String methodName = &quot;abc&quot;;
    public static void main(String[] args) throws InterruptedException {
        HelloXunChe helloXunChe = new HelloXunChe();
        helloXunChe.sayHi();
    }
    public void sayHi() throws InterruptedException {
        System.out.println(&quot;hi, xunche&quot;);
        sleep();
    }

    public void sleep() throws InterruptedException {
        Thread.sleep((long) (Math.random() * 200));
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我实话跟你说，这个target类里，压根访问不到org/xunche/agent/TimeAgentByJava$TimeAdviceAdapter类的methodName字段。&lt;/p&gt;
&lt;p&gt;我是怎么发现这个问题的，之前一直报错，直到我在target后来加了这么一行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class HelloXunChe {
    private String methodName = &quot;abc&quot;;
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哎，没个大佬带我，真的难。&lt;/p&gt;
&lt;p&gt;当然，我是通过这个确认了上述问题，最终解决的思路呢，就是：把你生成的class，反编译出来看看，看看是不是你想要的。&lt;/p&gt;
&lt;p&gt;所以，我专门写了个main测试类，来测试改后的class是否符合预期。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SaveGeneratedClassWithOriginAgentTest {

    public static void main(String[] args) throws IOException {
        //1
        ClassReader reader = new ClassReader(&quot;org.xunche.app.HelloXunChe&quot;);
        ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
        reader.accept(new TimeAgentByJava.TimeClassVisitor(writer), ClassReader.EXPAND_FRAMES);
        byte[] bytes = writer.toByteArray();
            
        // 2
        File file = new File(
&quot;F:\\ownprojects\\all-simple-demo-in-work\\java-agent-premain-demo\\test-agent\\src\\main\\java\\org\\xunche\\app\\HelloXunCheCopy2.class&quot;);
        FileOutputStream fos = new FileOutputStream(file);
        fos.write(bytes);
        fos.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;1处这段代码，就是模拟在classTransformer中的那段。&lt;/li&gt;
&lt;li&gt;2处，将最终要返回给jvm的那段class字节码，写到一个文件里，然后我们就可以反编译，看看有问题没。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，上面那段asm，大家如果看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ArP0CtVZMB2oUYSdjr7RGw&quot;&gt;初探 Java agent&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;会发现，访问methodname那句代码，是这么写的：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mv.visitLdcInsn(methodName);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这就是，相当于直接把methodName写死到最终的class里去了；最终的class就会是想要的样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void sayHi() throws InterruptedException {
        //1 
        TimeHolder.start(this.getClass().getName() + &quot;.&quot; + &quot;sayHi&quot;);
        System.out.println(&quot;hi, xunche&quot;);
        this.sleep();
        // 2
        String var1 = this.getClass().getName() + &quot;.&quot; + &quot;sayHi&quot;;
        System.out.println(var1 + &quot;: &quot; + TimeHolder.cost(var1));
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;1/2处，直接把sayHi写死到target了，而不是此时再去访问field。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;maven插件配置premain-class&quot;&gt;maven插件配置premain-class&lt;/h2&gt;
&lt;p&gt;插件中，配置Premain-Class&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.3.1&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;archive&amp;gt;
                        &amp;lt;manifest&amp;gt;
                            &amp;lt;addClasspath&amp;gt;true&amp;lt;/addClasspath&amp;gt;
                        &amp;lt;/manifest&amp;gt;
                        &amp;lt;manifestEntries&amp;gt;
                            &amp;lt;Premain-Class&amp;gt;
                                org.xunche.agent.TimeAgent
                            &amp;lt;/Premain-Class&amp;gt;
                        &amp;lt;/manifestEntries&amp;gt;
                    &amp;lt;/archive&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;测试模块，没啥开发的，就只有那个target那个类。&lt;/p&gt;

&lt;p&gt;最终我是这么运行的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;java -javaagent:agent.jar -classpath lib/*;java-agent-premain-demo.jar org/xunche/app/He
lloXunChe
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里指定了lib目录，主要是agent模块需要的jar包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202003/519126-20200327223600517-1086274030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单的运行效果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;loaded class: org/xunche/app/HelloXunChe
methodName = 0 &amp;lt;init&amp;gt;
methodName = 0 main
methodName = 0 sayHi
methodName = 0 sleep
hi, xunche
org.xunche.app.HelloXunChe.abc: 129
org.xunche.app.HelloXunChe.abc: 129
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;ASM这个东西，想要不熟悉字节码就去像我上面这样傻瓜操作，坑还是比较多的，比较难趟。回头有空再介绍字节码吧。我也是半桶水，大家一起学习吧。&lt;br/&gt;本节源码：&lt;br/&gt;&lt;a href=&quot;https://gitee.com/ckl111/all-simple-demo-in-work/tree/master/java-agent-premain-demo&quot;&gt;https://gitee.com/ckl111/all-simple-demo-in-work/tree/master/java-agent-premain-demo&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Mar 2020 14:42:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>写在前面的话 相关背景及资源： &amp;quot;曹工说Spring Boot源码（1） Bean Definition到底是什么，附spring思维导图分享&amp;quot; &amp;quot;曹工说Spring B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/12584861.html</dc:identifier>
</item>
<item>
<title>跟面试官侃半小时MySQL事务隔离性，从基本概念深入到实现 - 阿丸</title>
<link>http://www.cnblogs.com/awan-note/p/12584757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/awan-note/p/12584757.html</guid>
<description>&lt;p&gt;提到MySQL的事务，我相信对MySQL有了解的同学都能聊上几句，无论是面试求职，还是日常开发，MySQL的事务都跟我们息息相关。&lt;/p&gt;
&lt;p&gt;而事务的ACID（即原子性Atomicity、一致性Consistency、隔离性Isolation、持久性Durability）可以说涵盖了事务的全部知识点，所以，我们不仅要知道ACID是什么，还要了解ACID背后的实现，只有这样，无论在日常开发还是面试求职，都能无往而不利。&lt;/p&gt;
&lt;p&gt;为了大家更好的阅读体验，对ACID的深入分析将分为上下两篇。&lt;/p&gt;
&lt;p&gt;本篇为上篇，主要围绕ACID中的I,也就是“隔离性”展开，从基本概念，到隔离性的实现，最后以一个实战案例进行融会贯通。&lt;/p&gt;
&lt;blockquote class=&quot;pgc-blockquote-abstract article-blockquote&quot; readability=&quot;30&quot;&gt;
&lt;p&gt;嗯，看完你都能理解，那跟面试官侃半小时隔离性就没问题了。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;Isolation,隔离性，也有人称之为并发控制（concurrency control）。事务的隔离性要求每个事务读写的对象对其他事务都是相互隔离的，也就是这个事务提交前，这个事务的修改内容对其他事务都是不可见的。事务的隔离性，主要是解决不同事物之间的相互读写影响。&lt;/p&gt;
&lt;p&gt;所谓的读写影响注意分为三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;脏读：读到了别的事务尚未提交（commit）的变更，别人没提交，我读到了。&lt;/li&gt;
&lt;li&gt;不可重复读：别的事务提交了变更，被当前事务读到了。然后导致本事务多次select的结果不一样，读到了别的事务提交的内容。&lt;/li&gt;
&lt;li&gt;幻读：也是读到了别的事务提交的内容，但是跟上面的不同之处在于，读到了原本不存在的记录。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，不可重复读，主要是读到了别的事务update的内容。而幻读，是读到了别的事务insert的内容。&lt;/p&gt;

&lt;p&gt;为了解决事务隔离性的问题，数据库一般会有不同的隔离级别来解决相应的读写影响。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读未提交：一个事务B还没提交，它的修改就被别的事务A读到了。&lt;/li&gt;
&lt;li&gt;读已提交：一个事务B提交后，它的修改被其他事务A看到了。&lt;/li&gt;
&lt;li&gt;可重复读：一个事物B提交前和提交后，事务A都无法读到事务B的变更。&lt;/li&gt;
&lt;li&gt;串行化：对同一行记录，当出现不同事物的读写冲突时，是通过串行化的方式解决的，后一个事务必须等前一个事务完成才能执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同隔离级别能够解决不同的隔离性问题。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/7fa847b957b24f67931021b180ad37c1&quot; alt=&quot;跟面试官侃半小时MySQL事务隔离性，从基本概念深入到实现&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;需要注意的是，这是标准事务隔离级别的定义。在MySQL的innodb引擎中，在可重复读级别下，通过mvcc解决了幻读的问题，具体实现我们后面再讲。&lt;/p&gt;
&lt;p&gt;同时，需要注意的是，到目前为止，我们说的读，都是”快照读”，普通的select。后面我们还会提到“当前读”，是不一样的哦。&lt;/p&gt;

&lt;p&gt;要实现事务的隔离性，需要了解两个方面的内容，一个是锁，一个是多版本并发控制（MVCC）。&lt;/p&gt;

&lt;p&gt;InnoDB中，实现了两种标准的行级锁：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;共享锁（S Lock），也叫读锁，允许事务读取一行数据。&lt;/li&gt;
&lt;li&gt;排它锁（X Lock），也叫写锁，允许事务删除或者更新一行数据（注意，这里没有提到插入哦，插入涉及到幻读，可以看文章最后的说明）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;普通select语句不会有任何锁，那么如何获得共享锁和排它锁呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Select … lock in share mode语句能够获得共享锁&lt;/li&gt;
&lt;li&gt;Select … for update（特殊的select，用mysql简单实现分布式锁经常用它）、Update、delete语句能够获得排它锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当一个事务A已经获得了行r的共享锁，那么另一个事务B可以立刻获得行r的共享锁，因为不会改变r的数值，这种叫做锁兼容。&lt;/p&gt;
&lt;p&gt;如果这时候有事务C希望获得行r的排它锁，那么就必须等待事务A和事务B释放行r的共享锁之后，才能获得排它锁，这种叫做锁不兼容。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/dea648b19912400385ff5fdae0e4549f&quot; alt=&quot;跟面试官侃半小时MySQL事务隔离性，从基本概念深入到实现&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;普通的select不会对行上锁，而select…lock in share mode会上共享锁，select…for update会上排它锁。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于普通的select的读取方式，称为”快照读“，也叫”一致性非锁定读“。&lt;/li&gt;
&lt;li&gt;对于带锁的select读取，或者update tb set a = a+1（读取a的当前值），称为“当前读”，也叫“一致性锁定读”。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果在update、insert的时候，不能进行select，那么服务的并发访问性能就太差了。因此，我们日常的查询，都是“快照读”，不会上锁，只有在update\insert\“当前读”的时候，才会上锁。而为了解决“快照读”的并发访问问题，就引入了MVCC。&lt;/p&gt;

&lt;p&gt;如果说上面的行锁是一种悲观锁，那么MVCC就是一种乐观锁的实现方式，而且是一种很常用的乐观锁实现方式。&lt;/p&gt;
&lt;p&gt;所谓多版本，就是一行记录在数据库中存储了多个版本，每个版本以事务ID作为版本号。InnoDB 里面每个事务有一个唯一的事务 ID，是在事务开始的时候向InnoDB的事务系统申请的，并且按照申请顺序严格递增的。假如一行记录被多个事务更新，那么，就会产生多个版本的记录。&lt;/p&gt;
&lt;p&gt;以某一行数据作为例子：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/b7fb1e80dc7d4a3ab9262c407a94dd42&quot; alt=&quot;跟面试官侃半小时MySQL事务隔离性，从基本概念深入到实现&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;经过两次事务的操作，value从22变成了19，同时，保留了三个事务id，15、25、30。&lt;/p&gt;
&lt;p&gt;在每个记录多版本的基础上，需要利用“一致性视图”，来做版本的可见性判断。&lt;/p&gt;
&lt;p&gt;这里，我们要区分MySQL里面的两个”视图”概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个是view，通过语法create view … 实现，主要创建一个虚拟表，用来执行查询语句。&lt;/li&gt;
&lt;li&gt;一个是InnoDB用来实现mvcc的一致性视图（consistent read view），纯逻辑概念，没有物理结构，定义了在事务期间，你能看到哪些版本的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们全文提到的“视图”都是第二种，主要是支持InnoDB在“读已提交”和“可重复读”级别的并发访问问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“读未提及”级别下，没有一致性视图&lt;/li&gt;
&lt;li&gt;“读已提交”级别下，会在 每个SQL开始执行的时候 创建一致性视图&lt;/li&gt;
&lt;li&gt;“可重复读”级别下，会在 每个事务开始的时候 创建一致性视图&lt;/li&gt;
&lt;li&gt;“串行化”级别下，直接通过加锁避免并发问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面，我们简单介绍一下创建一致性视图的逻辑。&lt;/p&gt;
&lt;p&gt;以“可重复读”级别为例。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当一个事务开启的时候，会向系统申请一个新事务id&lt;/li&gt;
&lt;li&gt;此时，可能还有多个正在进行的其他事务没有提交，因此在瞬时时刻，是有多个活跃的未提交事务id&lt;/li&gt;
&lt;li&gt;将这些未提交的事务id组成一个数组，数组里面最小的事务id记录为低水位，当前系统创建过的事务id的最大值+1记录为高水位&lt;/li&gt;
&lt;li&gt;这个数组array 和 高水位，就组成了“一致性视图”。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有了一致性视图后，我们就可以判断一行数据的多版本可见性了，无论是“读已提交”还是“可重复读”级别，可见性判断规则是一样的，区别在于创建快照（一致性视图）的时间。&lt;/p&gt;
&lt;p&gt;在当前事务中，读取其他某一行的记录，对其中的版本号的可见性判断有五种情况（建议自己跟着捋一捋，挺重要的）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果版本号小于“低水位”，说明事务已经提交，那肯定 可见；&lt;/li&gt;
&lt;li&gt;如果版本号大于“高水位”，说明这行数据的这个事务id版本是在快照后产生的，那肯定 不可见；&lt;/li&gt;
&lt;li&gt;如果版本号在事务数组array中，说明这个事务还没提交，所以 不可见；&lt;/li&gt;
&lt;li&gt;如果版本号不在事务数组array中，且低于高水位，说明这个事务已经提交，所以 可见；&lt;/li&gt;
&lt;li&gt;当然，无论什么时候，自己的事务id中的任何变化，都是可见的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看看下面这个例子，更容易理解。&lt;/p&gt;
&lt;blockquote readability=&quot;27&quot;&gt;
&lt;p&gt;系统创建过的事务id：1,2,3,4,5,6,7,8,9,10,11,12,13,14,15&lt;/p&gt;
&lt;p&gt;事务A启动，拍个快照&lt;/p&gt;
&lt;p&gt;此时未提交的事务id有：7，8，9&lt;/p&gt;
&lt;p&gt;一致性视图：数组array[7,8,9] + 高水位16（15+1）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于任意一行数据的可见性判断如下：&lt;/p&gt;
&lt;p&gt;1）小于7的，可见&lt;/p&gt;
&lt;p&gt;2）大于16的，说明是快照后产生的，不可见&lt;/p&gt;
&lt;p&gt;3）10-15，不在数组array中，说明已经提交了，可见&lt;/p&gt;
&lt;p&gt;4）7，8，9在array中，说明未提交，不可见&lt;/p&gt;
&lt;p&gt;两个重要结论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。&lt;/li&gt;
&lt;li&gt;MVCC的实现，就是根据当前事务的事务id为依据创建“一致性视图”，利用一致性视图来判断数据版本的可见性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面，我们来两个实战案例，将上面的基础概念与实现融会贯通吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）并发select&amp;amp;update 案例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;id=1 的value初始为1。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p9.pstatp.com/large/pgc-image/a9796f3bcfba4a4989eb62a67ab45520&quot; alt=&quot;跟面试官侃半小时MySQL事务隔离性，从基本概念深入到实现&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们看下，在不同隔离级别，Time5、Time7、Time9事务A查询到的value 分布为多少。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“读未提交”：2，2，2&lt;/li&gt;
&lt;li&gt;“读以提交”：1，2，2&lt;/li&gt;
&lt;li&gt;“可重复读”：1，1，2&lt;/li&gt;
&lt;li&gt;串行化：1，1，2（注意，这里在事务A提交前，事务B都会阻塞，直到事务A提交后才能执行）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）并发update案例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;id=1 的value初始为1，在可重复读级别：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/591ac0b9591848ef848532e71126e578&quot; alt=&quot;跟面试官侃半小时MySQL事务隔离性，从基本概念深入到实现&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们看一下，你猜猜事务A和事务B读取的value是多少？&lt;/p&gt;
&lt;p&gt;答案是：1 和 3&lt;/p&gt;
&lt;p&gt;可能会产生困惑，事务A在启动后快照，所以读到了1是正常的，但是事务2在启动的时候快照了，然后在自己的事务中+1，怎么会读到3而不是2呢？&lt;/p&gt;
&lt;p&gt;原因很简单，即使是在可重复读的级别，事务 更新数据 的时候，只能用当前读（想想也能理解，不然update就出现数据不一致了）。&lt;/p&gt;
&lt;p&gt;如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。&lt;/p&gt;
&lt;p&gt;这里，我们需要注意的是事务的启动时机。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动,一致性视图是在执行第一个快照读语句时创建的。&lt;/li&gt;
&lt;li&gt;如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令，一致性视图是在执行 start transaction with consistent snapshot 时创建的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先明确一下，什么是幻读？开篇介绍了什么是幻读，这里再申明一下幻读出现的场景&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一：事务的隔离级别为可重复读，且是当前读&lt;/li&gt;
&lt;li&gt;第二：幻读仅专指新插入的行，在范围查询中，后一次查询出现了新的数据行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前文已经提到了，对于普通数据库，需要到可串行化的隔离级别才能解决幻读问题。&lt;/p&gt;
&lt;p&gt;而对于InnoDB存储引擎来说，在可重复读级别下就能解决幻读问题。&lt;/p&gt;
&lt;p&gt;InnoDB存储引擎有三种行锁算法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;行锁：当个行记录上的锁&lt;/li&gt;
&lt;li&gt;间隙锁：Gap Lock，锁定一个范围，但不包含记录本身&lt;/li&gt;
&lt;li&gt;Next-Key Lock:就是行锁+间隙锁，同时锁上一个范围，并且锁定记录本身&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;InnoDB就是通过Next-Key Lock解决了幻读的问题，具体内容可以看我之前的文章： &lt;a class=&quot;pgc-link&quot; href=&quot;https://www.cnblogs.com/awan-note/p/12423355.html&quot; target=&quot;_blank&quot; data-content=&quot;mp&quot;&gt;前阿里数据库专家总结的MySQL里的各种锁（下篇）&lt;/a&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;看到这里了，原创不易，点个关注、点个赞吧，你最好看了～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4.030534351145&quot;&gt;
&lt;p&gt;知识碎片重新梳理，构建Java知识图谱：&lt;a href=&quot;https://github.com/saigu/JavaKnowledgeGraph&quot;&gt;https://github.com/saigu/JavaKnowledgeGraph&lt;/a&gt;（历史文章查阅非常方便）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;扫码关注我的公众号“阿丸笔记”，第一时间获取最新更新。同时可以免费获取海量Java技术栈电子书、各个大厂面试题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;https://img-blog.csdnimg.cn/20200216153626581.jpg&quot; alt=&quot;阿丸笔记&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Mar 2020 14:20:00 +0000</pubDate>
<dc:creator>阿丸</dc:creator>
<og:description>提到MySQL的事务，我相信对MySQL有了解的同学都能聊上几句，无论是面试求职，还是日常开发，MySQL的事务都跟我们息息相关。 而事务的ACID（即原子性Atomicity、一致性Consiste</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/awan-note/p/12584757.html</dc:identifier>
</item>
<item>
<title>设计模式 - 适配器模式详解 - 农夫三拳有点疼~</title>
<link>http://www.cnblogs.com/songjilong/p/12584633.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songjilong/p/12584633.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;生活中，充电插头有两脚的、三脚的，还有圆形的，如果想使这些插头都能工作，就需要一个多功能适配器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200327171032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本介绍&quot;&gt;基本介绍&lt;/h2&gt;
&lt;p&gt;适配器模式（Adapter Pattern）属于&lt;strong&gt;结构性模式&lt;/strong&gt;，它可以将某个类的接口转换为客户端期望的另一个接口表示，主要目的是&lt;strong&gt;兼容性&lt;/strong&gt;，让原本因接口不匹配不能一起工作的两个类可以协同工作，其别名为&lt;strong&gt;包装器&lt;/strong&gt;（Wrapper）。适配器模式主要分为三类：&lt;strong&gt;类适配器模式&lt;/strong&gt;、&lt;strong&gt;对象适配器模式&lt;/strong&gt;、&lt;strong&gt;接口适配器模式&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;工作原理&quot;&gt;工作原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200327172553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;让原本接口不兼容的类可以兼容&lt;/li&gt;
&lt;li&gt;从用户的角度看不到被适配者，是解耦的&lt;/li&gt;
&lt;li&gt;用户调用适配器转化出来的目标接口方法，适配器去再调用被适配者的相关接口方法&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;类适配器模式&quot;&gt;类适配器模式&lt;/h2&gt;
&lt;h3 id=&quot;实现原理&quot;&gt;实现原理&lt;/h3&gt;
&lt;p&gt;Adapter 类继承 src 类，实现 dst 接口，完成 src 对 dst 的适配。&lt;/p&gt;
&lt;h3 id=&quot;案例&quot;&gt;案例&lt;/h3&gt;
&lt;p&gt;插座（Voltage220V）的输出电压是220V，充电插头（Voltage5V）输出电压是5V，这时候就需要一个适配器（VoltageAdapter）转换电压，才能给手机（Phone）充电&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;电源输出电压为220V&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Voltage220V {
    public int output220V() {
        int src = 220;
        System.out.println(&quot;电源输出&quot; + src + &quot;V&quot;);
        return src;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;充电器输出电压为5V&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Voltage5V {
    int output5V();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;适配器需要将220V转为5V&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class VoltageAdapter extends Voltage220V implements Voltage5V {
    @Override
    public int output5V() {
        int src = super.output220V();
        int dst = src / 44;
        System.out.println(&quot;转换为&quot; + dst + &quot;V&quot;);
        return dst;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机接收5V电压，判断电压是否为5V&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Phone {
    public static void charging(Voltage5V voltage5V){
        int v = voltage5V.output5V();
        if(v == 5){
            System.out.println(&quot;接收电压为5V，正常充电&quot;);
        }else if(v &amp;gt; 5){
            System.out.println(&quot;电压高于5V，无法充电&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test01(){
    System.out.println(&quot;====类适配器模式====&quot;);
    Phone.charging(new VoltageAdapter());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;====类适配器模式====
电源输出220V
转换为5V
接收电压为5V，正常充电
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;由于 Java 是单继承机制，所以类适配器模式有一定的&lt;strong&gt;局限性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;src 类的方法再 Adapter 中都会暴露出来，&lt;strong&gt;增加了使用的成本&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;由于继承了 src 类，所以它可以重写父类方法，使 Adapter 的&lt;strong&gt;灵活性增强了&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;对象适配器模式&quot;&gt;对象适配器模式&lt;/h2&gt;
&lt;h3 id=&quot;实现原理-2&quot;&gt;实现原理&lt;/h3&gt;
&lt;p&gt;基本的思路和类的适配器模式相同，只是将 Adapter 类做修改，&lt;strong&gt;使用聚合关系替代继承关系&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码实现-2&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;沿用前面的代码，新建一个适配器，只是将原来的 Adapter 继承 src 类换为聚合的关系&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class VoltageAdapter2 implements Voltage5V {

    private Voltage220V voltage220V;

    public VoltageAdapter2(){
        this.voltage220V = new Voltage220V();
    }

    @Override
    public int output5V() {
        int src = this.voltage220V.output220V();
        int dst = src / 44;
        return dst;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test02(){
    System.out.println(&quot;====对象适配器模式====&quot;);
    Phone.charging(new VoltageAdapter2(new Voltage220V()));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;====对象适配器模式====
电源输出220V
转换为5V
接收电压为5V，正常充电
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;接口适配器模式&quot;&gt;接口适配器模式&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;接口适配器模式也可称为&lt;strong&gt;缺省适配器模式&lt;/strong&gt;，当不需要实现接口的全部方法时，可先设计一个抽象类实现接口，并为该接口的每个方法都提供一个&lt;strong&gt;默认实现&lt;/strong&gt;，那么该抽象类的子类就可以&lt;strong&gt;有选择的&lt;/strong&gt;覆盖父类的某些方法来实现需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;适用于一个接口不想使用其所有的方法的情况&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码实现-3&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;写一个接口，里面定义一些方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface InterfaceMethod {
    void m1();
    void m2();
    void m3();
    void m4();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个抽象类，实现该接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class AbstractAdapter implements InterfaceMethod {
    @Override
    public void m1() {
    }

    @Override
    public void m2() {
    }

    @Override
    public void m3() {
    }

    @Override
    public void m4() {
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test(){
    //使用匿名内部类的方式
    AbstractAdapter adapter = new AbstractAdapter() {
        @Override
        public void m1() {
            System.out.println(&quot;我要用m1方法&quot;);
        }
    };
    adapter.m1();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我要用m1方法
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;三种命名方式是根据 src 是以怎样的形式给到 Adapter (在Adapter里的形式)来命名的。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;类适配器：以类给到，在 Adapter 里，就是将 src 当做类，&lt;strong&gt;继承&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对象适配器：以对象给到，在 Adapter 里， 将 src 作为一个对象，&lt;strong&gt;持有&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 27 Mar 2020 13:55:00 +0000</pubDate>
<dc:creator>农夫三拳有点疼~</dc:creator>
<og:description>适配器模式 生活中，充电插头有两脚的、三脚的，还有圆形的，如果想使这些插头都能工作，就需要一个多功能适配器 基本介绍 适配器模式（Adapter Pattern）属于 结构性模式 ，它可以将某个类的接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/songjilong/p/12584633.html</dc:identifier>
</item>
<item>
<title>【面试QA-基本模型】RNN 与 CNN - 西多士NLP</title>
<link>http://www.cnblogs.com/sandwichnlp/p/12578733.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sandwichnlp/p/12578733.html</guid>
<description>&lt;h4 id=&quot;为什么传统-cnn-适用于-cv-任务，rnn-适用于-nlp-任务&quot;&gt;为什么传统 CNN 适用于 CV 任务，RNN 适用于 NLP 任务&lt;/h4&gt;
&lt;p&gt;从模型特点上来说：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对于 CNN 每一个卷积核都可以看作是一个滤波器，卷积运算的本质是互相关运算，每个卷积核仅对于具有特定特征具有较大的激活值，而且 CNN 有参数共享和局部连接的特点，能够提取图像上不同位置的同一个特征，即 CNN 具有平移不变性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;RNN 的特点在于其是一个时序模型，在对每个神经元不仅可以接收当前时刻的输入信息，还将接收上一个时刻的该神经元的输出信息，具有短期记忆能力。这在用于 NLP 任务时相当于隐含着建立了一个语言模型，这对词序具有很强的区分能力。而 CNN 和 DNN 均类似词袋模型，丢失的词序特征。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从数据特征上来说&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图像矩阵中的每个元素为图像中的像素值，每个像素与其周围元素都是高度相关的&lt;/li&gt;
&lt;li&gt;文本矩阵中的数据为词的 embedding 向量，每个元素在词向量内与词向量间的相邻元素的关联性是不同的，因此 CNN 用于 NLP 任务常使用的是一维卷积&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;cnn-与-fcn-相比有什么优点？&quot;&gt;CNN 与 FCN 相比有什么优点？&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;CNN 相比于 FCN 具有更少的参数，主要有下面两个原因：
&lt;ul&gt;&lt;li&gt;参数共享：一个卷积核能对样本图像上的所有区域采用相同的参数进行特征检测。&lt;/li&gt;
&lt;li&gt;稀疏连接：在每一层中，由于滤波器的尺寸限制，输入和输出之间的连接是稀疏的，每个输出值只取决于输入在局部的一小部分值。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;池化层降维：池化过程则在卷积后很好地聚合了特征，通过降维来减少运算量。&lt;/li&gt;
&lt;li&gt;由于 CNN 参数数量较小，所需的训练样本就相对较少，因此在一定程度上不容易发生过拟合现象。&lt;/li&gt;
&lt;li&gt;平移不变性：CNN 比较擅长捕捉区域位置偏移。即进行物体检测时，不太受物体在图片中位置的影响，增加检测的准确性和系统的健壮性。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;cnn的相关计算&quot;&gt;CNN的相关计算&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;输出维度计算&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输出维度 = (输入维度 - 卷积核大小 + 2*Padding长度)/步长 + 1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;感受野的计算&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第k-1层的感受野 = (第k层的感受野 - 1) * 步长 + 卷积核大小&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;卷积核的参数量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;参数量=（filter size * 输入通道数 ）* 当前层 filter 数量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;卷积核的计算量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;计算量 = 输出的维度^2 * 输出的通道数 * 卷积核个数 * 卷积核大小^2&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;rnn-原理&quot;&gt;RNN 原理&lt;/h4&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1816627/202003/1816627-20200327214806791-221171209.png&quot; width=&quot;60%&quot; height=&quot;60%&quot;/&gt;&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\hat y\)&lt;/span&gt; 部分的激活函数可以根据下游任务设置&lt;/p&gt;
&lt;h4 id=&quot;lstm-原理&quot;&gt;LSTM 原理&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;三个门：[output_dim + input_dim, 1]&lt;/li&gt;
&lt;li&gt;更新门位置的全连接层：[output_dim + input_dim, output_dim]&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1816627/202003/1816627-20200327214848703-368235252.png&quot; width=&quot;60%&quot; height=&quot;60%&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;gru-原理&quot;&gt;GRU 原理&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;两个门：[output_dim + input_dim, 1]&lt;/li&gt;
&lt;li&gt;全连接层：[output_dim + input_dim, output_dim]&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1816627/202003/1816627-20200327215013039-1116198473.jpg&quot; width=&quot;60%&quot; height=&quot;60%&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;rnn-bptt&quot;&gt;RNN BPTT&lt;/h4&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1816627/202003/1816627-20200327214806791-221171209.png&quot; width=&quot;60%&quot; height=&quot;60%&quot;/&gt; - 假设$t$时刻的损失函数为$L_t$，以 $W_{aa}$，$W_{ax}$，$W_{ya}$ 为例 $$ \begin{aligned} &amp;amp;\frac{\delta L_t}{\delta W_{ya}} = \frac{\delta L_3}{\delta \hat{y}_t}\frac{\delta \hat{y}_t}{\delta W_{ya}} \\ &amp;amp;\frac{\delta L_t}{\delta W_{aa}} = \frac{\delta L_t}{\delta \hat{y}_t}\frac{\delta \hat{y}_t}{\delta a_{t}}(\frac{\delta a_{t}}{\delta W_{aa}} + \frac{\delta a_{t}}{\delta a_{t-1}}\frac{\delta a_{t-1}}{\delta W_{aa}} + ...)\\ &amp;amp;\frac{\delta L_t}{\delta W_{ax}} = \frac{\delta L_3}{\delta \hat{y}_t}\frac{\delta \hat{y}_t}{\delta a_{t}}(\frac{\delta a_{t}}{\delta W_{ax}} + \frac{\delta a_{t}}{\delta a_{t-1}}\frac{\delta a_{t-1}}{\delta W_{ax}} + ...) \end{aligned}$$
&lt;ul&gt;&lt;li&gt;对于任意时刻t对 &lt;span class=&quot;math inline&quot;&gt;\(W_x\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(W_s\)&lt;/span&gt; 求偏导的公式为：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;\[\begin{aligned} &amp;amp;\frac{\delta L_t}{\delta W_{aa}} = \sum_{k=0}^{t}\frac{\delta L_t}{\delta y_t}\frac{\delta y_t}{\delta a_t}( \prod_{j=k+1}^t\frac{\delta a_j}{\delta a_{j-1}} ) \frac{\delta a_k}{\delta W_{aa}}\\ &amp;amp;\frac{\delta L_t}{\delta W_{aa}} = \sum_{k=0}^{t}\frac{\delta L_t}{\delta y_t}\frac{\delta y_t}{\delta a_t}( \prod_{j=k+1}^t\frac{\delta a_j}{\delta a_{j-1}} ) \frac{\delta a_k}{\delta W_{aa}} \end{aligned}\]&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\frac{\delta a_j}{\delta a_{j-1}}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\frac{\delta a_k}{\delta W_{aa}}\)&lt;/span&gt;还存在&lt;span class=&quot;math inline&quot;&gt;\(tanh'\)&lt;/span&gt;的导数项，而&lt;span class=&quot;math inline&quot;&gt;\(tanh'\)&lt;/span&gt;的值域为&lt;span class=&quot;math inline&quot;&gt;\((0, 1)\)&lt;/span&gt;。随着时间步的增长，累乘项会趋于 0，出现梯度消失的问题&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;lstm-如何解决-rnn-的梯度消失问题&quot;&gt;LSTM 如何解决 RNN 的梯度消失问题&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;RNN 的激活函数为 &lt;span class=&quot;math inline&quot;&gt;\(tanh\)&lt;/span&gt;，而 &lt;span class=&quot;math inline&quot;&gt;\(tanh\)&lt;/span&gt; 的导数取值范围为 &lt;span class=&quot;math inline&quot;&gt;\([0, 1]\)&lt;/span&gt;，在时间上的反向传播会存在时间上的梯度累乘项，时间步长了会导致梯度累乘而消失&lt;/li&gt;
&lt;li&gt;LSTM 通过引入全局信息流，在时间维度上引入残差结构，残差结构的引入就使得链式求导过程中引入了一个求和项，从反向传播的求导来看，最多只有两个激活函数的导数累乘，因此远距离的梯度通常都可以正常传播，减弱了梯度消失问题&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;怎样增加-lstm-的长距离特征提取能力&quot;&gt;怎样增加 LSTM 的长距离特征提取能力&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Dilated RNN：Dilated CNN 为空洞卷积，Dilated RNN 则是在时间维度上空洞，浅层部分的为传统 RNN，每个时间步都循环，深层的循环周期更长，增大时间维度上的“感受野”&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;个人为面试做的知识储备，如有出错，请大家指正，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 27 Mar 2020 13:51:00 +0000</pubDate>
<dc:creator>西多士NLP</dc:creator>
<og:description>[TOC] 为什么传统 CNN 适用于 CV 任务，RNN 适用于 NLP 任务 从模型特点上来说： 对于 CNN 每一个卷积核都可以看作是一个滤波器，卷积运算的本质是互相关运算，每个卷积核仅对于具有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sandwichnlp/p/12578733.html</dc:identifier>
</item>
</channel>
</rss>