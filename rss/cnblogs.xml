<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>爬虫-使用BeautifulSoup4（bs4）解析html数据 - Elite-Wang</title>
<link>http://www.cnblogs.com/Elite-Wang/p/14306011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Elite-Wang/p/14306011.html</guid>
<description>&lt;p&gt;&lt;span&gt;Beautiful Soup 是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip install beautifulsoup4
&lt;/pre&gt;&lt;/div&gt;

&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;h2&gt;导入模块&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; bs4 &lt;span&gt;import&lt;/span&gt; BeautifulSoup
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;3.5&quot;&gt;
&lt;h2&gt;创建BeautifulSoup对象&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [1]: &lt;span&gt;from&lt;/span&gt; bs4 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BeautifulSoup

In [&lt;/span&gt;2]: text = &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
   ...: &amp;lt;div&amp;gt;
   ...:     &amp;lt;ul&amp;gt;
   ...:         &amp;lt;li class=&quot;item-0&quot; id=&quot;first&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
   ...:         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
   ...:         &amp;lt;li class=&quot;item-inactive&quot;&amp;gt;&amp;lt;a href=&quot;link3.html&quot;&amp;gt;&amp;lt;span class=&quot;bold&quot;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
   ...:         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link4.html&quot;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
   ...:         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
   ...:     &amp;lt;/ul&amp;gt;
   ...: &amp;lt;/div&amp;gt;
   ...: &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;3]: bs = BeautifulSoup(text)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建BeautifulSoup对象，可以直接传入字符串&lt;br/&gt;&lt;/span&gt;
In [4]: bs1 = BeautifulSoup(open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./test.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))&lt;span&gt;#也&lt;/span&gt;&lt;span&gt;可以传入文件对象&lt;br/&gt;&lt;/span&gt;
In [5&lt;span&gt;]: bs
Out[&lt;/span&gt;5&lt;span&gt;]: 
&lt;/span&gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-inactive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;创建Beautiful Soup对象时，既可以传入字符串，也可以传入文件对象。它将复杂HTML文档转换成一个复杂的树形结构，并且会自动修正文档，像上述例子中补齐了html和body节点，每个节点都是Python对象&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;h2&gt;获取Tag对象&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [6]: bs.ul &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取ul标签内容&lt;/span&gt;
Out[6&lt;span&gt;]: 
&lt;/span&gt;&amp;lt;ul&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-inactive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;&lt;span&gt;

In [&lt;/span&gt;7&lt;span&gt;]: type(bs.ul)
Out[&lt;/span&gt;7&lt;span&gt;]: bs4.element.Tag

In [&lt;/span&gt;8]: bs.li &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取li标签内容，注意返回的是第一个符合要求的标签&lt;/span&gt;
Out[8]: &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;

In [&lt;/span&gt;12]: bs.ul.li.a &lt;span&gt;#&lt;/span&gt;&lt;span&gt;可叠加查找标签&lt;/span&gt;
Out[12]: &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过Beautiful Soup对象后面接上‘.标签名’来获取需要查找的标签，可叠加&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h2&gt;Tag对象常用属性&lt;/h2&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2.5&quot;&gt;
&lt;h3&gt;name-----显示标签名&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
In [13]: bs.name &lt;span&gt;#&lt;/span&gt;&lt;span&gt;大部分时候，可以把BeautifulSoup当作Tag对象，是一个特殊的 Tag&lt;/span&gt;
Out[13]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[document]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;14&lt;span&gt;]: bs.li.name
Out[&lt;/span&gt;14]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;BeautifulSoup 对象表示的是一个文档的内容。大部分时候,可以把它当作 Tag 对象&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;h3&gt;attrs----以字典的方式显示该标签所有属性&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
In [15&lt;span&gt;]: bs.attrs
Out[&lt;/span&gt;15&lt;span&gt;]: {}

In [&lt;/span&gt;16]: bs.li.attrs &lt;span&gt;#&lt;/span&gt;&lt;span&gt;以字典的形式显示所有属性&lt;/span&gt;
Out[16]: {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}

In [&lt;/span&gt;17]: bs.li.attrs[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取具体的某个属性方法1&lt;/span&gt;
Out[17]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;18]: bs.li[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取具体属性方法2，'.attrs'可省略&lt;/span&gt;
Out[18]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;19]: bs.li.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取具体 属性方法3，利用get方法&lt;/span&gt;
Out[19]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;h3&gt;string----获取标签里面的内容&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
In [20]: bs.li.string &lt;span&gt;#&lt;/span&gt;&lt;span&gt;li标签里面只有唯一的a标签了，那么 .string 会返回最里面a标签的内容&lt;/span&gt;
Out[20]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;first item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;21]: bs.li.a.string &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回a标签的内容&lt;/span&gt;
Out[21]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;first item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：如果标签内容是一个注释，则注释符号会被去掉，比如“&amp;lt;!-- 这是一个注释 --&amp;gt;”，则返回&quot;这是一个注释&quot;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;
&lt;h3&gt;contents----将直接子节点以列表的形式输出，同时也包含换行符'\n'&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
In [22&lt;span&gt;]: bs.ul.contents
Out[&lt;/span&gt;22&lt;span&gt;]: 
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-inactive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;h3&gt;chilldren----将直接子节点以列表生成器的形式输出，也包括换行符‘\n&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [28]: bs.ul.children &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回的是列表生成器对象&lt;/span&gt;
Out[28]: &amp;lt;list_iterator at 0x7f2d9e90ea30&amp;gt;&lt;span&gt;

In [&lt;/span&gt;29]: &lt;span&gt;for&lt;/span&gt; child &lt;span&gt;in&lt;/span&gt;&lt;span&gt; bs.ul.children:
    ...:     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(child)
    ...: 


&lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;


&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;


&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-inactive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;


&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;


&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;h3&gt;descendants----返回的是一个生成器对象，进行迭代取值的时候，会递归循环的显示所有子孙节点&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [30]: bs.ul.descendants &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回的是一个生成器对象，进行迭代取值的时候，会递归循环的显示所有子孙节点&lt;/span&gt;
Out[30]: &amp;lt;generator object Tag.descendants at 0x7f2d9e79fc80&amp;gt;&lt;span&gt;

In [&lt;/span&gt;31]: &lt;span&gt;for&lt;/span&gt; d &lt;span&gt;in&lt;/span&gt;&lt;span&gt; bs.ul.descendants:
    ...:     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(d)
    ...: 


&lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&lt;span&gt;
first item


&lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&lt;span&gt;
second item


&lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-inactive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;
&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&lt;span&gt;
third item


&lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&lt;span&gt;
fourth item


&lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;&lt;span&gt;
fifth item&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h2&gt;Tag对象常用方法&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;
&lt;h3&gt;find（self, name=None, attrs={}, recursive=True, text=None,**kwargs）----------只返回第一个匹配的对象&lt;/h3&gt;
&lt;ol&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;h4&gt;name参数----过滤标签名，可以传入字符串、正则以及列表3种形式&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
In [32]: bs.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找第一个匹配的li标签&lt;/span&gt;
Out[32]: &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;

In [3&lt;/span&gt;3]: bs.find([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找第一个匹配的li标签或者a标签&lt;/span&gt;
Out[33]: &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;

In [3&lt;/span&gt;4]: &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re

In [3&lt;/span&gt;5]: bs.find(re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^l&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找第一个以l开头的标签，li标签匹配上&lt;/span&gt;
Out[35]: &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;

In [36&lt;/span&gt;]: bs.find(re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找第一个以l结尾的标签，html标签符合&lt;/span&gt;
Out[36&lt;span&gt;]: 
&lt;/span&gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-inactive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;h4&gt;attrs参数----过滤属性，dict类型&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
In [37]: bs.find(attrs={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找class属性为item-1的第一个标签&lt;/span&gt;
Out[37]: &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;h4&gt;recursive参数----如果为True，表示是否递归地从子孙节点中去查找匹配对象。否则只从直接子节点中进行查找&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
In [38]: bs.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,recursive=True) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;递归查找，能够匹配到li对象&lt;/span&gt;
Out[38]: &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;

In [&lt;/span&gt;39]: bs.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,recursive=False) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从直接子节点（即html）中无法找到li标签&lt;/span&gt;
&lt;span&gt;
In [&lt;/span&gt;40]: bs.ul.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,recursive=False) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;ul的直接子节点为li标签，所以能够匹配到&lt;/span&gt;
Out[40]: &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;h4&gt;text参数----可以搜索文档中匹配的内容，和name参数一样，有字符串、正则、列表这3种形式&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
In [41]: bs.find(text=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找字符串，需要传入完整内容，否则无法匹配&lt;/span&gt;
Out[41]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;first item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [42&lt;/span&gt;]: bs.find(text=re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找第一个包含item的内容&lt;/span&gt;
Out[42]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;first item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;43]: bs.find(text=re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ir&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找第一个包含ir的内容&lt;/span&gt;
Out[43]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;first item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [&lt;/span&gt;44]: bs.find(text=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;second item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;third item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找内容为second item或third item的第一个内容&lt;/span&gt;
Out[44]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;second item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;h4&gt;其它关键字参数----关键字为属性名，但是注意不能传入和python关键字重名的class属性&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
In [45]: bs.find(id=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;id属性作为关键字参数进行查找&lt;/span&gt;
Out[45]: &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;

In [&lt;/span&gt;43]: bs.find(href=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;href属性作为关键字参数进行查找&lt;/span&gt;
Out[43]: &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&lt;span&gt;

In [&lt;/span&gt;44]: bs.find(&lt;span&gt;class&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item-inactive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;和python关键字class重名的class属性则会报错&lt;/span&gt;
  File &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;ipython-input-42-a9ab4a3f6cee&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 1&lt;span&gt;
    bs.find(&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item-inactive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;^&lt;span&gt;
SyntaxError: invalid syntax&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;
&lt;h3&gt;find_all（self, name=None, attrs={}, recursive=True, text=None,**kwargs）----以列表的形式返回所有能够匹配到的对象，所有参数用法同find（）方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
In [45]: bs.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找所有的li标签&lt;/span&gt;
Out[45&lt;span&gt;]: 
[&lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-inactive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;]

In [4&lt;/span&gt;6]: bs.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,attrs={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找所有的li标签，并且class属性为item-1&lt;/span&gt;
Out[46&lt;span&gt;]: 
[&lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;h3&gt;get（）方法----获取对象的特定属性&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
In [47]: bs.li.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;class属性因为可以有多个，所以返回的是列表形式&lt;/span&gt;
Out[47]: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

In [48&lt;/span&gt;]: bs.find(attrs={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}).get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;以字符串的形式返回id属性值&lt;/span&gt;
Out[48]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

In [4&lt;/span&gt;9]: bs.find_all(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[1].get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Out[4&lt;/span&gt;9]: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;h3&gt;get_text（）方法----获取标签里面的内容，同string属性返回的结果一样&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [50]: bs.li.get_text() #获取第一个li最里面的内容
Out[50]: 'first item'

In [51]: bs.find(attrs={&quot;class&quot;:&quot;bold&quot;}).get_text() #获取class属性为bold标签(即span标签)里面的内容
Out[51]: 'third item'

In [52]: bs.find_all('a')[3].get_text() #获取第4个a标签里面的内容
Out[52]: 'fourth item'　
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;select（）方法----css选择器，同find_all方法有点类似，返回的是列表&lt;/h3&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;1.5&quot;&gt;
&lt;h4&gt;通过标签名查找&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
In [53]: bs.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找所有li标签&lt;/span&gt;
Out[53&lt;span&gt;]: 
[&lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-inactive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;,
 &lt;/span&gt;&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;h4&gt;通过类名查找，类名前加上'.'&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
In [54]: bs.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.bold&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找class='bold'的标签&lt;/span&gt;
Out[54]: [&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;h4&gt;通过id查找，id前加上'#'&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [55]: bs.select('#first') #查找id为first的标签
Out[55]: [&amp;lt;li class=&quot;item-0&quot; id=&quot;first&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;h4&gt;混合查找&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
In [56]: bs.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.item-0 a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找class=&quot;item-0&quot;下的a标签&lt;/span&gt;
Out[56]: [&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;, &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt;&lt;span&gt;]

In [&lt;/span&gt;57]: bs.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#first a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找id=&quot;first&quot;下面的a标签&lt;/span&gt;
Out[57]: [&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&lt;span&gt;]

In [&lt;/span&gt;58]: bs.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ul span&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找ul下面的span标签&lt;/span&gt;
Out[58]: [&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&lt;span&gt;]

In [&lt;/span&gt;59]: bs.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ul&amp;gt;span&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;标签后面带上&quot;&amp;gt;&quot;表示直接子标签，因为span标签不是ul的直接子标签，所以匹配不到&lt;/span&gt;
Out[59&lt;span&gt;]: []

In [&lt;/span&gt;60]: bs.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&amp;gt;span&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;span标签是a标签的子标签，所以能匹配到&lt;/span&gt;
Out[60]: [&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;直接子标签查找，则使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 分隔&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;h4&gt;通过属性查找&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
In [61]: bs.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li[class=&quot;item-inactive&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找class属性为'item-inactive'的li标签&lt;/span&gt;
Out[61]: [&amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-inactive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;span&gt;]

In [&lt;/span&gt;62]: bs.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a[href=&quot;link2.html&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查找href属性为'link2.html'的a标签&lt;/span&gt;
Out[62]: [&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 23 Jan 2021 16:38:00 +0000</pubDate>
<dc:creator>Elite-Wang</dc:creator>
<og:description>Beautiful Soup 是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML 数据。 一、安装 pip install beautifulsoup4 二、使用 导入模块</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Elite-Wang/p/14306011.html</dc:identifier>
</item>
<item>
<title>技术基础 | Apache Cassandra 4.0基准测试 - DataStax</title>
<link>http://www.cnblogs.com/datastax/p/14319631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/datastax/p/14319631.html</guid>
<description>&lt;p&gt;&lt;span data-offset-key=&quot;8oqa5-0-0&quot;&gt;经作者测试，Cassandra 4.0在吞吐量和时延方面都有25%到30%的提升。所以在使用相同的垃圾收集器时，Cassandra 4.0可以很轻易地打败Cassandra 3.11.6。&lt;/span&gt;&lt;/p&gt;&lt;div data-offset-key=&quot;8oqa5-0-0&quot; readability=&quot;108.90948723272&quot;&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;dmocl-0-0&quot;&gt;01 测试方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;bnaal-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bnaal-0-0&quot;&gt;下面进行的基准测试是用tlp-cluster在AWS中生成并配置Apache Cassandra集群的，并用tlp-stress来进行负载生成和指标收集工作的。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;ctrkk-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ctrkk-0-0&quot;&gt;所有在本测试中用到的工具都是开源的，并且只要拥有一个AWS账号，任何人都可以很容易地复现本次测试的过程和结果。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;2kv8m-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2kv8m-0-0&quot;&gt;本测试中的集群中有三个r3.2xlarge实例作为节点，另有一个c3.2xlarge实例作为压测节点。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;3edgh-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3edgh-0-0&quot;&gt;除了垃圾收集和堆内存设置外，我们使用了Apache Cassandra的默认设置。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;1chc1-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1chc1-0-0&quot;&gt;集群的生成和配置是由最新版本的tlp-cluster完成的。除此之外，我们还添加了一些辅助脚本(helper script)，从而可以将Reaper和Medusa的集群生成和安装过程自动化。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;cmapv-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cmapv-0-0&quot;&gt;在根据文档安装并配置好tlp-cluster工具之后，你就可以随时创建跟我们一样的 用来做基准测试的Cassandra集群了。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;5rehn-0-0&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 3.11.6 CMS JDK8
build_cluster.sh -n CMS_3-11-6_jdk8 -v 3.11.6 --heap=16 --gc=CMS -s 1 -i r3.2xlarge --jdk=8 --cores=8

# 3.11.6 G1 JDK8
build_cluster.sh -n G1_3-11-6_jdk8 -v 3.11.6 --heap=31 --gc=G1 -s 1 -i r3.2xlarge --jdk=8 --cores=8

# 4.0 CMS JDK11
build_cluster.sh -n CMS_4-0_jdk11 -v 4.0~alpha4 --heap=16 --gc=CMS -s 1 -i r3.2xlarge --jdk=11 --cores=8

# 4.0 G1 JDK14
build_cluster.sh -n G1_4-0_jdk14 -v 4.0~alpha4 --heap=31 --gc=G1 -s 1 -i r3.2xlarge --jdk=14 --cores=8

# 4.0 ZGC JDK11
build_cluster.sh -n ZGC_4-0_jdk11 -v 4.0~alpha4 --heap=31 --gc=ZGC -s 1 -i r3.2xlarge --jdk=11 --cores=8

# 4.0 ZGC JDK14
build_cluster.sh -n ZGC_4-0_jdk14 -v 4.0~alpha4 --heap=31 --gc=ZGC -s 1 -i r3.2xlarge --jdk=14 --cores=8

# 4.0 Shenandoah JDK11
build_cluster.sh -n Shenandoah_4-0_jdk11 -v 4.0~alpha4 --heap=31 --gc=Shenandoah -s 1 -i r3.2xlarge --jdk=11 --cores=8　　
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;61jp2-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;61jp2-0-0&quot;&gt;注意：为了在基准测试中控制变量，整个测试中我们会同用一组EC2实例进行测试。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;fjecu-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fjecu-0-0&quot;&gt;适当地使用下面的脚本，就可以完成Cassandra 3.11.6到Cassandra 4.0~alpha4的升级以及不同版本JDK的置换：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;2c8m4-0-0&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
#!/usr/bin/env bash

OLD=$1
NEW=$2
curl -sL https://github.com/shyiko/jabba/raw/master/install.sh | bash
. ~/.jabba/jabba.sh
jabba uninstall $OLD
jabba install $NEW
jabba alias default $NEW
sudo update-alternatives --install /usr/bin/java java ${JAVA_HOME%*/}/bin/java 20000
sudo update-alternatives --install /usr/bin/javac javac ${JAVA_HOME%*/}/bin/java
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span data-offset-key=&quot;9kgau-0-0&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;45ogt-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;45ogt-0-0&quot;&gt;在调用JDK版本管理工具jabba时，可以使用以下JDK值：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;42uo7-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;42uo7-0-0&quot;&gt;OpenJDK 8已经用Ubuntu的apt工具安装完成。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;eqrq9-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;eqrq9-0-0&quot;&gt;下面是在基准测试中，在不同的JDK版本下，java -version的输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;89kb7-0-0&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
openjdk version &quot;1.8.0_252&quot;
OpenJDK Runtime Environment (build 1.8.0_252-8u252-b09-1~18.04-b09)
OpenJDK 64-Bit Server VM (build 25.252-b09, mixed mode)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;1192m-0-0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;1192m-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;1192m-0-0&quot;&gt;jdk8 with Shenandoah&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
openjdk version &quot;11.0.2&quot; 2019-01-15
OpenJDK Runtime Environment 18.9 (build 11.0.2+9)
OpenJDK 64-Bit Server VM 18.9 (build 11.0.2+9, mixed mode)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;56arj-0-0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;56arj-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;56arj-0-0&quot;&gt;jdk11 with Shenandoah&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;bf0h3-0-0&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
openjdk version &quot;11.0.8-testing&quot; 2020-07-14
OpenJDK Runtime Environment (build 11.0.8-testing+0-builds.shipilev.net-openjdk-shenandoah-jdk11-b277-20200624)
OpenJDK 64-Bit Server VM (build 11.0.8-testing+0-builds.shipilev.net-openjdk-shenandoah-jdk11-b277-20200624, mixed mode)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
openjdk version &quot;14.0.1&quot; 2020-04-14
OpenJDK Runtime Environment (build 14.0.1+7)
OpenJDK 64-Bit Server VM (build 14.0.1+7, mixed mode, sharing)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;f44td-0-0&quot;&gt;02 CMS&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;41n5j-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;41n5j-0-0&quot;&gt;CMS (Concurrent Mark Sweep)收集器是目前Apache Cassandra默认的垃圾收集器。由于它在JDK 14中被移除了，所以所有的测试都是基于JDK 8或JDK 11进行的。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;1l0ns-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1l0ns-0-0&quot;&gt;下面的设置被用于CMS的基准测试：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;1goru-0-0&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 -XX:+UseParNewGC
 -XX:+UseConcMarkSweepGC
 -XX:+CMSParallelRemarkEnabled
 -XX:SurvivorRatio=8
 -XX:MaxTenuringThreshold=1
 -XX:CMSInitiatingOccupancyFraction=75
 -XX:+UseCMSInitiatingOccupancyOnly
 -XX:CMSWaitDuration=10000
 -XX:+CMSParallelInitialMarkEnabled
 -XX:+CMSEdenChunksRecordAlways
 -XX:+CMSClassUnloadingEnabled
 -XX:ParallelGCThreads=8
 -XX:ConcGCThreads=8
 -Xms16G
 -Xmx16G
 -Xmn8G
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;aaf7d-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;aaf7d-0-0&quot;&gt;请注意，&lt;span data-offset-key=&quot;aaf7d-0-1&quot;&gt;&lt;strong&gt;-XX:+UseParNewGC&lt;/strong&gt;&lt;span data-offset-key=&quot;aaf7d-0-2&quot;&gt;参数已经被从JDK 11中移除，在那之后它就变成了一个隐式参数(implicit parameter)。使用这个参数会阻止JVM的启动。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;4uua3-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4uua3-0-0&quot;&gt;我们将CMS的最大堆内存(max heap)限制在16GB，否则它可能会引发major collection的长时间暂停。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;3kmmu-0-0&quot;&gt;03 G1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;ve9d-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ve9d-0-0&quot;&gt;相比CMS收集器，G1GC（即Garbage-First Garbage Collector，垃圾优先型垃圾收集器）要容易配置一些，因为它可以动态调整年轻代的大小。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;fs8c7-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fs8c7-0-0&quot;&gt;不过G1GC更适用于大型的堆内存（&amp;gt;=24GB）——这也就是为什么它没有成为Cassandra的默认垃圾收集器。另外，虽然它的吞吐量比CMS更好，但是它的时延比调试过的CMS要长。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;4p9jj-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4p9jj-0-0&quot;&gt;下面的设置被用于G1的基准测试：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;e3q7p-0-0&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 -XX:+UseG1GC
 -XX:G1RSetUpdatingPauseTimePercent=5
 -XX:MaxGCPauseMillis=300
 -XX:InitiatingHeapOccupancyPercent=70
 -XX:ParallelGCThreads=8
 -XX:ConcGCThreads=8
 -Xms31G
 -Xmx31G
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;filic-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;filic-0-0&quot;&gt;为了对Cassandra 4.0进行基准测试，我们在运行G1测试时使用了JDK14。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;7a3d7-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7a3d7-0-0&quot;&gt;我们使用31GB的堆内存大小，从而可以受益于压缩指针(compressed oops)，并可以以最小的堆内存大小拥有最多的可寻址对象。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;efbaa-0-0&quot;&gt;04 ZGC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;8292u-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8292u-0-0&quot;&gt;ZGC(Z Garbage Collector)是JDK中最新的垃圾收集器，它主要的关注点是将让全世界暂停(stop-the-world)的时延缩小至10ms以内。ZGC还应该可以保证堆内存大小对暂停时间没有影响，这使得它的堆内存大小可以扩充至16TB。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;e84sc-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;e84sc-0-0&quot;&gt;如果这些令人期待的效果都能被满足，ZGC就使得使用堆外存储变得没有必要，而且还能简化Apache Cassandra的一些开发任务。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;12s0g-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;12s0g-0-0&quot;&gt;下面的设置被用于ZGC的基准测试：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;buas0-0-0&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 -XX:+UnlockExperimentalVMOptions
 -XX:+UseZGC
 -XX:ConcGCThreads=8
 -XX:ParallelGCThreads=8
 -XX:+UseTransparentHugePages
 -verbose:gc
 -Xms31G
 -Xmx31G
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;5quma-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5quma-0-0&quot;&gt;我们需要用&lt;strong&gt;-&lt;/strong&gt;&lt;span data-offset-key=&quot;5quma-0-1&quot;&gt;&lt;strong&gt;XX:+UseTransparentHugePages&lt;/strong&gt;&lt;span data-offset-key=&quot;5quma-0-2&quot;&gt;作为一种灵活变通的方式来避免在Linux里启用大内存页(page)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;1g9d1-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1g9d1-0-0&quot;&gt;尽管官方的ZGC文档称这可能会造成时延激增，从测试的结果来看似乎并没出现这种情况。我们也许可以使用大内存页来进行多次吞吐量测试，从而判断这种方法会对基准测试的结果有什么影响。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;51j9m-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;51j9m-0-0&quot;&gt;请注意，ZGC不能使用压缩指针，但是也不受“32GB阈值”的限制。我们在对ZGC的测试中，使用和在G1测试中一样的31GB的堆内存。这样，两种情况下系统空闲的内存大小就会是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;3moes-0-0&quot;&gt;05 Shenandoah&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;ank9v-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ank9v-0-0&quot;&gt;Shenandoah是一个由红帽(RedHat)开发的低时延垃圾收集器。在JDK 8和11中，它作为一个向后移植(backport)的版本存在。从Java 13开始，它就被包含在OpenJDK的主线版本里了。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;1g113-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1g113-0-0&quot;&gt;与ZGC一样，在大多数情况下Shenandoah是个并发垃圾收集器。它的目标是让暂停时间不会随着堆内存的增大而线性增加。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;aeds-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;aeds-0-0&quot;&gt;下面的设置被用于Shenandoah的基准测试：&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;6kv2s-0-0&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 -XX:+UnlockExperimentalVMOptions
 -XX:+UseShenandoahGC
 -XX:ConcGCThreads=8
 -XX:ParallelGCThreads=8
 -XX:+UseTransparentHugePages
 -Xms31G
 -Xmx31G
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;9du5n-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9du5n-0-0&quot;&gt;Shenandoah应该可以使用压缩指针，因此可以受益于使用比32GB稍小一些的堆。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;vp8j-0-0&quot;&gt;06 Cassandra 4.0的JVM配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;3m9ef-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3m9ef-0-0&quot;&gt;Cassandra 4.0版本分别为Java 8和Java 11推出了不同的jvm.options文件。它们是：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;14bpb-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;14bpb-0-0&quot;&gt;如果将Cassandra从3.11版本升级到4.0版本，原先已有的&lt;span data-offset-key=&quot;14bpb-0-1&quot;&gt;&lt;strong&gt;jvm.options&lt;/strong&gt;&lt;span data-offset-key=&quot;14bpb-0-2&quot;&gt;文件依然可以沿用，只要它被重命名为&lt;span data-offset-key=&quot;14bpb-0-3&quot;&gt;&lt;strong&gt;jvm-server.options&lt;/strong&gt;&lt;span data-offset-key=&quot;14bpb-0-4&quot;&gt;，并且将&lt;span data-offset-key=&quot;14bpb-0-5&quot;&gt;&lt;strong&gt;jvm8-server.options&lt;/strong&gt;&lt;span data-offset-key=&quot;14bpb-0-6&quot;&gt;和&lt;span data-offset-key=&quot;14bpb-0-7&quot;&gt;&lt;strong&gt;jvm11-server.options&lt;/strong&gt;&lt;span data-offset-key=&quot;14bpb-0-8&quot;&gt;文件移除就好。不过，这并不是值得推荐的方式.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;1gpv1-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1gpv1-0-0&quot;&gt;值得推荐的方式是将原来的&lt;span data-offset-key=&quot;1gpv1-0-1&quot;&gt;&lt;strong&gt;jvm.options&lt;/strong&gt;&lt;span data-offset-key=&quot;1gpv1-0-2&quot;&gt;文件里的设置，重新应用到新的&lt;span data-offset-key=&quot;1gpv1-0-3&quot;&gt;&lt;strong&gt;jvm-server.options&lt;/strong&gt;&lt;span data-offset-key=&quot;1gpv1-0-4&quot;&gt;和&lt;span data-offset-key=&quot;1gpv1-0-5&quot;&gt;&lt;strong&gt;jvm8-server.options&lt;/strong&gt;&lt;span data-offset-key=&quot;1gpv1-0-6&quot;&gt;文件上。这些特定的Java选项文件(option file)大多是和垃圾收集的参数相关的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;k07e-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;k07e-0-0&quot;&gt;一旦&lt;span data-offset-key=&quot;k07e-0-1&quot;&gt;&lt;strong&gt;jvm-server.options&lt;/strong&gt;&lt;span data-offset-key=&quot;k07e-0-2&quot;&gt;和&lt;span data-offset-key=&quot;k07e-0-3&quot;&gt;&lt;strong&gt;jvm8-server.options&lt;/strong&gt;&lt;span data-offset-key=&quot;k07e-0-4&quot;&gt;文件更新完毕并且就位，配置&lt;span data-offset-key=&quot;k07e-0-5&quot;&gt;&lt;strong&gt;jvm11-server.options&lt;/strong&gt;&lt;span data-offset-key=&quot;k07e-0-6&quot;&gt;文件以及从JDK 8转换到JDK 11就容易多了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;f92rm-0-0&quot;&gt;07 工作负载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;cghc9-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cghc9-0-0&quot;&gt;本次基准测试中有8个线程，并将读写比例限制为80%写/20%读。tlp-stress大量使用异步的查询语句，这使得它只要有限的几个压测线程一不小心就可能会让Cassandra节点过载。在本次的负载测试中，每一个线程会一次并发地发送50个查询语句。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;79dv-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;79dv-0-0&quot;&gt;本次测试中的键空间(keyspace)的复制因子(replication factor)为3，并且所有的语句都以一致性级别LOCAL_ONE来执行。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;o263-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;o263-0-0&quot;&gt;对于所有垃圾收集器和Cassandra版本的测试，操作的数目都以每秒25k、40k、45k、50k的增长幅度进行，因而我们能够评估它们在不同压力水平下的性能表现。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;98io8-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;98io8-0-0&quot;&gt;下面的tlp-stress语句被使用在本测试中：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;b3h5d-0-0&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
tlp-stress run BasicTimeSeries -d 30m -p 100M -c 50 --pg sequence -t 8 -r 0.2 --rate &amp;lt;desired rate&amp;gt; --populate 200000
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;4hid5-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4hid5-0-0&quot;&gt;所有的工作负载都运行30分钟，将5至16GB的数据装载到每个节点并考虑合理的压实负载。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;akf2b-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;akf2b-0-0&quot;&gt;请注意，这个测试的目的并非测评Cassandra的最优性能，因为对于不同的工作负载，可以通过很多方式进行调试出最优性能。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;7u8j0-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7u8j0-0-0&quot;&gt;这个测试的目的也并非调试这些垃圾收集器，虽然它们其实已经暴露了很多可以针对特定工作负载提高性能的参数和选项。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;e4nub-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;e4nub-0-0&quot;&gt;这些基准测试想要达到的目的是：在使用大部分默认设置并且Cassandra产生同样的负载的情况下，提供一个针对不同垃圾收集器的公平比较。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;1k10q-0-0&quot;&gt;&lt;span data-offset-key=&quot;1k10q-0-1&quot;&gt;08 &lt;span data-offset-key=&quot;1k10q-0-2&quot;&gt;&lt;span data-offset-key=&quot;1k10q-0-3&quot;&gt;基准测试结果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;d9jfl-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;d9jfl-0-0&quot;&gt;3.11.6 25k-40k ops/s&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-a4e32b831ae713e4303d4c7b33e71c9d_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1325&quot; data-rawheight=&quot;872&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-a4e32b831ae713e4303d4c7b33e71c9d.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-631c53c2e2fb43ddf323ce4154ab3ada.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;assq8-0-0&quot;&gt;

&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;assq8-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;4.0 25k-40k ops/s&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-7892fbbdabda0a34e4fea7ad415273f1_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1326&quot; data-rawheight=&quot;824&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-7892fbbdabda0a34e4fea7ad415273f1.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-38061681e07d25f442b4292d4f245ec9.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;603ff-0-0&quot;&gt;

&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;603ff-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;4.0 45k-50k ops/s&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-bbe9709f3696ea1b6323024e079b735c_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1324&quot; data-rawheight=&quot;871&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-bbe9709f3696ea1b6323024e079b735c.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-e72ec4d6cb30d0c0158170e49b960df1.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-d82518847b414e99779546d6a85fc220_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;848&quot; data-rawheight=&quot;262&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-d82518847b414e99779546d6a85fc220.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-4ce2610cae6110c5b1e633a892f323bb.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;85r67-0-0&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;85r67-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;就吞吐量而言，Cassandra 3.11.6最高可达41k ops/s，而Cassandra 4.0则高达51k ops/s。两种版本都用了CMS作为垃圾收集器，而升级后的Cassandra 4.0的比Cassandra 3.11.6的提升达到了25%。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;48bpr-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;48bpr-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;4.0版本中的大量性能提升都可以用来解释这个结果，尤其是关于压实(compaction)操作引发的堆内存压力问题（可查看CASSANDRA-14654作为例子）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;cliim-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cliim-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;在Cassandra 3.11.6集群中的JDK 8的Shenandoah在40k ops/s的负载测试中，不仅没能实现最高的吞吐量，还出现了查询失败的情况。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;4s455-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4s455-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;而借助于Cassandra 4.0集群和JDK 11，Shenandoah的表现就好很多——它在这种情况下的最大吞吐量49.6k ops/s，几乎可以赶得上4.0在CMS下的吞吐量了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;ea700-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ea700-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;使用JDK 8和Cassandra 3.11.6，G1和Shenandoah总体上的吞吐量都只能最高达到36k ops/s。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;fva71-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fva71-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;使用JDK 14和JDK 11，前者似乎让G1的表现也有些微提高——从47k/s提高到50k/s。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;aubej-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;aubej-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;无论是使用JDK 14还是JDK 11，ZGC的吞吐量都无法与其它的垃圾回收器匹敌，最高只能到41k ops/s。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-f754378a76cc8b5c34c91635e238017e_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;786&quot; data-rawheight=&quot;260&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-f754378a76cc8b5c34c91635e238017e.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-5d202c3f5c1e95bbc37aaf35f5235099.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-1c728e87e4284689cc109d4787a1a047_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2151&quot; data-rawheight=&quot;747&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-1c728e87e4284689cc109d4787a1a047.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-af4cc16da03c4cb3afa9c79e076dc5fe.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-7d60c79c68eddf77a64557d706b2a723_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;785&quot; data-rawheight=&quot;262&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-7d60c79c68eddf77a64557d706b2a723.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-cb1d73ef3ab2b6b4b92a5d8bf5ea36e8.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-c48aa4b5204e0c4c222a94fcc919cb0b_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2138&quot; data-rawheight=&quot;784&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-c48aa4b5204e0c4c222a94fcc919cb0b.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-b466b165c9a5cf2660b123b4e27b32bb.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-3d93542d48cbfc0d30a99e6aef3de226_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;786&quot; data-rawheight=&quot;262&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-3d93542d48cbfc0d30a99e6aef3de226.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-0ac63ef6b95ddcfed3679a37247e58f1.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-4a60abff87b59f58389b62894833c1c5_720w.png&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2146&quot; data-rawheight=&quot;753&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-4a60abff87b59f58389b62894833c1c5.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-b6e2aded0b461bde939e824756a4dbcd.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;7pe3-0-0&quot; readability=&quot;8&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;7pe3-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;在Cassandra 3.11.6集群中，JDK 8的Shenandoah在中等程度的负载下，展现出了非常令人印象深刻的低时延。不过，它的性能会随着负载压力的提升而严重下降。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;2hti7-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2hti7-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;在使用CMS的情况下，Cassandra 4.0的平均p99（99百分位）值介于11ms到31ms之间，而吞吐量则高达50k ops/s。在中等程度的负载下，读操作的P99平均值在Cassandra 3.11.6中为17ms，而在Cassandra 4.0中则下降到了11.5ms。即相比之下，在时延方面Cassandra 4.0有30%的提升。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;2mppq-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2mppq-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Cassandra 4.0在吞吐量和时延方面都有25%到30%的提升，所以在使用相同的垃圾收集器时，Cassandra 4.0可以很轻易地打败Cassandra 3.11.6。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;628mv-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;628mv-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;值得一提的是，在Cassandra 3.11.6集群中，Shenandoah在中等程度的负载下的延迟非常低，不过它在压力下的表现使我们担心其处理突增负载的能力。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;euo33-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;euo33-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;虽然ZGC在中等程度的负载下展现出了非常令人印象深刻的低时延，尤其是在使用JDK 14时，但是它的最高吞吐量并不能与Shenandoah相匹敌。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;eg4ks-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;eg4ks-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;几乎在所有的负载测试中，Shenandoah的读操作时延和写操作时延的平均p99值都是最低的。Shenandoah这样低的时延再加上它在Cassandra 4.0中能达到的吞吐量，使它成为了在向Cassandra 4.0升级时，一个值得考虑的垃圾收集器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;a8dqq-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;a8dqq-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;在中等程度的负载下，读操作时延的平均p99值只有2.64ms本身已经是相当令人印象深刻的。在此基础上，如果你知道这些的数据是由客户端记录的，你就不得不对Shenandoah刮目相看了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;4bmig-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4bmig-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;在大多数情况下，G1的最大p99值符合它所配置的最大暂停时间，即300ms。如果想要降低目标的暂停时间，则可能会在高负载的情况下出现不想看到的效果，甚至可能会触发更长时间的暂停。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;90qdj-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;90qdj-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;在中等程度的负载下，Shenandoah的平均p99时延可以降低77%，即最高时延只有2.64ms。这对于时延敏感的用例来说会是一项重大的提升——相比使用Cassandra 3.11.6中的CMS，读操作的p99时延大幅降低了85%！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;j2jr-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;j2jr-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;值得一提的是，JDK 14中的ZGC在中等程度的负载下有着良好的性能，但是遗憾的是它不能在更大的吞吐速率下保持同样的表现。我们乐观地认为ZGC会在未来的几个月内被改进，最终可能会足以与Shenandoah一较高下。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;6ogom-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;09 &lt;span data-offset-key=&quot;6ogom-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;反思&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;6t90o-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6t90o-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;G1通过移除对不同代的大小的调试需求得以提升Cassandra的易用性，但是 是以牺牲一定的性能为代价的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;bgtr4-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bgtr4-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;新发行的Apache Cassandra 4.0带来了令人印象极为深刻的性能增强，它将会允许使用像是Shenandoah和ZGC这样的新一代垃圾收集器。这些收集器简单易用，无需太多细微精妙的调试，并且在时延问题上更为高效。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;1i2fn-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1i2fn-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;如果使用Cassandra 3.11.6，我们很难向你推荐Shenandoah，因为Cassandra节点在高负载情况下的表现并不如意。但是从JDK 11和Cassandra 4.0开始，Shenandoah在延迟方面有着惊人的改进，同时还能支持几乎是Cassandra数据库所能提供的最大吞吐量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;277bp-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;277bp-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;由于这次基准测试集中关注于特定的工作负载，你的测试结果可能会依情况而有所不同。但是对于时延敏感的用例来说，这次测试的结果让我们对Apache Cassandra的未来感到相当的乐观，因为它将为我们带来超过Cassandra 3.11.6的大幅改进。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;ecoru&quot; data-offset-key=&quot;fef8q-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;fef8q-0-0&quot;&gt;&lt;span data-offset-key=&quot;fef8q-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;下载最新的Apache 4并且自行尝试一番吧。如果你有任何反馈意见，记得通过社区邮件或是ASF Slack联系我们。&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://cassandra.apache.org/community/&quot; target=&quot;_blank&quot; data-offset-key=&quot;fef8q-1-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;fef8q-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;点击这里&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;fef8q-2-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;查看我们的联系方式。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 23 Jan 2021 15:57:00 +0000</pubDate>
<dc:creator>DataStax</dc:creator>
<og:description>Apache Cassandra 4.0已经发布了Beta版，这是第一个支持JDK 11及更高JDK版本的Cassandra版本。 时延对于Apache Cassandra™用户来说是个显而易见的关注</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/datastax/p/14319631.html</dc:identifier>
</item>
<item>
<title>QT串口助手（三）：数据接收 - zzssdd2</title>
<link>http://www.cnblogs.com/zzssdd2/p/14319615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzssdd2/p/14319615.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;作者：&lt;/strong&gt;zzssdd2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E-mail：&lt;/strong&gt;zzssdd2@foxmail.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;开发环境：&lt;strong&gt;Qt5.12.10 + MinGW&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实现的功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;串口数据的接收&lt;/li&gt;
&lt;li&gt;ascii字符形式显示与hex字符形式显示&lt;/li&gt;
&lt;li&gt;时间戳的显示&lt;/li&gt;
&lt;li&gt;接收数据的统计与显示&lt;/li&gt;
&lt;li&gt;接收清零&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;涉及的知识点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;QSerialPort&lt;/code&gt;类的使用&lt;/li&gt;
&lt;li&gt;数据格式的转换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QTime&lt;/code&gt;类的使用&lt;/li&gt;
&lt;li&gt;控件&lt;code&gt;QTextEdit&lt;/code&gt;、&lt;code&gt;QCheckBox&lt;/code&gt;、&lt;code&gt;QPushButton&lt;/code&gt;、&lt;code&gt;QLabel&lt;/code&gt;的使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202101/2193174-20210123234501671-1437707537.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面开始逐步讲解以上列举的功能实现&lt;/p&gt;
&lt;h2 id=&quot;21、数据读取&quot;&gt;2.1、数据读取&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/zzssdd2/p/14310882.html&quot; target=&quot;_blank&quot;&gt;《QT串口助手（二）：参数配置》&lt;/a&gt;中已经实现了串口参数的配置，参数配置完成后就可以开启串口的数据接收功能了。在QT中的&lt;em&gt;QSerialPort&lt;/em&gt;类继承自&lt;em&gt;QIODevice&lt;/em&gt;类，所以可以使用QIODevice的&lt;em&gt;readyRead()&lt;/em&gt;信号来触发数据的接收，在槽函数中实现数据的读取与处理。信号槽连接如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/* 接收数据信号槽 */
connect(serial, &amp;amp;QSerialPort::readyRead, this, &amp;amp;Widget::SerialPortReadyRead_slot);
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;18.071513706794&quot;&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;signalvoid-qiodevicereadyread&quot;&gt;&lt;code&gt;[signal]&lt;/code&gt;void QIODevice::readyRead()&lt;/h3&gt;
&lt;p&gt;This signal is emitted once every time new data is available for reading from the device's current read channel. It will only be emitted again once new data is available, such as when a new payload of network data has arrived on your network socket, or when a new block of data has been appended to your device.&lt;/p&gt;
&lt;p&gt;readyRead() is not emitted recursively; if you reenter the event loop or call &lt;a href=&quot;https://doc.qt.io/qt-5.12/qiodevice.html#waitForReadyRead&quot; target=&quot;_blank&quot;&gt;waitForReadyRead&lt;/a&gt;() inside a slot connected to the readyRead() signal, the signal will not be reemitted (although &lt;a href=&quot;https://doc.qt.io/qt-5.12/qiodevice.html#waitForReadyRead&quot; target=&quot;_blank&quot;&gt;waitForReadyRead&lt;/a&gt;() may still return true).&lt;/p&gt;
&lt;p&gt;Note for developers implementing classes derived from &lt;a href=&quot;https://doc.qt.io/qt-5.12/qiodevice.html&quot; target=&quot;_blank&quot;&gt;QIODevice&lt;/a&gt;: you should always emit readyRead() when new data has arrived (do not emit it only because there's data still to be read in your buffers). Do not emit readyRead() in other conditions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当有收到新数据信号时，就会执行槽函数里面的数据读取功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/*读取串口收到的数据*/
QByteArray bytedata = serial-&amp;gt;readAll();
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9.2957746478873&quot;&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;qbytearray-qiodevicereadall&quot;&gt;&lt;a href=&quot;https://doc.qt.io/qt-5.12/qbytearray.html&quot; target=&quot;_blank&quot;&gt;QByteArray&lt;/a&gt; QIODevice::readAll()&lt;/h3&gt;
&lt;p&gt;Reads all remaining data from the device, and returns it as a byte array.&lt;/p&gt;
&lt;p&gt;This function has no way of reporting errors; returning an empty &lt;a href=&quot;https://doc.qt.io/qt-5.12/qbytearray.html&quot; target=&quot;_blank&quot;&gt;QByteArray&lt;/a&gt; can mean either that no data was currently available for reading, or that an error occurred.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;22、数据转换&quot;&gt;2.2、数据转换&lt;/h2&gt;
&lt;p&gt;若需要将接收到的数据以HEX格式显示，则需要对接收到的数据进行以下处理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/*将数据转换为hex格式并以空格分隔-&amp;gt;去掉头尾空白字符-&amp;gt;转换为大写形式*/
framedata = bytedata.toHex(' ').trimmed().toUpper();
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;34.810900082576&quot;&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;qbytearray-qbytearraytohexchar-separator-const&quot;&gt;&lt;a href=&quot;https://doc.qt.io/qt-5.12/qbytearray.html#QByteArray&quot; target=&quot;_blank&quot;&gt;QByteArray&lt;/a&gt; QByteArray::toHex(char &lt;em&gt;separator&lt;/em&gt;) const&lt;/h3&gt;
&lt;p&gt;This is an overloaded function.&lt;/p&gt;
&lt;p&gt;Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and the letters a-f.&lt;/p&gt;
&lt;p&gt;If &lt;em&gt;separator&lt;/em&gt; is not '\0', the separator character is inserted between the hex bytes.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QByteArray macAddress = QByteArray::fromHex(&quot;123456abcdef&quot;);
macAddress.toHex(':'); // returns &quot;12:34:56:ab:cd:ef&quot;
macAddress.toHex(0);   // returns &quot;123456abcdef&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;This function was introduced in Qt 5.9.&lt;/p&gt;
&lt;h3 id=&quot;qbytearray-qbytearraytrimmed-const&quot;&gt;&lt;a href=&quot;https://doc.qt.io/qt-5.12/qbytearray.html#QByteArray&quot; target=&quot;_blank&quot;&gt;QByteArray&lt;/a&gt; QByteArray::trimmed() const&lt;/h3&gt;
&lt;p&gt;Returns a byte array that has whitespace removed from the start and the end.&lt;/p&gt;
&lt;p&gt;Whitespace means any character for which the standard C++ &lt;code&gt;isspace()&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt; in the C locale. This includes the ASCII characters '\t', '\n', '\v', '\f', '\r', and ' '.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QByteArray ba(&quot;  lots\t of\nwhitespace\r\n &quot;);
ba = ba.trimmed();
// ba == &quot;lots\t of\nwhitespace&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Unlike &lt;a href=&quot;https://doc.qt.io/qt-5.12/qbytearray.html#simplified&quot; target=&quot;_blank&quot;&gt;simplified&lt;/a&gt;(), trimmed() leaves internal whitespace alone.&lt;/p&gt;
&lt;h3 id=&quot;qbytearray-qbytearraytoupper-const&quot;&gt;&lt;a href=&quot;https://doc.qt.io/qt-5.12/qbytearray.html#QByteArray&quot; target=&quot;_blank&quot;&gt;QByteArray&lt;/a&gt; QByteArray::toUpper() const&lt;/h3&gt;
&lt;p&gt;Returns an uppercase copy of the byte array. The bytearray is interpreted as a Latin-1 encoded string.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QByteArray x(&quot;Qt by THE QT COMPANY&quot;);
QByteArray y = x.toUpper();
// y == &quot;QT BY THE QT COMPANY&quot;
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;23、添加时间戳&quot;&gt;2.3、添加时间戳&lt;/h2&gt;
&lt;p&gt;有时为了便于观察数据收发时间，需要在数据前插入时间戳显示。使用&lt;em&gt;QTime&lt;/em&gt;类中的方法可以获取当前系统的时间（精确到ms），对数据处理如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/*在数据前插入时间戳：[时:分:秒:毫秒]:RX -&amp;gt; 数据*/
framedata = QString(&quot;[%1]:RX -&amp;gt; %2&quot;).arg(QTime::currentTime().toString(&quot;HH:mm:ss:zzz&quot;)).arg(framedata);
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;15.824945295405&quot;&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;staticqtime-qtimecurrenttime&quot;&gt;&lt;code&gt;[static]&lt;/code&gt;&lt;a href=&quot;https://doc.qt.io/qt-5.12/qtime.html#QTime&quot; target=&quot;_blank&quot;&gt;QTime&lt;/a&gt; QTime::currentTime()&lt;/h3&gt;
&lt;p&gt;Returns the current time as reported by the system clock.&lt;/p&gt;
&lt;p&gt;Note that the accuracy depends on the accuracy of the underlying operating system; not all systems provide 1-millisecond accuracy.&lt;/p&gt;
&lt;p&gt;Furthermore, currentTime() only increases within each day; it shall drop by 24 hours each time midnight passes; and, beside this, changes in it may not correspond to elapsed time, if a daylight-saving transition intervenes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;24、接收计数&quot;&gt;2.4、接收计数&lt;/h2&gt;
&lt;p&gt;使用一个&lt;em&gt;quint32&lt;/em&gt;类型数据对每次接收数据长度进行累加，记录接收数据总数，然后将数据更新到ui界面：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;dataTotalRx += bytedata.length();
ui-&amp;gt;RxCnt_label-&amp;gt;setText(QString::number(dataTotalRx));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;25、数据显示&quot;&gt;2.5、数据显示&lt;/h2&gt;
&lt;p&gt;以上功能完成后将数据显示到接收框中（为了区分不同显示格式，做了不同的颜色显示）。完整的数据接收功能展示如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/*
    函   数：SerialPortReadyRead_slot
    描   述：readyRead()信号对应的数据接收槽函数
    输   入：无
    输   出：无
*/
void Widget::SerialPortReadyRead_slot()
{
    QString framedata;
    /*读取串口收到的数据*/
    QByteArray bytedata = serial-&amp;gt;readAll();

    /*数据是否为空*/
    if (!bytedata.isEmpty())
    {
        if(ui-&amp;gt;HexDisp_checkBox-&amp;gt;isChecked())
        {
            /*hex显示*/
            framedata = bytedata.toHex(' ').trimmed().toUpper();
            ui-&amp;gt;Receive_TextEdit-&amp;gt;setTextColor(QColor(Qt::green));
        }
        else
        {
            /*ascii显示*/
            framedata = QString(bytedata);
            ui-&amp;gt;Receive_TextEdit-&amp;gt;setTextColor(QColor(Qt::magenta));
        }
        
        /*是否显示时间戳*/
        if (ui-&amp;gt;TimeDisp_checkBox-&amp;gt;isChecked()) 
        {
            framedata = QString(&quot;[%1]:RX -&amp;gt; %2&quot;).arg(QTime::currentTime().toString(&quot;HH:mm:ss:zzz&quot;)).arg(framedata);
            ui-&amp;gt;Receive_TextEdit-&amp;gt;append(framedata);
        }
        else
        {
            ui-&amp;gt;Receive_TextEdit-&amp;gt;insertPlainText(framedata);
        }
        
        /*更新接收计数*/
        dataTotalRxCnt += bytedata.length();
        ui-&amp;gt;RxCnt_label-&amp;gt;setText(QString::number(dataTotalRxCnt));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;演示效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2193174/202101/2193174-20210123234524403-2004902213.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8.7341356673961&quot;&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;qcolorqcolorqtglobalcolor-color&quot;&gt;QColor::QColor(&lt;a href=&quot;https://doc.qt.io/qt-5.12/qt.html#GlobalColor-enum&quot; target=&quot;_blank&quot;&gt;Qt::GlobalColor&lt;/a&gt; &lt;em&gt;color&lt;/em&gt;)&lt;/h3&gt;
&lt;p&gt;This is an overloaded function.&lt;/p&gt;
&lt;p&gt;Constructs a new color with a color value of &lt;em&gt;color&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&quot;enum-qtglobalcolor&quot;&gt;enum Qt::GlobalColor&lt;/h3&gt;
&lt;p&gt;Qt's predefined &lt;a href=&quot;https://doc.qt.io/qt-5.12/qcolor.html&quot; target=&quot;_blank&quot;&gt;QColor&lt;/a&gt; objects:&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Constant&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.957264957265&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::white&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;3&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;White (#ffffff)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::black&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Black (#000000)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::red&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;7&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Red (#ff0000)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::darkRed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;13&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Dark red (#800000)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::green&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;8&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Green (#00ff00)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::darkGreen&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;14&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Dark green (#008000)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::blue&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;9&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Blue (#0000ff)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::darkBlue&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;15&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Dark blue (#000080)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::cyan&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;10&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Cyan (#00ffff)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::darkCyan&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;16&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Dark cyan (#008080)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::magenta&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;11&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Magenta (#ff00ff)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::darkMagenta&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;17&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Dark magenta (#800080)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::yellow&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;12&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Yellow (#ffff00)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::darkYellow&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;18&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Dark yellow (#808000)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::gray&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;5&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Gray (#a0a0a4)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::darkGray&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;4&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Dark gray (#808080)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Qt::lightGray&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;6&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Light gray (#c0c0c0)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5.4929577464789&quot;&gt;&lt;td&gt;&lt;code&gt;Qt::transparent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;19&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;a transparent black value (i.e., &lt;a href=&quot;https://doc.qt.io/qt-5.12/qcolor.html&quot; target=&quot;_blank&quot;&gt;QColor&lt;/a&gt;(0, 0, 0, 0))&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Qt::color0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;0 pixel value (for bitmaps)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Qt::color1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1 pixel value (for bitmaps)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;26、清除接收&quot;&gt;2.6、清除接收&lt;/h2&gt;
&lt;p&gt;当&lt;code&gt;清除接收&lt;/code&gt;按键点击后，会清除接收框显示的内容以及接收计数。使用&lt;em&gt;QPushButton&lt;/em&gt;的点击信号槽实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;/*
    函   数：on_ClearRx_Bt_clicked
    描   述：清除接收按键点击信号对应的槽函数
    输   入：无
    输   出：无
*/
void Widget::on_ClearRx_Bt_clicked()
{
    ui-&amp;gt;Receive_TextEdit-&amp;gt;clear();
    ui-&amp;gt;RxCnt_label-&amp;gt;setText(QString::number(0));
    dataTotalRxCnt = 0;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本篇文章主要是讲述如何对串口数据进行接收和显示。除了上面列出的主要功能外，还需要了解各个控件的操作方法，比如&lt;em&gt;QTextEdit&lt;/em&gt;文本的添加、&lt;em&gt;QLabel&lt;/em&gt;文本的设置等。还有就是QT中基本的数据类型的数据使用，比如&lt;em&gt;QString&lt;/em&gt;、&lt;em&gt;QBytArray&lt;/em&gt;等。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Jan 2021 15:50:00 +0000</pubDate>
<dc:creator>zzssdd2</dc:creator>
<og:description>作者：zzssdd2 E-mail：zzssdd2@foxmail.com 一、前言 开发环境：Qt5.12.10 + MinGW 实现的功能 串口数据的接收 ascii字符形式显示与hex字符形式显</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzssdd2/p/14319615.html</dc:identifier>
</item>
<item>
<title> 消息队列之kafka - pluto_charon</title>
<link>http://www.cnblogs.com/pluto-charon/p/14319587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pluto-charon/p/14319587.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/pluto-charon/p/14225896.html&quot; target=&quot;_blank&quot;&gt;消息队列之activeMQ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/pluto-charon/p/14288765.html&quot; target=&quot;_blank&quot;&gt;消息队列之RabbitMQ&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1kafka介绍&quot;&gt;1.kafka介绍&lt;/h2&gt;
&lt;p&gt;kafka是由scala语言开发的一个多分区，多副本的并且居于zookeeper协调的分布式的发布-订阅消息系统。具有高吞吐、可持久化、可水平扩展、支持流处理等特性；能够支撑海量数据的数据传递；并且将消息持久化到磁盘中，并对消息创建了备份保证了数据的安全。kafka在保证了较高的处理速度的同时，又能保证数据处理的低延迟和数据的零丢失。&lt;/p&gt;
&lt;p&gt;kafka的特性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;高吞吐量，低延迟：kafka每秒可以处理几十万条消息，延迟最低大概毫秒，每个主题可以分为多个分区，消费组对分区进行消费操作&lt;/li&gt;
&lt;li&gt;可扩展性：支持热扩展&lt;/li&gt;
&lt;li&gt;持久性，可靠性：消息被持久化到本地磁盘，并且支持数据备份&lt;/li&gt;
&lt;li&gt;容错性：允许集群中节点失败，如副本的数量为n，则允许n-1个节点失败&lt;/li&gt;
&lt;li&gt;高并发：允许上千个客户端同时读写&lt;/li&gt;
&lt;li&gt;可伸缩性：kafka在运行期间可以轻松的扩展或者收缩；可以扩展一个kafka主题来包含更多的分区&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;kafka的主要应用场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;消息处理&lt;/li&gt;
&lt;li&gt;网站跟踪&lt;/li&gt;
&lt;li&gt;指标存储&lt;/li&gt;
&lt;li&gt;日志聚合&lt;/li&gt;
&lt;li&gt;流式处理&lt;/li&gt;
&lt;li&gt;事件朔源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基本流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1459011/202101/1459011-20210123233305608-1701696775.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;kafka的关键角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Producer：&lt;/strong&gt;生产者即数据的发布者，该角色将消息发布到kafka的topic中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consumer：&lt;/strong&gt;消费者，可以从broker中读取数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consumer Group：&lt;/strong&gt;每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Topic：&lt;/strong&gt;划分数据的所属类的一个类别属性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Partition：&lt;/strong&gt;topic中的数据分割为一个或多个partition，每个topic中至少含有一个partition&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Partition offset：&lt;/strong&gt;每条消息都有一个当前partition下的唯一的64字节的offset，它指名了这条消息的起始位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Replicas of Partition：&lt;/strong&gt;副本，是一个分区的备份&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Broker：&lt;/strong&gt;kafka集群中包含一个或多个服务器 ，服务器的节点称为broker&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Leader：&lt;/strong&gt;每个partition由多个副本，其中有且仅有一个作为leader，leader是当前负责数据的读写的partition&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Follower：&lt;/strong&gt;Follower跟随Leader，所有的写请求都是通过leader路由，数据变更会广播到所有的follower上，follower与leader的数据保持同步&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AR：&lt;/strong&gt;分区中所有的副本统称为AR&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ISR：&lt;/strong&gt;所有与leader部分保持一定程度的副本组成ISR&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OSR：&lt;/strong&gt;与leader副本同步滞后过多的副本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HW：&lt;/strong&gt;高水位，标识了一个特定的offset，消费者只能拉去到这个offset之前的消息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LEO：&lt;/strong&gt;即日志末端位移，记录了该副本底层日志中的下一条消息的位移值&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2kafka的安装&quot;&gt;2.kafka的安装&lt;/h2&gt;
&lt;p&gt;安装kafka的前提是安装zookeeper以及jdk环境。我这里安装的版本是jdk1.8.0_20，kafka_2.11-1.0.0,zookeeper-3.4.14。kafka与jdk的版本一定要对应。我之前用的kafka_2.12_2.3.0,就不行&lt;/p&gt;
&lt;p&gt;1.将kafka的文件上传到home目录下并解压缩到/usr/local目录下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;root@localhost home]# tar -xvzf kafka_2.11-1.0.0.tgz -C /usr/local
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.进入kafka的config&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost local]# cd /usr/local/kafka_2.11-1.0.0/config
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.编辑server.properties文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;# 如果是集群环境中，则每个broker.id要设置为不同
broker.id=0
# 将下面这一行打开，这相当于kafka对外提供服务的入口
listeners=PLAINTEXT://192.168.189.150:9092
# 日志存储位置：log.dirs=/tmp/kafka_logs 改为
log.dirs=/usr/local/kafka_2.11-1.0.0/logs
# 修改zookeeper的地址
zookeeper.connect=192.168.189.150:2181
# 修改zookeeper的连接超时时长，默认为6000（可能会超时）
zookeeper.connection.timeout.ms=10000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.启动zookeeper&lt;/p&gt;
&lt;p&gt;因为我是配置的zookeeper集群，所以需要将三台zookeeper都启动。只启动单台服务器zookeeper在选举的时候将不可进行（当整个集群超过半数机器宕机，zookeeper会认为集群处于不可用状态）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost ~]# zkServer.sh start
# 查看状态
[root@localhost ~]# zkServer.sh status
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.启动kafka&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost kafka_2.11-1.0.0]# bin/kafka-server-start.sh config/server.properties
# 也可以使用后台启动的方式，如果不使用后台启动，则在启动后操作需要新开一个窗口才能操作
[root@localhost kafka_2.11-1.0.0]# bin/kafka-server-start.sh -daemon config/server.properties
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.创建一个主题&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# --zookeeper： 指定了kafka所连接的zookeeper的服务地址
# --partitions： 指定了分区的个数
# --replication-factor： 指定了副本因子
[root@localhost kafka_2.11-1.0.0]# bin/kafka-topics.sh --zookeeper localhost:2181 --create --topic charon --partitions 2 --replication-factor 1
Created topic &quot;charon&quot;.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6.展示所有的主题（验证创建的主题是否有问题）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost kafka_2.11-1.0.0]# bin/kafka-topics.sh --zookeeper localhost:2181 --list
charon
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7.查看某个主题的详情&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost kafka_2.11-1.0.0]# bin/kafka-topics.sh --zookeeper localhost:2181 --describe --topic charon
Topic:charon    PartitionCount:2        ReplicationFactor:1     Configs:
        Topic: charon   Partition: 0    Leader: 0       Replicas: 0     Isr: 0
        Topic: charon   Partition: 1    Leader: 0       Replicas: 0     Isr: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8.新开一个窗口启动消费者接收消息.&lt;/p&gt;
&lt;p&gt;--bootstrap-server:指定连接kafka集群的地址,9092是kafka服务的端口。因为我的配置文件中配置的是具体地址，所以需要写明具体地址。否则会报 &lt;strong&gt;[Producer clientId=console-producer] Connection to node -1 could not be established. Broker may not be available.&lt;/strong&gt;的错&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost kafka_2.11-1.0.0]# bin/kafka-console-consumer.sh --bootstrap-server 192.168.189.150:9092 --topic charon
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;9.新开一个窗口启动生产者产生消息&lt;/p&gt;
&lt;p&gt;--bootstrap-server:指定连接kafka集群的地址,9092是kafka服务的端口。因为我的配置文件中配置的是地址。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost kafka_2.11-1.0.0]# bin/kafka-console-producer.sh --broker-list 192.168.189.150:9092 --topic charon
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;10.产生消息并消费消息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 生产者生产消息
&amp;gt;hello charon good evening
# 消费者这边接收到的消息
hello charon good evening
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然上面这种方式，只有在同一个网段才能实现。&lt;/p&gt;
&lt;h2 id=&quot;3生产者和消费者&quot;&gt;3.生产者和消费者&lt;/h2&gt;
&lt;p&gt;kafka生产流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1459011/202101/1459011-20210123233438959-1615734513.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）producer先从zookeeper的 &quot;/brokers/.../state&quot;节点找到该partition的leader&lt;/p&gt;
&lt;p&gt;2）producer将消息发送给该leader&lt;/p&gt;
&lt;p&gt;3）leader将消息写入本地log&lt;/p&gt;
&lt;p&gt;4）followers从leader pull消息，写入本地log后向leader发送ACK&lt;/p&gt;
&lt;p&gt;5）leader收到所有ISR中的replication的ACK后，增加HW（high watermark，最后commit 的offset）并向producer发送ACK&lt;/p&gt;
&lt;p&gt;消费组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1459011/202101/1459011-20210123233518103-587435607.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;kafka消费者是消费组的一部分，当多个消费者形成一个消费组来消费主题的时候，每个消费者都会收到来自不同分区的消息。假如消费者都在同一个消费者组里面，则是工作-队列模型。假如消费者在不同的消费组里面，则是发布-订阅模型。&lt;/p&gt;
&lt;p&gt;当单个消费者无法跟上数据的生成速度时，就可以增加更多的消费者来分担负载，每个消费者只处理部分分区的消息，从而实现单个应用程序的横向伸缩。但是千万不要让消费者的数量少于分区的数量，因为此时会有多余的消费者空闲。&lt;/p&gt;
&lt;p&gt;当有多个应用程序都需要从kafka获取消息时，让每个应用程序对应一个消费者组，从而使每个应用程序都能获取一个或多个topic的全部消息。每个消费者对应一个线程，如果要在同一个消费者组中运行多个消费者，需要让每个消费者运行在自己的线程中。&lt;/p&gt;
&lt;h2 id=&quot;4代码实践&quot;&gt;4.代码实践&lt;/h2&gt;
&lt;p&gt;1.添加依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--添加kafka的依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.kafka&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;kafka_2.11&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.kafka&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;kafka-clients&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.kafka&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;kafka-streams&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生产者代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package kafka;

import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.common.serialization.StringSerializer;

import java.util.Properties;

/**
 * @className: Producer
 * @description: kafka的生产者
 * @author: charon
 * @create: 2021-01-18 08:52
 */
public class Producer {

    /**topic*/
    private static final String topic = &quot;charon&quot;;

    public static void main(String[] args) {
        // 配置kafka的属性
        Properties properties = new Properties();
        // 设置地址
        properties.put(&quot;bootstrap.servers&quot;,&quot;192.168.189.150:9092&quot;);
        // 设置应答类型，默认值为0。（0：生产者不会等待kafka的响应；1：kafka的leader会把这条消息写到本地日志文件中，但不会等待集群中其他机器的成功响应；
        // -1(all)：leader会等待所有的follower同步完成，确保消息不会丢失，除非kafka集群中的所有机器挂掉，保证可用性）
        properties.put(&quot;acks&quot;,&quot;all&quot;);
        // 设置重试次数，大于0，客户端会在消息发送失败是重新发送
        properties.put(&quot;reties&quot;,0);
        // 设置批量大小，当多条消息需要发送到同一个分区时，生产者会尝试合并网络请求，提交效率
        properties.put(&quot;batch.size&quot;,10000);
        // 生产者设置序列化方式，默认为：org.apache.kafka.common.serialization.StringSerializer
        properties.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
        properties.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
        // 创建生产者
        KafkaProducer producer = new KafkaProducer(properties);
        for (int i = 0; i &amp;lt; 5; i++) {
            String message = &quot;hello,charon message &quot;+ i ;
            producer.send(new ProducerRecord(topic,message));
            System.out.println(&quot;生产者发送消息：&quot; + message);
        }
        producer.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费者代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;
import org.apache.kafka.common.serialization.StringSerializer;

import java.util.Arrays;
import java.util.List;
import java.util.Properties;

/**
 * @className: Consumer
 * @description: kafka的消费者
 * @author: charon
 * @create: 2021-01-18 08:53
 */
public class Consumer implements Runnable{

    /**topic*/
    private static final String topic = &quot;charon&quot;;

    /**kafka消费者*/
    private static KafkaConsumer kafkaConsumer;

    /**消费消息*/
    private static ConsumerRecords&amp;lt;String,String&amp;gt; msgList;

    public static void main(String[] args) {
        // 配置kafka的属性
        Properties properties = new Properties();
        // 设置地址
        properties.put(&quot;bootstrap.servers&quot;,&quot;192.168.189.150:9092&quot;);
        // 消费者设置反序列化方式
        properties.put(&quot;key.deserializer&quot;, StringDeserializer.class.getName());
        properties.put(&quot;value.deserializer&quot;, StringDeserializer.class.getName());
        // 设置消费组
        properties.put(&quot;group.id&quot;,&quot;test01&quot;);
        // 设置允许自动提交
        properties.put(&quot;enable.auto.commit&quot;,&quot;true&quot;);
        // 设置自动提交的时间间隔
        properties.put(&quot;auto.commit.interval.ms&quot;,&quot;1000&quot;);
        // 设置连接的超时市场
        properties.put(&quot;session.timeout.ms&quot;,&quot;30000&quot;);
        // 创建消费者
        kafkaConsumer = new KafkaConsumer(properties);
        // 指定分区
        kafkaConsumer.subscribe(Arrays.asList(topic));
        Consumer consumer = new Consumer();
        new Thread(consumer).start();
        // kafkaConsumer.close();
    }

    @Override
    public void run() {
        for (;;){
            // 获取数据的超时1000ms
            msgList = kafkaConsumer.poll(1000);
            if(null != msgList &amp;amp;&amp;amp; msgList.count() &amp;gt; 0){
                for (ConsumerRecord&amp;lt;String,String&amp;gt; consumerRecord: msgList ) {
                    System.out.println(&quot;消费者接受到消息，开始消费：&quot; + consumerRecord);
                    System.out.println(&quot;topic= &quot;+consumerRecord.topic()+&quot; ,partition= &quot;+consumerRecord.partition()+&quot; ,offset= &quot;+consumerRecord.offset()+&quot; ,value=&quot;+consumerRecord.value()+&quot;\n&quot;);
                }
            }else{
                // 如果没有接受到数据，则阻塞一段时间
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5提交和偏移量&quot;&gt;5.提交和偏移量&lt;/h2&gt;
&lt;p&gt;kafka不会像activemq那样需要得到消费者确认，所以消费者需要追踪kafka的消息消费到分区中的哪个位置了，这个位置就叫偏移量。把更新分区当前位置的操作叫做提交。如果消费者发生崩溃或者有新的消费者加入群组，就会触发再均衡，完成再均衡之后，每个消费者可能分配到新的分区上，而不是之前处理的那个，为了能够继续之前的工作，消费者需要读取每个分区最后一次提交的偏移量，然后从偏移量指定的地方继续处理。&lt;/p&gt;
&lt;p&gt;这样的话就可能会有以下两种情况：&lt;/p&gt;
&lt;p&gt;1.提交的偏移量小于客户端处理的偏移量&lt;/p&gt;
&lt;p&gt;如果提交的偏移量小于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息就会被重新处理。&lt;/p&gt;
&lt;p&gt;2.提交的偏移量大于客户端处理的偏移量&lt;/p&gt;
&lt;p&gt;如果提交的偏移量大于客户端处理的最后一个消息的偏移量，那么处于两个偏移量之间的消息就会丢失。&lt;/p&gt;
&lt;p&gt;kafka的提交方式：&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;自动提交模式：消费者拉取数据之后自动提交偏移量，不关心后续对消息的处理是否正确。优点是：&lt;strong&gt;消费快，适用于数据一致性弱的业务场景&lt;/strong&gt;，缺点为：&lt;strong&gt;消息容易丢失或者重复消费&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;将enable.auto.commit被设为 true&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;手动提交模式：消费者拉取数据之后做业务处理，而且需要业务处理完成才算真正消费成功。缺点：&lt;strong&gt;在broker对提交请求做出回应之前，应用程序会一直阻塞，会限制应用程序的吞吐量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;将enable.auto.commit被设为 false；&lt;/p&gt;
&lt;p&gt;在消息处理完成后手动调用consumer.commitSync();&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;异步提交：只需要发送提交请求，无需等待broker的响应&lt;/p&gt;
&lt;p&gt;在消息处理完成后手动调用consumer.commitAsync();这个方法也支持回调，在broker作出响应时会执行回调，回调经常被用于记录提交失败将错误信息和偏移量记录下来，如果重新提交，则需要注意提交的顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;6再均衡监听器&quot;&gt;6.再均衡监听器&lt;/h2&gt;
&lt;p&gt;在为消费者分配新的分区或者移除旧的分区时，可以通过消费者API执行一些应用程序代码，在调用subscribe(Pattern pattern, ConsumerRebalanceListener listener)时，可以传入一个再均衡监听器。&lt;/p&gt;
&lt;p&gt;需要实现的两个方法：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;public void onPartitionRevoked(Collection partitions)；&lt;/p&gt;
&lt;p&gt;在再均衡开始之前和消费者停止读取消息之后被调用，如果在这里提交偏移量，下一个接管分区的消费者就知道从哪里开始读取了，要注意提交的是最近处理过的偏移量，而不是批次中还在处理的最后一个偏移量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;public void onPartitionAssigned(Collection partitions)&lt;/p&gt;
&lt;p&gt;在重新分配分区之后和消费者开始夫区消息之前被调用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;7kafka消息重复和丢失分析&quot;&gt;7.kafka消息重复和丢失分析&lt;/h2&gt;
&lt;p&gt;首先来看看kafka的应答类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ack=0：生产者无需等待来自broker的确认而继续发送下一批消息（数据传输效率最高，但可靠性最低）&lt;/li&gt;
&lt;li&gt;ack=1：生产者在ISR中的leader已成功收到数据并写入到本地日志文件中，但不会等待集群中其他follower的成功响应&lt;/li&gt;
&lt;li&gt;ack=-1：生产者需要等待ISR中的所有的follower同步完成，确保消息不会丢失，除非kafka集群中的所有机器挂掉，保证可用性（可靠性最高，但也不能保证数据不丢失）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果是单机环境中，三者没有区别。&lt;/p&gt;
&lt;p&gt;kafka的消息重复和丢失可能发生在三个阶段：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.生产者阶段&lt;/strong&gt;的原因为：生产者发送的消息没有收到正确的broker的响应，导致生产者重试。&lt;/p&gt;
&lt;p&gt;生产者发送一条消息，broker罗盘以后因为网络等种种原因，发送端得到一个发送失败的响应或者网络中断，然后prodcuer收到一个可恢复的exception重试消息导致消息重试。&lt;/p&gt;
&lt;p&gt;重试过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1459011/202101/1459011-20210123233554353-1802482972.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;new KafkaProducer()后创建一个后台线程KafkaThread扫描RecordAccumulator中是否有消息；&lt;/li&gt;
&lt;li&gt;调用KafkaProducer.send()发送消息，实际上只是把消息保存到RecordAccumulator中；&lt;/li&gt;
&lt;li&gt;后台线程KafkaThread扫描到RecordAccumulator中有消息后，将消息发送到kafka集群；&lt;/li&gt;
&lt;li&gt;如果发送成功，那么返回成功；&lt;/li&gt;
&lt;li&gt;如果发送失败，那么判断是否允许重试。如果不允许重试，那么返回失败的结果；如果允许重试，把消息再保存到RecordAccumulator中，等待后台线程KafkaThread扫描再次发送；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;解决方式：&lt;/p&gt;
&lt;p&gt;1.启动kafka的幂等性。要启动kafka的幂等性，需要修改配置文件中的:enable.idempotenmce=true,同时要求ack=all且retries&amp;gt;1。如果要提高数据的可靠性，还需要min.insync.replicas这个参数配合，如果ISR的副本数少于min.insync.replicas则会产生异常，原因:消息被拒绝,同步副本数量少于所需的数量&lt;/p&gt;
&lt;p&gt;幂等性的原理:&lt;/p&gt;
&lt;p&gt;每个生产者都有一个PID，服务端回通过PID关联记录每个生产者的状态，每个生产者的每个消息会带上一个递增的序列（sequence），服务端会记录每个生产者对应的当前的最大的序列（PID+seq），如果新的消息带上的序列不大于当前的最大的seq就拒绝这条消息，如果消息落盘会同时更新最大的seq，这个时候重发的消息会呗服务器拒掉从而避免了消息重复。&lt;/p&gt;
&lt;p&gt;2.设置ack=0，即不需要确认，不重试。但可能会丢失数据，所以适用于吞吐量指标重要性高于数据丢失，例如：日志收集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.生产者和broker阶段&lt;/strong&gt;的原因：&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ack=0，不重试。生产者发送消息后，不管结果如何，如果发送失败数据也就丢失了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ack=1，leader宕机(crash)了，生产者发送消息完，只等待leader写入成功就返回了，leader宕机了，这是follower还没来得及同步，那么消息就丢失了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;unclean.leader.election.enable 配置为true。允许选举ISR以外的副本作为leader，会导致数据丢失，默认为fase(非ISR中的副本不能参与选举)。&lt;/p&gt;
&lt;p&gt;生产者发送完异步消息，只等待leader写入成功就返回了，leader宕机了，这时ISR中没有follower，leader从OSR中选举，因为OSR中本来落后于leader而造成数据丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;解决方式：&lt;/p&gt;
&lt;p&gt;1.配置：ack=-1，retries&amp;gt;1,unclean.leader.election.enable=false&lt;/p&gt;
&lt;p&gt;生产者发送完消息，等待follower同步完在返回，如果异常则重试，这时副本的数量可能影响吞吐量，最大不超过5个，一般三个就够了。&lt;/p&gt;
&lt;p&gt;2.配置：min.insync.replicas &amp;gt; 1&lt;/p&gt;
&lt;p&gt;当生产者将ack设置为all或-1时，min.insync副本指定必须确认写操作成功的最小副本数量，如果不能满足这个最小值，则生产者将引发一个异常。当一起使用时，min.insync.replicas和ack允许执行更大的持久性保证。&lt;/p&gt;
&lt;p&gt;3.失败的offset单独记录&lt;/p&gt;
&lt;p&gt;生产者发送消息，回自动重试，遇到不可恢复的异常会抛出，这时可以捕获异常记录到数据库或缓存中，进行单独处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.消费阶段&lt;/strong&gt;的原因：数据消费完没有及时提交offset到broker。消息消费端在消费过程中挂掉没有及时提交offset到broker，另一个消费者启动拿到之前记录的offset开始消费，由于offset的滞后性可能会导致新启动的客户端有少量重复消费。&lt;/p&gt;
&lt;p&gt;解决方式：&lt;/p&gt;
&lt;p&gt;1.取消自动提交，每次消费完或者程序退出时手动提交，这也没有办法保证不会有重复。&lt;/p&gt;
&lt;p&gt;2.做幂等性，尽量让下游做幂等或者尽量每消费一条消息都记录offset。对于少书严格的场景可能需要吧offset或唯一ID和下游状态更新放在同一个数据库里做事务来保证精确的一次更新或者在下游数据库表里同时记录消费的offset。然后更新数据的时候用消费位点做乐观锁拒绝掉旧的位点的数据更新。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/qingyunzong/p/9004509.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qingyunzong/p/9004509.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/frankdeng/p/9310704.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/frankdeng/p/9310704.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/6845469d99e6&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/6845469d99e6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wangzhuxing/p/10124308.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/wangzhuxing/p/10124308.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Jan 2021 15:39:00 +0000</pubDate>
<dc:creator>pluto_charon</dc:creator>
<og:description>消息队列之activeMQ 消息队列之RabbitMQ 1.kafka介绍 kafka是由scala语言开发的一个多分区，多副本的并且居于zookeeper协调的分布式的发布-订阅消息系统。具有高吞吐</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pluto-charon/p/14319587.html</dc:identifier>
</item>
<item>
<title>浅谈JavaScript代码性能优化2 - メSerendipity</title>
<link>http://www.cnblogs.com/websiteblogs/p/14319505.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/websiteblogs/p/14319505.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一.减少判断层级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从下图代码中可以明显看出，同样的效果判断层级的减少可以优化性能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202101/2257600-20210123230027887-34754436.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二.减少作用域链查找层级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单解释下,下图中第一个运行foo函数，bar函数内打印name，bar作用域内没有name，所以作用域链往上查找，foo内部有name，&lt;/p&gt;
&lt;p&gt;但是这种写法实际上是赋值，还要往上查找，全局作用域中查询到name，相比于下图第二个,多向上查了一级,所以时间要长一些。&lt;/p&gt;
&lt;p&gt;（备注：不考虑内存空间消耗的前提下，具体根据产品来定。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202101/2257600-20210123230133598-949185494.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三.减少数据读取次数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单解释下，对于多次频繁调用，比如数组，对象是比较慢的，因为按照引用关系先要找到堆内存中的位置，所以说减少时间的消耗,&lt;/p&gt;
&lt;p&gt;就应该减少查找成员的次数，比如放到一个变量中缓存起来（备注：不考虑内存空间消耗的前提下，具体根据产品来定。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202101/2257600-20210123230246103-324027573.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202101/2257600-20210123230256143-1246649237.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四.字面量与构造式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单解释下，下图中第一个new Object() 相当于调用函数，比较慢，而下图第二个相当于在堆区开辟空间，在里面放属性和值就可&lt;/p&gt;
&lt;p&gt;以了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202101/2257600-20210123230402854-1151741157.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次举例说明,下图中第一个创建的仅仅是个字面量字符串，而第二个相当于创建了个字符串对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202101/2257600-20210123230425485-33693346.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五.循环优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单解释下：下图二中把一个频繁使用到的值做了一个缓存，提升了执行效率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202101/2257600-20210123230514528-1038174708.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如下图所示：在不考虑顺序的前提下,while循环递减比for循环，执行效率更高一些&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202101/2257600-20210123230535387-309572487.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六.减少声明及语句数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简答解释下:对于不频繁使用的数据,不建议先缓存，执行的时候再去获取，降低执行时对内存的消耗在运行之前有编译过程，表达式&lt;/p&gt;
&lt;p&gt;量比较多,对单词要进行词法拆分变成词法单元，然后做语法分析，然后转成代码再去执行，时间消耗浪费在这里了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202101/2257600-20210123230643953-1116467078.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202101/2257600-20210123230657330-1141715122.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;减少声明变量解释也如上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2257600/202101/2257600-20210123230717709-1020111997.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 23 Jan 2021 15:12:00 +0000</pubDate>
<dc:creator>メSerendipity</dc:creator>
<og:description>一.减少判断层级 从下图代码中可以明显看出，同样的效果判断层级的减少可以优化性能 二.减少作用域链查找层级 简单解释下,下图中第一个运行foo函数，bar函数内打印name，bar作用域内没有name</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/websiteblogs/p/14319505.html</dc:identifier>
</item>
<item>
<title>特征预处理之归一化&amp;标准化 - noor9</title>
<link>http://www.cnblogs.com/xp-thebest/p/14319425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xp-thebest/p/14319425.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;这篇博客的主要内容&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用MinMaxScaler实现对特征数据进行归一化&lt;/li&gt;
&lt;li&gt;应用StandardScaler实现对特征数据进行标准化&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;特征预处理&quot;&gt;特征预处理&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;​ 通过&lt;strong&gt;一些转换函数&lt;/strong&gt;将特征数据&lt;strong&gt;转换成更加适合算法模型&lt;/strong&gt;的特征数据过程&lt;/p&gt;
&lt;h3 id=&quot;特征预处理api&quot;&gt;特征预处理API&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;sklearn.preprocessing
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;为什么要进行归一化标准化？&quot;&gt;为什么要进行归一化/标准化？&lt;/h3&gt;
&lt;p&gt;​ 特征的&lt;strong&gt;单位或者大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级&lt;/strong&gt;，&lt;strong&gt;容易影响（支配）目标结果&lt;/strong&gt;，使得一些算法无法学习到其它的特征&lt;/p&gt;
&lt;h3 id=&quot;归一化&quot;&gt;归一化&lt;/h3&gt;
&lt;h4 id=&quot;定义-1&quot;&gt;定义&lt;/h4&gt;
&lt;p&gt;​ 通过对原始数据进行变换把数据映射到(默认为[0,1])之间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/%E5%BD%92%E4%B8%80%E5%8C%96%E5%85%AC%E5%BC%8F.png&quot; alt=&quot;归一化公式&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;作用于每一列，max为一列的最大值，min为一列的最小值,那么X’’为最终结果，mx，mi分别为指定区间值默认mx为1,mi为0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;api&quot;&gt;API&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;sklearn.preprocessing.MinMaxScaler (feature_range=(0,1)… )
&lt;ul&gt;&lt;li&gt;MinMaxScalar.fit_transform(X)
&lt;ul&gt;&lt;li&gt;X:numpy array格式的数据[n_samples,n_features]&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回值：转换后的形状相同的array&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;数据&quot;&gt;数据&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;milage,Liters,Consumtime,target
40920,8.326976,0.953952,3
14488,7.153469,1.673904,2
26052,1.441871,0.805124,1
75136,13.147394,0.428964,1
38344,1.669788,0.134296,1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;代码&quot;&gt;代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sklearn.preprocessing import MinMaxScaler
import pandas as pd
def minmax_demo():
    data = pd.read_csv(&quot;dating.txt&quot;)
    print(data)
    # 1、实例化一个转换器类
    transfer = MinMaxScaler(feature_range=(2, 3))
    # 2、调用fit_transform
    data = transfer.fit_transform(data[['milage','Liters','Consumtime']])
    print(&quot;最小值最大值归一化处理的结果：\n&quot;, data)

    return None
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;结果&quot;&gt;结果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/image-20210123224728916.png&quot; alt=&quot;归一化运行结果&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;标准化&quot;&gt;标准化&lt;/h3&gt;
&lt;h4 id=&quot;定义-2&quot;&gt;定义&lt;/h4&gt;
&lt;p&gt;​ 通过对原始数据进行变换把数据变换到均值为0,标准差为1范围内&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/%E6%A0%87%E5%87%86%E5%8C%96%E5%85%AC%E5%BC%8F.png&quot; alt=&quot;标准化公式&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作用于每一列，mean为平均值，σ为标准差&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;api-1&quot;&gt;API&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;sklearn.preprocessing.StandardScaler( )
&lt;ul&gt;&lt;li&gt;处理之后每列来说所有数据都聚集在均值0附近标准差差为1&lt;/li&gt;
&lt;li&gt;StandardScaler.fit_transform(X)
&lt;ul&gt;&lt;li&gt;X:numpy array格式的数据[n_samples,n_features]&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回值：转换后的形状相同的array&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;数据-1&quot;&gt;数据&lt;/h4&gt;
&lt;p&gt;​ 同上归一化介绍中使用的数据&lt;/p&gt;
&lt;h4 id=&quot;代码-1&quot;&gt;代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sklearn.preprocessing import StandardScaler
import pandas as pd
def stand_demo():
    data = pd.read_csv(&quot;dating.txt&quot;)
    print(data)
    transfer = StandardScaler()
    data = transfer.fit_transform(data[['milage','Liters','Consumtime']])
    print(&quot;标准化的结果：\n&quot;,data)
    print(&quot;每一列特征的平均值：\n&quot;,transfer.mean_)
    print(&quot;每一列特征的方差：\n&quot;,transfer.var_)
    return None
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;运行结果&quot;&gt;运行结果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xp-thebest/blog_img/raw/master/img/image-20210123224804238.png&quot; alt=&quot;标准化运行结果&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;&quot;/&gt;
</description>
<pubDate>Sat, 23 Jan 2021 14:50:00 +0000</pubDate>
<dc:creator>noor9</dc:creator>
<og:description>应用MinMaxScaler实现归一化、StandardScaler实现标准化</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xp-thebest/p/14319425.html</dc:identifier>
</item>
<item>
<title>在.NET Core 中使用Quartz.NET - SpringLeee</title>
<link>http://www.cnblogs.com/myshowtime/p/14319212.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myshowtime/p/14319212.html</guid>
<description>&lt;p&gt;Quartz.NET是功能齐全的开源作业调度系统，可用于最小的应用程序到大型企业系统。&lt;/p&gt;
&lt;p&gt;Quartz.NET具有三个主要概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;job：运行的后台任务&lt;/li&gt;
&lt;li&gt;trigger：控制后台任务运行的触发器。&lt;/li&gt;
&lt;li&gt;scheduler：协调job和trigger&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210123_095408.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core通过托管服务对运行“后台任务”具有良好的支持，托管服务在ASP.NET Core应用程序启动时启动，并在应用程序生存期内在后台运行，Quartz.NET版本3.2.0通过Quartz.Extensions.Hosting包引入了对该模式的直接支持，Quartz.Extensions.Hosting可以与ASP.NET Core应用程序一起使用，也可以与基于“通用主机”的工作程序服务一起使用。&lt;/p&gt;
&lt;p&gt;虽然.NET Core可以创建“定时”后台服务（例如，每10分钟运行一次任务），但Quartz.NET提供了更为强大的解决方案, 通过使用Cron表达式，您可以确保任务在特定时间（例如，凌晨2:30）运行，或仅在特定的几天运行，或这些时间的任意组合。Quartz.NET还允许您以集群方式运行应用程序的多个实例，以便在任何时候都只能运行一个实例。&lt;/p&gt;
&lt;h2 id=&quot;安装quartznet&quot;&gt;安装Quartz.NET&lt;/h2&gt;
&lt;p&gt;Quartz.NET是一个.NET Standard 2.0 NuGet软件包，所以大部分项目都是支持的，你可以运行安装命令，&lt;code&gt;dotnet add package Quartz.Extensions.Hosting&lt;/code&gt;,或者在NNuget可视化安装，如果查看该项目的.csproj，应该是下边这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk.Worker&quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;net5.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;UserSecretsId&amp;gt;dotnet-QuartzWorkerService-9D4BFFBE-BE06-4490-AE8B-8AF1466778FD&amp;lt;/UserSecretsId&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&quot;Microsoft.Extensions.Hosting&quot; Version=&quot;5.0.0&quot; /&amp;gt;
    &amp;lt;PackageReference Include=&quot;Quartz.Extensions.Hosting&quot; Version=&quot;3.2.3&quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完成以后，这个包会自动安装 Quartz.NET包，接下来，我们需要在我们的应用程序中注册Quartz服务和Quartz 。&lt;/p&gt;
&lt;h2 id=&quot;添加quartznet-hosted-service&quot;&gt;添加Quartz.NET hosted service&lt;/h2&gt;
&lt;p&gt;修改Program.cs，注册服务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
        Host.CreateDefaultBuilder(args)
            .ConfigureServices((hostContext, services) =&amp;gt;
            {
                // Add the required Quartz.NET services
                services.AddQuartz(q =&amp;gt;  
                {
                    // Use a Scoped container to create jobs. I'll touch on this later
                    q.UseMicrosoftDependencyInjectionScopedJobFactory();
                });

                // Add the Quartz.NET hosted service

                services.AddQuartzHostedService(
                    q =&amp;gt; q.WaitForJobsToComplete = true);

                // other config
            });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UseMicrosoftDependencyInjectionScopedJobFactory(),这个地方告诉Quartz.NET注册一个IJobFactory，然后从DI容器中获取Job，这样也可以使用 Scoped 类型的服务。&lt;/p&gt;
&lt;p&gt;WaitForJobsToComplete()：当程序关闭时，此设置可确保Quartz.NET在退出之前等待Job正常结束。&lt;/p&gt;
&lt;p&gt;如果现在运行您的应用程序，您将看到Quartz服务启动，并将有很多日志输出到控制台：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;info: Quartz.Core.SchedulerSignalerImpl[0]
      Initialized Scheduler Signaller of type: Quartz.Core.SchedulerSignalerImpl
info: Quartz.Core.QuartzScheduler[0]
      Quartz Scheduler v.3.2.3.0 created.
info: Quartz.Core.QuartzScheduler[0]
      JobFactory set to: Quartz.Simpl.MicrosoftDependencyInjectionJobFactory
info: Quartz.Simpl.RAMJobStore[0]
      RAMJobStore initialized.
info: Quartz.Core.QuartzScheduler[0]
      Scheduler meta-data: Quartz Scheduler (v3.2.3.0) 'QuartzScheduler' with instanceId 'NON_CLUSTERED'
  Scheduler class: 'Quartz.Core.QuartzScheduler' - running locally.
  NOT STARTED.
  Currently in standby mode.
  Number of jobs executed: 0
  Using thread pool 'Quartz.Simpl.DefaultThreadPool' - with 10 threads.
  Using job-store 'Quartz.Simpl.RAMJobStore' - which does not support persistence. and is not clustered.

info: Quartz.Impl.StdSchedulerFactory[0]
      Quartz scheduler 'QuartzScheduler' initialized
info: Quartz.Impl.StdSchedulerFactory[0]
      Quartz scheduler version: 3.2.3.0
info: Quartz.Core.QuartzScheduler[0]
      Scheduler QuartzScheduler_$_NON_CLUSTERED started.
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，您已经将Quartz作为托管服务运行在您的应用程序中，但是现在还没有添加需要运行的Job。&lt;/p&gt;
&lt;h2 id=&quot;创建一个ijob&quot;&gt;创建一个IJob&lt;/h2&gt;
&lt;p&gt;这个地方我创建一个简单的服务，并且我可以从构造函数中获取服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using Microsoft.Extensions.Logging;
using Quartz;
using System.Threading.Tasks;

[DisallowConcurrentExecution]
public class HelloWorldJob : IJob
{
    private readonly ILogger&amp;lt;HelloWorldJob&amp;gt; _logger;
    public HelloWorldJob(ILogger&amp;lt;HelloWorldJob&amp;gt; logger)
    {
        _logger = logger;
    }

    public Task Execute(IJobExecutionContext context)
    {
        _logger.LogInformation(&quot;Hello world!&quot;);
        return Task.CompletedTask;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我还用[DisallowConcurrentExecution]特性，防止Quartz.NET尝试同时运行同一个作业。&lt;/p&gt;
&lt;h3 id=&quot;设置job&quot;&gt;设置Job&lt;/h3&gt;
&lt;p&gt;这个地方通常使用Cron表达式，来设置job的执行时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
    Host.CreateDefaultBuilder(args)
        .ConfigureServices((hostContext, services) =&amp;gt;
        {
            services.AddQuartz(q =&amp;gt;  
            {
                q.UseMicrosoftDependencyInjectionScopedJobFactory();

                // Create a &quot;key&quot; for the job
                var jobKey = new JobKey(&quot;HelloWorldJob&quot;);

                // Register the job with the DI container
                q.AddJob&amp;lt;HelloWorldJob&amp;gt;(opts =&amp;gt; opts.WithIdentity(jobKey));

                // Create a trigger for the job
                q.AddTrigger(opts =&amp;gt; opts
                    .ForJob(jobKey) // link to the HelloWorldJob
                    .WithIdentity(&quot;HelloWorldJob-trigger&quot;) // give the trigger a unique name
                    .WithCronSchedule(&quot;0/5 * * * * ?&quot;)); // run every 5 seconds

            });
            services.AddQuartzHostedService(q =&amp;gt; q.WaitForJobsToComplete = true);
            // ...
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在运行应用程序，您将看到和以前相同的启动消息，然后每隔5秒钟就会看到HelloWorldJob写入控制台的信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210123_094338.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;将配置提取到appsettingsjson&quot;&gt;将配置提取到appsettings.json&lt;/h2&gt;
&lt;p&gt;一般情况，我们都不会把cron表达式写死在代码中，一般是设置在appsettings.json中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;{
  &quot;Quartz&quot;: {
    &quot;HelloWorldJob&quot;: &quot;0/5 * * * * ?&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了更简单的注册服务，这个地方我简单做了一个封装，这样也更灵活。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static class ServiceCollectionQuartzConfiguratorExtensions
{
    public static void AddJobAndTrigger&amp;lt;T&amp;gt;(
        this IServiceCollectionQuartzConfigurator quartz,
        IConfiguration config)
        where T : IJob
    {
        // Use the name of the IJob as the appsettings.json key
        string jobName = typeof(T).Name;

        // Try and load the schedule from configuration
        var configKey = $&quot;Quartz:{jobName}&quot;;
        var cronSchedule = config[configKey];

        // Some minor validation
        if (string.IsNullOrEmpty(cronSchedule))
        {
            throw new Exception($&quot;No Quartz.NET Cron schedule found for job in configuration at {configKey}&quot;);
        }

        // register the job as before
        var jobKey = new JobKey(jobName);
        quartz.AddJob&amp;lt;T&amp;gt;(opts =&amp;gt; opts.WithIdentity(jobKey));

        quartz.AddTrigger(opts =&amp;gt; opts
            .ForJob(jobKey)
            .WithIdentity(jobName + &quot;-trigger&quot;)
            .WithCronSchedule(cronSchedule)); // use the schedule from configuration
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后修改Program.cs，然后使用扩展方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Program
{
   public static void Main(string[] args) =&amp;gt; CreateHostBuilder(args).Build().Run();

   public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
       Host.CreateDefaultBuilder(args)
           .ConfigureServices((hostContext, services) =&amp;gt;
           {
               services.AddQuartz(q =&amp;gt;
               {
                   q.UseMicrosoftDependencyInjectionScopedJobFactory();

                   // Register the job, loading the schedule from configuration
                   q.AddJobAndTrigger&amp;lt;HelloWorldJob&amp;gt;(hostContext.Configuration);
               });

               services.AddQuartzHostedService(q =&amp;gt; q.WaitForJobsToComplete = true);
           });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行该应用程序将提供相同的输出：Job每5秒输入一次信息。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0672268907563&quot;&gt;
&lt;p&gt;原文作者: andrewlock&lt;br/&gt;原文链接： &lt;a target=&quot;_blank&quot;&gt;https://andrewlock.net/using-quartz-net-with-asp-net-core-and-worker-services/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;欢迎扫码关注我们的公众号 【全球技术精选】，专注国外优秀博客的翻译和开源项目分享，也可以添加QQ群 897216102&lt;/p&gt;
&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/wechat-logo2.png&quot;/&gt;</description>
<pubDate>Sat, 23 Jan 2021 14:03:00 +0000</pubDate>
<dc:creator>SpringLeee</dc:creator>
<og:description>Quartz.NET是功能齐全的开源作业调度系统，可用于最小的应用程序到大型企业系统。 Quartz.NET具有三个主要概念： job：运行的后台任务 trigger：控制后台任务运行的触发器。 sc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myshowtime/p/14319212.html</dc:identifier>
</item>
<item>
<title>对“微信十年产品思考”的思考 - NeilZhang</title>
<link>http://www.cnblogs.com/NeilZhang/p/14319192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeilZhang/p/14319192.html</guid>
<description>&lt;h2 id=&quot;整体感受&quot;&gt;整体感受&lt;/h2&gt;
&lt;p&gt;对于社交/视频/直播的本质有很好的认识，微信的各种功能也是这些本质东西在不同时代背景下的体现。希望自己能get到这些本质的东西。&lt;br/&gt;张小龙对于目标/结果的认知较高，更多的是从产品/用户出发，而不是为了获得什么样的结果/数据才去做什么事情，数据只是最终的一个结果。&lt;/p&gt;
&lt;h2 id=&quot;1-视频号&quot;&gt;1. 视频号&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;   背景：在做视频号之前，微信的价值是有个唯一的id，所有的社交/支持/通信等等都是基于这个id去操作，它是一个非公开的存在。普通用户（公众号/小程序/视频号除外）基于这个id去发朋友圈/视频/生产内容都是在自己的私域，而不能被拿到公域去消费，存在的弊端很明显：好的内容无被广大网友消费。
   视频号是另外一个账号体系，它是一个公开的身份，发的内容可以被公开到公域。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;11-内容发现方式&quot;&gt;1.1 内容发现方式&lt;/h3&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;朋友：&lt;br/&gt;相比与普通的互联网产品（微博/抖音/快手）的内容分发，这里多了一个渠道“朋友”，这也是微信的优势所在，其它产品很难短期内形成微信这样的社交圈，也可以说是不可能。基于社交的内容推荐更有说服力，更能得到用户的肯定。&lt;br/&gt;虽然张小龙一直强调，当内容十分丰富时，机器推荐未来才是会占大头。单从理性角度上讲有一定的道理，因为内容逐渐丰富时，推荐的质量也越高，可以做到越来越逼近用户的真正需求。但是人类的社交不是简单的去阅读自己喜欢的内容，人们也会十分关注身边人在看什么/做什么/玩什么，这也成为自己了解自己朋友家人的一种渠道，所以我觉得朋友这一部分一直会占有很高的比例，也是无法被推荐所替代的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;推荐：&lt;br/&gt;容易形成负向的循环，也容易形成正向的循环。前期内容较少/质量较差时推荐的效果也很差，需要依赖其它手段去做推荐。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;关注：&lt;br/&gt;自己关注人的内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;12-tab内部呈现形式：-瀑布流-vs-全屏&quot;&gt;1.2 tab内部呈现形式： 瀑布流 vs 全屏&lt;/h3&gt;
&lt;p&gt;一屏里的内容条数，应当跟命中率成反比： 你越是确定这是用户感兴趣的东西，你就可以让他展现的区域越大，如果你百分之一百确定，那就可以全屏去展示，因为这样的阅读/观看效果最好。&lt;br/&gt;朋友圈没有去做全屏浏览也是因为，你并不是对每条朋友圈对内容都干兴趣，更多的是浏览一下。&lt;/p&gt;
&lt;h2 id=&quot;2-直播&quot;&gt;2. 直播&lt;/h2&gt;
&lt;p&gt;背景：&lt;br/&gt;互联网的内容形态一直在改变： 博客-图片-视频 （普通人更能生产/消费）- 直播&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;张小龙把直播说成“短视频”的更高形态，门槛更低，能被更多的人接受，这一点我并不是很认同。&lt;br/&gt;它们更多是一种互补的关系，直播的门槛也不比短视频低，它不同与一般的聊天，你要掌握了一定知识/准备了一定的东西才能直播。说它们是互补关系，是因为我觉得直播只是实时性高一点的短视频，对于实时性要求不高的内容（例如知识分享，但是像直播带货/娱乐互动类型的实时性比较高），直播后的视频就是一种很好的视频内容。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;终极形态：每个人可以通过直播人的眼睛看到他所看到的&lt;/p&gt;
&lt;h2 id=&quot;3-产品观点&quot;&gt;3. 产品/观点&lt;/h2&gt;
&lt;p&gt;对于视频/直播不做流量推广，通过社交去推广。让真正去做好内容的用户去获得回报，而不是花钱买量的用户获得回报。（抖音/快手做不到这一点，没有社交关系）&lt;br/&gt;社交化的产品很难提前知道他在用户中的效果，只有当用户真正参与/互动到过程中才能知道结果。&lt;br/&gt;拍一拍/表情是对古老人与人表达的一种方式对模拟&lt;br/&gt;产品是拼创造力而不是拼人力，人多内耗也会很大&lt;/p&gt;
&lt;h2 id=&quot;4-微信十年总结&quot;&gt;4. 微信十年总结&lt;/h2&gt;
&lt;p&gt;连接：世界由万生万物连接起来，微信可以做最底层的设施，连接万物可以产生非常丰富的结果出来。 连接人/连接内容/连接服务，通俗点讲其实就是做平台，但又不是单一对平台，各个平台之间通过社交联系起来又会产生不一样对结果&lt;br/&gt;简单： 美观/实用/优雅，最简单的有可能是最好的&lt;/p&gt;
&lt;h2 id=&quot;5-提出问题&quot;&gt;5. 提出问题&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;很好奇微信的kpi考核是怎么样，张小龙很强调从产品本身/用户思考，不已结果（数据）为目标？&lt;/li&gt;
&lt;li&gt;好的数据一定是好的产品？现在很多互联网产品都会通过各种红包/签到/任务体系来提高时长/留存。这种方式能吸引用户来体验产品，但是并不能提升产品，为什么每个产品都百分之两百对热衷于此？&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 23 Jan 2021 13:58:00 +0000</pubDate>
<dc:creator>NeilZhang</dc:creator>
<og:description>整体感受 对于社交/视频/直播的本质有很好的认识，微信的各种功能也是这些本质东西在不同时代背景下的体现。希望自己能get到这些本质的东西。 张小龙对于目标/结果的认知较高，更多的是从产品/用户出发，而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/NeilZhang/p/14319192.html</dc:identifier>
</item>
<item>
<title>RecyclerView 源码分析（二） —— 缓存机制 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/14288574.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/14288574.html</guid>
<description>&lt;p&gt;在前一篇文章 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/huansky/p/14252980.html&quot;&gt;RecyclerView 源码分析（一） —— 绘制流程解析&lt;/a&gt; 介绍了 RecyclerView 的绘制流程，RecyclerView 通过将绘制流程从 View 中抽取出来，放到 LayoutManager 中，使得 RecyclerView 在不同的 LayoutManager 中，拥有不同的样式，使得 RecyclerView 异常灵活，大大加强了 RecyclerView 使用场景。&lt;/p&gt;
&lt;p&gt;当然，RecyclerView 的缓存机制也是它特有的一个优点，减少了对内存的占用以及重复的绘制工作，因此，本文意在介绍和学习 RecyclerView 的缓存设计思想。&lt;/p&gt;
&lt;p&gt;当我们在讨论混存的时候，一定会经历创建-缓存-复用的过程。因此对于 RecyclerView 的缓存机制也是按照如下的步骤进行。&lt;/p&gt;

&lt;p&gt;在讲到对子 itemView 测量的时候，layoutChunk 方法中会先获得每一个 itemView，在获取后，在将其添加到 RecyclerView 中。所以我们先来看看创建的过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        View next(RecyclerView.Recycler recycler) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mScrapList != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextViewFromScrapList();
            }
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; View view =&lt;span&gt; recycler.getViewForPosition(mCurrentPosition);
            mCurrentPosition &lt;/span&gt;+=&lt;span&gt; mItemDirection;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; view;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;next &lt;/code&gt;就是调用 &lt;code&gt;RecyclerView &lt;/code&gt;的 &lt;code&gt;getViewForPosition &lt;/code&gt;方法来获取一个 &lt;code&gt;View &lt;/code&gt;的。而 &lt;code&gt;getViewForPosition &lt;/code&gt;方法最终会调用到 &lt;code&gt;RecyclerView &lt;/code&gt;的&lt;code&gt;tryGetViewHolderForPositionByDeadline &lt;/code&gt;方法。&lt;/p&gt;
&lt;h3&gt;tryGetViewHolderForPositionByDeadline&lt;/h3&gt;
&lt;p&gt;这个方法很长，但是其实逻辑很简单，整个过程前面部分是先从缓存尝试获取 VH，如果找不到，就会创建新的 VH，然后绑定数据，最后将再将 VH 绑定到 LayoutParams (LP) 上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
        ViewHolder tryGetViewHolderForPositionByDeadline(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; position,
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; dryRun, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; deadlineNs) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (position &amp;lt; 0 || position &amp;gt;=&lt;span&gt; mState.getItemCount()) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IndexOutOfBoundsException(&quot;Invalid item position &quot; +&lt;span&gt; position
                        &lt;/span&gt;+ &quot;(&quot; + position + &quot;). Item count:&quot; +&lt;span&gt; mState.getItemCount()
                        &lt;/span&gt;+&lt;span&gt; exceptionLabel());
            }
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; fromScrapOrHiddenOrCache = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            ViewHolder holder &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略从缓存查找 VH 的逻辑，下面是如果还是没找到，就会创建一个新的&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (holder == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; getNanoTime();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (deadlineNs !=&lt;span&gt; FOREVER_NS
                            &lt;/span&gt;&amp;amp;&amp;amp; !&lt;span&gt;mRecyclerPool.willCreateInTime(type, start, deadlineNs)) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; abort - we have a deadline we can't meet&lt;/span&gt;
                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    }&lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　// 创建 VH 
&lt;/span&gt;                    holder &lt;/span&gt;= mAdapter.createViewHolder(RecyclerView.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, type);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ALLOW_THREAD_GAP_WORK) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; only bother finding nested RV if prefetching&lt;/span&gt;
                        RecyclerView innerView =&lt;span&gt; findNestedRecyclerView(holder.itemView);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (innerView != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            holder.mNestedRecyclerView &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;&lt;span&gt;(innerView);
                        }
                    }

                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; getNanoTime();
                    mRecyclerPool.factorInCreateTime(type, end &lt;/span&gt;-&lt;span&gt; start);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG) {
                        Log.d(TAG, &lt;/span&gt;&quot;tryGetViewHolderForPositionByDeadline created new ViewHolder&quot;&lt;span&gt;);
                    }
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is very ugly but the only place we can grab this information
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; before the View is rebound and returned to the LayoutManager for post layout ops.
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We don't need this in pre-layout since the VH is not updated by the LM.&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (fromScrapOrHiddenOrCache &amp;amp;&amp;amp; !mState.isPreLayout() &amp;amp;&amp;amp;&lt;span&gt; holder
                    .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) {
                holder.setFlags(&lt;/span&gt;0&lt;span&gt;, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mState.mRunSimpleAnimations) {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; changeFlags =&lt;span&gt; ItemAnimator
                            .buildAdapterChangeFlagsForAnimations(holder);
                    changeFlags &lt;/span&gt;|=&lt;span&gt; ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;
                    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ItemHolderInfo info =&lt;span&gt; mItemAnimator.recordPreLayoutInformation(mState,
                            holder, changeFlags, holder.getUnmodifiedPayloads());
                    recordAnimationInfoIfBouncedHiddenView(holder, info);
                }
            }

            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; bound = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mState.isPreLayout() &amp;amp;&amp;amp;&lt;span&gt; holder.isBound()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do not update unless we absolutely have to.&lt;/span&gt;
                holder.mPreLayoutPosition =&lt;span&gt; position;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!holder.isBound() || holder.needsUpdate() ||&lt;span&gt; holder.isInvalid()) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (DEBUG &amp;amp;&amp;amp;&lt;span&gt; holder.isRemoved()) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Removed holder should be bound and it should&quot;
                            + &quot; come here only in pre-layout. Holder: &quot; +&lt;span&gt; holder
                            &lt;/span&gt;+&lt;span&gt; exceptionLabel());
                }
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; offsetPosition =&lt;span&gt; mAdapterHelper.findPositionOffset(position);&lt;br/&gt;&lt;span&gt;　　　　　　　　　 // 进行数据绑定
&lt;/span&gt;                bound &lt;/span&gt;=&lt;span&gt; tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
            }

            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ViewGroup.LayoutParams lp =&lt;span&gt; holder.itemView.getLayoutParams();
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; LayoutParams rvLayoutParams;&lt;br/&gt;&lt;span&gt;　　　　　　　// 下面逻辑就是将 VH 绑定到 LP, LP 又设置到 ItemView  上
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lp == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                rvLayoutParams &lt;/span&gt;=&lt;span&gt; (LayoutParams) generateDefaultLayoutParams();
                holder.itemView.setLayoutParams(rvLayoutParams);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;checkLayoutParams(lp)) {
                rvLayoutParams &lt;/span&gt;=&lt;span&gt; (LayoutParams) generateLayoutParams(lp);
                holder.itemView.setLayoutParams(rvLayoutParams);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                rvLayoutParams &lt;/span&gt;=&lt;span&gt; (LayoutParams) lp;
            }
            rvLayoutParams.mViewHolder &lt;/span&gt;=&lt;span&gt; holder;
            rvLayoutParams.mPendingInvalidate &lt;/span&gt;= fromScrapOrHiddenOrCache &amp;amp;&amp;amp;&lt;span&gt; bound;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; holder;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 即使省略了中间从缓存查找 VH 的逻辑，剩下部分的代码还是很长。那我再概括下 tryGetViewHolderForPositionByDeadline 方法所做的事：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;从缓存查找 VH ;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;缓存没有，那么就创建一个 VH；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;判断 VH 需不需要更新数据，如果需要就会调用 tryBindViewHolderByDeadline 绑定数据；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;将 VH 绑定到 LP, LP 又设置到 ItemView 上，互相依赖；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;到这里关于创建 VH 的逻辑就讲完了。&lt;/p&gt;

&lt;p&gt;在介绍添加到缓存的逻辑时，还是需要介绍缓存相关的类和变量。&lt;/p&gt;
&lt;h3&gt;缓存整体设计&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/916005/202101/916005-20210123202534774-1581817291.png&quot; alt=&quot;&quot; width=&quot;349&quot; height=&quot;434&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;由图可知，RecyclerView 缓存是一个四级缓存的架构。当然，从 RecyclerView 的代码注释来看，官方认为只有三级缓存，即mCachedViews是一级缓存，mViewCacheExtension 是二级缓存，mRecyclerPool 是三级缓存。从开发者的角度来看，mAttachedScrap 和 mChangedScrap 对开发者是不透明的，官方并未暴露出任何可以改变他们行为的方法。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;h3&gt;缓存机制 Recycler 详解&lt;/h3&gt;
&lt;p&gt;Recycler 是 RecyclerView 的一个内部类。我们来看一下它的主要的成员变量。&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;ul readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;mAttachedScrap 缓存屏幕中可见范围的 ViewHolder&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;final ArrayList&amp;lt;ViewHolder&amp;gt; mAttachedScrap = new ArrayList&amp;lt;&amp;gt;();&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;mChangedScrap 缓存滑动时即将与 RecyclerView 分离的ViewHolder，按子View的position或id缓存，默认最多存放2个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;ArrayList&amp;lt;ViewHolder&amp;gt; mChangedScrap = null;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;mCachedViews  ViewHolder 缓存列表，其大小由 mViewCacheMax 决定，默认 DEFAULT_CACHE_SIZE 为 2，可动态设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;final ArrayList&amp;lt;ViewHolder&amp;gt; mCachedViews = new ArrayList&amp;lt;ViewHolder&amp;gt;();&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;ViewCacheExtension 开发者可自定义的一层缓存，是虚拟类 ViewCacheExtension 的一个实例，开发者可实现方法 getViewForPositionAndType(Recycler recycler, int position, int type) 来实现自己的缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;private ViewCacheExtension mViewCacheExtension;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;RecycledViewPool ViewHolder 缓存池，在有限的 mCachedViews 中如果存不下 ViewHolder 时，就会把 ViewHolder 存入 RecyclerViewPool 中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RecycledViewPool mRecyclerPool;&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;添加到缓存&lt;/h2&gt;
&lt;p&gt;VH 被创建之后，是要被缓存，然后重复利用的，那么他们是什么时候被添加到缓存的呢？此处还是以 LinearLayoutManager 举例说明。在 &lt;span&gt;&lt;code&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/huansky/p/14252980.html&quot;&gt;RecyclerView 源码分析（一） —— 绘制流程解析&lt;/a&gt; &lt;span&gt;一文中曾提到一个方法：&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {&lt;/span&gt;&lt;span&gt;
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
　　　　　detachAndScrapAttachedViews(recycler);  &lt;span&gt;
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; onLayoutChildren 是对子 view 进行绘制。在对子 view 会先调用 detachAndScrapAttachedViews 方法，下面来看看这个方法。&lt;/p&gt;
&lt;h3&gt;detachAndScrapAttachedViews&lt;/h3&gt;
&lt;p&gt;下面来看下这个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;       //&lt;/span&gt;&lt;span&gt; recyclerview      &lt;/span&gt;
       &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; detachAndScrapAttachedViews(@NonNull Recycler recycler) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; childCount =&lt;span&gt; getChildCount();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = childCount - 1; i &amp;gt;= 0; i--&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; View v =&lt;span&gt; getChildAt(i);&lt;br/&gt;&lt;span&gt;　　　　　　　　　　// 每个 view 都会放到里面
&lt;/span&gt;                scrapOrRecycleView(recycler, i, v);
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; scrapOrRecycleView(Recycler recycler, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, View view) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ViewHolder viewHolder =&lt;span&gt; getChildViewHolderInt(view);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (viewHolder.shouldIgnore()) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DEBUG) {
                    Log.d(TAG, &lt;/span&gt;&quot;ignoring view &quot; +&lt;span&gt; viewHolder);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }&lt;br/&gt;&lt;span&gt;　　　　　　　 // 如果 VH 无效，并且已经被移除了，就会走另一个逻辑
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (viewHolder.isInvalid() &amp;amp;&amp;amp; !&lt;span&gt;viewHolder.isRemoved()
                    &lt;/span&gt;&amp;amp;&amp;amp; !&lt;span&gt;mRecyclerView.mAdapter.hasStableIds()) {
               &lt;span&gt; removeViewAt(index);
                recycler.recycleViewHolderInternal(viewHolder);&lt;/span&gt;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　　　　　&lt;span&gt;　　// 先 detch 掉，然后放入缓存中&lt;/span&gt;
&lt;span&gt;                detachViewAt(index);
&lt;/span&gt;              &lt;span&gt;  recycler.scrapView(view);
                mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);&lt;/span&gt;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是在上面的逻辑里，被放到缓存中。这里就可以看到&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果是 remove，会执行 &lt;code&gt;recycleViewHolderInternal(viewHolder) &lt;/code&gt;方法，而这个方法最终会将 ViewHolder 加入 CacheView 和 Pool 中，&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;而当是 Detach，会将 View 加入到 ScrapViews 中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;需要指出的一点是：需要区分两个概念，&lt;strong&gt;Detach &lt;/strong&gt;和 &lt;strong&gt;Remove&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;detach&lt;/strong&gt;: 在 ViewGroup 中的实现很简单，只是将 ChildView 从 ParentView 的 ChildView 数组中移除，ChildView 的 mParent 设置为 null, 可以理解为轻量级的临时 remove, 因为 View此时和 View 树还是藕断丝连, 这个函数被经常用来改变 ChildView 在 ChildView 数组中的次序。View 被 detach 一般是临时的，在后面会被重新 attach。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;remove&lt;/strong&gt;: 真正的移除，不光被从 ChildView 数组中除名，其他和 View 树各项联系也会被彻底斩断(不考虑 Animation/LayoutTransition 这种特殊情况)， 比如焦点被清除，从TouchTarget 中被移除等。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;recycleViewHolderInternal&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;下面来看 Recycler 两个的具体逻辑方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * internal implementation checks if view is scrapped or attached and throws an exception
         * if so.
         * Public version un-scraps before calling recycle.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; recycleViewHolderInternal(ViewHolder holder) {&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　// ...省略前面的代码，前面都是在做检验
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; transientStatePreventsRecycling =&lt;span&gt; holder
                    .doesTransientStatePreventRecycling();
            @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; forceRecycle = mAdapter != &lt;span&gt;null&lt;/span&gt;
                    &amp;amp;&amp;amp;&lt;span&gt; transientStatePreventsRecycling
                    &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; mAdapter.onFailedToRecycleView(holder);
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; cached = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; recycled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (DEBUG &amp;amp;&amp;amp;&lt;span&gt; mCachedViews.contains(holder)) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;cached view received recycle internal? &quot;
                        + holder +&lt;span&gt; exceptionLabel());
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (forceRecycle ||&lt;span&gt; holder.isRecyclable()) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mViewCacheMax &amp;gt; 0
                        &amp;amp;&amp;amp; !&lt;span&gt;holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID
                        &lt;/span&gt;|&lt;span&gt; ViewHolder.FLAG_REMOVED
                        &lt;/span&gt;|&lt;span&gt; ViewHolder.FLAG_UPDATE
                        &lt;/span&gt;|&lt;span&gt; ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Retire oldest cached view 如果缓存数量超了，就会先移除最先加入的&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; cachedViewSize =&lt;span&gt; mCachedViews.size();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cachedViewSize &amp;gt;= mViewCacheMax &amp;amp;&amp;amp; cachedViewSize &amp;gt; 0&lt;span&gt;) {
                        recycleCachedViewAt(&lt;/span&gt;0&lt;span&gt;);
                        cachedViewSize&lt;/span&gt;--&lt;span&gt;;
                    }

                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; targetCacheIndex =&lt;span&gt; cachedViewSize;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ALLOW_THREAD_GAP_WORK
                            &lt;/span&gt;&amp;amp;&amp;amp; cachedViewSize &amp;gt; 0
                            &amp;amp;&amp;amp; !&lt;span&gt;mPrefetchRegistry.lastPrefetchIncludedPosition(holder.mPosition)) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; when adding the view, skip past most recently prefetched views&lt;/span&gt;
                        &lt;span&gt;int&lt;/span&gt; cacheIndex = cachedViewSize - 1&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (cacheIndex &amp;gt;= 0&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cachedPos =&lt;span&gt; mCachedViews.get(cacheIndex).mPosition;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mPrefetchRegistry.lastPrefetchIncludedPosition(cachedPos)) {
                                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                            }
                            cacheIndex&lt;/span&gt;--&lt;span&gt;;
                        }
                        targetCacheIndex &lt;/span&gt;= cacheIndex + 1&lt;span&gt;;
                    }&lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　// 添加到缓存
&lt;/span&gt;                    mCachedViews.add(targetCacheIndex, holder);
                    cached &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cached) {
                    addViewHolderToRecycledViewPool(holder, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    recycled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
         &lt;/span&gt;&lt;span&gt;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; even if the holder is not removed, we still call this method so that it is removed
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; from view holder lists.&lt;/span&gt;
&lt;span&gt;            mViewInfoStore.removeViewHolder(holder);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!cached &amp;amp;&amp;amp; !recycled &amp;amp;&amp;amp;&lt;span&gt; transientStatePreventsRecycling) {
                holder.mOwnerRecyclerView &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法所做的事具体如下：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;检验该 VH 的有效性，确保已经不再被使用；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;判断缓存的容量，超了就会进行移除，然后找一个合适的位置进行添加。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果不能加入到 CacheViews 中，则加入到 Pool 中。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div readability=&quot;10&quot;&gt;
&lt;h3&gt;&lt;strong&gt;mCachedViews&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;mCachedViews 对应的数据结构也是 ArrayList 但是该缓存对集合的大小是有限制的，默认是 2。该缓存中 ViewHolder 的特性和 mAttachedScrap 中的特性是一样的，只要 position或者 itemId 对应上了，那么它就是干净的，无需重新绑定数据。开发者可以调用 setItemViewCacheSize(size) 方法来改变缓存的大小。该层级缓存触发的一个常见的场景是滑动 RV。当然 notifyXXX 也会触发该缓存。该缓存和 mAttachedScrap 一样特别高效。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;h3&gt;&lt;strong&gt;RecyclerViewPool&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;RecyclerViewPool 缓存可以针对多ItemType，设置缓存大小。默认每个 ItemType 的缓存个数是 5。而且该缓存可以给多个 RecyclerView 共享。由于默认缓存个数为 5，假设某个新闻 App，每屏幕可以展示 10 条新闻，那么必然会导致缓存命中失败，频繁导致创建 ViewHolder 影响性能。所以需要扩大缓存size。&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;scrapView&lt;/h3&gt;
&lt;p&gt;接下去看 scrapView 这个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; scrapView(View view) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ViewHolder holder =&lt;span&gt; getChildViewHolderInt(view);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED |&lt;span&gt; ViewHolder.FLAG_INVALID)
                    &lt;/span&gt;|| !holder.isUpdated() ||&lt;span&gt; canReuseUpdatedViewHolder(holder)) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (holder.isInvalid() &amp;amp;&amp;amp; !holder.isRemoved() &amp;amp;&amp;amp; !&lt;span&gt;mAdapter.hasStableIds()) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Called scrap view with an invalid view.&quot;
                            + &quot; Invalid views cannot be reused from scrap, they should rebound from&quot;
                            + &quot; recycler pool.&quot; +&lt;span&gt; exceptionLabel());
                }
                holder.setScrapContainer(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;); &lt;span&gt;// 这里的 false&lt;/span&gt; 
&lt;span&gt;                mAttachedScrap.add(holder);
&lt;/span&gt;            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mChangedScrap == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    mChangedScrap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;ViewHolder&amp;gt;&lt;span&gt;();
                }
                holder.setScrapContainer(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);  &lt;span&gt;// 这里是 true&lt;/span&gt;
&lt;span&gt;                mChangedScrap.add(holder);
&lt;/span&gt;            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;该方法就比较简单了，没有那么多需要检验的逻辑。这里根据条件，有两种缓存类型可以选择，具体就不展开了，大家都可以看懂。这里讲解下两个 scrapView 的缓存。&lt;/p&gt;
&lt;h3&gt;mAttachedScrap&lt;/h3&gt;
&lt;div readability=&quot;37.5&quot;&gt;
&lt;p&gt;mAttachedScrap 的对应数据结构是ArrayList，在 LayoutManager#onLayoutChildren 方法中，对 views 进行布局时，会将 RecyclerView 上的 Views 全部暂存到该集合中，以备后续使用，该缓存中的 ViewHolder 的特性是，如果和 RV 上的 position 或者 itemId 匹配上了，那么认为是干净的 ViewHolder，是可以直接拿出来使用的，无需调用 onBindViewHolder 方法。该 ArrayList 的大小是没有限制的，屏幕上有多少个 View，就会创建多大的集合。&lt;/p&gt;
&lt;p&gt;触发该层级缓存的场景一般是调用 notifyItemXXX 方法。调用 notifyDataSetChanged 方法，只有当 Adapter hasStableIds 返回 true，会触发该层级的缓存使用。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;mChangedScrap&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;mChangedScrap 和 mAttachedScrap 是同一级的缓存，他们是平等的。但是mChangedScrap的调用场景是notifyItemChanged和notifyItemRangeChanged，只有发生变化的ViewHolder才会放入到 mChangedScrap 中。mChangedScrap缓存中的ViewHolder是需要调用onBindViewHolder方法重新绑定数据的。那么此时就有个问题了，为什么同一级别的缓存需要设计两个不同的缓存？&lt;/p&gt;
&lt;p&gt;在 dispatchLayoutStep2 阶段 LayoutManager onLayoutChildren方法中最终会调用 layoutForPredictiveAnimations 方法，把 mAttachedScrap 中剩余的 ViewHolder 填充到屏幕上，所以他们的区别就是，mChangedScrap 中的 ViewHolder 在 RV 填充满的情况下，是不会强行填充到 RV 上的。那么有办法可以让发生改变的 ViewHolder 进入 mAttachedScrap 缓存吗？当然可以。调用 notifyItemChanged(int position, Object payload) 方法可以，实现局部刷新功能，payload 不为空，那么发生改变的 ViewHolder 是会被分离到 mAttachedScrap 中的。&lt;/p&gt;

&lt;p&gt;下面进入到最后一节，使用缓存。这个在之前绘制篇幅也有提到，下面直接看对应的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据传入的position获取ViewHolder &lt;/span&gt;
ViewHolder tryGetViewHolderForPositionByDeadline(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; position,
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; dryRun, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; deadlineNs) {
    &lt;/span&gt;---------省略----------
    &lt;span&gt;boolean&lt;/span&gt; fromScrapOrHiddenOrCache = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    ViewHolder holder &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;预布局 属于特殊情况 从mChangedScrap中获取ViewHolder&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mState.isPreLayout()) {
        holder &lt;/span&gt;=&lt;span&gt; getChangedScrapViewForPosition(position);
        fromScrapOrHiddenOrCache &lt;/span&gt;= holder != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (holder == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、尝试从mAttachedScrap中获取ViewHolder,此时获取的是屏幕中可见范围中的ViewHolder
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、mAttachedScrap缓存中没有的话，继续从mCachedViews尝试获取ViewHolder&lt;/span&gt;
        holder =&lt;span&gt; getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);
     &lt;/span&gt;----------省略----------&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (holder == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; offsetPosition =&lt;span&gt; mAdapterHelper.findPositionOffset(position);
        &lt;/span&gt;---------省略----------
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; type =&lt;span&gt; mAdapter.getItemViewType(offsetPosition);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果Adapter中声明了Id，尝试从id中获取，这里不属于缓存&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mAdapter.hasStableIds()) {
            holder &lt;/span&gt;=&lt;span&gt; getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),
                    type, dryRun);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (holder == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; mViewCacheExtension != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;3&lt;span&gt;、从自定义缓存mViewCacheExtension中尝试获取ViewHolder，该缓存需要开发者实现
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; View view =&lt;span&gt; mViewCacheExtension
                    .getViewForPositionAndType(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, position, type);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (view != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                holder &lt;/span&gt;=&lt;span&gt; getChildViewHolder(view);
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (holder == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; fallback to pool
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、从缓存池mRecyclerPool中尝试获取ViewHolder&lt;/span&gt;
            holder =&lt;span&gt; getRecycledViewPool().getRecycledView(type);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (holder != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果获取成功，会重置ViewHolder状态，所以需要重新执行Adapter#onBindViewHolder绑定数据&lt;/span&gt;
&lt;span&gt;                holder.resetInternal();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (FORCE_INVALIDATE_DISPLAY_LIST) {
                    invalidateDisplayListInt(holder);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (holder == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;---------省略----------
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5、若以上缓存中都没有找到对应的ViewHolder，最终会调用Adapter中的onCreateViewHolder创建一个&lt;/span&gt;
            holder = mAdapter.createViewHolder(RecyclerView.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, type);
        }
    }

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; bound = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mState.isPreLayout() &amp;amp;&amp;amp;&lt;span&gt; holder.isBound()) {
        holder.mPreLayoutPosition &lt;/span&gt;=&lt;span&gt; position;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!holder.isBound() || holder.needsUpdate() ||&lt;span&gt; holder.isInvalid()) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; offsetPosition =&lt;span&gt; mAdapterHelper.findPositionOffset(position);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6、如果需要绑定数据，会调用Adapter#onBindViewHolder来绑定数据&lt;/span&gt;
        bound =&lt;span&gt; tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
    }
    &lt;/span&gt;----------省略----------
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; holder;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述逻辑用流程图表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/916005/202101/916005-20210123214211555-2028302424.png&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;359&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;div readability=&quot;14&quot;&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;p&gt;总结一下上述流程：&lt;strong&gt;通过 mAttachedScrap、mCachedViews 及 mViewCacheExtension 获取的 ViewHolder 不需要重新创建布局及绑定数据；通过缓存池 mRecyclerPool 获取的 ViewHolder不需要重新创建布局，但是需要重新绑定数据；如果上述缓存中都没有获取到目标 ViewHolder，那么就会回调 Adapter#onCreateViewHolder 创建布局，以及回调 Adapter#onBindViewHolder来绑定数据。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;ViewCacheExtension&lt;/h3&gt;
&lt;p&gt;我们已经知道 ViewCacheExtension 属于第三级缓存，需要开发者自行实现，那么 ViewCacheExtension 在什么场景下使用？又是如何实现的呢？&lt;/p&gt;
&lt;p&gt;首先我们要明确一点，那就是 &lt;code&gt;Recycler &lt;/code&gt;本身已经设置了好几级缓存了，为什么还要留个接口让开发者去自行实现缓存呢？&lt;/p&gt;
&lt;p&gt;关于这一点，来看看 &lt;code&gt;Recycler &lt;/code&gt;中的其他缓存：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;mAttachedScrap &lt;/code&gt;用来处理可见屏幕的缓存；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;mCachedViews &lt;/code&gt;里存储的数据虽然是根据 &lt;code&gt;position &lt;/code&gt;来缓存，但是里面的数据随时可能会被替换的；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;mRecyclerPool &lt;/code&gt;里按 &lt;code&gt;viewType &lt;/code&gt;去存储 &lt;code&gt;ArrayList&amp;lt; ViewHolder&amp;gt;&lt;/code&gt;，所以 &lt;code&gt;mRecyclerPool &lt;/code&gt;并不能按 &lt;code&gt;position &lt;/code&gt;去存储 &lt;code&gt;ViewHolder&lt;/code&gt;，而且从 &lt;code&gt;mRecyclerPool &lt;/code&gt;取出的 &lt;code&gt;View &lt;/code&gt;每次都要去走 &lt;code&gt;Adapter#onBindViewHolder &lt;/code&gt;去重新绑定数据。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;假如我现在需要在一个特定的位置(比如 position=0 位置)一直展示某个 View，且里面的内容是不变的，那么最好的情况就是在特定位置时，既不需要每次重新创建 View，也不需要每次都去重新绑定数据，上面的几种缓存显然都是不适用的，这种情况该怎么办呢？可以通过自定义缓存 &lt;code&gt;ViewCacheExtension &lt;/code&gt;实现上述需求。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div readability=&quot;8.5165622202328&quot;&gt;
&lt;div readability=&quot;12.301700984781&quot;&gt;

&lt;p&gt;结论援引自：&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzA3NTYzODYzMg%3D%3D%26mid%3D2653578065%26idx%3D2%26sn%3D25e64a8bb7b5934cf0ce2e49549a80d6%26chksm%3D84b3b156b3c43840061c28869671da915a25cf3be54891f040a3532e1bb17f9d32e244b79e3f%26scene%3D21%23wechat_redirect&quot; target=&quot;_blank&quot;&gt;Android ListView 与 RecyclerView 对比浅析--缓存机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ListView和RecyclerView缓存机制基本一致：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;mActiveViews 和 mAttachedScrap 功能相似，意义在于快速重用屏幕上可见的列表项ItemView，而不需要重新 createView 和 bindView；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;mScrapView 和 mCachedViews + mReyclerViewPool功能相似，意义在于缓存离开屏幕的 ItemView，目的是让即将进入屏幕的 ItemView 重用.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;RecyclerView 的优势在于&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;mCacheViews 的使用，可以做到屏幕外的列表项 ItemView 进入屏幕内时也无须bindView快速重用；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;mRecyclerPool 可以供多个 RecyclerView 共同使用，在特定场景下，如 viewpaper+ 多个列表页下有优势.客观来说，RecyclerView 在特定场景下对 ListView 的缓存机制做了补强和完善。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不同使用场景：&lt;strong&gt;列表页展示界面，需要支持动画，或者频繁更新，局部刷新，建议使用 RecyclerView，更加强大完善，易扩展；其它情况(如微信卡包列表页)两者都OK，但ListView在使用上会更加方便，快捷。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;参考文章&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/2b19e9bcda84&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/2b19e9bcda84&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/6e6bf58b7f0d&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/6e6bf58b7f0d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/e1b257484961&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/e1b257484961&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;articleContentId&quot; class=&quot;title-article&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/c10wtiybq1ye3/article/details/106065952&quot; target=&quot;_blank&quot;&gt;RecyclerView加载了那么多图，为什么就是不崩呢？&lt;/a&gt;&lt;/h3&gt;
</description>
<pubDate>Sat, 23 Jan 2021 13:53:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>在前一篇文章&amp;#160;RecyclerView 源码分析（一） —— 绘制流程解析&amp;#160;介绍了&amp;#160;RecyclerView 的绘制流程，RecyclerView 通过将绘制流程从 Vi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huansky/p/14288574.html</dc:identifier>
</item>
<item>
<title>核酸检测：让我明白AQS原理 - 叫练</title>
<link>http://www.cnblogs.com/jiaolian/p/14319024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiaolian/p/14319024.html</guid>
<description>&lt;p&gt;春节越来越近了，疫情也越来越严重，但挡不住叫练携一家老小回老家（湖北）团聚的冲动。响应国家要求去我们做&lt;strong&gt;核酸检测&lt;/strong&gt;了。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1897706/1611306766342-6abb6877-c070-44f0-b609-619b98618abf.png#align=left&amp;amp;display=inline&amp;amp;height=347&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=347&amp;amp;originWidth=505&amp;amp;size=63717&amp;amp;status=done&amp;amp;style=none&amp;amp;width=505&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;独占锁&quot;&gt;独占锁&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;早上叫练带着一家三口来到了南京市第一医院做核酸检测，护士小姐姐站在医院门口拦着告诉我们人比较多，无论大人小孩，需要排队一个个等待医生采集唾液检测，OK，下面我们用代码+图看看我们一家三口是怎么排队的！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author ：jiaolian
 * @date ：Created in 2021-01-22 10:33
 * @description：独占锁测试
 * @modified By：
 * 公众号:叫练
 */
public class ExclusiveLockTest {

    private static ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    private static ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();

    //医院
    private static class Hospital {

        private String name;

        public Hospital(String name) {
            this.name = name;
        }

        //核酸检测排队测试
        public void checkUp() {
            try {
                writeLock.lock();
                System.out.println(Thread.currentThread().getName()+&quot;正在做核酸检测&quot;);
                //核酸过程...难受...
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                writeLock.unlock();
            }
        }
    }


    public static void main(String[] args) throws InterruptedException {
        Hospital hospital = new Hospital(&quot;南京市第一医院&quot;);
        Thread JLWife = new Thread(()-&amp;gt;hospital.checkUp(),&quot;叫练妻&quot;);
        JLWife.start();
        //睡眠100毫秒是让一家三口是有顺序的排队去检测
        Thread.sleep(100);
        Thread JLSon = new Thread(()-&amp;gt;hospital.checkUp(),&quot;叫练子&quot;);
        JLSon.start();
        Thread.sleep(100);
        Thread JL = new Thread(()-&amp;gt;hospital.checkUp(),&quot;叫练&quot;);
        JL.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码：在主线程启动三个线程去医院门口排队，&lt;strong&gt;女士优先&lt;/strong&gt;，叫练妻是排在最前面的，中间站的是叫练的孩子，最后就是叫练自己了。我们假设模拟了下核酸检测一次需要３秒。代码中我们用了独占锁，独占锁可以理解成医院只有一个医生，一个医生同时只能为一个人做核酸，所以需要逐个排队检测，所以代码执行完毕一共需要花费９秒，核酸检测就可以全部做完。代码逻辑还是比较简单，和我们之前文章描述synchronized同理。核酸排队我们用图描述下吧！&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1897706/1611284683327-328575c1-1adc-40f3-9b99-813456f3fcc5.png#align=left&amp;amp;display=inline&amp;amp;height=407&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=407&amp;amp;originWidth=957&amp;amp;size=67154&amp;amp;status=done&amp;amp;style=none&amp;amp;width=957&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AQS全称是&lt;strong&gt;AbstractQueueSynchroniz，意为队列同步器&lt;/strong&gt;，本质上是一个双向链表，在AQS里面每个线程都被封装成一个Node节点，每个节点都通过尾插法添加。另外节点还有还封装状态信息，比如是独占的还是共享的，如上面的案例就表示独占Node，医生他本身是一种共享资源，在AQS内部里面叫它state，用int类型表示，线程都会通过CAS的方式争抢state。线程抢到锁了，就自增，没有抢到锁的线程会阻塞等待时机被唤醒。如下图：根据我们理解抽象出来AQS的内部结构。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1897706/1611286004499-547b1ef4-8bec-48c4-b1ff-88ce2041e136.png#align=left&amp;amp;display=inline&amp;amp;height=424&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=424&amp;amp;originWidth=983&amp;amp;size=77571&amp;amp;status=done&amp;amp;style=none&amp;amp;width=983&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;**根据上面描述，大家看AQS不就是用Node封装线程，然后把线程按照先来后到（&lt;strong&gt;&lt;strong&gt;非公平锁除外&lt;/strong&gt;&lt;/strong&gt;）连接起来的双向链表嘛！关于非公平锁我之前写《排队打饭》案例中也通过简单例子描述过。有兴趣童鞋可以翻看下！&lt;br/&gt;**&lt;br/&gt;**&lt;/p&gt;
&lt;h2 id=&quot;共享锁&quot;&gt;共享锁&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;上面我们做核酸的过程是同步执行的，叫独占锁。那共享锁是什么意思呢？现在叫练孩子只有3岁，不能独立完成核酸检测，护士小姐姐感同身受，观察叫练子是排在叫练妻后面的，就让他们一起同时做核酸检测。这种同时做核酸的操作，相当于同时去获取医生资源，我们称之为共享锁。下面是我们测试代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author ：jiaolian
 * @date ：Created in 2021-01-21 19:54
 * @description：共享锁测试
 * @modified By：
 * 公众号:叫练
 */
public class SharedLockTest {

    private static ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    private static ReentrantReadWriteLock.ReadLock readLock = lock.readLock();

    //医院
    private static class Hospital {

        private String name;

        public Hospital(String name) {
            this.name = name;
        }

        //核酸检测排队测试
        public void checkUp() {
            try {
                readLock.lock();
                System.out.println(Thread.currentThread().getName()+&quot;正在做核酸检测&quot;);
                //核酸过程...难受...
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                readLock.unlock();
            }
        }
    }


    public static void main(String[] args) throws InterruptedException {
        Hospital hospital = new Hospital(&quot;南京市第一医院&quot;);
        Thread JLWife = new Thread(()-&amp;gt;hospital.checkUp(),&quot;叫练妻&quot;);
        JLWife.start();
        //睡眠100毫秒是让一家三口是有顺序的排队去检测
        Thread.sleep(100);
        Thread JLSon = new Thread(()-&amp;gt;hospital.checkUp(),&quot;叫练子&quot;);
        JLSon.start();
        /*Thread.sleep(100);
        Thread JL = new Thread(()-&amp;gt;hospital.checkUp(),&quot;叫练&quot;);
        JL.start();*/
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码我们用ReentrantReadWriteLock.ReadLock作为读锁，在主线程启动“叫练妻”和“叫练”两个线程，本来母子俩一共需要6秒才能完成的事情，现在只需要3秒就可以做完，共享锁好处是效率比较高。如下图，是AQS内部某一时刻Node节点状态。对比上图，&lt;strong&gt;Node的状态变为了共享状态，这些节点可以同时去共享医生资源&lt;/strong&gt;！&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1897706/1611298738189-d5f9e42b-820b-454a-8cce-40b29fccb9fe.png#align=left&amp;amp;display=inline&amp;amp;height=433&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=433&amp;amp;originWidth=882&amp;amp;size=67291&amp;amp;status=done&amp;amp;style=none&amp;amp;width=882&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;synchronized锁不响应中断&quot;&gt;synchronized锁不响应中断&lt;/h2&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @author ：jiaolian
 * @date ：Created in 2020-12-31 18:17
 * @description：sync不响应中断
 * @modified By：
 * 公众号:叫练
 */
public class SynchronizedInterrputedTest {

    private static class MyService {

        public synchronized void lockInterrupt() {
            try {
                System.out.println(Thread.currentThread().getName()+&quot; 获取到了锁&quot;);
                while (true) {
                   //System.out.println();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        MyService myService = new MyService();
        //先启动线程A，让线程A先拥有锁
        Thread threadA = new Thread(()-&amp;gt;{
            myService.lockInterrupt();
        });
        threadA.start();
        Thread.sleep(1000);
        //启动线程B，中断，synchronized不响应中断！
        Thread threadB = new Thread(()-&amp;gt;{
            myService.lockInterrupt();
        });
        threadB.start();
        Thread.sleep(1000);
        threadB.interrupt();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上述代码：先启动A线程，让线程A先拥有锁，睡眠1秒再启动线程B是让B线程处于可运行状态，隔1秒后再中断B线程。在控制台输出如下：A线程获取到了锁，等待2秒后控制台并没有立刻输出报错信息，程序一直未结束执行，说明&lt;strong&gt;synchronized锁不响应中断，需要B线程获取锁后才会输出线程中断报错信息！&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1897706/1611299701736-370a64d7-c079-4ed1-91ab-3b73eab0b64a.png#align=left&amp;amp;display=inline&amp;amp;height=220&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=220&amp;amp;originWidth=548&amp;amp;size=13708&amp;amp;status=done&amp;amp;style=none&amp;amp;width=548&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;aqs响应中断&quot;&gt;AQS响应中断&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;经常做比较知识才会融会贯通，在Lock提供lock和lockInterruptibly两种获取锁的方式，其中lock方法和&lt;strong&gt;synchronized&lt;/strong&gt;是不响应中断的，那下面我们看看&lt;strong&gt;lockInterruptibly&lt;/strong&gt;响应中断是什么意思。我们还是用核酸案例说明。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author ：jiaolian
 * @date ：Created in 2021-01-22 15:18
 * @description：AQS响应中断代码测试
 * @modified By：
 * 公众号:叫练
 */
public class AQSInterrputedTest {

    private static ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    private static ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();

    //医院
    private static class Hospital {

        private String name;

        public Hospital(String name) {
            this.name = name;
        }

        //核酸检测排队测试
        public void checkUp() {
            try {
                writeLock.lockInterruptibly();
                System.out.println(Thread.currentThread().getName()+&quot;正在做核酸检测&quot;);
                //核酸过程...难受...
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                writeLock.unlock();
            }
        }
    }


    public static void main(String[] args) throws InterruptedException {
        Hospital hospital = new Hospital(&quot;南京市第一医院&quot;);
        Thread JLWife = new Thread(()-&amp;gt;hospital.checkUp(),&quot;叫练妻&quot;);
        JLWife.start();
        //睡眠100毫秒是让一家三口是有顺序的排队去检测
        Thread.sleep(100);
        Thread JLSon = new Thread(()-&amp;gt;hospital.checkUp(),&quot;叫练子&quot;);
        JLSon.start();
        Thread.sleep(100);
        Thread JL = new Thread(()-&amp;gt;hospital.checkUp(),&quot;叫练&quot;);
        JL.start();
        //等待1秒，中断叫练线程
        System.out.println(&quot;护士小姐姐想和叫练私聊会!&quot;);
        Thread.sleep(1000);
        JL.interrupt();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码：叫练一家三口采用的是独占锁排队去做核酸，叫练线程等待一秒后，护士小姐姐想和叫练私聊会！莫非小姐姐会有啥想法，于是叫练立刻中断了这次的核酸检测，注意是&lt;strong&gt;立刻中断&lt;/strong&gt;。控制台打印结果如下：叫练妻线程和叫练子线程都做了核酸，但叫练却没有做成功！因为被护士小姐姐中断了，结果如下图所示。所以我们能得出结论，在aqs中锁是可以响应中断的。现在如果将上述代码中lockInterruptibly方法换成lock方法会发生什么情况呢，如果换成这种方式，小姐姐再来撩我，叫练要先成功获取锁，也就说叫练已经到医生旁边准备做核酸了，小姐姐突然说有事找叫练，&lt;strong&gt;最终导致叫练没有做核酸&lt;/strong&gt;，碰上这样的事，只能说小姐姐是存心的，小姐姐&lt;strong&gt;太坏&lt;/strong&gt;了。关于lock方法不响应中断的测试大家可以自己测试下。看看我是不是&lt;strong&gt;冤枉&lt;/strong&gt;护士小姐姐了。&lt;br/&gt;我们可以得出结论：在aqs中如果一个线程正在获取锁或者处于等待状态，另一个线程中断了该线程，响应中断的意思是该线程立刻中断，而不响应中断的意思是该线程需要获取锁后再中断。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1897706/1611302174719-33066e7c-c789-4fba-b539-c54a622dfdbb.png#align=left&amp;amp;display=inline&amp;amp;height=291&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=291&amp;amp;originWidth=944&amp;amp;size=53011&amp;amp;status=done&amp;amp;style=none&amp;amp;width=944&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1897706/1611302781019-8f417560-8249-4c17-8b31-4bbbece0f020.png#align=left&amp;amp;display=inline&amp;amp;height=473&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=473&amp;amp;originWidth=968&amp;amp;size=88503&amp;amp;status=done&amp;amp;style=none&amp;amp;width=968&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;条件队列&quot;&gt;条件队列&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;人生或许有那么些不如意。漫长的一个小时排队等待终于过去了，轮到我们准备做核酸了，你说&lt;strong&gt;气不气&lt;/strong&gt;，每次叫练妻出门都带身份证，可偏偏回家这次忘记了？我们用代码看看叫练一家三口在做核酸的过程中到底发生了啥事情？又是怎么处理的！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author ：jiaolian
 * @date ：Created in 2021-01-22 16:10
 * @description：条件队列测试
 * @modified By：
 * 公众号:叫练
 */
public class ConditionTest {

    private static ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    private static ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();

    //条件队列
    private static Condition condition = writeLock.newCondition();

    //医院
    private static class Hospital {

        private String name;

        public Hospital(String name) {
            this.name = name;
        }

        //核酸检测排队测试
        public void checkUp(boolean isIdCard) {
            try {
                writeLock.lock();
                validateIdCard(isIdCard);
                System.out.println(Thread.currentThread().getName()+&quot;正在做核酸检测&quot;);
                //核酸过程...难受...
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                writeLock.unlock();
                System.out.println(Thread.currentThread().getName()+&quot;核酸检测完成&quot;);
            }
        }

        //校验身份信息;
        private void validateIdCard(boolean isIdCard) {
            //如果没有身份信息，需要等待
            if (!isIdCard) {
                try {
                    System.out.println(Thread.currentThread().getName()+&quot;忘记带身份证了&quot;);
                    condition.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        //通知所有等待的人
        public void singleAll() {
            try {
                writeLock.lock();
                condition.signalAll();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                writeLock.unlock();
            }
        }

    }


    public static void main(String[] args) throws InterruptedException {
        Hospital hospital = new Hospital(&quot;南京市第一医院&quot;);
        Thread.currentThread().setName(&quot;护士小姐姐线程&quot;);
        Thread JLWife = new Thread(()-&amp;gt;{
            hospital.checkUp(false);
            },&quot;叫练妻&quot;);
        JLWife.start();
        //睡眠100毫秒是让一家三口是有顺序的排队去检测
        Thread.sleep(100);
        Thread JLSon = new Thread(()-&amp;gt;hospital.checkUp(true),&quot;叫练子&quot;);
        JLSon.start();
        Thread.sleep(100);
        Thread JL = new Thread(()-&amp;gt;{
            hospital.checkUp(true);
        },&quot;叫练&quot;);
        JL.start();
        //等待叫练线程执行完毕
        JL.join();
        hospital.singleAll();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码：一家人获取独占锁需要排队检测，叫练妻先进去准备核酸，护士小姐姐说先要刷身份证才能进去，叫练妻突然回想起来，出门走得急身份证忘记带了，这可咋办，需要重新排队吗？叫练妻很恐慌，护士小姐姐说，要不这样吧，你先赶紧回家拿，等叫练子，叫练先检测完，我就赶紧安排你进去在做核酸，那样你就不需要重新排队了，这就是上述这段代码的表达意思。我们看看执行结果如下图，和我们分析的结果一致，下图最后画红圈的地方叫练妻最后完成核酸检测。下面我们看看AQS内部经历的过程。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1897706/1611304655228-aad9da15-45d4-42e8-b683-f915a15a2173.png#align=left&amp;amp;display=inline&amp;amp;height=274&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=274&amp;amp;originWidth=593&amp;amp;size=21325&amp;amp;status=done&amp;amp;style=none&amp;amp;width=593&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如下图，当叫练妻先获取锁，发现身份证忘带调用&lt;strong&gt;await&lt;/strong&gt;方法会释放持有的锁，并把自己当做node节点放入条件队列的尾部，此时条件队列为空，所以条件队列中只有叫练妻一个线程在里面，接着护士小姐姐会将核酸医生这个资源释放分配给下一个等待者，也就是叫练子线程，同理，叫练子执行完毕释放锁之后会唤醒叫练线程，底层是用LockSupport.unpark来完成唤醒的的操作，相当于基础系列里的wait/notify/notifyAll等方法。当叫练线程执行完毕，后面没有线程了，护士小姐姐调用singleAll方法会见条件队列的叫练妻线程唤醒，并加入到AQS的尾部，等待执行。其中条件队列是一个单向链表，一个AQS可以通过newCondition()对应多个条件队列。这里我们就不单独用代码做测试了。&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/1897706/1611305244792-22389c84-15a8-4f1b-9cb4-39f978e92dad.png#align=left&amp;amp;display=inline&amp;amp;height=600&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=600&amp;amp;originWidth=753&amp;amp;size=60995&amp;amp;status=done&amp;amp;style=none&amp;amp;width=753&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;今天我们用代码+图片+故事的方式说明了AQS重要的几个概念，整理出来希望能对你有帮助，写的比不全，同时还有许多需要修正的地方，希望亲们加以指正和点评，年前这段时间会继续输出实现AQS高级锁，如：ReentrantLock，线程池这些概念等。最后喜欢的请点赞加关注哦。我是&lt;strong&gt;叫练【公众号】&lt;/strong&gt;，边叫边练。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：本故事是自己虚构出来的，仅供大家参考理解。希望大家过年都能顺利回家团聚！&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/gif/1897706/1611306713183-cc11c946-1455-4f12-a60e-6e84fa3d65be.gif#align=left&amp;amp;display=inline&amp;amp;height=128&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=tempImage1611306633088.gif&amp;amp;originHeight=128&amp;amp;originWidth=128&amp;amp;size=20544&amp;amp;status=done&amp;amp;style=none&amp;amp;width=128&quot; alt=&quot;tempImage1611306633088.gif&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Jan 2021 13:12:00 +0000</pubDate>
<dc:creator>叫练</dc:creator>
<og:description>春节越来越近了，疫情也越来越严重，但挡不住叫练携一家老小回老家（湖北）团聚的冲动。响应国家要求去我们做核酸检测了。 独占锁 早上叫练带着一家三口来到了南京市第一医院做核酸检测，护士小姐姐站在医院门口拦</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiaolian/p/14319024.html</dc:identifier>
</item>
</channel>
</rss>