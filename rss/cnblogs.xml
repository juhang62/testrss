<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.net webapi 接收保存图片到服务器，并居中剪裁压缩图片 - 野菊花</title>
<link>http://www.cnblogs.com/Jackyye/p/12510943.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackyye/p/12510943.html</guid>
<description>&lt;p&gt;*原创*每天解决一些c#小问题，在写微信小程序，或者一些手机软件接口，我们经常要用到上传图片到服务器，或者使用图床去保存我们的图片。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;154.13840045377&quot;&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https:////www.cnblogs.com/Jackyye/p/12510943.html&quot; class=&quot;uri&quot;&gt;https:////www.cnblogs.com/Jackyye/p/12510943.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每天解决一些c#小问题，在写微信小程序，或者一些手机软件接口，我们经常要用到上传图片到服务器，或者使用图床去保存我们的图片。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这次就简单明了的来梳理一下如何实现图片的接受和对接受到的图片进行一些处理。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;一实现图片的接收&quot;&gt;一、实现图片的接收&lt;/h3&gt;
&lt;p&gt;1.首先要明确现在大部分前端的传输图片的统一规范都是通过&lt;strong&gt;POST请求+form表单&lt;/strong&gt;提交文件的形式&lt;br/&gt;话不多说上代码，这里是上传一张图片的示例，我用的是时间戳命名&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        [HttpPost,Route(&quot;UpLoadImageFiles&quot;)]
        public string UpLoadImageFiles(string suffix)//suffix是后缀的意思，可以自己判断，也可以前端传输
        {

            var files = HttpContext.Current.Request.Files;//首先先确定请求里夹带的文件数量
            if (files.AllKeys.Any())//如果存在文件
            {
                using (HttpClient client = new HttpClient())
                {
                    HttpContextBase HttpContext = (HttpContextBase)Request.Properties[&quot;MS_HttpContext&quot;];

                    var text = HttpContext.Request.Files[0].InputStream;//获取到文件流

                    string path = HttpContext.Request.MapPath(&quot;~/&quot;);//获取你的根目录
                    string datetime = GetTimeStamp();
                    string strPath = path + &quot;File\\&quot; + datetime + suffix;//这里要注意的是先要建立File文件夹，不然会报错，也可以自己写一个检测文件夹，这里就先不赘述
                    StreamHelp.StreamToFile(text,strPath);//需要用到下一步的帮助类将其保存为文件

                    //------------------以下是剪裁和压缩图片代码不需要的可以略过
                    string imgPath = path + &quot;File\\img\\&quot; + datetime + suffix;
                    ImageHelp img = new ImageHelp(strPath);
                    img.GetReducedImage(0.8, imgPath);
                }
                return &quot;添加成功&quot;;
            }
            return &quot;无文件&quot;;
        }
        
        ///获取时间戳的方法
        private string GetTimeStamp()
        {
            TimeSpan ts = DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, 0);
            return Convert.ToInt64(ts.TotalMilliseconds).ToString();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.获取到文件流后，需要一个帮助类将其转化为文件保存起来，我把它封装了一下&lt;strong&gt;StreamHelp.cs&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public static class StreamHelp
    {
        /// &amp;lt;summary&amp;gt;
        /// 流转文件
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;stream&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;fileName&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public static void StreamToFile(Stream stream, string fileName)
        {
            // 把 Stream 转换成 byte[] 
            byte[] bytes = new byte[stream.Length];
            stream.Read(bytes, 0, bytes.Length);
            // 设置当前流的位置为流的开始 
            stream.Seek(0, SeekOrigin.Begin);
            // 把 byte[] 写入文件 

            FileStream fs = new FileStream(fileName, FileMode.Create);
            BinaryWriter bw = new BinaryWriter(fs);
            bw.Write(bytes);
            bw.Close();
            fs.Close();
        }

        /// &amp;lt;summary&amp;gt;
        /// 文件转流
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;fileName&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static Stream FileToStream(string fileName)

        {

            // 打开文件 
            FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);

            // 读取文件的 byte[] 
            byte[] bytes = new byte[fileStream.Length];
            fileStream.Read(bytes, 0, bytes.Length);
            fileStream.Close();

            // 把 byte[] 转换成 Stream 

            Stream stream = new MemoryStream(bytes);
            return stream;

        }

        /// &amp;lt;summary&amp;gt;
        /// 流转Bytes
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;stream&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static byte[] StreamToBytes(Stream stream)

        {

            byte[] bytes = new byte[stream.Length];
            stream.Read(bytes, 0, bytes.Length);

            // 设置当前流的位置为流的开始 

            stream.Seek(0, SeekOrigin.Begin);
            return bytes;

        }

        /// &amp;lt;summary&amp;gt;
        /// Bytes转流
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;bytes&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static Stream BytesToStream(byte[] bytes)
        {

            Stream stream = new MemoryStream(bytes);
            return stream;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.接收图片的步奏这样就已经完成了，图片会保存到你自定义的文件夹中，接下来就是压缩图片&lt;br/&gt;为了方便我将剪裁和压缩图片放在了同一个类中&lt;strong&gt;ImageHelp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先是裁剪，我需要的是居中裁剪，也就是无论什么形状的图片传过来，都会裁剪成正方形&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;ImageTailor(string path)&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;剪裁使用的方法就是重画，使用Graphics.DrawImage()，新建一个正方形画布&lt;/p&gt;
&lt;p&gt;首先先做长宽对比取最小的的边，然后把长的边剪裁，(bmp.Width - bmp.Height) / 2&lt;/p&gt;
&lt;p&gt;这里通过改变原图的起始点进行检查，不用改变原图的长宽，防止图片形变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;GetReducedImage(double Percent, string targetFilePath)&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;然后通过百分比压缩图片，推荐80%就足够了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class ImageHelp
    {
        public Image ResourceImage;
        private int ImageWidth;
        private int ImageHeight;
        public string ErrMessage;

        /// &amp;lt;summary&amp;gt;   
        /// 类的构造函数   
        /// &amp;lt;/summary&amp;gt;   
        /// &amp;lt;param name=&quot;ImageFileName&quot;&amp;gt;图片文件的全路径名称&amp;lt;/param&amp;gt;   
        public ImageHelp(string ImageFileName)
        {
            var BeImage = Image.FromFile(ImageFileName);
            ResourceImage = ImageTailor(ImageFileName);
            ErrMessage = &quot;&quot;;
        }

        public bool ThumbnailCallback()
        {
            return false;
        }


        /// &amp;lt;summary&amp;gt;
        /// 裁剪居中
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;path&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public Image ImageTailor(string path)
        {
            Bitmap bmp = new Bitmap(path);
            var width = 0;
            var height = 0;
            var x = 0;
            var y = 0;
            if (bmp.Width &amp;gt; bmp.Height)
            {
                width = bmp.Height;
                height = bmp.Height;
                y = 0;
                x = (bmp.Width - bmp.Height) / 2;
            }
            else
            {
                width = bmp.Width;
                height = bmp.Width;
                y = (bmp.Height - bmp.Width) / 2;
                x = 0;
            }

            Bitmap newbm = new Bitmap(width, height);
            Graphics g = Graphics.FromImage(newbm);
            g.InterpolationMode = InterpolationMode.HighQualityBicubic;
            g.SmoothingMode = SmoothingMode.HighQuality;
            g.CompositingQuality = CompositingQuality.HighQuality;
            //前Rectangle代表画布大小，后Rectangle代表裁剪后右边留下的区域
            g.DrawImage(bmp, new Rectangle(0, 0, width, height), new Rectangle(x, y, width, height), GraphicsUnit.Pixel);
            g.Dispose();
            return newbm;
        }


        /// &amp;lt;summary&amp;gt;   
        /// 生成缩略图重载方法1，返回缩略图的Image对象   
        /// &amp;lt;/summary&amp;gt;   
        /// &amp;lt;param name=&quot;Width&quot;&amp;gt;缩略图的宽度&amp;lt;/param&amp;gt;   
        /// &amp;lt;param name=&quot;Height&quot;&amp;gt;缩略图的高度&amp;lt;/param&amp;gt;   
        /// &amp;lt;returns&amp;gt;缩略图的Image对象&amp;lt;/returns&amp;gt;   
        public Image GetReducedImage(int Width, int Height)
        {
            try
            {
                Image ReducedImage;

                Image.GetThumbnailImageAbort callb = new Image.GetThumbnailImageAbort(ThumbnailCallback);

                ReducedImage = ResourceImage.GetThumbnailImage(Width, Height, callb, IntPtr.Zero);

                return ReducedImage;
            }
            catch (Exception e)
            {
                ErrMessage = e.Message;
                return null;
            }
        }

        /// &amp;lt;summary&amp;gt;   
        /// 生成缩略图重载方法2，将缩略图文件保存到指定的路径   
        /// &amp;lt;/summary&amp;gt;   
        /// &amp;lt;param name=&quot;Width&quot;&amp;gt;缩略图的宽度&amp;lt;/param&amp;gt;   
        /// &amp;lt;param name=&quot;Height&quot;&amp;gt;缩略图的高度&amp;lt;/param&amp;gt;   
        /// &amp;lt;param name=&quot;targetFilePath&quot;&amp;gt;缩略图保存的全文件名，(带路径)，参数格式：D:Images ilename.jpg&amp;lt;/param&amp;gt;   
        /// &amp;lt;returns&amp;gt;成功返回true，否则返回false&amp;lt;/returns&amp;gt;   
        public bool GetReducedImage(int Width, int Height, string targetFilePath)
        {
            try
            {
                Image ReducedImage;

                Image.GetThumbnailImageAbort callb = new Image.GetThumbnailImageAbort(ThumbnailCallback);

                ReducedImage = ResourceImage.GetThumbnailImage(Width, Height, callb, IntPtr.Zero);
                ReducedImage.Save(@targetFilePath, ImageFormat.Jpeg);

                ReducedImage.Dispose();

                return true;
            }
            catch (Exception e)
            {
                ErrMessage = e.Message;
                return false;
            }
        }

        /// &amp;lt;summary&amp;gt;   
        /// 生成缩略图重载方法3，返回缩略图的Image对象   
        /// &amp;lt;/summary&amp;gt;   
        /// &amp;lt;param name=&quot;Percent&quot;&amp;gt;缩略图的宽度百分比 如：需要百分之80，就填0.8&amp;lt;/param&amp;gt;     
        /// &amp;lt;returns&amp;gt;缩略图的Image对象&amp;lt;/returns&amp;gt;   
        public Image GetReducedImage(double Percent)
        {
            try
            {
                Image ReducedImage;

                Image.GetThumbnailImageAbort callb = new Image.GetThumbnailImageAbort(ThumbnailCallback);

                ImageWidth = Convert.ToInt32(ResourceImage.Width * Percent);
                ImageHeight = Convert.ToInt32(ResourceImage.Height * Percent);

                ReducedImage = ResourceImage.GetThumbnailImage(ImageWidth, ImageHeight, callb, IntPtr.Zero);

                return ReducedImage;
            }
            catch (Exception e)
            {
                ErrMessage = e.Message;
                return null;
            }
        }


        /// &amp;lt;summary&amp;gt;   
        /// 生成缩略图重载方法4，返回缩略图的Image对象   
        /// &amp;lt;/summary&amp;gt;   
        /// &amp;lt;param name=&quot;Percent&quot;&amp;gt;缩略图的宽度百分比 如：需要百分之80，就填0.8&amp;lt;/param&amp;gt;     
        /// &amp;lt;param name=&quot;targetFilePath&quot;&amp;gt;缩略图保存的全文件名，(带路径)，参数格式：D:Images ilename.jpg&amp;lt;/param&amp;gt;   
        /// &amp;lt;returns&amp;gt;成功返回true,否则返回false&amp;lt;/returns&amp;gt;   
        public bool GetReducedImage(double Percent, string targetFilePath)
        {
            try
            {
                Image ReducedImage;

                Image.GetThumbnailImageAbort callb = new Image.GetThumbnailImageAbort(ThumbnailCallback);

                ImageWidth = Convert.ToInt32(ResourceImage.Width * Percent);
                ImageHeight = Convert.ToInt32(ResourceImage.Height * Percent);

                ReducedImage = ResourceImage.GetThumbnailImage(ImageWidth, ImageHeight, callb, IntPtr.Zero);

                ReducedImage.Save(@targetFilePath, ImageFormat.Jpeg);

                ReducedImage.Dispose();

                return true;
            }
            catch (Exception e)
            {
                ErrMessage = e.Message;
                return false;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Wed, 18 Mar 2020 00:34:00 +0000</pubDate>
<dc:creator>野菊花</dc:creator>
<og:description>*原创*每天解决一些c#小问题，在写微信小程序，或者一些手机软件接口，我们经常要用到上传图片到服务器，或者使用图床去保存我们的图片。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jackyye/p/12510943.html</dc:identifier>
</item>
<item>
<title>ASP.NET 开源导入导出库Magicodes.IE 完成Excel图片导入导出 - HueiFeng</title>
<link>http://www.cnblogs.com/yyfh/p/12515229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyfh/p/12515229.html</guid>
<description>&lt;p&gt;为了更好的根据实际功能来迭代，从2.2的里程碑规划开始，我们将结合社区的建议和意见来进行迭代，您可以点此链接来提交您的意见和建议：&lt;br/&gt;&lt;a href=&quot;https://github.com/dotnetcore/Magicodes.IE/issues/46&quot; class=&quot;uri&quot;&gt;https://github.com/dotnetcore/Magicodes.IE/issues/46&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/17d06429-eed0-416e-948f-db3a714627da.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;本章教程主要说明如何使用Magicodes.IE.Excel进行图片的导入导出。&lt;/p&gt;
&lt;h2 id=&quot;要点&quot;&gt;要点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;配置DTO进行Excel图片导出&lt;/li&gt;
&lt;li&gt;配置DTO进行Excel图片导入&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;图片导入导出特性说明&quot;&gt;图片导入导出特性说明&lt;/h2&gt;
&lt;h3 id=&quot;exportimagefieldattribute&quot;&gt;ExportImageFieldAttribute&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Height&lt;/strong&gt;： 高度(默认15)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Width&lt;/strong&gt;：宽度(默认50)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alt&lt;/strong&gt;：图片不存在时替换文本&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;importimagefieldattribute&quot;&gt;ImportImageFieldAttribute&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ImageDirectory&lt;/strong&gt;： 图片存储路径（默认存储到临时目录）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ImportImageTo&lt;/strong&gt;：图片导出方式（默认Base64），支持的方式如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    ///     图片导入类型
    /// &amp;lt;/summary&amp;gt;
    public enum ImportImageTo
    {
        /// &amp;lt;summary&amp;gt;
        ///     导入到临时目录
        /// &amp;lt;/summary&amp;gt;
        TempFolder,

        /// &amp;lt;summary&amp;gt;
        ///     导入为base64格式
        /// &amp;lt;/summary&amp;gt;
        Base64
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;主要步骤&quot;&gt;主要步骤&lt;/h2&gt;
&lt;h3 id=&quot;安装包magicodes.ie.excel&quot;&gt;1.安装包Magicodes.IE.Excel&lt;/h3&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;Install-Package Magicodes.IE.Excel&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用magicodes.ie.excel导出图片到excel&quot;&gt;2.使用Magicodes.IE.Excel导出图片到Excel&lt;/h3&gt;
&lt;p&gt;如下述示例代码所示，我们需要在图片属性上添加&lt;strong&gt;ExportImageFieldAttribute&lt;/strong&gt;特性，使用特性的“Width”属性指定图片宽度，“Height”属性指定图片高度，“Alt”属性指定替换文本，也就是当图片不存在时则会显示此文本：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;   [ExcelExporter(Name = &quot;测试&quot;)]
    public class ExportTestDataWithPicture
    {
        [ExporterHeader(DisplayName = &quot;加粗文本&quot;, IsBold = true)]
        public string Text { get; set; }

        [ExporterHeader(DisplayName = &quot;普通文本&quot;)] public string Text2 { get; set; }
        [ExporterHeader(DisplayName = &quot;忽略&quot;, IsIgnore = true)]
        public string Text3 { get; set; }

        [ExportImageField(Width = 20, Height = 120)]
        [ExporterHeader(DisplayName = &quot;图1&quot;)]
        public string Img1 { get; set; }
        [ExporterHeader(DisplayName = &quot;数值&quot;, Format = &quot;#,##0&quot;)]
        public decimal Number { get; set; }
        [ExporterHeader(DisplayName = &quot;名称&quot;, IsAutoFit = true)]
        public string Name { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 时间测试
        /// &amp;lt;/summary&amp;gt;
        [ExporterHeader(DisplayName = &quot;日期1&quot;, Format = &quot;yyyy-MM-dd&quot;)]
        public DateTime Time1 { get; set; }

        [ExportImageField(Width = 50, Height = 120, Alt = &quot;404&quot;)]
        [ExporterHeader(DisplayName = &quot;图&quot;, IsAutoFit = false)]
        public string Img { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得注意的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ExportImageFieldAttribute特性是必须的&lt;/li&gt;
&lt;li&gt;图片属性类型必须为string类型，支持本地图片和远程图片地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，我们就可以使用API来执行导出了。其实除了Dto的不同，导出API还是一个，如下述代码所示：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        public async Task ExportPicture_Test()
        {
            IExporter exporter = new ExcelExporter();
            var url = Path.Combine(&quot;TestFiles&quot;, &quot;ExporterTest.png&quot;);
            for (var i = 0; i &amp;lt; data.Count; i++)
            {
                var item = data[i];
                item.Img1 = url;
                if (i == 4)
                    item.Img = null;
                else
                    item.Img = &quot;https://docs.microsoft.com/en-us/media/microsoft-logo-dark.png&quot;;
            }
            var result = await exporter.Export(filePath, data);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上述代码所示，目前图片导出可以设置为远程图片地址，以及本地图片地址，并且也可以设置为null（null将会被替代文本所代替）。效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/ea124562-cf98-4d5e-8f53-35855439198b.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用magicodes.ie.excel导入图片&quot;&gt;3.使用Magicodes.IE.Excel导入图片&lt;/h3&gt;
&lt;p&gt;Magicodes.IE.Excel支持从Excel导入图片，仅需使用特性“ImportImageField”。其支持两种导入方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;导入到临时目录&lt;/li&gt;
&lt;li&gt;导入为Base64&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;仅需设置ImportImageTo属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ImportImageTo枚举&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是，同上文一样，图片属性字段类型也仅支持string类型。&lt;/p&gt;
&lt;h4 id=&quot;准备待导入的包含图片的excel&quot;&gt;准备待导入的包含图片的Excel&lt;/h4&gt;
&lt;p&gt;在开始之前，我们需准备好导入的Excel，本示例中的模板如下图所示：&lt;/p&gt;
&lt;h4 id=&quot;导入到临时目录&quot;&gt;导入到临时目录&lt;/h4&gt;
&lt;p&gt;Dto模型如下所示：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
    public class ImportPictureDto
    {
        [ImporterHeader(Name = &quot;加粗文本&quot;)]
        public string Text { get; set; }
        [ImporterHeader(Name = &quot;普通文本&quot;)]
        public string Text2 { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 将图片写入到临时目录
        /// &amp;lt;/summary&amp;gt;
        [ImportImageField(ImportImageTo = ImportImageTo.TempFolder)]
        [ImporterHeader(Name = &quot;图1&quot;)]
        public string Img1 { get; set; }
        [ImporterHeader(Name = &quot;数值&quot;)]
        public string Number { get; set; }
        [ImporterHeader(Name = &quot;名称&quot;)]
        public string Name { get; set; }
        [ImporterHeader(Name = &quot;日期&quot;)]
        public DateTime Time { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 将图片写入到临时目录
        /// &amp;lt;/summary&amp;gt;
        [ImportImageField(ImportImageTo = ImportImageTo.TempFolder)]
        [ImporterHeader(Name = &quot;图&quot;)]
        public string Img { get; set; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导入还是那个导入，只是Dto设置变了：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        public async Task ImportPicture_Test()
        {
            var filePath = Path.Combine(Directory.GetCurrentDirectory(), &quot;TestFiles&quot;, &quot;Import&quot;, &quot;图片导入模板.xlsx&quot;);
            var import = await Importer.Import&amp;lt;ImportPictureDto&amp;gt;(filePath);
            if (import.Exception != null) _testOutputHelper.WriteLine(import.Exception.ToString());

            if (import.RowErrors.Count &amp;gt; 0) _testOutputHelper.WriteLine(JsonConvert.SerializeObject(import.RowErrors));
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示，Excel中的图片就会导入到临时目录。值得注意的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;图片导入到临时目录之后，如果导入结果符合业务需要，请立即将图片移动到正式存储位置，比如网站目录、云存储等；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;图片导入也支持指定位置，不过不推荐。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/6a4022a1-bc1b-40b6-919b-556dd411d2f8.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;将图片导入为base64&quot;&gt;将图片导入为base64&lt;/h4&gt;
&lt;p&gt;将图片导入为base64仅需设置“ImportImageTo”属性值为“ImportImageTo.Base64”即可：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
    public class ImportPictureBase64Dto
    {
        [ImporterHeader(Name = &quot;加粗文本&quot;)]
        public string Text { get; set; }
        [ImporterHeader(Name = &quot;普通文本&quot;)]
        public string Text2 { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 将图片导入为base64（默认为base64）
        /// &amp;lt;/summary&amp;gt;
        [ImportImageField(ImportImageTo = ImportImageTo.Base64)]
        [ImporterHeader(Name = &quot;图1&quot;)]
        public string Img1 { get; set; }

        [ImporterHeader(Name = &quot;数值&quot;)]
        public string Number { get; set; }
        [ImporterHeader(Name = &quot;名称&quot;)]
        public string Name { get; set; }
        [ImporterHeader(Name = &quot;日期&quot;)]
        public DateTime Time { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 将图片导入到临时目录
        /// &amp;lt;/summary&amp;gt;
        [ImportImageField(ImportImageTo = ImportImageTo.TempFolder)]
        [ImporterHeader(Name = &quot;图&quot;)]
        public string Img { get; set; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导入代码同上：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
public async Task ImportPictureBase64_Test()
        {
            var filePath = Path.Combine(Directory.GetCurrentDirectory(), &quot;TestFiles&quot;, &quot;Import&quot;, &quot;图片导入模板.xlsx&quot;);
            var import = await Importer.Import&amp;lt;ImportPictureBase64Dto&amp;gt;(filePath);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示，我们就很方便的得到了图片的base64编码的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/dffc122b-8996-4844-b647-83c53016a19a.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnetcore/Magicodes.IE&quot; class=&quot;uri&quot;&gt;https://github.com/dotnetcore/Magicodes.IE&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Mar 2020 00:14:00 +0000</pubDate>
<dc:creator>HueiFeng</dc:creator>
<og:description>Magicodes.IE Excel图片导入导出 为了更好的根据实际功能来迭代，从2.2的里程碑规划开始，我们将结合社区的建议和意见来进行迭代，您可以点此链接来提交您的意见和建议： https://g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yyfh/p/12515229.html</dc:identifier>
</item>
<item>
<title>每天都在用 Map，这些核心技术你知道吗？ - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/12515199.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/12515199.html</guid>
<description>&lt;p&gt;本篇文章站在多线程并发安全角度，带你了解多线程并发使用 &lt;code&gt;HashMap&lt;/code&gt; 将会引发的问题，深入学习 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; ，带你彻底掌握这些核心技术。&lt;/p&gt;
&lt;p&gt;全文摘要：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;HashMap&lt;/code&gt; 核心技术&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 核心技术&lt;/li&gt;
&lt;li&gt;分段锁实战应用&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;博文地址：https://sourl.cn/r3RVY8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;hashmap&quot;&gt;HashMap&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; 是我们经常会用到的集合类，JDK 1.7 之前底层使用了数组加链表的组合结构，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073655404-1946367811.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新添加的元素通过取模的方式，定位 &lt;code&gt;Table&lt;/code&gt; 数组位置，然后将元素加入链表头部，这样下次提取时就可以快速被访问到。&lt;/p&gt;
&lt;p&gt;访问数据时，也是通过取模的方式，定位数组中的位置，然后再遍历链表，依次比较，获取相应的元素。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;HasMap&lt;/code&gt; 中元素过多时，可能导致某个位置上链表很长。原本 &lt;strong&gt;O(1)&lt;/strong&gt; 查找性能，可能就退化成 &lt;strong&gt;O(N)&lt;/strong&gt;,严重降低查找效率。&lt;/p&gt;
&lt;p&gt;为了避免这种情况，当 &lt;code&gt;HasMap&lt;/code&gt; 元素数量满足以下条件时，将会自动扩容,重新分配元素。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// size:HashMap 中实际元素数量 
//capacity：HashMap 容量，即 Table 数组长度，默认为：16 
//loadFactor：负载因子，默认为：0.75
size&amp;gt;=capacity*loadFactor&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;HasMap&lt;/code&gt; 将会把容量扩充为原来的两倍，然后将原数组元素迁移至新数组。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;
    for (Entry&amp;lt;K,V&amp;gt; e : table) {
        while(null != e) {
            Entry&amp;lt;K,V&amp;gt; next = e.next;
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            // 以下代码导致死链的产生
            e.next = newTable[i];
            // 插入到链表头结点，
            newTable[i] = e;
            e = next;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;旧数组元素迁移到新数组时，依旧采用『&lt;strong&gt;头插入法&lt;/strong&gt;』，这样将会导致新链表元素的逆序排序。&lt;/p&gt;
&lt;p&gt;多线程并发扩容的情况下，链表可能形成&lt;strong&gt;死链（环形链表）&lt;/strong&gt;。一旦有任何查找元素的动作，线程将会陷入死循环,从而引发 &lt;strong&gt;CPU&lt;/strong&gt; 使用率飙升。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073655753-1582437419.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网上详细分析死链形成的过程比较多，这里就不再详细解释，大家感兴趣可以阅读以下&lt;strong&gt;@陈皓&lt;/strong&gt;的文章。&lt;/p&gt;
&lt;p&gt;文章地址：&lt;strong&gt;https://coolshell.cn/articles/9606.html&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;jdk1.8-改进方案&quot;&gt;JDK1.8 改进方案&lt;/h3&gt;
&lt;p&gt;JDK1.8 &lt;code&gt;HashMap&lt;/code&gt; 底层结构进行彻底重构，使用数组加链表/红黑树方式这种组合结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073655909-1824520601.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新元素依旧通过取模方式获取 &lt;code&gt;Table&lt;/code&gt; 数组位置，然后再将元素加入链表&lt;strong&gt;尾部&lt;/strong&gt;。一旦链表元素数量超过 8 之后，自动转为&lt;strong&gt;红黑树&lt;/strong&gt;，进一步提高了查找效率。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;面试题：为什么这里使用红黑树？而不是其他二叉树呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于 JDK1.8 链表采用『&lt;strong&gt;尾插入&lt;/strong&gt;』法，从而避免并发扩容情况下链表形成死链的可能。&lt;/p&gt;
&lt;p&gt;那么 &lt;code&gt;HashMap&lt;/code&gt; 在 JDK1.8 版本就是并发安全的吗？&lt;/p&gt;
&lt;p&gt;其实并没有，多线程并发的情况，&lt;code&gt;HashMap&lt;/code&gt; 可能导致丢失数据。&lt;/p&gt;
&lt;p&gt;下面是一段 JDK1.8 测试代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073656092-1496439112.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在我的电脑上输出如下，数据发生了丢失：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073656268-1193847388.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从源码出发，并发过程数据丢失的原因有以下几点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并发赋值时被覆盖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073656454-1536472687.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并发的情况下，一个线程的赋值可能被另一个线程覆盖，这就导致对象的丢失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;size 计算问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073656593-1982234729.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每次元素增加完成之后，&lt;code&gt;size&lt;/code&gt; 将会加 1。这里采用 &lt;code&gt;++i&lt;/code&gt;方法，天然的并发不安全。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;对象丢失的问题原因可能还有很多，这里只是列举两个比较的明显的问题。&lt;/p&gt;
&lt;p&gt;当然 JDK1.7 中也是存在数据丢失的问题，问题原因也比较相似。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一旦发生&lt;strong&gt;死链&lt;/strong&gt;的问题，机器 &lt;strong&gt;CPU&lt;/strong&gt; 飙升，通过系统监控，我们可以很容易发现。&lt;/p&gt;
&lt;p&gt;但是数据丢失的问题就不容易被发现。因为数据丢失环节往往非常长，往往需要系统运行一段时间才可能出现，而且这种情况下又不会形成脏数据。只有出现一些诡异的情况，我们才可能去排查，而且这种问题排查起来也比较困难。&lt;/p&gt;
&lt;h2 id=&quot;synchronizedmap&quot;&gt;SynchronizedMap&lt;/h2&gt;
&lt;p&gt;对于并发的情况，我们可以使用 JDK 提供 &lt;code&gt;SynchronizedMap&lt;/code&gt; 保证安全。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SynchronizedMap&lt;/code&gt; 是一个内部类，只能通过以下方式创建实例。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Map m = Collections.synchronizedMap(new HashMap(...));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SynchronizedMap&lt;/code&gt; 源码如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073656721-916126705.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个方法内将会使用 &lt;code&gt;synchronized&lt;/code&gt; 关键字加锁，从而保证并发安全。&lt;/p&gt;
&lt;p&gt;由于多线程共享同一把锁，导致同一时间只允许一个线程读写操作，其他线程必须等待，极大降低的性能。&lt;/p&gt;
&lt;p&gt;并且大多数业务场景都是读多写少，多线程读操作本身并不冲突，&lt;code&gt;SynchronizedMap&lt;/code&gt; 极大的限制读的性能。&lt;/p&gt;
&lt;p&gt;所以多线程并发场景我们很少使用 &lt;code&gt;SynchronizedMap&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;concurrenthashmap&quot;&gt;ConcurrentHashMap&lt;/h2&gt;
&lt;p&gt;既然多线程共享一把锁，导致性能下降。那么设想一下我们是不是多搞几把锁，分流线程，减少锁冲突，提高并发度。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 正是使用这种方法，不但保证并发过程数据安全，又保证一定的效率。&lt;/p&gt;
&lt;h3 id=&quot;jdk1.7&quot;&gt;JDK1.7&lt;/h3&gt;
&lt;p&gt;JDK1.7 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 数据结构如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073656893-708691654.jpg&quot; alt=&quot;ConcurrentHashMap-1.7&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Segament&lt;/code&gt; 是一个&lt;code&gt;ConcurrentHashMap&lt;/code&gt;内部类，底层结构与 &lt;code&gt;HashMap&lt;/code&gt; 一致。另外&lt;code&gt;Segament&lt;/code&gt; 继承自 &lt;code&gt;ReentrantLock&lt;/code&gt;，类图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073657040-700530078.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当新元素加入 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 时，首先根据 key hash 值找到相应的 &lt;code&gt;Segament&lt;/code&gt;。接着直接对 &lt;code&gt;Segament&lt;/code&gt; 上锁，若获取成功，后续操作步骤如同 &lt;code&gt;HashMap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;由于锁的存在，&lt;code&gt;Segament&lt;/code&gt; 内部操作都是并发安全，同时由于其他 &lt;code&gt;Segament&lt;/code&gt; 未被占用，因此可以支持 &lt;strong&gt;concurrencyLevel&lt;/strong&gt; 个线程安全的并发读写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;size 统计问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 引入分段锁解决多线程并发的问题，但是同时引入新的复杂度，导致计算 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 元素数量将会变得复杂。&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 元素实际分布在 &lt;code&gt;Segament&lt;/code&gt; 中，为了统计实际数量，只能遍历 &lt;code&gt;Segament&lt;/code&gt;数组求和。&lt;/p&gt;
&lt;p&gt;为了数据的准确性，这个过程过我们需要锁住所有的 &lt;code&gt;Segament&lt;/code&gt;，计算结束之后，再依次解锁。不过这样做，将会导致写操作被阻塞，一定程度降低 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;性能。&lt;/p&gt;
&lt;p&gt;所以这里对 &lt;code&gt;ConcurrentHashMap#size&lt;/code&gt; 统计方法进行一定的优化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073657173-1146939298.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Segment&lt;/code&gt; 每次被修改（写入，删除）,都会对 &lt;code&gt;modCount&lt;/code&gt;（更新次数）加 1。只要相邻两次计算获取所有的 &lt;code&gt;Segment&lt;/code&gt; &lt;code&gt;modCount&lt;/code&gt; 总和一致，则代表两次计算过程并无写入或删除，可以直接返回统计数量。&lt;/p&gt;
&lt;p&gt;如果三次计算结果都不一致，那没办法只能对所有 &lt;code&gt;Segment&lt;/code&gt; 加锁，重新计算结果。&lt;/p&gt;
&lt;p&gt;这里需要注意的是，这里求得 &lt;strong&gt;size&lt;/strong&gt; 数量不能做到 100% 准确。这是因为最后依次对 &lt;code&gt;Segment&lt;/code&gt; 解锁后，可能会有其他线程进入写入操作。这样就导致返回时的数量与实际数不一致。&lt;/p&gt;
&lt;p&gt;不过这也能被接受，总不能因为为了统计元素停止所有元素的写入操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;性能问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想象一种极端情况的，所有写入都落在同一个 &lt;code&gt;Segment&lt;/code&gt;中，这就导致&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 退化成 &lt;code&gt;SynchronizedMap&lt;/code&gt;，共同抢一把锁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073657298-391064127.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jdk1.8-改进方案-1&quot;&gt;JDK1.8 改进方案&lt;/h3&gt;
&lt;p&gt;JDK1.8 之后，&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 取消了分段锁的设计，进一步减锁冲突的发生。另外也引入红黑树的结构，进一步提高查找效率。&lt;/p&gt;
&lt;p&gt;数据结构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073657415-1154002796.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Table&lt;/code&gt; 数组的中每一个 &lt;code&gt;Node&lt;/code&gt; 我们都可以看做一把锁，这就避免了 &lt;code&gt;Segament&lt;/code&gt; 退化问题。&lt;/p&gt;
&lt;p&gt;另外一旦 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 扩容， &lt;code&gt;Table&lt;/code&gt; 数组元素变多，锁的数量也会变多，并发度也会提高。&lt;/p&gt;
&lt;p&gt;写入元素源码比较复杂，这里可以参考下面流程图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073657534-1337631469.jpg&quot; alt=&quot;concurrentHashMap-1.8 加入元素&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总的来说，JDK1.8 使用 CAS 方法加 &lt;code&gt;synchronized&lt;/code&gt; 方式，保证并发安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;size 方法优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JDK1.8 &lt;code&gt;ConcurrentHashMap#size&lt;/code&gt; 统计方法还是比较简单的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073657674-753021723.png&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073657862-1849832399.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个方法我们需要知道两个重要变量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;baseCount&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CounterCell[] counterCells&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;baseCount&lt;/code&gt; 记录元素数量的，每次元素元素变更之后，将会使用 &lt;code&gt;CAS&lt;/code&gt;方式更新该值。&lt;/p&gt;
&lt;p&gt;如果多个线程并发增加新元素，&lt;code&gt;baseCount&lt;/code&gt; 更新冲突，将会启用 &lt;code&gt;CounterCell&lt;/code&gt;，通过使用 &lt;code&gt;CAS&lt;/code&gt; 方式将总数更新到 &lt;code&gt;counterCells&lt;/code&gt; 数组对应的位置，减少竞争。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;CAS&lt;/code&gt; 更新 &lt;code&gt;counterCells&lt;/code&gt; 数组某个位置出现多次失败，这表明多个线程在使用这个位置。此时将会通过扩容 &lt;code&gt;counterCells&lt;/code&gt;方式，再次减少冲突。&lt;/p&gt;
&lt;p&gt;通过上面的努力，统计元素总数就变得非常简单，只要计算 &lt;code&gt;baseCount&lt;/code&gt; 与 &lt;code&gt;counterCells&lt;/code&gt;总和，整个过程都不需要加锁。&lt;/p&gt;
&lt;p&gt;仔细回味一下，&lt;code&gt;counterCells&lt;/code&gt; 也是通过类似分段锁思想，减少多线程竞争。&lt;/p&gt;
&lt;h2 id=&quot;分段锁实战应用&quot;&gt;分段锁实战应用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 通过使用分段锁的设计方式，降低锁的粒度，提高并发度。我们可以借鉴这种设计，解决某些&lt;strong&gt;热点数据&lt;/strong&gt;更新问题。&lt;/p&gt;
&lt;p&gt;举个例子，假如现在我们有一个支付系统，用户每次支付成功，商家的账户余额就会相应的增加。&lt;/p&gt;
&lt;p&gt;当大促的时候，非常多用户同时支付，同一个商家账户余额会被并发更新。&lt;/p&gt;
&lt;p&gt;数据库层面为了保证数据安全，每次更新时将会使用行锁。同时并发更新的情况，只有一个线程才能获取锁，更新数据，其他线程只能等待锁释放。这就很有可能导致其他线程余额更新操作耗时过长，甚至事务超时，余额更新失败的。&lt;/p&gt;
&lt;p&gt;这就是一个典型的&lt;strong&gt;热点数据&lt;/strong&gt;更新问题。&lt;/p&gt;
&lt;p&gt;这个问题实际原因是因为多线程并发抢夺&lt;strong&gt;行锁&lt;/strong&gt;导致，那如果有多把行锁，是不是就可以降低锁冲突了那？&lt;/p&gt;
&lt;p&gt;没错，这里我们借鉴 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 分段锁的设计，在商家的账户的下创建多个&lt;strong&gt;影子账户&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然后每次更新余额，随机选择某个&lt;strong&gt;影子账户&lt;/strong&gt;进行相应的更新。&lt;/p&gt;
&lt;p&gt;理论上&lt;strong&gt;影子账户&lt;/strong&gt;可以创建无数个，这就代表我们可以无限提高并发的能力。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里感谢&lt;strong&gt;@why&lt;/strong&gt; 神提出影子账户的概念，大家感兴趣可以搜索关注，公众号: why技术&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073658040-1561298103.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;架构设计中引入新的方案，就代表会引入新的复杂度，我们一定要这些问题考虑清楚，综合权衡设计。&lt;/p&gt;
&lt;p&gt;引入影子账户虽然解决热点数据的问题，但是商户总余额统计就变得很麻烦，我们必须统计所有子账户的余额。&lt;/p&gt;
&lt;p&gt;另外实际的业务场景，商家余额不只是会增加，还有可能的进行相应的扣减。这就有可能产生商户总余额是足够的，但是选中的影子账户的余额却不足。&lt;/p&gt;
&lt;p&gt;这怎么办？这留给大家思考了。不知道各位读者有没有碰到这种类似的问题，欢迎留言讨论。&lt;/p&gt;
&lt;p&gt;大家感兴趣的话，后面的文章我们可以详细聊聊&lt;strong&gt;热点账户&lt;/strong&gt;的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; 在多线程并发的过程中存在死链与丢失数据的可能，不适合用于多线程并发使用的场景的,我们可以在方法的局部变量中使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SynchronizedMap&lt;/code&gt; 虽然线程安全，但是由于锁粒度太大，导致性能太低，所以也不太适合在多线程使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 由于使用多把锁，充分降低多线程并发竞争的概率，提高了并发度，非常适合在多线程中使用。&lt;/p&gt;
&lt;p&gt;最后小黑哥再提一点，不要一提到多线程环境，就直接使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;。如果仅仅使用 &lt;code&gt;Map&lt;/code&gt; 当做全局变量，而这个变量初始加载之后，从此数据不再变动的场景下。建议使用不变集合类 &lt;code&gt;Collections#unmodifiableMap&lt;/code&gt;,或者使用 Guava 的 &lt;code&gt;ImmutableMap&lt;/code&gt;。不变集合的好处在于，可以有效防止其他线程偷偷修改，从而引发一些业务问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt; 分段锁的经典思想，我们可以应用在&lt;strong&gt;热点更新&lt;/strong&gt;的场景，提高更新效率。&lt;/p&gt;
&lt;p&gt;不过一定要记得，当我们引入新方案解决问题时，必定会引入新的复杂度，导致其他问题。这个过程一定要先将这些问题想清楚，然后这中间做一定权衡。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;码出高效 Java 开发手册&lt;/li&gt;
&lt;li&gt;http://www.jasongj.com/java/concurrenthashmap/&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;最后说一句求关注&quot;&gt;最后说一句（求关注）&lt;/h2&gt;
&lt;p&gt;看到这里，点个关注呀，点个赞呗。别下次一定啊，大哥。写文章很辛苦的，需要来点正反馈。&lt;/p&gt;
&lt;p&gt;才疏学浅，难免会有纰漏，如果你发现了错误的地方，还请你留言给我指出来，我对其加以修改。&lt;/p&gt;
&lt;p&gt;感谢您的阅读，我坚持原创，十分欢迎并感谢您的关注&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202003/1419561-20200318073658179-171483038.gif&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 17 Mar 2020 23:37:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>Map 真是一个宝藏类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/12515199.html</dc:identifier>
</item>
<item>
<title>Java 基础（四）：从面试题看String - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/12515175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/12515175.html</guid>
<description>&lt;h3 id=&quot;字符串介绍&quot;&gt;字符串介绍&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;String&lt;/code&gt;类是&lt;code&gt;java.lang&lt;/code&gt;包中的一个类，是我们日常中使用的非常多的一个类，它不是基础数据类型，底层实现是字符数组来实现的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** The value is used for character storage. */
    private final char value[];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;String&lt;/code&gt;类是由&lt;code&gt;final&lt;/code&gt;修饰的，所以是无法被继承的，一旦创建了&lt;code&gt;String&lt;/code&gt;对象，我们就无法改变它的值。因此，&lt;strong&gt;它是线程安全的&lt;/strong&gt;，可以安全地用于多线程环境中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final class String
    implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们通过几道面试题来学习&lt;code&gt;String&lt;/code&gt;类&lt;/p&gt;
&lt;h3 id=&quot;如何创建一个字符串&quot;&gt;如何创建一个字符串&lt;/h3&gt;
&lt;p&gt;一般来说有三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过&lt;code&gt;new&lt;/code&gt;关键字通过构造方法去创建&lt;/li&gt;
&lt;li&gt;通过双引号&lt;code&gt;“”&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过字符串连接符&lt;code&gt;+&lt;/code&gt;和其余字符串进行拼接创建&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;说说这几种的区别&quot;&gt;说说这几种的区别&lt;/h3&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当通过&lt;code&gt;new&lt;/code&gt;关键字调用无参构造时，仅仅在JVM的堆内存中创建了一个对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通过&lt;code&gt;&quot;&quot;&lt;/code&gt;创建对象的时候，如果字符串常量池存在该字符串，直接返回该字符串对象在字符串常量池的地址，否则创建一个新的字符串对象并存储在字符串常量池。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;string-s-new-stringa-创建了几个对象&quot;&gt;String s = new String(&quot;a&quot;) 创建了几个对象&lt;/h3&gt;
&lt;p&gt;当通过&lt;code&gt;new&lt;/code&gt;关键字传入双引号字符串参数时，会先去把该双引号的字符串放入字符串常量池，然后遇到new以后会在堆中再次创建一个字符串对象，这里是创建了两个对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/18/170eab56fa9652ce?w=1362&amp;amp;h=670&amp;amp;f=png&amp;amp;s=277137&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;的实现原理&quot;&gt;+ 的实现原理&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String s1 = null;
String s2 = &quot;abc&quot;;
System.out.println(s1 + s2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;借这道面试题来聊一下+的原理，这道题的答案是”nullabc“，也许会有些奇怪，但是当你了解了&lt;code&gt;+&lt;/code&gt;的原理后也许就不会感到奇怪了，我们使用&lt;code&gt;javap&lt;/code&gt;命令去看一下编译器那里把&lt;code&gt;+&lt;/code&gt;编译成了什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/18/170eab56faaaab55?w=1700&amp;amp;h=860&amp;amp;f=png&amp;amp;s=565688&quot; alt=&quot;image-20190817165354182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在图中被红色框柱的部分可以看出，&lt;code&gt;+&lt;/code&gt;的执行的过程其实就是先把 &lt;code&gt;String&lt;/code&gt;转换成了&lt;code&gt;StringBuilder&lt;/code&gt;后调用&lt;code&gt;append&lt;/code&gt;方法完成拼接后再调用&lt;code&gt;toString&lt;/code&gt;方法完成字符串的拼接。所以上面的代码也可以转换为&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;StringBuilder s1 = new StringBuilder(String.valueOf(null));
StringBuilder s2 = new StringBuilder(&quot;abc&quot;);
s1.append(s2).toString();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关于stringbuilder和stringbuffer&quot;&gt;关于StringBuilder和StringBuffer&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt; 和 &lt;code&gt;StringBuilder&lt;/code&gt; 二者都继承了 &lt;code&gt;AbstractStringBuilder&lt;/code&gt; ，底层都是利用可修改的char数组(JDK 9 以后是 byte数组)。两者的区别是&lt;code&gt;StringBuilder&lt;/code&gt;是线程不安全的，而&lt;code&gt;StringBuffer&lt;/code&gt;是线程安全的。性能上来说，&lt;code&gt;StringBuilder&lt;/code&gt;要高于&lt;code&gt;StringBuffer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在单线程情况下，如有大量的字符串操作情况，不能使用&lt;code&gt;String&lt;/code&gt;来拼接而是使用，避免产生大量无用的中间对象，耗费空间且执行效率低下（新建对象、回收对象花费大量时间）。这时就需要用到我们的&lt;code&gt;StringBuilder&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而在多线程情况下，应当使用&lt;code&gt;StringBuffer&lt;/code&gt;来保证线程的安全~&lt;/p&gt;
&lt;h3 id=&quot;判空&quot;&gt;判空&lt;/h3&gt;
&lt;p&gt;在日常的开发中，我们经常会遇到判断字符串是否为空的需求，这里安利几个工具类中的写法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 来自apache下的lang3包中的StringUtils
import org.apache.commons.lang3.StringUtils
....
  
  
  //这里是判断是否为null或为空
  String s;
  StringUtils.isNotEmpty(s);

    //这里是用于判断是否为null或为空，或空格，Tab这样的占用符
    StringUtils.isNotBlank(s);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;是否相等&quot;&gt;是否相等&lt;/h3&gt;
&lt;p&gt;关于两个字符串是否相等，我用的最多的是&lt;code&gt;java.util&lt;/code&gt;包下的&lt;code&gt;Objects&lt;/code&gt;类中的方法 ，实现方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static boolean equals(Object a, Object b) {
        return (a == b) || (a != null &amp;amp;&amp;amp; a.equals(b));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用法也很简单:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Objects.equals(a,b);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;公众号&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/18/170eaaef7c4af3bf?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=42100&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Mar 2020 22:50:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>字符串介绍 类是 包中的一个类，是我们日常中使用的非常多的一个类，它不是基础数据类型，底层实现是字符数组来实现的： 类是由 修饰的，所以是无法被继承的，一旦创建了 对象，我们就无法改变它的值。因此，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/12515175.html</dc:identifier>
</item>
<item>
<title>WEB应用之http协议和httpd闲聊 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12515075.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12515075.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_200227040346apache-httpd.png&quot; class=&quot;desc_img&quot;/&gt; IPC（Inter-Process Communication，进程间通信），所谓进程间通信就是两个进程互相交换数据；进程间通信的方式有很多，比如内存共享、内存映射、BSD socket等等；其中最为常见的一种BSD socket，它允许位于不同主机（当然同一主机也是可以的，只不过同一主机用这种socket机制显得不那么高效）上的进程之间进行通信；&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;169.31918780299&quot;&gt;
&lt;p&gt;　　什么是web？在日常生活中我们常常听到web这个词，它到底是什么呢？今天我们来聊一聊web应用http协议；相信生活在如今互联网时代的我们，http这个协议应该对我们不是很陌生吧！比如双十一双十二我们去某宝、某东去抢购商品，它背后就是用一堆web服务器通过http协议或https协议在给我们提供服务；简单点说web服务就是一个C/S架构，服务端提供服务，客户端通过http协议或https协议进行访问，拿到服务端对应的资源，这就是web服务；所谓C/S架构就是客户端和服务端架构；对于服务端一侧在iso七层网络模型中应用层协议存在的意义是实现某一具体应用，通常情况下他们都会向内核空间注册一众所周知的服务端口，并监听在某一地址，或多个地址上，对外提供服务；这也通常是C/S架构的软件服务工作的特点；而http协议就是工作在应用层的80端口对外提供服务；对于客户端一侧就没有监听这一说了，通常情况下客户端也是工作在应用层或者我们可以这样理解，它实际不是工作在应用层；我们知道网络资源对于计算机来说只有内核的特权指令才能够操作，而对于普通用户来说，内核的功能我们必须在用户空间提供一应用程序，通过应用程序对内核提供的API进行系统调用，从而实现操作网络资源的能力；实现客户端的软件有很多，图形界面下常见的浏览器chrome呀，firefox呀，ie等等，这些程序都是web服务的客户端，当然除此之外，像在Linux字符界面的web客户端有，wget、curl、elinks等等；这些客户端在用户空间访问服务端时，会随机向内核注册一端口，然后把自己的请求信息通过封装应用层首部，传输层，网络层，数据链路层，物理层，最后通过网卡发送给服务端，服务端收到客户端的请求会对客户端封装的报文，层层拆除，从而拿到客户端的请求，拿到客户端的请求后，然后封装响应报文，封装响应报文的过程类似客户端封装请求报文，先封装应用层首部，然后传输层，网络层，数据链路层，物理层，然后发送给客户端；客户端拿到报文后，层层拆封装，最终拿到服务端的响应；这就是http协议的一次事务过程，无外乎就是客户端请求，服务端响应；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200317231119859-1611196299.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上是以太网的封装报文和解封装报文的一个过程，http协议是应用层协议，通常情况下应用层就是上面三层；应用层是工作在用户空间的，而下面四层是工作在内核空间，通常我们把下面四层称为通信子网层；这也是我们之前的iptables里面经常提到的内核空间功能必须要由用户空间程序对内核发起系统调用才能够操作内核空间功能，所以像iptables、ipvsadm这类工具我们不称他们叫服务，而是工具的原因；同理像web客户端我们通常也只是叫它是工具，而不叫服务；通常所谓服务就是需要向内核注册一端口，然后监听在某一地址上，我们把这种工作在用户空间（或者内核空间的功能）的程序叫服务，简单点讲服务需要被监听，之所以要被监听是因为通信的需要；&lt;/p&gt;
&lt;p&gt;　　IPC（Inter-Process Communication，进程间通信），所谓进程间通信就是两个进程互相交换数据；进程间通信的方式有很多，比如内存共享、内存映射、BSD socket等等；其中最为常见的一种BSD socket，它允许位于不同主机（当然同一主机也是可以的，只不过同一主机用这种socket机制显得不那么高效）上的进程之间进行通信；什么叫socket?相信懂点网络编程的人都听过这个词吧！ 所谓socket就是IP加端口，对于套接字可以分TCP套接字、udp套接字、raw套接字，它们通常情况下是通过socket API(封装了内核中的socket通信相关的系统调用)来创建不同的套接字类型；如SOCK_STREAM就是表示TCP套接字，SOCK_DGRAM就表示UDP套接字，SOCK_RAW就表示raw套接字；根据套接字所使用的地址格式，我们又可以分为IPV4的套接字、ipv6套接字和unix_sock(同一主机上的不同进程间基于socket套接字通信使用的一种地址)；例如AF_INET就表示ipv4格式的套接字，AF_INET6就表示ipv6套接字格式，AF_UNIX就表示unix_sock套接字格式；其中前两者用于网络通信，通常是位于不同主机间进程通信，而后者unix_sock用于同一主机的两个进程通信较为常见；后者就是我们常见的sock文件，例如mysql客户端连接本地服务端就是用的这种机制;&lt;/p&gt;
&lt;p&gt;　　了解上面的底层通信原理，我们再来聊聊今天的主题http吧&lt;/p&gt;
&lt;p&gt;　　http是hyper text transfer protocol的简写，它是应用层协议，默认工作在tcp协议的80端口，属于文本协议；在http协议0.9版本中，它就只能用于传输html文本，也是在互联网上使用的最原始的版本，功能相当简陋；1.0版本引进了cache机制，MIME机制和更多的method，使得http协议一下子被广泛使用，MIME是多用途互联网邮件扩展类型，它的主要作用是让一些非文本格式的附件能够通过互联网互相传输，并且在接收方接收后能够将其还原成原有格式的附件的机制，什么意思呢？它能够让一些非文本格式的附件在通过互联网传输后还原成原来格式的附件的一种机制；这使得http协议可以传输非文本格式的数据，比如图片、视频、音乐等；所谓method就是客户端请求服务端资源时数据传输请求的方法，在0.9版本http协议只支持GET这一种方法，在1.0版本中http协议支持了更多的请求方法，如GET、PUT、POST、DELETE、HEAD等等；在这之后有1.1版本，它主要是在1.0版本上增强了缓存功能；随后就是2.0，2.0主要是在1.1版本上做了很多优化，使得原有1.1本版的诸多性能问题得以解决，现在主流使用的http协议版本是1.1和2.0版本；&lt;/p&gt;
&lt;p&gt;　　http工作模式&lt;/p&gt;
&lt;p&gt;　　http的工作模式非常简单，在上面我们也提到过，不外乎就是客户端请求，服务端响应；其中我们把请求报文叫做http request响应报文叫做http response；对于客户端的一次请求和服务端的一次响应响应我们把这一过程叫做http协议的一次事务；&lt;/p&gt;
&lt;p&gt;　　web资源：web resource&lt;/p&gt;
&lt;p&gt;　　web资源分静态资源和动态资源，所谓静态资源就是无需服务端做额外的处理的资源，我们叫静态资源，什么意思呢？客户端请求的资源，在服务端是什么样通过http协议传输后到客户端上就是什么样，我们就把这种不需要服务端额外处理的资源叫静态资源，常见的静态资源有.jpg, .png, .gif, .html, txt, .js, .css, .mp3, .avi等；所谓动态资源就与之相反，客户端请求的资源通常是需要被程序执行或处理后，然后把执行结果或处理后的结果发送给客户端，我们把这种需要服务端通过某一执行程序作出处理的资源叫动态资源；常见的有.php.jsp.asp等；这里还需要注意一点的是，我们平常看到的网页资源往往不是单独的一个资源，它可能是有很多资源组成，有动态的，也有静态的，每个资源都需要单独请求，如下所示；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200318010540823-181453185.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们访问一个页面的背后其实是有很多资源组成；&lt;/p&gt;
&lt;p&gt;　　资源的标识机制：URL&lt;/p&gt;
&lt;p&gt;　　所谓资源标识符就是用于描述服务器某特定资源的位置；简单点就是用于告诉服务端客户端要访问的资源；通常情况下URL由协议加“：//”加服务器地址（可以是域名，或主机名）[:port](若服务端工作在非标准端口，我们还需要指定端口)然后加资源路径或资源名称（这里的资源路径指的是web服务的根路径开始，而非文件系统的根路径）例如http://www.test.com/index.html这就是一个URL，客户端介入这样一个URL对应的服务端就知道客户端请求的资源是www.test.com这台主机上的index.html文件，服务端就会把对应目录下的文件响应给客户端；对于服务端它怎么去自己的文件系统上找index.html这个文件，通常情况下是通过我们对服务端定义的documentroot来决定的，在nginx中我们可以通过root指令来指定虚拟主机的根目录对应文件系统路径的映射；&lt;/p&gt;
&lt;p&gt;　　一次完整的http请求处理过程通常是有以下几步来完成：&lt;/p&gt;
&lt;p&gt;　　(1) 建立或处理连接：接收请求或拒绝请求；&lt;br/&gt;　　(2) 接收请求：接收来自于网络上的主机请求报文中对某特定资源的一次请求的过程；&lt;/p&gt;
&lt;p&gt;　　http的响应模型，http的响应模型主要有单进程I/O模型、多进程、复用I/O模型和服用多进程模型，其中单进程I/O模型就是启动一个进程处理用户的请求，这意味着，一次只能处理一个请求，多个请求被串行响应；多进程I/O模型表示由父进程并行启动多个子进程，每个子进程进行相应一个用户请求；复用单进程I/O模型有两个模式，多线程模式和事件驱动模式，前者表示一个进程生成N个线程，一个线程处理一个请求；而事件驱动模式中一个进程直接处理N个请求，没有线程的说法；复用多进程I/O模型中，启动多个进程，每个进程生成n个线程，每个线程处理一个请求，响应的请求数量是进程数量乘每个进程生成的线程数；&lt;br/&gt;　　(3) 处理请求：服务器对请求报文进行解析，并获取请求的资源及请求方法等相关信息，根据方法，资源，首部和可选的主体部分对请求进行处理&lt;/p&gt;
&lt;p&gt;　　　　元数据：请求报文首部&lt;br/&gt;　　　　&amp;lt;method&amp;gt; &amp;lt;URL&amp;gt; &amp;lt;VERSION&amp;gt;&lt;br/&gt;　　　　HEADERS 格式 name:value&lt;br/&gt;　　　　&amp;lt;request body&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　　　……&lt;/p&gt;
&lt;p&gt;　　　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1503305/202003/1503305-20200318021726416-449973000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　(4) 访问资源：获取请求报文中请求的资源；服务器获取请求报文中请求的资源web服务器，即存放了web资源的服务器，负责向请求者提供对方请求的静态资源，或动态运行后生成的资源；资源放置于本地文件系统特定的路径：DocRoot&lt;/p&gt;
&lt;p&gt;　　　　示例：如果我们将web资源根目录映射成文件系统上的/var/www/html，即www.test.com/   ----&amp;gt;&amp;gt;  /var/www/html，用户访问www.test.com/index.html，就相当于访问文件系统上的/var/www/html/index.html，通常情况下web服务器资源路径映射方式有4种，第一种是通过定义docroot来指定，第二种是alias别名来指定，第三种是虚拟主机的docroot第四种是用户家目录的docroot&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　&lt;/em&gt;(5) 构建响应报文：一旦Web服务器识别除了资源，就执行请求方法中描述的动作，并返回响应报文。响应报文中 包含有响应状态码、响应首部，如果生成了响应主体的话，还包括响应主体；&lt;/p&gt;
&lt;p&gt;　　　　响应实体：如果事务处理产生了响应主体，就将内容放在响应报文中回送过去。响应报文中通常包括：描述了响应主体MIME类型的Content-Type首部，描述了响应主体长度的Content-LengthContent-Type首部和实际报文的主体内容&lt;/p&gt;
&lt;p&gt;　　　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1503305/202003/1503305-20200318023151185-571614440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　(6) 发送响应报文：Web服务器通过连接发送数据时也会面临与接收数据一样的问题。服务器可能有很多条到各个客户端的连接，有些是空闲的，有些在向服务器发送数据，还有一些在向客户端回送响应数据。服务器要记录连接的状态，还要特别注意对持久连接的处理。对非持久连接而言，服务器应该在发送了整条报文之后，关闭自己这一端的连接。对持久连接来说，连接可能仍保持打开状态，在这种情况下，服务器要正确地计算Content-Length首部，不然客户端就无法知道响应什么时候结束了；&lt;br/&gt;　　(7) 记录日志：最后，当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务；&lt;/p&gt;
&lt;p&gt;　　 HTTP服务器应用&lt;/p&gt;
&lt;p&gt;　　http服务器程序有httpd、nginx、lighttpd等nginx相关使用和说明可参考本人前面的博客&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/category/1646010.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/category/1646010.html&lt;/a&gt;；接下来我们着重来说说httpd；&lt;/p&gt;
&lt;p&gt;　　httpd是20世纪90年代初，国家超级计算机应用中心NCSA开发，1995年开源社区发布apache（a patchy server）它是一款高度模块化，支持动态加卸载模块，支持多路处理模块，所谓多路处理模块就是httpd的三种响应模型；&lt;/p&gt;
&lt;p&gt;　　第一种是prefork多进程模型，每个进程响应一个请求，一个主进程，主进程程负责生成子进程以及回收子进程、套接字的创建和接收请求并将其派发给某个子进程处理；n个子进程（一个子进程中生成一个线程处理一个请求），子进程主要用于处理请求；工作模型：会预先生成几个空闲进程，随时等待用于响应用户请求；最大空闲和最小空闲；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200318030753753-1876251162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第二种是worker多进程多线程模型，在这种模型中每个线程处理一个用户请求；同样的它也会由一个主进程负责生成子进程，套接字的创建和接收请求并将请求派发给某个子进程进行处理；n个子进程，和上面的profork不同的是，这里的子进程主要负责生成多个线程，而每个线程处理一个请求；这样一来在这种模型中并发响应数量就是n个子进程乘每个子进程生成的M个线程；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200318030830889-1432616900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第三种是event:事件驱动模型，多进程模型，一个主进程生成m个子进程，每个进程直接响应n个请求，并发响应请求：m*n，有专门的线程来管理这些keep-alive类型的线程，当有真实请求时，将请求传递给服务线程，执行完毕后，又允许释放。这样增强了高并发场景下的请求处理能力&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202003/1503305-20200318031322003-144244498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是httpd的一些简单介绍，在后续的文章中我会持续更新httpd的其他用法和配置指令的说明，有感兴趣的朋友可以关注关注，共同探讨；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 17 Mar 2020 19:36:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>什么是web？在日常生活中我们常常听到web这个词，它到底是什么呢？今天我们来聊一聊web应用http协议；相信生活在如今互联网时代的我们，http这个协议应该对我们不是很陌生吧！比如双十一双十二我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12515075.html</dc:identifier>
</item>
<item>
<title>《前端之路》- TypeScript(二) 函数篇 - SmallW</title>
<link>http://www.cnblogs.com/erbingbing/p/12515101.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erbingbing/p/12515101.html</guid>
<description>&lt;h3 id=&quot;一定义函数方法&quot;&gt;一、定义函数方法&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在 es5 中定时函数的方法有 命名函数和函数表达式（匿名函数）这门两种。那么同样的，在 TypeScript 中，函数的定义是什么样子的呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;命名函数&quot;&gt;1-1 命名函数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;这里需要注意的一点是： viod 类型，是函数不返回任何类型数据&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt; 语法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;function func1(): string {
    return '213';
}

function func2(): number {
    return 123;
}

function func3(): Array&amp;lt;any&amp;gt; {
    return [123, {}];
}

function func4(): Array&amp;lt;number&amp;gt; {
    return [123, 456];
}

function func5(): Array&amp;lt;string&amp;gt; {
    return ['123', '1233'];
}

function func6(): void {
    console.log(123);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;被编译成 &lt;code&gt;ES5&lt;/code&gt; 的 &lt;code&gt;JavaScript&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&quot;use strict&quot;;
function func1() {
    return '213';
}
function func2() {
    return 123;
}
function func3() {
    return [123, {}];
}
function func4() {
    return [123, 456];
}
function func5() {
    return ['123', '1233'];
}
function func6() {
    console.log(123);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;函数表达式&quot;&gt;1-2 函数表达式&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;这里需要简单的普及一个 ES6 的箭头函数，无大括号时，直接表示 return 这个值。&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt; 语法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;const fun11 = (): string =&amp;gt; {
    return '123';
};

const fun12 = (): string =&amp;gt; '123';

const fun13 = (): any =&amp;gt; [123, '123'];

const fun14 = function(): string {
    return '123';
};

const fun15 = function(): any {
    return { name: 123 };
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;被编译成 &lt;code&gt;ES5&lt;/code&gt; 的 &lt;code&gt;JavaScript&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&quot;use strict&quot;;
var fun11 = function () {
    return '123';
};
var fun12 = function () { return '123'; };
var fun13 = function () { return [123, '123']; };
var fun14 = function () {
    return '123';
};
var fun15 = function () {
    return { name: 123 };
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二定义函数传参&quot;&gt;二、定义函数传参&lt;/h3&gt;
&lt;h4 id=&quot;定义函数传参&quot;&gt;2-1 定义函数传参&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;这里需要简单的描述下，函数的传参的类型和之前文章中介绍到的数据类型定义方式是一致的。&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt; 语法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;const parasFun1 = (x: string, y: number) =&amp;gt; {
    console.log(x + y);
};

let res1 = parasFun1('1', 2); // 猜猜返回啥？哈哈哈哈 可以子啊留言中写下你的答案&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;被编译成 &lt;code&gt;ES5&lt;/code&gt; 的 &lt;code&gt;JavaScript&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&quot;use strict&quot;;
var parasFun1 = function (x, y) {
    console.log(x + y);
};
var res1 = parasFun1('1', 2); // 猜猜返回啥？哈哈哈哈 可以子啊留言中写下你的答案&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三可选传参&quot;&gt;三、可选传参&lt;/h3&gt;
&lt;h4 id=&quot;定义函数的可选传参&quot;&gt;3-1 定义函数的可选传参&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;这里需要简单的描述下，函数的可选参数，很明显就是可以选择传入这个参数也可以选择不传入这个参数，且可选参数一定是排在必传参数的后面。&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt; 语法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;const parmaFunc1 = (name: string, age?: number) =&amp;gt; {
    if (age) {
        return `我的名字是：${name} --- 我的年龄是： ${age}`;
    } else {
        return `我的名字是：${name} --- 我的年龄保密！`;
    }
};

let res11 = parmaFunc1('zhangsan', 123);
let res12 = parmaFunc1('zhangsan');

const parmaFunc2 = (name?: string, age: number) =&amp;gt; {
    if (age) {
        return `我的名字是：${name} --- 我的年龄是： ${age}`;
    } else {
        return `我的名字是：${name} --- 我的年龄保密！`;
    }
};
// 这里的 parmaFunc2 会报错么？&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;被编译成 &lt;code&gt;ES5&lt;/code&gt; 的 &lt;code&gt;JavaScript&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&quot;use strict&quot;;
var parmaFunc1 = function (name, age) {
    if (age) {
        return &quot;\u6211\u7684\u540D\u5B57\u662F\uFF1A&quot; + name + &quot; --- \u6211\u7684\u5E74\u9F84\u662F\uFF1A &quot; + age;
    }
    else {
        return &quot;\u6211\u7684\u540D\u5B57\u662F\uFF1A&quot; + name + &quot; --- \u6211\u7684\u5E74\u9F84\u4FDD\u5BC6\uFF01&quot;;
    }
};
var res11 = parmaFunc1('zhangsan', 123);
var res12 = parmaFunc1('zhangsan');&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四默认传参&quot;&gt;四、默认传参&lt;/h3&gt;
&lt;h4 id=&quot;定义函数默认传参&quot;&gt;4-1 定义函数默认传参&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;这里的默认传参和 ES6 中默认传参的使用方式是一致的&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt; 语法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;const defaultParamFunc1 = (x: string, age: number = 10): void =&amp;gt; {
    console.log(`我的名字是：${name} --- 我的年龄是： ${age}`);
};

let defaultRes1 = defaultParamFunc1('zhangsan');
// 这里会打印出什么呢？&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;被编译成 &lt;code&gt;ES5&lt;/code&gt; 的 &lt;code&gt;JavaScript&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&quot;use strict&quot;;
var defaultParamFunc1 = function (x, age) {
    if (age === void 0) { age = 10; }
    console.log(&quot;\u6211\u7684\u540D\u5B57\u662F\uFF1A&quot; + name + &quot; --- \u6211\u7684\u5E74\u9F84\u662F\uFF1A &quot; + age);
};
var defaultRes1 = defaultParamFunc1('zhangsan');
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五传递剩余参数&quot;&gt;五、传递剩余参数&lt;/h3&gt;
&lt;h4 id=&quot;定义函数传递剩余参数三点运算符&quot;&gt;5-1 定义函数传递剩余参数（三点运算符）&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;这里的传递剩余参数和 ES6 中传递剩余参数的使用方式是一致的,只不过我们可能需要对剩余参数进行一个类型的定义&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt; 语法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;// 写一个demo 就是，我们需要对一个对个求和，且我们不知道具体会有多少个参数

const restParamsFunc1 = (x: any, y: any, z: any): number =&amp;gt; {
    return x + y + z;
};
let restRes1 = restParamsFunc1(1, 2, 3); // 正常运行

// let restRes2 = restParamsFunc1(1, 2, 3, 4); // ts 会报错，说第四个参数未声明

const restParamsFunc2 = (...res: number[]): number =&amp;gt; {
    let sum = 0;
    for (let index = 0; index &amp;lt; res.length; index++) {
        sum += res[index];
    }
    return sum;
};
let restRes3 = restParamsFunc2(1, 2, 3, 4); // 这个时候又会得出什么结果呢？
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;被编译成 &lt;code&gt;ES5&lt;/code&gt; 的 &lt;code&gt;JavaScript&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&quot;use strict&quot;;
// 写一个demo 就是，我们需要对一个对个求和，且我们不知道具体会有多少个参数
var restParamsFunc1 = function (x, y, z) {
    return x + y + z;
};
var restRes1 = restParamsFunc1(1, 2, 3); // 正常运行
// let restRes2 = restParamsFunc1(1, 2, 3, 4); // ts 会报错，说第四个参数未声明
var restParamsFunc2 = function () {
    var res = [];
    for (var _i = 0; _i &amp;lt; arguments.length; _i++) {
        res[_i] = arguments[_i];
    }
    var sum = 0;
    for (var index = 0; index &amp;lt; res.length; index++) {
        sum += res[index];
    }
    return sum;
};
var restRes3 = restParamsFunc2(1, 2, 3, 4); // 这个时候又会得出什么结果呢？&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;六函数重载&quot;&gt;六、函数重载&lt;/h3&gt;
&lt;h4 id=&quot;javascript-中的函数重载&quot;&gt;6-1 JavaScript 中的函数重载&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;函数名称相同，但是函数的传入参数不同。执行不同的功能，这个时候就会出现函数重载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt; 语法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;const reloadFunc1 = (name: string) =&amp;gt; {
    console.log(name);
};
const reloadFunc1 = (age: string) =&amp;gt; {
    console.log(age);
};
const reloadFunc1 = (name: string, age: number) =&amp;gt; {
    if (age) {
        console.log(name, age);
    } else {
        console.log(name);
    }
};

// 这个时候我们会发现 ts 已经给我们报了语法的错误，但是转译成 es5 的代码的时候依然可以运行，只不过后面定义的方式会覆盖前面定义的同名函数的方法
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;被编译成 &lt;code&gt;ES5&lt;/code&gt; 的 &lt;code&gt;JavaScript&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&quot;use strict&quot;;
var reloadFunc1 = function (name) {
    console.log(name);
};
var reloadFunc1 = function (age) {
    console.log(age);
};
var reloadFunc1 = function (name, age) {
    if (age) {
        console.log(name, age);
    }
    else {
        console.log(name);
    }
};
// 这个时候我们会发现 ts 已经给我们报了语法的错误，但是转译成 es5 的代码的时候依然可以运行，只不过后面定义的方式会覆盖前面定义的同名函数的方法&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里我们需要区分一下 Java 中的函数重载和 ts 中的函数重载的区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在 Java 中 定义的同名重载函数，会根据传入数据类型的差异，直接执行对应的函数，但是 ts 不会。&lt;/li&gt;
&lt;li&gt;在 ts 中，即使定义了重载函数，编译成 ES5 以后，还是只剩下一个对应函数的判断。这里我们只做一个简单的了解，在前端写 JS 的时候还是需要注意命名空间和命名重叠的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们还是以代码的例子来做区分，例子一如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt; 语法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;const reloadFunc2 = (name: string):string;
const reloadFunc2 = (age: number):number;
const reloadFunc2 = (age:any):any =&amp;gt; {
    if(typeof age === 'number') {
        console.log(name, age)
    }  else {
        console.log(name)
    }
}

// 这个时候，ts 依然会报错，是为什么？ 这里就要提到 const 、let 的作用域的问题，因为这里也是 ES6 的基础知识，不展开来说了。&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;被编译成 &lt;code&gt;ES5&lt;/code&gt; 的 &lt;code&gt;JavaScript&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var reloadFunc2 = function (name) { return ; };
var reloadFunc2 = function (age) { return ; };
var reloadFunc2 = function (age) {
    if (typeof age === 'number') {
        console.log(name, age);
    }
    else {
        console.log(name);
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们还是以代码的例子来做区分，例子二如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt; 语法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;function reloadFunc3(name: string):string; 
function reloadFunc3(age: number):number;
function reloadFunc3(str:any):any {
    if(typeof str === 'number') {
        console.log(name, str)
    }  else {
        console.log(name)
    }
}; &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;被编译成 &lt;code&gt;ES5&lt;/code&gt; 的 &lt;code&gt;JavaScript&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function reloadFunc3(str) {
    if (typeof str === 'number') {
        console.log(name, str);
    }
    else {
        console.log(name);
    }
}

// 这里编译出来，居然只有一个函数，惊叹了，为什么惊叹了呢？因为这里和 Java 中的函数重载差别有点大。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;七箭头函数&quot;&gt;七、箭头函数&lt;/h3&gt;
&lt;h4 id=&quot;定义箭头函数&quot;&gt;7-1 定义箭头函数&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;箭头函数的话，其实和 ES6 中的写法是一致的，然后需要我们注意的是，箭头函数中的上下文，指向的是起父级函数的上下文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt; 语法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;const arrowFunc = (): number =&amp;gt; {
    return 123;
};

setTimeout(() =&amp;gt; {
    console.log('过了一秒');
}, 1000);
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;被编译成 &lt;code&gt;ES5&lt;/code&gt; 的 &lt;code&gt;JavaScript&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&quot;use strict&quot;;
var arrowFunc = function () {
    return 123;
};
setTimeout(function () {
    console.log('过了一秒');
}, 1000);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;八总结&quot;&gt;八、总结&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这一篇文章也只能算是基础入门级别的 ts 中函数的定义方式和方法，这个需要大家在日常的项目中多书写，才能避免一些问题，然后我们就会发现，我们在使用 ts 去书写一些函数和对应参数的时候，我们已经可以避免一些多余参数和错误的参数类型的传入导致的一些奇奇怪怪的bug。好了，这一章就先写到这里。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;2.5252525252525&quot;&gt;
&lt;p&gt;GitHub 地址：（欢迎 star 、欢迎推荐 : )&lt;br/&gt;&lt;a href=&quot;https://github.com/erbing/blog/blob/master/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%20-%20TypeScript/%E4%BA%8C%E3%80%81typeScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0.md&quot;&gt;《前端之路》 - TypeScript（二）函数篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 17 Mar 2020 18:11:00 +0000</pubDate>
<dc:creator>SmallW</dc:creator>
<og:description>[TOC] 一、定义函数方法 在 es5 中定时函数的方法有 命名函数和函数表达式（匿名函数）这门两种。那么同样的，在 TypeScript 中，函数的定义是什么样子的呢？ 1 1 命名函数 这里需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/erbingbing/p/12515101.html</dc:identifier>
</item>
<item>
<title>React hooks详解 - 漠然1992丶</title>
<link>http://www.cnblogs.com/moran1992/p/12514899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moran1992/p/12514899.html</guid>
<description>&lt;p&gt;此篇文章仅是对hooks入门的总结，老鸟略过吧~&lt;/p&gt;
&lt;p&gt;React从16.8.X以后增加了一个新特性，react hooks 让我们看看这个新特性又带来了哪些惊喜呢~以下内容我们采取不同方式创建组件来进行对比总结&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件的创建方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用过react的都了解，传统react创建组件提供了两种方式，函数式与类（class）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class创建无状态组件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class App extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;
      &amp;lt;p&amp;gt;{&lt;span&gt;this&lt;/span&gt;.props.name}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;span&gt;  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; renderApp() {
  let appProps &lt;/span&gt;=&lt;span&gt; {
    name: &lt;/span&gt;'dqhan'&lt;span&gt;
  }
  ReactDOM.render(
    &lt;/span&gt;&amp;lt;App  {...appProps} /&amp;gt;,
    document.getElementById('app'&lt;span&gt;)
  )
}

renderApp();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;添加状态管理&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class App extends React.Component {
  constructor(props) {
    super(props);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
      name: props.name
    };
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handleChangeName = &lt;span&gt;this&lt;/span&gt;.handleChangeName.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }

  handleChangeName() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
      name: &lt;/span&gt;'我变了'&lt;span&gt;
    })
  }

  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;React.Fragment&amp;gt;
        &amp;lt;p&amp;gt; {`hello~${&lt;span&gt;this&lt;/span&gt;.state.name}`} &amp;lt;/p&amp;gt;
        &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.handleChangeName}&amp;gt;&amp;lt;/button&amp;gt;
      &amp;lt;/React.Fragment&amp;gt;
&lt;span&gt;    );
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们通过class可以实现无状态组件以及常规组件通过setState的状态管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数式创建组件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App(props) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;p&amp;gt;{`hello! ${props.name}`}&amp;lt;/p&amp;gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; renderApp() {
  let appProps &lt;/span&gt;= { name: &quot;dqhan&quot;&lt;span&gt; };
  ReactDOM.render(&lt;/span&gt;&amp;lt;App {...appProps} /&amp;gt;, document.getElementById(&quot;app&quot;));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数式创建组件通常是无状态组件，这种方式没有办法在内部对状态统一管理，如果我们非要添加状态管理呢，那就只能借助redux啦~或者我们自己利用观察者模式实现一个发布订阅（emmmm比较勉强吧，毕竟实际开发中我们不可能这么做）&lt;/p&gt;
&lt;p&gt;那么如果我们非要这么做呢，正题来了，React版本在16.8.X以后增添了一个新特性就是hooks。&lt;/p&gt;
&lt;p&gt;hooks涉及API有useState、 useEffect、 useCallback、 useRef、 useMemo、 React.memo、 useReducer等，具体可以参考官方文档，我们来看一下hooks怎么用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React Hooks创建组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无状态组件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App(props) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;{`hello~${props.name}`}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哈哈，跟函数式一样，毕竟我们要在函数式组件里添加状态管理嘛&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.useState&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作用：添加状态管理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App() {
  let [name, setName] &lt;/span&gt;= useState('dqhan'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;{`hello~${name}`}&amp;lt;/p&amp;gt;
    &amp;lt;button onClick={() =&amp;gt; setName('我变了')}&amp;gt;Click&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;react hook可以管理自己的状态，有自己的函数钩子，这点相比要函数式显然效果更好，不需要借助redux，这就是我们为啥要在前面提到函数式编程涉及状态管理问题，就是要在这里跟react hook做个比较。&lt;/p&gt;
&lt;p&gt;到这里我们知道了这个useState，多了一个useState让函数式创建类有了自己的持久状态。那么在函数式里面我们如何做到class组件中的setState呢？&lt;/p&gt;
&lt;div readability=&quot;14.462686567164&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App(props) {
  let [name, setName] &lt;/span&gt;= useState('dqhan'&lt;span&gt;);
  let handleChangeName &lt;/span&gt;= useCallback(() =&amp;gt;&lt;span&gt; {
    setName(preState &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      let updatedValues &lt;/span&gt;=&lt;span&gt; {
        newValue: &lt;/span&gt;'我变了'&lt;span&gt;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; { ...{ preState }, ...updatedValues }
    })
  })
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; click1(params) {
    setName(&lt;/span&gt;'我变了1'&lt;span&gt;)
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;{`hello~${name}`}&amp;lt;/p&amp;gt;
    &amp;lt;button onClick={handleChangeName}&amp;gt;Click1&amp;lt;/button&amp;gt;
    &amp;lt;button onClick={click1}&amp;gt;Click2&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这中方式已经实现了状态整合，但是我们如果模拟一个state呢，来统一管理state呢，我们可以这么实现&lt;/p&gt;
&lt;div readability=&quot;16.455429497569&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App(props) {
  let [state, setState] &lt;/span&gt;=&lt;span&gt; useState({
    name: &lt;/span&gt;'dqhan'&lt;span&gt;
  });
  let handleChangeName &lt;/span&gt;= useCallback(() =&amp;gt;&lt;span&gt; {
    setState(preState &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      let updatedValues &lt;/span&gt;=&lt;span&gt; {
        name: &lt;/span&gt;'我变了'&lt;span&gt;
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; { ...preState, ...updatedValues }
    })
  })
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;{`hello~${state.name}`}&amp;lt;/p&amp;gt;
    &amp;lt;button onClick={handleChangeName}&amp;gt;Click&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到目前为止，已经知道了react hook中如何使用state，那么周期函数呢，那么就涉及另一个钩子useEffect&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.useEffect&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作用：周期函数&lt;/p&gt;
&lt;p&gt;useEffect涉及三个周期函数 componentDidMount 、componentDidUpdate、 compinentWillUmount 我们看一个简单的实例&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App() {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; [count, setCount] = useState(0&lt;span&gt;);
  useEffect(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    console.log(`update&lt;/span&gt;--&lt;span&gt;${count}`);
  }, [count]);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;div&amp;gt;
      &amp;lt;button onClick={() =&amp;gt; setCount(count + 1)}&amp;gt;Click&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;span&gt;  );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们来了解一下react hooks的周期函数，他是如何工作的&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App() {
  let [count, setCount] &lt;/span&gt;= useState(0&lt;span&gt;);
  useEffect(
    () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认每一次渲染都需要执行的方法&lt;/span&gt;
      console.log('didmount'&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果需要实现componentWillComponent,则return 一个函数即可    &lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; unmount() {
        console.log(&lt;/span&gt;'unmount'&lt;span&gt;)
      }
    }
  )

  let handleSetCount &lt;/span&gt;= useCallback(() =&amp;gt;&lt;span&gt; {
    setCount((preCount) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      let updatedCount &lt;/span&gt;= preCount + 1&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; updatedCount;
    });
  })

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;React.Fragment&amp;gt;&lt;span&gt;
    {console.log(&lt;/span&gt;'render'&lt;span&gt;)}
    &lt;/span&gt;&amp;lt;p&amp;gt;{`${count}`}&amp;lt;/p&amp;gt;
    &amp;lt;button onClick={handleSetCount}&amp;gt;Click&amp;lt;/button&amp;gt;
  &amp;lt;/React.Fragment&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;p&gt;我们可以看一下执行周期&lt;/p&gt;
&lt;p&gt;第一次渲染时候执行 render  didmount&lt;/p&gt;
&lt;p&gt;点击事件执行顺序 render unmount didmount&lt;/p&gt;
&lt;p&gt;不难看出，每一次渲染我们都会执行render进行渲染，然后清除掉上一次的useEffect，然后渲染完成之后重新执行useEffect&lt;/p&gt;
&lt;p&gt;这样通过一个useEffec可以默认执行两个周期函数，也就是当我们需要对组件添加一些需要当组件卸载时候清除掉的功能时候，这个是很方便的，常见的就是setTimeout setIntrval等定时器&lt;/p&gt;
&lt;p&gt;但是比如一个component渲染之后我们通常会发送一个请求来请求数据，然后重写渲染这个组件，这样会造成死循环怎么办，我们可以在useEffect后添加第二个参数&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;阻止useEffect每一次都要执行&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;12.956115674581&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App() {
  let [count, setCount] &lt;/span&gt;= useState(0&lt;span&gt;);
  useEffect(
    () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认每一次渲染都需要执行的方法&lt;/span&gt;
      console.log('didmount'&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果需要实现componentWillComponent,则return 一个函数即可    &lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; unmount() {
        console.log(&lt;/span&gt;'unmount'&lt;span&gt;)
      }
    },
    [setCount]
  )

  let handleSetCount &lt;/span&gt;= useCallback(() =&amp;gt;&lt;span&gt; {
    setCount((preCount) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      let updatedCount &lt;/span&gt;= preCount + 1&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; updatedCount;
    });
  })

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;React.Fragment&amp;gt;&lt;span&gt;
    {console.log(&lt;/span&gt;'render'&lt;span&gt;)}
    &lt;/span&gt;&amp;lt;p&amp;gt;{`${count}`}&amp;lt;/p&amp;gt;
    &amp;lt;button onClick={handleSetCount}&amp;gt;Click&amp;lt;/button&amp;gt;
  &amp;lt;/React.Fragment&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当传入第二个参数得值不变得时候就会跳过useEffect函数执行&lt;/p&gt;
&lt;div readability=&quot;8.9673083908464&quot;&gt;
&lt;p&gt;如何模拟componentDidMount与componentWillUmount,第二个参数我们传一个空数组，这样就可以实现仅当组件渲染跟组件卸载得时候执行&lt;/p&gt;
&lt;div readability=&quot;12.951822112415&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App() {
  let [count, setCount] &lt;/span&gt;= useState(0&lt;span&gt;);
  useEffect(
    () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认每一次渲染都需要执行的方法&lt;/span&gt;
      console.log('didmount'&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果需要实现componentWillComponent,则return 一个函数即可    &lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; unmount() {
        console.log(&lt;/span&gt;'unmount'&lt;span&gt;)
      }
    },
    []
  )

  let handleSetCount &lt;/span&gt;= useCallback(() =&amp;gt;&lt;span&gt; {
    setCount((preCount) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      let updatedCount &lt;/span&gt;= preCount + 1&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; updatedCount;
    });
  })

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;React.Fragment&amp;gt;&lt;span&gt;
    {console.log(&lt;/span&gt;'render'&lt;span&gt;)}
    &lt;/span&gt;&amp;lt;p&amp;gt;{`${count}`}&amp;lt;/p&amp;gt;
    &amp;lt;button onClick={handleSetCount}&amp;gt;Click&amp;lt;/button&amp;gt;
  &amp;lt;/React.Fragment&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;18.924543288324&quot;&gt;
&lt;p&gt;不过，这隐藏了一个问题:传递空数组容易出现问题。如果咱们添加了依赖项，那么很容易忘记向其中添加项，如果错过了一个依赖项，那么该值将在下一次运行useEffect时失效，并且可能会导致一些奇怪的问题。&lt;/p&gt;
&lt;p&gt;常见得就是当我们想用父组件调用子组件时候使用得ref,或者我们要获取dom焦点时&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App() {
  let [count, setCount] &lt;/span&gt;= useState(0&lt;span&gt;);
  let [value, setValue] &lt;/span&gt;= useState(''&lt;span&gt;)
  const inputRef &lt;/span&gt;=&lt;span&gt; useRef();

  useEffect(
    () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认每一次渲染都需要执行的方法&lt;/span&gt;
      console.log('didmount'&lt;span&gt;)

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果需要实现componentWillComponent,则return 一个函数即可    &lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; unmount() {
        console.log(&lt;/span&gt;'unmount'&lt;span&gt;)
      }
    },
    [inputRef]
  )

  let handleSetCount &lt;/span&gt;= useCallback(() =&amp;gt;&lt;span&gt; {
    setCount((preCount) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      let updatedCount &lt;/span&gt;= preCount + 1&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; updatedCount;
    });
  })

  let handleSetValue &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
    setValue(e.target.value);
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;React.Fragment&amp;gt;&lt;span&gt;
    {console.log(&lt;/span&gt;'render'&lt;span&gt;)}
    &lt;/span&gt;&amp;lt;p&amp;gt;{`${count}`}&amp;lt;/p&amp;gt;
    &amp;lt;&lt;span&gt;input
      ref&lt;/span&gt;=&lt;span&gt;{inputRef}
      value&lt;/span&gt;=&lt;span&gt;{value}
      onChange&lt;/span&gt;=&lt;span&gt;{handleSetValue}
    &lt;/span&gt;&amp;gt;&amp;lt;/input&amp;gt;
    &amp;lt;&lt;span&gt;button
      ref&lt;/span&gt;=&lt;span&gt;{inputRef}
      onClick&lt;/span&gt;=&lt;span&gt;{handleSetCount}
    &lt;/span&gt;&amp;gt;Click&amp;lt;/button&amp;gt;

  &amp;lt;/React.Fragment&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们实现一个请求实例&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;请求实例&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;35.830028328612&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App() {
  let [data, setData] &lt;/span&gt;= useState(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
  useEffect(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    const fetchData &lt;/span&gt;= async () =&amp;gt;&lt;span&gt; {
      const result &lt;/span&gt;=&lt;span&gt; await axios(config);
      setData(result);
    };

    fetchData();
  }, []);

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;利用hook可以做到分离接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; useFetchHook(config, watch) {
  let [data, setData] &lt;/span&gt;= useState(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
  let [status, setStatus] &lt;/span&gt;= useState(0&lt;span&gt;);
  useEffect(
    () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      const fetchData &lt;/span&gt;= async () =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          const result &lt;/span&gt;=&lt;span&gt; await axios(config);
          setData(result);
          setStatus(&lt;/span&gt;0&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
          setStatus(&lt;/span&gt;1&lt;span&gt;);
        }
        fetchData();
      };
    },
    watch &lt;/span&gt;?&lt;span&gt; [...watch] : []
  );

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; { data, status };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们整体上知道了useState useEffect怎么使用了，我们来自己实现一个简易的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现useState&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; useState(initVal) {
  let resultVal &lt;/span&gt;= val ||&lt;span&gt; initVal;
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setVal(newVal) {
    resultVal &lt;/span&gt;=&lt;span&gt; newVal;
    render();
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [resultVal, setVal]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实现useEffect&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; watchArr =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; useEffect(fn, watch) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hasWatchChange = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  hasWatchChange &lt;/span&gt;= watchArr &amp;amp;&amp;amp; watch.every((val, i) =&amp;gt; val ===&lt;span&gt; watchArr[i])
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hasWatchChange) {
    fn();
    watchArr &lt;/span&gt;=&lt;span&gt; watch;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hooks里面最常用的两个API就是useState与useEffect，现在是不是已经了解了呢，下面我们介绍一些其他API&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.useContext&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;作用：越级别获取组件内容&lt;/p&gt;
&lt;p&gt;类组件中我们也常用context，类组件实现方式&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;p&gt;　const AppContext = React.createContext('target');&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;class App extends React.Component {
  constructor(props) {
    super(props)
  }
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;AppContext.Provider value=&quot;dark&quot;&amp;gt;
        &amp;lt;Target /&amp;gt;
      &amp;lt;/AppContext.Provider&amp;gt;
&lt;span&gt;    );
  }
}

class Target extends React.Component {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过定义静态属性 contextType 来订阅&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有定义是获取不到的&lt;/span&gt;
  static contextType =&lt;span&gt; AppContext;
  render() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Hooks实现方式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const AppContext = React.createContext('target'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App() {
  useEffect(
    () &lt;/span&gt;=&amp;gt;&lt;span&gt; { },
    []
  );
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;AppContext.Provider value=&quot;dark&quot;&amp;gt;
    &amp;lt;Target /&amp;gt;
  &amp;lt;/AppContext.Provider&amp;gt;;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Target() {
  const value &lt;/span&gt;=&lt;span&gt; useContext(AppContext);
  console.log(value);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在需要订阅多个 context 的时候，就更能体现出useContext的优势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统的实现方式&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;CurrentUser.Consumer&amp;gt;&lt;span&gt;
    {
      user &lt;/span&gt;=&amp;gt; &amp;lt;Notifications.Consumer&amp;gt;&lt;span&gt;
        {notifications &lt;/span&gt;=&amp;gt;
          &amp;lt;header&amp;gt;&lt;span&gt;
            Welcome back, {user.name}&lt;/span&gt;!&lt;span&gt;
              You have {notifications.length} notifications.
          &lt;/span&gt;&amp;lt;/header&amp;gt;
&lt;span&gt;        }
      &lt;/span&gt;&amp;lt;/Notifications.Consumer&amp;gt;
&lt;span&gt;    }
  &lt;/span&gt;&amp;lt;/CurrentUser.Consumer&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;hooks实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App() {
  const user &lt;/span&gt;=&lt;span&gt; useContext(CurrentUser);
  const notifications &lt;/span&gt;=&lt;span&gt; useContext(Notifications);

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;header&amp;gt;&lt;span&gt;
      Welcome back, {user.name}&lt;/span&gt;!&lt;span&gt;
      You have {notifications.length} notifications.
    &lt;/span&gt;&amp;lt;/header&amp;gt;
&lt;span&gt;  );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是不是比传统的要简单的多&lt;/p&gt;
&lt;div readability=&quot;8.9268490923869&quot;&gt;
&lt;p&gt;&lt;strong&gt;4.useReducer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作用：复杂状态管理，跟redux本质上是一样的&lt;/p&gt;
&lt;div readability=&quot;10.908789386401&quot;&gt;
&lt;p&gt;函数式组件如果涉及到状态管理，我们需要借助redux，那么hooks需要吗，答案也是一样的，简单的状态管理我们可以通过useState来进行管理，如果比较复杂的状态管理呢，react hook给我们提供了方法 useReducer&lt;/p&gt;
&lt;div readability=&quot;16.352150537634&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; init(initialCount) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; { count: initialCount };
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; reducer(state, action) {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'increment'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; { count: state.count + 1&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'decrement'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; { count: state.count - 1&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'reset'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; init(action.payload);
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error();
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Counter({ initialCount }) {
  const [state, dispatch] &lt;/span&gt;=&lt;span&gt; useReducer(reducer, initialCount, init);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&amp;lt;&amp;gt;&lt;span&gt;
      Count: {state.count}
      &lt;/span&gt;&amp;lt;&lt;span&gt;button
        onClick&lt;/span&gt;={() =&amp;gt; dispatch({ type: 'reset', payload: initialCount })}&amp;gt;&lt;span&gt;
        Reset
      &lt;/span&gt;&amp;lt;/button&amp;gt;
      &amp;lt;button onClick={() =&amp;gt; dispatch({ type: 'increment' })}&amp;gt;+&amp;lt;/button&amp;gt;
      &amp;lt;button onClick={() =&amp;gt; dispatch({ type: 'decrement' })}&amp;gt;-&amp;lt;/button&amp;gt;
    &amp;lt;/&amp;gt;
&lt;span&gt;  );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5.useCallback&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作用：提升性能，缓存事件，减少没必要的渲染&lt;/p&gt;
&lt;p&gt;当我们使用类组件创建时，我们会怎么绑定事件呢&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class App extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;
      &amp;lt;p&amp;gt;{`hello~${name}`}&amp;lt;/p&amp;gt;
      &amp;lt;button onClick={() =&amp;gt; { console.log('click') }}&amp;gt;Click&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样写会导致什么结果呢，就是当渲染的时候react会认为每一次绑定的事件都是新的，从而从新进行计算&lt;/p&gt;
&lt;p&gt;改进如下&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class App extends React.Component {
  constructor(props) {
    super(props);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handleClick = &lt;span&gt;this&lt;/span&gt;.handleClick.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }
  handleClick() {
    console.log(&lt;/span&gt;'click'&lt;span&gt;)
  }
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;
      &amp;lt;p&amp;gt;{`hello~${name}`}&amp;lt;/p&amp;gt;
      &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.handleClick}&amp;gt;Click&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们讲触发函数绑定在this上，来缓存这个方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hooks&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App() {
  let [count, setCount] &lt;/span&gt;= useState(0&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;
    &amp;lt;button onClick={() =&amp;gt; setCount(1)} &amp;gt;&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样的问题这么写也是存在的，改进如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App() {
  let [count, setCount] &lt;/span&gt;= useState(0&lt;span&gt;);
  let handleSetCount &lt;/span&gt;= useCallback(() =&amp;gt;&lt;span&gt; {
    setCount(&lt;/span&gt;1&lt;span&gt;);
  })
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;
    &amp;lt;button onClick={handleSetCount} &amp;gt;&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们通过useCallback来缓存这个事件达到优化效果&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;6.useMemo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作用：提升性能，选择性的渲染变化组件&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App(target, target2) {
  const target &lt;/span&gt;= useMemo(() =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;Target /&amp;gt;
&lt;span&gt;  }, [target])
  const target2 &lt;/span&gt;= useMemo(() =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;Target2 /&amp;gt;
&lt;span&gt;  }, [target2])
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;&lt;span&gt;
    {target}
    {target2}
  &lt;/span&gt;&amp;lt;/div&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当target变化仅渲染Target组件，同理也作用与Target2组件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React.memo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作用：提升性能&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;如果想实现class中的shouldComponentUpdate方法呢 ，区别是它只能比较 props，不会比较 state：&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;12.100213219616&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
const App = React.mome((target, target2) =&amp;gt;&lt;span&gt; {
  const target &lt;/span&gt;= useMemo(() =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;Target /&amp;gt;
&lt;span&gt;  }, [target])
  const target2 &lt;/span&gt;= useMemo(() =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;Target2 /&amp;gt;
&lt;span&gt;  }, [target2])
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;&lt;span&gt;
    {target}
    {target2}
  &lt;/span&gt;&amp;lt;/div&amp;gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;7.useRef&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作用：获取dom依赖关系&lt;/p&gt;
&lt;p&gt;类组件实现方式&lt;/p&gt;
&lt;div readability=&quot;13.364599092284&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class App extends React.Component {
  constructor(props) {
    super(props);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.myRef =&lt;span&gt; React.createRef();
  }

  componentDidMount() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.myRef.current.focus();
  }

  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;input ref={&lt;span&gt;this&lt;/span&gt;.myRef} type=&quot;text&quot; /&amp;gt;;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hooks&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; App() {
  let [value, setValue] &lt;/span&gt;= useState(''&lt;span&gt;)
  const inputRef &lt;/span&gt;=&lt;span&gt; useRef();

  useEffect(
    () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    },
    [inputRef]
  )

  let handleSetValue &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
    setValue(e.target.value);
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;React.Fragment&amp;gt;
    &amp;lt;&lt;span&gt;input
      ref&lt;/span&gt;=&lt;span&gt;{inputRef}
      value&lt;/span&gt;=&lt;span&gt;{value}
      onChange&lt;/span&gt;=&lt;span&gt;{handleSetValue}
    &lt;/span&gt;&amp;gt;&amp;lt;/input&amp;gt;

  &amp;lt;/React.Fragment&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了hooks的基本使用方式就介绍完了，现在你对hook多少能了解了一些吧~&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/Dqhan/React&quot;&gt;https://github.com/Dqhan/React&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;



</description>
<pubDate>Tue, 17 Mar 2020 17:11:00 +0000</pubDate>
<dc:creator>漠然1992丶</dc:creator>
<og:description>此篇文章仅是对hooks入门的总结，老鸟略过吧~ React从16.8.X以后增加了一个新特性，react hooks 让我们看看这个新特性又带来了哪些惊喜呢~以下内容我们采取不同方式创建组件来进行对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/moran1992/p/12514899.html</dc:identifier>
</item>
<item>
<title>一文搞懂 Elasticsearch 之 Mapping - 武培轩</title>
<link>http://www.cnblogs.com/wupeixuan/p/12514843.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wupeixuan/p/12514843.html</guid>
<description>&lt;p&gt;作为 Elasticsearch 的“表结构定义”的 Mapping，你可能需要了解下！&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;272.07393597672&quot;&gt;
&lt;p&gt;这篇文章主要介绍 Mapping、Dynamic Mapping 以及 ElasticSearch 是如何自动判断字段的类型，同时介绍 Mapping 的相关参数设置。&lt;/p&gt;
&lt;p&gt;首先来看下什么是 Mapping：&lt;/p&gt;
&lt;h2 id=&quot;什么是-mapping&quot;&gt;什么是 Mapping？&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.tianheyu.top/archives/elasticsearch-term&quot;&gt;一篇文章带你搞定 ElasticSearch 术语&lt;/a&gt;中，我们讲到了 Mapping 类似于数据库中的表结构定义 &lt;code&gt;schema&lt;/code&gt;，它有以下几个作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;定义索引中的字段的名称&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定义字段的数据类型&lt;/strong&gt;，比如字符串、数字、布尔&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字段，倒排索引的相关配置&lt;/strong&gt;，比如设置某个字段为不被索引、记录 position 等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 ES 早期版本，一个索引下是可以有多个 Type 的，从 7.0 开始，一个索引只有一个 Type，也可以说一个 Type 有一个 Mapping 定义。&lt;/p&gt;
&lt;p&gt;在了解了什么是 Mapping 之后，接下来对 Mapping 的设置做下介绍：&lt;/p&gt;
&lt;h3 id=&quot;mapping-设置&quot;&gt;Mapping 设置&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;PUT users
{
    &quot;mappings&quot;: {
        &quot;_doc&quot;: {
            &quot;dynamic&quot;: false
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在创建一个索引的时候，可以对 &lt;code&gt;dynamic&lt;/code&gt; 进行设置，可以设成 &lt;code&gt;false&lt;/code&gt;、&lt;code&gt;true&lt;/code&gt; 或者 &lt;code&gt;strict&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200316224959884.png&quot; alt=&quot;Dynamic Mappings 设置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如一个新的文档，这个文档包含一个字段，当 Dynamic 设置为 &lt;code&gt;true&lt;/code&gt; 时，这个文档可以被索引进 ES，这个字段也可以被索引，也就是这个字段可以被搜索，Mapping 也同时被更新；当 dynamic 被设置为 &lt;code&gt;false&lt;/code&gt; 时候，存在新增字段的数据写入，该数据可以被索引，但是新增字段被丢弃；当设置成 &lt;code&gt;strict&lt;/code&gt; 模式时候，数据写入直接出错。&lt;/p&gt;
&lt;p&gt;另外还有 &lt;code&gt;index&lt;/code&gt; 参数，用来控制当前字段是否被索引，默认为 &lt;code&gt;true&lt;/code&gt;，如果设为 &lt;code&gt;false&lt;/code&gt;，则该字段不可被搜索。&lt;/p&gt;
&lt;p&gt;参数 &lt;code&gt;index_options&lt;/code&gt; 用于控制倒排索引记录的内容，有如下 4 种配置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;doc：只记录 &lt;code&gt;doc id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;freqs：记录 &lt;code&gt;doc id&lt;/code&gt; 和 &lt;code&gt;term frequencies&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;positions：记录 &lt;code&gt;doc id&lt;/code&gt;、&lt;code&gt;term frequencies&lt;/code&gt; 和 &lt;code&gt;term position&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;offsets：记录 &lt;code&gt;doc id&lt;/code&gt;、&lt;code&gt;term frequencies&lt;/code&gt;、&lt;code&gt;term position&lt;/code&gt; 和 &lt;code&gt;character offects&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，&lt;code&gt;text&lt;/code&gt; 类型默认配置为 &lt;code&gt;positions&lt;/code&gt;，其他类型默认为 &lt;code&gt;doc&lt;/code&gt;，记录内容越多，占用存储空间越大。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;null_value&lt;/code&gt; 主要是当字段遇到 &lt;code&gt;null&lt;/code&gt; 值时的处理策略，默认为 &lt;code&gt;NULL&lt;/code&gt;，即空值，此时 ES 会默认忽略该值，可以通过设定该值设定字段的默认值，另外只有 KeyWord 类型支持设定 &lt;code&gt;null_value&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;copy_to&lt;/code&gt; 作用是将该字段的值复制到目标字段，实现类似 &lt;code&gt;_all&lt;/code&gt; 的作用，它不会出现在 &lt;code&gt;_source&lt;/code&gt; 中，只用来搜索。&lt;/p&gt;
&lt;p&gt;除了上述介绍的参数，还有许多参数，大家感兴趣的可以在官方文档中进行查看。&lt;/p&gt;
&lt;p&gt;在学习了 Mapping 的设置之后，让我们来看下字段的数据类型有哪些吧！&lt;/p&gt;
&lt;h2 id=&quot;字段数据类型&quot;&gt;字段数据类型&lt;/h2&gt;
&lt;p&gt;ES 字段类型类似于 MySQL 中的字段类型，ES 字段类型主要有：核心类型、复杂类型、地理类型以及特殊类型，具体的数据类型如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200317003814117.png&quot; alt=&quot;字段数据类型&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;核心类型&quot;&gt;核心类型&lt;/h3&gt;
&lt;p&gt;从图中可以看出核心类型可以划分为字符串类型、数字类型、日期类型、布尔类型、基于 BASE64 的二进制类型、范围类型。&lt;/p&gt;
&lt;h4 id=&quot;字符串类型&quot;&gt;字符串类型&lt;/h4&gt;
&lt;p&gt;其中，在 ES 7.x 有两种字符串类型：&lt;code&gt;text&lt;/code&gt; 和 &lt;code&gt;keyword&lt;/code&gt;，在 ES 5.x 之后 &lt;code&gt;string&lt;/code&gt; 类型已经不再支持了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;text&lt;/code&gt; 类型适用于需要被全文检索的字段，例如新闻正文、邮件内容等比较长的文字，&lt;code&gt;text&lt;/code&gt; 类型会被 Lucene 分词器（Analyzer）处理为一个个词项，并使用 Lucene 倒排索引存储，&lt;strong&gt;text 字段不能被用于排序&lt;/strong&gt;，如果需要使用该类型的字段只需要在定义映射时指定 JSON 中对应字段的 &lt;code&gt;type&lt;/code&gt; 为 &lt;code&gt;text&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;keyword&lt;/code&gt; 适合简短、结构化字符串，例如主机名、姓名、商品名称等，&lt;strong&gt;可以用于过滤、排序、聚合检索，也可以用于精确查询&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;数字类型&quot;&gt;数字类型&lt;/h4&gt;
&lt;p&gt;数字类型分为 &lt;code&gt;long、integer、short、byte、double、float、half_float、scaled_float&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;数字类型的字段在满足需求的前提下应当尽量选择范围较小的数据类型，字段长度越短，搜索效率越高，对于浮点数，可以优先考虑使用 &lt;code&gt;scaled_float&lt;/code&gt; 类型，该类型可以通过缩放因子来精确浮点数，例如 12.34 可以转换为 1234 来存储。&lt;/p&gt;
&lt;h4 id=&quot;日期类型&quot;&gt;日期类型&lt;/h4&gt;
&lt;p&gt;在 ES 中日期可以为以下形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;格式化的日期字符串，例如 2020-03-17 00:00、2020/03/17&lt;/li&gt;
&lt;li&gt;时间戳（和 1970-01-01 00:00:00 UTC 的差值），单位毫秒或者秒&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;即使是格式化的日期字符串，ES 底层依然采用的是时间戳的形式存储。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;布尔类型&quot;&gt;布尔类型&lt;/h4&gt;
&lt;p&gt;JSON 文档中同样存在布尔类型，不过 JSON 字符串类型也可以被 ES 转换为布尔类型存储，前提是字符串的取值为 &lt;code&gt;true&lt;/code&gt; 或者 &lt;code&gt;false&lt;/code&gt;，布尔类型常用于检索中的过滤条件。&lt;/p&gt;
&lt;h4 id=&quot;二进制类型&quot;&gt;二进制类型&lt;/h4&gt;
&lt;p&gt;二进制类型 &lt;code&gt;binary&lt;/code&gt; 接受 BASE64 编码的字符串，默认 &lt;code&gt;store&lt;/code&gt; 属性为 &lt;code&gt;false&lt;/code&gt;，并且不可以被搜索。&lt;/p&gt;
&lt;h4 id=&quot;范围类型&quot;&gt;范围类型&lt;/h4&gt;
&lt;p&gt;范围类型可以用来表达一个数据的区间，可以分为5种：&lt;code&gt;integer_range、float_range、long_range、double_range&lt;/code&gt; 以及 &lt;code&gt;date_range&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;复杂类型&quot;&gt;复杂类型&lt;/h3&gt;
&lt;p&gt;复合类型主要有对象类型（object）和嵌套类型（nested）：&lt;/p&gt;
&lt;h4 id=&quot;对象类型&quot;&gt;对象类型&lt;/h4&gt;
&lt;p&gt;JSON 字符串允许嵌套对象，一个文档可以嵌套多个、多层对象。可以通过对象类型来存储二级文档，不过由于 Lucene 并没有内部对象的概念，ES 会将原 JSON 文档扁平化，例如文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;name&quot;: {
        &quot;first&quot;: &quot;wu&quot;,
        &quot;last&quot;: &quot;px&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上 ES 会将其转换为以下格式，并通过 Lucene 存储，即使 &lt;code&gt;name&lt;/code&gt; 是 &lt;code&gt;object&lt;/code&gt; 类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;name.first&quot;: &quot;wu&quot;,
    &quot;name.last&quot;: &quot;px&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;嵌套类型&quot;&gt;嵌套类型&lt;/h4&gt;
&lt;p&gt;嵌套类型可以看成是一个特殊的对象类型，可以让对象数组独立检索，例如文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;group&quot;: &quot;users&quot;,
  &quot;username&quot;: [
    { &quot;first&quot;: &quot;wu&quot;, &quot;last&quot;: &quot;px&quot;},
    { &quot;first&quot;: &quot;hu&quot;, &quot;last&quot;: &quot;xy&quot;},
    { &quot;first&quot;: &quot;wu&quot;, &quot;last&quot;: &quot;mx&quot;}
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;username&lt;/code&gt; 字段是一个 JSON 数组，并且每个数组对象都是一个 JSON 对象。如果将 &lt;code&gt;username&lt;/code&gt; 设置为对象类型，那么 ES 会将其转换为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;group&quot;: &quot;users&quot;,
  &quot;username.first&quot;: [&quot;wu&quot;, &quot;hu&quot;, &quot;wu&quot;],
  &quot;username.last&quot;: [&quot;px&quot;, &quot;xy&quot;, &quot;mx&quot;]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出转换后的 JSON 文档中 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;last&lt;/code&gt; 的关联丢失了，如果尝试搜索 &lt;code&gt;first&lt;/code&gt; 为 &lt;code&gt;wu&lt;/code&gt;，&lt;code&gt;last&lt;/code&gt; 为 &lt;code&gt;xy&lt;/code&gt; 的文档，那么成功会检索出上述文档，但是 &lt;code&gt;wu&lt;/code&gt; 和 &lt;code&gt;xy&lt;/code&gt; 在原 JSON 文档中并不属于同一个 JSON 对象，应当是不匹配的，即检索不出任何结果。&lt;/p&gt;
&lt;p&gt;嵌套类型就是为了解决这种问题的，嵌套类型将数组中的每个 JSON 对象作为独立的隐藏文档来存储，每个嵌套的对象都能够独立地被搜索，所以上述案例中虽然表面上只有 1 个文档，但实际上是存储了 4 个文档。&lt;/p&gt;
&lt;h3 id=&quot;地理类型&quot;&gt;地理类型&lt;/h3&gt;
&lt;p&gt;地理类型字段分为两种：经纬度类型和地理区域类型：&lt;/p&gt;
&lt;h4 id=&quot;经纬度类型&quot;&gt;经纬度类型&lt;/h4&gt;
&lt;p&gt;经纬度类型字段（geo_point）可以存储经纬度相关信息，通过地理类型的字段，可以用来实现诸如查找在指定地理区域内相关的文档、根据距离排序、根据地理位置修改评分规则等需求。&lt;/p&gt;
&lt;h4 id=&quot;地理区域类型&quot;&gt;地理区域类型&lt;/h4&gt;
&lt;p&gt;经纬度类型可以表达一个点，而 &lt;code&gt;geo_shape&lt;/code&gt; 类型可以表达一块地理区域，区域的形状可以是任意多边形，也可以是点、线、面、多点、多线、多面等几何类型。&lt;/p&gt;
&lt;h3 id=&quot;特殊类型&quot;&gt;特殊类型&lt;/h3&gt;
&lt;p&gt;特殊类型包括 IP 类型、过滤器类型、Join 类型、别名类型等，在这里简单介绍下 IP 类型和 Join 类型，其他特殊类型可以查看官方文档。&lt;/p&gt;
&lt;h4 id=&quot;ip-类型&quot;&gt;IP 类型&lt;/h4&gt;
&lt;p&gt;IP 类型的字段可以用来存储 IPv4 或者 IPv6 地址，如果需要存储 IP 类型的字段，需要手动定义映射：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;my_ip&quot;: {
        &quot;type&quot;: &quot;ip&quot;
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;join-类型&quot;&gt;Join 类型&lt;/h4&gt;
&lt;p&gt;Join 类型是 ES 6.x 引入的类型，以取代淘汰的 &lt;code&gt;_parent&lt;/code&gt; 元字段，用来实现文档的一对一、一对多的关系，主要用来做父子查询。&lt;/p&gt;
&lt;p&gt;Join 类型的 Mapping 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PUT my_index
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;my_join_field&quot;: { 
        &quot;type&quot;: &quot;join&quot;,
        &quot;relations&quot;: {
          &quot;question&quot;: &quot;answer&quot; 
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;my_join_field&lt;/code&gt; 为 Join 类型字段的名称；&lt;code&gt;relations&lt;/code&gt; 指定关系：&lt;code&gt;question&lt;/code&gt; 是 &lt;code&gt;answer&lt;/code&gt; 的父类。&lt;/p&gt;
&lt;p&gt;例如定义一个 ID 为 1 的父文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PUT my_join_index/1?refresh
{
  &quot;text&quot;: &quot;This is a question&quot;,
  &quot;my_join_field&quot;: &quot;question&quot; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来定义一个子文档，该文档指定了父文档 ID 为 1：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PUT my_join_index/_doc/2?routing=1&amp;amp;refresh 
{
  &quot;text&quot;: &quot;This is an answer&quot;,
  &quot;my_join_field&quot;: {
    &quot;name&quot;: &quot;answer&quot;, 
    &quot;parent&quot;: &quot;1&quot; 
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再了解完字段数据类型后，再让我们看下什么是 Dynamic Mapping？&lt;/p&gt;
&lt;h2 id=&quot;什么是-dynamic-mapping&quot;&gt;什么是 Dynamic Mapping？&lt;/h2&gt;
&lt;p&gt;Dynamic Mapping 机制使我们不需要手动定义 Mapping，ES 会&lt;strong&gt;自动根据文档信息来判断字段合适的类型&lt;/strong&gt;，但是有时候也会推算的不对，比如地理位置信息有可能会判断为 &lt;code&gt;Text&lt;/code&gt;，当类型如果设置不对时，会导致一些功能无法正常工作，比如 Range 查询。&lt;/p&gt;
&lt;h3 id=&quot;类型自动识别&quot;&gt;类型自动识别&lt;/h3&gt;
&lt;p&gt;ES 类型的自动识别是基于 JSON 的格式，如果输入的是 JSON 是字符串且格式为日期格式，ES 会自动设置成 &lt;code&gt;Date&lt;/code&gt; 类型；当输入的字符串是数字的时候，ES 默认会当成字符串来处理，可以通过设置来转换成合适的类型；如果输入的是 &lt;code&gt;Text&lt;/code&gt; 字段的时候，ES 会自动增加 &lt;code&gt;keyword&lt;/code&gt; 子字段，还有一些自动识别如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200316222833869.png&quot; alt=&quot;类型自动识别&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们通过一个例子是看看是怎么类型自动识别的，输入如下请求，创建索引：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PUT /mapping_test/_doc/1
{
  &quot;uid&quot;: &quot;123&quot;,
  &quot;username&quot;: &quot;wupx&quot;,
  &quot;birth&quot;: &quot;2020-03-16&quot;,
  &quot;married&quot;: false,
  &quot;age&quot;: 18,
  &quot;heigh&quot;: 180,
  &quot;tags&quot;: [
    &quot;java&quot;,
    &quot;boy&quot;
  ],
  &quot;money&quot;: 999.9
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用 &lt;code&gt;GET /mapping_test/_mapping&lt;/code&gt; 查看，结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200316231640595.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以从结果中看出，ES 会根据文档信息自动推算出合适的类型。&lt;/p&gt;
&lt;p&gt;哦豁，万一我想修改 Mapping 的字段类型，能否更改呢？让我们分以下两种情况来探究下：&lt;/p&gt;
&lt;h3 id=&quot;修改-mapping-字段类型&quot;&gt;修改 Mapping 字段类型？&lt;/h3&gt;
&lt;p&gt;如果是新增加的字段，根据 Dynamic 的设置分为以下三种状况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当 Dynamic 设置为 &lt;code&gt;true&lt;/code&gt; 时，一旦有新增字段的文档写入，Mapping 也同时被更新。&lt;/li&gt;
&lt;li&gt;当 Dynamic 设置为 &lt;code&gt;false&lt;/code&gt; 时，索引的 Mapping 是不会被更新的，新增字段的数据无法被索引，也就是无法被搜索，但是信息会出现在 &lt;code&gt;_source&lt;/code&gt; 中。&lt;/li&gt;
&lt;li&gt;当 Dynamic 设置为 &lt;code&gt;strict&lt;/code&gt; 时，文档写入会失败。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外一种是字段已经存在，这种情况下，ES 是不允许修改字段的类型的，因为 ES 是根据 Lucene 实现的倒排索引，一旦生成后就不允许修改，如果希望改变字段类型，必须使用 Reindex API 重建索引。&lt;/p&gt;
&lt;p&gt;不能修改的原因是如果修改了字段的数据类型，会导致已被索引的无法被搜索，但是如果是增加新的字段，就不会有这样的影响。&lt;/p&gt;

&lt;p&gt;本文主要介绍了 Mapping 和 Dynamic Mapping，同时对字段类型做了详细介绍，也介绍了在 ES 中是如何对字段类型做推算的，了解了 Mapping 的相关参数设置。&lt;/p&gt;
&lt;p&gt;在公众号【&lt;strong&gt;武培轩&lt;/strong&gt;】回复【&lt;strong&gt;es&lt;/strong&gt;】获取思维导图以及源代码。&lt;/p&gt;
&lt;blockquote readability=&quot;6.8963730569948&quot;&gt;
&lt;p&gt;参考文献&lt;/p&gt;
&lt;p&gt;《Elasticsearch技术解析与实战》&lt;/p&gt;
&lt;p&gt;Elastic Stack从入门到实践&lt;/p&gt;
&lt;p&gt;Elasticsearch核心技术与实战&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.1/mapping.html&quot; class=&quot;uri&quot;&gt;https://www.elastic.co/guide/en/elasticsearch/reference/7.1/mapping.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 17 Mar 2020 16:24:00 +0000</pubDate>
<dc:creator>武培轩</dc:creator>
<og:description>作为 Elasticsearch 的“表结构定义”的 Mapping，你可能需要了解下！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wupeixuan/p/12514843.html</dc:identifier>
</item>
<item>
<title>Unity 随机数与随机种子 - 汐夜</title>
<link>http://www.cnblogs.com/koshio0219/p/12514825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/koshio0219/p/12514825.html</guid>
<description>&lt;p&gt;随机数几乎应用于游戏开发的方方面面，例如，随机生成的地图，迷宫，怪物属性等，在Unity中，使用随机数非常方便：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Return a random integer number between min [inclusive] and max [exclusive] (Read
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Only).
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   min:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   max:&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Range(&lt;span&gt;int&lt;/span&gt; min, &lt;span&gt;int&lt;/span&gt; max);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Return a random float number between min [inclusive] and max [inclusive] (Read
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Only).
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   min:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   max:&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        [FreeFunction]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Range(&lt;span&gt;float&lt;/span&gt; min, &lt;span&gt;float&lt;/span&gt; max);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Returns a random number between 0.0 [inclusive] and 1.0 [inclusive] (Read Only).&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; value { &lt;span&gt;get&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正常情况下使用以上三种完全够用了，注意整型的随机是左开右闭的。当然了，你也可以使用System.Random中的方法来随机，可以构造出类似于Unity中的扩展方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Range(&lt;span&gt;this&lt;/span&gt; System.Random random, &lt;span&gt;int&lt;/span&gt; min, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; max)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; random.Next(min, max);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; Range(&lt;span&gt;this&lt;/span&gt; System.Random random, &lt;span&gt;float&lt;/span&gt; min, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; max)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; r =&lt;span&gt; random.NextDouble();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;float&lt;/span&gt;)(r * (max - min) +&lt;span&gt; min);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;值得注意的是，System.Random需要实例化才能随机，而UnityEngine.Random是直接使用。&lt;/p&gt;

&lt;p&gt;但很多时候，我们除了需要随机数之外，可能会有保留上次随机结果的需求，换句话说，从某一时刻起，我们希望每次都能随机出和上次相同的结果，这个时候就该随机种子出场了。&lt;/p&gt;
&lt;p&gt;举例来说，当玩家需要重新进入一次他以前随机出来过的一个迷宫地图进行二次创作，又比如，我们在开发过程中，某个随机单位出现了Bug，但如果下次又没法产生之前随机结果的话，那么就会出现十分头疼的状况了，这样很可能永远有个难以排查的潜在Bug一直在开发过程中而又难以再次复现。&lt;/p&gt;
&lt;p&gt;所以，强烈建议，&lt;strong&gt;只要是做相对比较复杂的随机行为，我们最好利用随机种子来执行随机&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然了，你说我将所有随机的数据结果序列化保存到本地，那也没问题，但相比随机种子只需要保存一个整型数据来说，哪种方式更可取显而易见。这样也可以大大减少游戏保存的数据容量。&lt;/p&gt;

&lt;p&gt;说了这么半天，什么是随机种子呢？&lt;/p&gt;
&lt;p&gt;顾名思义，一个种子对应着一个结果，随机种子对应的就是一个唯一的随机结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Initializes the random number generator state with a seed.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   seed:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Seed used to initialize the random number generator.&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         [NativeMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SetSeed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         [StaticAccessor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetScriptingRand()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StaticAccessorType.Dot)]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; InitState(&lt;span&gt;int&lt;/span&gt; seed);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的方法中，参数seed就是传入的随机种子，如果在脚本的一开始执行调用了此方法，那么只有当此次随机种子与上次的种子不相同时，才能随机出不同的随机结果，否则随机的结果总是一样的。&lt;/p&gt;
&lt;p&gt;注意，这里指的随机结果是指的&lt;strong&gt;所有的随机结果&lt;/strong&gt;，是一个随机数表，它从本质上改变的是整个UnityEngine.Random类的所有随机方法执行的结果，包括最开始列举的三种中的任意一种。&lt;/p&gt;
&lt;p&gt;下面做一个测试就很容易理解了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; UnityEngine;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RanTest : MonoBehaviour
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; bDebug;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.Random random;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;random = new System.Random((int)System.DateTime.Now.Ticks);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;string s = &quot;&quot;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for(int i = 0; i &amp;lt; 233; i++)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    s += random.Range(0, 10) + &quot;,&quot;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Debug.Log(s);&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; seed = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)System.DateTime.Now.Ticks;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (bDebug)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             seed = PlayerPrefs.GetInt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Seed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;   
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             PlayerPrefs.SetInt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Seed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)System.DateTime.Now.Ticks);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        Random.InitState(seed);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt; s = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;32&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             s += Random.Range(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        Debug.Log(s);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如我开了一个Debug模式，如果勾选，则随机种子是从上次保存的数据中读取，随机出来的结果永远是一样的，因为我并没有对保存的数据种子进行任何的更改。&lt;/p&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1725907/202003/1725907-20200317235328597-685080167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们发现每次的随机数都一样，因为它们都源于同一个随机种子，无论之后再随机多少次，结果都是这个随机数序列，这个种子对应的结果已经被计算机固定了，除非种子更改，不然随机结果不会变。&lt;/p&gt;
&lt;p&gt;当我关闭Debug模式时，正常的随机种子时刻都不会一样，这里用到了System.DateTime.Now.Ticks来保证得到和上次的种子绝不相同的整型，也可以使用guid等。&lt;/p&gt;
&lt;p&gt;每次在本地备份一次上一次随机种子的记录，以便随时可以再现上一次随机的结果，只需要轻松勾选Debug即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1725907/202003/1725907-20200318000451527-10713882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 例如，我在第三次时发现了随机产生的其他Bug，这样我只用启动Debug模式反复分析几遍后把复现的隐藏Bug修改结束后再回到正常模式产生新的随机数就好。&lt;/p&gt;

&lt;p&gt;另外，我们也可以利用System.Random类的构造方法来实现同样的随机效果，一个构造方法带有随机种子的参数，一个则没有，原理和上面是一样的：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;Random();&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Random(&lt;span&gt;int&lt;/span&gt; Seed);&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;这个时候改变的就是System.Random类的随机方法，而非UnityEngine.Random的随机方法。&lt;/p&gt;
&lt;p&gt;所以一开始就决定好整个开发过程中用的随机类也不容忽视，建议要么就全部用Unity中的，要么就全部用System中的，这样调整起来自然更得心应手事半功倍。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Mar 2020 16:20:00 +0000</pubDate>
<dc:creator>汐夜</dc:creator>
<og:description>随机数几乎应用于游戏开发的方方面面，例如，随机生成的地图，迷宫，怪物属性等，在Unity中，使用随机数非常方便： 1 // 2 // 摘要: 3 // Return a random integer</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/koshio0219/p/12514825.html</dc:identifier>
</item>
<item>
<title>【WPF学习】第五十九章 理解控件模板 - Peter.Luo</title>
<link>http://www.cnblogs.com/Peter-Luo/p/12513188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Peter-Luo/p/12513188.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;最近工作比较忙，未能及时更新内容，敬请了解！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　对于可视化树的分析引出了几个有趣问题。例如，控件如何从逻辑树表示扩张成可视化树表示？&lt;/p&gt;
&lt;p&gt;　　每个控件都有一个内置的方法，用于确定如何渲染控件（作为一组更基础的元素）。该方法称为控件模板(control template),是用XAML标记块定义的。&lt;/p&gt;
&lt;p&gt;　　下面是普通Button类的模板的简化版本。该版本省略了XML明朝空间声明、为嵌套的元素设置属性的特性，以及当按钮被禁用、取得焦点或单击时确定按钮行为的触发器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mwt:ButtonChrome &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Chrome&quot;&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ContentPresenter &lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding ContentControl.Content}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ... &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mwt:ButtonChrome&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    ...
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　尽管尚未研究ButtonChrome和ContentPresenter类，但很容易就能联想到：控件模板提供了在可视化树中看到的扩展内容。ButtonChrome类定义按钮的标准可视化外观，而ContentPresenter类存储了提供的所有内容。如果希望构建全新按钮，只需要创建新的控件模板。除ButtonChrome类之外，还使用其他一些内容——可能是自定义元素，也能使在前面介绍的某个绘制形状的元素。&lt;/p&gt;
&lt;p&gt;　　当按钮获得焦点、被单击以及被禁用时，触发器控制按钮如何进行变化。对于这些触发器，实际上没有什么特别需要介绍的内容。针对获取焦点和单击的触发器并不会修改按钮本身，只是修改为按钮提供可视化外观的ButtonChrome类的属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;UIElement.IsKeyboardFocused“&amp;gt;
    &amp;lt;Setter Property=&quot;&lt;/span&gt;&lt;span&gt;mwt:ButtonChrome.RenderDefaulted TargetName&lt;/span&gt;&lt;span&gt;=&quot;Chrome&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:Boolean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;True&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;s:Boolean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:Boolean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;True&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;s:Boolean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;UIElement.IsChecked“&amp;gt;
    &amp;lt;Setter Property=&quot;&lt;/span&gt;&lt;span&gt;mwt:ButtonChrome.RenderDefaulted TargetName&lt;/span&gt;&lt;span&gt;=&quot;Chrome&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:Boolean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;True&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;s:Boolean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:Boolean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;True&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;s:Boolean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一个触发器确保当按钮接受到焦点时，RenderDefaulted属性设置为true。第二个触发器确保当按钮被单击时,RenderDefaulted属性被设置为true。对于每种情况，ButtonChrome类都会相应地调整自身。由于发生的图形变化过于复杂，因此无法只通过几个属性设置器语句来表示这些变化。&lt;/p&gt;
&lt;p&gt;　　该例中的两个Setter对象都通过使用TargetName属性作用于控件模板的特定部分。只有当使用控件模板时，才恩能够使用这种技术。换句话说，不能编写样式触发器以使用TargetName属性访问ButtonChrome对象，因为名称Chrome超出了样式范围。这种技术只是模板提供的比单独使用样式功能更强大的方法之一。&lt;/p&gt;
&lt;p&gt;　　触发器未必需要使用TargetName属性。例如，针对IsEnabled属性的触发器仅调整按钮中任何文本内容的前景色。该触发器通过设置TextElement.Foreground附加属性就能工作，而未必借助于ButtonChrome类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;UIElement.IsEnabled&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;TextElement.Foreground&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SolidColorBrush&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;#FFADADAD&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;SolidColorBrush&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:Boolean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;False&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;s:Boolean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当构建自己的控件模板时将看到同样的职责分离。如果足够幸运，可直接使用触发器完成所有工作，可能不需要创建自己定义类并添加代码。另一方面，如果需啊哟提供更复杂的可视化设计，可能需要继承自定义的修饰类，ButtonChrome类本身不提供定制功能——该类专门用于渲染标准按钮的特定主题外观。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 一、修饰类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　ButtonChrome类是在Microsoft.Windows.Themes名称空间中定义的，在该名称空间中包含了一些较少的彼此相似的类，这些类用来渲染基本的Windows细节。除ButtonChrome外，这些类还包括BulletChrome（用于复选框和单选按钮）、ScrollChrome(用于滚动条)、ListBoxChrome以及SystemDropShadowChrome。这是最低级别的公有控件API。在少高级别上，会发现System.Windows.Controls.Primitives名称空间中包含大量可以独立使用的基本元素，但他们通常被封装到更有用的控件中。这些元素包括ScrollBar、ResizeGrip(用于改变窗口的尺寸)、Thumb(滚动条上的拖动按钮)、TickBar(滚动条上可选的刻度设置)等。在本质上，System.Windows.Controls.Primitives名称空间提供了可用在各种控件中的基本要素，本身的作用不大，而Microsoft.Windows.Themes名称空间包含了用于渲染这些细节的基本绘图逻辑。&lt;/p&gt;
&lt;p&gt;　　还有一点区别。与大多数WPF类型一样，System.Windows.Controls.Primitives名称空间中的类型都是在PresentationFramework.dll程序集中定义的。然而，Microsoft.Windows.Themes名称控件中的类型是在三个不同的程序集中定义的：PresentationFramework.Aero.dll、PresentationFramework.Luna.dll和PresentationFramework.Royale.dll。每个程序集都包含自己的ButtonChrome类(以及其他修饰类)版本，这些版本的渲染逻辑稍有不同。WPF使用那个程序集取决于操作系统和主题设置。&lt;/p&gt;
&lt;p&gt;　　尽管控件模板经常使用修饰类进行绘图，但并非总需要这样。例如，ResizeGrip元素(该元素用于在可以改变尺寸的窗口的右下角创建点网格)非常简单，它的模板可使用在前面介绍的绘图类，如Path、DrawingBrush以及LinearGradientBrush。下面是其使用的标记(有些复杂)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Type ResizeGrip}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding Panel.Background}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; SnapsToDevicePixels&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Path &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;0,0,2,2&quot;&lt;/span&gt;&lt;span&gt; Data&lt;/span&gt;&lt;span&gt;=&quot;M9,0L11,0 11,11 0,11 0,9 3,9 3,6 6,6 6,3 9,3z&quot;&lt;/span&gt;&lt;span&gt; HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Right&quot;&lt;/span&gt;&lt;span&gt; VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Bottom&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Path.Fill&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DrawingBrush &lt;/span&gt;&lt;span&gt;ViewboxUnits&lt;/span&gt;&lt;span&gt;=&quot;Absolute&quot;&lt;/span&gt;&lt;span&gt; TileMode&lt;/span&gt;&lt;span&gt;=&quot;Tile&quot;&lt;/span&gt;&lt;span&gt; Viewbox&lt;/span&gt;&lt;span&gt;=&quot;0,0,3,3&quot;&lt;/span&gt;&lt;span&gt; Viewport&lt;/span&gt;&lt;span&gt;=&quot;0,0,3,3&quot;&lt;/span&gt;&lt;span&gt; ViewportUnits&lt;/span&gt;&lt;span&gt;=&quot;Absolute&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DrawingBrush.Drawing&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DrawingGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DrawingGroup.Children&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing &lt;/span&gt;&lt;span&gt;Geometry&lt;/span&gt;&lt;span&gt;=&quot;M0,0L2,0 2,2 0,2z&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing.Brush&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearGradientBrush &lt;/span&gt;&lt;span&gt;EndPoint&lt;/span&gt;&lt;span&gt;=&quot;1,0.75&quot;&lt;/span&gt;&lt;span&gt; StartPoint&lt;/span&gt;&lt;span&gt;=&quot;0,0.25&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearGradientBrush.GradientStops&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GradientStop &lt;/span&gt;&lt;span&gt;offset&lt;/span&gt;&lt;span&gt;=&quot;0.3&quot;&lt;/span&gt;&lt;span&gt; Color&lt;/span&gt;&lt;span&gt;=&quot;#FFFFFFFF&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GradientStop &lt;/span&gt;&lt;span&gt;offset&lt;/span&gt;&lt;span&gt;=&quot;0.75&quot;&lt;/span&gt;&lt;span&gt; Color&lt;/span&gt;&lt;span&gt;=&quot;#FFBBC5D7&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GradientStop &lt;/span&gt;&lt;span&gt;offset&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Color&lt;/span&gt;&lt;span&gt;=&quot;#FF6D83A9&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                                             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearGradientBrush.GradientStops&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearGradientBrush&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing.Brush&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;GeometryDrawing&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DrawingGroup.Children&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DrawingGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DrawingBrush.Drawing&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DrawingBrush&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Path.Fill&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Path&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二、剖析控件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当创建控件模板时，新建的模板完全替代了原有的模板，这样可以得到更大的灵活性，但更复杂些。大多数情况下，在创建满足自己需要的模板之前，需要查看控件使用的标准模板。某些情况下，自定义的控件模板可镜像标准模板，并只进行很少的修改。&lt;/p&gt;
&lt;p&gt;　　WPF文档没有列出标准控件模板的XAML。然而， 可通过编程获取所需的信息。基本思想是从Tmeplate属性(该属性在Control类中定义)获取控件的模板，然后使用XamlWriter类，将该模板串行化到XAML文件中。下图显示了一个示例程序，该程序列出了所有WPF控件，并允许查看每个控件的模板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/263728/202003/263728-20200317231813001-1525985543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　构建该应用程序的诀窍是使用反射(reflection),反射是用于检查类型的.NET API。当第一次加载应用程序的住窗口时，扫描PresentationFramework.dll核心程序集(在该程序集中定义了控件类)中的所有类型，然后将这些类型添加到一个集合中，根据类型名称进行排序，此后将该集合绑定到一个列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Window_Loaded(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            Type controlType &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Control);
            List&lt;/span&gt;&amp;lt;Type&amp;gt; derivedTypes = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Type&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Search all the types in the assembly where the Control class is defined.&lt;/span&gt;
            Assembly assembly = Assembly.GetAssembly(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Control));
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (Type type &lt;span&gt;in&lt;/span&gt;&lt;span&gt; assembly.GetTypes())
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only add a type of the list if it's a Control, a concrete class, and public.&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (type.IsSubclassOf(controlType) &amp;amp;&amp;amp; !type.IsAbstract &amp;amp;&amp;amp;&lt;span&gt; type.IsPublic)
                {
                    derivedTypes.Add(type);
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Sort the types by type name.&lt;/span&gt;
            derivedTypes.Sort(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TypeComparer());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Show the list of types.&lt;/span&gt;
            lstType.ItemsSource =&lt;span&gt; derivedTypes;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　无论何时从列表中选择控件，相应的控件模板都会显示在右边的文本框中。完成这一步需要做更多的工作。第一个挑战是，在窗口中实际显示控件之前，控件的模板为空。通过使用反射，代码视图创建控件的一个实例，并将它添加到当前窗口中(但可将Visibility设置为Collapse，使控件不可见)。第二个挑战是，将现存的ControlTemplate对象转换为大家熟悉的XAML标记。XamlWriter.Save()静态方法负责完成该任务，但代码使用XamlWriter和XamlWriterSetting对象以确保Xaml缩进合理，便于阅读。所有这些代码都被封装在异常处理块中，异常处理块监视不能被创建或不能添加到Grid网格(如另一个Windows或Page)中的控件产生的问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; lstTypes_SelectionChanged(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, SelectionChangedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get the selected type.&lt;/span&gt;
                Type type =&lt;span&gt; (Type)lstType.SelectedItem;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instantiate the type.&lt;/span&gt;
                ConstructorInfo info =&lt;span&gt; type.GetConstructor(System.Type.EmptyTypes);
                Control control &lt;/span&gt;= (Control)info.Invoke(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

                Window win &lt;/span&gt;= control &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Window;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (win != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create the window (but keep it minimized).&lt;/span&gt;
                    win.WindowState =&lt;span&gt; System.Windows.WindowState.Minimized;
                    win.ShowInTaskbar &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    win.Show();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add it to the grid (but keep it hidden).&lt;/span&gt;
                    control.Visibility =&lt;span&gt; Visibility.Collapsed;
                    grid.Children.Add(control);
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get the template.&lt;/span&gt;
                ControlTemplate template =&lt;span&gt; control.Template;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get the XAML for the template.&lt;/span&gt;
                XmlWriterSettings settings = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlWriterSettings();
                settings.Indent &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
                XmlWriter writer &lt;/span&gt;=&lt;span&gt; XmlWriter.Create(sb, settings);
                System.Windows.Markup.XamlWriter.Save(template, writer);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Display the template.&lt;/span&gt;
                txtTemplate.Text =&lt;span&gt; sb.ToString();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remove the control from the grid.&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (win != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    win.Close();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    grid.Children.Remove(control);
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception err)
            {
                txtTemplate.Text &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;&amp;lt; Error generating template:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + err.Message + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;; ;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　扩展该应用程序，从而在文本框中编辑模板，使用XamlReader将模板转换回ControlTemplate对象，然后指定给某个控件并观察效果，这并不是很困难。然而，通过将模板放置到真实窗口中进行实际操作，测试和改进他们更加会容易。下一章节将介绍如何创建控件模板。&lt;/p&gt;
&lt;p&gt;　　本章涉及的程序可通过下面的链接进行下载：&lt;/p&gt;
&lt;p&gt; 　　&lt;a href=&quot;https://files.cnblogs.com/files/Peter-Luo/ControlTemplateBrowser.zip&quot; target=&quot;_blank&quot;&gt;ControlTemplateBrower.zip&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 17 Mar 2020 15:33:00 +0000</pubDate>
<dc:creator>Peter.Luo</dc:creator>
<og:description>最近工作比较忙，未能及时更新内容，敬请了解！！！ 对于可视化树的分析引出了几个有趣问题。例如，控件如何从逻辑树表示扩张成可视化树表示？ 每个控件都有一个内置的方法，用于确定如何渲染控件（作为一组更基础</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Peter-Luo/p/12513188.html</dc:identifier>
</item>
</channel>
</rss>