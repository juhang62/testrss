<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>29岁了还一事无成是人生的常态？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/10171951.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/10171951.html</guid>
<description>&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://upload-images.jianshu.io/upload_images/1179389-1adfef6226d8f55d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;文/沉默王二&lt;/p&gt;

&lt;h3 id=&quot;h1&quot;&gt;1.&lt;/h3&gt;
&lt;p&gt;又到了年底该总结的时候了，一年一年地过得真快。2018年，我29岁，这一年非要用一个词来形容的话，就是一无所成。&lt;/p&gt;
&lt;p&gt;我读书、写作、敲代码——2018年就这样过去了。这种略带伤感的语调，其实和2017年写总结的时候差别不大，唯一的差别可能是：今年比去年更老了。&lt;/p&gt;
&lt;p&gt;成功人士在写年终总结的时候，总能轻而易举地罗列出一大堆清单。比如说，“2018年我读了200本书”、“2018年，简书的粉丝暴涨了近十万”、“2018年，我坚持日更365天”、“2018年，我通过写作小赚30万”、“2018年，公司的交易额因为我暴涨60%”。&lt;/p&gt;
&lt;p&gt;我也想做成功人士，于是扛了一把铁锹，钻进脑壳，吭哧吭哧凿了半天——&lt;strong&gt;没有找到可列出的清单，只找到“平淡”两个字&lt;/strong&gt;——这也证明我肯定是不成功的。&lt;/p&gt;
&lt;p&gt;成功是什么？通常来说，金钱的多少是衡量成功与否的一般标准。我认识的绝大多数人（包括我自己在内）都过得辛辛苦苦，收入很一般，把“无产阶级”的帽子扣在我们的头顶是符合事实的。&lt;/p&gt;
&lt;h3 id=&quot;h2&quot;&gt;2.&lt;/h3&gt;
&lt;p&gt;小时候，我们的作文可能写过这方面的主题：“我是一个什么样的人？”长大了，与人交往的过程中，也不免要自我介绍。尤其找工作的时候，面试官免不了要问：“说说你的优缺点吧！”每次遇到这样的问题，我都胆战心惊，因为我知道这句话的弦外之音：“你到底几斤几两，心里还没个数？”&lt;/p&gt;
&lt;p&gt;有人会说，这是你不自信的表现。我不是没有自信过，写新年计划的时候我总是信心满满，可28年过去了，我离“期望中的自己”还是有很长的距离，跑上十年，也不一定能追赶得上。&lt;/p&gt;
&lt;p&gt;这么多年来，我一直过得很纠结，原因就是我和“期望中的自己”不一样。期望中的自己要月入十万，要拥有两到三套房产，还要“腹有诗书气自华”。&lt;/p&gt;
&lt;p&gt;一开始的时候，我把责任归咎于环境：“如果我是在北上广深，而不是在软件行业相对落后的四线城市洛阳，我现在就能成为‘期望中的自己’”。&lt;/p&gt;
&lt;p&gt;后来，我在博多舍费尔的《财务自由之路》中读到了一句话：“每个人获得的东西都恰好是他值得获得的东西。”这句话令我如梦初醒，原来挣钱多少，成功与否，都与环境无关。重要的是，你有没有正视你自己？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经过这么多年的摸爬滚打，我认清楚了自己，就是一个普普通通的程序员&lt;/strong&gt;。我并不比别人更优秀，也没有大多数人能吃苦，甚至比许多人的执行力都差。这些性格特点我早就隐隐约约地感觉到了，只是一直不愿意相信。&lt;/p&gt;
&lt;p&gt;但如果你认为我会把自己看得一文不值，那就完全搞错了。当我认清楚了自己之后，反而松了一口气，我不再刻意地强求自己了。&lt;/p&gt;
&lt;h3 id=&quot;h3&quot;&gt;3.&lt;/h3&gt;
&lt;p&gt;在读书方面，我把那些所谓的经典书籍束之高阁，只读自己喜欢的那一些。2018年，我读了大概30本书，我把其中印象最深刻的3本推荐给大家。&lt;/p&gt;
&lt;p&gt;A、《胡适文选》&lt;/p&gt;
&lt;p&gt;推荐原因：我们要力争做一个不受人惑的人，一个不被牵着鼻子走的人，那如何做到呢？&lt;strong&gt;首先，要学会怀疑，不轻易信任那些没有充分证据的东西；其次，我们要学会思考，对要解决的问题提出自己的解决办法，并进行实践验证；最后，要知道我们每个人都是独立的，要学会为自己而活，而不是他人&lt;/strong&gt;。这些，都是读《胡适文选》给我最大的启发。&lt;/p&gt;
&lt;p&gt;B、《匠人精神》&lt;/p&gt;
&lt;p&gt;推荐原因：什么是匠人精神？就是做人做事要认真执着，对工作和选定的内容，不敷衍，不放弃，一个一流的人，应该能专注在自己关心的领域，几十年如一日，追求极致完美，力求从每一个细节上改进、改善，并不断淬炼心性。&lt;/p&gt;
&lt;p&gt;这是一个追求速效、刺激的现代社会，绝大多数人都在追求急功近利。作为一个软件开发人员，我感受最深的就是客户永远都在强调一个观念，这业务很简单，大家加把油，一个星期、一个月就能完成。如果我们能在高速发展地社会里，慢下来做好一件事情，会不会更好呢？&lt;/p&gt;
&lt;p&gt;C：《Java编程思想》&lt;/p&gt;
&lt;p&gt;推荐原因：作为一名正儿八经的程序员，技术书籍是必须要读的。本书作为Java编程方面的经典书籍，赢得了全球程序员的广泛赞誉。这本书把Java当中晦涩难懂的概念讲解得非常清楚，尽管它并没有脱离技术图书“枯燥乏味”的怪圈。&lt;/p&gt;
&lt;h3 id=&quot;h4&quot;&gt;4.&lt;/h3&gt;
&lt;p&gt;在写作方面，我不再去羡慕那些优秀写作者取得的斐然成绩，比如说，一篇文章的浏览量能够轻松破万；一篇文章能拿到两百块的稿费；一年的广告收入超过20万。因为如果长时间去关注这些遥不可及的成绩时，内心就会变得无比的焦虑，对写作就会产生怀疑。&lt;/p&gt;
&lt;p&gt;坚持原创很难，2018年我大概写了60篇文章，有15万字左右，每周写一到两篇。&lt;/p&gt;
&lt;p&gt;这些文字都很平淡，就像我的生活一样。我知道，如果一直这样写下去的话，永远也不可能得到提高。于是，我报了无戒的收费的写作训练课，收获还不错。&lt;/p&gt;
&lt;p&gt;为了更好的输出，输入也必须跟得上，于是我花了199元订阅了《薛兆丰的经济学课》。截止到目前，我只学习了大概二十多节课，但已经大大的改观了我对这个世界的看法。&lt;/p&gt;
&lt;p&gt;我记得最清楚的几个概念是：&lt;/p&gt;
&lt;p&gt;1、经济学规律，不因人的理性与否而转移&lt;br/&gt;2、市场经济不会使人情淡薄&lt;br/&gt;3、竞争压力迫使人们减少不恰当的歧视&lt;br/&gt;4、现实中不可能做到机会平等&lt;br/&gt;5、强者越强的趋势不会永远继续下去&lt;/p&gt;
&lt;p&gt;平常我对现实社会的一些现象很不理解，但《薛兆丰的经济学课》给了我一个比较清晰的认知。而这正是写作引发的蝴蝶效应——为了写作而去读书，为了写作而去练习，为了写作而去求知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写作对于我来说，最重要的好处就在于，回顾以往，你会发现你曾经那样地生活过，一点都不空白&lt;/strong&gt;。有人说：“写作只是我活着的重要方式。我没有刻意追求成功，我在享受生命的过程。”我的写作心路，大概也是这样的。&lt;/p&gt;
&lt;h3 id=&quot;h5&quot;&gt;5.&lt;/h3&gt;
&lt;p&gt;2019年，我希望比今年好一点。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://upload-images.jianshu.io/upload_images/1179389-af5101caaa12d7c0.png?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 23:20:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>又到了年底该总结的时候了，一年一年地过得真快。2018年，我29岁，这一年非要用一个词来形容的话，就是一无所成。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qing-gee/p/10171951.html</dc:identifier>
</item>
<item>
<title>[python] bluepy 一款python封装的BLE利器 - beautifulzzzz</title>
<link>http://www.cnblogs.com/zjutlitao/p/10171913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjutlitao/p/10171913.html</guid>
<description>&lt;h4 id=&quot;bluepy-简介&quot;&gt;1、bluepy 简介&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;bluepy&lt;/strong&gt; 是github上一个很好的蓝牙开源项目，其地址在 &lt;a href=&quot;https://github.com/IanHarvey/bluepy&quot;&gt;&lt;strong&gt;LINK-1&lt;/strong&gt;&lt;/a&gt;， 其主要功能是用python实现linux上BLE的接口。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;This is a project to provide an API to allow access to Bluetooth Low Energy devices from Python. At present it runs on Linux only; I've mostly developed it using a Raspberry Pi, but it will also run on x86 Debian Linux.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;支持python版本：The code is tested on &lt;strong&gt;Python 2.7&lt;/strong&gt; and &lt;strong&gt;3.4&lt;/strong&gt;; it should also work on 3.3.&lt;/p&gt;

&lt;h4 id=&quot;安装&quot;&gt;2、安装&lt;/h4&gt;
&lt;p&gt;直接源码安装，python3加持：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo apt-get install git build-essential libglib2.0-dev
git clone https://github.com/IanHarvey/bluepy.git
cd bluepy
python3 setup.py build
sudo python3 setup.py install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;不要用python2，这辈子都不会用python2!&lt;br/&gt;&lt;strong&gt;注：&lt;/strong&gt;进行到这一步突然惊醒我的台式机无蓝牙，遂开启我的无屏幕树莓派，用命令找其ip，并用ssh登录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  Downloads  sudo nmap -sS -p 22 192.168.31.0/24 | grep -B 5 -A 0 &quot;Pi&quot;
Nmap scan report for 192.168.31.51
Host is up (0.19s latency).

PORT   STATE SERVICE
22/tcp open  ssh
MAC Address: B8:27:EB:71:33:AE (Raspberry Pi Foundation)

➜  Downloads  ssh pi@192.168.31.51
pi@192.168.31.51's password: 1234&lt;/code&gt;
&lt;/pre&gt;

&lt;h4 id=&quot;看文档玩demo&quot;&gt;3、看文档，玩DEMO&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;bluepy&lt;/strong&gt; 的文档地址 &lt;a href=&quot;http://ianharvey.github.io/bluepy-doc/&quot;&gt;&lt;strong&gt;LINK-2&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;在bluepy中新建一个examples文件夹，用来存放接下来我们的测试DEMO：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 scan devices demo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里第一个DEMO是BLE设备扫描，这里用到了Scanner对象，该对象可以用来搜索BLE设备的广播包数据。在大多数情况下该对象将会扫描出周围所有可连接设备。&lt;/p&gt;
&lt;p&gt;下面是我改造为python3的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  examples git:(master) ✗ cat scan.py 
#!/usr/bin/env python
# coding=utf-8

from bluepy.btle import Scanner, DefaultDelegate

class ScanDelegate(DefaultDelegate):
    def __init__(self):
        DefaultDelegate.__init__(self)

    def handleDiscovery(self, dev, isNewDev, isNewData):
        if isNewDev:
            print(&quot;Discovered device&quot;, dev.addr)
        elif isNewData:
            print(&quot;Received new data from&quot;, dev.addr)

scanner = Scanner().withDelegate(ScanDelegate())
devices = scanner.scan(10.0)

for dev in devices:
    print(&quot;Device %s (%s), RSSI=%d dB&quot; % (dev.addr, dev.addrType, dev.rssi))
    for (adtype, desc, value) in dev.getScanData():
        print(&quot;  %s = %s&quot; % (desc, value))&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;其中&lt;code&gt;Scanner([index=0])&lt;/code&gt;用于产生并初始化一个新的scanner对象，index 用来指名哪一个蓝牙设备就会被用（默认0表示使用/dev/hci0）。扫描知道调用start或scan函数之后才会开始；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;其中&lt;code&gt;withDelegate(delegate)&lt;/code&gt;存储对委托对象的引用，委托对象在接收来自设备的广播时接收回调。有关详细信息，请参阅DefaultDelegate的文档；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;其中&lt;code&gt;scan([timeout = 10])&lt;/code&gt;开始扫描并带有超时，在此扫描期间扫描到的设备会触发Delegate的回调函数，我们可以在其回调函数中实时获取并打印。当超时后会返回一个设备列表；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/0c/8891f957bbf2e03a57f7b605cedc6f.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;注意用sudo运行，更详细的接口见 &lt;a href=&quot;http://ianharvey.github.io/bluepy-doc/scanner.html#sample-code&quot;&gt;&lt;strong&gt;LINK-3&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;3.2 get services&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bluepy&lt;/strong&gt; 的DEMO有点少，我又找了个专是DEMO的github项目：&lt;a href=&quot;https://github.com/rlangoy/bluepy_examples_nRF51822_mbed&quot;&gt;&lt;strong&gt;LINK-5&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将其中的&lt;code&gt;getServices.py&lt;/code&gt;改造下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  examples git:(master) ✗ cat get_setvices.py 
import sys
from bluepy.btle import UUID, Peripheral

if len(sys.argv) != 2:
  print(&quot;Fatal, must pass device address:&quot;, sys.argv[0], &quot;&amp;lt;device address=&quot;&quot;&amp;gt;&quot;)
  quit()

p = Peripheral(sys.argv[1],&quot;public&quot;)

services=p.getServices()

#displays all services
for service in services:
   print(service)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.48876404494382&quot;&gt;&lt;li readability=&quot;1.943661971831&quot;&gt;
&lt;p&gt;其中&lt;code&gt;Peripheral(sys.argv[1],&quot;public&quot;)&lt;/code&gt;是用mac地址创建一个连接，由于我们上一步用scan搜索到的mac地址为public类型，因此这里第二个参数为&quot;public&quot;，更详细的介绍见 &lt;a href=&quot;https://ianharvey.github.io/bluepy-doc/peripheral.html&quot;&gt;&lt;strong&gt;LINK-6&lt;/strong&gt;&lt;/a&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;其中&lt;code&gt;getServices&lt;/code&gt;会返回所连接设备的服务；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/cb/1bccec083898d6643c1883a46265b3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;3.3 get characteristics&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同3.2获取characteristic的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  examples git:(master) ✗ cat get_characteristics.py 
import sys
from bluepy.btle import UUID, Peripheral

if len(sys.argv) != 2:
  print(&quot;Fatal, must pass device address:&quot;, sys.argv[0], &quot;&amp;lt;device address=&quot;&quot;&amp;gt;&quot;)
  quit()

p = Peripheral(sys.argv[1],&quot;public&quot;)

chList = p.getCharacteristics()
print(&quot;Handle   UUID                                Properties&quot;)
print(&quot;-------------------------------------------------------&quot;)                     
for ch in chList:
   print(&quot;  0x&quot;+ format(ch.getHandle(),'02X')  +&quot;   &quot;+str(ch.uuid) +&quot; &quot; + ch.propertiesToString())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/91/95a589e959b86ead3dfa915e61f011.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;3.4 get device name&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  examples git:(master) ✗ cat get_device_name.py 
import sys
from bluepy.btle import UUID, Peripheral
 
dev_name_uuid = UUID(0x2A00)
 
if len(sys.argv) != 2:
  print(&quot;Fatal, must pass device address:&quot;, sys.argv[0], &quot;&amp;lt;device address=&quot;&quot;&amp;gt;&quot;)
  quit()
 
p = Peripheral(sys.argv[1],&quot;public&quot;)
 
try:
    ch = p.getCharacteristics(uuid=dev_name_uuid)[0]
    if (ch.supportsRead()):
            print(ch.read())
 
finally:
    p.disconnect()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.beautifulzzzz.com:3000/?path=/ec/daa8603696c0fff2e52cb6472c6b0b.png&quot;/&gt;&lt;/p&gt;

&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;bluepy&lt;/strong&gt; 是非常棒的一款蓝牙BLE工具，掌握它会为你节省比较多的时间～&lt;/p&gt;

&lt;p&gt;: &lt;strong&gt;完～&lt;/strong&gt;&lt;br/&gt;: &lt;strong&gt;大家觉得不错，可以点推荐给更多人～&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;links&quot;&gt;LINKS&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/IanHarvey/bluepy&quot;&gt;[1]. bluepy GITHUB 链接地址&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://ianharvey.github.io/bluepy-doc/&quot;&gt;[2]. bluepy 的文档地址&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://ianharvey.github.io/bluepy-doc/scanner.html#sample-code&quot;&gt;[3]. Scanner Demo 地址&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.python.org/3/whatsnew/3.0.html&quot;&gt;[4]. python3和python2的print的区别&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/rlangoy/bluepy_examples_nRF51822_mbed&quot;&gt;[5]. bluepy examples using nRF51822 width mbed&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://ianharvey.github.io/bluepy-doc/peripheral.html&quot;&gt;[6]. The Peripheral class&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;@beautifulzzzz
智能硬件、物联网，热爱技术，关注产品
博客：http://blog.beautifulzzzz.com
园友交流群：414948975&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 24 Dec 2018 19:28:00 +0000</pubDate>
<dc:creator>beautifulzzzz</dc:creator>
<og:description>1、bluepy 简介 bluepy 是github上一个很好的蓝牙开源项目，其地址在 [ LINK 1 ][ 1]， 其主要功能是用python实现linux上BLE的接口。 This is a p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjutlitao/p/10171913.html</dc:identifier>
</item>
<item>
<title>[学习笔记]编译sensetime发表的Single View Stereo Matching(SVS)遇到的问题 - RichardYao1995</title>
<link>http://www.cnblogs.com/RichardYao/p/10171504.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RichardYao/p/10171504.html</guid>
<description>&lt;p&gt;最近在研究用深度学习预测图像深度信息的方法，一开始用的是2017年CVPR上Godard大神的monodepth，代码在&lt;a href=&quot;https://github.com/mrharicot/monodepth&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。这篇文章介绍了利用双目的consistency训练网络以对单张图像进行深度估计，思路还是蛮有新意的。某天在必应上无意中发现了商汤(sensetime)的Yue Luo同学发表在2018年CVPR上的一篇文章Single View Stereo Matching，&lt;a href=&quot;https://github.com/lawy623/SVS&quot; target=&quot;_blank&quot;&gt;代码&lt;/a&gt;开源了，因此fork一下clone下来跑一跑，没想到按照readme跑第一步installation就遇到了几个问题，在网上都没有找到问题的解决办法，于是自己花了点时间解决了这些问题，特此记录，以示其他同学。&lt;/p&gt;
&lt;h2&gt;1.makefile.config缺失问题&lt;/h2&gt;
&lt;p&gt;原作者给了一个Makefile.config.example，各位同学如果要install的话记得把.example去掉，我们需要的是Makefile.config。&lt;/p&gt;
&lt;p&gt;里面的参数是否要取消注释讲的很清楚，我使用了cudnn，因此取消注释USE_CUDNN := 1。我的opencv版本是3.2.0，因此取消注释OPENCV_VERSION := 3。对于CUDA_ARCH，如果你的CUDA版本比较高，建议你删掉compute_20和compute_21这两行。然后就是一些引用库的路径，后面会说到。&lt;/p&gt;
&lt;h2&gt;2.缺少hdf5.h问题&lt;/h2&gt;
&lt;p&gt;首先安装hdf5，你需要在&lt;a href=&quot;https://www.hdfgroup.org/downloads/hdf5/source-code/&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;下载hdf5，然后解压编译安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ cd hdf5-1.10.3
$ mkdir build
$ cd build
$ cmake ..
$ sudo make
$ sudo make install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果遇到问题，我的&lt;a href=&quot;https://www.cnblogs.com/RichardYao/p/9900562.html&quot; target=&quot;_blank&quot;&gt;另一篇文章&lt;/a&gt;里介绍了如何解决hdf5的安装问题。&lt;/p&gt;
&lt;p&gt;安装好了hdf5之后，需要在Makefile.config里加入链接，以保证可以调用hdf5的库。对于我来说，我需要在这里加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
HDF5_DIRS :=/home/yao/Environment/hdf5-1.10.3/hdf5&lt;br/&gt;OpenCV_DIR :=/home/yao/Environment/opencv-3.2.0/build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我顺便加了一个OpenCV的路径，以防需要。同学们把前面的路径改成自己的路径即可。然后将下面的两行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include
LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include $(HDF5_DIRS)/include $(OpenCV_DIR)/include
LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib $(HDF5_DIRS)/lib $(OpenCV_DIR)/lib&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.cudnn版本的问题&lt;/h2&gt;
&lt;p&gt;make的时候发现了如下的问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;In file included from ./include/caffe/util/device_alternate.hpp:40:0,
                 from ./include/caffe/common.hpp:19,
                 from src/caffe/syncedmem.cpp:1:
./include/caffe/util/cudnn.hpp: In function ‘void caffe::cudnn::setConvolutionDesc(cudnnConvolutionStruct**, cudnnTensorDescriptor_t, cudnnFilterDescriptor_t, int, int, int, int)’:
./include/caffe/util/cudnn.hpp:112:3: error: too few arguments to function ‘cudnnStatus_t cudnnSetConvolution2dDescriptor(cudnnConvolutionDescriptor_t, int, int, int, int, int, int, cudnnConvolutionMode_t, cudnnDataType_t)’
   CUDNN_CHECK(cudnnSetConvolution2dDescriptor(*conv,
   ^
In file included from ./include/caffe/util/cudnn.hpp:5:0,
                 from ./include/caffe/util/device_alternate.hpp:40,
                 from ./include/caffe/common.hpp:19,
                 from src/caffe/syncedmem.cpp:1:
/usr/local/cuda/include/cudnn.h:537:27: note: declared here
 cudnnStatus_t CUDNNWINAPI cudnnSetConvolution2dDescriptor( cudnnConvolutionDescriptor_t convDesc,
                           ^
Makefile:579: recipe for target '.build_release/src/caffe/syncedmem.o' failed
make: *** [.build_release/src/caffe/syncedmem.o] Error 1
make: *** Waiting for unfinished jobs....&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在网上看了一下，是这份代码提供的cudnn版本太老，从别的caffe里比如caffe/include/caffe/util复制cudnn.hpp到SVS/caffe/include/caffe/util/目录下，即可解决。&lt;/p&gt;
&lt;h2&gt;4.src/caffe/util/util_img.cpp中caffe::BlobToGrayImage函数的问题&lt;/h2&gt;
&lt;p&gt;接下来的几步的问题都比较隐蔽，要在命令行的编译结果里仔细找才能看到。这一步的问题我在github的issue里也看到了，好几个人都在讨论怎么解决，大家没什么办法，作者似乎也不太清楚怎么回事，我自己研究了一下，解决了这个问题，还是比较有成就感的。&lt;/p&gt;
&lt;p&gt;这一步的主要问题如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;src/caffe/util/util_img.cpp: At global scope:
src/caffe/util/util_img.cpp:709:33: error: redeclaration of ‘template&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;Dtype&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; cv::Mat caffe::BlobToGrayImage(const caffe::Blob&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Dtype&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;*, int, int, Dtype)’ may not have default arguments [-fpermissive]
   const Dtype scale = Dtype(1.0)) {
                                 ^
Makefile:595: recipe for target '.build_release/src/caffe/util/util_img.o' failed
make: *** [.build_release/src/caffe/util/util_img.o] Error 1
make: *** Waiting for unfinished jobs....&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们找到这个cpp，打开移动到709行，发现函数定义如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
template &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;typename &lt;/span&gt;&lt;span&gt;Dtype&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
cv::Mat BlobToGrayImage(const Blob&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Dtype&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;* blob, 
            const int n, const int c,
            const Dtype scale = Dtype(1.0))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;报的错是对于Dtype(1.0)这个赋值，我们在函数里找一找scale这个变量，发现只用到了一处&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
v1 *= scale;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照原定义的1.0，这里相当于什么都没有做，为了解决这个问题，我们直接删掉初始化，将定义改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
template &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;typename &lt;/span&gt;&lt;span&gt;Dtype&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
cv::Mat BlobToGrayImage(const Blob&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Dtype&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;* blob, 
            const int n, const int c,
            const Dtype scale)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后将用到scale的句子屏蔽&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
//v1 *= scale;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即可解决此问题。&lt;/p&gt;
&lt;h2&gt;5.不支持compute_20的问题&lt;/h2&gt;
&lt;p&gt;问题显示如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NVCC src/caffe/solvers/nesterov_solver.cu
nvcc fatal   : Unsupported gpu architecture 'compute_20'
Makefile:608: recipe for target '.build_release/cuda/src/caffe/solvers/nesterov_solver.o' failed
make: *** [.build_release/cuda/src/caffe/solvers/nesterov_solver.o] Error 1
make: *** Waiting for unfinished jobs....&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个是因为你的cuda版本比较新，不支持compute_20，因此需要你删掉compute_20和compute_21这两行，即可解决。&lt;/p&gt;
&lt;h2&gt;6.gpumat.hpp缺失&lt;/h2&gt;
&lt;p&gt;这个问题比较少见，网上没有找到答案，甚至这个hpp文件官方都没有适合的，问题如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;In file included from src/caffe/layers/resample_layer.cu:11:0:
./include/thirdparty/gpu/gpu.hpp:52:35: fatal error: opencv2/core/gpumat.hpp: No such file or directory
compilation terminated.
Makefile:608: recipe for target '.build_release/cuda/src/caffe/layers/resample_layer.o' failed
make: *** [.build_release/cuda/src/caffe/layers/resample_layer.o] Error 1
make: *** Waiting for unfinished jobs...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是没有找到gpu_mat.hpp这个文件，我去OpenCV里找了找，有两个叫这个名字的文件，不过不是/opencv2/core/文件夹下的，试着在gpu.hpp里改一下头文件的引用位置，改成OpenCV里的那两个文件，都会报如下的错误&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
./include/thirdparty/gpu/gpu.hpp(161): error: identifier &quot;GpuMat&quot; is undefined
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明这两个头文件不是我们需要的，没办法，只能在网上找找了，果然找到了一个&lt;a href=&quot;https://github.com/stonier/opencv2/blob/master/modules/core/include/opencv2/core/gpumat.hpp&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;中有，大概看了一眼，貌似是因为OpenCV2中的文件，看来是OpenCV3改动比较大。于是我直接在/usr/local/include/opencv2/core文件夹里面创建了一个gpumat.hpp文件，然后把这个文件的内容复制进去即可，记得加sudo权限。&lt;/p&gt;
&lt;h2&gt;7.cuda_devptrs.hpp缺失&lt;/h2&gt;
&lt;p&gt;这个问题跟上面的问题一样，也需要一个新的hpp头文件，我们在网上找到了另一个&lt;a href=&quot;https://github.com/cinder/Cinder-OpenCV/blob/master/include/opencv2/core/cuda_devptrs.hpp&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;，相似的操作，同样的位置直接创建一个cuda_devptrs.hpp文件，然后复制进去。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;NVCC src/caffe/layers/resample_layer.cu
In file included from ./include/thirdparty/gpu/gpu.hpp:52:0,
                 from src/caffe/layers/resample_layer.cu:11:
/usr/local/include/opencv2/core/gpumat.hpp:49:41: fatal error: opencv2/core/cuda_devptrs.hpp: No such file or directory
compilation terminated.
Makefile:608: recipe for target '.build_release/cuda/src/caffe/layers/resample_layer.o' failed
make: *** [.build_release/cuda/src/caffe/layers/resample_layer.o] Error 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;8.vector没有声明std空间&lt;/h2&gt;
&lt;p&gt;不知道是不是作者粗心，gpu.hpp里调用了vector，却没有在前面加上std::或者在最前面声明using namespace std;结果产生如下错误&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
./include/thirdparty/gpu/gpu.hpp(432): error: vector is not a template
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;太多vector了，不可能一个个加，虽然我很不情愿，但我只能在最前面加一个using namespace std;了，希望作者下次用心，也不知道他是怎么调通的。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 16:18:00 +0000</pubDate>
<dc:creator>RichardYao1995</dc:creator>
<og:description>最近在研究用深度学习预测图像深度信息的方法，一开始用的是2017年CVPR上Godard大神的monodepth，代码在这里。这篇文章介绍了利用双目的consistency训练网络以对单张图像进行深度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/RichardYao/p/10171504.html</dc:identifier>
</item>
<item>
<title>使用VisualVM分析性能 - 冰魄秋雨</title>
<link>http://www.cnblogs.com/skyice/p/VisualVm.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyice/p/VisualVm.html</guid>
<description>&lt;p&gt;对于java虚拟机，像我这样工作才两年的会是比较陌生和神秘，但是时候，需要对JVM有一定的认识，并且能够设置一些参数。下面是自己学习到的内容。&lt;/p&gt;
&lt;p&gt;这里需要使用一个java自带的一个工具，VisualVM。使用IDEA下载一个VisualVM。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464717/201812/1464717-20181224231014473-1399412253.png&quot; alt=&quot;&quot; width=&quot;684&quot; height=&quot;428&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;一、查看程序的JVM内存&lt;/h2&gt;
&lt;p&gt;首先任务参数有不要设置，然后编写一个程序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class JavaHeapTest {
    public final static int OUTOFMEMORY = 200000000;
    
    private String oom;

    private int length;
    
    StringBuffer tempOOM = new StringBuffer();

    public JavaHeapTest(int leng) {
        this.length = leng;
       
        int i = 0;
        while (i &amp;lt; leng) {
            i++;
            try {
                tempOOM.append(&quot;a&quot;);
            } catch (OutOfMemoryError e) {
               e.printStackTrace();
               break;
            }
        }
        this.oom = tempOOM.toString();

    }

    public String getOom() {
        return oom;
    }

    public int getLength() {
        return length;
    }

    public static void main(String[] args) {
        JavaHeapTest javaHeapTest = new JavaHeapTest(OUTOFMEMORY);
        System.out.println(javaHeapTest.getOom().length());
    }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　然后使用VIsualVM运行程序。&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464717/201812/1464717-20181224231419954-96425794.png&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;455&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序运行起来，但是第一次需要设置VisualVM的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464717/201812/1464717-20181224231736562-1010467115.png&quot; alt=&quot;&quot; width=&quot;741&quot; height=&quot;410&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序运行起来后后堆的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464717/201812/1464717-20181224231956845-645303039.png&quot; alt=&quot;&quot; width=&quot;778&quot; height=&quot;494&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 上面的图是没有设置任何程序的事情下做的，为什么需要看堆的大小，因为堆存放对象的实例，一般都会需要设置该值，在没有做任何设置的时候，就会看到堆的内存可能达到1G的大小。有时候需要模拟线上环境的上的Java内存大小，在IDEA中设置下一年堆的大小，这里设置堆的初始化和最大值都一样，以避免每次垃圾回收完成后JVM重新分配内存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464717/201812/1464717-20181224232602412-772433751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464717/201812/1464717-20181224232632163-799967588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置之后运行程序，堆的内存变为设置的大小，但是这个时候有可能出现异常，在我的电脑上就出现 java.lang.OutOfMemoryError: Java heap space，该异常就是设置的堆内存太小导致，但是一般情况下不会出现该情况，因为上面的程序并不需要特别大的程序，可能是我的笔记本电脑的原因。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464717/201812/1464717-20181224232759332-806794569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面知道看堆的大小，接下来可以看一下堆中存储了什么。在程序运行的时候，需要快速点击堆dump，然后就看到如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464717/201812/1464717-20181224233358713-1085115329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;双击某个列表之后查看其中的内容，而存储最多的就是程序中设置的tempOOM参数，此时知道了堆中存储最大的内容是什么，如果是其他程序，某一个字段占用特多的内存，可能就是程序出现问题了，那么就需要对那个字段进行优化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464717/201812/1464717-20181224233604022-48431027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 二、查看程序的线程情况&lt;/h2&gt;
&lt;p&gt;接下来运行下面的程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class DeadLock {
    public static void main(String[] args) {
        Resource r1 = new Resource();
        Resource r0 = new Resource();

        Thread myTh1 = new LockThread1(r1, r0);
        Thread myTh0 = new LockThread0(r1, r0);

        myTh1.setName(&quot;DeadLock-1 &quot;);
        myTh0.setName(&quot;DeadLock-0 &quot;);

        myTh1.start();
        myTh0.start();
    }
}

    class Resource {
        private int i;
    
        public int getI() {
            return i;
        }
    
        public void setI(int i) {
            this.i = i;
        }
        
    }

    class LockThread1 extends Thread {
        private Resource r1, r2;
    
        public LockThread1(Resource r1, Resource r2) {
            this.r1 = r1;
            this.r2 = r2;
        }
    
        @Override
        public void run() {
            int j = 0;
            while (true) {
                synchronized (r1) {
                    System.out.println(&quot;The first thread got r1's lock &quot; + j);
                    synchronized (r2) {
                        System.out.println(&quot;The first thread got r2's lock  &quot; + j);
                    }
                }
                j++;
            }
        }
    
    }

    class LockThread0 extends Thread {
        private Resource r1, r2;
    
        public LockThread0(Resource r1, Resource r2) {
            this.r1 = r1;
            this.r2 = r2;
        }
    
        @Override
        public void run() {
            int j = 0;
            while (true) {
                synchronized (r2) {
                    System.out.println(&quot;The second thread got r2's lock  &quot; + j);
                    synchronized (r1) {
                        System.out.println(&quot;The second thread got r1's lock&quot; + j);
                    }
                }
                j++;
            }
        }
    
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　程序运行之后，查看线程标签后直接告警出现了死锁的线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464717/201812/1464717-20181224234322255-112371176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的程序可以看到蓝色部分为线程正常运行，黄色为等待。&lt;/p&gt;

&lt;p&gt;三、使用VisualGC来查看年轻代，老年代的堆内存的GC情况，如果是频繁的GC,那么可能就是内存不足，就需要增加堆内存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1464717/201812/1464717-20181224235105952-2045265347.png&quot; alt=&quot;&quot; width=&quot;791&quot; height=&quot;387&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的图大部分的GC都是在Eden区，即对象都是朝生暮死的，并且发生了GC time收集到0条GC,那么就是该程序一直运行可以（这里程序运行时间很短，在长时间观察，可以得到更多的信息，如果是将堆内存设置很小的时候，那么就会经常发生GC的情况）&lt;/p&gt;

&lt;p&gt;JVM调优，需要变设置参数，边进行观察，这样更容易理解其中缘由，可以上手试一试。&lt;/p&gt;

</description>
<pubDate>Mon, 24 Dec 2018 15:57:00 +0000</pubDate>
<dc:creator>冰魄秋雨</dc:creator>
<og:description>对于java虚拟机，像我这样工作才两年的会是比较陌生和神秘，但是时候，需要对JVM有一定的认识，并且能够设置一些参数。下面是自己学习到的内容。 这里需要使用一个java自带的一个工具，VisualVM</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyice/p/VisualVm.html</dc:identifier>
</item>
<item>
<title>AnnotationTransactionAttributeSource is only available on Java 1.5 and higher - 灰色遗忘</title>
<link>http://www.cnblogs.com/caihongmin/p/10171740.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caihongmin/p/10171740.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在eclipse中用到spring2.0的web项目，启动elipse自带的tomcat7，tomcat7报错如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;AnnotationTransactionAttributeSource is only available on Java 1.5 and higher
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;出错原因：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　因为spring core org.springframework.core.JdkVersion.java不支持Jdk1.8。支持的Jdk版本分别为1.3(default)，1.4, 1.5, 1.6 and 1.7，如果检测到Tomcat配置的不是1.4, 1.5,　1.6， 1.7，那么就认为是1.3，所以会报这个错。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　解决方法是将Jdk1.8降到1.7，或者升级spring版本，使其支持Jdk1.8。&lt;/p&gt;
&lt;p&gt;　　我尝试将Jdk1.8降到1.7，亲测可行，但要注意几个地方都要改。(仅作用于elipse，其他IDE大体思路雷同)&lt;/p&gt;
&lt;p&gt;　　1、右键该项目-&amp;gt;Build Pah-&amp;gt;Configure Build Path-&amp;gt;java Build Path-&amp;gt;选中当前jdk点击编辑(具体如下图)&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1560517/201812/1560517-20181224232810751-129174358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2、点击alternate JRE-&amp;gt;选择jdk1.7（具体如下图）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1560517/201812/1560517-20181224233122277-1858385712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3.去修改该项目所在ecipse工作空间中的 &lt;strong&gt;.setting 文件夹下的org.eclipse.wst.common.project.facet.core.xml中的&amp;lt;installed facet=&quot;java&quot; &lt;span&gt;version=&quot;1.7&quot;&lt;/span&gt;/&amp;gt;，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　否则其自带的Tomcat7将会报&lt;span&gt;Project facet Java version 1.8 is not supported错误。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;p.s.　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　因为eclipse的使用需要读取JAVA_HOME环境变量，较新的要求是jdk1.8y以上，否则还打不开呢。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　当我们项目需要用到低版本的jdk，重复上文的1步骤，然后再添加低版本jdk安装位置。(具体如下图)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1560517/201812/1560517-20181224234554512-570707208.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1560517/201812/1560517-20181224234752413-1432121963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;　&lt;span&gt;&lt;strong&gt;最后选择你的其他jdk版本即可。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;






</description>
<pubDate>Mon, 24 Dec 2018 15:53:00 +0000</pubDate>
<dc:creator>灰色遗忘</dc:creator>
<og:description>前言： 在eclipse中用到spring2.0的web项目，启动elipse自带的tomcat7，tomcat7报错如下： 出错原因： 因为spring core org.springframewo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caihongmin/p/10171740.html</dc:identifier>
</item>
<item>
<title>输入与输出（初学者） - 巫师笔记</title>
<link>http://www.cnblogs.com/lvfengkun/p/10171743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvfengkun/p/10171743.html</guid>
<description>&lt;p&gt;1、数据输入与输出&lt;/p&gt;
&lt;p&gt;（1）所谓输入与输出是以计算机为主题而言的。&lt;/p&gt;
&lt;p&gt;（2）本博客介绍的是向标准输出设备显示器输出数据的语句。&lt;/p&gt;
&lt;p&gt;（3）在C语言中，所有数据输入输出都是由库函数完成，因此都是函数语句。&lt;/p&gt;
&lt;p&gt;（4）在使用C语言库函数时，要用预编译命令#include将有关“头文件”包括到源文件中。使用标准输入输出库函数时要用到&quot;stdio.h&quot;文件，因此源文件开头应有以下预编译命令：&lt;/p&gt;
&lt;p&gt;#include&amp;lt;stdio.h&amp;gt;或#include&quot;stdio.h&quot;&lt;/p&gt;
&lt;p&gt;stdio是standand input&amp;amp;output的意思。&lt;/p&gt;
&lt;p&gt;（5）考虑到printf和scanf函数使用频繁，系统允许在使用这两个函数时可不加#include&amp;lt;stdio.h&amp;gt;&lt;/p&gt;
&lt;p&gt;2、字符数据的输入输出&lt;/p&gt;
&lt;p&gt;（1）putchar函数（字符输出函数）：putchar函数是字符输出函数，其功能是在显示器上输出单个字符。其一般形式为：putchar(字符变量）&lt;/p&gt;
&lt;p&gt;例如：putchar('A');     //输出大写字母A&lt;/p&gt;
&lt;p&gt;           putchar(x);       //输出字符变量x的值&lt;/p&gt;
&lt;p&gt;           putchar('\101')  //也是输出字符A，注：101为八进制&lt;/p&gt;
&lt;p&gt;           putchar('\n')      //换行&lt;/p&gt;
&lt;p&gt;注：（1）对控制字符则执行控制功能，不在屏幕上显示。&lt;/p&gt;
&lt;p&gt;（2）使用本函数前必须要用文件包含命令：#include&amp;lt;stdio.h&amp;gt;&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; a=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,b=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,c=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    putchar(a);putchar(b);putchar(b);putchar(c);putchar(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);putchar(a);putchar(b);
    putchar(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    putchar(b);putchar(c);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）getchar函数（键盘输入函数）：getchar函数的功能是从键盘上输入一个字符。其一般形式为：getchar();通常把输入的字符赋予一个字符变量，构成赋值语句，如：cahr C；C=getchar();&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; C;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input a character\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    C&lt;/span&gt;=&lt;span&gt;getchar();
    putchar(C);
    putchar(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、格式输入与输出：printf函数（格式输出函数）：printf函数称为格式输出函数，其最末一个字母f即为”格式“（format)之意。其功能是按用户指定的格式，把指定的数据显示到显示器的屏幕上。&lt;/p&gt;
&lt;p&gt;（1）print函数调用的一般形式：printf函数是一个标准库函数，它的函数原型在头文件”stdio.h&quot;中。但作为一个特例，不要求在使用printf函数之前必须包含stdio.h文件。&lt;/p&gt;
&lt;p&gt;printf函数调用的一般形式为：printf（“格式控制字符串”，输出列表）其中格式控制字符串用于指定输出格式。格式控制字符串可由格式字符串和非格式字符串两种组成。格式字符串是以%开头的字符串，在%后面跟有各种格式字符，以说明输出数据的类型、形式、长度、小数、位数等。常见的有：&lt;/p&gt;
&lt;p&gt;%d:十进制整数&lt;/p&gt;
&lt;p&gt;%x十六进制整数&lt;/p&gt;
&lt;p&gt;%o八进制整数&lt;/p&gt;
&lt;div readability=&quot;13.5&quot;&gt;%u无符号十进制整数
&lt;p&gt;%c一个字符&lt;/p&gt;
&lt;p&gt;%s字符串&lt;/p&gt;
&lt;p&gt;%e浮点数（指数形式，有称科学记数法）&lt;/p&gt;
&lt;div readability=&quot;23.5&quot;&gt;%f浮点数（小数形式），有六位小数部分
&lt;p&gt;%ld十进制长整型数&lt;/p&gt;
&lt;p&gt;%lf双精度浮点数（小数形式），取到小数点后20位&lt;/p&gt;
&lt;p&gt;%%百分号本身&lt;/p&gt;
&lt;p&gt;非格式字符串在输出时原样打印，在显示中其提示作用。&lt;/p&gt;
&lt;p&gt;输出列表中输出了各个输出项，要求格式字符串和个输出项在数量和类型上一一对应。&lt;/p&gt;
&lt;div readability=&quot;52.5&quot;&gt;例：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a=&lt;span&gt;88&lt;/span&gt;,b=&lt;span&gt;89&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a,b);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a,b);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c,%c\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a,b);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a=%d,b=%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a,b);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）标志：&lt;span&gt;&lt;span&gt;　标志字符为&lt;span&gt;-&lt;span&gt;&lt;span&gt;、&lt;span&gt;+&lt;span&gt;&lt;span&gt;、&lt;span&gt;#&lt;span&gt;&lt;span&gt;、空格四种，其意义下表所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr&gt;&lt;td&gt;标志&lt;/td&gt;
&lt;td&gt;意义&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt; 结果左对齐，右边填空格&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt; 输出符号(正号或负号)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;空格&lt;/td&gt;
&lt;td&gt;输出值为正时冠以空格，为负时冠以负号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;#&lt;/td&gt;
&lt;td&gt;对c，s，d，u类无影响；对o类， 在输出时加前缀。对x类，在输出时加前缀0x；对e,g,f 类当结果有小数时才给出小数点 &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;（3）输出最小宽度：&lt;span&gt;&lt;span&gt;用十进制整数来表示输出的最少位数。 &lt;span&gt;&lt;span&gt;若实际位数多于定义的宽度，则按实际位数输出， &lt;span&gt;&lt;span&gt;若实际位数少于定义的宽度则补以空格或&lt;span&gt;0&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;·&lt;/p&gt;
&lt;p&gt;（4）精度：&lt;span&gt;&lt;span&gt;精度格式符以“&lt;span&gt;.&lt;span&gt;&lt;span&gt;”开头，后跟十进制整数。本项的意义是：如果输出数字，则表示小数的位数；如果输出的是字符， &lt;span&gt;&lt;span&gt;则表示输出字符的个数；若实际位数大于所定义的精度数，则截去超过的部分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）&lt;span&gt;&lt;span&gt;长度：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;长度格式符为&lt;span&gt;h,l&lt;span&gt;&lt;span&gt;两种，&lt;span&gt;h&lt;span&gt;&lt;span&gt;表示按短整型量输出，&lt;span&gt;l&lt;span&gt;&lt;span&gt;表示按长整型量输出。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a=&lt;span&gt;15&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; b=&lt;span&gt;123.1234567&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; c=&lt;span&gt;12345678.1234567&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; d=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a=%d,%5d,%o,%x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a,a,a,a);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b=%f,%lf,%5.4lf%e\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,b,b,b,b);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c=%lf,%f,%8.4f\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,c,c,c);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d=%c,%8c\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,d,d);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：输出列表中的求值顺序，不同编译器不一定相同，可以从左到右，也可以从右到左。&lt;/p&gt;
&lt;p&gt;区分：单个printf语句和多个printf语句输出结果是不同的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n%d\n%d\n%d\n%d\n%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,++i,--i,i++,i--,-i++,-i--&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,++&lt;span&gt;i);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,--&lt;span&gt;i);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i++&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i--&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,-i++&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,-i--&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 24 Dec 2018 15:53:00 +0000</pubDate>
<dc:creator>巫师笔记</dc:creator>
<og:description>1、数据输入与输出 （1）所谓输入与输出是以计算机为主题而言的。 （2）本博客介绍的是向标准输出设备显示器输出数据的语句。 （3）在C语言中，所有数据输入输出都是由库函数完成，因此都是函数语句。 （4</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvfengkun/p/10171743.html</dc:identifier>
</item>
<item>
<title>netty源码解解析(4.0)-8 ChannelPipeline的设计 - 自带buff</title>
<link>http://www.cnblogs.com/brandonli/p/10137555.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brandonli/p/10137555.html</guid>
<description>&lt;p&gt;io.netty.channel.ChannelPipeline&lt;/p&gt;

&lt;div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;设计原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;34&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/895062/201812/895062-20181218153318244-385536843.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　上图中，为了更直观地展示事件处理顺序, 故意有规律地放置两种handler的顺序，实际上ChannelInboundHandler和ChanneOutboundHandler的顺序可以是任意，取决于用户调用add方法把handler方在哪里。&lt;/p&gt;

&lt;p&gt;　　ChannelPipeline的特性:&lt;/p&gt;
&lt;p&gt;　　1. 它是一个双向链表&lt;/p&gt;
&lt;p&gt;　　2. 每个节点持有一个ChannelHandler实例，这个实例可以是ChannelInboundHandler类型或ChannelOutboundHandler类型，&lt;/p&gt;
&lt;p&gt;　　3. ChannelInboundHandler类型的handler只处理inbound事件，ChannelInboundHandler只处理outbound事件。&lt;/p&gt;
&lt;p&gt;　　4. inbound事件处理顺序是由链表头到链表尾，outbound事件的处理顺序是由链表尾到链表头。&lt;/p&gt;
&lt;p&gt;　　5. inbound事件由netty内部触发，最终由netty外部的代码消费。outbound事件由netty外部的代码触发，最终由netty内部消费。&lt;/p&gt;

&lt;div readability=&quot;29&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;接口设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　ChannelPipeline接口定义的方法分为三种类型：链表管理的方法、触发outbound事件的方法、触发inbound事件的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;链表管理的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加：addFirst, addLast, addAfter, addBefore。&lt;/p&gt;
&lt;p&gt;删除：removeFirst, removeLast, remove。&lt;/p&gt;
&lt;p&gt;替换：replace。&lt;/p&gt;
&lt;p&gt;查找：first, last, get。&lt;/p&gt;

&lt;div readability=&quot;27&quot;&gt;
&lt;p&gt;&lt;strong&gt;触发outbound事件的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bind(SocketAddress, ChannelPromise)&lt;/p&gt;
&lt;p&gt;connect(SocketAddress, SocketAddress, ChannelPromise)&lt;/p&gt;
&lt;p&gt;write(Object, ChannelPromise)&lt;/p&gt;
&lt;p&gt;flush()&lt;/p&gt;
&lt;p&gt;read()&lt;/p&gt;
&lt;p&gt;disconnect(ChannelPromise)&lt;/p&gt;
&lt;p&gt;close(ChannelPromise)&lt;/p&gt;
&lt;p&gt;deregister(ChannelPromise)&lt;/p&gt;

&lt;div readability=&quot;32.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;触发inbound事件的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fireChannelRegistered()&lt;/p&gt;
&lt;p&gt;fireChannelActive()&lt;/p&gt;
&lt;p&gt;fireChannelRead(Object)&lt;/p&gt;
&lt;p&gt;fireChannelReadComplete()&lt;/p&gt;
&lt;p&gt;fireExceptionCaught(Throwable)&lt;/p&gt;
&lt;p&gt;fireUserEventTriggered(Object)&lt;/p&gt;
&lt;p&gt;fireChannelWritabilityChanged()&lt;/p&gt;
&lt;p&gt;fireChannelInactive()&lt;/p&gt;
&lt;p&gt;fireChannelUnregistered()&lt;/p&gt;



&lt;div readability=&quot;36&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Channel，EventLoop，ChannelPipeline，EventExecutor和ChannelHandler之间的关系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;每个channel持有一个eventLoop, channel.unsafe的方法会在这个eventLoop中执行。那么问题来了，使用add方法向channelPiple中添加一个channelHandler，这个handler的方法在哪里执行呢？下面以addLast为例看看添加方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ChannelPipeline addLast(ChannelHandler... handlers)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ChannelPipeline addLast(EventExecutorGroup group, ChannelHandler... handlers)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　channelPiple负责为每个新添加的handler分配一个eventExecutor。如果你调用了带grop参数的方法添加handler ，channelPiple会从group中取出一个eventExecutor分配给这个handler, 这时handler中的回调方法会在这个eventExecutor线程中执行，否则channelPiple会把channel的eventLoop当成eventExecutor分配给这个handler，这时这个handler的回调方法会在eventLoop的线程中执行。这个两者有什么不同呢？如果没你没有给handler指定group，它将会和channel的I/O操作共享线程资源，它能得到多少线程资源取决于eventLoop的ioRatio属性的设置，执行时间过长的handler的回调方法会影响I/O操作。如果指定了group，handler的回调方法和channel的I/O操作将会被隔离到不同的线程中。在高并发情况下，强烈建议为不同功能的handler指定不同的group。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个channel实例在创建的时候，它自己负责创建一个channelPiple实例。随后这个channel会被注册到一个eventLoop中，eventLoop负责处理channel上触发的I/O事件，把I/O事件转换成对channel.unsafe方法的调用。unsafe负责做实际的I/O操作，根据需要调用channelPiple触发事件。channelPiple依次调用合适的handler处理事件。这里的&quot;依次”和“合适”的含义是:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果是inbound事件，会从头到尾按顺序调用双向链表上的ChannelInboundHandler类型的handler。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果是outbound事件，会从尾到头按顺序调用双向链表上的ChannelOutboundHandler类型的handler。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　piplePile确保一个handler调用始终在一个唯一的eventExecutor中，这个eventExecutor可能是channel的eventLoop，也可能是从用户指定的eventExecutorGroup中分配到的一个executor。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
</description>
<pubDate>Mon, 24 Dec 2018 15:43:00 +0000</pubDate>
<dc:creator>自带buff</dc:creator>
<og:description>io.netty.channel.ChannelPipeline 设计原理 &lt;!--5f39ae17-8c62-4a45-bc43-b32064c9388a:W3siYmxvY2tJZCI6Ij</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brandonli/p/10137555.html</dc:identifier>
</item>
<item>
<title>find cat sed awk 简单组合使用 - 西瓜_太郎</title>
<link>http://www.cnblogs.com/Q-Meo/p/10171691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Q-Meo/p/10171691.html</guid>
<description>
&lt;h2&gt;find：查找&lt;/h2&gt;
&lt;p&gt;// .表示当前目录；   /表示根目录；  | 管道符；  xargs表示将前面的搜索接口作为参数传递到后面的命令中；grep 过滤&lt;/p&gt;
&lt;p&gt;// xxxx表示文件名&lt;/p&gt;
&lt;p&gt;1.查找指定文件名的文件&lt;/p&gt;
&lt;p&gt;find . -name xxxx    // 区分大小写&lt;/p&gt;
&lt;p&gt;find . -iname xxxx   // 不区分大小写&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224232543648-36941116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.查找当前目录中文件名后缀为 .json的所有文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;find . -type f -name '*.json'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.查找当前目录下所有文件夹&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;find . -type d&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.查找当前目录1小时内被修改的文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;find . -cmin -60 // 单位: 分钟&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-a 表示前后条件都满足&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-o 表示前后条件满足一条即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224233229040-2095929408.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.查找当前目录中包含 function 字符串的文件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;find . | xargs grep function&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.查找文件名包含 function 字符串的文件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;find . -type f -name '*function*'&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.查找3天前创建的后缀为.function的文件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;find . -type f -name '*.function' -ctime +3&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.查找3天前创建的后缀为.function的文件并删除&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;find . -type f -name '*.function' -ctime +3 | xargs rm -r&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;awk：切分列&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;// xxxx 是被操作的文件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.查看某文件指定列数的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;awk '{print $1}' xxxx&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224231423708-921635101.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;sed：切分行&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;// &lt;span&gt;xxxx 是当前被操作的文件&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.查看某文件指定列数的内容&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;sed -n 'startLine, endLinep' xxxx&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224231549180-229781990.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;cat：查看&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;// xxxx 是当前要查看的文件名&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.查看文件内容cat&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cat xxxx&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.查看带行数的内容&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cat -n xxxx 或 cat -b xxxx&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224231808074-810233152.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.统计文件中去重复后的行数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;cat xxxx | sort | uniq | wc -l      // sort 排序  // uniq去除重复&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4.获取指定列内容 awk 切分列 $num 表示第几列&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// num 表示想获取的列数&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cat xxxx | awk '{print $num}'&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 写进新文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cat xxxx | awk '{print $num}' &amp;gt; xxxx_new&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.获取指定行数内容 sed 切分行  -n 表示行数  startline 起始行数  endline 截止行数&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cat xxxx |  sed -n 'startline,endlinep' // 最后的p不能丢&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 写进新文件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cat xxxx |  sed -n 'startline,endlinep' &amp;gt; xxxx_new // 最后的p不能丢&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.将指定列指定行数的内容放入新文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// awk 切分列  $ 后面的数字表示第几列&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// sed 切分行  -n 表示行数  startline 起始行数  endline 截止行数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;cat xxxx | awk '{print $num}' | sed -n 'startline,endlinep' &amp;gt; xxxx_new&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;获取指定进程的ID&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.ps -ef | grep down 获取包含指定进程的信息，第二列就是进程ID&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224225956469-1261026494.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2.ps -ef | grep down | grep -v grep  过滤grep本身&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224230109550-431898415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.获取指定进程的进程ID 两种方式，结果一样&lt;/p&gt;
&lt;p&gt;ps -ef | grep down | grep -v grep | awk '{print $2}'  或 ps -ef | grep down |  awk '{print $2}' | sed -n '1, 1p'&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224230326396-472745079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224230502899-822463726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 15:36:00 +0000</pubDate>
<dc:creator>西瓜_太郎</dc:creator>
<og:description>find：查找 // .表示当前目录； /表示根目录； | 管道符； xargs表示将前面的搜索接口作为参数传递到后面的命令中；grep 过滤 // xxxx表示文件名 1.查找指定文件名的文件 fi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Q-Meo/p/10171691.html</dc:identifier>
</item>
<item>
<title>单元测试框架之unittest(三) - davieyang</title>
<link>http://www.cnblogs.com/davieyang/p/10162469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davieyang/p/10162469.html</guid>
<description>&lt;h2&gt;一、摘要&lt;/h2&gt;
&lt;p&gt;前边的文章我们看到执行测试用例的是通过调用unittest.mian()函数，它会将模块的测试用例收集起来并执行，然而当我们的测试用例增多了以后，这样的执行非常不灵活而且没有效率，我们更愿意看到自由组合的一组用例，只执行这组用例的方式，unittest.TestSuite能够满足我们这个需求，笔者将一random类作为被测试类来详细展示unittest.TestSuite&lt;/p&gt;
&lt;h2&gt;二、代码示例&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;以前的执行方式&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; encoding = utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestRandomFunction(unittest.TestCase):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        self.str &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abcdef!@#$%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_randomchoice(self):
        var &lt;/span&gt;=&lt;span&gt; random.choice(self.str)
        self.assertTrue(var &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.str)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(var)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_randomsample(self):
        with self.assertRaises(ValueError):
            random.sample(self.str, &lt;/span&gt;100&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; var &lt;span&gt;in&lt;/span&gt; random.sample(self.str, 6&lt;span&gt;):
            self.assertTrue(var &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.str)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(var)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestRandomShuffleFunction(unittest.TestCase):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        self.list &lt;/span&gt;= [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13&lt;span&gt;]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_randomshuffle(self):
        random.shuffle(self.list)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.list)
        self.list.sort()
        self.assertEqual(self.list, [&lt;/span&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13&lt;span&gt;])


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    unittest.main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;方式一  使用unittest.TestLoader，它可以通过传给他的参数获取测试用例的测试方法，然后再组合成TestSuite，最后在将TestSuite传递给TestRunner  完成我们所期望的执行组合&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; encoding = utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestRandomFunction(unittest.TestCase):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        self.str &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abcdef!@#$%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_randomchoice(self):
        var &lt;/span&gt;=&lt;span&gt; random.choice(self.str)
        self.assertTrue(var &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.str)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(var)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_randomsample(self):
        with self.assertRaises(ValueError):
            random.sample(self.str, &lt;/span&gt;100&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; var &lt;span&gt;in&lt;/span&gt; random.sample(self.str, 6&lt;span&gt;):
            self.assertTrue(var &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.str)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(var)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestRandomShuffleFunction(unittest.TestCase):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        self.list &lt;/span&gt;= [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13&lt;span&gt;]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_randomshuffle(self):
        random.shuffle(self.list)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.list)
        self.list.sort()
        self.assertEqual(self.list, [&lt;/span&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13&lt;span&gt;])


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; unittest.main()&lt;/span&gt;
    testcase1 =&lt;span&gt; unittest.TestLoader().loadTestsFromTestCase(TestRandomFunction)
    testcase2 &lt;/span&gt;=&lt;span&gt; unittest.TestLoader().loadTestsFromTestCase(TestRandomShuffleFunction)
    suite &lt;/span&gt;=&lt;span&gt; unittest.TestSuite([testcase1, testcase2])
    unittest.TextTestRunner(verbosity&lt;/span&gt;=2).run(suite)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; 方式二 另创建一个.py文件，定义suite方法，使用unittest.TestSuite().addTest(测试类（测试方法）)&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; encoding = utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; unittest3.TestSuiteDemo2 &lt;span&gt;import&lt;/span&gt; *


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; suite():
    suite &lt;/span&gt;=&lt;span&gt; unittest.TestSuite()
    suite.addTest(TestRandomFunction(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_randomchoice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    suite.addTest(TestRandomShuffleFunction(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_randomshuffle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; suite


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    runner &lt;/span&gt;=&lt;span&gt; unittest.TextTestRunner()
    runner.run(suite())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; 方式三 另创建一个.py文件，使用unittest.TestLoader().discover(“路径”，“匹配文件名”)&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; encoding = utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    suite &lt;/span&gt;= unittest.TestLoader().discover(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, pattern=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestSuiteDemo1.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    unittest.TextTestRunner(verbosity&lt;/span&gt;=2).run(suite)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 24 Dec 2018 15:21:00 +0000</pubDate>
<dc:creator>davieyang</dc:creator>
<og:description>一、摘要 前边的文章我们看到执行测试用例的是通过调用unittest.mian()函数，它会将模块的测试用例收集起来并执行，然而当我们的测试用例增多了以后，这样的执行非常不灵活而且没有效率，我们更愿意</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/davieyang/p/10162469.html</dc:identifier>
</item>
<item>
<title>CUBA 使用 Spring 查询接口 - CUBA-China</title>
<link>http://www.cnblogs.com/cubacn/p/cuba-query.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cubacn/p/cuba-query.html</guid>
<description>&lt;p&gt;原文链接：&lt;span&gt;&lt;a href=&quot;https://www.cuba-platform.com/blog/spring-query-interfaces-in-cuba&quot;&gt;https://www.cuba-platform.com/blog/spring-query-interfaces-in-cuba&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;翻译：&lt;/span&gt;CUBA China&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CUBA-Platform 官网 :&lt;/span&gt; &lt;a href=&quot;https://www.cuba-platform.com&quot;&gt;&lt;span&gt;https://www.cuba-platform.com&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CUBA China 官网 : &lt;span&gt;&lt;a href=&quot;http://cuba-platform.cn&quot;&gt;http://cuba-platform.cn&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根本原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　开发人员通常不喜欢改变他们编码的习惯。当我刚开始接触&lt;/span&gt; &lt;a href=&quot;https://www.cuba-platform.com/&quot;&gt;&lt;span&gt;CUBA&lt;/span&gt;&lt;/a&gt; 的时候，发现不需要学很多新的东西，创建应用程序的过程也是非常顺利的。但是其中有一样是需要重新学习的，那就是如何使用数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;Spring框架中，有好几个库可以用来处理数据，其中最流行的一个就是 &lt;a href=&quot;https://docs.spring.io/spring-data/jpa/docs/current/reference/html/&quot;&gt;&lt;span&gt;spring-data-jpa&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，使用这个库可以使开发人员在很多情况下避免编写&lt;/span&gt;SQL或者JPQL。只需要创建一个接口类，然后在接口中创建  &lt;a href=&quot;https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repository-query-keywords&quot;&gt;&lt;span&gt;&lt;span&gt;带有特殊名称&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;的方法，&lt;/span&gt;Spring会自动帮你创建和执行查询语句。&lt;/p&gt;
&lt;p&gt;　　比如，这里有一个接口，其中有个方法是数数有多少客户是同一个姓的：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193042135-403384064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以直接将这个接口注入到&lt;/span&gt;service中，然后就可以在需要的地方调用这个方法了（注意，不需要写实现类）。&lt;/p&gt;
&lt;p&gt;　　CUBA提供了很多开箱即用的数据操控方法，比如加载实体的部分属性以及成熟的数据安全子系统 - 可以限制数据访问权限至实体属性和表数据的行级别。并且这些所有的功能都带有API，但是跟大家都知道的Spring Data或者JPA/Hibernate的略有不同。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以，为什么在&lt;/span&gt;CUBA中没有上面说的查询接口？有没有可能添加呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CUBA中使用数据的方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　CUBA的API中有三个主要的类用来处理数据：DataStore，EntityManager 和 DataManager。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/data_store.html&quot;&gt;DataStore&lt;/a&gt;&lt;/span&gt; &lt;span&gt;的抽象是提供处理持久化存储的&lt;/span&gt;API，比如RDBMS，文件系统或者云存储。可以通过DataStore执行基本的数据操作，但是，不推荐直接使用DataStore，除非需要开发自定义的持久化存储或者需要对底层存储进行非常特殊的访问。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/entityManager.html&quot;&gt;EntityManager&lt;/a&gt;&lt;/span&gt; &lt;span&gt;很大程度上只是&lt;/span&gt;JPA EntityManager 的拷贝，但是有额外的方法用来处理 &lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/views.html&quot;&gt;&lt;span&gt;CUBA视图&lt;/span&gt;&lt;/a&gt;&lt;span&gt;、软删除以及&lt;/span&gt; &lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/query.html?_ga=2.26406845.1445638773.1545295201-2145930198.1545295201&quot;&gt;&lt;span&gt;CUBA 查询语句&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。作为&lt;/span&gt;CUBA开发人员，很少在日常工作中使用这个类，除非需要克服CUBA的安全限制。&lt;/p&gt;
&lt;p&gt;　　下一个要说的，&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/dataManager.html&quot;&gt;&lt;span&gt;DataManager&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，是在&lt;/span&gt;CUBA中处理数据主要使用的类。此类提供了处理数据的API并且支持到属性和行级别的 &lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/dm_security.html&quot;&gt;&lt;span&gt;CUBA安全模型&lt;/span&gt;&lt;/a&gt; &lt;span&gt;。当查询数据的时候，&lt;/span&gt;DataManager会隐式的修改查询语句。比如，在关系型数据库中，它会更改“select”语句，排除那些受限的属性，然后自动添加“where”语句来筛选那些当前用户不能看到的数据行。这种安全感知的行为是很有帮助的，开发人员不需要死记在查询语句中需要添加哪些关于安全方面的条件。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里有个&lt;/span&gt;CUBA类交互的图，展示使用DataManager从RDBMS中获取数据的过程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193125761-2033937489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用&lt;/span&gt;DataManager可以相对容易的查询实体（或者使用CUBA视图查询实体层级结构）。最简单的查询是这样：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193153736-1962536901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　DataManager会自己过滤掉“软删除”的记录、受限制访问的实体属性或实体，也会自己创建数据库事务。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是如果需要执行带有复杂&lt;/span&gt;“where”条件的查询语句，就需要写JPQL了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　看看最开头那个例子，如果需要按姓统计客户人数，在&lt;/span&gt;CUBA中需要写这样的：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193216197-2008955927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里可以看到，需要将&lt;/span&gt;JPQL语句丢给DataManager去执行。在CUBA API里，JPQL需要用字符串来定义（目前还不支持Criteria API&lt;span&gt;）。&lt;/span&gt;JPQL有很好的可读性，也能清晰的定义一个查询语句，但是如果出问题，可能不是很好调试。另外，JPQL字符串不像Criteria API那样能在构建编译时进行验证，或者在Spring上下文初始化的时候验证。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　比较一下&lt;/span&gt;Spring Data JPA 的接口：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193239105-973922918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个接口只有三分之一的代码量而且不包含任何显式的字符串。此外，&lt;/span&gt;countByLastName 方法会在部署阶段验证。如果方法名敲错了，比如，敲成 countByLastNome，则会有异常抛出：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193301772-1518567698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于&lt;/span&gt;CUBA也是基于Spirng框架构建的，所以可以将Spring-data-jpa添加为CUBA项目的依赖库然后使用这个功能。唯一的问题，Spring的查询接口底层使用JPA的EntityManager，所以查询语句不会被CUBA的EntityManager或者DataManager处理。因此，需要找到合适的方法在CUBA中添加查询接口 - 需要自定义，所有调用EntityManager的地方都需要用CUBA的DataManager相应的方法替换，并且添加对CUBA视图的支持。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　也有人会说，使用&lt;/span&gt;Spring的方案不如CUBA的方案可控，因为不能控制生成查询语句的过程。这是在便利性和抽象化级别之间的平衡问题，需要开发者决定到底使用那个方案。但是有个额外的处理数据的简单方法总是没坏处，尽管这也不是唯一的方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果需要更多的控制，&lt;/span&gt;Spring里也有方法为接口&lt;a href=&quot;https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query&quot;&gt;&lt;span&gt;&lt;span&gt;指定查询语句&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，所以这个方法也需要添加到&lt;/span&gt;CUBA。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实施&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　查询接口使用&lt;/span&gt; &lt;a href=&quot;https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/&quot;&gt;&lt;span&gt;spring-data-commons&lt;/span&gt;&lt;/a&gt; &lt;span&gt;实现，构建为&lt;/span&gt;CUBA应用程序组件。这个库包含实现自定义查询接口的类，比如，Spring的&lt;a href=&quot;https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/&quot;&gt;&lt;span&gt;spring-data-mongodb&lt;/span&gt;&lt;/a&gt; &lt;span&gt;库就是基于这个实现的。&lt;/span&gt;Spring-data-commons利用代理技术来为声明式查询接口创建正确的实现。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;CUBA的上下文初始化期间，查询接口的引用都会被生成的代理bean隐式替换。当开发人员调用接口方法时，相应的代理会进行拦截。然后代理根据方法名称生成JPQL查询，替换参数值，并交给DataManager执行。下图展示了模块关键组件之间的简单交互过程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193336003-1085451496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;在&lt;/span&gt;CUBA中使用查询接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　需要在项目的构建文件中添加新的应用程序组件才能使用&lt;/span&gt;CUBA的查询接口：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193401254-66504660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　XML配置文件也需要修改启用查询接口：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193424684-1429395698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果习惯使用注解而不是创建&lt;/span&gt;XML配置文件，可以用下面的方法启用查询接口：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193445825-845957290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　启用查询接口后，可以在应用程序中创建并使用。下面是示例：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193509192-1984357187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以在接口方法上使用&lt;/span&gt; @CubaView 和 @JpqlQuery 注解。第一个注解定义需要使用的&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/views.html?_ga=2.135316529.1445638773.1545295201-2145930198.1545295201&quot;&gt;&lt;span&gt;&lt;span&gt;视图&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;（如果没有使用这个注解默认使用&lt;/span&gt;“_local”视图）。第二个注解是用来设置JPQL的，用在查询语句不能通过&lt;a href=&quot;https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repository-query-keywords&quot;&gt;&lt;span&gt;&lt;span&gt;方法名表示&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;的时候。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　查询接口的应用程序组件是绑定到&lt;/span&gt;CUBA的“global”模块，所以可以在“core”和“web”模块定义和使用查询接口，只是别忘了在相应的配置文件中启用接口。接口使用的示例：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193531109-6048947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　CUBA很灵活。如果觉得需要为应用程序添加新的功能，又不想等CUBA的新版本，很容易在不修改CUBA核心的情况下实施并添加到项目中。通过为CUBA添加查询接口，我们希望能帮助开发人员更加有效的工作，更快的交付可靠的代码。这个库的第一个版本可以在&lt;a href=&quot;https://github.com/cuba-rnd/cuba-jpa-repositories&quot;&gt;&lt;span&gt;GitHub&lt;/span&gt;&lt;/a&gt;&lt;span&gt;找到，目前支持&lt;/span&gt;CUBA 6.10和更高版本。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193553747-800135619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Mon, 24 Dec 2018 15:15:00 +0000</pubDate>
<dc:creator>CUBA-China</dc:creator>
<og:description>原文链接：https://www.cuba-platform.com/blog/spring-query-interfaces-in-cuba 翻译：CUBA China CUBA-Platform</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cubacn/p/cuba-query.html</dc:identifier>
</item>
</channel>
</rss>