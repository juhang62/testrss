<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>带你了解数据库中JOIN的用法 - Coder编程</title>
<link>http://www.cnblogs.com/coder-programming/p/10668123.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coder-programming/p/10668123.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;欢迎关注公众号：&lt;strong&gt;Coder编程&lt;/strong&gt;&lt;br/&gt;获取最新原创技术文章和相关免费学习资料，随时随地学习技术知识！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本章主要介绍数据库中Join的的用法，也是我们在使用数据库时非常基础的一个知识点。本次会介绍数据库中的&lt;code&gt;inner join&lt;/code&gt;、&lt;code&gt;left join&lt;/code&gt;、&lt;code&gt;right join&lt;/code&gt; 的用法以及它们之间的区别。 文章如有错误还请大家及时指出~&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以下都是采用mysql数据库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;join&quot;&gt;Join&lt;/h2&gt;
&lt;p&gt;相信大家在学习数据库的使用时，都有使用过Join，对数据库中的两张或两张以上表进行连接操作。&lt;br/&gt;&lt;strong&gt;Join&lt;/strong&gt; 分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内连接(inner join)&lt;/li&gt;
&lt;li&gt;外连接(outer join)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中&lt;strong&gt;外连接&lt;/strong&gt;分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;左外连接(left outer join)&lt;/li&gt;
&lt;li&gt;右外连接(right outer join)&lt;/li&gt;
&lt;li&gt;全外连接(full outer join)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1.其中外连接的“OUTER”关键字可以省略不写。&lt;br/&gt;2.内连接用于返回满足连接条件的记录；而外连接则是内连接的扩展，它不仅会满足连接条件的记录，而且还会返回不满足连接条件的记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;笛卡尔积&quot;&gt;笛卡尔积&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在我们进行多表联合查询的时候会出现的一种情况——&lt;strong&gt;笛卡尔积现象&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们以下面两张表举例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学生表（Student）&lt;/strong&gt;&lt;br/&gt;|ID | StudentName | StudentClassID|&lt;br/&gt;|---|---|---|&lt;br/&gt;|1 | 小明| 1|&lt;br/&gt;|2 | 小红| 2|&lt;br/&gt;|3 | 小兰 | 3|&lt;br/&gt;|4 | 小吕 | 2|&lt;br/&gt;|5 | 小梓 | 1|&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;班级表（Class）&lt;/strong&gt;&lt;br/&gt;|ClassID| ClassName|&lt;br/&gt;|---|---|&lt;br/&gt;|1 | 软件一班|&lt;br/&gt;|2 | 软件二班|&lt;br/&gt;|3 | 软件三班|&lt;/p&gt;
&lt;p&gt;当我们进行查询操作的时候：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;select * from Student,Class;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407222148953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;查询&quot;/&gt;&lt;br/&gt;就会出现上面的情况，也就是笛卡尔现象，表Student中有5条记录，表Class中有3条记录，那么对于表Student而言有5种选择，对于表Class来说有3种选择。所以一共有 5 * 3 = 15种选择了，也就是&lt;strong&gt;笛卡尔积&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;内连接inner-join&quot;&gt;内连接——inner join&lt;/h2&gt;
&lt;p&gt;内连接查询返回满足条件的所有记录，默认情况下没有指定任何连接则为内连接。&lt;br/&gt;例如：查询xx学生在xx班级 &lt;code&gt;沿用上面的数据表&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;select stu.StudentName,cl.ClassName from Student stu &lt;code&gt;inner join&lt;/code&gt; Class cl on stu.StudentClassID=cl.ClassID;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;查询结果&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407224142330.png&quot; alt=&quot;inner join&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;左外连接left-join&quot;&gt;左外连接——left join&lt;/h2&gt;
&lt;p&gt;左外连接查询不仅返回满足条件的所有记录，而且还会返回不满足连接条件的连接操作符左边表的其他行。&lt;br/&gt;我们在原Student 表中新增学生：小美&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407225114143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;新增学生-小美&quot;/&gt;&lt;br/&gt;例如： 查询xx学生在xx班级 &lt;code&gt;沿用上面的数据表&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;select stu.StudentName,cl.ClassName from Student stu &lt;code&gt;left join&lt;/code&gt; Class cl on stu.StudentClassID=cl.ClassID;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;查询结果&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407225326466.png&quot; alt=&quot;左外连接&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;右外连接right-join&quot;&gt;右外连接——right join&lt;/h2&gt;
&lt;p&gt;右外连接查询不仅返回满足条件的所有记录，而且还会返回不满足连接条件的连接操作符右边表的其他行。&lt;br/&gt;我们在原Class表中新增班级：软件四班&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407225710404.png&quot; alt=&quot;新增班级_软件四班&quot;/&gt;&lt;br/&gt;例如： 查询xx学生在xx班级 &lt;code&gt;沿用上面的数据表&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;select stu.StudentName,cl.ClassName from Student stu right join Class cl on stu.StudentClassID=cl.ClassID;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;查询结果&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407225819462.png&quot; alt=&quot;查询结果&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;全连接full-join&quot;&gt;全连接——full join&lt;/h2&gt;
&lt;p&gt;全连接查询不仅返回满足条件的所有记录，而且还会返回不满足连接条件的其他行。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：mysql默认不支持full join。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我们就不做介绍了。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;文末&quot;&gt;文末&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本章节主要介绍了Iterable与Iterator之间的区别与联系，以及其他方面的小知识点，也是面试过程中会出现的内容点。&lt;br/&gt;欢迎关注公众号：&lt;strong&gt;Coder编程&lt;/strong&gt;&lt;br/&gt;获取最新原创技术文章和相关免费学习资料，随时随地学习技术知识！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407231851378.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483676&amp;amp;idx=1&amp;amp;sn=9033af3cb37754446779e1fcd89e3329&amp;amp;chksm=96e6700fa191f91919b4c2a46a8a99a7a7dda037181e97b5377835500e99a5f66cb1d3337898&amp;amp;token=424171447&amp;amp;lang=zh_CN#rd&quot;&gt;一篇让你理解进程与线程的区别与联系&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483701&amp;amp;idx=1&amp;amp;sn=b21d65f8ba4ae7f861a6e6175be2303c&amp;amp;chksm=96e67026a191f930c540a8c823c6ad5355dc4cb92824eadc9485aa195167768560dc506af358&amp;amp;token=1104592742&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot;&gt;通过“表白”的方式，让我们快速了解网络协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&amp;amp;mid=2247483706&amp;amp;idx=1&amp;amp;sn=8eed9d160013bd8ed6203ad511711553&amp;amp;chksm=96e67029a191f93fdd1543af2bf06025397d9c3bd0f0692c7fe247ab9c139cd869d69ab05498&amp;amp;token=1104592742&amp;amp;lang=zh_CN#rd&quot;&gt;一篇带你读懂TCP之“滑动窗口”协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jackson-zhangjiang/p/7819634.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/jackson-zhangjiang/p/7819634.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.360doc.com/content/14/1229/21/7635_436727229.shtml&quot; class=&quot;uri&quot;&gt;http://www.360doc.com/content/14/1229/21/7635_436727229.shtml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CoderMerlin/coder-programming&quot;&gt;Github个人主页目录&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://gitee.com/573059382/coder-programming&quot;&gt;Gitee个人主页目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎大家关注并Star~&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 15:41:00 +0000</pubDate>
<dc:creator>Coder编程</dc:creator>
<og:description>前言 欢迎关注公众号： Coder编程 获取最新原创技术文章和相关免费学习资料，随时随地学习技术知识！ 本章主要介绍数据库中Join的的用法，也是我们在使用数据库时非常基础的一个知识点。本次会介绍数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coder-programming/p/10668123.html</dc:identifier>
</item>
<item>
<title>维护gcd的线段树 补发一波。。。 - Jack_Pei</title>
<link>http://www.cnblogs.com/Jackpei/p/10668114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackpei/p/10668114.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Jackpei/p/10352817.html&quot; target=&quot;_blank&quot;&gt;基础线段树&lt;/a&gt;（辣鸡的不行）&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;发现自己线段树除了会维护加法和乘法就啥也不会了QWQ太菜了&lt;/p&gt;
&lt;p&gt;瞎写了一个维护gcd的&lt;/p&gt;
&lt;p&gt;首先，gcd(x,y)= gcd(x,y-x) 并且很容易推广到n个数，所以我们可以把原数组差分一下，&lt;/p&gt;
&lt;p&gt;find时就左右子树大力合并gcd，最后和左端点元素本身取gcd；&lt;/p&gt;
&lt;p&gt;upd时就直接修改差分数组的端点，同时用树状数组维护原数组变化量；轻松加愉悦。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;106&quot;&gt;
&lt;pre&gt;
#include&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cmath&amp;gt;
&lt;span&gt;#define&lt;/span&gt; ll long long
&lt;span&gt;#define&lt;/span&gt; R register ll
&lt;span&gt;#define&lt;/span&gt; ls tr&amp;lt;&amp;lt;1
&lt;span&gt;#define&lt;/span&gt; rs tr&amp;lt;&amp;lt;1|1
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; N=&lt;span&gt;500050&lt;/span&gt;&lt;span&gt;;
ll w[N&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;],c[N],a[N],n,m;
inline ll g() {
    R ret&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;,fix=&lt;span&gt;1&lt;/span&gt;; register &lt;span&gt;char&lt;/span&gt; ch; &lt;span&gt;while&lt;/span&gt;(!isdigit(ch=getchar())) fix=ch==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;?-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:fix;
    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt; ret=ret*&lt;span&gt;10&lt;/span&gt;+(ch^&lt;span&gt;48&lt;/span&gt;); &lt;span&gt;while&lt;/span&gt;(isdigit(ch=getchar())); &lt;span&gt;return&lt;/span&gt; ret*&lt;span&gt;fix;
}
inline ll gcd(ll a,ll b) {&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; b?gcd(b,a%&lt;span&gt;b):a;}
inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; build(&lt;span&gt;int&lt;/span&gt; tr,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; r) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(l==r) {w[tr]=a[l]-a[l-&lt;span&gt;1&lt;/span&gt;]; &lt;span&gt;return&lt;/span&gt;;}
    R md=(l+r)&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    build(ls,l,md),build(rs,md&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;,r);
    w[tr]=&lt;span&gt;gcd(w[ls],w[rs]);
}
inline ll find(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tr,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r,&lt;span&gt;int&lt;/span&gt; LL,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; RR) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(l==LL&amp;amp;&amp;amp;r==RR) &lt;span&gt;return&lt;/span&gt; abs(w[tr]);
    R md=(l+r)&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(RR&amp;lt;=md) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; find(ls,l,md,LL,RR);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(LL&amp;gt;md) &lt;span&gt;return&lt;/span&gt; find(rs,md+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,r,LL,RR);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; abs(gcd(find(ls,l,md,LL,md),find(rs,md+&lt;span&gt;1&lt;/span&gt;,r,md+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,RR)));
}
inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; upd(&lt;span&gt;int&lt;/span&gt; tr,&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt; r,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; pos,ll inc) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(l==r) {w[tr]+=inc; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;}
    R md&lt;/span&gt;=(l+r)&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pos&amp;lt;=&lt;span&gt;md) upd(ls,l,md,pos,inc);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; upd(rs,md+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,r,pos,inc);
    w[tr]&lt;/span&gt;=&lt;span&gt;gcd(w[ls],w[rs]);
}
inline &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lbt(&lt;span&gt;int&lt;/span&gt; x) {&lt;span&gt;return&lt;/span&gt; x&amp;amp;-&lt;span&gt;x;}
inline ll ask(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pos) {R ret=&lt;span&gt;0&lt;/span&gt;; &lt;span&gt;for&lt;/span&gt;(;pos;pos-=lbt(pos)) ret+=c[pos]; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;}
inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; pos,ll inc) {&lt;span&gt;for&lt;/span&gt;(;pos&amp;lt;=n;pos+=lbt(pos)) c[pos]+=&lt;span&gt;inc;}
signed main() {
    n&lt;/span&gt;=g(),m=&lt;span&gt;g();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(R i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;++i) a[i]=&lt;span&gt;g();
    build(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,n);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(m--) { register &lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!isalpha(ch=getchar())); register &lt;span&gt;int&lt;/span&gt; l=g(),r=&lt;span&gt;g(); R inc;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ch==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Q&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,gcd(a[l]+ask(l),find(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,n,l+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,r)));
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            inc&lt;/span&gt;=g();add(l,inc);upd(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,n,l,inc),add(r+&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;inc);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(r&amp;lt;n) upd(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,n,r+&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;inc);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;2019.04.07&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 15:38:00 +0000</pubDate>
<dc:creator>Jack_Pei</dc:creator>
<og:description>基础线段树（辣鸡的不行） 发现自己线段树除了会维护加法和乘法就啥也不会了QWQ太菜了 瞎写了一个维护gcd的 首先，gcd(x,y)= gcd(x,y-x) 并且很容易推广到n个数，所以我们可以把原数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jackpei/p/10668114.html</dc:identifier>
</item>
<item>
<title>Prometheus安装和配置node_exporter监控主机 - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/10668116.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/10668116.html</guid>
<description>&lt;p&gt;Node_exporter是可以在* Nix和Linux系统上运行的计算机度量标准的导出器。&lt;/p&gt;
&lt;p&gt;Node_exporter 主要用于暴露 metrics 给 Prometheus，其中 metrics 包括：cpu 的负载，内存的使用情况，网络等。&lt;/p&gt;
&lt;p&gt;官方下载地址：&lt;a href=&quot;https://github.com/prometheus/node_exporter/releases/download/v0.17.0/node_exporter-0.17.0.linux-amd64.tar.gz&quot; target=&quot;_blank&quot;&gt;https://github.com/prometheus/node_exporter/releases/download/v0.17.0/node_exporter-0.17.0.linux-amd64.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、安装Node_exporter&lt;/p&gt;
&lt;p&gt;解压缩node_exporter并将目录重命名为“node_exporter”放到/usr/local/下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
tar -xf node_exporter-0.17.0.linux-amd64.tar.gz
mv node_exporter-0.17.0.linux-amd64 /usr/local/node_exporter
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 放在后台启动即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
nohup ./node_exporter &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2、修改Prometheus的配置文件 prometheus.yml的scrape_configs下添加node_exporter，后重启Prometheus。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
scrape_configs:
  # The job name is added as a label `job=&amp;lt;job_name&amp;gt;` to any timeseries scraped from this config.
  - job_name: 'prometheus'

    # metrics_path defaults to '/metrics'
    # scheme defaults to 'http'.

    static_configs:
    - targets: ['localhost:9090']
  - job_name: 'node_exporter'
    static_configs:
      - targets: 
        - '172.31.182.140:9100'
        - '172.31.182.141:9100'
        - '172.31.182.142:9100'
        - '172.31.182.143:9100'
        - '172.31.182.144:9100'
        - '172.31.182.145:9100'
        - '172.31.182.146:9100'
        - '172.31.182.147:9100'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3、添加granfana&lt;/p&gt;
&lt;p&gt;模板下载地址：&lt;a href=&quot;https://grafana.com/api/dashboards/1860/revisions/13/download&quot; target=&quot;_blank&quot;&gt;https://grafana.com/api/dashboards/1860/revisions/13/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201904/1271786-20190407233633355-386808300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;导入后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1271786/201904/1271786-20190407233702429-193453051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 07 Apr 2019 15:38:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<og:description>Node_exporter是可以在* Nix和Linux系统上运行的计算机度量标准的导出器。 Node_exporter 主要用于暴露 metrics 给 Prometheus，其中 metrics</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dev0ps/p/10668116.html</dc:identifier>
</item>
<item>
<title>NCE损失(Noise-Constrastive Estimation Loss) - 混沌战神阿瑞斯</title>
<link>http://www.cnblogs.com/arachis/p/NCE_Loss.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/arachis/p/NCE_Loss.html</guid>
<description>&lt;h3 id=&quot;算法概述&quot;&gt;1.算法概述&lt;/h3&gt;
&lt;p&gt;假设X是从真实的数据（或语料库）中抽取的样本,其服从一个相对可参考的概率密度函数P(d),噪音样本Y服从概率密度函数为P(n)，噪音对比估计(NCE)就是通过学习一个分类器把这两类样本区别开来，并能从模型中学到数据的属性。&lt;/p&gt;
&lt;p&gt;模型原始论文：&lt;a href=&quot;http://www.jmlr.org/proceedings/papers/v9/gutmann10a/gutmann10a.pdf&quot;&gt;Noise-contrastive estimation: A new estimation principle for unnormalized statistical models&lt;/a&gt;&lt;br/&gt;tensorflow引用：&lt;a href=&quot;https://www.tensorflow.org/extras/candidate_sampling.pdf&quot;&gt;Candidate Sampling Algorithms Reference&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;算法要点与推导&quot;&gt;2.算法要点与推导&lt;/h3&gt;
&lt;h4 id=&quot;损失函数定义&quot;&gt;2.1损失函数定义：&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \text{让$U=X\bigcup Y={u1,u2,⋯,u_{T_d}+u_{T_n}}$，其中$T_d$为数据样本个数，$T_n$为噪音分布的样本个数。那么我们认为$u_t$服从(0-1)分布，给每个$u_t$一个标签$C_t$，则} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ C_t= \begin{cases} 1, &amp;amp; \text{if $u_t \in X$} \\ 0, &amp;amp; \text{if $u_t \in Y$} \end{cases} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \text{由于$p_d$未知，我们让$p(⋅|C=1)=p_m(.;θ)$，我们假设存在一个$\theta^*$} \text{使得$p_d(.)=p_m(.;\theta^*)$，那么，就可以认为经验分布$p_d(.)$为参数分布簇$p_m(.;θ)$中的一员。} \]&lt;/span&gt;&lt;br/&gt;给定以上定义，我们得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{cases} p(u|C=1)=p_m(u;\theta) ,&amp;amp; \text{data} \\ p(u|C=0)=p_n(u) ,&amp;amp; \text{noise} \end{cases} \]&lt;/span&gt;&lt;br/&gt;这里时间有限，中间推到步骤先略过。最终得到损失函数公式如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(θ)=Σ^{T_d+T_n}_{t=1}[C_tlnP(C_t=1|u_t;\theta)+(1-C_t)lnP(C_t=0|u_t)] =Σ^{T_d}_{t=1}ln[h(x_t;θ)]+Σ^{Tn}_{t=1}ln[1-h(y_t;θ)] \]&lt;/span&gt;&lt;br/&gt;注意到，如果给式（9）加上个负号就成为了交叉熵函数了。从结果可以看出，我们进行的无监督学习的密度估计可由监督学习算法logistic regression来学习，这就是监督学习与无监督学习的联系。&lt;/p&gt;
&lt;h3 id=&quot;算法特性及优缺点&quot;&gt;3.算法特性及优缺点&lt;/h3&gt;
&lt;h3 id=&quot;实现和具体例子&quot;&gt;4.实现和具体例子&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/littlely_ll/article/details/79252064&quot;&gt;噪音对比估计（NCE）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/Tongzhenguo/Python-Project/blob/master/ctr_model/nce_loss.py&quot;&gt;tensorflow tf.nn.nce_loss()源代码学习&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 15:31:00 +0000</pubDate>
<dc:creator>混沌战神阿瑞斯</dc:creator>
<og:description>### 1.算法概述 ### 2.算法要点与推导 ### 3.算法特性及优缺点 ### 4.实现和具体例子</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/arachis/p/NCE_Loss.html</dc:identifier>
</item>
<item>
<title>第二次Java程序设计作业 - 梶浦由记</title>
<link>http://www.cnblogs.com/xiaoju-1-3/p/10668080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoju-1-3/p/10668080.html</guid>
<description>&lt;h4&gt;1.编写“人”类及其测试类。&lt;br/&gt;1.1 “人”类：&lt;br/&gt; 类名：Person&lt;br/&gt; 属性：姓名、性别、年龄、身份证号码&lt;br/&gt; 方法：在控制台输出各个信息&lt;br/&gt;1.2 测试类&lt;br/&gt; 类名：TestPerson&lt;br/&gt; 方法：main&lt;br/&gt; 对象：（张三，男，18,430101010101010101）&lt;br/&gt;（李四，女，18,123456789009876543）&lt;img src=&quot;https://img2018.cnblogs.com/blog/1638410/201904/1638410-20190407232600475-1130326404.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;2.编写“手机”类及其测试类。&lt;br/&gt;2.1 “手机”类：&lt;br/&gt; 类名：Phone&lt;br/&gt; 属性：手机品牌、手机型号&lt;br/&gt; 方法：在控制台输出手机信息&lt;br/&gt;2.2 测试类&lt;br/&gt; 类名：TestPhone&lt;br/&gt; 方法：main&lt;br/&gt; 对象：（华为，荣耀3C）&lt;br/&gt;（联想，A3600D）&lt;br/&gt;（小米，note）&lt;img src=&quot;https://img2018.cnblogs.com/blog/1638410/201904/1638410-20190407232622514-1130510843.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;3.编写“书籍”类及其测试类。&lt;br/&gt;3.1 “书籍”类&lt;br/&gt; 类名：Book&lt;br/&gt; 属性：书名、书号、主编、出版社、出版时间、页数、价格&lt;br/&gt; 方法：在控制台输出每本书的信息&lt;br/&gt;3.2 测试类&lt;br/&gt; 创建2个对象，并调用方法&lt;img src=&quot;https://img2018.cnblogs.com/blog/1638410/201904/1638410-20190407232835682-1736149093.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;4.编写“圆柱体”类及其测试类。&lt;br/&gt;4.1 “圆柱体”类&lt;br/&gt; 属性：圆底半径、高，&lt;br/&gt; 方法1：计算底面积&lt;br/&gt; 方法2：计算体积&lt;br/&gt; 方法3：打印圆底半径、高、底面积和体积。&lt;br/&gt;4.2 测试类&lt;br/&gt; 创建2个对象，并调用方法&lt;img src=&quot;https://img2018.cnblogs.com/blog/1638410/201904/1638410-20190407232923469-1646285094.png&quot; alt=&quot;&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;本次操作eclipse，还是有很多不熟练的地方，对一些基本格式把握的不够好，但是慢慢的我可以适应了&lt;/p&gt;

</description>
<pubDate>Sun, 07 Apr 2019 15:30:00 +0000</pubDate>
<dc:creator>梶浦由记</dc:creator>
<og:description>1.编写“人”类及其测试类。1.1 “人”类： 类名：Person 属性：姓名、性别、年龄、身份证号码 方法：在控制台输出各个信息1.2 测试类 类名：TestPerson 方法：main</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoju-1-3/p/10668080.html</dc:identifier>
</item>
<item>
<title>CentOS7.0小随笔——指令基本操作（Part.B） - 悲催世界一雷</title>
<link>http://www.cnblogs.com/lilywhite/p/10668043.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lilywhite/p/10668043.html</guid>
<description>&lt;p&gt;一、文件与目录基本操作指令&lt;/p&gt;
&lt;p&gt;touch命令&lt;/p&gt;
&lt;p&gt;在Linux中，touch指令可以建立一个空文件&lt;/p&gt;
&lt;p&gt;但如果创建的文件本身存在（指在同一目录下），则会修改文件最后的访问时间，并不会更改文件内的内容。&lt;/p&gt;
&lt;p&gt;例：# touch vsftpd.conf.bak&lt;/p&gt;

&lt;p&gt;cp命令&lt;/p&gt;
&lt;p&gt;cp功能：复制文件或文件夹（目录）&lt;/p&gt;
&lt;p&gt;语法：cp  [选项]  &amp;lt;源文件/源目录&amp;gt;  &amp;lt;目标文件/目标目录&amp;gt;&lt;/p&gt;
&lt;p&gt;常用选项：-f ：强行复制，不论目标文件或目录是否存在（如果存在则就覆盖）&lt;/p&gt;
&lt;p&gt;　　　　　-r ：递归处理，将指定目录内的所有文件与子目录一并处理复制&lt;/p&gt;
&lt;p&gt;　　　　　-i ：覆盖已经存在的文件前先询问是否执行操作（起到了保险的作用）&lt;/p&gt;
&lt;p&gt;例：# cp -r /var/backup/ /home/user1/　　　　&lt;/p&gt;
&lt;p&gt;//将/var/backup目录下的所有文件与子目录复制到/home/user1下（使用递归）&lt;/p&gt;

&lt;p&gt;mv命令&lt;/p&gt;
&lt;p&gt;mv功能：移动或对现有的文件/目录进行重命名的操作&lt;/p&gt;
&lt;p&gt;语法：mv  [选项]  &amp;lt;源文件/源目录&amp;gt;  &amp;lt;目标文件/目标目录&amp;gt;&lt;/p&gt;
&lt;p&gt;常用选项： -f ：若目标文件或目录与现有的文件或目录有重复，则强制覆盖现有的文件或目录&lt;/p&gt;
&lt;p&gt;　　　　　 -i ：覆盖前先询问是否执行操作&lt;/p&gt;
&lt;p&gt;例：# mv Sakurauchi_Riko.txt Aida_Rikako.txt&lt;/p&gt;
&lt;p&gt;//将当前目录下Sakurauchi_Riko.txt文件重命名为Aida_Rikako.txt&lt;/p&gt;

&lt;p&gt;rm命令：&lt;/p&gt;
&lt;p&gt;rm功能：删除文件或目录&lt;/p&gt;
&lt;p&gt;语法：rm [选项] &amp;lt;文件或目录&amp;gt;&lt;/p&gt;
&lt;p&gt;常用选项：-r ：递归删除&lt;/p&gt;
&lt;p&gt;　　　　　-f ：强制删除不提示&lt;/p&gt;
&lt;p&gt;tips：-rf选项虽好，但永前要慎重，避免翻车！（谨记业内津津乐道的删库段子）&lt;/p&gt;
&lt;p&gt;例：# rm -rf /&lt;/p&gt;
&lt;p&gt;//强制删除根目录下的所有文件，且不经询问（是不是很可怕？）&lt;/p&gt;
&lt;p&gt;（tips：在CentOS中，删除重要目录光是加个-rf选项是远远不够的，还要加别的参数--no-preserve-root）&lt;/p&gt;

&lt;p&gt;mkdir和rmdir命令：&lt;/p&gt;
&lt;p&gt;mkdir功能：新建文件夹（建立目录：make directory）&lt;/p&gt;
&lt;p&gt;rmdir功能：删除文件夹（删除目录，有时rmdir常用rm -rf指令替代）&lt;/p&gt;

&lt;p&gt;二、文件查看命令&lt;/p&gt;
&lt;p&gt;file命令：&lt;/p&gt;
&lt;p&gt;file命令可以探测文件和目录类型&lt;/p&gt;
&lt;p&gt;语法：# file [选项] &amp;lt;目标文件名&amp;gt;&lt;/p&gt;

&lt;p&gt;cat命令：&lt;/p&gt;
&lt;p&gt;cat指令常常用来显示文件内容，类似于DOS下的type&lt;/p&gt;
&lt;p&gt;例：# cat /etc/vsftp/vsftpd.conf&lt;/p&gt;
&lt;p&gt;//显示/etc/vsftp/vsftpd.conf文件内容&lt;/p&gt;

&lt;p&gt;head命令：&lt;/p&gt;
&lt;p&gt;head指令可以规定显示文件内容的前几行&lt;/p&gt;
&lt;p&gt;例：# head -n 10 /etc/vsftp/vsftpd.conf&lt;/p&gt;
&lt;p&gt;//输出文件/etc/vsftp/vsftpd.conf的前十行&lt;/p&gt;

&lt;p&gt;less和more命令：&lt;/p&gt;
&lt;p&gt;less指令和more指令的功能都是一样的：逐页阅读文件内容&lt;/p&gt;
&lt;p&gt;这是十分有用的，可以不需要修改就可以在屏幕上显示你想看的文件内容&lt;/p&gt;
&lt;p&gt;区别是：less指令可以前后翻页，但是more指令只能使用空格键向后翻页。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 15:21:00 +0000</pubDate>
<dc:creator>悲催世界一雷</dc:creator>
<og:description>一、文件与目录基本操作指令 touch命令 在Linux中，touch指令可以建立一个空文件 但如果创建的文件本身存在（指在同一目录下），则会修改文件最后的访问时间，并不会更改文件内的内容。 例：#</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lilywhite/p/10668043.html</dc:identifier>
</item>
<item>
<title>4.3递归运行的机制：递归的微观解读 - WFaceBoss</title>
<link>http://www.cnblogs.com/wfaceboss/p/10667325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wfaceboss/p/10667325.html</guid>
<description>&lt;p&gt;前言：在4.1节和4.2节中我们分别通过数组以及链表对递归进行了应用，那时我们只是对递归进行了宏观理解--递归是将问题化为更小问题的子过程。这一节我们对在4.1节中递归在数组中的应用和4.2节中递归在链表中的应用进行微观解读：&lt;/p&gt;
&lt;h2&gt;一.关于4.1节中递归在数组中的应用&lt;/h2&gt;
&lt;p&gt;1） 我们先来看看4.1节中的代码实现，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407215024916-912487382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了更好的进行分析，我们将上述代码的最后一句进行拆分，拆分结果如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407215203416-1166698813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时 n=arr.length=2：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407215529990-877840409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2）现在我们对已经拆分的代码进行分析为此来说明：递归函数的调用，本质就是函数调用。&lt;/p&gt;
&lt;p&gt; 为了分析简单，我们使用只有两个元素的数组 arr=[6,10]&lt;/p&gt;
&lt;p&gt;第一次调用：sum(arr,0)&lt;/p&gt;
&lt;p&gt;使用sun(arr,0)进行调用，进入方法体之后，由于不满足递归的基本条件，进而继续调用sum（arr,1）方法，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407220147915-1241676386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二次调用：sum(arr,1)&lt;/p&gt;
&lt;p&gt; 使用sun(arr,1)进行调用，进入方法体之后，由于不满足递归的基本条件，进而继续调用sum（arr,2）方法，此时调用过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407220625127-2055524321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当调用sum(arr,2)时，由于此时已经满足了递归的基本条件，结果直接返回0，回到上一次中断的位置，也就是下图中调用sum(arr,1) 方法中的sum（arr,l+1）处，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407221314529-1109906791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码从中断处继续向下执行，返回arr[1]=10, x=0因此res=10,此时返回值为res=10;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407221614204-2005560332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;此时代码也将回到sum(arr,1)父亲的调用中，也就是sum(arr,0)中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407221827774-152126544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码从中断处继续向下执行，返回arr[0]=6, x=10因此res=16,此时返回值为res=16;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407222015909-1527678726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过递归得到了我们最终的结果为16。&lt;/p&gt;
&lt;p&gt;从上述的过程中印证了：递归函数的调用，本质就是函数调用（自身函数）---也就是使用不同的参数，执行相同的逻辑。&lt;/p&gt;
&lt;h2&gt;二、关于4.2节中递归在链表中的应用（删除链表中指定的所有元素值）&lt;/h2&gt;
&lt;p&gt; 1）我们先来看看4.2节中的代码实现，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407222643775-1972541571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了分析的方便，我们对方法体中的代码做一个简单的标识1,2,3，结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407222558660-978465104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2）为了分析的简便，我们来进行模拟调用，对6---&amp;gt;7---&amp;gt;8---&amp;gt;null 删除元素为7的节点。&lt;/p&gt;
&lt;p&gt;注意：下面的分析中我们使用1,2,3这样的编号，表示代码执行到的位置&lt;/p&gt;
&lt;p&gt;第一次调用：&lt;/p&gt;
&lt;p&gt;首先传入头结点为6的链表，由于不满足递归的基本结束条件，再一次触发第二次调用，此时链表变为头结点为7的链表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407223422322-1973782784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二次调用：&lt;/p&gt;
&lt;p&gt;此时链表的头结点变为7，由于不满足递归的基本结束条件，再一次触发第三次调用，此时链表变为头结点为8的链表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407223604160-989459905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三次调用：&lt;/p&gt;
&lt;p&gt; 此时链表的头结点变为8，由于不满足递归的基本结束条件，再一次触发第四次调用，此时链表变为空链表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407224040829-935152947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四次调用中，由于此时已经满足了递归的基本条件，回到上一次中断的位置也就是2的位置，返回值为null，如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407224328369-1806494901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时的链表为头结点为8的链表，如上图黄色区域，执行第三步代码之后，返回的结果为为头结点为8的链表，即为8--&amp;gt;null，并将该结果返回到上一步调用，也就是标号为2的地方，得到结果为7--&amp;gt;8--&amp;gt;null的链表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407230036403-1393044956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后继续执行第三步，此时链表7--&amp;gt;8--&amp;gt;null满足删除条件，也就是head.val=val=7,将执行head.next,返回最终结果为8--&amp;gt;null，如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407230643841-543643949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到父级调用的中断位置，得到的结果为6--&amp;gt;8---&amp;gt;null，然后执行第三步代码,判断此时的链表的head.val是否等于val=7,此时的链表不满足，直接返回head，也就是6--8--&amp;gt;null&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407231103443-1587874542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 到此递归调用得以结束，完成过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201904/860581-20190407231203065-1103199318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;递归的调用是由代价的：函数调用（时间开销）+系统栈空间,但是使用递归书写逻辑是更为简单的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 关于本小节，若您觉得还行、还过得去，记得给个推荐哦~，谢谢！！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 15:16:00 +0000</pubDate>
<dc:creator>WFaceBoss</dc:creator>
<og:description>前言：在4.1节和4.2节中我们分别通过数组以及链表对递归进行了应用，那时我们只是对递归进行了宏观理解--递归是将问题化为更小问题的子过程。这一节我们对在4.1节中递归在数组中的应用和4.2节中递归在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wfaceboss/p/10667325.html</dc:identifier>
</item>
<item>
<title>不要总想着二进制 - apolis</title>
<link>http://www.cnblogs.com/apolis/p/10668006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apolis/p/10668006.html</guid>
<description>&lt;p&gt;同事转了一道题：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;有 100 支一模一样的瓶子，编号 1-100。其中 99 瓶是水，1 瓶是看起来像水的毒药。&lt;br/&gt;只要老鼠喝下一小口毒药，一天后就会死。&lt;/p&gt;
&lt;p&gt;现在你有 7 只老鼠和一天时间，怎么检验出哪个号码的瓶子里是毒药？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻看答案：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;首先，将瓶子的 10 进制编号数改成 7 位的 2 进制码。&lt;br/&gt;然后，让第 1 只老鼠喝所有 2 进制码第 1 位是 1 的瓶子中的水；让第 2 只老鼠喝所有 2 进制码第 2 位是 1 的瓶子中的水；以此类推下去。&lt;br/&gt;这样，每个老鼠第二天的死活情况就决定了毒水瓶子二进制码这一位的数字：老鼠死，对应 1，反之为 0.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看懂后你也许会说：啊~~~原来是二进制啊~~~&lt;/p&gt;
&lt;p&gt;可我要说：这道题和二进制无关，其本质是建立一组映射关系。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;毒药状态&lt;/code&gt;到&lt;code&gt;小鼠生死状态&lt;/code&gt;的映射关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;1-100 有一瓶是毒药，可能的状态共有 100 种&lt;/li&gt;
&lt;li&gt;7 只小鼠编上号，每只小鼠有生或死两种状态，状态有 2^7 种&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;能让每种可能的&lt;code&gt;毒药状态&lt;/code&gt;映射到不同的&lt;code&gt;小鼠生死状态&lt;/code&gt;，都是这道题的解。&lt;/p&gt;
&lt;p&gt;给出的答案只是&lt;code&gt;A(128, 100)&lt;/code&gt;种方案中的一种。&lt;/p&gt;
&lt;p&gt;例如构造一个让小鼠死亡最少的方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1 是毒药对应小鼠 1 会死，所以 1 只让小鼠 1 喝&lt;/li&gt;
&lt;li&gt;2 是毒药对应小鼠 2 会死，所以 2 只让小鼠 2 喝&lt;br/&gt;...&lt;/li&gt;
&lt;li&gt;7 是毒药对应小鼠 7 会死，所以 7 只让小鼠 7 喝&lt;/li&gt;
&lt;li&gt;8 是毒药对应小鼠 1、2 会死，所以 8 只让小鼠 1、2 喝&lt;br/&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总和二进制打交道，导致我们想问题角度总往二进制上靠，仅得出一些只有程序员才能理解的答案。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 15:13:00 +0000</pubDate>
<dc:creator>apolis</dc:creator>
<og:description>有 100 支一模一样的瓶子，编号 1-100。其中 99 瓶是水，1 瓶是看起来像水的毒药。只要老鼠喝下一小口毒药，一天后就会死。现在你有 7 只老鼠和一天时间，怎么检验出哪个号码的瓶子里是毒药？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apolis/p/10668006.html</dc:identifier>
</item>
<item>
<title>为什么我们要做单元测试？(二) - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10667988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10667988.html</guid>
<description>&lt;p&gt; &lt;span&gt;&lt;strong&gt;引子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我第一篇博客原题叫做&amp;lt;为什么.NET开发者都不写单元测试&amp;gt;,我的本意是想跟.NET技术圈的朋友们一起交流,为什么过去在.NET开发中很少用到单元测试,之后，在公众号文章和博客园的留言中，许多开发者纷纷表示，单元测试作为企业行为，与实施的技术栈不同，不是开发者个人行为，实施单元测试花费的时间精力过于庞大，与实际效果严重不对等，而且如果过度的采用单元测试，也会增加新的测试点，因为单元测试代码本身就需要进行测试等。&lt;/p&gt;
&lt;p&gt;从这些回复可以看出，程序员要不要编写单元测试这种话题，大概做传统开发时，问程序员要不要写项目文档一样充满争议。正如大家都深刻明白项目文档的重要性，但是一旦程序员需要编写项目文档了，往往会对这个事情产生抵触情绪，这实际上是绝大多数开发者的通病。&lt;/p&gt;
&lt;p&gt;单元测试也是这样的矛盾纠结体。在长沙.net技术社区就有不少朋友纷纷表示，他们都曾经试图在公司推动单元测试的应用，但是受到了自上而下的反对声，最终迫于压力，只能放弃。 而之所以阻力这么大，其主要原因是编写单元测试会增加额外的时间，因为编写单元测试，不仅仅只是编写一个简单的测试入口，而是一系列步骤，但是领导要求在最短的时间看到效果，并且有的领导还经常改变主意，如果设计了一个优秀的单元测试用例，有时候甚至会因为无法适应需求的变化，而最终腐烂。 &lt;/p&gt;
&lt;p&gt;显然，使用单元测试和更高的单元测试的代码覆盖率，大概是一个试金石。过去在长沙还很少有企业会问开发者会不会使用单元测试，但是近年来越来越多的企业会问候选人代码覆盖率的问题，所以作为开发者，可以尝试从单元测试开始,努力提高自己的代码习惯，编写更加高质量的代码。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;有哪些公司在要求编写单元测试？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;过去，单元测试一直是专业软件公司的首选，有一位原诺基亚核心部门的开发者说为诺基亚内部，对单元测试的要求很高，虽然没有达到百分之百，但也有非常高的要求，在《构建之法》中，邹欣老师介绍了微软的开发实践，也对单元测试覆盖率提出了很高的要求。 当然有的读者或许会嗤之以鼻，这些都是古典软件公司，举这些例子有什么意义呢？中国式IT 公司，哪家都是996，哪里还有什么时间实行单元测试？ &lt;/p&gt;
&lt;p&gt;然而，优秀的互联网公司都开始推行devops 作为企业信息化建设过程中的最佳实践标准，持续集成和持续发布都对单元测试有很高的要求，例如在阿里巴巴java 开发者手册中，就明确提出了以下一系列指标，要求开发者务必采用单元测试方法，尽可能的提高代码质量。&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;【强制】好的单元测试必须遵守 AIR 原则。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;...此处省略七百字&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;【推荐】单元测试的基本目标：语句覆盖率达到 70% ；核心模块的语句覆盖率和分支覆盖率都要达到 100% &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参见原文阿里巴巴Java 开发者手册，由此可见，单元测试已经作为一种行之有效的手段，显然已经成为了中国优秀互联网企业的必然之选。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;单元测试中的代码覆盖率有什么用？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码覆盖率是单元测试的重要衡量指标，反映了单元测试中测试用例对被测代码的覆盖程度，是对代码的测试质量衡量的重要指标。&lt;/p&gt;
&lt;p&gt;在十年前，博客园《代码覆盖率浅谈》(参考资料1）一文，深入浅出的介绍了单元测试的四种类型， 包括语句覆盖，判定覆盖，条件覆盖，路径覆盖四种类型，作者指出，单元测试覆盖率结果，有以下作用：&lt;/p&gt;
&lt;p&gt;a. 覆盖率数据只能代表你测试过哪些代码，不能代表你是否测试好这些代码。 &lt;/p&gt;
&lt;p&gt;b. 不要过于相信覆盖率数据。&lt;/p&gt;
&lt;p&gt;c. 不要只拿语句覆盖率(行覆盖率)来考核你的测试人员。 &lt;/p&gt;
&lt;p&gt;d. 路径覆盖率 &amp;gt; 判定覆盖 &amp;gt; 语句覆盖 &lt;/p&gt;
&lt;p&gt;e. 测试人员不能盲目追求代码覆盖率，而应该想办法设计更多更好的案例，哪怕多设计出来的案例对覆盖率一点影响也没有。 &lt;/p&gt;
&lt;p&gt;在软件开发过程中盲目的追求的高代码覆盖率，往往得不偿失，尤其是为了提高代码覆盖率而做的单元测试，往往只会成为累赘。&lt;/p&gt;
&lt;p&gt;合理的操作形式应该是基于实际用例出发，设定更多的用例场景，实现基于用户场景驱动的单元测试覆盖，像在阿里巴巴开发者手册中说的，测试人员与开发人员配合，共同完成测试用例覆盖，就是一种不错的应用实践。&lt;/p&gt;
&lt;p&gt;当然，即便测试缺位，开发者也完全应该主动的承担更多单元测试的职能，尽可能多的思考用户场景中可能存在的变数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编写好的单元测试的一些小技巧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　技巧一，多看书肯定是不错的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有朋友问，怎么写好单元测试？有什么书推荐么？我很惭愧，我自己的代码单元测试的覆盖率还相当低，可能没办法给出指导，我想多看书肯定是没错的，而编写单元测试的书，还挺多的，例如这一本，《单元测试的艺术》，一看就是基于C#的，可以试一试。  &lt;/p&gt;
&lt;p&gt; 而想入单元测试的门，可以看看我后面找到的一系列引文，相信能给你带来方便。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　技巧二，运用测试框架&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;1、单元测试框架：XUnit、NUnit、MSTest等.&lt;/p&gt;
&lt;p&gt;2、测试运行工具：xunit.runner.visualstudio 。类似如：Resharper的xUnit runner插件。 &lt;/p&gt;
&lt;p&gt;3、模拟框架：Moq、RhinoMocks、NSubstitute、FakeItEasy等。   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　技巧三，灵活的运用事务回滚或内存数据库，避免单元测试数据污染正常数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前者是阿里巴巴开发者手册中提到的一种方法，在有的场景下也挺实用的，不过有开发者指出，可以使用模拟内存数据库来解决这个问题更为妥当，例如使用Effort.EF6，通过nuget获取，使得创建一个伪造的、供EF容易使用的内存数据库成为可能。与这类似的，还可以使用HttpSimulator来模拟http 请求。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　技巧四，使用依赖注入和单例模式改良不可测代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态类为代码编写带来了许多便利，但是也使得代码测试变得相对困难，而使用单例模式进行改良则使得操作更可控。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;人生苦短，撸码不易。从选择成为开发者的那一天起，我们就被迫承受了许多压力，尤其是技术发展的不确定性，更是如此，你永远也不知道自己当下的选择是否正确，说不定你今天最为熟悉的技术或框架，明天就凉凉了。尤其是现在的各种自媒体，时不时的发几篇文章来输出焦虑，巴不得天天说优胜劣汰才能获得读者的关注一般，让开发者们压力更大。 &lt;/p&gt;
&lt;p&gt;我觉得，技术是解决问题的方法，而良好的代码习惯则是自身心法，尤其是单元测试，更是一种好习惯，先别总想着担心自己被淘汰，努力的使自己习惯更好，总会获得无穷收获。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;参考资料1:《&lt;a href=&quot;https://www.cnblogs.com/coderzh/archive/2009/03/29/1424344.html?tt_from=copy_link&amp;amp;utm_source=copy_link&amp;amp;utm_medium=toutiao_ios&amp;amp;utm_campaign=client_share&quot; target=&quot;_blank&quot;&gt;代码覆盖率浅谈&lt;/a&gt;》.&lt;/p&gt;
&lt;p&gt;参考资料2：《&lt;a href=&quot;https://www.infoq.cn/article/test-coverage-ocd&quot; target=&quot;_blank&quot;&gt;代码覆盖率强迫症&lt;/a&gt;》.&lt;br/&gt;参考资料3: 《&lt;a href=&quot;https://www.cnblogs.com/jacksundatashare/p/5083352.html.&quot; target=&quot;_blank&quot;&gt;代码覆盖率 (Code Coverage)从简到繁&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;参考资料4，《&lt;a href=&quot;http://www.cnblogs.com/zhaopei/p/UnitTesting.html?from=singlemessage&amp;amp;isappinstalled=0&quot; target=&quot;_blank&quot;&gt;C#单元测试，带你快速入门&lt;/a&gt;》.&lt;/p&gt;
&lt;p&gt;【版权声明】 &lt;/p&gt;
&lt;p&gt;本博客版权归作者和博客园共有，作品来自于长沙.NET技术社区成员【邹溪源】，有兴趣了解长沙.NET技术社区详情，请关注公众号【DotNET技术圈】,作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 15:12:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>引子 当我第一篇博客原题叫做&lt;为什么.NET开发者都不写单元测试&gt;,我的本意是想跟.NET技术圈的朋友们一起交流,为什么过去在.NET开发中很少用到单元测试,之后，在公众号文章和博客园的留</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10667988.html</dc:identifier>
</item>
<item>
<title>2.CentOS6.5下的DNS主从区域传送配置 - 浩天四哥</title>
<link>http://www.cnblogs.com/boltkiller/p/10667987.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/boltkiller/p/10667987.html</guid>
<description>&lt;p&gt;接着《1.CentOS6.5下的基础DNS配置》来说，主从区域传送只能让从服务器来进行传送，不给任何人传送，我们看看上一章节《1.CentOS6.5下的基础DNS配置》是否可传送：&lt;/p&gt;
&lt;p&gt;[root@localhost etc]# &lt;span&gt;&lt;strong&gt;dig -t axfr itox.com.cn @192.168.100.3&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;;; Connection to 192.168.100.3#53(192.168.100.3) for itox.com.cn failed: host unreachable.&lt;br/&gt;[root@localhost etc]# dig -t axfr itox.com.cn @192.168.100.3&lt;/p&gt;
&lt;p&gt;; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.9.4-RedHat-9.9.4-73.el7_6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; -t axfr itox.com.cn @192.168.100.3&lt;br/&gt;;; global options: +cmd&lt;br/&gt;itox.com.cn. 600 IN SOA ns1.itox.com.cn. admin.itox.com.cn. 2019040701 7200 540 259200 36000&lt;br/&gt;itox.com.cn. 600 IN NS ns1.itox.com.cn.&lt;br/&gt;itox.com.cn. 600 IN MX 10 mail.itox.com.cn.&lt;br/&gt;*.itox.com.cn. 600 IN A 192.168.100.3&lt;br/&gt;ftp.itox.com.cn. 600 IN A 192.168.100.25&lt;br/&gt;kali2.itox.com.cn. 600 IN A 192.168.100.22&lt;br/&gt;kali3.itox.com.cn. 600 IN A 192.168.100.23&lt;br/&gt;mail.itox.com.cn. 600 IN A 192.168.100.24&lt;br/&gt;nfs.itox.com.cn. 600 IN A 192.168.100.28&lt;br/&gt;ns1.itox.com.cn. 600 IN A 192.168.100.3&lt;br/&gt;radius.itox.com.cn. 600 IN CNAME ftp.itox.com.cn.&lt;br/&gt;samba.itox.com.cn. 600 IN A 192.168.100.27&lt;br/&gt;www.itox.com.cn. 600 IN A 192.168.100.26&lt;br/&gt;itox.com.cn. 600 IN SOA ns1.itox.com.cn. admin.itox.com.cn. 2019040701 7200 540 259200 36000&lt;br/&gt;;; Query time: 2 msec&lt;br/&gt;;; SERVER: 192.168.100.3#53(192.168.100.3)&lt;br/&gt;;; WHEN: 日 4月 07 22:25:18 CST 2019&lt;br/&gt;;; XFR size: 14 records (messages 1, bytes 343)&lt;/p&gt;
&lt;p&gt;这里我们看到是能够被任何人传送的，因此我们在配置DNS主从传送的时候还需要改动一下named.conf只能被从服务器（这里实验指定192.168.100.24为从服务器），开始配置之前，主从服务器都改一下/etc/sysconfig/named文件，默认里面全部是注释的，加一行在末尾：OPTIONS=&quot;-4&quot;,去除去IPv6的解析，只解析IPv4，OPTIONS选项的值可以是：whatever、-4、-6中的一个，不然在主从传送过程中会看到一堆的：named network unreachable resolving，&lt;span&gt;&lt;strong&gt;主从都要改&lt;/strong&gt;&lt;/span&gt;，记得！&lt;/p&gt;
&lt;p&gt;区域传送DNS&lt;span&gt;&lt;strong&gt;主服务器named.conf如下，有改动的位置专注标红&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;options {&lt;br/&gt;directory &quot;/var/named&quot;;&lt;br/&gt;#recursion yes;&lt;br/&gt;&lt;span&gt;allow-recursion { 192.168.100.0/24; };  #这里只允许给192.168.100.0/24的网段递归查询，实际中几乎不会用&lt;/span&gt;&lt;br/&gt;};&lt;/p&gt;
&lt;p&gt;zone &quot;.&quot; IN {&lt;br/&gt;type hint;&lt;br/&gt;file &quot;named.ca&quot;;&lt;br/&gt;};&lt;/p&gt;
&lt;p&gt;zone &quot;localhost&quot; IN {&lt;br/&gt;type master;&lt;br/&gt;file &quot;named.localhost&quot;;&lt;br/&gt;&lt;span&gt;allow-transfer { none; };&lt;/span&gt;&lt;br/&gt;};&lt;/p&gt;
&lt;p&gt;zone &quot;0.0.127&quot; IN {&lt;br/&gt;type master;&lt;br/&gt;file &quot;named.loopback&quot;;&lt;br/&gt;&lt;span&gt;allow-transfer { none; };&lt;/span&gt;&lt;br/&gt;};&lt;/p&gt;
&lt;p&gt;zone &quot;itox.com.cn&quot; IN {&lt;br/&gt;type master;&lt;br/&gt;file &quot;itox.com.cn.zone&quot;;&lt;br/&gt;&lt;span&gt;allow-transfer { 192.168.100.24; };&lt;/span&gt;&lt;br/&gt;};&lt;/p&gt;
&lt;p&gt;zone &quot;100.168.192.in-addr.arpa&quot; IN {&lt;br/&gt;type master;&lt;br/&gt;file &quot;192.168.100.zone&quot;;&lt;br/&gt;&lt;span&gt;allow-transfer { 192.168.100.24; };&lt;/span&gt;&lt;br/&gt;};&lt;/p&gt;
&lt;p&gt;把主服务器的named.conf复制到从服务器相同的位置，然后改动部分内容，就可以启动服务了，从服务器named.conf如下：&lt;/p&gt;
&lt;p&gt;options {&lt;br/&gt;directory &quot;/var/named&quot;;&lt;br/&gt;#recursion yes;&lt;br/&gt;allow-recursion { 192.168.100.0/24; };&lt;br/&gt;};&lt;/p&gt;
&lt;p&gt;zone &quot;.&quot; IN {&lt;br/&gt;type hint;&lt;br/&gt;file &quot;named.ca&quot;;&lt;br/&gt;};&lt;/p&gt;
&lt;p&gt;zone &quot;localhost&quot; IN {&lt;br/&gt;type master;&lt;br/&gt;file &quot;named.localhost&quot;;&lt;br/&gt;allow-transfer { none; };&lt;br/&gt;};&lt;/p&gt;
&lt;p&gt;zone &quot;0.0.127&quot; IN {&lt;br/&gt;type master;&lt;br/&gt;file &quot;named.loopback&quot;;&lt;br/&gt;allow-transfer { none; };&lt;br/&gt;};&lt;/p&gt;
&lt;p&gt;zone &quot;itox.com.cn&quot; IN {&lt;br/&gt;type &lt;span&gt;slave&lt;/span&gt;;      #这里改成从哦&lt;br/&gt;&lt;span&gt;file &quot;slaves/itox.com.cn.zone&quot;;    #传送过来的文件放在slaves目录下，这个文件夹named用户是用权限写入的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;masters { 192.168.100.3; };       #指定主服务器在哪里&lt;/span&gt;&lt;br/&gt;&lt;span&gt;masterfile-format text;   #这个写上，不然你看到的主服务器传送过来的/var/named/slaves/itox.com.cn的正反向文件是乱码，raw格式的，无法读。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;allow-transfer { none; };  #我就是从了，我就不给别人传送了&lt;/span&gt;&lt;br/&gt;};&lt;/p&gt;
&lt;p&gt;zone &quot;100.168.192.in-addr.arpa&quot; IN {&lt;br/&gt;type slave;&lt;br/&gt;&lt;span&gt;file &quot;slaves/192.168.100.zone&quot;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;masterfile-format text;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;masters { 192.168.100.3; };&lt;/span&gt;&lt;br/&gt;&lt;span&gt;allow-transfer { none; };&lt;/span&gt;&lt;br/&gt;};&lt;/p&gt;

&lt;p&gt;好了，配置完成，验证办法很简单，直接看看/var/named/slaves目录下，文件过来了没有。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 15:09:00 +0000</pubDate>
<dc:creator>浩天四哥</dc:creator>
<og:description>接着《1.CentOS6.5下的基础DNS配置》来说，主从区域传送只能让从服务器来进行传送，不给任何人传送，我们看看上一章节《1.CentOS6.5下的基础DNS配置》是否可传送： [root@loc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/boltkiller/p/10667987.html</dc:identifier>
</item>
</channel>
</rss>