<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>前端与算法 leetcode 7. 整数反转 - 墨抒颖</title>
<link>http://www.cnblogs.com/moshuying/p/11903463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moshuying/p/11903463.html</guid>
<description>&lt;h2 id=&quot;前端与算法-leetcode-7.-整数反转&quot;&gt;# 前端与算法 leetcode 7. 整数反转&lt;/h2&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入: 123
输出: 321&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 示例 2:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入: -123
输出: -321&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例 3:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入: 120
输出: 21
注意:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-integer&quot;&gt;7. 整数反转&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概要&quot;&gt;概要&lt;/h2&gt;
&lt;h2 id=&quot;提示&quot;&gt;提示&lt;/h2&gt;
&lt;p&gt;这里需要注意溢出条件是&lt;code&gt;2**31到-(2**31)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;解析&quot;&gt;解析&lt;/h2&gt;
&lt;p&gt;递归,循环,注意溢出条件&lt;/p&gt;
&lt;h3 id=&quot;解法&quot;&gt;解法&lt;/h3&gt;
&lt;p&gt;如果不考虑溢出问题的话是非常简单的(才怪),用js解这道题有两个坑,第一个是变量提升,整数进行乘除取余等操作时,会转成浮点数,获得的结果存在&lt;code&gt;0!=0&lt;/code&gt;的情况,我们需要给这些结果用&lt;code&gt;Math.floor&lt;/code&gt;或者&lt;code&gt;~~&lt;/code&gt;进行舍去取余操作才可以&lt;/p&gt;
&lt;h2 id=&quot;算法&quot;&gt;算法&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * @param {number} x
 * @return {number}
 */
var reverse = function (x) {
  let ans = 0;
  while (x !== 0) {
    ans = ans * 10 + ~~(x % 10);
    x = ~~(x / 10);
  }
  return (ans &amp;gt;= (2 ** 31) || ans &amp;lt;= -(2 ** 31)) ? 0 : ans;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;传入测试用例的运行结果&quot;&gt;传入测试用例的运行结果&lt;/h2&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;input:123
output:321&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;执行结果&quot;&gt;执行结果&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;执行用时 :80 ms, 在所有 javascript 提交中击败了94.48%的用户
内存消耗 :35.8 MB, 在所有 javascript 提交中击败了36.81%的用户&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;github仓库&quot;&gt;GitHub仓库&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/moshuying/AlgorithmAndBlog&quot;&gt;7. 整数反转&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Nov 2019 00:48:00 +0000</pubDate>
<dc:creator>墨抒颖</dc:creator>
<og:description>[TOC] 前端与算法 leetcode 7. 整数反转 题目描述 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 示例 2: 示例 3: 假设我们的环境只能存储</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/moshuying/p/11903463.html</dc:identifier>
</item>
<item>
<title>HTML中的表格标签 - 阿桥_Qiao</title>
<link>http://www.cnblogs.com/aqiao/p/11895824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aqiao/p/11895824.html</guid>
<description>&lt;p&gt;  表格是网页制作中使用最多的工具之一，在制作网页时，使用表格可以更清晰地排列数据。但是在实际制作过程中，表格更多用在网页布局的定位上。很多网页都是以表格布局的。这是因为表格在文本和图像的位置控制方面都有很强的功能。&lt;/p&gt;

&lt;p&gt;表格由行、列、和单元格3部分组成，一般通过3个标记来创建，分别是表格标记&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;、行标记&lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;、和单元格标记&lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;。表格的各种属性都要在表格的开始标记&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;和表格的结束标记&lt;code&gt;&amp;lt;/table&amp;gt;&lt;/code&gt;之间才有效。&lt;/p&gt;
&lt;p&gt;创建表格的四个元素：&lt;/p&gt;
&lt;p&gt;table、tr、th、td&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;tabel&amp;gt;...&amp;lt;/table&amp;gt;&lt;/code&gt;:整个表格以&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;标记开始、&lt;code&gt;&amp;lt;/table&amp;gt;&lt;/code&gt;标记结束。&lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;lt;tr&amp;gt;...&amp;lt;/tr&amp;gt;&lt;/code&gt;：表格的一行，那么以为着有几对&lt;code&gt;&amp;lt;tr&amp;gt;&amp;lt;/td&amp;gt;&lt;/code&gt;，表格就有几行。&lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;lt;td&amp;gt;...&amp;lt;/td&amp;gt;&lt;/code&gt;:表格的一个单元格，一行中包含几对&lt;code&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/code&gt;,说明一行中就有几列。&lt;/p&gt;&lt;p&gt;&lt;code&gt;&amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;&lt;/code&gt;:表格的头部的一个单元格，表格表头。&lt;/p&gt;
&lt;p&gt;表格中列的个数，取决于一行中数据单元格的个数&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;th&amp;gt;动物名称&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;物种&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;生活习性&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;食性&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;老虎&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;猫科动物&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;单独活动&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;肉食&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;狮子&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;猫科动物&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;集群&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;肉食&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;大象&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;哺乳纲动物&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;群居&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;草食&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1778803/201911/1778803-20191120104735931-1950859732.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;内容仅做实例参考，不保证其真实性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;表格标题caption&quot;&gt;&lt;strong&gt;表格标题caption&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;一个表格只能有一个标题&lt;/p&gt;
&lt;p&gt;在上述代码的&lt;code&gt;&amp;lt;table&amp;gt;&amp;lt;/table&amp;gt;&lt;/code&gt;间添加&lt;code&gt;&amp;lt;caption&amp;gt;动物世界&amp;lt;/caption&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1778803/201911/1778803-20191120104755296-1984907396.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;表格宽度与高度&quot;&gt;&lt;strong&gt;表格宽度与高度&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表格宽度为&lt;code&gt;width&lt;/code&gt;，高度为&lt;code&gt;height&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;语法为&lt;code&gt;&amp;lt;table width=&quot;500&quot; height=&quot;130&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1778803/201911/1778803-20191120104823755-198270168.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以下功能实现与此类似，将不进行示例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;表格表头对齐方式align&quot;&gt;&lt;strong&gt;表格表头对齐方式align&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;语法为&lt;code&gt;&amp;lt;table align=&quot;对齐方式&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在对齐方式中填入相应的属性值：&lt;/p&gt;
&lt;p&gt;left:左对齐&lt;br/&gt;center：居中&lt;br/&gt;right：右对齐&lt;/p&gt;
&lt;h2 id=&quot;表格边框宽度border&quot;&gt;&lt;strong&gt;表格边框宽度border&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;border值不设置时或设置为0时，显示为无边框&lt;/p&gt;
&lt;p&gt;语法为&lt;code&gt;&amp;lt;table border=&quot;5&quot;&amp;gt;&lt;/code&gt; , 5为边框宽度&lt;/p&gt;
&lt;h2 id=&quot;表格边框颜色bordercolor&quot;&gt;&lt;strong&gt;表格边框颜色bordercolor&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;语法为&lt;code&gt;&amp;lt;table bordercolor=&quot;#66ccff&quot;&amp;gt;&lt;/code&gt; ， 各颜色对应的具体编码可从网上查找&lt;/p&gt;
&lt;h2 id=&quot;表格内框宽度cellspacing&quot;&gt;&lt;strong&gt;表格内框宽度cellspacing&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表格内框宽度属性用于设置表格内部每个单元格之间的间距&lt;/p&gt;
&lt;p&gt;语法为&lt;code&gt;&amp;lt;table cellspacing=&quot;内框宽度值&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;表内文字与边框边距cellpadding&quot;&gt;&lt;strong&gt;表内文字与边框边距cellpadding&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在默认情况下，单元格里的内容会紧贴着表格的边框，这样看上去会非常拥挤，可用词语法设置其间距离&lt;/p&gt;
&lt;p&gt;语法为&lt;code&gt;&amp;lt;table cellspadding=&quot;文字与边框距离值&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;表格背景颜色bgcolor&quot;&gt;&lt;strong&gt;表格背景颜色bgcolor&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;语法为&lt;code&gt;&amp;lt;table bgcolor=&quot;7fffaa&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;表格背景图像background&quot;&gt;&lt;strong&gt;表格背景图像background&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;语法为&lt;code&gt;&amp;lt;table background=&quot;图片链接&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;表格表首标记thead&quot;&gt;&lt;strong&gt;表格表首标记thead&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表首样式的开始标记是&lt;code&gt;&amp;lt;thead&amp;gt;&lt;/code&gt;，结束标记是&lt;code&gt;&amp;lt;/thead&amp;gt;&lt;/code&gt;。它用于定义表格最上端表首的样式，可以设置背景颜色、文字对齐方式、文字垂直方式等。&lt;/p&gt;
&lt;h2 id=&quot;表主体标记tbody&quot;&gt;&lt;strong&gt;表主体标记tbody&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表主体标记与表首标记功能类似，表主体样式用于统一设计表主体部分的样式，标记为&lt;code&gt;&amp;lt;tbody&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;tfoot&amp;gt;&lt;/code&gt;用于定义表尾样式&lt;/p&gt;

&lt;h2 id=&quot;表格行属性设置&quot;&gt;&lt;strong&gt;表格行属性设置&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表格中行属性的设置与表格的属性设置类似，只需要将相关的属性值添加在行标签中即可，如&lt;code&gt;&amp;lt;tr width=&quot;5&quot; height=&quot;3&quot; align=&quot;content&quot; bordercolor=&quot;#66ccff&quot; cellspacing=&quot;3&quot;&amp;gt;&lt;/code&gt;&lt;br/&gt;多个参数值用空格隔开&lt;/p&gt;
&lt;h2 id=&quot;表格行对齐方式&quot;&gt;&lt;strong&gt;表格行对齐方式&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表格中行对齐方式除了上面在表头对齐方式中介绍的水平对齐方式&lt;code&gt;align&lt;/code&gt;，还有垂直对齐方式&lt;code&gt;valign&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;语法为&lt;code&gt;&amp;lt;tr valign=&quot;对齐方式&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可设置的值有三个：&lt;code&gt;top&lt;/code&gt;、&lt;code&gt;middle&lt;/code&gt;、&lt;code&gt;bottom&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;valign&lt;/code&gt;也可用于单元格属性&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;单元格大小&quot;&gt;&lt;strong&gt;单元格大小&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;语法为&lt;code&gt;&amp;lt;td width=&quot;8&quot; height=&quot;5&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;水平跨度colspan&quot;&gt;&lt;strong&gt;水平跨度colspan&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在设计表格时，有时需要将两个或多个相邻单元格合成一个单元格&lt;/p&gt;
&lt;p&gt;语法为&lt;code&gt;&amp;lt;td colspan=&quot;跨度的列数&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;垂直跨度rowspan&quot;&gt;&lt;strong&gt;垂直跨度rowspan&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;单元格除了可以在水平方向上跨列，还可以在垂直方向上跨行&lt;/p&gt;
&lt;p&gt;语法为&lt;code&gt;&amp;lt;td rowspan=&quot;跨度的行数&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;给出一段实例代码：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;table width=&quot;500&quot; height=&quot;300&quot; align=&quot;content&quot; border=&quot;5&quot; bordercolor=&quot;#66ccff&quot; cellspacing=&quot;3&quot; bgcolor=&quot;7fffaa&quot;&amp;gt;
        &amp;lt;caption&amp;gt;动物世界&amp;lt;/caption&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;th&amp;gt;动物名称&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;物种&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;生活习性&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;食性&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr align=&quot;center&quot;&amp;gt;
        &amp;lt;td&amp;gt;老虎&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;猫科动物&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;单独活动&amp;lt;/td&amp;gt;
        &amp;lt;td rowspan=&quot;2&quot;&amp;gt;肉食&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr align=&quot;center&quot;&amp;gt;
        &amp;lt;td&amp;gt;狮子&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;猫科动物&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;集群&amp;lt;/td&amp;gt;
        
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr align=&quot;center&quot;&amp;gt;
        &amp;lt;td&amp;gt;大象&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;哺乳纲动物&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;群居&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;草食&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1778803/201911/1778803-20191120104842150-323346420.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Nov 2019 00:47:00 +0000</pubDate>
<dc:creator>阿桥_Qiao</dc:creator>
<og:description>表格是网页制作中使用最多的工具之一，在制作网页时，使用表格可以更清晰地排列数据。但是在实际制作过程中，表格更多用在网页布局的定位上。很多网页都是以表格布局的。这是因为表格在文本和图像的位置控制方面都有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aqiao/p/11895824.html</dc:identifier>
</item>
<item>
<title>小白学 Python 爬虫（1）：开篇 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11903446.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11903446.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191121084432777-914812268.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我用 Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;各位同学大家好，好久不见（可能只有一两天没见：囧）~~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191121084433024-2015649180.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先讲一件事情，昨天为啥没更新。&lt;/p&gt;
&lt;p&gt;emmmmmmmmm，当然是因为加班啦，快到年底了，公司项目比较忙，最近的更新频率会有下降，请各位海涵。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191121084433180-2047835070.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;废话不多说，开始今天的正题，从题目大家应该已经猜到了，小编要开始更新一个新的系列《小白学 Python 爬虫》，介于大家水平参差不齐，建议没有 Python 基础第一次接触的同学先看下小编之前更新的&lt;a href=&quot;https://www.geekdigging.com/tags/Python-%E5%9F%BA%E7%A1%80/&quot;&gt;《小白学 Python 系列》&lt;/a&gt;，大致了解下 Python 的语法规则以及一些基础用法。&lt;/p&gt;
&lt;p&gt;先自己吹一波水，这个系列小编计划做成长期更新系列，目前 Python 爬虫涉及到的第三方的类库有些多，还会有很多有关 web 编程方面的基础知识，因面向的群体主要是小白，这些内容都需要一一介绍，这会是一个大的系列。额，远超之前的 Python 基础。&lt;/p&gt;
&lt;p&gt;额，忘了件事儿，再加一句题外话，最近公众号后台留言有点略多，很多同学的问题来不及回复就被留言冲的看不到了，这里请大家有问题可以添加小编的个人微信：allen_6174（放心加，这个是小编的个人生活微信号，和工作号是分开的）。&lt;/p&gt;
&lt;p&gt;算了，顺便再打个广告吧：本爬虫系列文章后续将于公众号首发，个人博客站次日同步，第三方博客平台不定期同步，泥萌要不要关注我一下呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191121084433616-323299092.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是爬虫&quot;&gt;什么是爬虫？&lt;/h2&gt;
&lt;p&gt;不管是作为程序员还是小白，对爬虫这个词应该都不陌生，毕竟最近也发生了很多事情，很多人因为某些事情都进去了，具体情况我就不提了，容易被和谐。有想知道的同学可以翻一翻我之前公众号转的一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/UQlAwuXwB1p8KyTHoSy1HQ&quot;&gt;《只因写了一段爬虫，公司200多人被抓！》&lt;/a&gt;。最近的网络报道此类的新闻还有很多。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191121084433792-1771365521.webp&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在正式内容开始之前，提醒各位读者敬畏法律，热爱生活。&lt;/p&gt;
&lt;p&gt;老规矩，先百度一波看看百度释义：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;讲点接地气的就是我们把平时使用的网络看成是一张大蜘蛛网，每个站点看做是这张网上面的一个一个的节点，爬虫好比是一只蜘蛛，在这张网上面按照一定的或者已经设计好的路线，找到目标节点获取所需资源。&lt;/p&gt;
&lt;h2 id=&quot;为什么使用爬虫&quot;&gt;为什么使用爬虫&lt;/h2&gt;
&lt;p&gt;平时我们在上网的时候，看到一些感兴趣的网络资源，可以使用复制黏贴的方式将这些资源下载回来，比如看知乎的时候，一些回答很精彩的高赞回答，数据量小的时候，我们动动鼠标右键也就搞定了，但是如果这种数据量非常大，有时候可以大到超出你的想像，再用鼠标右键复制黏贴就有些捉襟见肘了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191121084433952-1236687001.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上图是博主在用的鼠标，非广告，型号我就不贴了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这时，我们就需要勤劳的爬虫出马了，爬虫这种“生物”，可以全天候24小时候不间断工作，只需提供必要的网络和电力，就可以一直勤劳的工作下去，让你解放双手，再也无需人工使用 CV 大法了。&lt;/p&gt;
&lt;p&gt;可以看出，爬虫非常适合帮我们做两类事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;大量数据的提取，在一定规则条件下。&lt;/li&gt;
&lt;li&gt;完全自动化，无需人工过多干预。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;想像一下，当老板让你搜索某类信息时，写一只勤劳的小爬虫，自己在旁边泡上一杯清茶，拿起手机开始愉快的玩耍，时不时的看这只爬虫有没有完成工作，这场景一下让我想起了万恶的资本家压榨劳动力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201911/908359-20191121084434103-1286276483.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本篇文章为各位同学介绍了爬虫的基本概念，让大家对爬虫有一个大致的了解，以便后续章节的学习。开胃菜吃完了，下一节我们就要开始吃大餐了哟，你准备好了吗？&lt;/p&gt;
</description>
<pubDate>Thu, 21 Nov 2019 00:45:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我用 Python 引言 各位同学大家好，好久不见（可能只有一两天没见：囧）~~~ 先讲一件事情，昨天为啥没更新。 emmmmmmmmm，当然是因为加班啦，快到年底了，公司项目比较忙，最近的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11903446.html</dc:identifier>
</item>
<item>
<title>Leetcode算法【114. 二叉树展开为链表】 - 小酒窝</title>
<link>http://www.cnblogs.com/dimple91/p/11903440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dimple91/p/11903440.html</guid>
<description>&lt;p&gt;上周通过一位小伙伴，加入了一个氛围很好的小群，人不多，但是大家保持着对知识的渴望，让我很感动。&lt;/p&gt;
&lt;p&gt;我自己也有一个群，人数也不多，但是能真正互动起来一起学习，一起进步的，还是太少。所以，现在也在学习如何让自己成为更好的群主，带动群活跃，带动一个社群活跃，带动小伙伴们一起进步，是我的愿景。当然，也不否认现在很多群友正在朝着积极向上的方向走着，我要做的，也是时刻保持对知识的渴望，做到“持续学习”。&lt;/p&gt;
&lt;p&gt;谁让咱是一名优秀的程序员呢。上周日也学习了一遍递归，还通过一个二叉树的例子来简单介绍了下。我之前解决二叉树相关的问题，基本上用的都是递归，结果那天分享的朋友用了队列，让我眼前一亮，原来程序的世界真是奇妙。&lt;/p&gt;
&lt;p&gt;所以，思想碰撞真的是一件很开心的事情。大家在持续的学习，持续的交流中，会打开一些思维定式，接纳更多的方式，你们觉得呢？&lt;/p&gt;
&lt;h3 id=&quot;algorithm-leetcode算法&quot;&gt;Algorithm LeetCode算法&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/&quot;&gt;114. 二叉树展开为链表&lt;/a&gt;&lt;br/&gt;(&lt;code&gt;https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：给定一个二叉树，原地将它展开为链表。&lt;/p&gt;
&lt;p&gt;例如，给定二叉树&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    1  
   / \
  2   5
 / \   \
3   4   6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将其展开为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文题解参考地址：&lt;code&gt;https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;解法后序遍历法&quot;&gt;解法：后序遍历法&lt;/h4&gt;
&lt;p&gt;题目其实就是将二叉树通过右指针，组成一个链表。&lt;/p&gt;
&lt;p&gt;从例子上可以看出，其实就是让我们把二叉树，通过先序遍历展示出来。所以我们首先想到的是能不能用先序遍历的方式，每遍历一个节点，就将上一个节点的右指针更新为当前节点。&lt;/p&gt;
&lt;p&gt;先序遍历的顺序是 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6，如下：&lt;/p&gt;
&lt;p&gt;遍历到&lt;code&gt;2&lt;/code&gt;，把&lt;code&gt;1&lt;/code&gt;的右指针指向&lt;code&gt;2&lt;/code&gt;，即变成 &lt;code&gt;1-&amp;gt;2 3 4 5 6&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;遍历到&lt;code&gt;3&lt;/code&gt;，把&lt;code&gt;2&lt;/code&gt;的右指针指向&lt;code&gt;3&lt;/code&gt;，即变成 &lt;code&gt;1-&amp;gt;2-&amp;gt;3 4 5 6&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;理想状况下，以此类推即可。&lt;/p&gt;
&lt;p&gt;但是，如果我们把&lt;code&gt;1&lt;/code&gt;的右指针指向&lt;code&gt;2&lt;/code&gt;，那么这时候&lt;code&gt;1&lt;/code&gt;原本的右节点就丢失了，也就是我们后续找不到&lt;code&gt;5&lt;/code&gt;这个节点。&lt;/p&gt;
&lt;p&gt;所以，又引起了我们的思考，如何才能不让&lt;code&gt;5&lt;/code&gt;丢失呢？后序遍历可以吗？&lt;/p&gt;
&lt;p&gt;也就是我们依次遍历&lt;code&gt;6 5 4 3 2 1&lt;/code&gt;，然后每遍历一个节点就将当前节点的右指针更新为上一个节点，如下：&lt;/p&gt;
&lt;p&gt;遍历到&lt;code&gt;5&lt;/code&gt;，把&lt;code&gt;5&lt;/code&gt;的右指针指向&lt;code&gt;6&lt;/code&gt;，即变成&lt;code&gt;6 &amp;lt;- 5 4 3 2 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;遍历到&lt;code&gt;4&lt;/code&gt;，把&lt;code&gt;4&lt;/code&gt;的右指针指向&lt;code&gt;5&lt;/code&gt;，即变成&lt;code&gt;6 &amp;lt;- 5 &amp;lt;- 4 3 2 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以此类推，因为我们更新当前右指针的时候，当前节点的右节点已经访问过了，所以就不会存在丢失节点的问题。&lt;/p&gt;
&lt;p&gt;把这个转变成后序遍历，遍历顺序就是 右子树 -&amp;gt; 左子树 -&amp;gt; 根节点&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 将二叉树构建完成
public static void main(String[] args) {
    TreeNode treeNode = new TreeNode(1);
    treeNode.left = new TreeNode(2);
    treeNode.left.left = new TreeNode(3);
    treeNode.left.right = new TreeNode(4);
        
    treeNode.right = new TreeNode(5);
    treeNode.right.right = new TreeNode(6);
    flattern(treeNode);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 
 * @Title      :  
 * @Description: 后续遍历
 * @param treeNode
 * @return     :void
 * @throws
 */
public static void flattern(TreeNode root) {
    Stack&amp;lt;TreeNode&amp;gt; treeNodes = new Stack&amp;lt;&amp;gt;();
    TreeNode current = root;
    TreeNode preview = null;
        
    while (current != null || !treeNodes.isEmpty()) {
        while (current != null) {
            // 添加根节点
            treeNodes.push(current);
            // 添加右节点
            current = current.right;
        }
            
        // 已经访问到最右边的节点
        current = treeNodes.peek();
        // 当右节点已经被访问过或者左节点不存在的情况，就去访问根节点
        if (current.left == null || current.left == preview) {
            treeNodes.pop();
            current.right = preview;
            current.left = null;
            preview = current;
            current = null;
        } else {
            current = current.left;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;补充说明先序遍历&quot;&gt;补充说明：先序遍历&lt;/h4&gt;
&lt;p&gt;在介绍着后序遍历的时候，我们先用先序遍历的例子以及缺陷，来说明为什么我们选择后序遍历。那么，就一定不能用先序遍历了吗？显然，答案是不对的。&lt;/p&gt;
&lt;p&gt;有一种特殊的先序遍历，提前将右节点保存到栈中，我们利用这种遍历方式就可以防止右节点的丢失。因为栈是先进后出，所以我们先将右节点入栈。&lt;/p&gt;
&lt;p&gt;再根据上面先序遍历的分析，因为我们用栈保存了右孩子，所以不需要担心右孩子丢失了。用一个 pre 变量保存上次遍历的节点即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void flatten1(TreeNode root) { 
    if (root == null){
        return;
    }
    Stack&amp;lt;TreeNode&amp;gt; s = new Stack&amp;lt;TreeNode&amp;gt;();
    s.push(root);
    TreeNode pre = null;
    while (!s.isEmpty()) {
        TreeNode temp = s.pop(); 
        if(pre!=null){
            pre.right = temp;
            pre.left = null;
        }
        if (temp.right != null){
            s.push(temp.right);
        }
        if (temp.left != null){
             s.push(temp.left);
        } 
        pre = temp;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;结语&quot;&gt;结语&lt;/h4&gt;
&lt;p&gt;二叉树，是一颗神奇的树，理论上我们都可以通过先序、中序、后续遍历来拆解他，得到我们想要的结果，在做题的时候也是如此。&lt;/p&gt;
&lt;p&gt;但是真正体现到编程的世界里，还是和理论做题有一点不同，编程需要我们用机器语言是实现，去思考，去打通我们算法的任督二脉，这样就是LeetCode存在的魅力，他是一个氛围很好的社区，拥有它，就拥有了算法的世界，拥有了进阶的可能。&lt;/p&gt;
&lt;p&gt;安利了LeetCode，安利下自己的号，尽量做到每周一题，分模块的学习。小编最大的后悔就是没能在大学学好&lt;strong&gt;数据结构和算法&lt;/strong&gt;这门课，现在吃亏了，吃大亏了。好在万变不离其宗，只要通过自己的勤奋，没有什么是不可能的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加油，奔跑吧兄弟们！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者：Dimple&lt;/p&gt;
&lt;p&gt;公众号：奔跑吧攻城狮&lt;/p&gt;
&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 21 Nov 2019 00:42:00 +0000</pubDate>
<dc:creator>小酒窝</dc:creator>
<og:description>上周通过一位小伙伴，加入了一个氛围很好的小群，人不多，但是大家保持着对知识的渴望，让我很感动。 我自己也有一个群，人数也不多，但是能真正互动起来一起学习，一起进步的，还是太少。所以，现在也在学习如何让</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dimple91/p/11903440.html</dc:identifier>
</item>
<item>
<title>EFCore批量操作，你真的清楚吗 - nodotnet</title>
<link>http://www.cnblogs.com/JulianHuang/p/11897788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JulianHuang/p/11897788.html</guid>
<description>&lt;h2 id=&quot;4569-1574217432309&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;EntityFramework Core有许多新的特性，其中一个重要特性便是批量操作。&lt;/p&gt;
&lt;p&gt;批量操作意味着不需要为每次Insert/Update/Delete操作发送单独的命令，而是在一次SQL请求中发送批量组合指令。&lt;/p&gt;
&lt;div readability=&quot;17.289248334919&quot;&gt;
&lt;h2 id=&quot;5117-1574219865513&quot;&gt;EFCore批量操作实践&lt;/h2&gt;
&lt;p&gt;批处理是期待已久的功能，社区多次提出要求。现在EFCore支持开箱即用确实很棒，可以提高应用程序的性能和速度。&lt;/p&gt;
&lt;h3 id=&quot;4818-1574219915545&quot;&gt;P1 对比实践&lt;/h3&gt;
&lt;p&gt;下面以常见的批量插入为例，使用SQL Server Profiler 观察实际产生并执行的SQL语句。&lt;/p&gt;
&lt;div readability=&quot;55.053191489362&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; category table中添加了3条记录并执行保存&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; c= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SampleDBContext())
{
    c.Categories.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Category() { CategoryID = &lt;span&gt;1&lt;/span&gt;, CategoryName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Clothing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
    c.Categories.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Category() { CategoryID = &lt;span&gt;2&lt;/span&gt;, CategoryName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Footwear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
    c.Categories.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Category() { CategoryID = &lt;span&gt;3&lt;/span&gt;, CategoryName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Accessories&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
    c.SaveChanges();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 当执行SaveChanges(), 从SQL Profiler追溯到的SQL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
exec sp_executesql N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SET NOCOUNT ON;&lt;/span&gt;
&lt;span&gt;INSERT INTO [Categories] ([CategoryID], [CategoryName])
VALUES (@p0, @p1),(@p2, @p3),(@p4, @p5);&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;@p0 int,@p1 nvarchar(4000),@p2 int,@p3 nvarchar(4000),@p4 int,@p5 nvarchar(4000)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
@p0&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;,@p1=N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Clothing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,@p2=&lt;span&gt;2&lt;/span&gt;,@p3=N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Footwear&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,@p4=&lt;span&gt;3&lt;/span&gt;,@p5=N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Accessories&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如你所见，批量插入没有产生3个独立的语句，而是被组合为一个传参存储过程脚本(用列值作为参数)；如果使用EF6执行相同的代码，则在SQL Server Profiler中将看到3个独立的插入语句 。下面左右是EFCore、EF6批量插入的对比截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201911/587720-20191120144159690-1848460507.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587720/201911/587720-20191120144251199-737500968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;① 就性能和速度而言，EFCore批量插入更具优势。&lt;/p&gt;
&lt;p&gt;② 若数据库是针对云部署，EF6运行这些查询，还将产生额外的流量成本。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt; 经过验证：EFCore批量更新、批量删除功能，EFCore均发出了使用sp_executesql存储过程+批量参数构建的SQL脚本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt; P2 深入分析&lt;/h3&gt;
&lt;p&gt;起关键作用的 sp_executesql存储过程： 可以多次执行的语句或批处理 （可带参）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; Syntax for SQL Server, Azure SQL Database, Azure SQL Data Warehouse, Parallel Data Warehouse  &lt;/span&gt;
&lt;span&gt;  
sp_executesql &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; @stmt = &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; statement  
&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;   
  { , [ @params = &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;@parameter_name data_type [ OUT | OUTPUT ][ ,...n ]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }   
     { , &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; @param1 = &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt; ,...n &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; }  
]  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意官方限制： &lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;The amount of data that can be passed by using this method is limited by the number of parameters allowed. SQL Server procedures can have, at most, 2100 parameters. Server-side logic is required to assemble these individual values into a table variable or a temporary table for processing.       &lt;span&gt;// SQL存储过程最多可使用2100个参数&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;P3 豁然开朗&lt;/h3&gt;
&lt;div readability=&quot;37.7334609076&quot;&gt;
&lt;p&gt;SqlServer  sp_executesql存储过程最多支持2100个批量操作形成的列值参数，所以遇到很大数量的批量操作，EFCore SqlProvider会帮我们将批量操作分块传输， &lt;/p&gt;
&lt;p&gt;这也是我们在实际大批量使用时看到分块发送的原因。&lt;/p&gt;
&lt;p&gt;同时EFCore开放了【配置关系型数据库批量操作大小】：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected override void OnConfiguring(DbContextOptionsBuilder optionbuilder)
{
    string sConnString &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; @&quot;Server&lt;span&gt;=&lt;/span&gt;localhost;&lt;span&gt;Database&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;EFSampleDB;Trusted_Connection&lt;span&gt;=&lt;/span&gt;&lt;span&gt;true;&quot;;
    optionbuilder.UseSqlServer(sConnString , b &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt; b.MaxBatchSize(&lt;span&gt;1&lt;/span&gt;));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 批量操作的SQL语句数量，也可设定为1禁用批量插入
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;1768-1574221189575&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;① EFCore 相比EF6，已经支持批量操作，能有效提高应用程序的性能&lt;/p&gt;
&lt;p&gt;② EFCore的批量操作能力，由对应的DataBaseProvider支撑（Provider实现过程跟背后的存储载体密切相关）&lt;/p&gt;
&lt;p&gt;　　对于SQL关注这个存储过程sp_executesql ， 官方明文显示批量操作的列值参数最多2100 个，这个关键因素决定了在大批量操作的时候 依旧会被分块传输。&lt;/p&gt;
&lt;p&gt;③ 另外一个批量操作的方法，这里也点一下：构造Rawsql【EFCore支持Rawsql】。&lt;/p&gt;
&lt;p&gt;　　sqlite不支持存储过程，为完成批量插入提高性能，可采用此方案。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; insertStr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
insertStr.AppendLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insert into ProfileUsageCounters (profileid,datetime,quota,usage,natureusage) values&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; txt = insertStr.AppendLine(&lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, usgaeEntities.ToList().Select(x =&amp;gt;&lt;span&gt;
{
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;({x.ProfileId},{x.DateTime},{x.Quota},{x.Usage},{x.NatureUsage})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}).ToArray()));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; _context.Database.ExecuteSqlCommandAsync(txt.ToString());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;+ &lt;a href=&quot;https://github.com/aspnet/EntityFrameworkCore/issues/6604&quot;&gt;https://github.com/aspnet/EntityFrameworkCore/issues/6604&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;+ &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/table-valued-parameters?redirectedfrom=MSDN&quot;&gt;https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/table-valued-parameters?redirectedfrom=MSDN&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 21 Nov 2019 00:08:00 +0000</pubDate>
<dc:creator>nodotnet</dc:creator>
<og:description>背景 EntityFramework Core有许多新的特性，其中一个重要特性便是批量操作。 批量操作意味着不需要为每次Insert/Update/Delete操作发送单独的命令，而是在一次SQL请求</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JulianHuang/p/11897788.html</dc:identifier>
</item>
<item>
<title>使用Spring安全表达式控制系统功能访问权限 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11902381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11902381.html</guid>
<description>&lt;h2 id=&quot;一spel表达式权限控制&quot;&gt;一、SPEL表达式权限控制&lt;/h2&gt;
&lt;p&gt;从&lt;code&gt;spring security 3.0&lt;/code&gt;开始已经可以使用&lt;code&gt;spring Expression&lt;/code&gt;表达式来控制授权，允许在表达式中使用复杂的布尔逻辑来控制访问的权限。Spring Security可用表达式对象的基类是SecurityExpressionRoot。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;14.680426098535&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3.5395683453237&quot;&gt;&lt;td&gt;&lt;code&gt;hasRole([role]&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;用户拥有指定的角色时返回true （&lt;code&gt;Spring security&lt;/code&gt;默认会带有&lt;code&gt;ROLE_&lt;/code&gt;前缀）,去除前缀参考&lt;a href=&quot;https://github.com/spring-projects/spring-security/issues/4134&quot;&gt;Remove the ROLE_&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;hasAnyRole([role1,role2])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用户拥有任意一个指定的角色时返回true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;hasAuthority([authority])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;拥有某资源的访问权限时返回true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;hasAnyAuthority([auth1,auth2])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;拥有某些资源其中部分资源的访问权限时返回true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;permitAll&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;永远返回true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;code&gt;denyAll&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;永远返回false&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;anonymous&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当前用户是&lt;code&gt;anonymous&lt;/code&gt;时返回true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;rememberMe&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当前用户是&lt;code&gt;rememberMe&lt;/code&gt;用户返回true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;authentication&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当前登录用户的&lt;code&gt;authentication&lt;/code&gt;对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;fullAuthenticated&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;当前用户既不是&lt;code&gt;anonymous&lt;/code&gt;也不是&lt;code&gt;rememberMe&lt;/code&gt;用户时返回true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;hasIpAddress('192.168.1.0/24'))&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;请求发送的IP匹配时返回true&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;部分朋友可能会对Authority和Role有些混淆。Authority作为资源访问权限可大可小，可以是某按钮的访问权限（如资源ID：biz1），也可以是某类用户角色的访问权限（如资源ID：ADMIN）。当Authority作为角色资源权限时，hasAuthority（'ROLE_ADMIN'）与hasRole（'ADMIN'）是一样的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二spel在全局配置中的使用&quot;&gt;二、SPEL在全局配置中的使用&lt;/h2&gt;
&lt;p&gt;我们可以通过继承WebSecurityConfigurerAdapter，实现相关的配置方法，进行全局的安全配置（之前的章节已经讲过） 。下面就为大家介绍一些如何在全局配置中使用SPEL表达式。&lt;/p&gt;
&lt;h3 id=&quot;url安全表达式&quot;&gt;2.1.URL安全表达式&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;config.antMatchers(&quot;/system/*&quot;).access(&quot;hasAuthority('ADMIN') or hasAuthority('USER')&quot;)
      .anyRequest().authenticated();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们定义了应用&lt;code&gt;/person/*&lt;/code&gt;URL的范围，只有拥有&lt;code&gt;ADMIN&lt;/code&gt;或者&lt;code&gt;USER&lt;/code&gt;权限的用户才能访问这些person资源。&lt;/p&gt;
&lt;h3 id=&quot;安全表达式中引用bean&quot;&gt;2.2.安全表达式中引用bean&lt;/h3&gt;
&lt;p&gt;这种方式，比较适合有复杂权限验证逻辑的情况，当Spring Security提供的默认表达式方法无法满足我们的需求的时候。首先我们定义一个权限验证的RbacService。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component(&quot;rbacService&quot;)
@Slf4j
public class RbacService {
    //返回true表示验证通过
    public boolean hasPermission(HttpServletRequest request, Authentication authentication) {
        //验证逻辑代码
        return true;
    }
    public boolean checkUserId(Authentication authentication, int id) {
        //验证逻辑代码
        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于&quot;/person/{id}&quot;对应的资源的访问，调用rbacService的bean的方法checkUserId进行权限验证，传递参数为authentication对象和person的id。该id为PathVariable，以#开头表示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;config.antMatchers(&quot;/person/{id}&quot;).access(&quot;@rbacService.checkUserId(authentication,#id)&quot;)
      .anyRequest().access(&quot;@rbacService.hasPermission(request,authentication)&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三-method表达式安全控制&quot;&gt;三、 Method表达式安全控制&lt;/h2&gt;
&lt;p&gt;如果我们想实现方法级别的安全配置，&lt;code&gt;Spring Security&lt;/code&gt;提供了四种注解，分别是&lt;code&gt;@PreAuthorize&lt;/code&gt; , &lt;code&gt;@PreFilter&lt;/code&gt; , &lt;code&gt;@PostAuthorize&lt;/code&gt; 和 &lt;code&gt;@PostFilter&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;开启方法级别注解的配置&quot;&gt;3.1.开启方法级别注解的配置&lt;/h3&gt;
&lt;p&gt;在Spring安全配置代码中，加上EnableGlobalMethodSecurity注解，开启方法级别安全配置功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MySecurityConfig extends WebSecurityConfigurerAdapter {&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用preauthorize注解&quot;&gt;3.2 使用PreAuthorize注解&lt;/h3&gt;
&lt;p&gt;@PreAuthorize 注解适合进入方法前的权限验证。只有拥有ADMIN角色才能访问findAll方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@PreAuthorize(&quot;hasRole('ADMIN')&quot;)
List&amp;lt;Person&amp;gt; findAll();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用postauthorize注解&quot;&gt;3.3 使用PostAuthorize注解&lt;/h3&gt;
&lt;p&gt;@PostAuthorize 在方法执行后再进行权限验证,适合根据返回值结果进行权限验证。&lt;code&gt;Spring EL&lt;/code&gt; 提供返回对象能够在表达式语言中获取返回的对象&lt;code&gt;returnObject&lt;/code&gt;。下文代码只有返回值的name等于authentication对象的name才能正确返回，否则抛出异常。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@PostAuthorize(&quot;returnObject.name == authentication.name&quot;)
Person findOne(Integer id);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用prefilter注解&quot;&gt;3.4 使用PreFilter注解&lt;/h3&gt;
&lt;p&gt;PreFilter 针对参数进行过滤,下文代码表示针对ids参数进行过滤，只有id为偶数才能访问delete方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//当有多个对象是使用filterTarget进行标注
@PreFilter(filterTarget=&quot;ids&quot;, value=&quot;filterObject%2==0&quot;)
public void delete(List&amp;lt;Integer&amp;gt; ids, List&amp;lt;String&amp;gt; usernames) {&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用postfilter-注解&quot;&gt;3.5 使用PostFilter 注解&lt;/h3&gt;
&lt;p&gt;PostFilter 针对返回结果进行过滤，特别适用于集合类返回值，过滤集合中不符合表达式的对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@PostFilter(&quot;filterObject.name == authentication.name&quot;)
List&amp;lt;Person&amp;gt; findAll();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Thu, 21 Nov 2019 00:03:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、SPEL表达式权限控制 从 开始已经可以使用 表达式来控制授权，允许在表达式中使用复杂的布尔逻辑来控制访问的权限。Spring Security可用表达式对象的基类是SecurityExpress</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11902381.html</dc:identifier>
</item>
<item>
<title>jwt 实践应用以及特殊案例思考 - 山月水风</title>
<link>http://www.cnblogs.com/xianwang/p/11902364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xianwang/p/11902364.html</guid>
<description>&lt;p&gt;JSON Web Token 是 &lt;a href=&quot;https://tools.ietf.org/html/rfc7519&quot;&gt;rfc7519&lt;/a&gt; 出的一份标准，使用 JSON 来传递数据，用于判定用户是否登录状态。&lt;/p&gt;
&lt;p&gt;jwt 之前，使用 &lt;code&gt;session&lt;/code&gt; 来做用户认证。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以下代码均使用 javascript 编写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;session&quot;&gt;session&lt;/h2&gt;
&lt;p&gt;传统判断是否登录的方式是使用 &lt;code&gt;session + token&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;token&lt;/code&gt; 是指在客户端使用 token 作为用户状态凭证，浏览器一般存储在 &lt;code&gt;localStorage&lt;/code&gt; 或者 &lt;code&gt;cookie&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;session&lt;/code&gt; 是指在服务器端使用 redis 或者 sql 类数据库，存储 user_id 以及 token 的键值对关系，基本工作原理如下。&lt;/p&gt;
&lt;p&gt;在服务器端使用 &lt;code&gt;sessions&lt;/code&gt; 存储键值对&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const sessions = {
  &quot;ABCED1&quot;: 10086,
  &quot;CDEFA0&quot;: 10010
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次客户端请求带权限数据时携带 token，在服务器端根据 token 与 sessions 获取 user_id， 完成认证过程&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function getUserIdByToken (token) {
  return sessions[token]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果存储在 &lt;code&gt;cookie&lt;/code&gt; 中就是经常听到的 &lt;code&gt;session + cookie&lt;/code&gt; 的登录方案。其实存储在 &lt;code&gt;cookie&lt;/code&gt;，&lt;code&gt;localStorage&lt;/code&gt; 甚至 &lt;code&gt;IndexedDB&lt;/code&gt; 或者 &lt;code&gt;WebSQL&lt;/code&gt; 各有利弊，核心思想一致。&lt;/p&gt;
&lt;p&gt;关于 &lt;code&gt;cookie&lt;/code&gt; 以及 &lt;code&gt;token&lt;/code&gt; 优缺点，在 &lt;a href=&quot;https://stackoverflow.com/questions/17000835/token-authentication-vs-cookies&quot;&gt;token authetication vs cookies&lt;/a&gt; 中有讨论。&lt;/p&gt;
&lt;p&gt;如果不使用 cookie，可以采取 &lt;code&gt;localStorage + Authorization&lt;/code&gt; 的方式进行认证，更加无状态化&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// http 的头，每次请求权限接口时，需要携带 Authorization Header
const headers = {
  Authorization: `Bearer ${localStorage.get('token')}`
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.394495412844&quot;&gt;
&lt;p&gt;推荐一个前端的存储库 &lt;a href=&quot;https://github.com/localForage/localForage&quot;&gt;localForage&lt;/a&gt;，使用 &lt;code&gt;IndexedDB&lt;/code&gt;，&lt;code&gt;WebSQL&lt;/code&gt; 以及 &lt;code&gt;IndexedDB&lt;/code&gt; 做键值对存储。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;无状态登录&quot;&gt;无状态登录&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;session&lt;/code&gt; 需要在数据库中保持用户及token对应信息，所以叫 &lt;strong&gt;有状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;试想一下，如何在数据库中不保持用户状态也可以登录。&lt;/p&gt;
&lt;p&gt;第一种方法： &lt;strong&gt;前端直接传 user_id 给服务端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;缺点也特别特别明显，容易被用户篡改成任意 user_id，权限设置形同虚设。不过思路正确，接着往下走。&lt;/p&gt;
&lt;p&gt;改进： &lt;strong&gt;对 user_id 进行对称加密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务端对 user_id 进行对称加密后，作为 token 返回客户端，作为用户状态凭证。比上边略微强点，但由于对称加密，选择合适的算法以及密钥比较重要&lt;/p&gt;
&lt;p&gt;改进： &lt;strong&gt;对 user_id 不需要加密，只需要进行签名，保证不被篡改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这便是 jwt 的思想：user_id，加密算法和签名组成 token 一起存储到客户端，每当客户端请求接口时携带 token，服务器根据 token 解析出加密算法与 user_id 来判断签名是否一致。&lt;/p&gt;
&lt;h2 id=&quot;json-web-token&quot;&gt;Json Web Token&lt;/h2&gt;
&lt;p&gt;jwt 根据 &lt;code&gt;Header&lt;/code&gt;，&lt;code&gt;Payload&lt;/code&gt; 以及 &lt;code&gt;Signature&lt;/code&gt; 三个部分由 &lt;code&gt;.&lt;/code&gt; 拼接而成。&lt;/p&gt;

&lt;p&gt;Header 由非对称加密算法和类型组成，如下&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const header = {
  // 加密算法
  alg: 'HS256',
  type: 'jwt'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;payload&quot;&gt;Payload&lt;/h3&gt;
&lt;p&gt;Payload 中由 &lt;a href=&quot;https://tools.ietf.org/html/rfc7519#section-4.1&quot;&gt;Registered Claim&lt;/a&gt; 以及需要通信的数据组成。这些数据字段也叫 &lt;code&gt;Claim&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Registered Claim&lt;/code&gt; 中比较重要的是 &lt;code&gt;&quot;exp&quot; Claim&lt;/code&gt; 表示过期时间，在用户登录时会设置过期时间。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const payload = {
  // 表示 jwt 创建时间
  iat: 1532135735,

  // 表示 jwt 过期时间
  exp: 1532136735,

  // 用户 id，用以通信
  user_id: 10086
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;signature&quot;&gt;Signature&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Signature&lt;/code&gt; 由 &lt;code&gt;Header&lt;/code&gt;，&lt;code&gt;Payload&lt;/code&gt; 以及 &lt;code&gt;secretOrPrivateKey&lt;/code&gt; 计算而成。&lt;code&gt;secretOrPrivateKey&lt;/code&gt; 作为敏感数据存储在服务器端，可以考虑使用 &lt;code&gt;vault secret&lt;/code&gt; 或者 &lt;code&gt;k8s secret&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于 &lt;code&gt;secretOrPrivateKey&lt;/code&gt;，如果加密算法采用 &lt;code&gt;HMAC&lt;/code&gt;，则为字符串，如果采用 &lt;code&gt;RSA&lt;/code&gt; 或者 &lt;code&gt;ECDSA&lt;/code&gt;，则为 PrivateKey。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 由 HMACSHA256 算法进行签名，secret 不能外泄
const sign = HMACSHA256(base64.encode(header) + '.' + base64.encode(payload), secret)

// jwt 由三部分拼接而成
const jwt = base64.encode(header) + '.' + base64.encode(payload) + '.' + sign&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从生成 jwt 规则可知客户端可以解析出 payload，因此不要在 payload 中携带敏感数据，比如用户密码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;校验过程&quot;&gt;校验过程&lt;/h3&gt;
&lt;p&gt;在生成规则中可知，jwt 前两部分是对 header 以及 payload 的 base64 编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当服务器收到客户端的 token 后，解析前两部分得到 header 以及 payload，并使用 header 中的算法与 secretOrPrivateKey 进行签名，判断与 jwt 中携带的签名是否一致。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;带个问题，如何判断 token 过期？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;
&lt;p&gt;由上可知，jwt 并不对数据进行加密，而是对数据进行签名，保证不被篡改。&lt;strong&gt;除了在登录中可以用到，在进行邮箱校验，图形验证码和短信验证码时也可以用到。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;图形验证码&quot;&gt;图形验证码&lt;/h3&gt;
&lt;p&gt;在登录时，输入密码错误次数过多会出现图形验证码。&lt;/p&gt;
&lt;p&gt;图形验证码的原理是给客户端一个图形，并且在服务器端保存与这个图片配对的字符串，以前也大都通过 session 来实现。&lt;/p&gt;
&lt;p&gt;可以把验证码配对的字符串作为 secret，进行无状态校验。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const jwt = require('jsonwebtoken')

// 假设验证码为字符验证码，字符为 ACDE，10分钟失效
const token = jwt.sign({}, secrect + 'ACDE', { expiresIn: 60 * 10 })

const codeImage = getImageFromString('ACDE')

// 给前端的响应
const res = {
  // 验证码图片的 token，从中可以校验前端发送的验证码
  token,
  // 验证码图片
  codeImage,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;短信验证码与图形验证码同理&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;邮箱校验&quot;&gt;邮箱校验&lt;/h3&gt;
&lt;p&gt;现在网站在注册成功后会进行邮箱校验，具体做法是给邮箱发一个链接，用户点开链接校验成功。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 把邮箱以及用户id绑定在一起
const code = jwt.sign({ email, userId }, secret, { expiresIn: 60 * 30 })

// 在此链接校验验证码
const link = `https://example.com/code=${code}`&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;无状态-vs-有状态&quot;&gt;无状态 VS 有状态&lt;/h2&gt;
&lt;p&gt;关于无状态和有状态，在其它技术方向也有对比，比如 React 的 &lt;code&gt;stateLess component&lt;/code&gt; 以及 &lt;code&gt;stateful component&lt;/code&gt;，函数式编程中的副作用可以理解为状态，http 也是一个无状态协议，需要靠 header 以及 cookie 携带状态。&lt;/p&gt;
&lt;p&gt;在用户认证这里，有无状态是指是否依赖外部数据存储，如 mysql，redis 等。&lt;/p&gt;
&lt;h2 id=&quot;案例&quot;&gt;案例&lt;/h2&gt;
&lt;p&gt;思考以下几个关于登录的问题如何使用 session 以及 jwt 实现，来更加清楚 &lt;code&gt;jwt&lt;/code&gt; 的使用场景&lt;/p&gt;
&lt;h3 id=&quot;当用户注销时如何使该-token-失效&quot;&gt;当用户注销时，如何使该 token 失效&lt;/h3&gt;
&lt;p&gt;因为 jwt 无状态，不保存用户设备信息，没法单纯使用它完成以上问题，可以再利用数据库保存一些状态完成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;session&lt;/code&gt;: 只需要把 user_id 对应的 token 清掉即可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jwt&lt;/code&gt;: 使用 redis，维护一张黑名单，用户注销时把该 token 加入黑名单，过期时间与 jwt 的过期时间保持一致。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;如何允许用户只能在一个设备登录如微信&quot;&gt;如何允许用户只能在一个设备登录，如微信&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;session&lt;/code&gt;: 使用 sql 类数据库，对用户数据库表添加 token 字段并加索引，每次登陆重置 token 字段，每次请求需要权限接口时，根据 token 查找 user_id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jwt&lt;/code&gt;: 假使使用 sql 类数据库，对用户数据库表添加 token 字段(不需要添加索引)，每次登陆重置 token 字段，每次请求需要权限接口时，根据 jwt 获取 user_id，根据 user_id 查用户表获取 token 判断 token 是否一致。另外也可以使用计数器的方法，如下一个问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于这个需求，session 稍微简单些，毕竟 jwt 也需要依赖数据库。&lt;/p&gt;
&lt;h3 id=&quot;如何允许用户只能在最近五个设备登录如诸多播放器&quot;&gt;如何允许用户只能在最近五个设备登录，如诸多播放器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;session&lt;/code&gt;: 使用 sql 类数据库，创建 token 数据库表，有 id, token, user_id 三个字段，user 与 token 表为 1:m 关系。每次登录添加一行记录。根据 token 获取 user_id，再根据 user_id 获取该用户有多少设备登录，超过 5 个，则删除最小 id 一行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jwt&lt;/code&gt;: 使用计数器，使用 sql 类数据库，在用户表中添加字段 count，默认值为 0，每次登录 count 字段自增1，每次登录创建的 jwt 的 Payload 中携带数据 current_count 为用户的 count 值。每次请求权限接口时，根据 jwt 获取 count 以及 current_count，根据 user_id 查用户表获取 count，判断与 current_count 差值是否小于 5&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于这个需求，jwt 略简单些，而使用 session 还需要多维护一张 token 表。&lt;/p&gt;
&lt;h3 id=&quot;如何允许用户只能在最近五个设备登录而且使某一用户踢掉除现有设备外的其它所有设备如诸多播放器&quot;&gt;如何允许用户只能在最近五个设备登录，而且使某一用户踢掉除现有设备外的其它所有设备，如诸多播放器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;session&lt;/code&gt;: 在上一个问题的基础上，删掉该设备以外其它所有的token记录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jwt&lt;/code&gt;: 在上一个问题的基础上，对 count + 5，并对该设备重新赋值为新的 count。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;如何显示该用户登录设备列表-如何踢掉特定用户&quot;&gt;如何显示该用户登录设备列表 / 如何踢掉特定用户&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;session&lt;/code&gt;: 在 token 表中新加列 device&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jwt&lt;/code&gt;: 需要服务器端保持设备列表信息，做法与 session 一样，使用 jwt 意义不大&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;从以上问题得知，如果不需要控制登录设备数量以及设备信息，无状态的 jwt 是一个不错的选择。一旦涉及到了设备信息，就需要对 jwt 添加额外的状态支持，增加了认证的复杂度，此时选用 session 是一个不错的选择。&lt;/p&gt;
&lt;p&gt;jwt 不是万能的，是否采用 jwt，需要根据业务需求来确定。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Nov 2019 23:19:00 +0000</pubDate>
<dc:creator>山月水风</dc:creator>
<og:description>JSON Web Token 是 'rfc7519' 出的一份标准，使用 JSON 来传递数据，用于判定用户是否登录状态。 jwt 之前，使用 来做用户认证。 以下代码均使用 javascript 编</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xianwang/p/11902364.html</dc:identifier>
</item>
<item>
<title>并发编程-硬件加持的CAS操作够快么？ - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/11902198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/11902198.html</guid>
<description>&lt;h3 id=&quot;talk-is-cheap&quot;&gt;Talk is cheap&lt;/h3&gt;
&lt;p&gt;CAS(Compare And Swap)，即比较并交换。是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论位置V的值是否等于A， 都将返回V原有的值。&lt;/p&gt;
&lt;p&gt;CAS的含义是”我认为V的值应该是A，如果是，那我将V的值更新为B，否则不修改并告诉V的值实际是多少“&lt;/p&gt;
&lt;h3 id=&quot;show-you-my-code&quot;&gt;Show you my code&lt;/h3&gt;
&lt;p&gt;在单线程环境中分别使用无锁，加锁以及cas进行十组5亿次累加运算，然后打印出平均耗时。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; /**
 * cas对比加锁测试
 *
 * @author Jann Lee
 * @date 2019-11-21 0:12
 **/
public class CasTest {

    @Test
    public void test() {
        long times = 500_000_000;
        // 记录耗时
        List&amp;lt;Long&amp;gt; elapsedTime4NoLock = new ArrayList&amp;lt;&amp;gt;(10);
        List&amp;lt;Long&amp;gt; elapsedTime4Synchronized = new ArrayList&amp;lt;&amp;gt;(10);
        List&amp;lt;Long&amp;gt; elapsedTime4ReentrantLock = new ArrayList&amp;lt;&amp;gt;(10);
        List&amp;lt;Long&amp;gt; elapsedTime4Cas = new ArrayList&amp;lt;&amp;gt;(10);

        // 进行10组试验
        for (int j = 0; j &amp;lt; 10; j++) {
            // 无锁
            long startTime = System.currentTimeMillis();
            for (long i = 0; i &amp;lt; times; i++) {
            }
            long endTime = System.currentTimeMillis();
            elapsedTime4NoLock.add(endTime - startTime);

            // synchronized 关键字（隐式锁）
            startTime = endTime;
            for (long i = 0; i &amp;lt; times; ) {
                i = addWithSynchronized(i);
            }
            endTime = System.currentTimeMillis();
            elapsedTime4Synchronized.add(endTime - startTime);

            // ReentrantLock 显式锁
            startTime = endTime;
            ReentrantLock lock = new ReentrantLock();
            for (long i = 0; i &amp;lt; times; ) {
                i = addWithReentrantLock(i, lock);
            }
            endTime = System.currentTimeMillis();
            elapsedTime4ReentrantLock.add(endTime - startTime);

            // cas(AtomicLong底层是用cas实现)
            startTime = endTime;
            AtomicLong atomicLong = new AtomicLong();
            while (atomicLong.getAndIncrement() &amp;lt; times) {
            }
            endTime = System.currentTimeMillis();
            elapsedTime4Cas.add(endTime - startTime);
        }

        System.out.println(&quot;无锁计算耗时: &quot; + average(elapsedTime4NoLock) + &quot;ms&quot;);
        System.out.println(&quot;synchronized计算耗时: &quot; + average(elapsedTime4Synchronized) + &quot;ms&quot;);
        System.out.println(&quot;ReentrantLock计算耗时: &quot; + average(elapsedTime4ReentrantLock) + &quot;ms&quot;);
        System.out.println(&quot;cas计算耗时: &quot; + average(elapsedTime4Cas) + &quot;ms&quot;);

    }

    /**
     * synchronized加锁
     */
    private synchronized long addWithSynchronized(long i) {
        i = i + 1;
        return i;
    }

    /**
     * ReentrantLock加锁
     */
    private long addWithReentrantLock(long i, Lock lock) {
        lock.lock();
        i = i + 1;
        lock.unlock();
        return i;
    }

    /**
     * 计算平均耗时
     */
    private double average(Collection&amp;lt;Long&amp;gt; collection) {
        return collection.stream().mapToLong(i -&amp;gt; i).average().orElse(0);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191121010247472-1234350872.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从案例中我们可能看出在单线程环境场景下cas的性能要高于锁相关的操作。当然，在竞争比较激烈的情况下性能可能会有所下降，因为&lt;strong&gt;要不断的重试和回退或者放弃操作&lt;/strong&gt;，这也是CAS的一个缺点所在，因为这些重试，回退等操作通常用开发者来实现。&lt;/p&gt;
&lt;p&gt;CAS的实现并非是简单的代码层面控制的，而是需要硬件的支持，因此在不同的体系架构之间执行的性能差异很大。但是一个很管用的经验法则是：在大多数处理器上，在无竞争的锁获取和释放的”快速代码路径“上的开销，大约是CAS开销的两倍。&lt;/p&gt;
&lt;h3 id=&quot;为何cas如此优秀&quot;&gt;为何CAS如此优秀&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;硬件加持&lt;/strong&gt;，现代大多数处理器都从硬件层面通过一些列指令实现CompareAndSwap(比较并交换)同步原语，进而使操作系统和JVM可以直接使用这些指令实现锁和并发的数据结构。我们可以简单认为，&lt;strong&gt;CAS是将比较和交换合成是一个原子操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JVM对CAS的支持&lt;/strong&gt;， 由于Java程序运行在JVM上，所以应对不同的硬件体系架构的处理则需要JVM来实现。在不支持CAS操作的硬件上，jvm将使用自旋锁来实现。&lt;/p&gt;
&lt;h3 id=&quot;cas的aba问题&quot;&gt;CAS的ABA问题&lt;/h3&gt;
&lt;p&gt;cas操作让我们减少了锁带来的性能损耗，同时也给我们带来了新的麻烦-ABA问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191121010259189-1680816902.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在线程A读取到x的值与执行CAS操作期间，线程B对x执行了两次修改，x的值从100变成200，然后再从200变回100；而后在线程A执行CAS操作过程中并未发现x发生过变化，成功修改了x的值。由于x的值100 -&amp;gt;200-&amp;gt;100,所以称之为ABA的原因。&lt;/p&gt;
&lt;p&gt;魔高一尺道高一丈，解决ABA的问题目前最常用的办法就是给数据加上“版本号”，每次修改数据时同时改变版本号即可。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1055780/201911/1055780-20191121010312149-1300900526.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;qa&quot;&gt;Q&amp;amp;A&lt;/h3&gt;
&lt;p&gt;在竞争比较激烈的情况下，CAS要进行回退，重试等操作才能得到正确的结果，那么CAS一定比加锁性能要高吗？&lt;/p&gt;
</description>
<pubDate>Wed, 20 Nov 2019 17:07:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<og:description>Talk is cheap CAS(Compare And Swap)，即比较并交换。是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liqiangchn/p/11902198.html</dc:identifier>
</item>
<item>
<title>asp.net core 自定义 Policy 替换 AllowAnonymous 的行为 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/11884392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/11884392.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;最近对我们的服务进行了改造，原本内部服务在内部可以匿名调用，现在增加了限制，通过 identity server 来管理 api 和 client，网关和需要访问api的客户端或api服务相互调用通过 &lt;code&gt;client_credencial&lt;/code&gt; 的方式来调用，这样一来我们可以清晰知道哪些 api 服务会被哪些 api/client 所调用，而且安全性来说更好。&lt;br/&gt;为了保持后端服务的代码更好的兼容性，希望能够实现相同的代码通过在 Startup 里不同的配置实现不同的 Authorization 逻辑，原来我们的服务的 &lt;code&gt;Authorize&lt;/code&gt; 都是以 &lt;code&gt;Authorize(&quot;policyName&quot;)&lt;/code&gt; 的形式来写的，这样一来我们只需要修改这个 Policy 的授权配置就可以了。对于 AllowAnonymous 就希望可以通过一种类似的方式来实现，通过自定义一个 Policy 来实现自己的逻辑&lt;/p&gt;
&lt;h2 id=&quot;实现方式&quot;&gt;实现方式&lt;/h2&gt;
&lt;p&gt;将 action 上的 &lt;code&gt;AllowAnonymous&lt;/code&gt; 替换为 &lt;code&gt;Authorize(&quot;policyName&quot;)&lt;/code&gt;，在没有设置 &lt;code&gt;Authorize&lt;/code&gt; 的 controller 上增加 &lt;code&gt;Authorize(&quot;policyName&quot;)&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class AllowAnonymousPolicyTransformer : IApplicationModelConvention
{
    private readonly string _policyName;

    public AllowAnonymousPolicyTransformer() : this(&quot;anonymous&quot;)
    {
    }

    public AllowAnonymousPolicyTransformer(string policyName) =&amp;gt; _policyName = policyName;

    public void Apply(ApplicationModel application)
    {
        foreach (var controllerModel in application.Controllers)
        {
            if (controllerModel.Filters.Any(_ =&amp;gt; _.GetType() == typeof(AuthorizeFilter)))
            {
                foreach (var actionModel in controllerModel.Actions)
                {
                    if (actionModel.Filters.Any(_ =&amp;gt; _.GetType() == typeof(AllowAnonymousFilter)))
                    {
                        var allowAnonymousFilter = actionModel.Filters.First(_ =&amp;gt; _.GetType() == typeof(AllowAnonymousFilter));
                        actionModel.Filters.Remove(allowAnonymousFilter);
                        actionModel.Filters.Add(new AuthorizeFilter(_policyName));
                    }
                }
            }
            else
            {
                if (controllerModel.Filters.Any(_ =&amp;gt; _.GetType() == typeof(AllowAnonymousFilter)))
                {
                    var allowAnonymousFilter = controllerModel.Filters.First(_ =&amp;gt; _.GetType() == typeof(AllowAnonymousFilter));
                    controllerModel.Filters.Remove(allowAnonymousFilter);
                }
                controllerModel.Filters.Add(new AuthorizeFilter(_policyName));
            }
        }
    }
}

public static class MvcBuilderExtensions
{
    public static IMvcBuilder AddAnonymousPolicyTransformer(this IMvcBuilder builder)
    {
        builder.Services.Configure&amp;lt;MvcOptions&amp;gt;(options =&amp;gt;
        {
            options.Conventions.Insert(0, new AllowAnonymousPolicyTransformer());
        });
        return builder;
    }

    public static IMvcBuilder AddAnonymousPolicyTransformer(this IMvcBuilder builder, string policyName)
    {
        builder.Services.Configure&amp;lt;MvcOptions&amp;gt;(options =&amp;gt;
        {
            options.Conventions.Insert(0, new AllowAnonymousPolicyTransformer(policyName));
        });
        return builder;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;controller 中的代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
public class ValuesController : Controller
{
    private readonly ILogger _logger;

    public ValuesController(ILogger&amp;lt;ValuesController&amp;gt; logger)
    {
        _logger = logger;
    }

    // GET api/values
    [HttpGet]
    public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
    {
        var msg = $&quot;IsAuthenticated: {User.Identity.IsAuthenticated} ,UserName: {User.Identity.Name}&quot;;
        _logger.LogInformation(msg);
        return new string[] { msg };
    }

    // GET api/values/5
    [Authorize]
    [HttpGet(&quot;{id:int}&quot;)]
    public ActionResult&amp;lt;string&amp;gt; Get(int id)
    {
        return &quot;value&quot;;
    }
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Startup 中 ConfigureServices 配置：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var anonymousPolicyName = &quot;anonymous&quot;;

services.AddAuthorization(options =&amp;gt;
{
    options.AddPolicy(anonymousPolicyName, builder =&amp;gt; builder.RequireAssertion(context =&amp;gt; context.User.Identity.IsAuthenticated));

    options.DefaultPolicy = new AuthorizationPolicyBuilder(HeaderAuthenticationDefaults.AuthenticationSchema)
        .RequireAuthenticatedUser()
        .RequireAssertion(context =&amp;gt; context.User.GetUserId&amp;lt;int&amp;gt;() &amp;gt; 0)
        .Build();
});

services.AddMvc(options =&amp;gt;
    {
        options.Conventions.Add(new ApiControllerVersionConvention());
    })
    .AddAnonymousPolicyTransformer(anonymousPolicyName)
    ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现效果&quot;&gt;实现效果&lt;/h2&gt;
&lt;p&gt;访问原来的匿名接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201911/489462-20191118183349599-58563317.png&quot; alt=&quot;with custom anonymous policy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;userId 为0访问原来的匿名接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201911/489462-20191118183540249-491492843.png&quot; alt=&quot;with header authentication &amp;amp;&amp;amp; userId &amp;lt;= 0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;userId 大于0访问原来的匿名接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201911/489462-20191118183458495-1444506676.png&quot; alt=&quot;with header authentication &amp;amp;&amp;amp; userId &amp;gt; 0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;userId 为0访问需要登录的接口&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201911/489462-20191118183633482-555500684.png&quot; alt=&quot;with header authentication &amp;amp;&amp;amp; userId &amp;lt;= 0 &amp;amp;&amp;amp; userId &amp;gt;0 required&quot;/&gt;&lt;/p&gt;
&lt;p&gt;userId 大于0访问需要登录的接口&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/489462/201911/489462-20191118183737395-1757946893.png&quot; alt=&quot;with header authentication &amp;amp;&amp;amp; userId &amp;gt; 0 &amp;amp;&amp;amp; userId &amp;gt;0 required&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;注：按照上面的做法已经可以做到自定义 policy 代替 AllowAnonymous 的行为，但是原来返回的401，现在可能返回到就是 403 了&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Wed, 20 Nov 2019 15:12:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>asp.net core 自定义 Policy 替换 AllowAnonymous 的行为 Intro 最近对我们的服务进行了改造，原本内部服务在内部可以匿名调用，现在增加了限制，通过 identit</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/11884392.html</dc:identifier>
</item>
<item>
<title>Mysql备份还有这么多套路，还不了解下？ - 架构文摘</title>
<link>http://www.cnblogs.com/xwgblog/p/11901835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xwgblog/p/11901835.html</guid>
<description>&lt;h3&gt;&lt;span&gt;逻辑备份和物理备份&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;逻辑备份&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;逻辑备份用于备份数据库的结构（CREAET DATABASE、CREATE TABLE）和数据（INSERT），这种备份类型适合数据量小、跨SQL服务器、需要修改数据等场景。如&lt;code&gt;mysqldump&lt;/code&gt;命令就是产生一个逻辑备份工具，使用&lt;code&gt;mysqldump&lt;/code&gt;输出的文件包含&lt;code&gt;CREATE TABLE&lt;/code&gt;和&lt;code&gt;INSERT&lt;/code&gt;语句，能够直接重建表内容和表结构。&lt;/p&gt;
&lt;p&gt;使用逻辑备份有以下优势和劣势：&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;优势&lt;/span&gt;&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;可移植性高，SQL语句可直接适用于其他SQL服务器；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在数据恢复之前可增加、修改数据；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据恢复粒度小可以是服务器、数据库、表级别；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用文本格式，可读性高；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h5&gt;&lt;span&gt;劣势&lt;/span&gt;&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;备份时需要访问mysql服务器，影响其他客户端；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;需要将数据转换成逻辑格式（SQL，CSV）；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果命令运行在客户端，mysql服务器还需要将数据发送给客户端；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;因为输出格式为文本文件，占用空间较大；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4&gt;&lt;span&gt;物理备份&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;物理备份是包括存储数据库内容的目录和文件的副本，这种类型的备份适用于需要在出现问题时快速恢复的大型重要数据库。&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;优势&lt;/span&gt;&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;完整的Mysql文件和目录备份，只需要复制文件不需要转换，速度比逻辑备份更快；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;除了备份数据，还能备份配置文件和日志文件；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不需要运行Mysql服务器就可以完成备份；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;备份工具简单使用cp、scp、tar命令即可完成备份；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h5&gt;&lt;span&gt;劣势&lt;/span&gt;&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;可移植性不高，恢复数据只适用于相同或类似的机器上；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;为了保持数据库文件的一致性，需要停机备份；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;恢复粒度不能按表或用户恢复；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;在线备份和离线备份&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在线备份需要mysql服务器处理运行状态，以便备份工具从mysql服务器中获取数据。离线备份表示mysql服务器处理停止状态。两种备份形式也可以称为“热备份”和“冷备份“。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;在线备份的主要特性&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;备份不需要停机，对其他客户端影响较小其他连接能够正常访问mysql服务器（依赖操作类型，如读操作）；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;备份需要加锁，以免在备份期间对数据做出修改；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4&gt;&lt;span&gt;离线备份的主要特性&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;备份期间服务器不可用；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;备份过程更简单，不会受到客户端的干扰；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;逻辑备份（mysqldump使用）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;mysqldump&lt;/code&gt;属于逻辑备份命令，使用&lt;code&gt;mysqldump&lt;/code&gt;备份的优势是它非常方便和灵活，可以直接编辑输出文件或者使用导入到其他的SQL服务器中去，但是它不能用作备份大量数据的快速解决方案，对于大数据量，即使备份花费的时候可以接受，但是恢复数据也可能会非常缓慢，因为执执行SQL语句会涉及磁盘I/O进行插入，创建索引等。&lt;code&gt;mysqldump&lt;/code&gt;的使用方式非常简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code language-shell=&quot;&quot;&gt;&lt;span&gt;shell&amp;gt;&lt;/span&gt;&lt;span&gt; mysqldump [options] db_name [tbl_name ...]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;shell&amp;gt;&lt;/span&gt;&lt;span&gt; mysqldump [options] --databases db_name ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;shell&amp;gt;&lt;/span&gt;&lt;span&gt; mysqldump [options] --all-databases&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;mysqldump&lt;/code&gt;备份时要注意：&lt;strong&gt;数据库的一致状态，在执行&lt;code&gt;mysqldump&lt;/code&gt;命令时要保证数据不会再发生变更&lt;/strong&gt;，保持数据的一致性有二种方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使Mysql服务器只读&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;使用事务加上隔离级别：&lt;code&gt;REPEATABLE READ&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用&lt;code&gt;REPEATABLE READ&lt;/code&gt;事务隔离级别执行&lt;code&gt;mysqldump&lt;/code&gt;命令（使用事务保持数据库的一致状态）：&lt;/p&gt;
&lt;pre&gt;
&lt;code language-shell=&quot;&quot;&gt;mysqldump --master-data=2 \&lt;br/&gt;--flush-logs  \&lt;br/&gt;--single-transaction  \&lt;br/&gt;--all-databases &amp;gt; /backup/`date +%F-%H`-mysql-all.sql  &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备份参数说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;--master-data: 将二进制日志文件的名称和位置备份&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;--flush-logs: 开始备份之前刷新mysql服务器日志文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;--single-transaction：开始备份之前设置事务隔离级别为&lt;strong&gt;REPEATABLE READ&lt;/strong&gt;然后发送一个&lt;strong&gt;START TRANSACTION&lt;/strong&gt;命令。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;--all-databases：备份所有数据库&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;物理备份（复制原始文件）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;为了保证复制文件的完整性，备份原始文件最好是&lt;strong&gt;停止mysql服务器&lt;/strong&gt;，复制原始文件备份由以下步骤完成：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;停止mysql服务器&lt;br/&gt;&lt;code&gt;$ mysqladmin shutdown&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用合适的工具复制原始数据文件&lt;br/&gt;&lt;code&gt;$ tar cf /tmp/dbbackup.tar ./data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;备份完成后，运行mysql服务器&lt;br/&gt;&lt;code&gt;$ mysqld_safe&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;使用主从备份模式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;mysqldump&lt;/code&gt;和&lt;code&gt;tar&lt;/code&gt;备份或多或少都会对业务产生影响，使用&lt;code&gt;mysqldump&lt;/code&gt;备份需要对数据加锁，加锁就意味着其他客户端操作受到限制。使用&lt;code&gt;tar&lt;/code&gt;命令需要停止服务器直接导致数据库服务器不可用，有没有办法能解决这两种问题呢？答案是有的，就是使用主从备份模式。&lt;/p&gt;
&lt;p&gt;在单机的基础上增加一台Slave机器对Master机器的数据进行同步：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/20/16e88e37b5005cae?w=374&amp;amp;h=315&amp;amp;f=png&amp;amp;s=10551&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;开始备份时对Slave进行备份，这样即使Slave停机或对数据加锁也不会影响业务的正常使用，如果公司有条件或业务非常重要可以选择这种方案来备份数据。&lt;/p&gt;

&lt;p&gt;欢迎关注微信公众号《架构文摘》，高质量技术文章第一时间推送。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/11/19/16e82d0b006032ac?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27413&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;</description>
<pubDate>Wed, 20 Nov 2019 15:10:00 +0000</pubDate>
<dc:creator>架构文摘</dc:creator>
<og:description>逻辑备份和物理备份 逻辑备份 逻辑备份用于备份数据库的结构（CREAET DATABASE、CREATE TABLE）和数据（INSERT），这种备份类型适合数据量小、跨SQL服务器、需要修改数据等场</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xwgblog/p/11901835.html</dc:identifier>
</item>
</channel>
</rss>