<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>极客 Play 玩 Terminal——GitHub 热点速览 Vol.40 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13794102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13794102.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202010/759200-20201010173550985-193880884.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多少人以为暗黑的终端便是一名程序员的工作台，其实上，终端可以不只是一个输入 command 的界面，也可以是本周特推 kb 一样，面向极客的极简命令行知识库管理器，将图像、PDF、视频及文件管理的井井有条方便你快速找寻信息线索。终端，也可是一个游戏机，玩着像是 shapez.io 的图形游戏，靠你的想象力通关终端，抑或是回归本质，只是一个简简单单的磁盘管理工具，仅仅只是简单地用命令便可查看磁盘使用率，还是那个刚知道终端时的输入工具…&lt;/p&gt;
&lt;p&gt;以下内容摘录自微博&lt;a href=&quot;https://www.weibo.com/hellogithub/&quot;&gt;@HelloGitHub&lt;/a&gt; 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 7 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过一周。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;本周特推&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 面向极客的极简命令行知识库管理器：kb&lt;/li&gt;
&lt;li&gt;1.2 极客风磁盘工具：Duf&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;GitHub Trending 周榜&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 可视化组件集：Visx&lt;/li&gt;
&lt;li&gt;2.2 HTTP 工具包：Hetty&lt;/li&gt;
&lt;li&gt;2.3 打包压缩工具：esbuild&lt;/li&gt;
&lt;li&gt;2.4 Steam 图形游戏：shapez.io&lt;/li&gt;
&lt;li&gt;2.5 高可用 UI 组件：headlessui&lt;/li&gt;
&lt;li&gt;2.6 NLP 数据集：Datasets&lt;/li&gt;
&lt;li&gt;2.7 负载测试工具：ali&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1-本周特推&quot;&gt;1. 本周特推&lt;/h2&gt;
&lt;h3 id=&quot;11-面向极客的极简命令行知识库管理器：kb&quot;&gt;1.1 面向极客的极简命令行知识库管理器：kb&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;kb 是一个面向极客的极简命令行知识库管理器。&lt;/p&gt;
&lt;p&gt;虽然 kb 主要针对基于文本的笔记收集，但它也支持非文本文件，比如：图像，PDF，视频和其他文件。主要特性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将包含笔记、指南、过程、备忘单的项目收集到有组织的知识库中；&lt;/li&gt;
&lt;li&gt;根据不同的元数据过滤知识库：标题，类别，标签和其他；&lt;/li&gt;
&lt;li&gt;使用（或不使用）语法高亮显示知识库中的项目；&lt;/li&gt;
&lt;li&gt;使用正则表达式浏览知识库中的 grep；&lt;/li&gt;
&lt;li&gt;导入/导出整个知识库；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/gnebbia/kb&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202010/759200-20201010173712197-653592165.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-极客风磁盘工具：duf&quot;&gt;1.2 极客风磁盘工具：Duf&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开源不到 1 周就获得 2k+ star 的磁盘工具 Duf，可在终端使用命令查看磁盘使用率。Duf 特性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;🎨 用户友好的彩色输出&lt;/li&gt;
&lt;li&gt;💻 调整终端宽度&lt;/li&gt;
&lt;li&gt;🥳 按需排列结果&lt;/li&gt;
&lt;li&gt;🏄‍♂️ 群组 &amp;amp; 设备筛选&lt;/li&gt;
&lt;li&gt;📝 支持 JSON 输出&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/muesli/duf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202010/759200-20201010173723718-1016717878.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-github-trending-周榜&quot;&gt;2. GitHub Trending 周榜&lt;/h2&gt;
&lt;h3 id=&quot;21-可视化组件集：visx&quot;&gt;2.1 可视化组件集：Visx&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2000+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Visx 是可复用、低阶的可视化组件集合，它结合了 d3 的强大功能和 React 更新 DOM 的优势来生成你的可视化组件。而上周时隔 Visx 发布三年之后，Airbnb 使用 TypeScript 重写并发布了 Visx 1.0 正式版。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/airbnb/visx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202010/759200-20201010173734304-604836774.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-http-工具包：hetty&quot;&gt;2.2 HTTP 工具包：Hetty&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1750+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt; Hetty 是一个用于安全研究的 HTTP 工具包。它的目标是希望成为像 Burp Suite Pro 这样的商业软件的开源替代品，拥有为 infosec 和 bug 奖励社区量身定制的强大功能。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/dstotijn/hetty&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202010/759200-20201010173747198-1783856656.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-打包压缩工具：esbuild&quot;&gt;2.3 打包压缩工具：esbuild&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1050+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个 JavaScript 打包和压缩程序。它用于打包 JavaScript 和 TypeScript 代码以在网络上分发。目前 esbuild 有两个基准测试用于衡量 esbuild 的性能，esbuild 比测试的其他 JavaScript 打包程序 快至少 100 倍。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/evanw/esbuild&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202010/759200-20201010173759500-269475905.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;24-steam-图形游戏：shapezio&quot;&gt;2.4 Steam 图形游戏：shapez.io&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;shapez.io 的源代码，shapez.io 是一款 Steam 游戏，在无边际的地图上建造工厂、自动化生产与组合愈加复杂的图形的游戏。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/tobspr/shapez.io&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202010/759200-20201010173810358-999677078.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;25-高可用-ui-组件：headlessui&quot;&gt;2.5 高可用 UI 组件：headlessui&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：650+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;headlessui 是一组无风格的、高可用的 UI 组件，它被设计可完美集成 CSS，headlessui 有对应 Vue、React 包。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/tailwindlabs/headlessui&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202010/759200-20201010173822859-1130189263.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;26-nlp-数据集：datasets&quot;&gt;2.6 NLP 数据集：Datasets&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Datasets 是一个轻量级和可扩展的库，可以方便地共享和访问自然语言处理（NLP）的数据集和评估指标等，可用于 PyTorch、TensorFlow、NumPy 和 Pandas。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/huggingface/datasets&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202010/759200-20201010173833622-1347572239.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;27-负载测试工具：ali&quot;&gt;2.7 负载测试工具：ali&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：550+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ali 是一个受 vegeta 和 jplot 启发的负载测试工具，它带有一个嵌入式的基于终端的 UI，可实时绘制指标，因此可以在终端上执行实时分析。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/nakabonne/ali&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202010/759200-20201010173844133-638727683.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-推荐阅读&quot;&gt;3. 推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 40 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 &lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub&quot;&gt;HelloGitHub&lt;/a&gt; issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 11 Oct 2020 00:45:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub-小鱼干 多少人以为暗黑的终端便是一名程序员的工作台，其实上，终端可以不只是一个输入 command 的界面，也可以是本周特推 kb 一样，面向极客的极简命令行知识库管理器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13794102.html</dc:identifier>
</item>
<item>
<title>[源码阅读] 阿里SOFA服务注册中心MetaServer(2)  - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/13789353.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/13789353.html</guid>
<description>&lt;p&gt;SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列将带领大家一起分析其MetaServer的实现机制，本文为第二篇，介绍MetaServer基本功能，比如注册，存储，通知，续约等。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;942.19282279073&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列将带领大家一起分析其MetaServer的实现机制，本文为第二篇，介绍MetaServer基本功能，比如注册，存储，通知，续约等。&lt;/p&gt;

&lt;h3 id=&quot;11-leader入口&quot;&gt;1.1 Leader入口&lt;/h3&gt;
&lt;p&gt;MetaServer 的业务启动是从setLeaderProcessListener开始。&lt;/p&gt;
&lt;p&gt;前面提到，MetaServer 集群内部基于 Raft 协议选举和复制，只要不超过 1⁄2 节点宕机，就可以对外服务。&lt;/p&gt;
&lt;p&gt;Raft 协议由三个部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;领导人选举（Leader Election）&lt;/li&gt;
&lt;li&gt;日志复制（Log Replication）&lt;/li&gt;
&lt;li&gt;安全性（Safety）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果使用JRaft, 需要实现其状态机，而在MetaServer之中， jraft FSM 的具体实现是 ServiceStateMachine类（后文中会有大量 Raft 相关内容）。&lt;/p&gt;
&lt;p&gt;在 raft 选出了MetaServer leader之后，ServiceStateMachine会调用 setLeaderProcessListener，其中又调用到了registerCurrentNode，这样就在MetaServer中注册了当前Meta节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;raftServer.setLeaderProcessListener(new LeaderProcessListener() {
    @Override
    public void startProcess() {
        executorManager.startScheduler();
        PeerId leader = new PeerId(NetUtil.getLocalAddress().getHostAddress(),
            metaServerConfig.getRaftServerPort());
        registerCurrentNode();  //
        raftServer.sendNotify(leader, &quot;leader&quot;);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其运行堆栈如下 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;register:51, MetaServerRegistry (com.alipay.sofa.registry.server.meta.registry)
registerCurrentNode:203, RaftExchanger (com.alipay.sofa.registry.server.meta.remoting)
access$200:56, RaftExchanger (com.alipay.sofa.registry.server.meta.remoting)
startProcess:105, RaftExchanger$1 (com.alipay.sofa.registry.server.meta.remoting)
lambda$onLeaderStart$2:234, ServiceStateMachine (com.alipay.sofa.registry.jraft.bootstrap)
run:-1, 318295790 (com.alipay.sofa.registry.jraft.bootstrap.ServiceStateMachine$$Lambda$191)
call:511, Executors$RunnableAdapter (java.util.concurrent)
run$$$capture:266, FutureTask (java.util.concurrent)
run:-1, FutureTask (java.util.concurrent)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;12-注册&quot;&gt;1.2 注册&lt;/h3&gt;
&lt;p&gt;注册行为由 Registry 完成。注册接口实现为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Registry&amp;lt;T extends Node&amp;gt; {
    NodeChangeResult setNodes(List&amp;lt;T&amp;gt; nodes);
    NodeChangeResult register(T node);
    void cancel(String connectId, NodeType nodeType);
    void evict();
    void renew(T node, int duration);
    void getOtherDataCenterNodeAndUpdate(NodeType nodeType);
    DataCenterNodes getDataCenterNodes(NodeType nodeType);
    NodeChangeResult getAllNodes(NodeType nodeType);
    void pushNodeListChange(NodeType nodeType);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体实现举例是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MetaServerRegistry implements Registry&amp;lt;Node&amp;gt; {  
    @Override
    public NodeChangeResult register(Node node) {
        StoreService storeService = ServiceFactory.getStoreService(node.getNodeType());
        return storeService.addNode(node);
    }            
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Registry 根据不同的节点类型，获取对应的&lt;code&gt;StoreService&lt;/code&gt;完成添加节点服务，这里节点类型就是&quot;META&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;node = {MetaNode@6342} &quot;MetaNode{ip=192.168.1.2}&quot;
 nodeType = {Node$NodeType@6369} &quot;META&quot;
 nodeUrl = {URL@6370} &quot;URL{address='192.168.1.2:0'}&quot;
 dataCenter = &quot;DefaultDataCenter&quot;
 name = &quot;192.168.1.2&quot;
 regionId = null
 nodeStatus = {Node$NodeStatus@6373} &quot;INIT&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;storeService 就是从上文 ServiceFactory 介绍的 storeServiceMap 中提取。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;MetaNode&lt;/code&gt;，其对应 storeService 实现为 &lt;code&gt;MetaStoreService&lt;/code&gt; ，所以就会用 &lt;code&gt;MetaStoreService&lt;/code&gt; 完成存储。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;storeServiceMap = {HashMap@6394}  size = 3
 {Node$NodeType@6454} &quot;SESSION&quot; -&amp;gt; {SessionStoreService@6455} 
 {Node$NodeType@6369} &quot;META&quot; -&amp;gt; {MetaStoreService@6456} 
 {Node$NodeType@6457} &quot;DATA&quot; -&amp;gt; {DataStoreService@6458} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;13-存储服务&quot;&gt;1.3 存储服务&lt;/h3&gt;
&lt;p&gt;Node 然后由 &lt;code&gt;StoreService&lt;/code&gt; 存储到 &lt;code&gt;Repository&lt;/code&gt; 中，具体举例 &lt;code&gt;MetaStoreService&lt;/code&gt; 实现为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MetaStoreService implements StoreService&amp;lt;MetaNode&amp;gt; {
    @RaftReference(uniqueId = &quot;metaServer&quot;)
    private RepositoryService&amp;lt;String, RenewDecorate&amp;lt;MetaNode&amp;gt;&amp;gt; metaRepositoryService;

    @Override
    public NodeChangeResult addNode(MetaNode metaNode) {
        NodeChangeResult nodeChangeResult;
        String ipAddress = metaNode.getNodeUrl().getIpAddress();
        write.lock();
        try {
            //存放到repository（自动通过jraft同步给集群）
            metaRepositoryService.put(ipAddress, new RenewDecorate(metaNode,
                RenewDecorate.DEFAULT_DURATION_SECS));

            //触发通知(需要通知data/session)
            nodeChangeResult = getNodeChangeResult();
            firePushDataListTask(nodeChangeResult, &quot;addMetaNode&quot;);
            firePushSessionListTask(nodeChangeResult, &quot;addMetaNode&quot;);
        } finally {
            write.unlock();
        }
        return nodeChangeResult;
    }  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;预先把存储流程总结如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                                                                                      +------------------------------+
                                                     +-----------------------+        |  Map(String, NodeRepository) |
                                                +---&amp;gt;+ metaRepositoryService +-------&amp;gt;+  registry                    |
                                                |    +-----------------------+        +------------------------------+
                                                |
                                                |
                                                |
Register +-------------------+  addNode   +-----+-----------+
+------&amp;gt; | MetaServerRegistry| +--------&amp;gt; | MetaStoreService|
         +-------------------+            +-----+-----------+
                                                |
                                                |
                                                |            +-------------------+     +--------------+       +----------------------+
                                                +----------&amp;gt; |TaskListenerManager+---&amp;gt; |TaskDispatcher| +---&amp;gt; |DataNodeChangePushTask|
                                               sendTaskEvent +-------------------+     +--------------+       +----------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机上参见：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201009224341528-1176675905.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;14-repository服务&quot;&gt;1.4 Repository服务&lt;/h3&gt;
&lt;p&gt;Repository算是一个比较经典的概念了，封装数据查询和存储逻辑。定义（来自Martin Fowler的《企业应用架构模式》）：Mediates between the domain and data mapping layers using a collection-like interface for accessing domain objects。&lt;/p&gt;
&lt;p&gt;Repository是一个独立的层，介于领域层与数据映射层（数据访问层）之间。它的存在让领域层感觉不到数据访问层的存在，即提供一个类似集合的接口提供给领域层进行领域对象的访问。&lt;/p&gt;
&lt;p&gt;Repository可以被认为是仓库管理员，领域层需要什么东西只需告诉仓库管理员，由仓库管理员把东西拿给它，并不需要知道东西实际放在哪。&lt;/p&gt;
&lt;p&gt;在这里，Node并没有持久化，而是存储在内存中。于是就要 &lt;u&gt;&lt;strong&gt;重点注意&lt;/strong&gt;，虽然Repository存储一个Node是很简单的，但是在分布式状态下，如何保证 &quot;在一个Repository中新Node的存储状态&quot; 可以拓展到集群其他节点中？而且能保证 数据一致性呢？&lt;/u&gt;&lt;/p&gt;
&lt;h4 id=&quot;141-metarepositoryservice&quot;&gt;1.4.1 MetaRepositoryService&lt;/h4&gt;
&lt;p&gt;&lt;u&gt;MetaRepositoryService 内部的存储是在集群内部由Raft协议来保证数据一致性的&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;后端 Repository 可以看作 SOFAJRaft 的状态机，任何对 Map 的操作都会在集群内部，交由 Raft 协议进行同步，从而达到集群内部的一致。从代码中可以看到&lt;code&gt;MetaRepositoryService&lt;/code&gt;加上了 &lt;code&gt;RaftService&lt;/code&gt; 注解，这就是Raft的部分实现。&lt;/p&gt;
&lt;p&gt;为了更好的说明，我们这里提前介绍下 Raft 的两个注解：&lt;code&gt;RaftReference&lt;/code&gt; 和 &lt;code&gt;RaftService&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这两个注解可以认为是封装好Raft的，呈现给Registry的接口。&lt;u&gt;RaftReference 对应了客户端代理，RaftService对应着服务端的实现&lt;/u&gt;。为什么要这么做？&lt;u&gt;&lt;strong&gt;因为需要维护数据一致性，所以必须把单纯的本地调用转换为异步网络调用，这样才能用raft协议保证数据一致性&lt;/strong&gt;&lt;/u&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;RepositoryService&lt;/code&gt; 的具体实现类都加了 &lt;code&gt;@RaftService&lt;/code&gt; 注解，这样就说明自己是一个服务端；&lt;/li&gt;
&lt;li&gt;凡是 &lt;strong&gt;引用&lt;/strong&gt; &lt;code&gt;RepositoryService&lt;/code&gt; 的地方，都加了 &lt;code&gt;@RaftReference&lt;/code&gt;，这样调用 &lt;code&gt;RepositoryService&lt;/code&gt; 的函数就相当于客户端调用到服务端；&lt;/li&gt;
&lt;li&gt;凡是加了 &lt;code&gt;@RaftReference&lt;/code&gt; 注解的属性，都会被动态代理类替换，其代理实现见 &lt;code&gt;ProxyHandler&lt;/code&gt; 类，即将方法调用，封装为 &lt;code&gt;ProcessRequest&lt;/code&gt;，通过 RaftClient 发送给 RaftServer。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;回到&lt;code&gt;MetaRepositoryService&lt;/code&gt;代码，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RaftService(uniqueId = &quot;metaServer&quot;)
public class MetaRepositoryService extends AbstractSnapshotProcess
                          implements RepositoryService&amp;lt;String, RenewDecorate&amp;lt;MetaNode&amp;gt;&amp;gt; {
    @Autowired
    private NodeConfig                                 nodeConfig;
    /**
     * meta node store and version
     */
    private Map&amp;lt;String/*dataCenter*/, NodeRepository&amp;gt; registry          = new ConcurrentHashMap&amp;lt;&amp;gt;();
    private Set&amp;lt;String&amp;gt;                                snapShotFileNames = new HashSet&amp;lt;&amp;gt;();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;142-put操作&quot;&gt;1.4.2 put操作&lt;/h4&gt;
&lt;p&gt;当有新节点 时候，MetaRepositoryService 会进行 put 操作。&lt;u&gt;在具体put函数调用中，实际上是将方法调用，封装为 &lt;code&gt;ProcessRequest&lt;/code&gt;，通过 RaftClient 发送给 RaftServer。这样就由 Raft 协议保证了数据一致性&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public RenewDecorate&amp;lt;MetaNode&amp;gt; put(String ipAddress, RenewDecorate&amp;lt;MetaNode&amp;gt; metaNode,
                                   Long currentTimeMillis) {
    try {
        String dataCenter = metaNode.getRenewal().getDataCenter();
        NodeRepository&amp;lt;MetaNode&amp;gt; metaNodeRepository = registry.get(dataCenter);
        if (metaNodeRepository == null) {
            NodeRepository&amp;lt;MetaNode&amp;gt; nodeRepository = new NodeRepository&amp;lt;&amp;gt;(dataCenter,
                new ConcurrentHashMap&amp;lt;&amp;gt;(), currentTimeMillis);
            // put操作实际上是调用到了服务端
            metaNodeRepository = registry.put(dataCenter, nodeRepository); 
            if (metaNodeRepository == null) {
                metaNodeRepository = nodeRepository;
            }
        }
        metaNodeRepository.setVersion(currentTimeMillis);
        Map&amp;lt;String/*ipAddress*/, RenewDecorate&amp;lt;MetaNode&amp;gt;&amp;gt; metaNodes = metaNodeRepository
            .getNodeMap();
        RenewDecorate oldRenewDecorate = metaNodes.get(ipAddress);
        metaNodes.put(ipAddress, metaNode);
    } 
    return metaNode;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;143-节点数据存储&quot;&gt;1.4.3 节点数据存储&lt;/h4&gt;
&lt;p&gt;节点数据的存储，其本质上是存储在内存的哈希表中，其存储结构为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// RepositoryService 底层存储
Map&amp;lt;String/*dataCenter*/, NodeRepository&amp;gt; registry;

// NodeRepository 底层存储
Map&amp;lt;String/*ipAddress*/, RenewDecorate&amp;lt;T&amp;gt;&amp;gt; nodeMap;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将&lt;code&gt;RenewDecorate&lt;/code&gt;存储到该 Map 中，整个节点注册的流程就完成了，至于如何和 Raft 协议进行结合和数据同步，后续会介绍。&lt;/p&gt;
&lt;p&gt;节点移除的逻辑类似，将节点信息从该 Map 中删除，也会存储一个变更事件到队列。&lt;/p&gt;
&lt;p&gt;最后结果如下 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;this = {MetaRepositoryService@6905} 
 registry = {ConcurrentHashMap@6907}  size = 1
  &quot;DefaultDataCenter&quot; -&amp;gt; {NodeRepository@7251} 
 snapShotFileNames = {HashSet@6904}  size = 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;15-jraft实现数据一致性&quot;&gt;1.5 jraft实现数据一致性&lt;/h3&gt;
&lt;p&gt;成员列表数据存储在 Repository 中，Repository 被一致性协议层进行包装，作为 SOFAJRaft 的状态机实现，所有对 Repository 的操作都会同步到其他节点，通过 Registry 来操作存储层。&lt;/p&gt;
&lt;p&gt;在同步时候，jraft可以直接调用 MetaRepositoryService，实现内部数据一致性。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;这里说的是其他节点的同步操作，和上节不同。上节是主动存储节点，这里是被动同步&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;put:45, MetaRepositoryService (com.alipay.sofa.registry.server.meta.repository.service)
put:31, RepositoryService (com.alipay.sofa.registry.server.meta.repository)
invokeInterface_L3_L:-1, 1412712349 (java.lang.invoke.LambdaForm$DMH)
reinvoke:-1, 1139092036 (java.lang.invoke.LambdaForm$BMH)
invoker:-1, 403463237 (java.lang.invoke.LambdaForm$MH)
invokeExact_MT:-1, 1568507411 (java.lang.invoke.LambdaForm$MH)
invokeWithArguments:627, MethodHandle (java.lang.invoke)
process:123, Processor (com.alipay.sofa.registry.jraft.processor)
onApply:133, ServiceStateMachine (com.alipay.sofa.registry.jraft.bootstrap)
doApplyTasks:534, FSMCallerImpl (com.alipay.sofa.jraft.core)
doCommitted:503, FSMCallerImpl (com.alipay.sofa.jraft.core)
runApplyTask:431, FSMCallerImpl (com.alipay.sofa.jraft.core)
access$100:72, FSMCallerImpl (com.alipay.sofa.jraft.core)
onEvent:147, FSMCallerImpl$ApplyTaskHandler (com.alipay.sofa.jraft.core)
onEvent:141, FSMCallerImpl$ApplyTaskHandler (com.alipay.sofa.jraft.core)
run:137, BatchEventProcessor (com.lmax.disruptor)
run:748, Thread (java.lang)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;16-通知data-session&quot;&gt;1.6 通知data, session&lt;/h3&gt;
&lt;h4 id=&quot;161-通知操作&quot;&gt;1.6.1 通知操作&lt;/h4&gt;
&lt;p&gt;前文 &quot;1.3 存储服务&quot; 中有 firePushDataListTask，firePushSessionListTask，最终目的是通知所有data/session有metaServer变动，这里把代码再贴出来温习下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MetaStoreService implements StoreService&amp;lt;MetaNode&amp;gt; {

    @Override
    public NodeChangeResult addNode(MetaNode metaNode) {

            //存放到repository（自动通过jraft同步给集群）
            metaRepositoryService.put(ipAddress, new RenewDecorate(metaNode,
                RenewDecorate.DEFAULT_DURATION_SECS));

            //触发通知(需要通知data/session)，我们说的就是这里
            nodeChangeResult = getNodeChangeResult();
            firePushDataListTask(nodeChangeResult, &quot;addMetaNode&quot;);
            firePushSessionListTask(nodeChangeResult, &quot;addMetaNode&quot;);
    }  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;firePushDataListTask 和 firePushSessionListTask 进而会往taskListenerManager发送消息，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void firePushDataListTask(NodeChangeResult nodeChangeResult, String nodeOperate) {
    TaskEvent taskEvent = new TaskEvent(nodeChangeResult, TaskType.DATA_NODE_CHANGE_PUSH_TASK);
    taskEvent.setAttribute(Constant.PUSH_NEED_CONFIRM_KEY, false);
    taskEvent.setAttribute(Constant.PUSH_TARGET_TYPE, NodeType.DATA);
    taskEvent.setAttribute(Constant.PUSH_TARGET_OPERATOR_TYPE, nodeOperate);
    taskListenerManager.sendTaskEvent(taskEvent);
}

private void firePushSessionListTask(NodeChangeResult nodeChangeResult, String nodeOperate) {
    //notify all session node
    TaskEvent taskEvent = new TaskEvent(nodeChangeResult, TaskType.DATA_NODE_CHANGE_PUSH_TASK);
    taskEvent.setAttribute(Constant.PUSH_TARGET_TYPE, NodeType.SESSION);
    taskEvent.setAttribute(Constant.PUSH_TARGET_OPERATOR_TYPE, nodeOperate);
    taskListenerManager.sendTaskEvent(taskEvent);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处是触发通知，于是data 节点, session节点会得到通知。&lt;/p&gt;
&lt;p&gt;如何通知data节点, session节点？这里用到了Listener，即调用了 DefaultTaskListenerManager # sendTaskEvent。&lt;/p&gt;
&lt;p&gt;堆栈如下 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;sendTaskEvent:45, DefaultTaskListenerManager (com.alipay.sofa.registry.task.listener)
firePushDataListTask:355, MetaStoreService (com.alipay.sofa.registry.server.meta.store)
addNode:127, MetaStoreService (com.alipay.sofa.registry.server.meta.store)
addNode:54, MetaStoreService (com.alipay.sofa.registry.server.meta.store)
register:52, MetaServerRegistry (com.alipay.sofa.registry.server.meta.registry)
registerCurrentNode:203, RaftExchanger (com.alipay.sofa.registry.server.meta.remoting)
access$200:56, RaftExchanger (com.alipay.sofa.registry.server.meta.remoting)
startProcess:105, RaftExchanger$1 (com.alipay.sofa.registry.server.meta.remoting)
lambda$onLeaderStart$2:234, ServiceStateMachine (com.alipay.sofa.registry.jraft.bootstrap)
run:-1, 50941601 (com.alipay.sofa.registry.jraft.bootstrap.ServiceStateMachine$$Lambda$192)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;162-分发通知消息&quot;&gt;1.6.2 分发通知消息&lt;/h4&gt;
&lt;p&gt;TaskListenerManager 是用来分发各种通知消息的类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DefaultTaskListenerManager implements TaskListenerManager {
    @Override
    public void sendTaskEvent(TaskEvent taskEvent) {
        Collection&amp;lt;TaskListener&amp;gt; taskListeners = this.taskListeners.get(taskEvent.getTaskType());
        for (TaskListener taskListener : taskListeners) {
            taskListener.handleEvent(taskEvent);
        }
    }  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 taskListenerManager.addTaskListener(taskListener); 中注册了很多处理消息的handler，从下面运行变量的文字中可以看出其逻辑意义。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;this.taskListeners = {ArrayListMultimap@7221} 
 expectedValuesPerKey = 3
 map = {HashMap@7227}  size = 4
  {TaskEvent$TaskType@7235} &quot;RECEIVE_STATUS_CONFIRM_NOTIFY_TASK&quot; -&amp;gt; {ArrayList@7236}  size = 1
   key = {TaskEvent$TaskType@7235} &quot;RECEIVE_STATUS_CONFIRM_NOTIFY_TASK&quot;
   value = {ArrayList@7236}  size = 1
    0 = {ReceiveStatusConfirmNotifyTaskListener@7248} 
  {TaskEvent$TaskType@7237} &quot;PERSISTENCE_DATA_CHANGE_NOTIFY_TASK&quot; -&amp;gt; {ArrayList@7238}  size = 1
   key = {TaskEvent$TaskType@7237} &quot;PERSISTENCE_DATA_CHANGE_NOTIFY_TASK&quot;
   value = {ArrayList@7238}  size = 1
    0 = {PersistenceDataChangeNotifyTaskListener@7254} 
  {TaskEvent$TaskType@7239} &quot;SESSION_NODE_CHANGE_PUSH_TASK&quot; -&amp;gt; {ArrayList@7240}  size = 1
   key = {TaskEvent$TaskType@7239} &quot;SESSION_NODE_CHANGE_PUSH_TASK&quot;
   value = {ArrayList@7240}  size = 1
    0 = {SessionNodeChangePushTaskListener@7252} 
  {TaskEvent$TaskType@7241} &quot;DATA_NODE_CHANGE_PUSH_TASK&quot; -&amp;gt; {ArrayList@7242}  size = 1
   key = {TaskEvent$TaskType@7241} &quot;DATA_NODE_CHANGE_PUSH_TASK&quot;
   value = {ArrayList@7242}  size = 1
    0 = {DataNodeChangePushTaskListener@7250} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是在 sendTaskEvent 之中会调用相关的消息handler来进行处理。&lt;/p&gt;
&lt;h4 id=&quot;163-异步处理消息&quot;&gt;1.6.3 异步处理消息&lt;/h4&gt;
&lt;p&gt;具体处理消息，我们举例如下：&lt;/p&gt;
&lt;p&gt;DataNodeChangePushTaskListener 就是用来处理DataNode相关消息的类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataNodeChangePushTaskListener implements TaskListener {
  
    private TaskDispatcher&amp;lt;String, MetaServerTask&amp;gt; dataSingleTaskDispatcher;
    private TaskDispatcher&amp;lt;String, MetaServerTask&amp;gt; sessionSingleTaskDispatcher;
  
    @Override
    public void handleEvent(TaskEvent event) {

        NodeType nodeType = (NodeType) event.getAttribute(Constant.PUSH_TARGET_TYPE);
        switch (nodeType) {
            case SESSION:
                MetaServerTask sessionNodeChangePushTask = new DataNodeChangePushTask(
                    NodeType.SESSION, metaServerConfig);
                sessionNodeChangePushTask.setTaskEvent(event);
                sessionSingleTaskDispatcher.dispatch(sessionNodeChangePushTask.getTaskId(),
                    sessionNodeChangePushTask, sessionNodeChangePushTask.getExpiryTime());
                break;
            case DATA:
                MetaServerTask dataNodeChangePushTask = new DataNodeChangePushTask(NodeType.DATA,
                    metaServerConfig);
                dataNodeChangePushTask.setTaskEvent(event);
                dataSingleTaskDispatcher.dispatch(dataNodeChangePushTask.getTaskId(),
                    dataNodeChangePushTask, dataNodeChangePushTask.getExpiryTime());
                break;
            default:
                break;
        }
    }  
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，TaskDispatcher 是一个分发异步消息，随之通过TaskExecutors进行异步操作的类。&lt;/p&gt;
&lt;p&gt;假如是DataNode，最后会调用到 DataNodeChangePushTask，其是由 DataNodeSingleTaskProcessor 来执行。&lt;/p&gt;
&lt;p&gt;其调用栈如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;pushDataNodes:73, DataNodeServiceImpl (com.alipay.sofa.registry.server.meta.node.impl)
execute:86, DataNodeChangePushTask (com.alipay.sofa.registry.server.meta.task)
process:41, DataNodeSingleTaskProcessor (com.alipay.sofa.registry.server.meta.task.processor)
process:32, DataNodeSingleTaskProcessor (com.alipay.sofa.registry.server.meta.task.processor)
run:136, TaskExecutors$WorkerRunnable (com.alipay.sofa.registry.task.batcher)
run:748, Thread (java.lang)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体到 DataNodeChangePushTask 来进行与各个DataNode进行交互的操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataNodeChangePushTask extends AbstractMetaServerTask {
    private final SessionNodeService sessionNodeService;
    private final DataNodeService    dataNodeService;
    final private MetaServerConfig   metaServerConfig;
    final private NodeType           nodeType;
    private NodeChangeResult         nodeChangeResult;
    private Boolean                  confirm;
    private String                   confirmNodeIp;

    private Map&amp;lt;String, DataNode&amp;gt;    targetNodes;
  
    @Override
    public void execute() {
        switch (nodeType) {
            case SESSION:
                sessionNodeService.pushDataNodes(nodeChangeResult);
                break;
            case DATA:
                dataNodeService
                    .pushDataNodes(nodeChangeResult, targetNodes, confirm, confirmNodeIp);
                break;
            default:
                break;
        }
    }
}  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以DataNodeServiceImpl为例，可以看到最后调用了 dataNodeExchanger 完成了节点间通讯。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataNodeServiceImpl implements DataNodeService {

    @Autowired
    private NodeExchanger         dataNodeExchanger;

    @Autowired
    private StoreService          dataStoreService;

    @Autowired
    private AbstractServerHandler dataConnectionHandler;

    @Override
    public void pushDataNodes(NodeChangeResult nodeChangeResult, Map&amp;lt;String, DataNode&amp;gt; targetNodes,
                              boolean confirm, String confirmNodeIp) {

        if (nodeChangeResult != null) {

            List&amp;lt;Throwable&amp;gt; exceptions = new ArrayList&amp;lt;&amp;gt;();
            NodeConnectManager nodeConnectManager = getNodeConnectManager();

            Collection&amp;lt;InetSocketAddress&amp;gt; connections = nodeConnectManager.getConnections(null);

            // add register confirm
            StoreService storeService = ServiceFactory.getStoreService(NodeType.DATA);
            DataCenterNodes dataCenterNodes = storeService.getDataCenterNodes();
            Map&amp;lt;String, DataNode&amp;gt; registeredNodes = dataCenterNodes.getNodes();

            for (InetSocketAddress address : connections) {
                try {
                    if (targetNodes != null &amp;amp;&amp;amp; !targetNodes.isEmpty()) {
                        if (!targetNodes.keySet().contains(address.getAddress().getHostAddress())) {
                            continue;
                        }
                    } else {
                        if (!registeredNodes.keySet().contains(
                            address.getAddress().getHostAddress())) {
                            continue;
                        }
                    }

                    Request&amp;lt;NodeChangeResult&amp;gt; nodeChangeRequestRequest = new Request&amp;lt;NodeChangeResult&amp;gt;() {
                        @Override
                        public NodeChangeResult getRequestBody() {
                            return nodeChangeResult;
                        }

                        @Override
                        public URL getRequestUrl() {
                            return new URL(address);
                        }
                    };
                    // 节点间通讯
                    Response response = dataNodeExchanger.request(nodeChangeRequestRequest);

                    if (confirm) {
                        Object result = response.getResult();
                        if (result instanceof CommonResponse) {
                            CommonResponse genericResponse = (CommonResponse) result;
                            if (genericResponse.isSuccess()) {
                                confirmStatus(address, confirmNodeIp);
                            } 
                        } 
                    }
                } 
            }
        }
    }
}  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;164-另一种产生通知方式&quot;&gt;1.6.4 另一种产生通知方式&lt;/h4&gt;
&lt;p&gt;&lt;u&gt;ExecutorManager的pushNodeListChange会定期检查，如果有必要，则产生通知&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;对应后文的 DataConfirmStatusService 节点变更事件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;scheduler.schedule(
        new TimedSupervisorTask(&quot;CheckDataNodeListChangePush&quot;, scheduler, checkNodeListChangePushExecutor,
                metaServerConfig.getSchedulerCheckNodeListChangePushTimeout(), TimeUnit.SECONDS,
                metaServerConfig.getSchedulerCheckNodeListChangePushExpBackOffBound(),
                () -&amp;gt; metaServerRegistry.pushNodeListChange(NodeType.DATA)),
        metaServerConfig.getSchedulerCheckNodeListChangePushFirstDelay(), TimeUnit.SECONDS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其堆栈是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;pushNodeListChange:278, DataStoreService (com.alipay.sofa.registry.server.meta.store)
pushNodeListChange:103, MetaServerRegistry (com.alipay.sofa.registry.server.meta.registry)
lambda$startScheduler$4:158, ExecutorManager (com.alipay.sofa.registry.server.meta.executor)
run:-1, 758751909 (com.alipay.sofa.registry.server.meta.executor.ExecutorManager$$Lambda$202)
call:511, Executors$RunnableAdapter (java.util.concurrent)
run$$$capture:266, FutureTask (java.util.concurrent)
run:-1, FutureTask (java.util.concurrent)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataStoreService implements StoreService&amp;lt;DataNode&amp;gt; {
    @Override
    public void pushNodeListChange() {
        NodeOperator&amp;lt;DataNode&amp;gt; fireNode;
        if ((fireNode = dataConfirmStatusService.peekConfirmNode()) != null) {
            NodeChangeResult nodeChangeResult = getNodeChangeResult();
            Map&amp;lt;String, Map&amp;lt;String, DataNode&amp;gt;&amp;gt; map = nodeChangeResult.getNodes();
            Map&amp;lt;String, DataNode&amp;gt; addNodes = map.get(nodeConfig.getLocalDataCenter());
            if (addNodes != null) {
                Map&amp;lt;String, DataNode&amp;gt; previousNodes = dataConfirmStatusService.putExpectNodes(
                    fireNode.getNode(), addNodes);

                if (!previousNodes.isEmpty()) {
                    // 产生通知
                    firePushDataListTask(fireNode, nodeChangeResult, previousNodes, true);
                }
            }
            // 产生通知
            firePushSessionListTask(nodeChangeResult, fireNode.getNodeOperate().toString());
        }
    }  
}  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x02-节点注册&quot;&gt;0x02 节点注册&lt;/h2&gt;
&lt;h3 id=&quot;21--dataapplication&quot;&gt;2.1 DataApplication&lt;/h3&gt;
&lt;h4 id=&quot;211-dataconnectionhandler&quot;&gt;2.1.1 DataConnectionHandler&lt;/h4&gt;
&lt;p&gt;当一个DataApplication启动，首先DataConnectionHandler会响应。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;connected:40, DataConnectionHandler (com.alipay.sofa.registry.server.meta.remoting.connection)
onEvent:69, ConnectionEventAdapter (com.alipay.sofa.registry.remoting.bolt)
onEvent:44, ConnectionEventListener (com.alipay.remoting)
run:201, ConnectionEventHandler$1 (com.alipay.remoting)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;感觉只是设置了一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataConnectionHandler extends AbstractServerHandler implements NodeConnectManager {
    private Map&amp;lt;String/*connectId*/, InetSocketAddress&amp;gt; connections = new ConcurrentHashMap&amp;lt;&amp;gt;();

    @Override
    public void connected(Channel channel) throws RemotingException {
        super.connected(channel);
        addConnection(channel);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;212-datanodehandler&quot;&gt;2.1.2 DataNodeHandler&lt;/h4&gt;
&lt;p&gt;然后是 DataNodeHandler 会响应。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;reply:43, DataNodeHandler (com.alipay.sofa.registry.server.meta.remoting.handler)
handleRequest:54, SyncUserProcessorAdapter (com.alipay.sofa.registry.remoting.bolt)
dispatchToUserProcessor:239, RpcRequestProcessor (com.alipay.remoting.rpc.protocol)
doProcess:145, RpcRequestProcessor (com.alipay.remoting.rpc.protocol)
run:366, RpcRequestProcessor$ProcessTask (com.alipay.remoting.rpc.protocol)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体代码如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataNodeHandler extends AbstractServerHandler&amp;lt;DataNode&amp;gt; {
    @Autowired
    private Registry            metaServerRegistry;

    @Override
    public Object reply(Channel channel, DataNode dataNode) {
        NodeChangeResult nodeChangeResult;
        nodeChangeResult = metaServerRegistry.register(dataNode);
        return nodeChangeResult;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来是调用Store服务进行添加节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public NodeChangeResult register(Node node) {
    StoreService storeService = ServiceFactory.getStoreService(node.getNodeType());
    return storeService.addNode(node);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码来到 DataStoreService，依然是调用 RepositoryService 来进行节点的注册和存储。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataStoreService implements StoreService&amp;lt;DataNode&amp;gt; {
    @Autowired
    private TaskListenerManager                                taskListenerManager;

    @RaftReference(uniqueId = &quot;dataServer&quot;)
    private RepositoryService&amp;lt;String, RenewDecorate&amp;lt;DataNode&amp;gt;&amp;gt; dataRepositoryService;

    @RaftReference(uniqueId = &quot;dataServer&quot;)
    private NodeConfirmStatusService&amp;lt;DataNode&amp;gt;                 dataConfirmStatusService;

    @Override
    public NodeChangeResult addNode(DataNode dataNode) {
        NodeChangeResult nodeChangeResult;
        String ipAddress = dataNode.getNodeUrl().getIpAddress();
        write.lock();
        try {
            dataRepositoryService.put(ipAddress, new RenewDecorate(dataNode,
                RenewDecorate.DEFAULT_DURATION_SECS));
            renew(dataNode, 30);
            nodeChangeResult = getNodeChangeResult();
            dataConfirmStatusService.putConfirmNode(dataNode, DataOperator.ADD);
        } finally {
            write.unlock();
        }
        return nodeChangeResult;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;dataConfirmStatusService.putConfirmNode&lt;/code&gt; 同时会存储一个变更事件到队列中，主要用于数据推送，消费处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void putConfirmNode(DataNode node, DataOperator nodeOperate) {
        expectNodesOrders.put(new NodeOperator(node, nodeOperate));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;213-dataconfirmstatusservice&quot;&gt;2.1.3 DataConfirmStatusService&lt;/h4&gt;
&lt;p&gt;DataConfirmStatusService 也是注解了RaftService，这说明是一个由 Raft 协议进行同步的存储。&lt;/p&gt;
&lt;p&gt;以下的这些存储结构会被同步。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;expectNodesOrders&lt;/code&gt; 用来存储节点变更事件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expectNodes&lt;/code&gt; 用来存储变更事件需要确认的节点，也就是说 &lt;code&gt;NodeOperator&lt;/code&gt; 只有得到了其他节点的确认，才会从 &lt;code&gt;expectNodesOrders&lt;/code&gt; 移除；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;snapShotFileNames&lt;/code&gt; 是快照文件名；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RaftService(uniqueId = &quot;dataServer&quot;)
public class DataConfirmStatusService extends AbstractSnapshotProcess
                                      implements NodeConfirmStatusService&amp;lt;DataNode&amp;gt; {
  
        private ConcurrentHashMap&amp;lt;DataNode/*node*/, Map&amp;lt;String/*ipAddress*/, DataNode&amp;gt;&amp;gt; expectNodes             = new ConcurrentHashMap&amp;lt;&amp;gt;();
        private BlockingQueue&amp;lt;NodeOperator&amp;gt;                                               expectNodesOrders       = new LinkedBlockingQueue();
        private Set&amp;lt;String&amp;gt;   snapShotFileNames 
      
        @Override
  public void putConfirmNode(DataNode node, DataOperator nodeOperate) {
      expectNodesOrders.put(new NodeOperator(node, nodeOperate));
  }    
    
  public NodeOperator&amp;lt;DataNode&amp;gt; peekConfirmNode() {
      return expectNodesOrders.peek();
  }
}  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;214-消费&quot;&gt;2.1.4 消费&lt;/h4&gt;
&lt;p&gt;事件存储到 BlockingQueue expectNodesOrders 里，哪里去消费呢？ 看源码发现，并不是想象中的使用一个线程阻塞的读。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;ExecutorManager&lt;/code&gt;中会启动一个定时任务，轮询该队列有没有数据。即周期性的调用&lt;code&gt;Registry#pushNodeListChange&lt;/code&gt;方法，获取队列的头节点并消费。Data 和 Session 各对应一个任务。&lt;/p&gt;
&lt;p&gt;具体流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/338467/1568256774231-1672888e-de2f-44fd-b9c5-45573f3d4b79.png&quot; alt=&quot;push_processor&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先获取队列（expectNodesOrders）头节点，如果为Null直接返回；&lt;/li&gt;
&lt;li&gt;获取当前数据中心的节点列表，并存储到确认表（expectNodes）；&lt;/li&gt;
&lt;li&gt;提交节点变更推送任务（firePushXxListTask)；&lt;/li&gt;
&lt;li&gt;处理任务，即调用 XxNodeService 的 pushXxxNode 方法，即通过 ConnectionHandler 获取所有的节点连接，发送节点列表；&lt;/li&gt;
&lt;li&gt;收到回复后，如果需要确认，则会调用&lt;code&gt;StoreService#confirmNodeStatus&lt;/code&gt; 方法，将该节点从expectNodes中移除；&lt;/li&gt;
&lt;li&gt;待所有的节点从 expectNodes 中移除，则将此次操作从 expectNodesOrders 移除，处理完毕；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体可以细化如下。&lt;/p&gt;
&lt;h5 id=&quot;2141-定时提交节点变更推送任务&quot;&gt;2.1.4.1 定时提交节点变更推送任务&lt;/h5&gt;
&lt;p&gt;本小节对应上面步骤的前三步。&lt;/p&gt;
&lt;p&gt;比如关于Data 定时任务如下，里面定期调用了MetaServerRegistry 的 pushNodeListChange函数来处理任务 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;scheduler.schedule(
        new TimedSupervisorTask(&quot;CheckDataNodeListChangePush&quot;, scheduler, checkNodeListChangePushExecutor,
                metaServerConfig.getSchedulerCheckNodeListChangePushTimeout(), TimeUnit.SECONDS,
                metaServerConfig.getSchedulerCheckNodeListChangePushExpBackOffBound(),
                () -&amp;gt; metaServerRegistry.pushNodeListChange(NodeType.DATA)),
        metaServerConfig.getSchedulerCheckNodeListChangePushFirstDelay(), TimeUnit.SECONDS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MetaServerRegistry 中的 pushNodeListChange 定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void pushNodeListChange(NodeType nodeType) {
    StoreService storeService = ServiceFactory.getStoreService(nodeType);
    if (storeService != null) {
        storeService.pushNodeListChange();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DataStoreService 这里做了以下工作。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先获取队列（expectNodesOrders）头节点，如果为Null直接返回；&lt;/li&gt;
&lt;li&gt;获取当前数据中心的节点列表，并存储到确认表（expectNodes）；&lt;/li&gt;
&lt;li&gt;提交节点变更推送任务（firePushXxListTask)；&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void pushNodeListChange() {
    NodeOperator&amp;lt;DataNode&amp;gt; fireNode;
    //  首先获取队列（expectNodesOrders）头节点，如果为Null直接返回；
    if ((fireNode = dataConfirmStatusService.peekConfirmNode()) != null) {
        NodeChangeResult nodeChangeResult = getNodeChangeResult();
        Map&amp;lt;String, Map&amp;lt;String, DataNode&amp;gt;&amp;gt; map = nodeChangeResult.getNodes();
        Map&amp;lt;String, DataNode&amp;gt; addNodes = map.get(nodeConfig.getLocalDataCenter());
        if (addNodes != null) {
            // 获取当前数据中心的节点列表，并存储到确认表（expectNodes）；
            Map&amp;lt;String, DataNode&amp;gt; previousNodes = dataConfirmStatusService.putExpectNodes(
                fireNode.getNode(), addNodes);
            // 提交节点变更推送任务（firePushXxListTask)；
            if (!previousNodes.isEmpty()) {
                firePushDataListTask(fireNode, nodeChangeResult, previousNodes, true);
            }
        }
        // 提交节点变更推送任务（firePushXxListTask)；
        firePushSessionListTask(nodeChangeResult, fireNode.getNodeOperate().toString());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就把任务提交到了Task任务。&lt;/p&gt;
&lt;h5 id=&quot;2142-定时异步处理任务&quot;&gt;2.1.4.2 定时异步处理任务&lt;/h5&gt;
&lt;p&gt;本小节对应上面步骤的后三步。&lt;/p&gt;
&lt;p&gt;下面就是定时异步处理任务 。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;处理任务，即调用 XxNodeService 的 pushXxxNode 方法，即通过 ConnectionHandler 获取所有的节点连接，发送节点列表；&lt;/li&gt;
&lt;li&gt;收到回复后，如果需要确认，则会调用&lt;code&gt;StoreService#confirmNodeStatus&lt;/code&gt; 方法，将该节点从expectNodes中移除；&lt;/li&gt;
&lt;li&gt;待所有的节点从 expectNodes 中移除，则将此次操作从 expectNodesOrders 移除，处理完毕；&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataNodeServiceImpl implements DataNodeService {
    @Override
    public void pushDataNodes(NodeChangeResult nodeChangeResult, Map&amp;lt;String, DataNode&amp;gt; targetNodes,
                              boolean confirm, String confirmNodeIp) {

        if (nodeChangeResult != null) {
            NodeConnectManager nodeConnectManager = getNodeConnectManager();
            Collection&amp;lt;InetSocketAddress&amp;gt; connections = nodeConnectManager.getConnections(null);

            // add register confirm
            StoreService storeService = ServiceFactory.getStoreService(NodeType.DATA);
            DataCenterNodes dataCenterNodes = storeService.getDataCenterNodes();
            Map&amp;lt;String, DataNode&amp;gt; registeredNodes = dataCenterNodes.getNodes();

            // 通过 ConnectionHandler 获取所有的节点连接，发送节点列表；
            for (InetSocketAddress address : connections) {
                try {
                    Request&amp;lt;NodeChangeResult&amp;gt; nodeChangeRequestRequest = new Request&amp;lt;NodeChangeResult&amp;gt;() {
                        @Override
                        public NodeChangeResult getRequestBody() {
                            return nodeChangeResult;
                        }

                        @Override
                        public URL getRequestUrl() {
                            return new URL(address);
                        }
                    };
                    // 发送节点列表；
                    Response response = dataNodeExchanger.request(nodeChangeRequestRequest);

                    if (confirm) {
                        Object result = response.getResult();
                        if (result instanceof CommonResponse) {
                            CommonResponse genericResponse = (CommonResponse) result;
                            if (genericResponse.isSuccess()) {
                             // 收到回复后，如果需要确认，则会调用`StoreService#confirmNodeStatus` 方法，将该节点从expectNodes中移除；
                                confirmStatus(address, confirmNodeIp);
                            }
                        } 
                    }

                } 
            }
        }
    }  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其堆栈如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;pushDataNodes:73, DataNodeServiceImpl (com.alipay.sofa.registry.server.meta.node.impl)
execute:86, DataNodeChangePushTask (com.alipay.sofa.registry.server.meta.task)
process:41, DataNodeSingleTaskProcessor (com.alipay.sofa.registry.server.meta.task.processor)
process:32, DataNodeSingleTaskProcessor (com.alipay.sofa.registry.server.meta.task.processor)
run:136, TaskExecutors$WorkerRunnable (com.alipay.sofa.registry.task.batcher)
run:748, Thread (java.lang)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;2143-确认步骤&quot;&gt;2.1.4.3 确认步骤&lt;/h5&gt;
&lt;p&gt;进一步细化上文提到的 “确认步骤”&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void confirmStatus(InetSocketAddress address, String confirmNodeIp) {
    String ipAddress = address.getAddress().getHostAddress();
    dataStoreService.confirmNodeStatus(ipAddress, confirmNodeIp);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是 DataStoreService&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;收到回复后，如果需要确认，则会调用&lt;code&gt;StoreService#confirmNodeStatus&lt;/code&gt; 方法，将该节点从expectNodes中移除；&lt;/li&gt;
&lt;li&gt;待所有的节点从 expectNodes 中移除，则将此次操作从 expectNodesOrders 移除，处理完毕；&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void confirmNodeStatus(String ipAddress, String confirmNodeIp) {
    NodeOperator&amp;lt;DataNode&amp;gt; fireNode = dataConfirmStatusService.peekConfirmNode();
    if (fireNode != null) {
        String fireNodeIp = fireNode.getNode().getIp();
        Map&amp;lt;String/*ipAddress*/, DataNode&amp;gt; waitNotifyNodes = dataConfirmStatusService
            .getExpectNodes(fireNode.getNode());

        if (waitNotifyNodes != null) {
            Set&amp;lt;String&amp;gt; removeIp = getRemoveIp(waitNotifyNodes.keySet());
            removeIp.add(ipAddress);

            // 将该节点从expectNodes中移除；
            waitNotifyNodes = dataConfirmStatusService.removeExpectConfirmNodes(
                fireNode.getNode(), removeIp);

            if (waitNotifyNodes.isEmpty()) {
                //all node be notified,or some disconnect node be evict
                try {
                    // 待所有的节点从 expectNodes 中移除，则将此次操作从 expectNodesOrders 移除，处理完毕；
                    if (null != dataConfirmStatusService
                        .removeExpectNodes((dataConfirmStatusService.pollConfirmNode())
                            .getNode())) {
                        //add init status must notify
                        if (fireNode.getNodeOperate() == DataOperator.ADD) {
                            notifyConfirm(fireNode.getNode());
                        }
                    }
                }
            }
        } else {
            try {
                //wait node not exist,
                dataConfirmStatusService.pollConfirmNode();
            } 
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;2144-总结消费流程&quot;&gt;2.1.4.4 总结消费流程&lt;/h5&gt;
&lt;p&gt;对于消费流程，总结如下图：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; +-------------------+        +-----------+         +------------------------+                                       +----------------+
 |ServiceStateMachine+------&amp;gt; | Processor | +-----&amp;gt; |DataConfirmStatusService|                                       |     loop       |
 +-------------------+        +-----------+         +-----+------------------+                                       v                |
                                                          |                                                   +------+------+         |
                                                          | put                                               |TaskExecutors|         |
                                                          v                                                   +------+------+         |
                                                 +--------+--------+   remo^e                                        |                |
                            +------------------&amp;gt; |expectNodesOrders| &amp;lt;-------+                                       |                |
                            | loop               +--------+--------+         |                                       v                |
                            |                             |                  |                          +------------+--------------+ |
                            |                             | peekConfirmNode  |                          |DataNodeSingleTaskProcessor| |
                            |                             |                  |                          +------------+--------------+ |
                            |                             |                  |                                       |                |
+---------------------------+--------------------+        v                  |                                       |                |
|               ExecutorManager                  |   +----+---+              |                                       v                |
| +--------------------------------------------+ |   |fireNode|              |                            +----------+-----------+    |
| |           TimedSuper^isorTask              | |   +----+---+              |                            |DataNodeChangePushTask|    |
| |  +---------------------------------------+ | |        |                  |                            +----------+-----------+    |
| |  | metaServerRegistry.pushNodeListChange | | |        | putExpectNodes   |                                       |                |
| |  +---------------------------------------+ | |        |                  |                                       |                |
| +--------------------------------------------+ |        v                  |                                       v                |
+------------------------------------------------+ +------+------+   remo^e  |                             +---------+---------+      |
                            ^                      | expectNodes | &amp;lt;---------+------------------&amp;lt;--------+ |DataNodeServiceImpl|      |
                            |                      +------+------+                                       | +---------+---------+      |
                            |                             |                                              |           |                |
                            |                             v                                              |           |                |
                            |               +-------------+--------+                                     |           v                |
                            |               | firePushDataListTask +-----------------------------------&amp;gt; |    +------+-------+        |
                            |               +-------------+--------+ taskListenerManager.sendTaskEvent   |    | StoreService |        |
                            |                             |                                              |    +------+-------+        ^
                            |                             v                                              |           |                |
                            |               +-------------+-----------+                                  |           v                |
                            ^&amp;lt;--------------+ firePushSessionListTask +--------------------------------&amp;gt; |     +-----+-------+        |
                                            +-------------------------+taskListenerManager.sendTaskEvent +-----+confirmStatus|        |
                                                                                                               +-----+-------+        |
                                                                                                                     |                |
                                                                                                                     &amp;gt;----------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机上参见如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201009224427134-654536082.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;215-总结&quot;&gt;2.1.5 总结&lt;/h4&gt;
&lt;p&gt;数据节点注册流程总结如下图。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                                                                                                       +----------------------------+
                                                              put        +----------------------+      | Map(String, NodeRepository)|
                                                            +----------&amp;gt; |dataRepositoryService +----&amp;gt; | registry                   |
                                                            |            +----------------------+      +----------------------------+
                                                            |
                 register                   addNode         |
+----------------+      +------------------+        +-------+--------+
| DataNodeHandler+-----&amp;gt;+metaServerRegistry+-------&amp;gt;+DataStoreService|                                       TimedSupervisorTask
+----------------+      +------------------+        +-------+--------+
                                                            |            +------------------------+          +------------------+
                                                            +----------&amp;gt; |dataConfirmStatusService| +------&amp;gt; |pushNodeListChange|
                                                          putConfirmNode +------------------------+          +------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机上参见如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201009224450673-148329632.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22--sessionnodehandler&quot;&gt;2.2 SessionNodeHandler&lt;/h3&gt;
&lt;p&gt;Session节点的注册和Data节点几乎类似。&lt;/p&gt;
&lt;p&gt;SessionNodeHandler 定义如下 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SessionNodeHandler extends AbstractServerHandler&amp;lt;SessionNode&amp;gt; {

    private static final Logger LOGGER = LoggerFactory.getLogger(SessionNodeHandler.class);

    @Autowired
    private Registry            metaServerRegistry;

    @Override
    public Object reply(Channel channel, SessionNode sessionNode) {
        NodeChangeResult nodeChangeResult;
        try {
            nodeChangeResult = metaServerRegistry.register(sessionNode);
        } 
        return nodeChangeResult;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是进行业务处理的SessionStoreService。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SessionStoreService implements StoreService&amp;lt;SessionNode&amp;gt; {
  
    @Override
    public NodeChangeResult addNode(SessionNode sessionNode) {

        write.lock();
        try {
            String ipAddress = sessionNode.getNodeUrl().getIpAddress();

            sessionRepositoryService.put(ipAddress, new RenewDecorate(sessionNode,
                RenewDecorate.DEFAULT_DURATION_SECS));

            sessionVersionRepositoryService.checkAndUpdateVersions(nodeConfig.getLocalDataCenter(),
                System.currentTimeMillis());

            renew(sessionNode, 30);
            sessionConfirmStatusService.putConfirmNode(sessionNode, DataOperator.ADD);

        } finally {
            write.unlock();
        }

        return dataStoreService.getNodeChangeResult();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是SessionRepositoryService。&lt;/p&gt;
&lt;p&gt;注意，这里map的key是ip，这是与Data不一致的地方。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RaftService(uniqueId = &quot;sessionServer&quot;)
public class SessionRepositoryService extends AbstractSnapshotProcess
                                                                     implements
                                                                     RepositoryService&amp;lt;String, RenewDecorate&amp;lt;SessionNode&amp;gt;&amp;gt; {
    /**
     * session node store
     */
    private ConcurrentHashMap&amp;lt;String/*ipAddress*/, RenewDecorate&amp;lt;SessionNode&amp;gt;&amp;gt; registry          = new ConcurrentHashMap&amp;lt;&amp;gt;();
  
    @Override
    public RenewDecorate&amp;lt;SessionNode&amp;gt; put(String ipAddress, RenewDecorate&amp;lt;SessionNode&amp;gt; sessionNode,
                                          Long currentTimeMillis) {
        try {
            RenewDecorate oldRenewDecorate = registry.get(ipAddress);
            registry.put(ipAddress, sessionNode);
        }
        return sessionNode;
    }  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上节可知，DataServer 和 SessionServer 都有处理节点注册请求的 Handler。注册行为由 Registry 完成。&lt;/p&gt;
&lt;p&gt;比如 metaServerHandlers。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean(name = &quot;metaServerHandlers&quot;)
public Collection&amp;lt;AbstractServerHandler&amp;gt; metaServerHandlers() {
    Collection&amp;lt;AbstractServerHandler&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    list.add(metaConnectionHandler());
    list.add(getNodesRequestHandler());
    return list;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x03-注册信息续约&quot;&gt;0x03 注册信息续约&lt;/h2&gt;
&lt;h3 id=&quot;31-关键类-renewdecorate&quot;&gt;3.1 关键类 RenewDecorate&lt;/h3&gt;
&lt;p&gt;节点注册的时候，节点信息被 &lt;code&gt;RenewDecorate&lt;/code&gt; 包装起来了，这个就是实现注册信息续约和驱逐的关键，该类定义 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RenewDecorate&amp;lt;T&amp;gt; implements Serializable {
    public static final int DEFAULT_DURATION_SECS = 15;
    private T               renewal;  // 节点对象封装
    private long            beginTimestamp; // 注册事件
    private volatile long   lastUpdateTimestamp; // 续约时间
    private long            duration; // 超时时间
  
    public boolean isExpired() {
        return System.currentTimeMillis() &amp;gt; lastUpdateTimestamp + duration;
    }

    public void renew() {
        lastUpdateTimestamp = System.currentTimeMillis() + duration;
    }

    public void renew(long durationSECS) {
        lastUpdateTimestamp = System.currentTimeMillis() + durationSECS * 1000;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该对象为注册节点信息，附加了注册时间、上次续约时间、过期时间。&lt;/p&gt;
&lt;p&gt;续约操作就是修改&lt;code&gt;lastUpdateTimestamp&lt;/code&gt;，是否过期就是判断&lt;code&gt;System.currentTimeMillis() - lastUpdateTimestamp &amp;gt; duration&lt;/code&gt; 是否成立，成立则认为节点超时进行驱逐。&lt;/p&gt;
&lt;h3 id=&quot;32-执行路径&quot;&gt;3.2 执行路径&lt;/h3&gt;
&lt;p&gt;可以看到，renew可以从多条执行路径调用。&lt;/p&gt;
&lt;p&gt;路径一：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;renew:70, RenewDecorate (com.alipay.sofa.registry.server.meta.store)
replace:176, DataRepositoryService (com.alipay.sofa.registry.server.meta.repository.service)
replace:45, DataRepositoryService (com.alipay.sofa.registry.server.meta.repository.service)
replace:39, RepositoryService (com.alipay.sofa.registry.server.meta.repository)
invokeInterface_L3_L:-1, 1889671331 (java.lang.invoke.LambdaForm$DMH)
reinvoke:-1, 171310548 (java.lang.invoke.LambdaForm$BMH)
invoker:-1, 559310456 (java.lang.invoke.LambdaForm$MH)
invokeExact_MT:-1, 426124479 (java.lang.invoke.LambdaForm$MH)
invokeWithArguments:627, MethodHandle (java.lang.invoke)
process:123, Processor (com.alipay.sofa.registry.jraft.processor)
onApply:133, ServiceStateMachine (com.alipay.sofa.registry.jraft.bootstrap)
doApplyTasks:534, FSMCallerImpl (com.alipay.sofa.jraft.core)
doCommitted:503, FSMCallerImpl (com.alipay.sofa.jraft.core)
runApplyTask:431, FSMCallerImpl (com.alipay.sofa.jraft.core)
access$100:72, FSMCallerImpl (com.alipay.sofa.jraft.core)
onEvent:147, FSMCallerImpl$ApplyTaskHandler (com.alipay.sofa.jraft.core)
onEvent:141, FSMCallerImpl$ApplyTaskHandler (com.alipay.sofa.jraft.core)
run:137, BatchEventProcessor (com.lmax.disruptor)
run:748, Thread (java.lang)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;路径二：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;renew:171, DataStoreService (com.alipay.sofa.registry.server.meta.store)
addNode:111, DataStoreService (com.alipay.sofa.registry.server.meta.store)
addNode:60, DataStoreService (com.alipay.sofa.registry.server.meta.store)
register:52, MetaServerRegistry (com.alipay.sofa.registry.server.meta.registry)
reply:43, DataNodeHandler (com.alipay.sofa.registry.server.meta.remoting.handler)
reply:32, DataNodeHandler (com.alipay.sofa.registry.server.meta.remoting.handler)
handleRequest:54, SyncUserProcessorAdapter (com.alipay.sofa.registry.remoting.bolt)
dispatchToUserProcessor:239, RpcRequestProcessor (com.alipay.remoting.rpc.protocol)
doProcess:145, RpcRequestProcessor (com.alipay.remoting.rpc.protocol)
run:366, RpcRequestProcessor$ProcessTask (com.alipay.remoting.rpc.protocol)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如在 DataStoreService 之中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public NodeChangeResult addNode(DataNode dataNode) {
    NodeChangeResult nodeChangeResult;
    String ipAddress = dataNode.getNodeUrl().getIpAddress();
    write.lock();
    try {
        dataRepositoryService.put(ipAddress, new RenewDecorate(dataNode,
            RenewDecorate.DEFAULT_DURATION_SECS));
        renew(dataNode, 30);  // 续约 
        nodeChangeResult = getNodeChangeResult();
        dataConfirmStatusService.putConfirmNode(dataNode, DataOperator.ADD);
    } finally {
        write.unlock();
    }
    return nodeChangeResult;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进而调用renew&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void renew(DataNode dataNode, int duration) {
    write.lock();
    try {
        String ipAddress = dataNode.getNodeUrl().getIpAddress();
        RenewDecorate renewer = dataRepositoryService.get(ipAddress);
        if (renewer == null) {
            addNode(dataNode); // 新增 
        } else {
            // 续约
            if (duration &amp;gt; 0) {
                dataRepositoryService.replace(ipAddress, new RenewDecorate(dataNode, duration));
            } else {
                dataRepositoryService.replace(ipAddress, new RenewDecorate(dataNode,
                    RenewDecorate.DEFAULT_DURATION_SECS));
            }

        }
    } finally {
        write.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为是Raft对Repository进行数据一致性维护，所以 dataRepositoryService.replace 会被 Proxy 替换，进而来到了ProxyHandler。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public Object invoke(Object proxy, Method method, Object[] args) {
    try {
        ProcessRequest request = new ProcessRequest();
        request.setMethodArgSigs(createParamSignature(method.getParameterTypes()));
        request.setMethodName(method.getName());
        request.setMethodArgs(args);
        request.setServiceName(serviceId);

        if (Processor.getInstance().isLeaderReadMethod(method)) {
            return doInvokeMethod(request);
        }
        return client.sendRequest(request);
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 Raft 来到 &lt;strong&gt;服务端&lt;/strong&gt;，堆栈如下 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;replace:165, DataRepositoryService (com.alipay.sofa.registry.server.meta.repository.service)
replace:45, DataRepositoryService (com.alipay.sofa.registry.server.meta.repository.service)
replace:39, RepositoryService (com.alipay.sofa.registry.server.meta.repository)
invokeInterface_L3_L:-1, 1177311202 (java.lang.invoke.LambdaForm$DMH)
reinvoke:-1, 960369282 (java.lang.invoke.LambdaForm$BMH)
invoker:-1, 198860519 (java.lang.invoke.LambdaForm$MH)
invokeExact_MT:-1, 2035225037 (java.lang.invoke.LambdaForm$MH)
invokeWithArguments:627, MethodHandle (java.lang.invoke)
process:123, Processor (com.alipay.sofa.registry.jraft.processor)
onApply:133, ServiceStateMachine (com.alipay.sofa.registry.jraft.bootstrap)
doApplyTasks:534, FSMCallerImpl (com.alipay.sofa.jraft.core)
doCommitted:503, FSMCallerImpl (com.alipay.sofa.jraft.core)
runApplyTask:431, FSMCallerImpl (com.alipay.sofa.jraft.core)
access$100:72, FSMCallerImpl (com.alipay.sofa.jraft.core)
onEvent:147, FSMCallerImpl$ApplyTaskHandler (com.alipay.sofa.jraft.core)
onEvent:141, FSMCallerImpl$ApplyTaskHandler (com.alipay.sofa.jraft.core)
run:137, BatchEventProcessor (com.lmax.disruptor)
run:748, Thread (java.lang)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体renew代码如下，这样就最终完成了更新：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public RenewDecorate&amp;lt;DataNode&amp;gt; replace(String ipAddress, RenewDecorate&amp;lt;DataNode&amp;gt; dataNode,
                                       Long currentTimeMillis) {
    try {
        String dataCenter = dataNode.getRenewal().getDataCenter();
        NodeRepository&amp;lt;DataNode&amp;gt; dataNodeRepository = registry.get(dataCenter);

        if (dataNodeRepository != null) {
            Map&amp;lt;String/*ipAddress*/, RenewDecorate&amp;lt;DataNode&amp;gt;&amp;gt; dataNodes = dataNodeRepository
                .getNodeMap();
            RenewDecorate&amp;lt;DataNode&amp;gt; oldRenewDecorate = dataNodes.get(ipAddress);
            if (oldRenewDecorate != null &amp;amp;&amp;amp; oldRenewDecorate.getRenewal() != null) {
                oldRenewDecorate.setRenewal(dataNode.getRenewal());
                oldRenewDecorate.renew();
            } 
        } 
        return dataNode;
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体如下图&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;+---------------------------------------+        +---------------------------------------------+
| +------------------------------+      |        |       +----------------------------------+  |
| | +----------------+  registry |Client|        | Server| +----------------------+registry |  |
| | |DataStoreService|           |      |        |       | | DataRepositoryService|         |  |
| | +-----+----------+           |      |        |       | +---------+------------+         |  |
| |       | replace              |      |        |       |           ^  replace             |  |
| |       |                      |      |        |       |           |                      |  |
| |       v                      |      |        |       |    +------+----+                 |  |
| | +-----+--------------------+ |      |        |       |    | Processor |                 |  |
| | |DataRepositoryService stub| |      |        |       |    +------+----+                 |  |
| | +-----+--------------------+ |      |        |       |           ^  onApply             |  |
| |       |                      |      |        |       |           |                      |  |
| |       v                      |      |        |       |   +-------+------+               |  |
| |     +-+---+                  |      |        |       |   | StateMachine |               |  |
| |     |Proxy|                  |      |        |       |   +-------+------+               |  |
| |     +-+---+                  |      |        |       |           ^  process             |  |
| |       | invoke               |      |        |       |           |                      |  |
| |       v                      |      |        |       |           |                      |  |
| |  +----+-------+              |      |        |       |    +------+------+               |  |
| |  |ProxyHandler|              |      |        |       |    |FSMCallerImpl|               |  |
| |  +----+-------+              |      |        |       |    +------+------+               |  |
| |       | sendRequest          |      |        |       |           ^                      |  |
| |       v                      |      |        |       |           |  received            |  |
| |   +---+------+               |      |        |       |           |                      |  |
| |   |RaftClient|               |      |        |       |   +-----------------+            |  |
| |   +----------+               |      | network|       |   |RaftServerHandler|            |  |
| |                              | +-------------------&amp;gt; |   +-----------------+            |  |
| +------------------------------+      |        |       +----------------------------------+  |
|                                       |        |                                             |
+---------------------------------------+        +---------------------------------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机上如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202010/1850883-20201009224518218-1316861681.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-renewnodesrequesthandler&quot;&gt;3.3 ReNewNodesRequestHandler&lt;/h3&gt;
&lt;p&gt;和注册一样，续约请求的处理 Handler 为&lt;code&gt;ReNewNodesRequestHandler&lt;/code&gt;，最终交由 StoreService 进行续约操作。另外一点，续约的时候如果没有查询到注册节点，会触发节点注册的操作。&lt;/p&gt;
&lt;p&gt;在初始化时候，就设置了ReNew handler。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        @Bean(name = &quot;sessionServerHandlers&quot;)
        public Collection&amp;lt;AbstractServerHandler&amp;gt; sessionServerHandlers() {
            Collection&amp;lt;AbstractServerHandler&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
            list.add(sessionConnectionHandler());
            list.add(sessionNodeHandler());
            list.add(renewNodesRequestHandler()); // 注册到Server handler
            list.add(getNodesRequestHandler());
            list.add(fetchProvideDataRequestHandler());
            return list;
        }

        @Bean(name = &quot;dataServerHandlers&quot;)
        public Collection&amp;lt;AbstractServerHandler&amp;gt; dataServerHandlers() {
            Collection&amp;lt;AbstractServerHandler&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
            list.add(dataConnectionHandler());
            list.add(getNodesRequestHandler());
            list.add(dataNodeHandler());
            list.add(renewNodesRequestHandler()); // 注册到Server handler
            list.add(fetchProvideDataRequestHandler());
            return list;
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RenewNodesRequestHandler extends AbstractServerHandler&amp;lt;RenewNodesRequest&amp;gt; {
    @Autowired
    private Registry            metaServerRegistry;

    @Override
    public Object reply(Channel channel, RenewNodesRequest renewNodesRequest) {
        Node renewNode = null;
        renewNode = renewNodesRequest.getNode();
        metaServerRegistry.renew(renewNode, renewNodesRequest.getDuration());
        return null;
    }

    @Override
    public Class interest() {
        return RenewNodesRequest.class;
    }

    @Override
    public HandlerType getType() {
        return HandlerType.PROCESSER;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x04-驱除&quot;&gt;0x04 驱除&lt;/h2&gt;
&lt;p&gt;驱出的操作是由定时任务完成，MetaServer 在启动时会启动多个定时任务，详见&lt;code&gt;ExecutorManager#startScheduler&lt;/code&gt;，其中一个任务会调用&lt;code&gt;Registry#evict&lt;/code&gt;，其实现为遍历存储的 Map, 获得过期的列表，调用&lt;code&gt;StoreService#removeNodes&lt;/code&gt;方法，将他们从 &lt;code&gt;Repository&lt;/code&gt; 中移除，&lt;u&gt;这个操作也会触发变更通知&lt;/u&gt;。该任务默认每3秒执行一次。&lt;/p&gt;
&lt;h3 id=&quot;41-配置&quot;&gt;4.1 配置&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void startScheduler() {
    scheduler.schedule(new TimedSupervisorTask(&quot;HeartbeatCheck&quot;, scheduler, heartbeatCheckExecutor,
                    metaServerConfig.getSchedulerHeartbeatTimeout(), TimeUnit.SECONDS,
                    metaServerConfig.getSchedulerHeartbeatExpBackOffBound(), () -&amp;gt; metaServerRegistry.evict()),
            metaServerConfig.getSchedulerHeartbeatFirstDelay(), TimeUnit.SECONDS);
}  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42-驱除&quot;&gt;4.2 驱除&lt;/h3&gt;
&lt;p&gt;这里就是遍历各种StoreService，获取其中的过期节点，然后进行驱除。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MetaServerRegistry implements Registry&amp;lt;Node&amp;gt; {
    @Override
    public void evict() {
        for (NodeType nodeType : NodeType.values()) {
            StoreService storeService = ServiceFactory.getStoreService(nodeType);
            if (storeService != null) {
                Collection&amp;lt;Node&amp;gt; expiredNodes = storeService.getExpired();
                if (expiredNodes != null &amp;amp;&amp;amp; !expiredNodes.isEmpty()) {
                    storeService.removeNodes(expiredNodes);
                }
            }
        }
    }  
}    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体又会继续调用 DataStoreService。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void removeNodes(Collection&amp;lt;DataNode&amp;gt; nodes) {
    write.lock();
    try {
        if (nodes != null &amp;amp;&amp;amp; !nodes.isEmpty()) {
            for (DataNode dataNode : nodes) {
                String ipAddress = dataNode.getNodeUrl().getIpAddress();
                RenewDecorate&amp;lt;DataNode&amp;gt; dataNodeRemove = dataRepositoryService
                    .remove(ipAddress);
                if (dataNodeRemove != null) {
                    dataConfirmStatusService.putConfirmNode(dataNode, DataOperator.REMOVE);
                }
            }
        }
    } finally {
        write.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后调用到 DataRepositoryService&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public RenewDecorate&amp;lt;DataNode&amp;gt; remove(Object key, Long currentTimeMillis) {
    try {
        String ipAddress = (String) key;
        String dataCenter = nodeConfig.getLocalDataCenter();

        NodeRepository&amp;lt;DataNode&amp;gt; dataNodeRepository = registry.get(dataCenter);
        if (dataNodeRepository != null) {
            Map&amp;lt;String/*ipAddress*/, RenewDecorate&amp;lt;DataNode&amp;gt;&amp;gt; dataNodes = dataNodeRepository
                .getNodeMap();
            if (dataNodes != null) {
                RenewDecorate&amp;lt;DataNode&amp;gt; oldRenewDecorate = dataNodes.remove(ipAddress);
                dataNodeRepository.setVersion(currentTimeMillis);
                return oldRenewDecorate;
            }
        }
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x05-节点列表查询&quot;&gt;0x05 节点列表查询&lt;/h2&gt;
&lt;p&gt;Data，Meta, Session Server 都提供 &lt;code&gt;getNodesRequestHandler&lt;/code&gt; ，用于处理查询当前节点列表的请求，其本质上从底层存储 Repository 读取数据返回。返回的结果的具体结构见 &lt;code&gt;NodeChangeResult&lt;/code&gt; 类，包含各个数据中心的节点列表以及版本号。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class NodeChangeResult&amp;lt;T extends Node&amp;gt; implements Serializable {
    private final NodeType                                               nodeType;
    private Map&amp;lt;String/*dataCenter id*/, Map&amp;lt;String /*ipAddress*/, T&amp;gt;&amp;gt; nodes;
    private Long                                                         version;
    private Map&amp;lt;String/*dataCenter*/, Long /*version*/&amp;gt;                dataCenterListVersions;
    /** local dataCenter id */
    private String                                                       localDataCenter;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;51-配置&quot;&gt;5.1 配置&lt;/h3&gt;
&lt;p&gt;Data，Meta，Session Server 都提供 &lt;code&gt;getNodesRequestHandler&lt;/code&gt;。具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean(name = &quot;sessionServerHandlers&quot;)
public Collection&amp;lt;AbstractServerHandler&amp;gt; sessionServerHandlers() {
    Collection&amp;lt;AbstractServerHandler&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    list.add(sessionConnectionHandler());
    list.add(sessionNodeHandler());
    list.add(renewNodesRequestHandler());
    list.add(getNodesRequestHandler()); // 做了配置
    list.add(fetchProvideDataRequestHandler());
    return list;
}

@Bean(name = &quot;dataServerHandlers&quot;)
public Collection&amp;lt;AbstractServerHandler&amp;gt; dataServerHandlers() {
    Collection&amp;lt;AbstractServerHandler&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    list.add(dataConnectionHandler());
    list.add(getNodesRequestHandler()); // 做了配置
    list.add(dataNodeHandler());
    list.add(renewNodesRequestHandler()); 
    list.add(fetchProvideDataRequestHandler());
    return list;
}

@Bean(name = &quot;metaServerHandlers&quot;)
public Collection&amp;lt;AbstractServerHandler&amp;gt; metaServerHandlers() {
    Collection&amp;lt;AbstractServerHandler&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    list.add(metaConnectionHandler());
    list.add(getNodesRequestHandler()); // 做了配置
    return list;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;getNodesRequestHandler的Bean配置生成如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public static class MetaServerRemotingConfiguration {
        @Bean
        public AbstractServerHandler getNodesRequestHandler() {
            return new GetNodesRequestHandler();
        }  
}  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;52-响应handler&quot;&gt;5.2 响应handler&lt;/h3&gt;
&lt;p&gt;NodesRequest 是通过Bolt来响应消息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class GetNodesRequestHandler extends AbstractServerHandler&amp;lt;GetNodesRequest&amp;gt; {
    @Autowired
    private Registry            metaServerRegistry;

    @Override
    public Object reply(Channel channel, GetNodesRequest getNodesRequest) {
        NodeChangeResult nodeChangeResult;
        try {
            nodeChangeResult = metaServerRegistry.getAllNodes(getNodesRequest.getNodeType());
        } 
        return nodeChangeResult;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;堆栈为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;getNodeChangeResult:188, MetaStoreService (com.alipay.sofa.registry.server.meta.store)
getAllNodes:96, MetaServerRegistry (com.alipay.sofa.registry.server.meta.registry)
reply:44, GetNodesRequestHandler (com.alipay.sofa.registry.server.meta.remoting.handler)
reply:33, GetNodesRequestHandler (com.alipay.sofa.registry.server.meta.remoting.handler)
handleRequest:54, SyncUserProcessorAdapter (com.alipay.sofa.registry.remoting.bolt)
dispatchToUserProcessor:239, RpcRequestProcessor (com.alipay.remoting.rpc.protocol)
doProcess:145, RpcRequestProcessor (com.alipay.remoting.rpc.protocol)
run:366, RpcRequestProcessor$ProcessTask (com.alipay.remoting.rpc.protocol)
runWorker:1149, ThreadPoolExecutor (java.util.concurrent)
run:624, ThreadPoolExecutor$Worker (java.util.concurrent)
run:748, Thread (java.lang)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体如下图所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                      +-------------------------+
                      | SyncUserProcessorAdapter|
                      +-----------+-------------+
                                  |
                                  |
                                  v  handleRequest
                       +----------+-----------+
                       |GetNodesRequestHandler|
                       +----------+-----------+
                                  |
                                  |
                                  v  getAllNodes
                         +--------+---------+
                         |MetaServerRegistry|
                         +--------+---------+
                                  |
                                  |
                                  v  getNodeChangeResult
                          +-------+--------+
                          |MetaStoreService|
                          +----+------+----+
                               |      |
                   +-----------+      +------------+
                   |                               |
      getNodeMap   v                               v  getNodeMap
+------------------+-----------+        +----------+-------------------+
|dataCenter, metaNodeRepository|  ...   |dataCenter, metaNodeRepository|
+------------------------------+        +------------------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以再具体深入下。&lt;/p&gt;
&lt;h3 id=&quot;53-registry操作&quot;&gt;5.3 Registry操作&lt;/h3&gt;
&lt;p&gt;Registry 只是简单调用StoreService。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MetaServerRegistry implements Registry&amp;lt;Node&amp;gt; {
    @Override
    public NodeChangeResult getAllNodes(NodeType nodeType) {
        StoreService storeService = ServiceFactory.getStoreService(nodeType);
        return storeService.getNodeChangeResult();
    }  
}  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;54-storeservice操作&quot;&gt;5.4 StoreService操作&lt;/h3&gt;
&lt;p&gt;Service 会遍历数据中心，获取对应的Node列表以及version，最终返回。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MetaStoreService implements StoreService&amp;lt;MetaNode&amp;gt; {
    @Override
    public NodeChangeResult getNodeChangeResult() {

        NodeChangeResult nodeChangeResult = new NodeChangeResult(NodeType.META);
        String localDataCenter = nodeConfig.getLocalDataCenter();
        Map&amp;lt;String/*dataCenter*/, NodeRepository&amp;gt; metaRepositoryMap = metaRepositoryService.getNodeRepositories();
        ConcurrentHashMap&amp;lt;String/*dataCenter*/, Map&amp;lt;String/*ipAddress*/, MetaNode&amp;gt;&amp;gt; pushNodes = new ConcurrentHashMap&amp;lt;&amp;gt;();
        Map&amp;lt;String/*dataCenter*/, Long&amp;gt; versionMap = new ConcurrentHashMap&amp;lt;&amp;gt;();

        metaRepositoryMap.forEach((dataCenter, metaNodeRepository) -&amp;gt; {

            if (localDataCenter.equalsIgnoreCase(dataCenter)) {
                nodeChangeResult.setVersion(metaNodeRepository.getVersion());
            }
            versionMap.put(dataCenter, metaNodeRepository.getVersion());

            Map&amp;lt;String, RenewDecorate&amp;lt;MetaNode&amp;gt;&amp;gt; dataMap = metaNodeRepository.getNodeMap();
            Map&amp;lt;String, MetaNode&amp;gt; newMap = new ConcurrentHashMap&amp;lt;&amp;gt;();
            dataMap.forEach((ip, dataNode) -&amp;gt; newMap.put(ip, dataNode.getRenewal()));
            pushNodes.put(dataCenter, newMap);
        });

        nodeChangeResult.setLocalDataCenter(localDataCenter);
        nodeChangeResult.setNodes(pushNodes);
        nodeChangeResult.setDataCenterListVersions(versionMap);
        return nodeChangeResult;
    } 
}  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;nodeChangeResult = 
 nodeType = {Node$NodeType@7190} &quot;DATA&quot;
 nodes = {ConcurrentHashMap@8267}  size = 1
  &quot;DefaultDataCenter&quot; -&amp;gt; {ConcurrentHashMap@8276}  size = 0
   key = &quot;DefaultDataCenter&quot;
   value = {ConcurrentHashMap@8276}  size = 0
 version = {Long@8268} 1601126414990
 dataCenterListVersions = {ConcurrentHashMap@8269}  size = 1
  &quot;DefaultDataCenter&quot; -&amp;gt; {Long@8268} 1601126414990
   key = &quot;DefaultDataCenter&quot;
   value = {Long@8268} 1601126414990
 localDataCenter = &quot;DefaultDataCenter&quot;
  value = {char[17]@8280} 
  hash = 761435552
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;55-节点变更时的数据同步&quot;&gt;5.5 节点变更时的数据同步&lt;/h3&gt;
&lt;p&gt;MetaServer 会通过网络连接感知到新节点上线或者下线，所有的 DataServer 中运行着一个定时刷新连接的任务 ConnectionRefreshTask，该任务定时去轮询 MetaServer，获取数据节点的信息。需要注意的是，除了 DataServer 主动去 MetaServer 拉取节点信息外，MetaServer 也会主动发送 NodeChangeResult 请求到各个节点，通知节点信息发生变化，推拉获取信息的最终效果是一致的。&lt;/p&gt;
&lt;p&gt;本文提到了很多Raft相关信息，下篇文章就具体探究下究竟MetaServer是如何使用 Raft。&lt;/p&gt;
&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-metaserver-function-introduction/&quot;&gt;服务注册中心 MetaServer 功能介绍和实现剖析 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-dataserver-smooth-expansion-contraction/&quot;&gt;服务注册中心如何实现 DataServer 平滑扩缩容 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-data-consistency/&quot;&gt;服务注册中心数据一致性方案分析 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-service-offline-notification/&quot;&gt;服务注册中心如何实现秒级服务上下线通知 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-session-storage/&quot;&gt;服务注册中心 Session 存储策略 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-data-fragmentation-synchronization-scheme/&quot;&gt;服务注册中心数据分片和同步方案详解 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-service-discovery-optimization/&quot;&gt;服务注册中心 SOFARegistry 解析 | 服务发现优化之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-introduction/&quot;&gt;海量数据下的注册中心 - SOFARegistry 架构介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/projects/sofa-registry/server-quick-start/&quot;&gt;服务端部署&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/projects/sofa-registry/client-quick-start/&quot;&gt;客户端使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/125573685&quot;&gt;全面理解Raft协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ff00yo/article/details/89212859&quot;&gt;详解蚂蚁金服 SOFAJRaft | 生产级高性能 Java 实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/13150808.html&quot;&gt;从JRaft来看Raft协议实现细节&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11627092.html&quot;&gt;SOFAJRaft—初次使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bookstack.cn/read/sofa-jraft/3.md&quot;&gt;JRaft 用户指南 &amp;amp; API 详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/bonelee/p/6228998.html&quot;&gt;怎样打造一个分布式数据库——rocksDB, raft, mvcc，本质上是为了解决跨数据中心的复制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.bubuko.com/infodetail-3451565.html&quot;&gt;sofa-bolt源码阅读(5)-日志&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mindwind/p/5231986.html&quot;&gt;Raft 为什么是更易理解的分布式一致性算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000022397988&quot;&gt;SOFAJRaft 源码分析一（启动流程和节点变化）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-jraft-algorithm-storage-module-deep-dive/&quot;&gt;SOFAJRaft 实现原理 - 生产级 Raft 算法库存储模块剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/projects/sofa-registry/client-quick-start/&quot;&gt;客户端使用&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 11 Oct 2020 00:37:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列将带领大家一起分析其MetaServer的实现机制，本文为第二篇，介绍MetaServer基本功能，比如注册，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/13789353.html</dc:identifier>
</item>
<item>
<title>洛谷  P6851 【onu】贪心 - liuchanglc</title>
<link>http://www.cnblogs.com/liuchanglc/p/13796131.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuchanglc/p/13796131.html</guid>
<description>&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P6851&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;因为小 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 打出的牌与小 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 打出的牌花色必须相同，所以我们需要按照花色分类讨论&lt;/p&gt;
&lt;p&gt;对于某一种花色&lt;/p&gt;
&lt;p&gt;如果小 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 没有这种花色的牌但是小 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 有，那么小 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 的牌一定打不出去，直接 &lt;span class=&quot;math inline&quot;&gt;\(continue\)&lt;/span&gt; 掉&lt;/p&gt;
&lt;p&gt;如果小 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 有这种花色的牌，那么对于小 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 来说，他肯定想让他赢的次数尽可能多&lt;/p&gt;
&lt;p&gt;这其实就是一个田忌赛马的问题&lt;/p&gt;
&lt;p&gt;我们把小 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 和小 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 的牌按照点数从大到小排序&lt;/p&gt;
&lt;p&gt;对于小 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 的每一张牌，我们在小 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 小于等于这张牌点数的牌里选择点数最大的那一张与其配对&lt;/p&gt;
&lt;p&gt;因为消耗一个点数大的牌肯定更优，这样可以为之后的牌创造更多的获胜机会&lt;/p&gt;
&lt;p&gt;因为小 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 的牌的点数是单调递减的，所以选出的牌的点数也一定是单调递减的&lt;/p&gt;
&lt;p&gt;因此，我们可以用一个指针维护&lt;/p&gt;
&lt;p&gt;这样到最后小 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 的牌要么都打光，要么剩下一些&lt;/p&gt;
&lt;p&gt;对于剩下的牌，我们随便配对就可以了，因为打出去肯定比不打出去更优&lt;/p&gt;
&lt;p&gt;在匹配的过程中如果小 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 的牌不够用，那么就停止匹配&lt;/p&gt;
&lt;p&gt;如果小 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 的牌打光后小 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 还剩下牌，那么小 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 只能选择弃权&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#define rg register
struct asd{
        int id,val;
        asd(){}
        asd(int aa,int bb){ id=aa,val=bb; }
};
bool cmp(asd aa,asd bb){
        return aa.val&amp;gt;bb.val;
}
const int maxn=1e5+5;
std::vector&amp;lt;asd&amp;gt; gd[maxn],gc[maxn];
int ans[maxn],n,m,maxid;
long long c,v;
bool vis[maxn];
void solve(int id){
        if(gc[id].size()==0) return;
        rg int head=0,js=0;
        for(rg int i=0;i&amp;lt;gd[id].size();i++){
                rg int cs=gd[id][i].val;
                if(head&amp;gt;=gc[id].size()) break;
                while(1){
                        if(gc[id][head].val&amp;gt;cs) head++;
                        if(head&amp;gt;=gc[id].size()) break;
                        if(gc[id][head].val&amp;lt;=cs){
                                ans[gc[id][head].id]=gd[id][i].id;
                                vis[gc[id][head].id]=1;
                                v=v+c+gd[id][i].val;
                                head++,js++;
                                break;
                        }
                }
        }
        for(rg int i=0;i&amp;lt;gc[id].size();i++){
                rg int now=gc[id][i].id;
                if(vis[now]) continue;
                if(js&amp;gt;=gd[id].size()){
                        ans[now]=-1;
                        vis[now]=1;
                        v=v-c;
                } else {
                        ans[now]=gd[id][js].id;
                        v=v-c+gd[id][js].val;
                        vis[now]=1;
                        js++;
                }
        }
}
int main(){
        scanf(&quot;%d%d%lld%lld&quot;,&amp;amp;n,&amp;amp;m,&amp;amp;c,&amp;amp;v);
        rg int aa,bb;
        for(rg int i=1;i&amp;lt;=n;i++){
                scanf(&quot;%d%d&quot;,&amp;amp;aa,&amp;amp;bb);
                gd[aa].push_back(asd(i,bb));
                maxid=std::max(maxid,aa);
        }
        for(rg int i=1;i&amp;lt;=m;i++){
                scanf(&quot;%d%d&quot;,&amp;amp;aa,&amp;amp;bb);
                gc[aa].push_back(asd(i,bb));
                maxid=std::max(maxid,aa);
        }
        for(rg int i=1;i&amp;lt;=maxid;i++){
                std::sort(gd[i].begin(),gd[i].end(),cmp);
                std::sort(gc[i].begin(),gc[i].end(),cmp);
        }
        for(rg int i=1;i&amp;lt;=maxid;i++) solve(i);
        printf(&quot;%lld\n&quot;,v);
        for(rg int i=1;i&amp;lt;=m;i++) printf(&quot;%d\n&quot;,ans[i]);
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 11 Oct 2020 00:05:00 +0000</pubDate>
<dc:creator>liuchanglc</dc:creator>
<og:description>题目描述 题目传送门 分析 因为小 \(D\) 打出的牌与小 \(C\) 打出的牌花色必须相同，所以我们需要按照花色分类讨论 对于某一种花色 如果小 \(C\) 没有这种花色的牌但是小 \(D\)	有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuchanglc/p/13796131.html</dc:identifier>
</item>
<item>
<title>DX12龙书 01 - 向量在几何学和数学中的表示以及运算定义 - drnkcff</title>
<link>http://www.cnblogs.com/drnkcff/p/13795323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/drnkcff/p/13795323.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;向量 ( vector ) 是一种兼具大小 ( magnitude ) 和方向的量。&lt;/p&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;几何方法中用一条有向线段来表示一个向量，其中，线段长度代表向量的模，箭头的指向代表向量的方向。&lt;/p&gt;
&lt;p&gt;改变向量的位置不会改变其大小和方向，所以向量与其位置无关。当我们说两个向量相等，当且仅当它们的长度相等且方向相同。&lt;/p&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;数学中使用坐标系来描述向量，通过平移操作将向量的尾部移动到原点，就可以通过坐标来确定该向量。&lt;/p&gt;
&lt;p&gt;每当我们根据坐标来确定一个向量时，其对应的坐标总是相对于某一参考系而言的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;标量和向量都可以用坐标 (x, y, z) 来表示。但它们的意义截然不同：点仅表示位置，而向量表示大小与方向。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;设有向量 &lt;span class=&quot;math inline&quot;&gt;\(u = (u_x, u_y, y_z)\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(v = (v_x, v_y, v_z)\)&lt;/span&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;两个向量相等，当且仅当它们对应的分量分别相等。&lt;/li&gt;
&lt;li&gt;向量加法：&lt;span class=&quot;math inline&quot;&gt;\(u + v = (u_x + v_x, u_y + v_y, u_z + v_z)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;标量乘法 ( scalar multiplication )，设 k 是一个标量，则 &lt;span class=&quot;math inline&quot;&gt;\(ku = (ku_x, ku_y, ku_z)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;向量减法：&lt;span class=&quot;math inline&quot;&gt;\(u - v = (u_x - v_x, u_y - v_y, u_z - v_z)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\((0, 0, 0)\)&lt;/span&gt; 称为零向量 (zero-vector)，可简记为 0。&lt;/li&gt;
&lt;/ol&gt;&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;向量的大小（即模）的几何意义是对应有向线段的擦汗高难度，用双竖线表示（如 &lt;span class=&quot;math inline&quot;&gt;\(||u||\)&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;代数计算方法：&lt;span class=&quot;math inline&quot;&gt;\(\|u\| = \sqrt{x^2 + y^2 + z^2}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;规范化 (normalizing) ：&lt;/p&gt;
&lt;p&gt;将向量的长度变为单位长度，将向量的每个分量分别除以该向量的模：&lt;span class=&quot;math inline&quot;&gt;\(\hat{u} = \frac{u}{\|u\|} = (\frac{x}{\|u\|},\frac{y}{\|u\|}\frac{z}{\|u\|})\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;规范化又称标准化、归一化、正常化、规格化、正态化、单位化……不必拘泥于名词译法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;点积 ( dot product ，也称为数量积或内积 ) 是一种计算结果为标量值的向量乘法运算，因此也称标量积 ( scalar product )。设 &lt;span class=&quot;math inline&quot;&gt;\(u = (u_x, u_y, y_z)\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(v = (v_x, v_y, v_z)\)&lt;/span&gt;，则点积的定义为：&lt;span class=&quot;math inline&quot;&gt;\(u \cdot v = u_xv_x + u_yv_y + u_zv_z\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点积的几何意义是：&lt;span class=&quot;math inline&quot;&gt;\(u \cdot v = \|u\| \|v\| \cos{\theta}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点积的一些几何性质：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(u \cdot v = 0\)&lt;/span&gt;，那么 &lt;span class=&quot;math inline&quot;&gt;\(u \perp v\)&lt;/span&gt; （即两个向量正交）。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(u \cdot v \gt 0\)&lt;/span&gt;，那么两向量之间的夹角 θ 小于 90°（即两向量间的夹角为一锐角）。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(u \cdot v \lt 0\)&lt;/span&gt;，那么两向量之间的夹角 θ 大于 90°（即两向量间的夹角为一钝角）。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;正交 （orthogonal）与垂直（perendicular）为同义词。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;给出向量 v 和单位向量 n，用点积公式求出 p。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1890896/202010/1890896-20201010214523031-1746004248.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为 n 是单位向量，所以：&lt;span class=&quot;math inline&quot;&gt;\(p = (\|v\| \cos{\theta}) n = (v \cdot n)n\)&lt;/span&gt;。我们称 p 为向量 v 落在向量 n 上的&lt;strong&gt;正交投影&lt;/strong&gt;（orhogonal projection），通常将它表示为：&lt;span class=&quot;math inline&quot;&gt;\(p = proj_n(v)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果 n 不具有单位长度，就先对它进行规划法处理，使之成为单位向量。可以得到更一般的投影公式：&lt;span class=&quot;math inline&quot;&gt;\(p = proj_n(v) = (v \cdot \frac{n}{\|n\|}) \frac{n}{\|n\|} = \frac{(v \cdot n)}{\|n\|^2}n\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果向量集合中每个向量都是相互正交且皆具单位长度，我们就称此集合是&lt;strong&gt;规范正交&lt;/strong&gt;（orhonormal）的。&lt;/p&gt;
&lt;br/&gt;有一种常见的工作，将非规范正交集正交化。
&lt;p&gt;&lt;strong&gt;1.2D 正交化处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设有一个向量集合 &lt;span class=&quot;math inline&quot;&gt;\(\{v_0, v_1\}\)&lt;/span&gt;，现在要将它正交化为 &lt;span class=&quot;math inline&quot;&gt;\(\{w_0, w_1\}\)&lt;/span&gt;。首先设 &lt;span class=&quot;math inline&quot;&gt;\(w_0=v_0\)&lt;/span&gt;，通过使 &lt;span class=&quot;math inline&quot;&gt;\(v_1\)&lt;/span&gt; 减去它在 &lt;span class=&quot;math inline&quot;&gt;\(w_0\)&lt;/span&gt; 上的分量来令它正交于 &lt;span class=&quot;math inline&quot;&gt;\(w_0\)&lt;/span&gt;：&lt;span class=&quot;math inline&quot;&gt;\(w_1 = v_1 - proj_{w_0}(v_1)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;此时我们就得到一个元素相互正交的向量集合 &lt;span class=&quot;math inline&quot;&gt;\(\{w_0, w_1\}\)&lt;/span&gt;；最后将其中的元素规范化为单位向量即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3D 正交化处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与 2D 的处理方式类似，只不过要多一些步骤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.格拉姆-施密特正交化（Gram-Schmidt Orthogonalization）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于具有 n 个向量的一般集合 &lt;span class=&quot;math inline&quot;&gt;\(\{ v_0, ..., v_{n-1}\}\)&lt;/span&gt; 来说，基本步骤：&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(w_0 = v_0\)&lt;/span&gt;，对于 &lt;span class=&quot;math inline&quot;&gt;\(1 \le i \le n - 1\)&lt;/span&gt;，令 &lt;span class=&quot;math inline&quot;&gt;\(w_i=v_i - \sum_{j=0}^{i-1}proj_{w_j}(v_i)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;规范化步骤：令 &lt;span class=&quot;math inline&quot;&gt;\(w_i=\frac{w_i}{\|w_i\|}\)&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;将给定集合内的向量 &lt;span class=&quot;math inline&quot;&gt;\(v_i\)&lt;/span&gt; 添加到规范正交集中时，需要令 &lt;span class=&quot;math inline&quot;&gt;\(v_i\)&lt;/span&gt; 减去它在现有规范正交集中的其他向量方向上的分量，这样可以确保新加入规范正交集的向量与该集合中的其他向量相互正交。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;假设 3D 向量 u 与 v 的叉积为 w，则 w 与向量 u、v 彼此正交。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(w = u \times v = (u_yv_z - u_zv_y, u_zv_x - u_xv_z, u_xv_y - u_yv_x)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过叉积来进行正交化&lt;/p&gt;
&lt;p&gt;流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(w_0 = \frac{v_0}{\|v_0\|}\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(w_2 = \frac{w_0 \times v_1}{\|w_0 \times v_1\|}\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(w_1 = w_2 \times w_0\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此时，向量集 &lt;span class=&quot;math inline&quot;&gt;\(\{ w_0, w_1, w_2 \}\)&lt;/span&gt; 是规范正交的。&lt;/p&gt;
&lt;br/&gt;</description>
<pubDate>Sat, 10 Oct 2020 23:27:00 +0000</pubDate>
<dc:creator>drnkcff</dc:creator>
<og:description>0x00 向量 向量 ( vector ) 是一种兼具大小 ( magnitude ) 和方向的量。 0x01 几何表示 几何方法中用一条有向线段来表示一个向量，其中，线段长度代表向量的模，箭头的指向</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/drnkcff/p/13795323.html</dc:identifier>
</item>
<item>
<title>JVM系列【4】内存模型 - kongxubihai</title>
<link>http://www.cnblogs.com/kongbubihai/p/13796052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kongbubihai/p/13796052.html</guid>
<description>&lt;h2 id=&quot;jvm系列笔记目录&quot;&gt;JVM系列笔记目录&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;虚拟机的基础概念&lt;/li&gt;
&lt;li&gt;class文件结构&lt;/li&gt;
&lt;li&gt;class文件加载过程&lt;/li&gt;
&lt;li&gt;jvm内存模型&lt;/li&gt;
&lt;li&gt;JVM常用指令&lt;/li&gt;
&lt;li&gt;GC与调优&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;硬件层数据一致性&quot;&gt;硬件层数据一致性&lt;/h3&gt;
&lt;h4 id=&quot;--存储器层次结构&quot;&gt;- 存储器层次结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1295651/202010/1295651-20201011014108077-1425354914.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从L6-L0 空间由大变小，速度由慢到快。&lt;/p&gt;
&lt;h4 id=&quot;-缓存一致性算法&quot;&gt;-缓存一致性算法&lt;/h4&gt;
&lt;p&gt;CPU实现缓存一致性的协议很多，其中intel 使用的MESI(Modified Exclusive Shared Or Invalid)协议。具体可以参考：[&lt;a href=&quot;https://www.cnblogs.com/z00377750/p/9180644.html&quot;&gt;MESI--CPU缓存一致性协议&lt;/a&gt;](&lt;a href=&quot;https://www.cnblogs.com/z00377750/p/9180644.html&quot;&gt;https://www.cnblogs.com/z00377750/p/9180644.html&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1295651/202010/1295651-20201011014108883-1611103947.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现代CPU的数据一致性实现=缓存锁(MESI...) +总线锁&lt;/p&gt;
&lt;h4 id=&quot;-缓存行&quot;&gt;-缓存行&lt;/h4&gt;
&lt;p&gt;缓存读取时的单位，一般是64Byte&lt;br/&gt;使用缓存行的对齐能够提高效率&lt;/p&gt;
&lt;h4 id=&quot;-伪共享&quot;&gt;-伪共享&lt;/h4&gt;
&lt;p&gt;位于同一缓存行的2个不同的数据，被2个不同的CPU锁定，产生互相影响的伪共享问题。&lt;/p&gt;
&lt;p&gt;如何解决？ 使用缓存行的对齐能够提高效率&lt;/p&gt;
&lt;h4 id=&quot;cpu乱序问题&quot;&gt;CPU乱序问题&lt;/h4&gt;
&lt;h4 id=&quot;--概念&quot;&gt;- 概念&lt;/h4&gt;
&lt;p&gt;CPU为了提高执行效率，会在一条指令执行的过程中(比如去内存取数据(慢100倍))，去同时执行另一条指令，前提是两条指令没有依赖关系。具体参考：[&lt;a href=&quot;https://www.cnblogs.com/liushaodong/p/4777308.html&quot;&gt;现代cpu的合并写技术对程序的影响&lt;/a&gt;](&lt;a href=&quot;https://www.cnblogs.com/liushaodong/p/4777308.html&quot;&gt;https://www.cnblogs.com/liushaodong/p/4777308.html&lt;/a&gt;)&lt;/p&gt;
&lt;h4 id=&quot;-合并写&quot;&gt;-合并写&lt;/h4&gt;
&lt;p&gt;CPU上有一个WriteCombinBuffer，仅4个字节，比L1等级还高，某些写操作会合并在一起提交。[&lt;a href=&quot;https://www.cnblogs.com/liushaodong/p/4777308.html&quot;&gt;现代cpu的合并写技术对程序的影响&lt;/a&gt;](&lt;a href=&quot;https://www.cnblogs.com/liushaodong/p/4777308.html&quot;&gt;https://www.cnblogs.com/liushaodong/p/4777308.html&lt;/a&gt;)&lt;/p&gt;
&lt;h4 id=&quot;-乱序证明&quot;&gt;-乱序证明&lt;/h4&gt;
&lt;p&gt;CPU乱序现象有大佬写程序模拟出来了，具体参考： &lt;a href=&quot;https://preshing.com/20120515/memory-reordering-caught-in-the-act/&quot;&gt;Memory Reordering Caught in the Act&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;如何保证在特定情况下保证不乱序&quot;&gt;如何保证在特定情况下保证不乱序&lt;/h4&gt;
&lt;h4 id=&quot;硬件级别&quot;&gt;硬件级别&lt;/h4&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;X86 CPU级别内存屏障&lt;/p&gt;
&lt;p&gt;sfence&lt;br/&gt;store fence 在sfence指令前的写操作必须在sfence指令后的写操作前完成&lt;/p&gt;
&lt;p&gt;lfence&lt;br/&gt;load fence 在lfence指令前的读操作必须在lfence指令后的读操作前完成&lt;/p&gt;
&lt;p&gt;mfence&lt;br/&gt;mixed fence 在mfence指令前的读写操作必须在mfence指令后的读写操作前完成&lt;/p&gt;
&lt;p&gt;CPU原子指令&lt;br/&gt;如x86上的”lock …” 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU&lt;/p&gt;
&lt;p&gt;总结： Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保持程序顺序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;jvm级别&quot;&gt;JVM级别&lt;/h4&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;JSR113规范规定了4种内存屏障&lt;/p&gt;
&lt;p&gt;LoadLoad屏障&lt;br/&gt;对于语句Load1;LoadLoad;Load2，在Load2及后续读取指令要读取的数据被访问前，保证Load1要读取的数据被读取完毕&lt;/p&gt;
&lt;p&gt;StoreStore屏障&lt;br/&gt;对于语句Store1;StoreStore;Store2,在Store2及后续写操作执行前，保证Store1的写入操作对其它处理器可见&lt;/p&gt;
&lt;p&gt;LoadStore屏障&lt;br/&gt;对于语句Load1;StoreStore;Store2,在Store2及后续写操作被刷出前，保证Load1要读取的数据被读取完毕&lt;/p&gt;
&lt;p&gt;StoreLoad屏障&lt;br/&gt;对于语句Store1;StoreStore;Load2,在Load2及后续读取指令要执行前，保证Store1的写入操作对其它处理器可见&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;sychronizedvolatile在字节码、jvm、硬件os层面实现细节&quot;&gt;sychronized/volatile在字节码、JVM、硬件OS层面实现细节&lt;/h4&gt;
&lt;h4 id=&quot;--sychronized&quot;&gt;- sychronized&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;字节码层面&lt;/p&gt;
&lt;p&gt;sychronized m() : AccessFlag : ACC_VOLATILE&lt;/p&gt;
&lt;p&gt;sychronized(this){} : monitorenter monitorexit monitorenter&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;JVM层面&lt;/p&gt;
&lt;p&gt;C/C++ 调用操作系统的同步操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;硬件OS层面&lt;/p&gt;
&lt;p&gt;X86 : lock cmpxchg / xxx&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;-volatile&quot;&gt;-volatile&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;字节码层面&lt;br/&gt;AccessFlag : ACC_VOLATILE&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;JVM层面&lt;/p&gt;
&lt;p&gt;volatile内存区域都加屏障&lt;/p&gt;
&lt;p&gt;StoreStoreBarrier volatile 写操作 StoreLoadBarrier&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;​ LoadLoadBarrier ​ volatile 读操作 ​ LoadStoreBarrier&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;面试new-object-6连问&quot;&gt;面试new Object() 6连问&lt;/h3&gt;
&lt;ul readability=&quot;3.7699115044248&quot;&gt;&lt;li readability=&quot;2.6647564469914&quot;&gt;
&lt;p&gt;1.解释对象的创建过程&lt;/p&gt;
&lt;p&gt;该问题结合上篇博客：&lt;a href=&quot;https://blog.csdn.net/qq_21579619/article/details/109001854&quot;&gt;JVM系列【3】Class文件加载过程&lt;/a&gt;不难回答出来。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;class loading&lt;/p&gt;
&lt;p&gt;class linking (vertification prepraration resolution)&lt;/p&gt;
&lt;p&gt;class initiazing&lt;/p&gt;
&lt;p&gt;new 申请内存空间&lt;/p&gt;
&lt;p&gt;成员变量赋初始值&lt;/p&gt;
&lt;p&gt;调用构造方法:成员变量赋初始值；执行构造方法语句，super()父类构造。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;2.对象在内存中的存储布局&lt;/p&gt;
&lt;p&gt;对象在内存中布局分普通对象和数组对象。&lt;/p&gt;
&lt;p&gt;普通对象4部分：对象头markword(8字节)、ClassPointer指针(4或8字节)、实例数据、padding对齐为8的倍数。&lt;/p&gt;
&lt;p&gt;数组对象5部分，和普通对象类似，但中间是数组长度4字节和具体的数组数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1295651/202010/1295651-20201011014109454-1345580660.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.3309352517986&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;3.对象头具体包括什么&lt;/p&gt;
&lt;p&gt;对象头markword(8字节)具体内容和对象锁状态有关系，其中最高位2位是锁状态中，最低3位用作锁标志位，中间4位是GC年龄，如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1295651/202010/1295651-20201011014253677-451292269.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5948275862069&quot;&gt;
&lt;p&gt;4.对象怎么定位&lt;/p&gt;
&lt;p&gt;通过句柄池和直接指针，具体参考：&lt;a href=&quot;https://blog.csdn.net/clover_lily/article/details/80095580&quot;&gt;访问对象两种方式--句柄和直接指针&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;5.对象怎么分配？&lt;/p&gt;
&lt;p&gt;对象的分配其实和垃圾回收GC有关系，后续总结GC详细讲。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1295651/202010/1295651-20201011014109802-290925713.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;知识分享，转载请注明出处。学无先后，达者为先！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 10 Oct 2020 17:41:00 +0000</pubDate>
<dc:creator>kongxubihai</dc:creator>
<og:description>JVM系列笔记目录 虚拟机的基础概念 class文件结构 class文件加载过程 jvm内存模型 JVM常用指令 GC与调优 硬件层数据一致性 - 存储器层次结构 从L6-L0 空间由大变小，速度由慢</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kongbubihai/p/13796052.html</dc:identifier>
</item>
<item>
<title>golang拾遗：指针和接口 - apocelipes</title>
<link>http://www.cnblogs.com/apocelipes/p/13796041.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apocelipes/p/13796041.html</guid>
<description>&lt;p&gt;这是本系列的第一篇文章，golang拾遗主要是用来记录一些遗忘了的、平时从没注意过的golang相关知识。想做本系列的契机其实是因为疫情闲着在家无聊，网上冲浪的时候发现了zhuihu上的&lt;a href=&quot;https://www.zhihu.com/column/polaris&quot;&gt;go语言爱好者周刊&lt;/a&gt;和&lt;a href=&quot;https://go101.org/article/101.html&quot;&gt;Go 101&lt;/a&gt;，读之如醍醐灌顶，受益匪浅，于是本系列的文章就诞生了。拾遗主要是收集和golang相关的琐碎知识，当然也会对周刊和101的内容做一些补充说明。好了，题外话就此打住，下面该进入今天的正题了。&lt;/p&gt;
&lt;h2 id=&quot;指针和接口&quot;&gt;指针和接口&lt;/h2&gt;
&lt;p&gt;golang的类型系统其实很有意思，有意思的地方就在于类型系统表面上看起来众生平等，然而实际上却要分成普通类型（types）和接口（interfaces）来看待。普通类型也包含了所谓的引用类型，例如&lt;code&gt;slice&lt;/code&gt;和&lt;code&gt;map&lt;/code&gt;，虽然他们和&lt;code&gt;interface&lt;/code&gt;同为引用类型，但是行为更趋近于普通的内置类型和自定义类型，因此只有特立独行的&lt;code&gt;interface&lt;/code&gt;会被单独归类。&lt;/p&gt;
&lt;p&gt;那我们是依据什么把golang的类型分成两类的呢？其实很简单，看类型能不能在编译期就确定以及调用的类型方法是否能在编译期被确定。&lt;/p&gt;
&lt;p&gt;如果觉得上面的解释太过抽象的可以先看一下下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;package main

import &quot;fmt&quot;

func main(){
    m := make(map[int]int)
    m[1] = 1 * 2
    m[2] = 2 * 2
    fmt.Println(m)
    m2 := make(map[string]int)
    m2[&quot;python&quot;] = 1
    m2[&quot;golang&quot;] = 2
    fmt.Println(m2)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们来看非interface的引用类型，&lt;code&gt;m&lt;/code&gt;和&lt;code&gt;m2&lt;/code&gt;明显是两个不同的类型，不过实际上在底层他们是一样的，不信我们用objdump工具检查一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;go tool objdump -s 'main\.main' a

TEXT main.main(SB) /tmp/a.go
  a.go:6  CALL runtime.makemap_small(SB)     # m := make(map[int]int)
  ...
  a.go:7  CALL runtime.mapassign_fast64(SB)  # m[1] = 1 * 2
  ...
  a.go:8  CALL runtime.mapassign_fast64(SB)  # m[2] = 2 * 2
  ...
  ...
  a.go:10 CALL runtime.makemap_small(SB)     # m2 := make(map[string]int)
  ...
  a.go:11 CALL runtime.mapassign_faststr(SB) # m2[&quot;python&quot;] = 1
  ...
  a.go:12 CALL runtime.mapassign_faststr(SB) # m2[&quot;golang&quot;] = 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;省略了一些寄存器的操作和无关函数的调用，顺便加上了对应的代码的原文，我们可以清晰地看到尽管类型不同，但map调用的方法都是相同的而且是编译期就已经确定的。如果是自定义类型呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;package main

import &quot;fmt&quot;

type Person struct {
    name string
    age int
}

func (p *Person) sayHello() {
    fmt.Printf(&quot;Hello, I'm %v, %v year(s) old\n&quot;, p.name, p.age)
}

func main(){
    p := Person{
        name: &quot;apocelipes&quot;,
        age: 100,
    }
    p.sayHello()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次我们创建了一个拥有自定义字段和方法的自定义类型，下面再用objdump检查一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;go tool objdump -s 'main\.main' b

TEXT main.main(SB) /tmp/b.go
  ...
  b.go:19   CALL main.(*Person).sayHello(SB)
  ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用字面量创建对象和初始化调用堆栈的汇编代码不是重点，重点在于那句&lt;code&gt;CALL&lt;/code&gt;，我们可以看到自定义类型的方法也是在编译期就确定了的。&lt;/p&gt;
&lt;p&gt;那反过来看看interface会有什么区别：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;package main

import &quot;fmt&quot;

type Worker interface {
    Work()
}

type Typist struct{}
func (*Typist)Work() {
    fmt.Println(&quot;Typing...&quot;)
}

type Programer struct{}
func (*Programer)Work() {
    fmt.Println(&quot;Programming...&quot;)
}

func main(){
    var w Worker = &amp;amp;Typist{}
    w.Work()
    w = &amp;amp;Programer{}
    w.Work()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意！编译这个程序需要禁止编译器进行优化，否则编译器会把接口的方法查找直接优化为特定类型的方法调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;go build -gcflags &quot;-N -l&quot; c.go
go tool objdump -S -s 'main\.main' c

TEXT main.main(SB) /tmp/c.go
  ...
  var w Worker = &amp;amp;Typist{}
    LEAQ runtime.zerobase(SB), AX
    MOVQ AX, 0x10(SP)
    MOVQ AX, 0x20(SP)
    LEAQ go.itab.*main.Typist,main.Worker(SB), CX
    MOVQ CX, 0x28(SP)
    MOVQ AX, 0x30(SP)
  w.Work()
    MOVQ 0x28(SP), AX
    TESTB AL, 0(AX)
    MOVQ 0x18(AX), AX
    MOVQ 0x30(SP), CX
    MOVQ CX, 0(SP)
    CALL AX
  w = &amp;amp;Programer{}
    LEAQ runtime.zerobase(SB), AX
    MOVQ AX, 0x8(SP)
    MOVQ AX, 0x18(SP)
    LEAQ go.itab.*main.Programer,main.Worker(SB), CX
    MOVQ CX, 0x28(SP)
    MOVQ AX, 0x30(SP)
  w.Work()
    MOVQ 0x28(SP), AX
    TESTB AL, 0(AX)
    MOVQ 0x18(AX), AX
    MOVQ 0x30(SP), CX
    MOVQ CX, 0(SP)
    CALL AX
  ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次我们可以看到调用接口的方法会去在runtime进行查找，随后&lt;code&gt;CALL&lt;/code&gt;找到的地址，而不是像之前那样在编译期就能找到对应的函数直接调用。这就是interface为什么特殊的原因：interface是动态变化的类型。&lt;/p&gt;
&lt;p&gt;可以动态变化的类型最显而易见的好处是给予程序高度的灵活性，但灵活性是要付出代价的，主要在两方面。&lt;/p&gt;
&lt;p&gt;一是性能代价。动态的方法查找总是要比编译期就能确定的方法调用多花费几条汇编指令（mov和lea通常都是会产生实际指令的），数量累计后就会产生性能影响。不过好消息是通常编译器对我们的代码进行了优化，例如&lt;code&gt;c.go&lt;/code&gt;中如果我们不关闭编译器的优化，那么编译器会在编译期间就替我们完成方法的查找，实际生产的代码里不会有动态查找的内容。然而坏消息是这种优化需要编译器可以在编译期确定接口引用数据的实际类型，考虑如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;type Worker interface {
    Work()
}

for _, v := workers {
    v.Work()
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为只要实现了&lt;code&gt;Worker&lt;/code&gt;接口的类型就可以把自己的实例塞进&lt;code&gt;workers&lt;/code&gt;切片里，所以编译器不能确定v引用的数据的类型，优化自然也无从谈起了。&lt;/p&gt;
&lt;p&gt;而另一个代价，确切地说其实应该叫陷阱，就是接下来我们要探讨的主题了。&lt;/p&gt;
&lt;h2 id=&quot;golang的指针&quot;&gt;golang的指针&lt;/h2&gt;
&lt;p&gt;指针也是一个极有探讨价值的话题，特别是指针在reflect以及runtime包里的各种黑科技。不过放轻松，今天我们只用了解下指针的自动解引用。&lt;/p&gt;
&lt;p&gt;我们把&lt;code&gt;b.go&lt;/code&gt;里的代码改动一行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;p := &amp;amp;Person{
    name: &quot;apocelipes&quot;,
    age: 100,
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;p现在是个指针，其余代码不需要任何改动，程序依旧可以正常编译执行。对应的汇编是这样的画风（当然得关闭优化）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;p.sayHello()
    MOVQ AX, 0(SP)
    CALL main.(*Person).sayHello(SB)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对比一下非指针版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;p.sayHello()
    LEAQ 0x8(SP), AX
    MOVQ AX, 0(SP)
    CALL main.(*Person).sayHello(SB)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与其说是指针自动解引用，倒不如说是非指针版本先求出了对象的实际地址，随后传入了这个地址作为方法的接收器调用了方法。这也没什么好奇怪的，因为我们的方法是指针接收器：P。&lt;/p&gt;
&lt;p&gt;如果把接收器换成值类型接收器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;p.sayHello()
    TESTB AL, 0(AX)
    MOVQ 0x40(SP), AX
    MOVQ 0x48(SP), CX
    MOVQ 0x50(SP), DX
    MOVQ AX, 0x28(SP)
    MOVQ CX, 0x30(SP)
    MOVQ DX, 0x38(SP)
    MOVQ AX, 0(SP)
    MOVQ CX, 0x8(SP)
    MOVQ DX, 0x10(SP)
    CALL main.Person.sayHello(SB)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为对比：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;p.sayHello()
    MOVQ AX, 0(SP)
    MOVQ $0xa, 0x8(SP)
    MOVQ $0x64, 0x10(SP)
    CALL main.Person.sayHello(SB)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候golang就是先检查指针随后解引用了。同时要注意，这里的方法调用是已经在编译期确定了的。&lt;/p&gt;
&lt;h2 id=&quot;指向interface的指针&quot;&gt;指向interface的指针&lt;/h2&gt;
&lt;p&gt;铺垫了这么久，终于该进入正题了。不过在此之前还有一点小小的预备知识需要提一下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;A pointer type denotes the set of all pointers to variables of a given type, called the base type of the pointer. --- go language spec&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;换而言之，只要是能取地址的类型就有对应的指针类型，比较巧的是在golang里引用类型是可以取地址的，包括interface。&lt;/p&gt;
&lt;p&gt;有了这些铺垫，现在我们可以看一下我们的说唱歌手程序了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;package main

import &quot;fmt&quot;

type Rapper interface {
    Rap() string
}

type Dean struct {}

func (_ Dean) Rap() string {
    return &quot;Im a rapper&quot;
}

func doRap(p *Rapper) {
    fmt.Println(p.Rap())
}

func main(){
    i := new(Rapper)
    *i = Dean{}
    fmt.Println(i.Rap())
    doRap(i)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题来了，小青年Dean能圆自己的说唱梦么？&lt;/p&gt;
&lt;p&gt;很遗憾，编译器给出了反对意见：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;# command-line-arguments
./rapper.go:16:18: p.Rap undefined (type *Rapper is pointer to interface, not interface)
./rapper.go:22:18: i.Rap undefined (type *Rapper is pointer to interface, not interface)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也许&lt;code&gt;type *XXX is pointer to interface, not interface&lt;/code&gt;这个错误你并不陌生，你曾经也犯过用指针指向interface的错误，经过一番搜索后你找到了一篇教程，或者是博客，有或者是随便什么地方的资料，他们都会告诉你不应该用指针去指向接口，接口本身是引用类型无需再用指针去引用。&lt;/p&gt;
&lt;p&gt;其实他们只说对了一半，事实上只要把i和p改成接口类型就可以正常编译运行了。没说对的一半是指针可以指向接口，也可以使用接口的方法，但是要绕些弯路（当然，用指针引用接口通常是多此一举，所以听从经验之谈也没什么不好的）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func doRap(p *Rapper) {
    fmt.Println((*p).Rap())
}

func main(){
    i := new(Rapper)
    *i = Dean{}
    fmt.Println((*i).Rap())
    doRap(i)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;go run rapper.go 

Im a rapper
Im a rapper
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;神奇的一幕出现了，程序不仅没报错而且运行得很正常。但是这和golang对指针的自动解引用有什么区别呢？明明看起来都一样但就是第一种方案会报&lt;br/&gt;找不到&lt;code&gt;Rap&lt;/code&gt;方法？&lt;/p&gt;
&lt;p&gt;为了方便观察，我们把调用语句单独抽出来，然后查看未优化过的汇编码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;s := (*p).Rap()
  0x498ee1              488b842488000000        MOVQ 0x88(SP), AX
  0x498ee9              8400                    TESTB AL, 0(AX)
  0x498eeb              488b08                  MOVQ 0(AX), CX
  0x498eee              8401                    TESTB AL, 0(CX)
  0x498ef0              488b4008                MOVQ 0x8(AX), AX
  0x498ef4              488b4918                MOVQ 0x18(CX), CX
  0x498ef8              48890424                MOVQ AX, 0(SP)
  0x498efc              ffd1                    CALL CX
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抛开手工解引用的部分，后6行其实和直接使用interface进行动态查询是一样的。真正的问题其实出在自动解引用上：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-assembly&quot;&gt;p.sayHello()
    TESTB AL, 0(AX)
    MOVQ 0x40(SP), AX
    MOVQ 0x48(SP), CX
    MOVQ 0x50(SP), DX
    MOVQ AX, 0x28(SP)
    MOVQ CX, 0x30(SP)
    MOVQ DX, 0x38(SP)
    MOVQ AX, 0(SP)
    MOVQ CX, 0x8(SP)
    MOVQ DX, 0x10(SP)
    CALL main.Person.sayHello(SB)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不同之处就在于这个&lt;code&gt;CALL&lt;/code&gt;上，自动解引用时的&lt;code&gt;CALL&lt;/code&gt;其实是把指针指向的内容视作_普通类型_，因此会去静态查找方法进行调用，而指向的内容是interface的时候，编译器会去interface本身的数据结构上去查找有没有&lt;code&gt;Rap&lt;/code&gt;这个方法，答案显然是没有，所以爆了&lt;code&gt;p.Rap undefined&lt;/code&gt;错误。&lt;/p&gt;
&lt;p&gt;那么interface的真实长相是什么呢，我们看看go1.15.2的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;// src/runtime/runtime2.go
// 因为这边没使用空接口，所以只节选了含数据接口的实现
type iface struct {
        tab  *itab
        data unsafe.Pointer
}

// src/runtime/runtime2.go
type itab struct {
        inter *interfacetype
        _type *_type
        hash  uint32 // copy of _type.hash. Used for type switches.
        _     [4]byte
        fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.
}

// src/runtime/type.go
type imethod struct {
        name nameOff
        ityp typeOff
}

type interfacetype struct {
        typ     _type
        pkgpath name
        mhdr    []imethod // 类型所包含的全部方法
}

// src/runtime/type.go
type _type struct {
        size       uintptr
        ptrdata    uintptr // size of memory prefix holding all pointers
        hash       uint32
        tflag      tflag
        align      uint8
        fieldAlign uint8
        kind       uint8
        // function for comparing objects of this type
        // (ptr to object A, ptr to object B) -&amp;gt; ==?
        equal func(unsafe.Pointer, unsafe.Pointer) bool
        // gcdata stores the GC type data for the garbage collector.
        // If the KindGCProg bit is set in kind, gcdata is a GC program.
        // Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
        gcdata    *byte
        str       nameOff
        ptrToThis typeOff
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没有给出定义的类型都是对各种整数类型的typing alias。&lt;code&gt;interface&lt;/code&gt;实际上就是存储类型信息和实际数据的&lt;code&gt;struct&lt;/code&gt;，自动解引用后编译器是直接查看内存内容的（见汇编），这时看到的其实是&lt;code&gt;iface&lt;/code&gt;这个普通类型，所以静态查找一个不存在的方法就失败了。而为什么手动解引用的代码可以运行？因为我们手动解引用后编译器可以推导出实际类型是interface，这时候编译器就很自然地用处理interface的方法去处理它而不是直接把内存里的东西寻址后塞进寄存器。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;其实也没什么好总结的。只有两点需要记住，一是interface是有自己对应的实体数据结构的，二是尽量不要用指针去指向interface，因为golang对指针自动解引用的处理会带来陷阱。&lt;/p&gt;
&lt;p&gt;如果你对interface的实现很感兴趣的话，这里有个reflect+暴力穷举实现的&lt;a href=&quot;https://www.tapirgames.com/blog/golang-interface-implementation&quot;&gt;乞丐版&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;理解了乞丐版的基础上如果有兴趣还可以看看真正的golang实现，数据的层次结构上更细化，而且有使用指针和内存偏移等的聪明办法，不说是否会有收获，起码研究起来不会无聊：P。&lt;/p&gt;
</description>
<pubDate>Sat, 10 Oct 2020 17:15:00 +0000</pubDate>
<dc:creator>apocelipes</dc:creator>
<og:description>这是本系列的第一篇文章，golang拾遗主要是用来记录一些遗忘了的、平时从没注意过的golang相关知识。想做本系列的契机其实是因为疫情闲着在家无聊，网上冲浪的时候发现了zhuihu上的go语言爱好者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/apocelipes/p/13796041.html</dc:identifier>
</item>
<item>
<title>spring-boot-route（十一）数据库配置信息加密 - Java旅途</title>
<link>http://www.cnblogs.com/zhixie/p/13796002.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhixie/p/13796002.html</guid>
<description>&lt;p&gt;Spring Boot最大的特点就是自动配置了，大大的减少了传统Spring框架的繁琐配置，通过几行简单的配置就可以完成其他组件的接入。比如你想要连接mysql数据库，只需要的配置文件里面加入mysql的一些配置信息就可以了。为了保护数据的安全性，越来越多的公司选择加密这些重要信息。接下来一起来看看如何实现配置加密文件并且成功连接数据库的。&lt;/p&gt;
&lt;p&gt;配置信息加密有好几种方式，这里我只详细的写一下我比较常用的一种方式。首先通过某种加密算法将用户名和密码进行加密，然后在配置文件中用加密串代替原来的明文。然后自定义数据源，在自定义数据源中解密用户名和密码。&lt;/p&gt;
&lt;h2 id=&quot;springboot自动装配&quot;&gt;SpringBoot自动装配&lt;/h2&gt;
&lt;p&gt;SpringBoot的自动装配，以前的推文中也详细的讲到过，今天简单来复习一下。在每个Spring Boot的应用的启动类上都能发现有一个注解&lt;code&gt;@SpringBootApplication&lt;/code&gt;，这个注解包含的注解&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;就是用来完成自动装配的。这个注解通过导入类&lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt;，这个类中有一个方法&lt;code&gt;selectImports&lt;/code&gt;，其作用就是扫描所有jar包中的&lt;code&gt;META-INF/spring.factories&lt;/code&gt;文件，去加载里面的具体实现类，完成自动装配。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;spring-boot-autoconfigure&lt;/code&gt;jar包的&lt;code&gt;META-INF/spring.factories&lt;/code&gt;文件中指定了一个类用来加载数据库配置信息，这个类就是&lt;code&gt;org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;自定义数据源&quot;&gt;自定义数据源&lt;/h2&gt;
&lt;p&gt;这里使用&lt;code&gt;HikariDataSource&lt;/code&gt;作为自定义的数据源，自定义的数据源目的就是为了解密配置文件中的配置信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class DataSourceConfiguration {

    @Autowired
    DataSourceProperties properties;

    @Bean
    public DataSource dataSource() throws Exception{
        String username = Des3.decryptThreeDESECB(properties.getUsername(),Des3.DES3KEY);
        String password = Des3.decryptThreeDESECB(properties.getPassword(),Des3.DES3KEY);
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setDriverClassName(properties.getDriverClassName());
        dataSource.setJdbcUrl(properties.getUrl());
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        return dataSource;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置文件信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/xxx
    username: aMkeRCLWqNw=
    password: rq-fzucH32I=
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的加解密算法这里就不在提及了，根据具体要求选择一种可逆的加密算法就可以了，如果还不是很了解加密算法的种类，可以参考我以前写的一篇文章——&lt;a href=&quot;https://mp.weixin.qq.com/s/x_y6w-F1lCN102E8KQmuvQ&quot;&gt;面试官：说一下你常用的加密算法&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;此是spring-boot-route系列的第十一篇文章，这个系列的文章都比较简单，主要目的就是为了帮助初次接触Spring Boot 的同学有一个系统的认识。本文已收录至我的&lt;a href=&quot;https://github.com/binzh303/spring-boot-route&quot;&gt;github&lt;/a&gt;，欢迎各位小伙伴&lt;code&gt;star&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;github&lt;/strong&gt;：&lt;a href=&quot;https://github.com/binzh303/spring-boot-route&quot;&gt;https://github.com/binzh303/spring-boot-route&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;点关注、不迷路&quot;&gt;点关注、不迷路&lt;/h2&gt;
&lt;p&gt;如果觉得文章不错，欢迎&lt;strong&gt;关注&lt;/strong&gt;、&lt;strong&gt;点赞&lt;/strong&gt;、&lt;strong&gt;收藏&lt;/strong&gt;，你们的支持是我创作的动力，感谢大家。&lt;/p&gt;
&lt;p&gt;如果文章写的有问题，请不要吝啬，欢迎留言指出，我会及时核查修改。&lt;/p&gt;
&lt;p&gt;如果你还想更加深入的了解我，可以微信搜索「&lt;strong&gt;Java旅途&lt;/strong&gt;」进行关注。回复「&lt;strong&gt;1024&lt;/strong&gt;」即可获得学习视频及精美电子书。每天7:30准时推送技术文章，让你的上班路不在孤独，而且每月还有送书活动，助你提升硬实力！&lt;/p&gt;
</description>
<pubDate>Sat, 10 Oct 2020 16:31:00 +0000</pubDate>
<dc:creator>Java旅途</dc:creator>
<og:description>Spring Boot最大的特点就是自动配置了，大大的减少了传统Spring框架的繁琐配置，通过几行简单的配置就可以完成其他组件的接入。比如你想要连接mysql数据库，只需要的配置文件里面加入mysq</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhixie/p/13796002.html</dc:identifier>
</item>
<item>
<title>二分只能用来查找元素吗？ - RioTian</title>
<link>http://www.cnblogs.com/RioTian/p/13795935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RioTian/p/13795935.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201010234644.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二分搜索简介&quot;&gt;二分搜索简介&lt;/h3&gt;
&lt;p&gt;在计算机科学中，二分搜索（binary search）也称折半搜索（half-interval search）、对数搜索（logarithmic search），是在有序数组中查找某一特定元素的搜索算法。&lt;/p&gt;
&lt;p&gt;其基本思想是通过逐次比较数组特定范围的中间元素与目标元素的大小，每次缩小一半的搜索范围，来提高搜索效率。&lt;/p&gt;
&lt;p&gt;二分搜索的时间复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(log n)\)&lt;/span&gt;，空间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二分查找到底能运用在哪里？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最常见的就是教科书上的例子，也就是上文介绍的一般。在&lt;strong&gt;有序数组&lt;/strong&gt;中搜索给定的某个目标值的索引。再推广一点，如果目标值存在重复，修改版的二分查找可以返回目标值的左侧边界索引或者右侧边界索引。&lt;/p&gt;
&lt;blockquote readability=&quot;4.9859154929577&quot;&gt;
&lt;p&gt;PS：以上提到的三种二分查找算法形式在东哥的 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;amp;mid=2247484507&amp;amp;idx=1&amp;amp;sn=36b8808fb8fac0e1906493347d3c96e6&amp;amp;chksm=9bd7fa53aca0734531ec9f37127c0f371344e1690918888dfb1cfdf043c40c0b43d1121e5851&amp;amp;scene=21#wechat_redirect&quot;&gt;二分查找算法详解&lt;/a&gt; 有代码详解，如果没看过强烈建议看看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抛开有序数组这个枯燥的数据结构，二分查找如何运用到实际的算法问题中呢？当搜索空间有序的时候，就可以通过二分搜索「剪枝」，大幅提升效率。&lt;/p&gt;
&lt;p&gt;说起来玄乎得很，本文用「Koko 吃香蕉」和「货物运输」的问题来举个例子。&lt;/p&gt;
&lt;h3 id=&quot;一、koko-吃香蕉&quot;&gt;一、Koko 吃香蕉&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201010234136.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说，Koko 每小时最多吃一堆香蕉，如果吃不下的话留到下一小时再吃；如果吃完了这一堆还有胃口，也只会等到下一小时才会吃下一堆。在这个条件下，让我们确定 Koko 吃香蕉的&lt;strong&gt;最小速度&lt;/strong&gt;（根/小时）。&lt;/p&gt;
&lt;p&gt;如果直接给你这个情景，你能想到哪里能用到二分查找算法吗？如果没有见过类似的问题，恐怕是很难把这个问题和二分查找联系起来的。&lt;/p&gt;
&lt;p&gt;那么我们先抛开二分查找技巧，&lt;strong&gt;想想如何暴力解决这个问题呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，算法要求的是「&lt;code&gt;H&lt;/code&gt;小时内吃完香蕉的最小速度」，我们不妨称为&lt;code&gt;speed&lt;/code&gt;，&lt;strong&gt;请问&lt;code&gt;speed&lt;/code&gt;最大可能为多少，最少可能为多少呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显然最少为 1，最大为&lt;code&gt;max(piles)&lt;/code&gt;，因为一小时最多只能吃一堆香蕉。那么暴力解法就很简单了，只要从 1 开始穷举到&lt;code&gt;max(piles)&lt;/code&gt;，一旦发现发现某个值可以在&lt;code&gt;H&lt;/code&gt;小时内吃完所有香蕉，这个值就是最小速度：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int minEatingSpeed(int[] piles, int H) {
    // piles 数组的最大值
    int max = getMax(piles);
    for (int speed = 1; speed &amp;lt; max; speed++) {
        // 以 speed 是否能在 H 小时内吃完香蕉
        if (canFinish(piles, speed, H))
            return speed;
    }
    return max;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这个 for 循环，就是在&lt;strong&gt;连续的空间线性搜索，这就是二分查找可以发挥作用的标志****。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于我们要求的是最小速度，所以可以用一个&lt;strong&gt;搜索左侧边界的二分查找&lt;/strong&gt;来代替线性搜索，提升效率：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int minEatingSpeed(int[] piles, int H) {
    // 套用搜索左侧边界的算法框架
    int left = 1, right = getMax(piles) + 1;
    while (left &amp;lt; right) {
        // 防止溢出
        int mid = left + (right - left) / 2;
        if (canFinish(piles, mid, H)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;剩下的辅助函数也很简单，可以一步步拆解实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 时间复杂度 O(N)boolean canFinish(int[] piles, int speed, int H) {
    int time = 0;
    for (int n : piles) {
        time += timeOf(n, speed);
    }
    return time &amp;lt;= H;
}

int timeOf(int n, int speed) {
    return (n / speed) + ((n % speed &amp;gt; 0) ? 1 : 0);
}

int getMax(int[] piles) {
    int max = 0;
    for (int n : piles)
        max = Math.max(n, max);
    return max;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，借助二分查找技巧，算法的时间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(O(NlogN)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;二、包裹运输问题&quot;&gt;二、包裹运输问题&lt;/h3&gt;
&lt;p&gt;类似的，再看一道运输问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com//riotian/blogimage/raw/master/img/20201010234239.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要在&lt;code&gt;D&lt;/code&gt;天内运输完所有货物，货物不可分割，如何确定运输的最小载重呢（下文称为&lt;code&gt;cap&lt;/code&gt;）？&lt;/p&gt;
&lt;p&gt;其实本质上和 Koko 吃香蕉的问题一样的，首先确定&lt;code&gt;cap&lt;/code&gt;的最小值和最大值分别为&lt;code&gt;max(weights)&lt;/code&gt;和&lt;code&gt;sum(weights)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;类似刚才的问题，我们要求&lt;strong&gt;最小载重&lt;/strong&gt;，可以用 for 循环从小到大遍历，那么就可以用&lt;strong&gt;搜索左侧边界的二分查&lt;/strong&gt;找算法优化线性搜索：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 寻找左侧边界的二分查找int shipWithinDays(int[] weights, int D) {
    // 载重可能的最小值
    int left = getMax(weights);
    // 载重可能的最大值 + 1
    int right = getSum(weights) + 1;
    while (left &amp;lt; right) {
        int mid = left + (right - left) / 2;
        if (canFinish(weights, D, mid)) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}

// 如果载重为 cap，是否能在 D 天内运完货物？boolean canFinish(int[] w, int D, int cap) {
    int i = 0;
    for (int day = 0; day &amp;lt; D; day++) {
        int maxCap = cap;
        while ((maxCap -= w[i]) &amp;gt;= 0) {
            i++;
            if (i == w.length)
                return true;
        }
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这两个例子，你是否明白了二分查找在实际问题中的应用呢？&lt;/p&gt;
&lt;p&gt;首先思考使用 for 循环暴力解决问题，观察代码是否如下形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;for (int i = 0; i &amp;lt; n; i++)
    if (isOK(i))
        return answer;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是，那么就可以使用二分搜索优化搜索空间：如果要求最小值就是搜索左侧边界的二分，如果要求最大值就用搜索右侧边界的二分。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;很多人觉得二分搜索很简单，实际上二分搜索也可以出比较难的题。甚至有些题目，你不一定能想到用二分法来解决。&lt;/p&gt;
&lt;p&gt;同时在不同的数据结构和不同的应用场景中，都可以使用二分搜索的思想。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/tag/binary-search/&quot;&gt;这里&lt;/a&gt; 是 leetcode 中和二分搜索有关的习题。&lt;br/&gt;leetcode 上还有个二分查找的 &lt;a href=&quot;https://leetcode-cn.com/explore/learn/card/binary-search&quot;&gt;专题练习卡片&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;最简单的二分搜索&quot;&gt;最简单的二分搜索&lt;/h3&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/circle/article/OPV954/&quot;&gt;https://leetcode-cn.com/circle/article/OPV954/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 10 Oct 2020 15:50:00 +0000</pubDate>
<dc:creator>RioTian</dc:creator>
<og:description>二分搜索简介 在计算机科学中，二分搜索（binary search）也称折半搜索（half-interval search）、对数搜索（logarithmic search），是在有序数组中查找某一特</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RioTian/p/13795935.html</dc:identifier>
</item>
<item>
<title>使用树莓派制作智能小车 - DiyAbc-Eleven</title>
<link>http://www.cnblogs.com/DiyAbc/p/13795792.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DiyAbc/p/13795792.html</guid>
<description>&lt;p&gt;电影里，时不时地可以看到一些这样的场景，一辆小车，上面装有摄像头，这辆小车可以通过电脑或都是手机进行远程遥控，车上摄像头拍到的画面，可以实时地显示在电脑或手机上，就像下图这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2115834/202010/2115834-20201010225109313-1677111488.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没有接触过这方面的朋友或许会觉得这是一门很高大上的技术活，其实，并不然，这种小车做起来其实很简单。那么，这样子的小车，需要怎么去做呢？&lt;/p&gt;
&lt;p&gt;其实，我们只需要准备一块控制小车的电路板（开发板），2到4个电机（马达）、小车架子一个、摄像头以及摄像头云台一个，以上这些基础配件，然后对开发板进行编程、控制就可以了，整 体硬件成本加起来不到500块钱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发板：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发板有很多种，比如51单片机、树莓派、STM32、Arduino、micro:bit等等，都可以做为小车的控制板，我使用的是树莓派开发板，然后，可持树莓派有很多版本、型号，最便宜的树莓派zero 68元就可以买到，不过不建议买这种，没有网卡，需要另外买网线模块，我使用的是树莓派3B，价格220元，带有无线和有线网卡，还带有蓝牙。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2115834/202010/2115834-20201010225251516-538873627.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小车架子：&lt;/strong&gt;某宝上有很多这种车架子，各式各样的，只需要在某宝上搜索“智能小车”就能找到，带上马达一整套，也就五六十块钱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2115834/202010/2115834-20201010225259838-862430688.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摄像头+云台：&lt;/strong&gt;某宝上也是一搜一大堆，比如我下面用的那个，45块钱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2115834/202010/2115834-20201010225310681-1468725279.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配件准备好了，就是给小车的开发板装系统，然后对小车进行编程控制。&lt;/p&gt;
&lt;p&gt;小车的控制最主要有两方面的控制，一个是小车的前后左右的运动控制，一个是摄像头的拍摄、上下左右转运的控制。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;-*- coding:UTF-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; RPi.GPIO as GPIO
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;小车电机引脚定义&lt;/span&gt;
LeftIn1 = 20&lt;span&gt;
LeftIn2 &lt;/span&gt;= 21&lt;span&gt;
LeftSpeed &lt;/span&gt;= 16&lt;span&gt;


RightIn1 &lt;/span&gt;= 19&lt;span&gt;
RightIn2 &lt;/span&gt;= 26&lt;span&gt;
RightSpeed &lt;/span&gt;= 13

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置GPIO口为BCM编码方式&lt;/span&gt;
&lt;span&gt;GPIO.setmode(GPIO.BCM)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;忽略警告信息&lt;/span&gt;
&lt;span&gt;GPIO.setwarnings(False)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;电机引脚初始化操作&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; car_init():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; pwm_LeftSpeed
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; pwm_RightSpeed
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; delaytime
    GPIO.setup(LeftSpeed,GPIO.OUT,initial&lt;/span&gt;=&lt;span&gt;GPIO.LOW)
    GPIO.setup(LeftIn1,GPIO.OUT,initial&lt;/span&gt;=&lt;span&gt;GPIO.LOW)
    GPIO.setup(LeftIn2,GPIO.OUT,initial&lt;/span&gt;=&lt;span&gt;GPIO.LOW)

    GPIO.setup(RightSpeed,GPIO.OUT,initial&lt;/span&gt;=&lt;span&gt;GPIO.LOW)
    GPIO.setup(RightIn1,GPIO.OUT,initial&lt;/span&gt;=&lt;span&gt;GPIO.LOW)
    GPIO.setup(RightIn2,GPIO.OUT,initial&lt;/span&gt;=&lt;span&gt;GPIO.LOW)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置pwm引脚和频率为2000hz&lt;/span&gt;
    pwm_LeftSpeed = GPIO.PWM(LeftSpeed, 2000&lt;span&gt;)
    pwm_RightSpeed &lt;/span&gt;= GPIO.PWM(RightSpeed, 2000&lt;span&gt;)
    pwm_LeftSpeed.start(0)
    pwm_RightSpeed.start(0)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;小车前进   &lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(delaytime):
    GPIO.output(LeftIn1, GPIO.HIGH)
    GPIO.output(LeftIn2, GPIO.LOW)

    GPIO.output(RightIn1, GPIO.HIGH)
    GPIO.output(RightIn2, GPIO.LOW)

    pwm_LeftSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    pwm_RightSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    time.sleep(delaytime)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;小车后退&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; back(delaytime):
    GPIO.output(LeftIn1, GPIO.LOW)
    GPIO.output(LeftIn2, GPIO.HIGH)
    GPIO.output(RightIn1, GPIO.LOW)
    GPIO.output(RightIn2, GPIO.HIGH)
    pwm_LeftSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    pwm_RightSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    time.sleep(delaytime)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;小车左转   &lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; left(delaytime):
    GPIO.output(LeftIn1, GPIO.LOW)
    GPIO.output(LeftIn2, GPIO.LOW)
    GPIO.output(RightIn1, GPIO.HIGH)
    GPIO.output(RightIn2, GPIO.LOW)
    pwm_LeftSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    pwm_RightSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    time.sleep(delaytime)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;小车右转&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; right(delaytime):
    GPIO.output(LeftIn1, GPIO.HIGH)
    GPIO.output(LeftIn2, GPIO.LOW)
    GPIO.output(RightIn1, GPIO.LOW)
    GPIO.output(RightIn2, GPIO.LOW)
    pwm_LeftSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    pwm_RightSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    time.sleep(delaytime)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;小车原地左转&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; spin_left(delaytime):
    GPIO.output(LeftIn1, GPIO.LOW)
    GPIO.output(LeftIn2, GPIO.HIGH)
    GPIO.output(RightIn1, GPIO.HIGH)
    GPIO.output(RightIn2, GPIO.LOW)
    pwm_LeftSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    pwm_RightSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    time.sleep(delaytime)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;小车原地右转&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; spin_right(delaytime):
    GPIO.output(LeftIn1, GPIO.HIGH)
    GPIO.output(LeftIn2, GPIO.LOW)
    GPIO.output(RightIn1, GPIO.LOW)
    GPIO.output(RightIn2, GPIO.HIGH)
    pwm_LeftSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    pwm_RightSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    time.sleep(delaytime)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;小车停止   &lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; brake(delaytime):
    GPIO.output(LeftIn1, GPIO.LOW)
    GPIO.output(LeftIn2, GPIO.LOW)
    GPIO.output(RightIn1, GPIO.LOW)
    GPIO.output(RightIn2, GPIO.LOW)
    pwm_LeftSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    pwm_RightSpeed.ChangeDutyCycle(&lt;/span&gt;80&lt;span&gt;)
    time.sleep(delaytime)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;摄像头控制有两部分，一是拍摄、二是云台转动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摄像头的拍摄：&lt;/strong&gt;拍摄部分，我使用的是mjpg-streamer，这个工具可以把小车上的摄像头当作远程摄像头（Web Camera）使用，安装的方式也很简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;安装必要的库&lt;/span&gt;
sudo apt-&lt;span&gt;get update
sudo apt&lt;/span&gt;-get install libjpeg8-&lt;span&gt;dev
sudo apt&lt;/span&gt;-&lt;span&gt;get install imagemagick
sudo apt&lt;/span&gt;-get install libv4l-&lt;span&gt;dev
sudo apt&lt;/span&gt;-&lt;span&gt;get autoremove cmake
sudo apt&lt;/span&gt;-get install cmake
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;必要库安装好后，下载mjpg-streamer到树莓派上，并执行编译即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd mjpg-streamer/mjpg-streamer-&lt;span&gt;experimental
make all
sudo make install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过以上操作，就可以启动摄像头了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;运行mjpg-streamer&lt;/span&gt;
&lt;span&gt;
.&lt;/span&gt;/mjpg_streamer -i &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./input_uvc.so&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -o &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./output_http.so -w ./www&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;摄像头启动后，可以在局域网内的任何一台电脑上使用浏览器输入：&lt;a href=&quot;http://xn--ip-t68di3qyq6a:8080/?action=stream&quot; rel=&quot;nofollow&quot;&gt;http://树莓派IP:8080/?action=stream&lt;/a&gt; 即可看到摄像头拍到的画面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;云台控制：&lt;/strong&gt;云台的主是对控制上下和左右的两舵机进行编码控制：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; RPi.GPIO as GPIO
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pygame


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;舵机引脚定义&lt;/span&gt;
ServoUpDownPin = 9&lt;span&gt;
ServoLeftRightPin &lt;/span&gt;= 11

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置GPIO口为BCM编码方式&lt;/span&gt;
&lt;span&gt;GPIO.setmode(GPIO.BCM)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;忽略警告信息&lt;/span&gt;
&lt;span&gt;GPIO.setwarnings(False)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化上下左右角度为90度&lt;/span&gt;
ServoLeftRightPos = 90&lt;span&gt;
ServoUpDownPos &lt;/span&gt;= 90

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; init():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; pwm_UpDownServo
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; pwm_LeftRightServo
    
    GPIO.setup(ServoUpDownPin, GPIO.OUT)
    GPIO.setup(ServoLeftRightPin, GPIO.OUT)
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置舵机的频率和起始占空比&lt;/span&gt;
    pwm_UpDownServo = GPIO.PWM(ServoUpDownPin, 50&lt;span&gt;)
    pwm_LeftRightServo &lt;/span&gt;= GPIO.PWM(ServoLeftRightPin, 50&lt;span&gt;)
    
    pwm_UpDownServo.start(0)
    pwm_LeftRightServo.start(0)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;摄像头舵机左右旋转到指定角度&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; leftrightservo_appointed_detection(pos): 
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1&lt;span&gt;):   
        pwm_LeftRightServo.ChangeDutyCycle(&lt;/span&gt;2.5 + 10 * pos/180&lt;span&gt;)
        time.sleep(&lt;/span&gt;0.02)                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;等待20ms周期结束&lt;/span&gt;
        pwm_LeftRightServo.ChangeDutyCycle(0)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;归零信号&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;摄像头舵机上下旋转到指定角度&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; updownservo_appointed_detection(pos):  
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1&lt;span&gt;):  
        pwm_UpDownServo.ChangeDutyCycle(&lt;/span&gt;2.5 + 10 * pos/180&lt;span&gt;)
        time.sleep(&lt;/span&gt;0.02)                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;等待20ms周期结束&lt;/span&gt;
        pwm_UpDownServo.ChangeDutyCycle(0) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;归零信号&lt;/span&gt;
        
        

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;摄像头舵机向上运动&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; servo_up():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; ServoUpDownPos
    pos &lt;/span&gt;=&lt;span&gt; ServoUpDownPos
    updownservo_appointed_detection(pos)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;time.sleep(0.05)&lt;/span&gt;
    pos +=0.7&lt;span&gt; 
    ServoUpDownPos &lt;/span&gt;=&lt;span&gt; pos
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ServoUpDownPos &amp;gt;= 180&lt;span&gt;:
        ServoUpDownPos &lt;/span&gt;= 180

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;摄像头舵机向下运动      &lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; servo_down():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; ServoUpDownPos
    pos &lt;/span&gt;=&lt;span&gt; ServoUpDownPos
    updownservo_appointed_detection(pos)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;time.sleep(0.05)&lt;/span&gt;
    pos -= 0.7&lt;span&gt;
    ServoUpDownPos &lt;/span&gt;=&lt;span&gt; pos
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ServoUpDownPos &amp;lt;= 45&lt;span&gt;:
        ServoUpDownPos &lt;/span&gt;= 45
    

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;摄像头舵机向左运动&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; servo_left():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;servo_left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; ServoLeftRightPos
    pos &lt;/span&gt;=&lt;span&gt; ServoLeftRightPos
    leftrightservo_appointed_detection(pos)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;time.sleep(0.10)&lt;/span&gt;
    pos += 0.7&lt;span&gt;
    ServoLeftRightPos &lt;/span&gt;=&lt;span&gt; pos
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ServoLeftRightPos:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,ServoLeftRightPos)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ServoLeftRightPos &amp;gt;= 180&lt;span&gt;:
        ServoLeftRightPos &lt;/span&gt;= 180

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;摄像头舵机向右运动&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; servo_right():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; ServoLeftRightPos
    pos &lt;/span&gt;=&lt;span&gt; ServoLeftRightPos
    leftrightservo_appointed_detection(pos)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;time.sleep(0.10)&lt;/span&gt;
    pos -= 0.7&lt;span&gt; 
    ServoLeftRightPos &lt;/span&gt;=&lt;span&gt; pos
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ServoLeftRightPos &amp;lt;=&lt;span&gt; 0:
        ServoLeftRightPos &lt;/span&gt;=&lt;span&gt;  0
        
        
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;所有舵机归位&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; servo_init():
    servoflag &lt;/span&gt;=&lt;span&gt; 0
    servoinitpos &lt;/span&gt;= 90
    &lt;span&gt;if&lt;/span&gt; servoflag !=&lt;span&gt; servoinitpos:  
        updownservo_appointed_detection(servoinitpos)
        leftrightservo_appointed_detection(servoinitpos)
        time.sleep(&lt;/span&gt;0.5&lt;span&gt;)        
        pwm_LeftRightServo.ChangeDutyCycle(0)   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;归零信号&lt;/span&gt;
        pwm_UpDownServo.ChangeDutyCycle(0)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;归零信号&lt;/span&gt;
    
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;舵机停止&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; servo_stop():
    pwm_LeftRightServo.ChangeDutyCycle(0)   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;归零信号&lt;/span&gt;
    pwm_UpDownServo.ChangeDutyCycle(0)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;归零信号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对小车的控制编程完成后，最后我们使用WebSocket远程连接小车，发送相关的控制命令，就可以使用电脑或手机远程控制小车了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2115834/202010/2115834-20201010225109313-1677111488.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;完整的教学视频可查看：&lt;a href=&quot;http://www.diyabc.com/frontweb/product400.html&quot; rel=&quot;nofollow&quot;&gt;http://www.diyabc.com/frontweb/product400.html&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 10 Oct 2020 14:59:00 +0000</pubDate>
<dc:creator>DiyAbc-Eleven</dc:creator>
<og:description>电影里，时不时地可以看到一些这样的场景，一辆小车，上面装有摄像头，这辆小车可以通过电脑或都是手机进行远程遥控，车上摄像头拍到的画面，可以实时地显示在电脑或手机上，就像下图这样。 没有接触过这方面的朋友</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/DiyAbc/p/13795792.html</dc:identifier>
</item>
<item>
<title>静态分派与动态分派——记一次被腾讯面试官暴虐的面试经历 - wunsiang</title>
<link>http://www.cnblogs.com/wunsiang/p/13795782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wunsiang/p/13795782.html</guid>
<description>&lt;p&gt;在腾讯的面试中被问到了重载的运行时多态是怎么实现的，显然这一块是我的知识盲区，所以赶紧补充下。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;86.82426199262&quot;&gt;
&lt;p&gt;在腾讯的面试中被问到了重载的运行时多态是怎么实现的，显然这一块是我的知识盲区，所以赶紧补充下。&lt;/p&gt;
&lt;h2 id=&quot;静态分派&quot;&gt;静态分派&lt;/h2&gt;
&lt;p&gt;依赖静态类型来定位方法执行版本的分派动作称作静态分派，静态分派的典型是方法重载。如下代码实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StaticDispatch {
    static abstract class Human {
    }

    static class Man extends Human {
    }

    static class Woman extends Human {
    }

    public void sayHello (Human guy) {
        System.out.println(&quot;hello,guy&quot;);
    }

    public void sayHello (Man guy) {
        System.out.println(&quot;hello,gentleman&quot;);
    }

    public void sayHello (Woman guy) {
        System.out.println(&quot;hello,lady&quot;);
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sr = new StaticDispatch();
        sr.sayHello(man);//hello,guy!
        sr.sayHello(woman);//hello,guy!
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于这段代码的运行结果想必大家都很清楚，究其原因，重载的方法调用是由静态类型而非实际类型决定的，在编译器便决定了使用哪个重载版本，并会把这个方法的符号引用写到main()方法的两条invokevirtual指令的参数中。&lt;br/&gt;总结：Java重载是基于静态分派完成的。&lt;/p&gt;
&lt;h2 id=&quot;动态分派&quot;&gt;动态分派&lt;/h2&gt;
&lt;p&gt;我们知道Java多态性另一种实现方式是“重写”，而这种运行时多态编译器是不可能知道它的实际调用的实例的，如下代码所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Scanner in = new Scanner(System.in);
Person person = null;
if (in.nextLine().equals(&quot;chinese&quot;)) {
    person = new Chinese();
} else {
    person = new English();
}
person.sayHello();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在重载的场景下，JVM使用的是动态分派，即在运行时确定接受者的实际类型。JVM会在操作数栈中找到指向对象的实际类型，之后在该类的方法表（存在方法区中，存放着各个方法的实际入口）中找到对应描述符和和简单名称都相符的方法，同时进行访问权限校验，如通过则查找过程结束。如果没有找到匹配的方法，则通过继承关系在该类的父类的方法表中查找，查找到则结束，否则抛异常。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-lo-polymorph/&quot;&gt;多态在 Java 和 C++ 编程语言中的实现比较&lt;/a&gt;&lt;br/&gt;《深入理解Java虚拟机》&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 10 Oct 2020 14:56:00 +0000</pubDate>
<dc:creator>wunsiang</dc:creator>
<og:description>在腾讯的面试中被问到了重载的运行时多态是怎么实现的，显然这一块是我的知识盲区，所以赶紧补充下。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wunsiang/p/13795782.html</dc:identifier>
</item>
</channel>
</rss>