<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于Unity的AR开发初探：第一个AR应用程序 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/unity_ar_development_introduction_index_01.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/unity_ar_development_introduction_index_01.html</guid>
<description>&lt;p&gt;记得2014年曾经写过一个Unity3D的游戏开发初探系列，收获了很多好评和鼓励，不过自那之后再也没有用过Unity，因为没有相关的需求让我能用到。目前公司有一个App开发的需求，想要融合一下AR到App中以便为客户提供更好的体验，因此我开始了一些调研和学习，会依次总结一些文章出来与各位分享。此外，也希望能给更多的.NET&amp;amp;.NET Core开发者看到用C#语言开发AR应用的场景，有更多的人使用C#开发应用程序。&lt;/p&gt;

&lt;h2&gt;1.1 VR&lt;/h2&gt;
&lt;p&gt;　　所谓VR，就是Virtual Reality，虚拟现实，就是把虚拟世界的东西呈现到你的面前，让你以为是真实的。其实，游戏世界就是典型的虚拟现实。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127105756104-10994808.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;电影头号玩家 — 里面全是VR世界&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;1.2 AR&lt;/h2&gt;
&lt;p&gt;　　所谓AR，即Augmented Reality，增强现实，是指将虚拟世界的东西叠加到现实世界里。2018年任天堂公司推出了一款Pokemon Go的游戏，运用了AR技术，玩家可以通过手机屏幕在现实世界中发现精灵，然后进行捕捉或战斗。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127110207775-1513516339.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Pokemon Go — 一款AR手机游戏&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;1.3 MR　　&lt;/h2&gt;
&lt;p&gt;　　所谓MR，即Mixed Reality，混合现实，与AR相反，MR是指将真实世界的东西叠加到虚拟世界里。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;举个栗子, 对于修汽车，有些老师身怀绝技且经验丰富，但人数有限，而汽车故障可以发生在任何地方，无法保证每个修车店都有优秀的技师。如果有了MR工具，现场的技师就能把车况排成三维的虚拟图像传给你老师傅，老师傅则可以根据眼前看到的非常真实的现场情况给出修理建议，而且还能够在三维的虚拟实体上把每一步都指点出来，现场的技师只要照着做就可以保证修理质量了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127111351892-1598597039.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;MR混合现实—将真实世界叠加到虚拟世界&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;1.4 More AR?&lt;/h2&gt;
&lt;p&gt;　　目前VR已经很成熟，AR正在广泛地应用之中，而MR还在研究阶段，这里我主要关注AR。&lt;/p&gt;
&lt;p&gt;　　（1）AR的行业应用及发展趋势&lt;/p&gt;
&lt;p&gt;　　AR目前主要应用在幼教、游戏及大屏互动之中。AR游戏目前处于不断试水阶段，大屏互动已经广泛地应用在了博物馆、商场及广告屏等公共场所。&lt;/p&gt;
&lt;p&gt;　　（2）AR的主流应用玩法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Scan It — 根据识别图出发AR操作&lt;/li&gt;
&lt;li&gt;Place It — 由用户根据需要将虚拟物体拖动到真实环境的某个区域之中&lt;/li&gt;
&lt;li&gt;Find It — 将虚拟物体直接初始化在真实环境中的某个区域（就像它本来就真实存在一样）引导用户去寻找得到快感&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127113011887-43232793.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（3）如何制作AR？&lt;/p&gt;
&lt;p&gt;　　不同的项目和开发人员会有不同的选择，这里介绍一种常见的工具技术栈：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;引擎：Unity&lt;/li&gt;
&lt;li&gt;AR开发工具包：EasyAR（中国出品）、Vuforia（高通出品）、ARKit（苹果出品）、ARCore（谷歌出品）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note：&lt;/strong&gt;&lt;/em&gt;如果将Unity比作厨房，各种资源是料理用的食材，那么制作AR的SDK就是菜品的配方。　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;3D美术工具：AutoDesk MAYA&lt;/li&gt;
&lt;li&gt;平面美术工具：Photoshop&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.1 Unity与EasyAR版本&lt;/h2&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127105056498-1655422095.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里Unity选择版本为5.5.2，因为跟随了我参考的书籍《UnityAR增强现实完全自学教程》的版本，避免我在学习初期就碰到很多坑，降低学习的挫折感。&lt;/p&gt;
&lt;p&gt;　　这里AR SDK选择EasyAR，版本为1.3.1，因为也是跟随参考书籍，实际开发中还可以考虑苹果公司的ARKit以及高通公司的Vuforia。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127114605588-691670367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.2 安装Unity&lt;/h2&gt;
&lt;p&gt;　　由于我们下载的是历史旧版本，因此到&lt;a href=&quot;https://unity3d.com/cn/get-unity/download/archive&quot; target=&quot;_blank&quot;&gt;archive&lt;/a&gt;中找到5.5.2，并下载它：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127114354696-1966247964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　打开Unity5.5.2f1.exe开始安装：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127114958207-1493157483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在选择Unity组件时，勾选“Android Build Support”，如果是Mac主机，还可以勾选“iOS Build Support”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127115121121-431874017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后就是一路的Next了，再然后就耐心等待一会吧，安装需要一定的时间。最后你可以注册并登陆Unity账号，我们可以选择免费个人版用于学习。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127120918813-411117155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后就可以创建一个项目了，要注意的是项目名称及文件存放路径不要出现中文字符（包括中文输入状态下的文字及符号）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127121849541-1861157678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后就进入了Unity的Editor主界面了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127122143462-1931803025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　关于Editor的细节，这里就不再赘述了，有兴趣的可以阅读我的&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/3541191.html&quot; target=&quot;_blank&quot;&gt;这一篇&lt;/a&gt;，或者浏览参考书《&lt;a href=&quot;http://www.broadview.com.cn/book/4758&quot; target=&quot;_blank&quot;&gt;Unity AR增强现实完全自学教程&lt;/a&gt;》。&lt;/p&gt;
&lt;h2&gt;2.3 安装EasyAR&lt;/h2&gt;
&lt;p&gt;　　首先需要去&lt;a href=&quot;https://www.easyar.cn&quot; target=&quot;_blank&quot;&gt;EasyAR官网&lt;/a&gt;注册一个账户，然后在下载页面找到历史版本v1.3.1，注意是选择v1.3.1 Unity Samples（它不是单纯的EasyAR Unity SDK v1.3.1，而是官方的样例Samples）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127123203038-577350831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后将下载的文件解压，以备后续使用。&lt;/p&gt;

&lt;p&gt;　　接下来我们以EasyAR SDK Unity Samples中的一个案例HelloAR来作为第一个AR应用程序，看看如何实现。&lt;/p&gt;
&lt;h2&gt;3.1 EasyAR SDK基本配置&lt;/h2&gt;
&lt;p&gt;　　在Unity中打开刚刚解压后的EasyAR Unity Samples，选择HelloAR这个子项目进行打开：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127124555654-1637040435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后在弹出的对话框选择“Upgrade”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127124707403-161317869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在打开Unity之后，我们可以在项目资源面板（Project）中按文件夹层级 Hello AR - Scenes 找到HelloAR场景文件，双击进入场景，可以看到如下图所示的画面：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128220940610-1712156308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;*.图中展示了识别图和他们的增强效果模型&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　在场景资源（Hierarchy）面板中，可以看到加载入的“EasyAR_Startup”这个AR相机，选中它并转到检视（Inspector）面板，可以看到如下所示的画面，要求我们输入AR密钥才能激活这个AR相机。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128221553690-1661813901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这时需要我们回到EasyAR的官网，进入开发中心获取AR密钥。这里我们要做的就是添加一个SDK License，这里我选择的是免费版。此外，由于这里我用的是老版本1.x的SDK，因此需要复制SDK 1.0的key。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128222052668-230819067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将这段key粘贴近刚刚的AR密钥输入框中：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128222301666-1987983215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击运行按钮，（事前确保摄像头为开启状态），则可验证密钥是否有效：&lt;/p&gt;
&lt;p&gt;　　（1）识别图1：原谅我拍的不行，因为必须要与一个手机给摄像头展示识别图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128224533636-1520069331.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）识别图2：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128224717615-653482979.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至此，基于EasyAR的第一个示例Hello World就跑起来了，虽然我们还没有写一行代码，但至少有了一个初步的感性认识。&lt;/p&gt;
&lt;h2&gt;3.2 发布你的AR应用&lt;/h2&gt;
&lt;p&gt;　　接下来，仍然先不写代码，来体验下刚刚这个Demo应用发布的效果。&lt;/p&gt;
&lt;p&gt;　　（1）File - Build Settings ：打开发布设置面板，如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128225115607-1344493770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;添加要发布的场景（Scenes）、选择要发布的平台（比如iOS），然后就是Build！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　（2）首先来一个Windows平台的发布：&lt;/p&gt;
&lt;p&gt;　　进入PlayerSettings，输入一些产品相关的信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128225410663-459064768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　开启分辨率设置：Enabled&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128230103649-265485093.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;　　然后就可以点击Build，生成后的文件如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128230225607-1302850371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　双击exe，进入应用界面，由于启用了分辨率选择设置，会首先选择分辨率：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128230355607-268230358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后点击Play，开始AR之旅：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128231710662-573228181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128231725626-715483487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当然，还可以发布为Android平台的应用程序，如下图所示，不过今天就到此为止，下次有机会再介绍：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128232011611-2097059739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　本文简单地介绍了VR、AR以及MR三者的概念及其关系，然后通过Unity与EasyAR介绍了一个HelloAR的示例的基本配置与运行，最后介绍了一下基于Unity如何发布AR应用程序。虽然都很简单，而且没有涉及到一行C#代码，但是可以对AR有个初步的认知，后续有机会还会分享更多我的学习经历。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190128232518636-417328622.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;李晔，《&lt;a href=&quot;http://product.dangdang.com/25157639.html&quot; target=&quot;_blank&quot;&gt;Unity AR增强现实完全自学教程&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201901/381412-20190127111609928-452614545.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;王煜全，《&lt;a href=&quot;http://www.eusource.cn/index.php/Article/newInfo/article_id/17603.html&quot; target=&quot;_blank&quot;&gt;混合现实：把真实世界叠加进虚拟世界&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;百度AR平台，《&lt;a href=&quot;http://bit.baidu.com/course/detail/id/226.html&quot; target=&quot;_blank&quot;&gt;无处不在的AR应用&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;EasyAR，&lt;a href=&quot;https://www.easyar.cn&quot; target=&quot;_blank&quot;&gt;https://www.easyar.cn&lt;/a&gt;&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;&lt;span&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 28 Jan 2019 15:28:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<og:description>记得2014年曾经写过一个Unity3D的游戏开发初探系列，收获了很多好评和鼓励，不过自那之后再也没有用过Unity，因为没有相关的需求让我能用到。目前公司有一个App开发的需求，想要融合一下AR到A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/unity_ar_development_introduction_index_01.html</dc:identifier>
</item>
<item>
<title>在Airtest中如何使用无线模式控制手机 - 青南</title>
<link>http://www.cnblogs.com/xieqiankun/p/wireless-mode-of-poco.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieqiankun/p/wireless-mode-of-poco.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;https://www.kingname.info/2019/01/19/use-airtest/&quot;&gt;使用Airtest超快速开发App爬虫&lt;/a&gt;文章的最后，我们留了一个尾巴：如何启动Airtest的无线模式，不用USB线就能控制手机？&lt;/p&gt;
&lt;p&gt;本文将会讲到具体的做法。做法分为两种：第一种是在Airtest的IDE中控制手机。第二种是在Python代码里面控制远程手机。&lt;/p&gt;
&lt;h2 id=&quot;启动开启手机上的adb端口&quot;&gt;启动开启手机上的adb端口&lt;/h2&gt;
&lt;p&gt;无论使用哪种方式，要远程控制手机，就需要首先把手机上的adb端口打开。这一步必需先用USB线把手机连上电脑。&lt;/p&gt;
&lt;p&gt;在终端里面执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;adb tcpip 48887&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的端口号48887你可以自行设定为其他的端口号，但不能和已有的端口冲突。&lt;/p&gt;
&lt;p&gt;命令执行完成以后，你就可以拔下USB线了。接下来就是远程控制手机。&lt;/p&gt;
&lt;h2 id=&quot;在airtestide中无线遥控手机&quot;&gt;在AirtestIDE中无线遥控手机&lt;/h2&gt;
&lt;p&gt;打开Airtest，点击下图红框框住的 remote connection:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-28-21-56-01.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在弹出来的输入框中，输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;adb connect 手机IP:端口&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中手机的IP你可以在无线路由器中找到，也可以在手机的系统设置中找到。端口就是上一条命令设定的端口。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;adb connect 192.168.0.102:48887&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-01-28-21-57-21.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;connect&lt;/code&gt;，此时手机就会在上方的 Device列表中出现。双击它就可以无线连接手机并看到手机屏幕了。&lt;/p&gt;
&lt;h2 id=&quot;在python中控制手机&quot;&gt;在Python中控制手机&lt;/h2&gt;
&lt;p&gt;首先说明，Airtest的官方文档有问题，如果你跟着文档来写代码，一定会失败。&lt;/p&gt;
&lt;p&gt;官方文档中，在&lt;a href=&quot;https://airtest.readthedocs.io/zh_CN/latest/README_MORE.html#connect-android-device&quot; class=&quot;uri&quot;&gt;https://airtest.readthedocs.io/zh_CN/latest/README_MORE.html#connect-android-device&lt;/a&gt;有一段介绍如何连接远程安卓手机的例子：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;本地设备
# connect a remote device using custom params
connect_device(&quot;android://adbhost:adbport/1234566?cap_method=javacap&amp;amp;touch_method=adb&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个代码看起来，你可能会把Python代码写为：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from airtest.core.api import *
device_1 = connect_device('android://192.168.0.100:48887/手机串号?cap_method=javacap&amp;amp;touch_method=adb')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你这样写，&lt;strong&gt;你一定无法连上手机&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;正确的代码为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from airtest.core.api import *

device_1 = connect_device('android:///192.168.0.100:48887?cap_method=javacap&amp;amp;touch_method=adb')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有按我这里的写法才能正确控制手机。如下面的gif所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/correct_method_of_connect.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;动图中涉及到的完整代码为：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from airtest.core.api import *
import time
from poco.drivers.android.uiautomation import AndroidUiautomationPoco

device_1 = connect_device('android:///192.168.0.100:48887?cap_method=javacap&amp;amp;touch_method=adb')

poco = AndroidUiautomationPoco(device_1, use_airtest_input=True, screenshot_each_action=False)


poco(text=&quot;知乎&quot;).click()
poco(name=&quot;com.zhihu.android:id/input&quot;).click()
poco(name=&quot;com.zhihu.android:id/input&quot;).set_text('古剑奇谭三')

time.sleep(2)


poco(name='com.zhihu.android:id/magi_title', textMatches='^古剑奇谭三.*$').click()
poco.swipe([0.5, 0.8], [0.5, 0.2])
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 28 Jan 2019 14:49:00 +0000</pubDate>
<dc:creator>青南</dc:creator>
<og:description>在[使用Airtest超快速开发App爬虫](https://www.kingname.info/2019/01/19/use-airtest/)文章的最后，我们留了一个尾巴：如何启动Airtest的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieqiankun/p/wireless-mode-of-poco.html</dc:identifier>
</item>
<item>
<title>MongoDB中数组类型相关的操作 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/10331524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/10331524.html</guid>
<description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;在MongoDB的模式中，我们经常将一些数据存储到数组类型中，即我们常见的嵌套模式设计的一种实现方式。数组的这种设计实现方式在关系数据库中是没有或者说不常见的。所以，通过本文我们来梳理一下MongoDB的数组的相关操作。关于数组的操作可以分成两类，一类是数组操作符，另一个是数组运算修饰符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 数组操作符&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;操作符&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;实现功能&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;根据查询选择器定位要更新的文档&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;$push&lt;/td&gt;
&lt;td&gt;添加值到数组中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$pushAll&lt;/td&gt;
&lt;td&gt;添加数组到一个数组中。（将被$rach取代）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;$addToSet&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;添加值到数组中，重复了也不处理&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$pop&lt;/td&gt;
&lt;td&gt;从数组中删除第一个或者最后一个值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$pull&lt;/td&gt;
&lt;td&gt;从数组中删除匹配查询条件的值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$pullAll&lt;/td&gt;
&lt;td&gt;从数组中删除多个值。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;数组运算修饰符&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;修饰符&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;实现功能&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$each&lt;/td&gt;
&lt;td&gt;与$push和$addToSet一起使用来操作多个值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$slice&lt;/td&gt;
&lt;td&gt;与$push和$each一起使用来缩小更新后数组的大小。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$sort&lt;/td&gt;
&lt;td&gt;与$push、$each、$slice一起来排序数组中的子文档。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;1.$push操作符&lt;/h3&gt;
&lt;h4&gt;1.1 语法及功能描述&lt;/h4&gt;
&lt;p&gt;$push 主要用来向数组中添加元素。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{ $push: { &lt;span&gt;&amp;lt;&lt;/span&gt;field1&lt;span&gt;&amp;gt;&lt;/span&gt;: &lt;span&gt;&amp;lt;&lt;/span&gt;value1&lt;span&gt;&amp;gt;&lt;/span&gt;, ... } }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况下，它会在数组尾部添加一个单独的元素。&lt;/p&gt;
&lt;h4&gt;1.2 操作案例&lt;/h4&gt;
&lt;p&gt;假如我们有一个学生成绩的集合studentscore，其文档格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;name&quot; : &quot;xiaoming&quot;, &quot;score&quot; : &lt;span&gt;[&lt;/span&gt;&lt;span&gt; { &quot;math&quot; : 99, &quot;english&quot; : 89 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;name&quot; : &quot;xiaohong&quot;, &quot;score&quot; : &lt;span&gt;[&lt;/span&gt;&lt;span&gt; { &quot;math&quot; : 98, &quot;english&quot; : 96 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的需求为，更新_id 为1的文档记录，在分数数组的字段上，添加 物理学的成绩，修改代码为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
db.studentscore.&lt;span&gt;update&lt;/span&gt;({_id:&lt;span&gt;1&lt;/span&gt;},{$push: {score:{&quot;physics&quot;:&lt;span&gt;100&lt;/span&gt;}}})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改后，结果查询如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;name&quot; : &quot;xiaoming&quot;, &quot;score&quot; : &lt;span&gt;[&lt;/span&gt;&lt;span&gt; { &quot;math&quot; : 99, &quot;english&quot; : 89 }, { &quot;physics&quot; : 100 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;name&quot; : &quot;xiaohong&quot;, &quot;score&quot; : &lt;span&gt;[&lt;/span&gt;&lt;span&gt; { &quot;math&quot; : 98, &quot;english&quot; : 96 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt; 1.3 结合$each修饰符，批量插入&lt;/h4&gt;
&lt;p&gt;如果一次将多个值添加到数组中，可结合 数组修改符  &lt;code class=&quot;xref mongodb mongodb-update docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;$each 一起使用。&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;xref mongodb mongodb-update docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;例如，我们将小红的（_id =2）的物理成绩、化学成绩、生物成绩一起添加到文档中。执行的语句如下：&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
db.studentscore.&lt;span&gt;update&lt;/span&gt;({ _id: &lt;span&gt;2&lt;/span&gt;&lt;span&gt; },
    {
        $push: {
            score: {
                $each: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;{ &quot;physics&quot;: 100 }, { &quot;chemistry&quot;: 90 }, { &quot;biology&quot;: 99 }&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
            }

        }
    }
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询的结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;name&quot; : &quot;xiaoming&quot;, &quot;score&quot; : &lt;span&gt;[&lt;/span&gt;&lt;span&gt; { &quot;math&quot; : 99, &quot;english&quot; : 89 }, { &quot;physics&quot; : 100 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; }
{ &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, &quot;name&quot; : &quot;xiaohong&quot;, &quot;score&quot; : &lt;span&gt;[&lt;/span&gt;&lt;span&gt; { &quot;math&quot; : 98, &quot;english&quot; : 96 }, { &quot;physics&quot; : 100 }, { &quot;chemistry&quot; : 90 }, { &quot;biology&quot; : 99 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.4 数组修饰符 $sort 和 $slice的使用&lt;/h4&gt;
&lt;p&gt;前面讲了$each 数组运算修饰符，那我们再举一个例子，将剩余的两个修饰符一起讲解了好了（$sort 和 $slice）&lt;/p&gt;
&lt;p&gt;例如，我们有文档记录如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
   &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,
   &quot;quizzes&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
      { &quot;wk&quot;: 1, &quot;score&quot; : 10 },
      { &quot;wk&quot;: 2, &quot;score&quot; : 8 },
      { &quot;wk&quot;: 3, &quot;score&quot; : 5 },
      { &quot;wk&quot;: 4, &quot;score&quot; : 6 }
   &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们，有个需求，就是 首先向文档的quizzes数组字段，追加三个记录，然后，我们再按照score排序，选取数组中的前三个元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
db.students.&lt;span&gt;update&lt;/span&gt;&lt;span&gt;(
   { _id: &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; },
   {
     $push: {
       quizzes: {
          $each: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; { wk: 5, score: 8 }, { wk: 6, score: 7 }, { wk: 7, score: 6 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,
          $sort: { score: &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; },
          $slice: &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
       }
     }
   }
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新后的结果显示如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,
  &quot;quizzes&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
     { &quot;wk&quot; : 1, &quot;score&quot; : 10 },
     { &quot;wk&quot; : 2, &quot;score&quot; : 8 },
     { &quot;wk&quot; : 5, &quot;score&quot; : 8 }
  &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; $slice操作修饰符是在MongoDB 2.4 里添加的，其目的是方便管理经常更新的数组。当向数组添加值但是不想数组太大的时候，这个操作符非常有用。它必须与$push、$each操作符一起使用，允许用来剪短数组的大小、删除旧的值。&lt;/p&gt;
&lt;p&gt;与$slice操作修饰符很像，MongoDB 2.4 新增了$sort操作修饰符，帮助更新数组。当使用$push和$slice时，有时候要先排序再删除它们。&lt;/p&gt;
&lt;h3&gt;2. $pop 操作符&lt;/h3&gt;
&lt;h4&gt;2.1 语法及功能描述&lt;/h4&gt;
&lt;p&gt;$pop操作符可以实现从数组中删除第一个或者是最好一个元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{ $pop: { &lt;span&gt;&amp;lt;&lt;/span&gt;field&lt;span&gt;&amp;gt;&lt;/span&gt;: &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;, ... } }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数为-1 ，代表要删除数组中的第一个元素；参数为1 ，代表要删除数组中的最后一个元素。&lt;/p&gt;
&lt;h4&gt;2.2 操作案例&lt;/h4&gt;
&lt;p&gt;例如集合students 中有以下文档：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
{ _id: &lt;span&gt;1&lt;/span&gt;, scores: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; 8, 9, 10 &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们的需求是要把数组中的第一个元素（成绩为8）移除，SQL 语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
db.students.&lt;span&gt;update&lt;/span&gt;( { _id: &lt;span&gt;1&lt;/span&gt; }, { $pop: { scores: &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; } } )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新后，文档如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
{ _id: &lt;span&gt;1&lt;/span&gt;, scores: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; 9, 10 &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续演示，如果在现有的基础上，我们需要进一步把数组的最后一个元素移除（成绩为10），更新的sQL如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
db.students.&lt;span&gt;update&lt;/span&gt;( { _id: &lt;span&gt;1&lt;/span&gt; }, { $pop: { scores: &lt;span&gt;1&lt;/span&gt; } } )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询结果 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{ _id: &lt;span&gt;1&lt;/span&gt;, scores: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; 9 &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. &lt;code class=&quot;xref mongodb mongodb-update docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;$pull操作符&lt;/span&gt;&lt;/code&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span class=&quot;pre&quot;&gt;3.1 语法及功能描述&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;$pull是$pop的复杂形式。使用$pull,可以通过值精确指定要删除的元素。&lt;/p&gt;
&lt;p&gt;语法格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
{ $pull: { &lt;span&gt;&amp;lt;&lt;/span&gt;field1&lt;span&gt;&amp;gt;&lt;/span&gt;: &lt;span&gt;&amp;lt;&lt;/span&gt;value&lt;span&gt;|&lt;/span&gt;condition&lt;span&gt;&amp;gt;&lt;/span&gt;, &lt;span&gt;&amp;lt;&lt;/span&gt;field2&lt;span&gt;&amp;gt;&lt;/span&gt;: &lt;span&gt;&amp;lt;&lt;/span&gt;value&lt;span&gt;|&lt;/span&gt;condition&lt;span&gt;&amp;gt;&lt;/span&gt;, ... } }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt; 3.2 操作案例&lt;/h4&gt;
&lt;h5&gt;3.2.1 移除数组中等于&lt;em&gt;指定值&lt;/em&gt;的元素&lt;/h5&gt;
&lt;p&gt;测试文档如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
   _id: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
   fruits: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;apples&quot;, &quot;pears&quot;, &quot;oranges&quot;, &quot;grapes&quot;, &quot;bananas&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,
   vegetables: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;carrots&quot;, &quot;celery&quot;, &quot;squash&quot;, &quot;carrots&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}
{
   _id: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
   fruits: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;plums&quot;, &quot;kiwis&quot;, &quot;oranges&quot;, &quot;bananas&quot;, &quot;apples&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,
   vegetables: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;broccoli&quot;, &quot;zucchini&quot;, &quot;carrots&quot;, &quot;onions&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;操作要求是将 数组字段fruits中的&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;&quot;apples&quot;&lt;/span&gt;&lt;/code&gt; and &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;&quot;oranges&quot; 移除，还要将vegetables数组字段中的&quot;carrots&quot; 移除，其更新语句如下：&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
db.stores.&lt;span&gt;update&lt;/span&gt;&lt;span&gt;(
    { },
    { $pull: { fruits: { $&lt;/span&gt;&lt;span&gt;in&lt;/span&gt;: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;apples&quot;, &quot;oranges&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; }, vegetables: &quot;carrots&quot; } },
    { multi: true }
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新后的结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
  &quot;fruits&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;pears&quot;, &quot;grapes&quot;, &quot;bananas&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,
  &quot;vegetables&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;celery&quot;, &quot;squash&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}
{
  &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
  &quot;fruits&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;plums&quot;, &quot;kiwis&quot;, &quot;bananas&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,
  &quot;vegetables&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;broccoli&quot;, &quot;zucchini&quot;, &quot;onions&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 此时，集合文档中，fruit的数组字段 没有&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;apples也没有&lt;/span&gt;&lt;/code&gt;&lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;oranges，vegetables数组字段也没有了carrots。&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;h5&gt;3.2.2 移除数组中满足&lt;em&gt;指定条件&lt;/em&gt;的元素&lt;/h5&gt;
&lt;p&gt;假如我们有一个 profiles 的集合，其文档格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
{ _id: &lt;span&gt;1&lt;/span&gt;, votes: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; 3, 5, 6, 7, 7, 8 &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们要把votes大于等于6的元素移除，其语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
db.profiles.&lt;span&gt;update&lt;/span&gt;( { _id: &lt;span&gt;1&lt;/span&gt; }, { $pull: { votes: { $gte: &lt;span&gt;6&lt;/span&gt; } } } )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新后的结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
{ _id: &lt;span&gt;1&lt;/span&gt;, votes: &lt;span&gt;[&lt;/span&gt;&lt;span&gt;  3,  5 &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;3.2.3 移除数组中内嵌子文档（即此时数组元素是子文档，每一个{}中的内容是一个数组元素）&lt;/h5&gt;
&lt;p&gt;假设我们有一个关于 调查的集合 survey，其数据如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
   _id: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
   results: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
      { item: &quot;A&quot;, score: 5 },
      { item: &quot;B&quot;, score: 8, comment: &quot;Strongly agree&quot; }
   &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}
{
   _id: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
   results: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
      { item: &quot;C&quot;, score: 8, comment: &quot;Strongly agree&quot; },
      { item: &quot;B&quot;, score: 4 }
   &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需求是将 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;score 为&lt;/span&gt;&lt;/code&gt; &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;8&lt;/span&gt;&lt;/code&gt; 并且 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;item&lt;/span&gt;&lt;/code&gt; 为 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;&quot;B&quot;的元素移除&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
db.survey.&lt;span&gt;update&lt;/span&gt;&lt;span&gt;(
  { },
  { $pull: { results: { score: &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt; , item: &quot;B&quot; } } },
  { multi: true }
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新后的文档如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
   &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
   &quot;results&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; { &quot;item&quot; : &quot;A&quot;, &quot;score&quot; : 5 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}
{
  &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
  &quot;results&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
      { &quot;item&quot; : &quot;C&quot;, &quot;score&quot; : 8, &quot;comment&quot; : &quot;Strongly agree&quot; },
      { &quot;item&quot; : &quot;B&quot;, &quot;score&quot; : 4 }
   &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;3.2.4 如果数组类型的元素还内嵌一个数组（数组包数组），就要特别小心了。&lt;/h5&gt;
&lt;p&gt;此时就要用到 &lt;code class=&quot;xref mongodb mongodb-query docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;$elemMatch操作符。&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pre&quot;&gt;例如 文档格式如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
   _id: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
   results: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
      { item: &quot;A&quot;, score: 5, answers: [ { q: 1, a: 4 }, { q: 2, a: 6 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; },
      { item: &quot;B&quot;, score: &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;, answers: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; { q: 1, a: 8 }, { q: 2, a: 9 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; }
   ]
}
{
   _id: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
   results: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
      { item: &quot;C&quot;, score: 8, answers: [ { q: 1, a: 8 }, { q: 2, a: 7 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; },
      { item: &quot;B&quot;, score: &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;, answers: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; { q: 1, a: 0 }, { q: 2, a: 8 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; }
   ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要将 results数组字段 移除，移除的条件是 results数组字段中的&lt;span class=&quot;nx&quot;&gt;answers字段，符合  &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;q&lt;/span&gt;&lt;/code&gt; 为 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;2&lt;/span&gt;&lt;/code&gt; and &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;a&lt;/span&gt;&lt;/code&gt; 大于等于 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;8。&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
db.survey.&lt;span&gt;update&lt;/span&gt;&lt;span&gt;(
  { },
  { $pull: { results: { answers: { $elemMatch: { q: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;, a: { $gte: &lt;span&gt;8&lt;/span&gt;&lt;span&gt; } } } } } },
  { multi: true }
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新后的数据如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
   &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
   &quot;results&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
      { &quot;item&quot; : &quot;A&quot;, &quot;score&quot; : 5, &quot;answers&quot; : [ { &quot;q&quot; : 1, &quot;a&quot; : 4 }, { &quot;q&quot; : 2, &quot;a&quot; : 6 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; }
   ]
}
{
   &quot;_id&quot; : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
   &quot;results&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
      { &quot;item&quot; : &quot;C&quot;, &quot;score&quot; : 8, &quot;answers&quot; : [ { &quot;q&quot; : 1, &quot;a&quot; : 8 }, { &quot;q&quot; : 2, &quot;a&quot; : 7 } &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; }
   ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.$addToSet&lt;/h3&gt;
&lt;h4&gt;4.1 语法及功能描述&lt;/h4&gt;
&lt;p&gt;使用$addToSet也会往数组后面添加值，但是它比较特殊：它只会添加数组里不存在的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{ $addToSet: { &lt;span&gt;&amp;lt;&lt;/span&gt;field1&lt;span&gt;&amp;gt;&lt;/span&gt;: &lt;span&gt;&amp;lt;&lt;/span&gt;value1&lt;span&gt;&amp;gt;&lt;/span&gt;, ... } }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.2 操作案例&lt;/h4&gt;
&lt;p&gt;假如有一个集合 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;inventory&lt;/span&gt;&lt;/code&gt;  格式如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
{ _id: &lt;span&gt;1&lt;/span&gt;, item: &quot;polarizing_filter&quot;, tags: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;electronics&quot;, &quot;camera&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们希望向向字段 &lt;span class=&quot;nx&quot;&gt;tags 数组 ，添加一个元素&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;accessories，则&lt;/span&gt;更新语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
db.inventory.&lt;span&gt;update&lt;/span&gt;&lt;span&gt;(
   { _id: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; },
   { $addToSet: { tags: &quot;accessories&quot; } }
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新后的结果为 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
{ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;item&quot; : &quot;polarizing_filter&quot;, &quot;tags&quot; : &lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;electronics&quot;, &quot;camera&quot;, &quot;accessories&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想批量的增加如果元素，我们可以结合 &lt;code class=&quot;xref mongodb mongodb-update docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;$each 操作符一起使用。&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pre&quot;&gt;例如以下文档&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
{ _id: &lt;span&gt;2&lt;/span&gt;, item: &quot;cable&quot;, tags: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;electronics&quot;, &quot;supplies&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们想在字段 &lt;span class=&quot;nx&quot;&gt;tags 数组，添加元素 &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;camera&quot;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;electronics&quot;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;accessories&quot;，则更新语句如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
db.inventory.&lt;span&gt;update&lt;/span&gt;&lt;span&gt;(
   { _id: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; },
   { $addToSet: { tags: { $each: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;camera&quot;, &quot;electronics&quot;, &quot;accessories&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; } } }
 )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新后的结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  _id: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
  item: &quot;cable&quot;,
  tags: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;electronics&quot;, &quot;supplies&quot;, &quot;camera&quot;, &quot;accessories&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.3 注意点&lt;/h4&gt;
&lt;p&gt;需要注意是，如果添加的元素是数组格式，则会将新添加的元素保留为数组（将会出现数组嵌套数组）&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
{ _id: &lt;span&gt;1&lt;/span&gt;, letters: &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;a&quot;, &quot;b&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行的语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
db.test.&lt;span&gt;update&lt;/span&gt;&lt;span&gt;(
   { _id: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; },
   { $addToSet: {letters: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;c&quot;, &quot;d&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; } }
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询结构显示为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
{ _id: &lt;span&gt;1&lt;/span&gt;, letters: &lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;a&quot;, &quot;b&quot;, [ &quot;c&quot;, &quot;d&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; ] }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;本文部分例子来自官网及网络，在此感谢。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载&lt;/strong&gt;&lt;strong&gt;,&lt;/strong&gt;&lt;strong&gt;谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 28 Jan 2019 14:42:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>概述 在MongoDB的模式中，我们经常将一些数据存储到数组类型中，即我们常见的嵌套模式设计的一种实现方式。数组的这种设计实现方式在关系数据库中是没有或者说不常见的。所以，通过本文我们来梳理一下Mon</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/10331524.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Alibaba基础教程：支持的几种服务消费方式（RestTemplate、WebClient、Feign） - 程序猿DD</title>
<link>http://www.cnblogs.com/didispace/p/10332103.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/didispace/p/10332103.html</guid>
<description>&lt;p&gt;通过&lt;a href=&quot;http://blog.didispace.com/spring-cloud-alibaba-1/&quot;&gt;《Spring Cloud Alibaba基础教程：使用Nacos实现服务注册与发现》&lt;/a&gt;一文的学习，我们已经学会如何使用Nacos来实现服务的注册与发现，同时也介绍如何通过LoadBalancerClient接口来获取某个服务的具体实例，并根据实例信息来发起服务接口消费请求。但是这样的做法需要我们手工的去编写服务选取、链接拼接等繁琐的工作，对于开发人员来说非常的不友好。所以接下来，我们再来看看除此之外，还支持哪些其他的服务消费方式。&lt;/p&gt;
&lt;h2 id=&quot;使用resttemplate&quot;&gt;使用RestTemplate&lt;/h2&gt;
&lt;p&gt;在之前的例子中，已经使用过&lt;code&gt;RestTemplate&lt;/code&gt;来向服务的某个具体实例发起HTTP请求，但是具体的请求路径是通过拼接完成的，对于开发体验并不好。但是，实际上，在Spring Cloud中对RestTemplate做了增强，只需要稍加配置，就能简化之前的调用方式。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableDiscoveryClient
@SpringBootApplication
public class TestApplication {

    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }

    @Slf4j
    @RestController
    static class TestController {

        @Autowired
        RestTemplate restTemplate;

        @GetMapping(&quot;/test&quot;)
        public String test() {
            String result = restTemplate.getForObject(&quot;http://alibaba-nacos-discovery-server/hello?name=didi&quot;, String.class);
            return &quot;Return : &quot; + result;
        }
    }

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在定义RestTemplate的时候，增加了&lt;code&gt;@LoadBalanced&lt;/code&gt;注解，而在真正调用服务接口的时候，原来host部分是通过手工拼接ip和端口的，直接采用服务名的时候来写请求路径即可。在真正调用的时候，Spring Cloud会将请求拦截下来，然后通过负载均衡器选出节点，并替换服务名部分为具体的ip和端口，从而实现基于服务名的负载均衡调用。&lt;/p&gt;
&lt;p&gt;关于这种方式，可在文末仓库查看完整代码示例。而对于这种方式的实现原理，可以参考我之前写的这篇文章的前半部分：&lt;a href=&quot;http://blog.didispace.com/springcloud-sourcecode-ribbon/&quot;&gt;Spring Cloud源码分析（二）Ribbon&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用webclient&quot;&gt;使用WebClient&lt;/h2&gt;
&lt;p&gt;WebClient是Spring 5中最新引入的，可以将其理解为reactive版的RestTemplate。下面举个具体的例子，它将实现与上面RestTemplate一样的请求调用：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableDiscoveryClient
@SpringBootApplication
public class TestApplication {

    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }

    @Slf4j
    @RestController
    static class TestController {

        @Autowired
        private WebClient.Builder webClientBuilder;

        @GetMapping(&quot;/test&quot;)
        public Mono&amp;lt;String&amp;gt; test() {
            Mono&amp;lt;String&amp;gt; result = webClientBuilder.build()
                    .get()
                    .uri(&quot;http://alibaba-nacos-discovery-server/hello?name=didi&quot;)
                    .retrieve()
                    .bodyToMono(String.class);
            return result;
        }
    }

    @Bean
    @LoadBalanced
    public WebClient.Builder loadBalancedWebClientBuilder() {
        return WebClient.builder();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在定义WebClient.Builder的时候，也增加了&lt;code&gt;@LoadBalanced&lt;/code&gt;注解，其原理与之前的RestTemplate时一样的。关于WebClient的完整例子也可以通过在文末的仓库中查看。&lt;/p&gt;
&lt;h2 id=&quot;使用feign&quot;&gt;使用Feign&lt;/h2&gt;
&lt;p&gt;上面介绍的RestTemplate和WebClient都是Spring自己封装的工具，下面介绍一个Netflix OSS中的成员，通过它可以更方便的定义和使用服务消费客户端。下面也举一个具体的例子，其实现内容与上面两种方式结果一致：&lt;/p&gt;
&lt;p&gt;第一步：在&lt;code&gt;pom.xml&lt;/code&gt;中增加openfeign的依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步：定义Feign客户端和使用Feign客户端：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableDiscoveryClient
@SpringBootApplication
@EnableFeignClients
public class TestApplication {

    public static void main(String[] args) {
        SpringApplication.run(TestApplication.class, args);
    }

    @Slf4j
    @RestController
    static class TestController {

        @Autowired
        Client client;

        @GetMapping(&quot;/test&quot;)
        public String test() {
            String result = client.hello(&quot;didi&quot;);
            return &quot;Return : &quot; + result;
        }
    }


    @FeignClient(&quot;alibaba-nacos-discovery-server&quot;)
    interface Client {

        @GetMapping(&quot;/hello&quot;)
        String hello(@RequestParam(name = &quot;name&quot;) String name);

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里主要先通过&lt;code&gt;@EnableFeignClients&lt;/code&gt;注解开启扫描Spring Cloud Feign客户端的功能；然后又创建一个Feign的客户端接口定义。使用&lt;code&gt;@FeignClient&lt;/code&gt;注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口，比如下面就是绑定&lt;code&gt;alibaba-nacos-discovery-server&lt;/code&gt;服务的&lt;code&gt;/hello&lt;/code&gt;接口的例子。最后，在Controller中，注入了Client接口的实现，并调用hello方法来触发对服务提供方的调用。关于使用Feign的完整例子也可以通过在文末的仓库中查看。&lt;/p&gt;
&lt;h2 id=&quot;深入思考&quot;&gt;深入思考&lt;/h2&gt;
&lt;p&gt;如果之前已经用过Spring Cloud的读者，肯定会这样的感受：不论我用的是&lt;code&gt;RestTempalte&lt;/code&gt;也好、还是用的&lt;code&gt;WebClient&lt;/code&gt;也好，还是用的&lt;code&gt;Feign&lt;/code&gt;也好，似乎跟我用不用Nacos没啥关系？我们在之前介绍Eureka和Consul的时候，也都是用同样的方法来实现服务调用的，不是吗？&lt;/p&gt;
&lt;p&gt;确实是这样，对于Spring Cloud老手来说，就算我们更换了Nacos作为新的服务注册中心，其实对于我们应用层面的代码是没有影响的。那么为什么Spring Cloud可以带给我们这样的完美编码体验呢？实际上，这完全归功于Spring Cloud Common的封装，由于在服务注册与发现、客户端负载均衡等方面都做了很好的抽象，而上层应用方面依赖的都是这些抽象接口，而非针对某个具体中间件的实现。所以，在Spring Cloud中，我们可以很方便的去切换服务治理方面的中间件。&lt;/p&gt;
&lt;h2 id=&quot;代码示例&quot;&gt;代码示例&lt;/h2&gt;
&lt;p&gt;本文示例读者可以通过查看下面仓库：&lt;/p&gt;
&lt;p&gt;其中，本文的几种示例可查看下面的几个项目：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;alibaba-nacos-discovery-server&lt;/code&gt;：服务提供者，必须启动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alibaba-nacos-discovery-client-resttemplate&lt;/code&gt;：使用RestTemplate消费&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alibaba-nacos-discovery-client-webclient&lt;/code&gt;：使用WebClient消费&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alibaba-nacos-discovery-client-feign&lt;/code&gt;：使用Feign消费&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;如果您对这些感兴趣，欢迎star、follow、收藏、转发给予支持！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;以下专题教程也许您会有兴趣&quot;&gt;以下专题教程也许您会有兴趣&lt;/h2&gt;
</description>
<pubDate>Mon, 28 Jan 2019 14:37:00 +0000</pubDate>
<dc:creator>程序猿DD</dc:creator>
<og:description>通过 '《Spring Cloud Alibaba基础教程：使用Nacos实现服务注册与发现》' 一文的学习，我们已经学会如何使用Nacos来实现服务的注册与发现，同时也介绍如何通过LoadBalan</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/didispace/p/10332103.html</dc:identifier>
</item>
<item>
<title>asp.net core microservices 架构之Task  事务一致性  事件源 详解 - 无为有道</title>
<link>http://www.cnblogs.com/ck0074451665/p/10332044.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ck0074451665/p/10332044.html</guid>
<description>&lt;p&gt;&lt;span&gt;一 aspnetcore之task的任务状态-CancellationToken                   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     我有一篇文章讲解了asp.net的线程方面的知识。我们知道.net的针对于多线程的一个亮点就是Task，net clr维护了一个线程池，自动的分派给task执行，执行完成，迅速返回线程池，并且维护异常和状态，针对于基础的thread和其他两种异步编程，Task非常的灵巧，但是针对和应用生命周期关联的异步任务，还是使用Workbackgroup比较合适，或者甚至是基础的thread，因为Task比较高级的线程类，操作也比较简化，人为控制比较弱。那这一节为什么要说线程尼？大家有没有遇到过，部署或者人为的去重启，往往会造成一些不必要的业务中断，web api有这样的情况，后台程序也有这样的情况。异常和系统硬件的故障已经让我们防不胜防了，那么就尽量的人为的情况少那么一点点，系统的健壮性也就高那么一点点。&lt;/p&gt;
&lt;p&gt;　  目前有两个技巧可以处理这一类事情，第一是让主机graceful方式关闭，并且超时时间设置长一点，这样就有足够的时间，让运行的请求执行完毕，看代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HostBuilder()
        .Build();

    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; host.RunAsync();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;32ef4-124&quot;&gt;这是官方上的一段话：&lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/dotnet/api/microsoft.extensions.hosting.ihostedservice&quot; data-linktype=&quot;external&quot;&gt;IHostedService&lt;/a&gt; 是执行代码的入口点。 &lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;32ef4-125&quot;&gt;每个 &lt;code&gt;IHostedService&lt;/code&gt; 实现都按照 &lt;a class=&quot;x-hidden-focus&quot; href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.2#configureservices&quot; data-linktype=&quot;self-bookmark&quot;&gt;ConfigureServices 中服务注册&lt;/a&gt;的顺序执行。 &lt;span class=&quot;x-hidden-focus&quot; data-ttu-id=&quot;32ef4-126&quot;&gt;主机启动时，每个 &lt;code&gt;IHostedService&lt;/code&gt; 上都会调用 &lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/dotnet/api/microsoft.extensions.hosting.ihostedservice.startasync&quot; data-linktype=&quot;external&quot;&gt;StartAsync&lt;/a&gt;，主机正常关闭时，以反向注册顺序调用 &lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/dotnet/api/microsoft.extensions.hosting.ihostedservice.stopasync&quot; data-linktype=&quot;external&quot;&gt;StopAsync&lt;/a&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//关闭超时值

ShutdownTimeout 设置 StopAsync 的超时值。 默认值为 &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; 秒。
Program.Main 中的以下选项配置将默认值为 &lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 秒的关闭超时值增加至 &lt;span&gt;20&lt;/span&gt;&lt;span&gt; 秒：
C#

//复制
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HostBuilder()
    .ConfigureServices((hostContext, services) &lt;/span&gt;=&amp;gt;&lt;span&gt;
    {
        services.Configure&lt;/span&gt;&amp;lt;HostOptions&amp;gt;(option =&amp;gt;&lt;span&gt;
        {
            option.ShutdownTimeout &lt;/span&gt;= System.TimeSpan.FromSeconds(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
        });
    })
    .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而我们看看源码中StopAsync方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Attempts to gracefully stop the host with the given timeout.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;host&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;timeout&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The timeout for stopping gracefully. Once expired the
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; server may terminate any remaining active connections.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Task StopAsync(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IHost host, TimeSpan timeout)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; host.StopAsync(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationTokenSource(timeout).Token);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;系统接受到Ctrl+c和sign，就会调用这个方法，以比较礼貌的方式关闭。&lt;/p&gt;
&lt;p&gt;那么看源码，这两个都是具有阻塞功能的异步方法，对应的非异步方法，都是同步调用的这两个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Runs an application and returns a Task that only completes when the token is triggered or shutdown is triggered.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;host&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IHost&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt; to run.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;token&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The token to trigger shutdown.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task RunAsync(&lt;span&gt;this&lt;/span&gt; IHost host, CancellationToken token = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; (host)
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; host.StartAsync(token);

                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; host.WaitForShutdownAsync(token);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Returns a Task that completes when shutdown is triggered via the given token.
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;host&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The running &lt;/span&gt;&lt;span&gt;&amp;lt;see cref=&quot;IHost&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;token&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;The token to trigger shutdown.&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task WaitForShutdownAsync(&lt;span&gt;this&lt;/span&gt; IHost host, CancellationToken token = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; applicationLifetime = host.Services.GetService&amp;lt;IApplicationLifetime&amp;gt;&lt;span&gt;();
　　　　　　　　&lt;span&gt;//当前token执行取消的时候，激发这个委托。&lt;/span&gt;
            token.Register(state &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                ((IApplicationLifetime)state).StopApplication(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当进程取消的时候，通知注册IApplicationLifetime的进程也取消。&lt;/span&gt;
&lt;span&gt;            },
            applicationLifetime);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; waitForStop = &lt;span&gt;new&lt;/span&gt; TaskCompletionSource&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;(TaskCreationOptions.RunContinuationsAsynchronously);
            &lt;span&gt;//应用程序生命周期中的停止应用token激发的时候，执行这个委托，去释放阻塞，执行host的停止方法。&lt;/span&gt;
            applicationLifetime.ApplicationStopping.Register(obj &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tcs = (TaskCompletionSource&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;)obj;
                tcs.TrySetResult(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }, waitForStop);

            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; waitForStop.Task;&lt;span&gt;//阻塞，直到 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;tcs.TrySetResult(null);执行完毕。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Host will use its default ShutdownTimeout if none is specified.&lt;/span&gt;           &lt;span&gt;await&lt;/span&gt;&lt;span&gt; host.StopAsync(); &lt;span&gt;//调用关闭&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体原理就是Host使用这个applicationLifetime，去控制。而applicationLifetime主要的是用到了CancellationTokenSource这个类，使用这个类是可以控制task的取消执行的。&lt;/p&gt;
&lt;p&gt;所以，两个解决方案，如果是webapi，就将将超时时间设置大一点。&lt;/p&gt;
&lt;p&gt;第二，如果在非webapi中，使用了超长执行的Task，就使用CancellationTokenSource吧，将它的Token传进去，在外边判断是否执行中，如果不在执行中，就执行&lt;span class=&quot;lang-csharp&quot;&gt;Cancel方法，当然在task内部，也可以&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lang-csharp&quot;&gt;判断token，是否自己主动取消掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lang-csharp&quot;&gt;这是官方的一个例子，了解CancellationTokenSource这个类，那么就会明白如何去处理Task&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Example
{
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
   {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Define the cancellation token.&lt;/span&gt;
      CancellationTokenSource source = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationTokenSource();
      CancellationToken token &lt;/span&gt;=&lt;span&gt; source.Token;

      Random rnd &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
      Object lockObj &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
      
      List&lt;/span&gt;&amp;lt;Task&amp;lt;&lt;span&gt;int&lt;/span&gt;[]&amp;gt;&amp;gt; tasks = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Task&amp;lt;&lt;span&gt;int&lt;/span&gt;[]&amp;gt;&amp;gt;&lt;span&gt;();
      TaskFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TaskFactory(token);
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; taskCtr = &lt;span&gt;0&lt;/span&gt;; taskCtr &amp;lt;= &lt;span&gt;10&lt;/span&gt;; taskCtr++&lt;span&gt;) {
         &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iteration = taskCtr + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
         tasks.Add(factory.StartNew( () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                                       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;
                                       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] values = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
                                       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; ctr = &lt;span&gt;1&lt;/span&gt;; ctr &amp;lt;= &lt;span&gt;10&lt;/span&gt;; ctr++&lt;span&gt;) {
                                          &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (lockObj) {
                                             value &lt;/span&gt;= rnd.Next(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;101&lt;/span&gt;&lt;span&gt;);
                                          }
                                          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) { 
                                             source.Cancel();
                                             Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cancelling at task {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, iteration);
                                             &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                                          }   
                                          values[ctr&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; value; 
                                       }
                                       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; values;
                                    }, token));   
         
      }
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
         Task&lt;/span&gt;&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt; fTask =&lt;span&gt; factory.ContinueWhenAll(tasks.ToArray(), 
                                                      (results) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                                                         Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Calculating overall mean...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                                                         &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                                                         &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 
                                                         &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; t &lt;span&gt;in&lt;/span&gt;&lt;span&gt; results) {
                                                            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; r &lt;span&gt;in&lt;/span&gt;&lt;span&gt; t.Result) {
                                                                  sum &lt;/span&gt;+=&lt;span&gt; r;
                                                                  n&lt;/span&gt;++&lt;span&gt;;
                                                               }
                                                         }
                                                         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sum/(&lt;span&gt;double&lt;/span&gt;&lt;span&gt;) n;
                                                      } , token);
         Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The mean is {0}.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, fTask.Result);
      }   
      &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AggregateException ae) {
         &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (Exception e &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ae.InnerExceptions) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;is&lt;/span&gt;&lt;span&gt; TaskCanceledException)
               Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unable to compute mean: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
                                 ((TaskCanceledException) e).Message);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
               Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exception: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e.GetType().Name);
         }
      }
      &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
         source.Dispose();
      }
   }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Repeated execution of the example produces output like the following:
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Cancelling at task 5
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Unable to compute mean: A task was canceled.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;       
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Cancelling at task 10
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Unable to compute mean: A task was canceled.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;       
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Calculating overall mean...
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       The mean is 5.29545454545455.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;       
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Cancelling at task 4
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Unable to compute mean: A task was canceled.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;       
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Cancelling at task 5
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Unable to compute mean: A task was canceled.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;       
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Cancelling at task 6
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Unable to compute mean: A task was canceled.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;       
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Calculating overall mean...
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       The mean is 4.97363636363636.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;       
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Cancelling at task 4
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Unable to compute mean: A task was canceled.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;       
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Cancelling at task 5
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Unable to compute mean: A task was canceled.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;       
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Cancelling at task 4
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Unable to compute mean: A task was canceled.
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;       
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       Calculating overall mean...
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       The mean is 4.86545454545455.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;二   业务的事务一致性                                                                &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       因为微服务的理念中是牺牲了系统业务的一致性，我们知道事务的一致性都是靠的数据库的本地事务，或者分布式事务来实现的，但是微服务是严禁使用分布式事务。那么如何保证整个系统的事务完整性尼？举个例子：比如订单服务中，新接受一个订单，这个订单需要同步到库房的订单子系统，那么在订单服务中的这个订单在最后更新自己订单状态的时候，是需要同时发送异步消息给库房消息服务器的，如果这时候网络断了，本地订单更新成功了，但是异步消息没有发送过去，这样就会引起业务的缺失，目前有两个方法可以实现：&lt;/p&gt;
&lt;p&gt;      第一：为本地数据库创建事件源表，记录下消息和本地数据更新的全部状态，比如订单在更新前就可以添加事件，事件状态可以有，准备更新订单，订单已更新，发送消息队列，消息发送成功等。&lt;/p&gt;
&lt;p&gt;这样的好处就是最后跟踪这个事务处理的时候，每个步骤都可以找到，而且完全不用事务。最后job去跟踪失败情况，然后根据情况处理。&lt;/p&gt;
&lt;p&gt;      第二：只是用本地事务，就是在订单更新的时候，同时给事件源表添加消息内容，然后让后台job去发送消息，这样是最简单和最稳定的方式。&lt;/p&gt;
&lt;p&gt;      当然，最合适的还是第一种方法，虽然代码能复杂点，但是最后的效果是一样的，而且效率是比第二种方法更高效，但是考虑打事件源表并不是并发频繁操作的表，所以这个看自己的喜好了。&lt;/p&gt;
&lt;p&gt;针对一个系统，业务的一致性，也并不是全部，针对于一些关键业务做好一致性，但是很多其实可以设计成为在用户ui层面去补偿操作，唯一的坏处就是一部分数据需要重新填写。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三     事件源                                                                                 &lt;/span&gt;                          &lt;/p&gt;
&lt;p&gt;     这个事件源并不是为了解决业务的一致性，而是为了应对大数据量的请求，比如，客户管理，一个分类下有上万条记录需要处理，那么往往我们需要对性能和实时反馈上有个折衷。&lt;/p&gt;
&lt;p&gt;     系统设计如下：&lt;/p&gt;
&lt;p&gt;                                   &lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190128192849638-593940303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样看来，会增加1个api服务和一个后台服务，但是对于系统的问题，却得到了一个缓冲，或许这个设计不是最好的，但是却可以做一个抛砖引玉的案例，现实中案例非常多变，所以设计也会有很多方案。&lt;/p&gt;
&lt;p&gt;　　因为目前我们看到的大部分app，请求的时候，某些功能确实会有少许等待事件，这个都是为了折衷，当然这一篇内容并不是讨论云或者分布式计算，但是在后台这块处理越快，反馈也越快。&lt;/p&gt;
&lt;p&gt;　　这套方案的设计理念其实就是异步处理，可以有自己的优化空间，而并不会消耗api这个轻量级服务，后台分布式计算越快，app反应也越快，到一定程度，就并不会感觉到有延迟，这就是大师比喻的鼻子与眼睛的关系。&lt;/p&gt;
</description>
<pubDate>Mon, 28 Jan 2019 14:14:00 +0000</pubDate>
<dc:creator>无为有道</dc:creator>
<og:description>一 aspnetcore之task的任务状态-CancellationToken 我有一篇文章讲解了asp.net的线程方面的知识。我们知道.net的针对于多线程的一个亮点就是Task，net clr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ck0074451665/p/10332044.html</dc:identifier>
</item>
<item>
<title>深入springboot原理——一步步分析springboot启动机制（starter机制） - ITPSC</title>
<link>http://www.cnblogs.com/hjwublog/p/10332042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hjwublog/p/10332042.html</guid>
<description>&lt;p&gt;使用过springboot的同学应该已经知道，springboot通过默认配置了很多框架的使用方式帮我们大大简化了项目初始搭建以及开发过程。本文的目的就是一步步分析springboot的启动过程，分析springboot是如何帮我们简化这个过程的。&lt;/p&gt;
&lt;h2&gt;springboot帮我们做了什么&lt;/h2&gt;
&lt;p&gt;通常搭建一个基于spring的web应用，我们需要做以下工作：&lt;/p&gt;
&lt;p&gt;1、pom文件中引入相关jar包，包括spring、springmvc、redis、mybaits、log4j、mysql-connector-java 等等相关jar ...&lt;/p&gt;
&lt;p&gt;2、配置web.xml，Listener配置、Filter配置、Servlet配置、log4j配置、error配置 ...&lt;/p&gt;
&lt;p&gt;3、配置数据库连接、配置spring事务&lt;/p&gt;
&lt;p&gt;4、配置视图解析器&lt;/p&gt;
&lt;p&gt;5、开启注解、自动扫描功能&lt;/p&gt;
&lt;p&gt;6、配置完成后部署tomcat、启动调试&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;搭个初始项目不一会就一个小时甚至半天过去了。而用springboot后，一切都变得很简便快速。下来我们来一步步分析springboot的起步依赖与自动配置这两个核心原理。&lt;/p&gt;

&lt;p&gt;在springboot中我们只需要引入下面简单的几步就可以完成一个ssm后台项目的初始搭建。&lt;/p&gt;
&lt;p&gt;1、引入jar&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.0.4.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; lookup parent from repository &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;mybatis 开发包&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis.spring.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.3.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;springboot web模块支持&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;runtime&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;druid 的数据源&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;druid&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0.31&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;spring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包，&lt;/p&gt;
&lt;p&gt;mybatis-spring-boot-starter帮我们引入了dao开发相关的jar包。&lt;/p&gt;
&lt;p&gt;spring-boot-starter-xxx是官方提供的starter，xxx-spring-boot-starter是第三方提供的starter。&lt;/p&gt;
&lt;p&gt;如下截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/783994/201901/783994-20190128221725608-805455471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出在这个mybatis-spring-boot-starter 中，并没有任何源码，只有一个pom文件，它的作用就是帮我们引入了相关jar包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/783994/201901/783994-20190128221748630-1822519107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、配置数据源&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  datasource:
     url: jdbc:mysql://127.0.0.1:3306/mybatis_test
     username: root
     password: root
     driver-class-name: com.mysql.jdbc.Driver
     type: com.alibaba.druid.pool.DruidDataSource
     dbcp2:
       min-idle: 5
       initial-size: 5
       max-total: 5
       max-wait-millis: 200&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; stater机制帮我们完成了项目起步所需要的的相关jar包。那问题又来了，传统的spring应用中不是要在application.xml中配置很多bean的吗，比如dataSource的配置，transactionManager的配置 ... springboot是如何帮我们完成这些bean的配置的？下面我们来分析这个过程&lt;/p&gt;

&lt;h2&gt;基于java代码的bean配置&lt;/h2&gt;
&lt;p&gt;以mybatis为例，在上面的截图中，我们发下mybatis-spring-boot-starter这个包帮我们引入了mybatis-spring-boot-autoconfigure这个包，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/783994/201901/783994-20190128221810627-1936870136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面有MybatisAutoConfiguration这个类，打开这个类看看有什么东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/783994/201901/783994-20190128221836628-581406781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;熟悉@Configuration&amp;amp;、@Bean这两个bean的同学或许已经知道了。&lt;span&gt;这两个注解一起使用就可以创建一个基于java代码的配置类，可以用来替代相应的xml配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@Configuration注解的类可以看作是能生产让Spring IoC容器管理的Bean实例的工厂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册到spring容器中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;传统的基于xml的bean配置方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;= &quot;car&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.test.Car&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;wheel&quot;&lt;/span&gt;&lt;span&gt; ref &lt;/span&gt;&lt;span&gt;= &quot;wheel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;= &quot;wheel&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.test.Wheel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相当于用基于java代码的配置方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration  
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Conf {  
    @Bean  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car car() {  
        Car car &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Car();  
        car.setWheel(wheel());  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; car;  
    }  
    @Bean   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Wheel wheel() {  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Wheel();  
    }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;所以上面的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;MybatisAutoConfiguration&lt;span&gt;这个类，自动帮我们生成了&lt;/span&gt;&lt;span&gt;SqlSessionFactory&lt;/span&gt;&lt;span&gt;这些&lt;/span&gt;&lt;span&gt;Mybatis&lt;/span&gt;&lt;span&gt;的重要实例并交给&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;容器管理，从而完成&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;的自动注册。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;自动配置条件依赖&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从&lt;/span&gt;&lt;/span&gt;&lt;span&gt;MybatisAutoConfiguration&lt;/span&gt;&lt;span&gt;&lt;span&gt;这个类中使用的注解可以看出，要完成自动配置是有依赖条件的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@ConditionalOnClass({SqlSessionFactory.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, SqlSessionFactoryBean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@ConditionalOnBean({DataSource.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@EnableConfigurationProperties({MybatisProperties.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@AutoConfigureAfter({DataSourceAutoConfiguration.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MybatisAutoConfiguration {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些是springboot特有的，常见的条件依赖注解有：&lt;/p&gt;
&lt;p&gt;@ConditionalOnBean，仅在当前上下文中存在某个bean时，才会实例化这个Bean。&lt;/p&gt;
&lt;p&gt;@ConditionalOnClass，某个class位于类路径上，才会实例化这个Bean。&lt;/p&gt;
&lt;p&gt;@ConditionalOnExpression，当表达式为true的时候，才会实例化这个Bean。&lt;/p&gt;
&lt;p&gt;@ConditionalOnMissingBean，仅在当前上下文中不存在某个bean时，才会实例化这个Bean。&lt;/p&gt;
&lt;p&gt;@ConditionalOnMissingClass，某个class在类路径上不存在的时候，才会实例化这个Bean。&lt;/p&gt;
&lt;p&gt;@ConditionalOnNotWebApplication，不是web应用时才会实例化这个Bean。&lt;/p&gt;
&lt;p&gt;@AutoConfigureAfter，在某个bean完成自动配置后实例化这个bean。&lt;/p&gt;
&lt;p&gt;@AutoConfigureBefore，在某个bean完成自动配置前实例化这个bean。&lt;/p&gt;
&lt;p&gt;所以要完成Mybatis的自动配置，需要在类路径中存在SqlSessionFactory.class、SqlSessionFactoryBean.class这两个类，需要存在DataSource这个bean且这个bean完成自动注册。&lt;/p&gt;
&lt;p&gt;进入DataSourceAutoConfiguration这个类，可以看到这个类属于这个包：&lt;/p&gt;
&lt;p&gt;org.springframework.boot.autoconfigure.jdbc&lt;/p&gt;
&lt;p&gt;这个包又属于spring-boot-autoconfigure-2.0.4.RELEASE.jar这个包，自动配置这个包帮们引入了jdbc、kafka、logging、mail、mongo等包。很多包需要我们引入相应jar后自动配置才生效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/783994/201901/783994-20190128221901648-1674213553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&lt;span&gt;参数获取&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;到此我们已经知道了bean的配置过程，但是还没有看到springboot是如何读取yml或者properites配置文件的的属性来创建数据源的？&lt;/p&gt;
&lt;p&gt;在DataSourceAutoConfiguration类里面，我们注意到使用了EnableConfigurationProperties这个注解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@ConditionalOnClass({DataSource.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, EmbeddedDatabaseType.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@EnableConfigurationProperties({DataSourceProperties.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@Import({DataSourcePoolMetadataProvidersConfiguration.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, DataSourceInitializationConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataSourceAutoConfiguration {
...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DataSourceProperties中封装了数据源的各个属性，且使用了注解ConfigurationProperties指定了配置文件的前缀。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@ConfigurationProperties(
    prefix &lt;/span&gt;= &quot;spring.datasource&quot;&lt;span&gt;
)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DataSourceProperties &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanClassLoaderAware, InitializingBean {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ClassLoader classLoader;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; generateUniqueName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; DataSource&amp;gt;&lt;span&gt; type;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String driverClassName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String url;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
&lt;/span&gt;&lt;span&gt;    private&lt;/span&gt;&lt;span&gt; String jndiName;
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;@EnableConfigurationProperties&lt;span&gt;与&lt;/span&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;这两个注解有什么用呢？我们先看一个例子：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@ConfigurationProperties(prefix&lt;/span&gt;=&quot;spring.datasource&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PropertiesBean {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String url;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略getter、setter...&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;PropertiesBean{&quot; +
                &quot;url='&quot; + url + '\'' +
                &quot;, username='&quot; + username + '\'' +
                &quot;, password='&quot; + password + '\'' +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@MapperScan(&lt;/span&gt;&quot;com.itpsc.mapper*&quot;&lt;span&gt;)
@EnableConfigurationProperties
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringbootMybatisDemoApplication {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SpringApplication.run(SpringbootMybatisDemoApplication.class, args);&lt;/span&gt;
        ConfigurableApplicationContext context = SpringApplication.run(SpringbootMybatisDemoApplication.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取yml配置转换后的bean&lt;/span&gt;
        System.out.println(&quot;----------------------&quot;+context.getBean(PropertiesBean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        context.close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/783994/201901/783994-20190128221934631-232641466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从运行结果可以看出&lt;/span&gt;&lt;/span&gt;&lt;span&gt;@ConfigurationProperties&lt;span&gt;与&lt;/span&gt;&lt;span&gt;@EnableConfigurationPropertie&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;的作用就是：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;@ConfigurationProperties&lt;span&gt;注解的作用是把&lt;/span&gt;&lt;span&gt;yml&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;配置文件转化为&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;@EnableConfigurationProperties&lt;span&gt;注解的作用是使&lt;/span&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;&lt;span&gt;注解生效。如果只配置&lt;/span&gt;&lt;span&gt;@ConfigurationProperties&lt;/span&gt;&lt;span&gt;注解，在&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;容器中是获取不到&lt;/span&gt;&lt;span&gt;yml&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;配置文件转化的&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;通过这种方式，把&lt;/span&gt;&lt;/span&gt;&lt;span&gt;yml&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;配置参数转化为&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;，这些&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;又是如何被发现与加载的？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&lt;span&gt;发现&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;springboot&lt;span&gt;默认扫描启动类所在的包下的主类与子类的所有组件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;，但并没有包括依赖包的中的类，那么依赖包中的&lt;/span&gt;bean&lt;/span&gt;&lt;span&gt;&lt;span&gt;是如何被发现和加载的？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们通常在启动类中加&lt;/span&gt;&lt;/span&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;&lt;span&gt;&lt;span&gt;这个注解，点进去看&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters &lt;/span&gt;=&lt;span&gt; {@Filter(
    type &lt;/span&gt;=&lt;span&gt; FilterType.CUSTOM,
    classes &lt;/span&gt;= {TypeExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;}
), @Filter(
    type &lt;/span&gt;=&lt;span&gt; FilterType.CUSTOM,
    classes &lt;/span&gt;= {AutoConfigurationExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;}
)}
)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; SpringBootApplication {
...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;实际上重要的只有三个&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Annotation&lt;/span&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;@Configuration&lt;span&gt;（&lt;/span&gt;&lt;span&gt;@SpringBootConfiguration&lt;/span&gt;&lt;span&gt;里面还是应用了&lt;/span&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;@EnableAutoConfiguration&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;@ComponentScan&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;@Configuration&lt;span&gt;的作用上面我们已经知道了，被注解的类将成为一个&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;配置类。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;@ComponentScan&lt;span&gt;的作用就是自动扫描并加载符合条件的组件，比如&lt;/span&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;@Repository&lt;/span&gt;&lt;span&gt;等，最终将这些&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;定义加载到&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;容器中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;@EnableAutoConfiguration &lt;span&gt;这个注解的功能很重要，借助&lt;/span&gt;&lt;span&gt;@Import&lt;/span&gt;&lt;span&gt;的支持，收集和注册依赖包中相关的&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;定义。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import({AutoConfigurationImportSelector.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY &lt;/span&gt;= &quot;spring.boot.enableautoconfiguration&quot;&lt;span&gt;;

    Class&lt;/span&gt;&amp;lt;?&amp;gt;[] exclude() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    String[] excludeName() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如上源码，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;@EnableAutoConfiguration&lt;span&gt;注解引入了&lt;/span&gt;&lt;span&gt;@AutoConfigurationPackage&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;@Import&lt;/span&gt;&lt;span&gt;这两个注解。&lt;/span&gt;&lt;span&gt;@AutoConfigurationPackage&lt;/span&gt;&lt;span&gt;的作用就是自动配置的包，&lt;/span&gt;&lt;span&gt;@Import&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;导入需要自动配置的组件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;进入&lt;/span&gt;&lt;/span&gt;&lt;span&gt;@AutoConfigurationPackage&lt;span&gt;，发现也是引入了&lt;/span&gt;&lt;span&gt;@Import&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;注解&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import({Registrar.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; AutoConfigurationPackage {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Registrar &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ImportBeanDefinitionRegistrar, DeterminableImports {
        Registrar() {
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
            AutoConfigurationPackages.register(registry, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String[]{(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AutoConfigurationPackages.PackageImport(metadata)).getPackageName()});
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;Object&amp;gt;&lt;span&gt; determineImports(AnnotationMetadata metadata) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Collections.singleton(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AutoConfigurationPackages.PackageImport(metadata));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;new AutoConfigurationPackages.PackageImport(metadata)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这两句代码的作用就是加载启动类所在的包下的主类与子类的所有组件注册到&lt;/span&gt;&lt;/span&gt;&lt;span&gt;spring&lt;span&gt;容器，这就是前文所说的&lt;/span&gt;&lt;span&gt;springboot&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;默认扫描启动类所在的包下的主类与子类的所有组件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;那问题又来了，要搜集并注册到&lt;/span&gt;&lt;/span&gt;&lt;span&gt;spring&lt;span&gt;容器的那些&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;来自哪里？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;进入&lt;/span&gt;&lt;/span&gt; &lt;span&gt;AutoConfigurationImportSelector&lt;/span&gt;&lt;span&gt;&lt;span&gt;类，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AutoConfigurationImportSelector &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String[] NO_IMPORTS = &lt;span&gt;new&lt;/span&gt; String[0&lt;span&gt;];
...
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String[] selectImports(AnnotationMetadata annotationMetadata) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEnabled(annotationMetadata)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NO_IMPORTS;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            AutoConfigurationMetadata autoConfigurationMetadata &lt;/span&gt;= AutoConfigurationMetadataLoader.loadMetadata(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanClassLoader);
            AnnotationAttributes attributes &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getAttributes(annotationMetadata);
            List configurations &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getCandidateConfigurations(annotationMetadata, attributes);
            configurations &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.removeDuplicates(configurations);
            Set exclusions &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getExclusions(annotationMetadata, attributes);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.checkExcludedClasses(configurations, exclusions);
            configurations.removeAll(exclusions);
            configurations &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.filter(configurations, autoConfigurationMetadata);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fireAutoConfigurationImportEvents(configurations, exclusions);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StringUtils.toStringArray(configurations);
        }
    }
...

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
        List configurations &lt;/span&gt;= SpringFactoriesLoader.loadFactoryNames(&lt;span&gt;this&lt;/span&gt;.getSpringFactoriesLoaderFactoryClass(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getBeanClassLoader());
        Assert.notEmpty(configurations, &lt;/span&gt;&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; configurations;
    }

...

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;SpringFactoriesLoader.loadFactoryNames&lt;span&gt;方法调用&lt;/span&gt;&lt;span&gt;loadSpringFactories&lt;/span&gt;&lt;span&gt;方法从所有的&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包中读取&lt;/span&gt;&lt;span&gt;META-INF/spring.factories&lt;/span&gt;&lt;span&gt;文件信息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;&lt;span&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {
        MultiValueMap result &lt;/span&gt;=&lt;span&gt; (MultiValueMap)cache.get(classLoader);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(result != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Enumeration ex &lt;/span&gt;= classLoader != &lt;span&gt;null&lt;/span&gt;?classLoader.getResources(&quot;META-INF/spring.factories&quot;):ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;&lt;span&gt;);
                LinkedMultiValueMap result1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedMultiValueMap();

                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(ex.hasMoreElements()) {
                    URL url &lt;/span&gt;=&lt;span&gt; (URL)ex.nextElement();
                    UrlResource resource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UrlResource(url);
                    Properties properties &lt;/span&gt;=&lt;span&gt; PropertiesLoaderUtils.loadProperties(resource);
                    Iterator var6 &lt;/span&gt;=&lt;span&gt; properties.entrySet().iterator();

                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(var6.hasNext()) {
                        Entry entry &lt;/span&gt;=&lt;span&gt; (Entry)var6.next();
                        List factoryClassNames &lt;/span&gt;=&lt;span&gt; Arrays.asList(StringUtils.commaDelimitedListToStringArray((String)entry.getValue()));
                        result1.addAll((String)entry.getKey(), factoryClassNames);
                    }
                }

                cache.put(classLoader, result1);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result1;
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException var9) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;&lt;span&gt;, var9);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;下面是&lt;/span&gt;&lt;/span&gt;&lt;span&gt;spring-boot-autoconfigure&lt;span&gt;这个&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;spring.factories&lt;/span&gt;&lt;span&gt;文件部分内容，其中有一个&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration&lt;/span&gt;&lt;span&gt;的值定义了需要自动配置的&lt;/span&gt;&lt;span&gt;bean，&lt;/span&gt;&lt;span&gt;通过读取这个配置获取一组&lt;/span&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;类。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
org.springframework.boot.autoconfigure.AutoConfigurationImportListener=&lt;span&gt;\
org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener

# Auto Configuration Import Filters
org.springframework.boot.autoconfigure.AutoConfigurationImportFilter&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.autoconfigure.condition.OnClassCondition

# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration&lt;/span&gt;=&lt;span&gt;\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;每个&lt;/span&gt;&lt;/span&gt;&lt;span&gt;xxxAutoConfiguration&lt;span&gt;都是一个基于&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;配置类。实际上，这些&lt;/span&gt;&lt;span&gt;xxxAutoConfiguratio&lt;/span&gt;&lt;span&gt;不是所有都会被加载，会根据&lt;/span&gt;&lt;span&gt;xxxAutoConfiguration&lt;/span&gt;&lt;span&gt;上的&lt;/span&gt;&lt;span&gt;@ConditionalOnClass&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;等条件判断是否加载。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T instantiateFactory(String instanceClassName, Class&amp;lt;T&amp;gt;&lt;span&gt; factoryClass, ClassLoader classLoader) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Class ex &lt;/span&gt;=&lt;span&gt; ClassUtils.forName(instanceClassName, classLoader);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;factoryClass.isAssignableFrom(ex)) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Class [&quot; + instanceClassName + &quot;] is not assignable to [&quot; + factoryClass.getName() + &quot;]&quot;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ReflectionUtils.accessibleConstructor(ex, &lt;span&gt;new&lt;/span&gt; Class[0]).newInstance(&lt;span&gt;new&lt;/span&gt; Object[0&lt;span&gt;]);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable var4) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Unable to instantiate factory class: &quot; +&lt;span&gt; factoryClass.getName(), var4);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;如上代码段，通过反射机制将&lt;/span&gt;&lt;/span&gt;&lt;span&gt;spring.factories&lt;span&gt;中&lt;/span&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;span&gt;类实例化为对应的&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;实列。到此我们已经知道怎么发现要自动配置的&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;了，最后一步就是怎么样将这些&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;加载到&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;容器。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&lt;span&gt;加载&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;如果要让一个普通类交给&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;span&gt;&lt;span&gt;容器管理，通常有以下方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;1&lt;span&gt;、使用&lt;/span&gt; &lt;span&gt;@Configuration&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;注解&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;2&lt;span&gt;、使用&lt;/span&gt;&lt;span&gt;@Controller @Service @Repository @Component&lt;/span&gt; &lt;span&gt;注解标注该类，然后启用&lt;/span&gt;&lt;span&gt;@ComponentScan&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;自动扫描&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;3&lt;span&gt;、使用&lt;/span&gt;&lt;span&gt;@Import&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;springboot&lt;span&gt;中使用了&lt;/span&gt;&lt;span&gt;@Import&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;@EnableAutoConfiguration&lt;span&gt;注解中使用了&lt;/span&gt;&lt;span&gt;@Import({AutoConfigurationImportSelector.class})&lt;/span&gt;&lt;span&gt;注解，&lt;/span&gt;&lt;span&gt;AutoConfigurationImportSelector&lt;/span&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;span&gt;DeferredImportSelector&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;接口，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;DeferredImportSelector&lt;span&gt;接口继承了&lt;/span&gt;&lt;span&gt;ImportSelector&lt;/span&gt;&lt;span&gt;接口，&lt;/span&gt;&lt;span&gt;ImportSelector&lt;/span&gt;&lt;span&gt;接口只有一个&lt;/span&gt;&lt;span&gt;selectImports&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AutoConfigurationImportSelector &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; DeferredImportSelector{
...
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String[] selectImports(AnnotationMetadata annotationMetadata) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEnabled(annotationMetadata)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NO_IMPORTS;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            AutoConfigurationMetadata autoConfigurationMetadata &lt;/span&gt;= AutoConfigurationMetadataLoader.loadMetadata(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanClassLoader);
            AnnotationAttributes attributes &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getAttributes(annotationMetadata);
            List configurations &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getCandidateConfigurations(annotationMetadata, attributes);
            configurations &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.removeDuplicates(configurations);
            Set exclusions &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getExclusions(annotationMetadata, attributes);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.checkExcludedClasses(configurations, exclusions);
            configurations.removeAll(exclusions);
            configurations &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.filter(configurations, autoConfigurationMetadata);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fireAutoConfigurationImportEvents(configurations, exclusions);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StringUtils.toStringArray(configurations);
        }
}
...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; DeferredImportSelector &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ImportSelector {
    @Nullable
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; DeferredImportSelector.Group&amp;gt;&lt;span&gt; getImportGroup() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Group {...}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ImportSelector {
    String[] selectImports(AnnotationMetadata var1);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;我们先通过一个简单例子看看&lt;/span&gt;&lt;/span&gt;&lt;span&gt;@Import&lt;span&gt;注解是如何将&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;导入到&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;容器的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;1&lt;span&gt;、新建一个&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String phone;
...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;2&lt;span&gt;、创建一个&lt;/span&gt;&lt;span&gt;ItpscSelector&lt;/span&gt;&lt;span&gt;类继承&lt;/span&gt;&lt;span&gt;ImportSelector&lt;/span&gt;&lt;span&gt;接口并实现&lt;/span&gt;&lt;span&gt;selectImports&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ItpscSelector &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ImportSelector {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String[] selectImports(AnnotationMetadata importingClassMetadata) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String[]{&quot;com.itpsc.entity.User&quot;&lt;span&gt;};
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;创建&lt;/span&gt;ImportConfig&lt;span&gt;类，使用&lt;/span&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;@Import(ItpscSelector.class)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;注解。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@Import(ItpscSelector.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImportConfig {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;从容器获取&lt;/span&gt;bean&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@RunWith(SpringRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@SpringBootTest
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImportSelectorTests {
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSelectImport() {
        ApplicationContext ctx &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(ImportConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        String[] beanDefinitionNames &lt;/span&gt;=&lt;span&gt; ctx.getBeanDefinitionNames();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String name : beanDefinitionNames) {
            System.out.println(name);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalRequiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
importConfig
com.itpsc.entity.User&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;很直观，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;selectImports&lt;span&gt;方法返回一组&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;@EnableAutoConfiguration&lt;/span&gt;&lt;span&gt;注解借助&lt;/span&gt;&lt;span&gt;@Import&lt;/span&gt;&lt;span&gt;注解将这组&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;注入到&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;容器中，&lt;/span&gt;&lt;span&gt;springboot&lt;/span&gt;&lt;span&gt;正式通过这种机制来完成&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;的注入的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们可以将自动配置的关键几步以及相应的注解总结如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;1&lt;span&gt;、&lt;/span&gt;&lt;span&gt;@Configuration&amp;amp;&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;@Bean-&amp;gt;&lt;/span&gt;&lt;span&gt;基于&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;代码的&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;配置&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;2&lt;span&gt;、&lt;/span&gt;&lt;span&gt;@Conditional-&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;设置自动配置条件依赖&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;3&lt;span&gt;、&lt;/span&gt;&lt;span&gt;@EnableConfigurationProperties&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;@ConfigurationProperties-&amp;gt;&lt;/span&gt;&lt;span&gt;读取配置文件转换为&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;4&lt;span&gt;、&lt;/span&gt;&lt;span&gt;@EnableAutoConfiguration&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;@AutoConfigurationPackage&lt;/span&gt; &lt;span&gt;与&lt;/span&gt;&lt;span&gt;@Import-&amp;gt;&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;发现与加载。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 28 Jan 2019 14:13:00 +0000</pubDate>
<dc:creator>ITPSC</dc:creator>
<og:description>前言 使用过springboot的同学应该已经知道，springboot通过默认配置了很多框架的使用方式帮我们大大简化了项目初始搭建以及开发过程。本文的目的就是一步步分析springboot的启动过程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hjwublog/p/10332042.html</dc:identifier>
</item>
<item>
<title>函数的返回值（初学者） - 巫师笔记</title>
<link>http://www.cnblogs.com/lvfengkun/p/10332022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvfengkun/p/10332022.html</guid>
<description>&lt;p&gt;通常，希望通过函数使主调函数得到一个确定的值，这就是函数的返回值。&lt;/p&gt;
&lt;p&gt;说明：1、函数的返回值是通过函数的return语句获得的。&lt;/p&gt;
&lt;p&gt;（1）return语句将被调函数中的一个确定值带回主调函数中去。&lt;/p&gt;
&lt;p&gt;（2）若需要从被调函数带回一个值供主调函数使用，被调函数必须包含return语句。如果不需要就可以不带。&lt;/p&gt;
&lt;p&gt;（3）一个函数语句可以有一个以上的return语句，执行到哪一个return语句，哪一个语句起作用。return语句后面的括弧也可以不要。如：return 2；等价于：return（2）；&lt;/p&gt;
&lt;p&gt;（4）return后的值可以是一个表达式。&lt;/p&gt;
&lt;p&gt;例：int max(int x,int y);&lt;/p&gt;
&lt;p&gt;　　{&lt;/p&gt;
&lt;p&gt;　　　　return(x&amp;gt;y?x:y);&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;2、（1）函数的返回值应当属于某一个确定的类型，在定义函数时指定函数返回值的类型。&lt;/p&gt;
&lt;p&gt;例：int max(float x,float y)   /*函数的值为整型*/&lt;/p&gt;
&lt;p&gt;（2）在C语言中，凡不加类型说明符的函数自动按整形处理。&lt;/p&gt;
&lt;p&gt;3、（1）在定义函数时指定函数的类型一般应和return语句中的表达式类型一致。如果函数值的类型和return语句表达式的值不一致，则以函数类型为准。对数值型数据可以自动进行类型转换。&lt;/p&gt;
&lt;p&gt;（2）对于不带回值的函数，应当用“viod”定义函数为无类型（空类型）。这样，系统就保证不使函数带回任何值。此时，在函数体中不得出现return语句。&lt;/p&gt;
&lt;p&gt;例：（反例）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdafx.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; max(&lt;span&gt;float&lt;/span&gt; x,&lt;span&gt;float&lt;/span&gt;&lt;span&gt; y);
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; a,b;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;b);
    c&lt;/span&gt;=&lt;span&gt;max(a,b);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Max is %d:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,c);
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; max(&lt;span&gt;float&lt;/span&gt; x,&lt;span&gt;float&lt;/span&gt;&lt;span&gt; y)
{
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; z;
    z&lt;/span&gt;=x&amp;gt;y?&lt;span&gt;x:y;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(z);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdafx.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; max(&lt;span&gt;float&lt;/span&gt; x,&lt;span&gt;float&lt;/span&gt;&lt;span&gt; y);
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; a,b;
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; c;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%f%f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;b);
    c&lt;/span&gt;=&lt;span&gt;max(a,b);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Max is %f:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,c);
}
&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; max(&lt;span&gt;float&lt;/span&gt; x,&lt;span&gt;float&lt;/span&gt;&lt;span&gt; y)
{
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; z;
    z&lt;/span&gt;=x&amp;gt;y?&lt;span&gt;x:y;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(z);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 28 Jan 2019 14:07:00 +0000</pubDate>
<dc:creator>巫师笔记</dc:creator>
<og:description>通常，希望通过函数使主调函数得到一个确定的值，这就是函数的返回值。 说明：1、函数的返回值是通过函数的return语句获得的。 （1）return语句将被调函数中的一个确定值带回主调函数中去。 （2）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvfengkun/p/10332022.html</dc:identifier>
</item>
<item>
<title>再探Redux Middleware - Raion</title>
<link>http://www.cnblogs.com/raion/p/10328448.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/raion/p/10328448.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在初步了解Redux中间件演变过程之后，继续研究Redux如何将中间件结合。上次将中间件与redux硬结合在一起确实有些难看，现在就一起看看Redux如何加持中间件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;中间件执行过程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190127194143663-1752537207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;希望借助图形能帮助各位更好的理解中间件的执行情况。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;redux如何加持中间件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在是时候看看redux是如何将中间件结合了，我们在源码中一探究竟。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
*&lt;span&gt; @param {Function} [enhancer] The store enhancer. &lt;span&gt;You may optionally specify it
 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;* to enhance the store with third-&lt;/span&gt;&lt;span&gt;&lt;span&gt;party capabilities such as &lt;strong&gt;middleware&lt;/strong&gt;&lt;/span&gt;,
 &lt;/span&gt;* time travel, persistence, etc. The &lt;span&gt;&lt;strong&gt;only&lt;/strong&gt;&lt;/span&gt; store enhancer that ships &lt;span&gt;with&lt;/span&gt;&lt;span&gt; Redux
 &lt;/span&gt;*&lt;span&gt; is `&lt;span&gt;&lt;strong&gt;applyMiddleware&lt;/strong&gt;&lt;/span&gt;()`.
 &lt;/span&gt;*
 *&lt;span&gt; @returns {Store} A Redux store that lets you read the state, dispatch actions
 &lt;/span&gt;*&lt;span&gt; and subscribe to changes.
 &lt;/span&gt;*/&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; createStore(reducer, preloadedState, enhancer) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (
    (&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; preloadedState === 'function' &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; enhancer === 'function') ||&lt;span&gt;
    (&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt; enhancer === 'function' &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; arguments[3] === 'function'&lt;span&gt;)
  ) {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(
      &lt;/span&gt;'It looks like you are passing several store enhancers to ' +
        'createStore(). This is not supported. Instead, compose them ' +
        'together to a single function'&lt;span&gt;
    )
  }

  &lt;/span&gt;&lt;span&gt;if (typeof preloadedState === 'function' &amp;amp;&amp;amp; typeof enhancer === 'undefined') {
    enhancer = preloadedState &lt;span&gt;// 如果初始化state是一个函数，则认为有中间件&lt;/span&gt;
    preloadedState = undefined
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.')
    }

    return enhancer(createStore)(reducer, preloadedState)
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果createStore第二个参数是函数（第二，第三都是函数会抛异常），则redux认为第二个参数是调用applyMiddleware函数的返回值（注释有说明）。&lt;/p&gt;
&lt;p&gt;根据&lt;strong&gt;&lt;span&gt;return enhancer(createStore)&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;reducer, preloadedState)&lt;/span&gt;&lt;/strong&gt;，说明applyMiddleware返回了一个函数，该函数内还返回了一个函数。那么接下来从applyMiddleware源码中一探究竟。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; applyMiddleware(...middlewares) { &lt;span&gt;// 将所有中间件存入middlewares数组
  &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; createStore =&amp;gt; (...args) =&amp;gt;&lt;span&gt; { &lt;span&gt;// 返回函数以createStore为参数，args即[reducer, preloadedState]&lt;/span&gt;
    const store &lt;/span&gt;=&lt;span&gt; createStore(...args) &lt;span&gt;// 创建一个store&lt;/span&gt;
    let dispatch &lt;/span&gt;= () =&amp;gt;&lt;span&gt; { &lt;span&gt;// 定义一个dispatch变量指向匿名函数，如果被调用则抛出异常
      &lt;/span&gt;&lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(
        `Dispatching &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; constructing your middleware is not allowed. ` +&lt;span&gt;
          `Other middleware would not be applied to &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt; dispatch.`
      )
    }

    const middlewareAPI &lt;/span&gt;=&lt;span&gt; {
      getState: store.getState,
      dispatch: (...args) &lt;/span&gt;=&amp;gt;&lt;span&gt; dispatch(...args) &lt;span&gt;// middlewareAPI的dispatch属性指向一个匿名函数，该函数内部会执行外部dispatch变量指向的那个函数。&lt;/span&gt;
    }
    const chain &lt;/span&gt;= middlewares.map(middleware =&amp;gt;&lt;span&gt; middleware(middlewareAPI)) &lt;span&gt;// 执行每个中间件，顺带检查是否有中间件调用传入参数中的dispatch，如果有则抛出异常&lt;/span&gt;
    dispatch &lt;/span&gt;=&lt;span&gt; compose(...chain)(store.dispatch) &lt;span&gt;// 将chain展开传入compose，然后执行返回的函数，传入store.dispatch，最后将所有中间件组合成最终的中间件，并将dispatch变量指向这个中间件。
　　// 由于dispatch变量的更改，它原来指向的匿名函数现在没有任何变量指向它，会被垃圾回收。&lt;br/&gt;// &lt;strong&gt;误区：&lt;/strong&gt;调用middlewareAPI的dispatch属性指向的函数时，内部的dispatch会指向原来抛出异常的匿名函数。这是错误的，在调用middlewareAPI的dispatch属性所指向的函数时，&lt;br/&gt;　　// 会寻找dispatch变量，函数内部找不到就向外部作用域寻找，然后找到外部dispatch，而此时外部的dispatch指向最终的中间件，所以会调用最终的中间件。&lt;strong&gt;这对于理解redux-thunk非常重要。&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      ...store,
      dispatch &lt;span&gt;// 覆盖store中dispatch变量&lt;/span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码中还有一点疑惑，compose函数是什么样子，那么我们再探compose。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 *&lt;span&gt; @param {...Function} funcs The functions to compose.
 &lt;/span&gt;* @returns {Function} A &lt;span&gt;function&lt;/span&gt;&lt;span&gt; obtained by composing the argument functions
 &lt;/span&gt;*&lt;span&gt; from right to left. For example, &lt;span&gt;compose(f, g, h) is identical to doing
 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;* &lt;strong&gt;(...args) =&amp;gt; f(g(h(...args)))&lt;/strong&gt;. 可以发现，和我们之前写的代码效果一模一样
 &lt;/span&gt;*/&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; compose(...funcs) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (funcs.length === 0&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; arg =&amp;gt;&lt;span&gt; arg
  }

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (funcs.length === 1&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; funcs[0&lt;span&gt;]
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; funcs.reduce((a, b) =&amp;gt; (...args) =&amp;gt;&lt;span&gt; a(b(...args)))
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也许你对数组的reduce方法不是很熟，上篇文章篇幅也比较饱满。那么这儿简单讲解下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
[1, 2, 3, 4].reduce((a, b) =&amp;gt; { console.log(a, b); &lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b })
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1 2 可以发现第一次执行，我们拿到数组的第1，2个变量&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 3 3 拿到上次返回的结果和第3个变量&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 6 4 拿到上次返回的结果和第4个变量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后结果为10，没有打印所以看不出。当然数组存储的也可能是对象，在reduce函数执行时，拿到每个变量的副本（浅拷贝），然后根据你的代码做对应的事。在这就以上篇文章的中间&lt;/p&gt;
&lt;p&gt;件为例，再加入logMiddleware3（和logMiddleware2类似，只是将打印的数字部分改为3而已），看看compose函数执行过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[logMiddleware3, logMiddleware2, logMiddleware].reduce((a, b) =&amp;gt; (...args) =&amp;gt; a(b(...args)))&lt;br/&gt;&lt;span&gt;// &lt;strong&gt;假定compose函数传入的参数为store.dispatch，则有以下结果：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// （logMiddleware3, logMiddleware2） =&amp;gt; (...args) =&amp;gt; logMiddleware3(logMiddleware2(...args)) 这里args[0]为logMiddleware(store.dispatch)返回的中间件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// （logMiddleware3(logMiddleware2(...args)), logMiddleware） =&amp;gt; (...args) =&amp;gt; logMiddleware3(logMiddleware2(logMiddleware(...args))) 这里的args[0]为store.dispatch&lt;br/&gt;//  最后返回（...args）=&amp;gt; logMiddleware3(logMiddleware2(logMiddleware(...args))) ,接着执行该函数，传入store.dispatch，也就产生了最终的中间件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在对于redux结合过程已经有了一定的认识，是时候看看别人的中间件了，对比我们自己的中间件，也许有不同的收获。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;redux-thunk&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至此我们写的中间件都比较好理解，是时候认识下redux-thunk了。它又会有什么特别之处了，让我们一起看看源码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createThunkMiddleware(extraArgument) { &lt;span&gt;// 这里extraArgument完全没用到
  &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ({ dispatch, getState }) =&amp;gt; next =&amp;gt; action =&amp;gt;&lt;span&gt; { &lt;span&gt;// 这里的dispatch如果有疑惑，请看上面👆applyMiddleware源码解析
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; action === 'function'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; action(dispatch, getState, extraArgument);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next(action);
  };
}

const thunk &lt;/span&gt;=&lt;span&gt; createThunkMiddleware();
thunk.withExtraArgument &lt;/span&gt;=&lt;span&gt; createThunkMiddleware;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; thunk;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;what？太精辟了有木有。其实理解起来也很简单，如果传入的action是一个函数，则调用该函数；否则调用上一个中间件并返回结果。当然你还可以再精简些。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; action === 'function' ? action(dispatch, getState, extraArgument) : next(action)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么问题来了，什么时候用得着redux-thunk呢？也就是什么情况下action会是函数。我们仔细看看action为函数时，它的参数也就明白了。在执行action函数时，我们还能调用dispatch，说明dispatch操作是要等待某个东西执行完才可以执行。说到这，还能是什么呢？当然非异步任务莫属了。&lt;/p&gt;
&lt;p&gt;好了现在我们将原来的代码更改下，实现和redux，redux-thunk结合，这里我们先自己实现redux-thunk。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ThunkMiddleware() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ({ dispatch, getState }) =&amp;gt; next =&amp;gt; action =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; action === 'function' ?&lt;span&gt; action(dispatch, getState) : next(action)
  }
}

const thunk &lt;/span&gt;=&lt;span&gt; ThunkMiddleware();
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; thunk;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新建middleware目录，新建redux-thunk和redux-logger，接着封装redux-logger模块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; LoggerMiddleware() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ({ getState }) =&amp;gt; next =&amp;gt; action =&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;'dispatch: '&lt;span&gt;, action);
    let result &lt;/span&gt;=&lt;span&gt; next(action);
    console.log(&lt;/span&gt;'nextState: '&lt;span&gt;, getState());
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  }
}

const logger &lt;/span&gt;=&lt;span&gt; LoggerMiddleware();
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; logger;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更改index.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
import React from 'react'&lt;span&gt;;
import ReactDOM from &lt;/span&gt;'react-dom'&lt;span&gt;;
import { createStore, &lt;span&gt;applyMiddleware&lt;/span&gt; } from &lt;/span&gt;'redux'&lt;span&gt;;
import { Provider } from &lt;/span&gt;'react-redux'&lt;span&gt;;
import App from &lt;/span&gt;'./App'&lt;span&gt;;
import &lt;/span&gt;* as serviceWorker from './serviceWorker'&lt;span&gt;;
&lt;span&gt;import reduxLogger from &lt;/span&gt;&lt;/span&gt;&lt;span&gt;'./middlewares/redux-logger';
import reduxThunk from './middlewares/redux-thunk';

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; listReducer(state =&lt;span&gt; { list: [] }, action) {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'receive'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        list: action.data
      };
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
  }
}

const store &lt;/span&gt;=&lt;span&gt; createStore(listReducer, &lt;span&gt;applyMiddleware(reduxLogger, reduxThunk)&lt;/span&gt;);

ReactDOM.render(
  &lt;/span&gt;&amp;lt;Provider store={store}&amp;gt;
    &amp;lt;App /&amp;gt;
  &amp;lt;/Provider&amp;gt;, document.getElementById('root'));
&lt;span&gt;
serviceWorker.unregister();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更改App.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
import React, { Component } from 'react'&lt;span&gt;;
import { connect } from &lt;/span&gt;'react-redux'&lt;span&gt;;
import axios from &lt;/span&gt;'axios'&lt;span&gt;;
import Mock from &lt;/span&gt;'mockjs'&lt;span&gt;;

Mock.mock(&lt;/span&gt;'http://test.com/search'&lt;span&gt;, {
  &lt;/span&gt;'list|0-5'&lt;span&gt;: [{
    &lt;/span&gt;'id|+1': 1&lt;span&gt;,
    name: &lt;/span&gt;'@character(&quot;lower&quot;)'&lt;span&gt;,
    &lt;/span&gt;'version': '@float(1, 10, 2, 2)'&lt;span&gt;,
    publisher: &lt;/span&gt;'@cname'&lt;span&gt;
  }]
});

class App extends Component {
  state &lt;/span&gt;=&lt;span&gt; {
    searchValue: &lt;/span&gt;''&lt;span&gt;,
  };
  handleSearch &lt;/span&gt;= e =&amp;gt;&lt;span&gt; {
    e.preventDefault();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.searchValue) {
      &lt;/span&gt;&lt;span&gt;this.props.changeList(this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.state.searchValue);&lt;/span&gt;
    }
  };
  changeValue &lt;/span&gt;= e =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({ searchValue: e.target.value });
  };
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;div style={{ textAlign: 'center', margin: '40px' }}&amp;gt;
        &amp;lt;form onSubmit={&lt;span&gt;this&lt;/span&gt;.handleSearch}&amp;gt;
          &amp;lt;input type=&quot;text&quot; value={&lt;span&gt;this&lt;/span&gt;.state.searchValue} onChange={&lt;span&gt;this&lt;/span&gt;.changeValue} /&amp;gt;
          &amp;lt;button type=&quot;submit&quot;&amp;gt;搜索&amp;lt;/button&amp;gt;
        &amp;lt;/form&amp;gt;
        &amp;lt;ul&amp;gt;&lt;span&gt;
          {&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.props.list.map(item =&amp;gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;li key={item.id} style={{ listStyle: 'none' }}&amp;gt;
              &amp;lt;p&amp;gt;{item.name}&amp;lt;/p&amp;gt;
              &amp;lt;p&amp;gt;&lt;span&gt;
                {item.publisher} publish {item.version}
              &lt;/span&gt;&amp;lt;/p&amp;gt;
            &amp;lt;/li&amp;gt;
&lt;span&gt;          ))}
        &lt;/span&gt;&amp;lt;/ul&amp;gt;
      &amp;lt;/div&amp;gt;
&lt;span&gt;    );
  }
}

&lt;span&gt;const fetchResult &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= (searchValue) =&amp;gt; dispatch =&amp;gt; {
  return axios.get(`http://test.com/search`).then(result =&amp;gt; {
    if (result.status === 200) {
      const data = result.data.list.map(item =&amp;gt; ({...item, name: `${searchValue}${item.name}`}));
      const action = { type: 'receive', data };
      dispatch(action);
    }
  })
};

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mapStateToProps(state) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    list: state.list
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mapDispatchToProps(dispatch) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    &lt;span&gt;changeList: searchValue &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; dispatch(fetchResult(searchValue))&lt;/span&gt;
  }
}

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; connect(mapStateToProps, mapDispatchToProps)(App);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190127232309627-254947379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目目录如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1300457/201901/1300457-20190127232525658-268941372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你理解了redux处理中间件的过程，那本文的目的也达到了。海纳百川，有容乃大。redux正是中间件的加持，才变得越发强大。也希望我们每天能进步一点点，造就更美好的自己。&lt;/p&gt;

</description>
<pubDate>Mon, 28 Jan 2019 13:26:00 +0000</pubDate>
<dc:creator>Raion</dc:creator>
<og:description>前言 在初步了解Redux中间件演变过程之后，继续研究Redux如何将中间件结合。上次将中间件与redux硬结合在一起确实有些难看，现在就一起看看Redux如何加持中间件。 中间件执行过程 希望借助图</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/raion/p/10328448.html</dc:identifier>
</item>
<item>
<title>条件随机场之CRF++源码详解-训练 - 渡码</title>
<link>http://www.cnblogs.com/duma/p/10325724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duma/p/10325724.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;上篇的CRF++源码阅读中， 我们看到CRF++如何处理样本以及如何构造特征。本篇文章将继续探讨CRF++的源码，并且本篇文章将是整个系列的重点，会介绍条件随机场中如何构造无向图、前向后向算法、如何计算条件概率、如何计算特征函数的期望以及如何求似然函数的梯度。本篇将结合条件随机场公式推导和CRF++源码实现来讲解以上问题。&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;a href=&quot;https://www.cnblogs.com/duma/p/10325724.html%20&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;开启多线程&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　我们接着上一篇encoder.cpp文件中的learn函数继续看，该函数的下半部分将会调用具体的学习算法做训练。目前CRF++支持两种训练算法，一种是拟牛顿算法中的LBFGS算法，另一种是MIRA算法， 本篇文章主要探讨LBFGS算法的实现过程。在learn函数中，训练算法的入口代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (algorithm) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MIRA:　　　　　　　　　　　　　　　　　　　　//MIRA算法的入口
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!runMIRA(x, &amp;amp;feature_index, &amp;amp;alpha[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],
                   maxitr, C, eta, shrinking_size, thread_num)) {
        WHAT_ERROR(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MIRA execute error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; CRF_L2:　　　　　　　　　　　　　　　　　　//LBFGS-L2正则化的入口函数
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!runCRF(x, &amp;amp;feature_index, &amp;amp;alpha[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],
                  maxitr, C, eta, shrinking_size, thread_num, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)) {
        WHAT_ERROR(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CRF_L2 execute error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; CRF_L1:　　　　　　　　　　　　　　　　　 //LBFGS-L1正则化的入口函数
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!runCRF(x, &amp;amp;feature_index, &amp;amp;alpha[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],
                  maxitr, C, eta, shrinking_size, thread_num, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
        WHAT_ERROR(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CRF_L1 execute error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      }
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; runCRF函数中会初始化CRFEncoderThread数组，并启动每个线程，源码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; runCRF(&lt;span&gt;const&lt;/span&gt; std::vector&amp;lt;TaggerImpl* &amp;gt; &amp;amp;&lt;span&gt;x,
            EncoderFeatureIndex &lt;/span&gt;*&lt;span&gt;feature_index,
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; *&lt;span&gt;alpha,
            size_t maxitr,
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; C,
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; eta,
            unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;&lt;span&gt; shrinking_size,
            unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;&lt;span&gt; thread_num,
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; orthant) {
  ... //省略代码&lt;br/&gt;　&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t itr = &lt;span&gt;0&lt;/span&gt;; itr &amp;lt; maxitr; ++&lt;span&gt;itr) { //开始迭代， 最大迭代次数为maxitr，即命令行参数-m
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; thread_num; ++&lt;span&gt;i) {
      thread[i].start();                    //启动每个线程，start函数中会调用CRFEncoderThread类中的run函数  
    }

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; thread_num; ++&lt;span&gt;i) {
      thread[i].join();　　　　　　　　　　　　//等待所有线程结束
    }&lt;br/&gt;　　... //省略代码&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; CRFEncoderThread类中的run函数调用gradient函数，完成一系列的核心计算。源码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
    obj &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
    err &lt;/span&gt;= zeroone = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    std::fill(expected.begin(), expected.end(), &lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;); //excepted变量存放期望
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t i = start_i; i &amp;lt; size; i +=&lt;span&gt; thread_num) {//每个线程并行处理多个句子， 并且每个线程处理的句子不相同， size是句子的个数
      obj &lt;/span&gt;+= x[i]-&amp;gt;gradient(&amp;amp;expected[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);  //x[i]是TaggerImpl对象，代表一个句子， gradient函数主要功能： 1. 构建无向图  2. 调用前向后向算法 3. 计算期望
      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; error_num = x[i]-&amp;gt;&lt;span&gt;eval();         
      err &lt;/span&gt;+=&lt;span&gt; error_num;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (error_num) {
        &lt;/span&gt;++&lt;span&gt;zeroone;
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;构造无向图&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　我们知道条件随机场是概率图模型，几乎所有的概率计算都是在无向图上进行的。那么这个图是如果构造的呢？答案就在gradient函数第一个调用 —— buildLattice函数中。该函数完成2个核心功能，1. &lt;strong&gt;构建无向图&lt;/strong&gt; 2. &lt;strong&gt;计算节点以及边上的代价&lt;/strong&gt;，先看一下无向图的构造过程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; TaggerImpl::buildLattice() {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (x_.empty()) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }

  feature_index_&lt;/span&gt;-&amp;gt;rebuildFeatures(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;); //调用该方法初始化节点（Node）和边（Path），并连接
&lt;/span&gt;&lt;span&gt;
  ... &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略代码  &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; FeatureIndex::rebuildFeatures(TaggerImpl *tagger) &lt;span&gt;const&lt;/span&gt;&lt;span&gt; {
  size_t fid &lt;/span&gt;= tagger-&amp;gt;&lt;span&gt;feature_id();           //取出当前句子的feature_id，上篇介绍构造特征的时候，在buildFeatures函数中会set feature_id
  &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; size_t thread_id = tagger-&amp;gt;&lt;span&gt;thread_id();

  Allocator &lt;/span&gt;*allocator = tagger-&amp;gt;&lt;span&gt;allocator();
  allocator&lt;/span&gt;-&amp;gt;&lt;span&gt;clear_freelist(thread_id);
  FeatureCache &lt;/span&gt;*feature_cache = allocator-&amp;gt;&lt;span&gt;feature_cache();
　&lt;br/&gt;//每个词以及对应的所有可能的label，构造节点
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t cur = &lt;span&gt;0&lt;/span&gt;; cur &amp;lt; tagger-&amp;gt;size(); ++&lt;span&gt;cur) { //遍历每个词， 
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *f = (*feature_cache)[fid++&lt;span&gt;]; //取出每个词的特征列表，词的特征列表对应特征模板里的Unigram特征
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; y_.size(); ++&lt;span&gt;i) { //每个词都对应不同的label， &lt;strong&gt;每个label用数组的下标表示&lt;/strong&gt;，每个特征+当前的label就是特征函数
      Node &lt;/span&gt;*n = allocator-&amp;gt;&lt;span&gt;newNode(thread_id); //初始化新的节点，即Node对象
      n&lt;/span&gt;-&amp;gt;&lt;span&gt;clear();
      n&lt;/span&gt;-&amp;gt;x =&lt;span&gt; cur; //当前词
      n&lt;/span&gt;-&amp;gt;y =&lt;span&gt; i;　　//当前词的label
      n&lt;/span&gt;-&amp;gt;fvector =&lt;span&gt; f; //特征列表
      tagger&lt;/span&gt;-&amp;gt;&lt;span&gt;set_node(n, cur, i); //有一个二维数组node_存放每个节点
    }
  }
&lt;br/&gt;//从第二个词开始构造节点之间的边，两个词之间有y_.size()*y_.size()条边
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t cur = &lt;span&gt;1&lt;/span&gt;; cur &amp;lt; tagger-&amp;gt;size(); ++&lt;span&gt;cur) {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *f = (*feature_cache)[fid++&lt;span&gt;]; //取出每个边的特征列表，边的特征列表对应特征模板里的Bigram特征
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; y_.size(); ++&lt;span&gt;j) {//前一个词的label有y_.size()种情况，即y_.size()个节点
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; y_.size(); ++&lt;span&gt;i) {//当前词label也有y_.size()种情况，即y_.size()个节点
        Path &lt;/span&gt;*p = allocator-&amp;gt;&lt;span&gt;newPath(thread_id);//初始化新的节点，即Path对象
        p&lt;/span&gt;-&amp;gt;&lt;span&gt;clear();&lt;br/&gt;　　　　 //add函数会设置当前边的左右节点，同时会把当前边加入到左右节点的边集合中
        p&lt;/span&gt;-&amp;gt;add(tagger-&amp;gt;node(cur - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, j), //前一个节点
               tagger&lt;/span&gt;-&amp;gt;&lt;span&gt;node(cur,     i)); //当前节点 
        p&lt;/span&gt;-&amp;gt;fvector =&lt;span&gt; f;
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 图构造完成后， 接下来看看节点和边上的代价是如何计算的。那么代价是什么？我的理解就是特征函数值乘以特征的权重。这部分源码在buildLattice函数中，具体如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; x_.size(); ++&lt;span&gt;i) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; ysize_; ++&lt;span&gt;j) {
      feature_index_&lt;/span&gt;-&amp;gt;calcCost(node_[i][j]); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算节点的代价&lt;/span&gt;
      &lt;span&gt;const&lt;/span&gt; std::vector&amp;lt;Path *&amp;gt; &amp;amp;lpath = node_[i][j]-&amp;gt;&lt;span&gt;lpath;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (const_Path_iterator it = lpath.begin(); it != lpath.end(); ++&lt;span&gt;it) {
        feature_index_&lt;/span&gt;-&amp;gt;calcCost(*it); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算边的代价&lt;/span&gt;
&lt;span&gt;      }
    }
}
//节点的代价计算函数
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; FeatureIndex::calcCost(Node *n) &lt;span&gt;const&lt;/span&gt;&lt;span&gt; {
  n&lt;/span&gt;-&amp;gt;cost = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; ADD_COST(T, A)                                                  \
  &lt;span&gt;do&lt;/span&gt; { T c = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;                                                               \
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *f = n-&amp;gt;fvector; *f != -&lt;span&gt;1&lt;/span&gt;; ++f) { c += (A)[*f + n-&amp;gt;&lt;span&gt;y];  }  \  //取每个特征以及当前节点的label，即为特征函数，且值为1，特征函数乘以权重（alpha_[*f + n-&amp;gt;y]）是代价，特征函数为1所以代价=alpha_[*f + n-&amp;gt;y]*1，对所有代价求和
    n&lt;/span&gt;-&amp;gt;cost =cost_factor_ *(T)c; } &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) //cost_factor_是代价因子

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (alpha_float_) {
    ADD_COST(&lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt;,  alpha_float_);
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    ADD_COST(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt;, alpha_); //将会在这里调用， 上一篇内容可以看到，CRF++初始化的是alpha_变量
  }
&lt;/span&gt;&lt;span&gt;#undef&lt;/span&gt; ADD_COST&lt;span&gt;
}&lt;br/&gt;//边的代价计算函数与节点类似，不再赘述&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 看完源码，我们举个例子来可视化一下无向图，仍然&lt;/span&gt;&lt;span&gt;用上一篇中构造特征的那个例子。如果忘记了，&lt;a href=&quot;https://www.cnblogs.com/duma/p/10293190.html&quot; target=&quot;_blank&quot;&gt;出门左转&lt;/a&gt;回顾一下。上一个例子中有三个词，假设这三个词分别是“我”、“爱”、“你”。&lt;/span&gt;&lt;span&gt;构建的无向图如图一所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201901/1129006-20190127153533065-1277451338.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图一&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个例子中，有三个词和三个label，每个label用0,1，2表示，&lt;strong&gt;之前我们说过用数组下标代替label&lt;/strong&gt;。每个词有3个节点，且这三个节点的特征列表f是一样的，由于label不一样，所以他们的特征函数值不一样。由于没有bigram特征，所有边上的特征列表都是f=[-1]。大部分资料的无向图前后会加一个start节点和stop节点，加上后可以便于理解和公式推导。CRF++源码中没加，所以我们这里就没有表示。在这里node_[0][0]对应就是最左上角的节点，代表“我”这个词label为0的节点。我们再看一下node_[0][0]这个节点的代价如何计算的，node_[0][0]的cost = alpha_[0 + 0] + alpha_[3 + 0] = alpha_[0] + alpha_[3]，由于alpha_第一次节点初始化为0，所以cost=0。其余节点和边计算方法类似。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;前向-后向算法&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　有了无向图，我们就可以在图上进行前向-后向算法。利用前向-后向算法，很容易计算标记序列在位置i（词）的label是y&lt;sub&gt;i&lt;/sub&gt;的条件概率，以及在位置i-1（前一个词）与位置i（当前词）的label是y&lt;sub&gt;i-1&lt;/sub&gt;与y&lt;sub&gt;i&lt;/sub&gt;的条件概率。进行CRF++源码阅读之前先看一下条件随机场矩阵的表示形式。对一个句子的每一个位置（单词） i=1,2,…，n+1，定义一个 m 阶矩阵（m 是标记 yi 取值的个数），i=0代表start节点， i=n+1代表stop节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{aligned}  M_i(x) &amp;amp;= \left \{  M_i(y_{i-1},y_i|x)\right \} \\ M_i(y_{i-1},y_i|x)&amp;amp;= \exp  \left \{ W_i(y_{i-1} ,y_i|x)\right \}\\ W_i(y_{i-1},y_i|x)&amp;amp;= \sum_{k=1}^Kw_k \cdot f_k(y_{i-1},y_i,x,i) \end{aligned}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{align} f_k(y_{i-1},y_i,x,i) = \left \{ \begin{aligned}  &amp;amp;t_k(y_{i-1},y_i,x,i), \ \ k = 1,2,...,K_1 \\ &amp;amp;s_t(y_i,x,i), \ \ \  \ \ \ \ \  \ \  k = K_1 + l ; l = 1,2,...,K_2 \end{aligned}\right. \end{align}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;W&lt;sub&gt;i &lt;/sub&gt;的解释&lt;/strong&gt;：当前节点代价 + 与该节点相连的一条边的代价。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;节点之间的转移概率，用矩阵的形式表现如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{aligned} M_1(x) &amp;amp;= \begin{bmatrix} M_1(0,0|x) &amp;amp; M_1(0,1|x)  &amp;amp;M_1(0,2|x) \\ 0 &amp;amp; 0  &amp;amp;0 \\ 0 &amp;amp; 0  &amp;amp;0  \end{bmatrix} \\ \\ M_2(x) &amp;amp;=\begin{bmatrix} M_2(0,0|x) &amp;amp; M_2(0,1|x) &amp;amp; M_2(0,2|x)\\  M_2(1,0|x) &amp;amp; M_2(1,1|x) &amp;amp; M_2(1,2|x)\\  M_2(2,0|x) &amp;amp; M_2(2,1|x) &amp;amp; M_2(2,2|x) \end{bmatrix} \\ \\ M_i(x) \ &amp;amp;\mathbf{has \ the \ same \ form \  with} \ M_2(X), \ i = 3,...,n\\ \\ M_{n+1}(x) &amp;amp;=\begin{bmatrix}  1 &amp;amp; 0 &amp;amp; 0 \\   1 &amp;amp; 0 &amp;amp; 0  \\   1&amp;amp;0&amp;amp;0  \end{bmatrix} \\ \end{aligned}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;M&lt;sub&gt;i&lt;/sub&gt; 的解释&lt;/strong&gt;：以 \begin{aligned} M_2(2,1|x) \end{aligned} 为例，代表第2个位置（第2个词）label是1，前一个词label是2，计算W&lt;sub&gt;i&lt;/sub&gt;，再取exp后的值。接下来，&lt;/span&gt;&lt;span&gt;我们看一下用矩阵表示的前向-后向算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对i = 0, 1, 2, ... n+1， 定义前向向量α&lt;sub&gt;i&lt;/sub&gt;(x)，对于起始状态i = 0：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{align} \alpha_0(y|x) = \left \{ \begin{aligned}  &amp;amp;1, \ \ y = start \\ &amp;amp;0, \ \ else \end{aligned}\right. \end{align}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于之后的状态 i=1,2,...,n+1，递推公式为：&lt;span id=&quot;MathJax-Element-7-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;i&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2026;&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;n&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;+&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{aligned} a_i^T(y_i|x) = a^T_{i-1}(y_{i-1}|x)M_i(y_{i-1},y_i|x) \end{aligned}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;假设label个数是m，α是m*1的列向量，M&lt;sub&gt;i&lt;/sub&gt;(y&lt;sub&gt;i-1&lt;/sub&gt;,y&lt;sub&gt;i&lt;/sub&gt;|x) 是m*m的矩阵，&lt;strong&gt;α解释&lt;/strong&gt;：前一个单词每个节点的α分别乘以（与当前节点相连的边的代价 + 当前节点的代价），再求和&lt;/span&gt; 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样，后向算法β计算， 对于i = 0, 1, 2, ..., n+1，定义后向向量β&lt;sub&gt;i&lt;/sub&gt;(x)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{align} \beta_{n+1}(y_{n+1}|x) = \left \{ \begin{aligned}  &amp;amp;1, \ \ y_{n+1} = stop \\ &amp;amp;0, \ \ else \end{aligned}\right. \end{align}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;向前递推公式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{aligned} \beta_i(y_i|x) = M_i(y_i,y_{i+1}|x)\beta_{i+1}(y_{i+1}|x) \end{aligned}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;β&lt;sub&gt;i&lt;/sub&gt;是m*1的列向量， M&lt;sub&gt;i&lt;/sub&gt;(y&lt;sub&gt;i&lt;/sub&gt;,y&lt;sub&gt;i+1&lt;/sub&gt;|x)是m*m的矩阵。&lt;strong&gt;β解释&lt;/strong&gt;：（当前词与下一个词连接的边的代价 + 下一个词的代价） 分别乘以下一个词的β，再相加。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由前向-后向向量定义不难得到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{aligned} Z(x) = a_n^T(x) \cdot \mathbf{1} = \mathbf{1}^T \cdot \beta_1(x) \end{aligned}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;需要注意一下，矩阵表示形式的代价是对特征函数乘以权重加和后再取exp的值， 而上面的CRF++ calcCost函数中并没有取exp值。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来继续看下α和β在CRF++中是如何计算的。在gradient函数中调用的forwardbackward函数即是这部分的核心代码，具体如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47.223909848114&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; TaggerImpl::forwardbackward() {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (x_.empty()) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }

  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; static_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(x_.size()); ++&lt;span&gt;i) { //前向算法
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; ysize_; ++&lt;span&gt;j) {
      node_[i][j]&lt;/span&gt;-&amp;gt;&lt;span&gt;calcAlpha();
    }
  }

  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = static_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(x_.size() - &lt;span&gt;1&lt;/span&gt;); i &amp;gt;= &lt;span&gt;0&lt;/span&gt;;  --&lt;span&gt;i) { //后向算法
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; ysize_; ++&lt;span&gt;j) {
      node_[i][j]&lt;/span&gt;-&amp;gt;&lt;span&gt;calcBeta();
    }
  }

  Z_ &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; ysize_; ++&lt;span&gt;j) { //计算Z(x)
    Z_ &lt;/span&gt;= logsumexp(Z_, node_[&lt;span&gt;0&lt;/span&gt;][j]-&amp;gt;beta, j == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Node::calcAlpha() {
  alpha &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (const_Path_iterator it = lpath.begin(); it != lpath.end(); ++&lt;span&gt;it) { //这里遍历当前节点的左边(path)的集合， 对应的就是M&lt;sub&gt;i&lt;/sub&gt;(y&lt;sub&gt;i-1&lt;/sub&gt;,y&lt;sub&gt;i&lt;/sub&gt;|x)矩阵中的某一列
    alpha &lt;/span&gt;=&lt;span&gt; logsumexp(alpha,
                      (&lt;/span&gt;*it)-&amp;gt;cost +(*it)-&amp;gt;lnode-&amp;gt;&lt;span&gt;alpha,
                      (it &lt;/span&gt;==&lt;span&gt; lpath.begin()));  //函数里面回取exp，因此边的代价 + 上一个节点的α，会转化成相乘，取完exp还会再取log，&lt;strong&gt;取log为了方式直接exp导致的溢出&lt;/strong&gt;
  }
  alpha &lt;/span&gt;+=&lt;span&gt; cost; //统一加上当前节点的代价， Mi(yi-1,yi|x)每列中每个元素都加了当前节点的代价， 只不过CRF++是在后面统一加上
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Node::calcBeta() { //与上面类似
  beta &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (const_Path_iterator it = rpath.begin(); it != rpath.end(); ++&lt;span&gt;it) {
    beta &lt;/span&gt;=&lt;span&gt; logsumexp(beta,
                     (&lt;/span&gt;*it)-&amp;gt;cost +(*it)-&amp;gt;rnode-&amp;gt;&lt;span&gt;beta,
                     (it &lt;/span&gt;==&lt;span&gt; rpath.begin()));
  }
  beta &lt;/span&gt;+=&lt;span&gt; cost; //&lt;span&gt;这里需要注意&lt;/span&gt;，在矩阵的推导过程中，没有加当前节点的代价，但是CRF++里面加了， 后续我们会看到有一个减当前节点代价的一段代码
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; log(exp(x) + exp(y));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    this can be used recursivly
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g., log(exp(log(exp(x) + exp(y))) + exp(z)) =
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; log(exp (x) + exp(y) + exp(z))&lt;br/&gt;// 这部分取log的操作是为了防止直接取exp溢出，具体的解释以及推导参考 &lt;em&gt;&lt;a href=&quot;http://www.hankcs.com/ml/computing-log-sum-exp.html&quot; target=&quot;_blank&quot;&gt;计算指数函数的和的对数&lt;/a&gt;&lt;/em&gt;&lt;br/&gt;&lt;/span&gt;inline &lt;span&gt;double&lt;/span&gt; logsumexp(&lt;span&gt;double&lt;/span&gt; x, &lt;span&gt;double&lt;/span&gt; y, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; flg) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (flg) &lt;span&gt;return&lt;/span&gt; y;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; init mode&lt;/span&gt;
  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; vmin =&lt;span&gt; std::min(x, y);
  &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; vmax =&lt;span&gt; std::max(x, y);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (vmax &amp;gt; vmin +&lt;span&gt; MINUS_LOG_EPSILON) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; vmax;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; vmax + std::log(std::exp(vmin - vmax) + &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;阅读完上述代码会发现，这里的α计算除了没有对最终结果取exp以外，跟上面矩阵推导的α计算是一样的。可以利用矩阵方法和CRF++的算法具体算一下α或β的值，对比一下理解的会更深， 这个过程并不复杂。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 概率计算&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　有了α和β，就可以进行条件概率和期望的计算。一个句子在位置i的label是y&lt;sub&gt;i&lt;/sub&gt;的条件概率，以及在位置i-1与位置i标记为y&lt;sub&gt;i-1&lt;/sub&gt;与y&lt;sub&gt;i&lt;/sub&gt;的概率：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{aligned}  P(Y_i= y_i|x) &amp;amp;= \frac{a_i^T(y_i|x) \beta_i(y_i|x)}{Z(x)} \\ P(Y_{i-1} = y_{i-1} ,Y_i= y_i|x) &amp;amp;=\frac{a_{i-1}^T(y_{i-1}|x)M_i(y_{i-1},y_i|x)\beta_i(y_i|x)}{Z(x)} \end{aligned}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个式子可以说是节点的概率，第二个式子是节点之间边的概率。有了条件概率，就可以计算特征函数f&lt;sub&gt;k &lt;/sub&gt;关于条件分布 P(Y|X) 的数学期望是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{aligned}  E_{p(Y|X)}[f_k] &amp;amp;= \sum_yP(y|x)f_k(y,x) \\ &amp;amp;=\sum_{i=1}^{n+1}\sum_{y_{i-1}\ y_i}f_k(y_{i-1},y_i,x,i) \frac{a_{i-1}^TM_i(y_{i-1},y_i|x)\beta_i(y_i|x)}{Z(x)} \end{aligned}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算特征函数的期望是因为后续计算梯度的时候会用到。这里，如果f&lt;sub&gt;k&lt;/sub&gt;是unigram特征（状态特征），对应的条件概率是节点的概率， 如果是bigram特征（转移特征），条件概率就是边的概率。继续看下CRF++中是如何计算条件概率和特征函数的期望的，代码在gradient函数中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;;   i &amp;lt; x_.size(); ++&lt;span&gt;i) { //遍历每一个节点的，遍历计算每个节点和每条边上的特征函数，计算每个特征函数的期望
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; ysize_; ++&lt;span&gt;j) {
      node_[i][j]&lt;/span&gt;-&amp;gt;&lt;span&gt;calcExpectation(expected, Z_, ysize_);
    }
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Node::calcExpectation(&lt;span&gt;double&lt;/span&gt; *expected, &lt;span&gt;double&lt;/span&gt; Z, size_t size) &lt;span&gt;const&lt;/span&gt;&lt;span&gt; { //&lt;strong&gt;状态特征的期望
  &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; c = std::exp(alpha + beta - cost -&lt;span&gt; Z); //这里减去一个多余的cost，剩下的就是上面提到的节点的概率值 P(Y&lt;sub&gt;i&lt;/sub&gt;=y&lt;sub&gt;i&lt;/sub&gt; | x)，这里已经取了exp，跟矩阵形式的计算结果一致
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *f = fvector; *f != -&lt;span&gt;1&lt;/span&gt;; ++&lt;span&gt;f) { 
    expected[&lt;/span&gt;*f + y] +=&lt;span&gt; c;           //这里会把所有节点的相同状态特征函数对应的节点概率相加，特征函数值*概率再加和便是期望。由于特征函数值为1，所以直接加概率值
  }
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (const_Path_iterator it = lpath.begin(); it != lpath.end(); ++&lt;span&gt;it) { //&lt;strong&gt;转移特征的期望&lt;/strong&gt;
    (&lt;/span&gt;*it)-&amp;gt;&lt;span&gt;calcExpectation(expected, Z, size);
  }
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Path::calcExpectation(&lt;span&gt;double&lt;/span&gt; *expected, &lt;span&gt;double&lt;/span&gt; Z, size_t size) &lt;span&gt;const&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; c = std::exp(lnode-&amp;gt;alpha + cost + rnode-&amp;gt;beta -&lt;span&gt; Z); //这里计算的是上面提到的边的条件概率P(Y&lt;sub&gt;i-1&lt;/sub&gt;=y&lt;sub&gt;i-1&lt;/sub&gt;,Y&lt;sub&gt;i=&lt;/sub&gt;y&lt;sub&gt;i&lt;/sub&gt;|x)，这里取了exp，跟矩阵形式的计算结果一致
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *f = fvector; *f != -&lt;span&gt;1&lt;/span&gt;; ++&lt;span&gt;f) { 
    expected[&lt;/span&gt;*f + lnode-&amp;gt;y * size + rnode-&amp;gt;y] +=&lt;span&gt; c; //这里把所有边上相同的转移特征函数对应的概率相加
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，CRF++中前后-后向算法、条件概率计算以及特征函数的期望便介绍完毕，接下来看看如何计算似然函数值和梯度。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;计算梯度&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　条件随机场的训练，我们这里主要看CRF++中应用的LBFGS算法。先做简单的推导， 再结合实际的CRF++源码去理解。条件随机场模型如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{aligned} P_w(y|x) = \frac{\exp \left \{ \sum_{k=1}^K w_kf_k(x,y)\right \}}{ \sum_y  \left \{ \exp \sum_{i=1}^n w_if_i(x,y)\right \}} \end{aligned}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{aligned} f_k(y,x) = \sum_{i=1}^nf_k(y_{i-1},y_i,x,i), k=1,2,...,K \end{aligned}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;训练函数的对数似然如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{aligned}  L(w) &amp;amp;=  \log \prod_{t}P_w(y^t|x^t) \\ &amp;amp;= \sum_{t} \log P_w(y^t|x^t) \\ &amp;amp;= \sum_{t} \left \{ \sum_{k=1}^Kw_kf_k(y^t,x^t)-\log Z_w(x) \right \}   \end{aligned}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t代表所有的训练样本， 一般使用m来表示，但是上面已经把m给用了， 为了避免歧义， 我们用t来表示训练样本。我们求似然函数最大值来求解最优参数w，同时也可以对似然函数加负号，通过求解最小值来求最优的w。这里我们与CRF++保持一致，将似然函数取负号，再对w&lt;/span&gt;&lt;span&gt;&lt;span&gt;j&lt;span&gt;求导，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;推导如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\begin{aligned}  \frac{\partial L(w)}{\partial w_j} &amp;amp;= \sum_{t} \left \{ \frac{\sum_y  \left \{ f_i(x^t,y^t)\exp \sum_{i=1}^K w_if_i(x^t,y)\right \}}{Z_w(x)} - f_j(y^t,x^t) \right \} \\ &amp;amp;= \sum_{t} \left \{ \sum_y P(y|x^t)f_j(y, x^t) - f_j(y^t,x^t) \right \} \\ &amp;amp;= \sum_{t} \left \{ E_{P(y|x)}[f_j(y,x)] - f_j(y^t,x^t) \right \} \end{aligned}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一个句子来说，特征函数的期望减去特征函数真实值就是我们要计算的梯度，Σ&lt;sub&gt;t &lt;/sub&gt;代表对所有句子求和得到最终的梯度。接下来看下CRF++中是如何实现的，代码还是在gradient函数中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;;   i &amp;lt; x_.size(); ++i) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历每一个位置（词）&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *f = node_[i][answer_[i]]-&amp;gt;fvector; *f != -&lt;span&gt;1&lt;/span&gt;; ++f) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;answer_[i]代表当前样本的label，遍历每个词当前样本label的特征，进行减1操作，遍历所有节点减1就相当于公式中fj(y,x)&lt;/span&gt;
      --expected[*f + answer_[i]]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;状态特征函数期望减去真实的状态特征函数值&lt;/span&gt;
&lt;span&gt;    }
    s &lt;/span&gt;+= node_[i][answer_[i]]-&amp;gt;cost;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; UNIGRAM cost 节点的损失求和&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; std::vector&amp;lt;Path *&amp;gt; &amp;amp;lpath = node_[i][answer_[i]]-&amp;gt;&lt;span&gt;lpath;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (const_Path_iterator it = lpath.begin(); it != lpath.end(); ++it) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历边，对转移特征做类似计算&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; ((*it)-&amp;gt;lnode-&amp;gt;y == answer_[(*it)-&amp;gt;lnode-&amp;gt;&lt;span&gt;x]) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *f = (*it)-&amp;gt;fvector; *f != -&lt;span&gt;1&lt;/span&gt;; ++&lt;span&gt;f) {
          &lt;/span&gt;--expected[*f +(*it)-&amp;gt;lnode-&amp;gt;y * ysize_ +(*it)-&amp;gt;rnode-&amp;gt;y]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;转移特征函数期望减去真实转移特征函数值&lt;/span&gt;
&lt;span&gt;        }
        s &lt;/span&gt;+= (*it)-&amp;gt;cost;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; BIGRAM COST  边损失求和&lt;/span&gt;
        &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      }
    }
  }
viterbi();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; call for eval() 调用维特比算法做预测，为了计算分类错误的次数，算法详细内容下篇介绍&lt;/span&gt;

&lt;span&gt;return&lt;/span&gt; Z_ - s ;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回似然函数值，看L(w)推导的最后一步，大括号内有两项，其中一项是logZw(x)，我们知道变量Z_是没有取exp的结果，我们要求这一项需要先对Z_取exp，取exp再取log相当于还是Z_，因此 logZw(x) = Z_
                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再看另一项，是对当前样本代价求和，正好这一项是没有取exp的因此该求和项就等于s， 之前说过CRF++是对似然函数取负号，因此返回Z_ - s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 至此，一个句子的似然函数值和梯度就计算完成了。公式的Σ&lt;sub&gt;t&lt;/sub&gt; 是对所有句子求和，CRF++的求和过程是在run函数调用gradient函数结束后由线程内汇总，然后所有线程结束后再汇总。runCRF函数剩下的代码便是所有线程完成一轮计算后的汇总逻辑，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; thread_num; ++&lt;span&gt;i) { //汇总每个线程的数据
      thread[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].obj +=&lt;span&gt; thread[i].obj; //似然函数值
      thread[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].err +=&lt;span&gt; thread[i].err; 
      thread[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].zeroone +=&lt;span&gt; thread[i].zeroone; 
    }

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; thread_num; ++&lt;span&gt;i) {
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; feature_index-&amp;gt;size(); ++&lt;span&gt;k) { 
        thread[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].expected[k] +=&lt;span&gt; thread[i].expected[k]; //梯度值求和
      }
    }

    size_t num_nonzero &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (orthant) {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L1 根据L1或L2正则化，更新似然函数值&lt;/span&gt;
      &lt;span&gt;for&lt;/span&gt; (size_t k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; feature_index-&amp;gt;size(); ++&lt;span&gt;k) {
        thread[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].obj += std::abs(alpha[k] /&lt;span&gt; C);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (alpha[k] != &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;) {
          &lt;/span&gt;++&lt;span&gt;num_nonzero;
        }
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; { //L2
      num_nonzero &lt;/span&gt;= feature_index-&amp;gt;&lt;span&gt;size();
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; feature_index-&amp;gt;size(); ++&lt;span&gt;k) {
        thread[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].obj += (alpha[k] * alpha[k] /(&lt;span&gt;2.0&lt;/span&gt; *&lt;span&gt; C));
        thread[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].expected[k] += alpha[k] /&lt;span&gt; C;
      }
    }

    ...省略代码
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lbfgs.optimize(feature_index-&amp;gt;&lt;span&gt;size(),
                       &lt;/span&gt;&amp;amp;alpha[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;],
                       thread[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].obj,
                       &lt;/span&gt;&amp;amp;thread[&lt;span&gt;0&lt;/span&gt;].expected[&lt;span&gt;0&lt;/span&gt;], orthant, C) &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) { //传入似然函数值和梯度等参数，调用LBFGS算法
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最终调用LBFGS算法更新w，CRF++中的LBFGS算法最终是调用的Fortran语言编译后的C代码，可读性比较差，本篇文章暂时不深入介绍。至此，一次迭代的计算过程便介绍完毕。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;通过这篇文章的介绍，已经了解到了CRF++如何构建无向图、如何计算代价、如何进行前向-后向算法、如何计算特征函数的期望以及如何计算梯度。写这篇文章耗时最长，花了整整一天的时间。力求这篇文章通俗易懂，理论结合实践。希望能够把条件随机场这个比较枯燥的算法诠释好。文中有可能仍然有表达不通顺或者表达不通俗的地方，甚至可能会有表达错误的地方，如果存在上述问题欢迎评论区留言，我将第一时间更新。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 28 Jan 2019 11:21:00 +0000</pubDate>
<dc:creator>渡码</dc:creator>
<og:description>上篇的CRF++源码阅读中， 我们看到CRF++如何处理样本以及如何构造特征。本篇文章将继续探讨CRF++的源码，并且本篇文章将是整个系列的重点，会介绍条件随机场中如何构造无向图、前向后向算法、如何计</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/duma/p/10325724.html</dc:identifier>
</item>
<item>
<title>数据结构与算法 - 图的邻接表 （思想以及实现方式） - CMusketeer</title>
<link>http://www.cnblogs.com/cmusketeer/p/10331450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmusketeer/p/10331450.html</guid>
<description>&lt;h3 id=&quot;9011-1548667804340&quot;&gt;PS：邻接表，存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的&lt;a&gt;存储结构&lt;/a&gt;。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。图的邻接表储存方式相对于邻接矩阵比较节约空间，对于邻接矩阵需要分别把顶点和边（顶点之间的关系）用一维数组和二维数组储存起来。而邻接表则是把顶点按照顺序储存到一维数组中，然后再通过链式方式，把有关系的顶点下标链接到后方，咱们先不考虑权重问题，结构体定义简单一点，当然加上权值也不难。下方看图解释。&lt;/h3&gt;
&lt;h3&gt;邻接表&lt;/h3&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;有向图&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;无向图&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;h3 id=&quot;4791-1548668350227&quot;&gt;逆邻接表&lt;/h3&gt;

&lt;h3&gt;邻接表实现步骤&lt;/h3&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;结构体&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;创建图&lt;/span&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;顶点和边数，顶点需要用一维数组保存&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;获取顶点的下标，因为链接结点中的index域是顶点的下标值。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;创建结点，通过头插法（或尾插法）把结点链接到头结点的尾部&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;打印（遍历方式后序介绍）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以分为头和表结构，如图所示&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258190/201901/1258190-20190128185835609-1993511757.png&quot; alt=&quot;&quot; width=&quot;747&quot; height=&quot;195&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;8.5&quot;&gt;
&lt;h3&gt;那么结构体就可以这样设计&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
* 表头连接的表中结点定义
* &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; tableBody {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; vexIndex;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邻接点在数组中的位置下标&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; tableBody *nextarc;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向下一个邻接点的指针&lt;/span&gt;
&lt;span&gt;} tableBody;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 表头结点定义
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; tableHead {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; data;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;顶点的数据域&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; tableBody *firstarc;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向邻接点的指针&lt;/span&gt;
} tableHead, *tableHeadArr;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储各链表头结点的数组&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;*图-邻接表定义&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    tableHead vertices[&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图中顶点及各邻接点数组&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; vexnum, arcnum;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录图中顶点数和边或弧数&lt;/span&gt;
} LJBGraph;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;内部注释涵盖了上述步骤。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; createGraph(LJBGraph *&lt;span&gt;g) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总顶点个数，总边数&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, j, k;
    tableBody &lt;/span&gt;*&lt;span&gt;tb;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入顶点数和边数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;g-&amp;gt;vexnum, &amp;amp;g-&amp;gt;arcnum);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取顶点数和边数
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gettchar();&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; g-&amp;gt;vexnum; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; c;
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入%d 个顶点值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
        getchar();
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;c);
        g&lt;/span&gt;-&amp;gt;vertices[i].data = c;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取顶点值，&lt;/span&gt;
        g-&amp;gt;vertices[i].firstarc = NULL;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将边表置为空&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; g-&amp;gt;arcnum; k++&lt;span&gt;) {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入a,b 在图中有a--&amp;gt;b:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        getchar();
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; a,b;
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c %c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;a, &amp;amp;b);               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入i,j 在图中有i--&amp;gt;j&lt;/span&gt;
        tb = (tableBody *) &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(tableBody));
        i&lt;/span&gt;=localIndex(g,a); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;a顶点所在顶点数组中的下标值。&lt;/span&gt;
        j=localIndex(g,b); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b顶点所在数组中的下标值。&lt;/span&gt;
        tb-&amp;gt;vexIndex =&lt;span&gt; j;
        tb&lt;/span&gt;-&amp;gt;nextarc = g-&amp;gt;vertices[i].firstarc;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头插法建立边表&lt;/span&gt;
        g-&amp;gt;vertices[i].firstarc = tb;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把新建的结点链接在顶点后面&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;如果为无向图，则加入以下代码
                e=(EdgeNode*)malloc(sizeof(EdgeNode));
                e-&amp;gt;adjvex = i;
                e-&amp;gt;next = g-&amp;gt;adjList[j].firstedge;
                g-&amp;gt;adjList[j].firstedge= e;&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
    printfL(g);
    DFSTraverse(g);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;寻找下标值，就是普通的遍历，在顶点数组中遍历返回下标。&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; localIndex(LJBGraph *g,&lt;span&gt;char&lt;/span&gt;&lt;span&gt; data){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;g-&amp;gt;vexnum;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(g-&amp;gt;vertices[i].data ==&lt;span&gt; data){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        }
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有这个字符&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;所得有向图和无向图的结构图不一样&lt;/h3&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258190/201901/1258190-20190128190046628-593200009.png&quot; alt=&quot;&quot; width=&quot;827&quot; height=&quot;469&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258190/201901/1258190-20190128190135664-1271954497.png&quot; alt=&quot;&quot; width=&quot;827&quot; height=&quot;450&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;6&quot;&gt;

&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; printfL(LJBGraph *&lt;span&gt;g) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出图的信息&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;表为 :\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    tableBody &lt;/span&gt;*&lt;span&gt;p;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邻接表不需要表标题。&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; g-&amp;gt;vexnum; i++&lt;span&gt;) {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%c\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(i),g-&amp;gt;vertices[i].data);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表头结点&lt;/span&gt;
        p = g-&amp;gt;&lt;span&gt;vertices[i].firstarc;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (p) {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, p-&amp;gt;vexIndex);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;外表结点&lt;/span&gt;
            p = p-&amp;gt;nextarc;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;外表结点下移&lt;/span&gt;
&lt;span&gt;        }
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;9067-1548670571622&quot;&gt;主方法&lt;/h2&gt;
&lt;p&gt;是不是代码很简单，所有东西都封装起来。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    LJBGraph &lt;/span&gt;*&lt;span&gt;g;
    createGraph(g);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;7041-1548670984164&quot;&gt;注：比较邻接矩阵和邻接表的区别&lt;/h3&gt;
&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr align=&quot;center&quot;&gt;&lt;td&gt;&lt;span&gt;存储结构&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;储存方式&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;操作特性&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;&lt;span&gt;邻接矩阵&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;一维数组（顶点）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二维数组（邻接关系）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;1：易于判定顶点是否邻接，查顶点的邻接点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2：插入、删除顶点复杂&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;&lt;span&gt;邻接表&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;头结点（顶点）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表结点（邻接关系）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;1&lt;span&gt;：易于：查询某顶点的邻接点，边或弧的插入、删除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2：判定顶点是否邻接，比邻接矩阵低效。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;







&lt;div id=&quot;2176-1548670595367&quot; readability=&quot;7&quot;&gt;

&lt;h3&gt;所谓逆邻接表就是方向相反的链接到顶点后面，一看图便知。&lt;/h3&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258190/201901/1258190-20190128190840606-552282615.png&quot; alt=&quot;&quot; width=&quot;722&quot; height=&quot;397&quot;/&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h3&gt;完：&lt;/h3&gt;
&lt;h3&gt;下一篇讲会讲解深度优先遍历和广度优先遍历基本使用和思想。&lt;/h3&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 28 Jan 2019 11:12:00 +0000</pubDate>
<dc:creator>CMusketeer</dc:creator>
<og:description>PS：邻接表，存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的存储结构。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。图的邻接表储存方式相</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmusketeer/p/10331450.html</dc:identifier>
</item>
</channel>
</rss>