<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>find cat sed awk 简单组合使用 - 西瓜_太郎</title>
<link>http://www.cnblogs.com/Q-Meo/p/10171691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Q-Meo/p/10171691.html</guid>
<description>
&lt;h2&gt;find：查找&lt;/h2&gt;
&lt;p&gt;// .表示当前目录；   /表示根目录；  | 管道符；  xargs表示将前面的搜索接口作为参数传递到后面的命令中；grep 过滤&lt;/p&gt;
&lt;p&gt;// xxxx表示文件名&lt;/p&gt;
&lt;p&gt;1.查找指定文件名的文件&lt;/p&gt;
&lt;p&gt;find . -name xxxx    // 区分大小写&lt;/p&gt;
&lt;p&gt;find . -iname xxxx   // 不区分大小写&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224232543648-36941116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.查找当前目录中文件名后缀为 .json的所有文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;find . -type f -name '*.json'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.查找当前目录下所有文件夹&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;find . -type d&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.查找当前目录1小时内被修改的文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;find . -cmin -60 // 单位: 分钟&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-a 表示前后条件都满足&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-o 表示前后条件满足一条即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224233229040-2095929408.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.查找当前目录中包含 function 字符串的文件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;find . | xargs grep function&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.查找文件名包含 function 字符串的文件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;find . -type f -name '*function*'&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.查找3天前创建的后缀为.function的文件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;find . -type f -name '*.function' -ctime +3&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.查找3天前创建的后缀为.function的文件并删除&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;find . -type f -name '*.function' -ctime +3 | xargs rm -r&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;awk：切分列&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;// xxxx 是被操作的文件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.查看某文件指定列数的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;awk '{print $1}' xxxx&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224231423708-921635101.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;sed：切分行&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;// &lt;span&gt;xxxx 是当前被操作的文件&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.查看某文件指定列数的内容&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;sed -n 'startLine, endLinep' xxxx&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224231549180-229781990.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;cat：查看&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;// xxxx 是当前要查看的文件名&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.查看文件内容cat&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cat xxxx&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.查看带行数的内容&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cat -n xxxx 或 cat -b xxxx&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224231808074-810233152.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.统计文件中去重复后的行数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;cat xxxx | sort | uniq | wc -l      // sort 排序  // uniq去除重复&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4.获取指定列内容 awk 切分列 $num 表示第几列&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// num 表示想获取的列数&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cat xxxx | awk '{print $num}'&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 写进新文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cat xxxx | awk '{print $num}' &amp;gt; xxxx_new&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.获取指定行数内容 sed 切分行  -n 表示行数  startline 起始行数  endline 截止行数&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cat xxxx |  sed -n 'startline,endlinep' // 最后的p不能丢&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 写进新文件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cat xxxx |  sed -n 'startline,endlinep' &amp;gt; xxxx_new // 最后的p不能丢&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.将指定列指定行数的内容放入新文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// awk 切分列  $ 后面的数字表示第几列&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// sed 切分行  -n 表示行数  startline 起始行数  endline 截止行数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;cat xxxx | awk '{print $num}' | sed -n 'startline,endlinep' &amp;gt; xxxx_new&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;获取指定进程的ID&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.ps -ef | grep down 获取包含指定进程的信息，第二列就是进程ID&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224225956469-1261026494.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2.ps -ef | grep down | grep -v grep  过滤grep本身&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224230109550-431898415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.获取指定进程的进程ID 两种方式，结果一样&lt;/p&gt;
&lt;p&gt;ps -ef | grep down | grep -v grep | awk '{print $2}'  或 ps -ef | grep down |  awk '{print $2}' | sed -n '1, 1p'&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224230326396-472745079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1431683/201812/1431683-20181224230502899-822463726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 15:36:00 +0000</pubDate>
<dc:creator>西瓜_太郎</dc:creator>
<og:description>find：查找 // .表示当前目录； /表示根目录； | 管道符； xargs表示将前面的搜索接口作为参数传递到后面的命令中；grep 过滤 // xxxx表示文件名 1.查找指定文件名的文件 fi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Q-Meo/p/10171691.html</dc:identifier>
</item>
<item>
<title>单元测试框架之unittest(三) - davieyang</title>
<link>http://www.cnblogs.com/davieyang/p/10162469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davieyang/p/10162469.html</guid>
<description>&lt;h2&gt;一、摘要&lt;/h2&gt;
&lt;p&gt;前边的文章我们看到执行测试用例的是通过调用unittest.mian()函数，它会将模块的测试用例收集起来并执行，然而当我们的测试用例增多了以后，这样的执行非常不灵活而且没有效率，我们更愿意看到自由组合的一组用例，只执行这组用例的方式，unittest.TestSuite能够满足我们这个需求，笔者将一random类作为被测试类来详细展示unittest.TestSuite&lt;/p&gt;
&lt;h2&gt;二、代码示例&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;以前的执行方式&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; encoding = utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestRandomFunction(unittest.TestCase):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        self.str &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abcdef!@#$%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_randomchoice(self):
        var &lt;/span&gt;=&lt;span&gt; random.choice(self.str)
        self.assertTrue(var &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.str)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(var)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_randomsample(self):
        with self.assertRaises(ValueError):
            random.sample(self.str, &lt;/span&gt;100&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; var &lt;span&gt;in&lt;/span&gt; random.sample(self.str, 6&lt;span&gt;):
            self.assertTrue(var &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.str)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(var)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestRandomShuffleFunction(unittest.TestCase):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        self.list &lt;/span&gt;= [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13&lt;span&gt;]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_randomshuffle(self):
        random.shuffle(self.list)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.list)
        self.list.sort()
        self.assertEqual(self.list, [&lt;/span&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13&lt;span&gt;])


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    unittest.main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;方式一  使用unittest.TestLoader，它可以通过传给他的参数获取测试用例的测试方法，然后再组合成TestSuite，最后在将TestSuite传递给TestRunner  完成我们所期望的执行组合&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; encoding = utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestRandomFunction(unittest.TestCase):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        self.str &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abcdef!@#$%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_randomchoice(self):
        var &lt;/span&gt;=&lt;span&gt; random.choice(self.str)
        self.assertTrue(var &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.str)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(var)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_randomsample(self):
        with self.assertRaises(ValueError):
            random.sample(self.str, &lt;/span&gt;100&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; var &lt;span&gt;in&lt;/span&gt; random.sample(self.str, 6&lt;span&gt;):
            self.assertTrue(var &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.str)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(var)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestRandomShuffleFunction(unittest.TestCase):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        self.list &lt;/span&gt;= [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13&lt;span&gt;]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_randomshuffle(self):
        random.shuffle(self.list)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.list)
        self.list.sort()
        self.assertEqual(self.list, [&lt;/span&gt;1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13&lt;span&gt;])


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; unittest.main()&lt;/span&gt;
    testcase1 =&lt;span&gt; unittest.TestLoader().loadTestsFromTestCase(TestRandomFunction)
    testcase2 &lt;/span&gt;=&lt;span&gt; unittest.TestLoader().loadTestsFromTestCase(TestRandomShuffleFunction)
    suite &lt;/span&gt;=&lt;span&gt; unittest.TestSuite([testcase1, testcase2])
    unittest.TextTestRunner(verbosity&lt;/span&gt;=2).run(suite)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; 方式二 另创建一个.py文件，定义suite方法，使用unittest.TestSuite().addTest(测试类（测试方法）)&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; encoding = utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; unittest3.TestSuiteDemo2 &lt;span&gt;import&lt;/span&gt; *


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; suite():
    suite &lt;/span&gt;=&lt;span&gt; unittest.TestSuite()
    suite.addTest(TestRandomFunction(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_randomchoice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    suite.addTest(TestRandomShuffleFunction(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test_randomshuffle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; suite


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    runner &lt;/span&gt;=&lt;span&gt; unittest.TextTestRunner()
    runner.run(suite())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt; 方式三 另创建一个.py文件，使用unittest.TestLoader().discover(“路径”，“匹配文件名”)&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; encoding = utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    suite &lt;/span&gt;= unittest.TestLoader().discover(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, pattern=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TestSuiteDemo1.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    unittest.TextTestRunner(verbosity&lt;/span&gt;=2).run(suite)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 24 Dec 2018 15:21:00 +0000</pubDate>
<dc:creator>davieyang</dc:creator>
<og:description>一、摘要 前边的文章我们看到执行测试用例的是通过调用unittest.mian()函数，它会将模块的测试用例收集起来并执行，然而当我们的测试用例增多了以后，这样的执行非常不灵活而且没有效率，我们更愿意</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/davieyang/p/10162469.html</dc:identifier>
</item>
<item>
<title>CUBA 使用 Spring 查询接口 - CUBA-China</title>
<link>http://www.cnblogs.com/cubacn/p/cuba-query.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cubacn/p/cuba-query.html</guid>
<description>&lt;p&gt;原文链接：&lt;span&gt;&lt;a href=&quot;https://www.cuba-platform.com/blog/spring-query-interfaces-in-cuba&quot;&gt;https://www.cuba-platform.com/blog/spring-query-interfaces-in-cuba&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;翻译：&lt;/span&gt;CUBA China&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CUBA-Platform 官网 :&lt;/span&gt; &lt;a href=&quot;https://www.cuba-platform.com&quot;&gt;&lt;span&gt;https://www.cuba-platform.com&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CUBA China 官网 : &lt;span&gt;&lt;a href=&quot;http://cuba-platform.cn&quot;&gt;http://cuba-platform.cn&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根本原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　开发人员通常不喜欢改变他们编码的习惯。当我刚开始接触&lt;/span&gt; &lt;a href=&quot;https://www.cuba-platform.com/&quot;&gt;&lt;span&gt;CUBA&lt;/span&gt;&lt;/a&gt; 的时候，发现不需要学很多新的东西，创建应用程序的过程也是非常顺利的。但是其中有一样是需要重新学习的，那就是如何使用数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;Spring框架中，有好几个库可以用来处理数据，其中最流行的一个就是 &lt;a href=&quot;https://docs.spring.io/spring-data/jpa/docs/current/reference/html/&quot;&gt;&lt;span&gt;spring-data-jpa&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，使用这个库可以使开发人员在很多情况下避免编写&lt;/span&gt;SQL或者JPQL。只需要创建一个接口类，然后在接口中创建  &lt;a href=&quot;https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repository-query-keywords&quot;&gt;&lt;span&gt;&lt;span&gt;带有特殊名称&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;的方法，&lt;/span&gt;Spring会自动帮你创建和执行查询语句。&lt;/p&gt;
&lt;p&gt;　　比如，这里有一个接口，其中有个方法是数数有多少客户是同一个姓的：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193042135-403384064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以直接将这个接口注入到&lt;/span&gt;service中，然后就可以在需要的地方调用这个方法了（注意，不需要写实现类）。&lt;/p&gt;
&lt;p&gt;　　CUBA提供了很多开箱即用的数据操控方法，比如加载实体的部分属性以及成熟的数据安全子系统 - 可以限制数据访问权限至实体属性和表数据的行级别。并且这些所有的功能都带有API，但是跟大家都知道的Spring Data或者JPA/Hibernate的略有不同。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以，为什么在&lt;/span&gt;CUBA中没有上面说的查询接口？有没有可能添加呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CUBA中使用数据的方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　CUBA的API中有三个主要的类用来处理数据：DataStore，EntityManager 和 DataManager。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/data_store.html&quot;&gt;DataStore&lt;/a&gt;&lt;/span&gt; &lt;span&gt;的抽象是提供处理持久化存储的&lt;/span&gt;API，比如RDBMS，文件系统或者云存储。可以通过DataStore执行基本的数据操作，但是，不推荐直接使用DataStore，除非需要开发自定义的持久化存储或者需要对底层存储进行非常特殊的访问。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/entityManager.html&quot;&gt;EntityManager&lt;/a&gt;&lt;/span&gt; &lt;span&gt;很大程度上只是&lt;/span&gt;JPA EntityManager 的拷贝，但是有额外的方法用来处理 &lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/views.html&quot;&gt;&lt;span&gt;CUBA视图&lt;/span&gt;&lt;/a&gt;&lt;span&gt;、软删除以及&lt;/span&gt; &lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/query.html?_ga=2.26406845.1445638773.1545295201-2145930198.1545295201&quot;&gt;&lt;span&gt;CUBA 查询语句&lt;/span&gt;&lt;/a&gt;&lt;span&gt;。作为&lt;/span&gt;CUBA开发人员，很少在日常工作中使用这个类，除非需要克服CUBA的安全限制。&lt;/p&gt;
&lt;p&gt;　　下一个要说的，&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/dataManager.html&quot;&gt;&lt;span&gt;DataManager&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，是在&lt;/span&gt;CUBA中处理数据主要使用的类。此类提供了处理数据的API并且支持到属性和行级别的 &lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/dm_security.html&quot;&gt;&lt;span&gt;CUBA安全模型&lt;/span&gt;&lt;/a&gt; &lt;span&gt;。当查询数据的时候，&lt;/span&gt;DataManager会隐式的修改查询语句。比如，在关系型数据库中，它会更改“select”语句，排除那些受限的属性，然后自动添加“where”语句来筛选那些当前用户不能看到的数据行。这种安全感知的行为是很有帮助的，开发人员不需要死记在查询语句中需要添加哪些关于安全方面的条件。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里有个&lt;/span&gt;CUBA类交互的图，展示使用DataManager从RDBMS中获取数据的过程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193125761-2033937489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用&lt;/span&gt;DataManager可以相对容易的查询实体（或者使用CUBA视图查询实体层级结构）。最简单的查询是这样：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193153736-1962536901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　DataManager会自己过滤掉“软删除”的记录、受限制访问的实体属性或实体，也会自己创建数据库事务。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是如果需要执行带有复杂&lt;/span&gt;“where”条件的查询语句，就需要写JPQL了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　看看最开头那个例子，如果需要按姓统计客户人数，在&lt;/span&gt;CUBA中需要写这样的：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193216197-2008955927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里可以看到，需要将&lt;/span&gt;JPQL语句丢给DataManager去执行。在CUBA API里，JPQL需要用字符串来定义（目前还不支持Criteria API&lt;span&gt;）。&lt;/span&gt;JPQL有很好的可读性，也能清晰的定义一个查询语句，但是如果出问题，可能不是很好调试。另外，JPQL字符串不像Criteria API那样能在构建编译时进行验证，或者在Spring上下文初始化的时候验证。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　比较一下&lt;/span&gt;Spring Data JPA 的接口：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193239105-973922918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个接口只有三分之一的代码量而且不包含任何显式的字符串。此外，&lt;/span&gt;countByLastName 方法会在部署阶段验证。如果方法名敲错了，比如，敲成 countByLastNome，则会有异常抛出：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193301772-1518567698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于&lt;/span&gt;CUBA也是基于Spirng框架构建的，所以可以将Spring-data-jpa添加为CUBA项目的依赖库然后使用这个功能。唯一的问题，Spring的查询接口底层使用JPA的EntityManager，所以查询语句不会被CUBA的EntityManager或者DataManager处理。因此，需要找到合适的方法在CUBA中添加查询接口 - 需要自定义，所有调用EntityManager的地方都需要用CUBA的DataManager相应的方法替换，并且添加对CUBA视图的支持。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　也有人会说，使用&lt;/span&gt;Spring的方案不如CUBA的方案可控，因为不能控制生成查询语句的过程。这是在便利性和抽象化级别之间的平衡问题，需要开发者决定到底使用那个方案。但是有个额外的处理数据的简单方法总是没坏处，尽管这也不是唯一的方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果需要更多的控制，&lt;/span&gt;Spring里也有方法为接口&lt;a href=&quot;https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query&quot;&gt;&lt;span&gt;&lt;span&gt;指定查询语句&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，所以这个方法也需要添加到&lt;/span&gt;CUBA。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实施&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　查询接口使用&lt;/span&gt; &lt;a href=&quot;https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/&quot;&gt;&lt;span&gt;spring-data-commons&lt;/span&gt;&lt;/a&gt; &lt;span&gt;实现，构建为&lt;/span&gt;CUBA应用程序组件。这个库包含实现自定义查询接口的类，比如，Spring的&lt;a href=&quot;https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/&quot;&gt;&lt;span&gt;spring-data-mongodb&lt;/span&gt;&lt;/a&gt; &lt;span&gt;库就是基于这个实现的。&lt;/span&gt;Spring-data-commons利用代理技术来为声明式查询接口创建正确的实现。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;CUBA的上下文初始化期间，查询接口的引用都会被生成的代理bean隐式替换。当开发人员调用接口方法时，相应的代理会进行拦截。然后代理根据方法名称生成JPQL查询，替换参数值，并交给DataManager执行。下图展示了模块关键组件之间的简单交互过程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193336003-1085451496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;在&lt;/span&gt;CUBA中使用查询接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　需要在项目的构建文件中添加新的应用程序组件才能使用&lt;/span&gt;CUBA的查询接口：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193401254-66504660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　XML配置文件也需要修改启用查询接口：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193424684-1429395698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果习惯使用注解而不是创建&lt;/span&gt;XML配置文件，可以用下面的方法启用查询接口：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193445825-845957290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　启用查询接口后，可以在应用程序中创建并使用。下面是示例：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193509192-1984357187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以在接口方法上使用&lt;/span&gt; @CubaView 和 @JpqlQuery 注解。第一个注解定义需要使用的&lt;a href=&quot;https://doc.cuba-platform.com/manual-6.10/views.html?_ga=2.135316529.1445638773.1545295201-2145930198.1545295201&quot;&gt;&lt;span&gt;&lt;span&gt;视图&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;（如果没有使用这个注解默认使用&lt;/span&gt;“_local”视图）。第二个注解是用来设置JPQL的，用在查询语句不能通过&lt;a href=&quot;https://docs.spring.io/spring-data/data-commons/docs/current/reference/html/#repository-query-keywords&quot;&gt;&lt;span&gt;&lt;span&gt;方法名表示&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;的时候。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　查询接口的应用程序组件是绑定到&lt;/span&gt;CUBA的“global”模块，所以可以在“core”和“web”模块定义和使用查询接口，只是别忘了在相应的配置文件中启用接口。接口使用的示例：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193531109-6048947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　CUBA很灵活。如果觉得需要为应用程序添加新的功能，又不想等CUBA的新版本，很容易在不修改CUBA核心的情况下实施并添加到项目中。通过为CUBA添加查询接口，我们希望能帮助开发人员更加有效的工作，更快的交付可靠的代码。这个库的第一个版本可以在&lt;a href=&quot;https://github.com/cuba-rnd/cuba-jpa-repositories&quot;&gt;&lt;span&gt;GitHub&lt;/span&gt;&lt;/a&gt;&lt;span&gt;找到，目前支持&lt;/span&gt;CUBA 6.10和更高版本。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438872/201812/1438872-20181222193553747-800135619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Mon, 24 Dec 2018 15:15:00 +0000</pubDate>
<dc:creator>CUBA-China</dc:creator>
<og:description>原文链接：https://www.cuba-platform.com/blog/spring-query-interfaces-in-cuba 翻译：CUBA China CUBA-Platform</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cubacn/p/cuba-query.html</dc:identifier>
</item>
<item>
<title>年终总结，我为什么离开舒适区？ - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10171587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10171587.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;　　当圣诞夜过去，也意味着这一年即将结束，迎来崭新的开始，一年时间既短暂，又漫长，当离开人生的舒适区，将迎来一个又一个的挑战。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        如果说一个人的优秀，取决于他天赋，以及他为之付出的额外努力，那么问一问自己，是否真的认真的付出了吗？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        回顾2018，前大半段时间，为了某大型国企的信息化建设项目，付出了非常多的努力，但是却没能获得足够令人满意的收获，总体而言，觉得还是努力的不够。主要原因依然在于，低估了项目的难度，而高估了自己的能力。也许表面上看，似乎能够把事情妥善的处理，但是却实际上已经无法真的能够方方面面考虑周全。当事情压到身上时，不足以应对所有的挑战，最终已经完全没有任何办法。制造业信息化项目，作为一个充分竞争的市场，也许从表面上看，依然是一个充满机遇的大市场，或许有很多机会去尝试新的挑战，包括制造业与信息化相结合等多种不同的方式，以及通过物联网技术与制造业相结合的方式，完成制造业大数据平台的建设，都是非常主流的概念，但是却没有看破迷雾。尤其是参加了岳麓峰会工业互联网专场之后，反而对这个行业充满了质疑，看到一群所谓的互联网业者跨界而来，款款而谈所谓的工业app，说得再多也不过是笑谈而已。难道工业互联网，不过是那些互联网业者们炒作的概念吗？&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       我片面的认为，IT技术时代，本质上来说，依然是靠技术来驱动，也许谈不上改变时代，却至少应该给时代带来便利。而传统行业的制造业，已经经历了几十年的发展，实际上已经有大量优秀的企业了。根本不是短期的投入就可以实现弯道超车的，更需要一个正规团队，持续不断的努力才可以，往往需要至少三年才能看出成效来。这支团队，分工明确，共同面对未知的挑战才行。带头人固然重要，却终究只是一个人，唯有实现一加一大于二的目标，也许才有一线生机。我们团队也没办法招到更多拥有专业制造业的领域专家，只能靠自己去梳理业务，整理知识体系，独立的设计业务流程、领域模型、乃至核心代码的编写，每件事都需要真正用心去思考，这同样也意味着，个人的错误反而容易被无限放大。再看长沙数量众多的制造业信息化软件企业，依然停留在温饱的水平，也许老板们利益丰厚，却是在小市场独自过着自己小而美的生活。当然必须承认，也许越是闭塞的行业越有希望赚到温饱的钱，但是却也更容易让人陷入其中不可自拔，甚至也许让你产生舒适区的错觉而沉溺。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        下半段，选择了互联网公司，加入了一家奋斗者为伍的公司，看到大家为了打造更加完善的产品而奋勇拼搏时，也深刻意识到自己的不足。遽然想起，2012年，曾经在HT公司技术部开会的时候提到过这一点，却最终沦为大家的笑柄。这几年来，其实自己也放弃了奋斗者的格言，成为舒适区里的温水青蛙。 舒适区，容易让人放弃目标，迷惑自己。来到互联网公司，意味着离开了舒适区，也开始了新的发展方向。选择IT，意味着终生学习。要明白眼前的短暂安逸，不过是迷惑人心的温床，只有执着的坚持自我，才能获得属于自己的成功。尤其是软件开发领域，一定要持续五年以上、勤劳不辍的努力才能真正掌握应对各种环境下的挑战。也许从传统开发行业来说，靠某些技术的堆积，可以快速的完成项目，却不足以让人真正的掌握技术的内涵。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         技术者最忌讳的，其实是所谓云程序员。你以为你什么都懂，但是正儿八经的用起来，不过哑弹一枚。因为你只是了解一点点皮毛而已。必须承认，知道皮毛，不过是大道三千，你只是记住了书名而已，其实什么用都没有。最关键的，不是浮于表面，而是深入核心用心的去领悟和思考，只有这样才能掌控自己的知识体系。但是真正的工程师，往往必须真正掌握一种属于自己的知识体系。弱水三千 ，先取一瓢饮。如果广度太广，反而成为一种负担。因此，无论是项目开发也好，产品开发也罢，都应该把时间花在学习技术本源之中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         回顾职场，实际上已经走在了云程序员这条错误的路上，进入了空谈主义的错误路线。无论是微服务也好，或者领域驱动也好，都成为扩充知识体系的一部分，固然储备了技术，却反而可能形成错误的观点，即，看什么都很简单，其实根本就不是这样的。甚至也许反而容易丢掉了最本质的东西，那就是，工程师精神。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        工程师精神才是最值得尊重的宝贵财富，再多的空谈，也不如一段优秀的代码，一个精心设计的算法或业务流程，或者一个精心考究的技术方案。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        作为工程师，应该坚持以技术为准绳，时刻以提升产品品质为目标，以提升产品用户体验为目标，把用户的需求放在基本面上，这一点，其实不管是哪种公司都一样。技术思维，项目思维，产品思维，都是工程师赖以为生的法宝。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        竹子用了4年的时间，仅仅长了3厘米。从第5年开始，以每天30厘米的速度疯狂地生长，仅仅用了6周的时间就长到了15米。其实，在前面的4年，竹子将根在土壤里延伸了数百平米。 做人做事都是这样。不要担心此刻的付出没有回报，熬过三厘米，才能一飞冲天。也不要自责时间的逝去，总是难以一次性把事情做对的话，至少走在了正确的道路上，也是一种积累。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       要坚信一点，你此刻的沉沦和沉淀，都会像熏肉一般，一点一点熏进你的灵魂。他们将为你铺路，或把你埋葬，或让你登顶。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        自省。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 15:15:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>年终总结，我为什么离开舒适区？ 当圣诞夜过去，也意味着这一年即将结束，迎来崭新的开始，一年时间既短暂，又漫长，当离开人生的舒适区，将迎来一个又一个的挑战。 如果说一个人的优秀，取决于他天赋，以及他为之</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10171587.html</dc:identifier>
</item>
<item>
<title>ML.NET教程之出租车车费预测(回归问题) - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10171481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10171481.html</guid>
<description>&lt;p&gt;出租车的车费不仅与距离有关，还涉及乘客数量，是否使用信用卡等因素(这是的出租车是指纽约市的)。所以并不是一个简单的一元方程问题。&lt;/p&gt;

&lt;p&gt;建立一控制台应用程序工程，新建&lt;code&gt;Data&lt;/code&gt;文件夹，在其目录下添加&lt;a href=&quot;https://github.com/dotnet/machinelearning/blob/master/test/data/taxi-fare-train.csv&quot;&gt;taxi-fare-train.csv&lt;/a&gt;与&lt;a href=&quot;https://github.com/dotnet/machinelearning/blob/master/test/data/taxi-fare-test.csv&quot;&gt;taxi-fare-test.csv&lt;/a&gt;文件，不要忘了把它们的&lt;code&gt;Copy to Output Directory&lt;/code&gt;属性改为&lt;code&gt;Copy if newer&lt;/code&gt;。之后，添加Microsoft.ML类库包。&lt;/p&gt;

&lt;p&gt;新建MLContext对象，及创建TextLoader对象。TextLoader对象可用于从文件中读取数据。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;MLContext mlContext = new MLContext(seed: 0);

_textLoader = mlContext.Data.TextReader(new TextLoader.Arguments()
{
    Separator = &quot;,&quot;,
    HasHeader = true,
    Column = new[]
    {
        new TextLoader.Column(&quot;VendorId&quot;, DataKind.Text, 0),
        new TextLoader.Column(&quot;RateCode&quot;, DataKind.Text, 1),
        new TextLoader.Column(&quot;PassengerCount&quot;, DataKind.R4, 2),
        new TextLoader.Column(&quot;TripTime&quot;, DataKind.R4, 3),
        new TextLoader.Column(&quot;TripDistance&quot;, DataKind.R4, 4),
        new TextLoader.Column(&quot;PaymentType&quot;, DataKind.Text, 5),
        new TextLoader.Column(&quot;FareAmount&quot;, DataKind.R4, 6)
    }
});&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;数据集文件里共有七列，前六列做为特征数据，最后一列是标记数据。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class TaxiTrip
{
    [Column(&quot;0&quot;)]
    public string VendorId;

    [Column(&quot;1&quot;)]
    public string RateCode;

    [Column(&quot;2&quot;)]
    public float PassengerCount;

    [Column(&quot;3&quot;)]
    public float TripTime;

    [Column(&quot;4&quot;)]
    public float TripDistance;

    [Column(&quot;5&quot;)]
    public string PaymentType;

    [Column(&quot;6&quot;)]
    public float FareAmount;
}

public class TaxiTripFarePrediction
{
    [ColumnName(&quot;Score&quot;)]
    public float FareAmount;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;首先读取训练数据集，其次建立管道。管道中第一步是把&lt;code&gt;FareAmount&lt;/code&gt;列复制到&lt;code&gt;Label&lt;/code&gt;列，做为标记数据。第二步，通过OneHotEncoding方式将&lt;code&gt;VendorId&lt;/code&gt;，&lt;code&gt;RateCode&lt;/code&gt;，&lt;code&gt;PaymentType&lt;/code&gt;三个字符串类型列转换成数值类型列。第三步，合并六个数据列为一个特征数据列。最后一步，选择FastTreeRegressionTrainer算法做为训练方法。&lt;br/&gt;完成管道后，开始训练模型。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;IDataView dataView = _textLoader.Read(dataPath);
var pipeline = mlContext.Transforms.CopyColumns(&quot;FareAmount&quot;, &quot;Label&quot;)
    .Append(mlContext.Transforms.Categorical.OneHotEncoding(&quot;VendorId&quot;))
    .Append(mlContext.Transforms.Categorical.OneHotEncoding(&quot;RateCode&quot;))
    .Append(mlContext.Transforms.Categorical.OneHotEncoding(&quot;PaymentType&quot;))
    .Append(mlContext.Transforms.Concatenate(&quot;Features&quot;, &quot;VendorId&quot;, &quot;RateCode&quot;, &quot;PassengerCount&quot;, &quot;TripTime&quot;, &quot;TripDistance&quot;, &quot;PaymentType&quot;))
    .Append(mlContext.Regression.Trainers.FastTree());
var model = pipeline.Fit(dataView);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这里要使用测试数据集，并用回归问题的&lt;code&gt;Evaluate&lt;/code&gt;方法进行评估。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;IDataView dataView = _textLoader.Read(_testDataPath);
var predictions = model.Transform(dataView);
var metrics = mlContext.Regression.Evaluate(predictions, &quot;Label&quot;, &quot;Score&quot;);
Console.WriteLine();
Console.WriteLine($&quot;*************************************************&quot;);
Console.WriteLine($&quot;*       Model quality metrics evaluation         &quot;);
Console.WriteLine($&quot;*------------------------------------------------&quot;);
Console.WriteLine($&quot;*       R2 Score:      {metrics.RSquared:0.##}&quot;);
Console.WriteLine($&quot;*       RMS loss:      {metrics.Rms:#.##}&quot;);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;完成训练的模型可以被保存为zip文件以备之后使用。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using (var fileStream = new FileStream(_modelPath, FileMode.Create, FileAccess.Write, FileShare.Write))
    mlContext.Model.Save(model, fileStream);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;首先加载已经保存的模型。接着建立预测函数对象，&lt;code&gt;TaxiTrip&lt;/code&gt;为函数的输入类型，&lt;code&gt;TaxiTripFarePrediction&lt;/code&gt;为输出类型。之后执行预测方法，传入待测数据。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;ITransformer loadedModel;
using (var stream = new FileStream(_modelPath, FileMode.Open, FileAccess.Read, FileShare.Read))
{
    loadedModel = mlContext.Model.Load(stream);
}

var predictionFunction = loadedModel.MakePredictionFunction&amp;lt;TaxiTrip, TaxiTripFarePrediction&amp;gt;(mlContext);

var taxiTripSample = new TaxiTrip()
{
    VendorId = &quot;VTS&quot;,
    RateCode = &quot;1&quot;,
    PassengerCount = 1,
    TripTime = 1140,
    TripDistance = 3.75f,
    PaymentType = &quot;CRD&quot;,
    FareAmount = 0 // To predict. Actual/Observed = 15.5
};

var prediction = predictionFunction.Predict(taxiTripSample);

Console.WriteLine($&quot;**********************************************************************&quot;);
Console.WriteLine($&quot;Predicted fare: {prediction.FareAmount:0.####}, actual fare: 15.5&quot;);
Console.WriteLine($&quot;**********************************************************************&quot;);&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using Microsoft.ML;
using Microsoft.ML.Core.Data;
using Microsoft.ML.Runtime.Data;
using System;
using System.IO;

namespace TexiFarePredictor
{
    class Program
    {
        static readonly string _trainDataPath = Path.Combine(Environment.CurrentDirectory, &quot;Data&quot;, &quot;taxi-fare-train.csv&quot;);
        static readonly string _testDataPath = Path.Combine(Environment.CurrentDirectory, &quot;Data&quot;, &quot;taxi-fare-test.csv&quot;);
        static readonly string _modelPath = Path.Combine(Environment.CurrentDirectory, &quot;Data&quot;, &quot;Model.zip&quot;);
        static TextLoader _textLoader;

        static void Main(string[] args)
        {
            MLContext mlContext = new MLContext(seed: 0);

            _textLoader = mlContext.Data.TextReader(new TextLoader.Arguments()
            {
                Separator = &quot;,&quot;,
                HasHeader = true,
                Column = new[]
                {
                    new TextLoader.Column(&quot;VendorId&quot;, DataKind.Text, 0),
                    new TextLoader.Column(&quot;RateCode&quot;, DataKind.Text, 1),
                    new TextLoader.Column(&quot;PassengerCount&quot;, DataKind.R4, 2),
                    new TextLoader.Column(&quot;TripTime&quot;, DataKind.R4, 3),
                    new TextLoader.Column(&quot;TripDistance&quot;, DataKind.R4, 4),
                    new TextLoader.Column(&quot;PaymentType&quot;, DataKind.Text, 5),
                    new TextLoader.Column(&quot;FareAmount&quot;, DataKind.R4, 6)
                }
            });

            var model = Train(mlContext, _trainDataPath);

            Evaluate(mlContext, model);

            TestSinglePrediction(mlContext);

            Console.Read();
        }

        public static ITransformer Train(MLContext mlContext, string dataPath)
        {
            IDataView dataView = _textLoader.Read(dataPath);
            var pipeline = mlContext.Transforms.CopyColumns(&quot;FareAmount&quot;, &quot;Label&quot;)
                .Append(mlContext.Transforms.Categorical.OneHotEncoding(&quot;VendorId&quot;))
                .Append(mlContext.Transforms.Categorical.OneHotEncoding(&quot;RateCode&quot;))
                .Append(mlContext.Transforms.Categorical.OneHotEncoding(&quot;PaymentType&quot;))
                .Append(mlContext.Transforms.Concatenate(&quot;Features&quot;, &quot;VendorId&quot;, &quot;RateCode&quot;, &quot;PassengerCount&quot;, &quot;TripTime&quot;, &quot;TripDistance&quot;, &quot;PaymentType&quot;))
                .Append(mlContext.Regression.Trainers.FastTree());
            var model = pipeline.Fit(dataView);
            SaveModelAsFile(mlContext, model);
            return model;
        }

        private static void SaveModelAsFile(MLContext mlContext, ITransformer model)
        {
            using (var fileStream = new FileStream(_modelPath, FileMode.Create, FileAccess.Write, FileShare.Write))
                mlContext.Model.Save(model, fileStream);
        }

        private static void Evaluate(MLContext mlContext, ITransformer model)
        {
            IDataView dataView = _textLoader.Read(_testDataPath);
            var predictions = model.Transform(dataView);
            var metrics = mlContext.Regression.Evaluate(predictions, &quot;Label&quot;, &quot;Score&quot;);
            Console.WriteLine();
            Console.WriteLine($&quot;*************************************************&quot;);
            Console.WriteLine($&quot;*       Model quality metrics evaluation         &quot;);
            Console.WriteLine($&quot;*------------------------------------------------&quot;);
            Console.WriteLine($&quot;*       R2 Score:      {metrics.RSquared:0.##}&quot;);
            Console.WriteLine($&quot;*       RMS loss:      {metrics.Rms:#.##}&quot;);
        }

        private static void TestSinglePrediction(MLContext mlContext)
        {
            ITransformer loadedModel;
            using (var stream = new FileStream(_modelPath, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                loadedModel = mlContext.Model.Load(stream);
            }

            var predictionFunction = loadedModel.MakePredictionFunction&amp;lt;TaxiTrip, TaxiTripFarePrediction&amp;gt;(mlContext);

            var taxiTripSample = new TaxiTrip()
            {
                VendorId = &quot;VTS&quot;,
                RateCode = &quot;1&quot;,
                PassengerCount = 1,
                TripTime = 1140,
                TripDistance = 3.75f,
                PaymentType = &quot;CRD&quot;,
                FareAmount = 0 // To predict. Actual/Observed = 15.5
            };

            var prediction = predictionFunction.Predict(taxiTripSample);

            Console.WriteLine($&quot;**********************************************************************&quot;);
            Console.WriteLine($&quot;Predicted fare: {prediction.FareAmount:0.####}, actual fare: 15.5&quot;);
            Console.WriteLine($&quot;**********************************************************************&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序运行后显示的结果：&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;*************************************************
*       Model quality metrics evaluation
*------------------------------------------------
*       R2 Score:      0.92
*       RMS loss:      2.81
**********************************************************************
Predicted fare: 15.7855, actual fare: 15.5
**********************************************************************&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后的预测结果还是比较符合实际数值的。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 14:56:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>理解问题 出租车的车费不仅与距离有关，还涉及乘客数量，是否使用信用卡等因素(这是的出租车是指纽约市的)。所以并不是一个简单的一元方程问题。 准备数据 建立一控制台应用程序工程，新建 文件夹，在其目录下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10171481.html</dc:identifier>
</item>
<item>
<title>Java线程入门第二篇 - 布尔bl</title>
<link>http://www.cnblogs.com/chenzhuantou/p/10171479.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhuantou/p/10171479.html</guid>
<description>&lt;h2&gt;Java线程通信方法&lt;/h2&gt;
&lt;p&gt;0、(why)每个线程都有自己的栈空间，我们要线程之间进行交流，合作共赢。&lt;/p&gt;
&lt;p&gt;1、synchronized和volatile关键字&lt;/p&gt;
&lt;p&gt;　　a)  看下面的synchronized关键字&lt;/p&gt;
&lt;p&gt;　　b)  看下面的volatile关键字&lt;/p&gt;
&lt;p&gt;2、等待/通知机制：一个线程A调用对象的wait（）方法，另一个线程调用线程B的notity（）或者的notifyall（）方法.&lt;/p&gt;
&lt;p&gt;　　a)  顺序打印奇数偶数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPrintDemo2 {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        final ThreadPrintDemo2 demo2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPrintDemo2();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java8新特性&lt;/span&gt;
        Thread t1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(demo2 :: print1);
        Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(demo2 :: print2);
        t1.start();
        t2.start();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;   synchronized &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print2() {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;100&lt;/span&gt;; i +=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(i);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.notify();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知等待中的进程&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.wait();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程进入等待&lt;/span&gt;
                Thread.sleep(&lt;span&gt;100&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防止打印速度过快导致混乱&lt;/span&gt;
            } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NO&lt;/span&gt;
&lt;span&gt;            }
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print1() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span&gt;100&lt;/span&gt;; i += &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(i);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.notify();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知等待中的进程&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.wait();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程进入等待&lt;/span&gt;
                Thread.sleep(&lt;span&gt;100&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防止打印速度过快导致混乱&lt;/span&gt;
            } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NO&lt;/span&gt;
&lt;span&gt;            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　b) 打印连续句子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPrintDemo2 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[]{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;};

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        final ThreadPrintDemo2 demo2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPrintDemo2();
        Thread t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(demo2::print1);
        Thread t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(demo2::print2);
        t1.start();
        t2.start();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print2() {

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; arr.length; i +=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.print(arr[i]);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.notify();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.wait();
                Thread.sleep(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防止打印速度过快导致混乱&lt;/span&gt;
            } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NO&lt;/span&gt;
&lt;span&gt;            }
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print1() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; arr.length; i +=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.print(arr[i]);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.notify();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.wait();
                Thread.sleep(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防止打印速度过快导致混乱&lt;/span&gt;
            } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NO&lt;/span&gt;
&lt;span&gt;            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：a bcde&lt;/p&gt;
&lt;p&gt;3、管道输入输出流：pipedreader和pipedwriter 面向字符&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　Pipedoutputstream和pipedinputstream面向字节&lt;/p&gt;
&lt;p&gt;4、使用thread.join()方法：利用线程等待特性&lt;/p&gt;
&lt;p&gt;5、使用ThreadLocal线程变量&lt;/p&gt;
&lt;h2&gt;Synchronize关键字（重量级锁）&lt;/h2&gt;
&lt;p&gt;1、基础：Java中每一个对象都可以作为锁&lt;/p&gt;
&lt;p&gt;2、手段：确保多线程在同一时刻，只有一个线程处于方法或同步块中&lt;/p&gt;
&lt;p&gt;3、实现原理：JVM基于进入和退出monitor对象来实现方法同步和代码块同步&lt;/p&gt;
&lt;p&gt;4、锁优化：jdk1.6之后优化了锁，加入了偏向锁和轻量级锁，锁可以升级但不能降级&lt;/p&gt;
&lt;p&gt;5、使用场景：方法  代码块&lt;/p&gt;
&lt;h2&gt;Lock接口&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181224224336363.png&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;30&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、他是一个接口&lt;/p&gt;
&lt;p&gt;2、使用的时候需要显式获取锁&lt;/p&gt;
&lt;p&gt;3、使用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Lock &lt;span&gt;lock&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    
}&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.unlock();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、Synchronized经常与Lock放在一起比较&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181224224808770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTg5MzgzMDg5Njg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;867&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Volatile&lt;/h2&gt;
&lt;p&gt;1、是什么：（what）是轻且量级的synchronize，保证共享变量的可见性（一个线程修改一个共享变量的时候，另一个线程会知道），并他不会引起线程的上下文切换和调度。&lt;/p&gt;
&lt;p&gt;2、使用场景：修饰变量&lt;/p&gt;
&lt;p&gt;3、优化：在1.7中将共享变量追加了60个字节，变成64个字节。因为（硬件）目前流行的cpu的高速缓存行是64个字节，当队列的头尾节点不足64字节时候，处理器会将他们读到同一个缓存行，并且锁定缓存行。这样会影响队列出队入队效率。&lt;/p&gt;
&lt;h2&gt;ThreadLoacl类（线程变量）&lt;/h2&gt;
&lt;p&gt;为每个线程变量创建一个该变量的副本，避免并发访问的线程安全问题，保证线程安全&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 14:51:00 +0000</pubDate>
<dc:creator>布尔bl</dc:creator>
<og:description>Java线程通信方法 0、(why)每个线程都有自己的栈空间，我们要线程之间进行交流，合作共赢。 1、synchronized和volatile关键字 a) 看下面的synchronized关键字 b</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenzhuantou/p/10171479.html</dc:identifier>
</item>
<item>
<title>FutureTask简单实战 - flylinran</title>
<link>http://www.cnblogs.com/flylinran/p/10171449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flylinran/p/10171449.html</guid>
<description>&lt;h2 id=&quot;futuretask是什么&quot;&gt;FutureTask是什么？&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;线程池的实现核心之一是FutureTask。在提交任务时，用户实现的Callable实例task会被包装为FutureTask实例ftask；提交后任务异步执行，无需用户关心；当用户需要时，再调用FutureTask#get()获取结果——或异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本使用&quot;&gt;基本使用&lt;/h2&gt;
&lt;p&gt;方法中可能会调用到多个服务/方法，且这些服务/方法之间是互相独立的，不存在先后关系。在高并发场景下，如果执行比较耗时，可以考虑多线程异步的方式调用。&lt;/p&gt;
&lt;h3 id=&quot;我们先模拟两个耗时服务&quot;&gt;我们先模拟两个耗时服务&lt;/h3&gt;
&lt;p&gt;一个&lt;strong&gt;150ms&lt;/strong&gt;，一个&lt;strong&gt;200ms&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UserApi {

    /** 查询用户基本信息，模拟耗时150ms */
    public String queryUserInfo(long userId) {
        String userInfo = &quot;userInfo: &quot; + userId;

        try {
            TimeUnit.MILLISECONDS.sleep(150L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return userInfo;
    }

    /** 查询用户地址，模拟耗时200ms */
    public String queryUserAddress(long userId) {
        String userAddress = &quot;userAddress: &quot; + userId;

        try {
            TimeUnit.MILLISECONDS.sleep(200L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return userAddress;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;不使用futuretask&quot;&gt;不使用FutureTask&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void testNotUseFutureTask() {
    UserApi userApi = new UserApi();

    long userId = 12;
    long startTime = System.currentTimeMillis();

    // 获取用户基本信息
    String userInfo = userApi.queryUserInfo(userId);
    // 获取用户地址
    String userAddress = userApi.queryUserAddress(userId);

    System.err.println(&quot;testNotUseFutureTask 耗时：&quot; + (System.currentTimeMillis() - startTime));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行几次，结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;testNotUseFutureTask 耗时：358
testNotUseFutureTask 耗时：360&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果中，可以看到，总耗时是大于&lt;code&gt;queryUserInfo&lt;/code&gt;和&lt;code&gt;queryUserAddress&lt;/code&gt;之和的。但这两个服务逻辑上并不存在先后关系，理论上最长耗时取决于最慢的那个，即&lt;code&gt;queryUserAddress&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用futuretask&quot;&gt;使用FutureTask&lt;/h3&gt;
&lt;p&gt;下例使用了&lt;code&gt;FutureTask&lt;/code&gt;，来异步调用&lt;code&gt;queryUserInfo&lt;/code&gt;和&lt;code&gt;queryUserAddress&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void testUseFutureTask() throws ExecutionException, InterruptedException {
    UserApi userApi = new UserApi();

    long userId = 12;
    long startTime = System.currentTimeMillis();

    Callable&amp;lt;String&amp;gt; userInfoCallable = new Callable&amp;lt;String&amp;gt;() {
        @Override
        public String call() throws Exception {
            return userApi.queryUserInfo(userId);
        }
    };
    Callable&amp;lt;String&amp;gt; userAddressCallable = new Callable&amp;lt;String&amp;gt;() {
        @Override
        public String call() throws Exception {
            return userApi.queryUserAddress(userId);
        }
    };
    FutureTask&amp;lt;String&amp;gt; userInfoFutureTask = new FutureTask&amp;lt;&amp;gt;(userInfoCallable);
    FutureTask&amp;lt;String&amp;gt; userAddressFutureTask = new FutureTask&amp;lt;&amp;gt;(userAddressCallable);

    new Thread(userInfoFutureTask).start();
    new Thread(userAddressFutureTask).start();

    String userInfo = userInfoFutureTask.get();
    String userAddress = userAddressFutureTask.get();
    System.err.println(&quot;testUseFutureTask 耗时：&quot; + (System.currentTimeMillis() - startTime));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行几次，结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;testUseFutureTask 耗时：239
testUseFutureTask 耗时：237&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显，总耗时大大减少了，这就验证了前面所说，总耗时取决于&lt;code&gt;queryUserAddress&lt;/code&gt;的耗时。&lt;/p&gt;
&lt;h3 id=&quot;实现一个简单的futuretask&quot;&gt;实现一个简单的FutureTask&lt;/h3&gt;
&lt;p&gt;从前面使用FutureTask的代码中可以看到，一个FutureTask需要包含以下几点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、范型
2、构造函数，传入Callable
3、实现Runnable
4、有返回值&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;MyFutureTask&lt;/code&gt;代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyFutureTask&amp;lt;T&amp;gt; implements Runnable {

    private Callable&amp;lt;T&amp;gt; callable;
    private T           result;
    private String      state;

    public MyFutureTask(Callable&amp;lt;T&amp;gt; callable) {
        this.callable = callable;
    }

    @Override
    public void run() {
        state = &quot;NEW&quot;;
        try {
            result = callable.call();
        } catch (Exception e) {
            e.printStackTrace();
        }
        state = &quot;DONE&quot;;
        synchronized (this) {
            this.notify();
        }
    }

    /** 获取调用结果 */
    public T get() throws InterruptedException {
        if (&quot;DOEN&quot;.equals(state)) {
            return result;
        }
        synchronized (this) {
            this.wait();
        }
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void testMyUseFutureTask() throws InterruptedException {
    UserApi userApi = new UserApi();

    long userId = 12;
    long startTime = System.currentTimeMillis();

    Callable&amp;lt;String&amp;gt; userInfoCallable = new Callable&amp;lt;String&amp;gt;() {
        @Override
        public String call() throws Exception {
            return userApi.queryUserInfo(userId);
        }
    };
    Callable&amp;lt;String&amp;gt; userAddressCallable = new Callable&amp;lt;String&amp;gt;() {
        @Override
        public String call() throws Exception {
            return userApi.queryUserAddress(userId);
        }
    };
    
    // 不同点
    MyFutureTask&amp;lt;String&amp;gt; userInfoFutureTask = new MyFutureTask&amp;lt;&amp;gt;(userInfoCallable);
    MyFutureTask&amp;lt;String&amp;gt; userAddressFutureTask = new MyFutureTask&amp;lt;&amp;gt;(userAddressCallable);

    new Thread(userInfoFutureTask).start();
    new Thread(userAddressFutureTask).start();

    String userInfo = userInfoFutureTask.get();
    String userAddress = userAddressFutureTask.get();
    System.err.println(&quot;testMyUseFutureTask 耗时：&quot; + (System.currentTimeMillis() - startTime));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;输出结果：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;testMyUseFutureTask 耗时：208
testMyUseFutureTask 耗时：211&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果中看到，预期与使用&lt;code&gt;FutureTask&lt;/code&gt;的一致。至于使用我们自定义的&lt;code&gt;MyFutureTask&lt;/code&gt;执行耗时为何会比&lt;code&gt;FutureTask&lt;/code&gt;长，我猜测是我们自己写的未做更多的检查和判断。我们自己写的只是用来学习&lt;code&gt;FutureTask&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;不使用异步的方式时，&lt;code&gt;queryUserAddress&lt;/code&gt;在&lt;code&gt;queryUserInfo&lt;/code&gt;执行之后才会执行，两者相加的时间算入总调用耗时。如果使用了异步线程调用，由于&lt;code&gt;queryUserAddress&lt;/code&gt;耗时长，这样在&lt;code&gt;queryUserAddress&lt;/code&gt;执行结束前，&lt;code&gt;queryUserInfo&lt;/code&gt;就执行结束了，这样&lt;code&gt;queryUserInfo&lt;/code&gt;调用耗时就不计了。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 14:47:00 +0000</pubDate>
<dc:creator>flylinran</dc:creator>
<og:description>线程池的实现核心之一是FutureTask。在提交任务时，用户实现的Callable实例task会被包装为FutureTask实例ftask；提交后任务异步执行，无需用户关心；当用户需要时，再调用Fu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flylinran/p/10171449.html</dc:identifier>
</item>
<item>
<title>ffmpeg定制滤波器 - TaigaComplex</title>
<link>http://www.cnblogs.com/TaigaCon/p/10171464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TaigaCon/p/10171464.html</guid>
<description>&lt;p&gt;如果有定制ffmpeg滤波器的需求，有两个结构体是必须要了解的：AVFilter、AVFilterPad，所定制的滤波器主要就是通过填充这两个结构体来实现的。我们下面将详细解析这两个结构体，并通过对滤波器的初始化流程以及滤波流程进行分析，进一步加深对ffmpeg滤波框架的了解。&lt;/p&gt;


&lt;p&gt;AVFilter就是一个滤波器的主体，其结构体定义如下：&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
typedef struct AVFilter {
    const char *name;
    const char *description;
    const AVFilterPad *inputs;
    const AVFilterPad *outputs;
    const AVClass *priv_class;
    int flags;
    int (*preinit)(AVFilterContext *ctx);
    int (*init)(AVFilterContext *ctx);
    int (*init_dict)(AVFilterContext *ctx, AVDictionary **options);
    void (*uninit)(AVFilterContext *ctx);
    int (*query_formats)(AVFilterContext *);
    int priv_size;      
    int flags_internal; 
    struct AVFilter *next;
    int (*process_command)(AVFilterContext *, const char *cmd, const char *arg, char *res, int res_len, int flags);
    int (*init_opaque)(AVFilterContext *ctx, void *opaque);
    int (*activate)(AVFilterContext *ctx);
} AVFilter;
&lt;/pre&gt;
&lt;p&gt;其各个成员变量有如下含义：&lt;/p&gt;
&lt;table class=&quot;List&quot;&gt;&lt;tbody readability=&quot;22.28112033195&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;name&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;滤波器名字。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;description&lt;/td&gt;
&lt;td&gt;滤波器的简短介绍。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;inputs&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;滤波器入口（AVFilterPad）列表。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;outputs&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;滤波器出口（AVFilterPad）列表。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3.8634812286689&quot;&gt;&lt;td&gt;&lt;strong&gt;priv_class&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;主要用于维护用户传入的参数（AVOption）的结构体，一般来说用户向滤波器传入参数有两个手段：在创建滤波器实例的时候传入指定参数的字符串，或者在创建完成滤波器实例后通过&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__opt__set__funcs.html#ga5fd4b92bdf4f392a2847f711676a7537&quot;&gt;av_opt_set&lt;/a&gt;之类的接口传入字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;flags&lt;/td&gt;
&lt;td&gt;滤波器标志。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;preinit&lt;/td&gt;
&lt;td&gt;滤波器预初始化函数。这个函数会在创建滤波器实例的开头被调用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5.8227848101266&quot;&gt;&lt;td&gt;&lt;strong&gt;init&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;滤波器自身的特制初始化函数。初始化，即&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__lavfi.html#gac0788a9ab6966dba9318b5d5c7524fea&quot;&gt;avfilter_graph_create_filter&lt;/a&gt;，可以被分解成通用的初始化以及特制初始化。&lt;br/&gt;通用初始化通常包含三个步骤：&lt;br/&gt;  1. 创建用于存放滤波器实例的内存，进行一些初始化默认的赋值处理。&lt;br/&gt;  2.把传入的字符串解析进行解析得到字典的两要素：参数名称key,参数值val。&lt;br/&gt;  3.通过priv_class所维护的AVOption，可以找到名为key的参数对应的内存位置（即滤波器实例的私有结构体priv中名称为key的参数的位置），并把val写入该位置当中即可完成参数设置。私有结构体priv中的参数就通常就是滤波器的实际参数，在进行滤波时会根据其中的参数进行滤波处理。&lt;br/&gt;特制的初始化有很多不同的用途，比如检查参数，如果检查到所输入的参数中缺少一些重要的参数，则可以返回负值来表示初始化错误。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;init_dict&lt;/td&gt;
&lt;td&gt;与上方init功能相同，不太常用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;uninit&lt;/td&gt;
&lt;td&gt;如果在init函数出现错误则会调用uninit来做一些后续处理。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.7096774193548&quot;&gt;&lt;td&gt;&lt;strong&gt;query_formats&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;为了进行滤波器之间的&lt;a href=&quot;https://www.cnblogs.com/TaigaCon/p/10111326.html&quot;&gt;滤波格式协商&lt;/a&gt;，AVFilter的query_formats函数会去设置AVFilterLink上的in_formats/out_formats等，这是格式协商的第一步。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;priv_size&lt;/td&gt;
&lt;td&gt;滤波器实例的私有结构体（priv）的大小。我们前面也说了priv当中的参数就是滤波器的实际参数，而不同滤波器的参数不同，那么所占用的空间也不会一样，因此在创建滤波器实例的时候会根据priv_size来开辟用于存放参数的空间。&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;flags_internal&lt;/td&gt;
&lt;td&gt;滤波器内部标志。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.6336633663366&quot;&gt;&lt;td&gt;next&lt;/td&gt;
&lt;td&gt;在新版本ffmpeg中不会使用到这个next参数。&lt;br/&gt;老版本的ffmpeg需要用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__lavfi.html#ga3db814dea5d918f88af888d484f77fb8&quot;&gt;avfilter_rigister&lt;/a&gt;来注册滤波器（AVFilter），注册的时候就会使用这个next参数，使得所有注册了的滤波器形成一个滤波器链表，如果需要某个滤波器则可以从该链表中获取。&lt;br/&gt;新版本的ffmpeg使用的是列表（filter_list）来列出所有的滤波器（AVFilter），一般来说，如果想获得滤波器，可以调用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__lavfi.html#gadd774ec49e50edf00158248e1bfe4ae6&quot;&gt;avfilter_get_by_name&lt;/a&gt;来轮询列表获得。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5624430264357&quot;&gt;&lt;td&gt;process_command&lt;/td&gt;
&lt;td&gt;一般来说，滤波参数的设置有两种方式：&lt;br/&gt;  1. 在初始化时（&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__lavfi.html#gac0788a9ab6966dba9318b5d5c7524fea&quot;&gt;avfilter_graph_create_filter&lt;/a&gt;），输入参数字符串。&lt;br/&gt;  2. 在初始化后，配置整个滤波图前（&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__lavfi.html#ga1896c46b7bc6ff1bdb1a4815faa9ad07&quot;&gt;avfilter_graph_config&lt;/a&gt;），调用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__opt__set__funcs.html#ga5fd4b92bdf4f392a2847f711676a7537&quot;&gt;av_opt_set&lt;/a&gt;之类的接口输入参数。&lt;br/&gt;为了保证滤波器正常运行，在滤波的过程中一般是不会对滤波参数进行修改的。当然，在滤波过程中调用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__opt__set__funcs.html#ga5fd4b92bdf4f392a2847f711676a7537&quot;&gt;av_opt_set&lt;/a&gt;之类的函数是可以修改滤波参数，但是并不能保证滤波器会按照我们预想地那样运行。因为如果按照前面的两种方式设置滤波参数，后面可能还会执行AVFilterPad的config_props操作，而在滤波过程中通过av_opt_set之类的函数去设置滤波参数时是不会再回去继续执行这一步的。&lt;br/&gt;不过现实当中确实存在在滤波过程中修改滤波参数的需求，比如说播放音乐时可以调整EQ。此时就可以通过实现process_command这个函数来实现滤波过程中的各种变化。&lt;br/&gt;使用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__lavfi.html#gaaad7850fb5fe26d35e5d371ca75b79e1&quot;&gt;avfilter_graph_send_command&lt;/a&gt;就能触发所指定的滤波器调用其process_command函数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;init_opaque&lt;/td&gt;
&lt;td&gt;与init功能相同，不常用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.6826222684703&quot;&gt;&lt;td&gt;&lt;strong&gt;activate&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;滤波函数。滤波函数有两种实现方式，一种是通过activate来实现，另一种是后面会说到的AVFilterPad中的filter_frame以及request_frame函数。如果是采用activate的方式，就需要在activate内实现以下流程：&lt;br/&gt;  1. 获取前面的滤波器实例输出的帧。具体操作就是调用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/avfilter_8c.html#ac1daee38f363044775732a960441861c&quot;&gt;ff_inlink_consume_frame&lt;/a&gt;来从inlink获取前面滤波器实例输出的帧。&lt;br/&gt;        如果所需要的帧未准备好，则需要通知相应的滤波器实例，表明当前滤波器需要帧。具体操作就是调用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/avfilter_8c.html#aea1024da8862dda53d050c7619bdf9fc&quot;&gt;ff_inlink_request_frame&lt;/a&gt;来设置inlink上的frame_wanted_out，该变量就是用于表明inlink的目标滤波器实例，即当前滤波器实例需要前一个滤波器实例输出帧。&lt;br/&gt;        如果所需要的帧已准备好，就可以执行滤波操作。&lt;br/&gt;  2. 向后面的滤波器实例输出滤波完成的帧。具体操作就是调用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/avfilter_8c.html#a65d6e9755eadf69367843dfc738143b4&quot;&gt;ff_filter_frame&lt;/a&gt;来向outlink输出帧。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;AVFilterPad是滤波器的出口或者入口，其结构定义如下：&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
struct AVFilterPad {
    const char *name;
    enum AVMediaType type;
    AVFrame *(*get_video_buffer)(AVFilterLink *link, int w, int h);
    AVFrame *(*get_audio_buffer)(AVFilterLink *link, int nb_samples);
    int (*filter_frame)(AVFilterLink *link, AVFrame *frame);
    int (*poll_frame)(AVFilterLink *link);
    int (*request_frame)(AVFilterLink *link);
    int (*config_props)(AVFilterLink *link);
    int needs_fifo;
    int needs_writable;
};
&lt;/pre&gt;
&lt;p&gt;各成员变量具有如下含义：&lt;/p&gt;
&lt;table class=&quot;List&quot;&gt;&lt;tbody readability=&quot;27.616358325219&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;name&lt;/td&gt;
&lt;td&gt;出/入口（input/output pads）名字。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;支持的帧类型：AVMEDIA_TYPE_VIDEO/AVMEDIA_TYPE_AUDIO。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.2920353982301&quot;&gt;&lt;td&gt;get_video_buffer&lt;br/&gt;(input pads only)&lt;/td&gt;
&lt;td&gt;提供用于写入视频图像的buffer，一般是向前一个滤波器实例提供。&lt;br/&gt;一个滤波器在滤波过程中，可能需要额外的buffer来进行滤波处理，比如scale或者aresample这种格式转换滤波器，在进行滤波处理时，有输入帧作为源材料，输入帧有确实存在的buffer，而为了进行输出，我们需要额外的buffer来存放格式转换后的帧。所需的buffer除了指定的宽与高之外，还有像素格式，这三点是影响buffer大小的因素，像素格式就是输出链上的格式（link-&amp;gt;format）。&lt;br/&gt;如果一个滤波器实例需要buffer，可以通过&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/video_8c.html#a7f0f699d7689ef551622672dcd39a96a&quot;&gt;ff_get_video_buffer(outlink, w, h)&lt;/a&gt;来调用下一个滤波器对应AVFilterPad上的get_video_buffer函数。不过一般来说，是不需要AVFilterPad去实现get_video_buffer这个函数的，因为如果AVFilterPad不实现这个函数，则会调用默认的&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/video_8c.html#aeac3e4fc069b44947d469b037a435092&quot;&gt;ff_default_get_video_buffer&lt;/a&gt;，该函数会根据输入的w,h以及link的format来提供buffer。&lt;br/&gt;&lt;em&gt;※ffmpeg中仅有几个filter实现了get_video_buffer（vflip，swapuv等），不过其内部也是调用了&lt;/em&gt;&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/video_8c.html#aeac3e4fc069b44947d469b037a435092&quot;&gt;&lt;em&gt;ff_default_get_video_buffer&lt;/em&gt;&lt;/a&gt;&lt;em&gt;，并且其它部分的代码看起来并没有起到什么实际作用。&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.821978021978&quot;&gt;&lt;td&gt;get_audio_buffer&lt;br/&gt;(input pads only)&lt;/td&gt;
&lt;td&gt;含义同上，提供给上一个滤波器实例调用。&lt;br/&gt;调用接口为&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/audio_8c.html#a7954d515c464dafcefd68c2a344489a7&quot;&gt;ff_get_audio_buffer(outlink, nb_samples)&lt;/a&gt;，如果没有实现该函数，则会默认调用到函数&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/audio_8c.html#a7f6ef4e5a27f396787e4642039d2ef3b&quot;&gt;ff_default_get_audio_buffer&lt;/a&gt;，buffer的大小受到输入参数的nb_samples以及link-&amp;gt;channels，link-&amp;gt;format的影响。&lt;br/&gt;一般来说不需要滤波器实现get_audio_buffer函数。&lt;br/&gt;※ffmpeg中并没有实现了get_audio_buffer的滤波器。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.3814655172414&quot;&gt;&lt;td&gt;&lt;strong&gt;filter_frame&lt;br/&gt;&lt;/strong&gt;(input pads only)&lt;/td&gt;
&lt;td&gt;filter_frame是最常见的滤波实现函数。如果AVFilter没有实现activate函数，则会调用默认的activate函数&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/avfilter_8c.html#abda1357b88f06c1554eae51fb881b82a&quot;&gt;ff_filter_activate_default&lt;/a&gt;，该函数最终会调用到filter_frame来提供滤波的实现。&lt;br/&gt;filter_frame的输入参数中包括滤波实例的inlink以及从inlink上提取的frame，一般来说filter_frame会对该frame进行滤波处理，然后调用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/avfilter_8c.html#a65d6e9755eadf69367843dfc738143b4&quot;&gt;ff_filter_frame&lt;/a&gt;向outlink输出滤波后的帧。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;poll_frame&lt;br/&gt;(output pads only)&lt;/td&gt;
&lt;td&gt;设定上poll_frame是用于查看前一个滤波器实例的request_frame能返回多少帧，不过实际上应该是没有用到这个函数的地方。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;&lt;strong&gt;request_frame&lt;br/&gt;&lt;/strong&gt; (output pads only)&lt;/td&gt;
&lt;td&gt;request_frame其实也是一个用于产生帧的滤波函数，不过观察request_frame的参数可以发现该函数并没有frame作为输入参数，这表明了request_frame有特定的应用场景：&lt;br/&gt;1. 如果一个滤波器是源滤波器，仅需要输出帧，则可以在request_frame内生成帧，然后调用ff_filter_frame把帧输出到outlink。ffmpeg中源滤波器的源文件都带有src关键字，如buffersrc以及vsrc/asrc为开头的滤波器。&lt;br/&gt;2. 如果一个滤波器希望在EOF后继续输出帧，则可以用request_frame调用ff_filter_frame来进行输出。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;config_props&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;config_props的调用发生在query_formats之后，此时滤波格式的协调已经完成，也就已经确定了滤波器实例的输入以及输出格式（inlink-&amp;gt;format/outlink-&amp;gt;format）。如果某些设置需要使用到这些输入输出格式，就可以在config_props中进行设置。如aresampe在config_props中就利用协调完成的format、channel_layout、sample_rate来进行重采样的参数设置。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;needs_fifo&lt;br/&gt;(input pad only)&lt;/td&gt;
&lt;td&gt;表明只有当滤波器实例主动请求帧（调用ff_inlink_request frame或者ff_request_frame）的时候，前一个滤波器实例才会向当前滤波器实例输出帧（ff_filter_frame）。&lt;br/&gt;如果needs_fifo为1，会自动在当前滤波器实例与前一个滤波器实例之间插入一个名为fifo的滤波器，该滤波器实现了上述功能。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;needs_writable&lt;br/&gt;(input pad only)&lt;/td&gt;
&lt;td&gt;表明滤波器需要对pad对应的link所输入的frame进行写入。如进行字幕渲染的ass滤波器就需要对输入的视频帧进行写入。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;首先是&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__lavfi.html#gac0788a9ab6966dba9318b5d5c7524fea&quot;&gt;avfilter_graph_create_filter&lt;/a&gt;，即创建滤波器实例。如前面所说，这个函数会在最开头调用滤波器的preinit函数，然后创建滤波器实例并做一些简单的初始化，解析输入的字符串，最后调用滤波器的init函数。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181224224527903-902661147.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181224224528405-1308397682.png&quot; alt=&quot;image&quot; width=&quot;350&quot; height=&quot;343&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在构建好一整个AVFilterGraph后，就可以调用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__lavfi.html#ga1896c46b7bc6ff1bdb1a4815faa9ad07&quot;&gt;avfilter_graph_config&lt;/a&gt;来做graph最后的配置。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181224224528767-584189413.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181224224529176-1004975923.png&quot; alt=&quot;image&quot; width=&quot;320&quot; height=&quot;313&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/avfiltergraph_8c.html#a9a3f1a9df56f7346848e658b1a99859f&quot;&gt;graph_insert_fifos&lt;/a&gt;中就会对设定了needs_fifo=1的input pad所在的link插入名为fifo的滤波器。&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
            if (!link-&amp;gt;dstpad-&amp;gt;needs_fifo)
                continue;

            fifo = f-&amp;gt;inputs[j]-&amp;gt;type == AVMEDIA_TYPE_VIDEO ?
                   avfilter_get_by_name(&quot;fifo&quot;) :
                   avfilter_get_by_name(&quot;afifo&quot;);

            snprintf(name, sizeof(name), &quot;auto_fifo_%d&quot;, fifo_count++);

            ret = avfilter_graph_create_filter(&amp;amp;fifo_ctx, fifo, name, NULL,
                                               NULL, graph);

            ret = avfilter_insert_filter(link, fifo_ctx, 0, 0);
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/avfiltergraph_8c.html#aef8b0d3746f278d0b81c1abdf12c7fd0&quot;&gt;graph_config_formats&lt;/a&gt;中如&lt;a href=&quot;https://www.cnblogs.com/TaigaCon/p/10111326.html&quot;&gt;前一篇文章&lt;/a&gt;所说，就是对整个graph中滤波格式进行协商，协商过后可以确定所有link上的格式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/avfiltergraph_8c.html#a364e5126c89a6b46ffc771bf368d4ac7&quot;&gt;graph_config_links&lt;/a&gt;主要目的就是调用pad中的config_props，那么config_props就能根据前面协商得到的link格式做进一步的操作。&lt;/p&gt;



&lt;p&gt;一般来说，用户会按照如下方式调用滤波API来进行滤波处理：&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
    ret = av_buffersrc_add_frame(in_filter, pFrame);

    while((ret = av_buffersink_get_frame(out_filter, pFrame))&amp;gt;=0){
        //TODO
    }
&lt;/pre&gt;
&lt;h4&gt;向graph输入帧&lt;/h4&gt;
&lt;p&gt;滤波的流程都是首先调用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__lavfi__buffersrc.html#ga8fc71cb48c1ad1aa78b48f87daa4cf19&quot;&gt;av_buffersrc_add_frame&lt;/a&gt;，从向buffersrc输入帧开始的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181224224529548-115897878.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181224224529926-135502033.png&quot; alt=&quot;image&quot; width=&quot;370&quot; height=&quot;197&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到调用了buffersrc的request_frame函数，该函数最后用ff_filter_frame向outlink输出帧。、&lt;/p&gt;

&lt;h4&gt;从graph提取帧&lt;/h4&gt;
&lt;p&gt;然后调用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__lavfi__buffersink.html#ga653228f4cbca427c654d844a5fc59cfa&quot;&gt;av_buffersink_get_frame&lt;/a&gt;，尝试获得buffersink输出的帧，如果返回值大于0则表明得到了一帧，正常情况下如果无法获得帧通常会返回EAGAIN，这表明要求用户向buffersrc输入更多的帧。&lt;/p&gt;
&lt;p&gt;av_buffersink_get_frame会向下调用到get_frame_internal，该函数主要作用就是调用滤波器进行滤波，并返回滤波完成的帧。函数实现如下：&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
static int get_frame_internal(AVFilterContext *ctx, AVFrame *frame, int flags, int samples)
{
    BufferSinkContext *buf = ctx-&amp;gt;priv;
    AVFilterLink *inlink = ctx-&amp;gt;inputs[0];
    int status, ret;
    AVFrame *cur_frame;
    int64_t pts;

    if (buf-&amp;gt;peeked_frame)
        return return_or_keep_frame(buf, frame, buf-&amp;gt;peeked_frame, flags);

    while (1) {
        ret = samples ? ff_inlink_consume_samples(inlink, samples, samples, &amp;amp;cur_frame) :
                        ff_inlink_consume_frame(inlink, &amp;amp;cur_frame);
        if (ret &amp;lt; 0) {
            return ret;
        } else if (ret) {
            /* TODO return the frame instead of copying it */
            return return_or_keep_frame(buf, frame, cur_frame, flags);
        } else if (ff_inlink_acknowledge_status(inlink, &amp;amp;status, &amp;amp;pts)) {
            return status;
        } else if ((flags &amp;amp; AV_BUFFERSINK_FLAG_NO_REQUEST)) {
            return AVERROR(EAGAIN);
        } else if (inlink-&amp;gt;frame_wanted_out) {
            ret = ff_filter_graph_run_once(ctx-&amp;gt;graph);
            if (ret &amp;lt; 0)
                return ret;
        } else {
            ff_inlink_request_frame(inlink);
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;该函数有如下实现逻辑：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用ff_inlink_consume_frame，看是否可以获得滤波完成的帧，如果得到了滤波后的帧，则调用return_or_keep_frame进行返回。&lt;/li&gt;
&lt;li&gt;调用ff_inlink_acknowledge_status，查看滤波过程中是否出了差错，或者是否到了EOF，是则返回错误。&lt;/li&gt;
&lt;li&gt;frame_wanted_out用于表明当前滤波器是否已经获得了前一个滤波器输出的一帧，等于1则表示未获得，那么需要调用ff_filter_graph_run_once；等于0则表示已获得一帧，或者是第一次调用该函数。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;跳出get_frame_internal里面的while循环只有下面几种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ff_inlink_consume_frame返回值不为0，表明可以返回滤波后的帧。&lt;/li&gt;
&lt;li&gt;ff_inlink_acknowledge_status返回值不为0，表明滤波器运行过程中出错。&lt;/li&gt;
&lt;li&gt;ff_filter_graph_run_once返回值小于0，一般情况下为EAGAIN，表明滤波器需要输入更多的帧作为原料。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果是第一次调用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__lavfi__buffersink.html#ga653228f4cbca427c654d844a5fc59cfa&quot;&gt;av_buffersink_get_frame&lt;/a&gt;，当进入该函数时，正常情况下会按照如下步骤执行：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于是第一次调用，因此frame_wanted_out为0，那么第一次循环会去执行ff_inlink_request_frame，这个函数会把frame_wanted_out设置为1，表明当前滤波器未获得前一个滤波器输出的帧。&lt;/li&gt;
&lt;li&gt;然后下一次循环时由于frame_wanted_out为1，会去调用ff_filter_graph_run_once。&lt;/li&gt;
&lt;li&gt;通常来说，经过几次循环调用ff_filter_graph_run_once后，会得到滤波后的帧，此时ff_inlink_consume_frame会返回1，因此就能调用return_or_keep_frame来向用户返回滤波后的帧了。&lt;/li&gt;
&lt;li&gt;如果需要输入更多的帧才能继续进行滤波，那么会从ff_filter_graph_run_once返回EAGAIN。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;激活滤波器&lt;/h4&gt;
&lt;p&gt;我们前面提到的ff_filter_graph_run_once就是查找已经就绪（ready）的滤波器实例，并对该滤波器进行激活。所得到的滤波器实例会满足两个条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;滤波器的ready值（优先级）更高的会被选上&lt;/li&gt;
&lt;li&gt;在此基础上，因为查找顺序是按照用户调用&lt;a href=&quot;https://ffmpeg.org/doxygen/3.3/group__lavfi.html#gac0788a9ab6966dba9318b5d5c7524fea&quot;&gt;avfilter_graph_create_filter&lt;/a&gt;的顺序，因此最先创建的滤波器实例会被选中。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
AVFilterContext *avfilter_graph_alloc_filter(AVFilterGraph *graph,
                                             const AVFilter *filter,
                                             const char *name)
{
    s = ff_filter_alloc(filter, name);
    graph-&amp;gt;filters[graph-&amp;gt;nb_filters++] = s;
}

int ff_filter_graph_run_once(AVFilterGraph *graph)
{
    filter = graph-&amp;gt;filters[0];
    for (i = 1; i &amp;lt; graph-&amp;gt;nb_filters; i++)
        if (graph-&amp;gt;filters[i]-&amp;gt;ready &amp;gt; filter-&amp;gt;ready)
            filter = graph-&amp;gt;filters[i];
    if (!filter-&amp;gt;ready)
        return AVERROR(EAGAIN);
    return ff_filter_activate(filter);
}
&lt;/pre&gt;

&lt;p&gt;选出优先级最高的滤波器实例后，首先把该滤波器就绪状态清零，然后开始执行激活操作：如果该滤波器实现了activate函数，则调用该函数，否则调用默认的激活函数ff_filter_activate_default。&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
int ff_filter_activate(AVFilterContext *filter)
{
    filter-&amp;gt;ready = 0;
    ret = filter-&amp;gt;filter-&amp;gt;activate ? filter-&amp;gt;filter-&amp;gt;activate(filter) :
          ff_filter_activate_default(filter);
}
&lt;/pre&gt;
&lt;p&gt;如果调用的是默认的激活函数，则会按照以下优先级进行激活处理：&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
static int ff_filter_activate_default(AVFilterContext *filter)
{
    unsigned i;

    for (i = 0; i &amp;lt; filter-&amp;gt;nb_inputs; i++) {
        if (samples_ready(filter-&amp;gt;inputs[i], filter-&amp;gt;inputs[i]-&amp;gt;min_samples)) {
            return ff_filter_frame_to_filter(filter-&amp;gt;inputs[i]);
        }
    }
    for (i = 0; i &amp;lt; filter-&amp;gt;nb_inputs; i++) {
        if (filter-&amp;gt;inputs[i]-&amp;gt;status_in &amp;amp;&amp;amp; !filter-&amp;gt;inputs[i]-&amp;gt;status_out) {
            av_assert1(!ff_framequeue_queued_frames(&amp;amp;filter-&amp;gt;inputs[i]-&amp;gt;fifo));
            return forward_status_change(filter, filter-&amp;gt;inputs[i]);
        }
    }
    for (i = 0; i &amp;lt; filter-&amp;gt;nb_outputs; i++) {
        if (filter-&amp;gt;outputs[i]-&amp;gt;frame_wanted_out &amp;amp;&amp;amp;
            !filter-&amp;gt;outputs[i]-&amp;gt;frame_blocked_in) {
            return ff_request_frame_to_filter(filter-&amp;gt;outputs[i]);
        }
    }
    return FFERROR_NOT_READY;
}
&lt;/pre&gt;
&lt;p&gt;可以发现共有三种激活处理方式，分别为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从上往下传递滤波完成的帧。&lt;/li&gt;
&lt;li&gt;从上往下传递错误代码。&lt;/li&gt;
&lt;li&gt;从下往上传递帧的请求。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前面的方式优先级更高。下面我们会对这三种方式进行较为详细的分析&lt;/p&gt;
&lt;h5&gt;ff_filter_frame_to_filter&lt;/h5&gt;
&lt;p&gt;触发条件是：当前滤波器实例的input link上的samples_ready。这samples_ready表明了前面的滤波器实例已经执行ff_filter_frame向当前滤波器实例的input link输出了帧。&lt;/p&gt;
&lt;p&gt;有了上述条件，那么为了完成当前滤波器实例的滤波操作，接下来会执行：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从input link上提取出帧。&lt;/li&gt;
&lt;li&gt;调用当前滤波器的filter_frame函数来执行滤波操作。&lt;/li&gt;
&lt;li&gt;一般来说滤波处理完成过后也会调用ff_filter_frame来把滤波完成的帧输出到output link。&lt;/li&gt;
&lt;li&gt;ff_filter_frame接下来会把下一个滤波器实例设为就绪状态。&lt;/li&gt;
&lt;li&gt;如果在执行filter_frame时出错，没能完成滤波处理，则会把错误代码写入input link的status_out，表明该link无法顺利输出frame到当前filter。&lt;/li&gt;
&lt;li&gt;如果执行filter_frame成功，考虑到前一个滤波器实例可能输出了不止一帧，因此再次把当前滤波器实例设为就绪状态，如果前一个滤波器确实输出了多个帧，这部操作会使得这多个帧都被当前滤波器实例滤波完成后才会执行下一个滤波器实例的滤波处理。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181224224530325-1509525684.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181224224530792-767251985.png&quot; alt=&quot;image&quot; width=&quot;550&quot; height=&quot;367&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h5&gt;foward_status_change&lt;/h5&gt;
&lt;p&gt;触发条件是：当前滤波器实例的input link上有status_in &amp;amp;&amp;amp; !status_out。status_in不为0表明调用前一个滤波器实例的request_frame时出现了错误，status_in的值就是错误代码，我们需要向后面的滤波器实例传播这个错误代码。&lt;/p&gt;
&lt;p&gt;forward_status_change是传播错误代码的入口，传播错误代码的很大一步分的实现都在ff_request_frame函数内。基于上述条件，即调用前一个滤波器实例的request_frame时出现了错误。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;forward_status_change会调用当前滤波器实例的request_frame来传输错误代码，request_frame一般内部都会调用到ff_request_farme函数。&lt;/li&gt;
&lt;li&gt;错误代码status_in会导致ff_request_frame走入错误处理分支。&lt;/li&gt;
&lt;li&gt;把status_out的值设置为status_in。&lt;/li&gt;
&lt;li&gt;那么返回值也会是该错误代码，这用于表示当前request_frame也出现了错误。&lt;/li&gt;
&lt;li&gt;因此在返回的时候会把下一个滤波器实例的input link（即当前滤波器实例的output link）上的status_in设置为错误代码。&lt;/li&gt;
&lt;li&gt;把frame_wanted_out设置为0用于表示当前滤波器实例的错误处理已完成，避免再次调用当前滤波器实例的request_frame函数做重复的错误处理。&lt;/li&gt;
&lt;li&gt;把下一个滤波器实例设置为就绪状态。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181224224531504-2130740663.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181224224532014-518819674.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;258&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h5&gt;ff_request_frame_to_filter&lt;/h5&gt;
&lt;p&gt;触发条件是：当前滤波器的output link上有frame_wanted_out以及!frame_blocked_in。其中frame_blocked_in用于防止重复对同一个link执行request frame操作，重要的是frame_wanted_out。我们前面也说过，如果一个link上的frame_wanted_out=1，表明该link的dst要求src输出帧，具体一点，就是这会导致执行src的request_frame函数。那么这里的output link上的frame_wanted_out=1就会导致：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当前的滤波器实例的request_frame被执行。&lt;/li&gt;
&lt;li&gt;request_frame内一般会调用ff_request_frame函数。一般情况下，该函数会把input link的frame_wanted_out设置为1。&lt;/li&gt;
&lt;li&gt;然后把前一个滤波器实例设为就绪状态。&lt;/li&gt;
&lt;li&gt;如果request_frame出错的话，就是request_frame没能处理完成，则会把错误代码写入outlink的status_in，表明该link无法顺序求得当前滤波器实例的帧。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181224224532692-2139886791.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181224224533165-758106272.png&quot; alt=&quot;image&quot; width=&quot;600&quot; height=&quot;234&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意：上面所描述的三种处理方式只是比较常见方式。在实际应用中，有些滤波器在filter_frame内调用ff_request_frame，也有些滤波器在request_frame内调用ff_filter_frame的，而且实现了activate函数的滤波器并不会执行上述流程，如果全部都列出来就过于冗余了，具体问题具体分析是很重要的。&lt;/p&gt;

&lt;p&gt;此外，我们可以看到在执行ff_filter_frame时会把ready值设置为300；在执行ff_request_frame时会吧ready值设置为100；在保存错误代码时会把ready值设置为200。这表明了优先进行滤波处理，其次是错误处理，最后才是帧请求。&lt;/p&gt;
&lt;p&gt;滤波的激活处理可以按照如下进行总结：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;优先执行滤波处理，如果前面的滤波器实例输出帧，当前的滤波器实例就可以执行滤波处理，并把滤波后得到的帧向后传递。&lt;/li&gt;
&lt;li&gt;如果在滤波时缺乏帧作为原料，则向前要求前面的滤波器实例输出帧，这个要求会一直往前发送，直到有滤波器实例可以输出帧。&lt;/li&gt;
&lt;li&gt;如果在滤波或者请求帧的过程中出错了，就把错误往后传递，典型的如EOF就是这种传递方式。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 24 Dec 2018 14:46:00 +0000</pubDate>
<dc:creator>TaigaComplex</dc:creator>
<og:description>如果有定制ffmpeg滤波器的需求，有两个结构体是必须要了解的：AVFilter、AVFilterPad，所定制的滤波器主要就是通过填充这两个结构体来实现的。我们下面将详细解析这两个结构体，并通过对滤</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TaigaCon/p/10171464.html</dc:identifier>
</item>
<item>
<title>关于SQL Server 数据库归档的一些思考和改进 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/10168858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/10168858.html</guid>
<description>&lt;h2&gt;一.需求背景&lt;/h2&gt;
&lt;p&gt;SQL Server开源的归档工具不多，DBA一般都是通过计划任务来触发执行，执行的脚本多是SP或者是SSIS包。SSIS包的性能稍好一些，但是维护更新成本高些。所以更常见的是通过SP脚本来实现归档操作。&lt;/p&gt;
&lt;p&gt;当数据库规模较小时，可以方便的直接在数据库上进行脚本的编写部署。但是随着数据库越来越多，管理维护成本就会越来越大，越来越不方便。现在我们实行的方式是通过中央管理器来管理众多的数据库备份（这是在拥有专门的备份程序前的一个过渡方案）。我们将归档基础配置信息、归档运行历史记录、异常报错等数据统一维护在中央数据库上。如此,可以方便统一的查看、管理和维护。&lt;/p&gt;
&lt;h2&gt; 二.主要架构&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201812/780228-20181224223019340-665846017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三.主要关联表&lt;/h2&gt;
&lt;p&gt;2.1 归档基础配置表&lt;/p&gt;
&lt;p&gt;表字段含义，请耐心查看字段说明。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;132&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DBName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DataTable&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;TargetIP&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;TargetDB&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;TargetTable&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Prerequisite&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;300&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DelMaxQTY&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;IsCheckOrderID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;SP_Name&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;StartTime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;EndTime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;
) &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Server IP(数据位于中央管理器中，所以归档数据库库所在的IP要维护，可维修虚拟的IP)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;要归档的数据库&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;要归档的表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DataTable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;备份指向的IP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TargetIP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;备份指向的数据库&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TargetDB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;备份指向的表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TargetTable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;归档条件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Prerequisite&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;循环中一次归档删除的数据量&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DelMaxQTY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;此为 备用字段，考虑可能有些表，会和其他表关联&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;IsCheckOrderID&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;为提高并发度，一个DB对应的归档SP可能是多个，通过此列，进行分组。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SP_Name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;此为拓展字段，原计划根据 开始时间、结束时间，每天可以多个时间段内执行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;StartTime&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;EXEC&lt;/span&gt; sys.sp_addextendedproperty &lt;span&gt;@name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MS_Description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@value&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;此为拓展字段，原计划根据 开始时间、结束时间，每天可以多个时间段内执行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;@level0type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SCHEMA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level0name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level1type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level1name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;@level2type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLUMN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;@level2name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;EndTime&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.2 归档运行的Log表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DBData_ArchiveLog&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DBName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DataTable&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;80&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;BakQTY&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;BakStartDate&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;BakEndDate&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;
) &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;GO&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.3 异常错误信息表&lt;/p&gt;
&lt;p&gt;执行的过程中会外包一层 try...catch,将操作过程中的错误信息保存在表 DBData_ArchiveErrLog。表结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DBData_ArchiveErrLog&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DBName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;60&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DataTable&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;80&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;TargetIP&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;TargetDB&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;60&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;TargetTable&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;80&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Errormsg&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;nvarchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;TransDateTime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;
) &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; TEXTIMAGE_ON &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;

&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四. 存储过程相应的主要代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;134&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; ANSI_NULLS &lt;span&gt;ON&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;SET&lt;/span&gt; QUOTED_IDENTIFIER &lt;span&gt;ON&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; =============================================&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; Author:        &amp;lt;Author,,Name&amp;gt;&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; Create date: &amp;lt;Create Date,,&amp;gt;&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; Description:    &amp;lt;Description,,&amp;gt;&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; =============================================&lt;/span&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;PROCEDURE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;SP_XXXXX_DataArchive&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;AS&lt;/span&gt;
    &lt;span&gt;SET&lt;/span&gt; NOCOUNT &lt;span&gt;ON&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@sql1&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;) 
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@sql&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;) 
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@sql2&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@IP&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;) 
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@DBName&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;) 
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@DataTable&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;) 
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@TargetIP&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;) 
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@TargetDB&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;) 
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@TargetTable&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;) 
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Prerequisite&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;) 
    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@DelMaxQTY&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
    &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@StartTime&lt;/span&gt; &lt;span&gt;DATETIME&lt;/span&gt;
    &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@EndTime&lt;/span&gt; &lt;span&gt;DATETIME&lt;/span&gt;
    &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@qty&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt; 
    &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@ISCHECKORDERID&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt; 
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--Carson   2018-12-17 备份数据的时间往往比删除的时间长3倍,因此,如果考虑将备份的操作转移到辅助库,将会对线上的操作影响降至更低&lt;/span&gt;
    &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@BakDateIP&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;)  
    &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@BakDateIP&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[XXX.XXX.XXX.XXX].&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----后面一定要有一个点&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt;------------------------------------------------归档操作---------------------------------&lt;/span&gt;
    &lt;span&gt;DECLARE&lt;/span&gt; DBName &lt;span&gt;CURSOR&lt;/span&gt;
    &lt;span&gt;FOR&lt;/span&gt;
        &lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt;  IP ,
                DBName ,
                DataTable ,
                TargetIP ,
                TargetDB ,
                TargetTable ,
                Prerequisite ,
                DelMaxQTY ,
                ISCHECKORDERID ,
                StartTime ,
                EndTime
        &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;    &lt;span&gt;[&lt;/span&gt;&lt;span&gt;中央管理器&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;中央管理数据库&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
        &lt;span&gt;WHERE&lt;/span&gt;   DataTable &lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
                &lt;span&gt;AND&lt;/span&gt; TargetTable &lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
                &lt;span&gt;AND&lt;/span&gt; DBNAME &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;XXXXXXXXX&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; SP_Name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;?????&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;OPEN&lt;/span&gt;&lt;span&gt; DBName    
    &lt;/span&gt;&lt;span&gt;FETCH&lt;/span&gt; &lt;span&gt;NEXT&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; DBName &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;@IP&lt;/span&gt;, &lt;span&gt;@DBName&lt;/span&gt;, &lt;span&gt;@DataTable&lt;/span&gt;, &lt;span&gt;@TargetIP&lt;/span&gt;, &lt;span&gt;@TargetDB&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;@TargetTable&lt;/span&gt;, &lt;span&gt;@Prerequisite&lt;/span&gt;, &lt;span&gt;@DelMaxQTY&lt;/span&gt;, &lt;span&gt;@ISCHECKORDERID&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;@StartTime&lt;/span&gt;, &lt;span&gt;@EndTime&lt;/span&gt;   
    &lt;span&gt;WHILE&lt;/span&gt; ( &lt;span&gt;@@fetch_status&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; )
    &lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;  
        &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@datetime&lt;/span&gt; &lt;span&gt;DATETIME&lt;/span&gt;
        &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;@ISCHECKORDERID&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;@DataTable&lt;/span&gt; &lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
        &lt;span&gt;BEGIN&lt;/span&gt;
            &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@datetime&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;), &lt;span&gt;GETDATE&lt;/span&gt;() &lt;span&gt;-&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;120&lt;/span&gt;&lt;span&gt;)                
            &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@sql&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Insert into [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@TargetIP&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;].&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@TargetDB&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@TargetTable&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                 select * FROM &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@BakDateIP&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DBName&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DataTable&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt; 
                 with(nolock) where &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@Prerequisite&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
                
            &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@sql1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DECLARE @icount INTEGER  
                        SELECT @icount = COUNT(1)  
                        FROM &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@BakDateIP&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DBName&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DataTable&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                        where &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@Prerequisite&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;  
                        insert into [中央管理器].[中央管理数据库].dbo.DBData_ArchiveLog (IP, DBName, DataTable, BakQTY, BakStartDate, BakEndDate)
                        select &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@IP&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DBName&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DataTable&lt;/span&gt;
                                    &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;,@icount,getdate(),null

                        WHILE @icount &amp;gt; 0   
                        BEGIN  
                    
                            DELETE TOP (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@DelMaxQTY&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;)) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
                            FROM &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DBName&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DataTable&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt; 
                            where &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@Prerequisite&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;
      
                            SET @icount = @icount -(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                                    &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@DelMaxQTY&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;)) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
                            WAITFOR DELAY &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;00:00:01&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;  
                        END  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;                    
          &lt;span&gt;BEGIN&lt;/span&gt;&lt;span&gt; TRY
            &lt;/span&gt;&lt;span&gt;EXEC&lt;/span&gt; (&lt;span&gt;@sql&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;EXEC&lt;/span&gt; (&lt;span&gt;@sql1&lt;/span&gt;&lt;span&gt;) 
          &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt; TRY
          &lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;&lt;span&gt; CATCH
             &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Errmsg&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;nvarchar&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;)
             &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@Errmsg&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;ERROR_MESSAGE()
               &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----0001 BEGIN SAVE ERR LOG IN TABLE&lt;/span&gt;
               &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;中央管理器&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;中央管理数据库&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.DBData_ArchiveErrLog  (&lt;span&gt;[&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; ,&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DBName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;,&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DataTable&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;,&lt;span&gt;[&lt;/span&gt;&lt;span&gt;TargetIP&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;,&lt;span&gt;[&lt;/span&gt;&lt;span&gt;TargetDB&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;,&lt;span&gt;[&lt;/span&gt;&lt;span&gt;TargetTable&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;,&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Errormsg&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; ,&lt;span&gt;[&lt;/span&gt;&lt;span&gt;TransDateTime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;)
               &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;@IP&lt;/span&gt;, &lt;span&gt;@DBName&lt;/span&gt;, &lt;span&gt;@DataTable&lt;/span&gt;, &lt;span&gt;@TargetIP&lt;/span&gt;, &lt;span&gt;@TargetDB&lt;/span&gt;, &lt;span&gt;@TargetTable&lt;/span&gt;,&lt;span&gt;@Errmsg&lt;/span&gt;,&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;25&lt;/span&gt;),&lt;span&gt;GETDATE&lt;/span&gt;(), &lt;span&gt;120&lt;/span&gt;&lt;span&gt;))       
               &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;----0001 END&lt;/span&gt;
                &lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----------0002 BEGIN SEND EMAIL MESSAGE----------------              &lt;/span&gt;
                    &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Subject&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;nvarchar&lt;/span&gt;(&lt;span&gt;200&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Body&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;nvarchar&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@SPName&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;nvarchar&lt;/span&gt;(&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;)
            
                    &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@Subject&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;数据库归档异常 -重要!;ServerIP:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@IP&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt; DB:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DBName&lt;/span&gt;
                                &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@SPName&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
                                &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@Body&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;Dear All,&amp;lt;br&amp;gt; &amp;lt;br&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;ServerIP:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;@IP&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt; ; DataBase:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DBName&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;上的Table归档异常,请及时检查!!!
                               &amp;lt;br&amp;gt;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;You can get detail information from the table. &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;table border=1 bgcolor=#aaff11&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
                                &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@Body&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Body&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;tr bgcolor=#ff3311&amp;gt;&amp;lt;td&amp;gt;ServerIP&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;DBName&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;TableName&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;TargetIP&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;TargetDB&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;Errmsg&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;TransDateTime&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                                &lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;@SPName&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@SPName&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;tr bgcolor=#ffaa11&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@IP&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;))&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@DBName&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;)) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@DataTable&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;))&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;
                                &amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@TargetIP&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;))&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@TargetDB&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;NVARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;))&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;SUBSTRING&lt;/span&gt;(&lt;span&gt;@Errmsg&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;)&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;CONVERT&lt;/span&gt;(&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;), &lt;span&gt;GETDATE&lt;/span&gt;(), &lt;span&gt;21&lt;/span&gt;)&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                                &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@Body&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Body&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@SPName&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

                    &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@BODY&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;REPLACE&lt;/span&gt;(&lt;span&gt;@BODY&lt;/span&gt;,&lt;span&gt;''''&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)

                    &lt;/span&gt;&lt;span&gt;IF&lt;/span&gt; &lt;span&gt;REPLACE&lt;/span&gt;(&lt;span&gt;@BODY&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;)&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
                        &lt;span&gt;BEGIN&lt;/span&gt;
                            &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@AllEmailToAddress&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;3000&lt;/span&gt;)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
                            &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@AllEmailCcAddress&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;3000&lt;/span&gt;)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
                            &lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@Allprofile_name&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
                            &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@AllEmailToAddress&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
                            &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@AllEmailCcAddress&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;
                            &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;TOP&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Allprofile_name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;NAME &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; msdb.dbo.sysmail_profile 
                            &lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; profile_id

                            &lt;/span&gt;&lt;span&gt;EXEC&lt;/span&gt; msdb..sp_send_dbmail &lt;span&gt;@profile_name&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@Allprofile_name&lt;/span&gt;   &lt;span&gt;--&lt;/span&gt;&lt;span&gt; profile 名称 &lt;/span&gt;
                             ,&lt;span&gt;@recipients&lt;/span&gt;   &lt;span&gt;=&lt;/span&gt;  &lt;span&gt;@AllEmailToAddress&lt;/span&gt;        &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 收件人邮箱 &lt;/span&gt;
                             ,&lt;span&gt;@copy_recipients&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@AllEmailCcAddress&lt;/span&gt;&lt;span&gt;
                             ,&lt;/span&gt;&lt;span&gt;@subject&lt;/span&gt;      &lt;span&gt;=&lt;/span&gt;  &lt;span&gt;@Subject&lt;/span&gt;                  &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 邮件标题 &lt;/span&gt;
                             ,&lt;span&gt;@body&lt;/span&gt;         &lt;span&gt;=&lt;/span&gt;  &lt;span&gt;@BODY&lt;/span&gt;                     &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 邮件内容 &lt;/span&gt;
                             ,&lt;span&gt;@body_format&lt;/span&gt;  &lt;span&gt;=&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;                    &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 邮件格式 &lt;/span&gt;
                             ,&lt;span&gt;@file_attachments&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;
                             ,&lt;/span&gt;&lt;span&gt;@Importance&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;High&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                        &lt;span&gt;END&lt;/span&gt;     
                      &lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----------    0002 end ------------            &lt;/span&gt;
             &lt;span&gt;END&lt;/span&gt;&lt;span&gt; CATCH          
            &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;

                &lt;span&gt;FETCH&lt;/span&gt; &lt;span&gt;NEXT&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; DBName &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;@IP&lt;/span&gt;, &lt;span&gt;@DBName&lt;/span&gt;, &lt;span&gt;@DataTable&lt;/span&gt;, &lt;span&gt;@TargetIP&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;@TargetDB&lt;/span&gt;, &lt;span&gt;@TargetTable&lt;/span&gt;, &lt;span&gt;@Prerequisite&lt;/span&gt;, &lt;span&gt;@DelMaxQTY&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;@ISCHECKORDERID&lt;/span&gt;, &lt;span&gt;@StartTime&lt;/span&gt;, &lt;span&gt;@EndTime&lt;/span&gt;      
        &lt;span&gt;END&lt;/span&gt;
        
    &lt;span&gt;CLOSE&lt;/span&gt;&lt;span&gt; DBName 
    &lt;/span&gt;&lt;span&gt;DEALLOCATE&lt;/span&gt;&lt;span&gt; DBName

    &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; DELETETABLE &lt;span&gt;CURSOR&lt;/span&gt;
    &lt;span&gt;FOR&lt;/span&gt;
        &lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt;  IP ,
                DBName ,
                DataTable ,
                TargetTable ,
                Prerequisite ,
                DelMaxQTY 
        &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;    &lt;span&gt;[&lt;/span&gt;&lt;span&gt;中央管理器&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;中央管理数据库&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;DBData_ArchiveConfig&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
        &lt;span&gt;WHERE&lt;/span&gt;   DataTable &lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
                &lt;span&gt;AND&lt;/span&gt; TargetTable &lt;span&gt;=&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;
                &lt;span&gt;AND&lt;/span&gt; DBNAME &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;XXXXXXXXX&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;and&lt;/span&gt; SP_Name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;????&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;OPEN&lt;/span&gt;&lt;span&gt; DELETETABLE  
    &lt;/span&gt;&lt;span&gt;FETCH&lt;/span&gt; &lt;span&gt;NEXT&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; DELETETABLE &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;@IP&lt;/span&gt;, &lt;span&gt;@DBName&lt;/span&gt;, &lt;span&gt;@DataTable&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;@TargetTable&lt;/span&gt;, &lt;span&gt;@Prerequisite&lt;/span&gt;, &lt;span&gt;@DelMaxQTY&lt;/span&gt;
    &lt;span&gt;WHILE&lt;/span&gt; ( &lt;span&gt;@@fetch_status&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; )
        &lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;
          &lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@sql1&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DECLARE @icount INTEGER  
                                    SELECT @icount = COUNT(1)  
                                    FROM &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DBName&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DataTable&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                                    where &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@Prerequisite&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;  
                                    WHILE @icount &amp;gt; 0   
                                    BEGIN  
                    
                                        DELETE TOP (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@DelMaxQTY&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;)) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
                                        FROM &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DBName&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dbo.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@DataTable&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt; 
                                        where &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;@Prerequisite&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;
      
                                        SET @icount = @icount -(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                                                &lt;span&gt;+&lt;/span&gt; &lt;span&gt;CAST&lt;/span&gt;(&lt;span&gt;@DelMaxQTY&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;)) &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
                                        WAITFOR DELAY &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;00:00:01&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;  
                                    END  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                        &lt;span&gt;PRINT&lt;/span&gt; &lt;span&gt;@sql1&lt;/span&gt;
                        &lt;span&gt;EXEC&lt;/span&gt; (&lt;span&gt;@sql1&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;FETCH&lt;/span&gt; &lt;span&gt;NEXT&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; DELETETABLE &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;@IP&lt;/span&gt;, &lt;span&gt;@DBName&lt;/span&gt;, &lt;span&gt;@DataTable&lt;/span&gt;,&lt;span&gt;@TargetTable&lt;/span&gt;, &lt;span&gt;@Prerequisite&lt;/span&gt;, &lt;span&gt;@DelMaxQTY&lt;/span&gt;
        &lt;span&gt;END&lt;/span&gt; 
    &lt;span&gt;CLOSE&lt;/span&gt;&lt;span&gt; DELETETABLE 
    &lt;/span&gt;&lt;span&gt;DEALLOCATE&lt;/span&gt;&lt;span&gt; DELETETABLE

&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五.补充数据&lt;/h2&gt;
&lt;p&gt;1.数据库归档，一般都是先将当前库的历史数据归档到历史库，再将当前库的历史数据删除。这两个阶段，一般是前者耗时较多（一般都在2:1以上），虽然可以在select 过程加上nolock，但是或者I/O或者网络等原因，其实这个阶段对应用程序的影响还是比较大的。所以，建议将这两个阶段物理分开，即如果有配置AlwaysOn，请将第一个阶段在辅助数据库中执行。上面的SP示例，就是通过参数 @BakDateIP 来实现了这一作用。&lt;/p&gt;
&lt;p&gt;2.存储过程中包含了try...catch，所以运行此sp就会很少报错，某一个表的异常不会相互影响。例如，我们常见的当前库、历史库由于表结构变更而导致的不一致，此情况出现后，try..catch可以捕捉到异常，将异常记录在档，并将此信息以邮件的形式发送给指定人，但整个SP不会执行失败。并且还会跳过这一个异常，继续执行下一个备份归档表的归档。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载,谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 14:44:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>一.需求背景 SQL Server开源的归档工具不多，DBA一般都是通过计划任务来触发执行，执行的脚本多是SP或者是SSIS包。SSIS包的性能稍好一些，但是维护更新成本高些。所以更常见的是通过SP脚</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/10168858.html</dc:identifier>
</item>
<item>
<title>koa2入门使用总结 - fozero</title>
<link>http://www.cnblogs.com/fozero/p/10171322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fozero/p/10171322.html</guid>
<description>&lt;h3 id=&quot;koa2的介绍&quot;&gt;koa2的介绍&lt;/h3&gt;
&lt;p&gt;Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。&lt;/p&gt;
&lt;h3 id=&quot;koa2安装&quot;&gt;koa2安装&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;npm install koa&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;koa-middleware&quot;&gt;koa middleware&lt;/h3&gt;
&lt;p&gt;每收到一个http请求，koa就会调用通过app.use()注册的async函数，并传入ctx和next参数&lt;br/&gt;middleware的顺序很重要，也就是调用app.use()的顺序决定了middleware的顺序&lt;/p&gt;
&lt;p&gt;对于await next()，如果一个middleware没有调用，则后续的middleware将不再执行了，使用场景&lt;br/&gt;如，一个检测用户权限的middleware可以决定是否继续处理请求，还是直接返回403错误&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.use(async (ctx, next) =&amp;gt; {
    if (await checkUserPermission(ctx)) {
        await next();
    } else {
        ctx.response.status = 403;
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ctx简写&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ctx.url相当于ctx.request.url，ctx.type相当于ctx.response.type&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;url处理-使用koa-router&quot;&gt;url处理 ，使用koa-router&lt;/h3&gt;
&lt;p&gt;安装koa-router&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install koa-router&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 注意require('koa-router')返回的是函数:
const router = require('koa-router')();

这里导入koa-router的语句最后的()是函数调用
const router = require('koa-router')();
相当于 
const fn_router = require('koa-router');
const router = fn_router();


// add url-route:
router.get('/hello/:name', async (ctx, next) =&amp;gt; {
    var name = ctx.params.name;
    ctx.response.body = `&amp;lt;h1&amp;gt;Hello, ${name}!&amp;lt;/h1&amp;gt;`;
});

router.get('/', async (ctx, next) =&amp;gt; {
    ctx.response.body = '&amp;lt;h1&amp;gt;Index&amp;lt;/h1&amp;gt;';
});

// add router middleware:
app.use(router.routes());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们在访问http://localhost:3000/hello/kerry时会打印hello，kerry&lt;/p&gt;
&lt;h3 id=&quot;处理post请求&quot;&gt;处理post请求&lt;/h3&gt;
&lt;p&gt;post请求通常会发送一个表单，或者JSON，它作为request的body发送，但无论是Node.js提供的原始request对象，还是koa提供的request对象，都不提供解析request的body的功能，所以我们需要用到koa-bodyparser中间件来解析request的body&lt;/p&gt;
&lt;p&gt;安装koa-bodyparser&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install koa-bodyparser&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;const bodyParser = require('koa-bodyparser');

// 解决body 需在router之前注册到app对象上
app.use(bodyParser());


这样我们就可以处理post请求了
router.get('/', async (ctx, next) =&amp;gt; {
    ctx.response.body = `&amp;lt;h1&amp;gt;Index&amp;lt;/h1&amp;gt;
        &amp;lt;form action=&quot;/signin&quot; method=&quot;post&quot;&amp;gt;
            &amp;lt;p&amp;gt;Name: &amp;lt;input name=&quot;name&quot; value=&quot;koa&quot;&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;Password: &amp;lt;input name=&quot;password&quot; type=&quot;password&quot;&amp;gt;&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;&amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;/form&amp;gt;`;
});

router.post('/signin', async (ctx, next) =&amp;gt; {
    var
        name = ctx.request.body.name || '',
        password = ctx.request.body.password || '';
    console.log(`signin with name: ${name}, password: ${password}`);
    if (name === 'koa' &amp;amp;&amp;amp; password === '12345') {
        ctx.response.body = `&amp;lt;h1&amp;gt;Welcome, ${name}!&amp;lt;/h1&amp;gt;`;
    } else {
        ctx.response.body = `&amp;lt;h1&amp;gt;Login failed!&amp;lt;/h1&amp;gt;
        &amp;lt;p&amp;gt;&amp;lt;a href=&quot;/&quot;&amp;gt;Try again&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;`;
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码优化&quot;&gt;代码优化&lt;/h3&gt;
&lt;p&gt;所有的代码都放在了app.js中&lt;br/&gt;我们可以单独将所有路由放到一个js文件中，如果是复杂系统，还可以按模块建立多个路由文件，如&lt;br/&gt;user.js(处理用户管理相关url)、login.js（处理用户登录相关url）&lt;/p&gt;
&lt;h3 id=&quot;静态资源&quot;&gt;静态资源&lt;/h3&gt;
&lt;p&gt;安装koa-static&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install koa-static&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;const static = require('koa-static')
const path = require('path')

// 静态资源目录
app.use(static(
  path.join( __dirname,'./static')
));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在根目录下建立static文件夹，新建一个json文件，输入如下地址访问&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:3000/china.geojson&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;art-template模板引擎&quot;&gt;art-template模板引擎&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;npm install --save art-template
npm install --save koa-art-template


// 模板引擎
const render = require('koa-art-template');

render(app, {
  root: path.join(__dirname, './static'),
  extname: '.html',
  // debug: process.env.NODE_ENV !== 'production'
});

// 使用ctx.render渲染页面 可传递数据
router.get('/user', async (ctx, next) =&amp;gt; {
    ctx.render('user',{
            data:'hello msg'
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;html中渲染数据 {{data}}&lt;/p&gt;
&lt;p&gt;更多用法查看&lt;br/&gt;&lt;a href=&quot;https://aui.github.io/art-template/zh-cn/docs/index.html&quot; class=&quot;uri&quot;&gt;https://aui.github.io/art-template/zh-cn/docs/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;koa2-跨域请求设置&quot;&gt;koa2 跨域请求设置&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;https://github.com/zadzbw/koa2-cors
npm install --save koa2-cors

var cors = require('koa2-cors');
app.use(cors());&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;开发部署-使用nodemon在本地开发环境下自动重启项目&quot;&gt;开发部署 ，使用nodemon在本地开发环境下自动重启项目&lt;/h3&gt;
&lt;p&gt;1、 项目搭建好后，通过node运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;node app.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以在package.json中添加scripts&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;scripts&quot;: {
    &quot;start&quot;: &quot;node app.js&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就可以运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm run start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后访问http://localhost:3000&lt;/p&gt;
&lt;p&gt;2、 通过nodemon来运行项目&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install -g nodemon&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后用 nodemon 来代替 node 来启动应用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nodemon app.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、 如果是在线上 我们则使用pm2来管理应用程序，&lt;br/&gt;pm2 是一个带有负载均衡功能的Node应用的进程管理器.当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/lxg0/p/7771229.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lxg0/p/7771229.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;通过以上简单介绍对koa2使用，我搭建了一个koa2本地静态node服务器，已上传至github，欢迎大家star或clone&lt;br/&gt;&lt;a href=&quot;https://github.com/fozero/koa2-server&quot;&gt;koa2-server&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Dec 2018 14:15:00 +0000</pubDate>
<dc:creator>fozero</dc:creator>
<og:description>koa2的介绍 Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fozero/p/10171322.html</dc:identifier>
</item>
</channel>
</rss>