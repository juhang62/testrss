<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>bluetooth(蓝牙) AVRCP协议概念及代码流程解析 - 虚生</title>
<link>http://www.cnblogs.com/dylancao/p/11535985.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dylancao/p/11535985.html</guid>
<description>&lt;p&gt;一 概念&lt;/p&gt;
&lt;p data-line=&quot;6&quot;&gt;　　AVRCP全称：The Audio/Video Remote Control Profile (AVRCP) 翻译成中文就是：音视频远程控制协议。&lt;br/&gt;概念：AVRCP定义了蓝牙设备之间的音视频传输的特点和流程，来确保不同蓝牙设备之间音视频传输控制的兼容。一般包括暂停，停止，播放，音量控制等远程控制操作。例如，使用蓝牙耳机可以暂停，切换下一曲等操作来控制音乐播放器。&lt;/p&gt;
&lt;p data-line=&quot;10&quot;&gt;基本角色：avrcp是两个设备之间的音视频控制协议。这就需要定义好角色。一般主动发起的称为控制端，简称(CT),通过发送一些AT命令帧来初始化基本流程。一般情况下，CT经常是个人电脑，手机，或者是手持设备。目标设备（简称TG）一般是接收到一个CT发来的帧并返回一个回应帧。TG一般是音视频播放设备，比如，耳机，音响等。常见的流程如下图所示：&lt;/p&gt;
&lt;p data-line=&quot;10&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003156/201909/1003156-20190917183210499-556883640.png&quot; alt=&quot;&quot; width=&quot;758&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;-1&quot; data-line=&quot;17&quot;&gt;二 流程分析&lt;/h4&gt;
&lt;p data-line=&quot;19&quot;&gt;　　avrcp是蓝牙应用层的协议，下面一张图很好的呈现了它在整个蓝牙协议栈中的位置：从这里可以看出，ARVCP的下面还有一个被称为AVRTP的协议，其实，它就是AVRCP的底层传输协议，可以理解成是AVRCP和a2dp之间的适配层。&lt;/p&gt;
&lt;p data-line=&quot;19&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003156/201909/1003156-20190917183430951-798982776.png&quot; alt=&quot;&quot; width=&quot;628&quot; height=&quot;340&quot;/&gt;　　&lt;/p&gt;
&lt;p data-line=&quot;19&quot;&gt;　　接下来看一下收发流程是什么样的，下面一个图很好的诠释了它的创建和收发流程。如果连接没有创建，CT应该会主动发起连接建立的动作。一旦连接建立，它就可以发送AV/C 命令了。&lt;/p&gt;
&lt;p data-line=&quot;19&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1003156/201909/1003156-20190917183249953-297575122.png&quot; alt=&quot;&quot; width=&quot;922&quot; height=&quot;431&quot;/&gt;&lt;/p&gt;
&lt;p data-line=&quot;19&quot;&gt;　　&lt;strong&gt;注意：&lt;/strong&gt;AV/C interim response 只会在接收到VENDOR DEPENDENT command的情况下才会被TG发送。&lt;br/&gt;　　在有些异常的情况下，TG可能不会对回复CT的response帧。&lt;/p&gt;
&lt;h4 id=&quot;-2&quot; data-line=&quot;29&quot;&gt;三 代码分析&lt;/h4&gt;
&lt;p data-line=&quot;31&quot;&gt;　　其实，代码流程就是围绕者协议栈流程来的，假如你懂了协议栈的基本流程，就很容易看懂了。协议栈的流程如下：&lt;/p&gt;
&lt;p data-line=&quot;33&quot;&gt;注册并创建连接：&lt;/p&gt;
&lt;p data-line=&quot;33&quot;&gt;　　注册状态：BtStatus AVRCP_Register&lt;br/&gt;　　CT创建连接：AVRCP_Connect&lt;br/&gt;　　TG回复连接成功：AVRCP_ConnectRsp&lt;/p&gt;
&lt;p data-line=&quot;33&quot;&gt;发送命令：&lt;/p&gt;
&lt;p data-line=&quot;33&quot;&gt;　　发送的命令函数：BtStatus AVRCP_SendCommand(AvrcpChannel *chnl, AvrcpCmdFrame *cmdFrame);&lt;br/&gt;　　回复的命令函数：BtStatus AVRCP_SendResponse(AvrcpChannel *chnl, AvrcpRspFrame *rspFrame);&lt;/p&gt;
&lt;p data-line=&quot;45&quot;&gt;断开连接：&lt;/p&gt;
&lt;p data-line=&quot;47&quot;&gt;　　BtStatus AVRCP_Disconnect(AvrcpChannel *chnl);即可&lt;/p&gt;
&lt;h4 id=&quot;-3&quot; data-line=&quot;51&quot;&gt;四 自问自答&lt;/h4&gt;
&lt;p data-line=&quot;53&quot;&gt;1 AvrcpTxTimeout 作用是什么？&lt;br/&gt;　　发送命令的超时函数，假如超时，就上报发送失败的命令。&lt;br/&gt;2 Avrcp Browse的作用是什么？&lt;br/&gt;　　用于浏览TG上的播放文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五 参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　关于蓝牙的资料我都放在github上了，需要的朋友可以直接去下载，完全免费，记得下载时候给我点个赞就行了。&lt;/p&gt;
&lt;p&gt;github地址链接：&lt;a href=&quot;https://github.com/DyLanCao/bluetooth.git&quot; target=&quot;_blank&quot;&gt;https://github.com/DyLanCao/bluetooth.git&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 18 Sep 2019 00:24:00 +0000</pubDate>
<dc:creator>虚生</dc:creator>
<og:description>一 概念 AVRCP全称：The Audio/Video Remote Control Profile (AVRCP) 翻译成中文就是：音视频远程控制协议。概念：AVRCP定义了蓝牙设备之间的音视频传</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dylancao/p/11535985.html</dc:identifier>
</item>
<item>
<title>Golang error 的突围 - Stefno</title>
<link>http://www.cnblogs.com/qcrao-2018/p/11538387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcrao-2018/p/11538387.html</guid>
<description>&lt;p&gt;写过 C 的同学知道，C 语言中常常返回整数错误码（errno）来表示函数处理出错，通常用 &lt;code&gt;-1&lt;/code&gt; 来表示错误，用 &lt;code&gt;0&lt;/code&gt; 表示正确。&lt;/p&gt;
&lt;p&gt;而在 Go 中，我们使用 &lt;code&gt;error&lt;/code&gt; 类型来表示错误，不过它不再是一个整数类型，是一个接口类型：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type error interface {
    Error() string
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它表示那些能用一个字符串就能说清的错误。&lt;/p&gt;
&lt;p&gt;我们最常用的就是 &lt;code&gt;errors.New()&lt;/code&gt; 函数，非常简单：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// src/errors/errors.go

func New(text string) error {
    return &amp;amp;errorString{text}
}

type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 New 函数创建出来的 error 类型实际上是 errors 包里未导出的 &lt;code&gt;errorString&lt;/code&gt; 类型，它包含唯一的一个字段 &lt;code&gt;s&lt;/code&gt;，并且实现了唯一的方法：&lt;code&gt;Error() string&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通常这就够了，它能反映当时“出错了”，但是有些时候我们需要更加具体的信息，例如：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func Sqrt(f float64) (float64, error) {
    if f &amp;lt; 0 {
        return 0, errors.New(&quot;math: square root of negative number&quot;)
    }
    // implementation
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当调用者发现出错的时候，只知道传入了一个负数进来，并不清楚到底传的是什么值。在 Go 里：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;It is the error implementation's responsibility to summarize the context.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它要求返回这个错误的函数要给出具体的“上下文”信息，也就是说，在 &lt;code&gt;Sqrt&lt;/code&gt; 函数里，要给出这个负数到底是什么。&lt;/p&gt;
&lt;p&gt;所以，如果发现 &lt;code&gt;f&lt;/code&gt; 小于 0，应该这样返回错误：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;if f &amp;lt; 0 {
    return 0, fmt.Errorf(&quot;math: square root of negative number %g&quot;, f)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就用到了 &lt;code&gt;fmt.Errorf&lt;/code&gt; 函数，它先将字符串格式化，再调用 &lt;code&gt;errors.New&lt;/code&gt; 函数来创建错误。&lt;/p&gt;
&lt;p&gt;当我们想知道错误类型，并且打印错误的时候，直接打印 error：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;fmt.Println(err)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;fmt.Println(err.Error)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;fmt&lt;/code&gt; 包会自动调用 &lt;code&gt;err.Error()&lt;/code&gt; 函数来打印字符串。&lt;/p&gt;
&lt;p&gt;通常，我们将 error 放到函数返回值的最后一个，没什么好说的，大家都这样做，约定俗成。&lt;/p&gt;
&lt;p&gt;参考资料【Tony Bai】这篇文章提到，构造 error 的时候，要求传入的字符串首字母小写，结尾不带标点符号，这是因为我们经常会这样使用返回的 error：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;... err := errors.New(&quot;error example&quot;)
fmt.Printf(&quot;The returned error is %s.\n&quot;, err)&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;In Go, error handling is important. The language's design and conventions encourage you to explicitly check for errors where they occur (as distinct from the convention in other languages of throwing exceptions and sometimes catching them).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Go 语言中，错误处理是非常重要的。它从语言层面要求我们需要明确地处理遇到的错误。而不是像其他语言，类如 Java，使用 &lt;code&gt;try-catch- finally&lt;/code&gt; 这种“把戏”。&lt;/p&gt;
&lt;p&gt;这就造成代码里 “error” 满天飞，显得非常冗长拖沓。&lt;/p&gt;
&lt;p&gt;而为了代码健壮性考虑，对于函数返回的每一个错误，我们都不能忽略它。因为出错的同时，很可能会返回一个 &lt;code&gt;nil&lt;/code&gt; 类型的对象。如果不对错误进行判断，那下一行对 &lt;code&gt;nil&lt;/code&gt; 对象的操作百分之百会引发一个 &lt;code&gt;panic&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这样，Go 语言中诟病最多的就是它的错误处理方式似乎回到了上古 C 语言时代。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;rr := doStuff1()
if err != nil {
    //handle error...
}

err = doStuff2()
if err != nil {
    //handle error...
}

err = doStuff3()
if err != nil {
    //handle error...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Go authors 之一的 Russ Cox 对于这种观点进行过驳斥：当初选择返回值这种错误处理机制而不是 try-catch，主要是考虑前者适用于大型软件，后者更适合小程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在参考资料【Go FAQ】里也提到，&lt;code&gt;try-catch&lt;/code&gt; 会让代码变得非常混乱，程序员会倾向将一些常见的错误，例如，&lt;code&gt;failing to open a file&lt;/code&gt;，也抛到异常里，这会让错误处理更加冗长繁琐且易出错。&lt;/p&gt;
&lt;p&gt;而 Go 语言的多返回值使得返回错误异常简单。对于真正的异常，Go 提供 &lt;code&gt;panic-recover&lt;/code&gt; 机制，也使得代码看起来非常简洁。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当然 Russ Cox 也承认 Go 的错误处理机制对于开发人员的确有一定的心智负担。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考资料【Go 语言的错误处理机制是一个优秀的设计吗？】是知乎上的一个回答，阐述了 Go 对待错误和异常的不同处理方式，前者使用 error，后者使用 panic，这样的处理比较 Java 那种错误异常一锅端的做法更有优势。&lt;/p&gt;
&lt;p&gt;【如何优雅的在Golang中进行错误处理】对于在业务上如何处理 error，给出了一些很好的示例。&lt;/p&gt;

&lt;p&gt;这部分的内容主要来自 Dave cheney GoCon 2016 的演讲，参考资料可以直达原文。&lt;/p&gt;
&lt;p&gt;经常听到 Go 有很多“箴言”，说得很顺口，但理解起来并不是太容易，因为它们大部分都是有故事的。例如，我们常说：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Don't communicating by sharing memory, share memory by communicating.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文中还列举了很多，都很有意思：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/64576578-d355e180-d3ab-11e9-8e99-34222a3994f1.png&quot; alt=&quot;go proverbs&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们讲三条关于 error 的“箴言”。&lt;/p&gt;
&lt;h2 id=&quot;errors-are-just-values&quot;&gt;Errors are just values&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Errors are just values&lt;/code&gt; 的实际意思是只要实现了 &lt;code&gt;Error&lt;/code&gt; 接口的类型都可以认为是 &lt;code&gt;Error&lt;/code&gt;，重要的是要理解这些“箴言”背后的道理。&lt;/p&gt;
&lt;p&gt;作者把处理 error 的方式分为三种：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;Sentinel errors&lt;/li&gt;
&lt;li&gt;Error Types&lt;/li&gt;
&lt;li&gt;Opaque errors&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;我们来挨个说。首先 &lt;code&gt;Sentinel errors&lt;/code&gt;，Sentinel 来自计算机中常用的词汇，中文意思是“哨兵”。以前在学习快排的时候，会有一个“哨兵”，其他元素都要和“哨兵”进行比较，它划出了一条界限。&lt;/p&gt;
&lt;p&gt;这里 &lt;code&gt;Sentinel errors&lt;/code&gt; 实际想说的是这里有一个错误，暗示处理流程不能再进行下去了，必须要在这里停下，这也是一条界限。而这些错误，往往是提前约定好的。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;io&lt;/code&gt; 包里的 &lt;code&gt;io.EOF&lt;/code&gt;，表示“文件结束”错误。但是这种方式处理起来，不太灵活：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    r := bytes.NewReader([]byte(&quot;0123456789&quot;))
    
    _, err := r.Read(make([]byte, 10))
    if err == io.EOF {
        log.Fatal(&quot;read failed:&quot;, err)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;必须要判断 &lt;code&gt;err&lt;/code&gt; 是否和约定好的错误 &lt;code&gt;io.EOF&lt;/code&gt; 相等。&lt;/p&gt;
&lt;p&gt;再来一个例子，当我想返回 err 并且加上一些上下文信息时，就麻烦了：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    err := readfile(“.bashrc”)
    if strings.Contains(error.Error(), &quot;not found&quot;) {
        // handle error
    }
}

func readfile(path string) error {
    err := openfile(path)
    if err != nil {
        return fmt.Errorf(“cannot open file: %v&quot;, err)
    }
    // ……
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;readfile&lt;/code&gt; 函数里判断 err 不为空，则用 fmt.Errorf 在 err 前加上具体的 &lt;code&gt;file&lt;/code&gt; 信息，返回给调用者。返回的 err 其实还是一个字符串。&lt;/p&gt;
&lt;p&gt;造成的后果时，调用者不得不用字符串匹配的方式判断底层函数 &lt;code&gt;readfile&lt;/code&gt; 是不是出现了某种错误。当你必须要这样才能判断某种错误时，代码的“坏味道”就出现了。&lt;/p&gt;
&lt;p&gt;顺带说一句，&lt;code&gt;err.Error()&lt;/code&gt; 方法是给程序员而非代码设计的，也就是说，当我们调用 &lt;code&gt;Error&lt;/code&gt; 方法时，结果要写到文件或是打印出来，是给程序员看的。在代码里，我们不能根据 &lt;code&gt;err.Error()&lt;/code&gt; 来做一些判断，就像上面的 &lt;code&gt;main&lt;/code&gt; 函数里做的那样，不好。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sentinel errors&lt;/code&gt; 最大的问题在于它在定义 error 和使用 error 的包之间建立了依赖关系。比如要想判断 &lt;code&gt;err == io.EOF&lt;/code&gt; 就得引入 io 包，当然这是标准库的包，还 Ok。如果很多用户自定义的包都定义了错误，那我就要引入很多包，来判断各种错误。麻烦来了，这容易引起循环引用的问题。&lt;/p&gt;
&lt;p&gt;因此，我们应该尽量避免 &lt;code&gt;Sentinel errors&lt;/code&gt;，仅管标准库中有一些包这样用，但建议还是别模仿。&lt;/p&gt;
&lt;p&gt;第二种就是 &lt;code&gt;Error Types&lt;/code&gt;，它指的是实现了 &lt;code&gt;error&lt;/code&gt; 接口的那些类型。它的一个重要的好处是，类型中除了 error 外，还可以附带其他字段，从而提供额外的信息，例如出错的行数等。&lt;/p&gt;
&lt;p&gt;标准库有一个非常好的例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// PathError records an error and the operation and file path that caused it.
type PathError struct {
    Op   string
    Path string
    Err  error
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PathError&lt;/code&gt; 额外记录了出错时的文件路径和操作类型。&lt;/p&gt;
&lt;p&gt;通常，使用这样的 error 类型，外层调用者需要使用类型断言来判断错误：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// underlyingError returns the underlying error for known os error types.
func underlyingError(err error) error {
    switch err := err.(type) {
    case *PathError:
        return err.Err
    case *LinkError:
        return err.Err
    case *SyscallError:
        return err.Err
    }
    return err
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这又不可避免地在定义错误和使用错误的包之间形成依赖关系，又回到了前面的问题。&lt;/p&gt;
&lt;p&gt;即使 &lt;code&gt;Error types&lt;/code&gt; 比 &lt;code&gt;Sentinel errors&lt;/code&gt; 好一些，因为它能承载更多的上下文信息，但是它仍然存在引入包依赖的问题。因此，也是不推荐的。至少，不要把 &lt;code&gt;Error types&lt;/code&gt; 作为一个导出类型。&lt;/p&gt;
&lt;p&gt;最后一种，&lt;code&gt;Opaque errors&lt;/code&gt;。翻译一下，就是“黑盒 errors”，因为你能知道错误发生了，但是不能看到它内部到底是什么。&lt;/p&gt;
&lt;p&gt;譬如下面这段伪代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func fn() error {
    x, err := bar.Foo()
    if err != nil {
        return err
    }
    
    // use x
    return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为调用者，调用完 &lt;code&gt;Foo&lt;/code&gt; 函数后，只用知道 &lt;code&gt;Foo&lt;/code&gt; 是正常工作还是出了问题。也就是说你只需要判断 err 是否为空，如果不为空，就直接返回错误。否则，继续后面的正常流程，不需要知道 err 到底是什么。&lt;/p&gt;
&lt;p&gt;这就是处理 &lt;code&gt;Opaque errors&lt;/code&gt; 这种类型错误的策略。&lt;/p&gt;
&lt;p&gt;当然，在某些情况下，这样做并不够用。例如，在一个网络请求中，需要调用者判断返回的错误类型，以此来决定是否重试。这种情况下，作者给出了一种方法：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;In this case rather than asserting the error is a specific type or value, we can assert that the error implements a particular behaviour.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是说，不去判断错误的类型到底是什么，而是去判断错误是否具有某种行为，或者说实现了某个接口。&lt;/p&gt;
&lt;p&gt;来个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type temporary interface {
    Temporary() bool
}

func IsTemporary(err error) bool {
    te, ok := err.(temporary)
    return ok &amp;amp;&amp;amp; te.Temporary()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿到网络请求返回的 error 后，调用 &lt;code&gt;IsTemporary&lt;/code&gt; 函数，如果返回 true，那就重试。&lt;/p&gt;
&lt;p&gt;这么做的好处是在进行网络请求的包里，不需要 &lt;code&gt;import&lt;/code&gt; 引用定义错误的包。&lt;/p&gt;
&lt;h2 id=&quot;handle-not-just-check-errors&quot;&gt;handle not just check errors&lt;/h2&gt;
&lt;p&gt;这一节要说第二句箴言：“Don't just check errors, handle them gracefully”。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func AuthenticateRequest(r *Request) error {
     err := authenticate(r.User)
     if err != nil {
        return err
     }
     return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这个例子中的代码是有问题的，直接优化成一句就可以了：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func AuthenticateRequest(r *Request) error {
     return authenticate(r.User)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有其他的问题，在函数调用链的最顶层，我们得到的错误可能是：&lt;code&gt;No such file or directory&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个错误反馈的信息太少了，不知道文件名、路径、行号等等。&lt;/p&gt;
&lt;p&gt;尝试改进一下，增加一点上下文：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func AuthenticateRequest(r *Request) error {
     err := authenticate(r.User)
     if err != nil {
        return fmt.Errorf(&quot;authenticate failed: %v&quot;, err)
     }
     return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种做法实际上是先错误转换成字符串，再拼接另一个字符串，最后，再通过 &lt;code&gt;fmt.Errorf&lt;/code&gt; 转换成错误。这样做破坏了相等性检测，即我们无法判断错误是否是一种预先定义好的错误了。&lt;/p&gt;
&lt;p&gt;应对方案是使用第三方库：&lt;code&gt;github.com/pkg/errors&lt;/code&gt;。提供了友好的界面：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// Wrap annotates cause with a message.
func Wrap(cause error, message string) error
// Cause unwraps an annotated error.
func Cause(err error) error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;Wrap&lt;/code&gt; 可以将一个错误，加上一个字符串，“包装”成一个新的错误；通过 &lt;code&gt;Cause&lt;/code&gt; 则可以进行相反的操作，将里层的错误还原。&lt;/p&gt;
&lt;p&gt;有了这两个函数，就方便很多：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func ReadFile(path string) ([]byte, error) {
    f, err := os.Open(path)
    if err != nil {
        return nil, errors.Wrap(err, &quot;open failed&quot;)
    }
    defer f.Close()
    
    buf, err := ioutil.ReadAll(f)
    if err != nil {
        return nil, errors.Wrap(err, &quot;read failed&quot;)
    }
    return buf, nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个读文件的函数，先尝试打开文件，如果出错，则返回一个附加上了 “open failed” 的错误信息；之后，尝试读文件，如果出错，则返回一个附加上了 “read failed” 的错误。&lt;/p&gt;
&lt;p&gt;当在外层调用 &lt;code&gt;ReadFile&lt;/code&gt; 函数时：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    _, err := ReadConfig()
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
}

func ReadConfig() ([]byte, error) {
    home := os.Getenv(&quot;HOME&quot;)
    config, err := ReadFile(filepath.Join(home, &quot;.settings.xml&quot;))
    return config, errors.Wrap(err, &quot;could not read config&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们在 main 函数里就能打印出这样一个错误信息：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它是有层次的，非常清晰。而如果我们用 &lt;code&gt;pkg/errors&lt;/code&gt; 库提供的打印函数：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main() {
    _, err := ReadConfig()
    if err != nil {
        errors.Print(err)
        os.Exit(1)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;能得到更有层次、更详细的错误：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;readfile.go:27: could not read config
readfile.go:14: open failed
open /Users/dfc/.settings.xml: no such file or directory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面讲的是 &lt;code&gt;Wrap&lt;/code&gt; 函数，接下来看一下 “Cause” 函数，以前面提到的 &lt;code&gt;temporary&lt;/code&gt; 接口为例：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type temporary interface {
    Temporary() bool
}

// IsTemporary returns true if err is temporary.
func IsTemporary(err error) bool {
    te, ok := errors.Cause(err).(temporary)
    return ok &amp;amp;&amp;amp; te.Temporary()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判断之前先使用 &lt;code&gt;Cause&lt;/code&gt; 取出错误，做断言，最后，递归地调用 &lt;code&gt;Temporary&lt;/code&gt; 函数。如果错误没实现 &lt;code&gt;temporary&lt;/code&gt; 接口，就会断言失败，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;only-handle-errors-once&quot;&gt;Only handle errors once&lt;/h2&gt;
&lt;p&gt;什么叫“处理”错误：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Handling an error means inspecting the error value, and making a decision.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思是查看了一下错误，并且做出一个决定。&lt;/p&gt;
&lt;p&gt;例如，如果不做任何决定，相当于忽略了错误：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func Write(w io.Writer, buf []byte) {  w.Write(buf) 
    w.Write(buf) 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;w.Write(buf) &lt;/code&gt; 会返回两个结果，一个表示写成功的字节数，一个是 error，上面的例子中没有对这两个返回值做任何处理。&lt;/p&gt;
&lt;p&gt;下面这个例子却又处理了两次错误：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func Write(w io.Writer, buf []byte) error {  
     _, err := w.Write(buf) 
    if err != nil { 
        // annotated error goes to log file 
        log.Println(&quot;unable to write:&quot;, err)
     
        // unannotated error returned to caller  return err 
        return err
    } 
    return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次处理是将错误写进了日志，第二次处理则是将错误返回给上层调用者。而调用者也可能将错误写进日志或是继续返回给上层。&lt;/p&gt;
&lt;p&gt;这样一来，日志文件中会有很多重复的错误描述，并且在最上层调用者（如 main 函数）看来，它拿到的错误却还是最底层函数返回的 error，没有任何上下文信息。&lt;/p&gt;
&lt;p&gt;使用第三方的 error 包就可以比较完美的解决问题：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func Write(w io.Write, buf []byte) error { 
    _, err := w.Write(buf) 
    return errors.Wrap(err, &quot;write failed&quot;) 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回的错误，对于人和机器而言，都是友好的。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;这一部分主要讲了处理 error 的一些原则，引入了第三方的 errors 包，使得错误处理变得更加优雅。&lt;/p&gt;
&lt;p&gt;作者最后给出了一些结论：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;errors 就像对外提供的 API 一样，需要认真对待。&lt;/li&gt;
&lt;li&gt;将 errors 看成黑盒，判断它的行为，而不是类型。&lt;/li&gt;
&lt;li&gt;尽量不要使用 sentinel errors。&lt;/li&gt;
&lt;li&gt;使用第三方的错误包来包裹 error（errors.Wrap），使得它更好用。&lt;/li&gt;
&lt;li&gt;使用 errors.Cause 来获取底层的错误。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;p&gt;之前已经出现用 “check &amp;amp; handle” 关键字和 “try 内置函数”改进错误处理流程的提案，目前 try 内置函数的提案已经被官方提前拒绝，原因是社区里一边倒地反对声音。&lt;/p&gt;
&lt;p&gt;关于这两个提案的具体内容见参考资料【check &amp;amp; handle】和【try 提案】。&lt;/p&gt;

&lt;p&gt;有一些 Go 语言失败的尝试，比如 Go 1.5 引入的 vendor 和 internal 来管理包，最后被滥用而引发了很多问题。因此 Go 1.13 直接抛弃了 &lt;code&gt;GOPATH&lt;/code&gt; 和 &lt;code&gt;vendor&lt;/code&gt; 特性，改用 &lt;code&gt;module&lt;/code&gt; 来管理包。&lt;/p&gt;
&lt;p&gt;柴大在《Go 语言十年而立，Go2 蓄势待发》一文中表示：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;比如最近 Go 语言之父之一 Robert Griesemer 提交的通过 try 内置函数来简化错误处理就被否决了。失败的尝试是一个好的现象，它表示 Go 语言依然在一些新兴领域的尝试 —— Go 语言依然处于活跃期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今年 9 月 3 号，Go 发布 1.13 版本，除了 module 特性转正之外，还改进了数字字面量。比较重要的还有 defer 性能提升 30%，将更多的对象从堆上移动到栈上以提升性能，等等。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;还有一个重大的改进发生在 errors 标准库中。errors 库增加了 Is/As/Unwrap三个函数，这将用于支持错误的再次包装和识别处理，为 Go 2 中新的错误处理改进提前做准备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;1.13&lt;/code&gt; 支持了 &lt;code&gt;error&lt;/code&gt; 包裹（wrapping）：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;An error e can wrap another error w by providing an Unwrap method that returns w. Both e and w are available to programs, allowing e to provide additional context to w or to reinterpret it while still allowing programs to make decisions based on w.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了支持 wrapping，&lt;code&gt;fmt.Errorf&lt;/code&gt; 增加了 &lt;code&gt;%w&lt;/code&gt; 的格式，并且在 &lt;code&gt;error&lt;/code&gt; 包增加了三个函数：&lt;code&gt;errors.Unwrap&lt;/code&gt;，&lt;code&gt;errors.Is&lt;/code&gt;，&lt;code&gt;errors.As&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;fmt.errorf&quot;&gt;fmt.Errorf&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;fmt.Errorf&lt;/code&gt; 加上 &lt;code&gt;%w&lt;/code&gt; 格式符来生成一个嵌套的 error，它并没有像 &lt;code&gt;pkg/errors&lt;/code&gt; 那样使用一个 Wrap 函数来嵌套 error，非常简洁。&lt;/p&gt;
&lt;h2 id=&quot;unwrap&quot;&gt;Unwrap&lt;/h2&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func Unwrap(err error) error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将嵌套的 error 解析出来，多层嵌套需要调用 &lt;code&gt;Unwrap&lt;/code&gt; 函数多次，才能获取最里层的 error。&lt;/p&gt;
&lt;p&gt;源码如下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func Unwrap(err error) error {
    // 判断是否实现了 Unwrap 方法
    u, ok := err.(interface {
        Unwrap() error
    })
    // 如果不是，返回 nil
    if !ok {
        return nil
    }
    // 调用 Unwrap 方法返回被嵌套的 error
    return u.Unwrap()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对 err 进行断言，看它是否实现了 Unwrap 方法，如果是，调用它的 Unwrap 方法。否则，返回 nil。&lt;/p&gt;
&lt;h2 id=&quot;is&quot;&gt;Is&lt;/h2&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func Is(err, target error) bool&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;判断 err 是否和 target 是同一类型，或者 err 嵌套的 error 有没有和 target 是同一类型的，如果是，则返回 true。&lt;/p&gt;
&lt;p&gt;源码如下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func Is(err, target error) bool {
    if target == nil {
        return err == target
    }

    isComparable := reflectlite.TypeOf(target).Comparable()
    
    // 无限循环，比较 err 以及嵌套的 error
    for {
        if isComparable &amp;amp;&amp;amp; err == target {
            return true
        }
        // 调用 error 的 Is 方法，这里可以自定义实现
        if x, ok := err.(interface{ Is(error) bool }); ok &amp;amp;&amp;amp; x.Is(target) {
            return true
        }
        // 返回被嵌套的下一层的 error
        if err = Unwrap(err); err == nil {
            return false
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过一个无限循环，使用 &lt;code&gt;Unwrap&lt;/code&gt; 不断地将 err 里层嵌套的 error 解开，再看被解开的 error 是否实现了 Is 方法，并且调用它的 Is 方法，当两者都返回 true 的时候，整个函数返回 true。&lt;/p&gt;
&lt;h2 id=&quot;as&quot;&gt;As&lt;/h2&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func As(err error, target interface{}) bool&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从 err 错误链里找到和 target 相等的并且设置 target 所指向的变量。&lt;/p&gt;
&lt;p&gt;源码如下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func As(err error, target interface{}) bool {
    // target 不能为 nil
    if target == nil {
        panic(&quot;errors: target cannot be nil&quot;)
    }
    
    val := reflectlite.ValueOf(target)
    typ := val.Type()
    
    // target 必须是一个非空指针
    if typ.Kind() != reflectlite.Ptr || val.IsNil() {
        panic(&quot;errors: target must be a non-nil pointer&quot;)
    }
    
    // 保证 target 是一个接口类型或者实现了 Error 接口
    if e := typ.Elem(); e.Kind() != reflectlite.Interface &amp;amp;&amp;amp; !e.Implements(errorType) {
        panic(&quot;errors: *target must be interface or implement error&quot;)
    }
    targetType := typ.Elem()
    for err != nil {
        // 使用反射判断是否可被赋值，如果可以就赋值并且返回true
        if reflectlite.TypeOf(err).AssignableTo(targetType) {
            val.Elem().Set(reflectlite.ValueOf(err))
            return true
        }
        
        // 调用 error 自定义的 As 方法，实现自己的类型断言代码
        if x, ok := err.(interface{ As(interface{}) bool }); ok &amp;amp;&amp;amp; x.As(target) {
            return true
        }
        // 不断地 Unwrap，一层层的获取嵌套的 error
        err = Unwrap(err)
    }
    return false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回 true 的条件是错误链里的 err 能被赋值到 target 所指向的变量；或者 err 实现的 &lt;code&gt;As(interface{}) bool&lt;/code&gt; 方法返回 true。&lt;/p&gt;
&lt;p&gt;前者，会将 err 赋给 target 所指向的变量；后者，由 As 函数提供这个功能。&lt;/p&gt;
&lt;p&gt;如果 target 不是一个指向“实现了 error 接口的类型或者其它接口类型”的非空的指针的时候，函数会 panic。&lt;/p&gt;
&lt;p&gt;这一部分的内容，飞雪无情大佬的文章【飞雪无情 分析 1.13 错误】写得比较好，推荐阅读。&lt;/p&gt;

&lt;p&gt;Go 语言使用 error 和 panic 处理错误和异常是一个非常好的做法，比较清晰。至于是使用 error 还是 panic，看具体的业务场景。&lt;/p&gt;
&lt;p&gt;当然，Go 中的 error 过于简单，以至于无法记录太多的上下文信息，对于错误包裹也没有比较好的办法。当然，这些可以通过第三方库来解决。官方也在新发布的 go 1.13 中对这一块作出了改进，相信在 Go 2 里会有更进一步的优化。&lt;/p&gt;
&lt;p&gt;本文还列举了一些处理 error 的示例，例如不要两次处理一个错误，判断错误的行为而不是类型等等。&lt;/p&gt;
&lt;p&gt;参考资料里列举了很多错误处理相关的示例，这篇文章作为一个引子。&lt;/p&gt;

&lt;p&gt;【Go 2 错误提案】&lt;a href=&quot;https://go.googlesource.com/proposal/+/master/design/29934-error-values.md&quot; class=&quot;uri&quot;&gt;https://go.googlesource.com/proposal/+/master/design/29934-error-values.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【check &amp;amp; handle】&lt;a href=&quot;https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md&quot; class=&quot;uri&quot;&gt;https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【错误讨论的 issue】&lt;a href=&quot;https://github.com/golang/go/issues/29934&quot; class=&quot;uri&quot;&gt;https://github.com/golang/go/issues/29934&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【error value 的 FAQ】&lt;a href=&quot;https://github.com/golang/go/wiki/ErrorValueFAQ&quot; class=&quot;uri&quot;&gt;https://github.com/golang/go/wiki/ErrorValueFAQ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【error 包】&lt;a href=&quot;https://golang.org/pkg/errors/&quot; class=&quot;uri&quot;&gt;https://golang.org/pkg/errors/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【飞雪无情的博客 错误处理】&lt;a href=&quot;https://www.flysnow.org/2019/01/01/golang-error-handle-suggestion.html&quot; class=&quot;uri&quot;&gt;https://www.flysnow.org/2019/01/01/golang-error-handle-suggestion.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【飞雪无情 分析 1.13 错误】&lt;a href=&quot;https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html&quot; class=&quot;uri&quot;&gt;https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Tony Bai Go语言错误处理】&lt;a href=&quot;https://tonybai.com/2015/10/30/error-handling-in-go/&quot; class=&quot;uri&quot;&gt;https://tonybai.com/2015/10/30/error-handling-in-go/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Go 官方 error 使用教程】&lt;a href=&quot;https://blog.golang.org/error-handling-and-go&quot; class=&quot;uri&quot;&gt;https://blog.golang.org/error-handling-and-go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Go FAQ】&lt;a href=&quot;https://golang.org/doc/faq#exceptions&quot; class=&quot;uri&quot;&gt;https://golang.org/doc/faq#exceptions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【ethancai 错误处理】&lt;a href=&quot;https://ethancai.github.io/2017/12/29/Error-Handling-in-Go/&quot; class=&quot;uri&quot;&gt;https://ethancai.github.io/2017/12/29/Error-Handling-in-Go/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Dave cheney GoCon 2016 演讲】&lt;a href=&quot;https://dave.cheney.net/paste/gocon-spring-2016.pdf&quot; class=&quot;uri&quot;&gt;https://dave.cheney.net/paste/gocon-spring-2016.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Morsing's Blog Effective error handling in Go】&lt;a href=&quot;http://morsmachine.dk/error-handling&quot; class=&quot;uri&quot;&gt;http://morsmachine.dk/error-handling&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【如何优雅的在Golang中进行错误处理】&lt;a href=&quot;https://www.ituring.com.cn/article/508191&quot; class=&quot;uri&quot;&gt;https://www.ituring.com.cn/article/508191&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Go 2 错误处理提案：try 还是 check？】&lt;a href=&quot;https://toutiao.io/posts/uh9qo7/preview&quot; class=&quot;uri&quot;&gt;https://toutiao.io/posts/uh9qo7/preview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【try 提案】&lt;a href=&quot;https://github.com/golang/go/issues/32437&quot; class=&quot;uri&quot;&gt;https://github.com/golang/go/issues/32437&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【否决 try 提案】&lt;a href=&quot;https://github.com/golang/go/issues/32437#issuecomment-512035919&quot; class=&quot;uri&quot;&gt;https://github.com/golang/go/issues/32437#issuecomment-512035919&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【Go 语言的错误处理机制是一个优秀的设计吗？】&lt;a href=&quot;https://www.zhihu.com/question/27158146/answer/44676012&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/question/27158146/answer/44676012&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Sep 2019 00:15:00 +0000</pubDate>
<dc:creator>Stefno</dc:creator>
<og:description>Golang 的错误处理一直广受诟病，其实它有自身的优势，并且一直在进步。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qcrao-2018/p/11538387.html</dc:identifier>
</item>
<item>
<title>读了《跃迁-成为高手的技术》我的工资翻倍了 - 会飞的笨石头</title>
<link>http://www.cnblogs.com/flyrock/p/11538374.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flyrock/p/11538374.html</guid>
<description>&lt;p&gt;如果你被我的标题吸引过来了，恭喜你，你距离成为一名高手越来越近了，通过下面的文章介绍，相信你一定有所有收获。 本章目录结构概括，我分为下面几个部分总结说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我为什么读这本书&lt;/li&gt;
&lt;li&gt;这本书适合什么人看？&lt;/li&gt;
&lt;li&gt;这本书讲了什么？&lt;/li&gt;
&lt;li&gt;我的收获？&lt;/li&gt;
&lt;li&gt;本书不足之处&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;温馨提示：本文4679字，阅读大概需要10分钟&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;我为什么读这本书？&lt;/h2&gt;
&lt;p&gt;最近我时刻在想，自己工作了这么多年，兢兢业业，拼搏努力，现在混的理想吗？我给自己的答案：暂时饿不死，但距离小康还有一段距离，有危机感，以后还要养老婆养孩子养父母。所以我想是不是自己的方法不好，方向不对，然后我就网上google,知乎询问大V，让我发现了原新东方古典老师一本新书《跃迁-成为高手的技术》，里面详细说明了成为一名高手的需要的思维认知，方法论，书中举了大量的事例说明作者的观点。&lt;/p&gt;
&lt;p&gt;读完之后通过运用书中的技巧，我发现自己有很大的改变，我也希望通过这篇读书总结带给你收获。&lt;/p&gt;
&lt;h2 id=&quot;-1&quot;&gt;这本书适合什么人看？&lt;/h2&gt;
&lt;p&gt;首先声明这不是一本简单教给你成功的书（类似成功学，鸡汤），而是从战略层面，宏观角度让你认识怎么样成为一个出众优秀的人。&lt;/p&gt;
&lt;p&gt;我站在自己的角度列几种类型需要看这本书的人，仅供参考：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拼命工作却看不到希望，回报率低的人&lt;/li&gt;
&lt;li&gt;努力学习，却看不到明显效果的人&lt;/li&gt;
&lt;li&gt;想改变现状破局的人&lt;/li&gt;
&lt;li&gt;想加速成长实现价值的人&lt;/li&gt;
&lt;li&gt;读了这么多书，为什么用的时候脑子还是一团浆糊的人&lt;/li&gt;
&lt;li&gt;学习效率低下，一心想改变提高的人&lt;/li&gt;
&lt;li&gt;找不到自己方向的人&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;-2&quot;&gt;这本书讲了什么？&lt;/h2&gt;
&lt;p&gt;整体思维导图概括：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/15/16d34588fdd0ac59?w=1576&amp;amp;h=576&amp;amp;f=png&amp;amp;s=89081&quot; alt=&quot;&quot;/&gt; 这本书大概讲了下面几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;什么在变化？&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;信息变多，思考变浅；机会变多，竞争跨界；随时干扰，永远在线。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;怎么抓住机会？&lt;/li&gt;
&lt;li&gt;如何学可以成为高手？&lt;/li&gt;
&lt;li&gt;遇到问题怎么破局重生？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;-3&quot;&gt;第一章：高手的暗箱：利用规律放大努力&lt;/h3&gt;
&lt;p&gt;这一章主要讲高手作弊的暗箱技巧，借外界的势提高自己，我们需要做的提升心智，洞悉趋势，找出自己的暗箱。&lt;/p&gt;
&lt;p&gt;在现实生活中，为什么有些人总是那么厉害，挣那么多钱，难道是他们真有本事？或许本事是有一点点，更多的时候，暗箱在帮助他们，很多情况下高手都有自己的暗箱，比如挣钱的套路，或者他们利用信息的不对称性，利用行业潜规则，为自己谋利，这里不是教大家学坏，我们要利用合法的暗箱操作为自己谋利，我们都是文化人，你懂得。&lt;/p&gt;
&lt;p&gt;本章思维导图如下： &lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/15/16d345a954554d55?w=2102&amp;amp;h=1312&amp;amp;f=png&amp;amp;s=282605&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;-4&quot;&gt;第二章：高手战略-抢占高价值区专注做正确的事&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;这一章通过大量的案例，讲解了通过头部效应，提升能力的跃迁。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么是头部？就是一件事情中最有价值的部分。 比如：一个工作项目，一般项目分为最核心部分，重要部分，和不重要部分，如何你在不重要的部分里面负责执行任务，分配的资源和获得的能力提升甚至回报，肯定没最核心部分的好。&lt;/p&gt;
&lt;p&gt;再比如孩子的教育问题，都是争着去最好的学校跑，为什么？这里就是头部，因为这里的资源好，孩子发展前途好，进步快。&lt;/p&gt;
&lt;p&gt;其实我们都懂，就是好的东西争着去抢，但是需要满足一定的条件，比如钱够不够，能力行不行，否是能够胜任处理项目中最重要的部分等等。我觉得人要一心向着高价值区奋斗，不要因为能力不行，甘愿进入不重要的部分，而要自己争取，通过自己的努力想各种办法，找人帮忙也行，也可以借助外力先进入头部，进去之后在根据项目要求努力学习，有好项目实战经验+个人努力你的进步是飞快的，只要你愿意往上爬，没人拦得住你好，需要有那股拼劲。&lt;/p&gt;
&lt;p&gt;另外，你要发现哪些是头部，比如一个公司和核心部门，那里的职业发展会更好，你要选择去那里，而不是去一个干活少，轻松的打杂部门。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，在所在的头部，通过两个关键技巧完成你的能力跃迁：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;刻意练习（如何刻意练习，请详看一个书叫做《刻意练习》完成技能的高效能提高）&lt;/li&gt;
&lt;li&gt;保持专注&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本章思维导图如下： &lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/15/16d3572fc32d7d91?w=2900&amp;amp;h=1944&amp;amp;f=png&amp;amp;s=526056&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;-5&quot;&gt;第三章：联机学习：构建自己知识体系&lt;/h3&gt;
&lt;p&gt;本章其实讲解了，如何通过读书，联机学习构建自己的知识体系，完成一次能力的跃迁。通过，讲解从获取知识源头开始，提升知识可靠行，到功利读书，再到通过打造自己的知识晶体（避免知识的遗忘和散乱不成体系），再到联机抱团学习获取更多的知识晶体，最后自己整理总结完成一次知识体系的跃迁。&lt;/p&gt;
&lt;p&gt;里面有很多关键词概念：比如，知识源头，功利读书，知识晶体，联机学习&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;知识源头：也就是获取第一手资料，这样保证信息的非变质,站在上帝视角分析问题&lt;/li&gt;
&lt;li&gt;功利读书：带着目的性读书，让你读书质量和效果更高效&lt;/li&gt;
&lt;li&gt;知识晶体：打磨自己的知识晶体，才更有价值，类似钻石一样，不然让知识分散各处不成体系，容易遗忘不说，还很难有更高价值&lt;/li&gt;
&lt;li&gt;联机学习：抱团找高手学习，打磨一个知识晶体，抛出去换回别人的知识模块，整合自己的知识体系实现知识的跃迁&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本章核心关键点: 终身提问，知识晶体，联机学习&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我贯彻了上述方法之后，我读书的效率变高了，我学习的能力增强了。 这里指的效率变高不是我读一本书的时间变快了，而是指对一本书本身价值的获取提升了。首先，我不再盲目的瞎读书，而是根据最近遇到的问题选择性的读书，每次读一本书，我不再拿起书就开始从第一页开始，我会参看网络上相关该书文章的介绍，再认真分析本书的目录结构对书有个大概的了解，再带着各种疑问去读，也不是每个段落都读，不必要的段落，比如已经知道事实或者枯燥难懂的说明（读也读不懂不如不读）可以跳过，获取自己想要部分就可以了，这样下来，发现读书的时间缩短了很多，读书的质量反而提升了不少，也不会读完一段时间就忘记了。&lt;/p&gt;
&lt;p&gt;有时候为了更好的理解一本书的要义，我会在生活中运用读到的技巧和思想认知，和相关的高手讨论，每个人的精力不同，思想认知不同，读到的东西也不一定相同，我发现另一个新大陆，重新打开了我另个视角，让我又一次开阔了思维，这个就是联机学习的效应。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;过去自己学自己悟，才是真本事。在信息爆炸时代，“调用”和“整合”他人的答案，显然更加重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本章思维导图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/15/16d35771e6a9476f?w=2720&amp;amp;h=4736&amp;amp;f=png&amp;amp;s=1149328&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;-6&quot;&gt;第四章：破局思维&lt;/h3&gt;
&lt;p&gt;生活中的困局，比如永远减不完的肥，如何破局？&lt;/p&gt;
&lt;p&gt;一般很多人通过少吃甚至节食来减肥，后来搞的反而体重升了或者身体虚弱；为什么呢？吃的少可能营养跟不上，造成身体虚弱，一段时间吃的少会造成控制不住哪天多吃了体重又回升了。破局的关键在于找到科学合理的减肥方案，如果自己不懂可以联机学习找高手请教，合理的减肥应该是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;饮食，作息，运动相结合&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多吃营养均衡食物；&lt;/li&gt;
&lt;li&gt;多运动提高肌肉含量会加速代谢；&lt;/li&gt;
&lt;li&gt;多睡觉，睡眠其实能加速新陈代谢，利于减肥；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本章主要讲，如何看清事物本质，解决当前遇到的困局破局重生&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;介绍三种人境界：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新手学习系统&lt;/li&gt;
&lt;li&gt;老手利用系统&lt;/li&gt;
&lt;li&gt;高手破局&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;回过头来想象真有道理，刚入职场或者刚进入一个领域的时候，我们是一个新手，需要熟悉环境，了解行业规则，不断适应学习，我们一直在了解这个系统。当你快速进入状态了之后，你开始在这个系统里面愉快的玩耍，就是利用系统为自己工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是重点来了，当你遇到重大问题的时候，解决不了了，思维认知受限，能力不足，此时你陷入了一个困局，那么如何破局解决问题显得尤为重要&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;两个破局入口点:1.回路：设计人生增长引擎 2.层级：看透问题的技术&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;回路：设计人生增长引擎&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;这里说的回路是什么意思呢？ 举个简单例子就是，为什么富人越来越富，穷人越来越穷，这里涉及正向和负向循环在里面： 富人资源多，善于利用资源整合挣更多的钱； 穷人翻身很难，没资源没人脉还没思想认知，怎么比得过富人（个别案例排除）&lt;/p&gt;
&lt;p&gt;有一个案例特别有意思：&lt;/p&gt;
&lt;p&gt;国家对一个地区的脱贫的解决方式，最好的方式是给钱，比如：&lt;/p&gt;
&lt;p&gt;数千亿的资金投入非洲，并没有让非洲脱贫；因为贫困是一种政治和心智问题，援助往往让当地官员更加腐败奢华，钱发不到民众手中；即使少数到了穷人手中，他们也倾向于消费一轮，而不是改变困境；&lt;/p&gt;
&lt;p&gt;再举个贴近生活的例子，为什么我们工作中这么忙，忙的没完没了，可能你已经陷入了一个负向循环的局中：&lt;strong&gt;忙----乱----忙&lt;/strong&gt; ，想要破局必须把乱终止掉。&lt;/p&gt;
&lt;p&gt;所以我们要打破自己的负向循环，增强我们的正向循环，来解决破局。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;层级：看透问题的技术&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么很多问题无解？因为答案根本就不在你当前认识的系统内。“单维思考者永远看不懂整体的“系统思维”，看懂系统，才能破局。巧的是，你面临无解的问题是个多层系统，这就像你在一个三层楼里找一本书，你只知道在一楼找，找里半天怎么都找不到，因为书在二楼或者三楼，而你却不知道去楼上找（可能二楼三楼隐藏里，你根本不知道有二楼三楼）。这就就像一个迷宫一样，需要你去发现，去探索，或者去找高手请教，才能破局。&lt;/p&gt;
&lt;p&gt;多层系统都有两个特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;上层决定下层 ；&lt;/li&gt;
&lt;li&gt;下层无解，向上一层。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不管什么系统，之所以会涌现出更高层级，是为了更高效地协调原来层次的资源。困于底部，说白了就是意识还未完成进化的跃迁，也就失去了在更高层次调用资源、解决问题的能力。&lt;/p&gt;
&lt;p&gt;我觉得破局思维认识起来很容易，实现起来很难，需要技巧，经验，丰富的阅历，实在自己搞不定，我们就找高手请教吧，哈哈，知道谁懂，也是一种能力。&lt;/p&gt;
&lt;p&gt;本章思维导图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/15/16d35762308e9526?w=2176&amp;amp;h=1556&amp;amp;f=png&amp;amp;s=267029&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;-7&quot;&gt;第五章：内在修炼&lt;/h3&gt;
&lt;p&gt;内在修炼即处事的心法，心法的表述历来是简单的，古典老师总结里关键字给我们。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;现代高手的7个心智关键词：开放、专注、迟钝、有趣、简单、善良、可激怒&lt;/p&gt;
&lt;p&gt;开放而专注九律&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;见得人好，经常随喜赞叹。&lt;/li&gt;
&lt;li&gt;找到自己领域的知识源头，并分享。&lt;/li&gt;
&lt;li&gt;不随便崇拜谁。一旦崇拜，以他为顶，你的系统就又封闭了。&lt;/li&gt;
&lt;li&gt;不再认为自己看不懂、不喜欢的东西就是傻的。&lt;/li&gt;
&lt;li&gt;小心那些“一切都解释得通”的上帝视角感理论。&lt;/li&gt;
&lt;li&gt;对水平没有你高的人宽容，因为你也没有掌握真理。&lt;/li&gt;
&lt;li&gt;留出10%~30%的时间给自己不懂也不太会接触的领域。&lt;/li&gt;
&lt;li&gt;站在更高角度，发现和专注于自己的独特之处。&lt;/li&gt;
&lt;li&gt;专注于自己的人生大问题。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;迟钝而有趣七律&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;对不重要的事漠不关心。&lt;/li&gt;
&lt;li&gt;忍住第一反应，等待第二反应。&lt;/li&gt;
&lt;li&gt;不追热点，等要点浮现。&lt;/li&gt;
&lt;li&gt;寻找整体最优解，站在长周期做判断。&lt;/li&gt;
&lt;li&gt;多元，定期做一些不靠谱、有趣无用的事。&lt;/li&gt;
&lt;li&gt;成功是小概率事件，找到自己的无限游戏。&lt;/li&gt;
&lt;li&gt;放下焦虑，不要放下好奇心。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本章思维导图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/15/16d3585d879ebeaf?w=1048&amp;amp;h=554&amp;amp;f=png&amp;amp;s=64095&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-8&quot;&gt;我的收获？&lt;/h2&gt;
&lt;p&gt;该书是我近期阅读过程中对我产生较大影响的一本书。它引发了我对现状的思考，也促使我做出了一些影响我职业生涯的决策。&lt;/p&gt;
&lt;p&gt;接下来让我进行里以下的反思和总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在这个知识爆炸的时代，如何筛选自己需要显得更加重要，寻找高价值有利资源&lt;/li&gt;
&lt;li&gt;走出舒适区，找到高价值区快速成长&lt;/li&gt;
&lt;li&gt;以问题为导向，采用刻意练习方法论，提升自己技能&lt;/li&gt;
&lt;li&gt;一个人学习势单力薄，进步慢，不如找高手一起进步&lt;/li&gt;
&lt;li&gt;输出倒逼输入，分享演讲，训练自己&lt;/li&gt;
&lt;li&gt;生活工作中，面临多个困局，学习如何破局之道&lt;/li&gt;
&lt;li&gt;打造知识晶体，构建自己核心的知识体系，为未来做打算&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;-9&quot;&gt;本书不足之处&lt;/h2&gt;
&lt;p&gt;每个章节的标题和内容不完全匹配，举个例子，第三章标题“联机学习”：&lt;/p&gt;
&lt;p&gt;具体看第三章，你会发现这里讲了几个点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提升认知效率说起：知识源头，功利读书法，萃取知识晶体 三个方面讲述&lt;/li&gt;
&lt;li&gt;联机学习交换价值&lt;/li&gt;
&lt;li&gt;以问题为中心：讲知识树和问题树&lt;/li&gt;
&lt;li&gt;知识IPO&lt;/li&gt;
&lt;li&gt;构建知识体系&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;作者章末也说了，整章节内容的形成为了构建自己的知识体系，我觉得标题叫做“构建自己知识体系” 是不是更好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本书所有的概念和理论，总的来说生活中都熟悉，都了解，只是作者认真思考分析后系统化的整理总结起来，本来是分散在世界的各个角落，作者打磨到一起形成里一套完整的知识晶体，思想认知，理论学习，实战技巧，案例说明一整套体系，完美的元素和紧密的关系组合，形成一套有效实现跃迁的功能体系，非常完美。&lt;/p&gt;
&lt;h2 id=&quot;end&quot;&gt;END&lt;/h2&gt;
&lt;p&gt;如有收获，请帮忙转发，后续会有更好文章贡献，您的鼓励是作者最大的动力！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：架构师的修炼，获得独家整理的学习资源和日常干货推送。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关注公众号，回复“跃迁” 两个字，发送给您一份整体高清思维导图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/13/16d2952d580dc9a5?w=598&amp;amp;h=596&amp;amp;f=png&amp;amp;s=459957&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Sep 2019 00:08:00 +0000</pubDate>
<dc:creator>会飞的笨石头</dc:creator>
<og:description>如果你被我的标题吸引过来了，恭喜你，你距离成为一名高手越来越近了，通过下面的文章介绍，相信你一定有所有收获。 本章目录结构概括，我分为下面几个部分总结说明： 我为什么读这本书 这本书适合什么人看？ 这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flyrock/p/11538374.html</dc:identifier>
</item>
<item>
<title>多场景抢红包业务引发.NETCore下使用适配器模式实现业务接口分离 - Ron.Liang</title>
<link>http://www.cnblogs.com/viter/p/11532822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viter/p/11532822.html</guid>
<description>&lt;h2 id=&quot;事情的起因&quot;&gt;事情的起因&lt;/h2&gt;
&lt;p&gt;我们公司现有一块业务叫做抢红包，最初的想法只是实现了一个初代版本，就是给指定的好友单发红包，随着业务的发展，发红包和抢红包的场景也越来越多，目前主要应用的场景有：单聊发红包、群聊发红包、名片发红包、直播场景中的主播发红包/观众给主播发红包/定时抢红包，接下来，如果出现其它产品的业务，也将大概率的出现抢红包的需求。&lt;/p&gt;
&lt;h2 id=&quot;大同小异的抢红包业务&quot;&gt;大同小异的抢红包业务&lt;/h2&gt;
&lt;p&gt;红包的场景无论怎么变化，其核心算法不变，这部分是可以抽象的内容，随着迭代发展，我们之前通常都是通过增加红包的类型（业务）来扩展，但是随着肉眼可见的发展，部分业务的改动如果需要对红包业务进行调整和优化对话，将有可能产生牵一发而动全身的debuff效果。&lt;/p&gt;
&lt;h2 id=&quot;新的改变&quot;&gt;新的改变&lt;/h2&gt;
&lt;p&gt;其实这些业务代码早该优化一下，我就是懒+忙（借口），正好有位新同事入职，这块的优化任务就交给他来做了，从头到尾我都没有参与（不知道有没有吐槽我的代码，捂脸～），我初步看了一下，代码的实现质量还是挺高的，正好也是一个比较好的应用场景，我就简单实现一下他做的适配器模式，彻底的将各个红包业务类型分离，很好的实现了设计模式的开闭原则，加入某天某个场景的抢红包业务下线了，这种做法是非常有利于业务的扩展和维护。&lt;/p&gt;
&lt;h2 id=&quot;定义抢红包接口&quot;&gt;定义抢红包接口&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public interface IRedPacket
{
    string Name { get; }
    string Put(int org_id, int money, int count, string reason);
    string Get(int id);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上接口包含一个属性和2个方法，用于设置业务名称和收发红包。初次之外，我们还需要定义一个实现业务的基类，用于处理公共业务。&lt;/p&gt;
&lt;h2 id=&quot;红包基类业务实现&quot;&gt;红包基类业务实现&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class RedPacket : IRedPacket
{
    public abstract string Name { get; }
    public abstract string Put(int org_id, int money, int count, string reason);
    public abstract string Get(int id);

    protected string Create(string reason, int money, int count)
    {
            Console.WriteLine(&quot;创建了红包:{0},金额：Money:{1},数量:{2}&quot;, reason, money, count);
            return &quot;成功&quot;;
    }

    protected string Fighting()
    {
            Console.WriteLine(&quot;调用了抢红包方法:{0}&quot;, nameof(Fighting));
            return &quot;成功&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在基类中，我们选择不实现接口，将接口方法定义为抽象类型。同时，定义并实现两个受保护的方法 Create（创建红包）/Fighting（抢红包），接口方法由子类实现具体的业务细节，当子类针对具体的业务细节实现完成后，他们应该会调用Create（创建红包）/Fighting（抢红包）的方法，直至最终完成整个红包的流程。&lt;/p&gt;
&lt;h2 id=&quot;实现单聊红包&quot;&gt;实现单聊红包&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt; public class ChatOneRedPacket : RedPacket
 {
     public override string Name { get; } = &quot;ChatOne&quot;;
     public override string Put(int org_id, int money, int count, string reason)
     {
         Console.WriteLine(&quot;检查接收人ID:{0}是否存在&quot;, org_id);
         return base.Create(reason, money, count);
     }

     public override string Get(int id)
     {
         Console.WriteLine(&quot;检查红包ID:{0}，是否具有领取资格&quot;, id);
         return base.Fighting();
     }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;群聊红包&quot;&gt;群聊红包&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class ChatGroupRedPacket : RedPacket
{
    public override string Name { get; } = &quot;ChatGroup&quot;;
    public override string Put(int org_id, int money, int count, string reason)
    {
        Console.WriteLine(&quot;检查群ID：{0},是否存在&quot;, org_id);
        return base.Create(reason, money, count);
    }

    public override string Get(int id)
    {
        Console.WriteLine(&quot;检查是否群ID:{0}，当前用户是否群成员&quot;, id);
        return base.Fighting();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;直播红包&quot;&gt;直播红包&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class LiveRedPacket : RedPacket
{
    public override string Name { get; } = &quot;Live&quot;;
    public override string Put(int org_id, int money, int count, string reason)
    {
        Console.WriteLine(&quot;检查直播ID:{0}是否存在&quot;, org_id);
        return base.Create(reason, money, count);
    }

    public override string Get(int id)
    {
        Console.WriteLine(&quot;检查红包ID：{0} 是否当前主播红包&quot;, id);
        return base.Fighting();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了方便演示，上面的三种红包子类仅简单的实现类属性 Name=&quot;ChatOne&quot;，除此之外，还实现类接口的收发红包接口，子类实现 Name 属性主要是便于我们在DI中去灵活的区分调用的主体，实现业务的分离。除了单聊红包外，我们还有群聊和直播红包，都采用上面的处理方式，只是各自实现的 Name 属性时，指定不同的名字即可。在接口实现的方法中，各自的业务还需要执行不同的业务检查，比如单聊红包就需要检查接收人是否存在，群聊红包还需要检查群是否存在，该群是否被冻结等等，直播红包需要检查主播是否在直播中，观众是否在直播房间内，这些都是不同业务场景产生的特殊的业务处理需求。&lt;/p&gt;
&lt;h2 id=&quot;创建容器实例&quot;&gt;创建容器实例&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddScoped(typeof(IRedPacket), typeof(ChatOneRedPacket))
            .AddScoped(typeof(IRedPacket), typeof(ChatGroupRedPacket))
            .AddScoped(typeof(IRedPacket), typeof(LiveRedPacket));
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;容器实例的创建非常简单，只需要将已实现 IRedPacket 接口的子类注册到服务管道即可。&lt;/p&gt;
&lt;h2 id=&quot;依赖注入以实例集的方式&quot;&gt;依赖注入，以实例集的方式&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class HomeController : ControllerBase
{
    private readonly IEnumerable&amp;lt;IRedPacket&amp;gt; redpackets;
    public HomeController(IEnumerable&amp;lt;IRedPacket&amp;gt; redpackets)
    {
        this.redpackets = redpackets;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过建立一个控制台 HomeController 用于演示，在 HomeController 的构造方法中，使用 IEnumerable 获得在服务中创建的所有实现接口 IRedPacket 的实例。下面将在 HomeController 中 创建两个接口进行演示发红包/抢红包。&lt;/p&gt;
&lt;h2 id=&quot;发红包&quot;&gt;发红包&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;[HttpPost]
public ActionResult&amp;lt;string&amp;gt; Post([FromBody] RedPacketViewModel model)
{
    var rp = this.redpackets.Where(f =&amp;gt; f.Name == model.Type).FirstOrDefault();
    if (rp == null)
    {
        var msg = $&quot;红包业务类型：{model.Type}不存在&quot;;
        Console.WriteLine(msg);
        return msg;
    }
    var result = rp.Put(model.Org_Id, model.Money, model.Count, model.Reason);
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了演示方便，我们构造4中不同的业务实体去调用发红包的接口，分别将结果输出到客户端&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 单聊红包
{
  &quot;type&quot;:&quot;ChatOne&quot;,
  &quot;org_id&quot;:1,
  &quot;money&quot;:8,
  &quot;count&quot;:1,
  &quot;reason&quot;:&quot;恭喜发财，大吉大利！&quot;
}

// 群聊红包
{
  &quot;type&quot;:&quot;ChatGroup&quot;,
  &quot;org_id&quot;:2,
  &quot;money&quot;:9,
  &quot;count&quot;:3,
  &quot;reason&quot;:&quot;恭喜发财，大吉大利！&quot;
}

// 直播红包
{
  &quot;type&quot;:&quot;Live&quot;,
  &quot;org_id&quot;:3,
  &quot;money&quot;:8,
  &quot;count&quot;:1,
  &quot;reason&quot;:&quot;恭喜发财，大吉大利！&quot;
}

//圈子红包
{
  &quot;type&quot;:&quot;Quanzi&quot;,
  &quot;org_id&quot;:4,
  &quot;money&quot;:8,
  &quot;count&quot;:1,
  &quot;reason&quot;:&quot;恭喜发财，大吉大利！&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 单聊红包

检查接收人ID:1是否存在
红包类型：ChatOne，创建了红包:恭喜发财，大吉大利！,金额：Money:8,数量:1

// 群聊红包
检查群ID：2,是否存在
红包类型：ChatGroup，创建了红包:恭喜发财，大吉大利！,金额：Money:9,数量:3

// 直播红包
检查直播ID:3是否存在
红包类型：Live，创建了红包:恭喜发财，大吉大利！,金额：Money:8,数量:1

//圈子红包&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;红包业务类型：Quanzi不存在&lt;/p&gt;
&lt;h2 id=&quot;抢红包&quot;&gt;抢红包&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;[HttpGet(&quot;{id}&quot;)]
public ActionResult&amp;lt;string&amp;gt; Get(int id)
{
    // 生产环境下，该红包消息应该是从数据库中读取
    var model = GetRedPacket(id);
    var rp = this.redpackets.Where(f =&amp;gt; f.Name == model.Type).FirstOrDefault();
    var result = rp.Get(id);
    return result;
}

private RedPacketViewModel GetRedPacket(int id)
{
    int type = --id;
    string[] redPackets = { &quot;ChatOne&quot;, &quot;ChatGroup&quot;, &quot;Live&quot; };
    var model = new RedPacketViewModel
    {
        Count = 3,
        Money = 8,
        Org_Id = 115,
        Reason = &quot;恭喜发财，大吉大利！&quot;,
        Type = redPackets[type]
    };
    return model;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抢红包的过程，传入一个红包ID,然后跟进该ID到数据库进行查找，得到红包后，根据红包类型找出 IRedPacket 的实现类，并进行调用，完成抢红包的操作。可能有的同学会觉得比较奇怪，为什么不直接拆红包呢？这是因为我们要根据红包设计的初衷，不同的红包，其所执行的业务规范性检查是不同的，不能直接进行暴力拆包。&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;上面我们创建了3个IRedPacket的实现类，并将他们注册到服务管道中，然后在HomeController中获得服务依赖注入的实例对象，通过在不同的参数传入，实现了不同的红包业务场景的拆分，很好的实现了设计模式中所说的开闭原则。&lt;/p&gt;
&lt;h2 id=&quot;演示代码下载&quot;&gt;演示代码下载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lianggx/Examples/tree/master/Ron.RedPacketTest&quot; class=&quot;uri&quot;&gt;https://github.com/lianggx/Examples/tree/master/Ron.RedPacketTest&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Sep 2019 00:07:00 +0000</pubDate>
<dc:creator>Ron.Liang</dc:creator>
<og:description>我们创建了3个IRedPacket的实现类，并将他们注册到服务管道中，然后在HomeController中获得服务依赖注入的实例对象，通过在不同的参数传入，实现了不同的红包业务场景的拆分，很好的实现了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viter/p/11532822.html</dc:identifier>
</item>
<item>
<title>编程必备基础知识|计算机组成原理篇(07)：计算机的总线 - 悟小天</title>
<link>http://www.cnblogs.com/sum-41/p/11538275.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sum-41/p/11538275.html</guid>
<description>&lt;p&gt;计算机基础方面的知识，对于一些非科班出身的同学来讲，一直是他们心中的痛，而对于科班出身的同学，很多同学在工作之后，也意识到自身所学知识的不足与欠缺，想回头补补基础知识。关于计算机基础的课程很多，内容繁杂，但无论是相关书籍还是大学课程，都有点脱离工作。特别地，计算机基础知识体系庞杂，想要从零学习或者复习都耗时耗力。&lt;/p&gt;
&lt;p&gt;有鉴于此，本系列文章将带你更快的补足编程必备基础知识，涵盖计算机领域三大基础知识：计算机组成原理、操作系统、计算机网络，这些都是大学计算机课程里面最重要的内容。文章对这些内容做了提炼和总结，摒弃了作为程序员不需要掌握的知识。&lt;/p&gt;
&lt;p&gt;目的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;帮助大家形成计算机知识的结构体系&lt;/li&gt;
&lt;li&gt;帮助大家理解计算机底层原理&lt;/li&gt;
&lt;li&gt;帮助大家在工作实践中借鉴其中的优秀设计&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;本篇是计算机组成原理之计算机的总线&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;欢迎关注、转发、收藏、评论&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总线（bus），是用于连接计算机中各种功能部件（如CPU、内存、输入、输出设备），并在它们之间传送数据的公用线路或通路，主机的各个部件通过总线相连接，外部设备（如U盘、移动硬盘）通过相应的接口再与总线相连接，从而形成计算机硬件系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190918022558360-281209348.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果说主板是一座城市，那么总线就像是城市里的公共汽车（bus），能按照固定行车路线，传输来回不停运作的比特（bit）。&lt;/p&gt;

&lt;p&gt;在计算机系统中，按其所连接的对象，总线可分为： 片内总线和系统总线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;片内总线&lt;/strong&gt;，它是CPU内部的信息传输线，连接着控制器、运算器等部件，使用片内总线可以简化CPU内部的电路结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190918022613781-667181403.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统总线&lt;/strong&gt;，它是连接CPU、主存、硬盘、IO设备、USB插槽、PCI插槽等计算机组件的一条信息传输线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190918022625463-433149755.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照所传输的信息种类，系统总线可以分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据总线：双向传输各个部件的数据信息&lt;/li&gt;
&lt;li&gt;地址总线：指定源数据或目的数据在内存中的地址&lt;/li&gt;
&lt;li&gt;控制总线：用来发出各种控制信号的传输线，控制信号经由控制总线从一个组件发送给另外一个组件，可以监视不同组件之间的状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1666949/201909/1666949-20190918022644002-1866542804.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Sep 2019 18:27:00 +0000</pubDate>
<dc:creator>悟小天</dc:creator>
<og:description>计算机组成原理（07）：计算机的总线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sum-41/p/11538275.html</dc:identifier>
</item>
<item>
<title>asp.net core 使用 signalR（二） - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/11538220.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/11538220.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;上次介绍了 asp.net core 中使用 signalR 服务端的开发，这次总结一下web前端如何接入和使用 signalR，本文主要分两部分，一是直接使用 &lt;code&gt;@aspnet/signalr&lt;/code&gt; 这个微软开发好的 signalR 的客户端，另一部分是使用 h5 原生的 websocket 直接连接 signalR 的 websocket&lt;/p&gt;
&lt;h2 id=&quot;使用-signalr-客户端&quot;&gt;使用 signalR 客户端&lt;/h2&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装 signalr 客户端 npm 包 &lt;code&gt;npm install @aspnet/signalr --save&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;获取一个 connection&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;
import * as signalR from &quot;@aspnet/signalr&quot;;
// ...
const connection = new signalR.HubConnectionBuilder()
    .withUrl(Constants.HubUrl, { accessTokenFactory: () =&amp;gt; Constants.TestToken })
    .build();

// accessTokenFactory 用于指定获取 accessToken 的方式，如果不需要用户登录，不需要认证没有这个配置&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;添加客户端处理方法&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;connection.on(&quot;GameAnswerResultReceived&quot;, (result:any)=&amp;gt;{
    showMessage(`收到问题：${result.QuestionId} 答案`, JSON.stringify(result));
});

connection.on(&quot;GameOver&quot;, (result: object)=&amp;gt;{
    showMessage(`游戏结束`, `Game Over\n ${JSON.stringify(result)}`);
});&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;客户端调用服务器端方法&lt;/p&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;调用服务器端方法，没有返回值&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;connection.send(&quot;CheckQuestionAnswer&quot;, {
                    QuestionId: questionId,
                    Answer: tbMessage.value,            
                }, gameId);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;调用服务器端方法并获取返回值&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt; connection.invoke(&quot;CheckQuestionAnswer&quot;, {
                 QuestionId: questionId,
                 Answer: tbMessage.value,            
             }, gameId)
             .then(result =&amp;gt; {
                 console.log(result);
                 showMessage(`答案检查结果：${result.Succeeded}`, JSON.stringify(result));
             });&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;websocket-直接连接-signalr&quot;&gt;websocket 直接连接 signalR&lt;/h2&gt;
&lt;ol readability=&quot;15.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建 websocket 连接&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;
let connection = new WebSocket(`${Constants.HubUrl}?access_token=${Constants.TestToken}`);
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;连接成功后发送使用协议信息&lt;/p&gt;
&lt;p&gt;signalr 发送的消息均以 &lt;code&gt;0x1e&lt;/code&gt; 这个字符结尾，在发送消息的时候需要在消息的最后增加 &lt;code&gt;0x1e&lt;/code&gt; 字符&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;connection.onopen = (event) =&amp;gt; {
    // console.log(event);
    connection.send(`{&quot;protocol&quot;:&quot;json&quot;, &quot;version&quot;:1}${String.fromCharCode(0x1e)}`);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码表示我们要使用 JSON 的形式进行消息的序列化，如果有较高的性能要求也可以使用 messagePack 二进制序列化消息内容（对浏览器要求较高，需要支持 xhr2)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;接受服务器端消息&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;connection.onmessage = (event) =&amp;gt; {
    var msg = event.data.replace(String.fromCharCode(0x1e), &quot;&quot;); //替换消息结束符
    console.log(`received message: ${msg}`);
    let eventData = JSON.parse(msg);
    if(eventData.type === 1 &amp;amp;&amp;amp; eventData.target){ // type为1表示调用客户端的某一个方法
        let func: (...args:any[])=&amp;gt;any = callbacks[eventData.target];
        if(func !== undefined){
            func(...eventData.arguments);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;定义客户端方法&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;
callbacks[&quot;GameAnswerResultReceived&quot;] = (result:any)=&amp;gt;{
    showMessage(`收到问题：${result.QuestionId} 答案`, JSON.stringify(result));
};

callbacks[&quot;GameOver&quot;] = (result)=&amp;gt;{    
    showMessage(`游戏结束`, `Game Over\n ${JSON.stringify(result)}`);
};&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;调用服务器端方法&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;// 可以把这个方法扩展为 WebSocket 的一个原型方法
function invokeMethod(webSocket: WebSocket, methodName:string, ...args: any[]) : Promise&amp;lt;void&amp;gt; {
    // type为1表示调用远程的方法(一个 RPC 调用)，target为要调用的方法名称，arguments为要调用的方法的参数
    webSocket.send(`${JSON.stringify({
        arguments: args,
        target: methodName,
        type: 1,
    })}${String.fromCharCode(0x1e)}`);
    return Promise.resolve();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;memo&quot;&gt;Memo&lt;/h2&gt;
&lt;p&gt;上面的完全基于 websocket 去连接 signalr 的代码还有些简陋，实际使用的话可以再修改优化一下&lt;/p&gt;
&lt;p&gt;强类型调用服务器端的方法，自定义的话可以在 websocket 的基础上封装一下，signalr 强类型调用服务器端方法还没找到解决办法，不过问题不大，有兴趣的话可以研究一下 &lt;a href=&quot;https://github.com/aspnet/AspNetCore/tree/master/src/SignalR&quot;&gt;signalR 源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Tue, 17 Sep 2019 16:44:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>asp.net core 使用 signalR（二） Intro 上次介绍了 asp.net core 中使用 signalR 服务端的开发，这次总结一下web前端如何接入和使用 signalR，本文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/11538220.html</dc:identifier>
</item>
<item>
<title>操作系统原理之I/O设备管理（第六章上半部分下） - 小禾点点</title>
<link>http://www.cnblogs.com/jalja/p/11537890.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jalja/p/11537890.html</guid>
<description>&lt;h2&gt;五、I/O软件原理&lt;/h2&gt;
&lt;p&gt;输入输出软件的总体目标是将软件组织成一种层次结构&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;低层软件用来屏蔽硬件的具体细节&lt;/li&gt;
&lt;li&gt;高层软件则主要是为用户提供一个简洁、规范的界面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;设备管理的4个层次：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户层软件 -》向系统发出I/O请求，显示I/O操作的结果，提供⽤户与设备的接⼝&lt;/li&gt;
&lt;li&gt;与设备无关的软件层-》完成设备命名、设备分配、设备独⽴性和缓冲管理等功能&lt;/li&gt;
&lt;li&gt;设备驱动程序-》与硬件关系最密切，包括设备服务程序和中断处理程序&lt;/li&gt;
&lt;li&gt;中断处理程序（底层）-》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;设备管理软件的功能：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）实现I/O设备的独⽴性&lt;br/&gt;（2）错误处理&lt;br/&gt;（3）异步传输&lt;br/&gt;（4）缓冲管理&lt;br/&gt;（5）设备的分配和释放&lt;br/&gt;（6）实现I/O控制⽅式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中断处理程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　中断处理程序的作⽤：I/O中断处理程序的作⽤是将发出I/O请求⽽被阻塞的进程唤醒&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设备驱动程序：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190917225609144-1258051966.png&quot; alt=&quot;&quot; width=&quot;601&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 与硬件⽆关的I/O软件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与设备⽆关的I/O软件的功能如下：&lt;/p&gt;
&lt;p&gt;（1）设备命名&lt;/p&gt;
&lt;p&gt;（2）设备保护&lt;/p&gt;
&lt;p&gt;（3）提供独⽴于设备的块⼤⼩&lt;/p&gt;
&lt;p&gt;（4）为块设备和字符设备提供必要的缓冲技术&lt;/p&gt;
&lt;p&gt;（5）块设备的存储分配&lt;/p&gt;
&lt;p&gt;（6）分配和释放独⽴设备&lt;/p&gt;
&lt;p&gt;（7）错误处理&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;六、 磁盘管理&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;磁盘存储器容量⼤，存取速度快，⽽且可以实现随机存取，是存放⼤量程序和数据的理想设备；&lt;/li&gt;
&lt;li&gt;磁盘管理的重要⽬标是提⾼磁盘空间利⽤率和磁盘访问速度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;磁盘结构：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　⼀个物理记录存储在⼀个扇区上，磁盘存储的物理记录数⽬是由扇区数、磁道数及 磁盘⾯数决定的。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190917230025170-1264878457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190917230512834-2113819346.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;36&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 磁盘类型：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;固定头磁盘 在每条磁道上都有读/写磁头                       &lt;/li&gt;
&lt;li&gt;活动头磁盘 (移动头)：每⼀个盘⾯仅配有⼀个磁头&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;strong&gt;磁盘访问时间：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190917230811359-1175277056.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; 磁盘调度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　磁盘调度的一个重要目标是使磁盘的平均寻道时间最少&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 磁盘调度算法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;先来先服务 (First Come First Served, FCFS)&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;最简单的磁盘调度算法 根据进程请求访问磁盘的先后顺序进⾏调度&lt;/li&gt;
&lt;li&gt;优点：公平、简单，且每个进程的请求都能依次得到处理，不会出现某⼀ 进程的请求⻓期得不到满⾜的情况&lt;/li&gt;
&lt;li&gt;缺点：平均寻道时间较⻓&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190917231537272-522180890.png&quot; alt=&quot;&quot; width=&quot;734&quot; height=&quot;181&quot;/&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最短寻道时间优先 (Shortest Seek Time First, SSTF)&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;该算法选择的进程：其要求访问的磁道与当前磁头所在的磁道距离最近， 以使每次的寻道时间最短。&lt;/li&gt;
&lt;li&gt;优点：每次的寻道时间最短，较之FCFS有更好的寻道性能&lt;/li&gt;
&lt;li&gt;缺点：可能导致某个进程发⽣“饥饿”现象&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190917231726478-985278501.png&quot; alt=&quot;&quot; width=&quot;324&quot; height=&quot;189&quot;/&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扫描算法 (SCAN)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;不仅考虑到要访问的磁道与当前磁道的距离，更优先考虑磁头当前的移动⽅向。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　　　优点：有较好的寻道性能，防⽌“饥饿”现象&lt;br/&gt;　　　　缺点：有时候进程请求被⼤⼤推迟&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190917232200763-2136637377.png&quot; alt=&quot;&quot; width=&quot;502&quot; height=&quot;218&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;循环扫描算法 (CSCAN)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;em id=&quot;__mceDel&quot;&gt;在扫描算法的基础上，规定磁头是单向移动的。将最⼩磁道号紧接着最⼤&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;磁道号构成循环，进⾏循环扫描。&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;NStepSCAN和FSCAN调度算法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190917232916315-867080794.png&quot; alt=&quot;&quot; width=&quot;570&quot; height=&quot;94&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;　　　　这两种算法可以避免磁臂粘着&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190917232817048-1778197959.png&quot; alt=&quot;&quot; width=&quot;617&quot; height=&quot;241&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;计算题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设磁盘有1000个磁道，若磁盘请求是一些随机请求，它们按照到达的次序分别处于 811、 348、153、968、407、580、233、679、801、121磁道。当前磁头在656号 磁道上，并且读写磁头正在向磁道号增加的方向移动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要求： 1.给出用FCFS算法进行磁盘调度时满足请求的次序，并计算出它们的平均寻道长度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190917233725734-818065150.png&quot; alt=&quot;&quot; width=&quot;677&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2.给出用SSTF算法进行磁盘调度时满足请求的次序，并计算出它们的平均寻道长度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190917233750176-820971399.png&quot; alt=&quot;&quot; width=&quot;692&quot; height=&quot;291&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;假设磁盘有1000个磁道，若磁盘请求是一些随机请求，它们按照到达的次序分别处于150、 160、 184、90、58、55、39、38、18磁道。当前磁头100号磁道上，并且读写磁头正在向磁道号增 加的方向移动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要求： 1.给出用SCAN算法进行磁盘调度时满足请求的次序，并计算出它们的平均寻道长度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190917235207575-268099262.png&quot; alt=&quot;&quot; width=&quot;677&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2.给出用CSCAN算法进行磁盘调度时满足请求的次序，并计算出它们的平均寻道长度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190918000159942-1702268471.png&quot; alt=&quot;&quot; width=&quot;644&quot; height=&quot;252&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;提⾼磁盘I/O速度的⽅法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190918000244478-1071148494.png&quot; alt=&quot;&quot; width=&quot;583&quot; height=&quot;163&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 为了提高磁盘I/O速度，用来暂存从磁盘中读出的一系列盘块中的信息的方 法是磁盘高速缓存&lt;/p&gt;

</description>
<pubDate>Tue, 17 Sep 2019 16:07:00 +0000</pubDate>
<dc:creator>小禾点点</dc:creator>
<og:description>中断处理程序的作⽤：I/O中断处理程序的作⽤是将发出I/O请求⽽被阻塞的进程唤醒</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jalja/p/11537890.html</dc:identifier>
</item>
<item>
<title>一次搞懂建模语言UML - sands</title>
<link>http://www.cnblogs.com/sands/p/11538149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sands/p/11538149.html</guid>
<description>&lt;p&gt;Unified Modeling Language (UML)又称统一建模语言或标准建模语言，它是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持，包括由需求分析到规格，到构造和配置。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UML分类&lt;br/&gt;（1）静态模型（系统结构）： 用例图、类图、对象图、构件图、部署图&lt;br/&gt;（2）动态模型（系统行为）：状态图、活动图、顺序图、协作图&lt;/li&gt;
&lt;li&gt;UML中有4种事务：&lt;br/&gt;（1）结构事务：名词、静态部分、物理元素。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-90ffbcf740e9eedb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;（2）行为事务：动词、动态部分、行为。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-aa0734c2ca9bbd32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;（3）分组事务：包。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-ccd526138cb1d0e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;（4）注释事务：注解。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-b6fed951117293b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;用例图&quot;&gt;用例图：&lt;/h2&gt;
&lt;p&gt;用例图是指由参与者（Actor）、用例（Use Case），边界以及它们之间的关系构成的用于描述系统功能的视图。用例图（User Case）是外部用户（被称为参与者）所能观察到的系统功能的模型图。用例图是系统的蓝图，用于需求分析阶段。用例图呈现了一些参与者，一些用例，以及它们之间的关系，主要用于对系统、子系统或类的功能行为进行建模。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-36aeed2f42fd9a2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800&quot; alt=&quot;用例图1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-48293ad2cbd9c2ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800&quot; alt=&quot;用例图2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用例之间的关系&lt;br/&gt;（1）包含 (include) 关系&lt;br/&gt;&lt;strong&gt;父用例包含子用例，父用例执行，子用例必然被执行&lt;/strong&gt;&lt;br/&gt;当两个或多个用例中共用一组相同的动作，这时可以将这组相同的动作抽出来作为一个独立的子用例，供多个基用例所共享。因为子用例被抽出，基用例并非一个完整的用例，所以include关系中的基用例必须和子用例一起使用才够完整，子用例也必然被执行。include关系在用例图中使用带箭头的虚线表示(在线上标注&amp;lt;&amp;gt;)，箭头从基用例指向子用例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-1f58ab766e473f0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）扩展(extend)关系&lt;br/&gt;&lt;strong&gt;子用例扩展父用例，复用执行，子用例不一定执行&lt;/strong&gt;&lt;br/&gt;是对基用例的扩展，基用例是一个完整的用例，即使没有子用例的参与，也可以完成一个完整的功能。 extend关系在用例图中使用带箭头的虚线表示(在线上标注&amp;lt;&amp;gt;)，箭头从子用例指向基用例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-b40bbafc2a24b926.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图例：用户如果如期还书，则还书业务就结束了，如果超期了，才会有罚款的业务，罚款不是必须，所以是扩展关系。&lt;/p&gt;
&lt;h2 id=&quot;类图&quot;&gt;类图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-873625b63d21bae7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类图（Class diagram）展现了一组对象、接口、协作和它们之间的关系。类图是静态视图。&lt;br/&gt;类图中包括：&lt;br/&gt;（1）类&lt;br/&gt;（2）接口&lt;br/&gt;（3）协作&lt;br/&gt;（4）依赖、泛化和关联关系&lt;/p&gt;
&lt;p&gt;使用类图的场景：&lt;br/&gt;（1）对系统的静态设计建模&lt;br/&gt;（2）对简单的协作建模&lt;br/&gt;（3）对逻辑数据库模式建模&lt;/p&gt;
&lt;p&gt;类的分类：&lt;/p&gt;
&lt;p&gt;(1) 实体类：实体类对应系统需求中的每个实体，它们通常需要保存在永久存储体中，一般使用数据库表或文件来记录，实体类既包括存储和传递数据的类，还包括操作数据的类。实体类来源于需求说明中的名词，如学生、商品等。&lt;/p&gt;
&lt;p&gt;(2) 控制类：控制类用于体现应用程序的执行逻辑，提供相应的业务操作，将控制类抽象出来可以降低界面和数据库之间的耦合度。控制类用于对一个或几个用例所特有的控制行为进行建模。控制对象（控制类的实例）通常控制其他对象，因此它们的行为具有协调性质。控制类将用例的特有行为进行封装&lt;/p&gt;
&lt;p&gt;(3) 边界类：边界类用于对外部用户与系统之间的交互对象进行抽象，主要包括界面类，如对话框、窗口、菜单等。&lt;/p&gt;
&lt;p&gt;类图中的关系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;依赖(Dependency)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-9461d3f7d9e318a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-a04d3510f1ba9698.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是一种使用的关系, 即一个类的实现需要另一个类的协助, 所以要尽量不使用双向的互相依赖。可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;泛化（Generalization）&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-b7068aa65bd47eda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-fe32c67af9eafba7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是继承关系的反关系，用于描述父类与子类之间的关系，父类又称作基类或超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的直线来表示。&lt;br/&gt;子类继承自父类，父类是子类的泛化。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关联（Association)&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-f9fdc91f439bdd50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-8fb3a2c1b5c4623d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;关联关系&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;是一种拥有的关系, 它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子。&lt;br/&gt;关联是类之间的结构关系，它描述了一组链，链是对象之间的连接。两个类之间可以有多个由不同角色标识的关联。关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。&lt;/p&gt;
&lt;p&gt;(1) 双向关联。默认情况下，关联是双向的。&lt;/p&gt;
&lt;p&gt;(2) 单向关联&lt;br/&gt;(3)自关联&lt;br/&gt;(4)多重关联&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;聚合（Aggregation）&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-1c3815a695c923ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-eea070d4f2b40635.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享在UML中，聚合关系用带空心菱形的直线表示。例如：汽车发动机(Engine)是汽车(Car)的组成部分，但是汽车发动机可以独立存在，因此，汽车和发动机是聚合关系，如图所示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组合(Composition)&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-db8b55fe6a13bfad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-f9a3f4e040e2a2e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;组合也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束。在UML中，组合关系用带实心菱形的直线表示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实现（Realization）&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-91d8b2467314f76c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-0580d58b96522966.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;是用来规定接口和实现接口的类或者构建结构的关系，接口是操作的集合，而这些操作就用于规定类或者构建的一种服务。&lt;br/&gt;接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现关系(Realization)，在这种关系中，类实现了接口，类中的操作实现了接口中所 声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。例如：定义了一个交通工具接口Vehicle，包含一个抽象操作move()，在类Ship和类Car中都实现了该move()操作，不过具体的实现细节将会不一样，如图所示：&lt;/p&gt;
&lt;h2 id=&quot;对象图&quot;&gt;对象图&lt;/h2&gt;
&lt;p&gt;对象图(ObjectDiagram) 展现了某一时刻一组对象以及它们之间的关系，描述了在类图中所建立的事物的实例的静态快照。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-7ce7880e40636f6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;交互图&quot;&gt;交互图&lt;/h2&gt;
&lt;p&gt;交互图表现为序列图、通信图、交互概览图和计时图。用于动态建模。&lt;/p&gt;
&lt;h3 id=&quot;序列图&quot;&gt;序列图&lt;/h3&gt;
&lt;p&gt;序列图强调消息时间顺序的交互&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-5f681c19cbad0987.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-71b1cc9b9e4ce536.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;通信图&quot;&gt;通信图&lt;/h3&gt;
&lt;p&gt;通信图（协作图）强调接收和发送信息的对象的结构组织的交互&lt;br/&gt;对象：图中的矩形元素即为对象，其中冒号前面部分为对象名，后面为类名，表示类的一个实例。&lt;br/&gt;链接：用两个对象之间的单一线条表示，用来在通信图中关联对象，目的是让消息在不同系统对象之间传递。可以理解链接是公路，消息是车。&lt;br/&gt;消息：通信图中对象之间通信的方式。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-65799305e3a2825d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-67a23e161ee66aae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-586196fd2561aa8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;交互概览图&quot;&gt;交互概览图&lt;/h3&gt;
&lt;p&gt;交互概览图强调控制流的交互图&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-1dc98d02c22548dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;计时图&quot;&gt;计时图&lt;/h3&gt;
&lt;p&gt;计时图适合嵌入式系统建模的交互图&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-8946e7a13c88c003.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;状态图&quot;&gt;状态图&lt;/h2&gt;
&lt;p&gt;用来描述一个特定的对象所有可能的状态，以及由于各种事件的发生而引起的状态之间的转移和变化。用于对系统的动态方面建模。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-d11061ee7f6f87c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;活动图&quot;&gt;活动图&lt;/h2&gt;
&lt;p&gt;将进程或其他计算的结构展示为计算内部一步步的控制流和数据流，主要用来描述系统的动态视图。活动图在本质上是一种流程图。活动图着重表现从一个活动到另一个活动的控制流，是内部处理驱动的流程。&lt;br/&gt;活动图主要描述行为的动作，&lt;br/&gt;状态图主要描述行为的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-916ea1114a65eded.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-1675696e4f01e1da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;构件图&quot;&gt;构件图&lt;/h2&gt;
&lt;p&gt;使用构件图的思想是复用。就像是我们盖房子，当房子的大体框架建好之后，剩下的门和窗户家具之类的直接拿来安装上即可，不需要再从新制作，直接拿来复用的思想。这些门和窗户就相当于一个个的构件。&lt;br/&gt;构件有一下几种类型：&lt;br/&gt;（1）部署构件：dll文件、exe文件、com+对象、CORBA对象、EJB、动态Web页和数据库表等。&lt;br/&gt;（2）工作产品构件：源代码文件、数据文件等&lt;br/&gt;（3）执行构件：系统执行后得到的构件。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-ba9377d859dbfab5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-394539ed43b98ab3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;部署图&quot;&gt;部署图&lt;/h2&gt;
&lt;p&gt;表示系统中软件和硬件的物理架构。&lt;br/&gt;从部署图中，可以了解到软件和硬件组件之间的物理关系以及处理节点的组件分布情况。使用部署图可以显示运行时系统的结构，同时还传达构成应用程序的硬件和软件元素的配置和部署方式。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-9ffb1e0debcbc677.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;包图&quot;&gt;包图&lt;/h2&gt;
&lt;p&gt;在 UML 中用类似于文件夹的符号表示的模型元素的组合。包图是一种维护和描述系统总体结构的模型的重要建模工具，通过对包中各个包以及包之间关系的描述，展现出系统的模块与模块之间的依赖关系。&lt;br/&gt;包图的作用：包图可以描述需求，设计的高阶概况；包图通过合理规划自身功能反应系统的高层架构，在逻辑上将系统进行模块化分解；包图最终是组织源码的方式。&lt;br/&gt;一个包图可以由任何一种ＵＭＬ图组成，通常是ＵＭＬ用例图或是ＵＭＬ类图。&lt;br/&gt;包被描述成文件夹，可以用于ＵＭＬ任何一种的图上。&lt;br/&gt;包图只是把某些类放在一个包中，因此可以看做是类图的一种。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8145282-47e4d61d8d4fb730.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Sep 2019 16:05:00 +0000</pubDate>
<dc:creator>sands</dc:creator>
<og:description>Unified Modeling Language (UML)又称统一建模语言或标准建模语言，它是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持，包括由需求分析到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sands/p/11538149.html</dc:identifier>
</item>
<item>
<title>Dijkstra算法详细(单源最短路径算法) - bigsai</title>
<link>http://www.cnblogs.com/bigsai/p/11537975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigsai/p/11537975.html</guid>
<description>&lt;p&gt;对于&lt;code&gt;dijkstra&lt;/code&gt;算法，很多人可能感觉熟悉而又陌生，可能大部分人比较了解&lt;code&gt;bfs和dfs&lt;/code&gt;，而对dijkstra和floyd算法可能知道大概是图论中的某个算法，但是可能不清楚其中的作用和原理，又或许，你曾经感觉它很难，那么，这个时候正适合你重新认识它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dijkstra能是干啥的？&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190909002921297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjkzMTcx,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Dijkstra是用来求单源最短路径的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就拿上图来说，假如直到的路径和长度已知，那么可以使用&lt;code&gt;dijkstra&lt;/code&gt;算法计算&lt;strong&gt;南京到图中所有节点的最短距离。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单源&lt;/strong&gt;什么意思？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从一个顶点出发，Dijkstra算法只能求一个顶点到其他点的最短距离而不能任意两点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;和&lt;code&gt;bfs&lt;/code&gt;求的最短路径有什么区别？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;bfs&lt;/code&gt;求的与其说是路径，不如说是&lt;strong&gt;次数&lt;/strong&gt;。因为bfs他是按照队列一次一次进行加入相邻的点，而两点之间没有权值或者权值相等(代价相同)。处理的更多是偏向迷宫类的这种都是只能走邻居(不排除特例)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Dijkstra在处理具体实例的应用还是很多的，因为具体的问题其实带权更多一些。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;比如一个城市有多个乡镇，乡镇可能有道路，也可能没有，整个乡镇联通，如果想计算每个乡镇到ａ镇的最短路径，那么Dijkstra就派上了用场。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于一个算法，首先要理解它的&lt;strong&gt;运行流程&lt;/strong&gt;。&lt;br/&gt;对于一个Dijkstra算法而言，前提是它的前提条件和环境：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个连通图，若干节点，节点可能有数值，但是&lt;code&gt;路径&lt;/code&gt;一定有&lt;code&gt;权值&lt;/code&gt;。并且路径&lt;strong&gt;不能为负&lt;/strong&gt;。否则Dijkstra就不适用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Dijkstra的核心思想是贪心算法的思想。不懂贪心？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。&lt;br/&gt;贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于贪心算法，在很多情况都能用到。下面举几个不恰当的例子！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;打个比方，吃自助餐，目标是吃回本，那么胃有限那么每次都仅最贵的吃。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上学时，麻麻说只能带5个苹果，你想带最多，那么选五个苹果你每次都选最大的那个五次下来你就选的最重的那个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不难发现上面的&lt;code&gt;策略&lt;/code&gt;&lt;strong&gt;虽然没有很强的理论数学依据&lt;/strong&gt;，或者不太好说明。但是&lt;strong&gt;事实规律就是那样&lt;/strong&gt;，并且对于贪心问题大部分都需要&lt;strong&gt;排序&lt;/strong&gt;,还可能会遇到类排序。并且一个物体可能有多个属性，不同问题需要按照不同属性进行排序，操作。&lt;/p&gt;
&lt;p&gt;那么我们的&lt;code&gt;Dijkstra&lt;/code&gt;是如何贪心的呢？对于一个点，求图中所有点的最短路径，如果没有正确的方法胡乱想确实很难算出来，并且如果暴力匹配复杂度呈指数级上升不适合解决实际问题。&lt;/p&gt;
&lt;p&gt;那么我们该怎么想呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dijkstra算法的前提&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先，Dijkstra处理的是带正权值的&lt;code&gt;有权图&lt;/code&gt;，那么，就需要一个&lt;strong&gt;二维数组&lt;/strong&gt;（如果空间大用list数组）存储各个点到达(&lt;code&gt;边&lt;/code&gt;)的权值大小。&lt;strong&gt;(邻接矩阵或者邻接表存储)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;其次，还需要一个&lt;strong&gt;boolean数组&lt;/strong&gt;判断那些点已经确定最短长度，那些点没有确定。&lt;strong&gt;int数组&lt;/strong&gt;记录距离(&lt;strong&gt;在算法执行过程可能被多次更新&lt;/strong&gt;)。&lt;/li&gt;
&lt;li&gt;需要&lt;strong&gt;优先队列&lt;/strong&gt;加入&lt;strong&gt;已经确定点的周围点&lt;/strong&gt;。每次抛出确定最短路径的那个并且确定最短，直到所有点路径确定最短为止。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;简单的概括流程为&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一般从选定点开始抛入优先队列。（路径一般为0），&lt;code&gt;boolean数组&lt;/code&gt;标记0的位置(最短为0) , 然后0&lt;code&gt;周围连通的点&lt;/code&gt;抛入优先队列中（可能是node类），并把各个点的距离记录到对应数组内(&lt;strong&gt;如果小于就更新，大于就不动，初始第一次是无穷肯定会更新&lt;/strong&gt;)，第一次就结束了&lt;/li&gt;
&lt;li&gt;从队列中抛出&lt;code&gt;距离最近&lt;/code&gt;的那个点&lt;code&gt;B&lt;/code&gt;（&lt;strong&gt;第一次就是0周围邻居&lt;/strong&gt;）。这个点距离一定是最近的（所有权值都是正的，点的距离只能越来越长。）标记这个点为&lt;code&gt;true&lt;/code&gt;，&lt;strong&gt;并且将这个点的邻居加入队列&lt;/strong&gt;(下一次确定的最短点在前面未确定和这个点邻居中产生),并更新通过&lt;code&gt;B&lt;/code&gt;点计算各个位置的长度，如果小于则更新！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190913132647145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjkzMTcx,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;重复二的操作，直到所有点都确定。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190913133500806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjkzMTcx,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package 图论;

import java.util.ArrayDeque;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;

public class dijkstra {
    static class node
    {
        int x; //节点编号
        int lenth;//长度
        public node(int x,int lenth) {
            this.x=x;
            this.lenth=lenth;
        }
    }

    public static void main(String[] args) {
         
        int[][] map = new int[6][6];//记录权值，顺便记录链接情况，可以考虑附加邻接表
        initmap(map);//初始化
        boolean bool[]=new boolean[6];//判断是否已经确定
        int len[]=new int[6];//长度
        for(int i=0;i&amp;lt;6;i++)
        {
            len[i]=Integer.MAX_VALUE;
        }
        Queue&amp;lt;node&amp;gt;q1=new PriorityQueue&amp;lt;node&amp;gt;(com);
        len[0]=0;//从0这个点开始
        q1.add(new node(0, 0));
        int count=0;//计算执行了几次dijkstra
        while (!q1.isEmpty()) {
            node t1=q1.poll();
            int index=t1.x;//节点编号
            int length=t1.lenth;//节点当前点距离
            bool[index]=true;//抛出的点确定
            count++;//其实执行了6次就可以确定就不需要继续执行了  这句可有可无，有了减少计算次数
            for(int i=0;i&amp;lt;map[index].length;i++)
            {
                if(map[index][i]&amp;gt;0&amp;amp;&amp;amp;!bool[i])
                {
                    node node=new node(i, length+map[index][i]);
                    if(len[i]&amp;gt;node.lenth)//需要更新节点的时候更新节点并加入队列
                    {
                        len[i]=node.lenth;
                        q1.add(node);
                    }
                }
            }
        }       
        for(int i=0;i&amp;lt;6;i++)
        {
            System.out.println(len[i]);
        }
    }
    static Comparator&amp;lt;node&amp;gt;com=new Comparator&amp;lt;node&amp;gt;() {

        public int compare(node o1, node o2) {
            return o1.lenth-o2.lenth;
        }
    };

    private static void initmap(int[][] map) {
        map[0][1]=2;map[0][2]=3;map[0][3]=6;
        map[1][0]=2;map[1][4]=4;map[1][5]=6;
        map[2][0]=3;map[2][3]=2;
        map[3][0]=6;map[3][2]=2;map[3][4]=1;map[3][5]=3;
        map[4][1]=4;map[4][3]=1;
        map[5][1]=6;map[5][3]=3;    
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190915181948987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjkzMTcx,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;当然，dijkstra算法比较灵活，实现方式也可能有点区别，但是思想是不变的：一个贪心思路。dijkstra执行一次就能够确定一个点，所以只需要执行点的总和次数即可完成整个算法。&lt;/p&gt;
&lt;p&gt;欢迎感谢小伙伴点赞、关注，&lt;strong&gt;赠人玫瑰，手有余香&lt;/strong&gt;！蟹蟹！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1745421/201909/1745421-20190917232152715-856969062.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Sep 2019 15:22:00 +0000</pubDate>
<dc:creator>bigsai</dc:creator>
<og:description>介绍 对于 算法，很多人可能感觉熟悉而又陌生，可能大部分人比较了解 ，而对dijkstra和floyd算法可能知道大概是图论中的某个算法，但是可能不清楚其中的作用和原理，又或许，你曾经感觉它很难，那么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigsai/p/11537975.html</dc:identifier>
</item>
<item>
<title>5.Sentinel源码分析—Sentinel如何实现自适应限流？ - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/11537947.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/11537947.html</guid>
<description>&lt;p&gt;Sentinel源码解析系列：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11439993.html&quot;&gt;1.Sentinel源码分析—FlowRuleManager加载规则做了什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11451557.html&quot;&gt;2. Sentinel源码分析—Sentinel是如何进行流量统计的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11489128.html&quot;&gt;3. Sentinel源码分析— QPS流量控制是如何实现的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/luozhiyun/p/11517918.html&quot;&gt;4.Sentinel源码分析— Sentinel是如何做到降级的？&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;这篇文章主要学习一下Sentinel如何实现自适应限流的。&lt;br/&gt;为什么要做自适应限流，官方给了两个理由：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;保证系统不被拖垮&lt;/li&gt;
&lt;li&gt;在系统稳定的前提下，保持系统的吞吐量&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我再贴一下官方的原理：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204119/201909/1204119-20190917231341386-2088117907.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;能够保证水管里的水量，能够让水顺畅的流动，则不会增加排队的请求；也就是说，这个时候的系统负载不会进一步恶化。&lt;/li&gt;
&lt;li&gt;当保持入口的流量是水管出来的流量的最大的值的时候，可以最大利用水管的处理能力。&lt;br/&gt;更加具体的原理解释可以看官方：&lt;a href=&quot;https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81&quot;&gt;系统自适应限流&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以看起来好像很厉害的样子，所以我们来看看具体实现吧。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置系统自适应规则&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;SystemRule&amp;gt; rules = new ArrayList&amp;lt;SystemRule&amp;gt;();
SystemRule rule = new SystemRule();
//限制最大负载
rule.setHighestSystemLoad(3.0);
// cpu负载60%
rule.setHighestCpuUsage(0.6);
// 设置平均响应时间 10 ms
rule.setAvgRt(10);
// 设置qps is 20
rule.setQps(20);
// 设置最大线程数 10
rule.setMaxThread(10);

rules.add(rule);
SystemRuleManager.loadRules(Collections.singletonList(rule));&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;设置限流&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Entry entry = null;
try {
    entry = SphU.entry(&quot;methodA&quot;, EntryType.IN); 
    //dosomething
} catch (BlockException e1) {
    block.incrementAndGet();
    //dosomething
} catch (Exception e2) {
    // biz exception
} finally { 
    if (entry != null) {
        entry.exit();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量（EntryType.IN），比如 Web 服务或 Dubbo 服务端接收的请求，都属于入口流量。&lt;/p&gt;
&lt;p&gt;我们先讲一下SystemRuleManager这个类在初始化的时候做了什么吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SystemRuleManager&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static SystemStatusListener statusListener = null;
@SuppressWarnings(&quot;PMD.ThreadPoolCreationRule&quot;)
private final static ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1,
    new NamedThreadFactory(&quot;sentinel-system-status-record-task&quot;, true));

static {
    checkSystemStatus.set(false);
    statusListener = new SystemStatusListener();
    scheduler.scheduleAtFixedRate(statusListener, 5, 1, TimeUnit.SECONDS);
    currentProperty.addListener(listener);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SystemRuleManager初始化的时候会调用静态代码块，然后用scheduler线程池定时调用SystemStatusListener类的run方法。我们进入到SystemStatusListener类里看一下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SystemStatusListener#run&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void run() {
    try {
        OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);
        currentLoad = osBean.getSystemLoadAverage();
       
        currentCpuUsage = osBean.getSystemCpuLoad();

        StringBuilder sb = new StringBuilder();
        if (currentLoad &amp;gt; SystemRuleManager.getHighestSystemLoad()) {
            sb.append(&quot;load:&quot;).append(currentLoad).append(&quot;;&quot;);
            sb.append(&quot;cpu:&quot;).append(currentCpuUsage).append(&quot;;&quot;);
            sb.append(&quot;qps:&quot;).append(Constants.ENTRY_NODE.passQps()).append(&quot;;&quot;);
            sb.append(&quot;rt:&quot;).append(Constants.ENTRY_NODE.avgRt()).append(&quot;;&quot;);
            sb.append(&quot;thread:&quot;).append(Constants.ENTRY_NODE.curThreadNum()).append(&quot;;&quot;);
            sb.append(&quot;success:&quot;).append(Constants.ENTRY_NODE.successQps()).append(&quot;;&quot;);
            sb.append(&quot;minRt:&quot;).append(Constants.ENTRY_NODE.minRt()).append(&quot;;&quot;);
            sb.append(&quot;maxSuccess:&quot;).append(Constants.ENTRY_NODE.maxSuccessQps()).append(&quot;;&quot;);
            RecordLog.info(sb.toString());
        }

    } catch (Throwable e) {
        RecordLog.info(&quot;could not get system error &quot;, e);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法用来做两件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定时收集全局资源情况，并打印日志&lt;/li&gt;
&lt;li&gt;给全局变量currentLoad和currentCpuUsage赋值，用来做限流使用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后看一下SystemRuleManager.loadRules方法。SystemRuleManager和其他的规则管理是一样的，当调用loadRules方法的时候会调用内部的listener并触发它的configUpdate方法。&lt;br/&gt;在SystemRuleManager中实现类了一个SystemPropertyListener，最终SystemRuleManager.loadRules方法会调用到SystemPropertyListener的configUpdate中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SystemPropertyListener#configUpdate&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void configUpdate(List&amp;lt;SystemRule&amp;gt; rules) {
    restoreSetting();
    // systemRules = rules;
    if (rules != null &amp;amp;&amp;amp; rules.size() &amp;gt;= 1) {
        for (SystemRule rule : rules) {
            loadSystemConf(rule);
        }
    } else {
        checkSystemStatus.set(false);
    }

    RecordLog.info(String.format(&quot;[SystemRuleManager] Current system check status: %s, &quot;
            + &quot;highestSystemLoad: %e, &quot;
            + &quot;highestCpuUsage: %e, &quot;
            + &quot;maxRt: %d, &quot;
            + &quot;maxThread: %d, &quot;
            + &quot;maxQps: %e&quot;,
        checkSystemStatus.get(),
        highestSystemLoad,
        highestCpuUsage,
        maxRt,
        maxThread,
        qps));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法很简单，首先是调用restoreSetting，用来重置rule的属性，然后遍历rule调用loadSystemConf对规则进行设置：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SystemRuleManager#loadSystemConf&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void loadSystemConf(SystemRule rule) {
    boolean checkStatus = false;
    // Check if it's valid.

    if (rule.getHighestSystemLoad() &amp;gt;= 0) {
        highestSystemLoad = Math.min(highestSystemLoad, rule.getHighestSystemLoad());
        highestSystemLoadIsSet = true;
        checkStatus = true;
    }

    if (rule.getHighestCpuUsage() &amp;gt;= 0) {
        highestCpuUsage = Math.min(highestCpuUsage, rule.getHighestCpuUsage());
        highestCpuUsageIsSet = true;
        checkStatus = true;
    }

    if (rule.getAvgRt() &amp;gt;= 0) {
        maxRt = Math.min(maxRt, rule.getAvgRt());
        maxRtIsSet = true;
        checkStatus = true;
    }
    if (rule.getMaxThread() &amp;gt;= 0) {
        maxThread = Math.min(maxThread, rule.getMaxThread());
        maxThreadIsSet = true;
        checkStatus = true;
    }

    if (rule.getQps() &amp;gt;= 0) {
        qps = Math.min(qps, rule.getQps());
        qpsIsSet = true;
        checkStatus = true;
    }

    checkSystemStatus.set(checkStatus);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些属性都是在限流控制中会用到的属性，无论设置哪个属性都会设置checkStatus=true表示开启系统自适应限流。&lt;/p&gt;
&lt;p&gt;在设置好限流规则后会进入到SphU.entry方法中，通过创建slot链调用到SystemSlot，这里是系统自适应限流的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SystemSlot#entry&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count,
                  boolean prioritized, Object... args) throws Throwable {
      //检查一下是否符合限流条件，符合则进行限流
    SystemRuleManager.checkSystem(resourceWrapper);
    fireEntry(context, resourceWrapper, node, count, prioritized, args);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SystemRuleManager#checkSystem&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void checkSystem(ResourceWrapper resourceWrapper) throws BlockException {
    // Ensure the checking switch is on.
    if (!checkSystemStatus.get()) {
        return;
    }
    //如果不是入口流量，那么直接返回
    // for inbound traffic only
    if (resourceWrapper.getType() != EntryType.IN) {
        return;
    }

    // total qps
    double currentQps = Constants.ENTRY_NODE == null ? 0.0 : Constants.ENTRY_NODE.successQps();
    if (currentQps &amp;gt; qps) {
        throw new SystemBlockException(resourceWrapper.getName(), &quot;qps&quot;);
    }

    // total thread
    int currentThread = Constants.ENTRY_NODE == null ? 0 : Constants.ENTRY_NODE.curThreadNum();
    if (currentThread &amp;gt; maxThread) {
        throw new SystemBlockException(resourceWrapper.getName(), &quot;thread&quot;);
    }

    double rt = Constants.ENTRY_NODE == null ? 0 : Constants.ENTRY_NODE.avgRt();
    if (rt &amp;gt; maxRt) {
        throw new SystemBlockException(resourceWrapper.getName(), &quot;rt&quot;);
    }

    // load. BBR algorithm.
    if (highestSystemLoadIsSet &amp;amp;&amp;amp; getCurrentSystemAvgLoad() &amp;gt; highestSystemLoad) {
        if (!checkBbr(currentThread)) {
            throw new SystemBlockException(resourceWrapper.getName(), &quot;load&quot;);
        }
    }

    // cpu usage
    if (highestCpuUsageIsSet &amp;amp;&amp;amp; getCurrentCpuUsage() &amp;gt; highestCpuUsage) {
        if (!checkBbr(currentThread)) {
            throw new SystemBlockException(resourceWrapper.getName(), &quot;cpu&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法首先会校验一下checkSystemStatus状态和EntryType是不是IN，如果不是则直接返回。&lt;br/&gt;然后对Constants.ENTRY_NODE进行操作。这个对象是一个final static 修饰的变量，代表是全局对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final static ClusterNode ENTRY_NODE = new ClusterNode();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以这里的限流操作都是对全局其作用的，而不是对资源起作用。ClusterNode还是继承自StatisticNode，所以最后都是调用StatisticNode的successQps、curThreadNum、avgRt，这几个方法我的前几篇文章都已经讲过了，感兴趣的可以自己去翻一下，这里就不过多涉及了。&lt;/p&gt;
&lt;p&gt;在下面调用getCurrentSystemAvgLoad方法和getCurrentCpuUsage方法调用到SystemStatusListener设置的全局变量currentLoad和currentCpuUsage。这两个参数是SystemRuleManager的定时任务定时收集的，忘了的同学回到上面讲解SystemRuleManager的地方看一下。&lt;/p&gt;
&lt;p&gt;在做load判断和cpu usage判断的时候会还会调用checkBbr方法来判断：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static boolean checkBbr(int currentThread) {
    if (currentThread &amp;gt; 1 &amp;amp;&amp;amp;
        currentThread &amp;gt; Constants.ENTRY_NODE.maxSuccessQps() * Constants.ENTRY_NODE.minRt() / 1000) {
        return false;
    }
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说：当系统 load1 超过阈值，且系统当前的并发线程数超过系统容量时才会触发系统保护。系统容量由系统的 maxQps * minRt 计算得出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StatisticNode#maxSuccessQps&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public double maxSuccessQps() {
    return rollingCounterInSecond.maxSuccess() * rollingCounterInSecond.getSampleCount();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;maxSuccessQps方法是用窗口内的最大成功调用数和窗口数量相乘rollingCounterInSecond的窗口1秒的窗口数量是2，最大成功调用数如下得出：&lt;br/&gt;&lt;strong&gt;ArrayMetric#maxSuccess&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public long maxSuccess() {
    data.currentWindow();
    long success = 0;

    List&amp;lt;MetricBucket&amp;gt; list = data.values();
    for (MetricBucket window : list) {
        if (window.success() &amp;gt; success) {
            success = window.success();
        }
    }
    return Math.max(success, 1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最大成功调用数是通过整个遍历整个窗口，获取所有窗口里面最大的调用数。所以这样的最大的并发量是一个预估值，不是真实值。&lt;/p&gt;
&lt;p&gt;看到这里我们再来看一下Constants.ENTRY_NODE的信息是怎么被收集的。&lt;br/&gt;我在分析StatisticSlot这个类的时候有一段代码我当时也没看懂有什么用，现在就迎刃而解了：&lt;br/&gt;&lt;strong&gt;StatisticSlot#entry&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void entry(Context context, ResourceWrapper resourceWrapper, DefaultNode node, int count,
                  boolean prioritized, Object... args) throws Throwable {
    try { 
            ....
        if (resourceWrapper.getType() == EntryType.IN) {
            // Add count for global inbound entry node for global statistics.
            Constants.ENTRY_NODE.increaseThreadNum();
            Constants.ENTRY_NODE.addPassRequest(count);
        }
            ....
    } catch (PriorityWaitException ex) {
            ....
        if (resourceWrapper.getType() == EntryType.IN) {
            // Add count for global inbound entry node for global statistics.
            Constants.ENTRY_NODE.increaseThreadNum();
        }
         ....
    } catch (BlockException e) {
            ....
        if (resourceWrapper.getType() == EntryType.IN) {
            // Add count for global inbound entry node for global statistics.
            Constants.ENTRY_NODE.increaseBlockQps(count);
        }
            .... 
        throw e;
    } catch (Throwable e) {
         ....
        if (resourceWrapper.getType() == EntryType.IN) {
            Constants.ENTRY_NODE.increaseExceptionQps(count);
        }
        throw e;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在StatisticSlot的entry方法里有很多对于type的判断，如果是EntryType.IN，那么就调用Constants.ENTRY_NODE的静态方法进行数据的收集。&lt;/p&gt;
&lt;p&gt;所以看到这里我们可以知道，在前面有很多看不懂的代码其实只要慢慢琢磨，打个标记，那么在后面的解析的过程中还是能够慢慢看懂的。&lt;/p&gt;
&lt;p&gt;共勉~~&lt;/p&gt;
</description>
<pubDate>Tue, 17 Sep 2019 15:14:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>Sentinel源码解析系列： '1.Sentinel源码分析—FlowRuleManager加载规则做了什么？' '2. Sentinel源码分析—Sentinel是如何进行流量统计的？' '3.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/11537947.html</dc:identifier>
</item>
</channel>
</rss>