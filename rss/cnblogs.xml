<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小白学 Python 爬虫（12）：urllib 基础使用（二） - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11993172.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11993172.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191206084518764-1354305081.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我用 Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/13/3303836941/&quot;&gt;小白学 Python 爬虫（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/20/2586166930/&quot;&gt;小白学 Python 爬虫（2）：前置准备（一）基本类库的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/21/1005563697/&quot;&gt;小白学 Python 爬虫（3）：前置准备（二）Linux基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/22/3679472340/&quot;&gt;小白学 Python 爬虫（4）：前置准备（三）Docker基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/24/334078215/&quot;&gt;小白学 Python 爬虫（5）：前置准备（四）数据库基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/25/1881661601/&quot;&gt;小白学 Python 爬虫（6）：前置准备（五）爬虫框架的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/26/1197821400/&quot;&gt;小白学 Python 爬虫（7）：HTTP 基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/27/101847406/&quot;&gt;小白学 Python 爬虫（8）：网页基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/28/1668465912/&quot;&gt;小白学 Python 爬虫（9）：爬虫基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/01/2475257648/&quot;&gt;小白学 Python 爬虫（10）：Session 和 Cookies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/12/02/2333822325/&quot;&gt;小白学 Python 爬虫（11）：urllib 基础使用（一）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;上一篇我们聊了 urlopen 的基本使用姿势，但这几个简单的参数并不足以构建一个完整的请求。对于复杂的请求，例如需要添加请求头就显得无能为力，这时我们可以选择使用 Request 。&lt;/p&gt;
&lt;h2 id=&quot;request&quot;&gt;Request&lt;/h2&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://docs.python.org/zh-cn/3.7/library/urllib.request.html&quot; class=&quot;uri&quot;&gt;https://docs.python.org/zh-cn/3.7/library/urllib.request.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先来看一下 Request 的使用语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;url：请求的地址链接，只有这个是必传参数，其余都是可选参数。&lt;/li&gt;
&lt;li&gt;data：如果这个参数需要传递，则必须传bytes（字节流）类型的。&lt;/li&gt;
&lt;li&gt;headers：请求头信息，它是一个字典，可以在构造请求的时候通过 headers 之间构造，也可以调用 add_header() 添加。&lt;/li&gt;
&lt;li&gt;origin_req_host：发起请求一方的 host 名称或者也可以是 ip 地址。&lt;/li&gt;
&lt;li&gt;unverifiable：指的是这个请求是否是无法验证的，默认是 False 。意思就是说用户没有足够权限来选择接收这个请求的结果。例如我们请求一个HTML文档中的图片，但是我们没有自动抓取图像的权限，这时 unverifiable 的值就是 True 。&lt;/li&gt;
&lt;li&gt;method：请求方法，如 GET 、 POST 、 PUT 、 DELETE 等等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还是先来看一个简单的示例，使用 Request 爬取博客网站：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import urllib.request

request = urllib.request.Request('https://www.geekdigging.com/')
response = urllib.request.urlopen(request)
print(response.read().decode('utf-8'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里还是使用 urlopen() 来发起请求，只是参数不再是之前的 URL 、 Data 、 timeout 等等信息，而是变成了 &lt;code&gt;Request&lt;/code&gt; 类型的对象。&lt;/p&gt;
&lt;p&gt;我们来构建一个稍微复杂一点的请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import urllib.request, urllib.parse
import json

url = 'https://httpbin.org/post'
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36',
    'Content-Type': 'application/json;encoding=utf-8',
    'Host': 'geekdigging.com'
}
data = {
    'name': 'geekdigging',
    'hello':'world'
}
data = bytes(json.dumps(data), encoding='utf8')
req = urllib.request.Request(url=url, data=data, headers=headers, method='POST')
resp = urllib.request.urlopen(req)
print(resp.read().decode('utf-8'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;args&quot;: {}, 
  &quot;data&quot;: &quot;{\&quot;name\&quot;: \&quot;geekdigging\&quot;, \&quot;hello\&quot;: \&quot;world\&quot;}&quot;, 
  &quot;files&quot;: {}, 
  &quot;form&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Accept-Encoding&quot;: &quot;identity&quot;, 
    &quot;Content-Length&quot;: &quot;41&quot;, 
    &quot;Content-Type&quot;: &quot;application/json;encoding=utf-8&quot;, 
    &quot;Host&quot;: &quot;geekdigging.com&quot;, 
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36&quot;
  }, 
  &quot;json&quot;: {
    &quot;hello&quot;: &quot;world&quot;, 
    &quot;name&quot;: &quot;geekdigging&quot;
  }, 
  &quot;origin&quot;: &quot;116.234.254.11, 116.234.254.11&quot;, 
  &quot;url&quot;: &quot;https://geekdigging.com/post&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们通过 4 个参数构建了一个 &lt;code&gt;Request&lt;/code&gt; 对象。&lt;/p&gt;
&lt;p&gt;通过 url 指定了访问的链接，还是前面一片文章中提到的测试链接。&lt;/p&gt;
&lt;p&gt;在 headers 中指定了 &lt;code&gt;User-Agent&lt;/code&gt; 、 &lt;code&gt;Content-Type&lt;/code&gt; 和 &lt;code&gt;Host&lt;/code&gt; 3 个参数。&lt;/p&gt;
&lt;p&gt;在 data 中使用 &lt;code&gt;json.dumps()&lt;/code&gt; 将一个 dict 转换成 json 格式，并通过 &lt;code&gt;bytes()&lt;/code&gt; 最终转换为字节流。&lt;/p&gt;
&lt;p&gt;最后，指定了访问方式为 POST 。&lt;/p&gt;
&lt;p&gt;从最终的结果中，可以看到我们前面的设定全都成功。&lt;/p&gt;
&lt;h2 id=&quot;进阶操作&quot;&gt;进阶操作&lt;/h2&gt;
&lt;p&gt;前面我们使用 Request 完成了请求头的添加，如果我们想处理 Cookies 和使用代理访问，就需要使用到更加强大的 Handler 了。 Handler 可以简单理解为各种功能的处理器，使用它，几乎可以为我们做到所有有关 HTTP 请求的事情。&lt;/p&gt;
&lt;p&gt;urllib.request 为我们提供了 BaseHandler 类，它是所有其他 Handler 的父类，它提供了直接使用使用的方法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;add_parent()：添加director作为父类。&lt;/li&gt;
&lt;li&gt;close()：关闭它的父类。&lt;/li&gt;
&lt;li&gt;parent()：打开使用不同的协议或处理错误。&lt;/li&gt;
&lt;li&gt;default_open()：捕获所有的URL及子类，在协议打开之前调用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，就有各种 Handler 子类集成这个 BaseHandler 类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HTTPDefaultErrorHandler：用来处理http响应错误，错误会抛出HTTPError类的异常。&lt;/li&gt;
&lt;li&gt;HTTPRedirectHandler：用于处理重定向。&lt;/li&gt;
&lt;li&gt;ProxyHandler：用于设置代理，默认代理为空。&lt;/li&gt;
&lt;li&gt;HTTPPasswordMgr：用于管理密码，它维护用户名和密码表。&lt;/li&gt;
&lt;li&gt;AbstractBasicAuthHandler：用于获取用户/密码对，然后重试请求来处理身份验证请求。&lt;/li&gt;
&lt;li&gt;HTTPBasicAuthHandler：用于重试带有身份认证信息的请求。&lt;/li&gt;
&lt;li&gt;HTTPCookieProcessor：用于处理cookies。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;等等， urllib 为我们提供的 BaseHandler 子类非常的多，小编这里就不一一列举，各位同学可以通过访问官方文档来查看。&lt;/p&gt;
&lt;p&gt;官方文档地址：&lt;a href=&quot;https://docs.python.org/zh-cn/3.7/library/urllib.request.html#basehandler-objects&quot; class=&quot;uri&quot;&gt;https://docs.python.org/zh-cn/3.7/library/urllib.request.html#basehandler-objects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在介绍如何使用 Handler 之前，先介绍一个高级类： OpenerDirector 。&lt;/p&gt;
&lt;p&gt;OpenerDirector 是用来处理URL的高级类，它分三个阶段来打开URL：&lt;/p&gt;
&lt;p&gt;在每个阶段中调用这些方法的顺序是通过对处理程序实例进行排序来确定的;每个使用此类方法的程序都会调用 protocol_request() 方法来预处理请求，然后调用 protocol_open() 来处理请求;最后调用 protocol_response() 方法来处理响应。&lt;/p&gt;
&lt;p&gt;我们可以称 OpenerDirector 为 Opener 。我们之前用过 urlopen() 这个方法，实际上它就是 urllib 为我们提供的一个 Opener 。&lt;/p&gt;
&lt;p&gt;Opener的方法包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;add_handler(handler)：添加处理程序到链接中&lt;/li&gt;
&lt;li&gt;open(url,data=None[,timeout])：打开给定的URL与urlopen()方法相同&lt;/li&gt;
&lt;li&gt;error(proto,*args)：处理给定协议的错误&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们来演示一下如何获取网站的 Cookies ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import http.cookiejar, urllib.request

# 实例化cookiejar对象
cookie = http.cookiejar.CookieJar()
# 使用 HTTPCookieProcessor 构建一个 handler
handler = urllib.request.HTTPCookieProcessor(cookie)
# 构建Opener
opener = urllib.request.build_opener(handler)
# 发起请求
response = opener.open('https://www.baidu.com/')
print(cookie)
for item in cookie:
    print(item.name + &quot; = &quot; + item.value)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中具体的含义小编就不再解释了，注释已经写得比较完善。最后得到的打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;CookieJar[&amp;lt;Cookie BAIDUID=48EA1A60922D7A30F711A420D3C5BA22:FG=1 for .baidu.com/&amp;gt;, &amp;lt;Cookie BIDUPSID=48EA1A60922D7A30DA2E4CBE7B81D738 for .baidu.com/&amp;gt;, &amp;lt;Cookie PSTM=1575167484 for .baidu.com/&amp;gt;, &amp;lt;Cookie BD_NOT_HTTPS=1 for www.baidu.com/&amp;gt;]&amp;gt;
BAIDUID = 48EA1A60922D7A30F711A420D3C5BA22:FG=1
BIDUPSID = 48EA1A60922D7A30DA2E4CBE7B81D738
PSTM = 1575167484
BD_NOT_HTTPS = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里产生一个问题， cookie 既然可以打印，那么我们能不能将 cookie 的输出保存到文件中呢？&lt;/p&gt;
&lt;p&gt;答案当然是可以的，因为我们知道， cookie 本身就是保存在文件中的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cookies 保存 Mozilla 型文件示例
filename = 'cookies_mozilla.txt'
cookie = http.cookiejar.MozillaCookieJar(filename)
handler = urllib.request.HTTPCookieProcessor(cookie)
opener = urllib.request.build_opener(handler)
response = opener.open('http://www.baidu.com')
cookie.save(ignore_discard=True, ignore_expires=True)
print('cookies_mozilla 保存成功')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们需修改之前的 &lt;code&gt;CookieJar&lt;/code&gt; 为 &lt;code&gt;MozillaCookieJar&lt;/code&gt; ，它在生成文件时会用到，是 CookieJar 的子类，可以用来处理 Cookies 和文件相关的事件，比如读取和保存 Cookies ，可以将 Cookies 保存成 Mozilla 型浏览器的 Cookies 格式。&lt;/p&gt;
&lt;p&gt;在运行完成之后，我们可以在当前程序的目录下看到生成了一个 &lt;code&gt;cookies.txt&lt;/code&gt; 的文件，具体内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Netscape HTTP Cookie File
# http://curl.haxx.se/rfc/cookie_spec.html
# This is a generated file!  Do not edit.

.baidu.com  TRUE    /   FALSE   1606703804  BAIDUID 0A7A76A3705A730B35A559B601425953:FG=1
.baidu.com  TRUE    /   FALSE   3722651451  BIDUPSID    0A7A76A3705A730BE64A1F6D826869B5
.baidu.com  TRUE    /   FALSE       H_PS_PSSID  1461_21102_30211_30125_26350_30239
.baidu.com  TRUE    /   FALSE   3722651451  PSTM    1575167805
.baidu.com  TRUE    /   FALSE       delPer  0
www.baidu.com   FALSE   /   FALSE       BDSVRTM 0
www.baidu.com   FALSE   /   FALSE       BD_HOME 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小编比较懒，就不截图了，直接贴结果了。&lt;/p&gt;
&lt;p&gt;当然我们除了可以将 cookies 保存成为 Mozilla 型浏览器的格式，还可以将 cookies 保存成为 libwww-perl(LWP) 格式的 Cookies 文件。&lt;/p&gt;
&lt;p&gt;要保存成LWP格式的Cookies文件，在声明的时候需要修改为 LWPCookieJar：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cookies 保存 LWP 型文件示例
filename = 'cookies_lwp.txt'
cookie = http.cookiejar.LWPCookieJar(filename)
handler = urllib.request.HTTPCookieProcessor(cookie)
opener = urllib.request.build_opener(handler)
response = opener.open('http://www.baidu.com')
cookie.save(ignore_discard=True, ignore_expires=True)
print('cookies_lwp 保存成功')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#LWP-Cookies-2.0
Set-Cookie3: BAIDUID=&quot;D634D45523004545C6E23691E7CE3894:FG=1&quot;; path=&quot;/&quot;; domain=&quot;.baidu.com&quot;; path_spec; domain_dot; expires=&quot;2020-11-30 02:45:24Z&quot;; comment=bd; version=0
Set-Cookie3: BIDUPSID=D634D455230045458E6056651566B7E3; path=&quot;/&quot;; domain=&quot;.baidu.com&quot;; path_spec; domain_dot; expires=&quot;2087-12-19 05:59:31Z&quot;; version=0
Set-Cookie3: H_PS_PSSID=1427_21095_30210_18560_30125; path=&quot;/&quot;; domain=&quot;.baidu.com&quot;; path_spec; domain_dot; discard; version=0
Set-Cookie3: PSTM=1575168325; path=&quot;/&quot;; domain=&quot;.baidu.com&quot;; path_spec; domain_dot; expires=&quot;2087-12-19 05:59:31Z&quot;; version=0
Set-Cookie3: delPer=0; path=&quot;/&quot;; domain=&quot;.baidu.com&quot;; path_spec; domain_dot; discard; version=0
Set-Cookie3: BDSVRTM=0; path=&quot;/&quot;; domain=&quot;www.baidu.com&quot;; path_spec; discard; version=0
Set-Cookie3: BD_HOME=0; path=&quot;/&quot;; domain=&quot;www.baidu.com&quot;; path_spec; discard; version=0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，两种类型产生的 cookie 文件格式差异还是非常大的。&lt;/p&gt;
&lt;p&gt;已经生成了 cookie 文件，下一步我们就是要在请求的时候添加 cookie ，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 请求是使用 Mozilla 型文件
cookie = http.cookiejar.MozillaCookieJar()
cookie.load('cookies_mozilla.txt', ignore_discard=True, ignore_expires=True)
handler = urllib.request.HTTPCookieProcessor(cookie)
opener = urllib.request.build_opener(handler)
response = opener.open('http://www.baidu.com')
print(response.read().decode('utf-8'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们使用 load() 方法来读取本地的Cookies文件，获取到了 Cookies 的内容。&lt;/p&gt;
&lt;p&gt;前提是，我们需要提前生成了 Mozilla 格式的 cookie 文件，然后读取 Cookies 之后使用同样的方法构建 Handler 和 Opener 即可。&lt;/p&gt;
&lt;p&gt;请求正常的时候可以相应摆渡首页的源码，结果小编也就不贴了，属实有点长。&lt;/p&gt;
&lt;p&gt;本篇的内容就到这里了，希望各位同学记得自己动手写代码哦~~~&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;本系列的所有代码小编都会放在代码管理仓库 Github 和 Gitee 上，方便大家取用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/python-learning/tree/master/python-spider/urllib-request&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/python-learning/tree/master/python-spider/urllib-request&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangxinqi/p/9170312.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zhangxinqi/p/9170312.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cuiqingcai.com/5500.html&quot; class=&quot;uri&quot;&gt;https://cuiqingcai.com/5500.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Dec 2019 00:45:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我用 Python 前文传送门： '小白学 Python 爬虫（1）：开篇' '小白学 Python 爬虫（2）：前置准备（一）基本类库的安装' '小白学 Python 爬虫（3）：前置准备</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11993172.html</dc:identifier>
</item>
<item>
<title>WebGPU学习（二）: 学习“绘制一个三角形”示例 - Wonder-YYC</title>
<link>http://www.cnblogs.com/chaogex/p/11993144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaogex/p/11993144.html</guid>
<description>&lt;p&gt;大家好，本文学习Chrome-&amp;gt;webgl-samplers-&amp;gt;helloTriangle示例。&lt;/p&gt;
&lt;p&gt;上一篇文章：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/95461662&quot;&gt;WebGPU学习（一）: 开篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;克隆&lt;a href=&quot;https://github.com/austinEng/webgpu-samples&quot;&gt;webgl-samplers Github Repo&lt;/a&gt;到本地。&lt;br/&gt;（备注：当前的version为0.0.2）&lt;/p&gt;
&lt;p&gt;实际的sample代码在src/examples/文件夹中，是typescript代码写的：&lt;br/&gt;&lt;img src=&quot;http://static.zybuluo.com/yangyc/78dc1oxrsvstvcaa36pmgv3c/%E6%88%AA%E5%B1%8F2019-12-04%E4%B8%8B%E5%8D%883.53.16.png&quot; alt=&quot;截屏2019-12-04下午3.53.16.png-64.7kB&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打开helloTriangle.ts文件，我们来看下init函数的内容。&lt;/p&gt;
&lt;h2 id=&quot;首先是shader代码&quot;&gt;首先是shader代码&lt;/h2&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;    const vertexShaderGLSL = `#version 450
      const vec2 pos[3] = vec2[3](vec2(0.0f, 0.5f), vec2(-0.5f, -0.5f), vec2(0.5f, -0.5f));

      void main() {
          gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);
      }
    `;

    const fragmentShaderGLSL = `#version 450
      layout(location = 0) out vec4 outColor;

      void main() {
          outColor = vec4(1.0, 0.0, 0.0, 1.0);
      }
    `;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是vertex shader和fragment shader的glsl代码。&lt;/p&gt;
&lt;p&gt;（webgpu支持vertex shader、fragment shader、compute shader，这里只使用了前面两个）&lt;/p&gt;
&lt;p&gt;“#version 450”声明了glsl版本为4.5（它要放在glsl的第一行）&lt;/p&gt;
&lt;p&gt;第2行定义了三角形的三个顶点坐标，使用2维数组保存（每个元素为vec2类型）。因为都在一个平面，所以顶点只定义了x、y坐标（顶点的z为0.0）&lt;/p&gt;
&lt;p&gt;第5行的gl_VertexIndex为顶点序号，每次执行时值依次为0、1、2（vertex shader被执行了3次，因为只有3个顶点）（具体见本文末尾对draw的分析）&lt;/p&gt;
&lt;p&gt;第9行是fragment shader，因为三角形为一个颜色，所以所有片段的颜色为同一个固定值&lt;/p&gt;
&lt;h2 id=&quot;然后我们继续看下面的代码&quot;&gt;然后我们继续看下面的代码&lt;/h2&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;    const adapter = await navigator.gpu.requestAdapter();
    const device = await adapter.requestDevice();
    // 准备编译glsl的库
    const glslang = await glslangModule();
    // 获得webgpu上下文
    const context = canvas.getContext('gpupresent');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第4行的glslangModule是import的第三方库：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;import glslangModule from '../glslang';&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;继续往下看&quot;&gt;继续往下看&lt;/h2&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;    // 定义swapbuffer的格式为RGBA8位的无符号归一化格式
    const swapChainFormat = &quot;bgra8unorm&quot;;

    // @ts-ignore:
    const swapChain: GPUSwapChain = context.configureSwapChain({
      device,
      format: swapChainFormat,
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@ts-ignore是typescript用来忽略错误的。因为context的类型是RenderingContext，它没有定义configureSwapChain函数，如果编译该行typescript会报错，所以需要忽略错误。&lt;/p&gt;
&lt;p&gt;第5行配置了swap chain。&lt;a href=&quot;https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Swap_chain&quot;&gt;vulkan tutorial&lt;/a&gt;对此进行了说明：&lt;br/&gt;swap chain是一个缓冲结构，webgpu会先将内容渲染到swap chain的buffer中，然后再将其显示到屏幕上；&lt;br/&gt;swap chain本质上是等待呈现在屏幕上的一个图片队列。&lt;/p&gt;
&lt;h2 id=&quot;接下来就是创建render-pipeline&quot;&gt;接下来就是创建render pipeline&lt;/h2&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;    const pipeline = device.createRenderPipeline({
      layout: device.createPipelineLayout({ bindGroupLayouts: [] }),

      vertexStage: {
        module: device.createShaderModule({
          code: glslang.compileGLSL(vertexShaderGLSL, &quot;vertex&quot;),

          // @ts-ignore
          source: vertexShaderGLSL,
          transform: source =&amp;gt; glslang.compileGLSL(source, &quot;vertex&quot;),
        }),
        entryPoint: &quot;main&quot;
      },
      fragmentStage: {
        module: device.createShaderModule({
          code: glslang.compileGLSL(fragmentShaderGLSL, &quot;fragment&quot;),

          // @ts-ignore
          source: fragmentShaderGLSL,
          transform: source =&amp;gt; glslang.compileGLSL(source, &quot;fragment&quot;),
        }),
        entryPoint: &quot;main&quot;
      },

      primitiveTopology: &quot;triangle-list&quot;,

      colorStates: [{
        format: swapChainFormat,
      }],
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;了解pipeline&quot;&gt;了解pipeline&lt;/h3&gt;
&lt;p&gt;WebGPU有两种pipeline:render pipeline和compute pipeline，这里只用了render pipeline&lt;/p&gt;
&lt;p&gt;这里使用render pipeline descriptor来创建render pipeline，它的定义如下：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;dictionary GPUPipelineDescriptorBase : GPUObjectDescriptorBase {
    required GPUPipelineLayout layout;
};

...

dictionary GPURenderPipelineDescriptor : GPUPipelineDescriptorBase {
    required GPUProgrammableStageDescriptor vertexStage;
    GPUProgrammableStageDescriptor fragmentStage;

    required GPUPrimitiveTopology primitiveTopology;
    GPURasterizationStateDescriptor rasterizationState = {};
    required sequence&amp;lt;GPUColorStateDescriptor&amp;gt; colorStates;
    GPUDepthStencilStateDescriptor depthStencilState;
    GPUVertexStateDescriptor vertexState = {};

    unsigned long sampleCount = 1;
    unsigned long sampleMask = 0xFFFFFFFF;
    boolean alphaToCoverageEnabled = false;
    // TODO: other properties
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;render pipeline可以设置绑定的资源布局、编译的shader、fixed functions（如混合、深度、模版、cullMode等各种状态和顶点数据的格式vertexState），相对于WebGL（WebGL的一个API只能设置一个，如使用gl.cullFace设置cull mode），提升了性能（静态设置了各种状态，不需要在运行时设置），便于管理（把各个状态集中到了一起设置）。&lt;/p&gt;
&lt;h3 id=&quot;分析render-pipeline-descriptor&quot;&gt;分析render pipeline descriptor&lt;/h3&gt;
&lt;p&gt;vertexStage和fragmentStage分别设置vertex shader和fragment shader：&lt;br/&gt;使用第三方库，将glsl编译为字节码（格式为SPIR-V）；&lt;br/&gt;source和transform字段是多余的，可以删除。&lt;/p&gt;
&lt;p&gt;因为shader没有绑定资源（如uniform buffer, texture等），所以第2行的bindGroupLayouts为空数组，不需要bind group和bind group layout&lt;/p&gt;
&lt;p&gt;第25行的primitiveTopology指定片元的拓扑结构，此处为三角形。&lt;br/&gt;它可以为以下值：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;enum GPUPrimitiveTopology {
    &quot;point-list&quot;,
    &quot;line-list&quot;,
    &quot;line-strip&quot;,
    &quot;triangle-list&quot;,
    &quot;triangle-strip&quot;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在先忽略colorStates&lt;/p&gt;
&lt;h2 id=&quot;我们继续分析后面的代码接下来定义了frame函数&quot;&gt;我们继续分析后面的代码，接下来定义了frame函数&lt;/h2&gt;
&lt;p&gt;frame函数定义了每帧执行的逻辑：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;    function frame() {
      const commandEncoder = device.createCommandEncoder({});
      const textureView = swapChain.getCurrentTexture().createView();

      const renderPassDescriptor: GPURenderPassDescriptor = {
        colorAttachments: [{
          attachment: textureView,
          loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
        }],
      };

      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setPipeline(pipeline);
      passEncoder.draw(3, 1, 0, 0);
      passEncoder.endPass();

      device.defaultQueue.submit([commandEncoder.finish()]);
    }

    return frame;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;学习command-buffer&quot;&gt;学习command buffer&lt;/h3&gt;
&lt;p&gt;我们不能直接操作command buffer，需要创建command encoder，使用它将多个commands（如render pass的draw）设置到一个command buffer中，然后执行submit，把command buffer提交到gpu driver的队列中。&lt;/p&gt;
&lt;p&gt;根据 webgpu设计文档-&amp;gt;&lt;a href=&quot;https://github.com/gpuweb/gpuweb/blob/master/design/CommandSubmission.md&quot;&gt;Command Submission&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Command buffers carry sequences of user commands on the CPU side. They can be recorded independently of the work done on GPU, or each other. They go through the following stages:&lt;br/&gt;creation -&amp;gt; &quot;recording&quot; -&amp;gt; &quot;ready&quot; -&amp;gt; &quot;executing&quot; -&amp;gt; done&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道，command buffer有&lt;br/&gt;creation, recording,ready,executing,done五种状态。&lt;/p&gt;
&lt;p&gt;根据该文档，结合代码来分析command buffer的操作流程：&lt;br/&gt;第2行创建command encoder时，应该是创建了command buffer，它的状态为creation；&lt;br/&gt;第12行开始render pass（webgpu还支持compute pass，不过这里没用到），command buffer的状态变为recording；&lt;br/&gt;13-14行将“设置pipeline”、“绘制”的commands设置到command buffer中；&lt;br/&gt;第15行结束render pass，(可以设置下一个pass，如compute pass，不过这里只用了一个pass）；&lt;br/&gt;第17行“commandEncoder.finish()”将command buffer的状态变为ready；&lt;br/&gt;然后执行subimit，command buffer状态变为executing，被提交到gpu driver的队列中，不能再在cpu端被操作；&lt;br/&gt;如果提交成功，gpu会决定在某个时间处理它。&lt;/p&gt;
&lt;h3 id=&quot;分析render-pass&quot;&gt;分析render pass&lt;/h3&gt;
&lt;p&gt;第5行的renderPassDescriptor描述了render pass，它的定义为：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;dictionary GPURenderPassDescriptor : GPUObjectDescriptorBase {
    required sequence&amp;lt;GPURenderPassColorAttachmentDescriptor&amp;gt; colorAttachments;
    GPURenderPassDepthStencilAttachmentDescriptor depthStencilAttachment;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只用到了colorAttachments。它类似于WebGL-&amp;gt;framebuffer的colorAttachments。这里只用到了一个color buffer attachment。&lt;/p&gt;
&lt;p&gt;我们来看下colorAttachment的定义：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;dictionary GPURenderPassColorAttachmentDescriptor {
    required GPUTextureView attachment;
    GPUTextureView resolveTarget;

    required (GPULoadOp or GPUColor) loadValue;
    GPUStoreOp storeOp = &quot;store&quot;;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里设置attachment，将其与swap chain关联：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;          attachment: textureView,&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们现在忽略resolveTarget。&lt;/p&gt;
&lt;p&gt;loadValue和storeOp决定渲染前和渲染后怎样处理attachment中的数据。&lt;br/&gt;我们看下它的类型：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;enum GPULoadOp {
    &quot;load&quot;
};
enum GPUStoreOp {
    &quot;store&quot;,
    &quot;clear&quot;
};

...
dictionary GPUColorDict {
    required double r;
    required double g;
    required double b;
    required double a;
};
typedef (sequence&amp;lt;double&amp;gt; or GPUColorDict) GPUColor;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;loadValue如果为GPULoadOp类型，则只有一个值：“load”，它的意思是渲染前保留attachment中的数据；&lt;br/&gt;如果为GPUColor类型（如这里的{ r: 0.0, g: 0.0, b: 0.0, a: 1.0 }），则不仅为&quot;load&quot;，而且设置了渲染前的初始值，类似于WebGL的clearColor。&lt;/p&gt;
&lt;p&gt;storeOp如果为“store”，意思是渲染后保存被渲染的内容到内存中，后面可以被读取；&lt;br/&gt;如果为“clear”，意思是渲染后清空内容。&lt;/p&gt;
&lt;p&gt;现在我们回头看下render pipeline中的colorStates：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;      colorStates: [{
        format: swapChainFormat,
      }],&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;colorStates与colorAttachments对应，也只有一个，它的format应该与swap chain的format相同&lt;/p&gt;
&lt;p&gt;我们继续看render pass代码:&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setPipeline(pipeline);
      passEncoder.draw(3, 1, 0, 0);
      passEncoder.endPass();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;draw的定义为：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;void draw(unsigned long vertexCount, unsigned long instanceCount,
              unsigned long firstVertex, unsigned long firstInstance);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三角形有3个顶点，这里只绘制1个实例，两者都从0开始（所以vertex shader中的gl_VertexIndex依次为0、1、2），所以第3行为“draw(3, 1, 0, 0)”&lt;/p&gt;
&lt;h2 id=&quot;最终渲染结果&quot;&gt;最终渲染结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/yangyc/27ponnq38o0e1fzifo3k75hd/%E6%88%AA%E5%B1%8F2019-12-04%E4%B8%8B%E5%8D%889.53.50.png&quot; alt=&quot;截屏2019-12-04下午9.53.50.png-8kB&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/austinEng/webgpu-samples&quot;&gt;webgl-samplers Github Repo&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://vulkan-tutorial.com/Introduction&quot;&gt;vulkan tutorial&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/gpuweb/gpuweb/blob/master/design/CommandSubmission.md&quot;&gt;webgpu设计文档-&amp;gt;Command Submission&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/caxieyou/article/details/94631287&quot;&gt;WebGPU-4&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Dec 2019 00:34:00 +0000</pubDate>
<dc:creator>Wonder-YYC</dc:creator>
<og:description>大家好，本文学习Chrome-&gt;webgl-samplers-&gt;helloTriangle示例。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chaogex/p/11993144.html</dc:identifier>
</item>
<item>
<title>Mybatis分页插件PageHelper的学习与使用 - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11974596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11974596.html</guid>
<description>&lt;p&gt;后端程序员都知道，在Web系统中，分页是一种常见的功能，我之前写的分页方法都比较麻烦，移植性也不高，这就很不乐观了。作为一个积极开朗的程序员，怎么能不去了解PageHelper分页插件呢？PageHelper是国内非常优秀的一款开源的mybatis分页插件，它支持基本主流与常用的数据库，一致支持mysql、oracle、mariaDB、DB2、SQLite、Hsqldb等。OK接下来就一起来了解了解PageHelper分页插件！&lt;br/&gt;@&lt;/p&gt;
&lt;h2 id=&quot;中文教程&quot;&gt;中文教程&lt;/h2&gt;
&lt;p&gt;首先，推荐两个PageHelper分页插件项目地址，这里面有中文教程：&lt;br/&gt;&lt;a href=&quot;https://github.com/pagehelper/Mybatis-PageHelper&quot;&gt;github 项目&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://git.oschina.net/free/Mybatis_PageHelper&quot;&gt;gitosc 项目&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;pagehelper使用&quot;&gt;PageHelper使用&lt;/h2&gt;
&lt;p&gt;至于怎么使用我想上面提供的两个项目讲的绝逼讲的比我清楚，下面直接进入PageHelper使用实战&lt;/p&gt;
&lt;p&gt;首先，集成引入分页插件有下面2种方式，一种是直接下jar包一种是mawen依赖，&lt;strong&gt;推荐使用 Maven 方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;方法一： 直接下载jar包&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://repo1.maven.org/maven2/com/github/pagehelper/pagehelper/&quot;&gt;jar包下载地址&lt;/a&gt;，由于使用了sql 解析工具，你还需要下载 &lt;a href=&quot;http://repo1.maven.org/maven2/com/github/jsqlparser/jsqlparser/0.9.5/&quot;&gt;jsqlparser.jar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;方法二： Maven添加依赖&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.github.pagehelper&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;pagehelper&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.1.2&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;导入maven依赖分页插件&quot;&gt;1.导入maven依赖分页插件&lt;/h4&gt;
&lt;p&gt;我这里就采用方法二maven依赖&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190917152517853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;各个情况下xml的配置&quot;&gt;2.各个情况下xml的配置&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;情况一&lt;/code&gt;：如果是&lt;strong&gt;mybatis单独使用PageHelper分页插件&lt;/strong&gt;的时候，就需要在xml配置中添加如下代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  &amp;lt;!--
plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下properties?, settings?,
 typeAliases?, typeHandlers?, objectFactory?,objectWrapperFactory?, plugins?, 
 environments?, databaseIdProvider?, mappers?
  --&amp;gt;
  &amp;lt;!-- com.github.pagehelper为PageHelper类所在包名 --&amp;gt;
    &amp;lt;plugins&amp;gt; 
    &amp;lt;!-- 使用下面的方式配置参数，推荐的两个项目中有所有的参数介绍 --&amp;gt;
        &amp;lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&amp;gt; 
            &amp;lt;property name=&quot;param1&quot; value=&quot;value1&quot;/&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;情况二&lt;/code&gt;：显然，我是这个是ssm项目，&lt;strong&gt;mybatis是交由spring的IOC容器管理&lt;/strong&gt;的，就需要在spring的xml配置中添加如下代码（创建工厂中添加）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  &amp;lt;!-- 把交给IOC管理 SqlSessionFactory --&amp;gt;
 &amp;lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&amp;gt;
     &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
     &amp;lt;!-- 传入PageHelper的插件 --&amp;gt;
     &amp;lt;property name=&quot;plugins&quot;&amp;gt;
         &amp;lt;array&amp;gt;
             &amp;lt;!-- 传入插件的对象 --&amp;gt;
             &amp;lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&amp;gt;
                 &amp;lt;property name=&quot;properties&quot;&amp;gt;
                     &amp;lt;props&amp;gt;
                         &amp;lt;prop key=&quot;helperDialect&quot;&amp;gt;oracle&amp;lt;/prop&amp;gt;
                         &amp;lt;prop key=&quot;reasonable&quot;&amp;gt;true&amp;lt;/prop&amp;gt;
                     &amp;lt;/props&amp;gt;
                 &amp;lt;/property&amp;gt;
             &amp;lt;/bean&amp;gt;
         &amp;lt;/array&amp;gt;
     &amp;lt;/property&amp;gt;
 &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面用一个图来分析一下两个参数作用：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190917154842364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;更多情况请参考上面推荐的项目~&lt;/p&gt;
&lt;h4 id=&quot;controller代码编写&quot;&gt;3.Controller代码编写&lt;/h4&gt;
&lt;p&gt;上面我们配置完了，至于为什么从controller代码开始是因为controller调用service嘛，这样编写代码更方便快捷！为了看出差别，未分页的controller代码方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
@RequestMapping(&quot;/orders&quot;)
public class OrdersController {

    @Autowired
    private IOrdersService ordersService;

//查询所有orders未分页
   @RequestMapping(&quot;/findAll.do&quot;)
    public ModelAndView findAll() {
        ModelAndView mv = new ModelAndView();
        List&amp;lt;Orders&amp;gt; ordersList = ordersService.findAll();
        mv.addObject(&quot;ordersList&quot;, ordersList);
        mv.setViewName(&quot;orders-list&quot;);
        return mv;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而采用了分页代码则是如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//采用分页代码方法
   @RequestMapping(&quot;/findAll.do&quot;)
    public ModelAndView findAll(@RequestParam(name=&quot;page&quot;,required = true,defaultValue = &quot;1&quot;)int page,@RequestParam(name=&quot;size&quot;,required = true,defaultValue = &quot;4&quot;)int size ) {
        ModelAndView mv = new ModelAndView();
        List&amp;lt;Orders&amp;gt; ordersList = ordersService.findAll(page,size);

        //PageInfo就是一个分页Bean
        PageInfo pageInfo =new PageInfo(ordersList);
        mv.addObject(&quot;pageInfo&quot;, pageInfo);
        mv.setViewName(&quot;orders-list&quot;);
        return mv;

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现多了两个参数分别是&lt;code&gt;page&lt;/code&gt;和&lt;code&gt;size&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;service接口代码编写&quot;&gt;4.Service接口代码编写&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface IOrdersService {
    List&amp;lt;Orders&amp;gt; findAll(int page,int size);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;service实现类代码编写&quot;&gt;5.Service实现类代码编写&lt;/h4&gt;
&lt;p&gt;在执行sql之前（ServiceImpl），使用PageHelper分页，参数&lt;code&gt;pageNum&lt;/code&gt; 是页码值 参数&lt;code&gt;pageSize&lt;/code&gt; 代表是每页显示条数。在ServiceImpl中,使用PageHelper分页操作代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class OrdersServiceImpl implements IOrdersService {
    @Autowired
    private IOrdersDao ordersDao;

    @Override
    public List&amp;lt;Orders&amp;gt; findAll(int page,int size) {
        //参数pageNum 是页码值   参数pageSize 代表是每页显示条数
        PageHelper.startPage(page, size);
        return ordersDao.findAll();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特别注意：在编写PageHelper分页代码时的 &lt;code&gt;PageHelper.startPage(page, size)&lt;/code&gt;这一句必须写在查询方法的上一句，中间不能添加任何代码，否则失效！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190917170222963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;jsp页面未处理代码&quot;&gt;6.jsp页面未处理代码&lt;/h4&gt;
&lt;p&gt;没有更改的jsp页面代码,普通查询关键更改代码块，注意这里接收数据为 &lt;code&gt;ordersList&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;c:forEach items=&quot;${ordersList}&quot; var=&quot;orders&quot;&amp;gt;
   &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;&amp;lt;input name=&quot;ids&quot; type=&quot;checkbox&quot;&amp;gt;&amp;lt;/td&amp;gt;
        ...
        &amp;lt;td&amp;gt;...&amp;lt;/td&amp;gt;
        &amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/c:forEach&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这下面的代码则是未分页逻辑代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; &amp;lt;div class=&quot;box-tools pull-right&quot;&amp;gt;
                        &amp;lt;ul class=&quot;pagination&quot;&amp;gt;
                            &amp;lt;li&amp;gt;
                                &amp;lt;a href=&quot;#&quot; aria-label=&quot;Previous&quot;&amp;gt;首页&amp;lt;/a&amp;gt;
                            &amp;lt;/li&amp;gt;
                            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;上一页&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;1&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;2&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;3&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;4&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;5&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;下一页&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                            &amp;lt;li&amp;gt;
                                &amp;lt;a href=&quot;#&quot; aria-label=&quot;Next&quot;&amp;gt;尾页&amp;lt;/a&amp;gt;
                            &amp;lt;/li&amp;gt;
                        &amp;lt;/ul&amp;gt;
                    &amp;lt;/div&amp;gt;

                &amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;jsp页面处理后代码&quot;&gt;7.jsp页面处理后代码&lt;/h4&gt;
&lt;p&gt;更改后的jsp页面代码,分页查询的关键更改代码块，注意这里接收数据为 &lt;code&gt;ordersList.list&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;c:forEach items=&quot;${ordersList.list}&quot; var=&quot;orders&quot;&amp;gt;
   &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;&amp;lt;input name=&quot;ids&quot; type=&quot;checkbox&quot;&amp;gt;&amp;lt;/td&amp;gt;
        ...
        &amp;lt;td&amp;gt;...&amp;lt;/td&amp;gt;
        &amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/c:forEach&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这下面的代码则是分页逻辑代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;div class=&quot;box-tools pull-right&quot;&amp;gt;
   &amp;lt;ul class=&quot;pagination&quot;&amp;gt;
        &amp;lt;li&amp;gt;
            &amp;lt;a href=&quot;${pageContext.request.contextPath}/orders/findAll.do?page=1&amp;amp;size=${pageInfo.pageSize}&quot; aria-label=&quot;Previous&quot;&amp;gt;首页&amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&quot;${pageContext.request.contextPath}/orders/findAll.do?page=${pageInfo.pageNum-1}&amp;amp;size=${pageInfo.pageSize}&quot;&amp;gt;上一页&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;c:forEach begin=&quot;1&quot; end=&quot;${pageInfo.pages}&quot; var=&quot;pageNum&quot;&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&quot;${pageContext.request.contextPath}/orders/findAll.do?page=${pageNum}&amp;amp;size=${pageInfo.pageSize}&quot;&amp;gt;${pageNum}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/c:forEach&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&quot;${pageContext.request.contextPath}/orders/findAll.do?page=${pageInfo.pageNum+1}&amp;amp;size=${pageInfo.pageSize}&quot;&amp;gt;下一页&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;
            &amp;lt;a href=&quot;${pageContext.request.contextPath}/orders/findAll.do?page=${pageInfo.pages}&amp;amp;size=${pageInfo.pageSize}&quot; aria-label=&quot;Next&quot;&amp;gt;尾页&amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;jsp页面处理前后代码分析&quot;&gt;8.jsp页面处理前后代码分析&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190917190422658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019091719102915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //PageInfo就是一个分页Bean
   PageInfo pageInfo =new PageInfo(ordersList);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了能看到上面的pageInfo源代码，我就把代码贴在下面了&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.github.pagehelper;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;

public class PageInfo&amp;lt;T&amp;gt; implements Serializable {
    private static final long serialVersionUID = 1L;
    private int pageNum;
    private int pageSize;
    private int size;
    private int startRow;
    private int endRow;
    private long total;
    private int pages;
    private List&amp;lt;T&amp;gt; list;
    private int prePage;
    private int nextPage;
    private boolean isFirstPage;
    private boolean isLastPage;
    private boolean hasPreviousPage;
    private boolean hasNextPage;
    private int navigatePages;
    private int[] navigatepageNums;
    private int navigateFirstPage;
    private int navigateLastPage;

    public PageInfo() {
        this.isFirstPage = false;
        this.isLastPage = false;
        this.hasPreviousPage = false;
        this.hasNextPage = false;
    }

    public PageInfo(List&amp;lt;T&amp;gt; list) {
        this(list, 8);
    }

    public PageInfo(List&amp;lt;T&amp;gt; list, int navigatePages) {
        this.isFirstPage = false;
        this.isLastPage = false;
        this.hasPreviousPage = false;
        this.hasNextPage = false;
        if (list instanceof Page) {
            Page page = (Page)list;
            this.pageNum = page.getPageNum();
            this.pageSize = page.getPageSize();
            this.pages = page.getPages();
            this.list = page;
            this.size = page.size();
            this.total = page.getTotal();
            if (this.size == 0) {
                this.startRow = 0;
                this.endRow = 0;
            } else {
                this.startRow = page.getStartRow() + 1;
                this.endRow = this.startRow - 1 + this.size;
            }
        } else if (list instanceof Collection) {
            this.pageNum = 1;
            this.pageSize = list.size();
            this.pages = this.pageSize &amp;gt; 0 ? 1 : 0;
            this.list = list;
            this.size = list.size();
            this.total = (long)list.size();
            this.startRow = 0;
            this.endRow = list.size() &amp;gt; 0 ? list.size() - 1 : 0;
        }

        if (list instanceof Collection) {
            this.navigatePages = navigatePages;
            this.calcNavigatepageNums();
            this.calcPage();
            this.judgePageBoudary();
        }

    }

    private void calcNavigatepageNums() {
        int i;
        if (this.pages &amp;lt;= this.navigatePages) {
            this.navigatepageNums = new int[this.pages];

            for(i = 0; i &amp;lt; this.pages; ++i) {
                this.navigatepageNums[i] = i + 1;
            }
        } else {
            this.navigatepageNums = new int[this.navigatePages];
            i = this.pageNum - this.navigatePages / 2;
            int endNum = this.pageNum + this.navigatePages / 2;
            int i;
            if (i &amp;lt; 1) {
                i = 1;

                for(i = 0; i &amp;lt; this.navigatePages; ++i) {
                    this.navigatepageNums[i] = i++;
                }
            } else if (endNum &amp;gt; this.pages) {
                endNum = this.pages;

                for(i = this.navigatePages - 1; i &amp;gt;= 0; --i) {
                    this.navigatepageNums[i] = endNum--;
                }
            } else {
                for(i = 0; i &amp;lt; this.navigatePages; ++i) {
                    this.navigatepageNums[i] = i++;
                }
            }
        }

    }

    private void calcPage() {
        if (this.navigatepageNums != null &amp;amp;&amp;amp; this.navigatepageNums.length &amp;gt; 0) {
            this.navigateFirstPage = this.navigatepageNums[0];
            this.navigateLastPage = this.navigatepageNums[this.navigatepageNums.length - 1];
            if (this.pageNum &amp;gt; 1) {
                this.prePage = this.pageNum - 1;
            }

            if (this.pageNum &amp;lt; this.pages) {
                this.nextPage = this.pageNum + 1;
            }
        }

    }

    private void judgePageBoudary() {
        this.isFirstPage = this.pageNum == 1;
        this.isLastPage = this.pageNum == this.pages || this.pages == 0;
        this.hasPreviousPage = this.pageNum &amp;gt; 1;
        this.hasNextPage = this.pageNum &amp;lt; this.pages;
    }

    public int getPageNum() {
        return this.pageNum;
    }

    public void setPageNum(int pageNum) {
        this.pageNum = pageNum;
    }

    public int getPageSize() {
        return this.pageSize;
    }

    public void setPageSize(int pageSize) {
        this.pageSize = pageSize;
    }

    public int getSize() {
        return this.size;
    }

    public void setSize(int size) {
        this.size = size;
    }

    public int getStartRow() {
        return this.startRow;
    }

    public void setStartRow(int startRow) {
        this.startRow = startRow;
    }

    public int getEndRow() {
        return this.endRow;
    }

    public void setEndRow(int endRow) {
        this.endRow = endRow;
    }

    public long getTotal() {
        return this.total;
    }

    public void setTotal(long total) {
        this.total = total;
    }

    public int getPages() {
        return this.pages;
    }

    public void setPages(int pages) {
        this.pages = pages;
    }

    public List&amp;lt;T&amp;gt; getList() {
        return this.list;
    }

    public void setList(List&amp;lt;T&amp;gt; list) {
        this.list = list;
    }

    /** @deprecated */
    @Deprecated
    public int getFirstPage() {
        return this.navigateFirstPage;
    }

    /** @deprecated */
    @Deprecated
    public void setFirstPage(int firstPage) {
        this.navigateFirstPage = firstPage;
    }

    public int getPrePage() {
        return this.prePage;
    }

    public void setPrePage(int prePage) {
        this.prePage = prePage;
    }

    public int getNextPage() {
        return this.nextPage;
    }

    public void setNextPage(int nextPage) {
        this.nextPage = nextPage;
    }

    /** @deprecated */
    @Deprecated
    public int getLastPage() {
        return this.navigateLastPage;
    }

    /** @deprecated */
    @Deprecated
    public void setLastPage(int lastPage) {
        this.navigateLastPage = lastPage;
    }

    public boolean isIsFirstPage() {
        return this.isFirstPage;
    }

    public void setIsFirstPage(boolean isFirstPage) {
        this.isFirstPage = isFirstPage;
    }

    public boolean isIsLastPage() {
        return this.isLastPage;
    }

    public void setIsLastPage(boolean isLastPage) {
        this.isLastPage = isLastPage;
    }

    public boolean isHasPreviousPage() {
        return this.hasPreviousPage;
    }

    public void setHasPreviousPage(boolean hasPreviousPage) {
        this.hasPreviousPage = hasPreviousPage;
    }

    public boolean isHasNextPage() {
        return this.hasNextPage;
    }

    public void setHasNextPage(boolean hasNextPage) {
        this.hasNextPage = hasNextPage;
    }

    public int getNavigatePages() {
        return this.navigatePages;
    }

    public void setNavigatePages(int navigatePages) {
        this.navigatePages = navigatePages;
    }

    public int[] getNavigatepageNums() {
        return this.navigatepageNums;
    }

    public void setNavigatepageNums(int[] navigatepageNums) {
        this.navigatepageNums = navigatepageNums;
    }

    public int getNavigateFirstPage() {
        return this.navigateFirstPage;
    }

    public int getNavigateLastPage() {
        return this.navigateLastPage;
    }

    public void setNavigateFirstPage(int navigateFirstPage) {
        this.navigateFirstPage = navigateFirstPage;
    }

    public void setNavigateLastPage(int navigateLastPage) {
        this.navigateLastPage = navigateLastPage;
    }

    public String toString() {
        StringBuffer sb = new StringBuffer(&quot;PageInfo{&quot;);
        sb.append(&quot;pageNum=&quot;).append(this.pageNum);
        sb.append(&quot;, pageSize=&quot;).append(this.pageSize);
        sb.append(&quot;, size=&quot;).append(this.size);
        sb.append(&quot;, startRow=&quot;).append(this.startRow);
        sb.append(&quot;, endRow=&quot;).append(this.endRow);
        sb.append(&quot;, total=&quot;).append(this.total);
        sb.append(&quot;, pages=&quot;).append(this.pages);
        sb.append(&quot;, list=&quot;).append(this.list);
        sb.append(&quot;, prePage=&quot;).append(this.prePage);
        sb.append(&quot;, nextPage=&quot;).append(this.nextPage);
        sb.append(&quot;, isFirstPage=&quot;).append(this.isFirstPage);
        sb.append(&quot;, isLastPage=&quot;).append(this.isLastPage);
        sb.append(&quot;, hasPreviousPage=&quot;).append(this.hasPreviousPage);
        sb.append(&quot;, hasNextPage=&quot;).append(this.hasNextPage);
        sb.append(&quot;, navigatePages=&quot;).append(this.navigatePages);
        sb.append(&quot;, navigateFirstPage=&quot;).append(this.navigateFirstPage);
        sb.append(&quot;, navigateLastPage=&quot;).append(this.navigateLastPage);
        sb.append(&quot;, navigatepageNums=&quot;);
        if (this.navigatepageNums == null) {
            sb.append(&quot;null&quot;);
        } else {
            sb.append('[');

            for(int i = 0; i &amp;lt; this.navigatepageNums.length; ++i) {
                sb.append(i == 0 ? &quot;&quot; : &quot;, &quot;).append(this.navigatepageNums[i]);
            }

            sb.append(']');
        }

        sb.append('}');
        return sb.toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，基本就OK了，我再次强调我推荐的那两个项目，那里面讲的很详细大佬写的，强调完毕，挥爪~&lt;/p&gt;
</description>
<pubDate>Fri, 06 Dec 2019 00:05:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>后端程序员都知道，在Web系统中，分页是一种常见的功能，我之前写的分页方法都比较麻烦，移植性也不高，这就很不乐观了。作为一个积极开朗的程序员，怎么能不去了解PageHelper分页插件呢？PageHe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11974596.html</dc:identifier>
</item>
<item>
<title>Spring 框架基础(06)：Mvc架构模式简介，执行流程详解 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/11993119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/11993119.html</guid>
<description>&lt;p&gt;本文源码：&lt;a href=&quot;https://github.com/cicadasmile/spring-mvc-parent&quot;&gt;GitHub·点这里&lt;/a&gt; || &lt;a href=&quot;https://gitee.com/cicadasmile/spring-mvc-parent&quot;&gt;GitEE·点这里&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;mvc设计理念&quot;&gt;1、Mvc设计理念&lt;/h2&gt;
&lt;p&gt;MVC是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个组件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，MVC分层有助于管理和架构复杂的应用程序&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;M:代表模型&lt;code&gt;Model&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;模型就是数据，应用程序的核心。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;V:代表视图&lt;code&gt;View&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;回显数据的界面,例如JSP就是用来展示模型中的数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;C:代表控制器&lt;code&gt;Controller&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;控制器的作用就是根据入参，把不同的响应数据(&lt;code&gt;Model&lt;/code&gt;)，显示在不同的视图(&lt;code&gt;View&lt;/code&gt;)上。&lt;/p&gt;
&lt;h2 id=&quot;springmvc简介&quot;&gt;2、SpringMvc简介&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;框架描述&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;SpringMVC&lt;/code&gt;是一种基于&lt;code&gt;Java&lt;/code&gt;实现的&lt;code&gt;MVC&lt;/code&gt;设计模式的请求驱动类型的轻量级&lt;code&gt;Web&lt;/code&gt;框架，出自&lt;code&gt;Spring&lt;/code&gt;框架全家桶，与&lt;code&gt;Spring&lt;/code&gt;框架无缝整合，使用了&lt;code&gt;MVC&lt;/code&gt;架构模式的思想，将&lt;code&gt;Web&lt;/code&gt;层进行职责解耦。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;框架优点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;结构松散，几乎可以在&lt;code&gt;SpringMVC&lt;/code&gt;中使用各类视图，各个模块分离而且耦合度非常低，且易于扩展。与&lt;code&gt;Spring&lt;/code&gt;无缝集成，且简单，灵活，容易上手。&lt;/p&gt;

&lt;h2 id=&quot;流程图解&quot;&gt;1、流程图解&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201912/1691717-20191206075323347-1687024519.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;步骤描述&quot;&gt;2、步骤描述&lt;/h2&gt;
&lt;p&gt;(1)、发起请求到前端控制器&lt;code&gt;DispatcherServlet&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;(2)、前端控制器请求&lt;code&gt;HandlerMapping&lt;/code&gt;查找,&lt;code&gt;Handler&lt;/code&gt;可以根据&lt;code&gt;xml&lt;/code&gt;配置、注解进行查找;&lt;/p&gt;
&lt;p&gt;(3)、处理器映射器&lt;code&gt;HandlerMapping&lt;/code&gt;向前端控制器返回&lt;code&gt;Handler&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;(4)、前端控制器调用处理器适配器去执行&lt;code&gt;Handler&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;(5)、处理器适配器去执行&lt;code&gt;Handler&lt;/code&gt; ;&lt;/p&gt;
&lt;p&gt;(6)、&lt;code&gt;Handler&lt;/code&gt;执行完成给适配器返回&lt;code&gt;ModelAndView&lt;/code&gt; ;&lt;/p&gt;
&lt;p&gt;(7)、处理器适配器向前端控制器返回&lt;code&gt;ModelAndView&lt;/code&gt;,&lt;code&gt;ModelAndView&lt;/code&gt;是&lt;code&gt;springmvc&lt;/code&gt;框架的一个底层对象,包括&lt;code&gt;Model&lt;/code&gt;和&lt;code&gt;view&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;(8)、前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图 ;&lt;/p&gt;
&lt;p&gt;(9)、视图解析器向前端控制器返回&lt;code&gt;View&lt;/code&gt; ;&lt;/p&gt;
&lt;p&gt;(10)、前端控制器进行视图渲染,视图渲染将模型数据(在&lt;code&gt;ModelAndView&lt;/code&gt;对象中)填充到&lt;code&gt;request&lt;/code&gt;域中;&lt;/p&gt;
&lt;p&gt;(11)、前端控制器向用户响应结果 ;&lt;/p&gt;
&lt;h2 id=&quot;核心组件&quot;&gt;3、核心组件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;前端控制器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;:请求离开浏览器后，最先到达的就是DispatcherServlet，是整个流程控制的中心，作用接收请求，响应结果，相当于转发器，中央处理器。减少各个组件之间的耦合度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;处理器映射器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;HandlerMapping&lt;/code&gt;:根据请求的url路由到指定接口，用户请求找到Handler处理器，springmvc提供不同类型映射器，例如：Xml配置方式，注解方式等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;处理器适配器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;HandlerAdapter&lt;/code&gt;:按照特定规则去执行Handler，SpringMvc支持多种处理器，各种处理器中的处理方法各不相同，为了解决适应多种处理器，就出现了处理器适配器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt;：处理用户请求，涉及具体业务逻辑，需要程序员根据业务需求开发。编写Handler时按照HandlerAdapter的规则开发，这样适配器才可以正确执行Handler。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;视图解析器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;ViewResolver&lt;/code&gt;：负责将请求的响应结果生成View，根据逻辑视图名解析成物理视图名，就是具体页面地址，生成View视图对象，对View进行渲染，通过页面展示给用户。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;View&lt;/code&gt;：SpringMvc框架提供很多的View视图类型的支持，包括：jsp、freemarker、pdf等。通过页面标签或页面模版解析模型数据回显到页面，需要根据业务开发具体页面。&lt;/p&gt;

&lt;h2 id=&quot;spring-mvc配置&quot;&gt;1、spring-mvc配置&lt;/h2&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- 扫描文件 --&amp;gt;
&amp;lt;context:component-scan base-package=&quot;com.spring.mvc.controller&quot; /&amp;gt;
&amp;lt;!-- MVC默认的注解映射的方式 --&amp;gt;
&amp;lt;mvc:annotation-driven /&amp;gt;
&amp;lt;mvc:default-servlet-handler/&amp;gt;
&amp;lt;!-- 视图解析器 --&amp;gt;
&amp;lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;
    &amp;lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot; /&amp;gt;
    &amp;lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;web.xml配置&quot;&gt;2、Web.xml配置&lt;/h2&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;spring-mvc&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;classpath:spring-mvc.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;spring-mvc&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试接口&quot;&gt;3、测试接口&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
public class HelloController {
    @RequestMapping(&quot;/getInfo&quot;)
    public @ResponseBody String getInfo (String name){
        return name ;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常用注解说明&quot;&gt;4、常用注解说明&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Controller&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;标记一个类是Handler，也就是开发的Controller，然后使用@RequestMapping或其他相关注解（@GetMapping、@PostMapping、@PutMapping、@DeleteMapping），用来关联请求和Controller方法之间的映射关系，这样的Controller 就可以被请求访问。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@RequestMapping&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;处理请求地址映射的注解，可作用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以类上标注地址作为父路径。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@requestParam&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主要用于在SpringMvc框架的控制层获取参数，三个常用参数：defaultValue表示设置默认值，required 通过boolean设置是否是必须要传入的参数，value值表示传入的参数名称。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@RequestBody&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接收请求体中传递给后端的Json字符串数据的，GET方式无请求体，所以使用@RequestBody接收数据时，不能使用GET方式提交数据，需要用POST方式进行提交。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@ResponseBody&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该注解用于方法的返回对象，可以通过配置转换器为指定数据响应格式，如果希望返回的数据不是View试图页面，而是指定数据格式的时候使用，例如：Json、Xml等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Autowired&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。&lt;/p&gt;
&lt;p&gt;按照ByName自动注入，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@PathVariable&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。&lt;/p&gt;

&lt;h2 id=&quot;普通映射&quot;&gt;1、普通映射&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/getSum&quot;)
public Integer getSum (int a,int b){
    return a+b ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://localhost:6003/getSum?a=1&amp;amp;b=2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;传参名称和方法参数保持一致。&lt;/p&gt;
&lt;h2 id=&quot;指定参数名&quot;&gt;2、指定参数名&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/getInfo&quot;)
public String getInfo (@RequestParam(&quot;name&quot;) String var1,
                       @RequestParam(&quot;say&quot;) String var2){
    return var1+&quot;:&quot;+var2 ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://localhost:6003/getInfo?name=cica&amp;amp;say=hello&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;传参名和 @RequestParam 指定的参数名要对应。&lt;/p&gt;
&lt;h2 id=&quot;数组参数&quot;&gt;3、数组参数&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(&quot;/getArray&quot;)
public String getArray (String[] ids){
    return ids[0]+&quot;-&quot;+ids[1] ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://localhost:6003/getArray?ids=2&amp;amp;ids=3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;传递并解析数组类型的参数格式。&lt;/p&gt;
&lt;h2 id=&quot;map参数&quot;&gt;4、Map参数&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/getMap&quot;)
public String getMap (@RequestParam Map&amp;lt;String,String&amp;gt; paramMap){
    return paramMap.get(&quot;name&quot;) ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://localhost:6003/getCityEntity?province=浙江&amp;amp;name=杭州&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里以Post方式将相关参数传递CityEntity实体对象中。&lt;/p&gt;
&lt;h2 id=&quot;包装参数&quot;&gt;5、包装参数&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(&quot;/getCityEntity&quot;)
public CityEntity getCityEntity (CityEntity cityEntity){
    return cityEntity ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://localhost:6003/getCityEntity?province=浙江&amp;amp;name=杭州&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里以Post方式将相关参数传递CityEntity实体对象中。&lt;/p&gt;
&lt;h2 id=&quot;rest风格参数&quot;&gt;6、Rest风格参数&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(&quot;/getId/{id}&quot;)
public String getId (@PathVariable(&quot;id&quot;) Integer id){
    return &quot;id=&quot;+id ;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;http://localhost:6003/getId/1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;RestFul 风格参数映射。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile/spring-mvc-parent
GitEE·地址
https://gitee.com/cicadasmile/spring-mvc-parent&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1691717/201908/1691717-20190823075428183-1996768914.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 06 Dec 2019 00:04:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>本文源码： 'GitHub·点这里' || 'GitEE·点这里' 一、SpringMvc框架简介 1、Mvc设计理念 MVC是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/11993119.html</dc:identifier>
</item>
<item>
<title>salesforce lightning零基础学习(十六) 公用组件之 获取字段label信息 - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/11992457.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/11992457.html</guid>
<description>&lt;p&gt;我们做的项目好多都是多语言的项目，针对不同国家需要展示不同的语言的标题。我们在classic中的VF page可谓是得心应手，因为系统中已经封装好了我们可以直接在VF获取label/api name等方法。但是我们在lightning aura中开发却发现这个常用的功能并没有包含，好吧，既然没有现成可用的那我们就要有workaround的方式去后台获取。此篇主要封装好组件去实现获取某个object或者某些object相关字段的label。&lt;/p&gt;
&lt;p&gt;那我们来开始进行这个组件的开发，开发以前我们需要先思考一下，组件化的东西，传参应该是什么，返回应该是什么，应该实现哪些功能解决哪些痛点。如何用到更好的优化。本人思考可能并不特别的完全，感兴趣的可以进行优化。&lt;/p&gt;
&lt;p&gt;1. object 的API name应该为必填项。 这里应该实现可以同时获取多个表的字段的label信息，我们画component时，很可能需要获取当前的对象，父对象以及相关的子对象的字段的label，所以此处传参应该能做到传递list而不是单一的object&lt;/p&gt;
&lt;p&gt;2. object对应的指定的field的api name列表，此项应该为可选项，非必填。我们都知道aura开发现在很慢，而且我们在前台获取label时，可能一个object有上百个字段，但是我们在页面只需要某几个字段的label的信息，如果全部查出来放在前台特别影响view state，所以我们此处应该支持可以通过指定的一些字段进行查询。因为object传参是list,所以此参数应该为Map&amp;lt;String,List&amp;lt;String&amp;gt;&amp;gt;方式。&lt;/p&gt;
&lt;p&gt;3. 返回类型应该为 Map&amp;lt;String,Map&amp;lt;String,String&amp;gt;&amp;gt;类型，外层的key是objectAPIName，内层的map的key是fieldAPIName,内层的map的value为我们需要的field label&lt;/p&gt;
&lt;p&gt;OK，上面的已经梳理出来，那干就完了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一. 公用组件搭建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FieldLabelServiceController.cls 用于后台搭建查询指定的obj / field的value -&amp;gt; label信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; with sharing &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FieldLabelServiceController {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    * @param objApiNameList : object API name list. eg:['Account','Contact']
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    * @param objApiName2FieldsMap: object API name 2 fields map. eg:{'Account':['Name','Type'],'Contact':['LastName','Phone']}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    * @return object API name 2 map of field API name -&amp;gt; label name. eg:{'Account':{'Type'：'类型'},'Contact':{'LastName':'姓'}}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @AuraEnabled
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String,Map&amp;lt;String,String&amp;gt;&amp;gt; getFieldLabelService(List&amp;lt;String&amp;gt; objApiNameList,Map&amp;lt;String,List&amp;lt;String&amp;gt;&amp;gt;&lt;span&gt; objApiName2FieldsMap) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key: object API name ; value : (Map: key:field API name, value: field label)&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         Map&amp;lt;String,Map&amp;lt;String,String&amp;gt;&amp;gt; object2FieldLabelMap = &lt;span&gt;new&lt;/span&gt; Map&amp;lt;String,Map&amp;lt;String,String&amp;gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;get all sobject sObjectType map&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         Map&amp;lt;String,sObjectType&amp;gt; objName2ObjTypeMap =&lt;span&gt; Schema.getGlobalDescribe();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String objApiName : objApiNameList) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. get specific object sObjectType&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             sObjectType objType =&lt;span&gt; objName2ObjTypeMap.get(objApiName);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. get all of the fields map via specific object&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             Map&amp;lt;String,Schema.SObjectField&amp;gt; fieldsMap =&lt;span&gt; objType.getDescribe().fields.getMap();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3. check if retrieve specific field list or all the fields mapping via object&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             Set&amp;lt;String&amp;gt; retrieveFieldList = &lt;span&gt;new&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(objApiName2FieldsMap != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; objApiName2FieldsMap.containsKey(objApiName)) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 retrieveFieldList = &lt;span&gt;new&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt;(objApiName2FieldsMap.get(objApiName));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;             Map&amp;lt;String,String&amp;gt; fieldApiName2FieldLabelMap = &lt;span&gt;new&lt;/span&gt; Map&amp;lt;String,String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4. get all / specific field api name -&amp;gt; label name mapping&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String fieldApiName : fieldsMap.keySet()){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(retrieveFieldList.size() &amp;gt; 0 &amp;amp;&amp;amp; !&lt;span&gt;retrieveFieldList.contains(fieldApiName)) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;                 String label =&lt;span&gt; fieldsMap.get(fieldApiName).getDescribe().getLabel();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 fieldApiName2FieldLabelMap.put(String.valueOf(fieldsMap.get(fieldApiName)), label == &lt;span&gt;null&lt;/span&gt; ?&lt;span&gt; fieldApiName : label);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            object2FieldLabelMap.put(objApiName, fieldApiName2FieldLabelMap);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; object2FieldLabelMap;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FieldLabelService.cmp:用于封装共用方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component &lt;/span&gt;&lt;span&gt;access&lt;/span&gt;&lt;span&gt;=&quot;global&quot;&lt;/span&gt;&lt;span&gt; description&lt;/span&gt;&lt;span&gt;=&quot;Field label service&quot;&lt;/span&gt;&lt;span&gt; controller&lt;/span&gt;&lt;span&gt;=&quot;FieldLabelServiceController&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:method &lt;/span&gt;&lt;span&gt;access&lt;/span&gt;&lt;span&gt;=&quot;global&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;getFieldLabel&quot;&lt;/span&gt;&lt;span&gt; action&lt;/span&gt;&lt;span&gt;=&quot;{!c.getFieldLabelAction}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;List&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;objectAPINameList&quot;&lt;/span&gt;&lt;span&gt; required&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; description&lt;/span&gt;&lt;span&gt;=&quot;object list to retrieve field label&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Map&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;objectFieldAPINameMap&quot;&lt;/span&gt;&lt;span&gt; description&lt;/span&gt;&lt;span&gt;=&quot;specific fields need to retrieve via object api name&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Function&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;callback&quot;&lt;/span&gt;&lt;span&gt; required&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:method&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FieldLabelServiceController.js：用于封装对应的controller js方法，调用后台获取结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;({
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     getFieldLabelAction : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         const params = event.getParam('arguments'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         const action = component.get('c.getFieldLabelService'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        action.setParams({
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &quot;objApiNameList&quot;&lt;span&gt; : params.objectAPINameList,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &quot;objApiName2FieldsMap&quot;&lt;span&gt;:params.objectFieldAPINameMap
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         action.setCallback(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(response) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             const state =&lt;span&gt; response.getState();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (state === 'SUCCESS'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                params.callback(response.getReturnValue());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (state === 'ERROR'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 const errors =&lt;span&gt; response.getError();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (errors) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    console.error(JSON.stringify(errors));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     console.error('Unknown error'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        $A.enqueueAction(action);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此组件封装完成，下面是调用部分。调用部分没有UI，感兴趣的自行画UI。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二. 公用组件测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FieldLabelTestComponent：用于引入公用组件，并且初始化获取Account/Contact的field label。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt;=&quot;flexipage:availableForAllPageTypes&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:handler &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;init&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;{!this}&quot;&lt;/span&gt;&lt;span&gt; action&lt;/span&gt;&lt;span&gt;=&quot;{!c.doInit}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;accountFieldLabelMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Map&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;contactFieldLabelMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Map&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:FieldLabelService &lt;/span&gt;&lt;span&gt;aura:id&lt;/span&gt;&lt;span&gt;=&quot;service&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FieldLabelTestComponentController.js：用于后台调用公用组件的方法，传值，针对response进行解析获取自己需要的内容。demo中针对account只获取name以及type的值，对contact获取所有字段的label值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;({
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     doInit : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         const service = component.find('service'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         let objectAPINameList = ['Account','Contact'&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         let objectFieldAPINameMap = {'Account':['name','type'&lt;span&gt;]};
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         service.getFieldLabel(objectAPINameList,objectFieldAPINameMap,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(result) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            console.log(JSON.stringify(result));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             component.set('v.accountFieldLabelMap',result['Account'&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             component.set('v.contactFieldLabelMap',result['Contact'&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             console.log(JSON.stringify(result['Account'&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            console.log(JSON.stringify(result.Account));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结果展示：&lt;/strong&gt;针对account只获取了指定的字段的label，Contact获取了所有的label信息。可以使用[]方式或者.的方式获取详细内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/910966/201912/910966-20191205235010990-1835587870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;总结：&lt;/strong&gt;篇中简单的介绍了针对aura情况下获取field label的公用组件的实现，因为后台通过schema获取fieldmap得到field api name为小写，所以我们如果要传递第二个参数是，需要保证field 的名称为小写，免得获取结果和想象的不同。篇中有错误的地方欢迎指出，有不懂的欢迎留言，有可以优化的地方欢迎交流并且鼓励优化。&lt;/p&gt;

</description>
<pubDate>Thu, 05 Dec 2019 15:55:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<og:description>我们做的项目好多都是多语言的项目，针对不同国家需要展示不同的语言的标题。我们在classic中的VF page可谓是得心应手，因为系统中已经封装好了我们可以直接在VF获取label/api name等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zero-zyq/p/11992457.html</dc:identifier>
</item>
<item>
<title>7. 彤哥说netty系列之Java NIO核心组件之Selector - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/11992860.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/11992860.html</guid>
<description>&lt;p align=&quot;right&quot;&gt;——日拱一卒，不期而至！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201912/1648938-20191205234835312-385005935.png&quot; alt=&quot;nio&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你好，我是彤哥，本篇是netty系列的第七篇。&lt;/p&gt;

&lt;p&gt;上一章我们一起学习了Java NIO的核心组件Buffer，它通常跟Channel一起使用，但是它们在网络IO中又该如何使用呢，今天我们将一起学习另一个NIO核心组件——&lt;strong&gt;Selector&lt;/strong&gt;，没有它可以说就干不起来网络IO。&lt;/p&gt;

&lt;p&gt;我们先来看两段Selector的注释，见类&lt;code&gt;java.nio.channels.Selector&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;注释i&quot;&gt;注释I&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;A multiplexor of {@link SelectableChannel} objects.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;它是&lt;code&gt;SelectableChannel&lt;/code&gt;对象的多路复用器&lt;/strong&gt;，从这里我们也可以知道Java NIO实际上是多路复用IO。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SelectableChannel&lt;/code&gt;有几个子类，你会非常熟悉：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DatagramChannel，UDP协议连接&lt;/li&gt;
&lt;li&gt;SocketChannel，TCP协议连接&lt;/li&gt;
&lt;li&gt;ServerSocketChannel，专门处理TCP协议Accept事件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们有必要复习一下&lt;strong&gt;多路复用IO的流程&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201912/1648938-20191205234835763-1681148105.png&quot; alt=&quot;multiplexing-io&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一阶段通过select去轮询检查有没有连接准备好数据，第二阶段把数据从内核空间拷贝到用户空间。&lt;/p&gt;
&lt;p&gt;在Java中，就是通过&lt;code&gt;Selector&lt;/code&gt;这个多路复用器来实现第一阶段的。&lt;/p&gt;
&lt;h2 id=&quot;注释ii&quot;&gt;注释II&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;A selector may be created by invoking the {@link #open open} method of this class, which will use the system's default {@link java.nio.channels.spi.SelectorProvider selector provider} to create a new selector. A selector may also be created by invoking the {@link java.nio.channels.spi.SelectorProvider#openSelector openSelector} method of a custom selector provider. A selector remains open until it is closed via its {@link #close close} method.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Selector&lt;/code&gt;可以通过它自己的&lt;code&gt;open()&lt;/code&gt;方法创建，它将通过默认的&lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt;类创建一个新的Selector。也可以通过实现&lt;code&gt;java.nio.channels.spi.SelectorProvider&lt;/code&gt;类的抽象方法&lt;code&gt;openSelector()&lt;/code&gt;来自定义实现一个Selector。Selector一旦创建将会一直处于open状态直到调用了&lt;code&gt;close()&lt;/code&gt;方法为止。&lt;/p&gt;
&lt;p&gt;那么，&lt;strong&gt;默认使用的Selector究竟是哪个呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过跟踪源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; java.nio.channels.Selector#open()
  1&amp;gt; java.nio.channels.spi.SelectorProvider#provider()
    1.1&amp;gt; sun.nio.ch.DefaultSelectorProvider#create() // 返回WindowsSelectorProvider
  2&amp;gt; sun.nio.ch.WindowsSelectorProvider#openSelector() // 返回WindowsSelectorImpl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在Windows平台下，默认实现的Provider是&lt;code&gt;WindowsSelectorProvider&lt;/code&gt;，它的&lt;code&gt;openSelector()&lt;/code&gt;方法返回的是&lt;code&gt;WindowsSelectorImpl&lt;/code&gt;，它就是Windows平台默认的Selector实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要提到在Windows平台呢，难道在Linux下面实现不一样？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是滴，因为网络IO是跟操作系统息息相关的，不同的操作系统的实现可能都不一样，Linux下面JDK的实现完全不一样，那么我们为什么没有感知到呢？我的代码在Windows下面写的，拿到Linux下面不是一样运行？那是Java虚拟机（或者说Java运行时环境）帮我们把这个事干了，它屏蔽了跟操作系统相关的细节，这也是Java代码可以“Write Once, Run Anywhere”的精髓所在。&lt;/p&gt;

&lt;p&gt;上面我们说了selector是多路复用器，它是在网络IO的第一阶段用来轮询检查有没有连接准备好数据的，那么它和Channel是什么关系呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201912/1648938-20191205234836012-1796804557.png&quot; alt=&quot;nio&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Selector通过不断轮询的方式同时监听多个Channel的事件，注意，这里是&lt;code&gt;同时监听&lt;/code&gt;，一旦有Channel准备好了，它就会返回这些准备好了的Channel，交给处理线程去处理。&lt;/p&gt;
&lt;p&gt;所以，在NIO编程中，通过Selector我们就实现了一个线程同时处理多个连接请求的目标，也可以一定程序降低服务器资源的消耗。&lt;/p&gt;

&lt;h2 id=&quot;创建selector&quot;&gt;创建Selector&lt;/h2&gt;
&lt;p&gt;通过调用&lt;code&gt;Selector.open()&lt;/code&gt;方法是我们常用的方式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Selector selector = Selector.open();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，也可以通过实现&lt;code&gt;java.nio.channels.spi.SelectorProvider.openSelector()&lt;/code&gt;抽象方法自定义一个Selector。&lt;/p&gt;
&lt;h2 id=&quot;将channel注册到selector上&quot;&gt;将Channel注册到Selector上&lt;/h2&gt;
&lt;p&gt;为了将Channel跟Selector绑定在一起，需要将Channel注册到Selector上，调用Channel的&lt;code&gt;register()&lt;/code&gt;方法即可：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;channel.configureBlocking(false);

SelectionKey key = channel.register(selector, SelectionKey.OP_READ);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Channel必须是非阻塞模式才能注册到Selector上，所以，无法将一个FileChannel注册到Selector，因为FileChannel没有所谓的阻塞还是非阻塞模式，本文来源于工从号彤哥读源码。&lt;/p&gt;
&lt;p&gt;注册的时候第二个参数传入的是监听的事件，一共有四种事件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Connect&lt;/li&gt;
&lt;li&gt;Accept&lt;/li&gt;
&lt;li&gt;Read&lt;/li&gt;
&lt;li&gt;Write&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当Channel触发了某个事件，通常也叫作那个事件就绪了。比如，数据准备好可以读取了就叫作读就绪了，同样地，还有写就绪、连接就绪、接受就绪，当然后面两个不常听到。&lt;/p&gt;
&lt;p&gt;在Java中，这四种监听事件是定义在&lt;code&gt;SelectionKey&lt;/code&gt;中的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SelectionKey.OP_READ，值为 1 &amp;lt;&amp;lt; 0 = 0000 0001&lt;/li&gt;
&lt;li&gt;SelectionKey.OP_WRITE，值 为 1 &amp;lt;&amp;lt; 2 = 0000 0100&lt;/li&gt;
&lt;li&gt;SelectionKey.OP_CONNECT，值为 1 &amp;lt;&amp;lt; 3 = 0000 1000&lt;/li&gt;
&lt;li&gt;SelectionKey.OP_ACCEPT，值为 1 &amp;lt;&amp;lt; 4 = 0001 0000&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，也可以通过&lt;code&gt;位或&lt;/code&gt;命令监听多个感兴趣的事件：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;selectionkey&quot;&gt;SelectionKey&lt;/h2&gt;
&lt;p&gt;正如上面所看到的，Channel注册到Selector后返回的是一个&lt;code&gt;SelectionKey&lt;/code&gt;，所以&lt;code&gt;SelectionKey&lt;/code&gt;又可以看作是Channel和Selector之间的一座桥梁，把两者绑定在了一起。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SelectionKey&lt;/code&gt;具有以下几个重要属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;interest set，感兴趣的事件集&lt;/li&gt;
&lt;li&gt;ready set，就绪的事件集&lt;/li&gt;
&lt;li&gt;保存着的Channel&lt;/li&gt;
&lt;li&gt;保存着的Selector&lt;/li&gt;
&lt;li&gt;attached object，附件&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;interest-set&quot;&gt;interest set&lt;/h3&gt;
&lt;p&gt;里面保存了注册Channel到Selector时传入的第二个参数，即感兴趣的事件集。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int interestSet = selectionKey.interestOps();

boolean isInterestedInAccept  = interestSet &amp;amp; SelectionKey.OP_ACCEPT;
boolean isInterestedInConnect = interestSet &amp;amp; SelectionKey.OP_CONNECT;
boolean isInterestedInRead    = interestSet &amp;amp; SelectionKey.OP_READ;
boolean isInterestedInWrite   = interestSet &amp;amp; SelectionKey.OP_WRITE;    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过&lt;code&gt;位与&lt;/code&gt;运算查看是否注册了相应的事件。&lt;/p&gt;
&lt;h3 id=&quot;ready-set&quot;&gt;ready set&lt;/h3&gt;
&lt;p&gt;里面保存了就绪了的事件集。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int readySet = selectionKey.readyOps();
selectionKey.isAcceptable();
selectionKey.isConnectable();
selectionKey.isReadable();
selectionKey.isWritable();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过&lt;code&gt;readyOps()&lt;/code&gt;方法获取所有就绪了的事件，也可以通过&lt;code&gt;isXxxable()&lt;/code&gt;方法检查某个事件是否就绪。&lt;/p&gt;
&lt;h3 id=&quot;保存的channel和selector&quot;&gt;保存的Channel和Selector&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Channel  channel  = selectionKey.channel();

Selector selector = selectionKey.selector();    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;channel()&lt;/code&gt;和&lt;code&gt;selector()&lt;/code&gt;方法可以获取绑定的Channel和Selector。&lt;/p&gt;
&lt;h3 id=&quot;attachment&quot;&gt;attachment&lt;/h3&gt;
&lt;p&gt;可以调用&lt;code&gt;attach(obj)&lt;/code&gt;方法绑定一个对象到&lt;code&gt;SelectionKey&lt;/code&gt;上，并在后面需要用到的时候通过&lt;code&gt;attachment()&lt;/code&gt;方法取出绑定的对象，也可以翻译为&lt;code&gt;附件&lt;/code&gt;，它可以看作是数据传递的一种媒介，跟ThreadLocal有点类似，在前面绑定数据，在后面使用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;selectionKey.attach(theObject);

Object attachedObj = selectionKey.attachment();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，也可以在注册Channel到Selector的时候就绑定附件：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;selector.select&quot;&gt;Selector.select()&lt;/h2&gt;
&lt;p&gt;一旦将一个或多个Channel注册到Selector上了，我们就可以调用它的&lt;code&gt;select()&lt;/code&gt;方法了，它会返回注册时感兴趣的事件中就绪的事件，本文来源于工从号彤哥读源码。&lt;/p&gt;
&lt;p&gt;select()方法有三种变体：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;select()，无参数，阻塞直到某个Channel有就绪的事件了才返回（当然是我们注册的感兴趣的事件）&lt;/li&gt;
&lt;li&gt;select(timeout)，带超时，阻塞直到某个Channel有就绪的事件了，或者超时了才返回&lt;/li&gt;
&lt;li&gt;selectNow()，立即返回，不会阻塞，不管有没有就绪的Channel都立即返回&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;select()的返回值为int类型，表示两次select()之间就绪的Channel，即使上一次调用select()时返回的就绪Channel没有被处理，下一次调用select()也不会再返回上一次就绪的Channel。比如，第一次调用select()返回了一个就绪的Channel，但是没有处理它，第二次调用select()时又有一个Channel就绪了，那也只会返回1，而不是2。&lt;/p&gt;
&lt;h2 id=&quot;selector.selectedkeys&quot;&gt;Selector.selectedKeys()&lt;/h2&gt;
&lt;p&gt;一旦调用select()方法返回了有就绪的Channel，我们就可以使用&lt;code&gt;selectedKeys()&lt;/code&gt;方法来获取就绪的Channel了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Set&amp;lt;SelectionKey&amp;gt; selectedKeys = selector.selectedKeys();    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，就可以遍历这些SelectionKey来查看感兴趣的事件是否就绪了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Set&amp;lt;SelectionKey&amp;gt; selectedKeys = selector.selectedKeys();

Iterator&amp;lt;SelectionKey&amp;gt; keyIterator = selectedKeys.iterator();

while(keyIterator.hasNext()) {
    
    SelectionKey key = keyIterator.next();

    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.

    } else if (key.isConnectable()) {
        // a connection was established with a remote server.

    } else if (key.isReadable()) {
        // a channel is ready for reading

    } else if (key.isWritable()) {
        // a channel is ready for writing
    }

    keyIterator.remove();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，一定要记得调用&lt;code&gt;keyIterator.remove();&lt;/code&gt;移除已经处理的SelectionKey。&lt;/p&gt;
&lt;h2 id=&quot;selector.wakeup&quot;&gt;Selector.wakeup()&lt;/h2&gt;
&lt;p&gt;前面我们说了调用select()方法时，调用者线程会进入阻塞状态，直到有就绪的Channel才会返回。其实也不一定，wakeup()就是用来破坏规则的，可以在另外一个线程调用wakeup()方法强行唤醒这个阻塞的线程，这样select()方法也会立即返回。&lt;/p&gt;
&lt;p&gt;如果调用wakeup()时并没有线程阻塞在select()上，那么，下一次调用select()将立即返回，不会进入阻塞状态。这跟LockSupport.unpark()方法是比较类似的。&lt;/p&gt;
&lt;h2 id=&quot;selector.close&quot;&gt;Selector.close()&lt;/h2&gt;
&lt;p&gt;调用close()方法将会关闭Selector，同时也会将关联的SelectionKey失效，但不会关闭Channel。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201912/1648938-20191205234836239-217186836.png&quot; alt=&quot;nio&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class EchoServer {
    public static void main(String[] args) throws IOException {
        // 创建一个Selector
        Selector selector = Selector.open();
        // 创建ServerSocketChannel
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        // 绑定8080端口
        serverSocketChannel.bind(new InetSocketAddress(8080));
        // 设置为非阻塞模式，本文来源于工从号彤哥读源码
        serverSocketChannel.configureBlocking(false);
        // 将Channel注册到selector上，并注册Accept事件
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

        while (true) {
            // 阻塞在select上
            selector.select();

            // 如果使用的是select(timeout)或selectNow()需要判断返回值是否大于0

            // 有就绪的Channel
            Set&amp;lt;SelectionKey&amp;gt; selectionKeys = selector.selectedKeys();
            // 遍历selectKeys
            Iterator&amp;lt;SelectionKey&amp;gt; iterator = selectionKeys.iterator();
            while (iterator.hasNext()) {
                SelectionKey selectionKey = iterator.next();
                // 如果是accept事件
                if (selectionKey.isAcceptable()) {
                    // 强制转换为ServerSocketChannel
                    ServerSocketChannel ssc = (ServerSocketChannel) selectionKey.channel();
                    SocketChannel socketChannel = ssc.accept();
                    System.out.println(&quot;accept new conn: &quot; + socketChannel.getRemoteAddress());
                    socketChannel.configureBlocking(false);
                    // 将SocketChannel注册到Selector上，并注册读事件
                    socketChannel.register(selector, SelectionKey.OP_READ);
                } else if (selectionKey.isReadable()) {
                    // 如果是读取事件
                    // 强制转换为SocketChannel
                    SocketChannel socketChannel = (SocketChannel) selectionKey.channel();
                    // 创建Buffer用于读取数据
                    ByteBuffer buffer = ByteBuffer.allocate(1024);
                    // 将数据读入到buffer中
                    int length = socketChannel.read(buffer);
                    if (length &amp;gt; 0) {
                        buffer.flip();
                        byte[] bytes = new byte[buffer.remaining()];
                        // 将数据读入到byte数组中
                        buffer.get(bytes);

                        // 换行符会跟着消息一起传过来
                        String content = new String(bytes, &quot;UTF-8&quot;).replace(&quot;\r\n&quot;, &quot;&quot;);
                        if (content.equalsIgnoreCase(&quot;quit&quot;)) {
                            selectionKey.cancel();
                            socketChannel.close();
                        } else {
                            System.out.println(&quot;receive msg: &quot; + content);
                        }
                    }
                }
                iterator.remove();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;今天我们学习了Java NIO核心组件Selector，到这里，NIO的三个最重要的核心组件我们就学习完毕了，说实话，NIO这块最重要的还是思维的问题，时刻记着在NIO中一个线程是可以处理多个连接的。&lt;/p&gt;
&lt;p&gt;看着Java原生NIO实现网络编程似乎也没什么困难的吗？那么为什么还要有Netty呢？下一章我们将正式进入Netty的学习之中，我们将在其中寻找答案。&lt;/p&gt;
&lt;p&gt;最后，也欢迎来我的工从号&lt;strong&gt;彤哥读源码&lt;/strong&gt;系统地学习&lt;strong&gt;源码&amp;amp;架构&lt;/strong&gt;的知识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1648938/201912/1648938-20191205234836719-409581497.png&quot; alt=&quot;nio&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Dec 2019 15:49:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>——日拱一卒，不期而至！ 你好，我是彤哥，本篇是netty系列的第七篇。 简介 上一章我们一起学习了Java NIO的核心组件Buffer，它通常跟Channel一起使用，但是它们在网络IO中又该如何</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/11992860.html</dc:identifier>
</item>
<item>
<title>4.Netty执行IO事件和非IO任务 - 朵巴阁</title>
<link>http://www.cnblogs.com/spiritsx/p/11992688.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/spiritsx/p/11992688.html</guid>
<description>&lt;p&gt;上文说到NioEventLoop的run方法可以分为3个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;轮询channel中就绪的IO事件&lt;/li&gt;
&lt;li&gt;处理轮询出的IO事件&lt;/li&gt;
&lt;li&gt;处理所有任务，也包括定时任务&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中步骤1已在上一节讲述，这里接着讲述下面2个步骤&lt;/p&gt;

&lt;p&gt;首先看一下在步骤2和步骤3的主干代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final int ioRatio = this.ioRatio;
// 将所有任务执行完
if (ioRatio == 100) {
    try {
        processSelectedKeys();
    } finally {
        // Ensure we always run tasks.
        runAllTasks();
    }
} else {
    // 记录IO事件消耗的时间，然后按比例处理分配时间处理非IO任务
    final long ioStartTime = System.nanoTime();
    try {
        processSelectedKeys();
    } finally {
        // Ensure we always run tasks.
        final long ioTime = System.nanoTime() - ioStartTime;
        // ioRatio默认50，(100-ioRatio)/ioRatio刚好等于1，做到平均分配
        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ioRadio是NioEventLoop的一个成员变量,用来控制分配花费在IO事件与非IO任务时间的比例。默认情况下，ioRadio是50，表示IO事件与非IO任务&lt;br/&gt;将分配相同时间。而当ioRatio为100时，该值失效，不再平衡两种动作的时间分配比值。&lt;br/&gt;了解了这一点，上述两种分支代码就不难理解了，我们直接进入processSelectedKeys，看看netty如何执行IO事件&lt;/p&gt;
&lt;h2 id=&quot;处理io事件&quot;&gt;处理IO事件&lt;/h2&gt;
&lt;p&gt;先进入processSelectedKeys方法内部。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void processSelectedKeys() {
    if (selectedKeys != null) {
        processSelectedKeysOptimized();
    } else {
        processSelectedKeysPlain(selector.selectedKeys());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这里又根据selectedKeys是否为空这个条件来确定是处理优化过的keys还是普通keys。关于selectedKeys，在NioEventLoop介绍这一节中，&lt;br/&gt;我们介绍了NioEventLoop的创建，在创建过程中，默认会将SelectedKeys由Hashset替换为数组实现，此处的selectedKeys正是替换过后的实现。&lt;br/&gt;我们继续跟进到processSelectedKeysOptimized方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void processSelectedKeysOptimized() {
    for (int i = 0; i &amp;lt; selectedKeys.size; ++i) {
        final SelectionKey k = selectedKeys.keys[i];
        selectedKeys.keys[i] = null;
        final Object a = k.attachment();
        if (a instanceof AbstractNioChannel) {
            processSelectedKey(k, (AbstractNioChannel) a);
        } else {
            NioTask&amp;lt;SelectableChannel&amp;gt; task = (NioTask&amp;lt;SelectableChannel&amp;gt;) a;
            processSelectedKey(k, task);
        }
        if (needsToSelectAgain) {
            selectedKeys.reset(i + 1);
            selectAgain();
            i = -1;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法内部用一个for循环处理selectedKeys。key的attchment默认是在注册时附加上去的NioServerSocketChannel和NioSocketChannel。&lt;br/&gt;继续跟进processSelectedKey(k, (AbstractNioChannel) a)方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
    if (!k.isValid()) {
        final EventLoop eventLoop = ch.eventLoop();  
        if (eventLoop != this || eventLoop == null) {
            return;
        }
        unsafe.close(unsafe.voidPromise());
        return;
    }

    int readyOps = k.readyOps();
    if ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != 0) {
        int ops = k.interestOps();
        ops &amp;amp;= ~SelectionKey.OP_CONNECT;
        k.interestOps(ops);
        unsafe.finishConnect();
    }
    if ((readyOps &amp;amp; SelectionKey.OP_WRITE) != 0) {
        ch.unsafe().forceFlush();
    }
    if ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
        unsafe.read();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;netty首先对selectionKey的有效性做了一个判断。当key无效时，关闭key所在的channel。当key有效时，委托NioUnsafe对象对key进行IO操作。&lt;br/&gt;注意这里先进行OP_CONNECT,再执行OP_WRITE,最后执行OP_READ和OP_ACCEPT。关于Unsafe的这些IO操作留待以后分析。&lt;/p&gt;
&lt;p&gt;processSelectedKeysPlain方法流程类似，略过&lt;/p&gt;
&lt;h2 id=&quot;处理非io任务&quot;&gt;处理非IO任务&lt;/h2&gt;
&lt;p&gt;由于IoRatio默认为50，我们先进入runAllTasks(ioTime * (100 - ioRatio) / ioRatio)方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected boolean runAllTasks(long timeoutNanos) {
    // 步骤1
    fetchFromScheduledTaskQueue();
    // 步骤2
    Runnable task = pollTask();
    if (task == null) {
        afterRunningAllTasks();
        return false;
    }
    // 步骤3
    final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;
    long runTasks = 0;
    long lastExecutionTime;
    for (;;) {
        // 步骤4
        safeExecute(task);
        runTasks ++;
        // 步骤5
        if ((runTasks &amp;amp; 0x3F) == 0) {
            lastExecutionTime = ScheduledFutureTask.nanoTime();
            if (lastExecutionTime &amp;gt;= deadline) {
                break;
            }
        }
        task = pollTask();
        if (task == null) {
            lastExecutionTime = ScheduledFutureTask.nanoTime();
            break;
        }
    }
    // 步骤6
    afterRunningAllTasks();
    this.lastExecutionTime = lastExecutionTime;
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;非IO任务的执行可以分为6个步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从定时任务队列聚合任务到普通任务队列&lt;/li&gt;
&lt;li&gt;从普通队列中获取任务&lt;/li&gt;
&lt;li&gt;计算任务执行的超时时间&lt;/li&gt;
&lt;li&gt;安全执行任务&lt;/li&gt;
&lt;li&gt;任务执行到一定次数，计算是否超时&lt;/li&gt;
&lt;li&gt;执行完taskQueue普通队列里的任务后，再去执行tailTaskQueue里的任务。但目前暂时没有看到tailTaskQueue使用的地方，也许是一个扩展点吧，这里先略过。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们一个一个步骤讲解&lt;/p&gt;
&lt;h3 id=&quot;聚合定时任务到普通任务队列&quot;&gt;聚合定时任务到普通任务队列&lt;/h3&gt;
&lt;p&gt;首先看一下整体流程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private boolean fetchFromScheduledTaskQueue() {
    if (scheduledTaskQueue == null || scheduledTaskQueue.isEmpty()) {
        return true;
    }
    long nanoTime = AbstractScheduledEventExecutor.nanoTime();
    for (;;) {
        Runnable scheduledTask = pollScheduledTask(nanoTime);
        if (scheduledTask == null) {
            return true;
        }
        if (!taskQueue.offer(scheduledTask)) {
            scheduledTaskQueue.add((ScheduledFutureTask&amp;lt;?&amp;gt;) scheduledTask);
            return false;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先先判断定时任务队列是否有任务，然后调用了一个AbstractScheduledEventExecutor.nanoTime(),该方法返回ScheduledFutureTask类从初始化&lt;br/&gt;到当前时刻的差值。也即将ScheduledFutureTask初始化的时刻当成零时刻。&lt;br/&gt;获取到零时刻到当前时刻的差值后，用一个for循环不断去定时任务队列里获取终止时刻在当前时刻之后的任务(scheduledTask.deadlineNanos() - nanoTime&amp;lt;=0)&lt;br/&gt;当获取到定时任务后，将它添加到普通任务队列taskQueue里。同时添加失败后，还会再重新添加回定时任务队列，防止任务直接丢失。&lt;/p&gt;
&lt;p&gt;说到定时任务队列，也少不了一探其实现。scheduledTaskQueue初始化代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PriorityQueue&amp;lt;ScheduledFutureTask&amp;lt;?&amp;gt;&amp;gt; scheduledTaskQueue() {
    if (scheduledTaskQueue == null) {
        scheduledTaskQueue = new DefaultPriorityQueue&amp;lt;&amp;gt;(
                SCHEDULED_FUTURE_TASK_COMPARATOR,
                11);
    }
    return scheduledTaskQueue;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;采用的是一个懒加载的方式，在调用scheduledTaskQueue()创建定时任务时才进行初始化。从名字可以看出，它是一个优先级队列，初始化容量为11，&lt;br/&gt;采用的Comparator是调用2个ScheduledFutureTask的compareTo方法，首先比较任务的终止时间，然后比较两个任务的id。代码较简单，就不列了。&lt;/p&gt;
&lt;p&gt;然后我们看下调度方法schedule&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private &amp;lt;V&amp;gt; ScheduledFuture&amp;lt;V&amp;gt; schedule(final ScheduledFutureTask&amp;lt;V&amp;gt; task) {
    if (inEventLoop()) {
        scheduledTaskQueue().add(task.setId(nextTaskId++));
    } else {
        executeScheduledRunnable(new Runnable() {
            @Override
            public void run() {
                scheduledTaskQueue().add(task.setId(nextTaskId++));
            }
        }, true, task.deadlineNanos());
    }
    return task;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，netty将&quot;添加定时任务&quot;也当做一个任务，放入任务队列里。&lt;/p&gt;
&lt;h3 id=&quot;从普通队列中获取任务&quot;&gt;从普通队列中获取任务&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// NioEventLoop中定义的pollTask方法
protected Runnable pollTask() {
    Runnable task = super.pollTask();
    if (needsToSelectAgain) {
        selectAgain();
    }
    return task;
}
// super.pollTask调用了此方法，定义在SingleThreadEventExecutor中
protected static Runnable pollTaskFrom(Queue&amp;lt;Runnable&amp;gt; taskQueue) {
        for (;;) {
            Runnable task = taskQueue.poll();
            if (task != WAKEUP_TASK) {
                return task;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里依然是通过轮询从任务队列里取出任务，并且忽略WAKEUP_TASK这个标记性任务。&lt;/p&gt;
&lt;h3 id=&quot;计算任务执行的超时时间&quot;&gt;计算任务执行的超时时间&lt;/h3&gt;
&lt;p&gt;在当前时间上，加上IO事件执行的时间，作为非IO任务执行的超时时间&lt;/p&gt;
&lt;h3 id=&quot;安全执行&quot;&gt;安全执行&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;protected static void safeExecute(Runnable task) {
    try {
        task.run();
    } catch (Throwable t) {
        logger.warn(&quot;A task raised an exception. Task: {}&quot;, task, t);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;捕获所有异常，使得定时任务报错时不退出&lt;/p&gt;
&lt;h3 id=&quot;计算是否超时&quot;&gt;计算是否超时&lt;/h3&gt;
&lt;p&gt;由于nanoTime()是一个相对耗时的操作，netty默认执行了64次非IO任务后，才计算是否超时。若执行了超过64个任务没或者任务队列已经没有任务，&lt;br/&gt;就打断循环，并将当前时间更新为lastExecutionTime。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;到了这里，我们已经介绍完了大部分NioEventLoop的内容，限于笔者水平和文章篇幅，nioEventLoop所使用的任务队列MpscQueue和ScheduleFutureTask&lt;br/&gt;内部执行原理不再进一步深究。但这也已经足够对NioEventLoop塑造一个比较整体性的认识了。&lt;/p&gt;
</description>
<pubDate>Thu, 05 Dec 2019 15:05:00 +0000</pubDate>
<dc:creator>朵巴阁</dc:creator>
<og:description>&lt;! TOC '回顾NioEventLoop的run方法流程' 'IO事件与非IO任务' '处理IO事件' '处理非IO任务' '聚合定时任务到普通任务队列' '从普通队列中获取任务' '计算任务执行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/spiritsx/p/11992688.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：恩智浦i.MX RTxxx系列MCU启动那些事（3）- Serial ISP模式(blhost) - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/11992494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/11992494.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是&lt;strong&gt;恩智浦i.MX RTxxx系列MCU的Serial ISP模式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　在上一篇文章 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/11990219.html&quot;&gt;Boot配置(ISP Pin, OTP)&lt;/a&gt; 里痞子衡为大家介绍了i.MXRTxxx Boot的行为配置，其中第1.2节里讲了Boot有三类行为模式：Serial ISP、Serial Boot、Device Boot，后两种都是跟App启动执行相关的行为模式，而Serial ISP模式则是相对独立的Flash下载功能，有了Serial ISP，便可省去专用Flash编程器，今天痞子衡就来详细聊一聊Serial ISP模式。&lt;/p&gt;
&lt;p&gt;　　痞子衡在前面已经讲过Serial ISP模式是一种串行编程模式，在这种模式下，BootROM通过指定的UART/SPI/I2C/USB-HID口来接收来自Host（恩智浦提供了上位机工具blhost.exe或者MCUBootUtility）的Application数据，并将数据下载进i.MXRTxxx支持的所有外部非易失性存储器中，为后续从外部存储器启动做准备。&lt;/p&gt;
&lt;h3 id=&quot;一进入serial-isp模式&quot;&gt;一、进入Serial ISP模式&lt;/h3&gt;
&lt;p&gt;　　i.MXRTxxx上电永远是从ROM启动去执行BootROM程序，最顶层的Boot行为模式由OTP memory里的PRIMARY_BOOT_SRC[3:0]位和芯片外部ISP[2:0]管脚状态共同决定。假设我们正处于研发阶段，PRIMARY_BOOT_SRC[3:0]并未烧写，那想进入Serial ISP模式最直接的方式便是将ISP[2:0]输入状态拨成3'b110，在设计i.MXRTxxx的硬件板时ISP[2:0] pins应设计成可通过拨码开关选择输入电平，下图是RT600-EVK板（Rev.E）的参考设计：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRTxxx_Boot_SerialISP_Pin.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　拨码开关SW5应拨向SW_DIP-6的6，即设置ISP[2:0]=3'b110，此时便直接进入了Serial ISP模式。&lt;/p&gt;
&lt;h3 id=&quot;二blhost的使用&quot;&gt;二、blhost的使用&lt;/h3&gt;
&lt;p&gt;　　进入了Serial ISP模式，此时便可以用恩智浦提供的host工具与BootROM进行命令交互，host工具在 &lt;a href=&quot;https://github.com/JayHeng/NXP-MCUBootUtility&quot;&gt;MCUBootUtility包&lt;/a&gt; 里。下载好MCUBootUtility包之后，在\MCUBootUtility\Tools\blhost2_3\win下可以找到用于与BootROM通信的blhost.exe。&lt;/p&gt;
&lt;h4 id=&quot;支持的通信外设pinout&quot;&gt;2.1 支持的通信外设pinout&lt;/h4&gt;
&lt;p&gt;　　BootROM支持四种通信外设，分别是UART/SPI/I2C/USB-HID（其中UART和USB比较常用），pinout如下（Pinout适用RT600）：&lt;br/&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRTxxx_Boot_SerialISP_Pinout.PNG&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;blhost用法&quot;&gt;2.2 blhost用法&lt;/h4&gt;
&lt;p&gt;　　blhost.exe是命令行工具，使用blhost可以通过上述UART/SPI/I2C/USB-HID口与BootROM进行通信与命令交互。&lt;br/&gt;　　在命令行下打开blhost.exe，输入-?命令可以看到blhost使用帮助，blhost支持的命令很多：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;PS D:\NXP-MCUBootUtility\tools\blhost2_3\win&amp;gt; .\blhost.exe
usage: D:\NXP-MCUBootUtility\tools\blhost2_3\win\blhost.exe
                                                                      [-?|--help]
                                                                      [-p|--port &amp;lt;name&amp;gt;[,&amp;lt;speed&amp;gt;]]
                                                                      [-u|--usb [[[&amp;lt;vid&amp;gt;,]&amp;lt;pid&amp;gt;]]]
                                                                      [-t|--timeout &amp;lt;ms&amp;gt;]
                                                                      -- command &amp;lt;args...&amp;gt;

Options:
  -?/--help                    Show this help
  -p/--port &amp;lt;name&amp;gt;[,&amp;lt;speed&amp;gt;]   Connect to target over UART. Specify COM port
                               and optionally baud rate
                                 (default=57600)
                                 If -ftbi, then port is BusPal port
  --ftdi spi[,&amp;lt;speed&amp;gt;,&amp;lt;polarity&amp;gt;,&amp;lt;phase&amp;gt;,lsb|msb] |
              i2c[,&amp;lt;address&amp;gt;,&amp;lt;speed&amp;gt;]
                               Use SPI or I2C for BusPal&amp;lt;--&amp;gt;Target link
                               All parameters between square brackets are
                               optional, but preceding parameters must be
                               present or marked with a comma.
                               (ex. -b spi,1000,0,1) (ex. --ftdi spi,1000,,lsb)
                                 spi:  speed(KHz),
                                       polarity(0=active_high | 1=active_low),
                                       phase(0=rising_edge | 1=falling_edge),
                                       &quot;lsb&quot; | &quot;msb&quot;
                                       (default=100,1,1,msb)
                                 i2c:  address(7-bit hex), speed(KHz)
                                       (default=0x10,100)
  -u/--usb [[[&amp;lt;vid&amp;gt;,]&amp;lt;pid&amp;gt;] | [&amp;lt;path&amp;gt;]]
                               Connect to target over USB HID device denoted by
                               vid/pid (default=0x15a2,0x0073) or device path
  -t/--timeout &amp;lt;ms&amp;gt;            Set packet timeout in milliseconds
                                 (default=5000)

Memory ID:
  Internal Memory              Device internal memory space
    0                            Internal Memory
                                 (Default selected memory)
    16 (0x10)                    Execute-only region on internal flash
                                 (Only used for flash-erase-all)
  Mapped External Memory       The memories that are remapped to internal space,
                               and must be accessed by internal addresses.
                               (IDs in this group are only used for flash-erase-all and
                               configure-memory, and ignored by write-memory, read-memory,
                               flash-erase-region and flash-image(use default 0))
    1                            QuadSPI Memory
    9                            FlexSPI NOR Memory
  Unmapped External Memory     Memories which cannot be remapped to internal space,
                               and only can be accessed by memories' addresses.
                               (Must be specified for all commands with &amp;lt;memoryId&amp;gt; argument)
    272 (0x110)                  SPI NOR/EEPROM Memory
    288 (0x120)                  uSDHC SD Memory
    289 (0x121)                  uSDHC MMC Memory

** Note that not all memories are supported on all platforms.

Command:
  reset                        Reset the chip
  get-property &amp;lt;tag&amp;gt; [&amp;lt;memoryId&amp;gt; | &amp;lt;index&amp;gt;]
                               Return bootloader specific property.
                               &amp;lt;memoryId&amp;gt; and &amp;lt;index&amp;gt; are required by some properties.
                               &amp;lt;memoryId&amp;gt; = 0, &amp;lt;index&amp;gt; = 0, if not specified.
                               &amp;lt;memoryId&amp;gt; and &amp;lt;index&amp;gt; are ignored for the other properties.
                               If &amp;lt;index&amp;gt; is over the range supported by the device, bootloader
                               will treat as &amp;lt;index&amp;gt; = 0.

    1                          Bootloader version
    2                          Available peripherals
    3                          Start of program flash, &amp;lt;index&amp;gt; is required
    4                          Size of program flash, &amp;lt;index&amp;gt; is required
    5                          Size of flash sector, &amp;lt;index&amp;gt; is required
    6                          Blocks in flash array, &amp;lt;index&amp;gt; is required
    7                          Available commands
    9                          Last Error
    10                         Verify Writes flag
    11                         Max supported packet size
    14                         Start of RAM, &amp;lt;index&amp;gt; is required
    15                         Size of RAM, &amp;lt;index&amp;gt; is required
    23                         QuadSpi initialization status
    24                         Target version
    25                         External memory attrubutes, &amp;lt;memoryId&amp;gt; is required
    27                         Flash page size, &amp;lt;index&amp;gt; is required
    28                         Interrupt notifier pin
    29                         FFR key store update option
  set-property &amp;lt;tag&amp;gt; &amp;lt;value&amp;gt;
    10                         Verify Writes flag
    28                         Interrupt notifier pin
                               &amp;lt;value&amp;gt;:
                                   bit[31] for enablement, 0: disable, 1: enable
                                   bit[7:0] for GPIO pin index
                                   bit[15:8] for GPIO port index
    29                         FFR key store update option
                               &amp;lt;value&amp;gt;:
                                   0 for Keyprovisioning
                                   1 for write-memory
  flash-erase-region &amp;lt;addr&amp;gt; &amp;lt;byte_count&amp;gt; [memory_id]
                               Erase a region of flash according to [memory_id].
  flash-erase-all [memory_id]  Erase all flash according to [memory_id],
                               excluding protected regions.
  read-memory &amp;lt;addr&amp;gt; &amp;lt;byte_count&amp;gt; [&amp;lt;file&amp;gt;] [memory_id]
                               Read memory according to [memory_id] and write to file
                               or stdout if no file specified
  write-memory &amp;lt;addr&amp;gt; [&amp;lt;file&amp;gt;[,byte_count]| {{&amp;lt;hex-data&amp;gt;}}] [memory_id]
                               Write memory according to [memory_id] from file
                               or string of hex values,
                               e.g. data.bin (writes entire file)
                               e.g. data.bin 8 (writes first 8 bytes from file)
                               e.g. &quot;{{11 22 33 44}}&quot; (w/quotes)
                               e.g. {{11223344}} (no spaces)
  fill-memory &amp;lt;addr&amp;gt; &amp;lt;byte_count&amp;gt; &amp;lt;pattern&amp;gt; [word | short | byte]
                               Fill memory with pattern; size is
                               word (default), short or byte
  receive-sb-file &amp;lt;file&amp;gt;       Receive SB file
  execute &amp;lt;addr&amp;gt; &amp;lt;arg&amp;gt; &amp;lt;stackpointer&amp;gt;
                               Execute at address with arg and stack pointer
  call &amp;lt;addr&amp;gt; &amp;lt;arg&amp;gt;            Call address with arg
  configure-memory &amp;lt;memory_id&amp;gt; &amp;lt;internal_addr&amp;gt;
                               Apply configuration block at internal memory address
                               &amp;lt;internal_addr&amp;gt; to memory with ID &amp;lt;memory_id&amp;gt;
  key-provisioning &amp;lt;operation&amp;gt; [arguments...]
                               &amp;lt;enroll&amp;gt;
                                   Key provisioning enroll. No argument for this operation
                               &amp;lt;set_user_key&amp;gt; &amp;lt;type&amp;gt; &amp;lt;file&amp;gt;[,&amp;lt;size&amp;gt;]
                                   Send the user key specified by &amp;lt;type&amp;gt; to bootloader. &amp;lt;file&amp;gt; is
                                   the binary file containing user key plaintext. If &amp;lt;size&amp;gt; is not
                                   specified, the entire &amp;lt;file&amp;gt; will be sent. Otherwise, only send
                                   the first &amp;lt;size&amp;gt; bytes
                               &amp;lt;set_key&amp;gt; &amp;lt;type&amp;gt; &amp;lt;size&amp;gt;
                                   Generate &amp;lt;size&amp;gt; bytes of the key specified by &amp;lt;type&amp;gt;
                               &amp;lt;write_key_nonvolatile&amp;gt; [memoryID]
                                   Write the key to a nonvolatile memory
                               &amp;lt;read_key_nonvolatile&amp;gt; [memoryID]
                                   Load the key from a nonvolatile memory to bootloader
                               &amp;lt;write_key_store&amp;gt; &amp;lt;file&amp;gt;[,&amp;lt;size&amp;gt;]
                                   Send the key store to bootloader. &amp;lt;file&amp;gt; is the binary file
                                   containing key store. If &amp;lt;size&amp;gt; is not specified, the entire
                                   &amp;lt;file&amp;gt; will be sent. Otherwise, only send the first &amp;lt;size&amp;gt; bytes
                               &amp;lt;read_key_store&amp;gt; &amp;lt;file&amp;gt;
                                   Read the key store from bootloader to host(PC). &amp;lt;file&amp;gt; is the
                                   binary file to store the key store
  flash-image &amp;lt;file&amp;gt; [erase] [memory_id]
                               Write a formated image &amp;lt;file&amp;gt; to memory with ID
                               &amp;lt;memory_id&amp;gt;. Supported file types: SRecord
                               (.srec and .s19) and HEX (.hex). Flash is erased
                               before writing if [erase]=erase. The erase unit
                               size depends on the target and the minimum erase
                               unit size is 1K.
  list-memory                  List all on-chip Flash and RAM regions, and off-chip
                               memories, supported by current device.
                               Only the configured off-chip memory will be list.
  efuse-program-once &amp;lt;addr&amp;gt; &amp;lt;data&amp;gt; [nolock/lock]
                               Program one word of OCOTP Field
                               &amp;lt;addr&amp;gt; is ADDR of OTP word, not the shadowed memory address.
                               &amp;lt;data&amp;gt; is hex digits without prefix '0x'
  efuse-read-once &amp;lt;addr&amp;gt;
                               Read one word of OCOTP Field
                               &amp;lt;addr&amp;gt; is ADDR of OTP word, not the shadowed memory address.
  generate-key-blob &amp;lt;dek_file&amp;gt; &amp;lt;blob_file&amp;gt;
                               Generate the Blob for given Dek Key
                               &amp;lt;dek_file&amp;gt; - input, a binary Dek Key (128 Bits) generated by CST tool.
                               &amp;lt;blob_file&amp;gt; - output, a generated blob (72 Bytes) in binary format.

** Note that not all commands/properties are supported on all platforms.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　当使用串口转USB模块连接i.MXRTxxx的Flexcomm UART0或者使用USB Cable连接上USB1口后可以看到PC设备管理器会识别出相关设备：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/i.MXRTxxx_Boot_SerialISP_device_manager.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　让我们尝试一下使用blhost与BootROM通信，先试一下USB通信:&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;PS D:\NXP-MCUBootUtility\tools\blhost2_3\win&amp;gt; &lt;span&gt;.\blhost.exe -u 0x1fc9,0x0020 -- get-property 1&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;Inject command 'get-property'
Response status = 0 (0x0) Success.
Response word 1 = 1258487808 (0x4b030000)
Current Version = K3.0.0&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;　　再接着试一下UART通信，似乎通信失败了。需要注意的是，当使用USB通信过一次之后，BootROM已经激活USB外设，不会再去检测其他外设（包括UART），如果想使用UART通信，需要将板子reset一次，使BootROM重回外设检测状态。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PS D:\NXP-MCUBootUtility\tools\blhost2_3\win&amp;gt; &lt;span&gt;.\blhost.exe -p COM25 -- get-property 1&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;Error: Initial ping failure: No response received for ping command.&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;三下载更新application示例&quot;&gt;三、下载更新Application示例&lt;/h3&gt;
&lt;p&gt;　　因为BootROM支持启动的外部存储器很多，所以Serial ISP模式下进行Application更新操作要指定具体的外部存储器类型。在上一节blhost的命令帮助里，我们可以看到Memory ID里已经给各种外部储存器分配了ID号，在使用blhost命令时使用不同的ID号即可操作相应外部存储器。&lt;br/&gt;　　其实BootROM里已经把外部存储器的下载更新Application操作封装得很简单也很统一，我们其实只需要3步操作即可完成Application的下载。以备份启动的1bit SPI NOR为例（即Flexcomm SPI NOR Memory，Memory ID=0x110）：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;// 在SRAM里临时存储Serial EEPROM/NOR配置数据
blhost -p COMx -- fill-memory 0x1C000 0x4 0xC0300000 // Flexcomm SPI3, NOR Flash

// 使用Serial EEPROM/NOR配置数据去配置Flexcomm SPI接口
blhost -p COMx -- configure-memory 0x110 0x1C000

// 擦除Serial EEPROM/NOR并将image下载进Serial EEPROM/NOR
blhost -p COMx -- flash-erase-region 0x0 0x20000 0x110
blhost -p COMx -- write-memory 0x0 bt_image.bin 0x110&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　其中bt_image.bin是填充了Image类型数据的Application镜像，关于上述命令的具体意义痞子衡会在后续Serial(1-bit SPI) EEPROM/NOR恢复启动的文章里详尽解释，这里只是给大家一个初步体验。&lt;/p&gt;
&lt;p&gt;　　至此，恩智浦i.MX RTxxx系列MCU的Serial ISP模式痞子衡便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
</description>
<pubDate>Thu, 05 Dec 2019 14:56:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>i.MXRTxxx Boot有三类行为模式：Serial ISP、Serial Boot、Device Boot，后两种都是跟App启动执行相关的行为模式，而Serial ISP模式则是相对独立的Fl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/11992494.html</dc:identifier>
</item>
<item>
<title>深入了解CSS中盒子模型 - 微笑是最初的信仰</title>
<link>http://www.cnblogs.com/lq0001/p/11992092.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lq0001/p/11992092.html</guid>
<description>&lt;h2 id=&quot;css中盒子模型介绍&quot;&gt;CSS中盒子模型介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;什么是盒子？&lt;/li&gt;
&lt;li&gt;盒子是用来存储物品，我们可以将盒子理解为酒盒，酒盒有什么组成的呢？ 有酒可以喝、有填充物保护酒防止酒被摔坏、纸盒子。&lt;/li&gt;
&lt;li&gt;我们怎么理解&lt;code&gt;CSS&lt;/code&gt;中的盒子呢，&lt;code&gt;CSS&lt;/code&gt;中盒子有什么组成的呢？有内容、内边距、边框、外边距。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CSS&lt;/code&gt;中盒子的主要属性有&lt;code&gt;5&lt;/code&gt;种如：&lt;code&gt;width&lt;/code&gt;宽度、&lt;code&gt;height&lt;/code&gt;高度、&lt;code&gt;padding&lt;/code&gt;内边距、&lt;code&gt;border&lt;/code&gt;边框、&lt;code&gt;margin&lt;/code&gt;外边距。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;css中盒子模型实践&quot;&gt;CSS中盒子模型实践&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;CSS&lt;/code&gt;中盒子模型实践，给大家看看我们&lt;code&gt;CSS&lt;/code&gt;中的盒子长什么样。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    div {
       /*这里的宽度指的就是盒子内容的宽度*/
      width: 100px;
       /*这里的高度值的就是盒子内容的高度*/
      height: 100px;
      /*内边距就是盒子里面的内容到边框的距离*/
      padding: 30px;
      /*这个就是指盒子的外边框*/
      border: 1px solid red;
      /*这个就是指盒子的外边距，盒子与盒子之间的距离*/
      margin: 20px;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div&amp;gt;
    微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰。
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212147507-44552418.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何计算一个盒子的总宽度和总高度，笔者那宽度举例：&lt;code&gt;一个盒子的总宽度&lt;/code&gt;=&lt;code&gt;盒子内容宽度&lt;/code&gt; +&lt;code&gt;左右2边内边距&lt;/code&gt;+&lt;code&gt;左右2边边框线&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212207108-1510956808.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：一个盒子的高度一般情况下不设置高度，因为一个盒子的高度它应该是由其内容来决定的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;padding内边距介绍&quot;&gt;padding内边距介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;padding&lt;/code&gt;内边距的意思就是指的盒子中间的内容与边框的这段距离。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;padding&lt;/code&gt;内边距分为&lt;code&gt;4&lt;/code&gt;个方向，所以我们能够设置或描述这&lt;code&gt;4&lt;/code&gt;个方向的内边距。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;padding&lt;/code&gt;内边距属性值说明表：&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;padding-top&lt;/td&gt;
&lt;td&gt;设置向上的内边距的距离。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;padding-bottom&lt;/td&gt;
&lt;td&gt;设置向下的内边的距距离。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;padding-left&lt;/td&gt;
&lt;td&gt;设置向左的内边距的距离。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;padding-right&lt;/td&gt;
&lt;td&gt;设置向右的内边距的距离。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;padding&lt;/td&gt;
&lt;td&gt;设置上下左右内边距的距离，是上面的属性值缩写。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;padding内边距实践&quot;&gt;padding内边距实践&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;我们将&lt;code&gt;div&lt;/code&gt;标签设置内边距，实践内容如：将&lt;code&gt;div&lt;/code&gt;标签&lt;code&gt;上&lt;/code&gt;边内边距设置为&lt;code&gt;20px&lt;/code&gt;、&lt;code&gt;下&lt;/code&gt;边内边距设置为&lt;code&gt;30px&lt;/code&gt;、&lt;code&gt;左&lt;/code&gt;边边距设置为&lt;code&gt;40px&lt;/code&gt;、&lt;code&gt;右&lt;/code&gt;边内边距设置为&lt;code&gt;50px&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    div {
       /*这里的宽度指的就是盒子内容的宽度*/
      width: 100px;
       /*这里的高度值的就是盒子内容的高度*/
      height: 100px;
      border: 1px solid red;
      padding-top: 20px;
      padding-bottom: 30px;
      padding-left: 40px;
      padding-right: 50px;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div&amp;gt;
    微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰。
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212245508-302585685.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;padding内边距缩写实践&quot;&gt;padding内边距缩写实践&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;缩写是有方向的可以同时表示四个方向，但是这个&lt;code&gt;padding&lt;/code&gt;属性的方向是有顺序的，顺序规则如：&lt;code&gt;上&lt;/code&gt;、&lt;code&gt;右&lt;/code&gt;、&lt;code&gt;下&lt;/code&gt;、&lt;code&gt;左&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;padding&lt;/code&gt;属性值有&lt;code&gt;4&lt;/code&gt;个，接下来我们就一一试试看看会有什么效果呢。&lt;/li&gt;
&lt;li&gt;我们给&lt;code&gt;padding&lt;/code&gt;属性设置&lt;code&gt;1&lt;/code&gt;个值实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    div {
       /*这里的宽度指的就是盒子内容的宽度*/
      width: 100px;
       /*这里的高度值的就是盒子内容的高度*/
      height: 100px;
      border: 1px solid red;
      padding: 20px;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div&amp;gt;
    微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰。
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212311692-705747436.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：假设我们给&lt;code&gt;padding&lt;/code&gt;属性值设置了&lt;code&gt;1&lt;/code&gt;个值为：&lt;code&gt;padding: 20px;&lt;/code&gt;表示&lt;code&gt;上&lt;/code&gt;、&lt;code&gt;右&lt;/code&gt;、&lt;code&gt;下&lt;/code&gt;、&lt;code&gt;左&lt;/code&gt;、方向的内边距都为&lt;code&gt;20px&lt;/code&gt;像素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;我们给&lt;code&gt;padding&lt;/code&gt;属性设置&lt;code&gt;2&lt;/code&gt;个值实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    div {
       /*这里的宽度指的就是盒子内容的宽度*/
      width: 100px;
       /*这里的高度值的就是盒子内容的高度*/
      height: 100px;
      border: 1px solid red;
      padding: 20px 30px;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div&amp;gt;
    微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰。
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212336041-948858895.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：假设我们给&lt;code&gt;padding&lt;/code&gt;属性值设置了&lt;code&gt;2&lt;/code&gt;个值如：&lt;code&gt;padding: 20px 30px;&lt;/code&gt;表示内边距的&lt;code&gt;（上、下）&lt;/code&gt;为&lt;code&gt;20px&lt;/code&gt;像素、&lt;code&gt;（左、右）&lt;/code&gt;为&lt;code&gt;30px&lt;/code&gt;像素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;我们给&lt;code&gt;padding&lt;/code&gt;属性设置&lt;code&gt;3&lt;/code&gt;个值实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    div {
       /*这里的宽度指的就是盒子内容的宽度*/
      width: 100px;
       /*这里的高度值的就是盒子内容的高度*/
      height: 100px;
      border: 1px solid red;
      padding: 20px 30px 40px;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div&amp;gt;
    微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰。
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212402903-1762524673.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：假设我们给&lt;code&gt;padding&lt;/code&gt;属性值设置了&lt;code&gt;3&lt;/code&gt;个值如：&lt;code&gt;padding: 20px 30px 40px;&lt;/code&gt;表示内边距的&lt;code&gt;上&lt;/code&gt;为&lt;code&gt;20px&lt;/code&gt;像素、&lt;code&gt;（左、右&lt;/code&gt;）为&lt;code&gt;30px&lt;/code&gt;像素、&lt;code&gt;下&lt;/code&gt;为&lt;code&gt;40px&lt;/code&gt;像素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;我们给&lt;code&gt;padding&lt;/code&gt;属性设置&lt;code&gt;4&lt;/code&gt;个值实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    div {
       /*这里的宽度指的就是盒子内容的宽度*/
      width: 100px;
       /*这里的高度值的就是盒子内容的高度*/
      height: 100px;
      border: 1px solid red;
      padding: 20px 30px 40px 50px;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;div&amp;gt;
    微笑是最初的信仰，微笑是最初的信仰，微笑是最初的信仰。
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212424291-217796629.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：假设我们给&lt;code&gt;padding&lt;/code&gt;属性值设置了&lt;code&gt;3&lt;/code&gt;个值如&lt;code&gt;padding: 20px 30px 40px 50px;&lt;/code&gt;表示内边距的&lt;code&gt;上&lt;/code&gt;为&lt;code&gt;20px&lt;/code&gt;像素、&lt;code&gt;右&lt;/code&gt;为&lt;code&gt;30px&lt;/code&gt;像素、&lt;code&gt;下&lt;/code&gt;为&lt;code&gt;40px&lt;/code&gt;像素、&lt;code&gt;左&lt;/code&gt;为&lt;code&gt;50px&lt;/code&gt;像素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;margin外边距介绍&quot;&gt;margin外边距介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;margin&lt;/code&gt;外边距的意思就是指的盒子与盒子之间的距离。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;margin&lt;/code&gt;外边距分为&lt;code&gt;4&lt;/code&gt;个方向，所以我们能够设置或描述这&lt;code&gt;4&lt;/code&gt;个方向的外边距。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;margin&lt;/code&gt;外边距属性值说明表：&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;margin-top&lt;/td&gt;
&lt;td&gt;设置向上的外边距的距离。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;margin-bottom&lt;/td&gt;
&lt;td&gt;设置向下的外边的距距离。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;margin-left&lt;/td&gt;
&lt;td&gt;设置向左的外边距的距离。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;margin-right&lt;/td&gt;
&lt;td&gt;设置向右的外边距的距离。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;margin&lt;/td&gt;
&lt;td&gt;设置上下左右外边距的距离，是上面的属性值缩写。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;auto&lt;/td&gt;
&lt;td&gt;自动。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;margin上下外边距实践&quot;&gt;margin上下外边距实践&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;我们将&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.top&lt;/code&gt;元素设置上外边距为&lt;code&gt;20px&lt;/code&gt;像素并且将&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.bottom&lt;/code&gt;设置下外边距为&lt;code&gt;20px&lt;/code&gt;像素。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    .bottom{
      width: 100px;
      height: 100px;
      background-color: red;
      margin-bottom: 20px;
    }
    .top{
      width: 100px;
      height: 100px;
      background-color: slateblue;
      margin-top: 20px;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;bottom&quot;&amp;gt;&amp;lt;/div&amp;gt;
   &amp;lt;div class=&quot;top&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;calss&lt;/code&gt;属性值为&lt;code&gt;.bottom&lt;/code&gt;结果图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212454090-558581463.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;calss&lt;/code&gt;属性值为&lt;code&gt;.top&lt;/code&gt;结果图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212512977-184422341.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：两张图有什么区别呢，事实证明外边距竖直方向的&lt;code&gt;margin&lt;/code&gt;的属性值不会叠加，它会取最大的属性值，大家要明白哦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;margin左右外边距实践&quot;&gt;margin左右外边距实践&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;我们将&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.right&lt;/code&gt;元素设置右外边距为&lt;code&gt;20px&lt;/code&gt;像素并且将&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.left&lt;/code&gt;设置左外边距为&lt;code&gt;20px&lt;/code&gt;像素。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    
     .left{
       background-color: slateblue;
       margin-left: 20px;
     }
     .right{
        background-color: red;
        margin-right: 20px;
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;span class=&quot;right&quot;&amp;gt;right&amp;lt;/span&amp;gt;
  &amp;lt;span class=&quot;left&quot;&amp;gt;left&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;calss&lt;/code&gt;属性值为&lt;code&gt;.right&lt;/code&gt;结果图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212534026-143174226.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;calss&lt;/code&gt;属性值为&lt;code&gt;.left&lt;/code&gt;结果图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212553885-1485140363.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.42268041237113&quot;&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：两张图有什么区别呢，事实证明外边距水平线方向&lt;code&gt;margin&lt;/code&gt;的属性值会叠加。大家要明白哦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5689655172414&quot;&gt;
&lt;p&gt;若想让竖直方向的&lt;code&gt;margin&lt;/code&gt;属性值叠加外边距的距离咱也是有办法如：将要设置&lt;code&gt;margin&lt;/code&gt;属性的元素进行浮动即可，元素浮动之后它的&lt;code&gt;margin&lt;/code&gt;属性值就会叠加，若有读者朋友不熟悉浮动的可以看看笔者之间发布的&lt;a href=&quot;https://www.cnblogs.com/lq0001/p/11967202.html&quot;&gt;CSS中如果实现元素浮动和清除浮动，看这篇文章就足够了&lt;/a&gt;文章。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
     .box{
       width: 110px;
       border: 2px solid red;
       overflow: hidden;
     }
     .bottom{
       width: 100px;
       height: 100px;
       background-color: slateblue;
       float: left;
       margin-bottom: 20px;
      
     }
     .top{
        width: 100px;
        height: 100px;
        background-color: darkblue;
        float: left;
        margin-top: 20px;
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;box&quot;&amp;gt;
     &amp;lt;div class=&quot;bottom&quot;&amp;gt;&amp;lt;/div&amp;gt;
     &amp;lt;div class=&quot;top&quot;&amp;gt;&amp;lt;/div&amp;gt;
   &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;calss&lt;/code&gt;属性值为&lt;code&gt;.bottom&lt;/code&gt;结果图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212620896-1070695341.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;calss&lt;/code&gt;属性值为&lt;code&gt;.top&lt;/code&gt;结果图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212637228-908906782.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;margin外边距缩写实践&quot;&gt;margin外边距缩写实践&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;缩写是有方向的可以同时表示四个方向，但是这个&lt;code&gt;margin&lt;/code&gt;属性的方向是有顺序的，顺序规则如：&lt;code&gt;上&lt;/code&gt;、&lt;code&gt;右&lt;/code&gt;、&lt;code&gt;下&lt;/code&gt;、&lt;code&gt;左&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;margin&lt;/code&gt;属性值有&lt;code&gt;4&lt;/code&gt;个，接下来我们就一一试试看看会有什么效果呢。&lt;/li&gt;
&lt;li&gt;我们给&lt;code&gt;margin&lt;/code&gt;属性设置&lt;code&gt;1&lt;/code&gt;个值实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
     .box {
     /*这里的宽度指的就是盒子内容的宽度*/
     width: 100px;
     /*这里的高度值的就是盒子内容的高度*/
     height: 100px;
     background-color: red;
     margin: 20px;
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212701677-1118842935.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：假设我们给&lt;code&gt;margin&lt;/code&gt;属性值设置了&lt;code&gt;1&lt;/code&gt;个值为： &lt;code&gt;margin: 20px;&lt;/code&gt;表示&lt;code&gt;上&lt;/code&gt;、&lt;code&gt;右&lt;/code&gt;、&lt;code&gt;下&lt;/code&gt;、&lt;code&gt;左&lt;/code&gt;、方向的外边距都为&lt;code&gt;20px&lt;/code&gt;像素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;我们给&lt;code&gt;margin&lt;/code&gt;属性设置&lt;code&gt;2&lt;/code&gt;个值实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
     .box {
     /*这里的宽度指的就是盒子内容的宽度*/
     width: 100px;
     /*这里的高度值的就是盒子内容的高度*/
     height: 100px;
     background-color: red;
     margin: 20px 30px;
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212726539-1346380429.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：假设我们&lt;code&gt;margin&lt;/code&gt;属性值设置了&lt;code&gt;2&lt;/code&gt;个值如：&lt;code&gt;margin: 20px 30px;&lt;/code&gt;表示外边距的&lt;code&gt;（上、下）&lt;/code&gt;为&lt;code&gt;20px&lt;/code&gt;像素、&lt;code&gt;（左、右）&lt;/code&gt;为&lt;code&gt;30px&lt;/code&gt;像素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;我们给&lt;code&gt;margin&lt;/code&gt;属性设置&lt;code&gt;3&lt;/code&gt;个值实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
     .box {
     /*这里的宽度指的就是盒子内容的宽度*/
     width: 100px;
     /*这里的高度值的就是盒子内容的高度*/
     height: 100px;
     background-color: red;
     margin: 20px 30px 40px;
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212750361-59650660.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：假设我们给&lt;code&gt;margin&lt;/code&gt;属性值设置了&lt;code&gt;3&lt;/code&gt;个值如：&lt;code&gt;margin: 20px 30px 40px;&lt;/code&gt;表示外边距的&lt;code&gt;上&lt;/code&gt;为&lt;code&gt;20px&lt;/code&gt;像素、&lt;code&gt;（左、右&lt;/code&gt;）为&lt;code&gt;30px&lt;/code&gt;像素、&lt;code&gt;下&lt;/code&gt;为&lt;code&gt;40px&lt;/code&gt;像素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;我们给&lt;code&gt;margin&lt;/code&gt;属性设置&lt;code&gt;4&lt;/code&gt;个值实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
     .box {
     /*这里的宽度指的就是盒子内容的宽度*/
     width: 100px;
     /*这里的高度值的就是盒子内容的高度*/
     height: 100px;
     background-color: red;
     margin: 20px 30px 40px 50px;
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212811014-231222104.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：假设我们给&lt;code&gt;margin&lt;/code&gt;属性值设置了&lt;code&gt;4&lt;/code&gt;个值如&lt;code&gt;margin: 20px 30px 40px 50px;&lt;/code&gt;表示外边距的&lt;code&gt;上&lt;/code&gt;为&lt;code&gt;20px&lt;/code&gt;像素、&lt;code&gt;右&lt;/code&gt;为&lt;code&gt;30px&lt;/code&gt;像素、&lt;code&gt;下&lt;/code&gt;为&lt;code&gt;40px&lt;/code&gt;像素、&lt;code&gt;左&lt;/code&gt;为&lt;code&gt;50px&lt;/code&gt;像素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;margin属性居中介绍&quot;&gt;margin属性居中介绍&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;margin&lt;/code&gt;属性值设置为&lt;code&gt;auto&lt;/code&gt;，&lt;code&gt;auto&lt;/code&gt;表示自动的意思，当左外边距与右外边距的值都是&lt;code&gt;auto&lt;/code&gt;时那么这个盒子就会水平居中。&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;margin&lt;/code&gt;属性设置水平居中注意事项如：&lt;/li&gt;
&lt;li&gt;1、一定要给盒子设置固定的宽高度。&lt;/li&gt;
&lt;li&gt;2、只有块级元素才可以实现水平居中，行内元素不能够实现水平居中。&lt;/li&gt;
&lt;li&gt;3、只有标准文档流中的盒子才可以使用&lt;code&gt;margin&lt;/code&gt;属性来实现水平居中。&lt;/li&gt;
&lt;li&gt;4、&lt;code&gt;margin&lt;/code&gt;属性是用来实现盒子的水平居中，而不是文本的水平居中。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;margin属性值为auto实践&quot;&gt;margin属性值为auto实践&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;我们将使用&lt;code&gt;margin&lt;/code&gt;属性值为&lt;code&gt;auto&lt;/code&gt;实现盒子水平线左居中的实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    
     .box{
        width: 100px;
        height: 100px;
        background-color: red;
         margin-left:auto;
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;box&quot;&amp;gt;
   &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212835254-1407353341.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们将使用&lt;code&gt;margin&lt;/code&gt;属性值为&lt;code&gt;auto&lt;/code&gt;实现盒子水平线居中的实践。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    
     .box{
        width: 100px;
        height: 100px;
        background-color: red;
        margin-left:auto;
        margin-right: auto;
     
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;box&quot;&amp;gt;
   &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212855818-414984774.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：&lt;code&gt;margin&lt;/code&gt;属性值为&lt;code&gt;auto&lt;/code&gt;设置&lt;code&gt;上下&lt;/code&gt;外边距不起任何作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    
     .box{
        width: 100px;
        height: 100px;
        background-color: red;
        margin-bottom:auto;
        margin-top: auto;
     
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;box&quot;&amp;gt;
   &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212921309-1512906552.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;注意事项一&quot;&gt;注意事项一&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;用实践来证明为什么：一定要给盒子设置固定的宽高度。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    
     .box{
   
        height: 100px;
        background-color: red;
        margin-left: auto;
        margin-right: auto;
     
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;box&quot;&amp;gt;
   &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205212943128-819835716.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    
     .box{
        width: 100px;
        height: 100px;
        background-color: red;
        margin-left: auto;
        margin-right: auto;
     
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
   &amp;lt;span class=&quot;box&quot;&amp;gt;微笑是最初的信仰
   &amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205213004256-1380708043.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：因为行内元素不能设置宽度，所以无法实现水平线居中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;注意事项三&quot;&gt;注意事项三&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    
     .box{
        width: 100px;
        height: 100px;
        background-color: red;
        margin-left: auto;
        margin-right: auto;
        float: left;
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205213025424-1472754860.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：笔者给&lt;code&gt;class&lt;/code&gt;属性值为&lt;code&gt;.box&lt;/code&gt;设置了一个&lt;code&gt;float: left;&lt;/code&gt;左浮动，浮动的元素已经脱离了标准文档流，所以无法实现水平线居中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;注意事项四&quot;&gt;注意事项四&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    
     .box{
        width: 200px;
        height: 100px;
        background-color: red;
        margin-left: auto;
        margin-right: auto;
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;box&quot;&amp;gt;
     微笑是最初的信仰
   &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205213046268-250577977.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;注意事项五&quot;&gt;注意事项五&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;如果想让文本居中怎么办呢，使用&lt;code&gt;text-align&lt;/code&gt;属性并且属性值为&lt;code&gt;center&lt;/code&gt;才可以实现文本水平线居中。&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;盒子模型&amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    
     .box{
        width: 200px;
        height: 100px;
        background-color: red;
        margin-left: auto;
        margin-right: auto;
        text-align: center;
     }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
   &amp;lt;div class=&quot;box&quot;&amp;gt;
     微笑是最初的信仰
   &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1781381/201912/1781381-20191205213105146-606473886.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Dec 2019 14:12:00 +0000</pubDate>
<dc:creator>微笑是最初的信仰</dc:creator>
<og:description>CSS中盒子模型介绍 什么是盒子？ 盒子是用来存储物品，我们可以将盒子理解为酒盒，酒盒有什么组成的呢？ 有酒可以喝、有填充物保护酒防止酒被摔坏、纸盒子。 我们怎么理解 中的盒子呢， 中盒子有什么组成的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lq0001/p/11992092.html</dc:identifier>
</item>
<item>
<title>EFK教程(4) - ElasticSearch集群TLS加密通讯 - 小慢哥</title>
<link>http://www.cnblogs.com/fzxiaomange/p/efk-tls.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fzxiaomange/p/efk-tls.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://fzxiaomange.com/img/efk/tls-cover.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于TLS实现ElasticSearch集群加密通讯&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;strong&gt;“发颠的小狼”&lt;/strong&gt;，欢迎转载&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;▪ 用途&lt;br/&gt;▪ ES节点信息&lt;br/&gt;▪ Step1. 关闭服务&lt;br/&gt;▪ Step2. 创建CA证书&lt;br/&gt;▪ Step3. 创建CERT证书&lt;br/&gt;▪ Step4. 创建密钥库&lt;br/&gt;▪ Step5. 删除CA证书&lt;br/&gt;▪ Step6. 修改elasticsearch.yml配置&lt;br/&gt;▪ Step7. 启动服务&lt;br/&gt;▪ 附. 参考文档&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;前情提要：&lt;/p&gt;
&lt;p&gt;▷ 在第一篇《EFK教程 - 快速入门指南》中，阐述了EFK的安装部署，其中ElasticSearch的架构为三节点，即master、ingest、data角色同时部署在三台服务器上。&lt;br/&gt;▷ 在第二篇《EFK教程 - ElasticSearch高性能高可用架构》中，阐述了EFK的data/ingest/master角色的用途及分别部署三节点，在实现性能最大化的同时保障高可用。&lt;br/&gt;▷ 在第三篇《EFK教程(3) - ElasticSearch冷热数据分离》中，阐述了ES多实例部署，将不同热度的数据存在不同的磁盘上，实现了数据冷热分离、资源合理分配。&lt;/p&gt;
&lt;p&gt;前三篇文章，ES集群之间数据交互都是明文交互，而在本文中，为ES集群创建CA、CERT证书，实现ElasticSearch集群之间数据通过TLS进行双向加密交互。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;由于本文是基于上一篇文章《EFK教程(3) - ElasticSearch冷热数据分离》为环境进行阐述，因此节点信息和上一篇一致：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://fzxiaomange.com/img/efk/tls-3.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;首先，需要停止所有ElasticSearch、kibana、filebeat服务，待证书配置完成后再启动&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;1️⃣ 找任一一台ElasticSearch节点服务器操作即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /opt/elasticsearch/
# --days: 表示有效期多久
sudo -u elasticsearch ./bin/elasticsearch-certutil ca --days 3660&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2️⃣ 务必将生成的CA证书，传到安全地方永久存储，因为后期若需要新增ES节点，还会用到该证书&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://fzxiaomange.com/img/efk/tls-1.jpeg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://fzxiaomange.com/img/efk/tls-2.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3️⃣ 请将elastic-stack-ca.p12证书传到所有ES实例服务器上&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;按上面表格进入相对应的目录创建CERT证书&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 在ES目录中建立证书目录及给予elasticsearch权限
mkdir -p config/certs;chown elasticsearch.elasticsearch config/certs -R

# 每一个实例一个证书
# --ca CA证书的文件名，必选参数
# --dns 服务器名，多服务器名用逗号隔开，可选参数
# --ip 服务器IP，多IP用逗号隔开，可选参数
# --out 输出到哪里，可选参数
# --days 有效期多久，可选参数
sudo -u elasticsearch ./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12 --ip ${本机IP},127.0.0.1 --out config/certs/cert.p12 --days 3660
# 例如elasticsearch-master-1（192.168.1.31）执行命令：sudo -u elasticsearch ./bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12 --ip 192.168.1.31,127.0.0.1 --out config/certs/cert.p12 --days 3660&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://fzxiaomange.com/img/efk/tls-4.jpeg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://fzxiaomange.com/img/efk/tls-5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想批量生成CERT证书，请自行查阅附录链接，不过批量生成有时会碰到生成的证书不可用，因此建议一台一台生成&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;按上面表格进入相对应的目录创建密钥库&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 每一个实例都要操作
# 创建密钥库
sudo -u elasticsearch ./bin/elasticsearch-keystore create
# PKCS＃12文件的密码
sudo -u elasticsearch ./bin/elasticsearch-keystore add xpack.security.transport.ssl.keystore.secure_password
# 信任库的密码
sudo -u elasticsearch ./bin/elasticsearch-keystore add xpack.security.transport.ssl.truststore.secure_password&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://fzxiaomange.com/img/efk/tls-6.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://fzxiaomange.com/img/efk/tls-7.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://fzxiaomange.com/img/efk/tls-8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确认keystore、truststore已录入至密钥库&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo -u elasticsearch ./bin/elasticsearch-keystore list&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://fzxiaomange.com/img/efk/tls-9.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;由于上面创建的elastic-stack-ca.p12含有私钥，因此为了安全，建议将该文件删除（请务必提前备份好，因为后期增加节点还会用到）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按上面表格进入相对应的目录删除CA证书&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rm -f elastic-stack-ca.p12&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;按上面表格对应的实例配置conf目录下elasticsearch.yml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 在所有实例上加上以下配置
# 开启transport.ssl认证
xpack.security.transport.ssl.enabled: true
# xpack认证方式 full为主机或IP认证及证书认证，certificates为证书认证，不对主机和IP认证，默认为full
xpack.security.transport.ssl.verification_mode: full
# xpack包含私钥和证书的PKCS＃12文件的路径
xpack.security.transport.ssl.keystore.path: certs/cert.p12
# xpack包含要信任的证书的PKCS＃12文件的路径
xpack.security.transport.ssl.truststore.path: certs/cert.p12&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;pre&gt;
&lt;code&gt;# 开启所有ES实例
sudo -u elasticsearch ./bin/elasticsearch

# 开启filebeat
/opt/filebeat/filebeat -e -c /opt/filebeat/filebeat.yml -d &quot;publish&quot;

# 开启kibana
sudo -u kibana /opt/kibana/bin/kibana -c /opt/kibana/config/kibana.yml&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;pre&gt;
&lt;code&gt;https://www.elastic.co/guide/en/elasticsearch/reference/current/configuring-tls.html
https://www.elastic.co/guide/en/elasticsearch/reference/7.3/certutil.html&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 05 Dec 2019 13:49:00 +0000</pubDate>
<dc:creator>小慢哥</dc:creator>
<og:description>基于TLS实现ElasticSearch集群加密通讯</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fzxiaomange/p/efk-tls.html</dc:identifier>
</item>
</channel>
</rss>