<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>40 张图带你搞懂 TCP 和 UDP - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/14059379.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/14059379.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;欢迎阅读「程序员cxuan」 的文章，从今往后，你就是我的读者了。&lt;/p&gt;
&lt;p&gt;我的 github bestJavaer 已经收录此文章，目录在&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/crisxuan/bestJavaer&quot;&gt;https://github.com/crisxuan/bestJavaer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;希望你可以给我一个 star 哦！&lt;/p&gt;
&lt;p&gt;这一篇文章是计算机网络连载文章的第四篇，历史文章请阅读&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/cxuanBlog/p/13952195.html&quot;&gt;一不小心画了 24 张图剖析计网应用层协议！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/cxuanBlog/p/13917812.html&quot;&gt;TCP/IP 基础知识&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/cxuanBlog/p/13844269.html&quot;&gt;计算机网络基础知识总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面开始本篇文章。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;运输层&lt;/code&gt;位于应用层和网络层之间，是 OSI 分层体系中的第四层，同时也是网络体系结构的重要部分。运输层主要负责网络上的端到端通信。&lt;/p&gt;
&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/DwCCes.png&quot;/&gt;&lt;p&gt;运输层为运行在不同主机上的应用程序之间的通信起着至关重要的作用。下面我们就来一起探讨一下关于运输层的协议部分&lt;/p&gt;
&lt;h2 id=&quot;运输层概述&quot;&gt;运输层概述&lt;/h2&gt;
&lt;p&gt;计算机网络的运输层非常类似于高速公路，高速公路负责把人或者物品从一端运送到另一端，而计算机网络的运输层则负责把报文从一端运输到另一端，这个端指的就是 &lt;code&gt;端系统&lt;/code&gt;。在计算机网络中，任意一个可以交换信息的介质都可以称为端系统，比如手机、网络媒体、电脑、运营商等。&lt;/p&gt;
&lt;p&gt;在运输层运输报文的过程中，会遵守一定的协议规范，比如一次传输的数据限制、选择什么样的运输协议等。运输层实现了让两个互不相关的主机进行&lt;code&gt;逻辑通信&lt;/code&gt;的功能，看起来像是让两个主机相连一样。&lt;/p&gt;
&lt;p&gt;运输层协议是在端系统中实现的，而不是在路由器中实现的。路由只是做识别地址并转发的功能。这就比如快递员送快递一样，当然是要由地址的接受人也就是 xxx 号楼 xxx 单元 xxx 室的这个人来判断了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/DwCioq.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;TCP 如何判断是哪个端口的呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还记得数据包的结构吗，这里来回顾一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/DwCAYV.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据包经过每层后，该层协议都会在数据包附上包首部，一个完整的包首部图如上所示。&lt;/p&gt;
&lt;p&gt;在数据传输到运输层后，会为其附上 TCP 首部，首部包含着源端口号和目的端口号。&lt;/p&gt;
&lt;p&gt;在发送端，运输层将从发送应用程序进程接收到的报文转化成运输层&lt;code&gt;分组&lt;/code&gt;，分组在计算机网络中也称为 &lt;code&gt;报文段(segment)&lt;/code&gt;。运输层一般会将报文段进行分割，分割成为较小的块，为每一块加上运输层首部并将其向目的地发送。&lt;/p&gt;
&lt;p&gt;在发送过程中，可选的运输层协议(也就是交通工具) 主要有 &lt;code&gt;TCP&lt;/code&gt; 和 &lt;code&gt;UDP&lt;/code&gt; ，关于这两种运输协议的选择及其特性也是我们着重探讨的重点。&lt;/p&gt;
&lt;h2 id=&quot;tcp-和-udp-前置知识&quot;&gt;TCP 和 UDP 前置知识&lt;/h2&gt;
&lt;p&gt;在 TCP/IP 协议中能够实现传输层功能的，最具代表性的就是 TCP 和 UDP。提起 TCP 和 UDP ，就得先从这两个协议的定义说起。&lt;/p&gt;
&lt;p&gt;TCP 叫做&lt;code&gt;传输控制协议(TCP，Transmission Control Protocol)&lt;/code&gt;，通过名称可以大致知道 TCP 协议有控制传输的功能，主要体现在其可控，可控就表示着可靠，确实是这样的，TCP 为应用层提供了一种&lt;strong&gt;可靠的、面向连接&lt;/strong&gt;的服务，它能够将分组可靠的传输到服务端。&lt;/p&gt;
&lt;p&gt;UDP 叫做 &lt;code&gt;用户数据报协议(UDP，User Datagram Protocol)&lt;/code&gt;，通过名称可以知道 UDP 把重点放在了数据报上，它为应用层提供了一种无需建立连接就可以直接发送数据报的方法。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;怎么计算机网络中的术语对一个数据的描述这么多啊？&lt;/p&gt;
&lt;p&gt;在计算机网络中，在不同层之间会有不同的描述。我们上面提到会将运输层的分组称为报文段，除此之外，还会将 TCP 中的分组也称为报文段，然而将 UDP 的分组称为数据报，同时也将网络层的分组称为数据报&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/DwCpLj.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是为了统一，一般在计算机网络中我们统一称 TCP 和 UDP 的报文为 &lt;code&gt;报文段&lt;/code&gt;，这个就相当于是约定，到底如何称呼不用过多纠结啦。&lt;/p&gt;
&lt;h3 id=&quot;套接字&quot;&gt;套接字&lt;/h3&gt;
&lt;p&gt;在 TCP 或者 UDP 发送具体的报文信息前，需要先经过一扇 &lt;code&gt;门&lt;/code&gt;，这个门就是&lt;code&gt;套接字(socket)&lt;/code&gt;，套接字向上连接着应用层，向下连接着网络层。在操作系统中，操作系统分别为应用和硬件提供了&lt;code&gt;接口(Application Programming Interface)&lt;/code&gt;。而在计算机网络中，套接字同样是一种接口，它也是有接口 API 的。&lt;/p&gt;
&lt;p&gt;使用 TCP 或 UDP 通信时，会广泛用到套接字的 API，使用这套 API 设置 IP 地址、端口号，实现数据的发送和接收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/DwCPwn.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们知道了， Socket 和 TCP/IP 没有必然联系，Socket 的出现只是方便了 TCP/IP 的使用，如何方便使用呢？你可以直接使用下面 Socket API 的这些方法。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;create()&lt;/td&gt;
&lt;td&gt;创建一个 socket&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bind()&lt;/td&gt;
&lt;td&gt;套接字标识，一般用于绑定端口号&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;listen()&lt;/td&gt;
&lt;td&gt;准备接收连接&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;connect()&lt;/td&gt;
&lt;td&gt;准备充当发送者&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;accept()&lt;/td&gt;
&lt;td&gt;准备作为接收者&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;write()&lt;/td&gt;
&lt;td&gt;发送数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;read()&lt;/td&gt;
&lt;td&gt;接收数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;close()&lt;/td&gt;
&lt;td&gt;关闭连接&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;套接字类型&quot;&gt;套接字类型&lt;/h4&gt;
&lt;p&gt;套接字的主要类型有三种，下面我们分别介绍一下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;数据报套接字(Datagram sockets)&lt;/code&gt;：数据报套接字提供一种&lt;code&gt;无连接&lt;/code&gt;的服务，而且并不能保证数据传输的可靠性。数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。数据报套接字使用&lt;code&gt;UDP( User DatagramProtocol)协议&lt;/code&gt;进行数据的传输。由于数据报套接字不能保证数据传输的可靠性，对于有可能出现的数据丢失情况，需要在程序中做相应的处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;流套接字(Stream sockets)&lt;/code&gt;：流套接字用于提供面向连接、可靠的数据传输服务。能够保证数据的可靠性、顺序性。流套接字之所以能够实现可靠的数据服务，原因在于其使用了传输控制协议，即 &lt;code&gt;TCP(The Transmission Control Protocol)协议&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;原始套接字(Raw sockets)&lt;/code&gt;: 原始套接字允许直接发送和接收 IP 数据包，而无需任何特定于协议的传输层格式，原始套接字可以读写内核没有处理过的 IP 数据包。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;套接字处理过程&quot;&gt;套接字处理过程&lt;/h4&gt;
&lt;p&gt;在计算机网络中，要想实现通信，必须至少需要两个端系统，至少需要一对两个套接字才行。下面是套接字的通信过程。&lt;/p&gt;
&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/DwCkF0.png&quot;/&gt;&lt;ol&gt;&lt;li&gt;socket 中的 API 用于创建通信链路中的端点，创建完成后，会返回描述该套接字的&lt;code&gt;套接字描述符&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;就像使用文件描述符来访问文件一样，套接字描述符用来访问套接字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;当应用程序具有套接字描述符后，它可以将唯一的名称绑定在套接字上，服务器必须绑定一个名称才能在网络中访问&lt;/li&gt;
&lt;li&gt;在为服务端分配了 socket 并且将名称使用 bind 绑定到套接字上后，将会调用 listen api。&lt;code&gt;listen&lt;/code&gt; 表示客户端愿意等待连接的意愿，listen 必须在 accept api 之前调用。&lt;/li&gt;
&lt;li&gt;客户端应用程序在流套接字(基于 TCP)上调用 &lt;code&gt;connect&lt;/code&gt; 发起与服务器的连接请求。&lt;/li&gt;
&lt;li&gt;服务器应用程序使用&lt;code&gt;accept&lt;/code&gt;API 接受客户端连接请求，服务器必须先成功调用 bind 和 listen 后，再调用 accept api。&lt;/li&gt;
&lt;li&gt;在流套接字之间建立连接后，客户端和服务器就可以发起 read/write api 调用了。&lt;/li&gt;
&lt;li&gt;当服务器或客户端要停止操作时，就会调用 &lt;code&gt;close&lt;/code&gt; API 释放套接字获取的所有系统资源。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;虽然套接字 API 位于应用程序层和传输层之间的通信模型中，但是套接字 API 不属于通信模型。套接字 API 允许应用程序与传输层和网络层进行交互。&lt;/p&gt;
&lt;p&gt;在往下继续聊之前，我们先播放一个小插曲，简单聊一聊 IP。&lt;/p&gt;
&lt;h3 id=&quot;聊聊-ip&quot;&gt;聊聊 IP&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;IP&lt;/code&gt; 是&lt;code&gt;Internet Protocol（网际互连协议）&lt;/code&gt;的缩写，是 TCP/IP 体系中的&lt;code&gt;网络层&lt;/code&gt;协议。设计 IP 的初衷主要想解决两类问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提高网络扩展性：实现大规模网络互联&lt;/li&gt;
&lt;li&gt;对应用层和链路层进行解藕，让二者独立发展。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;IP 是整个 TCP/IP 协议族的核心，也是构成互联网的基础。为了实现大规模网络的互通互联，IP 更加注重适应性、简洁性和可操作性，并在可靠性做了一定的牺牲。IP 不保证分组的&lt;strong&gt;交付时限和可靠性&lt;/strong&gt;，所传送分组有可能出现&lt;strong&gt;丢失、重复、延迟或乱序&lt;/strong&gt;等问题。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们知道，TCP 协议的下一层就是 IP 协议层，既然 IP 不可靠，那么如何保证数据能够准确无误地到达呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就涉及到 TCP 传输机制的问题了，我们后面聊到 TCP 的时候再说。&lt;/p&gt;
&lt;h3 id=&quot;端口号&quot;&gt;端口号&lt;/h3&gt;
&lt;p&gt;在聊端口号前，先来聊一聊文件描述以及 socket 和端口号的关系&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;为了方便资源的使用，提高机器的性能、利用率和稳定性等等原因，我们的计算机都有一层软件叫做操作系统，它用于帮我们管理计算机可以使用的资源，当我们的程序要使用一个资源的时候，可以向操作系统申请，再由操作系统为我们的程序分配和管理资源。通常当我们要访问一个内核设备或文件时，程序可以调用系统函数，系统就会为我们打开设备或文件，然后返回一个文件描述符fd（或称为ID，是一个整数），我们要访问该设备或文件，只能通过该文件描述符。可以认为该编号对应着打开的文件或设备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而当我们的程序要使用网络时，要使用到对应的操作系统内核的操作和网卡设备，所以我们可以向操作系统申请，然后系统会为我们创建一个套接字 Socket，并返回这个 Socket 的ID，以后我们的程序要使用网络资源，只要向这个 Socket 的编号 ID 操作即可。而我们的每一个网络通信的进程至少对应着一个 Socket。向 Socket 的 ID 中写数据，相当于向网络发送数据，向 Socket 中读数据，相当于接收数据。而且这些套接字都有唯一标识符——文件描述符 fd。&lt;/p&gt;
&lt;p&gt;端口号是 &lt;code&gt;16&lt;/code&gt; 位的非负整数，它的范围是 0 - 65535 之间，这个范围会分为三种不同的端口号段，由 Internet 号码分配机构 IANA 进行分配&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;周知/标准端口号，它的范围是 0 - 1023&lt;/li&gt;
&lt;li&gt;注册端口号，范围是 1024 - 49151&lt;/li&gt;
&lt;li&gt;私有端口号，范围是 49152 - 6553&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一台计算机上可以运行多个应用程序，当一个报文段到达主机后，应该传输给哪个应用程序呢？你怎么知道这个报文段就是传递给 HTTP 服务器而不是 SSH 服务器的呢？&lt;/p&gt;
&lt;p&gt;是凭借端口号吗？当报文到达服务器时，是端口号来区分不同应用程序的，所以应该借助端口号来区分。&lt;/p&gt;
&lt;p&gt;举个例子反驳一下 cxuan，假如到达服务器的两条数据都是由 80 端口发出的你该如何区分呢？或者说到达服务器的两条数据端口一样，协议不同，该如何区分呢？&lt;/p&gt;
&lt;p&gt;所以仅凭端口号来确定某一条报文显然是不够的。&lt;/p&gt;
&lt;p&gt;互联网上一般使用 &lt;strong&gt;源 IP 地址、目标 IP 地址、源端口号、目标端口号&lt;/strong&gt; 来进行区分。如果其中的某一项不同，就被认为是不同的报文段。这些也是&lt;code&gt;多路分解和多路复用&lt;/code&gt; 的基础。&lt;/p&gt;
&lt;h4 id=&quot;确定端口号&quot;&gt;确定端口号&lt;/h4&gt;
&lt;p&gt;在实际通信之前，需要先确定一下端口号，确定端口号的方法分为两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标准既定的端口号&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;标准既定的端口号是静态分配的，每个程序都会有自己的端口号，每个端口号都有不同的用途。端口号是一个 16 比特的数，其大小在 0 - 65535 之间，0 - 1023 范围内的端口号都是动态分配的既定端口号，例如 HTTP 使用 80 端口来标识，FTP 使用 21 端口来标识，SSH 使用 22 来标识。这类端口号有一个特殊的名字，叫做 &lt;code&gt;周知端口号(Well-Known Port Number)&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时序分配的端口号&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第二种分配端口号的方式是一种动态分配法，在这种方法下，客户端应用程序可以完全不用自己设置端口号，凭借操作系统进行分配，操作系统可以为每个应用程序分配互不冲突的端口号。这种动态分配端口号的机制即使是同一个客户端发起的 TCP 连接，也能识别不同的连接。&lt;/p&gt;
&lt;h3 id=&quot;多路复用和多路分解&quot;&gt;多路复用和多路分解&lt;/h3&gt;
&lt;p&gt;我们上面聊到了在主机上的每个套接字都会分配一个端口号，当报文段到达主机时，运输层会检查报文段中的目的端口号，并将其定向到相应的套接字，然后报文段中的数据通过套接字进入其所连接的进程。下面我们来聊一下什么是多路复用和多路分解的概念。&lt;/p&gt;
&lt;p&gt;多路复用和多路分解分为两种，即&lt;code&gt;无连接&lt;/code&gt;的多路复用(多路分解)和&lt;code&gt;面向连接&lt;/code&gt;的多路复用(多路分解)&lt;/p&gt;
&lt;h4 id=&quot;无连接的多路复用和多路分解&quot;&gt;无连接的多路复用和多路分解&lt;/h4&gt;
&lt;p&gt;开发人员会编写代码确定端口号是周知端口号还是时序分配的端口号。假如主机 A 中的一个 10637 端口要向主机 B 中的 45438 端口发送数据，运输层采用的是 &lt;code&gt;UDP&lt;/code&gt; 协议，数据在应用层产生后，会在运输层中加工处理，然后在网络层将数据封装得到 IP 数据报，IP 数据包通过链路层尽力而为的交付给主机 B，然后主机 B 会检查报文段中的端口号判断是哪个套接字的，这一系列的过程如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/DwCnOJ.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;UDP 套接字就是一个二元组，二元组包含目的 IP 地址和目的端口号。&lt;/p&gt;
&lt;p&gt;所以，如果两个 UDP 报文段有不同的源 IP 地址和/或相同的源端口号，但是具有相同的目的 IP 地址和目的端口号，那么这两个报文会通过套接字定位到相同的目的进程。&lt;/p&gt;
&lt;p&gt;这里思考一个问题，主机 A 给主机 B 发送一个消息，为什么还需要知道源端口号呢？比如我给妹子表达出我对你有点意思的信息，妹子还需要知道这个信息是从我的哪个器官发出的吗？知道是我这个人对你有点意思不就完了？实际上是需要的，因为妹子如果要表达出她对你也有点意思，她是不是可能会亲你一口，那她得知道往哪亲吧？&lt;/p&gt;
&lt;p&gt;这就是，在 A 到 B 的报文段中，源端口号会作为 &lt;code&gt;返回地址&lt;/code&gt; 的一部分，即当 B 需要回发一个报文段给 A 时，B 需要从 A 到 B 中的源端口号取值，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/DwCZSU.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;面向连接的多路复用与多路分解&quot;&gt;面向连接的多路复用与多路分解&lt;/h4&gt;
&lt;p&gt;如果说无连接的多路复用和多路分解指的是 UDP 的话，那么面向连接的多路复用与多路分解指的是 TCP 了，TCP 和 UDP 在报文结构上的差别是，UDP 是一个二元组而 TCP 是一个四元组，即&lt;strong&gt;源 IP 地址、目标 IP 地址、源端口号、目标端口号&lt;/strong&gt; ，这个我们上面也提到了。当一个 TCP 报文段从网络到达一台主机时，这个主机会根据这四个值拆解到对应的套接字上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/DwCKm9.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图显示了面向连接的多路复用和多路分解的过程，图中主机 C 向主机 B 发起了两个 HTTP 请求，主机 A 向主机 C 发起了一个 HTTP 请求，主机 A、B、C 都有自己唯一的 IP 地址，当主机 C 发出 HTTP 请求后，主机 B 能够分解这两个 HTTP 连接，因为主机 C 发出请求的两个源端口号不同，所以对于主机 B 来说，这是两条请求，主机 B 能够进行分解。对于主机 A 和主机 C 来说，这两个主机有不同的 IP 地址，所以对于主机 B 来说，也能够进行分解。&lt;/p&gt;
&lt;h2 id=&quot;udp&quot;&gt;UDP&lt;/h2&gt;
&lt;p&gt;终于，我们开始了对 UDP 协议的探讨，淦起！&lt;/p&gt;
&lt;p&gt;UDP 的全称是 &lt;code&gt;用户数据报协议(UDP，User Datagram Protocol)&lt;/code&gt;，UDP 为应用程序提供了一种&lt;code&gt;无需建立连接&lt;/code&gt;就可以发送封装的 IP 数据包的方法。如果应用程序开发人员选择的是 UDP 而不是 TCP 的话，那么该应用程序相当于就是和 IP 直接打交道的。&lt;/p&gt;
&lt;p&gt;从应用程序传递过来的数据，会附加上多路复用/多路分解的源和目的端口号字段，以及其他字段，然后将形成的报文传递给网络层，网络层将运输层报文段封装到 IP 数据报中，然后尽力而为的交付给目标主机。最关键的一点就是，使用 UDP 协议在将数据报传递给目标主机时，发送方和接收方的运输层实体间是没有&lt;code&gt;握手&lt;/code&gt;的。正因为如此，UDP 被称为是&lt;code&gt;无连接&lt;/code&gt;的协议。&lt;/p&gt;
&lt;h3 id=&quot;udp-特点&quot;&gt;UDP 特点&lt;/h3&gt;
&lt;p&gt;UDP 协议一般作为流媒体应用、语音交流、视频会议所使用的传输层协议，我们大家都知道的 DNS 协议底层也使用了 UDP 协议，这些应用或协议之所以选择 UDP 主要是因为以下这几点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;速度快&lt;/code&gt;，采用 UDP 协议时，只要应用进程将数据传给 UDP，UDP 就会将此数据打包进 UDP 报文段并立刻传递给网络层，然后 TCP 有拥塞控制的功能，它会在发送前判断互联网的拥堵情况，如果互联网极度阻塞，那么就会抑制 TCP 的发送方。使用 UDP 的目的就是希望实时性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;无须建立连接&lt;/code&gt;，TCP 在数据传输之前需要经过三次握手的操作，而 UDP 则无须任何准备即可进行数据传输。因此 UDP 没有建立连接的时延。如果使用 TCP 和 UDP 来比喻开发人员：TCP 就是那种凡事都要设计好，没设计不会进行开发的工程师，需要把一切因素考虑在内后再开干！所以非常&lt;code&gt;靠谱&lt;/code&gt;；而 UDP 就是那种上来直接干干干，接到项目需求马上就开干，也不管设计，也不管技术选型，就是干，这种开发人员非常&lt;code&gt;不靠谱&lt;/code&gt;，但是适合快速迭代开发，因为可以马上上手！&lt;/li&gt;
&lt;li&gt;&lt;code&gt;无连接状态&lt;/code&gt;，TCP 需要在端系统中维护&lt;code&gt;连接状态&lt;/code&gt;，连接状态包括接收和发送缓存、拥塞控制参数以及序号和确认号的参数，在 UDP 中没有这些参数，也没有发送缓存和接受缓存。因此，某些专门用于某种特定应用的服务器当应用程序运行在 UDP 上，一般能支持更多的活跃用户&lt;/li&gt;
&lt;li&gt;&lt;code&gt;分组首部开销小&lt;/code&gt;，每个 TCP 报文段都有 20 字节的首部开销，而 UDP 仅仅只有 8 字节的开销。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里需要注意一点，并不是所有使用 UDP 协议的应用层都是&lt;code&gt;不可靠&lt;/code&gt;的，应用程序可以自己实现可靠的数据传输，通过增加确认和重传机制。所以使用 UDP 协议最大的特点就是速度快。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;udp-报文结构&quot;&gt;UDP 报文结构&lt;/h3&gt;
&lt;p&gt;下面来一起看一下 UDP 的报文结构，每个 UDP 报文分为 UDP 报头和 UDP 数据区两部分。报头由 4 个 16 位长（2 字节）字段组成，分别说明该报文的源端口、目的端口、报文长度和校验值。&lt;/p&gt;
&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/DwCEWT.png&quot;/&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;源端口号(Source Port)&lt;/code&gt; :这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口。接收端的应用程序利用这个字段的值作为发送响应的目的地址。这个字段是可选项，有时不会设置源端口号。没有源端口号就默认为 0 ，通常用于不需要返回消息的通信中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;目标端口号(Destination Port)&lt;/code&gt;: 表示接收端端口，字段长为 16 位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;长度(Length)&lt;/code&gt;: 该字段占据 16 位，表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度。因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8，最大长度为 65535 字节。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;校验和(Checksum)&lt;/code&gt;：UDP 使用校验和来保证数据安全性，UDP 的校验和也提供了差错检测功能，差错检测用于校验报文段从源到目标主机的过程中，数据的完整性是否发生了改变。发送方的 UDP 对报文段中的 16 比特字的和进行反码运算，求和时遇到的位溢出都会被忽略，比如下面这个例子，三个 16 比特的数字进行相加&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/DwCelF.png&quot;/&gt;&lt;p&gt;​ 这些 16 比特的前两个和是&lt;/p&gt;
&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/DwCmy4.png&quot;/&gt;&lt;p&gt;​ 然后再将上面的结果和第三个 16 比特的数进行相加&lt;/p&gt;
&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/DwCMwR.png&quot;/&gt;&lt;p&gt;最后一次相加的位会进行溢出，溢出位 1 要被舍弃，然后进行反码运算，反码运算就是将所有的 1 变为 0 ，0 变为 1。因此 &lt;strong&gt;1000 0100 1001 0101&lt;/strong&gt; 的反码就是 &lt;strong&gt;0111 1011 0110 1010&lt;/strong&gt;，这就是校验和，如果在接收方，数据没有出现差错，那么全部的 4 个 16 比特的数值进行运算，同时也包括校验和，如果最后结果的值不是 1111 1111 1111 1111 的话，那么就表示传输过程中的数据出现了差错。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;下面来想一个问题，为什么 UDP 会提供差错检测的功能？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这其实是一种 &lt;code&gt;端到端&lt;/code&gt; 的设计原则，这个原则说的是&lt;strong&gt;要让传输中各种错误发生的概率降低到一个可以接受的水平&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;文件从主机&lt;em&gt;A&lt;/em&gt;传到主机&lt;em&gt;B&lt;/em&gt;，也就是说&lt;em&gt;AB&lt;/em&gt;主机要通信，需要经过三个环节：首先是主机&lt;em&gt;A&lt;/em&gt;从磁盘上读取文件并将数据分组成一个个数据包&lt;em&gt;packet,&lt;/em&gt;，然后数据包通过连接主机&lt;em&gt;A&lt;/em&gt;和主机&lt;em&gt;B&lt;/em&gt;的网络传输到主机&lt;em&gt;B&lt;/em&gt;，最后是主机&lt;em&gt;B&lt;/em&gt;收到数据包并将数据包写入磁盘。在这个看似简单其实很复杂的过程中可能会由于某些原因而影响正常通信。比如：磁盘上文件读写错误、缓冲溢出、内存出错、网络拥挤等等这些因素都有可能导致数据包的出错或者丢失，由此可见用于通信的网络是不可靠的。&lt;/p&gt;
&lt;p&gt;由于实现通信只要经过上述三个环节，那么我们就想是否在其中某个环节上增加一个检错纠错机制来用于对信息进行把关呢？&lt;/p&gt;
&lt;p&gt;网络层肯定不能做这件事，因为网络层的最主要目的是增大数据传输的速率，网络层不需要考虑数据的完整性，数据的完整性和正确性交给端系统去检测就行了，因此在数据传输中，对于网络层只能要求其提供尽可能好的数据传输服务，而不可能寄希望于网络层提供数据完整性的服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UDP 不可靠的原因是它虽然提供差错检测的功能，但是&lt;strong&gt;对于差错没有恢复能力更不会有重传机制&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;tcp&quot;&gt;TCP&lt;/h2&gt;
&lt;p&gt;UDP 是一种没有复杂的控制，提供无连接通信服务的一种协议，换句话说，它将部分控制部分交给应用程序去处理，自己只提供作为传输层协议最基本的功能。&lt;/p&gt;
&lt;p&gt;而与 UDP 不同的是，同样作为传输层协议，TCP 协议要比 UDP 的功能多很多。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt; 的全称是 &lt;code&gt;Transmission Control Protocol&lt;/code&gt;，它被称为是一种&lt;code&gt;面向连接(connection-oriented)&lt;/code&gt; 的协议，这是因为一个应用程序开始向另一个应用程序发送数据之前，这两个进程必须先进行&lt;code&gt;握手&lt;/code&gt;，握手是一个逻辑连接，并不是两个主机之间进行真实的握手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcMzAH.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个连接是指各种设备、线路或者网络中进行通信的两个应用程序为了相互传递消息而专有的、虚拟的通信链路，也叫做虚拟电路。&lt;/p&gt;
&lt;p&gt;一旦主机 A 和主机 B 建立了连接，那么进行通信的应用程序只使用这个虚拟的通信线路发送和接收数据就可以保证数据的传输，TCP 协议负责控制连接的建立、断开、保持等工作。&lt;/p&gt;
&lt;p&gt;TCP 连接是&lt;code&gt;全双工服务(full-duplex service)&lt;/code&gt; 的，全双工是什么意思？全双工指的是主机 A 与另外一个主机 B 存在一条 TCP 连接，那么应用程数据就可以从主机 B 流向主机 A 的同时，也从主机 A 流向主机 B。&lt;/p&gt;
&lt;p&gt;TCP 只能进行 &lt;code&gt;点对点(point-to-point)&lt;/code&gt; 连接，那么所谓的&lt;code&gt;多播&lt;/code&gt;，即一个主机对多个接收方发送消息的情况是不存在的，TCP 连接只能连接两个一对主机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQSNd.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TCP 的连接建立需要经过三次握手，这个我们下面再说。一旦 TCP 连接建立后，主机之间就可以相互发送数据了，客户进程通过套接字传送数据流。数据一旦通过套接字后，它就由客户中运行的 TCP 协议所控制。&lt;/p&gt;
&lt;p&gt;TCP 会将数据临时存储到连接的&lt;code&gt;发送缓存(send buffer)&lt;/code&gt; 中，这个 send buffer 是三次握手之间设置的缓存之一，然后 TCP 在合适的时间将发送缓存中的数据发送到目标主机的接收缓存中，实际上，每一端都会有发送缓存和接收缓存，如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQP3t.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主机之间的发送是以 &lt;code&gt;报文段(segment)&lt;/code&gt; 进行的，那么什么是 Segement 呢？&lt;/p&gt;
&lt;p&gt;TCP 会将要传输的数据流分为多个&lt;code&gt;块(chunk)&lt;/code&gt;，然后向每个 chunk 中添加 TCP 标头，这样就形成了一个 TCP 段也就是报文段。每一个报文段可以传输的长度是有限的，不能超过&lt;code&gt;最大数据长度(Maximum Segment Size)&lt;/code&gt;，俗称 &lt;code&gt;MSS&lt;/code&gt;。在报文段向下传输的过程中，会经过链路层，链路层有一个 &lt;code&gt;Maximum Transmission Unit&lt;/code&gt; ，最大传输单元 MTU， 即数据链路层上所能通过最大数据包的大小，最大传输单元通常与通信接口有关。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么 MSS 和 MTU 有啥关系呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为计算机网络是分层考虑的，这个很重要，不同层的称呼不一样，对于传输层来说，称为报文段而对网络层来说就叫做 IP 数据包，所以，&lt;strong&gt;MTU 可以认为是网络层能够传输的最大 IP 数据包，而 MSS（Maximum segment size）可以认为是传输层的概念，也就是 TCP 数据包每次能够传输的最大量&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;tcp-报文段结构&quot;&gt;TCP 报文段结构&lt;/h3&gt;
&lt;p&gt;在简单聊了聊 TCP 连接后，下面我们就来聊一下 TCP 的报文段结构，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQC9I.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TCP 报文段结构相比 UDP 报文结构多了很多内容。但是前两个 32 比特的字段是一样的。它们是 &lt;code&gt;源端口号&lt;/code&gt; 和 &lt;code&gt;目标端口号&lt;/code&gt;，我们知道，这两个字段是用于多路复用和多路分解的。另外，和 UDP 一样，TCP 也包含&lt;code&gt;校验和(checksum field)&lt;/code&gt; ，除此之外，TCP 报文段首部还有下面这些&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;32 比特的&lt;code&gt;序号字段(sequence number field)&lt;/code&gt; 和 32 比特的&lt;code&gt;确认号字段(acknowledgment number field)&lt;/code&gt; 。这些字段被 TCP 发送方和接收方用来实现可靠的数据传输。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;4 比特的&lt;code&gt;首部字段长度字段(header length field)&lt;/code&gt;，这个字段指示了以 32 比特的字为单位的 TCP 首部长度。TCP 首部的长度是可变的，但是通常情况下，选项字段为空，所以 TCP 首部字段的长度是 20 字节。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;16 比特的 &lt;code&gt;接受窗口字段(receive window field)&lt;/code&gt; ，这个字段用于流量控制。它用于指示接收方能够/愿意接受的字节数量&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可变的&lt;code&gt;选项字段(options field)&lt;/code&gt;，这个字段用于发送方和接收方协商最大报文长度，也就是 MSS 时使用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;6 比特的 &lt;code&gt;标志字段(flag field)&lt;/code&gt;， &lt;code&gt;ACK&lt;/code&gt; 标志用于指示确认字段中的值是有效的，这个报文段包括一个对已被成功接收报文段的确认；&lt;code&gt;RST&lt;/code&gt;、&lt;code&gt;SYN&lt;/code&gt;、&lt;code&gt;FIN&lt;/code&gt; 标志用于连接的建立和关闭；&lt;code&gt;CWR&lt;/code&gt; 和 &lt;code&gt;ECE&lt;/code&gt; 用于拥塞控制；&lt;code&gt;PSH&lt;/code&gt; 标志用于表示立刻将数据交给上层处理；&lt;code&gt;URG&lt;/code&gt; 标志用来表示数据中存在需要被上层处理的 &lt;em&gt;紧急&lt;/em&gt; 数据。紧急数据最后一个字节由 16 比特的&lt;code&gt;紧急数据指针字段(urgeent data pointer field)&lt;/code&gt; 指出。一般情况下，PSH 和 URG 并没有使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TCP 的各种功能和特点都是通过 TCP 报文结构来体现的，在聊完 TCP 报文结构之后，我们下面就来聊一下 TCP 有哪些功能及其特点了。&lt;/p&gt;
&lt;h3 id=&quot;序号、确认号实现传输可靠性&quot;&gt;序号、确认号实现传输可靠性&lt;/h3&gt;
&lt;p&gt;TCP 报文段首部中两个最重要的字段就是 &lt;code&gt;序号&lt;/code&gt; 和 &lt;code&gt;确认号&lt;/code&gt;，这两个字段是 TCP 实现可靠性的基础，那么你肯定好奇如何实现可靠性呢？要了解这一点，首先我们得先知道这两个字段里面存了哪些内容吧？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个报文段的序号就是数据流的字节编号&lt;/strong&gt; 。因为 TCP 会把数据流分割成为一段一段的字节流，因为字节流本身是有序的，所以每一段的字节编号就是标示是哪一段的字节流。比如，主机 A 要给主机 B 发送一条数据。数据经过应用层产生后会有一串数据流，数据流会经过 TCP 分割，分割的依据就是 MSS，假设数据是 10000 字节，MSS 是 2000 字节，那么 TCP 就会把数据拆分成 0 - 1999 , 2000 - 3999 的段，依次类推。&lt;/p&gt;
&lt;p&gt;所以，第一个数据 0 - 1999 的首字节编号就是 0 ，2000 - 3999 的首字节编号就是 2000 。。。。。。&lt;/p&gt;
&lt;p&gt;然后，每个序号都会被填入 TCP 报文段首部的序号字段中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQp4A.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于确认号的话，会比序号要稍微麻烦一些。这里我们先拓展下几种通信模型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单工通信：单工数据传输只支持数据在一个方向上传输；在同一时间只有一方能接受或发送信息，不能实现双向通信，比如广播、电视等。&lt;/li&gt;
&lt;li&gt;双工通信是一种点对点系统，由两个或者多个在两个方向上相互通信的连接方或者设备组成。双工通信模型有两种：&lt;em&gt;全双工(FDX)和半双工(HDX)&lt;/em&gt;
&lt;ul&gt;&lt;li&gt;全双工：在全双工系统中，连接双方可以相互通信，一个最常见的例子就是电话通信。全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。&lt;/li&gt;
&lt;li&gt;半双工：在半双工系统中，连接双方可以彼此通信，但不能同时通信，比如对讲机，只有把按钮按住的人才能够讲话，只有一个人讲完话后另外一个人才能讲话。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;单工、半双工、全双工通信如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQEDS.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TCP 是一种全双工的通信协议，因此主机 A 在向主机 B 发送消息的过程中，也在接受来自主机 B 的数据。&lt;em&gt;主机 A 填充进报文段的确认号是期望从主机 B 收到的下一字节的序号&lt;/em&gt;。稍微有点绕，我们来举个例子看一下。比如主机 A 收到了来自主机 B 发送的编号为 0 - 999 字节的报文段，这个报文段会写入序号中，随后主机 A 期望能够从主机 B 收到 1000 - 剩下的报文段，因此，主机 A 发送到主机 B 的报文段中，它的确认号就是 1000 。&lt;/p&gt;
&lt;h4 id=&quot;累积确认&quot;&gt;累积确认&lt;/h4&gt;
&lt;p&gt;这里再举出一个例子，比如主机 A 在发送 0 - 999 报文段后，期望能够接受到 1000 之后的报文段，但是主机 B 却给主机 A 发送了一个 1500 之后的报文段，那么主机 A 是否还会继续进行等待呢？&lt;/p&gt;
&lt;p&gt;答案显然是会的，因为 TCP 只会确认流中至第一个丢失字节为止的字节，因为 1500 虽然属于 1000 之后的字节，但是主机 B 没有给主机 A 发送 1000 - 1499 之间的字节，所以主机 A 会继续等待。&lt;/p&gt;
&lt;p&gt;在了解完序号和确认号之后，我们下面来聊一下 TCP 的发送过程。下面是一个正常的发送过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQigP.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TCP 通过肯定的&lt;code&gt;确认应答(ACK)&lt;/code&gt; 来实现可靠的数据传输，当主机 A将数据发出之后会等待主机 B 的响应。如果有确认应答(ACK)，说明数据已经成功到达对端。反之，则数据很可能会丢失。&lt;/p&gt;
&lt;p&gt;如下图所示，如果在一定时间内主机 A 没有等到确认应答，则认为主机 B 发送的报文段已经丢失，并进行重发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQFjf.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主机 A 给主机 B 的响应可能由于网络抖动等原因无法到达，那么在经过特定的时间间隔后，主机 A 将重新发送报文段。&lt;/p&gt;
&lt;p&gt;主机 A 没有收到主机 B 的响应还可能是因为主机 B 在发送给主机 A 的过程中丢失。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQAu8.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，由主机 B 返回的确认应答，由于网络拥堵等原因在传送的过程中丢失，并没有到达主机 A。主机 A 会等待一段时间，如果在这段时间内主机 A 仍没有等到主机 B 的响应，那么主机 A 会重新发送报文段。&lt;/p&gt;
&lt;p&gt;那么现在就存在一个问题，如果主机 A 给主机 B 发送了一个报文段后，主机 B 接受到报文段发送响应，此刻由于网络原因，这个报文段并未到达，等到一段时间后主机 A 重新发送报文段，然后此时主机 B 发送的响应在主机 A 第二次发送后失序到达主机 A，那么主机 A 应该如何处理呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQVHg.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TCP RFC 并未为此做任何规定，也就是说，我们可以自己决定如何处理失序到达的报文段。一般处理方式有两种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接收方立刻丢弃失序的报文段&lt;/li&gt;
&lt;li&gt;接收方接受时许到达的报文段，并等待后续的报文段&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说通常采取的做法是第二种。&lt;/p&gt;
&lt;h3 id=&quot;传输控制&quot;&gt;传输控制&lt;/h3&gt;
&lt;h4 id=&quot;利用窗口控制提高速度&quot;&gt;利用窗口控制提高速度&lt;/h4&gt;
&lt;p&gt;前面我们介绍了 TCP 是以数据段的形式进行发送，如果经过一段时间内主机 A 等不到主机 B 的响应，主机 A 就会重新发送报文段，接受到主机 B 的响应，再会继续发送后面的报文段，我们现在看到，这一问一答的形式还存在许多条件，比如响应未收到、等待响应等，那么对崇尚性能的互联网来说，这种形式的性能应该不会很高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQeEQ.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么如何提升性能呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了解决这个问题，TCP 引入了 &lt;code&gt;窗口&lt;/code&gt; 这个概念，即使在往返时间较长、频次很多的情况下，它也能控制网络性能的下降，听起来很牛批，那它是如何实现的呢？&lt;/p&gt;
&lt;p&gt;如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQn4s.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们之前每次请求发送都是以报文段的形式进行的，引入窗口后，每次请求都可以发送多个报文段，也就是说一个窗口可以发送多个报文段。窗口大小就是指无需等待确认应答就可以继续发送报文段的最大值。&lt;/p&gt;
&lt;p&gt;在这个窗口机制中，大量使用了 &lt;code&gt;缓冲区&lt;/code&gt; ，通过对多个段同时进行确认应答的功能。&lt;/p&gt;
&lt;p&gt;如下图所示，发送报文段中高亮部分即是我们提到的窗口，在窗口内，即是没有收到确认应答也可以把请求发送出去。不过，在整个窗口的确认应答没有到达之前，如果部分报文段丢失，那么主机 A 将仍会重传。为此，主机 A 需要设置缓存来保留这些需要重传的报文段，直到收到他们的确认应答。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQmNj.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在滑动窗口以外的部分是尚未发送的报文段和已经接受到的报文段，如果报文段已经收到确认则不可进行重发，此时报文段就可以从缓冲区中清除。&lt;/p&gt;
&lt;p&gt;在收到确认的情况下，会将窗口滑动到确认应答中确认号的位置，如上图所示，这样可以顺序的将多个段同时发送，用以提高通信性能，这种窗口也叫做 &lt;code&gt;滑动窗口(Sliding window)&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;窗口控制和重发&quot;&gt;窗口控制和重发&lt;/h4&gt;
&lt;p&gt;报文段的发送和接收，必然伴随着报文段的丢失和重发，窗口也是同样如此，如果在窗口中报文段发送过程中出现丢失怎么办？&lt;/p&gt;
&lt;p&gt;首先我们先考虑确认应答没有返回的情况。在这种情况下，主机 A 发送的报文段到达主机 B，是不需要再进行重发的。这和单个报文段的发送不一样，如果发送单个报文段，&lt;strong&gt;即使确认应答没有返回，也要进行重发&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQKCn.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;窗口在一定程度上比较大时，即使有少部分确认应答的丢失，也不会重新发送报文段。&lt;/p&gt;
&lt;p&gt;我们知道，如果在某个情况下由于发送的报文段丢失，导致接受主机未收到请求，或者主机返回的响应未到达客户端的话，会经过一段时间重传报文。那么在使用窗口的情况下，报文段丢失会怎么样呢？&lt;/p&gt;
&lt;p&gt;如下图所示，报文段 0 - 999 丢失后，但是主机 A 并不会等待，主机 A 会继续发送余下的报文段，主机 B 发送的确认应答却一直是 1000，同一个确认号的应答报文会被持续不断的返回，如果发送端主机在连续 3 次收到同一个确认应答后，就会将其所对应的数据重发，这种机制要比之前提到的超时重发更加高效，这种机制也被称为 &lt;code&gt;高速重发控制&lt;/code&gt;。这种重发的确认应答也被称为 &lt;code&gt;冗余 ACK(响应)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQM3q.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主机 B 在没有接收到自己期望序列号的报文段时，会对之前收到的数据进行确认应答。发送端则一旦收到某个确认应答后，又连续三次收到同样的确认应答，那么就会认为报文段已经丢失。需要进行重发。&lt;em&gt;使用这种机制可以提供更为快速的重发服务&lt;/em&gt;。&lt;/p&gt;
&lt;h3 id=&quot;流量控制&quot;&gt;流量控制&lt;/h3&gt;
&lt;p&gt;前面聊的是传输控制，下面 cxuan 再和你聊一下 &lt;code&gt;流量控制&lt;/code&gt;。我们知道，在每个 TCP 连接的一侧主机都会有一个 socket 缓冲区，缓冲区会为每个连接设置接收缓存和发送缓存，当 TCP 建立连接后，从应用程序产生的数据就会到达接收方的接收缓冲区中，接收方的应用程序并不一定会马上读区缓冲区的数据，它需要等待操作系统分配时间片。如果此时发送方的应用程序产生数据过快，而接收方读取接受缓冲区的数据相对较慢的话，那么接收方中缓冲区的数据将会&lt;code&gt;溢出&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是还好，TCP 有 &lt;code&gt;流量控制服务(flow-control service)&lt;/code&gt; 用于消除缓冲区溢出的情况。流量控制是一个速度匹配服务，即发送方的发送速率与接受方应用程序的读取速率相匹配。&lt;/p&gt;
&lt;p&gt;TCP 通过使用一个 &lt;code&gt;接收窗口(receive window)&lt;/code&gt; 的变量来提供流量控制。接受窗口会给发送方一个指示&lt;strong&gt;到底还有多少可用的缓存空间&lt;/strong&gt;。发送端会根据接收端的实际接受能力来控制发送的数据量。&lt;/p&gt;
&lt;p&gt;接收端主机向发送端主机通知自己可以接收数据的大小，发送端会发送不超过这个限度的数据，这个大小限度就是窗口大小，还记得 TCP 的首部么，有一个接收窗口，我们上面聊的时候说这个字段用于流量控制。它用于指示接收方能够/愿意接受的字节数量。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么只知道这个字段用于流量控制，那么如何控制呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;发送端主机会定期发送一个&lt;code&gt;窗口探测包&lt;/code&gt;，这个包用于探测接收端主机是否还能够接受数据，当接收端的缓冲区一旦面临数据溢出的风险时，窗口大小的值也随之被设置为一个更小的值通知发送端，从而控制数据发送量。&lt;/p&gt;
&lt;p&gt;下面是一个流量控制示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQ3uT.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发送端主机根据接收端主机的窗口大小进行流量控制。由此也可以防止发送端主机一次发送过大数据导致接收端主机无法处理。&lt;/p&gt;
&lt;p&gt;如上图所示，当主机 B 收到报文段 2000 - 2999 之后缓冲区已满，不得不暂时停止接收数据。然后主机 A 发送窗口探测包，窗口探测包非常小仅仅一个字节。然后主机 B 更新缓冲区接收窗口大小并发送窗口更新通知给主机 A，然后主机 A 再继续发送报文段。&lt;/p&gt;
&lt;p&gt;在上面的发送过程中，窗口更新通知可能会丢失，一旦丢失发送端就不会发送数据，所以窗口探测包会随机发送，以避免这种情况发生。&lt;/p&gt;
&lt;h3 id=&quot;连接管理&quot;&gt;连接管理&lt;/h3&gt;
&lt;p&gt;在继续介绍下面有意思的特性之前，我们先来把关注点放在 TCP 的&lt;code&gt;连接管理&lt;/code&gt;上，因为没有 TCP 连接，也就没有后续的一系列 TCP 特性什么事儿了。假设运行在一台主机上的进程想要和另一台主机上的进程建立一条 TCP 连接，那么客户中的 TCP 会使用下面这些步骤与服务器中的 TCP 建立连接。&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首先，客户端首先向服务器发送一个特殊的 TCP 报文段。这个报文段首部不包含应用层数据，但是在报文段的首部中有一个 &lt;code&gt;SYN 标志位&lt;/code&gt; 被置为 1。因此，这个特殊的报文段也可以叫做 SYN 报文段。然后，客户端随机选择一个&lt;code&gt;初始序列号(client_isn)&lt;/code&gt; ，并将此数字放入初始 TCP SYN 段的序列号字段中，SYN 段又被封装在 IP 数据段中发送给服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;一旦包含 IP 数据段到达服务器后，服务端会从 IP 数据段中提取 TCP SYN 段，将 TCP 缓冲区和变量分配给连接，然后给客户端发送一个连接所允许的报文段。这个&lt;strong&gt;连接所允许的报文段&lt;/strong&gt;也不包括任何应用层数据。然而，它却包含了三个非常重要的信息。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这些缓冲区和变量的分配使 TCP 容易受到称为 SYN 泛洪的拒绝服务攻击。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;首先，SYN 比特被置为 1 。&lt;/li&gt;
&lt;li&gt;然后，TCP 报文段的首部确认号被设置为 &lt;code&gt;client_isn + 1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;最后，服务器选择自己的&lt;code&gt;初始序号(server_isn)&lt;/code&gt;，并将其放置到 TCP 报文段首部的序号字段中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果用大白话解释下就是，我收到了你发起建立连接的 SYN 报文段，这个报文段具有首部字段 client_isn。我同意建立该连接，我自己的初始序号是 server_isn。这个允许连接的报文段被称为 &lt;code&gt;SYNACK 报文段&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第三步，在收到 SYNACK 报文段后，客户端也要为该连接分配缓冲区和变量。客户端主机向服务器发送另外一个报文段，最后一个报文段对服务器发送的响应报文做了确认，确认的标准是客户端发送的数据段中确认号为 server_isn + 1，因为连接已经建立，所以 SYN 比特被置为 0 。以上就是 TCP 建立连接的三次数据段发送过程，也被称为 &lt;code&gt;三次握手&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一旦完成这三个步骤，客户和服务器主机就可以相互发送报文段了，在以后的每一个报文段中，SYN 比特都被置为 0 ，整个过程描述如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQQg0.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在客户端主机和服务端主机建立连接后，参与一条 TCP 连接的两个进程中的任何一个都能终止 TCP 连接。连接结束后，主机中的&lt;em&gt;缓存和变量&lt;/em&gt;将会被释放。假设客户端主机想要终止 TCP 连接，它会经历如下过程&lt;/p&gt;
&lt;p&gt;客户应用进程发出一个关闭命令，客户 TCP 向服务器进程发送一个特殊的 TCP 报文段，这个特殊的报文段的首部标志 FIN 被设置为 1 。当服务器收到这个报文段后，就会向发送方发送一个确认报文段。然后，服务器发送它自己的终止报文段，FIN 位被设置为 1 。客户端对这个终止报文段进行确认。此时，在两台主机上用于该连接的所有资源都被释放了，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQlvV.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在一个 TCP 连接的生命周期内，运行在每台主机中的 TCP 协议都会在各种 &lt;code&gt;TCP 状态(TCP State)&lt;/code&gt; 之间进行变化，TCP 的状态主要有 &lt;strong&gt;LISTEN、SYN-SEND、SYN-RECEIVED、ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK、TIME-WAIT 和 CLOSED&lt;/strong&gt; 。这些状态的解释如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;LISTEN&lt;/code&gt;: 表示等待任何来自远程 TCP 和端口的连接请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SYN-SEND&lt;/code&gt;: 表示发送连接请求后等待匹配的连接请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SYN-RECEIVED&lt;/code&gt;: 表示已接收并发送连接请求后等待连接确认，也就是 TCP 三次握手中第二步后服务端的状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ESTABLISHED&lt;/code&gt;: 表示已经连接已经建立，可以将应用数据发送给其他主机&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面这四种状态是 TCP 三次握手所涉及的。&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;FIN-WAIT-1&lt;/code&gt;: 表示等待来自远程 TCP 的连接终止请求，或者等待先前发送的连接终止请求的确认。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;FIN-WAIT-2&lt;/code&gt;: 表示等待来自远程 TCP 的连接终止请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;CLOSE-WAIT&lt;/code&gt;: 表示等待本地用户的连接终止请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;CLOSING&lt;/code&gt;: 表示等待来自远程 TCP 的连接终止请求确认。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;LAST-ACK&lt;/code&gt;: 表示等待先前发送给远程 TCP 的连接终止请求的确认（包括对它的连接终止请求的确认）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;TIME-WAIT&lt;/code&gt;: 表示等待足够的时间以确保远程 TCP 收到其连接终止请求的确认。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;CLOSED&lt;/code&gt;: 表示连接已经关闭，无连接状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面 7 种状态是 TCP 四次挥手，也就是断开链接所设计的。&lt;/p&gt;
&lt;p&gt;TCP 的连接状态会进行各种切换，这些 TCP 连接的切换是根据事件进行的，这些事件由用户调用：&lt;strong&gt;OPEN、SEND、RECEIVE、CLOSE、ABORT 和 STATUS&lt;/strong&gt;。涉及到 TCP 报文段的标志有 &lt;strong&gt;SYN、ACK、RST 和 FIN&lt;/strong&gt; ，当然，还有超时。&lt;/p&gt;
&lt;p&gt;我们下面加上 TCP 连接状态后，再来看一下三次握手和四次挥手的过程。&lt;/p&gt;
&lt;h4 id=&quot;三次握手建立连接&quot;&gt;三次握手建立连接&lt;/h4&gt;
&lt;p&gt;下图画出了 TCP 连接建立的过程。假设图中左端是客户端主机，右端是服务端主机，一开始，两端都处于&lt;code&gt;CLOSED（关闭）&lt;/code&gt;状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQ8DU.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务端进程准备好接收来自外部的 TCP 连接，一般情况下是调用 bind、listen、socket 三个函数完成。这种打开方式被认为是 &lt;code&gt;被动打开(passive open)&lt;/code&gt;。然后服务端进程处于 &lt;code&gt;LISTEN&lt;/code&gt; 状态，等待客户端连接请求。&lt;/li&gt;
&lt;li&gt;客户端通过 &lt;code&gt;connect&lt;/code&gt; 发起&lt;code&gt;主动打开(active open)&lt;/code&gt;，向服务器发出连接请求，请求中首部同步位 SYN = 1，同时选择一个初始序号 sequence ，简写 seq = x。SYN 报文段不允许携带数据，只消耗一个序号。此时，客户端进入 &lt;code&gt;SYN-SEND&lt;/code&gt; 状态。&lt;/li&gt;
&lt;li&gt;服务器收到客户端连接后，，需要确认客户端的报文段。在确认报文段中，把 SYN 和 ACK 位都置为 1 。确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。此时，TCP 服务器进入 &lt;code&gt;SYN-RECEIVED(同步收到)&lt;/code&gt; 状态。&lt;/li&gt;
&lt;li&gt;客户端在收到服务器发出的响应后，还需要给出确认连接。确认连接中的 ACK 置为 1 ，序号为 seq = x + 1，确认号为 ack = y + 1。TCP 规定，这个报文段可以携带数据也可以不携带数据，如果不携带数据，那么下一个数据报文段的序号仍是 seq = x + 1。这时，客户端进入 &lt;code&gt;ESTABLISHED (已连接)&lt;/code&gt; 状态&lt;/li&gt;
&lt;li&gt;服务器收到客户的确认后，也进入 &lt;code&gt;ESTABLISHED&lt;/code&gt; 状态。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;TCP 建立一个连接需要三个报文段，释放一个连接却需要四个报文段。&lt;/p&gt;
&lt;h4 id=&quot;四次挥手&quot;&gt;四次挥手&lt;/h4&gt;
&lt;p&gt;数据传输结束后，通信的双方可以释放连接。数据传输结束后的客户端主机和服务端主机都处于 ESTABLISHED 状态，然后进入释放连接的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQN59.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TCP 断开连接需要历经的过程如下&lt;/p&gt;
&lt;ol readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;客户端应用程序发出释放连接的报文段，并停止发送数据，主动关闭 TCP 连接。客户端主机发送释放连接的报文段，报文段中首部 FIN 位置为 1 ，不包含数据，序列号位 seq = u，此时客户端主机进入 &lt;code&gt;FIN-WAIT-1(终止等待 1)&lt;/code&gt; 阶段。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;服务器主机接受到客户端发出的报文段后，即发出确认应答报文，确认应答报文中 ACK = 1，生成自己的序号位 seq = v，ack = u + 1，然后服务器主机就进入 &lt;code&gt;CLOSE-WAIT(关闭等待)&lt;/code&gt; 状态，这个时候客户端主机 -&amp;gt; 服务器主机这条方向的连接就释放了，客户端主机没有数据需要发送，此时服务器主机是一种半连接的状态，但是服务器主机仍然可以发送数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;客户端主机收到服务端主机的确认应答后，即进入 &lt;code&gt;FIN-WAIT-2(终止等待2)&lt;/code&gt; 的状态。等待客户端发出连接释放的报文段。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;当服务器主机没有数据发送后，应用进程就会通知 TCP 释放连接。这时服务端主机会发出断开连接的报文段，报文段中 ACK = 1，序列号 seq = w，因为在这之间可能已经发送了一些数据，所以 seq 不一定等于 v + 1。ack = u + 1，在发送完断开请求的报文后，服务端主机就进入了 &lt;code&gt;LAST-ACK(最后确认)&lt;/code&gt;的阶段。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;客户端收到服务端的断开连接请求后，客户端需要作出响应，客户端发出断开连接的报文段，在报文段中，ACK = 1, 序列号 seq = u + 1，因为客户端从连接开始断开后就没有再发送数据，ack = w + 1，然后进入到 &lt;code&gt;TIME-WAIT(时间等待)&lt;/code&gt; 状态，请注意，这个时候 TCP 连接还没有释放。必须经过时间等待的设置，也就是 &lt;code&gt;2MSL&lt;/code&gt; 后，客户端才会进入 &lt;code&gt;CLOSED&lt;/code&gt; 状态，时间 MSL 叫做&lt;code&gt;最长报文段寿命（Maximum Segment Lifetime）&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;服务端主要收到了客户端的断开连接确认后，就会进入 CLOSED 状态。因为服务端结束 TCP 连接时间要比客户端早，而整个连接断开过程需要发送四个报文段，因此释放连接的过程也被称为四次挥手。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;什么是-time-wait&quot;&gt;什么是 TIME-WAIT&lt;/h4&gt;
&lt;p&gt;我上面只是简单提到了一下 TIME-WAIT 状态和 2MSL 是啥，下面来聊一下这两个概念。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MSL&lt;/code&gt; 是 TCP 报文段可以存活或者驻留在网络中的最长时间。RFC 793 定义了 MSL 的时间是两分钟，但是具体的实现还要根据程序员来指定，一些实现采用了 30 秒的这个最大存活时间。&lt;/p&gt;
&lt;p&gt;那么为什么要等待 &lt;code&gt;2MSL&lt;/code&gt; 呢？&lt;/p&gt;
&lt;p&gt;主要是因为两个理由&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为了保证最后一个响应能够到达服务器，因为在计算机网络中，最后一个 ACK 报文段可能会丢失，从而致使客户端一直处于 &lt;code&gt;LAST-ACK&lt;/code&gt; 状态等待客户端响应。这时候服务器会重传一次 &lt;em&gt;FINACK&lt;/em&gt; 断开连接报文，客户端接收后再重新确认，重启定时器。如果客户端不是 2MSL ，在客户端发送 ACK 后直接关闭的话，如果报文丢失，那么双方主机会无法进入 CLOSED 状态。&lt;/li&gt;
&lt;li&gt;还可以防止&lt;code&gt;已失效&lt;/code&gt;的报文段。客户端在发送最后一个 ACK 之后，再经过经过 2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里注意一点：在服务器发送了 FIN-ACK 之后，会立即启动超时重传计时器。客户端在发送最后一个 ACK 之后会立即启动时间等待计时器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;说好的-rst-呢&quot;&gt;说好的 RST 呢&lt;/h4&gt;
&lt;p&gt;说好的 &lt;code&gt;RST&lt;/code&gt;、&lt;code&gt;SYN&lt;/code&gt;、&lt;code&gt;FIN&lt;/code&gt; 标志用于连接的建立和关闭，那么 SYN 和 FIN 都现身了，那 RST 呢？也是啊，我们上面探讨的都是一种理想的情况，就是客户端服务器双方都会接受传输报文段的情况，还有一种情况是当主机收到 TCP 报文段后，其 IP 和端口号不匹配的情况。假设客户端主机发送一个请求，而服务器主机经过 IP 和端口号的判断后发现不是给这个服务器的，那么服务器就会发出一个 &lt;code&gt;RST&lt;/code&gt; 特殊报文段给客户端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQGbF.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，当服务端发送一个 RST 特殊报文段给客户端的时候，它就会告诉客户端&lt;em&gt;没有匹配的套接字连接，请不要再继续发送了&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;上面探讨的是 TCP 的情况，那么 UDP 呢？&lt;/p&gt;
&lt;p&gt;使用 UDP 作为传输协议后，如果套接字不匹配的话，UDP 主机就会发送一个特殊的 ICMP 数据报。&lt;/p&gt;
&lt;h4 id=&quot;syn-洪泛攻击&quot;&gt;SYN 洪泛攻击&lt;/h4&gt;
&lt;p&gt;下面我们来讨论一下什么是 &lt;em&gt;SYN 洪泛攻击&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;我们在 TCP 的三次握手中已经看到，服务器为了响应一个收到的 SYN，分配并初始化变量连接和缓存，然后服务器发送一个 SYNACK 作为响应，然后等待来自于客户端的 ACK 报文。如果客户端不发送 ACK 来完成最后一步的话，那么这个连接就处在一个挂起的状态，也就是半连接状态。&lt;/p&gt;
&lt;p&gt;攻击者通常在这种情况下发送大量的 TCP SYN 报文段，服务端继续响应，但是每个连接都完不成三次握手的步骤。随着 SYN 的不断增加，服务器会不断的为这些半开连接分配资源，导致服务器的连接最终被消耗殆尽。这种攻击也是属于 &lt;code&gt;Dos&lt;/code&gt; 攻击的一种。&lt;/p&gt;
&lt;p&gt;抵御这种攻击的方式是使用 &lt;code&gt;SYN cookie&lt;/code&gt; ，下面是它的工作流程介绍&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当服务器收到一个 SYN 报文段时，它并不知道这个报文段是来自哪里，是来自攻击者主机还是客户端主机(虽然攻击者也是客户端，不过这么说更便于区分) 。因此服务器不会为报文段生成一个半开连接。与此相反，服务器生成一个初始的 TCP 序列号，这个序列号是 SYN 报文段的源和目的 IP 地址与端口号这个四元组构造的一个复杂的散列函数，这个散列函数生成的 TCP 序列号就是 &lt;code&gt;SYN Cookie&lt;/code&gt;，用于缓存 SYN 请求。然后，服务器会发送带着 SYN Cookie 的 SYNACK 分组。&lt;strong&gt;有一点需要注意的是，服务器不会记忆这个 Cookie 或 SYN 的其他状态信息&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果客户端不是攻击者的话，它就会返回一个 ACK 报文段。当服务器收到这个 ACK 后，需要验证这个 ACK 与 SYN 发送的是否相同，验证的标准就是确认字段中的确认号和序列号，源和目的 IP 地址与端口号以及和散列函数的是否一致，散列函数的结果 + 1 是否和 SYNACK 中的确认值相同。(大致是这样，说的不对还请读者纠正) 。如果有兴趣读者可以自行深入了解。如果是合法的，服务器就会生成一个具有套接字的全开连接。&lt;/li&gt;
&lt;li&gt;如果客户端没有返回 ACK，即认为是攻击者，那么这样也没关系，服务器没有收到 ACK，不会分配变量和缓存资源，不会对服务器产生危害。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;拥塞控制&quot;&gt;拥塞控制&lt;/h3&gt;
&lt;p&gt;有了 TCP 的窗口控制后，使计算机网络中两个主机之间不再是以单个数据段的形式发送了，而是能够连续发送大量的数据包。然而，大量数据包同时也伴随着其他问题，比如网络负载、网络拥堵等问题。TCP 为了防止这类问题的出现，使用了 &lt;code&gt;拥塞控制&lt;/code&gt; 机制，拥塞控制机制会在面临网络拥塞时遏制发送方的数据发送。&lt;/p&gt;
&lt;p&gt;拥塞控制主要有两种方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;端到端的拥塞控制&lt;/code&gt;: 因为网络层没有为运输层拥塞控制提供显示支持。所以即使网络中存在拥塞情况，端系统也要通过对网络行为的观察来推断。&lt;strong&gt;TCP 就是使用了端到端的拥塞控制方式&lt;/strong&gt;。IP 层不会向端系统提供有关网络拥塞的反馈信息。那么 TCP 如何推断网络拥塞呢？&lt;strong&gt;如果超时或者三次冗余确认就被认为是网络拥塞，TCP 会减小窗口的大小，或者增加往返时延来避免&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;网络辅助的拥塞控制&lt;/code&gt;: 在网络辅助的拥塞控制中，路由器会向发送方提供关于网络中拥塞状态的反馈。这种反馈信息就是一个比特信息，它指示链路中的拥塞情况。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下图描述了这两种拥塞控制方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQYE4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;tcp-拥塞控制&quot;&gt;TCP 拥塞控制&lt;/h4&gt;
&lt;p&gt;如果你看到这里，那我就暂定认为你了解了 TCP 实现可靠性的基础了，那就是使用序号和确认号。除此之外，另外一个实现 TCP 可靠性基础的就是 TCP 的拥塞控制。如果说&lt;/p&gt;
&lt;p&gt;TCP 所采用的方法是让每一个发送方根据所感知到的网络的拥塞程度来限制发出报文段的速率，如果 TCP 发送方感知到没有什么拥塞，则 TCP 发送方会增加发送速率；如果发送方感知沿着路径有阻塞，那么发送方就会降低发送速率。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;但是这种方法有三个问题&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;TCP 发送方如何限制它向其他连接发送报文段的速率呢？&lt;/li&gt;
&lt;li&gt;一个 TCP 发送方是如何感知到网络拥塞的呢？&lt;/li&gt;
&lt;li&gt;当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率呢？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;我们先来探讨一下第一个问题，&lt;strong&gt;TCP 发送方如何限制它向其他连接发送报文段的速率呢&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;我们知道 TCP 是由接收缓存、发送缓存和&lt;code&gt;变量(LastByteRead, rwnd，等)&lt;/code&gt;组成。发送方的 TCP 拥塞控制机制会跟踪一个变量，即 &lt;code&gt;拥塞窗口(congestion window)&lt;/code&gt; 的变量，拥塞窗口表示为 &lt;code&gt;cwnd&lt;/code&gt;，用于限制 TCP 在接收到 ACK 之前可以发送到网络的数据量。而&lt;code&gt;接收窗口(rwnd)&lt;/code&gt; 是一个用于告诉接收方能够接受的数据量。&lt;/p&gt;
&lt;p&gt;一般来说，发送方未确认的数据量不得超过 cwnd 和 rwnd 的最小值，也就是&lt;/p&gt;
&lt;p&gt;&lt;em&gt;LastByteSent - LastByteAcked &amp;lt;= min(cwnd,rwnd)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;由于每个数据包的往返时间是 RTT，我们假设接收端有足够的缓存空间用于接收数据，我们就不用考虑 rwnd 了，只专注于 cwnd，那么，该发送方的发送速率大概是 &lt;code&gt;cwnd/RTT 字节/秒&lt;/code&gt; 。通过调节 cwnd，发送方因此能调整它向连接发送数据的速率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个 TCP 发送方是如何感知到网络拥塞的呢&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;这个我们上面讨论过，是 TCP 根据超时或者 3 个冗余 ACK 来感知的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率呢&lt;/strong&gt; ?&lt;/p&gt;
&lt;p&gt;这个问题比较复杂，且容我娓娓道来，一般来说，TCP 会遵循下面这几种指导性原则&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果在报文段发送过程中丢失，那就意味着网络拥堵，此时需要适当降低 TCP 发送方的速率。&lt;/li&gt;
&lt;li&gt;一个确认报文段指示发送方正在向接收方传递报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率。为啥呢？因为未确认的报文段到达接收方也就表示着网络不拥堵，能够顺利到达，因此发送方拥塞窗口长度会变大，所以发送速率会变快&lt;/li&gt;
&lt;li&gt;&lt;code&gt;带宽探测&lt;/code&gt;，带宽探测说的是 TCP 可以通过调节传输速率来增加/减小 ACK 到达的次数，如果出现丢包事件，就会减小传输速率。因此，为了探测拥塞开始出现的频率， TCP 发送方应该增加它的传输速率。然后慢慢使传输速率降低，进而再次开始探测，看看拥塞开始速率是否发生了变化。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在了解完 TCP 拥塞控制后，下面我们就该聊一下 TCP 的 &lt;code&gt;拥塞控制算法(TCP congestion control algorithm)&lt;/code&gt; 了。TCP 拥塞控制算法主要包含三个部分：&lt;em&gt;慢启动、拥塞避免、快速恢复&lt;/em&gt;，下面我们依次来看一下&lt;/p&gt;
&lt;h4 id=&quot;慢启动&quot;&gt;慢启动&lt;/h4&gt;
&lt;p&gt;当一条 TCP 开始建立连接时，cwnd 的值就会初始化为一个 MSS 的较小值。这就使得初始发送速率大概是 &lt;code&gt;MSS/RTT 字节/秒&lt;/code&gt; ，比如要传输 1000 字节的数据，RTT 为 200 ms ，那么得到的初始发送速率大概是 40 kb/s 。实际情况下可用带宽要比这个 MSS/RTT 大得多，因此 TCP 想要找到最佳的发送速率，可以通过 &lt;code&gt;慢启动(slow-start)&lt;/code&gt; 的方式，在慢启动的方式中，cwnd 的值会初始化为 1 个 MSS，并且每次传输报文确认后就会增加一个 MSS，cwnd 的值会变为 2 个 MSS，这两个报文段都传输成功后每个报文段 + 1，会变为 4 个 MSS，依此类推，每成功一次 cwnd 的值就会翻倍。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/29/DcQtUJ.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发送速率不可能会一直增长，增长总有结束的时候，那么何时结束呢？慢启动通常会使用下面这几种方式结束发送速率的增长。&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果在慢启动的发送过程出现丢包的情况，那么 TCP 会将发送方的 cwnd 设置为 1 并重新开始慢启动的过程，此时会引入一个 &lt;code&gt;ssthresh(慢启动阈值)&lt;/code&gt; 的概念，它的初始值就是产生丢包的 cwnd 的值 / 2，即当检测到拥塞时，ssthresh 的值就是窗口值的一半。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第二种方式是直接和 ssthresh 的值相关联，因为当检测到拥塞时，ssthresh 的值就是窗口值的一半，那么当 cwnd &amp;gt; ssthresh 时，每次翻番都可能会出现丢包，所以最好的方式就是 cwnd 的值 = ssthresh ，这样 TCP 就会转为拥塞控制模式，结束慢启动。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;慢启动结束的最后一种方式就是如果检测到 3 个冗余 ACK，TCP 就会执行一种快速重传并进入恢复状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;拥塞避免&quot;&gt;拥塞避免&lt;/h4&gt;
&lt;p&gt;当 TCP 进入拥塞控制状态后，cwnd 的值就等于拥塞时值的一半，也就是 ssthresh 的值。所以，无法每次报文段到达后都将 cwnd 的值再翻倍。而是采用了一种相对&lt;code&gt;保守&lt;/code&gt;的方式，每次传输完成后只将 cwnd 的值增加&lt;code&gt;一个 MSS&lt;/code&gt;，比如收到了 10 个报文段的确认，但是 cwnd 的值只增加一个 MSS。这是一种线性增长模式，它也会有增长逾值，它的增长逾值和慢启动一样，如果出现丢包，那么 cwnd 的值就是一个 MSS，ssthresh 的值就等于 cwnd 的一半；或者是收到 3 个冗余的 ACK 响应也能停止 MSS 增长。如果 TCP 将 cwnd 的值减半后，仍然会收到 3 个冗余 ACK，那么就会将 ssthresh 的值记录为 cwnd 值的一半，进入 &lt;code&gt;快速恢复&lt;/code&gt; 状态。&lt;/p&gt;
&lt;h4 id=&quot;快速恢复&quot;&gt;快速恢复&lt;/h4&gt;
&lt;p&gt;在快速恢复中，对于使 TCP 进入快速恢复状态缺失的报文段，对于每个收到的冗余 ACK，cwnd 的值都会增加一个 MSS 。当对丢失报文段的一个 ACK 到达时，TCP 在降低 cwnd 后进入拥塞避免状态。如果在拥塞控制状态后出现超时，那么就会迁移到慢启动状态，cwnd 的值被设置为 1 个 MSS，ssthresh 的值设置为 cwnd 的一半。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;如果你能用心看到这里，我相信你定会有所收获。&lt;/p&gt;
&lt;p&gt;这篇文章写的时间很长，图中很多样式和配色都是精挑细选，如果你仔细阅读，可以看到我的用心良苦。&lt;/p&gt;
&lt;p&gt;如果你觉得文章写的还不错，欢迎你帮助 cxuan 扩散一下，这将是我继续更新的动力，切忌不要白嫖，会让自己变得廉价，好的文章值得分享。&lt;/p&gt;
&lt;p&gt;请记得给我一个赞哦！&lt;/p&gt;
&lt;p&gt;另外，我自己肝了六本 PDF，微信搜索「程序员cxuan」关注公众号后，在后台回复 cxuan ，领取全部 PDF，这些 PDF 如下&lt;/p&gt;
&lt;p&gt;{{uploading-image-580232.png(uploading...)}}&lt;/p&gt;
</description>
<pubDate>Mon, 30 Nov 2020 00:27:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>前言 欢迎阅读「程序员cxuan」 的文章，从今往后，你就是我的读者了。 我的 github bestJavaer 已经收录此文章，目录在 https://github.com/crisxuan/be</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/14059379.html</dc:identifier>
</item>
<item>
<title>外甥女问我计算机是如何组成的？ - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/14059376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/14059376.html</guid>
<description>&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5.2110091743119&quot;&gt;
&lt;p&gt;本文已经收录至我的GitHub,欢迎大家踊跃star 和 issues。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/midou-tech/articles&quot;&gt;https://github.com/midou-tech/articles&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继上一篇外甥问我计算机问题之后，外甥女就显得格外勤奋了，竟然也对计算机感兴趣了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生活中有一类人特别让人害怕，就是&lt;strong&gt;突然&lt;/strong&gt; 对某件事&lt;strong&gt;非常&lt;/strong&gt;感兴趣&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也不知道是真的感兴趣了，还是觉得我对他弟偏心了，哈哈&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管咋说，这姐弟俩是非常优秀的，碾压我姐弟俩一大截，是真的后浪&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上次发文章之后，外甥女晚上发消息问我 计算机是如何组成的？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章就来唠唠这个问题&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为外甥女是医学类专业，对计算机了解犹如我对女孩子的了解一般生疏&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以先说点简单的问题和一些专业名词介绍&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;什么是计算机&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说一个小故事，看下有没有相同经历&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接触计算机是因为&lt;strong&gt;计算器&lt;/strong&gt;的经历&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkwkfzlw4ij30dw0dwjrk.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这个东西，应该没人没用过吧，让我接触了计算机&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初中那会已经有函数概念了、也在解二元一次方程了，中考是允许用计算器的&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中考之前老师会让我们&lt;strong&gt;练习&lt;/strong&gt;计算器的使用&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那时候买不起计算器，日常练习的时候都是&lt;strong&gt;借&lt;/strong&gt;别人的计算器使用&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可那时候我偏偏分不清&lt;strong&gt;计算器&lt;/strong&gt;和&lt;strong&gt;计算机&lt;/strong&gt;，总有那么几次把计算器说成是计算机&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时那个女同学就用一个让我非常不能理解的眼神看着我，然后冷冷的回答道 &lt;strong&gt;没有&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在想这女同学咋回事啊，明明在桌子上却睁眼说瞎话，难道她是真的视力障碍了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;年纪亲亲摊上这事，真是替他未来的男朋友了担忧，细思极恐啊，我赶紧换一个女同学询问&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这个计算器，还有另外一个大妙处，在我们的成长岁月中 他是一个&lt;strong&gt;信息载体&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初中时载着给女孩的 小纸条、表白信 ；老师不让上课说话，此时计算器变成了 电话线，承载着老师不能懂的秘密&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高中那会开始用点高级功能了，考试的时候 他会载着好学生的答案 驶向每一个像我一样优秀的少年&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个高级功能就是表白，土豪学生表白都是送贺卡、送奶茶，而我只能让这计算器 &lt;strong&gt;物尽所能&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkxvj431unj30g40lh0tm.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时他会载着 我的一时才华和绵绵爱意，驶向那个从来不敢正视的女神&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;女神收到计算器的一瞬间嘴角上扬，而我的心 也随之欣喜若狂，世界此时都在微笑&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;言归正传哈，女孩到是没有的事，不过从此我对计算机有了概念了，产生兴趣了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机，俗称电脑 ，是一种高速计算的电子计算机器，可以进行&lt;strong&gt;数值计算&lt;/strong&gt;、&lt;strong&gt;逻辑计算&lt;/strong&gt;还具有&lt;strong&gt;存储记忆&lt;/strong&gt;功能&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看来我冒然的把计算器称为计算机也不算太离谱，起码都具有&lt;strong&gt;计算&lt;/strong&gt;功能&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;一些名词解释&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU：中央处理器是计算机系统的&lt;strong&gt;运算&lt;/strong&gt;和&lt;strong&gt;控制&lt;/strong&gt;核心模块，分为&lt;strong&gt;运算器&lt;/strong&gt;和&lt;strong&gt;控制器&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面这图是CPU的工作原理&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gky551t504j30so07fjrr.jpg&quot; alt=&quot;&quot;/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;取指令：即将一条指令从&lt;strong&gt;主存储器&lt;/strong&gt;中取到&lt;strong&gt;指令寄存器&lt;/strong&gt;的过程&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;指令译码阶段：取出指令后，&lt;strong&gt;指令译码器&lt;/strong&gt;按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;执行指令阶段：执行具体指令的功能，例如sum=a+b&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储器：许多&lt;strong&gt;存储单元&lt;/strong&gt;的集合，按&lt;strong&gt;单元号&lt;/strong&gt;顺序排列&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储器分为&lt;strong&gt;主存&lt;/strong&gt;(内存)、&lt;strong&gt;辅存&lt;/strong&gt;(磁盘)和&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主存用于存放活动的程序和数据，其速度高、容量较小、每位价位高&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;外存主要用于存放当前不活跃的程序和数据，其速度慢、容量大、每位价位低&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存主要在两个不同工作速度的部件起缓冲作用&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计数器：用来指示当前指令在主存中的&lt;strong&gt;位置&lt;/strong&gt;，当 一条指令被取出后，PC中的数值将根据指令字长度自动递增&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存地址：内存地址是一种用于软件及硬件等不同层级中的&lt;strong&gt;数据概念&lt;/strong&gt;，用来访问电脑主存中的数据，也就是上面说的存储单元的单元号&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序：存放在磁盘文件中的可执行文件或者源代码&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;计算机是如何组成的&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完了什么是计算机和一些基本概念，再来说说计算机是如何组成的&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了了解计算机的组成，我是拆过笔记本的，拆完就废了，当然拆的是一个被我淘汰的本&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkxwtd0i48j30m80gognc.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在拆本的那个时候，只有光驱、风扇我能命名，其他的都统称为芯片和集成电路，无法对他们准确命名&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要是以一名工程师的身份去拆这个电脑，那这个被拆的电脑&lt;strong&gt;透出的价值&lt;/strong&gt;可能会更大一些&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在那时候，他只不过是一个被我拆过的众多机中满足我好奇心的其中一个罢了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在拆完这个本之后，很长一段时间我认为计算机就是一堆&lt;strong&gt;集成电路&lt;/strong&gt;和&lt;strong&gt;芯片&lt;/strong&gt;组成的&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在大多数人士看来，一台计算机由&lt;strong&gt;主机&lt;/strong&gt;、&lt;strong&gt;显示器&lt;/strong&gt;、&lt;strong&gt;键盘&lt;/strong&gt;、&lt;strong&gt;鼠标&lt;/strong&gt;和&lt;strong&gt;音箱&lt;/strong&gt;等部件所组成&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种说法当然也没错，只是站在不同的角度来说&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天、站在一名专业的工程师(程序员，oh no 打工人)的角度说说计算机是如何组成的&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先计算机是由计算机&lt;strong&gt;硬件&lt;/strong&gt;和计算机&lt;strong&gt;软件&lt;/strong&gt;两部分组成&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;硬件部分包括&lt;strong&gt;中央处理器&lt;/strong&gt;、&lt;strong&gt;存储器&lt;/strong&gt;、&lt;strong&gt;输入输出&lt;/strong&gt;设备&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件部门包括&lt;strong&gt;操作系统&lt;/strong&gt;、&lt;strong&gt;驱动软件&lt;/strong&gt;、&lt;strong&gt;编译器&lt;/strong&gt;软件、&lt;strong&gt;应用软件&lt;/strong&gt;等&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkxznb68uqj30h90bpjry.jpg&quot; alt=&quot;计算机组成&quot;/&gt;计算机组成
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图就是计算机的主要组成，这种典型的组成结构就是冯·诺依曼体系结构&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然计算机除了冯·诺依曼体系结构还有一种较为常用的叫做ARM结构(哈佛结构)&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然说到了冯·诺依曼 体系和ARM体系，龙叔就带大家聊聊这块内容&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先说&lt;strong&gt;冯·诺依曼体系&lt;/strong&gt;，冯·诺依曼是一位数学家，但是被称为 &lt;strong&gt;现代计算机之父&lt;/strong&gt;，听着头衔就够一个大写的牛掰了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二战期间，美军试图开发全球首台计算机ENIAC，在当时已经有了最先进的电子技术，但是缺乏理论上的指导&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;美军没办法开发出来，这时，冯·诺依曼出现了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;冯·诺依曼的出现，瞬间让计算机发展的步伐走上了一条快速道&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;定义了计算机的&lt;strong&gt;组成结构&lt;/strong&gt;，计算机应包括运算器、存储器、控制器、输入和输出设备五大基本部件。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;计算机内部应该采用&lt;strong&gt;二进制&lt;/strong&gt;来表示指令和数据。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;将编好的程序存储在内存中，&lt;strong&gt;程序存储思想&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几点构成了 冯·诺依曼 体系，该体系计算机的特点是 &lt;strong&gt;程序存储，共享数据，顺序执行&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;冯·诺依曼 体系结构的工作示意图&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gky1howod1j30nd0fbta7.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;冯·诺依曼除了在计算机领域有杰出贡献，在数学领域、量子理论、原子弹等等领域都有杰出贡献&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍了 冯·诺依曼 结构再来说说&lt;strong&gt;哈佛结构&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gky4kspyffj30ht0b5wf6.jpg&quot; alt=&quot;哈佛结构&quot;/&gt;哈佛结构
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;冯·诺依曼结构是由五部分组成的，哈佛结构的计算机分为三大部件：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）CPU；（2）程序存储器；（3）数据存储器。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈佛结构把&lt;strong&gt;程序&lt;/strong&gt;和&lt;strong&gt;数据&lt;/strong&gt;进行了分离，分别独立为&lt;strong&gt;程序存储器&lt;/strong&gt;和&lt;strong&gt;数据存储器&lt;/strong&gt;，程序存储器和数据存储器采用&lt;strong&gt;不同的总线&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个存储器采用不同的总线意味着可以同时读取两个存储器的内容，这点大大&lt;strong&gt;提高&lt;/strong&gt;了程序运行时的&lt;strong&gt;访存效率&lt;/strong&gt;&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;冯·诺依曼和哈佛结构对比&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先 冯·诺依曼 结构的特点是：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;单处理机结构，机器以运算器为核心&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;采用程序存储的思想&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;指令和数据都可以参与运算&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;数据以二进制表示&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;软件和硬件完全分离&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;指令由操作码和操作数组成&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;顺序执行&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;冯·诺依曼结构的缺点：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;section readability=&quot;3&quot;&gt;&lt;p&gt;指令和数据存储在同一个存储器中，形成系统对存储器的过分依赖，计算的效率受到存储设备的影响&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;section readability=&quot;4&quot;&gt;&lt;p&gt;指令在存储器中按其执行顺序存放，由指令计数器PC指明要执行的指令所在的单元地址。 然后取出指令执行操作任务。所以指令的执行是串行，影响了系统执行的速度。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;section readability=&quot;5&quot;&gt;&lt;p&gt;存储器是按地址访问的线性编址，按顺序排列的地址访问，利于存储和执行的机器语言指令，适用于作数值计算。但是高级语言表示的存储器则是一组有名字的变量，按名字调用变量，不按地址访问。机器语言同高级语言在语义上存在很大的间隔， 称之为冯·诺依曼语 义间隔。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;section readability=&quot;4&quot;&gt;&lt;p&gt;冯·诺依曼体系结构计算机是为算术和逻辑运算而诞生的，目前在数值处理方面已经到达较高的速度和精度，而非数值处理应用领域发展缓慢，需要在体系结构方面有重大的突破。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈佛结构的优点:&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈佛结构的缺点：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;独立两个存储器导致结构复杂，一个电脑得装两个内存条和两个磁盘&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各自都有优缺点，现在主流电脑都使用 冯·诺依曼结构 ，嵌入式设备基本采用的ARM体系结构&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是本期的全部内容了，感谢各位阅读，求点赞、求在看、求分享，一键三连就是对我创作的最大鼓励&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是龙叔，一个半吊子架构师，我们下期见&lt;/p&gt;
</description>
<pubDate>Mon, 30 Nov 2020 00:25:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>本文已经收录至我的GitHub,欢迎大家踊跃star 和 issues。 https://github.com/midou-tech/articles 继上一篇外甥问我计算机问题之后，外甥女就显得格外</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/14059376.html</dc:identifier>
</item>
<item>
<title>CoProcessFunction实战三部曲之一：基本功能 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14059326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14059326.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;关于《coprocessfunction实战三部曲》系列&quot;&gt;关于《CoProcessFunction实战三部曲》系列&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;《CoProcessFunction实战三部曲》旨在通过三次实战，由浅入深的学习和掌握Flink低阶处理函数CoProcessFunction的用法；&lt;/li&gt;
&lt;li&gt;整个系列的开篇先介绍CoProcessFunction，然后迅速进入实战，了解CoProcessFunction的基本功能；&lt;/li&gt;
&lt;li&gt;下一篇会结合状态，让双流元素的处理彼此保持关系；&lt;/li&gt;
&lt;li&gt;终篇的实战会加入定时器功能，确保同一个key的数据在双流场景下能够及时处理；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;版本信息&quot;&gt;版本信息&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;开发环境操作系统：MacBook Pro 13寸， macOS Catalina 10.15.3&lt;/li&gt;
&lt;li&gt;开发工具：IDEA ULTIMATE 2018.3&lt;/li&gt;
&lt;li&gt;JDK：1.8.0_211&lt;/li&gt;
&lt;li&gt;Maven：3.6.0&lt;/li&gt;
&lt;li&gt;Flink：1.9.2&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;系列文章链接&quot;&gt;系列文章链接&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/109624375&quot;&gt;基本功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/109629119&quot;&gt;状态处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/109645214&quot;&gt;定时器和侧输出&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;关于coprocessfunction&quot;&gt;关于CoProcessFunction&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;CoProcessFunction的作用是同时处理两个数据源的数据；&lt;/li&gt;
&lt;li&gt;试想在面对两个输入流时，如果这两个流的数据之间有业务关系，该如何编码实现呢，例如下图中的操作，同时监听&lt;span&gt;9998&lt;/span&gt;和&lt;span&gt;9999&lt;/span&gt;端口，将收到的输出分别处理后，再由同一个sink处理(打印)：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201130075837289-720933326.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Flink支持的方式是扩展CoProcessFunction来处理，为了更清楚认识，我们把&lt;span&gt;KeyedProcessFunction&lt;/span&gt;和&lt;span&gt;CoProcessFunction&lt;/span&gt;的类图摆在一起看，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201130075837678-1470633056.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;从上图可见，CoProcessFunction和KeyedProcessFunction的继承关系一样，另外CoProcessFunction自身也很简单，在&lt;span&gt;processElement1&lt;/span&gt;和&lt;span&gt;processElement2&lt;/span&gt;中分别处理两个上游流入的数据即可，并且也支持定时器设置；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;本篇实战功能简介&quot;&gt;本篇实战功能简介&lt;/h3&gt;
&lt;p&gt;本篇咱们要开发的应用，其功能非常简单，描述如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;建两个数据源，数据分别来自本地&lt;span&gt;9998&lt;/span&gt;和&lt;span&gt;9999&lt;/span&gt;端口；&lt;/li&gt;
&lt;li&gt;每个端口收到类似&lt;span&gt;aaa,123&lt;/span&gt;这样的数据，转成Tuple2实例，f0是&lt;span&gt;aaa&lt;/span&gt;，f1是&lt;span&gt;123&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;在CoProcessFunction的实现类中，对每个数据源的数据都打日志，然后全部传到下游算子；&lt;/li&gt;
&lt;li&gt;下游操作是打印，因此&lt;span&gt;9998&lt;/span&gt;和&lt;span&gt;9999&lt;/span&gt;端口收到的所有数据都会在控制台打印出来；&lt;/li&gt;
&lt;li&gt;整个demo的功能如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201130075837972-465920736.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;接下来开始编码；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;p&gt;如果您不想写代码，整个系列的源码可在GitHub下载到，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/p&gt;
&lt;p&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;flinkstudy&lt;/span&gt;文件夹下，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201130075838383-357010033.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码简介&quot;&gt;代码简介&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;开发一个Map算子，将字符串转成Tuple2；&lt;/li&gt;
&lt;li&gt;再开发抽象类&lt;span&gt;AbstractCoProcessFunctionExecutor&lt;/span&gt;，功能包括：flink启动、监听端口、调用算子处理数据、双流连接、将双流处理结果打印出来；&lt;/li&gt;
&lt;li&gt;从上面的描述可见，&lt;span&gt;AbstractCoProcessFunctionExecutor&lt;/span&gt;做了很多事情，唯独没有实现双流连接后的具体业务逻辑，这些没有做的是留给子类来实现的，整个三部曲系列的重点都集中在AbstractCoProcessFunctionExecutor的子类上，把双流连接后的业务逻辑做好，如下图所示，红色为CoProcessFunction的业务代码，其他的都在抽象类中完成：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201130075838646-1963831744.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;map算子&quot;&gt;Map算子&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;做一个map算子，用来将字符串&lt;span&gt;aaa,123&lt;/span&gt;转成Tuple2实例，f0是&lt;span&gt;aaa&lt;/span&gt;，f1是&lt;span&gt;123&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;算子名为&lt;span&gt;WordCountMap.java&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.coprocessfunction;

import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.util.StringUtils;

public class WordCountMap implements MapFunction&amp;lt;String, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; {
    @Override
    public Tuple2&amp;lt;String, Integer&amp;gt; map(String s) throws Exception {

        if(StringUtils.isNullOrWhitespaceOnly(s)) {
            System.out.println(&quot;invalid line&quot;);
            return null;
        }

        String[] array = s.split(&quot;,&quot;);

        if(null==array || array.length&amp;lt;2) {
            System.out.println(&quot;invalid line for array&quot;);
            return null;
        }

        return new Tuple2&amp;lt;&amp;gt;(array[0], Integer.valueOf(array[1]));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;抽象类&quot;&gt;抽象类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;抽象类AbstractCoProcessFunctionExecutor.java，源码如下，稍后会说明几个关键点：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.coprocessfunction;

import org.apache.flink.api.java.tuple.Tuple;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.KeyedStream;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.co.CoProcessFunction;

/**
 * @author will
 * @email zq2599@gmail.com
 * @date 2020-11-09 17:33
 * @description 串起整个逻辑的执行类，用于体验CoProcessFunction
 */
public abstract class AbstractCoProcessFunctionExecutor {

    /**
     * 返回CoProcessFunction的实例，这个方法留给子类实现
     * @return
     */
    protected abstract CoProcessFunction&amp;lt;
            Tuple2&amp;lt;String, Integer&amp;gt;,
            Tuple2&amp;lt;String, Integer&amp;gt;,
            Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; getCoProcessFunctionInstance();

    /**
     * 监听根据指定的端口，
     * 得到的数据先通过map转为Tuple2实例，
     * 给元素加入时间戳，
     * 再按f0字段分区，
     * 将分区后的KeyedStream返回
     * @param port
     * @return
     */
    protected KeyedStream&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;, Tuple&amp;gt; buildStreamFromSocket(StreamExecutionEnvironment env, int port) {
        return env
                // 监听端口
                .socketTextStream(&quot;localhost&quot;, port)
                // 得到的字符串&quot;aaa,3&quot;转成Tuple2实例，f0=&quot;aaa&quot;，f1=3
                .map(new WordCountMap())
                // 将单词作为key分区
                .keyBy(0);
    }

    /**
     * 如果子类有侧输出需要处理，请重写此方法，会在主流程执行完毕后被调用
     */
    protected void doSideOutput(SingleOutputStreamOperator&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; mainDataStream) {
    }

    /**
     * 执行业务的方法
     * @throws Exception
     */
    public void execute() throws Exception {
        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        // 并行度1
        env.setParallelism(1);

        // 监听9998端口的输入
        KeyedStream&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;, Tuple&amp;gt; stream1 = buildStreamFromSocket(env, 9998);

        // 监听9999端口的输入
        KeyedStream&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;, Tuple&amp;gt; stream2 = buildStreamFromSocket(env, 9999);

        SingleOutputStreamOperator&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; mainDataStream = stream1
                // 两个流连接
                .connect(stream2)
                // 执行低阶处理函数，具体处理逻辑在子类中实现
                .process(getCoProcessFunctionInstance());

        // 将低阶处理函数输出的元素全部打印出来
        mainDataStream.print();

        // 侧输出相关逻辑，子类有侧输出需求时重写此方法
        doSideOutput(mainDataStream);

        // 执行
        env.execute(&quot;ProcessFunction demo : CoProcessFunction&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;关键点之一：一共有两个数据源，每个源的处理逻辑都封装到&lt;span&gt;buildStreamFromSocket&lt;/span&gt;方法中；&lt;/li&gt;
&lt;li&gt;关键点之二：&lt;span&gt;stream1.connect(stream2)&lt;/span&gt;将两个流连接起来；&lt;/li&gt;
&lt;li&gt;关键点之三：&lt;span&gt;process&lt;/span&gt;接收CoProcessFunction实例，合并后的流的处理逻辑就在这里面；&lt;/li&gt;
&lt;li&gt;关键点之四：&lt;span&gt;getCoProcessFunctionInstance&lt;/span&gt;是抽象方法，返回&lt;span&gt;CoProcessFunction&lt;/span&gt;实例，交给子类实现，所以CoProcessFunction中做什么事情完全由子类决定；&lt;/li&gt;
&lt;li&gt;关键点之五：doSideOutput方法中啥也没做，但是在主流程代码的末尾会被调用，如果子类有侧输出(SideOutput)的需求，重写此方法即可，此方法的入参是处理过的数据集，可以从这里取得侧输出；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;子类，对连接后的双流进行操作&quot;&gt;子类，对连接后的双流进行操作&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本篇子类&lt;span&gt;CollectEveryOne.java&lt;/span&gt;如下所示，逻辑很简单，将每个源的上游数据直接输出到下游算子：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.coprocessfunction;

import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.functions.co.CoProcessFunction;
import org.apache.flink.util.Collector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CollectEveryOne extends AbstractCoProcessFunctionExecutor {

    private static final Logger logger = LoggerFactory.getLogger(CollectEveryOne.class);

    @Override
    protected CoProcessFunction&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; getCoProcessFunctionInstance() {
        return new CoProcessFunction&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt;() {

            @Override
            public void processElement1(Tuple2&amp;lt;String, Integer&amp;gt; value, Context ctx, Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; out) {
                logger.info(&quot;处理1号流的元素：{},&quot;, value);
                out.collect(value);
            }

            @Override
            public void processElement2(Tuple2&amp;lt;String, Integer&amp;gt; value, Context ctx, Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; out) {
                logger.info(&quot;处理2号流的元素：{}&quot;, value);
                out.collect(value);
            }
        };
    }

    public static void main(String[] args) throws Exception {
        new CollectEveryOne().execute();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;上述代码中，CoProcessFunction后面的泛型定义很长：&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; ，一共三个Tuple2，分别代表一号数据源输入、二号数据源输入、下游输出的类型；&lt;/li&gt;
&lt;li&gt;编码完成，运行起来试试；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;分别开启本机的&lt;span&gt;9998&lt;/span&gt;和&lt;span&gt;9999&lt;/span&gt;端口，我这里是MacBook，执行&lt;span&gt;nc -l 9998&lt;/span&gt;和&lt;span&gt;nc -l 9999&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;启动Flink应用，如果您和我一样是Mac电脑，直接运行&lt;span&gt;CollectEveryOne.main&lt;/span&gt;方法即可（如果是windows电脑，我这没试过，不过做成jar在线部署也是可以的）；&lt;/li&gt;
&lt;li&gt;在监听9998和9999端口的控制台分别输入&lt;span&gt;aaa,111&lt;/span&gt;和&lt;span&gt;bbb,222&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;以下是flink控制台输出的内容，可见processElement1和processElement2方法的日志代码已经执行，并且print方法作为最下游，将两个数据源的数据都打印出来了，符合预期：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;12:45:38,774 INFO CollectEveryOne - 处理1号流的元素：(aaa,111),
(aaa,111)
12:45:43,816 INFO CollectEveryOne - 处理2号流的元素：(bbb,222)
(bbb,222)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;至此，咱们的第一个双流处理低阶函数就完成了，对CoProcessFunction也有了最基本的认识，当然CoProcessFunction的作用远不及此，下一篇咱们借助状态让&lt;span&gt;processElement1&lt;/span&gt;和&lt;span&gt;processElement2&lt;/span&gt;分别对方处理过的状态，让每个元素的处理都和另一个流关联，不再孤立；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 29 Nov 2020 23:59:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14059326.html</dc:identifier>
</item>
<item>
<title>什么是NoSQL - DataStax</title>
<link>http://www.cnblogs.com/datastax/p/14059309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/datastax/p/14059309.html</guid>
<description>&lt;p&gt;&lt;em&gt;在本文中，我们将简单介绍什么是NoSQL、NoSQL与关系型数据库的区别、NoSQL数据库的优势以及如何使用NoSQL。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在文末，我们也将分享一些有用的资源，帮助初学者快速开始使用NoSQL。&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;什么是NoSQL&lt;/h2&gt;
&lt;p&gt;NoSQL数据库是为满足云计算的需求而设计的，它突破了传统关系型数据库对规模、性能、数据模型和数据分布的限制。&lt;/p&gt;
&lt;p&gt;NoSQL (Not-only-SQL，不只是SQL) 数据库采用与关系型数据库不同的方式来存储、分布和获取数据。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-d7feed0e25e02ede52fda3745b23fd82_1440w.jpg&quot; width=&quot;758&quot; height=&quot;342&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1020&quot; data-rawheight=&quot;460&quot; data-original=&quot;https://pic3.zhimg.com/v2-d7feed0e25e02ede52fda3745b23fd82_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d7feed0e25e02ede52fda3745b23fd82_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;最初，Facebook、Google和Amazon这样的互联网巨头希望能够在全球各地读写数据，并向数十亿用户提供高性能和高可用的保障，这就产生了对可伸缩性(scalable) 的数据管理系统的需求。于是他们创造并开始使用NoSQL。&lt;/p&gt;
&lt;p&gt;现如今，大多数公司和组织都需要通过大型应用系统来满足用户的个性化需求。而NoSQL正是可以助其一臂之力的数据库技术。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;NoSQL与关系型数据库&lt;/h2&gt;
&lt;p&gt;NoSQL和关系型数据库分别支持不同的应用需求，很多时候企业会同时使用这两种数据库来应对不同的使用场景。从技术的角度来说，区别这两者的主要标准包括：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-7a6496bb55e657ce246aeca45e31c98e_1440w.jpg&quot; width=&quot;630&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;630&quot; data-rawheight=&quot;546&quot; data-original=&quot;https://pic3.zhimg.com/v2-7a6496bb55e657ce246aeca45e31c98e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-7a6496bb55e657ce246aeca45e31c98e_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;NoSQL的优势&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NoSQL数据库最初是为了支持以云端应用为目标的、去中心化的系统所设计。相比其它数据库管理系统，像Cassandra这样的NoSQL数据库通常有以下优势：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-80983445b805b7d638d785055360a473_1440w.jpg&quot; width=&quot;180&quot; class=&quot;content_image lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;180&quot; data-rawheight=&quot;180&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-80983445b805b7d638d785055360a473_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;持续的可用性：&lt;/strong&gt;即使遭遇最为严重的基础设施故障，NoSQL数据库仍然能保持在线&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-709da39a11e0c7f87417786c5474d556_1440w.jpg&quot; width=&quot;180&quot; class=&quot;content_image lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;180&quot; data-rawheight=&quot;180&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-709da39a11e0c7f87417786c5474d556_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;环球分布：&lt;/strong&gt;不论身在何方，都能获取数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-c64ad216116101a4bb807cd18e4a5051_1440w.jpg&quot; width=&quot;180&quot; class=&quot;content_image lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;180&quot; data-rawheight=&quot;180&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c64ad216116101a4bb807cd18e4a5051_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;操作低延迟：&lt;/strong&gt;满足绝大部分密集操作的云应用的反应时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-55ce9998f074576b8af0df62ff54ece0_1440w.jpg&quot; width=&quot;180&quot; class=&quot;content_image lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;180&quot; data-rawheight=&quot;180&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-55ce9998f074576b8af0df62ff54ece0_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;线性拓展：&lt;/strong&gt;可预见的扩展和收缩满足了当下及未来的云应用需求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-950333e01608c03782ec23f999fa2a7c_1440w.jpg&quot; width=&quot;180&quot; class=&quot;content_image lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;180&quot; data-rawheight=&quot;180&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-950333e01608c03782ec23f999fa2a7c_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;功能整体性：&lt;/strong&gt;混合的工作内容和多种数据模型的紧密集成 (coherent integration) 和互用性 (interoperability)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-ae6b385416d1c976640da1fca3eef0fb_1440w.jpg&quot; width=&quot;180&quot; class=&quot;content_image lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;180&quot; data-rawheight=&quot;180&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ae6b385416d1c976640da1fca3eef0fb_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;操作成熟性：&lt;/strong&gt;为企业准备好的云应用数据管理系统&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-eacfcecbdb0c157e90cc36624d3f67d7_1440w.jpg&quot; width=&quot;180&quot; class=&quot;content_image lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;180&quot; data-rawheight=&quot;180&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-eacfcecbdb0c157e90cc36624d3f67d7_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;低拥有成本：&lt;/strong&gt;无需特殊硬件或附加软件&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2&gt;如何使用NoSQL&lt;/h2&gt;
&lt;p&gt;从现实层面来讲，应该如何开始使用NoSQL并且落实你的首个应用呢？大致来说，有三种采用NoSQL数据库的方法。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-226c64bf17373fa9287e33c2dbb8daed_1440w.jpg&quot; width=&quot;180&quot; class=&quot;content_image lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;180&quot; data-rawheight=&quot;180&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-226c64bf17373fa9287e33c2dbb8daed_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;新应用：&lt;/strong&gt;很多人从零开始使用NoSQL，是从将其应用到一个新的云服务开始的。这种方式避免了应用的重写和数据的迁移。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-764e6ae17f4938b1367c9aeeaf7a74d4_1440w.jpg&quot; width=&quot;180&quot; class=&quot;content_image lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;180&quot; data-rawheight=&quot;180&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-764e6ae17f4938b1367c9aeeaf7a74d4_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;扩编：&lt;/strong&gt;有些人选择将现有的系统扩充，添加NoSQL的元素进去。通常这种情况发生在关系型数据库管理系统不能再满足应用程序的成长需求时，此时应用程序需要一个能满足更大的规模或是更好的可用性的系统来支持。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-897763985d46de5c10c1563ef94d14bf_1440w.jpg&quot; width=&quot;180&quot; class=&quot;content_image lazy&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;180&quot; data-rawheight=&quot;180&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-897763985d46de5c10c1563ef94d14bf_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;完全替代：&lt;/strong&gt;对于一直在烧钱的系统或者是由于并发性、数据速率和数据数量产生重大问题的系统，人们通常会使用NoSQL数据库完全替代原有的系统。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2&gt;从何处开始&lt;/h2&gt;
&lt;p&gt;如果你正打算更多地学习了解Apache Cassandra，我们有很多资源帮助你顺利起航。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.datastax.com/dev&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;DataStax for Developers&lt;/a&gt;：学习如何玩转Apache Cassandra™&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.datastax.com/products/datastax-astra&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;DataStax Astra&lt;/a&gt;：通过DataStax Astra，一个基于Apache Cassandra的数据库及服务平台，能够帮你快速地建立云原生应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;References：&lt;br/&gt;　　　　&lt;/strong&gt;https://www.datastax.com/nosql&lt;/p&gt;

</description>
<pubDate>Sun, 29 Nov 2020 23:46:00 +0000</pubDate>
<dc:creator>DataStax</dc:creator>
<og:description>在本文中，我们将简单介绍什么是NoSQL、NoSQL与关系型数据库的区别、NoSQL数据库的优势以及如何使用NoSQL。 在文末，我们也将分享一些有用的资源，帮助初学者快速开始使用NoSQL。 什么是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/datastax/p/14059309.html</dc:identifier>
</item>
<item>
<title>Appium上下文和H5测试(二) - 清菡</title>
<link>http://www.cnblogs.com/qinghan123/p/14059255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qinghan123/p/14059255.html</guid>
<description>&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;坚持原创输出，点击蓝字关注我吧&lt;/span&gt;&lt;/h2&gt;&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201129210336.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：清菡&lt;br/&gt;博客：oschina、云+社区、知乎等各大平台都有。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;文章总览图&lt;/span&gt;&lt;/h2&gt;
&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201129231154.png&quot; alt=&quot;&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;一、往期回顾&lt;/span&gt;&lt;/h2&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;loc=&lt;span class=&quot;hljs-string&quot;&gt;'new UiSelector().text(&quot;全程班&quot;)'&lt;/span&gt;&lt;br/&gt;WebDriverWait(driver,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;).until(EC.visibility_of_element_located((MobileBy.ANDROID_UIAUTOMATOR,loc))&lt;br/&gt;driver.find_element_by_android_uiautomator(loc).click()&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这个步骤后进入了这个页面：&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201129133617.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入这个页面也是需要时间的。WebView 这个元素当中，放的才是 html 页面。真的等到 html 页面加载出来之后，再去获取所有相关的内容，这样比较好。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;万一切过来的时候，html 页面还没有开始加载，我就马上去获取当前所有可以操作的对象，这样很容易丢失，所以也一样要讲究等待。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲究等待，首先等到 WebView 这个元素出现。等到 WebView 这个 class 控件出现，class 值代表它的控件。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;WebDriverWait(driver,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;).until(EC.visibility_of_element_located((MobileBy.CLASS_NAME,&lt;span class=&quot;hljs-string&quot;&gt;'android.webkit.WebView'&lt;/span&gt;)))&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;1 秒钟，确保里面的 html，所有的都能加载完成。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;time.sleep(1)&lt;/code&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;二、怎么切换？&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;用什么样的语句来获取我们的 WebView、获取我们的原生控件呢？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它这个东西在我们 App 当中叫做&lt;code&gt;context&lt;/code&gt;，翻译成中文就是&lt;strong&gt;上下文。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;上下文在我们自动化中就是指可以切换的东西，就是我们的原生控件。&lt;/strong&gt; 原生控件是我们默认的，就像窗口切换就是我们默认的窗口是一样的。原生控件是它的默认上下文。打开 app，默认就是在它的原生控件当中。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebView 就是它的第二种&lt;code&gt;context&lt;/code&gt;。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201129152903.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要当前页面中有 WebView，它就会显示出来，有 2 个就会显示 2 个。如图片中这个例子中只有一个 Webview，所以它只显示一个 WebView。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201129160059.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是&lt;code&gt;context&lt;/code&gt;上下文。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有这种情况下需要切换，其它情况下都是原生控件就不需要切换，不用管它，一旦有 html 页面就需要考虑这些事情了。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;三、上下文切换&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可用的上下文（Contexts）&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列出所有可用的上下文（contexts）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;driver.contexts&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;driver.window_handles&lt;/code&gt; 获取所有窗口的 handle，返回 list 列表。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当前上下文（context）：列出当前的上下文（context）&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;driver.current_context&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;切换至默认的上下文（context）&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切换回默认的上下文（context）。（译者注：一般就是原生上下文 “NATIVE_APP”）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;driver.switch_to.context(None)&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当前 Activity：获取当前的 Acticity。仅支持 Android。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;driver.current_activity&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当前包名（package）：获取当前包名（package）。仅支持 Android 。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;driver.current_package&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上下文的操作方式在这里，和 Windows 窗口是一模一样的。和 Web 自动化中所谓的窗口是一样的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先列出所有可用的上下文。就像列出目前所有打开的窗口是一样的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个上下文，有 WebView 的时候，也是在执行代码的时候，它进入了有 WebView 的&lt;strong&gt;页面当中&lt;/strong&gt;，才会有多个，没有进入有 WebView 的页面当中只有一个 WebView 的（相当于一个大箱子，箱子打开后有多个）。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列出所有可用的上下文，再去切换至需要的上下文。怎么切换呢？他们得到的结果也是个列表啊。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列表当中放的值呢，不是原生控件就是 WebView。所以它也有下标。如果要切换的话就是&lt;code&gt;driver.switch_to.context(None)&lt;/code&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;None 表示什么呢？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表示切换回默认的上下文，按照 Web 自动化的讲法就是默认的窗口，在我们这里就是默认的原生控件里面。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想切换到 WebView 的话，&lt;code&gt;driver.contexts&lt;/code&gt;返回值 0，列表取下标 1，2，3，4 都是可以取得。也可以将你得到的 Web 名称放在&lt;code&gt;driver.switch_to.context(None)&lt;/code&gt;中替换 None 就可以了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;driver.switch_to.context(None)&lt;/code&gt;可以切进去，也可以切出来。如果你想获取当前的窗口，当前的上下文，叫做&lt;code&gt;driver.current_context&lt;/code&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的做法与窗口是一模一样的。&lt;strong&gt;Web 自动化中叫做窗口，这里叫做上下文。&lt;/strong&gt; 其它的时候不需要切换，但是有窗口需要交替的时候就必须要切换。有 iframe，需要更换 html 页面的时候就需要切换，其它情况下就不切换。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;现在在这个地方已经等到了这个所有的 WebView 出现了，所以接下来这样做：&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201129165336.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;button[@class=&quot;bottom-btn buy&quot;]&lt;/code&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201129165818.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相当于 App 自动化和 Web 自动化组合起来用了，无缝切换，不需要改什么，照着套路用就好了：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;WebDriverWait(driver,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;).until(EC.visibility_of_element_located((MobileBy.XPATH,&lt;span class=&quot;hljs-string&quot;&gt;'//button[@class=&quot;bottom-btn buy&quot;]'&lt;/span&gt;)))&lt;br/&gt;driver.find_element_by_xpath(&lt;span class=&quot;hljs-string&quot;&gt;'//button[@class=&quot;bottom-btn buy&quot;]'&lt;/span&gt;).click()&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201129173857.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;列出了当前的上下文：&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;['NATIVE_APP', 'WEBVIEW_com.tencent.mobileqq:mini', 'WEBVIEW_com.保密']&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NATIVE_APP 是当前的原生控件，按照 web 自动化来说，是默认的主窗口。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;是因为这段代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;cons=driver.contexts  &lt;br/&gt;print(cons)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201129174909.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一定要开启 webview debug 属性，如果你没有开启它，那么这 2 项，在这里获取的时候是看不到的：&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201129175328.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就只有一个了，就是 NATIVE_APP。只能看到 NATIVE_APP 是切换不到 WebView 的。一定要保证能够识别得到，才能够去切换。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 报错的时候先看第一行代码，看看在你自己当前脚本当中到底是哪一行出错了。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;四、样例代码&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手机设置中开启着显示布局边界的情况下，然后 run 代码。因为 App 界面有变更，所以代码和现有界面不一致，即&lt;strong&gt;立即购买&lt;/strong&gt;现在成了&lt;strong&gt;报名截止并跳转至 QQ 界面&lt;/strong&gt;。代码提示找不到元素请不要奇怪，因为为了便于理解，放的元素还是&lt;strong&gt;立即购买&lt;/strong&gt;的元素。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此代码只是样例，不一定保证在你的电脑上就能运行成功，请根据实际情况修改。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;16&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;26&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; appium &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; webdriver&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; time&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; selenium.webdriver.support.wait &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; WebDriverWait&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; expected_conditions &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; EC&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; appium.webdriver.common.mobileby &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; MobileBy&lt;p&gt;desired_caps={}&lt;br/&gt;desired_caps[&lt;span class=&quot;hljs-string&quot;&gt;&quot;platformName&quot;&lt;/span&gt;]=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Android&quot;&lt;/span&gt;&lt;br/&gt;desired_caps[&lt;span class=&quot;hljs-string&quot;&gt;&quot;platformVersion&quot;&lt;/span&gt;]=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot;&lt;/span&gt;&lt;br/&gt;desired_caps[&lt;span class=&quot;hljs-string&quot;&gt;&quot;deviceName&quot;&lt;/span&gt;]=&lt;span class=&quot;hljs-string&quot;&gt;&quot;2NSDU20410017297&quot;&lt;/span&gt;&lt;br/&gt;desired_caps[&lt;span class=&quot;hljs-string&quot;&gt;&quot;appPackage&quot;&lt;/span&gt;]=&lt;span class=&quot;hljs-string&quot;&gt;&quot;输入appPackage&quot;&lt;/span&gt;&lt;br/&gt;desired_caps[&lt;span class=&quot;hljs-string&quot;&gt;&quot;appActivity&quot;&lt;/span&gt;]=&lt;span class=&quot;hljs-string&quot;&gt;&quot;输入appActivity&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;driver = webdriver.Remote(&lt;span class=&quot;hljs-string&quot;&gt;'http://127.0.0.1:4723/wd/hub'&lt;/span&gt;,desired_caps)&lt;/p&gt;&lt;p&gt;loc=&lt;span class=&quot;hljs-string&quot;&gt;'new UiSelector().text(&quot;全程班&quot;)'&lt;/span&gt;&lt;br/&gt;WebDriverWait(driver,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;).until(EC.visibility_of_element_located((MobileBy.ANDROID_UIAUTOMATOR,loc)))&lt;br/&gt;driver.find_element_by_android_uiautomator(loc).click()&lt;/p&gt;&lt;p&gt;&lt;br/&gt;WebDriverWait(driver,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;).until(EC.visibility_of_element_located((MobileBy.CLASS_NAME,&lt;span class=&quot;hljs-string&quot;&gt;'android.webkit.WebView'&lt;/span&gt;)))&lt;br/&gt;time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;cons=driver.contexts  &lt;br/&gt;print(cons)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;driver.switch_to.context(cons[&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;])&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;WebDriverWait(driver,&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;).until(EC.visibility_of_element_located((MobileBy.XPATH,&lt;span class=&quot;hljs-string&quot;&gt;'//button[@class=&quot;bottom-btn buy&quot;]'&lt;/span&gt;)))&lt;br/&gt;driver.find_element_by_xpath(&lt;span class=&quot;hljs-string&quot;&gt;'//button[@class=&quot;bottom-btn buy&quot;]'&lt;/span&gt;).click()&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;遇到的问题&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;appium 报错 session not created: This version of ChromeDriver only supports Chrome version 84&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;靠谱链接：&lt;/strong&gt; https://www.codenong.com/jsb8d9e8746809/&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;温馨提示：&lt;/strong&gt; 如果你的代码没问题，还报错，那么就换 Appium 版本吧，Appium 的 bug 很多。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上篇文章 中此处代码错了，应该改成这样：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/qinghanstudy/qinghan/raw/master/img/20201129173111.png&quot; alt=&quot;&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公众号 &lt;strong&gt;清菡软件测试&lt;/strong&gt; 首发，更多原创文章：清菡软件测试 95+原创文章，欢迎关注、交流，禁止第三方擅自转载。&lt;/p&gt;
</description>
<pubDate>Sun, 29 Nov 2020 19:43:00 +0000</pubDate>
<dc:creator>清菡</dc:creator>
<og:description>坚持原创输出，点击蓝字关注我吧 作者：清菡 博客：oschina、云+社区、知乎等各大平台都有。 文章总览图 一、往期回顾 loc=&amp;amp;#39;new&amp;amp;#160;UiSelector()</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qinghan123/p/14059255.html</dc:identifier>
</item>
<item>
<title>浅析 - 被歧视的小众需求 - 木深</title>
<link>http://www.cnblogs.com/sam-zhang/p/14059209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sam-zhang/p/14059209.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/dd14e89c-528d-4294-9747-8a72c688a7ea.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=m7ZxEYok5ksMb%252BHe2wcUim4fg0Q%253D&amp;amp;Expires=1606755783&quot; width=&quot;900&quot; height=&quot;383&quot; data-ratio=&quot;0.4255555555555556&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; data-image-size=&quot;900,383&quot;/&gt;&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;❝&lt;/p&gt;
&lt;p&gt;大家好，我是木小深，高级产品经理。我们的公众号主要是分享关于产品经理个人成长和职业发展相关的话题。今天分享是的产品经理个人成长中，关于小众需求的思考。&lt;/p&gt;
❞&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「初稿｜木深、木小深」&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「编辑｜牟深、Sam、Ella」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/e2e16fa0-97da-48d8-b349-f08d360db035.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=vtaG4GJr4AAkNJ00cpugo160%252Fkw%253D&amp;amp;Expires=1606754455&quot; width=&quot;920&quot; height=&quot;920&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;920&quot; data-image-size=&quot;920,920&quot;/&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;1、开场白&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本周是自我反省的一周。设计产品的时候，我总是会按照所谓的行业标准，形成结论，给到解决方案。这种惯性思维的直接结果，就是在设计通用型产品功能的时候，会歧视小众用户的需求。例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/c872259a-e06d-4078-89e9-6495c5e170a9.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=JbbqAxqJxXrMzn%252FjFakXYcCkPgk%253D&amp;amp;Expires=1606754515&quot; width=&quot;650&quot; height=&quot;650&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;650&quot; data-image-size=&quot;650,650&quot;/&gt;&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;❝&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「需求#88」&lt;/strong&gt;：用户握手机姿势不标准，导致较难按到右下角的确认按钮。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「评审结果」&lt;/strong&gt;：不响应 - 需求小众。（当前产品阶段，没有时间精力相应此类用户需求）&lt;/p&gt;
❞&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当天夜里，我做了一个噩梦。突然一天，咱们从多数用户，变成了被歧视的小众用户。首先是，咱们只能像上图一样握手机，点不到确定按钮。其次，视觉也出现了障碍，看不见曾经清晰可见的各种按钮。最后，完全失去视觉，从此告别智能手机，被歧视小众用户的“我们”无情抛弃！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/065c61ea-5561-483b-828a-b29c80fbd7df.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=eV7%252BvmLrO3wkqq4Q7VqaBJeL9KM%253D&amp;amp;Expires=1606754564&quot; width=&quot;920&quot; height=&quot;690&quot; data-ratio=&quot;0.75&quot; data-type=&quot;jpeg&quot; data-w=&quot;920&quot; data-image-size=&quot;920,690&quot;/&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;二、大背景&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据世界卫生组织2010的统计数据显示，在中国，这个群体十分庞大。失明人士共有824.8万，全国此类存在视力障碍的人数量位列世界第一。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而2016年，视障人数的数量已经迅速增长到了1731万人，也就是说，每八十个人中，大约就有一名失明人士。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/39f0d33f-7a43-4d42-92aa-b9089ab8624d.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=UJFCanuhPTds5f5lUlPlosi38Fg%253D&amp;amp;Expires=1606754583&quot; width=&quot;1080&quot; height=&quot;1945&quot; data-ratio=&quot;1.8009259259259258&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-image-size=&quot;1080,1945&quot;/&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;三、无障碍功能设计&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;苹果设备的辅助功能多次获得大奖，为了响应全球无障碍宣传日。苹果官方网站上线了主题为“不为多数人，不为少数人”的辅助功能介绍页面。让每一个人受益的科技，才是真正强大的科技。苹果所追求的创新，不仅是强大的性能和出众的外观。真正的科技创新，应该让每个人都从中受益，当然也包括残障人士。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/f4cefbd3-4c89-4442-b5c0-c2913dceb827.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=qHfbMhdzJvj%252BTiVb4nV8tXC%252FZCo%253D&amp;amp;Expires=1606754771&quot; width=&quot;640&quot; height=&quot;360&quot; data-ratio=&quot;0.5625&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-image-size=&quot;640,360&quot;/&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;旁白功能&lt;/h3&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;❝&lt;/p&gt;
&lt;p&gt;屏幕显示什么，旁白都能告诉你。&lt;/p&gt;
❞&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;旁白功能可准确描述你的 iPhone、iPad、Mac 和 Apple Watch 上正在进行的操作，让你通过聆听就能在设备中操控浏览。Apple 的内置 app 都支持旁白功能，能通过语音引导你在其中完成各种任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/ccc4df3d-d133-4f46-ba0a-7466b38e35a4.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=DzPxoheBPI6FEVFdf9LahexMez8%253D&amp;amp;Expires=1606754938&quot; width=&quot;392&quot; height=&quot;383&quot; data-ratio=&quot;0.9770408163265306&quot; data-type=&quot;jpeg&quot; data-w=&quot;392&quot; data-image-size=&quot;392,383&quot;/&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;朗读功能&lt;/h3&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;❝&lt;/p&gt;
&lt;p&gt;使用朗读屏幕功能，把阅读变为聆听。&lt;/p&gt;
❞&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果文字被朗读出来有助于你更便利地阅读，你可使用“朗读屏幕”功能，将 iPhone 或 iPad 上的文档、网页或邮件里的文字读出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/5585d825-0156-4a93-b1d7-6aaed51d7eda.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=6P83UgApK0F4iMt7PrTiPV2rg3k%253D&amp;amp;Expires=1606754979&quot; width=&quot;316&quot; height=&quot;542&quot; data-ratio=&quot;1.7151898734177216&quot; data-type=&quot;png&quot; data-w=&quot;316&quot; data-image-size=&quot;316,542&quot;/&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;实时收听功能&lt;/h3&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;❝&lt;/p&gt;
&lt;p&gt;实时收听，阻隔噪音打扰。&lt;/p&gt;
❞&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是在喧闹的餐厅吃饭，还是在拥挤的讲堂听课，借助“实时收听”功能，你都可微调 Made for iPhone 助听器或 AirPods 来帮助你听得更清楚。要与人静静地交谈，只需将你的 iPhone 或 iPad 靠近谈话对象，设备内置的麦克风便会放大对方的话音。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;显示调节功能&lt;/h3&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;❝&lt;/p&gt;
&lt;p&gt;让显示充分适应你的眼睛。&lt;/p&gt;
❞&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你有色盲或其他视觉障碍，可以调节你的 Mac、iPad、iPhone 和 Apple Watch 的视图显示，使其更适合你观看。你可以从一系列色彩滤镜中进行选择，或加以微调。还可在所有设备上开启“反转颜色”功能，即时更改颜色值，营造更强烈的对比。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/28aec5ef-92d0-4e61-bcd8-b3fdc263d40f.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=W%252F7sKa%252FQQJlwcOozlipJfKLhT4U%253D&amp;amp;Expires=1606755037&quot; width=&quot;316&quot; height=&quot;540&quot; data-ratio=&quot;1.7088607594936709&quot; data-type=&quot;png&quot; data-w=&quot;316&quot; data-image-size=&quot;316,540&quot;/&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;人物检测功能&lt;/h3&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;❝&lt;/p&gt;
&lt;p&gt;可以识别到通过广角镜头下可拍摄到的所有人，并且通过雷达实时反馈信息提醒用户。&lt;/p&gt;
❞&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以较好的辅助盲人出行场景。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过测试可以发现，在打开人物检测功能后，当侦测到镜头范围内有人后，屏幕上会出现使用者和人的距离，并会通过扬声器或耳机进行语音提示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/eb86fa19-ca10-4c16-adda-fcd0566ac0fb.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=sCl3FwTGWTscRmzLBE%252FL5bvzDcU%253D&amp;amp;Expires=1606755251&quot; width=&quot;339&quot; height=&quot;732&quot; data-ratio=&quot;2.15929203539823&quot; data-type=&quot;png&quot; data-w=&quot;339&quot; data-image-size=&quot;339,732&quot;/&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;四、小节&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很喜欢苹果官网的这段话：&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;❝&lt;/p&gt;
&lt;p&gt;我们深信，真正的科技创新，应该让每个人都从中受益，当然也包括残障人士。所以在设计产品时，我们习惯将所有人都考虑在内，从而让每个人都能无障碍地工作、创作、沟通、健身和娱乐。&lt;strong&gt;「不为多数人，不为少数人，我们的产品设计是为了每一个人。」&lt;/strong&gt;&lt;/p&gt;
❞&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，我们今天介绍的，还仅仅是几个最基础的功能。在 iPhone 上，用户还能找到更多针对视力、听力、学习与读写、肢体与活动能力而设计的各种辅助功能。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，除了苹果以外，更多的有社会责任心的企业正在意识到这一点——科技和互联网属于每一个人。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「中国的互联网公司们也在为之努力。」&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2013 年起，中国互联网行业中就有了一个信息无障碍产品联盟，这是是一个合作型组织，由信息无障碍研究会、阿里巴巴集团、腾讯、百度、微软(中国)共同发起。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些公司可能在任何一个行业都存在竞争，但唯独在信息无障碍这件事上，只有合作学习和共同进步。有了这个组织以后，我们可以看到很多明显的变化。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过去的几年，企业们与研究会合作推动无障碍的产品从数款增加到数十款比如钉钉、手机 QQ、随手记等产品。涉及的领域从初期的社交、电商扩大到现在的云平台、手机 OS、保险、金融等领域。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或许，我们的社会还没有实现真正的信息无障碍。但不论怎么说，都要谢谢这些企业的努力。互联网属于每个人，总有一天会实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/59a3dade-bab6-4ba1-a366-6fd637efb1a9.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=nvbeBCgog9d5dYdVxc%252B%252FNgKXgKo%253D&amp;amp;Expires=1606755527&quot; width=&quot;920&quot; height=&quot;920&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;920&quot; data-image-size=&quot;920,920&quot;/&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;五、结束语&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品经理的前进道路，不应该是一场孤独求索的旅行 。沿途那些美好的风景，有趣的人文，我愿意沉淀下来，分享与同行的你，或者是在路上的他。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上，希望对小伙伴儿们有所帮助，共勉~&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你有任何问题，请在留言区告诉我们。也请记得订阅&lt;strong&gt;「公众号：木小深」&lt;/strong&gt;和我们的专栏，欢迎分享给其它有需要的人。我们这期分享就到这里了，再见❤️。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/7eb756b4-63ec-4f40-893b-1a00c04f659b.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=ALb9DNaS0gEdY4qGsGhtrcxZPMo%253D&amp;amp;Expires=1606755303&quot; width=&quot;905&quot; height=&quot;906&quot; data-ratio=&quot;1.0011049723756906&quot; data-type=&quot;jpeg&quot; data-w=&quot;905&quot; data-image-size=&quot;905,906&quot;/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201123010111117.png&quot; width=&quot;639&quot; height=&quot;443&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;387&quot; data-ratio=&quot;0.6932707355242567&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot; data-image-size=&quot;639,443&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 29 Nov 2020 17:30:00 +0000</pubDate>
<dc:creator>木深</dc:creator>
<og:description>❝ 大家好，我是木小深，高级产品经理。我们的公众号主要是分享关于产品经理个人成长和职业发展相关的话题。今天分享是的产品经理个人成长中，关于小众需求的思考。 ❞ 「初稿｜木深、木小深」 「编辑｜牟深、S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sam-zhang/p/14059209.html</dc:identifier>
</item>
<item>
<title>Kafka分布式查询引擎 - 哥不是小萝莉</title>
<link>http://www.cnblogs.com/smartloli/p/14053206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smartloli/p/14053206.html</guid>
<description>&lt;p&gt;Kafka是一个分布式消息中间件系统，里面存储着实际场景中的数据。Kafka原生是不支持点查询的，如果我们想对存储在Topic中的数据进行查询，可能需要对Topic中的数据进行消费落地，然后构建索引（或者数据落地到自带所以的存储系统中，例如HBase、Hive等）。今天，笔者就为大家来介绍如何实现Kafka分布式查询引擎。&lt;/p&gt;

&lt;p&gt;对于点查询，我们可以总结为两个要点。其一，有数据供我们查询；其二，对待查询的数据构建索引。在Kafka中，Topic存储数据，满足了第一点，虽然Kafka有索引的概念，但是它的索引是基于Offset的稀疏索引，并不是对每条Message都会构建一个索引。并且，这个Offset索引对于实际情况查询场景来说，也帮助不大。比如，你查询Topic01下的Partition_0，但是，也仅仅只是查下到某个Topic中分区下的Offset对应的一条记录，但是这条记录是啥，你并不知道。真实查询的情况，可能是你需要查询某个ID，或者模糊查询某个Name是否存在。&lt;/p&gt;
&lt;h2&gt;2.1 索引&lt;/h2&gt;
&lt;p&gt;其实有一种方式，是可行的。就是对Kafka源代码进行改造，在Broker落地每条数据的时候，构建一条索引（其实，这种方式与在原始的Kafka外面加一层Proxy类似，由Proxy充当与Client交互的角色，接收Client的数据存储并构建索引）。这样的实现方式如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/666745/202011/666745-20201128160800913-104368959.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果对Kafka源代码熟悉，有能力改造其源代码，可以在Kafka中添加对每条数据构建索引的逻辑。如果，觉得怕对Kafka的性能有影响，或者改造有难度。上述流程图的方式，也可以实现这种点查询。&lt;/p&gt;
&lt;p&gt;改造Kafka源代码添加索引，或者是Proxy的方式存储数据并构建索引，这种两种方式来说，数据上都会要冗余一倍左右的的存储容量。&lt;/p&gt;
&lt;h2&gt;2.2 单节点查询&lt;/h2&gt;
&lt;p&gt;基于上述的问题，我们对这种方案进行升级改造一下。因为很多情况下，生产环境的数据已经是运行了很长时间了，加Proxy或者改造Kafka源代码的方式适合构建一个Kafka的新集群的时候使用。对于已有的Kafka集群，如果我们要查询Topic中的数据，如何实现呢。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://www.kafka-eagle.org/&quot; target=&quot;_blank&quot;&gt;Kafka-Eagle&lt;/a&gt;中，我对Topic数据查询实现了基于SQL查询的实现方案。逻辑是这样的，编写SQL查询语句，对SQL进行解析，映射出一个Topic的Schema以及过滤条件，然后根据过滤条件消费Topic对应的数据，最后拿到数据集，通过SQL呈现出最后的结果。流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/666745/202011/666745-20201128162558608-1790384037.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但是，这样是由局限性的。由于，单节点的计算能力有限，所以对每个Partition默认查询5000条数据，这个记录是可以增加或者减少的。如果在配置文件中对这个属性增大，比如设置为了50000条，那么对应的ke.sh脚本中的内存也需要增加，因为每次查询需要的内存增加了。不然，频繁若干用户同时查询，容易造成OOM的情况。&lt;/p&gt;
&lt;p&gt;但是，通常一个Topic中存储的数据一般达到上亿条数据以上，这种方式要从上亿条或者更多的数据中查询我们想要的数据，可能就满足不了了。&lt;/p&gt;
&lt;h2&gt;2.3 分布式查询&lt;/h2&gt;
&lt;p&gt;基于这种情况，我们可以对这中单节点查询的方式进行升级改造，将它变为分布式查询。其实，仔细来看，单节点查询的方式，就是一个分布式查询的缩版。那我们需要实现这样一个分布式查询的Kafka SQL引擎呢？&lt;/p&gt;
&lt;p&gt;首先，我们可以借助Hadoop的MapReduce思想，“化繁为简，分而治之”。我们将一个Topic看成一个比较大的数据集，每次我们需要对这个数据集进行查询，可以将待查询的数据进行拆分若干份Segment，然后，充分利用服务器的CPU，进行多线程消费（&lt;strong&gt;这样就可以打破Kafka中一个线程只能消费一个分区的局限性&lt;/strong&gt;）。实现流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/666745/202011/666745-20201128170124825-501821030.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上图可知，由客户端发起请求，提交请求到Master节点，然后Master节点解析客户端的请求，并生成待执行策略。比如上述有三个工作节点，按照客户端的情况，Master会将生成的执行策略下发给三个工作节点，让其进行计算。&lt;/p&gt;
&lt;p&gt;这里以其中一个工作节点为例子，比如WorkNode1接收到了Master下发的计算任务，接收到执行指令后，结合工作节点自身的资源情况（比如CPU和内存，这里CPU较为重要），将任务进行拆解为若干个子任务（子任务的个数取决于每个批次的BatchSize，可以在属性中进行配置），然后让生成好的若干个子任务并行计算，得到若干个子结果，然后将若干个子结果汇总为一个最终结果作为当前工作节点的最终计算结果，最后将不同的工作节点的结果进行最后的Merge作为本次查询的结果返回给Master节点（这里需要注意的是，多个工作节点汇总在同一个JobID下）。然后，Master节点收到工作节点返回的结果后，返回给客户端。&lt;/p&gt;

&lt;p&gt;查询10条Topic中的数据，工作节点执行如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
select * &lt;span&gt;from&lt;/span&gt; ke1115 where `partition` &lt;span&gt;in&lt;/span&gt; (0) limit 10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/666745/202011/666745-20201128171801050-250199685.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 上图显示了，同一WorkNode节点下，同一JobID中，不同线程子任务的计算进度日志。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/666745/202011/666745-20201128172016654-734338056.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;KSqlStrategy显示了Master节点下发的待执行策略，msg表示各个工作节点返回的最终结果。&lt;/p&gt;

&lt;p&gt;目前Kafka分布式查询引擎基础功能已实现可以用，任务托管、子任务查询内存优化等还有优化的空间，计划正在考虑集成到&lt;a href=&quot;http://www.kafka-eagle.org/&quot; target=&quot;_blank&quot;&gt;KafkaEagle&lt;/a&gt;系统中。 &lt;/p&gt;

&lt;p&gt;这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！&lt;/p&gt;
&lt;p&gt;另外，博主出书了《&lt;a href=&quot;https://item.jd.com/12455361.html&quot; target=&quot;_blank&quot;&gt;Kafka并不难学&lt;/a&gt;》和《&lt;a href=&quot;https://item.jd.com/12371763.html&quot; target=&quot;_blank&quot;&gt;Hadoop大数据挖掘从入门到进阶实战&lt;/a&gt;》，喜欢的朋友或同学， 可以在公告栏那里点击购买链接购买博主的书进行学习，在此感谢大家的支持。关注下面公众号，根据提示，可免费获取书籍的教学视频。&lt;/p&gt;
</description>
<pubDate>Sun, 29 Nov 2020 16:24:00 +0000</pubDate>
<dc:creator>哥不是小萝莉</dc:creator>
<og:description>1.概述 Kafka是一个分布式消息中间件系统，里面存储着实际场景中的数据。Kafka原生是不支持点查询的，如果我们想对存储在Topic中的数据进行查询，可能需要对Topic中的数据进行消费落地，然后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/smartloli/p/14053206.html</dc:identifier>
</item>
<item>
<title>Linux下使用Docker部署nacos-server:1.4.0（单机模式），丧心病狂的我在半夜给UCloud提交了一份工单 - 你好，旧时光</title>
<link>http://www.cnblogs.com/haoxianrui/p/14059009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haoxianrui/p/14059009.html</guid>
<description>&lt;h2 id=&quot;1-拉取nacos-server镜像&quot;&gt;1. 拉取nacos-server镜像&lt;/h2&gt;
&lt;p&gt;进入 &lt;a href=&quot;https://hub.docker.com/r/nacos/nacos-server/tags?page=1&amp;amp;ordering=last_updated&quot;&gt;Docker Hub&lt;/a&gt; 查看nacos-server最新版本为 &lt;code&gt;nacos-server:1.4.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/28/q6hexgnHUjJ2OKE.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置阿里云镜像加速&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-'EOF'
{
  &quot;registry-mirrors&quot;: [&quot;https://g6jp4cfd.mirror.aliyuncs.com&quot;]
}
EOF
sudo systemctl daemon-reload
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拉取最新版本镜像(1.4.0)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker pull nacos/nacos-server
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2-创建nacos_config数据库&quot;&gt;2. 创建nacos_config数据库&lt;/h2&gt;
&lt;p&gt;MySQL创建数据库名为nacos_config并导入官方脚本&lt;br/&gt;&lt;a href=&quot;https://github.com/alibaba/nacos/blob/1.4.0/config/src/main/resources/META-INF/nacos-db.sql&quot;&gt;nacos-db.sql&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;/*
 * Copyright 1999-2018 Alibaba Group Holding Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = config_info   */
/******************************************/
CREATE TABLE `config_info` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) NOT NULL COMMENT 'data_id',
  `group_id` varchar(255) DEFAULT NULL,
  `content` longtext NOT NULL COMMENT 'content',
  `md5` varchar(32) DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '修改时间',
  `src_user` text COMMENT 'source user',
  `src_ip` varchar(20) DEFAULT NULL COMMENT 'source ip',
  `app_name` varchar(128) DEFAULT NULL,
  `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段',
  `c_desc` varchar(256) DEFAULT NULL,
  `c_use` varchar(64) DEFAULT NULL,
  `effect` varchar(64) DEFAULT NULL,
  `type` varchar(64) DEFAULT NULL,
  `c_schema` text,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info';

/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = config_info_aggr   */
/******************************************/
CREATE TABLE `config_info_aggr` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) NOT NULL COMMENT 'data_id',
  `group_id` varchar(255) NOT NULL COMMENT 'group_id',
  `datum_id` varchar(255) NOT NULL COMMENT 'datum_id',
  `content` longtext NOT NULL COMMENT '内容',
  `gmt_modified` datetime NOT NULL COMMENT '修改时间',
  `app_name` varchar(128) DEFAULT NULL,
  `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='增加租户字段';


/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = config_info_beta   */
/******************************************/
CREATE TABLE `config_info_beta` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) NOT NULL COMMENT 'group_id',
  `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name',
  `content` longtext NOT NULL COMMENT 'content',
  `beta_ips` varchar(1024) DEFAULT NULL COMMENT 'betaIps',
  `md5` varchar(32) DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '修改时间',
  `src_user` text COMMENT 'source user',
  `src_ip` varchar(20) DEFAULT NULL COMMENT 'source ip',
  `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_beta';

/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = config_info_tag   */
/******************************************/
CREATE TABLE `config_info_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `data_id` varchar(255) NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) NOT NULL COMMENT 'group_id',
  `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id',
  `tag_id` varchar(128) NOT NULL COMMENT 'tag_id',
  `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name',
  `content` longtext NOT NULL COMMENT 'content',
  `md5` varchar(32) DEFAULT NULL COMMENT 'md5',
  `gmt_create` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '修改时间',
  `src_user` text COMMENT 'source user',
  `src_ip` varchar(20) DEFAULT NULL COMMENT 'source ip',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_tag';

/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = config_tags_relation   */
/******************************************/
CREATE TABLE `config_tags_relation` (
  `id` bigint(20) NOT NULL COMMENT 'id',
  `tag_name` varchar(128) NOT NULL COMMENT 'tag_name',
  `tag_type` varchar(64) DEFAULT NULL COMMENT 'tag_type',
  `data_id` varchar(255) NOT NULL COMMENT 'data_id',
  `group_id` varchar(128) NOT NULL COMMENT 'group_id',
  `tenant_id` varchar(128) DEFAULT '' COMMENT 'tenant_id',
  `nid` bigint(20) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`nid`),
  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_tag_relation';

/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = group_capacity   */
/******************************************/
CREATE TABLE `group_capacity` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `group_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Group ID，空字符表示整个集群',
  `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值',
  `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量',
  `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值',
  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数，，0表示使用默认值',
  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值',
  `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量',
  `gmt_create` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_group_id` (`group_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='集群、各Group容量信息表';

/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = his_config_info   */
/******************************************/
CREATE TABLE `his_config_info` (
  `id` bigint(64) unsigned NOT NULL,
  `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `data_id` varchar(255) NOT NULL,
  `group_id` varchar(128) NOT NULL,
  `app_name` varchar(128) DEFAULT NULL COMMENT 'app_name',
  `content` longtext NOT NULL,
  `md5` varchar(32) DEFAULT NULL,
  `gmt_create` datetime NOT NULL DEFAULT '2010-05-05 00:00:00',
  `gmt_modified` datetime NOT NULL DEFAULT '2010-05-05 00:00:00',
  `src_user` text,
  `src_ip` varchar(20) DEFAULT NULL,
  `op_type` char(10) DEFAULT NULL,
  `tenant_id` varchar(128) DEFAULT '' COMMENT '租户字段',
  PRIMARY KEY (`nid`),
  KEY `idx_gmt_create` (`gmt_create`),
  KEY `idx_gmt_modified` (`gmt_modified`),
  KEY `idx_did` (`data_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='多租户改造';


/******************************************/
/*   数据库全名 = nacos_config   */
/*   表名称 = tenant_capacity   */
/******************************************/
CREATE TABLE `tenant_capacity` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `tenant_id` varchar(128) NOT NULL DEFAULT '' COMMENT 'Tenant ID',
  `quota` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '配额，0表示使用默认值',
  `usage` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '使用量',
  `max_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个配置大小上限，单位为字节，0表示使用默认值',
  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '聚合子配置最大个数',
  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值',
  `max_history_count` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '最大变更历史数量',
  `gmt_create` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '创建时间',
  `gmt_modified` datetime NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='租户容量信息表';


CREATE TABLE `tenant_info` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `kp` varchar(128) NOT NULL COMMENT 'kp',
  `tenant_id` varchar(128) default '' COMMENT 'tenant_id',
  `tenant_name` varchar(128) default '' COMMENT 'tenant_name',
  `tenant_desc` varchar(256) DEFAULT NULL COMMENT 'tenant_desc',
  `create_source` varchar(32) DEFAULT NULL COMMENT 'create_source',
  `gmt_create` bigint(20) NOT NULL COMMENT '创建时间',
  `gmt_modified` bigint(20) NOT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),
  KEY `idx_tenant_id` (`tenant_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='tenant_info';

CREATE TABLE users (
        username varchar(50) NOT NULL PRIMARY KEY,
        password varchar(500) NOT NULL,
        enabled boolean NOT NULL
);

CREATE TABLE roles (
        username varchar(50) NOT NULL,
        role varchar(50) NOT NULL,
        constraint uk_username_role UNIQUE (username,role)
);

CREATE TABLE permissions (
    role varchar(50) NOT NULL,
    resource varchar(512) NOT NULL,
    action varchar(8) NOT NULL,
    constraint uk_role_permission UNIQUE (role,resource,action)
);

INSERT INTO users (username, password, enabled) VALUES ('nacos', '$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu', TRUE);

INSERT INTO roles (username, role) VALUES ('nacos', 'ROLE_ADMIN');
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-创建挂载目录&quot;&gt;3. 创建挂载目录&lt;/h2&gt;
&lt;p&gt;在宿主机创建日志目录和配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    mkdir -p /home/nacos/logs                  
    mkdir -p /home/nacos/init.d          
    vim /home/nacos/init.d/custom.properties 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4-创建和启动容器&quot;&gt;4. 创建和启动容器&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;    docker run -d  --name nacos --restart=always --net=host \
    -e MODE=standalone \
    -e JVM_XMS=256m \
    -e JVM_XMX=256m \
    -e SPRING_DATASOURCE_PLATFORM=mysql \
    -e MYSQL_SERVICE_HOST= 192.168.1.99 \
    -e MYSQL_SERVICE_PORT=3306 \
    -e MYSQL_SERVICE_DB_NAME=nacos_config \
    -e MYSQL_SERVICE_USER=root \
    -e MYSQL_SERVICE_PASSWORD=123456 \
    -e MYSQL_DATABASE_NUM=1 \
    -v /home/nacos/init.d/custom.properties:/home/nacos/init.d/custom.properties \
    -v /home/nacos/logs:/home/nacos/logs \
    nacos/nacos-server
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体配置参数请参考 &lt;a href=&quot;https://nacos.io/zh-cn/docs/quick-start-docker.html&quot;&gt;Nacos官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果启动容器失败，请在宿主机目录 &lt;code&gt;/home/nacos/logs&lt;/code&gt; 查看日志。&lt;/p&gt;
&lt;p&gt;到这里就完成了nacos-server应用的部署了，可以通过链接进入到Nacos控制台。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;--net=host 指定Docker容器的网络模式为Host和宿主机在同一个网络，而不是默认的Bridge桥接模式，所以不指定端口的映射 -p 8848:8848。&lt;/p&gt;
&lt;p&gt;至于为什么没有使用Bridge网络模式，中间是有些插曲的，先申明下我使用的云服务器是UCloud家的。&lt;/p&gt;
&lt;p&gt;最开始使用的Bridge模式，创建和启动容器之后，然后关闭了内外网防火墙，准备访问nacos控制台截个图时，悲剧悄然发生。&lt;/p&gt;
&lt;p&gt;原以为，实指望，谁料想，怎奈何。这十二个字，写尽了所有我的悲伤。&lt;/p&gt;
&lt;p&gt;啊，我怎么访问不到~&lt;/p&gt;
&lt;p&gt;在我的电脑telnet端口8848同样没反应，内网防火墙完全关闭的，自然就想着甩锅到UCloud上，配置的外网防火墙的开放端口没有生效吧。然后快到半夜给UCloud提交了个工单~这里不得不说UCloud技术售后是真的好，这个点提交不到一分钟就给回复了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/29/bhsVrjte2PkwZIL.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到的结果就是UCloud云服务器不支持tcp6的监听(先不说tcp6兼容tcp4的事，关键只认tcp4监听)，而使用Bridge模式启动的容器默认只开启了tcp6的监听，所以就导致无法访问应用的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/29/jvhZuMlKQHtaV7G.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以就想办法看能不能开启容器的tcp4监听咯，其实搜索下docker、tcp6、监听无法访问 等关键词会发现很多类似的问题，系统是Centos 8.0，试用了好几个方案都不可行。不知道配置才能使Docker容器开启tcp4的监听，所以也在这里问一下各位童鞋，麻烦知道的告知一下。&lt;/p&gt;
&lt;p&gt;最后没辙，只能选择Host模式来避开docker-proxy映射的端口监听默认是tcp6的问题。&lt;/p&gt;
&lt;p&gt;以下是使用 &lt;code&gt;--net = host&lt;/code&gt; 设置网络为Host模式的端口监听信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/29/fyRWljm6O2sQFbu.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-nacos控制台访问测试&quot;&gt;4. nacos控制台访问测试&lt;/h2&gt;
&lt;p&gt;访问: &lt;a href=&quot;http://106.75.231.227:8848/nacos&quot;&gt;http://106.75.231.227:8848/nacos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用户名/密码: nacos/nacos&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/29/zJPehjT4Xk75coE.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-总结&quot;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hxrui/youlai-mall.git&quot;&gt;youlai-mall&lt;/a&gt; (Spring Cloud +Spring Cloud Alibaba + Vue 前后端分离一套商城项目) 暂处于开发阶段，并没有部署到线上，大家只能在本地搭建看到效果，其实挺不方便的，所以准备在云服务器部署一套环境。但没成想，一件很容易的事情居然耽误了那么久的时间，仅仅是因为UCloud云服务器不支持tcp6的监听，但是另外几台阿里云的服务器不会在使用Docker的过程中有这样的问题。所以写了这篇文章希望能帮助到各位童鞋少走点弯路。&lt;/p&gt;
&lt;p&gt;最后附上项目往期系列文章，对项目有兴趣的小伙伴欢迎随时联系我（微信号：haoxianrui）~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附：往期文章链接&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;后端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13581881.html&quot;&gt;Spring Cloud实战 | 第一篇：Windows搭建Nacos服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13584204.html&quot;&gt;Spring Cloud实战 | 第二篇：Spring Cloud整合Nacos实现注册中心&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13585125.html&quot;&gt;Spring Cloud实战 | 第三篇：Spring Cloud整合Nacos实现配置中心&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13608650.html&quot;&gt;Spring Cloud实战 | 第四篇：Spring Cloud整合Gateway实现API网关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13615592.html&quot;&gt;Spring Cloud实战 | 第五篇：Spring Cloud整合OpenFeign实现微服务之间的调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13719356.html&quot;&gt;Spring Cloud实战 | 第六篇：Spring Cloud Gateway+Spring Security OAuth2+JWT实现微服务统一认证授权&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13740264.html&quot;&gt;Spring Cloud实战 | 最七篇：Spring Cloud Gateway+Spring Security OAuth2集成统一认证授权平台下实现注销使JWT失效方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14022632.html&quot;&gt;Spring Cloud实战 | 最八篇：Spring Cloud +Spring Security OAuth2+ Vue前后端分离模式下无感知刷新实现JWT续期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14022632.html&quot;&gt;Spring Cloud实战 | 最九篇：Spring Security OAuth2认证服务器统一认证自定义异常处理&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;管理前端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13624548.html&quot;&gt;vue-element-admin实战 | 第一篇： 移除mock接入后台，搭建有来商城youlai-mall前后端分离管理平台&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13676619.html&quot;&gt;vue-element-admin实战 | 第二篇： 最小改动接入后台实现根据权限动态加载菜单&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;微信小程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13882310.html&quot;&gt;vue+uniapp商城实战 | 第一篇：【有来小店】微信小程序快速开发接入Spring Cloud OAuth2认证中心完成授权登录&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 29 Nov 2020 15:52:00 +0000</pubDate>
<dc:creator>你好，旧时光</dc:creator>
<og:description>1. 拉取nacos-server镜像 进入 Docker Hub 查看nacos-server最新版本为 nacos-server:1.4.0 配置阿里云镜像加速 sudo mkdir -p /et</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haoxianrui/p/14059009.html</dc:identifier>
</item>
<item>
<title>【Go语言绘图】gg 库的基本使用 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/14058811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/14058811.html</guid>
<description>&lt;p&gt;最近接了个比较大的需求，需要做很多图片处理的事情，比如图片的旋转裁截拼接，各种渐变处理，文字排列，一开始光是想想就头疼。但没有办法，既然已经需求已经到手上了，那就得把它做好才行，于是便开始被迫营业，无证上岗了。&lt;/p&gt;
&lt;p&gt;经过一番查找，找到了一个Go语言图片处理的库，经过调研发现还挺强的，能满足需求，于是决定写点文章，记录一下使用心得，以便日后不时之需。&lt;/p&gt;
&lt;h2 id=&quot;gg-库的安装和简单使用&quot;&gt;gg 库的安装和简单使用&lt;/h2&gt;
&lt;p&gt;使用之前，我们当然得先来安装一下这个库：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;go get -u github.com/fogleman/gg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个库的一个好处是有很多测试代码，可以拿来跑跑看，就知道它大概能实现什么样的效果了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201129225727088-1249761080.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是它例子的大概效果图，可以看到，能实现的图形效果还是挺多的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201129225740020-772172306.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们拿其中的一个代码来简单体验一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import &quot;github.com/fogleman/gg&quot;

func main() {
    dc := gg.NewContext(1000, 1000)
    dc.DrawCircle(500, 500, 400)
    dc.SetRGB(0, 0, 0)
    dc.Fill()
    dc.SavePNG(&quot;out.png&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;duang 的一下，一张黑不溜秋的圆形图就生成了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201129225752581-1808981032.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于上面的代码，下面会进行逐一说明。&lt;/p&gt;
&lt;h2 id=&quot;调整生成图片的大小&quot;&gt;调整生成图片的大小&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;dc := gg.NewContext(1000, 1000)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是先初始化一个 &lt;code&gt;Context&lt;/code&gt; 对象，使用库之前都需要先初始化一个 &lt;code&gt;Context&lt;/code&gt; 对象，后面的两个 &lt;code&gt;1000&lt;/code&gt;，分别对应着最终生成图片的宽度和高度。我们可以修改一下高度为 &lt;code&gt;500&lt;/code&gt; 看看效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;dc := gg.NewContext(1000, 500)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201129225806025-180282236.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到图片被腰斩了，高度矮了一半，同样修改宽度参数也可以得到类似的效果，这里就不演示了。&lt;/p&gt;
&lt;h2 id=&quot;调整圆形参数&quot;&gt;调整圆形参数&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;dc.DrawCircle(500, 500, 400)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是画一个圆心位置在 &lt;code&gt;(500,500)&lt;/code&gt;，半径为 &lt;code&gt;400&lt;/code&gt; 的圆形。需要说明的一点是，这里的坐标轴是以左上角为原点的，水平向右是横轴正方向，竖直向下是纵轴正方向，所以&lt;code&gt;(500,500)&lt;/code&gt;正是中心位置。我们可以调整一下参数值来看下效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;dc := gg.NewContext(1000, 1000)
dc.DrawCircle(300, 300, 400)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201129225840255-1996907694.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，圆心往左上角移动了。还可以调整一下半径参数试试：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;dc := gg.NewContext(1000, 1000)
dc.DrawCircle(300, 300, 300)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201129225818459-305671084.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们又得到了一个完整的圆。&lt;/p&gt;
&lt;h2 id=&quot;调整颜色&quot;&gt;调整颜色&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;dc.SetRGB(0, 0, 0)
dc.Fill()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两句的意思是先设置颜色值为 &lt;code&gt;(0,0,0)&lt;/code&gt;，也就是黑色，乍眼一看这三个值分别对应的是颜色的 &lt;code&gt;R、G、B&lt;/code&gt;值，但实际上完全不是这么回事，这里需要注意的是，这三个值分别代表红色、绿色、蓝色的程度，所以如果分别设置为，会得到下面的三张图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201129225852663-1357357809.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201129225900851-492786722.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201129225906915-1588397281.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那如果想要根据RGB值来设置颜色该怎么处理呢？其实也很简单，做一个压缩映射即可，&lt;code&gt;RGB&lt;/code&gt;值的范围是0～255，表示的含义也是对应色值的程度，这里不过将范围变成了0～1，那我们将需要使用到的值除以255就可以得到对应的映射值了。具体的颜色RGB值跟颜色的对应关系可以在网上搜到。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tool.oschina.net/commons?type=3&quot;&gt;https://tool.oschina.net/commons?type=3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我们用淡黄色做一个例子，对应的 &lt;code&gt;RGB&lt;/code&gt; 值是 &lt;code&gt;(255,222,173)&lt;/code&gt; ，我们添加一下映射转换的代码即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var rbgConverter = func(r []float64) []float64 {
        result := make([]float64, 0)
        for i := 0; i &amp;lt; len(r); i++ {
                result = append(result, r[i] / 255)
        }
        return result
}

func main() {
        dc := gg.NewContext(1000, 1000)

        dc.DrawCircle(500, 500, 400)

        rgb := []float64{255,222,173}
        newRgb := rbgConverter(rgb)

        dc.SetRGB(newRgb[0], newRgb[1], newRgb[2])
        dc.Fill()
        dc.SavePNG(&quot;out.png&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就得到了一张黄图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201129225919489-1939358509.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;保存图片&quot;&gt;保存图片&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;dc.SavePNG(&quot;out.png&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SavePNG()&lt;/code&gt; 方法可以将当前图形保存成 &lt;code&gt;PNG&lt;/code&gt; 格式文件，路径可以是相对路径，也可以是绝对路径。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SaveJPG()&lt;/code&gt; 方法可以将当前图形保存成 &lt;code&gt;JPG&lt;/code&gt; 格式文件。&lt;/p&gt;
&lt;p&gt;当然，这里的两个方法其实也只是包装了一下，点进代码可以看到，里面并没有什么奇奇怪怪的逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// SavePNG encodes the image as a PNG and writes it to disk.
func (dc *Context) SavePNG(path string) error {
        return SavePNG(path, dc.im)
}

func SavePNG(path string, im image.Image) error {
        file, err := os.Create(path)
        if err != nil {
                return err
        }
        defer file.Close()
        return png.Encode(file, im)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，我们也可以根据自己的需要将图片保存成其它格式或者存到其它地方。&lt;/p&gt;
&lt;h2 id=&quot;加载图片&quot;&gt;加载图片&lt;/h2&gt;
&lt;p&gt;加载图片有三个方法可以实现，&lt;code&gt;LoadPNG()&lt;/code&gt; 用来加载 &lt;code&gt;PNG&lt;/code&gt; 格式的图片，&lt;code&gt;LoadJPG()&lt;/code&gt; 用来加载 &lt;code&gt;JPG&lt;/code&gt; 格式的图片，如果不清楚该用什么方法，可以直接使用 &lt;code&gt;LoadImage()&lt;/code&gt; 方法来加载图片。&lt;/p&gt;
&lt;p&gt;加载图片后，得到的是一个 &lt;code&gt;image.Image&lt;/code&gt; 对象，可以通过该对象来获取图片的一些基本信息，如：图片的长和宽、图片某一点的颜色RGB值。&lt;/p&gt;
&lt;p&gt;加载图片之后，可以使用 &lt;code&gt;DrawImage()&lt;/code&gt; 方法来将图片绘制出来，以便用于后续操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;im, err := gg.LoadImage(&quot;/Users/bytedance/Desktop/test.jpg&quot;)
if err != nil {
    panic(err)
}
w := im.Bounds().Size().X
h := im.Bounds().Size().Y

dc := gg.NewContext(h, w)
dc.DrawImage(im, 0, 0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;裁剪&quot;&gt;裁剪&lt;/h2&gt;
&lt;p&gt;有一个经常使用到的方法叫 &lt;code&gt;Clip()&lt;/code&gt; ，该方法可以将图像进行裁剪，裁剪的形状取决于之前画的图形。&lt;/p&gt;
&lt;p&gt;下面来举个例子，这是我们要裁剪的图，我们用一个圆形来对它进行裁剪。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201129225955407-1226785362.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func main() {
    // 加载图片，这里路径换成自己的
        im, err := gg.LoadImage(&quot;test.jpg&quot;)
        if err != nil {
                panic(err)
        }

    // 获取图片的宽度和高度
        w := im.Bounds().Size().X
        h := im.Bounds().Size().Y

        dc := gg.NewContext(h, w)
    
    
    // 取宽度和高度的最小值作为直径
        radius := math.Min(float64(w), float64(h)) / 2
    // 画圆形
        dc.DrawCircle(float64(w/2), float64(h/2), radius)
    // 对画布进行裁剪
        dc.Clip()
    // 加载图片
        dc.DrawImage(im, 0, 0)
        dc.SavePNG(&quot;out.png&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201129225944595-1790763691.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样一来，头像就做好了【手动狗头】。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;Go 语言也可以实现对图片进行很多类型的操作，今天主要介绍了图片的加载、保存、绘制圆形、调整大小和颜色以及裁剪。之后还会进一步介绍其它功能。&lt;/p&gt;
&lt;p&gt;我觉得如果不是需要使用并没有熟悉它的必要，但知道有这么个东西，知道它能实现什么样的效果，可以让你手上的牌又多了一张，以后有需要的时候便不至于捉襟见肘了。所以还在等什么，赶紧点赞收藏加关注吧～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1043143/202011/1043143-20201129231140317-1903446423.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 29 Nov 2020 15:12:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<og:description>最近接了个比较大的需求，需要做很多图片处理的事情，比如图片的旋转裁截拼接，各种渐变处理，文字排列，一开始光是想想就头疼。但没有办法，既然已经需求已经到手上了，那就得把它做好才行，于是便开始被迫营业，无</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mfrank/p/14058811.html</dc:identifier>
</item>
<item>
<title>系统架构性能优化思路 - 常见-youmen</title>
<link>http://www.cnblogs.com/you-men/p/14058806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/you-men/p/14058806.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201129231132130-246094198.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这篇文章重点还是谈已经上线的业务系统后续出现性能问题后的问题诊断和优化重点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;系统性能问题分析流程&quot;&gt;系统性能问题分析流程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201129231142925-51593396.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们首先来分析下如果一个业务系统上线前没有性能问题，而在上线后出现了比较严重的性能问题，那么实际上潜在的场景主要来自于以下几个方面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                1.业务出现大并发的访问，导致出现性能瓶颈

    2.上线后的系统数据库数据日积月累，数据量增加后出现性能瓶颈
    3.其它关键环境改变，比如我们常说的网络带宽影响
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;正是由于这个原因，当我们发现性能问题的时候，首先就需要判断是单用户非并发状态下本身就有性能问题，还是说在并发状态才存在性能问题。对于单用户性能问题往往比较容易测试和验证，对于并发性能问题我们可以在测试环境进行加压测试和验证，以判断并发下的性能。&lt;/p&gt;
&lt;p&gt;如果是单用户本身就存在性能问题，那么大部分问题都出在程序代码和SQL需要进一步优化上面。如果是并发性能问题，我们就需要进一步分析数据库和中间件本身的状态，看是否需要对中间件进行性能调优。&lt;/p&gt;
&lt;p&gt;在加压测试过程中，我们还需要对CPU，内存和JVM进行监控，观察是否存在类似内存泄漏无法释放等情况，即并发下性能问题本身也可能是代码本身原因导致性能异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;性能问题影响因素分析&quot;&gt;性能问题影响因素分析&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201129231157675-1762583759.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对于性能问题影响因素，简单来说包括了硬件环境，软件运行环境和软件程序三个方面的主要内容。下面分别再展开说明下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;硬件环境&quot;&gt;硬件环境&lt;/h4&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;硬件环境就是我们常说的计算，存储和网络资源。&lt;/p&gt;
&lt;p&gt;对于服务器的计算能力，一般来说厂家都会提供TPMC参数作为一个参考数据，但是我们实际看到相同TPMC能力下的X86服务器能力仍然低于小型机的能力。&lt;/p&gt;
&lt;p&gt;除了服务器的计算能力参数，另外一个重点就是我们说的存储设备，影响到存储的重点又是IO读写性能问题。有时候我们监控发现CPU和内存居高不下，而真正的瓶颈通过分析反而发现是由于IO瓶颈导致，由于读写性能跟不上，导致大量数据无法快速持久化并释放内存资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201129231208527-1508755352.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;比如在Linux环境下，本身也提供了性能监控工具方便进行性能分析。比如常用的iostat,ps,sar,top,vmstat等，这些工具可以对CPU，内存，JVM，磁盘IO等进行性能监控和分析，以发现真正的性能问题在哪里。&lt;/p&gt;
&lt;p&gt;比如我们常说的内存使用率持续告警，你就必须发现是高并发调用导致，还是JVM内存泄漏导致，还是本身由于磁盘IO瓶颈导致。&lt;/p&gt;
&lt;p&gt;对于CPU，内存，磁盘IO性能监控和分析的一个思路可以参考：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201129231222428-365220635.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;运行环境-数据库和应用中间件&quot;&gt;运行环境-数据库和应用中间件&lt;/h4&gt;
&lt;p&gt;数据库和应用中间件性能调优是另外一个经常出现性能问题的地方。&lt;/p&gt;
&lt;h5 id=&quot;数据库性能调优&quot;&gt;数据库性能调优&lt;/h5&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;拿Oracle数据库来说，影响数据库性能的因素包括：系统、数据库、网络。数据库的优化包括：优化数据库磁盘I/O、优化回滚段、优化Rrdo日志、优化系统全局区、优化数据库对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201129231234621-167440207.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;要调整首先就需要对数据库性能进行监控&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们可以在init.ora参数文件中设置TIMED_STATISTICS=TRUE 和在你的会话层设置ALTER SESSION SET STATISTICS=TRUE 。运行svrmgrl 用 connect internal 注册，在你的应用系统正常活动期间，运行utlbstat.sql 开始统计系统活动，达到一定的时间后，执行utlestat.sql 停止统计。统计结果将产生在report.txt 文件中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;数据库性能优化应该是一个持续性的工作，一个方面是本身的性能和参数巡检，另外一个方面就是DBA也会经常提取最占用内存的低效SQL语句给开发人员进一步分析，同时也会从数据库本身的以下告警KPI指标中发现问题。&lt;/p&gt;
&lt;p&gt;比如我们可能会发现Oracle数据库出现内存使用率高的告警，而通过检查会发现是产生了大量的Redo日志导致，那么我们就需要从程序上进一步分析为何会产生如此多的回滚。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;应用中间件性能分析和调优&quot;&gt;应用中间件性能分析和调优&lt;/h5&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;应用中间件容器即我们常说的Weblogic, Tomcat等应用中间件容器或Web容器。应用中间件调优一个方面是本身的配置参数优化设置，一个方面就是JVM内存启动参数调优。&lt;/p&gt;
&lt;p&gt;对于应用中间件本身的参数设置，主要包括了JVM启动参数设置，线程池设置，连接数的最小最大值设置等。如果是集群环境，还涉及到集群相关的配置调优。&lt;/p&gt;
&lt;p&gt;对于JVM启动参数调优，往往也是应用中间件调优的一个关键点，但是一般JVM参数调优会结合应用程序一起进行分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201129231245099-1633566988.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;比如我们常见的JVM堆内存溢出，如果程序代码没有内存泄漏问题的话，我就需要考虑调整JVM启动时候堆内存设置。在32位操作系统下只能够设置到4G，但是在64位操作系统下已经可以设置到8G甚至更大的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;其中JVM启动的主要控制参数说明如下:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                -Xmx设置最大堆空间
    -Xms设置最小堆空间
    -XX:MaxNewSize设置最大新生代空间
    -XX:NewSize设置最小新生代空间
    -XX:MaxPermSize设置最大永久代空间(注：新内存模型已经替换为Metaspace)
    -XX:PermSize设置最小永久代空间(注：新内存模型已经替换为Metaspace)
    -Xss设置每个线程的堆栈大小
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;那么这些值究竟设置多大合适，具体来讲：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201129231256652-79578222.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Java整个堆大小设置，Xmx 和 Xms设置为老年代存活对象的3-4倍，即FullGC之后的老年代内存占用的3-4倍。永久代 PermSize和MaxPermSize设置为老年代存活对象的1.2-1.5倍。&lt;/p&gt;
&lt;p&gt;年轻代Xmn的设置为老年代存活对象的1-1.5倍。&lt;/p&gt;
&lt;p&gt;老年代的内存大小设置为老年代存活对象的2-3倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                注意在新的JVM内存模型下已经没有PermSize而是变化为Metaspace，
                因此需要考虑Heap内存和Metaspace大小的配比，同时还需要考虑相关的垃圾回收机制是采用哪种类型等。
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;对于JVM内存溢出问题，我前面写过一篇专门的分析文章可以参考。&lt;/p&gt;
&lt;p&gt;从表象到根源-一个软件系统JVM内存溢出问题分析解决全过程&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201129231307417-1117198418.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;软件程序性能问题分析&quot;&gt;&lt;strong&gt;软件程序性能问题分析&lt;/strong&gt;&lt;/h5&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;在这里首先要强调的一点就是，当我们发现性能问题后首先想到的就是扩展资源，但是大部分的性能问题本身并不是资源能力不够导致，而是我们程序实现上出现明显缺陷。&lt;/p&gt;
&lt;p&gt;比如我们经常看到的大量循环创建连接，资源使用了不释放，SQL语句低效执行等。&lt;/p&gt;
&lt;p&gt;为了解决这些性能问题，最好的方法仍然是在事前控制。其中包括了事前的代码静态检查工具的使用，也包括了开发团队对代码进行的Code Review来发现性能问题。&lt;/p&gt;
&lt;p&gt;所有已知的问题都必须形成开发团队的开发规范要求，避免重复再犯。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;业务系统性能问题扩展思考&quot;&gt;业务系统性能问题扩展思考&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;对于业务系统的性能优化，除了上面谈到的标准分析流程和分析要素外，再谈下其它一些性能问题引发的关键思考。&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;上线前的性能测试是否有用&quot;&gt;上线前的性能测试是否有用&lt;/h5&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有时候大家可能觉得奇怪，为何我们系统上线前都做了性能测试，为何上线后还是会出现系统性能问题。那么我们可以考虑下实际上我们上线前性能测试可能存在的一些无法真实模拟生产环境的地方，具体为：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                硬件能否完全模拟真实环境？最好的性能测试往往是直接在搭建完成的生产环境进行。

    数据量能否模拟实际场景？真实场景往往是多个业务表都已经存在大数据量的积累而非空表。

    并发能否模拟真实场景？一个是需要录制复合业务场景，一个是需要多台压测机。
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;而实际上我们在做性能测试的时候以上几个点都很难真正做到，因此要想完全模拟出生产真实环境是相当困难的，这也导致了很多性能问题是在真正上线后才发现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;系统本身水平弹性扩展是否完全解决性能问题&quot;&gt;系统本身水平弹性扩展是否完全解决性能问题&lt;/h5&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;第二个点也是我们经常谈的比较多的点，就是我们的业务系统在进行架构设计的时候，特别是面对非功能性需求，我们都会谈到系统本身的数据库，中间件都采用了集群技术，能够做到弹性水平扩展。那么这种弹性水平扩展能力是否又真正解决了性能问题？&lt;/p&gt;
&lt;p&gt;实际上我们看到对于数据库往往很难真正做到无限的弹性水平扩展，即使对于Oracle RAC集群往往也是最多扩展到单点的2到3倍性能。对于应用集群往往可以做到弹性水平扩展，当前技术也比较成熟。&lt;/p&gt;
&lt;p&gt;当中间件能够做到完全弹性扩展的时候，实际上仍然可能存在性能问题，即随着我们系统的运行和业务数据量的不断积累增值。实际上你可以看到往往非并发状态下的单用户访问本身就很慢，而不是说并发上来后慢。因此也是我们常说的要给点，即：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                单点访问性能正常的时候可以扩展集群来应对大并发状态下的同时访问

                单点访问本身性能就有问题的时候，要优先优化单节点访问性能
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;业务系统性能诊断的分类&quot;&gt;&lt;strong&gt;业务系统性能诊断的分类&lt;/strong&gt;&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对于业务系统性能诊断，如果从静态角度我们可以考虑从以下三个方面进行分类:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                操作系统和存储层面
                中间件层面(包括了数据库,应用服务器中间件)
                软件层面(包括了数据库SQL和存储过程,逻辑层,前端展现层等)
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;那么一个业务系统应用功能出现问题了，我们当然也可以从动态层面来看实际一个应用请求从调用开始究竟经过了哪些代码和硬件基础设施，通过分段方法来定位和查询问题。&lt;/p&gt;
&lt;p&gt;比如我们常见的就是一个查询功能如果出现问题了，首先就是找到这个查询功能对应的SQL语句在后台查询是否很慢，如果这个SQL本身就慢，那么就要优化优化SQL语句。如果SQL本身快但是查询慢，那就要看下是否是前端性能问题或者集群问题等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;软件代码的问题往往是最不能忽视的一个性能问题点&quot;&gt;&lt;strong&gt;软件代码的问题往往是最不能忽视的一个性能问题点&lt;/strong&gt;&lt;/h5&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;对于业务系统性能问题，我们经常想到的就是要扩展数据库的硬件性能，比如扩展CPU和内存，扩展集群，但是实际上可以看到很多应用的性能问题并不是硬件性能导致的，而是由于软件代码性能引起的。对于软件代码常见的性能问题我在以往的博客文章里面也谈过到，比较典型的包括了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                循环中初始化大的结构对象，数据库连接等
    资源不释放导致的内存泄露等
    没有基于场景需求来适度通过缓存等方式提升性能
    长周期事务处理耗费资源
    处理某一个业务场景或问题的时候，没有选择最优的数据结构或算法
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以上都是常见的一些软件代码性能问题点，而这些往往需要通过我们进行Code Review或代码评审的方式才能够发现出来。因此如果要做全面的性能优化，对于软件代码的性能问题排查是必须的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;通过IT资源监控或APM应用工具来发现性能问题&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201129231316720-1367224614.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;对于性能问题的发现一般有两条路径，一个就是通过我们IT资源的监控，APM的性能监控和预警来提前发现性能问题，一个是通过业务用户在使用过程中的反馈来发现性能问题。&lt;/p&gt;
&lt;p&gt;APM应用性能管理主要指对企业的关键业务应用进行监测、优化，提高企业应用的可靠性和质量，保证用户得到良好的服务，降低IT总拥有成本(TCO)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;资源池-》应用层-》业务层&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;这个可以理解为APM的一个关键点，原有的网管类监控软件更多的是资源和操作系统层面，包括计算和存储资源的使用和利用率情况，网络本身的性能情况等。但是当要分析所有的资源层问题如何对应到具体的应用，对应到具体的业务功能的时候很难。&lt;/p&gt;
&lt;p&gt;传统模式下，当出现CPU或内存满负荷的时候，如果要查找到具体是哪个应用，哪个进程或者具体哪个业务功能，哪个sql语句导致的往往并不是容易的事情。在实际的性能问题优化中往往也需要做大量的日志分析和问题定位，最终才可能找到问题点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                比如在我们最近的项目实施中，结合APM和服务链监控，我们可以快速的发现究竟是哪个服务调用出现了性能问题，
                或者快速的定位出哪个SQL语句有验证的性能问题。这个都可以帮助我们快速的进行性能问题分析和诊断。
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;资源上承载的是应用，应用本身又包括了数据库和应用中间件容器，同时也包括了前端；在应用之上则是对应到具体的业务功能。因此APM一个核心就是要将资源-》应用-》功能之间进行整合分析和衔接。&lt;/p&gt;
&lt;p&gt;而随着DevOps和自动化运维的思路推进，我们更加希望是通过APM等工具主动监控来发现性能问题，对于APM工具最大的好处就是可以进行服务全链路的性能分析，方便我们发现性能问题究竟发生在哪里。比如我们提交一个表单很慢，通过APM分析我们很容易发现究竟是调用哪个业务服务慢，或者是处理哪个SQL语句慢。这样可以极大的提升我们性能问题分析诊断的效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;来源&lt;/code&gt; &lt;a href=&quot;https://4m.cn/rN8IB&quot;&gt;https://4m.cn/rN8IB&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 29 Nov 2020 15:11:00 +0000</pubDate>
<dc:creator>常见-youmen</dc:creator>
<og:description>这篇文章重点还是谈已经上线的业务系统后续出现性能问题后的问题诊断和优化重点。 系统性能问题分析流程 我们首先来分析下如果一个业务系统上线前没有性能问题，而在上线后出现了比较严重的性能问题，那么实际上潜</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/you-men/p/14058806.html</dc:identifier>
</item>
</channel>
</rss>