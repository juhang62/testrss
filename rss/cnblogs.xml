<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于 HTML5 WebGL 的智慧城市（一） - HT学习笔记</title>
<link>http://www.cnblogs.com/htdaydayup/p/12047850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/htdaydayup/p/12047850.html</guid>
<description>&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;中共中央、国务院在今年12月印发了《&lt;/span&gt;&lt;a href=&quot;http://www.gov.cn/zhengce/2019-12/01/content_5457442.htm?tdsourcetag=s_pcqq_aiomsg&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;长江三角洲区域一体化发展规划纲要&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》(下文简称《纲要》&lt;span&gt;)&lt;/span&gt;，并发出通知，要求各地区各部门结合实际认真贯彻落实。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;《纲要》强调，要提升基础设施互联互通水平，打造数字长三角，协同建设新一代信息基础设施，共同推动重点领域智慧应用。大力发展基于物联网、大数据、人工智能的专业化服务，提升各领域融合发展、信息化协同和精细化管理水平。围绕城市公共管理、公共服务、公共安全等领域，支持有条件的城市建设基于人工智能和&lt;/span&gt; &lt;span&gt;5G&lt;/span&gt;&lt;span&gt; 物联的城市大脑集群。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;城市治理和管理不仅是国家治理体系的重要组成部分，同时也是全球互联网治理体系的重要载体和构建网络空间命运共同体的重要基础。上个月我们发布了一篇文章《&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/htdaydayup/p/11898465.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;基于&lt;/span&gt; HTML5 WebGL 构建智能城市 3D 场景&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》，大体介绍了如何使用&lt;/span&gt; &lt;span&gt;ht.js&lt;/span&gt;&lt;span&gt; &lt;span&gt;快速&lt;/span&gt;&lt;/span&gt; &lt;span&gt;3D  &lt;/span&gt;&lt;span&gt;建模，展示了良好的可视化效果，今天继续探讨智慧城市的应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;demo&lt;/span&gt;:&lt;span&gt; &lt;/span&gt;&lt;a href=&quot;http://www.hightopo.com/demo/city/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.hightopo.com/demo/city/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;功能点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;应急响应&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;交通情况&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;城市漫游&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;工程情况&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;1.应急响应&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;随着城市化、工业化、信息化进程加快,各种风险隐患层出不穷&lt;span&gt;,&lt;/span&gt;突发事件频繁发生&lt;span&gt;,&lt;/span&gt;已经从&lt;span&gt;“&lt;/span&gt;非常态化&lt;span&gt;”&lt;/span&gt;的偶发事件演变成了&lt;span&gt;“&lt;/span&gt;常态化&lt;span&gt;”&lt;/span&gt;的频发事件&lt;span&gt;,&lt;/span&gt;直接威胁着公众的生命财产安全。为了及时、有效、妥善地处置各种城市突发事件&lt;span&gt;,&lt;/span&gt;必须建立统一领导的指挥系统、常备不懈的保障系统和防患未然的防范系统&lt;span&gt;,&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img title=&quot; 模拟应急响应动画（4倍速）&quot; src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191216104216733-519120101.gif&quot; alt=&quot; 模拟应急响应动画（4倍速）&quot; width=&quot;550&quot; height=&quot;255&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;上图主要以&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 2/3D&lt;/span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;联动的方式，依次展示了在面对突发情况下，城市应急救援的响应过程。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;步骤：事故定位-&amp;gt;告警设施自启动&lt;span&gt;-&amp;gt;&lt;/span&gt;电力切断&lt;span&gt;-&amp;gt;&lt;/span&gt;油气截断阀启动&lt;span&gt;-&amp;gt;&lt;/span&gt;周边情况&lt;span&gt;-&amp;gt;&lt;/span&gt;确认告警范围&lt;span&gt;-&amp;gt;&lt;/span&gt;通知学校&lt;span&gt;-&amp;gt;&lt;/span&gt;医院准备&lt;span&gt;-&amp;gt;&lt;/span&gt;应急人员准备&lt;span&gt;-&amp;gt;&lt;/span&gt;交通规划&lt;span&gt;-&amp;gt;&lt;/span&gt;应急方案预备&lt;span&gt;-&amp;gt;&lt;/span&gt;应急方案启动&lt;span&gt;-&amp;gt;&lt;/span&gt;应急资源触发&lt;span&gt;-&amp;gt;&lt;/span&gt;现场方案预备&lt;span&gt;-&amp;gt;&lt;/span&gt;现场方案启动&lt;span&gt;-&amp;gt;&lt;/span&gt;人员进场&lt;span&gt;-&amp;gt;&lt;/span&gt;作业中）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;实现思路：首先对模型进行分组，并在相应的图元上标记&lt;/span&gt; &lt;span&gt;tag&lt;/span&gt; &lt;span&gt;，使用&lt;/span&gt; &lt;span&gt;ht.Default.startAnim()&lt;/span&gt;&lt;span&gt;  来完成每一步的动画效果，然后拼接动画即可实现上图中的&lt;/span&gt; &lt;span&gt;3D&lt;/span&gt;&lt;span&gt; 动画效果。至于右边的&lt;/span&gt; &lt;span&gt;2D&lt;/span&gt;&lt;span&gt; &lt;span&gt;步骤显示面板&lt;/span&gt;的联动，&lt;span&gt;因为本&lt;/span&gt;&lt;/span&gt; &lt;span&gt;demo&lt;/span&gt;&lt;span&gt; &lt;span&gt;采用的是&lt;/span&gt;&lt;/span&gt; &lt;span&gt;ht.js&lt;/span&gt;&lt;span&gt; 来实现的，&lt;/span&gt; &lt;span&gt;ht.DataModel&lt;/span&gt; &lt;span&gt;&lt;span&gt;作为承载&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Data&lt;/span&gt;&lt;span&gt;  数据的模型，管理&lt;span&gt;着&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Data&lt;/span&gt;&lt;span&gt;  数据的增删以及事件派发，右侧&lt;span&gt;的&lt;/span&gt;&lt;/span&gt; &lt;span&gt;2D&lt;/span&gt;&lt;span&gt; &lt;span&gt;面板里的步骤也是一个个&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Data&lt;/span&gt;&lt;span&gt; ，我们只要对其进行&lt;/span&gt;&lt;a href=&quot;http://www.hightopo.com/guide/guide/core/databinding/ht-databinding-guide.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span&gt;数据绑定&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;，在动画执行到某一时刻，通过动态修数据来控制图元的透明度等样式就可以实现&lt;/span&gt; &lt;span&gt;2/3D&lt;/span&gt;&lt;span&gt; 联动了。&lt;/span&gt;&lt;span&gt;demo &lt;/span&gt;&lt;span&gt;&lt;span&gt;中的&lt;/span&gt;事故地点，点击可跳转到另一个室内定位的&lt;/span&gt; &lt;a href=&quot;http://www.hightopo.com/demo/indoor-position/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;案例&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事故定位动画主要代码&lt;/span&gt;
&lt;span&gt; animStep_1() {
    let process_01 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.main.g2d.dm().getDataByTag(&quot;process_01&quot;&lt;span&gt;);
    process_01.s(&lt;/span&gt;&quot;opacity&quot;, 1&lt;span&gt;);
    let emergencyResponseParent_1 &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.main.g3d
        .dm()
        .getDataByTag(&lt;/span&gt;&quot;emergencyResponseParent_1&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setVisible(emergencyResponseParent_1, &lt;span&gt;true&lt;/span&gt;, &quot;children&quot;&lt;span&gt;);
    let children &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getChildren(emergencyResponseParent_1);
    children.forEach(i &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        i.s(&lt;/span&gt;&quot;shape3d.transparent&quot;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        i.s(&lt;/span&gt;&quot;shape3d.opacity&quot;, 0&lt;span&gt;);
    });
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.main.anim =&lt;span&gt; ht.Default.startAnim({
        duration: &lt;/span&gt;2000&lt;span&gt;,
        easing: t &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
        },
        finishFunc: () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.animStep_2();
        }, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动画结束后调用的函数。&lt;/span&gt;
        action: (v, t) =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setStepPanel(process_01, t, 4&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &amp;lt;= 0.25&lt;span&gt;) {
                children[&lt;/span&gt;0].s(&quot;shape3d.opacity&quot;, 5 *&lt;span&gt; Ease.easeOutSine(t));
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (t &amp;lt;= 0.375&lt;span&gt;) {
                children[&lt;/span&gt;1&lt;span&gt;].s(
                    &lt;/span&gt;&quot;shape3d.opacity&quot;&lt;span&gt;,
                    &lt;/span&gt;8 * Ease.easeOutSine(t - 0.25&lt;span&gt;)
                );
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (t &amp;lt;= 0.5&lt;span&gt;) {
                children[&lt;/span&gt;2&lt;span&gt;].s(
                    &lt;/span&gt;&quot;shape3d.opacity&quot;&lt;span&gt;,
                    &lt;/span&gt;8 * Ease.easeOutSine(t - 0.375&lt;span&gt;)
                );
            }
        }
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;2.交通情况&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;先上图：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img title=&quot;交通情况示意图&quot; src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191216104944139-1482971168.png&quot; alt=&quot;交通情况示意图&quot; width=&quot;550&quot; height=&quot;309&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;从应用领域来看，目前我国智慧交通主要应用在公路交通信息化、城市道路交通管理服务信息化以及城市公交信息化领域。伴随着数字化转型，政府主动牵头智慧城市建设，未来市场潜力巨大。该功能点能更直观有效的反应当前的道路交通情况，使各地政府更加有效的、科学的管理交通，发挥出大城市的交通效能。常规的&lt;/span&gt; &lt;span&gt;2D&lt;/span&gt;&lt;span&gt; 效果图已经不满足于当下的需求了，伴随着大数据、云计算、&lt;/span&gt;&lt;span&gt;5G&lt;/span&gt;&lt;span&gt;&lt;span&gt;、&lt;/span&gt;&lt;/span&gt;&lt;span&gt;AI&lt;/span&gt;&lt;span&gt;、边缘计算等技术的发展成熟，&lt;/span&gt;&lt;span&gt;3D  &lt;/span&gt;&lt;span&gt;&lt;span&gt;可视&lt;/span&gt;化更能直观的、有效的反馈信息。当然，&lt;/span&gt;&lt;span&gt;3D&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;span&gt;可视化离不开一款强大的图形引擎。本模块只是简单地模拟了交通状况，并未继续拓展。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;3.城市漫游&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img title=&quot;漫游效果图（2倍速）&quot; src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191216105536484-1361039183.gif&quot; alt=&quot;漫游效果图（2倍速）&quot; width=&quot;550&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;由于计算机图形学和软硬件技术的快速发展,虚拟现实技术越来越为人们所重视。虚拟现实技术的应用一直是计算机应用领域的热点&lt;span&gt;,&lt;/span&gt;虚拟现实技术的应用价值已经得到了广泛的认可。&lt;/span&gt;&lt;span&gt;3D &lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;漫游可以提供很好的用户交互体验，所以本&lt;/span&gt; &lt;span&gt;demo &lt;/span&gt;&lt;span&gt; 也展示了这一功能。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;借助于&lt;/span&gt;&lt;/span&gt; &lt;span&gt;HT&lt;/span&gt;&lt;span&gt;，漫游功能的实现只要几行代码就可以实现了。&lt;/span&gt;&lt;a href=&quot;http://www.hightopo.com/guide/guide/core/shape/ht-shape-guide.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;ht.Shape&lt;/span&gt;&lt;/a&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;span&gt;是极其强大的&lt;/span&gt;图元类型，这里绘制漫游路线就是使用其扩展&lt;span&gt;子类&lt;/span&gt;&lt;/span&gt; &lt;span&gt;ht.Polyline&lt;/span&gt;&lt;span&gt; ，绘制一条三维空间管道，然后通过获取该路径上的点来不断设置&lt;/span&gt; &lt;span&gt;eye&lt;/span&gt; &lt;span&gt;&lt;span&gt;就&lt;/span&gt;行了。代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:false;&quot;&gt;
// 漫游动画
roamingAnim() {
    // polyline
    let polyline = this.main.g3d.dm().getDataByTag(&quot;polyline&quot;);
    this.main.anim = ht.Default.startAnim({
        duration: 15000,
        easing: t =&amp;gt; {
            return t;
        },
        finishFunc: () =&amp;gt; {
        }, // 动画结束后调用的函数。
        action: (v, t) =&amp;gt; {
            let length = this.main.g3d.getLineLength(polyline),
                offset = this.main.g3d.getLineOffset(polyline, length * v),
                point = offset.point,
                px = point.x,
                py = point.y,
                pz = point.z;
                this.main.g3d.setEye(
                    px ,
                    py ,
                    pz
                );
                this.main.g3d.setCenter(0, 0, 0);
        }
    });
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;4.工程情况&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img title=&quot;工程情况示意图&quot; src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191216105845737-1457224724.png&quot; alt=&quot;工程情况示意图&quot; width=&quot;550&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;该页面主要展示了工程情况：大桥（&lt;/span&gt;&lt;a href=&quot;https://hightopo.com/demo/Bridge3d/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;戳&lt;/span&gt;&lt;/a&gt;&lt;span&gt;）、盾构作业（&lt;/span&gt;&lt;a href=&quot;https://hightopo.com/demo/fan3d-magic/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;戳&lt;/span&gt;&lt;/a&gt;&lt;span&gt;）、海底隧道（&lt;/span&gt;&lt;a href=&quot;https://hightopo.com/demo/tunnel2/index.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;戳&lt;/span&gt;&lt;/a&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;至此，该&lt;/span&gt; &lt;span&gt;demo&lt;/span&gt;&lt;span&gt; &lt;span&gt;的功能&lt;/span&gt;点就介绍完了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img title=&quot;厦门吕厝路面塌陷图&quot; src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191216105952812-863979399.png&quot; alt=&quot;厦门吕厝路面塌陷图&quot; width=&quot;550&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img title=&quot;江苏盐城化工厂爆炸图&quot; src=&quot;https://img2018.cnblogs.com/common/1496396/201912/1496396-20191216110006376-1682060184.png&quot; alt=&quot;江苏盐城化工厂爆炸图&quot; width=&quot;550&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;图一，12月&lt;span&gt;12&lt;/span&gt;日晚，厦门地铁&lt;span&gt;2&lt;/span&gt;号线吕厝路口配套的物业开发地块施工现场发生塌陷，所幸没有造成人员伤亡，事故原因疑似管道破裂导致，水流将路基中的稳定土层掏空，加上路面上的汽车压力，导致路面坍塌。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;图二，3月&lt;span&gt;21&lt;/span&gt;日下午&lt;span&gt;14:48&lt;/span&gt;左右，位于响水县生态化工园区的化工厂发生爆炸。近年来，多加化工厂爆炸，所造成的生命、财产损失不可估量。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一场场事故触目惊心，时刻提醒着我们要防患于未然。水是人类生活的源泉而随着城市的发展水污染问题也越来越严重，水资源监管和治理成为城市发展的一大困扰，&lt;/span&gt;&lt;span&gt;水质监控&lt;/span&gt;&lt;span&gt;不及时、水灾预警不及时更是直接关系到民生问题。而智慧水务的发展则能非常及时、准确的解决问题。假如有比较好的监控预警系统，这些事故发生的可能性将大大降低。后续会再写些关于智慧水务的文章，也会再拓展应急预案的场景案例。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Feb 2020 00:44:00 +0000</pubDate>
<dc:creator>HT学习笔记</dc:creator>
<og:description>前言 中共中央、国务院在今年12月印发了《长江三角洲区域一体化发展规划纲要》(下文简称《纲要》)，并发出通知，要求各地区各部门结合实际认真贯彻落实。 《纲要》强调，要提升基础设施互联互通水平，打造数字</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/htdaydayup/p/12047850.html</dc:identifier>
</item>
<item>
<title>最好用的web端代码文本编辑器ACE - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/12289756.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/12289756.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用足够简单，功能足够强大，体验足够优秀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前有一个系列文章介绍我在运维系统开发过程中用到的那些顺手的前端插件，总共发了四篇文章介绍了三个非常棒的插件，分别是&lt;a href=&quot;https://ops-coffee.cn/s/3Or2JK7_Wy9B0WqdUYDroA&quot;&gt;bootstrap-duallistbox&lt;/a&gt;、&lt;a href=&quot;https://ops-coffee.cn/s/2w956ln2fA1jzdC-UQ55Vg&quot;&gt;select2&lt;/a&gt;和&lt;a href=&quot;https://ops-coffee.cn/s/5dZx6HrPE1Y4rdxqHTYN-g&quot;&gt;datatables&lt;/a&gt;，今天再更此系列，让好东西让更多的人知道，受益！&lt;/p&gt;
&lt;p&gt;本次介绍ace.js，这是一个用JavaScript编写的独立代码编辑器。支持超过120种语言的语法高亮，超过20个不同风格的主题，同时还支持实时语法检查，自定义快捷键绑定，代码折叠，搜索替换，自动缩进等等功能&lt;/p&gt;
&lt;p&gt;项目地址为：&lt;a href=&quot;https://ace.c9.io&quot; class=&quot;uri&quot;&gt;https://ace.c9.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我主要用它来替换表单中的textarea标签，以及实现在网页上修改文件的展示，例如之前&lt;a href=&quot;https://ops-coffee.cn/s/QG42UqJ9rnswQDMd41CYUg&quot;&gt;配置中心Kerrigan&lt;/a&gt;文章中讲到的web端修改配置文件就用了ace&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/images/20200117.01.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;基本使用&quot;&gt;基本使用&lt;/h2&gt;
&lt;p&gt;这个项目引入非常简单，只需要引入一个ace.js文件即可，然后实例化即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 引入js文件
&amp;lt;script src=&quot;/static/js/ace.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;pre id=&quot;content&quot; style=&quot;height:620px&quot;&amp;gt;&amp;lt;/pre&amp;gt;

// 实例化编辑器
var editor = ace.edit(&quot;content&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;github上除了源码文件外，ace还贴心的准备了编译好的项目文件，以方便用户使用，我们只需要将编译好的文件目录copy到我们项目的js目录下即可，编译好的仓库地址是：&lt;a href=&quot;https://github.com/ajaxorg/ace-builds&quot; class=&quot;uri&quot;&gt;https://github.com/ajaxorg/ace-builds&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推荐同时引入&lt;code&gt;ext-searchbox.js&lt;/code&gt;文件，这样可以在编辑器中直接使用ctrl+F快捷键进行搜索&lt;/p&gt;
&lt;h2 id=&quot;基本配置&quot;&gt;基本配置&lt;/h2&gt;
&lt;p&gt;ace有许多的配置项可供选择，通过这些配置项可以打造自己的个性编辑器&lt;/p&gt;
&lt;p&gt;你可以通过&lt;code&gt;setTheme&lt;/code&gt;来设置主题，需要注意的是主题文件要存在，并且需要与ace.js同级，命名规则为&lt;code&gt;theme-主题名.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.setTheme(&quot;ace/theme/twilight&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下编辑器为纯文本模式，你可以通过&lt;code&gt;setMode&lt;/code&gt;来设置编辑器对应的语言模式，例如你想让其匹配markdown，就可以像下边这样配置，同样需要语言模式的文件存在，文件与ace.js同级，命名规则为&lt;code&gt;mode-语言模式.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.session.setMode(&quot;ace/mode/markdown&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;setFontSize&lt;/code&gt;可以设置编辑器内文本字体的大小&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.setFontSize(14);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;setTabSize&lt;/code&gt;可以设置制表符的长度&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.getSession().setTabSize(4);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时可以通过&lt;code&gt;setUseSoftTabs&lt;/code&gt;将制表符变成对应长度的空格&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.session.setUseSoftTabs(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你不想编辑，可以通过&lt;code&gt;setReadOnly&lt;/code&gt;可以将编辑器设置为只读模式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.setReadOnly(true)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下ace编辑器中会有一道竖线标识打印的边距，可以通过&lt;code&gt;setShowPrintMargin&lt;/code&gt;来控制其是否显示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.setShowPrintMargin(false);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编辑器操作&quot;&gt;编辑器操作&lt;/h2&gt;
&lt;p&gt;ace可以方便的对编辑器内的数据进行获取和写入，甚至可以只获取选中的内容，同时也能实现获取行数，跳转到行等操作&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;getValue&lt;/code&gt;可以获取到编辑器中的全部数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.getSession().getValue()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果编辑器内有部分数据被选中，则可以通过&lt;code&gt;getSelectionRange&lt;/code&gt;来获取选中的部分内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.session.getTextRange(editor.getSelectionRange())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这在特性我实现SQL查询的功能中有用到，如果查询框内有多条SQL，可以选择其中一条SQL进行查询&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/images/20200117.02.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;setValue&lt;/code&gt;可以给编辑器初始化数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.getSession().setValue(&quot;ops-coffee.cn&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你想往编辑器插入数据时，可以通过&lt;code&gt;insert&lt;/code&gt;在光标处插入数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.insert('ops-coffee.cn')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;getLength&lt;/code&gt;可以获取到编辑器内数据的总行数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.session.getLength()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;goLine&lt;/code&gt;则可以跳转到指定的行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.gotoLine(37)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;getCursor&lt;/code&gt;可以获取到编辑器内光标的位置，输出结果为一个标识行和列的字典，像这样：&lt;code&gt;{row:13,column:37}&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.selection.getCursor()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;搜索与替换&quot;&gt;搜索与替换&lt;/h2&gt;
&lt;p&gt;ace还实现了强大的搜索和替换功能，可以单个替换也可以全部替换&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;find&lt;/code&gt;可以进行搜索&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.find('ops-coffee', {  
    backwards: false,  
    wrap: false,  
    caseSensitive: false,  
    wholeWord: false,  
    regExp: false  
});  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;find后边跟了两个参数， 第一个为要搜索的内容，第二个为搜索配置的字典， 字典内可以配置如下一些参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;backwards: 是否反向搜索，默认为false&lt;/li&gt;
&lt;li&gt;wrap: 搜索到文档底部是否回到顶端，默认为false&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;caseSensitive: 是否匹配大小写搜索，默认为false&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;wholeWord: 是否匹配整个单词搜素，默认为false&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;range: 搜索范围，要搜素整个文档则设置为空&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;regExp: 搜索内容是否是正则表达式，默认为false&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;start: 搜索起始位置&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;skipCurrent: 是否不搜索当前行，默认为false&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过&lt;code&gt;findAll&lt;/code&gt;可以高亮显示全部搜索到的内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.findAll();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;findNext&lt;/code&gt;则可以查找下一个搜索到的内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.findNext();  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;findPrevious&lt;/code&gt;查找上一个匹配的内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.findPrevious();  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;replace&lt;/code&gt;可以对&lt;strong&gt;当前&lt;/strong&gt;&lt;code&gt;find&lt;/code&gt;查找到的字符串进行替换&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.replace('ops-coffee.cn'); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而通过&lt;code&gt;replaceAll&lt;/code&gt;则可以对&lt;code&gt;find&lt;/code&gt;查找到的所有内容替换&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.replaceAll('ops-coffee.cn');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，无论是&lt;code&gt;replace&lt;/code&gt;还是&lt;code&gt;replaceAll&lt;/code&gt;都需要配合&lt;code&gt;find&lt;/code&gt;一起使用&lt;/p&gt;
&lt;h2 id=&quot;监听变化&quot;&gt;监听变化&lt;/h2&gt;
&lt;p&gt;ace另一个强大的地方是实现了对编辑器的监听，除了可以监听内容的变化外，还能监听选中内容的变化，甚至是光标的变化&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;change&lt;/code&gt;可以监听到编辑器内容的变化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.getSession().on('change', function(e) {
    console.log('内容有变化')
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;changeSelection&lt;/code&gt;则可以监听到选择内容的变化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.getSession().selection.on('changeSelection', function(e) {
    console.log('选择内容有变化')
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连光标的变化都可以通过&lt;code&gt;changeCursor&lt;/code&gt;监听到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;editor.getSession().selection.on('changeCursor', function(e) {
    console.log('监听光标的变化')
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;替换textarea&quot;&gt;替换textarea&lt;/h3&gt;
&lt;p&gt;html中的textarea比较鸡肋，连最基本的换行都无法实现，所以我通常都会用ace来代替form表单中的textarea，但默认情况下submit无法自动获取pre标签的数据做提交，这该如何处理呢？&lt;/p&gt;
&lt;p&gt;一种简单的方式就是将textarea隐藏，同时创建一个ace编辑器来取代他，然后检测编辑器内数据的变化自动给填充到textarea内，完整的例子就像下边这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;form class=&quot;form-horizontal&quot; id=&quot;modalForm_Content&quot; method=&quot;post&quot; action=&quot;&quot;&amp;gt;{% csrf_token %}
  &amp;lt;div class=&quot;form-group&quot;&amp;gt;
    &amp;lt;label class=&quot;col-md-2 control-label&quot;&amp;gt; 内容&amp;lt;/label&amp;gt;
    &amp;lt;div class=&quot;col-md-9&quot;&amp;gt;
      &amp;lt;textarea class=&quot;form-control&quot; id=&quot;form_content&quot; name=&quot;content&quot; rows=&quot;20&quot;&amp;gt;&amp;lt;/textarea&amp;gt;
      &amp;lt;pre id=&quot;content&quot; style=&quot;height:415px&quot;&amp;gt;&amp;lt;/pre&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/form&amp;gt;

// 加载ace editor
var editor = ace.edit(&quot;content&quot;);
var textarea = $('textarea[name=&quot;content&quot;]').hide();
editor.getSession().on('change', function(){
  textarea.val(editor.getSession().getValue());
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;非常完美的弥补了textarea的不足，简单好用且足够强大&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://blz.nosdn.127.net/sre/wx.qrcode.png&quot; alt=&quot;扫码关注公众号查看更多实用文章&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相关文章推荐阅读：&lt;/p&gt;
</description>
<pubDate>Sun, 09 Feb 2020 23:35:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>使用足够简单，功能足够强大，体验足够优秀 之前有一个系列文章介绍我在运维系统开发过程中用到的那些顺手的前端插件，总共发了四篇文章介绍了三个非常棒的插件，分别是 &amp;quot;bootstrap dual</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/37Y37/p/12289756.html</dc:identifier>
</item>
<item>
<title>《领域驱动设计》学习笔记 - wc的一些事一些情</title>
<link>http://www.cnblogs.com/wcd144140/p/12289586.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wcd144140/p/12289586.html</guid>
<description>&lt;hr/&gt;&lt;h2&gt;第1章：消化知识&lt;/h2&gt;
&lt;h3&gt;有效的建模要素&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1）模型和实现的绑定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）建立了一种基于模型的语言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）开发一个蕴含丰富知识的模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）提炼模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）头脑风暴和实验&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：千万不要用自己有限的思维规划完整的图形，持续学习、消化、输出（讨论）、沉淀，所有道理都是一致的。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;第2章：交流语言与使用&lt;/h2&gt;
&lt;h3&gt;模式：UBIQUITOUS LANGUAGE（通用语言）&lt;/h3&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-52e7cb181fa0a0e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;&lt;span&gt;术语的交集产生了UBIQUITOUS LANGUAGE&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;想要创建种灵活的、蕴含丰富知识的设计，需要一种通用的、共享的团队语言，以及对语言不断的试验——然而，软件项目上很少出现这样的试验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果语言支离破碎，项目必将遭遇严重问题。领域专家使用他们自己的术语，而技术团队所使用的语言则经过调整，以便从设计角度讨论领域。日常讨论所使用的术语与代码（软件项目的最重要产品）中使用的术语不一致，甚至同一个人在讲话和写东西时使用的言语也不一致，这导致的后果是，对领域的深刻表达常常稍纵即逝，根本无法记录到代码或文档中。翻译使得沟通不畅，并削弱了知识消化。然而任何一方的语言都不能成为公共语言，因为它们无法满足所有的需求。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：在自己有限的项目经验里，说沟通成本占据项目总成本的八成都不为过，就像本书一开始的重点，就是无处不在的语言。这语言可以是人话、可以是图形、可以是表格，重点在于可以帮助项目高质量高效率的落地。这里引用歌德的一句话：“世界上的误解和懈怠，也许比奸诈和恶意更误事”。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;第3章：绑定模型和实现&lt;/h2&gt;
&lt;h3&gt;模式：MODEL-DRIVEN-DESIGN&lt;/h3&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-70c32c8afc264ff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;模型-范式-设计&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;严格按照基础模型来编写代码，能够使代码更好地表达设计含义，并且使模型与实际的系统想契合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果整个程序设计或者其核心部分没有与领域模型相对应，那么这个模型就是没有价值的，软件的正确性也值得怀疑。同时，模型和设计功能之间过于复杂的对应关系也是难于理解的，在实际项目中，当设计改变时也无法维护这种关系。若分析与设计之间产生严重分歧，那么在分析和设计活动中所获得的知识就无法彼此共享。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;软件系统各个部分的设计应该忠实地反映领域模型，以便体现出这二者之间的明确对应关系。我们应该反复检查并修改模型，以便软件可以更加自然地实现模型，即使想让模型反映出更深层次的领域概念时也应如此。我们需要的模型不但应该满足这种需求，还应该能够支持健壮的UBIQUITOUS LANGUAGE（通用语言）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从模型中获取用于程序设计和基本职责分配的术语。让程序代码成为模型的表达，代码的改变可能会是模型的改变。而其影响势必要波及接下来相应的项目活动。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：模型、范式与设计的基本认知时候所有沟通的基石，无论是技术人员还是领域业务人员都有必要对这些知识有一个深入的理解，切记把自己局限在自己的细节当中，用人话讲就是钉子思维。对其他工作小组的认识是一种促进大家更好合作的责任心态度，还是那句话，用宏观的视野做微观的事情。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h2&gt;第4章：分离领域&lt;/h2&gt;
&lt;h3&gt;模式：LAYERED ARCHTECTURE&lt;/h3&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-1ca800a5b353ce36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;分层模式&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;想要创建出能够处理复杂任务的程序，需要做到关注点分离——使设计中的每个部分得到单独的关注。在分离的同时，也需要维持系统内部复杂的交互关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分层的价值在于每一层都只代表程序中的某一特定方面的。这种限制使每个方面的设计都更具内聚性，更容易理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而领域层是模型的精髓。领域模型是一些列概念的集合。“领域层”则是领域模型以及所有与其直接相关的设计元素的表现，他由业务逻辑的设计和实现组成。在MODEL-DRIVEN-DESIGN中，领域层的软件构造反映出了模型概念。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：分离意味着原始的复杂，这是发展的一个趋势，技术的进步往往在于精细化的分工，而这种分层的另一个好处是，分离核心，聚焦问题。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;第5章：软件中所表示的模型&lt;/h2&gt;
&lt;h3&gt;模式：ENTITY（又称为REFERENCE OBJECT）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;一些对象主要不是由它们的属性定义的。它们实际上表示了一条“标识线”（A Thread of Identity），这条线跨越时间，而且常常经历多种不同的表示。有时，这样的对象必须与另一个具有不同属性的对象相匹配。而有时一个对象必须与具有相同属性的另一个对象区分开。错误的标识可能会破坏数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个对象由其标识（而不是属性）区分时，那么在模型中应该主要通过标识来确定该对象的定义。是类定义变得简单，并集中关注生命周期的连续性和标识。定义一种区分每个对象的方式，这种方式应该与其形式和历史无关。要格外注意那些需要通过属性来匹配对象的需求。在定义标识操作时，要确保这种操作为每个对象生成唯一的结果，这可以通过附加一个保证唯一性的符号来实现。这种定义标识的方法可能来自外部，也可能是由系统创建的任意标示符，但它在模型中必须是唯一的标识。模型必须定义“符合什么条件才算是相同的事物”。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：VALUE OBJECT&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;很多对象没有概念上的标识，它们描述了一个事务的某种特征。而这类用于描述领域的某个方面而本身没有概念标识的对象称为VALUE OBJECT（值对象）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们只关心一个模型元素的属性时，应把它归类为VALUE OBJECT。我们应该使这个模型元素能够表示出其属性的意义，并为它提供相关功能。VALUE OBJECT应该是不可变的。不要为它分配任何标识，而且不要把它设计成像ENTITY那么复杂。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：SERVICE&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;有时，对象不是一个事物。在某些情况下，最清楚、最实用的设计会包含一些特殊的操作，这些操作从概念上讲不属于任何对象。与其把它们强制地归于哪一类，不如顺其自然地在模型中引入一种新的元素，这就是SERVICE（服务）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓SERVICE，它强调的是与其他对象的关系。与ENTITY和VALUE OBJECT不同，它只是定义了能够为客户做什么。SERVICE往往是一个一活动来命名，而不是以一个ENTITY来命名，也就是说，它是动词而不是名词。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好的SERVICE有以下3个特征：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）与领域概念相关的操作不是ENTITY或VALUE OBJECT的一个自然组成部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）接口是根据领域模型的其他元素定义的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）操作是无状态的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当领域中的某个重要的过程或转换操作不是ENTITY或VALUE OBJECT的自然职责时，应该在模型中添加一个作为独立接口的操作，并将其声明为SERVICE。定义接口时要使用模型语言，并确保操作名称是UBIQUITOUS LANGUAGE中的术语。此外，应该使SERVICE成为无状态的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SERVICE与孤立的领域层：这种模式只重视那些在领域中具有重要意义的SERVICE，但SERVICE并不只是在领域中使用。我们需要注意区分属于领域层的SERVICE和那些属于其他层的SERVICE，并划分责任，以便将它们明确地区分开。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-1cfdcff971193727.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;将SERVICE划分到各层中（资金转账 示例）&lt;/p&gt;

&lt;/div&gt;
&lt;h3&gt;模式：MODULE（也称为PACKAGE）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;MODULE是一个传统的、较成熟的设计元素。虽然使用模块有一些技术上的原因，但主要原因却是“认知超载”。MODULE为人们提供了两种观察模型的方式，一是可以在MODULE中查看细节，而不会被整个模型淹没，二是观察MODULE之间的关系，而不考虑其内部细节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个人都会使用MODULE，但却很少有人它们当作模型中的一个成熟的组成部分。代码按照各种各样的类别进行分解，有时是按照技术架构来分割的，有时是按照开发人员的任务分工来分割的。甚至那些从事大量重构工作的开发人员也倾向于使用项目早期形成的一些MODULE。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;众所周知，MODULE之间应该是低耦合的，而在MODULE的内部则是高内聚的。耦合和内聚的解释使得MODULE听上去像是一种技术指标，仿佛根据关联和交互的分布情况来机械地判断它们。然而，MODULE并不仅仅是代码的划分，而且也是概念的划分。一个人一次考虑的事情是有限的（因此才要低耦合）。不连贯的思想和“一锅粥”似的思想同样难于理解（因此才要高内聚）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;选择能够描述系统的MODULE，并使之包含一个内聚的概念集合。这通常会实现MODULE之间的低耦合，但如果效果不理想，则应寻找一种更改模型的方式来消除概念之间的耦合，或者找到一个可以作为MODULE基础的概念（这个概念先前可能被忽视了），基于这个概念组织的MODULE可以以一种有意义的方式将元素集中到一起。找到一种低耦合的概念组织方式，从而可以相互独立地理解和分析这些概念。对模型进行精化，直到可以根据高层领域概念对模型进行划分，同时相应的代码也不会产生耦合。MODULE的名称应该是UBIQUITOUS LANGUAGE中的术语。MODULE及其名称应反映出领域的深层知识。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：每一个概念或方法，都有其含义来源和出处。学会寻找信息的源头，学会给自己的认知指明来源和出处，具备严谨的逻辑思维，科学地学习和认知，是一切成功的基础。杜绝垃圾二手信息资料，杜绝自我局限性拍脑袋的认知决策过程。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;第6章：领域对象的什么周期&lt;/h2&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-a6ca0ab73321a739.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;领域对象的生命周期&lt;/p&gt;

&lt;/div&gt;
&lt;h3&gt;模式：AGGREGATE&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在具有复杂关联的模型中，要想保证对象更改的一致性是很困难的。不仅互不关联的对象需要遵守一些固定规则，而且紧密关联的各组对象也要遵守一些固定规则。然而，过于谨慎的锁定机制又会导致多个用户之间毫无意义地互相干扰，从而使系统不可用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;固定规则（invariant）是指在数据变化时必须保持一致性规则，其涉及AGGREGATE成员之间的内部关系。而任何跨越AGGREGATE的规则将不要求每时每刻都保持最新状态。通过事件处理，批处理或其他更新机制，这些依赖会在一定时间内得以解决。但在每个事务完成时，AGGREGATE内部所应用的固定规则必须得到满足。为了实现这个概念上的AGGREGATE，需要对所有事务应用一组规则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 根ENTITY具有全局标识，它最终负责检查固定规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 根ENTITY具有全局标识。边界内的ENTITY具有本地标识，这些标识只在AGGREGATE内部才是唯一的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ AGGREGATE外部的对象不能引用除根ENTITY之外的任何内部对象。根ENTITY可以把对内部ENTITY的引用传递给它们，但这些对象只能临时使用这些引用，而不能保持引用。根可以把一个VALUE OBJECT的副本传递给另外一个对象，而不必关心它发生什么变化，因为它只是一个VALUE，不再与AGGREGATE有任何关联。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 作为上一条规则的推论，只有AGGREGATE的根才能直接通过数据库查询获取。所有其他对象必须通过遍历关联来发现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ AGGREGATE内部的对象可以保持对其他AGGREGATE根的引用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 删除操作必须一次删除AGGREGATE边界之内的所有对象。（利用垃圾回收机制，这很容易做到。由于除了根以外的其他对象都没有外部引用，因此删除了根以后，其他对象均会被回收。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 当提交对AGGREGATE边界内部的任何对象的修改时，整个AGGREGATE的所有固定规则都必须满足。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-be4136e6c393bf15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;本地标识与全局标识及对象引用&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们应该将ENTITY和VALUE OBJECT分门类别地聚集到AGGREGATE中，并定义每个AGGREGATE的边界。在每个AGGREGATE中，选择一个ENTITY作为根，并通过根来控制对边界内其他对象的所有访问。只允许外部对象保持对根对象的引用。对内部成员的临时引用可以被传递出去，但仅在一次操作中有效。由于根控制访问，因此不能绕过它来修改内部对象。这种设计有利于确保AGGREAGATE中的对象满足所有固定规则，也可以确保在任何状态变化时AGGREGATE作为一个整体满足固定规则。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：FACTORY&lt;/h3&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-4e2118600685cf22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;与FACTORY的基本交互&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当创建一个对象或创建整个AGGREGATE时，如果创建工作很复杂，或者暴露了过多的内部结果，则可以使用FACTORY进行封装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对象的创建本身可以是一个主要操作，但被创建的对象并不适合承担复杂的装配操作。将这些职责混在一起可能产生难以理解的拙劣设计。让客户直接负责创建对象又会使客户的设计陷入混乱，并且破坏被装配对象或AGGREGATE的封装，而且导致客户与被创建对象的实现之间产生过于紧密的耦合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;应该讲创建复杂对象的实例和AGGREGATE的职责转移给单独的对象，这个对象本身可能没有承担领域模型中的职责，但它仍是领域设计的一部分。提供一个封装所有复杂装配操作的接口，而且这个接口不需要客户引用要被实例化的对象的具体类。在创建AGGREGATE时要把它作为一个整体，并确保它满足固定规则。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：REPOSITORY&lt;/h3&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-5771da2bda3d2259.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;REPOSITORY为客户执行一个搜索&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在所有持久化对象中，有一小部分必须通过基于对象属性的搜索来全局访问。当很难通过遍历方式来访问某些AGGREGATE根的时候，就需要使用这种访问方式。它们通常是ENTITY，有时是具有复杂内部结构的VALUE OBJECT，还可能是枚举VALUE。而其他对象则不宜使用这种方式，因为这会混淆它们之间的重要区别。随意的数据库查询会破坏领域对象的封装和AGGREGATE。技术基础设施和数据库访问机制的暴露会增加客户的复杂度，并妨碍模型驱动的设计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;REPOSITORY是一个简单的概念框架，它可用来封装这些解决方案，并将我们的注意力重新拉回到模型上。REPOSITORY将某种类型的所有对象表示为一个概念集合（通常是模拟的）。它的行为类似于集合（collection），只是具有更复杂的查询功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;为每种需要全局访问的对象类型创建一个对象，这个对象相当于该类型的所有对象在内存中的一个集合的“替身”。通过一个众所周知的全局接口来提供访问。提供添加和删除对象的方法，用这些方法来封装在数据存储中实际插入或删除数据的操作。提供根据具体条件来挑选对象的方法，并返回属性值满足查询条件的对象或对象集合（所返回的对象是完全实例化的），从而将实际的存储和查询技术封装起来。只为那些确实需要直接访问的AGGREGATE根提供REPOSITORY。让客户始终聚焦于模型，而将所有对象的存储和访问操作交给REPOSITORY来完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FACTORY与REPOSITORY的关系是：FACTORY负责处理对象生命周期的开始，而REPOSITORY帮助管理生命周期的中间和结束。从领域驱动设计的角度来看，FACTORY和REPOSITORY具有完全不同的职责。FACTORY负责制造新对象，而REPOSITORY负责查找已有对象。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：有时候学习上的困难不是因为自己的理解能力差，而是缺乏一定的基础沟通语言。急于求成和半路出家的问题就在于基础的不扎实，也就是我们所说的野路子。我曾经也会认为用到了再来学，这都是技术圈子的一个悖论。就好像等自己需要用钱了再来理财一样可笑。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;第7章：使用语言：一个扩展的示例&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;略&lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;h2&gt;第8章：突破&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-1d52ba1077c9402c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;突破价值曲线&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;一般来说，持续重构让事物逐步变得有序。代码和模型的每一次精化都让开发人员有了更加清晰的认识。这使得理解上的突破成为可能。之后，一系列快速的改变得到了更符合用户需要并更加切合实际的模型。其功能性及说明性急速增强，而复杂性却随之消失。这种突破不是某种技巧，而是一个事件。它的困难之处在于你需要判断发生了什么，然后再决定如何处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当突破带来更深层次的模型时，通常会令人感到不安。与大部分重构相比，这种变化的回报更多，风险也更高。而且突破出现的时机可能很不合时宜。尽管我们希望进展顺利，但往往事与愿违。过渡到真正的深层次模型需要从根本上调整思路，并且对设计做大幅修改。在很多项目中，建模和设计工作最重要的进展都来自于突破。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要试图去制造突破，那只会使项目陷入困境。通常，只有在实现了许多适度的重构后才有可能出现突破。在大部分时间里，我们都在进行微小的改进，而在这种连续的改进中模型深层含义也会逐渐显现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要为突破做好准备，应专注于知识消化过程，同时也要逐渐建立健壮的UBIQUITOUS LANGUAGE。寻找那些重要的领域概念，并在模型中清晰地表达出来。精化模型，使其更具有柔性。提炼模型。利用这些更容易掌握的手段使模型变得更清晰，这通常会带来突破。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要犹豫着不去做小的改进，这些改进即使脱离不开常规的概念框架，也可以逐渐加深我们对模型的理解。不要因为好高骛远而使项目陷入困境。只要随时注意可能出现的机会就够了。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：我自己手头上目前持有一个运行了近十年的千万级用户系统，至今还在持续运营和追加功能。对于以上那些突破的感受，我太有体会了。整个项目总共经历了两次大的突破，以及无数次小突破。而每一次突破都十分痛苦，但快乐着。离不开团队的坚持，离不开团队的持续学习，更离不开团队吃苦精神。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;第9章：将隐式概念转变为显示概念&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;深层建模听起来很不错，但是我们要如何时间它呢？深层模型之所以强大是因为它包含了领域的核心概念和抽象，能够以简单灵活的方式表达出基本的用户活动、问题以及解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若开发人员识别出设计中隐含的某个概念或者在讨论中收到启发而发现一个概念时，就会对领域建模和响应的代码进行许多转换，在模型中加入一个或多个对象或关系，从而将此概念显示地表达出来。有时，这种从隐式概念到显示概念的转换可能就是一次突破。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;概念挖掘&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;1、倾听领域专家使用的语言。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;有没有一些术语能够简洁地表达出复杂的概念？他们有没有纠正过你的用词（也许是很委婉的提醒）？当你使用某个特定词语时，他们脸上是否已经不再流露出迷惑的表情？这些都是暗示了某个概念也许可以改进模型。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、检查不足之处。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;你所需要的概念并不总是浮在表面上，也绝不仅仅是通过对话和文档就能让它显现出来。有些概念可能需要你自己去挖掘和创造。要挖掘的地方就是设计中最不足的地方，也就是操作复杂且难于理解的地方。每当有新需求时，似乎都会让这个地方变得更加复杂。有时，你很难意识到模型中丢失了什么概念。也许你的对象能够实现所有的功能，但是有些职责的实现却很笨拙。而有时，你虽然能够意识到模型中丢失了某些东西，但是却无法找到解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3、思考矛盾之处。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;由于经验和需求的不同，不同的领域专家对同样的事情会有不同的看法。即使是同一个人提供的信息，仔细分析后也会发现逻辑上不一致的地方。在挖掘程序需求的时候，我们会不断遇到这种令人烦恼的矛盾，但它们也为深层模型的实现提供了重要线索。有时矛盾只是术语说法上的不一致，有些则是由于误解而产生的。但还有一种情况是专家们会给出相互矛盾的两种说法。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;4、查阅书籍。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在寻找模型概念时，不要忽略一些显而易见的资源。在很多领域中，你都可以找到解释基本概念和传统思想的书籍。你依然需要与领域专家合作，提炼与你的问题相关的那部分知识，然后将其转化为适用于面向对象软件的概念。但是，查阅书籍也许能够使你一开始就形成一致且深层的认识。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;5、尝试，再尝试。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;并不是所有这些方向性的改变都毫无用处。每次改变都会把开发人员更深刻的理解添加到模型中。每次重构都使设计变得更灵活且为那些可能需要修改的地方做好准备。我们其实别无选择。只有不断尝试才能了解什么有效什么无效。企图避免设计上的失误将会导致开发出来的产品质量劣质，因为没有更多的经验可用来借鉴，同时也会比进行一系列快速实验更加费时。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;如何为那些不太明显的概念建模？&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;1、显示的约束。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;约束是模型概念中非常重要的类别。它们通常是隐含的，将它们显式地表现出来可以极大地提高设计质量。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-ed3ed73a835b6537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;（例子）为显示表达超订策略而重构的模型  &lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;2、将过程建模为领域对象。&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;首先要说明的是，我们都不希望过程变成模型的主要部分。对象是用来封装过程的，这样我们只需要考虑对象的业务目的或意图就可以了。就像我们以上用来安排货运路线的运输系统例子，安排路线的过程具有业务意义。SERVICE是显示表达这种过程的一种方式，同时它还会降异常复杂的算法封装起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果过程的执行有多种方式，那么我们也可以用另一种方法来处理它，那就是将算法本身或其中的关键部分放到一个单独的对象中。这样，选择不同的过程就变成了选择不同的对象，每个对象都表示一种不同的STRATEGY（策略）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，过程是应该被显示表达出来，还是应该被隐藏起来呢？区分的方法很简单：它是经常被领域专家提起呢，还是仅仅被当作计算机程序机制的一部分？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;约束和过程是两大类概念模型，当我们用面向对象语言编程时，不会立即想到它们，然而它们一旦被我们视为模型元素，就真的可以让我们的设计更为清晰。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;3、模式：SPECIFICATION&lt;/h3&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-43c162495602acf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;检查发票“谓词”提取例子&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;业务规则通常不适合作为ENTITY和VALUE OBJECT的职责，而且规则的变化和组合也会被掩盖领域对象的基本含义。但是将规则移出领域层的结果会更糟糕，因为这样一来，领域代码就不再表达模型了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;逻辑编程提供了一个概念，即“谓词”这种可分离、可组合的规则对象，但是要把这种概念用对象完全实现是很麻烦的。同时，这种概念过于通用，在表达设计意图方面，它的针对性不如专门的设计那么好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;为特殊目的创建谓词形式的显式的VALUE OBJECT。SPECIFICATION就是一个谓词，可用来确定对象是否满足某些标准。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：项目的沟通成本之大，正是因为许多人的内心都会有一颗“自尊心”，我的领域我最懂，我的技术牛逼，你们业务人员可以一边站。所以，想成为一个合格的团队成员，至少得让自己能成为一个合格的聆听者。看似简单，但我在生活中就发现了自己并非一位很好的聆听者。错过了许多对自己有用的信息，更多还是用了许多自以为是的拍脑袋决策。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;第10章：柔性设计&lt;/h2&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-1afca424e0461d21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;一些有助于获得柔性设计的模式  &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;为了使项目能够随着开发工作的进行加速前进，而不会由于它自己的老化将停滞不前，设计必须要让人们乐于使用，而且易于做出修改。这就是柔性设计（supple design）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多过度设计（overengineering）借着灵活性的名义而得到合理的外衣。但是，过多的抽象层和间接设计常常成为项目的绊脚石。看一下真正为用户带来强大功能的软件设计，你常常会发现一些简单的东西。简单并不容易做到。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：INTENTION-REVEALING INTERFACES（意图揭示接口）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果开发人员为了使用一个组件而必须要去研究它的实现，那么就失去了封装的价值。当某个人开发的对象或操作被别人使用时，如果使用这个组件的新的开发者不得不根据其实现来推测其用途，那么他推测出来的可能并不是那个操作或类的主要用途。如果这不是那个组件的用途，虽然代码暂时可以工作，但设计的概念基础已经被误用了，两位开发人员的意图也是背道而驰。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;在命名类和操作时要描述它们的效果和目的，而不是表露它们是通过何种方式达到目的的。这样可以使客户开发人员不必去理解内部细节。这些名称应该与UBIQUITOUS LANGUAGE保持一致，以便团队成员可以迅速推断出它们的意义。在创建一个行为之前先为它编写一个测试，这样可以促使你站在客户开发人员的角度上来思考它。所有复杂的机制都应该封装到抽象接口的后面，接口只表明意图，而不表明方式。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-4d79c3514c4305c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;新的方法名更能表达“油漆”有混合的作用&lt;/p&gt;

&lt;/div&gt;
&lt;h3&gt;模式：SIDE-EFFECT-FREE FUNCTION（无副作用功能）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;大多数操作都会调用其他的操作，而后者又会调用另外一些操作。一旦形成这种任意深度的嵌套，就很难预测调用一个操作将要产生的所有后果。第二层和第三层操作的影响可能并不是客户开发人员有意为之的，也是它们就变成了完全意义上的副作用（任何对未来操作产生影响的系统状态改变都可以成为副作用）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多个规则的相互作用或计算的组合产生的结果是很难预测的。开发人员在调用一个操作时，为了预测操作的结果，必须理解它的实现以及它所调用的其他方法的实现。如果开发人员不得不“揭开接口的面纱”，那么接口的抽象作用就受到了限制。如果没有了可以安全地预见到结果的抽象，开发人员就必须限制“组合爆炸”，这就限制了系统行为的丰富性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;尽可能把程序的逻辑放到函数（返回结果而不产生副作用的操作称为函数）中，因为函数是只返回结果而不产生明显副作用的操作。严格地把命令（引起明显的状态改变的方法）隔离到不返回领域信息的、非常简单的操作中。当发现了一个非常适合承担复杂逻辑职责的概念时，就可以把这个复杂逻辑移到VALUE OBJECT中，这样可以进一步控制副作用。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-c7f063a2f51e3e15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;Paint分解了无副作用的Pigment Color类&lt;/p&gt;

&lt;/div&gt;
&lt;h3&gt;模式：ASSERTION（断言）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;把复杂的计算封装到SIDE-EFFECT-FREE FUNCTION中可以简化问题，但实体仍然会留有一些有副作用的命令，使用这些ENTITY的人必须了解使用这些命令的后果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果操作的副作用仅仅是由它们的实现隐式定义的，那么在一个具有大量相互调用关系的系统中，起因和结果会变得一团糟。理解程序的唯一方式就是沿着分支路径来跟踪程序的执行，封装完全失去了价值。跟踪具体的执行也使抽象失去了意义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;把操作的后置条件和类及AGGREGATE的固定规则表达清楚。如果在你的编程语言中不能直接编写ASSERTION，那么就把它们编写成自动的单元测试。还可以把它们写到文档或图中（如果符合项目开发风格的话）。寻找在概念上内聚的模型，以便使开发人员更容易推断出预期的ASSERTION，从而加快学习过程并避免代码矛盾。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;INTENTION-REVEALING INTERFACE清楚地表明了用途，SIDE-EFFECT-FREE FUNCTION和ASSERTION使我们能够更准确地预测结果，因此封装和抽象更加安全。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：CONCEPTUAL CONTOUR（概念轮廓）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果把模型或设计的所有元素都放在一个整体的大结构中，那么它们的功能就会发生重复。外部接口无法给出客户可能关心的全部信息。由于不同的概念被混合在一起，它们的意义变得很难理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而另一方面，把类和方法分解开也可能是毫无意义的，这会使客户更复杂，迫使客户对象去理解各个细微部分是如何组合在一起的。更糟的是，有的概念可能会完全丢失。铀原子的一半并不是铀。而且，粒度的大小并不是唯一要考虑的问题，我们还要考虑粒度是在哪种场合下使用的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;把设计元素（操作、接口、类和AGGREGATE）分解为内聚单元，在这个过程中，你对领域中一切重要划分的直观认识也要考虑在内。在连续的重构过程中观察发生变化和保证稳定的规律性，并寻找能够解释这些变化模式的底层CONCEPTUAL CONTOUR。使模型与领域中那些一致的方面（正是这些方面使得领域成为一个有用的知识体系）相匹配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的目标是得到一组可以在逻辑上组合起来的简单接口，使我们可以用UBIQUITOUS LANGUAGE进行合理的表述，并且使那些无关的选项不会分散我的注意力，也不增加维护负担。但这通常是通过重构才能得到的结果，很难在前期就实现。而且如果仅仅是从技术角度进行重构，可能永远也不会出现这种结果；只有通过重构得到更深层次的理解，才能实现这样的目标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;INTENTION-REVEALING INTERFACE使客户能够把对象表示为有意义的单元，而不仅仅是一些机制。SIDE-EFFECT-FREE FUNCTION和ASSERTION使我们可以安全地使用这些单元，并对它们进行复杂的组合。CONCEPTUAL CONTOUR的出现使模型的各个部分变得更加稳定，也使得这些单元更直观，更易于使用和组合。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：STANDALONE CLASS（独立的类）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;即使是在MODULE内部，设计也会随着依赖关系的增加而变得越来越难以理解。这加重了我们的思考负担，从而限制了开发人员能处理的设计复杂度。隐式概念比显式引用增加的负担更大了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;低耦合是对象设计的一个基本要素。尽一切可能保持低耦合。把其他所有无关概念提取到对象之外。这样类就变得完全独立了，这就使得我们可以单独地研究和理解它。每个这样的独立类都极大地减轻了因理解MODULE而带来的负担。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽力把最复杂的计算提取到STANDALONE CLASS（独立的类）中，实现此目的的一种方法是从存在大量依赖的类中将VALUE OBJECT建模出来。低耦合是减少概念过载的最基本方法。独立的类是低耦合的极致。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：CLOSURE OF OPERATION（闭合操作）&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;        两个实数相乘，结果仍为实数（实数是所有有理数和所有无理数的集合）。由于这一点永远成立，因此我们说实数的“乘法运算是闭合的”：乘法运算的结果永远无法脱离实数这个集合。当我们对集合中的任意两个元素组合时，结果仍在这个集合中，这就叫做闭合操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                         ——The Math Forum，Drexel University&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;加法运算是实数集中的闭合运算。数学家们都极力避免去引入无关的概念，而闭合运算的性质正好为他们提供了这样一种方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;在适当情况下，在定义操作时让它的返回类型与其参数的类型相同。如果实现者（implementer）的状态在计算中会被用到，那么实现者实际上就是操作一个参数，因此参数和返回值应该与实现者有相同的类型。这样的操作就是在该类型的实例集合中的闭合操作。闭合操作提供了一个高层接口，同时又不会引人对其他概念的任何依赖。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：经历了（还在经历）一个近十年的项目，我想自己还是比较有资格谈谈柔性设计的感受。没有学习这些柔性概念之前，我们能持续高效并运行开发一个项目那么长时间，功劳归于一个重要的原则：简单。起初，整个团队都缺乏以上这些实用的模式理论作为参考，但大家都有秉承着一个“简单”的共同原则，其实不知不觉中摸着石头过河，在无数次重构中逐渐跟以上模式契合起来。当然，如果我们能提前认识这些基础的理论基础知识，我想不必要的弯路会少走许多。也当然，系统还在不断完善中，现在认识也不晚。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;第11章：应用分析模式&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在《分析模式》一书中，Martin Fowler这样定义分析模式：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;分析模式是一种概念集合，用来表示业务建模中的常见结构。它可能只与一个领域有关，也可能跨多个领域。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;Fowler所提出的分析模式来自于实践经验，因此只要用在合适的情形下，它们会非常实用。对于那些面对着具有挑战性领域的人们，这些模型为他们的迭代开发过程提供了一个非常有价值的起点。“分析模式”这个名字本身就强调了其概念本质。分析模式不是技术方案，他们只是参考，用来指导人们设计特定领域中的模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析模式最大的作用是借鉴其他项目的经验，把那些项目中有关设计方向和实现结构的广泛讨论与当前模型的理解结合起来。脱离具体的上下文来讨论模型思想不但难以落地，而且还会造成分析与设计严重脱节的风险，而这一点正是MODEL-DRIVEN DESIGN坚决反对的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你可以幸运地使用一种分析模式时，它一般并不会直接满足你的需求。但它为你的研究提供了有价值的线索，而且提供了明确抽象的词汇。它还可以知道我们的实现，从而省去很多麻烦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们应该把所有分析模式的知识融入知识消化和重构的过程中，从而形成更深刻的理解，并促进开发。当我们应用一种分析模式时，所得到的结果通常与该模式的文献中记载的形式非常想像，只是因具体情况不同而略有差异。但有时完全看不出这个结果与分析模式本身有关，然而这个结果仍然是受该模式思想的启发而得到的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但有一个误区是应该避免的。当使用众所周知的分析模式中的术语时，一定要注意，不管其表面形式的变化有多大，都不要改变它所表示的基本概念。这样做有两个原因，一是模式中蕴含的基本概念将帮助我们避免问题，二是（也是更重要的原因）使用被广泛理解或至少是被明确理解的术语可以增强UBIQUITOUS LANGUAGE。如果在模型的自然演变过程中模型的定义也发生改变，那么就要修改模型名称了。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：本章节主要还是借助《分析模式》一书中的例子，用实践例子来分析系统是如何在演绎过程使用模型的。这种科学谨慎的做法，才是一个工程师的基本观念要求。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;第12章：将设计模式应用于模型&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在《设计模式》中，有些（但并非所有）模式可用作领域模式，但在这样使用的时候，需要变换一下重点。有些模式反映了一些在领域中出现的深层概念。这些模式都有很大的利用价值。为了在领域驱动设计中充分利用这些模式，我们必须同时从两个角度看待它们：从代码的角度来看它们是技术设计模式，从模型的角度来看它们就是概念模式。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;模式：STRATEGY（也称POLICY）&lt;/h3&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-35072d50d65d89bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;策略模式&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;策略模式：定义了一组算法，将每个算法封装起来，并使它们可以互换。STRATEGY允许算法独立于使用它的客户而变化[Gamma et al. 1995]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;领域模型包含一些并非用于解决技术问题的过程，将它们包含进来是因为它们处理问题领域具有实际的价值。当必须从多个过程中进行选择时，选择的复杂性再加上多个过程本身的复杂性使局面失去控制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;我们需要把过程中的易变部分提取到模型的一个单独的“策略”对象中。将规则与它所控制的行为区分开。按照STRATEGY设计模式来实现规则或可替换的过程。策略对象的多个版本表示了完成过程的不同方式。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：COMPOSITE&lt;/h3&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-e09ee1d2da7992d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;组合模式&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;组合模式：将对象组织为树来表示部分—整体的层次结构。利用COMPOSITE，客户可以对单独的对象和对象组合进行同样的处理。[Gamma et al.1995]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;当嵌套容器的关联性没有在模型中反映出来时，公共行为必然会在层次结构的每一层重复出现，而且嵌套也变得僵化（例如，容器通常不能包含同一层中的其他容器，而且嵌套的层数也是固定的）。客户必须通过不同的接口来处理层次结构中的不同层，尽管这些层在概念上可能没有区别。通过层次结构来递归地收集信息也变得非常复杂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;定义一个把COMPOSITE的所有成员都包含在内的抽象类型。在容器上实现那些查询信息的方法时，这些方法返回由容器内容所汇总的信息。而“叶”节点则基于它们自己的值来实现这些方法。客户只需使用抽象类型，而无需区分“叶”和容器。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：很多时候，技术人员钉子思维是无法区分技术角度和模型角度。虽然许多方法是相通的，但不通维度的思考方式也会产生巨大的效果。学以致用，不是停留在嘴巴上，是在实践中证明的。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;第13章：通过重构得到更深层次的理解&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;通过重构得到更深层次的理解是一个涉及很多方面的过程。我们有必要暂停一下，把一些要点归纳到一起。有三件事情是必须要关注的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）以领域为本；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）用一种不同的方式来看待事物；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）始终坚持与领域专家对话。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在寻求理解领域的过程中，可以发现更广泛的重构机会。但一提到传统意义上的重构，我们头脑中就会出现这样一幅场景：一两位开发人员坐在键盘前面，发现一些代码可以改进，然后立刻动手修改代码（当然还要用单元测试来验证结果）。这个过程应该是一直进行下去，但它并不是重构过程的全部。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、开始重构&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;与传统重构观点不同的是，即使在代码看上去很整洁的时候也可能需要重构，原因是模型的语言没有与领域专家保持一致，或者新需求不能被自然地添加到模型中。重构的原因也可能来自学习：当开发人员通过学习获得了更深刻的理解，从而发现了一个得到更清晰或更有用的模型的机会。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、探索团队&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;不管问题的根源是什么，下一步都是要找到一种能够使模型表达变得更清楚和更自然的改进方案。这可能只需要做一些简单、明显的修改，只需几小时即可完成。在这种情况下，所做的修改类似于传统重构。但寻找新模型可能需要更多时间，而且需要更多人参与。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改的发起者会挑选几位开发人员一起工作，这些开发人员应该擅长思考该类问题，了解领域，或者掌握深厚的建模技巧。如果涉及一些难以捉摸的问题，他们还要请一位领域专家加入。想要保证重构迭代过程的效率，需要注意几个关键事项：自主决定，注意范围和休息，以及练习使用UBIQUITOUS LANGUAGE。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3、借鉴先前的经验&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;我们没有必要总去做一些无谓的重复工作。用于查找缺失概念或改进模型的头脑风暴过程具有巨大的作用，通过这个过程可以收集来自各个方面的想法，并把这些想法与已有知识结合起来。随着知识消化的不断开展，就能找到当前问题的答案。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;4、针对开发人员的设计&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;软件不仅仅是为用户提供的，也是为开发人员提供的。开发人员必须把他们编写的代码与系统的其他部分集成到一起。在迭代过程中，开发人员反复修改代码。开发人员应该通过重构得到更深层的理解，这样既能够实现柔性设计，也能够从这样一个设计中获益。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;5、重构的时机&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如果一直等到完全证明了修改的合理性之后才去修改，那么可能要等待太长时间了。项目正承受巨大的耗支，推迟修改将使修改变得更难执行，因为要修改的代码已经变得更加复杂，并更深地嵌入到其他代码中。持续重构渐渐被认为是一种“最佳实践”，但大不部分团队仍然对它抱有很大的戒心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在探索领域的过程中，在培训开发人员的过程中，以及在开发人员与领域专家进行思想交流的过程中，必须始终坚持把“通过重构得到更深层次理解”作为这些工作的一部分。因此，当发生一下情况时，就应该进行重构了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 设计没有表达出团队对领域的最新理解；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 重要的概念被隐藏在设计中了（而且你已经发现了把它们呈现出来的方法）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 发现了一个能令某个重要的设计部分变得更灵活的机会。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;6、危机就是机遇&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;传统意义上的重构听起来是一个非常稳定的过程。但通过重构得到更深层理解往往不是这样的。在对模型进行一段时间稳定的改进后，你可能突然有所顿悟，而这会改变模型中的一切。这些突破不会每天都发生，然而很大一部分深层模型和柔性设计都来自这些突破。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样的情况往往看起来不像是机遇，而更像危机。例如，你突然发现模型中一些明显的缺陷，在表达方面显示出一个很大的漏洞，或存在一些没有表达清楚的关键区域。或者有些描述是完全错误的。这些都表明团队对模型的理解已经达到了一个新的水平。他们现在站在更高的层次上发现了原有模型的弱点。他们可以从这种角度构思一个更好的模型。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：我曾几何时一直认为，发现自己问题是一种耻辱。这种思维极其可怕，当我不再发现自己问题的时候，那才叫可怕。在软件领域，新思维的提升叫重构，在生活方面，新观念的形成叫重生。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h2&gt;第14章：保持模型的完整性&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;模型最基本的要求是它应该保持内部一致，术语总具有相同的意义，并且不包含相互矛盾的规则：虽然我们很少明确地考虑这些要求。模型的内部一致性又叫统一（unification），这种情况下，每个术语都不会有模棱两可的意义，也不会有规则冲突。除非模型在逻辑上是一致的，否则它就没有意义。在理想世界中，我们可以得到涵盖整个企业领域的单一模型。这个模型将是统一的，没有任何相互矛盾或相互重叠的术语定义。每个有关领域的逻辑声明都是一致的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但，大型系统开发并非如此理想。在整个企业系统中保持这种水平的统一是一件得不偿失的事情。在系统的各个不同部分中开发多个模型是很有必要的，但我们必须慎重地选择系统的哪些部分可以分开，以及它们之间是什么关系。我们需要用一些方法保持模型关键部分的高度统一。所有这些都不会自行发生，而且光有良好的意愿也没用的。它只有通过有意识的设计决策和建立特定过程才能实现。大型系统领域模型的完全统一既不可行，也不划算。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：BOUNDED CONTEXT（边界上下文）&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;细胞之所以能够存在，是因为细胞膜限定了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;任何大型项目都会存在多个模型。而当基于不同模型的代码被组合到一起后，软件就会出现bug，变得不可靠和难以理解。团队成员之间的沟通变得混乱。人们往往弄不清楚一个模型不应该在哪个上下文中使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;明确地定义模型所应用的上下文。根据团队的组织，软件系统的各个部分的用法以及物理表现（代码和数据库模式等）来设置模型的边界。在这些边界中严格保持模型的一致性，而不要收到边界之外问题的干扰和混淆。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;但记住，BUOUNDED CONTEXT不是MODULE。有时这两个概念易引起混淆，但它们是具有不同动机的不同模式。确实，当两组对象组成两个不同模型时，人们几乎总是把它们放在不同的MODULE中。这样做的确提供了不同的命名空间（对不同的CONTEXT很重要）和一些划分方法。但人们也会在一个模型中用MODULE来组织元素，它们不一定要表达划分CONTEXT的意图。MODULE在BOUNDED CONTEXT内部创建的独立命名空间实际上使人们很难发现意外产生的模型分裂。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们通过定义这个BOUNDED CONTEXT，最终得到了什么？对CONTEXT内的团队而言：清晰！对于CONTEXT之外的团队而言：自由。当然，边界只不过是一些特殊的位置。各个BUONDED CONTEXT之间的关系需要我们仔细地处理。CONTEXTMAP（上下文图）画出了上下文范围，并给出了CONTEXT以及它们之间联系的总体视图，而几种模式定义了CONTEXT之间的各种关系的性质。CONTINUOUS INTEGRATION（持续集成）的过程可以使模型在BOUNDED CONTEXT中保持一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何识别BOUNDED CONTEXT中的不一致？很多征兆都可能表明模型出现了差异。最明显的是已编码的接口不匹配。对于更微妙的情况，一些意外行为也可能是一种信号。采用了自动测试的CONTINUOUS INTEGRATION可以帮助捕捉到这类问题，但语言上的混乱往往是一种早期信号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将不同模型的元素组合到一起可能会引发两类问题：重复的概念和假同源。重复的概念是指两个模型元素（以及伴随的实现）实际上表示同一个概念，而假同源是指使用相同术语（或已实现的对象）的两个人认为他们是在谈论同一件事情，但实际上并不是这样。假同源可能稍微少见一点，但它潜在的危害更大。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：CONTINUOUS INTEGRATION（持续集成）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当很多人在同一个BOUNDED CONTEXT中工作时，模型很容易发生分裂。团队越大，问题就越大，但即使3、4个人的团队也有可能会遇到严重的问题。然而，如果将系统分解为更小的CONTEXT，最终又难以保持集成度和一致性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;建立一个把所有代码和其他实现工件频繁地合并到一起的过程，并通过自动化测试来快速查明模型的分类问题。严格坚持使用UBIQUITOUS LANGUAGE，以便在不同人的头脑中演变出不同的概念时，是所有人对模型都能达成一个共识。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：CONTEXT MAP（上下文整体关联图）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;其他团队中的人员并不是十分清楚CONTEXT的边界，他们会不知不觉地做出一些更改，从而使边界变得模糊或者使互连变得复杂。当不同的上下文必须互相连接时，它们可能会互相重叠。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;识别在项目中起作用的每个模型，并定义其BOUNDED CONTEXT。这包括非面向对象子系统的隐含模型。为每个BOUNDED CONTEXT命名，并把名称添加到UBIQUITOUS LANGUAGE中。描述模型之间的联系点，明确所有通信需要的转换，并突出任何共享的内容。先将当前的情况描绘出来，以后再做改变。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CONTEXT MAP无需拘泥于任何特定的文档格式。我发现类似本章的简图在可视化和沟通上下文图方面很有帮助。有些人可能喜欢使用较多的文本描述或别的图形表示。在某些情况下，团队成员之间的讨论就足够了。需求不同，细节层次也不同。不管CONTEXT MAP采用什么形式，它必须在所有项目人员之间共享，并被他们理解。它必须为每个BOUNDED CONTEXT提供一个明确的名称，而且必须阐明联系点和它们的本质。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面介绍的这些模式涵盖了将两个模型关联起来的众多策略。这些模式的主要区别包括你对另一个模型的控制程度、两个团队之前合作水平和合作类型，以及特性和数据的集成程度。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：SHARED KERNEL（共享内核）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当不同团队开发一些紧密相关的应用程序时，如果团队之间不进行协调，即使短时间内能够获得快速进展，但他们开发出的产品可能无法结合到一起。租后可能不得不耗费大量精力在转换层上，并且频繁地进行改动，不如一开始就用CONTINUOUS INTEGRATION那么省心省力，同时这也造成重复工作，并且无法实现公共的UBIQUITOUS LANGUAGE所带来的好处。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;从模型中选出两个团队都同意共享的一个子集。当然，除了这个模型子集以外，还包括与该模型部分相关的代码子集，或数据库设计的子集。这部分明确共享的内容具有特殊的地位，一个团队在没与另一个团队商量的情况下不应擅自更改它。功能系统要经常进行集成，但集成的频率应该比团队中CONTINUOUS INTEGRATION的频率低一些。在进行这些集成的时候，两个团队都要运行测试。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：CUSTOMER/SUPPLIER DEVELOPMENT TEAM（客户/供应商 开发团队）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们经常会碰到这样的情况：一个子系统主要服务于另外一个子系统；“下游”组件执行分析或其他功能，这些功能向“上游”组件反馈的信息非常少，所有依赖都是单向的。两个子系统通常服务于完全不同的用户群，其执行的任务也不同，在这种情况下使用不同的模型会很有帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果下游团队对变更具有否决权，或请求变更的程序太复杂，那么上游团队的开发自由度就会受到限制。由于担心破坏下游系统，上游团队甚至会受到抑制。同时，由于上游团队掌握优先权。下游团队有时也会无能为力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;在两个团队之间建立一种明确的客户/供应商关系。在计划会议中，下游团队相当于上游团队的客户。根据下游团队的需求来协商需要执行的任务并为这些任务做预算，以便每个人都知道双方的约定和进度。两个团队共同开发自动化验收测试，用来验证预期的接口。把这些测试添加到上游团队的测试套件中，以便作为其持续集成的一部分来运行。这些测试使上游团队在做出修改时不必担心对下游团队产生副作用。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：CONFORMIST（承诺）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当两个具有上游/下游关系的团队不归同一个管理者指挥时，CUSTOMER/SUPPLIER TEAM这样的合作模式就不会凑效。勉强应用这种模式会给下游团队带来麻烦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当两个开发团队具有上/下游关系时，如果上游团队没有动力来满足下游团队的需求，那么下游团队将无能为力。出于利他主义的考虑，上游开发人员可能会做出承诺，但他们可能不会履行承诺。下游团队出于良好的意愿会相信这些承诺，从而根据一些永远不会实现的特性来制定计划。下游项目只能被搁置，直到团队最终学会利用现有条件自力更生为止。下游团队不会得到根据他们的需求而量身定做的接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;通过严格遵从上游团队的模型，可以消除在BOUNDED CONTEXT之间进行转换的复杂性。尽管这会限制下游设计人员的风格，而且可能不会得到理想的应用程序模型，但选择CONFORMITY模式可以极大地简化集成。此外，这样还可以与供应商团队共享UBIQUITOUS LANGUAGE。供应商处于统治地位，因此最好使沟通变容易。他们从利他主义的角度出发，会与你分享信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SHARED KERNEL是两个高度协调的团队之间的合作模式，而CONFORMIST模式则是应对一个对合作不感兴趣的团队进行集成。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：ANTICORRUPTION LAYER（隔离层）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;新系统几乎总是需要与遗留系统或其他系统进行集成，这些系统具有自己的模型。当把参与集成的BOUNDED CONTEXT设计完善并且团队相互合作时，转换层可能很简单，甚至很优雅。但是，当边界那侧发生渗透时，转换层就要承担起更多的防护职责。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当正在构建的新系统与另一个系统的接口很大时，为了克服连接两个模型而带来的困难，新模型所表达的意图可能会被完全改变，最终导致它被修改得像另一个系统的模型了（以一种特定风格）。遗留系统的模型通常很弱。即使对于那些模型开发得很好的例外情况，它们可能也不符合当前项目的需要。然而，集成遗留系统仍然具有很大的价值，而且有时还是绝对必要的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;创建一个隔离层，以便根据客户自己的领域模型来为客户提供相关功能。这个层通过另一个系统现有接口与其进行对话，而只需对那个系统作出很少的修改，甚至无需修改。在内部，这个层在两个模型之间进行必要的双向转换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种连接两个系统的机制可能会使我们想到把数据从一个程序传输到另一个程序，或者从一个服务器传输到另一个服务器。我们很快就会讨论技术通信机制的使用。但这些细节问题不应与ANTICORRUPTION LAYER混淆，因为ANTICORRUPTION LAYER并不是向另一个系统发送消息的机制。想反，它是不同的模型和协议之间转换概念对象和操作的机制。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;如何设计ANTICORRUPTION LAYER的接口？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;ANTICORRUPTION LAYER的公共接口通常以一组SERVICE形式出现，但偶尔也会采用ENTITY的形式。在我们的模型中，把外部系统表示为一个单独组件可能是没有意义的。最好是使用多个SERVICE（或偶尔使用ENTITY），其中每个SERVICE都使用我们的模型来履行一致的职责。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;如何实现ANTICORRUPTION LAYER？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;对ANTICORRUPTION LAYER设计进行组织的一种方法是把它实现为FACEDE、ADAPTER和转换器的组合，外加两个系统之间进行对话所需的通信和传输机制。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-bdac6a41194ec4b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;ANTICORRUPTION LAYER的结构&lt;/p&gt;

&lt;/div&gt;
&lt;h3&gt;模式：SEPARATE WAY（各行其道）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们必须严格划定需求的范围。如果两组功能之间的关系并非必不可少，那么二者完全可以彼此独立。因为集成总是代价高昂，而有时获益却很小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;声明一个与其他上下文毫无关联的BOUNDED CONTEXT，使开发人员能够在这个小范围内找到简单、专用的解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;采用SEPARATE WAY（各行其道）模式需要预先决定一些选项。尽管持续重构最后可以撤销任何决策，但完全隔离开发的模型是很难合并的。如果最终仍需要集成，那么转换层将是必要的，而且可能很复杂。当然，不管怎样，这都是我们将要面对的问题。现在，让我们回到更为合作的关系上，来看一下几种提高集成度的模式。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：OPEN HOST SERVICE（开放主机服务）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当一个子系统必须与大量其他系统进行集成时，为每个集成都定制一个转换层可能会减慢团队的工作速度。需要维护的东西会越来越多。而且进行修改的时候担心的事情也会越来越多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;定义一个协议，把你的子系统作为一组SERVICE供其他系统访问。开放这个协议，以便所有需要与你的子系统集成的人都可以使用它。当有新的集成需求时，就增强并扩展这个协议，但个别团队的特殊需求除外。满足这种特殊需求的方法是使用一次性的转换器来扩充协议，以便使共享协议简单且内聚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种通信形式暗含一些共享的模型词汇，它们是SERVICE接口的基础。这样，其他子系统就变成了与OPEN HOST（开放主机）的模型相连接，而其他团队则必须学习HOST团队所使用的专用术语。在一些情况下，使用一个众所周知的PUBLISHED LANGUAGE（公开发布的语言）作为交换模型可以减少耦合并简化理解。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：PUBLISHED LANGUAGE（公开发布的语言）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;与现有领域模型进行直接的转换可能不是一种好的解决方案。这些模型可能过于复杂或设计得较差。它们可能没有被很好地文档化。如果把其中一个模型作为数据交互语言，它实际上就被固定住了，而无法满足新的开发需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;把一个良好文档化的、能够表达出所需领域信息的共享语言作为公共的通信媒介，必要时在其他信息与该语言之间进行转换。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;“大象”的统一&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;讲一个盲人摸象的故事：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;第一个盲人碰巧摸到了大象宽阔结实的身躯，就以为大象就像一堵墙；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;······&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三个盲人碰巧把扭动着的象鼻抓在书中，就大胆认为大象就像一条蛇；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四个盲人急切伸出双手，摸到了大象的膝盖，就很明显地认为大象就像一颗树；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;······&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第六个盲人一开始摸这头大象，就抓住了它摆动着的尾巴，就认为大象就像一根绳子。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;即便他们对大象的本质不能达成完成的一致，这些盲人仍然可以根据他们所触摸到的大象身体的部位来扩展各自的认识。如果并不需要集成，那么模型统不统一就无关紧要。如果他们需要进行一些集成，那么实际上并不需要对大象是什么达成一致，而只要接受各种不同意见就会获得很多价值。这样，他们就会在不知不觉中各执己见。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-fe3e491cae948f76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;4个没有集成的上下文&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当盲人想要分享更多大象的信息时，他们会共享单个BOUNDED CONTEXT得到更大的价值。但统一多个模型几乎总是意味着创建一个新模型：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-d6d7e0042d112aec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;4个只有最小集成的上下文&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;经过一些想象和讨论（也许是激烈的讨论）之后，盲人们最终可能会认识到他们正在对一个更大整体的不同部分进行描述和建模。从很多方面来讲，部分-整体的统一可能不需要花费很多工作。至少集成的第一步只需弄清楚各个部分是如何相连的就够了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-bd4f8962d9c87374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;一个粗略集成的上下文&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;尽管我们已经把部分合并成一个整体，但得到的模型还是很简陋的。他缺乏内聚性，也没有形成任何潜在的领域的轮廓。在持续精华的过程中，新的理解可能会产生更深层的模型。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-48ca1c74ed07d0ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;一个更深入集成的上下文&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;承认多个相互冲突的领域模型实际上正式面对现实的做法。通过明确定义每个模型都适用的上下文，可以维护每个模型的完整性，并清楚地看到要在两个模型之间创建的任何特殊接口的含义。盲人没办法看到整个大象，但只要他们承认各自的理解是不完整的，他们的问题就能得到解决。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;选择你的模型上下文策略&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在任何时候，绘制出CONTEXT MAP来反映当前状况都是很重要的。但是，一旦绘制好CONTEXT MAP之后，你很可能想要改变现状。现状，你可以开始有意识地选择CONTEXT的边界和关系。以下是一些指导原则：&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、团队决策或更高层决策&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;按照本身价值来说，在决定是否扩展或分割BOUNDED CONTEXT时，应该权衡团队独立工作的价值以及能产生直接且丰富集成的价值，以这两种价值的成本-效益作为决策的依据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实践中，团队之间的行政关系往往决定了系统的集成方式。由于汇报结构，有技术优势的统一可能无法实现。管理层所要求的合并可能并不实用。你不会总能得到你想要的东西，大你至少可以评估出这些决策的代价，并反映给管理层，以便采取相应的措施来减少代价。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、置身上下文中&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;开发软件项目时，我们首先是对自己团队正在开发的那些部分感兴趣（“设计中的系统”），其次是对那些与我们交互的系统感兴趣。这是一种简单、典型的情况，能让你对可能遇到的情形有一些粗略的了解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上，我们正式自己所处理的主要CONTEXT的一部分，这会在我们的CONTEXT MAP中反映出来。只要我们知道自己存在偏好，并且超过该CONTEXT MAP的应用边界时能够意识到已越界，那么就不会有什么问题。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3、转换边界&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在画出BOUNDED CONTEXT的边界时，有无数种情况，也有无数种选择。但权衡时所要考虑的通常是下面所列出的某些因素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首选较大的BOUNDED CONTEXT：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 当用一个统一模型来处理更多任务时，用户任务之间的流动更顺畅。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 一个内聚模型比两个不同模型再加它们之间的映射更容易理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 两个模型之间的转换可能会很难（有时甚至是不可能的）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 共享语言可以使团队沟通起来更清楚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首选较小的BOUNDED CONTEXT：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 开发人员之间的沟通开销减少了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 由于团队和代码规模较小，CONTINOUS INTEGRATION更容易了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 较大的上下文要求更加通用的抽象模型，而掌握所需技巧的人员会出现短缺。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 不同模型可以满足一些特殊需求，或者是能够把一些特殊用户群的专门术语和UBIQUITOUS LANGUAGE的专门术语包括进来。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;4、接受那些我们无法更改的事物：描述外部系统&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;最好从一些简单的决策开始。一些子系统显然不在开发中的系统的任何BOUNDED CONTEXT中。一些无法立即淘汰的大型遗留系统和那些提供所需服务的外部系统就是这样的例子。我们很容易就能识别出这些系统，并把它们与你的设计隔离开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在做出假设时必须要保持谨慎。我们会轻易地认为这些系统构成了其自己的BOUNDED CONTEXT，但大多数外部系统只是勉强满足定义。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;5、与外部系统的关系&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;这里可以应用3种模式。首先，可以考虑SEPARATE WAY模式。当然，如果你不需要集成，就不用把它们包括进来。但一定要真正确定不需要集成。只为用户提供对两个系统的简单访问确实够用吗？集成要花费很大的代价而且还会分散精力，因此要尽可能为你的项目减轻负担。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果集成确实非常重要，可以在两种极端的模式之中选择：CONFORMIST模式或ANTICORRUPTION LAYER模式。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;6、设计中的系统&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;你的项目团队正在构建的软件就是设计中的系统。你可以在这个区域内声明BOUNDED CONTEXT，并在每个BOUNDED CONTEXT中应用CONTINOUS INTEGRATION，以便保持它们的统一。但应该有几个上下文呢？各个上下文之间又应该是什么关系呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;情况可能非常简单：设计中的整个系统使用一个BOUNDED CONTEXT。例如，当一个少于10个人的团队正在开发高度相关的功能时，这可能就是一个很好的选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随着团队规模的增大，CONTINOUS INTEGRATION可能会变得困难起来（尽管我也曾看过一些较大的团队仍能保持持续集成）。你可能希望采用SHARED KERNEL模式，并把几组相对独立的功能划分到不同的BOUNDED CONTEXT中，使得在每个BOUNDED CONTEXT中工作的人员少于10人。在这些BOUNDED CONTEXT中，如果有两个上下文之间的所有依赖都是单向的，就可以建成CUSTOMER/SUPPLIER DEVELOPMENT TEAM。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可能认识到两个团队的思想截然不同，以致他们的建模工作总是发生矛盾。如果这种矛盾的原因是你无法改变或不想改变的，那么可以让他们的模型采用SEPARATE WAY模式。在需要集成的地方，两个团队可以共同开发维护一个转换层，把它作为唯一的CONTINOUS INTEGRATION点。这与同外部系统的集成正好相反，在外部集成中，一般由ANTICORRUPTION LAYER来起调节作用，而且从另一端得不到太多的支持。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般来说，每个BOUNDED CONTEXT对应一个团队。一个团队也可以维护多个BOUNDED CONTEXT，但多个团队在一个上下文中工作却是比较难的。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;7、用不同模型满足特殊需求&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;你可能决定通过不同的BOUNDED CONTEXT来满足这些特殊需求，除了转换层的CONTINOUS INTEGTATION以外，让模型采用SEPARATE WAY模式。UBIQUITOUS LANGUAGE的不同专用术语将围绕这些模型以及它们所基于的行话来发展。如果两种专用术语有很多重叠之处，那么SHARED KERNEL模式就可以满足特殊化要求，同时又能把转换成本减至最小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最重要的是：这个用户群的专门术语有多大的价值？你必须在团队独立操作的价值与转换的风险之间做出权衡，并且留心合理地处理一些没有价值的术语变化。但记住，在需要大量集成的地方，转换成本会大大增加。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;8、部署&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在复杂系统中，对打包和部署进行协调是一项繁琐的任务，这类任务总是要比看上去难得多。BOUNDED CONTEXT策略的选择将影响部署。由于部署环境和技术存在不同，有很多技术因素需要考虑。但BOUNDED CONTEXT关系可以为我们指出重点问题。转换接口已经被标出。所以，绘制CONTEXT边界时应该反映出部署计划的可行性。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;9、权衡&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;通过总结这些知道原则可知有很多统一或集成模型的策略。一般来说，我们需要在无缝功能集成的益处和额外的协调和沟通工作之间做出权衡。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-fa27a699f75a5113.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;CONTEXT关系模型的相对要求&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;10、当项目正在进行时&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;很多情况下，我们不是从头开发一个项目，而是会改进一个正在开发的项目。在这种情况下，第一步是根据当前的状况来定义BOUNDED CONTEXT。这很关键。为了有效地定义上下文，CONTEXT MAP必须反映出团队的实际工作，而不是反映那个通过遵守以上描述的指导原则而得出的理想组织。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;描述了当前真实的BOUNDED CONTEXT以及它们的关系以后，下一步就是围绕当前组织结构来加强团队的工作。在CONTEXT中加强CONTINOUS INTEGRATION。把所有分散的转换代码重构到ANTICORRUPTION LAYER中。命名现有的BOUNDED CONTEXT，并确保它们处于项目的UBIQUITOUS LANGUAGE中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一节将讨论如何修改CONTEXT边界：转换。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;转换&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;像建模和设计的其他方面，有关BOUNDED CONTEXT的决策并非不可改变的。在很多情况下，我们必须改变最初有关边界以及BOUNDED CONTEXT之间关系的决策，这是不可避免的。一般而言，分割CONTEXT是很容易，但合并它们或改变它们之间的关系却很难。下面将介绍几种有代表性的修改，它们很难，但也很重要。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、合并CONTEXT：SEPARETE WAY→SHARED KERNEL&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;合并BOUNDED CONTEXT的动机很多：翻译开销够高、重复现象很明显。合并很难，但什么时候做都不晚，只是需要一些耐心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即使你的最终目标是完全合并一个采用CONTINUOS INTEGRATION的CONTEXT，也应该先过渡到SHARED KERNEL。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）评估现状。在开始统一两个CONTEXT之前，一定要确信它们确实需要统一。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）建立合并过程。你需要决定代码的共享方式以及模块应该采用哪种命名约定。SHARED KERNEL的代码至少每周要集成一次，而且它必须有一个测试套件。在开发任何共享代码之前，先把它设置好。（测试套件将是空的，因此很容易通过！）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）选择某个小的子领域作为开始，它应该是两个CONTEXT中重复出现的子领域，但不是CORE DOMAIN的一部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）从两个团队中共选出2~4位开发人员组成一个小组，有他们来为子领域开发一个共享的模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）来自两个团队的开发成员一起负责实现模型（或修改要共享的现有代码）、确定各种细节并使模型开始工作。如果这些开发人员在模型中遇到了问题，就从第（3）步开始重新组织团队，并进行必要的概念修订工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）每个团队的开发人员都承担与新的SHARED KERNEL集成的任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（7）清除那些不再需要的翻译。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、合并CONTEXT：SHARED KERNEL→CONTINOUS INTEGRATION&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如果你的KERNEL正在扩大，你可能会被完全统一两个BOUNDED CONTEXT的优点所吸引。但这并不只是一个解决模型差异的问题。你将改变团队的结构，而且最终会改变人们所使用的语言。这个过程从人员和团队开始准备。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）确保每个团队都已经建立了CONTINOUS INTEGRATION所需的所有过程（共享代码所有权、频繁集成等）。两个团队协商集成步骤，以便所有人都以同一步调工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）团队成员在团队之间流动。这样可以形成一大批同时理解两个模型的人员，并且可以把两个团队的人员联系起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）澄清每个模型的精髓。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）现在，团队应该有了足够的信心把核心领域合并到SHARED KERNEL中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）随着SHARED KERNEL的增长，把集成频率提高到每天一次，最后实现CONTINOUS INTEGRATION。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）当SHARED KERNEL逐渐把先前两个BOUNDED CONTEXT的所有内容都包括进来的时候，你会发现要么形成了一个大的团队，要么形成了两个较小的团队，这两个较小的团队共享一个CONTINOUS INTEGRATION的代码库，而且团队成员可以经常在两个团队之间来回流动。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3、逐步淘汰遗留系统&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;好花美丽不常开，好景怡人不常在，就算遗留计算机软件也一样会走向终结。但这可不会自动自发地出现。这些老的系统可能与业务及其他系统紧密交织在一起，因此淘汰它们可能需要很多年。好在我们并不需要一次就把所有东西都淘汰掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先要执行的步骤是确定测试策略。应该为新系统中的新功能编写自动的单元测试，但逐步淘汰遗留系统还有一些特殊的测试要求。一些组织会在某段时间内同时运行新旧两个系统。在任何一次迭代中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）确定遗留系统的哪个功能可以在一个迭代中被添加到某个新系统中；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）确定需要在ANTICORRUPTION LAYER中添加功能；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）实现；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）部署；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）找出ANTICORRUPTION LAYER中那些不必要的部分，并去掉它们；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）考虑删除遗留系统中目前未被使用的模块，虽然这种做法未必实际。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不断重复这几个步骤。遗留系统应该越来越少地参与业务，最终，替换工作会看到希望的曙光并完全停止遗留系统。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;4、OPEN HOST SERVICE→PUBLISHED LANGUAGE&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;我们已经通过一系列特地的协议与其他系统进行了集成，但随着需要访问的系统逐渐增多，维护负担也不断增加，或者交互变得很难理解。我们需要通过PUBLISHED LANGUAGE来规范系统之间的关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）如果有一种行业标准语言可用，则尽可能评估并使用它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）如果没有标准语言或预先公开发布的语言，则完善作为HOST的系统的CORE DOMAIN。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）使用CORE DOMAIN作为交换语言的基础，尽可能使用像XML这样的标准交互范式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）（至少）向所有参与协作的各方发布语言。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）如果涉及新的系统架构，那么也要发布它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）为每个协作系统构建转换层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（7）切换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，当加入更多协作系统时，对整个系统的破坏已经减至最小了。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：学以致用，具体问题具体分析。模式毕竟是巨人的肩膀，要学会站着巨人肩膀看事情，无论项目多大还是多下，又或者团队多大还是多小，总有属于当前自己的模式。结合自身情况，找准定位。我们所做的大部分事情几乎都有方法或模式借鉴，千万不要埋头单干。就像耗子叔所说，学会Evidence Driven：任何讨论和分析都要基于权威的证据、数据或是引用。在我们做设计的时候，或是有争论的时候，说服对方最好的方式就是拿出证据、数据或是权威引用。比如：我的XX设计参考了TCP协议中的XX设计，我的XX观点是基于XX开源软件的实现……如果争论不休就停止争论，然后各自收集和调查自己观点的佐证。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;第15章：精炼&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如何才能专注于核心问题而不被大量的次要问题淹没呢？LAYERED ARCHITECTURE可以把领域概念从技术逻辑中（技术逻辑确保了计算机系统能够运转）分离出来，但在大型系统中，即使领域被分离出来，它的复杂性也可能仍然难以管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;精炼是把一堆混杂在一起的组件分开的过程，以便通过某种形式从中提取出最重要的内容，而这种形式将使它更有价值，也更有用。模型就是知识的精炼。通过每次重构所得到的更深层的理解，我们得以把关键的领域知识和优先级提取出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本章将展示对CORE DOMAIN进行战略精炼的系统性方法，解释如何在团队中有效地统一认识，并提供一种用于讨论工作的语言。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-c21cabfdd9955fe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;战略精炼的导航图&lt;/p&gt;

&lt;/div&gt;
&lt;h3&gt;模式：CORE DOMAIN（核心领域）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在设计大型系统时，有非常多的组成部分——它们都很复杂而且对开发的功能也至关重要，到导致真正的业务资产——领域模型最为精华的部分——被掩盖和忽略了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个严峻的现实是我们不可能对所有设计部分进行同等的精化，而是必须分出优先级。为了使领域模型成为有价值的资产，必须整齐地梳理出模型的真正核心，并完全根据这个核心来创建应用程序的功能。但本来就稀缺的高水平开发人员往往会把工作重点放在技术基础设施上，或者只是去解决那些不需要专门领域知识就能理解的领域问题（这些问题都已经有了很好的定义）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;对模型进行提炼。找到CORE DOMAIN并提供一种易于区分的方法把它与那些去辅助作用的模型和代码分开。最有价值和最专业的概念要轮廓分明。尽量压缩CORE DOMAIN。让最有才能的人来开发CORE DOMAIN，并据此要求进行相应的招聘。在CORE DOMAIN中努力开发能够确保现实系统蓝图的深层模型和柔性设计。仔细判断任何其他部分的投入，看它是否能够支持这个提炼出来的CORE。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、选择核心&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;我们需要关注的是那些能够表示业务领域并解决业务问题的模型部分。一个应用程序中的CORE DOMAIN在另一个应用程序中可能只是通用的支持组件。尽管如此，仍然可以在一个项目中（而且通常在一个公司中）定义一个一致的CORE。像其他设计部分一样，人们对CORE DOMAIN的认识也会随着迭代而发展。开始时，一些特殊关系可能显得不重要。而最初被认为是核心对象可能逐渐被证明只是起支持作用。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、工作的分配&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在项目团队中，技术能力最强的人员往往缺乏丰富的领域知识。这限制了他们的作用，并且更倾向于分派他们来开发一些支持组件，从而形成了一个恶性循环——知识的缺乏使他们远离了那些能够学到领域知识的工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打破这种恶心循环是很重要的，方法是建立一支由开发人员和一位或多位领域专家组成的联合团队，其中开发人员必须能力很强、能够长期稳定地工作并且学习领域知识非常感兴趣，而领域专家则要掌握深厚的业务知识。如果你认真对待领域设计，那么它就是一项有趣且充满技术挑战的工作。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3、精炼的逐步提升&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;本章接下来将要介绍各种精炼技术，它们在使用顺序上基本没什么要求，但对设计的改动却大不相同。请往下看：&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：GENERIC SUBDOMIAN（通用子领域）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;模型中有些部分除了增加复杂性以外并没有捕捉或传递任何专门的知识。任何外来因素都会是CORE DOMAIN愈发的难以分辨和理解。模型中充斥着大量众所周知的一般原则，或者专门的细节，这些细节并不是我们的主要关注点，而只是起到支持作用。然而，无论它们是多么通用的元素，它们对实现系统功能和充分表达模型都是极为重要的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;识别出那些与项目意图无关的内聚子领域。把这些子领域的通用模型提取出来，并放到单独的MODULE中。任何专有的东西都不应该放在这些模块中。把它们分离出来以后，在继续开发的过程中，它们的优先级应低于CORE DOMAIN的优先级，并且不要分派核心开发人员来完成这些任务（因为他们很少能够从这些任务中获得领域知识）。此外，还可以考虑为这些GENERIC SUBDOMAIN使用现成的解决方案或“公开发布的模型”（PUBLISHED MODEL）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当开发这样的软件包时，有以下几种选择：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、现成的解决方案&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、公开发布的设计或模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、把实现外包出去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、内部实现&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：DOMAIN VISION STATEMENT（领域愿景说明）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在项目开始时，模型通常并不存在，但是模型开发的需求是早就确定下来的重点。在后面的开发阶段，我们需要解释清楚系统的价值，但这并不需要深入地分析模型。此外，领域模型的关键方面可能跨越多个BOUNDED CONTEXT，而且从定义上看，无法将这些彼此不同的模型组织起来表明其共同的关注点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;写一份CORE DOMAIN的简短描述（大约一页纸）以及它将会创造的价值，也就是“价值主张”。那些不能将你的领域模型与其他领域模型区分开的方面就不要写了。展示出领域模型是如何实现和均衡各方面利益的。这份描述要尽量精简。尽早把它写出来，随着新的理解随时修改它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DOMAIN VISION STATEMENT可以用作一个指南，它帮助开发团队在精炼模型和代码的过程中保持统一的方向。团队中的非技术成员，管理层甚至是客户也都可以共享领域愿景说明。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：HIGHLIGHTED CORE（突出核心）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;DOMAIN VISION STATEMENT从宽泛的角度对CORE DOMAIN进行了说明，但它把什么是具体核心模型元素留给人们自己去解释和猜测。除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非团队的沟通极其充分，否则单靠VISION STATEMENT是很难产生什么效果的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽管团队成员可能大体上知道核心领域是由什么构成的，但CORE DOMIAN中到底包含哪些元素，不同的人会有不同的理解，甚至同一个人在不同的时间也有会不同的理解。如果我们总是要不断过滤模型以便识别出关键部分，那么就会分散本应该投入到设计上的精力，而且这还需要广泛的模型知识。因此，CORE DOMAIN必须要很容易被分辨出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对代码所做的重大结构性改动是识别CORE DOMAIN的理想方式，但这些改动往往无法在短期内完成。事实上，如果团队的认识还不够全面，这样的重大代码修改是很难进行的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过修改模型的组织结构（如划分GENERIC SUBDOMIAN和本章后面要介绍的一些改动），可以用MODULE表达出核心领域。但如果把它作为表达CORE DOMAIN的唯一方法，那么对模型的改动会很大，因此很难马上看到结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可能需要用一种轻量级的解决方案来补充这些激进的技术手段。可能有一些约束使你无法从物理上分离出CORE，或者你可能是从已有代码开始工作的，而这些代码并没有很好地区分出CORE，但你确实很需要知道什么是CORE并建立共识，以便有效地通过重构进行更好的精炼。我们可以通过以下两种典型的代表性技术来突出核心：&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、精炼文档&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;编写一个非常简短的文档（3~7页，每页内容不必太多），用于描述CORE DOMAIN以及CORE元素之间的主要交互过程。但独立文档带来的所有常见风险也会在这里出现（如下所示），控制这些风险的最好方法是保持绝对的精简。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）文档可能得不到维护；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）文档可能没人阅读；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）由于多个信息来源，文档可能达不到简化复杂性的目的。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、标明CORE&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;可能你会遇到一份数百页的“领域模型”文档等资料，但无需慌张。把模型的主要存储库中的CORE DOMAIN标记出来，不用特意去阐明其角色。是开发人员很容易就知道什么在核心内，什么在核心外。只需做很少的处理和维护工作，即可让处理模型的人员很清晰地看到CORE DOMAIN了。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;因此：把精炼文档作为过程工具&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如果精炼文档概括了CORE DOMAIN的核心元素，那么它就可以作为一个指示器——用以指示模型改变的重要程度。当模型或代码的修改影响到精炼文档时，需要与团队其他成员一起协商。当对精炼文档做出修改时，需要立即通知所有团队成员，而且要把心版本的文档分发给他们。CORE外部的修改或精炼文档外部的细节修改则无需协商或通知，可以直接把它们集成到系统中，其他成员在后续工作过程中自然会看到这些修改。这样开发人员就拥有了XP所建议的完全的自治性。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：COHESIVE MECHANISM（内聚机制）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;计算有时会非常复杂，使设计开始变得膨胀。机械性的“如何做”大量增加，把概念性的“做什么”完全掩盖了。为了解决问题提供算法的大量方法掩盖了那些用于表达问题的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;把概念上的COHESIVE MECHANISM（内聚机制）分离到一个单独的轻量级框架中。要特别注意公式或那些有完备文档的算法。用一个INTENTION-REVEALING INTERFACE来暴露这个框架的功能。现在，领域中的其他元素就可以只专注于如何表达问题（做什么）了，而把解决方案的复杂细节（如何做）转移给了框架。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;GENERIC SUBDOMAIN和COHESIVE MECHANISM有什么不同？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;GENERIC SUBDOMIAN与COHESIVE MECHANISM的动机是相同的——都是为CORE DOMAIN减负。区别在于二者所承担的职责的性质不同。GENERIC SUBDOMAIN是以描述性的模型作为基础的，它用这个模型表示出团队会如何看待领域的某个方面。在这一点上与CORE DOMIAN没什么区别，只是重要性和专门程度较低而已。COHESIVE MECHANISM并不表示领域，它的目的是解决描述性模型所提出来的一些复杂的计算问题。模型提出问题，COHESIVE MECHANISM解决问题。所以GENERIC SUBDOMAIN是模型级别维度，而COHESIVE MECHANISM是CORE DOMAIN的一部分。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式提升：通过精炼得到声明式风格&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;声明式设计是一种精简的设计风格，在本书中也多处提及。精炼的价值在于使你能够看到自己正在做什么，不让无关细节分散你的注意力，并通过不断削减得到核心。如果领域中那些起到支持作用的部分提供了一种简练的语言，可用于表示CORE的概念和规则，同时又能够把计算或实施这些概念和规则的方式封装起来，那么CORE DOMAIN的重要部分就可以采用声明式设计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;COHESIVE MACHANISM用途最大的地方是它通过设计一个INTENTION-REVEALING INTERFACE来提供访问，并且具有概念上一致的ASSERTION和SIDE-EFFECT-FREE FUNCTION。利用这些MECHANISM和柔性设计，CORE DOMAIN可以使用有意义的声明，而不必调用难懂的函数。但最不同寻常的回报来自于使CORE DOMAIN的一部分产生突破，得到一个深层模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把GENERIC SUBDOMAIN提取出来可以减少混乱，而COHESIVE MECHANISM可以把复杂操作封装起来。这样可以得到一个更专注的模型，从而减少了那些对用户活动没什么价值、分散注意力的方面。但我们不太可能为领域模型中所有非CORE元素安排一个适当的去处。SEGREGATED CORE（分离的核心）采用直接的方法从结构上把CORE DOMAIN划分出来。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：SEGREGATED CORE（分离的核心）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;模型中的元素可能有一部分属于CORE DOMAIN，而另一部分起支持作用。核心元素可能与一般元素紧密耦合在一起。CORE的概念内聚性可能不很强，看上去也不明显。这种混乱性和耦合关系抑制了CORE。设计人员如果无法清晰地看到最重要的关系，就会开发出脆弱的设计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过把GENERIC SUBDOMAIN提取出来，可以从领域中清除一些干扰性的细节，使CORE变得更清楚。但识别和澄清所有这些子领域是很困难的工作，而且有些工作看起来并不值得去做。同事，最重要的CORE DOMAIN仍然与剩下的那些元素纠缠在一起。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;对模型进行重构，把核心概念从支持性元素（包括定义得不清楚的那些元素）中分离出来，并增强CORE的内聚性，同时减少它与其他代码的耦合。把所有通用元素或支持性元素提取出来到其他对象中，并把这些对象放到其他的包中——即使这会把一些紧密耦合的元素分开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里基本上采用了与GENERIC SUBDOMAIN一样的原则，只是从另一个方向考虑而已。就目前来看，使用哪种简单解决方案都可以，只需把注意力集中在SEGREGATED CORE（分离的核心）上即可。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：ABSTRACT CORE&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;通常，即便是CORE DOMAIN模型也会包含太多的细节，以至于它很难表达出整体视图。当不同MODULE的子领域之间有大量交互时，要么需要在MODULE之间创建很多引用，这在很大程度上抵消了划分模块的价值；要么就必须间接地实现这些交互，而后者会使模型变得晦涩难度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;把模型中最基本的概念识别出来，并分离到不同的类、抽象类或接口中。设计这个抽象模型，使之能够表达重要组件之间的大部分交互。把这个完整的抽象模型放到它自己的MODULE中，而专用的、详细的实现类则留在由子领域定义的MODULE中。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：我很幸运，能遇到一个近做了近十年的大型应用项目，我记得从刚开始只有两台刀片机服务发展至目前百来台高配置级别的PC规模。虽然我现在才看到这本书，但这十年的摸索过程其实就是这章节的实现。实在是非常宝贵的经验。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;第16章：大型结构&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在一个大的系统中，如果因为缺少一种全局性的原则而使人们无法根据元素在模式（这些模式被应用于整个设计）中的角色来解释这些元素，那么开发人员就会陷入“只见树木，不见森林”的境地。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;“大型结构”是一种语言，人们可以用它来从大局上讨论和理解系统。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;设计一种应用于整个系统的规则（或角色和关系）模式，使人们可以通过它在一定程度上了解各个部分在整体中所处的位置（即使是在不知道各个部分的详细职责的情况下）。本章将探讨一些能成功构建这种设计结构的模式。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-6e47ad2e7fef625e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;一些大型结构模式&lt;/p&gt;

&lt;/div&gt;
&lt;h3&gt;模式：EVOLVING ORDER（演化有序）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;一个没有任何规则的随意设计会产生一些无法理解整体含义且很难维护的系统。但架构中早期的设计假设又会使项目变得束手无策，而且会极大地限制应用程序中某些部分的开发人员/设计人员的能力。很快，开发人员就会为适应结构而不得不在应用程序的开发上委曲求全，要么就是完全推翻架构而又回到没有协调的开发老路上来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;让这种概念上的大型结构随着应用程序一起演变，甚至可以变成一种完全不同结构的风格。不要依次过分限制详细的设计和模型决策，这些决策和模型决策必须在掌握了详细之后才能确定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于CONTEXT MAP不同的是，大型结构是可选的。当发现一种大型结构可以明显使系统变得更加清晰，而又没有对模型开发施加一些不自然的约束时，就应该采用这种结构。使用不合适的结构还不如不使用它，因此最好不要为了追求设计的完整性而勉强去使用一种结构，而应该找到尽可能精简的方式解决所出现问题。要记住宁缺毋滥的原则。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：SYSTEM METAPHOR（系统隐喻）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;软件设计往往非常抽象且难于掌握。开发人员和用户都需要一些切实可行的方式来理解系统，并共享系统的一个整体视图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;当系统的一个具体类比正好符合团队成员对系统的想象，并且能够引导他们向着一个有用的方向进行思考时，就应该把这个类比用作一种大型结构。围绕这个隐喻来组织设计，并把它吸收到UBIQUITOUS LANGUAGE中。SYSTEM METAPHOR应该既能促进系统的交流，又能指导系统的开发。它可以增加系统不同部分之间的一致性，甚至可以跨越不同的BOUNDED CONTEXT。但所有隐喻都不是完全精确的，因此应不断检查隐喻是否过度或不恰当，当发现它起到妨碍作用时，要随时准备放弃它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYSTEM METAPHOR并不适用于所有项目。从总体上讲，大型结构不是必须要用的。在极限编程的12个实践中，SYSTEM METAPHOR的角色可以由UBIQUITOUS LANGUAGE来承担。当项目中发现一种非常适合的SYSTEM METAPHOR或其他大型结构时，应该用它来补充UBIQUITOUS LANGUAGE。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：RESPONSIBILITY LAYER（职责分层）&lt;/h3&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-1b341e73c3a64a3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;自发分层，这些包描述了什么事情&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果每个对象的职责都是人为分配的，将没有统一的指导原则和一致性，也无法把领域作为一个整体来处理。为了保持大型模型的一致，有必要在职责分配上实施一定的结构化控制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;注意观察模型中的概念依赖性，以及领域中不同部分的变化频率和变化的原因。如果在领域中发现了自然的层次结构，就把它们转换为宽泛的抽象职责。这些职责应该描述系统的高层目的和设计。对模型进行重构，使得每个领域对象，AGGREGATE和MODULE的职责都清晰地位于一个职责层当中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想要找到一种适当的RESPONSIBILITY LAYER或大比例结构，需要理解问题领域并反复进行实验。如果遵循EVOLVING ORDER，那么最初的起点并不是十分重要，尽管差劲的选择确实会加大工作量。结构可能最后演变得面目全非。因此，下面将给出一些指导方针，无论是刚开始选择一种结构，还是对已有结构进行转换，这些指导方针都适用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当对层进行删除、合并、拆分和重新定义等操作时，应寻找并保留一下一些有用的特征：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 场景描述。层应该能够表达出领域的基本实现或优先级选择一种大比例结构与其说是一种技术决策，不如说是一种业务建模决策。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 概念依赖性。“较高”层概念的意义应该依赖“较低”层，而低层概念的意义应该独立于较高层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ CONCEPTUAL CONTOUR。如果不同层的对象必须具有不同的变化频率或原因，那么层应该能够容许它们之间的变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 潜能层。我们能够做什么？潜能层不关心我们打算做什么，而关心能够做什么。如企业的资源（包括人力资源）以及这些资源的组织方式是潜能层的核心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 作业层。我们正在做什么？我们利用这些潜能做了什么事情？像潜能层一样，这个层也应该反映出现实情况，而不是我们设想的状况。如我们希望在这个层中看到自己的工作和活动：我们正在销售什么，而不是能够销售什么。通常来说，作业层对象可以引用潜能层对象，它甚至可以由潜能层对象组成，但潜能层对象不应该引用作业层对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 决策支持层。应该采取什么行动或制定什么策略？这个层是用来作出分析和制定决策的。它根据来自较低层（如潜能层或作业层）的信息进行分析。决策支持软件可以利用历史信息来主动寻找适用于当前和未来作业的机会&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 策略层。规则和目标是什么？规则和目标主要是被动的，但它们约束着其他层的行为。这些交互的设计是一个微妙的问题。有时策略会作为一个参数传递给较低层的方法。有时会使用STRATEGY模式。策略层与决策支持层能够进行很好的协作，决策支持层提供了用于搜索策略层所设定的目标的方式，这些目标又受到策略层设定的规则约束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 承诺层。我们承诺了什么？这个层具有策略层的性质，因为他表述了一些指导未来运营的目标；但它也有作业层的性质，因为承诺是作为后续因为活动的一部分而出现和变化的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然这5个层对很多企业系统都适用，但并不是所有领域的主要概念都涵盖在这5个层中。有些情况下，在设计中生硬地套用这种形式反而会起反作用，而使用一组更自然的RESPONSIBILITY LAYER会更有效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们需要对分层结构进行调整和实验，但一定要使分层系统保持简单，如果层数超过4或5，就比较难处理了。层数越多将无法有效地描述领域，而且本来要使用大比例结构解决的复杂性问题又会以一种新的方式出现。我们必须对大比例结构进行严格的精简。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果一个领域与上述讨论毫无关系，所有的分层可能都必须从头开始。最后，我们必须根据直觉选择一个起点，然后通过EVOLVING ORDER来改进它。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：KNOWLEGE LEVEL（知识级别）&lt;/h3&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-5fb636d4df712bb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;员工工资和养老金系统的原来模型，在新的需求下被过多地约束&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果在一个应用程序中，ENTITY的角色和它们之间的关系在不同的情况下有很大变化，那么复杂性会显著增加。在这种情况下，无论是一般的模型还是高度定制的模型，都无法满足用户的需求。为了兼顾各种不同的情形，对象需要引用其他的类型，或者需要具备一些在不同情况下包括不同使用方式的属性。具有相同数据和行为的类可能会大量增加，而这些类的唯一作用只是为了满足不同的组装规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;创建一组不同的对象，用它们来描述和约束基本模型的结构和行为。把这些对象分为两个“级别”，一个是非常具体的级别，另一个级别则提供了一些可供用户或超级用户定制的规则和知识。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果得到合理的运用，KNOWLEDGE LEVEL能够解决一些其他方式很难解决的问题。如果系统中某些部分的定制非常关键，而要是不提供定制能力就会破坏掉整个设计，这时就可以利用知识级别来解决这一问题。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-9dc3222492fc088e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;Payroll现在已经显示出来，它已与Employee Type分离&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;像其他大比例结构一样，KNOWLEDGE LEVEL也不是必须要使用的。没有它，对象照样能工作，而且团队可能仍然能够认识到他们需要将Employee与Payroll分离。当项目进行到某个时刻，这种结构看起来已经没什么用了，那么就可以放弃它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;咋看上去，KNOWLEDGE LEVEL像是RESPONSIBILITY LAYER（特别是策略层）的一个特例，但它并不是。首先，KNOWLEDGE LEVEL两个级别之间的依赖是双向的，而RESPONSIBILITY LAYER在层次结构中，较低的层不依赖于较高的层。实际上，RESPONSIBILITY LAYER可以与其他大部分的大比例结构共存，它提供了另一种用来组织模型的维度。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;模式：PLUGGABLE COMPONENT FRAMEWORK（ 可插入式组件框架 ）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在深入理解和反复精炼基础上得到的成熟模型中，会出现很多机会。通常只有在同一个领域中实现了多个应用程序之后，才有机会使用PLUGGABLE COMPONENT FRAMEWORK（可插入式组件框架）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当很多应用程序需要进行相互操作时，如果应用程序都基于相同的一些抽象，但它们是独立设计的，那么在多个BOUNDED CONTEXT之间的转换会限制它们的集成。各个团队之间如果不能紧密地协作，就无法形成一个SHARED KERNEL。重复和分裂将会增加开发和安装的成本，而且互操作会变得很难实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;因此：&lt;/strong&gt;从接口和交互中提炼一个ABSTRACT CORE，并创建一个框架，这个框架要允许这些接口各种不同实现被自由替换。同样，无论是什么应用程序，只要它严格地通过ABSTRACT CORE的接口进行操作，那么就可以允许它使用这些组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PLUGGABLE COMPONENT FRAMEWORK也有几个缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 一个缺点是它是一种非常难以使用的模式。它需要高度精确的接口设计和一个非常深入的模型，以便把一些必要的行为捕获到ABSTRACT CORE中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;□ 另一个很大的缺点是它只为应用程序提供了有限的选择。如果一个应用程序需要对CORE DOMAIN使用一种非常不同的方法，那么可插入式组件框架将起到妨碍作用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;总结：通过重构得到更适当的结构&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、最小化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、沟通和自律&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、通过重构得到柔性设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、通过精炼可以减轻负担&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：如果是在持续用心做事的话，每一次重构都是为了比原来的更好，以上的几种模式多少都会触碰得到，如果系统足够“大且运行良好的话。当然，这本书会给了我更加宽广的视野。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;第17章：领域驱动设计的综合运用&lt;/h2&gt;
&lt;h3&gt;1、把大型结构与BOUNDED CONTEXT结合起来使用&lt;/h3&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-7d4f742e32a5cf5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;大型结构与BOUNDED CONTEXT结合&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1599094-074c11256d776d65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;在一个CONTEXT中和整个CONTEXT MAP（作为一个整体）是使用同一种结构&lt;/p&gt;

&lt;/div&gt;
&lt;h3&gt;2、将大型结构与精炼结合起来使用&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;大型结构和精炼的概念也是互为补充的。大型结构可以帮助解释CORE DOMAIN内部的关系以及GENERIC SUBDOMIAN之间的关系。同时大型结构本身可能也是CORE DOMAIN的一个重要部分。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3、首先评估&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当对一个项目进行战略设计时，首先需要清洗地评估现状。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）画出CONTEXT MAP。你能画出一个一致的图吗？有没有一些模棱两可的情况？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）注意项目上的语言使用。有没有UBIQUITOUS LANGUAGE？这种语言是否足够丰富，以便帮助开发？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）理解重点所在。CORE DOMAIN被识别出来了吗？有没有DOMAIN VISION STATEMENT？你能写一个吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）项目所采用的技术是遵循MODEL-DRIVEN DESIGN，还是与之相悖？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）开发团队是否具备必要的技能？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）开发人员是否了解领域知识？他们对领域是否感兴趣？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，我们不会发现完美的答案。我们现在对项目的了解永远不如将来的了解深入。但这些问题为我们提供了一个可靠的起点。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;4、有谁定制策略&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;传统上，架构是在应用程序开发开始之前建立的，并且在这种组织中，负责建立架构的团队比应用开发团队拥有更大的权利。但我们并不一定的遵循这种传统的方式，因为它并不总是十分有效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;战略设计必须明确地应用于整个项目。项目有很多组织方式，这一点我并不想做过多的说明。但是，要想使决策制定过程更有效，需要注意一些基本问题。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、从应用程序开发自动得出的结构&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;一个非常善于沟通、懂得自律的团队在没有核心领导的情况下照样能够很好地工作，他们能够遵循EVOLVING ORDER来达成一组共同遵守的原则，这样就能够有机地形成一种秩序，而不用靠命令来约束。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、以客户为中心的架构团队&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;当几个团队共用同一种策略时，确实需要集中制定一些决策。架构师如果脱离实际开发工作，就可能会设计出失败的模型，但这是完全可以避免的。架构团队可以把自己放在与应用开发团队平等的位置上，帮助他们协调大型架构、BOUNDED CONTEXT边界和其他一些跨团队的技术问题。为了在这个过程中发挥作用，架构团队必须把思考重点放在应用程序的开发上。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;5、制定战略设计决策的6个要点&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、决策必须传达整个团队；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、决策过程必须收集反馈意见；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、计划必须允许演变；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、架构团队不必把所有最好、最聪明的人员都吸收进来；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、战略设计需要遵守简约和谦逊的原则；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、对象的职责要专一，而开发人员应该是多面手。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;技术框架同样如此&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;技术框架提供了基础设施层，从而使应用程序不必自己去实现基础服务，而且技术框架还能帮助把领域与其他关注点隔离开，因此它能够极大地加速应用程序（包括领域层）的开发。但技术框架也有风险的，那就是它会影响领域模型实现的表达能力，并妨碍领域模型的自由改变。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不要编写“傻瓜式”的框架。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在划分团队时，如果认为一些开发人员不够聪明，无法胜任设计工作，而让他们去做开发工作，那么这种态度可能会导致失败，因为他们低估了应用程序开发的难度。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;注意总体规划&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;由Christopher Alexander领导的一群建筑师（设计大楼的建筑师）在建筑和城市规划领域中提倡“聚少成多地成长”（piecemeal growth）。他们非常好地解释了总体规划失败的原因。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;30&quot;&gt;
&lt;p&gt;&lt;span&gt;    如果没有某种规划过程，那么俄勒冈州大学的校园永远不会像剑桥大学校园那样庞大、和谐而井井有条。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    总体规划是解决这种难题的传统方法。它试图建立足够多的指导方针，来保持整体环境的一致性，同时仍然为每幢建筑保留自由度，并为适应局部需要预留下广阔的空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ······将来这所大学的所有部分将构成一致的整体，因为它们只是被“插入”到总体设计的各个位置中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ······实际上总体规划会失败，因为它只是建立了一种极权主义的秩序，而不是一种有机的秩序。它们过于生硬，因此不容易根据自然变化和不可预料的社会生活变化来做出调整。当这些变化发生时······总体规划就过时了，而且不再被人们遵守。即使人们遵守总体规划······它们也没有足够详细地指定建筑物之前的联系，人口规模、功能均衡等这些用来帮助每幢建筑的局部行为和设计很好地符合整体环境的方面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ······试图驾驭这种总体规划过程非常类似于在小孩的填色本上填充颜色······这个过程最多也不过是得到一种极为平常的秩序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ······因此，通过总体规划是无法得到一种有机的秩序的，因为这个规划既过于精确，又不够细致。它在整体上过于精确了，而细节上又不够细致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ······总体规划的存在疏远了用户[因为，从根本上讲]大部分重要决策已经确定下来，因此社区成员对社区未来的建设几乎没有什么影响了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           ——摘自Oregon Experiment，PP. 16-28 [Alexander et al. 1975]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;Alexander和他的同事倡议由社区成员共同制定一组原则，并在“聚少成多地成长”的每次行动中多应用这些原则，这样就会形成一种“有机秩序”，并且能够根据环境变化做出调整。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;【学习心得】：由于我阅读的集中力不足，所以无法很好地从一次阅读中获取系统性的认知。因此，我必须用抄写去深入我心。特别是一些重要且很重要的知识，我必须这么做。虽然费时费力，但用未来的眼光去看，当下是值得的，再用当下的眼光看未来，原来我现在做的都是对的。笨一点没关系，时间就这么用的。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 09 Feb 2020 16:32:00 +0000</pubDate>
<dc:creator>wc的一些事一些情</dc:creator>
<og:description>【第一部分】运用领域模型 第1章：消化知识 有效的建模要素 （1）模型和实现的绑定 （2）建立了一种基于模型的语言 （3）开发一个蕴含丰富知识的模型 （4）提炼模型 （5）头脑风暴和实验 【学习心得】</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wcd144140/p/12289586.html</dc:identifier>
</item>
<item>
<title>安卓开发实战-记账本APP（三） - 清风紫雪</title>
<link>http://www.cnblogs.com/xiaofengzai/p/12289426.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaofengzai/p/12289426.html</guid>
<description>&lt;p&gt;&lt;span&gt;本次实现的是有关登录，注册和整体页面的改观，实现下方选项导致页面的切换效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用到的技术有Sqlite数据库的增删改查，与fragment实现。由于暂时没有找到合适的图标，先借用微信的图标暂代一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①在数据库这方面的学习后，我总结出三步走战略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：定义实体类。先建立好用户对象，存储数据。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.fragment;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;username 用户名
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;password 密码&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String password;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; User(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, String username, String password) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User(String username, String password) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User(){}

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassword() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; password;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassword(String password) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;第二步：创建数据库管理类。建立DBHelper继承&lt;/span&gt;&lt;span&gt;extends SQLiteOpenHelper，然后创建表。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.fragment;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Context;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.database.sqlite.SQLiteDatabase;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.database.sqlite.SQLiteOpenHelper;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDBHelper &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SQLiteOpenHelper {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserDBHelper(Context context,String name, SQLiteDatabase.CursorFactory factory, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; version){
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(context,name,factory,1&lt;span&gt;);
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(SQLiteDatabase db) {
        String created&lt;/span&gt;=&quot;create table Users (&quot;
                +&quot;id integer primary key autoincrement, &quot;
                +&quot;username text, &quot;
                +&quot;password text)&quot;&lt;span&gt;;
        db.execSQL(created);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onUpgrade(SQLiteDatabase db, &lt;span&gt;int&lt;/span&gt; oldVersion, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; newVersion) {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;该类中，共有三个方法，一个是构造函数，剩下两个是重写的方法，onCreate和onUpgrade，主要关注onCreate方法，在这个方法中创建了数据表，我这里定义数据表名为Users。构造函数主要关注参数，因为等会儿要调用，参数一共有四个，分别为系统上下文Context，数据库名，游标工厂（通常为null）以及数据库版本号，都是比较直接的参数，然后最后的onUpgrade，从字面上来理解，就是在数据库更新的时候调用的方法，需要传入新老版本号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：定义数据库操作类。方便我们增删改查操作的实现，不必再一个一个重写。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.fragment;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Context;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.database.Cursor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.database.sqlite.SQLiteDatabase;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserOperator {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDBHelper UserDBHelper;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SQLiteDatabase db;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserOperator(Context context){
        UserDBHelper&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; UserDBHelper(context,&quot;db_user&quot;,&lt;span&gt;null&lt;/span&gt;,1&lt;span&gt;);
        db&lt;/span&gt;=&lt;span&gt;UserDBHelper.getWritableDatabase();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加一条用户信息&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser(User bean){
        db.execSQL(&lt;/span&gt;&quot;insert into Users (username,password) values(?,?)&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{bean.username,bean.password});
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新用户密码&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; updateUser(User bean){
        db.execSQL(&lt;/span&gt;&quot;update Users set password=? where username=?&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{bean.password,bean.username});
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除某位用户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteUser(String username){
        db.execSQL(&lt;/span&gt;&quot;delete from Users where username=?&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[]{username});
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断用户是否存在&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; User isExit(String name){
        User bean&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Cursor c&lt;/span&gt;=db.rawQuery(&quot;select * from Users where username=?&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[]{name});
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(c.moveToNext()){
            bean&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
            bean.setUsername(c.getString(c.getColumnIndex(&lt;/span&gt;&quot;username&quot;&lt;span&gt;)));
            bean.setPassword(c.getString(c.getColumnIndex(&lt;/span&gt;&quot;password&quot;&lt;span&gt;)));
        }
        c.close();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有用户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; getallUser(){
        List&lt;/span&gt;&amp;lt;User&amp;gt; list=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        Cursor c&lt;/span&gt;=db.rawQuery(&quot;select * from Users&quot;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(c.moveToNext()){
            User bean&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
            bean.setUsername(c.getString(c.getColumnIndex(&lt;/span&gt;&quot;username&quot;&lt;span&gt;)));
            bean.setPassword(c.getString(c.getColumnIndex(&lt;/span&gt;&quot;password&quot;&lt;span&gt;)));
            list.add(bean);
        }
        c.close();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;数据库操作类的构造方法是值得一提的，主要执行了如下两步操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//数据库名：db_user&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;UserDBHelper=new UserDBHelper(context,&quot;db_user&quot;,null,1);&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;//初始化数据库操作对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;db = UserDBHelper.getWritableDatabase();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步就是刚才讲到创建数据库管理类时提到的构造方法。可以观察到传入的四个参数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.上下文Context与调用数据库操作类时传入的上下文一致，2.定义了数据库名称为“db_user”，3.游标工厂为null，4.数据库版本号为1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步为初始化数据库操作的对象。因为这里需要执行sql语句，所以必须要创建数据库的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外还需要关注的地方就是增删改查四类sql语句的写法，主要有如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;增：（add）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
db.execSQL(&quot;insert into Users (username,password) values(?,?)&quot;,&lt;span&gt;new&lt;/span&gt; Object[]{bean.username,bean.password});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;删：（delete）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
db.execSQL(&quot;delete from Users where username=?&quot;,&lt;span&gt;new&lt;/span&gt; String[]{username});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;改：（update）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
db.execSQL(&quot;update Users set password=? where username=?&quot;,&lt;span&gt;new&lt;/span&gt; Object[]{bean.password,bean.username});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查：（select）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Cursor c=db.rawQuery(&quot;select * from Users where username=?&quot;,&lt;span&gt;new&lt;/span&gt; String[]{name});
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Cursor c=db.rawQuery(&quot;select * from Users&quot;,&lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;说明：查询语句我觉得是四种操作之中最为复杂的一个，也是与用户需求最为贴合的一个需求。数据库把查询结果放入游标Cursor之中，然后通过遍历Cursor，把结果再赋给实体类User的对象或者是实体类泛型集合List&amp;lt;User&amp;gt;的对象，最终实现数据从数据库中到逻辑部分的传递。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，完成了这“三步走”之后，剩下的就是在Activity中的调用了。记得要在Activity中不仅要定义数据库操作类的对象，更要对其进行初始化。这是很重要的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一共两个Activity：loginActivity和RegisterActivity&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.fragment;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.app.Activity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Intent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.text.TextUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Button;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.EditText;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.LinearLayout;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.RelativeLayout;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.TextView;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Toast;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; androidx.annotation.Nullable;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; loginActivity &lt;span&gt;extends&lt;/span&gt; Activity &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; View.OnClickListener{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserOperator muserOperator;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TextView mTvLoginactivityRegister;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private RelativeLayout mRlLoginactivityTop;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; EditText mEtLoginactivityUsername;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; EditText mEtLoginactivityPassword;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private LinearLayout mLlLoginactivityTwo;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Button mBtLoginactivityLogin;

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(@Nullable Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_login);
        muserOperator&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; UserOperator(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        initView();


    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initView() {
        mBtLoginactivityLogin &lt;/span&gt;=&lt;span&gt; findViewById(R.id.bt_loginactivity_login);
        mTvLoginactivityRegister &lt;/span&gt;=&lt;span&gt; findViewById(R.id.tv_loginactivity_register);
        mEtLoginactivityUsername &lt;/span&gt;=&lt;span&gt; findViewById(R.id.et_loginactivity_username);
        mEtLoginactivityPassword &lt;/span&gt;=&lt;span&gt; findViewById(R.id.et_loginactivity_password);

        mBtLoginactivityLogin.setOnClickListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        mTvLoginactivityRegister.setOnClickListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (v.getId()){
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.tv_loginactivity_register:
                startActivity(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Intent(&lt;span&gt;this&lt;/span&gt;,RegisterActivity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
                finish();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.bt_loginactivity_login:
                String username&lt;/span&gt;=&lt;span&gt;mEtLoginactivityUsername.getText().toString().trim();
                String password&lt;/span&gt;=&lt;span&gt;mEtLoginactivityPassword.getText().toString().trim();
                User bean&lt;/span&gt;=&lt;span&gt;muserOperator.isExit(username);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!TextUtils.isEmpty(username)&amp;amp;&amp;amp;!&lt;span&gt;TextUtils.isEmpty(password)){
                    User bean1&lt;/span&gt;=&lt;span&gt;muserOperator.isExit(username);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(bean.password.equals(password)){
                        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;登录成功&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
                        Intent intent &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Intent(&lt;span&gt;this&lt;/span&gt;, MainActivity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                        startActivity(intent);
                        finish();
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;用户名或密码不正确，请重新输入&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
                    }
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;请输入你的用户名或密码&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;RegisterActivity&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.fragment;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Intent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.PersistableBundle;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.text.TextUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Button;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.EditText;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.ImageView;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.LinearLayout;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.RelativeLayout;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Toast;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; androidx.annotation.Nullable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; androidx.appcompat.app.AppCompatActivity;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RegisterActivity &lt;span&gt;extends&lt;/span&gt; AppCompatActivity &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; View.OnClickListener{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; userList;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String realCode;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserOperator muserOperator;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Button mBtRegisteractivityRegister;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private RelativeLayout mRlRegisteractivityTop;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ImageView mIvRegisteractivityBack;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private LinearLayout mLlRegisteractivityBody;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; EditText mEtRegisteractivityUsername;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; EditText mEtRegisteractivityPassword1;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; EditText mEtRegisteractivityPassword2;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; EditText mEtRegisteractivityPhonecodes;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ImageView mIvRegisteractivityShowcode;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private RelativeLayout mRlRegisteractivityBottom;&lt;/span&gt;
&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(@Nullable Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_register);
        muserOperator&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; UserOperator(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        init();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将验证码用图片的形式显示出来&lt;/span&gt;
&lt;span&gt;        mIvRegisteractivityShowcode.setImageBitmap(Code.getInstance().createBitmap());
        realCode &lt;/span&gt;=&lt;span&gt; Code.getInstance().getCode().toLowerCase();

    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
        mBtRegisteractivityRegister &lt;/span&gt;=&lt;span&gt; findViewById(R.id.bt_registeractivity_register);
        mIvRegisteractivityBack &lt;/span&gt;=&lt;span&gt; findViewById(R.id.iv_registeractivity_back);
        mEtRegisteractivityUsername &lt;/span&gt;=&lt;span&gt; findViewById(R.id.et_registeractivity_username);
        mEtRegisteractivityPassword1 &lt;/span&gt;=&lt;span&gt; findViewById(R.id.et_registeractivity_password1);
        mEtRegisteractivityPassword2 &lt;/span&gt;=&lt;span&gt; findViewById(R.id.et_registeractivity_password2);
        mEtRegisteractivityPhonecodes &lt;/span&gt;=&lt;span&gt; findViewById(R.id.et_registeractivity_phoneCodes);
        mIvRegisteractivityShowcode &lt;/span&gt;=&lt;span&gt; findViewById(R.id.iv_registeractivity_showCode);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按钮的点击事件，返回事件，点击二维码事件，注册事件&lt;/span&gt;
        mIvRegisteractivityBack.setOnClickListener(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        mIvRegisteractivityShowcode.setOnClickListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        mBtRegisteractivityRegister.setOnClickListener(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (v.getId()){
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.iv_registeractivity_back:
                    Intent intent1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Intent(&lt;span&gt;this&lt;/span&gt;,loginActivity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                    startActivity(intent1);
                    finish();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.iv_registeractivity_showCode:
                    mIvRegisteractivityShowcode.setImageBitmap(Code.getInstance().createBitmap());
                    realCode &lt;/span&gt;=&lt;span&gt; Code.getInstance().getCode().toLowerCase();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.bt_registeractivity_register:
                    String username &lt;/span&gt;=&lt;span&gt; mEtRegisteractivityUsername.getText().toString().trim();
                    String password &lt;/span&gt;=&lt;span&gt; mEtRegisteractivityPassword1.getText().toString().trim();
                    String password2 &lt;/span&gt;=&lt;span&gt; mEtRegisteractivityPassword2.getText().toString().trim();
                    String phoneCode &lt;/span&gt;=&lt;span&gt; mEtRegisteractivityPhonecodes.getText().toString().toLowerCase();

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;password.equals(password2)) {
                        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;两次密码不一致，请重新注册&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!TextUtils.isEmpty(username)&amp;amp;&amp;amp;!TextUtils.isEmpty(password)&amp;amp;&amp;amp;!&lt;span&gt;TextUtils.isEmpty(phoneCode)){
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(phoneCode.equals(realCode)){
                            User bean&lt;/span&gt;=&lt;span&gt;muserOperator.isExit(username);
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bean!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                                Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;该用户已存在，请重新注册&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
                            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                                User bean2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User(username,password);
                                muserOperator.addUser(bean2);
                                Intent intent2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Intent(&lt;span&gt;this&lt;/span&gt;, loginActivity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                                startActivity(intent2);
                                finish();
                                Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,  &quot;验证通过，注册成功&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
                            }
                        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                            Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;,  &quot;验证码错误,注册失败&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
                        }
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        Toast.makeText(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &quot;未完善信息，注册失败&quot;&lt;span&gt;, Toast.LENGTH_SHORT).show();
                    }
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这样第一部分登录与注册就完成了，接下来就是第二步的fragment的模块：分四块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一块：添加账单&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二块：显示本月的账单收支对比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三块：利用图表来形象的展示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四块：个人信息的展示与修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于目前刚刚掌握fragment的使用，先做了一个小案例：使用的是微信的相关界面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在activity_main的布局中加入fragment与四个图片来控制这四块的切换，并设置第一个展示的是WeChart_Fragment&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RelativeLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:app&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res-auto&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:tools&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    tools:context&lt;/span&gt;&lt;span&gt;=&quot;.MainActivity&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;fragment
        &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/fragment&quot;&lt;/span&gt;&lt;span&gt;
        android:name&lt;/span&gt;&lt;span&gt;=&quot;com.example.fragment.WeChart_Fragment&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
         &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout
        &lt;/span&gt;&lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;50dp&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_alignParentBottom&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
        android:orientation&lt;/span&gt;&lt;span&gt;=&quot;horizontal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ImageView
            &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/image1&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;0dp&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;50dp&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;
            android:background&lt;/span&gt;&lt;span&gt;=&quot;#ffffff&quot;&lt;/span&gt;&lt;span&gt;
            android:src&lt;/span&gt;&lt;span&gt;=&quot;@drawable/bottom_1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ImageView
            &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/image2&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;0dp&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;50dp&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;
            android:background&lt;/span&gt;&lt;span&gt;=&quot;#ffffff&quot;&lt;/span&gt;&lt;span&gt;
            android:src&lt;/span&gt;&lt;span&gt;=&quot;@drawable/bottom_2&quot;&lt;/span&gt;
            &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ImageView
            &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/image3&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;0dp&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;50dp&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;
            android:background&lt;/span&gt;&lt;span&gt;=&quot;#ffffff&quot;&lt;/span&gt;&lt;span&gt;
            android:src&lt;/span&gt;&lt;span&gt;=&quot;@drawable/bottom_3&quot;&lt;/span&gt;
            &lt;span&gt;/&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ImageView
            &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/image4&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;0dp&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;50dp&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_weight&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;
            android:background&lt;/span&gt;&lt;span&gt;=&quot;#ffffff&quot;&lt;/span&gt;&lt;span&gt;
            android:src&lt;/span&gt;&lt;span&gt;=&quot;@drawable/bottom_4&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;RelativeLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后就是创建四个Fragment布局文件并通过对应的Java文件来展示view&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后在MainActivity中设置四个图片的监听事件，分被调用不同的Fragment&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面来简单看一下如何启动fragemnt&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
View.OnClickListener l = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; View.OnClickListener() {
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View v) {
            FragmentManager fm &lt;/span&gt;= getFragmentManager();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取Fragment&lt;/span&gt;
            FragmentTransaction ft = fm.beginTransaction(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启一个事务&lt;/span&gt;
            Fragment f = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为Fragment初始化&lt;/span&gt;
            &lt;span&gt;switch&lt;/span&gt; (v.getId()) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过获取点击的id判断点击了哪个张图片&lt;/span&gt;
                &lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.image1:
                    f &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; WeChart_Fragment(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第一个Fragment&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.image2:
                    f &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Message_Fragment();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第二个Fragment&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.image3:
                    f &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Find_Fragment();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第三个Fragment&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; R.id.image4:
                    f &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Me_Fragment();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第四个Fragment&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            ft.replace(R.id.fragment,f); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换Fragment&lt;/span&gt;
            ft.commit(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交事务&lt;/span&gt;
&lt;span&gt;        }
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最后来看看今天的成果展示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;登录界面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1717524/202002/1717524-20200209233156144-17168230.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 注册界面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1717524/202002/1717524-20200209233230292-931435350.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 登陆成功后的界面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1717524/202002/1717524-20200209233431715-1272631366.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1717524/202002/1717524-20200209233500517-102163699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1717524/202002/1717524-20200209233513843-788866532.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1717524/202002/1717524-20200209233537064-40849316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 09 Feb 2020 15:36:00 +0000</pubDate>
<dc:creator>清风紫雪</dc:creator>
<og:description>本次实现的是有关登录，注册和整体页面的改观，实现下方选项导致页面的切换效果。 利用到的技术有Sqlite数据库的增删改查，与fragment实现。由于暂时没有找到合适的图标，先借用微信的图标暂代一下。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaofengzai/p/12289426.html</dc:identifier>
</item>
<item>
<title>我的一个react路由之旅（步骤及详图） - GGbondMan</title>
<link>http://www.cnblogs.com/GGbondLearn/p/12287488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GGbondLearn/p/12287488.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;今天开始react一个重要部分的xiao~习，路由~（过程截图，最后附代码）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下代码只能骗糊涂蛋子，没错，就是我自己，不要打算让我敲出多高级的东西~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;理论性知识几乎没有，请不要打算让我给你说原理啥的，原理性的东西，网上很多，我现在搬砖学习很开心，勿忘初心~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）首先，你确定你安装了react环境，这第一步难度系数1，菜鸟级别的不演示了&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）接下来，你要是用react路由，需要安装路由插件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; npm install react-router-dom --save-dev &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里可以使用cnpm代替npm命令&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一步安装，你的选择很多，我是用的 vs code的终端安装的，因为不想开小窗口，嫌烦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200208161934319-1884744245.png&quot; alt=&quot;&quot; width=&quot;696&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 安装成功。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（3）因为不知道我们要用到些什么，于是我就引入了很多组件。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里我去搜索了一下模块和组件的区别，为什么叫引入组件而不是模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;组件是具体的：按照一些小功能的通用性和可复用性来抽象组件
组件化更多的关注UI部分，比如用户看到的弹出框，页脚，确认按钮等，这些组件可以组合成新的组件，又可以和其他组件组合组合成新的组件

模块是抽象的：按照项目业务划分的大模块
模块化侧重于数据的封装，一组相关的组件定义成一个模块，一个json对象可以是一个模块。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里只谈区别，因为用词的精确性问题，程序员应该有一种对逻辑和正确性 ‘&lt;span&gt;&lt;strong&gt;咬文嚼字&lt;/strong&gt;&lt;/span&gt;’ 的态度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200208203614446-143540176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 引入了不少的东西。。。&lt;strong&gt;&lt;span&gt;我后面会给你解释每一个的，你先引进去。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（4）我新建了两个儿子（子文件son1和son2）在newDemo文件夹中。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200208214256045-1833792208.png&quot; alt=&quot;&quot; width=&quot;950&quot; height=&quot;379&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 我区分了他们呢，并把他们抛出。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（5）父组件引入抛出的son1和son2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200208214936619-663265766.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;514&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 运行环境，浏览器中打开显示是这样的：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200208215213980-2078296844.png&quot; alt=&quot;&quot; width=&quot;884&quot; height=&quot;199&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图中显示了父组件的&quot;我是个React&quot;和引入的两个子组件的“大儿子“和”二儿子”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;黄色部分的警告：不影响砸门使用，提醒砸门引入了但是没有用的组件和模块。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（6）上面的操作只是证明引入没问题。。。哈哈哈嗝~&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209104101600-1976708825.png&quot; alt=&quot;&quot; width=&quot;556&quot; height=&quot;349&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 这是一个规规矩矩的局部路由，&lt;strong&gt;（友情踩坑提示，link标签的首字母记得大写）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Router大标签，套住Link和Route，注释呢，已经在图片上给你写出来了，在网页上，他是这个样子的：&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209145913831-1026757302.png&quot; alt=&quot;&quot; width=&quot;891&quot; height=&quot;131&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 右边的警告是不是少了？额，不喜欢就注释了嘛先。而你点击跳转是这样的：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209150114806-251115793.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;171&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;（7）现在呢我们，说一下我们为什么用哈西路由（HasRouter）而不是浏览器路由（BrowserRouter）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（Router是我们起的别名 as 的作用就是这个啦。）&lt;/p&gt;
&lt;p&gt;首先说一下哈西路由（HashRouter）和浏览器路由（BrowserRouter）:&lt;/p&gt;
&lt;p&gt;以下解释的前提是你要懂什么叫 hash 地址，hash 地址就是指 # 号后面的 url。&lt;/p&gt;
&lt;p&gt;假如有一个 Link 标签，点击后跳转到 &lt;span&gt;/abc/def&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
BrowserRouter： http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8080/abc/def&lt;/span&gt;
HashRouter： http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8080/#/abc/def&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有服务器端的动态支持，建议使用 BrowserRouter，否则建议使用 HashRouter。&lt;/p&gt;
&lt;p&gt;原因在于，如果是单纯的静态文件，假如路径从 / 切换到 /a 后，此时刷新页面，页面将无法正常访问。&lt;/p&gt;
&lt;p&gt;因为写服务器文件还比较麻烦，因此在之后的 DEMO 中，&lt;strong&gt;我们将主要使用 HashRouter 而不是 BrowserRouter。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线上项目和实际网站是不会出现#的，所以用的是&lt;strong&gt; BrowserRouter。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（8）现在呢，我就把BrowserRouter删掉了，Link换成NavLink&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;说一说Link和NavLink的区别：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;NavLink&amp;gt;是&amp;lt;Link&amp;gt;&lt;span&gt;的一个特定版本，会在匹配上当前的url的时候给已经渲染的元素添加参数，组件的属性有

。activeClassName(string)：设置选中样式，默认值为active
。activeStyle(object)：当元素被选中时，为此元素添加样式
。exact(bool)：为true时，只有当导致和完全匹配class和style才会应用
。strict(bool)：为true时，在确定为位置是否与当前URL匹配时，将考虑位置pathname后的斜线
。isActive(func)判断链接是否激活的额外逻辑的功能&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好吧，我摊牌了&lt;a href=&quot;https://blog.csdn.net/lhjuejiang/article/details/80366839&quot;&gt;https://blog.csdn.net/lhjuejiang/article/details/80366839&lt;/a&gt; 链接给你！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209160218376-29271667.png&quot; alt=&quot;&quot; width=&quot;516&quot; height=&quot;314&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看这里，我把to后面直接跟了一个路径，也是没问题的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; （9）把son2也引进去，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209161259269-1714020724.png&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;162&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 现在我要试一试NavLink的选中样式了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209161704484-268863187.png&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;49&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209161618885-958712385.png&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;165&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 虽然只是一个简单的样式的使用，可见其优化后用起来还是很不错的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（10）重定向的使用Redirect&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;重定向，我觉得吧，分两种常用的情况。&lt;/p&gt;
&lt;p&gt;1》进入界面你需要默认一个网址，或者默认一个局部，就是我现在的情况，直接定义到son3，但是没有son3这个模块，所以啥也不显示，但是你可以定义到其它界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209221803711-2031391539.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;390&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209221508431-1140948124.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 2》匹配没有那个界面的时候，转到一个404界面或者其它界面，这个比较常见，符合实际产品的开发。&lt;/p&gt;
&lt;p&gt; (11)Switch的使用&lt;/p&gt;
&lt;p&gt;有&amp;lt;Switch&amp;gt;标签，则其中的&amp;lt;Route&amp;gt;在路径相同的情况下，只匹配第一个，这个可以避免重复匹配；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209222858613-1924893878.png&quot; alt=&quot;&quot; width=&quot;537&quot; height=&quot;293&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 我其他地方没有动，只改了路径，我们看效果。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209222959398-1415058297.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;171&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 只出现了一个大儿子。&lt;/p&gt;
&lt;p&gt;如果没有Switch呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209223649451-1762799563.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;164&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209223110477-1736941973.png&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;168&quot;/&gt;&lt;/p&gt;


&lt;p&gt;大儿子二儿子都蹦跶出来了。。。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（12）exact的用处，严格匹配！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209230422785-167530114.png&quot; alt=&quot;&quot; width=&quot;527&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 看标红线的地方，然后看界面显示，这个时候没有用exact，我们进入   '&lt;strong&gt;/son1/son2&lt;/strong&gt;' 时，两个组件都会加载出来。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209230656939-1022572757.png&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 现在我们给第一个son1加上exact！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209230801596-434885790.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;245&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 看界面！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200209230849777-446447918.png&quot; alt=&quot;&quot; width=&quot;534&quot; height=&quot;169&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 只加载了一个二儿子！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（13）新人的总结感言。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;东西不算多，但是一个一个截图查资料，真的受益无穷，会和熟悉，对于新开发一个功能，可能区别不大，因为我们都会在网上查大量的资料，去完善，去对比，但是对于搬砖期间，熟悉可以更有效地搬砖，节约时间，从而提高效率，抽出时间去学习！&lt;/p&gt;

</description>
<pubDate>Sun, 09 Feb 2020 15:21:00 +0000</pubDate>
<dc:creator>GGbondMan</dc:creator>
<og:description>今天开始react一个重要部分的xiao~习，路由~（过程截图，最后附代码） 以下代码只能骗糊涂蛋子，没错，就是我自己，不要打算让我敲出多高级的东西~ 理论性知识几乎没有，请不要打算让我给你说原理啥的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/GGbondLearn/p/12287488.html</dc:identifier>
</item>
<item>
<title>Linux防火墙之iptables常用扩展处理动作 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12287100.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12287100.html</guid>
<description>&lt;p&gt;　　前文我们讲了iptables的扩展匹配，一些常用的扩展模块以及它的专有选项的使用和说明，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12285152.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12285152.html&lt;/a&gt;；今天我们来说说iptables的处理动作；iptables的处理动作分基本处理动作和扩展处理动作，基本处理动作有ACCEPT和DROP 这两个动作很好理解，一个表示放行操作，一个表示丢弃操作。扩展处理动作有REJECT，这个动作表示拒绝，通常情况下建议都用DROP 去丢弃不想通过的报文，REJECT这个处理动作，它表示明确的拒绝，并且它会给拒绝的报文一个回应消息；RETURN表示返回，RETURN常用于自定义链上，用于返回主链。接下来我们一一来介绍LOG、SNAT、DNAT、MASQUERADE、REDIRECT这些扩展处理动作的用法，以及一些常用选项的说明；&lt;/p&gt;
&lt;p&gt;　　基本处理动作这里就不多说了，无外乎就是放行和丢弃操作。想必大家都会用，这里着重介绍扩展处理动作的用法，废话不多说，下面我们来看看扩展处理动作的用法。&lt;/p&gt;
&lt;p&gt;　　1、LOG，此处理动作用于记录日志，它可以帮我们哪些报文来请求过我们服务器，并通过日志的形式记录到日志文件中。默认情况LOG处理动作将日志记录在/var/log/messages系统日志中（事实上它是把日志交给rsyslog,如果我们没有更改rsyslog的配置，默认是记录到/var/log/messages）；它是非中断处理动作，也就是说它本身不做允许或拒绝操作，为了能匹配更多的报文，我们可以把此处理动作规则放在那些允许和拒绝规则之前，这样一来就可以记录来访我们服务器的报文在允许或拒绝之前的所有报文，方便日后分析日志。&lt;/p&gt;
&lt;p&gt;　　--log-level level ，此选项表示定义日志的级别，这个日志级别同rsyslog的日志级别类似，日志级别有debug、info、notice、warning、error、crit、alert、emerg，有关日志级别的说明请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12091118.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12091118.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　--log-prefix prefix，此选项表示定义日志的前缀信息，用于区别不同的日志，最多29个字符&lt;/p&gt;
&lt;p&gt;　　示例，记录来访本机的80端口的报文日志，日志级别是info,日志前缀为“web log”&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -nvL
Chain INPUT (policy DROP 241 packets, 19880 bytes)
 pkts bytes target     prot opt in     out     source               destination         
  772  108K ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state ESTABLISHED
   65  3920 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            multiport dports 80,3306,41319 state NEW
   35 13283 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy DROP 2 packets, 144 bytes)
 pkts bytes target     prot opt in     out     source               destination         
  847  269K ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state ESTABLISHED
   23  1604 ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0           
[root@test ~]# iptables -I INPUT 1 -p tcp --dport 80 -j LOG --log-level info --log-prefix &quot;web log&quot; 
[root@test ~]# iptables -nvL
Chain INPUT (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 LOG        tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80 LOG flags 0 level 6 prefix &quot;web log&quot;
 1000  124K ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state ESTABLISHED
   65  3920 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            multiport dports 80,3306,41319 state NEW
   35 13283 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
  993  284K ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state ESTABLISHED
   23  1604 ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0           
[root@test ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试：我们用本机访问80端口，看看/var/log/messages系统日志会不记录我们访问80端口的报文&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# curl -I http://192.168.0.99/loganalyzer
HTTP/1.1 301 Moved Permanently
Date: Sun, 09 Feb 2020 05:58:40 GMT
Server: Apache/2.4.6 (CentOS) PHP/5.4.16
Location: http://192.168.0.99/loganalyzer/
Content-Type: text/html; charset=iso-8859-1

[root@test ~]# curl -I http://192.168.0.99/loganalyzer
HTTP/1.1 301 Moved Permanently
Date: Sun, 09 Feb 2020 05:58:48 GMT
Server: Apache/2.4.6 (CentOS) PHP/5.4.16
Location: http://192.168.0.99/loganalyzer/
Content-Type: text/html; charset=iso-8859-1

[root@test ~]# tail  /var/log/messages
Dec 24 21:43:07 test systemd: Started System Logging Service.
Dec 24 23:26:04 test systemd: Stopping System Logging Service...
Dec 24 23:26:04 test rsyslogd: [origin software=&quot;rsyslogd&quot; swVersion=&quot;8.24.0-41.el7_7.2&quot; x-pid=&quot;16136&quot; x-info=&quot;http://www.rsyslog.com&quot;] exiting on signal 15.
Dec 24 23:26:04 test systemd: Stopped System Logging Service.
Dec 24 23:26:04 test systemd: Starting System Logging Service...
Dec 24 23:26:04 test rsyslogd: [origin software=&quot;rsyslogd&quot; swVersion=&quot;8.24.0-41.el7_7.2&quot; x-pid=&quot;16359&quot; x-info=&quot;http://www.rsyslog.com&quot;] start
Dec 24 23:26:04 test rsyslogd: action '*' treated as ':omusrmsg:*' - please use ':omusrmsg:*' syntax instead, '*' will not be supported in the future [v8.24.0-41.el7_7.2 try http://www.rsyslog.com/e/2184 ]
Dec 24 23:26:04 test systemd: Started System Logging Service.
Dec 24 23:26:04 test rsyslogd: error during parsing file /etc/rsyslog.conf, on or before line 76: warnings occured in file '/etc/rsyslog.conf' around line 76 [v8.24.0-41.el7_7.2 try http://www.rsyslog.com/e/2207 ]
Dec 24 23:26:13 test-node1 qiuhom: i am test-node1
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：我们访问两次，在/var/log/messages系统日志文件中却没有记录我们访问80端口的报文日志，这是为什么呢？防火墙规则写的不对吗？我们来看看我们防火墙规则是否匹配到报文？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209140149558-1549829668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　提示：我们查看防火墙规则，我们刚才写的规则是匹配到有规则呀，但是/var/log/messges日志文件中为什么没有记录呢？我们在来看看rsyslog的配置文件吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209142751138-9237465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   　　提示：看了rsyslog的配置文件终于明白了，防火墙把日志交给rsyslog,rsyslog它的配置文件中定义了把任何设施级别为info的日志都存放在数据库里了。那我们来看看数据库里是否有呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209140726901-133026435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　提示：本人用的是rsyslog的前端展示工具loganalyzer,这个工具本质就是把rsyslog日志从数据库里读出来，然后展示给用户。我们从上面的信息可以看到我们用本机去访问80端口的报文日志，以及我们定义的日志前缀。从上面的日志信息我们还了解到，我们数据报文所走的流入接口是lo,日志的facillity是KERN（内核）。&lt;/p&gt;
&lt;p&gt;　　当然我们还可以基于某种报文的状态来记录日志，例如，我们就只想记录状态为NEW的报文&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -nvL
Chain INPUT (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
  368 71198 LOG        tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:80 LOG flags 0 level 6 prefix &quot;web log&quot;
 4227  656K ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state ESTABLISHED
  127  7438 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            multiport dports 80,3306,41319 state NEW
   35 13283 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy DROP 20 packets, 1430 bytes)
 pkts bytes target     prot opt in     out     source               destination         
 4130 1134K ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state ESTABLISHED
   53  3418 ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0           
[root@test ~]# iptables -R INPUT 1 -p tcp -m state --state NEW -j LOG --log-level info --log-prefix &quot;status NEW&quot;  
[root@test ~]# iptables -nvL
Chain INPUT (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 LOG        tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state NEW LOG flags 0 level 6 prefix &quot;status NEW&quot;
 4304  662K ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state ESTABLISHED
  127  7438 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            multiport dports 80,3306,41319 state NEW
   35 13283 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           

Chain FORWARD (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy DROP 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
 4196 1141K ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state ESTABLISHED
   53  3418 ACCEPT     all  --  *      lo      0.0.0.0/0            0.0.0.0/0           
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：我们把原来的规则给更改成状态为NEW的是访问我本机说明服务都给记录下来&lt;/p&gt;
&lt;p&gt;　　测试，我们用192.168.0.151 去访问我们的web服务，我们在loganalyzer里看看，有没有记录到状态为NEW的报文日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209142250473-1819120866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　提示：从上面的信息看，我们是匹配到了两个包，我们在loganalyzer里在看看呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209142421763-1853806013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　提示：可以看到loganalyzer里是记录了我们用192.168.0.151 访问80端口且状态为NEW的报文&lt;/p&gt;
&lt;p&gt; 　　2、NAT它的全称是network address translation，意思是网络地址转换，不难理解此处理动作用于转换地址所用的处理动作，它通常用于PREROUTING，INPUT，OUTPUT，POSTROUTING这四个主链上。我们可以用iptables -t nat -nvL 命令来查看nat表所在的所有链的规则情况，从而知道nat表的规则只用于这四个主链上。&lt;/p&gt;
&lt;p&gt;　　SNAT，此处理动作表示源地址转换，通常在POSTROUTING链上做SNAT，主要作用是让本地网络中的主机通过某一特定地址访问外部网络，实现地址伪装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209171918437-1641996039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　提示：SNAT的TOP图如上所示，内网主机要上互联网，必须通过防火墙将其源地址更改为能够访问互联网的ip地址FWIP0。报文走向流程是这样的，内网主机向远端服务器发送请求，其报文段源IP是内网主机本身的ip，目标ip是远端服务器的ip，当报文到达防火墙时，防火墙一看，目标地址不是自己，然后它就把报文通过路由从FORWARD链上给转发出去了，在报文通过FORWARD链后，我们就要在防火墙的POSTROUTING链上明确说明，源地址为172.16.0.0/16的报文，访问外部主机，必须给修改成192.168.0.11，也就是防火墙能够上互联网的IP ，这样一修改后，从防火墙出去的报文源IP就是防火墙的外网IP（FWIP0）,通过互联网的层层路由报文终于到达了目标服务器，目标服务器收到报文，一看是访问它本机的，然后它就把报文给拆了，拿到客户端请求的内容，然后它就开始响应客户端，响应时，它把自己的SIP当源地址，FWIP0即防火墙外网ip当目标ip给封装好，从自己的网卡发出去，同样回来的报文，通过互联网的层层路由，相应报文到达防火墙后，一看是自己的报文，然后它就把响应报文给收下了，然后它会去查它本机自动维护的一个NAT表，这个表记录着那个客户端的源地址，源端口，和目标地址，目标端口等信息的一个对应表，它一看源IP为172.16.0.10源端口为55114的客户端主机，请求了192.168.0.20的80端口，然后对比自己收到的报文，它就把自己刚才收到的源地址为192.168.0.20源端口为80的报文给修改成源地址为192.168.0.20，源端口为80，目标地址为172.16.0.10目标端口为55114，然后通过FORWARD链把报文发送给客户端，客户端收到防火墙发来的报文，然后拆开数据包拿到服务器的响应。这就是SNAT报文从客户端到远端服务端，服务端响应回来的报文过程。这里需要注意一点的是，服务端响应回来的数据包到达防火墙，防火墙修改目标地址的过程是NAT自身的功能，我们不需要做额外的配置，换句话说我们只关心出去的报文就行，回来的报文NAT会自动维持一个NAT会话表，自动把响应报文修改成我们客户端的ip发送给客户端。&lt;/p&gt;
&lt;p&gt;　　了解了SNAT的报文走向，接下来我们来配置防火墙，让其内部主机能够通过SNAT去访问远端服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209175046316-135268288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　提示：在内网主机上我们ping远端服务器上ping 不通的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209175224408-2119817765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　提示：在防火墙主机上是可以正常访问远端服务器&lt;/p&gt;
&lt;p&gt;　　接下来我们要在防火墙主机上打开转发，并在其防火墙的POSTROUTING做SANT ，把172.16.0.0/16的源地址更改为192.168.0.11&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos6-node1 ~]# cat /proc/sys/net/ipv4/ip_forward    
0
[root@test-centos6-node1 ~]# echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
[root@test-centos6-node1 ~]# cat /proc/sys/net/ipv4/ip_forward
1  
[root@test-centos6-node1 ~]# iptables -nvL -t nat
Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
[root@test-centos6-node1 ~]# iptables -t nat -A POSTROUTING -s 172.16.0.0/24 -j SNAT --to-source 192.168.0.11 
[root@test-centos6-node1 ~]# iptables -nvL -t nat
Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 SNAT       all  --  *      *       172.16.0.0/24        0.0.0.0/0           to:192.168.0.11 

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
[root@test-centos6-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：SNAT 只能在nat表上做，我们开启了防火墙的核心转发，同时在POSTROUTING链上的nat表上添加了一条 源地址为172.16.0.0/16网段的主机通过时，我们就将其源地址更给为192.168.0.11，接下来我们在内网主机上访问远端服务器看看是不是能够访问呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209180326629-590118186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　提示：可以看到内网主机上可以正常的访问远端服务器了&lt;/p&gt;
&lt;p&gt;　　我们在防火墙上抓包看看，数据报文的走向&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209181439967-2015960832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　提示：我们可以看到，当报文到达eth1时，源ip和目标ip都未发生改变。经过eht1到达eth0时，报文段源ip变成了192.168.0.11，目标ip没有发生变化还是192.168.0.20.服务端收到报文响应回来在防火墙，eth0相应报文段源ip是192.168.0.20，目标IP是192.168.0.11,响应报文通过eth0后，到达eth1响应报文的源ip没有发生变化还是192.168.0.20，目标ip却变成了172.16.0.10，通过这一过程，想必大家对SNAT的工作机制有了很好的了解。&lt;/p&gt;
&lt;p&gt;　　--to-source [ipaddr[-ipaddr]][:port[-port]]，此选项表示指定SNAT后的源地址，它可以说一个网络地址范围，当防火墙上有多个外网ip时 我们可以指定其一个网络地址范围；如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
iptables -t nat -A POSTROUTING -s 10.0.1.0/24 ! –d 10.0.1.0/24 -j SNAT --to-source 172.18.1.6-172.18.1.9
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上规则表示在POSTROUTING 链上的nat标上增加一条源地址为10.0.1.0/24的ip地址 目标地址非10.0.1.0/24的ip地址，都做源地址转换，转换源地址为172.18.1.6-172.18.1.9，这样设置规则后，当报文匹配到后，防火墙会在172.18.1.6-172.18.1.9中顺序去转换源地址，也就说第一个报文来了，它会把源地址更改为172.18.1.6，第二个报文来了它会把源地址更改为172.18.1.7，依次轮循。&lt;/p&gt;
&lt;p&gt;　　--random 此选项会任意的从地址池里任意挑选一个给客户端请求报文做源地址转换。&lt;/p&gt;
&lt;p&gt;　　--persistent 此选项会从地址池中轮询的方式给客户端固定其转换后的源地址，比如第一个客户端报文来了，第一次防火墙会把172.18.1.6这个地址做SNAT给第一个客户端，其后只要是同一客户端，它都会拿这个地址给做SNAT，同理第二个客户端第一次做地址转换后的地址是172.18.0.7，那么它后面不管第几次来，都会被转换成172.18.0.7这个地址。通常情况--random和--persistent这两个选项用得很少。&lt;/p&gt;
&lt;p&gt;　　DNAT，此处理动作表示目标地址转换，通常在PREROUTING链上做DNAT，主要作用是把本地网络中的主机上的某服务开放给外部网络访问(发布服务和端口映射)，但隐藏真实IP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209203748722-1936491838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    　　提示：DNAT的TOP图如上所示，客户端要访问远端服务器，通过互联网层层路由，到达服务器所在网络的防火墙上，当防火墙收到来自客户端的请求报文，在入站的一瞬间，我们需要在防火墙的PREROUTING链上配置其目标地址为192.168.0.11，目标端口为21的报文，把其目标地址更改为172.16.0.12，端口更改为80。（这里的端口可以修改也可不修改，这个要看自己的环境，我这里以要修改端口为例）因为在入站的最开始就把目标地址给转换为后端服务器的地址后，修改后的报文就不会到防火墙的INPUT链上去了，它会直接通过FORWARD链从POSTROUTING链出去，最后报文到达对应的服务器网卡上，服务器收到来自客户端的请求报文，一看是自己的ip，然后就拆报文，然后响应客户端，封装回应报文，此时，服务器会把自己的IP地址封装成源ip，客户端的ip封装成目标ip然后发出去，当响应报文来到防火墙时，防火墙收到服务端的响应报文，一看源地址是服务端的，这个时候它会像SANT一样，它本身也维护了一张nat会话表，这个表记录了源ip 源端口 目标ip 目标端口 更改后的目标地址ip 更改后的目标端口等等信息，防火墙一查自己的NAT会话表，一看有一条源地址是192.168.0.10 源端口为52113 目标地址为192.168.0.11 目标端口为21的记录，然后对比自己刚才收到的报文，它就会把响应报文修改源地址和源端口，把响应报文的源地址，修改成之前客户端请求的目标地址，把响应报文里的源端口修改成客户端之前请求的目标端口，然后再发送给客户端，当客户端收到响应报文时，一看目标地址是自己，然后客户端就开始拆包，从而得到服务端的响应内容。DNAT和SNAT是类似的，回来的响应报文做源地址转换时DNAT自己根据记录的nat会话表更改，这个是NAT自身的连接追踪功能呢，我们不需要手动配置。也就是说做目标地址转换我们只关心把目标地址更换成那个，后续的响应报文会自动的做源地址转换。&lt;/p&gt;
&lt;p&gt;　　了解了DNAT的报文流向，接下来我们就以上面的TOP图来准备环境，实现DNAT&lt;/p&gt;
&lt;p&gt; 　　在没有配置防火墙规则时，我们客户端直接访问192.168.0.11看看能不能访问到后端服务?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209212803236-1521124670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209212919776-837769657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在防火墙上没有配置DNAT规则时，我们可以看到客户端主机上没有办法访问到后端服务的，防火墙是可以正常访问后端服务的&lt;/p&gt;
&lt;p&gt;　　在防火墙上添加规则，访问 192.168.0.11的报文都把其目标地址更改为172.16.0.12&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test-centos6-node1 ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:c8:fe:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.0.11/24 brd 192.168.0.255 scope global eth0
    inet6 fe80::20c:29ff:fec8:fe46/64 scope link 
       valid_lft forever preferred_lft forever
3: eth1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:c8:fe:50 brd ff:ff:ff:ff:ff:ff
    inet 172.16.0.11/16 brd 172.16.255.255 scope global eth1
    inet6 fe80::20c:29ff:fec8:fe50/64 scope link 
       valid_lft forever preferred_lft forever
[root@test-centos6-node1 ~]# iptables -t nat -nvL
Chain PREROUTING (policy ACCEPT 3 packets, 180 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain POSTROUTING (policy ACCEPT 1 packets, 60 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 1 packets, 60 bytes)
 pkts bytes target     prot opt in     out     source               destination         
[root@test-centos6-node1 ~]# iptables -t nat -A PREROUTING -d 192.168.0.11 -j DNAT --to-destination 172.16.0.12
[root@test-centos6-node1 ~]# iptables -t nat -nvL
Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 DNAT       all  --  *      *       0.0.0.0/0            192.168.0.11        to:172.16.0.12 

Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
[root@test-centos6-node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试：用客户端访问 192.168.0.11 看看能不能访问到后端的服务？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209213514831-1110786073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　提示：可以看到在防火墙添加规则后，客户端就可以访问到后端的服务了，我们在防火墙上抓包看看，报文的走向&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209214041412-1033423877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　提示：可以看到当客户端向服务端发起请求时，客户端请求报文到达防火墙的eth0时源ip是192.168.0.10 目标ip是192.168.0.11，当报文到达eth1时，报文的源ip还是192.168.0.10 目标ip却变成了172.16.0.12，当然服务端响应报文的到达eth1时，它的源ip是172.16.0.12 目标ip是192.168.0.10，当响应报文从eth1到eth0时，它的源ip变成了192.168.0.11，目标ip变成了192.168.0.10。这就是我们说的DNAT 它响应报文会根据自己维护的nat会话表里的数据，来自动作源地址转换。&lt;/p&gt;
&lt;p&gt;　　3、MASQUERADE：此处理动作用于源地址转换的场景，在做源地址转换时，我们转换后端源地址经常发生变化，如动态IP，如拨号网络。在这样的网络环境中我们做源地址转换就可以使用这个动作，它的工作流程是没做一次源地址转换它就要去扫描一下可用的IP和端口，然后再做源地址转换。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
iptables -t nat -A POSTROUTING -s 10.0.1.0/24 ! –d 10.0.1.0/24 -j MASQUERADE
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上规则表示，在POSTROUTING链上的nat表上增加一条规则，匹配源地址为10.0.1.0/24网络里的ip地址，且目标地址不是10.0.1.0/24的网段的ip地址时，就做源地址转换，这个源地址具体转换成那个，这个就要看报文通过时扫描出来的对外地址是多少就转换成多少。&lt;/p&gt;
&lt;p&gt;　　4、REDIRECT，此动作用于PREROUTING OUTPUT 链上的nat表上，主要用于通过改变目标IP和端口，将接受的包转发至不同端口，通常用于端口映射。&lt;/p&gt;
&lt;p&gt;　　--to-ports port[-port]，此选项表示指定要使用的目标端口或端口范围，如果不指定，目标端口是不会发生变化的，并且这个仅用于协议为tcp、udp、dccp、sctp&lt;/p&gt;
&lt;p&gt;　　 测试，把本机httpd服务监听端口更改为8080，然后客户端通过访问80，在其防火墙上对来访的80端口的报文加以更改目标端口为8080&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209223339110-1813013574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　提示：在防火墙上没有添加任何规则是，我们客户端只能通过8080去访问服务端，现在我们在防火墙上增加一条规则，让其来访80的端口的报文，去访问8080&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@test ~]# iptables -t nat -nvL
Chain PREROUTING (policy ACCEPT 8 packets, 396 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain INPUT (policy ACCEPT 5 packets, 300 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 4 packets, 336 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain POSTROUTING (policy ACCEPT 4 packets, 336 bytes)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# iptables -t nat -A PREROUTING  -d 192.168.0.99 -p tcp --dport 80 -j REDIRECT --to-ports 8080
[root@test ~]# iptables -t nat -nvL
Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 REDIRECT   tcp  --  *      *       0.0.0.0/0            192.168.0.99         tcp dpt:80 redir ports 8080

Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         
[root@test ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试：用客户端去访问192.168.0.99的80端口，看看是不是能够访问到8080所对应的服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503305/202002/1503305-20200209223903562-1318396390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　提示：可以看到客户端去访问80端口和访问8080端口的服务都是一样的内容。&lt;/p&gt;
</description>
<pubDate>Sun, 09 Feb 2020 14:52:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们讲了iptables的扩展匹配，一些常用的扩展模块以及它的专有选项的使用和说明，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/12285152.html</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12287100.html</dc:identifier>
</item>
<item>
<title>终于！疫情之下，第一批企业没能熬住面临倒闭，员工被遣散，没能等来春暖花开！ - 码农突围</title>
<link>http://www.cnblogs.com/hejunlin/p/12289061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hejunlin/p/12289061.html</guid>
<description>&lt;p&gt;先来看一个图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017584/202002/1017584-20200209220845663-980913290.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个春节，我同所有人一样，不仅密切关注这次新型肺炎，还同时关注行业趋势和企业。在家憋了半个月，我选择给自己看书充电。因为在疫情之后，行业竞争会更加加剧，必须做好未雨绸缪，时刻保持充电。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017584/202002/1017584-20200209220846014-1631314328.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看了今年的情况，突然想到大佬往年经典语录：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;马云：未来无业可就，无工可打，无商可务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;李彦宏：人工智能时代，有些专业将被淘汰，还没毕业就失业&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;马化腾：未来3年将大洗牌，迎21世界以来最大失业潮&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;王兴：2019年是十年内最惨的一年，也是十年后最好的一年&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;李开复说：“未来10年，50% 的人将要失业”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大家怎么看待大佬们的夸张语录…难道真是预言家？&lt;/p&gt;
&lt;h4 id=&quot;风暴来临时不是拼谁强大而是拼谁稳&quot;&gt;1、风暴来临时，不是拼谁强大，而是拼谁稳&lt;/h4&gt;
&lt;p&gt;2月6日晚间，知名IT培训机构「兄弟连教育」创始人李超，在其微信公众号中发表《致兄弟连全体学员、员工、股东的一封信》，表示因受疫情影响，即日起，兄弟连北京校区停止招生，员工全部遣散。消息一出，立马刷屏了，兄弟连教育早期是做PHP培训，成立于2006年。专注于IT技术培训，是国内早及大的PHP/LAMP技术专业培训学校。2015年，兄弟连获得华图1.25亿战略投资；2016年11月挂牌新三板，2018年4月25日终止挂牌。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017584/202002/1017584-20200209220846310-1953043943.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公司原计划在2020春节后招生旺季打一个翻身战，但疫情将公司计划全部打乱。最终输给了这场突如起来的疫情。这个黑天鹅，让他们最后一根救命稻草被压跨。&lt;/p&gt;
&lt;h4 id=&quot;现金流将影响一个公司的全年&quot;&gt;2、现金流将影响一个公司的全年&lt;/h4&gt;
&lt;p&gt;与此同时，完全依靠人流量的线下餐饮行业，更是受到影响。西贝CEO贾国龙，此前表示面临非常大现金流压力，一算账，连3个月都扛不过去。&lt;/p&gt;
&lt;p&gt;根据研究机构弗若斯特沙利文的统计，在2018年中国西北菜餐厅排名中，西贝筱面村位居第一，年收入超53亿元。但在疫情袭来之后，西贝餐饮副总裁楚学友透露了几个数据：&lt;/p&gt;
&lt;p&gt;截止到2019年底，西贝在全国有367家店，只有45家店在正常营业，195家店开放了外卖业务，剩余127家店全部闭店。&lt;/p&gt;
&lt;p&gt;贾国龙说：&quot;我们一个月工资发1.56个亿，两个月就三个多亿，三个月就四五个亿了。哪个企业储备那么多现金流？&quot;他只能无奈地承认，&quot;危机来了，突然发现现金流根本扛不住，一算账，真的，我们连3个月都扛不过去。&quot;&lt;/p&gt;
&lt;p&gt;作为行业头部的西贝都已经到如此境地，更不用说其他中小餐饮企业面对的压力和危机。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017584/202002/1017584-20200209220846630-1495353479.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有些人觉得中小餐饮企业虽然收入比西贝要少的多，那成本也应该低多了，不会面临倒闭或破产。&lt;/p&gt;
&lt;p&gt;事实上，不管是龙头企业还是中小企业，餐饮行业的成本，本就是居高不下的。而大企业因为有口碑背书，在贷款、政府支持等方面，反而有一些得天独厚的优势，像西贝现在还能够通过贷款拿到上亿元的资金。（PS：据最新消息，2月6日，浦发银行北京分行即完成核批西贝餐饮授信额度5.3亿元，次日通过远程线上核保、签署保证合同后，浦发银行即落地1.2亿元流动资金贷款，入账西贝餐饮集团）&lt;/p&gt;
&lt;p&gt;一位不愿透露店铺名的老板表示，自己春节前为店铺进货食材十几万，现在不能营业被大量退单，食材也保存不了很久，加上后面每个月员工工资有十几万，房租十几万，林林总总一加五十多万，再往下三个月都不敢想。&lt;/p&gt;
&lt;p&gt;那这些中小企业的未来在哪里呢？他们如何度过这次危机，如何在“疫情寒冬”中安然存活下来？所以这时候企业caiyuan也是迫不得已。但是给员工赔偿需要到位。&lt;/p&gt;
&lt;h4 id=&quot;裁员此时是无奈之举员工赔偿要到位&quot;&gt;3、裁员，此时是无奈之举、员工赔偿要到位&lt;/h4&gt;
&lt;p&gt;2月5日，公号秦子帅发表名为一篇《疫情下，我被裁了》，让技术圈一阵唏嘘。主人公从事Android开发，在还没正式上班（2.10）前，就通知被cai了。主人公表示：2月4日，公司下达了通知，基本上所有试用期员工全清，又劝退了一些正式员工。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017584/202002/1017584-20200209220847502-1577733731.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2月7日，北京知名KTV“K歌之王”发布了《总经理致全体员工的一封信》。信中称：“正当我们充满信心的准备在2020年重新展翅之际，威胁中国大江南北的疫情却突然出现。”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017584/202002/1017584-20200209220848152-1022404047.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;受疫情影响，K歌之王宣布将于2月9日（今天），也就是北京市准备正式上班的前一天，与全部员工、200多名员工解除劳动合同，如果有30%员工不同意这个方案，公司将进行破产清算。&lt;/p&gt;
&lt;h4 id=&quot;延迟复工再通知企业在滴血&quot;&gt;4、延迟复工再通知，企业在滴血&lt;/h4&gt;
&lt;p&gt;与此同时，企业再次延期复工。&lt;br/&gt;阿里：原定于10号开始的正常办公的阿里，将会至少延后一周或以上，具体时间待定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017584/202002/1017584-20200209220848425-1546545152.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;腾讯：2月9日（今天），腾讯再发通知，员工延长至2.24日返回工作场所地办公。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017584/202002/1017584-20200209220848966-782915973.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;字节跳动：2月26日-3月1日上班，2月12日-2月16日返京（再隔离14天回公司上班）&lt;br/&gt;美团：2月10日-2月14日在家办公，2月17日返岗上班&lt;br/&gt;IBM：3月中旬上班，办公任务：在家照顾好自己和家人&lt;br/&gt;而对于延期复工，不同人群的不同反应如下：&lt;/p&gt;
&lt;p&gt;00后：开黑继续，别走，决战到天亮……&lt;/p&gt;
&lt;p&gt;95后：延迟一时爽，一直延迟一直爽；&lt;/p&gt;
&lt;p&gt;90后：延迟上班没钱花?信用卡花呗一起刷；&lt;/p&gt;
&lt;p&gt;80后：上有老下有小，房贷车贷等着还，闹心；&lt;/p&gt;
&lt;p&gt;70后：命比钱重要，暂时吃老本，在家修身养性；&lt;/p&gt;
&lt;p&gt;实体店老板：越延迟，越损失惨重，泪两行，无处话凄凉……&lt;/p&gt;
&lt;h4 id=&quot;硝烟会过去待春暖花开相约再次出发&quot;&gt;5、硝烟会过去，待春暖花开，相约再次出发&lt;/h4&gt;
&lt;p&gt;小编想说的是，即使疫情严峻，市场竞争剧烈，但是只要我们时刻保持充电。同别人拉开差距，风暴来临时，拼的不是谁强大，而是谁站的稳。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、锻炼身体，编程是个体力活，除了拼技术，更要拼的是身体。&lt;/li&gt;
&lt;li&gt;2、关注趋势，比闭门造车更重要。&lt;/li&gt;
&lt;li&gt;3、多和行业更高阶的人交朋友，交流经验学习，更高阶的人可以点拨你，可以避免不必要的坑。&lt;/li&gt;
&lt;li&gt;4、提高对自己要求，永远比岗位要求高一个段位，才能不断进阶下一个段位。&lt;/li&gt;
&lt;li&gt;5、跳3个职级思考问题。开始有点难，慢慢你就能和别人与众不同。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;明天就办公了，大家有什么想说的呢？欢迎留言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017584/202002/1017584-20200209220849255-332523965.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的微信公众号「码农突围」，分享Python、Java、大数据、机器学习、人工智能等技术，关注码农技术提升•职场突围•思维跃迁，20万+码农成长充电第一站，陪有梦想的你一起成长。&lt;/p&gt;
</description>
<pubDate>Sun, 09 Feb 2020 14:09:00 +0000</pubDate>
<dc:creator>码农突围</dc:creator>
<og:description>先来看一个图： 这个春节，我同所有人一样，不仅密切关注这次新型肺炎，还同时关注行业趋势和企业。在家憋了半个月，我选择给自己看书充电。因为在疫情之后，行业竞争会更加加剧，必须做好未雨绸缪，时刻保持充电。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hejunlin/p/12289061.html</dc:identifier>
</item>
<item>
<title>精心整理「服务器Linux C/C++」 成长路程（附思维导图） - 小林coding</title>
<link>http://www.cnblogs.com/xiaolincoding/p/12288924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaolincoding/p/12288924.html</guid>
<description>&lt;p&gt;我不是名校毕业，更没有大厂的背景，我只是一个毕业不到 2 年的普普通通的程序员，在摸爬滚打的工作这段时间里，深知了有一个「完整的知识体系」是非常重要的。当事人非常后悔没有在大学期间知道这个道理……&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200209212845925.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;众多大厂招人的需求也是非常注重此方面，毕竟我们不能单单只是一个只会写代码的程序员，更应该成为一个全面的工程师，能够迅速解决工作上的需求及众多问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200209212858140.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;特此，我根据众多大佬的书籍推荐和豆瓣的高分书籍总结了一份较为全面的「服务器Linux C/C++」 成长路程，我自己也是在跟着这份思维导图进一步的学习，希望这份路程也能伴随大家的成长。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020020921291419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70&quot; alt=&quot;「Linux C/C++ 成长路程」 思维导图&quot;/&gt;&lt;br/&gt;特此说明下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有书籍资料和高清思维导图的获取的方式见文章末尾（机智的你，应该发现图就有途径）&lt;/li&gt;
&lt;li&gt;思维导图中的极客时间专栏，是我自己订阅的专栏，不是打广告，对此部分不感兴趣的小伙伴可以略过……&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;入门&quot;&gt;入门：&lt;/h2&gt;
&lt;p&gt;《啊哈C语言》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;《啊哈C语言！逻辑的挑战（修订版）》是一本非常有趣的编程启蒙书，书内容从中小学生的角度来讲述，没有生涩的内容，取而代之的是生动活泼的漫画和风趣幽默的文字。你可以在茶余饭后阅读，甚至坐在马桶上也可以看得津津有味。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;进阶&quot;&gt;进阶：&lt;/h2&gt;
&lt;p&gt;《C和指针》&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本书提供与C语言编程相关的全面资源和深入讨论。本书通过对指针的基础知识和高级特性的探讨，帮助程序员把指针的强大功能融入到自己的程序中去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《C专家编程》&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本书展示了最优秀的C程序员所使用的编码技巧，并专门开辟了一章对C++的基础知识进行了介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《C陷阱与缺陷》&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本书的出发点不是要批判C语言，而是要帮助C程序员绕过编程过程中的陷阱和障碍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;入门-1&quot;&gt;入门：&lt;/h2&gt;
&lt;p&gt;《 C++ Primer 中文版（第 5 版) 》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这本久负盛名的 C++经典教程，时隔八年之久，终迎来史无前例的重大升级。除令全球无数程序员从中受益，甚至为之迷醉的——C++ 大师&lt;br/&gt;Stanley B. Lippman 的丰富实践经验，C++标准委员会原负责人 Josée Lajoie 对C++标准的深入理解，以及C++&lt;br/&gt;先驱 Barbara E. Moo 在 C++教学方面的真知灼见外，更是基于全新的&lt;br/&gt;C++11标准进行了全面而彻底的内容更新。非常难能可贵的是，《C++ Primer 中文版(第5版)》所有示例均全部采用 C++11&lt;br/&gt;标准改写，这在经典升级版中极其罕见——充分体现了 C++ 语言的重大进展及其全面实践。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;进阶effective-c-四部曲&quot;&gt;进阶（Effective C 四部曲）：&lt;/h2&gt;
&lt;p&gt;《Effective C++ 中文版（第3版）》&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;《Effective C++：改善程序与设计的55个具体做法》(中文版)(第3版)一共组织55个准则，每一条准则描述一个编写出更好的C++的方式。每一个条款的背后都有具体范例支撑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《More Effective C++ 中文版》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;《More Effective C++:35个改善编程与设计的有效方法(中文版)》是梅耶尔大师Effective思部曲之一。继Effective C++之后，Scott Meyers于1996推出这本《More Effective C++(35个改善编程与设计的有效方法)》“续集”。条款变得比较少，页数倒是多了一些，原因是这次选材比“一集”更高阶。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《Effective STL 中文版》&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;STL是C++标准库的一部分。本书是针对STL的经验总结，书中列出了50个条款，绝大多数条款都解释了在使用STL时应该注意的某一个方面的问题，并且详尽地分析了问题的来源、解决方案的优劣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《Effective Modern C++ 中文版》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;想要彻底理解C++11和C++14，不可止步于熟悉它们引入的语言特性（例如，auto型别推导、移动语义、lambda表达式以及并发支持）。挑战在于高效地运用这些特性——从而使你的软件具备正确性、高效率、可维护性和可移植性。这正是这本实用的图书意欲达成的定位。它描述的正是使用C++11和C++14——现代C++来撰写真正卓越的软件之道。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;深入学习&quot;&gt;深入学习：&lt;/h2&gt;
&lt;p&gt;《深度探索C++对象模型》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这本书探索“对象导向程序所支持的C++对象模型”下的程序行为。对于“对象导向性质之基础实现技术”以及“各种性质背后的隐含利益交换”提供一个清楚的认识。检验由程序变形所带来的效率冲击。提供丰富的程序范例、图片，以及对象导向观念和底层对象模型之间的效率测量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《 STL 源码剖析 》&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;学习编程的人都知道，阅读、剖析名家代码乃是提高水平的捷径。源码之前，了无秘密。大师们的缜密思维、经验结晶、技术思路、独到风格，都原原本本体现在源码之中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;linux-基础知识&quot;&gt;Linux 基础知识：&lt;/h2&gt;
&lt;p&gt;《鸟哥的 Linux 私房菜》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本书是最具知名度的Linux入门书《鸟哥的Linux私房菜基础学习篇》的最新版，全面而详细地介绍了Linux操作系统。全书分为5个部分：第一部分着重说明Linux的起源及功能，如何规划和安装Linux主机；第二部分介绍Linux的文件系统、文件、目录与磁盘的管理；第三部分介绍文字模式接口&lt;br/&gt;shell和管理系统的好帮手shell脚本，另外还介绍了文字编辑器vi和vim的使用方法；第四部分介绍了对于系统安全非常重要的Linux账号的管理，以及主机系统与程序的管理，如查看进程、任务分配和作业管理；第五部分介绍了系统管理员(root)的管理事项，如了解系统运行状况、系统服务，针对登录文件进行解析，对系统进行备份以及核心的管理等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《Linux命令行与Shell脚本编程大全》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本书是一本关于Linux 命令行与shell 脚本编程的全面教程。全书分为四部分：第一部分介绍Linuxshell&lt;br/&gt;命令行；第二部分介绍shell 脚本编程基础；第三部分深入探讨shell 脚本编程的高级内容；第四部分介绍如何在现实环境中使用shell&lt;br/&gt;脚本。本书不仅涵盖了详尽的动手教程和现实世界中的实用信息，还提供了与所学内容相关的参考信息和背景资料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《Linux程序设计 （第4版）》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本书是Linux程序设计领域的经典名著，以简单易懂、内容全面和示例丰富而受到广泛好评。中文版前两版出版后，在国内的Linux爱好者和程序员中也引起了强烈反响，这一热潮一直持续至今。本书是国内读者翘首以待的第4版，此次新版内容组织更加严谨，译者更是细心雕琢，保留了这部权威著作的原汁原味。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;linux-环境编程&quot;&gt;Linux 环境编程：&lt;/h2&gt;
&lt;p&gt;《Linux 高性能服务器编程》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本书是Linux服务器编程领域的经典著作，由资深Linux软件开发工程师撰写，从网络协议、服务器编程核心要素、原理机制、工具框架等多角度全面阐释了编写高性能Linux服务器应用的方法、技巧和思想。不仅理论全面、深入，抓住了重点和难点，还包含两个综合性案例，极具实战意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《UNIX 环境高级编程（第3版）》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;《UNIX环境高级编程（第3版）》是被誉为UNIX编程“圣经”的Advanced Programming in the UNIX Environment一书的第3版。在本书第2版出版后的8年中，UNIX行业发生了巨大的变化，特别是影响UNIX编程接口的有关标准变化很大。本书在保持前一版风格的基础上，根据最新的标准对内容进行了修订和增补，反映了最新的技术发展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;linux-网络编程&quot;&gt;Linux 网络编程：&lt;/h2&gt;
&lt;p&gt;《UNIX网络编程 卷1：套接字联网API（第3版）》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这是一部传世之作！顶级网络编程专家Bill Fenner和Andrew M. Rudoff应邀执笔，对W. Richard Stevens的经典作品进行修订。书中吸纳了近几年网络技术的发展，增添了IPv6、SCTP协议和密钥管理套接字等内容，深入讨论了最新的关键标准、实现和技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《UNIX网络编程 卷2：进程间通信（第2版）》&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;《UNIX网络编程.卷2：进程间通信(第2版)》是一部UNIX网络编程的经典之作！进程间通信(IPC)几乎是所有Unix程序性能的关键，理解IPC也是理解如何开发不同主机间网络应用程序的必要条件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;linux-内核&quot;&gt;Linux 内核：&lt;/h2&gt;
&lt;p&gt;《深入理解linux内核 中文版（第3版）》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;《深入理解Linux内核，第三版》指导你对内核中使用的最重要的数据结构、算法和程序设计诀窍进行一次遍历。通过对表面特性的探究，作者给那些想知道自己机器工作原理的人提供了颇有价值的见解。书中讨论了Intel特有的重要性质。相关的代码片段被逐行剖析。然而，本书涵盖的不仅仅是代码的功能，它解释了Linux以自己的方式工作的理论基础。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;《算法导论》&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这本书深入浅出，全面地介绍了计算机算法。对每一个算法的分析既易于理解又十分有趣，并保持了数学严谨性。本书的设计目标全面，适用于多种用途。涵盖的内容有：算法在计算中的作用，概率分析和随机算法的介绍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;tcpip-详解-三部曲&quot;&gt;TCP/IP 详解 三部曲：&lt;/h2&gt;
&lt;p&gt;《TCP/IP详解 卷1：协议》&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;《TCP/IP详解卷1：协议》是一本完整而详细的TCP/IP协议指南。描述了属于每一层的各个协议以及它们如何在不同操作系统中运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《TCP/IP详解·卷2：实现》&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;《TCP/IP详解·卷2：实现》完整而详细地介绍了TCP/IP协议是如何实现的。书中给出了约500个图例，15000行实际操作的C代码，采用举例教学的方法帮助你掌握TCP/IP实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《TCP/IP详解(卷3):CP事务协议.HP.P和UIX域协议》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;《TCP/IP详解(卷3):CP事务协议.HP.P和UIX域协议》是“TCP/IP详解系列”的延续。主要内容包括：TCP事务协议，即T/TCP，这是对TCP的扩展，使客户-服务器事务更快、更高效和更可靠；TCP/IP应用，主要是HTTP和NNTP；UNIX域协议，这些协议提供了进程之间通信的一种手段。当客户与服务器进程在同一台主机上时，UNIX域协议通常要比TCP/IP快一倍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;《计算机是怎样跑起来的》&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本书以图配文，以计算机的三大原则为开端、相继介绍了计算机的结构、手工汇编、程序流程、算法、数据结构、面向对象编程、数据库、TCP/IP 网络、数据加密、XML、计算机系统开发以及SE 的相关知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《程序是怎样跑起来的》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本书从计算机的内部结构开始讲起，以图配文的形式详细讲解了二进制、内存、数据压缩、源文件和可执行文件、操作系统和应用程序的关系、汇编语言、硬件控制方法等内容，目的是让读者了解从用户双击程序图标到程序开始运行之间到底发生了什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《深入理解计算机系统》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本书从程序员的视角详细阐述计算机系统的本质概念，并展示这些概念如何实实在在地影响应用程序的正确性、性能和实用性。全书共12章，主要内容包括信息的表示和处理、程序的机器级表示、处理器体系结构、优化程序性能、存储器层次结构、链接、异常控制流、虚拟存储器、系统级I/O、网络编程、并发编程等。书中提供大量的例子和练习，并给出部分答案，有助于读者加深对正文所述概念和知识的理解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;mysql&quot;&gt;MySQL：&lt;/h2&gt;
&lt;p&gt;《MySQL必知必会》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;《MySQL必知必会》MySQL是世界上最受欢迎的数据库管理系统之一。书中从介绍简单的数据检索开始，逐步深入一些复杂的内容，包括联结的使用、子查询、正则表达式和基于全文本的搜索、存储过程、游标、触发器、表约束，等等。通过重点突出的章节，条理清晰、系统而扼要地讲述了读者应该掌握的知识，使他们不经意间立刻功力大增。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《高性能mysql(第3版)》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;《高性能mysql(第3版)》是mysql 领域的经典之作，拥有广泛的影响力。第3 版更新了大量的内容，不但涵盖了最新mysql 5.5版本的新特性，也讲述了关于固态盘、高可扩展性设计和云计算环境下的数据库相关的新内容，原有的基准测试和性能优化部分也做了大量的扩展和补充。全书共分为16 章和6 个附录，内容涵盖mysql 架构和历史，基准测试和性能剖析，数据库软硬件性能优化，复制、备份和恢复，高可用与高可扩展性，以及云端的mysql 和mysql相关工具等方面的内容。每一章都是相对独立的主题，读者可以有选择性地单独阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;redis&quot;&gt;Redis：&lt;/h2&gt;
&lt;p&gt;《Redis入门指南》&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;《Redis入门指南》是一本Redis的入门指导书籍，以通俗易懂的方式介绍了Redis基础与实践方面的知识，包括历史与特性、在开发和生产环境中部署运行Redis、数据类型与命令、使用Redis实现队列、事务、复制、管道、持久化、优化Redis存储空间等内容，并采用任务驱动的方式介绍了PHP、Ruby、Python和Node.js这4种语言的Redis客户端库的使用方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;书籍 + 视频是很好的学习的方式，推荐两个学习资源较多的网站：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;中国大学MOOC&lt;/li&gt;
&lt;li&gt;B站&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文的全部书籍+思维导图内容，关注公众号「&lt;strong&gt;小林coding&lt;/strong&gt;」，后台回复「&lt;strong&gt;我要学习&lt;/strong&gt;」，即&lt;strong&gt;可免费获取书籍资源+高清思维导图&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200209214026972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Feb 2020 13:44:00 +0000</pubDate>
<dc:creator>小林coding</dc:creator>
<og:description>前言 我不是名校毕业，更没有大厂的背景，我只是一个毕业不到 2 年的普普通通的程序员，在摸爬滚打的工作这段时间里，深知了有一个「完整的知识体系」是非常重要的。当事人非常后悔没有在大学期间知道这个道理…</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaolincoding/p/12288924.html</dc:identifier>
</item>
<item>
<title>jdk和dubbo的SPI机制 - Yrion</title>
<link>http://www.cnblogs.com/wyq178/p/12171881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq178/p/12171881.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：开闭原则一直是软件开发领域中所追求的,开闭原则中的&quot;开&quot;是指对于组件功能的扩展是开放的,是允许对其进行功能扩展的,“闭”,是指对于原有代码的修改是封闭的,即不应该修改原有的代码。对于一个高度集成化的、成熟、稳健的系统来讲,永远不是封闭、固守的，它需要向外提供一定的可扩展的能力,外部的实现类或者jar包都可以调用它。在面向对象的开发领域中，接口是对系统功能的高度抽象，因为&lt;strong&gt;SPI&lt;/strong&gt;可谓是&quot;应运而生&quot;，本篇博客就开始走进SPI,探究java自身的SPI和Dubbo的SPI到底是什么原理&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一：SPI是什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二：jdk的SPI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三：dubbo的SPI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四：总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一：SPI是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;spi全称英文是service provider Interface，翻译成中文也就是服务提供接口，在jdk 1.6开始,就已经提供了SPI.它的使用比较简单。即在项目的类路径下提供一个META/services/xx文件，配置一个文件，文件名为接口的全路径的名称，内容为具体的实现类全路径名。jdk将会使用&lt;/span&gt;ServiceLoader.load（）方法去解析和加载接口和其中的实现类,按需执行不同的方法。&lt;/p&gt;
&lt;p&gt;举个简单的例子：在jdbc中，jdk提供了driver(数据库)接口，但是不同的厂商实现起来的方式不同，比如mysql、oracle、sqlLite等厂商底层的实现逻辑都是不同的,因此在对数据库驱动driver实现方式上,可以采用SPI机制。比如在mysql-contactor.jar包中会在META/services路径下,这里相当于扩展了java.sql.Driver接口,jdk会在META/services路径下扫描该文件,然后加载mysql的diver实现类com.mysql.cj.jdbc.Driver，就相当于扩展了Driver的接口能力，按需加载mysql的实现类。oracle的连接jar包会有oracle的配置文件，这样不同的数据库根据自身的不同逻辑按需扩展了Driver的能力，这就是SPI的最大好处。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202001/1066538-20200119113357344-1960559033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; java.sql.Driver的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202001/1066538-20200119113641337-55364853.png&quot; alt=&quot;&quot; width=&quot;496&quot; height=&quot;38&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二：java的SPI机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从jdk1.6开始，java就提供了spi机制的支持,接下来我们就从一个例子来说明jdk的spi是如何实现的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1：设计一个接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Animal {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; sound();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.2：有两个实现类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cat &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Animal {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sound() {
        System.out.println(&lt;/span&gt;&quot;小猫在叫&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Animal {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sound() {
        System.out.println(&lt;/span&gt;&quot;小狗在叫&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.3:配置META-INF类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202001/1066538-20200119191302071-1507528865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202001/1066538-20200119191414969-1416492094.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;60&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2.4:读取配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ServiceLoader&lt;/span&gt;&amp;lt;Animal&amp;gt; serviceLoader = ServiceLoader.load(Animal.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;Animal&amp;gt; iterator =&lt;span&gt; serviceLoader.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iterator.hasNext()) {
            Animal next &lt;/span&gt;=&lt;span&gt;  iterator.next();
            next.sound();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202001/1066538-20200119191532983-1140390845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.5:原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面的例子中：定义了一个接口Animal,然后有两个实现类:Cat和Dog,在META-INF的文件目录下,两个接口都进行了相关的配置,接口实现类模块要同时加载两个类,具体的调用逻辑在客户端的ServiceLoader中来通过迭代器遍历来调用具体的配置实现类,那么代码具体的原理是什么呢？跟着我一起走进源码来分析一下jdk：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;ServiceLoader的load方法中首先会获取上下文类加载器,然后构造一个ServiceLoader，在ServiceLoader中有一个懒加载器，懒加载器会通过BufferedReader来从META-INF/services路径下读取对应的接口名的全路径名文件，也就是我们配置的文件,然后通过文件的类解析器读取文件中的内容,再通过类加载器加载类的全路径&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202001/1066538-20200120194430081-734118756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 仔细分析下java的spi具有以下缺点：&lt;/p&gt;
&lt;p&gt;①无法按需加载。虽然 ServiceLoader 做了延迟载入，使用了LazyIterator,但是基本只能通过遍历全部获取，接口的实现类得全部载入并实例化一遍。如果你并不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了,假如我只需要其中一个,其它的并不需要这就形成了一定的资源消耗浪费&lt;/p&gt;
&lt;p&gt;②不具有IOC的功能,假如我有一个实现类,如何将它注入到我的容器中呢，类之间依赖关系如何完成呢？&lt;/p&gt;
&lt;p&gt;③serviceLoader不是线程安全的,会出现线程安全的问题&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; &lt;strong&gt;三：dubbo的SPI&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; dubbo在原有的spi基础上主要有以下的改变,&lt;strong&gt;①配置文件采用键值对配置的方式，使用起来更加灵活和简单&lt;/strong&gt; &lt;strong&gt;②&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; 增强了原本SPI的功能，使得SPI具备ioc和aop的功能&lt;/strong&gt;，这在原本的java中spi是不支持的。dubbo的spi是通过ExtensionLoader来解析的，通过ExtensionLoader来加载指定的实现类，配置文件的路径在META-INF/dubbo路径下，我们通过一个例子来了解dubbo的SPI运行机制：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.1：dubbo的负载均衡机制其中就采用了spi机制,选择哪个负载均衡策略是通过@SPI注解来实现的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202002/1066538-20200204224946586-1096989867.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 利用ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(name)来获取具体的LoadBalance的实现类,其中name是对应配置文件(见下文)中的键；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202002/1066538-20200208185233553-23477531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 其中用了@SPI来指定了dubbo的负载均衡策略为随机(random),我们再来了解一下@SPI注解和@Adaptive是如何工作的？&lt;/p&gt;
&lt;p&gt;3.2：在dubbo的META_INF.dubbo.internal路径下存在一个文件：&lt;/p&gt;
&lt;p&gt;com.alibaba.dubbo.rpc.cluster.LoadBalance文件,文件内容是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202002/1066538-20200204234101119-1185599811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 可以看出dubbo的spi配置是采用&lt;strong&gt;键值对&lt;/strong&gt;的方式,键值对最大的好处就是可以以键来获取值，取值比较简单和方便。这点和java的spi配置方式是不同的，java的spi只有全路径名；&lt;/p&gt;
&lt;h3&gt;3.3:@SPI和@Adaptive注解的作用是什么？&lt;/h3&gt;
&lt;p&gt;Dubbo通过注解@Adaptive作为标记实现了一个适配器类，dubbo将会为这个类动态生成代理对象；ExtensionLoader中获取默认实现类或者通过实现类名称(由@SPI注解指定的名称)来获取实现类&lt;/p&gt;
&lt;p&gt;为什么会出现@Adaptive这个注解呢？主要原因是因为dubbo的加载扩展了是从配置文件加载的，是很动态的，但是实现类却要固定写死或者灵活实现，所以就得区分开。用@Adaptive就是表示由框架自己生成,不需要人为实现.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在dubbo加载SPI时会动态创建&lt;/span&gt;&lt;span&gt;SPI &lt;/span&gt;&lt;/span&gt;&lt;code&gt;Adaptive&lt;/code&gt;&lt;span&gt;实现&lt;/span&gt;&lt;code&gt;ExtensionLoader&lt;/code&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;从URL获取密钥，该密钥将通过&lt;/span&gt;&lt;/span&gt;&lt;code&gt;@Adaptive由&lt;/code&gt;&lt;span&gt;&lt;span&gt;接口方法定义的注释&lt;/span&gt;&lt;span&gt;提供&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.4:dubbo的spi读取配置和实现类原理&lt;/h3&gt;
&lt;p&gt;3.4.1:从解析加载配置类的源码开始分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ExtensionLoader.getExtensionLoader(LoadBalance.&lt;span&gt;class&lt;/span&gt;).getExtension(Constants.DEFAULT_LOADBALANCE)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的源码比较简单，首先是根据传入的接口从缓存(一个以class为键,ExtensionLoader为值的concurrentHashMap)中获取，如果拿不到就放入到缓存中；逻辑比较简单,这里就不做详细分析了。接下来主要是分析:ExtensionLoader.getExtension(name)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202002/1066538-20200208191614816-1551230456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们来看下具体的createExtension方法的源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202002/1066538-20200208201017032-483775054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;createExtension 方法的逻辑稍复杂一下，包含了如下的步骤:&lt;/p&gt;
&lt;p&gt;①通过 getExtensionClasses 获取所有的拓展类，也就是所有META-INF下的配置文件中的键值对名&lt;/p&gt;
&lt;p&gt;②通过反射创建拓展对象&lt;/p&gt;
&lt;p&gt;③向拓展对象中注入依赖&lt;/p&gt;
&lt;p&gt;④将拓展对象包裹在相应的 Wrapper 对象中，后面需要从wrapper中取&lt;/p&gt;
&lt;p&gt;来具体看一下dubbo是如何解析配置文件的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202002/1066538-20200208203143377-1954180068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 上面可以看出三个路径,这和我们刚才上面看到的路径是一致的，dubbo就是读取该路径下的的文件 &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202002/1066538-20200208203523511-1232129294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 加载配置文件下的文件内容，也就是上面的com.alibaba.dubbo.rpc.cluster.LoadBalance文件&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202002/1066538-20200208211316891-1953784897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.5：dubbo的IOC机制&lt;/h3&gt;
&lt;p&gt;dubbo的IOC是通过setter方法来实现注入的,通过遍历对象实例的所有方法,找到其setter方法在进行截取，从objectFactory中获取扩展类再进行反射执行。这样的话,就算实现实例中有依赖的扩展实例，都可以注入完成，是dubbo的IOC体现。ojectFactory 变量的类型为 AdaptiveExtensionFactory，AdaptiveExtensionFactory 内部维护了一个 ExtensionFactory 列表，用于存储其他类型的 ExtensionFactory。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1066538/202002/1066538-20200209211454573-1517681203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;    本篇博客简单分别介绍了 Java SPI 与 Dubbo SPI 用法，java的spi举了个简单的例子来进行了说明。并仔细分析了jdk的spi不足，dubbo是如何面对jdk的不足之处，然后自己定制开发出一套更加合理和更好的dubbo自我实现。以及详细分析了 Dubbo SPI 的加载拓展类的过程和源码的分析。其中可以看出来dubbo中对于缓存和反射的利用是相当之多的.SPI是软件设计中高扩展性的一个体现,通过spi机制可以灵活地实现厂商的规范订制和不同企业的具体规范自己实现.高度扩展了原程序，使得我们设计出来的程序更加具有扩展力。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Feb 2020 13:41:00 +0000</pubDate>
<dc:creator>Yrion</dc:creator>
<og:description>前言：开闭原则一直是软件开发领域中所追求的,开闭原则中的&amp;quot;开&amp;quot;是指对于组件功能的扩展是开放的,是允许对其进行功能扩展的,“闭”,是指对于原有代码的修改是封闭的,即不应该修改原有的代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyq178/p/12171881.html</dc:identifier>
</item>
<item>
<title>C语言指针及占据内存空间 - 拿着保温瓶的年轻人</title>
<link>http://www.cnblogs.com/l-hh/p/12288613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/l-hh/p/12288613.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文章文字有点多，会有点枯燥，配合图文一起看可以缓解枯燥，耐心阅读哦！！！&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;先了解内存地址，才更好的理解指针！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;我们可以把内存想象为成一列很长很长的&lt;strong&gt;&lt;span&gt;货运火车&lt;/span&gt;&lt;/strong&gt;，有很多大小相同的车厢，而每个车厢正好相当于在内存中表示&lt;strong&gt;&lt;span&gt;&lt;code&gt;一个字节&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;。这些车厢装着不同的货物，就像我们的内存要存着各式各样的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200209204325314-279457590.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200209204401625-608587334.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;多啰嗦一下&lt;/span&gt;&lt;/h3&gt;
&lt;p data-source-line=&quot;11&quot;&gt;&lt;span&gt;我们平时在电脑上能够听音乐、看视频和文章，其实看到的这些东西就是内存中每个“车厢”里面的数据，这些数据最终还是由二进制0/1演变而成。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;13&quot;&gt;&lt;span&gt;虽然视频、文章、音乐等这些信息在我们眼里是不同的，但对于计算机来说它们在内存中都是以二进制的形式来表示。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;15&quot;&gt;&lt;span&gt;因为我们要知道去哪存或取数据，所以内存中每个字节都有对应的编号，就像火车上的车厢编号一样。而这个内存中每个字节的编号就是我们常说的&lt;span&gt;&lt;strong&gt;内存地址&lt;/strong&gt;&lt;/span&gt;，是按一个字节接着一个字节的次序进行编址。如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;15&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200209204611480-473984199.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 data-source-line=&quot;20&quot;&gt;&lt;strong&gt;&lt;span&gt;凡事多问几个为什么？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p id=&quot;为什么内存地址都有0x开头&quot; data-source-line=&quot;20&quot;&gt;&lt;strong&gt;&lt;span&gt;1. 为什么内存地址都有0x开头？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;21&quot;&gt;&lt;span&gt;0x 开头代表以十六进制来表示的意思。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;为什么我们平时看到内存地址是这样的呢如图&quot; data-source-line=&quot;23&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 为什么我们平时看到内存地址是这样的呢？如图：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;21&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200209204821523-217261052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;21&quot;&gt;&lt;span&gt;因为内存容量很大，容量大字节数自然也多了，所以需要更多位来编址内存地址。上图的（0x00 ...）内存地址这里只是便于理解！&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;为什么我那么菜呢&quot; data-source-line=&quot;28&quot;&gt;&lt;strong&gt;&lt;span&gt;3. 为什么我那么菜呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哈哈哈......你心里没点*数吗？&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于内存字节&quot; data-source-line=&quot;31&quot;&gt;关于内存字节&lt;/h3&gt;
&lt;ul data-source-line=&quot;32&quot;&gt;&lt;li&gt;&lt;span&gt;1个内存地址只存1个字节 (Byte)；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;1个字节等于8位二进制，每一位二进制的0或1，叫“比特”(bit)；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;比特是最小单位，字节是比特的集合，也是一个单位；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;内存给数据类型地址分配如下：&lt;/span&gt;&lt;/h3&gt;
&lt;ul data-source-line=&quot;37&quot;&gt;&lt;li&gt;&lt;span&gt;char:占&lt;span&gt;&lt;strong&gt;一个字节&lt;/strong&gt;&lt;/span&gt;分配一个地址；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;int: 占&lt;span&gt;&lt;strong&gt;四个字节&lt;/strong&gt;&lt;/span&gt;分配四个地址；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;还有long、float、double等类型，等着你来动手测试。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;可以使用sizeof进行验证：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main () {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sizeof(char)=%u\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;&lt;span&gt;));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sizeof(int)=%u\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200209210106232-2080748455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;不要把指针想得太复杂，指针的实质就是内存“地址”，可以说&lt;strong&gt;&lt;span&gt;指针就是地址&lt;/span&gt;&lt;/strong&gt;，其实指针就是保存地址的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拿普通变量跟指针变量做比较：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;char&lt;/span&gt; a;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个变量a，用于保存char类型的数据；&lt;/span&gt;
&lt;span&gt;char&lt;/span&gt; *b;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义一个指针变量b，用于保存一个内存地址，这个内存地址上的数据必须是char类型的。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;举个例子，给指针变量进行赋值：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#include&amp;lt;stdio.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main () {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; char 类型占一个字节； &lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; *b = &amp;amp;a;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; “&amp;amp;”是取变量的地址，取出a在内存中的地址；
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 赋值给b指针，此时b变量存储的就是a地址。&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是a变量的值：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*b);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; *b表示输出b里面存储的地址上的数据； 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 证明b上存储的是a的地址；&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是a的地址：%p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;a);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是b变量的值：%p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,b);
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;我是a变量的值：&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
我是a的地址：000000000062FE17
我是b变量的值：000000000062FE17&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过画图来理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200209210456232-957920165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过指针间接性修改变量的值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;char&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *b = &amp;amp;&lt;span&gt;a;
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;初始值：a=%d,*b=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,a,*&lt;span&gt;b);
&lt;/span&gt;*b = &lt;span&gt;12&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其实操作的就是变量a本身的值；&lt;/span&gt;
printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;修改后：a=%d,*b=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,a,*&lt;span&gt;b);
&lt;/span&gt;------------------------------------------&lt;span&gt;
输出结果为：
初始值：a&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;,*b=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
修改后：a&lt;/span&gt;=&lt;span&gt;12&lt;/span&gt;,*b=&lt;span&gt;12&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;指针类型的概念&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们知道char类型的数据只占一个字节，有很多类型是需要多个字节来存储的，像int类型的数据就需要四个字节来存储（根据平台不同，长度也有可能不一致）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于int类型的指针从当前字节(地址)开始共四个字节(地址)都是属于该变量的值， 而对于char类型则只表示当前字节(地址)。代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;259&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; * p1 = &amp;amp;&lt;span&gt;a;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; * p2 = (&lt;span&gt;char&lt;/span&gt; *)&amp;amp;a; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里需要强制转换一下类型&lt;/span&gt;
printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*p1=%d,*p2=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*p1,*&lt;span&gt;p2);
&lt;/span&gt;-----------------------&lt;span&gt;
输出：&lt;/span&gt;*p1=&lt;span&gt;259&lt;/span&gt;,*p2=&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过画图来便于理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200209210718629-404573579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过上文我们已经对int类型指针有所了解了，*p1的输出是在我们预算范围之内的，但是为什么*p2输出的值是3呢？&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;重点，敲黑板！！！&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;因为计算机是使用二进制来表示数字的，上面(259)十进制转换二进制是 [100000011]，由于一个int类型变量占用四个字节，8位二进制为一个字节，补齐高位的0后，则 [00000000 00000000 00000001 00000011]，每8位二进制(一个字节)换算为十进制，则 [0  0  1  3]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时你应该差不多明白*p2为什么输出的值为3了吧，但是内存地址中有个概念叫&quot;&lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F/6750542?fr=aladdin&quot; target=&quot;_blank&quot;&gt;大小端模式&lt;/a&gt;&quot;，就会有两种不同的排序：[0  0  1  3] or [3  1  0  0]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于计算机读取*p2的地址是0x00，所以直接输出这个地址上的数据，你也可以试着改一下，把259换成258/257等，看看是否正如所说。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;验证它们存储地址，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;259&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; * p1 = &amp;amp;&lt;span&gt;a;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; * p2 = (&lt;span&gt;char&lt;/span&gt; *)&amp;amp;&lt;span&gt;a;
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*p1=%d,*p2=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*p1,*&lt;span&gt;p2);
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;a=0x%p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;a);
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p1=0x%p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,p1);
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p2=0x%p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p2);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出结果正如我们预想的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200209210937674-1177185753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你看到这里的时候，你只是刚刚认识指针而已，以上是我们俗称的&lt;strong&gt;&lt;span&gt;一级指针&lt;/span&gt;&lt;/strong&gt;，一级指针是比较简单的，还有二级指针和多级指针，更绕、更难理解，接下来介绍一下二级指针。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;在讲二级指针前，我们是否有疑问：什么是一级指针？什么是二级指针呢？两者有什么区别呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul data-source-line=&quot;141&quot;&gt;&lt;li&gt;&lt;span&gt;一级指针存储变量的地址，通过这个地址&quot;直接获取&quot;变量的数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;二级指针存储一级指针的地址，二级指针通过一级指针&quot;间接获取&quot;获取变量的数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;多级指针以此类推，个人理解，讲的不对欢迎指正。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;再坚持一下，精彩在&quot;下面&quot;！！！[/滑稽]&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二级指针&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;“指针的指针”也就是我们俗称的二级指针。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;什么是“指针的指针”，例如下面代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;char&lt;/span&gt; a = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; * p1 = &amp;amp;&lt;span&gt;a;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; ** p2= &amp;amp;&lt;span&gt;p1;
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*p=%d，**p2=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*p1,**p2);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：*p1=5，**p2=5&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过画图来理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200209211237035-1334651090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多级指针也就是指针的指针的指针.....，以此类推即可。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;指针运算是根据&lt;span&gt;&lt;strong&gt;指针的类型不同&lt;/strong&gt;&lt;/span&gt;而进行运算的，因类型的不同，在加1/减1操作时，内存分配的空间也不同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;又拿int类型和char类型来作比较，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;char类型+1：&lt;/span&gt;&lt;span&gt;从输出结果可以看出地址是递增1的，正符合char类型占一个字节的说法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;char&lt;/span&gt; c = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *a = &amp;amp;&lt;span&gt;c;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;3&lt;/span&gt;;i++&lt;span&gt;){
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a+1=0x%p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,a +&lt;span&gt; i);
}
&lt;/span&gt;--------------------------------&lt;span&gt;
输出结果：
a&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;=&lt;span&gt;0x000000000062FE0F&lt;/span&gt;&lt;span&gt;
a&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;=&lt;span&gt;0x000000000062FE10&lt;/span&gt;&lt;span&gt;
a&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;=&lt;span&gt;0x000000000062FE11&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;int类型+1：&lt;span class=&quot;Apple-converted-space&quot;&gt;输出的地址之间相差为4，正是int类型占据空间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;259&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *a = &amp;amp;&lt;span&gt;c;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;3&lt;/span&gt;;i++&lt;span&gt;){
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a+1=0x%p\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,a +&lt;span&gt; i);
}
&lt;/span&gt;--------------------------------&lt;span&gt;
输出结果：
a&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;=&lt;span&gt;0x000000000062FE0C&lt;/span&gt;&lt;span&gt;
a&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;=&lt;span&gt;0x000000000062FE10&lt;/span&gt;&lt;span&gt;
a&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;=&lt;span&gt;0x000000000062FE14&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;char类型和int类型分别+1在内存中地址分配，如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1418489/202002/1418489-20200209211439136-1831961421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;指针就介绍到这里，这只是指针的基础，还有数组指针、指针数组、null指针、void指针等等知识，还需要学习，后续继续更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;以上有不恰当或者讲得不对的地方，希望各位留言指正，谢谢！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;站在巨人的肩膀上！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 09 Feb 2020 13:34:00 +0000</pubDate>
<dc:creator>拿着保温瓶的年轻人</dc:creator>
<og:description>第一、了解内存空间 本文章文字有点多，会有点枯燥，配合图文一起看可以缓解枯燥，耐心阅读哦！！！ 先了解内存地址，才更好的理解指针！ 我们可以把内存想象为成一列很长很长的货运火车，有很多大小相同的车厢，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/l-hh/p/12288613.html</dc:identifier>
</item>
</channel>
</rss>