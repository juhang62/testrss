<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JavaFX桌面应用-SpringBoot + JavaFX - HiIT青年</title>
<link>http://www.cnblogs.com/itqn/p/13545604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itqn/p/13545604.html</guid>
<description>&lt;p&gt;SpringBoot对于Java程序员来说可以是一个福音，它让程序员在开发的时候，大大简化了各种spring的xml配置。&lt;/p&gt;
&lt;p&gt;那么在JavaFX项目使用SpringBoot会是怎么样的体验呢？&lt;/p&gt;
&lt;dl&gt;&lt;dt&gt;这次使用“GuyHub”的开源项目springboot-javafx-support体验一下SpringBoot + JavaFX开发。&lt;/dt&gt;
&lt;dd&gt;JavaFX桌面应用开发系列文章传送门 ~&lt;/dd&gt;
&lt;/dl&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/itqn/p/13379866.html&quot;&gt;JavaFX桌面应用开发-HelloWorld&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/itqn/p/13380499.html&quot;&gt;JavaFX布局神器-SceneBuilder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/itqn/p/13381560.html&quot;&gt;JavaFX让UI更美观-CSS样式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/itqn/p/13388247.html&quot;&gt;JavaFX桌面应用-为什么应用老是“未响应”&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/itqn/p/13462943.html&quot;&gt;JavaFX桌面应用-MVC模式开发，“真香”&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/itqn/p/13543681.html&quot;&gt;JavaFX桌面应用-loading界面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/itqn/p/13387577.html&quot;&gt;JavaFX桌面应用-表格用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/itqn/p/13505579.html&quot;&gt;JavaFX桌面应用-视频转码工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JavaFX桌面应用-SpringBoot + JavaFX (本文)&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;引入依赖&quot;&gt;引入依赖&lt;/h3&gt;
&lt;p&gt;采用最新的SpringBoot版本和springboot-javafx-support版本&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.3.2.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;de.roskenet&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;springboot-javafx-support&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;极速体验&quot;&gt;极速体验&lt;/h3&gt;
&lt;p&gt;springboot-javafx-support 主要两个关键的组件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;AbstractJavaFxApplicationSupport (启动类继承它)&lt;/li&gt;
&lt;li&gt;AbstractFxmlView (视图类继承它)&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;视图排版&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里使用FXML布局界面。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Pane maxHeight=&quot;-Infinity&quot; maxWidth=&quot;-Infinity&quot; minHeight=&quot;-Infinity&quot; minWidth=&quot;-Infinity&quot; prefHeight=&quot;400.0&quot; prefWidth=&quot;600.0&quot; xmlns=&quot;http://javafx.com/javafx/8.0.112&quot; 
        xmlns:fx=&quot;http://javafx.com/fxml/1&quot;&amp;gt;
   &amp;lt;children&amp;gt;
      &amp;lt;Label layoutX=&quot;99.0&quot; layoutY=&quot;109.0&quot; prefHeight=&quot;34.0&quot; prefWidth=&quot;394.0&quot; text=&quot;Hello World!&quot;&amp;gt;
         &amp;lt;font&amp;gt;
            &amp;lt;Font size=&quot;26.0&quot; /&amp;gt;
         &amp;lt;/font&amp;gt;
      &amp;lt;/Label&amp;gt;
   &amp;lt;/children&amp;gt;
&amp;lt;/Pane&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;视图类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;视图类很简单，只需要继承AbstractFxmlView并添加@FXMLView注解即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FXMLView
public class HelloworldView extends AbstractFxmlView {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;启动类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;启动类跟SpringBoot的启动类差不多，不过需要需要继承AbstractJavaFxApplicationSupport，然后将主视图类传进去。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
public class App extends AbstractJavaFxApplicationSupport {

        public static void main(String[] args) {
                launch(App.class, HelloworldView.class, args);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一个超级简单的SpringBoot + JavaFX就完成了。&lt;/p&gt;
&lt;p&gt;springboot-javafx-support默认带了启动界面，这在SpringBoot项目中是非常有必要的，因为SpringBoot项目通常来说启动都要一定的时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202008/2083963-20200822144108090-1529073965.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序启动完成后，启动界面会自动关闭，显示程序主界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202008/2083963-20200822144120251-2127407289.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;框架分析&quot;&gt;框架分析&lt;/h3&gt;
&lt;p&gt;springboot-javafx-support 这个框架及其简单，所有源码总共才9个类，下面介绍一下这9个类。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;AbstractFxmlView 视频抽象基类，负责加载FXML界面，然后通过getView()来获取视图。&lt;/li&gt;
&lt;li&gt;AbstractJavaFxApplicationSupport 启动抽象基类，继承了JavaFX的Application，在init方法启动SpringBoot程序，并提供了一些声明周期的回调。&lt;/li&gt;
&lt;li&gt;Constant 一些配置key的常量，可以通过application.yml来配置JavaFX程序的标题，宽高、样式等。&lt;/li&gt;
&lt;li&gt;FXMLController Controller层的注解，使用这个注解的类将注册成为Spring Bean。&lt;/li&gt;
&lt;li&gt;FXMLView FXML视图层的注解，同样的，使用这个注解的类也将注册成为Spring Bean。&lt;/li&gt;
&lt;li&gt;GUIState 枚举单例，存储一样JavaFX的对象，如果Stage，Scene，HostService，系统托盘等。&lt;/li&gt;
&lt;li&gt;PropertyReaderHelper 配置读取工具。&lt;/li&gt;
&lt;li&gt;ResourceBundleControl 支持自定编码的ResouceBundle，针对I18N很有用。&lt;/li&gt;
&lt;li&gt;SplashScreen 默认启动动画界面。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;一些约定&quot;&gt;一些约定&lt;/h3&gt;
&lt;p&gt;springboot-javafx-support中有一些约定：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;资源（fxml\css\i18n）放在resources中，目录结构跟View类的包目录结构一致。&lt;/li&gt;
&lt;li&gt;将View类名的&quot;View&quot;去掉后所有字母转为小写作为资源的名称。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当然这些约定可以通过@FXMLView注解中的属性来调整。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public @interface FXMLView {
        String value() default &quot;&quot;;
        String[] css() default {};
        String bundle() default &quot;&quot;;
        String encoding() default &quot;ISO-8859-1&quot;;
        String title() default &quot;&quot;;
        String stageStyle() default &quot;UTILITY&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;spring展现&quot;&gt;Spring展现&lt;/h3&gt;
&lt;p&gt;到目前为止还看不到springboot-javafx-support中spring的影子，接下来通过一个例子来展现一下springboot-javafx-support的魅力。&lt;/p&gt;
&lt;p&gt;这里通过两个视图切换作为例子：&lt;/p&gt;
&lt;p&gt;调整之前的视图，新增调整到Hi视图的按钮，并将视图跟ViewController绑定，处理toHi事件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Pane maxHeight=&quot;-Infinity&quot; maxWidth=&quot;-Infinity&quot; minHeight=&quot;-Infinity&quot; minWidth=&quot;-Infinity&quot; prefHeight=&quot;400.0&quot; prefWidth=&quot;600.0&quot; xmlns=&quot;http://javafx.com/javafx/8.0.112&quot; 
        xmlns:fx=&quot;http://javafx.com/fxml/1&quot;
        fx:controller=&quot;example.ViewController&quot;&amp;gt;
   &amp;lt;children&amp;gt;
      &amp;lt;Label layoutX=&quot;99.0&quot; layoutY=&quot;109.0&quot; prefHeight=&quot;34.0&quot; prefWidth=&quot;394.0&quot; text=&quot;Hello World!&quot;&amp;gt;
         &amp;lt;font&amp;gt;
            &amp;lt;Font size=&quot;26.0&quot; /&amp;gt;
         &amp;lt;/font&amp;gt;
      &amp;lt;/Label&amp;gt;
      &amp;lt;Button layoutX=&quot;99.0&quot; layoutY=&quot;169.0&quot; prefHeight=&quot;34.0&quot; prefWidth=&quot;150.0&quot; text=&quot;Hi&quot; onAction=&quot;#toHi&quot;/&amp;gt;
   &amp;lt;/children&amp;gt;
&amp;lt;/Pane&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的Hi视图也绑定到ViewController中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Pane maxHeight=&quot;-Infinity&quot; maxWidth=&quot;-Infinity&quot; minHeight=&quot;-Infinity&quot; minWidth=&quot;-Infinity&quot; prefHeight=&quot;400.0&quot; prefWidth=&quot;600.0&quot; xmlns=&quot;http://javafx.com/javafx/8.0.112&quot; 
        xmlns:fx=&quot;http://javafx.com/fxml/1&quot;
        fx:controller=&quot;example.ViewController&quot;&amp;gt;
   &amp;lt;children&amp;gt;
      &amp;lt;Label layoutX=&quot;99.0&quot; layoutY=&quot;109.0&quot; prefHeight=&quot;34.0&quot; prefWidth=&quot;394.0&quot; text=&quot;Hi IT青年!&quot;&amp;gt;
         &amp;lt;font&amp;gt;
            &amp;lt;Font size=&quot;26.0&quot; /&amp;gt;
         &amp;lt;/font&amp;gt;
      &amp;lt;/Label&amp;gt;
      &amp;lt;Button layoutX=&quot;99.0&quot; layoutY=&quot;169.0&quot; prefHeight=&quot;34.0&quot; prefWidth=&quot;150.0&quot; text=&quot;Hello&quot; onAction=&quot;#toHello&quot;/&amp;gt;
   &amp;lt;/children&amp;gt;
&amp;lt;/Pane&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里跟之前写过的一些案例有点不同的时候，fxml和controller的关系是多对一的关系。（之前的案例都是一对一的关系）。&lt;/p&gt;
&lt;p&gt;springboot-javafx-support组件的关系图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202008/2083963-20200822144137852-911816395.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ViewController中，将Helloworld和Hi视图注入进来，单点击按钮的时候进行视图切换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202008/2083963-20200822144152150-842355917.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ViewController源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FXMLController
public class ViewController {

        @Autowired
        private HelloworldView helloworldView;
        @Autowired
        private HiView hiView;
        @Autowired
        private FooService fooService;
        
        public void toHi() {
                System.out.println(fooService.service());
                App.getScene().setRoot(hiView.getView());
        }
        
        public void toHello() {
                App.getScene().setRoot(helloworldView.getView());
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的@Autowired是Spring的注解，由于@FXMLController主键的Controller是Spring的bean，所以这里完全可以像spring开发一样编写代码。&lt;/p&gt;
&lt;p&gt;如：@Autowired private FooService fooService;&lt;/p&gt;
&lt;p&gt;FoorService是一个简单的接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface FooService {
        String service();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class FooServiceImpl implements FooService {
        @Override
        public String service() {
                return &quot;Foo Service&quot;;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动界面&quot;&gt;启动界面&lt;/h3&gt;
&lt;p&gt;springboot-javafx-support提供了默认的启动界面，当然也开放了自定义界面的入库。&lt;/p&gt;
&lt;p&gt;自定义启动节目只需要继承SplashScreen并重写相关方法即可，这里简单的替换启动图案：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CustomLoadingView extends SplashScreen {
        @Override
        public String getImagePath() {
                return &quot;/images/logo.png&quot;;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在启动类中指定启动界面：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
public class App extends AbstractJavaFxApplicationSupport {
        public static void main(String[] args) {
                launch(App.class, HelloworldView.class, new CustomLoadingView(), args);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样启动界面就不再是之前的样子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202008/2083963-20200822144207270-1185212.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;更多案例&quot;&gt;更多案例&lt;/h3&gt;
&lt;p&gt;springboot-javafx-support提供了一些案例，包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何加载css&lt;/li&gt;
&lt;li&gt;如何使用i18n&lt;/li&gt;
&lt;li&gt;如何打开视图&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;等等。&lt;/p&gt;
&lt;p&gt;有兴趣的话可以看看，GitHub传送门&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/roskenet/spring-javafx-examples&quot;&gt;https://github.com/roskenet/spring-javafx-examples&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外附送 springboot-javafx-support 的GitHub地址&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/roskenet/springboot-javafx-support&quot;&gt;https://github.com/roskenet/springboot-javafx-support&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;=========================================================&lt;br/&gt;&lt;strong&gt;关注&lt;/strong&gt; 公众号 “HiIT青年” 发送 “javafx-springboot” 获取源码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/itqn/1797476/o_200702010008qrcode.jpg&quot; alt=&quot;HiIT青年&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;关注公众号&lt;/strong&gt;，阅读更多文章。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Aug 2020 00:48:00 +0000</pubDate>
<dc:creator>HiIT青年</dc:creator>
<og:description>SpringBoot对于Java程序员来说可以是一个福音，它让程序员在开发的时候，大大简化了各种spring的xml配置。 那么在JavaFX项目使用SpringBoot会是怎么样的体验呢？ 这次使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itqn/p/13545604.html</dc:identifier>
</item>
<item>
<title>关于结构体的初始化 - liuchanglc</title>
<link>http://www.cnblogs.com/liuchanglc/p/13551872.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuchanglc/p/13551872.html</guid>
<description>&lt;p&gt;在&lt;span class=&quot;math inline&quot;&gt;\(cstring\)&lt;/span&gt;库中，有一个函数叫&lt;span class=&quot;math inline&quot;&gt;\(memset\)&lt;/span&gt;&lt;br/&gt;可以方便的把数组赋值成0，-1，无穷大或者无穷小&lt;br/&gt;如果我们要对一个数组&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;进行初始化，那么写法是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;memset(a,0,sizeof(a));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们要对一个结构体初始化，要写成&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;const int maxn=1e6+5;
struct asd{
      int from,to,next,val;
}b[maxn];
memset(&amp;amp;b,0,sizeof(b));
//而不是memset(&amp;amp;b,0,sizeof(struct asd));
//之前博客中的都是错误写法，大家看的时候要注意
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 24 Aug 2020 00:40:00 +0000</pubDate>
<dc:creator>liuchanglc</dc:creator>
<og:description>在$cstring$库中，有一个函数叫$memset$ 可以方便的把数组赋值成0，-1，无穷大或者无穷小 如果我们要对一个数组$a$进行初始化，那么写法是 memset(a,0,sizeof(a));</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuchanglc/p/13551872.html</dc:identifier>
</item>
<item>
<title>.NET 数据库事务的各种玩法进化 - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/13551855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/13551855.html</guid>
<description>&lt;p&gt;事务是数据库系统中的重要概念，本文讲解作者从业 CRUD 十余载的事务多种使用方式总结。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以下所有内容都是针对单机事务而言,不涉及分布式事务相关的东西!&lt;/li&gt;
&lt;li&gt;关于事务原理的讲解不针对具体的某个数据库实现,所以某些地方可能和你的实践经验不符。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;认识事务&quot;&gt;认识事务&lt;/h2&gt;
&lt;p&gt;为什么需要数据库事务？&lt;/p&gt;
&lt;p&gt;转账是生活中常见的操作,比如从A账户转账100元到B账号。站在用户角度而言,这是一个逻辑上的单一操作,然而在数据库系统中,至少会分成两个步骤来完成：&lt;/p&gt;
&lt;p&gt;1.将A账户的金额减少100元&lt;/p&gt;
&lt;p&gt;2.将B账户的金额增加100元。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202008/31407-20200824071752184-765142530.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个过程中可能会出现以下问题:&lt;/p&gt;
&lt;p&gt;1.转账操作的第一步执行成功,A账户上的钱减少了100元,但是第二步执行失败或者未执行便发生系统崩溃,导致B账户并没有相应增加100元。&lt;/p&gt;
&lt;p&gt;2.转账操作刚完成就发生系统崩溃,系统重启恢复时丢失了崩溃前的转账记录。&lt;/p&gt;
&lt;p&gt;3.同时又另一个用户转账给B账户,由于同时对B账户进行操作,导致B账户金额出现异常。&lt;/p&gt;
&lt;p&gt;为了便于解决这些问题,需要引入数据库事务的概念。&lt;/p&gt;
&lt;blockquote readability=&quot;1.6901408450704&quot;&gt;
&lt;p&gt;以上内容引用自：&lt;a href=&quot;https://www.cnblogs.com/takumicx/p/9998844.html&quot;&gt;https://www.cnblogs.com/takumicx/p/9998844.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;认识-adonet&quot;&gt;认识 ADO.NET&lt;/h2&gt;
&lt;p&gt;ADO.NET是.NET框架中的重要组件，主要用于完成C#应用程序访问数据库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/31407/202008/31407-20200824072133302-544974950.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ADO.NET的组成：&lt;/p&gt;
&lt;p&gt;System.Data.Common → 各种数据访问类的基类和接口&lt;br/&gt;System.Data.SqlClient → 对Sql Server进行操作的数据访问类&lt;/p&gt;
&lt;p&gt;a) SqlConnection → 数据库连接器&lt;br/&gt;b) SqlCommand → 数据库命名对象&lt;br/&gt;d) SqlDataReader → 数据读取器&lt;br/&gt;f) SqlParameter → 为存储过程定义参数&lt;br/&gt;g) SqlTransaction → 数据库事物&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;事务1：adonet&quot;&gt;事务1：ADO.NET&lt;/h2&gt;
&lt;p&gt;最原始的事务使用方式，缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码又臭又长&lt;/li&gt;
&lt;li&gt;逻辑难控制，一不小心就忘了提交或回滚，随即而来的是数据库锁得不到释放、或者连接池不够用&lt;/li&gt;
&lt;li&gt;跨方法传递 Tran 对象太麻烦&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;推荐：★☆☆☆☆&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;SqlConnection conn = new SqlConnection(connString);
SqlCommand cmd = new SqlCommand();
cmd.Connection = conn;
try
{
    conn.Open();
    cmd.Transaction = conn.BeginTransaction();//开启事务
    int result = 0;
    foreach (string sql in sqlList)
    {
        cmd.CommandText = sql;
        result += cmd.ExecuteNonQuery();
    }
    cmd.Transaction.Commit();//提交事务
    return result;
}
catch (Exception ex)
{
    //写入日志...
    if (cmd.Transaction != null)
        cmd.Transaction.Rollback();//回滚事务
    throw new Exception(&quot;调用事务更新方法时出现异常：&quot; + ex.Message);
}
finally
{
    if (cmd.Transaction != null)
        cmd.Transaction = null;//清除事务
    conn.Close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;事务2：sqlhepler&quot;&gt;事务2：SqlHepler&lt;/h2&gt;
&lt;p&gt;原始 ADO.NET 事务代码又臭又长，是时候封装一个 SqlHelper 来操作 ADO.NET 了。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;SqlHelper.ExecuteNonQuery(...);
SqlHelper.ExecuteScaler(...);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样封装之后对单次命令执行确实方法不了少，用着用着又发现，事务怎么处理？重截一个 IDbTransaction 参数传入吗？比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;SqlHelper.ExecuteNonQuery(tran, ...);
SqlHelper.ExecuteScaler(tran, ...);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;推荐：★☆☆☆☆&lt;/p&gt;
&lt;p&gt;好像也还行，勉强能接受。&lt;/p&gt;
&lt;p&gt;随着在项目不断的实践，总有一天不能再忍受这种 tran 传递的方式，因为它太容易漏传，特别是跨方法传来传去的时候，真的太难了。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;事务3：利用线程id&quot;&gt;事务3：利用线程id&lt;/h2&gt;
&lt;p&gt;在早期 .NET 还没有异步方法的时候，对事务2的缺陷进行了简单封装，避免事务 tran 对象传来传去的问题。&lt;/p&gt;
&lt;p&gt;其原因是利用线程id，在事务开启之时保存到 staic Dictionary&amp;lt;int, IDbTransaction&amp;gt; 之中，在 SqlHelper.ExecuteXxx 方法执行之前获取当前线程的事务对象，执行命令。&lt;/p&gt;
&lt;p&gt;这样免去了事务传递的恶梦，最终呈现的事务代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;SqlHelper.Transaction(() =&amp;gt;
{
    SqlHelper.ExecuteNonQuery(...); //不再需要显式传递 tran
    SqlHelper.ExecuteScaler(...);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种事务使用起来非常简单，不需要考虑事务提交/释放问题，被默认应用在了 FreeSql 中，缺点：不支持异步。&lt;/p&gt;
&lt;p&gt;推荐：★★★☆☆&lt;/p&gt;
&lt;p&gt;同线程事务使用简单，同时又产生了设计限制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认是提交，遇异常则回滚；&lt;/li&gt;
&lt;li&gt;事务对象在线程挂载，每个线程只可开启一个事务连接，嵌套使用的是同一个事务；&lt;/li&gt;
&lt;li&gt;事务体内代码不可以切换线程，因此不可使用任何异步方法，包括FreeSql提供的数据库异步方法（可以使用任何 Curd 同步方法）；&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;事务4：工作单元&quot;&gt;事务4：工作单元&lt;/h2&gt;
&lt;p&gt;显式将 ITransaction 对象传来传去，说直接点像少女没穿衣服街上乱跑一样，不安全。而且到时候想给少女带点货（状态），一丝不挂没穿衣服咋带货（没口袋）。&lt;/p&gt;
&lt;p&gt;这个时候对 ITransaction 做一层包装就显得有必要了，在IUnitOfWork 中可以定义更多的状态属性。&lt;/p&gt;
&lt;p&gt;推荐：★★★★☆&lt;/p&gt;
&lt;p&gt;定义 IUnitOfWork 接口如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public interface IUnitOfWork : IDisposable
{
    IDbTransaction GetOrBeginTransaction(); //创建或获取对应的 IDbTransaction
    IsolationLevel? IsolationLevel { get; set; }
    void Commit();
    void Rollback();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;事务5：aop-事务&quot;&gt;事务5：AOP 事务&lt;/h2&gt;
&lt;p&gt;技术不断在发展，先来一堆理论：&lt;/p&gt;
&lt;blockquote readability=&quot;1.3186813186813&quot;&gt;
&lt;p&gt;以下内容引用自：&lt;a href=&quot;https://www.cnblogs.com/zhugenqiang/archive/2008/07/27/1252761.html&quot;&gt;https://www.cnblogs.com/zhugenqiang/archive/2008/07/27/1252761.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。&lt;/p&gt;
&lt;p&gt;而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。&lt;/p&gt;
&lt;p&gt;使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”&lt;/p&gt;
&lt;p&gt;实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。&lt;/p&gt;
&lt;p&gt;最终呈现的使用代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;[Transactional]
public void SaveOrder()
{
    SqlHelper.ExecuteNonQuery(...);
    SqlHelper.ExecuteScaler(...);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;推荐：★★★★☆&lt;/p&gt;
&lt;p&gt;利用 [Transactional] 特性标记 SaveOrder 开启事务，他其实是执行类似这样的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public void SaveOrder()
{
    var (var tran = SqlHelper.BeginTransaction())
    {
        try
        {
            SqlHelper.ExecuteNonQuery(tran, ...);
            SqlHelper.ExecuteScaler(tran, ...);
            tran.Commit();
        }
        catch
        {
            tran.Roolback();
            throw;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决了即不用显着传递 tran 对象，也解决了异步逻辑难控制的问题。&lt;/p&gt;
&lt;p&gt;目前该事务方式在 Asp.NETCore 中应用比较广泛，实现起来相当简单，利用动态代理技术，替换 Ioc 中注入的内容，动态拦截 [Transactional] 特性标记的方法。&lt;/p&gt;
&lt;p&gt;使用 Ioc 后就不能再使用 SqlHelper 技术了，此时应该使用 Repository。&lt;/p&gt;
&lt;p&gt;组合技术：Ioc + Repository + UnitOfWork&lt;/p&gt;
&lt;p&gt;了解原理比较重要，本节讲得比较抽象，如果想深入了解原理，请参考 FreeSql 的使用实现代码如下：&lt;/p&gt;
&lt;p&gt;自定义仓储基类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class UnitOfWorkRepository&amp;lt;TEntity, TKey&amp;gt; : BaseRepository&amp;lt;TEntity, TKey&amp;gt;
{
    public UnitOfWorkRepository(IFreeSql fsql, IUnitOfWork uow) : base(fsql, null, null)
    {
        this.UnitOfWork = uow;
    }
}
public class UnitOfWorkRepository&amp;lt;TEntity&amp;gt; : BaseRepository&amp;lt;TEntity, int&amp;gt;
{
    public UnitOfWorkRepository(IFreeSql fsql, IUnitOfWork uow) : base(fsql, null, null)
    {
        this.UnitOfWork = uow;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注入仓储、单例 IFreeSql、AddScoped(IUnitOfWork)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static IServiceCollection AddFreeRepository(this IServiceCollection services, params Assembly[] assemblies)
{
    services.AddScoped(typeof(IReadOnlyRepository&amp;lt;&amp;gt;), typeof(UnitOfWorkRepository&amp;lt;&amp;gt;));
    services.AddScoped(typeof(IBasicRepository&amp;lt;&amp;gt;), typeof(UnitOfWorkRepository&amp;lt;&amp;gt;));
    services.AddScoped(typeof(BaseRepository&amp;lt;&amp;gt;), typeof(UnitOfWorkRepository&amp;lt;&amp;gt;));

    services.AddScoped(typeof(IReadOnlyRepository&amp;lt;,&amp;gt;), typeof(UnitOfWorkRepository&amp;lt;,&amp;gt;));
    services.AddScoped(typeof(IBasicRepository&amp;lt;,&amp;gt;), typeof(UnitOfWorkRepository&amp;lt;,&amp;gt;));
    services.AddScoped(typeof(BaseRepository&amp;lt;,&amp;gt;), typeof(UnitOfWorkRepository&amp;lt;,&amp;gt;));

    if (assemblies?.Any() == true)
        foreach (var asse in assemblies)
            foreach (var repo in asse.GetTypes().Where(a =&amp;gt; a.IsAbstract == false &amp;amp;&amp;amp; typeof(UnitOfWorkRepository).IsAssignableFrom(a)))
                services.AddScoped(repo);

    return services;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;事务6：unitofworkmanager&quot;&gt;事务6：UnitOfWorkManager&lt;/h2&gt;
&lt;p&gt;推荐：★★★★★&lt;/p&gt;
&lt;p&gt;（事务5）声明式事务管理在底层是建立在 AOP 的基础之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。&lt;/p&gt;
&lt;p&gt;声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明（或通过等价的基于标注的方式），便可以将事务规则应用到业务逻辑中。因为事务管理本身就是一个典型的横切逻辑，正是 AOP 的用武之地。&lt;/p&gt;
&lt;p&gt;通常情况下，笔者强烈建议在开发中使用声明式事务，不仅因为其简单，更主要是因为这样使得纯业务代码不被污染，极大方便后期的代码维护。&lt;/p&gt;
&lt;p&gt;和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。&lt;/p&gt;
&lt;p&gt;事务6 UnitOfWorkManager 参考隔壁强大的 java spring 事务管理机制，事务5只能定义单一事务行为（比如不能嵌套），事务5实现的行为机制如下：&lt;/p&gt;
&lt;p&gt;六种传播方式(propagation)，意味着跨方法的事务非常方便，并且支持同步异步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，默认的选择。&lt;/li&gt;
&lt;li&gt;Supports：支持当前事务，如果没有当前事务，就以非事务方法执行。&lt;/li&gt;
&lt;li&gt;Mandatory：使用当前事务，如果没有当前事务，就抛出异常。&lt;/li&gt;
&lt;li&gt;NotSupported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;/li&gt;
&lt;li&gt;Never：以非事务方式执行操作，如果当前事务存在则抛出异常。&lt;/li&gt;
&lt;li&gt;Nested：以嵌套事务方式执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考 FreeSql 的使用方式如下：&lt;/p&gt;
&lt;p&gt;第一步：配置 Startup.cs 注入&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;//Startup.cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton&amp;lt;IFreeSql&amp;gt;(fsql);
    services.AddScoped&amp;lt;UnitOfWorkManager&amp;gt;();
    services.AddFreeRepository(null, typeof(Startup).Assembly);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;UnitOfWorkManager 成员&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;IUnitOfWork Current&lt;/td&gt;
&lt;td&gt;返回当前的工作单元&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;void Binding(repository)&lt;/td&gt;
&lt;td&gt;将仓储的事务交给它管理&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;IUnitOfWork Begin(propagation, isolationLevel)&lt;/td&gt;
&lt;td&gt;创建工作单元&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;第二步：定义事务特性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[AttributeUsage(AttributeTargets.Method)]
public class TransactionalAttribute : Attribute
{
    /// &amp;lt;summary&amp;gt;
    /// 事务传播方式
    /// &amp;lt;/summary&amp;gt;
    public Propagation Propagation { get; set; } = Propagation.Requierd;
    /// &amp;lt;summary&amp;gt;
    /// 事务隔离级别
    /// &amp;lt;/summary&amp;gt;
    public IsolationLevel? IsolationLevel { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步：引入动态代理库&lt;/p&gt;
&lt;p&gt;在 Before 从容器中获取 UnitOfWorkManager，调用它的 var uow = Begin(attr.Propagation, attr.IsolationLevel) 方法&lt;/p&gt;
&lt;p&gt;在 After 调用 Before 中的 uow.Commit 或者 Rollback 方法，最后调用 uow.Dispose&lt;/p&gt;
&lt;p&gt;第四步：在 Controller 或者 Service 或者 Repository 中使用事务特性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class SongService
{
    BaseRepository&amp;lt;Song&amp;gt; _repoSong;
    BaseRepository&amp;lt;Detail&amp;gt; _repoDetail;
    SongRepository _repoSong2;

    public SongService(BaseRepository&amp;lt;Song&amp;gt; repoSong, BaseRepository&amp;lt;Detail&amp;gt; repoDetail, SongRepository repoSong2)
    {
        _repoSong = repoSong;
        _repoDetail = repoDetail;
        _repoSong2 = repoSong2;
    }

    [Transactional]
    public virtual void Test1()
    {
        //这里 _repoSong、_repoDetail、_repoSong2 所有操作都是一个工作单元
        this.Test2();
    }

    [Transactional(Propagation = Propagation.Nested)]
    public virtual void Test2() //嵌套事务，新的（不使用 Test1 的事务）
    {
        //这里 _repoSong、_repoDetail、_repoSong2 所有操作都是一个工作单元
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题：是不是进方法就开事务呢？&lt;/p&gt;
&lt;p&gt;不一定是真实事务，有可能是虚的，就是一个假的 unitofwork（不带事务）。&lt;/p&gt;
&lt;p&gt;也有可能是延用上一次的事务。&lt;/p&gt;
&lt;p&gt;也有可能是新开事务，具体要看传播模式。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;技术不断的演变进步，从 1.0 -&amp;gt; 10.0 需要慢长的过程。&lt;/p&gt;
&lt;p&gt;同时呼吁大家不要盲目使用微服务，演变的过程周期漫长对项目的风险太高。&lt;/p&gt;
&lt;p&gt;早上五点半醒来，写下本文对事务理解的一点总结。谢谢！！&lt;/p&gt;
&lt;p&gt;以上各种事务机制在 FreeSql 中都有实现，FreeSql 是功能强大的对象关系映射技术(O/RM)，支持 .NETCore 2.1+ 或 .NETFramework 4.0+ 或 Xamarin。支持 MySql/SqlServer/PostgreSQL/Oracle/Sqlite/达梦/人大金仓/神舟通用/Access；单元测试数量 5000+，以 MIT 开源协议托管于 github：&lt;a href=&quot;https://github.com/dotnetcore/FreeSql&quot;&gt;https://github.com/dotnetcore/FreeSql&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Aug 2020 00:39:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>事务是数据库系统中的重要概念，本文讲解作者从业 CRUD 十余载的事务多种使用方式总结。 以下所有内容都是针对单机事务而言,不涉及分布式事务相关的东西! 关于事务原理的讲解不针对具体的某个数据库实现,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kellynic/p/13551855.html</dc:identifier>
</item>
<item>
<title>Docker 安装及配置镜像加速 - 哈喽沃德先生</title>
<link>http://www.cnblogs.com/mrhelloworld/p/docker3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrhelloworld/p/docker3.html</guid>
<description>&lt;h2 id=&quot;docker-版本&quot;&gt;Docker 版本&lt;/h2&gt;

&lt;p&gt;　　随着 Docker 的飞速发展，企业级功能的上线，更好的服务意味着需要支付一定的费用，目前 Docker 被分为两个版本：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;community-edition 社区版&lt;/li&gt;
&lt;li&gt;enterprise-edition 企业版&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　Docker 企业版（EE）专为企业开发和 IT 团队设计，可在大规模生产中构建，运送和运行关键业务应用程序。Docker EE 集成，认证和支持，为企业提供业界最安全的容器平台，实现所有应用程序的现代化。作为一个以应用为中心的平台，Docker EE 旨在加速和保护整个软件供应链，从开发到在任何基础设施上运行的生产。&lt;/p&gt;
&lt;p&gt;　　我们学习 Docker 使用 CE 社区版即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812120322558.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;在-centos-上安装-docker-引擎&quot;&gt;在 CentOS 上安装 Docker 引擎&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200818150924974.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　Docker 支持 Mac Windows Linux，本文使用 Linux 环境教大家如何基于 CentOS 安装 Docker 及配置镜像加速。&lt;/p&gt;
&lt;p&gt;　　官方文档：&lt;a href=&quot;https://docs.docker.com/&quot;&gt;https://docs.docker.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;系统要求&quot;&gt;系统要求&lt;/h3&gt;

&lt;p&gt;　　官网提示如果要安装 Docker Engine，您需要一个 CentOS 7 以及以上的稳定版本。&lt;/p&gt;

&lt;h3 id=&quot;卸载旧版本&quot;&gt;卸载旧版本&lt;/h3&gt;

&lt;p&gt;　　较旧的 Docker 版本为 &lt;code&gt;docker&lt;/code&gt; 或 &lt;code&gt;docker-engine&lt;/code&gt;。 如果已安装这些程序，请卸载它们以及相关的依赖项。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Docker 镜像、容器、数据卷和网络数据都保存在 &lt;code&gt;/var/lib/docker/&lt;/code&gt;。新的 Docker 引擎包现在为 &lt;code&gt;Docker-ce&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;设置-yum-源&quot;&gt;设置 yum 源&lt;/h3&gt;

&lt;p&gt;　　安装 &lt;code&gt;yum-utils&lt;/code&gt; 软件包（提供了 &lt;code&gt;yum-config-manager&lt;/code&gt; 程序）并设置稳定的 yum 源方便下载 Docker Engine。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 安装 yum-utils
sudo yum install -y yum-utils
# 设置 yum 源为阿里云方便下载 Docker Engine
sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;docker-安装&quot;&gt;Docker 安装&lt;/h3&gt;

&lt;p&gt;　　安装最新版本的 Docker Engine 和容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sudo yum install docker-ce docker-ce-cli containerd.io
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812123550828.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;安装过程中如果提示您接受 GPG 密钥，请验证指纹是否与 060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35 匹配，如果是，请接受。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;docker-的启动与停止&quot;&gt;Docker 的启动与停止&lt;/h3&gt;

&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 启动 docker
sudo systemctl start docker
# 停止 docker
sudo systemctl stop docker
# 重启 docker
sudo systemctl restart docker
# 设置开机启动
sudo systemctl enable docker
# 查看 docker 状态
sudo systemctl status docker
# 查看 docker 内容器的运行状态
sudo docker stats
# 查看 docker 概要信息
sudo docker info
# 查看 docker 帮助文档
sudo docker --help
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;安装校验&quot;&gt;安装校验&lt;/h3&gt;

&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# docker -v
Docker version 19.03.12, build 48a66213fe
[root@localhost ~]# docker version
Client: Docker Engine - Community
 Version:           19.03.12
 API version:       1.40
 Go version:        go1.13.10
 Git commit:        48a66213fe
 Built:             Mon Jun 22 15:46:54 2020
 OS/Arch:           linux/amd64
 Experimental:      false

Server: Docker Engine - Community
 Engine:
  Version:          19.03.12
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.13.10
  Git commit:       48a66213fe
  Built:            Mon Jun 22 15:45:28 2020
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.2.13
  GitCommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429
 runc:
  Version:          1.0.0-rc10
  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd
 docker-init:
  Version:          0.18.0
  GitCommit:        fec3683
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;配置镜像加速&quot;&gt;配置镜像加速&lt;/h2&gt;

&lt;p&gt;　　Docker 从 Docker Hub 拉取镜像，因为是从国外获取，所以速度较慢，会出现以下情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# docker run hello-world
Unable to find image 'hello-world:latest' locally
docker: Error response from daemon: Get https://registry-1.docker.io/v2/library/hello-world/manifests/latest: net/http: TLS handshake timeout.
See 'docker run --help'.
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　可以通过配置国内镜像源的方式，从国内获取镜像，提高拉取速度。这里介绍中国科学技术大学（LUG@USTC）的开源镜像：&lt;a href=&quot;https://docker.mirrors.ustc.edu.cn&quot;&gt;https://docker.mirrors.ustc.edu.cn&lt;/a&gt; 和网易的开源镜像：&lt;a href=&quot;http://hub-mirror.c.163.com&quot;&gt;http://hub-mirror.c.163.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　USTC 是老牌的 Linux 镜像服务提供者了，USTC 的 Docker 镜像加速服务速度很快。USTC 和网易的优势之一就是不需要注册，属于真正的公共服务。（也可以使用阿里等其他服务商的镜像加速服务）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812130946587.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　编辑文件 &lt;code&gt;daemon.json&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vi /etc/docker/daemon.json
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　在文件中输入以下内容并保存。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;]
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　重新加载配置信息及重启 Docker 服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 重新加载某个服务的配置文件
sudo systemctl daemon-reload
# 重新启动 docker
sudo systemctl restart docker
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;hello-world&quot;&gt;hello-world&lt;/h2&gt;

&lt;p&gt;　　通过运行 &lt;code&gt;hello-world&lt;/code&gt; 镜像来验证 &lt;code&gt;Docker Engine&lt;/code&gt; 是否已正确安装。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@localhost ~]# docker run hello-world
Unable to find image 'hello-world:latest' locally # 本地找不到 hello-world 镜像
latest: Pulling from library/hello-world # 拉取最新版本的 hello-world 镜像
0e03bdcc26d7: Pull complete 
Digest: sha256:49a1c8800c94df04e9658809b006fd8a686cab8028d33cfba2cc049724254202
Status: Downloaded newer image for hello-world:latest

# 看到此消息表示您已正常安装。
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;　　&lt;code&gt;docker run hello-world&lt;/code&gt; 命令执行流程图如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mrhelloworld.com/resources/articles/docker/image-20200812140803688.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过以上步骤大家已完成 Docker 安装的所有工作，接下来通过学习镜像命令和容器命令更加熟悉 Docker 的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/1/171cf87f564bc82e?w=433&amp;amp;h=133&amp;amp;f=gif&amp;amp;s=333013&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;知识共享「署名-非商业性使用-禁止演绎 4.0 国际」许可协议&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;大家可以通过 &lt;a href=&quot;https://mrhelloworld.com/categories&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;分类&lt;/code&gt;&lt;/a&gt; 查看更多关于 &lt;a href=&quot;https://mrhelloworld.com/categories/docker&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;Docker&lt;/code&gt;&lt;/a&gt; 的文章。&lt;/p&gt;

&lt;p&gt;🤗 您的&lt;code&gt;点赞&lt;/code&gt;和&lt;code&gt;转发&lt;/code&gt;是对我最大的支持。&lt;/p&gt;
&lt;p&gt;📢 扫码关注 &lt;code&gt;哈喽沃德先生&lt;/code&gt;「文档 + 视频」每篇文章都配有专门视频讲解，学习更轻松噢 ~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/27/171b91f4ae03d737?w=500&amp;amp;h=500&amp;amp;f=gif&amp;amp;s=126591&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c43d1b5eb06c4b499f0f61eba9e33b4d~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Aug 2020 00:36:00 +0000</pubDate>
<dc:creator>哈喽沃德先生</dc:creator>
<og:description>Docker 版本 随着 Docker 的飞速发展，企业级功能的上线，更好的服务意味着需要支付一定的费用，目前 Docker 被分为两个版本： community-edition 社区版 enterp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrhelloworld/p/docker3.html</dc:identifier>
</item>
<item>
<title>Java并发---concurrent包 - mark-xiang</title>
<link>http://www.cnblogs.com/houqx/p/13529943.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/houqx/p/13529943.html</guid>
<description>&lt;h2&gt;&lt;span&gt;一、包的结构层次&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1483390/202008/1483390-20200819143804297-1733667610.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 其中包含了两个子包atomic和locks，另外字concurrent下的阻塞队列以及executor，这些就是concurrent包中的精华。而这些类的实现主要是依赖于volatile和CAS，从整体上看concurrent包的整体实现图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1483390/202008/1483390-20200819144254368-755129446.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、Lock和synchronized的比较&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。在Lock接口出现之前，Java主要是靠synchronized关键字实现锁功能的，而Java1.5之后，并发包增加了Lock接口，它提供了与synchronized一样的锁功能。虽然它失去了想synchronized关键字隐式加锁解锁的便捷性，单却拥有了获取锁和释放锁的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常Lock使用的形式如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Lock lock=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
lock.lock();
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            
} &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
    lock.unlock();
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;需要注意的是：synchronized同步块执行完成活着遇到异常会自动释放锁，而lock必须调用unlock()释放锁，因此必须在finally中释放锁。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、Lock接口API的介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;看看Lock定义了哪些方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;void lock()；获取锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;void lockInterruptibly() throws InterruptedException;获取所的过程能够响应中断&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;boolean tryLock();非阻塞式响应中断能立即返回，获取锁返回true，反之返回false；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;boolean tryLock(long time, TimeUnit unit) throws InterruptedException;超时获取锁，在超时内或者中断的情况下能够获取锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Condition newCondition();获取与lock绑定的等待通知组件，当前线程必须获得了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;void unlock();释放锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么在locks包下有哪些类实现了改接口？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ReentrantLock&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ReentrantLock &lt;span&gt;implements&lt;/span&gt; Lock, java.io.Serializable &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;很显然ReentrantLock实现了lock接口，当你查看源码是会发现ReentrantLock并没有多少代码，另外一个很明显的特点是：基本上所有的方法的实现实际上都是调用了其静态内部类Sync中的方法，而Sync类继承了AbstractQueuedSynchronizer（AQS）。可以看出ReentrantLock关键核心在于对队列同步器AbstractQueuedSynchronizer的理解。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;四、了解队列同步器AQS（AbstractQueuedSynchronizer）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;关于AQS在源码中有十分具体的解释&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1483390/202008/1483390-20200819155444641-420988875.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 同步器是用来构建锁和其他同步组件的基础框架，它的实现主要依赖一个int成员变量来表示同步状态以及通过一个FIFO队列构成等待队列。它的子类必须重写AQS的几个protected修饰的用来改变同步状态的方法，其他方法主要是实现了排队和阻塞机制。状态的更新使用getState，setState以及compareAndSetState这三个方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子类被推荐定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用，同步器既支持独占式获取同步状态，也支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作。锁和同步器很好的隔离了使用者和实现者所需要关注的领域。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; 五、AQS的设计模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;AQS的设计模式是使用模板方法设计模式，它将一些方法开放给子类进行重写，而同步器给同步组件所提供模板方法又会重新被子类重写的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子，AQS中需要重写的方法tryAcquire&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ReentrantLock中NonfairSync（继承AQS）会重写该方法为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nonfairTryAcquire(acquires);
        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;而AQS中的模板方法acquire()：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;span&gt;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;会调用tryAcquire方法，而此时当继承AQS的NonfairSync调用模板方法acquire时就会调用已经被NonfairSync重写的tryAcquire方法。这就是使用AQS的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同步组件（这里不仅仅指锁，还包括CountDownLatch等）的实现依赖于同步器AQS，在同步组件实现中，使用AQS的方式被推荐定义继承AQS的静态内部类；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AQS采用模板方法进行设计，AQS的protected修饰的方法需要由继承AQS的子类进行重写实现，当调用AQS的子类的方法是就会调用被重写的方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AQS负责同步状态的管理，线程的排队，等待和唤醒这些底层操作，而Lock等同步组件主要专注于实现同步语义；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在重写AQS的方式时，使用AQS提供的getState()，setState()以及compareAndSetState()方法进行修改同步状态.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AQS可重写的方法如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1483390/202008/1483390-20200820161350117-185257960.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 在实现同步组件是AQS提供的模板方法如下图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1483390/202008/1483390-20200820161421233-1277280276.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; AQS提供的模板方法可以分为3类：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;独占式获取与释放同步状态&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;共享式获取与释放同步状态&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;查询同步队列中等待线程情况&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;同步组件通过AQS提供的模板方法实现自己的同步语义。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;span&gt; &lt;span&gt;六、AQS的使用example&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Mutex implements Lock, java.io.Serializable {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Our internal helper class&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sync extends AbstractQueuedSynchronizer {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reports whether in locked state&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; boolean isHeldExclusively() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getState() == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Acquires the lock if state is zero&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; boolean tryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
            assert acquires &lt;/span&gt;== &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Otherwise unused&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (compareAndSetState(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)) {
                setExclusiveOwnerThread(Thread.currentThread());
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Releases the lock by setting state to zero&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; boolean tryRelease(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; releases) {
            assert releases &lt;/span&gt;== &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Otherwise unused&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (getState() == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalMonitorStateException();
            setExclusiveOwnerThread(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            setState(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Provides a Condition&lt;/span&gt;
&lt;span&gt;        Condition newCondition() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConditionObject();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Deserializes properly&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
            s.defaultReadObject();
            setState(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; reset to unlocked state&lt;/span&gt;
&lt;span&gt;        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The sync object does all the hard work. We just forward to it.&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; final Sync sync = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sync();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;() {
        sync.acquire(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean tryLock() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sync.tryAcquire(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock() {
        sync.release(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Condition newCondition() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sync.newCondition();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean isLocked() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sync.isHeldExclusively();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean hasQueuedThreads() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sync.hasQueuedThreads();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; boolean tryLock(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeout, TimeUnit unit) throws InterruptedException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sync.tryAcquireNanos(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, unit.toNanos(timeout));
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; passtra;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MutextDemo {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Mutex mutex = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Mutex();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
                mutex.lock();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;3000&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    mutex.unlock();
                }
            });
            thread.start();
        }
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个例子来源于AQS源码的example，执行情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1483390/202008/1483390-20200821093112127-1784996314.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 上面的例子实现了独占锁的语义，在同一个时刻只允许一个线程占有锁。 MutextDemo新建10个线程，分别睡眠3s。从执行情况也可以看出当前Thread-6正在执行占有锁而其他线程7/8处于WAIT状态。按照推荐的方式，Mutext定义了一个集成AQS的静态内部类Sync，并且重写了AQS的tryAcquire等等方法，而对state的更新也是利用了getState，setState，compareAndSetStaste这三个方法。在实现lock接口中方法也是调用AQS提供的模板方法（因为Sync继承了AQS）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从这个例子就可以很清楚的看出来，在同步组件的实现上主要利用了AQS，而AQS“屏蔽”了同步状态的修改，线程排队等底层实现，通过AQS的模板方法可以很方便的给同步组件的实现警醒调用。而针对用户来说，只需要调用同步组件提供的方法来实现并发编程即可，同时在新建一个同步组件时需要把握的两个关键点是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现同步组件时推荐定义继承AQS的静态内部类，并重写需要的proyected修饰的方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同步组件语义的实现依赖于AQS的模板方法，而AQS模板方法有依赖于AQS的子类重写的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 通俗的说，因为AQS整体设计思路采用模板方法设计模式，同步组件以及AQS的功能实际上分别切换成各自的两部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;同步组件实现者的角度：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过可重新写的方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;独占式：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;tryAcquire()（独占式获取同步状态）；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;tryRelease()（独占式释放同步状态）&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;共享式：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;tryAcquireShared()（共享式获取同步状态）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;tryReleaseShared()（共享式释放同步状态&lt;/strong&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;告诉AQS怎么判断当前同步状态是否成功获取或者是否成功释放。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同步组件专注于对当前同步状态的逻辑判断，从而实现自己的同步语义。这句话比较抽象，举个例子，上面的Mutex例子中通过tryAcquire方法实现自己的同步语义，在该方法中如果当前同步状态为0（即该同步组件没有被任何线程获取），当前线程可以获取同时将状态更改为1返回true，否则，该组件只能在同一时刻被线程占用，mutex专注于获取释放的逻辑来实现自己想要表达的同步语义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;AQS角度&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而对AQS来说，只需要同步组件返回的true和false即可，因为AQS会对true和fals会有不同的操作，true会认为当前线程获取同步组件成功直接返回，而false的话AQS会将当前献策还给你插入同步队列等一系列的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总的来说，同步组件通过重写AQS的方法实现自己想要表达的同步语义，而AQS只需要同步组件表达true和false即可，AQS会针对true和false不同的情况做不同的处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Aug 2020 00:36:00 +0000</pubDate>
<dc:creator>mark-xiang</dc:creator>
<og:description>一、包的结构层次 其中包含了两个子包atomic和locks，另外字concurrent下的阻塞队列以及executor，这些就是concurrent包中的精华。而这些类的实现主要是依赖于volati</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/houqx/p/13529943.html</dc:identifier>
</item>
<item>
<title>学会反射后，我被录取了（干货） - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/13551797.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/13551797.html</guid>
<description>&lt;p&gt;反射是一个非常重要的知识点，在学习&lt;code&gt;Spring 框架&lt;/code&gt;时，Bean的初始化用到了反射，在&lt;code&gt;破坏单例模式&lt;/code&gt;时也用到了反射，在&lt;code&gt;获取标注的注解&lt;/code&gt;时也会用到反射······&lt;/p&gt;
&lt;p&gt;当然了，反射在日常开发中，我们没碰到过多少，至少我没怎么用过。但面试是&lt;strong&gt;造火箭&lt;/strong&gt;现场，可爱的面试官们又怎会轻易地放过我们呢？反射是开源框架中的一个重要设计理念，在源码分析中少不了它的身影，所以，今天我会尽量用浅显易懂的语言，让你去理解下面这几点：&lt;/p&gt;
&lt;p&gt;（1）反射的思想以及它的作用​ 👉 &lt;strong&gt;概念篇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（2）反射的基本使用及应用场景 👉 &lt;strong&gt;应用篇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（3）使用反射能给我们编码时带来的优势以及存在的缺陷 👉 &lt;strong&gt;分析篇&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;反射的思想及作用&quot;&gt;反射的思想及作用&lt;/h2&gt;
&lt;p&gt;有反必有正，就像世间的阴和阳，计算机的0和1一样。天道有轮回，苍天...&lt;s&gt;（净会在这瞎bibi）&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;在学习反射之前，先来了解&lt;strong&gt;正射&lt;/strong&gt;是什么。我们平常用的最多的 &lt;code&gt;new&lt;/code&gt; 方式实例化对象的方式就是一种正射的体现。假如我需要实例化一个&lt;code&gt;HashMap&lt;/code&gt;，代码就会是这样子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
map.put(1, 1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;某一天发现，该段程序不适合用 HashMap 存储键值对，更倾向于用&lt;code&gt;LinkedHashMap&lt;/code&gt;存储。重新编写代码后变成下面这个样子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;Integer, Integer&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;();
map.put(1, 1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如又有一天，发现数据还是适合用 HashMap来存储，难道又要重新修改源码吗？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;发现问题了吗？我们每次改变一种需求，都要去重新&lt;strong&gt;修改源码&lt;/strong&gt;，然后对代码进行编译，打包，再到 JVM 上重启项目。这么些步骤下来，效率非常低。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200824072139183-1709253232.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这种&lt;strong&gt;需求频繁变更但变更不大&lt;/strong&gt;的场景，频繁地更改源码肯定是一种不允许的操作，我们可以使用一个&lt;code&gt;开关&lt;/code&gt;，判断什么时候使用哪一种数据结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Map&amp;lt;Integer, Integer&amp;gt; getMap(String param) {
    Map&amp;lt;Integer, Integer&amp;gt; map = null;
    if (param.equals(&quot;HashMap&quot;)) {
        map = new HashMap&amp;lt;&amp;gt;();
    } else if (param.equals(&quot;LinkedHashMap&quot;)) {
        map = new LinkedHashMap&amp;lt;&amp;gt;();
    } else if (param.equals(&quot;WeakHashMap&quot;)) {
        map = new WeakHashMap&amp;lt;&amp;gt;();
    }
    return map;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过传入参数&lt;code&gt;param&lt;/code&gt;决定使用哪一种数据结构，可以在项目运行时，通过&lt;strong&gt;动态传入参数&lt;/strong&gt;决定使用哪一个数据结构。&lt;/p&gt;
&lt;p&gt;如果某一天还想用&lt;code&gt;TreeMap&lt;/code&gt;，还是避免不了修改源码，重新编译执行的弊端。这个时候，&lt;strong&gt;反射&lt;/strong&gt;就派上用场了。&lt;/p&gt;
&lt;p&gt;在代码运行之前，我们&lt;strong&gt;不确定&lt;/strong&gt;将来会使用哪一种数据结构，只有在程序&lt;strong&gt;运行时才决定&lt;/strong&gt;使用哪一个数据类，而&lt;code&gt;反射&lt;/code&gt;可以在&lt;strong&gt;程序运行过程&lt;/strong&gt;中动态&lt;strong&gt;获取类信息&lt;/strong&gt;和&lt;strong&gt;调用类方法&lt;/strong&gt;。通过反射构造类实例，代码会演变成下面这样。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Map&amp;lt;Integer, Integer&amp;gt; getMap(String className) {
    Class clazz = Class.forName(className);
    Consructor con = clazz.getConstructor();
    return (Map&amp;lt;Integer, Integer&amp;gt;) con.newInstance();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论使用什么 Map，只要实现了&lt;code&gt;Map接口&lt;/code&gt;，就可以使用&lt;code&gt;全类名路径&lt;/code&gt;传入到方法中，获得对应的 Map 实例。例如java.util.HashMap / java.util.LinkedHashMap····如果要创建其它类例如&lt;code&gt;WeakHashMap&lt;/code&gt;，我也&lt;strong&gt;不需要修改上面这段源码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们来回顾一下如何从 &lt;code&gt;new&lt;/code&gt; 一个对象引出使用&lt;code&gt;反射&lt;/code&gt;的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在不使用反射时，构造对象使用 new 方式实现，这种方式在&lt;strong&gt;编译期&lt;/strong&gt;就可以把对象的类型确定下来。&lt;/li&gt;
&lt;li&gt;如果需求发生变更，需要构造另一个对象，则需要修改源码，非常不优雅，所以我们通过使用&lt;code&gt;开关&lt;/code&gt;，在程序运行时判断需要构造哪一个对象，在运行时可以&lt;strong&gt;变更开关&lt;/strong&gt;来实例化不同的数据结构。&lt;/li&gt;
&lt;li&gt;如果还有其它扩展的类有可能被使用，就会创建出&lt;strong&gt;非常多的分支&lt;/strong&gt;，且在编码时不知道有什么其他的类被使用到，假如日后&lt;code&gt;Map&lt;/code&gt;接口下多了一个集合类是&lt;code&gt;xxxHashMap&lt;/code&gt;，还得创建分支，此时引出了反射：可以在&lt;code&gt;运行时&lt;/code&gt;才确定使用哪一个数据类，在切换类时，无需重新修改源码、编译程序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一章总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;反射的&lt;strong&gt;思想&lt;/strong&gt;：&lt;strong&gt;在程序运行过程中确定和解析数据类的类型。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;反射的&lt;strong&gt;作用&lt;/strong&gt;：对于在&lt;code&gt;编译期&lt;/code&gt;无法确定使用哪个数据类的场景，通过&lt;code&gt;反射&lt;/code&gt;可以在程序运行时&lt;strong&gt;构造出不同的数据类实例&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;反射的基本使用&quot;&gt;反射的基本使用&lt;/h2&gt;
&lt;p&gt;Java 反射的主要组成部分有4个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Class&lt;/code&gt;：任何运行在内存中的所有类都是该 Class 类的实例对象，每个 Class 类对象内部都包含了本来的&lt;strong&gt;所有信息&lt;/strong&gt;。记着一句话，通过反射干任何事，先找 Class 准没错！&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Field&lt;/code&gt;：描述一个类的&lt;strong&gt;属性&lt;/strong&gt;，内部包含了该属性的所有信息，例如&lt;strong&gt;数据类型，属性名，访问修饰符&lt;/strong&gt;······&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Constructor&lt;/code&gt;：描述一个类的&lt;strong&gt;构造方法&lt;/strong&gt;，内部包含了构造方法的所有信息，例如&lt;strong&gt;参数类型，参数名字，访问修饰符&lt;/strong&gt;······&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Method&lt;/code&gt;：描述一个类的&lt;strong&gt;所有方法&lt;/strong&gt;（包括抽象方法），内部包含了该方法的所有信息，与&lt;code&gt;Constructor&lt;/code&gt;类似，不同之处是 Method 拥有&lt;strong&gt;返回值类型&lt;/strong&gt;信息，因为构造方法是没有返回值的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我总结了一张脑图，放在了下面，如果用到了反射，离不开这核心的&lt;code&gt;4&lt;/code&gt;个类，只有去了解它们内部提供了哪些信息，有什么作用，运用它们的时候才能&lt;strong&gt;易如反掌&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200824072149419-1625663390.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在学习反射的基本使用时，我会用一个&lt;code&gt;SmallPineapple&lt;/code&gt;类作为模板进行说明，首先我们先来熟悉这个类的基本组成：&lt;strong&gt;属性，构造函数和方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SmallPineapple {
    public String name;
    public int age;
    private double weight; // 体重只有自己知道
        
    public SmallPineapple() {}
    
    public SmallPineapple(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public void getInfo() {
        System.out.print(&quot;[&quot;+ name + &quot; 的年龄是：&quot; + age + &quot;]&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反射中的用法有非常非常多，常见的功能有以下这几个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在运行时获取一个类的 &lt;strong&gt;Class 对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在运行时构造一个类的&lt;strong&gt;实例化对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在运行时获取一个类的所有信息：&lt;strong&gt;变量、方法、构造器、注解&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;获取类的-class-对象&quot;&gt;获取类的 Class 对象&lt;/h3&gt;
&lt;p&gt;在 Java 中，每一个类都会有专属于自己的 Class 对象，当我们编写完&lt;code&gt;.java&lt;/code&gt;文件后，使用&lt;code&gt;javac&lt;/code&gt;编译后，就会产生一个字节码文件&lt;code&gt;.class&lt;/code&gt;，在字节码文件中包含类的所有信息，如&lt;code&gt;属性&lt;/code&gt;，&lt;code&gt;构造方法&lt;/code&gt;，&lt;code&gt;方法&lt;/code&gt;······当字节码文件被装载进虚拟机执行时，会在内存中生成 Class 对象，它包含了该类内部的所有信息，在程序运行时可以获取这些信息。&lt;/p&gt;
&lt;p&gt;获取 Class 对象的方法有&lt;code&gt;3&lt;/code&gt;种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;类名.class&lt;/code&gt;：这种获取方式只有在&lt;code&gt;编译&lt;/code&gt;前已经声明了该类的类型才能获取到 Class 对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz = SmallPineapple.class;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;实例.getClass()&lt;/code&gt;：通过实例化对象获取该实例的 Class 对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;SmallPineapple sp = new SmallPineapple();
Class clazz = sp.getClass();
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Class.forName(className)&lt;/code&gt;：通过类的&lt;strong&gt;全限定名&lt;/strong&gt;获取该类的 Class 对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz = Class.forName(&quot;com.bean.smallpineapple&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拿到 &lt;code&gt;Class&lt;/code&gt;对象就可以对它为所欲为了：剥开它的皮（获取&lt;strong&gt;类信息&lt;/strong&gt;）、指挥它做事（调用它的&lt;strong&gt;方法&lt;/strong&gt;），看透它的一切（获取&lt;strong&gt;属性&lt;/strong&gt;），总之它就没有隐私了。&lt;/p&gt;
&lt;p&gt;不过在程序中，每个类的 Class 对象只有一个，也就是说你只有这一个&lt;code&gt;奴隶&lt;/code&gt;。我们用上面三种方式测试，通过三种方式打印各个 &lt;code&gt;Class&lt;/code&gt; 对象都是相同的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz1 = Class.forName(&quot;com.bean.SmallPineapple&quot;);
Class clazz2 = SmallPineapple.class;
SmallPineapple instance = new SmallPineapple();
Class clazz3 = instance.getClass();
System.out.println(&quot;Class.forName() == SmallPineapple.class:&quot; + (clazz1 == clazz2));
System.out.println(&quot;Class.forName() == instance.getClass():&quot; + (clazz1 == clazz3));
System.out.println(&quot;instance.getClass() == SmallPineapple.class:&quot; + (clazz2 == clazz3));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200824072159080-1118139076.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;内存中只有一个 Class 对象的原因要牵扯到 &lt;code&gt;JVM 类加载机制&lt;/code&gt;的&lt;code&gt;双亲委派模型&lt;/code&gt;，它保证了程序运行时，&lt;code&gt;加载类&lt;/code&gt;时每个类在内存中仅会产生一个&lt;code&gt;Class对象&lt;/code&gt;。在这里我不打算详细展开说明，可以简单地理解为 JVM 帮我们保证了&lt;strong&gt;一个类在内存中至多存在一个 Class 对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;构造类的实例化对象&quot;&gt;构造类的实例化对象&lt;/h3&gt;
&lt;p&gt;通过反射构造一个类的实例方式有&lt;code&gt;2&lt;/code&gt;种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Class 对象调用&lt;code&gt;newInstance()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz = Class.forName(&quot;com.bean.SmallPineapple&quot;);
SmallPineapple smallPineapple = (SmallPineapple) clazz.newInstance();
smallPineapple.getInfo();
// [null 的年龄是：0]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即使 SmallPineapple 已经显式定义了构造方法，通过 newInstance() 创建的实例中，所有属性值都是对应类型的&lt;code&gt;初始值&lt;/code&gt;，因为 newInstance() 构造实例会&lt;strong&gt;调用默认无参构造器&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Constructor 构造器调用&lt;code&gt;newInstance()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz = Class.forName(&quot;com.bean.SmallPineapple&quot;);
Constructor constructor = clazz.getConstructor(String.class, int.class);
constructor.setAccessible(true);
SmallPineapple smallPineapple2 = (SmallPineapple) constructor.newInstance(&quot;小菠萝&quot;, 21);
smallPineapple2.getInfo();
// [小菠萝 的年龄是：21]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 getConstructor(Object... paramTypes) 方法指定获取&lt;strong&gt;指定参数类型&lt;/strong&gt;的 Constructor， Constructor 调用 newInstance(Object... paramValues) 时传入构造方法参数的值，同样可以构造一个实例，且内部属性已经被赋值。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;Class&lt;/code&gt;对象调用 newInstance() 会走&lt;strong&gt;默认无参构造方法&lt;/strong&gt;，如果想通过&lt;strong&gt;显式构造方法&lt;/strong&gt;构造实例，需要提前从Class中调用&lt;code&gt;getConstructor()&lt;/code&gt;方法获取对应的构造器，通过构造器去实例化对象。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这些 API 是在开发当中最常遇到的，当然还有非常多重载的方法，本文由于篇幅原因，且如果每个方法都一一讲解，我们也记不住，所以用到的时候去类里面查找就已经足够了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;获取一个类的所有信息&quot;&gt;获取一个类的所有信息&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Class 对象中包含了该类的所有信息，在编译期我们能看到的信息就是该类的变量、方法、构造器，在运行时最常被获取的也是这些信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200824072208255-1751310989.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;获取类中的变量（field）&quot;&gt;获取类中的变量（Field）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Field[] getFields()：获取类中所有被&lt;code&gt;public&lt;/code&gt;修饰的所有变量&lt;/li&gt;
&lt;li&gt;Field getField(String name)：根据&lt;strong&gt;变量名&lt;/strong&gt;获取类中的一个变量，该&lt;strong&gt;变量必须被public修饰&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Field[] getDeclaredFields()：获取类中所有的变量，但&lt;strong&gt;无法获取继承下来的变量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Field getDeclaredField(String name)：根据姓名获取类中的某个变量，&lt;strong&gt;无法获取继承下来的变量&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;获取类中的方法（method）&quot;&gt;获取类中的方法（Method）&lt;/h3&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Method[] getMethods()：获取类中被&lt;code&gt;public&lt;/code&gt;修饰的所有方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Method getMethod(String name, Class...&amp;lt;?&amp;gt; paramTypes)：根据&lt;strong&gt;名字和参数类型&lt;/strong&gt;获取对应方法，该方法必须被&lt;code&gt;public&lt;/code&gt;修饰&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Method[] getDeclaredMethods()：获取&lt;code&gt;所有&lt;/code&gt;方法，但&lt;strong&gt;无法获取继承下来的方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Method getDeclaredMethod(String name, Class...&amp;lt;?&amp;gt; paramTypes)：根据&lt;strong&gt;名字和参数类型&lt;/strong&gt;获取对应方法，&lt;strong&gt;无法获取继承下来的方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;获取类的构造器（constructor）&quot;&gt;获取类的构造器（Constructor）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Constuctor[] getConstructors()：获取类中所有被&lt;code&gt;public&lt;/code&gt;修饰的构造器&lt;/li&gt;
&lt;li&gt;Constructor getConstructor(Class...&amp;lt;?&amp;gt; paramTypes)：根据&lt;code&gt;参数类型&lt;/code&gt;获取类中某个构造器，该构造器必须被&lt;code&gt;public&lt;/code&gt;修饰&lt;/li&gt;
&lt;li&gt;Constructor[] getDeclaredConstructors()：获取类中所有构造器&lt;/li&gt;
&lt;li&gt;Constructor getDeclaredConstructor(class...&amp;lt;?&amp;gt; paramTypes)：根据&lt;code&gt;参数类型&lt;/code&gt;获取对应的构造器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每种功能内部以 Declared 细分为&lt;code&gt;2&lt;/code&gt;类：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;有&lt;code&gt;Declared&lt;/code&gt;修饰的方法：可以获取该类内部包含的&lt;strong&gt;所有&lt;/strong&gt;变量、方法和构造器，但是&lt;strong&gt;无法获取继承下来的信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无&lt;code&gt;Declared&lt;/code&gt;修饰的方法：可以获取该类中&lt;code&gt;public&lt;/code&gt;修饰的变量、方法和构造器，可&lt;strong&gt;获取继承下来的信息&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想获取类中&lt;strong&gt;所有的（包括继承）&lt;/strong&gt;变量、方法和构造器，则需要同时调用&lt;code&gt;getXXXs()&lt;/code&gt;和&lt;code&gt;getDeclaredXXXs()&lt;/code&gt;两个方法，用&lt;code&gt;Set&lt;/code&gt;集合存储它们获得的变量、构造器和方法，以防两个方法获取到相同的东西。&lt;/p&gt;
&lt;p&gt;例如：要获取SmallPineapple获取类中&lt;strong&gt;所有的变量&lt;/strong&gt;，代码应该是下面这样写。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz = Class.forName(&quot;com.bean.SmallPineapple&quot;);
// 获取 public 属性，包括继承
Field[] fields1 = clazz.getFields();
// 获取所有属性，不包括继承
Field[] fields2 = clazz.getDeclaredFields();
// 将所有属性汇总到 set
Set&amp;lt;Field&amp;gt; allFields = new HashSet&amp;lt;&amp;gt;();
allFields.addAll(Arrays.asList(fields1));
allFields.addAll(Arrays.asList(fields2));
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;不知道你有没有发现一件&lt;strong&gt;有趣的事情&lt;/strong&gt;，如果父类的属性用&lt;code&gt;protected&lt;/code&gt;修饰，利用反射是&lt;strong&gt;无法获取到&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;protected 修饰符的作用范围：只允许&lt;code&gt;同一个包下&lt;/code&gt;或者&lt;code&gt;子类&lt;/code&gt;访问，可以继承到子类。&lt;/p&gt;
&lt;p&gt;getFields() 只能获取到本类的&lt;code&gt;public&lt;/code&gt;属性的变量值；&lt;/p&gt;
&lt;p&gt;getDeclaredFields() 只能获取到&lt;strong&gt;本类的所有属性，不包括继承&lt;/strong&gt;的；无论如何都获取不到父类的 protected 属性修饰的变量，但是它的的确确存在于子类中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;获取注解&quot;&gt;获取注解&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;获取注解单独拧了出来，因为它并不是专属于 Class 对象的一种信息，每个变量，方法和构造器都可以被注解修饰，所以在反射中，Field，Constructor 和 Method 类对象都可以调用下面这些方法获取标注在它们之上的注解。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Annotation[] getAnnotations()：获取该对象上的&lt;strong&gt;所有注解&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Annotation getAnnotation(Class annotaionClass)：传入&lt;code&gt;注解类型&lt;/code&gt;，获取该对象上的特定一个注解&lt;/li&gt;
&lt;li&gt;Annotation[] getDeclaredAnnotations()：获取该对象上的显式标注的所有注解，无法获取&lt;code&gt;继承&lt;/code&gt;下来的注解&lt;/li&gt;
&lt;li&gt;Annotation getDeclaredAnnotation(Class annotationClass)：根据&lt;code&gt;注解类型&lt;/code&gt;，获取该对象上的特定一个注解，无法获取&lt;code&gt;继承&lt;/code&gt;下来的注解&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只有注解的&lt;code&gt;@Retension&lt;/code&gt;标注为&lt;code&gt;RUNTIME&lt;/code&gt;时，才能够通过反射获取到该注解，@Retension 有&lt;code&gt;3&lt;/code&gt;种保存策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;SOURCE&lt;/code&gt;：只在&lt;strong&gt;源文件(.java)&lt;/strong&gt;中保存，即该注解只会保留在源文件中，&lt;strong&gt;编译时编译器会忽略该注解&lt;/strong&gt;，例如 @Override 注解&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CLASS&lt;/code&gt;：保存在&lt;strong&gt;字节码文件(.class)&lt;/strong&gt;中，注解会随着编译跟随字节码文件中，但是&lt;strong&gt;运行时&lt;/strong&gt;不会对该注解进行解析&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUNTIME&lt;/code&gt;：一直保存到&lt;strong&gt;运行时&lt;/strong&gt;，&lt;strong&gt;用得最多的一种保存策略&lt;/strong&gt;，在运行时可以获取到该注解的所有信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;像下面这个例子，SmallPineapple 类继承了抽象类&lt;code&gt;Pineapple&lt;/code&gt;，&lt;code&gt;getInfo()&lt;/code&gt;方法上标识有 @Override 注解，且在子类中标注了&lt;code&gt;@Transient&lt;/code&gt;注解，在运行时获取子类重写方法上的所有注解，只能获取到&lt;code&gt;@Transient&lt;/code&gt;的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Pineapple {
    public abstract void getInfo();
}
public class SmallPineapple extends Pineapple {
    @Transient
    @Override
    public void getInfo() {
        System.out.print(&quot;小菠萝的身高和年龄是:&quot; + height + &quot;cm ; &quot; + age + &quot;岁&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动类&lt;code&gt;Bootstrap&lt;/code&gt;获取 SmallPineapple 类中的 getInfo() 方法上的注解信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Bootstrap {
    /**
     * 根据运行时传入的全类名路径判断具体的类对象
     * @param path 类的全类名路径
     */
    public static void execute(String path) throws Exception {
        Class obj = Class.forName(path);
        Method method = obj.getMethod(&quot;getInfo&quot;);
        Annotation[] annotations = method.getAnnotations();
        for (Annotation annotation : annotations) {
            System.out.println(annotation.toString());
        }
    }
    public static void main(String[] args) throws Exception {
        execute(&quot;com.pineapple.SmallPineapple&quot;);
    }
}
// @java.beans.Transient(value=true)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过反射调用方法&quot;&gt;通过反射调用方法&lt;/h3&gt;
&lt;p&gt;通过反射获取到某个 Method 类对象后，可以通过调用&lt;code&gt;invoke&lt;/code&gt;方法执行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;invoke(Oject obj, Object... args)&lt;/code&gt;：参数``1&lt;code&gt;指定调用该方法的**对象**，参数&lt;/code&gt;2`是方法的参数列表值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果调用的方法是&lt;strong&gt;静态方法&lt;/strong&gt;，参数1只需要传入&lt;code&gt;null&lt;/code&gt;，因为静态方法不与某个对象有关，只与某个类有关。&lt;/p&gt;
&lt;p&gt;可以像下面这种做法，通过反射实例化一个对象，然后获取&lt;code&gt;Method&lt;/code&gt;方法对象，调用&lt;code&gt;invoke()&lt;/code&gt;指定&lt;code&gt;SmallPineapple&lt;/code&gt;的&lt;code&gt;getInfo()&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Class clazz = Class.forName(&quot;com.bean.SmallPineapple&quot;);
Constructor constructor = clazz.getConstructor(String.class, int.class);
constructor.setAccessible(true);
SmallPineapple sp = (SmallPineapple) constructor.newInstance(&quot;小菠萝&quot;, 21);
Method method = clazz.getMethod(&quot;getInfo&quot;);
if (method != null) {
    method.invoke(sp, null);
}
// [小菠萝的年龄是：21]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;反射的应用场景&quot;&gt;反射的应用场景&lt;/h2&gt;
&lt;p&gt;反射常见的应用场景这里介绍&lt;code&gt;3&lt;/code&gt;个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring 实例化对象：当程序启动时，Spring 会读取配置文件&lt;code&gt;applicationContext.xml&lt;/code&gt;并解析出里面所有的 标签实例化到&lt;code&gt;IOC&lt;/code&gt;容器中。&lt;/li&gt;
&lt;li&gt;反射 + 工厂模式：通过&lt;code&gt;反射&lt;/code&gt;消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，&lt;code&gt;反射&lt;/code&gt;可以使得程序更加健壮。&lt;/li&gt;
&lt;li&gt;JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的&lt;code&gt;驱动类&lt;/code&gt;时用到反射加载驱动类&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;spring-的-ioc-容器&quot;&gt;Spring 的 IOC 容器&lt;/h3&gt;
&lt;p&gt;在 Spring 中，经常会编写一个上下文配置文件&lt;code&gt;applicationContext.xml&lt;/code&gt;，里面就是关于&lt;code&gt;bean&lt;/code&gt;的配置，程序启动时会读取该 xml 文件，解析出所有的 &lt;code&gt;&amp;lt;bean&amp;gt;&lt;/code&gt;标签，并实例化对象放入&lt;code&gt;IOC&lt;/code&gt;容器中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;
    &amp;lt;bean id=&quot;smallpineapple&quot; class=&quot;com.bean.SmallPineapple&quot;&amp;gt;
        &amp;lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;小菠萝&quot;/&amp;gt;
        &amp;lt;constructor-arg type=&quot;int&quot; value=&quot;21&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在定义好上面的文件后，通过&lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt;加载该配置文件，程序启动时，Spring 会将该配置文件中的所有&lt;code&gt;bean&lt;/code&gt;都实例化，放入 IOC 容器中，IOC 容器本质上就是一个工厂，通过该工厂传入 &amp;lt;bean&amp;gt; 标签的&lt;code&gt;id&lt;/code&gt;属性获取到对应的实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Main {
    public static void main(String[] args) {
        ApplicationContext ac =
                new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        SmallPineapple smallPineapple = (SmallPineapple) ac.getBean(&quot;smallpineapple&quot;);
        smallPineapple.getInfo(); // [小菠萝的年龄是：21]
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring 在实例化对象的过程经过简化之后，可以理解为反射实例化对象的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;获取Class对象的构造器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过构造器&lt;strong&gt;调用 newInstance()&lt;/strong&gt; 实例化对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然 Spring 在实例化对象时，做了非常多额外的操作，才能够让现在的开发足够的&lt;strong&gt;便捷且稳定&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在之后的文章中会专门写一篇文章讲解如何利用反射实现一个&lt;code&gt;简易版&lt;/code&gt;的&lt;code&gt;IOC&lt;/code&gt;容器，IOC容器原理很简单，只要掌握了反射的思想，了解反射的常用 API 就可以实现，我可以提供一个简单的思路：利用 HashMap 存储所有实例，key 代表 &amp;lt;bean&amp;gt; 标签的 &lt;code&gt;id&lt;/code&gt;，value 存储对应的实例，这对应了 Spring IOC容器管理的对象默认是&lt;strong&gt;单例&lt;/strong&gt;的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;反射--抽象工厂模式&quot;&gt;反射 + 抽象工厂模式&lt;/h3&gt;
&lt;p&gt;传统的工厂模式，如果需要生产新的子类，&lt;strong&gt;需要修改工厂类，在工厂类中增加新的分支&lt;/strong&gt;；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MapFactory {
    public Map&amp;lt;Object, object&amp;gt; produceMap(String name) {
        if (&quot;HashMap&quot;.equals(name)) {
            return new HashMap&amp;lt;&amp;gt;();
        } else if (&quot;TreeMap&quot;.equals(name)) {
            return new TreeMap&amp;lt;&amp;gt;();
        } // ···
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用反射和工厂模式相结合，在产生新的子类时，&lt;strong&gt;工厂类不用修改任何东西&lt;/strong&gt;，可以专注于子类的实现，&lt;strong&gt;当子类确定下来时，工厂也就可以生产该子类了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;反射 + 抽象工厂的&lt;strong&gt;核心思想&lt;/strong&gt;是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;在运行时通过参数传入不同子类的全限定名获取到不同的 Class 对象，调用 newInstance() 方法返回不同的子类。&lt;/strong&gt;细心的读者会发现提到了&lt;strong&gt;子类&lt;/strong&gt;这个概念，所以反射 + 抽象工厂模式，一般会用于有&lt;strong&gt;继承&lt;/strong&gt;或者&lt;strong&gt;接口实现&lt;/strong&gt;关系。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，在运行时才确定使用哪一种 &lt;code&gt;Map&lt;/code&gt; 结构，我们可以利用反射传入某个具体 Map 的全限定名，实例化一个特定的子类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MapFactory {
    /**
     * @param className 类的全限定名
     */
    public Map&amp;lt;Object, Object&amp;gt; produceMap(String className) {
        Class clazz = Class.forName(className);
        Map&amp;lt;Object, Object&amp;gt; map = clazz.newInstance();
        return map;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;className&lt;/code&gt; 可以指定为 java.util.HashMap，或者 java.util.TreeMap 等等，根据业务场景来定。&lt;/p&gt;
&lt;h3 id=&quot;jdbc-加载数据库驱动类&quot;&gt;JDBC 加载数据库驱动类&lt;/h3&gt;
&lt;p&gt;在导入第三方库时，JVM不会主动去加载外部导入的类，而是&lt;strong&gt;等到真正使用时，才去加载需要的类&lt;/strong&gt;，正是如此，我们可以在获取数据库连接时传入驱动类的全限定名，交给 JVM 加载该类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DBConnectionUtil {
    /** 指定数据库的驱动类 */
    private static final String DRIVER_CLASS_NAME = &quot;com.mysql.jdbc.Driver&quot;;
    
    public static Connection getConnection() {
        Connection conn = null;
        // 加载驱动类
        Class.forName(DRIVER_CLASS_NAME);
        // 获取数据库连接对象
        conn = DriverManager.getConnection(&quot;jdbc:mysql://···&quot;, &quot;root&quot;, &quot;root&quot;);
        return conn;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我们开发 SpringBoot 项目时，会经常遇到这个类，但是可能习惯成自然了，就没多大在乎，我在这里给你们看看常见的&lt;code&gt;application.yml&lt;/code&gt;中的数据库配置，我想你应该会恍然大悟吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200824072224209-864434052.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的 &lt;strong&gt;driver-class-name&lt;/strong&gt;，和我们一开始加载的类是不是觉得很相似，这是因为&lt;strong&gt;MySQL&lt;/strong&gt;版本不同引起的&lt;strong&gt;驱动类不同&lt;/strong&gt;，这体现使用反射的好处：不需要修改源码，&lt;strong&gt;仅加载配置文件就可以完成驱动类的替换&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;在之后的文章中会专门写一篇文章详细地介绍反射的应用场景，实现简单的&lt;code&gt;IOC&lt;/code&gt;容器以及通过反射实现工厂模式的好处。&lt;/p&gt;
&lt;p&gt;在这里，你只需要掌握反射的基本用法和它的思想，了解它的主要使用场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;反射的优势及缺陷&quot;&gt;反射的优势及缺陷&lt;/h2&gt;
&lt;p&gt;反射的&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;增加程序的灵活性&lt;/strong&gt;：面对需求变更时，可以灵活地实例化不同对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，有得必有失，一项技术不可能只有优点没有缺点，反射也有&lt;strong&gt;两个比较隐晦的缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;破坏类的封装性&lt;/strong&gt;：可以强制访问 private 修饰的信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能损耗&lt;/strong&gt;：反射相比直接实例化对象、调用方法、访问变量，中间需要非常多的&lt;strong&gt;检查步骤和解析步骤&lt;/strong&gt;，JVM无法对它们优化。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;增加程序的灵活性&quot;&gt;增加程序的灵活性&lt;/h3&gt;
&lt;p&gt;这里不再用 SmallPineapple 举例了，我们来看一个更加&lt;code&gt;贴近开发&lt;/code&gt;的例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用反射连接数据库，&lt;strong&gt;涉及到数据库的数据源&lt;/strong&gt;。在 SpringBoot 中一切约定大于配置，想要&lt;strong&gt;定制配置&lt;/strong&gt;时，使用&lt;code&gt;application.properties&lt;/code&gt;配置文件指定数据源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;角色1 - Java的设计者&lt;/strong&gt;：我们设计好&lt;code&gt;DataSource&lt;/code&gt;接口，你们其它数据库厂商想要开发者用&lt;code&gt;你们的数据源&lt;/code&gt;监控数据库，就得实现&lt;code&gt;我的这个接口&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;角色2 - 数据库厂商&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MySQL 数据库厂商：我们提供了 &lt;strong&gt;com.mysql.cj.jdbc.MysqlDataSource&lt;/strong&gt; 数据源，开发者可以使用它连接 MySQL。&lt;/li&gt;
&lt;li&gt;阿里巴巴厂商：我们提供了 &lt;strong&gt;com.alibaba.druid.pool.DruidDataSource&lt;/strong&gt; 数据源，我这个数据源更牛逼，具有&lt;strong&gt;页面监控&lt;/strong&gt;，&lt;strong&gt;慢SQL日志记录&lt;/strong&gt;等功能，开发者快来用它监控 MySQL吧！&lt;/li&gt;
&lt;li&gt;SQLServer 厂商：我们提供了 &lt;strong&gt;com.microsoft.sqlserver.jdbc.SQLServerDataSource&lt;/strong&gt; 数据源，如果你想实用SQL Server 作为数据库，那就使用我们的这个数据源连接吧&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;角色3 - 开发者&lt;/strong&gt;：我们可以用&lt;code&gt;配置文件&lt;/code&gt;指定使用&lt;code&gt;DruidDataSource&lt;/code&gt;数据源&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;需求变更&lt;/strong&gt;：某一天，老板来跟我们说，Druid 数据源不太符合我们现在的项目了，我们使用 &lt;strong&gt;MysqlDataSource&lt;/strong&gt; 吧，然后程序猿就会修改配置文件，重新加载配置文件，并重启项目，完成数据源的切换。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;spring.datasource.type=com.mysql.cj.jdbc.MysqlDataSource
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在改变连接数据库的数据源时，只需要改变配置文件即可，&lt;strong&gt;无需改变任何代码&lt;/strong&gt;，原因是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Spring Boot 底层封装好了连接数据库的数据源配置，利用反射，适配各个数据源。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面来简略的进行源码分析。我们用&lt;code&gt;ctrl+左键&lt;/code&gt;点击&lt;code&gt;spring.datasource.type&lt;/code&gt;进入 DataSourceProperties 类中，发现使用setType() 将&lt;strong&gt;全类名转化为 Class 对象&lt;/strong&gt;注入到&lt;code&gt;type&lt;/code&gt;成员变量当中。在连接并监控数据库时，就会使用指定的数据源操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Class&amp;lt;? extends DataSource&amp;gt; type;

public void setType(Class&amp;lt;? extends DataSource&amp;gt; type) {
    this.type = type;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Class&lt;/code&gt;对象指定了泛型上界&lt;code&gt;DataSource&lt;/code&gt;，我们去看一下各大数据源的&lt;code&gt;类图结构&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200824072244099-80644253.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上图展示了一部分数据源，当然不止这些，但是我们可以看到，无论指定使用哪一种数据源，我们都只需要与配置文件打交道，而无需更改源码，这就是反射的灵活性！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;破坏类的封装性&quot;&gt;破坏类的封装性&lt;/h3&gt;
&lt;p&gt;很明显的一个特点，反射可以获取类中被&lt;code&gt;private&lt;/code&gt;修饰的变量、方法和构造器，这&lt;strong&gt;违反了面向对象的封装特性&lt;/strong&gt;，因为被 private 修饰意味着不想对外暴露，只允许本类访问，而&lt;code&gt;setAccessable(true)&lt;/code&gt;可以无视访问修饰符的限制，外界可以强制访问。&lt;/p&gt;
&lt;p&gt;还记得&lt;code&gt;单例模式&lt;/code&gt;一文吗？里面讲到反射破坏饿汉式和懒汉式单例模式，所以之后用了&lt;code&gt;枚举&lt;/code&gt;避免被反射KO。&lt;/p&gt;
&lt;p&gt;回到最初的起点，SmallPineapple 里有一个 weight 属性被 private 修饰符修饰，目的在于自己的体重并不想给外界知道。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SmallPineapple {
    public String name;
    public int age;
    private double weight; // 体重只有自己知道
    
    public SmallPineapple(String name, int age, double weight) {
        this.name = name;
        this.age = age;
        this.weight = weight;
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然 weight 属性理论上只有自己知道，但是如果经过反射，这个类就像在&lt;strong&gt;裸奔&lt;/strong&gt;一样，在反射面前变得&lt;code&gt;一览无遗&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;SmallPineapple sp = new SmallPineapple(&quot;小菠萝&quot;, 21, &quot;54.5&quot;);
Clazz clazz = Class.forName(sp.getClass());
Field weight = clazz.getDeclaredField(&quot;weight&quot;);
weight.setAccessable(true);
System.out.println(&quot;窥觑到小菠萝的体重是：&quot; + weight.get(sp));
// 窥觑到小菠萝的体重是：54.5 kg
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;性能损耗&quot;&gt;性能损耗&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在直接 new 对象并调用对象方法和访问属性时，编译器会在编译期提前检查可访问性，如果尝试进行不正确的访问，IDE会提前提示错误，例如参数传递类型不匹配，非法访问 private 属性和方法。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;而在利用反射操作对象时，编译器无法提前得知对象的类型，访问是否合法，参数传递类型是否匹配。只有在程序运行时调用反射的代码时才会从头开始检查、调用、返回结果，JVM也无法对反射的代码进行优化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然反射具有性能损耗的特点，但是我们不能一概而论，产生了使用反射就会性能下降的思想，反射的慢，需要同时调用上&lt;code&gt;100W&lt;/code&gt;次才可能体现出来，在几次、几十次的调用，并不能体现反射的性能低下。所以不要一味地戴有色眼镜看反射，&lt;strong&gt;在单次调用反射的过程中，性能损耗可以忽略不计。如果程序的性能要求很高，那么尽量不要使用反射。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;反射基础篇文末总结&quot;&gt;反射基础篇文末总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;反射的思想：反射就像是&lt;strong&gt;一面镜子&lt;/strong&gt;一样，在&lt;strong&gt;运行时&lt;/strong&gt;才看到自己是谁，可获取到自己的信息，甚至实例化对象。&lt;/li&gt;
&lt;li&gt;反射的作用：&lt;strong&gt;在运行时才确定实例化对象，使程序更加健壮&lt;/strong&gt;，面对需求变更时，可以最大程度地做到不修改程序源码应对不同的场景，实例化不同类型的对象。&lt;/li&gt;
&lt;li&gt;反射的应用场景常见的有&lt;code&gt;3&lt;/code&gt;个：Spring的 IOC 容器，反射+工厂模式 使工厂类更稳定，JDBC连接数据库时加载驱动类&lt;/li&gt;
&lt;li&gt;反射的&lt;code&gt;3&lt;/code&gt;个特点：增加程序的灵活性、破坏类的封装性以及性能损耗&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你好，我是 cxuan，我自己手写了四本 PDF，分别是 Java基础总结、HTTP 核心总结、计算机基础知识，操作系统核心总结，我已经整理成为 PDF，可以关注公众号 Java建设者 回复 PDF 领取优质资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202008/1515111-20200824072327466-1728309036.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 23 Aug 2020 23:24:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>反射是一个非常重要的知识点，在学习Spring 框架时，Bean的初始化用到了反射，在破坏单例模式时也用到了反射，在获取标注的注解时也会用到反射&amp;amp;#183;&amp;amp;#183;&amp;amp;#18</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/13551797.html</dc:identifier>
</item>
<item>
<title>精讲响应式WebClient第5篇-请求超时设置与异常处理 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13551783.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13551783.html</guid>
<description>&lt;p&gt;本文是精讲响应式WebClient第5篇，前篇的blog访问地址如下：&lt;/p&gt;
&lt;p&gt;本文来为大家介绍一下，当WebClient请求发生异常的时候，该如何处理。为了讲解异常处理，我们需要先制造出异常，所以我们先为大家介绍：请求超时时长的设置。&lt;/p&gt;
&lt;h2 id=&quot;一、请求超时时长的设置&quot;&gt;一、请求超时时长的设置&lt;/h2&gt;
&lt;p&gt;要想模拟超时异常，我们首先要知道超时时长的正常配置渠道是怎么样的。如下文代码所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ChannelOption.CONNECT_TIMEOUT_MILLIS&lt;/code&gt;用来设置连接超时时长,单位是毫秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReadTimeoutHandler(5000, TimeUnit.MILLISECONDS)&lt;/code&gt;用来设置读数据超时时长,单位是毫秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WriteTimeoutHandler(5000, TimeUnit.MILLISECONDS)&lt;/code&gt;用来设置写数据超时时长,单位是毫秒&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//初始化一个WebClient
private WebClient getWebClient(){
   TcpClient tcpClient = TcpClient
               .create()
               .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)
               .doOnConnected(connection -&amp;gt; {
                  connection.addHandlerLast(new ReadTimeoutHandler(5000, TimeUnit.MILLISECONDS));
                  connection.addHandlerLast(new WriteTimeoutHandler(5000, TimeUnit.MILLISECONDS));
               });

   return WebClient.builder()
               .baseUrl(&quot;http://jsonplaceholder.typicode.com&quot;)
               .clientConnector(new ReactorClientHttpConnector(HttpClient.from(tcpClient)))
               .build();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们把连接超时时长设置为5(毫秒)的时候，则连接肯定会超时。随便发送一个请求，超时之后会抛出ConnectTimeoutException&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200824070203846-1695770937.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们把读数据超市时长设置为5(毫秒)的时候，则数据读操作肯定会超时。随便发送一个请求，超时之后会抛出ReadTimeoutException&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200824070204108-971232027.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、处理特定的异常&quot;&gt;二、处理特定的异常&lt;/h2&gt;
&lt;p&gt;下面我们就以ConnectTimeoutException为例，进行异常处理&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//制造异常，将超时时间设置为5毫秒
.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行下面的GET请求，上文WebClient的baseurl为：&quot;&lt;a href=&quot;http://jsonplaceholder.typicode.com&quot;&gt;http://jsonplaceholder.typicode.com&lt;/a&gt;&quot; ，该网站是一个免费提供HTTP服务端测试的网站。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
public void testSimple() throws Exception {
   Mono&amp;lt;String&amp;gt; mono = getWebClient()
               .get()    // 发送GET 请求
               .uri(&quot;/posts/1&quot;)  //服务请求路径，基于baseurl
               .retrieve() // 获取响应体
               .bodyToMono(String.class) //响应数据类型转换
                //进行异常处理
               .doOnError(ConnectTimeoutException.class, err -&amp;gt; {
                  System.out.println(&quot;发生错误：&quot; +err.getMessage() );
               });
   System.out.println(mono.block());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上文中的doOnError是我们本节为大家介绍的异常处理方法，用于处理ConnectTimeoutException，输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200824070204347-1466195768.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从输出结果上看：一：异常得到处理，因为看到了System.out打印日志。二是异常仍然被抛出了，没有得到返回值。&lt;/p&gt;
&lt;h2 id=&quot;三、请求异常给出默认返回值&quot;&gt;三、请求异常给出默认返回值&lt;/h2&gt;
&lt;p&gt;从第二小节中的代码及控制台输出，可以看出HTTP 客户端请求没有得到返回值，而是继续把异常对外抛出。假如我们目前的需求是，不论请求成功失败，都给客户端一个返回值，该怎么做？也就是说我们需要在请求发生异常的时候，给出默认返回值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
public void testReturn() throws Exception {
   Mono&amp;lt;String&amp;gt; mono = getWebClient()
               .get()    // 发送GET 请求
               .uri(&quot;/posts/1&quot;)  //服务请求路径，基于baseurl
               .retrieve() // 获取响应体
               .bodyToMono(String.class) //响应数据类型转换
               .doOnError(ConnectTimeoutException.class, err -&amp;gt; {
                  System.out.println(&quot;发生错误：&quot; +err.getMessage() );
               })
               .onErrorReturn(&quot;请求发生异常，请检查！&quot;);
   System.out.println(mono.block());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;onErrorReturn();&lt;/code&gt;给出请求的默认返回值，输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200824070204686-1241751080.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到请求测试用例成功pass了，因为我们给出了异常处理的默认返回值，没有把异常继续抛出。&lt;/p&gt;
&lt;h2 id=&quot;四、分类异常处理&quot;&gt;四、分类异常处理&lt;/h2&gt;
&lt;p&gt;上面的异常处理方法，只能处理指定的某种异常：ConnectTimeoutException。如果说我们想让异常处理相对通用一些该怎么办？有的小伙伴可能会想到拦截异常的父类Exception，当然这也是一种办法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.doOnError(Exception.class, err -&amp;gt; {
   System.out.println(&quot;发生错误：&quot; +err.getMessage() );
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们下面为大家介绍一种，针对HTTP 响应异常处理更友好的一种方式。通常来说，异常可以分为两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一种是客户端输入或访问异常，比如：访问的资源不存在404，没有权限访问资源403，输入的数据不符合格式等等。这种异常通常是用户访问了不该访问的资源，或者输入了不该输入的数据导致的。通常用HTTP状态码表示在400-499范围内。&lt;/li&gt;
&lt;li&gt;另一种是服务端内部错误，比如：500服务内部错误、502网关错误等等。这种异常通常和用户没什么关系，是IT基础设施或者编程导致的异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以我们只需要针对上面的两类异常进行处理即可。如下文代码所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;e.is4xxClientError()表示的是400-499状态码段的异常&lt;/li&gt;
&lt;li&gt;e.is5xxClientError()表示的是500-599状态码段的异常&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public void testSimple2() throws Exception {
   Mono&amp;lt;String&amp;gt; mono = getWebClient()
               .get()    // 发送GET 请求
               .uri(&quot;/postss/1&quot;)  //服务请求路径，基于baseurl
               .retrieve() // 获取响应体
               .onStatus(e -&amp;gt; e.is4xxClientError(), resp -&amp;gt; {
                  System.out.println(&quot;发生客户端输入错误：&quot; + resp.statusCode().value() + &quot; &quot;
                              + resp.statusCode().getReasonPhrase());
                  return Mono.error(new RuntimeException(&quot;请求失败&quot;));
               })
               .onStatus(e -&amp;gt; e.is5xxServerError(), resp -&amp;gt; {
                  System.out.println(&quot;发生服务端错误：&quot; + resp.statusCode().value() + &quot; &quot;
                              + resp.statusCode().getReasonPhrase());
                  return Mono.error(new RuntimeException(&quot;服务器异常&quot;));
               })
               .bodyToMono(String.class); //响应数据类型转换
   System.out.println(mono.block());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们将请求地址由正确的&quot;/posts/1&quot;，改成错误的&quot;/postss/1&quot;，所以当我们访问服务端的时候，服务端并不存在这个资源。异常处理的输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200824070204918-1306589683.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Sun, 23 Aug 2020 23:02:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本文是精讲响应式WebClient第5篇，前篇的blog访问地址如下： 精讲响应式webclient第1篇-响应式非阻塞IO与基础用法 精讲响应式WebClient第2篇-GET请求阻塞与非阻塞调用方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13551783.html</dc:identifier>
</item>
<item>
<title>程序员深夜惨遭老婆鄙视，原因竟是CAS原理太简单？| 每一张图都力求精美 - 悟空聊架构</title>
<link>http://www.cnblogs.com/jackson0714/p/CAS.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackson0714/p/CAS.html</guid>
<description>&lt;p&gt;夜黑风高的晚上，一名苦逼程序员正在疯狂敲着键盘，突然他老婆带着一副睡眼朦胧的眼神瞟了下电脑桌面。于是有了如下对话：&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;206&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;悟空&lt;/code&gt;&lt;br/&gt;种树比较好的时间是十年前，其次是现在。&lt;br/&gt;自主开发了Java学习平台、PMP刷题小程序。目前主修&lt;code&gt;Java&lt;/code&gt;、&lt;code&gt;多线程&lt;/code&gt;、&lt;code&gt;SpringBoot&lt;/code&gt;、&lt;code&gt;SpringCloud&lt;/code&gt;、&lt;code&gt;k8s&lt;/code&gt;。&lt;br/&gt;本公众号不限于分享技术，也会分享工具的使用、人生感悟、读书总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;夜黑风高的晚上，一名苦逼程序员正在疯狂敲着键盘，突然他老婆带着一副睡眼朦胧的眼神瞟了下电脑桌面。于是有了如下对话：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;老婆：这画的图是啥意思，怎么还有三角形，四边形？&lt;/p&gt;
&lt;p&gt;我：我在画CAS的原理，要不我跟你讲一遍？&lt;/p&gt;
&lt;p&gt;老婆：好呀！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200819/QrgY3SbBks2v.png?imageslim&quot; alt=&quot;请开始你的表演&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;案例：甲看见一个三角形积木，觉得不好看，想替换成五边形，但是乙想把积木替换成四边形。（前提条件，只能被替换一次）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200818/OEvyi3KQE95G.png?imageslim&quot; alt=&quot;案例&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;甲比较鸡贼，想到了一个办法：“我把积木带到另外一个房间里面去替换，并上锁，就不会被别人打扰了。”（这里用到了&lt;code&gt;排他锁synchronized&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;乙觉得甲太不厚道：“房间上了锁，我进不去，我也看不见积木长啥样。（因上了锁，所以不能访问）”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200818/zp0QVrLMySPu.png?imageslim&quot; alt=&quot;甲把房间锁住了&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是甲、乙想到了另外一个办法：&lt;strong&gt;谁先抢到积木，谁先替换，如果积木形状变了，则不允许其他人再次替换&lt;/strong&gt;。（&lt;code&gt;比较并替换CAS&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;于是他们就开始抢三角形积木：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;场景1：&lt;code&gt;甲抢到，替换成五边形，乙不能替换&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;假如甲先抢到了，积木还是三角形的，就把三角形替换成五边形了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200819/PrE1uNFiib8y.png?imageslim&quot; alt=&quot;甲先抢到，替换成五边形&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;场景2：&lt;code&gt;乙抢到未替换，甲替换成功&lt;/code&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;假如乙先抢到了，但是突然觉得三角形也挺好看的，没有替换，放下积木就走开了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;然后甲抢到了积木，积木还是三角形的，想到乙没有替换，就把三角形替换成五边形了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200818/HzprJycWtrux.png?imageslim&quot; alt=&quot;乙抢到未替换，甲替换成功&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;场景3：&lt;code&gt;乙抢到，替换成三角形，甲替换成五边形，ABA问题&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;假如乙先抢到了，但是觉得这个三角形是旧的，就换了另外一个一摸一样的三角形，只是积木比较新。&lt;/li&gt;
&lt;li&gt;然后甲抢到了积木，积木还是三角形的，想到乙没有替换，就把三角形替换成五边形了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200819/hC9pmBC6olW7.png?imageslim&quot; alt=&quot;乙抢到，替换成三角形，甲替换成五边形，ABA问题&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;老婆听完后，觉得这三种场景都太简单了，&lt;strong&gt;原来计算机这么简单，早知道我也去学计算机&lt;/strong&gt;。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200819/OuWkYsoSzQMe.png?imageslim&quot; alt=&quot;mark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;被无情鄙视了，好在老婆居然听懂了，不知道大家听懂没？&lt;/p&gt;
&lt;p&gt;回归正传，我们用计算机术语来讲下Java CAS的原理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CAS的全称：&lt;/strong&gt;Compare-And-Swap（比较并交换）。比较变量的现在值与之前的值是否一致，若一致则替换，否则不替换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAS的作用：&lt;/strong&gt;原子性更新变量值，保证线程安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAS指令：&lt;/strong&gt;需要有三个操作数，变量的当前值（V），旧的预期值（A），准备设置的新值（B）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAS指令执行条件：&lt;/strong&gt;当且仅当V=A时，处理器才会设置V=B，否则不执行更新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAS的返回指：&lt;/strong&gt;V的之前值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAS处理过程：&lt;/strong&gt;原子操作，执行期间不会被其他线程中断，线程安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CAS并发原语：&lt;/strong&gt;体现在Java语言中sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，这是一种完全依赖于硬件的功能，通过它实现了原子操作。由于CAS是一种系统原语，原语属于操作系统用于范畴，是由&lt;code&gt;若干条指令&lt;/code&gt;组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，所以CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题，所以CAS是线程安全的。&lt;/p&gt;

&lt;p&gt;在上篇讲volatile时，讲到了如何使用原子整型类AtomicInteger来解决volatile的非原子性问题，保证多个线程执行num++的操作，最终执行的结果与单线程一致，输出结果为20000。&lt;/p&gt;
&lt;p&gt;这次我们还是用AtomicInteger。&lt;/p&gt;
&lt;p&gt;首先定义atomicInteger变量的初始值等于10，主内存中的值设置为10&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;AtomicInteger atomicInteger = new AtomicInteger(10);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后调用atomicInteger的CAS方法，先比较当前变量atomicInteger的值是否是10，如果是，则将变量的值设置为20&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;atomicInteger.compareAndSet(10, 20);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置成功，atomicInteger更新为20&lt;/p&gt;
&lt;p&gt;当我们再次调用atomicInteger的CAS方法，先比较当前变量atomicInteger的值是否是10，如果是，则将变量的值设置为30&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;atomicInteger.compareAndSet(10, 30);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置失败，因atomicInteger的当前值为20，而比较值是10，&lt;strong&gt;所以比较后，不相等，故不能进行更新&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.jackson0714.passjava.threads;
import java.util.concurrent.atomic.AtomicInteger;
/**
 演示CAS compareAndSet 比较并交换
 * @author: 悟空聊架构
 * @create: 2020-08-17
 */
public class CASDemo {
    public static void  main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(10);
        Boolean result1 = atomicInteger.compareAndSet(10,20);
        System.out.printf(&quot;当前atomicInteger变量的值:%d 比较结果%s\r\n&quot;, atomicInteger.get(), result1);
        Boolean result2 = atomicInteger.compareAndSet(10,30);
        System.out.printf(&quot;当前atomicInteger变量的值:%d, 比较结果%s\n&quot; , atomicInteger.get(), result2);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;当前atomicInteger变量的值:20 比较结果true
当前atomicInteger变量的值:20, 比较结果false
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200818/0bMPvFoWDkew.png?imageslim&quot; alt=&quot;atomicInteger比较并交换的示例结果&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来对比看下原理图理解下上面代码的过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步：线程1和线程2都有主内存中变量的拷贝，值都等于10&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200819/XNCblvAWCr3w.png?imageslim&quot; alt=&quot;mark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第二步：线程1想要将值更新为20，先要将工作内存中的变量值与主内存中的变量进行比较，值都等于10，所以可以将主内存中的值替换成20&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200819/lqJdYaKuklVl.png?imageslim&quot; alt=&quot;mark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第三步：线程1将主内存中的值替换成20，并将线程1中的工作内存中的副本更新为20&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200819/i8Fv62wVF14v.png?imageslim&quot; alt=&quot;mark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第四步：线程2想要将变量更新为30，先要将线程2的工作内存中的值与主内存进行比较10不等于20，所以不能更新&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200819/rpb0rUGrrHJk.png?imageslim&quot; alt=&quot;mark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第五步：线程2将工作内存的副本更新为与主内存一致：20&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200819/11Np54tAbYk5.png?imageslim&quot; alt=&quot;mark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图画得非常棒！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200819/lvuvw7hiOURc.png?imageslim&quot; alt=&quot;mark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述的场景和我们用Git代码管理工具是一样的，如果有人先提交了代码到develop分支，另外一个人想要改这个地方的代码，就得先pull develop分支，以免提交时提示冲突。&lt;/p&gt;

&lt;h2 id=&quot;源码调试&quot;&gt;源码调试&lt;/h2&gt;
&lt;p&gt;这里我们用atomicInteger的getAndIncrement()方法来讲解，这个方法里面涉及到了比较并替换的原理。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void  main(String[] args) throws InterruptedException {
    AtomicInteger atomicInteger = new AtomicInteger(10);
    Thread.sleep(100);

    new Thread(() -&amp;gt; {
        atomicInteger.getAndIncrement();
    }, &quot;aaa&quot;).start();

    atomicInteger.getAndIncrement();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;（1）首先需要开启IDEA的多线程调试模式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;（2）我们先打断点到17行，main线程执行到此行，子线程&lt;code&gt;aaa&lt;/code&gt;还未执行自增操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200820/AQswHVY8bOw9.png?imageslim&quot; alt=&quot;mark&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;getAndIncrement方法会调用unsafe的&lt;code&gt;getAndAddInt&lt;/code&gt;方法，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;（3）在源码&lt;code&gt;getAndAddInt&lt;/code&gt;方法的361行打上断点，main线程先执行到361行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final int getAndAddInt(Object var1, long var2, int var4) {
        int var5;
        do {
                var5 = this.getIntVolatile(var1, var2);
        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
        return var5;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;源码解释：&lt;/strong&gt; &lt;u&gt;&lt;em&gt;划重点！！！&lt;/em&gt;&lt;/u&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;var1：当前对象，我们定义的atomicInteger&lt;/li&gt;
&lt;li&gt;var2：当前对象的内存偏移量&lt;/li&gt;
&lt;li&gt;var4：当前自增多少，默认为1，且不可设为其他值&lt;/li&gt;
&lt;li&gt;var5：当前变量的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;this.getIntVolatile(var1, var2)&lt;/code&gt;：根据当前对象var1和对象的内存偏移量var2得到主内存中变量的值，赋值给var5，并在main线程的工作内存中存放一份var5的副本&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200820/w4Pbmh2KKIBu.png?imageslim&quot; alt=&quot;1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;（4）在362行打上断点，main线程继续执行一步&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;var5获取到主内存中的值为10&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200820/Gt3sSVnLxYBa.png?imageslim&quot; alt=&quot;2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;（5）切换到子线程aaa，还是在361行断点处，还未获取主内存的值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200820/SecJqDjHaLe9.png?imageslim&quot; alt=&quot;3&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;（6）子线程aaa继续执行一步，获取到var5的值等于10&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200820/vdvPqeVu9sGF.png?imageslim&quot; alt=&quot;4&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（7）切换到main线程，进行比较并替换&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;this.compareAndSwapInt(var1, var2, var5, var5 + var4)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;var5=10，通过var1和var2获取到的值也是10，因为没有其他线程修改变量。compareAndSwapInt的源码我们后面再说。&lt;/p&gt;
&lt;p&gt;所以比较后，发现变量没被其他线程修改，可以进行替换，替换值为var5+var4=11，变量值替换后为 11，也就是自增1。这行代码执行结果返回true（自增成功），退出do while循环。return值为变量更新前的值10。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200820/mqLNonLDmpm5.png?imageslim&quot; alt=&quot;5&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（8）切换到子线程aaa，进行比较并自增&lt;/p&gt;
&lt;p&gt;因为此时aaa线程的var5=10，而主内存中的值已经更新为11了，所以比较后发现被其他线程修改了，不能进行替换，返回false，继续执行do while循环。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200820/5jzAQ3Xy22eL.png?imageslim&quot; alt=&quot;6&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（9）子线程aaa继续执行，重新获取到的var=11&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200820/yqEqKOH3JKFl.png?imageslim&quot; alt=&quot;7&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;（10）子线程aaa继续执行，进行比较和替换，结果为true&lt;/p&gt;
&lt;p&gt;因var5=11，主内存中的变量值也等于11，所以比较后相等，可以进行替换，替换值为var5+var4，结果为12，也就是自增1。退出循环，返回变量更新前的值var5=11。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200820/zx1kGeVHR834.png?imageslim&quot; alt=&quot;8&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，getAndIncrement方法的整个原子自增的逻辑就debug完了。所以可以得出结论：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;先比较线程中的副本是否与主内存相等，相等则可以进行自增，并返回副本的值，若其他线程修改了主内存中的值，当前线程不能进行自增，需要重新获取主内存的值，然后再次判断是否与主内存中的值是否相等，以此往复。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不知道大家发现没，aaa线程可能会出现循环多次的问题，因为其他线程可能将主内存的值又改了，但是aaa线程拿到的还是老的数据，就会出现再循环一次，就会给CPU带来性能开销。这个就是&lt;code&gt;自旋&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;频繁出现自旋，循环时间长，开销大&lt;/code&gt;（因为执行的是do while，如果比较不成功一直在循环，最差的情况，就是某个线程一直取到的值和预期值都不一样，这样就会无限循环）&lt;/li&gt;
&lt;li&gt;只能保证&lt;code&gt;一个&lt;/code&gt;共享变量的原子操作
&lt;ul&gt;&lt;li&gt;当对&lt;code&gt;一个&lt;/code&gt;共享变量执行操作时，我们可以通过循环CAS的方式来保证原子操作&lt;/li&gt;
&lt;li&gt;但是对于&lt;code&gt;多个&lt;/code&gt;共享变量操作时，循环CAS就无法保证操作的原子性，这个时候只能用锁来保证原子性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;引出来ABA问题（有彩蛋）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇从和老婆的对话开始，以通俗的语言给老婆讲了CAS问题，其中还涉及到了并发锁。然后从底层代码一步一步debug，深入理解了CAS的原理。&lt;/p&gt;
&lt;p&gt;每一张图都力求精美！分享+在看啊，大佬们！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;彩蛋：&lt;/strong&gt;还有一个ABA问题没有给大家讲，另外这里怎么不是AAB（拖拉机），AAA（金花）？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200821/b5JUIpeSuH7E.png?imageslim&quot; alt=&quot;4个A&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这周前三天写技术文章花了大量时间，少熬夜，睡觉啦 ~ 我们下期再来讲ABA问题，小伙伴们分享转发下好吗？您的支持是我写作最大的动力~&lt;/p&gt;
&lt;p&gt;&lt;u&gt;悟空，一只努力变强的码农！我要变身超级赛亚人啦！&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200821/wp5kwn5UEWaJ.png?imageslim&quot; alt=&quot;悟空&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jayh.club/blog/20200824/085127482.png&quot; alt=&quot;公众号&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 23 Aug 2020 22:50:00 +0000</pubDate>
<dc:creator>悟空聊架构</dc:creator>
<og:description>夜黑风高的晚上，一名苦逼程序员正在疯狂敲着键盘，突然他老婆带着一副睡眼朦胧的眼神瞟了下电脑桌面。于是有了如下对话：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jackson0714/p/CAS.html</dc:identifier>
</item>
<item>
<title>从两周发布上线到一周发布上线，如何做到高效稳定？ - 宝玉</title>
<link>http://www.cnblogs.com/dotey/p/13551772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotey/p/13551772.html</guid>
<description>&lt;p&gt;早些年开发软件，一个版本发布上线的时间周期是以“月”甚至“年”为单位计的，但是现在随着敏捷开发的推行和普及，版本上线的周期变成了“周”为单位，甚至更短。周期缩短，并不意味着要牺牲质量，而是一样会有完善的开发流程来保障质量，比如设计、开发、自动化测试和手工测试。但是当缩短开发周期的时候，可能原本运行好好的开发流程就会出问题，软件质量下降，需要去重新调整开发流程，以重新做到高效和稳定。&lt;/p&gt;
&lt;p&gt;在这里将向您分享一下我所在团队的经历，我们从两周一个发布周期，到每周一个发布周期，都遇到了什么问题和挑战，最终如何克服和解决的。希望能对您有所帮助启发。&lt;/p&gt;
&lt;h2 id=&quot;在两周一个版本的迭代中，我们是进行项目开发的？&quot;&gt;在两周一个版本的迭代中，我们是进行项目开发的？&lt;/h2&gt;
&lt;h3 id=&quot;开发流程&quot;&gt;开发流程&lt;/h3&gt;
&lt;p&gt;在这里先简单介绍一下，我们两周一个Sprint的开发流程是什么样的。整个开发流程如图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/564/202008/564-20200824060754394-593313494.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sprint计划和部署上一版本到生产环境&lt;/strong&gt;&lt;br/&gt;每个Sprint开始前，会先有一个计划会议，规划好当前Sprint 要完成的新功能和要修复的Bug，这些任务都在Jira上用一条条Ticket记录和跟踪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码和分支管理&lt;/strong&gt;&lt;br/&gt;在计划好了后，紧接着是一整周的开发编码，这期间会对计划好的Tickets进行编码。我们是基于分支开发的，在开发一个Ticket之前会创建一个新的分支，开发完成后将分支代码提交PR，代码审核通过以及自动化测试完成后合并到git的master分支。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;br/&gt;在一周的开发编码完成后，就会基于master的最新代码创建tag，并发布到测试环境。QA人员会对发布的功能进行自动化测试和手工测试，发现的bug会提交ticket进行跟踪。开发人员会对报的bug进行修复，修复bug的代码会继续合并到master。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码冻结&lt;/strong&gt;&lt;br/&gt;由于我们要部署的代码都在master上，如果master持续的合并代码会不太稳定，所以在Sprint最后两天会对master的代码冻结，除非重要的bug修复，否则新的PR不合并，等到下一个Sprint开始再统一合并。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部署生产环境&lt;/strong&gt;&lt;br/&gt;在测试结束后，我们会根据版本创建release tag，这样根据tag就可以部署对应的版本到生产环境。&lt;/p&gt;
&lt;h3 id=&quot;两周sprint的优缺点&quot;&gt;两周Sprint的优缺点&lt;/h3&gt;
&lt;p&gt;这样两周一个Sprint的周期在执行的时候还算比较顺利，上线的版本由于测试较为充分，所以比较稳定。但缺点就是两周才能发布一个新的版本，响应需求的速度较慢；两周一个版本，由于更新的代码较多，在上线后出现问题也不容易定位。&lt;/p&gt;
&lt;p&gt;其实上面的开发流程还有一个问题，只是由于两周一个迭代，并没有暴露出来。这个稍后再讨论。&lt;/p&gt;
&lt;h2 id=&quot;在一周一个版本的迭代中，我们是进行项目开发的？&quot;&gt;在一周一个版本的迭代中，我们是进行项目开发的？&lt;/h2&gt;
&lt;p&gt;正是基于两周Sprint的一些问题，我们决定改成一周一个Sprint，这样就可以更高频率的发布新版本；发布的版本变更较小，有问题也能及时定位和发现。&lt;/p&gt;
&lt;p&gt;在最开始的时候，一周一个Sprint的开发流程和之前两周一个Sprint的开发模式类似，只是把相应的开发和测试时间缩短了。如图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/564/202008/564-20200824060815083-194559070.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;改成一周一个sprint后遇到的问题和挑战&quot;&gt;改成一周一个Sprint后遇到的问题和挑战&lt;/h3&gt;
&lt;p&gt;但在变成一个周一个Sprint后，我们很快发现版本质量下降了，经常在上线后发现严重的问题而需要回滚或者打补丁。&lt;/p&gt;
&lt;p&gt;于是在一次Retro会议（项目回顾会议）上，我们的QA提出了一个建议：“Avoid last minute change”。背景是我们的服务刚刚有过一次生产环境故障，故障的原因是因为开发在上线前有过一些改动，原以为改动很小，不会有问题，Code Review没发现问题，部署到测试环境简单测试后，也没发现问题。结果部署上生产环境后，出现严重的问题。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/564/202008/564-20200824060945073-193467030.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是个很好的建议，然而我们能避免上线前临时修改吗？避免了上线前的临时修改服务就会稳定吗？&lt;/p&gt;
&lt;p&gt;在接下来的时间里，我们努力避免上线前的临时修改，上线前的修改需要更严格的代码审查流程，然而想完全避免上线前的临时修改是几乎不可能的，总有一些上线前才发现的问题需要修复。&lt;/p&gt;
&lt;p&gt;那么在减少了上线前的临时修改后，我们的服务更稳定了吗？&lt;/p&gt;
&lt;p&gt;有一点改善，但并没有完全解决，服务还是不太稳定，而且很多服务器故障并不是由于上线前的临时修改导致的！&lt;/p&gt;
&lt;p&gt;这就说明上线前的临时修改并不是导致服务不稳定的根本原因，那么到底是什么原因导致的服务不稳定？&lt;/p&gt;
&lt;p&gt;于是我们又尝试了一些探索和改进，比如说增加更多的自动化测试、上线后对主要功能做一些手动的检查。这些方法都有一点效果，但都属于治标不治本的措施，服务还是不算稳定。&lt;/p&gt;
&lt;h3 id=&quot;是什么原因让服务不稳定&quot;&gt;是什么原因让服务不稳定&lt;/h3&gt;
&lt;p&gt;对于这个问题我一直没有答案，直到几个月后，又一年的“Holiday Readiness”，也就是美国的购物季，从万圣节开始一直持续到新年，商家有各种促销打折活动，民众也是各种买买买。这期间对于我们这种线上消费类网站来说，稳定性要求特别高，当机一点点时间都可能造成巨大损失。&lt;/p&gt;
&lt;p&gt;如何保证服务的稳定呢？根据我们过去几年的血泪教训中总结出来的经验，保证服务稳定的最简单有效的措施就是：&lt;strong&gt;节日期间不更新，除非必要的小更新和补丁！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以在消费季，我们会实行“Soft/Hard Moratorium”，也就是“Holiday Readiness”期间，我们不上线新功能，只做必要的补丁更新以修复一些严重的线上故障。并且上线需要有严格的审批流程。&lt;/p&gt;
&lt;p&gt;为了应对公司的“Soft/Hard Moratorium”策略，我们组也做了一些调整：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先我们创建了一个holiday的branch分支，这个分支只修复生产环境的Bug或者必须的新功能更新。其他常规的开发依然放在master主分支。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;然后每次holiday分支的修改在部署生产环境前，都预先在测试环境测试一周左右时间，测试没问题后再部署生产环境。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样实施下来，在“Holiday Readiness”结束的时候，我发现我们的服务异常的稳定，虽然有过数次更新，但是一次故障都没有发生。这给我很多启示，让我意识到之前服务之所以一直不稳定，有两个主要原因：&lt;/p&gt;
&lt;h4 id=&quot;原因一：没有一个稳定的可随时发布的分支&quot;&gt;原因一：没有一个稳定的可随时发布的分支&lt;/h4&gt;
&lt;p&gt;首先，我们的版本发布是基于master分支发布的，新功能和Bug修复的PR都会合并到master，这就意味着master分支一直是不稳定的。&lt;/p&gt;
&lt;p&gt;在以前每两周一个Sprint的时候，这个问题就存在，只是当时因为测试时间更长，所以没有暴露出来。当改成每周一个Sprint后，这个问题就很严重了，导致了很多上线前的临时修改。&lt;/p&gt;
&lt;p&gt;在“Holiday Readiness”期间，我们有一个稳定的holiday分支，这个分支只有bug修复，几乎没有新功能的代码，所以相对要稳定很多。&lt;/p&gt;
&lt;h4 id=&quot;原因二：测试时间不够充分&quot;&gt;原因二：测试时间不够充分&lt;/h4&gt;
&lt;p&gt;在以前每两周一个Sprint的时候，我们有3-5天的时间测试，有大的问题问题基本上能在测试环境发现，当改成每周一个Sprint后，留给测试的时间只有1-2天，这点时间是很难充分测试的，所以很多问题要在上线后才暴露出来。&lt;/p&gt;
&lt;p&gt;在“Holiday Readiness”期间，在每次代码修改后发布前，在测试环境都会有一周左右的测试时间，这样Bug就能得到充分的暴露，而不至于到生产环境才发现，而导致回滚或者补丁。&lt;/p&gt;
&lt;h2 id=&quot;怎么改善发布流程？&quot;&gt;怎么改善发布流程？&lt;/h2&gt;
&lt;p&gt;既然已经发现了问题所在，怎么去改进就相对容易了。所以我针对当前流程提出了一些改进的建议。&lt;/p&gt;
&lt;h3 id=&quot;每个sprint对应一个稳定的分支&quot;&gt;每个Sprint对应一个稳定的分支&lt;/h3&gt;
&lt;p&gt;对于没有稳定分支的问题，很好解决，那就是在每次Sprint完成，我们都创建一个对应的Release分支，Release分支创建好后，类似于我们之前在holiday分支做的那样，只做Bug修复，不增加新功能代码。&lt;/p&gt;
&lt;p&gt;对于前面说到的上线前临时修改，如果是紧急Bug更新，那么放到Release分支，如果是其他的，则只合并到master分支，不会影响到release分支。&lt;/p&gt;
&lt;h3 id=&quot;给测试留足时间&quot;&gt;给测试留足时间&lt;/h3&gt;
&lt;p&gt;对于测试时间不够的问题，一个简单可行的方案就是回到两周一个Sprint的开发方式。但是大家已经习惯了一周一个Sprint的节奏，尤其是产品经理，希望新功能能尽早上线，更喜欢保持一周一个Sprint。&lt;/p&gt;
&lt;p&gt;那么怎样在一周一个Sprint的情况下，保证有充足的时间测试呢？&lt;/p&gt;
&lt;p&gt;于是我提出了一个简单可行的方案：在“Holiday Readiness”结束后，推迟第一个Sprint的上线时间一周。&lt;/p&gt;
&lt;p&gt;具体做法是：我们的第一个Sprint完成后，不上线生产环境，在测试环境保留一周，同时开始第二个Sprint的开发，等到第二个Sprint开发完成后，上线第一个Sprint的版本，第二个Sprint的版本发布到测试环境测试一周，同时开始第三个Sprint的开发。&lt;/p&gt;
&lt;p&gt;如图所示&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/564/202008/564-20200824060825228-386419606.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就意味着我们每一个Sprint开发完成，有完整的一周时间进行测试和Bug修复，但我们还是可以每周一个版本部署生产环境。&lt;/p&gt;
&lt;p&gt;经过这样的调整后，我们的服务马上就稳定下来了，基本上不用担心发布后会有严重的质量问题，也极少需要上线后回滚或补丁。&lt;/p&gt;
&lt;p&gt;当然这样调整后，也带来一些小的问题：&lt;/p&gt;
&lt;h4 id=&quot;问题一：有两个sprint在并行&quot;&gt;问题一：有两个Sprint在并行&lt;/h4&gt;
&lt;p&gt;在当前Sprint开发的同时，还要对上一个Sprint的Bug进行修复。但一般Bug的修复都比较简单，这样并行并没有带来太多的问题，我们的开发人员对这种模式适应的很好。&lt;/p&gt;
&lt;h3 id=&quot;问题二：多分支管理&quot;&gt;问题二：多分支管理&lt;/h3&gt;
&lt;p&gt;由于每个Sprint都会创建一个分支，那么意味着修复一个Bug，有可能要将修改同时合并到多个分支。&lt;/p&gt;
&lt;p&gt;举例来说，在生产环境发现一个问题需要打补丁，那么这个PR要合并到生产环境版本对应的分支，还要合并到测试环境版本对应的分支，最后还要合并到master；如果在测试环境发现的Bug，需要同时合并到测试环境版本对应的分支和master。&lt;/p&gt;
&lt;p&gt;不过相对于稳定性带来的提升，这一点不便还是完全可以接受的。&lt;/p&gt;
&lt;h3 id=&quot;问题三：开发过程不易理解&quot;&gt;问题三：开发过程不易理解&lt;/h3&gt;
&lt;p&gt;这个开发模式在我们组内部运行的很好，但是对于组外的人来说，不是很容易理解，对于他们来说，最关心的是：我的需求或者PR什么时候能部署到测试环境，什么时候能部署到生产环境。&lt;/p&gt;
&lt;p&gt;于是我们开发了几个工具，可以直观的知道当前开发中的是在哪个版本，测试环境是哪个版本，生产环境是哪个版本。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/564/202008/564-20200824061100322-951459157.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;(电视投影)&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/564/202008/564-20200824061159063-346261013.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配合这样的小工具，无论是组内还是组外，都可以很直观的了解当前的开发状态了。&lt;/p&gt;
&lt;p&gt;总的来说，新的开发流程实行后，虽然存在一些小的麻烦，但是运行的很不错，服务的稳定性大幅提升。release分支让我们有一个随时可以发布的稳定版本；一周的测试时间可以很好的保证质量；同时每周一个版本的发布频率也可以让我们及时响应需求，有问题能及时发现。&lt;/p&gt;
&lt;h3 id=&quot;chrome的开发流程&quot;&gt;Chrome的开发流程&lt;/h3&gt;
&lt;p&gt;无独有偶，后来我发现Chrome的开发流程，和我们现在的这套开发流程很类似，它是6周的开发流程，其中上一个版本的测试和当前版本的开发也是重叠的。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/564/202008/564-20200824061228810-1289832456.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;a href=&quot;https://chromium.googlesource.com/chromium/src/+/master/docs/process/release_cycle.md&quot;&gt;Chrome Release Cycle&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;软件工程中没有银弹，不可能有一种开发模式适用于所有的软件项目。当项目发生变化时，以前一些运行的很好的开发模式可能渐渐的不适合了，这时候就需要先找出问题产生深层次的原因，然后对症下药，探索出适合于当前项目特点的开发模式。&lt;/p&gt;
</description>
<pubDate>Sun, 23 Aug 2020 22:14:00 +0000</pubDate>
<dc:creator>宝玉</dc:creator>
<og:description>早些年开发软件，一个版本发布上线的时间周期是以“月”甚至“年”为单位计的，但是现在随着敏捷开发的推行和普及，版本上线的周期变成了“周”为单位，甚至更短。周期缩短，并不意味着要牺牲质量，而是一样会有完善</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dotey/p/13551772.html</dc:identifier>
</item>
<item>
<title>【小白学AI】XGBoost推导详解与牛顿法 - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/13533137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/13533137.html</guid>
<description>&lt;p&gt;文章来自微信公众号：【机器学习炼丹术】&lt;/p&gt;

&lt;h2 id=&quot;1-作者前言&quot;&gt;1 作者前言&lt;/h2&gt;
&lt;p&gt;在2020年还在整理XGB的算法，其实已经有点过时了。不过，主要是为了扩大知识面和应付面试嘛。现在的大数据竞赛，XGB基本上已经全面被LGB模型取代了，这里主要是学习一下Boost算法。之前已经在其他博文中介绍了Adaboost算法和Gradient-boost算法，这篇文章讲解一下XGBoost。&lt;/p&gt;
&lt;h2 id=&quot;2-树模型概述&quot;&gt;2 树模型概述&lt;/h2&gt;
&lt;p&gt;XGB就是Extreme Gradient Boosting极限梯度提升模型。XGB简单的说是&lt;strong&gt;一组分类和回归树（CART）&lt;/strong&gt;的组合。跟GBDT和Adaboost都有异曲同工之处。&lt;br/&gt;【CART=classification adn regression trees】&lt;/p&gt;
&lt;p&gt;这里对于一个决策树，如何分裂，如何选择最优的分割点，其实就是一个搜索的过程。搜索怎么分裂，才能让目标函数最小。目标函数如下：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Obj = Loss + \Omega\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Obj\)&lt;/span&gt;就是我们要最小化的优化函数，&lt;span class=&quot;math inline&quot;&gt;\(Loss\)&lt;/span&gt;就是这个CART模型的预测结果和真实值得损失。&lt;span class=&quot;math inline&quot;&gt;\(\Omega\)&lt;/span&gt;就是这个CART模型的复杂度,类似神经网络中的正则项。&lt;br/&gt;&lt;strong&gt;【上面的公式就是一个抽象的概念。我们要知道的是：CART树模型即要求预测尽可能准确，又要求树模型不能过于复杂。】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于回归问题，我们可以用均方差来作为Loss：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Loss=\sum_i{(y_i-\hat{y_i})^2}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于分类问题，用交叉熵是非常常见的,这里用二值交叉熵作为例子：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Loss = \sum_i{(y_ilog(\hat{y_i})+(1-y_i)log(\hat{y_i}))}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;总之，这个Loss就是衡量模型预测准确度的损失。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;下面看一下如何计算这个模型复杂度&lt;span class=&quot;math inline&quot;&gt;\(\Omega\)&lt;/span&gt;吧。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Omega = \gamma T+\frac{1}{2} \lambda \sum^T_j{w_j}^2\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;表示叶子节点的数量，&lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;表示每个叶子节点上的权重（与叶子节点的样本数量成正比）。&lt;/p&gt;
&lt;p&gt;【这里有点麻烦的在于，&lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;是与每个叶子节点的样本数量成正比，但是并非是样本数量。这个&lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;的求取，要依靠与对整个目标函数求导数，然后找到每个叶子节点的权重值&lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt;。】&lt;/p&gt;
&lt;h2 id=&quot;3-xgb-vs-gbdt&quot;&gt;3 XGB vs GBDT&lt;/h2&gt;
&lt;p&gt;其实说了这么多，感觉XGB和GDBT好像区别不大啊？那是因为说了这么多还没开始说XGB呢！之前都是讲树模型的通用概念的。下面讲解XGB~整理一下网上有的说法，再加上自己的理解。有错误请指出评论，谢谢！&lt;/p&gt;
&lt;h3 id=&quot;31-区别1：自带正则项&quot;&gt;3.1 区别1：自带正则项&lt;/h3&gt;
&lt;p&gt;GDBT中，只是让新的弱分类器来拟合负梯度，那拟合多少棵树才算好呢？不知道。XGB的优化函数中，有一个&lt;span class=&quot;math inline&quot;&gt;\(\Omega\)&lt;/span&gt;复杂度。这个复杂度不是某一课CART的复杂度，而是XGB中所有CART的总复杂度。可想而知，每多一颗CART，这个复杂度就会增加他的惩罚力度，当损失下降小于复杂度上升的时候，XGB就停止了。&lt;/p&gt;
&lt;h3 id=&quot;32-区别2：有二阶导数信息&quot;&gt;3.2 区别2：有二阶导数信息&lt;/h3&gt;
&lt;p&gt;GBDT中新的CART拟合的是负梯度，也就是一阶导数。而在XGB会考虑二阶导数的信息。&lt;/p&gt;
&lt;p&gt;这里简单推导一下XGB如何用上二阶导数的信息的：&lt;/p&gt;
&lt;ol readability=&quot;12&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;之前我们得到了XGB的优化函数：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Obj = Loss + \Omega\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;然后我们把Loss和Omega写的更具体一点：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Obj = \sum_i^n{Loss(y_i,\hat{y}_i^t)}+\sum_j^t{\Omega(cart_j)}\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\hat{y_i^t}\)&lt;/span&gt;表示总共有t个CART弱分类器，然后t个弱分类器给出样本i的估计值就。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;第i个样本的真实值；&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Omega(cart_j)\)&lt;/span&gt;第j个CART模型的复杂度。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;我们现在要求取第t个CART模型的优化函数，所以目前我们只是知道前面t-1的模型。所以我们得到：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\hat{y}_i^t = \hat{y}_i^{t-1}+f_t(x_i)\)&lt;/span&gt;&lt;br/&gt;t个CART模型的预测，等于前面t-1个CART模型的预测加上第t个模型的预测。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;所以可以得到：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\sum_i^n{Loss(y_i,\hat{y}_i^t)}=\sum_i^n{Loss(y_i,\hat{y}_i^{t-1}+f_t(x_i))}\)&lt;/span&gt;&lt;br/&gt;这里考虑一下特勒展开：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f(x+\Delta x)\approx f(x)+f'(x)\Delta x + \frac{1}{2} f''(x)\Delta x^2\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;如何把泰勒公式带入呢？&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\({Loss(y_i,\hat{y}_i^t)}\)&lt;/span&gt;中的&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;其实就是常数，不是变量&lt;br/&gt;所以其实这个是可以看成&lt;span class=&quot;math inline&quot;&gt;\(Loss(\hat{y}_i^t)\)&lt;/span&gt;,也就是:&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Loss(\hat{y}_i^{t-1}+f_t(x_i))\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;带入泰勒公式，把&lt;span class=&quot;math inline&quot;&gt;\(f_t(x_i)\)&lt;/span&gt;看成&lt;span class=&quot;math inline&quot;&gt;\(\Delta x\)&lt;/span&gt;：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Loss(\hat{y}_i^{t-1}+f_t(x_i))=Loss(\hat{y}_i^{t-1})+Loss'(\hat{y}_i^{t-1})f_t(x_i)+\frac{1}{2}Loss''(\hat{y}_i^{t-1})(f_t(x_i))^2\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在很多的文章中，会用&lt;span class=&quot;math inline&quot;&gt;\(g_i=Loss'(\hat{y}_i^{t-1})\)&lt;/span&gt;,以及&lt;span class=&quot;math inline&quot;&gt;\(h_i=Loss''(\hat{y}_i^{t-1})\)&lt;/span&gt;来表示函数的一阶导数和二阶导数。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;把泰勒展开的东西带回到最开始的优化函数中，删除掉常数项&lt;span class=&quot;math inline&quot;&gt;\(Loss(\hat{y}_i^{t-1})\)&lt;/span&gt;(这个与第t个CART模型无关呀)以及前面t-1个模型的复杂度，可以得到第t个CART的优化函数：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(Obj^t \approx \sum_i^n{[g_i f_t(x_i)+\frac{1}{2}h_i(f_t(x_i))^2}]+{\Omega(cart_t)}\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;【所以XGB用到了二阶导数的信息，而GBDT只用了一阶的梯度】&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-区别3：列抽样&quot;&gt;3.3 区别3：列抽样&lt;/h3&gt;
&lt;p&gt;XGB借鉴了随机森林的做法，不仅仅支持样本抽样，还支持特征抽样（列抽样），不仅可以降低过拟合，还可以减少计算。（但是这一点我个人存疑，感觉这个只是代码给出的功能，并不算是XGB本身算法相对GBDT的优势。因为XGB和GBDT明明都可以用列抽样的方法。&lt;strong&gt;总之，最关键的区别是二阶导数那个和引入正则项&lt;/strong&gt;）&lt;/p&gt;
&lt;h2 id=&quot;4-xgb为什么用二阶导&quot;&gt;4 XGB为什么用二阶导&lt;/h2&gt;
&lt;p&gt;这个是一个关于XGB的面试进阶题。第一次看到这个问题的时候，一脸懵逼。&lt;/p&gt;
&lt;p&gt;【先说自己总结的答案】&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用了二阶导数的信息，加快了收敛速度。&lt;/li&gt;
&lt;li&gt;减少了计算量。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;41-为什么减少了计算量&quot;&gt;4.1 为什么减少了计算量&lt;/h3&gt;
&lt;p&gt;这个比较理解，就先从这个开始解释。&lt;br/&gt;在GBDT中，最花费时间的就是计算分裂点，选择哪个特征，在哪个分割点进行分裂可以得到最小的loss。假设有5个特征，每个特征有100个潜在分割点，那么分类一次需要计算500次。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(loss(y,\hat{y}^t)\)&lt;/span&gt;像之前一样，写成之前所有已经训练完成的弱分类器和正在训练的分类器&lt;span class=&quot;math inline&quot;&gt;\(loss(y,\hat{y}^{t-1}+f_t(x))\)&lt;/span&gt;&lt;br/&gt;如果计算这个损失的话，我们需要计算500次的&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(loss(y,\hat{y}^{t-1}+f_t(x))\)&lt;/span&gt;&lt;br/&gt;但是假设使用泰勒展开得到：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(loss(\hat{y}^{t-1})+g*f_t(x)+\frac{1}{2}h(f_t(x))^2\)&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;其中的&lt;span class=&quot;math inline&quot;&gt;\(loss(\hat{y}^{t-1})\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt;都是仅仅与之前已经训练完成的决策树相关，所以就是常数，所以是可以在500次的计算中共享，计算一次足以。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;42-为什么加快收敛速度&quot;&gt;4.2 为什么加快收敛速度&lt;/h3&gt;
&lt;p&gt;这里要回到泰勒展开那里：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f(x+\Delta x) = f(x) + g(x) * \Delta x + \frac{1}{2} h(x) (\Delta x)^2\)&lt;/span&gt;&lt;br/&gt;这个式子其实就可以看成是&lt;span class=&quot;math inline&quot;&gt;\(F(\Delta x)\)&lt;/span&gt;,因为&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;可以看成一个常数。我们希望&lt;span class=&quot;math inline&quot;&gt;\(F(\Delta x)\)&lt;/span&gt;最小（也就是损失最小），所以我们对&lt;span class=&quot;math inline&quot;&gt;\(\Delta x\)&lt;/span&gt;求导数：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(F'(\Delta x)=g(x)+h(x)\Delta x=0\)&lt;/span&gt;&lt;br/&gt;导数为0，则是极小值（默认是凸函数）&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta x=-\frac{g(x)}{h(x)}\)&lt;/span&gt;，也就是说，更新的步长其实就是&lt;strong&gt;一阶导数除以二阶导数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;了解最优化算法的朋友应该可以意识到，这个其实是跟牛顿法等价的。XGB每一次训练一个新的基模型，其实就是再使用牛顿法来对损失函数进行最小值的优化与更新。&lt;/p&gt;
&lt;p&gt;【小总结】&lt;br/&gt;&lt;strong&gt;因此我个人认为，使用了二阶信息的XGB比使用了一阶信息的GBDT收敛速度快的原因，可以用牛顿法比梯度下降法收敛快来解释。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【为什么牛顿法收敛速度快】&lt;br/&gt;其实这一块我有些解释不清楚了，因为我最优化算法学的也不精（好像突然发现找不到工作的原因了2333）。能给出的是一个比较通俗的解释：　&lt;strong&gt;从本质上去看，牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-牛顿法&quot;&gt;5 牛顿法&lt;/h2&gt;
&lt;p&gt;这里简单介绍一下牛顿法是什么。毕竟有的朋友可能没学过，或者学过像我一样忘记了。&lt;/p&gt;
&lt;p&gt;【牛顿法的目的】&lt;br/&gt;求解一个函数的根，也就是这个函数与x坐标轴的交点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_0a308b089d1cc9394b36227b05cb4fa2.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这里有一个三次曲线，我们初始点在A位置，然后做A位置的切线，可以发现这个切线相交于x轴。&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_89fe27669fd0844a9564deb7fcafff8d.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;然后这个焦点做一个平行于y轴的线，交于B点，然后B点做切线，然后交于x轴，然后......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_033028fd1b37bb857af15b22a0da053b.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;然后迭代到C点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_0cc516998008aab834291be2e9d8b2a9.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;慢慢的，就逼近三次函数与x轴的交点，也就是三次函数等于0的根了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/07/wp_editor_md_542cfb412baeb81a2dc8069ac4307114.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;【数学算式】&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_n\)&lt;/span&gt;点的切线方程：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f(x_n)+f'(x_n)(x-x_n)=0\)&lt;/span&gt;&lt;br/&gt;所以很简单得到：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{n+1}=x_n-\frac{f(x_n)}{f'(x_n)}\)&lt;/span&gt;&lt;br/&gt;【为什么这里只用到了一阶信息？】&lt;br/&gt;因为这里的目的是求取一个函数的根，也就是函数等于0的根。我们在最优化问题中，求解的是一个函数的极小值，这就要求求取这个函数的导数等于0的根，所以在最优化问题中，是一个二阶导数优化方法。&lt;/p&gt;
&lt;p&gt;写了4000字，太累了。欢迎大家加好友交流。&lt;/p&gt;
</description>
<pubDate>Sun, 23 Aug 2020 20:05:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>文章来自微信公众号：【机器学习炼丹术】 1 作者前言 在2020年还在整理XGB的算法，其实已经有点过时了。不过，主要是为了扩大知识面和应付面试嘛。现在的大数据竞赛，XGB基本上已经全面被LGB模型取</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/13533137.html</dc:identifier>
</item>
</channel>
</rss>