<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>机器学习（2）：简单线性回归 | 一元回归 | 损失计算 | MSE - 广州小程</title>
<link>http://www.cnblogs.com/freeself/p/10906151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeself/p/10906151.html</guid>
<description>&lt;p&gt;前文再续书接上一回，机器学习的主要目的，是根据特征进行预测。预测到的信息，叫标签。&lt;/p&gt;
&lt;p&gt;从特征映射出标签的诸多算法中，有一个简单的算法，叫简单线性回归。&lt;strong&gt;本文介绍简单线性回归的概念。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是简单线性回归&quot;&gt;（1）什么是简单线性回归&lt;/h4&gt;
&lt;p&gt;“回归（regression）”是什么？如之前所讲，预测模型可区分为“分类器”跟“回归器”，回归器，就是用来预测趋势变化的，比如预测明天哪支股会涨停，预测某天的降雨量是多少，预测未来一年房价的变化，等等。所以回归就是预测的意思，没有什么高深的。线性是什么意思？就是一条直线，够简单了吧，自然也有“非线性回归”。那“简单”是什么意思，就是只有一个变量的，也叫一元回归，如果是多个变量（拟合面），那就叫多元回归（自然不再是简单线性）。&lt;/p&gt;
&lt;p&gt;所以，简单线性回归，就是只有一个输入变量（自变量）的预测，就是这一种：y=ax+b，根据x的值，预测出y。你可以说，简单线性回归，就是一个函数。&lt;/p&gt;
&lt;p&gt;简单线性回归是一个预测模型（回归模型），是模型就要被训练，只有不断的训练才能得到最佳的预测状态--虽然这是废话，但的确是这样。同样，简单线性回归的目的，是尽可能拟合所有训练样本以达到最佳的预测状态。什么是拟合？比如画一条直线，尽可能地，让各个点（样本）的预测标签接近或重合实际标签，就是拟合。&lt;/p&gt;
&lt;p&gt;为了更好的解释这个概念，我画了一个图，图上面解释了相关概念：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92_%E6%9C%80%E7%BB%88%E7%A1%AE%E5%AE%9A%E7%9B%B4%E7%BA%BF.jpg&quot; alt=&quot;简单线性回归-确定特征与标签的关系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图上可以看到，如果对于每个点的输入特征，得到的预测标签跟这个点的实际标签都能重合的话，那就是最佳的。然而，实际上很可能做不到所有点都落在直线上，那这时候，找出一点最佳的直线，获得最好的拟合效果，就是机器学习要做的事情。&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92_%E7%A1%AE%E5%AE%9A%E6%9C%80%E4%BD%B3%E7%9A%84%E6%8B%9F%E5%90%88%E7%BA%BF.jpg&quot; alt=&quot;哪一条线有最好的拟合效果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单线性回归模型，给出了特征与标签的关系：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;y = mx + b&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;x是输入特征，y是预测标签。&lt;/p&gt;
&lt;p&gt;为了让这条直线更好的拟合所有的点，就要调整参数m跟b。&lt;/p&gt;
&lt;p&gt;m是直线的角度，叫斜率，在机器学习中叫权重。&lt;/p&gt;
&lt;p&gt;b叫截距，在机器学习中叫偏差。&lt;/p&gt;
&lt;p&gt;所以，使用简单线性回归算法，机器学习通过大量带标签的样本进行训练，最终调整出一个最佳的m跟b值，从而达到最好的拟合效果。&lt;/p&gt;
&lt;p&gt;那么，怎么判断拟合效果呢？怎么知道是变好还是变差了？&lt;/p&gt;
&lt;h4 id=&quot;如何判断拟合效果&quot;&gt;（2）如何判断拟合效果&lt;/h4&gt;
&lt;p&gt;为了判断拟合的效果，这里引入一个概念，叫损失计算。&lt;/p&gt;
&lt;p&gt;如果点刚好落在直线上，也就是预测标签跟实际标签一样，那损失为0。&lt;/p&gt;
&lt;p&gt;而实际上，更多的情况下，损失并不为0，这时要考虑整体损失。&lt;/p&gt;
&lt;p&gt;整体损失越小，拟合越好，比如下图所示，可以明显分辨出左线的拟合效果优于右线（当整体损失达到某个值时，就可以认为已经取得很好的预测效果，可以停止训练）：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92_%E6%8D%9F%E5%A4%B1.jpg&quot; alt=&quot;尽量减小损失&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，每个点跟预测标签的距离（也就是点到线的红箭头）称为损失。&lt;/p&gt;
&lt;p&gt;整体损失的计算可以有很多办法，这里引入一个简单实用的办法：均方误差（MSE）。&lt;/p&gt;
&lt;p&gt;均方误差（MSE），就是求出所有点的损失的平方和，再除以样本的个数。你可以参考这个图的解释：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/mse.jpg&quot; alt=&quot;MSE&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上这个图，来源于这个地址：&lt;a href=&quot;https://developers.google.com/machine-learning/crash-course/descending-into-ml/training-and-loss&quot; class=&quot;uri&quot;&gt;https://developers.google.com/machine-learning/crash-course/descending-into-ml/training-and-loss&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基本上，本文的内容与组织方式，都跟这个地址的教程有直接的关系。&lt;/p&gt;
&lt;p&gt;以上介绍了简单线性回归的定义，以及损失计算的一个办法即MSE，接下来小程用实例来演示简单线性回归的实现。&lt;/p&gt;
&lt;h4 id=&quot;简单线性回归示例&quot;&gt;（3）简单线性回归示例&lt;/h4&gt;
&lt;p&gt;这里以python来演示，主要是因为python易于使用。&lt;/p&gt;
&lt;p&gt;首先，给定一些散列的点，你可以参考下图的实现，截图中对部分代码做了解释：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E7%BB%98%E5%88%B6%E6%95%A3%E5%88%97%E7%82%B9.jpg&quot; alt=&quot;创建散列点&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行这一部分代码，可以看到这样的效果：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E6%95%A3%E5%88%97%E7%82%B9%E5%9B%BE.jpg&quot; alt=&quot;散列点绘制图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，对这些点进行简单线性回归，也就是画一条拟合线，并取得最好的拟合效果，参考下图：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E7%BB%98%E5%88%B6%E6%8B%9F%E5%90%88%E7%BA%BF.jpg&quot; alt=&quot;画拟合线&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终执行的效果是这样的：&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/%E6%8B%9F%E5%90%88%E7%BA%BF%E5%9B%BE.jpg&quot; alt=&quot;拟合线效果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，回头看一下吧。&lt;strong&gt;本文介绍了简单线性回归的定义以及损失计算的一个办法即MSE，最后用python示范了怎么使用简单线性回归算法绘制一条拟合线。简单线性回归，就是一个预测模型，更直接一点，就是一个函数--你可以说预测模型其实就是函数，就是一个算法设计（比如y=ax+b就是一个最核心的东西），它接受训练后的进化（比如不断地调整参数），从而得到最佳的预测状态。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E9%80%BB%E8%BE%91%E9%A2%98/%E9%80%BB30.png&quot; alt=&quot;haha&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 07:23:00 +0000</pubDate>
<dc:creator>广州小程</dc:creator>
<og:description>前文再续书接上一回，机器学习的主要目的，是根据特征进行预测。预测到的信息，叫标签。 从特征映射出标签的诸多算法中，有一个简单的算法，叫简单线性回归。 本文介绍简单线性回归的概念。 （1）什么是简单线性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeself/p/10906151.html</dc:identifier>
</item>
<item>
<title>python接口自动化（三十八）-python操作mysql数据库（详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10897822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10897822.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　现在的招聘要求对QA人员的要求越来越高，测试的一些基础知识就不必说了，来说测试知识以外的，会不会一门或者多门开发与语言，能不能读懂代码，会不会Linux，会不会搭建测试系统，会不会常用的数据库，会不会SQL等等，因此我们这篇文章来讲解如何用&lt;/p&gt;
&lt;p&gt;python语言操作mysql数据库。&lt;/p&gt;
&lt;p&gt; 本科阶段曾学过使用java对MySQL数据库进行操作，基本思路是先连接数据库，然后执行SQL语句对数据库进行操作，最后打印结果并断开连接。使用Python操作数据库的流程和以上过程基本一致，在对其进行介绍之前，先介绍一些基本的概念。&lt;/p&gt;
&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;h3&gt;python操作数据库的流程&lt;/h3&gt;
&lt;p&gt;以流程图的方式展示python操作MySQL数据库的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522093039167-2057351860.png&quot; alt=&quot;&quot; width=&quot;1129&quot; height=&quot;833&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　对上图的解读：首先检查是否依次创建Connection对象（数据库连接对象）用于打开数据库连接，创建Cursor对象（游标对象）用于执行查询和获取结果；然后执行SQL语句对数据库进行增删改查等操作并提交事务，此过程如果出现异常则使用回滚技术使数据库恢&lt;/p&gt;
&lt;p&gt;复到执行SQL语句之前的状态；最后，依次销毁Cursor对象和Connection对象，以避免多计算机内存过多的占用和浪费。&lt;/p&gt;
&lt;p&gt;　　下面依次对Connection对象、Cursor对象和事务等概念进行介绍。&lt;/p&gt;
&lt;h3&gt;Connection对象&lt;/h3&gt;
&lt;p&gt;Connection对象即为数据库连接对象，在python中可以使用py&lt;a class=&quot;keylink&quot; href=&quot;https://www.2cto.com/database/MySQL/&quot; target=&quot;_blank&quot;&gt;mysql&lt;/a&gt;.connect()方法创建Connection对象，该方法的常用参数如下：&lt;/p&gt;
&lt;p&gt;host：连接的数据库服务器主机名，默认为本地主机（localhost）；字符串类型（String） 。&lt;/p&gt;
&lt;p&gt;user：用户名，默认为当前用户；字符串类型（String） 。&lt;/p&gt;
&lt;p&gt;passwd：密码，无默认值；字符串类 （String）。&lt;/p&gt;
&lt;p&gt;db：数据库名称，无默认值；字符串类型（String） 。&lt;/p&gt;
&lt;p&gt;port：指定数据库服务器的连接端口，默认为3306；整型（int）。&lt;/p&gt;
&lt;p&gt;charset：连接字符集；字符串类型（String）&lt;/p&gt;
&lt;h4&gt;Connection对象常用的方法如下：&lt;/h4&gt;
&lt;p&gt;cursor()：使用当前连接创建并返回游标 。&lt;/p&gt;
&lt;p&gt;commit()：提交当前事务 。&lt;/p&gt;
&lt;p&gt;rollback()：回滚当前事务 。&lt;/p&gt;
&lt;p&gt;close()：关闭当前连接&lt;/p&gt;
&lt;h3&gt;Cursor对象&lt;/h3&gt;
&lt;p&gt;Cursor对象即为游标对象，用于执行查询和获取结果，在python中可以使用conn.cursor()创建，conn为Connection对象。Cursor对象常用的方法和属性如下：&lt;/p&gt;
&lt;p&gt;execute()：执行数据库查询或命令，将结果从数据库获取到客户端 fetchone()：获取结果集的下一行 fetchmany()：获取结果集的下几行 fetchall()：获取结果集中剩下的所有行 close()：关闭当前游标对象 rowcount：最近一次的execute返回数据的行数或受影响的行数&lt;/p&gt;
&lt;h2&gt;事务&lt;/h2&gt;
&lt;p&gt;1、事务机制可以确保数据一致性。&lt;/p&gt;
&lt;p&gt;事务是数据库理论中一个比较重要的概念，指访问和更新数据库的一个程序执行单元，具有ACID特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。&lt;/li&gt;
&lt;li&gt;一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。&lt;/li&gt;
&lt;li&gt;隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。&lt;/li&gt;
&lt;li&gt;持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在开发时，我们以以下三种方式使用事务：&lt;/p&gt;
&lt;p&gt;正常结束事务：conn.commit() 异常结束事务：conn.rollback() 关闭自动commit：设置 conn.autocommit(False)&lt;/p&gt;
&lt;p&gt;2 、使用python实现对MySQL数据库的增删改查等操作&lt;/p&gt;
&lt;p&gt;在python中操作MySQL数据库时，要使用的模块是：&lt;/p&gt;
&lt;p&gt;Python2中：mysqldb（pip2 install mysqldb） Python3中：pymysql（pip3 install pymysql）&lt;/p&gt;
&lt;p&gt;本篇博客所使用的环境为：&lt;/p&gt;
&lt;p&gt;python 3.7 win 10 pycharm 2018.3.5 pymysql 0.9.2 mysql 5.6 &lt;/p&gt;
&lt;p&gt;下面将以具体代码的形式依次介绍python中如何实现对MySQL数据库的增删改查等操作。&lt;/p&gt;
&lt;h2&gt;python操作数据库&lt;/h2&gt;
&lt;p&gt;Python 标准数据库接口为 Python DB-API，Python DB-API为开发人员提供了数据库应用编程接口。&lt;/p&gt;
&lt;p&gt;Python 数据库接口支持非常多的数据库，你可以选择适合你项目的数据库：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GadFly&lt;/li&gt;
&lt;li&gt;mSQL&lt;/li&gt;
&lt;li&gt;MySQL（小公司、小厂首选）&lt;/li&gt;
&lt;li&gt;PostgreSQL&lt;/li&gt;
&lt;li&gt;Microsoft SQL Server 2008（中型厂、中等公司首选）&lt;/li&gt;
&lt;li&gt;Informix&lt;/li&gt;
&lt;li&gt;Interbase&lt;/li&gt;
&lt;li&gt;Oracle（大厂、大企业首选）&lt;/li&gt;
&lt;li&gt;Sybase&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你可以访问&lt;a href=&quot;https://wiki.python.org/moin/DatabaseInterfaces&quot; target=&quot;_blank&quot;&gt;Python数据库接口及API&lt;/a&gt;查看详细的支持数据库列表。&lt;/p&gt;
&lt;p&gt;不同的数据库你需要下载不同的DB API模块，例如你需要访问Oracle数据库和Mysql数据，你需要下载Oracle和MySQL数据库模块。&lt;/p&gt;
&lt;p&gt;DB-API 是一个规范. 它定义了一系列必须的对象和数据库存取方式, 以便为各种各样的底层数据库系统和多种多样的数据库接口程序提供一致的访问接口 。&lt;/p&gt;
&lt;p&gt;Python的DB-API，为大多数的数据库实现了接口，使用它连接各数据库后，就可以用相同的方式操作各数据库。&lt;/p&gt;
&lt;h2&gt;Python DB-API使用流程：&lt;/h2&gt;
&lt;ul class=&quot;list&quot;&gt;&lt;li&gt;引入 API 模块。&lt;/li&gt;
&lt;li&gt;获取与数据库的连接。&lt;/li&gt;
&lt;li&gt;执行SQL语句和存储过程。&lt;/li&gt;
&lt;li&gt;关闭数据库连接。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2&gt;什么是MySQLdb?&lt;/h2&gt;
&lt;p&gt;PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的一个库，Python2中则使用mysqldb。&lt;/p&gt;
&lt;p&gt;PyMySQL 遵循 Python 数据库 API v2.0 规范，并包含了 pure-Python MySQL 客户端库。&lt;/p&gt;
&lt;h2&gt;如何安装MySQLdb?&lt;/h2&gt;
&lt;p&gt;在使用 PyMySQL 之前，我们需要确保 PyMySQL 已安装。&lt;/p&gt;
&lt;p&gt;PyMySQL 下载地址：https://github.com/PyMySQL/PyMySQL。&lt;/p&gt;
&lt;p&gt;如果还未安装，我们可以使用以下命令安装最新版的 PyMySQL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; pip install PyMySQL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522134717229-660691548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你的系统不支持 pip 命令，可以使用以下方式安装：&lt;/p&gt;
&lt;p&gt;1、使用 git 命令下载安装包安装(你也可以手动下载)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/PyMySQL/PyMySQL&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; cd PyMySQL/
&lt;span&gt;3&lt;/span&gt; python3 setup.py install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、如果需要制定版本号，可以使用 curl 命令来安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;# X.X 为 PyMySQL 的版本号
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; url -L https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/PyMySQL/PyMySQL/tarball/pymysql-X.X | tar xz&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; cd PyMySQL*
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;python3 setup.py install
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; # 现在你可以删除 PyMySQL* 目录
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;请确保您有root权限来安装上述模块。&lt;/p&gt;
&lt;blockquote readability=&quot;8.78125&quot;&gt;
&lt;p&gt;安装的过程中可能会出现&quot;ImportError: No module named setuptools&quot;的错误提示，意思是你没有安装setuptools，你可以访问&lt;a href=&quot;https://pypi.python.org/pypi/setuptools&quot; target=&quot;_blank&quot;&gt;https://pypi.python.org/pypi/setuptools&lt;/a&gt; 找到各个系统的安装方法。&lt;/p&gt;
&lt;p&gt;Linux 系统安装实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; $ wget https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;bootstrap.pypa.io/ez_setup.py&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; $ python3 ez_setup.py
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2&gt;数据库连接&lt;/h2&gt;
&lt;p&gt;连接数据库前，请先确认以下事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;您已经创建了数据库 TESTDB（测试数据库）&lt;/li&gt;
&lt;li&gt;在TESTDB数据库中您已经创建了表 EMPLOYEE（测试用的测试表）&lt;/li&gt;
&lt;li&gt;EMPLOYEE表字段为 FIRST_NAME, LAST_NAME, AGE, SEX 和 INCOME。&lt;/li&gt;
&lt;li&gt;连接数据库TESTDB（测试数据库）使用的用户名为 &quot;testuser&quot; ，密码为 &quot;test123&quot;,你可以可以自己设定或者直接使用root用户名及其密码，Mysql数据库用户授权请使用Grant命令。&lt;/li&gt;
&lt;li&gt;在你的机子上已经安装了 Python MySQLdb 模块。&lt;/li&gt;
&lt;li&gt;如果你对sql语句不熟悉，可以自己先简单的学习一下&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1、查看有没有创建数据库TESTDB（测试数据库），打开MySQL的client界面输入密码 后，输入命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; show databases;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522133027447-1253841502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、看到没有那个数据库，那我们就开始创建一个TESTDB数据库，输入命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; create database TESTDB;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522133659838-489646343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、再次输入第一步的命令查看，看到已经成功创建&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522133728435-496568491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、查看TESTDB数据库里，有没有EMPLOYEE（测试用的测试表），输入命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;use testdb;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; show tables;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522134117555-151928111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、查看到在TESTDB数据库中没有EMPLOYEE表，那么没有我们就创建一张EMPLOYEE表即可。&lt;/p&gt;
&lt;h2&gt;创建一个实例&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522135623241-766602808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行结果：（从结果中我们可以看见成功创建了一个Connection和Cursor对象。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522135652161-1858329714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;下面将以具体代码的形式依次介绍python中如何实现对MySQL数据库的增删改查等操作。&lt;/h2&gt;
&lt;h3&gt;实例：&lt;/h3&gt;
&lt;h4&gt;1、连接数据库&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522140536120-1399975454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522140638667-843910318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; # &lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; # &lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;22&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-&lt;span&gt;宏哥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用python操作MySQL数据库
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; # &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import pymysql
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import pymysql
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;# 打开数据库连接
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; conn = pymysql.connect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;# 使用cursor()方法创建一个游标对象
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; cursor =&lt;span&gt; conn.cursor()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;# 使用execute()方法执行SQL查询
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; cursor.execute(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SELECT VERSION()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;# 使用fetchone()方法获取单条数据
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; data =&lt;span&gt; cursor.fetchone()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;# 打印
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;database version: %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; data)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;# 关闭数据库连接
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; conn.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2、创建数据库表&lt;/h4&gt;
&lt;p&gt;如果数据库连接存在我们可以使用execute()方法来为数据库创建表，如下所示创建表EMPLOYEE：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522140959322-930458326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行代码后查看有没有表创建，输入命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;use TESTDB；
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; show tables;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522141802760-1972503197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522142104484-1886215381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; # &lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; # &lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;22&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-&lt;span&gt;宏哥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用python操作MySQL数据库
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; # &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import pymysql
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import pymysql
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;# 打开数据库连接
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; conn = pymysql.connect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;# 使用cursor()方法创建一个游标对象cursor
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; cursor =&lt;span&gt; conn.cursor()  # 游标对象用于执行查询和获取结果
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;# 使用execute()方法执行SQL，如果表存在则将其删除
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; cursor.execute(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DROP TABLE IF EXISTS EMPLOYEE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;# 使用预处理语句创建表
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; sql = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;CREATE TABLE `employee` (&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;   `first_name` varchar(&lt;span&gt;255&lt;/span&gt;) DEFAULT NULL COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;姓&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;   `last_name` varchar(&lt;span&gt;255&lt;/span&gt;) DEFAULT NULL COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;   `age` &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) DEFAULT NULL COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;年龄&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;   `sex` varchar(&lt;span&gt;255&lt;/span&gt;) DEFAULT NULL COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;性别&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;   `income` varchar(&lt;span&gt;255&lt;/span&gt;) DEFAULT NULL COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;收入&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; ) ENGINE=InnoDB DEFAULT CHARSET=&lt;span&gt;utf8;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;# 执行SQL语句
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;# 关闭数据库连接
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; conn.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3、数据库插入操作&lt;/h4&gt;
&lt;p&gt;以下实例使用执行 SQL INSERT 语句向表 EMPLOYEE 插入记录：&lt;/p&gt;
&lt;p&gt;1、首先查询有没有记录输入查询语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; employee;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522142734620-715136586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、代码实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522143028200-1161510174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522143058549-976392202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次查看有没有记录，输入第一步的sql语句：（可以看到插入一条记录）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522143215144-1434316013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
# coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
# &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行

# &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;22&lt;/span&gt;&lt;span&gt;
@author: 北京&lt;/span&gt;-&lt;span&gt;宏哥
Project:学习和使用python操作MySQL数据库
&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;# &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入模块
import pymysql

import pymysql

# 打开数据库连接
conn &lt;/span&gt;= pymysql.connect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

# 使用cursor()方法获取操作游标
cursor &lt;/span&gt;=&lt;span&gt; conn.cursor()

# SQL语句：向数据表中插入数据
sql &lt;/span&gt;= &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO EMPLOYEE(FIRST_NAME,&lt;/span&gt;
&lt;span&gt;         LAST_NAME, AGE, SEX, INCOME)
         VALUES (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mac&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mohan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2000&lt;/span&gt;)&lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;
# 异常处理
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    # 执行SQL语句
    cursor.execute(sql)
    # 提交事务到数据库执行
    conn.commit()  # 事务是访问和更新数据库的一个程序执行单元
except:
    # 如果发生错误则执行回滚操作
    conn.rollback()

# 关闭数据库连接
conn.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
# coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
# &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行

# &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;22&lt;/span&gt;&lt;span&gt;
@author: 北京&lt;/span&gt;-&lt;span&gt;宏哥
Project:学习和使用python操作MySQL数据库
&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;# &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入模块
import pymysql

import pymysql

# 打开数据库连接
conn &lt;/span&gt;= pymysql.connect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

# 使用cursor()方法获取操作游标
cursor &lt;/span&gt;=&lt;span&gt; conn.cursor()

# SQL语句：向数据表中插入数据
sql &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INSERT INTO EMPLOYEE(FIRST_NAME, \&lt;/span&gt;
&lt;span&gt;       LAST_NAME, AGE, SEX, INCOME) \
       VALUES (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,  %s,  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,  %s)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; % \&lt;/span&gt;
       (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mac&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mohan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2000&lt;/span&gt;&lt;span&gt;)
# 异常处理
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    # 执行SQL语句
    cursor.execute(sql)
    # 提交事务到数据库执行
    conn.commit()  # 事务是访问和更新数据库的一个程序执行单元
except:
    # 如果发生错误则执行回滚操作
    conn.rollback()

# 关闭数据库连接
conn.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;实例：&lt;/h3&gt;
&lt;p&gt;以下代码使用变量向SQL语句中传递参数:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;..................................
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; user_id = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; con.execute(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;insert into Login values( %s,  %s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;             (user_id, password))
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; ..................................
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3、数据库查询操作&lt;/h4&gt;
&lt;p&gt;Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;fetchone():&lt;/strong&gt; 该方法获取下一个查询结果集。结果集是一个对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fetchall():&lt;/strong&gt;接收全部的返回结果行.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rowcount:&lt;/strong&gt; 这是一个只读属性，并返回执行execute()方法后影响的行数。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;实例：&lt;/h3&gt;
&lt;p&gt;查询EMPLOYEE表中salary（工资）字段大于1000的所有数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522143846155-1580202610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522143913198-328248229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; # &lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; # &lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;22&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-&lt;span&gt;宏哥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用python操作MySQL数据库
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; # &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import pymysql
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import pymysql
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;# 打开数据库连接
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; conn = pymysql.connect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;# 使用cursor()方法获取操作游标
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; cursor =&lt;span&gt; conn.cursor()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;# SQL语句：查询
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT * FROM employee WHERE income &amp;gt; 1000 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;# 异常处理
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    # 执行SQL语句
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    # 获取所有的记录列表
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     results =&lt;span&gt; cursor.fetchall()
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    # 遍历列表
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; results:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        # 打印列表元素
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        print(row)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        # 姓
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         first_name = row[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        # 名
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         last_name = row[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        # 年龄
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         age = row[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        # 性别
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         sex = row[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        # 收入
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         income = row[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        # 打印列表元素
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        print(first_name, last_name, age, sex, income)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;except:
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     print(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Uable to fetch data!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;# 关闭数据库连接
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; conn.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4、数据库更新操作&lt;/h4&gt;
&lt;p&gt;更新操作用于更新数据表的的数据，以下实例将 EMPLOYEE 表中的 SEX 字段为 'M' 的 AGE 字段递增 5：&lt;/p&gt;
&lt;p&gt;1、以前age是20，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522144249346-485014602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、代码实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522144451993-596997079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522144512041-1863872617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、查询age变更到25了没有&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522144603004-1034685737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、参考代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
# coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
# &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行

# &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;22&lt;/span&gt;&lt;span&gt;
@author: 北京&lt;/span&gt;-&lt;span&gt;宏哥
Project:学习和使用python操作MySQL数据库
&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;# &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入模块
import pymysql

import pymysql

# 打开数据库连接
conn &lt;/span&gt;= pymysql.connect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

# 使用cursor()方法获取操作游标
cursor &lt;/span&gt;=&lt;span&gt; conn.cursor()

# SQL语句，执行更新操作
sql &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;UPDATE employee SET age = age + 5 WHERE sex = &quot;M&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

# 异常处理
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    # 执行SQL语句
    cursor.execute(sql)
    # 提交到数据库执行
    conn.commit()
except:
    # 发生错误时回滚
    conn.rollback()

# 关闭数据库连接
conn.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;5、删除操作&lt;/h4&gt;
&lt;p&gt;删除操作用于删除数据表中的数据，以下实例演示了删除数据表 EMPLOYEE 中 AGE 大于 20 的所有数据：&lt;/p&gt;
&lt;p&gt;1、大于20的只有一条，删除了就没有记录了，输入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; employee;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522145115234-2051097733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、代码实现&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522145318688-692528367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522145305518-1938594856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、查看数据库表，重复第一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190522152659620-917907207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5、参考代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; # &lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; # &lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;22&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-&lt;span&gt;宏哥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用python操作MySQL数据库
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; # &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import pymysql
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import pymysql
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;# 打开数据库连接
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; conn = pymysql.connect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;# 使用cursor()方法获取操作游标
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; cursor =&lt;span&gt; conn.cursor()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;# SQL语句，执行删除操作
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; sql = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DELETE FROM employee WHERE age &amp;gt;20&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;# 异常处理
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    # 执行SQL语句
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    cursor.execute(sql)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    # 提交到数据库执行
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    conn.commit()
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;except:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    # 发生错误时回滚
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    conn.rollback()
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;# 关闭数据库连接
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; conn.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;执行事务&lt;/h2&gt;
&lt;p&gt;事务机制可以确保数据一致性。&lt;/p&gt;
&lt;p&gt;事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。&lt;/li&gt;
&lt;li&gt;一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。&lt;/li&gt;
&lt;li&gt;隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。&lt;/li&gt;
&lt;li&gt;持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Python DB API 2.0 的事务提供了两个方法 commit 或 rollback。&lt;/p&gt;
&lt;h3&gt;实例：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;# SQL删除记录语句
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DELETE FROM EMPLOYEE WHERE AGE &amp;gt; %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;   # 执行SQL语句
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;   cursor.execute(sql)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;   # 向数据库提交
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;   db.commit()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;except:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;   # 发生错误时回滚
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    db.rollback()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于支持事务的数据库， 在Python数据库编程中，当游标建立之时，就自动开始了一个隐形的数据库事务。&lt;/p&gt;
&lt;p&gt;commit()方法游标的所有更新操作，rollback（）方法回滚当前游标的所有操作。每一个方法都开始了一个新的事务。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;错误处理&lt;/h2&gt;
&lt;p&gt;DB API中定义了一些数据库操作的错误及异常，下表列出了这些错误和异常:&lt;/p&gt;
&lt;table class=&quot;reference&quot;&gt;&lt;tbody readability=&quot;14.5&quot;&gt;&lt;tr&gt;&lt;th&gt;异常&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Warning&lt;/td&gt;
&lt;td&gt;当有严重警告时触发，例如插入数据是被截断等等。必须是 StandardError 的子类。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Error&lt;/td&gt;
&lt;td&gt;警告以外所有其他错误类。必须是 StandardError 的子类。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;InterfaceError&lt;/td&gt;
&lt;td&gt;当有数据库接口模块本身的错误（而不是数据库的错误）发生时触发。 必须是Error的子类。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DatabaseError&lt;/td&gt;
&lt;td&gt;和数据库有关的错误发生时触发。 必须是Error的子类。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;DataError&lt;/td&gt;
&lt;td&gt;当有数据处理时的错误发生时触发，例如：除零错误，数据超范围等等。 必须是DatabaseError的子类。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;OperationalError&lt;/td&gt;
&lt;td&gt;指非用户控制的，而是操作数据库时发生的错误。例如：连接意外断开、 数据库名未找到、事务处理失败、内存分配错误等等操作数据库是发生的错误。 必须是DatabaseError的子类。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;IntegrityError&lt;/td&gt;
&lt;td&gt;完整性相关的错误，例如外键检查失败等。必须是DatabaseError子类。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;InternalError&lt;/td&gt;
&lt;td&gt;数据库的内部错误，例如游标（cursor）失效了、事务同步失败等等。 必须是DatabaseError子类。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;ProgrammingError&lt;/td&gt;
&lt;td&gt;程序错误，例如数据表（table）没找到或已存在、SQL语句语法错误、 参数数量错误等等。必须是DatabaseError的子类。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;NotSupportedError&lt;/td&gt;
&lt;td&gt;不支持错误，指使用了数据库不支持的函数或API等。例如在连接对象上 使用.rollback()函数，然而数据库并不支持事务或者事务已关闭。 必须是DatabaseError的子类。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt; 　　哈哈，终于搞完了、整完了，累死宝宝了，已到半夜，明天有时间分享！！！&lt;/p&gt;
&lt;p&gt;　　小伙伴python操作MySQL数据库就是这么简单！！！最重要的自己要会、要有扎实的SQL基础。&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 07:20:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 现在的招聘要求对QA人员的要求越来越高，测试的一些基础知识就不必说了，来说测试知识以外的，会不会一门或者多门开发与语言，能不能读懂代码，会不会Linux，会不会搭建测试系统，会不会常用的数据库，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/du-hong/p/10897822.html</dc:identifier>
</item>
<item>
<title>在线抠图网站速抠图sukoutu.com全面技术解析之canvas应用 - aiaito</title>
<link>http://www.cnblogs.com/guozefeng/p/10905285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guozefeng/p/10905285.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;strong&gt;技术关键词&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          Canvas应用,泛洪算法（Flood Fill),图片缩放,相对位置等比缩放,判断一个点是否在一个平面闭合多边形，nginx代理&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;业务关键词&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         在线抠图,智能抠图,一键抠图,钢笔抠图,矩阵抠图,图片处理,图片压缩,图片尺寸,图片格式,图片透明度,图片下载&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;引用组件（前端）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         Jquery,Canvas,Jcrop, Layer,MiniColors&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;技术解析背景&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          发表这篇随笔，一方面帮助前端的同学认识Canvas的实际应用场景和了解相关技术点，另一方面让&lt;a href=&quot;http://www.sukoutu.com/&quot; target=&quot;_blank&quot;&gt;sukoutu.com&lt;/a&gt;能够帮助更多的人去快速高效的完成抠图。&lt;/p&gt;
&lt;p&gt;         作为一名后端研发去开发一套纯前端的在线抠图工具实际上看起来有些疑惑和怪异，或许是因为 14年5月发表的一个随笔  &lt;strong&gt;&lt;a title=&quot;在线抠图教程-智能抠图&quot; href=&quot;https://www.cnblogs.com/guozefeng/p/3719915.html&quot; target=&quot;_blank&quot;&gt;html5 canvas+js实现ps钢笔抠图&lt;/a&gt; &lt;/strong&gt;的延续。&lt;/p&gt;
&lt;p&gt;         发表在&lt;a title=&quot;速抠图sukoutu.com&quot; href=&quot;https://zhuanlan.zhihu.com/p/65833367&quot; target=&quot;_blank&quot;&gt;知乎上的一篇文章&lt;/a&gt; 能让你知道sukoutu.com上线的原由、目的以及相关功能简介。&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/401614/201905/401614-20190522134438014-531403932.png&quot; alt=&quot;&quot; width=&quot;844&quot; height=&quot;675&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;速抠图网站实现原理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;   &lt;/strong&gt;       网站几乎没有和后端服务做交互。后端用nginx作为server，另外代理了三方房展的图片访问（解决前端跨域访问网络图片跨域禁止canvas渲染的问题，通过nginx代理访问规避这个问题）。图片上传及图片操作等均在客户端浏览器上完成（图片操作流畅的很），因为有Canvas，所以整个工具网站的核心都在于js的交互及canvas的应用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;智能抠图（仿PS魔法棒效果）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         这里参考了一些开源项目和泛洪算法（Flood Fill)的实现案例。对于一次纯色或者背景色差比较大的图片抠图，基本都能实现一键抠图的效果，通过点击滑选闭合色区来实现抠图，但是对于背景色差复杂的图片就很难实现自己想要的抠图了。&lt;/p&gt;
&lt;p&gt;         算法参考：&lt;a href=&quot;%20http://www.pianshen.com/article/172962944/&quot; target=&quot;_blank&quot;&gt; 图像分割经典算法--《泛洪算法》（Flood Fill）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;         实现原理：底层放图片，顶层放canvas，将图片按照对等尺寸渲染至到画布上得到ImageData,鼠标点击获取ImageData RGB 色值，用floodfill算法得到闭合外围坐标，在顶层canvas渲染边线（ctx.putImageData）&lt;a href=&quot;%20http://www.pianshen.com/article/172962944/&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  init: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (img) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.data.img =&lt;span&gt; img;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.data.tempCanvas = document.createElement('canvas'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tempCtx = &lt;span&gt;this&lt;/span&gt;.data.tempCanvas.getContext('2d'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;切记，原始图像大小&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         tempCtx.canvas.width =&lt;span&gt; panel.data.targetImgWidth;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         tempCtx.canvas.height =&lt;span&gt; panel.data.targetImgHeight;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         tempCtx.drawImage(img, 0, 0&lt;span&gt;, panel.data.targetImgWidth, panel.data.targetImgHeight);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.data.imgData = tempCtx.getImageData(0, 0&lt;span&gt;, panel.data.targetImgWidth, panel.data.targetImgHeight);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     },
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;钢笔抠图&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         钢笔抠图参考 &lt;strong&gt;&lt;a title=&quot;在线抠图教程-智能抠图&quot; href=&quot;https://www.cnblogs.com/guozefeng/p/3719915.html&quot; target=&quot;_blank&quot;&gt;html5 canvas+js实现ps钢笔抠图&lt;/a&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;         &lt;/strong&gt;实现原理：底层放图片，顶层放canvas，鼠标点击坐标存放到array中，canvas根据坐标list画线画点，canvas的 globalCompositeOperation = &quot;destination-out&quot; 属性可以实现通过由多个点构成的闭合区间设置成透明色穿透画布背景色或是背景图片。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;矩阵抠图&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;         这里用的是非常实用的Jcrop插件，&lt;a href=&quot;http://deepliquid.com/content/Jcrop.html&quot; target=&quot;_blank&quot;&gt;参考Jcrop官网&lt;/a&gt; ,提供了丰富的api，比如等比、移动等实用的功能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;图片等比缩放（很实用）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          解决图片加载要等比缩放到画布中，并且居中显示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; imgScale(src, w, h, fun) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; img = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Image();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     img.src =&lt;span&gt; src;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     img.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; wi =&lt;span&gt; img.width;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; he =&lt;span&gt; img.height;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; toHe = he * w /&lt;span&gt; wi;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; toWi = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (toHe &amp;gt;&lt;span&gt; h) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             toWi = wi * h /&lt;span&gt; he;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             toHe =&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             toWi =&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        fun(toWi, toHe);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;相对位置等比缩放&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        在实现钢笔抠图或矩阵抠图需要放大，并且钢笔及矩阵坐标list也要等比缩放，需要用到如下算法来实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; _scale = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (c, a, f) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     x1 *=&lt;span&gt; c.x;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     y1 *=&lt;span&gt; c.y;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     x2 *=&lt;span&gt; c.x;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     y2 *=&lt;span&gt; c.y;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (a) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         _values = [1.0000000000000002, -0, -0, 1.0000000000000002&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; b = transform(a.x - translationStart.x, a.y -&lt;span&gt; translationStart.y);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; d = transform(c.x * -b.x, c.y * -&lt;span&gt;b.y);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         translation.x = d.x +&lt;span&gt; a.x;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         translation.y = d.y +&lt;span&gt; a.y
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; transform = &lt;span&gt;function&lt;/span&gt; (b, d, a) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两中心x差，两中心y差&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; c = &lt;span&gt;new&lt;/span&gt; Point(_values[0] * b + _values[1] * d, _values[2] * b + _values[3] *&lt;span&gt; d);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; c
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt; Canvas应用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt; 图片压缩、图片尺寸调整、图片背景色、图片透明度实际均可通过canvas属性来操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;透明度 &lt;/span&gt;
ctx.globalAlpha =&lt;span&gt; imgCreate.cutObj.alpha;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;背景色&lt;/span&gt;
ctx.fillStyle =&lt;span&gt; imgCreate.cutObj.color;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据坐标list裁剪图片&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; ctx = $(&quot;#createCanvas&quot;)[0].getContext('2d'&lt;span&gt;);
ctx.beginPath();
ctx.moveTo(&lt;/span&gt;0, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; proxy.cutObj.pointArray.length; i++&lt;span&gt;) {
    ctx.lineTo(proxy.cutObj.pointArray[i].pointx, proxy.cutObj.pointArray[i].pointy);
}
ctx.lineTo(proxy.cutObj.pointArray[&lt;/span&gt;0].pointx, proxy.cutObj.pointArray[0&lt;span&gt;].pointy);
ctx.clip();
ctx.drawImage(proxy.cutObj.imgObj, tempPointArray[&lt;/span&gt;0].pointx * -1, tempPointArray[0].pointy * -1&lt;span&gt;, proxy.cutObj.width, proxy.cutObj.height);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成及下载图片兼容（ie\谷歌\火狐）&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; fileName = proxy.cutObj.name + &quot;.&quot; + proxy.cutObj.suffix.replace(&quot;e&quot;, &quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (window.navigator.msSaveOrOpenBlob) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; imgData = $(&quot;#createCanvas&quot;)[0&lt;span&gt;].msToBlob();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blobObj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Blob([imgData]);
    window.navigator.msSaveOrOpenBlob(blobObj, fileName);
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; imgData = $(&quot;#createCanvas&quot;)[0].toDataURL(&quot;image/&quot; +&lt;span&gt; imgCreate.cutObj.suffix, parseFloat(imgCreate.cutObj.quality));
    imgData &lt;/span&gt;= imgData.replace(&quot;image/&quot; + imgCreate.cutObj.suffix, 'image/octet-stream'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = document.createElement('a'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; event = &lt;span&gt;new&lt;/span&gt; MouseEvent('click'&lt;span&gt;);
    a.download &lt;/span&gt;=&lt;span&gt; fileName;
    a.href &lt;/span&gt;=&lt;span&gt; URL.createObjectURL(dataURIToBlob(imgData));
    a.dispatchEvent(event);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Wed, 22 May 2019 06:50:00 +0000</pubDate>
<dc:creator>aiaito</dc:creator>
<og:description>技术关键词 Canvas应用,泛洪算法（Flood Fill),图片缩放,相对位置等比缩放,判断一个点是否在一个平面闭合多边形，nginx代理 业务关键词 在线抠图,智能抠图,一键抠图,钢笔抠图,矩阵</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guozefeng/p/10905285.html</dc:identifier>
</item>
<item>
<title>Node学习图文教程之express重写留言本案例 - pubdreamcc</title>
<link>http://www.cnblogs.com/dreamcc/p/10905719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dreamcc/p/10905719.html</guid>
<description>&lt;p&gt;小伙伴们大家好，我是你们的&lt;code&gt;pubdreamcc&lt;/code&gt;，接着前面的学习，这篇博文出至于我的GitHub仓库：&lt;code&gt;Node学习教程资料&lt;/code&gt;，如果你觉得对你有帮助，欢迎&lt;code&gt;star&lt;/code&gt;，你们的点赞是我持续更新的动力，谢谢！&lt;/p&gt;
&lt;blockquote readability=&quot;4.1176470588235&quot;&gt;
&lt;p&gt;Node.js学习教程资料：&lt;a href=&quot;https://github.com/pubdreamcc/Node.js&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我们在之前的node.js学习的基础课程中已经完成了一个简单的用户发表评论社区，今天我们利用web开发框架--&lt;code&gt;express&lt;/code&gt;来重写案例，进一步加强对&lt;code&gt;express&lt;/code&gt;框架的理解和使用。&lt;/p&gt;
&lt;h2 id=&quot;demo主体&quot;&gt;demo主体&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;创建项目文件夹，&lt;code&gt;npm&lt;/code&gt;初始化项目&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在本地任意目录下创建名为：&lt;code&gt;expressCommentList&lt;/code&gt;文件夹，cd文件夹中，运行：&lt;code&gt;npm init -y&lt;/code&gt;快速初始化，生成&lt;code&gt;package.json&lt;/code&gt;文件。安装相应第三方依赖：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;npm install express art-template express-art-template body-parser --save&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;创建静态资源文件夹&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们在&lt;code&gt;expressCommentList&lt;/code&gt;文件夹中创建一个名为：&lt;code&gt;public&lt;/code&gt;文件夹，用来存放静态文件，也就是公开的资源文件。项目中用到的&lt;code&gt;bootstrap&lt;/code&gt;样式文件和页面的脚本文件等都可以放到&lt;code&gt;public&lt;/code&gt;文件夹中。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建页面视图文件夹&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;同样地，在&lt;code&gt;expressCommentList&lt;/code&gt;文件夹中创建名为：&lt;code&gt;views&lt;/code&gt;文件夹，&lt;code&gt;views&lt;/code&gt;文件夹用来存放页面视图相关的文件，这也为后面模板引擎默认查找模板文件的位置一致，便于后续编码。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建服务器文件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;app.js&lt;/code&gt;为我们的服务器文件，在这里我们使用&lt;code&gt;express&lt;/code&gt;来开启一个web服务器。&lt;/p&gt;
&lt;h2 id=&quot;demo主要代码&quot;&gt;demo主要代码&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;app.js&lt;/code&gt;文件中核心代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const express = require('express')
// 引入body-parser
const bodyParser = require('body-parser')
const app = express()
// 开放静态资源
app.use('/public/', express.static('./public'))
// 配置express-art-template模板引擎
app.engine('html', require('express-art-template'))
// 配置body-parser
app.use(bodyParser.urlencoded({ extended: false }))
// 先造一些假数据，供模板引擎渲染
let comments = [
  {
    name: 'jack',
    content: 'hello world',
    time: '2019-5-1'
  },
  {
    name: 'Tom',
    content: 'hello world',
    time: '2019-5-1'
  },
  {
    name: 'dream',
    content: 'hello world',
    time: '2019-5-1'
  },
  {
    name: 'james',
    content: 'hello world',
    time: '2019-5-1'
  },
  {
    name: 'jack',
    content: 'hello world',
    time: '2019-5-1'
  },
  {
    name: 'life',
    content: 'hello world',
    time: '2019-5-3'
  }
]
app.get('/', (req, res) =&amp;gt; {
  res.render('index.html', {
    comments: comments
  })
})
app.get('/post', (req, res) =&amp;gt; {
  res.render('post.html')
})
app.post('/comment', (req, res) =&amp;gt; {
  // 得到post请求发送的数据
  const comment = req.body
  comment.time = '2019-5-21'
  comments.unshift(comment)
  // 重定向到首页（‘/’）
  res.redirect('/')
})
app.listen(3000, () =&amp;gt; {
  console.log('running...')
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用了&lt;code&gt;express-art-template&lt;/code&gt;模板引擎渲染模板文件，并且通过express的中间件：&lt;code&gt;body-parser&lt;/code&gt;来获取表单POST提交后的数据，最终通过把POST提交的数据合并到原始数据中即可显示在首页上。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;express-art-template&lt;/code&gt;和&lt;code&gt;body-parser&lt;/code&gt;在express中的具体用法，不清楚的伙伴可以关注我的之前Node教程资料：&lt;code&gt;express中art-template的使用&lt;/code&gt;和&lt;code&gt;express中获取post请求数据&lt;/code&gt;，这里就不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;demo演示效果图&quot;&gt;demo演示效果图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1632878/201905/1632878-20190522142956968-752592251.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果需要完整demo代码，可以查看GitHub上仓库&lt;code&gt;Node学习demo案例&lt;/code&gt;文件夹&lt;/em&gt;，当然如果你有好的建议也可以issue我，或者留言评论，thank you!&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 06:31:00 +0000</pubDate>
<dc:creator>pubdreamcc</dc:creator>
<og:description>写在前面 小伙伴们大家好，我是你们的 ，接着前面的学习，这篇博文出至于我的GitHub仓库： ，如果你觉得对你有帮助，欢迎 ，你们的点赞是我持续更新的动力，谢谢！ Node.js学习教程资料： 'Gi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dreamcc/p/10905719.html</dc:identifier>
</item>
<item>
<title>AppBoxFuture(七): 分布式外键约束 - 白菜园</title>
<link>http://www.cnblogs.com/BaiCai/p/10905592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BaiCai/p/10905592.html</guid>
<description>&lt;p&gt;  关系数据库与NoSql其中的一个主要区别是具备完整的外键约束，虽说现在一些大厂在设计数据存储结构时禁止使用外键约束，靠业务逻辑来保证数据完整性，但考虑到是人就会犯错，为了保证关键业务数据的完整性，所以作者还是决定在存储引擎层面实现外键约束功能。&lt;/p&gt;

&lt;p&gt;  由于存储引擎是分布式的，所以引用者与被引用者可能存在不同的节点上（如订单数据在节点1上，订单引用的产品数据在节点2上），这样实现外键约束的方式就会与传统关系数据库有些不一样，作者设计了如下图所示的存储结构，在RocksDB划分一个ColumnFamily存储引用索引（记录谁的某个成员引用了哪个目标），以及存储被引用者的计数器（记录哪个分区引用了我，被引用了多少次），通过分布式事务保证数据与引用索引及计数器的一致性。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201905/4928-20190522140829286-1023502383.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  根据上述设计，以下描述的逻辑可以得到保证（为了方便以下订单指引用者，产品指被引用者）：&lt;/p&gt;
&lt;h2 id=&quot;insert订单&quot;&gt;1.Insert订单&lt;/h2&gt;
&lt;p&gt;  Insert时存储引擎根据实体模型元数据是否存在EntityRef成员，是则在同一事务内会向被引用者的分区自动发送AddRefCommand，该命令会锁定并判断是否存在相应的记录，如不存在则通知事务回滚。如果是同一事务内Insert产品再Insert订单，AddRefCommand会检测同一事务内是否存在被引用者记录。事务递交时原子保存引用索引与引用计数。&lt;/p&gt;
&lt;h2 id=&quot;delete产品&quot;&gt;2.Delete产品&lt;/h2&gt;
&lt;p&gt;  Delete时存储引擎先判断当前记录所有分区的引用计数值是否等于0，不等于0则通知事务回滚。&lt;/p&gt;
&lt;h2 id=&quot;update-or-delete订单&quot;&gt;3.Update or Delete订单&lt;/h2&gt;
&lt;p&gt;  如果引用的产品变更，则删除旧引用索引然后添加新引用索引；如果引用的产品设为Null或删除订单，则删除引用索引，同时通知产品分区更新引用计数。&lt;/p&gt;

&lt;p&gt;  由于存储引擎的分布式事务是基于2PL实现的，如果大量不同的事务Insert订单且引用同一产品，会造成这些事务排队执行，从而导致并发性能不理想。作者做了个简单优化，允许不同事务的AddRefCommand共享锁定被引用者以提高并发性能。就上述场景作者简单测试了并发Insert带EntityRef的性能，单节点Debug模式约14000tps(I74C8G虚拟机)，不带外键引用的并发Insert约28000tps。&lt;/p&gt;

&lt;p&gt;  暂利用初始化时的实体Emploee及OrgUnit来做测试，OrgUnit.CreateById引用Emploee.Id。通过IDE新建一个服务模型，然后依次实现以下服务方法保存发布后将输入光标定位在需要测试的方法名称内，点击主菜单-&amp;gt;Service-&amp;gt;Invoke进行服务方法调用测试。&lt;/p&gt;
&lt;h2 id=&quot;测试引用至不存在的目标&quot;&gt;1.测试引用至不存在的目标&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public async Task&amp;lt;string&amp;gt; Test1()
{
    var ou = new Entities.OrgUnit();
    ou.Name = &quot;Name&quot;;
    ou.CreateById = Guid.Empty; //指向不存在的目标
    await EntityStore.SaveAsync(ou);
    return &quot;Done.&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用此方法显示&quot;Insert error: ForeignKeyConstraint&quot;, 即违反外键约束。&lt;/p&gt;
&lt;h2 id=&quot;测试同一事务插入&quot;&gt;2.测试同一事务插入&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public async Task&amp;lt;string&amp;gt; Test2()
{
    var txn = await Transaction.BeginAsync();
    try
    {
        //先新建并保存被引用者
        var emp = new Entities.Emploee();
        emp.Name = &quot;Batch name&quot;;
        emp.Account = emp.Name;
        emp.Birthday = new DateTime(1977, 3, 16);
        await EntityStore.SaveAsync(emp, txn);
        //再新建并保存引用者
        var ou = new Entities.OrgUnit();
        ou.Name = &quot;Batch ou&quot;;
        ou.CreateById = emp.Id;
        await EntityStore.SaveAsync(ou, txn);

        await txn.CommitAsync();
    }
    catch (Exception ex)
    {
        txn.Rollback();
        return $&quot;Failed: {ex.Message}&quot;;
    }
    return &quot;Done.&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用此方法返回&quot;Done.&quot;，此时可打开Emploee及OrgUnit的模型设计器内的&quot;Data&quot;栏验证插入的数据。&lt;/p&gt;
&lt;h2 id=&quot;测试同一事务删除&quot;&gt;3.测试同一事务删除&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public async Task&amp;lt;string&amp;gt; Delete()
{
    var q1 = new TableScan&amp;lt;Entities.OrgUnit&amp;gt;();
    q1.Filter(t =&amp;gt; t.Name == &quot;Batch ou&quot;);
    var ous = await q1.ToListAsync();

    var q2 = new TableScan&amp;lt;Entities.Emploee&amp;gt;();
    q2.Filter(t =&amp;gt; t.Name == &quot;Batch name&quot;);
    var emps = await q2.ToListAsync();

    var txn = await Transaction.BeginAsync();
    try
    {
        //先删除引用者, 如果注释这一行则存在外键约束导致下一行执行失败
        await EntityStore.DeleteAsync(ous[0], txn);
        //再删除被引用者
        await EntityStore.DeleteAsync(emps[0], txn);
        await txn.CommitAsync();
    }
    catch(Exception ex)
    {
        txn.Rollback();
        return $&quot;Failed: {ex.Message}&quot;;
    }
    return &quot;Done.&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用此方法返回&quot;Done.&quot;，此时可打开Emploee及OrgUnit的模型设计器内的&quot;Data&quot;栏验证数据已被删除。&lt;/p&gt;

&lt;p&gt;  本篇主要介绍了框架集成的存储引擎如何用另类的方式实现外键约束，&lt;a href=&quot;https://github.com/enjoycode/appbox.deploy&quot;&gt;Github&lt;/a&gt;上的运行时已经更新可测试。如果您有问题或Bug报告，请留言或在&lt;a href=&quot;https://github.com/enjoycode/appbox.deploy&quot;&gt;Github&lt;/a&gt;提交Issue。&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 06:10:00 +0000</pubDate>
<dc:creator>白菜园</dc:creator>
<og:description>  关系数据库与NoSql其中的一个主要区别是具备完整的外键约束，虽说现在一些大厂在设计数据存储结构时禁止使用外键约束，靠业务逻辑来保证数据完整性，但考虑到是人就会犯错，为了保证关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BaiCai/p/10905592.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core模块化前后端分离快速开发框架介绍之2、快速创建一个业务模块 - oldli</title>
<link>http://www.cnblogs.com/oldli/p/10905415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oldli/p/10905415.html</guid>
<description>&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/iamoldli/NetModular&quot; class=&quot;uri&quot;&gt;https://github.com/iamoldli/NetModular&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;地址：&lt;a href=&quot;http://129.211.40.240:6220&quot; class=&quot;uri&quot;&gt;http://129.211.40.240:6220&lt;/a&gt;&lt;br/&gt;账户：admin&lt;br/&gt;密码：admin&lt;/p&gt;

&lt;p&gt;地址：&lt;a href=&quot;http://progqx5cu.bkt.clouddn.com/skins/index.html#/&quot; class=&quot;uri&quot;&gt;http://progqx5cu.bkt.clouddn.com/skins/index.html#/&lt;/a&gt;&lt;br/&gt;账户：admin&lt;br/&gt;密码：admin&lt;/p&gt;

&lt;blockquote readability=&quot;3.8888888888889&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/oldli/p/10895001.html&quot;&gt;1、开篇&lt;/a&gt;&lt;br/&gt;2、快速创建一个业务模块&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/iamoldli/NetModular&quot;&gt;NetModular&lt;/a&gt;实现快速开发有两个前提条件：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1、约定优于配置的开发原则&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;2、代码生成器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;约定优于配置是现在到处可见的一种开发原则，比如ASP.NET MVC中的&lt;code&gt;HttpGet&lt;/code&gt;、&lt;code&gt;HttpPost&lt;/code&gt;等特性限制请求方式，比如控制器都以&lt;code&gt;Controller&lt;/code&gt;结尾，比如SpringBoot中各种注解等，都属于约定优于配置，这种开发原则的好处在于可以减少开发人员需要做决定的次数，使开发变得简单、快速，只是这是对于老手来说的，对于新手则提高了学习成本。&lt;/p&gt;
&lt;p&gt;基本上每个开源的框架都会有配套的代码生成器，而代码生成器其实就是以约定优于配置为基础的，只有先约定好了项目结构和开发规范，你才能实现一个代码生成器。与其它代码生成器不同，&lt;code&gt;NetModular&lt;/code&gt;的代码生成器不是根据数据库来生成代码，而是提供了一个单独的模块，可以很方便的集成到任何项目当中，通过Web的形式在线配置项目、实体、属性、模型、枚举等内容，然后可以一键生成项目代码并下载。&lt;/p&gt;
&lt;p&gt;其实，我的最终目标是希望能够有一个强大的可视化编辑页面，可以灵活配置前端的视图页面以及后端的实体信息，最后直接在线编译并热加载到当前项目中。后端热加载还有点思路，但是前端因为要打包的原因，现在还没想好解决，以后努力~&lt;/p&gt;

&lt;p&gt;上面说了，代码生成器是依赖与约定的，所以我们先来看下一个模块的项目结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/646935/201905/646935-20190522133453096-404324650.png&quot; alt=&quot;模块的结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中的Blog目录，就是一个模块的示例，本身就是通过代码生成器生成后放到项目当中的(很多人第一眼看到以为是DDD架构的，其实不是，顶多就是个DDDLite~)，先说一下每层的作用&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;h4 id=&quot;domain领域层包含实体实体扩展实体相关的枚举仓储接口&quot;&gt;1、Domain：领域层，包含实体、实体扩展、实体相关的枚举、仓储接口&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;实体都已&lt;code&gt;Entity&lt;/code&gt;结尾&lt;br/&gt;仓储接口都已&lt;code&gt;Repository&lt;/code&gt;结尾，且必须继承&lt;code&gt;IRepository&amp;lt;&amp;gt;&lt;/code&gt;泛型接口&lt;br/&gt;实体包含扩展属性的，需要把实体设置为部分类，且扩展类需要以&lt;code&gt;Extend.cs&lt;/code&gt;结尾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4.5&quot;&gt;
&lt;h4 id=&quot;infrastructure基础设施层包含仓储实现以及一些当前模块特有的类像配置项等&quot;&gt;2、Infrastructure：基础设施层，包含仓储实现以及一些当前模块特有的类，像配置项等&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;仓储实现位于Repositories目录下，不同数据库放到不同的目录下面&lt;br/&gt;模块特有的配置项放在Options目录下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4.5&quot;&gt;
&lt;h4 id=&quot;application应用服务层包含所有的业务逻辑&quot;&gt;3、Application：应用服务层、包含所有的业务逻辑&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;每个实体对应一个目录，目录名称为&lt;code&gt;实体名称+Service&lt;/code&gt;&lt;br/&gt;每个目录下包含有服务接口和实现、视图模型、对象映射配置、模型验证配置等信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;h4 id=&quot;web接口层包含控制器模块初始化配置等&quot;&gt;4、Web：接口层、包含控制器、模块初始化配置等&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;必须创建&lt;code&gt;ModuleInitializer&lt;/code&gt;类，且该类必须继承&lt;code&gt;IModuleInitializer&lt;/code&gt;接口&lt;br/&gt;必须创建&lt;code&gt;ModuleController&lt;/code&gt;基类控制器，继承&lt;code&gt;ModuleControllerAbstract&lt;/code&gt;抽象类，并配置&lt;code&gt;Area&lt;/code&gt;特性用于配置区域&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4.5&quot;&gt;
&lt;h4 id=&quot;webhostweb主机包含配置文件用于安装所需的模块以及启动项目&quot;&gt;5、WebHost：Web主机，包含配置文件，用于安装所需的模块以及启动项目&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;必须创建&lt;code&gt;Startup&lt;/code&gt;类，并且继承&lt;code&gt;StartupAbstract&lt;/code&gt;抽象类&lt;br/&gt;在&lt;code&gt;Program&lt;/code&gt;的&lt;code&gt;Main&lt;/code&gt;函数中，使用&lt;code&gt;WebHostCreator.Run&amp;lt;Startup&amp;gt;(args);&lt;/code&gt;方式启动&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;webhost.electron客户端主机用于启动基于-electron.js-的客户端程序&quot;&gt;6、WebHost.Electron：客户端主机，用于启动基于 &lt;a href=&quot;https://electronjs.org/&quot;&gt;Electron.js&lt;/a&gt; 的客户端程序&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上就是&lt;code&gt;NetModular&lt;/code&gt;框架中一个模块的结构，有了约定，那么接下来就演示一下如何通过代码生成器来创建项目吧。&lt;/p&gt;

&lt;h2 id=&quot;创建项目&quot;&gt;1、创建项目&lt;/h2&gt;
&lt;p&gt;已个人博客为例，项目需要填名称车和编码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/646935/201905/646935-20190522133516259-983538290.gif&quot; alt=&quot;创建项目&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;添加枚举&quot;&gt;2、添加枚举&lt;/h2&gt;
&lt;p&gt;因为文章有多媒体信息，所以先添加一个多媒体的枚举&lt;code&gt;MediaType&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/646935/201905/646935-20190522133534656-1829820502.gif&quot; alt=&quot;添加枚举&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;添加实体&quot;&gt;3、添加实体&lt;/h2&gt;
&lt;p&gt;添加文章&lt;code&gt;Article&lt;/code&gt;、分类&lt;code&gt;Category&lt;/code&gt;、标签&lt;code&gt;Tag&lt;/code&gt;三个实体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/646935/201905/646935-20190522133553834-365527715.gif&quot; alt=&quot;添加实体&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置实体属性&quot;&gt;4、配置实体属性&lt;/h2&gt;
&lt;p&gt;以文章&lt;code&gt;Article&lt;/code&gt;为例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/646935/201905/646935-20190522133615618-669389168.gif&quot; alt=&quot;配置实体属性&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;生成&quot;&gt;5、生成&lt;/h2&gt;
&lt;p&gt;在项目列表中，点击生成按钮生成代码并下载。&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;6、测试&lt;/h2&gt;
&lt;p&gt;打开生成的代码，进入&lt;code&gt;Blog/data&lt;/code&gt;目录，按需创建数据库，因为模块默认依赖&lt;code&gt;Nm_Admin&lt;/code&gt;模块，所以也要创建&lt;code&gt;Nm_Admin&lt;/code&gt;的数据库&lt;/p&gt;
&lt;p&gt;进入&lt;code&gt;Blog/src/WebHost/config&lt;/code&gt;目录，打开&lt;code&gt;db.json&lt;/code&gt;配置数据库连接&lt;/p&gt;
&lt;p&gt;回到&lt;code&gt;Blog/src/WebHost&lt;/code&gt;目录，代开命令行输入以下命令启动服务端&lt;/p&gt;
&lt;pre class=&quot;ps&quot;&gt;
&lt;code&gt;
dotnet watch run --environment Development
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入&lt;code&gt;Blog/src/UI/nm-module-blog&lt;/code&gt;目录，执行以下命令来启动前端代码&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;
npm install

npm update

npm run serve
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后在浏览器中输入 &lt;a href=&quot;http://localhost:6220&quot; class=&quot;uri&quot;&gt;http://localhost:6220&lt;/a&gt; 进行浏览&lt;/p&gt;
&lt;p&gt;接口文档地址 &lt;a href=&quot;http://localhost:6220/swagger/index.html&quot; class=&quot;uri&quot;&gt;http://localhost:6220/swagger/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果没有意外的话，应该可以了~&lt;/p&gt;
&lt;p&gt;原文首发：&lt;a href=&quot;https://iamoldli.github.io/2019/05/10/net-core-mo-kuai-hua-kai-fa-kuang-jia/2-kuai-su-chuang-jian-ye-wu-mo-kuai/&quot;&gt;ASP.NET Core模块化前后端分离快速开发框架介绍之2、快速创建一个业务模块&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 05:49:00 +0000</pubDate>
<dc:creator>oldli</dc:creator>
<og:description>源码地址 GitHub： 'https://github.com/iamoldli/NetModular' 演示地址(换了台新服务器，应该不怎么卡了~) 地址： 'http://129.211.40.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/oldli/p/10905415.html</dc:identifier>
</item>
<item>
<title>利用jenkins和docker实现持续交付 - 流星划过天际</title>
<link>http://www.cnblogs.com/zhaowei520/p/10905222.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaowei520/p/10905222.html</guid>
<description>

&lt;h2&gt;一.什么是持续交付&lt;/h2&gt;
&lt;p&gt;　　让软件产品的产出过程在一个短周期内完成，以保证软件可以稳定、持续的保持在随时可以发布的状况。它的目标在于让软件的构建、测试与发布变得更快以及更频繁。这种方式可以减少软件开发的成本与时间，减少风险。&lt;/p&gt;

&lt;h2&gt;二.对比持续交付和传统交付&lt;/h2&gt;
&lt;p&gt;　　传统交付的发布周期可以表示为下图：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522123044860-1156333181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;传统交付的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         慢交付:在这里，客户在指定需求之后很长时间才收到产品。这导致了不满意的上市时间和客户反馈的延迟。&lt;/p&gt;
&lt;p&gt;　　反馈周期长:反馈周期不仅与客户有关，还与开发人员有关。假设您意外地创建了一个bug，并在UAT阶段了解了它。修理你两个月前修过的东西需要多长时间?即使是很小的错误也会耗费数周的时间。&lt;/p&gt;
&lt;p&gt;　　危险的热修复程序:热修复程序通常不能等待完整的UAT阶段，因此它们的测试方式往往不同(UAT阶段缩短了)，或者根本没有测试。&lt;/p&gt;
&lt;p&gt;　　压力:对运营团队来说，无法预测的发布是有压力的。更重要的是，发布周期通常被安排得很紧，这给开发人员和测试人员带来了额外的压力。&lt;/p&gt;
&lt;p&gt;  　 为了能够持续地交付产品，而不是将大笔资金花在全天候工作的运营团队上，我们需要自动化。这就是为什么，连续交付就是将传统交付过程的每个阶段都更改为一系列脚本，称为自动部署管道或连续交付管道。&lt;/p&gt;
&lt;p&gt;　   然后，如果不需要手动步骤，我们可以在每次代码更改之后运行该流程，从而不断地将产品交付给用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续交付的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        &lt;/strong&gt; 快速交付:开发完成后，客户就可以使用产品，大大缩短了产品上市的时间。请记住，软件只有在用户手中才会带来收入。&lt;/p&gt;
&lt;p&gt;         快速反馈周期:假设您在代码中创建了一个bug，该bug在同一天投入生产。要花多少时间才能修好你当天工作的东西?可能没有那么多。这与快速回滚策略一起，是保持生产稳定的最佳方法。&lt;/p&gt;
&lt;p&gt;         低风险的发布:如果您每天都发布，那么这个过程就会变得可重复，因此更加安全。&lt;/p&gt;
&lt;p&gt;         灵活的发布选项:如果您需要立即发布，那么一切都已经准备好了，因此没有与发布决策相关的额外时间/成本。&lt;/p&gt;
&lt;p&gt;　　 不用说，我们可以通过消除所有交付阶段并直接在生产上进行开发来实现所有的好处。然而，这将导致质量下降。实际上，引入连续交付的全部困难在于担心质量会随着取消手工步骤而降低。我们将展示如何以一种安全的方式处理它，交付的产品不断地有更少的bug，并更好地适应客户的需求。&lt;/p&gt;

&lt;h2&gt;三.怎么实现持续交付&lt;/h2&gt;

&lt;p&gt;　　自动化部署管道，它包括如下图所示的三个阶段:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522123314326-1845731899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　每一步都对应着传统交付过程中的一个阶段，具体如下:&lt;/p&gt;
&lt;p&gt; 　　　   持续集成:检查以确保不同开发人员编写的代码集成在一起　　　　&lt;/p&gt;
&lt;p&gt;　　　　自动化验收测试:这将取代手工QA阶段，并检查开发人员实现的特性是否满足客户的需   求&lt;/p&gt;
&lt;p&gt;        　   配置管理:这将取代手工操作阶段——配置环境和部署软件&lt;/p&gt;
&lt;h3&gt;　　1.持续集成&lt;/h3&gt;
&lt;p&gt;　　　　持续集成阶段向开发人员提供第一个反馈。它从存储库(git,svn)中检出代码，编译代码，运行单元测试，并验证代码质量。如果任何步骤失败，则停止管道执行，开发人员应该做的第一件事是修复持续集成构建。&lt;/p&gt;

&lt;h3&gt;　　2.自动化验收测试&lt;/h3&gt;
&lt;p&gt;　　　　自动化验收测试阶段是和QAs一起编写的一组测试，这些测试应该替代手动UAT阶段。它作为一个质量检验关来决定一个产品是否准备好发布。如果任何验收测试失败，则停止管道执行，不再运行进一步的步骤。它阻止移动到配置管理阶段，从而阻止发布。&lt;/p&gt;

&lt;h3&gt;　　3.配置管理&lt;/h3&gt;
&lt;p&gt;　　　　配置管理阶段负责跟踪和控制软件及其环境中的更改。它涉及准备和安装必要的工具、扩展服务实例的数量及其分布、基础设施清单以及与应用程序部署相关的所有任务。&lt;/p&gt;
&lt;p&gt;　　　　配置管理是针对在生产环境中手动部署和配置应用程序所带来的问题的解决方案。配置管理工具(如Ansible、Chef或Puppet)支持在版本控制系统中存储配置文件，并跟踪在生产服务器上所做的每个更改。&lt;/p&gt;
&lt;p&gt;　　　　替代操作（运维）团队手工任务的另一项工作是负责应用程序监视。这通常是通过将运行系统的日志和指标流到一个公共仪表板来完成的，该仪表板由开发人员(或DevOps团队，如下一节所述)监视。&lt;/p&gt;

&lt;h2&gt;四.工具&lt;/h2&gt;
&lt;h3&gt;　　1.docker生态链&lt;/h3&gt;

&lt;p&gt;　　　　　　Docker作为集装箱化的领导者，近年来在软件行业占据了主导地位。它允许在与环境无关的映像中打包应用程序，因此将服务器视为一个资源场，而不是必须为每个应用程序配置的机器。&lt;/p&gt;
&lt;p&gt;　　　　　　Docker是一个明确选择，因为它非常适合(微)服务世界和持续交付过程。&lt;/p&gt;


&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;　2.jenkins&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　　　Jenkins是目前市场上最流行的自动化服务器。它有助于创建连续集成和连续交付管道，通常还有助于创建任何其他自动化的脚本。高度面向插件，它有一个伟大的社区，不断扩展它的新功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　　　更重要的是，它允许将管道编写为代码并支持分布式构建环境。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　3. Ansible&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　　　Ansible是一个自动化工具，可以帮助进行软件配置、配置管理和应用程序部署。它采用无代理的体系结构，并与Docker进行了良好的集成。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　4.gitHub&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　GitHub绝对是所有托管版本控制系统中排名第一的。它提供了一个非常稳定的系统，一个基于web的UI，以及一个公共存储库的免费服务。&lt;/p&gt;
&lt;p&gt;　　　　尽管如此，任何源代码控制管理服务或工具都可以使用连续交付，无论它是在云中还是自托管的，也无论它是基于Git、SVN、Mercurial或任何其他工具。&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522123922571-2140083727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 五.docker实战&lt;/h2&gt;

&lt;h3&gt;　　1.docker概述&lt;/h3&gt;

&lt;p&gt;　　　　Docker是一个开源项目，旨在帮助使用软件容器进行应用程序部署。以下引用自Docker官方页面:&lt;/p&gt;
&lt;p&gt;　　　　Docker容器将一段软件封装在一个完整的文件系统中，该文件系统包含运行所需的一切:代码、运行时、系统工具、系统库——任何可以安装在服务器上的东西。这保证了软件将始终运行相同的，不管它的环境如何。&lt;/p&gt;
&lt;p&gt;　　　　因此，Docker以类似于虚拟化的方式，允许将应用程序打包成可以在任何地方运行的映像。&lt;/p&gt;

&lt;h3&gt;　　2.虚拟化和容器化&lt;/h3&gt;

&lt;p&gt;　　　　没有Docker，使用硬件虚拟化(通常称为虚拟机)可以实现隔离和其他好处。最流行的解决方案是VirtualBox、VMware和Parallels。&lt;/p&gt;
&lt;p&gt;　　　　虚拟机模拟计算机体系结构并提供物理计算机的功能。如果每个应用程序都作为单独的虚拟机映像交付并运行，我们就可以实现应用程序的完全隔离。下图展示了虚拟化的概念:&lt;/p&gt;

&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522124128915-668818094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　每个应用程序都作为独立的映像启动，其中包含所有依赖项和客户操作系统。映像由虚拟机监控程序运行，虚拟机监控程序模拟物理计算机体系结构。&lt;/p&gt;
&lt;p&gt;　　　　许多工具(如Vagrant)都广泛支持这种部署方法，并致力于开发和测试环境。然而，虚拟化有三个显著的缺点:&lt;/p&gt;

&lt;p&gt;　　　　　　低性能:虚拟机模拟整个计算机体系结构来运行客户操作系统，因此每个操作都有很大的开销。&lt;/p&gt;
&lt;p&gt;　　　　　　高资源消耗:模拟需要大量的资源，并且必须为每个应用程序分别执行。这就是为什么在标准的台式机上，只有几个应用程序可以同时运行。&lt;/p&gt;
&lt;p&gt;　　　　　　大型映像:每个应用程序都使用完整的操作系统交付，因此在服务器上的部署意味着发送和存储大量数据。&lt;/p&gt;

&lt;p&gt;　　　　下面的图是docker带来的不同：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522124307731-215026166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;　　3.docker的安装　　&lt;/h3&gt;
&lt;p&gt;　　　　　　Docker的安装过程快速简单。目前，大多数Linux操作系统都支持它，其中很多都提供了专用的二进制文件。Mac和Windows也得到了本地应用程序的良好支持。&lt;/p&gt;
&lt;p&gt;　　　　　　但是，重要的是要理解Docker内部是基于Linux内核及其细节的，这就是为什么在Mac和Windows中，它使用虚拟机(Mac使用xhyve, Windows使用hyv)来运行Docker引擎环境。&lt;/p&gt;

&lt;p&gt;　　　　　　这里只说在linux上的Ubuntu 16.04操作(官方的命令)：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;sudo&lt;/span&gt; apt-&lt;span&gt;get update
$ &lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-key adv --keyserver hkp:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p80.pool.sks-keyservers.net:80 --recv-keys 9DC858229FC7DD38854AE2D88D81803C0EBFCD88&lt;/span&gt;
$ &lt;span&gt;sudo&lt;/span&gt; apt-add-repository &lt;span&gt;'&lt;/span&gt;&lt;span&gt;deb [arch=amd64] https://download.docker.com/linux/ubuntu xenial main stable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
$ &lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-&lt;span&gt;get update
$ &lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; -y docker-ce
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　　　如果提示报错：&lt;/p&gt;
&lt;p&gt; 　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522124522876-1944348023.png&quot; alt=&quot;&quot;/&gt;，可以再次执行下面的命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$ cd /etc/apt/&lt;span&gt;sources.list.d
$ &lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;vi&lt;/span&gt;&lt;span&gt; docker.list
     deb https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;download.docker.com/linux/ubuntu zesty edge&lt;/span&gt;
$&lt;span&gt;sudo&lt;/span&gt;&lt;span&gt; apt update
$&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt &lt;span&gt;install&lt;/span&gt; docker-ce　
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
　　　　　　这一次没有报错，但是发现太慢了，因为下载docker-ce比较大，并且是国外网站，这里可以改成国内源，指令如下：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt-&lt;span&gt;get update 
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; \ apt-transport-https \ ca-certificates \ curl \ software-properties-&lt;span&gt;common
curl &lt;/span&gt;-fsSL https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add&lt;/span&gt;
&lt;span&gt;sudo&lt;/span&gt; add-apt-&lt;span&gt;repository &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) &lt;/span&gt;stable&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-&lt;span&gt;get update 
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; docker-ce
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
　　　　测试是否安装完成：docker -v或者docker info可以看到docker一些基本信息表示安装成功了：&lt;br/&gt;　　　　
&lt;/pre&gt;
&lt;p&gt;                &lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522124901267-995138676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;　　4.运行docker&lt;/h3&gt;
&lt;p&gt;　　　　docker的环境已经安装完成，我们可以先运行一个非常经典的例子：hello world：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ docker run hello-world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　当你看到如下信息表示你运行正确了：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522125010834-1144465612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　让我们一步一步来看看引擎盖下面发生了什么:&lt;/p&gt;
&lt;p&gt;　　　　　　　　1.使用run命令运行Docker客户机。&lt;/p&gt;
&lt;p&gt;　　　　　　　　2.Docker客户机联系Docker守护进程，要求从名为hello-world的映像创建一个容器。&lt;/p&gt;
&lt;p&gt;　　　　　　　　3.Docker守护进程检查它是否在本地包含hello-world映像，因为它没有，所以从远程Docker Hub注册中心请求hello-world映像。&lt;/p&gt;
&lt;p&gt;　　　　　　　　4.Docker Hub注册表包含hello-world映像，因此将其拖放到Docker守护进程中。&lt;/p&gt;
&lt;p&gt;　　　　　　　　5.Docker守护进程从hello-world映像创建了一个新容器，该映像启动了生成输出的可执行文件。&lt;/p&gt;
&lt;p&gt;　　　　　　　　6.Docker守护进程将此输出流到Docker客户机。&lt;/p&gt;
&lt;p&gt;　　　　　　　　7.Docker客户机将其发送到您的终端。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522125116310-687447969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;　　5.构建镜像&lt;/h3&gt;

&lt;p&gt;　　　　构建镜像有2种方式：&lt;/p&gt;
&lt;p&gt;                   Docker commit命令和Dockerfile自动构建。我们来探讨下docker怎么构建镜像的。&lt;/p&gt;

&lt;p&gt;         　　我再这只说Dockerfile方式：&lt;/p&gt;
&lt;p&gt;　　　　　　使用commit命令手动创建每个Docker映像可能很费力，特别是在构建自动化和连续交 付过程的情况下。幸运的是，有一种内置语言可以指定构建Docker映像所需执行的所有指令。&lt;/p&gt;
&lt;p&gt; 　　　　　　1.创建DockerFile文件，并输入以下内容：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
FROM ubuntu:&lt;span&gt;16.04&lt;/span&gt;&lt;span&gt;
RUN apt&lt;/span&gt;-get update &amp;amp;&amp;amp;&lt;span&gt; \
    apt&lt;/span&gt;-get &lt;span&gt;install&lt;/span&gt; -y python
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
　　　　　　2.执行构建镜像命令：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker build -t ubuntu_with_python .
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　　　3. 我们可以通过命令：&lt;/p&gt;
&lt;p&gt;                   　　docker images看到我们创建了的镜像：&lt;/p&gt;
&lt;pre&gt;
　　　　　　
&lt;/pre&gt;
&lt;p&gt;                        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522125600063-1396798506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　 6.docker容器&lt;/h3&gt;
&lt;pre&gt;
　　　　
&lt;/pre&gt;
&lt;p&gt;　　　　我们可以通过命令：docker ps查看正在运行的容器，docker ps -a查看所有容器。容器是有状态的。&lt;/p&gt;
&lt;p&gt;         　　通过镜像来启动容器，并且查看容器的状态：&lt;/p&gt;
&lt;p&gt;              &lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522125709700-135863658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　停止docker容器是命令：docker stop 容器id&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522125738815-130440003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt; 　　 7.运行tomcat,使用外部访问&lt;/h3&gt;

&lt;p&gt; 　　　　1.运行tomcat镜像：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker run -d tomcat
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;11&quot;&gt;
&lt;pre&gt;
　　　　但是我们外部浏览器是访问不到tomcat 8080端口的，中间有虚拟机阻断了网络连接。
&lt;/pre&gt;
&lt;pre&gt;
       所以我们启动容器的时候，就要用-p指令来连接虚拟主机和docker容器的网络端口映射
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
　　　　2.-p启动&lt;br/&gt;　　　　
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run -d -p &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; tomcat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;strong&gt;在网页输入虚拟机&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;ip+&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;端口访问如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
　　
&lt;/pre&gt;
&lt;p&gt;                          &lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522125940604-163211631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;六.jenkins实战&lt;/h2&gt;
&lt;h3&gt;　　1.介绍jenkins&lt;/h3&gt;

&lt;p&gt;　　　　　 Jenkins是一个用Java编写的开源自动化服务器。由于非常活跃的基于社区的支持和大量的插件，它是实现持续集成和持续交付过程的最流行的工具。&lt;/p&gt;
&lt;p&gt;                   Jenkins优于其他持续集成工具，是同类软件中使用最广泛的。由于它的特性和功能，这一切都是可能的。&lt;/p&gt;

&lt;h3&gt;　　2.安装jenkins&lt;/h3&gt;


&lt;p&gt;Jenkins的安装过程快速而简单。有许多不同的方法可以做到这一点，但是由于我们已经熟悉Docker工具及其带来的好处，我们将从基于Docker的解决方案开始。这也是最简单、最可预测和最聪明的方法。&lt;/p&gt;
&lt;p&gt;                   jenkins的安装有一些环境要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;                     Java 8&lt;/li&gt;
&lt;li&gt;                     256MB free memory&lt;/li&gt;
&lt;li&gt;                     1 GB+ free disk space&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;                   然而，必须理解需求严格依赖于您计划使用Jenkins做什么。如果Jenkins用作整个团队的持续集成服务器，那么即使是小团队，也建议使用1gb +空闲内存和50gb +空闲磁盘空间。不用说，Jenkins还执行一些计算并在网络上传输大量数据，因此CPU和带宽是至关重要的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                   安装jenkins有两种方式：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                            1.使用docker镜像&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                            2.不使用docker镜像&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                   1.使用docker镜像安装jenkins&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                   使用命令：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre&gt;
             &lt;strong&gt;docker run -p &amp;lt;host_port&amp;gt;:8080 -v &amp;lt;host_volume&amp;gt;:/var/jenkins_home jenkins:2.60.1&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;                   在网页上输入网址，如图代表安装成功：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522132702143-446124828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　输入密码，是在日志中可以看到一个初始密码：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522132721438-545213964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　2.不使用docker镜像安装jenkins&lt;/p&gt;
&lt;p&gt;                   安装也非常简单，只需要执行以下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;wget&lt;/span&gt; -q -O - https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -&lt;/span&gt;
$ &lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;sh&lt;/span&gt; -c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;echo deb http://pkg.jenkins.io/debian-stable binary/ &amp;gt; /etc/apt/sources.list.d/jenkins.list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
$ &lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-&lt;span&gt;get update
$ &lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; jenkins
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　　　3.jenkins简单应用(hello world)&lt;/h3&gt;


&lt;p&gt;&lt;strong&gt;　　　　　　　&lt;/strong&gt;　让我们遵循这条规则，看看创建第一个Jenkins管道的步骤:&lt;/p&gt;
&lt;p&gt;                            单击New Item。&lt;/p&gt;
&lt;p&gt;                            输入hello world作为项目名称，选择Pipeline，然后单击OK。&lt;/p&gt;
&lt;p&gt;                            有很多选择。现在我们将跳过它们，直接进入管道部分。&lt;/p&gt;
&lt;p&gt;                            在脚本文本框中，我们可以输入流水线脚本:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;pipeline {
           agent any
           stages {
                stage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
                     steps {
                          &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                     }
                }
           }
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　　　点击保存，并且立即构建，我们可以在输出日志里面看到如下图：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522132931118-28124149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;七.持续集成管道&lt;/h2&gt;

&lt;h3&gt;　　　1.介绍管道&lt;/h3&gt;

&lt;p&gt;　　　　　　管道可以理解为一系列的自动化操作，可以看成是一个简单的脚本链：&lt;/p&gt;
&lt;p&gt;                            操作分组:将操作分组到各个阶段(也称为门或质量门)，这些阶段向流程引入一 个结构，并明确定义了规则:如果一个阶段失败，则不再执行其他阶段&lt;/p&gt;
&lt;p&gt;                            可见性:流程的所有方面都是可视化的，这有助于快速进行故障分析并促进团队协作&lt;/p&gt;
&lt;p&gt;                            反馈:团队成员在任何问题发生时都能及时了解，这样他们就能快速做出反应&lt;/p&gt;

&lt;h3&gt;　　　2.管道结构&lt;/h3&gt;

&lt;p&gt;　　　　　　Jenkins管道由两种元素组成:阶段和步骤。下图显示了如何使用它们：&lt;/p&gt;

&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522133153586-289341192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　　3.管道的hello world&lt;/h3&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;pipeline {
     agent any
     stages {
          stage(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;First Stage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
               steps {
                    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Step 1. Hello World&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
               }
          }
          stage(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Second Stage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
               steps {
                    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Step 2. Second time Hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                    &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Step 3. Third time Hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
               }
          }
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　　　立即构建成功后可以看到以下图：&lt;/p&gt;

&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1657327/201905/1657327-20190522133305844-651489187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;　　　4.管道规则&lt;/h3&gt;

&lt;p&gt;　　　　　 &lt;strong&gt;Agent&lt;/strong&gt;:它指定执行发生的位置，并可以定义标签来匹配标记相同的代理或docker，以指定动态准备的容器，以便为管道执行提供环境&lt;/p&gt;
&lt;p&gt;                   &lt;strong&gt;Triggers&lt;/strong&gt;:这定义了自动触发管道的方法，并可以使用cron设置基于时间的调度或pollScm来检查存储库中的更改(我们将在触发器和通知部分详细介绍)&lt;/p&gt;
&lt;p&gt;                   &lt;strong&gt;Options&lt;/strong&gt;:这指定了特定管道的选项，例如超时(管道运行的最大时间)或重试(失败后应该重新运行管道的次数)&lt;/p&gt;
&lt;p&gt;                   &lt;strong&gt;Environment&lt;/strong&gt;:这定义了一组关键值，在构建过程中用作环境变量&lt;/p&gt;
&lt;p&gt;                   &lt;strong&gt;Parameters&lt;/strong&gt;:这定义了一个用户输入参数列表&lt;/p&gt;
&lt;p&gt;                   &lt;strong&gt;Stage&lt;/strong&gt;:这允许对步骤进行逻辑分组&lt;/p&gt;
&lt;p&gt;                   &lt;strong&gt;When&lt;/strong&gt;:这决定是否应该根据给定的条件执行阶段&lt;/p&gt;

&lt;p&gt; 　这个就是最基础的一些知识，后续会发一些高级一点的特性。&lt;/p&gt;

</description>
<pubDate>Wed, 22 May 2019 05:36:00 +0000</pubDate>
<dc:creator>流星划过天际</dc:creator>
<og:description>利用jenkins和docker实现持续交付 一.什么是持续交付 让软件产品的产出过程在一个短周期内完成，以保证软件可以稳定、持续的保持在随时可以发布的状况。它的目标在于让软件的构建、测试与发布变得更</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaowei520/p/10905222.html</dc:identifier>
</item>
<item>
<title>Golang项目的测试实践 - 轩脉刃</title>
<link>http://www.cnblogs.com/yjf512/p/10905352.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjf512/p/10905352.html</guid>
<description>&lt;p&gt;最近有一个项目，链路涉及了4个服务。最核心的是一个配时服务。要如何对这个项目进行测试，保证输出质量，是最近思考和实践的重点。这篇就说下最近这个实践的过程总结。&lt;/p&gt;

&lt;p&gt;按照Mike Cohn提出的“测试金字塔”概念，测试分为4个层次&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/21/5ce34ea15584577479.png&quot; alt=&quot;test&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最下面是单元测试，单元测试对代码进行测试。再而上是集成测试，它对一个服务的接口进行测试。继而是端到端的测试，我也称他为链路测试，它负责从一个链路的入口输入测试用例，验证输出的系统的结果。再上一层是我们最常用的UI测试，就是测试人员在UI界面上根据功能进行点击测试。&lt;/p&gt;

&lt;p&gt;对于一个Golang写的服务，单元测试已经是很方便了。我们在写一个文件，函数的时候，可以直接在需要单元测试的文件旁边增加一个_test.go的文件。而后直接使用 &lt;code&gt;go test&lt;/code&gt; 直接跑测试用例就可以了。&lt;/p&gt;
&lt;p&gt;一般单元测试，最直接的衡量标准就是代码覆盖率。&lt;/p&gt;
&lt;p&gt;单元测试一般测试的对象是一个函数，一个类。&lt;/p&gt;
&lt;p&gt;这个部分已经有很多实践例子了，就没什么好聊的。&lt;/p&gt;

&lt;h2 id=&quot;思考和需求&quot;&gt;思考和需求&lt;/h2&gt;
&lt;p&gt;对于一个服务，会提供多个接口，那么，测试这些接口的表现就是集成测试最重要的目标了。只有通过了集成测试，我们的这个服务才算是有保障。&lt;/p&gt;
&lt;p&gt;手头这个配时项目，对外提供的是一系列HTTP服务，基本上代码是以MVC的形式架构的。在思考对它的集成测试过程中，我希望最终能做到下面几点：&lt;/p&gt;
&lt;p&gt;首先，我希望我手上这个配时服务的集成测试是自动化的。最理想的情况下，我能调用一个命令，直接将所有case都跑一遍。&lt;/p&gt;
&lt;p&gt;其次，衡量集成测试的达标指标。这个纠结过一段时间，是否需要有衡量指标呢？还是直接所有case通过就行？我们的服务，输入比较复杂，并不是简单的1-2个参数，是一个比较复杂的json。那么这个json的构造有各种各样的。需要实现写一些case，但是怎么保证我的这些case是不是有漏的呢？这里还是需要有个衡量指标的，最终我还是选择用代码覆盖率来衡量我的测试达标情况，但是这个代码覆盖率在MVC中，我并不强制要求所有层的所有代码都要覆盖住，主要是针对Controller层的代码。controller层主要是负责流程控制的，需要保证所有流程分支都能走到。&lt;/p&gt;
&lt;p&gt;然后，我希望集成测试中有完善的测试概念，主要是TestCase， TestSuite，这里参考了JUnit的一些概念。TestCase是一个测试用例，它提供测试用例启动和关闭时候的注入函数，TestSuite是一个测试套件，代表的是一系列类似的测试用例集合，它也带测试套件启动和关闭时候的注入函数。&lt;/p&gt;
&lt;p&gt;最后，可视化需求。我希望这个测试结果很友好，能有一个可视化的测试界面，我能很方便知道哪个测试套件，哪个测试用例中的哪个断言失败了。&lt;/p&gt;
&lt;h2 id=&quot;集成测试实践&quot;&gt;集成测试实践&lt;/h2&gt;
&lt;p&gt;Golang 只有_test.go的测试，其中的每个Test_XXX相当于是TestCase的概念，也没有提供测试case启动，关闭执行的注入函数，也没有TestSuite的概念。首先我需要使用 Golang 的test搭建一个测试架子。&lt;/p&gt;
&lt;p&gt;集成测试和单元测试不一样，它不属于某个文件，集成测试可能涉及到多个文件中多个接口的测试，所以它需要有一个单独的文件夹。它的目录结构我是这么设计的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/21/5ce3657dcc3c146792.png&quot; alt=&quot;tester_folder&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;suites&quot;&gt;suites&lt;/h3&gt;
&lt;p&gt;存放测试套件&lt;/p&gt;
&lt;h3 id=&quot;suitesxxx&quot;&gt;suites/xxx&lt;/h3&gt;
&lt;p&gt;这里存放测试套件，测试套件文件夹需要包含下列文件：&lt;/p&gt;
&lt;p&gt;before.go存放有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SetUp() 函数，这个函数在Suite运行之前会运行&lt;/li&gt;
&lt;li&gt;Before() 函数，这个函数在所有Case运行之前运行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;after.go存放有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TearDown() 函数，这个函数在Suite运行之后会运行&lt;/li&gt;
&lt;li&gt;After() 函数，这个函数在Suite运行之后运行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;run_test.go文件&lt;/p&gt;
&lt;p&gt;这个文件是testsuite的入口，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package adapt

import &quot;testing&quot;
import . &quot;github.com/smartystreets/goconvey/convey&quot;

func TestRunSuite(t *testing.T) {
    SetUp()
    defer TearDown()
    Convey(&quot;初始化&quot;, t, nil)

    runCase(t, NormalCasePEE001)
    runCase(t, PENormalCase01)
    runCase(t, PENormalCase04)
    runCase(t, PENormalCase11)
    runCase(t, PENormalCase13)
    runCase(t, PENormalCase14)
    runCase(t, NormalCasePIE001)
    runCase(t, NormalCasePIE002)
    runCase(t, NormalCase01)
    runCase(t, NormalCase02)
    runCase(t, NormalCase07)
    runCase(t, NormalCase08)
    runCase(t, NormalCasePIN003)
    runCase(t, NormalCasePIN005)
    runCase(t, NormalCasePIN006)
    runCase(t, NormalCasePIN015)

}

func runCase(t *testing.T, testCase func(*testing.T)) {
    Before()
    defer After()

    testCase(t)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;envionment&quot;&gt;envionment&lt;/h3&gt;
&lt;p&gt;初始化测试环境的工具&lt;/p&gt;
&lt;p&gt;当前我这里面存放了初始化环境的配置文件和db的建表文件。&lt;/p&gt;
&lt;h3 id=&quot;report&quot;&gt;report&lt;/h3&gt;
&lt;p&gt;存放报告的地址&lt;/p&gt;
&lt;p&gt;代码覆盖率需要额外跑脚本&lt;/p&gt;
&lt;p&gt;在tester目录下运行：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sh coverage.sh&lt;/code&gt; 会在report下生成coverage.out和coverage.html，并自动打开浏览器&lt;/p&gt;
&lt;h2 id=&quot;引入convey&quot;&gt;引入Convey&lt;/h2&gt;
&lt;p&gt;关于可视化的需求。&lt;/p&gt;
&lt;p&gt;我引入了Convey这个项目，&lt;a href=&quot;http://goconvey.co/&quot; class=&quot;uri&quot;&gt;http://goconvey.co/&lt;/a&gt; 。第一次看到这个项目，觉得这个项目的脑洞真大。&lt;/p&gt;
&lt;p&gt;下面可了劲的夸一夸这个项目的优点：&lt;/p&gt;
&lt;h3 id=&quot;断言&quot;&gt;断言&lt;/h3&gt;
&lt;p&gt;首先它提供了基于原装go test的断言框架；提供了Convey和So两个重要的关键字，还提供了 Shouldxxx等一系列很好用的方法。它的测试用例写下来像是这个样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package package_name

import (
    &quot;testing&quot;
    . &quot;github.com/smartystreets/goconvey/convey&quot;
)

func TestIntegerStuff(t *testing.T) {
    Convey(&quot;Given some integer with a starting value&quot;, t, func() {
        x := 1

        Convey(&quot;When the integer is incremented&quot;, func() {
            x++

            Convey(&quot;The value should be greater by one&quot;, func() {
                So(x, ShouldEqual, 2)
            })
        })
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很清晰明了，并且超赞的是很多参数都使用函数封装起来了，go中的 := 和 = 的问题能很好避免了。并且不要再绞尽脑汁思考tmp1,tmp2这种参数命名了。（因为都已经分散到Convey语句的func中了）&lt;/p&gt;
&lt;h3 id=&quot;web界面&quot;&gt;Web界面&lt;/h3&gt;
&lt;p&gt;其次，它提供了一个很赞的Web平台，这个web平台有几个点我非常喜欢。首先它有一个case编辑器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/21/5ce36937c732851354.png&quot; alt=&quot;convy-edit&quot;/&gt;&lt;/p&gt;
&lt;p&gt;什么叫好的测试用例实践? 我认为这个编辑器完全体现出来了。写一个完整的case先考虑流程和断言，生成代码框架，然后我们再去代码框架中填写具体的逻辑。这种实践步骤很好解决了之前写测试用例思想偷懒的问题，特别是断言，基本不会由于偷懒而少写。&lt;/p&gt;
&lt;p&gt;其次它提供很赞的测试用例结果显示页面：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/05/21/5ce36aecaff8497245.png&quot; alt=&quot;goconvey-img&quot;/&gt;&lt;br/&gt;很赞吧，哪个case错误，哪个断言问题，都很清楚显示出来。&lt;/p&gt;
&lt;p&gt;还有，goconvey能监控你运行测试用例的目录，当目录中有任何文件改动的时候，都会重新跑测试用例，并且提供提醒&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/21/5ce36bbc83d0036844.jpg&quot; alt=&quot;goconve-notice&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个真是太方便了，可以在每次保存的时候，都知道当前写的case是否有问题，能直接提高测试用例编写的效率。&lt;/p&gt;
&lt;h2 id=&quot;testsuite初始化&quot;&gt;TestSuite初始化&lt;/h2&gt;
&lt;p&gt;Web服务测试的环境是个很大问题。特别是DB依赖，这里不同的人有不同的做法。有使用model mock的，有使用db的。这里我的经验是：集成测试尽量使用真是DB，但是这个DB应该是私有的，不应该是多个人共用一个DB。&lt;/p&gt;
&lt;p&gt;所以我的做法，把需要初始化的DB结构使用sql文件导出，放在目录中。这样，每个人想要跑这一套测试用例，只需要搭建一个mysql数据库，倒入sql文件，就可以搭建好数据库环境了。其他的初始化数据等都在TestSuite初始化的SetUp函数中调用。&lt;/p&gt;
&lt;p&gt;关于保存测试数据环境，我这里有个小贴士，在SetUp函数中实现 清空数据库+初始化数据库 ，在TearDown函数中不做任何事情。这样如果你要单独运行某个TestSuite，能保持最后的测试数据环境，有助于我们进行测试数据环境测试。&lt;/p&gt;
&lt;h2 id=&quot;testcase编写&quot;&gt;TestCase编写&lt;/h2&gt;
&lt;p&gt;在集成测试环境中，TestCase编写调用HTTP请求就是使用正常的 httptest包，其使用方式没有什么特别的。&lt;/p&gt;
&lt;h2 id=&quot;代码覆盖率&quot;&gt;代码覆盖率&lt;/h2&gt;
&lt;p&gt;goconvey有个小问题，测试覆盖率是根据运行goconvey的目录计算的，不能额外设置，但是go test是提供的。所以代码覆盖率我还额外写了一个shell脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash

go test  -coverpkg xxx/controllers/... -coverprofile=report/coverage.out ./...
go tool cover -html=report/coverage.out -o report/coverage.html
open report/coverage.html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要就是使用converpkg参数，把代码覆盖率限制在controller层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/21/5ce36eb964db211138.png&quot; alt=&quot;tester-coverage&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;集成测试总结&quot;&gt;集成测试总结&lt;/h2&gt;
&lt;p&gt;这套搭建实践下来，对接口的代码测试有底很多了，也测试出不少controller层面的bug。&lt;/p&gt;

&lt;p&gt;这个是测试金字塔的第二层了。&lt;/p&gt;
&lt;p&gt;关于端到端的测试，我的理解就是全链路测试。从整个项目角度来看，它属于一个架构的层次了，需要对每个服务有一定的改造和设计。这个测试需要保证的是整个链路流转是按照预期的。&lt;/p&gt;
&lt;p&gt;比如我的项目的链路通过了4个服务，一个请求可能在多个服务之间进行链路调用。但是这个项目特别的是，这些服务并不都是一个语言的。如何进行测试呢？&lt;/p&gt;
&lt;p&gt;理想的端到端测试我的设想是这样的，测试人员通过postman调用最上游的服务，构造不同的请求参数和case，有的case其实可能无法通到最下游，那么就需要有一个全链路日志监控系统，在这个系统可以看到这个请求在各个服务中的流转情况。全链路日志监控系统定义了一套tag和一个traceid，要求所有服务在打日志的时候带上这个traceid，和当前步骤的tag，日志监控系统根据这些日志，在页面上能很好反馈出这个链路。&lt;/p&gt;
&lt;p&gt;然后测试人员每个case，就根据返回的traceid，去日志中查找，并且确认链路中的tag是否都全齐。&lt;/p&gt;
&lt;p&gt;关于如何在各个服务中传递traceid，这个很多微服务监控的项目中都已经说过了，我也是一样的做法，在http的header头中增加这个traceId。&lt;/p&gt;
&lt;p&gt;关于打日志的地方，其实有很多地方都可以打日志，但是我只建议在失败的地方+请求的地方打上tag日志，并且是由调用方进行tag日志记录，这样主要是能把请求和返回都记录，方便调试，查错等问题。&lt;/p&gt;

&lt;p&gt;这个目前还是让测试人员手动进行点击。这种方式看起来确实比较low，但是貌似也是目前大部分互联网公司的测试方法了。&lt;/p&gt;

&lt;p&gt;这几周主要是在集成测试方面做了一些实践，有一些想法和思路，所以拿出来进行了分享，肯定还有很多不成熟的地方没有考虑到，欢迎评论留言讨论。&lt;/p&gt;
&lt;p&gt;测试是一个费时费力的工作，大多数情况下，业务的迭代速度估计都不允许做很详细的测试。但是对于复杂，重要的业务，强烈建议这四层的测试都能做到，这样代码上线才能有所底气。&lt;/p&gt;
</description>
<pubDate>Wed, 22 May 2019 05:23:00 +0000</pubDate>
<dc:creator>轩脉刃</dc:creator>
<og:description>Golang项目的测试实践 最近有一个项目，链路涉及了4个服务。最核心的是一个配时服务。要如何对这个项目进行测试，保证输出质量，是最近思考和实践的重点。这篇就说下最近这个实践的过程总结。 测试金字塔</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjf512/p/10905352.html</dc:identifier>
</item>
<item>
<title>angular源码剖析之Provider系列--QProvider - john23.net</title>
<link>http://www.cnblogs.com/johnwonder/p/10905277.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/johnwonder/p/10905277.html</guid>
<description>&lt;h2 id=&quot;qprovider-简介&quot;&gt;QProvider 简介&lt;/h2&gt;
&lt;p&gt;源码里是这么描述的：&lt;/p&gt;
&lt;p&gt;A service that helps you run functions asynchronously, and use their return values (or exceptions) when they are done processing.&lt;/p&gt;
&lt;p&gt;大概意思是帮助你异步执行方法，且当他们执行完后可以使用他们的返回值。&lt;/p&gt;
&lt;p&gt;This is an implementation of promises/deferred objects inspired by Kris Kowal's Q.&lt;/p&gt;
&lt;p&gt;这是一个 promises/deferred 对象的实现,灵感来自于 &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Kris Kowal's Q&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;qprovider-用法&quot;&gt;QProvider 用法&lt;/h2&gt;
&lt;p&gt;下面的例子假设$q和asyncGreet在当前作用域内是有效的.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    function asyncGreet(name) {
    // perform some asynchronous operation, resolve or reject the promise when appropriate.
    return $q(function(resolve, reject) {
      setTimeout(function() {
        if (okToGreet(name)) {
          resolve('Hello, ' + name + '!');
        } else {
          reject('Greeting ' + name + ' is not allowed.');
        }
      }, 1000);
    });
    }

    var promise = asyncGreet('Robin Hood');
    //then函数放入pending数组
    promise.then(function(greeting) {
    alert('Success: ' + greeting);
    }, function(reason) {
    alert('Failed: ' + reason);
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们深入源码内部去一探究竟：&lt;/p&gt;
&lt;h2 id=&quot;qprovider-定义&quot;&gt;$QProvider 定义&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  function $QProvider() {

    this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
      return qFactory(function(callback) {
        $rootScope.$evalAsync(callback);
      }, $exceptionHandler);
    }];
  }

  $evalAsync: function(expr, locals) {
       // if we are outside of an $digest loop and this is the first time we are scheduling async
       // task also schedule async auto-flush
       //如果当前不处于$digest或者$apply的过程中(只有在$apply和$digest方法中才会设置$$phase这个字段)，并且asyncQueue数组中还不存在任务时，
       //就会异步调度一轮digest循环来确保asyncQueue数组中的表达式会被执行
       if (!$rootScope.$$phase &amp;amp;&amp;amp; !asyncQueue.length) {
         $browser.defer(function() {
           //最终调用的是setTimeout
           if (asyncQueue.length) {
             $rootScope.$digest();//执行消化功能
           }
         });
       }
       asyncQueue.push({scope: this, expression: $parse(expr), locals: locals});
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由之前 &lt;a href=&quot;http://johnwonder.coding.me/2018/03/01/angular-provider-cachefactory/&quot;&gt;cacheFactory的分析&lt;/a&gt;&lt;br/&gt;，再结合上面源码我们就知道 注入$q时调用了qFactory工厂方法：&lt;/p&gt;
&lt;h2 id=&quot;qfactory&quot;&gt;qFactory&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  function qFactory(nextTick, exceptionHandler) {

      function Promise() {
      //初始化Promise的状态对象
      this.$$state = { status: 0 };
    }
    //扩展Promise类原型
    extend(Promise.prototype, {
      //then主要是把一个defer对象和fullfiled reject 函数 放入pending数组
      then: function(onFulfilled, onRejected, progressBack) {
        if (isUndefined(onFulfilled) &amp;amp;&amp;amp; isUndefined(onRejected) &amp;amp;&amp;amp; isUndefined(progressBack)) {
          return this;
        }
        var result = new Deferred();

        this.$$state.pending = this.$$state.pending || [];
        //把一个新的 Defer 对象push进pending数组
        this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);

        if (this.$$state.status &amp;gt; 0) scheduleProcessQueue(this.$$state);

        //返回这个新建Defer对象的promise
        //可以形成promise chain
        return result.promise;
      }
      //代码省略
    }
    //通过$q注入时返回Q函数
    //随后Q函数 传入resolver参数调用
    //调用resolver函数时传入包装deferred对象的resolve和 reject函数
    //随后返回promise对象
    //promise对象调用then函数时放入pending队列
    var $Q = function Q(resolver) {
       if (!isFunction(resolver)) {
         throw $qMinErr('norslvr', &quot;Expected resolverFn, got '{0}'&quot;, resolver);
       }
       //构造一个Deferred对象
       var deferred = new Deferred();
       function resolveFn(value) {
         deferred.resolve(value);
       }
       function rejectFn(reason) {
         deferred.reject(reason);
       }
        //调用resolver参数函数
        //resolveFn供外部调用
       resolver(resolveFn, rejectFn);
       //返回一个promise对象
       //供调用then函数
       return deferred.promise;
     };
      // Let's make the instanceof operator work for promises, so that
      // `new $q(fn) instanceof $q` would evaluate to true.
      //使得new $q(fn) 也可以调用promise的方法
      $Q.prototype = Promise.prototype;

      //暴露内部方法
      $Q.defer = defer;
      $Q.reject = reject;
      $Q.when = when;
      $Q.resolve = resolve;
      //$q.all是用于执行多个异步任务进行回调，它可以接受一个promise的数组，
      //或是promise的hash(object)。任何一个promise失败，都会导致整个任务的失败。
      //https://blog.csdn.net/shidaping/article/details/52398925
      $Q.all = all;
      //$q.race() 是 Angular 里面的一个新方法，和 $q.all() 类似，但是它只会返回第一个处理完成的 Promise 给你///。假定 API 调用 1 和 API 调用 2 同时执行，而 API 调用 2 在 API 调用 1 之前处理完成，那么你就只会得到 //API 调用 2 的返回对象。换句话说，最快（处理完成）的 Promise 会赢得返回对象的机会：
      $Q.race = race;

      return $Q;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用then方法时实际上是新建一个defer对象放入pending数组，在调用defer.resolve的时候&lt;br/&gt;去调度这个数组中的元素，也就是任务.&lt;/p&gt;
&lt;h2 id=&quot;resolve-方法&quot;&gt;resolve 方法&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  extend(Deferred.prototype, {
    resolve: function(val) {
      //第一次resolve的时候为0 所以会往下走
      if (this.promise.$$state.status) return;
      if (val === this.promise) {
        this.$$reject($qMinErr(
          'qcycle',
          &quot;Expected promise to be resolved with value other than itself '{0}'&quot;,
          val));
      } else {
        //调度pending数组里的任务
        this.$$resolve(val);
      }
    },

    $$resolve: function(val) {
      var then;
      var that = this;
      var done = false;
      try {
        if ((isObject(val) || isFunction(val))) then = val &amp;amp;&amp;amp; val.then;
        if (isFunction(then)) {
           //val.then方法 val是promise的时候
           //resolvePromise函数里放入了当前defer对象
          this.promise.$$state.status = -1;
          then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify));
        } else {

          //更新promise的状态对象
          this.promise.$$state.value = val;
          this.promise.$$state.status = 1;
          //调度的时候pending为空就返回了
          scheduleProcessQueue(this.promise.$$state);
        }
      } catch (e) {
        rejectPromise(e);
        exceptionHandler(e);
      }

      function resolvePromise(val) {
        if (done) return;
        done = true;
        that.$$resolve(val);
      }
      function rejectPromise(val) {
        if (done) return;
        done = true;
        that.$$reject(val);
      }
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;scheduleprocessqueue-方法&quot;&gt;scheduleProcessQueue 方法&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  //传入promise的state对象
  function scheduleProcessQueue(state) {
   if (state.processScheduled || !state.pending) return;
   state.processScheduled = true;
   //nextTick里调用$browser.defer函数

   nextTick(function() { processQueue(state); });
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;processqueue-方法&quot;&gt;processQueue 方法&lt;/h3&gt;
&lt;p&gt;实际最终处理的还是processQueue函数，里面循环调用pending数组&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  function processQueue(state) {
    var fn, deferred, pending;

    pending = state.pending;
    state.processScheduled = false;
    state.pending = undefined;
    for (var i = 0, ii = pending.length; i &amp;lt; ii; ++i) {

      //获取pending数组的元素 元素本身也是数组
      deferred = pending[i][0];
      fn = pending[i][state.status];
      try {
        if (isFunction(fn)) {
          deferred.resolve(fn(state.value));
        } else if (state.status === 1) {
          deferred.resolve(state.value);
        } else {
          deferred.reject(state.value);
        }
      } catch (e) {
        deferred.reject(e);
        exceptionHandler(e);
      }
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/64521/201905/64521-20190522125659365-657973283.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的微信公众号，获取最新源码解析文章！&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/stefanpenner/es6-promise/&quot;&gt;a tiny implementation of Promises/A+.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ZengYunChun/p/6438330.html&quot;&gt;Angular中的$q的形象解释及深入用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/58465c4979bc440065c6e720&quot;&gt;关于 Angular 里的 $q 和 Promise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://glumes.com/post/android/understand-state-machine/?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&quot;&gt;理解状态机&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 22 May 2019 04:59:00 +0000</pubDate>
<dc:creator>john23.net</dc:creator>
<og:description>QProvider 简介 源码里是这么描述的： A service that helps you run functions asynchronously, and use their return</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/johnwonder/p/10905277.html</dc:identifier>
</item>
<item>
<title>住手，请放开你的“思维” - wc的一些事一些情</title>
<link>http://www.cnblogs.com/wcd144140/p/10905212.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wcd144140/p/10905212.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;    在5月17日《每日一句》的收藏中我记录了这么一句话，&lt;strong&gt;“我不是天才。我有几点聪明，我只不过就留在这几点里面”&lt;/strong&gt;，这句话是IBM创始人兼CEO托马斯·沃森所说。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;    同时，让我想起了在1月27日记录了爱默生这样一段话：&lt;strong&gt;“忌妒等于无知，模仿无异于自杀，一个人不管好坏，必须把自己看作自己的命运，虽然广阔的宇宙不乏善举，可是若不在自己得到的那块土地上辛勤耕耘，一粒富有营养的粮食也不会自行送上门来”&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;    以及，加上查理·芒格和沃伦·巴菲特前段时间股东大会大热的观念之一：&lt;strong&gt;“每个人都有自己的能力圈，要扩大那个能力圈非常困难。你必须在自己的能力圈之内竞争。你专注的领域越小越好”&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;　　以上众多的“成功理论”以及加上自己个人长期实践的感想抽象得出：&lt;strong&gt;做自己所擅长&lt;/strong&gt;。因此，这个通过自己实践和思考沉淀的“个人基础观点”影响着我在“管理”层面一个基础原则的形成：&lt;strong&gt;挖掘别人的优点&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201905/758472-20190522122114484-1064481261.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        芒格在上面也表态了，专注的领域越小越好。我个人觉得吧，但凡给别人留下抽象，每个人对这抽象的实现范围肯定是不一样的。有的人觉得专注自己在&lt;strong&gt;&lt;em&gt;“我要做一个有价值的人”&lt;/em&gt;&lt;/strong&gt;就好，有的人发誓自己要一辈子专注在&lt;strong&gt;&lt;em&gt;“IT行业”&lt;/em&gt;&lt;/strong&gt;，有的人觉得&lt;strong&gt;&lt;em&gt;“程序员”&lt;/em&gt;&lt;/strong&gt;注定是自己一辈子的职业。当然，这几个具体的想法都是自己对自己负责任的一个实现目标，有一个能让自己持续执行的目标已经领先很多人了。就像我的一个同事，他对他自身适合做项目经理上的“自我认知”是我们开始合作的基础，他对自己定位上的专注与坚定非常值得尊重，在我们共同合作的过程当中，他的这个优势也发挥得淋漓尽致，这是我们能够共赢的一种合作模式。每个人都有自己的缺点，但我的职责不是去挖掘他的缺点，而是最大地发挥他的优点。所以，对于近期一些关于他个人在工作上的想法，我觉得还是值得拿出来一起探讨和相互促进。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201905/758472-20190522122209814-470250770.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        我觉得吧，职能的职责范围会因企业的组织架构和经营模式的差异而有所不同，而企业组织架构的各种职责又会因为自身的业务发展和适应市场所需而不断地在完善当中。就像我们部门在不久前对“项目经理小组”职能的职责范围进行了调整，覆盖了“需求职能”的管理同时还要涵盖了部门售前和售后的大部分职责。当然，这不是一个人可以拍的脑袋，而是在所有信息高度对等的情况下再结合自身组织问题和公司业务发展所需而共同决定做出的决策。职能范围的增加往往意味着责任和工作量会大大增加，能在这样一个隐藏的明显事实下大家还能无疑义地达成这个共识，我十分为我能在这个团队工作而感到骄傲。矛盾和冲突是我为这个决策所做好的心理准备，但找到我的第一个问题不是工作量太大或者哪个环节不通畅，而是以上这位项目经理的担心：&lt;strong&gt;当前过多售前售后工作的占比慢慢侵蚀和弱化了他作为项目经理本职该有的核心工作技能&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201905/758472-20190522122230869-732809142.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        以上这位项目经理的担心让我想起了不久前跟另外一位女同事吃饭时的一些观点碰撞，她一直始终认为“选择比努力重要”，对于她的这个观点我是认同的，但我不知道她是否知道“选择”的背后其实就是自己三观的综合体现，我更担心的是她是否会错误地把“选择”和“努力”看成鱼和熊掌之分并认为自己“选择”对了就可以减少以后“努力”的付出。我觉得吧，我们很容易有这样一个错误认知，就是觉得自己掌握了&lt;strong&gt;“一点”&lt;/strong&gt;就觉得自己掌握了&lt;strong&gt;“全部”&lt;/strong&gt;，而不再愿意花费更多的精力深入探讨并陷入“拍脑袋”这种主观且被动的局面。对于那位项目经理的担忧，我能做的只能“抛身引玉”。我跟他说，我目前给自己的定位还只是一个‘“程序员”，在公司干了这么多年，我从“程序员”干到现在“部门经理”这个角色，同时，近年来还披着“项目总监”的皮去干“销售”，但这些所谓的“角色”从来都不会影响我以“代码”为中心点出发，去探索整个&lt;strong&gt;“业务价值链”&lt;/strong&gt;以及&lt;strong&gt;“跨领域学习”&lt;/strong&gt;的渴望。我跑市场的经历让我每个月下来积累的那两行代码比我以前写的几千行代码有价值多了。我不确保自己的观点是正确的，既然我们一起努力一起进步，我希望我自己的观点能给这位同事带来个人观点上的一些触碰吧。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201905/758472-20190522122633549-2076171603.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 22 May 2019 04:27:00 +0000</pubDate>
<dc:creator>wc的一些事一些情</dc:creator>
<og:description>在5月17日《每日一句》的收藏中我记录了这么一句话，“我不是天才。我有几点聪明，我只不过就留在这几点里面”，这句话是IBM创始人兼CEO托马斯·沃森所说。 同时，让我想起了在1月27日记录了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wcd144140/p/10905212.html</dc:identifier>
</item>
</channel>
</rss>