<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>sklearn中的pipeline实际应用 - 快到皖里来</title>
<link>http://www.cnblogs.com/pythonfl/p/14424136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonfl/p/14424136.html</guid>
<description>&lt;h5 id=&quot;前面提到，应用sklearn中的pipeline机制的高效性；本文重点讨论pipeline与网格搜索在机器学习实践中的结合运用：&quot;&gt;前面提到，应用sklearn中的pipeline机制的高效性；本文重点讨论pipeline与网格搜索在机器学习实践中的结合运用：&lt;/h5&gt;
&lt;h2 id=&quot;结合管道和网格搜索以调整预处理步骤以及模型参数&quot;&gt;结合管道和网格搜索以调整预处理步骤以及模型参数&lt;/h2&gt;
&lt;p&gt;一般地，sklearn中经常用到网格搜索寻找应用模型的超参数；实际上，在训练数据被送入模型之前，对数据的预处理中也会有超参数的介入，比如给数据集添加多项式特征时所指定的指数大小；&lt;/p&gt;
&lt;p&gt;而且，一般都是将数据预处理完成后再传入估计器进行拟合，此时利用网格搜索只会单独调整估计器的超参数；如若利用pipeline结合预处理步骤和模型估计器则可以同时寻找最佳的超参数配对。&lt;/p&gt;
&lt;p&gt;实例如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1875829/202102/1875829-20210221082207299-581361872.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，利用管道结合了3个处理步骤，并使用网格搜索机制针对其中两个步骤的超参数进行调优，一个是预处理阶段的PolynomialFeatures，另一个是模型Ridge&lt;/p&gt;
&lt;h2 id=&quot;结合管道和网格搜索以选定模型&quot;&gt;结合管道和网格搜索以选定模型&lt;/h2&gt;
&lt;p&gt;一般地，选用不同的模型会涉及到不同的预处理步骤，如采用随机森林进行分类训练时可以不对数据作预处理操作，而应用支持向量机时则需要对数据进行标准化；&lt;/p&gt;
&lt;p&gt;下图中，利用管道结合预处理中的标准化步骤和分类模型，当模型采用随机森林时，预处理步骤置空，并利用网格搜索寻找随机森林的超参数；当模型采用支持向量机时，启用预处理步骤，并利用网格搜索寻找支持向量机的超参数。&lt;/p&gt;
&lt;p&gt;通过此种结合应用，选定最适合的分类模型。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1875829/202102/1875829-20210221083705351-1799757543.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Feb 2021 00:43:00 +0000</pubDate>
<dc:creator>快到皖里来</dc:creator>
<og:description>#####前面提到，应用sklearn中的pipeline机制的高效性；本文重点讨论pipeline与网格搜索在机器学习实践中的结合运用： ##结合管道和网格搜索以调整预处理步骤以及模型参数 一般地，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pythonfl/p/14424136.html</dc:identifier>
</item>
<item>
<title>【SpringMVC】 4.2 异常处理 - 二七零零</title>
<link>http://www.cnblogs.com/chuchq/p/14423893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chuchq/p/14423893.html</guid>
<description>&lt;p&gt;&lt;strong&gt;SpringMVC学习记录&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：以下内容是学习 &lt;em&gt;&lt;strong&gt;北京动力节点&lt;/strong&gt;&lt;/em&gt; 的SpringMVC视频后所记录的笔记、源码以及个人的理解等，记录下来仅供学习&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;42异常处理&quot;&gt;4.2异常处理&lt;/h2&gt;
&lt;p&gt; SpringMVC框架处理异常的常用方式：使用@ExceptionHandler注解处理异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常处理步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建maven web项目&lt;/li&gt;
&lt;li&gt;加入依赖&lt;/li&gt;
&lt;li&gt;新建一个自定义异常类 MyUserException , 再定义它的子类NameException ,AgeException&lt;/li&gt;
&lt;li&gt;在controller抛出NameException , AgeException&lt;/li&gt;
&lt;li&gt;创建一个普通类，作用全局异常处理类&lt;br/&gt;(1). 在类的上面加入@ControllerAdvice&lt;br/&gt;(2). 在类中定义方法，方法的上面加入@ExceptionHandler&lt;/li&gt;
&lt;li&gt;创建处理异常的视图页面&lt;/li&gt;
&lt;li&gt;.创建springmvc的配置文件&lt;br/&gt;(1).组件扫描器 ，扫描@Controller注解&lt;br/&gt;(2).组件扫描器，扫描@ControllerAdvice所在的包名&lt;br/&gt;(3).声明注解驱动&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;项目结构：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2130787/202102/2130787-20210220234121298-1965551078.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;421-exceptionhandler-注解&quot;&gt;4.2.1 @ExceptionHandler 注解&lt;/h3&gt;
&lt;p&gt; 使用注解@ExceptionHandler可以将一个方法指定为异常处理方法。该注解只有一个可 选属性value,为一个Class&amp;lt;?&amp;gt;数组，用于指定该注解的方法所要处理的异常类，即所要匹 配的异常。&lt;br/&gt; 而被注解的方法，其返回值可以是ModelAndView、String，或void，方法名随意，方法 参数可以是 Exception 及其子类对象、HttpServletRequest、HttpServletResponse 等。系统会 自动为这些方法参数赋值。&lt;br/&gt;对于异常处理注解的用法，也可以直接将异常处理方法注解于Controller之中。&lt;/p&gt;
&lt;h3 id=&quot;1-自定义异常类&quot;&gt;(1) 自定义异常类&lt;/h3&gt;
&lt;p&gt; 定义三个异常类：NameException、AgeException、MyUserException。其中 MyUserException 是另外两个异常的父类。&lt;br/&gt;MyUserException.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bjpowernode.exception;
public class MyUserException extends Exception {
    public MyUserException() {
        super();
    }

    public MyUserException(String message) {
        super(message);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AgeException.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bjpowernode.exception;

//当年龄有问题时，抛出的异常
public class AgeException extends MyUserException {
    public AgeException() {
        super();
    }

    public AgeException(String message) {
        super(message);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NameException.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bjpowernode.exception;
//表示当用户的姓名有异常，抛出NameException
public class NameException extends MyUserException {
    public NameException() {
        super();
    }
    public NameException(String message) {
        super(message);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-修改-controller-抛出异常&quot;&gt;(2) 修改 Controller 抛出异常&lt;/h3&gt;
&lt;p&gt;MyController.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bjpowernode.controller;

import com.bjpowernode.exception.AgeException;
import com.bjpowernode.exception.MyUserException;
import com.bjpowernode.exception.NameException;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import javax.xml.ws.RequestWrapper;

/**
 * @RequestMapping:
 *    value ： 所有请求地址的公共部分，叫做模块名称
 *    位置： 放在类的上面
 */
@Controller
public class MyController {
    @RequestMapping(value = &quot;/some.do&quot;)
    public ModelAndView doSome(String name,Integer age) throws MyUserException {
        //处理some.do请求了。 相当于service调用处理完成了。
        ModelAndView mv  = new ModelAndView();

        //try {
            //根据请求参数抛出异常
            if (!&quot;zs&quot;.equals(name)) {
                throw new NameException(&quot;姓名不正确！！！&quot;);
            }

            if (age == null || age &amp;gt; 80) {
                throw new AgeException(&quot;年龄比较大！！！&quot;);
            }

        //}catch(Exception e){
        //   e.printStackTrace();
        //}
        mv.addObject(&quot;myname&quot;,name);
        mv.addObject(&quot;myage&quot;,age);
        mv.setViewName(&quot;show&quot;);
        return mv;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3-定义异常请求以及响应页面&quot;&gt;(3) 定义异常请求以及响应页面&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;请求页面：&lt;/strong&gt;&lt;br/&gt;index.jsp&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;%
    String basePath = request.getScheme() + &quot;://&quot; +
            request.getServerName() + &quot;:&quot; + request.getServerPort() +
            request.getContextPath() + &quot;/&quot;;
%&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;base href=&quot;&amp;lt;%=basePath%&amp;gt;&quot; /&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
     &amp;lt;p&amp;gt;处理异常的，全局异常处理&amp;lt;/p&amp;gt;
    &amp;lt;form action=&quot;some.do&quot; method=&quot;post&quot;&amp;gt;
        姓名：&amp;lt;input type=&quot;text&quot; name=&quot;name&quot;&amp;gt; &amp;lt;br/&amp;gt;
        年龄：&amp;lt;input type=&quot;text&quot; name=&quot;age&quot;&amp;gt; &amp;lt;br/&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;提交请求&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;响应页面&lt;/strong&gt;&lt;br/&gt;ageError.jsp&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
   ageError.jsp &amp;lt;br/&amp;gt;
   提示信息：${msg} &amp;lt;br/&amp;gt;
   系统异常消息：${ex.message}

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;defaultError.jsp&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
   defaultError.jsp &amp;lt;br/&amp;gt;
   提示信息：${msg} &amp;lt;br/&amp;gt;
   系统异常消息：${ex.message}

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;nameError.jsp&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
   nameError.jsp &amp;lt;br/&amp;gt;
   提示信息：${msg} &amp;lt;br/&amp;gt;
   系统异常消息：${ex.message}

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4-定义全局异常处理类&quot;&gt;(4) 定义全局异常处理类&lt;/h3&gt;
&lt;p&gt;不过，一般不这样使用。而是将异常处理方法专门定义在一个类中，作为全局的异常处理类。需要使用注解@ControllerAdvice，字面理解就是“控制器增强”，是给控制器对象增强功能的。使用@ControllerAdvice 修饰的类中可以使用@ExceptionHandler。当使用@RequestMapping 注解修饰的方法抛出异常时，会执行@ControllerAdvice 修饰的类中的异常处理方法。&lt;mark&gt;&lt;em&gt;@ControllerAdvice 是使用@Component 注解修饰的&lt;/em&gt;&lt;/mark&gt;，可以&lt;a target=&quot;_blank&quot;&gt;context:component-scan&lt;/a&gt;扫描到@ControllerAdvice 所在的类路径(包名)，创建对象。&lt;/p&gt;
&lt;p&gt;GlobalExceptionHandler.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bjpowernode.handler;

import com.bjpowernode.exception.AgeException;
import com.bjpowernode.exception.NameException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.servlet.ModelAndView;

/**
 * @ControllerAdvice : 控制器增强（也就是说给控制器类增加功能--异常处理功能）
 *           位置：在类的上面。
 *  特点：必须让框架知道这个注解所在的包名，需要在springmvc配置文件声明组件扫描器。
 *  指定@ControllerAdvice所在的包名
 */
@ControllerAdvice
public class GlobalExceptionHandler {
    //定义方法，处理发生的异常
    /*
        处理异常的方法和控制器方法的定义一样， 可以有多个参数，可以有ModelAndView,
        String, void,对象类型的返回值

        形参：Exception，表示Controller中抛出的异常对象。
        通过形参可以获取发生的异常信息。

        @ExceptionHandler(异常的class)：表示异常的类型，当发生此类型异常时，
        由当前方法处理
     */

    @ExceptionHandler(value = NameException.class)
    public ModelAndView doNameException(Exception exception){
        //处理NameException的异常。
        /*
           异常发生处理逻辑：
           1.需要把异常记录下来， 记录到数据库，日志文件。
             记录日志发生的时间，哪个方法发生的，异常错误内容。
           2.发送通知，把异常的信息通过邮件，短信，微信发送给相关人员。
           3.给用户友好的提示。
         */
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;姓名必须是zs，其它用户不能访问&quot;);
        mv.addObject(&quot;ex&quot;,exception);
        mv.setViewName(&quot;nameError&quot;);
        return mv;
    }


    //处理AgeException
    @ExceptionHandler(value = AgeException.class)
    public ModelAndView doAgeException(Exception exception){
        //处理AgeException的异常。
        /*
           异常发生处理逻辑：
           1.需要把异常记录下来， 记录到数据库，日志文件。
             记录日志发生的时间，哪个方法发生的，异常错误内容。
           2.发送通知，把异常的信息通过邮件，短信，微信发送给相关人员。
           3.给用户友好的提示。
         */
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;你的年龄不能大于80&quot;);
        mv.addObject(&quot;ex&quot;,exception);
        mv.setViewName(&quot;ageError&quot;);
        return mv;
    }

    //处理其它异常， NameException, AgeException以外，不知类型的异常
    @ExceptionHandler
    public ModelAndView doOtherException(Exception exception){
        //处理其它异常
        ModelAndView mv = new ModelAndView();
        mv.addObject(&quot;msg&quot;,&quot;你的年龄不能大于80&quot;);
        mv.addObject(&quot;ex&quot;,exception);
        mv.setViewName(&quot;defaultError&quot;);
        return mv;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;mark&gt;&lt;em&gt;@ControllerAdvice 是使用@Component 注解修饰的&lt;/em&gt;&lt;/mark&gt;&lt;br/&gt;这句话看了源码是这样的，ControllerAdvice类是用@Component 注解的，&lt;br/&gt;  @Component 作用：把普通pojo类实例化到spring容器中，相当于配置文件中的 &lt;code&gt;&amp;lt;bean id=&quot;&quot; class=&quot;&quot;/&amp;gt;&lt;/code&gt;&lt;br/&gt;  @Component,@Service,@Controller,@Repository注解的类，并把这些类纳入进spring容器中管理。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2130787/202102/2130787-20210221080528611-1294251393.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-定义-spring-配置文件&quot;&gt;(5) 定义 Spring 配置文件&lt;/h3&gt;
&lt;p&gt;springmvc.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&amp;gt;

    &amp;lt;!--声明组件扫描器--&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.bjpowernode.controller&quot; /&amp;gt;

    &amp;lt;!--声明 springmvc框架中的视图解析器， 帮助开发人员设置视图文件的路径--&amp;gt;
    &amp;lt;bean  class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;
        &amp;lt;!--前缀：视图文件的路径--&amp;gt;
        &amp;lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot; /&amp;gt;
        &amp;lt;!--后缀：视图文件的扩展名--&amp;gt;
        &amp;lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    
    &amp;lt;!--处理需要的两步--&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.bjpowernode.handler&quot; /&amp;gt;
    &amp;lt;mvc:annotation-driven /&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;web.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&amp;gt;

    &amp;lt;!--声明，注册springmvc的核心对象DispatcherServlet
        需要在tomcat服务器启动后，创建DispatcherServlet对象的实例。
        为什么要创建DispatcherServlet对象的实例呢？
        因为DispatcherServlet在他的创建过程中， 会同时创建springmvc容器对象，
        读取springmvc的配置文件，把这个配置文件中的对象都创建好， 当用户发起
        请求时就可以直接使用对象了。

        servlet的初始化会执行init（）方法。 DispatcherServlet在init（）中{
           //创建容器，读取配置文件
           WebApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;springmvc.xml&quot;);
           //把容器对象放入到ServletContext中
           getServletContext().setAttribute(key, ctx);
        }

        启动tomcat报错，读取这个文件 /WEB-INF/springmvc-servlet.xml（/WEB-INF/myweb-servlet.xml）
        springmvc创建容器对象时，读取的配置文件默认是/WEB-INF/&amp;lt;servlet-name&amp;gt;-servlet.xml .
    --&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;myweb&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;

        &amp;lt;!--自定义springmvc读取的配置文件的位置--&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;!--springmvc的配置文件的位置的属性--&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;!--指定自定义文件的位置--&amp;gt;
            &amp;lt;param-value&amp;gt;classpath:springmvc.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;

        &amp;lt;!--在tomcat启动后，创建Servlet对象
            load-on-startup:表示tomcat启动后创建对象的顺序。它的值是整数，数值越小，
                            tomcat创建对象的时间越早。 大于等于0的整数。
        --&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;

    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;myweb&amp;lt;/servlet-name&amp;gt;
        &amp;lt;!--
            使用框架的时候， url-pattern可以使用两种值
            1. 使用扩展名方式， 语法 *.xxxx , xxxx是自定义的扩展名。 常用的方式 *.do, *.action, *.mvc等等
               不能使用 *.jsp
               http://localhost:8080/myweb/some.do
               http://localhost:8080/myweb/other.do

            2.使用斜杠 &quot;/&quot;
        --&amp;gt;
        &amp;lt;url-pattern&amp;gt;*.do&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 21 Feb 2021 00:11:00 +0000</pubDate>
<dc:creator>二七零零</dc:creator>
<og:description>SpringMVC学习记录 注意：以下内容是学习 北京动力节点 的SpringMVC视频后所记录的笔记、源码以及个人的理解等，记录下来仅供学习 第4章 SpringMVC 核心技术 4.2异常处理 S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chuchq/p/14423893.html</dc:identifier>
</item>
<item>
<title>AtCoder Beginner Contest 192 F - Potion - GsjzTle</title>
<link>http://www.cnblogs.com/StarRoadTang/p/14424054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StarRoadTang/p/14424054.html</guid>
<description>&lt;h2 id=&quot;题目链接&quot;&gt;题目链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc192/tasks/abc192_f&quot; target=&quot;_blank&quot;&gt;点我跳转&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意&quot;&gt;题目大意&lt;/h2&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;给定 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 个物品和一个 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; ，第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个物品的重量为 &lt;span class=&quot;math inline&quot;&gt;\(ai\)&lt;/span&gt;，你可以从中选择任意个物品(不能不选)&lt;/p&gt;
&lt;p&gt;假定选择了 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 个物品，物品的总重量为 &lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么再满足 &lt;span class=&quot;math inline&quot;&gt;\((X - V) \% S = 0\)&lt;/span&gt; 的前提下还需要支付 &lt;span class=&quot;math inline&quot;&gt;\((X - V) / S\)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;\(money\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;问最少需要支付多少 &lt;span class=&quot;math inline&quot;&gt;\(money\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;解题思路&lt;/h2&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt; 一定时&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为满足 &lt;span class=&quot;math inline&quot;&gt;\((X - V) \% S = 0\)&lt;/span&gt;，则 &lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt; 需满足 &lt;span class=&quot;math inline&quot;&gt;\(V = X \% S\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为了使支付的 &lt;span class=&quot;math inline&quot;&gt;\(money\)&lt;/span&gt; 最少, 则 &lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt; 要尽可能大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是可以枚举 &lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;并定义 &lt;span class=&quot;math inline&quot;&gt;\(dp[i][j][k]\)&lt;/span&gt; 表示从前 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个物品中选择了 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 个物品使得总重量最大，且这 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 个物品的总重量 &lt;span class=&quot;math inline&quot;&gt;\(\% S = k\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么对于每个物品只有两种状态 ： 选 &lt;span class=&quot;math inline&quot;&gt;\(or\)&lt;/span&gt; 不选&lt;/p&gt;
&lt;p&gt;于是不难得到 ：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(dp[i][j][k] = dp[i - 1][j][k]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(dp[i][j][k] = dp[i - 1][j - 1][(k - a[i] % S + S) % S] + a[i]\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后取最小的 &lt;span class=&quot;math inline&quot;&gt;\((X - dp[N][S][X \% S]) / S\)&lt;/span&gt; 即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ac_code&quot;&gt;AC_Code&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;

#define rep(i , a , b) for(int i = a ; i &amp;lt;= b ; i ++)

#define int long long

using namespace std;

const int N = 1e2 + 10;

int a[N] , dp[N][N][N];

signed main()
{
        int n , x , mi = 1e18;
        
        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; x;

        rep(i , 1 , n) cin &amp;gt;&amp;gt; a[i];
        
        rep(S , 1 , n)
        {
                memset(dp , -1 , sizeof(dp));
                
                dp[0][0][0] = 0;
                
                rep(i , 1 , n) rep(j , 0 , S) rep(k , 0 , S - 1)
                {
                        dp[i][j][k] = dp[i - 1][j][k];
                                
                        if(j &amp;gt; 0 &amp;amp;&amp;amp; ~dp[i - 1][j - 1][(k - a[i] % S + S) % S]) 
                        
                        dp[i][j][k] = max(dp[i][j][k] , dp[i - 1][j - 1][(k - a[i] % S + S) % S] + a[i]);
                        
                }
                
                int res = dp[n][S][x % S];
                
                if(~res) mi = min(mi , (x - dp[n][S][x % S]) / S);
        }
        
        cout &amp;lt;&amp;lt; mi &amp;lt;&amp;lt; '\n';
        
        return 0;
} 
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 20 Feb 2021 19:14:00 +0000</pubDate>
<dc:creator>GsjzTle</dc:creator>
<og:description>题目链接 点我跳转 题目大意 给定 \(N\) 个物品和一个 \(X\) ，第 \(i\) 个物品的重量为 \(ai\)，你可以从中选择任意个物品(不能不选) 假定选择了 \(S\) 个物品，物品的总</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/StarRoadTang/p/14424054.html</dc:identifier>
</item>
<item>
<title>MySQL表连接及其优化 - gegeman</title>
<link>http://www.cnblogs.com/lijiaman/p/14381027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiaman/p/14381027.html</guid>
<description>&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;导读：&lt;/p&gt;
&lt;p&gt;在做MySQL数据库的优化工作时，如果只涉及到单表查询，那么95%的慢SQL都只需从索引上入手优化即可，通过添加索引来消除全表扫描或者排序操作，大概率能实现SQL语句执行速度质的飞跃。对于单表的优化操作，相信大部分DBA甚至开发人员都可以完成。&lt;/p&gt;
&lt;p&gt;然而，在实际生产中，除了单表操作，更多的是多个表联合起来查询，这样的查询通常是慢SQL的重灾区，查询速度慢，使用服务器资源较多，高CPU，高I/O。本文通过对表连接的表现形式以及内部理论进行探究，以及思考如何优化表连接操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt; 本文基于MySQL 5.7版本进行探究，由于MySQL 8中引入了新的连接方式hash join，本文可能不适用MySQL8版本&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;（一）MySQL的七种连接方式介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 在MySQL中，常见的表连接方式有4类，共计7种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;INNER JOIN：inner join是根据表连接条件，求取2个表的数据交集；&lt;/li&gt;
&lt;li&gt;LEFT JOIN  ：left join是根据表连接条件，求取2个表的数据交集再加上左表剩下的数据；此外，还可以&lt;span&gt;使用where过滤条件求左表独有的数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;RIGHT JOIN：right join是根据表连接条件，求取2个表的数据交集再加上右表剩下的数据；此外，还可以使用where过滤条件求右表独有的数据。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;FULL JOIN：full join是左连接与右连接的并集，MySQL并未提供full join语法，如果要实现full join,需要left join与right join进行求并集，此外还可以使用where查看2个表各自独有的数据。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 通过图形来表现，各种连接形式的求取集合部分如下，蓝色部分代表满足join条件的数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210206132413137-1413860237.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 接下来，我们通过例子来理解各种JOIN的含义。&lt;/p&gt;

&lt;p&gt;首先创建测试数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 1.创建部门表&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; 部门表记录部门信息，公司共有4个部门：财务(FINANCE)、人力(HR)、销售(SALES)、研发(RD)。&lt;br/&gt;-- 不一定每个部门都有人，例如，公司虽然有研发部，但是没有在编人员&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; dept (deptno &lt;span&gt;int&lt;/span&gt;,dname &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;14&lt;/span&gt;),loc &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; dept &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FINANCE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BEIJING&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; dept &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BEIJING&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; dept &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SALES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SHANGHAI&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; dept &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;40&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CHENGDU&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 2.创建员工表&lt;br/&gt;-- 员工表记录了员工工号、姓名、部门编号。&lt;br/&gt;-- 不一定每个员工都有部门。例如，外包人员dd就没有部门&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; emp (empno &lt;span&gt;int&lt;/span&gt;,ename &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;14&lt;/span&gt;),deptno &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; emp &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; emp &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; emp &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; emp &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; emp &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; emp &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ff&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ER图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210206134406689-584309055.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt; （1.1）INNER JOIN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;业务场景：查看公司正式员工的详细信息，包括工号、姓名、部门名称。&lt;/p&gt;
&lt;p&gt;需求分析：正式员工都有对应部门，使用INNER JOIN，通过部门编号关联部门与员工求交集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210206142922136-214368608.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SQL语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; e.empno,e.ename,d.dname
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   emp e &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; dept d
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     e.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.deptno;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+---------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; empno &lt;span&gt;|&lt;/span&gt; ename &lt;span&gt;|&lt;/span&gt; dname   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+---------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; aa    &lt;span&gt;|&lt;/span&gt; FINANCE &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; bb    &lt;span&gt;|&lt;/span&gt; HR      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; cc    &lt;span&gt;|&lt;/span&gt; SALES   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ee    &lt;span&gt;|&lt;/span&gt; SALES   &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ff    &lt;span&gt;|&lt;/span&gt; HR      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+---------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;INNER JOIN就是求取2个表的共有数据(交集)，我们可以这样来理解表INNER JOIN过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从驱动表按顺序数据，然后到被驱动表中逐行进行比较&lt;/li&gt;
&lt;li&gt;如果条件满足，则取出该行数据(注意取出的是2个表连接之后的数据)，如果条件不满足，则丢弃数据，然后继续向下比较，直到遍历完被驱动表的所有行&lt;/li&gt;
&lt;li&gt;一致循环上面2步，知道步骤1的驱动表也遍历结束。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于上面SQL，其执行过程我们可以使用伪代码来描述：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;// 特别注意：2个for循环，哪个表用来做外部循环，哪个表用来做内部循环，是由执行计划决定的，可用explain来查看，通常使用结果集较小的表来做驱动表，&lt;br/&gt;// 本例子中，SQL中顺序为emp，dept，但在执行计划中却是dept,emp。因此内外表顺序需要看MySQL的执行计划&lt;/span&gt;&lt;br/&gt;for&lt;/span&gt; (i=1;i&amp;lt;=d.counts;i++&lt;span&gt;)
{
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j=1;j&amp;lt;=e.counts;j++&amp;gt;&lt;span&gt;)
  {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (d[i].key =&lt;span&gt; e[j].key)
        {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;     d[i].dname,e[j].empno,e[j].ename;
      }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt; （1.2）LEFT JOIN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;业务场景：查看每一个部门的详细信息，包括工号、姓名、部门名称。&lt;/p&gt;
&lt;p&gt;需求分析：既然包含每一个部门，那么可以使用部门表进行LEFT JOIN，通过部门编号关联部门与员工求交集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210206151240741-1180590129.png&quot; alt=&quot;&quot; width=&quot;264&quot; height=&quot;128&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SQL语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; d.dname,e.empno,e.ename
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   dept d &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; emp e
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     e.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.deptno;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; dname   &lt;span&gt;|&lt;/span&gt; empno &lt;span&gt;|&lt;/span&gt; ename &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; FINANCE &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; aa    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; HR      &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; bb    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; SALES   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; cc    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; SALES   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ee    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; HR      &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ff    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; RD      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LEFT JOIN就是求取2个表的共有数据(交集)再加上左表剩下的数据，也就是左表的数据全部都要，左表的数据只要满足关联条件的。&lt;/p&gt;

&lt;p&gt;我们可以这样来理解表LEFT JOIN过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从左表按顺序数据，然后到右表中逐行进行比较&lt;/li&gt;
&lt;li&gt;如果条件满足，则取出该行数据(注意取出的是2个表连接之后的数据)，如果条件不满足，则丢弃数据，然后继续向下比较，直到遍历完被驱动表的所有行，如果遍历完右表所有的行都没有与左表匹配的数据，则返回左表的行，右表的记录用NULL填充。&lt;/li&gt;
&lt;li&gt;一致循环上面2步，知道步骤1的驱动表也遍历结束。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于上面SQL，其执行过程我们可以使用伪代码来描述：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;关于外连接查询算法描述(https://dev.mysql.com/doc/refman/5.7/en/nested-join-optimization.html)：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;通常，对于外部联接操作中第一个内部表的任何嵌套循环，都会引入一个标志，该标志在循环之前关闭并在循环之后检查。当针对外部表中的当前行找到表示内部操作数的表中的匹配项时，将打开该标志。如果在循环周期结束时该标志仍处于关闭状态，则未找到外部表的当前行的匹配项。在这种情况下，该行由NULL内部表的列的值补充 。结果行将传递到输出的最终检查项或下一个嵌套循环，但前提是该行满足所有嵌入式外部联接的联接条件。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;*/&lt;p&gt;for&lt;/p&gt;&lt;/span&gt; (i=1;i&amp;lt;=d.counts;i++&lt;span&gt;)
{
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; is_success=&lt;span&gt;false&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 确认d.[i]是否匹配到至少1行数据，默认未匹配到&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt; (j=1;j&amp;lt;=e.counts;j++&amp;gt;&lt;span&gt;)
  {        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (d[i].key =&lt;span&gt; e[j].key)
        {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;     d[i].dname,e[j].empno,e[j].ename;
          is_success &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      }
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (is_success=&lt;span&gt;false&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果左边的表没有匹配到数据，也会将左边表返回，右边表用null代替&lt;/span&gt;
&lt;span&gt;  {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; d[i].key,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;    
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;LEFT JOIN的补充&lt;/strong&gt;：使用LEFT JOIN来获取左表独有的数据&lt;/p&gt;
&lt;p&gt;业务场景：查看哪些部门没有员工&lt;/p&gt;
&lt;p&gt;需求分析：要查看没有部门的员工，只需要先查出所有的部门与员工关系数据，然后过滤掉有员工的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210206200521442-1635510999.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; SQL语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; d.dname,e.empno,e.ename
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   dept d &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; emp e
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     d.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; e.deptno
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;  e.deptno &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; dname &lt;span&gt;|&lt;/span&gt; empno &lt;span&gt;|&lt;/span&gt; ename &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; RD    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  使用LEFT JOIN获取2个表的共有数据(交集)再加上左表剩下的数据，然后又把交集去除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1.3）RIGHT JOIN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;业务场景：查看每一个员工的详细信息，包括工号、姓名、部门名称。&lt;/p&gt;
&lt;p&gt;需求分析：既然包含每一个员工，那么可以使用部门表进行LEFT JOIN，通过部门编号关联部门与员工求交集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210206203152225-753074076.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SQL语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; d.dname,e.empno,e.ename
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   dept d &lt;span&gt;right&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; emp e
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     e.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.deptno;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; dname   &lt;span&gt;|&lt;/span&gt; empno &lt;span&gt;|&lt;/span&gt; ename &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; FINANCE &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; aa    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; HR      &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; bb    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; HR      &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ff    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; SALES   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; cc    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; SALES   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ee    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; dd    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是，右连接和左连接是可以相互转换的，即右连接的语句，通过调换表位置并修改连接关键字为左连接，即可实现等价转换。上面的SQL的等价左连接为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;  d.dname,e.empno,e.ename
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   emp e &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; dept d
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     e.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.deptno;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; dname   &lt;span&gt;|&lt;/span&gt; empno &lt;span&gt;|&lt;/span&gt; ename &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; FINANCE &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; aa    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; HR      &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; bb    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; HR      &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ff    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; SALES   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; cc    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; SALES   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ee    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; dd    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 实际上，MySQL在解析SQL阶段，会自动将右外连接转换等效的左外连接（文档：https://dev.mysql.com/doc/refman/5.7/en/outer-join-simplification.html），所以我们也无需深入的去了解右连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1.4）FULL JOIN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;业务场景：查看所有部门及其所有员工的详细信息，包括工号、姓名、部门名称。&lt;/p&gt;
&lt;p&gt;需求分析：既然包含每一个部门及所有员工，那么可以使用全连接获取数据。然而，MySQL并没有关键字去获取全连接的数据，我们可以通过合并左连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210206203426093-253686179.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; SQL语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; d.dname,e.empno,e.ename
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   dept d &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; emp e
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     e.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.deptno
&lt;/span&gt;&lt;span&gt;union&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; d.dname,e.empno,e.ename
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   dept d &lt;span&gt;right&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; emp e
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     e.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.deptno;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; dname   &lt;span&gt;|&lt;/span&gt; empno &lt;span&gt;|&lt;/span&gt; ename &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; FINANCE &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; aa    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; HR      &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; bb    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; SALES   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; cc    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; SALES   &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ee    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; HR      &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ff    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; RD      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; dd    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;FULL JOIN的补充&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;如果要查找没有员工的部门或者没有部门的员工，即求取两个表各自独有的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210206203823609-453843529.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; SQL语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; d.dname,e.empno,e.ename
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   dept d &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; emp e
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     e.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.deptno
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;  e.deptno &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;
&lt;span&gt;union&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; d.dname,e.empno,e.ename
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   dept d &lt;span&gt;right&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; emp e
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     e.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.deptno
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;  d.deptno &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; dname &lt;span&gt;|&lt;/span&gt; empno &lt;span&gt;|&lt;/span&gt; ename &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; RD    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; dd    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; &lt;strong&gt;（二）MySQL Join算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在MySQL 5.7中，MySQL仅支持Nested-Loop Join算法及其改进型Block-Nested-Loop Join算法，在8.0版本中，又新增了Hash Join算法，这里只讨论5.7版本的表连接方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; （2.1）Nested-Loop Join算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;嵌套循环连接算法(NLJ)从第一个循环的表中读取1行数据，并将该行传递到下一个表进行连接运算，如果符合条件，则继续与下一个表的行数据进行连接，知道连接完所有的表，然后重复上面的过程。简单来讲Nested-Loop Join就是编程中的多层for循环。假设存在3个表进行连接，连接方式如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;table    join type&lt;/strong&gt;&lt;br/&gt;------    -------------&lt;br/&gt;t1        range&lt;br/&gt;t2        ref&lt;br/&gt;t3        ALL&lt;/p&gt;
&lt;p&gt;如果使用NLJ算法进行连接，伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; each row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; t1 matching range {
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; each row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; t2 matching reference key {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; each row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; t3 {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; row satisfies join conditions, send to client
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt; （2.2）Block Nested-Loop Join算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;块嵌套循环（BLN）连接算法使用外部表的行缓冲来减少对内部表的读次数。例如，将外部表的10行数据读入缓冲区并将缓冲区传递到下一个内部循环，则可以将内部循环中的每一行与缓冲区的10行数据进行比较，此时，内部表读取的次数将减少为1/10。&lt;/p&gt;
&lt;p&gt;如果使用BNL算法，上述连接的伪代码可以写为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; each row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; t1 matching range {
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; each row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; t2 matching reference key {
    store used columns from t1, t2 &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; join buffer
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; buffer is full {
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; each row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; t3 {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; each t1, t2 combination &lt;span&gt;in&lt;/span&gt;&lt;span&gt; join buffer {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; row satisfies join conditions, send to client
        }
      }
      empty join buffer
    }
  }
}

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; buffer is not empty {
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; each row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; t3 {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; each t1, t2 combination &lt;span&gt;in&lt;/span&gt;&lt;span&gt; join buffer {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; row satisfies join conditions, send to client
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; MySQL Join Buffer有如下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;join buffer可以被使用在表连接类型为ALL，index,range。换句话说，只有索引不可能被使用，或者索引全扫描，索引范围扫描等代价较大的查询才会使用Block Nested-Loop Join算法；&lt;/li&gt;
&lt;li&gt;仅仅用于连接的列数据才会被存在连接缓存中，而不是整行数据&lt;/li&gt;
&lt;li&gt;join_buffer_size系统变量用来决定每一个join buffer的大小&lt;/li&gt;
&lt;li&gt;MySQL为每一个可以被缓存的join语句分配一个join buffer，以便每一个查询都可以使用join buffer。&lt;/li&gt;
&lt;li&gt;在执行连接之前分配连接缓冲区，并在查询完成后释放连接缓冲区。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;（三）表连接顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在关系型数据库中，对于多表连接，位于嵌套循环外部的表我们称为驱动表，位于嵌套循环内部的表我们称为被驱动表，驱动表与被驱动表的顺序对于Join性能影响非常大，接下来我们探索一下MySQL中表连接的顺序。因为RIGHT JOIN和FULL JOIN在MySQL中最终都会转换为LEFT JOIN，所以我们只需讨论INNER JOIN和LEFT JOIN即可。&lt;/p&gt;
&lt;p&gt;这里为了确保测试准确，我们使用MySQL提供的测试数据库employees，下载地址为：https://github.com/datacharmer/test_db。其ER图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210208221208558-1708043777.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;（3.1）INNER JOIN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 对应INNER JOIN，MySQL永远选择&lt;span&gt;结果集&lt;/span&gt;小的表作为驱动表。&lt;/p&gt;
&lt;p&gt;例子1：查看员工部门对应信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 将employees，dept_manager ， departments 3个表进行内连接即可&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt;      e.emp_no,e.first_name,e.last_name,d.dept_name
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;        employees e &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; dept_manager dm &lt;span&gt;on&lt;/span&gt; e.emp_no &lt;span&gt;=&lt;/span&gt;&lt;span&gt; dm.emp_no
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;  departments d &lt;span&gt;on&lt;/span&gt; dm.dept_no &lt;span&gt;=&lt;/span&gt; d.dept_no;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们来看一下3个表的大小，需要注意的是，这里仅仅是MySQL粗略统计行数，在这个例子中，实际行数与之有一定的差距：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------------+------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; table_name   &lt;span&gt;|&lt;/span&gt; table_rows &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------------+------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; departments  &lt;span&gt;|&lt;/span&gt;          &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; dept_manager &lt;span&gt;|&lt;/span&gt;         &lt;span&gt;24&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; employees    &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;299468&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------------+------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 最终的执行计划为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+-----------------+-----------+---------+---------------------+------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type   &lt;span&gt;|&lt;/span&gt; possible_keys   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                 &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+-----------------+-----------+---------+---------------------+------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; d     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt; dept_name &lt;span&gt;|&lt;/span&gt; &lt;span&gt;42&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;                &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; dm    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;,dept_no &lt;span&gt;|&lt;/span&gt; dept_no   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.d.dept_no &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; eq_ref &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.dm.emp_no &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+-----------------+-----------+---------+---------------------+------+----------+-------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以看到，在INNER JOIN中，MySQL并不是按照语句中表的出现顺序来按顺序执行的，而是首先评估每个表结果集的大小，选择小的作为驱动表，大的作为被驱动表，不管我们如何调整SQL中的表顺序，MySQL优化器选择表的顺序与上面相同。&lt;/p&gt;
&lt;p&gt;这里需要特别说明的是：&lt;span&gt;通常我们所说的&quot;小表驱动大表&quot;是非常不严谨的，在INNER JOIN中，MySQL永远选择结果集小的表作为驱动表，而不是小表。这有什么区别呢？结果集是指表进行了数据过滤后形成的临时表，其数据量小于或等于原表。下面提及的&quot;小表和大表&quot;都是指结果集大小。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;例子2：查看工号为110567的员工部门对应信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt;      e.emp_no,e.first_name,e.last_name,d.dept_name
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;        employees e &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; dept_manager dm &lt;span&gt;on&lt;/span&gt; e.emp_no &lt;span&gt;=&lt;/span&gt; dm.emp_no &lt;span&gt;and&lt;/span&gt; e.emp_no &lt;span&gt;=&lt;/span&gt; &lt;span&gt;110567&lt;/span&gt;
&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;  departments d &lt;span&gt;on&lt;/span&gt; dm.dept_no &lt;span&gt;=&lt;/span&gt; d.dept_no;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 最终的执行计划为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+-----------------+---------+---------+----------------------+------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type   &lt;span&gt;|&lt;/span&gt; possible_keys   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                  &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+-----------------+---------+---------+----------------------+------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; const  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; const                &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; dm    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;,dept_no &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; const                &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; d     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; eq_ref &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.dm.dept_no &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+-----------------+---------+---------+----------------------+------+----------+-------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以看到，这里驱动表是employees，这个表是数据量最大的表，但是为什么选择它作为驱动表呢？因为他的结果集最小，在执行查询时，MySQL会首先选择employees表中emp_no=110567的数据，而这样的数据只有1条，其结果集也就最小，所以优化器选择了employees作为驱动表。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3.2）LEFT JOIN &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 对于LEFT JOIN，执行顺序永远是&lt;strong&gt;从左往右&lt;/strong&gt;，我们可以通过例子来看一下。&lt;/p&gt;
&lt;p&gt;例子2：LEFT JOIN表顺序的选择测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 表顺序：e --&amp;gt; dm --&amp;gt; d&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;&lt;span&gt;      e.emp_no,e.first_name,e.last_name,d.dept_name
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;        employees e &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; dept_manager dm &lt;span&gt;on&lt;/span&gt; e.emp_no &lt;span&gt;=&lt;/span&gt;&lt;span&gt; dm.emp_no
&lt;/span&gt;&lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;   departments d &lt;span&gt;on&lt;/span&gt; dm.dept_no &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.dept_no;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+---------------+---------+---------+----------------------+--------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type   &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                  &lt;span&gt;|&lt;/span&gt; rows   &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+---------------+---------+---------+----------------------+--------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;                 &lt;span&gt;|&lt;/span&gt; &lt;span&gt;299468&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; dm    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.e.emp_no   &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; d     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; eq_ref &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.dm.dept_no &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+---------------+---------+---------+----------------------+--------+----------+-------------+&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 表顺序：dm --&amp;gt; e --&amp;gt; d&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;&lt;span&gt;      e.emp_no,e.first_name,e.last_name,d.dept_name
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;        dept_manager dm &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; employees e &lt;span&gt;on&lt;/span&gt; e.emp_no &lt;span&gt;=&lt;/span&gt;&lt;span&gt; dm.emp_no
&lt;/span&gt;&lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;   departments d &lt;span&gt;on&lt;/span&gt; dm.dept_no &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.dept_no;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type   &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                  &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; dm    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; dept_no &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;                 &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;24&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; eq_ref &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.dm.emp_no  &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; d     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; eq_ref &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.dm.dept_no &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+---------------+---------+---------+----------------------+------+----------+-------------+&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 表顺序：e --&amp;gt; dm --&amp;gt; d&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;&lt;span&gt;      e.emp_no,e.first_name,e.last_name,d.dept_name
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;        employees e &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;  dept_manager dm &lt;span&gt;on&lt;/span&gt; e.emp_no &lt;span&gt;=&lt;/span&gt;&lt;span&gt; dm.emp_no  
&lt;/span&gt;&lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;   departments d &lt;span&gt;on&lt;/span&gt; dm.dept_no &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.dept_no;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+---------------+---------+---------+----------------------+--------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type   &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                  &lt;span&gt;|&lt;/span&gt; rows   &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+---------------+---------+---------+----------------------+--------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;                 &lt;span&gt;|&lt;/span&gt; &lt;span&gt;299468&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; dm    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.e.emp_no   &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; d     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; eq_ref &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.dm.dept_no &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+--------+---------------+---------+---------+----------------------+--------+----------+-------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果右表存在谓词过滤条件，MySQL会将left join转换为inner join，详见本文：（5.3）left join优化&lt;/p&gt;


&lt;p&gt; &lt;strong&gt;（四）ON和WHERE的思考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 在表连接中，我们可以在2个地方写过滤条件，一个是在ON后面，另一个就是WHERE后面了。那么，这两个地方写谓词过滤条件有什么区别呢？我们还是通过INNER JOIN和LEFT JOIN分别看一下。&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;（4.1）INNER JOIN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 使用INNER JOIN，不管谓词条件写在ON部分还是WHERE部分，其结果都是相同的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 将过滤条件写在ON部分&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; e.empno,e.ename,d.dname
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   emp e &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; dept d
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     e.deptno &lt;span&gt;=&lt;/span&gt; d.deptno &lt;span&gt;and&lt;/span&gt; d.dname &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; empno &lt;span&gt;|&lt;/span&gt; ename &lt;span&gt;|&lt;/span&gt; dname &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; bb    &lt;span&gt;|&lt;/span&gt; HR    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ff    &lt;span&gt;|&lt;/span&gt; HR    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 将过滤条件写在WHERE部分&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; e.empno,e.ename,d.dname
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   emp e &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; dept d
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     e.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.deptno 
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;  d.dname &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; empno &lt;span&gt;|&lt;/span&gt; ename &lt;span&gt;|&lt;/span&gt; dname &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; bb    &lt;span&gt;|&lt;/span&gt; HR    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ff    &lt;span&gt;|&lt;/span&gt; HR    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 使用非标准写法，将表连接条件和过滤条件写在WHERE部分&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; e.empno,e.ename,d.dname
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   emp e &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; dept d
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;     e.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.deptno 
&lt;/span&gt;&lt;span&gt;and&lt;/span&gt;  d.dname &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; empno &lt;span&gt;|&lt;/span&gt; ename &lt;span&gt;|&lt;/span&gt; dname &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; bb    &lt;span&gt;|&lt;/span&gt; HR    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ff    &lt;span&gt;|&lt;/span&gt; HR    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 实际上，通过trace报告可以看到，在inner join中，不管谓词条件写在ON部分还是WHERE部分，MySQL都会将SQL语句的谓词条件等价改写到where后面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; （4.2）LEFT JOIN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 我们继续来看LEFT JOIN中ON与WHERE的区别。&lt;/p&gt;
&lt;p&gt;使用ON作为谓词过滤条件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; e.empno,e.ename,d.dname
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   emp e &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; dept d
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     e.deptno &lt;span&gt;=&lt;/span&gt; d.deptno &lt;span&gt;and&lt;/span&gt; d.dname &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; empno &lt;span&gt;|&lt;/span&gt; ename &lt;span&gt;|&lt;/span&gt; dname &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; aa    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; bb    &lt;span&gt;|&lt;/span&gt; HR    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; cc    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; dd    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ee    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ff    &lt;span&gt;|&lt;/span&gt; HR    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们可以把使用ON的情况用下图来描述，先使用ON条件进行关联，并在关联的时候进行数据过滤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210209224056671-1078464770.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再看看使用where的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; e.empno,e.ename,d.dname
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   emp e &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; dept d
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     e.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; d.deptno 
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;  d.dname &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; empno &lt;span&gt;|&lt;/span&gt; ename &lt;span&gt;|&lt;/span&gt; dname &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; bb    &lt;span&gt;|&lt;/span&gt; HR    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;     &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ff    &lt;span&gt;|&lt;/span&gt; HR    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-----+-------+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们可以把使用where的情况用下图来描述，先使用ON条件进行关联，然后对关联的结果进行数据过滤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210209222544745-215030979.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以看到，在LEFT JOIN中，过滤条件放在ON和WHERE之后结果是不同的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果过滤条件在ON后面，那么将使用左表与右表每行数据进行连接，然后根据过滤条件判断，如果满足判断条件，则左表与右表数据进行连接，如果不满足判断条件，则返回左表数据，右表数据用NULL值代替；&lt;/li&gt;
&lt;li&gt;如果过滤条件在WHERE后面，那么将使用左表与右表每行数据进行连接，然后将连接的结果集进行条件判断，满足条件的行信息保留。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;strong&gt;（五）JOIN优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JOIN语句相对而言比较复杂，我们根据SQL语句的结构考虑优化方法，JOIN相关的主要SQL结构如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;inner join&lt;/li&gt;
&lt;li&gt;inner join + 排序(group by 或者 order by)&lt;/li&gt;
&lt;li&gt;left join&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;（5.1）inner join优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常规inner join的SQL语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;select_list&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;FROM&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;left_table&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;right_table&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;join_condition&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;WHERE&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;where_condition&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;优化方法&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;1.对于inner join，通常是采用小表驱动大表的方式，即小标作为驱动表，大表作为被驱动表（相当于小表位于for循环的外层，大表位于for循环的内层）。这个过程MySQL数据局优化器以帮助我们完成，通常无需手动处理(特殊情况，表的统计信息不准确)。注意，这里的“小表”指的是结果集小的表。&lt;/p&gt;
&lt;p&gt;2.对于inner join，需要对被驱动表的连接条件创建索引&lt;/p&gt;
&lt;p&gt;3.对于inner join，考虑对连接条件和过滤条件(ON、WHERE)创建复合索引&lt;/p&gt;

&lt;p&gt;例子1：对于inner join，需要对被驱动表的连接条件创建索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; ---------- 构造测试表 --------------------------  &lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 创建新表employees_new&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; employees_new &lt;span&gt;like&lt;/span&gt;&lt;span&gt; employees;
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; empployees_new &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; employees;
Query OK, &lt;/span&gt;&lt;span&gt;300024&lt;/span&gt; rows affected (&lt;span&gt;2.69&lt;/span&gt;&lt;span&gt; sec)
Records: &lt;/span&gt;&lt;span&gt;300024&lt;/span&gt;  Duplicates: &lt;span&gt;0&lt;/span&gt;  Warnings: &lt;span&gt;0&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 创建新表salaries_new&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; salaries_new &lt;span&gt;like&lt;/span&gt;&lt;span&gt; salaries;
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; salaries_new &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; salaries;
Query OK, &lt;/span&gt;&lt;span&gt;2844047&lt;/span&gt; rows affected (&lt;span&gt;13.00&lt;/span&gt;&lt;span&gt; sec)
Records: &lt;/span&gt;&lt;span&gt;2844047&lt;/span&gt;  Duplicates: &lt;span&gt;0&lt;/span&gt;  Warnings: &lt;span&gt;0&lt;/span&gt;


&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 删除主键&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; employees_new &lt;span&gt;drop&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt;;
Query OK, &lt;/span&gt;&lt;span&gt;300024&lt;/span&gt; rows affected (&lt;span&gt;1.84&lt;/span&gt;&lt;span&gt; sec)
Records: &lt;/span&gt;&lt;span&gt;300024&lt;/span&gt;  Duplicates: &lt;span&gt;0&lt;/span&gt;  Warnings: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; salaries_new &lt;span&gt;drop&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt;;
Query OK, &lt;/span&gt;&lt;span&gt;2844047&lt;/span&gt; rows affected (&lt;span&gt;9.58&lt;/span&gt;&lt;span&gt; sec)
Records: &lt;/span&gt;&lt;span&gt;2844047&lt;/span&gt;  Duplicates: &lt;span&gt;0&lt;/span&gt;  Warnings: &lt;span&gt;0&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 表大小&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;   table_name,table_rows 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt;     information_schema.tables a 
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;    a.table_schema &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;employees&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;and&lt;/span&gt;      a.table_name &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;employees_new&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salaries_new&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; table_name    &lt;span&gt;|&lt;/span&gt; table_rows &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; employees_new &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;299389&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; salaries_new  &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;2837194&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------------+------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此时测试表ER关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210219193619367-1199714833.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 进行表连接查询，语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt;  e.emp_no,e.first_name,e.last_name,s.salary,s.from_date,s.to_date
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;    employees_new  e &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; salaries_new s
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;      e.emp_no &lt;span&gt;=&lt;/span&gt; s.emp_no ;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 1. 被驱动表没有索引，执行时间：大于800s，(800s未执行完)&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; 执行计划：&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows    &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra                                              &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;299389&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;                                               &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; s     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2837194&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;10.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;; Using &lt;span&gt;join&lt;/span&gt; buffer (Block Nested Loop) &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+---------------+------+---------+------+---------+----------+----------------------------------------------------+&lt;/span&gt;


&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 2. 在被驱动表连接条件上创建索引，执行时间: 37s&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; 创建索引语句&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; idx_empno &lt;span&gt;on&lt;/span&gt;&lt;span&gt; salaries_new(emp_no);

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 执行计划：&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+---------------+-----------+---------+--------------------+--------+----------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                &lt;span&gt;|&lt;/span&gt; rows   &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+---------------+-----------+---------+--------------------+--------+----------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;               &lt;span&gt;|&lt;/span&gt; &lt;span&gt;299389&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; s     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_empno     &lt;span&gt;|&lt;/span&gt; idx_empno &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.e.emp_no &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+---------------+-----------+---------+--------------------+--------+----------+-------+&lt;/span&gt;


&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 3. 更进一步，在驱动表连接条件上也创建索引，执行时间: 40s&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; 创建索引语句&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; idx_employees_new_empno &lt;span&gt;on&lt;/span&gt;&lt;span&gt; employees_new(emp_no);

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 执行计划：&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+-------------------------+-----------+---------+--------------------+--------+----------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys           &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                &lt;span&gt;|&lt;/span&gt; rows   &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+-------------------------+-----------+---------+--------------------+--------+----------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; idx_employees_new_empno &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;               &lt;span&gt;|&lt;/span&gt; &lt;span&gt;299389&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; s     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_empno               &lt;span&gt;|&lt;/span&gt; idx_empno &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.e.emp_no &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+-------------------------+-----------+---------+--------------------+--------+----------+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 通过以上测试可见，在被驱动表的连接条件上创建索引是非常有必要的，而在驱动表连接条件上创建索引则不会显著提高速度。&lt;/p&gt;

&lt;p&gt;例子2：对于inner join，考虑对连接条件和过滤条件(ON、WHERE)创建复合索引&lt;/p&gt;
&lt;p&gt; 进行表连接查询，语句如下(以下2个SQL在MySQL优化器中解析为相同SQL)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; e.emp_no,e.first_name,e.last_name,s.salary,s.from_date,s.to_date
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; employees_new e &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; salaries_new s
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt; e.emp_no &lt;span&gt;=&lt;/span&gt; s.emp_no &lt;span&gt;and&lt;/span&gt; e.first_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Georgi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 或者&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; e.emp_no,e.first_name,e.last_name,s.salary,s.from_date,s.to_date
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; employees_new e &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; salaries_new s
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt; e.emp_no &lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.emp_no
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; e.first_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Georgi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 1. 未在连接条件和过滤条件上创建复合索引，执行时间: 0.162s&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 执行计划：&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+-------------------------+-----------+---------+--------------------+--------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys           &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                &lt;span&gt;|&lt;/span&gt; rows   &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+-------------------------+-----------+---------+--------------------+--------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; idx_employees_new_empno &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;               &lt;span&gt;|&lt;/span&gt; &lt;span&gt;299389&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;10.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; s     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_empno               &lt;span&gt;|&lt;/span&gt; idx_empno &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.e.emp_no &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+-------------------------+-----------+---------+--------------------+--------+----------+-------------+&lt;/span&gt;


&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 2.在连接条件和过滤条件上创建复合索引，执行时间: 0.058s&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 创建索引语句&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; idx_employees_first_name_emp_no &lt;span&gt;on&lt;/span&gt;&lt;span&gt; employees_new(first_name,emp_no);
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; idx_employees_emp_no_first_name &lt;span&gt;on&lt;/span&gt;&lt;span&gt; employees_new(emp_no,first_name);

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 执行计划：&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+-----------------------------------------------------------------------------------------+---------------------------------+---------+--------------------+------+----------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys                                                                           &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;                             &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+-----------------------------------------------------------------------------------------+---------------------------------+---------+--------------------+------+----------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_employees_new_empno,idx_employees_first_name_emp_no,idx_employees_emp_no_first_name &lt;span&gt;|&lt;/span&gt; idx_employees_first_name_emp_no &lt;span&gt;|&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; const              &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;253&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; s     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_empno                                                                               &lt;span&gt;|&lt;/span&gt; idx_empno                       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.e.emp_no &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+-----------------------------------------------------------------------------------------+---------------------------------+---------+--------------------+------+----------+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  通过以上测试可见，表的连接条件上和过滤条件上创建复合索引可以提高查询速度，从本例子看，速度没有较大提高，因为对employees_new表全表扫描速度很快，但是在非常大的表中，复合索引能够有效提高速度。&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;（5.2）inner join +  排序(group by 或者 order by)优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常规inner join+排序的SQL语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
SELECT   &amp;lt;select_list&amp;gt;
FROM     &amp;lt;left_table&amp;gt; inner join &amp;lt;right_table&amp;gt; ON &amp;lt;join_condition&amp;gt;
WHERE    &amp;lt;where_condition&amp;gt;&lt;br/&gt;GROUP BY  &amp;lt;group_by_list&amp;gt;&lt;br/&gt;ORDER BY  &amp;lt;order_by_list&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;优化方法&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.与inner join一样，在被驱动表的连接条件上创建索引&lt;/p&gt;
&lt;p&gt;2.inner join + 排序往往会在执行计划里面伴随着Using temporary Using filesort关键字出现，如果临时表或者排序的数据量很大，那么将会导致查询非常慢，需要特别重视；反之，临时表或者排序的数据量较小，例如只有几百条，那么即使执行计划有Using temporary Using filesort关键字，对查询速度影响也不大。&lt;strong&gt;如果说排序操作消耗了大部分的时间，那么可以考虑使用索引的有序性来消除排序，&lt;/strong&gt;接下来对该优化方法进行讨论。&lt;/p&gt;
&lt;p&gt; group by和order by都会对相关列进行排序，根据SQL是否存在GROUP BY或者ORDER BY关键字，分3种情况讨论：&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;strong&gt;SQL语句存在&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;group by&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;SQL语句存在&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;order by&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;优化操作考虑的排序列&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;情况1&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;只需考虑group by相关列排序问题即可&lt;/td&gt;
&lt;td&gt;如果SQL语句中只含有group by，则只需考虑group by后面的列排序问题即可&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;情况2&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;只需考虑order by相关列排序问题即可&lt;/td&gt;
&lt;td&gt;如果SQL语句中只含有order by，则只需考虑order by后面的列排序问题即可&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;情况3&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;只需考虑group by相关列排序问题即可&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;如果SQL语句中同时含有group by和order by，只需考虑group by后面的排序即可。&lt;/p&gt;
&lt;p&gt;因为MySQL先执行group by，后执行order by，通常group by之后数据量已经较少了，&lt;/p&gt;
&lt;p&gt;后续的order by直接在磁盘上排序即可&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;








&lt;p&gt; 对于上面3种情况：&lt;/p&gt;
&lt;p&gt;1.如果优化考虑的排序列全部来源于驱动表，则可以考虑：在&lt;strong&gt;等值&lt;/strong&gt;谓词过滤条件上+排序列上创建复合索引，这样可以使用索引先过滤数据，再使用索引按顺序获取数据。&lt;/p&gt;
&lt;p&gt;2.如果优化考虑的排序列全部来源于某个被驱动表，则可以考虑：使用表连接hint(Straight_JOIN)控制连接顺序，将排序相关表设置为驱动表，然后按照1创建复合索引；&lt;/p&gt;
&lt;p&gt;3.如果优化考虑的排序列来源于多个表，貌似没有好的解决办法，有想法的同学也可以留言，一起进步。&lt;/p&gt;

&lt;p&gt;例子1：如果优化考虑的排序列全部来源于驱动表，则可以考虑：在&lt;strong&gt;等值&lt;/strong&gt;谓词过滤条件上+排序列上创建复合索引，这样可以使用索引先过滤数据，再使用索引按顺序获取数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 1.驱动表e上存在排序&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt;  explain &lt;span&gt;select&lt;/span&gt;    e.first_name,&lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(salary)
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;      employees_new e &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; salaries_new s &lt;span&gt;on&lt;/span&gt;  e.emp_no &lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.emp_no
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;     e.last_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Aamodt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt;  e.first_name;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+------------------------------------------------------+------------------------------+---------+--------------------+------+----------+-----------------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys                                        &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;                          &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra                                                     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+------------------------------------------------------+------------------------------+---------+--------------------+------+----------+-----------------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_employees_new_empno,idx_lastname_empno_firstname &lt;span&gt;|&lt;/span&gt; idx_lastname_empno_firstname &lt;span&gt;|&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; const              &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;205&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;; Using &lt;span&gt;index&lt;/span&gt;; Using &lt;span&gt;temporary&lt;/span&gt;; Using filesort &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; s     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_empno                                            &lt;span&gt;|&lt;/span&gt; idx_empno                    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.e.emp_no &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;                                                      &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+------------------------------------------------------+------------------------------+---------+--------------------+------+----------+-----------------------------------------------------------+&lt;/span&gt;


&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 2.在驱动表e上的等值谓词过滤条件last_name和排序列first_name上创建索引&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; idx_lastname_firstname &lt;span&gt;on&lt;/span&gt;&lt;span&gt; employees_new (last_name,first_name);


&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 3.可以看到，排序消除&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;    e.first_name,&lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(salary)
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;      employees_new e &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; salaries_new s &lt;span&gt;on&lt;/span&gt;  e.emp_no &lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.emp_no
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;     e.last_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Aamodt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt;  e.first_name;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+----------------------------------------------------------------------------------+------------------------+---------+--------------------+------+----------+-----------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys                                                                    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;                    &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra                 &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+----------------------------------------------------------------------------------+------------------------+---------+--------------------+------+----------+-----------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_employees_new_empno,idx_employees_new_empno_firstname,idx_lastname_firstname &lt;span&gt;|&lt;/span&gt; idx_lastname_firstname &lt;span&gt;|&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; const              &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;205&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;index&lt;/span&gt; condition &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; s     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_empno                                                                        &lt;span&gt;|&lt;/span&gt; idx_empno              &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.e.emp_no &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;                  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+----------------------------------------------------------------------------------+------------------------+---------+--------------------+------+----------+-----------------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 需要说明的是，消除排序只是提供了一种数据优化的方式，消除排序后，其速度并不一定会比之前快，需要具体问题具体分析测试。&lt;/p&gt;

&lt;p&gt;例子2：如果优化考虑的排序列全部来源于某个被驱动表，则可以考虑：使用表连接hint(Straight_JOIN)控制连接顺序，将排序相关表设置为驱动表，然后按照1创建复合索引；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 1. 被驱动表s上存在排序&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;    s.from_date,&lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(salary)
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;      employees_new e &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; salaries_new s &lt;span&gt;on&lt;/span&gt;  e.emp_no &lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.emp_no
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;     e.last_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Aamodt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;and&lt;/span&gt;       s.salary &lt;span&gt;=&lt;/span&gt; &lt;span&gt;40000&lt;/span&gt;
&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt;  s.from_date;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+------------------...-------+------------------------+---------+--------------------+------+----------+---------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys    ...       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;                    &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra                           &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+------------------...-------+------------------------+---------+--------------------+------+----------+---------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_employees_new...stname &lt;span&gt;|&lt;/span&gt; idx_lastname_firstname &lt;span&gt;|&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; const              &lt;span&gt;|&lt;/span&gt;  &lt;span&gt;205&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;temporary&lt;/span&gt;; Using filesort &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; s     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_empno        ...       &lt;span&gt;|&lt;/span&gt; idx_empno              &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.e.emp_no &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;10.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;                     &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+------------------...-------+------------------------+---------+--------------------+------+----------+---------------------------------+&lt;/span&gt;


&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 2. 使用Straight_join改变表的连接顺序&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;    s.from_date,&lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(salary)
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;      salaries_new s STRAIGHT_JOIN employees_new e  &lt;span&gt;on&lt;/span&gt;  e.emp_no &lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.emp_no
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;     e.last_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Aamodt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;and&lt;/span&gt;       s.salary &lt;span&gt;=&lt;/span&gt; &lt;span&gt;40000&lt;/span&gt;
&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt;  s.from_date;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+-----------------...----------+-------------------------+---------+--------------------+---------+----------+----------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys   ...          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;                     &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                &lt;span&gt;|&lt;/span&gt; rows    &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra                                        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+-----------------...----------+-------------------------+---------+--------------------+---------+----------+----------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; s     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; idx_empno       ...          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;                    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;               &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2837194&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;10.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;; Using &lt;span&gt;temporary&lt;/span&gt;; Using filesort &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_employees_ne...firstname &lt;span&gt;|&lt;/span&gt; idx_employees_new_empno &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.s.emp_no &lt;span&gt;|&lt;/span&gt;       &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;5.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;                                  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+-----------------...----------+-------------------------+---------+--------------------+---------+----------+----------------------------------------------+&lt;/span&gt;


&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 3. 在新的驱动表上创建等值谓词+排序列索引&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; idx_salary_fromdate &lt;span&gt;on&lt;/span&gt;&lt;span&gt; salaries_new(salary,from_date);
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;5.39&lt;/span&gt;&lt;span&gt; sec)
Records: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  Duplicates: &lt;span&gt;0&lt;/span&gt;  Warnings: &lt;span&gt;0&lt;/span&gt;


&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 4. 可以看到，消除排序&lt;/span&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;    s.from_date,&lt;span&gt;sum&lt;/span&gt;&lt;span&gt;(salary)
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;      salaries_new s STRAIGHT_JOIN employees_new e  &lt;span&gt;on&lt;/span&gt;  e.emp_no &lt;span&gt;=&lt;/span&gt;&lt;span&gt; s.emp_no
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;     e.last_name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Aamodt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;and&lt;/span&gt;       s.salary &lt;span&gt;=&lt;/span&gt; &lt;span&gt;40000&lt;/span&gt;
&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt;  s.from_date;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+---------------------------------...--+-------------------------+---------+--------------------+--------+----------+-----------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys                   ...  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;                     &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                &lt;span&gt;|&lt;/span&gt; rows   &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra                 &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+---------------------------------...--+-------------------------+---------+--------------------+--------+----------+-----------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; s     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_empno,idx_salary_fromdate   ...  &lt;span&gt;|&lt;/span&gt; idx_salary_fromdate     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; const              &lt;span&gt;|&lt;/span&gt; &lt;span&gt;199618&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;index&lt;/span&gt; condition &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_employees_new_empno,idx_empl...e &lt;span&gt;|&lt;/span&gt; idx_employees_new_empno &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; employees.s.emp_no &lt;span&gt;|&lt;/span&gt;      &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;     &lt;span&gt;5.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;           &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+---------------------------------...--+-------------------------+---------+--------------------+--------+----------+-----------------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 需要说明的是，大部分情况下，MySQL优化器会自动选择最优的表连接方式，Straight_join的引入往往会造成大表做驱动表的情况出现，虽然消除了排序，但是又引入了新的麻烦。到底是排序带来的开销大，还是NLJ循环嵌套不合理带来的开销大，需要具体情况具体分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（5.3）left join优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在MySQL中外连接(left join、right join 、full join)会被优化器转换为left join，因此，外连接只需讨论left join即可。常规left join的SQL语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;select_list&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;FROM&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;left_table&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;right_table&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;join_condition&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;WHERE&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;where_condition&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;  &lt;span&gt;&amp;lt;&lt;/span&gt;group_by_list&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;  &lt;span&gt;&amp;lt;&lt;/span&gt;order_by_list&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;优化方法&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.与inner join一样，在被驱动表的连接条件上创建索引&lt;/p&gt;
&lt;p&gt;2.left join的表连接顺序都是从左像右的，我们无法改变表连接顺序。但是&lt;strong&gt;如果右表在where条件中存在谓词过滤，则MySQL会将left join自动转换为inner join&lt;/strong&gt;，其原理图如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210220225659650-209655974.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 例子1：.如果右表在where条件中存在谓词过滤，则MySQL会将left join自动转换为inner join&lt;/p&gt;
&lt;p&gt;创建测试表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; dept
(
  deptno   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,
  dname    &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; dept &lt;span&gt;values&lt;/span&gt; (&lt;span&gt;10&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sales&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(&lt;span&gt;20&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(&lt;span&gt;30&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;product&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),(&lt;span&gt;40&lt;/span&gt;,    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;develop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);


&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; emp 
(
  empno    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,
  ename    &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
  deptno   &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; emp &lt;span&gt;values&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;),(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;),(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;),(&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;),(&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 执行left join，查看其执行计划，发现并不是左表作为驱动表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;&lt;span&gt; d.dname,e.ename
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   dept d &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; emp e
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     d.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; e.deptno
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;  e.deptno &lt;span&gt;=&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra                                              &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; e     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;20.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;                                        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; d     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;25.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt;; Using &lt;span&gt;join&lt;/span&gt; buffer (Block Nested Loop) &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 通过trace追踪，发现MySQL对其该语句进行了等价改写，将外连接改为了内连接。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;78.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_4eff3280-558f-457d-a9ce-a585b315441f&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_4eff3280-558f-457d-a9ce-a585b315441f&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4eff3280-558f-457d-a9ce-a585b315441f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;152&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; optimizer_trace&lt;span&gt;=&lt;/span&gt;&quot;enabled&lt;span&gt;=&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&quot;,end_markers_in_JSON&lt;span&gt;=&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;;
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt; d.dname,e.ename
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   dept d &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; emp e
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     d.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; e.deptno
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;  e.deptno &lt;span&gt;=&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; dname   &lt;span&gt;|&lt;/span&gt; ename &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; product &lt;span&gt;|&lt;/span&gt; dd    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; product &lt;span&gt;|&lt;/span&gt; ee    &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;-------+-------+&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.03&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; information_schema.optimizer_trace;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; MISSING_BYTES_BEYOND_MAX_MEM_SIZE &lt;span&gt;|&lt;/span&gt; INSUFFICIENT_PRIVILEGES &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; d.dname,e.ename
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;   dept d &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; emp e
&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;     d.deptno &lt;span&gt;=&lt;/span&gt;&lt;span&gt; e.deptno
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;  e.deptno &lt;span&gt;=&lt;/span&gt; &lt;span&gt;30&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;&lt;span&gt; {
  &quot;steps&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
    {
      &quot;join_preparation&quot;: {
        &quot;select#&quot;: 1,
        &quot;steps&quot;: [
          {
            &quot;expanded_query&quot;: &quot;/* select#1 */ select `d`.`dname` AS `dname`,`e`.`ename` AS `ename` from (`dept` `d` left join `emp` `e` on((`d`.`deptno` = `e`.`deptno`))) where (`e`.`deptno` = 30)&quot;
          },
          {
            &quot;transformations_to_nested_joins&quot;: {
              &quot;transformations&quot;: [
                &quot;outer_join_to_inner_join&quot;,
                &quot;JOIN_condition_to_WHERE&quot;,
                &quot;parenthesis_removal&quot;
              &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; transformations &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;,
              &quot;expanded_query&quot;: &quot;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; select#1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; `d`.`dname` &lt;span&gt;AS&lt;/span&gt; `dname`,`e`.`ename` &lt;span&gt;AS&lt;/span&gt; `ename` &lt;span&gt;from&lt;/span&gt; `dept` `d` &lt;span&gt;join&lt;/span&gt; `emp` `e` &lt;span&gt;where&lt;/span&gt; ((`e`.`deptno` &lt;span&gt;=&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;) &lt;span&gt;and&lt;/span&gt; (`d`.`deptno` &lt;span&gt;=&lt;/span&gt;&lt;span&gt; `e`.`deptno`))&quot;
            } &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; transformations_to_nested_joins &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          }
        ] &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; steps &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; join_preparation &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    },
    {
      &quot;join_optimization&quot;: {
        &quot;&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;#&quot;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
        &quot;steps&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
          {
            &quot;condition_processing&quot;: {
              &quot;condition&quot;: &quot;WHERE&quot;,
              &quot;original_condition&quot;: &quot;((`e`.`deptno` = 30) and (`d`.`deptno` = `e`.`deptno`))&quot;,
              &quot;steps&quot;: [
                {
                  &quot;transformation&quot;: &quot;equality_propagation&quot;,
                  &quot;resulting_condition&quot;: &quot;((`e`.`deptno` = 30) and (`d`.`deptno` = `e`.`deptno`))&quot;
                },
                {
                  &quot;transformation&quot;: &quot;constant_propagation&quot;,
                  &quot;resulting_condition&quot;: &quot;((`e`.`deptno` = 30) and (`d`.`deptno` = `e`.`deptno`))&quot;
                },
                {
                  &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,
                  &quot;resulting_condition&quot;: &quot;((`e`.`deptno` = 30) and (`d`.`deptno` = `e`.`deptno`))&quot;
                }
              &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; steps &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            } &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; condition_processing &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          },
          {
            &quot;substitute_generated_columns&quot;: {
            } &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; substitute_generated_columns &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          },
          {
            &quot;table_dependencies&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
              {
                &quot;table&quot;: &quot;`dept` `d`&quot;,
                &quot;row_may_be_null&quot;: false,
                &quot;map_bit&quot;: 0,
                &quot;depends_on_map_bits&quot;: [
                &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; depends_on_map_bits &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
              },
              {
                &quot;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&quot;: &quot;`emp` `e`&quot;,
                &quot;row_may_be_null&quot;: true,
                &quot;map_bit&quot;: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                &quot;depends_on_map_bits&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;
                &lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; depends_on_map_bits &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
              }
            ] &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; table_dependencies &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          },
          {
            &quot;ref_optimizer_key_uses&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;
            &lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ref_optimizer_key_uses &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          },
          {
            &quot;rows_estimation&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
              {
                &quot;table&quot;: &quot;`dept` `d`&quot;,
                &quot;table_scan&quot;: {
                  &quot;rows&quot;: 4,
                  &quot;cost&quot;: 1
                } /* table_scan */
              },
              {
                &quot;table&quot;: &quot;`emp` `e`&quot;,
                &quot;table_scan&quot;: {
                  &quot;rows&quot;: 5,
                  &quot;cost&quot;: 1
                } /* table_scan */
              }
            &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; rows_estimation &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          },
          {
            &quot;considered_execution_plans&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
              {
                &quot;plan_prefix&quot;: [
                &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; plan_prefix &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;,
                &quot;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&quot;: &quot;`dept` `d`&quot;,
                &quot;best_access_path&quot;: {
                  &quot;considered_access_paths&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
                    {
                      &quot;rows_to_scan&quot;: 4,
                      &quot;access_type&quot;: &quot;scan&quot;,
                      &quot;resulting_rows&quot;: 4,
                      &quot;cost&quot;: 1.8,
                      &quot;chosen&quot;: true
                    }
                  &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; considered_access_paths &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                } &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; best_access_path &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;,
                &quot;condition_filtering_pct&quot;: &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;,
                &quot;rows_for_plan&quot;: &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
                &quot;cost_for_plan&quot;: &lt;/span&gt;&lt;span&gt;1.8&lt;/span&gt;&lt;span&gt;,
                &quot;rest_of_plan&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
                  {
                    &quot;plan_prefix&quot;: [
                      &quot;`dept` `d`&quot;
                    &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; plan_prefix &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;,
                    &quot;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&quot;: &quot;`emp` `e`&quot;,
                    &quot;best_access_path&quot;: {
                      &quot;considered_access_paths&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
                        {
                          &quot;rows_to_scan&quot;: 5,
                          &quot;access_type&quot;: &quot;scan&quot;,
                          &quot;using_join_cache&quot;: true,
                          &quot;buffers_needed&quot;: 1,
                          &quot;resulting_rows&quot;: 1,
                          &quot;cost&quot;: 2.6007,
                          &quot;chosen&quot;: true
                        }
                      &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; considered_access_paths &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    } &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; best_access_path &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;,
                    &quot;condition_filtering_pct&quot;: &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;,
                    &quot;rows_for_plan&quot;: &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
                    &quot;cost_for_plan&quot;: &lt;/span&gt;&lt;span&gt;4.4007&lt;/span&gt;&lt;span&gt;,
                    &quot;chosen&quot;: true
                  }
                ] &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; rest_of_plan &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
              },
              {
                &quot;plan_prefix&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;
                &lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; plan_prefix &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;,
                &quot;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&quot;: &quot;`emp` `e`&quot;,
                &quot;best_access_path&quot;: {
                  &quot;considered_access_paths&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
                    {
                      &quot;rows_to_scan&quot;: 5,
                      &quot;access_type&quot;: &quot;scan&quot;,
                      &quot;resulting_rows&quot;: 1,
                      &quot;cost&quot;: 2,
                      &quot;chosen&quot;: true
                    }
                  &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; considered_access_paths &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                } &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; best_access_path &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;,
                &quot;condition_filtering_pct&quot;: &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;,
                &quot;rows_for_plan&quot;: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                &quot;cost_for_plan&quot;: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                &quot;rest_of_plan&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
                  {
                    &quot;plan_prefix&quot;: [
                      &quot;`emp` `e`&quot;
                    &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; plan_prefix &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;,
                    &quot;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&quot;: &quot;`dept` `d`&quot;,
                    &quot;best_access_path&quot;: {
                      &quot;considered_access_paths&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
                        {
                          &quot;rows_to_scan&quot;: 4,
                          &quot;access_type&quot;: &quot;scan&quot;,
                          &quot;using_join_cache&quot;: true,
                          &quot;buffers_needed&quot;: 1,
                          &quot;resulting_rows&quot;: 4,
                          &quot;cost&quot;: 1.8002,
                          &quot;chosen&quot;: true
                        }
                      &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; considered_access_paths &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    } &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; best_access_path &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;,
                    &quot;condition_filtering_pct&quot;: &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;,
                    &quot;rows_for_plan&quot;: &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
                    &quot;cost_for_plan&quot;: &lt;/span&gt;&lt;span&gt;3.8002&lt;/span&gt;&lt;span&gt;,
                    &quot;chosen&quot;: true
                  }
                ] &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; rest_of_plan &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
              }
            ] &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; considered_execution_plans &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          },
          {
            &quot;attaching_conditions_to_tables&quot;: {
              &quot;original_condition&quot;: &quot;((`e`.`deptno` &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;) &lt;span&gt;and&lt;/span&gt; (`d`.`deptno` &lt;span&gt;=&lt;/span&gt;&lt;span&gt; `e`.`deptno`))&quot;,
              &quot;attached_conditions_computation&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;
              &lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; attached_conditions_computation &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;,
              &quot;attached_conditions_summary&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
                {
                  &quot;table&quot;: &quot;`emp` `e`&quot;,
                  &quot;attached&quot;: &quot;(`e`.`deptno` = 30)&quot;
                },
                {
                  &quot;table&quot;: &quot;`dept` `d`&quot;,
                  &quot;attached&quot;: &quot;(`d`.`deptno` = `e`.`deptno`)&quot;
                }
              &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; attached_conditions_summary &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            } &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; attaching_conditions_to_tables &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          },
          {
            &quot;refine_plan&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
              {
                &quot;table&quot;: &quot;`emp` `e`&quot;
              },
              {
                &quot;table&quot;: &quot;`dept` `d`&quot;
              }
            &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; refine_plan &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          }
        ] &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; steps &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; join_optimization &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    },
    {
      &quot;join_execution&quot;: {
        &quot;&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;#&quot;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
        &quot;steps&quot;: &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;
        &lt;span&gt;]&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; steps &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; join_execution &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
  ] &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; steps &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
} &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;                                 &lt;span&gt;0&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;                       &lt;span&gt;0&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--------------------------------------------------------------------------&lt;/span&gt;
&lt;span&gt;
mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/823295/202102/823295-20210220234826416-84933451.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;p&gt; 【完】&lt;/p&gt;


&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;1.嵌套循环连接算法：https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html&lt;/p&gt;
&lt;p&gt;2.外部连接优化：https://dev.mysql.com/doc/refman/5.7/en/outer-join-optimization.html&lt;/p&gt;

&lt;p&gt;&lt;span&gt; Note：MySQL菜鸟一枚，文章仅代表个人观点，如有不对，敬请指出，共同进步，谢谢。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 20 Feb 2021 15:35:00 +0000</pubDate>
<dc:creator>gegeman</dc:creator>
<og:description>导读： 在做MySQL数据库的优化工作时，如果只涉及到单表查询，那么95%的慢SQL都只需从索引上入手优化即可，通过添加索引来消除全表扫描或者排序操作，大概率能实现SQL语句执行速度质的飞跃。对于单表</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lijiaman/p/14381027.html</dc:identifier>
</item>
<item>
<title>实现TensorRT-7.0插件自由！(如果不踩坑使用TensorRT插件功能) - 老潘博客</title>
<link>http://www.cnblogs.com/bigoldpan/p/14423858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigoldpan/p/14423858.html</guid>
<description>&lt;p&gt;本系列为新TensorRT的第一篇，为什么叫新，因为之前已经写了两篇关于TensorRT的文章，是关于TensorRT-5.0版本的。好久没写关于TensorRT的文章了，所幸就以&lt;strong&gt;新&lt;/strong&gt;来开头吧~&lt;/p&gt;
&lt;p&gt;接下来将要讲解的TensorRT，将会是基于7.0版本。&lt;/p&gt;
&lt;p&gt;7版本开头的TensorRT变化还是挺大的，增加了很多新特性，但是TensorRT的核心运作方式还是没有什么变化的，关于TensorRT的介绍可以看之前写的这两篇：&lt;/p&gt;
&lt;p&gt;本文的内容呢，主要是讲解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TensorRT自定义插件的使用方式&lt;/li&gt;
&lt;li&gt;如何添加自己的自定义算子&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看完本篇可以让你&lt;strong&gt;少踩巨多坑&lt;/strong&gt;，客官记得常来看啊。&lt;/p&gt;

&lt;p&gt;随着tensorRT的不断发展(v5-&amp;gt;v6-&amp;gt;v7)，TensorRT的插件的使用方式也在不断更新。插件接口也在不断地变化，由v5版本的&lt;code&gt;IPluginV2Ext&lt;/code&gt;，到v6版本的&lt;code&gt;IPluginV2IOExt&lt;/code&gt;和&lt;code&gt;IPluginV2DynamicExt&lt;/code&gt;。未来不知道会不会出来新的API，不过这也不是咱要考虑的问题，因为TensorRT的后兼容性做的很好，根本不用担心你写的旧版本插件在新版本上无法运行。&lt;/p&gt;
&lt;p&gt;目前的plugin-API：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2304365/202102/2304365-20210220233348807-1309897715.png&quot; alt=&quot;QQ20201103-101737&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TensorRT插件的存在目的，主要是为了让我们&lt;strong&gt;实现TensorRT目前还不支持的算子&lt;/strong&gt;，毕竟众口难调嘛，我们在转换过程中肯定会有&lt;em&gt;op&lt;/em&gt;不支持的情况。这个时候就需要使用TensorRT的plugin去实现我们的自己的op。此时我们需要通过TensorRT提供的接口去实现自己的op，&lt;strong&gt;因此这个plugin的生命周期也需要遵循TensorRT的规则&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一个简单的了解&quot;&gt;一个简单的了解&lt;/h2&gt;
&lt;p&gt;那么plugin到底长啥样，可以先看看TensorRT的官方plugin库长啥样，截止写这篇文章时，master分支是7.2版本的plugin：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NVIDIA/TensorRT/tree/master/plugin&quot; target=&quot;_blank&quot;&gt;https://github.com/NVIDIA/TensorRT/tree/master/plugin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2304365/202102/2304365-20210220233349191-461444403.jpg&quot; alt=&quot;tensorrt-plugin&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;官方提供的插件已经相当多，而且TensorRT开源了plugin部分(可以让我们白嫖！)。并且可以看到其源码，通过模仿源码来学习plugin是如何写的。&lt;/p&gt;
&lt;p&gt;如果要添加自己的算子，可以在官方的plugin库里头进行修改添加，然后编译官方的plugin库。将生成的&lt;code&gt;libnvinfer_plugin.so.7&lt;/code&gt;替换原本的&lt;code&gt;.so&lt;/code&gt;文件即可。或者自己写一个类似于官方plugin的组件，将名称替换一下，同样生成&lt;code&gt;.so&lt;/code&gt;，在TensorRT的推理项目中引用这个动态链接库即可。&lt;/p&gt;
&lt;p&gt;以下介绍中，我们需要写的&lt;code&gt;IPlugin&lt;/code&gt;简称为插件op。&lt;/p&gt;

&lt;p&gt;有兴趣的可以先看看TensorRT的&lt;a href=&quot;https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html#extending&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;，官方文档的介绍简单意骇，不过坑是少不了的..而本文的目的，就是尽量让你少趟坑。&lt;/p&gt;
&lt;p&gt;首先按照官方plugin的排布方式，下面随便挑了个官方plugin：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2304365/202102/2304365-20210220233349445-2084541208.jpg&quot; alt=&quot;instance_normalization_plugin&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;准备一个自己的插件:&lt;code&gt;custom.cpp&lt;/code&gt;和&lt;code&gt;custom.h&lt;/code&gt;，copy并paste官方代码，名字替换成自己的。以最新的&lt;code&gt;IPluginV2DynamicExt&lt;/code&gt;类为接口。&lt;/p&gt;
&lt;p&gt;我们需要写两个类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;MyCustomPlugin&lt;/code&gt;，继承&lt;code&gt;IPluginV2DynamicExt&lt;/code&gt;，是插件类，用于写插件具体的实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyCustomPluginCreator&lt;/code&gt;，继承&lt;code&gt;BaseCreator&lt;/code&gt;，是插件工厂类，用于根据需求创建该插件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对了，插件类继承&lt;code&gt;IPluginV2DynamicExt&lt;/code&gt;才可以支持动态尺寸，其他插件类接口例如&lt;code&gt;IPluginV2IOExt&lt;/code&gt;和前者大部分是相似的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;// 继承IPluginV2DynamicExt就够啦
class MyCustomPlugin final : public nvinfer1::IPluginV2DynamicExt

class MyCustomPluginCreator : public BaseCreator
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;总览：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;class MyCustomPlugin final : public nvinfer1::IPluginV2DynamicExt
{

public:

  MyCustomPlugin( int in_channel,
                  const std::vector&amp;lt;float&amp;gt;&amp;amp; weight,
                  const std::vector&amp;lt;float&amp;gt;&amp;amp; bias);
                            
  MyCustomPlugin( int in_channel,
                  nvinfer1::Weights const&amp;amp; weight,
                  nvinfer1::Weights const&amp;amp; bias);

  MyCustomPlugin(void const* serialData, size_t serialLength);
  MyCustomPlugin() = delete;
  ~MyCustomPlugin() override;
  int getNbOutputs() const override;
  DimsExprs getOutputDimensions(int outputIndex, const nvinfer1::DimsExprs* inputs, int nbInputs, nvinfer1::IExprBuilder&amp;amp; exprBuilder) override;
  int initialize() override;
  void terminate() override;
  size_t getWorkspaceSize(const nvinfer1::PluginTensorDesc* inputs, int nbInputs, const nvinfer1::PluginTensorDesc* outputs, int nbOutputs) const override;
  int enqueue(const nvinfer1::PluginTensorDesc* inputDesc, const nvinfer1::PluginTensorDesc* outputDesc, 
              const void* const* inputs, void* const* outputs, 
              void* workspace, 
              cudaStream_t stream) override;
  size_t getSerializationSize() const override;
  void serialize(void* buffer) const override;
  bool supportsFormatCombination(int pos, const nvinfer1::PluginTensorDesc* inOut, int nbInputs, int nbOutputs) override;
  const char* getPluginType() const override;
  const char* getPluginVersion() const override;
  void destroy() override;
  nvinfer1::IPluginV2DynamicExt* clone() const override;
  void setPluginNamespace(const char* pluginNamespace) override;
  const char* getPluginNamespace() const override;
  DataType getOutputDataType(int index, const nvinfer1::DataType* inputTypes, int nbInputs) const override;
  void attachToContext(cudnnContext* cudnn, cublasContext* cublas, nvinfer1::IGpuAllocator* allocator) override;
  void detachFromContext() override;
  void configurePlugin(const nvinfer1::DynamicPluginTensorDesc* in, int nbInputs, 
                       const nvinfer1::DynamicPluginTensorDesc* out, int nbOutputs) override;
private:
    int _in_channel;
    std::vector&amp;lt;float&amp;gt; weight;
    std::vector&amp;lt;float&amp;gt; bias;
    float* weight;
    float* bias;
    bool _initialized;
    const char* mPluginNamespace;
    std::string mNamespace;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;成员变量&quot;&gt;成员变量&lt;/h2&gt;
&lt;p&gt;如果你的插件有weights(类似于conv操作的weight和bias)，有参数(类似于conv中的kernel-size、padding)，在类中则需要定义为成员变量，为&lt;code&gt;private&lt;/code&gt;类型：&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;MyCustomPlugin&lt;/code&gt;为例，假设我们的这个MyCustomPlugin有两个权重weight和bias以及一个参数in_channel(这个权重和参数没有啥意义，纯粹，纯粹为了演示)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;private:
    int  _in_channel; // 参数 
    std::vector&amp;lt;float&amp;gt; _weight; // 权重，在cpu空间存放
    std::vector&amp;lt;float&amp;gt; _bias;   // 偏置权重，在cpu空间存放
    float* _d_weight;           // 权重，在GPU空间存放
    float* _d_bias;
    bool _initialized;
    cudnnHandle_t _cudnn_handle;
    const char* mPluginNamespace;
    std::string mNamespace;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;构造函数和析构函数&quot;&gt;构造函数和析构函数&lt;/h2&gt;
&lt;p&gt;构造函数一般设置为三个。&lt;/p&gt;
&lt;p&gt;第一个用于在parse阶段，&lt;code&gt;PluginCreator&lt;/code&gt;用于创建该插件时调用的构造函数，需要传递权重信息以及参数。&lt;/p&gt;
&lt;p&gt;第二个用于在&lt;code&gt;clone&lt;/code&gt;阶段，复制这个plugin时会用到的构造函数。&lt;/p&gt;
&lt;p&gt;第三个用于在&lt;code&gt;deserialize&lt;/code&gt;阶段，用于将序列化好的权重和参数传入该plugin并创建爱你哦。&lt;/p&gt;
&lt;p&gt;以我们的&lt;code&gt;MyCustomPlugin&lt;/code&gt;为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;MyCustomPlugin(int in_channel, nvinfer1::Weights const&amp;amp; weight, nvinfer1::Weights const&amp;amp; bias);
MyCustomPlugin(float in_channel, const std::vector&amp;lt;float&amp;gt;&amp;amp; weight, const std::vector&amp;lt;float&amp;gt;&amp;amp; bias);
MyCustomPlugin(void const* serialData, size_t serialLength);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;析构函数则需要执行&lt;code&gt;terminate&lt;/code&gt;，&lt;code&gt;terminate&lt;/code&gt;函数就是释放这个op之前开辟的一些显存空间:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;MyCustomPlugin::~MyCustomPlugin()
{
    terminate();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意需要把默认构造函数删掉：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;MyCustomPlugin() = delete;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;getnboutputs&quot;&gt;getNbOutputs&lt;/h2&gt;
&lt;p&gt;插件op返回多少个Tensor，比如&lt;code&gt;MyCustomPlugin&lt;/code&gt;这个操作只输出一个Tensor(也就是一个output)，所以直接&lt;code&gt;return 1&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;// MyCustomPlugin returns one output.
int MyCustomPlugin::getNbOutputs() const
{
    return 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;initialize&quot;&gt;initialize&lt;/h2&gt;
&lt;p&gt;初始化函数，在这个插件准备开始run之前执行。&lt;/p&gt;
&lt;p&gt;主要初始化一些提前开辟空间的参数，一般是一些cuda操作需要的参数(例如conv操作需要执行卷积操作，我们就需要提前开辟weight和bias的显存)，假如我们的算子需要这些参数，则在这里需要提前开辟显存。&lt;/p&gt;
&lt;p&gt;需要注意的是，如果插件算子需要开辟比较大的显存空间，&lt;strong&gt;不建议自己去申请显存空间，可以使用Tensorrt官方接口传过来的workspace指针来获取显存空间&lt;/strong&gt;。因为如果这个插件被一个网络调用了很多次，而这个插件op需要开辟很多显存空间，那么TensorRT在构建network的时候会根据这个插件被调用的次数开辟很多显存，很容易导致显存溢出。&lt;/p&gt;
&lt;h2 id=&quot;getoutputdatatype&quot;&gt;getOutputDataType&lt;/h2&gt;
&lt;p&gt;返回结果的类型，一般来说我们插件op返回结果类型与输入类型一致：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;nvinfer1::DataType InstanceNormalizationPlugin::getOutputDataType(
    int index, const nvinfer1::DataType* inputTypes, int nbInputs) const
{
    ASSERT(inputTypes &amp;amp;&amp;amp; nbInputs &amp;gt; 0 &amp;amp;&amp;amp; index == 0);
    return inputTypes[0];
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;getworkspacesize&quot;&gt;getWorkspaceSize&lt;/h2&gt;
&lt;p&gt;这个函数需要返回这个插件op需要中间显存变量的实际数据大小(bytesize)，这个是通过TensorRT的接口去获取，是比较规范的方式。&lt;/p&gt;
&lt;p&gt;我们需要在这里确定这个op需要多大的显存空间去运行，在实际运行的时候就可以直接使用TensorRT开辟好的空间而不是自己去申请显存空间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;size_t MyCustomPlugin::getWorkspaceSize(const nvinfer1::PluginTensorDesc* inputs, int nbInputs, const nvinfer1::PluginTensorDesc* outputs, int nbOutputs) const 
{ 
    // 计算这个op前向过程中你认为需要的中间显存数量
    size_t need_num;
    return need_num * sizeof(float);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;enqueue&quot;&gt;enqueue&lt;/h2&gt;
&lt;p&gt;实际插件op的执行函数，我们自己实现的cuda操作就放到这里(当然C++写的op也可以放进来，不过因为是CPU执行，速度就比较慢了)，与往常一样接受输入&lt;code&gt;inputs&lt;/code&gt;产生输出&lt;code&gt;outputs&lt;/code&gt;，传给相应的指针就可以。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;int enqueue(const nvinfer1::PluginTensorDesc* inputDesc, const nvinfer1::PluginTensorDesc* outputDesc,
        const void* const* inputs, void* const* outputs, void* workspace, cudaStream_t stream){

            // 假如这个fun是你需要的中间变量 这里可以直接用TensorRT为你开辟的显存空间
            fun  = static_cast&amp;lt;float*&amp;gt;(workspace);

        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，如果我们的操作需要一些分布在显存中的中间变量，可以通过传过来的指针参数&lt;code&gt;workspace&lt;/code&gt;获取，上述代码简单说明了一下使用方法。&lt;/p&gt;
&lt;p&gt;再多说一句，我们默认写的&lt;code&gt;.cu&lt;/code&gt;是fp32的，TensorRT在fp16运行模式下，运行到不支持fp16的插件op时，会自动切换到fp32模式，等插件op运行完再切换回来。&lt;/p&gt;
&lt;h2 id=&quot;getoutputdimensions&quot;&gt;getOutputDimensions&lt;/h2&gt;
&lt;p&gt;TensorRT支持Dynamic-shape的时候，batch这一维度必须是explicit的，也就是说，TensorRT处理的维度从以往的三维[3,-1,-1]变成了[1,3,-1,-1]。最新的onnx-tensorrt也必须设置explicit的batchsize，而且这个batch维度在&lt;code&gt;getOutputDimensions&lt;/code&gt;中是可以获取到的。&lt;/p&gt;
&lt;p&gt;在旧版的IPluginV2类中，getOutputDimensions的定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;  virtual Dims getOutputDimensions(int index, const Dims* inputs, int nbInputDims) TRTNOEXCEPT = 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而在新版的IPluginV2DynamicExt类中定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;virtual DimsExprs getOutputDimensions(int outputIndex, const DimsExprs* inputs, int nbInputs, IExprBuilder&amp;amp; exprBuilder) = 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们要做的就是在这个成员函数中根据输入维度推理出模型的输出维度，需要注意的是，虽然说输出维度&lt;br/&gt;是由输入维度决定，但这个&lt;strong&gt;输出维度其实“内定”的&lt;/strong&gt;(也就是在计算之前就算出来了)。如果咱的插件op的输出维度需要通过实际运行计算得到，那么这个函数就无法满足咱了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2304365/202102/2304365-20210220233349809-2132721205.jpg&quot; alt=&quot;去你妈的好气哦&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;setgetpluginnamespace&quot;&gt;set/getPluginNamespace&lt;/h2&gt;
&lt;p&gt;为这个插件设置namespace名字，如果不设置则默认是&lt;code&gt;&quot;&quot;&lt;/code&gt;，需要注意的是同一个&lt;code&gt;namespace&lt;/code&gt;下的plugin如果名字相同会冲突。&lt;/p&gt;
&lt;h2 id=&quot;pluginfieldcollection&quot;&gt;PluginFieldCollection&lt;/h2&gt;
&lt;p&gt;这个是成员变量，也会作为&lt;code&gt;getFieldNames&lt;/code&gt;成员函数的返回类型。&lt;code&gt;PluginFieldCollection&lt;/code&gt;的主要作用是传递这个插件op所需要的权重和参数，在实际的engine推理过程中并不使用，而在parse中会用到(例如caffe2trt、onnx2trt)。&lt;/p&gt;
&lt;p&gt;当使用这些parse去解析这个op的时候，这个op的权重和参数会经历&lt;code&gt;Models --&amp;gt; TensorRT engine --&amp;gt; TensorRT runtime&lt;/code&gt;这个过程。&lt;/p&gt;
&lt;p&gt;举个例子，在&lt;a href=&quot;https://github.com/onnx/onnx-tensorrt&quot; target=&quot;_blank&quot;&gt;onnx-tensorrt&lt;/a&gt;中，我们用过&lt;code&gt;DEFINE_BUILTIN_OP_IMPORTER&lt;/code&gt;去注册op，然后通过parse解析onnx模型，根据注册好的op去一个个解析构建模型，假如我们定义的op为&lt;code&gt;my_custom_op&lt;/code&gt;,在&lt;code&gt;DEFINE_BUILTIN_OP_IMPORTER(my_custom_op)&lt;/code&gt;会这样实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;DEFINE_BUILTIN_OP_IMPORTER(mycustom_op)
{
    ASSERT(inputs.at(0).is_tensor(), ErrorCode::kUNSUPPORTED_NODE); 
    ...
    const std::string pluginName = &quot;CUSTOM-OP&quot;;
    const std::string pluginVersion = &quot;001&quot;;
    // 这个f保存这个op需要的权重和参数，从onnx模型中获取
    std::vector&amp;lt;nvinfer1::PluginField&amp;gt; f;

    f.emplace_back(&quot;in_channel&quot;, &amp;amp;in_channel, nvinfer1::PluginFieldType::kINT32, 1);
    f.emplace_back(&quot;weight&quot;, kernel_weights.values, nvinfer1::PluginFieldType::kFLOAT32, kernel_weights.count());
    f.emplace_back(&quot;bias&quot;, bias_weights.values, nvinfer1::PluginFieldType::kFLOAT32, bias_weights.count);

    // 这个从将plugin工厂中获取该插件，并且将权重和参数传递进去
    nvinfer1::IPluginV2* plugin = importPluginFromRegistry(ctx, pluginName, pluginVersion, node.name(), f);

    RETURN_FIRST_OUTPUT(ctx-&amp;gt;network()-&amp;gt;addPluginV2(tensors.data(), tensors.size(), *plugin));
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入&lt;code&gt;importPluginFromRegistry&lt;/code&gt;函数内部，可以发现参数通过&lt;code&gt;fc&lt;/code&gt;变量通过&lt;code&gt;createPlugin&lt;/code&gt;传递给了&lt;code&gt;plugin&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;nvinfer1::IPluginV2* importPluginFromRegistry(IImporterContext* ctx, const std::string&amp;amp; pluginName,
    const std::string&amp;amp; pluginVersion, const std::string&amp;amp; nodeName,
    const std::vector&amp;lt;nvinfer1::PluginField&amp;gt;&amp;amp; pluginFields)
{
    const auto mPluginRegistry = getPluginRegistry();
    const auto pluginCreator
        = mPluginRegistry-&amp;gt;getPluginCreator(pluginName.c_str(), pluginVersion.c_str(), &quot;ONNXTRT_NAMESPACE&quot;);

    if (!pluginCreator)
    {
        return nullptr;
    }
    // 接受传进来的权重和参数信息 传递给plugin
    nvinfer1::PluginFieldCollection fc;
    fc.nbFields = pluginFields.size();
    fc.fields = pluginFields.data();

    return pluginCreator-&amp;gt;createPlugin(nodeName.c_str(), &amp;amp;fc);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述步骤中，会提供&lt;code&gt;pluginName&lt;/code&gt;和&lt;code&gt;pluginVersion&lt;/code&gt;初始化&lt;code&gt;MyCustomPluginCreator&lt;/code&gt;，其中&lt;code&gt;createPlugin&lt;/code&gt;成员函数是我们需要编写的(下文会说)。&lt;/p&gt;
&lt;h2 id=&quot;configureplugin&quot;&gt;configurePlugin&lt;/h2&gt;
&lt;p&gt;配置这个插件op，判断输入和输出类型数量是否正确。官方还提到通过这个配置信息可以告知TensorRT去选择合适的算法(algorithm)去调优这个模型。&lt;/p&gt;
&lt;p&gt;但自动调优目前还没有尝试过，我们一般自己写的plugin执行代码都是定死的，所谓的调优步骤可能更多地针对官方的op。&lt;/p&gt;
&lt;p&gt;下面的plugin中&lt;code&gt;configurePlugin&lt;/code&gt;函数仅仅是简单地确认了下输入和输出以及类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void MyCustomPluginDynamic::configurePlugin(
    const nvinfer1::DynamicPluginTensorDesc *inputs, int nbInputs,
    const nvinfer1::DynamicPluginTensorDesc *outputs, int nbOutputs) {
  // Validate input arguments
  assert(nbOutputs == 1);
  assert(nbInputs == 2);
  assert(mType == inputs[0].desc.type);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;clone&quot;&gt;clone&lt;/h2&gt;
&lt;p&gt;这玩意儿干嘛的，顾名思义，就是克隆嘛，将这个&lt;code&gt;plugin&lt;/code&gt;对象克隆一份给TensorRT的builder、network或者engine。这个成员函数会调用上述说到的第二个构造函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;MyCustomPlugin(float in_channel, const std::vector&amp;lt;float&amp;gt;&amp;amp; weight, const std::vector&amp;lt;float&amp;gt;&amp;amp; bias);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将要克隆的plugin的权重和参数传递给这个构造函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;IPluginV2DynamicExt* MyCustomPlugin::clone() const
{ 
    // 
    auto plugin = new MyCustomPlugin{_in_channel, _weight, _bias};
    plugin-&amp;gt;setPluginNamespace(mPluginNamespace);
    return plugin;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;clone&lt;/code&gt;成员函数主要用于传递不变的权重和参数，将plugin复制n多份，从而可以被不同engine或者builder或者network使用。&lt;/p&gt;
&lt;h2 id=&quot;getserializationsize&quot;&gt;getSerializationSize&lt;/h2&gt;
&lt;p&gt;返回序列化时需要写多少字节到buffer中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;size_t MyCustomPlugin::getSerializationSize() const
{
    return (serialized_size(_in_channel) +
            serialized_size(_weight) +
            serialized_size(_bias)
            );
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;supportsformatcombination&quot;&gt;supportsFormatCombination&lt;/h2&gt;
&lt;p&gt;TensorRT调用此方法以判断pos索引的输入/输出是否支持&lt;code&gt;inOut[pos].format&lt;/code&gt;和&lt;code&gt;inOut[pos].type&lt;/code&gt;指定的格式/数据类型。&lt;/p&gt;
&lt;p&gt;如果插件支持&lt;code&gt;inOut[pos]&lt;/code&gt;处的格式/数据类型，则返回true。 如果&lt;code&gt;是否支持&lt;/code&gt;取决于其他的输入/输出格式/数据类型，则插件可以使其结果取决于&lt;code&gt;inOut[0..pos-1]&lt;/code&gt;中的格式/数据类型，该格式/数据类型将设置为插件支持的值。 这个函数不需要检查&lt;code&gt;inOut[pos + 1..nbInputs + nbOutputs-1]&lt;/code&gt;，pos的决定必须仅基于&lt;code&gt;inOut[0..pos]&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;bool MyCustomPlugin::supportsFormatCombination(
    int pos, const nvinfer1::PluginTensorDesc* inOut, int nbInputs, int nbOutputs)
{
    // 假设有一个输入一个输出
    assert(0 &amp;lt;= pos &amp;amp;&amp;amp; pos &amp;lt; 2);
    const auto *in = inOut;
    const auto *out = inOut + nbInputs;
    switch (pos) {
        case 0:
        return in[0].type == DataType::kFLOAT &amp;amp;&amp;amp;
                in[0].format == nvinfer1::TensorFormat::kLINEAR;
        case 1:
        return out[0].type == in[0].type &amp;amp;&amp;amp;
                out[0].format == nvinfer1::TensorFormat::kLINEAR;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;serialize&quot;&gt;serialize&lt;/h2&gt;
&lt;p&gt;把需要用的数据按照顺序序列化到buffer里头。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void MyCustomPlugin::serialize(void *buffer) const
{
    serialize_value(&amp;amp;buffer, _in_channel);
    serialize_value(&amp;amp;buffer, _weight);
    serialize_value(&amp;amp;buffer, _bias);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;attachtocontext&quot;&gt;attachToContext&lt;/h2&gt;
&lt;p&gt;如果这个op使用到了一些其他东西，例如&lt;code&gt;cublas handle&lt;/code&gt;，可以直接借助TensorRT内部提供的&lt;code&gt;cublas handle&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void MyCustomPlugin::attachToContext(cudnnContext* cudnnContext, cublasContext* cublasContext, IGpuAllocator* gpuAllocator)
{
     mCublas = cublasContext;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;总览：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;class MyCustomPluginCreator : public BaseCreator
{
public:
  MyCustomPluginCreator();
  ~MyCustomPluginCreator() override = default;
  const char* getPluginName() const override;    // 不介绍
  const char* getPluginVersion() const override; // 不介绍
  const PluginFieldCollection* getFieldNames() override; // 不介绍
  IPluginV2DynamicExt* createPlugin(const char* name, const nvinfer1::PluginFieldCollection* fc) override;
  IPluginV2DynamicExt* deserializePlugin(const char* name, const void* serialData, size_t serialLength) override;
private:
  static PluginFieldCollection mFC;
  static std::vector&amp;lt;PluginField&amp;gt; mPluginAttributes;
  std::string mNamespace;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;构造函数&lt;/h2&gt;
&lt;p&gt;创建一个空的&lt;code&gt;mPluginAttributes&lt;/code&gt;初始化&lt;code&gt;mFC&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;MyCustomPluginCreator::MyCustomPluginCreator()
{
    mPluginAttributes.emplace_back(PluginField(&quot;in_channel&quot;, nullptr, PluginFieldType::kFLOAT32, 1));
    mPluginAttributes.emplace_back(PluginField(&quot;weight&quot;, nullptr, PluginFieldType::kFLOAT32, 1));
    mPluginAttributes.emplace_back(PluginField(&quot;bias&quot;, nullptr, PluginFieldType::kFLOAT32, 1));
    
    mFC.nbFields = mPluginAttributes.size();
    mFC.fields = mPluginAttributes.data();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;createplugin&quot;&gt;createPlugin&lt;/h2&gt;
&lt;p&gt;这个成员函数作用是通过&lt;code&gt;PluginFieldCollection&lt;/code&gt;去创建plugin，将op需要的权重和参数一个一个取出来，然后调用上文提到的第一个构造函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;MyCustomPlugin(int in_channel, nvinfer1::Weights const&amp;amp; weight, nvinfer1::Weights const&amp;amp; bias);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;去创建plugin。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MyCustomPlugin&lt;/code&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;IPluginV2DynamicExt* MyCustomPlugin::createPlugin(const char* name, const nvinfer1::PluginFieldCollection* fc)
{
    int in_channel;
    std::vector&amp;lt;float&amp;gt; weight;
    std::vector&amp;lt;float&amp;gt; bias;
    const PluginField* fields = fc-&amp;gt;fields;
    for (int i = 0; i &amp;lt; fc-&amp;gt;nbFields; ++i)
    {
        const char* attrName = fields[i].name;
        if (!strcmp(attrName, &quot;in_channel&quot;))
        {
            ASSERT(fields[i].type == PluginFieldType::kINT32);
            in_channel= *(static_cast&amp;lt;const int32_t*&amp;gt;(fields[i].data));
        }
        else if (!strcmp(attrName, &quot;weight&quot;))
        {
            ASSERT(fields[i].type == PluginFieldType::kFLOAT32);
            int size = fields[i].length;
            h_weight.reserve(size);
            const auto* w = static_cast&amp;lt;const float*&amp;gt;(fields[i].data);
            for (int j = 0; j &amp;lt; size; j++)
            {
                h_weight.push_back(*w);
                w++;
            }
        }
        else if (!strcmp(attrName, &quot;bias&quot;))
        {
            ASSERT(fields[i].type == PluginFieldType::kFLOAT32);
            int size = fields[i].length;
            h_bias.reserve(size);
            const auto* w = static_cast&amp;lt;const float*&amp;gt;(fields[i].data);
            for (int j = 0; j &amp;lt; size; j++)
            {
                h_bias.push_back(*w);
                w++;
            }
        }
    }

    Weights weightWeights{DataType::kFLOAT, weight.data(), (int64_t) weight.size()};
    Weights biasWeights{DataType::kFLOAT, bias.data(), (int64_t)_bias.size()};

    MyCustomPlugin* obj = new MyCustomPlugin(in_channel, weightWeights, biasWeights);
    obj-&amp;gt;setPluginNamespace(mNamespace.c_str());
    return obj;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;deserializeplugin&quot;&gt;deserializePlugin&lt;/h2&gt;
&lt;p&gt;这个函数会被&lt;code&gt;onnx-tensorrt&lt;/code&gt;的一个叫做&lt;code&gt;TRT_PluginV2&lt;/code&gt;的转换op调用，这个op会读取onnx模型的&lt;code&gt;data&lt;/code&gt;数据将其反序列化到network中。&lt;/p&gt;

&lt;p&gt;使用官方插件会遇到些小问题。&lt;/p&gt;
&lt;h2 id=&quot;topk问题&quot;&gt;topk问题&lt;/h2&gt;
&lt;p&gt;官方的topk插件最多支持&lt;code&gt;k&amp;lt;=3840&lt;/code&gt;。否则会报：&lt;/p&gt;
&lt;p&gt;[TensorRT] ERROR: Parameter check failed at: ../builder/Layers.cpp::TopKLayer::3137, condition: k &amp;gt; 0 &amp;amp;&amp;amp; k &amp;lt;= MAX_TOPK_K&lt;/p&gt;
&lt;p&gt;相关问题：&lt;a href=&quot;https://github.com/tensorflow/tensorflow/issues/31671&quot; target=&quot;_blank&quot;&gt;https://github.com/tensorflow/tensorflow/issues/31671&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;batchednms问题&quot;&gt;batchednms问题&lt;/h2&gt;
&lt;p&gt;官方的&lt;code&gt;batchednms&lt;/code&gt;最大支持的&lt;code&gt;topk&lt;/code&gt;为4096，太大也会崩溃。不过可以修改源代码实现突破这个数值，但仍然有&lt;code&gt;bug&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;  void (*kernel[])(const int, const int, const int, const int, const float,
                     const bool, const bool, float *, T_SCORE *, int *,
                     T_SCORE *, int *, bool) = {
      P(1), P(2), P(3), P(4), P(5), P(6), P(7), P(8), P(9), P(10),
      P(11), P(12), P(13), P(14), P(15), P(16)
  };
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;简单说下plugin的注册流程。&lt;/p&gt;
&lt;p&gt;在加载&lt;code&gt;NvInferRuntimeCommon.h&lt;/code&gt;头文件的时候会得到一个&lt;code&gt;getPluginRegistry&lt;/code&gt;，这里类中包含了所有已经注册了的&lt;code&gt;IPluginCreator&lt;/code&gt;，在使用的时候我们通过&lt;code&gt;getPluginCreator&lt;/code&gt;函数得到相应的&lt;code&gt;IPluginCreator&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注册插件有两种方式，第一种可以看官方的plugin代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;extern &quot;C&quot; {
bool initLibNvInferPlugins(void* logger, const char* libNamespace)
{
    initializePlugin&amp;lt;nvinfer1::plugin::GridAnchorPluginCreator&amp;gt;(logger, libNamespace);
    initializePlugin&amp;lt;nvinfer1::plugin::NMSPluginCreator&amp;gt;(logger, libNamespace);
    initializePlugin&amp;lt;nvinfer1::plugin::ReorgPluginCreator&amp;gt;(logger, libNamespace);
    ...
    return true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;initializePlugin&lt;/code&gt;函数执行了&lt;code&gt;addPluginCreator&lt;/code&gt;函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;template &amp;lt;typename CreatorType&amp;gt;
void initializePlugin(void* logger, const char* libNamespace)
{
    PluginCreatorRegistry::getInstance().addPluginCreator&amp;lt;CreatorType&amp;gt;(logger, libNamespace);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;addPluginCreator&lt;/code&gt;函数又执行了&lt;code&gt;getPluginRegistry()-&amp;gt;registerCreator&lt;/code&gt;对&lt;code&gt;pluginCreator&lt;/code&gt;进行了注册，这样就完成注册任务了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;void addPluginCreator(void* logger, const char* libNamespace)
{
    ...
        if (mRegistryList.find(pluginType) == mRegistryList.end())
        {
            bool status = getPluginRegistry()-&amp;gt;registerCreator(*pluginCreator, libNamespace);
            if (status)
            {
                mRegistry.push(std::move(pluginCreator));
                mRegistryList.insert(pluginType);
                verboseMsg = &quot;Plugin creator registration succeeded - &quot; + pluginType;
            }
            else
            {
                errorMsg = &quot;Could not register plugin creator:  &quot; + pluginType;
            }
        }
        else
        {
            verboseMsg = &quot;Plugin creator already registered - &quot; + pluginType;
        }
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一种注册可以直接通过&lt;code&gt;REGISTER_TENSORRT_PLUGIN&lt;/code&gt;来注册：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;//!
//! \brief Return the plugin registry
//!
//  在加载`NvInferRuntimeCommon.h`头文件的时候会得到一个`getPluginRegistry`
extern &quot;C&quot; TENSORRTAPI nvinfer1::IPluginRegistry* getPluginRegistry();

namespace nvinfer1
{

template &amp;lt;typename T&amp;gt;
class PluginRegistrar
{
public:
    PluginRegistrar() { getPluginRegistry()-&amp;gt;registerCreator(instance, &quot;&quot;); }
private:
    T instance{};
};

#define REGISTER_TENSORRT_PLUGIN(name) \
    static nvinfer1::PluginRegistrar&amp;lt;name&amp;gt; pluginRegistrar##name {}

} // namespace nvinfer1

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，如果我们已经在plugin的&lt;code&gt;.h&lt;/code&gt;文件中执行了&lt;code&gt;REGISTER_TENSORRT_PLUGIN(BatchedNMSPluginCreator);&lt;/code&gt;就不需要再创建一个类似于官方的&lt;code&gt;initLibNvInferPlugins()&lt;/code&gt;函数去一个一个注册了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/NVIDIA/TensorRT/tree/release/7.0/plugin&quot; target=&quot;_blank&quot;&gt;https://github.com/NVIDIA/TensorRT/tree/release/7.0/plugin&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/triton-inference-server/server/issues/767&quot; target=&quot;_blank&quot;&gt;https://github.com/triton-inference-server/server/issues/767&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/u010552731/article/details/106520241&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u010552731/article/details/106520241&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html#work_dynamic_shapes&quot; target=&quot;_blank&quot;&gt;https://docs.nvidia.com/deeplearning/tensorrt/developer-guide/index.html#work_dynamic_shapes&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://forums.developer.nvidia.com/t/tensorrt-5-1-6-custom-plugin-with-fp16-issue/84132/4&quot; target=&quot;_blank&quot;&gt;https://forums.developer.nvidia.com/t/tensorrt-5-1-6-custom-plugin-with-fp16-issue/84132/4&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://forums.developer.nvidia.com/t/tensorrt-cask-error-in-checkcaskexecerror-false-7-cask-convolution-execution/109735&quot; target=&quot;_blank&quot;&gt;https://forums.developer.nvidia.com/t/tensorrt-cask-error-in-checkcaskexecerror-false-7-cask-convolution-execution/109735&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/NVIDIA/TensorRT/tree/release/7.0/samples/opensource/samplePlugin&quot; target=&quot;_blank&quot;&gt;https://github.com/NVIDIA/TensorRT/tree/release/7.0/samples/opensource/samplePlugin&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://forums.developer.nvidia.com/t/unable-to-run-two-tensorrt-models-in-a-cascade-manner/145274/2&quot; target=&quot;_blank&quot;&gt;https://forums.developer.nvidia.com/t/unable-to-run-two-tensorrt-models-in-a-cascade-manner/145274/2&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;dcnv2-github&quot;&gt;DCNv2-github&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CharlesShang/DCNv2&quot; target=&quot;_blank&quot;&gt;https://github.com/CharlesShang/DCNv2&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/chengdazhi/Deformable-Convolution-V2-PyTorch&quot; target=&quot;_blank&quot;&gt;https://github.com/chengdazhi/Deformable-Convolution-V2-PyTorch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果你与我志同道合于此，老潘很愿意与你交流；如果你喜欢老潘的内容，欢迎关注和支持。博客每周更新一篇深度原创文，关注公众号「&lt;strong&gt;oldpan博客&lt;/strong&gt;」不错过最新文章。老潘也会整理一些自己的私藏，希望能帮助到大家，公众号回复&quot;888&quot;获取老潘学习路线资料与文章汇总，还有更多等你挖掘。如果不想错过老潘的最新推文，请点击&lt;a href=&quot;https://oldpan.me/archives/oldpan-treasure-updating&quot; target=&quot;_blank&quot;&gt;神秘链接&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Sat, 20 Feb 2021 15:34:00 +0000</pubDate>
<dc:creator>老潘博客</dc:creator>
<og:description>本系列为新TensorRT的第一篇，为什么叫新，因为之前已经写了两篇关于TensorRT的文章，是关于TensorRT-5.0版本的。好久没写关于TensorRT的文章了，所幸就以新来开头吧~ 接下来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigoldpan/p/14423858.html</dc:identifier>
</item>
<item>
<title>【Android初级】如何实现一个有动画效果的自定义下拉菜单 - snowyeti</title>
<link>http://www.cnblogs.com/snowyeti/p/14423857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowyeti/p/14423857.html</guid>
<description>&lt;p&gt;我们在购物APP里面设置收货地址时，都会有让我们选择省份及城市的下拉菜单项。今天我将使用Android原生的 &lt;strong&gt;Spinner&lt;/strong&gt; 控件来实现一个自定义的下拉菜单功能，并配上一个透明渐变动画效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要实现的功能及思路如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下拉菜单样式是自定义的、非原生效果：需要使用 setDropDownViewResource 方法来设置下拉视图的布局样式。该方法需要传入布局资源，该布局需要定义每个 Item 的属性，比如宽高和文字颜色等（为了使效果明显，我将每个 Item 的高度设置为 50 dp，文字设置为蓝色）&lt;/li&gt;
&lt;li&gt;点击这个 Spinner 控件时，让其运行一段“从左到右、逐渐显示”的渐变动画：我通过 xml 的方式来定义这个动画，需要包含 translate（位移） 和 alpha（透明度） 两个TAG，并设置相应的属性值&lt;/li&gt;
&lt;li&gt;下拉菜单的内容列表要展示在 Spinner 里面，需要通过适配器 Adapter 跟 Spinner 进行绑定：可以直接使用Android原生的 ArrayAdapter&lt;/li&gt;
&lt;li&gt;选择任意一个 Item 后，将其内容展示在界面上，告知用户选择的内容：需要实现 Spinner 的 onItemSelected 监听回调&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;源码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、主Activity&lt;/strong&gt;（注意代码中的注释，不然你会遇到一些坑！）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SpinnerDemo extends Activity {
    private static final String[] countries = {&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;, &quot;成都&quot;, &quot;杭州&quot;};

    private TextView mTextView;
    private Spinner mSpinner;
    private ArrayAdapter&amp;lt;String&amp;gt; mAdapter;
    private Animation mAnimation;

    @Override
    protected void onCreate(Bundle onSavedInstance) {
        super.onCreate(onSavedInstance);
        setContentView(R.layout.spinner_demo);

        mTextView = findViewById(R.id.textView9);
        mSpinner = findViewById(R.id.spinner);

        mAdapter = new ArrayAdapter&amp;lt;&amp;gt;(this, android.R.layout.simple_spinner_item, countries);

        // 自定义的下拉视图布局样式
        mAdapter.setDropDownViewResource(R.layout.spinner_drop_down);

        // 设置数据的适配器
        mSpinner.setAdapter(mAdapter);

        mSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            @Override
            public void onItemSelected(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {
                mTextView.setText(&quot;你选择的是：&quot; + countries[position]);

                // 一定要设置父视图可见，否则 在选择后，Spinner会消失
                parent.setVisibility(View.VISIBLE);
            }

            @Override
            public void onNothingSelected(AdapterView&amp;lt;?&amp;gt; parent) {
            }
        });

        // 通过 xml 的形式来定义动画
        mAnimation = AnimationUtils.loadAnimation(this, R.anim.my_anim);
        mSpinner.setOnTouchListener(new Spinner.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                // 点击 Spinner 后，运行动画
                v.startAnimation(mAnimation);
                return false;
            }
        });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、布局文件 spinner_demo.xml 如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;match_parent&quot;
              android:orientation=&quot;vertical&quot;&amp;gt;

    &amp;lt;TextView android:layout_width=&quot;wrap_content&quot;
              android:layout_height=&quot;wrap_content&quot;
              android:layout_gravity=&quot;center&quot;
              android:id=&quot;@+id/textView9&quot;/&amp;gt;

    &amp;lt;Spinner android:layout_width=&quot;wrap_content&quot;
             android:layout_height=&quot;wrap_content&quot;
             android:id=&quot;@+id/spinner&quot;
             android:layout_gravity=&quot;center&quot;
             android:layout_marginTop=&quot;15dp&quot;/&amp;gt;

&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3、自定义的下拉视图样式布局文件 spinner_drop_down.xml 如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
              android:layout_width=&quot;wrap_content&quot;
              android:layout_height=&quot;50dp&quot;
              android:textColor=&quot;@color/colorBlue&quot;
              android:singleLine=&quot;true&quot;
              style=&quot;?android:attr/spinnerDropDownItemStyle&quot;&amp;gt;
&amp;lt;/TextView&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4、自定义动画 xml 文件如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;gt;
    &amp;lt;translate
        android:fromXDelta=&quot;0&quot;
        android:toXDelta=&quot;50%p&quot;
        android:duration=&quot;2000&quot;/&amp;gt;

    &amp;lt;alpha
        android:fromAlpha=&quot;0.0&quot;
        android:toAlpha=&quot;1.0&quot;
        android:duration=&quot;2000&quot;/&amp;gt;
&amp;lt;/set&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5、效果图如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1263158/202102/1263158-20210220233304338-1423100428.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Feb 2021 15:33:00 +0000</pubDate>
<dc:creator>snowyeti</dc:creator>
<og:description>我们在购物APP里面设置收货地址时，都会有让我们选择省份及城市的下拉菜单项。今天我将使用Android原生的 Spinner 控件来实现一个自定义的下拉菜单功能，并配上一个透明渐变动画效果。 要实现的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snowyeti/p/14423857.html</dc:identifier>
</item>
<item>
<title>re模块之简单计算器的实现 - guguguhuha</title>
<link>http://www.cnblogs.com/guguguhuha/p/14423853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guguguhuha/p/14423853.html</guid>
<description>&lt;p&gt;本节大纲： 表达式的输入及检查、格式化 怎么样进行匹配最里面的括号以及操作数的匹配 如何实现表达式的四则运算 完整代码展示&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;158&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;本节大纲：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;表达式的输入及检查、格式化&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;怎么样进行匹配最里面的括号以及操作数的匹配&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;如何实现表达式的四则运算&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;完整代码展示&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在我们学习re模块之后，通常的练习就是利用所学相关知识来写一个计算器&lt;/p&gt;
&lt;p&gt;那么，现在我们开始理一下思路：&lt;/p&gt;
&lt;h2&gt;1.表达式的输入及检查、格式化&lt;/h2&gt;
&lt;h3&gt;1.1 输入&lt;/h3&gt;
&lt;p&gt;首先呢，我们肯定要让用户先输入一个表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
strs = input()
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;1.2 检查&lt;/h3&gt;
&lt;p&gt;之后，我们要做的就是检查所输入内容的合法性，这里我们用一个函数来封装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; check_str(s):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查字符串是否合法&lt;/span&gt;
    flag = True  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化假设字符串合法&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; s.count(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) != s.count(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查（）是否个数相等&lt;/span&gt;
        flag =&lt;span&gt; False
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; re.search(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[a-zA-Z]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, s):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查是否出现了非法字符&lt;/span&gt;
        flag =&lt;span&gt; False
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;    print(&quot;该表达式的合法性为：%s&quot; % flag)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; flag
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所相应的匹配程序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; check_str(strs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;非法表达式！请重新输入&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        strs &lt;/span&gt;= input()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
IN:(1+1&lt;span&gt;
OUT:非法表达式！请重新输入
&lt;/span&gt;IN:1+&lt;span&gt;2p
OUT:非法表达式！请重新输入
&lt;/span&gt;IN:2+3&lt;br/&gt;OUT:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，在上述代码中，非法字符的检测并不完善，这肯定需要改善，具体思路为：&lt;/p&gt;
&lt;p&gt; 在我们输入表达式的时候，所输入的字符无非就如下几种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数字  1~9&lt;/li&gt;
&lt;li&gt;运算符号  + - * /&lt;/li&gt;
&lt;li&gt;左右括号  (  )&lt;/li&gt;
&lt;li&gt;空格  “ ”&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以我们只需做出相应的匹配即可&lt;/p&gt;

&lt;h3&gt;1.3 格式化&lt;/h3&gt;
&lt;p&gt;接下来我们要做的就是将表达式格式化---为了匹配的准确性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; format_str(s):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 格式化字符串&lt;/span&gt;
    s = s.replace(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
    s &lt;/span&gt;= s.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    s &lt;/span&gt;= s.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    s &lt;/span&gt;= s.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    s &lt;/span&gt;= s.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    s &lt;/span&gt;= s.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    s &lt;/span&gt;= s.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;    print(&quot;该表达式格式化后的结果为：%s&quot; % s)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; s
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.&lt;strong&gt;怎么样进行匹配最里面的括号以及操作数的匹配&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;2.1.最里面的括号&lt;/h3&gt;
&lt;p&gt;为什么要匹配最里面的括号呢？&lt;/p&gt;
&lt;p&gt;当然是为了优先级啊&lt;/p&gt;
&lt;p&gt;那么怎么匹配呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re

strs &lt;/span&gt;=&lt;span&gt; input()
ret &lt;/span&gt;= re.search(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\([^()]+\)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, strs)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ret:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret.group())
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210220224459650-1682906155.png&quot; alt=&quot;&quot; width=&quot;889&quot; height=&quot;450&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
IN：(1+(1+(1+1&lt;span&gt;)))
OUT:(&lt;/span&gt;1+1)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
IN:1+1&lt;span&gt;
OUT:None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2 操作数的匹配&lt;/h3&gt;
&lt;p&gt;我们的日常使用中操作数不仅仅只是整形，还有浮点型，所以我们需要考虑的就要多一点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*-coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re

s &lt;/span&gt;=&lt;span&gt; input()
ret &lt;/span&gt;= re.search(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(?P&amp;lt;num1&amp;gt;\d+(?:\.\d+)?)(?P&amp;lt;sign&amp;gt;[*/])(?P&amp;lt;num2&amp;gt;[+-]?\d+(?:\.\d+)?)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, s)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ret:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exp:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;ret.group())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;num1:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%ret.group(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;num1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sign:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%ret.group(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sign&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;num2:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%ret.group(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;num2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230905/202102/2230905-20210220225951561-314127941.png&quot; alt=&quot;&quot; width=&quot;795&quot; height=&quot;259&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
IN：1*1&lt;span&gt;
OUT:exp:&lt;/span&gt;1*1&lt;span&gt;
    num1:&lt;/span&gt;1&lt;span&gt;
    sign:&lt;/span&gt;*&lt;span&gt;
    num2:&lt;/span&gt;1    
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
IN:1.3/3.2&lt;span&gt;
OUT:exp:&lt;/span&gt;1.3/3.2&lt;span&gt;
    num1:&lt;/span&gt;1.3&lt;span&gt;
    sign:&lt;/span&gt;/&lt;span&gt;
    num2:&lt;/span&gt;3.2
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3.四则运算&lt;/h2&gt;
&lt;h3&gt;3.1 乘除法&lt;/h3&gt;
&lt;p&gt;在我们传递完最里面括号的内容后，我们要不断的匹配，计算，替换，直至最后没有括号&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;先一直循环，然后不断匹配符合要求的表达式，进行运算，替换，再匹配，直至匹配不到表达式，退出循环&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*-coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; div_mul(s):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行表达式中乘或除的计算&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        ret &lt;/span&gt;= re.search(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(?P&amp;lt;num1&amp;gt;\d+(?:\.\d+)?)(?P&amp;lt;sign&amp;gt;[*/])(?P&amp;lt;num2&amp;gt;[+-]?\d+(?:\.\d+)?)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, s)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 匹配乘或除的式子，&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第二个操作数可以匹配符号，防止比如 1*-3匹配不到&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一个操作数没有匹配符号是因为防止 1-2*-3 --&amp;gt; 1  (-2*-3) --&amp;gt; 1 6 --&amp;gt;在下一个函数中成为 1+6 --&amp;gt; 7  的错误结果&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ret = re.search(&quot;(?P&amp;lt;num1&amp;gt;\d+(?:\.\d+)?)(?P&amp;lt;sign&amp;gt;[*/])(?P&amp;lt;num2&amp;gt;\d+(?:\.\d+)?)&quot;, s)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; if not ret:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     ret = re.search(&quot;(?P&amp;lt;num1&amp;gt;\d+(?:\.\d+)?)(?P&amp;lt;sign&amp;gt;[*/])(?P&amp;lt;num2&amp;gt;[+-]?\d+(?:\.\d+)?)&quot;, s)&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; ret:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果ret不为空就代表表达式中含有加或减的式子&lt;/span&gt;
            exp = ret.group()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把表达式分离开来&lt;/span&gt;
            num1 = ret.group(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;num1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 操作数1&lt;/span&gt;
            num2 = ret.group(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;num2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 操作数2&lt;/span&gt;
            sign = ret.group(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sign&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运算符号&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; sign == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 乘法&lt;/span&gt;
                result = float(num1) *&lt;span&gt; float(num2)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sign == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 除法&lt;/span&gt;
                result = float(num1) /&lt;span&gt; float(num2)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}{}{}={}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(num1, sign, num2, result))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果的打印&lt;/span&gt;
            s = s.replace(exp, str(result))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将计算结果替代表达式&lt;/span&gt;

        &lt;span&gt;else&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果ret为空就代表该表达式中已经没有乘或除的式子了，就跳出循环&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;s = format_str(s)  # 格式化该字符串中的输出结果&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s


s &lt;/span&gt;=&lt;span&gt; input()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(div_mul(s))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
IN:1+3*2-7*2&lt;span&gt;
OUT:&lt;/span&gt;3*2=6.0
    7*2=14.0
    1+6.0-14.0
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2 加减法&lt;/h3&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;将表达式中所有的数字分割为 一个操作数加上它前面的符号，最后对这些数进行统一的相加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*-coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools&lt;/span&gt;&lt;span&gt;
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; add_sub(s):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行表达式中加或减的计算&lt;/span&gt;
    result = 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先定义一个求和的总变量为0&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; re.search(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[+-]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, s):
        ret &lt;/span&gt;= re.findall(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[+/-]?\d+(?:\.\d+)?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, s)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只匹配一个数字以及该数字前的符号，最后进行相加&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(ret)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印所匹配的内容，即所有要相加的数&lt;/span&gt;
        result = str(functools.reduce(&lt;span&gt;lambda&lt;/span&gt; x, y: float(x) + float(y), ret))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行各个数的相加&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
        s &lt;/span&gt;= s.replace(s, result)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将计算结果替代表达式&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s


s &lt;/span&gt;=&lt;span&gt; input()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(add_sub(s))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
IN:1-2+3.2+1.7-5.2&lt;span&gt;
OUT:[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+3.2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+1.7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-5.2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;-1.2999999999999998
    -1.2999999999999998
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在这我们的四则运算也准备好了，最后我们要做的就是如何把表达式合理的送如四则运算中。&lt;/p&gt;
&lt;p&gt;还是不断的进行运算、替换&lt;/p&gt;
&lt;p&gt;值得一提的是，算完之后，我们要记得去其括号，进行下一个（）的匹配&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;while&lt;/span&gt; re.search(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, strs):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果还有（）就进入循环&lt;/span&gt;
        ret = re.search(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\([^()]+\)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, strs)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 匹配最里面的（）&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ret):
            exp &lt;/span&gt;= ret.group()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行表达式的分离&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(exp)
            result &lt;/span&gt;= calc(exp)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行表达式的计算&lt;/span&gt;
            strs = strs.replace(exp, result)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表达式与结果的替换&lt;/span&gt;
            strs = format_str(strs)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 格式化&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(strs)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;4.完整代码展示：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: UTF-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; format_str(s):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 格式化字符串&lt;/span&gt;
    s = s.replace(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
    s &lt;/span&gt;= s.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    s &lt;/span&gt;= s.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    s &lt;/span&gt;= s.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    s &lt;/span&gt;= s.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    s &lt;/span&gt;= s.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    s &lt;/span&gt;= s.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;    print(&quot;该表达式格式化后的结果为：%s&quot; % s)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; check_str(s):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查字符串是否合法&lt;/span&gt;
    flag = True  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化假设字符串合法&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; s.count(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) != s.count(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查（）是否个数相等&lt;/span&gt;
        flag =&lt;span&gt; False
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; re.search(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[a-zA-Z]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, s):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查是否出现了非法字符&lt;/span&gt;
        flag =&lt;span&gt; False
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;    print(&quot;该表达式的合法性为：%s&quot; % flag)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; flag


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; div_mul(s):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行表达式中乘或除的计算&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        ret &lt;/span&gt;= re.search(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(?P&amp;lt;num1&amp;gt;\d+(?:\.\d+)?)(?P&amp;lt;sign&amp;gt;[*/])(?P&amp;lt;num2&amp;gt;[+-]?\d+(?:\.\d+)?)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, s)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 匹配乘或除的式子，&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第二个操作数可以匹配符号，防止比如 1*-3匹配不到&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一个操作数没有匹配符号是因为防止 1-2*-3 --&amp;gt; 1  (-2*-3) --&amp;gt; 1 6 --&amp;gt;在下一个函数中成为 1+6 --&amp;gt; 7  的错误结果&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ret = re.search(&quot;(?P&amp;lt;num1&amp;gt;\d+(?:\.\d+)?)(?P&amp;lt;sign&amp;gt;[*/])(?P&amp;lt;num2&amp;gt;\d+(?:\.\d+)?)&quot;, s)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; if not ret:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     ret = re.search(&quot;(?P&amp;lt;num1&amp;gt;\d+(?:\.\d+)?)(?P&amp;lt;sign&amp;gt;[*/])(?P&amp;lt;num2&amp;gt;[+-]?\d+(?:\.\d+)?)&quot;, s)&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; ret:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果ret不为空就代表表达式中含有加或减的式子&lt;/span&gt;
            exp = ret.group()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把表达式分离开来&lt;/span&gt;
            num1 = ret.group(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;num1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 操作数1&lt;/span&gt;
            num2 = ret.group(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;num2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 操作数2&lt;/span&gt;
            sign = ret.group(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sign&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运算符号&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; sign == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 乘法&lt;/span&gt;
                result = float(num1) *&lt;span&gt; float(num2)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sign == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 除法&lt;/span&gt;
                result = float(num1) /&lt;span&gt; float(num2)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}{}{}={}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(num1, sign, num2, result))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果的打印&lt;/span&gt;
            s = s.replace(exp, str(result))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将计算结果替代表达式&lt;/span&gt;

        &lt;span&gt;else&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果ret为空就代表该表达式中已经没有乘或除的式子了，就跳出循环&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;
    s &lt;/span&gt;= format_str(s)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 格式化该字符串中的输出结果&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; add_sub(s):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行表达式中加或减的计算&lt;/span&gt;
    result = 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先定义一个求和的总变量为0&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; re.search(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[+-]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, s):
        ret &lt;/span&gt;= re.findall(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[+/-]?\d+(?:\.\d+)?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, s)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只匹配一个数字以及该数字前的符号，最后进行相加&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(ret)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印所匹配的内容，即所有要相加的数&lt;/span&gt;
        result = str(functools.reduce(&lt;span&gt;lambda&lt;/span&gt; x, y: float(x) + float(y), ret))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行各个数的相加&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
        s &lt;/span&gt;= s.replace(s, result)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将计算结果替代表达式&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; calc(s):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行表达式的计算&lt;/span&gt;
    s =&lt;span&gt; div_mul(s)
    s &lt;/span&gt;=&lt;span&gt; add_sub(s)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; s = s.replace(&quot;(&quot;, &quot;&quot;)#去括号&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; s = s.replace(&quot;)&quot;, &quot;&quot;)&lt;/span&gt;
    s = s.strip(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去括号&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该表达式计算后的结果为：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; s)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    strs &lt;/span&gt;=&lt;span&gt; input()

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; check_str(strs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;非法表达式！请重新输入&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        strs &lt;/span&gt;=&lt;span&gt; input()

    strs &lt;/span&gt;=&lt;span&gt; format_str(strs)

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; re.search(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, strs):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果还有（）就进入循环&lt;/span&gt;
        ret = re.search(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\([^()]+\)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, strs)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 匹配最里面的（）&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ret):
            exp &lt;/span&gt;= ret.group()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行表达式的分离&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(exp)
            result &lt;/span&gt;= calc(exp)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行表达式的计算&lt;/span&gt;
            strs = strs.replace(exp, result)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表达式与结果的替换&lt;/span&gt;
            strs = format_str(strs)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 格式化&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(strs)

    strs &lt;/span&gt;=&lt;span&gt; calc(strs)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(strs)


main()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(eval(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1-2*((60-30 +(9-2*5/3+7/3*99/4*2998+10*568/14)*(-40 / 5))-(-4*3)/(16-3*2))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1-2*((60-30 +(9-2*5/3+7/3*99/4*2998+10*568/14)*(-40 / 5))-(-4*3)/(16-3*2))&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2776672.6952380957&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
IN: 1-2*((60-30 +(9-2*5/3+7/3*99/4*2998+10*568/14)*(-40 / 5))-(-4*3)/(16-3*2&lt;span&gt;))
OUT:(&lt;/span&gt;9-2*5/3+7/3*99/4*2998+10*568/14&lt;span&gt;)
    &lt;/span&gt;2*5=10.0
    10.0/3=3.3333333333333335
    7/3=2.3333333333333335
    2.3333333333333335*99=231.00000000000003
    231.00000000000003/4=57.75000000000001
    57.75000000000001*2998=173134.50000000003
    10*568=5680.0
    5680.0/14=405.7142857142857&lt;span&gt;
    [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-3.3333333333333335&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+173134.50000000003&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+405.7142857142857&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;173545.88095238098&lt;span&gt;
    该表达式计算后的结果为：&lt;/span&gt;173545.88095238098
    1-2*((60-30+173545.88095238098*(-40/5))-(-4*3)/(16-3*2&lt;span&gt;))
    (&lt;/span&gt;-40/5&lt;span&gt;)
    &lt;/span&gt;40/5=8.0&lt;span&gt;
    [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-8.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;-8.0&lt;span&gt;
    该表达式计算后的结果为：&lt;/span&gt;-8.0
    1-2*((60-30+173545.88095238098*-8.0)-(-4*3)/(16-3*2&lt;span&gt;))
    (&lt;/span&gt;60-30+173545.88095238098*-8.0&lt;span&gt;)
    &lt;/span&gt;173545.88095238098*-8.0=-1388367.0476190478&lt;span&gt;
    [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-30&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-1388367.0476190478&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;-1388337.0476190478&lt;span&gt;
    该表达式计算后的结果为：&lt;/span&gt;-1388337.0476190478
    1-2*(-1388337.0476190478-(-4*3)/(16-3*2&lt;span&gt;))
    (&lt;/span&gt;-4*3&lt;span&gt;)
    &lt;/span&gt;4*3=12.0&lt;span&gt;
    [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-12.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;-12.0&lt;span&gt;
    该表达式计算后的结果为：&lt;/span&gt;-12.0
    1-2*(-1388337.0476190478+12.0/(16-3*2&lt;span&gt;))
    (&lt;/span&gt;16-3*2&lt;span&gt;)
    &lt;/span&gt;3*2=6.0&lt;span&gt;
    [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-6.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;10.0&lt;span&gt;
    该表达式计算后的结果为：&lt;/span&gt;10.0
    1-2*(-1388337.0476190478+12.0/10.0&lt;span&gt;)
    (&lt;/span&gt;-1388337.0476190478+12.0/10.0&lt;span&gt;)
    &lt;/span&gt;12.0/10.0=1.2&lt;span&gt;
    [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-1388337.0476190478&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+1.2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;-1388335.8476190479&lt;span&gt;
    该表达式计算后的结果为：&lt;/span&gt;-1388335.8476190479
    1-2*-1388335.8476190479
    2*-1388335.8476190479=-2776671.6952380957&lt;span&gt;
    [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+2776671.6952380957&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;2776672.6952380957&lt;span&gt;
    该表达式计算后的结果为：&lt;/span&gt;2776672.6952380957
    2776672.6952380957
    2776672.6952380957
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在这，为了比对运算结果是否正确，笔者特地拿了 eval 进行计算，显然测试后：两结果相同&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Sat, 20 Feb 2021 15:31:00 +0000</pubDate>
<dc:creator>guguguhuha</dc:creator>
<og:description>本节大纲： 表达式的输入及检查、格式化 怎么样进行匹配最里面的括号以及操作数的匹配 如何实现表达式的四则运算 完整代码展示</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guguguhuha/p/14423853.html</dc:identifier>
</item>
<item>
<title>《数据结构与算法分析》学习笔记-第十章-算法设计技巧 - CrazyCatJack</title>
<link>http://www.cnblogs.com/CrazyCatJack/p/14408191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CrazyCatJack/p/14408191.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;101-贪婪算法&quot;&gt;10.1 贪婪算法&lt;/h2&gt;
&lt;p&gt;贪婪算法分阶段的工作，在每个阶段，可以认为所做决定是最好的，而不考虑将来的后果。一般来说，这意味着选择的是某个局部的最优。当算法终止时，我们希望局部最优就是全局最优。如果是这样的话，那么算法就是正确的，否则，算法得到的是一个次最优解。如果不要求绝对最佳答案，那么有时用简单的贪婪算法生成近似答案，而不是使用一般来说产生准确答案所需要的复杂算法。&lt;/p&gt;
&lt;h3 id=&quot;1011-调度问题&quot;&gt;10.1.1 调度问题&lt;/h3&gt;
&lt;h3 id=&quot;10111-单处理器&quot;&gt;10.1.1.1 单处理器&lt;/h3&gt;
&lt;p&gt;设有作业j1,j2,j3,j4，其对应的运行时间分别为t1,t2,t3,t4.而处理器只有一个。为了把作业的平均完成的时间最小化，调度这些作业最优的顺序是什么。如果按照顺序调度，那么调度作业的平均时间为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t1
t1+t2
t1+t2+t3
t1+t2+t3+t4
求和：4t1+3t2+2t3+t4
求平均调度时间：4t1+3t2+2t3+t4/4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显而易见，如果希望平均调度时间最优，那么就要优先做耗时较短的工作，因此操作系统调度程序一般把优先权赋予那些更短的作业。&lt;/p&gt;
&lt;h3 id=&quot;10112-多处理器&quot;&gt;10.1.1.2 多处理器&lt;/h3&gt;
&lt;p&gt;让最短的作业先运行，按照作业运行时间从短到长的顺序，依次轮流让不同的处理器进行处理&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CPU1 j1 j4 j7
CPU2 j2 j5 j8
CPU3 j3 j6 j9
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之前的操作都是将平均调度时间最小化，如果想将最后完成时间最小化就不是很容易，即让整个序列完成的时间更早。&lt;/p&gt;
&lt;h3 id=&quot;1012-huffman编码&quot;&gt;10.1.2 Huffman编码&lt;/h3&gt;
&lt;p&gt;文件压缩中常见。ASCII码中有100个左右可打印字符。那么可以用log100个bit来表示。对于压缩文件中只使用了某些字符，那么可以通过更少的Bit来表示。例如图中向左分支是0，向右分支是1，那么a为000，c为001,以此类推。&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/rICzsH&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/27/rICzsH.png&quot; alt=&quot;rICzsH.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/rIPlF0&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/27/rIPlF0.png&quot; alt=&quot;rIPlF0.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于newline没有右兄弟，因此上移，将树变成满树&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/rIPdT1&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/27/rIPdT1.png&quot; alt=&quot;rIPdT1.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;满树：所有的节点，要么是树叶，要么有两个儿子。一种最优的编码将总具有这个性质，否则就像上面，具有一个儿子的节点可以向上移动一层。如果字符都只放在&lt;mark&gt;树叶&lt;/mark&gt;上，那么任何比特序列总能够被毫无歧义的译码。并且，这些字符代码的长度是否不同并不要紧，只要没有字符代码是别的字符代码的前缀即可。这种编码叫做&lt;mark&gt;前缀码&lt;/mark&gt;。反之，如果一个字符放在非树叶节点上，那就不能够保证译码没有二义性。可以想见，如果想要以最小的空间表示最多的字符，那么就要将&lt;mark&gt;出现频率高的字符，放到尽可能浅的深度，而出现频率低的字符，可以放到深的深度&lt;/mark&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/rIijDH&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/27/rIijDH.png&quot; alt=&quot;rIijDH.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;哈夫曼算法&quot;&gt;哈夫曼算法&lt;/h4&gt;
&lt;p&gt;假设字符的个数为C，哈夫曼算法可以描述如下：算法对一个由树组成的森林进行。一棵树的权等于它的树叶的频率的和。任意选取最小权的两棵树T1和T2，并任意形成以T1和T2为子树的新树，将这样的过程进行C-1次。在算法的开始，存在C棵单节点数。每个字符一棵。在算法结束时得到一棵树，这棵树就是最优哈弗曼编码树。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/ro3tEt&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/28/ro3tEt.png&quot; alt=&quot;ro3tEt.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/ro3TbR&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/28/ro3TbR.png&quot; alt=&quot;ro3TbR.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始阶段，每个元素看成一棵单节点树。每个节点有自己的value和权重。&lt;/li&gt;
&lt;li&gt;将当前森林中，权值最低的两棵树进行合并，合并后新树的权值是老树权值的和&lt;/li&gt;
&lt;li&gt;继续进行第二步，不断将当前森林中权值最低的两棵树进行合并，合并时，左右分支任意，可以互换&lt;/li&gt;
&lt;li&gt;可以看出，权值（出现频率）越低，其深度越深；权值越高，其深度越浅。这样就能保证总开销最小。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;该算法是贪婪算法的原因在于，在每一阶段我们都进行一次合并而没有进行全局的考虑，我们只是选择两棵权值最小的树进行合并。我们可以依权排序将这些树保存在一个优先队列中。那么对于元素个数不超过C的优先队列将进行一次BuildHeap, 2C-2次DeleteMin和C-2次Insert，因此运行时间伟O(ClogC)。如果不使用优先队列，而是链表的话，将给出一个O(C^2)的算法。优先队列实现方法的选择取决于C有多大。&lt;/p&gt;
&lt;h3 id=&quot;1013-近似装箱问题&quot;&gt;10.1.3 近似装箱问题&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;联机：必须解决当前问题，流程才能继续&lt;/li&gt;
&lt;li&gt;脱机：必须了解完所有的问题，流程才能开始&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;10131-联机算法&quot;&gt;10.1.3.1 联机算法&lt;/h4&gt;
&lt;p&gt;对于联机装箱问题不存在&lt;mark&gt;最优算法&lt;/mark&gt;。联机算法从不知道&lt;mark&gt;输入何时会结束&lt;/mark&gt;，因此它提供的性能保证必须在整个算法的每一时刻成立。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定理：存在使得任意联机装箱算法至少使用4/3最优箱子数的输入&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;1-下项适合算法&quot;&gt;1. 下项适合算法&lt;/h5&gt;
&lt;p&gt;当处理任何一项物品时，我们检查看它是否能装进刚刚装进物品的同一个箱子中去。如果能够装进去，那么就把它放入该箱中。否则就开辟一个新箱子。该算法能够以线性时间运行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;令M是将一列物品I装箱所需的最优装箱数，则下项适合算法所用箱数绝不超过2M个箱子。存在一些顺序使得下项适合算法用箱2M-2个&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/roab9I&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/28/roab9I.png&quot; alt=&quot;roab9I.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;2-首次适合算法&quot;&gt;2. 首次适合算法&lt;/h5&gt;
&lt;p&gt;虽然下项适合算法有一个合理的性能保证。但是它的实践效果却很差，因为在不需要开辟新箱子的时候，它却开辟了新的箱子。首次适合算法的策略是&lt;mark&gt;依序扫描这些箱子&lt;/mark&gt;，但把&lt;mark&gt;新的一项物品&lt;/mark&gt;放入足够盛下它的&lt;mark&gt;第一个箱子中&lt;/mark&gt;。因此，只有当先前放置物品的结果已经没有再容下当前物品余地的时候，我们才开辟一个新的箱子。首次适合算法保证其解最多包含最优装箱数的二倍。当首次适合算法对大量其大小均匀分布在0和1之间的物品进行运算时，经验结果指出，首次适合算法用到大约比最优装箱方法多2%的箱子，这是完全可以接受的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/roBU54&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/28/roBU54.png&quot; alt=&quot;roBU54.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;3-最佳适合算法&quot;&gt;3. 最佳适合算法&lt;/h5&gt;
&lt;p&gt;该法不是把一项新物品放入所发现的第一个能容纳它的箱子，而是放到所有箱子中能容纳它的&lt;mark&gt;最满&lt;/mark&gt;的箱子中。最佳适合算法比起最优算法，绝不会坏过1.7倍左右&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/ror64e&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/28/ror64e.png&quot; alt=&quot;ror64e.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;10132-脱机算法&quot;&gt;10.1.3.2 脱机算法&lt;/h4&gt;
&lt;p&gt;如果能够观察全部物品之后再算出答案，那么应该会做的更好。所有联机算法的主要问题在于将大项物品装箱困难，特别是当他们在输入的晚期出现的时候。因此解决该问题的方法时将&lt;mark&gt;各项物品排序&lt;/mark&gt;，将&lt;mark&gt;最大的物品放在最先&lt;/mark&gt;。此时可以应用首次适合算法或最佳适合算法，分别得到首次适合递减算法和最佳适合递减算法。最佳适合递减算法和首次适合递减算法的效果差不多。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;令N项物品的输入大小（以递减顺序排序）分别为s1, s2, ... , sN。并设最优装箱方法使用M个箱子。那么，首次适合递减算法放到外加的箱子中的所有物品的大小最多为1/3&lt;/li&gt;
&lt;li&gt;放入外加的箱子中的物品的个数最多是M-1&lt;/li&gt;
&lt;li&gt;令M时物品集I装箱所需的最优箱子数，则首次适合递减算法所用箱子数绝不超过(4M+1)/3&lt;/li&gt;
&lt;li&gt;令M是将物品集I装箱所需要的最优箱子数，则首次适合递减算法所用箱子数绝不超过11/9 * M + 4。存在使得首次适合递减算法用到11/9 * M个箱子的序列&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;102-分治算法&quot;&gt;10.2 分治算法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;分：递归解决较小的问题（基本情况除外）&lt;/li&gt;
&lt;li&gt;治：从子问题的解，构建原问题的解&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;1021-分治算法的运行时间&quot;&gt;10.2.1 分治算法的运行时间&lt;/h3&gt;
&lt;p&gt;所有有效的分治算法都是把问题分成一些子问题，每个子问题都是原问题的一部分。然后进行某些附加的工作以算出最后的答案。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;方程T(N)=aT(N/b)+Θ(N^k)的解为
T(N)=
O(N^(log(b)a)), 若a&amp;gt;b^k
O(N^k * logN), 若a=b^k
O(N^k), 若a&amp;lt;b^k
其中a&amp;gt;=1, b&amp;gt;1

方程T(N)=aT(N/b)+Θ(N^k * (logN)^p)的解为
T(N)=
O(N^(log(b)a)), 若a&amp;gt;b^k
O(N^k * (logN)^(p+1)), 若a=b^k
O(N^k * (logN)^p), 若a&amp;lt;b^k
a &amp;gt;=1, b&amp;gt; 1 且p &amp;gt;=0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/rH3mJx&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/29/rH3mJx.png&quot; alt=&quot;rH3mJx.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1022-最近点问题&quot;&gt;10.2.2 最近点问题&lt;/h3&gt;
&lt;p&gt;平面上有点列P，如果p1=(x1,y1), p2=(x2,y2)，那么p1和p2间欧几里得距离为[(x1-x2)^2 + (y1-y2)&lt;sup&gt;2]&lt;/sup&gt;(1/2)。我们需要找出一对距离最近的点。将这些点按照x的坐标排序，画一条垂线，将点集分为两半：PL和PR，最近的一对点或者都在PL中，或者都在PR中，或者一个在PL而另一个在PR中。这三个距离分别叫做dL、dR和dC&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/rHSEan&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/29/rHSEan.png&quot; alt=&quot;rHSEan.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;蛮力计算&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;for(i = 0; i&amp;lt;NumPointsInStrip; i++)
    for(j=i+1; j&amp;lt;NumPointsInStrip; j++)
        if(Distance(Pi, Pj) &amp;lt; x)
            x = Distance(Pi,Pj);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;精炼计算&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;for(i = 0; i&amp;lt;NumPointsInStrip; i++)
    for(j=i+1; j&amp;lt;NumPointsInStrip; j++)
        if (Pi和Pj的y坐标相差大于x)
            break;
        else
            if(Distance(Pi, Pj) &amp;lt; x)
                x = Distance(Pi,Pj);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;1023-选择问题&quot;&gt;10.2.3 选择问题&lt;/h3&gt;
&lt;p&gt;要求找出含N个元素的表S中的第k个小的元素。基本的算法是简单递归策略。设N大于截止点，在截止点后元素将进行简单的排序。v是选出的一个元素，叫做枢纽元。其余的元素被放在两个集合S1和S2中。S1含有那些不大于v的元素，而S2则包含那些不小于v的元素。如果k &amp;lt;= |S1|，那么S中的第k个最小的元素，可以通过递归的计算S1中第k个最小的元素而找到。如果k=|S1|+1，则枢纽元就是第k个最小的元素。否则，在S中第k个最小的元素是S2中的第（k-|S1|-1）个最小元素。这个算法和快速排序之间的主要区别在于，这里要求解的只有一个子问题而不是两个子问题。为了保证快速的选择出好枢纽元，关键想法是再用一个间接层。我们不是从随即元素的样本中找出中项，而是从中项的样本中找出中项。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把N个元素分成[N/5]组，5个元素一组，忽略（最多4个）剩余的元素&lt;/li&gt;
&lt;li&gt;找出每组的中项，得到[N/5]个中项的表M&lt;/li&gt;
&lt;li&gt;求出M的中项，将其作为枢纽元V返回&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用五分化中项的中项的快速选择算法的运行时间为O(N)。分治算法还可以用来降低选择算法预计所需要的比较次数&lt;/p&gt;
&lt;h3 id=&quot;1024-一些运算问题的理论改进&quot;&gt;10.2.4 一些运算问题的理论改进&lt;/h3&gt;
&lt;h4 id=&quot;10241-整数相乘&quot;&gt;10.2.4.1 整数相乘&lt;/h4&gt;
&lt;p&gt;假设想要将两个N位数X和Y相乘。如果X和Y恰好有一个是负的，那么结果就是负的，否则结果为正数。因此可以进行这种检查然后假设X, Y &amp;gt;= 0。设X=61438521，Y=94736407。我们将X和Y拆成两半。分别由最高几位和最低几位数字组成。XL=6143，XR=8521，YL=9473，YR=6407.我们还有X=XL10&lt;sup&gt;4+XR和Y=YL10&lt;/sup&gt;4+YR。由此得到：XY=XLYL10&lt;sup&gt;8+（XLYR+XRYL）10&lt;/sup&gt;4+XRYR。该方程由四次乘法组成。即XLYL、XLYR、XRYL、XRYR。它们每一个都是原问题大小的一般（N/2数字）。用10&lt;sup&gt;8和10&lt;/sup&gt;4做乘法实际就是添加一些0，这及其后的几次加法只是添加了O(N)附加的工作。如果我们递归地使用该算法进行这四项乘法，在一个适当的基本情形下停止，我们得到递归：T(N)=4T(N/2)+O(N)。根据定理，可以看到T(N)=O(N^2)。为了得到一个亚二次的算法，我们必须使用少于四次的递归调用.关键在于XLYR+XRYL=(XL-XR)(YR-YL)+XLYL+XRYR。这样通过三次递归调用即可得出结果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/rH3z0H&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/29/rH3z0H.png&quot; alt=&quot;rH3z0H.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在的递归方程满足：T(N)=3T(N/2)+O(N)，根据定理，得到T(N)=O(N^(log(2)3)) = O(N^1.59)。未完成这个算法，我们必须要有一个基准情况，该情况可以无需递归而解决。当两个数都是一位数字时，可以通过&lt;mark&gt;查表进行乘法&lt;/mark&gt;，若有一个乘数为0，则我们返回0.假如我们在实践中要用这种算法，我们将选择对机器最方便的情况作为基本情况。&lt;/p&gt;
&lt;h4 id=&quot;10242-矩阵乘法&quot;&gt;10.2.4.2 矩阵乘法&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/rOshHH&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/12/30/rOshHH.png&quot; alt=&quot;rOshHH.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当矩阵A的列数（column）等于矩阵B的行数（row）时，A与B可以相乘。&lt;/li&gt;
&lt;li&gt;矩阵C的行数等于矩阵A的行数，C的列数等于B的列数。&lt;/li&gt;
&lt;li&gt;乘积C的第m行第n列的元素等于矩阵A的第m行的元素与矩阵B的第n列对应元素乘积之和。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;简单的O(N^3)矩阵乘法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void
MatrixMultiply(Matrix A, Matrix B, Matrix C, int N)
{
    int i, j, k;
    
    for (i = 0; i &amp;lt; N; i++)
        for (j = 0; j &amp;lt; N; j++)
            C[i][j] = 0;
    
    for (i = 0; i &amp;lt; N; i++)
        for (j = 0; j &amp;lt; N; j++)
            for (k = 0; k &amp;lt; N; k++)
                C[i][j] += A[i][k] * B[k][j];
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;103-动态规划&quot;&gt;10.3 动态规划&lt;/h2&gt;
&lt;p&gt;一个可以被数学上递归表示的问题也可以表示成一个递归算法，在许多情形下对朴素的穷举搜索得到显著的性能改进。任何数学递归公式都可以直接翻译成递归算法，但是基本现实是编译器常常&lt;mark&gt;不能正确对待&lt;/mark&gt;递归算法，结果导致低效的算法。当我们&lt;mark&gt;怀疑很可能是这种情况&lt;/mark&gt;时，必须再给编译器提供一些帮助，&lt;mark&gt;将递归算法重新写成非递归算法&lt;/mark&gt;，让编译器把那些子问题的答案&lt;mark&gt;系统的记录在一个表内&lt;/mark&gt;，利用这种方法的一种技巧叫做动态规划。&lt;/p&gt;
&lt;h3 id=&quot;1031-用一个表代替递归&quot;&gt;10.3.1 用一个表代替递归&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;斐波那契数的低效算法&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;int
Fib(int N)
{
    if (N &amp;lt;= 1)
        return 1;
    else
        return Fib(N - 1) + Fib(N - 2);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该算法慢的原因在于&lt;mark&gt;冗余计算&lt;/mark&gt;，且荣誉计算的增长是&lt;mark&gt;爆炸性&lt;/mark&gt;的，如果编译器的递归模拟算法要是能够保留一个预先算出的值的表而对&lt;mark&gt;已经解过的子问题不再进行递归调用&lt;/mark&gt;。那么这种指数式的爆炸增长就可以避免。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;斐波那契数的线性算法&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;int
Fibonacci(int N)
{
    int i, Last, NextToLast, Answer;
    
    if (N &amp;lt;= 1)
        return 1;
    
    Last = NextToLast = 1;
    for (i = 2; i &amp;lt;= N; i++)
    {
        Answer = Last + NextToLast;
        NextToLast = Last;
        Last = Answer;
    }
    
    return Answer;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;1032-矩阵乘法的顺序安排&quot;&gt;10.3.2 矩阵乘法的顺序安排&lt;/h3&gt;
&lt;p&gt;设有四个矩阵ABC和D。不同的相乘顺序导致计算次数完全不同，导致效率完全不同。最好的排列顺序方法大约只用了最坏的排列顺序方法的九分之一的惩罚次数。我们定义T(N)是顺序的个数，此时T(1)=T(2)=1, T(3)=2,而T(4)=5.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/spHHxI&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/03/spHHxI.png&quot; alt=&quot;spHHxI.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/spHqMt&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/03/spHqMt.jpg&quot; alt=&quot;spHqMt.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设mLeft, Right是进行矩阵乘法ALeftALeft+1 ... ARight-1ARight所需要的乘法次数，为方便起见，mLeft,Left=0.设最后的乘法是(ALeft...Ai)(Ai+1...ARight)，其中Left&amp;lt;=i&amp;lt;Right。此时所用的乘法次数为mLeft,i+mi+1,Right+cLeft-1cicRight。这三项分别代表计算（Aleft...Ai）、(Ai+1...ARight)以及它们的乘积所需要的乘法。如果我们定义MLeft,Right为在最优排列顺序下所需要的乘法次数，那么，若Left&amp;lt;Right，则：&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/s9FUfI&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/03/s9FUfI.png&quot; alt=&quot;s9FUfI.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个方程意味着，如果我们有乘法ALeft...ARight的最优的乘法排列顺序，那么子问题ALeft...Ai和Ai+1...ARight就不能次最优的执行。否则我们可以通过用最优的计算代替次最优计算而改进整个结果。&lt;br/&gt;这个公式可以直接翻译成递归程序，这样的程序将是明显低效的，由于大约只有MLeft,Right的N^2/2个值需要计算，因此显然可以用一个表来存放这些值。进一步的考察表明，如果Right-Left=k，那么只有在MLeft,Right的计算中所需要的那些值Mx,y满足y-x&amp;lt;k。这告诉我们计算这个表所需要使用的顺序。如果除最后答案M1,N外我们还想要显示实际的乘法顺序，那么我们可以使用第九章中的最短路径算法的思路，无论何时改变MLeft,Right，我们都要记录i的值，这个值是重要的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;找出矩阵乘法最优顺序的程序
void
OptMatrix(const long C[], int N, TwoDimArray M, TwoDimArray LastChange)
{
    int i, k, Left, Right;
    long ThisM;
    
    for (Left = 1; Left &amp;lt;=N; Left++)
        M[Left][Left] = 0;
    for (k = 1; k &amp;lt; N; k++)
        for (Left = 1; Left &amp;lt;= N-k; Left++)
        {
            /* for each position */
            Right = Left + k;
            M[Left][Right] = Infinity;
            for (i = Left; i &amp;lt; Right; i++)
            {
                ThisM = M[Left][i] + M[i+1][Right] + C[Left - 1]*C[i]*C[Right];
                if (ThisM &amp;lt; M[Left][Right])
                {
                    M[Left][Right] = ThisM;
                    LastChange[Left][Right] = i;
                }
            }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;1033-最优二叉查找树&quot;&gt;10.3.3 最优二叉查找树&lt;/h3&gt;
&lt;p&gt;给定一列单词w1, w2, ... wN和他们出现的固定的概率p1, p2, ... pN。问题是要以一种方法在一棵二叉查找树中安放这些单词使得总的期望存取时间最小。在一棵二叉查找树中，访问深度d处的一个元素所需要的比较次数是d+1，因此如果wi被放在深度di上，那么我们就要将&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/s9mBPe&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/03/s9mBPe.png&quot; alt=&quot;s9mBPe.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设样本输入如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/s9KzRg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/03/s9KzRg.png&quot; alt=&quot;s9KzRg.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第一棵树是是用贪婪方法形成的，存取概率最高的单词被放在根节点处。然后左右子树递归形成。第二棵树是理想平衡查找树。这两棵树都不是最优的，由第三棵树的存在可以证实。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/s9MSzQ&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/03/s9MSzQ.png&quot; alt=&quot;s9MSzQ.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最优二叉树的构造：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/s9MUQH&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/03/s9MUQH.png&quot; alt=&quot;s9MUQH.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果Left &amp;gt; Right，那么树的开销是0，这就是NULL情形，对于二叉查找树我们总有这种情形，否则，根花费pi，左子树的代价相对于它的根为Cleft,i-1，右子树相对于它的根的代价为Ci+1,Right,这两棵树的每个节点从wi开始都比从它们对应的根开始深一层。因此我们必须加&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/s9MWOs&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/03/s9MWOs.png&quot; alt=&quot;s9MWOs.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由此得到公式：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/s9M4wq&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s3.ax1x.com/2021/01/03/s9M4wq.png&quot; alt=&quot;s9M4wq.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1034-所有点对最短路径&quot;&gt;10.3.4 所有点对最短路径&lt;/h3&gt;
&lt;p&gt;计算有向图G=(V,E)中每一点时间赋权最短路径的一个算法。在第九章我们看到单发点最短路径问题的一个算法，该算法找出从任意一点s到所有其他顶点的最短路径。该算法（Dijkstra）对稠密的图以O(|V|&lt;sup&gt;2)时间运行，实际上对稀疏的图更快。这里将给出一个较小的算法解决对稠密图的所有点对的问题，该算法的运行时间为O(|V|&lt;/sup&gt;3),他不是对Dijkstra算法|V|次迭代的一种渐进改进，但对非常稠密的图可能更快，原因是它的循环更紧凑。如果存在一些负的边值但没有负值圈，那么这个算法也能正确运行，而Dijkstra算法此时是失败的。Dijkstra算法在顶点s开始并分阶段工作。图中的&lt;mark&gt;每个顶点最终都要被选作中间结点&lt;/mark&gt;。如果当前所选的顶点是v，那么对于每个w属于V，置dw=min(dw, dv+cv,w)，这个公式是说，从s到w的最佳举例或者是从前面知道的从s到w的举例，或者是从s（最优的）到v然后在直接从v到w的结果。Dijkstra算法提供了动态规划算法的想法。我们依序选择这些顶点。我们将Dk,i,j定义为从vi到vj只使用v1,v2,...vk作为中间顶点的最短路径的权。根据这个定义，D0,i,j=ci,j。其中若（vi, vj）不是该图的边则ci,j是无穷。再有，根据定义，D|V|,i,j是图中从vi到vj的最短路径。当k&amp;gt;0时，我们可以给Dk,i,j写出一个简单公式。从vi到vj只使用v1,v2,...vk作为中间顶点的最短路径或者根本不使用vk作为中间顶点的最短路径，或者是由两条路景vi-&amp;gt;vk和vk-&amp;gt;vj合并而成的最短路径。其中每条路径只使用前k-1个顶点作为中间顶点。得出公式：Dk,i,j=min{Dk-1,i,j, Dk-1,i,k+Dk-1,k,j}。实践需求还是O(|V|^3),跟前面的两个动态规划例子不同，这个时间界实际上尚未用另外的方法降低。因为第k阶段只依赖于第k-1阶段，所以看来只有两个|V|*|V|矩阵需要保存，然而，在用k开始或结束的路径上以k作为中间顶点对结果没有改进，除非存在一个负的圈。因此只有一个矩阵是必须的，因为Dk-1,i,k=Dk,i,k和Dk-1,k,j=Dk,k,j。这意味着右边的项都不改变值且都不需要存储。这个观察结果导致图中的简单程序。在一个完全图中，每一对顶点（两个方向上）都是联通的，该算法几乎肯定要比Dijkstra算法的|V|次迭代快，因为这里的循环非常紧凑并适合并行计算。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void
AllPairs(TwoDimArray A, TwoDimArrayD, TwoDimArray Path, int N)
{
    int i, j, k;
    
    /* Initialize D and Path */
    for (i = 0; i &amp;lt; N; i++)
        for (j = 0; j &amp;lt; N; j++)
        {
            D[i][j] = A[i][j];
            Path[i][j] = NotAVertex;
        }
    
    for (k = 0; k &amp;lt; N; k++)
        /* Consider each vertex as an intermediate */
        for (i = 0; i &amp;lt; N; i++)
            for (j = 0; j &amp;lt; N; j++)
                if (D[i][k] + D[k][j] &amp;lt; D[i][j])
                {
                    /* Update shortest path */
                    D[i][j] = D[i][k] + D[k][j];
                    Path[i][k] = k;
                }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态规划是强大的算法设计技巧，它给解提供一个起点，它基本上是首先求解一些更简单问题的分治算法的范例，&lt;mark&gt;重要的区别在于这些更简单的问题不是原问题的明确的分割&lt;/mark&gt;。因为&lt;mark&gt;子问题反复被求解，所以重要的是将它们的解记录在一个表中&lt;/mark&gt;而不是重新计算它们。在某些情况下，解可以被改进（这确实不总是明显鹅，而且常常是困难的）。在另一些情况下，动态规划方法则是所知道的最好的处理方法。在某种意义上，&lt;mark&gt;如果你看出一个动态规划问题，那么你就看出所有的问题&lt;/mark&gt;。&lt;/p&gt;
&lt;h2 id=&quot;104-随机化算法&quot;&gt;10.4 随机化算法&lt;/h2&gt;
&lt;p&gt;在算法期间，随机数至少有一次用于&lt;mark&gt;决策&lt;/mark&gt;。该算法的运行时间不只依赖于特定的输入，而且依赖于所&lt;mark&gt;发生的随机数&lt;/mark&gt;。一个&lt;mark&gt;随机化算法的最坏运行时间&lt;/mark&gt;几乎总是和&lt;mark&gt;非随机化算法的最坏情形运行时间&lt;/mark&gt;相同，区别在于，好的随机化算法没有不好的输入，而只有坏的随机数（相对于特定的输入）。例如快速排序中枢纽元的选择，方法A选第一个元素，方法B随机选出一个元素。两种最坏情形之间的区别在于，存在特定的输入总能够出现在A中并产生不好的运行时间。当每一次给定已排序数据时，方法A总是会以最坏运行时间运行（O(N^2)）。如果方法B以相同的输入运行两次，它将有两个不同的运行时间。在运行时间的计算中，我们假设所有的输入都是等可能的，实际上这并不成立。例如排序的输入常常要比统计上期望的出现的多得多。这会产生一些问题，特别是对于快速排序和二叉查找树。通过使用&lt;mark&gt;随机化算法&lt;/mark&gt;，&lt;mark&gt;特定的输入不再是重要的&lt;/mark&gt;。&lt;mark&gt;重要的是随机数&lt;/mark&gt;，我们可以得到一个期望的运行时间，此时我们是对&lt;mark&gt;所有可能的随机数取平均而不是对所有可能的输入取平均&lt;/mark&gt;。使用随机枢纽元的快速排序算法是一个O(NlogN)期望时间算法，这就是说，对任意的输入，包括已经排序的输入，运行时间的期望值为O(NlogN)。期望运行时间界要多少&lt;mark&gt;强于&lt;/mark&gt;平均时间界，比对应的最坏情形界弱。得到最坏情形时间界的那些解决方案&lt;mark&gt;常常不如他们的平均情形那样在实际中常见、但是随机化算法却通常是一致的。&lt;/mark&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Mark Allen Weiss.数据结构与算法分析[M].America, 2007&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;本文作者:&lt;/strong&gt; CrazyCatJack&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文链接:&lt;/strong&gt; &lt;a href=&quot;https://www.cnblogs.com/CrazyCatJack/p/14408191.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CrazyCatJack/p/14408191.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权声明:&lt;/strong&gt;本博客所有文章除特别声明外，均采用 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot;&gt;BY-NC-SA&lt;/a&gt; 许可协议。转载请注明出处！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注博主:&lt;/strong&gt;如果您觉得该文章对您有帮助，可以点击文章右下角&lt;strong&gt;推荐&lt;/strong&gt;一下，您的支持将成为我最大的动力！&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Sat, 20 Feb 2021 15:29:00 +0000</pubDate>
<dc:creator>CrazyCatJack</dc:creator>
<og:description>10.1 贪婪算法 贪婪算法分阶段的工作，在每个阶段，可以认为所做决定是最好的，而不考虑将来的后果。一般来说，这意味着选择的是某个局部的最优。当算法终止时，我们希望局部最优就是全局最优。如果是这样的话</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CrazyCatJack/p/14408191.html</dc:identifier>
</item>
<item>
<title>亿级流量架构之服务限流思路与方法 - 等不到的口琴</title>
<link>http://www.cnblogs.com/Courage129/p/14423707.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Courage129/p/14423707.html</guid>
<description>&lt;h2 id=&quot;为什么要限流&quot;&gt;为什么要限流&lt;/h2&gt;
&lt;p&gt;日常生活中,有哪些需要限流的地方?&lt;/p&gt;
&lt;p&gt;像我旁边有一个国家AAAA景区,平时可能根本没什么人前往,但是一到五一或者春节就人满为患,这时候景区管理人员就会实行一系列的政策来限制进入人流量,&lt;br/&gt;为什么要限流呢?假如景区能容纳一万人,现在进去了三万人,势必摩肩接踵,整不好还会有事故发生,这样的结果就是所有人的体验都不好,如果发生了事故景区可能还要关闭,导致对外不可用,这样的后果就是所有人都觉得体验糟糕透了。&lt;/p&gt;
&lt;p&gt;限流的思想就是,在保证可用的情况下尽可能多增加进入的人数,其余的人在外面排队等待,保证里面的一万人可以正常游玩。&lt;/p&gt;
&lt;p&gt;回到网络上,同样也是这个道理,例如某某明星公布了恋情,访问从平时的50万增加到了500万,系统最多可以支撑200万访问,那么就要执行限流规则,保证是一个可用的状态,不至于服务器崩溃导致所有请求不可用。&lt;/p&gt;
&lt;h2 id=&quot;限流思路&quot;&gt;限流思路&lt;/h2&gt;
&lt;p&gt;对系统服务进行限流，一般有如下几个模式：&lt;/p&gt;
&lt;h3 id=&quot;熔断&quot;&gt;熔断&lt;/h3&gt;
&lt;p&gt;系统在设计之初就把熔断措施考虑进去。当系统出现问题时，如果短时间内无法修复，系统要自动做出判断，开启熔断开关，拒绝流量访问，避免大流量对后端的过载请求。&lt;/p&gt;
&lt;p&gt;系统也应该能够动态监测后端程序的修复情况，当程序已恢复稳定时，可以关闭熔断开关，恢复正常服务。常见的熔断组件有Hystrix以及阿里的Sentinel，两种互有优缺点，可以根据业务的实际情况进行选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210220223818478-1442921157.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;服务降级&quot;&gt;服务降级&lt;/h3&gt;
&lt;p&gt;将系统的所有功能服务进行一个分级，当系统出现问题需要紧急限流时，可将不是那么重要的功能进行降级处理，停止服务，这样可以释放出更多的资源供给核心功能的去用。&lt;/p&gt;
&lt;p&gt;例如在电商平台中，如果突发流量激增，可临时将商品评论、积分等非核心功能进行降级，停止这些服务，释放出机器和CPU等资源来保障用户正常下单，而这些降级的功能服务可以等整个系统恢复正常后，再来启动，进行补单/补偿处理。除了功能降级以外，还可以采用不直接操作数据库，而全部读缓存、写缓存的方式作为临时降级方案。&lt;/p&gt;
&lt;h3 id=&quot;延迟处理&quot;&gt;延迟处理&lt;/h3&gt;
&lt;p&gt;这个模式需要在系统的前端设置一个流量缓冲池，将所有的请求全部缓冲进这个池子，不立即处理。然后后端真正的业务处理程序从这个池子中取出请求依次处理，常见的可以用队列模式来实现。这就相当于用异步的方式去减少了后端的处理压力，但是当流量较大时，后端的处理能力有限，缓冲池里的请求可能处理不及时，会有一定程度延迟。后面具体的漏桶算法以及令牌桶算法就是这个思路。&lt;/p&gt;
&lt;h3 id=&quot;特权处理&quot;&gt;特权处理&lt;/h3&gt;
&lt;p&gt;这个模式需要将用户进行分类，通过预设的分类，让系统优先处理需要高保障的用户群体，其它用户群的请求就会延迟处理或者直接不处理。&lt;/p&gt;
&lt;h3 id=&quot;缓存、降级、限流区别&quot;&gt;缓存、降级、限流区别&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;，是用来增加系统吞吐量，提升访问速度提供高并发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;降级&lt;/strong&gt;，是在系统某些服务组件不可用的时候、流量暴增、资源耗尽等情况下，暂时屏蔽掉出问题的服务，继续提供降级服务，给用户尽可能的友好提示，返回兜底数据，不会影响整体业务流程，待问题解决再重新上线服务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;限流&lt;/strong&gt;，是指在使用缓存和降级无效的场景。比如当达到阈值后限制接口调用频率，访问次数，库存个数等，在出现服务不可用之前，提前把服务降级。只服务好一部分用户。&lt;/p&gt;
&lt;h2 id=&quot;限流的算法&quot;&gt;限流的算法&lt;/h2&gt;
&lt;p&gt;限流算法很多,常见的有三类,分别是计数器算法、漏桶算法、令牌桶算法,下面逐一讲解。&lt;/p&gt;
&lt;h3 id=&quot;计数器算法&quot;&gt;计数器算法&lt;/h3&gt;
&lt;p&gt;简单粗暴,比如指定线程池大小，指定数据库连接池大小、nginx连接数等,这都属于计数器算法。&lt;/p&gt;
&lt;p&gt;计数器算法是限流算法里最简单也是最容易实现的一种算法。举个例子,比如我们规定对于A接口，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开 始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个请求的间隔时间还在1分钟之内，那么说明请求数过多,拒绝访问；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置 counter,就是这么简单粗暴。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210220223830090-1203904838.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;漏桶算法&quot;&gt;漏桶算法&lt;/h3&gt;
&lt;p&gt;漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会超过桶可接纳的容量时直接溢出，可以看出漏桶算法能强行限制数据的传输速率。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210220223842536-838208163.png&quot; alt=&quot;2002319-20210220223842536-838208163&quot;/&gt;&lt;p&gt;这样做的好处是:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;削峰&lt;/strong&gt;:有大量流量进入时,会发生溢出,从而限流保护服务可用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓冲&lt;/strong&gt;:不至于直接请求到服务器,缓冲压力&lt;br/&gt;消费速度固定 因为计算性能固定&lt;/p&gt;
&lt;h3 id=&quot;令牌桶算法&quot;&gt;令牌桶算法&lt;/h3&gt;
&lt;p&gt;令牌桶与漏桶相似,不同的是令牌桶桶中放了一些令牌,服务请求到达后,要获取令牌之后才会得到服务,举个例子,我们平时去食堂吃饭,都是在食堂内窗口前排队的,这就好比是漏桶算法,大量的人员聚集在食堂内窗口外,以一定的速度享受服务,如果涌进来的人太多,食堂装不下了,可能就有一部分人站到食堂外了,这就没有享受到食堂的服务,称之为溢出,溢出可以继续请求,也就是继续排队,那么这样有什么问题呢?&lt;/p&gt;
&lt;p&gt;如果这时候有特殊情况,比如有些赶时间的志愿者啦、或者高三要高考啦,这种情况就是突发情况,如果也用漏桶算法那也得慢慢排队,这也就没有解决我们的需求,对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。如图所示，令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210220223928172-1995912492.png&quot; alt=&quot;2002319-20210220223928172-1995912492&quot;/&gt;&lt;p&gt;令牌桶好处就是,如果某一瞬间访问量剧增或者有突发情况,可以通过改变桶中令牌数量来改变连接数,就好比那个食堂排队吃饭的问题,如果现在不是直接去窗口排队,而是先来楼外拿饭票然后再去排队,那么有高三的学生时可以将增加饭票数量或者优先将令牌给高三的学生,这样比漏桶算法更加灵活。&lt;/p&gt;
&lt;h2 id=&quot;并发限流&quot;&gt;并发限流&lt;/h2&gt;
&lt;p&gt;简单来说就是设置系统阈值总的QPS个数,这些也挺常见的,就拿Tomcat来说,很多参数就是出于这个考虑,例如&lt;/p&gt;
&lt;p&gt;配置的&lt;code&gt;acceptCount&lt;/code&gt; 设置响应连接数, &lt;code&gt;maxConnections&lt;/code&gt;设置瞬时最大连接数, &lt;code&gt;maxThreads&lt;/code&gt; 设置最大线程数,在各个框架或者组件中,并发限流体现在下面几个方面:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;限制总并发数（如数据库连接池、线程池）&lt;/li&gt;
&lt;li&gt;限制瞬时并发数（nginx的limit_conn模块，用来限制瞬时并发连接数）&lt;/li&gt;
&lt;li&gt;限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）&lt;/li&gt;
&lt;li&gt;其他的还有限制远程接口调用速率、限制MQ的消费速率。&lt;/li&gt;
&lt;li&gt;另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有了并发限流，就意味着在处理高并发的时候多了一种保护机制，不用担心瞬间流量导致系统挂掉或雪崩，最终做到有损服务而不是不服务；但是限流需要评估好，不能乱用，否则一些正常流量出现一些奇怪的问题而导致用户体验很差造成用户流失。&lt;/p&gt;
&lt;h2 id=&quot;接口限流&quot;&gt;接口限流&lt;/h2&gt;
&lt;p&gt;接口限流分为两个部分,一是限制一段时间内接口调用次数,参照前面限流算法的计数器算法, 二是设置滑动时间窗口算法。&lt;/p&gt;
&lt;h3 id=&quot;接口总数&quot;&gt;接口总数&lt;/h3&gt;
&lt;p&gt;控制一段时间内接口被调用的总数量,可以参考前面的计数器算法,不再赘述。&lt;/p&gt;
&lt;h3 id=&quot;接口时间窗口&quot;&gt;接口时间窗口&lt;/h3&gt;
&lt;p&gt;固定时间窗口算法(也就是前面提到的计数器算法)的问题是统计区间太大，限流不够精确，而且在第二个统计区间 时没有考虑与前一个统计区间的关系与影响（第一个区间后半段 + 第二个区间前半段也是一分钟）。为了解决上面我们提到的临界问题，我们试图把每个统计区间分为更小的统计区间，更精确的统计计数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210220224002117-1776104138.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的例子中,假设QPS可以接受100次查询/秒, 前一分钟前40秒访问很低,后20秒突增,并且这个持续了一段时间,直到第二分钟的第40秒才开始降下来,根据前面的计数方法,前一秒的QPS为94,后一秒的QPS为92,那么没有超过设定参数,但是!但是在中间区域,QPS达到了142,这明显超过了我们的允许的服务请求数目,所以固定窗口计数器不太可靠,需要滑动窗口计数器。&lt;/p&gt;
&lt;p&gt;计数器算法其实就是固定窗口算法, 只是它没有对时间窗口做进一步地划分，所以只有1格；由此可见，当滑动窗口的格子划分的越多，也就是将秒精确到毫秒或者纳秒, 那么滑动窗口的滚动就越平滑，限流的统计就会越精确。&lt;/p&gt;
&lt;p&gt;需要注意的是,消耗的空间就越多。&lt;/p&gt;
&lt;h2 id=&quot;限流实现&quot;&gt;限流实现&lt;/h2&gt;
&lt;p&gt;这一部分是限流的具体实现,简单说说,毕竟长篇代码没人愿意看。&lt;/p&gt;
&lt;h3 id=&quot;guava实现&quot;&gt;guava实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;引入包&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/com.google.guava/guava --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;28.1-jre&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;核心代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;               LoadingCache&amp;lt;Long, AtomicLong&amp;gt; counter = CacheBuilder.newBuilder().
                                expireAfterWrite(2, TimeUnit.SECONDS)
                                .build(new CacheLoader&amp;lt;Long, AtomicLong&amp;gt;() {

                                        @Override
                                        public AtomicLong load(Long secend) throws Exception {
                                                // TODO Auto-generated method stub
                                                return new AtomicLong(0);
                                        }
                                });
                counter.get(1l).incrementAndGet();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;&quot;/&gt;
&lt;h3 id=&quot;令牌桶实现&quot;&gt;令牌桶实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;稳定模式(SmoothBursty:令牌生成速度恒定)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public static void main(String[] args) {
                // RateLimiter.create(2)每秒产生的令牌数
                RateLimiter limiter = RateLimiter.create(2);
        // limiter.acquire() 阻塞的方式获取令牌
                System.out.println(limiter.acquire());;
                try {
                        Thread.sleep(2000);
                } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                System.out.println(limiter.acquire());;
                System.out.println(limiter.acquire());;
                System.out.println(limiter.acquire());;
                System.out.println(limiter.acquire());;
                
                System.out.println(limiter.acquire());;
                System.out.println(limiter.acquire());;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;```RateLimiter.create(2)`` 容量和突发量，令牌桶算法允许将一段时间内没有消费的令牌暂存到令牌桶中，用来突发消费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;渐进模式(SmoothWarmingUp:令牌生成速度缓慢提升直到维持在一个稳定值)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       // 平滑限流，从冷启动速率（满的）到平均消费速率的时间间隔
                RateLimiter limiter = RateLimiter.create(2,1000l,TimeUnit.MILLISECONDS);
                System.out.println(limiter.acquire());;
                try {
                        Thread.sleep(2000);
                } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }
                System.out.println(limiter.acquire());;
                System.out.println(limiter.acquire());;
                System.out.println(limiter.acquire());;
                System.out.println(limiter.acquire());;
                
                System.out.println(limiter.acquire());;
                System.out.println(limiter.acquire());;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;超时&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean tryAcquire = limiter.tryAcquire(Duration.ofMillis(11));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在timeout时间内是否能够获得令牌，异步执行&lt;/p&gt;
&lt;h3 id=&quot;分布式系统限流&quot;&gt;分布式系统限流&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Nginx + Lua实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用resty.lock保持原子特性，请求之间不会产生锁的重入&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/openresty/lua-resty-lock&quot; target=&quot;_blank&quot;&gt;https://github.com/openresty/lua-resty-lock&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用lua_shared_dict存储数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;local locks = require &quot;resty.lock&quot;

local function acquire()
    local lock =locks:new(&quot;locks&quot;)
    local elapsed, err =lock:lock(&quot;limit_key&quot;) --互斥锁 保证原子特性
    local limit_counter =ngx.shared.limit_counter --计数器

    local key = &quot;ip:&quot; ..os.time()
    local limit = 5 --限流大小
    local current =limit_counter:get(key)

    if current ~= nil and current + 1&amp;gt; limit then --如果超出限流大小
       lock:unlock()
       return 0
    end
    if current == nil then
       limit_counter:set(key, 1, 1) --第一次需要设置过期时间，设置key的值为1，
--过期时间为1秒
    else
        limit_counter:incr(key, 1) --第二次开始加1即可
    end
    lock:unlock()
    return 1
end
ngx.print(acquire())

&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 20 Feb 2021 14:43:00 +0000</pubDate>
<dc:creator>等不到的口琴</dc:creator>
<og:description>为什么要限流 日常生活中,有哪些需要限流的地方? 像我旁边有一个国家AAAA景区,平时可能根本没什么人前往,但是一到五一或者春节就人满为患,这时候景区管理人员就会实行一系列的政策来限制进入人流量, 为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Courage129/p/14423707.html</dc:identifier>
</item>
<item>
<title>Java中Singleton的三种实现方式解析 - pedro7</title>
<link>http://www.cnblogs.com/WangXianSCU/p/14423665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WangXianSCU/p/14423665.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;32&quot;&gt;&lt;img src=&quot;https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2603075043,127995163&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; class=&quot;desc_img&quot;/&gt;Java中Singleton的三种实现方式解析&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;110&quot;&gt;
&lt;h2 id=&quot;一、什么是singleton？&quot;&gt;一、什么是Singleton？&lt;/h2&gt;
&lt;p&gt;《设计模式》的作者、Eclipse和 Junit 的开发者 Erich Gamma 在它的理论体系中将 Singleton 定义为仅仅被实例化一次的类。在当今面向对象程序的实际开发中，Singleton 通常被用来代表&lt;strong&gt;一个无状态的对象&lt;/strong&gt;，例如函数和那些本质上唯一的系统组件。&lt;/p&gt;
&lt;p&gt;值得注意的是，使类成为 Singleton 会使得它的客户端测试变得非常困难，因为我们不可能给Singleton替换模拟实现，除非我们实现一个充当其类型的接口。&lt;/p&gt;
&lt;p&gt;实现 Singleton 有三种常见方法，他们或是保持构造器私有并导出公有的静态成员，或是声明一个包含单个元素的枚举类型。&lt;/p&gt;
&lt;h2 id=&quot;二、singleton实现--构造器私有&quot;&gt;二、Singleton实现 —— 构造器私有&lt;/h2&gt;
&lt;h4 id=&quot;1、公有静态成员为一个final域&quot;&gt;1、公有静态成员为一个final域&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;//Singleton with public final field 
public class Elvis { 
        public static final Elvis INSTANCE = new Elvis(); 
        pritvate Elvis() { ... } 
        public void leaveTheBuilding() { ... }
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个类中，我们仅仅拥有一个私有的构造器，它也只在初始化final域时被调用一次。由于缺少可以使用的构造器，后续的程序无法再创建 Elvis 对象。这保证了在该Java程序的整个生命周期中， Elvis 对象有且只有一个存在。&lt;/p&gt;
&lt;p&gt;但需要注意的是，一些高权限的客户端可以借助 AccessibleObject.setAccessible 方法通过反射机制调用私有的构造器。为了避免这样的可能的攻击，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。&lt;/p&gt;
&lt;p&gt;公有域方法的主要优势在于，API很清楚地表明了这个类是一个 Singleton ，毕竟这是一个公有的静态属性。另外，这个方法要更加简单。&lt;/p&gt;
&lt;h4 id=&quot;2、公有静态成员为一个静态工厂方法&quot;&gt;2、公有静态成员为一个静态工厂方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;//Singleton with static factory
public class Elvis { 
        private static final Elvis INSTANCE = new Elvis(); 
        pritvate Elvis() { ... } 
        public static Elvis getInstance(){ return INSTANCE; }
        public void leaveTheBuilding(){ ... }
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，无论怎样调用 getInstance 方法，返回的都是同一个对象的引用。注意上面提示的反射攻击问题依然存在。&lt;/p&gt;
&lt;p&gt;静态工厂方法有两大优势&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一，它提供了更多的灵活性，在不改变API的前提下，我们可以轻易地自由调整这个类是否是Singleton。工厂方法返回该类的唯一实例，但它很容易修改成别的样子，例如为每个调用该方法的线程提供唯一实例。&lt;/li&gt;
&lt;li&gt;第二，如果程序需要，我们可以编写一个泛型 Singleton 工厂。&lt;/li&gt;
&lt;li&gt;第三，我们可以通过方法引用作为提供者，比如 Elvis::instance 就是一个 Supplier&amp;lt; Elvis &amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;（注：方法引用是Java8的一个新特性）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除非我们需要上述的其中一种优势，我们还是应该选择更简单易懂的使用公有域的方法。&lt;/p&gt;
&lt;h4 id=&quot;3、将利用上述方法实现的singleton类变为可序列化的&quot;&gt;3、将利用上述方法实现的Singleton类变为可序列化的&lt;/h4&gt;
&lt;p&gt;使用上述两种方法实现的 Singleton ，要把他们变成可序列化的，不能仅仅在声明中加上 implements Serializable 。为了维护并保证 Singleton ，我们必须生命所有实例域都是瞬时的，并提供一个 readResolve 方法。否则在我们每次序列化时都会创建一个新的实例。为了防止这种情况，我们要在 Elvis 类中加入如下这样的 readResolve 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//readResolve method to preserve singleton property 
        private Object readResolve(){
                //Return the one true Elvis and let the garbage collector take care of the Elvis impersonator
                return INSTANCE;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、singleton实现--声明包含单个元素的枚举类型&quot;&gt;三、Singleton实现 —— 声明包含单个元素的枚举类型&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//Enum singleton - the preferred approach
public enum Elvis{
        INSTANCE;
        public void leaveTheBuilding(){ ... }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法在功能上与公有域方法相似，但更加简洁，无偿地提供了序列化机制，绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。 虽然这种方法还没有广 泛采用，&lt;strong&gt;但是单元素的枚举类型经常成为实现 Singleton 的最佳方法&lt;/strong&gt;。 注意，如果 Singleton 必须扩展一个超类，而不是扩展 Enum 的时候，则不宜使用这个方法（虽然可以声明枚举去实现接口）。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 20 Feb 2021 14:32:00 +0000</pubDate>
<dc:creator>pedro7</dc:creator>
<og:description>一、什么是Singleton？ 《设计模式》的作者、Eclipse和 Junit 的开发者 Erich Gamma 在它的理论体系中将 Singleton 定义为仅仅被实例化一次的类。在当今面向对象程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/WangXianSCU/p/14423665.html</dc:identifier>
</item>
</channel>
</rss>