<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>学习领域驱动设计走过的误区 - 往事随灬锋</title>
<link>http://www.cnblogs.com/lifeng618/p/10793773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifeng618/p/10793773.html</guid>
<description>&lt;h3&gt;自己学习的误区&lt;/h3&gt;
&lt;p&gt;最开始在博客文章中看到DDD的分层以及一些概念后被深深的吸引了，不喜欢看文章的我，连续看了几个小时没有感觉到厌恶，虽然看完一脸茫然，但是感觉发现了新大陆一样，便开启了学习之路，其中遇到过许多的问题，坚持过，放弃过，有许多的不甘，不愿认输，技不如人，岂能怨天尤人，循序渐进，终有收获，现在的我还只是停留在起步阶段，希望与大家一起交流沟通，相互学习。&lt;/p&gt;
&lt;p&gt;一：没有基础就去学习DDD战术设计，真的很痛苦，比如面向接口编程，什么是依赖注入，为什么要分层，三层架构的理解，以及ORM等等等，没有一定的基础，很难理解仓储模式，应用服务，领域服务，聚合，值对象等&lt;/p&gt;&lt;p&gt;二：一直纠结该怎样去分层，这个是实体还是值对象，领域服务还是应用服务,写代码时犹豫不定，浪费了大量的时间&lt;/p&gt;&lt;p&gt;三：以为学会了一些DDD的分层模式和战术设计，就学会了DDD，DDD是一套综合软件系统分析和设计的面向对象建模方法，是针对复杂系统设计的一套软件工程方法，是思想和技术无关&lt;/p&gt;&lt;p&gt;四：没有重视战略设计，直接就学习战术设计的内容，导致自己的实现无非就是吧 三层架构==》四层架构，只是融入了一些战术设计的一些知识而已&lt;/p&gt;&lt;p&gt;五：看博客文章视频没有记录重要的知识，很容易忘记&lt;/p&gt;&lt;p&gt;六：缺乏面向对象的分析方法与思维，看山是山，看水是水&lt;/p&gt;&lt;p&gt;七：写Demo学习不应该好高骛远，先从基础做起，看一些高层建筑，会让学习举步艰难&lt;/p&gt;&lt;p&gt;八：业务分析，理解能力不够，没有宏观的把控能力，战略设计一片空白&lt;/p&gt;&lt;p&gt;最近在学习战略设计的内容，学习业务的分析方法，想要转变自己的思维，后面我会收集一些DDD的资料以及写一个简单的Demo，希望我们可以一起沟通交流，提出您宝贵的意见，一起学习进步&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1297333/201904/1297333-20190430012533169-1314449584.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Apr 2019 23:44:00 +0000</pubDate>
<dc:creator>往事随灬锋</dc:creator>
<og:description>自己学习的误区 最开始在博客文章中看到DDD的分层以及一些概念后被深深的吸引了，不喜欢看文章的我，连续看了几个小时没有感觉到厌恶，虽然看完一脸茫然，但是感觉发现了新大陆一样，便开启了学习之路，其中遇到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifeng618/p/10793773.html</dc:identifier>
</item>
<item>
<title>一个Login页面全面了解session与cookie - 漠然1992丶</title>
<link>http://www.cnblogs.com/moran1992/p/10793748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moran1992/p/10793748.html</guid>
<description>&lt;p&gt;做了四年的前端开发，对外一直说自己是web开发，那么身为一个web开发怎能不知道session与cookie以及其管理方式呢~&lt;/p&gt;
&lt;p&gt;Login涉及技术栈：Nodejs，MongoDB，Express以及html，css，js&lt;/p&gt;
&lt;p&gt;了解session与cookie之前首先要知道什么是http协议，为什么会出现session与cookie，可以参考很久之前总结的（戳我：&lt;strong&gt;&lt;a title=&quot;session与cookie&quot; href=&quot;https://www.cnblogs.com/moran1992/p/6244308.html&quot; target=&quot;_blank&quot;&gt;session与cookie&lt;/a&gt;&lt;/strong&gt;）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;http协议：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;http即超文本传输协议（万维网定义的），一种基于浏览器请求与服务器响应的链接，它是一个很纯粹的传输协议。http协议主要的特征就是它是一种无状态的协议（只针对cookie与session问题），在客户端连续向服务器发送请求的时候，每次请求的过程中只要数据交换完毕，服务器与客户端就会断开连接，再次请求的时候会重新连接客户端与服务器，这样服务器记录上次的对话，那么问题来了，如何让服务器知道是哪个客户端向自己发出的请求呢，这个时候cookie就诞生了~&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是cookie&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;cookie是一小段文本信息，这段小文本信息由服务器首次响应客户端时发送的，在客户端向服务器首次发送请求的时候，服务器会判断是否要记录客户端的身份，如果需要，此时就会在响应中(response)给客户端发送一个cookie，该cookie文本信息保存在http的报头里，当浏览器会将cookie保存起来，当该浏览器再次发送请求时会携带cookie，服务器检查cookie来识别浏览器请求，这里cookie的特征就不在说明了。下面我们上代码！&lt;/p&gt;
&lt;p&gt;页面代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;doctype html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;jquery-3.3.1.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;='test.js'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Register&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;display:inline-block; width: 100px;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;register-user-name-label&quot;&lt;/span&gt;&lt;span&gt; htmlfor&lt;/span&gt;&lt;span&gt;=&quot;register-user-name-input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;register：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;display:inline-block; width: 200px;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;register-user-name-input&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;display:inline-block; width: 100px;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;register-password-label&quot;&lt;/span&gt;&lt;span&gt; htmlfor&lt;/span&gt;&lt;span&gt;=&quot;register-password-input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pasword：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;display:inline-block; width: 200px;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;register-password-input&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;register&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Register&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Login&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;display:inline-block; width: 100px;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;user-name-label&quot;&lt;/span&gt;&lt;span&gt; htmlfor&lt;/span&gt;&lt;span&gt;=&quot;user-name-input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;login name：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;display:inline-block; width: 200px;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;user-name-input&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;display:inline-block; width: 100px;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;password-label&quot;&lt;/span&gt;&lt;span&gt; htmlfor&lt;/span&gt;&lt;span&gt;=&quot;password-input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pasword：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;display:inline-block; width: 200px;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;password-input&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Login&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;='test.js'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很简单，一个注册按钮一个登陆按钮（ps：代码冗余请忽视，就是为了做个demo用）。&lt;/p&gt;
&lt;p&gt;首先注册一个user：&lt;/p&gt;
&lt;p&gt;注册user之后我们查看db&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1017914/201904/1017914-20190429235033381-1159862583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们用这个user进行登陆操作，重点来啦~&lt;/p&gt;
&lt;p&gt;首先刷新下页面，调用获取user方法，看下效果&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
app.get('/userInfo', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cookie&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (req.cookies.userInfo) {
        console.log(&lt;/span&gt;'login successfully'&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'session timeout.'&lt;span&gt;);
    }
    res.status(&lt;/span&gt;200&lt;span&gt;).json(req.cookies.userInfo);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;session&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if (req.session.userInfo) console.log('login successfully');&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; else console.log('session timeout.');&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017914/201904/1017914-20190429235726326-2092630815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了先mark下，回头再来做对比，下面执行login操作，这里要上代码了。&lt;/p&gt;
&lt;p&gt;首先引入一个中间件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; cookie = require('cookie-parser');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用它：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
app.use(cookie('express_cookie'&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cookie&lt;/span&gt;
app.post('/login', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {
    User.findOne({
        username: req.body.username
    }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (userInfo) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;userInfo) {
            console.log(&lt;/span&gt;'user is not exist.'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; {};
        data[&lt;/span&gt;'username'] =&lt;span&gt; userInfo.username;
        data[&lt;/span&gt;'password'] =&lt;span&gt; userInfo.password;
        res.cookie(&lt;/span&gt;'username', JSON.stringify(data), { maxAge: 900000, httpOnly: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; });
        res.status(&lt;/span&gt;200&lt;span&gt;).json(data);
    })
        .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
            console.log(e);
        })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们可以设置cookie的httpOnly属性，最大生命周期，等等，然后我们先在db内查询当前登录user，如果已经注册过，我们获取user信息并存入cookie中。这时候看下前端的响应有什么不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017914/201904/1017914-20190430000457192-168918139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以看见，服务器颁发的cookie在响应的header中的Set-Cookie中。似不似发现不同了。这时候我们在刷新下页面调用userInfo方法看下效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017914/201904/1017914-20190430000700542-2107198199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咦，我们发现这次的请求里面居然有cookie了，就这么神奇（Ps：我们要相信科学！）。&lt;/p&gt;
&lt;p&gt; debug下看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017914/201904/1017914-20190430000834956-783929976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务器端有我们想要的cookie信息了。这样服务器就可以根据cookie知道了我们每一次的请求是不是同一个人了。&lt;/p&gt;
&lt;p&gt;总结：首先cookie是服务器颁发的，然后随着响应返回给客户端也就是我们的浏览器，浏览器保存cookie，每一次发送请求都会带着这个cookie来让服务器知道，嗯我就是上次的那个人，到这里对cookie是不是多少了解了一些呢~&lt;/p&gt;
&lt;p&gt;好了，那么现在很多浏览器都是禁用cookie的，原因是啥呢~，由于cookie是可以被获取的以及cookie是可以修改的，这时候引出了web安全方面的姿势，跨站脚本攻击以及跨站协议伪造，可以参考我之前写的关于XSS攻击（戳我：&lt;a title=&quot;XSS与CFRS&quot; href=&quot;https://www.cnblogs.com/moran1992/p/10512027.html&quot; target=&quot;_blank&quot;&gt;什么是XSS以及CFRS&lt;/a&gt;），那么如果cookie禁用了我们该怎么办呢？这时候session就诞生了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;何为session：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;session本省并不存在，只是一个概念，session是服务器用来记录客户端状态的机制，不同于cookie保存在浏览器中，session是保存在服务器上的，服务器会根据cookie生成一个session id存在服务器上，当请求再次抵达服务器时，服务器发出响应时会将session id 存在cookie内一同反回给浏览器，这就是session。session具体哪些特点这里就不写啦，话不多说，上代码。&lt;/p&gt;
&lt;p&gt;首先引入一个中间件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; session = require('express-session');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用它&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
app.use(cookie('express_cookie'&lt;span&gt;));
app.use(session({
    secret: &lt;/span&gt;'express_cookie'&lt;span&gt;,
    resave: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    saveUninitialized: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    cookie: { maxAge: &lt;/span&gt;60 * 1000 * 30&lt;span&gt; },
    rolling: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
}));

app.post(&lt;/span&gt;'/login', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {
    User.findOne({
        username: req.body.username
    }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (userInfo) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;userInfo) {
            console.log(&lt;/span&gt;'user is not exist.'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; {};
        data[&lt;/span&gt;'username'] =&lt;span&gt; userInfo.username;
        data[&lt;/span&gt;'password'] =&lt;span&gt; userInfo.password;
        req.session.userInfo &lt;/span&gt;=&lt;span&gt; data;
        res.status(&lt;/span&gt;200&lt;span&gt;).json(data);
    })
        .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
            console.log(e);
        })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们登录一下看下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017914/201904/1017914-20190430002050615-614403521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会发现，多了一个Cookie，而且Cookie里面多了一个sid，不用联想了，这就是sessionId，这时候我们在刷新一下页面看下userInfo变成啥样了呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017914/201904/1017914-20190430002242187-1647611249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以清晰的看到再次请求的时候，sessionId会装在Cookie中，然后发送给服务器，这时候服务器就知道了，咦，原来是上个人。这就是session。&lt;/p&gt;
&lt;p&gt;由于现在服务器session存入的方式我们采用了服务器自带的内存，也叫session memory。如果server挂了怎么办呢，挂掉了内存就释放了啊，session就没了啊。这个时候就引出了另外一个问题，session的可持续化。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;session的可持续化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;session的可持续化方式简单的理解就是让session可以在生命周期内一直存在，可以把session存入db中，可以是MongoDB，可以是redis，上代码，我们这里用MongoDB吧，个人比较喜爱。&lt;/p&gt;
&lt;p&gt;引入中间件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; MongoStore = require('connect-mongo')(session);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
app.use(cookie('express_cookie'&lt;span&gt;));
app.use(session({
    secret: &lt;/span&gt;'express_cookie'&lt;span&gt;,
    resave: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    saveUninitialized: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    cookie: { maxAge: &lt;/span&gt;60 * 1000 * 30&lt;span&gt; },
    rolling: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    store: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MongoStore({
        url: &lt;/span&gt;'mongodb://127.0.0.1:27017/demo'&lt;span&gt;,
        collection: &lt;/span&gt;'sessions'&lt;span&gt;
    })
}));
app.post(&lt;/span&gt;'/login', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {
    User.findOne({
        username: req.body.username
    }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (userInfo) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;userInfo) {
            console.log(&lt;/span&gt;'user is not exist.'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; {};
        data[&lt;/span&gt;'username'] =&lt;span&gt; userInfo.username;
        data[&lt;/span&gt;'password'] =&lt;span&gt; userInfo.password;
        req.session.userInfo &lt;/span&gt;=&lt;span&gt; data;
        res.status(&lt;/span&gt;200&lt;span&gt;).json(data);
    })
        .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
            console.log(e);
        })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;http请求与响应部分我们就不看了，直接看server跟DB。&lt;/p&gt;
&lt;p&gt;server中我们将userInfo放入session中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; {};
data[&lt;/span&gt;'username'] =&lt;span&gt; userInfo.username;
data[&lt;/span&gt;'password'] =&lt;span&gt; userInfo.password;
req.session.userInfo &lt;/span&gt;= data;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看DB&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017914/201904/1017914-20190430003052842-504363352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咦，一条session就在DB中诞生了，这里要注意的是，session不是设置的时候就会存入DB中的，包括内存等等，而且响应成功的时候才会存入，一定要注意，不然坑的就是你。&lt;/p&gt;
&lt;p&gt;然后刷新页面看下效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1017914/201904/1017914-20190430003402576-1102047259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;似不似，session中就有了user信息。好了到这里关于session持久化的问题也解决了。&lt;/p&gt;
&lt;p&gt;登出功能就很简单了，销毁session就ok了，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
app.get(&quot;/loginOut&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
    req.session.destroy(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err){
        console.log(err);
    })
    res.send(&lt;/span&gt;'退出登录成功'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Redis方式：&lt;/p&gt;
&lt;p&gt;中间件以及使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; RedisStrore = require('connect-redis'&lt;span&gt;)(session);
app.use(session({
    secret: &lt;/span&gt;'express_cookie'&lt;span&gt;,
    resave: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    saveUninitialized: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    cookie: { maxAge: &lt;/span&gt;60 * 1000 * 30&lt;span&gt; },
    rolling: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    store: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisStrore({})
}));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：第一次登陆请求的时候，服务器会颁发一个sessionId，响应的时候将sessionId放入cookie中返回给浏览器，此时session已存入DB中，当再次请求的时候携带着sessionId进入服务器中，获取session信息，服务器还是会记得我。&lt;/p&gt;
&lt;p&gt; 时间不早了。在这块的知识还涉及什么时候token，token认证方式，以及什么是jwt。以后有时间会继续更新的。&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/Dqhan/Login&quot;&gt;https://github.com/Dqhan/Login&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;大半夜的，写个博客不容易，请博客园管理员高抬贵手，让我留在首页吧。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 29 Apr 2019 16:54:00 +0000</pubDate>
<dc:creator>漠然1992丶</dc:creator>
<og:description>背景 做了四年的前端开发，对外一直说自己是web开发，那么身为一个web开发怎能不知道session与cookie以及其管理方式呢~ Login涉及技术栈：Nodejs，MongoDB，Express</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moran1992/p/10793748.html</dc:identifier>
</item>
<item>
<title>C#位运算实际运用 - 张林-布莱恩特</title>
<link>http://www.cnblogs.com/zhangmumu/p/10793689.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangmumu/p/10793689.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;前几天写了一篇关于c#位操作，&lt;a href=&quot;https://www.cnblogs.com/zhangmumu/p/10781201.html&quot;&gt;c#位运算基本概念与计算过程&lt;/a&gt;&lt;br/&gt;最后提到一个实际问题&lt;/p&gt;
&lt;ul readability=&quot;0.4806338028169&quot;&gt;&lt;li&gt;需求：C# 用两个short，一个int32拼成一个long型&lt;/li&gt;
&lt;li&gt;要求：现在有两个short和一个int，需要拼成一个long型，高16位用short，中间32位用int，最低16位用另外一个short&lt;br/&gt;&lt;a href=&quot;https://bbs.csdn.net/topics/392202825?page=1&quot; class=&quot;uri&quot;&gt;https://bbs.csdn.net/topics/392202825?page=1&lt;/a&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;答案：((long)shortA &amp;lt;&amp;lt; 48 )+ ((long)intA &amp;lt;&amp;lt; 16)+ shortB=longResult&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;我提出的疑问：能不能根据longResult反推出shortA、intA、shortB&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;我当时的回答：是一个极其错误的答案，原文片段如下&lt;br/&gt;&lt;del&gt;那么疑问来了可以通过longResult返推出shortA，shortB，intA。当然是不能这是直接相加。&lt;br/&gt;返回不应该用这种组合字符串的方式&lt;br/&gt;((long)shortA &amp;lt;&amp;lt; 48 ) 16位二进制0或1的字符串&lt;br/&gt;((long)intA &amp;lt;&amp;lt; 16) 32位二进制0或1的字符串&lt;br/&gt;shortB 16位二进制0或1的字符串&lt;br/&gt;将这三个字符串拼接成64位二进制字符串，再将这个64位二进制字符串转成一个long&lt;/del&gt;&lt;br/&gt;当然这种方式得到的结果是没毛病的，分割二进制的位数，对应去设置0或1。但是做法太草率，没有动脑筋，这种做法效率太低。&lt;br/&gt;正确的做法根据longResult算出shortA、intA、shortB也是要用位运算的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;为什么我要记录下来&quot;&gt;1.为什么我要记录下来&lt;/h3&gt;
&lt;p&gt;有很多最基本的知识点，没有了解到，在遇到错误的时候，会走不少弯路，浪费很多不应该浪费的时间。说简单点，基础知识不牢固，工作效率低。&lt;br/&gt;比如：一个二进制数的第一位是从左边开始算，还是从右边开始算起？&lt;br/&gt;我深信读到这里的人，至少有一部分人不知道。当然，我也是属于这一部分人。（我并不想直接说出答案，可能会猜到有点人打开了百度）&lt;br/&gt;为什么要记录下来？因为今天提交了一段垃圾代码关于整型合并的相互转换。领导看了，很沉默，不说话，发了篇文章给我，让我看，修改一下。其实我提交那段垃圾代码的时候心里就很没底悬得慌，感觉这样做很不合适。学而时习之，温故而知新。&lt;/p&gt;
&lt;h3 id=&quot;两个short一个int如何合并一个long&quot;&gt;2.两个short一个int如何合并一个long？&lt;/h3&gt;
&lt;p&gt;需求：&lt;br/&gt;高16位用short，中间32位用int，最低16位用另外一个short。&lt;br/&gt;答案：((long)shortA &amp;lt;&amp;lt; 48 )+ ((long)intA &amp;lt;&amp;lt; 16)+ shortB&lt;br/&gt;具体的计算过程是这样的&lt;br/&gt;距离shortA 是 17，intA是8，shortB是20&lt;br/&gt;17是short类型 16位的二进制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0001    0001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8是int类型 32位的二进制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0000    0000
0000    0000    0000    1000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;20是short类型 16位的二进制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0001    0100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这个三个二进制就可以得出long类型的64位二进制,long值是4785074604605460&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0001    0001
0000    0000    0000    0000
0000    0000    0000    1000
0000    0000    0001    0100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;step1：将shortA 17的二进制左位移48位也就是这个long类型最左边16位（17一定要先转成long再左位移,一定要记住这一点）&lt;br/&gt;(long)17&amp;lt;&amp;lt;48 的结果是4785074604081152 17乘以2的48次方法&lt;br/&gt;2的49次方（第一个1在49位）加上2的53次方（第二个1在53位）&lt;br/&gt;17的64位二进制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0000    0000
0000    0000    0000    0000
0000    0000    0000    0000
0000    0000    0001    0001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;向左移动48位后&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0001    0001
0000    0000    0000    0000
0000    0000    0000    0000
0000    0000    0000    0000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;step2：8的二进制左移16位，（long）8&amp;lt;&amp;lt;16的结果是：524588&lt;br/&gt;8的64位二进制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0000    0000
0000    0000    0000    0000
0000    0000    0000    0000
0000    0000    0000    1000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;向左移动16位后&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0000    0000
0000    0000    0000    1000
0000    0000    0000    0000
0000    0000    0000    0000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;step3 ：&lt;br/&gt;(long)17&amp;lt;&amp;lt;48 +（long)8&amp;lt;&amp;lt;16 =4785074604081152 +524588&lt;br/&gt;有效位数已经占满了前48位，剩下的有效16位就是20&lt;br/&gt;最终的结果就是&lt;br/&gt;((long)8&amp;lt;&amp;lt;16)+((long)17&amp;lt;&amp;lt;48)+20 =4785074604605460&lt;/p&gt;
&lt;h3 id=&quot;根据long如何反推出合并前的两个short和一个int&quot;&gt;3.根据long如何反推出合并前的两个short和一个int&lt;/h3&gt;
&lt;p&gt;完美三部曲，干就完事了。&lt;br/&gt;step1：首先要获取前16位有效值shortA&lt;br/&gt;我们已经知道了longResult 4785074604605460的64位二进制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0001    0001
0000    0000    0000    0000
0000    0000    0000    1000
0000    0000    0001    0100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将这个long类型往右移动48位得到的64位二进制，也就是16位有效值shortA，这个short就是17&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0000    0000
0000    0000    0000    0000
0000    0000    0000    0000
0000    0000    0001    0001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;longResult &amp;gt;&amp;gt;48完美得到shortA的值17,右位移也就是longResult整除2的48次方&lt;br/&gt;shortA =（short)(longResult&amp;lt;&amp;lt;48)&lt;/p&gt;
&lt;p&gt;step2：然后获取中间32位intA的值，先将这个longResult右位移16位，得到后48位有效值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0000    0000
0000    0000    0001    0001
0000    0000    0000    0000
0000    0000    0000    1000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在要取的后面32位有效值才是intA的值，再将(longResult&amp;gt;&amp;gt;16)&amp;amp;0xFFFFFFFF，做逻辑与运算，0xFFFFFFFF（4294967295）的64位二进制全部都是1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1111    1111    1111    1111
1111    1111    1111    1111
1111    1111    1111    1111
1111    1111    1111    1111&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与运算的规则1&amp;amp;1=1 、1&amp;amp;0=0、0&amp;amp;0=0，所以对后48位有效值做完逻辑与运算，就得到有效32位的intA&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0000    0000
0000    0000    0000    0000
0000    0000    0000    0000
0000    0000    0000    1000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;intA=(int)((longResult&amp;gt;&amp;gt;16)&amp;amp;0xFFFFFFFF)&lt;br/&gt;intA的最终结果就是8&lt;/p&gt;
&lt;p&gt;step3：最后获取最右边16位的shortB（将前面48位都变成0），只需要做一次与运算就可以，longResult做与运算的对象是0xFFFF（65535），有效16位全部都是1，二进制如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0000    0000
0000    0000    0000    0000
1111    1111    1111    1111
1111    1111    1111    1111&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;longResult&amp;amp;0xFFFF的最终结果就是20&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0000    0000    0000    0000
0000    0000    0000    0000
0000    0000    0000    0000
0000    0000    0001    0100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;shortB=(short)(longResult&amp;amp;0xFFFF)=20；&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;4.总结&lt;/h3&gt;
&lt;p&gt;高16位用short，中间32位用int，最低16位用另外一个short。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;longResult=((long)shortA &amp;lt;&amp;lt; 48 )+ ((long)intA &amp;lt;&amp;lt; 16)+ shortB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据longResult获取前16位shortA，中间32位intA，后16位shortB&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;shortA=(short)(longResult&amp;gt;&amp;gt;48)
intA=(int)((longResult&amp;gt;&amp;gt;16)&amp;amp;0xFFFFFFFF)
shortB=(short)(longResult&amp;amp;0xFFFF)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么&lt;br/&gt;想用一个byte存两个数，如何相互转换？&lt;br/&gt;如何获取和设置一个int的二进制位？&lt;br/&gt;知道计算过程和位运算的基本概念，这些问题就非常简单，会者不难，难者不会。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Apr 2019 16:24:00 +0000</pubDate>
<dc:creator>张林-布莱恩特</dc:creator>
<og:description>一个二进制数的第一位是从左边开始算，还是从右边开始算起？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangmumu/p/10793689.html</dc:identifier>
</item>
<item>
<title>MySQL 中的数字类型 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/mysql_data_type_number.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/mysql_data_type_number.html</guid>
<description>&lt;p&gt;MySQL 中数据类型常用的就三大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数字类型/numeric types&lt;/li&gt;
&lt;li&gt;日期和时间/date and time types&lt;/li&gt;
&lt;li&gt;字符类型/string (character and byte) types&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外还包含两个没那么常用的大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特殊类型/spatial types&lt;/li&gt;
&lt;li&gt;JSON&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;继续之前，先来看一些单位上的约定和概念，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;M&lt;/strong&gt;：根据具体不同的类型，其表示的意思不一样，见下方关于这个参数的讨论。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;D&lt;/strong&gt; 用于定点及浮点数，表示小数点后有多少位。最大可能取值为 30，但不应该超过 M-2。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fsp&lt;/strong&gt; 适用于 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/time.html&quot; rel=&quot;nofollow&quot;&gt;TIME&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/datetime.html&quot; rel=&quot;nofollow&quot;&gt;DATETIME&lt;/a&gt; 及 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/datetime.html&quot; rel=&quot;nofollow&quot;&gt;TIMESTAMP&lt;/a&gt;。可理解秒后面的小数点位数。它应该是介于 0~6 之间的，0 表示没有小数部分（fractin part）。默认为 0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; 方括号表示类型中可选的部分。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;存储字符串时指定的类型 &lt;code&gt;VARCHAR(50)&lt;/code&gt; 中可接收一个数字作为长度，其实除了字符串类型，数字类型也是可指定该参数的，比如 &lt;code&gt;INT(10)&lt;/code&gt;，&lt;code&gt;BIGINT(20)&lt;/code&gt;。假设后续讨论中这个参数使用字母 &lt;strong&gt;M&lt;/strong&gt; 来表示，即上面提到的。该参数被用在不同类型上时，其表示的意思不一样。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于整形，它表示 &lt;strong&gt;展示宽度/display width&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;对于定点数（fixed point）或浮点数（floating point），表示能够存储的总位数，即精度。&lt;/li&gt;
&lt;li&gt;对于字符串，表示能够存储的字符串长度。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;展示宽度/Display Width&lt;/h4&gt;
&lt;p&gt;那么什么是&lt;strong&gt;展示宽度&lt;/strong&gt;。展示宽度这个参数具有迷惑性，它不像 &lt;code&gt;CHAR(M)&lt;/code&gt; 中有实际意义表示能够存储的字符串长度，在数字类型中，它指数字展示时需要的宽度，是 MySQL 格式化时使用的。即 &lt;code&gt;INT(5)&lt;/code&gt;，&lt;code&gt;INT(15)&lt;/code&gt;，&lt;code&gt;INT(25)&lt;/code&gt; 能够存储的数字范围都是 &lt;code&gt;INT&lt;/code&gt; 类型的范围 -2147483648 ~ 2147483647。如果指定了 &lt;code&gt;ZEROFILL&lt;/code&gt;，MySQL 在返回该数字时，对于实际位数小于展示宽度的数字，将自动在左边补零。比如列的类型为 &lt;code&gt;INT(5)&lt;/code&gt;，实际存储了数字 5，返回时会得到 &lt;code&gt;00005&lt;/code&gt;。对于没有指定 &lt;code&gt;ZEROFILL&lt;/code&gt; 或实际存储的位数大于指定的展示宽度，则不会自动补零，此时看上去没有任何效果。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;test_zero_fill&lt;/span&gt; 
  ( 
     with_fill    &lt;span class=&quot;pl-k&quot;&gt;INT&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;5&lt;/span&gt;) UNSIGNED ZEROFILL &lt;span class=&quot;pl-k&quot;&gt;NOT NULL&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;PRIMARY KEY&lt;/span&gt;, 
     without_fill &lt;span class=&quot;pl-k&quot;&gt;INT&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;5&lt;/span&gt;) UNSIGNED &lt;span class=&quot;pl-k&quot;&gt;NOT NULL&lt;/span&gt; 
  ); 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; INSERT INTO test_zero_fill (with_fill, without_fill) VALUES (5, 5),(123456, 123456)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;*&lt;/span&gt; from test_zero_fill&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+-----------+--------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; with_fill &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; without_fill &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+-----------+--------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;     00005 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;            5 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;    123456 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;       123456 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+-----------+--------------+
2 rows &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，如果使用了 &lt;code&gt;ZEROFILL&lt;/code&gt;，该列将自动设置为 &lt;code&gt;UNSIGNED&lt;/code&gt; 类型。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; ALTER TABLE test_zero_fill ADD signed_num INT(5) signed ZEROFILL NOT NULL after without_fill&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; describe test_zero_fill&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+--------------+--------------------------+------+-----+---------+-------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Field        &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Type                     &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Null &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Key &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Default &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Extra &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+--------------+--------------------------+------+-----+---------+-------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; with_fill    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; int(5) unsigned zerofill &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; NO   &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; PRI &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; NULL    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;       &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; without_fill &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; int(5) unsigned          &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; NO   &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;     &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; NULL    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;       &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; signed_num   &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; int(5) unsigned zerofill &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; NO   &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;     &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; NULL    &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;       &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+--------------+--------------------------+------+-----+---------+-------+
3 rows &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以对于数据存储层面来说，展示宽度其实没什么用途。如果真的需要格式化，程序中能够请求 MySQL 的 meta 信息以获取到相应的展示宽度。&lt;/p&gt;
&lt;p&gt;假如在 Node.js 中使用 &lt;a href=&quot;https://github.com/mysqljs/mysql&quot;&gt;mysqljs/mysql&lt;/a&gt; 作为数据库连接的模块，在执行请求时，其回调中返回的 &lt;code&gt;fields&lt;/code&gt; 入参便包含了列相应的 meta 信息。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-smi&quot;&gt;connection&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;SELECT * from test_zero_fill&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt;(
    &lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;,
    &lt;span class=&quot;pl-smi&quot;&gt;results&lt;/span&gt;,
    &lt;span class=&quot;pl-smi&quot;&gt;fields&lt;/span&gt;
) {
    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; (error) &lt;span class=&quot;pl-k&quot;&gt;throw&lt;/span&gt; error;
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(fields);
});
&lt;/pre&gt;&lt;/div&gt;
&lt;details readability=&quot;23&quot;&gt;fields 中包含列的 meta 信息
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
  FieldPacket {
    catalog: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;def&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    db: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;data_type&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    table: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;test_zero_fill&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    orgTable: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;test_zero_fill&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    name: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;with_fill&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    orgName: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;with_fill&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    charsetNr: 63,
    length: 5,
    type: 3,
    flags: 20579,
    decimals: 0,
    default: undefined,
    zeroFill: true,
    protocol41: &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
  },
  FieldPacket {
    catalog: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;def&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    db: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;data_type&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    table: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;test_zero_fill&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    orgTable: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;test_zero_fill&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    name: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;without_fill&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    orgName: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;without_fill&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    charsetNr: 63,
    length: 5,
    type: 3,
    flags: 4129,
    decimals: 0,
    default: undefined,
    zeroFill: false,
    protocol41: &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
  },
  FieldPacket {
    catalog: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;def&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    db: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;data_type&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    table: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;test_zero_fill&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    orgTable: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;test_zero_fill&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    name: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;signed_num&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    orgName: &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;signed_num&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;,
    charsetNr: 63,
    length: 5,
    type: 3,
    flags: 4193,
    decimals: 0,
    default: undefined,
    zeroFill: true,
    protocol41: &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;
  }
]
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;p&gt;因此，在设计表时，应该关注使用哪种具体的数据类型能够满足数据存储的需要，而不要被展示宽度所迷惑。&lt;/p&gt;
&lt;h2&gt;数字类型&lt;/h2&gt;
&lt;p&gt;数字类型分为有符号 &lt;code&gt;SIGNED&lt;/code&gt; 和无符号 &lt;code&gt;UNSIGNED&lt;/code&gt; 的情况，有符号即最前面有一位符呈位，可表示正负数。默认情况下为 &lt;code&gt;SIGNED&lt;/code&gt; 即有符号。&lt;/p&gt;
&lt;h3&gt;整型&lt;/h3&gt;
&lt;p&gt;MySQL 中支持标准的 SQL 整型，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;INTEGER (INT)&lt;/li&gt;
&lt;li&gt;SMALLINT&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;并且扩展了一些类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TINYINT&lt;/li&gt;
&lt;li&gt;MEDIUMINT&lt;/li&gt;
&lt;li&gt;BIGINT&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下是 MySQL 中支持的整型，及其对应所需存储空间和取值范围。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;空间 (字节)&lt;/th&gt;
&lt;th&gt;有符号时最小取值&lt;/th&gt;
&lt;th&gt;无符号时最小取值&lt;/th&gt;
&lt;th&gt;有符号时最大取值&lt;/th&gt;
&lt;th&gt;无符号时最大取值&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;TINYINT&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-128&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;-32768&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;32767&lt;/td&gt;
&lt;td&gt;65535&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;-8388608&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;8388607&lt;/td&gt;
&lt;td&gt;16777215&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;-2147483648&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2147483647&lt;/td&gt;
&lt;td&gt;4294967295&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BIGINT&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;-2&lt;sup&gt;63&lt;/sup&gt;&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;sup&gt;63&lt;/sup&gt;-1&lt;/td&gt;
&lt;td&gt;2&lt;sup&gt;64&lt;/sup&gt;-1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;具体到每种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/integer-types.html&quot; rel=&quot;nofollow&quot;&gt;TINYINT[(M)] [UNSIGNED] [ZEROFILL]&lt;/a&gt;：微整型，取值范围 -128 ~ 127，无符号情况下为 0 ~ 255。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/integer-types.html&quot; rel=&quot;nofollow&quot;&gt;BOOL, BOOLEAN&lt;/a&gt;：效果等同 &lt;code&gt;TINYINT(1)&lt;/code&gt;，0 表示 FALSE，其他非 0 值处理成 TRUE。其中关键字 &lt;code&gt;TRUE&lt;/code&gt;，&lt;code&gt;FALSE&lt;/code&gt; 真实代表的是数字 1 和 0。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;22&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT IF(0, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; IF(0, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;                  &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------------------------+

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT IF(1, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; IF(1, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;                   &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------------------------+

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT IF(2, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; IF(2, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;                   &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------------------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;26&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT IF(0 = FALSE, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+--------------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; IF(0 = FALSE, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+--------------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;                           &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+--------------------------------+

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT IF(1 = TRUE, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+-------------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; IF(1 = TRUE, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+-------------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;true&lt;/span&gt;                          &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+-------------------------------+

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT IF(2 = TRUE, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+-------------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; IF(2 = TRUE, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+-------------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;                         &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+-------------------------------+

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT IF(2 = FALSE, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+--------------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; IF(2 = FALSE, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;true&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;false&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+--------------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;false&lt;/span&gt;                          &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+--------------------------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于大整型，关键字 &lt;code&gt;SERIAL&lt;/code&gt; 等同于 &lt;code&gt;BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;还记得创建表时一般需要指定一个自增的整形 ID 字段么，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
CREATE TABLE table_name (id INT UNSIGNED PRIMARY KEY NOT NULL AUTO_INCREMENT)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;SERIAL&lt;/code&gt; 关键字其实是 &lt;code&gt;BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE&lt;/code&gt; 的别名，所以下次创建表时可直接使用该关键字，会省事很多。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
CREATE TABLE table_name (id SERIAL PRIMARY KEY)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你不想要 BIGINT，&lt;code&gt;SERIAL DEFAULT VALUE&lt;/code&gt; 是 &lt;code&gt;NOT NULL AUTO_INCREMENT UNIQUE&lt;/code&gt; 的别名，那么可以这样来简写 ID 字段：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
CREATE TABLE table_name (id INT SERIAL DEFAULT VALUE PRIMARY KEY)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;定点型&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/fixed-point-types.html&quot; rel=&quot;nofollow&quot;&gt;DECIMAL[(M[,D])] [UNSIGNED] [ZEROFILL]&lt;/a&gt; 定点型数字，其中 M 表示总的位数（不包含正负号及小数点），D 表示小数位数。D 为 0 则表示没有小数部分。M 最大取值 65，默认 10；D 最大支持到 30，默认 0。所有的算术运算（&lt;code&gt;+&lt;/code&gt;，&lt;code&gt;-&lt;/code&gt;，&lt;code&gt;*&lt;/code&gt;，&lt;code&gt;/&lt;/code&gt;）都基于 65 位的 DECIMAL。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/fixed-point-types.html&quot; rel=&quot;nofollow&quot;&gt;DEC[(M[,D])] [UNSIGNED] [ZEROFILL]&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/fixed-point-types.html&quot; rel=&quot;nofollow&quot;&gt;NUMERIC[(M[,D])] [UNSIGNED] [ZEROFILL]&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/fixed-point-types.html&quot; rel=&quot;nofollow&quot;&gt;FIXED[(M[,D])] [UNSIGNED] [ZEROFILL]&lt;/a&gt; 同 &lt;code&gt;DECIMAL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;定点型数字存储精确的数字，用于准确性要求高的场合，比如涉及&lt;strong&gt;金钱&lt;/strong&gt;。底层实现上，MySQL 使用二进制形式存储该类型的值。&lt;/p&gt;
&lt;p&gt;通常的用法如下：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot;&gt;
&lt;pre&gt;
salary &lt;span class=&quot;pl-k&quot;&gt;DECIMAL&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;pl-c1&quot;&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面示例中，salary 为一个 5 位精度两位小数的定点型。取值范围 -999.99 ~ 999.99。&lt;/p&gt;
&lt;p&gt;因为 D 缺省时默认为 0，所以 &lt;code&gt;DECIMAL(M)&lt;/code&gt; 表示 &lt;code&gt;DECIMAL(M,0)&lt;/code&gt;，现时，MySQL 中，M 缺省时默认为 10，所以 &lt;code&gt;DECIMAL&lt;/code&gt; 表示 &lt;code&gt;DECIMAL(10,0)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当实际存储的值其小数大于指定的位数时，其精度会自动转换成所存储的值的精度。&lt;/p&gt;
&lt;h3&gt;浮点型&lt;/h3&gt;
&lt;p&gt;区别于 DECIMAL，浮点型存储的数字是个近似值。内部存储时，MySQL 为单精度使用 4 字节（bytes），双精度使用 8 字节。&lt;/p&gt;
&lt;p&gt;浮点型包含以下这些类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/floating-point-types.html&quot; rel=&quot;nofollow&quot;&gt;FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]&lt;/a&gt;：小型的单精度浮点型。根据 IEEE 标准理论取值范围 -3.402823466E+38 ~ -1.175494351E-38, 0, 1.175494351E-38 ~ 3.402823466E+38，实际的取值范围因硬件和操作系统而异，会比理论值要小。
&lt;ul&gt;&lt;li&gt;M 表示总位数，D 表示小数位数。两者省略的情况下，其值为硬件允许的最大值。比如 &lt;code&gt;FLOAT(7,4)&lt;/code&gt; 看起来会是这个样子： &lt;code&gt;-999.9999&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FLOAT[(M,D)&lt;/code&gt; 这种形式的类型不是标准的 SQL 类型，后续会废弃掉。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/floating-point-types.html&quot; rel=&quot;nofollow&quot;&gt;FLOAT(p) [UNSIGNED] [ZEROFILL]&lt;/a&gt;：是标准的 SQL 类型，p 表示精度。但 MySQL 中，根据 p 取值的不同，底层实际将其处理成别的类型。比如 0 ~ 24 时，当成 4 字节单精度 FLOAT 类型来处理，25 ~ 53 时处理成 8 字节双精度的 DOUBLE 类型。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/floating-point-types.html&quot; rel=&quot;nofollow&quot;&gt;DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]&lt;/a&gt;：双精度浮点型。取值范围 -1.7976931348623157E+308 ~ -2.2250738585072014E-308, 0, 2.2250738585072014E-308 ~ 1.7976931348623157E+308。同 &lt;code&gt;FLOAT(M,D)&lt;/code&gt;，&lt;code&gt;DOUBLE(M,D)&lt;/code&gt; 这种形式的双精度类型也是非标准 SQL 类型，后续会废弃。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/floating-point-types.html&quot; rel=&quot;nofollow&quot;&gt;DOUBLE PRECISION[(M,D)] [UNSIGNED] [ZEROFILL]&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/floating-point-types.html&quot; rel=&quot;nofollow&quot;&gt;REAL[(M,D)] [UNSIGNED] [ZEROFILL]&lt;/a&gt;：DOUBLE 的别名。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以实际使用时，为了最大限度的兼容性，直接使用 &lt;code&gt;FLOAT&lt;/code&gt;，&lt;code&gt;DOUBLE&lt;/code&gt;，&lt;code&gt;PRECISION&lt;/code&gt; 而不要指定精度及小数。&lt;/p&gt;
&lt;h3&gt;BIT 类型&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/bit-type.html&quot; rel=&quot;nofollow&quot;&gt;BIT[(M)]&lt;/a&gt; 类型用于存储单个状态值，M 表示包含几位。默认为1，最大可取 64。&lt;/p&gt;
&lt;p&gt;该类型的值可通过 &lt;code&gt;b'value'&lt;/code&gt; 的形式书写，其中 value 部分以二进制的形式呈现，比如 b'111' 和 b'10000000' 分别表示 7 和 128。更加详细的信息可参考 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/bit-value-literals.html&quot; rel=&quot;nofollow&quot;&gt;9.1.5 Bit-Value Literals&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果赋值到该类型上的值小于 M 指定的位数，值左边会补零，比如将 b'101' 存储到类型为 BIT(6) 的列，实际会是 b'000101'。&lt;/p&gt;
&lt;h2&gt;存储的值溢出的情况&lt;/h2&gt;
&lt;p&gt;将要存储的值超出数字类型的范围时，其表现跟当前设置的 SQL 模式有关。具体来说，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开启 SQL 严格模式时，超出范围的值会写入失败，MySQL 会中断操作并且直接抛错。&lt;/li&gt;
&lt;li&gt;非严格模式下，MySQL 会将值裁剪到合适的大小进行写入。即超出的情况下存成该类型能够接收的最大值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;考察一个通过如下语句创建的表 &lt;code&gt;t1&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t1&lt;/span&gt; (i1 TINYINT, i2 TINYINT UNSIGNED);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SQL 严格模式下，尝试写入一个超出范围的值时抛错：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SET sql_mode = &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;TRADITIONAL&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; INSERT INTO t1 (i1, i2) VALUES(256, 256)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
ERROR 1264 (22003): Out of range value &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; column &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;i1&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; at row 1
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; FROM t1&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Empty &lt;span class=&quot;pl-c1&quot;&gt;set&lt;/span&gt; (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下是非严格模式下进行裁剪存储的情况：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SET sql_mode = &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; INSERT INTO t1 (i1, i2) VALUES(256, 256)&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SHOW WARNINGS&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+---------+------+---------------------------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Level   &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Code &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Message                                     &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+---------+------+---------------------------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Warning &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 1264 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Out of range value &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; column &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;i1&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; at row 1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Warning &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 1264 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; Out of range value &lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; column &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;i2&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt; at row 1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+---------+------+---------------------------------------------+
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; FROM t1&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+------+------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; i1   &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; i2   &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------+------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;  127 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;  255 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+------+------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述表现同样会出现在涉及到对列进行转换修改的一些操作上，比如 &lt;code&gt;ALTER TABLE&lt;/code&gt;，&lt;code&gt;LOAD DATA&lt;/code&gt;，&lt;code&gt;UPDATE&lt;/code&gt; 以及使用 &lt;code&gt;INSERT&lt;/code&gt; 同时插入多行数据时。严格模式下会抛错失败，非严格模式下值会进行裁剪。但失败的情况不尽相同，如果是事务类型的表，会整个全失败，其他情况根据具体的值会部分成功，部分失败。&lt;/p&gt;
&lt;p&gt;进行数字计算时如果有溢出，也会抛错，比如对于 BIGINT 其最大值为 9223372036854775807，因为 MySQL 中默认对数字类型是有符号类型，如下操作会抛错，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT 9223372036854775807 + 1&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
ERROR 1690 (22003): BIGINT value is out of range &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;(9223372036854775807 + 1)&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于上述情况，可显式将 被操作数进行类型转换，转成无符号的 BIGINT：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT CAST(9223372036854775807 AS UNSIGNED) + 1&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+-------------------------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; CAST(9223372036854775807 AS UNSIGNED) + 1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+-------------------------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;                       9223372036854775808 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+-------------------------------------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过带上小数后，转成 DECIMAL 也能修正上面的错误，因为 DECIMAL 比整形要大，&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT 9223372036854775807.0 + 1&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+---------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; 9223372036854775807.0 + 1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+---------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;     9223372036854775808.0 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+---------------------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两数相减时，其中一个为无符号数，得出的结果默认为也为无符号。所以如果想减之后结果是负数，则会抛错。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SET sql_mode = &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
Query OK, 0 rows affected (0.00 sec)

mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT CAST(0 AS UNSIGNED) - 1&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
ERROR 1690 (22003): BIGINT UNSIGNED value is out of range &lt;span class=&quot;pl-k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;(cast(0 as unsigned) - 1)&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除非开启了 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html#sqlmode_no_unsigned_subtraction&quot; rel=&quot;nofollow&quot;&gt;&lt;code&gt;NO_UNSIGNED_SUBTRACTION&lt;/code&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SET sql_mode = &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;NO_UNSIGNED_SUBTRACTION&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
mysql&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt; SELECT CAST(0 AS UNSIGNED) - 1&lt;span class=&quot;pl-k&quot;&gt;;&lt;/span&gt;
+-------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt; CAST(0 AS UNSIGNED) - 1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+-------------------------+
&lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;                      -1 &lt;span class=&quot;pl-k&quot;&gt;|&lt;/span&gt;
+-------------------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;对于整型或浮点型，可指定 &lt;code&gt;AUTO_INCREMTN&lt;/code&gt; 属性。指定该属性性，将不能接收负值。同时 &lt;code&gt;CHECK&lt;/code&gt; 属性与该属性冲突，也不能同时使用。但对于 FLOAT 和 DOUBLE，&lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 属性的支持将逐渐废弃掉，实际使用时尽量避免。&lt;/p&gt;
&lt;p&gt;对于需要精确数值的场合，使用 DECIMAL，比如涉及金钱的情况。&lt;/p&gt;
&lt;p&gt;对于整形，展示宽度不是其存储的值范围，只用来格式化。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Mon, 29 Apr 2019 15:47:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>MySQL 中数据类型常用的就三大类： 数字类型/numeric types 日期和时间/date and time types 字符类型/string (character and byte) ty</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/mysql_data_type_number.html</dc:identifier>
</item>
<item>
<title>ABP实践(3)-ASP.NET Core 2.x版本(从创建实体到输出api)简单实现商品列表及增删改 - wuyubing</title>
<link>http://www.cnblogs.com/wuyubing/p/10790963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyubing/p/10790963.html</guid>
<description>&lt;p&gt;项目基于前两篇文章.&lt;/p&gt;
&lt;p&gt;本章创建一个简单版的商品管理后台api,用到EF Core用code fist迁移数据创建数据库.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建Goods实体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在领域层xxx.Core项目[新建文件夹Goods;文件夹名称和类名称一样后面引用的时候需要Goods.Goods,所以建议文件夹名称最好是不要与类同名]在文件夹下创建Goods.cs实体类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190429114526159-290036606.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    [Table(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;goods&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Goods : AuditedAggregateRoot&amp;lt;Guid&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 商品名称
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Required]&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必填&lt;/span&gt;
        [StringLength(&lt;span&gt;100&lt;/span&gt;)]&lt;span&gt;//&lt;/span&gt;&lt;span&gt;限制长度100&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GoodsName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 价格
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 描述
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Describe{ &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 剩余数量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SurplusQty { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构造函数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;goodsName&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;price&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;describe&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;surplusQty&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Goods(&lt;span&gt;string&lt;/span&gt; goodsName, &lt;span&gt;decimal&lt;/span&gt; price, &lt;span&gt;string&lt;/span&gt; describe,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; surplusQty)
        {
            GoodsName &lt;/span&gt;=&lt;span&gt; goodsName;
            Price &lt;/span&gt;=&lt;span&gt; price;
            Describe &lt;/span&gt;=&lt;span&gt; describe;
            SurplusQty &lt;/span&gt;=&lt;span&gt; surplusQty;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ABP有两个基本的实体基类: &lt;code&gt;AggregateRoot&lt;span&gt;(领域驱动设计(DDD)的概念之一)&lt;/span&gt;&lt;/code&gt; 和 &lt;code&gt;Entity,继承AggregateRoot会默认添加审计属性CreationTime,CreatorId&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;Guid&amp;gt;&lt;/code&gt;是&lt;code&gt;Goods&lt;/code&gt;实体的主键类型可以是int,string等根据自己场景设置&lt;/p&gt;
&lt;h4 id=&quot;将book实体添加到dbcontext中&quot;&gt;将Goods实体添加到DbContext中&lt;/h4&gt;
&lt;p&gt;在基础层xxx.EntityFrameworkCore下找到xxxDbContext.cs加入Goods实体对应的DbSet&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190429114706282-589848639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于文件夹名称和类文件同名所以需要Goods.Goods不然只需要类名Goods就行了&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Goods.Goods&amp;gt; Goods { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 添加新的Migration并更新数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1,打开程序包管理器控制台，默认项目选择Entityframework对应的项目后。执行&lt;code&gt;Add-Migration Add_Goods_Entity&lt;/code&gt;，创建迁移&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190429145340377-2021549034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2,在程序包管理器控制台，输入&lt;code&gt;Update-Database&lt;/code&gt;，回车执行迁移。执行成功后，查看数据库,看是否存在表及初始数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190429151249071-807357701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行成功之后刷新数据库查看是否有成功创建表goods&lt;/p&gt;
&lt;p&gt;3,给goods表添加几条初始化数据&lt;/p&gt;
&lt;p&gt;3.1 在基础层xxx.EntityFrameworkCore下创建Goods初始化数据类DefaultGoodsCreator.cs&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190429150034450-794133540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultGoodsCreator
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; crazyDbContext _context;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;crazy.Goods.Goods&amp;gt; GoodsList=&lt;span&gt; GetInitialGoods();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DefaultGoodsCreator(crazyDbContext context)
        {
            _context &lt;/span&gt;=&lt;span&gt; context;
        }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;crazy.Goods.Goods&amp;gt;&lt;span&gt; GetInitialGoods()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;crazy.Goods.Goods&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; crazy.Goods.Goods(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;商品1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;描述1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; crazy.Goods.Goods(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;商品2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;260&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;描述2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;50&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; crazy.Goods.Goods(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;商品3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;描述2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;),
            };
        }
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Create()
        {
            CreateGoods();
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 循环添加初始数据
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CreateGoods()
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; goods &lt;span&gt;in&lt;/span&gt;&lt;span&gt; GoodsList)
            {
                AddGoodsIfNotExists(goods);
            }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 判断添加不存在的商品数据
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;goods&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddGoodsIfNotExists(crazy.Goods.Goods goods)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_context.Goods.IgnoreQueryFilters().Any(l =&amp;gt; l.GoodsName ==&lt;span&gt; goods.GoodsName))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            _context.Goods.Add(goods);
            _context.SaveChanges();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.2在基础层xxx.EntityFrameworkCore找到文件夹Seed下的SeedHelper.cs插入代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Goods初始化数据&lt;/span&gt;
&lt;span&gt;new&lt;/span&gt; DefaultGoodsCreator(context).Create();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190429150748012-1143399657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置crazy.Web.Host为启动项运行项目,运行之后数据库就会生成goods初始化数据.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190429155700707-2011746468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;创建应用服务&quot;&gt;创建应用服务&lt;/h3&gt;
&lt;p&gt;1在应用服务层xxx.Application创建文件夹Goods&amp;gt;Dto&lt;/p&gt;
&lt;p&gt;①添加GoodsDto.cs&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190429163224970-554688540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_862f5464-010e-413f-9057-40b4484baf9e&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_862f5464-010e-413f-9057-40b4484baf9e&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_862f5464-010e-413f-9057-40b4484baf9e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
[AutoMapFrom(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Goods))]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GoodsDto : AuditedEntityDto&amp;lt;Guid&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 商品名称
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GoodsName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 价格
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 描述
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Describe { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 剩余数量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SurplusQty { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;code&gt;[AutoMapFrom(typeof(Goods))]&lt;/code&gt;用来创建从&lt;code&gt;Goods&lt;/code&gt;类到&lt;code&gt;GoodsDto&lt;/code&gt;的AutoMapper映射.使用这种方法.你可以将&lt;code&gt;Goods&lt;/code&gt;对象自动转换成&lt;code&gt;GoodsDto&lt;/code&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;②添加&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot; language-csharp&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;CreateUpdateBookDto用于在创建或更新&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[AutoMapFrom(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Goods))]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CreateUpdateGoodsDto : AuditedEntityDto&amp;lt;Guid&amp;gt;
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 商品名称
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        [Required]
        [StringLength(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GoodsName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 价格
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 描述
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Describe { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 剩余数量
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SurplusQty { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;999&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③在应用服务层的Goods文件夹下创建接口&lt;code&gt;IGoodsAppService.cs&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IGoodsAppService :
        IAsyncCrudAppService&lt;/span&gt;&amp;lt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义了基础的 CRUD方法:GetAsync, GetListAsync, CreateAsync, UpdateAsync 和 DeleteAsync.如果不需要扩展它,你可以继承空的IApplicationService接口定义你自己的方法&lt;/span&gt;
            GoodsDto, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;展示商品&lt;/span&gt;
            Guid, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Goods实体的主键&lt;/span&gt;
            PagedAndSortedResultRequestDto, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取商品的时候用于分页和排序&lt;/span&gt;
            CreateUpdateGoodsDto, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建&lt;/span&gt;
            CreateUpdateGoodsDto&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新&lt;/span&gt;
&lt;span&gt;    {

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④在应用服务层的Goods文件夹下创建商品服务类&lt;code&gt;GoodsAppService.cs&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GoodsAppService :
        AsyncCrudAppService&lt;/span&gt;&amp;lt;&lt;span&gt;Goods, GoodsDto, Guid, PagedAndSortedResultRequestDto,
                            CreateUpdateGoodsDto, CreateUpdateGoodsDto&lt;/span&gt;&amp;gt;&lt;span&gt;,
        IGoodsAppService
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; GoodsAppService(IRepository&amp;lt;Goods, Guid&amp;gt; repository)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入IRepository自动为Goods创建仓储&lt;/span&gt;
            : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(repository)
        {

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此就可以运行项目得到如下效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/587824/201904/587824-20190429174618842-265404110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 29 Apr 2019 15:20:00 +0000</pubDate>
<dc:creator>wuyubing</dc:creator>
<og:description>项目基于前两篇文章. 本章创建一个简单版的商品管理后台api,用到EF Core用code fist迁移数据创建数据库. 创建Goods实体 在领域层xxx.Core项目[新建文件夹Goods;文件夹</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuyubing/p/10790963.html</dc:identifier>
</item>
<item>
<title>死磕 java集合之ArrayDeque源码分析 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/ArrayDeque.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/ArrayDeque.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）什么是双端队列？&lt;/p&gt;
&lt;p&gt;（2）ArrayDeque是怎么实现双端队列的？&lt;/p&gt;
&lt;p&gt;（3）ArrayDeque是线程安全的吗？&lt;/p&gt;
&lt;p&gt;（4）ArrayDeque是有界的吗？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;双端队列是一种特殊的队列，它的两端都可以进出元素，故而得名双端队列。&lt;/p&gt;
&lt;p&gt;ArrayDeque是一种以数组方式实现的双端队列，它是非线程安全的。&lt;/p&gt;
&lt;h2 id=&quot;继承体系&quot;&gt;继承体系&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/ArrayDeque.png&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过继承体系可以看，ArrayDeque实现了Deque接口，Deque接口继承自Queue接口，它是对Queue的一种增强。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public interface Deque&amp;lt;E&amp;gt; extends Queue&amp;lt;E&amp;gt; {
    // 添加元素到队列头
    void addFirst(E e);
    // 添加元素到队列尾
    void addLast(E e);
    // 添加元素到队列头
    boolean offerFirst(E e);
    // 添加元素到队列尾
    boolean offerLast(E e);
    // 从队列头移除元素
    E removeFirst();
    // 从队列尾移除元素
    E removeLast();
    // 从队列头移除元素
    E pollFirst();
    // 从队列尾移除元素
    E pollLast();
    // 查看队列头元素
    E getFirst();
    // 查看队列尾元素
    E getLast();
    // 查看队列头元素
    E peekFirst();
    // 查看队列尾元素
    E peekLast();
    // 从队列头向后遍历移除指定元素
    boolean removeFirstOccurrence(Object o);
    // 从队列尾向前遍历移除指定元素
    boolean removeLastOccurrence(Object o);

    // *** 队列中的方法 ***
    
    // 添加元素，等于addLast(e)
    boolean add(E e);
     // 添加元素，等于offerLast(e)
    boolean offer(E e);
    // 移除元素，等于removeFirst()
    E remove();
    // 移除元素，等于pollFirst()
    E poll();
    // 查看元素，等于getFirst()
    E element();
    // 查看元素，等于peekFirst()
    E peek();

    // *** 栈方法 ***

    // 入栈，等于addFirst(e)
    void push(E e);
    // 出栈，等于removeFirst()
    E pop();

    // *** Collection中的方法 ***
    
    // 删除指定元素，等于removeFirstOccurrence(o)
    boolean remove(Object o);
    // 检查是否包含某个元素
    boolean contains(Object o);
    // 元素个数
    public int size();
    // 迭代器
    Iterator&amp;lt;E&amp;gt; iterator();
    // 反向迭代器
    Iterator&amp;lt;E&amp;gt; descendingIterator();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Deque中新增了以下几类方法：&lt;/p&gt;
&lt;p&gt;（1）*First，表示从队列头操作元素；&lt;/p&gt;
&lt;p&gt;（2）*Last，表示从队列尾操作元素；&lt;/p&gt;
&lt;p&gt;（3）push(e)，pop()，以栈的方式操作元素的方法；&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;h3 id=&quot;主要属性&quot;&gt;主要属性&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 存储元素的数组
transient Object[] elements; // non-private to simplify nested class access
// 队列头位置
transient int head;
// 队列尾位置
transient int tail;
// 最小初始容量
private static final int MIN_INITIAL_CAPACITY = 8;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从属性我们可以看到，ArrayDeque使用数组存储元素，并使用头尾指针标识队列的头和尾，其最小容量是8。&lt;/p&gt;
&lt;h3 id=&quot;主要构造方法&quot;&gt;主要构造方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 默认构造方法，初始容量为16
public ArrayDeque() {
    elements = new Object[16];
}
// 指定元素个数初始化
public ArrayDeque(int numElements) {
    allocateElements(numElements);
}
// 将集合c中的元素初始化到数组中
public ArrayDeque(Collection&amp;lt;? extends E&amp;gt; c) {
    allocateElements(c.size());
    addAll(c);
}
// 初始化数组
private void allocateElements(int numElements) {
    elements = new Object[calculateSize(numElements)];
}
// 计算容量，这段代码的逻辑是算出大于numElements的最接近的2的n次方且不小于8
// 比如，3算出来是8，9算出来是16，33算出来是64
private static int calculateSize(int numElements) {
    int initialCapacity = MIN_INITIAL_CAPACITY;
    // Find the best power of two to hold elements.
    // Tests &quot;&amp;lt;=&quot; because arrays aren't kept full.
    if (numElements &amp;gt;= initialCapacity) {
        initialCapacity = numElements;
        initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  1);
        initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  2);
        initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  4);
        initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  8);
        initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt; 16);
        initialCapacity++;

        if (initialCapacity &amp;lt; 0)   // Too many elements, must back off
            initialCapacity &amp;gt;&amp;gt;&amp;gt;= 1;// Good luck allocating 2 ^ 30 elements
    }
    return initialCapacity;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过构造方法，我们知道默认初始容量是16，最小容量是8。&lt;/p&gt;
&lt;h3 id=&quot;入队&quot;&gt;入队&lt;/h3&gt;
&lt;p&gt;入队有很多方法，我们这里主要分析两个，addFirst(e)和addLast(e)。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 从队列头入队
public void addFirst(E e) {
    // 不允许null元素
    if (e == null)
        throw new NullPointerException();
    // 将head指针减1并与数组长度减1取模
    // 这是为了防止数组到头了边界溢出
    // 如果到头了就从尾再向前
    // 相当于循环利用数组
    elements[head = (head - 1) &amp;amp; (elements.length - 1)] = e;
    // 如果头尾挨在一起了，就扩容
    // 扩容规则也很简单，直接两倍
    if (head == tail)
        doubleCapacity();
}
// 从队列尾入队
public void addLast(E e) {
    // 不允许null元素
    if (e == null)
        throw new NullPointerException();
    // 在尾指针的位置放入元素
    // 可以看到tail指针指向的是队列最后一个元素的下一个位置
    elements[tail] = e;
    // tail指针加1，如果到数组尾了就从头开始
    if ( (tail = (tail + 1) &amp;amp; (elements.length - 1)) == head)
        doubleCapacity();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）入队有两种方式，从队列头或者从队列尾；&lt;/p&gt;
&lt;p&gt;（2）如果容量不够了，直接扩大为两倍；&lt;/p&gt;
&lt;p&gt;（3）通过取模的方式让头尾指针在数组范围内循环；&lt;/p&gt;
&lt;p&gt;（4）x &amp;amp; (len - 1) = x % len，使用&amp;amp;的方式更快；&lt;/p&gt;
&lt;h3 id=&quot;扩容&quot;&gt;扩容&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void doubleCapacity() {
    assert head == tail;
    // 头指针的位置
    int p = head;
    // 旧数组长度
    int n = elements.length;
    // 头指针离数组尾的距离
    int r = n - p; // number of elements to the right of p
    // 新长度为旧长度的两倍
    int newCapacity = n &amp;lt;&amp;lt; 1;
    // 判断是否溢出
    if (newCapacity &amp;lt; 0)
        throw new IllegalStateException(&quot;Sorry, deque too big&quot;);
    // 新建新数组
    Object[] a = new Object[newCapacity];
    // 将旧数组head之后的元素拷贝到新数组中
    System.arraycopy(elements, p, a, 0, r);
    // 将旧数组下标0到head之间的元素拷贝到新数组中
    System.arraycopy(elements, 0, a, r, p);
    // 赋值为新数组
    elements = a;
    // head指向0，tail指向旧数组长度表示的位置
    head = 0;
    tail = n;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扩容这里迁移元素可能有点绕，请看下面这张图来理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/array-deque1.png&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;出队&quot;&gt;出队&lt;/h3&gt;
&lt;p&gt;出队同样有很多方法，我们主要看两个，pollFirst()和pollLast()。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 从队列头出队
public E pollFirst() {
    int h = head;
    @SuppressWarnings(&quot;unchecked&quot;)
    // 取队列头元素
    E result = (E) elements[h];
    // 如果队列为空，就返回null
    if (result == null)
        return null;
    // 将队列头置为空
    elements[h] = null;     // Must null out slot
    // 队列头指针右移一位
    head = (h + 1) &amp;amp; (elements.length - 1);
    // 返回取得的元素
    return result;
}
// 从队列尾出队
public E pollLast() {
    // 尾指针左移一位
    int t = (tail - 1) &amp;amp; (elements.length - 1);
    @SuppressWarnings(&quot;unchecked&quot;)
    // 取当前尾指针处元素
    E result = (E) elements[t];
    // 如果队列为空返回null
    if (result == null)
        return null;
    // 将当前尾指针处置为空
    elements[t] = null;
    // tail指向新的尾指针处
    tail = t;
    // 返回取得的元素
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）出队有两种方式，从队列头或者从队列尾；&lt;/p&gt;
&lt;p&gt;（2）通过取模的方式让头尾指针在数组范围内循环；&lt;/p&gt;
&lt;p&gt;（3）出队之后没有缩容哈哈^^&lt;/p&gt;
&lt;h2 id=&quot;栈&quot;&gt;栈&lt;/h2&gt;
&lt;p&gt;前面我们介绍Deque的时候说过，Deque可以直接作为栈来使用，那么ArrayDeque是怎么实现的呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void push(E e) {
    addFirst(e);
}

public E pop() {
    return removeFirst();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是很简单，入栈出栈只要都操作队列头就可以了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）ArrayDeque是采用数组方式实现的双端队列；&lt;/p&gt;
&lt;p&gt;（2）ArrayDeque的出队入队是通过头尾指针循环利用数组实现的；&lt;/p&gt;
&lt;p&gt;（3）ArrayDeque容量不足时是会扩容的，每次扩容容量增加一倍；&lt;/p&gt;
&lt;p&gt;（4）ArrayDeque可以直接作为栈使用；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;双端队列与双重队列？&lt;/p&gt;
&lt;p&gt;双端队列（Deque）是指队列的两端都可以进出元素的队列，里面存储的是实实在在的元素。&lt;/p&gt;
&lt;p&gt;双重队列（Dual Queue）是指一种队列有两种用途，里面的节点分为数据节点和非数据节点，它是LinkedTransferQueue使用的数据结构。&lt;/p&gt;
&lt;p&gt;还记得LinkedTransferQueue吗？点击链接直达【&lt;a href=&quot;https://mp.weixin.qq.com/s/OZ8tbFqvD9lWEgdvtJ5wog&quot;&gt;死磕 java集合之LinkedTransferQueue源码分析&lt;/a&gt;】。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Apr 2019 15:17:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>什么是双端队列？ ArrayDeque是怎么实现双端队列的？ ArrayDeque是线程安全的吗？ ArrayDeque是有界的吗？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/ArrayDeque.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第17期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10793008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10793008.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;.NET版本的Apache Spark&quot; &quot;Apache Spark预览版介绍&quot; &quot;F Apache Spark示例&quot; &quot;微软Build 2019大会(5月6日至8日)&quot; &quot;Rider用于F 的解决方案内的重命名&quot; &quot;Spark+AI峰会——开发智能云与智能边缘&quot; &quot;CNTK最新的重大发布—</description>
<pubDate>Mon, 29 Apr 2019 15:02:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 '.NET版本的Apache Spark' 'Apache Spark预览版介绍' 'F Apache Spark示例' '微软Build 2019大会(5月6日至8日)' 'Rider用于F </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10793008.html</dc:identifier>
</item>
<item>
<title>Java核心技术梳理-泛型 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10789988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10789988.html</guid>
<description>&lt;h2&gt;一、引言&lt;/h2&gt;
&lt;p&gt;在学习集合的时候我们会发现一个问题，将一个对象丢到集合中后，集合并不记住对象的类型，统统都当做Object处理，这样我们取出来再使用时就得强制转换类型，导致代码臃肿，而且加入集合时都是以Object，没做类型检查，那么强制转换就容易出错，泛型的诞生就是为解决这些问题。&lt;/p&gt;
&lt;h2&gt;二、&lt;span class=&quot;md-plain md-expand&quot;&gt;使用泛型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;泛型是如何解决这个问题呢？按照上面的问题，我们只需要在创建集合时指定集合元素的类型，那么集合就能记住对象的类型，那当我们加入是就只能按照指定的类型进行加入，而取出使用时也不需要强制转换：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ArrayList&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是Java 7之前的写法，很明显构造器上面的泛型没有必要，现在推荐以下写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ArrayList&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既然我已经指定了类型，那么添加时只能添加Integer，并且使用时可以直接当做Integer使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
System.out.println(list.get(2)+3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种参数化类型就是泛型，泛型就是允许在定义类、接口、方法时使用类型形参，这个参数形参将在申明变量、创建对象、调用方法时动态指定。&lt;/p&gt;
&lt;h2&gt;三、&lt;span class=&quot;md-plain md-expand&quot;&gt; 定义泛型接口、类&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;来看看List接口和Map接口的定义：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; List&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; Collection&amp;lt;E&amp;gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Map&amp;lt;K,V&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;List接口定义时指定了一个类型形参，Map接口定义了两个类型形参。接口定义了形参之后，在接口中形参就可以当做一种类型来使用，那么其中的方法就可以使用类型形参&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;boolean&lt;/span&gt; add(E e);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式其实也是一种代码复用，我们通过类型形参，高度的将参数抽象，而不需要每种类型都去重新定义类，只要在使用时确定类型即可。我们也可以自定义泛型类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebResult&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用T类型形参定义实例变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; T data;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WebResult() {
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用T类型形参构造对象&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; WebResult(T data) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setData(T data) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T getData() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        WebResult&lt;/span&gt;&amp;lt;String&amp;gt; webResult = &lt;span&gt;new&lt;/span&gt; WebResult&amp;lt;&amp;gt;(&quot;返回一个String对象&quot;&lt;span&gt;);
        System.out.println(webResult.getData());
        WebResult&lt;/span&gt;&amp;lt;Integer&amp;gt; webResult1 = &lt;span&gt;new&lt;/span&gt; WebResult&amp;lt;&amp;gt;(10&lt;span&gt;);
        System.out.println(webResult1.getData());
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四、&lt;span class=&quot;md-plain md-expand&quot;&gt;通配符&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;先看下面这段代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] str){
    ArrayList&lt;/span&gt;&amp;lt;String&amp;gt; arrayList=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
    test(arrayList);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(List&amp;lt;Object&amp;gt;&lt;span&gt; test){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;test.size() ; i++&lt;span&gt;) {
        System.out.println(test.get(i));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这段代码会出现编译错误，因为List&lt;span class=&quot;md-tag md-raw-inline&quot;&gt;&amp;lt;String&amp;gt;&lt;span class=&quot;md-plain&quot;&gt;对象不能作为List&lt;span class=&quot;md-tag md-raw-inline&quot;&gt;&amp;lt;Object&amp;gt;&lt;span class=&quot;md-plain&quot;&gt;使用，这说明&lt;span&gt;&lt;strong&gt;泛型&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;不是协变的，因为之前数组的设计是协变的，导致存在安全性问题，而泛型的设计原则是编译时不出现警告就不会出现类型转换错误，那为了表示各种泛型的父类，就引入了通配符：？这个问号代表可以是匹配任何类型。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;将方法修改：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(List&amp;lt;?&amp;gt;&lt;span&gt; test){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;test.size() ; i++&lt;span&gt;) {
        System.out.println(test.get(i));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样便可以顺利编译，我们再加上这段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] str){
    ArrayList&lt;/span&gt;&amp;lt;String&amp;gt; arrayList=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
    test(arrayList);
    List&lt;/span&gt;&amp;lt;?&amp;gt; strings =&lt;span&gt; arrayList;
    strings.add(&lt;/span&gt;&quot;abc&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们可以将arrayList给strings，按说这个时候是不能赋值的，因为List不知道类型参数的值，这是编译器作用，可以进行类型推理，但是后面的strings.add(&quot;abc&quot;)是不能通过编译的，编译器不能对 List 的类型参数作出足够严密的推理，以确定将 String 传递给 List.add() 是类型安全的。所以编译器将不允许这么做。&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;4.1 设置通配符上限&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt;List&amp;lt;?&amp;gt;这种方式，通配的是所有的类型，很多时候我们可以确定是哪一类对象可以添加进去，我们只希望它代表某一类泛型的父类，这个时候我们可以设置通配符的上限。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动物类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Animal {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cat &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say() {
        System.out.println(&lt;/span&gt;&quot;喵喵&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say() {
        System.out.println(&lt;/span&gt;&quot;旺旺&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候我们就限定了上限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test1(List&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Animal&amp;gt;&lt;span&gt; animals) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; animals.size(); i++&lt;span&gt;) {
        animals.get(i).say();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们也可以直接在定义类型形参的时候设置上限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebResult&amp;lt;T &lt;span&gt;extends&lt;/span&gt; Animal&amp;gt; {
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;4.2 通配符下限&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;既然有设置上限，那也有设置下限，那在什么情况下会使用下限呢？看个例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将src中的集合复制到dest，并返回最后一个值&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T copy(Collection&amp;lt;T&amp;gt; dest, Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt;&lt;span&gt; src) {
    T last &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (T ele : src) {
        last &lt;/span&gt;=&lt;span&gt; ele;
        dest.add(ele);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; last;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;功能比较很简单，将src中的集合复制到dest，并返回src最后一个值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
List&amp;lt;Number&amp;gt; ln = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
List&lt;/span&gt;&amp;lt;Integer&amp;gt; li = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译出错，类型不确定&lt;/span&gt;
Integer last = copy(ln, li);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候出错，因为虽然我们知道返回的值一定是Integer，但是由于copy方法的返回值并不是，所有相当于我们在复制的过程中丢失了src的类型，如果我们想定义约束关系使得返回值明确即：dest集合元素类型与src的关系要么相同要么是其父类，为了表示这种约束关系，引入了&amp;lt;? super T&amp;gt; 这个通配符表示它必须是T本身或者T的父类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将src中的集合复制到dest，并返回最后一个值&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T copy(Collection&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; dest, Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T&amp;gt;&lt;span&gt; src) {
    T last &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (T ele : src) {
        last &lt;/span&gt;=&lt;span&gt; ele;
        dest.add(ele);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; last;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、&lt;span class=&quot;md-plain md-expand&quot;&gt;泛型方法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;除了泛型接口和泛型类，我们还可以定义泛型方法，写法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;void&lt;/span&gt; arrayToList(T[] a, List&amp;lt;T&amp;gt;&lt;span&gt; list) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (T o : a) {
        list.add(o);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
Object[] objects = &lt;span&gt;new&lt;/span&gt; Object[10&lt;span&gt;];
List&lt;/span&gt;&amp;lt;Object&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
arrayToList(objects, list);

Integer[] integers &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Integer[10&lt;span&gt;];
List&lt;/span&gt;&amp;lt;Integer&amp;gt; integerList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
arrayToList(integers, integerList);

String[] strings &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; String[10&lt;span&gt;];
List&lt;/span&gt;&amp;lt;String&amp;gt; stringList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
arrayToList(strings, stringList);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译错误，类型不正确&lt;/span&gt;
arrayToList(strings, integerList);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这里可以看出泛型方法跟类型通配符的功能有点类似，其实在大部分情况下我们可以用泛型方法代替类型通配符。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;泛型方法允许类型形参被用来表示方法的一个或者多个参数之间的依赖关系，或者说与返回值之间的关系，如果没有这种关系，我们就不使用泛型方法。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;六、&lt;/span&gt;&lt;span class=&quot;md-plain&quot;&gt;擦除与转换&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;当把一个具有泛型信息的对象赋给一个没有泛型信息的变量时，所有的类型信息就都丢掉了，比如List&lt;span class=&quot;md-tag md-raw-inline&quot;&gt;&amp;lt;String&amp;gt;&lt;span class=&quot;md-plain&quot;&gt;类型被转换成List,则对该List的类型检查也变成了Object。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WebResult&amp;lt;T &lt;span&gt;extends&lt;/span&gt; Number&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用T类型形参定义实例变量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; T data;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WebResult() {
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用T类型形参构造对象&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; WebResult(T data) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setData(T data) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T getData() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        WebResult&lt;/span&gt;&amp;lt;Integer&amp;gt; webResult1 = &lt;span&gt;new&lt;/span&gt; WebResult&amp;lt;&amp;gt;(10&lt;span&gt;);
        System.out.println(webResult1.getData());
        WebResult&lt;/span&gt;&amp;lt;Integer&amp;gt; a = &lt;span&gt;new&lt;/span&gt; WebResult&amp;lt;&amp;gt;(20&lt;span&gt;);
        WebResult b &lt;/span&gt;=&lt;span&gt; a;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经擦除了泛型，只能按最高类型Object
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Integer bData = b.getData();&lt;/span&gt;
        Object object=&lt;span&gt;b.getData();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;原本的泛型类上限是Number，而当把a赋给擦除泛型的b对象时，编译器失去了推断能力，只能把其当做Objec来处理。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;而当一个List转成泛型对象是java是允许的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
List&amp;lt;Integer&amp;gt; integerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
List stringList &lt;/span&gt;=&lt;span&gt; integerList;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许直接将list对象转换给&lt;/span&gt;
List&amp;lt;String&amp;gt; strings =&lt;span&gt; stringList;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接获取数据会出现错误，因为转换不成功&lt;/span&gt;
System.out.println(stringList.get(0));
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 29 Apr 2019 14:29:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 在学习集合的时候我们会发现一个问题，将一个对象丢到集合中后，集合并不记住对象的类型，统统都当做Object处理，这样我们取出来再使用时就得强制转换类型，导致代码臃肿，而且加入集合时都是以Ob</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10789988.html</dc:identifier>
</item>
<item>
<title>Java线程机制学习 - 木瓜芒果</title>
<link>http://www.cnblogs.com/volcano-liu/p/10765247.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/volcano-liu/p/10765247.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;前面的文章中总结过Java中用来解决共享资源竞争导致线程不安全的几种常用方式：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;synchronized；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ReentrantLock；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ThreadLocal；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;这些都是在简单介绍了基本用法的基础上再侧重于对底层原理的探讨，由于这些知识点涉及到方方面面，短时间之内完全弄懂并非易事。而写博客的初衷其实是驱动自己在学习的过程中及时总结，用自己的语言再将所学复述一遍以强化对知识的理解程度。所以在这篇文章里，我会从Java中最基本的一些并发概念开始，到Java的基本线程机制，梳理一个相对完整的基础知识脉络，尽量让知识形成体系。所谓勿以浮沙筑高台，如是说。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本文会从如下几个方面来阐述：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10765247.html#a&quot;&gt;&lt;span&gt;　　关于并发&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10765247.html#b&quot;&gt;&lt;span&gt;　　基本线程机制&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10765247.html#c&quot;&gt;&lt;span&gt;　　线程状态&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10765247.html#d&quot;&gt;&lt;span&gt;　　线程常用方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10765247.html#e&quot;&gt;&lt;span&gt;　　线程中断&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10765247.html#f&quot;&gt;&lt;span&gt;　　终止线程&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/volcano-liu/p/10765247.html#g&quot;&gt;&lt;span&gt;　　总结&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;1. 关于并发&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;虽然编程问题中相当大的一部分都可以通过使用顺序编程来解决，但是由于cpu的运算速度比计算机系统中存储及通信等子系统的速度要快几个量级，相对而言在计算过程中，大部分时间会花费在磁盘I/O、网络通信上面，这样处理器在大部分时间里面就都需要等待其他资源，为了不浪费处理器的强大计算能力，让计算机“同时”处理几项任务则是简单而有效的一个“压榨”手段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　除了充分利用cpu的计算能力，在后端开发中，服务端往往也需要同时对多个客户端提供服务，这是一个更具体的并发应用场景。衡量一个服务性能的好坏，每秒事物处理数(Transactions Per Second，TPS)是一个重要指标，代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系，程序并发协调得越有条不紊，效率自然越高；反之，线程之间频繁阻塞甚至死锁，则会大大降低程序的并发能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Java支持多线程编程，而且服务端是其最擅长的领域之一，不过对于如何写好并发应用程序却又是服务端开发的难点之一。学习并发编程就像进入了一个全新的领域，如果你花点儿工夫，就能明白其基本机制，但要想真正地掌握它的实质，就需要深入的学习和理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　说到并发，需要和并行进行区别：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;所谓并发，其实是按顺序执行的，cpu在任一时间只执行一个线程，通过给不同线程分配时间段的形式来进行调度，只是看起来好像多个任务是同时执行的；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;并行，就是多个任务同时在进行着的；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. 基本线程机制&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;并发编程使我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务(也被称为子任务)中的每一个都将通过执行线程来驱动。一个线程就是在进程中的一个单一的顺序控制流，单个进程可以拥有多个并发执行的任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　线程模型为编程带来了便利，它简化了在单一程序中同时交织在一起的多个操作的处理。在使用线程时，CPU将轮流给每个任务分配其占用的时间。每个任务都觉得自己在一直占用CPU，但事实上CPU时间是划分成片段分配给了所有的任务(例外情况是程序确实运行在多个CPU之上)。线程的一大好处是可以使你从这个层次抽身出来，即代码不必知道它是运行在具有一个还是多个CPU的机器上，所以，使用线程机制是一种建立透明的、可扩展的程序的方法。多任务和多线程往往是使用多处理器系统的最合理方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在JDK1.2之后，Java中的线程模型是基于操作系统原生线程模型来实现，但这和Java程序的编码来说是没有影响的。因为Java语言提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行start()且还未结束的java.lang.Thread类的实例就代表了一个线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们可以通过三种传统的方式来通过线程驱动任务：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-source-line=&quot;8&quot;&gt;&lt;li&gt;&lt;span&gt;new一个Thread类，并重写run方法(也可以通过匿名类的方式)；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;实现Runnable接口，传入Thread的构造器中；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;直接在main函数中new一个实现了Runnable接口的类，实例化，直接调用其run方法，其实是由main线程来驱动的； &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　通过一个例子来体会一下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefineRunnable {
    &lt;br/&gt;　　 // 获取一个线程唯一标识
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicInteger a = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicInteger();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getThreadId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.getAndIncrement();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 驱动任务，方式1，通过重写Thread中run方法，直接由Thread类驱动&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(&lt;/span&gt;&quot;lightsOff ! doing-Thread: &quot; +&lt;span&gt; DefineRunnable.getThreadId());
            }
        }.start();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 驱动任务，方式2，通过将实现了Runnable的类作为构造参数传入Thread的构造器中，通过Thread类来驱动&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightsOff()).start();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 驱动任务，方式3，通过主线程直接驱动Runnable任务&lt;/span&gt;
        LightsOff lightsOff = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightsOff();
        lightsOff.run();
    }
    
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; LightsOff &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        System.out.println(&lt;/span&gt;&quot;lightsOff ! doing-Thread: &quot; +&lt;span&gt; DefineRunnable.getThreadId());
    }
    
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 输出
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
lightsOff &lt;/span&gt;! doing-Thread: 0&lt;span&gt;
lightsOff &lt;/span&gt;! doing-Thread: 1&lt;span&gt;
lightsOff &lt;/span&gt;! doing-Thread: 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;如上是一些基本的驱动任务的方式，当然还有更好的方式，通过交给线程池处理，这在后面会专门撰文详述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　调用Thread对象的start()方法为线程执行必需的初始化操作，然后会自动去调用Runnable的run()方法。调用start()方法之后会迅速返回，即使run()方法没有执行完，这是因为run()是由不同的线程执行的，你仍旧可以执行main中的其他后续操作，程序会同时执行多个方法，main()和多个Runnable中的run()方法。这一点可能会让初次接触线程Thread这一概念的同学觉得莫名困惑，至少我当年就困惑过。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当我们将任务交给线程来驱动之后，任务是否被执行则要取决于线程调度器的调度了。虽然Java的线程调度是由系统自动完成的，但我们还是可以“建议”系统给某些线程多分配一点执行时间或少一点，这项操作可以通过设置线程优先级来完成。Java中一共设置了10个线程优先级(Thread.MIN_PRIORITY至Thread.MAX_PRIORITY)，在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是，线程优先级并不是很靠谱，前面也说到过，Java的线程是通过映射到操作系统的原生线程上来实现的，所以线程调度最终取决于操作系统，不同操作系统的优先级概念是不同的。所以，我们不能在程序中通过优先级来完全准确地判断一组状态都为Ready的线程将会先执行哪一个。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3. 线程状态&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;Java语言定义了5种线程状态，在任一时间点，一个线程只能有且只有其中的一种状态，分别是新建、运行、等待、阻塞、结束。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.1 新建(New)&lt;/h3&gt;
&lt;p&gt;  &lt;span&gt;创建后尚未启动的线程就处于这种状态。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.2 运行(Runable)&lt;/h3&gt;
&lt;p&gt;  &lt;span&gt;Runable包括了操作系统线程状态中的 Running和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.3 无限期等待(Waiting)&lt;/h3&gt;
&lt;p&gt;  &lt;span&gt;处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;没有设置 Timeout参数的Object.wait()方法；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;没有设置 Timeout参数的Thread.join()方法；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;LockSupport park()方法；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3.4 有限期等待(Timed Waiting)&lt;/h3&gt;
&lt;p&gt; &lt;span&gt; 处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒,在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Thread.sleep()方法；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;设置了Timeout参数的Object.wait()方法；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;设置了Timeout参数的Thread.join()方法；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;LockSupport.parkNanos()方法；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;LockSupport.parkUntil()方法；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3.5 阻塞(Blocked)&lt;/h3&gt;
&lt;p&gt;  &lt;span&gt;线程被阻塞了，“阻塞状态”在等待着获取到一个排他锁(synchronized中获取的monitor)，这个事件将在另外一个线程放弃这个锁的时候发生，在程序等待进入同步区域的时候，线程将进入这种状态。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.6 结束(Terminated)&lt;/h3&gt;
&lt;p&gt;  &lt;span&gt;已终止线程的线程状态，线程已经结束执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上述5种状态在遇到特定事件发生的时候会互相转换，他们的转换关系如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1335887/201904/1335887-20190427172638715-790500578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4. 线程常用方法&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;在线程运行的过程中，我们需要通过各种方式来操纵线程(比如暂停，中断线程)或者协调多个线程(比如通知别的线程)。常用的方式有sleep、join、yield、wait、notify/notifyAll。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;休眠sleep&quot; data-source-line=&quot;61&quot;&gt;4.1 休眠(sleep)&lt;/h3&gt;
&lt;p data-source-line=&quot;62&quot;&gt;&lt;span&gt;　　调用某个线程的sleep()方法可以使其休眠给定的时间。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;62&quot;&gt;&lt;span&gt;　　sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。而join()方法会释放&quot;锁标志&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;加入一个线程join&quot; data-source-line=&quot;75&quot;&gt;4.2 加入一个线程(join)&lt;/h3&gt;
&lt;p data-source-line=&quot;76&quot;&gt;  &lt;span&gt;一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第另一个线程结束才继续执行。如果线程A在另一个线程B上调用B.join()，则线程A将被挂起，直到目标线程B结束才恢复(即B.isAlive()返回为假)。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;78&quot;&gt;&lt;span&gt;  也可以在调用join()时带上一个超时参数(单位可以是毫秒，或者毫秒和纳秒)，这样如果目标线程在这段时间到期时还没有结束的话， join方法总能返回。对join()方法的调用可以被中断，做法是在调用线程上调用interrupt方法，这时需要用到try- -catch子句，与sleep类似。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Sleeper &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; duration;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Sleeper(String name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sleepTime){
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
        duration &lt;/span&gt;=&lt;span&gt; sleepTime;
        start();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            sleep(duration);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){
            System.out.println(getName() &lt;/span&gt;+ &quot; was interrupted. &quot; + &quot;isInterrupted(): &quot; +&lt;span&gt; isInterrupted());
        }
        System.out.println(getName() &lt;/span&gt;+ &quot; has awakened&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Joiner &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Sleeper sleeper;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Joiner(String name,Sleeper sleeper){
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(name);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sleeper =&lt;span&gt; sleeper;
        start();
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            sleeper.join();
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){
            System.out.println(&lt;/span&gt;&quot;Interrupted&quot;&lt;span&gt;);
        }
        System.out.println(getName() &lt;/span&gt;+ &quot; join completed&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Joining{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        Sleeper sleepy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Sleeper(&quot;Sleepy&quot;,1500&lt;span&gt;);
        Sleeper grumpy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Sleeper(&quot;Grumpy&quot;,1500&lt;span&gt;);
        Joiner dopey &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Joiner(&quot;Dopey&quot;&lt;span&gt;,sleepy);
        Joiner doc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Joiner(&quot;Doc&quot;&lt;span&gt;,grumpy);
        grumpy.interrupt();
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 输出结果
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Grumpywas interrupted. isInterrupted(): &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
Grumpy has awakened
Doc join completed
Sleepy has awakened
Dopey join completed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;73&quot;&gt;　&lt;span&gt;　在上面的demo中，主线程会启动4个子线程，分别是sleepy、grumpy、doc、dopey。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li data-source-line=&quot;73&quot;&gt;&lt;span&gt;sleepy和grumpy启动之后会进入休眠状态，doc和dopey启动之后会调用相应sleep和grumpy的join方法，意味着要等sleepy执行完才会再执行dopey，doc也一样；&lt;/span&gt;&lt;/li&gt;
&lt;li data-source-line=&quot;73&quot;&gt;&lt;span&gt;这时主线程调用grumpy的interrupt()方法，因为grumpy处于休眠状态所以抛出InterruptedException异常&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;让步yield&quot; data-source-line=&quot;72&quot;&gt;4.3 让步(yield)&lt;/h3&gt;
&lt;p data-source-line=&quot;73&quot;&gt; &lt;span&gt; 这是Thread类的一个静态方法，当在线程中调用这个方法之后，当前线程将放弃cpu使用，进入ready状态，等待系统重新调度，有可能会重新进入running状态也有可能不会，相当于给其他线程一个机会了。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;73&quot;&gt;&lt;span&gt;　　如果知道已经完成了在run()方法的循环的一次迭代过程中所需的工作，就可以给线程调度机制一个暗示：你的工作已经做得差不多了，可以让别的线程使用CPU了。这个暗示将通过调用 yield方法来作出(不过这只是一个暗示，没有任何机制保证它将会被采纳)。当调用yield()时，你也是在建议具有相同优先级的其他线程可以运行。所以，对于任何重要的控制或在调整应用时，都不能依赖于yield()。&lt;/span&gt;&lt;/p&gt;
&lt;h3 data-source-line=&quot;73&quot;&gt;&lt;span&gt;4.4 wait、notify/notifyAll&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　这三个方法比较特殊，它们不属于Thread类，而是定义在Object中的，虽然不在Thread中，但是又和线程相关。这三个方法的调用方式是通过同步对象锁来调用的，而且必须在同步块中调用。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;wait表示阻塞，调用此方法时当前线程会阻塞，同时释放对象锁；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;notify、notifyAll表示通知，调用该方法之后会释放一个或多个因等待同步锁而阻塞的线程，被释放的线程会去竞争同步锁(synchronized)，获取锁了才会继续执行，否则还是处于阻塞状态；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; String content;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; String LOCK = &quot;lock&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(){
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
                &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(LOCK){
                    content &lt;/span&gt;= &quot;hello world&quot;&lt;span&gt;;
                    LOCK.notifyAll();
                }
            } 
        }.start();

        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;(LOCK){
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(content == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    LOCK.wait();
                }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){
                    e.printStackTrace();
                }
                System.out.println(content.toUpperCase());
            }
        }
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出&lt;/span&gt;
HELLO WORLD
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;如上面的例子中所示，主线程会启动一个子线程，主线程会判断成员变量content为null时则调用LOCK的wait进入无限等待，然后释放同步锁，子线程获取到锁之后，给content赋值，然后通过调用LOCK的notifyAll()来通知主线程，使得主线程可以解除等待状态，进入到阻塞状态，当子线程执行完毕之后会释放锁，这时主线会获取锁然后继续执行，输出大写的hello world。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;5. 线程中断&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;线程中断仅仅是置线程的中断状态位，并不会停止线程(至于如何停止，本文后面会详述)。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，比如sleep、join等，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常，并且将中断标志重新置为false。所以在Java中设置线程的中断状态位并不会产生对线程运行的实际影响，而是通过监视线程的状态位并做相应处理，或者通过抛出中断异常(InterruptedException)来通知用户进行处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　和线程中断状态位有直接关系的方法主要有：interrupt()、interrupted()、isInterrupted()，其使用介绍如下：&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;interrupt&quot; data-source-line=&quot;1&quot;&gt;5.1 interrupt()&lt;/h3&gt;
&lt;p data-source-line=&quot;2&quot;&gt;　　&lt;span&gt;interrupt()是Thread的实例方法，用于中断线程。调用该方法的线程的状态为将被置为&quot;中断&quot;状态。 &lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;interrupted&quot; data-source-line=&quot;5&quot;&gt;5.2 interrupted()&lt;/h3&gt;
&lt;p data-source-line=&quot;6&quot;&gt;  &lt;span&gt;interrupted()方法为Thread的静态方法，该方法就是直接调用当前线程的isInterrupted(true)的方法，是作用于当前线程，并且会重置当前线程的中断状态。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; interrupted(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; currentThread().isInterrupted(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;isinterrupted&quot; data-source-line=&quot;12&quot;&gt;5.3 isInterrupted()&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;isInterrupted()方法是Thread的实例方法，是作用于调用该方法的线程对象所对应的线程，是直接调用对应线程的isInterrupted(false)的方法,不会重置对应线程的中断状态。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isInterrupted () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; isInterrupted( &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　为了更清楚其中的区别，我自己写了一个例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterruptTest {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Thread threadA &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LightsOff());
        threadA.start();

        System.out.println(&lt;/span&gt;&quot;ThreadA isInterruptd --&amp;gt; &quot; +&lt;span&gt; threadA.isInterrupted());
        Thread.sleep(&lt;/span&gt;500&lt;span&gt;);
        threadA.interrupt();
    
        System.out.println(&lt;/span&gt;&quot;ThreadA isInterruptd --&amp;gt; &quot; +&lt;span&gt; threadA.isInterrupted());
        Thread.sleep(&lt;/span&gt;100&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;ThreadA isInterruptd --&amp;gt; &quot; +&lt;span&gt; threadA.isInterrupted());
        
    }
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LightsOff &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            System.out.println(&lt;/span&gt;&quot;ThreadA start&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;Thread.currentThread().isInterrupted()) {
                
            }
            System.out.println(&lt;/span&gt;&quot;ThreadA continue&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;threadA is interrupted? --&amp;gt; &quot; +&lt;span&gt; Thread.interrupted());            
        }        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;输出结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ThreadA isInterruptd --&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
ThreadA start
ThreadA &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
ThreadA isInterruptd &lt;/span&gt;--&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
threadA is interrupted&lt;/span&gt;? --&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
ThreadA isInterruptd &lt;/span&gt;--&amp;gt; &lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　我们看一下整个过程：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;首先主线程启动线程A；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;主线程这时候通过实例对象threadA的isInterrupted()获取线程A的中断状态标志位，此时为默认的false；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;主线程休眠500ms；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;线程A启动后输出ThreadA start，然后进入while循环，只要线程的中断标志位为false，则一直循环；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;主线程休眠结束后，调用threadA的interrupted方法，设置线程A的中断状态标志位为true，此时主线程获取线程A的中断标志位为true；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;线程A跳出循环，输出Thread continue，然后调用线程的静态方法interrrupted，返回true，并且将线程A的中断标志复原为false；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;主线程休眠100ms，确保线程A已经调用了interrupted方法，此时获取到线程A的中断标志位为false； &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;6. 终止线程&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;当调用线程的start方法之后，线程会开始驱动任务，当任务执行完毕之后(也就是run方法执行结束)线程将终止，但是如果因为线程阻塞或者线程长时间执行而不能结束，所以我们希望能够通过某种途径可以终止线程以达到想要的效果，常用的方式有两种：中断、检查中断。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;中断&quot; data-source-line=&quot;27&quot;&gt;6.1 中断&lt;/h3&gt;
&lt;p data-source-line=&quot;30&quot;&gt;&lt;span&gt;  Thread类包含interrupt()方法，因此你可以终止被阻塞的任务，这个方法将设置线程的中断状态。如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将导致线程抛出InterruptedException。当抛出该异常或者该任务调用Thread.interrupted()时，中断状态将被复位。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;30&quot;&gt;&lt;span&gt;　　因为这种方式是在任务的run()方法中间打断，更像是抛出的异常，所以在Java线程的中断中用到了异常。而为了在以这种方式终止任务时，返回众所周知的良好状态，必须仔细考虑代码的执行路径，并仔细编写catch子句以正确清除所有事物。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;如何调用interrupt&quot; data-source-line=&quot;32&quot;&gt;　　&lt;span&gt;如何调用interrupt？&lt;/span&gt;&lt;/p&gt;
&lt;ul data-source-line=&quot;33&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;为了调用interrupt()，你必须持有Thread对象。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果你在Executor上调用shutdownNow()，那么它将发送一个interrupt()调用给它启动的所有线程。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;如果希望只中断某个单一任务，那么可以通过调用submit()而不是executor()来启动任务，就可以持有该任务的上下文。submit()将返回一个泛型Future&amp;lt;?&amp;gt;，持有这种Future的关键在于你可以在其上调用cancel()，并因此可以使用它来中断某个特定任务。如果你将true传递给cancel()，那么它就会拥有在该线程上调用interrupt()以停止这个线程的权限，因此，cancel()是一种中断由Executor启动的单个线程的方式。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;47&quot;&gt;&lt;span&gt;　　对于互斥导致阻塞的中断：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-source-line=&quot;49&quot;&gt;&lt;li&gt;&lt;span&gt;在ReentrantLock上阻塞的任务具备可以被中断的能力(即interrupt()可以打断被ReentrantLock互斥所阻塞的调用)，而在synchronized方法或临界区上阻塞的任务则不能被中断；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不能中断正在试图获取synchronized锁或者试图执行I/O操作的线程；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;检查中断&quot; data-source-line=&quot;51&quot;&gt;6.2 检查中断&lt;/h3&gt;
&lt;p data-source-line=&quot;53&quot;&gt;  &lt;span&gt;当你在线程上调用interrupt()时，中断发生的唯一时刻是在任务要进入到阻塞操作中，或者已经在阻塞操作内部时。但是如果根据程序运行的环境，你已经编写了可能会产生这种阻塞调用的代码，那又该怎么办呢?如果你只能通过在阻塞调用上抛出异常来退出，那么你就无法总是可以离开run()循环。因为如果你调用interrupt()以停止某个任务，那么在run循环碰巧没有产生任何阻塞调用的情况下这种方式就不起作用了，需要另一种方式来退出。Thread.interrupted()提供了离开run()循环而不抛出异常的第二种方式。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;55&quot;&gt;&lt;span&gt;  这种机会是由中断状态来表示的，其状态可以通过调用interrupt()来设置。你可以通过调用interrupted()来检查中断状态，这不仅可以告诉你interrupt()是否被调用过，而且还可以清除中断状态。清除中断状态可以确保并发结构不会就某个任务被中断这个问题通知你两次，你可以经由单一的InterruptedException或单一的成功的Thread.interrupted()测试来得到这种通知。如果想要再次检查以了解是否被中断，则可以在调用Thread.interrupted()时将结果存储起来。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;57&quot;&gt;&lt;span&gt;  下面的示例展示了典型的惯用法，你应该在run()方法中使用它来处理在中断状态被设置时，被阻塞和不被阻塞的各种可能：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; NeedsCleanup{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; NeedsCleanup(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ident){
        id &lt;/span&gt;=&lt;span&gt; ident;
        System.out.println(&lt;/span&gt;&quot;NeedsCleanup &quot; +&lt;span&gt; id);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cleanup(){
        System.out.println(&lt;/span&gt;&quot;Cleaning up &quot; +&lt;span&gt; id);
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Blocked &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; d = 0.0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{&lt;br/&gt;　　　　　　　// 第2中方式，检查中断的方式
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;Thread.interrupted()){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; point1&lt;/span&gt;
                NeedsCleanup n1 = &lt;span&gt;new&lt;/span&gt; NeedsCleanup(1&lt;span&gt;);&lt;/span&gt;
                &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    System.out.println(&lt;/span&gt;&quot;Sleeping&quot;&lt;span&gt;);
                    TimeUnit.SECONDS.sleep(&lt;/span&gt;1&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; point2&lt;/span&gt;
                    NeedsCleanup n2 = &lt;span&gt;new&lt;/span&gt; NeedsCleanup(2&lt;span&gt;);&lt;/span&gt;
                    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                        System.out.println(&lt;/span&gt;&quot;Calculating&quot;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 复杂浮点运算，耗时但是不会导致阻塞&lt;/span&gt;
                        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 1; i&amp;lt;2500000; i++&lt;span&gt;)
                            d &lt;/span&gt;= d + (Math.PI + Math.E)/&lt;span&gt;d;
                        System.out.println(&lt;/span&gt;&quot;Finished time-consuming operation&quot;&lt;span&gt;);
                    }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{&lt;br/&gt;　　　　　　　　　　　　　　 // 保证即使被中断结束了， 依然能够完成n2清理工作
                        n2.cleanup();
                    }
                }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{&lt;br/&gt;　　　　　　　　　　　　// 保证即使被中断结束了，依然能够完成n1的清理工作
                    n1.cleanup();
                }
            }
            System.out.println(&lt;/span&gt;&quot;Exiting via while() test&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){
            System.out.println(&lt;/span&gt;&quot;Exiting via InterruptedException&quot;&lt;span&gt;);
        }    
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterruptingIdiom{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(args.length != 1&lt;span&gt;){
            System.out.println(&lt;/span&gt;&quot;usage: java InterruptingIdiom delay-in-mS&quot;&lt;span&gt;);
            System.exit(&lt;/span&gt;1&lt;span&gt;);
        }
        Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Blocked());
        t.start();
        TimeUnit.MILLISECONDS.sleep(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Integer(args[0&lt;span&gt;]));&lt;br/&gt;　　　　　// 第1中方式，直接中断
        t.interrupt();
    }
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 输出
NeedsCleanup 1
Sleeping
NeedsCleanup 2
Calculating
Finished time-consuming operation
Cleaning up 2
Cleaning up 1
NeedsCleanup 1
Sleeping
Cleaning up 1
Exiting via InterruptedException
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;如上演示了两种中断线程的方法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在主线程中，经过一段时间的休眠之后，调用线程t的interrupt()方法将其中断，此为&lt;strong&gt;中断&lt;/strong&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在线程t的run()方法中，将所有逻辑都放在一个while循环中，判断条间就是Thread.isInterrupted()的返回值，即使线程t没有进入阻塞状态，但是每一次循环都会检查中断状态，一旦发现中断状态被设置则会退出循环，此为&lt;strong&gt;检查中断&lt;/strong&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;7. 总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;关于并发，是为了充分利用cpu的计算能力而产生的；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Java中的多线程机制是将程序划分为多个分离的、独立的运行任务，每个任务靠单独线程来驱动；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Java中对线程定义了5种状态：新建、运行、等待、阻塞、结束；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;线程常用到的方法：sleep、join、yield、wait、notify/notifyAll；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;线程中断：interrupt()、interrupted()、isInterrupted()；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;终止线程有2种常用的方式：中断、检查中断；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; 　　本文重点在最基础的Java线程机制，虽然这部分比较基础，也正是因为如此，往往容易被忽视。但是基础不代表不重要，本文的很多概念还是费了一点时间来搞懂的，如果有不对的地方还请指正，如果你觉得对你有帮助的话，请点个赞吧 ^_^ ！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Apr 2019 12:50:00 +0000</pubDate>
<dc:creator>木瓜芒果</dc:creator>
<og:description>Java线程机制的一些整理总结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/volcano-liu/p/10765247.html</dc:identifier>
</item>
<item>
<title>C#以太坊基础入门 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/10744950.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/10744950.html</guid>
<description>&lt;p&gt;在这一部分，我们将使用C#开发一个最简单的.Net控制台应用，来接入以太坊节点，并打印 所连接节点旳版本信息。通过这一部分的学习，你将掌握以下技能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何使用节点仿真器&lt;/li&gt;
&lt;li&gt;如何在命令行访问以太坊节点&lt;/li&gt;
&lt;li&gt;如何在C#代码中访问以太坊节点&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们将使用ganache来模拟以太坊节点。ganache虽然不是一个真正的以太坊节点软件， 但它完整实现了以太坊的JSON RPC接口，非常适合以太坊智能合约与去中心化应用开发的 学习与快速验证：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421134027636-1525710058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ganache启动后将在8545端口监听http请求，因此，我们会将JSON RPC调用请求 使用http协议发送到节点旳8545端口。不同的节点软件可能会使用不同的监听端口，但 大部分节点软件通常默认使用8545端口。&lt;/p&gt;
&lt;p&gt;以太坊规定了节点必须实现web3_clientVersion 调用来返回节点软件的版本信息，因此我们可以用这个命令来测试与 节点旳链接是否成功。&lt;/p&gt;
&lt;p&gt;ganache-cli是以太坊节点仿真器软件ganache的命令行版本，可以方便开发者快速进行 以太坊DApp的开发与测试。在windows下你也可以使用其GUI版本。启动ganache很简单，只需要在命令行执行ganache-cli即可：ganache-cli是一个完整的词，-两边是没有空格的。一切顺利的话，你会看到与下图类似的屏幕输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421134200849-1530720460.png&quot; alt=&quot;&quot; width=&quot;544&quot; height=&quot;412&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，ganache会随机创建10个账户，每个账户中都有100ETH的余额。你可以在 命令行中指定一些参数来调整这一默认行为。例如使用&lt;code&gt;-a&lt;/code&gt;或&lt;code&gt;--acounts&lt;/code&gt;参数来指定 要创建的账户数量为20：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ganache-cli -a &lt;span&gt;20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421135203306-177933291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用curl获取节点版本信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以太坊规定了节点必须实现web3_clientVersion 接口来向外部应用提供节点旳版本信息。接口协议的交互流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421134439692-2095587128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个典型的请求/应答模型，请求包和响应包都是标准的JSON格式。其中，jsonrpc字段用来 标识协议版本，id则用来帮助建立响应包与请求包的对应关系。&lt;/p&gt;
&lt;p&gt;在请求包中，使用method字段来声明接口方法，例如web3_clientVersion，使用params 字段来声明接口方法的参数数组。 在响应包中，result字段中保存了命令执行的返回结果。&lt;/p&gt;
&lt;p&gt;以太坊JSON RPC并没有规定传输层的实现，不过大部分节点都会实现HTTP和IPC的访问。因此 我们可以使用命令行工具curl来测试这个接口：&lt;/p&gt;
&lt;p&gt;curl http://localhost:8545 -X POST -d '{&quot;jsonrpc&quot;: &quot;2.0&quot;,&quot;method&quot;: &quot;web3_clientVersion&quot;,&quot;params&quot;: [], &quot;id&quot;: 123}'&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421135124046-1586104586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 使用C#获取节点版本信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就像前一节看到的，我们只要在C#代码中按照以太坊RPC接口要求发送http请求包就可以了。 你可以使用任何一个你喜欢的http库，甚至直接使用socket来调用以太坊的JSON RPC API。例如，下面的代码使用.Net内置的HttpClient类来访问以太坊节点，注意代码中的注释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; GetVersionByHttpDemo
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cuiyw-test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            GetVersion().Wait();
            GetAccounts().Wait();
            Console.ReadLine();
        }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task GetVersion()
        {
            HttpClient httpClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:7545&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; payload = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{\&quot;jsonrpc\&quot;:\&quot;2.0\&quot;,\&quot;method\&quot;:\&quot;web3_clientVersion\&quot;,\&quot;params\&quot;:[],\&quot;id\&quot;:7878}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;= &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; payload);
            StringContent content &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringContent(payload, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            HttpResponseMessage rsp &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; httpClient.PostAsync(url, content);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; ret = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; rsp.Content.ReadAsStringAsync();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ret);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task GetAccounts()
        {
            HttpClient httpClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:7545&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; payload = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{\&quot;jsonrpc\&quot;:\&quot;2.0\&quot;,\&quot;method\&quot;:\&quot;eth_accounts\&quot;,\&quot;params\&quot;:[],\&quot;id\&quot;:5777}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;= &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; payload);
            StringContent content &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringContent(payload, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            HttpResponseMessage rsp &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; httpClient.PostAsync(url, content);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; ret = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; rsp.Content.ReadAsStringAsync();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ret);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421140636494-1626915630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;序列化与反序列化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在应用逻辑里直接拼接RPC请求字符串，或者直接解析RPC响应字符串，都不是 令人舒心的事情。&lt;/p&gt;
&lt;p&gt;更干净的办法是使用数据传输对象（Data Transfer Object）层来 隔离这个问题，在DTO层将C#的对象序列化为Json字符串，或者从Json字符串 反序列化为C#的对象，应用代码只需要操作C#对象即可。&lt;/p&gt;
&lt;p&gt;我们首先定义出JSON请求与响应所对应的C#类。例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421140840615-74516229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们获取节点版本的代码可以不用直接操作字符串了：&lt;/p&gt;
&lt;p&gt;如下图，在SerializeDemo中定义了请求与响应的model。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421141940741-1183907628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RpcRequestMessage&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Newtonsoft.Json;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SerializeDemo
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RpcRequestMessage
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RpcRequestMessage(&lt;span&gt;string&lt;/span&gt; method, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] parameters)
        {
            Id &lt;/span&gt;=&lt;span&gt; Environment.TickCount;
            Method &lt;/span&gt;=&lt;span&gt; method;
            Parameters &lt;/span&gt;=&lt;span&gt; parameters;
        }

        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Id;

        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jsonrpc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; JsonRpc = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Method;

        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;params&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Parameters;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RpcResponseMessage&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Newtonsoft.Json;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SerializeDemo
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RpcResponseMessage
    {
        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jsonrpc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; JsonRpc { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [JsonProperty(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Result { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RpcHttpDto&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Newtonsoft.Json;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SerializeDemo
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RpcHttpDto
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Run()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; version = &lt;span&gt;await&lt;/span&gt; Rpc(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;web3_clientVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;version =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + version + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; type =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; version.GetType().Name);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; accounts = &lt;span&gt;await&lt;/span&gt; Rpc(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eth_accounts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accounts =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + accounts + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; type =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; accounts.GetType().Name);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; Rpc(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; method)
        {
            HttpClient httpClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:7545&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            RpcRequestMessage rpcReqMsg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RpcRequestMessage(method);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; payload =&lt;span&gt; JsonConvert.SerializeObject(rpcReqMsg);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;= &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; payload);

            StringContent content &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringContent(payload, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            HttpResponseMessage rsp &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; httpClient.PostAsync(url, content);

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; ret = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; rsp.Content.ReadAsStringAsync();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ret);
            RpcResponseMessage rpcRspMsg &lt;/span&gt;= JsonConvert.DeserializeObject&amp;lt;RpcResponseMessage&amp;gt;&lt;span&gt;(ret);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rpcRspMsg.Result;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Program&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SerializeDemo
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cuiyw-test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Call Ethereum RPC Api with HttpClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            RpcHttpDto demo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RpcHttpDto();
            demo.Run().Wait();
            Console.ReadLine();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421141920589-1522586777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;使用现成的轮子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽管可行，但我还是建议你尽量避免自己去封装这些rpc接口，毕竟 这个事已经做过好几次了，而且rpc接口封装仅仅是整个故事的一部分。&lt;/p&gt;
&lt;p&gt;Nethereum是以太坊官方推荐的.Net下的rpc接口封装库，因此我们优先 选择它。&lt;/p&gt;
&lt;p&gt;下面是使用Nethereum获取节点版本信息的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
                Web3 web3 = &lt;span&gt;new&lt;/span&gt; Web3(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:7545&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; version = &lt;span&gt;await&lt;/span&gt; web3.Client.SendRequestAsync&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;web3_clientVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;version =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + version);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Web3是Nethereum的入口类，我们与以太坊的交互，基本上是通过 这个入口来完成的，实例化Web3需要指定要链接的节点地址，例如本地ganache节点，就 可以使用http://localhost:7545这个地址。&lt;/p&gt;
&lt;p&gt;Web3实例的Client属性是一个IClient接口的实现对象，这个接口抽象了与 节点的RPC接口交互的方法，因此与具体的通信传输机制无关：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421143633825-1603142035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图容易看出，Nethereum目前支持通过四种不同的通信机制来访问以太坊： Http、WebSocket、命名管道和Unix套接字。&lt;/p&gt;
&lt;p&gt;容易理解，当我们提供一个节点url作为Web3实例化的参数时，Web3将自动创建 一个基于Http的IClient实现实例，即RpcClient实例。&lt;/p&gt;
&lt;p&gt;一旦获得了Iclient的实现实例，就可以调用其SendRequestAsync&amp;lt;T&amp;gt;()方法来向节点 提交请求了，例如，下面的代码提交一个web3_clientVersion调用请求：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;string&lt;/span&gt; version = &lt;span&gt;await&lt;/span&gt; web3.Client.SendRequestAsync&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;web3_clientVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SendRequestAsync()是一个泛型方法，其泛型参数T用来声明返回值的类型。例如， 对于web3_clientVersion调用，其RPC响应的result字段是一个字符串，因此我们使用 string作为泛型参数。&lt;/p&gt;
&lt;p&gt;需要指出的是，SendRequestAsync()不需要我们传入完整的请求报文，其返回的结果 也不是完整的响应报文，只是其中result字段的内容。&lt;/p&gt;
&lt;p&gt;对于需要传入参数的RPC调用，例如用来计算字符串keccak哈希值的 web3_sha3调用， 可以在SendRequestAsync()方法自第3个参数开始依次写入。例如，下面的代码 计算hello,ethereum的keccak哈希：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
                HexUTF8String hexstr = &lt;span&gt;new&lt;/span&gt; HexUTF8String(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello,ethereum&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello,ethereum =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; hexstr.HexValue);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; hash = &lt;span&gt;await&lt;/span&gt; web3.Client.SendRequestAsync&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;web3_sha3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, hexstr);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keccak hash =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + hash);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SendRequestAsync()方法的第2个参数表示路由名称，可以用来拦截RPC请求，满足 一些特殊的应用需求，我们通常将其设置为null即可。由于web3_sha3调用要求传入 的参数为16进制字符串格式，例如，hello,ethereum应当表示为0x68656c6c6f2c657468657265756d， 因此我们使用HexUtf8String类进行转换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421143954038-1773134816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 使用RPC接口封装类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你倾向于薄薄一层的封装，那么使用IClient的SendRequestAsync()接口， 已经可以满足大部分访问以太坊的需求了，而且基本上只需要参考RPC API的手册， 就可以完成工作了。不过Nethereum走的更远。&lt;/p&gt;
&lt;p&gt;Nethereum为每一个RPC接口都封装了单独的类。&lt;/p&gt;
&lt;p&gt;例如，对于web3_clientVersion调用，其对应的实现类为Web3ClientVersion； 而对于web3_sha3调用，其对应的实现类为Web3Sha3：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421144849643-1614607208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有一点有助于我们的开发：容易根据RPC调用的名字猜测出封装类的名称 —— 去掉 下划线，然后转换为单词首字母大写的Pascal风格的命名。&lt;/p&gt;
&lt;p&gt;由于每一个RPC接口的封装类都依赖于一个IClient接口的实现，因此我们可以直接 在接口封装类实例上调用SendRequestAsync()方法，而无须再显式地使用一个IClient 实现对象来承载请求 —— 当然在创建封装类实例时需要传入IClient的实现对象。&lt;/p&gt;
&lt;p&gt;例如，下面的代码使用类Web3ClientVersion来获取节点版本信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
                Web3ClientVersion w3cv = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Web3ClientVersion(web3.Client);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; version = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; w3cv.SendRequestAsync();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;version =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + version);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;容易注意到封装类的SendRequestAsync()方法不再需要使用泛型参数声明返回值的 类型，这是因为特定RPC接口的对应封装类在定义时已经确定了调用返回值的类型。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Nethereum.RPC.Web3
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Web3ClientVersion : GenericRpcRequestResponseHandlerNoParam&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Web3ClientVersion(IClient client);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果RPC接口需要额外的参数，例如web3_sha3，那么在SendRequestAsync() 方法中依次传入即可。例如，下面的代码使用Web3Sha3类来计算一个字符串 的keccak哈希值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
                HexUTF8String hexstr = &lt;span&gt;new&lt;/span&gt; HexUTF8String(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello,ethereum&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Web3Sha3 w3s &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Web3Sha3(web3.Client);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; hash = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; w3s.SendRequestAsync(hexstr);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keccak hash =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + hash);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接口封装类比直接使用IClient提供了更多的类型检查能力，但同时也 带来了额外的负担 —— 需要同时查阅RPC API接口文档和Nethereum的接口 封装类文档，才能顺利地完成任务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Nethereum.Hex.HexTypes;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Nethereum.RPC.Web3;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Nethereum.Web3;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Web3HeavyDemo
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cuiyw-test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Access Ethereum with Nethereum&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Task.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; () =&amp;gt;&lt;span&gt; {
                Web3 web3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Web3(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:7545&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                Web3ClientVersion w3cv &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Web3ClientVersion(web3.Client);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; version = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; w3cv.SendRequestAsync();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;version =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; version);

                HexUTF8String hexstr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HexUTF8String(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello,ethereum&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                Web3Sha3 w3s &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Web3Sha3(web3.Client);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; hash = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; w3s.SendRequestAsync(hexstr);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keccak hash =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; hash);
            }).Wait();
            Console.ReadLine();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421150126624-1609381165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理解Nethereum的命名规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大多数情况下，我们容易从以太坊的RPC接口名称，推测出Nethereum的封装类名称。但是别忘了，在C#中，还有个命名空间的问题。&lt;/p&gt;
&lt;p&gt;Nethereum根据不同的RPC接口系列，在不同的命名空间定义接口实现类。 例如对于web3_*这一族的接口，其封装类的命名空间为Nethereum.RPC.Web3:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421145903804-573524776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，对于eth_*系列的接口，并不是所有的封装类都定义在Nethereum.RPC.Eth 命名空间，Nethereum又任性地做了一些额外的工作 —— 根据接口的功能划分了一些 子命名空间！例如，和交易有关的接口封装类，被归入Nethereum.RPC.Eth.Transactions命名 空间，而和块有关的接口封装类，则被归入Nethereum.RPC.Eth.Blocks命名空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421145959930-1351087383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然，如果你从一个RPC调用出发，尝试推测出它在Nethereum中正确的命名空间和 封装类名称，这种设计并不友好 —— 虽然方便了Nethereume的开发者维护代码， 但会让Nethereum的使用者感到崩溃 —— 不可预测的API只会伤害开发效率。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Nethereum.Hex.HexTypes;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Nethereum.RPC.Eth;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Nethereum.Web3;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Web3Namerules
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cuiyw-test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Access Ethereum with Nethereum&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Task.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; () =&amp;gt;&lt;span&gt; {
                Web3 web3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Web3(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:7545&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                EthAccounts ea &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EthAccounts(web3.Client);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] accounts = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ea.SendRequestAsync();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accounts =&amp;gt; \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, accounts));

                EthGasPrice egp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EthGasPrice(web3.Client);
                HexBigInteger price &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; egp.SendRequestAsync();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gas price =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; price.Value);
            }).Wait();
            Console.ReadLine();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421150726142-1772905377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用Web3入口类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Netherem推荐通过入口类Web3来使用接口封装类，这可以在某种程度上减轻 复杂的命名空间设计给使用者带来的困扰。&lt;/p&gt;
&lt;p&gt;例如，我们可以使用web3.Eth.Accounts来直接访问EthAccounts类的实例， 而无须引入命名空间来实例化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421150808944-1364904901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说，在实例化入口类Web3的时候，Nethereum同时也创建好了所有的接口 封装类的实例，并挂接在不同的属性（例如Eth）之下。&lt;/p&gt;
&lt;p&gt;我们可以先忽略Eth属性的具体类型，简单地将其视为接口封装对象的容器。 因此，当我们需要使用EthGetBalance类的时候，通过web3.Eth.GetBalance 即可访问到其实例对象；同样，当我们希望使用EthSendTransaction类时， 则可以通过web3.Eth.Transactions.SendTransaction来访问其实例对象 —— 它在子容器Transactions里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421150837941-333430055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，下面的代码调用eth_accounts接口获取节点账户列表，然后调用 eth_getBalance接口获取第一个账户的余额：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cuiyw-test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web3 Entry Demo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Web3Entry demo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Web3Entry();
            demo.Run().Wait();
            Console.ReadLine();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Nethereum.Hex.HexTypes;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Nethereum.Web3;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Web3EntryDemo
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Web3Entry
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Run()
        {
            Web3 web3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Web3(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:7545&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] accounts = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; web3.Eth.Accounts.SendRequestAsync();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;account#0 =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + accounts[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
            HexBigInteger balance &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt; web3.Eth.GetBalance.SendRequestAsync(accounts[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;balance =&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; balance.Value);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421152343492-1758851977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于eth_getBalance 返回的账户余额采用16进制字符串表示，因此我们需要使用HexBigInteger类型 的变量来接收这个值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190421151426806-442101116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Apr 2019 12:42:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>在这一部分，我们将使用C#开发一个最简单的.Net控制台应用，来接入以太坊节点，并打印 所连接节点旳版本信息。通过这一部分的学习，你将掌握以下技能： 我们将使用ganache来模拟以太坊节点。gana</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/10744950.html</dc:identifier>
</item>
</channel>
</rss>