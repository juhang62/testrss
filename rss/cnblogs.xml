<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C#3 分部方法，简单标记一下 - 凯帝农垦</title>
<link>http://www.cnblogs.com/wwkk/p/10325463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wwkk/p/10325463.html</guid>
<description>&lt;p&gt;    如果我问你，如果一个普通的类实现了一个接口方法，但是这个类的实例却访问不到这个接口的方法，这种情况你遇到过吗？有时候，你可能在使用分部方法时就会发现这么一个现象。&lt;/p&gt;
&lt;p&gt;    C#3 中出现了 “分部方法” ，工作了好几年一直没用过，可能不咋实用，也有可能是工作中没有遇到这种场景，分部类倒是用了不少。最近看了一下，内容简单，标记一下。&lt;/p&gt;
&lt;p&gt;    我们 分部方法 和分部类有点类似的是 也是使用的关键字 partial ,不过不同的是 部分方法 不能有访问修饰符 (像public) 或者 virtual ，abstract，override，new，sealed，extern  。&lt;/p&gt;
&lt;p&gt;     而分部类是没有这个限制。那么你应该会想这个方法，是会像接口中定义的没法带修饰符方法一样 天生是公用的，  还是像普通类中 是私有的呢，我迫不及待的做了个代码，结局倾向了后者。&lt;/p&gt;
&lt;p&gt;//文件1中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; People
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; People(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; arg)
        {
              Speak($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我被构造了,带着{arg}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;partial&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Speak(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; paramStr);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;//文件2中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; People 
    {      
        &lt;/span&gt;&lt;span&gt;partial&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Speak(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; paramStr)
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收到参数{params}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);         
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
        {
            People p&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; People(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2019到了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//p&lt;/span&gt;&lt;span&gt;.Speaks(&quot;Hello&quot;);     访问不到                  &lt;/span&gt;
&lt;span&gt;            Console.ReadKey();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      上面是我们的使用例子，部分方法 限制了我们的方法不能有返回值，只能是void的方法，且不能获取out参数，它必须是私有的，可以是静态的或者泛型。&lt;/p&gt;
&lt;p&gt;      文件1中   分部方法 的申明和抽象方法相同，只提供了partial修饰符的签名而没有实现，以分号结尾。我们分析文件1中的IL代码，发现构造函数中没有任何痕迹。&lt;/p&gt;
&lt;p&gt;      接下来，我们看下如果定义接口，然后实现的时候使用分部方法呢。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IPeople
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Speaks();                   
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;//文件1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; People:IPeople
    {        
        &lt;/span&gt;&lt;span&gt;partial&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Speaks();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;//文件2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; People : IPeople  //接口可写可不写
    {
       &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; IPeople.Speaks()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;哎呀，2019都来了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       我们发现 实现接口需要显式实现。然后我们调用看看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
        {           &lt;/span&gt;&lt;span&gt;
            People p2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; People();
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; p2.Speaks();  访问不到&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     p2访问不到实现的接口方法。当然，如果再定义一个子类，子类的实例也是访问不到的。那么怎么才能访问到呢，你一定会这么写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
        {
            IPeople p1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; People();
            p1.Speaks(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 完全ok        &lt;/span&gt;
   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      所以你总的感觉下来，这个东西限制还是蛮大的。这个特性特别适用那些自动生成代码和手动写代码一起交互场景。概况的说，C#3的分部方法让生成代码可以和手写代码以一种丰富的方式进行交互，而不会产生任何性能上的损失，可以说是C#2分部类一种自然的延续。&lt;/p&gt;

</description>
<pubDate>Sat, 26 Jan 2019 17:01:00 +0000</pubDate>
<dc:creator>凯帝农垦</dc:creator>
<og:description>C#3 分部方法，简单标记一下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wwkk/p/10325463.html</dc:identifier>
</item>
<item>
<title>Reactive Extensions 相见恨晚的Rx.Net - 长沙大鹏</title>
<link>http://www.cnblogs.com/hunanzp/p/10325454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hunanzp/p/10325454.html</guid>
<description>&lt;h3&gt;何为Reactive Extensions（Rx）&lt;/h3&gt;
&lt;p&gt;Rx是一个遵循函数式编程的类库，它引用观察者以及迭代器设计模式对可观察对象产生的数据进行异步消费。使用Rx，&lt;/p&gt;
&lt;p&gt;开发人员将使用LINQ运算符操作异步数据流，并使用调度程序参数化异步数据流中的并发性，简单地说，Rx = Observables + LINQ + Schedulers。&lt;/p&gt;
&lt;p&gt;使用Rx需要Nuget安装System.Reactive Nuget包&lt;/p&gt;
&lt;h4&gt;Rx的使用场景&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;响应式UI&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UI界面上，用户对一个绑定数据集合的控件进行关键字查询。常规的流程是我们必须在等待用户键盘按下指定的完成键(如回车)或鼠标点击查询按钮后程序才开始执行相应的查询处理。但假设需求变更：“用户希望在每输入一个关键字后就能及时将关键字相应的查询结果集绑定到控件” 如果面临这个需求，那你会如何实现呢？ 你会少不了定义相应的全局状态字段，少不了相应的时间间隔刷新。我相信写出来的代码也会让你很烦恼。 其实你有更好的选择，那就是我们的主角Rx。&lt;/p&gt;
&lt;h4&gt;Rx 核心&lt;/h4&gt;
&lt;p&gt;Rx有两个核心接口 IObservable&amp;lt;T&amp;gt;、IObserver&amp;lt;T&amp;gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IObservable&amp;lt;T&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先来看此接口的结构:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349354/201901/349354-20190127004910127-1086779920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IObservable&amp;lt;T&amp;gt;接口就提供一个Subscribe(订阅)方法，入参是一个&lt;strong&gt;观察者对象接口&lt;/strong&gt;。&lt;br/&gt;我们可以&lt;strong&gt;将IObservable&amp;lt;T&amp;gt;称之为被观察者(可观察者)，IObserver&amp;lt;T&amp;gt;称之为观察者&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过可接口签名可以看出被观察者需要输出T类型的对象。需要理解被观察者IObservable&amp;lt;T&amp;gt;我们需要与现有的一些常规知识点做出比较，这里我们用IEnumerable&amp;lt;T&amp;gt;比较。&lt;br/&gt;我想我们都使用过Linq，操作过IEnumerable&amp;lt;T&amp;gt;集合，IEnumerable&amp;lt;T&amp;gt;集合有个明显的状态就是它所存储的元素是静态的。集合内的元素状态除非代码显示的新增或删除、修改，否则这个集合基本是静态(数据未变动)的。但是IObservable&amp;lt;T&amp;gt;则不同，它的元素是根据被观察者提供的数据而变动的(不可预测的)，就好比在UI上你无法预测用户的操作行为一样。&lt;/p&gt;
&lt;p&gt;下面这个表格可以看出两者区别&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr readability=&quot;1&quot;&gt;&lt;th&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;IEnumerable&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/th&gt;
&lt;th readability=&quot;-3&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;可方便的列举集合元素值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;IObservable&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;可观察对象变动的值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote&gt;
&lt;p&gt;IObserver&amp;lt;T&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;IObserver&amp;lt;T&amp;gt;接口可以理解为消费被贯彻着提供数据的一个接口，它的三个方法决定了本次数据流的观察行为的走向。&lt;br/&gt;通俗理解就是&lt;strong&gt;被观察者生成数据，观察者消费数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;来看下IObserver&amp;lt;T&amp;gt;的结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349354/201901/349354-20190127004952237-1469366938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;OnNext 表示消费新数据&lt;/li&gt;
&lt;li&gt;OnError 表示观察数据流出现异常&lt;/li&gt;
&lt;li&gt;OnCompleted 表示明确关闭观察数据流&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;代码示例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面代码定义了一个可观察的队列，该队列会提供给观察者三个int类型的入参 1、2、3 供观察者对象的OnNext方法消费。 MyConsoleObserver(观察者)在得到数据后打印出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; {   
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            Test();    
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Test()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;        &lt;span&gt;var&lt;/span&gt; numbers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MySequenceOfNumbers();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;        &lt;span&gt;var&lt;/span&gt; observer = &lt;span&gt;new&lt;/span&gt; MyConsoleObserver&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;       numbers.Subscribe(observer);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;       Console.ReadLine();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自定义被观察队列
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MySequenceOfNumbers : IObservable&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IDisposable Subscribe(IObserver&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; observer)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             observer.OnNext(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             observer.OnNext(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             observer.OnNext(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            observer.OnCompleted();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Disposable.Empty;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;   &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自定义观察者对象
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyConsoleObserver&amp;lt;T&amp;gt; : IObserver&amp;lt;T&amp;gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnNext(T value)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收到 value {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, value);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnError(Exception error)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出现异常! {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, error);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnCompleted()
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;关闭观察行为&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过示例代码我们得知了Rx.Net的数据流订阅、消费流程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Subject&amp;lt;T&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们再来认识下Subject&amp;lt;T&amp;gt;，Subject是一个IObservable，它以命令形式生成一个值，并将该值推送给观察者对象。我们看下Subject&amp;lt;T&amp;gt;的结构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349354/201901/349354-20190127005343534-933759581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看这继承关系，我们继续看SubjectBase&amp;lt;T&amp;gt;里面有些啥~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349354/201901/349354-20190127005400608-124561861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哎呀，这个类真不得了啊，把IObserver&amp;lt;T&amp;gt;和IObservable&amp;lt;T&amp;gt;都给继承了。这不是可以自己提供数据自己进行订阅和消费了么....&lt;br/&gt;我们来看看Subject&amp;lt;T&amp;gt;是怎么玩的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SubjectTest()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个 类型string的Subject对象&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; inputs = &lt;span&gt;new&lt;/span&gt; Subject&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;订阅数据流&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             inputs.Subscribe((p =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;得到的值:{p}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环造数据&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 inputs.OnNext($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;时间:{DateTime.Now.ToString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;yyyy-MM-dd HH:mm:ss&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)}, 下标:{i}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            Console.ReadLine();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349354/201901/349354-20190127005514246-743497454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是订阅方法需要在数据生成前声明。&lt;/p&gt;
&lt;h4 id=&quot;%E6%80%BB%E7%BB%93&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;好啦，要睡觉啦，基本上Rx核心的几个点就先讲到这，我们也来总结下Rx.Net的几个核心知识点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可观察(被观察)对象生产数据；&lt;/li&gt;
&lt;li&gt;观察者总是被动接收数据；&lt;/li&gt;
&lt;li&gt;需要明确订阅后观察者才得以消费数据；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里也只是自己的一个学习总结，Rx也不是眼前的几个小示例就可以一目了然，不过核心的知识基本上就是这些。至于还有一些操作符的话相信用过Linq的话上手不难，难点在于需要在实际业务中找到合适的场景使用，只有不断使用才会融会贯通。但是任何技术都不能滥用，每一项新技术都有它最佳使用场景，优秀的开发者需要做好权衡。&lt;/p&gt;

</description>
<pubDate>Sat, 26 Jan 2019 16:58:00 +0000</pubDate>
<dc:creator>长沙大鹏</dc:creator>
<og:description>何为Reactive Extensions（Rx） Rx是一个遵循函数式编程的类库，它引用观察者以及迭代器设计模式对可观察对象产生的数据进行异步消费。使用Rx， 开发人员将使用LINQ运算符操作异步数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hunanzp/p/10325454.html</dc:identifier>
</item>
<item>
<title>大数据学习之_01_Linux学习_02_组管理和权限管理+定时任务调度+linux磁盘分区、挂载+linux的网络配置+进程管理(重点)+软件包管理+大厂面试题+感悟分享+资料附录 - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10325450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10325450.html</guid>
<description>&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h10&quot;&gt;10 组管理和权限管理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h101linux&quot;&gt;10.1 Linux组的基本介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h102&quot;&gt;10.2 文件/目录的所有者&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h103&quot;&gt;10.3 文件/目录的所在组&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h104&quot;&gt;10.4 权限的基本介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h105rwx&quot;&gt;10.5 rwx权限详解&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h106chmod&quot;&gt;10.6 修改权限指令-chmod&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h107chown&quot;&gt;10.7 修改文件所有者-chown&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h108chgrp&quot;&gt;10.8 修改文件所在组-chgrp&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h109&quot;&gt;10.9 最佳实践-警察和土匪游戏&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h11&quot;&gt;11 定时任务调度&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h111crond&quot;&gt;11.1 crond任务调度&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h12linux&quot;&gt;12 linux磁盘分区、挂载&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h121&quot;&gt;12.1 分区的基本知识&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h122linux&quot;&gt;12.2 Linux分区&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h123&quot;&gt;12.3 挂载的经典案例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h124&quot;&gt;12.4 查询系统整体磁盘使用情况&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h125&quot;&gt;12.5 查询指定目录的磁盘占用情况&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h126&quot;&gt;12.6 磁盘情况-工作中实用指令&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h13linux&quot;&gt;13 linux的网络配置&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h131linux&quot;&gt;13.1 linux的网络配置的原理图&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h132ip&quot;&gt;13.2 查看网络IP和网关&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h133linux&quot;&gt;13.3 linux网络环境配置&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h1321ip&quot;&gt;13.2.1 第一种方法：自动获取ip地址&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h1332ip&quot;&gt;13.3.2 第二种方法：配置固定的ip地址&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h134&quot;&gt;13.4 修改主机名&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h14&quot;&gt;14 进程管理(重点)&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h141&quot;&gt;14.1 基本介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h1411&quot;&gt;14.1.1 显示系统执行的进程&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h1412ps&quot;&gt;14.1.2 ps指令详解&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h142killkillall&quot;&gt;14.2 终止进程kill和killall&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h143pstree&quot;&gt;14.3 查看进程树pstree&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h144service&quot;&gt;14.4 服务(service)管理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h1441&quot;&gt;14.4.1 查看服务名称&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h1442runlevel&quot;&gt;14.4.2 服务的运行级别(runlevel)&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h145chkconfig&quot;&gt;14.5 chkconfig指令&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h145&quot;&gt;14.5 动态监控进程&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h146&quot;&gt;14.6 监控网络状态&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h15&quot;&gt;15 软件包管理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h151rpm&quot;&gt;15.1 rpm包的管理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h152rpm&quot;&gt;15.2 卸载rpm包&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h153rpm&quot;&gt;15.3 安装rpm包&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h154yum&quot;&gt;15.4 yum包的管理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h16&quot;&gt;16 大厂面试题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h161&quot;&gt;16.1 百度面试题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h162&quot;&gt;16.2 瓜子二手车面试题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h17&quot;&gt;17 感悟分享&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10325450.html#h18&quot;&gt;18 资料附录&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h10&quot;&gt;&lt;span&gt;&lt;strong&gt;10 组管理和权限管理&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h101linux&quot;&gt;&lt;span&gt;&lt;strong&gt;10.1 Linux组的基本介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。&lt;br/&gt;  1) 所有者&lt;br/&gt;  2) 所在组&lt;br/&gt;  3) 其它组&lt;br/&gt;  4) 改变用户所在的组&lt;br/&gt;示意图如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kukxl8.png&quot; alt=&quot;&quot;/&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h102&quot;&gt;&lt;span&gt;&lt;strong&gt;10.2 文件/目录的所有者&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一般为文件的创建者，谁创建了该文件，就自然的成为该文件的所有者。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;查看文件的所有者&lt;br/&gt;指令：&lt;code&gt;ls –ahl&lt;/code&gt;&lt;br/&gt;应用实例：创建一个组police，再创建一个用户tom，将tom放在police组，然后使用tom来创建一个文件ok.txt。【参考补充示例】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuASOg.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;修改文件的所有者&lt;br/&gt;指令：chown 用户名 文件名&lt;br/&gt;应用案例：使用root用户创建一个文件apple.txt，然后将该文件的所有者修改成tom。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuAPTs.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;补充示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;hljs diff&quot; readability=&quot;9&quot;&gt;示例：增加用户时直接指定用户的家目录和用户组&lt;p&gt;创建一个用户，名字叫abc，主目录是/home/abc/目录，属于aabb这个组。&lt;br/&gt;&lt;strong&gt;useradd -d /home/abc/ abc -m -g aabb&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-d的意思是指定用户的主目录 &lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-m的意思是，如果主目录不存在，那么就自动创建这个目录 &lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-deletion&quot;&gt;-g的意思是指定该用户属于哪个组&lt;/span&gt;&lt;/p&gt;&lt;p&gt;注意1：我们需要先创建组aabb。命令：groupadd aabb&lt;br/&gt;注意2：我们新增用户后，要及时通过root用户设置新增用户的密码。这是一个好习惯！&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h103&quot;&gt;&lt;span&gt;&lt;strong&gt;10.3 文件/目录的所在组&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;当某个用户创建了一个文件后，默认情况下，这个文件的所在组就是该用户所在的组。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;查看文件/目录所在组&lt;br/&gt;指令：ls –ahl&lt;br/&gt;应用实例：同上。&lt;/li&gt;
&lt;li&gt;修改文件所在的组&lt;br/&gt;指令：chgrp 组名 文件名&lt;br/&gt;应用实例：使用root用户创建文件orange.txt，看看当前这个文件属于哪个组【root】，然后将这个文件所在组，修改到police组。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuACwj.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;其他组&lt;br/&gt;除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。&lt;/li&gt;
&lt;li&gt;改变用户所在组&lt;br/&gt;在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变某个用户所在的组。【参考补充示例】&lt;br/&gt;指令：&lt;br/&gt;  1) usermod –g 组名 用户名&lt;br/&gt;  2) usermod –d 目录名 用户名 （功能描述：改变该用户登陆的初始目录）&lt;br/&gt;应用实例：创建一个土匪组(bandit)将tom这个用户从原来所在的police组，修改到bandit(土匪)组，命令 &lt;code&gt;usermod -g bandit tom&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuAkYq.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h104&quot;&gt;&lt;span&gt;&lt;strong&gt;10.4 权限的基本介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuAFkn.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h105rwx&quot;&gt;&lt;span&gt;&lt;strong&gt;10.5 rwx权限详解&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;rwx权限详解&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuAVpV.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;文件及目录权限实际案例&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuAAf0.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h106chmod&quot;&gt;&lt;span&gt;&lt;strong&gt;10.6 修改权限指令-chmod&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;第一种方式：+ 、-、= 变更权限&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuEvqg.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;演示案例如下截图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuEXM8.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;第二种方式：通过数字变更权限&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuEzZQ.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h107chown&quot;&gt;&lt;span&gt;&lt;strong&gt;10.7 修改文件所有者-chown&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuELxf.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h108chgrp&quot;&gt;&lt;span&gt;&lt;strong&gt;10.8 修改文件所在组-chgrp&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuEbGt.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h109&quot;&gt;&lt;span&gt;&lt;strong&gt;10.9 最佳实践-警察和土匪游戏&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVSaj.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（1）创建组&lt;br/&gt;（2）创建用户（好习惯，创建用户后要设置密码）&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuViR0.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（3）jack 创建一个文件，自己可以读写，本组人可以读，其它组没人任何权限&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVAMT.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（4）jack 可以修改该文件，本组人可以读写，让其它组人可以读&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVCin.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（5）xh 投靠警察，看看是否可以读写（使用root用户）&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVpIs.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h11&quot;&gt;&lt;span&gt;&lt;strong&gt;11 定时任务调度&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h111crond&quot;&gt;&lt;span&gt;&lt;strong&gt;11.1 crond任务调度&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;说明：&lt;br/&gt;crontab 进行定时任务的设置。&lt;/li&gt;
&lt;li&gt;概述： 任务调度：是指系统在某个时间执行的特定的命令或程序。 任务调度分类：
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1) 系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2) 个别用户工作：个别用户可能希望执行某些程序。比如对mysql数据库的备份。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;基本语法：&lt;br/&gt;crontab [选项]&lt;/li&gt;
&lt;li&gt;常用选项&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVFzV.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;快速入门：&lt;br/&gt;设置任务调度文件：/etc/crontab&lt;br/&gt;设置个人任务调度。执行&lt;code&gt;crontab –e&lt;/code&gt;命令。&lt;br/&gt;接着输入任务到调度文件，如：&lt;code&gt;*/1 * * * * ls –l /etc/ &amp;amp;gt; /tmp/to.txt&lt;/code&gt;&lt;br/&gt;意思说：每小时的每分钟执行&lt;code&gt;ls –l /etc/ &amp;amp;gt; /tmp/to.txt&lt;/code&gt;命令&lt;/li&gt;
&lt;li&gt;参数细节说明：&lt;br/&gt;5个占位符的说明：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVPGq.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;特殊符号的说明：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVVLF.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;特定时间执行任务案例：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVeZ4.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;应用实例：&lt;br/&gt;案例1：每隔1分钟，就将当前的日期信息，追加到/tmp/mydate.log 文件中&lt;br/&gt;步骤：&lt;br/&gt;1) 编写一个文件&lt;code&gt;/home/mytask1.sh&lt;/code&gt;，文件内容是：&lt;code&gt;date &amp;amp;gt;&amp;amp;gt; /tmp/mydate.log&lt;/code&gt;&lt;br/&gt;2) 给文件&lt;code&gt;/home/mytask1.sh&lt;/code&gt;一个可以执行的权限，命令&lt;code&gt;chmod 744 /home/mytask1.sh&lt;/code&gt;&lt;br/&gt;3) 设置个人任务调度。执行&lt;code&gt;crontab –e&lt;/code&gt;命令&lt;br/&gt;4) 输入任务到调度文件，任务内容：&lt;code&gt;*/1 * * * * /home/mytask1.sh&lt;/code&gt;&lt;br/&gt;5) 查看文件/tmp/mydate.log，成功！&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVEsU.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;案例2：每隔1分钟，将当前日期和日历信息，都追加到/tmp/mycal.log 文件中&lt;br/&gt;步骤：&lt;br/&gt;1) 编写一个文件&lt;code&gt;/home/mytask2.sh&lt;/code&gt;，文件内容是：&lt;code&gt;date &amp;amp;gt;&amp;amp;gt; /tmp/mycal.log&lt;/code&gt; 和 &lt;code&gt;cal &amp;amp;gt;&amp;amp;gt; /tmp/mycal.log&lt;/code&gt;&lt;br/&gt;2) 给文件&lt;code&gt;/home/mytask2.sh&lt;/code&gt;一个可以执行的权限，命令&lt;code&gt;chmod 744 /home/mytask2.sh&lt;/code&gt;&lt;br/&gt;3) 设置个人任务调度。执行&lt;code&gt;crontab –e&lt;/code&gt;命令&lt;br/&gt;4) 输入任务到调度文件，任务内容：&lt;code&gt;*/1 * * * * /home/mytask2.sh&lt;/code&gt;&lt;br/&gt;5) 查看文件/tmp/mycal.log，成功！&lt;br/&gt;截图同上！不在赘图！&lt;br/&gt;案例3：每天凌晨2:00将mysql数据库testdb，备份到文件/tmp/mydb.bak中。&lt;br/&gt;步骤：&lt;br/&gt;1) 编写一个文件&lt;code&gt;/home/mytask3.sh&lt;/code&gt;，文件内容是：&lt;code&gt;/usr/local/mysql/bin/mysqldump -uroot -proot testdb &amp;amp;gt; /tmp/mydb.bak&lt;/code&gt;&lt;br/&gt;2) 给文件&lt;code&gt;/home/mytask3.sh&lt;/code&gt;一个可以执行的权限，命令&lt;code&gt;chmod 744 /home/mytask3.sh&lt;/code&gt;&lt;br/&gt;3) 设置个人任务调度。执行&lt;code&gt;crontab –e&lt;/code&gt;命令&lt;br/&gt;4) 输入任务到调度文件，任务内容：&lt;code&gt;0 2 * * * /home/mytask3.sh&lt;/code&gt;&lt;br/&gt;5) 查看文件/tmp/mydb.bak，成功！&lt;br/&gt;截图同上！不在赘图！&lt;/li&gt;
&lt;li&gt;crond 相关指令:&lt;br/&gt;1) conrtab –r：终止任务调度(删除所有任务调度)。&lt;br/&gt;2) crontab –l：列出当前有那些任务调度。&lt;br/&gt;3) service crond restart [重启任务调度]&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVmdJ.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;拓展：比较难的shell脚本的编写&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVKiR.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;shell脚本文件内容：&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;shell language-shell hljs&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;!/bin/bash   &lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;备份路径&lt;/span&gt;&lt;br/&gt;BACKUP=/data/backup/sql/dy&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;当前时间&lt;/span&gt;&lt;br/&gt;DATETIME=$(date +%Y-%m-%d_%H%M%S)&lt;br/&gt;echo &quot;===备份开始===&quot;&lt;br/&gt;echo &quot;备份文件存放于${BACKUP}/$DATETIME.tar.gz&quot;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;数据库地址&lt;/span&gt;&lt;br/&gt;HOST=localhost&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;数据库用户名&lt;/span&gt;&lt;br/&gt;DB_USER=root&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;数据库密码&lt;/span&gt;&lt;br/&gt;DB_PW=Ces123456&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;创建备份目录&lt;/span&gt;&lt;br/&gt;[ ! -d &quot;${BACKUP}/$DATETIME&quot; ] &amp;amp;&amp;amp; mkdir -p &quot;${BACKUP}/$DATETIME&quot;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;后台系统数据库&lt;/span&gt;&lt;br/&gt;DATABASE=dy_backgroundms&lt;br/&gt;mysqldump -u${DB_USER} -p${DB_PW} --host=$HOST -q -R --databases $DATABASE | gzip &amp;gt; ${BACKUP}/$DATETIME/$DATABASE.sql.gz&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;投入品监管数据库&lt;/span&gt;&lt;br/&gt;DATABASE=dy_firip&lt;br/&gt;mysqldump -u${DB_USER} -p${DB_PW} --host=$HOST -q -R --databases $DATABASE | gzip &amp;gt; ${BACKUP}/$DATETIME/$DATABASE.sql.gz&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;压缩成tar.gz包&lt;/span&gt;&lt;br/&gt;cd $BACKUP&lt;br/&gt;tar -zcvf $DATETIME.tar.gz $DATETIME&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;删除备份目录&lt;/span&gt;&lt;br/&gt;rm -rf ${BACKUP}/$DATETIME&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;删除30天前备份的数据&lt;/span&gt;&lt;br/&gt;find $BACKUP -mtime +30 -name &quot;*.tar.gz&quot; -exec rm -rf {} \;&lt;br/&gt;echo &quot;===备份成功===&quot;&lt;p&gt;注：find：linux的查找命令，用户查找指定条件的文件。&lt;br/&gt;-mtime：标准语句写法。&lt;br/&gt;＋10：查找10天前的文件，这里用数字代表天数，＋30表示查找30天前的文件。&lt;br/&gt;&quot;*.*&quot;：希望查找的数据类型，&quot;*.jpg&quot;表示查找扩展名为jpg的所有文件，&quot;*&quot;表示查找所有文件，这个可以灵活运用，举一反三&lt;br/&gt;-exec：固定写法。&lt;br/&gt;rm -rf：强制删除文件，包括目录。&lt;br/&gt;{} \; ：固定写法，一对大括号+空格+\;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h12linux&quot;&gt;&lt;span&gt;&lt;strong&gt;12 linux磁盘分区、挂载&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h121&quot;&gt;&lt;span&gt;&lt;strong&gt;12.1 分区的基本知识&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;分区的方式(知道即可)：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVno9.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;Windows下的磁盘分区：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVQRx.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h122linux&quot;&gt;&lt;span&gt;&lt;strong&gt;12.2 Linux分区&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;原理介绍：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuV8sO.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;Linux系统分区的原理示意图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVMJ1.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;硬盘说明：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVlz6.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;查看所有设备(光驱/media，u盘，硬盘)挂载情况&lt;br/&gt;命令：lsblk 或者 lsblk -f 【简记：老师不离开】&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVGLD.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h123&quot;&gt;&lt;span&gt;&lt;strong&gt;12.3 挂载的经典案例&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;说明：&lt;br/&gt;下面我们以&lt;strong&gt;增加一块新的虚拟硬盘2G&lt;/strong&gt;为例来熟悉下磁盘的相关指令和深入理解磁盘分区、挂载、卸载的概念。&lt;br/&gt;图同上【Linux系统分区的原理示意图】。&lt;/li&gt;
&lt;li&gt;如何增加一块硬盘，步骤如下：&lt;br/&gt;1) 虚拟机添加硬盘&lt;br/&gt;2) 分区 &lt;code&gt;fdisk /dev/sdb&lt;/code&gt;&lt;br/&gt;3) 格式化 &lt;code&gt;mkfs -t ext4 /dev/sdb1&lt;/code&gt;&lt;br/&gt;4) 挂载 &lt;code&gt;mount /dev/sdb1 /home/newdisk/&lt;/code&gt; 卸载 &lt;code&gt;umount /dev/sdb1 或者 umount /home/newdisk/&lt;/code&gt;&lt;br/&gt;5) 设置可以自动挂载 &lt;code&gt;vim /etc/fstab&lt;/code&gt;，添加完成后，执行&lt;code&gt;mount -a&lt;/code&gt;即刻生效。&lt;/li&gt;
&lt;li&gt;步骤一：虚拟机添加硬盘&lt;br/&gt;先选中一台虚拟机，然后右键该虚拟机，点击【设置】，然后在硬件列表里选中【硬盘(SCSI)】，点击【添加(A)】，然后一路【下一步】，中间只有【选择磁盘大小】的地方需要修改，直到完成。然后重启系统（才能识别）！&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVwWt.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuV3QK.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVdJI.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;重新查看所有设备(光驱/media，u盘，硬盘)挂载情况&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVNod.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;步骤二：分区命令：&lt;code&gt;fdisk /dev/sdb&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;开始对/sdb分区：
&lt;ul&gt;&lt;li&gt;&lt;span&gt;m 显示命令列表&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;p 显示磁盘分区，同：fdisk -1&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;n 新增分区&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;d 删除分区&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;w 写入并退出&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;说明：开始分区后输入n，新增分区，然后选择p，分区类型为主分区。主分区编号：输入1后回车，是否默认剩余全部空间，回车。最后输入w写入分区并退出，若不保存退出输入q。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVYee.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;步骤三：格式化磁盘&lt;br/&gt;格式化命令：&lt;code&gt;mkfs -t ext4 /dev/sdb1&lt;/code&gt;&lt;br/&gt;其中ext4是格式化后的文件类型&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVtdH.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;步骤四：挂载，先创建一个目录/home/newdisk/，然后将一个分区与一个目录联系起来，挂载命令：&lt;code&gt;mount 设备名称 挂载目录&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuVaFA.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;注意：&lt;/strong&gt;用命令行挂载重启后会失效！&lt;/li&gt;
&lt;li&gt;步骤五：永久挂载：通过修改/etc/fstab文件实现挂载，添加完成后，执行&lt;code&gt;mount -a&lt;/code&gt;即刻生效。&lt;br/&gt;&lt;code&gt;vim /etc/fstab&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuNG9.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h124&quot;&gt;&lt;span&gt;&lt;strong&gt;12.4 查询系统整体磁盘使用情况&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;基本语法：&lt;br/&gt;df -h&lt;/li&gt;
&lt;li&gt;应用实例：&lt;br/&gt;查询系统整体磁盘使用情况。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuax1.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h125&quot;&gt;&lt;span&gt;&lt;strong&gt;12.5 查询指定目录的磁盘占用情况&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;基本语法：&lt;br/&gt;du -h /目录&lt;/li&gt;
&lt;li&gt;查询指定目录的磁盘占用情况，默认为当前目录&lt;br/&gt;-s 指定目录占用大小汇总&lt;br/&gt;-h 带计量单位&lt;br/&gt;-a 含文件&lt;br/&gt;--max-depth=1 子目录深度&lt;br/&gt;-c 列出明细的同时，增加汇总值&lt;/li&gt;
&lt;li&gt;应用实例：&lt;br/&gt;查询&lt;code&gt;/usr/目录&lt;/code&gt;的磁盘占用情况，深度为1&lt;br/&gt;命令：&lt;code&gt;du -ach --max-depth=1 /usr/&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuutPJ.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h126&quot;&gt;&lt;span&gt;&lt;strong&gt;12.6 磁盘情况-工作中实用指令&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;1、统计/home/文件夹下文件的个数&lt;code&gt;ls –l /home/ | grep “^-” | wc -l&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuu0r6.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;2、统计/home/文件夹下目录的个数&lt;code&gt;ls –l /home/ | grep “^d” | wc -l&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuU2R.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;3、统计/home/文件夹下文件的个数，包括子文件夹里的&lt;code&gt;ls –lR /home/ | grep “^-” | wc -l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4、统计/home/文件夹下目录的个数，包括子文件夹里的&lt;code&gt;ls –lR /home/ | grep “^d” | wc -l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;5、以树状显示home目录结构 &lt;code&gt;tree /home/&lt;/code&gt; [没有tree指令咋办，使用yum来安装]&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuwKx.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;效果：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuucPH.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;h13linux&quot;&gt;&lt;span&gt;&lt;strong&gt;13 linux的网络配置&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h131linux&quot;&gt;&lt;span&gt;&lt;strong&gt;13.1 linux的网络配置的原理图&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;目前我们的网络配置采用的是NAT&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuhsP.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h132ip&quot;&gt;&lt;span&gt;&lt;strong&gt;13.2 查看网络IP和网关&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;查看VMware虚拟网络编辑器&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuBqK.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;修改VMnet8的ip地址&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuurVO.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;查看虚拟机的网关&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuusaD.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;查看windows环境的中VMnet8网络配置 (ipconfig指令方式和图形化界面方式)&lt;/strong&gt;&lt;br/&gt;ipconfig指令方式&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuyIe.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图形化界面方式&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuugGd.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;使用ping，测试主机之间网络连通性&lt;/strong&gt;&lt;br/&gt;  Linux ping Windows&lt;br/&gt;  Windows ping Linux&lt;/p&gt;
&lt;h3 id=&quot;h133linux&quot;&gt;&lt;span&gt;&lt;strong&gt;13.3 linux网络环境配置&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h1321ip&quot;&gt;&lt;span&gt;&lt;strong&gt;13.2.1 第一种方法：自动获取ip地址&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuu2RA.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;勾选【自动连接(A)】即可&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuRxI.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;br/&gt;  登陆后，通过界面来设置自动获取ip。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;br/&gt;  1) 配置比较简单。&lt;br/&gt;  2) 每次启动linux后，分配的ip地址可能不一样。不适合做服务器。&lt;/p&gt;
&lt;h4 id=&quot;h1332ip&quot;&gt;&lt;span&gt;&lt;strong&gt;13.3.2 第二种方法：配置固定的ip地址&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;方式一：&lt;br/&gt;通过图像化界面进行操作，系统 -&amp;gt; 首选项 -&amp;gt; 网络连接 -&amp;gt; 选中【System eth0】-&amp;gt; 编辑&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuu4qf.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;此种方式，不需要重启网路服务或者重启虚拟机，因为我们点击【应用】的本质就是重启网络服务！&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;方式二：&lt;br/&gt;直接修改配置文件来指定IP，并可以连接到外网(程序员推荐)，&lt;br/&gt;编辑&lt;code&gt;vim /etc/sysconfig/network-scripts/ifcfg-eth0&lt;/code&gt;（原装的虚拟机）&lt;br/&gt;或者&lt;code&gt;vim /etc/sysconfig/network-scripts/ifcfg-Auto_eth1&lt;/code&gt;（复制的原装的虚拟机，本博主使用的）&lt;br/&gt;要求：将ip地址配置为&lt;code&gt;静态的static（或为none也行）&lt;/code&gt;，ip地址为：192.168.xxx.xxx&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuufMt.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;如果希望配置生效：&lt;br/&gt;  法1) reboot // 重启系统&lt;br/&gt;  法2) service network restart // 重启网络服务&lt;br/&gt;配置文件说明：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuIZ8.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h134&quot;&gt;&lt;span&gt;&lt;strong&gt;13.4 修改主机名&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;1) 查看当前主机名&lt;br/&gt;hostname&lt;/li&gt;
&lt;li&gt;2) 修改linux的主机映射文件 &lt;code&gt;vim /etc/sysconfig/network&lt;/code&gt;&lt;br/&gt;文件中内容如下：&lt;br/&gt;  NETWORKING=yes&lt;br/&gt;  NETWORKING_IPV6=no&lt;br/&gt;  HOSTNAME= hadoop // 写入新的主机名&lt;br/&gt;注意：主机名称不要有“_”下划线，不识别。&lt;/li&gt;
&lt;li&gt;3) 修改 &lt;code&gt;vim /etc/hosts&lt;/code&gt; 文件增加&lt;code&gt;ip和主机的映射&lt;/code&gt;&lt;br/&gt;  192.168.25.204 hadoop&lt;br/&gt;  ….&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuTIg.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;4) 并重启设备，生效。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuqRs.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;5) 如果希望Windows也可以通过&lt;code&gt;主机名&lt;/code&gt;来连接CentOS，进入C:\Windows\System32\drivers\etc\hosts 192.168.25.104 hadoop&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;h14&quot;&gt;&lt;span&gt;&lt;strong&gt;14 进程管理(重点)&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h141&quot;&gt;&lt;span&gt;&lt;strong&gt;14.1 基本介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;在LINUX中，每个执行的程序（代码）都称为一个&lt;code&gt;进程&lt;/code&gt;。每一个进程都分配一个&lt;code&gt;ID号&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如：www服务器。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;每个进程都可能以两种方式存在的。&lt;code&gt;前台与后台&lt;/code&gt;，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行，例如：[sshd,crond]。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;h1411&quot;&gt;&lt;span&gt;&lt;strong&gt;14.1.1 显示系统执行的进程&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;ps命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuodS.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;用法说明：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuHiQ.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;ps -aux // 显示所有的进程&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuubGj.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ps -aux | more // 分页显示所有的进程&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;ps -aux | grep sshd // 查看sshd进程&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuujs0.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;h1412ps&quot;&gt;&lt;span&gt;&lt;strong&gt;14.1.2 ps指令详解&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuXMq.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;应用实例：以全格式显示当前所有的进程，查看进程的父进程。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuLzn.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;演示截图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuzZT.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;查看sshd进程的父进程号是多少？&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKSdU.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h142killkillall&quot;&gt;&lt;span&gt;&lt;strong&gt;14.2 终止进程kill和killall&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;介绍:&lt;br/&gt;若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用kill命令来完成此项任务。&lt;/li&gt;
&lt;li&gt;基本语法：&lt;br/&gt;kill [选项] 进程号 （功能描述：通过进程号杀死进程，-9 强制终止）&lt;br/&gt;killall 进程名称 （功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）&lt;/li&gt;
&lt;li&gt;常用选项：&lt;br/&gt;-9 ： 表示强迫进程立即停止。&lt;/li&gt;
&lt;li&gt;最佳实践：&lt;br/&gt;案例1：踢掉某个非法登录用户。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuuvLV.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;案例2：终止远程登录服务sshd，在适当时候再次重启sshd服务。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKpoF.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;案例3：终止多个gedit编辑器。通过进程名称终止进程&lt;br/&gt;  killall gedit&lt;br/&gt;案例4：强制杀掉一个终端。&lt;br/&gt;  kill 对应的bash的进程号，但是杀不掉。&lt;br/&gt;  kill -9 对应的bash的进程号&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKAQ1.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;注意：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKCi4.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h143pstree&quot;&gt;&lt;span&gt;&lt;strong&gt;14.3 查看进程树pstree&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;基本语法：&lt;br/&gt;pstree [选项] 可以更加直观的来看进程信息&lt;/li&gt;
&lt;li&gt;常用选项：&lt;br/&gt;-p ： 显示进程的PID&lt;br/&gt;-u ： 显示进程的所属用户&lt;/li&gt;
&lt;li&gt;应用实例：&lt;br/&gt;案例1：请用树状的形式显示进程的pid。&lt;br/&gt;  pstree -p&lt;br/&gt;案例2：请用树状的形式进程的用户id。&lt;br/&gt;  pstree –u&lt;br/&gt;  pstree -pu&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h144service&quot;&gt;&lt;span&gt;&lt;strong&gt;14.4 服务(service)管理&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;介绍：&lt;br/&gt;&lt;code&gt;服务(service)&lt;/code&gt;本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql，sshd，防火墙等)，因此我们又称为&lt;code&gt;守护进程&lt;/code&gt;，是Linux中非常重要的知识点。【原理图】&lt;/li&gt;
&lt;li&gt;service管理指令：&lt;br/&gt;service 服务名 [start | stop | restart | reload | status]&lt;br/&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;code&gt;在CentOS7X后，不再使用service，而是systemctl。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用案例：&lt;br/&gt;查看当前防火墙的状况，关闭防火墙和重启防火墙。&lt;br/&gt;service iptables status&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKPJJ.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;细节讨论：&lt;br/&gt;1、关闭或者启用防火墙后，立即生效。[&lt;code&gt;我们可以通过Windows的telnet指令来测试某个端口是否在监听并可以访问&lt;/code&gt;] 命令：&lt;code&gt;telnet ip 端口&lt;/code&gt;&lt;br/&gt;2、说明：&lt;br/&gt;service iptables stop&lt;br/&gt;service iptables start&lt;br/&gt;这种方式只是&lt;code&gt;临时生效&lt;/code&gt;，当重启系统后，还是回归以前对服务的设置。&lt;br/&gt;如果希望设置某个服务自启动或关闭永久生效，要使用&lt;code&gt;chkconfig指令&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;h1441&quot;&gt;&lt;span&gt;&lt;strong&gt;14.4.1 查看服务名称&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;查看服务名称：&lt;br/&gt;方式1：使用&lt;code&gt;setup -&amp;amp;gt; 系统服务&lt;/code&gt; 就可以看到。&lt;br/&gt;在Linux的命令行中输入：setup 回车&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKFzR.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;选择 系统服务 回车，服务前面显示&lt;code&gt;星号&lt;/code&gt;表示的该服务已启动&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKiW9.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;方式2：查看/etc/init.d/服务名称&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKEsx.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;h1442runlevel&quot;&gt;&lt;span&gt;&lt;strong&gt;14.4.2 服务的运行级别(runlevel)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuK3QI.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;一个思考题：&lt;/strong&gt;&lt;br/&gt;  如果不小心将默认的运行级别设置成 0 或者 7 ，怎么处理？&lt;br/&gt;  别怕，进入单用户模式，修改成正常的即可！

&lt;h3 id=&quot;h145chkconfig&quot;&gt;&lt;span&gt;&lt;strong&gt;14.5 chkconfig指令&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;介绍：&lt;br/&gt;通过chkconfig命令可以给每个服务的各个运行级别设置自启动/关闭。&lt;/li&gt;
&lt;li&gt;基本语法：&lt;br/&gt;0) 查看所有服务在各个运行级别自启动/关闭的状态 &lt;code&gt;chkconfig --list&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKeeK.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;1) 查看某个服务在各个运行级别自启动/关闭的状态 &lt;code&gt;chkconfig --list | grep xxx&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKVL6.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;2) 查看某个服务在各个运行级别自启动/关闭的状态 &lt;code&gt;chkconfig 服务名称 --list&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuK8yt.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;3) 设置某个服务，在某个运行级别，开启或关闭 &lt;code&gt;chkconfig --level 5 服务名称 on/off&lt;/code&gt;&lt;br/&gt;例如：设置sshd服务在1运行级别时on。&lt;br/&gt;&lt;code&gt;chkconfig --level 1 sshd off/on&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKmdO.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;4) 设置某个服务，开启或关闭 &lt;code&gt;chkconfig 服务名称 on/off&lt;/code&gt;&lt;br/&gt;例如：使iptables彻底关闭。&lt;br/&gt;&lt;code&gt;chkconfig iptables off&lt;/code&gt; [不管是哪个级别都关闭]&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKKFe.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;code&gt;chkconfig iptables off&lt;/code&gt; 表示在所有level下关闭防火墙&lt;br/&gt;&lt;code&gt;chkconfig iptables on&lt;/code&gt; 表示在所有level下开启防火墙&lt;/li&gt;
&lt;li&gt;应用实例：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKnoD.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h145&quot;&gt;&lt;span&gt;&lt;strong&gt;14.5 动态监控进程&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;介绍：&lt;br/&gt;top与ps命令很相似。它们都用来显示正在执行的进程。top与ps最大的不同之处，在于&lt;code&gt;top在执行一段时间可以更新正在运行的的进程(默认每3秒变化一次)&lt;/code&gt;。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKMJH.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;基本语法：&lt;br/&gt;top [选项]&lt;/li&gt;
&lt;li&gt;选项说明：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuK1SA.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;交互操作说明：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKQWd.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;应用实例：&lt;br/&gt;案例1：如何监视特定用户&lt;br/&gt;  top：输入此命令，按回车键，查看执行的进程。&lt;br/&gt;  u：然后输入“u”回车，再输入用户名，即可。&lt;br/&gt;案例2：如何终止指定的进程。&lt;br/&gt;  top：输入此命令，按回车键，查看执行的进程。&lt;br/&gt;  k：然后输入“k”回车，再输入要结束的进程ID号，即可。&lt;br/&gt;案例3：指定系统状态更新的时间(每隔10秒自动更新)。&lt;br/&gt;  &lt;code&gt;top -d 10&lt;/code&gt; 指定系统更新进程的时间为10秒。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h146&quot;&gt;&lt;span&gt;&lt;strong&gt;14.6 监控网络状态&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;介绍：&lt;br/&gt;netstat指令 用于查看系统网络情况&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKryq.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;基本语法：&lt;br/&gt;netstat [选项]&lt;/li&gt;
&lt;li&gt;选项说明：&lt;br/&gt;-an 按一定顺序排列输出&lt;br/&gt;-p 显示哪个进程在调用&lt;/li&gt;
&lt;li&gt;应用案例：&lt;br/&gt;1、查看服务名称为sshd的服务的信息。&lt;br/&gt;命令：&lt;code&gt;netstat –anp | grep sshd&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKYef.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;2、查看占用22端口的进程。&lt;br/&gt;命令：&lt;code&gt;netstat –anp | grep 22&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;h15&quot;&gt;&lt;span&gt;&lt;strong&gt;15 软件包管理&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h151rpm&quot;&gt;&lt;span&gt;&lt;strong&gt;15.1 rpm包的管理&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;介绍：&lt;br/&gt;一种用于互联网下载包的打包及安装工具，它包含&lt;code&gt;在某些Linux分发版中&lt;/code&gt;。它生成具有&lt;code&gt;.RPM扩展名的文件&lt;/code&gt;。RPM是&lt;code&gt;RedHat Package Manager(RedHat软件包管理工具)&lt;/code&gt;的缩写，类似windows的setup.exe，这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。&lt;br/&gt;Linux的分发版本都有采用(suse、redhat、centos等等)，可以算是公认的行业标准了。&lt;/li&gt;
&lt;li&gt;rpm包的简单查询指令：&lt;br/&gt;查询已安装的rpm列表 &lt;code&gt;rpm –qa | grep xxx&lt;/code&gt;&lt;br/&gt;例如：&lt;code&gt;rpm -qa | grep firefox&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKGOP.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;rpm包名基本格式：&lt;br/&gt;一个rpm包名：firefox-45.0.1-1.el6.centos.x86_64.rpm&lt;br/&gt;  名称：firefox&lt;br/&gt;  版本号：45.0.1-1&lt;br/&gt;  适用操作系统：el6.centos.x86_64，表示centos6.x的64位系统，如果是i686、i386表示32位系统，&lt;code&gt;noarch表示通用&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;rpm包的其它查询指令：&lt;br/&gt;rpm -qa 查询所安装的所有rpm软件包&lt;br/&gt;rpm -qa | more 分页查询所安装的所有rpm软件包&lt;br/&gt;rpm -qa | grep xxx 例如：&lt;code&gt;rpm -qa | grep firefox&lt;/code&gt;&lt;br/&gt;rpm -q 软件包名 查询rpm软件包是否安装，例如：&lt;code&gt;rpm -q firefox&lt;/code&gt;&lt;br/&gt;rpm -qi 软件包名 查询rpm软件包信息。例如：&lt;code&gt;rpm -qi filefox&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKBSs.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;rpm -ql 软件包名 查询软件包中的文件，例如：&lt;code&gt;rpm -ql firefox&lt;/code&gt;&lt;br/&gt;rpm -qf 文件全路径名 查询文件所属的软件包，例如：&lt;code&gt;rpm -qf /etc/passwd&lt;/code&gt;或者 &lt;code&gt;rpm -qf /root/install.log&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKtw8.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h152rpm&quot;&gt;&lt;span&gt;&lt;strong&gt;15.2 卸载rpm包&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;基本语法：&lt;br/&gt;rpm -e rpm包的名称&lt;/li&gt;
&lt;li&gt;应用案例：&lt;br/&gt;删除firefox软件包&lt;br/&gt;&lt;code&gt;rpm -e firefox&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;细节讨论：&lt;br/&gt;1) 如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。&lt;br/&gt;  如：&lt;code&gt;rpm -e foo&lt;/code&gt;&lt;br/&gt;removing these packages would break dependencies:foo is needed by bar-1.0-1&lt;br/&gt;2) 如果我们就是要删除foo这个rpm 包，可以增加参数 &lt;code&gt;--nodeps&lt;/code&gt;，就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行。&lt;br/&gt;  如：&lt;code&gt;rpm -e --nodeps foo&lt;/code&gt; [小心使用]&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h153rpm&quot;&gt;&lt;span&gt;&lt;strong&gt;15.3 安装rpm包&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;基本语法：&lt;br/&gt;rpm -ivh rpm包全路径名称&lt;/li&gt;
&lt;li&gt;参数说明：&lt;br/&gt;-i=install 安装&lt;br/&gt;-v=verbose 提示&lt;br/&gt;-h=hash 进度条&lt;br/&gt;--nodeps 不检测依赖进度&lt;/li&gt;
&lt;li&gt;应用实例： 演示卸载和安装firefox浏览器。 提示：很多的rpm包，就在我们的centos安装的镜像文件中。 安装firefox浏览器步骤：
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1、先找到firefox的安装rpm包，可以挂载上我们的CentOS的ISO文件，也可以从网络上下载firefox的安装rpm包。我们演示的是挂载上我们的CentOS的ISO文件。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2、然后到/media/目录中找到irefox的安装rpm包。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;3、执行安装命令。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKaFg.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;按照下图进行操作&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKNTS.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;此时会发现Linux桌面上出现一个光驱&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKdYQ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;具体安装过程：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKwWj.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h154yum&quot;&gt;&lt;span&gt;&lt;strong&gt;15.4 yum包的管理&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;介绍：&lt;br/&gt;yum 是一个 Shell 前端&lt;code&gt;软件包管理器&lt;/code&gt;。基于RPM包管理，能够从指定的服务器自动下载rpm包并且安装，可以&lt;code&gt;自动处理依赖性关系&lt;/code&gt;，并且&lt;code&gt;一次安装所有依赖的软件包&lt;/code&gt;。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKDln.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;yum的基本指令：&lt;br/&gt;1、查询yum服务器是否有需要安装的软件（一般显示的是最新版本的）&lt;br/&gt;  yum list | grep xxx 查看软件列表&lt;br/&gt;2、安装指定的yum包&lt;br/&gt;  yum install xxx 下载安装&lt;/li&gt;
&lt;li&gt;yum应用实例：&lt;br/&gt;案例：请使用yum的方式来安装firefox指令。&lt;br/&gt;  &lt;code&gt;yum install firefox&lt;/code&gt; //会自动的下载安装适合你系统的最新版本&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKgTU.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;h16&quot;&gt;&lt;span&gt;&lt;strong&gt;16 大厂面试题&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h161&quot;&gt;&lt;span&gt;&lt;strong&gt;16.1 百度面试题&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;问题：Linux常用命令，至少6个&lt;br/&gt;&lt;strong&gt;答：netstat、top、lsblk、find、ps、chkconfig。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;h162&quot;&gt;&lt;span&gt;&lt;strong&gt;16.2 瓜子二手车面试题&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;问题：Linux查看内存、磁盘存储情况、磁盘io读写情况、端口占用、进程等命令。&lt;br/&gt;答：&lt;br/&gt;&lt;strong&gt;top&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;df -lh&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;netstat -tunlp&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;ps –aux | grep 进程名&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;iotop 如果没有该命令，就先yum安装一把&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看端口占用情况：&lt;code&gt;netstat -tunlp&lt;/code&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKsO0.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;查看磁盘io读写：&lt;code&gt;iotop&lt;/code&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuK6mV.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h17&quot;&gt;&lt;span&gt;&lt;strong&gt;17 感悟分享&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;唐朝有《卖炭翁》--背后有故事，以后深究之。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/26/kuKcwT.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;宋朝有《卖油翁》--背后有故事，以后深究之。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/27/kuJ1qs.jpg&quot; alt=&quot;&quot;/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;  陈康肃公尧咨善射，当世无双，公亦以此自矜。尝射于家圃，有卖油翁释担而立，睨之，久而不去。见其发矢十中八九，但微颔之。康肃问曰：“汝亦知射乎？吾射不亦精乎？”翁曰：“&lt;code&gt;无他，但手熟尔。&lt;/code&gt;”康肃忿然曰：“尔安敢轻吾射?”翁曰：“以我酌油知之。”乃取一葫芦置于地，以钱覆其口，徐以杓酌油沥之，自钱孔入，而钱不湿。因曰：“&lt;code&gt;我亦无他，惟手熟尔。&lt;/code&gt;”康肃笑而遣之。&lt;br/&gt;  《卖油翁》这则故事的作者是欧阳修，出自他的私家笔记《归田录》。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老黄牛精神&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/01/27/kuJlrj.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h18&quot;&gt;&lt;span&gt;&lt;strong&gt;18 资料附录&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;尚硅谷大数据之Linux视频&lt;br/&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1wMTp4_Fh9Yl1CPjUNOydaw&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1wMTp4_Fh9Yl1CPjUNOydaw&lt;/a&gt;&lt;br/&gt;密码：6q4k&lt;br/&gt;  视频质量：优良&lt;br/&gt;  视频总个数：53个&lt;br/&gt;  视频总时长：15:01:16&lt;br/&gt;  建议学习时长：5天&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 26 Jan 2019 16:56:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>10 组管理和权限管理10.1 Linux组的基本介绍10.2 文件/目录的所有者10.3 文件/目录的所在组10.4 权限的基本介绍10.5 rwx权限详解10.6 修改权限指令-chmod10.7</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10325450.html</dc:identifier>
</item>
<item>
<title>blfs学习笔记-制作一个简单的桌面系统 - 仁人</title>
<link>http://www.cnblogs.com/renren-study-notes/p/10325336.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renren-study-notes/p/10325336.html</guid>
<description>&lt;p&gt;大概思路：&lt;/p&gt;
&lt;p&gt;lfs（系统）+xorg（驱动）+i3-wm（窗口+桌面）+lightdm（显示管理器+登录管理器）&lt;/p&gt;
&lt;p&gt;链接：&lt;/p&gt;
&lt;p&gt;lfs学习笔记系列：&lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10199344.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10199344.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;                            &lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10199381.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10199381.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;                            &lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10199965.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10199965.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;                           &lt;a target=&quot;_blank&quot;&gt; https://www.cnblogs.com/renren-study-notes/p/10279446.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;blfs书籍内容的学习笔记：&lt;/p&gt;
&lt;p&gt;总页：&lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10214504.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10214504.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前几章节的脚本：&lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10287905.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10287905.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;构建xorg：&lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10291901.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10291901.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;构建i3-wm：&lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10309977.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10309977.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;构建lightdm：&lt;a href=&quot;https://www.cnblogs.com/renren-study-notes/p/10325321.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/renren-study-notes/p/10325321.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 26 Jan 2019 15:49:00 +0000</pubDate>
<dc:creator>仁人</dc:creator>
<og:description>大概思路： lfs（系统）+xorg（驱动）+i3-wm（窗口+桌面）+lightdm（显示管理器+登录管理器） 链接： lfs学习笔记系列：https://www.cnblogs.com/renre</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renren-study-notes/p/10325336.html</dc:identifier>
</item>
<item>
<title>iOS学小程序从0到发布(适合iOS开发看) - 二进制||</title>
<link>http://www.cnblogs.com/wangcongiOS/p/10325325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangcongiOS/p/10325325.html</guid>
<description>&lt;p&gt;Emmmm，最近一波失业潮。富某康、某团、摩某、京某、知某、某浪、58 某大面积裁员，那么在这个千钧一发之际，单纯iOS开发也着实不好过，回过头看一下，裁掉的都是单一选手，为了节约成本公司留下的都是身兼多职的全栈开发工程师。&lt;/p&gt;
&lt;p&gt;那么iOS, 有些选手就要找对方向再学一手以备下次被裁员的不是自己。HTML，CSS, JS,小程序，React， React Native浮现在选手面前。 好，进入正题，今天开始从0入门小程序。咦，等等，为什么叫选手呢，因为当前环境下经济不景气都是去竞争口饭吃的，就像是在比赛，故本文称之为选手。&lt;/p&gt;
&lt;p&gt;首先，学习小程序开发对于学习iOS开发成本实在是低，低到什么程度呢？低到你单看这篇文章就可以开发并发布小程序。&lt;/p&gt;
&lt;p&gt;一：小程序注册&lt;/p&gt;
&lt;p&gt;注册小程序帐号&lt;/p&gt;
&lt;p&gt;在微信公众平台官网首页（&lt;a href=&quot;https://mp.weixin.qq.com/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;mp.weixin.qq.com&lt;/a&gt;）点击右上角的“立即注册”按钮。&lt;/p&gt;
&lt;p&gt;关于小程序账号注册填写从相关的各位选手可以去微信公众平台自己看官方文档这里不做详细介绍&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/introduction/index.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://developers.weixin.qq.com/miniprogram/introduction/index.html&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;980&quot; data-height=&quot;473&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-cae3ca9a5da76e8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/980/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-cae3ca9a5da76e8c.png&quot; data-original-width=&quot;980&quot; data-original-height=&quot;473&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;378207&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;二：这篇文章重点要介绍的是开发工具和代码方面的知识。&lt;/p&gt;
&lt;p&gt;微信开发工具下载地址:&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么现在我已经下载好了&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;966&quot; data-height=&quot;1328&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-26b89855a7215801.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/966/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-26b89855a7215801.png&quot; data-original-width=&quot;966&quot; data-original-height=&quot;1328&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;966916&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;点击小程序项目，进入&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1252&quot; data-height=&quot;948&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-ca0c1b75cc4a0d0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-ca0c1b75cc4a0d0f.png&quot; data-original-width=&quot;1252&quot; data-original-height=&quot;948&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;202421&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如图，我这是之前已经创建好的项目，会显示在图上右边，如果是本地没有小程序项目，则创建就可以了，相信我们的iOS开发们这些都不是事，emm不行，怕有些 人还是不会，老规矩上图&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1930&quot; data-height=&quot;1396&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-142e637fc98838de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-142e637fc98838de.png&quot; data-original-width=&quot;1930&quot; data-original-height=&quot;1396&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;614139&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;好，终于看到代码了，到这里才是本文接下来要讲的重点。&lt;/p&gt;
&lt;p&gt;先来看下我们今天要实现的效果。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;320&quot; data-height=&quot;618&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-c85e9fe02e663ea9.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/320/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-c85e9fe02e663ea9.gif&quot; data-original-width=&quot;320&quot; data-original-height=&quot;618&quot; data-original-format=&quot;image/gif&quot; data-original-filesize=&quot;2318102&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;再来整体看下代码架构&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2572&quot; data-height=&quot;1714&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-79b291a25827f45b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-79b291a25827f45b.png&quot; data-original-width=&quot;2572&quot; data-original-height=&quot;1714&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;517091&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;先来看四种文件，.js, .json,.wxss,.wxml。&lt;/p&gt;
&lt;p&gt;.js处理逻辑，数据，获取网络请求的数据即在这里面&lt;/p&gt;
&lt;p&gt;.json 配置文件，比如tabbar的配置，navigationbar的配置等&lt;/p&gt;
&lt;p&gt;.wxml创建的控件，比如view，button，map组件&lt;/p&gt;
&lt;p&gt;.wxss控件的修饰，比如frame，backgroudcolor等&lt;/p&gt;
&lt;p&gt;看到这里是不是感觉有点跟MVVM设计模式相似呀,不同功能的代码分文件来写，一目了然。&lt;/p&gt;
&lt;p&gt;好，先看示例首页搜索页面的输入框。&lt;/p&gt;
&lt;p&gt;.wxml里&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;searchPut&quot; &lt;span class=&quot;hljs-attr&quot;&gt;bindconfirm=&lt;span class=&quot;hljs-string&quot;&gt;&quot;shouldDone&quot; &lt;span class=&quot;hljs-attr&quot;&gt;placeholder=&lt;span class=&quot;hljs-string&quot;&gt;&quot;输入来搜索🔍&quot; &lt;span class=&quot;hljs-attr&quot;&gt;type=&lt;span class=&quot;hljs-string&quot;&gt;&quot;text&quot; &lt;span class=&quot;hljs-attr&quot;&gt;confirm-type=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Search&quot;&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;input&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;table&quot;&amp;gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;'contentview' &lt;span class=&quot;hljs-attr&quot;&gt;wx:for=&lt;span class=&quot;hljs-string&quot;&gt;&quot;{{searchResults}}&quot; &lt;span class=&quot;hljs-attr&quot;&gt;wx:for-index=&lt;span class=&quot;hljs-string&quot;&gt;&quot;bindex&quot;&amp;gt;
   &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;listitem&quot;  &lt;span class=&quot;hljs-attr&quot;&gt;bindtap=&lt;span class=&quot;hljs-string&quot;&gt;'didSelectCell'  &lt;span class=&quot;hljs-attr&quot;&gt;data-bindex=&lt;span class=&quot;hljs-string&quot;&gt;'{{bindex}}'&amp;gt;
     &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;image &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;img&quot; &lt;span class=&quot;hljs-attr&quot;&gt;src=&lt;span class=&quot;hljs-string&quot;&gt;&quot;{{item.cover_path}}&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;image&amp;gt;
      &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;right&quot;&amp;gt;
          &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&amp;gt;{{item.title}}&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
          &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;nameDes&quot;&amp;gt;{{item.intro}}&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
          &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;bottomView&quot;&amp;gt;
           &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;'playtimes'&amp;gt;播放次数:{{item.play}}&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
           &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;'length'&amp;gt;总共:{{item.tracks}}集&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
          &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
      &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图不同颜色框对应不同UI组件&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2742&quot; data-height=&quot;1388&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-13733bba12ac812f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-13733bba12ac812f.png&quot; data-original-width=&quot;2742&quot; data-original-height=&quot;1388&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;754265&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;.wxss&lt;/p&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.searchPut
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;margin-left: &lt;span class=&quot;hljs-number&quot;&gt;20rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;margin-right: &lt;span class=&quot;hljs-number&quot;&gt;20rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;height: &lt;span class=&quot;hljs-number&quot;&gt;60rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;border: &lt;span class=&quot;hljs-number&quot;&gt;2rpx ridge black;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.table
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;top: &lt;span class=&quot;hljs-number&quot;&gt;80rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;width: &lt;span class=&quot;hljs-number&quot;&gt;100vw;
  &lt;span class=&quot;hljs-attribute&quot;&gt;margin-bottom: &lt;span class=&quot;hljs-number&quot;&gt;0rpx;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.contentview
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;padding: &lt;span class=&quot;hljs-number&quot;&gt;0;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.listitem{  
  &lt;span class=&quot;hljs-attribute&quot;&gt;display: flex;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;flex-direction: row;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;padding:&lt;span class=&quot;hljs-number&quot;&gt;20rpx;  
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.img
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;width: &lt;span class=&quot;hljs-number&quot;&gt;100rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;height: &lt;span class=&quot;hljs-number&quot;&gt;100rpx;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.right
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;flex: &lt;span class=&quot;hljs-number&quot;&gt;1;
  &lt;span class=&quot;hljs-attribute&quot;&gt;width: &lt;span class=&quot;hljs-number&quot;&gt;590rpx;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;margin-left: &lt;span class=&quot;hljs-number&quot;&gt;20rpx;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;display: flex;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;flex-direction: column;  
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.name
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;font-size: &lt;span class=&quot;hljs-number&quot;&gt;35rpx;
}
&lt;span class=&quot;hljs-selector-class&quot;&gt;.nameDes
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;font-size: &lt;span class=&quot;hljs-number&quot;&gt;30rpx;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.bottomView
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;flex: &lt;span class=&quot;hljs-number&quot;&gt;1; 
  &lt;span class=&quot;hljs-attribute&quot;&gt;display: flex;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;flex-direction: row;  
  &lt;span class=&quot;hljs-attribute&quot;&gt;justify-content:space-between;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.playtimes
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;font-size: &lt;span class=&quot;hljs-number&quot;&gt;30rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;color: gray;
  &lt;span class=&quot;hljs-attribute&quot;&gt;vertical-align: center;
}

&lt;span class=&quot;hljs-selector-class&quot;&gt;.length
{
  &lt;span class=&quot;hljs-attribute&quot;&gt;font-size: &lt;span class=&quot;hljs-number&quot;&gt;30rpx;
  &lt;span class=&quot;hljs-attribute&quot;&gt;color: gray;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.searchPut ：margin-left ：距离左边， 那距离右边同理margin-right&lt;br/&gt;讲下border：border: 2rpx ridge black; 代表边框宽2rpx，样式ridge，颜色黑色&lt;br/&gt;2..table： width: 100vw;代表铺满宽，即100%&lt;br/&gt;3..listitem： display：flex；采用flex弹性布局，flex-direction: row; 即竖向布局，即我们熟悉的tableview样式，同理flex-direction: column; 横向布局。padding:20rpx;即向里周边都缩进20rpx&lt;br/&gt;4..bottomView ： justify-content:space-between;justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。&lt;br/&gt;| flex-start | 默认值。项目位于容器的开头。 | &lt;a href=&quot;http://www.runoob.com/try/playit.php?f=playcss_justify-content&amp;amp;preval=flex-start&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;测试 »&lt;/a&gt; |&lt;br/&gt;| flex-end | 项目位于容器的结尾。 | &lt;a href=&quot;http://www.runoob.com/try/playit.php?f=playcss_justify-content&amp;amp;preval=flex-end&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;测试 »&lt;/a&gt; |&lt;br/&gt;| center | 项目位于容器的中心。 | &lt;a href=&quot;http://www.runoob.com/try/playit.php?f=playcss_justify-content&amp;amp;preval=center&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;测试 »&lt;/a&gt; |&lt;br/&gt;| space-between | 项目位于各行之间留有空白的容器内。 | &lt;a href=&quot;http://www.runoob.com/try/playit.php?f=playcss_justify-content&amp;amp;preval=space-between&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;测试 »&lt;/a&gt; |&lt;br/&gt;| space-around | 项目位于各行之前、之间、之后都留有空白的容器内。 | &lt;a href=&quot;http://www.runoob.com/try/playit.php?f=playcss_justify-content&amp;amp;preval=space-around&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;测试 »&lt;/a&gt; |&lt;br/&gt;| initial | 设置该属性为它的默认值。请参阅 &lt;a href=&quot;http://www.runoob.com/cssref/css-initial.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;initial&lt;/em&gt;&lt;/a&gt;。 | &lt;a href=&quot;http://www.runoob.com/try/playit.php?f=playcss_justify-content&amp;amp;preval=initial&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;测试 »&lt;/a&gt; |&lt;br/&gt;| inherit | 从父元素继承该属性。请参阅 &lt;a href=&quot;http://www.runoob.com/cssref/css-inherit.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;inherit&lt;/em&gt;&lt;/a&gt;。 |&lt;br/&gt;5.其他诸如：color，font-size这些不多做解释。&lt;/p&gt;
&lt;p&gt;下面来到了.js文件有了这一步，咸鱼变活鱼，界面搭好了，就等渠里通水了。&lt;/p&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;code class=&quot;javascript&quot;&gt;age({

  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先输入搜索的内容后，点击搜索，iOS里应该是有个textfieldshouldReturn，这个事件。那么小程序同理，我们之前已经在wxml里绑定过了，那就是bindconfirm=&quot;shouldDone&quot;这行代码，bindconfirm就是这个事件，我们绑定上之后，在js文件里实现这个shouldDone方法，然后再shouldDone方法里进行网络请求去获取数据就好。&lt;/p&gt;
&lt;p&gt;说到网络请求，微信小程序的封装那是厉害的一批，&lt;br/&gt;看图&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1720&quot; data-height=&quot;992&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-8debfffba797f493.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-8debfffba797f493.png&quot; data-original-width=&quot;1720&quot; data-original-height=&quot;992&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;191049&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;wx.request就是调网络请求，url是请求的链接，method是请求的方法get，post。&lt;br/&gt;post需要传参的话下面再加个data参数传进去就好。&lt;br/&gt;success就是请求成功的回调，res就是response，更神奇的是，返回数据的解析如图上：var results = res.data.album.docs; 竟然直接点语法就把json给解析了，如图所示的格式&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;428&quot; data-height=&quot;252&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-1e8772765558ed0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/428/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-1e8772765558ed0f.png&quot; data-original-width=&quot;428&quot; data-original-height=&quot;252&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;185953&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;是不是太方便了。&lt;br/&gt;有了数据了，下面来处理数据，如图&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;666&quot; data-height=&quot;1120&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-64d95b6adbbfcad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/666/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-64d95b6adbbfcad0.png&quot; data-original-width=&quot;666&quot; data-original-height=&quot;1120&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;139247&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;播放次数，实际服务器返回的“play”这个字段播放次数是64168345，那我们要转为6416.8万，这该怎么转呢，如果是OC代码那我们就得心应手，但这里是小程序。&lt;br/&gt;首先这是一个列表，每条数据里都有play这个字段，两种方案：1.就是要遍历下数组，然后把数组中的这个字段对应的值做下修改。2.直接在对控件赋值的时候做转换（也就是对应iOS里cellforrow里给控件赋值的时候）。那我们现在wxml里已经写好了，直接取的就是play这个字段的值，并没有做转换，如图&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;872&quot; data-height=&quot;282&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-e12f75f3223bc2a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/872/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-e12f75f3223bc2a1.png&quot; data-original-width=&quot;872&quot; data-original-height=&quot;282&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;71903&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;suo&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;所以我们现在采用第一种方法&lt;/p&gt;
&lt;p&gt;遍历数组&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1506&quot; data-height=&quot;390&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-8b86b8001b44764b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-8b86b8001b44764b.png&quot; data-original-width=&quot;1506&quot; data-original-height=&quot;390&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;192847&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;那么现在数据就修改完了，要显示了&lt;/p&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code class=&quot;css&quot;&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;that&lt;span class=&quot;hljs-selector-class&quot;&gt;.setData({
          &lt;span class=&quot;hljs-attribute&quot;&gt;searchResults: results,
        })
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这句话就是把我们得到的返回的数据赋值给我们在data里定义的searchResults&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;558&quot; data-height=&quot;304&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-baff713f546cc918.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/558/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-baff713f546cc918.png&quot; data-original-width=&quot;558&quot; data-original-height=&quot;304&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;23162&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;同时，wxml里绑定的searchResults，就会刷新出来界面。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1684&quot; data-height=&quot;660&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-5647f9246b703ed9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-5647f9246b703ed9.png&quot; data-original-width=&quot;1684&quot; data-original-height=&quot;660&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;186999&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;到此首页搜索界面的实现介绍完毕。下班了，先回家吃饭了，饿死。回来继续&lt;/p&gt;
&lt;p&gt;感谢各位看官！&lt;/p&gt;
&lt;p&gt;代码地址:&lt;a href=&quot;https://git.dev.tencent.com/cong_Wang/xcx.git&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://git.dev.tencent.com/cong_Wang/xcx.git&lt;/a&gt;&lt;br/&gt;git clone 即可下载下来代码。&lt;br/&gt;如图：已经下载下来了&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;870&quot; data-height=&quot;854&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-e65e026a7755aa8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/870/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-e65e026a7755aa8d.png&quot; data-original-width=&quot;870&quot; data-original-height=&quot;854&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;53005&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;那么怎么跑这个代码呢？我们打开微信开发工具，&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1628&quot; data-height=&quot;1104&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-bc87330957280b1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-bc87330957280b1e.png&quot; data-original-width=&quot;1628&quot; data-original-height=&quot;1104&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;210259&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;点击+号，即新建项目，导入项目，选择代码的目录，选择测试号，即会为你生成一个测试appid，点击导入按钮。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1628&quot; data-height=&quot;1104&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-66859a9bba4780e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-66859a9bba4780e4.png&quot; data-original-width=&quot;1628&quot; data-original-height=&quot;1104&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;118963&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;大功告成，现在就可以跑项目了&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;2048&quot; data-height=&quot;1554&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3467163-a433247b8e0d3230.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/3467163-a433247b8e0d3230.png&quot; data-original-width=&quot;2048&quot; data-original-height=&quot;1554&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;250118&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 26 Jan 2019 15:43:00 +0000</pubDate>
<dc:creator>二进制||</dc:creator>
<og:description>Emmmm，最近一波失业潮。富某康、某团、摩某、京某、知某、某浪、58 某大面积裁员，那么在这个千钧一发之际，单纯iOS开发也着实不好过，回过头看一下，裁掉的都是单一选手，为了节约成本公司留下的都是身</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangcongiOS/p/10325325.html</dc:identifier>
</item>
<item>
<title>浅析C# Dictionary实现原理 - InCerry</title>
<link>http://www.cnblogs.com/InCerry/p/10325290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/InCerry/p/10325290.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;本篇文章配图以及文字其实整理出来很久了，但是由于各种各样的原因推迟到现在才发出来，还有之前立Flag的《多线程编程》的笔记也都已经写好了，只是说还比较糙，需要找个时间整理一下才能和大家见面。&lt;/p&gt;
&lt;p&gt;对于C#中的&lt;code&gt;Dictionary&lt;/code&gt;类相信大家都不陌生，这是一个&lt;code&gt;Collection(集合)&lt;/code&gt;类型，可以通过&lt;strong&gt;Key/Value(键值对&lt;/strong&gt;的形式来存放数据；该类最大的优点就是它查找元素的时间复杂度接近&lt;code&gt;O(1)&lt;/code&gt;，实际项目中常被用来做一些数据的本地缓存，提升整体效率。&lt;/p&gt;
&lt;p&gt;那么是什么样的设计能使得&lt;code&gt;Dictionary&lt;/code&gt;类能实现&lt;code&gt;O(1)&lt;/code&gt;的时间复杂度呢？那就是本篇文章想和大家讨论的东西；这些都是个人的一些理解和观点，&lt;strong&gt;如有表述不清楚、错误之处，请大家批评指正，共同进步。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二理论知识&quot;&gt;二、理论知识&lt;/h2&gt;
&lt;p&gt;对于Dictionary的实现原理，其中有两个关键的算法，一个是&lt;strong&gt;Hash&lt;/strong&gt;算法，一个是用于应对Hash碰撞&lt;strong&gt;冲突解决&lt;/strong&gt;算法。&lt;/p&gt;
&lt;h3 id=&quot;hash算法&quot;&gt;1、Hash算法&lt;/h3&gt;
&lt;p&gt;Hash算法是一种&lt;strong&gt;数字摘要&lt;/strong&gt;算法，它能将不定长度的二进制数据集给&lt;strong&gt;映射&lt;/strong&gt;到一个较短的二进制长度数据集，常见的MD5算法就是一种Hash算法，通过MD5算法可对任何数据生成数字摘要。而实现了Hash算法的函数我们叫她&lt;strong&gt;Hash函数&lt;/strong&gt;。Hash函数有以下几点特征。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;相同的数据进行Hash运算，得到的结果一定相同。&lt;code&gt;HashFunc(key1) == HashFunc(key1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不同的数据进行Hash运算，其结果也可能会相同，(&lt;strong&gt;Hash会产生碰撞&lt;/strong&gt;)。&lt;code&gt;key1 != key2 =&amp;gt; HashFunc(key1) == HashFunc(key2)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Hash运算时不可逆的，不能由key获取原始的数据。&lt;code&gt;key1 =&amp;gt; hashCode&lt;/code&gt;但是&lt;code&gt;hashCode =\=&amp;gt; key1&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;下图就是Hash函数的一个简单说明，任意长度的数据通过HashFunc映射到一个较短的数据集中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232146262-598525962.png&quot; alt=&quot;1548491108167&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于Hash碰撞下图很清晰的就解释了，可从图中得知&lt;code&gt;Sandra Dee&lt;/code&gt; 和 &lt;code&gt;John Smith&lt;/code&gt;通过hash运算后都落到了&lt;code&gt;02&lt;/code&gt;的位置，产生了碰撞和冲突。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232145973-1148017578.png&quot; alt=&quot;1548485331574&quot;/&gt;&lt;br/&gt;常见的构造Hash函数的算法有以下几种。&lt;/p&gt;
&lt;blockquote readability=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;1. 直接寻址法：&lt;/strong&gt;取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，当中a和b为常数（这样的散列函数叫做自身函数）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 数字分析法：&lt;/strong&gt;分析一组数据，比方一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体同样，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构成散列地址，则冲突的几率会明显减少。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 平方取中法：&lt;/strong&gt;取keyword平方后的中间几位作为散列地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 折叠法：&lt;/strong&gt;将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 随机数法：&lt;/strong&gt;选择一随机函数，取keyword的随机值作为散列地址，通经常使用于keyword长度不同的场合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 除留余数法：&lt;/strong&gt;取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p&amp;lt;=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，若p选的不好，容易产生碰撞.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;hash桶算法&quot;&gt;2、Hash桶算法&lt;/h3&gt;
&lt;p&gt;说到Hash算法大家就会想到&lt;strong&gt;Hash表&lt;/strong&gt;，一个Key通过Hash函数运算后可快速的得到hashCode，通过hashCode的映射可直接Get到Value，但是hashCode一般取值都是非常大的，经常是2^32以上，不可能对每个hashCode都指定一个映射。&lt;/p&gt;
&lt;p&gt;因为这样的一个问题，所以人们就将生成的HashCode以分段的形式来映射，把每一段称之为一个&lt;strong&gt;Bucket（桶）&lt;/strong&gt;，一般常见的Hash桶就是直接对结果取余。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;假设将生成的hashCode可能取值有2^32个，然后将其切分成一段一段，使用&lt;strong&gt;8&lt;/strong&gt;个桶来映射，那么就可以通过&lt;code&gt;bucketIndex = HashFunc(key1) % 8&lt;/code&gt;这样一个算法来确定这个hashCode映射到具体的哪个桶中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家可以看出来，通过hash桶这种形式来进行映射，所以会加剧hash的冲突。&lt;/p&gt;
&lt;h3 id=&quot;解决冲突算法&quot;&gt;3、解决冲突算法&lt;/h3&gt;
&lt;p&gt;对于一个hash算法，不可避免的会产生冲突，那么产生冲突以后如何处理，是一个很关键的地方，目前常见的冲突解决算法有&lt;strong&gt;拉链法(Dictionary实现采用的)、开放定址法、再Hash法、公共溢出分区法&lt;/strong&gt;，本文只介绍拉链法与再Hash法，对于其它算法感兴趣的同学可参考文章最后的参考文献。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;1. 拉链法：&lt;/strong&gt;这种方法的思路是将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 再Hash法：&lt;/strong&gt;顾名思义就是将key使用其它的Hash函数再次Hash，直到找到不冲突的位置为止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于拉链法有一张图来描述，通过在冲突位置建立单链表，来解决冲突。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232145660-1825878982.png&quot; alt=&quot;1548485607652&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三dictionary实现&quot;&gt;三、Dictionary实现&lt;/h2&gt;
&lt;p&gt;Dictionary实现我们主要对照源码来解析，目前对照源码的版本是&lt;strong&gt;.Net Framwork 4.7&lt;/strong&gt;。地址可戳一戳这个链接 源码地址：&lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,d3599058f8d79be0&quot;&gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这一章节中主要介绍Dictionary中几个比较关键的类和对象，然后跟着代码来走一遍插入、删除和扩容的流程，相信大家就能理解它的设计原理。&lt;/p&gt;
&lt;h3 id=&quot;entry结构体&quot;&gt;1. Entry结构体&lt;/h3&gt;
&lt;p&gt;首先我们引入&lt;strong&gt;Entry&lt;/strong&gt;这样一个结构体，它的定义如下代码所示。这是Dictionary种存放数据的最小单位，调用&lt;code&gt;Add(Key,Value)&lt;/code&gt;方法添加的元素都会被封装在这样的一个结构体中。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private struct Entry {
    public int hashCode;    // 除符号位以外的31位hashCode值, 如果该Entry没有被使用，那么为-1
    public int next;        // 下一个元素的下标索引，如果没有下一个就为-1
    public TKey key;        // 存放元素的键
    public TValue value;    // 存放元素的值
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其它关键私有变量&quot;&gt;2. 其它关键私有变量&lt;/h3&gt;
&lt;p&gt;除了Entry结构体外，还有几个关键的私有变量，其定义和解释如下代码所示。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private int[] buckets;      // Hash桶
private Entry[] entries;    // Entry数组，存放元素
private int count;          // 当前entries的index位置
private int version;        // 当前版本，防止迭代过程中集合被更改
private int freeList;       // 被删除Entry在entries中的下标index，这个位置是空闲的
private int freeCount;      // 有多少个被删除的Entry，有多少个空闲的位置
private IEqualityComparer&amp;lt;TKey&amp;gt; comparer;   // 比较器
private KeyCollection keys;     // 存放Key的集合
private ValueCollection values;     // 存放Value的集合&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，需要注意的是&lt;code&gt;buckets、entries&lt;/code&gt;这两个数组，这是实现Dictionary的关键。&lt;/p&gt;
&lt;h3 id=&quot;dictionary---add操作&quot;&gt;3. Dictionary - Add操作&lt;/h3&gt;
&lt;p&gt;经过上面的分析，相信大家还不是特别明白为什么需要这么设计，需要这么做。那我们现在来走一遍Dictionary的Add流程，来体会一下。&lt;/p&gt;
&lt;p&gt;首先我们用图的形式来描述一个Dictionary的数据结构，其中只画出了关键的地方。桶大小为4以及Entry大小也为4的一个数据结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232145341-1401582594.png&quot; alt=&quot;1548491185593&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们假设需要执行一个&lt;strong&gt;Add&lt;/strong&gt;操作，&lt;code&gt;dictionary.Add(&quot;a&quot;,&quot;b&quot;)&lt;/code&gt;，其中&lt;code&gt;key = &quot;a&quot;,value = &quot;b&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;根据&lt;strong&gt;key&lt;/strong&gt;的值，计算出它的hashCode。我们假设&quot;a&quot;的hash值为6（&lt;code&gt;GetHashCode(&quot;a&quot;) = 6&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通过对hashCode取余运算，计算出该hashCode落在哪一个buckets桶中。现在桶的长度（&lt;code&gt;buckets.Length&lt;/code&gt;）为4，那么就是&lt;code&gt;6 % 4&lt;/code&gt;最后落在&lt;code&gt;index&lt;/code&gt;为2的桶中，也就是&lt;code&gt;buckets[2]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;避开一种其它情况不谈，接下来它会将&lt;code&gt;hashCode、key、value&lt;/code&gt;等信息存入&lt;code&gt;entries[count]&lt;/code&gt;中，因为&lt;code&gt;count&lt;/code&gt;位置是空闲的；继续&lt;code&gt;count++&lt;/code&gt;指向下一个空闲位置。上图中第一个位置，index=0就是空闲的，所以就存放在&lt;code&gt;entries[0]&lt;/code&gt;的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;将&lt;code&gt;Entry&lt;/code&gt;的下标&lt;code&gt;entryIndex&lt;/code&gt;赋值给&lt;code&gt;buckets&lt;/code&gt;中对应下标的&lt;code&gt;bucket&lt;/code&gt;。步骤3中是存放在&lt;code&gt;entries[0]&lt;/code&gt;的位置，所以&lt;code&gt;buckets[2]=0&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;最后&lt;code&gt;version++&lt;/code&gt;，集合发生了变化，所以版本需要+1。&lt;strong&gt;只有增加、替换和删除元素才会更新版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上文中的步骤1~5只是方便大家理解，实际上有一些偏差，后文再谈Add操作小节中会补充。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;完成上面Add操作后，数据结构更新成了下图这样的形式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232144972-327613048.png&quot; alt=&quot;1548492100757&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样是理想情况下的操作，一个bucket中只有一个hashCode没有碰撞的产生，但是实际上是会经常产生碰撞；那么Dictionary类中又是如何解决碰撞的呢。&lt;/p&gt;
&lt;p&gt;我们继续执行一个&lt;strong&gt;Add&lt;/strong&gt;操作，&lt;code&gt;dictionary.Add(&quot;c&quot;,&quot;d&quot;)&lt;/code&gt;，假设&lt;code&gt;GetHashCode(“c”)=6&lt;/code&gt;，最后&lt;code&gt;6 % 4 = 2&lt;/code&gt;。最后桶的&lt;code&gt;index&lt;/code&gt;也是2，按照之前的&lt;strong&gt;步骤1~3&lt;/strong&gt;是没有问题的，执行完后数据结构如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232144707-1105753624.png&quot; alt=&quot;1548493287583&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果继续执行&lt;strong&gt;步骤4&lt;/strong&gt;那么&lt;code&gt;buckets[2] = 1&lt;/code&gt;，然后原来的&lt;code&gt;buckets[2]=&amp;gt;entries[0]&lt;/code&gt;的关系就会丢失，这是我们不愿意看到的。现在Entry中的&lt;code&gt;next&lt;/code&gt;就发挥大作用了。&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;如果对应的&lt;code&gt;buckets[index]&lt;/code&gt;有其它元素已经存在，那么会执行以下两条语句，让新的&lt;code&gt;entry.next&lt;/code&gt;指向之前的元素，让&lt;code&gt;buckets[index]&lt;/code&gt;指向现在的新的元素，就构成了一个单链表。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;entries[index].next = buckets[targetBucket];
...
buckets[targetBucket] = index;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上&lt;strong&gt;步骤4&lt;/strong&gt;也就是做一个这样的操作，并不会去判断是不是有其它元素，因为&lt;code&gt;buckets&lt;/code&gt;中桶初始值就是-1，不会造成问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过上面的步骤以后，数据结构就更新成了下图这个样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232144436-391161641.png&quot; alt=&quot;1548494357566&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dictionary---find操作&quot;&gt;4. Dictionary - Find操作&lt;/h3&gt;
&lt;p&gt;为了方便演示如何查找，我们继续Add一个元素&lt;code&gt;dictionary.Add(&quot;e&quot;,&quot;f&quot;)&lt;/code&gt;，&lt;code&gt;GetHashCode(“e”) = 7; 7% buckets.Length=3&lt;/code&gt;,数据结构如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232143619-706622936.png&quot; alt=&quot;1548494583006&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设我们现在执行这样一条语句&lt;code&gt;dictionary.GetValueOrDefault(&quot;a&quot;)&lt;/code&gt;，会执行以下步骤.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;获取key的hashCode，计算出所在的桶位置。我们之前提到，&quot;a&quot;的&lt;code&gt;hashCode=6&lt;/code&gt;，所以最后计算出来&lt;code&gt;targetBucket=2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;buckets[2]=1&lt;/code&gt;找到&lt;code&gt;entries[1]&lt;/code&gt;,比较key的值是否相等，相等就返回&lt;code&gt;entryIndex&lt;/code&gt;，不想等就继续&lt;code&gt;entries[next]&lt;/code&gt;查找，直到找到key相等元素或者&lt;code&gt;next == -1&lt;/code&gt;的时候。这里我们找到了&lt;code&gt;key == &quot;a&quot;&lt;/code&gt;的元素，返回&lt;code&gt;entryIndex=0&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;entryIndex &amp;gt;= 0&lt;/code&gt;那么返回对应的&lt;code&gt;entries[entryIndex]&lt;/code&gt;元素，否则返回&lt;code&gt;default(TValue)&lt;/code&gt;。这里我们直接返回&lt;code&gt;entries[0].value&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;整个查找的过程如下图所示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232143933-534053020.png&quot; alt=&quot;1548495296415&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将查找的代码摘录下来，如下所示。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// 寻找Entry元素的位置
private int FindEntry(TKey key) {
    if( key == null) {
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);
    }

    if (buckets != null) {
        int hashCode = comparer.GetHashCode(key) &amp;amp; 0x7FFFFFFF; // 获取HashCode，忽略符号位
        // int i = buckets[hashCode % buckets.Length] 找到对应桶，然后获取entry在entries中位置
        // i &amp;gt;= 0; i = entries[i].next 遍历单链表
        for (int i = buckets[hashCode % buckets.Length]; i &amp;gt;= 0; i = entries[i].next) {
            // 找到就返回了
            if (entries[i].hashCode == hashCode &amp;amp;&amp;amp; comparer.Equals(entries[i].key, key)) return i;
        }
    }
    return -1;
}
...
internal TValue GetValueOrDefault(TKey key) {
    int i = FindEntry(key);
    // 大于等于0代表找到了元素位置，直接返回value
    // 否则返回该类型的默认值
    if (i &amp;gt;= 0) {
        return entries[i].value;
    }
    return default(TValue);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dictionary---remove操作&quot;&gt;5. Dictionary - Remove操作&lt;/h3&gt;
&lt;p&gt;前面已经向大家介绍了增加、查找，接下来向大家介绍Dictionary如何执行删除操作。我们沿用之前的Dictionary数据结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232143619-706622936.png&quot; alt=&quot;1548494583006&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除前面步骤和查找类似，也是需要找到元素的位置，然后再进行删除的操作。&lt;/p&gt;
&lt;p&gt;我们现在执行这样一条语句&lt;code&gt;dictionary.Remove(&quot;a&quot;)&lt;/code&gt;，hashFunc运算结果和上文中一致。步骤大部分与查找类似，我们直接看摘录的代码，如下所示。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public bool Remove(TKey key) {
    if(key == null) {
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);
    }

    if (buckets != null) {
        // 1. 通过key获取hashCode
        int hashCode = comparer.GetHashCode(key) &amp;amp; 0x7FFFFFFF;
        // 2. 取余获取bucket位置
        int bucket = hashCode % buckets.Length;
        // last用于确定是否当前bucket的单链表中最后一个元素
        int last = -1;
        // 3. 遍历bucket对应的单链表
        for (int i = buckets[bucket]; i &amp;gt;= 0; last = i, i = entries[i].next) {
            if (entries[i].hashCode == hashCode &amp;amp;&amp;amp; comparer.Equals(entries[i].key, key)) {
                // 4. 找到元素后，如果last&amp;lt; 0，代表当前是bucket中最后一个元素，那么直接让bucket内下标赋值为 entries[i].next即可
                if (last &amp;lt; 0) {
                    buckets[bucket] = entries[i].next;
                }
                else {
                    // 4.1 last不小于0，代表当前元素处于bucket单链表中间位置，需要将该元素的头结点和尾节点相连起来,防止链表中断
                    entries[last].next = entries[i].next;
                }
                // 5. 将Entry结构体内数据初始化
                entries[i].hashCode = -1;
                // 5.1 建立freeList单链表
                entries[i].next = freeList;
                entries[i].key = default(TKey);
                entries[i].value = default(TValue);
                // *6. 关键的代码，freeList等于当前的entry位置，下一次Add元素会优先Add到该位置
                freeList = i;
                freeCount++;
                // 7. 版本号+1
                version++;
                return true;
            }
        }
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完上面代码后，数据结构就更新成了下图所示。需要注意&lt;code&gt;varsion、freeList、freeCount&lt;/code&gt;的值都被更新了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232143380-1521029377.png&quot; alt=&quot;1548496815179&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dictionary---resize操作扩容&quot;&gt;6. Dictionary - Resize操作(扩容)&lt;/h3&gt;
&lt;p&gt;有细心的小伙伴可能看过了&lt;strong&gt;Add&lt;/strong&gt;操作以后就想问了，&lt;code&gt;buckets、entries&lt;/code&gt;不就是两个数组么，那万一数组放满了怎么办？接下来就是我所要介绍的&lt;strong&gt;Resize（扩容）&lt;/strong&gt;这样一种操作，对我们的&lt;code&gt;buckets、entries&lt;/code&gt;进行扩容。&lt;/p&gt;
&lt;h4 id=&quot;扩容操作的触发条件&quot;&gt;6.1 扩容操作的触发条件&lt;/h4&gt;
&lt;p&gt;首先我们需要知道在什么情况下，会发生扩容操作；&lt;strong&gt;第一种情况自然就是数组已经满了，没有办法继续存放新的元素。&lt;/strong&gt;如下图所示的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232142991-753412617.png&quot; alt=&quot;1548498710430&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上文中大家都知道，Hash运算会不可避免的产生冲突，Dictionary中使用拉链法来解决冲突的问题，但是大家看下图中的这种情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232142685-1366765345.png&quot; alt=&quot;1548498901496&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有的元素都刚好落在&lt;code&gt;buckets[3]&lt;/code&gt;上面，结果就是导致了&lt;strong&gt;时间复杂度O(n)&lt;/strong&gt;，查找性能会下降；所以&lt;strong&gt;第二种，Dictionary中发生的碰撞次数太多，会严重影响性能，&lt;/strong&gt;也会触发扩容操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目前.Net Framwork 4.7中设置的碰撞次数阈值为100.&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public const int HashCollisionThreshold = 100;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;扩容操作如何进行&quot;&gt;6.2 扩容操作如何进行&lt;/h4&gt;
&lt;p&gt;为了给大家演示的清楚，模拟了以下这种数据结构，大小为2的Dictionary，假设碰撞的阈值为2；现在触发Hash碰撞扩容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232142310-209798626.png&quot; alt=&quot;1548499708530&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开始扩容操作。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;1.申请两倍于现在大小的buckets、entries&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2.将现有的元素拷贝到新的entries&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完成上面两步操作后，新数据结构如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232142082-458174885.png&quot; alt=&quot;1548499785441&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;3、如果是Hash碰撞扩容，使用新HashCode函数重新计算Hash值&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上文提到了，这是发生了Hash碰撞扩容，所以需要使用新的Hash函数计算Hash值。新的Hash函数并一定能解决碰撞的问题，有可能会更糟，像下图中一样的还是会落在同一个&lt;code&gt;bucket&lt;/code&gt;上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232141840-1221070461.png&quot; alt=&quot;1548500174305&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;4、对entries每个元素bucket = newEntries[i].hashCode % newSize确定新buckets位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、重建hash链，newEntries[i].next=buckets[bucket]; buckets[bucket]=i;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为&lt;code&gt;buckets&lt;/code&gt;也扩充为两倍大小了，所以需要重新确定&lt;code&gt;hashCode&lt;/code&gt;在哪个&lt;code&gt;bucket&lt;/code&gt;中；最后重新建立hash单链表.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232141497-1107893517.png&quot; alt=&quot;1548500290419&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就完成了扩容的操作，如果是达到&lt;strong&gt;Hash碰撞阈值&lt;/strong&gt;触发的扩容可能扩容后结果会更差。&lt;/p&gt;
&lt;p&gt;在JDK中，&lt;code&gt;HashMap&lt;/code&gt;如果碰撞的次数太多了，那么会将&lt;strong&gt;单链表转换为红黑树&lt;/strong&gt;提升查找性能。目前&lt;strong&gt;.Net Framwork&lt;/strong&gt;中还没有这样的优化，&lt;strong&gt;.Net Core&lt;/strong&gt;中已经有了类似的优化，以后有时间在分享&lt;strong&gt;.Net Core&lt;/strong&gt;的一些集合实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次扩容操作都需要遍历所有元素，会影响性能。所以创建Dictionary实例时最好设置一个预估的初始大小。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private void Resize(int newSize, bool forceNewHashCodes) {
    Contract.Assert(newSize &amp;gt;= entries.Length);
    // 1. 申请新的Buckets和entries
    int[] newBuckets = new int[newSize];
    for (int i = 0; i &amp;lt; newBuckets.Length; i++) newBuckets[i] = -1;
    Entry[] newEntries = new Entry[newSize];
    // 2. 将entries内元素拷贝到新的entries总
    Array.Copy(entries, 0, newEntries, 0, count);
    // 3. 如果是Hash碰撞扩容，使用新HashCode函数重新计算Hash值
    if(forceNewHashCodes) {
        for (int i = 0; i &amp;lt; count; i++) {
            if(newEntries[i].hashCode != -1) {
                newEntries[i].hashCode = (comparer.GetHashCode(newEntries[i].key) &amp;amp; 0x7FFFFFFF);
            }
        }
    }
    // 4. 确定新的bucket位置
    // 5. 重建Hahs单链表
    for (int i = 0; i &amp;lt; count; i++) {
        if (newEntries[i].hashCode &amp;gt;= 0) {
            int bucket = newEntries[i].hashCode % newSize;
            newEntries[i].next = newBuckets[bucket];
            newBuckets[bucket] = i;
        }
    }
    buckets = newBuckets;
    entries = newEntries;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;dictionary---再谈add操作&quot;&gt;7. Dictionary - 再谈Add操作&lt;/h3&gt;
&lt;p&gt;在我们之前的&lt;strong&gt;Add&lt;/strong&gt;操作步骤中，提到了这样一段话，这里提到会有一种其它的情况，那就是&lt;strong&gt;有元素被删除&lt;/strong&gt;的情况。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;避开一种其它情况不谈，接下来它会将&lt;code&gt;hashCode、key、value&lt;/code&gt;等信息存入&lt;code&gt;entries[count]&lt;/code&gt;中，因为&lt;code&gt;count&lt;/code&gt;位置是空闲的；继续&lt;code&gt;count++&lt;/code&gt;指向下一个空闲位置。上图中第一个位置，index=0就是空闲的，所以就存放在&lt;code&gt;entries[0]&lt;/code&gt;的位置。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;因为&lt;code&gt;count&lt;/code&gt;是通过自增的方式来指向&lt;code&gt;entries[]&lt;/code&gt;下一个空闲的&lt;code&gt;entry&lt;/code&gt;，如果有元素被删除了，那么在&lt;code&gt;count&lt;/code&gt;之前的位置就会出现一个空闲的&lt;code&gt;entry&lt;/code&gt;；如果不处理，会有很多空间被浪费。&lt;/p&gt;
&lt;p&gt;这就是为什么&lt;strong&gt;Remove&lt;/strong&gt;操作会记录&lt;code&gt;freeList、freeCount&lt;/code&gt;，就是为了将删除的空间利用起来。实际上&lt;strong&gt;Add&lt;/strong&gt;操作会优先使用&lt;code&gt;freeList&lt;/code&gt;的空闲&lt;code&gt;entry&lt;/code&gt;位置，摘录代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private void Insert(TKey key, TValue value, bool add){
    
    if( key == null ) {
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);
    }

    if (buckets == null) Initialize(0);
    // 通过key获取hashCode
    int hashCode = comparer.GetHashCode(key) &amp;amp; 0x7FFFFFFF;
    // 计算出目标bucket下标
    int targetBucket = hashCode % buckets.Length;
    // 碰撞次数
    int collisionCount = 0;
    for (int i = buckets[targetBucket]; i &amp;gt;= 0; i = entries[i].next) {
        if (entries[i].hashCode == hashCode &amp;amp;&amp;amp; comparer.Equals(entries[i].key, key)) {
            // 如果是增加操作，遍历到了相同的元素，那么抛出异常
            if (add) {      
                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);
            }
            // 如果不是增加操作，那可能是索引赋值操作 dictionary[&quot;foo&quot;] = &quot;foo&quot;
            // 那么赋值后版本++，退出
            entries[i].value = value;
            version++;
            return;
        }
        // 每遍历一个元素，都是一次碰撞
        collisionCount++;
    }
    int index;
    // 如果有被删除的元素，那么将元素放到被删除元素的空闲位置
    if (freeCount &amp;gt; 0) {
        index = freeList;
        freeList = entries[index].next;
        freeCount--;
    }
    else {
        // 如果当前entries已满，那么触发扩容
        if (count == entries.Length)
        {
            Resize();
            targetBucket = hashCode % buckets.Length;
        }
        index = count;
        count++;
    }

    // 给entry赋值
    entries[index].hashCode = hashCode;
    entries[index].next = buckets[targetBucket];
    entries[index].key = key;
    entries[index].value = value;
    buckets[targetBucket] = index;
    // 版本号++
    version++;

    // 如果碰撞次数大于设置的最大碰撞次数，那么触发Hash碰撞扩容
    if(collisionCount &amp;gt; HashHelpers.HashCollisionThreshold &amp;amp;&amp;amp; HashHelpers.IsWellKnownEqualityComparer(comparer)) 
    {
        comparer = (IEqualityComparer&amp;lt;TKey&amp;gt;) HashHelpers.GetRandomizedEqualityComparer(comparer);
        Resize(entries.Length, true);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面就是完整的&lt;strong&gt;Add&lt;/strong&gt;代码，还是很简单的对不对？&lt;/p&gt;
&lt;h3 id=&quot;collection版本控制&quot;&gt;8. Collection版本控制&lt;/h3&gt;
&lt;p&gt;在上文中一直提到了&lt;code&gt;version&lt;/code&gt;这个变量，在每一次新增、修改和删除操作时，都会使&lt;code&gt;version++&lt;/code&gt;；那么这个&lt;code&gt;version&lt;/code&gt;存在的意义是什么呢？&lt;/p&gt;
&lt;p&gt;首先我们来看一段代码，这段代码中首先实例化了一个Dictionary实例，然后通过&lt;code&gt;foreach&lt;/code&gt;遍历该实例，在&lt;code&gt;foreach&lt;/code&gt;代码块中使用&lt;code&gt;dic.Remove(kv.Key)&lt;/code&gt;删除元素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232140770-1720202601.png&quot; alt=&quot;1548504444217&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果就是抛出了&lt;code&gt;System.InvalidOperationException:&quot;Collection was modified...&quot;&lt;/code&gt;这样的异常，&lt;strong&gt;迭代过程中不允许集合出现变化&lt;/strong&gt;。如果在Java中遍历直接删除元素，会出现诡异的问题，所以.Net中就使用了&lt;code&gt;version&lt;/code&gt;来实现版本控制。&lt;/p&gt;
&lt;p&gt;那么如何在迭代过程中实现版本控制的呢？我们看一看源码就很清楚的知道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232140302-855859067.png&quot; alt=&quot;1548504844162&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在迭代器初始化时，就会记录&lt;code&gt;dictionary.version&lt;/code&gt;版本号，之后每一次迭代过程都会检查版本号是否一致，如果不一致将抛出异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这样就避免了在迭代过程中修改了集合，造成很多诡异的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;四参考文献及总结&quot;&gt;四、参考文献及总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;本文在编写过程中，主要参考了以下文献，在此感谢其作者在知识分享上作出的贡献！&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/mengfanrong/p/4034950.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/mengfanrong/p/4034950.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hash_table&quot; class=&quot;uri&quot;&gt;https://en.wikipedia.org/wiki/Hash_table&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/wuchaodzxx/p/7396599.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/wuchaodzxx/p/7396599.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/liwei2222/p/8013367.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/liwei2222/p/8013367.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,fd1acf96113fbda9&quot; class=&quot;uri&quot;&gt;https://referencesource.microsoft.com/#mscorlib/system/collections/generic/dictionary.cs,fd1acf96113fbda9&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Sat, 26 Jan 2019 15:24:00 +0000</pubDate>
<dc:creator>InCerry</dc:creator>
<og:description>﻿ 浅析C Dictionary实现原理 [TOC] 一、前言 本篇文章配图以及文字其实整理出来很久了，但是由于各种各样的原因推迟到现在才发出来，还有之前立Flag的《多线程编程》的笔记也都已经写好了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/InCerry/p/10325290.html</dc:identifier>
</item>
<item>
<title>AcceptEx与完成端口结合实例 - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/acceptex_socket.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/acceptex_socket.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt; 在windows平台下实现高性能网络服务器，iocp（完成端口）是唯一选择。编写网络服务器面临的问题有：1 快速接收客户端的连接。2 快速收发数据。3 快速处理数据。本文主要解决第一个问题。&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;AcceptEx&lt;/span&gt;函数定义
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;BOOL AcceptEx(
  SOCKET       sListenSocket,
  SOCKET       sAcceptSocket,
  PVOID        lpOutputBuffer,
  DWORD        dwReceiveDataLength,
  DWORD        dwLocalAddressLength,
  DWORD        dwRemoteAddressLength,
  LPDWORD      lpdwBytesReceived,
  LPOVERLAPPED lpOverlapped
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么要用AcceptEx&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;owner_title text-overflow&quot; title=&quot;请教accept和AcceptEx的区别&quot;&gt;  传统的accept函数能满足大部分场景的需要；但在某些极端条件下，必须使用acceptEx来实现。两个函数的区别如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;owner_title text-overflow&quot; title=&quot;请教accept和AcceptEx的区别&quot;&gt;  1）accept是阻塞的；在一个端口监听，必须启动一个专用线程调用accept。当然也可以用迂回的方式，绕过这个限制，处理起来会很麻烦，见文章&lt;a href=&quot;https://www.cnblogs.com/yuanchenhui/p/icop_accept.html&quot; target=&quot;_blank&quot;&gt;单线程实现同时监听多个端口&lt;/a&gt;。acceptEx是异步的，可以同时对很多端口监听（监听端口的数量没有上限的限制）。采用迂回的方式，使用accept监听，一个线程最多监听64个端口。这一点可能不是AcceptEx最大优点，毕竟同时对多个端口监听的情况非常少见。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;owner_title text-overflow&quot; title=&quot;请教accept和AcceptEx的区别&quot;&gt; 2）AcceptEx可以返回更多的数据。a）AcceptEx可以返回本地和对方ip地址和端口；而不需要调用函数getsockname和getpeername获取网络地址了。b）AcceptEx可以再接收到一段数据后，再返回。这种做法有利有弊，一般不建议这样做。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;owner_title text-overflow&quot; title=&quot;请教accept和AcceptEx的区别&quot;&gt; 3）AcceptEx是先准备套接字（socket）后接收。为了应对突发的连接高峰，可以多次投放AcceptEx。accept是事后建立SOCKET，就是tcp三次握手完成后，accept调用才返回，再生成socket。生成套接字是相对比较耗时的操作，accept的方式无法及时处理突发连接。对于AcceptEx的处理方式为建议做如下处理：一个线程负责创建socket，一个线程负责处理AcceptEx返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;owner_title text-overflow&quot; title=&quot;请教accept和AcceptEx的区别&quot;&gt;以上仅仅通过文字说明了AcceptEx的特点。下面通过具体代码，逐一剖析。我将AcceptEx的处理封装到类IocpAcceptEx中。编写该类时，尽量做到高内聚低耦合，使该类可以方便的被其他模块使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;owner_title text-overflow&quot; title=&quot;请教accept和AcceptEx的区别&quot;&gt;IocpAcceptEx外部功能说明&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; IocpAcceptEx
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    IocpAcceptEx();
    &lt;/span&gt;~&lt;span&gt;IocpAcceptEx();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置回调接口。当accept成功，调用回调接口。&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; SetCallback(IAcceptCallback*&lt;span&gt; callback);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加监听端口&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; AddListenPort(UINT16 port);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动服务&lt;/span&gt;
&lt;span&gt;    BOOL Start();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Stop();
        。。。以下代码省略
}&lt;br/&gt;#define POST_ACCEPT 1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用IocpAcceptEx类，必须实现该接口。接收客户端的连接&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; IAcceptCallback
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnAcceptClient(SOCKET hSocketClient, UINT16 nListenPort) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该类的调用函数很简单，对外接口也很明确。说明该类的职责很清楚，这也符合单一职责原则。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现步骤说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;AcceptEx不但需要与监听端口绑定，还需要与完成端口绑定。所以程序的第一步是创建完成端口：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a）创建完成端口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
m_hIocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, NULL, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (m_hIocp ==&lt;span&gt; NULL)
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; FALSE;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;b）监听端口创建与绑定&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成套接字&lt;/span&gt;
    SOCKET serverSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, WSA_FLAG_OVERLAPPED);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (serverSocket ==&lt;span&gt; INVALID_SOCKET)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定&lt;/span&gt;
&lt;span&gt;    SOCKADDR_IN addr;
    memset(&lt;/span&gt;&amp;amp;addr, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(addr));
    addr.sin_family &lt;/span&gt;=&lt;span&gt; AF_INET;
    addr.sin_addr.s_addr &lt;/span&gt;=&lt;span&gt;  INADDR_ANY ;
    addr.sin_port &lt;/span&gt;=&lt;span&gt; htons(port);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bind(serverSocket, (sockaddr *)&amp;amp;addr, &lt;span&gt;sizeof&lt;/span&gt;(addr)) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        closesocket(serverSocket);
        serverSocket &lt;/span&gt;=&lt;span&gt; INVALID_SOCKET;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动监听&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (listen(serverSocket, SOMAXCONN) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        closesocket(serverSocket);
        serverSocket &lt;/span&gt;=&lt;span&gt; INVALID_SOCKET;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听端口与完成端口绑定&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (CreateIoCompletionPort((HANDLE)serverSocket, m_hIocp, (ULONG_PTR)&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;) ==&lt;span&gt; NULL)
    {
        closesocket(serverSocket);
        serverSocket &lt;/span&gt;=&lt;span&gt; INVALID_SOCKET;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;c）投递AcceptEx&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; AcceptOverlapped
{
    OVERLAPPED     overlap;
    INT32 opType;
    SOCKET serverSocket;
    SOCKET clientSocket;

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; lpOutputBuf[&lt;span&gt;128&lt;/span&gt;&lt;span&gt;];
    DWORD dwBytes;
};

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; IocpAcceptEx::NewAccept(SOCKET serverSocket)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建socket&lt;/span&gt;
    SOCKET _socket =&lt;span&gt; socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); 

    AcceptOverlapped &lt;/span&gt;*ov = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AcceptOverlapped();
    ZeroMemory(ov,&lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(AcceptOverlapped));
    ov&lt;/span&gt;-&amp;gt;opType =&lt;span&gt; POST_ACCEPT;
    ov&lt;/span&gt;-&amp;gt;clientSocket =&lt;span&gt; _socket;
    ov&lt;/span&gt;-&amp;gt;serverSocket =&lt;span&gt; serverSocket;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放网络地址的长度&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; addrLen = &lt;span&gt;sizeof&lt;/span&gt;(sockaddr_in) + &lt;span&gt;16&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; bRetVal = AcceptEx(serverSocket, _socket, ov-&amp;gt;&lt;span&gt;lpOutputBuf,
        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,addrLen, addrLen,
        &lt;/span&gt;&amp;amp;ov-&amp;gt;&lt;span&gt;dwBytes, (LPOVERLAPPED)ov);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bRetVal ==&lt;span&gt; FALSE)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; error =&lt;span&gt; WSAGetLastError();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (error !=&lt;span&gt; WSA_IO_PENDING)
        {
            closesocket(_socket);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre readability=&quot;5&quot;&gt;
AcceptEx是非阻塞操作，调用会立即返回。当有客户端连接时，怎么得到通知。答案是通过完成端口返回。注意有一个步骤：监听端口与完成端口绑定，就是serverSocket与m_hIocp绑定，所以当有客户端连接serverSocket时，m_hIocp会得到通知。需要生成线程，等待完成端口的通知。&lt;p&gt;&lt;strong&gt;&lt;span&gt;d)通过完成端口，获取通知&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    DWORD dwBytesTransferred;
    ULONG_PTR    Key;
    BOOL rc;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; error;

    AcceptOverlapped &lt;/span&gt;*lpPerIOData =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (m_bServerStart)
    {
        error &lt;/span&gt;=&lt;span&gt; NO_ERROR;
        rc &lt;/span&gt;=&lt;span&gt; GetQueuedCompletionStatus(
            m_hIocp,
            &lt;/span&gt;&amp;amp;&lt;span&gt;dwBytesTransferred,
            &lt;/span&gt;&amp;amp;&lt;span&gt;Key,
            (LPOVERLAPPED &lt;/span&gt;*)&amp;amp;&lt;span&gt;lpPerIOData,
            INFINITE);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rc ==&lt;span&gt; FALSE)
        {
            error &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lpPerIOData ==&lt;span&gt; NULL)
            {
                DWORD lastError &lt;/span&gt;=&lt;span&gt; GetLastError();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastError ==&lt;span&gt; WAIT_TIMEOUT)
                {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    assert(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lastError;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lpPerIOData !=&lt;span&gt; NULL)
        {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (lpPerIOData-&amp;gt;&lt;span&gt;opType)
            {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; POST_ACCEPT:
            {
                OnIocpAccept(lpPerIOData, dwBytesTransferred, error);
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
        {            
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;　　
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;strong&gt; &lt;/strong&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DWORD WINAPI IocpAcceptEx::AcceptExThreadPool(PVOID pContext)
{
    ThreadPoolParam &lt;/span&gt;*param = (ThreadPoolParam*&lt;span&gt;)pContext;
    param&lt;/span&gt;-&amp;gt;pIocpAcceptEx-&amp;gt;NewAccept(param-&amp;gt;&lt;span&gt;ServeSocket);
    delete param;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; IocpAcceptEx::OnIocpAccept(AcceptOverlapped *acceptData, &lt;span&gt;int&lt;/span&gt; transLen, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; error)
{
    m_IAcceptCallback&lt;/span&gt;-&amp;gt;OnAcceptClient(acceptData-&amp;gt;clientSocket, acceptData-&amp;gt;&lt;span&gt;serverSocket);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当一个AcceptEx返回，需要投递一个新的AcceptEx。 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用线程池好像有点小题大做。前文已说过，套接字的创建相对是比较耗时的操作。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不在线程池投递AcceptEx，AcceptEx的优点就被抹杀了。&lt;/span&gt;
    ThreadPoolParam *param = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolParam();
    param&lt;/span&gt;-&amp;gt;pIocpAcceptEx = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    param&lt;/span&gt;-&amp;gt;ServeSocket = acceptData-&amp;gt;&lt;span&gt;serverSocket;
    QueueUserWorkItem(AcceptExThreadPool, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    delete acceptData;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}　　　　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;后记 &lt;/strong&gt;&lt;/span&gt;采用完成端口是提高IO处理能力的一个途径（广义上讲，通讯操作也是IO）。为了提高IO处理能力，windows提供很多异步操作函数，这些函数都与完成端口关联，所以这一类处理的思路基本一致。学会了AcceptEx的使用，可以做到触类旁通的效果。
&lt;/pre&gt;</description>
<pubDate>Sat, 26 Jan 2019 15:03:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>前言 在windows平台下实现高性能网络服务器，iocp（完成端口）是唯一选择。编写网络服务器面临的问题有：1 快速接收客户端的连接。2 快速收发数据。3 快速处理数据。本文主要解决第一个问题。 为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanchenhui/p/acceptex_socket.html</dc:identifier>
</item>
<item>
<title>GF(p)上的ELGamal型椭圆曲线密码详解（Java实现） - 蒙丿鑫</title>
<link>http://www.cnblogs.com/mx-lqk/p/10325192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mx-lqk/p/10325192.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/lqk1017237457/ECC_p&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span&gt;GitHub&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　椭圆曲线密码（Elliptic Curve Cryptosystem），简称ECC，是Neal Koblitz和Victor Miller于1985年提出的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　研究发现，有限域上的椭圆曲线上的一些点构成交换群，而且离散对数问题是难解的。于是在此群上定义ELGamal密码，并称为椭圆曲线密码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　目前，椭圆曲线密码已成为除RSA密码之外呼声最高的公钥密码之一。它密钥短、签名短、软件实现规模小、硬件实现电路省电。普遍认为，160位长的椭圆曲线密码的安全性相当于1024位的RSA密码，而且运算速度也较快。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　设p是大于3的素数，且4a&lt;sup&gt;3&lt;/sup&gt;+27b&lt;sup&gt;2&lt;/sup&gt;≠0(mod p)，称曲线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;y&lt;sup&gt;2&lt;/sup&gt;=x&lt;sup&gt;3&lt;/sup&gt;+ax+b（a,b∈GF(p)）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为GF(p)上的椭圆曲线。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由椭圆曲线方程可得到一同余方程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;y&lt;sup&gt;2&lt;/sup&gt;=x&lt;sup&gt;3&lt;/sup&gt;+ax+b(mod p)（a,b∈GF(p)）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其解为一个二元组(x,y)，其中x,y∈GF(p)，表示椭圆曲线上的一个点，称为该椭圆曲线上的解点。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;无穷点O&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　定义一个点O(∞,∞)表示无穷点，作为0元素。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;两解点相加&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　设P(x&lt;sub&gt;1&lt;/sub&gt;,y&lt;sub&gt;1&lt;/sub&gt;)和Q(x&lt;sub&gt;2&lt;/sub&gt;,y&lt;sub&gt;2&lt;/sub&gt;)是解点，R(x&lt;sub&gt;3&lt;/sub&gt;,y&lt;sub&gt;3&lt;/sub&gt;)=P(x&lt;sub&gt;1&lt;/sub&gt;,y&lt;sub&gt;1&lt;/sub&gt;)+Q(x&lt;sub&gt;2&lt;/sub&gt;,y&lt;sub&gt;2&lt;/sub&gt;)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.若P为无穷点，即P=O，此时R=P+Q=Q；若Q为无穷点，即Q=O，此时R=P+Q=P；若P和Q都为无穷点，即P=Q=O，则R=P+Q=O。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.若x&lt;sub&gt;1&lt;/sub&gt;=x&lt;sub&gt;2&lt;/sub&gt;且y&lt;sub&gt;1&lt;/sub&gt;=y&lt;sub&gt;2&lt;/sub&gt;，即P=Q，此时R=P+Q=2P，其中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126213309668-1828141427.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.若x1=x2而y1=-y2，此时称Q点为P点的逆，记为P=-Q，且R=P+Q=O。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.除上述特殊情况之外的一般情况，即P≠±Q时，R=P+Q，其中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126213524575-741998183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　集合E={所有的解点,无穷点O}和加法运算构成加法交换群。&lt;/span&gt;&lt;span&gt;设G(G≠O，即G为一个解点)为一个加法群的生成元，则使得nG=G+G+...+G=O的倍数n为该加法群的阶。加法群的阶整除集合E的阶，即n | |E|。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;求椭圆曲线的所有解点&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　当p较小，即GF(p)较小时，可以利用穷举的方法根据同余方程y&lt;sup&gt;2&lt;/sup&gt;=x&lt;sup&gt;3&lt;/sup&gt;+ax+b(mod p)（a,b∈GF(p)）求出所有解点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　具体方法为：求出x取0~p-1，x&lt;sup&gt;3&lt;/sup&gt;+ax+b(mod p)的结果是否为模p的二次剩余。如果是，则一个x值可得到两个对应的y值，也就得到互逆的两个解点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　e.m.取p=11，椭圆曲线y&lt;sup&gt;2&lt;/sup&gt;=x&lt;sup&gt;3&lt;/sup&gt;+x+6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126212911980-1076446260.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　       由此表得到所有的解点：(2,4)、(2,7)、(3,5)、(3,6)、(5,2)、(5,9)、(7,2)、(7,9)、(8,3)、(8,8)、(10,2)、(10,9)，再加上无穷点O共13个点的集合E加上加法运算就构成一个加法交换群。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　       因为集合E的阶|E|=13为素数，所以该加法群的阶为13。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　       取G=(2,7)为生成元，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;G=(2,7)，&lt;/span&gt;&lt;span&gt;2G=(5,2)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3G=(8,3)，4G=(10,2)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5G=(3,6)，6G=(7,9)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7G=(7,2)，8G=(3,5)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9G=(10,9)，10G=(8,8)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;11G=(5,9)，12G=(2,4)，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　       最终得到13G=O，所以加法群的阶为13。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　1.选择一个素数p，从而确定有限域GF(p)，将p公开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.选择元素a,b∈GF(p)，从而确定一条GF(p)上的椭圆曲线，确定加法交换群E，将a和b公开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.选择一个大素数n，并确定一个阶为n的基点G(x,y)，将n和G(x,y)公开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.余因子h=|E|/n，将h公开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.随机选择一个整数d(0&amp;lt;d&amp;lt;n)作为私钥保密。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　6.定义Q=dG作为公钥公开。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;加密&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　1.随机选择一个整数k(0&amp;lt;k&amp;lt;n)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.计算X&lt;sub&gt;1&lt;/sub&gt;=kG。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.计算X&lt;sub&gt;2&lt;/sub&gt;=kQ，若x&lt;sub&gt;2&lt;/sub&gt;=∞，则回到第1步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.加密：C=Mx&lt;sub&gt;2&lt;/sub&gt;(mod n)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.将(X&lt;sub&gt;1&lt;/sub&gt;,C)作为密文发送。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;解密&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　1.用私钥d求出X&lt;sub&gt;2&lt;/sub&gt;=dX&lt;sub&gt;1&lt;/sub&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.解密：M=Cx&lt;sub&gt;2&lt;/sub&gt;&lt;sup&gt;-1&lt;/sup&gt;(mod n)。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;推荐椭圆曲线&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　NIST向社会推荐了5条素域GF(p)上随机选取的椭圆曲线：&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;P-192&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　p=2&lt;sup&gt;192&lt;/sup&gt;-2&lt;sup&gt;64&lt;/sup&gt;-1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　a=-3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　b=64210519 E59C80E7 0FA7E9AB 72243049 FEB8DEEC C146B9B1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　x=188DA80E B03090F6 7CBf20EB 43A18800 F4FF0AFD 82FF1012&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　y=07192B95 FFC8DA78 631011ED 6B24CDD5 73F977A1 1E794811&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　n=FFFFFFFF FFFFFFFF FFFFFFFF 99DEF836 146BC9B1 B4D22831&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　h=1&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;P-224&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　p=2&lt;sup&gt;224&lt;/sup&gt;-2&lt;sup&gt;96&lt;/sup&gt;-1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　a=-3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　b=B4050A85 0C04B3AB F5413256 5044B0B7 D7BFD8BA 270B3943 2355FFB4&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　x=B70E0CBD 6BB4BF7F 321390B9 4A03C1D3 56C21122 343280D6 115C1D21&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　y=BD376388 B5F723FB 4C22DFE6 CD4375A0 5A074764 44D58199 85007E34&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　n=FFFFFFFF FFFFFFFF FFFFFFFF FFFF16A2 E0B8F03E 13DD2945 5C5C2A3D&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　h=1&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;P-256&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　p=2&lt;sup&gt;256&lt;/sup&gt;-2&lt;sup&gt;224&lt;/sup&gt;+2&lt;sup&gt;192&lt;/sup&gt;+2&lt;sup&gt;96&lt;/sup&gt;-1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　a=-3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　b=5AC635D8 AA3A93E7 B3EBBD55 769886BC 651D06B0 CC53B0F6 3BCE3C3E 27D2604B&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　x=6B17D1F2 E12C4247 F8BCE6E5 63A440F2 77037D81 2DEB33A0 F4A13945 D898C296&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　y=4FE342E2 FE1A7F9B 8EE7EB4A 7C0F9E16 2BCE3357 6B315ECE CBB64068 37BF51F5&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　n=FFFFFFFF 00000000 FFFFFFFF FFFFFFFF BCE6FAAD A7179E84 F3B9CAC2 FC632551&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　h=1&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;P-384&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　p=2&lt;sup&gt;384&lt;/sup&gt;-2&lt;sup&gt;128&lt;/sup&gt;-2&lt;sup&gt;96&lt;/sup&gt;+2&lt;sup&gt;32&lt;/sup&gt;-1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　a=-3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　b=B3312FA7 E23EE7E4 988E056B E3F82D19 181D9C6E FE814112 0314088F 5013875A C656398D 8A2ED19D 2A85C8ED D3EC2AEF&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　x=AA87CA22 BE8B0537 8EB1C71E F320AD74 6E1D3B62 8BA79B98 59F741E0 82542A38 5502F25D BF55296C 3A545E38 72760AB7&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　y=3617DE4A 96262C6F 5D9E98BF 9292DC29 F8F41DBD 289A147C E9DA3113 B5F0B8C0 0A60B1CE 1D7E819D 7A431D7C 90EA0E5F&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　n=FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF C7634D81 F4372DDF 581A0DB2 48B0A77A ECEC196A CCC52973&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　h=1&lt;/span&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;&lt;span&gt;P-521&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　p=2&lt;sup&gt;521&lt;/sup&gt;-1&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　a=-3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　b=00000051 953EB961 8E1C9A1F 929A21A0 B68540EE A2DA725B 99B315F3 B8B48991 8EF109E1 56193951 EC7E937B 1652C0BD 3BB1BF07 3573DF88 3D2C34F1 EF451FD4 6B503F00&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　x=000000C6 858E06B7 0404E9CD 9E3ECB66 2395B442 9C648139 053FB521 F828AF60 6B4D3DBA A14B5E77 EFE75928 FE1DC127 A2FFA8DE 3348B3C1 856A429B F97E7E31 C2E5BD66&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　y=00000118 39296A78 9A3BC004 5C8A5FB4 2C7D1BD9 98F54449 579B4468 17AFBD17 273E662C 97EE7299 5EF42640 C550B901 3FAD0761 353C7086 A272C240 88BE9476 9FD16650&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　n=000001FF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 51868783 BF2F966B 7FCC0148 F709A5D0 3BB5C9B8 899C47AE BB6FB71E 91386409&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　h=1&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　椭圆曲线密码的安全性建立在椭圆曲线离散对数问题的困难性之上。当素数p和n足够大时椭圆曲线密码是安全的。这就要求椭圆曲线解点群的阶要有大素数因子的根本原因，在理想情况下群的阶本身就是一个大素数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了确保椭圆曲线密码的安全，应当避免使用弱的椭圆曲线。所谓弱的椭圆曲线主要指超奇异椭圆曲线和反常椭圆曲线。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　椭圆曲线密码的密钥越长，自然越安全，但是技术实现也就越困难，效率也越低。一般认为，在目前的技术水平下采用190~256位的椭圆曲线，其安全性就足够了。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;解点类&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.math.BigInteger;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ECPoint {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    BigInteger x;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    BigInteger y;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ECPoint() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         x = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         y = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ECPoint(BigInteger x, BigInteger y) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isO()) 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;O&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;(&quot; + x.toString(16) + &quot;, &quot; + y.toString(16) + &quot;)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isO() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (x == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; y == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;两解点相加&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 两解点相加
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; p1
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; p2
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;ECPoint add(ECPoint p1, ECPoint p2) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (p1.isO()) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p2;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (p2.isO()) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p1;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     ECPoint p3 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ECPoint();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    BigInteger lambda;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (p1.x.compareTo(p2.x) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (p1.y.compareTo(p2.y) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             lambda = &lt;span&gt;new&lt;/span&gt; BigInteger(&quot;3&quot;).multiply(p1.x.pow(2)).add(a).multiply(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;2&quot;).multiply(p1.y).modPow(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;-1&quot;&lt;span&gt;), p)).mod(p);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             p3.x = lambda.pow(2).subtract(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;2&quot;&lt;span&gt;).multiply(p1.x)).mod(p);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             p3.y =&lt;span&gt; lambda.multiply(p1.x.subtract(p3.x)).subtract(p1.y).mod(p);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p3;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (p1.y.compareTo(p.subtract(p2.y)) == 0&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p3;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     lambda = p2.y.subtract(p1.y).multiply(p2.x.subtract(p1.x).modPow(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;-1&quot;&lt;span&gt;), p)).mod(p);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     p3.x = lambda.pow(2&lt;span&gt;).subtract(p1.x).subtract(p2.x).mod(p);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     p3.y =&lt;span&gt; lambda.multiply(p1.x.subtract(p3.x)).subtract(p1.y).mod(p);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p3;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;倍乘&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 倍乘
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; p
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; n
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  np
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;ECPoint multiply(ECPoint p, BigInteger n) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ECPoint q = add(p, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ECPoint());
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     ECPoint r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ECPoint();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (n.and(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;1&quot;)).intValue() == 1&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             r =&lt;span&gt; add(r, q);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         q =&lt;span&gt; add(q, q);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         n = n.shiftRight(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     } &lt;span&gt;while&lt;/span&gt; (n.intValue() != 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;求所有解点&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 求所有解点
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; List&amp;lt;ECPoint&amp;gt;&lt;span&gt; solutionPoints() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     List&amp;lt;ECPoint&amp;gt; r = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;ECPoint&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     List&amp;lt;BigInteger&amp;gt; l = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;BigInteger&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (BigInteger y = &lt;span&gt;new&lt;/span&gt; BigInteger(&quot;1&quot;); y.compareTo(p.divide(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;2&quot;))) != 1; y = y.add(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;1&quot;&lt;span&gt;))) 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         l.add(y.modPow(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;2&quot;&lt;span&gt;), p));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (BigInteger x = &lt;span&gt;new&lt;/span&gt; BigInteger(&quot;0&quot;); x.compareTo(p) == -1; x = x.add(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;1&quot;&lt;span&gt;))) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         BigInteger t = x.pow(3&lt;span&gt;).add(a.multiply(x)).add(b).mod(p);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (isExist(t, l) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             BigInteger y = &lt;span&gt;new&lt;/span&gt; BigInteger(isExist(t, l) + &quot;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             r.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ECPoint(x, y));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             r.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ECPoint(x, p.subtract(y)));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     r.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ECPoint());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; isExist(BigInteger b, List&amp;lt;BigInteger&amp;gt;&lt;span&gt; l) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; l.size(); i++&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (l.get(i).compareTo(b) == 0) &lt;span&gt;return&lt;/span&gt; (i + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;求阶&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 求阶
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; p  生成元
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;   p对应的阶
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;BigInteger o(ECPoint p) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     BigInteger r = &lt;span&gt;new&lt;/span&gt; BigInteger(&quot;1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt; p.isO()) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         r = r.add(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;1&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         p =&lt;span&gt; multiply(p, r);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;加密&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 加密
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; M
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;BigInteger[] encrypt(BigInteger M) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    BigInteger k;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    ECPoint X1, X2;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         k = &lt;span&gt;new&lt;/span&gt; BigInteger(n.bitLength(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     } &lt;span&gt;while&lt;/span&gt; ((X2 = ec.multiply(Q, k)).x == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     X1 =&lt;span&gt; ec.multiply(G, k);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     BigInteger[] C = &lt;span&gt;new&lt;/span&gt; BigInteger[3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     C[0] =&lt;span&gt; X1.x;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     C[1] =&lt;span&gt; X1.y;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     C[2] =&lt;span&gt; M.multiply(X2.x).mod(n);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; C;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;解密&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 解密
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; C
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;BigInteger decrypt(BigInteger[] C) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     ECPoint X1 = &lt;span&gt;new&lt;/span&gt; ECPoint(C[0], C[1&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ECPoint X2 =&lt;span&gt; ec.multiply(X1, d);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     BigInteger M = C[2].multiply(X2.x.modPow(&lt;span&gt;new&lt;/span&gt; BigInteger(&quot;-1&quot;&lt;span&gt;), n)).mod(n);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; M;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;测试数据&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　M=1234567890abcdef&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　k=abcdef&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;测试结果&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;P-192&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126223416707-506749300.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;P-224&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126223444524-1071421583.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;P-256&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126223517620-548565659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;P-384&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126223550814-1550786638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;P-521&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582448/201901/1582448-20190126223610960-1153651329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　张焕国，唐明.密码学引论（第三版）.武汉大学出版社，2015年&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 26 Jan 2019 14:46:00 +0000</pubDate>
<dc:creator>蒙丿鑫</dc:creator>
<og:description>GitHub 椭圆曲线密码 椭圆曲线密码（Elliptic Curve Cryptosystem），简称ECC，是Neal Koblitz和Victor Miller于1985年提出的。 研究发现，有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mx-lqk/p/10325192.html</dc:identifier>
</item>
<item>
<title>Jmeter 二次开发 将CSV Data Set Config添加从哪一行开始读数据 - 夏天里的Jasmine</title>
<link>http://www.cnblogs.com/qianjinyan/p/9543879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianjinyan/p/9543879.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064427/201808/1064427-20180827175812774-452934253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经常遇到性能测试的时候，有100万条数据，才用了5万条，中途因为某些原因停止了，继续用的时候，&lt;/p&gt;
&lt;p&gt;要么要清除DB中数据，要么要清除数据源中的数据，&lt;/p&gt;
&lt;p&gt;觉得特别麻烦，&lt;/p&gt;
&lt;p&gt;希望改写下代码，将&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
Ignore first line (only used if Variable Names is not empty)&lt;br/&gt;一列变成开始圆形需要选择的行数， StartLineNumber&lt;br/&gt;或者新增一个属性，StartLineNumber，原有的属性不需要更改。&lt;p&gt;看了一下大概涉及的java文件如下：&lt;br/&gt;config目录下的CSVDataSet和CSVDataSetBeanInfo，以及gui页面上的信息，gui又有几个语言版本，都要稍加修改。
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064427/201808/1064427-20180827180222291-1075882083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Core目录下的Services目录下的FileServer， 其中Readline方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064427/201808/1064427-20180827180419104-1332007655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;要采取第一种，改写Ignore first line 为StartLineNumber. 我觉得这种比较合理，一个忽略第一行，从第二行开始；另一个直接设置开始的行数。&lt;/p&gt;
&lt;p&gt;初步想法：&lt;/p&gt;
&lt;p&gt;1. 为空，则从第一行开始&lt;/p&gt;
&lt;p&gt;2. 有值，必须在【0，文件的行数-1】区间，从设置的行数开始。&lt;/p&gt;
&lt;p&gt;3. 如果选择Recyle on EOF， 首次从N行开始，接下去从0行开始取值？。。。。【其实从N行开始取值，就不应当可循环】&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;更新20180828， 改好了，如下，有点丑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064427/201808/1064427-20180828101848029-1473693207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面布局没有注意，放到了最上面，并且ignoreFirstLine没有去除&lt;/p&gt;
&lt;p&gt;自己测试了下，用了一个BeanShell Sampler&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064427/201808/1064427-20180828101957330-1658908047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看结果树看到的确是从20开始取值的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1064427/201808/1064427-20180828102031796-982883764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;修改的代码：&lt;/p&gt;
&lt;pre&gt;
CSVDataSet
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;87&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package org.apache.jmeter.config;

import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.io.IOException;
import java.util.ResourceBundle;

import org.apache.commons.lang3.StringUtils;
import org.apache.jmeter.engine.event.LoopIterationEvent;
import org.apache.jmeter.engine.event.LoopIterationListener;
import org.apache.jmeter.engine.util.NoConfigMerge;
import org.apache.jmeter.gui.GUIMenuSortOrder;
import org.apache.jmeter.save.CSVSaveService;
import org.apache.jmeter.services.FileServer;
import org.apache.jmeter.testbeans.TestBean;
import org.apache.jmeter.testbeans.gui.GenericTestBeanCustomizer;
import org.apache.jmeter.testelement.property.JMeterProperty;
import org.apache.jmeter.testelement.property.StringProperty;
import org.apache.jmeter.threads.JMeterContext;
import org.apache.jmeter.threads.JMeterVariables;
import org.apache.jmeter.util.JMeterUtils;
import org.apache.jorphan.util.JMeterStopThreadException;
import org.apache.jorphan.util.JOrphanUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Read lines from a file and split int variables.
 *
 * The iterationStart() method is used to set up each set of values.
 *
 * By default, the same file is shared between all threads
 * (and other thread groups, if they use the same file name).
 *
 * The shareMode can be set to:
 * &amp;lt;ul&amp;gt;
 * &amp;lt;li&amp;gt;All threads - default, as described above&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;Current thread group&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;Current thread&amp;lt;/li&amp;gt;
 * &amp;lt;li&amp;gt;Identifier - all threads sharing the same identifier&amp;lt;/li&amp;gt;
 * &amp;lt;/ul&amp;gt;
 *
 * The class uses the FileServer alias mechanism to provide the different share modes.
 * For all threads, the file alias is set to the file name.
 * Otherwise, a suffix is appended to the filename to make it unique within the required context.
 * For current thread group, the thread group identityHashcode is used;
 * for individual threads, the thread hashcode is used as the suffix.
 * Or the user can provide their own suffix, in which case the file is shared between all
 * threads with the same suffix.
 *
 */
@GUIMenuSortOrder(1)
public class CSVDataSet extends ConfigTestElement
        implements TestBean, LoopIterationListener, NoConfigMerge {
    private static final Logger log = LoggerFactory.getLogger(CSVDataSet.class);

    private static final long serialVersionUID = 233L;

    private static final String EOFVALUE = // value to return at EOF
            JMeterUtils.getPropDefault(&quot;csvdataset.eofstring&quot;, &quot;&amp;lt;EOF&amp;gt;&quot;); //$NON-NLS-1$ //$NON-NLS-2$

    private transient String filename;

    private transient String fileEncoding;

    private transient String variableNames;

    private transient String delimiter;

    private transient boolean quoted;

    private transient boolean recycle = true;

    private transient boolean stopThread;

    private transient String[] vars;

    private transient String alias;
    private transient String linenumber;

    private transient String shareMode;

    private boolean firstLineIsNames = false;

    private boolean ignoreFirstLine = false;

    private Object readResolve(){
        recycle = true;
        return this;
    }

    /**
     * Override the setProperty method in order to convert
     * the original String shareMode property.
     * This used the locale-dependent display value, so caused
     * problems when the language was changed.
     * If the &quot;shareMode&quot; value matches a resource value then it is converted
     * into the resource key.
     * To reduce the need to look up resources, we only attempt to
     * convert values with spaces in them, as these are almost certainly
     * not variables (and they are definitely not resource keys).
     */
    @Override
    public void setProperty(JMeterProperty property) {
        if (property instanceof StringProperty) {
            final String propName = property.getName();
            if (&quot;shareMode&quot;.equals(propName)) { // The original name of the property
                final String propValue = property.getStringValue();
                if (propValue.contains(&quot; &quot;)){ // variables are unlikely to contain spaces, so most likely a translation
                    try {
                        final BeanInfo beanInfo = Introspector.getBeanInfo(this.getClass());
                        final ResourceBundle rb = (ResourceBundle) beanInfo.getBeanDescriptor().getValue(GenericTestBeanCustomizer.RESOURCE_BUNDLE);
                        for(String resKey : CSVDataSetBeanInfo.getShareTags()) {
                            if (propValue.equals(rb.getString(resKey))) {
                                if (log.isDebugEnabled()) {
                                    log.debug(&quot;Converted {}={} to {} using Locale: {}&quot;, propName, propValue, resKey, rb.getLocale());
                                }
                                ((StringProperty) property).setValue(resKey); // reset the value
                                super.setProperty(property);
                                return;
                            }
                        }
                        // This could perhaps be a variable name
                        log.warn(&quot;Could not translate {}={} using Locale: {}&quot;, propName, propValue, rb.getLocale());
                    } catch (IntrospectionException e) {
                        log.error(&quot;Could not find BeanInfo; cannot translate shareMode entries&quot;, e);
                    }
                }
            }
        }
        super.setProperty(property);
    }

    @Override
    public void iterationStart(LoopIterationEvent iterEvent) {
        FileServer server = FileServer.getFileServer();
        final JMeterContext context = getThreadContext();
        String delim = getDelimiter();
        if (&quot;\\t&quot;.equals(delim)) { // $NON-NLS-1$
            delim = &quot;\t&quot;;// Make it easier to enter a Tab // $NON-NLS-1$
        } else if (delim.isEmpty()){
            log.debug(&quot;Empty delimiter, will use ','&quot;);
            delim=&quot;,&quot;;
        }
        if (vars == null) {
            String fileName = getFilename().trim();
            String mode = getShareMode();
            int modeInt = CSVDataSetBeanInfo.getShareModeAsInt(mode);
            switch(modeInt){
                case CSVDataSetBeanInfo.SHARE_ALL:
                    alias = fileName;
                    break;
                case CSVDataSetBeanInfo.SHARE_GROUP:
                    alias = fileName+&quot;@&quot;+System.identityHashCode(context.getThreadGroup());
                    break;
                case CSVDataSetBeanInfo.SHARE_THREAD:
                    alias = fileName+&quot;@&quot;+System.identityHashCode(context.getThread());
                    break;
                default:
                    alias = fileName+&quot;@&quot;+mode; // user-specified key
                    break;
            }
            final String names = getVariableNames();
            if (StringUtils.isEmpty(names)) {
                String header = server.reserveFile(fileName, getFileEncoding(), alias, true);
                try {
                    vars = CSVSaveService.csvSplitString(header, delim.charAt(0));
                    firstLineIsNames = true;
                } catch (IOException e) {
                    throw new IllegalArgumentException(&quot;Could not split CSV header line from file:&quot; + fileName,e);
                }
            } else {
                server.reserveFile(fileName, getFileEncoding(), alias, ignoreFirstLine);
                vars = JOrphanUtils.split(names, &quot;,&quot;); // $NON-NLS-1$
            }
            trimVarNames(vars);
        }

        // TODO: fetch this once as per vars above?
        JMeterVariables threadVars = context.getVariables();
        String[] lineValues = {};
        try {
            if (getQuotedData()) {
                lineValues = server.getParsedLine(alias, recycle,linenumber, delim.charAt(0));
            } else {
                //String line = server.readLine(alias, recycle,firstLineIsNames || ignoreFirstLine);
                String line = server.readLine(alias, recycle,linenumber);
                lineValues = JOrphanUtils.split(line, delim, false);
            }
            for (int a = 0; a &amp;lt; vars.length &amp;amp;&amp;amp; a &amp;lt; lineValues.length; a++) {
                threadVars.put(vars[a], lineValues[a]);
            }
        } catch (IOException e) { // treat the same as EOF
            log.error(e.toString());
        }
        if (lineValues.length == 0) {// i.e. EOF
            if (getStopThread()) {
                throw new JMeterStopThreadException(&quot;End of file:&quot;+ getFilename()+&quot; detected for CSV DataSet:&quot;
                        +getName()+&quot; configured with stopThread:&quot;+ getStopThread()+&quot;, recycle:&quot; + getRecycle());
            }
            for (String var :vars) {
                threadVars.put(var, EOFVALUE);
            }
        }
    }

    /**
     * trim content of array varNames
     * @param varsNames
     */
    private void trimVarNames(String[] varsNames) {
        for (int i = 0; i &amp;lt; varsNames.length; i++) {
            varsNames[i] = varsNames[i].trim();
        }
    }

    /**
     * @return Returns the filename.
     */
    public String getFilename() {
        return filename;
    }

    public String getLinenumber() {
        return linenumber;
    }

    public void setLinenumber(String linenumber) {
        this.linenumber = linenumber;
    }

    /**
     * @param filename
     *            The filename to set.
     */
    public void setFilename(String filename) {
        this.filename = filename;
    }

    /**
     * @return Returns the file encoding.
     */
    public String getFileEncoding() {
        return fileEncoding;
    }

    /**
     * @param fileEncoding
     *            The fileEncoding to set.
     */
    public void setFileEncoding(String fileEncoding) {
        this.fileEncoding = fileEncoding;
    }

    /**
     * @return Returns the variableNames.
     */
    public String getVariableNames() {
        return variableNames;
    }

    /**
     * @param variableNames
     *            The variableNames to set.
     */
    public void setVariableNames(String variableNames) {
        this.variableNames = variableNames;
    }

    public String getDelimiter() {
        return delimiter;
    }

    public void setDelimiter(String delimiter) {
        this.delimiter = delimiter;
    }

    public boolean getQuotedData() {
        return quoted;
    }

    public void setQuotedData(boolean quoted) {
        this.quoted = quoted;
    }

    public boolean getRecycle() {
        return recycle;
    }

    public void setRecycle(boolean recycle) {
        this.recycle = recycle;
    }

    public boolean getStopThread() {
        return stopThread;
    }

    public void setStopThread(boolean value) {
        this.stopThread = value;
    }

    public String getShareMode() {
        return shareMode;
    }

    public void setShareMode(String value) {
        this.shareMode = value;
    }

    /**
     * @return the ignoreFirstLine
     */
    public boolean isIgnoreFirstLine() {
        return ignoreFirstLine;
    }

    /**
     * @param ignoreFirstLine the ignoreFirstLine to set
     */
    public void setIgnoreFirstLine(boolean ignoreFirstLine) {
        this.ignoreFirstLine = ignoreFirstLine;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
CSVDataSetBeanInfo
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;86&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package org.apache.jmeter.config;

import java.beans.PropertyDescriptor;

import org.apache.jmeter.testbeans.BeanInfoSupport;
import org.apache.jmeter.testbeans.gui.FileEditor;
import org.apache.jmeter.testbeans.gui.TypeEditor;
import org.apache.jmeter.util.JMeterUtils;
import org.apache.jorphan.util.JOrphanUtils;

public class CSVDataSetBeanInfo extends BeanInfoSupport {

    // These names must agree case-wise with the variable and property names
    private static final String FILENAME = &quot;filename&quot;;               //$NON-NLS-1$
    private static final String FILE_ENCODING = &quot;fileEncoding&quot;;      //$NON-NLS-1$
    private static final String VARIABLE_NAMES = &quot;variableNames&quot;;    //$NON-NLS-1$
    private static final String IGNORE_FIRST_LINE = &quot;ignoreFirstLine&quot;;    //$NON-NLS-1$
    private static final String DELIMITER = &quot;delimiter&quot;;             //$NON-NLS-1$
    private static final String RECYCLE = &quot;recycle&quot;;                 //$NON-NLS-1$
    private static final String STOPTHREAD = &quot;stopThread&quot;;           //$NON-NLS-1$
    private static final String QUOTED_DATA = &quot;quotedData&quot;;          //$NON-NLS-1$
    private static final String SHAREMODE = &quot;shareMode&quot;;             //$NON-NLS-1$
    private static final String LINE_NUMBER = &quot;linenumber&quot;;

    // Access needed from CSVDataSet
    private static final String[] SHARE_TAGS = new String[3];
    static final int SHARE_ALL    = 0;
    static final int SHARE_GROUP  = 1;
    static final int SHARE_THREAD = 2;

    // Store the resource keys
    static {
        SHARE_TAGS[SHARE_ALL]    = &quot;shareMode.all&quot;; //$NON-NLS-1$
        SHARE_TAGS[SHARE_GROUP]  = &quot;shareMode.group&quot;; //$NON-NLS-1$
        SHARE_TAGS[SHARE_THREAD] = &quot;shareMode.thread&quot;; //$NON-NLS-1$
    }

    public CSVDataSetBeanInfo() {
        super(CSVDataSet.class);

        createPropertyGroup(&quot;csv_data&quot;,             //$NON-NLS-1$
                new String[] { FILENAME, FILE_ENCODING, VARIABLE_NAMES,
                        IGNORE_FIRST_LINE, DELIMITER, QUOTED_DATA,
                        RECYCLE, STOPTHREAD, SHAREMODE });

        PropertyDescriptor p = property(FILENAME);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, &quot;&quot;);        //$NON-NLS-1$
        p.setValue(NOT_EXPRESSION, Boolean.TRUE);
        p.setPropertyEditorClass(FileEditor.class);

        p = property(FILE_ENCODING, TypeEditor.ComboStringEditor);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, &quot;&quot;);        //$NON-NLS-1$
        p.setValue(TAGS, getListFileEncoding());

        p = property(VARIABLE_NAMES);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, &quot;&quot;);        //$NON-NLS-1$
        p.setValue(NOT_EXPRESSION, Boolean.TRUE);

        p = property(IGNORE_FIRST_LINE);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, Boolean.FALSE);

        //添加LINE_number的配置
        p = property(LINE_NUMBER);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, &quot;&quot;);
        p.setValue(NOT_EXPRESSION, Boolean.TRUE);

        p = property(DELIMITER);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, &quot;,&quot;);        //$NON-NLS-1$
        p.setValue(NOT_EXPRESSION, Boolean.TRUE);

        p = property(QUOTED_DATA);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, Boolean.FALSE);

        p = property(RECYCLE);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, Boolean.TRUE);

        p = property(STOPTHREAD);
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, Boolean.FALSE);

        p = property(SHAREMODE, TypeEditor.ComboStringEditor);
        p.setValue(RESOURCE_BUNDLE, getBeanDescriptor().getValue(RESOURCE_BUNDLE));
        p.setValue(NOT_UNDEFINED, Boolean.TRUE);
        p.setValue(DEFAULT, SHARE_TAGS[SHARE_ALL]);
        p.setValue(NOT_OTHER, Boolean.FALSE);
        p.setValue(NOT_EXPRESSION, Boolean.FALSE);
        p.setValue(TAGS, SHARE_TAGS);
    }

    public static int getShareModeAsInt(String mode) {
        if (mode == null || mode.length() == 0){
            return SHARE_ALL; // default (e.g. if test plan does not have definition)
        }
        for (int i = 0; i &amp;lt; SHARE_TAGS.length; i++) {
            if (SHARE_TAGS[i].equals(mode)) {
                return i;
            }
        }
        return -1;
    }

    /**
     * @return array of String for possible sharing modes
     */
    public static String[] getShareTags() {
        String[] copy = new String[SHARE_TAGS.length];
        System.arraycopy(SHARE_TAGS, 0, copy, 0, SHARE_TAGS.length);
        return copy;
    }

    /**
     * Get the mains file encoding
     * list from https://docs.oracle.com/javase/8/docs/technotes/guides/intl/encoding.doc.html
     * @return a String[] with the list of file encoding
     */
    private String[] getListFileEncoding() {
        return JOrphanUtils.split(JMeterUtils.getPropDefault(&quot;csvdataset.file.encoding_list&quot;, &quot;&quot;), &quot;|&quot;); //$NON-NLS-1$
    }

}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; CSVDataSetResources.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
#   Licensed to the Apache Software Foundation (ASF) under one or more
#   contributor license agreements.  See the NOTICE file distributed with
#   this work for additional information regarding copyright ownership.
#   The ASF licenses this file to You under the Apache License, Version 2.0
#   (the &quot;License&quot;); you may not use this file except in compliance with
#   the License.  You may obtain a copy of the License at
# 
#       http://www.apache.org/licenses/LICENSE-2.0
# 
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#   LINE_NUMBER=StartFromLineNumber

displayName=CSV Data Set Config
csv_data.displayName=Configure the CSV Data Source
filename.displayName=Filename
filename.shortDescription=Name of the file that holds the cvs data (relative or absolute filename)
fileEncoding.displayName=File encoding
fileEncoding.shortDescription=The character set encoding used in the file
#   ignoreFirstLine.displayName=Ignore first line (only used if Variable Names is not empty)
linenumber.displayName=StartFromLineNumber
linenumber.shortDescription=if linenumber blank, all the data would be involved;if linenum has value N, will read data from row N
#   ignoreFirstLine.shortDescription=Ignore first line of CSV file, it will only be used used if Variable Names is not empty, if Variable Names is empty the first line must contain the headers.
variableNames.displayName=Variable Names (comma-delimited)
variableNames.shortDescription=List your variable names in order to match the order of columns in your csv data. Keep it empty to use the first line of the file for variable names.
delimiter.displayName=Delimiter (use '\\t' for tab)
delimiter.shortDescription=Enter the delimiter ('\\t' for tab)
quotedData.displayName=Allow quoted data?
quotedData.shortDescription=Allow CSV data values to be quoted?
recycle.displayName=Recycle on EOF ?
recycle.shortDescription=Should the file be re-read from the start on reaching EOF ?
stopThread.displayName=Stop thread on EOF ?
stopThread.shortDescription=Should the thread be stopped on reaching EOF (if Recycle is false) ?
shareMode.displayName=Sharing mode
shareMode.shortDescription=Select which threads share the same file pointer
shareMode.all=All threads
shareMode.group=Current thread group
shareMode.thread=Current thread
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
FileServer
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;133&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 */

package org.apache.jmeter.services;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.Closeable;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;

import org.apache.commons.collections.ArrayStack;
import org.apache.jmeter.gui.JMeterFileFilter;
import org.apache.jmeter.save.CSVSaveService;
import org.apache.jmeter.util.JMeterUtils;
import org.apache.jorphan.util.JOrphanUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class provides thread-safe access to files, and to
 * provide some simplifying assumptions about where to find files and how to
 * name them. For instance, putting supporting files in the same directory as
 * the saved test plan file allows users to refer to the file with just it's
 * name - this FileServer class will find the file without a problem.
 * Eventually, I want all in-test file access to be done through here, with the
 * goal of packaging up entire test plans as a directory structure that can be
 * sent via rmi to remote servers (currently, one must make sure the remote
 * server has all support files in a relative-same location) and to package up
 * test plans to execute on unknown boxes that only have Java installed.
 */
public class FileServer {

    private static final Logger log = LoggerFactory.getLogger(FileServer.class);

    /**
     * The default base used for resolving relative files, i.e.&amp;lt;br/&amp;gt;
     * {@code System.getProperty(&quot;user.dir&quot;)}
     */
    private static final String DEFAULT_BASE = System.getProperty(&quot;user.dir&quot;);// $NON-NLS-1$

    /** Default base prefix: {@value} */
    private static final String BASE_PREFIX_DEFAULT = &quot;~/&quot;; // $NON-NLS-1$

    private static final String BASE_PREFIX =
            JMeterUtils.getPropDefault(&quot;jmeter.save.saveservice.base_prefix&quot;, // $NON-NLS-1$
                    BASE_PREFIX_DEFAULT);

    private File base;

    private final Map&amp;lt;String, FileEntry&amp;gt; files = new HashMap&amp;lt;&amp;gt;();

    private static final FileServer server = new FileServer();

    // volatile needed to ensure safe publication
    private volatile String scriptName;

    // Cannot be instantiated
    private FileServer() {
        base = new File(DEFAULT_BASE);
        log.info(&quot;Default base='{}'&quot;, DEFAULT_BASE);
    }

    /**
     * @return the singleton instance of the server.
     */
    public static FileServer getFileServer() {
        return server;
    }

    /**
     * Resets the current base to {@link #DEFAULT_BASE}.
     */
    public synchronized void resetBase() {
        checkForOpenFiles();
        base = new File(DEFAULT_BASE);
        log.info(&quot;Reset base to '{}'&quot;, base);
    }

    /**
     * Sets the current base directory for relative file names from the provided path.
     * If the path does not refer to an existing directory, then its parent is used.
     * Normally the provided path is a file, so using the parent directory is appropriate.
     *
     * @param basedir the path to set, or {@code null} if the GUI is being cleared
     * @throws IllegalStateException if files are still open
     */
    public synchronized void setBasedir(String basedir) {
        checkForOpenFiles(); // TODO should this be called if basedir == null?
        if (basedir != null) {
            File newBase = new File(basedir);
            if (!newBase.isDirectory()) {
                newBase = newBase.getParentFile();
            }
            base = newBase;
            log.info(&quot;Set new base='{}'&quot;, base);
        }
    }

    /**
     * Sets the current base directory for relative file names from the provided script file.
     * The parameter is assumed to be the path to a JMX file, so the base directory is derived
     * from its parent.
     *
     * @param scriptPath the path of the script file; must be not be {@code null}
     * @throws IllegalStateException if files are still open
     * @throws IllegalArgumentException if scriptPath parameter is null
     */
    public synchronized void setBaseForScript(File scriptPath) {
        if (scriptPath == null){
            throw new IllegalArgumentException(&quot;scriptPath must not be null&quot;);
        }
        setScriptName(scriptPath.getName());
        // getParentFile() may not work on relative paths
        setBase(scriptPath.getAbsoluteFile().getParentFile());
    }

    /**
     * Sets the current base directory for relative file names.
     *
     * @param jmxBase the path of the script file base directory, cannot be null
     * @throws IllegalStateException if files are still open
     * @throws IllegalArgumentException if {@code basepath} is null
     */
    public synchronized void setBase(File jmxBase) {
        if (jmxBase == null) {
            throw new IllegalArgumentException(&quot;jmxBase must not be null&quot;);
        }
        checkForOpenFiles();
        base = jmxBase;
        log.info(&quot;Set new base='{}'&quot;, base);
    }

    /**
     * Check if there are entries in use.
     * &amp;lt;p&amp;gt;
     * Caller must ensure that access to the files map is single-threaded as
     * there is a window between checking the files Map and clearing it.
     *
     * @throws IllegalStateException if there are any entries still in use
     */
    private void checkForOpenFiles() throws IllegalStateException {
        if (filesOpen()) { // checks for entries in use
            throw new IllegalStateException(&quot;Files are still open, cannot change base directory&quot;);
        }
        files.clear(); // tidy up any unused entries
    }

    public synchronized String getBaseDir() {
        return base.getAbsolutePath();
    }

    public static String getDefaultBase(){
        return DEFAULT_BASE;
    }

    /**
     * Calculates the relative path from {@link #DEFAULT_BASE} to the current base,
     * which must be the same as or a child of the default.
     *
     * @return the relative path, or {@code &quot;.&quot;} if the path cannot be determined
     */
    public synchronized File getBaseDirRelative() {
        // Must first convert to absolute path names to ensure parents are available
        File parent = new File(DEFAULT_BASE).getAbsoluteFile();
        File f = base.getAbsoluteFile();
        ArrayStack l = new ArrayStack();
        while (f != null) {
            if (f.equals(parent)){
                if (l.isEmpty()){
                    break;
                }
                File rel = new File((String) l.pop());
                while(!l.isEmpty()) {
                    rel = new File(rel, (String) l.pop());
                }
                return rel;
            }
            l.push(f.getName());
            f = f.getParentFile();
        }
        return new File(&quot;.&quot;);
    }

    /**
     * Creates an association between a filename and a File inputOutputObject,
     * and stores it for later use - unless it is already stored.
     *
     * @param filename - relative (to base) or absolute file name (must not be null)
     */
    public void reserveFile(String filename) {
        reserveFile(filename,null);
    }

    /**
     * Creates an association between a filename and a File inputOutputObject,
     * and stores it for later use - unless it is already stored.
     *
     * @param filename - relative (to base) or absolute file name (must not be null)
     * @param charsetName - the character set encoding to use for the file (may be null)
     */
    public void reserveFile(String filename, String charsetName) {
        reserveFile(filename, charsetName, filename, false);
    }

    /**
     * Creates an association between a filename and a File inputOutputObject,
     * and stores it for later use - unless it is already stored.
     *
     * @param filename - relative (to base) or absolute file name (must not be null)
     * @param charsetName - the character set encoding to use for the file (may be null)
     * @param alias - the name to be used to access the object (must not be null)
     */
    public void reserveFile(String filename, String charsetName, String alias) {
        reserveFile(filename, charsetName, alias, false);
    }

    /**
     * Creates an association between a filename and a File inputOutputObject,
     * and stores it for later use - unless it is already stored.
     *
     * @param filename - relative (to base) or absolute file name (must not be null or empty)
     * @param charsetName - the character set encoding to use for the file (may be null)
     * @param alias - the name to be used to access the object (must not be null)
     * @param hasHeader true if the file has a header line describing the contents
     * @return the header line; may be null
     * @throws IllegalArgumentException if header could not be read or filename is null or empty
     */
    public synchronized String reserveFile(String filename, String charsetName, String alias, boolean hasHeader) {
        if (filename == null || filename.isEmpty()){
            throw new IllegalArgumentException(&quot;Filename must not be null or empty&quot;);
        }
        if (alias == null){
            throw new IllegalArgumentException(&quot;Alias must not be null&quot;);
        }
        FileEntry fileEntry = files.get(alias);
        if (fileEntry == null) {
            fileEntry = new FileEntry(resolveFileFromPath(filename), null, charsetName);
            if (filename.equals(alias)){
                log.info(&quot;Stored: {}&quot;, filename);
            } else {
                log.info(&quot;Stored: {} Alias: {}&quot;, filename, alias);
            }
            files.put(alias, fileEntry);
            if (hasHeader) {
                try {
                    fileEntry.headerLine = readLine(alias, false);
                    if (fileEntry.headerLine == null) {
                        fileEntry.exception = new EOFException(&quot;File is empty: &quot; + fileEntry.file);
                    }
                } catch (IOException | IllegalArgumentException e) {
                    fileEntry.exception = e;
                }
            }
        }
        if (hasHeader &amp;amp;&amp;amp; fileEntry.headerLine == null) {
            throw new IllegalArgumentException(&quot;Could not read file header line for file &quot; + filename,
                    fileEntry.exception);
        }
        return fileEntry.headerLine;
    }

    /**
     * Resolves file name into {@link File} instance.
     * When filename is not absolute and not found from current working dir,
     * it tries to find it under current base directory
     * @param filename original file name
     * @return {@link File} instance
     */
    private File resolveFileFromPath(String filename) {
        File f = new File(filename);
        if (f.isAbsolute() || f.exists()) {
            return f;
        } else {
            return new File(base, filename);
        }
    }

    /**
     * Get the next line of the named file, recycle by default.
     *
     * @param filename the filename or alias that was used to reserve the file
     * @return String containing the next line in the file
     * @throws IOException when reading of the file fails, or the file was not reserved properly
     */
    public String readLine(String filename) throws IOException {
        return readLine(filename, true);
    }

    /**
     * Get the next line of the named file, first line is name to false
     *
     * @param filename the filename or alias that was used to reserve the file
     * @param recycle - should file be restarted at EOF?
     * @return String containing the next line in the file (null if EOF reached and not recycle)
     * @throws IOException when reading of the file fails, or the file was not reserved properly
     */
    public String readLine(String filename, boolean recycle) throws IOException {
        return readLine(filename, recycle, &quot;1&quot;);
    }
    /**
     * Get the next line of the named file
     *
     * @param filename the filename or alias that was used to reserve the file
     * @param recycle - should file be restarted at EOF?
     * //@param ignoreFirstLine - Ignore first line
     * @return String containing the next line in the file (null if EOF reached and not recycle)
     * @throws IOException when reading of the file fails, or the file was not reserved properly
     */
    public synchronized String readLine(String filename, boolean recycle,String linenum) throws IOException {
        FileEntry fileEntry = files.get(filename);
        String line =&quot;&quot;;
        if (fileEntry != null) {
            if (fileEntry.inputOutputObject == null) {
                fileEntry.inputOutputObject = createBufferedReader(fileEntry);
                BufferedReader reader = (BufferedReader) fileEntry.inputOutputObject;
                if(linenum!=&quot;&quot;){
                    for(int i=0;i&amp;lt;Integer.parseInt(linenum)-1;i++){
                        reader.readLine();
                    }
                }
            } else if (!(fileEntry.inputOutputObject instanceof Reader)) {
                throw new IOException(&quot;File &quot; + filename + &quot; already in use&quot;);
            }
            BufferedReader reader = (BufferedReader) fileEntry.inputOutputObject;
            line = reader.readLine();
            if (line == null &amp;amp;&amp;amp; recycle) {
                reader.close();
                reader = createBufferedReader(fileEntry);
                fileEntry.inputOutputObject = reader;
                //if (ignoreFirstLine) {
                    // read first line and forget
                  //  reader.readLine();//NOSONAR
                //}
                line = reader.readLine();
            }
            log.debug(&quot;Read:{}&quot;, line);
            return line;
        }
        throw new IOException(&quot;File never reserved: &quot;+filename);
    }

    /**
     *
     * @param alias the file name or alias
     * @param recycle whether the file should be re-started on EOF
    // * @param ignoreFirstLine whether the file contains a file header which will be ignored
     * @param delim the delimiter to use for parsing
     * @return the parsed line, will be empty if the file is at EOF
     * @throws IOException when reading of the aliased file fails, or the file was not reserved properly
     */
    public synchronized String[] getParsedLine(String alias, boolean recycle, String linenum, char delim) throws IOException {
        BufferedReader reader = getReader(alias, recycle, linenum);
        return CSVSaveService.csvReadFile(reader, delim);
    }

    /**
     * Return BufferedReader handling close if EOF reached and recycle is true
     * and ignoring first line if ignoreFirstLine is true
     *
     * @param alias           String alias
     * @param recycle         Recycle at eof
     //* @param ignoreFirstLine Ignore first line
     * @return {@link BufferedReader}
     */
    private BufferedReader getReader(String alias, boolean recycle, String linenum) throws IOException {
        FileEntry fileEntry = files.get(alias);
        if (fileEntry != null) {
            BufferedReader reader;
            if (fileEntry.inputOutputObject == null) {
                reader = createBufferedReader(fileEntry);
                fileEntry.inputOutputObject = reader;
                 if(linenum!=&quot;&quot;){
                    for(int i=0;i&amp;lt;Integer.parseInt(linenum)-1;i++){
                        reader.readLine();
                    }
                 }
            } else if (!(fileEntry.inputOutputObject instanceof Reader)) {
                throw new IOException(&quot;File &quot; + alias + &quot; already in use&quot;);
            } else {
                reader = (BufferedReader) fileEntry.inputOutputObject;
                if (recycle) { // need to check if we are at EOF already
                    reader.mark(1);
                    int peek = reader.read();
                    if (peek == -1) { // already at EOF
                        reader.close();
                        reader = createBufferedReader(fileEntry);
                        fileEntry.inputOutputObject = reader;
                        if(linenum!=&quot;&quot;){
                            for(int i=0;i&amp;lt;Integer.parseInt(linenum)-1;i++){
                                reader.readLine();
                            }
                        }
                    } else { // OK, we still have some data, restore it
                        reader.reset();
                    }
                }
            }
            return reader;
        } else {
            throw new IOException(&quot;File never reserved: &quot;+alias);
        }
    }

    private BufferedReader createBufferedReader(FileEntry fileEntry) throws IOException {
        if (!fileEntry.file.canRead() || !fileEntry.file.isFile()) {
            throw new IllegalArgumentException(&quot;File &quot;+ fileEntry.file.getName()+ &quot; must exist and be readable&quot;);
        }
        FileInputStream fis = new FileInputStream(fileEntry.file);
        InputStreamReader isr = null;
        // If file encoding is specified, read using that encoding, otherwise use default platform encoding
        String charsetName = fileEntry.charSetEncoding;
        if(!JOrphanUtils.isBlank(charsetName)) {
            isr = new InputStreamReader(fis, charsetName);
        } else {
            isr = new InputStreamReader(fis);
        }
        return new BufferedReader(isr);
    }

    public synchronized void write(String filename, String value) throws IOException {
        FileEntry fileEntry = files.get(filename);
        if (fileEntry != null) {
            if (fileEntry.inputOutputObject == null) {
                fileEntry.inputOutputObject = createBufferedWriter(fileEntry);
            } else if (!(fileEntry.inputOutputObject instanceof Writer)) {
                throw new IOException(&quot;File &quot; + filename + &quot; already in use&quot;);
            }
            BufferedWriter writer = (BufferedWriter) fileEntry.inputOutputObject;
            log.debug(&quot;Write:{}&quot;, value);
            writer.write(value);
        } else {
            throw new IOException(&quot;File never reserved: &quot;+filename);
        }
    }

    private BufferedWriter createBufferedWriter(FileEntry fileEntry) throws IOException {
        FileOutputStream fos = new FileOutputStream(fileEntry.file);
        OutputStreamWriter osw;
        // If file encoding is specified, write using that encoding, otherwise use default platform encoding
        String charsetName = fileEntry.charSetEncoding;
        if(!JOrphanUtils.isBlank(charsetName)) {
            osw = new OutputStreamWriter(fos, charsetName);
        } else {
            osw = new OutputStreamWriter(fos);
        }
        return new BufferedWriter(osw);
    }

    public synchronized void closeFiles() throws IOException {
        for (Map.Entry&amp;lt;String, FileEntry&amp;gt; me : files.entrySet()) {
            closeFile(me.getKey(),me.getValue() );
        }
        files.clear();
    }

    /**
     * @param name the name or alias of the file to be closed
     * @throws IOException when closing of the aliased file fails
     */
    public synchronized void closeFile(String name) throws IOException {
        FileEntry fileEntry = files.get(name);
        closeFile(name, fileEntry);
    }

    private void closeFile(String name, FileEntry fileEntry) throws IOException {
        if (fileEntry != null &amp;amp;&amp;amp; fileEntry.inputOutputObject != null) {
            log.info(&quot;Close: {}&quot;, name);
            fileEntry.inputOutputObject.close();
            fileEntry.inputOutputObject = null;
        }
    }

    boolean filesOpen() { // package access for test code only
        return files.values().stream()
                .anyMatch(fileEntry -&amp;gt; fileEntry.inputOutputObject != null);
    }

    /**
     * Method will get a random file in a base directory
     * &amp;lt;p&amp;gt;
     * TODO hey, not sure this method belongs here.
     * FileServer is for thread safe File access relative to current test's base directory.
     *
     * @param basedir    name of the directory in which the files can be found
     * @param extensions array of allowed extensions, if &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt; is given,
     *                   any file be allowed
     * @return a random File from the &amp;lt;code&amp;gt;basedir&amp;lt;/code&amp;gt; that matches one of
     * the extensions
     */
    public File getRandomFile(String basedir, String[] extensions) {
        File input = null;
        if (basedir != null) {
            File src = new File(basedir);
            File[] lfiles = src.listFiles(new JMeterFileFilter(extensions));
            if (lfiles != null) {
                // lfiles cannot be null as it has been checked before
                int count = lfiles.length;
                input = lfiles[ThreadLocalRandom.current().nextInt(count)];
            }
        }
        return input;
    }

    /**
     * Get {@link File} instance for provided file path,
     * resolve file location relative to base dir or script dir when needed
     *
     * @param path original path to file, maybe relative
     * @return {@link File} instance
     */
    public File getResolvedFile(String path) {
        reserveFile(path);
        return files.get(path).file;
    }

    private static class FileEntry{
        private String headerLine;
        private Throwable exception;
        private final File file;
        private Closeable inputOutputObject;
        private final String charSetEncoding;

        FileEntry(File f, Closeable o, String e) {
            file = f;
            inputOutputObject = o;
            charSetEncoding = e;
        }
    }

    /**
     * Resolve a file name that may be relative to the base directory. If the
     * name begins with the value of the JMeter property
     * &quot;jmeter.save.saveservice.base_prefix&quot; - default &quot;~/&quot; - then the name is
     * assumed to be relative to the basename.
     *
     * @param relativeName
     *            filename that should be checked for
     *            &amp;lt;code&amp;gt;jmeter.save.saveservice.base_prefix&amp;lt;/code&amp;gt;
     * @return the updated filename
     */
    public static String resolveBaseRelativeName(String relativeName) {
        if (relativeName.startsWith(BASE_PREFIX)){
            String newName = relativeName.substring(BASE_PREFIX.length());
            return new File(getFileServer().getBaseDir(),newName).getAbsolutePath();
        }
        return relativeName;
    }

    /**
     * @return JMX Script name
     * @since 2.6
     */
    public String getScriptName() {
        return scriptName;
    }

    /**
     * @param scriptName Script name
     * @since 2.6
     */
    public void setScriptName(String scriptName) {
        this.scriptName = scriptName;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 26 Jan 2019 14:46:00 +0000</pubDate>
<dc:creator>夏天里的Jasmine</dc:creator>
<og:description>经常遇到性能测试的时候，有100万条数据，才用了5万条，中途因为某些原因停止了，继续用的时候， 要么要清除DB中数据，要么要清除数据源中的数据， 觉得特别麻烦， 希望改写下代码，将 Core目录下的S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianjinyan/p/9543879.html</dc:identifier>
</item>
<item>
<title>12 JVM 垃圾回收（下） - 黑_子</title>
<link>http://www.cnblogs.com/yuepenglei/p/10325174.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuepenglei/p/10325174.html</guid>
<description>&lt;h4 id=&quot;java-虚拟机的堆划分&quot;&gt;Java 虚拟机的堆划分&lt;/h4&gt;
&lt;p&gt;Java 虚拟机将堆划分为新生代和老年代。其中新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。&lt;/p&gt;
&lt;p&gt;默认情况下，Java 虚拟机采取一种动态分配的策略，根据对象生成的速率，以及 Survivor 区的使用情况动态调整 Eden 区和 Survivor 区的比例。也可以通过参数 -XX:SurvivorRatio 来固定这个比例。需要注意的是，其中一个 Survivor 区会一直为空，因此比例越低浪费的空间越高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190125233636563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BlbmdsZWkxMjM0NTY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。由于堆内存是线程共享的，因此直接在这里划分空间是需要进行同步的。否则会出现两个对象公用一段内存的事故。&lt;/p&gt;
&lt;p&gt;Java 虚拟机的解决方法是：每个线程可以向 Java 虚拟机申请一段连续的内存，比如 2048 字节，作为线程私有的 TLAB。这个操作需要加锁，线程需要维护两个重要的指针，一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。&lt;/p&gt;
&lt;p&gt;然后通过 new 指令，便可以直接通过指针加法来实现，即把指向空余内存位置的指针加上所请求的字节数。如果加法后空余内存指针的值扔小于或等于指向末尾的指针，则代表分配成功。否则，TLAB 以及没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。&lt;/p&gt;
&lt;p&gt;当 Eden 区的空间耗尽了，这个时候 Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。当发生 MinorGC时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。&lt;/p&gt;
&lt;p&gt;Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制 15 次，那么该对象将被晋升至老年代。如果单个 Survivor 区已经被占用了 50%，那么较高复制次数的对象也会被晋升至老年代。&lt;/p&gt;
&lt;p&gt;Minor GC 有一个问题，那就是老年代的对象可能引用新生代的对象。在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。这样的话，就相当于进行了一次全堆扫描。&lt;/p&gt;
&lt;h4 id=&quot;卡表&quot;&gt;卡表&lt;/h4&gt;
&lt;p&gt;针对上述的问题，HotSpot 给出了一种解决方案叫做卡表。该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，用来存储每张卡的一个标示位。这个标示位代表对应的卡是否可能存在指向新生代对象的引用。如果可能存在，那么我们就认为这张卡是脏的。&lt;/p&gt;
&lt;p&gt;在进行 Minor GC 的时候，我们不用扫描整个老年代，而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标示位清零。&lt;/p&gt;
&lt;p&gt;上述总结介绍了用卡表这种方式解决全堆扫描效率低下的问题，置于如何标记脏卡，如何更新脏卡就不做深入总结了。&lt;/p&gt;
&lt;h4 id=&quot;问答&quot;&gt;问答&lt;/h4&gt;
&lt;h6 id=&quot;q请问jvm分代收集新生代对象进入老年代年龄为什么是15而不是其他的&quot;&gt;Q：请问JVM分代收集新生代对象进入老年代，年龄为什么是15而不是其他的?&lt;/h6&gt;
&lt;p&gt;HotSpot会在对象头中的标记字段里记录年龄，分配到的空间只有4位，最多只能记录到15&lt;/p&gt;
&lt;h6 id=&quot;qgc-root到底指的是对象本身还是引用&quot;&gt;Q：GC ROOT到底指的是对象本身，还是引用？&lt;/h6&gt;
&lt;p&gt;严格来说应该是对象。像局部变量中存放的引用只是导致对象成为GC roots的原因。我个人倾向于将这些引用作为GC roots，因为GC是从这些地方出发开始探索的。看各人理解方便吧。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;本文创作灵感来源于 极客时间 郑雨迪老师的《深入拆解 Java 虚拟机》课程，通过课后反思以及借鉴各位学友的发言总结，现整理出自己的知识架构，以便日后温故知新，查漏补缺。&lt;/p&gt;
&lt;h4 id=&quot;关注本人公众号第一时间获取最新文章发布每日更新一篇技术文章&quot;&gt;关注本人公众号，第一时间获取最新文章发布，每日更新一篇技术文章。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1562380/201901/1562380-20190113225450069-1906096752.png&quot; alt=&quot;关注我就是给我最大的鼓励和支持&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 26 Jan 2019 14:36:00 +0000</pubDate>
<dc:creator>黑_子</dc:creator>
<og:description>Java 虚拟机的堆划分 Java 虚拟机将堆划分为新生代和老年代。其中新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。 默认情况下，Java 虚拟机采取一种动态分配的策略，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuepenglei/p/10325174.html</dc:identifier>
</item>
</channel>
</rss>