<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用PInvoke互操作，让C#和C++愉快的交互优势互补 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/12985351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/12985351.html</guid>
<description>&lt;h2 id=&quot;一：背景&quot;&gt;一：背景&lt;/h2&gt;
&lt;h3 id=&quot;1-讲故事&quot;&gt;1. 讲故事&lt;/h3&gt;
&lt;p&gt;如果你常翻看FCL的源码，你会发现这里面有不少方法借助了C/C++的力量让C#更快更强悍,如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        [DllImport(&quot;QCall&quot;, CharSet = CharSet.Unicode)]
        [SecurityCritical]
        [SuppressUnmanagedCodeSecurity]
        private static extern bool InternalUseRandomizedHashing();

        [DllImport(&quot;mscoree.dll&quot;, EntryPoint = &quot;ND_RU1&quot;)]
        [SuppressUnmanagedCodeSecurity]
        [SecurityCritical]
        public static extern byte ReadByte([In] [MarshalAs(UnmanagedType.AsAny)] object ptr, int ofs);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;联想到上一篇阿里短信netsdk也是全用C++实现，然后用C#做一层壳，两者相互打辅助彰显更强大的威力，还有很多做物联网的朋友对这种.Net互操作技术太熟悉不过了，很多硬件，视频设备驱动都是用C/C++实现，然后用winform/WPF去做管理界面，C++还是在大学里学过，好多年没接触了，为了练手这一篇用P/Invoke来将两者相互打通。&lt;/p&gt;
&lt;h2 id=&quot;二：pinvoke互操作技术&quot;&gt;二：PInvoke互操作技术&lt;/h2&gt;
&lt;h3 id=&quot;1-一些前置基础&quot;&gt;1. 一些前置基础&lt;/h3&gt;
&lt;p&gt;这里我用vs2019创建C++的Console App，修改两个配置： 将程序导出为dll，修改成compile方式为&lt;code&gt;Compile as C++ Code (/TP)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202005/214741-20200529082058029-1669782279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202005/214741-20200529082058314-1211310366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-基本类型的互操作&quot;&gt;2. 基本类型的互操作&lt;/h3&gt;
&lt;p&gt;简单类型是最好处理的，基本上int,long，double都是一一对应的，这里我用C++实现了简单的Sum操作，画一个简图就是下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202005/214741-20200529082059175-979853684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建一个cpp文件和一个h头文件，如下代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;
--- Person.cpp

extern &quot;C&quot;
{
        _declspec(dllexport) int Sum(int a, int b);
}


--- Person.h

#include &quot;Person.h&quot;
#include &quot;iostream&quot;
using namespace std;

int Sum(int a, int b)
{
        return a + b;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一个注意的地方就是 &lt;code&gt;extern &quot;C&quot;&lt;/code&gt;，一定要用C方式导出，如果按照C++方式，Sum名称会被编译器自动修改，不信你把&lt;code&gt;extern &quot;C&quot;&lt;/code&gt;去掉，我用ida打开给你看一下，被修改成了 &lt;code&gt;?Sum@@YAHHH@Z&lt;/code&gt;, 尴尬。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202005/214741-20200529082059397-2110055706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来把C++项目生成好的 &lt;code&gt;ConsoleApplication1.dll&lt;/code&gt; copy到C#的bin目录下，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    class Program
    {
        [DllImport(&quot;ConsoleApplication1.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
        extern static int Sum(int a, int b);

        static void Main(string[] args)
        {
            var result = Sum(10, 20);

            Console.WriteLine($&quot;10+20={result}&quot;);

            Console.ReadLine();
        }
    }

---- output -----

10+20=30

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-字符串的互操作&quot;&gt;2. 字符串的互操作&lt;/h3&gt;
&lt;p&gt;我们知道托管代码和非托管代码是两个世界，这中间涉及到了两个世界的的类型映射，那映射关系去哪找呢？ 微软的msdn还真有一篇介绍 封送通用类型对照表： &lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/native-interop/type-marshaling&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/standard/native-interop/type-marshaling&lt;/a&gt; ，大家有兴趣可以看一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202005/214741-20200529082059611-1685264301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，C#中的string对应C++中的char*，所以这里就好处理了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;
--- Person.cpp

extern &quot;C&quot;
{
        //字符串
        _declspec(dllexport) int GetLength(char* chs);
}


--- Person.h

#include &quot;Person.h&quot;
#include &quot;iostream&quot;
using namespace std;

int GetLength(char* chs)
{
        return strlen(chs);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们看一下C#这边怎么写，通常string在C++中使用asc码，而C#中是Unicode，所以在DllImport中加一个CharSet指定即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    class Program
    {
        [DllImport(&quot;ConsoleApplication1.dll&quot;, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        extern static int GetLength([MarshalAs(UnmanagedType.LPStr)] string str);

        static void Main(string[] args)
        {
            var str = &quot;hello world&quot;;
            Console.WriteLine($&quot;length={GetLength(str)}&quot;);

            Console.ReadLine();
        }
    }

---- output -----

length=11

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3-复杂类型的处理&quot;&gt;3. 复杂类型的处理&lt;/h3&gt;
&lt;p&gt;复杂类型配置对应关系就难搞了，还容易搞错，错了弄不好还内存泄漏，怕了吧，幸好微软提供了一个小工具&lt;code&gt;P/Invoke Interop Assistant&lt;/code&gt; ，它可以帮助我们自动匹配对应关系，我就演示一个封送Person类的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202005/214741-20200529082059868-1776405051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，左边写好 &lt;code&gt;C++&lt;/code&gt;，右边自动给你配好&lt;code&gt;C#&lt;/code&gt;的映射类型，非常方便。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;
--- Person.cpp

extern &quot;C&quot;
{
        class Person
        {
        public:
                char* username;
                char* password;
        };

        _declspec(dllexport) char* AddPerson(Person person);
}

--- Person.h

#include &quot;Person.h&quot;
#include &quot;iostream&quot;
using namespace std;

char* AddPerson(Person person)
{
        return person.username;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到C++中AddPerson返回了char*，在C#中我们用IntPtr来接，然后用Marshal将指针转换string，接下来用工具生成好的C#代码拷到项目中来，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public struct Person
    {
        /// char*
        [System.Runtime.InteropServices.MarshalAsAttribute(System.Runtime.InteropServices.UnmanagedType.LPStr)]
        public string username;

        /// char*
        [System.Runtime.InteropServices.MarshalAsAttribute(System.Runtime.InteropServices.UnmanagedType.LPStr)]
        public string password;
    }   

    class Program
    {
        [DllImport(&quot;ConsoleApplication1.dll&quot;, CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
        extern static IntPtr AddPerson(Person person);

        static void Main(string[] args)
        {
            var person = new Person() { username = &quot;dotnetfly&quot;, password = &quot;123456&quot; };

            var ptr = AddPerson(person);
            var str = Marshal.PtrToStringAnsi(ptr);

            Console.WriteLine($&quot;username={str}&quot;);

            Console.ReadLine();
        }
    }

---------- output ------------

username=dotnetfly

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4-回调函数（异步）的处理&quot;&gt;4. 回调函数（异步）的处理&lt;/h3&gt;
&lt;p&gt;前面介绍的3种情况都是单向的，即C#向C++传递数据，有的时候也需要C++主动调用C#的函数，我们知道C#是用回调函数，也就是委托包装，具体我就不说了，很开心的是C++可以直接接你的委托，看下怎么实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;
--- Person.cpp

extern &quot;C&quot;
{
        //函数指针
        typedef void(_stdcall* PCALLBACK) (int result);
        _declspec(dllexport) void AsyncProcess(PCALLBACK ptr);
}

--- Person.h

#include &quot;Person.h&quot;
#include &quot;iostream&quot;
using namespace std;

void AsyncProcess(PCALLBACK ptr)
{
        ptr(10);  //回调C#的委托
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中看到，PCALLBACK就是我定义了函数指针，接受int参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    class Program
    {
        delegate void Callback(int a);

        [DllImport(&quot;ConsoleApplication1.dll&quot;, CallingConvention = CallingConvention.Cdecl)]
        extern static void AsyncProcess(Callback callback);

        static void Main(string[] args)
        {
            AsyncProcess((i) =&amp;gt;
            {
                //这里回调函数哦...

                Console.WriteLine($&quot;这是回调函数哦: {i}&quot;);
            });

            Console.ReadLine();
        }
    }

------- output -------  

这是回调函数哦: 10

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我做了一个自定义的delegate，因为我使用&lt;code&gt;Action&amp;lt;T&amp;gt;&lt;/code&gt;不接受泛型抛异常(┬＿┬)。&lt;/p&gt;
&lt;h2 id=&quot;四：总结&quot;&gt;四：总结&lt;/h2&gt;
&lt;p&gt;这让我想起来前段时间用python实现的线性回归，为了简便我使用了http和C#交互，这次准备用C++改写然后PInvoke直接交互就利索了，好了，借助C++的生态，让 C# 如虎添翼吧~~~&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;如您有更多问题与我互动，扫描下方进来吧&quot;&gt;如您有更多问题与我互动，扫描下方进来吧~&lt;/h3&gt;
&lt;hr/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202005/214741-20200522143723695-575216767.png&quot; width=&quot;600&quot; height=&quot;200&quot; alt=&quot;图片名称&quot; align=&quot;center&quot;/&gt;</description>
<pubDate>Fri, 29 May 2020 00:21:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>一：背景 1. 讲故事 如果你常翻看FCL的源码，你会发现这里面有不少方法借助了C/C++的力量让C#更快更强悍,如下所示： [DllImport(&amp;amp;quot;QCall&amp;amp;quot;,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangxincheng/p/12985351.html</dc:identifier>
</item>
<item>
<title>初尝 Blazor WebAssembly - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/12984971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/12984971.html</guid>
<description>&lt;h2 id=&quot;一-前言&quot;&gt;一. 前言&lt;/h2&gt;
&lt;blockquote readability=&quot;4.1333333333333&quot;&gt;
&lt;p&gt;Blazor 的整体介绍以及特点与优势，建议翻阅 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/blazor/?view=aspnetcore-3.1&quot;&gt;Blazor 介绍&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Blazor 是一个可是使用 .NET/C# 来编写交互式客户端的 Web UI 框架，在&lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor&quot;&gt;官网&lt;/a&gt;有一句话概括 “Build client web apps with C#”。在 Blazor 里面有三个比较重要的概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Components&lt;/li&gt;
&lt;li&gt;Blazor WebAssembly&lt;/li&gt;
&lt;li&gt;Blazor Server&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Components&lt;/strong&gt; 翻译过来就是组件，是指 UI 元素，例如页面、对话框或数据输入窗体。Blazor 应用就是由各种各样的组件搭建起来的，类似于 Vue、React、Angular等Js组件。组件的文件名 通常以 &lt;code&gt;.razor&lt;/code&gt; 结尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Blazor Server&lt;/strong&gt; 将组件呈现逻辑从 UI 更新的应用方式中分离出来。 Blazor Server 在 ASP.NET Core 应用中添加了对在服务器上托管 Razor 组件的支持。 可通过 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/signalr/introduction?view=aspnetcore-3.1&quot;&gt;SignalR&lt;/a&gt; 连接处理 UI 更新。运行时处理从浏览器向服务器发送 UI 事件，并在运行组件后，将服务器发送的 UI 更新并重新应用到浏览器。Blazor Server 用于与浏览器通信的连接还用于处理 JavaScript 互操作调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002418733-1802443014.png&quot; alt=&quot;Blazor 服务器在服务器上运行 .NET 代码，并通过 SignalR 连接与客户端上的文档对象模型进行交互&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Blazor WebAssembly&lt;/strong&gt; 是一个单页应用（SPA）框架，可用它通过 .NET 生成交互式客户端 Web 应用。 Blazor WebAssembly 使用开放的 Web 标准（没有插件或代码转换），适用于移动浏览器等各种新式 Web 浏览器。通过 &lt;a href=&quot;https://webassembly.org/&quot;&gt;WebAssembly&lt;/a&gt;（缩写为 wasm），可在 Web 浏览器内运行 .NET 代码。 WebAssembly 是针对快速下载和最大执行速度优化的压缩字节码格式。 WebAssembly 是开放的 Web 标准，支持无插件用于 Web 浏览器。WebAssembly 代码可通过 JavaScript JavaScript 互操作访问浏览器的完整功能。 通过浏览器中的 WebAssembly 执行的 .NET 代码在浏览器的 JavaScript 沙盒中运行，沙盒提供的保护可防御在客户端计算机上的恶意操作（这点无法像ActiveX那样了）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002418427-1154912059.png&quot; alt=&quot;Blazor WebAssembly 使用 WebAssembly 在浏览器中运行 .NET 代码。&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;以上内容 摘自官方文档&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2019 年 9 月 Blazor 发布了 0.1.0 版本，后面发布了 Blazor Server 正式版，但是 Blazor WebAssembly 一直还在预览版中，Blazor Server 虽然实现了 C# 来编写界面，但是应用UI更新，需要通过UI事件，经过 SignalR 与服务端通信执行业务代码来应用UI更新。最令我感兴趣的是 Blazor WebAssembly，期待已久 ，实现了开放 Web 标准 WebAssembly ，让在客户端浏览器运行C#代码成为现实，我觉得在这一点，微软走在了前列，虽然大家可能会用 Silverlight 的黑历史来吐槽微软，但是这次不一样，WebAssembly 不是微软自家定的。虽然目前它还很年轻，但是我对它还是非常期待与看好。&lt;/p&gt;
&lt;h2 id=&quot;二-blazor-server-与-blazor-webassembly-对比&quot;&gt;二. Blazor Server 与 Blazor WebAssembly 对比&lt;/h2&gt;
&lt;h3 id=&quot;1pwa的支持&quot;&gt;1.PWA的支持&lt;/h3&gt;
&lt;p&gt;Server 不支持，Wasm 支持&lt;/p&gt;
&lt;h3 id=&quot;2更新ui流程不同&quot;&gt;2.更新UI流程不同&lt;/h3&gt;
&lt;p&gt;（1）Blazor Server 在页面加载时，会创建一个 WebSocket 连接（通过 SignalR），会一直发送心跳包来检测连接是否健康。&lt;/p&gt;
&lt;p&gt;心跳包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002418091-217960465.png&quot; alt=&quot;image-20200528233338828&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Blazor Server 执行业务代码逻辑是通过 SignalR 发送事件到服务端，服务端执行代码，再返回结果，根据返回的数据渲染UI，应用更新，通过下图可以看到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002417447-289308866.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）Blazor WebAssembly 则不同，无需通过服务端来执行C#代码，直接在浏览器执行，来更新UI，获取数据。类似于 Ajax ，通过调用 HTTP Api 来获取数据。&lt;/p&gt;
&lt;p&gt;这里需要说明的是，VS里面打断点依然能被正常捕获，是因为 Blazor 框架与 VS 进行了通信来实现 Debug，不然要是不能 Debug 问题可就大了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002416429-2067355818.png&quot; alt=&quot;image-20200528234513970&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在VS中一直F10也会进入到一个JS文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002415482-183363477.png&quot; alt=&quot;image-20200528234556470&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然都能被Debug，但是流程实则完全不一样。&lt;/p&gt;
&lt;h2 id=&quot;三-建立第一个-blazor-webassembly-应用&quot;&gt;三. 建立第一个 Blazor WebAssembly 应用&lt;/h2&gt;
&lt;h3 id=&quot;1必备条件&quot;&gt;1.必备条件&lt;/h3&gt;
&lt;p&gt;因为 Blazor WebAssembly 是在 2020.05.19 才发布正式版的，所以 Visual Studio 2019 需要更新到新版 &amp;gt;=16.6（macOS &amp;gt;=8.6）&lt;/p&gt;
&lt;h3 id=&quot;2创建应用&quot;&gt;2.创建应用&lt;/h3&gt;
&lt;p&gt;第一步，选择 Blazor App 模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002415057-461342098.png&quot; alt=&quot;image-20200522001741402&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步，选择 Blazor WebAssembly&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002414623-920859366.png&quot; alt=&quot;image-20200522003100577&quot;/&gt;&lt;/p&gt;
&lt;p&gt;建立好的项目具有以下目录结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002414266-1646108033.png&quot; alt=&quot;image-20200522003222636&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行项目，可以看到加载了很多熟悉的 dll&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002413816-279357960.png&quot; alt=&quot;image-20200522003329595&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中列表页面，通过 HttpClient 访问了一个静态的 json 文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002413102-132717433.png&quot; alt=&quot;image-20200522003503239&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002412546-669315426.png&quot; alt=&quot;image-20200522003526807&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四-初体验&quot;&gt;四. 初体验&lt;/h2&gt;
&lt;h3 id=&quot;1运行浅析&quot;&gt;1.运行浅析&lt;/h3&gt;
&lt;p&gt;入口点在 wwwroot/index.html 通过 blazor.webassembly.js 下载 .NET 运行时、应用程序和依赖。这个js文件并不包含在项目文件中，是由 &lt;code&gt;Microsoft.AspNetCore.Components.WebAssembly.Build&lt;/code&gt; 工具包提供的，编译生成的时候会输出到目标目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002412074-1238873818.png&quot; alt=&quot;image-20200522004402373&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2实现简单逻辑&quot;&gt;2.实现简单逻辑&lt;/h3&gt;
&lt;p&gt;简单的改了 Counter 的代码，成了一个 Guid 生成器，这点体验还是很好的，直接用C#代码编写逻辑而不是JavaScript，而且是本地运行直接运行C#代码，不需要 Blazor Server 这样的通过 SignalR 通信。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;@page &quot;/counter&quot;

    &amp;lt;h1&amp;gt;GUID 生成器&amp;lt;/h1&amp;gt;

&amp;lt;div class=&quot;row&quot;&amp;gt;
    &amp;lt;div class=&quot;col-2&quot;&amp;gt;
        &amp;lt;input class=&quot;form-control&quot; type=&quot;text&quot;  value=&quot;@_guidValue&quot;/&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;col-10&quot;&amp;gt;
        &amp;lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;GenerateGuid&quot;&amp;gt;生 成&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;


@code {
    private Guid? _guidValue;

    private void GenerateGuid()
    {
        _guidValue = Guid.NewGuid();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002411640-1587238845.gif&quot; alt=&quot;guid_ys&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3与js的互操作&quot;&gt;3.与JS的互操作&lt;/h3&gt;
&lt;p&gt;上面实现了GUID生成器，但是每次生成了都需要自己去输入框复制，不方便，现在实现一个自动复制到剪贴板的功能。&lt;/p&gt;
&lt;p&gt;此功能无法百分百通过C#代码来实现，需要与JS进行交互。&lt;/p&gt;
&lt;p&gt;先编写 JS:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;window.clipboardCopy = {
    copyText: function (text) {
        navigator.clipboard.writeText(text).then(function () {
            alert(&quot;Copied to clipboard!&quot;);
        })
            .catch(function (error) {
                alert(error);
            });
    }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该JS放置的位置，可以写在Js文件中，在Index.html中应用，也可以直接写在 Index.html中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002410682-1800522270.png&quot; alt=&quot;image-20200529001147746&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在 Razor 组件中注入 JSRuntime，并调用该JS:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;@page &quot;/counter&quot;
@inject IJSRuntime JsRuntime

&amp;lt;h1&amp;gt;GUID 生成器&amp;lt;/h1&amp;gt;

&amp;lt;div class=&quot;row&quot;&amp;gt;
    &amp;lt;div class=&quot;col-2&quot;&amp;gt;
        &amp;lt;input class=&quot;form-control&quot; type=&quot;text&quot; value=&quot;@_guidValue&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;col-10&quot;&amp;gt;
        &amp;lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;GenerateGuid&quot;&amp;gt;生 成&amp;lt;/button&amp;gt;
        &amp;lt;button class=&quot;btn btn-danger&quot; @onclick=&quot;CopyTextToClipboard&quot;&amp;gt;复制到剪贴板&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;


@code {
    private Guid? _guidValue;

    private void GenerateGuid()
    {
        _guidValue = Guid.NewGuid();
    }

    private async Task CopyTextToClipboard()
    {
        await JsRuntime.InvokeVoidAsync(&quot;clipboardCopy.copyText&quot;, _guidValue);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002410106-1746675554.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小技巧：通过 &lt;code&gt;dotnet watch run&lt;/code&gt; 命令可以获得更快乐的开发体验。&lt;/p&gt;
&lt;h2 id=&quot;五结束&quot;&gt;五.结束&lt;/h2&gt;
&lt;p&gt;Blazor WebAssembly 的初次尝试到此就结束了，一直在等正式版，到现在终于等到了，我也是才是学习它，后面陆续会出一些分享文章，希望可以与大家一起学习进步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002408893-1807241989.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668104/202005/668104-20200529002408349-1581450596.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 May 2020 00:18:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<og:description>一. 前言 Blazor 的整体介绍以及特点与优势，建议翻阅 Blazor 介绍。 Blazor 是一个可是使用 .NET/C# 来编写交互式客户端的 Web UI 框架，在官网有一句话概括 “Bui</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stulzq/p/12984971.html</dc:identifier>
</item>
<item>
<title>程序员辉辉想裸辞，但又不太敢 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12985339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12985339.html</guid>
<description>&lt;p&gt;有个读者辉辉发来很长很长一段文字，要我答疑解惑一下，我看问题挺具有代表性的，就打算专门写一篇文章来一一回复下。毕竟遇到用心的读者，我就只有更用心，能帮一点是一点，对不对？&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/lizhi-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;问题一：二哥，我现在感觉个人能力有点差，两年工作生涯，但几乎没什么成长。我不算是科班，学历大专，好像和你一个学校，这里叫一声学长吧。另外，我计算机基础非常差。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过确认，辉辉确实是如假包换的学弟，但学校名称我仍然选择保密，主要是为了给学校留点面子，呵呵（战术性）。&lt;/p&gt;
&lt;p&gt;比辉辉幸运的是，我大学专业就是计算机网络，学的 Java，虽然大学两年也没学到啥，但好歹算是入了门吧。至于以后的造化还是要看个人啊。&lt;/p&gt;
&lt;p&gt;不过，工作的前两年，我的成长速度巨快，应该说是同一批进公司里面最优秀的，不接受反驳。工资上虽然不是第一，毕竟学历还是有限制，但工作能力绝对第一，木得说啊。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;能抗的差事我都能抗，虽然经常莫名其妙背锅，但无怨无悔，能力到手才是最重要的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;辉辉说自己几乎没有成长，我觉得要么是自卑情绪严重，要么进的公司有问题，因为刚工作的前两三年，是成长的黄金时期啊。如果说是公司的原因，那么早点离职是好事，真的。&lt;/p&gt;
&lt;p&gt;如果是自身的原因，那就还有的救，怎么救呢？&lt;/p&gt;
&lt;p&gt;制造恐慌，比如说，再特么不进步，连媳妇都找不到；再比如说，再特么努力，连房子也买不到。&lt;/p&gt;
&lt;p&gt;压力过大会造成焦虑，但适当的压力绝对是动力啊。这么一想，王者荣耀还不赶紧戒掉？&lt;/p&gt;
&lt;p&gt;我大学就上了两年，绝对是班里为数不多的渣渣，至少就我一个人敢烫爆炸头吧，照片就不爆了，还在 QQ 空间里仅自己可见着。但找到实习工作后，态度是 180 度大转变啊，我一想到如果表现不好被辞退了，又要还培训费的贷款，就心慌啊，总不能再厚着脸皮找父母要钱吧，那真没出息。&lt;/p&gt;
&lt;p&gt;再者，我看着那些苏州的土著，拿着和我一样的实习工资，竟然开着豪车上班，我就觉得太特么不公平了，再不比别人多付出点，社会真要把我毒打到失去自我。&lt;/p&gt;
&lt;p&gt;多刺激刺激自己，真的，有时候，你不逼自己一把，你就不知道自己有多菜逼，不，牛逼。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/lizhi-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;问题二：现在工作压力特别大，由于没有主管，到六月份我就要顶到这个位置。我能力不足，感觉不足以胜任这样的压力，有时候不是加班就能解决问题啊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就现在的大环境，谁要说谁没有压力，我过去扇他一嘴巴，嚣张啥呢！&lt;/p&gt;
&lt;p&gt;前两天，老板打电话给我说，公司真的快撑不下去了，洗个车都要花呗分期，再找不来投资，咱真要 GG 了。&lt;/p&gt;
&lt;p&gt;虽然我不想闲吃萝卜淡操心，但有一说一，老板卖过一套房是真的，至于第二套要不要卖，要视情况而定。&lt;/p&gt;
&lt;p&gt;看看看看，至少有两套房的人都有压力，我们能没有压力？&lt;/p&gt;
&lt;p&gt;我实习期结束后，就顶到了项目组长的位置，整个团队的技术难点、代码质量就全交给我负责了。谁要说我当时的能力足够胜任这份差事，我敢给他急眼，真的。&lt;/p&gt;
&lt;p&gt;除了硬上，除了无休止的背锅，还能有啥办法，但说实话，体验一遍下来，能力是真的锻炼了出来。毕竟人最怕不是能力差啊，而是机会啊！&lt;/p&gt;
&lt;p&gt;就算是加班解决不了问题，就算是车到山前没有路，那你想想，至少你经历过，成长了啊！&lt;/p&gt;
&lt;p&gt;我就不相信，刘禅有能力胜任这份帝王的压力，但人家仍然抗了啊，咱还能不如？&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/lizhi-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;问题三：想找一些时间来学习，但工作占据了自己几乎全部时间，真没时间学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一说到时间问题，我脑海里第一时间就跳出了罗 XX，真的，真·时间刺客啊。&lt;/p&gt;
&lt;p&gt;伟大的鲁迅同志曾经说过一句话，时间就像海绵里的水，挤挤总会有的。虽然说这句话不太符合能量守恒定律，但还是有一定的道理的。&lt;/p&gt;
&lt;p&gt;每个人的一天都是 24 小时，这个真没跑了。但我想说的是，我上初二的时候，真的拼过一把，体验过一把学习的极致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;凌晨三点多就起来钻到教室点起我的小煤油灯，真正做到了挑灯夜读啊，就差悬梁刺股了&lt;/strong&gt;。那学期，我成功超越了班里的一名同学，成为了班里学习最好的那个，全年级第三名，初中三年唯一一次。&lt;/p&gt;
&lt;p&gt;如果拼不了智商，拼不了家产，拼不了情商，真的，能拼身体的时候还是要拼一下的。&lt;/p&gt;
&lt;p&gt;我现在什么生活状态呢？很自由，老板喊我去上班我都不一定去，真的是，没有吹。每天早上六点多起来，骑一个小时的单车，回家后就伏案写作，或者读书，刷刷 B 站上学习区 Up 主的视频。&lt;/p&gt;
&lt;p&gt;为什么我有自由的资本，当然是因为我拼过。想学习，时间总是有的。如果真的没时间，可以把“几乎”二字去掉，那样的话，就当一天和尚撞一天钟吧，谁也没辙。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/lizhi-04.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;问题四：想一边工作一边面试是不可能的，工作状态不允许，要找新工作就裸辞；但我又担心裸辞后找不到工作。最坏的结果就是两三个月找不到工作，这样的后果我还可以承担。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里透露一点吧，我之前有个同事，为了出去面试，请的病假，真的是把自己搞病的那种。&lt;/p&gt;
&lt;p&gt;当然了，这些手段最好咱不去使，但如果公司真把你逼到这份上，那你看着办吧，点到为止。&lt;/p&gt;
&lt;p&gt;不是有那句话嘛，人不犯我我不犯人，人若犯我我必犯人。&lt;/p&gt;
&lt;p&gt;辉辉你说自己已经工作两年时间了，我觉得攒个十万块钱应该能做到吧，这也没有的话，也得有五万块吧，要不然真有点说不过去。&lt;/p&gt;
&lt;p&gt;五万块我觉得过两三个月没问题，过四五个月也没问题，意味着真的裸辞了，四五个月内找到一家心仪的公司真没问题。到时候，经济肯定会复苏，人才的缺口肯定会有。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/lizhi-05.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;问题五：现在纠结要不要裸辞，我一个朋友建议出去，找一个合格的团队，自己不懂的时候给指点一下。不至于让自己搞不出来还要继续去搞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;人生有很多选择，真的。选择的对与错，我觉得其实和选择的关系不大，为什么这么说呢？因为人生的成长本来就是不可逆的。&lt;/p&gt;
&lt;p&gt;我后悔过，怎么高三高四的时候不好好努力下，考个好一点的大学，也不至于起点那么低；我还后悔过，怎么大一大二的时候没有写博客，要不然早就很牛逼了；我还还后悔过，当年怎么就选择了和现在这个老板出来创业，留在原来的公司多好！&lt;/p&gt;
&lt;p&gt;但我在后悔的时候忽略了一个事实——马后炮，当你做出选择的时候，就是最优选择；在你还没有裸辞之前，窝在原来的公司就是辉辉你的最优选择，不是吗？&lt;/p&gt;
&lt;p&gt;之所以纠结，我觉得并不是公司造成的，而是你自己造成的。&lt;/p&gt;
&lt;p&gt;有导师当然好啊，有人指点当然好啊，但师傅只能领进门啊，没有师傅的时候幻象着师傅出现，是不是有点不切实际？&lt;/p&gt;
&lt;p&gt;白手起家，对。大多数平凡的人，普通的人，一出生下来就和某些人有着巨大的差距，而这差距绝不是别人能帮你缩短的，而是你自己啊！&lt;/p&gt;
&lt;p&gt;想想“鸡生蛋蛋生鸡”的问题，谁是第一个师傅，不是天生的啊，都是后天一点点积累的。&lt;strong&gt;如果你渴望被别人指导，那么你就永远也成长不起来&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我在之前的一篇文章里提到过，我有一段时间特别迷安晓辉，我三番五次请求他作为我的人生导师，但都被无情地拒绝了。我不能说我现在就比他做的好，至少在某些层面上已经超过了他。比如说我在 CSDN 上的总排名，现在是 43，超过了他；再比如说「沉默王二」这个号的平均阅读量，也超过了他的「程序视界」。&lt;/p&gt;
&lt;p&gt;人，总要学会自己成长。况且现在的互联网是这样的开放，GitHub 上、码云上优质的开源项目多得是，身边的导师也多得是，各个博主的技术交流群，都可以请教交流啊，只要你脸皮够厚，够锲而不舍！&lt;/p&gt;
&lt;p&gt;辉辉你现在来请教我，不就很明智吗？我不就是你的资源吗？还特么是免费服务！&lt;/p&gt;
&lt;p&gt;别再徘徊不定了，答案自在你心中！&lt;/p&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读。回复关键字「&lt;strong&gt;简历&lt;/strong&gt;」更有一份技术大佬整理的优质简历模板，助你一臂之力。&lt;/p&gt;
&lt;blockquote readability=&quot;4.4565217391304&quot;&gt;
&lt;p&gt;本文已收录 GitHub，&lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;&lt;strong&gt;传送门~&lt;/strong&gt;&lt;/a&gt; ，里面更有大厂面试完整考点，欢迎 Star。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我是沉默王二，一枚有颜值却靠才华苟且的程序员。&lt;strong&gt;关注即可提升学习效率，别忘了三连啊，点赞、收藏、留言，我不挑，嘻嘻&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Fri, 29 May 2020 00:12:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>有个读者辉辉发来很长很长一段文字，要我答疑解惑一下，我看问题挺具有代表性的，就打算专门写一篇文章来一一回复下。毕竟遇到用心的读者，我就只有更用心，能帮一点是一点，对不对？ 问题一：二哥，我现在感觉个人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12985339.html</dc:identifier>
</item>
<item>
<title>Java的字节流，字符流和缓冲流对比探究 - 黄钰朝</title>
<link>http://www.cnblogs.com/misterchaos/p/12985332.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/misterchaos/p/12985332.html</guid>
<description>&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;所谓IO，也就是Input/Output。Java程序跟外部进行的数据交换就叫做Java的IO操作。程序中数据的输入输出，被抽象为流， 按照相对于程序的流向，可分为输出流和输入流。 &lt;strong&gt;按照数据流的格式，可分为字节流和字符流&lt;/strong&gt;。Java IO流的体系很庞大，功能丰富。&lt;/p&gt;
&lt;p&gt;本文主要探讨了Java中字节操作和字符操作的区别。&lt;/p&gt;
&lt;h2 id=&quot;二、字节操作和字符操作&quot;&gt;二、字节操作和字符操作&lt;/h2&gt;
&lt;p&gt;下图可以表示Java 的IO体系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nextcloud.hellochaos.cn/index.php/s/Tpkw2Xb3oYZ8pCf/preview&quot; alt=&quot; ：&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类似于C语言中二进制文件和文本文件的区别，字符其实只是一种特殊的二进制字节，是按照一定的编码方式处理之后，按照一定规则来存储信息的数据，字符在计算机中也是由二进制组成的，只不过这种二进制可以按照一种规则解码后，成为人类可以直接阅读的自然语言，而普通的二进制文件只有计算机能直接“阅读”。&lt;strong&gt;字节操作和字符操作的区别就在于数据的格式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Java中，字节输入输出流有两个抽象基类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字节输入流：InputStream&lt;/li&gt;
&lt;li&gt;字节输出流：OutputStream&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;字符输入输出流也有两个抽象基类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;字符输入流：Reader&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符输出流：Writer&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外， Java提供了从字节流到字符流的转换流，分别是InputStreamReader和OutputStreamWriter，但没有从字符流到字节流的转换流。实际上：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符流=字节流+编码表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一次读取一个字节数组的效率明显比一次读取一个字节的效率高，因此Java提供了带缓冲区的字节类，称为字节缓冲区类：&lt;strong&gt;BufferedInputStream和BufferedOutputStream&lt;/strong&gt;，同理还有字符缓冲区类&lt;strong&gt;BufferedReader和BufferedWriter。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在使用场景上，无法直接获取文本信息的二进制文件，比如图片，mp3，视频文件等，只能使用字节流。而对于文本信息，则更适合使用字符流。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、两种方式的效率测试&quot;&gt;三、两种方式的效率测试&lt;/h2&gt;
&lt;p&gt;下面通过编写测试程序来比较两种方式的效率区别：&lt;/p&gt;
&lt;h3 id=&quot;31-测试代码&quot;&gt;3.1 测试代码&lt;/h3&gt;
&lt;p&gt;笔者编写了8个方法来分别测试字节方式/字符方式的输入输出流，带缓冲区的输入输出流。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.verygood.island;

import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.platform.commons.annotation.Testable;

import java.io.*;

/**
 * @author &amp;lt;a href=&quot;mailto:kobe524348@gmail.com&quot;&amp;gt;黄钰朝&amp;lt;/a&amp;gt;
 * @description
 * @date 2020-05-27 08:50
 */
@Testable
public class UnitTest {

    public static final String PATH = &quot;C:\\Users\\Misterchaos\\Documents\\Java Develop Workplaces\\&quot; +
            &quot;Github repository\\island\\src\\test\\java\\com\\verygood\\island\\&quot;;

    /**
     * 用于输出的对象
     */
    public static byte[] outputbytes = null;

    public static char[] outputchars = null;

    int count = 1;

    /**
     * 用于输入的对象
     */
    public static final File inputFile = new File(&quot;C:\\Users\\Misterchaos\\Downloads\\安装包\\TEST.zip&quot;);


    @BeforeClass
    public static void before() {
        StringBuilder stringBuilder = new StringBuilder(&quot;&quot;);
        for (int i = 0; i &amp;lt; 1000000; i++) {
            stringBuilder.append(&quot;stringstringstringstringstringstring&quot;);
        }
        outputbytes = stringBuilder.toString().getBytes();
        outputchars = stringBuilder.toString().toCharArray();
    }


    @Test
    public void test0() {
        System.out.println(&quot;--------------------------------------------------------&quot;);
        System.out.println(&quot;                      测试输出流                          &quot;);
        System.out.println(&quot;--------------------------------------------------------&quot;);
    }


    // 字节流
    @Test
    public void test1() {
        try {
            System.out.println(&quot;********方式一：字节流输出**********&quot;);
            // 新建文件命名
            String name = PATH + &quot;字节流输出文件.txt&quot;;
            File file = new File(name);
            // 创建输入输出流对象
            FileOutputStream fos = new FileOutputStream(file);
            // 读写数据
            long s1 = System.currentTimeMillis();// 测试开始，计时
            writeBytes(fos);
            long s2 = System.currentTimeMillis();// 测试结束，计时
            fos.close();
            System.out.println(&quot;输出文件耗时：&quot; + (s2 - s1) + &quot;ms&quot;);
            System.out.println(&quot;文件大小：&quot; + file.length() / 1024 + &quot;KB&quot;);
            file.delete();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    // 字节流
    @Test
    public void test2() {
        try {
            System.out.println(&quot;********方式二：字符流输出**********&quot;);
            // 新建文件命名
            String name = PATH + &quot;字符流输出文件.txt&quot;;
            File file = new File(name);
            // 创建输入输出流对象
            FileWriter fileWriter = new FileWriter(file);
            // 读写数据
            long s1 = System.currentTimeMillis();// 测试开始，计时
            writeChars(fileWriter);
            long s2 = System.currentTimeMillis();// 测试结束，计时
            fileWriter.close();
            System.out.println(&quot;输出文件耗时：&quot; + (s2 - s1) + &quot;ms&quot;);
            System.out.println(&quot;文件大小：&quot; + file.length() / 1024 + &quot;KB&quot;);
            file.delete();

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    // 字节缓冲流
    @Test
    public void test3() {
        try {
            System.out.println(&quot;********方式三：字节缓冲流输出**********&quot;);
            // 新建文件命名
            String name = PATH + &quot;字节缓冲流输出文件.txt&quot;;
            File file = new File(name);
            // 创建输入输出流对象
            FileOutputStream fileOutputStream = new FileOutputStream(file);
            BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);
            // 读写数据
            long s1 = System.currentTimeMillis();// 测试开始，计时
            writeBytes(bufferedOutputStream);
            long s2 = System.currentTimeMillis();// 测试结束，计时
            bufferedOutputStream.close();
            System.out.println(&quot;输出文件耗时：&quot; + (s2 - s1) + &quot;ms&quot;);
            System.out.println(&quot;文件大小：&quot; + file.length() / 1024 + &quot;KB&quot;);
            file.delete();

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    // 字符缓冲流
    @Test
    public void test4() {
        try {
            System.out.println(&quot;********方式四：字符缓冲流输出**********&quot;);
            // 新建文件命名
            String name = PATH + &quot;字符缓冲流输出文件.txt&quot;;
            File file = new File(name);
            // 创建输入输出流对象
            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(file));
            // 读写数据
            long s1 = System.currentTimeMillis();// 测试开始，计时
            for (int i = 0; i &amp;lt; count; i++) {
                bufferedWriter.write(outputchars);
            }
            long s2 = System.currentTimeMillis();// 测试结束，计时
            bufferedWriter.close();

            System.out.println(&quot;输出文件耗时：&quot; + (s2 - s1) + &quot;ms&quot;);
            System.out.println(&quot;文件大小：&quot; + file.length() / 1024 + &quot;KB&quot;);
            file.delete();

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    @Test
    public void test5() {
        System.out.println(&quot;--------------------------------------------------------&quot;);
        System.out.println(&quot;                      测试输入流                          &quot;);
        System.out.println(&quot;--------------------------------------------------------&quot;);
    }


    // 字节流
    @Test
    public void test6() {
        try {
            System.out.println(&quot;********方式一：字节流输入**********&quot;);
            // 新建文件命名
            // 创建输入输出流对象
            long s1 = System.currentTimeMillis();// 测试开始，计时
            FileInputStream fileInputStream = new FileInputStream(inputFile);
            // 读写数据
            // 读写数据
            while (fileInputStream.read() != -1) {
            }
            fileInputStream.close();
            long s2 = System.currentTimeMillis();// 测试结束，计时
            System.out.println(&quot;输入文件耗时：&quot; + (s2 - s1) + &quot;ms&quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 字节流
    @Test
    public void test7() {
        try {
            System.out.println(&quot;********方式二：字符流输入**********&quot;);
            // 新建文件命名
            long s1 = System.currentTimeMillis();// 测试开始，计时
            // 创建输入输出流对象
            FileReader fileReader = new FileReader(inputFile);
            // 读写数据
            while (fileReader.read() != -1) {
            }
            fileReader.close();
            long s2 = System.currentTimeMillis();// 测试结束，计时
            System.out.println(&quot;输入文件耗时：&quot; + (s2 - s1) + &quot;ms&quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 字节缓冲流
    @Test
    public void test8() {
        try {
            System.out.println(&quot;********方式三：字节缓冲流输入**********&quot;);
            // 新建文件命名
            long s1 = System.currentTimeMillis();// 测试开始，计时
            BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(inputFile));
            // 创建输入输出流对象
            // 读写数据
            while (bufferedInputStream.read() != -1) {
            }
            bufferedInputStream.close();
            long s2 = System.currentTimeMillis();// 测试结束，计时
            System.out.println(&quot;输入文件耗时：&quot; + (s2 - s1) + &quot;ms&quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    // 字符缓冲流
    @Test
    public void test9() {
        try {
            System.out.println(&quot;********方式四：字符缓冲流输入**********&quot;);
            // 新建文件命名
            long s1 = System.currentTimeMillis();// 测试开始，计时
            // 创建输入输出流对象
            BufferedReader bufferedReader = new BufferedReader(new FileReader(inputFile));
            // 读写数据
            while (bufferedReader.read() != -1) {
            }
            bufferedReader.close();
            long s2 = System.currentTimeMillis();// 测试结束，计时
            System.out.println(&quot;输入文件耗时：&quot; + (s2 - s1) + &quot;ms&quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }


    /**
     * 字节输出
     */
    private void writeBytes(OutputStream fos) throws IOException {
        for (int i = 0; i &amp;lt; count; i++) {
            for (int j = 0; j &amp;lt; outputbytes.length; j++) {
                fos.write(outputbytes[j]);
            }
        }
    }

    /**
     * 字符输出
     */
    private void writeChars(Writer writer) throws IOException {
        for (int i = 0; i &amp;lt; count; i++) {
            for (int j = 0; j &amp;lt; outputchars.length; j++) {
                writer.write(outputchars[j]);
            }
        }
    }


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-测试结果&quot;&gt;3.2 测试结果&lt;/h3&gt;
&lt;p&gt;测试结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;--------------------------------------------------------
                      测试输出流                          
--------------------------------------------------------
********方式一：字节流输出**********
输出文件耗时：153798ms
文件大小：35156KB

********方式二：字符流输出**********
输出文件耗时：5503ms
文件大小：35156KB

********方式三：字节缓冲流输出**********
输出文件耗时：514ms
文件大小：35156KB

********方式四：字符缓冲流输出**********
输出文件耗时：600ms
文件大小：35156KB
--------------------------------------------------------
                      测试输入流                          
--------------------------------------------------------
********方式一：字节流输入**********
输入文件耗时：3643276ms

********方式二：字符流输入**********
输入文件耗时：93332ms

********方式三：字节缓冲流输入**********
输入文件耗时：4700ms

********方式四：字符缓冲流输入**********
输入文件耗时：51538ms
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33-结果分析&quot;&gt;3.3 结果分析&lt;/h3&gt;
&lt;p&gt;测试发现，&lt;strong&gt;如果输出的对象是整个直接输出到文件，使用带缓冲区的输出流实际效率更低&lt;/strong&gt;，实际测试得到结果是：带缓冲区的输出流所需时间大约是不带缓冲区输出流的两倍。查看源码可以看到：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; public synchronized void write(byte b[], int off, int len) throws IOException {
        if (len &amp;gt;= buf.length) {
            /* If the request length exceeds the size of the output buffer,
               flush the output buffer and then write the data directly.
               In this way buffered streams will cascade harmlessly. */
            flushBuffer();
            out.write(b, off, len);
            return;
        }
        if (len &amp;gt; buf.length - count) {
            flushBuffer();
        }
        System.arraycopy(b, off, buf, count, len);
        count += len;
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的注释已经清楚地写出来，&lt;strong&gt;如果写入的长度大于缓冲区的大小，则先刷新缓存区，然后直接写入文件。简而言之，就是不使用缓冲区！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此，笔者重新设计了使用场景，将一次性的输出改为了一个字节一个字节地输出，上面展示的就是改进后的测试结果。&lt;strong&gt;从这一次结果来看，带缓冲区的字节输出流有了非常明显的优势，整体的性能提升了将近400倍！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;在FileWriter和FileOutputStream的比较中，发现FileOutputStream的速度明显更慢，&lt;/strong&gt;查看源码发现：&lt;/p&gt;
&lt;p&gt;FileWriter内部调用了StreamEncoder来输出，而StreamEncoder内部维护了一个8192大小的缓冲区。&lt;strong&gt;这样就不难解释为什么FileOutputStream使用字节的方式节省了编码开销反而效率更低，原因就在于FileWriter实际是带有缓冲区的，因此FileWriter在使用了BufferedWriter封装之后性能只有2倍的提升也就不足为奇了。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、字节顺序endian&quot;&gt;四、字节顺序endian&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;字节序，或字节顺序（&quot;Endian&quot;、&quot;endianness&quot; 或 &quot;byte-order&quot;），描述了计算机如何组织字节，组成对应的数字。&lt;strong&gt;大端字节序（big-endian）&lt;/strong&gt;：高位字节在前，低位字节在后。小端字节序（little-endian）反之。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;笔者使用编写了测试代码来测试C语言中二进制和文本两种方式效率区别，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;#define _CRT_SECURE_NO_WARNINGS
#include &quot;stdio.h&quot; 
#include &amp;lt;stdlib.h&amp;gt; 
#include &quot;time.h&quot;  
#define CLOCKS_PER_SEC ((clock_t)1000)  

int main()
{
        FILE* fpRead = fopen(&quot;C:\\test.txt&quot;, &quot;r&quot;);
        if (fpRead == NULL)
        {
                printf(&quot;文件打开失败&quot;);
                return 0;
        }
        clock_t start, finish;
        int a=0;
        start = clock();
        while (!feof(fpRead))
        {
                a = fgetc(fpRead);
        }
        finish = clock();
        double text_duration = (double)(finish - start) / CLOCKS_PER_SEC;
        printf(&quot;\n&quot;);
        

        fclose(fpRead);
        
        fpRead = fopen(&quot;C:\\test.txt&quot;,&quot;rb&quot;);

        if (fpRead == NULL)
        {
                printf(&quot;文件打开失败&quot;);
                return 0;
        }
        start = clock();
        while (!feof(fpRead))
        {
                a = fgetc(fpRead);
        }
        finish = clock();
        double binary_duration = (double)(finish - start) / CLOCKS_PER_SEC;
        printf(&quot;\n&quot;);

        printf(&quot;文本方式耗时：%f seconds\n&quot;, text_duration);
        printf(&quot;二进制方式耗时：%f seconds\n&quot;, binary_duration);

        system(&quot;pause&quot;);
        return 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;文本方式耗时：3.042000 seconds
二进制方式耗时：2.796000 seconds
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到二进制的方式效率比文本方式稍微有所提高。&lt;/p&gt;
&lt;h2 id=&quot;五、综合对比&quot;&gt;五、综合对比&lt;/h2&gt;
&lt;p&gt;根据以上实验，可以总结得出，字节流和字符流具有以下区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在同样使用缓冲区的前提下，&lt;strong&gt;字节流比字符流的效率稍微高一点&lt;/strong&gt;。对于频繁操作且每次输入输出的数据量较小时，使用缓冲区可以带来明显的效率提升。&lt;/li&gt;
&lt;li&gt;操作对象上，&lt;strong&gt;字节流操作的基本单元为字节，字符流操作的基本单元为Unicode码元&lt;/strong&gt;（字符）。&lt;/li&gt;
&lt;li&gt;字节流通常用于处理二进制数据，实际上它可以处理任意类型的数据，但它不支持直接写入或读取Unicode码元。而字符流通常处理文本数据，它支持写入及读取Unicode码元。&lt;/li&gt;
&lt;li&gt;从源码可以看出来，&lt;strong&gt;字节流默认不使用缓冲区，而字符流内部使用了缓冲区&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;六、总结&quot;&gt;六、总结&lt;/h2&gt;
&lt;p&gt;在这次博客编写过程中，测试字节流和字符流的效率时曾出现非常令人费解的结果，使用BufferWriter和BufferedOutputSteam封装的输出流效率都没有提高反而有所降低，后来查看源码才发现了问题所在。此外，字节流的效率明显低于字符流也令笔者抓狂，最后发现字符流内部维护了缓冲区，问题才迎刃而解。&lt;/p&gt;
</description>
<pubDate>Fri, 29 May 2020 00:07:00 +0000</pubDate>
<dc:creator>黄钰朝</dc:creator>
<og:description>一、前言 所谓IO，也就是Input/Output。Java程序跟外部进行的数据交换就叫做Java的IO操作。程序中数据的输入输出，被抽象为流， 按照相对于程序的流向，可分为输出流和输入流。 按照数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/misterchaos/p/12985332.html</dc:identifier>
</item>
<item>
<title>读懂操作系统之虚拟内存（一） - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/12969171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/12969171.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;由于个人对虚拟内存这块特别感兴趣，所以就直接暂且跳过其他，接下来将通过几篇文章进行详细讲解，当然其他基础内容后续在我进行相应整体学习后也会同步输出文章，比如操作系统概念、程序链接、进程管理、页面置换算法、流水线、浮点指令、内存管理、磁盘管理等内容。不管周遭的环境如何，毕竟还很菜，坚持每天让自己进步一点点，放下暂时的焦虑，不如专注于眼前的学习，跟着我一起学习操作系统吧。&lt;/p&gt;
&lt;h2&gt;虚拟存储器设计初衷&lt;/h2&gt;
&lt;p&gt;缓存从高到低，主存可作为磁盘的缓存，我们将这项技术称作为虚拟存储器，基于历史观点，构造虚拟存储器的主要出于两个目的，其一是允许云计算在多个虚拟机之间有效而安全的共享存储器，其二则是受限的主存容量对程序设计所造成的极大影响。有了虚拟存储器这样可确保每个程序只能对划分给它的那部分主存进行读写操作，而主存只需存放程序中的活跃区域。虚拟存储器实现程序地址空间到物理地址的转换，通过这种转换处理加强了各个程序地址之间的保护。若用户加载多个程序直接到主存，很显然最终可能会超过主存的容量，如此一来，将程序进行卸载或转入成为程序员不可推卸的责任，加重了程序员的负担，那么怎样才能将程序员从这种情况中解放出来呢？现代操作系统将主存提供了一种对主存的抽象概念，叫作虚拟内存，虚拟内存是硬件异常，硬件地址翻译、主存、磁盘文件和内核软件的完美交互，虚拟内存主要提供了三种能力：【1】&lt;span&gt;将主存看成是一个存储在磁盘上的地址空间的高速缓存（作为缓存）&lt;/span&gt;【2】&lt;span&gt;为每个进程提供一致的地址空间，从而简化内存管理（作为内存管理）&lt;/span&gt;【3】&lt;span&gt;防止每个进程的地址空间被其他进程所破坏（作为内存保护）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200527213129987-2104916706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;映射原理：CPU生成一个虚拟地址（Virtual Address简称VA）来访问主存，但是在此之前需要将虚拟地址转换为物理地址，这个过程称作为地址转换或地址映射或地址翻译，为进行此操作需要CPU硬件和操作系统合作，通过内存管理单元（Memory Management Unit）上的地址翻译硬件，利用存储在主存上的查询表来翻译虚拟地址，该表的内容由操作系统管理。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;页表地址翻译&lt;/h2&gt;
&lt;p&gt;虚拟内存系统将虚拟内存划分为固定大小的块，这个块我们称作为虚拟页（Virtual Page简称VP），同理将物理内存划分为物理页（Physical Page简称PP），也叫页帧（Page Frame）。这里我们需要明白虚拟地址、虚拟页、物理地址、物理页这四者之间的联系。如下图，通过CPU产生虚拟地址访问主存的物理地址，而虚拟存储器和物理存储器分别被划分成虚拟页和物理页，所以结果变成将虚拟页映射到物理页。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200527215240006-1123554237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在虚拟存储器中，地址被划分为虚页号（Virtual Page Number简称VPN）和虚拟页页偏移（Virtual Page Offset简称VPO），如下为从虚拟页到物理页号（Physical Page Number简称PPN）的转换。物理页构成物理地址的高位部分，而页偏移保持不变，构成物理地址的低位部分。页偏移的位数决定了页的大小，当然，虚拟页地址可寻址的页数与物理地址可寻址的页数可以不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200528205446447-1932974057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如具有32位逻辑地址的操作系统，如果每个页面的大小为4KB，由于上述物理页号有18位，那么存储器物理页数为2^18，因此，逻辑上最多可以支持1GB的主存，但是实际上虚拟地址空间可支持4GB，如此为解决主存的受限控制。和缓存机制一样，我们必须有某种机制来判断一个虚拟页是否缓存在DRAM中某一个地方，如果是，那么系统必须确定这个虚拟页存放在哪个物理页中，如果未命中，系统必须确定这个虚拟页存储在磁盘的哪个位置，然后在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，然后替换这个牺牲页。此功能由软硬件共同提供，包括操作系统软件、MMU中的地址翻译硬件、存放在物理内存中的页表（Page Table简称PT）所决定，上述将虚拟页映射到物理页就是通过查询页表实现，一个页表是由页表条目（Page Table Entry简称PTE）的数组组成。如下为页表简要信息版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200528214432375-1717118551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到上述每个PTE是由一个有效位和一个包含物理页号或磁盘地址组成，有效位标识虚拟页是否被缓存在主存中， 若为1则说明该虚拟页已被缓存在主存中，若为0分为两种情况，可能是虚拟内存未创建虚拟页，也有可能是已创建虚拟页但还未缓存到主存，所以虚拟页集合由3个子集组成：【1】虚拟内存系统还未分配或未创建、【2】已缓存在物理内存中的已分配页、【3】未缓存在物理内存中的已分配页。页表在主存中的位置由硬件决定，硬件包含一个指向页表首地址的页表基址寄存器（Page Table Base Register简称PTBR）。简要翻译过程如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200528215647997-211397649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们进一步得出MMU将虚拟地址映射为物理地址的详细过程：&lt;span&gt;CPU产生虚拟地址，然后从虚拟地址中得到虚拟页号，接下来通过将虚拟页号作为索引去查找页表，通过得到对应PTE上的有效位来判断当前虚拟页是否在主存中，若命中则将对应PTE上的物理页号和虚拟地址中的虚拟页偏移进行串联从而构造出主存中的物理地址，否则未命中（专业名词称为“缺页”），此时MMU将引发缺页异常，从CPU传递到操作系统内核处理缺页异常处理程序，此时将选择一个牺牲页并将对应所缺虚拟页调入并更新页表上的PTE，缺页处理程序再次返回到原来的进程，再次执行缺页指令，CPU重新将虚拟地址发给MMU，此时虚拟页已存在物理内存中，所以命中，最终将请求的字返回给处理器。&lt;/span&gt;详细过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200528221912276-1423676717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进程的地址空间以及它在主存中可以访问的所有数据，都由驻存在主存中的页表所定义，操作系统只是简单的加载页表寄存器用来指向它所想激活的进程页表，而不是保存整个页表。由于不同进程使用相同的虚拟地址，因此每个进程有各自的页表，操作系统负责分配物理主存和更新页表，因为我们通过将页表分离来保护进程，进而保证不同进程的虚拟地址空间不会发生任何冲突。上述我们已经得知，一个32位逻辑地址空间的系统，每个页面的大小为4KB（2^12），那么页表将包含（2^32/2^12）= 大约100万个页表条目即PTE，假设每个条目占4个字节，那么每个进程的页表将占用（4*（2^32/2^12））= 4MB的内存。&lt;/p&gt;
&lt;h2&gt;TLB加快地址翻译&lt;/h2&gt;
&lt;p&gt;我们知道每次CPU产生一个虚拟地址就必须通过MMU去查询页表从而得到PTE，但是页表存储在主存中，因此程序访存至少需要两次：第一次访存获取物理地址、第二次访存获得数据。提高访问性能的关键在于依靠页表的访问局部性，当一个转换的虚拟页号被使用时，它可能在不久的将来会被再次用到，因为对该页中字的引用同时具有时间局部性和空间局部性。为了消除这样的开销，在MMU中包括一个关于PTE的小的缓存，称为翻译后备缓冲器（Translation-Lookasice Buffer简称TLB），有些书中被称为快表，所以TLB存在的目的是：用于记录最近使用地址的映射信息的高速缓存，从而可以避免每次都访问页表。TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块，TLB大概包含64-1024个PTE。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200528232315695-863433327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从虚拟页号中提取出用于组选择和行匹配的索引和标记字段，如果TLB有 T= 2^t个组，那么TLB索引（TLBI）是由VPN的t个最低位组成，而TLB标记（TLBT）是由VPN中剩余的位组成。上述我们了解到虚拟地址由虚拟页号和虚拟页偏移量组成，在这里再进行补充，&lt;span&gt;虚拟地址由虚拟页号（VPN）、虚拟页偏移量（VPO）、TLBI（TLB索引）、TLBT（TLB标记）组成，对于物理地址由物理页号（PPN）、物理页偏移量（PPO）、缓冲块内的字节偏移量（CO）、高速缓存索引（CI）、高速缓存标记（CT）组成。&lt;span&gt;那么利用TLB加快地址翻译的整个大概过程是怎样的呢？CPU产生一个虚拟地址，MMU从虚拟地址中提取出虚拟页号，然后从TLB中根据虚拟页号取出相应的PTE，进而通过物理页号和虚拟页偏移构造出物理地址，将其发送到高速缓存/主存，高速缓存/主存将返回的数据返回给CPU（现代操作系统都已有SRAM的高速缓存（一级缓存、二级缓存、三级缓存），因为地址翻译硬件发生在访问高速缓存之前，所以我们到底是通过虚拟地址还是物理地址访问高速缓存呢？大多数都是选择物理地址访问高速缓存）。整个过程如下图：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200528234125552-1856956954.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本节属于小试牛刀，只是从整体上去分析虚拟内存地址翻译原理，里面仍涉及太多细节，比如页面交换策略、页表和TLB所包含详细内容，多级页表、TLB查找PTE、TLB缺失等，下一节我们分析TLB缺失和页面交换具体原理。 &lt;/p&gt;
</description>
<pubDate>Fri, 29 May 2020 00:02:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 由于个人对虚拟内存这块特别感兴趣，所以就直接暂且跳过其他，接下来将通过几篇文章进行详细讲解，当然其他基础内容后续在我进行相应整体学习后也会同步输出文章，比如操作系统概念、程序链接、进程管理、页面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/12969171.html</dc:identifier>
</item>
<item>
<title>rocketmq初识 - stoneFang</title>
<link>http://www.cnblogs.com/stoneFang/p/12985326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneFang/p/12985326.html</guid>
<description>&lt;p&gt;通常一个消息队列需要掌握的知识点有Topic（主体）、Producer（生产者）、Consumer（消费者）、Queue（队列）、Delivery Semantics（消息传递范式）&lt;/p&gt;
&lt;p&gt;蛋疼的是不同的消息队列关于这些名词叫法不一样，含义也不是很精确。所以阿里起了一个&lt;a href=&quot;http://jm.taobao.org/2017/10/18/20171018/&quot;&gt;项目OpenMessaging&lt;/a&gt;去发起首个分布式消息领域的国际标准。不过好像并没有多少人买账，但这并不妨碍我们按照这个规范去梳理学习消息队列的知识。&lt;/p&gt;
&lt;p&gt;有兴趣的可以对照着看：&lt;a href=&quot;https://github.com/openmessaging/specification/blob/master/specification-schema.md&quot;&gt;https://github.com/openmessaging/specification/blob/master/specification-schema.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;rocketmq&lt;a href=&quot;https://github.com/apache/rocketmq/tree/master/docs/cn&quot;&gt;官方文档&lt;/a&gt;已经说的比较清楚了，不再赘述&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200528214535403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZTMTM2MDQ3MjE3NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;消息写入与存储&quot;&gt;&lt;strong&gt;消息写入与存储&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;消息是存储到broker中的，写到commit log中，先写内存，在刷盘。&lt;br/&gt;存储到磁盘中是直接以&lt;strong&gt;文件系统&lt;/strong&gt;的方式。为了提高磁盘写入效率，都是顺序写，这样所有的topic都放在了一起，&lt;strong&gt;这一点与kafka不同&lt;/strong&gt;，kafka以topic作为基本单元。&lt;/p&gt;
&lt;p&gt;单个commitlog 文件大小为1G，之后滚动写入不同文件。&lt;/p&gt;
&lt;h3 id=&quot;消息读取&quot;&gt;&lt;strong&gt;消息读取&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;消费者先从ConsumeQueue（消息逻辑队列）读取持久化消息的offset（偏移量）、size（大小）和消息Tag的HashCode值，再从CommitLog中读取消息的真正实体内容部分；&lt;/p&gt;
&lt;p&gt;此外为了快速定位消息，还有一种文件叫index，在给定消息 Topic 和 Key 的前提下，可以快速定位消息&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200528223301188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZTMTM2MDQ3MjE3NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;注意点&quot;&gt;注意点&lt;/h2&gt;
&lt;p&gt;使用消息队列时，需要注意的地方&lt;/p&gt;
&lt;h3 id=&quot;消息保存时间&quot;&gt;消息保存时间&lt;/h3&gt;
&lt;p&gt;rocketmq默认保存72小时，超过了，无论有没有消费都会丢弃，通过参数&lt;code&gt;fileReserverdTime&lt;/code&gt;来配置。&lt;br/&gt;&lt;strong&gt;注意&lt;/strong&gt;这个配置是全局配置，没法针对不同的topic设置不同的值，原因在上面已经提到过了，因为rocketmq存储消息是所有的topic放在一起的。&lt;/p&gt;
&lt;h3 id=&quot;消息有序&quot;&gt;消息有序&lt;/h3&gt;
&lt;p&gt;MessageListenerOrderly&lt;/p&gt;
&lt;h3 id=&quot;消息丢失&quot;&gt;消息丢失&lt;/h3&gt;
&lt;p&gt;理论上可以保证不丢失（接受消息重复，以及一定程度的写入性能下降），&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产端&lt;/strong&gt;&lt;br/&gt;同步模式,或者异步模式时需要处理发送失败情况&lt;/p&gt;
&lt;p&gt;所以保证消费的幂等性是必须的&lt;br/&gt;&lt;strong&gt;broker端&lt;/strong&gt;&lt;br/&gt;为了保证不丢，需要开启同步刷盘（防止内存数据丢失），同步复制（防止单点故障）。&lt;br/&gt;这样是有性能损失的。刷盘机制参数&lt;code&gt;flushDiskType&lt;/code&gt; 默认是&lt;code&gt;ASYNC_FLUSH&lt;/code&gt;,broker 会消息一定量后再刷盘，显然性能更好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消费端&lt;/strong&gt;&lt;br/&gt;消费完再CONSUME_SUCCESS&lt;br/&gt;生产端，消费端都有可能因为网络问题导致消息成功了，但是ack没有成功，所以会重复投递/消费。所以&lt;code&gt;Delivery Semantics&lt;/code&gt;一般选择&lt;code&gt;At least once&lt;/code&gt;。应用程序必须要保证&lt;code&gt;消费的幂等性&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;写入效率消费效率消费积压&quot;&gt;写入效率/消费效率/消费积压&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;发送端&lt;/strong&gt;&lt;br/&gt;异步刷盘，异步复制情况下，两台4核8G，大小100Byte,写入速度能够达到几万。&lt;/p&gt;
&lt;p&gt;通常broker端不存在瓶颈。但是由于一般业务是是共用一个集群的，各个业务线都使用起来，流量还是很高的，需要监控报警，及时进行水平扩容。&lt;br/&gt;如果能够接受延迟，producer可以批量提交，发送效率更高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消费端&lt;/strong&gt;&lt;br/&gt;取决于消费逻辑是否耗时，默认单机处理线程&lt;code&gt;consumeThreadMax&lt;/code&gt; (默认20）如果消费端服务时独立的，可以调整调整更大，提高单机处理速度。&lt;/p&gt;
&lt;p&gt;无法提高单机处理速度的时候，可以集群水平扩展。不过不是无限水平扩展的，超过&lt;code&gt;defaultTopicQueueNums&lt;/code&gt; 订阅队列数无效，该值默认值为4&lt;/p&gt;

&lt;p&gt;为什么需要消息队列，这个问题都被讲烂了，经典三大场景还是削峰填谷、异步处理、服务解耦。&lt;br/&gt;个人觉得这边总结的比较全面。&lt;a href=&quot;https://github.com/openmessaging/specification/blob/master/usecase.md&quot;&gt;https://github.com/openmessaging/specification/blob/master/usecase.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重点介绍下&lt;code&gt;rpc&lt;/code&gt;场景，注意这个rpc不是rpc调用。是同步消息，相当于两次rpc。client发到server。server处理完再发到client。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200528230406852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZTMTM2MDQ3MjE3NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这个通常用于服务间的同步处理。比如有个核心服务A，某个请求里面需要有个高耗时的操作，为了不影响A服务，用了一个B服务来处理这个操作。这时候就会用到&lt;code&gt;rpc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://tech.meituan.com/2016/07/01/mq-design.html&quot;&gt;https://tech.meituan.com/2016/07/01/mq-design.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tinylcy.me/2019/the-design-of-rocketmq-message-storage-system/&quot;&gt;http://tinylcy.me/2019/the-design-of-rocketmq-message-storage-system/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 May 2020 00:00:00 +0000</pubDate>
<dc:creator>stoneFang</dc:creator>
<og:description>概念说明 通常一个消息队列需要掌握的知识点有Topic（主体）、Producer（生产者）、Consumer（消费者）、Queue（队列）、Delivery Semantics（消息传递范式） 蛋疼的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/stoneFang/p/12985326.html</dc:identifier>
</item>
<item>
<title>本地电脑搭建外网可访问服务原理与实战 - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/12985117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/12985117.html</guid>
<description>&lt;p&gt;互联网上的电脑相互通讯是通过IP地址的，那就是说理论上每台能上网的电脑都应该有一个世界上独一无二的IP,但限于IPV4的最大数量限定，这是不可能达到的事情，所以现在出现了IPV6，进一步扩展了IPV4的数量限制。&lt;/p&gt;
&lt;p&gt;为了解决IPV4的资源紧张问题，互联网多数由局域网组成，每个局域网都是一个独立的小王国，通过一个拥有公网IP的网关实现与外界英特网通信。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IPv4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地址长度：32位（4 个字节）&lt;/p&gt;
&lt;p&gt;地址数量：2^32&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IPv6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地址长度：128位（16 个字节）&lt;/p&gt;
&lt;p&gt;地址数量：2^128&lt;/p&gt;
&lt;p&gt;IPV4数量限制解决方案&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200529025523603-831998947.png&quot; alt=&quot;&quot; width=&quot;475&quot; height=&quot;321&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;让一台内网计算机拥有公网权限&lt;/h2&gt;
&lt;p&gt;内网穿透原理最基本底层里面都或多或少使用了动态域名解析、端口映射、p2p穿透等这些技术。动态域名解析是解决动态公网IP问题,同时结合了路由端口转发原理。端口映射应用是一个介质,起到中转作用,可以解决端口被屏蔽或无公网IP问题。p2p穿透是二端通信,点到点的通信,二点访问端都是需要使用经过数据处理通信的客户端,适用于任何环境。&lt;/p&gt;
&lt;p&gt;内网对应的是外网，只要是涉及内外网间的连通都可以理解为内网穿透。内网穿透可以实现二点直连方式数据交互，穿透是不限速的，速度取决于两端点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;端口映射&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;端口映射是NAT的一种，功能是把在公网的地址转翻译成私有地址， 采用路由方式的ADSL宽带路由器拥有一个动态或固定的公网IP，ADSL直接接在HUB或交换机上，所有的电脑共享上网。（百度百科）&lt;/p&gt;
&lt;p&gt;端口映射即在路由器注册端口转发服务，在路由器添加一个数据判断，如果外界访问自己的某个端口数据，就将这些数据转发到局域网的某个IP上。实现端口对应局域网的特定服务--局域网计算机IP和端口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器数据转发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不少所谓的穿透其实是数据全转发,两端都连接了一个服务器，AB主机的数据都是通过外网的服务器进行中间转发，这样就有效的避开了端口映射时所触及不到的路由器了。但缺点就是数据转发速度高度依赖于服务器。&lt;/p&gt;
&lt;p&gt;实现数据转发时，我们需要在服务端也就是被动访问端下载一个内网穿透工具，让其与服务器保持连接，以便随时获取主动访问的数据。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;访问实例&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;内网设备访问外网：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内网客户端主动发起请求后，路由器会记录其请求的目标外网服务所对应的服务器信息（IP和端口）并与内网客户端的局域网IP和端口做绑定，注册成NAT表。进而实现两个端点的点对点通讯。&lt;/p&gt;
&lt;p&gt;其详细过程例如：&lt;/p&gt;
&lt;p&gt;外网服务: 116.33.13.10:8000&lt;/p&gt;
&lt;p&gt;路由器公网IP：113.67.11.104&lt;/p&gt;
&lt;p&gt;路由器内网IP：192.168.0.1&lt;/p&gt;
&lt;p&gt;内网客户端IP：192.168.0.100&lt;/p&gt;
&lt;p&gt;内网客户端（192.168.0.100）随机生成了一个端口55667,并发送连接外网服务请求（116.33.13.10:8000），路由器局域网（192.168.0.1）接受到连接请求便通过公网IP（113.67.11.104）随机生成了一个端口号22334去于外网服务进行连接，在此时路由器会建立一条NAT数据，表示外网服务的IP和端口与局域网客户端的IP和端口连接关系。这样他们就能互相交互数据了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200529025745292-291740585.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;331&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外网设备访问内网：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果按照上面的流程，其重要一环就是路由器的NAT数据关联关系，但是内网服务作为被动者时，路由器是不存在此端口关联数据的。所以外网的主动访问数据会被路由器识别为无效数据而丢失。&lt;/p&gt;
&lt;p&gt;当然我们可以在路由器做端口映射，但是很重要的前提是你所能做端口映射的路由器是有公网IP的，但生活上基本是不可能的，公网IP基本都会被运营商所直接管辖，而我们的路由器连接的是运营商的路由器，是一个局域网IP,但是我们又没有权限去操作运营商的路由器，从而路由端口映射的路基本被赌完了。&lt;/p&gt;
&lt;p&gt;看花生壳是如何实现的，依照官网的收费手段，基本都是流量和带宽，视乎在说明其实现的关键技术是&lt;strong&gt;服务器数据转发&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;下载/安装内网穿透工具&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://hsk.oray.com/price/?utm_source=baidu&amp;amp;utm_medium=cpc&amp;amp;utm_campaign=hsk_buy&amp;amp;utm_term=%E8%8A%B1%E7%94%9F%E5%A3%B3&amp;amp;i=45629&amp;amp;bd_vid=7363549083530946143#personal&quot;&gt;https://hsk.oray.com/price/?utm_source=baidu&amp;amp;utm_medium=cpc&amp;amp;utm_campaign=hsk_buy&amp;amp;utm_term=%E8%8A%B1%E7%94%9F%E5%A3%B3&amp;amp;i=45629&amp;amp;bd_vid=7363549083530946143#personal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200529025921737-780568700.png&quot; alt=&quot;&quot; width=&quot;606&quot; height=&quot;264&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200529025928052-1862227309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200529025952398-317770313.png&quot; alt=&quot;&quot; width=&quot;613&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 微信扫描二维码，弹出关注公众号，点击关注即可&lt;/p&gt;
&lt;p&gt;关注完成后再次扫码，进入登录注册页，完成登录即可点击授权&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200529030014923-56414213.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;激活和开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200529030043034-395452879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200529030048830-925718679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200529030055666-220265031.png&quot; alt=&quot;&quot; width=&quot;644&quot; height=&quot;394&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200529030120971-293805636.png&quot; alt=&quot;&quot; width=&quot;641&quot; height=&quot;393&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tcp://12345.qicp.vip:7799&lt;/p&gt;
&lt;p&gt;这是一个tcp的URL，分解之后可见：&lt;/p&gt;
&lt;p&gt;【tcp://】协议为tcp&lt;/p&gt;
&lt;p&gt;【12345.qicp.vip】域名，域名是IP地址的索引，通过域名解析可以将其解释到IP地址&lt;/p&gt;
&lt;p&gt;【7799】端口号&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202005/1485202-20200529030139766-1335854703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/39825e2d71da?utm_campaign=maleskine&amp;amp;utm_content=note&amp;amp;utm_medium=seo_notes&amp;amp;utm_source=recommendation&quot;&gt;https://www.jianshu.com/p/39825e2d71da?utm_campaign=maleskine&amp;amp;utm_content=note&amp;amp;utm_medium=seo_notes&amp;amp;utm_source=recommendation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/cdc446e51675&quot;&gt;https://www.jianshu.com/p/cdc446e51675&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 May 2020 19:05:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>互联网上的电脑相互通讯是通过IP地址的，那就是说理论上每台能上网的电脑都应该有一个世界上独一无二的IP,但限于IPV4的最大数量限定，这是不可能达到的事情，所以现在出现了IPV6，进一步扩展了IPV4</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dongxiaodong/p/12985117.html</dc:identifier>
</item>
<item>
<title>【Java8新特性】面试官：谈谈Java8中的Stream API有哪些终止操作？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/12984967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/12984967.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;6.041958041958&quot;&gt;
&lt;p&gt;如果你出去面试，面试官问了你关于Java8 Stream API的一些问题，比如：Java8中创建Stream流有哪几种方式？（可以参见：《&lt;a href=&quot;https://www.cnblogs.com/binghe001/p/12961977.html&quot;&gt;【Java8新特性】面试官问我：Java8中创建Stream流有哪几种方式？&lt;/a&gt;》）Java8中的Stream API有哪些中间操作？（可以参见：《&lt;a href=&quot;https://www.cnblogs.com/binghe001/p/12969825.html&quot;&gt;【Java8新特性】Stream API有哪些中间操作？看完你也可以吊打面试官！！&lt;/a&gt;》）如果你都很好的回答了这些问题，那么，面试官可能又会问你：Java8中的Stream API有哪些终止操作呢？没错，这就是Java8中有关Stream API的灵魂三问！不要觉得是面试官在为难你，只有你掌握了这些细节，你就可以反过来吊打面试官了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;stream的终止操作&quot;&gt;Stream的终止操作&lt;/h2&gt;
&lt;p&gt;终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如： List、 Integer、Double、String等等，甚至是 void 。&lt;/p&gt;
&lt;p&gt;在Java8中，Stream的终止操作可以分为：查找与匹配、规约和收集。接下来，我们就分别简单说明下这些终止操作。&lt;/p&gt;
&lt;h2 id=&quot;查找与匹配&quot;&gt;查找与匹配&lt;/h2&gt;
&lt;p&gt;Stream API中有关查找与匹配的方法如下表所示。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;allMatch(Predicate p)&lt;/td&gt;
&lt;td&gt;检查是否匹配所有元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;anyMatch(Predicate p)&lt;/td&gt;
&lt;td&gt;检查是否至少匹配一个元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;noneMatch(Predicate p)&lt;/td&gt;
&lt;td&gt;检查是否没有匹配所有元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;findFirst()&lt;/td&gt;
&lt;td&gt;返回第一个元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;findAny()&lt;/td&gt;
&lt;td&gt;返回当前流中的任意元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;count()&lt;/td&gt;
&lt;td&gt;返回流中元素总数&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;max(Comparator c)&lt;/td&gt;
&lt;td&gt;返回流中最大值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;min(Comparator c)&lt;/td&gt;
&lt;td&gt;返回流中最小值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;forEach(Consumer c)&lt;/td&gt;
&lt;td&gt;内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反， Stream API 使用内部迭代)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;同样的，我们对每个重要的方法进行简单的示例说明，这里，我们首先建立一个Employee类，Employee类的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
@Builder
@ToString
@NoArgsConstructor
@AllArgsConstructor
public class Employee implements Serializable {
    private static final long serialVersionUID = -9079722457749166858L;
    private String name;
    private Integer age;
    private Double salary;
    private Stauts stauts;
    public enum Stauts{
        WORKING,
        SLEEPING,
        VOCATION
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们在测试类中定义一个用于测试的集合employees，如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected List&amp;lt;Employee&amp;gt; employees = Arrays.asList(
    new Employee(&quot;张三&quot;, 18, 9999.99, Employee.Stauts.SLEEPING),
    new Employee(&quot;李四&quot;, 38, 5555.55, Employee.Stauts.WORKING),
    new Employee(&quot;王五&quot;, 60, 6666.66, Employee.Stauts.WORKING),
    new Employee(&quot;赵六&quot;, 8, 7777.77, Employee.Stauts.SLEEPING),
    new Employee(&quot;田七&quot;, 58, 3333.33, Employee.Stauts.VOCATION)
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，准备工作就绪了。接下来，我们就开始测试Stream的每个终止方法。&lt;/p&gt;
&lt;h3 id=&quot;1allmatch&quot;&gt;1.allMatch()&lt;/h3&gt;
&lt;p&gt;allMatch()方法表示检查是否匹配所有元素。其在Stream接口中的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean allMatch(Predicate&amp;lt;? super T&amp;gt; predicate);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过类似如下示例来使用allMatch()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean match = employees.stream().allMatch((e) -&amp;gt; Employee.Stauts.SLEEPING.equals(e.getStauts()));
System.out.println(match);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：使用allMatch()方法时，只有所有的元素都匹配条件时，allMatch()方法才会返回true。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;2anymatch方法&quot;&gt;2.anyMatch()方法&lt;/h3&gt;
&lt;p&gt;anyMatch方法表示检查是否至少匹配一个元素。其在Stream接口中的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean anyMatch(Predicate&amp;lt;? super T&amp;gt; predicate);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过类似如下示例来使用anyMatch()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean match = employees.stream().anyMatch((e) -&amp;gt; Employee.Stauts.SLEEPING.equals(e.getStauts()));
System.out.println(match);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：使用anyMatch()方法时，只要有任意一个元素符合条件，anyMatch()方法就会返回true。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;3nonematch方法&quot;&gt;3.noneMatch()方法&lt;/h3&gt;
&lt;p&gt;noneMatch()方法表示检查是否没有匹配所有元素。其在Stream接口中的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean noneMatch(Predicate&amp;lt;? super T&amp;gt; predicate);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过类似如下示例来使用noneMatch()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean match = employees.stream().noneMatch((e) -&amp;gt; Employee.Stauts.SLEEPING.equals(e.getStauts()));
System.out.println(match);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：使用noneMatch()方法时，只有所有的元素都不符合条件时，noneMatch()方法才会返回true。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;4findfirst方法&quot;&gt;4.findFirst()方法&lt;/h3&gt;
&lt;p&gt;findFirst()方法表示返回第一个元素。其在Stream接口中的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;T&amp;gt; findFirst();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过类似如下示例来使用findFirst()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Employee&amp;gt; op = employees.stream().sorted((e1, e2) -&amp;gt; Double.compare(e1.getSalary(), e2.getSalary())).findFirst();
System.out.println(op.get());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5findany方法&quot;&gt;5.findAny()方法&lt;/h3&gt;
&lt;p&gt;findAny()方法表示返回当前流中的任意元素。其在Stream接口中的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;T&amp;gt; findAny();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过类似如下示例来使用findAny()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Employee&amp;gt; op = employees.stream().filter((e) -&amp;gt; Employee.Stauts.WORKING.equals(e.getStauts())).findFirst();
System.out.println(op.get());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;6count方法&quot;&gt;6.count()方法&lt;/h3&gt;
&lt;p&gt;count()方法表示返回流中元素总数。其在Stream接口中的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;long count();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过类似如下示例来使用count()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;long count = employees.stream().count();
System.out.println(count);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;7max方法&quot;&gt;7.max()方法&lt;/h3&gt;
&lt;p&gt;max()方法表示返回流中最大值。其在Stream接口中的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;T&amp;gt; max(Comparator&amp;lt;? super T&amp;gt; comparator);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过类似如下示例来使用max()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Employee&amp;gt; op = employees.stream().max((e1, e2) -&amp;gt; Double.compare(e1.getSalary(), e2.getSalary()));
System.out.println(op.get());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;8min方法&quot;&gt;8.min()方法&lt;/h3&gt;
&lt;p&gt;min()方法表示返回流中最小值。其在Stream接口中的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;T&amp;gt; min(Comparator&amp;lt;? super T&amp;gt; comparator);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过类似如下示例来使用min()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Double&amp;gt; op = employees.stream().map(Employee::getSalary).min(Double::compare);
System.out.println(op.get());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;9foreach方法&quot;&gt;9.forEach()方法&lt;/h3&gt;
&lt;p&gt;forEach()方法表示内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代。相反， Stream API 使用内部迭代)。其在Stream接口内部的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;void forEach(Consumer&amp;lt;? super T&amp;gt; action);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过类似如下示例来使用forEach()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;employees.stream().forEach(System.out::println);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;规约&quot;&gt;规约&lt;/h2&gt;
&lt;p&gt;Stream API中有关规约的方法如下表所示。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;reduce(T iden, BinaryOperator b)&lt;/td&gt;
&lt;td&gt;可以将流中元素反复结合起来，得到一个值。 返回 T&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;reduce(BinaryOperator b)&lt;/td&gt;
&lt;td&gt;可以将流中元素反复结合起来，得到一个值。 返回 Optional&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;reduce()方法在Stream接口中的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;T reduce(T identity, BinaryOperator&amp;lt;T&amp;gt; accumulator);
Optional&amp;lt;T&amp;gt; reduce(BinaryOperator&amp;lt;T&amp;gt; accumulator);
&amp;lt;U&amp;gt; U reduce(U identity, BiFunction&amp;lt;U, ? super T, U&amp;gt; accumulator, BinaryOperator&amp;lt;U&amp;gt; combiner);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过类似如下示例来使用reduce方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Integer&amp;gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10);
Integer sum = list.stream().reduce(0, (x, y) -&amp;gt; x + y);
System.out.println(sum);
System.out.println(&quot;----------------------------------------&quot;);
Optional&amp;lt;Double&amp;gt; op = employees.stream().map(Employee::getSalary).reduce(Double::sum);
System.out.println(op.get());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们也可以搜索employees列表中“张”出现的次数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; Optional&amp;lt;Integer&amp;gt; sum = employees.stream()
   .map(Employee::getName)
   .flatMap(TestStreamAPI1::filterCharacter)
   .map((ch) -&amp;gt; {
    if(ch.equals('六'))
     return 1;
    else
     return 0;
   }).reduce(Integer::sum);
  System.out.println(sum.get());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：上述例子使用了硬编码的方式来累加某个具体值，大家在实际工作中再优化代码。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;收集&quot;&gt;收集&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;collect(Collector c)&lt;/td&gt;
&lt;td&gt;将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;collect()方法在Stream接口中的定义如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;R&amp;gt; R collect(Supplier&amp;lt;R&amp;gt; supplier,
              BiConsumer&amp;lt;R, ? super T&amp;gt; accumulator,
              BiConsumer&amp;lt;R, R&amp;gt; combiner);

&amp;lt;R, A&amp;gt; R collect(Collector&amp;lt;? super T, A, R&amp;gt; collector);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过类似如下示例来使用collect方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Optional&amp;lt;Double&amp;gt; max = employees.stream()
   .map(Employee::getSalary)
   .collect(Collectors.maxBy(Double::compare));
  System.out.println(max.get());
  Optional&amp;lt;Employee&amp;gt; op = employees.stream()
   .collect(Collectors.minBy((e1, e2) -&amp;gt; Double.compare(e1.getSalary(), e2.getSalary())));
  System.out.println(op.get());
  Double sum = employees.stream().collect(Collectors.summingDouble(Employee::getSalary));
  System.out.println(sum);
  Double avg = employees.stream().collect(Collectors.averagingDouble(Employee::getSalary));
  System.out.println(avg);
  Long count = employees.stream().collect(Collectors.counting());
  System.out.println(count);
  System.out.println(&quot;--------------------------------------------&quot;);
  DoubleSummaryStatistics dss = employees.stream()
   .collect(Collectors.summarizingDouble(Employee::getSalary));
  System.out.println(dss.getMax());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何收集stream流？&quot;&gt;如何收集Stream流？&lt;/h2&gt;
&lt;p&gt;Collector接口中方法的实现决定了如何对流执行收集操作(如收集到 List、 Set、 Map)。 Collectors实用类提供了很多静态方法，可以方便地创建常见收集器实例， 具体方法与实例如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;返回类型&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;toList&lt;/td&gt;
&lt;td&gt;List&lt;/td&gt;
&lt;td&gt;把流中元素收集到List&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;toSet&lt;/td&gt;
&lt;td&gt;Set&lt;/td&gt;
&lt;td&gt;把流中元素收集到Set&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;toCollection&lt;/td&gt;
&lt;td&gt;Collection&lt;/td&gt;
&lt;td&gt;把流中元素收集到创建的集合&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;counting&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;td&gt;计算流中元素的个数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;summingInt&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;对流中元素的整数属性求和&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;averagingInt&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;td&gt;计算流中元素Integer属性的平均 值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;summarizingInt&lt;/td&gt;
&lt;td&gt;IntSummaryStatistics&lt;/td&gt;
&lt;td&gt;收集流中Integer属性的统计值。 如：平均值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;joining&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;连接流中每个字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;maxBy&lt;/td&gt;
&lt;td&gt;Optional&lt;/td&gt;
&lt;td&gt;根据比较器选择最大值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;minBy&lt;/td&gt;
&lt;td&gt;Optional&lt;/td&gt;
&lt;td&gt;根据比较器选择最小值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;reducing&lt;/td&gt;
&lt;td&gt;归约产生的类型&lt;/td&gt;
&lt;td&gt;从一个作为累加器的初始值 开始，利用BinaryOperator与 流中元素逐个结合，从而归 约成单个值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;collectingAndThen&lt;/td&gt;
&lt;td&gt;转换函数返回的类型&lt;/td&gt;
&lt;td&gt;包裹另一个收集器，对其结 果转换函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;groupingBy&lt;/td&gt;
&lt;td&gt;Map&amp;lt;K, List&amp;gt;&lt;/td&gt;
&lt;td&gt;根据某属性值对流分组，属 性为K，结果为V&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;partitioningBy&lt;/td&gt;
&lt;td&gt;Map&amp;lt;Boolean, List&amp;gt;&lt;/td&gt;
&lt;td&gt;根据true或false进行分区&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;每个方法对应的使用示例如下表所示。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;使用示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;16.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;toList&lt;/td&gt;
&lt;td&gt;List employees= list.stream().collect(Collectors.toList());&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;toSet&lt;/td&gt;
&lt;td&gt;Set employees= list.stream().collect(Collectors.toSet());&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;toCollection&lt;/td&gt;
&lt;td&gt;Collection employees=list.stream().collect(Collectors.toCollection(ArrayList::new));&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;counting&lt;/td&gt;
&lt;td&gt;long count = list.stream().collect(Collectors.counting());&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;summingInt&lt;/td&gt;
&lt;td&gt;int total=list.stream().collect(Collectors.summingInt(Employee::getSalary));&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;averagingInt&lt;/td&gt;
&lt;td&gt;double avg= list.stream().collect(Collectors.averagingInt(Employee::getSalary))&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;summarizingInt&lt;/td&gt;
&lt;td&gt;IntSummaryStatistics iss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Collectors&lt;/td&gt;
&lt;td&gt;String str= list.stream().map(Employee::getName).collect(Collectors.joining());&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;maxBy&lt;/td&gt;
&lt;td&gt;Optionalmax= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)))；&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;minBy&lt;/td&gt;
&lt;td&gt;Optional min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;reducing&lt;/td&gt;
&lt;td&gt;int total=list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;collectingAndThen&lt;/td&gt;
&lt;td&gt;int how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;groupingBy&lt;/td&gt;
&lt;td&gt;Map&amp;lt;Emp.Status, List&amp;gt; map= list.stream() .collect(Collectors.groupingBy(Employee::getStatus));&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;partitioningBy&lt;/td&gt;
&lt;td&gt;Map&amp;lt;Boolean,List&amp;gt;vd= list.stream().collect(Collectors.partitioningBy(Employee::getManage));&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void test4(){
    Optional&amp;lt;Double&amp;gt; max = emps.stream()
        .map(Employee::getSalary)
        .collect(Collectors.maxBy(Double::compare));
    System.out.println(max.get());

    Optional&amp;lt;Employee&amp;gt; op = emps.stream()
        .collect(Collectors.minBy((e1, e2) -&amp;gt; Double.compare(e1.getSalary(), e2.getSalary())));

    System.out.println(op.get());

    Double sum = emps.stream()
        .collect(Collectors.summingDouble(Employee::getSalary));

    System.out.println(sum);

    Double avg = emps.stream()
        .collect(Collecors.averagingDouble(Employee::getSalary));
    System.out.println(avg);
    Long count = emps.stream()
        .collect(Collectors.counting());

    DoubleSummaryStatistics dss = emps.stream()
        .collect(Collectors.summarizingDouble(Employee::getSalary));
    System.out.println(dss.getMax());
 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习Java8新特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，附上Java8新特性核心知识图，祝大家在学习Java8新特性时少走弯路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200520003727787.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 May 2020 16:24:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 如果你出去面试，面试官问了你关于Java8 Stream API的一些问题，比如：Java8中创建Stream流有哪几种方式？（可以参见：《【Java8新特性】面试官问我：Java8中创建S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/12984967.html</dc:identifier>
</item>
<item>
<title>springboot系列——重试机制原理和应用，还有比这个讲的更好的吗(附完整源码) - jack_wang_king</title>
<link>http://www.cnblogs.com/HelloWorld2016425/p/12984737.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HelloWorld2016425/p/12984737.html</guid>
<description>&lt;p&gt;如果有，请转给我！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 理解重试机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;“重试是为了提高成功的可能性“&lt;/p&gt;
&lt;p&gt;反过来理解，任何可能失败且允许重试操作的场景，就适合使用重试机制。但有了重试机制就一定能成功吗？显然不是。如果不成功就一直重试，这种处理方式会使得业务线程一直被重试占用，这样会导致服务的负载线程暴增直至服务宕机，因此需要限制重试次数。失败情况下，我们需要做后续的操作，如果是数据库操作的重试，需要回滚事物；如果是服务调用的重试，需要邮件报警通知运维开发人员，恢复服务。&lt;/p&gt;
&lt;p&gt;对于服务接口调用，可能是因为网络波动导致超时失败，这时候所有重试次数是在很短时间内发起的话，就很容易全部超时失败，因此超时机制还需要引入重试动作之间时间间隔以及第一次失败后延迟多长时间再开始重试等机制。&lt;/p&gt;
&lt;p&gt;重试机制要素&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;限制重试次数&lt;/li&gt;
&lt;li&gt;每次重试的时间间隔&lt;/li&gt;
&lt;li&gt;最终失败结果的报警或事物回滚&lt;/li&gt;
&lt;li&gt;在特定失败异常事件情况下选择重试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 总结重试机制使用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;任何可能失败且允许重试操作的场景，就适合使用重试机制。那么在分布式系统开发环境中，哪些场景需要是使用重试机制呢。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;乐观锁机制保证数据安全的数据更新场景，如账户信息的金额数据更新。&lt;/li&gt;
&lt;li&gt;微服务的分布式架构下，服务的调用因超时而失败。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. spring-retry重试组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;spring-retry核心:配置重试元数据，失败恢复或报警通知。&lt;/p&gt;
&lt;p&gt;pom文件依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.retry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-retry&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置重试元数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
@Retryable(value &lt;/span&gt;= Exception.&lt;span&gt;class&lt;/span&gt;,maxAttempts = 3  , backoff = @Backoff(delay = 2000,multiplier = 1.5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; retryServiceOne(&lt;span&gt;int&lt;/span&gt; code) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub &lt;/span&gt;
    System.out.println(&quot;retryServiceOne被调用,时间：&quot;+&lt;span&gt;LocalTime.now());
    System.out.println(&lt;/span&gt;&quot;执行当前业务逻辑的线程名：&quot;+&lt;span&gt;Thread.currentThread().getName());
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (code==0&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;业务执行失败情况！&quot;&lt;span&gt;);
    }
    System.out.println(&lt;/span&gt;&quot;retryServiceOne执行成功！&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 200&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置元数据情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重试次数为3&lt;/li&gt;
&lt;li&gt;第一次重试延迟2s&lt;/li&gt;
&lt;li&gt;每次重试时间间隔是前一次1.5倍&lt;/li&gt;
&lt;li&gt;Exception类异常情况下重试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试:&lt;/p&gt;
&lt;p&gt;启动应用，浏览器输入：http://localhost:8080/springRetry。&lt;/p&gt;
&lt;p&gt;后台结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
执行业务发起逻辑的线程名：http-nio-8080-exec-6&lt;span&gt;
retryServiceOne被调用,时间：&lt;/span&gt;17:55:48.235&lt;span&gt;
执行当前业务逻辑的线程名：http&lt;/span&gt;-nio-8080-exec-6&lt;span&gt;
retryServiceOne被调用,时间：&lt;/span&gt;17:55:50.235&lt;span&gt;
执行当前业务逻辑的线程名：http&lt;/span&gt;-nio-8080-exec-6&lt;span&gt;
retryServiceOne被调用,时间：&lt;/span&gt;17:55:53.236&lt;span&gt;
执行当前业务逻辑的线程名：http&lt;/span&gt;-nio-8080-exec-6&lt;span&gt;
回调方法执行！！！！&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 手写一个基于注解的重试组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注解类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 重试注解
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Documented
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; JdkRetry{
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认&lt;/span&gt;
     &lt;span&gt;int&lt;/span&gt; maxAttempts() &lt;span&gt;default&lt;/span&gt; 3&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认每次间隔等待3000毫秒&lt;/span&gt;
     &lt;span&gt;long&lt;/span&gt; waitTime() &lt;span&gt;default&lt;/span&gt; 3000&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕捉到的异常类型  再进行重发&lt;/span&gt;
     Class&amp;lt;?&amp;gt; exception () &lt;span&gt;default&lt;/span&gt; Exception.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ;
    
     String recoverServiceName () &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;DefaultRecoverImpl&quot;&lt;span&gt;;
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注解类包含的元数据有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尝试次数&lt;/li&gt;
&lt;li&gt;重试间隔时间&lt;/li&gt;
&lt;li&gt;抛出哪种异常会重试&lt;/li&gt;
&lt;li&gt;重试完后还是失败的恢复类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用spring AOP技术，实现重试注解的切面逻辑类RetryAspect。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 @Transactional(rollbackFor = Exception.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
      @Around(&lt;/span&gt;&quot;@annotation(jdkRetry)&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开发自定义注解的时候，定要注意  @annotation(jdkRetry)和下面方法的参数，按规定是固定的形式的，否则报错&lt;/span&gt;
      &lt;span&gt;public&lt;/span&gt; Object doConcurrentOperation(ProceedingJoinPoint pjp , JdkRetry jdkRetry) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取注解的属性
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        pjp.getClass().getMethod(, parameterTypes)&lt;/span&gt;
        System.out.println(&quot;切面作用：&quot;+jdkRetry.maxAttempts()+ &quot;  恢复策略类：&quot;+&lt;span&gt; jdkRetry.recoverServiceName());
        
        Object service &lt;/span&gt;=&lt;span&gt; JdkApplicationContext.jdkApplicationContext.getBean(jdkRetry.recoverServiceName());
        Recover recover &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(service == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;recover处理服务实例不存在&quot;&lt;span&gt;);
        recover &lt;/span&gt;=&lt;span&gt; (Recover)service;
        
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; waitTime =&lt;span&gt;  jdkRetry.waitTime();
        maxRetries &lt;/span&gt;=&lt;span&gt; jdkRetry.maxAttempts();
        Class&lt;/span&gt;&amp;lt;?&amp;gt; exceptionClass =&lt;span&gt; jdkRetry.exception();
        
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; numAttempts = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            numAttempts&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次执行业务代码&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pjp.proceed();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须只是乐观锁更新才能进行重试逻辑&lt;/span&gt;
&lt;span&gt;                System.out.println(ex.getClass().getName());
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;ex.getClass().getName().equals(exceptionClass.getName()))
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (numAttempts &amp;gt;&lt;span&gt; maxRetries) {
                    
                    recover.recover(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;log failure information, and throw exception
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    如果大于 默认的重试机制 次数，我们这回就真正的抛出去了
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    throw new Exception(&quot;重试逻辑执行完成，业务还是失败!&quot;);&lt;/span&gt;
                }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果 没达到最大的重试次数，将再次执行&lt;/span&gt;
                    System.out.println(&quot;=====正在重试=====&quot;+numAttempts+&quot;次&quot;&lt;span&gt;);
                    TimeUnit.MILLISECONDS.sleep(waitTime);
                }
            }
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (numAttempts &amp;lt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.maxRetries);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 500&lt;span&gt;;
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;切面类获取到重试注解元信息后，切面逻辑会做以下相应的处理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;捕捉异常，对比该异常是否应该重试&lt;/li&gt;
&lt;li&gt;统计重试次数，判断是否超限&lt;/li&gt;
&lt;li&gt;重试多次后失败，执行失败恢复逻辑或报警通知&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试：&lt;/p&gt;
&lt;p&gt;启动应用，浏览器输入：http://localhost:8080/testAnnotationRetry&lt;/p&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
切面作用：3&lt;span&gt;  恢复策略类：DefaultRecoverImpl
AnnotationServiceImpl被调用,时间：&lt;/span&gt;18:11:25.748&lt;span&gt;
org.jackdking.retry.jdkdkingannotation.retryException.UpdateRetryException
&lt;/span&gt;=====正在重试=====&lt;span&gt;1次
AnnotationServiceImpl被调用,时间：&lt;/span&gt;18:11:28.748&lt;span&gt;
org.jackdking.retry.jdkdkingannotation.retryException.UpdateRetryException
&lt;/span&gt;=====正在重试=====&lt;span&gt;2次
AnnotationServiceImpl被调用,时间：&lt;/span&gt;18:11:31.749&lt;span&gt;
org.jackdking.retry.jdkdkingannotation.retryException.UpdateRetryException
&lt;/span&gt;=====正在重试=====&lt;span&gt;3次
AnnotationServiceImpl被调用,时间：&lt;/span&gt;18:11:34.749&lt;span&gt;
org.jackdking.retry.jdkdkingannotation.retryException.UpdateRetryException
&lt;/span&gt;2020-05-26 18:11:34.749 ERROR 14892 --- [io-8080-exec-10] o.j.r.j.recover.impl.DefaultRecoverImpl  : 重试失败，未进行任何补全，此为默认补全：打出错误日志
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 重试机制下会出现的问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;幂等性问题：&lt;/p&gt;
&lt;p&gt;在分布式架构下，服务之间调用会因为网络原因出现超时失败情况，而重试机制会重复多次调用服务，但是对于被调用放，就可能收到了多次调用。如果被调用方不具有天生的幂等性，那就需要增加服务调用的判重模块，并对每次调用都添加一个唯一的id。&lt;/p&gt;
&lt;p&gt;大量请求超时堆积：&lt;/p&gt;
&lt;p&gt;超高并发下，大量的请求如果都进行超时重试的话，如果你的重试时间设置不安全的话，会导致大量的请求占用服务器线程进行重试，这时候服务器线程负载就会暴增，导致服务器宕机。对于这种超高并发下的重试设计，我们不能让重试放在业务线程，而是统一由异步任务来执行。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6. 模板方法设计模式实现异步重试机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;模板方法设计模式来实现异步重试机制&lt;/p&gt;
&lt;p&gt;所有业务类继承重试模板类RetryTemplate&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@Service(&quot;serviceone&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RetryTemplateImpl &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RetryTemplate{
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RetryTemplateImpl() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.setRecover(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RecoverImpl());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Object doBiz() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; code = 0&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;RetryTemplateImpl被调用,时间：&quot;+&lt;span&gt;LocalTime.now());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (code==0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;业务执行失败情况！&quot;&lt;span&gt;);
        }
        System.out.println(&lt;/span&gt;&quot;RetryTemplateImpl执行成功！&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 200&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; RecoverImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Recover{

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String recover() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
            System.out.println(&quot;重试失败   恢复逻辑，记录日志等操作&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;业务实现类在doBiz方法内实现业务过程&lt;/li&gt;
&lt;li&gt;所有业务实现一个恢复类,实现Recover接口，重试多次失败后执行恢复逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试:&lt;/p&gt;
&lt;p&gt;启动应用，浏览器输入：http://localhost:8080/testRetryTemplate&lt;/p&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
2020-05-26 22:53:41.935  INFO 25208 --- [nio-8080-exec-4&lt;span&gt;] o.j.r.r.c.RetryTemplateController        : 开始执行业务
RetryTemplateImpl被调用,时间：&lt;/span&gt;22:53:41.936&lt;span&gt;
RetryTemplateImpl被调用,时间：&lt;/span&gt;22:53:41.938&lt;span&gt;
RetryTemplateImpl被调用,时间：&lt;/span&gt;22:53:44.939&lt;span&gt;
RetryTemplateImpl被调用,时间：&lt;/span&gt;22:53:47.939
2020-05-26 22:53:50.940  INFO 25208 --- [pool-1-thread-1&lt;span&gt;] o.j.r.r.service.RetryTemplate            : 业务逻辑失败，重试结束
重试失败   恢复逻辑，记录日志等操作&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;完整的demo项目&lt;/strong&gt;&lt;/span&gt;，请关注公众号“前沿科技bot“并发送&quot;重试机制&quot;获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/943700/202005/943700-20200528232215050-1442958525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 28 May 2020 15:23:00 +0000</pubDate>
<dc:creator>jack_wang_king</dc:creator>
<og:description>1. 理解重试机制 2. 总结重试机制使用场景 3. spring-retry重试组件 4. 手写一个基于注解的重试组件 5. 重试机制下会出现的问题 6. 模板方法设计模式实现异步重试机制 如果有，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/HelloWorld2016425/p/12984737.html</dc:identifier>
</item>
<item>
<title>跨域知多少？ - 长沙大鹏</title>
<link>http://www.cnblogs.com/hunanzp/p/12984701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hunanzp/p/12984701.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;已经很久没写博客了，最近的工作之余就是在看书和弥补前端知识体系。想了想自己年初暗下决心说要养成长期编写博客的习惯，想了下就围绕着今天的主体“跨域”来讲解吧！文中如有错误，还请指出，感激不尽！&lt;/p&gt;
&lt;h3 id=&quot;什么是跨域？&quot;&gt;什么是跨域？&lt;/h3&gt;
&lt;p&gt;跨域资源共享（英语：Cross-origin resource sharing，缩写：CORS），用于让网页的受限资源能够被其他域名的页面访问的一种机制。 --摘自维基百科&lt;br/&gt;跨域的基本三要素:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同域名&lt;/li&gt;
&lt;li&gt;同端口&lt;/li&gt;
&lt;li&gt;同协议&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通俗理解:&lt;br/&gt;我们从站点A对其他站点进行网络请求时，浏览器端和服务端需要对这个请求进行处理，保证这个请求是安全的。 这个处理就是&lt;strong&gt;跨域&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么需要跨域&quot;&gt;为什么需要跨域&lt;/h3&gt;
&lt;p&gt;跨域是为了保证请求的安全作出的策略。&lt;br/&gt;浏览器请求必须遵循同源策略: 同一域名、同一端口、同一协议&lt;/p&gt;
&lt;h3 id=&quot;跨域方案&quot;&gt;跨域方案&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;JSONP跨域&lt;/li&gt;
&lt;li&gt;CORS跨域&lt;/li&gt;
&lt;li&gt;代理跨域&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;jsonp跨域&quot;&gt;JSONP跨域&lt;/h4&gt;
&lt;p&gt;JSONP是一种依靠开发人员的聪明才智创造出的一种非官方跨域数据交互协议。&lt;br/&gt;理解JSONP跨域前，回忆下我们在前端是不是有下面的编码经历。&lt;/p&gt;
&lt;p&gt;引用script元素通过设置src获取到第三方的js脚本过？&lt;br/&gt;还有我们的img元素也可以通过给src属性赋予url的方式获取其他第三方服务器上的图片资源？&lt;/p&gt;
&lt;p&gt;上面获取数据的方式就是采用JSONP。&lt;br/&gt;通俗而言，JSONP就是通过调用一个服务端的get接口返回带有引用前端方法的字符串。&lt;br/&gt;画了一个草图，希望大家能通过它看懂客户端和服务端通过JSONP是如何交互的：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/349354/202005/349354-20200528231139977-1888398753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面案例执行结果如下:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/349354/202005/349354-20200528231204837-1770917461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JSONP跨域特点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;只支持Http请求的Get方式&lt;/li&gt;
&lt;li&gt;后端、前端都需要编码&lt;/li&gt;
&lt;li&gt;安全系数低&lt;/li&gt;
&lt;li&gt;代码难以维护&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;cors跨域&quot;&gt;CORS跨域&lt;/h4&gt;
&lt;p&gt;CORS跨域个人是最常用的(多亏.NET Core对跨域策略的支持非常好用)。&lt;br/&gt;CORS跨域是由服务端应用设置的一个跨域策略，比如开放指定的HTTP Method、指定请求方Url、指定请求携带的Headers必须包含的字段等等~。&lt;br/&gt;CORS这种方式简单高效，合理的使用它的策略可以保证服务器的安全的同时也提升了前后端的开发体验~；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CORS跨域特点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;后端配置，前端直接请求;&lt;/li&gt;
&lt;li&gt;策略丰富，可支持多种策略，如HTTP方法、URL等;&lt;/li&gt;
&lt;li&gt;前后端交互方式非常规范；&lt;/li&gt;
&lt;li&gt;除了常用的GET、POST、HEAD 其他方法进行请求则需要发起OPTIONS请求对服务器端进行跨域允许的许可请求。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;代理跨域&quot;&gt;代理跨域&lt;/h4&gt;
&lt;p&gt;代理跨域非常好理解，通俗的说就是客户端请求到A地址，A地址的服务直接将客户端请求重定向到B地址，最终由B地址对客户端的请求进行处理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接口代理跨域特点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;服务端、客户端均不需要配置&lt;/li&gt;
&lt;li&gt;通过中间服务器(代理服务器)的配置实现(如Nginx、IIS、Apache)&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;JSONP方式看似简单，实际可行性非常差，目前在Web开发前后端分离的大背景下此方案已经算是销声匿迹了。&lt;br/&gt;而CORS依靠着丰富的策略项，让开发者以最小的代价满足日渐复杂的跨域需求，基本上已是目前最常用的跨域手段了。&lt;br/&gt;同时，代理跨域方式也很常见，此方案通常在满足跨域需求的同时也一并解决了其他的诸多需求。&lt;br/&gt;比如现在超级火爆的微服务架构。通过在代理服务器配置一个统一网关，让所有客户端请求全部归集到此代理服务器上，&lt;br/&gt;再通过此代理服务器对各个请求进行服务分发执行。这种方式解决了后端的单应用服务的压力，也解决了前端配置多个请求地址的繁琐工作，&lt;br/&gt;还保障了服务器的安全，后续的横向拓展也极其方便。&lt;/p&gt;
</description>
<pubDate>Thu, 28 May 2020 15:18:00 +0000</pubDate>
<dc:creator>长沙大鹏</dc:creator>
<og:description>前言 已经很久没写博客了，最近的工作之余就是在看书和弥补前端知识体系。想了想自己年初暗下决心说要养成长期编写博客的习惯，想了下就围绕着今天的主体“跨域”来讲解吧！文中如有错误，还请指出，感激不尽！ 什</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hunanzp/p/12984701.html</dc:identifier>
</item>
</channel>
</rss>