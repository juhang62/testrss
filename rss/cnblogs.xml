<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>insufficient permission for adding an object to repository database .git/objects - gxkx</title>
<link>http://www.cnblogs.com/gxkB/p/10771880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gxkB/p/10771880.html</guid>
<description>

&lt;p&gt;1.出错截图：&lt;/p&gt;
&lt;p&gt;有时候使用软件项目管理系统github时候，会出现一些问题截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/987956/201904/987956-20190425225638544-1925023446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.出错原因&lt;/p&gt;
&lt;p&gt;从出错的地方就知道是因为权限不足导致，回想一下，在链接远程服务器时候，不小心切换为管理员权限进行了git pull更新的项目的代码。&lt;/p&gt;
&lt;p&gt;如今切换为普通用户，应该是在git的某个目录下由于创建者是管理员，而当前用户权限比管理员小，故无法进行更新。&lt;/p&gt;
&lt;p&gt;3.解决办法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/987956/201904/987956-20190425230038279-570715648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从项目根目录下找到.git 目录，该目录下有一个文件夹objects：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/987956/201904/987956-20190425230210131-1235293027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人理解这些文件应该是记录了项目每次提交的信息，至于是怎么记录，差异还是全部，则没研究。&lt;/p&gt;
&lt;p&gt;进入里面查看文件发现果然有几个目录是root创建的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/987956/201904/987956-20190425233610759-2147166527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;，所以在外面更改一下用户即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/987956/201904/987956-20190425233708365-1018061105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后重新更新一下代码则可以成功。&lt;/p&gt;

</description>
<pubDate>Thu, 25 Apr 2019 15:38:00 +0000</pubDate>
<dc:creator>gxkx</dc:creator>
<og:description>1.出错截图： 有时候使用软件项目管理系统github时候，会出现一些问题截图如下： 2.出错原因 从出错的地方就知道是因为权限不足导致，回想一下，在链接远程服务器时候，不小心切换为管理员权限进行了g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gxkB/p/10771880.html</dc:identifier>
</item>
<item>
<title>补习系列(20)-大话 WebSocket 与 &quot;尬聊&quot;的实现 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/10771814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/10771814.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190425230806658-1937401204.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一聊聊-websocket&quot;&gt;一、聊聊 WebSocket&lt;/h2&gt;
&lt;p&gt;从HTML5技术流行至今，WebSocket已经有非常广泛的应用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在线游戏，提供实时的操作交互体验&lt;/li&gt;
&lt;li&gt;社交平台，与好友实时的私信对话&lt;/li&gt;
&lt;li&gt;新闻动态，获得感兴趣的主题信息推送&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;这些场景，都需要&lt;strong&gt;服务器能主动实时的给浏览器或客户端推送消息&lt;/strong&gt;，注意关键词是主动，还有实时！&lt;br/&gt;而在HTML5一统江湖之前，由于HTTP在推送场景下的&quot;薄弱&quot;，我们需要借助一些复杂或者非标准的手段来实现。&lt;/p&gt;
&lt;p&gt;这些方式包括有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Ajax轮询，比如每隔5秒钟，由浏览器对服务器主动请求数据后返回。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190425230844147-1750113329.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这种方案下，浏览器需要不断的向服务器发出请求，问题是比较明显的，包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HTTP请求头部会浪费一些带宽；&lt;/li&gt;
&lt;li&gt;频繁重建连接会造成很大的开销。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Comet，这个词好像翻译为&quot;彗星&quot;？ 这个是采用 streaming 或 long-pulling 的长连接技术：&lt;br/&gt;服务器在收到请求时先挂起，等待有事件发生时才返回数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190425230920495-2015812231.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Comet 效率提升了不少，它解决了Ajax轮询的部分问题，利用HTTP长连接的特性尽可能的避免了连接、带宽资源的浪费等等，于是在很长一段时间 Comet 成为了Web推送技术的主流。&lt;br/&gt;But ，.. Comet 的实现技术比较复杂，不同框架下的实现方式差异很大，在灵活性、性能上也有些欠缺。&lt;br/&gt;关于服务端Comet的技术可以参考下面这篇经典文章：&lt;br/&gt;https://www.ibm.com/developerworks/cn/web/wa-lo-comet/&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Flash，通过Flash 插件代码实现Socket通讯，本质上是基于TCP的通讯模式，由于Flash 需要安装插件以及浏览器的兼容性问题，目前已经逐渐废弃。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;websocket-出场&quot;&gt;WebSocket 出场&lt;/h4&gt;
&lt;p&gt;WebSocket 出现的目的没有别的，就是干掉前面的东西，Both!&lt;br/&gt;最开始WebSocket 协议由 &lt;a href=&quot;https://tools.ietf.org/html/rfc6455&quot;&gt;RFC6455&lt;/a&gt; 定义，其API标准包含于HTML5 范畴之中。&lt;br/&gt;目前各大主流浏览器已经能完全支持该技术。然后可以看看下面这个图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190425231012367-1382141147.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，WebSocket 协议中， 浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。&lt;br/&gt;那么相比以往的方式，这种方案更加节省资源了，它的实时性、灵活性都要强大不少。&lt;br/&gt;当然，有HTML5标准给它站台，后台杠杠的~&lt;/p&gt;
&lt;p&gt;那么一个 WebSocket 的请求响应长成怎么样呢？&lt;br/&gt;看下面这个图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190425231049388-895990952.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二stomp-是个什么鬼&quot;&gt;二、Stomp 是个什么鬼&lt;/h2&gt;
&lt;p&gt;一开始我一直认为 Stomp是暴风雨(误看为 Storm)，然后觉得说这个技术挺犀利的。&lt;br/&gt;然后在看了 Stomp 的协议介绍后发现，它是如此的简单..&lt;br/&gt;Stomp 的 全称叫 &lt;strong&gt;&lt;em&gt;Simple Text Orientated Messaging Protocol&lt;/em&gt;&lt;/strong&gt;，就是一个简单的文本定向消息协议，&lt;br/&gt;除了设计为简单易用之外，它的支持者也非常多。就比如目前主流的消息队列服务器如RabbitMQ、ActiveMQ都支持Stomp 协议。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;br/&gt;http://stomp.github.io/&lt;/p&gt;
&lt;p&gt;Stomp 定义了一些简单的指令，如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;CONNECT&lt;/td&gt;
&lt;td&gt;建立连接&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SEND&lt;/td&gt;
&lt;td&gt;发送消息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;SUBSCRIBE&lt;/td&gt;
&lt;td&gt;订阅主题&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;UNSUBSCRIBE&lt;/td&gt;
&lt;td&gt;取消订阅&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;BEGIN&lt;/td&gt;
&lt;td&gt;开启事务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;COMMIT&lt;/td&gt;
&lt;td&gt;提交事务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ABORT&lt;/td&gt;
&lt;td&gt;回滚事务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ACK&lt;/td&gt;
&lt;td&gt;确认消费&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;NACK&lt;/td&gt;
&lt;td&gt;消息丢弃&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;DISCONNECT&lt;/td&gt;
&lt;td&gt;断开连接&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;一个简单的STOMP消息大致如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CONNECT
accept-version:1.1,1.0
heart-beat:10000,10000\n\n\u0000


SEND
destination:/app/message\ncontent-length:6

发送内容\u0000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好的，你现在应该了解 Stomp是个什么了，那么为什么要介绍这个？&lt;/p&gt;
&lt;p&gt;WebSocket 为我们提供了Web 双向通信的通道，但对于消息的交互协议还需要我们来自己实现(WebSocket 果然不够意思)&lt;br/&gt;借助Stomp 协议，可以很方便的实现一种&quot;订阅-发布&quot;的通用机制，这个就是非常具有竞争力的一个特性了。&lt;/p&gt;
&lt;h2 id=&quot;三springboot-整合-websocket&quot;&gt;三、SpringBoot 整合 WebSocket&lt;/h2&gt;
&lt;p&gt;在介绍完WebSocket 之后，接下来干什么呢？&lt;br/&gt;可能你看完前面的东西会觉得 WebSocket 是如此之强大，以至于很多场景都应该使用这个技术来实现。&lt;br/&gt;那么如何做？ 在此前我所介绍的 SpringBoot 也是如此之强大，那么能不能通过SpringBoot 轻松整合WebSocket 呢？这当然可以！&lt;/p&gt;
&lt;p&gt;思索了很久，我决定做一个最简单的应用展示： &lt;strong&gt;尬聊！&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么是&quot;尬聊”，而不是聊天室...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么，下面开始讲这个案例，在该样例中会包含一个Controller类、一个HTML页面以及一个JS脚本。&lt;br/&gt;步骤如下：&lt;/p&gt;
&lt;h3 id=&quot;a.-引入依赖&quot;&gt;A. 引入依赖&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;
       &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${springboot.version}&amp;lt;/version&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--websocket--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-websocket&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${springboot.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${springboot.version}&amp;lt;/version&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.webjars&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;webjars-locator-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;0.32&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.webjars&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;sockjs-client&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.webjars&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;stomp-websocket&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.3.3&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.webjars&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jquery&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.1.4&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.foo.springboot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;base&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- jackson version --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.8.3&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jackson-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.8.3&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
           &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加&lt;strong&gt;spring-boot-starter-websocket&lt;/strong&gt; 会自动引入&lt;strong&gt;spring-websocket&lt;/strong&gt;的依赖，而后者就实现了WebSocket 操作的高级封装。&lt;br/&gt;还有一个好消息，就是spring-websocket 也默认支持了 Stomp协议(看吧，Stomp支持者太多了)。&lt;br/&gt;而除此之外，还内置了一个叫 SocketJS 的东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SocketJS&lt;/strong&gt;是一个流行的JS库，主要是在WebSocket之上封装了一层API，用于支持浏览器不兼容WebSocket的情况。&lt;br/&gt;其项目地址：&lt;br/&gt;https://github.com/sockjs/sockjs-client&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他组件的说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;webjars 主要是将一些前端的框架打包到Jar包中以方便我们使用，这里我们添加了socketJS、stompWebSocket相关的一些包；&lt;/li&gt;
&lt;li&gt;jackson 用于支持WebSocket消息的编解码，是必须添加的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;b.-websocket-配置&quot;&gt;B. WebSocket 配置&lt;/h3&gt;
&lt;p&gt;参考下面的代码，添加一个JavaConfig风格的配置类：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WebSocketConfig.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {

    private static final Logger logger = LoggerFactory.getLogger(WebSocketConfig.class);

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {

        //设置订阅通道(客户端可订阅)
        config.enableSimpleBroker(&quot;/topic&quot;);

        //接收APP(客户端)消息的路由前缀，可通过@MessageMapping 映射到方法
        config.setApplicationDestinationPrefixes(&quot;/app&quot;);
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {

        //websocket 连接端点
        registry.addEndpoint(&quot;/backend&quot;).withSockJS();
    }

    @Override
    public void configureWebSocketTransport(final WebSocketTransportRegistration registration) {

        //配置拦截器
        registration.addDecoratorFactory(new WebSocketHandlerDecoratorFactory() {
            @Override
            public WebSocketHandler decorate(final WebSocketHandler handler) {
                return new WebSocketHandlerDecorator(handler) {
                    @Override
                    public void afterConnectionEstablished(final WebSocketSession session) throws Exception {
                        String username = session.getPrincipal() != null? session.getPrincipal().getName(): &quot;GUEST&quot;;
                        logger.info(&quot;{} connect.&quot;, username);
                        super.afterConnectionEstablished(session);
                    }

                    @Override
                    public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {
                        String username = session.getPrincipal() != null? session.getPrincipal().getName(): &quot;GUEST&quot;;
                        logger.info(&quot;{} disconnect.&quot;, username);
                        super.afterConnectionClosed(session, closeStatus);
                    }
                };
            }
        });
        super.configureWebSocketTransport(registration);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在WebSocketConfig的配置中，有两点需要关注：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;registerStompEndpoints 用于添加端点，即浏览器通过 &lt;strong&gt;&lt;em&gt;ws://xxx&lt;/em&gt;&lt;/strong&gt; 能访问到的路径&lt;/li&gt;
&lt;li&gt;configureMessageBroker 用于做消息路由配置，包括订阅主题、方法映射路径&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;c.-控制器&quot;&gt;C. 控制器&lt;/h3&gt;
&lt;p&gt;控制层除了支持页面的渲染，还需要对WebSocket消息进行处理，实现如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConsoleController&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Controller
public class ConsoleController {

    //输出数据频道
    public static final String CHANNEL_CONSOLE = &quot;/topic/console&quot;;


    @Autowired
    private SimpMessagingTemplate template;

    /**
     * 控制台页面
     *
     * @return
     */
    @GetMapping(&quot;/console&quot;)
    public String console() {
        return &quot;console&quot;;
    }

    /**
     * 接收WebSocket消息方法
     * @param message
     */
    @MessageMapping(&quot;/message&quot;)
    public void onMessage(String message) {
        template.convertAndSend(CHANNEL_CONSOLE, &quot;我收到了你的消息：&quot; + message);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;d.-前端实现&quot;&gt;D. 前端实现&lt;/h3&gt;
&lt;p&gt;先做一个HTML页面，编辑&lt;strong&gt;&lt;em&gt;templates/console.html&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&amp;lt;/meta&amp;gt;
    &amp;lt;title&amp;gt;Web控制台&amp;lt;/title&amp;gt;
    &amp;lt;script th:src=&quot;@{/webjars/sockjs-client/sockjs.min.js}&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script th:src=&quot;@{/webjars/stomp-websocket/stomp.min.js}&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script th:src=&quot;@{/webjars/jquery/jquery.min.js}&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/static/console.js}&quot;&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        body { font-family: &quot;Microsoft YaHei&quot; ;}
        .span-tv{padding-right:12px}
        #console p {padding: 0px; margin: 0px;}
    &amp;lt;/style&amp;gt;

&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;div style=&quot;background-color:#AAA; padding: 5px; border-bottom: 1px solid #333&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; id=&quot;word&quot; style=&quot;width:100px&quot;&amp;gt;&amp;lt;/input&amp;gt;
    &amp;lt;button onclick=&quot;sendMessage()&quot;&amp;gt;发送消息&amp;lt;/button&amp;gt;
    &amp;lt;button onclick=&quot;reconnect()&quot;&amp;gt;重新连接&amp;lt;/button&amp;gt;
    &amp;lt;button onclick=&quot;clearConsole()&quot;&amp;gt;清空内容&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div id=&quot;console&quot; style=&quot;padding:5px; font-size:10px&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是实现 JS 脚本，编辑&lt;strong&gt;&lt;em&gt;public/static/console.js&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(document).ready(function(){
   //首次打开页面自动连接
   connect();
})

//执行连接
function connect() {

    //接入端点/backend
    var socket = new SockJS('/backend');
    window.stompClient = Stomp.over(socket);
    window.stompClient.connect({}, function (frame) {
        log('Connected: ' + frame);

        //订阅服务端输出的 Topic
        stompClient.subscribe('/topic/console', function (message) {
            log(&quot;[服务器说]：&quot; + message.body);
        });
    });

}

//断开连接
function disconnect() {
    if (stompClient !== null) {
        stompClient.disconnect();
    }
    log(&quot;Disconnected&quot;);
}

//重新连接
function reconnect(){
  clearConsole();
  disconnect();
  connect();
}

//发送消息
function sendMessage(){
    var content = $(&quot;#word&quot;).val();
    if(!content){
        alert(&quot;请输入消息!&quot;)
        return;
    }
    //向应用Topic发送消息
    stompClient.send(&quot;/app/message&quot;, {}, content);
    log(&quot;[你说]：&quot; + content);
}

//记录控制台消息
function log(message){
    $(&quot;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&quot;).text(message).appendTo($(&quot;#console&quot;));
}

//清空控制台
function clearConsole(){
    $(&quot;#console&quot;).empty();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，Web控制台已经制作好了，运行主程序后，打开地址&lt;br/&gt;&lt;strong&gt;&lt;em&gt;http://localhost:8080/console&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;进行体验，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190425231137490-1521906635.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，这个案例的确很尴尬..&lt;br/&gt;但是我认为，在这上面做一做改造，应该可以实现一个诸如&lt;strong&gt;&quot;美女聊天室&quot;&lt;/strong&gt; 的功能的，或者，你可以动手试试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201904/242916-20190425231924551-564159027.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/littleatp/springboot-samples/tree/master/springboot-samples/springboot-websocket&quot;&gt;码云同步代码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;四参考文档&quot;&gt;四、参考文档&lt;/h2&gt;
&lt;p&gt;https://spring.io/guides/gs/messaging-stomp-websocket/&lt;br/&gt;https://blog.coding.net/blog/spring-static-resource-process&lt;br/&gt;https://zh.wikipedia.org/wiki/WebSocket&lt;br/&gt;https://halfrost.com/websocket/&lt;/p&gt;
&lt;p&gt;欢迎继续关注&quot;美码师的补习系列-springboot篇&quot; ，期待更多精彩内容^-^&lt;/p&gt;
</description>
<pubDate>Thu, 25 Apr 2019 15:20:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 一、聊聊 WebSocket 从HTML5技术流行至今，WebSocket已经有非常广泛的应用： 在线游戏，提供实时的操作交互体验 社交平台，与好友实时的私信对话 新闻动态，获得感兴趣的主</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/10771814.html</dc:identifier>
</item>
<item>
<title>死磕 java集合之SynchronousQueue源码分析 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/SynchronousQueue.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/SynchronousQueue.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）SynchronousQueue的实现方式？&lt;/p&gt;
&lt;p&gt;（2）SynchronousQueue真的是无缓冲的吗？&lt;/p&gt;
&lt;p&gt;（3）SynchronousQueue在高并发情景下会有什么问题？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;SynchronousQueue是java并发包下无缓冲阻塞队列，它用来在两个线程之间移交元素，但是它有个很大的问题，你知道是什么吗？请看下面的分析。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;h3 id=&quot;主要属性&quot;&gt;主要属性&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// CPU的数量
static final int NCPUS = Runtime.getRuntime().availableProcessors();
// 有超时的情况自旋多少次，当CPU数量小于2的时候不自旋
static final int maxTimedSpins = (NCPUS &amp;lt; 2) ? 0 : 32;
// 没有超时的情况自旋多少次
static final int maxUntimedSpins = maxTimedSpins * 16;
// 针对有超时的情况，自旋了多少次后，如果剩余时间大于1000纳秒就使用带时间的LockSupport.parkNanos()这个方法
static final long spinForTimeoutThreshold = 1000L;
// 传输器，即两个线程交换元素使用的东西
private transient volatile Transferer&amp;lt;E&amp;gt; transferer;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过属性我们可以Get到两个点：&lt;/p&gt;
&lt;p&gt;（1）这个阻塞队列里面是会自旋的；&lt;/p&gt;
&lt;p&gt;（2）它使用了一个叫做transferer的东西来交换元素；&lt;/p&gt;
&lt;h3 id=&quot;主要内部类&quot;&gt;主要内部类&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Transferer抽象类，主要定义了一个transfer方法用来传输元素
abstract static class Transferer&amp;lt;E&amp;gt; {
    abstract E transfer(E e, boolean timed, long nanos);
}
// 以栈方式实现的Transferer
static final class TransferStack&amp;lt;E&amp;gt; extends Transferer&amp;lt;E&amp;gt; {
    // 栈中节点的几种类型：
    // 1. 消费者（请求数据的）
    static final int REQUEST    = 0;
    // 2. 生产者（提供数据的）
    static final int DATA       = 1;
    // 3. 二者正在匹配中
    static final int FULFILLING = 2;

    // 栈中的节点
    static final class SNode {
        // 下一个节点
        volatile SNode next;        // next node in stack
        // 匹配者
        volatile SNode match;       // the node matched to this
        // 等待着的线程
        volatile Thread waiter;     // to control park/unpark
        // 元素
        Object item;                // data; or null for REQUESTs
        // 模式，也就是节点的类型，是消费者，是生产者，还是正在匹配中
        int mode;
    }
    // 栈的头节点
    volatile SNode head;
}
// 以队列方式实现的Transferer
static final class TransferQueue&amp;lt;E&amp;gt; extends Transferer&amp;lt;E&amp;gt; {
    // 队列中的节点
    static final class QNode {
        // 下一个节点
        volatile QNode next;          // next node in queue
        // 存储的元素
        volatile Object item;         // CAS'ed to or from null
        // 等待着的线程
        volatile Thread waiter;       // to control park/unpark
        // 是否是数据节点
        final boolean isData;
    }

    // 队列的头节点
    transient volatile QNode head;
    // 队列的尾节点
    transient volatile QNode tail;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）定义了一个抽象类Transferer，里面定义了一个传输元素的方法；&lt;/p&gt;
&lt;p&gt;（2）有两种传输元素的方法，一种是栈，一种是队列；&lt;/p&gt;
&lt;p&gt;（3）栈的特点是后进先出，队列的特点是先进行出；&lt;/p&gt;
&lt;p&gt;（4）栈只需要保存一个头节点就可以了，因为存取元素都是操作头节点；&lt;/p&gt;
&lt;p&gt;（5）队列需要保存一个头节点一个尾节点，因为存元素操作尾节点，取元素操作头节点；&lt;/p&gt;
&lt;p&gt;（6）每个节点中保存着存储的元素、等待着的线程，以及下一个节点；&lt;/p&gt;
&lt;p&gt;（7）栈和队列两种方式有什么不同呢？请看下面的分析。&lt;/p&gt;
&lt;h3 id=&quot;主要构造方法&quot;&gt;主要构造方法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public SynchronousQueue() {
    // 默认非公平模式
    this(false);
}

public SynchronousQueue(boolean fair) {
    // 如果是公平模式就使用队列，如果是非公平模式就使用栈
    transferer = fair ? new TransferQueue&amp;lt;E&amp;gt;() : new TransferStack&amp;lt;E&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（1）默认使用非公平模式，也就是栈结构；&lt;/p&gt;
&lt;p&gt;（2）公平模式使用队列，非公平模式使用栈；&lt;/p&gt;
&lt;h3 id=&quot;入队&quot;&gt;入队&lt;/h3&gt;
&lt;p&gt;我们这里主要介绍以栈方式实现的传输模式，以put(E e)方法为例。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void put(E e) throws InterruptedException {
    // 元素不可为空
    if (e == null) throw new NullPointerException();
    // 直接调用传输器的transfer()方法
    // 三个参数分别是：传输的元素，是否需要超时，超时的时间
    if (transferer.transfer(e, false, 0) == null) {
        // 如果传输失败，直接让线程中断并抛出中断异常
        Thread.interrupted();
        throw new InterruptedException();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用transferer的transfer()方法，传入元素e，说明是生产者&lt;/p&gt;
&lt;h3 id=&quot;出队&quot;&gt;出队&lt;/h3&gt;
&lt;p&gt;我们这里主要介绍以栈方式实现的传输模式，以take()方法为例。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E take() throws InterruptedException {
    // 直接调用传输器的transfer()方法
    // 三个参数分别是：null，是否需要超时，超时的时间
    // 第一个参数为null表示是消费者，要取元素
    E e = transferer.transfer(null, false, 0);
    // 如果取到了元素就返回
    if (e != null)
        return e;
    // 否则让线程中断并抛出中断异常
    Thread.interrupted();
    throw new InterruptedException();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用transferer的transfer()方法，传入null，说明是消费者。&lt;/p&gt;
&lt;h3 id=&quot;transfer方法&quot;&gt;transfer()方法&lt;/h3&gt;
&lt;p&gt;transfer()方法同时实现了取元素和放元素的功能，下面我再来看看这个transfer()方法里究竟干了什么。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// TransferStack.transfer()方法
E transfer(E e, boolean timed, long nanos) {
    SNode s = null; // constructed/reused as needed
    // 根据e是否为null决定是生产者还是消费者
    int mode = (e == null) ? REQUEST : DATA;
    // 自旋+CAS，熟悉的套路，熟悉的味道
    for (;;) {
        // 栈顶元素
        SNode h = head;
        // 栈顶没有元素，或者栈顶元素跟当前元素是一个模式的
        // 也就是都是生产者节点或者都是消费者节点
        if (h == null || h.mode == mode) {  // empty or same-mode
            // 如果有超时而且已到期
            if (timed &amp;amp;&amp;amp; nanos &amp;lt;= 0) {      // can't wait
                // 如果头节点不为空且是取消状态
                if (h != null &amp;amp;&amp;amp; h.isCancelled())
                    // 就把头节点弹出，并进入下一次循环
                    casHead(h, h.next);     // pop cancelled node
                else
                    // 否则，直接返回null（超时返回null）
                    return null;
            } else if (casHead(h, s = snode(s, e, h, mode))) {
                // 入栈成功（因为是模式相同的，所以只能入栈）
                // 调用awaitFulfill()方法自旋+阻塞当前入栈的线程并等待被匹配到
                SNode m = awaitFulfill(s, timed, nanos);
                // 如果m等于s，说明取消了，那么就把它清除掉，并返回null
                if (m == s) {               // wait was cancelled
                    clean(s);
                    // 被取消了返回null
                    return null;
                }
                
                // 到这里说明匹配到元素了
                // 因为从awaitFulfill()里面出来要不被取消了要不就匹配到了
                
                // 如果头节点不为空，并且头节点的下一个节点是s
                // 就把头节点换成s的下一个节点
                // 也就是把h和s都弹出了
                // 也就是把栈顶两个元素都弹出了
                if ((h = head) != null &amp;amp;&amp;amp; h.next == s)
                    casHead(h, s.next);     // help s's fulfiller
                // 根据当前节点的模式判断返回m还是s中的值
                return (E) ((mode == REQUEST) ? m.item : s.item);
            }
        } else if (!isFulfilling(h.mode)) { // try to fulfill
            // 到这里说明头节点和当前节点模式不一样
            // 如果头节点不是正在匹配中
            
            // 如果头节点已经取消了，就把它弹出栈
            if (h.isCancelled())            // already cancelled
                casHead(h, h.next);         // pop and retry
            else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {
                // 头节点没有在匹配中，就让当前节点先入队，再让他们尝试匹配
                // 且s成为了新的头节点，它的状态是正在匹配中
                for (;;) { // loop until matched or waiters disappear
                    SNode m = s.next;       // m is s's match
                    // 如果m为null，说明除了s节点外的节点都被其它线程先一步匹配掉了
                    // 就清空栈并跳出内部循环，到外部循环再重新入栈判断
                    if (m == null) {        // all waiters are gone
                        casHead(s, null);   // pop fulfill node
                        s = null;           // use new node next time
                        break;              // restart main loop
                    }
                    SNode mn = m.next;
                    // 如果m和s尝试匹配成功，就弹出栈顶的两个元素m和s
                    if (m.tryMatch(s)) {
                        casHead(s, mn);     // pop both s and m
                        // 返回匹配结果
                        return (E) ((mode == REQUEST) ? m.item : s.item);
                    } else                  // lost match
                        // 尝试匹配失败，说明m已经先一步被其它线程匹配了
                        // 就协助清除它
                        s.casNext(m, mn);   // help unlink
                }
            }
        } else {                            // help a fulfiller
            // 到这里说明当前节点和头节点模式不一样
            // 且头节点是正在匹配中
            
            SNode m = h.next;               // m is h's match
            if (m == null)                  // waiter is gone
                // 如果m为null，说明m已经被其它线程先一步匹配了
                casHead(h, null);           // pop fulfilling node
            else {
                SNode mn = m.next;
                // 协助匹配，如果m和s尝试匹配成功，就弹出栈顶的两个元素m和s
                if (m.tryMatch(h))          // help match
                    // 将栈顶的两个元素弹出后，再让s重新入栈
                    casHead(h, mn);         // pop both h and m
                else                        // lost match
                    // 尝试匹配失败，说明m已经先一步被其它线程匹配了
                    // 就协助清除它
                    h.casNext(m, mn);       // help unlink
            }
        }
    }
}

// 三个参数：需要等待的节点，是否需要超时，超时时间
SNode awaitFulfill(SNode s, boolean timed, long nanos) {
    // 到期时间
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    // 当前线程
    Thread w = Thread.currentThread();
    // 自旋次数
    int spins = (shouldSpin(s) ?
                 (timed ? maxTimedSpins : maxUntimedSpins) : 0);
    for (;;) {
        // 当前线程中断了，尝试清除s
        if (w.isInterrupted())
            s.tryCancel();
        
        // 检查s是否匹配到了元素m（有可能是其它线程的m匹配到当前线程的s）
        SNode m = s.match;
        // 如果匹配到了，直接返回m
        if (m != null)
            return m;
        
        // 如果需要超时
        if (timed) {
            // 检查超时时间如果小于0了，尝试清除s
            nanos = deadline - System.nanoTime();
            if (nanos &amp;lt;= 0L) {
                s.tryCancel();
                continue;
            }
        }
        if (spins &amp;gt; 0)
            // 如果还有自旋次数，自旋次数减一，并进入下一次自旋
            spins = shouldSpin(s) ? (spins-1) : 0;
        
        // 后面的elseif都是自旋次数没有了
        else if (s.waiter == null)
            // 如果s的waiter为null，把当前线程注入进去，并进入下一次自旋
            s.waiter = w; // establish waiter so can park next iter
        else if (!timed)
            // 如果不允许超时，直接阻塞，并等待被其它线程唤醒，唤醒后继续自旋并查看是否匹配到了元素
            LockSupport.park(this);
        else if (nanos &amp;gt; spinForTimeoutThreshold)
            // 如果允许超时且还有剩余时间，就阻塞相应时间
            LockSupport.parkNanos(this, nanos);
    }
}

    // SNode里面的方向，调用者m是s的下一个节点
    // 这时候m节点的线程应该是阻塞状态的
    boolean tryMatch(SNode s) {
        // 如果m还没有匹配者，就把s作为它的匹配者
        if (match == null &amp;amp;&amp;amp;
            UNSAFE.compareAndSwapObject(this, matchOffset, null, s)) {
            Thread w = waiter;
            if (w != null) {    // waiters need at most one unpark
                waiter = null;
                // 唤醒m中的线程，两者匹配完毕
                LockSupport.unpark(w);
            }
            // 匹配到了返回true
            return true;
        }
        // 可能其它线程先一步匹配了m，返回其是否是s
        return match == s;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个逻辑比较复杂，这里为了简单起见，屏蔽掉多线程处理的细节，只描述正常业务场景下的逻辑：&lt;/p&gt;
&lt;p&gt;（1）如果栈中没有元素，或者栈顶元素跟将要入栈的元素模式一样，就入栈；&lt;/p&gt;
&lt;p&gt;（2）入栈后自旋等待一会看有没有其它线程匹配到它，自旋完了还没匹配到元素就阻塞等待；&lt;/p&gt;
&lt;p&gt;（3）阻塞等待被唤醒了说明其它线程匹配到了当前的元素，就返回匹配到的元素；&lt;/p&gt;
&lt;p&gt;（4）如果两者模式不一样，且头节点没有在匹配中，就拿当前节点跟它匹配，匹配成功了就返回匹配到的元素；&lt;/p&gt;
&lt;p&gt;（5）如果两者模式不一样，且头节点正在匹配中，当前线程就协助去匹配，匹配完成了再让当前节点重新入栈重新匹配；&lt;/p&gt;
&lt;p&gt;如果直接阅读这部分代码还是比较困难的，建议写个测试用例，打个断点一步一步跟踪调试。&lt;/p&gt;
&lt;p&gt;下面是我的测试用例，可以参考下，在IDEA中可以让断点只阻塞线程:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestSynchronousQueue {
    public static void main(String[] args) throws InterruptedException {
        SynchronousQueue&amp;lt;Integer&amp;gt; queue = new SynchronousQueue&amp;lt;&amp;gt;(false);

        new Thread(()-&amp;gt;{
            try {
                queue.put(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();


        Thread.sleep(500);
        System.out.println(queue.take());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改断点只阻塞线程的方法，右击断点，选择Thread：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/synchronous1.png&quot; alt=&quot;thread&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;交给你了&quot;&gt;交给你了&lt;/h2&gt;
&lt;p&gt;上面的源码分析都是基于Stack的方式来分析的，那么队列是怎么运行的呢？很简单哦，测试用例中的false改成true就可以了，这就交给你了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）SynchronousQueue是java里的无缓冲队列，用于在两个线程之间直接移交元素；&lt;/p&gt;
&lt;p&gt;（2）SynchronousQueue有两种实现方式，一种是公平（队列）方式，一种是非公平（栈）方式；&lt;/p&gt;
&lt;p&gt;（3）栈方式中的节点有三种模式：生产者、消费者、正在匹配中；&lt;/p&gt;
&lt;p&gt;（4）栈方式的大致思路是如果栈顶元素跟自己一样的模式就入栈并等待被匹配，否则就匹配，匹配到了就返回；&lt;/p&gt;
&lt;p&gt;（5）队列方式的大致思路是……不告诉你^^（两者的逻辑差别还是挺大的）&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;（1）SynchronousQueue真的是无缓冲的队列吗？&lt;/p&gt;
&lt;p&gt;通过源码分析，我们可以发现其实SynchronousQueue内部或者使用栈或者使用队列来存储包含线程和元素值的节点，如果同一个模式的节点过多的话，它们都会存储进来，且都会阻塞着，所以，严格上来说，SynchronousQueue并不能算是一个无缓冲队列。&lt;/p&gt;
&lt;p&gt;（2）SynchronousQueue有什么缺点呢？&lt;/p&gt;
&lt;p&gt;试想一下，如果有多个生产者，但只有一个消费者，如果消费者处理不过来，是不是生产者都会阻塞起来？反之亦然。&lt;/p&gt;
&lt;p&gt;这是一件很危险的事，所以，SynchronousQueue一般用于生产、消费的速度大致相当的情况，这样才不会导致系统中过多的线程处于阻塞状态。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Apr 2019 15:01:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>SynchronousQueue的实现方式？ SynchronousQueue真的是无缓冲的吗？ SynchronousQueue在高并发情景下会有什么问题？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/SynchronousQueue.html</dc:identifier>
</item>
<item>
<title>系统掉盘，机械硬盘掉盘，固态掉盘 - 三天泪</title>
<link>http://www.cnblogs.com/3daytears/p/10771724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/3daytears/p/10771724.html</guid>
<description>&lt;p&gt;之前的立式服务器当了主机打起了游戏，但是经过半年的游戏的时间发现，机子开始变得卡了？我不由得怀疑是不是机子出现老化的问题了。打开盖子一看进了灰尘，就开始清灰了，但是情况在心理暗示的情况下没有好转。这时我打游戏才了打了三个月。&lt;/p&gt;
&lt;p&gt;不由得开始思考是不是真的老化了，事情才刚刚开始。在2个月后打游戏的晚上，我的游戏盘掉了。一个属于2t分区（666g）的盘直接就没了，是分区先没的，然后我就困惑的发现其他盘也反应变慢，写一个笔记txt都要保存一分钟。我无奈的只能重启。英雄联盟挂机之路开始~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1130764/201904/1130764-20190425221937393-615713812.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现又变好了。嗯估计是系统bug吧，继续嗨~&lt;/p&gt;

&lt;p&gt;出问题第二个月，我的2t硬盘的分区开始全部掉了。可是这怎么能难倒我，我换一个sata插口继续玩，果然又识别了。果然是主板问题。然后也怀疑是电源老化，取下了一半的机箱风扇（3个）。继续玩着&lt;/p&gt;
&lt;p&gt;然后第三个月，悲哀的我发现或许是突然断电导致我的硬盘烧了。每次一开机就宿舍断电，宿管阿姨说是不是插排坏了，重买一个吧。。。。然后，我就重买了一个插排，仅靠着最后一个sata插口又玩了一个月。&lt;span&gt;（排除了插排和sata接口的问题）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第四个月，经过我的电脑谁都不许碰，但还是在一个宁静的中午突然断电。一问才知道没交电费，匆匆交了电费，发现我的电脑还能开，硬盘没有坏。但是此时此刻的我已经很悲伤了。因为这是最后一个sata口，一旦炸了，我的2t数据或许就这么没了。小电影还是随意的，但是那些保存了n年的破解软件，怎么搞？已经没有下载地方了啊！还有100g纯音乐，现在都是付费的下载怎么可能复现嘛。&lt;span&gt;（数据无价，硬盘有价！）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 然后买了三星的ssd，个人猜测是机械硬盘的质量问题。因为或许是机子过热导致硬盘识别不了？&lt;span&gt;（这排除了sata线的问题）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但是在换了ssd，把机械硬盘塞床底下玩了2个月后，简直颠覆我的想法了，ssd也在掉盘！！！&lt;span&gt;（排除了sdd固态硬盘是因为质量问题，也证明了机械硬盘掉盘不是自己的错）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我的天，我实在不敢相信三星的ssd还掉盘！怎么可能？我不由得目光投向主机，之前我抱到宿舍的机子，没有漏电，现在漏电了！是什么原因？排插没有地线？还是主板漏电？&lt;/p&gt;
&lt;p&gt;我尝试的摸了一下机箱并继续感受着光滑的机箱却出现粗糙的感觉，此时的脚晃着踩在了电脑桌上。突然发生针刺一般的痛。我记得之前漏电没有这么厉害！怎么可能会出现痛觉，记得是手指轻点的而不是针刺！我有点明白了。或许一开始我的配件就没有问题呢？&lt;/p&gt;
&lt;p&gt;或许吧&lt;/p&gt;
&lt;p&gt;我打开摸了一下ssd，果然带电了，摩擦感觉很足。和之前取下来机械硬盘的情况一样，带电！&lt;/p&gt;
&lt;p&gt;但是另一个ssd没问题？是因为是塑料壳子么，在我拔下来的时候sata的线电了我一下。我。。。&lt;/p&gt;
&lt;p&gt;主板！主板在漏电！一直在欺负我的硬盘！&lt;/p&gt;
&lt;p&gt;我决定要拆开他！全部拆开，我臆想着主板后面一定藏着大块灰尘！&lt;/p&gt;
&lt;p&gt;然而今天的早上的我发现。&lt;/p&gt;
&lt;p&gt;拆下来的电源轻轻放下来的时候，竟然掉了一团灰尘！我擦，我轻轻的掉一团！怎么可能嘛？&lt;/p&gt;
&lt;p&gt;我拆开了我的电源，悲伤的发现除了电路板就是灰尘。。。&lt;/p&gt;
&lt;p&gt;然后我大概就明白了是因为什么了。&lt;/p&gt;


&lt;p&gt;机箱的风道：&lt;/p&gt;
&lt;p&gt;每个机箱都不一样，但是都会因为ssd或者hdd的存放位置造成风道死角，当然这在新的主板已经得到有效解决了&lt;/p&gt;
&lt;p&gt;我的电源和硬盘在下面，风力小只有正面一个风扇抽风，背面没有地方安装，也正是正面抽风导致靠后的电源从下抽风周围的风压增大。&lt;/p&gt;
&lt;p&gt;这也是为什么我在家没问题来了就有问题，因为第一次清灰的时候发现这么设置不合理，正面应该抽风，而不是吸风，这样就不会造成主板上的灰尘堆积了。但是这样做就会造成电源的吸风变大，造成电源内囤积了灰尘。&lt;/p&gt;
&lt;p&gt;这或许就是X58主板的短板吧&lt;/p&gt;
&lt;p&gt;希望其他掉盘的也可以参考&lt;/p&gt;

</description>
<pubDate>Thu, 25 Apr 2019 15:00:00 +0000</pubDate>
<dc:creator>三天泪</dc:creator>
<og:description>之前的立式服务器当了主机打起了游戏，但是经过半年的游戏的时间发现，机子开始变得卡了？我不由得怀疑是不是机子出现老化的问题了。打开盖子一看进了灰尘，就开始清灰了，但是情况在心理暗示的情况下没有好转。这时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/3daytears/p/10771724.html</dc:identifier>
</item>
<item>
<title>页面性能优化-原生JS实现图片懒加载 - Peer1029</title>
<link>http://www.cnblogs.com/peerless1029/p/10771695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peerless1029/p/10771695.html</guid>
<description>
&lt;p&gt;  &lt;span&gt; &lt;span&gt;在项目开发中，我们往往会遇到一个页面需要加载很多图片的情况。我们可以一次性加载全部的图片，但是考虑到用户有可能只浏览部分图片。所以我们需要对图片加载进行优化，只加载浏览器窗口内的图片，当用户滚动时，再加载更多的图片。这种加载图片的方式叫做图片懒加载，又叫做按需加载或图片的延时加载。这样做的好处是：1.可以加快页面首屏渲染的速度；2.节约用户的流量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一.实现思路&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.图片img标签自定义一个属性data-src来存放真实的地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.当滚动页面时，检查所有的img标签，判断是否出现在事业中，如果出现在视野中，继续进行判断，看齐是否被加载过了，如果没有加载，那就进行加载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;判断图片元素是否处于浏览器视野中的示意图（手绘）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201904/1103967-20190425222810071-1832515366.jpg&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;806&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.根据思路完成代码如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;原生js实现图片懒加载&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    *&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      box-sizing&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; border-box&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    ul&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      overflow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; hidden&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      list-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; none&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    li&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    li img&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; inline-block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/1.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/1.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/2.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/3.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/4.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/5.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/6.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/7.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/8.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/9.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/10.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/11.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/12.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/13.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/14.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/15.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; data-src&lt;/span&gt;&lt;span&gt;=&quot;http://cdn.jirengu.com/book.jirengu.com/img/16.jpg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; window绑定滚动事件&lt;/span&gt;
&lt;span&gt;  window.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;scroll&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历所有的img标签&lt;/span&gt;
&lt;span&gt;    Array.prototype.slice.apply(document.getElementsByTagName(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)).forEach((li)&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;{
      let img&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;li.getElementsByTagName(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;img&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断当前img是否出现在了视野中&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断当前img是否被加载过了&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(checkShow(img) &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;isLoaded(img)){
        loadImg(img);
      }
    })
  });

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断img是否出现浏览器视野中&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkShow(img) {
    let scrollTop&lt;/span&gt;&lt;span&gt;=document.documentElement.scrollTop&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 页面向上滚动的高度&lt;/span&gt;
&lt;span&gt;    let windowHeight&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;window.innerHeight; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器自身高度&lt;/span&gt;
&lt;span&gt;    let offsetTop&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;img.offsetTop; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标标签相对于document的高度&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (offsetTop &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; scrollTop &lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; offsetTop &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;(windowHeight &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; scrollTop));
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否已经加载过&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; isLoaded(img) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; img.getAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;===&lt;/span&gt;&lt;span&gt;img.getAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data-src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载图片&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; loadImg(img) {
   img.setAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,img.getAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data-src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));
  }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，在浏览器中运行一下，第一次进页面如果不滚动滚轮的话什么也看不到，所以第一次进页面需要调用checkShow(),处于视野中的图片也加载出来。&lt;/p&gt;
&lt;p&gt;在代码最后加上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// 第一次进页面加载处于视野中的图片
 Array.prototype.slice.apply(document.getElementsByTagName('li')).forEach((li)=&amp;gt;{
    let img=li.getElementsByTagName('img')[0];
    // 判断当前img是否出现在了视野中
    // 判断当前img是否被加载过了
    if(checkShow(img) &amp;amp;&amp;amp; !isLoaded(img)){
      loadImg(img);
    }
  })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;此时我们发现判断加载视野中的图片代码存在重复，直接封装成一个新的方法lazyRenderImg();&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; window绑定滚动事件&lt;/span&gt;
  window.addEventListener('scroll',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历所有的img标签&lt;/span&gt;
&lt;span&gt;    lazyRenderImg();
  });

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; lazyRenderImg(){
 Array.prototype.slice.apply(document.getElementsByTagName(&lt;/span&gt;'li')).forEach((li)=&amp;gt;&lt;span&gt;{
      let img&lt;/span&gt;=li.getElementsByTagName('img')[0&lt;span&gt;];
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断当前img是否出现在了视野中&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断当前img是否被加载过了&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(checkShow(img) &amp;amp;&amp;amp; !&lt;span&gt;isLoaded(img)){
        loadImg(img);
      }
    })
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一次进页面加载处于视野中的图片&lt;/span&gt;
  lazyRenderImg();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 三.性能优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题：window.scroll 方法页面只要一滚动就会触发里面的方法，对性能影响很大&lt;/p&gt;
&lt;p&gt;解决方法：当页面停止滚动的时候，再去执行页面中的方法，类似与函数节流（throttle）&lt;/p&gt;
&lt;p&gt;Tips:函数节流：等时间间隔执行函数， 让一个函数不要执行得太频繁，减少一些过快的调用来节流。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; window绑定滚动事件&lt;/span&gt;
&lt;span&gt;  let timer;
  window.addEventListener(&lt;/span&gt;'scroll',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){&lt;br/&gt;console.log('scroll')
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历所有的img标签&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(timer){
      clearTimeout(timer)
    }
    timer&lt;/span&gt;=setTimeout(()=&amp;gt;&lt;span&gt;{&lt;br/&gt;console.log('lazyRenderImg...');
      lazyRenderImg();
    },&lt;/span&gt;300&lt;span&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过打印的日志发现当滚动停止后才执行lazyRenderImg方法的，确实减少了不必要调用lazyRenderImg的次数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201904/1103967-20190425224746163-1369627931.png&quot; alt=&quot;&quot; width=&quot;632&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    页面性能优化之图片懒加载就写这么多了，网页优化还有很多方法与技巧，前端路漫漫其修远兮，吾将上下而求索。本文不足之处，请多指正。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/1b32e16ed0e5&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 25 Apr 2019 14:55:00 +0000</pubDate>
<dc:creator>Peer1029</dc:creator>
<og:description>在项目开发中，我们往往会遇到一个页面需要加载很多图片的情况。我们可以一次性加载全部的图片，但是考虑到用户有可能只浏览部分图片。所以我们需要对图片加载进行优化，只加载浏览器窗口内的图片，当用户滚动时，再</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peerless1029/p/10771695.html</dc:identifier>
</item>
<item>
<title>[译]背景：着色的物理和数学(4) - BIT祝威</title>
<link>http://www.cnblogs.com/bitzhuwei/p/background-Physics-and-Math-of-Shading-4.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bitzhuwei/p/background-Physics-and-Math-of-Shading-4.html</guid>
<description>&lt;p&gt;&lt;span&gt;[译]背景：着色的物理和数学(4)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（译者注：本文是翻译的Naty Hoffman的《Background: Physics and Math of Shading》。我希望通过翻译此文，彻底理解PBR的原理。某些我实在不知道如何恰当翻译的地方，就把英文原文也放上了。）&lt;/p&gt;


&lt;p&gt;很多发表的微表面BRDF函数中，都把分子G(l, v, h)的和分母(n•l)(n•v)的各用一个子表达式代替了，所以有必要给它们起个名字。由于分母可以被认为是“透视缩减因子”，且它的两部分都与可见性相关，我就称它为“可见性项”。有的BRDF函数（常常是那些用于电影和游戏中的）根本没有可见性项，这等于将可见性项设置为1，算是对几何函数的隐式定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224350047-1079606976.png&quot; alt=&quot;&quot;/&gt;(29)&lt;/p&gt;
&lt;p&gt;这对于高度场微表面（对应Blinn-Phong的法线分布函数，毕竟它对所有背向的微观几何体表面区域都是0）这实际上是一个看起来可信的几何函数。当l=n且v=n时，Gimplicit()等于1，这对于高度场是正确的（在微表面法线方向上没有微观几何体的表面区域被遮挡）。它在l或v为掠射角时，它为0，这也是正确的（表面点被其他表面区域遮挡的概率，随观察者角度的增加而增加，极限是100%）。鉴于这一几何函数的耗费（一次循环都不需要），它有很高的“性价比”。&lt;/p&gt;
&lt;p&gt;当比较Gimplicit()与其图形学文献中的几何函数时，我们发现它达到0的速度太快——它在湿度的掠射角就很暗了。换句话说，添加一个显式的集合函数，会让specular项的高光更亮（这可能看起来不符合直觉，然后我们想起来我们同时也在分母引入了透视缩减因子）。这个隐式的函数不受表面粗糙度的影响，这不符合真实——我们期望粗糙的表面比光滑的表面有更大的阴影和遮蔽概率。&lt;/p&gt;
&lt;p&gt;图形学文献中最早的几何函数被称为“Cook-Torrance”，其出现在这两位作者的著名论文中[15, 16]：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224358906-1176308117.png&quot; alt=&quot;&quot;/&gt;(30)&lt;/p&gt;
&lt;p&gt;Torrance和Sparrow[70]提出了一个几何函数，之后（在Equation 30几年后），Blinn[7]在一篇论文中首次提出这个几何函数的一个变形（因此，更准确的叫法应该是“Blinn-Torrance-Sparrow几何函数”，但是“Cook-Torrance”的用法已经太普遍了，改不了了）。这些年来Cook-Torrance几何函数被大量采用（特别是电影），但是它有几个问题：它是基于一个不真实的微观几何体模型（由无限长的凹槽组成的各向同性表面），且不受粗糙度影响。&lt;/p&gt;
&lt;p&gt;另外，Cook-Torrance对游戏来说比较昂贵。但是，Kelemen et al.[41]提出了一个非常廉价高效的近似：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224405294-1677617758.png&quot; alt=&quot;&quot;/&gt;(31)&lt;/p&gt;
&lt;p&gt;这几乎和隐式几何函数一样廉价了。它逼近Cook-Torrance几何函数和分母上的透视缩减因子，却只需要除以点积（反正这个点积也要在Fresnel项中计算）的平方。&lt;/p&gt;
&lt;p&gt;当考虑整体上的精确度时，我个人推荐几何函数中的Smith函数族[66]。它们被广泛认为比Cook-Torrance更精确，而且考虑了粗糙度和法线分布的形状。原始的Smith函数被设计为供Beckmann的NDF用，但是Brown[9]和后来的Bourlier et al.[8]将Smith函数泛化为一套计算能适应任何NDF的几何函数的方法。Walter et al.[73]总结了这些成果，为Beckmann和Trowbridge-Reitz(GGX)（注意，Schlick对原始Smith函数的近似，严格来说，用在微平面BRDF中是错误的，因为它近似的是错误的函数版本。这个错误在多处被推荐给读者——悲剧的是包括我自己的书。但是，研究表明[38]，做一点参数重映射，它还能作为正确函数的高效近似）的NDF函数，给出了一个对Smith函数的高效的近似。Bagher et al.[4]针对他们提出的SGD版NDF，给出了一个Smith函数的近似。&lt;/p&gt;
&lt;p&gt;Smith函数组已经被用于制作效果良好的电影[10, 54]，尽管前述论文的作者推荐用户要调整粗糙度值。已发表的对各种Smith函数的近似，还是比Kelemen函数昂贵的多，尽管可能为游戏找到便宜的近似，在相同的程度上还是Kelemen函数更成功地逼近（更复杂得多的）Cook-Torrance几何函数（Schlick-Smith几何函数族的类似近似在本课程另一讲中有介绍）。&lt;/p&gt;

&lt;p&gt;《Real-Time Rendering》第三版第7章[58]，概述了基于物理的着色模型，比本课程更加深入一些。如果需要更深入了解，考虑读一下Glassner的《Principles of Digital Images Synthesis》[25, 26]，或者Dorsey、Rushmeier和Sillicon的《Digital Modeling of Material Appearance》[21]。注意，这些书里不包括这几年最新的研究成果。&lt;/p&gt;
&lt;p&gt;Dutre的免费在线《Global Illumination Compendium》[23]是BRDF、辐射度量数学和各种相关东西的有用的参考书。&lt;/p&gt;
&lt;p&gt;最后，本课程的其他讲（包括2010和2012的前任）包含很多将基于物理的着色模型用于生产的有用信息。&lt;/p&gt;

&lt;p&gt;（这个就不翻译了，有兴趣的自己看）&lt;/p&gt;

&lt;p&gt;（译者注：从PDF里直接复制，会出现很多乱码，所以我直接上图了。）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224417191-42099397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224427881-395569171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224441041-554503040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224446977-132369032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224455826-1610862286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224503351-1565424083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224507362-379113849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224515956-1933343626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224523710-983873681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224528526-760902870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224534051-225438429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201904/383191-20190425224540136-933113635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 25 Apr 2019 14:48:00 +0000</pubDate>
<dc:creator>BIT祝威</dc:creator>
<og:description>[译]背景：着色的物理和数学(4) （译者注：本文是翻译的Naty Hoffman的《Background: Physics and Math of Shading》。我希望通过翻译此文，彻底理解PB</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bitzhuwei/p/background-Physics-and-Math-of-Shading-4.html</dc:identifier>
</item>
<item>
<title>《k8s 源码分析》- Custom Controller 之 Informer - CloudGeek</title>
<link>http://www.cnblogs.com/cloudgeek/p/10771567.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloudgeek/p/10771567.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;本节标题写的是 Informer，不过我们的内容不局限于狭义的 Informer 部分，只是 Informer 最有代表性，其他的 Reflector 等也不好独立开来讲。&lt;/p&gt;
&lt;p&gt;Informer 在很多组件的源码中可以看到，尤其是 kube-controller-manager (写这篇文章时我已经基本写完 kube-scheduler 的源码分析，着手写 kube-controller-manager 了，鉴于 controlelr 和 client-go 关联比较大，跳过来先讲讲典型的控制器工作流程中涉及到的 client-go 部分).&lt;/p&gt;
&lt;p&gt;Informer 是 client-go 中一个比较核心的工具，通过 Informer(实际我们用到的都不是单纯的 informer，而是组合了各种工具的 sharedInformerFactory) 我们可以轻松 List/Get 某个资源对象，可以监听资源对象的各种事件(比如创建和删除)然后触发回调函数，让我们能够在各种事件发生的时候能够作出相应的逻辑处理。举个例字，当 pod 数量变化的时候 deployment 是不是需要判断自己名下的 pod 数量是否还和预期的一样？如果少了是不是要考虑创建？&lt;/p&gt;
&lt;h2 id=&quot;架构概览&quot;&gt;2. 架构概览&lt;/h2&gt;
&lt;p&gt;自定义控制器的工作流程基本如下图所示，我们今天要分析图中上半部分的逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://farmer-hutao.github.io/k8s-source-code-analysis/around/client-go/image/informer/1555996411720.png&quot; alt=&quot;1555996411720&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们开发自定义控制器的时候用到的“机制”主要定义在 client-go 的 tool/cache下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://farmer-hutao.github.io/k8s-source-code-analysis/around/client-go/image/informer/1556075198766.png&quot; alt=&quot;1556075198766&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们根据图中的9个步骤来跟源码&lt;/p&gt;
&lt;h2 id=&quot;reflector_-_List___Watch_API_Server&quot;&gt;3. reflector - List &amp;amp; Watch API Server&lt;/h2&gt;
&lt;p&gt;Reflector 会监视特定的资源，将变化写入给定的存储中，也就是 Delta FIFO queue.&lt;/p&gt;
&lt;h3 id=&quot;Reflector_对象&quot;&gt;3.1. Reflector 对象&lt;/h3&gt;
&lt;p&gt;Reflector 的中文含义是反射器，我们先看一下类型定义：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/reflector.go:47&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;type Reflector &lt;span class=&quot;token keyword&quot;&gt;struct &lt;span class=&quot;token punctuation&quot;&gt;{
   name &lt;span class=&quot;token builtin&quot;&gt;string
   metrics &lt;span class=&quot;token operator&quot;&gt;*reflectorMetrics
   expectedType reflect&lt;span class=&quot;token punctuation&quot;&gt;.Type

   store Store
   listerWatcher ListerWatcher

   period       time&lt;span class=&quot;token punctuation&quot;&gt;.Duration
   resyncPeriod time&lt;span class=&quot;token punctuation&quot;&gt;.Duration
   ShouldResync &lt;span class=&quot;token keyword&quot;&gt;func&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token builtin&quot;&gt;bool
   clock clock&lt;span class=&quot;token punctuation&quot;&gt;.Clock
   lastSyncResourceVersion &lt;span class=&quot;token builtin&quot;&gt;string
   lastSyncResourceVersionMutex sync&lt;span class=&quot;token punctuation&quot;&gt;.RWMutex
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;reflector.go&lt;/code&gt;中主要就 Reflector 这个 struct 和相关的一些函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://farmer-hutao.github.io/k8s-source-code-analysis/around/client-go/image/informer/1556075898739.png&quot; alt=&quot;1556075898739&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ListAndWatch&quot;&gt;3.2. ListAndWatch&lt;/h3&gt;
&lt;p&gt;ListAndWatch 首先 list 所有 items，获取当前的资源版本信息，然后使用这个版本信息来 watch(也就是从这个版本开始的所有资源变化会被关注)。我们看一下这里的 ListAndWatch 方法主要逻辑：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/reflector.go:168&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token punctuation&quot;&gt;(r &lt;span class=&quot;token operator&quot;&gt;*Reflector&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token function&quot;&gt;ListAndWatch&lt;span class=&quot;token punctuation&quot;&gt;(stopCh &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;span class=&quot;token keyword&quot;&gt;chan &lt;span class=&quot;token keyword&quot;&gt;struct&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token builtin&quot;&gt;error &lt;span class=&quot;token punctuation&quot;&gt;{
   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;watchHandler_-_add_obj_to_delta_fifo&quot;&gt;4. watchHandler - add obj to delta fifo&lt;/h2&gt;
&lt;p&gt;前面讲到 ListAndWatch 函数的最后一步逻辑是 watchHandler，在 ListAndWatch 中先是更新了 Delta FIFO 中的 item，然后 watch 资源对象，最后交给 watchHandler 处理，所以 watchHandler 基本可以猜到是将有变化的资源添加到 Delta FIFO 中了。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/reflector.go:287&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token punctuation&quot;&gt;(r &lt;span class=&quot;token operator&quot;&gt;*Reflector&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token function&quot;&gt;watchHandler&lt;span class=&quot;token punctuation&quot;&gt;(w watch&lt;span class=&quot;token punctuation&quot;&gt;.Interface&lt;span class=&quot;token punctuation&quot;&gt;, resourceVersion &lt;span class=&quot;token operator&quot;&gt;*&lt;span class=&quot;token builtin&quot;&gt;string&lt;span class=&quot;token punctuation&quot;&gt;, errc &lt;span class=&quot;token keyword&quot;&gt;chan &lt;span class=&quot;token builtin&quot;&gt;error&lt;span class=&quot;token punctuation&quot;&gt;, stopCh &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;span class=&quot;token keyword&quot;&gt;chan &lt;span class=&quot;token keyword&quot;&gt;struct&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token builtin&quot;&gt;error &lt;span class=&quot;token punctuation&quot;&gt;{
   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;Informer_(controller)_-_pop_obj_from_delta_fifo&quot;&gt;5. Informer (controller) - pop obj from delta fifo&lt;/h2&gt;
&lt;h3 id=&quot;Controller&quot;&gt;5.1. Controller&lt;/h3&gt;
&lt;p&gt;一个 Informer 需要实现 Controller 接口：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/controller.go:82&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;type Controller &lt;span class=&quot;token keyword&quot;&gt;interface &lt;span class=&quot;token punctuation&quot;&gt;{
   &lt;span class=&quot;token function&quot;&gt;Run&lt;span class=&quot;token punctuation&quot;&gt;(stopCh &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;span class=&quot;token keyword&quot;&gt;chan &lt;span class=&quot;token keyword&quot;&gt;struct&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;)
   &lt;span class=&quot;token function&quot;&gt;HasSynced&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token builtin&quot;&gt;bool
   &lt;span class=&quot;token function&quot;&gt;LastSyncResourceVersion&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token builtin&quot;&gt;string
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;一个基础的 Controller 实现如下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/controller.go:75&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;type controller &lt;span class=&quot;token keyword&quot;&gt;struct &lt;span class=&quot;token punctuation&quot;&gt;{
   config         Config
   reflector      &lt;span class=&quot;token operator&quot;&gt;*Reflector
   reflectorMutex sync&lt;span class=&quot;token punctuation&quot;&gt;.RWMutex
   clock          clock&lt;span class=&quot;token punctuation&quot;&gt;.Clock
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;controller 类型结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://farmer-hutao.github.io/k8s-source-code-analysis/around/client-go/image/informer/1556088003902.png&quot; alt=&quot;1556088003902&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到主要对外暴露的逻辑是 Run() 方法，我们看一下 Run() 中的逻辑：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/controller.go:100&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token punctuation&quot;&gt;(c &lt;span class=&quot;token operator&quot;&gt;*controller&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token function&quot;&gt;Run&lt;span class=&quot;token punctuation&quot;&gt;(stopCh &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;span class=&quot;token keyword&quot;&gt;chan &lt;span class=&quot;token keyword&quot;&gt;struct&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
   &lt;span class=&quot;token keyword&quot;&gt;defer utilruntime&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;HandleCrash&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
   &lt;span class=&quot;token keyword&quot;&gt;go &lt;span class=&quot;token keyword&quot;&gt;func&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
      &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-stopCh
      c&lt;span class=&quot;token punctuation&quot;&gt;.config&lt;span class=&quot;token punctuation&quot;&gt;.Queue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;Close&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;processLoop&quot;&gt;5.2. processLoop&lt;/h3&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/controller.go:148&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token punctuation&quot;&gt;(c &lt;span class=&quot;token operator&quot;&gt;*controller&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token function&quot;&gt;processLoop&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
   &lt;span class=&quot;token keyword&quot;&gt;for &lt;span class=&quot;token punctuation&quot;&gt;{
       &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 Queue 就是 Delta FIFO，Pop 是个阻塞方法，内部实现时会逐个 pop 队列中的数据，交给 PopProcessFunc 处理。我们先不看 Pop 的实现，关注一下 PopProcessFunc 是如何处理 Pop 中从队列拿出来的 item 的。&lt;/p&gt;
&lt;p&gt;PopProcessFunc 是一个类型：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;type PopProcessFunc func(interface{}) error&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以这里只是一个类型转换，我们关注&lt;code&gt;c.config.Process&lt;/code&gt;就行：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/controller.go:367&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;Process&lt;span class=&quot;token punctuation&quot;&gt;: &lt;span class=&quot;token keyword&quot;&gt;func&lt;span class=&quot;token punctuation&quot;&gt;(obj &lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token builtin&quot;&gt;error &lt;span class=&quot;token punctuation&quot;&gt;{
    &lt;span class=&quot;token keyword&quot;&gt;for &lt;span class=&quot;token boolean&quot;&gt;_&lt;span class=&quot;token punctuation&quot;&gt;, d &lt;span class=&quot;token operator&quot;&gt;:= &lt;span class=&quot;token keyword&quot;&gt;range obj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token punctuation&quot;&gt;(Deltas&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
        &lt;span class=&quot;token keyword&quot;&gt;switch d&lt;span class=&quot;token punctuation&quot;&gt;.Type &lt;span class=&quot;token punctuation&quot;&gt;{
            &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;这里涉及到2个点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;clientState&lt;/li&gt;
&lt;li&gt;ResourceEventHandler (h)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们一一来看&lt;/p&gt;
&lt;h2 id=&quot;Add_obj_to_Indexer_(Thread_safe_store)&quot;&gt;6. Add obj to Indexer (Thread safe store)&lt;/h2&gt;
&lt;p&gt;前面说到 clientState，这个变量的初始化是&lt;code&gt;clientState := NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;NewIndexer 代码如下：&lt;/p&gt;
&lt;div&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/store.go:239&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token function&quot;&gt;NewIndexer&lt;span class=&quot;token punctuation&quot;&gt;(keyFunc KeyFunc&lt;span class=&quot;token punctuation&quot;&gt;, indexers Indexers&lt;span class=&quot;token punctuation&quot;&gt;) Indexer &lt;span class=&quot;token punctuation&quot;&gt;{
   &lt;span class=&quot;token keyword&quot;&gt;return &lt;span class=&quot;token operator&quot;&gt;&amp;amp;cache&lt;span class=&quot;token punctuation&quot;&gt;{
      cacheStorage&lt;span class=&quot;token punctuation&quot;&gt;: &lt;span class=&quot;token function&quot;&gt;NewThreadSafeStore&lt;span class=&quot;token punctuation&quot;&gt;(indexers&lt;span class=&quot;token punctuation&quot;&gt;, Indices&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;,
      keyFunc&lt;span class=&quot;token punctuation&quot;&gt;:      keyFunc&lt;span class=&quot;token punctuation&quot;&gt;,
   &lt;span class=&quot;token punctuation&quot;&gt;}
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;div&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/index.go:27&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;type Indexer &lt;span class=&quot;token keyword&quot;&gt;interface &lt;span class=&quot;token punctuation&quot;&gt;{
   Store
   &lt;span class=&quot;token function&quot;&gt;Index&lt;span class=&quot;token punctuation&quot;&gt;(indexName &lt;span class=&quot;token builtin&quot;&gt;string&lt;span class=&quot;token punctuation&quot;&gt;, obj &lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token punctuation&quot;&gt;]&lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token builtin&quot;&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)
   &lt;span class=&quot;token function&quot;&gt;IndexKeys&lt;span class=&quot;token punctuation&quot;&gt;(indexName&lt;span class=&quot;token punctuation&quot;&gt;, indexKey &lt;span class=&quot;token builtin&quot;&gt;string&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token punctuation&quot;&gt;]&lt;span class=&quot;token builtin&quot;&gt;string&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token builtin&quot;&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)
   &lt;span class=&quot;token function&quot;&gt;ListIndexFuncValues&lt;span class=&quot;token punctuation&quot;&gt;(indexName &lt;span class=&quot;token builtin&quot;&gt;string&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token punctuation&quot;&gt;]&lt;span class=&quot;token builtin&quot;&gt;string
   &lt;span class=&quot;token function&quot;&gt;ByIndex&lt;span class=&quot;token punctuation&quot;&gt;(indexName&lt;span class=&quot;token punctuation&quot;&gt;, indexKey &lt;span class=&quot;token builtin&quot;&gt;string&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token punctuation&quot;&gt;]&lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token builtin&quot;&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)
   &lt;span class=&quot;token function&quot;&gt;GetIndexers&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) Indexers
   &lt;span class=&quot;token function&quot;&gt;AddIndexers&lt;span class=&quot;token punctuation&quot;&gt;(newIndexers Indexers&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token builtin&quot;&gt;error
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;顺带看一下 NewThreadSafeStore()&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/thread_safe_store.go:298&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token function&quot;&gt;NewThreadSafeStore&lt;span class=&quot;token punctuation&quot;&gt;(indexers Indexers&lt;span class=&quot;token punctuation&quot;&gt;, indices Indices&lt;span class=&quot;token punctuation&quot;&gt;) ThreadSafeStore &lt;span class=&quot;token punctuation&quot;&gt;{
   &lt;span class=&quot;token keyword&quot;&gt;return &lt;span class=&quot;token operator&quot;&gt;&amp;amp;threadSafeMap&lt;span class=&quot;token punctuation&quot;&gt;{
      items&lt;span class=&quot;token punctuation&quot;&gt;:    &lt;span class=&quot;token keyword&quot;&gt;map&lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token builtin&quot;&gt;string&lt;span class=&quot;token punctuation&quot;&gt;]&lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;,
      indexers&lt;span class=&quot;token punctuation&quot;&gt;: indexers&lt;span class=&quot;token punctuation&quot;&gt;,
      indices&lt;span class=&quot;token punctuation&quot;&gt;:  indices&lt;span class=&quot;token punctuation&quot;&gt;,
   &lt;span class=&quot;token punctuation&quot;&gt;}
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;然后关注一下 Process 中的&lt;code&gt;err := clientState.Add(d.Object)&lt;/code&gt;的 Add() 方法：&lt;/p&gt;
&lt;div&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/store.go:123&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token punctuation&quot;&gt;(c &lt;span class=&quot;token operator&quot;&gt;*cache&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token function&quot;&gt;Add&lt;span class=&quot;token punctuation&quot;&gt;(obj &lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token builtin&quot;&gt;error &lt;span class=&quot;token punctuation&quot;&gt;{
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;cacheStorage 是一个 ThreadSafeStore 实例，这个 Add() 代码如下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/thread_safe_store.go:68&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token punctuation&quot;&gt;(c &lt;span class=&quot;token operator&quot;&gt;*threadSafeMap&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token function&quot;&gt;Add&lt;span class=&quot;token punctuation&quot;&gt;(key &lt;span class=&quot;token builtin&quot;&gt;string&lt;span class=&quot;token punctuation&quot;&gt;, obj &lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
   c&lt;span class=&quot;token punctuation&quot;&gt;.lock&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;Lock&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
   &lt;span class=&quot;token keyword&quot;&gt;defer c&lt;span class=&quot;token punctuation&quot;&gt;.lock&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;Unlock&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;第四步和第五步的内容先分析到这里，后面关注 threadSafeMap 实现的时候再继续深入。&lt;/p&gt;
&lt;h2 id=&quot;sharedIndexInformer&quot;&gt;7. sharedIndexInformer&lt;/h2&gt;
&lt;p&gt;第六步是 Dispatch Event Handler functions(Send Object to Custom Controller)&lt;/p&gt;
&lt;p&gt;我们先看一个接口 SharedInformer：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/shared_informer.go:43&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;type SharedInformer &lt;span class=&quot;token keyword&quot;&gt;interface &lt;span class=&quot;token punctuation&quot;&gt;{
   &lt;span class=&quot;token function&quot;&gt;AddEventHandler&lt;span class=&quot;token punctuation&quot;&gt;(handler ResourceEventHandler&lt;span class=&quot;token punctuation&quot;&gt;)
   &lt;span class=&quot;token function&quot;&gt;AddEventHandlerWithResyncPeriod&lt;span class=&quot;token punctuation&quot;&gt;(handler ResourceEventHandler&lt;span class=&quot;token punctuation&quot;&gt;, resyncPeriod time&lt;span class=&quot;token punctuation&quot;&gt;.Duration&lt;span class=&quot;token punctuation&quot;&gt;)
   &lt;span class=&quot;token function&quot;&gt;GetStore&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) Store
   &lt;span class=&quot;token function&quot;&gt;GetController&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) Controller
   &lt;span class=&quot;token function&quot;&gt;Run&lt;span class=&quot;token punctuation&quot;&gt;(stopCh &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;span class=&quot;token keyword&quot;&gt;chan &lt;span class=&quot;token keyword&quot;&gt;struct&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;)
   &lt;span class=&quot;token function&quot;&gt;HasSynced&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token builtin&quot;&gt;bool
   &lt;span class=&quot;token function&quot;&gt;LastSyncResourceVersion&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token builtin&quot;&gt;string
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;SharedInformer 有一个共享的 data cache，能够分发 changes 通知到缓存，到通过 AddEventHandler 注册了的 listerners. 当你接收到一个通知，缓存的内容能够保证至少和通知中的一样新。&lt;/p&gt;
&lt;p&gt;再看一下 SharedIndexInformer 接口：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/shared_informer.go:66&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;type SharedIndexInformer &lt;span class=&quot;token keyword&quot;&gt;interface &lt;span class=&quot;token punctuation&quot;&gt;{
   SharedInformer
   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;相比 SharedInformer 增加了一个 Indexer. 然后看具体的实现 sharedIndexInformer 吧：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/shared_informer.go:127&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;type sharedIndexInformer &lt;span class=&quot;token keyword&quot;&gt;struct &lt;span class=&quot;token punctuation&quot;&gt;{
   indexer    Indexer
   controller Controller
   processor             &lt;span class=&quot;token operator&quot;&gt;*sharedProcessor
   cacheMutationDetector CacheMutationDetector
   listerWatcher ListerWatcher

   objectType    runtime&lt;span class=&quot;token punctuation&quot;&gt;.Object
   resyncCheckPeriod time&lt;span class=&quot;token punctuation&quot;&gt;.Duration
   defaultEventHandlerResyncPeriod time&lt;span class=&quot;token punctuation&quot;&gt;.Duration
   clock clock&lt;span class=&quot;token punctuation&quot;&gt;.Clock
   started&lt;span class=&quot;token punctuation&quot;&gt;, stopped &lt;span class=&quot;token builtin&quot;&gt;bool
   startedLock      sync&lt;span class=&quot;token punctuation&quot;&gt;.Mutex
   blockDeltas sync&lt;span class=&quot;token punctuation&quot;&gt;.Mutex
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;这个类型内包了很多我们前面看到过的对象，indexer、controller、listeratcher 都不陌生，我们看这里的 processor 是做什么的：&lt;/p&gt;
&lt;h3 id=&quot;sharedProcessor&quot;&gt;7.1. sharedProcessor&lt;/h3&gt;
&lt;p&gt;类型定义如下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/shared_informer.go:375&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;type sharedProcessor &lt;span class=&quot;token keyword&quot;&gt;struct &lt;span class=&quot;token punctuation&quot;&gt;{
   listenersStarted &lt;span class=&quot;token builtin&quot;&gt;bool
   listenersLock    sync&lt;span class=&quot;token punctuation&quot;&gt;.RWMutex
   listeners        &lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token punctuation&quot;&gt;]&lt;span class=&quot;token operator&quot;&gt;*processorListener
   syncingListeners &lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token punctuation&quot;&gt;]&lt;span class=&quot;token operator&quot;&gt;*processorListener
   clock            clock&lt;span class=&quot;token punctuation&quot;&gt;.Clock
   wg               wait&lt;span class=&quot;token punctuation&quot;&gt;.Group
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;这里的重点明显是 listeners 属性了，我们继续看 listeners 的类型中的 processorListener：&lt;/p&gt;
&lt;h4 id=&quot;processorListener&quot;&gt;7.1.1. processorListener&lt;/h4&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/shared_informer.go:466&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;type processorListener &lt;span class=&quot;token keyword&quot;&gt;struct &lt;span class=&quot;token punctuation&quot;&gt;{
   nextCh &lt;span class=&quot;token keyword&quot;&gt;chan &lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}
   addCh  &lt;span class=&quot;token keyword&quot;&gt;chan &lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}

   handler ResourceEventHandler
   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;processorListener 主要有2个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;run()&lt;/li&gt;
&lt;li&gt;pop()&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;processorListener_run()&quot;&gt;7.1.2. processorListener.run()&lt;/h4&gt;
&lt;p&gt;先看一下这个 run 做了什么：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/shared_informer.go:540&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token punctuation&quot;&gt;(p &lt;span class=&quot;token operator&quot;&gt;*processorListener&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token function&quot;&gt;run&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
   stopCh &lt;span class=&quot;token operator&quot;&gt;:= &lt;span class=&quot;token function&quot;&gt;make&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token keyword&quot;&gt;chan &lt;span class=&quot;token keyword&quot;&gt;struct&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;)
    wait&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;Until&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token keyword&quot;&gt;func&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{ &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;这个 run 过程不复杂，等待信号然后调用 handler 的增删改方法做对应的处理逻辑。case 里的 Notification 再看一眼：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/shared_informer.go:176&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;type updateNotification &lt;span class=&quot;token keyword&quot;&gt;struct &lt;span class=&quot;token punctuation&quot;&gt;{
   oldObj &lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}
   newObj &lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;span class=&quot;token punctuation&quot;&gt;}

&lt;span class=&quot;token keyword&quot;&gt;type addNotification &lt;span class=&quot;token keyword&quot;&gt;struct &lt;span class=&quot;token punctuation&quot;&gt;{
   newObj &lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;span class=&quot;token punctuation&quot;&gt;}

&lt;span class=&quot;token keyword&quot;&gt;type deleteNotification &lt;span class=&quot;token keyword&quot;&gt;struct &lt;span class=&quot;token punctuation&quot;&gt;{
   oldObj &lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;另外注意到&lt;code&gt;for next := range p.nextCh&lt;/code&gt;是下面的 case 执行的前提，也就是说触发点是 p.nextCh，我们接着看 pop 过程(这里的逻辑不简单，可能得多花点精力)&lt;/p&gt;
&lt;h4 id=&quot;processorListener_pop()&quot;&gt;7.1.3. processorListener.pop()&lt;/h4&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/shared_informer.go:510&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token punctuation&quot;&gt;(p &lt;span class=&quot;token operator&quot;&gt;*processorListener&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token function&quot;&gt;pop&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
   &lt;span class=&quot;token keyword&quot;&gt;defer utilruntime&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;HandleCrash&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
   &lt;span class=&quot;token keyword&quot;&gt;defer &lt;span class=&quot;token function&quot;&gt;close&lt;span class=&quot;token punctuation&quot;&gt;(p&lt;span class=&quot;token punctuation&quot;&gt;.nextCh&lt;span class=&quot;token punctuation&quot;&gt;) &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 pop 逻辑的入口是&lt;code&gt;&amp;lt;-p.addCh&lt;/code&gt;，我们继续向上找一下这个 addCh 的来源：&lt;/p&gt;
&lt;h4 id=&quot;processorListener_add()&quot;&gt;7.1.4. processorListener.add()&lt;/h4&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/shared_informer.go:506&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token punctuation&quot;&gt;(p &lt;span class=&quot;token operator&quot;&gt;*processorListener&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token function&quot;&gt;add&lt;span class=&quot;token punctuation&quot;&gt;(notification &lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
   p&lt;span class=&quot;token punctuation&quot;&gt;.addCh &lt;span class=&quot;token operator&quot;&gt;&amp;lt;- notification
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;这个 add() 方法又在哪里被调用呢？&lt;/p&gt;
&lt;h4 id=&quot;sharedProcessor_distribute()&quot;&gt;7.1.5. sharedProcessor.distribute()&lt;/h4&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/shared_informer.go:400&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token punctuation&quot;&gt;(p &lt;span class=&quot;token operator&quot;&gt;*sharedProcessor&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token function&quot;&gt;distribute&lt;span class=&quot;token punctuation&quot;&gt;(obj &lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;, sync &lt;span class=&quot;token builtin&quot;&gt;bool&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
   p&lt;span class=&quot;token punctuation&quot;&gt;.listenersLock&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;RLock&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
   &lt;span class=&quot;token keyword&quot;&gt;defer p&lt;span class=&quot;token punctuation&quot;&gt;.listenersLock&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;RUnlock&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)

   &lt;span class=&quot;token keyword&quot;&gt;if sync &lt;span class=&quot;token punctuation&quot;&gt;{
      &lt;span class=&quot;token keyword&quot;&gt;for &lt;span class=&quot;token boolean&quot;&gt;_&lt;span class=&quot;token punctuation&quot;&gt;, listener &lt;span class=&quot;token operator&quot;&gt;:= &lt;span class=&quot;token keyword&quot;&gt;range p&lt;span class=&quot;token punctuation&quot;&gt;.syncingListeners &lt;span class=&quot;token punctuation&quot;&gt;{
         listener&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;add&lt;span class=&quot;token punctuation&quot;&gt;(obj&lt;span class=&quot;token punctuation&quot;&gt;)
      &lt;span class=&quot;token punctuation&quot;&gt;}
   &lt;span class=&quot;token punctuation&quot;&gt;} &lt;span class=&quot;token keyword&quot;&gt;else &lt;span class=&quot;token punctuation&quot;&gt;{
      &lt;span class=&quot;token keyword&quot;&gt;for &lt;span class=&quot;token boolean&quot;&gt;_&lt;span class=&quot;token punctuation&quot;&gt;, listener &lt;span class=&quot;token operator&quot;&gt;:= &lt;span class=&quot;token keyword&quot;&gt;range p&lt;span class=&quot;token punctuation&quot;&gt;.listeners &lt;span class=&quot;token punctuation&quot;&gt;{
         listener&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;add&lt;span class=&quot;token punctuation&quot;&gt;(obj&lt;span class=&quot;token punctuation&quot;&gt;)
      &lt;span class=&quot;token punctuation&quot;&gt;}
   &lt;span class=&quot;token punctuation&quot;&gt;}
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法逻辑比较简洁，分发对象。我们继续看哪里进入的 distribute：&lt;/p&gt;
&lt;h3 id=&quot;sharedIndexInformer_HandleDeltas()&quot;&gt;7.2. sharedIndexInformer.HandleDeltas()&lt;/h3&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/shared_informer.go:344&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token punctuation&quot;&gt;(s &lt;span class=&quot;token operator&quot;&gt;*sharedIndexInformer&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token function&quot;&gt;HandleDeltas&lt;span class=&quot;token punctuation&quot;&gt;(obj &lt;span class=&quot;token keyword&quot;&gt;interface&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token builtin&quot;&gt;error &lt;span class=&quot;token punctuation&quot;&gt;{
   s&lt;span class=&quot;token punctuation&quot;&gt;.blockDeltas&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;Lock&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
   &lt;span class=&quot;token keyword&quot;&gt;defer s&lt;span class=&quot;token punctuation&quot;&gt;.blockDeltas&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;Unlock&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)

   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;继续往前看代码逻辑。&lt;/p&gt;
&lt;h3 id=&quot;sharedIndexInformer_Run()&quot;&gt;7.3. sharedIndexInformer.Run()&lt;/h3&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/shared_informer.go:189&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token punctuation&quot;&gt;(s &lt;span class=&quot;token operator&quot;&gt;*sharedIndexInformer&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token function&quot;&gt;Run&lt;span class=&quot;token punctuation&quot;&gt;(stopCh &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;span class=&quot;token keyword&quot;&gt;chan &lt;span class=&quot;token keyword&quot;&gt;struct&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
   &lt;span class=&quot;token keyword&quot;&gt;defer utilruntime&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;HandleCrash&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里已经挺和谐了，在 sharedIndexInformer 的 Run() 方法中先是创建一个 DeltaFIFO，然后和 lw 一起初始化 cfg，利用 cfg 创建 controller，最后 Run 这个 controller，也就是最基础的 informer.&lt;/p&gt;
&lt;p&gt;在这段代码里我们还注意到有一步是&lt;code&gt;s.processor.run&lt;/code&gt;，我们看一下这个 run 的逻辑。&lt;/p&gt;
&lt;h4 id=&quot;sharedProcessor_run()&quot;&gt;7.3.1. sharedProcessor.run()&lt;/h4&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;tools/cache/shared_informer.go:415&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token punctuation&quot;&gt;(p &lt;span class=&quot;token operator&quot;&gt;*sharedProcessor&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token function&quot;&gt;run&lt;span class=&quot;token punctuation&quot;&gt;(stopCh &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;span class=&quot;token keyword&quot;&gt;chan &lt;span class=&quot;token keyword&quot;&gt;struct&lt;span class=&quot;token punctuation&quot;&gt;{&lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
   &lt;span class=&quot;token keyword&quot;&gt;func&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
      p&lt;span class=&quot;token punctuation&quot;&gt;.listenersLock&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;RLock&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
      &lt;span class=&quot;token keyword&quot;&gt;defer p&lt;span class=&quot;token punctuation&quot;&gt;.listenersLock&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;RUnlock&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
      &lt;span class=&quot;token keyword&quot;&gt;for &lt;span class=&quot;token boolean&quot;&gt;_&lt;span class=&quot;token punctuation&quot;&gt;, listener &lt;span class=&quot;token operator&quot;&gt;:= &lt;span class=&quot;token keyword&quot;&gt;range p&lt;span class=&quot;token punctuation&quot;&gt;.listeners &lt;span class=&quot;token punctuation&quot;&gt;{
          &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;撇开细节，可以看到这里调用了内部所有 listener 的 run() 和 pop() 方法，和前面的分析呼应上了。&lt;/p&gt;
&lt;p&gt;到这里，我们基本讲完了自定义 controller 的时候 client-go 里相关的逻辑，也就是图中的上半部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://farmer-hutao.github.io/k8s-source-code-analysis/around/client-go/image/informer/1556161315850.png&quot; alt=&quot;1556161315850&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998740/201904/998740-20190425223300381-1441529605.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Apr 2019 14:33:00 +0000</pubDate>
<dc:creator>CloudGeek</dc:creator>
<og:description>Custom Controller 之 Informer 概述 架构概览 reflector - List &amp; Watch API Server Reflector 对象 ListAndWat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloudgeek/p/10771567.html</dc:identifier>
</item>
<item>
<title>mySql入门-（一） - Aaron-攻城狮</title>
<link>http://www.cnblogs.com/aaron---blog/p/10771471.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aaron---blog/p/10771471.html</guid>
<description>&lt;p&gt;学了很多乱七杂八的东西，但是依然停留在前端，在工作中一直和后端交流，但是不太了解数据库是怎么回事，为了加强学习，准备学习一些关于数据库相关的东西。&lt;/p&gt;
&lt;p&gt;说起数据库可能会有很多很多，&lt;code&gt;SQLServer&lt;/code&gt;、&lt;code&gt;Oracle&lt;/code&gt;、&lt;code&gt;Sybase&lt;/code&gt;等等等，还有就是要学习&lt;code&gt;MySql&lt;/code&gt;，说了这么多数据库这些都是&lt;code&gt;关系型数据库&lt;/code&gt;。既然有&lt;code&gt;关系型数据库&lt;/code&gt;自然也就会有&lt;code&gt;非关系型数据&lt;/code&gt;，比如&lt;code&gt;Neo4j&lt;/code&gt;、&lt;code&gt;MongodDB&lt;/code&gt;、&lt;code&gt;Cloudant&lt;/code&gt;等等等这些也就都属于&lt;code&gt;非关系型&lt;/code&gt;数据库,&lt;code&gt;非关系型数据库&lt;/code&gt;又被称为&lt;code&gt;nosql&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;非关系型数据库与关系型数据库对比&quot;&gt;非关系型数据库与关系型数据库对比&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;非关系型数据库&quot;&gt;# 非关系型数据库&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;p&gt;性能&lt;code&gt;NOSQL&lt;/code&gt;是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过&lt;code&gt;SQL&lt;/code&gt;层的解析，所以性能非常高。可扩展性同样shouce也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优势&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;nosql&lt;/code&gt;数据库简单易部署，基本都是开源软件，不需要像使用&lt;code&gt;oracle&lt;/code&gt;那样花费大量成本购买使用，相比关系型数据库价格便宜。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nosql&lt;/code&gt;数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及&lt;code&gt;nosql&lt;/code&gt;数据库。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nosql&lt;/code&gt;的存储格式是&lt;code&gt;key&lt;/code&gt;,&lt;code&gt;value&lt;/code&gt;形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持&lt;code&gt;基础类型&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;劣势&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;维护的工具和资料有限，因为&lt;code&gt;nosql&lt;/code&gt;是属于新的技术，不能和关系型数据库10几年的技术同日而语。&lt;/li&gt;
&lt;li&gt;不提供对&lt;code&gt;sql&lt;/code&gt;的支持，如果不支持&lt;code&gt;sql&lt;/code&gt;这样的工业标准，将产生一定用户的学习和使用成本。&lt;/li&gt;
&lt;li&gt;不提供关系型数据库对事物的处理。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;h5 id=&quot;关系型数据库&quot;&gt;# 关系型数据库&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;p&gt;关系型数据库对于复杂查询可以用&lt;code&gt;SQL&lt;/code&gt;语句方便的在一个表以及多个表之间做非常复杂的数据查询。事务支持使得对于安全性能很高的数据访问要求得以实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优势&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;保持数据的一致性（事务处理）&lt;/li&gt;
&lt;li&gt;由于以标准化为前提，数据更新的开销很小（相同的字段基本上都只有一处）&lt;/li&gt;
&lt;li&gt;可以进行Join等复杂查询&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;劣势&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;大量数据的写入处理&lt;/li&gt;
&lt;li&gt;为有数据更新的表做索引或表结构（schema）变更&lt;/li&gt;
&lt;li&gt;字段不固定时应用&lt;/li&gt;
&lt;li&gt;对简单查询需要快速返回结果的处理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于这两类数据库，对方的优势就是自己的弱势，反过来也是如此。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;mysql安装&quot;&gt;MySql安装&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;Windows&lt;/code&gt;上安装&lt;code&gt;Mysql&lt;/code&gt;还是比较简单的，去&lt;code&gt;Mysql&lt;/code&gt;&lt;a href=&quot;https://www.mysql.com/&quot;&gt;官网&lt;/a&gt;去现在&lt;code&gt;zip&lt;/code&gt;包就好了。下载完包之后把包解压到想要存放的存储盘内。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Mysql&lt;/code&gt;有提供安装版本，下载好之后安装就能使用了，如果下载&lt;code&gt;zip&lt;/code&gt;包解压后需要进行配置，比较麻烦，网上也有很多教程。&lt;/p&gt;
&lt;p&gt;然后打开刚刚解压的文件夹，在文件夹下面有一个&lt;code&gt;my.ini&lt;/code&gt;配置文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MySql&lt;/code&gt;的配置与我们平时学习的语言不太一样，&lt;code&gt;MySql&lt;/code&gt;在配置过程中有两点需要注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置中的&lt;code&gt;-&lt;/code&gt;与&lt;code&gt;_&lt;/code&gt;是等价的&lt;/li&gt;
&lt;li&gt;分段配置[******]隔离段&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8
 
[mysqld]
# 设置3306端口
port = 3306

# 设置mysql的安装目录
basedir=C:\\web\\mysql-8.0.11
# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错
# datadir=C:\\web\\sqldata

# 允许最大连接数
max_connections=20

# 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8

# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据以上内容更改配置就好了，并添加环境变量。这里安装就不详细介绍了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;mysql服务管理&quot;&gt;MySql服务管理&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;MySQL&lt;/code&gt;在服务中提供了一些对&lt;code&gt;MySQL&lt;/code&gt;管理的一些命令工具。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设置管理员密码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;./bin/mysqladmin -u root password &quot;root123&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mysqladmin&lt;/code&gt;是执行很多关于&lt;code&gt;MySQL&lt;/code&gt;的一些管理的工作，同样也是在命令行里面去执行的。执行上面的命令，就会为&lt;code&gt;root&lt;/code&gt;用户创建一个密码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;启动服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;./bin/mysqld_safe &amp;amp;
# ./bin/mysqld &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动服务的时候是使用&lt;code&gt;mysqld_safe&lt;/code&gt;这个命令的，实际上&lt;code&gt;mysqld_safe&lt;/code&gt;是一个脚本，他会管理&lt;code&gt;mysqld&lt;/code&gt;进程进行管理，一旦&lt;code&gt;mysqld&lt;/code&gt;因为异常导致程序崩溃的话&lt;code&gt;mysqld_safe&lt;/code&gt;会重启一下&lt;code&gt;MySQL&lt;/code&gt;服务。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;停止服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;./bin/mysqladmin shutdown
# kill -9 $mysqld_pid   //  重启服务
# kill $mysqld_pid&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;kill $mysqld_pid&lt;/code&gt;命名会停止mysql服务，包括&lt;code&gt;mysqld_safe&lt;/code&gt;也会停止。&lt;/p&gt;
&lt;p&gt;还有很多关于&lt;code&gt;MySql&lt;/code&gt;服务管理的命令，这里就不一一赘述了，单独出一篇文章对其进一步介绍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;mysql可视化工具&quot;&gt;MySql可视化工具&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装完数据库之后需要安装可视化工具，方便查看数据库内容，以及方便创建数据库和删除数据数据库等操作。&lt;/p&gt;
&lt;p&gt;想要可视化&lt;code&gt;MySQL&lt;/code&gt;需要借助&lt;code&gt;Nacicat&lt;/code&gt;，网上有很多破解版可以随便下载一个。&lt;a href=&quot;http://www.navicat.com.cn/manual/online_manual/cn/navicat/win_manual/index.html&quot;&gt;Nacicat使用手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下载安装好之后可以与数据库做连接，使用方法也很简单。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;mysql语法规范&quot;&gt;MySql语法规范&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;MySql&lt;/code&gt;数据库属于关联型数据库，需要使用&lt;code&gt;Sql&lt;/code&gt;语句对表数据进行查询。一个数据库通常包含一个或多个表。每个表由一个名字标识。表包含带有数据的记录（行）。&lt;code&gt;Sql&lt;/code&gt;语句对大小写不敏感，但是还是建议所有的&lt;code&gt;Sql&lt;/code&gt;语句使用大写，查询条件与表名用小写，这样方便区分哪些是&lt;code&gt;Sql&lt;/code&gt;语句哪些是查询条件。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;MySql&lt;/code&gt;系统要求在每条 SQL 命令的末端使用分号。分号是在数据库系统中分隔每条&lt;code&gt;Sql&lt;/code&gt;语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的语句。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;mysql数据类型&quot;&gt;MySql数据类型&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;数值类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整数型&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;TINYINT&lt;/td&gt;
&lt;td&gt;1 字节&lt;/td&gt;
&lt;td&gt;(-128，127)&lt;/td&gt;
&lt;td&gt;(0，255)&lt;/td&gt;
&lt;td&gt;小整数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td&gt;2 字节&lt;/td&gt;
&lt;td&gt;(-32 768，32 767)&lt;/td&gt;
&lt;td&gt;(0，65 535)&lt;/td&gt;
&lt;td&gt;大整数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;td&gt;3 字节&lt;/td&gt;
&lt;td&gt;(-8 388 608，8 388 607)&lt;/td&gt;
&lt;td&gt;(0，16 777 215)&lt;/td&gt;
&lt;td&gt;大整数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;INT或INTEGER&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;(-2 147 483 648，2 147 483 647)&lt;/td&gt;
&lt;td&gt;(0，4 294 967 295)&lt;/td&gt;
&lt;td&gt;大整数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;10&quot;&gt;&lt;td&gt;BIGINT&lt;/td&gt;
&lt;td&gt;8 字节&lt;/td&gt;
&lt;td&gt;(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)&lt;/td&gt;
&lt;td&gt;(0，18 446 744 073 709 551 615)&lt;/td&gt;
&lt;td&gt;极大整数值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;浮点型&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;FLOAT&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)&lt;/td&gt;
&lt;td&gt;0，(1.175 494 351 E-38，3.402 823 466 E+38)&lt;/td&gt;
&lt;td&gt;单精度，浮点数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;DOUBLE&lt;/td&gt;
&lt;td&gt;8 字节&lt;/td&gt;
&lt;td&gt;(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)&lt;/td&gt;
&lt;td&gt;0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)&lt;/td&gt;
&lt;td&gt;双精度，浮点数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;DECIMAL&lt;/td&gt;
&lt;td&gt;对DECIMAL(M,D) ，如果M&amp;gt;D，为M+2否则为D+2&lt;/td&gt;
&lt;td&gt;依赖于M和D的值&lt;/td&gt;
&lt;td&gt;依赖于M和D的值&lt;/td&gt;
&lt;td&gt;小数值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;设一个字段定义为 float(5,3)，如果插入一个数 123.45678,实际数据库里存的是 123.457，但总个数还以实际为准，即 6 位。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;日期和时间类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注：每个时间类型有一个有效值范围和一个&quot;零&quot;值，当指定不合法的MySQL不能表示的值时使用&quot;零&quot;值。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;DATE&lt;/td&gt;
&lt;td&gt;3 字节&lt;/td&gt;
&lt;td&gt;1000-01-01/9999-12-31&lt;/td&gt;
&lt;td&gt;YYYY-MM-DD&lt;/td&gt;
&lt;td&gt;日期值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt;3 字节&lt;/td&gt;
&lt;td&gt;'-838:59:59'/'838:59:59'&lt;/td&gt;
&lt;td&gt;HH:MM:SS&lt;/td&gt;
&lt;td&gt;时间值或持续时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;YEAR&lt;/td&gt;
&lt;td&gt;1 字节&lt;/td&gt;
&lt;td&gt;1901/2155&lt;/td&gt;
&lt;td&gt;YYYY-MM-DD HH:MM:SS&lt;/td&gt;
&lt;td&gt;混合日期和时间值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;DATETIME&lt;/td&gt;
&lt;td&gt;8 字节&lt;/td&gt;
&lt;td&gt;1000-01-01 00:00:00/9999-12-31 23:59:59&lt;/td&gt;
&lt;td&gt;YYYY-MM-DD HH:MM:SS&lt;/td&gt;
&lt;td&gt;混合日期和时间值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;TIMESTAMP&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;1970-01-01 00:00:00/2038 结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07&lt;/td&gt;
&lt;td&gt;YYYYMMDD HHMMSS&lt;/td&gt;
&lt;td&gt;混合日期和时间值，时间戳&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;字符串类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;CHAR&lt;/td&gt;
&lt;td&gt;0-255字节&lt;/td&gt;
&lt;td&gt;定长字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;VARCHAR&lt;/td&gt;
&lt;td&gt;0-65535 字节&lt;/td&gt;
&lt;td&gt;变长字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;TINYBLOB&lt;/td&gt;
&lt;td&gt;0-255字节&lt;/td&gt;
&lt;td&gt;不超过 255 个字符的二进制字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;TINYTEXT&lt;/td&gt;
&lt;td&gt;0-255字节&lt;/td&gt;
&lt;td&gt;短文本字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;BLOB&lt;/td&gt;
&lt;td&gt;0-65 535字节&lt;/td&gt;
&lt;td&gt;二进制形式的长文本数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;TEXT&lt;/td&gt;
&lt;td&gt;0-65 535字节&lt;/td&gt;
&lt;td&gt;长文本数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;MEDIUMBLOB&lt;/td&gt;
&lt;td&gt;0-16 777 215字节&lt;/td&gt;
&lt;td&gt;二进制形式的中等长度文本数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;MEDIUMTEXT&lt;/td&gt;
&lt;td&gt;0-16 777 215字节&lt;/td&gt;
&lt;td&gt;中等长度文本数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LONGBLOB&lt;/td&gt;
&lt;td&gt;0-4 294 967 295字节&lt;/td&gt;
&lt;td&gt;二进制形式的极大文本数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;LONGTEXT&lt;/td&gt;
&lt;td&gt;0-4 294 967 295字节&lt;/td&gt;
&lt;td&gt;极大文本数据&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;char和varchar：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以 char 类型存储的字符串末尾不能有空格，varchar 不限于此。&lt;/li&gt;
&lt;li&gt;char(n) 固定长度，char(4) 不管是存入几个字符，都将占用 4 个字节，varchar 是存入的实际字符数 +1 个字节（n&amp;lt;=255）或2个字节(n&amp;gt;255)，所以 varchar(4),存入 3 个字符将占用 4 个字节。&lt;/li&gt;
&lt;li&gt;char 类型的字符串检索速度要比 varchar 类型的快。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;varchar 和 text：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;varchar 可指定 n，text 不能指定，内部存储 varchar 是存入的实际字符数 +1 个字节（n&amp;lt;=255）或 2 个字节(n&amp;gt;255)，text 是实际字符数 +2 个字节。&lt;/li&gt;
&lt;li&gt;text 类型不能有默认值。&lt;/li&gt;
&lt;li&gt;varchar 可直接创建索引，text 创建索引要指定前多少个字符。varchar 查询速度快于 text, 在都创建索引的情况下，text 的索引似乎不起作用。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;MySql&lt;/code&gt;数据关联型数据库，使用&lt;code&gt;Sql&lt;/code&gt;语句对数据库进行操作。&lt;code&gt;Sql&lt;/code&gt;语句不区分大小写，无论是关联型数据库还是非关联型数据库都各有优缺点。&lt;/p&gt;
&lt;p&gt;在使用&lt;code&gt;MySql&lt;/code&gt;创建表时，需要多注意数据格式，会给数据库查询带来一些性能的提升。&lt;/p&gt;
&lt;p&gt;注：数据库中如果使用大量索引，虽然查询很快，但是会造成写入过慢的情况，使用的时候要稍加慎重。&lt;/p&gt;
</description>
<pubDate>Thu, 25 Apr 2019 14:19:00 +0000</pubDate>
<dc:creator>Aaron-攻城狮</dc:creator>
<og:description>学了很多乱七杂八的东西，但是依然停留在前端，在工作中一直和后端交流，但是不太了解数据库是怎么回事，为了加强学习，准备学习一些关于数据库相关的东西。 说起数据库可能会有很多很多， 、`Oracle Sy</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aaron---blog/p/10771471.html</dc:identifier>
</item>
<item>
<title>Android Gradle基于参数化配置实现差异化构建 - HappyCorn</title>
<link>http://www.cnblogs.com/lwbqqyumidi/p/10771289.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwbqqyumidi/p/10771289.html</guid>
<description>&lt;p&gt;一、背景：&lt;br/&gt;项目中有一些特殊的需求，如个别渠道继承腾讯bugly，个别渠道集成易观统计，不同的渠道集成不同的推送策略（如Oppo渠道优先Opush推送），不同的渠道拥有不同的第三方登录集成等等。这些需求本身，往往都与外部集成进来的功能有关，且需求上，功能与渠道本身，有一定的映射关系，对于此类需求，具体项目构建时可以有如下几种策略:&lt;br/&gt;1，不同的分支管理，以对应不同的差异化实现；&lt;br/&gt;2，通过变体，实现不同的差异化构建；&lt;br/&gt;3，通过Android Gradle参数化配置，实现差异化构建。&lt;/p&gt;
&lt;p&gt;二、方案利弊分析：&lt;br/&gt;1，基于不同的分支管理，差异部分的代码直接在特殊分支中，每次需要与主分支进行合并并解决可能的合并冲突。同时，针对特殊的渠道逻辑，如果代码通过分支隔离，往往开发个体都是基于主分支开发，渠道的差异性逻辑处理部分容易忽略，有时候造成不必要的bug等情形，维护成本较大。&lt;/p&gt;
&lt;p&gt;2，基于变体的差异化构建，直接使用Gradle变体方案，优势在于变体目录及对应的构建流程已经自动包含。对应的，不太优雅的地方在于此类需求一旦繁杂，变体的种类及对应的目录层次相对增多，变体类型会随着产品风味的增加而成倍数增长，在具体构建时，构建任务也会相对繁杂，且对应在build等目录下的输出的目录层次也相对复杂。&lt;/p&gt;
&lt;p&gt;3，基于Gradle的参数化配置，依据具体的需求详情，主动配置并处理对应的差异化构建逻辑，如渠道的映射关系，不同的外部依赖，以及对应的代码占位等，以此在保持原有变体不变和构建任务不变的情况下，只需通过参数化的配置，即可完成对应的差异化部分构建。&lt;/p&gt;
&lt;p&gt;本文主要讨论“通过参数化配置实现差异化构建”实现方案。 下面通过个别渠道集成bugly和易观统计详细讨论具体的实现过程。&lt;/p&gt;
&lt;p&gt;三，实例&lt;br/&gt;1，个别渠道的bugly集成 主工程如果要集成bugly，相对非常简单，主要包括&lt;code&gt;build.gradle&lt;/code&gt;中引入bugly依赖，适当位置（如&lt;code&gt;Application&lt;/code&gt;中）初始化bugly，&lt;code&gt;proguard.cfg&lt;/code&gt;中进行bugly的混淆配置。但本例中，bugly集成不是针主工程本身，而是针对特定的渠道。具体的参数化配置实现差异化构建过程如下：&lt;br/&gt;a，项目主工程中新建&lt;code&gt;ext.gradle&lt;/code&gt;文件，实现对渠道的逻辑映射：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;ext.gradle
--------------------------
ext {
    channel = project.hasProperty(&lt;span class=&quot;hljs-string&quot;&gt;'channel') ? channel : &lt;span class=&quot;hljs-string&quot;&gt;'feature'

    addBugly = {
        def buglyChannelList = [&lt;span class=&quot;hljs-string&quot;&gt;&quot;huawei&quot;]
        def result = buglyChannelList.contains(channel)
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;gt;&amp;gt;&amp;gt; channel:&lt;span class=&quot;hljs-variable&quot;&gt;${channel},  bugly added:&lt;span class=&quot;hljs-variable&quot;&gt;${result}&quot;

        &lt;span class=&quot;hljs-keyword&quot;&gt;if(result) {
            &lt;span class=&quot;hljs-built_in&quot;&gt;return &lt;span class=&quot;hljs-literal&quot;&gt;true
        }
        &lt;span class=&quot;hljs-built_in&quot;&gt;return &lt;span class=&quot;hljs-literal&quot;&gt;false
    }

}

android {
    &lt;span class=&quot;hljs-built_in&quot;&gt;sourceSets {
        main{
            java {
                &lt;span class=&quot;hljs-keyword&quot;&gt;if(addBugly()) {
                    srcDirs &lt;span class=&quot;hljs-string&quot;&gt;&quot;src/ext/bugly/java&quot;
                } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
                    srcDirs &lt;span class=&quot;hljs-string&quot;&gt;&quot;src/mock/bugly/java&quot;
                }
            }
        }
    }
}


dependencies {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if (addBugly()) {
        api &lt;span class=&quot;hljs-string&quot;&gt;'com.tencent.bugly:crashreport:latest.release'
        api &lt;span class=&quot;hljs-string&quot;&gt;'com.tencent.bugly:nativecrashreport:latest.release'
    }
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的逻辑映射包括：&lt;br/&gt;1.1，渠道值(&lt;code&gt;channel&lt;/code&gt;)的接收和逻辑判断&lt;code&gt;addBugly&lt;/code&gt;；&lt;br/&gt;1.2，对应逻辑确认下(&lt;code&gt;addBugly&lt;/code&gt;)的bugly依赖引入；&lt;br/&gt;1.3，对应逻辑确认下的源集指定。&lt;/p&gt;
&lt;p&gt;b，项目主工程中引入&lt;code&gt;ext.gradle&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;apply from: &lt;span class=&quot;hljs-string&quot;&gt;'../ext.gradle'
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;c，项目对应模块中，处理对应的源集逻辑(base模块为例)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;base/src/main/java/com/mycorn  ---默认工程源码
base/src/ext/bugly/com/mycorn  ---bugly逻辑确认下的额外源集源码目录
base/src/mock/bugly/com/mycorn ---通常情况下的额外源集源码目录

base/src/ext/bugly/com/mycorn
---------------------------------
package com.mycorn;

import android.app.Application;
import android.util.Log;

public class BuglyHelper {
    public static final String TAG = &lt;span class=&quot;hljs-string&quot;&gt;&quot;BuglyHelper&quot;;

    public static void initBugly(Application context) {
        Log.d(TAG, &lt;span class=&quot;hljs-string&quot;&gt;&quot;bugly init...&quot;;
        // 初始化腾讯bugly  第三个参数表示是否处于调试模式
        com.tencent.bugly.crashreport.CrashReport.initCrashReport(context, &lt;span class=&quot;hljs-string&quot;&gt;&quot;bbccdd123456&quot;, &lt;span class=&quot;hljs-literal&quot;&gt;false);
    }
}


base/src/mock/bugly/com/mycorn
---------------------------------
package com.mymoney;

import android.app.Application;
import android.util.Log;

public class BuglyHelper {
    public static final String TAG = &lt;span class=&quot;hljs-string&quot;&gt;&quot;BuglyHelper&quot;;

    public static void initBugly(Application context) {
        Log.d(TAG, &lt;span class=&quot;hljs-string&quot;&gt;&quot;bugly init...mock&quot;);
        // 实际上是空方法，主要是用于占位
    }
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;d，项目主工程下，在对应初始化bugly的地方直接写上通用性的bugly初始化占位逻辑&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;    ....
    ....
    com.mymoney.BuglyHelper.initBugly(context);
    ....
    ....
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;e,&lt;code&gt;proguard.cfg&lt;/code&gt;配置项，由于只是进行代码混淆的配置，此处可以直接放到对应模块的&lt;code&gt;proguard.cfg&lt;/code&gt;文件中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;    ....
    ....
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，基于参数化配置实现腾讯bugly引入的差异化构建，得以完成。&lt;/p&gt;
&lt;p&gt;其中关键点，在于对应的“占位”逻辑的处理。&lt;/p&gt;
&lt;p&gt;2，个别渠道的易观统计集成 总体上与上述的腾讯bugly集成类似，特别之处在于易观统计的接入项目中是直接引入的&lt;code&gt;jar&lt;/code&gt;文件，并在对应的&lt;code&gt;AndroidManifest.xml&lt;/code&gt;文件中配置了不少的如&lt;code&gt;&amp;lt;service&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;receiver&amp;gt;&lt;/code&gt;及其他元数据等配置项。&lt;br/&gt;Android Gradle项目构建时，对于同一模块，可以通过&lt;code&gt;sourceSets&lt;/code&gt;增加如源码及资源目录等，但却不能增加&lt;code&gt;AndroidManifest&lt;/code&gt;文件，形如&lt;code&gt;manifest.srcFile&lt;/code&gt;的写法当前只能是对&lt;code&gt;AndroidManifest&lt;/code&gt;文件的重新设定。但如果是独立模块，或已经是独立的外部&lt;code&gt;aar&lt;/code&gt;等依赖引入，&lt;code&gt;Android Gradle&lt;/code&gt;构建时会自动实现对应的&lt;code&gt;AndroidManifest&lt;/code&gt;文件合并。因此，为了能够将易观统计中的&lt;code&gt;AndroidManifest&lt;/code&gt;配置项进行单独隔离，需要在上例中的基础上将易观统计单独隔离成独立模块，或对应的&lt;code&gt;aar&lt;/code&gt;文件等（本例在于阐述具体解法，对于最新的易观统计如果已经支持依赖引入，则不在讨论范围内）。&lt;/p&gt;
&lt;p&gt;a，将易观形成独立模块，&lt;code&gt;AndroidManifest&lt;/code&gt;，&lt;code&gt;libs&lt;/code&gt;目录下的&lt;code&gt;jar&lt;/code&gt;包，&lt;code&gt;proguard.cfg&lt;/code&gt;文件等，实现独自配置；&lt;/p&gt;
&lt;p&gt;b，参照上例bugly的集成，处理对应的易观逻辑关系&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;ext {
    channel = project.hasProperty(&lt;span class=&quot;hljs-string&quot;&gt;'channel') ? channel : &lt;span class=&quot;hljs-string&quot;&gt;'feature'
    addBugly = {
        def buglyChannelList = [&lt;span class=&quot;hljs-string&quot;&gt;&quot;huawei&quot;]
        def result = buglyChannelList.contains(channel)
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;gt;&amp;gt;&amp;gt; channel:&lt;span class=&quot;hljs-variable&quot;&gt;${channel},  bugly added:&lt;span class=&quot;hljs-variable&quot;&gt;${result}&quot;

        &lt;span class=&quot;hljs-keyword&quot;&gt;if(result) {
            &lt;span class=&quot;hljs-built_in&quot;&gt;return &lt;span class=&quot;hljs-literal&quot;&gt;true
        }
        &lt;span class=&quot;hljs-built_in&quot;&gt;return &lt;span class=&quot;hljs-literal&quot;&gt;false
    }

    addEguan = {
        def eguanChannelList = [&lt;span class=&quot;hljs-string&quot;&gt;&quot;baidu&quot;]
        def result = eguanChannelList.contains(channel)
        println &lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;gt;&amp;gt;&amp;gt; channel:&lt;span class=&quot;hljs-variable&quot;&gt;${channel},  eguan added:&lt;span class=&quot;hljs-variable&quot;&gt;${result}&quot;

        &lt;span class=&quot;hljs-keyword&quot;&gt;if(result) {
            &lt;span class=&quot;hljs-built_in&quot;&gt;return &lt;span class=&quot;hljs-literal&quot;&gt;true
        }
        &lt;span class=&quot;hljs-built_in&quot;&gt;return &lt;span class=&quot;hljs-literal&quot;&gt;false
    }
}

android {
    &lt;span class=&quot;hljs-built_in&quot;&gt;sourceSets {
        main{
            java {
                &lt;span class=&quot;hljs-keyword&quot;&gt;if (addBugly()) {
                    srcDirs &lt;span class=&quot;hljs-string&quot;&gt;&quot;src/ext/bugly/java&quot;
                } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
                    srcDirs &lt;span class=&quot;hljs-string&quot;&gt;&quot;src/mock/bugly/java&quot;
                }

                &lt;span class=&quot;hljs-keyword&quot;&gt;if (addEguan()) {
                    srcDirs &lt;span class=&quot;hljs-string&quot;&gt;&quot;src/ext/eguan/java&quot;
                } &lt;span class=&quot;hljs-keyword&quot;&gt;else {
                    srcDirs &lt;span class=&quot;hljs-string&quot;&gt;&quot;src/mock/eguan/java&quot;
                }
            }
        }
    }
}


dependencies {
    &lt;span class=&quot;hljs-keyword&quot;&gt;if (addBugly()) {
        api &lt;span class=&quot;hljs-string&quot;&gt;'com.tencent.bugly:crashreport:latest.release'
        api &lt;span class=&quot;hljs-string&quot;&gt;'com.tencent.bugly:nativecrashreport:latest.release'
    }

    &lt;span class=&quot;hljs-keyword&quot;&gt;if (addEguan()) {
        api project(&lt;span class=&quot;hljs-string&quot;&gt;':eguan')
    }
}
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;c，同样的对应的目录下形成易观的源集逻辑，并在需要初始化的地方，改成通用的逻辑占位写法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;base/src/ext/eguan/com/mycorn
---------------------------------
package com.mycorn;

import android.content.Context;
import android.util.Log;

import com.eguan.monitor.EguanMonitorAgent;

public class EguanHelper {
    public static final String TAG = &lt;span class=&quot;hljs-string&quot;&gt;&quot;EguanHelper&quot;;

    public static void initEguan(Context context) {
        Log.d(TAG, &lt;span class=&quot;hljs-string&quot;&gt;&quot;eguan init...&quot;);
        try {
            EguanMonitorAgent.getInstance().initEguan(context, &lt;span class=&quot;hljs-string&quot;&gt;&quot;4909454903452702a&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;feidee&quot;);
        } catch (Exception e) {
            Log.d(TAG, &lt;span class=&quot;hljs-string&quot;&gt;&quot;eguan init exception...&quot;);
        }
    }
}


base/src/mock/eguan/com/mycorn
---------------------------------
package com.mycorn;

import android.content.Context;
import android.util.Log;

public class EguanHelper {
    public static final String TAG = &lt;span class=&quot;hljs-string&quot;&gt;&quot;EguanHelper&quot;;

    public static void initEguan(Context context) {
        Log.d(TAG, &lt;span class=&quot;hljs-string&quot;&gt;&quot;eguan init...mock&quot;);
        // 实际上是空方法，主要是用于占位
    }
}


&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;....
....
EguanHelper.initEguan(this);
....
....
&lt;span class=&quot;copy-code-btn&quot;&gt;复制代码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，完成基于参数化配置，实现特定渠道下的易观集成的差异化构建。&lt;/p&gt;
&lt;p&gt;四，结语&lt;br/&gt;基于参数化配置实现差异化构建，需要依据实际的需求背景，分析具体的差异部分，以考虑简便易行，同时兼顾易维护性为主，实现具体的配置过程。&lt;/p&gt;
</description>
<pubDate>Thu, 25 Apr 2019 13:56:00 +0000</pubDate>
<dc:creator>HappyCorn</dc:creator>
<og:description>一、背景： 项目中有一些特殊的需求，如个别渠道继承腾讯bugly，个别渠道集成易观统计，不同的渠道集成不同的推送策略（如Oppo渠道优先Opush推送），不同的渠道拥有不同的第三方登录集成等等。这些需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwbqqyumidi/p/10771289.html</dc:identifier>
</item>
<item>
<title>Detours HOOK 库 过滤LoadLibraryExW - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/10771002.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/10771002.html</guid>
<description>&lt;h2 id=&quot;一丶简介&quot;&gt;一丶简介&lt;/h2&gt;
&lt;h3 id=&quot;detours库简介&quot;&gt;1.1 Detours库简介&lt;/h3&gt;
&lt;p&gt;Detours是微软提供的HOOK库.为我们Hook提供了方便.再也不用手撸 HOOK了.当然手撸比较好.可以锻炼.不过工作中要求效率.所以使用这个库.&lt;br/&gt;这个库很强大.对于初学者来说也很简单.&lt;/p&gt;
&lt;h3 id=&quot;使用detours需要注意的问题&quot;&gt;1.2 使用Detours需要注意的问题&lt;/h3&gt;
&lt;p&gt;为什么说我们需要注意.很多博客也有说.但是往往都不太注意.比如我.一开始使用这个Hook库的时候各种崩溃.最后调试一下.发现了问题.&lt;br/&gt;所以这里列举出来&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;如果HOOK API 一定要注意调用约定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如我们如果HOOK一个API.一定要注意它的调用约定.否则最后平栈的时候返回地址不对.就会引发错误.当时我就犯了这个错误.不过调试之后解决了.&lt;/p&gt;
&lt;p&gt;比如你HOOK 自定义函数.的时候,如果是自己写的.没加调用约定的时候,那么就是C调用约定&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; &lt;strong&gt;不要使用typedef 重新定义函数指针&lt;/strong&gt;&lt;br/&gt;为什么说不要使用.也不是不要使用.主要是当时比较急.解决棘手问题.&lt;br/&gt;用了typedef. 导致函数地址不一样就出错了.所以能使用但是你需要了解一下.因为我工作原因.并没有深究.&lt;/p&gt;
&lt;h2 id=&quot;二丶使用detours的步骤&quot;&gt;二丶使用Detours的步骤&lt;/h2&gt;
&lt;h3 id=&quot;下载detours.以及使用&quot;&gt;2.1下载Detours.以及使用&lt;/h3&gt;
&lt;p&gt;说到使用,我们必须要下载Detours.当然我会上传.你可以去CSDN下载.或者自己下载源码编译.我下了好多.也编译好了.会上传.直接下载即可.&lt;br/&gt;首先使用Detours.&lt;br/&gt;Detours有两个头文件.我们都包含即可.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;detours.h&quot;
#include &quot;detver.h&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还需要一个lib库.我们放在VS工程中即可.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#pragma comment(lib,&quot;Detours.lib&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用detours步骤很简单.都是固定api&quot;&gt;2.2使用Detours步骤很简单.都是固定API&lt;/h3&gt;
&lt;p&gt;如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
void DetoursHook()
{
    DetourRestoreAfterWith();
    DetourTransactionBegin();           
    DetourUpdateThread(GetCurrentThread());
    DetourAttach(&amp;amp;(LPVOID&amp;amp;)PFnLoadLibraryExW, MyLoadLibraryExw);
    DetourTransactionCommit();

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总共五步&lt;br/&gt;1.AfterWith()避免重复HOOK&lt;br/&gt;2.TransactionBegin();开始HOOK&lt;br/&gt;3.UpdateThread();更新到当前线程&lt;br/&gt;4.DetourAttch();你要HOOK的函数的函数的地址,以及你自定义的函数的函数地址.&lt;br/&gt;5.TransactionCommit();提交HOOK 这一步才是最终进行HOOK.&lt;/p&gt;
&lt;p&gt;看一下第4步,DetourAttch();&lt;br/&gt;这一个函数指针我们需要定义为下面这样.比如&lt;br/&gt;&lt;strong&gt;LoadLibraryExW&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static HMODULE(WINAPI *PFnLoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE  hFile, DWORD   dwFlags) = (HMODULE(WINAPI *)(LPCWSTR, HANDLE, DWORD))DetourFindFunction(&quot;KernelBase.dll&quot;, &quot;LoadLibraryExW&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前边是&lt;strong&gt;LoadLibraryExW&lt;/strong&gt;的函数指针定义. 后面的 = 是对他进行赋值.不过需要强转.&lt;br/&gt;&lt;strong&gt;DetourFindFunction&lt;/strong&gt;函数就是寻找函数地址.给一个模块名,给一个函数名他就去找.然后找到就返回.不过你需要强转进行赋值即可.&lt;/p&gt;
&lt;p&gt;我们上面说了,既然要进行绑定.那么需要提供一个我们自己的函数才可以.&lt;br/&gt;自己定义的函数如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HMODULE  WINAPI MyLoadLibraryExw(LPCWSTR lpLibFileName, HANDLE  hFile, DWORD   dwFlags)
{
     
    
    
     
    if( wcscmp(lpLibFileName,TEXT(&quot;XXX) == 0)
    {
      return NULL; //return NULL的意思就是loadlibrary直接返回NULL就是没有加载,这一步就相当于拦截了.
    }
    return PFnLoadLibraryExW(lpLibFileName, hFile, dwFlags); //调用原函数,就是不做处理
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hook-自定义-函数&quot;&gt;2.2 HOOK 自定义 函数&lt;/h3&gt;
&lt;p&gt;上面说我们使用DetourFindFunction寻找API,其实我们HOOK自己的我们也可以写一个跟它一样的函数. 原理就是返回一个地址.&lt;br/&gt;你知道你的函数地址在哪你都可以写成如下;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static HMODULE(WINAPI *PFnLoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE  hFile, DWORD   dwFlags) = (HMODULE(WINAPI *)(LPCWSTR, HANDLE, DWORD))0x40001200
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设你的函数地址是0x40001200,那么Detours就会去HOOK这个地方.&lt;/p&gt;
&lt;h2 id=&quot;unhook&quot;&gt;3.UnHOOK&lt;/h2&gt;
&lt;p&gt;有了HOOK,那么自然有UnHOOK(卸载HOOK).也很简单.不一一说了.直接贴完整代码.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
#include &quot;detours.h&quot;
#include &quot;detver.h&quot;
#include &amp;lt;winnt.h&amp;gt;




using namespace std;
#pragma comment(lib,&quot;Detours.lib&quot;)







static HMODULE(WINAPI *PFnLoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE  hFile, DWORD   dwFlags) = (HMODULE(WINAPI *)(LPCWSTR, HANDLE, DWORD))DetourFindFunction(&quot;KernelBase.dll&quot;, &quot;LoadLibraryExW&quot;);

void DetoursUnHook();
void DetoursHook();



 HMODULE  WINAPI MyLoadLibraryExw(LPCWSTR lpLibFileName, HANDLE  hFile, DWORD   dwFlags)
{
     
    
    
     
    return PFnLoadLibraryExW(lpLibFileName, hFile, dwFlags);
    
}

void DetoursHook()
{
    DetourRestoreAfterWith();
    DetourTransactionBegin();           //开始
    DetourUpdateThread(GetCurrentThread());//初始化当前线程
    DetourAttach(&amp;amp;(LPVOID&amp;amp;)PFnLoadLibraryExW, MyLoadLibraryExw);//进行附加

    DetourTransactionCommit();//进行HOOK  

}

void DetoursUnHook()
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourDetach((void **)&amp;amp;PFnLoadLibraryExW, MyLoadLibraryExw);//撤销拦截函数
    DetourDetach(&amp;amp;(LPVOID&amp;amp;)PfnFreeLibrary, NewFreeLibrary);
    DetourTransactionCommit();//
    

}


BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{

    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        
        
        DisableThreadLibraryCalls(hModule);
        DetoursHook();
        
        break;
    case DLL_THREAD_ATTACH:
        
        break;
    case DLL_THREAD_DETACH:
        //DetoursUnHook();
        break;
    case DLL_PROCESS_DETACH:
        //DeleteCriticalSection(&amp;amp;testCS);
        //DetoursUnHook();
        break;
    }
    return TRUE;
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HOOK 库打包下载链接:&lt;br/&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1zhXqPfPhZdSWsipDuWVVQg&quot; class=&quot;uri&quot;&gt;https://pan.baidu.com/s/1zhXqPfPhZdSWsipDuWVVQg&lt;/a&gt;&lt;br/&gt;提取码：tcg5&lt;/p&gt;
</description>
<pubDate>Thu, 25 Apr 2019 13:09:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>Detours HOOK 库 Hook 过滤LoadLibraryExW 一丶简介 1.1 Detours库简介 Detours是微软提供的HOOK库.为我们Hook提供了方便.再也不用手撸 HOOK</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/10771002.html</dc:identifier>
</item>
</channel>
</rss>