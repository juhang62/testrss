<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java面试基础篇-List - 沉梦昂志~</title>
<link>http://www.cnblogs.com/mmmmyblog/p/12635683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mmmmyblog/p/12635683.html</guid>
<description>&lt;p&gt;&lt;span&gt;一.ArrayList:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　底层为数组实现,线程不安全,查询,修改快,增加删除慢,&lt;/p&gt;
&lt;p&gt;数据结构:数组以0为下标依次连续进行存储&lt;/p&gt;
&lt;p&gt;　　数组查询元素：根据下标查询就行&lt;/p&gt;
&lt;p&gt;　　数组增加元素：如果需要给index为10的位置添加，则从index为11的位置开始右移&lt;/p&gt;
&lt;p&gt;       数组删除元素：如果需要删除index为10的位置，则从index为11的位置开始左移&lt;/p&gt;
&lt;p&gt;线程: 如果判断线程安不安全只需要了解到是否进行加锁,如果没有加锁的话,多个线程操作同一个对象时就会出现线程不安全的情况.&lt;/p&gt;
&lt;p&gt;源码:&lt;/p&gt;
&lt;p&gt;1.new一个arraylist,调用add方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200404215205623-836812300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.查看add方法的源码可以看出,并没有任何加锁操作,这就是线程不安全的 ,这里首先会确认数组的容量,对其进行增加,并将新的元素加入到数组中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200404215350207-10813490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 使用场景:查询 修改多&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二.LikedList:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　底层为链表实现,线程不安全,查询修改慢,增加删除快&lt;/p&gt;
&lt;p&gt;数据结构:链表的每个元素都存储了下一个元素的地址，从而使一系列的随机的内存地址串在了一起，只要有足够的内存空间，就可以为链表分配内存&lt;/p&gt;
&lt;p&gt;　　链表查：当同时读取所有元素时，链表的效率很高，读第一个，读第二个，以此类推。如果需要找到某个节点时,就需要遍历整个节点,才可以找到需要的元素&lt;/p&gt;
&lt;p&gt;　　链表增加元素：只需要修改它前面的那个元素指针指向的地址即可&lt;/p&gt;
&lt;p&gt;　　链表删除元素:只需要将前一个元素指针指向的地址更改即可&lt;/p&gt;
&lt;p&gt;线程: 如果判断线程安不安全只需要了解到是否进行加锁,如果没有加锁的话,多个线程操作同一个对象时就会出现线程不安全的情况.&lt;/p&gt;
&lt;p&gt;源码:&lt;/p&gt;
&lt;p&gt;1.new一个likedlist&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200404223252526-1589517329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.可以看到likedlist源码中也无任何的加锁操作,其中add又调用了linklast&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200404225554461-119286105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.linklast里会吧新加元素设置为尾节点，所以创建了一个新的Node(节点)存起来,然后再新建一个节点,把之前的node指向链表的最后一个节点,然后再判断一下l是否为空也就是之前的链表里是否为空,如果为空则吧新的节点设为头节点,否则就把next改为newnode,同时size和modcound自增&lt;/p&gt;
&lt;p&gt;同样的 也没看到任何加锁的操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200404225850003-1268888944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用场景:增加删除多&lt;/p&gt;


&lt;p&gt;&lt;span&gt;三,Vector &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　底层是数组实现，线程安全的，操作的时候使用synchronized进行加锁 &lt;/p&gt;
&lt;p&gt;　　因为是数组实现的,curd方面可以参考arraylist,由于是加锁的,所以比前两个list效率更低的&lt;/p&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;p&gt;1.new一个Vector,&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200404232747297-1791135913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2. 可以看到这个方法使用了 synchronized来进行修饰,对此方法进行加锁,因此这个方法对元素操作时是效率安全的,但效率相对较低,&lt;/p&gt;
&lt;p&gt;同样的首先确认元素,扩容+1,把新的元素放进去&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200404232946333-360990056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;&lt;span&gt;题外话.怎样来保证list的线程安全&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　方式一:自己写一个包装类,根据业务,一般在进行add/update/remove操作时加锁&lt;/p&gt;
&lt;p&gt;　　方式二:collections调用 synchronizedlist方法,&lt;/p&gt;
&lt;p&gt;源码:&lt;/p&gt;
&lt;p&gt;1.创建一个list,会返回一个线程安全的list给你&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200404235208960-1216453930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.可看到这个方法里首先是一个list集合,mutex是一个加锁的对象&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200404235645464-1867753966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.在继续打开synchronizedrandomaccesslist&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200405000552843-1406236202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4,打开super,这里可以看到这里返回了一个同步的synchronizedlist,同样也继承了一个list方法&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200405000727506-880857287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.在synchronizedlist里可以找到常用的一些方法,同样也是加锁的,所以这个就变成线程安全了&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200405001125694-260230498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　方式三:CopyOnWriteArrayList  &lt;/p&gt;
&lt;p&gt;源码:&lt;/p&gt;
&lt;p&gt;1.new CopyOnWriteArrayList   使用ReentrantLock加锁&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200405001551195-1969948100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. CopyOnWriteArrayList 在使用get操作时没有加锁的 这个与synchronizedlist对比来说性能要更好一点&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200405023120093-1983566940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3,在add方法时可以看到用了ReentrantLock来进行加锁,再用object数组获取老的数组,并将老的数组获取保存在len,&lt;/p&gt;
&lt;p&gt;下面再用Arrays.copyof进行拷贝,将老的数组拷贝到新的数组newElements,并将长度+1,+1的原因就是为了存放新的元素,&lt;/p&gt;
&lt;p&gt;目前内存里有两个空间,一个空间是新的空间,另一个是旧的空间&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200405023328194-476797791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1282595/202004/1282595-20200405024029845-541083079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;setarray是为了将新的拷贝到旧的里,也就是改变了他的引用地址&lt;/p&gt;
&lt;p&gt;最终unlock,把锁释放&lt;/p&gt;










</description>
<pubDate>Sun, 05 Apr 2020 00:17:00 +0000</pubDate>
<dc:creator>沉梦昂志~</dc:creator>
<og:description>一.ArrayList: 底层为数组实现,线程不安全,查询,修改快,增加删除慢, 数据结构:数组以0为下标依次连续进行存储 数组查询元素：根据下标查询就行 数组增加元素：如果需要给index为10的位</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mmmmyblog/p/12635683.html</dc:identifier>
</item>
<item>
<title>【Redis】入门 - WilsonPan</title>
<link>http://www.cnblogs.com/WilsonPan/p/12635605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WilsonPan/p/12635605.html</guid>
<description>&lt;p&gt;Redis是一个开源的、基于内存的数据结构存储器，可以用作数据库、缓存和消息中间件 Redis最常用的功能 缓存 分布式锁&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;85.205585725368&quot;&gt;

&lt;p id=&quot;redisOverView&quot; class=&quot;ws-title&quot;&gt;Redis概述&lt;/p&gt;
&lt;div class=&quot;ws-content&quot; readability=&quot;37.238307349666&quot;&gt;
&lt;p&gt; Redis是一个开源的、基于内存的数据结构存储器，可以用作数据库、缓存和消息中间件&lt;/p&gt;
&lt;p&gt;Redis最常用的功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;分布式锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 本文介绍使用环境&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;Windows 10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis 3.0.504&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;6.3823529411765&quot;&gt;如何安装Redis就不做介绍，若不想安装Redis环境，可以使用&lt;a href=&quot;http://try.redis.io/&quot; target=&quot;_blank&quot;&gt;try redis&lt;/a&gt;尝试Redis功能&lt;/div&gt;
&lt;p&gt;CMD 启动 Redis，打开Reids目录，执行下面命令，出现下面图片代表启动成功&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-server redis.windows.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/413875/202004/413875-20200405014350671-1641948860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;p id=&quot;redisDataStructure&quot; class=&quot;ws-title&quot;&gt;Redis常用数据结构&lt;/p&gt;
&lt;div class=&quot;ws-content&quot;&gt;
&lt;p&gt;&lt;strong&gt;字符串(String)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用途&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;存放字符串/数字&lt;/li&gt;
&lt;li&gt;常规key-value缓存应用&lt;/li&gt;
&lt;li&gt;常规计数：订单数，商品数&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;常用命令&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;set key value&lt;/td&gt;
&lt;td&gt;设置指定 key 的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;get key&lt;/td&gt;
&lt;td&gt;获取指定key的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;decr key&lt;/td&gt;
&lt;td&gt;将指定的key的值递减1，若设置的值不是数字，报错&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;incr key&lt;/td&gt;
&lt;td&gt;将指定的key的值递增1，若设置的值不是数字，报错&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;mget key1 [key2]&lt;/td&gt;
&lt;td&gt;获取指定的key，返回多个值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/413875/202004/413875-20200405014847368-620618320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;哈希(Hash)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用途&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;hash 特别适合用于存储对象(用户信息，商品信息)&lt;/li&gt;
&lt;li&gt;可以修改/读取对象某个值&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;常用命令&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td&gt;hset key field value&lt;/td&gt;
&lt;td&gt;设置单个对象值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;hget key field value&lt;/td&gt;
&lt;td&gt;获取的那个对象值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;hmset key field1 value [field2 value2]&lt;/td&gt;
&lt;td&gt;设置对象多个字段值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;hmget&lt;/td&gt;
&lt;td&gt;获取对象多个值 , 返回列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;hgetall&lt;/td&gt;
&lt;td&gt;获取指定key对象字段和值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/413875/202004/413875-20200405015108024-1594640673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;列表(List)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用途&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;双向链表 ，支持反向查找和遍历&lt;/li&gt;
&lt;li&gt;可以添加重复数据&lt;/li&gt;
&lt;li&gt;适合存放消息列表，产品列表，订单列表等&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;常用命令&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr&gt;&lt;td&gt;lpush key value&lt;/td&gt;
&lt;td&gt;向链表左边推送值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;rpush key value&lt;/td&gt;
&lt;td&gt;向链表右边推送值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;lpop key&lt;/td&gt;
&lt;td&gt;链表的左边弹出值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;rpop key&lt;/td&gt;
&lt;td&gt;链表的右边弹出值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;lrange key start end&lt;/td&gt;
&lt;td&gt;链表左边指定范围内的元素 , 多用于分页&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;llen key&lt;/td&gt;
&lt;td&gt;获取链表长度&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/413875/202004/413875-20200405015443397-1442703298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;集合(Set)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用途&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;跟列表类似，集合会去重复&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;常用命令&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;sadd key value&lt;/td&gt;
&lt;td&gt;添加一个元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;spop key value&lt;/td&gt;
&lt;td&gt;随机返回一个元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;smembers key&lt;/td&gt;
&lt;td&gt;返回集合所有成员&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sunion key1 key2&lt;/td&gt;
&lt;td&gt;返回所有给定集合的并集&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/413875/202004/413875-20200405015535114-1192285148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有序集合(Sorted Set)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 用途&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;集合中的元素能够按score进行有序排列&lt;/li&gt;
&lt;li&gt;多用于排名数据&lt;/li&gt;
&lt;li&gt;score 相同情况下，按字典键值排序&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;常用命令&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;zadd key score1 member1 [score2 member2]&lt;/td&gt;
&lt;td&gt;向有序集合添加一个或多个成员，或者更新已存在成员的分数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;zrange key start end&lt;/td&gt;
&lt;td&gt;返回有序集合指定范围数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;zrem key member&lt;/td&gt;
&lt;td&gt;移除指定成员&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;zcard key&lt;/td&gt;
&lt;td&gt;获取集合成员数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/413875/202004/413875-20200405015636892-381228582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;/div&gt;
&lt;p id=&quot;redisDeletePolicy&quot; class=&quot;ws-title&quot;&gt;Redis删除过期数据策略&lt;/p&gt;
&lt;div class=&quot;ws-content&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;Redis删除过期数据有两种机制&lt;/p&gt;
&lt;p&gt;1. 定期删除 ：redis默认是每隔 100ms 就随机抽取过期的数据删除&lt;/p&gt;
&lt;p&gt;2. 惰性删除 ： 访问数据的时候检查数据是否过期&lt;/p&gt;

&lt;/div&gt;
&lt;p id=&quot;redisMaxMemoryPolicy&quot; class=&quot;ws-title&quot;&gt;Redis内存淘汰机制&lt;/p&gt;
&lt;div class=&quot;ws-content&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;当遇到写入数据的时候内存不够，Redis有下面几种机制来决定如何操作&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;volatile-lru&lt;/td&gt;
&lt;td&gt;从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;volatile-ttl&lt;/td&gt;
&lt;td&gt;从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;volatile-random&lt;/td&gt;
&lt;td&gt;从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;allkeys-lru&lt;/td&gt;
&lt;td&gt;当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;allkeys-random&lt;/td&gt;
&lt;td&gt;从数据集（server.db[i].dict）中任意选择数据淘汰&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;noeviction&lt;/td&gt;
&lt;td&gt;禁止删除，若超出内存报错&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;volatile-lfu&lt;/td&gt;
&lt;td&gt;从已设置过期时间的数据集挑选使用频率最低的数据淘汰（Redis5.0 以后才有）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;allkeys-lfu&lt;/td&gt;
&lt;td&gt;从数据集中挑选使用频率最低的数据淘汰（Redis5.0 以后才有）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在配置文件里面打开maxmemory-policy配置项，默认是：noeviction&lt;/p&gt;
&lt;p&gt;通常情况配合maxmemory配置设置最大内存使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/413875/202004/413875-20200405020921325-863226258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p id=&quot;redisPersistence&quot; class=&quot;ws-title&quot;&gt;Redis持久化机制&lt;/p&gt;
&lt;div class=&quot;ws-content&quot; readability=&quot;58&quot;&gt;
&lt;p&gt;Redis支持两种持久化方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快照（snapshotting）持久化（RDB）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本&lt;/li&gt;
&lt;li&gt;Redis默认采用的持久化方式&lt;/li&gt;
&lt;li&gt;配置多个save配置项指定触发创建副本条件，例：save 900 1 , 900秒内至少一个Key发生变化触发创建快照&lt;/li&gt;
&lt;li&gt;缺点：若没达到触发条件，数据容易丢失&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;AOF（append-only file）持久化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开启AOF持久化后，根据选择的方式写入AOF文件中&lt;/li&gt;
&lt;li&gt;配置appendfsync 配置项，配置同步频率&lt;/li&gt;
&lt;li&gt;缺点：可能经常发生同步，影响Redis的速度 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;AOF有3种方式&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;appendfsync always&lt;/td&gt;
&lt;td&gt;每次有数据修改发生时都会写入AOF文件 ，严重降低Redis的速度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;appendfsync everysec&lt;/td&gt;
&lt;td&gt;每秒钟同步一次，显示地将多个写命令同步到硬盘&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;appendfsync no&lt;/td&gt;
&lt;td&gt;让操作系统决定何时进行同步&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;144&quot;&gt;Redies默认AOF是关闭的，通过修改配置打开&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/413875/202004/413875-20200405021902029-157783512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Redis 4.0 对于持久化机制的优化&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;159&quot;&gt;Redis 4.0 开始支持 RDB 和 AOF 的混合持久化(默认关闭，可以通过配置项 aof-use-rdb-preamble 开启)。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;159&quot;&gt;如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;159&quot;&gt;这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;159&quot;&gt;当然缺点也是有的，AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;164&quot;&gt;由于Windows的版本最新只有3.0，这个就没法验证&lt;/p&gt;
&lt;/div&gt;
&lt;p id=&quot;redisCahceProblem&quot; class=&quot;ws-title&quot;&gt;缓存问题及解决方案&lt;/p&gt;
&lt;div class=&quot;ws-content&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;&lt;strong&gt;缓存雪崩&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;170&quot;&gt;同一时间大面积缓存失效，大量请求落到数据库上&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;172&quot;&gt;解决&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缓存穿透&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;177&quot;&gt;请求缓存不存在的数据，然请求穿透缓存到数据库，通常是黑客攻击&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;179&quot;&gt;解决&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤&lt;/li&gt;
&lt;li&gt;访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间&lt;/li&gt;
&lt;li&gt;采用签名验证提交数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缓存击穿&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;185&quot;&gt;缓存过期的一刻，同时有大量的请求，由于缓存失效，导致请求都落到DB&lt;/p&gt;
&lt;p class=&quot;line&quot; data-line=&quot;185&quot;&gt;解决&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单体使用互斥锁(mutex key)&lt;/li&gt;
&lt;li&gt;分布式使用setnx&lt;/li&gt;
&lt;li&gt;双重校验访问缓存数据（Double Check)，就是线程安全的单例模式&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;ws-copyright&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;转发请标明出处：https://www.cnblogs.com/WilsonPan/p/12635605.html&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ws-content&quot; readability=&quot;10.4&quot;&gt;
&lt;p&gt;参考文章&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;Command reference – Redis&quot; href=&quot;https://redis.io/commands&quot; target=&quot;_blank&quot;&gt;Command reference – Redis&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 04 Apr 2020 18:26:00 +0000</pubDate>
<dc:creator>WilsonPan</dc:creator>
<og:description>Redis是一个开源的、基于内存的数据结构存储器，可以用作数据库、缓存和消息中间件 Redis最常用的功能 缓存 分布式锁</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/WilsonPan/p/12635605.html</dc:identifier>
</item>
<item>
<title>Spring Framework之IoC容器 - 码头工人</title>
<link>http://www.cnblogs.com/boycelee/p/12635640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/boycelee/p/12635640.html</guid>
<description>&lt;h2 id=&quot;spring-ioc-概述&quot;&gt;Spring IoC 概述&lt;/h2&gt;
&lt;h3 id=&quot;问题&quot;&gt;问题&lt;/h3&gt;
&lt;p&gt;1.什么是依赖倒置？&lt;/p&gt;
&lt;p&gt;2.什么是控制反转？&lt;/p&gt;
&lt;p&gt;3.什么是依赖注入？&lt;/p&gt;
&lt;p&gt;4.它们之间的关系是怎样的？&lt;/p&gt;
&lt;p&gt;5.优点有哪些？&lt;/p&gt;
&lt;h3 id=&quot;依赖倒置原则-（dependency-inversion-principle）&quot;&gt;依赖倒置原则 （Dependency Inversion Principle）&lt;/h3&gt;
&lt;p&gt;​ &lt;strong&gt;依赖倒置是一种设计原则。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 依赖倒置包括三层含义：（1）高层模块不应该直接依赖于底层模块，两者都应依赖其抽象；（2）抽象不应依赖于细节；（3）细节应该依赖于抽象。&lt;/p&gt;
&lt;h3 id=&quot;控制反转-（inversion-of-control）&quot;&gt;控制反转 （Inversion of Control）&lt;/h3&gt;
&lt;p&gt;​ &lt;strong&gt;控制反转是一种思想。&lt;/strong&gt;其核心思想在于，合作的对象依赖关系的管理不由具体对象来完成，而是具体对象交出依赖关系的控制权，由第三方容器来集中管理。&lt;/p&gt;
&lt;p&gt;​ 第三方容器管理的优点：（1）依赖关系的集中管理，关系清晰且易管理；（2）降低合作对象之间的耦合程度。&lt;/p&gt;
&lt;p&gt;​ 举个栗子。我想在北京租一间房子，我只需要把我的需求告知链家等中介公司，通过他们整合的资源，我就能够找到一间符合我需求的房子。我不需要与房东产生任何直接的关系，中间的任何问题都由链家进行统一处理。在这个例子中，&lt;strong&gt;房客与房东是两个独立的对象，而链家则是充当中间容器&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;依赖注入（dependency-inversion）&quot;&gt;依赖注入（Dependency Inversion）&lt;/h3&gt;
&lt;p&gt;​ &lt;strong&gt;依赖注入是控制反转的具体方法之一。&lt;/strong&gt;依赖注入就是将底层依赖对象以参数形式传入上层对象。&lt;/p&gt;
&lt;p&gt;​ 对象间的依赖关系的管理被反转至IoC容器中。对象间的依赖关系由IoC容器进行统一管理，并由IoC容器来完成对象的注入。&lt;/p&gt;
&lt;h3 id=&quot;依赖倒置原则-、控制反转-、依赖注入的关系&quot;&gt;依赖倒置原则 、控制反转 、依赖注入的关系&lt;/h3&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/HyQMzQ.png&quot; alt=&quot;DIP、IoC、DI关系图&quot;/&gt;&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;p&gt;1.实现模块间松耦合&lt;/p&gt;
&lt;p&gt;2.由IoC容器来统一管理依赖关系，对象从复杂的依赖关系中解放。&lt;/p&gt;
&lt;p&gt;3.对象自身弄够专注于自身功能上，不需要了解依赖对象的内部结构。&lt;/p&gt;

&lt;h2 id=&quot;ioc-容器&quot;&gt;IoC 容器&lt;/h2&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/BeanFactory3.png&quot; alt=&quot;BeanFactory3&quot;/&gt;&lt;h3 id=&quot;beanfactory&quot;&gt;BeanFactory&lt;/h3&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/BeanFactory4.png&quot; alt=&quot;BeanFactory4&quot;/&gt;&lt;p&gt;​ &lt;strong&gt;BeanFactory提供最基本的IoC容器功能和基本规范。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ BeanFactory中有getBean、getType、getAliases、isSingleton、isPrototype等函数。主要常用接口是getBean，改函数能够通过Bean名称获取Bean&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BeanFactory扩展接口&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;（1）ListableBeanFactory：接口定义Bean的基本信息。&lt;/p&gt;
&lt;p&gt;​ 接口中函数有：getBeanDefinitionCount获取Bean数量、containsBeanDefinition判断容器中是否存在该Bean、getBeanDefinitionNames获取工程所有Bean的名称等。&lt;/p&gt;
&lt;p&gt;（2）HierarchicalBeanFactory：父子容器关联&lt;/p&gt;
&lt;p&gt;​ 接口中函数有：getParentBeanFactory子容器可以通过函数访问到父容器&lt;/p&gt;
&lt;p&gt;（3）ConfigurableBeanFactory：可定制IoC容器&lt;/p&gt;
&lt;p&gt;​ 接口中函数有：setBeanClassLoader设置Bean类加载器、setBeanExpressionResolver设置表达式解析器、registerCustomEditor注册编辑器等。&lt;/p&gt;
&lt;p&gt;（4）AutowireCapableBeanFactory：定义Bean自动装配规则&lt;/p&gt;
&lt;p&gt;​ 接口中函数有：autowireBeanProperties根据名称或属性给Bean进行自动装配等。&lt;/p&gt;
&lt;h3 id=&quot;applicationcontext&quot;&gt;ApplicationContext&lt;/h3&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/ApplicationContext%E5%85%B3%E7%B3%BB%E5%9B%BE.png&quot; alt=&quot;ApplicationContext关系图&quot;/&gt;&lt;p&gt;​ &lt;strong&gt;ApplicationContext基于BeanFactory，是比BeanFactory更为高级的容器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ ApplicationContext相对于BeanFactory提供更多功能，BeanFactory中需要通过编程实现的功能，ApplicationContext中可以使用配置来实现。&lt;/p&gt;
&lt;p&gt;​ ApplicationContext继承ListableBeanFactory、HierarchicalBeanFactory，除此之外还扩展了其他接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ApplicationContext扩展接口：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）ApplicationEventPublisher：封装事件发布功能。&lt;/p&gt;
&lt;p&gt;（2）MessageSource：提供i18n国际化消息刚问功能。（解释模块中解释i18n）&lt;/p&gt;
&lt;p&gt;（3）ResourcePatternResolver：通过路径加载资源&lt;/p&gt;
&lt;p&gt;（4）LifeCycle：start()、stop()、isRunning()，控制与判断容器当前状态，以达到控制与调度的作用。&lt;/p&gt;
&lt;p&gt;（5）ConfigurableApplicationContext：实现ApplicationContext，新增refresh()、close()，使ApplicationContext具备启动、刷新、关闭等功能。&lt;/p&gt;

&lt;h2 id=&quot;ioc容器的依赖注入&quot;&gt;IoC容器的依赖注入&lt;/h2&gt;
&lt;h3 id=&quot;基于注解定义bean&quot;&gt;基于注解定义Bean&lt;/h3&gt;
&lt;p&gt;​ Spring2.0开始Spring提供基于注解的依赖注入功能。使用xml进行配置使Bean定义信息与Bean实现代码分离，这就会造成代码复杂且易错。基于注解就可以在Bean实现类上进行注解标注，这大大降低的代码的复杂性。&lt;/p&gt;
&lt;p&gt;​ 定义Bean注解有以下4中：&lt;/p&gt;
&lt;p&gt;​ （1）@Component：组件&lt;/p&gt;
&lt;p&gt;​ （2）@Respository：对于Dao实现类进行标注&lt;/p&gt;
&lt;p&gt;​ （3）@Service：对于Service实现类进行标注&lt;/p&gt;
&lt;p&gt;​ （4）@Controller：对于Controller实现类进行标注&lt;/p&gt;
&lt;p&gt;@Respository、@Service、@Controller是@Component的扩展，尽量使用3种特殊的注解，因为能够标识出Bean的类型。&lt;/p&gt;
&lt;h3 id=&quot;自动装配&quot;&gt;自动装配&lt;/h3&gt;
&lt;h4 id=&quot;resource&quot;&gt;@Resource&lt;/h4&gt;
&lt;p&gt;​ resource是用J2EE提供的。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;查找方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）按照指定name和type，容器中找到后对bean进行装配，找不到抛出异常。&lt;/p&gt;
&lt;p&gt;（2）按照指定name，容器中找到后对bean进行装配，找不到抛出异常。&lt;/p&gt;
&lt;p&gt;（3）按照指定type，容器中找到后对bean进行装配，找不到或找到多个抛出异常。&lt;/p&gt;
&lt;p&gt;（4）没指定name和type，则先安装name方式装配，找不到这则按type进行装配，都没有抛异常。&lt;/p&gt;
&lt;h4 id=&quot;autowired&quot;&gt;@Autowired&lt;/h4&gt;
&lt;p&gt;​ autowired是spring提供的。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;查找方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）按照类型查找，如果该类型bean不唯一则抛异常。&lt;/p&gt;
&lt;h4 id=&quot;qualifier&quot;&gt;@Qualifier&lt;/h4&gt;
&lt;p&gt;​ &lt;strong&gt;查找方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）通过名称指定Bean，同一个接口有多个实现，我们要装配其中某一个Bean时，可以用qualifier通过名称直接指定，一般结合Autowired一起使用。&lt;/p&gt;
&lt;h3 id=&quot;基于java类配置&quot;&gt;基于Java类配置&lt;/h3&gt;
&lt;h4 id=&quot;bean&quot;&gt;@Bean&lt;/h4&gt;
&lt;p&gt;​ 普通的POJO可以通过标注@Configuration注解，就可以为Spring容器提供Bean定义信息，标注了@Bean的类方法就相当于提供了Bean的定义信息。当第三方库引入时，可以使用@Bean注解将Bean交由Spring容器进行管理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class AppConfig {

    @Bean(name = &quot;dataSource&quot;)
    public DataSource initDataSource() {
        return DataSourceBuilder.create().build();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相当于&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;beans&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.boot.jdbc.DataSourceBuilder&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;bean的作用域&quot;&gt;Bean的作用域&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;singleton&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;IoC容器中仅存在一个Bean实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;prototype&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;每次调用都会返回新的Bean实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;request&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;每次Http请求都会创建一个Bean&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;session&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;同一个session共享Bean&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;globalSession&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;同一个全局Session共享一个Bean&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;singleton&quot;&gt;singleton&lt;/h4&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/singleton.png&quot; alt=&quot;singleton&quot;/&gt;&lt;h4 id=&quot;prototype&quot;&gt;prototype&lt;/h4&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/prototype.png&quot; alt=&quot;prototype&quot;/&gt;
&lt;h2 id=&quot;factorybean&quot;&gt;FactoryBean&lt;/h2&gt;
&lt;h3 id=&quot;解释说明&quot;&gt;解释说明&lt;/h3&gt;
&lt;p&gt;​ FactoryBean是能够生产和修饰对象生成的工厂Bean。Spring提供了org.springframework.beans.factory. FactoryBean接口，使用者能通过实现接口对Bean的实例化进行定制。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;（1）第三方框架提供的类，我们很难直接修改类代码，为其添加@Service或@Componet时。&lt;br/&gt;（2）当我们需要对第三方框架生成的实例进行修饰时。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;应用案例&quot;&gt;应用案例&lt;/h3&gt;
&lt;p&gt;（1） mybatis-spring中org.mybatis.spring.SqlSessionFactoryBean&lt;/p&gt;

&lt;h2 id=&quot;ioc容器内部关系&quot;&gt;IoC容器内部关系&lt;/h2&gt;
&lt;img src=&quot;https://gitee.com/leeboyce/imagebed/raw/20200305-image/uPic/Spring%E5%AE%B9%E5%99%A8%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%81Bean%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%85%B3%E7%B3%BB%E5%9B%BE.png&quot; alt=&quot;Spring容器、配置文件、Bean、应用程序关系图&quot;/&gt;&lt;p&gt;​ Bean配置信息配置了Bean的实现与依赖关系，容器将Bean配置信息注册至注册表中，然后根据注册表加载与实例化，并建立Bean与Bean之间的依赖关系，最后将结果放置Bean缓存池中，供用应用程序调用。&lt;/p&gt;

&lt;h2 id=&quot;解释&quot;&gt;解释&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;i18n：&lt;/strong&gt;国际化信息也称为本地化信息 。 Java 通过 java.util.Locale 类来表示本地化对象，它通过 “语言类型” 和 “国家/地区” 来创建一个确定的本地化对象。比如在发送一个具体的请求的时候，在header中设置一个键值对：&quot;Accept-Language&quot;：&quot;zh&quot;，通过Accept-Language对应值，服务器就可以决定使用哪一个区域的语言，找到相应的资源文件，格式化处理，然后返回给客户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;[1]&lt;a href=&quot;https://www.jianshu.com/p/6f0a59623090&quot;&gt;https://www.jianshu.com/p/6f0a59623090&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]&lt;a href=&quot;https://www.cnblogs.com/hujunzheng/p/11037577.html&quot;&gt;https://www.cnblogs.com/hujunzheng/p/11037577.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3]《精通Spring4.x企业应用开发实战》&lt;/p&gt;
</description>
<pubDate>Sat, 04 Apr 2020 17:51:00 +0000</pubDate>
<dc:creator>码头工人</dc:creator>
<og:description>[toc] Spring IoC 概述 问题 1.什么是依赖倒置？ 2.什么是控制反转？ 3.什么是依赖注入？ 4.它们之间的关系是怎样的？ 5.优点有哪些？ 依赖倒置原则 （Dependency I</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/boycelee/p/12635640.html</dc:identifier>
</item>
<item>
<title>数据挖掘入门系列教程（八）之使用神经网络（基于pybrain）识别数字手写集MNIST - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/12635624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/12635624.html</guid>
<description>&lt;h2 id=&quot;数据挖掘入门系列教程（八）之使用神经网络（基于pybrain）识别数字手写集mnist&quot;&gt;数据挖掘入门系列教程（八）之使用神经网络（基于pybrain）识别数字手写集MNIST&lt;/h2&gt;
&lt;p&gt;在本章节中，并不会对神经网络进行介绍，因此如果不了解神经网络的话，强烈推荐先去看《西瓜书》，或者看一下我的上一篇博客：&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12623925.html&quot;&gt;数据挖掘入门系列教程（七点五）之神经网络介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本来是打算按照《Python数据挖掘入门与实践》里面的步骤使用神经网络来识别验证码，但是呢，验证码要自己生成，然后我又想了一下，不是有大名鼎鼎的MNIST数据集吗，为什么不使用它呢，他不香吗？&lt;/p&gt;
&lt;p&gt;MNIST（Mixed National Institute of Standards and Technology database）相信大家基本上都了解过他，大部分的机器学习入门项目就是它。它是一个非常庞大的手写&lt;strong&gt;数字&lt;/strong&gt;数据集（&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot;&gt;官网&lt;/a&gt;）。里面包含了0~9的手写的数字。部分数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200405013433144-779700135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据集分为两个部分，训练集和测试集。然后在不同的集合中分为两个文件，数据Images文件和Labels文件。在数据集中一个有60,000个训练数据和10,000个测试数据。图片的大小是28*28。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200405013433481-1961266374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;下载数据集&quot;&gt;下载数据集&lt;/h3&gt;
&lt;p&gt;万物始于数据集，尽管官网提供了数据集供我们下载，但是在&lt;strong&gt;sklearn&lt;/strong&gt;中提供了更方便方法让我们下载数据集。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
from sklearn.datasets import fetch_openml
# X为image数据，y为标签
X, y = fetch_openml('mnist_784', version=1, return_X_y=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中X，y中间既包含了训练集又包含了测试集。也就是说X或者y中有70,000条数据。 那么数据是什么呢？&lt;/p&gt;
&lt;p&gt;在X中，每一条数据是一个长为&lt;span class=&quot;math inline&quot;&gt;\(28 \times 28=784\)&lt;/span&gt;的数组，数组的数据是图片的像素值。每一条y数据就是一个标签，代表这张图片表示哪一个数字（从0到9）。&lt;/p&gt;
&lt;p&gt;然后我们将数据进行二值化，像素值大于0的置为1，并将数据保存到文件夹中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;X[X &amp;gt; 0 ] = 1
np.save(&quot;./Data/dataset&quot;,X)
np.save(&quot;./Data/class&quot;,y)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在Data文件夹中就出现了以下两个文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200405013433699-1622145825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们取出dataset中间的一条数据，然后转成28*28的格式，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200405013433984-1513321167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据集既可以使用上面的方法得到，也可以从我的&lt;a href=&quot;https://github.com/xiaohuiduan/data_mining/tree/master/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/Data&quot;&gt;Github&lt;/a&gt;上面进行下载（其中dataset数据集因为GitHub文件大小的限制所以进行了压缩，需要解压才能够使用）。&lt;/p&gt;
&lt;h3 id=&quot;加载数据集&quot;&gt;加载数据集&lt;/h3&gt;
&lt;p&gt;前面的步骤我们下载好了数据集，现在我们就可以来加载数据了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np
X = np.load(&quot;./Data/dataset.npy&quot;)
y = np.load(&quot;./Data/class.npy&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;取出X中的一条数据如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200405013434316-1351106605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;取出y中的一条数据，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200405013434620-1697272099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一切都很完美，但是这里有一个问题，在神经网络中，输出层实际上是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200405013435010-788298620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它并不是直接输出某一个结果，而是输出&lt;span class=&quot;math inline&quot;&gt;\(y_1,…,y_j,…,y_l\)&lt;/span&gt;结果（在MNIST中&lt;span class=&quot;math inline&quot;&gt;\(l=10\)&lt;/span&gt;，因为只有10种数字）。以上面的5为例子，输出层并不是单纯的输出只输出一个数字，而是要输出10个值。那么如何将输出5变成输出10个数字呢？这里我们使用”one hot Encoding“。&lt;/p&gt;
&lt;p&gt;One-Hot编码，又称为一位有效编码，主要是采用&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;位状态寄存器来对&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候只有一位有效。&lt;/p&gt;
&lt;p&gt;以下面的数据为例，每一行代表一条数据，每一列代表一个属性。其中第2个属性只需要3个状态码，因为他只有0，1，2三种属性。这样我们就可以使用100代表0，010代表1，001代表2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200405013435547-1067813367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么这个数据编码后的数据长什么样呢？如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200405013435828-526596123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们就可以将前面加载的数据集标签&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;进行“one hot Encoding”。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sklearn.preprocessing import OneHotEncoder
# False代表不生成稀疏矩阵
onehot = OneHotEncoder(sparse = False)
# 首先将y转成行长为7000，列长为1的矩阵，然后再进行转化。
y = onehot.fit_transform(y.reshape(y.shape[0],1))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着就是切割数据集了。将数据集切割成训练集和测试集。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test = train_test_split(X,y,random_state=14)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在神经网络中，我们使用&lt;a href=&quot;http://pybrain.org/&quot;&gt;pybrain&lt;/a&gt;框架去构建一个神经网络。但是呢，对于pybrain库，他很与众不同，他要使用自己的数据集格式，因此，我们需要将数据转成它规定的格式。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from pybrain.datasets import SupervisedDataSet

train_data = SupervisedDataSet(x_train.shape[1],y.shape[1])
test_data = SupervisedDataSet(x_test.shape[1],y.shape[1])

for i in range(x_train.shape[0]):
    train_data.addSample(x_train[i],y_train[i])
for i in range(x_test.shape[0]):
    test_data.addSample(x_test[i],y_test[i])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;终于，数据集的加载就到这里结束了。接下来我们就可以开始构建一个神经网络了。&lt;/p&gt;
&lt;h3 id=&quot;构建神经网络&quot;&gt;构建神经网络&lt;/h3&gt;
&lt;p&gt;首先我们来创建一个神经网络，网络中只含有输入层，输出层和一层隐层。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from pybrain.tools.shortcuts import buildNetwork
# X.shape[1]代表属性的个数，100代表隐层中神经元的个数，y.shape[1]代表输出
net = buildNetwork(X.shape[1],100, y.shape[1], bias=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里说有以下“bias”的作用。bias代表的是偏置神经元，bias = True代表偏置神经元激活，也就是在每一层都使用这个这个神经元。偏置神经元如下图，实际上也就是阈值，只不过换一种说法而已。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200405013436117-187317211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们已经构建好了一个比较简单的神经网络，接下来我们就是使用BP算法去得到合适的权重值了。&lt;/p&gt;
&lt;h3 id=&quot;反向传播bp算法&quot;&gt;反向传播(BP)算法&lt;/h3&gt;
&lt;p&gt;具体的算法步骤在上一篇&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12623925.html&quot;&gt;博客&lt;/a&gt;已经介绍过了，很幸运的是在pybrain中间提供了BP算法的库供我们使用。这里就直接上代码吧。关于BackpropTrainer更加细节的使用可以看&lt;a href=&quot;http://pybrain.org/docs/api/supervised/trainers.html&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from pybrain.supervised.trainers import BackpropTrainer
trainer = BackpropTrainer(net, train_data, learningrate=0.01,weightdecay=0.01)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面有几个参数稍微的说明下：&lt;/p&gt;
&lt;ul readability=&quot;3.9207920792079&quot;&gt;&lt;li&gt;
&lt;p&gt;net：神经网络&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;train_data：训练的数据集&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2.8980169971671&quot;&gt;
&lt;p&gt;learningrate：学习率，也就是下面的&lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt;，同样它可以使用&lt;em&gt;lrdecay&lt;/em&gt;这个参数去控制衰减率，具体的就去看&lt;a href=&quot;http://pybrain.org/docs/api/supervised/trainers.html&quot;&gt;官网文档&lt;/a&gt;吧。&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\begin{array}{l} \Delta w_{h j}=\eta g_{j} b_{h} \\ \Delta \theta_{j}=-\eta g_{j} \\ \Delta v_{i h}=\eta e_{h} x_{i} \\ \Delta \gamma_{h}=-\eta e_{h} \\ \end{array}\end{equation} \]&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;weightdecay：权重衰减，权重衰减也就是下面的&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;\[\begin{equation} E=\lambda \frac{1}{m} \sum_{k=1}^{m} E_{k}+(1-\lambda) \sum_{i} w_{i}^{2} \\ \lambda \in(0,1) \end{equation} \]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后我们就可以开始训练了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;trainer.trainEpochs(epochs=100)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;epochs&lt;/code&gt;也就是训练集被训练遍历的次数。&lt;/p&gt;
&lt;p&gt;接下载便是等待的时间了。等待训练集训练成完成。训练的时间跟训练集的大小，隐层神经元的个数，电脑的性能，步数等等有关。&lt;/p&gt;
&lt;p&gt;切记切记，这一次的程序就不要在阿里云的学生机上面跑了，还是用自己的机器跑吧。尽管联想小新pro13 i5版本性能还可以，但是还是跑了一个世纪这么久，哎（耽误了我打游戏的时间）。&lt;/p&gt;
&lt;h3 id=&quot;进行预测&quot;&gt;进行预测&lt;/h3&gt;
&lt;p&gt;通过前面的步骤以及等待一段时间后，我们就完成了模型的训练。然后我们就可以使用测试集进行预测。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;predictions = trainer.testOnClassData(dataset=test_data)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;predictions&lt;/code&gt;的部分数据，代表着测试集预测的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200405013436461-477788722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们就可以开始验证准确度了，这里继续使用F1评估。这个已经在前面介绍过了，就不再介绍了。&lt;/p&gt;
&lt;h3 id=&quot;f1验证&quot;&gt;F1验证&lt;/h3&gt;
&lt;p&gt;这里有个地方需要注意，因为之前的&lt;code&gt;y_test&lt;/code&gt;数据我们使用&lt;code&gt;one-hot encoding&lt;/code&gt;进行了编码，因此我们需要先将&lt;code&gt;one-hot&lt;/code&gt;编码转成正常的形式。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 取每一行最大值的索引。
y_test_arry = y_test.argmax(axis =1)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200405013436687-454155819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后使用&lt;code&gt;F1&lt;/code&gt;值进行验证。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from sklearn.metrics import f1_score
print(&quot;F-score: {0:.2f}&quot;.format(f1_score(predictions,y_test_arry,average='micro')))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200405013436923-1246887652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果只能说还行吧，不是特别的差，但是也不是特别的好。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/xiaohuiduan/data_mining/tree/master/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&quot;&gt;Github&lt;/a&gt;。尽管上面的准确度不咋地，只有&lt;span class=&quot;math inline&quot;&gt;\(86\%\)&lt;/span&gt;，但是也还行吧，毕竟也是使用了一层隐层，然后隐层也只有100个神经元。&lt;/p&gt;
&lt;p&gt;如果电脑的性能不够的话，可是适当的减少步数和训练集的大小，以及隐层神经元的个数。&lt;/p&gt;
&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;
</description>
<pubDate>Sat, 04 Apr 2020 17:36:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>[TOC] 数据挖掘入门系列教程（八）之使用神经网络（基于pybrain）识别数字手写集MNIST 在本章节中，并不会对神经网络进行介绍，因此如果不了解神经网络的话，强烈推荐先去看《西瓜书》，或者看一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/12635624.html</dc:identifier>
</item>
<item>
<title>自动化运维Ansible之常用模块 - jasonminghao</title>
<link>http://www.cnblogs.com/jasonminghao/p/12635616.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jasonminghao/p/12635616.html</guid>
<description>&lt;p&gt;在ansible中是指需要快速执行一条命令，并且不需要保存的命令，对于复杂的命令则为playbook&lt;/p&gt;
&lt;p&gt;查看模块帮助：ansible-doc -l&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 统计模块数量
$ ansible-doc -l |wc -l
3387  // ansible有大量的模块
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Ansible模块语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ansible [管理主机信息或者主机组信息] -m [模块名称] -a [相关模块参数] 
主机信息：远程主机IP地址；远程主机组名称；远程所有主机all
-m：指定相应模块
-a：利用模块中某些参数功能
-f ：定义每次输出内容的数量
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Ansible注意事项颜色信息：&lt;br/&gt;绿色：对远程节点不进行相应修改，或者只是对远程节点信息进行查看&lt;br/&gt;红色：操作执行命令有异常&lt;br/&gt;黄色：对远程节点进行相应修改&lt;br/&gt;深紫色：表示对命令执行发出警告信息（可能存在的问题，给你提示建议）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;command模块的作用：默认模块,&lt;code&gt;在远程主机执行命令&lt;/code&gt;；默认模块,可忽略-m选项&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// chaidr 先切换到特定的目录，然后在执行命令
[root@m01 ~]# ansible 10.4.7.8 -m command -a &quot;chdir=/tmp/ pwd&quot;

// creates 判断一个文件是否存在。文件如果存在，后面命令则不会执行；如果不存在，则执行
[root@m01 /]# ansible 10.4.7.8 -m command -a &quot;creates=/etc/rsyncd.conf hostname&quot;

// removes 判断一个文件是否存在。文件如果存在，后面命令执行；如果不存在，则不执行
[root@m01 /]# ansible 10.4.7.8 -m command -a &quot;removes=/etc/exports hostname&quot;

// fress_form 使用command模块批量获取执行hostname命令
[root@m01 /]# ansible sa -m command -a &quot;hostname&quot;  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该command模块无法和shell一样，像$HOME变量，和一些像 &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, &quot;|&quot;, &quot;;&quot; and &quot;&amp;amp;&quot; 这样的操作是没有办法执行（如果要支持这些特殊符号就必须要使用shell模块）错误的演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@m01 /]# ansible sa -m command -a &quot;hostname;date&quot;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;shell模块作用：shell模块是&lt;code&gt;万能模块&lt;/code&gt;,可以满足command模块所有功能，并且可以&lt;code&gt;支持识别特殊字符&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 在10.4.7.8的机器的当前目录下执行ls和pwd命令
[root@m01 /]# ansible 10.4.7.8 -m shell -a &quot;ls;pwd&quot;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;scripts模块作用：&lt;code&gt;专门运行脚本模块&lt;/code&gt;,在本地执行脚本,脚本产生所有的动作都在远端主机上执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 编写脚本，里面添加yum安装keepalived命令，将脚本执行命令放入到受控端执行 
[root@m01 ~]# cat /server/scripts/yum.sh
#!/bin/bash
yum install -y keepalived

[root@m01 ~]# ansible 10.4.7.8 -m script -a &quot;/server/scripts/yum.sh&quot;
[root@m01 ~]# ansible 10.4.7.8 -m shell -a &quot;rpm -qa keepalived&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：我们在管理机器上执行的脚本，远端（受控端）是不需要存在该脚本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;copy模块作用：将文件从本地或远程机器&lt;code&gt;复制到远程机器上&lt;/code&gt;的某个位置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 将本端的/etc/hosts文件推送到远端，并且重命名为test.txt
[root@m01 ~]# ansible sa -m copy -a &quot;src=/etc/hosts dest=/tmp/test.txt&quot;

// 本端在/tmp/下创建文件file01.txt，推送到远端
[root@m01 ~]# touch /tmp/file01.txt
[root@m01 ~]# ansible 10.4.7.7 -m copy -a &quot;src=/tmp/file01.txt dest=/tmp/&quot; 

// 为本端的/tmp/file01.txt文件追加内容，并推送到远端，覆盖时备份原文件
[root@m01 ~]# cat /tmp/file01.txt
[root@m01 ~]# echo 123456 &amp;gt;/tmp/file01.txt
[root@m01 ~]# cat /tmp/file01.txt
123456
[root@m01 ~]# ansible 10.4.7.7 -m copy -a &quot;src=/tmp/file01.txt dest=/tmp/ backup=yes&quot;

// 在/root/下创建test.txt文件，在复制的时候修改属主和属组为root，权限644
[root@m01 ~]# ansible 10.4.7.7 -m copy -a &quot;src=/root/test.txt dest=/test/oldboy/ owner=root group=root mode=644&quot;

// 为对端的/tmp/test.txt文件写入内容“1”
[root@m01 ~]# ansible 10.4.7.7 -m copy -a &quot;content='1' dest=/tmp/test.txt&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;- backup   # 对推送传输过去的文件，进行备份
- src      # 推送数据的源文件信息
- dest     # 推送数据的目标路径
- content  # 直接批量在被管理端文件中添加内容
- owner    # 将本地文件推送到远端，指定文件属主权限
- group    # 将本地文件推送到远端，指定文件属组权限
- mode     # 将本地文件推送到远端，指定文件权限信息
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;file模块作用：对受控端的&lt;code&gt;文件属性修改/目录创建/文件创建&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 为远端主机修改/tmp/file01.txt文件的属主和属组为root,权限为600
[root@m01 ~]# ansible 10.4.7.7 -m file -a &quot;path=/tmp/file01.txt owner=root group=root mode=600&quot;

// 为远端主机创建文件和目录，远程创建文件/tmp/file01.txt
[root@m01 ~]# ansible 10.4.7.7 -m file -a &quot; path =/tmp/file01.txt state=touch&quot;

// 远程创建目录/tmp/dir01
[root@m01 ~]# ansible 10.4.7.7 -m file -a &quot;path =/tmp/dir01 state=directory&quot;

// 递归修改远端主机的/data目录及目录下的所有文件的属主和属组都为root
[root@m01 /]# ansible 10.4.7.7 -m file -a &quot;path=/data state=directory owner=root group=root recurse=yes&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;模块参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;- path    # 指定远程主机目录或文件信息
- recurse # 递归授权：
    yes   # 递归修改权限
    no    # 不递归修改权限（默认）
- state   # 指定需要执行的动作：
    directory  # 在远端创建目录
    touch      # 在远端创建文件
    hard       #  硬链接
    link       #软链接
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;yum模块作用：可以对受控端&lt;code&gt;执行yum安装&lt;/code&gt;，&lt;code&gt;卸载和查看软件包&lt;/code&gt;等&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// yum安装iftop软件包
[root@m01 ~]# ansible 10.4.7.7 -m yum -a &quot;name=iftop state=installed&quot;

// 移除iftop软件
[root@m01 ~]# ansible 10.4.7.7 -m yum -a &quot;name=iftop state=absent&quot;

// 查看指定软件包名的列表
[root@m01 ~]# ansible 10.4.7.7 -m yum -a &quot;list=iftop&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;模块参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;- name  # 执行要安装软件的名称，以及软件的版本
- state # 指定需要执行的动作：
    installed、present   # 安装软件包
    latest               # 安装最新软件包
    removed、absent      # 移除软件包
- list  # 指定软件名称，查看软件是否已经安装了
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;service模块作用：&lt;code&gt;管理服务状态模块&lt;/code&gt;，对受控端进行服务的管理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 将远端的crond服务关闭，并且开机不启动
[root@m01 ~]# ansible 10.4.7.7 -m service -a &quot;name=crond state=stopped enabled=no&quot;

// 将远端的crond服务开启，并且开机自启动
[root@m01 ~]# ansible 10.4.7.7 -m service -a &quot;name=crond state=started enabled=yes&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;模块参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;- name    # 指定需要管理的服务名称（管理的服务一定在chkconfig中可以看到）
- state   # 指定需要执行的动作：
    started     # 启动服务
    reloaded    # 平滑重启
    restarted   # 重启服务
    stopped     # 停止服务
    running     # 运行(启动)服务
- enable  # 设置服务是否开机自启动：
    yes    # 服务开机自启动
    no     # 服务开机不启动
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;cron模块作用：为受控端&lt;code&gt;添加定时任务&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;x x x x x /bin/sh /server/scripts/test.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/p&gt;
&lt;p&gt;将系统命令行的定时任务变成ansilbe的语法&lt;br/&gt;传统的写法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;&quot;minute=0 hour=0 daay=* month=* weekday=* job='/bin/sh /server/scripts/test.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1'&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ansible的写法（* 号是可以省略的）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ansible 10.4.7.7 -m cron -a &quot;minute=0 hour=0 job='/bin/sh /server/scripts/test.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1'&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定时任务示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 添加一条定时任务
[root@m01 ~]# ansible 10.4.7.7 -m cron -a &quot;minute=0 hour=0 job='/bin/sh /server/scripts/test.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1'&quot;

// 设置定时任务注释信息，防止重复设置
[root@m01 ~]# ansible 10.4.7.7 -m cron -a &quot;name='cron01' minute=0 hour=0 job='/bin/sh /server/scripts/test.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1'&quot;

// 删除指定的name
[root@m01 ~]# ansible 10.4.7.7 -m cron -a &quot;name='cron01' minute=0 hour=0 job='/bin/sh /server/scripts/test.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1' state=absent&quot;

// 也可以直接指定定时任务项的名称，进行定时任务的删除
[root@m01 ~]# ansible 10.4.7.7 -m cron -a &quot;name='cron02' state=absent&quot;

// 使用 disabled 参数来注释定时任务
[root@m01 ~]# ansible 10.4.7.7 -m cron -a &quot;name='cron01' minute=0 hour=0 job='/bin/sh /server/scripts/test.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1' disabled=yes&quot;

// 取消注释
[root@m01 ~]# ansible 10.4.7.7 -m cron -a &quot;name='cron01' minute=0 hour=0 job='/bin/sh /server/scripts/test.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1' disabled=no&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;模块参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;- name # 为新的定时任务条目设置名称（防止定时任务项的重复）
- state  # 需要指定的动作：
    absent   # 添加定时任务
    preset   # 删除定时任务 
- disabled # 是否禁用定时任务（是否注释）：
    yes   # 禁用定时任务项（注释掉）
    no    # 开启定时任务项（取消注释）
# 该参数需要和job一起使用
- minute  # 分钟 0-59
- hour    # 小时 0-23
- day     # 天数 1-31
- month   # 月份 1-12
- weekday # 周 0-6
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;group模块作用：可以为远端&lt;code&gt;创建用户组&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 创建组，组名为demo，组id为1012
[root@m01 ~]# ansible 10.4.7.7  -m group -a &quot;name=demo gid=1012&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;模块参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;- name # 必须参数，指定创建的组名
- gid  # 指定用户的gid
- state
    absent   # 移除远端主机的组
    present  # 创建远端主机的组（默认）
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;user模块作用：可以为远端进行&lt;code&gt;创建用户&lt;/code&gt;、&lt;code&gt;修改用户&lt;/code&gt;、&lt;code&gt;删除用户&lt;/code&gt;等&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 创建用户名test，uid为999，组为test，shell为/sbin/nologin，并且不创建家目录
[root@m01 ~]# ansible 10.4.7.7 -m user -a &quot;name=test uid=1010 shell=/sbin/nologin createhome=no&quot;

// 创建普通用户alx，并配置对应的用户密码（-1 使用MD5加密）
[root@m01 /]# echo '123456' | openssl passwd -1 -stdin
$1$yGnjv/n3$J.tO.qSIyLy5q547tSisz/
[root@m01 /]# ansible 10.4.7.7 -m user -a 'name=alx password=&quot;$1$yGnjv/n3$J.tO.qSIyLy5q547tSisz/&quot;'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;模块参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;- name     # 必须参数，指定用户名
- group    # 指定用户组名称
- groups   # 指定附加组名称，多个组之间用逗号&quot;,&quot;分隔
- shell    # 指定用户登录的shell
- uid      # 指定用户的uid
- comment  # 指定用户的注释信息
- password # 给用户添加密码
- state  # 指定用户是否存在于受控主机中：
    preset  # 创建用户（默认）
    absent  # 删除用户
- createhome # 是否创建家目录：
    yes  # 创建家目录（默认）
    no   # 不创建家目录
- home  # 指定家目录，需要和createhome互相配合使用
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;密码设置：必须要将预先设置的密码做openssl加密处理后输出的一串数值，然后还数值就作为新创建用户的密码，如果添加的是明文密码的话是无效的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;mount模块作用：可以将&lt;code&gt;挂载参数写入到/etc/fastb文件&lt;/code&gt;中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 仅将挂载的配置写入到/etc/fastb，并不会执行挂载
[root@m01 ~]# ansible sa -m mount -a &quot;src=172.16.1.31:/data path=/tmp fstype=nfs opts=defaults state=present&quot;

// 临时挂载设备，并将挂载的配置写入到/etc/fastb
[root@m01 ~]# ansible sa -m mount -a &quot;src=172.16.1.31:/data path=/tmp fstype=nfs opts=defaults state=mounted&quot;

// 临时卸载，不会清理/etc/fstab
[root@m01 ~]# ansible sa -m mount -a &quot;src=172.16.1.31:/data path=/tmp fstype=nfs opts=defaults state=unmounted&quot;

// 卸载，不仅临时卸载，同时会清理/etc/fstab
[root@m01 ~]# ansible sa -m mount -a &quot;src=172.16.1.31:/data path=/tmp fstype=nfs opts=defaults state=absent&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;模块参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;- present   # 开机挂载，不会执行挂载指令，仅将挂载的配置写入到/etc/fastb
- mounted   # 挂载设备，并将挂载的配置写入到/etc/fastb
- unmounted # 卸载设备，不会清除/etc/fastb写入的配置
- absent    #卸载设备，会清理/etc/fastb写入的配置
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：path 所指定的挂载目录不需要手动创建，当执行挂载命令的时候，会自动的创建并挂载&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Unarchive模块作用：解压缩&lt;/p&gt;
&lt;p&gt;该模块有两种用法：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;将ansible主机上的压缩包在本地解压缩后传到远程主机上，这种情况下，copy=yes. 本地解压缩,解压缩位置不是默认的目录,没找到或传完删了 后传到远程主机&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将远程主机上的某个压缩包解压缩到指定路径下。这种情况下，需要设置copy=no 远程主机上面的操作,不涉及ansible服务端&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 将本地的压缩文件解压后传到远程主机
[root@m01 ~]# ansible 10.4.7.7 -m unarchive -a &quot;src=/opt/src/apache-tomcat-8.5.53.tar.gz dest=/opt copy=yes mode=0755&quot;

// 将远程主机的压缩文件解压
[root@m01 ~]# ansible 10.4.7.7 -m unarchive -a &quot;src=/opt/src/apache-tomcat-8.5.53.tar.gz dest=/opt copy=no mode=0755&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;模块参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;- src  # 源压缩包路径
- dest # 压缩包解压后存放路径
- copy # yes：本地压缩，no：远程压缩
    yes
    no
- mode # 解压后的目录/文件权限
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Git模块作用：管理git仓库的git checkout以部署文件或软件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 拉取git仓库commit id 为78d5d96的代码到指定目录
[root@m01 ~]# ansible 10.4.7.7 -m git -a &quot;repo=https://gitee.com/jasonminghao/dubbo-demo-service.git dest=/data/git_repo/dubbo-demo-service version=78d5d96 accept_hostkey=yes&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;模块参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;- repo    # git仓库地址(https/ssh)
- dest    # 将代码克隆到指定路径
- version # 克隆指定版本分支/commit id
- accept_hostkey # 类似于-o StrictHostKeyChecking=no
    yes
    no
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;systemd模块作用：如果使用systemctl 管理程序的话，可以使用systemd模块，systemctl 可以控制程序，reload，start，status，restart等&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;// 拉取git仓库commit id 为78d5d96的代码到指定目录
[root@m01 ~]# ansible 10.4.7.7 -m systemd -a  &quot;name=nfs state=started enabled=yes daemon_reload=true&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;模块参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;- name     # 需要管理的服务名称
- state    # 执行动作
    reloaded  # 平滑重启
    restarted # 重启
    started   # 启动
    stopped   # 停止
- enabled # 是否开机启动
- daemon_reload # 在执行任何其他操作之前运行daemon-reload，以确保systemd已经读取了任何更改。
     yes
     no
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 04 Apr 2020 17:27:00 +0000</pubDate>
<dc:creator>jasonminghao</dc:creator>
<og:description>[TOC] 0、Ansible模块语法 在ansible中是指需要快速执行一条命令，并且不需要保存的命令，对于复杂的命令则为playbook 查看模块帮助：ansible doc l Ansible模</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jasonminghao/p/12635616.html</dc:identifier>
</item>
<item>
<title>Vue.js系列(一)：Vue项目创建详解 - 爱在846</title>
<link>http://www.cnblogs.com/aizai846/p/12634878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aizai846/p/12634878.html</guid>
<description>&lt;p&gt;Vue.js作为目前最热门最具前景的前端框架之一，其提供了一种帮助我们快速构建并开发前端项目的新的思维模式。本文旨在帮助大家认识Vue.js，并详细介绍使用vue-cli脚手架工具快速的创建Vue项目，以及对项目目录结构的解释说明，使大家清晰的了解Vue项目的开发流程。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;160.07535338506&quot;&gt;
&lt;h3&gt;引言&lt;/h3&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;Vue.js作为目前最热门最具前景的前端框架之一，其提供了一种帮助我们快速构建并开发前端项目的新的思维模式。本文旨在帮助大家认识Vue.js，并详细介绍使用vue-cli脚手架工具快速的构建Vue项目，以及对项目目录结构的解释说明，使大家清晰的了解Vue项目的开发流程。&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。&lt;/p&gt;
&lt;p&gt;Vue.js 还提供了 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API，其目标是通过尽可能简单的 API 实现响应式的数据绑定和可组合的视图组件。&lt;/p&gt;
&lt;h4&gt;Vue.js 的主要特点&lt;/h4&gt;
&lt;p&gt;Vue.js 是一个优秀的前端界面开发 JavaScript 库，它之所以非常火，是因为有众多突出的特点，其中主要的特点有以下几个。&lt;/p&gt;
&lt;h5&gt;1) 轻量级的框架&lt;/h5&gt;
&lt;p&gt;Vue.js 能够自动追踪依赖的模板表达式和计算属性，提供 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API，使读者更加容易理解，能够更快上手。&lt;/p&gt;
&lt;h5&gt;2) 双向数据绑定&lt;/h5&gt;
&lt;p&gt;声明式渲染是数据双向绑定的主要体现，同样也是 Vue.js 的核心，它允许采用简洁的模板语法将数据声明式渲染整合进 DOM。&lt;/p&gt;
&lt;h5&gt;3) 指令&lt;/h5&gt;
&lt;p&gt;Vue.js 与页面进行交互，主要就是通过内置指令来完成的，指令的作用是当其表达式的值改变时相应地将某些行为应用到 DOM 上。&lt;/p&gt;
&lt;h5&gt;4) 组件化&lt;/h5&gt;
&lt;p&gt;组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。&lt;/p&gt;&lt;p&gt;在 Vue 中，父子组件通过 props 传递通信，从父向子单向传递。子组件与父组件通信，通过触发事件通知父组件改变数据。这样就形成了一个基本的父子通信模式。&lt;/p&gt;&lt;p&gt;在开发中组件和 HTML、JavaScript 等有非常紧密的关系时，可以根据实际的需要自定义组件，使开发变得更加便利，可大量减少代码编写量。&lt;/p&gt;&lt;p&gt;组件还支持热重载（hotreload）。当我们做了修改时，不会刷新页面，只是对组件本身进行立刻重载，不会影响整个应用当前的状态。CSS 也支持热重载。&lt;/p&gt;
&lt;h5&gt;5) 客户端路由&lt;/h5&gt;
&lt;p&gt;Vue-router 是 Vue.js 官方的路由插件，与 Vue.js 深度集成，用于构建单页面应用。Vue 单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来，传统的页面是通过超链接实现页面的切换和跳转的。&lt;/p&gt;
&lt;h6&gt;6) 状态管理&lt;/h6&gt;
&lt;p&gt;状态管理实际就是一个单向的数据流，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，使 State 产生变化，从而使 View 重新渲染，形成一个单独的组件。&lt;/p&gt;
&lt;h3&gt;SPA和MPA对比&lt;/h3&gt;
&lt;h4&gt;MPA&lt;/h4&gt;
&lt;p&gt;传统的项目大多使用多页应用结构（MultiPage Application, MPA），需要切换内容的时候我们往往会进行单个html文件的跳转，这个时候受网络、性能影响，浏览器会出现不定时间的空白界面，用户体验不好。&lt;/p&gt;
&lt;h4&gt;SPA       &lt;/h4&gt;
&lt;p&gt;单页面应用SPA应用（single page application）就是用户通过某些操作更改地址栏url之后，动态的进行不同模板内容的无刷新切换，用户体验好。&lt;/p&gt;
&lt;p&gt;Vue中会使用官方提供的vue-router插件来使用单页面，原理就是通过检测地址栏变化后将对应的路由组件进行切换（卸载和安装）。&lt;/p&gt;
&lt;h4&gt;两者对比&lt;/h4&gt;
&lt;table class=&quot;gridtable&quot;&gt;&lt;tbody readability=&quot;14.5&quot;&gt;&lt;tr&gt;&lt;th&gt;SPA vs MPA&lt;/th&gt;
&lt;th&gt;单页面应用（single page application, SPA）&lt;/th&gt;
&lt;th&gt;多页面应用（MultiPage Application, MPA）&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;th&gt;组成&lt;/th&gt;
&lt;td&gt;一个外壳页面和多个页面片段组成&lt;/td&gt;
&lt;td&gt;多个完整页面构成&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;th&gt;资源共享（css、js）&lt;/th&gt;
&lt;td&gt;共用只需要在外壳部分加载&lt;/td&gt;
&lt;td&gt;不共用，每个页面都需要加载&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;th&gt;刷新方式&lt;/th&gt;
&lt;td&gt;页面局部刷新或更改&lt;/td&gt;
&lt;td&gt;整页刷新&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;th&gt;url模式&lt;/th&gt;
&lt;td&gt;
&lt;p&gt;a.com/#/pagone&lt;/p&gt;
&lt;p&gt;a.com/#/pagtow&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;a.com/#/pagone.html&lt;/p&gt;
&lt;p&gt;a.com/#/pagtwo.html&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;th&gt;用户体验&lt;/th&gt;
&lt;td&gt;页面片段切换快，用户体验好&lt;/td&gt;
&lt;td&gt;页面切换加载缓慢，流畅度不够用户体验较差&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;转场动画&lt;/th&gt;
&lt;td&gt;容易实现&lt;/td&gt;
&lt;td&gt;无法实现&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;th&gt;数据传递&lt;/th&gt;
&lt;td&gt;容易&lt;/td&gt;
&lt;td&gt;依赖url传参、或者cookie、localStorage等&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;th&gt;搜索引擎优化（SEO）&lt;/th&gt;
&lt;td&gt;需要单独方案、实现较为困难、不利于SEO检索 可以利用服务器端渲染（ssr）优化&lt;/td&gt;
&lt;td&gt;实现方法简易&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;th&gt;适用范围&lt;/th&gt;
&lt;td&gt;高要求的体验度，追求界面流畅的应用&lt;/td&gt;
&lt;td&gt;适用于追求高度支持搜索引擎的应用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;th&gt;开发成本&lt;/th&gt;
&lt;td&gt;较高，常需借助专业的框架&lt;/td&gt;
&lt;td&gt;较低，但页面重复代码多&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;维护成本&lt;/th&gt;
&lt;td&gt;相对容易&lt;/td&gt;
&lt;td&gt;相对复杂&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;安装工具&lt;/h3&gt;
&lt;p&gt;第一步：&lt;/p&gt;
&lt;p&gt;安装node.js,具体可以参考博客&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/aizai846/p/11441693.html&quot;&gt;Node.js安装详细步骤教程(Windows版)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;第二步：&lt;/p&gt;
&lt;p&gt;安装webpack，具体参考博客&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/aizai846/p/11497508.html&quot;&gt;Webpack安装配置及打包详细过程&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;第三步：&lt;/p&gt;
&lt;p&gt;安装vue-cli，输入如下命令，全局安装vue-cli，其中cnpm是淘宝镜像，安装速度快，i是install的缩写，g是global的缩写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
cnpm i vue-cli -g
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;vue-cli创建过程&lt;/h3&gt;
&lt;p&gt;第一步：&lt;/p&gt;
&lt;p&gt;安装完成后，运行CMD，并切换到需要创建Vue项目的目录，输入如下命令开始创建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vue init webpack vue-test &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注：其中项目名称必须全部小写，否则会报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步：&lt;/p&gt;
&lt;p&gt;接着开始进行项目选项设置，具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Project name&lt;/strong&gt;---项目名称，直接回车；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project description&lt;/strong&gt;---项目描述，输入“Vue项目测试”，点击回车；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Author&lt;/strong&gt;---作者，输入“aizai846”,点击回车；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Runtime + Compiler: recommended for most users和Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere两个选项&lt;/strong&gt;---第一个是运行加编译，推荐使用，第二个仅运行时。通过键盘上下按钮选择后，点击回车；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Install vue-router?&amp;lt;Y/n&amp;gt;&lt;/strong&gt;---是否安装vue路由插件，输入“Y”,点击回车；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use ESLint to lint your code? &amp;lt;Y/n&amp;gt;&lt;/strong&gt;---是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用，但作为初学者，建议不进行安装，输入“n”，点击回车；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set up unit tests&amp;lt;Y/n&amp;gt;&lt;/strong&gt;---是否安装单元测试，这里输入“n”，点击回车；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Setup e2e tests with Nightwatch？&amp;lt;Y/n&amp;gt;?&lt;/strong&gt;---是否安装e2e测试，这里输入“n”，点击回车；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Should we run “npm install” for you after the project has been created?&amp;lt;recommended&amp;gt;&amp;lt;use arrow keys&amp;gt;Yes, use NPM   Yes, use Yarn    No, I will handle that myself&lt;/strong&gt;---三个选项，这里我们选择第三个，因为通过npm install安装vue项目依赖库，非常的慢，我们可以在项目创建后，自己通过“cnpm install”安装。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上就是我们创建项目的整个过程，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202004/1033899-20200404233723645-1908215480.png&quot; alt=&quot;&quot; width=&quot;496&quot; height=&quot;441&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 第三步：&lt;/p&gt;
&lt;p&gt;由于在第二步最后一个项，我们选择了自己安装项目包依赖，所以在这里输入如下命令，完成项目包依赖的安装。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cd F:\JsCodeProject\vue-test&lt;span&gt;//&lt;/span&gt;&lt;span&gt;切换到项目目录&lt;/span&gt;
&lt;span&gt;
cnpm i &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其中，cnpm是通过淘宝镜像安装，速度非常的快&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第四步：&lt;/p&gt;
&lt;p&gt;输入如下命令，测试项目是否能正常运行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm run dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  成功运行后，在shell命令框中，输出如下信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202004/1033899-20200404234928638-584261369.png&quot; alt=&quot;&quot; width=&quot;498&quot; height=&quot;107&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 此时，在浏览器中，输入上边的网址，可以访问我们新创建的vue项目，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202004/1033899-20200404235157632-1855955347.png&quot; alt=&quot;&quot; width=&quot;505&quot; height=&quot;209&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;vue目录介绍&lt;/h3&gt;
&lt;p&gt;通过VSCode打开我们新建的项目，具体目录结构如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202004/1033899-20200405001058297-203753534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在package.json文件中，我们可以到开发和生产环境的配置文件入口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &quot;scripts&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;start&quot;: &quot;npm run dev&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;build&quot;: &quot;node build/build.js&quot;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  其中，开发环境的入口文件为“webpack.dev.conf.js”；生产环境的入口文件为“build.js”，他们都在build文件下，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202004/1033899-20200405001856918-16598937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 其中部分文件说明如下：&lt;/p&gt;
&lt;ul&gt;&lt;li id=&quot;item-5-6&quot;&gt;build.js---生产环境的入口文件，为构建打包文件，会将源码进行构建（编译、压缩等）后打包；&lt;/li&gt;
&lt;li&gt;utils.js---一个被使用频率的文件，这个文件包含了三个工具函数：生成静态资源的路径、生成 ExtractTextPlugin对象或loader字符串、生成 style-loader的配置；&lt;/li&gt;
&lt;li id=&quot;item-5-7&quot;&gt;webpack.base.conf.js---在webpack.dev.conf.js中出现webpack.base.conf.js，这个文件是开发环境和生产环境，甚至测试环境，这些环境的公共webpack配置;&lt;/li&gt;
&lt;li id=&quot;item-4-2&quot;&gt;webpack.dev.conf.js---开发环境中webpack的配置入口。&lt;/li&gt;
&lt;li&gt;webpack.prod.conf.js---为生产环境中webpack的配置入口。同时，它也依赖于前面提到的webpack.base.conf.js、utils.js和config/index.js;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;打包部署&lt;/h3&gt;
&lt;p&gt;项目开发的文件放到src目录下，在项目开发完成之后，使用 如下命令来打包项目。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm run build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 打包完成后会生成dist文件夹，如图所示，项目上线时，直接将dist文件夹放到服务器即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1033899/202004/1033899-20200405004240667-408296416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;本文通过描述Vue项目的创建过程，及Vue目录结构的解释说明，可以使我们更加清晰的认识Vue项目的开发流程，对于初学的童鞋，能起到很好引路作用，项目里面还有很多没有解释到位的地方，童鞋可以添加关注，我们将在后续的博文中详细讲解，文中若有不足之处，还望海涵，同时，在创建中遇到问题，可留言交流！&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 04 Apr 2020 16:55:00 +0000</pubDate>
<dc:creator>爱在846</dc:creator>
<og:description>Vue.js作为目前最热门最具前景的前端框架之一，其提供了一种帮助我们快速构建并开发前端项目的新的思维模式。本文旨在帮助大家认识Vue.js，并详细介绍使用vue-cli脚手架工具快速的创建Vue项目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aizai846/p/12634878.html</dc:identifier>
</item>
<item>
<title>SpringBoot使用自定义注解实现简单参数加密解密(注解+HandlerMethodArgumentResolver) - yellowgg</title>
<link>http://www.cnblogs.com/yellowgg/p/12635553.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yellowgg/p/12635553.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我黄汉三又回来了，快半年没更新博客了，这半年来的经历实属不易，&lt;br/&gt;疫情当头，本人实习的公司没有跟员工共患难，直接辞掉了很多人。&lt;br/&gt;作为一个实习生，本人也被无情开除了。所以本人又得重新准备找工作了。&lt;br/&gt;算了，感慨一下，本来想昨天发的，但昨天是清明，哀悼时期，就留到了今天发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;话不多说，直接进入正题吧。这段时间本人在写毕设，学校也迟迟没有开学的消息，属实难顶。&lt;br/&gt;本来被开了本人只想回学校安度&quot;晚年&quot;算了，毕竟工作可以再找，但亲朋好友以后毕业了就很少见了。&lt;br/&gt;所以亲们，一定要珍惜身边的人噢。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;因为这篇博文是现在本地typora上面写好再放过博客园的，格式有点不统一&lt;br/&gt;博客园的markdown编辑器还不是很好用，这点有点头疼&lt;br/&gt;还有一点是代码格式问题，复制到markdown又变乱了&lt;br/&gt;我哭了，本来就乱了，再加上博客篇幅的问题一挤压，博文就乱完了&lt;br/&gt;以后更文都用markdown了，所以关于排版的问题会越来越美化一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过本文读者将可以学习到以下内容&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注解的简单使用和解析&lt;/li&gt;
&lt;li&gt;HandlerMethodArgumentResolver相关部分知识&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;写毕设，这周才把后台搭好，还有小程序端还没开始。如题目所说，用了SpringBoot做后端搭建。&lt;br/&gt;然后也当然应用了RESTful风格，当本人有一个url是/initJson/{id}的时候，直接就把用户ID传过来了。&lt;br/&gt;本人就想能不能在前端简单把ID加密一下，起码不能眼睁睁看着ID直接就传到后端。虽然只是一个毕设，&lt;br/&gt;但还是稍微处理一下吧，处理的话我选择用Base64好了。&lt;br/&gt;本人现在是想把前端传的一些简单参数，用密文传到后端再解密使用，避免明文传输。&lt;br/&gt;当然在真正的环境中，肯定是使用更好的方案的。这里只是说有那么一种思路或者说那么一种场景。&lt;br/&gt;给大家举个例子之后可以抛砖引玉。&lt;/p&gt;

&lt;h2 id=&quot;1前端&quot;&gt;1.前端&lt;/h2&gt;
&lt;p&gt;前端传参的时候，加密&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt; // encode是Base64加密的方法，可以自己随便整一个
 data.password = encode(pwd);
 data.username= encode(username);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样子前端传过去就是密文了。&lt;/p&gt;
&lt;h2 id=&quot;2后端&quot;&gt;2.后端&lt;/h2&gt;
&lt;p&gt;当参数传到后端之后，想要把密文解析回明文，然后接下来就是本文的主旨所在了。&lt;br/&gt;解密的时候，本人一开始是在接口里面解密的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
  *  此时参数接受到的内容是密文
  */
String login(String username, String password) {
       username =  Base64Util.decode(username);
       password=  Base64Util.decode(password);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来也没啥是吧，但是万一参数很多，或者说接口多，难道要每个接口都这么写一堆解密的代码吗。&lt;br/&gt;显然还可以改造，怎么做？本人想到了注解，或者说想用注解试试，这样自己也能加深对注解的学习。&lt;/p&gt;
&lt;h3 id=&quot;21-注解&quot;&gt;2.1 注解&lt;/h3&gt;
&lt;p&gt;注解这个东西，本人当时学习的时候还以为是怎么起作用的，原来是可以自定义的（笑哭）。&lt;br/&gt;我们在本文简单了解下注解吧，如果有需要，后面本人可以更新一篇关于注解的博文。&lt;br/&gt;或者读者可以自行学习了解一下，说到这里，本人写博客的理由是，网上没有，或者网上找到的东西跟本人需要的不一样时才会写博客。&lt;br/&gt;有的话就不写了，以免都是同样的东西，所以本人更新的博客并不算多，基本很久才一篇。&lt;br/&gt;但好像这样想并不对，写博客无论是什么内容，不仅方便自己学习也可以方便他人，&lt;br/&gt;所以以后应该更新频率会好点吧希望。&lt;/p&gt;
&lt;p&gt;回到正题，注解有三个主要的东西&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注解定义（Annotation）&lt;/li&gt;
&lt;li&gt;注解类型（ElementType）&lt;/li&gt;
&lt;li&gt;注解策略（RetentionPolicy）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;先来看看注解定义，很简单&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 主要的就是 @interface  使用它定义的类型就是注解了，就跟class定义的类型是类一样。
public @interface Base64DecodeStr {
    /**
     * 这里可以放一些注解需要的东西
     * 像下面这个count()的含义是解密的次数，默认为1次
     */
    int count() default 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再来看看注解类型&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 注解类型其实就是注解声明在什么地方
public enum ElementType {
    TYPE,               /* 类、接口（包括注释类型）或枚举声明  */
    FIELD,              /* 字段声明（包括枚举常量）  */
    METHOD,             /* 方法声明  */
    PARAMETER,          /* 参数声明  */
    CONSTRUCTOR,        /* 构造方法声明  */
    LOCAL_VARIABLE,     /* 局部变量声明  */
    ANNOTATION_TYPE,    /* 注释类型声明  */
    PACKAGE             /* 包声明  */
}

// 这个Target就是这么使用的
// 现在这个注解，本人希望它只能声明在方法上还有参数上，别的地方声明就会报错
@Target({ElementType.METHOD, ElementType.PARAMETER})
public @interface Base64DecodeStr {
    int count() default 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后再来看看注解策略&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public enum RetentionPolicy {
    SOURCE,  /* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了*/
    CLASS,   /* 编译器将Annotation存储于类对应的.class文件中。默认行为  */
    RUNTIME  /* 编译器将Annotation存储于class文件中，并且可由JVM读入 */
}

// 一般用第三个，RUNTIME，这样的话程序运行中也可以使用
@Target({ElementType.METHOD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
public @interface Base64DecodeStr {
    int count() default 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此为止，一个注解就定义好了。但是在什么时候工作呢，这时我们就需要写这个注解的解析了。&lt;br/&gt;然后想想，定义这个注解的目的是，想直接在接口使用参数就是明文，所以应该在进入接口之前就把密文解密回明文并放回参数里。&lt;br/&gt;这一步有什么好办法呢，这时候就轮到下一个主角登场了，它就是&lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;22--handlermethodargumentresolver&quot;&gt;2.2 HandlerMethodArgumentResolver&lt;/h3&gt;
&lt;p&gt;关于HandlerMethodArgumentResolver的作用和解析，官方是这么写的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Strategy interface for resolving method parameters into argument values in
 * the context of a given request.
 * 翻译了一下
 * 策略接口，用于在给定请求的上下文中将方法参数解析为参数值
 * @author Arjen Poutsma
 * @since 3.1
 * @see HandlerMethodReturnValueHandler
 */
public interface HandlerMethodArgumentResolver {

        /**
         * MethodParameter指的是控制器层方法的参数
         * 是否支持此接口
         * ture就会执行下面的方法去解析
         */
        boolean supportsParameter(MethodParameter parameter);

        /**
         * 常见的写法就是把前端的参数经过处理再复制给控制器方法的参数
         */
        @Nullable
        Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以这个接口，是很重要的，想想SpringMVC为何在控制器写几个注解，就能接收到参数，这个接口就是功不可没的。&lt;br/&gt;像常见的@PathVariable 就是用这个接口实现的。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1150097/202004/1150097-20200404233822953-1854453793.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;本人的理解是，实现这个接口，就能在前端到后端接口之间处理方法和参数，所以刚好满足上面的需求。&lt;br/&gt;其实这个接口也是属于SpringMVC源码里面常见的一个，读者依然也可自行了解下，&lt;br/&gt;目前本人还没有准备要写Spring读源码的文章，因为本人也还没系统的去看过，或许以后本人看了就会更新有关博客。&lt;/p&gt;
&lt;p&gt;继续，有了这样的接口就可以用来写解析自定义注解了，细心的同学可以发现，在这里写注解解析，&lt;br/&gt;那么这个注解就只能是在控制层起作用了，在服务层甚至DAO层都用不了，所以如果想全局用的话，&lt;br/&gt;本人想到的是可以用AOP切一下，把需要用到的地方都切起来就可以了。&lt;/p&gt;
&lt;p&gt;实现HandlerMethodArgumentResolver接口来写解析。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Base64DecodeStrResolver implements HandlerMethodArgumentResolver {

    private static final transient Logger log = LogUtils.getExceptionLogger();

    /**
     * 如果参数上有自定义注解Base64DecodeStr的话就支持解析
     */
    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.hasParameterAnnotation(Base64DecodeStr.class) 
                || parameter.hasMethodAnnotation(Base64DecodeStr.class);
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
         NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
        /**
         * 因为这个注解是作用在方法和参数上的，所以要分情况
         */
        int count = parameter.hasMethodAnnotation(Base64DecodeStr.class)
                ? parameter.getMethodAnnotation(Base64DecodeStr.class).count()
                : parameter.getParameterAnnotation(Base64DecodeStr.class).count();
        /**
         * 如果是实体类参数，就把前端传过来的参数构造成一个实体类
         * 在系统中本人把所有实体类都继承了BaseEntity
         */
            if (BaseEntity.class.isAssignableFrom(parameter.getParameterType())) {
                Object obj = parameter.getParameterType().newInstance();
                webRequest.getParameterMap().forEach((k, v) -&amp;gt; {
                    try {
                        BeanUtils.setProperty(obj, k, decodeStr(v[0], count));
                    } catch (Exception e) {
                        log.error(&quot;参数解码有误&quot;, e);
                    }
                });
                // 这里的return就会把转化过的参数赋给控制器的方法参数
                return obj;
                // 如果是非集合类，就直接解码返回
            } else if (!Iterable.class.isAssignableFrom(parameter.getParameterType())) {
                return decodeStr(webRequest.getParameter(parameter.getParameterName()), count);
            }
        return null;
    }

    /**
     * Base64根据次数恢复明文
     *
     * @param str   Base64加密*次之后的密文
     * @param count *次
     * @return 明文
     */
    public static String decodeStr(String str, int count) {
        for (int i = 0; i &amp;lt; count; i++) {
            str = Base64.decodeStr(str);
        }
        return str;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后注册一下这个自定义的Resolver。&lt;br/&gt;这里就不用配置文件注册了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class WebConfig extends WebMvcConfigurationSupport {
    //region 注册自定义HandlerMethodArgumentResolver
    @Override
    public void addArgumentResolvers(List&amp;lt;HandlerMethodArgumentResolver&amp;gt; resolvers) {
        resolvers.add(base64DecodeStrResolver());
    }

    @Bean
    public Base64DecodeStrResolver base64DecodeStrResolver() {
        return new Base64DecodeStrResolver();
    }
    //endregion
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在控制器层使用注解。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 先试试给方法加注解
 */
@Base64DecodeStr 
public void login(@NotBlank(message = &quot;用户名不能为空&quot;)  String username,
                   @NotBlank(message = &quot;密码不能为空&quot;) String password) {
            System.out.println(username);
            System.out.println(password);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看效果&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前端传值&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1150097/202004/1150097-20200404231114195-1171522897.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;后端接收&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1150097/202004/1150097-20200404231207764-1782030489.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至此整个功能上已经实现了，我们来看下关键api&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 这个就是一个参数，控制层的方法参数
MethodParameter parameter
    // 常用方法
    hasMethodAnnotation()  是否有方法注解
    hasParameterAnnotation()  是否有参数注解
    getMethodAnnotation()  获取方法注解(传入Class可以指定)
    getParameterAnnotation() 获取参数注解(传入Class可以指定)
    getParameterType()  获取参数类型


// 这个可以理解为是前端传过来的东西，里面可以拿到前端传过来的密文，也就是初始值，没有被处理过的
NativeWebRequest webRequest
    // 常用方法 其实这几个都是同一个 基于map的操作
    getParameter()  
    getParameterMap()
    getParameterNames()
    getParameterValues()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;23-深入探讨&quot;&gt;2.3 深入探讨&lt;/h3&gt;
&lt;p&gt;上面的例子是注解在方法上的，接下来试试注解在参数上。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 注解一个参数
 */
public void login(@NotBlank(message = &quot;用户名不能为空&quot;) @Base64DecodeStr  String username,
                   @NotBlank(message = &quot;密码不能为空&quot;) String password) {
            System.out.println(username);
            System.out.println(password);
}
/*****************输出******************************/
username
WTBkR2VtTXpaSFpqYlZFOQ==

/**
 * 注解两个参数
 */
public void login(@NotBlank(message = &quot;用户名不能为空&quot;) @Base64DecodeStr  String username,
                   @NotBlank(message = &quot;密码不能为空&quot;) @Base64DecodeStr String password) {
            System.out.println(username);
            System.out.println(password);
}
/*****************输出******************************/
username
password
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见注解在参数上也能用，接下来再来看看，同时注解在方法上和参数上，想一下。&lt;br/&gt;假设方法上的注解优先，参数上的注解其次，会不会被解析两次，&lt;br/&gt;也就是说，密文先被方法注解解析成明文，然后之后被参数注解再次解析成别的东西。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 注解方法 注解参数
 */
@Base64DecodeStr
public void login(@NotBlank(message = &quot;用户名不能为空&quot;) @Base64DecodeStr  String username,
                   @NotBlank(message = &quot;密码不能为空&quot;) @Base64DecodeStr String password) {
            System.out.println(username);
            System.out.println(password);
}
/*****************输出******************************/
username
password
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出的是正确的明文，也就是说上面的假设不成立，让我们康康是哪里的问题。&lt;/p&gt;
&lt;p&gt;回想一下，在解析的时候，我们都是用的&lt;code&gt;webRequest&lt;/code&gt;的getParameter，而&lt;code&gt;webRequest&lt;/code&gt;里面的值是从前端拿过来的，&lt;br/&gt;所以decodeStr解密都是对前端的值解密，当然会返回正确的内容(明文)，所以即使是方法注解先解密了，它解密的是前端的值，&lt;br/&gt;然后再到属性注解，它解密的也是前端的值，不会出现属性注解解密的内容是方法注解解密出来的内容。&lt;br/&gt;从这点来看，确实是这么一回事，所以即使方法注解和参数注解一起用也不会出现重复解密的效果。&lt;/p&gt;
&lt;p&gt;但是，这只是一个原因，一开始本人还没想到这个，然后就好奇打了断点追踪下源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
@Nullable
public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
                 // 获取参数的resolver，参数的定位是控制器.方法.参数位置 ，所以每个parameter都是唯一的
                 // 至于重载的啊，不知道没试过，你们可以试下，XD
                HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);
                if (resolver == null) {
                  throw new IllegalArgumentException(&quot;Unsupported parameter type [&quot; +
                  parameter.getParameterType().getName() + &quot;]. supportsParameter should be called first.&quot;);
                }
                  return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
}

@Nullable
private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {
                // argumentResolverCache是一个缓存，map，
                // 从这里可以看出，每个控制器方法的参数都会被缓存起来，
                HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);
                if (result == null) {
                        for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) {
                            // 调用supportsParameter看看是否支持
                            if (resolver.supportsParameter(parameter)) {
                                result = resolver;
                                // 一个参数可以有多个resolver 
                                this.argumentResolverCache.put(parameter, result);
                                break;
                                }
                        }
                }
                return result;          
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以问题再细化一点，当我们同时注解方法和参数的时候，会调用几次getArgumentResolver()呢，&lt;br/&gt;为了便于观察，本人将注解传不同的参数。&lt;br/&gt;在那之前，先放点小插曲，就是在调试的时候发现的问题&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 注解方法
 */
@Base64DecodeStr( count = 10)
public void login(@NotBlank(message = &quot;用户名不能为空&quot;) String username,
                   @NotBlank(message = &quot;密码不能为空&quot;)  String password) {
            System.out.println(username);
            System.out.println(password);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进去前&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1150097/202004/1150097-20200405000243862-496360814.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;parameter是获取不到方法上这个自定义注解的。&lt;br/&gt;当代码往下走，走到supportsParameter的时候&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1150097/202004/1150097-20200405000407312-2138777656.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;此时又有了，无语。&lt;br/&gt;什么原因本人暂时没找到。&lt;/p&gt;
&lt;p&gt;言归正传，我们继续调试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 注解方法 注解全部参数
 */
@Base64DecodeStr( count = 30)
public void login(@NotBlank(message = &quot;用户名不能为空&quot;) @Base64DecodeStr(count = 10)  String username,
                   @NotBlank(message = &quot;密码不能为空&quot;) @Base64DecodeStr(count =20) String password) {
            System.out.println(username);
            System.out.println(password);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看是先走方法注解还是参数注解。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一次进来&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1150097/202004/1150097-20200405000937302-1395304547.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;可以看到是第一个参数username&lt;/li&gt;
&lt;li&gt;第二次进来&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1150097/202004/1150097-20200405001138684-1178179507.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;依然是第一个参数username&lt;/li&gt;
&lt;li&gt;第三次进来&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1150097/202004/1150097-20200405001255974-975921134.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;看到是第二个参数password&lt;/li&gt;
&lt;li&gt;第四次进来&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1150097/202004/1150097-20200405001349649-1910780612.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;也是第二个参数password&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以可以看到，根本就没有走方法注解，或者说方法注解会走两次，参数注解一个一次，所以总共四次，这也没问题。&lt;br/&gt;这是怎么回事呢。要是不走方法注解，那方法注解怎么会生效呢，后面我找到了原因&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  /**
   * 原来是因为这里，虽然不是因为方法注解进来的，但是这里优先取的是方法注解的值，
   * 所以如果想让属性注解优先的话这里改一下就行
   */
  int count = parameter.hasMethodAnnotation(Base64DecodeStr.class)
                ? parameter.getMethodAnnotation(Base64DecodeStr.class).count()
                : parameter.getParameterAnnotation(Base64DecodeStr.class).count();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以真相大白了，如果方法注解和属性注解同时加上的话，会执行四次getArgumentResolver()，&lt;br/&gt;其中只会调用两次supportsParameter()，因为每个参数第二次都直接从map取到值了就不再走supportsParameter()了。&lt;/p&gt;

&lt;p&gt;至此我们完成了本次从前端到后端的旅途。&lt;br/&gt;简单总结一下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注解
&lt;ul&gt;&lt;li&gt;定义：@interface&lt;/li&gt;
&lt;li&gt;类型：TYPE，FIELD，METHOD，PARAMETER，CONSTRUCTOR，LOCAL_VARIABLE，ANNOTATION_TYPE，PACKAGE&lt;/li&gt;
&lt;li&gt;策略：SOURCE，CLASS，RUNTIME&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HandlerMethodArgumentResolver
&lt;ul&gt;&lt;li&gt;作用：像拦截器一样，在前端到后端中间的关卡&lt;/li&gt;
&lt;li&gt;两个方法
&lt;ul&gt;&lt;li&gt;supportsParameter：是否支持使用该Resolver&lt;/li&gt;
&lt;li&gt;resolveArgument：Resolver想要做的事&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后关于注解解析部分也不够完善，比如如果参数是集合类型的话应该怎么处理，这都是后续了。&lt;/p&gt;
&lt;p&gt;本篇内容都是本人真实遇到的问题并记录下来，从开始想要加密加密参数到想办法去实现这个功能，&lt;br/&gt;这么一种思路，希望能给新人一点启示，当然本人本身也还需要不断学习，不然都找不到工作了，我只能边忙毕设边挤时间复习了。&lt;br/&gt;人一惆怅话就多了，嘿嘿，不啰嗦了，现在是夜里两点，准备睡了。&lt;/p&gt;
</description>
<pubDate>Sat, 04 Apr 2020 16:55:00 +0000</pubDate>
<dc:creator>yellowgg</dc:creator>
<og:description>SpringBoot 自定义注解 参数加密解密 HandlerMethodArgumentResolver</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yellowgg/p/12635553.html</dc:identifier>
</item>
<item>
<title>SpringCloud入门(七)： Zuul 简介与使用 - 愚蠢的猴子</title>
<link>http://www.cnblogs.com/jiangyaxiong1990/p/12404292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangyaxiong1990/p/12404292.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;Zuul 简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Zuul 微服务网关是为Spring Cloud Netflix提供动态路由,监控,弹性,安全等服务的框架。可以和Eureka、Ribbon、Hystrix等组件配合使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Zuul 主要功能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、 身份认证与安全：识别每个资源的验证要求，并拒绝那些与要求不符的请求。&lt;/p&gt;
&lt;p&gt;　　2、审查与监控：在边缘位置追踪有意义的数据和统计结果，从而为我们带来精确的生产视图。&lt;/p&gt;
&lt;p&gt;　　3、动态路由：动态地将请求路由到不同的后端集群；&lt;/p&gt;
&lt;p&gt;　　4、压力测试：逐渐增加指向集群的流量，以了解性能；&lt;/p&gt;
&lt;p&gt;　　5、为每一种负载类型分配对应容量，并弃用超出限定值的请求；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Zuul 带了什么优势&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　没有使用网关服务的时候：&lt;/p&gt;
&lt;p&gt;　　1、客户端会多次请求不同的微服务，增加了客户端的复杂性。&lt;/p&gt;
&lt;p&gt;　　2、存在跨域请求，在一定场景下处理相对复杂。&lt;/p&gt;
&lt;p&gt;　　3、认证复杂，每个服务都需要独立认证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/403345/202003/403345-20200303171936993-1652835262.png&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;144&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　使用服务网关后：&lt;/p&gt;
&lt;p&gt;　　1、易于监控，可在微服务网关收集监控数据并将其推送到外部系统进行分析。&lt;/p&gt;
&lt;p&gt;　　2、易于认证，可在微服务网关上进行认证，然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。&lt;/p&gt;
&lt;p&gt;　　3、减少了客户端与各个微服务之间的交互次数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/403345/202003/403345-20200303172320210-1262889266.png&quot; alt=&quot;&quot; width=&quot;393&quot; height=&quot;212&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; Zuul 入门&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!--1. 配置pom文件，引入spring-cloud-starter-netflix-zuul包--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-zuul&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- 2. 配置属性文件--&amp;gt;&lt;span&gt;
server.port&lt;/span&gt;=9004&lt;span&gt;
#注册到eureka服务端的微服务名称
spring.application.name&lt;/span&gt;=ms-gateway-&lt;span&gt;zuul
#注册到eureka服务端的地址
eureka.client.service&lt;/span&gt;-url.defaultZone=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:9000/eureka/&lt;/span&gt;
&lt;span&gt;#点击具体的微服务，右下角是否显示ip
eureka.instance.prefer&lt;/span&gt;-ip-address=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
#显示微服务的名称
eureka.instance.instance&lt;/span&gt;-id=ms-gateway-zuul-9004

&amp;lt;!-- 3. 在Spring的启动入口添加@EnableZuulProxy注解 --&amp;gt;&lt;span&gt;
@SpringBootApplication
@EnableZuulProxy
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ZuulApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ZuulApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过Url访问：http://localhost:9004/&lt;span&gt;zuul&lt;/span&gt;/ms-consumer-user/userController/getUserInfo/{loginName}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Zuul 的常规配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、设置访问路径，默认值为zuul &lt;/p&gt;
&lt;p&gt;　　zuul.servlet-path=/zuul&lt;/p&gt;
&lt;p&gt;2、关闭通过微服务名称路访问（避免暴露服务名称）&lt;/p&gt;
&lt;p&gt;　　全部设置：zuul.ignored-services=*  &lt;/p&gt;
&lt;p&gt;　　分服务设置：zuul.ignored-services=ms-provider-order,ms-consumer-user&lt;/p&gt;
&lt;p&gt;3、通过服务实例指定映射路径&lt;/p&gt;
&lt;p&gt;　　zuul.routes.ms-provider-order=/order-service/**&lt;/p&gt;
&lt;p&gt;　　访问：http://localhost:9004/zuul/order-service/userController/getUserInfo/{loginName}&lt;/p&gt;
&lt;p&gt;4、通过服务的serviceId指定映射路径&lt;/p&gt;
&lt;p&gt;　　zuul.routes.use-routing.serviceId=ms-provider-order&lt;/p&gt;
&lt;p&gt;　　zuul.routes.use-routing.path=/order-service/**&lt;/p&gt;
&lt;p&gt;5、通过url指定映射路径(路由不会作为HystrixCommand执行，同时也不能使用Ribbon来负载均衡多个URL)&lt;/p&gt;
&lt;p&gt;　　zuul.routes.use-routing.url=http://localhost:8004/&lt;/p&gt;
&lt;p&gt;　　zuul.routes.use-routing.path=/order-service/**&lt;/p&gt;
&lt;p&gt;6、统一设置路由前缀&lt;/p&gt;
&lt;p&gt;　　全局设置：zuul.prefix=/order-api&lt;/p&gt;
&lt;p&gt;　　　　　　　&lt;span&gt;zuul.strip-prefix=true&lt;/span&gt;（是否剥离前缀，默认是true）&lt;/p&gt;
&lt;p&gt;　　　　　　　zuul.routes.use-routing.serviceId=ms-provider-order&lt;/p&gt;
&lt;p&gt;　　　　　　　zuul.routes.use-routing.path=/order-service/**&lt;/p&gt;
&lt;p&gt;　　　　　　　访问：http://localhost:9004/order-api/order-service/userController/getUserInfo/{loginName}&lt;/p&gt;
&lt;p&gt;　　分服务设置：zuul.strip-prefix=true&lt;/p&gt;
&lt;p&gt;　　　　　　　　zuul.routes.use-routing.serviceId=ms-provider-order&lt;/p&gt;
&lt;p&gt;　　　　　　　　zuul.routes.use-routing.path=/order-service/**&lt;/p&gt;
&lt;p&gt;　　　　　　　　zuul.routes.use-routing.stripPrefix=true&lt;/p&gt;
&lt;p&gt;　　　　　　　　访问：http://localhost:9004/zuul/order-service/userController/getUserInfo/{loginName}&lt;/p&gt;
&lt;p&gt;7、过滤敏感路径&lt;/p&gt;
&lt;p&gt;　　zuul.ignored-patterns=/**/admin/**&lt;/p&gt;
&lt;p&gt;8、过滤敏感头信息（通过zuul网关的时候，会过滤掉敏感的头信息，比如cookie等其他的）&lt;/p&gt;
&lt;p&gt;　　全局设置：zuul.sensitive-headers=&lt;/p&gt;
&lt;p&gt;　　分模块设置：zuul.routes.use-routing.serviceId=ms-provider-order&lt;/p&gt;
&lt;p&gt;　　　　　　　　zuul.routes.use-routing.path=/order-service/**&lt;/p&gt;
&lt;p&gt;　　　　　　　　zuul.routes.use-routing.sensitiveHeaders=&lt;/p&gt;

</description>
<pubDate>Sat, 04 Apr 2020 16:48:00 +0000</pubDate>
<dc:creator>愚蠢的猴子</dc:creator>
<og:description>Zuul 简介 Zuul 微服务网关是为Spring Cloud Netflix提供动态路由,监控,弹性,安全等服务的框架。可以和Eureka、Ribbon、Hystrix等组件配合使用。 Zuul</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiangyaxiong1990/p/12404292.html</dc:identifier>
</item>
<item>
<title>《软件开发者路线图——从学徒到高手》读书笔记 - 小蒋不素小蒋</title>
<link>http://www.cnblogs.com/xjnotxj/p/12635512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjnotxj/p/12635512.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;略&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;1、多种语言&quot;&gt;1、多种语言&lt;/h3&gt;
&lt;p&gt;第一门语言学得越好，下一门语言学起来就越容易。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;鄙人大二学的 JAVA，后来再去学 JS 就感觉好简单（虽然 js 的坑真的多）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;每一种语言都为你提供了使用不同模式来解决问题的机会&lt;/strong&gt;。在逐渐超越第一门语言的过程中，你应该寻找机会去学习一些采用迥然不同的方法来解决问题的语言。惬意于面向对象语言的学徒应该探究一下函数式（ functional）编程语言。畅然于动态类型的学徒应该钻研一下静态类型。安逸于服务器端编程的学徒应该考查一下用户界面设计。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我的目标就是全栈丫。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;你不应该“嫁”给任何特定技术&lt;/strong&gt;，而应该有足够宽的技术背影和经验基础，使自己能针对特定的情景选择好的解决方案。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我是很讨厌讨论什么语言最好的，每个使用场景都有最适合它的语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2、初学者心态&quot;&gt;2、初学者心态&lt;/h3&gt;
&lt;p&gt;通常，每一步都该有进门的感觉。这是&lt;strong&gt;初学者的心——一种正在“成为”的状态&lt;/strong&gt;。——铃木俊隆，《Zen Mind,Beginner's Mind》（禅者的初心）&lt;/p&gt;
&lt;p&gt;正如 Yoda 在电影《The Empire Strikes Back》（星球大战 2：帝国反击战）中所说的：“&lt;strong&gt;你必须忘记已经学到的东西&lt;/strong&gt;。”（You must unlearn what you have learned）&lt;/p&gt;
&lt;p&gt;有多少次你担心被人觉得愚蠢而没有尝试新东西？有多少回你担心被人认为幼稚而压抑了主动性？……心理学家 Abraham Maslow 发现，&lt;strong&gt;那些能把潜力发挥到显著水平的人身上都有一种孩童般的品质&lt;/strong&gt;。 Ashleigh Montagu 使用术语“婴儿化”（ neotany）（来自词语&quot; neonate&quot;，新生儿的意思）。&lt;/p&gt;
&lt;p&gt;发生在朋友或自己身上的一些事，我们认为愚蠢，紧锁双眉；但同样的事如果发生在世界著名的天才身上，我们只会觉得古怪，一笑置之；永远不要忘记：&lt;strong&gt;可以随便犯蠢的自由很可能是打开天才成功之门的钥匙&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这就是 大智若愚 吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在新知识有机会渗入到大脑之前，你必须设法避免将新旧知识混合在一起，并以初学者的心态着手解决新问题。这可能意味着短期内生产率会降低一些，以期在掌握新方法之后能获得技能水平的飞跃。&lt;/p&gt;
&lt;p&gt;学习新东西是痛苦的，特别当你在顶着压力而且几乎没有人指导的情况下学习。尽管如此，正如运动员必须忍受艰苦训练后的肌肉痛楚，软件开发者需要忍受学习新东西后的神智错乱。&lt;/p&gt;
&lt;h3 id=&quot;3、新人&quot;&gt;3、新人&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;尽管你缺乏经验（而且恰恰因为你缺乏经验），你会为团队带来一些独特的品质，包括富有感染力的激情&lt;/strong&gt;。不要让任何人压抑了你对软件工艺的兴奋——它是一种宝贵的财富，它将加速你的学习。作为软件开发者，你将不可避免地成为团队一部分，并在此基础上展开工作。在任何组织结构中，都会有一种遵循规范的趋向，对新人而言尤其如此。大多数团队都不会对技术有过热的激情。可以肯定，他们都专注于交付下一个项目，或者改善软件开发周期中的某些让他们头痛的方面。因此，&lt;strong&gt;充满激情的学徒常常会屈服于“做人要低调”的外界压力。他们要么完全压抑自己的热情，要么仅在日常工作之余才让它表现出来。在相对完善的团队中释放激情当然是有风险的。&lt;/strong&gt; 如果团队士气较低或者团队不欢迎新人，你可能在背后遭遇白眼。对那些认为竞争力比学习能力更重要的人来说，毫无疑问，你会给他们留下不好的印象，特别当你暴露出自己无知的时候。跟任何模式一样，这一模式也不应被盲目运用。团队动态（ team dynamics）永远都是需要考虑的因素。&lt;strong&gt;如果你发现自己处在一个无法接受你激情的团队中，那么你将需要想些办法来养护自己的激情。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;作者的观察真的细致，我之前也有类似的感悟，不过在中国，刚进入公司的新人，真的有激情，也尽量低调点，对自己大家都好。&lt;br/&gt;不过这让我想到另一个新词：奋斗逼。（这个是贬义，当然跟上面提到的有激情不一样）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;思想的多样性应看作集体智慧的关键因素。&lt;/strong&gt;对航空母舰舰队集体心理的一次有趣的研究显示：要安全地操纵一艘战斗机不断从它上面起降的巨船，需要复杂的、相互配合的行动，而新人在这类行动中扮演重要角色。&lt;strong&gt;研究者发现，一个由不同经验水准的人组成的团队更加健康。如果把不同的经验水平关联到一起，比如当脑子里没有任何“想当然”的新手与认为自己已纵观全貌的老前辈们更加频繁地打交道时，大家对问题的理解都会加深。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;确实，一个健康的团体还是参差多态的好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;随着你慢慢过渡到熟练工的角色，你将变得越来越不依赖于这些技能，慢慢地别人开始基于你的名声、你以前参与过的项目，以及你能带给团队的更深层品质来雇佣你。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;古有：始于颜值，陷于才华，忠于人品。&lt;br/&gt;今有：始于技能，陷于名声，忠于品质。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;专家技能是我们走的这条漫漫长路的副产品，但不是目的地。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;追求卓越，成功就会主动找上你。—— 《三傻》电影&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;4、无知&quot;&gt;4、无知&lt;/h3&gt;
&lt;p&gt;如果你想让他们安心，那也应该通过你的学习能力，而不是通过假装知道自己并不知道的东西。这样，你的&lt;strong&gt;名声将建立在你的学习能力上&lt;/strong&gt;，而不是你已经知道的事情上。&lt;strong&gt;暴露无知，最简单的方法就是问问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选出一种技能、工具或技术，&lt;strong&gt;积极地填补跟它有关的知识空白&lt;/strong&gt;。采用一种对你最有效的方法来做这件事。对于某些人，最好的方法可能是阅读能接触到的所有文献和 FAQ，来获得&lt;strong&gt;知识概览&lt;/strong&gt;。其他人则可能觉得直接动手构造一个“质脆玩具”才是理解一样东西的最有效途径。不管哪种方法适合你，都不要忘了问问周围的“同道中人”和指导者，看是否有人已经掌握了这项技能并愿意分享所学。有时其他人也可能在学习这项技能，跟他们一起工作你会获得更快的进步。到某个时刻，你将在这个新领域达到令人满意的能力水准，这时你就可以做决定了，是继续深入挖掘下去更有成效呢，还是应将注意力转到其他的技能空白上。每天只有 24 小时，你无法将每项技能都研磨到很高水平，因此你必须学会在它们中间做必要的权衡。&lt;/p&gt;
&lt;p&gt;它不只是征服先前未知的高峰，还要一步一步地走出一条新的道路。&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;1、技重于艺&quot;&gt;1、技重于艺&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;我愿意将编程说成一种&lt;code&gt;技艺&lt;/code&gt;，技艺本身也是一种艺术，但它不是&lt;code&gt;美术&lt;/code&gt;。技艺的意思是：使用可能带有装饰性的手法来制作有用的对象。美术的意思则是制作东西纯粹为了使之美丽&lt;/strong&gt;。——Richard Stallman 在&quot;Art and Programming&quot;（艺术与编程）&lt;/p&gt;
&lt;p&gt;作为技师，你的首要工作是构建能满足他人需要的东西，而不是沉迷于艺术展现。毕竟，&lt;strong&gt;世上不该有挨饿的技师。&lt;/strong&gt; 如果你挨饿了，因为你太像一个艺术家，你创造的东西太美以致在现实中无法交付，那你就是离开了技艺。&lt;/p&gt;
&lt;p&gt;我们为客户构建的东西“可以”是美的，但“必须”是有用的。&lt;br/&gt;其中的一部分就是培养在必要时牺牲美丽来换取效用的能力。&lt;br/&gt;&lt;strong&gt;功用和美好并不对立&lt;/strong&gt;，而是相辅相成。&lt;/p&gt;
&lt;h3 id=&quot;2、持续动力&quot;&gt;2、持续动力&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;”做你喜爱的事，钱自然会来。”&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我喜欢睡觉……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“如果你认为一样东西有趣，你就能学到有趣的东西。”&lt;/p&gt;
&lt;p&gt;上帝只让一小部分人开开心心地通过自己喜爱的工作谋生。感谢上帝，让我成为其中之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;受到来自消费者至上主义者和速成社会的塞壬歌声的诱惑，我们有时会选择一种只会带来成功表象和满意幻影的行动过程。&lt;/strong&gt;—— George Leonard，《 Mastery》（精通）&lt;/p&gt;
&lt;p&gt;大多数人把提升到管理职位等同于成功。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;远离幻象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;聪颖而且努力的学徒千万不要对自己的成功自鸣得意。在软件开发领域，超越平庸是很容易的，因为&lt;strong&gt;有太多的人只超出平均曲线一点点就开始满足了。&lt;/strong&gt;你必须去追寻那些技艺精湛、学徒甚至无法想象其水平的其他团队、组织、熟练工和师傅，向他们学习，以此来抗争趋于平庸的倾向。&lt;/p&gt;
&lt;h3 id=&quot;3、另辟蹊径&quot;&gt;3、另辟蹊径&lt;/h3&gt;
&lt;p&gt;不要因为他们没有走在你所走的路上，就认为他们已经迷失了。&lt;/p&gt;
&lt;p&gt;即使永远地离开原来的道路，在这一路上你所形成的价值和原则也将一直陪伴着你。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一切经历皆有用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;遗憾的是，传统的软件组织不一定会如此欢迎。他们常常把这些弯路看作职业生涯中的缺口，因此你必须为此做正当的解释。他们会期望你能给出一个符合他们价值系统的合理解释，&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;你很难想象一个程序员职业生涯中途出现跑出去当了几年厨子给面试官带来的坏印象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;4、学徒与师傅&quot;&gt;4、学徒与师傅&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;不知而不知其不知者，愚者也——避之！&lt;br/&gt;不知而知其不知者，惑者也——授之！&lt;br/&gt;知之而不知其知之者，寐者也——醒之！&lt;br/&gt;知之而知其知之者，觉者也——从之！&lt;br/&gt;—— Isabel Burton（ 1831— 1896）女士在《 The Life of Captain Sir Richard F. Burton》（ Richard F. Burton 上尉的一生）一书中引用的阿拉伯谚语&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学徒向技师学习，技师也向学徒们学习。激情洋溢的初学者不仅能恢复技师的活力，还能从外界带来新的思想来挑战更有经验的技师。精心挑选的学徒甚至能使师傅变得更有成效。&lt;br/&gt;俗话说：“一个人教的时候，两个人在学。”&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;所以从辩证的角度来看，学徒也是师傅的师傅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;顶多，你可以说这个人技能水平比你高。但这并不足以证明她技艺精通。&lt;strong&gt;一个人走在了你的前面并不能证明她是个师傅。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在那一天到来之前，发现精通技艺的最好方法只能是考察一个人和她的学徒们的工作质量。&lt;br/&gt;仅仅是天才并不能成就精通，但如果一个人可以培训他人，使之达到或超越自己的才华，那就是一种证据，证明此人有师傅的潜力。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;能把别人教的很厉害的人，自己一定也很厉害。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;h3 id=&quot;1、只求最差&quot;&gt;1、只求最差&lt;/h3&gt;
&lt;p&gt;宁为狮尾，不为狐头！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;还有另一句相反的：宁做鸡头，不做凤尾。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;让周围多些水平比你更高的开发者。找一个更强大的团队，在那里让自己成为最弱的成员并拥有成长的空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记住，被一位潜在的指导者拒绝或者认为你奇怪的概率并不高，而潜在的回报却是巨大的。即使那人没兴趣收你为全职学徒，邀请她出来共进午餐也会是很有价值的时间和金钱投资。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多多请教。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这类任务包括维护构建系统，产品支持，响应维护需求，bug 修正，代码复查，消除技术债务（technical debt），搭建项目 wiki，更新文档，为其他人的想法充当传声筒，等等。通常，你会关注风险更低的系统边缘部分，而不是常常带有大量依赖性和极高复杂度的核心。Jean Lave 和 Etienne Wenger 观察了不同行业中的学徒，发现“在工作流程中，新手的任务往往被置于分支的末尾，而不是一连串工作片段的中间”（《Situated Learning》（情景化学习），第 110 页）。&lt;strong&gt;这类边缘任务会使团队受益，对作为学徒的你也有好处，因为这些杂务在学校的课程中常常被略过了，做一做能填补知识中的漏洞&lt;/strong&gt;。当你成为熟练工时，这种体验还是能带来帮助，因为很多带你的师傅都明白：有个人去做单调的工作是多么重要。毕竟，如果没人打扫地面，那么富有魅力的工作也无法做出来，因为团队已深陷脏乱之中。&lt;/p&gt;
&lt;p&gt;被你的团队拖延了几个月的最邋遢的任务是什么？它应该是所有人都抱怨，却没有人愿意解决的那个。你去解决它。&lt;strong&gt;不要捂着鼻子强迫自己去做；看自己能否找到一种超出人们预期并为自己带来乐趣的方式，创造性地解决这个问题&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;2、自我评估&quot;&gt;2、自我评估&lt;/h3&gt;
&lt;p&gt;他们的同名论文中指出的：&lt;strong&gt;技艺不精的人常常不知道自己技艺不精。再者，越是技艺不精，你越不善于评估自己和他人的技能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;他们希望，如果曾经有一支人数和经验水平都差不多的团队在过去能完成一件差不多的事情，那么今天的团队或许也能完成。不幸的是，软件开发中的技能水平范围很广，在我们当中，最优秀的那些人可以稀松平常地做出大多数人认为不可能的事情。此外，&lt;strong&gt;多数程序员都认为自己的水平超出平均。悲惨的事实是：由于下图所示的不规则的技能水平分布，大多数程序员实际上是低于平均水平的&lt;/strong&gt;。这听起来有点反直觉，但你可以设想这样一个比方：现在我们两个人， Dave 和 Ade 坐在桌子边上，然后 Bill Gates 过来加入我们，突然之间坐在桌子旁的“大多数”人的薪水都低于平均水平了。也就是说，在编程技能曲线上处于极远端的那些人倾斜了整个分布。&lt;/p&gt;
&lt;h3 id=&quot;3、天赋与性格&quot;&gt;3、天赋与性格&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;天赋常常被误解。它并不是超常的智力，而是一种性格。&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;1、不断实践&quot;&gt;1、不断实践&lt;/h3&gt;
&lt;p&gt;“一个人一旦停止了实践，她对技艺的精通就马上开始消退。”每一个不写程序的日子，你都是在不断远离熟练工的目标。“&lt;/p&gt;
&lt;p&gt;我们所知道的大师，不会仅为了做得更好而让自己专注于某项技能。实际情况是：他们热爱实践——并且正因为热爱实践所以才做得更好。事情总是相辅相成的，做得越好，他们就越喜欢反复不断实施这些基本的实践活动。——George Leonard，《Mastery》（精通）&lt;/p&gt;
&lt;p&gt;“刻意实践”（deliberate practice）。&lt;/p&gt;
&lt;h3 id=&quot;2、质脆玩具&quot;&gt;2、质脆玩具&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;我们都可以从编写随意的“玩具”程序中受益，编写玩具程序时，我们会设置一些人为的限制，从而将自己的能力推到极限。&lt;/strong&gt;——Donald Knuth，《The Art of Computer Programming》（中译本及双语本《计算机程序设计艺术》，机械工业出版社）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果来自失败的经验可以与来自成功的经验一样多，那么你需要一个相对私有的空间来寻求失败&lt;/strong&gt;。在抛球杂技中，抛三只球的表演者，如果从来没抛过五只球，那他就永远不会取得进步。而那些连续几个小时去拣落下的球直到拣得背疼的人，最终却能把技艺练好。同样的经验也适用于软件领域。正如抛三只球的表演者不会在正式的表演中抛五只球，软件开发者也需要一个安全的地方来犯错误。&lt;/p&gt;
&lt;p&gt;“质脆玩具”模式的其他例子包括像 Tetris 和 Tic-Tac-Toe 这样的游戏（&lt;strong&gt;我们的一位前同事有一种习惯：每学习一门新语言，就用它来编一个游戏&lt;/strong&gt;）、博客软件和 IRC 客户端。问题的本质在于构建玩具包含了对新事物的学习，而且提供机会让你在特殊的环境中加深对手中工具的理解，这个环境不仅安全（因为你是唯一或者最重要的用户），而且，即使跟最强大的商业产品比起来，你仍有余地来更好地服务自己作为一名用户的需求。&lt;/p&gt;
&lt;p&gt;你还是要记住：它们只是玩具，而且正因为这一点&lt;strong&gt;它们应该是有趣的&lt;/strong&gt;。如果它们没什么意思，那么当最初的热乎劲过去之后，它们将成为尘封的旧物，而你则将自己的精力关注到你真正乐于构建的东西上去了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我之前也想过并做过，我称之为 demo。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;3、开源项目&quot;&gt;3、开源项目&lt;/h3&gt;
&lt;p&gt;在研究一个开源项目时，要养成下载最新版代码的习惯（最好从它们的源码控制系统下载），这样你可以查阅它的历史，跟踪未来的发展。看一下代码库的结构，想一想为什么代码是那样组织的。看一看开发者组织代码模块的方式是否有一定的道理，拿它跟自己可能使用的方式比较一下。试着重构代码，从而理解为什么它的编码者做了那样的决定，同时想想如果你是那个编码的人，写出的代码将是什么样子。这不仅能让你更好地理解这些项目；还确保你能构建这些项目。如果你发现了做一件事的更好方法，你就完全可以为这个项目贡献代码了。在研究代码的过程中，你会不可避免地看到一些自己完全不同意的决策。问问自己，是否项目的开发者可能知道一些你不知道的东西，或者相反。考虑一下有没有可能这是一个历史遗留设计，需要重构一下；并考虑：为相关特性做个玩具实现是否有助于澄清问题。&lt;/p&gt;
&lt;p&gt;最终你将获得一个&lt;strong&gt;工具盒&lt;/strong&gt;，里面都是从其他人的代码中收集来的各种奇技。这会磨炼你更迅速、更快捷地解决小问题的能力。你将能处理别人认为不可能解决的问题，因为他们接触不到你的工具盒。看一看 Linus Torvalds 编写的 Git 分布式源码控制系统的代码，或者任何 Daniel J. Bernstein（众所周知的 djb）编写的代码。像 Linus 和 djb 这样的程序员偶尔会用到我们大多数人甚至从未听说过的数据结构和算法。他们并不是魔术师——跟大多数人相比，他们不过是花时间构造了更大更好的工具盒。开源的优势就在于你可以随意观看他们的工具盒，而且可以把他们的工具变成你自己的。软件开发领域的问题之一是缺少教师。&lt;strong&gt;不过多亏了诸如 sourceforge. net 和 GitHub 这些站点上开源项目的繁荣，你可以从全世界程序员社区中那些相对有代表性的代码范例中学习&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在《Programmers at Work》一书中， &lt;strong&gt;Bill Gates 说：“对编程能力最精细的测试就是给程序员大约 30 页的代码，看他能多快地通读并理解它。” 他意识到了一种很重要的东西。那些能直接从源码中快速汲取知识的人很快就能成为更好的程序员，因为他们的老师就是世界上的每一位程序员写下的一行行代码&lt;/strong&gt;。要学习模式、惯用法和最佳实践，最好的方法就是阅读开源代码。看看其他人是如何写代码的。这是一种保持自己不落伍的优秀方法，而且是免费的。—— Chris Wanstrath 在 2008 Ruby 大会上的主讲内容[&lt;/p&gt;
&lt;p&gt;挑选一个算法精深的开源项目，如 Subversion、 Git 或 Mercurial 这样的源码控制系统。浏览项目的源码，记下让你觉得&lt;strong&gt;新奇的算法、数据结构和设计理念&lt;/strong&gt;。然后&lt;strong&gt;写一篇博客&lt;/strong&gt;，描述一下项目的架构，着重突出自己学到的新思想。你能在日常工作中找到可运用同样思想的场合吗？&lt;/p&gt;
&lt;h3 id=&quot;4、个人实践图&quot;&gt;4、个人实践图&lt;/h3&gt;
&lt;p&gt;只要你工作的时间足够长，人们就会开始称你为“老手”，但这不应该是你的目标。所有的经验都表明你已经有能力在这个行业生存。但它显示不出你所学到的知识量，仅仅是你所花费的时间。在我们行业的某些领域，有时很容易将&lt;strong&gt;同样的时间经历重复 10 次却没有取得能力上的实质进步。事实上，这有时会变成“&lt;code&gt;反经验&lt;/code&gt;”（anti-experience）&lt;/strong&gt;，即这样一种现象：&lt;strong&gt;每一次新的时间经历仅仅强化了你所养成的坏习惯&lt;/strong&gt;。这就是为什么&lt;strong&gt;你的目标应该是达到技能娴熟，而非“有经验”&lt;/strong&gt;。技能水平的提高，是你在研究、适应及改善工作习惯方面所付出努力的唯一有效的证明。&lt;/p&gt;
&lt;p&gt;一种可用于明确表达这种反思的技巧是使用“&lt;strong&gt;个人实践图&lt;/strong&gt;”（Personal Practices Map）。&lt;/p&gt;
&lt;p&gt;为你的工作习惯画一张“个人实践图”。重点关注一段时间内没有改变的那些实践之间的关联。问自己，如果你发现当中的某种实践实际上对生产率起反作用，你的图该做怎样的修改。仔细检查其中的某一种实践，看看是否存在达到同样目标的其他方法。它未必是更好的方法；只要不同就够了。然后问自己，如果你采用其中一种不同的实践，这张图又会怎样变化。&lt;/p&gt;
&lt;h3 id=&quot;5、记录所学&quot;&gt;5、记录所学&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;尽量避免落入写下经验之后就忘记它们的陷阱。你的笔记、博客或 wiki 应该是一个托儿所，而不是一座坟墓——经验应该从这次记录中降生，而不是到那里去灭亡。定期读一读以前写的东西，你就能保证这一点。试着在每次重读这些资料时都找到新的关联&lt;/strong&gt;。这种创造性的复读过程能让你基于新的数据重新评估旧的决策，或者坚定正在摇摆的信念。这两种结果都不错，只要你别停滞就行。重读你的笔记，你可以不断变换自己的过去和现在，从而造就你的未来。&lt;/p&gt;
&lt;p&gt;Ade 使用了同一种 wiki 的两个实例，一个用于记录私人的想法，另一个记录那些想要与别人分享的想法。在拥有公开记录的同时再保留一套私人记录，这意味着你可以同时利用两个世界的优势。&lt;/p&gt;
&lt;h3 id=&quot;6、分享所学&quot;&gt;6、分享所学&lt;/h3&gt;
&lt;p&gt;要在学徒期的早期就养成定期分享所学经验的习惯。形式可以是撰写博客，或者跟你的“同道中人”一起开展“便当会议”。也可以在技术会议上做演讲，或者为你正在学习的各类技术技巧编写教程。&lt;/p&gt;
&lt;h3 id=&quot;7、学会失败&quot;&gt;7、学会失败&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;我觉得一个学徒不应该过早地致力于不犯错误，而应该尽早找出如何确定错误的办法。一旦学徒能确定他们的错误，从错误中学习就容易得多了。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;8、追根溯源&quot;&gt;8、追根溯源&lt;/h3&gt;
&lt;p&gt;找出是谁第一次提出了那种思想，弄明白他们当初想要解决的问题。这样的上下文通常在思想四处传播的过程中由于各种转译而丢失了。&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;1、阅读&quot;&gt;1、阅读&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;任何一本书，你能从中获得的最有价值的东西就是一列值得阅读的其他书目&lt;/strong&gt;。时间长了，你会发现某些书不断地从“参考书目”（ bibliography）中跳出来，你应把那些书移到阅读列表的顶部。其他书会下沉。由于阅读列表实际上是个优先级队列（priority queue），最终你会发现有的书已经在队列中下沉得太深，你可能永远也不会再读它们了。&lt;/p&gt;
&lt;p&gt;开始时挑一本宽泛的书，让自己对目标主题有大致的了解；然后选择一些内容具体的书，从而掌握该主题中自己感兴趣的方面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在合适的时间读合适的书会有更好的效果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即使每两个月读一本编程相关的好书，也就是每周 35 页左右，用不了多久，你就会对我们的行业有深入的理解，并使自己不同于周围的人。——Steve McConnell，《Code Complete》&lt;/p&gt;
&lt;p&gt;关注于经典作品也有风险：你对它们投入过多的精力，而完全不顾那些能提高日常技能的、更加注重实效的知识和信息。&lt;strong&gt;在你的阅读列表中，要确保经典名著和现代的、更注重实效的图书和文章混合出现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在实践中，算法问题不会在大项目刚开始的时候就出现。然后，当突然之间程序员不知道如何继续下去或者目前的程序显然不恰当时，它们就作为子问题出现了。——Steven S.Skiena，《The Algorithm Design Manual》（算法设计手册）情景分析&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要真正理解任何思想，你都需要重建它第一次被表达时的上下文。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、常用工具&quot;&gt;2、常用工具&lt;/h3&gt;
&lt;p&gt;Ade 很早就采用了名叫 Subversion 的集中式源码控制系统。随着 Subversion 更加流行，会有客户请 Ade 为他们的项目提供帮助，因为他是这方面的专家。尽管如此， Ade 却从一开始就在关注分布式源码控制系统这一新品种的出现。[ 1] 当 Subversion 变得过时，它在 Ade 工具箱中的位置将早已被 Git[ 2] 或 Mercurial[ 3] 所取代。&lt;strong&gt;放弃熟悉而又好用的工具是一种让人痛苦的过程&lt;/strong&gt;，但也是一种需要学会的技能。我们可以保证：&lt;strong&gt;你在学徒期使用的工具到你变成熟练工时肯定会变得过时。最终，你所钟爱的所有工具都将变成垃圾。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Apr 2020 16:37:00 +0000</pubDate>
<dc:creator>小蒋不素小蒋</dc:creator>
<og:description>第 1 章 略 第 2 章 空杯心态 1、多种语言 第一门语言学得越好，下一门语言学起来就越容易。 鄙人大二学的 JAVA，后来再去学 JS 就感觉好简单（虽然 js 的坑真的多）。 每一种语言都为你</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xjnotxj/p/12635512.html</dc:identifier>
</item>
<item>
<title>基于vue-cli-和element-ui的开发admin（1） - 徐牧之</title>
<link>http://www.cnblogs.com/Xumuzhi/p/12635305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Xumuzhi/p/12635305.html</guid>
<description>&lt;p&gt;&lt;strong&gt;//首先以下仅是记录个人本次vue后台管理系统的登录界面部分操作的流程以及踩坑的注意点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、首先是搭建vue-cli工作环境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这里有两种方式：1.用npm；（在安装了vue，vue-cli以及webpack情况下，&lt;strong&gt;cd到要工作的区域&lt;/strong&gt;，使用命令行&lt;strong&gt;vue init webpack&lt;/strong&gt;（项目名称）然后开始搭建）；&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　2.用&lt;strong&gt;命令行&lt;/strong&gt;使用&lt;strong&gt;vue ui&lt;/strong&gt;进行操作，个人感觉对新手比较友好，因为相对于npm方式来说，用vue ui更可视化的搭建项目，下面是vue ui进去的界面；&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1983850/202004/1983850-20200404225523553-47815624.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;210&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、关于eslint的安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;eslint&lt;/strong&gt;这个插件呢属实很烦，烦到有空格，有分号等都要给你报错，但是我觉得是可以对于自己养成良好的编程习惯，并且要习惯性的去看控制台以及一些基本错误提示语句意思，才能找到错误所在；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、关于插件以及依赖的安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;vue-router&lt;/strong&gt;（路由，实现界面跳转这个必不可少）；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;vue-axios&lt;/strong&gt;（数据请求的ajax库也必不可少）；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;element-ui&lt;/strong&gt;（可以调用一些组件的使用，这里如果使用vue ui方式可能涉及到按需导入和全局导入，按需导入的话用哪个组件就需要到plugins下的element.js中导入所需要的组件，然后挨个vue.use（）设置全局使用）；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;less&lt;/strong&gt;（可能在style样式设置时候会用到，使用npm下载就可，&lt;strong&gt;npm install --save-dev less-loader less&lt;/strong&gt;）；&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1983850/202004/1983850-20200404230115965-1635884131.png&quot; alt=&quot;&quot; width=&quot;408&quot; height=&quot;397&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1983850/202004/1983850-20200404233917589-429288032.png&quot; alt=&quot;&quot; width=&quot;389&quot; height=&quot;174&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、清空所有原始界面。&lt;/span&gt;&lt;/strong&gt;保留最最基本的东西，比如，app.vue中自己带的内容（带id的div别删），components下面自带的，以及views下面的about.vue和hello.vue，app.vue中导入的原始组件，这些都为了方便自己从头开始写；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、新建全局样式。&lt;/strong&gt;&lt;/span&gt;在&lt;strong&gt;assets&lt;/strong&gt;下新建个&lt;strong&gt;css文件夹&lt;/strong&gt;，再新建个&lt;strong&gt;global.css&lt;/strong&gt;来保存整个界面样式，让&lt;strong&gt;body，html，#app&lt;/strong&gt;能达到全屏；&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1983850/202004/1983850-20200404231405557-1708559579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、登录页面设置。&lt;/span&gt;&lt;/strong&gt;在&lt;strong&gt;components&lt;/strong&gt;下面新建一个&lt;strong&gt;Login.vue的登录页面&lt;/strong&gt;，然后自由发挥登录界面，涉及到需要form表单以及button的请移步至&lt;strong&gt;elemen-ui官网组件栏中&lt;/strong&gt;选择自己需要的并copy，下面是自己的部分代码；&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1983850/202004/1983850-20200404231950828-988817719.png&quot; alt=&quot;&quot; width=&quot;398&quot; height=&quot;314&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七、简单说下其中几个重要的属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1. &lt;strong&gt;:model&lt;/strong&gt; （注意前面的冒号！个人感觉这是把form当做一个对象，然后在el-form-item中调用这个对象的属性使用v-model数据双向绑定）（官方文档将 el-form 的 model 属性描述为&quot;表单数据对象&quot;）；&lt;/p&gt;
&lt;p&gt;　　2. &lt;strong&gt;:rules&lt;/strong&gt;（注意前面的冒号！通过这个message和trigger：'blur'可以设置当鼠标离开input框时候账号密码的长度是否正确或者有没有输入的提示，required: true则表示这一个输入框是必填项）；&lt;/p&gt;
&lt;p&gt;　　3. &lt;strong&gt;type=&quot;password&quot;&lt;/strong&gt;是为了隐藏密码；&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1983850/202004/1983850-20200404233358248-1425958076.png&quot; alt=&quot;&quot; width=&quot;416&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　请结合六中的图片参考数据&lt;/p&gt;
&lt;p&gt;　　style板块就自己设置啦=。=&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;八、为了实现点击页面就进入login登录页面，我们要进行路由设置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　首先用import导入login界面；&lt;/p&gt;
&lt;p&gt;　　然后使用Vue.use（VueRouter）全局使用；&lt;/p&gt;
&lt;p&gt;　　接着设置主页已经其他对应地址；&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1983850/202004/1983850-20200404233741135-814613606.png&quot; alt=&quot;&quot; width=&quot;411&quot; height=&quot;325&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　还要在app.vue中设置router标签占坑；&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1983850/202004/1983850-20200404234036026-515949232.png&quot; alt=&quot;&quot; width=&quot;388&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面将会更新登录页面的登录和重置按钮事件跳转以及后续页面的设置。&lt;/p&gt;
&lt;p&gt;　　Github：ClearLuvMoki，欢迎指出不足&lt;/p&gt;

</description>
<pubDate>Sat, 04 Apr 2020 15:52:00 +0000</pubDate>
<dc:creator>徐牧之</dc:creator>
<og:description>//首先以下仅是记录个人本次vue后台管理系统的登录界面部分操作的流程以及踩坑的注意点 一、首先是搭建vue-cli工作环境 这里有两种方式：1.用npm；（在安装了vue，vue-cli以及webp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Xumuzhi/p/12635305.html</dc:identifier>
</item>
</channel>
</rss>