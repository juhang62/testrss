<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Mycat-多实例的搭建 - 小乔啊</title>
<link>http://www.cnblogs.com/wx1899325/p/12970284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wx1899325/p/12970284.html</guid>
<description>&lt;p&gt;1. 基础环境准备&lt;br/&gt;1.1 环境准备：&lt;br/&gt;两台虚拟机 db01 db02&lt;br/&gt;每台创建四个mysql实例：3307 3308 3309 3310&lt;br/&gt;1.2 删除历史环境：&lt;br/&gt;pkill mysqld&lt;br/&gt;rm -rf /data/33{07..10}&lt;br/&gt;mv /etc/my.cnf /etc/my.cnf.bak&lt;/p&gt;
&lt;p&gt;1.3 创建相关目录初始化数据&lt;br/&gt;mkdir /data/33{07..10}/data -p&lt;br/&gt;mysqld --initialize-insecure  --user=mysql --datadir=/data/3307/data --basedir=/app/database/mysql&lt;br/&gt;mysqld --initialize-insecure  --user=mysql --datadir=/data/3308/data --basedir=/app/database/mysql&lt;br/&gt;mysqld --initialize-insecure  --user=mysql --datadir=/data/3309/data --basedir=/app/database/mysql&lt;br/&gt;mysqld --initialize-insecure  --user=mysql --datadir=/data/3310/data --basedir=/app/database/mysql&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;1.4 准备配置文件和启动脚本&lt;br/&gt;========db01==============&lt;br/&gt;cat &amp;gt;/data/3307/my.cnf&amp;lt;&amp;lt;EOF&lt;br/&gt;[mysqld]&lt;br/&gt;basedir=/app/database/mysql&lt;br/&gt;datadir=/data/3307/data&lt;br/&gt;socket=/data/3307/mysql.sock&lt;br/&gt;port=3307&lt;br/&gt;log-error=/data/3307/mysql.log&lt;br/&gt;log_bin=/data/3307/mysql-bin&lt;br/&gt;binlog_format=row&lt;br/&gt;skip-name-resolve&lt;br/&gt;server-id=7&lt;br/&gt;gtid-mode=on&lt;br/&gt;enforce-gtid-consistency=true&lt;br/&gt;log-slave-updates=1&lt;br/&gt;EOF&lt;/p&gt;
&lt;p&gt;cat &amp;gt;/data/3308/my.cnf&amp;lt;&amp;lt;EOF&lt;br/&gt;[mysqld]&lt;br/&gt;basedir=/app/database/mysql&lt;br/&gt;datadir=/data/3308/data&lt;br/&gt;port=3308&lt;br/&gt;socket=/data/3308/mysql.sock&lt;br/&gt;log-error=/data/3308/mysql.log&lt;br/&gt;log_bin=/data/3308/mysql-bin&lt;br/&gt;binlog_format=row&lt;br/&gt;skip-name-resolve&lt;br/&gt;server-id=8&lt;br/&gt;gtid-mode=on&lt;br/&gt;enforce-gtid-consistency=true&lt;br/&gt;log-slave-updates=1&lt;br/&gt;EOF&lt;/p&gt;
&lt;p&gt;cat &amp;gt;/data/3309/my.cnf&amp;lt;&amp;lt;EOF&lt;br/&gt;[mysqld]&lt;br/&gt;basedir=/app/database/mysql&lt;br/&gt;datadir=/data/3309/data&lt;br/&gt;socket=/data/3309/mysql.sock&lt;br/&gt;port=3309&lt;br/&gt;log-error=/data/3309/mysql.log&lt;br/&gt;log_bin=/data/3309/mysql-bin&lt;br/&gt;binlog_format=row&lt;br/&gt;skip-name-resolve&lt;br/&gt;server-id=9&lt;br/&gt;gtid-mode=on&lt;br/&gt;enforce-gtid-consistency=true&lt;br/&gt;log-slave-updates=1&lt;br/&gt;EOF&lt;/p&gt;
&lt;p&gt;cat &amp;gt;/data/3310/my.cnf&amp;lt;&amp;lt;EOF&lt;br/&gt;[mysqld]&lt;br/&gt;basedir=/app/database/mysql&lt;br/&gt;datadir=/data/3310/data&lt;br/&gt;socket=/data/3310/mysql.sock&lt;br/&gt;port=3310&lt;br/&gt;log-error=/data/3310/mysql.log&lt;br/&gt;log_bin=/data/3310/mysql-bin&lt;br/&gt;binlog_format=row&lt;br/&gt;skip-name-resolve&lt;br/&gt;server-id=10&lt;br/&gt;gtid-mode=on&lt;br/&gt;enforce-gtid-consistency=true&lt;br/&gt;log-slave-updates=1&lt;br/&gt;EOF&lt;/p&gt;
&lt;p&gt;cat &amp;gt;/etc/systemd/system/mysqld3307.service&amp;lt;&amp;lt;EOF&lt;br/&gt;[Unit]&lt;br/&gt;Description=MySQL Server&lt;br/&gt;Documentation=man:mysqld(8)&lt;br/&gt;Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html&lt;br/&gt;After=network.target&lt;br/&gt;After=syslog.target&lt;br/&gt;[Install]&lt;br/&gt;WantedBy=multi-user.target&lt;br/&gt;[Service]&lt;br/&gt;User=mysql&lt;br/&gt;Group=mysql&lt;br/&gt;ExecStart=/app/database/mysql/bin/mysqld --defaults-file=/data/3307/my.cnf&lt;br/&gt;LimitNOFILE = 5000&lt;br/&gt;EOF&lt;/p&gt;
&lt;p&gt;cat &amp;gt;/etc/systemd/system/mysqld3308.service&amp;lt;&amp;lt;EOF&lt;br/&gt;[Unit]&lt;br/&gt;Description=MySQL Server&lt;br/&gt;Documentation=man:mysqld(8)&lt;br/&gt;Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html&lt;br/&gt;After=network.target&lt;br/&gt;After=syslog.target&lt;br/&gt;[Install]&lt;br/&gt;WantedBy=multi-user.target&lt;br/&gt;[Service]&lt;br/&gt;User=mysql&lt;br/&gt;Group=mysql&lt;br/&gt;ExecStart=/app/database/mysql/bin/mysqld --defaults-file=/data/3308/my.cnf&lt;br/&gt;LimitNOFILE = 5000&lt;br/&gt;EOF&lt;/p&gt;
&lt;p&gt;cat &amp;gt;/etc/systemd/system/mysqld3309.service&amp;lt;&amp;lt;EOF&lt;br/&gt;[Unit]&lt;br/&gt;Description=MySQL Server&lt;br/&gt;Documentation=man:mysqld(8)&lt;br/&gt;Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html&lt;br/&gt;After=network.target&lt;br/&gt;After=syslog.target&lt;br/&gt;[Install]&lt;br/&gt;WantedBy=multi-user.target&lt;br/&gt;[Service]&lt;br/&gt;User=mysql&lt;br/&gt;Group=mysql&lt;br/&gt;ExecStart=/app/database/mysql/bin/mysqld --defaults-file=/data/3309/my.cnf&lt;br/&gt;LimitNOFILE = 5000&lt;br/&gt;EOF&lt;/p&gt;

&lt;p&gt;cat &amp;gt;/etc/systemd/system/mysqld3310.service&amp;lt;&amp;lt;EOF&lt;br/&gt;[Unit]&lt;br/&gt;Description=MySQL Server&lt;br/&gt;Documentation=man:mysqld(8)&lt;br/&gt;Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html&lt;br/&gt;After=network.target&lt;br/&gt;After=syslog.target&lt;/p&gt;
&lt;p&gt;[Install]&lt;br/&gt;WantedBy=multi-user.target&lt;br/&gt;[Service]&lt;br/&gt;User=mysql&lt;br/&gt;Group=mysql&lt;br/&gt;ExecStart=/app/database/mysql/bin/mysqld --defaults-file=/data/3310/my.cnf&lt;br/&gt;LimitNOFILE = 5000&lt;br/&gt;EOF&lt;/p&gt;


&lt;p&gt;========db02===============&lt;br/&gt;cat &amp;gt;/data/3307/my.cnf&amp;lt;&amp;lt;EOF&lt;br/&gt;[mysqld]&lt;br/&gt;basedir=/app/database/mysql&lt;br/&gt;datadir=/data/3307/data&lt;br/&gt;socket=/data/3307/mysql.sock&lt;br/&gt;port=3307&lt;br/&gt;log-error=/data/3307/mysql.log&lt;br/&gt;log_bin=/data/3307/mysql-bin&lt;br/&gt;binlog_format=row&lt;br/&gt;skip-name-resolve&lt;br/&gt;server-id=17&lt;br/&gt;gtid-mode=on&lt;br/&gt;enforce-gtid-consistency=true&lt;br/&gt;log-slave-updates=1&lt;br/&gt;EOF&lt;br/&gt;cat &amp;gt;/data/3308/my.cnf&amp;lt;&amp;lt;EOF&lt;br/&gt;[mysqld]&lt;br/&gt;basedir=/app/database/mysql&lt;br/&gt;datadir=/data/3308/data&lt;br/&gt;port=3308&lt;br/&gt;socket=/data/3308/mysql.sock&lt;br/&gt;log-error=/data/3308/mysql.log&lt;br/&gt;log_bin=/data/3308/mysql-bin&lt;br/&gt;binlog_format=row&lt;br/&gt;skip-name-resolve&lt;br/&gt;server-id=18&lt;br/&gt;gtid-mode=on&lt;br/&gt;enforce-gtid-consistency=true&lt;br/&gt;log-slave-updates=1&lt;br/&gt;EOF&lt;br/&gt;cat &amp;gt;/data/3309/my.cnf&amp;lt;&amp;lt;EOF&lt;br/&gt;[mysqld]&lt;br/&gt;basedir=/app/database/mysql&lt;br/&gt;datadir=/data/3309/data&lt;br/&gt;socket=/data/3309/mysql.sock&lt;br/&gt;port=3309&lt;br/&gt;log-error=/data/3309/mysql.log&lt;br/&gt;log_bin=/data/3309/mysql-bin&lt;br/&gt;binlog_format=row&lt;br/&gt;skip-name-resolve&lt;br/&gt;server-id=19&lt;br/&gt;gtid-mode=on&lt;br/&gt;enforce-gtid-consistency=true&lt;br/&gt;log-slave-updates=1&lt;br/&gt;EOF&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;cat &amp;gt;/data/3310/my.cnf&amp;lt;&amp;lt;EOF&lt;br/&gt;[mysqld]&lt;br/&gt;basedir=/app/database/mysql&lt;br/&gt;datadir=/data/3310/data&lt;br/&gt;socket=/data/3310/mysql.sock&lt;br/&gt;port=3310&lt;br/&gt;log-error=/data/3310/mysql.log&lt;br/&gt;log_bin=/data/3310/mysql-bin&lt;br/&gt;binlog_format=row&lt;br/&gt;skip-name-resolve&lt;br/&gt;server-id=20&lt;br/&gt;gtid-mode=on&lt;br/&gt;enforce-gtid-consistency=true&lt;br/&gt;log-slave-updates=1&lt;br/&gt;EOF&lt;/p&gt;
&lt;p&gt;cat &amp;gt;/etc/systemd/system/mysqld3307.service&amp;lt;&amp;lt;EOF&lt;br/&gt;[Unit]&lt;br/&gt;Description=MySQL Server&lt;br/&gt;Documentation=man:mysqld(8)&lt;br/&gt;Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html&lt;br/&gt;After=network.target&lt;br/&gt;After=syslog.target&lt;br/&gt;[Install]&lt;br/&gt;WantedBy=multi-user.target&lt;br/&gt;[Service]&lt;br/&gt;User=mysql&lt;br/&gt;Group=mysql&lt;br/&gt;ExecStart=/app/database/mysql/bin/mysqld --defaults-file=/data/3307/my.cnf&lt;br/&gt;LimitNOFILE = 5000&lt;br/&gt;EOF&lt;/p&gt;
&lt;p&gt;cat &amp;gt;/etc/systemd/system/mysqld3308.service&amp;lt;&amp;lt;EOF&lt;br/&gt;[Unit]&lt;br/&gt;Description=MySQL Server&lt;br/&gt;Documentation=man:mysqld(8)&lt;br/&gt;Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html&lt;br/&gt;After=network.target&lt;br/&gt;After=syslog.target&lt;br/&gt;[Install]&lt;br/&gt;WantedBy=multi-user.target&lt;br/&gt;[Service]&lt;br/&gt;User=mysql&lt;br/&gt;Group=mysql&lt;br/&gt;ExecStart=/app/database/mysql/bin/mysqld --defaults-file=/data/3308/my.cnf&lt;br/&gt;LimitNOFILE = 5000&lt;br/&gt;EOF&lt;/p&gt;
&lt;p&gt;cat &amp;gt;/etc/systemd/system/mysqld3309.service&amp;lt;&amp;lt;EOF&lt;br/&gt;[Unit]&lt;br/&gt;Description=MySQL Server&lt;br/&gt;Documentation=man:mysqld(8)&lt;br/&gt;Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html&lt;br/&gt;After=network.target&lt;br/&gt;After=syslog.target&lt;br/&gt;[Install]&lt;br/&gt;WantedBy=multi-user.target&lt;br/&gt;[Service]&lt;br/&gt;User=mysql&lt;br/&gt;Group=mysql&lt;br/&gt;ExecStart=/app/database/mysql/bin/mysqld --defaults-file=/data/3309/my.cnf&lt;br/&gt;LimitNOFILE = 5000&lt;br/&gt;EOF&lt;br/&gt;cat &amp;gt;/etc/systemd/system/mysqld3310.service&amp;lt;&amp;lt;EOF&lt;br/&gt;[Unit]&lt;br/&gt;Description=MySQL Server&lt;br/&gt;Documentation=man:mysqld(8)&lt;br/&gt;Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html&lt;br/&gt;After=network.target&lt;br/&gt;After=syslog.target&lt;br/&gt;[Install]&lt;br/&gt;WantedBy=multi-user.target&lt;br/&gt;[Service]&lt;br/&gt;User=mysql&lt;br/&gt;Group=mysql&lt;br/&gt;ExecStart=/app/database/mysql/bin/mysqld --defaults-file=/data/3310/my.cnf&lt;br/&gt;LimitNOFILE = 5000&lt;br/&gt;EOF&lt;br/&gt;1.5 修改权限，启动多实例&lt;br/&gt;chown -R mysql.mysql /data/*&lt;br/&gt;systemctl start mysqld3307&lt;br/&gt;systemctl start mysqld3308&lt;br/&gt;systemctl start mysqld3309&lt;br/&gt;systemctl start mysqld3310&lt;/p&gt;
&lt;p&gt;mysql -S /data/3307/mysql.sock -e &quot;show variables like 'server_id'&quot;&lt;br/&gt;mysql -S /data/3308/mysql.sock -e &quot;show variables like 'server_id'&quot;&lt;br/&gt;mysql -S /data/3309/mysql.sock -e &quot;show variables like 'server_id'&quot;&lt;br/&gt;mysql -S /data/3310/mysql.sock -e &quot;show variables like 'server_id'&quot;&lt;/p&gt;
</description>
<pubDate>Wed, 27 May 2020 00:40:00 +0000</pubDate>
<dc:creator>小乔啊</dc:creator>
<og:description>1. 基础环境准备1.1 环境准备：两台虚拟机 db01 db02每台创建四个mysql实例：3307 3308 3309 33101.2 删除历史环境：pkill mysqldrm -rf /dat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wx1899325/p/12970284.html</dc:identifier>
</item>
<item>
<title>对 getopts 的理解 - usmile</title>
<link>http://www.cnblogs.com/usmile/p/12969768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/usmile/p/12969768.html</guid>
<description>&lt;h3 id=&quot;getopts&quot;&gt;getopts&lt;/h3&gt;
&lt;h4 id=&quot;格式&quot;&gt;格式&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;  1 #!/bin/bash
  2 echo &quot;begin index is $OPTIND&quot;
  3 echo &quot;begin ARG is $OPTARG&quot;
  4 
  5 while getopts &quot;:ab:c:&quot; OPT
  6 do
  7         case $OPT in
  8                 a)
  9                         echo &quot;\$OPTIND=$OPTIND, a is $OPTARG, \$1=$1, \$OPTIND=$OPTIND&quot;;;
 10                 b)
 11                         echo &quot;\$OPTIND=$OPTIND, b is $OPTARG, \$2=$2, \$OPTIND=$OPTIND&quot;;;
 12                 c)
 13                         echo &quot;\$OPTIND=$OPTIND, c is $OPTARG, \$3=$3, \$OPTIND=$OPTIND&quot;;;
 14                 :)
 15                         echo &quot;\$OPTIND=$OPTIND, : is $OPTARG, \$#=$@, \$OPTIND=$OPTIND&quot;;;
 14                 ?)
 15                         echo &quot;\$OPTIND=$OPTIND&quot; # 新的一轮开始的时候，OPTIND 的值就已经指向下一个参数
 16                         shift $(($OPTIND-2)) # -2 才可以让当前参数位于 $
 17                         echo &quot;剩余参数列表：$@&quot;
 18                         echo -e &quot;Illegal option -- '$1' \nUsage: `basename $0` [-a] [-b value] [-c value] args&quot;
 19                         exit 2 ;;
 20         esac
 21 done
 22 echo &quot;end index is $OPTIND&quot;


lfp@legion:~$ ./bin/getopts.sh -b bb -c cc -d 22 -a
begin index is 1 # 初始值为1
begin ARG is  # 没有初始值
$OPTIND=3, b is bb, $2=bb, $OPTIND=3
$OPTIND=5, c is cc, $3=-c, $OPTIND=5
$OPTIND=6
剩余参数列表：-d 22 -a
Illegal option -- '-d', Usage: getopts.sh [-a] [-b value] [-c value] args
 
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;区别 选项列表 参数列表&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;选项列表&lt;/p&gt;
&lt;p&gt;命令可以接收的选项&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;参数列表&lt;/p&gt;
&lt;p&gt;命令行中，除命令之外的字符组成参数列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bin/getopts.sh -b bb -c cc -d 22 -a
参数列表为 -b bb -c cc -d 22 -a，对应的位置从1开始计算
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;getopts 从命令行前面开始处理。参数列表中包括选项和参数，选项通过&lt;code&gt;-&lt;/code&gt;来区分，其他被视作选项的参数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;标准格式 while getopts &quot;选项列表&quot; OPT&lt;/p&gt;
&lt;p&gt;选项列表字符串&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前面加冒号&lt;code&gt;:&lt;/code&gt;则表示当遇到选项列表之外的选项时，不会有警告信息（静默模式）&lt;/li&gt;
&lt;li&gt;一个字母代表一个选项&lt;/li&gt;
&lt;li&gt;选项后面跟冒号&lt;code&gt;b:&lt;/code&gt;表示该选项b，需要指定参数&lt;/li&gt;
&lt;li&gt;选项后面没有冒号&lt;code&gt;ab:&lt;/code&gt;表示该选项a，不需要指定参数，也称作开关选项&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OPT&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;代表输入的参数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果出现了选项列表之外的选项，OPT 会被设置为&lt;code&gt;?&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果缺少参数&lt;/p&gt;
&lt;p&gt;如果选项列表前面加冒号，则OPT被设置为&lt;code&gt;:&lt;/code&gt;（如果此时没有&lt;code&gt;:&lt;/code&gt;匹配，则会匹配到&lt;code&gt;?&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;如果没加，则OPT被置为&lt;code&gt;?&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;case&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最后一个选择——?，表示如果出现了选项列表之外的选项，进行的操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;getopts 提供的两个常量&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;OPTARG&lt;/p&gt;
&lt;p&gt;表示当前选项的参数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;OPTIND&lt;/p&gt;
&lt;p&gt;表示下一个选项在【参数列表】中的位置，参数列表的初始值为1（即从$1开始）&lt;/p&gt;
&lt;p&gt;处理带参数的选项，值加2；处理不带参数的选项或非法选项，值加1&lt;/p&gt;
&lt;p&gt;在case匹配开始的时候就已经增加，指向了下一个参数的位置&lt;/p&gt;
&lt;p&gt;shift $(($OPTIND-2)) 让当前选项（正在处理的选项）处于 $1 位置&lt;/p&gt;
&lt;p&gt;shift $(($OPTIND-1)) 让下一个选项（未处理的选项）处于 $1 位置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;shift&lt;/p&gt;
&lt;p&gt;用来左移【参数列表】，shift 2 表示将参数列表中前2个左移（丢弃）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;特点&quot;&gt;特点&lt;/h4&gt;
&lt;ol readability=&quot;34.5&quot;&gt;&lt;li&gt;
&lt;p&gt;Shell 内建命令&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;getopts不支持长选项。如 --help&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;输入选项参数的格式必须是 &lt;code&gt;-o arg&lt;/code&gt; 参数紧跟选项，中间有空格&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;处理完一个参数后，OPTIND会自动指向下一个参数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不会重排所有参数的顺序&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;带参数的选项要放在不带参数的选项（开关选项）之前，或者开关选项后面不能带参数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 可以识别 -a 只是没有参数
lfp@legion:~$ ./bin/getopts.sh -a -b bb -c cc -d
begin index is 1
begin ARG is 
$OPTIND=2, a is , $1=-a, $OPTIND=2
$OPTIND=4, b is bb, $2=-b, $OPTIND=4
$OPTIND=6, c is cc, $3=bb, $OPTIND=6
$OPTIND=7
剩余参数列表：-d
Illegal option -- '-d', Usage: getopts.sh [-a] [-b arg] [-c arg] file ...
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;遇到非&lt;code&gt;-&lt;/code&gt;开头的参数或选项结束标记&lt;code&gt;--&lt;/code&gt;，则终止&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# -- 选项结束
lfp@legion:~$ ./bin/getopts.sh -b bb -c cc -- -d -a
begin index is 1
begin ARG is 
$OPTIND=3, b is bb, $2=bb, $OPTIND=3
$OPTIND=5, c is cc, $3=-c, $OPTIND=5
end index is 6

# 非 - 开头的参数
lfp@legion:~$ ./bin/getopts.sh -a aa -b bb -c cc -d
begin index is 1
begin ARG is 
$OPTIND=2, a is , $1=-a, $OPTIND=2
end index is 2
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;遇到非法选项，则后面的选项参数都无法获取&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# -d 非法选项
lfp@legion:~$ ./bin/getopts.sh -b bb -d -c cc -a
begin index is 1
begin ARG is 
$OPTIND=3, b is bb, $2=bb, $OPTIND=3
./bin/getopts.sh: 非法选项 -- d # 可以通过在选项列表字符串前面加冒号来取消
$OPTIND=4
剩余参数列表：-d -c cc -a
Illegal option -- '-d', Usage: getopts.sh [-a] [-b arg] [-c arg] file ...
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;如果缺少参数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 会把后面的 -c 选项当做参数，然后遇到 -c 选项的参数（非-开头的选项，终止）
lfp@legion:~$ ./bin/getopts.sh -b -c cc -a
begin index is 1
begin ARG is 
$OPTIND=3, b is -c, $2=-c, $OPTIND=3
end index is 3
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;如果选项和参数之间没有空格&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;lfp@legion:~$ ./bin/getopts.sh -bbb -c cc -a
begin index is 1
begin ARG is 
# 可以拿到选项的值，但是 OPTIND 只加1，按无参数选项处理的
$OPTIND=2, b is bb, $2=-c, $OPTIND=2
$OPTIND=4, c is cc, $3=cc, $OPTIND=4
$OPTIND=5, a is , $1=-bbb, $OPTIND=5
end index is 5
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 27 May 2020 00:37:00 +0000</pubDate>
<dc:creator>usmile</dc:creator>
<og:description>getopts 格式 1 #!/bin/bash 2 echo &amp;amp;quot;begin index is $OPTIND&amp;amp;quot; 3 echo &amp;amp;quot;begin AR</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/usmile/p/12969768.html</dc:identifier>
</item>
<item>
<title>Nginx 的过滤模块是干啥用的？ - 原少子杨</title>
<link>http://www.cnblogs.com/iziyang/p/12970270.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iziyang/p/12970270.html</guid>
<description>&lt;p&gt;上一篇文章我写了 &lt;a href=&quot;https://iziyang.github.io/2020/04/12/5-nginx/&quot;&gt;Nginx 的 11 个阶段&lt;/a&gt;，很多人都说太长了。这是出于文章完整性的考虑的，11 个阶段嘛，一次性说完就完事了。今天这篇文章比较短，看完没问题。&lt;/p&gt;
&lt;h2 id=&quot;过滤模块的位置&quot;&gt;过滤模块的位置&lt;/h2&gt;
&lt;p&gt;之前我们介绍了 Nginx 的 11 个阶段，在 content 阶段时，Nginx 会生成返回给用户的响应内容，对用户的响应内容，实际上还需要做再加工处理，Nginx 的过滤模块就是对响应内容进行再加工处理的。所以实际上过滤模块位于 content 阶段之后，log 阶段之前。&lt;/p&gt;
&lt;p&gt;我们先来看一段配置指令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-nginx&quot;&gt;limit_req zone=req_one
burst=120;
limit_conn c_zone 1;

satisfy any;
allow 192.168.1.0/32;
auth_basic_user_file access.pass;

gzip on;
image_filter resize 80 80;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么在这一段配置指令之下，会遵循怎样的请求流程呢？请看一下下面这张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1833725/202005/1833725-20200527083314534-1524763425.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这张图的流程大致说一下，如果对于 Nginx 的 11 个阶段不了解的去翻一下之前的文章。&lt;/p&gt;
&lt;p&gt;我这里再简单说一下。首先由 Nginx 框架接收 HTTP 请求，经过 preaccess、access、content 阶段的处理，当经过 static 模块之后生成响应的时候，很多时候需要对响应进行处理，然后才会返回给客户端。&lt;/p&gt;
&lt;p&gt;这里我们假如响应是一张图片的话，那么需要做缩略图的时候，首先就要经过 image_filter 模块的处理。这里面还有一个 gzip 模块，这两个模块也是需要遵循严格的顺序的。因为如果先做 gzip 压缩的话，缩略图后面就没办法做了。&lt;/p&gt;
&lt;p&gt;第二个需要关注的地方是，首先对 header 进行过滤，再对 body 进行过滤。因为我们在对用户发送响应的时候，一定是先发送 header，然后再发送 body，所以所有的过滤模块都会提供对 header 或 body 的过滤，当然 image_filter 和 gzip 模块对这两者都可以过滤。&lt;/p&gt;
&lt;h2 id=&quot;返回响应&quot;&gt;返回响应&lt;/h2&gt;
&lt;p&gt;前面我们说过，Nginx 的 11 个阶段是有严格的顺序的，而这个顺序是在 Nginx 的代码中以一个数组的形式存在的，这个数组的顺序是从后往前。在给用户返回响应的时候，过滤模块也是有严格顺序的，这个顺序同样是从后往前。来看一下在代码中的定义，标红的是我下面会提到的几个过滤模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1833725/202005/1833725-20200527083315320-1417299334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们需要重点关注四个过滤模块，它们分别的作用是啥呢？&lt;/p&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;copy_filter：复制包体内容&lt;/p&gt;
&lt;p&gt;当我们使用 sendfile 指令的时候，也就是零拷贝技术，不经过用户态内存，这里就是不经过 Nginx 直接发给用户，同时也用了 gzip 模块的时候，gzip 是必须在 copy_filter 模块之后的，因为 gzip 必须对内存中的数据做压缩，这时 copy_filter 就会让 sendfile 指令失效。有些模块不需要对内存中的数据进行处理，就需要在 copy_filter 模块之前进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;postpone_filter：处理子请求&lt;/p&gt;
&lt;p&gt;用来处理子请求，有些过滤模块需要关心子请求的处理结果，需要放在该模块之后。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;header_filter：构造响应头部&lt;/p&gt;
&lt;p&gt;用来构造最终发送给用户的响应头部，可能会添加一些 Server，Nginx 版本号等内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;write_filter：发送响应&lt;/p&gt;
&lt;p&gt;用来实际调用操作系统的 write 或 send 等系统调用，来把响应实际发送出去。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;介绍完了过滤模块的功能以及所处的阶段，下面来具体看两个模块。&lt;/p&gt;
&lt;h2 id=&quot;sub-模块&quot;&gt;sub 模块&lt;/h2&gt;
&lt;p&gt;介绍一个可以替换响应中字符串内容的模块：sub 模块。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;功能：将响应中指定的字符串，替换成新的字符串&lt;/li&gt;
&lt;li&gt;模块：&lt;code&gt;ngx_http_sub_filter_module&lt;/code&gt; 模块，默认未编译进 Nginx，通过 --with-http_sub_module 启用&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;指令&quot;&gt;指令&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-nginx&quot;&gt;Syntax: sub_filter string replacement;
Default: —
Context: http, server, location

Syntax: sub_filter_last_modified on | off;
Default: sub_filter_last_modified off; 
Context: http, server, location

Syntax: sub_filter_once on | off;
Default: sub_filter_once on; 
Context: http, server, location

Syntax: sub_filter_types mime-type ...;
Default: sub_filter_types text/html; 
Context: http, server, location
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来解释一下这四个指令都是啥意思。&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;sub_filter string replacement&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sub_filter&lt;/code&gt; 指令会把匹配到的 &lt;code&gt;string&lt;/code&gt; 字符串替换成 &lt;code&gt;replacement&lt;/code&gt; 表示的字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;sub_filter_last_modified on | off&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sub_filter_last_modified&lt;/code&gt; 指令的意思是，是否要返回原来的 &lt;code&gt;last_modified&lt;/code&gt; HTTP 头部，因为我们已经修改了文件内容，如果是 &lt;code&gt;on&lt;/code&gt; 的话，就会继续返回原来的头部。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;sub_filter_once on | off&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sub_filter_once&lt;/code&gt; 的意思是，是否只替换一次，默认打开，如果设置为 &lt;code&gt;off&lt;/code&gt; 的话，那就会将响应中的内容全部扫描一遍并替换。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;sub_filter_types mime-type&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个指令是说针对那些文件类型进行替换，这里可以设置成 *，但是效率就会比较低了，需要根据实际情况考虑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实战&quot;&gt;实战&lt;/h3&gt;
&lt;p&gt;配置文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-nginx&quot;&gt;server {
        server_name sub.ziyang.com;
        error_log  logs/myerror.log  info;
        
        location / {
        sub_filter 'Nginx.oRg'  '$host/nginx';
        sub_filter 'nginX.cOm' '$host/nginx';
        #sub_filter_once on;
                sub_filter_once off;
                #sub_filter_last_modified off;
                sub_filter_last_modified on;
        }       
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要重新编译 Nginx，我这里把下一节需要的模块也一起编译进去了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;./configure --prefix=/Users/mtdp/myproject/nginx/test_nginx --with-http_sub_module --with-http_addition_module --with-http_realip_module
make
cp nginx ../../test_nginx/sbin/ # 复制编译好的 nginx 到之前的目录
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行热部署：&lt;/p&gt;
&lt;blockquote readability=&quot;2.2727272727273&quot;&gt;
&lt;p&gt;热部署的流程详见 &lt;a href=&quot;https://iziyang.github.io/2020/03/10/1-nginx/&quot;&gt;Nginx 入门及命令行操作&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;kill -USR2 87693 # 使用新的 Nginx 二进制文件提供服务
kill -WINCH 87693 # 退出老的 Nginx 的 worker 进程
kill -quit 87693 # 优雅的退出老的 master 进程
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在浏览器中打开 sub.ziyang.com：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1833725/202005/1833725-20200527083315519-90095891.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面会发现，nginx.org 已经替换成了 sub.ziyang.com/nginx，nginx.com 也替换成了 sub.ziyang.com/nginx。&lt;/p&gt;
&lt;h2 id=&quot;addition-模块&quot;&gt;addition 模块&lt;/h2&gt;
&lt;p&gt;下面再来看一个过滤模块，addition 模块，它可以在响应的前后添加内容。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;功能：在相应前或者响应后增加内容，增加内容的方式，是通过新增子请求，根据子请求的响应来完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;模块：&lt;code&gt;ngx_http_addition_filter_module&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认未编译进 Nginx，通过 --with-http_addition_module 启用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;指令-2&quot;&gt;指令&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-nginx&quot;&gt;Syntax: add_before_body uri;
Default: —
Context: http, server, location

Syntax: add_after_body uri;
Default: —
Context: http, server, location

Syntax: addition_types mime-type ...;
Default: addition_types text/html; 
Context: http, server, location
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的三个指令都比较简单，说一下 &lt;code&gt;add_before_body&lt;/code&gt; 和 &lt;code&gt;add_after_body&lt;/code&gt; 后面的 &lt;code&gt;uri&lt;/code&gt;，这个的意思是说，向指定 &lt;code&gt;uri&lt;/code&gt; 发起子请求，根据子请求的响应来添加内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;addition_types&lt;/code&gt; 指令是指定要添加的文件类型。&lt;/p&gt;
&lt;h3 id=&quot;实战-2&quot;&gt;实战&lt;/h3&gt;
&lt;p&gt;配置文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-nginx&quot;&gt;server {
        server_name addition.ziyang.com;
        error_log logs/myerror.log info;
        
        location / {
        #add_before_body /before_action;
        #add_after_body  /after_action;
                #addition_types *;
        }       
        location /before_action {
                return 200 'new content before\n';
        }
        location /after_action {
                return 200 'new content after\n';
        }
        location /testhost {
                uninitialized_variable_warn on;
                set $foo 'testhost';
                return 200 '$gzip_ratio\n';
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看在注释掉 addition 模块的指令的情况下，会是什么效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;➜  ~ curl addition.ziyang.com/a.txt
a
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后打开注释：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;➜  ~ curl addition.ziyang.com/a.txt
new content before
a
new content after
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在原响应前后都增加了内容。&lt;/p&gt;
&lt;p&gt;这里面需要注意一点，在实际情况下，&lt;code&gt;add_before_body&lt;/code&gt; 和 &lt;code&gt;add_after_body&lt;/code&gt; 后面是其他的 uri，我这里为了简化，直接转发到对应的 location。&lt;/p&gt;
&lt;blockquote readability=&quot;4.0721649484536&quot;&gt;
&lt;p&gt;本文涉及到的所有配置文件我已经放在了 &lt;a href=&quot;https://docs.qq.com/doc/DSkFoT3pvUVhsaWhT&quot;&gt;Nginx 配置文件&lt;/a&gt;，大家可以自取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;本文首发于我的个人博客：&lt;a href=&quot;https://iziyang.github.io&quot;&gt;iziyang.github.io&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 May 2020 00:33:00 +0000</pubDate>
<dc:creator>原少子杨</dc:creator>
<og:description>上一篇文章我写了 Nginx 的 11 个阶段，很多人都说太长了。这是出于文章完整性的考虑的，11 个阶段嘛，一次性说完就完事了。今天这篇文章比较短，看完没问题。 过滤模块的位置 之前我们介绍了 Ng</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/iziyang/p/12970270.html</dc:identifier>
</item>
<item>
<title>粒子群优化算法对BP神经网络优化 Matlab实现 - 未名w</title>
<link>http://www.cnblogs.com/weimingai/p/12970255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weimingai/p/12970255.html</guid>
<description>&lt;p&gt;1、粒子群优化算法&lt;/p&gt;
&lt;p&gt;粒子群算法(particle swarm optimization，PSO)由Kennedy和Eberhart在1995年提出，该算法模拟鸟集群飞行觅食的行为，鸟之间通过集体的协作使群体达到最优目的，是一种基于 Swarm Inteligence的优化方法。同遗传算法类似，也是一种基于群体叠代的，但并没有遗传算法用的交叉以及变异，而是粒子在解空间追随最优的粒子进行搜索。PSO的优势在于简单容易实现同时又有深刻的智能背景，既适合科学研究，又特别适合工程应用，并且没有许多参数需要调整。&lt;/p&gt;
&lt;p&gt;粒子群优化算法源于1987年Reynolds对鸟群社会系统boids的仿真研究，boids是一个CAS。在boids中，一群鸟在空中飞行，每个鸟遵守以下三条规则：&lt;br/&gt;1）避免与相邻的鸟发生碰撞冲突；&lt;br/&gt;2）尽量与自己周围的鸟在速度上保持协调和一致；&lt;br/&gt;3）尽量试图向自己所认为的群体中靠近。&lt;br/&gt;仅通过使用这三条规则，boids系统就出现非常逼真的群体聚集行为，鸟成群地在空中飞行，当遇到障碍时它们会分开绕行而过，随后又会重新形成群体。&lt;br/&gt;Reynolds仅仅将其作为CAS的一个实例作仿真研究，而并未将它用于优化计算中 。&lt;br/&gt;Kennedy和Eberhart在中加入了一个特定点，定义为食物，鸟根据周围鸟的觅食行为来寻找食物。他们的初衷是希望通过这种模型来模拟鸟群寻找食源的现象，然而实验结果却揭示这个仿真模型中蕴涵着很强的优化能力，尤其是在多维空间寻优中。&lt;br/&gt;PSO中，每个优化问题的解都是搜索空间中的一只鸟。称之为“粒子(Particle)”。所有的粒子都有一个由被优化的函数决定的适应值，每个粒子还有一个速度决定他们飞翔的方向和距离。然后粒子们就追随当前的最优粒子在解空间中搜索.&lt;br/&gt;PSO 初始化为一群随机粒子。然后通过叠代找到最优解。在每一次叠代中，粒子通过跟踪两个&quot;极值&quot;来更新自己。第一个就是粒子本身所找到的最优解。这个解叫做个体极值pBest. 另一个极值是整个种群目前找到的最优解。这个极值是全局极值gBest。另外,也可以不用整个种群而只是用其中一部分的邻居。&lt;br/&gt;PSO算法数学表示如下：&lt;br/&gt;设搜索空间为D维，总粒子数为n。第i个粒子位置表示为向量Xi=( xi1, xi2,…, xiD )；第i个粒子 “飞行”历史中的过去最优位置（即该位置对应解最优）为Pi=( pi1,pi2,…,piD )，其中第g个粒子的过去最优位置Pg为所有Pi ( i=1, …,n)中的最优；第i个粒子的位置变化率（速度）为向量Vi=(vi1, vi2,…, viD)。每个粒子的位置按如下公式进行变化（“飞行”）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1550728/202005/1550728-20200527082459020-941292098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;其中，C1,C2为正常数，称为加速因子；rand( )为[0，1]之间的随机数；w称惯性因子，w较大适于对解空间进行大范围探查(exploration)，w较小适于进行小范围开挖(exploitation)。第d（1≤d≤D）维的位置变化范围为[-XMAXd , XMAXd]，速度变化范围为[-VMAXd , VMAXd]，迭代中若位置和速度超过边界范围则取边界值。&lt;/p&gt;
&lt;p&gt;粒子群初始位置和速度随机产生，然后按公式(1)(2)进行迭代，直至找到满意的解。目前，常用的粒子群算法将全体粒子群(Global)分成若干个有部分粒子重叠的相邻子群，每个粒子根据子群(Local)内历史最优Pl调整位置，即公式(2)中Pgd换为Pld。&lt;/p&gt;

&lt;p&gt;2、粒子群优化BP神经网络&lt;/p&gt;
&lt;p&gt;神经网络与粒子群算法的结合主要有两种方式：一是利用粒子群算法的全局搜索能力来优化神经网络的拓扑结构、连接权值和阈值，将粒子群算法良好的全局寻优能力与BP算法良好的局部寻优能力相结合，以提高神经网络的泛化能力和学习性能，从而改进神经网络的整体搜索效率；二是将神经网络嵌入到粒子群算法当中，利用神经网络良好的学习性能来改进粒子群算法的优化性能，以提高粒子群算法的收敛速度，减少计算的工作量。&lt;/p&gt;
&lt;p&gt;3、粒子群算法生成BP神经网络的权值和阈值，Matlab编程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;85&quot;&gt;
&lt;pre&gt;
&lt;span&gt;                            
function [W1,W2,B1,B2]&lt;/span&gt;=&lt;span&gt;pso(HiddenNum,InDim,OutDim)

&lt;/span&gt;%&lt;span&gt; clc;clear 
&lt;/span&gt;% tic;                              %&lt;span&gt;程序运行计时
E0&lt;/span&gt;=&lt;span&gt;0.001&lt;/span&gt;;                        %&lt;span&gt;允许误差
MaxNum&lt;/span&gt;=&lt;span&gt;100&lt;/span&gt;;                    %&lt;span&gt;粒子最大迭代次数
narvs&lt;/span&gt;=InDim*HiddenNum+&lt;span&gt;1&lt;/span&gt;+HiddenNum+HiddenNum;                         %目标函数的自变量个数=&lt;span&gt;51&lt;/span&gt;&lt;span&gt;
particlesize&lt;/span&gt;=&lt;span&gt;30&lt;/span&gt;;                    %粒子群规模=&lt;span&gt;200&lt;/span&gt;&lt;span&gt;
c1&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;;                            %&lt;span&gt;每个粒子的个体学习因子，也称为加速常数
c2&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;;                            %&lt;span&gt;每个粒子的社会学习因子，也称为加速常数
w&lt;/span&gt;=&lt;span&gt;0.6&lt;/span&gt;;                           %&lt;span&gt;惯性因子
vmax&lt;/span&gt;=&lt;span&gt;0.8&lt;/span&gt;;                        %&lt;span&gt;粒子的最大飞翔速度
x&lt;/span&gt;=-&lt;span&gt;5&lt;/span&gt;+&lt;span&gt;10&lt;/span&gt;*rand(particlesize,narvs);     %&lt;span&gt;粒子所在的位置
v&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;*rand(particlesize,narvs);         %&lt;span&gt;粒子的飞翔速度
&lt;/span&gt;%&lt;span&gt;用inline定义适应度函数以便将子函数文件与主程序文件放在一起，
&lt;/span&gt;%目标函数是：y=&lt;span&gt;1&lt;/span&gt;+(&lt;span&gt;2.1&lt;/span&gt;*(&lt;span&gt;1&lt;/span&gt;-x+&lt;span&gt;2&lt;/span&gt;*x.^&lt;span&gt;2&lt;/span&gt;).*exp(-x.^&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;%&lt;span&gt;inline命令定义适应度函数如下：
fitness&lt;/span&gt;=inline(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1/(1+(2.1*(1-x+2*x.^2).*exp(-x.^2/2)))&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;%&lt;span&gt;inline定义的适应度函数会使程序运行速度大大降低
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;:particlesize%&lt;span&gt;粒子群规模
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;:narvs %&lt;span&gt;目标函数自变量个数
        f(i)&lt;/span&gt;=&lt;span&gt;fitness(x(i,j));
    end
end
personalbest_x&lt;/span&gt;=x;%&lt;span&gt;30&lt;/span&gt;*&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
personalbest_faval&lt;/span&gt;=f;%&lt;span&gt;30&lt;/span&gt;*&lt;span&gt;1&lt;/span&gt;&lt;span&gt; 但是是
[globalbest_faval i]&lt;/span&gt;=&lt;span&gt;min(personalbest_faval);
globalbest_x&lt;/span&gt;=&lt;span&gt;personalbest_x(i,:);
k&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; k&amp;lt;=&lt;span&gt;MaxNum
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:particlesize
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:narvs
            f(i)&lt;/span&gt;=&lt;span&gt;fitness(x(i,j));
        end
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; f(i)&amp;lt;personalbest_faval(i) %&lt;span&gt;判断当前位置是否是历史上最佳位置
            personalbest_faval(i)&lt;/span&gt;=&lt;span&gt;f(i);
            personalbest_x(i,:)&lt;/span&gt;=&lt;span&gt;x(i,:);
        end
    end
    [globalbest_faval i]&lt;/span&gt;=&lt;span&gt;min(personalbest_faval);
    globalbest_x&lt;/span&gt;=&lt;span&gt;personalbest_x(i,:);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;:particlesize %&lt;span&gt;更新粒子群里每个个体的最新位置
        v(i,:)&lt;/span&gt;=w*v(i,:)+c1*rand*(personalbest_x(i,:)-&lt;span&gt;x(i,:))...
            &lt;/span&gt;+c2*rand*(globalbest_x-&lt;span&gt;x(i,:));
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;:narvs    %&lt;span&gt;判断粒子的飞翔速度是否超过了最大飞翔速度
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; v(i,j)&amp;gt;&lt;span&gt;vmax;
                v(i,j)&lt;/span&gt;=&lt;span&gt;vmax;
            elseif v(i,j)&lt;/span&gt;&amp;lt;-&lt;span&gt;vmax;
                v(i,j)&lt;/span&gt;=-&lt;span&gt;vmax;
            end
        end
        x(i,:)&lt;/span&gt;=x(i,:)+&lt;span&gt;v(i,:);
    end
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; abs(globalbest_faval)&amp;lt;E0,&lt;span&gt;break&lt;/span&gt;&lt;span&gt;,end
    k&lt;/span&gt;=k+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
end
Value1&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;/globalbest_faval-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;; 
Value1&lt;/span&gt;=&lt;span&gt;num2str(Value1);
&lt;/span&gt;%&lt;span&gt; strcat指令可以实现字符的组合输出
disp(strcat(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the maximum value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,Value1));
&lt;/span&gt;%&lt;span&gt;输出最大值所在的横坐标位置
Value2&lt;/span&gt;=&lt;span&gt;globalbest_x; 
&lt;/span&gt;% % Value2=&lt;span&gt;num2str(Value2);
&lt;/span&gt;% % disp(strcat(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;the corresponding coordinate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,Value2));
&lt;/span&gt;% x=-&lt;span&gt;2&lt;/span&gt;:&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;% y=&lt;span&gt;2.1&lt;/span&gt;*(&lt;span&gt;1&lt;/span&gt;-x+&lt;span&gt;2&lt;/span&gt;*x.^&lt;span&gt;2&lt;/span&gt;).*exp(-x.^&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;% plot(x,y,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;m-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;linewidth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;%&lt;span&gt; hold on;
&lt;/span&gt;% plot(globalbest_x,&lt;span&gt;1&lt;/span&gt;/globalbest_faval-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;linewidth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;% legend(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;样本的输出值&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;网络的输出值&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);xlabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);grid on;toc;

&lt;/span&gt;%&lt;span&gt; 赋值给 bp神经网络的权值和阈值
W1&lt;/span&gt;=&lt;span&gt;zeros(HiddenNum,InDim);
&lt;/span&gt;% B1=zeros(HiddenNum,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;% W2=zeros(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,HiddenNum);           
&lt;/span&gt;% B2=zeros(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,OutDim); 

    biaozhi&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; wi=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:HiddenNum
        W1(wi,:)&lt;/span&gt;=Value2(&lt;span&gt;1&lt;/span&gt;,biaozhi:biaozhi+InDim-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        biaozhi&lt;/span&gt;=wi*InDim+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    end
    B1&lt;/span&gt;=Value2(&lt;span&gt;1&lt;/span&gt;,biaozhi:biaozhi+HiddenNum-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    B1&lt;/span&gt;=B1&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    W2=Value2(&lt;span&gt;1&lt;/span&gt;,biaozhi+HiddenNum:biaozhi+HiddenNum+HiddenNum-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    B2&lt;/span&gt;=Value2(&lt;span&gt;1&lt;/span&gt;,biaozhi+HiddenNum+&lt;span&gt;HiddenNum);
end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 27 May 2020 00:27:00 +0000</pubDate>
<dc:creator>未名w</dc:creator>
<og:description>1、粒子群优化算法 粒子群算法(particle swarm optimization，PSO)由Kennedy和Eberhart在1995年提出，该算法模拟鸟集群飞行觅食的行为，鸟之间通过集体的协作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weimingai/p/12970255.html</dc:identifier>
</item>
<item>
<title>1700人点反对的LeetCode问题，是因为太难了吗？ - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12970247.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12970247.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;，原创不易，求个关注&lt;/p&gt;
&lt;p&gt;今天是&lt;strong&gt;LeetCode专题&lt;/strong&gt;的第40篇文章，我们一起来看的是LeetCode中的71题Simplify Path，中文名是简化路径。&lt;/p&gt;
&lt;p&gt;这题的难度是Medium，通过率是1/3左右，也是一道踩多捧少的题，一共有737个点赞，1703个反对。老实讲我觉得反对得不冤，我先卖个关子，等会来详细聊聊它为什么会被踩。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;题意&quot;&gt;题意&lt;/h2&gt;
&lt;p&gt;题目会给定一个字符串，表示一个&lt;strong&gt;Unix系统&lt;/strong&gt;下的文件路径，这个路径当中会包含一些路径的计算， 要求我们返回简化之后的结果。&lt;/p&gt;
&lt;p&gt;在Unix系统下用/来分隔文件夹，比如/home/download/file.txt。在这个路径当中支持简单的运算，比如.表示&lt;strong&gt;当前文件夹&lt;/strong&gt;。所以如果我们当前终端在download这个文件夹下，我们要访问file.txt文件，可以使用相对路径./file.txt即可。除此之外，还包括..操作。..表示&lt;strong&gt;当前文件夹的上层文件夹&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如如果我们在download文件夹下，当我们运行cd ..，那么我们就会返回到download文件夹的上层，也就是home文件夹下。我们是可以把..和.嵌入在文件路径中使用的。比如说/home/download/../download/file.txt也是合法的，中间由于我们嵌入了..所以会返回到download的上层也就是home，然后再进入download。虽然这样很费劲，但是是合法的。只要你愿意，可以不停地利用..回到上层，来回穿梭。&lt;/p&gt;
&lt;p&gt;我们要返回的是这个&lt;strong&gt;路径简化之后的版本&lt;/strong&gt;也就是：/home/download/file.txt&lt;/p&gt;
&lt;p&gt;我们来看几个案例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Input: &quot;/home/&quot;
Output: &quot;/home&quot;
Explanation: Note that there is no trailing slash after the last directory name.

Input: &quot;/../&quot;
Output: &quot;/&quot;
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.

Input: &quot;/a/../../b/../c//.//&quot;
Output: &quot;/c&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;题解&quot;&gt;题解&lt;/h2&gt;
&lt;p&gt;这题其实也是&lt;strong&gt;模拟题&lt;/strong&gt;，不过相比之前我们做过的模拟题难度要小上很多。这道题的思路还是蛮明显的，由于存在..和.的操作，我们需要记录下来访问的路径，在..向上移动的时候把之前的文件夹抛弃掉。&lt;/p&gt;
&lt;p&gt;举个例子，a/b/../b/d/e&lt;/p&gt;
&lt;p&gt;我们在b之后使用了..回到了a，然后我们再次进入b往下。显然这里&lt;strong&gt;由于..导致b在路径当中出现了两次&lt;/strong&gt;，这是多余的。我们需要在..回到上层的时候把b抛弃掉。对于.操作来说，由于它就表示当前路径，所以对于答案并不会影响，我们直接忽略它的存在即可。&lt;/p&gt;
&lt;p&gt;理解了这个思路之后，实现是非常简单的，我们只需要&lt;strong&gt;根据/将字符串分段&lt;/strong&gt;。每一段当中除了.和..之外就是文件夹的名称，我们用一个list去存储从上到下的经过的文件夹，遇见..就将最后一个添加的元素抛弃。最后用/将它们join在一起即可，唯一需要注意的是，当我们已经到了顶层的时候，如果我们继续执行..并不会报错，而是会停留在原地。所以我们需要特殊判断这种情况，除此之外就几乎没有难度了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def simplifyPath(self, path: str) -&amp;gt; str:
        folders = []
        # 按照/分割
        fs = path.split(&quot;/&quot;)
        for f in fs:
            # .直接跳过即可，不会影响结果
            if f == '.':
                continue
            # 如果是..需要判断是否在顶层
            # 不在顶层的话抛弃掉最后插入的文件夹
            if f == '..':
                if len(folders) &amp;gt; 0:
                    folders.pop()
            elif f != '':
                folders.append(f)
                
        return '/' + '/'.join(folders)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码非常简单，只有10行左右。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;到这里，关于题解的部分就结束了。&lt;/p&gt;
&lt;p&gt;我们回到标题当中的问题，为什么我会有这样的感受呢？是因为这道题我做过两次，上一次做的时候用的是C++。由于&lt;strong&gt;C++的string类型不支持split&lt;/strong&gt;，所以我需要自己进行split处理。整个的计算过程要复杂得多，我放一下C++的AC代码大家自己感受一下就知道了，简直不是一个次元的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;class Solution {
public:
    vector&amp;lt;string&amp;gt; split(string &amp;amp; path) {
        vector&amp;lt;string&amp;gt; vt;
        string cur = &quot;&quot;;
          // 遍历所有字符
        for (int i = 0; i &amp;lt; path.length(); i++) {
              // 如果是/ 说明需要把之前的内容放入vector
            if (path[i] == '/') {
                  // 如果是空或者是.就跳过，因为.没有意义
                if (cur != &quot;&quot; &amp;amp;&amp;amp; cur != &quot;.&quot;) {
                    vt.push_back(cur);
                }
                cur = &quot;&quot;;
            }else cur = cur + path[i];
        }
          // 要注意最后遗留的字符串
        if (cur != &quot;&quot; &amp;amp;&amp;amp; cur != &quot;.&quot;) vt.push_back(cur);
        return vt;
    }

    string simplifyPath(string path) {
        vector&amp;lt;string&amp;gt; dirs = split(path);
        string ret = &quot;&quot;;
          // 存储文件的结构
        vector&amp;lt;string&amp;gt; paths;
        for (string str : dirs) {
              // 如果是.. 则返回上级
            if (str == &quot;..&quot;) {
                if (paths.size() &amp;gt; 0) {
                    paths.pop_back();
                }
              // 否则则填入vector，表示合法
            }else paths.push_back(str);
        }
        for (string str : paths) ret = ret + &quot;/&quot; + str;
        if (ret == &quot;&quot;) return &quot;/&quot;;
        return ret;
    }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我说这些的重点并不是吐槽C++这门语言有多么落后，或者是证明Python有多么强大。不同的语言有不同的诞生背景，也有不同的强项，这个是很自然的。这题最主要的问题是&lt;strong&gt;不应该出这种因为语言本身的特性带来巨大差异的问题&lt;/strong&gt;，在正规比赛当中出这样的问题一定是会被疯狂吐槽的。&lt;/p&gt;
&lt;p&gt;举个例子，比如Java当中有大整数类BigInter，可以用来代替高精度算法来处理超过int64范围的大整数。如果有出题人出了一道非常复杂的大整数问题，那么使用Java的选手使用BigInter（算法比赛一般不允许使用Python），三两行代码就可以轻松AC，而C++选手却需要些上百行代码来实现高精度计算，这显然是不公平的。所以acm比赛当中，出题人一定会尽量避免这种语言特性差异巨大的问题，大概这也是这题遭黑的原因吧。&lt;/p&gt;
&lt;p&gt;这篇文章就到这里，如果喜欢本文，可以的话，请&lt;strong&gt;点个关注&lt;/strong&gt;，给我一点鼓励，也方便获取更多文章。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/27/172538137e01da9d?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 May 2020 00:24:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号：TechFlow，原创不易，求个关注 今天是LeetCode专题的第40篇文章，我们一起来看的是LeetCode中的71题Simplify Path，中文名是简化路径。 这题的难</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12970247.html</dc:identifier>
</item>
<item>
<title>.Net Core实现区块链初探 - Tiger.Wang</title>
<link>http://www.cnblogs.com/tiger-wang/p/12966882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-wang/p/12966882.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;区块链这么火，咱也跟个风。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;最近，银行总行关于数字货币即将推出的消息频传，把BTC也带得来了一波反弹。&lt;/p&gt;
&lt;p&gt;借着这个风，我们也研究一下区块链。&lt;/p&gt;

&lt;p&gt;通常大家说到区块链，实际包括两部分概念：&lt;/p&gt;
&lt;p&gt;第一个概念，就是狭义上的区块链。听起来很高大上又很复杂，但追根到底，它就是一种加密应用。&lt;/p&gt;
&lt;p&gt;提起加密，我们脑袋里会显现出：DES、3DES、AES、RSA、DSA、SHA-1、MD5……很多很多。&lt;/p&gt;
&lt;p&gt;狭义的区块链，其实就是&lt;strong&gt;使用这些加密技术而形成的一种应用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个应用又分为两个部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;区块&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;区块就是存放数据的一个独立空间。&lt;/p&gt;
&lt;p&gt;不好理解？举个例子：我们在纸上写个作文，写了好几篇。那每一篇纸上，都会有一些我们写的内容。这个内容，就是数据。而这张纸，就是一个区块。&lt;/p&gt;
&lt;p&gt;所以，区块就是放某些数据的一个特定的独立的空间。&lt;/p&gt;
&lt;p&gt;根据需要，一个数据可以放在一个区块上，也可以放在多个区块上。同时，一个区块可以只存放一个数据，也可以存放很多个数据。这儿不需要太纠结怎么放，自己决定就好。&lt;strong&gt;区块链关注的是数据的存放方式，而不是数据本身&lt;/strong&gt;。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;span&gt;链&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;链这个概念更简单，就是把上面说的区块，用一个链表记录下来。&lt;/p&gt;
&lt;p&gt;既然说到链表，就能想到，在链表上记录的区块，是有次序的。此外，最重要的是，链里的每一个区块，在记录数据的同时，也同时记录了他的前一个区块的信息（在区块链里，称之为指纹）。&lt;/p&gt;
&lt;p&gt;换句话说就是，每个区块里，都记录着这个区块前边所有区块的信息，同时，每个区块，都对这个区块后边的所有区块产生影响。&lt;/p&gt;

&lt;p&gt;这样的设计，会形成这样的效果：当改变一个区块的数据时，需要同时把这个区块后边所有区块的指纹信息全部进行同步更新。如果仅仅只改变这个区块本身的内容，那后边的区块会很容易通过指纹来验证这个区块非法和无效。&lt;/p&gt;
&lt;p&gt;第二个概念，是分布式存储&lt;/p&gt;
&lt;p&gt;上面区块链的概念中，在数据保存上有一个漏洞：如果一个非法用户真的把一个区块以及这个区块后边的所有区块都修改了，那他就改变了这个区块链里保存的数据。怎么破？&lt;/p&gt;
&lt;p&gt;一个有效的方式，就是分布式存储。把这样一个链，存放在很多个地方，每个地方都有这个链的一个副本。系统验证一个区块是否合法，除了验证链的合法性外，还需要验证这个区块在各处保存的副本是否一致。系统认可超过半数一致的区块为合法区块。&lt;/p&gt;
&lt;p&gt;这样，非法用户如果想改变一个区块的数据，不仅需要修改这个链，同时还需要把这个链在各处的副本中半数以上的记录也修改了。当这个副本的数量很大时，这将变成一个不可能完成的任务。&lt;/p&gt;

&lt;p&gt;当然，在互联网上，安全永远是相对的。去年币圈最大的事件，就是真的有一帮子黑客，利用廉价的服务器，造出了超过半数的区块链副本，然后修改区块数据，并让这些超过半数的副本认可并覆盖了正常的区块链数据，从而盗取了大量的数字币并抛售。&lt;/p&gt;
&lt;p&gt;这是题外话。&lt;/p&gt;

&lt;p&gt;区块链的概念就说到这里。&lt;/p&gt;
&lt;p&gt;今天的代码，我们仅研究区块链的原理和方法。分布式存储，有兴趣的话，可以研究一下P2P的种子结构和下载原理，路数是一样的。&lt;/p&gt;
&lt;p&gt;下面上代码。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;    &lt;span&gt;为了防止不提供原网址的转载，特在这里加上原文链接：&lt;a class=&quot;ng-star-inserted&quot; href=&quot;https://www.cnblogs.com/tiger-wang/p/12966882.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/tiger-wang/p/12966882.html&lt;/a&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;这个Demo的开发环境是：Mac + VS Code + Dotnet Core 3.1.2。&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;bash language-bash hljs&quot; readability=&quot;11&quot;&gt;$ dotnet --info&lt;br/&gt;.NET Core SDK (reflecting any global.json):&lt;br/&gt;Version:   3.1.201&lt;br/&gt;Commit:    b1768b4ae7&lt;p&gt;Runtime Environment:&lt;br/&gt;OS Name:     Mac OS X&lt;br/&gt;OS Version:  10.15&lt;br/&gt;OS Platform: Darwin&lt;br/&gt;RID:         osx.10.15-x64&lt;br/&gt;Base Path:   /usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/share/dotnet/sdk/3.1.201/&lt;/p&gt;&lt;p&gt;Host (useful &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; support):&lt;br/&gt;Version: 3.1.3&lt;br/&gt;Commit:  4a9f85e9f8&lt;/p&gt;&lt;p&gt;.NET Core SDKs installed:&lt;br/&gt;3.1.201 [/usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/share/dotnet/sdk]&lt;/p&gt;&lt;p&gt;.NET Core runtimes installed:&lt;br/&gt;Microsoft.AspNetCore.App 3.1.3 [/usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/share/dotnet/shared/Microsoft.AspNetCore.App]&lt;br/&gt;Microsoft.NETCore.App 3.1.3 [/usr/&lt;span class=&quot;hljs-built_in&quot;&gt;local&lt;/span&gt;/share/dotnet/shared/Microsoft.NETCore.App]&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;首先，在这个环境下建立工程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;创建Solution&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;bash language-bash hljs&quot;&gt;% dotnet new sln -o demo&lt;br/&gt;The template &lt;span class=&quot;hljs-string&quot;&gt;&quot;Solution File&quot;&lt;/span&gt; was created successfully.&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;span&gt;这次，我们用Console创建工程&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;bash language-bash hljs&quot; readability=&quot;3&quot;&gt;% &lt;span class=&quot;hljs-built_in&quot;&gt;cd&lt;/span&gt; demo&lt;br/&gt;% dotnet new webapi -o demo&lt;br/&gt;The template &lt;span class=&quot;hljs-string&quot;&gt;&quot;Console Application&quot;&lt;/span&gt; was created successfully.&lt;p&gt;Processing post-creation actions...&lt;br/&gt;Running &lt;span class=&quot;hljs-string&quot;&gt;'dotnet restore'&lt;/span&gt; on demo/demo.csproj...&lt;br/&gt;Determining projects to restore...&lt;br/&gt;Restored demo/demo.csproj (&lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; 170 ms).&lt;/p&gt;&lt;p&gt;Restore succeeded.&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基础工程搭建完成。&lt;/p&gt;

&lt;p&gt;在工程下面，创建一个目录&lt;code&gt;Models&lt;/code&gt;，并在目录下建立类&lt;code&gt;Block.cs&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Block&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; DateTimeOffset time_stamp { get; &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; object data { get; &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; pre_hash { get; &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; hash { get; &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; nonce { get; &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释一下各个字段：&lt;/p&gt;
&lt;p&gt;time_stamp：时间戳，也就是这个区块的创建时间&lt;/p&gt;
&lt;p&gt;data：数据，可以是任意类型，是我们要用区块链来保存的数据&lt;/p&gt;
&lt;p&gt;pre_hash：前一个区块的hash值&lt;/p&gt;
&lt;p&gt;hash：当前区块的hash值&lt;/p&gt;
&lt;p&gt;nonce：随机数&lt;/p&gt;
&lt;p&gt;在这几个字段中，真正在区块链中起作用的是后面三个字段：pre_hash、hash、nonce。&lt;/p&gt;
&lt;p&gt;在计算中，hash值是由这个区块的pre_hash、data、pre_hash、nonce四个字段共同计算产生。&lt;/p&gt;
&lt;p&gt;这样做，一方面，我们通过hash值可以验证保存的数据data，同时，也把前一个区块的hash信息保存到了这个区块中。&lt;/p&gt;
&lt;p&gt;nonce字段在这个demo中，实际意义不大，但在实际项目中，却有它的实用价值。比方BTC中，要求hash值有特定的格式（至少前8个字节全是0），需要通过改变nonce的值，来得到这样的hash。又因为hash无法逆向计算，所以只能用穷举法修改nonce，一个一个计算并测试hash，这个过程叫WK，&lt;/p&gt;

&lt;p&gt;有了区块model，创建链很简单。&lt;/p&gt;
&lt;p&gt;我们创建一个&lt;code&gt;BlockChains&lt;/code&gt;类，并在里面用&lt;code&gt;SortedList&lt;/code&gt;建立一个链。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BlockChains&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; SortedList&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, Block&amp;gt; _block_chains = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SortedList&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, Block&amp;gt;();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;链也建完了。&lt;/p&gt;
&lt;p&gt;后面，我们会在这个链中实现对于区块链的各种处理方法。&lt;/p&gt;

&lt;p&gt;下面我们在&lt;code&gt;BlockChains&lt;/code&gt;类中写一个往链中增加区块的方法：&lt;/p&gt;
&lt;pre readability=&quot;14&quot;&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot; readability=&quot;22&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; _hash_zero = &lt;span class=&quot;hljs-string&quot;&gt;&quot;Initialize_Hash_By_WangPlus&quot;&lt;/span&gt;;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;addBlockData&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(object data)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;Block new_block = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Block()&lt;br/&gt;{&lt;br/&gt;time_stamp = DateTimeOffset.Now,&lt;br/&gt;data = data,&lt;br/&gt;nonce = $&lt;span class=&quot;hljs-string&quot;&gt;&quot;{_random.Next(9999):D4}&quot;&lt;/span&gt;,&lt;br/&gt;};&lt;/p&gt;&lt;p&gt;new_block.pre_hash = _block_chains.Count &amp;lt;= &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; ? _hash_zero : _block_chains.Last().Value.hash;&lt;br/&gt;new_block.hash = calculateHash(new_block);&lt;/p&gt;&lt;p&gt;_block_chains.Add(_block_chains.Count + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, new_block);&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;calculateHash&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Block block)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (block == null)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;.Empty;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; data_json = JsonConvert.SerializeObject(block.data, Formatting.None);&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; block_string = $&lt;span class=&quot;hljs-string&quot;&gt;&quot;{block.time_stamp.Ticks.ToString()}|{block.pre_hash}|{data_json}|{block.nonce}&quot;&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;var block_hash = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SHA256Managed().ComputeHash(Encoding.UTF8.GetBytes(block_string));&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Convert.ToBase64String(block_hash);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个实现的方法中，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一个区块需要特殊处理，因为他的&lt;code&gt;pre_hash&lt;/code&gt;不存在，所以我们给了一个默认的串。&lt;/li&gt;
&lt;li&gt;计算&lt;code&gt;hash&lt;/code&gt;时，我们把区块的&lt;code&gt;time_stamp&lt;/code&gt;、&lt;code&gt;pre_hash&lt;/code&gt;、&lt;code&gt;data&lt;/code&gt;、&lt;code&gt;nonce&lt;/code&gt;全都包含在里面了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也是一个方法，加在&lt;code&gt;BlockChains&lt;/code&gt;中：&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot; readability=&quot;7&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;isBlockValid&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (index &amp;lt;= &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; || index &amp;gt; _block_chains.Count)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; ((index &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; _block_chains[index].pre_hash != _block_chains[index - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;].hash) || (index == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; _block_chains[index].pre_hash != _hash_zero))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (_block_chains[index].hash != calculateHash(index))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;calculateHash&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; calculateHash(_block_chains[index]);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个Demo中，没有实现分布存储，所以验证区块的部分，我们只做了简单验证：验证当前区块和前一个区块的hash是否匹配。&lt;/p&gt;

&lt;p&gt;做到这儿，这个简单的区块链Demo就完成了。&lt;/p&gt;

&lt;p&gt;上面是一个简单的区块链应用中，区块链概念的实现。&lt;/p&gt;
&lt;p&gt;在实际应用中，我们需要理解以下内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;区块链是一个加密技术，它本身跟数据无关；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;区块链在形成后，是一个只读链，就是说在通常情况下，我们不会从一个链中修改或删除一个区块。因为这会导致后续所有区块的修改，这个代价很大；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;因为区块不可更改，所以区块中存储的数据也不可更改。如果保存的数据有错，通常是采用类似记帐的方式，用反冲记录去消除这个错误，而不是修改区块链；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;区块链应用中，在安全级别要求比较高的情况下，应该把开发重点放在分布存储上面。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面Demo的代码已传到Github。&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/humornif/Demo-Code/tree/master/0010/demo&quot;&gt;https://github.com/humornif/Demo-Code/tree/master/0010/demo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;（全文完）&lt;/p&gt;

&lt;hr/&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td&gt;&lt;img src=&quot;https://i.niupic.com/images/2020/05/07/7Eyn.jpg&quot; alt=&quot;&quot; width=&quot;160&quot; height=&quot;160&quot;/&gt;&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;微信公众号：老王Plus&lt;/p&gt;
&lt;p&gt;扫描二维码，关注个人公众号，可以第一时间得到最新的个人文章和内容推送&lt;/p&gt;
&lt;p&gt;本文版权归作者所有，转载请保留此声明和原文链接&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 27 May 2020 00:19:00 +0000</pubDate>
<dc:creator>Tiger.Wang</dc:creator>
<og:description>区块链这么火，咱也跟个风。 一、前言 最近，银行总行关于数字货币即将推出的消息频传，把BTC也带得来了一波反弹。 借着这个风，我们也研究一下区块链。 通常大家说到区块链，实际包括两部分概念： 第一个概</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tiger-wang/p/12966882.html</dc:identifier>
</item>
<item>
<title>ketchup服务治理 - simple-</title>
<link>http://www.cnblogs.com/alangur/p/12965908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alangur/p/12965908.html</guid>
<description>[unable to retrieve full-text content]ketcup git地址：https://github.com/simple-gr/ketchup 服务治理是什么 企业为了确保事情顺利完成而实施的过程，包括最佳实践、架构原则、治理规程、规律以及其他决定性的因素。 我理解的就是服务治理就是一颗药，用来治疗服务之间存在的各种疑难杂症从而能让他正常的运</description>
<pubDate>Wed, 27 May 2020 00:18:00 +0000</pubDate>
<dc:creator>simple-</dc:creator>
<dc:identifier>https://www.cnblogs.com/alangur/p/12965908.html</dc:identifier>
</item>
<item>
<title>抛开技术细节，分享五年职场的个人感悟及道理总结 - leapMie</title>
<link>http://www.cnblogs.com/leap/p/12906564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leap/p/12906564.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;首发地址 &lt;a href=&quot;https://blog.leapmie.com/archives/93dada07/&quot;&gt;https://blog.leapmie.com/archives/93dada07/&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;个人简介&quot;&gt;个人简介&lt;/h2&gt;
&lt;h3 id=&quot;1-工作过程&quot;&gt;1. 工作过程&lt;/h3&gt;
&lt;p&gt;目前坐标广州，从毕业至今五年一直在当前的公司工作着，从部门最开始的十几人团队发展到现在的将近两百号人，几年了没换工作不是因为习惯舒适区，相反这一路过来都是不断的突破，因为团队在快速壮大，面临的问题也在不断升级，根本没有太多的时间可以休息整顿。当然，上百人的增速那也是部门而已，我的团队人数增速并不大，只是从两三人到目前的二十人，不过项目金额却是从最开始的十万级到目前的千万级，项目难度升级倒是挺大的。&lt;/p&gt;
&lt;h3 id=&quot;2-自我评价&quot;&gt;2. 自我评价&lt;/h3&gt;
&lt;h4 id=&quot;优点&quot;&gt;优点&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;能快速准确的理解需求&lt;/li&gt;
&lt;li&gt;对技术方案有较好的判断及把控&lt;/li&gt;
&lt;li&gt;性格不是主动外交型，面对外部沟通内心会有一定抵触，但还是能较好的完成大部分沟通协调工作&lt;/li&gt;
&lt;li&gt;相对容易接受变化，不会太死板&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;缺点&quot;&gt;缺点&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;技术还有很大进步空间。太多协调处理的事消耗精力，难以全身心投入到技术沉淀&lt;/li&gt;
&lt;li&gt;还没换过公司，没有深度接触其他公司的文化及工作流程&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;其他&quot;&gt;其他&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;一直有做产品的心，奈何团队的几个产品都没能成功落地，工作的方向还是项目型&lt;/li&gt;
&lt;li&gt;内心向往互联网方向，希望最后还是能进入互联网行业&lt;/li&gt;
&lt;li&gt;以架构师、CTO的目标前进，一方面永不放弃技术，另一方面在面对管理协调等“杂事”时，也会尽量调整心态去接受。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;3-当前项目&quot;&gt;3. 当前项目&lt;/h3&gt;
&lt;p&gt;一直都在想，如果以当前能力再去做小项目简直是游刃有余，能做得漂漂亮亮，但现实是一直以来都被推着往上走，根本不能回头，不过也正因如此才有不断的进步。目前在做的是一个省级项目，虽然概括起来项目都是增删查改，但背后要处理的问题复杂度与普通项目对比绝对不是一个量级的。&lt;/p&gt;
&lt;h2 id=&quot;个人感悟及道理总结&quot;&gt;个人感悟及道理总结&lt;/h2&gt;
&lt;h3 id=&quot;1-工作的本质就是解决问题&quot;&gt;1. 工作的本质就是解决问题&lt;/h3&gt;
&lt;p&gt;工作的本质就是解决问题，而你的位置决定了你面临的问题复杂度。按照事情发展的规律，一件复杂的事情总会出现大大小小的状况外的问题，可以说没问题才是不正常。当出现问题的时候应尽量保持淡定和积极的心态，不必过分焦虑和惊慌，因为你工作的意义就是来解决问题的。当你能坦然面对时，这个问题的难度已经减半。&lt;/p&gt;
&lt;h3 id=&quot;2-事情最难的是从混沌到有序&quot;&gt;2. 事情最难的是从混沌到有序&lt;/h3&gt;
&lt;p&gt;事情最难的是从混沌到有序的过程，你看到的成功产品看似简单，但每一个功能、每一个细节都是由一个个大大小小的决策构成，每个决策的背后都会对应大量的分析、讨论、协调与纠结的过程。每一个能带来价值的产品或项目都是伟大的，背后都是一帮人努力的结晶。&lt;/p&gt;
&lt;h3 id=&quot;3-要做成一件事不是那么简单&quot;&gt;3. 要做成一件事不是那么简单&lt;/h3&gt;
&lt;p&gt;要做成一件事，就需要去主动促使这件事的往前推进，这个过程会有很多的阻力，需要协调各方各面。有时候当事情完满结束时，回过头想好像也并不是那么难，但如果在过程中把每个细节都记下来，那肯定是每天都面对着各种奇奇怪怪的问题。&lt;/p&gt;
&lt;h3 id=&quot;4-有人的地方就有江湖&quot;&gt;4. 有人的地方就有江湖&lt;/h3&gt;
&lt;p&gt;有人的地方就有江湖，有江湖的地方就有是非。曾经我们还是个小团队的时候，大家都很善良淳朴，但是当团队壮大后，一切就都不那么简单了。一来是人际关系变得错综复杂，二来是做的事情大了，与外界的接触也越来越多，不能再待在象牙塔里，不得不面对社会的复杂性。&lt;/p&gt;
&lt;h4 id=&quot;41-没有密不透风的墙&quot;&gt;4.1 没有密不透风的墙&lt;/h4&gt;
&lt;p&gt;在办公室里，感受最深的就是没有密不透风的墙。工作中总会听到一些小道消息，有公司的经营状况，有高层的动向，有同事间的八卦，有某人对某人的吐槽，真真假假，难辨是非。这也是告诫自己，不要过多的吐槽别人，因为你真的不知道这个吐槽是怎么去到你吐槽对象的耳边的。。。同时当你听闻某人对自己的吐槽时，也没必要过于执着，一来不知真假，二来江湖难免冲突，对于吐槽的内容有则改之即可。&lt;/p&gt;
&lt;h4 id=&quot;42-做事留痕&quot;&gt;4.2 做事留痕&lt;/h4&gt;
&lt;p&gt;另外，在这个江湖中同样重要的是要学会保护自己。做的事情大了，就肯定要跟外部打交道，这个外部包括外部团队、外部企业等，你可以保持真诚合作，但也要注意做事过程中保留痕迹，因为你不能保证当发生利益冲突时，是否会导致合作关系破裂，当你没有证据时，很容易有理说不清。&lt;br/&gt;我认为在团队内部应尽量保持真诚，不要过多计较。但是当与团队边界外的相关方合作时，要有一定的戒备，关系越远戒备等级也越高，关系由近致远为：跨团队 -&amp;gt; 跨部门 -&amp;gt; 跨企业。&lt;/p&gt;
&lt;h3 id=&quot;5-没有绝对的对错，只有不同的立场&quot;&gt;5. 没有绝对的对错，只有不同的立场&lt;/h3&gt;
&lt;p&gt;是个简单的道理，不用细说了，遇事能保持客观就好。&lt;/p&gt;
&lt;h3 id=&quot;6-做过的事总会有意义的&quot;&gt;6. 做过的事总会有意义的&lt;/h3&gt;
&lt;p&gt;多做点总是有好处的，现在认为没用的事情，但是这份经验总会在某一天派上用场的。但也要注意分清主次，不要在分支上越走越远了，有些事情点到为止拿到经验值即可。&lt;/p&gt;
&lt;h3 id=&quot;7-站在用户角度思考问题&quot;&gt;7. 站在用户角度思考问题&lt;/h3&gt;
&lt;p&gt;一定要站在用户的角度思考问题，如果不考虑用户的实际使用场景，容易简单认为用户都是无理取闹，武断的否定需求，最终只从技术的简易性去设计方案。有时候一个小细节的实现能对用户工作效率带来非常大的提升，一个技术方案的确认并不那么简单，要结合用户的使用场景、技术的简洁合理、投入成本等多因素综合决策。&lt;/p&gt;
&lt;h3 id=&quot;8-合理上升问题&quot;&gt;8. 合理上升问题&lt;/h3&gt;
&lt;p&gt;从两方面说为什么要上升问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 信息断层很致命&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目经理最害怕的是任务下发后，成员埋头苦干，遇到问题不敢问，遇到风险不敢说，到了节点交付日期才说问题解决不了。有些问题，只要及早的向上反馈，解决办法是有多种的：可能可以请教高人指点，可能可以跟客户提前交底降低心理预期，可能可以通过方案的变更降低难度。但如果不把问题的风险尽早暴露，到了最后节点再爆发，可能问题就是一发不可收拾了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 会哭的孩子有奶吃&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;领导每天要处理的事情都很多，你不出声代表你没问题，那领导也肯定不会主动去找麻烦。所以当问题真的超出自己能力范围后，就应该考虑是否要烦扰领导，把问题上升了。而且有些问题在自己的层面是个大问题，但是在领导的眼里根本不是问题。要学会在必要时候合理的主动上升问题，不要什么都自己藏着掖着。当然，也要注意把握这个度，不要事事都麻烦别人。&lt;/p&gt;
&lt;h2 id=&quot;关于团队管理&quot;&gt;关于团队管理&lt;/h2&gt;
&lt;h3 id=&quot;1-交付的信息越多越有利于做出正确判断&quot;&gt;1. 交付的信息越多越有利于做出正确判断&lt;/h3&gt;
&lt;p&gt;通常我们做技术的，很少会出于私心而对一些信息的交付有所保留，但很多时候是因为我们太忙，在分发任务时容易缺乏耐心。但是对于复杂的任务，要保证成员交付的产物与你的期望一致，应该交付尽可能多的信息，如需求的背景、你希望的实现效果及实现方式、包含的一些隐性需求（如性能、可扩展性）、潜在风险等，只有当团队成员掌握足够多的信息，在遇到问题的歧义时，他才能做出正确的判断，避免任务的返工。&lt;/p&gt;
&lt;h3 id=&quot;2-梯度的搭建很重要&quot;&gt;2. 梯度的搭建很重要&lt;/h3&gt;
&lt;p&gt;你可以保持扁平化的氛围，但是工作任务还是要尽可能的搭建梯度，不然什么事情都会上升到你这里，你会被各种琐事打断你的思路，消耗你的精力。只有当你手上的事情能分发出去，你才能去做更重要的事情。&lt;/p&gt;
&lt;h3 id=&quot;3-团队情绪很重要&quot;&gt;3. 团队情绪很重要&lt;/h3&gt;
&lt;p&gt;当开始带领团队后，你就不能再只关注自身，和你一起做事的兄弟，他们不是没有感情的劳动机器，当他们的状态不佳时，你应该更主动的去关心他们，可能是因为一些私事，可能是因为薪酬福利，可能是因为工作强度，这些可能性是需要了解的，而不是一味的吐槽。只有保证团队的情绪是健康的，才能保持高昂的士气，确保团队有足够的战斗力。&lt;/p&gt;
&lt;h3 id=&quot;4-对团队成员要有要求&quot;&gt;4. 对团队成员要有要求&lt;/h3&gt;
&lt;p&gt;不能对团队成员过于仁慈，一定要对成员提出要求。千万不要因为成员的能力水平不足，或是担心任务超出他们的能力时会有抵触情绪，于是一直只安排简单的任务给到他们。你的仁慈会阻碍成员的成长，只有安排超出他们一定能力范围的工作时，在一定的压力情况下才会有快速的成长和突破，这样你的成员能够更多的为你分担工作，达到双赢的局面。&lt;/p&gt;
&lt;h3 id=&quot;5-不患寡而患不均&quot;&gt;5. 不患寡而患不均&lt;/h3&gt;
&lt;p&gt;公平是很难做到的，但也要尽量保证。在工作量分配上，要避免能力强的人承担过多，而能力差的人反而轻轻松松过日子。在奖金福利的分配上更是要小心，相当容易造成不满情绪，别把好事变成坏事。&lt;/p&gt;
&lt;h3 id=&quot;6-做好决策&quot;&gt;6. 做好决策&lt;/h3&gt;
&lt;p&gt;团队管理者就是要做大量的决策，把握方向。做技术的都希望可以玩新技术的，团队成员由于不用担责通常都是激进派，但作为决策者必须衡量其利弊，不能过于保守，也不能过于激进。当然说起来简单，要做好是需要大量的经验积累及学习的。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;时间匆匆，一不小心就已经五年工作经验，这一路也是跌跌撞撞的过来，以上都是个人的感悟总结，当然以上也有很多是“道理都懂”，自己也没能做好的。要说对这几年的工作生涯很满意那是不可能的，不过也不至于充满遗憾，毕竟成长嘛，还是有的。希望以后的道路更精彩，未来可期。&lt;/p&gt;
&lt;p&gt;如果希望再多的交流，可以关注我的公众号换取微信号，乐意解答各种各样的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.blog.leapmie.com/leapmie_wxdyh.png&quot; alt=&quot;leapMie公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 May 2020 00:17:00 +0000</pubDate>
<dc:creator>leapMie</dc:creator>
<og:description>首发地址 https://blog.leapmie.com/archives/93dada07/ 个人简介 1. 工作过程 目前坐标广州，从毕业至今五年一直在当前的公司工作着，从部门最开始的十几人团队</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leap/p/12906564.html</dc:identifier>
</item>
<item>
<title>Flutter 使用Navigator进行局部跳转页面 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/12970179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/12970179.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200527065210062-951827675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;老孟导读：Navigator组件使用的频率不是很高，但在一些场景下非常适用，比如局部表单多页填写、底部导航一直存在，每个tab各自导航场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Navigator 是管理路由的控件，通常情况下直接使用&lt;code&gt;Navigator.of(context)&lt;/code&gt;的方法来跳转页面，之所以可以直接使用&lt;code&gt;Navigator.of(context)&lt;/code&gt;是因为在&lt;code&gt;WidgetsApp&lt;/code&gt;中使用了此控件，应用程序的根控件通常是&lt;code&gt;MaterialApp&lt;/code&gt;，&lt;code&gt;MaterialApp&lt;/code&gt;包含&lt;code&gt;WidgetsApp&lt;/code&gt;，所以可以直接使用Navigator的相关属性。&lt;/p&gt;
&lt;p&gt;Navigator用法非常简单，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Navigator(
  initialRoute: '/',
  onGenerateRoute: (RouteSettings settings) {
    WidgetBuilder builder;
    switch (settings.name) {
      case 'home':
        builder = (context) =&amp;gt; PageA();
        break;
      case 'user':
        builder = (context) =&amp;gt; PageB();
        break;
    }
    return MaterialPageRoute(builder: builder, settings: settings);
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;initialRoute&lt;/code&gt;表示初始化路由，&lt;code&gt;onGenerateRoute&lt;/code&gt;表示根据&lt;strong&gt;RouteSettings&lt;/strong&gt;生成路由。&lt;/p&gt;
&lt;p&gt;那么在什么情况下需要使用Navigator？在需要局部页面跳转的地方使用Navigator，如下面的场景：&lt;/p&gt;
&lt;h2 id=&quot;头条客户端举报场景&quot;&gt;头条客户端举报场景&lt;/h2&gt;
&lt;p&gt;头条客户端每一个新闻下面都有一个“叉号”，点击弹出相关信息，点击其中的局部，会在当前小窗户内跳转到举报页面，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200527065232704-704664292.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此场景就是使用Navigator的典型场景，点击举报，并不是全屏切换页面，而是仅仅在当前弹出的页面进行切换。&lt;/p&gt;
&lt;p&gt;首页代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;@override
Widget build(BuildContext context) {
  return Center(
    child: Container(
      height: 350,
      width: 300,
      child: Navigator(
        initialRoute: '/',
        onGenerateRoute: (RouteSettings settins) {
          WidgetBuilder builder;
          switch (settins.name) {
            case '/':
              builder = (context) =&amp;gt; PageC();
              break;
          }
          return MaterialPageRoute(builder: builder);
        },
      ),
    ),
  );
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Navigator&lt;/code&gt;的初始化路由为&lt;strong&gt;PageC&lt;/strong&gt;页面，&lt;strong&gt;PageC&lt;/strong&gt;页面代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class PageC extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Card(
        child: Column(
          children: &amp;lt;Widget&amp;gt;[
            _buildItem(Icons.clear, '不感兴趣', '减少这类内容'),
            Divider(),
            _buildItem(Icons.access_alarm, '举报', '标题夸张，内容质量差 等',
                showArrow: true, onPress: () {
              Navigator.of(context).push(MaterialPageRoute(builder: (context) {
                return PageD();
              }));
            }),
            Divider(),
            _buildItem(Icons.perm_identity, '拉黑作者：新华网客户端', ''),
            Divider(),
            _buildItem(Icons.account_circle, '屏蔽', '军事视频、驾驶员等'),
          ],
        ),
      ),
    );
  }

  _buildItem(IconData iconData, String title, String content,
      {bool showArrow = false, Function onPress}) {
    return Row(
      children: &amp;lt;Widget&amp;gt;[
        Icon(iconData),
        SizedBox(
          width: 20,
        ),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: &amp;lt;Widget&amp;gt;[
              Text(
                title,
                style: TextStyle(fontSize: 18),
              ),
              Text(
                content,
                style: TextStyle(
                    color: Colors.black.withOpacity(.5), fontSize: 14),
              )
            ],
          ),
        ),
        !showArrow
            ? Container()
            : IconButton(
                icon: Icon(Icons.arrow_forward_ios),
                iconSize: 16,
                onPressed: onPress,
              ),
      ],
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;PageC&lt;/strong&gt;页面跳转到&lt;strong&gt;PageD&lt;/strong&gt;页面，&lt;strong&gt;PageD&lt;/strong&gt;页面代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class PageD extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      height: 200,
      width: 250,
      color: Colors.grey.withOpacity(.5),
      child: Column(
        children: &amp;lt;Widget&amp;gt;[
          Row(
            children: &amp;lt;Widget&amp;gt;[
              IconButton(
                icon: Icon(Icons.arrow_back_ios),
                onPressed: () {
                  Navigator.of(context).pop();
                },
              ),
              Text('返回'),
              SizedBox(
                width: 30,
              ),
              Text('举报'),
            ],
          ),
        ],
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200527065252537-314239190.gif&quot; alt=&quot;Navigator_2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终实现了局部跳转效果，只在中间区域变化，其他区域不变。&lt;/p&gt;
&lt;h2 id=&quot;tab内跳转&quot;&gt;Tab内跳转&lt;/h2&gt;
&lt;p&gt;还有一个典型到应用场景就Tab内跳转，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200527065302468-1505751050.gif&quot; alt=&quot;Navigator_3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;底部导航一直存在，每个tab都有自己的导航器。&lt;/p&gt;
&lt;p&gt;首页代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class TabMain extends StatefulWidget {
  @override
  State&amp;lt;StatefulWidget&amp;gt; createState() =&amp;gt; _TabMainState();
}

class _TabMainState extends State&amp;lt;TabMain&amp;gt; {
  int _currentIndex = 0;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: IndexedStack(
        index: _currentIndex,
        children: &amp;lt;Widget&amp;gt;[
          TabNavigator(0),
          TabNavigator(1),
          TabNavigator(2),
        ],
      ),
      bottomNavigationBar: BottomNavigationBar(
        onTap: (int index) {
          setState(() {
            _currentIndex = index;
          });
        },
        currentIndex: _currentIndex,
        items: &amp;lt;BottomNavigationBarItem&amp;gt;[
          BottomNavigationBarItem(title: Text('首页'), icon: Icon(Icons.home)),
          BottomNavigationBarItem(title: Text('书籍'), icon: Icon(Icons.book)),
          BottomNavigationBarItem(
              title: Text('我的'), icon: Icon(Icons.perm_identity)),
        ],
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首页定义了3个tab及切换效果。&lt;/p&gt;
&lt;p&gt;定义TabNavigator：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class TabNavigator extends StatelessWidget {
  TabNavigator(this.index);

  final int index;

  @override
  Widget build(BuildContext context) {
    return Navigator(
      initialRoute: '/',
      onGenerateRoute: (RouteSettings settins) {
        WidgetBuilder builder;
        switch (settins.name) {
          case '/':
            builder = (context) =&amp;gt; ListPage(index);
            break;
        }
        return MaterialPageRoute(builder: builder);
      },
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;列表页面，此页面一般为List页面，点击其中一个跳转到相关详情页面，这里为了简便，只放了一个跳转按钮：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class ListPage extends StatelessWidget {
  ListPage(this.index);

  final int index;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(),
      body: Center(
        child: RaisedButton(
          child: Text('$index'),
          onPressed: () {
            Navigator.of(context).push(MaterialPageRoute(builder: (context) {
              return DetailPage();
            }));
          },
        ),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详情页面&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class DetailPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(),
      body: Center(
        child: Text('DetailPage'),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然Navigator控件不是特别常用，但在一些场景下非常适用。&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（近200个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200527065305190-1444789088.png&quot; alt=&quot;&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200527065306698-1248689259.png&quot; alt=&quot;&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Tue, 26 May 2020 22:53:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：Navigator组件使用的频率不是很高，但在一些场景下非常适用，比如局部表单多页填写、底部导航一直存在，每个tab各自导航场景。 Navigator 是管理路由的控件，通常情况下直接使用N</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/12970179.html</dc:identifier>
</item>
<item>
<title>mybatis是怎样炼成的 - RoyTian</title>
<link>http://www.cnblogs.com/roytian/p/12762218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/roytian/p/12762218.html</guid>
<description>&lt;p&gt;一些个人感受：不管分析什么源码，如果我们能摸索出作者的心路历程，跟着他的脚步一步一步往前走，这样才能接近事实的真相，也能更平滑更有趣的学习到知识。跟福尔摩斯探案一样，作者都经历了些什么，为什么他要这样去设计这样去做，留给我们的只有无声的代码和那一段孤独的日子。&lt;/p&gt;
&lt;p&gt;阅读顺序建议是从上往下阅读，如果直接跳转到某一节，没有基于上面的分析推理的话可能会不容易理解。&lt;/p&gt;
&lt;h2&gt;一切的一切要从JDBC开始说起&lt;/h2&gt;
&lt;p&gt;先来一段JDBC代码回忆预热一下，方便我们后面进入正题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
Class.forName(&quot;com.mysql.jdbc.Driver&quot;&lt;span&gt;);
Connection conn &lt;/span&gt;=&lt;span&gt; DriverManager.getConnection(DB_URL, USER, PASS);
String sql &lt;/span&gt;= &quot;SELECT id, first, last, age FROM student where id=?&quot;&lt;span&gt;;
Statement stmt &lt;/span&gt;=&lt;span&gt; conn.prepareStatement(sql);
pre.setBigDecimal(&lt;/span&gt;1, 10000&lt;span&gt;);
ResultSet rs &lt;/span&gt;=&lt;span&gt; stmt.executeQuery();
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(rs.next()){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; id  = rs.getBigDecimal(&quot;id&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; age = rs.getInt(&quot;age&quot;&lt;span&gt;);
}
rs.close();
stmt.close();
conn.close();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于jdbc为什么要这样去抽象我们先放到一边，简单提取出几个关键对象：&lt;/p&gt;
&lt;p&gt;Connection&lt;br/&gt;Statement&lt;br/&gt;ResultSet &lt;/p&gt;

&lt;p&gt;mybatis是怎样一步一步演变出来的，其中设计思路是怎样的，mybatis关键对象又是怎么被抽象出来的？ &lt;/p&gt;
&lt;h2&gt;1.Sql语句提取到xml文件&lt;/h2&gt;
&lt;p&gt;众所周知，mybatis的一大创新和亮点，是将sql语句写到xml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
StringBuilder sql = new StringBuilder(&quot;SELECT * FROM BLOG WHERE state = 'ACTIVE'&quot;);
if (title != null) {
    sql.append(&quot;AND title like ?&quot;);
}
if (author!=null&amp;amp;&amp;amp;author.name!=null){
    sql.append(&quot;AND author_name like ?&quot;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Mybatis将sql语句提出来放到xml里，比上面java代码看起来可读性操作性都强很多，而且sql会统一放在一个地方一起管理，等于将sql与代码进行了分离，后面从全局去看sql、分析优化sql确实也会带来便利。当然，也可以通过注解的形式把sql语句写到java代码里，这样的目的和写到xml一样，也是为了把sql单独提取出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&amp;gt;
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  &amp;lt;if test=&quot;title != null&quot;&amp;gt;
    AND title like #{title}
  &amp;lt;/if&amp;gt;
  &amp;lt;if test=&quot;author != null and author.name != null&quot;&amp;gt;
    AND author_name like #{author.name}
  &amp;lt;/if&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后配置文件我们分为哪些呢，除了要执行的sql，即sql mapper外，我们还需要配置一些全局的设置吧，例如数据源等等&lt;/p&gt;
&lt;p&gt;所以配置文件我们分为两类：&lt;/p&gt;
&lt;h3&gt;Sql语句的配置&lt;/h3&gt;
&lt;p&gt;BlogMapper.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;BlogMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findActiveBlogLike&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;Blog&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;title != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    AND title like #{title}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;author != null and author.name != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    AND author_name like #{author.name}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;全局的配置&lt;/h3&gt;
&lt;p&gt;config.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;settings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;setting &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mapUnderscoreToCamelCase&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;settings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environments &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environment &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transactionManager &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;JDBC &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transactionManager&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataSource &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;POOLED&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driver&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;123&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;456&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;789&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataSource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environments&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，以上通过xml文件进行配置的都可用java代码进行配置&lt;/p&gt;
&lt;p&gt;这里environments我们不做过多分析，主要是把多环境的配置都写在一起，但是不管配置多少个environment，最后也只会用 default属性的那个，即只有一个在运行时生效&lt;/p&gt;
&lt;p&gt;如果有多个数据源，则需要多个config.xml配置文件去配置对应的数据源&lt;/p&gt;
&lt;p&gt;那么问题来了，上面两类xml解析后放到哪里，抽象出了哪些对象？&lt;/p&gt;
&lt;h2&gt;2.Configuration&lt;/h2&gt;
&lt;p&gt;将配置文件统一解析到Configuration对象，从xml解析的内容先放在这，后面谁想用拿去用就行了，这里还是很好理解&lt;/p&gt;
&lt;p&gt;Configuration对象如何生成呢？&lt;/p&gt;
&lt;p&gt;可以通过读取config.xml文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
XMLConfigBuilder parser = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLConfigBuilder(reader);
Configuration configuration&lt;/span&gt;=parser.parse();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，也可以通过java代码来初始化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
TransactionFactory transactionFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdbcTransactionFactory();
Environment environment &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Environment(&quot;development&quot;&lt;span&gt;, transactionFactory, dataSource);
Configuration configuration &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration(environment);
configuration.setDatabaseId(&lt;/span&gt;&quot;mysql&quot;&lt;span&gt;);&lt;br/&gt;//基于java注解配置sql
configuration.addMapper(IBlogMapper.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;);&lt;p&gt;//基于mapper.xml配置sql
Resource[] mapperLocations &lt;/p&gt;&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PathMatchingResourcePatternResolver().getResources(&quot;classpath*:mapper/*.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isEmpty(mapperLocations)) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Resource mapperLocation : mapperLocations) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mapperLocation == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            XMLMapperBuilder xmlMapperBuilder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLMapperBuilder(mapperLocation.getInputStream(),
                    configuration, mapperLocation.toString(), configuration.getSqlFragments());
            xmlMapperBuilder.parse();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NestedIOException(&quot;Failed to parse mapping resource: '&quot; + mapperLocation + &quot;'&quot;&lt;span&gt;, e);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            ErrorContext.instance().reset();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;configuration对象为mybatis抽象出的第一个关键对象，configuration对象里面长什么样，我们接着往下分析&lt;/p&gt;
&lt;h3&gt;2.1 SqlNode&lt;/h3&gt;
&lt;p&gt;首先我们从java解析xml开始，直接通过org.w3c.dom 来解析如下一段xml（mybatis的xml映射语句格式已经深入人心，我们这里也先不去操心为什么mybatis设计出sql语句在xml中写成如下格式）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findActiveBlogLike&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;Blog&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;    &lt;/span&gt;&lt;span&gt;
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;title != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    AND title like #{title}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;author != null and author.name != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    AND author_name like #{author.name}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们会得到父子关系如下的node集合（为了方便理解，我们忽略掉标签之间换行\n节点，后文同样也是省略掉）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findActiveBlogLike&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;Blog&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;    
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’           =&amp;gt;Node(type:TEXT_NODE)
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;title != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;                           =&amp;gt;Node(type:Element)&lt;/span&gt;&lt;span&gt;
    AND title like #{title}                             =&amp;gt;ChildNode(type:TEXT_NODE)
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;author != null and author.name != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;  =&amp;gt;Node(type:Element)&lt;/span&gt;&lt;span&gt;
    AND author_name like #{author.name}                 =&amp;gt;ChildNode(type:TEXT_NODE)
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们得到父节点 &amp;lt;select&amp;gt;节点下一共有三个节点，然后两个Element节点里各有一个子节点&lt;/p&gt;
&lt;p&gt;那么该xml node我们应该如何存到内存里呢，我们应该抽象成什么对象呢？&lt;/p&gt;
&lt;p&gt;这里就引入了SqlNode对象，原始的org.w3c.dom 解析出来的Node对象已经满足不了我们的需求，就算能满足我们处理起来也很绕，所以我们要转变成我们个性化的Node对象，方便去做判断和sql的拼接等操作&lt;/p&gt;
&lt;p&gt;所以在这里每个xml node都会转变成mybatis 的SqlNode，mybatis抽象出的SqlNode类型如下：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;11.5&quot;&gt;&lt;tr&gt;&lt;td width=&quot;140px&quot;&gt;&lt;strong&gt;&lt;em&gt;SqlNode&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;em&gt;说明&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;IfSqlNode&lt;/td&gt;
&lt;td&gt;&amp;lt;if&amp;gt; 标签生成的node，其test属性需配合ognl使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ChooseSqlNode&lt;/td&gt;
&lt;td&gt;&amp;lt;choose&amp;gt; &amp;lt;when&amp;gt; &amp;lt;otherwise&amp;gt; 标签生成的node&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ForEachSqlNode&lt;/td&gt;
&lt;td&gt;&amp;lt;foreach&amp;gt; 标签生成的node&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;StaticTextSqlNode  &lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;静态文本内容，可以包含#{}占位符&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;TextSqlNode&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;也是动态的node，带有${}占位符的文本内容&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;VarDeclSqlNode&lt;/td&gt;
&lt;td&gt;&amp;lt;bind&amp;gt; 标签生成的node&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TrimSqlNode&lt;/td&gt;
&lt;td&gt;&amp;lt;trim&amp;gt; 标签生成的node&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;SetSqlNode&lt;/td&gt;
&lt;td&gt;继承自TrimSqlNode,&amp;lt;set&amp;gt; 标签生成的node&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;WhereSqlNode&lt;/td&gt;
&lt;td&gt;继承自TrimSqlNode,&amp;lt;where&amp;gt; 标签生成的node&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;MixedSqlNode&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;一种特殊的节点，不是由具体的sql标签产生，相当于org.w3c.dom 的getChildNodes()返回的NodeList，即存放父节点的子节点集合&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;共 10 种，严格意义上来说只有 9 种， MixedSqlNode是一种特殊的节点，其本身并没有什么逻辑，只是在父节点存放其子节点的集合用&lt;/p&gt;
&lt;p&gt;那么上面xml转换成mybatis SqlNode后长什么样呢？如下图（为了方便理解，我们忽略掉标签之间换行\n节点，后文同样也是省略掉）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/416838/202005/416838-20200516014630220-1549999169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同&lt;span&gt;org.w3c.dom 解析出来一&lt;/span&gt;样， 一共三个节点，然后两个Element节点里各有一个子节点（不管一个节点的子节点有多少个，其子节点都会以集合形式统一放在MixSqlNode节点下）&lt;/p&gt;
&lt;p&gt;StaticTextSqlNode&lt;/p&gt;
&lt;p&gt;IfSqlNode&lt;/p&gt;
&lt;p&gt;--StaticTextSqlNode（由MixedSqlNode进行一层包装）&lt;/p&gt;
&lt;p&gt;ifSqlNode&lt;/p&gt;
&lt;p&gt;--StaticTextSqlNode（由MixedSqlNode进行一层包装）&lt;/p&gt;

&lt;p&gt;有同学肯定会说不对啊，少了一层MixedSqlNode&lt;/p&gt;
&lt;p&gt;是的，只要父节点包含子节点，不论子节点有多少个，那么子节点的集合统一都会放在MixedSqlNode节点下，是父子节点之间的媒介，为了方便理解我们这里先省略掉它&lt;/p&gt;
&lt;h4&gt;ognl&lt;/h4&gt;
&lt;p&gt;只在&amp;lt;if&amp;gt;和&amp;lt;foreach&amp;gt;标签的SqlNode中用到，例如if标签里常用到 test判断，我们如何判断对应的表达式呢，就是ognl的用武之地了&lt;/p&gt;
&lt;p&gt;不清楚ognl的同学可以去搜索一下该关键字，如下下划线xml里面的条件判断都是通过ognl结合请求参数去执行出来结果&lt;/p&gt;
&lt;pre&gt;
&amp;lt;if test=&lt;span&gt;&quot;&lt;strong&gt;&lt;span&gt;title != null&lt;/span&gt;&lt;/strong&gt;&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;if test=&quot;&lt;span&gt;&lt;strong&gt;&lt;span&gt;author != null and author.name != null&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&quot;&amp;gt;
&lt;/pre&gt;
&lt;p&gt;当把请求参数给到SqlNode时，通过参数和判断表达式，再结合ognl就能得到boolean结果，这样就可以去判断是否要append当前节点的子节点的sql语句了&lt;/p&gt;
&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (Ognl.getValue(&quot;title != null&quot;&lt;span&gt;, parameterObject)) {
   sql.append(&lt;/span&gt;&quot;AND title like #{title}&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2 BoundSql&lt;/h3&gt;
&lt;p&gt;我们上面将xml里的每段CRUD标签解析成了对应的一批SqlNode&lt;/p&gt;
&lt;p&gt;那么运行时，通过请求参数我们需要提取出来最终到数据库执行的jdbc statement，才能继续将我们的流程往下走&lt;/p&gt;
&lt;h4&gt;#{} 占位符&lt;/h4&gt;
&lt;p&gt;我们在mybatis xml中写sql语句时，可以写 #{} 和 ${} 占位符，这是原始jdbc statment不支持的，这样的书写方式解决了我们之前sql语句参数要用 “？” 问号，然后statment赋值要注意顺序的问题，参数一多眼睛就花了&lt;/p&gt;
&lt;p&gt;mybatis将这个问题帮我们简化了，可以在sql段里面写 #{} 占位符，项目运行时 #{} 会被替换成 &quot;?&quot; 和对应排好序的参数集合&lt;/p&gt;
&lt;p&gt;然后再去执行statement，伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Connection connection = transaction.getConnection();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从事务管理获取connection&lt;/span&gt;
PreparedStatement statement = connection.prepareStatement(&lt;span&gt;&lt;strong&gt;sql&lt;/strong&gt;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;准备statement&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; &lt;strong&gt;&lt;span&gt;parameterMappings&lt;/span&gt;&lt;/strong&gt;.size(); i++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环参数列表给statement赋值&lt;/span&gt;
  Object value = requestObject.getValue(parameterMappings.get(i).getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过反射拿到入参的属性值&lt;/span&gt;
  preparedStatement.setBigDecimal(i, &lt;span&gt;new&lt;/span&gt; BigDecimal(value));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给statement赋值&lt;/span&gt;
&lt;span&gt;}
preparedStatement.execute();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;几个关键点：&lt;/p&gt;
&lt;p&gt;1.prepareStatement 的 sql语句，即#{} 替换成 &quot;?&quot;的sql&lt;/p&gt;
&lt;p&gt;2.#{} 替换成 &quot;?&quot; 后，排好序的参数列表&lt;/p&gt;
&lt;p&gt;3.给statement赋值时，我们怎么知道是 setInt 还是 setBigDecimal &lt;/p&gt;
&lt;p&gt;这3个点，就是接下来要关注的，让我们来看看mybatis是怎么做的&lt;/p&gt;
&lt;h4&gt;Sql&lt;/h4&gt;
&lt;p&gt;如何通过SqlNode、请求参数 得到最终执行的sql？&lt;/p&gt;
&lt;p&gt;其实上面说ognl的时候已经提到了，简单理解就是由请求参数和条件表达式结合拼接出来，然后再把 &quot;#{}&quot; 替换成 &quot;?&quot; 即可&lt;/p&gt;
&lt;h4&gt;ParameterMapping&lt;/h4&gt;
&lt;p&gt;排好序的参数列表，给statement赋值使用&lt;/p&gt;
&lt;p&gt;xml使用示例：&lt;/p&gt;
&lt;p&gt;#{property,javaType=int,jdbcType=NUMERIC}&lt;/p&gt;
&lt;p&gt;#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}&lt;/p&gt;
&lt;p&gt;有如下一些关键的属性：&lt;/p&gt;
&lt;h5&gt;property&lt;/h5&gt;
&lt;p&gt;即 #{xxx} 中的属性名，是字符串&lt;/p&gt;
&lt;h5&gt;javaType&lt;/h5&gt;
&lt;p&gt;通过 #{}占位符中定义，如果没有定义则找入参对象parameterType该属性的类型&lt;/p&gt;
&lt;p&gt;优先级如下（由高到低）：&lt;/p&gt;
&lt;p&gt;1.xml配置文件中定义的类型&lt;/p&gt;
&lt;p&gt;2.入参对象该property属性的java type&lt;/p&gt;
&lt;p&gt;例如下面配置的 #{title}，就是通过反射找 入参对象的title 属性的java type&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findActiveBlogLike&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;Blog&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;title != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    AND title like #{title}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;author != null and author.name != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    AND author_name like #{author.name}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果传递进来的入参是Map，那么通过反射就找不到对应属性的java type，这种情况下该属性的 javaType 会设置成 Object.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Map map=new HashMap();
map.put(&quot;title&quot;,&quot;123&quot;);
map.put(&quot;author&quot;,new Author(){{setName(&quot;tt&quot;);}});
session.select(&quot;com.tj.mybatis.IBlogMapper.findActiveBlogLike&quot;,map,null);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;TypeHandler&lt;/h5&gt;
&lt;p&gt;#{property,javaType=int,jdbcType=NUMERIC}&lt;/p&gt;
&lt;p&gt;#{age,javaType=int,jdbcType=NUMERIC,typeHandler=MyTypeHandler}&lt;/p&gt;
&lt;p&gt;#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}&lt;/p&gt;
&lt;p&gt;优先级如下（由高到低）：&lt;/p&gt;
&lt;p&gt;1.xml配置文件中定义的类型&lt;/p&gt;
&lt;p&gt;2.通过javaType去找对应的TypeHandler&lt;/p&gt;
&lt;p&gt;该对象的作用就是解决给statement赋值时，让我们知道是用ps.setInt(value) 还是 ps.setBigDecimal(value)&lt;/p&gt;

&lt;p&gt;分为get 和 set：&lt;/p&gt;
&lt;p&gt;给statement赋值时  通过java类型找jdbc类型&lt;/p&gt;
&lt;p&gt;给java 对象赋值时   拿到数据库查询结果ResultSet后，是用哪个方法给java对象赋值rs.getInt(&quot;age&quot;); 还是 rs.getBigDecimal(&quot;age&quot;);通过jdbc类型找java类型&lt;/p&gt;

&lt;p&gt;UnknownTypeHandler&lt;/p&gt;
&lt;p&gt;上面java type为Object.class时，例如入参是Map 找不到对应的属性的java type，其对应的TypeHandler为UnknownTypeHandler&lt;/p&gt;
&lt;p&gt;这种情况下，在给statement入参赋值时会再次根据获取到的入参的值的类型去找TypeHandler&lt;/p&gt;
&lt;p&gt;例如 title 属性的值为 &quot;123&quot; 那么再通过值&quot;123&quot;去找其对应的 TypeHandler，即StringTypeHandler&lt;/p&gt;
&lt;h4&gt;${} 占位符&lt;/h4&gt;
&lt;p&gt;${} 和 #{} 这两种占位符的处理流程是不一样的：&lt;/p&gt;
&lt;p&gt;${}占位符在执行时，会将sql替换成我们参数设置的sql段，有sql注入风险，且该sql段可能还包含#{}占位符&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
select * from blog ${where}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可能会被替换成如下sql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
select * from blog where title like #{title}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即替换内容为  &quot;where title like #{title}&quot;，所以替换完后会再走一遍#{}占位符的替换流程&lt;/p&gt;

&lt;p&gt;如果xml中sql语句只包含 #{}占位符，那么通过请求参数，我们需要做的就是通过条件拼接sql（无sql注入风险），然后给statement参数赋值即可&lt;/p&gt;
&lt;p&gt;如果xml中sql语句包含${}占位符，那么需要将${}占位符进行替换，然后再进行上面#{}的流程，因为 ${} 可能包含 带有#{}占位符的语句替换进去&lt;/p&gt;
&lt;p&gt;所以mybatis流程上是统一先处理${}占位符，再处理#{}占位符（SqlSource.getBoundSql 方法的流程），然后一个有sql注入风险一个无sql注入风险。&lt;/p&gt;

&lt;p&gt;所以执行过程中，sqlNode最后变成了 statement所需要的两大关键点：&lt;/p&gt;
&lt;p&gt;1.sql（jdbc statement可直接使用的sql）&lt;/p&gt;
&lt;p&gt;2.参数列表 ParameterMappings（排好序的，给statment赋值时直接按顺序遍历赋值），其又包含：属性名property和TypeHandler&lt;/p&gt;
&lt;p&gt;这就是我们的BoundSql对象，该对象包含上面两个关键属性&lt;/p&gt;
&lt;p&gt;如下是大致的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/416838/202005/416838-20200524052141808-792385839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.3 SqlSource&lt;/h3&gt;
&lt;h4&gt;RawSqlSource 与 DynamicSqlSource&lt;/h4&gt;
&lt;p&gt;首先我们先分析一下如下两段sql，在运行时执行时有什么异同？&lt;/p&gt;
&lt;p&gt;第一段sql：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;selectBlog&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;Blog&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  SELECT * FROM BLOG WHERE id = #{id}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二段sql：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findActiveBlogLike&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;Blog&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;title != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    AND title like #{title}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;author != null and author.name != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    AND author_name like #{author.name}
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第一段sql我们在执行时不需要根据传递进来的条件参数进行sql拼接，在项目启动时就可以直接得到BoundSql的两个关键属性：&lt;/p&gt;
&lt;p&gt;1.sql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SELECT * FROM BLOG WHERE id=?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.参数列表：&lt;/p&gt;
&lt;p&gt;id&lt;/p&gt;
&lt;p&gt;在执行时，也根本不需要再做#{}标签的替换，直接拿BoundSql和参数赋值给statment即可&lt;/p&gt;
&lt;p&gt;而第二段sql我们在项目启动时没法提前得到BoundSql，只能在运行时通过传递进来的参数做判断才能得到BoundSql。&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;第一段sql，静态sql，执行时速度更快，项目加载时就能得到BoundSql&lt;/p&gt;
&lt;p&gt;第二段sql，动态sql，执行时速度稍慢，运行时才能得到BoundSql&lt;/p&gt;
&lt;p&gt;所以为了区分这两种类型的SqlNode集合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态sql： RawSqlSource&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当所有节点都是StaticTextSqlNode 或 MixedSqlNode ，就是RawSqlSource 静态sql源（不需要依据请求参数来做判断拼接sql，是固定的sql内容，如果有请求参数给statement赋值参数即可）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态sql： DynamicSqlSource&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要包含除StaticTextSqlNode 和 MixedSqlNode 以外的其他8 种SqlNode类型 （sql中存在 ${}占位符的是TextSqlNode），则都是DynamicSqlSource 动态sql源（需要根据请求参数做动态sql拼接） &lt;/p&gt;
&lt;p&gt;所以不同的SqlSource得到BoundSql的速度不一样，然后相同的是SqlSource下面都是放的SqlNode集合&lt;/p&gt;
&lt;p&gt;有细心的同学看了肯定会说我漏了StaticSqlSource，其实StaticSqlSource是上面两种SqlSource生成BoundSql的一个过渡产物，所以不需要单独拎出来说明&lt;/p&gt;
&lt;h3&gt;2.4 LanguageDriver&lt;/h3&gt;
&lt;p&gt;mybatis除了可以通过xml写sql外，也可以通过如下java 注解来写sql，还可以通过&lt;a href=&quot;https://github.com/mybatis/freemarker-scripting&quot; target=&quot;_blank&quot;&gt;freemarker&lt;/a&gt;、&lt;a href=&quot;https://github.com/mybatis/thymeleaf-scripting&quot; target=&quot;_blank&quot;&gt;thymeleaf&lt;/a&gt; 等格式来写书写sql文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
@Update({&quot;&amp;lt;script&amp;gt;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;update Author&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;  &amp;lt;set&amp;gt;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;    &amp;lt;if test='username != null'&amp;gt;username=#{username},&amp;lt;/if&amp;gt;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;    &amp;lt;if test='password != null'&amp;gt;password=#{password},&amp;lt;/if&amp;gt;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;    &amp;lt;if test='email != null'&amp;gt;email=#{email},&amp;lt;/if&amp;gt;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;    &amp;lt;if test='bio != null'&amp;gt;bio=#{bio}&amp;lt;/if&amp;gt;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;  &amp;lt;/set&amp;gt;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;where id=#{id}&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;&amp;lt;/script&amp;gt;&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; updateAuthorValues(Author author);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Select(&quot;SELECT * FROM BLOG&quot;&lt;span&gt;)
List&lt;/span&gt;&amp;lt;Blog&amp;gt; selectBlog();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以顾名思义，语言驱动 LanguageDriver的作用就是干这个，将不同来源的sql解析成SqlSource对象，不过mybatis java注解的sql也是统一用的XmlLanguageDriver去解析的，这里mybatis是为了方便扩展&lt;/p&gt;
&lt;h3&gt;2.5 MappedStatement&lt;/h3&gt;
&lt;p&gt;除了子节点SqlNode集合以外，&amp;lt;select&amp;gt; &amp;lt;update&amp;gt; &amp;lt;delete&amp;gt; 标签也包含很多属性，放到哪里呢，新开一个父级的SqlNode吗？而且从面向对象设计来说，这个Node跟下面的sql语句node区别还挺大的，至少跟上文那10种SqlNode差别挺大的，这里新开一个对象用于存放父级标签的属性：MappedStatement&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&amp;gt;
  SELECT * FROM BLOG WHERE state = ‘ACTIVE’
  &amp;lt;if test=&quot;title != null&quot;&amp;gt;
    AND title like #{title}
  &amp;lt;/if&amp;gt;
  &amp;lt;if test=&quot;author != null and author.name != null&quot;&amp;gt;
    AND author_name like #{author.name}
  &amp;lt;/if&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sql语句的配置，每一段curd都会被解析成一个MappedStatement对象，可以通过id去与dao接口方法进行对应&lt;/p&gt;
&lt;p&gt;这里的中间产物我们就叫他MappedStatement，为什么叫MappedStatement？&lt;/p&gt;
&lt;p&gt;即mybatis最终生成jdbc statement的中间产物，mybatis做的事情就是 orm （object relational mapping），那么最终生成statement的中间物就是MappedStatement&lt;/p&gt;
&lt;p&gt;如下图所示（右键新标签页打开可查看大图）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/416838/202005/416838-20200527051920542-1936088549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注： 虚线箭头表示此对象为通过某方法得到的返回值&lt;/p&gt;
&lt;p&gt;例如：MappendStatement.getBoundSql(Object requestObject)得到的返回值为BoundSql对象&lt;/p&gt;
&lt;p&gt;另外，每一段&amp;lt;select|insert|update|delete&amp;gt; 标签，对应生成一个SqlSource、MappedStatement，1对1的关系&lt;/p&gt;
&lt;h4&gt;ParameterType&lt;/h4&gt;
&lt;p&gt;用于说明请求参数的java type，非必须，xml的&amp;lt;select|insert|update|delete&amp;gt;标签中该属性可以不写，因为mybatis可以根据运行时传递进来的参数用反射判断其类型&lt;/p&gt;
&lt;h4&gt;ResultMap ResultType&lt;/h4&gt;
&lt;p&gt;如官方文档所说，两者只能用其中一个，不过不管用哪个，最终都是将信息放在ResultMap，用于后面ResultSetHandler创建返回对象时使用&lt;/p&gt;
&lt;p&gt;例如如下xml配置：&lt;/p&gt;
&lt;p&gt;&amp;lt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findActiveBlogLike&quot;&lt;/span&gt; &lt;span&gt;resultType&lt;/span&gt;&lt;span&gt;=&quot;xxx.Blog&quot;&lt;/span&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;生成的MappedStatement中，上面resultType会存放在ResultMap对象的type属性里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/416838/202005/416838-20200527044731424-2029113967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.6 TransactionFactory&lt;/h3&gt;
&lt;p&gt;顾名思义其主要就是用于创建不同的Transaction对象，这里涉及到mybatis的事务管理，关于事务管理下面内容我们会提到&lt;/p&gt;
&lt;h2&gt;3.StatementHandler&lt;/h2&gt;
&lt;p&gt;我们已经知道上面Configuration对象里面有哪些内容，然后结合BoundSql就能够将statement prepare 和 execute&lt;/p&gt;
&lt;p&gt;如下伪代码示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Transaction transaction = configuration.getEnvironment().getTransactionFactory().newTransaction(dataSource, TransactionIsolationLevel.READ_COMMITTED, false);
Connection connection = transaction.getConnection();
MappedStatement mappedStatement = configuration.getMappedStatement(&quot;findActiveBlogLike&quot;);
BoundSql boundSql = mappedStatement.getBoundSql(blog);&lt;br/&gt;PreparedStatement statement = connection.prepareStatement(boundSql.getSql());
List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();&lt;br/&gt;MetaObject metaObject = configuration.newMetaObject(parameterObject);//&lt;span&gt;MetaObject是mybatis提供的能很方便使用反射的工具对象&lt;/span&gt;
if (parameterMappings != null) {
    for (int i = 0; i &amp;lt; parameterMappings.size(); i++) {
        ParameterMapping parameterMapping = parameterMappings.get(i);
        Object value = metaObject.getValue(parameterMapping.getProperty());
        statement.setBigDecimal(i, new BigDecimal(value));
    }
}
statement.execute();
ResultSet rs=statement.getResultSet();
while(rs.next()){
    BigDecimal id  = rs.getBigDecimal(&quot;id&quot;);
    String title = rs.getString(&quot;title&quot;);
}
rs.close();
statement.close();
connection.close();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们知道，jdbc的statement有三种，每种执行起来有些区别：&lt;/p&gt;
&lt;p&gt;Statement&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Statement stm =&lt;span&gt; conn.createStatement()
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; stm.execute(sql);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PreparedStatement&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
PreparedStatement pstm =&lt;span&gt; conn.prepareStatement(sql);
pstm.setString(&lt;/span&gt;1, &quot;Hello&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; pstm.execute();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CallableStatement&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
CallableStatement cs = conn.prepareCall(&quot;{call xxx(?,?,?)}&quot;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;
cs.setInt(&lt;/span&gt;1, 10&lt;span&gt;);
cs.setString(&lt;/span&gt;2, &quot;Hello&quot;&lt;span&gt;);&lt;br/&gt;&lt;/span&gt;cs.registerOutParameter(3, Types.INTEGER);&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; cs.execute();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以这里抽象出三个不同的Handler再部分结合模板方法去处理不同的statement，也挺好理解，最后不管什么Statement都按如下模板来构建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;stmt &lt;/span&gt;=&lt;span&gt; handler.prepare(&lt;/span&gt;transaction.getConnection()&lt;span&gt;, transaction.getTimeout());&lt;br/&gt;handler.parameterize(stmt);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;区别是不同的hanlder里的prepare()和parameterize()方法有些区别而已，例如StatementHandler的parameterize()方法里代码为空，因为不支持参数设置&lt;/p&gt;
&lt;p&gt;有了StatementHandler之后，我们的伪代码变成下面这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
StatementHandler handler = configuration.newStatementHandler(mappedStatement, parameterObject, &lt;span&gt;boundSql);
Statement stmt &lt;/span&gt;=&lt;span&gt; handler.prepare(transaction.getConnection(), transaction.getTimeout());
handler.parameterize(stmt);
handler.update(stmt);

StatementHandler handler1 &lt;/span&gt;= configuration.newStatementHandler(mappedStatement, parameterObject, boundSql); &lt;br/&gt;Statement stmt1 =&lt;span readability=&quot;2&quot;&gt; handler.prepare(transaction.getConnection(), transaction.getTimeout()); &lt;br/&gt;handler1.parameterize(stmt); &lt;br/&gt;handler1.query(stmt1, resultHandler); &lt;p&gt;transaction.getConnection().commit();&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;newStatementHandler() 创建的StatementHandler默认是PreparedStatementHandler，也可以在xml的&amp;lt;select|insert|update|delete&amp;gt;标签中自己声明类型&lt;/p&gt;
&lt;h3&gt;3.1 ParameterHandler&lt;/h3&gt;
&lt;p&gt;StatementHandler.parameterize()方法中的逻辑，交由ParameterHandler去执行，即循环BoundSql的ParameterMapping集合，结合TypeHandler给statement赋值&lt;/p&gt;
&lt;h3&gt;3.2 ResultSetHandler&lt;/h3&gt;
&lt;p&gt;顾名思义，StatementHandler执行完statement后，交由ResultSetHandler处理成xml中CRUD标签ResultType ResultMap所声明的对象&lt;/p&gt;
&lt;p&gt;关于xml标签中的ResultMap和ResultType，先回顾一下我们上面MappedStatement的内容：&lt;/p&gt;
&lt;p&gt;不管是用ResultMap还是ResultType，最终都是将信息放在ResultMap里，ResultType会存放在ResultMap对象的type属性里&lt;/p&gt;

&lt;p&gt;关于返回结果：&lt;/p&gt;
&lt;p&gt;如果是 &amp;lt;select&amp;gt;标签，这里统一返回List&amp;lt;ResultType&amp;gt; 集合，如果结果只有一条，则直接list.get(0)就可以了&lt;/p&gt;
&lt;p&gt;如果是 &amp;lt;insert|update|delete&amp;gt;标签，则不会经过ResultSetHandler处理，statementHandler直接通过statement.getUpdateCount() 返回int值&lt;/p&gt;
&lt;p&gt;1.创建返回ResultMap 、ResultType的对象  （ObjectFactory）&lt;/p&gt;
&lt;p&gt;2.循环ResultSet每行，再循环每列，给对象属性进行赋值  （TypeHandler）&lt;/p&gt;
&lt;p&gt;3.如果是集合添加到集合再返回 （ResultHandler）&lt;/p&gt;
&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
ResultSet rs =&lt;span&gt; statement.getResultSet();
List&lt;/span&gt;&amp;lt;Object&amp;gt; list = objectFactory.create(List.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (rs.next()) {
    ResultSetMetaData metaData &lt;/span&gt;=&lt;span&gt; rs.getMetaData();
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; columnCount =&lt;span&gt; metaData.getColumnCount();

    Object resultObject &lt;/span&gt;= objectFactory.create(resultMap.getType());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用ObjectFactory实例化对象&lt;/span&gt;
    MetaObject metaObject = configuration.newMetaObject(resultObject);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MetaObject是mybatis提供的能很方便使用反射的工具对象&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= columnCount; i++&lt;span&gt;) {
        String columnName &lt;/span&gt;= configuration.isUseColumnLabel() ?&lt;span&gt; metaData.getColumnLabel(i) : metaData.getColumnName(i);

        String property &lt;/span&gt;=&lt;span&gt; metaObject.findProperty(columnName, configuration.isMapUnderscoreToCamelCase());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (property != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; metaObject.hasSetter(property)) {
            Class&lt;/span&gt;&amp;lt;?&amp;gt; propertyType =&lt;span&gt; metaObject.getSetterType(property);
            TypeHandler&lt;/span&gt;&amp;lt;?&amp;gt; typeHandler = getTypeHandler(propertyType, metaData.getColumnType(i));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过属性类型找对应的jdbc TypeHandler&lt;/span&gt;
&lt;span&gt;
            Object value &lt;/span&gt;=&lt;span&gt; typeHandler.getResult(rs, columnName);
            metaObject.setValue(property, value);
        }
    }
    list.add(resultObject);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ResultSetHandler配合ResultMap也支持嵌套查询、子查询，返回多结果集等，我们这里就不细化了&lt;/p&gt;
&lt;h4&gt;ObjectFactory&lt;/h4&gt;
&lt;p&gt;顾名思义，对象工厂，产出对象用的，什么对象呢，当然是查询数据库将结果映射到的java对象&lt;/p&gt;
&lt;p&gt;用来创建ResultType（等同于ResultMap中的Type）等对象时使用，用反射创建对象（这里可以做一些加工，比如创建完对象后给属性赋值，但是这种情况不常见），&lt;/p&gt;
&lt;p&gt;然后后面ResultSetHandler用TypeHandler去给新创建的对象属性赋值&lt;/p&gt;
&lt;p&gt;最后再用ResultHandler添加到返回集合里&lt;/p&gt;
&lt;p&gt;什么场景适合我们自定义实现呢？&lt;/p&gt;
&lt;p&gt;这里的职责就是通过反射创建对象，一般情况下使用默认的DefaultObjectFactory就可以了；&lt;/p&gt;
&lt;p&gt;如果想创建完对象给一些属性初始化值，这里可以做，但是可能会被后面数据库查到的结果值覆盖，使用下面的ResultHandler就可以实现&lt;/p&gt;
&lt;h4&gt;ResultHandler&lt;/h4&gt;
&lt;p&gt;为什么需要ResultHandler？&lt;/p&gt;
&lt;p&gt;区别于ResultSetHandler，ResultSet是jdbc返回的结果集，Result则理解为经过mybatis加工的结果&lt;/p&gt;
&lt;p&gt;默认ResultSetHandler都会循环ResultSet然后通过DefaultResultHandler添加到集合，最后从ResultHandler取结果返回给调用方法（调用方法无返回类型限制）&lt;/p&gt;
&lt;p&gt;上面伪代码中，如下几句就是在DefaultResultHandler中执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
List&amp;lt;Object&amp;gt; list = objectFactory.create(List.&lt;span&gt;class&lt;/span&gt;);&lt;br/&gt;list.add(resultObject);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只不过最后ResultSetHandler返回结果时自己调用了 defaultResultHandler.getResultList() 来进行返回。&lt;/p&gt;

&lt;p&gt;如果想用自定义的ResultHandler：查询方法必须是void类型，且入参有ResultHandler对象，然后结果集自己通过resultHandler来获取，例如DefaultResultHandler.getResultList()&lt;/p&gt;
&lt;p&gt;什么场景适合我们自定义实现呢？&lt;/p&gt;
&lt;p&gt;因为这里的职责是创建返回集合List&amp;lt;ResultType&amp;gt;，并添加记录行；所以我们可以对集合里创建的对象进行一些统一的操作，例如给集合里的对象某个字段设置默认值&lt;/p&gt;
&lt;h4&gt;RowBounds&lt;/h4&gt;
&lt;p&gt;mybatis的内存分页，在ResultSetHandler中使用，由外部方法层层传递进来，即通过RowBounds设置的参数对ResultSet进行 skip limit，只取想要页数的记录行&lt;/p&gt;
&lt;p&gt;但是关键问题是基于内存的分页，而不是物理分页，所以基本上都不会用到&lt;/p&gt;
&lt;h3&gt;MetaObject&lt;/h3&gt;
&lt;p&gt;上面我们已经提到了，MetaObject是mybatis提供的方法使用反射的工具类，将对象Object扔进去，就可以很简单的使用反射；自己项目中如果有需要也可以直接使用，很方便&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
MetaObject metaObject =&lt;span&gt; configuration.newMetaObject(parameterObject);
metaObject.getValue(&lt;/span&gt;&quot;name&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是此对象并不属于我们StatementHandler，只是这里用到比较多，所以我们就放到这里一起讲一下&lt;/p&gt;
&lt;h2&gt;4.Executor&lt;/h2&gt;
&lt;p&gt;熟悉mysql、mssql等关系型数据库隔离级别的同学都知道，数据库的隔离级别分为4类，由低到高：&lt;/p&gt;
&lt;p&gt;1.Read Uncommitted 读未提交&lt;/p&gt;
&lt;p&gt;2.Read Committed 读已提交&lt;/p&gt;
&lt;p&gt;3.Repeatable Read 可重复读&lt;/p&gt;
&lt;p&gt;4.Serializable 串行&lt;/p&gt;
&lt;p&gt;隔离级别越高则处理速度越慢，隔离级别越低则处理速度越快。&lt;/p&gt;
&lt;p&gt;mysql默认隔离级别是Repeatable Read 可重复读；即在同一个事务范围内，同样的查询语句得到的结果一致。&lt;/p&gt;
&lt;p&gt;mybatis的又一大亮点：&lt;strong&gt;同一个事务范围内，基于内存实现可重复读。&lt;/strong&gt;直接在mybatis这里就处理好了，都不用到数据库，这样减轻了数据库压力，且速度更快。&lt;/p&gt;

&lt;p&gt;所以mybatis在这里引入了缓存和一些其他操作，而它的媒介就是Executor，是对StatementHandler再做一层封装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Executor executor =&lt;span&gt; configuration.newExecutor(transaction);
executor.query(configuration.getMappedStatement(&lt;/span&gt;&quot;findActiveBlogLike&quot;&lt;span&gt;), parameterObject, rowBounds, Executor.NO_RESULT_HANDLER); &lt;br/&gt;executor.commit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Executor里的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
List&amp;lt;E&amp;gt;&lt;span&gt; list;
CacheKey key &lt;/span&gt;= createCacheKey(ms, parameter, rowBounds, boundSql);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过关键对象创建唯一的缓存key&lt;/span&gt;
list = localCache.getObject(key);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过缓存key查缓存&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (list == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
  StatementHandler handler &lt;/span&gt;=&lt;span&gt; configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
  stmt &lt;/span&gt;=&lt;span&gt; prepareStatement(handler, ms.getStatementLog());
  list &lt;/span&gt;= handler.&amp;lt;E&amp;gt;&lt;span&gt;query(stmt, resultHandler);
  localCache.putObject(key, list);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存至缓存&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; list;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是我们上面所说的，对StatementHandler进行包装，做一些逻辑封装&lt;/p&gt;
&lt;p&gt;然后Executor有哪几种呢？主要还是知道这些对象是如何演变过来的，剩下的其实代码里都能看的很明确了&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;td width=&quot;120px;&quot;&gt;&lt;em&gt;&lt;strong&gt;Executor&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;BaseExecutor&lt;/td&gt;
&lt;td&gt;下面三种Executor的父类，基础方法都在这里，查询方法实现了基于内存的一级缓存&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SimpleExecutor&lt;/td&gt;
&lt;td&gt;继承自BaseExecutor，默认的Executor&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ResuseExecutor&lt;/td&gt;
&lt;td&gt;继承自BaseExecutor，重用Statement，即同一个Executor内Statement不释放重复使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;BatchExecutor&lt;/td&gt;
&lt;td&gt;继承自BaseExecutor，针对增删改的批处理，调用增删改方法时，只是statement.addBatch()，最终还要通过调用commit方法触发批处理&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;CachingExecutor&lt;/td&gt;
&lt;td&gt;在一级缓存的基础上增加二级缓存，二级缓存查不到的情况再去上面几种Executor中进行查询&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;Transaction&lt;/h3&gt;
&lt;p&gt;为什么mybatis要抽象出Transaction事务对象，其实一方面是为了集中connection的管理，另一方面也是为了能够适应趋势解决事物发展过程中的问题，&lt;strong&gt;后面mybatis-spring中我们会详细介绍&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;spring关于事务的管理有：&lt;/p&gt;
&lt;p&gt;DataSourceTransactionManager、PlatformTransactionManager等&lt;/p&gt;
&lt;p&gt;mybatis这里同样也有自己的事务管理 Transaction接口的实现：JdbcTransaction 、SpringManagedTransaction等&lt;/p&gt;
&lt;p&gt;相比spring表面看起来只是后缀少了个单词 Manager而已&lt;/p&gt;
&lt;p&gt;简单点去理解，就是connection都是放在Transaction对象这里进行管理，要操作数据库连接都统一从这里操作；&lt;/p&gt;
&lt;p&gt;例如非托管的Transaction伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
protected&lt;span&gt; Connection connection;

public&lt;span&gt; Connection getConnection(){
    if (connection == null&lt;span&gt;) {
      connection =&lt;span&gt; dataSource.getConnection();
    }
    return&lt;span&gt; connection;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是受spring 托管的事务，则上面dataSource.getConnection() 变成 DataSourceUtils.getConnection();&lt;/p&gt;
&lt;h3&gt;一级缓存&lt;/h3&gt;
&lt;p&gt;一级缓存：默认开启，且不能关闭，同一个Executor内（同一个事务）相同参数、sql语句读到的结果是一样的，都不用到数据库，这样减轻了数据库压力，且速度更快。&lt;/p&gt;
&lt;h3&gt;二级缓存&lt;/h3&gt;
&lt;p&gt;CacheExecutor，可基于内存或第三方缓存实现&lt;/p&gt;
&lt;p&gt;要注意的是二级缓存的key 是通过 mapper.xml 里的namespace进行分组，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;UserMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;cache &lt;/span&gt;&lt;span&gt;eviction&lt;/span&gt;&lt;span&gt;=&quot;FIFO&quot;&lt;/span&gt;&lt;span&gt; size&lt;/span&gt;&lt;span&gt;=&quot;512&quot;&lt;/span&gt;&lt;span&gt; readOnly&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样所有该mapper &amp;lt;select&amp;gt;产生的cacheKey，都统一放在&quot;UserMapper&quot;这个namespace下汇总&lt;/p&gt;
&lt;p&gt;mapper.xml里面的&amp;lt;select|insert|update|delete&amp;gt; flushCache属性设置为true时，会清空该namespace下所有cacheKey的缓存&lt;/p&gt;
&lt;p&gt;flushCache属性在&amp;lt;select&amp;gt; 标签中默认值为 false，在&amp;lt;insert|update|delete&amp;gt;标签中默认值为 true。&lt;/p&gt;

&lt;p&gt;然后如果其他mapper想共用同一个缓存namespace，如下声明就可以了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;BlogMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;cache-ref &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;UserMapper&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.SqlSession&lt;/h2&gt;
&lt;p&gt;mybatis为什么要有session的概念？ 上面使用Executor进行crud已经可以满足我们绝大部分业务需求了，为什么还要弄出个session的概念？&lt;/p&gt;
&lt;p&gt;这里主要还是为了强调会话的概念，由会话来控制事务的范围，类似web 的session更方便使用者理解&lt;/p&gt;
&lt;p&gt;那既然这样，把上面Executor名字改成SqlSession不就行了？这样其实也不好，因为对应的BatchExecutor、CachingExecutor改成BatchSqlSession、CachingSqlSession的话感觉有点混乱了，不符合session干的事情&lt;/p&gt;
&lt;p&gt;使用SqlSession后代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
SqlSession session =&lt;span&gt; sqlSessionFactory.openSession();//&lt;span&gt;内部构造executor等对象&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
session.selectList(&lt;/span&gt;&quot;findActiveBlogLike&quot;,parameterObject);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;内部使用Executor进行执行&lt;/span&gt;&lt;span&gt;
session.commit();&lt;br/&gt;session.close();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实跟上面Executor的代码相比，也差不多，只不过SqlSessoin是通过factory工厂来创建，但是原理还是通过configuration创建transaction、executor等对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Executor executor =&lt;span&gt; configuration.newExecutor(transaction);
executor.query(configuration.getMappedStatement(&lt;/span&gt;&quot;findActiveBlogLike&quot;&lt;span&gt;), parameterObject, rowBounds, Executor.NO_RESULT_HANDLER); 
executor.commit();&lt;br/&gt;executor.close();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里可以这样理解，SqlSession就是为了更方便理解和使用而产生的对象，其方法本质还是交由Executor去执行。&lt;/p&gt;
&lt;p&gt;到目前为止整体的架构如下（右键新标签页打开可查看大图）  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/416838/202005/416838-20200527052022283-519933010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;SqlSessionFactory&lt;/h3&gt;
&lt;p&gt;SqlSession的工厂类，需要的参数主要就是Configuration对象，其实意思很明确了，就是SqlSession需要使用Configuration对象，创建SqlSession代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
SqlSessionFactory sqlSessionFactory = &lt;span&gt;new&lt;/span&gt; SqlSessionFactoryBuilder().build(configuration);&lt;br/&gt;SqlSession session = sqlSessionFactory.openSession();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过configuration的构建其实还是挺麻烦的，上面Configuration已经提到，然后后面mybatis-spring有提供SqlSessionFactoryBean（包含Configuration的构建）方便我们更快捷的构建SqlSessionFactory&lt;/p&gt;
&lt;h2&gt;6.MapperProxy&lt;/h2&gt;
&lt;p&gt;熟悉mybatis的朋友都知道xml中每段&amp;lt;select|insert|update|delete&amp;gt;与dao接口方法是一对一的，其实早在ibatis的年代是没有将两者关联起来的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/416838/202005/416838-20200526080027430-476562782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;java.lang.reflect.Proxy&lt;/h3&gt;
&lt;p&gt;那么实现这一功能的核心是什么呢，就是java的Proxy，通过session.getMapper(xxx.class)方法每次都会给接口生成一个代理Proxy的实现 &lt;/p&gt;
&lt;p&gt;实现后的效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
try (SqlSession session =&lt;span&gt; sqlSessionFactory.openSession()) {
  IBlogMapper mapper = session.getMapper(IBlogMapper.class&lt;span&gt;);
  Blog blog = mapper.selectBlog(101&lt;span&gt;);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们就不分析Proxy的原理了，还是不明白的同学可以百度搜索了解一下，如下是mybatis中使用proxy的代码：&lt;/p&gt;
&lt;p&gt;DefaultSqlSession：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt;&lt;span&gt; type) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; configuration.&amp;lt;T&amp;gt;getMapper(type, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经由Configuration和MapperRegistry、MapperProxyFactory，最终执行返回：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; T newInstance(MapperProxy&amp;lt;T&amp;gt;&lt;span&gt; mapperProxy) {
  MapperProxy&lt;/span&gt;&amp;lt;T&amp;gt; mapperProxy = &lt;span&gt;new&lt;/span&gt; MapperProxy&amp;lt;T&amp;gt;&lt;span&gt;(sqlSession, mapperInterface, methodCache);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Class[] { mapperInterface }, mapperProxy);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过需要注意的是getMapper(xxx.class)的使用前提的addMapper(xxx.class);否则不会生成代理；&lt;/p&gt;
&lt;p&gt;addMapper可以由如下两种形式触发：&lt;/p&gt;
&lt;p&gt;1.configuration.addMapper(xxx.Class);//基于java注解形式&lt;/p&gt;
&lt;p&gt;2.xmlMapperBuilder.parse();//基于mapper.xml配置，详细代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Configuration configuration = new Configuration(environment);&lt;br/&gt;Resource[] mapperLocations = &lt;span&gt;new&lt;/span&gt; PathMatchingResourcePatternResolver().getResources(&quot;classpath*:mapper/*.xml&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isEmpty(mapperLocations)) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Resource mapperLocation : mapperLocations) {
&lt;/span&gt;&lt;span&gt;            ...
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                XMLMapperBuilder xmlMapperBuilder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLMapperBuilder(mapperLocation.getInputStream(),
                        configuration, mapperLocation.toString(), configuration.getSqlFragments());
                xmlMapperBuilder.parse();
            ...&lt;/span&gt;&lt;span&gt;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面结合mybatis-spring时使用SqlSessionFactoryBean时就有帮我们实现了我们上面这段代码&lt;/p&gt;
&lt;h3&gt;MapperMethod&lt;/h3&gt;
&lt;p&gt;MapperProxy最后执行方法时，都会交给MapperMethod去执行，接口的每个方法method都会生成一个对应的MapperMethod去执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;  ...
  &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; MapperMethod mapperMethod =&lt;span&gt; cachedMapperMethod(method);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapperMethod.execute(sqlSession, args);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后只要在MapperMethod里调用SqlSession对应的方法就算完成了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object execute(SqlSession sqlSession, Object[] args) {
    Object result;
&lt;/span&gt;&lt;span&gt;    //&lt;/span&gt;&lt;span&gt;通过接口方法名找到对应的MappedStatement，判断MappedStatement的标签类型是其中哪种&amp;lt;select|insert|update|delete&amp;gt;&lt;/span&gt;
    &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (command.getType()) {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; INSERT: {
        Object param &lt;/span&gt;=&lt;span&gt; method.convertArgsToSqlCommandParam(args);
&lt;/span&gt;&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;调用对应的sqlSesion方法，传递MappedStatement id和请求参数，这里的command.getName即MappedStatement的id（前缀会自动加命名空间来区分唯一）&lt;/span&gt;&lt;span&gt;
        result &lt;/span&gt;=&lt;span&gt; rowCountResult(sqlSession.insert(command.getName(), param));
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; UPDATE: {
        Object param &lt;/span&gt;=&lt;span&gt; method.convertArgsToSqlCommandParam(args);
        result &lt;/span&gt;=&lt;span&gt; rowCountResult(sqlSession.update(command.getName(), param));
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; DELETE: {
        Object param &lt;/span&gt;=&lt;span&gt; method.convertArgsToSqlCommandParam(args);
        result &lt;/span&gt;=&lt;span&gt; rowCountResult(sqlSession.delete(command.getName(), param));
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SELECT:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (method.returnsVoid() &amp;amp;&amp;amp;&lt;span&gt; method.hasResultHandler()) {
          executeWithResultHandler(sqlSession, args);
          result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.returnsMany()) {
          result &lt;/span&gt;=&lt;span&gt; executeForMany(sqlSession, args);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.returnsMap()) {
          result &lt;/span&gt;=&lt;span&gt; executeForMap(sqlSession, args);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.returnsCursor()) {
          result &lt;/span&gt;=&lt;span&gt; executeForCursor(sqlSession, args);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          Object param &lt;/span&gt;=&lt;span&gt; method.convertArgsToSqlCommandParam(args);
          result &lt;/span&gt;=&lt;span&gt; sqlSession.selectOne(command.getName(), param);
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; FLUSH:
        result &lt;/span&gt;=&lt;span&gt; sqlSession.flushStatements();
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Unknown execution method for: &quot; +&lt;span&gt; command.getName());
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; method.getReturnType().isPrimitive() &amp;amp;&amp;amp; !&lt;span&gt;method.returnsVoid()) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BindingException(&quot;Mapper method '&quot; +&lt;span&gt; command.getName() 
          &lt;/span&gt;+ &quot; attempted to return null from a method with a primitive return type (&quot; + method.getReturnType() + &quot;).&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中就是select类型的方法复杂些，需要判断接口里的参数来去调用对应的SqlSession方法。&lt;/p&gt;
&lt;p&gt;简单点理解，就是调用mapper接口的方法，最后会被代理实现为调用对应的 sqlSession.select() 或 sqlSession.insert() 等对应的方法。&lt;/p&gt;
&lt;p&gt;流程图如下（右键新标签页打开可查看大图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/416838/202005/416838-20200527031500563-240307636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后调用的这个sqlSession从哪来？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在sqlSession.getMapper(xxx.class)时，会将sqlSession存到代理MapperProxy的属性，然后MapperProxy调用MapperMethod时，会传递给MapperMethod去使用，即&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过Proxy为接口生成并返回代理实现类MapperProxy，并将当前sqlSession存至代理实现类MapperProxy的属性&lt;/span&gt;
IBlogMapper mapper = session.getMapper(IBlogMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用具体方法时，MapperProxy会调用MapperMethod来判断执行对应的sqlSession.select 或 insert等方法，且此sqlSession就是上面生成代理类的sqlSession，是同一个&lt;/span&gt;
Blog blog = mapper.selectBlog(101);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是通过SqlSessionTemplate（后面mybatis-spring内容）.getMapper()，则后面调用的sqlSession就是SqlSessionTemplate对象&lt;/p&gt;

&lt;p&gt;然后这里还有一点小细节，我们可以在生成代理实现类MapperProxy时，就可以遍历接口的方法来提前生成好所有的MapperMethod【饿汉】，但是其实mybatis是在具体调用接口方法时，才生成对应的MapperMethod并缓存到内存【懒汉】 ；具体利弊我们这里就不做分析了。&lt;/p&gt;
&lt;h2&gt;7.Mybatis的插件&lt;/h2&gt;
&lt;p&gt;首先我们为什么需要插件，哪里需要用到插件？其本质也是通过Proxy做一层代理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterceptorChain {

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Interceptor&amp;gt; interceptors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Interceptor&amp;gt;&lt;span&gt;();

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object pluginAll(Object target) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Interceptor interceptor : interceptors) {
      target &lt;/span&gt;=&lt;span&gt; interceptor.plugin(target);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addInterceptor(Interceptor interceptor) {
    interceptors.add(interceptor);
  }
  
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Interceptor&amp;gt;&lt;span&gt; getInterceptors() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.unmodifiableList(interceptors);
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interceptor示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; XXXInterceptor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Interceptor {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object plugin(Object target) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Plugin.wrap(target, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object intercept(Invocation invocation) {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Plugin代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Plugin &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object wrap(Object target, Interceptor interceptor) {
    Map&lt;/span&gt;&amp;lt;Class&amp;lt;?&amp;gt;, Set&amp;lt;Method&amp;gt;&amp;gt; signatureMap =&lt;span&gt; getSignatureMap(interceptor);
    Class&lt;/span&gt;&amp;lt;?&amp;gt; type =&lt;span&gt; target.getClass();
    Class&lt;/span&gt;&amp;lt;?&amp;gt;[] interfaces =&lt;span&gt; getAllInterfaces(type, signatureMap);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (interfaces.length &amp;gt; 0&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Proxy.newProxyInstance(
          type.getClassLoader(),
          interfaces,
          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Plugin(target, interceptor, signatureMap));
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      Set&lt;/span&gt;&amp;lt;Method&amp;gt; methods =&lt;span&gt; signatureMap.get(method.getDeclaringClass());
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (methods != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; methods.contains(method)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; interceptor.intercept(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Invocation(target, method, args));
      }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; method.invoke(target, args);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ExceptionUtil.unwrapThrowable(e);
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们上面已经接触了很多使用Proxy的场景了，这里又是熟悉的配方，熟悉的味道。&lt;/p&gt;
&lt;p&gt;一共有四个地方可以使用插件，即可以被代理，当然被代理对象的所有方法都可以被拦截：&lt;/p&gt;
&lt;p&gt;Executor&lt;/p&gt;
&lt;p&gt;StatementHandler&lt;/p&gt;
&lt;p&gt;ParameterHandler&lt;/p&gt;
&lt;p&gt;ResultSetHandler&lt;/p&gt;
&lt;p&gt;mybatis比较经典的插件使用还是 &lt;a href=&quot;https://pagehelper.github.io/&quot; target=&quot;_blank&quot;&gt;pagehelper&lt;/a&gt; ，然后关于 &lt;a href=&quot;https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/Interceptor.md&quot; target=&quot;_blank&quot;&gt;插件拦截的使用规范&lt;/a&gt; 在 pagehelper官方文档 中也讲的很透彻很详细，我相信在弄懂了本文mybatis原理后再去看 pagehelper这类插件源码也会比较容易懂&lt;/p&gt;
&lt;h2&gt;8.Mybatis的扩展&lt;/h2&gt;
&lt;p&gt;由于我们基本上每个表都要用到一些增删改查方法，然后我们生成代码时，总是会生成一堆类似的代码，xml文件、mapper接口中存在大量相似代码，有没有办法把这些代码抽出来？&lt;/p&gt;
&lt;p&gt;这时候&lt;a href=&quot;https://mp.baomidou.com/&quot; target=&quot;_blank&quot;&gt;mybatis-plus&lt;/a&gt;就出现了，其原理其实就是在mybatis 构建Configuration对象时做了加工，帮我们把增删改查的MappedStatement添加进去；当然mybatis-plus还包含很多其它便捷的功能，但是也是也是基于mybatis做扩展。&lt;/p&gt;
&lt;p&gt;还是那句话，我们把mybatis原理分析清楚了，这块也就更容易去理解了，感兴趣的同学可以从mybatis-plus的MybatisSqlSessionFactoryBean为源头进去看&lt;/p&gt;

&lt;p&gt;我们要知道&lt;a href=&quot;https://mybatis.org/mybatis-3/zh/index.html&quot; target=&quot;_blank&quot;&gt;mybatis&lt;/a&gt; 和 &lt;a href=&quot;http://mybatis.org/spring/zh/index.html&quot; target=&quot;_blank&quot;&gt;mybatis-spring&lt;/a&gt;是分开的两个项目，然后又可以无缝的结合起来进行使用，但是为了便于我们理解，所以我们是分开进行分析，这样更有利于吸收&lt;/p&gt;
&lt;p&gt;与spring结合之前我们必须得熟悉一下spring的数据访问与实务管理&lt;/p&gt;
&lt;h2&gt;1.事务管理的发展史&lt;/h2&gt;
&lt;p&gt;其实spring关于数据访问、事务管理已经做得很好了，但是其中的发展史是怎样的，对于理解mybatis的事务管理非常重要&lt;/p&gt;
&lt;p&gt;我们简单概括一下关于事务的发展过程中的几个典型问题，尽量能够让大家回顾一下发展过程：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.局部事务的管理绑定了具体的数据访问方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题描述：即connection-passing问题，不同方法想要共用事务需要在方法间传递connection，如果使用jdbc则传递connection对象，如果使用hibernate则需要传递session或transaction对象，不同的数据访问形式要用不同的api来控制局部事务，这样我们的方法就业务层就没办法和数据访问解耦&lt;/p&gt;
&lt;p&gt;解决方法：connection绑定到线程ThreadLocal，在业务开始方法获取连接，业务结束方法提交、释放连接&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.事务管理代码与业务逻辑代码相互混杂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题描述：上面问题1虽然解决了方法间传递数据库连接的问题，但是事务的管理还是在业务代码里，且需要合理控制，否则也会有问题&lt;/p&gt;
&lt;p&gt;解决方法：面向切面编程，事务的切面管理（spring @Transactional）&lt;/p&gt;

&lt;p&gt;如果还是不是很理解的朋友， 推荐去看一下《spring 揭密》一书里的数据访问和事务管理相关章节，增加这一块的感知和认识，会有助于平滑的理解mybatis-spring的事务管理 &lt;/p&gt;
&lt;h2&gt;2.Spring 之 DataSourceUtils、@Transactional&lt;/h2&gt;
&lt;p&gt;使用spring事务，注册相关的bean：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Bean
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DataSourceTransactionManager transactionManager() {
    DataSourceTransactionManager dstm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataSourceTransactionManager();
    dstm.setDataSource(dataSource);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dstm;
}
@Bean
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BasicDataSource dataSource() {
    BasicDataSource bds &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BasicDataSource();
    bds.setDriverClassName(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
    bds.setUrl(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
    bds.setUsername(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
    bds.setPassword(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bds;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的使用，注意TransactionManager和DataSourceUtils里使用的dataSource是同一个，不然事务不生效：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodA(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;简单理解就是从ThreadLocal获取数据库连接，如果没有就从DataSource获取后set到ThreadLocal&lt;/span&gt;
    Connection connection =&lt;span&gt; DataSourceUtils.getConnection(dataSource);
    PreparedStatement statement &lt;/span&gt;= connection.prepareStatement(&quot;insert into blog xxx&quot;&lt;span&gt;);
    statement.executeUpdate();
    methodB();
}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Transactional切面after：当前ThreadLocal的connection自动commit，并release DataSourceUtils ThreadLocal中的connection&lt;/span&gt;
 
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodB(){
    Connection connection &lt;/span&gt;=&lt;span&gt; DataSourceUtils.getConnection(dataSource);
    PreparedStatement statement &lt;/span&gt;= connection.prepareStatement(&quot;insert into log xxx&quot;&lt;span&gt;);
    statement.executeUpdate();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;如果方法不在@Transactional事务控制范围内&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是如果方法不在@Transactional事务控制范围内，通过DataSourceUtils.getConnection还是会存在ThreadLocal，只不过ThreadLocal中的connection就需要我们手动去 commit和release，当然DataSourceUtils有方法供我们调用。&lt;/p&gt;

&lt;p&gt;DataSourceUtils中的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Connection&amp;gt; tlConnection = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;Connection&amp;gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;public static&lt;/span&gt;&lt;span&gt; Connection getConnection(DataSource dataSource){
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tlConnection.get() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    tlConnection.set(&lt;/span&gt;&lt;span&gt;dataSource.getConnection());
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tlConnection.get();
}

&lt;/span&gt;&lt;span&gt;public static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; releaseConnection(){
  tlConnection.get().close();
  tlConnection.set(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@Transactional切面实现的伪代码，需要结合TransactionManager和DataSourceUtils来使用，这里简化如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@After
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(JoinPoint joinPoint){
  commitConnection();
  DataSourceUtils.releaseConnection();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结合spring事务时，connection数据库连接在线程中的生命周期如下，即随着事务开始而开始，随时事务结束而结束&lt;/p&gt;
&lt;p&gt;要注意ThreadLocal中set Connection是在业务代码中第一次获取connection时，而不是@Transactional切面的before方法，在必须时才去获取数据库连接，而不是提前占用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/416838/202005/416838-20200526230848359-681102326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用spring的数据访问和事务管理就解决了我们上面所提到的两个问题：&lt;/p&gt;
&lt;p&gt;1.局部事务的管理绑定了具体的数据访问方式&lt;br/&gt;2.事务管理代码与业务逻辑代码相互混杂 &lt;/p&gt;

&lt;p&gt;其实mybatis项目一直抽象到SqlSession，都没有解决事务管理发展的那两个问题&lt;/p&gt;
&lt;p&gt;多个方法如果想要共用SqlSession需要通过参数传递，且事务的提交也要我们自己写在业务代码里，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodA(){
  SqlSession session &lt;/span&gt;=&lt;span&gt; sqlSessionFactory.openSession();
  session.insert(&lt;/span&gt;&quot;insertBlog&quot;&lt;span&gt;,xxx);
  methodB(session);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodB(SqlSesion session){
  session.insert(&lt;/span&gt;&quot;insertUser&quot;&lt;span&gt;,xxx);
  session.commit();
  session.close();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.SpringManagedTransaction&lt;/h2&gt;
&lt;p&gt;我们上文已经知道mybatis的Transaction对象是用来获取、操作connection，但是也仅限于单个Executor、SqlSession内部，没有放到线程ThreadLocal里去，要想共用同一个connection事务，还是必须参数传递SqlSession或者Connection对象（即上面的问题1），如何解决？我们把Transaction里的connection放到ThreadLocal不就解决了吗？&lt;/p&gt;
&lt;p&gt;那我们直接把Transaction对象里的getConnection方法改一下不就行了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Connection&amp;gt; tlConnection = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;Connection&amp;gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Connection getConnection(){
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tlConnection.get() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    tlConnection.set(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dataSource.getConnection());
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tlConnection.get();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现是不是跟DataSourceUtils的getConnection方法一模一样，所以结合spring的数据访问的话，可以精简成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Connection getConnection(){
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; DataSourceUtils.getConnection(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dataSource);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这段伪代码其实就是SpringManagedTransaction所干的事情&lt;/p&gt;
&lt;h2&gt;4.SqlSessionUtils&lt;/h2&gt;
&lt;p&gt;然后我们结合@Transactional使用，我们来看看代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodA(){
    TransactionFactory transactionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringManagedTransactionFactory();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    Transaction transaction &lt;/span&gt;=&lt;span&gt; transactionFactory.newTransaction(dataSource);&lt;p&gt;Connection connection &lt;/p&gt;&lt;/span&gt;=&lt;span&gt; transaction.getConnection();&lt;br/&gt;PreparedStatement statement &lt;/span&gt;= connection.prepareStatement(&quot;insert into blog xxx&quot;&lt;span&gt;);&lt;br/&gt;statement.executeUpdate();&lt;br/&gt;methodB(transaction);&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
public void&lt;span&gt; methodB(Transaction transaction){
    Connection connection =&lt;span&gt; transaction.getConnection();
    PreparedStatement statement = connection.prepareStatement(&quot;insert into user xxx&quot;&lt;span&gt;);
    statement.executeUpdate();
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码解决了问题2，但是没解决问题1，是不用传递connection了，但是现在又要传递transaction。&lt;/p&gt;
&lt;p&gt;类似connection，我们创建一个TransactionUtils工具类将transaction也绑定到ThreadLocal不就解决问题了？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodA(){
    Connection connection &lt;/span&gt;=&lt;span&gt; TransactionUtils.getTransaction().getConnection();
    PreparedStatement statement &lt;/span&gt;= connection.prepareStatement(&quot;insert into blog xxx&quot;&lt;span&gt;);
    statement.executeUpdate();
    methodB(transaction);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodB(){
    Connection connection &lt;/span&gt;=&lt;span&gt; TransactionUtils.getTransaction().getConnection();
    PreparedStatement statement &lt;/span&gt;= connection.prepareStatement(&quot;insert into user xxx&quot;&lt;span&gt;);
    statement.executeUpdate();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TransactionUtils的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Transaction&amp;gt; tlTransaction = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;Transaction&amp;gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Transaction getTransaction(){
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tlTransaction.get() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    TransactionFactory transactionFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringManagedTransactionFactory();
    Transaction transaction &lt;/span&gt;=&lt;span&gt; transactionFactory.newTransaction(dataSource);
    tlTransaction.set(transaction);
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tlTransaction.get();
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; releaseTransaction(){
  tlTransaction.get().connection.close();
  tlTransaction.set(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题并没有结束，我们要用的是mybatis的SqlSession，你这样不是又回到原始的jdbc了，行我们继续改，同样类似DataSourceUtils我们再建个SqlSessionUtils行了吧：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodA(){
    SqlSession sqlSession &lt;/span&gt;=&lt;span&gt; SqlSessionUtils.getSqlSession(sqlSessionFactory);
    sqlSession.insert(&quot;insertBlog&quot;,xxx);
    methodB();
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodB(){
    SqlSession sqlSession &lt;/span&gt;=&lt;span&gt; SqlSessionUtils.getSqlSession(sqlSessionFactory);
    sqlSession.insert(&quot;insertUser&quot;,xxx);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SqlSessionUtils里的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;SqlSession&amp;gt; tlSqlSession = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;SqlSession&amp;gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SqlSession getSqlSession(SqlSessionFactory factory){
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tlSqlSession.get() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    SqlSession sqlSession &lt;/span&gt;=&lt;span&gt; factory.openSession();
    tlSqlSession.set(sqlSession);
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tlSqlSession.get();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在SqlSession里的connection已经通过SpringManagedTransaction打通spring的DataSourceUtils存到ThreadLocal，且@Transactional注解切面after会自动connection.commit(); 且释放ThreadLocal资源（SqlSession）&lt;/p&gt;
&lt;p&gt;但是还有一个问题：&lt;/p&gt;
&lt;p&gt;同一个spring事务我们是使用相同的SqlSession了，但是我们想要的是@Transactional注解切面after自动实现sqlSession.commit() 而不是 connection.commit()；其实SqlSession.commit()主要也是实现connection.commit()，这个确实是一点小瑕疵，但是确实是不影响使用。&lt;/p&gt;

&lt;p&gt;这样SqlSession的生命周期就实现了类似spring事务里Connection的生命周期，且同connection一样，ThreadLocal中set SqlSession是在业务代码中第一次获取SqlSession时，而不是@Transactional切面的before方法，在必须时才去获取，而不是提前获取资源。&lt;/p&gt;
&lt;p&gt;需要注意的是源码中SqlSessionUtils不是直接将SqlSession存在ThreadLocal，而是和spring的DataSourceUtils一样，通过spring的TransactionSynchronizationManager来存储到ThreadLocal，这里为了便于理解我们直接进行了简化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/416838/202005/416838-20200526230908988-598329471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果不使用@Transactional注解进行事务管理的话怎么使用SqlSessionUtils&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SqlSession依然会帮我们存到ThreadLocal，不过同DataSourceUtils一样就需要我们手动commit和release；因为没人帮我们干这个事情了，需要我们自己处理。当然SqlSessionUtils有提供方法供我们自己调用。&lt;/p&gt;
&lt;p&gt;例如下面代码，如果这样写是不是就有问题了？就没人帮我们commit和close connection了！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodC(){
    SqlSession sqlSession &lt;/span&gt;=&lt;span&gt; SqlSessionUtils.getSqlSession(sqlSessionFactory);
    sqlSession.insert(&lt;/span&gt;&quot;insertXXX&quot;&lt;span&gt;,xxx);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要改成如下格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodC(){
    SqlSession sqlSession &lt;/span&gt;=&lt;span&gt; SqlSessionUtils.getSqlSession(sqlSessionFactory);
    sqlSession.insert(&lt;/span&gt;&quot;insertXXX&quot;&lt;span&gt;,xxx);
    sqlSession.commit();
    SqlSessionUtils.closeSqlSession(sqlSession,sqlSessionFactory);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这下问题又麻烦了：&lt;/p&gt;
&lt;p&gt;1.methodC可能会被其他方法受spring事务控制的方法调用，这样其也会被纳入spring事务范围管理，&lt;strong&gt;不需要自己提交connection。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如如果被上面methodA方法内部调用，@Transactional切面after会在methodA的所有代码（当然包括methodC的代码）执行完后自动提交connection&lt;/p&gt;
&lt;p&gt;2.如果直接调用methodC，其本身又不在spring事务管理范围，&lt;strong&gt;需要自己提交connection&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我们有没有办法判断当前方法是否在@Transactional事务范围内，如果在事务范围内，就不处理，交由事务去提交；如果不在事务范围内，就自己提交？ &lt;/p&gt;
&lt;h2&gt;5.SqlSessionTemplate&lt;/h2&gt;
&lt;p&gt;上述问题我们做一下判断，伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodC(){
    SqlSession sqlSession &lt;/span&gt;=&lt;span&gt; SqlSessionUtils.getSqlSession();
    sqlSession.insert(&lt;/span&gt;&quot;insertXXX&quot;&lt;span&gt;,xxx);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isSqlSessionTransactional(sqlSession,sqlSessionFactory)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断当前sqlSession是否在spring @Transactional事务管理范围内
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;donothing&lt;/span&gt;
    }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        sqlSession.commit();
        sqlSession.close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如何判断当前sqlSession是否在spring @Transactional事务管理范围内呢？如果感兴趣的话可以直接去看一下源码，我们这里就不啰嗦了&lt;/p&gt;
&lt;p&gt;然后上面这段判断代码我们不可能每个方法里都写一遍吧，有没有办法提取出来，我们就不绕弯子了，直接看优雅的SqlSessionTemplate：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodC(){
    SqlSessionTemplate sqlSessionTemplate&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionTemplate(sqlSessionFactory);
    sqlSessionTemplate.insert(&lt;/span&gt;&quot;insertXXX&quot;,xxx&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;又是基于Proxy代理，在执行 SqlSession方法时，都交由代理去处理，SqlSessionTemplate的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SqlSessionTemplate &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; SqlSession, DisposableBean {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ...
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getClassLoader(),
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Class[] { SqlSession.&lt;span&gt;class&lt;/span&gt; }, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionInterceptor());
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; insert(String statement, Object parameter) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sqlSessionProxy.insert(statement, parameter);
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SqlSessionInterceptor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
      SqlSession sqlSession &lt;/span&gt;=&lt;span&gt; SqlSessionUtils.getSqlSession(sqlSessionFactory);
      Object result &lt;/span&gt;= method.invoke(sqlSession, args);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行sqlSession对应的方法&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(isSqlSessionTransactional(sqlSession,sqlSessionFactory)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断当前sqlSession是否在spring @Transactional事务管理范围内
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;donothing&lt;/span&gt;
      }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        sqlSession.commit();
        sqlSession.close();
      }
    }
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/416838/202005/416838-20200527024948778-1608841486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;终于，经历了这么多，mybatis-spring终于能够与spring的事务管理比较完美的融合了？&lt;/p&gt;
&lt;p&gt;问题仍然还没结束，我们目前的操作也仅限于SqlSession的方法操作，我们上面基于Mapper接口的操作呢，回顾我们上面MapperProxy、MapperMethod，MapperMethod是调用SqlSession相应的方法，怎么才能对接上SqlSessionTemplate&lt;/p&gt;
&lt;p&gt;那还不简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
SqlSessionTemplate sqlSessionTemplate =&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionTemplate(sqlSessionFactory);
IBlogMapper blogMapper &lt;/span&gt;= sqlSessionTemplate.getMapper(IBlogMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
blogMapper.selectBlog(&lt;/span&gt;101);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.MapperScannerConfigurer&lt;/h2&gt;
&lt;p&gt;现在我们结合mybatis-spring来使用SqlSession已经优雅了很多，我们也可以基于MapperProxy来实现上面的MethodA、MethodB的代码，这样就省去了字符串硬编码，这种方式会更好：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodA(){
    SqlSessionTemplate sqlSessionTemplate &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionTemplate(sqlSessionFactory);
    IBlogMapper blogMapper &lt;/span&gt;= sqlSession.getMapper(IBlogMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    blogMapper.insertBlog(xxx);
    methodB();
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodB(){
    SqlSessionTemplate sqlSessionTemplate &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionTemplate(sqlSessionFactory);
    IUserMapper userMapper &lt;/span&gt;= sqlSession.getMapper(IUser.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    userMapper.insertUser(xxx);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们知道SqlSessionTemplate是基于proxy代理形式实现了对应的功能，那么我们在结合spring使用的时候，能否把这个代理注册成spring的bean呢，就是把sqlSession.getMapper(xxx.class)注册成spring的bean，这样我们就能够使用如下@Autowired这样更优雅的编码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Autowired
IBlogMapper blogMapper;

@Autowired
IUserMapper userMapper;

@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodA(){
    blogMapper.insertBlog(xxx);
    methodB();
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; methodB(){
    userMapper.insertUser(xxx);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;怎样注册spring bean呢，我们以IBlogMapper接口举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBlogMapper {
    List&lt;/span&gt;&amp;lt;Blog&amp;gt;&lt;span&gt; findActiveBlogLike(Map map);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;手动注册实现类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BlogMapper &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IBlogMapper {
    @Autowired
    SqlSessionFactory sqlSessionFactory;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Blog&amp;gt;&lt;span&gt; findActiveBlogLike(Map map) {
        SqlSessionTemplate sqlSessionTemplate &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionTemplate(sqlSessionFactory);
        List&lt;/span&gt;&amp;lt;Blog&amp;gt; list = sqlSessionTemplate.selectList(&quot;findActiveBlogLike&quot;&lt;span&gt;,map);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不对啊，这里没有用到MapperProxy代理实现啊，而是自己手动去判断和映射接口需要使用sqlsession的哪个方法了，完全没MapperProxy和MapperMethod的事情啊？这肯定不是我们想要的！&lt;/p&gt;
&lt;h3&gt;Spring 之 BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor&lt;/h3&gt;
&lt;p&gt;要想给spring动态的注册bean，这就又到了spring bean的生命周期的知识了，我们这里就直接看mybatis-spring使用的什么了，就不啰嗦spring bean生命周期了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Bean
MapperScannerConfigurer mapperScannerConfigurer() {
    MapperScannerConfigurer msc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MapperScannerConfigurer();
    msc.setBasePackage(&lt;/span&gt;&quot;xxx&quot;&lt;span&gt;);
    msc.setAnnotationClass(Mapper.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以设置只注册添加了mybatis @Mapper注解的接口&lt;/span&gt;
    msc.setSqlSessionFactoryBeanName(&quot;sqlSessionFactory&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; msc;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MapperScannerConfigurer的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MapperScannerConfigurer &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanDefinitionRegistryPostProcessor ... {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {&lt;/span&gt;&lt;span&gt;
    ClassPathMapperScanner scanner &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassPathMapperScanner(registry);
&lt;/span&gt;&lt;span&gt;    ...
    scanner.scan(
        StringUtils.tokenizeToStringArray(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
  }&lt;br/&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ClassPathMapperScanner的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ClassPathMapperScanner &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ClassPathBeanDefinitionScanner {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;BeanDefinitionHolder&amp;gt;&lt;span&gt; doScan(String... basePackages) {
    Set&lt;/span&gt;&amp;lt;BeanDefinitionHolder&amp;gt; beanDefinitions = &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.doScan(basePackages);
      ...
      processBeanDefinitions(beanDefinitions);
      ...
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; beanDefinitions;
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; MapperFactoryBean&amp;gt; mapperFactoryBeanClass = MapperFactoryBean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; processBeanDefinitions(Set&amp;lt;BeanDefinitionHolder&amp;gt;&lt;span&gt; beanDefinitions) {
    GenericBeanDefinition definition;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (BeanDefinitionHolder holder : beanDefinitions) {
      definition &lt;/span&gt;=&lt;span&gt; (GenericBeanDefinition) holder.getBeanDefinition();
      String beanClassName &lt;/span&gt;=&lt;span&gt; definition.getBeanClassName();
      
      definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; issue #59&lt;/span&gt;
      definition.setBeanClass(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mapperFactoryBeanClass);
&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; explicitFactoryUsed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (StringUtils.hasText(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sqlSessionFactoryBeanName)) {
        definition.getPropertyValues().add(&lt;/span&gt;&quot;sqlSessionFactory&quot;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RuntimeBeanReference(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sqlSessionFactoryBeanName));
        explicitFactoryUsed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      }
      ...
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即扫描我们设置的basepackage下的所有符合过滤器规则的接口(例如可以设置只扫描返回带有mybatis @Mapper注解的接口)，然后注册成为spring bean，不过注册的bean并不是MapperProxy，而是MapperFactoryBean，好吧，继续往里面看&lt;/p&gt;
&lt;h3&gt;MapperFactoryBean&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MapperFactoryBean&amp;lt;T&amp;gt; &lt;span&gt;extends&lt;/span&gt; SqlSessionDaoSupport &lt;span&gt;implements&lt;/span&gt; FactoryBean&amp;lt;T&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T getObject() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getSqlSession().getMapper(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mapperInterface);
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SqlSession getSqlSession() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionTemplate(sqlSessionFactory);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MapperFactoryBean这里实现了FactoryBean接口，实际注册的bean会通过getObject方法返回最终的实现类，终于到了我们的MapperProxy了 &lt;/p&gt;
&lt;h3&gt;@MapperScan @MapperScans&lt;/h3&gt;
&lt;p&gt;这两个mybatis-spring的注解其实就是用于自动帮我们注册MapperScannerConfigurer 的spring Bean&lt;/p&gt;
&lt;h3&gt;SqlSessionFactoryBean&lt;/h3&gt;
&lt;p&gt;我们之前声明SqlSessionFactory时要写一堆代码，现在这个工作交给SqlSessionFactoryBean，其也继承了spring FactoryBean接口，即通过getObject方法返回实际注册的对象：SqlSessionFactory&lt;/p&gt;
&lt;h2&gt;7.mybatis-spring-boot-starter&lt;/h2&gt;
&lt;p&gt;mybatis-spring-boot-starter其实就是帮我们做一些自动化的配置，和spring-boot-starter的初衷一样，这一块其实没有什么好讲的，所以我们就附属到mybatis-spring的一个小章节里&lt;/p&gt;
&lt;p&gt;该项目pom里引用了mybatis-spring-boot-autoconfigure，其spring.factories如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration,\
org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;MybatisLanguageDriverAutoConfiguration&lt;/h3&gt;
&lt;p&gt;就是帮我们自动设置LanguageDriver，例如FreeMarkerLanguageDriver、ThymeleafLanguageDriver等，mybatis默认是XMLLanguageDriver&lt;/p&gt;
&lt;h3&gt;MybatisAutoConfiguration&lt;/h3&gt;
&lt;p&gt;这里主要自动帮我们注册了SqlSessionFactory、SqlSessionTemplate、MapperScannerConfigurer的Bean&lt;/p&gt;
&lt;p&gt;主要还是MapperScannerConfigurer的Bean，就省去了我们之前还要手动去注册MapperScannerConfigurer Bean，不过这里有设置MapperScannerConfigurer 只扫描带有mybatis @Mapper注解的接口。&lt;/p&gt;
&lt;p&gt;到目前为止我们绝大多数场景只需要注册一个SqlSessionFactoryBean为 spring bean就可以了&lt;/p&gt;


&lt;p&gt;读懂源码不难，讲出来通俗易懂很难，写出来通俗易懂是难上加难，文章写出来不易，还望各位点点推荐，也欢迎评论区交流，你的互动也是我更新和维护的动力。&lt;/p&gt;
</description>
<pubDate>Tue, 26 May 2020 22:39:00 +0000</pubDate>
<dc:creator>RoyTian</dc:creator>
<og:description>mybatis 面向对象设计原理 架构原理解析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/roytian/p/12762218.html</dc:identifier>
</item>
</channel>
</rss>