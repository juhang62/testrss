<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据结构第九节(排序(上)) - W&amp;B</title>
<link>http://www.cnblogs.com/cs-Miscellaneous/p/14127791.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cs-Miscellaneous/p/14127791.html</guid>
<description>&lt;h2 id=&quot;简单排序差劲排序&quot;&gt;简单排序(差劲排序)&lt;/h2&gt;
&lt;p&gt;下面的几种排序都是非常简单容易实现的，不过也有着相应的问题，他们在正常的情况下排序，时间复杂度几乎都是&lt;span class=&quot;math inline&quot;&gt;\(O(N^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h3&gt;
&lt;p&gt;冒泡冒泡，大的沉底，小的浮起。&lt;br/&gt;基本思路是循环n-1次，每次把最大的元素沉底。&lt;br/&gt;从j遍历到i，如果j比他的下一个元素(j+1)大，就交换他们。还有一个小技巧判断整个序列是否已经有序，无需继续执行。首先每次循环默认有序，如果便利完了都没有发生交换，说明已经有序退出即可。&lt;br/&gt;算法最优时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(N)\)&lt;/span&gt;，整个序列完全有序。&lt;br/&gt;算法最坏时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(N^2)\)&lt;/span&gt;，整个序列完全逆序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//冒泡排序
void Bubble_Sort(int array[],int n) {
        for (int i = n-1; i &amp;gt;= 0; i--)
        {
                bool isend = true;
                for (int j = 0; j &amp;lt; i; j++)
                {
                        //swap j and j+1
                        if (array[j] &amp;gt; array[j + 1]) {
                                int temp = array[j];
                                array[j] = array[j+1];
                                array[j + 1] = temp;
                                isend = false;
                        }
                }
                if (isend) {
                        break;
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;插入排序&quot;&gt;插入排序&lt;/h3&gt;
&lt;p&gt;基本的原理类似于我们玩扑克时的插排。&lt;br/&gt;每次从未排序的数组中选一个，插到前面已经有序的序列里。初始从array[1]开始，向前扫描，如果array[0]如果比array[1]大，把0移到1的位置上，循环n-1次。&lt;br/&gt;算法最优时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(N)\)&lt;/span&gt;，整个序列完全有序。&lt;br/&gt;算法最坏时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(N^2)\)&lt;/span&gt;，整个序列完全逆序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//插入排序
void Insertion_Sort(int array[], int n) {
        for (int i = 1; i &amp;lt; n; i++)
        {
                int temp = array[i];
                int j = 0;
                for (j = i; j &amp;gt; 0&amp;amp;&amp;amp;array[j-1]&amp;gt;temp; j--)
                {
                        array[j] = array[j - 1];
                }
                array[j] = temp;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;选择排序&quot;&gt;选择排序&lt;/h3&gt;
&lt;p&gt;非常沙雕的一个排序，虽然很容易理解，但实在是太糟糕了。&lt;br/&gt;基本思路是循环i:0到n-1，每次从数组中找到最小的放在i的的位置。&lt;br/&gt;算法时间复杂度始终为&lt;span class=&quot;math inline&quot;&gt;\(O(N^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//选择排序
void Selection_Sort(int array[], int n) {
        for (int i = 0; i &amp;lt; n-1; i++)
        {
                int point = i;
                for (int j = i + 1; j &amp;lt; n; j++) {
                        if (array[j] &amp;lt; array[point]) {
                                point = j;
                        }
                }
                //swap
                if (point != i) {
                        int temp = array[i];
                        array[i] = array[point];
                        array[point] = temp;
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;高级排序&quot;&gt;高级排序&lt;/h2&gt;
&lt;p&gt;下面等级重排序相比上面略微难理解一些，不过相应的，他们的时间复杂度都有了质的变化。&lt;/p&gt;
&lt;h3 id=&quot;希尔排序&quot;&gt;希尔排序&lt;/h3&gt;
&lt;p&gt;作为插入排序的进阶版，速度提有了很大的提升，但面对特定的序列时可能会与选择排序达到同样的时间复杂。&lt;br/&gt;基本思路是做一个增量序列{&lt;span class=&quot;math inline&quot;&gt;\(k_1,k_2,k_3,k_4,k_5...k_n\)&lt;/span&gt;}。&lt;br/&gt;循环的i:1到k，每次以&lt;span class=&quot;math inline&quot;&gt;\(k_i\)&lt;/span&gt;为间隔做选择排序。在初始的版本中，选择的增量序列为数组元素个数的一半，每次循环变为原来的一半，直到为1时结束。不过这样的方法因为选定的增量序列不互质，给定特殊的序列例如{&lt;span class=&quot;math inline&quot;&gt;\(1,9,2,10,3,11,4,12\)&lt;/span&gt;}时，我们发现直到增量变为1时，压根就没有起效果，比插入排序还慢。&lt;br/&gt;选择合理的增量序列有时候会有奇效，选择不好的增量序列时也会非常头疼。&lt;br/&gt;传统的希尔排序算法最坏时间复杂度&lt;span class=&quot;math inline&quot;&gt;\(O(N^2)\)&lt;/span&gt;。&lt;br/&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shellsort#Gap_sequences&quot; target=&quot;_blank&quot;&gt;wiki中有更详细的其他的增量序列&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//希尔排序
void Shell_Sort(int array[], int n) {
        //i为增量序列，每隔i个的元素做插入排序
        for (int i = n/2; i &amp;gt; 0; i /=2)
        {
                for (int j = i; j &amp;lt; n; j++)
                {
                        int temp = array[j];
                        int k = 0;
                        for (k = j; k&amp;gt;=i &amp;amp;&amp;amp; array[k-i]&amp;gt;temp; k-=i)
                        {
                                array[k] = array[k - i];
                        }
                        array[k] = temp;
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;堆排序&quot;&gt;堆排序&lt;/h3&gt;
&lt;p&gt;基本思路是先将传入的数组调成一个最大堆，每次将堆顶元素拿出，与堆的末尾元素交换，再将堆的容量减1 ，再接着调整堆，直到堆变空。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//调整堆
void Adjustment(int array[],int n,int k) {
        //下标K代表数组元素array[k]空缺
        int temp = array[k];
        for (int j = k * 2 + 1; j &amp;lt; n; j = 2 * j + 1)
        {
                if (j + 1 &amp;lt; n &amp;amp;&amp;amp; array[j + 1] &amp;gt; array[j]) {
                        j++;
                }
                if (array[j] &amp;gt; temp) {
                        array[k] = array[j];
                        k = j;
                }
                else {
                        break;
                }
        }
        array[k] = temp;
}
//堆排序
void Heap_Sort(int array[], int n) {
        //使数组变成最大堆
        for (int i = n/2-1; i &amp;gt;= 0; i--)
        {
                Adjustment(array, n, i);
        }
        //每次交换最大元素array[0]和堆的最后一位，每次堆大小减1
        for (int i = n-1; i &amp;gt; 0; i--)
        {
                int temp = array[i];
                array[i] = array[0];
                array[0] = temp;
                Adjustment(array, i, 0);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;归并排序&quot;&gt;归并排序&lt;/h3&gt;
&lt;p&gt;归并排序是一种典型的分而治之思想，基本思路是递归的将一个数组一分为2，将左右排好序后，合并他们。对于每个一分为2的数组又可以接着递归，直到要分的数组大小已经为1便不再去分。&lt;br/&gt;我们都知到调用地规并不是一个好方法，可能会系统爆栈，这里通过循环实现。&lt;br/&gt;思路是，一个大小为N的数组，把他想成N个大小为1的有序数组，每次循环两个两个合并起来成为大小为2的有序数组 ，再接着合并大小为4的有序数组，直到合并为一整个数组，也实现了整个数组的排序。该方法坑略多，具体操作在代码中加了注释。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//合并2个有序子序列
void Merge(int array[],int temparray[],int head1,int head2,int rightend) {
        int leftend = head2 - 1;
        int i = head1, j = head2, k = head1;
        //循环条件为要合并的两个小数组都不空
        while (i&amp;lt;=leftend&amp;amp;&amp;amp;j&amp;lt;=rightend)
        {
                if (array[i] &amp;lt;= array[j]) {
                        temparray[k++] = array[i];
                        i++;
                }
                else {
                        temparray[k++] = array[j];
                        j++;
                }
        }
        //将剩余元素填入
        while (i &amp;lt;= leftend)
        {
                temparray[k++] = array[i++];
        }
        while (j &amp;lt;= rightend)
        {
                temparray[k++] = array[j++];
        }
        //将临时数组中的元素移回原数组
        for (i = head1; i &amp;lt;= rightend; i++)
        {
                array[i] = temparray[i];
        }
}
//按长度length归并
void Merge_Pass(int array[], int temparray[],int n,int length) {
        int i;
        //完全的两两合并
        for (i = 0; i &amp;lt;= n-2*length; i += 2 * length)
        {
                Merge(array, temparray, i, i + length, i + 2 * length - 1);
        }
        //残缺的两两合并
        if (i + length &amp;lt; n) {
                Merge(array, temparray, i, i + length, n-1);
        }
        //残的一个都没有,直接倒回去
        else {
                for (int j = 0; j &amp;lt; n; j++)
                {
                        temparray[j] = array[j];
                }
        }
}
//归并排序
void Merge_Sort(int array[], int n) {
        int length = 1;
        int* temparray = (int*)malloc(n * sizeof(array));
        if (temparray != NULL) {
                while (length&amp;lt;n)
                {
                        Merge_Pass(array, temparray, n, length);
                        length *= 2;
                        Merge_Pass(temparray, array, n, length);
                        length *= 2;
                }
                free(temparray);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三个小题&quot;&gt;三个小题&lt;/h2&gt;
&lt;h3 id=&quot;09-排序1-排序-25points&quot;&gt;09-排序1 排序 (25point(s))&lt;/h3&gt;
&lt;p&gt;给定N个（长整型范围内的）整数，要求输出从小到大排序后的结果。&lt;/p&gt;
&lt;p&gt;本题旨在测试各种不同的排序算法在各种数据情况下的表现。各组测试数据特点如下：&lt;/p&gt;
&lt;p&gt;数据1：只有1个元素；&lt;br/&gt;数据2：11个不相同的整数，测试基本正确性；&lt;br/&gt;数据3：103个随机整数；&lt;br/&gt;数据4：104个随机整数；&lt;br/&gt;数据5：105个随机整数；&lt;br/&gt;数据6：105个顺序整数；&lt;br/&gt;数据7：105个逆序整数；&lt;br/&gt;数据8：105个基本有序的整数；&lt;br/&gt;数据9：105个随机正整数，每个数字不超过1000。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入格式:&lt;/strong&gt;&lt;br/&gt;输入第一行给出正整数N（≤10&lt;br/&gt;​5&lt;br/&gt;​​ ），随后一行给出N个（长整型范围内的）整数，其间以空格分隔。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出格式:&lt;/strong&gt;&lt;br/&gt;在一行中输出从小到大排序后的结果，数字间以1个空格分隔，行末不得有多余空格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入样例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;11&lt;br/&gt;4 981 10 -17 0 -20 29 50 8 43 -5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;输出样例:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;-20 -17 -5 0 4 8 10 29 43 50 981&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题解：&lt;/strong&gt;&lt;br/&gt;没什么好说的，自行尝试上面的各种排序（部分排序因为过于慢，会导致长时间判断中）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdbool&amp;gt;
#include&amp;lt;cstdio&amp;gt;
using namespace std;

int arr[100000];
int main() {
        int n;
        scanf(&quot;%d&quot;, &amp;amp;n);
        for (int i = 0; i &amp;lt; n; i++)
        {
                scanf(&quot;%d&quot;, &amp;amp;arr[i]);
        }
        sort(arr, arr + n);
        bool isf = true;
        for (int i = 0; i &amp;lt; n; i++)
        {
                if (isf) {
                        printf(&quot;%d&quot;, arr[i]);
                        isf = false;
                }
                else {
                        printf(&quot; %d&quot;, arr[i]);
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;09-排序2-insert-or-merge-25points&quot;&gt;09-排序2 Insert or Merge (25point(s))&lt;/h3&gt;
&lt;p&gt;According to Wikipedia:&lt;/p&gt;
&lt;p&gt;Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.&lt;/p&gt;
&lt;p&gt;Merge sort works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining.&lt;/p&gt;
&lt;p&gt;Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input Specification:&lt;/strong&gt;&lt;br/&gt;Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output Specification:&lt;/strong&gt;&lt;br/&gt;For each test case, print in the first line either &quot;Insertion Sort&quot; or &quot;Merge Sort&quot; to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sample Input 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;10&lt;br/&gt;3 1 2 8 7 5 9 4 6 0&lt;br/&gt;1 2 3 7 8 5 9 4 6 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Sample Output 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Insertion Sort&lt;br/&gt;1 2 3 5 7 8 9 4 6 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Sample Input 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;10&lt;br/&gt;3 1 2 8 7 5 9 4 0 6&lt;br/&gt;1 3 2 8 5 7 4 9 0 6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Sample Output 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Merge Sort&lt;br/&gt;1 2 3 8 4 5 7 9 0 6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题解：&lt;/strong&gt;&lt;br/&gt;根据插入排序的性质，可以很容易判断出插入排序。&lt;br/&gt;首先从0开始扫描，直到扫描到逆序的点，接着从逆序点p开始向后扫描到n-1，如果array1和array2都一样，说明一定是插入排序，否则为归并排序。&lt;br/&gt;对插入排序，再对逆序的位置插一次。&lt;br/&gt;对归并排序，我们先分析一下要能分清楚插入还是归并，肯定至少经过一步，但是也不能完全排序，所以归并至少每2个元素组成的数组有序，那么，如何更高的判断4个的情况呢，就是取中间值，如果长度为n的小数组中点小于他的前节点，就说明是无序的，且排到有序长度正好为该长度的一半。&lt;br/&gt;所以从2开始，每次加2倍的2，判断是否达到了4。{2，6，10，14......}。&lt;br/&gt;如果4成功通过，接着{4，12，20......}，依次类推。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdbool&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#define MAXSIZE 101
using namespace std;

//调整堆
void Adjustment(int array[], int n, int k) {
        //下标K代表数组元素array[k]空缺
        int temp = array[k];
        for (int j = k * 2 + 1; j &amp;lt; n; j = 2 * j + 1)
        {
                if (j + 1 &amp;lt; n &amp;amp;&amp;amp; array[j + 1] &amp;gt; array[j]) {
                        j++;
                }
                if (array[j] &amp;gt; temp) {
                        array[k] = array[j];
                        k = j;
                }
                else {
                        break;
                }
        }
        array[k] = temp;
}
//打印数组
void PrintArray(int arr[], int n) {
        bool isf = true;
        for (int i = 0; i &amp;lt; n; i++)
        {
                if (isf) {
                        printf(&quot;%d&quot;, arr[i]);
                        isf = false;
                }
                else {
                        printf(&quot; %d&quot;, arr[i]);
                }
        }
}

//合并2个有序子序列
void Merge(int array[], int temparray[], int head1, int head2, int rightend) {
        int leftend = head2 - 1;
        int i = head1, j = head2, k = head1;
        //循环条件为要合并的两个小数组都不空
        while (i &amp;lt;= leftend &amp;amp;&amp;amp; j &amp;lt;= rightend)
        {
                if (array[i] &amp;lt;= array[j]) {
                        temparray[k++] = array[i];
                        i++;
                }
                else {
                        temparray[k++] = array[j];
                        j++;
                }
        }
        //将剩余元素填入
        while (i &amp;lt;= leftend)
        {
                temparray[k++] = array[i++];
        }
        while (j &amp;lt;= rightend)
        {
                temparray[k++] = array[j++];
        }
        //将临时数组中的元素移回原数组
        for (i = head1; i &amp;lt;= rightend; i++)
        {
                array[i] = temparray[i];
        }
}
//按长度length归并
void Merge_Pass(int array[], int temparray[], int n, int length) {
        int i;
        //完全的两两合并
        for (i = 0; i &amp;lt;= n - 2 * length; i += 2 * length)
        {
                Merge(array, temparray, i, i + length, i + 2 * length - 1);
        }
        //残缺的两两合并
        if (i + length &amp;lt; n) {
                Merge(array, temparray, i, i + length, n - 1);
        }
}

int main() {
        int array1[MAXSIZE];
        int array2[MAXSIZE];
        int n;
        //read array
        scanf(&quot;%d&quot;, &amp;amp;n);
        for (int i = 0; i &amp;lt; n; i++)
        {
                scanf(&quot;%d&quot;, &amp;amp;array1[i]);
        }
        for (int i = 0; i &amp;lt; n; i++)
        {
                scanf(&quot;%d&quot;, &amp;amp;array2[i]);
        }
        //check insertion or heap sort
        int p;
        for (p = 0; p &amp;lt; n - 1; p++)
        {
                if (array2[p] &amp;gt; array2[p + 1]) {
                        p++;
                        break;
                }
        }
        bool isinsertion = true;
        for (int i = p; i &amp;lt; n; i++)
        {
                if (array1[i] != array2[i]) {
                        isinsertion = false;
                        break;
                }
        }
        //get next step sort
        if (isinsertion) {
                int temp = array2[p];
                int j = 0;
                for (j = p; j &amp;gt; 0 &amp;amp;&amp;amp; array2[j - 1] &amp;gt; temp; j--)
                {
                        array2[j] = array2[j - 1];
                }
                array2[j] = temp;
                printf(&quot;Insertion Sort\n&quot;);
                PrintArray(array2, n);
        }
        else {
                bool con = true;
                int i;
                for (i = 2; con ; i*=2)
                {
                        for (int j = i; j &amp;lt; n; j+=i*2)
                        {
                                if (array2[j - 1] &amp;gt; array2[j]) {
                                        con = false;
                                }
                        }
                }
                Merge_Pass(array2, array1, n, i/2);
                printf(&quot;Merge Sort\n&quot;);
                PrintArray(array2, n);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;09-排序3-insertion-or-heap-sort-25points&quot;&gt;09-排序3 Insertion or Heap Sort (25point(s))&lt;/h3&gt;
&lt;p&gt;According to Wikipedia:&lt;/p&gt;
&lt;p&gt;Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.&lt;/p&gt;
&lt;p&gt;Heap sort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. it involves the use of a heap data structure rather than a linear-time search to find the maximum.&lt;/p&gt;
&lt;p&gt;Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?&lt;/p&gt;
&lt;p&gt;Input Specification:&lt;br/&gt;Each input file contains one test case. For each case, the first line gives a positive integer N (≤100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.&lt;/p&gt;
&lt;p&gt;Output Specification:&lt;br/&gt;For each test case, print in the first line either &quot;Insertion Sort&quot; or &quot;Heap Sort&quot; to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resulting sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sample Input 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;10&lt;br/&gt;3 1 2 8 7 5 9 4 6 0&lt;br/&gt;1 2 3 7 8 5 9 4 6 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Sample Output 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Insertion Sort&lt;br/&gt;1 2 3 5 7 8 9 4 6 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Sample Input 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;10&lt;br/&gt;3 1 2 8 7 5 9 4 6 0&lt;br/&gt;6 4 5 1 0 3 2 7 8 9&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Sample Output 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Heap Sort&lt;br/&gt;5 4 3 1 0 2 6 7 8 9&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题解：&lt;/strong&gt;&lt;br/&gt;根据插入排序的性质，可以很容易判断出插入排序。&lt;br/&gt;首先从0开始扫描，直到扫描到逆序的点，接着从逆序点p开始向后扫描到n-1，如果array1和array2都一样，说明一定是插入排序，否则为堆排序。&lt;br/&gt;对插入排序，再对逆序的位置插一次。&lt;br/&gt;对堆排序，先从后扫描直到小于堆顶，交换2个元素，并且调整堆，即可获得下一次结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstdbool&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#define MAXSIZE 101
using namespace std;

//调整堆
void Adjustment(int array[], int n, int k) {
        //下标K代表数组元素array[k]空缺
        int temp = array[k];
        for (int j = k * 2 + 1; j &amp;lt; n; j = 2 * j + 1)
        {
                if (j + 1 &amp;lt; n &amp;amp;&amp;amp; array[j + 1] &amp;gt; array[j]) {
                        j++;
                }
                if (array[j] &amp;gt; temp) {
                        array[k] = array[j];
                        k = j;
                }
                else {
                        break;
                }
        }
        array[k] = temp;
}
//打印数组
void PrintArray(int arr[],int n) {
        bool isf = true;
        for (int i = 0; i &amp;lt; n; i++)
        {
                if (isf) {
                        printf(&quot;%d&quot;, arr[i]);
                        isf = false;
                }
                else {
                        printf(&quot; %d&quot;, arr[i]);
                }
        }
}
int main() {
        int array1[MAXSIZE];
        int array2[MAXSIZE];
        int n;
        //read array
        scanf(&quot;%d&quot;, &amp;amp;n);
        for (int i = 0; i &amp;lt; n; i++)
        {
                scanf(&quot;%d&quot;, &amp;amp;array1[i]);
        }
        for (int i = 0; i &amp;lt; n; i++)
        {
                scanf(&quot;%d&quot;, &amp;amp;array2[i]);
        }
        //check insertion or heap sort
        int p;
        for (p = 0; p &amp;lt; n-1; p++)
        {
                if (array2[p] &amp;gt; array2[p + 1]) {
                        break;
                }
        }
        bool isinsertion = true;
        for (int i = p+1; i &amp;lt; n; i++)
        {
                if (array1[i] != array2[i]) {
                        isinsertion = false;
                        break;
                }
        }
        //get next step sort
        if (isinsertion) {
                int temp = array2[p+1];
                int j = 0;
                for (j = p + 1; j &amp;gt; 0 &amp;amp;&amp;amp; array2[j - 1] &amp;gt; temp; j--)
                {
                        array2[j] = array2[j - 1];
                }
                array2[j] = temp;
                printf(&quot;Insertion Sort\n&quot;);
        }
        else {
                for (int i = n-1; i &amp;gt;= 0; i--)
                {
                        if (array2[0] &amp;gt; array2[i]) {
                                int temp = array2[i];
                                array2[i] = array2[0];
                                array2[0] = temp;
                                Adjustment(array2, i, 0);
                                break;
                        }
                }
                printf(&quot;Heap Sort\n&quot;);
        }
        PrintArray(array2, n);
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 12 Dec 2020 18:49:00 +0000</pubDate>
<dc:creator>W&amp;B</dc:creator>
<og:description>#排序 ##简单排序(差劲排序) 下面的几种排序都是非常简单容易实现的，不过也有着相应的问题，他们在正常的情况下排序，时间复杂度几乎都是$O(N2)$。 ###冒泡排序 冒泡冒泡，大的沉底，小的浮起。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cs-Miscellaneous/p/14127791.html</dc:identifier>
</item>
<item>
<title>SpringBoot如何利用Actuator来监控应用？ - 天乔巴夏丶</title>
<link>http://www.cnblogs.com/summerday152/p/14127781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/14127781.html</guid>
<description>&lt;h2 id=&quot;actuator是什么？&quot;&gt;Actuator是什么？&lt;/h2&gt;
&lt;blockquote readability=&quot;0.80357142857143&quot;&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready&quot; target=&quot;_blank&quot;&gt;Spring Boot Actuator: Production-ready Features&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先从官网摘几句文绉绉的解释：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SpringBoot可以帮助你再将应用程序推向生产环境时对其进行监视和管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;你可以选择使用http断点或JMX来管理和监视应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;审计【auditing】、健康【health】和指标收集【metrics gathering】可以自动应用到你的应用程序中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结一下就是：Actuator就是用来监控你的应用程序的。&lt;/p&gt;
&lt;h2 id=&quot;快速开始&quot;&gt;快速开始&lt;/h2&gt;
&lt;h3 id=&quot;引入依赖&quot;&gt;引入依赖&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;        &amp;lt;!--Actuator--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--Spring MVC 自动化配置--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说这两个依赖都是相互配合的。&lt;/p&gt;
&lt;h3 id=&quot;yml与自动配置&quot;&gt;yml与自动配置&lt;/h3&gt;
&lt;p&gt;下面是一段yml的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 8081
management:
  endpoints:
    web:
      base-path: /actuator # Actuator 提供的 API 接口的根目录
      exposure:
        include: '*'  # 需要开放的端点
        exclude: # 需要排除的端点
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;management.endpoints.web&lt;/code&gt;对应的配置类是：&lt;code&gt;org.springframework.boot.actuate.autoconfigure.endpoint.web.WebEndpointProperties&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;相关的自动配置在&lt;code&gt;org.springframework.boot.actuate.autoconfigure.endpoint.web.WebEndpointAutoConfiguration&lt;/code&gt;中完成，感兴趣的同学可以查看一下源码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;basePath是Actuator提供的API接口的根目录，默认配置就是&lt;code&gt;/actuator&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Exposure.include表示需要开放的端点，默认只打开&lt;code&gt;health&lt;/code&gt;和&lt;code&gt;info&lt;/code&gt;两个断点，设置&lt;code&gt;*&lt;/code&gt;可以开放所有端点 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Exposure.include表示排除的端点，设置&lt;code&gt;*&lt;/code&gt;为排除所有的端点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;主程序类&quot;&gt;主程序类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
public class SpringBootActuatorApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringBootActuatorApplication.class, args);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;访问&lt;code&gt;http://localhost:8081/actuator/health&lt;/code&gt;，得到应用的健康信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  status: &quot;UP&quot;  // 开启
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;endpoints&quot;&gt;Endpoints&lt;/h2&gt;
&lt;p&gt;由于我们设置开放了所有的Endpoints，启动程序时，我们能够看到控制台输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-plain&quot;&gt;[  restartedMain] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 13 endpoint(s) beneath base path '/actuator'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说的很清楚，总共暴露了内置的13个端点，这些端点，SpringBoot文档已经交代地非常详细啦。&lt;/p&gt;
&lt;p&gt;其实内置的端点不止13个，官方文档说：每个端点可以被&lt;code&gt;enabled or disabled&lt;/code&gt;和&lt;code&gt;exposed over HTTP or JMX&lt;/code&gt;。只有当端点同时enabled和exposed的时候才可用，内置的端点也只有在自动配置生效的时候才可用。&lt;/p&gt;
&lt;p&gt;大多数的应用程序会选择HTTP暴露端点，我们可以通过&lt;code&gt;/actuator/health&lt;/code&gt;访问ID为&lt;code&gt;health&lt;/code&gt;的端点。&lt;/p&gt;
&lt;h3 id=&quot;官方列举的所有端点列表&quot;&gt;官方列举的所有端点列表&lt;/h3&gt;
&lt;p&gt;JMX和web共有的&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;auditevents&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示当前应用程序的审计事件信息，需要 &lt;code&gt;AuditEventRepository&lt;/code&gt; bean.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;beans&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;展示你应用程序中Spring Beans的完整列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;caches&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示可用缓存信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;conditions&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示自动装配类的状态及是否匹配&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;configprops&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示所有&lt;code&gt;@ConfigurationProperties&lt;/code&gt;列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;env&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示&lt;code&gt;ConfigurableEnvironment&lt;/code&gt;中的属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;flyway&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示Flyway数据库迁移信息，需要一个或多个 &lt;code&gt;Flyway&lt;/code&gt; beans&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;health&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示应用的健康信息（未认证只显示status，认证显示全部信息详情）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;httptrace&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示HTTP跟踪信息（默认显示最后100个HTTP请求 - 响应交换），需要一个 &lt;code&gt;HttpTraceRepository&lt;/code&gt; bean.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;info&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示任意的应用信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;integrationgraph&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示Spring Integration图，需要 &lt;code&gt;spring-integration-core&lt;/code&gt;依赖&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;loggers&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示和修改应用程序中日志记录器的配置。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;liquibase&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;展示Liquibase 数据库迁移，需要一个或多个 &lt;code&gt;Liquibase&lt;/code&gt; beans.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;metrics&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;展示当前应用的 metrics 信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;mappings&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示所有&lt;code&gt;@RequestMapping&lt;/code&gt; 路径集列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;scheduledtasks&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示应用程序中的计划任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;sessions&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;允许从Spring会话支持的会话存储中检索和删除用户会话。 需要一个 &lt;code&gt;Servlet-based web application&lt;/code&gt; using Spring Session.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;shutdown&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;允许应用以优雅的方式关闭（默认情况下不启用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;startup&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示由&lt;code&gt;ApplicationStartup&lt;/code&gt;收集的启动步骤. 将 &lt;code&gt;SpringApplication&lt;/code&gt; 配置为&lt;code&gt;BufferingApplicationStartup&lt;/code&gt;.&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;threaddump&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;执行一个线程dump&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果你的是web应用 (Spring MVC, Spring WebFlux, or Jersey)，你可以使用下面这些额外的端点:&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;heapdump&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回一个 &lt;code&gt;hprof&lt;/code&gt; 堆转储文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;jolokia&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;通过HTTP公开JMXbean 当Jolokia在类路径上时，不适用于WebFlux). 需要 &lt;code&gt;jolokia-core&lt;/code&gt;依赖&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;logfile&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回日志文件的内容(如果 &lt;code&gt;logging.file.name&lt;/code&gt; 或&lt;code&gt;logging.file.path&lt;/code&gt; 属性已经被设置) 支持使用HTTP&lt;code&gt;range&lt;/code&gt;标头来检索部分日志文件的内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;prometheus&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;以Prometheus服务器可以抓取的格式公开指标。 需要依赖于&lt;code&gt;micrometer-registry-prometheus&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;启动端点&quot;&gt;启动端点&lt;/h3&gt;
&lt;p&gt;如果你希望启动某个端点，你可以按照&lt;code&gt;management.endpoint.&amp;lt;id&amp;gt;.enabled&lt;/code&gt;的配置启动，以&lt;code&gt;shutdown&lt;/code&gt;端点为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;management:
  endpoint:
    shutdown:
      enabled: true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你只希望启动某个端点，你可以向下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;management:
  endpoints:
    enabled-by-default: false # 不启用默认配置
  endpoint:
    info:
      enabled: true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个示例，只会启用info端点。&lt;/p&gt;
&lt;h3 id=&quot;暴露端点&quot;&gt;暴露端点&lt;/h3&gt;
&lt;p&gt;端点可能会包含铭感信息，考虑暴露的时候应当慎重考虑。&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;code&gt;include&lt;/code&gt;和&lt;code&gt;exclude&lt;/code&gt;属性来控制端点是否需要暴露。下面是两个例子&lt;/p&gt;
&lt;p&gt;一、不让JMX暴露所有端点，只让它暴露&lt;code&gt;health&lt;/code&gt;和&lt;code&gt;info&lt;/code&gt;两个端点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;management:
  endpoints:
    jmx:
      exposure:
        include: &quot;health,info&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二、暴露web除&lt;code&gt;env&lt;/code&gt;和&lt;code&gt;beans&lt;/code&gt;之外的所有端点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;
        exclude: &quot;env,beans&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;management.endpoints.web.exposure.include=*  
management.endpoints.web.exposure.exclude=env,beans
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置端点&quot;&gt;配置端点&lt;/h3&gt;
&lt;p&gt;端点将会自动缓存对不带任何参数的读取操作的响应。你可以使用&lt;code&gt;cache.time-to-live&lt;/code&gt;属性配置。&lt;/p&gt;
&lt;p&gt;以下示例将Bean端点的缓存的生存时间设置为10秒。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;management:
  endpoint:
    beans:
      cache:
        time-to-live: &quot;10s&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;发现页面&quot;&gt;发现页面&lt;/h3&gt;
&lt;p&gt;默认你可以访问&lt;code&gt;/actuator&lt;/code&gt;页面获得所有的端点信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  _links: {
    self: {
      href: &quot;http://localhost:8081/actuator&quot;,
      templated: false
    },
    health: {
      href: &quot;http://localhost:8081/actuator/health&quot;,
      templated: false
    },
    health-path: {
      href: &quot;http://localhost:8081/actuator/health/{*path}&quot;,
      templated: true
    },
    info: {
      href: &quot;http://localhost:8081/actuator/info&quot;,
      templated: false
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;跨域支持&quot;&gt;跨域支持&lt;/h3&gt;
&lt;p&gt;默认情况下，CORS支持是禁用的，并且仅在设置了&lt;code&gt;management.endpoints.web.cors.allowed-origins&lt;/code&gt;属性后才启用。 以下配置允许来自example.com域的GET和POST调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;management:
  endpoints:
    web:
      cors:
        allowed-origins: &quot;https://example.com&quot;
        allowed-methods: &quot;GET,POST&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整的选项可以查看：&lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.1/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/CorsEndpointProperties.java&quot; target=&quot;_blank&quot;&gt;CorsEndpointProperties&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现一个定义的端点&quot;&gt;实现一个定义的端点&lt;/h2&gt;
&lt;p&gt;我们直接来看一个例子吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component  // 让Spring容器管理
@Endpoint(id = &quot;myEndPoint&quot;) //web和jmx公用， @WebEndpoint表示指定web
public class MyEndpoint {

    Runtime runtime = Runtime.getRuntime();

    @ReadOperation // 读操作
    public Map&amp;lt;String, Object&amp;gt; getData() {
        Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&quot;available-processors&quot;, runtime.availableProcessors());
        map.put(&quot;free-memory&quot;, runtime.freeMemory());
        map.put(&quot;max-memory&quot;, runtime.maxMemory());
        map.put(&quot;total-memory&quot;, runtime.totalMemory());
        return map;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Component&lt;/code&gt;表明让这个bean给Spring容器管理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Endpoint&lt;/code&gt;标注这是个端点，类似的还有&lt;code&gt;@WebEndpoint&lt;/code&gt;标注的是特指web程序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;id = &quot;myEndPoint&quot;&lt;/code&gt;限制访问端点的路径：&lt;code&gt;/actuator/myEndPoint&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ReadOperation&lt;/code&gt;规定HTTP请求的方法为GET，&lt;code&gt;@ReadOperation&lt;/code&gt;为POST，&lt;code&gt;@DeleteOperation&lt;/code&gt;为DELETE。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来我们测试一下，再测试之前，不要忘了yml中启动设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 8081

management:
  endpoints:
    web:
      exposure:
        include: '*' # 需要开放的端点。默认值只打开 health 和 info 两个端点。通过设置 * 
    enabled-by-default: false
  endpoint:
    myEndPoint:
      enabled: true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们暂时关闭其他所有的端点，只关注myEndPoint端点，接着启动程序，访问：&lt;code&gt;http://localhost:8081/actuator/myEndPoint&lt;/code&gt;，获得json信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    max-memory: 3787980800,
    free-memory: 235775968,
    available-processors: 4,
    total-memory: 298844160
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上如果是用于SpringMVC或Spring WebFlux，我们可以使用&lt;code&gt;@RestControllerEndpoint&lt;/code&gt;或&lt;code&gt;@ControllerEndpoint&lt;/code&gt;注解，定义一个更符合我们平时web开发模式的端点，你可以看一下下面这个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
@RestControllerEndpoint(id = &quot;web&quot;)
public class MyWebEndPoint {
    @GetMapping(&quot;/&quot;)
    public Map&amp;lt;String, Object&amp;gt; getData() {
                // ...
        return map;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;health端点&quot;&gt;Health端点&lt;/h2&gt;
&lt;p&gt;端点这么多，我们挑几个学习一下，&lt;code&gt;health&lt;/code&gt;作为默认开放的端点之一，还是需要好好了解一下的。&lt;/p&gt;
&lt;h3 id=&quot;设置何时显示信息&quot;&gt;设置何时显示信息&lt;/h3&gt;
&lt;p&gt;你可以使用得到的健康信息去检查你的应用程序，暴露的health信息依赖于下面两个属性配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-plain&quot;&gt;management.endpoint.health.show-details
management.endpoint.health.show-components
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个属性可以设置的值如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;never&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;永远不显示&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;when-authorized&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;需要授权，通过 &lt;code&gt;management.endpoint.health.roles&lt;/code&gt;配置&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;always&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对所有用户显示&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;health端点通过健康指示器&lt;code&gt;HealthIndicator&lt;/code&gt;获取不同的资源的健康信息，且Autuator内置了多个HealthIndicator的实现，太多啦太多啦，如果需要可以看看官网 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready-health-indicators&quot; target=&quot;_blank&quot;&gt;Auto-configured HealthIndicators&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外，如果你想启用或者禁用指定的指示器，你可以配置&lt;code&gt;management.health.key.enabled&lt;/code&gt;，key需要被替换，官网表格上有。&lt;/p&gt;
&lt;p&gt;如果你想设置全部的，你可以配置&lt;code&gt;management.health.defaults.enabled&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置顺序&quot;&gt;设置顺序&lt;/h3&gt;
&lt;p&gt;你可以通过以下设置显示顺序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;management:
  endpoint:
    health:
      status:
        order: &quot;fatal,down,out-of-service,unknown,up&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置响应码&quot;&gt;设置响应码&lt;/h3&gt;
&lt;p&gt;响应码反应了总体健康状态。默认情况下，&lt;code&gt;OUT_OF_SERVICE&lt;/code&gt;和&lt;code&gt;DOWN&lt;/code&gt;的映射为503，其他状态为200。你可以按照下面的方式设置映射：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;management:
  endpoint:
    health:
      status:
        http-mapping:
          down: 503
          fatal: 503
          out-of-service: 503
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义健康信息&quot;&gt;自定义健康信息&lt;/h3&gt;
&lt;p&gt;纵使，Actuator已经提供了许多内置实现，总会满足不了我们的需求，那如何去自定义呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注册实现HealthIndicator接口的Spring Bean。&lt;/li&gt;
&lt;li&gt;提供health()方法的实现并返回健康响应，包括状态和其他需要显示的详细信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下代码展示了一个案例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;
import java.util.Random;

@Component
public class MyHealthIndicator implements HealthIndicator {

    @Override
    public Health health() {
        // perform some specific health check
        boolean check = check();
        if (!check) {
            return Health.down().withDetail(&quot;Error Code&quot;, 0).build();
        }
        return Health.up().build();
    }

    private boolean check() {
        return new Random().nextBoolean();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;id就是bena的名称去掉HealthIndicator后缀，这里id就是my。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看看相关的yml怎么配置？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;management:
  endpoints:
    web:
      exposure:
        include: '*' # 需要开放的端点。默认值只打开 health 和 info 两个端点。通过设置 * ，可以开放所有端点。
    enabled-by-default: false
  endpoint:
    health:
      enabled: true
      show-details: always # 何时显示完整的健康信息
      show-components: always
      status:
        http-mapping: # 设置不同健康状态对应的响应状态码
          DOWN: 503
        order: FATAL, DOWN, OUT_OF_SERVICE, UP, UNKNOWN # 状态排序
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试一下，访问：&lt;code&gt;/actuator/health&lt;/code&gt;，可以尝试多点几次，会出现UP和DOWN的情况，得到以下信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  status: &quot;DOWN&quot;,
  components: {
    diskSpace: {
      status: &quot;UP&quot;,
      details: {
        total: 267117391872,
        free: 130840469504,
        threshold: 10485760,
        exists: true
      }
    },
    my: {
      status: &quot;DOWN&quot;,
      details: {
        Error Code: 0
      }
    },
    ping: {
      status: &quot;UP&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;my对应的就是我们自定义的MyHealthIndicator，里面详细的信息有：状态status，信息details。&lt;/li&gt;
&lt;li&gt;diskSpace对应DiskSpaceHealthIndicator，ping对应的是PingHealthIndicator。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他的端点，感兴趣的小伙伴可以去到官网一一测试，总之，通过这些Actuator提供的端点，我们很容易就能够监控管理我们的应用程序。&lt;/p&gt;
&lt;h2 id=&quot;源码下载&quot;&gt;源码下载&lt;/h2&gt;
&lt;p&gt;本文内容均为对优秀博客及官方文档总结而得，原文地址均已在文中参考阅读处标注。最后，文中的代码样例已经全部上传至Gitee：&lt;a href=&quot;https://gitee.com/tqbx/springboot-samples-learn&quot; target=&quot;_blank&quot;&gt;https://gitee.com/tqbx/springboot-samples-learn&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;参考阅读&quot;&gt;参考阅读&lt;/h2&gt;
</description>
<pubDate>Sat, 12 Dec 2020 18:04:00 +0000</pubDate>
<dc:creator>天乔巴夏丶</dc:creator>
<og:description>Actuator是什么？ 官网：Spring Boot Actuator: Production-ready Features 先从官网摘几句文绉绉的解释： SpringBoot可以帮助你再将应用程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/14127781.html</dc:identifier>
</item>
<item>
<title>容器编排系统之Kubernetes基础入门 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14126750.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14126750.html</guid>
<description>&lt;p&gt;　　一、kubernetes简介&lt;/p&gt;
&lt;p&gt;　　1、什么是kubernetes？它是干什么用的？&lt;/p&gt;
&lt;p&gt;　　kubernetes是google公司用go语言开发的一套容器编排系统，简称k8s；它主要用于容器编排；所谓容器编排简单的我们可以理解为管理容器；这个有点类似openstack，不同的是openstack是用来管理虚拟机，而k8s中是管理的pod（所谓pod就是容器的一个外壳，里面可以跑一个或多个容器，可以理解为pod就是将一个或多个容器逻辑的组织在一起）；k8s除了可以全生命周期的管理pod，它还可以实现pod的自动化部署，自动修复以及动态的扩缩容等功能；&lt;/p&gt;
&lt;p&gt;　　2、k8s架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201212204107100-311079036.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：k8s是master/node模型，master是整个k8s的管理端，其上主要运行etcd，api server ，scheduler，controllermanager以及网络相关插件；其中etcd是一个kv键值存储数据库，主要存放k8s中所有配置信息以及pod状态信息，一旦etcd宕机，k8s整个系统将不可用；apiserver主要用来接收客户端请求，也是k8s中唯一的入口；用户的所有管理操作都是将请求发送给apiserver；scheduler主要用来调度用户请求，比如用户要在k8s系统上运行一个pod，至于这个pod该运行在那个node节点，这个就需要scheduler的调度；controllermanager主要用来管理以及监控pod状态；对于scheduler调度的结果，controlmanager就负责让对应节点上的对应pod精准处于调度的状态；node的节点是k8s的工作节点，主要用于运行pod；node节点主要运行的应用有docker，kubelet,kube-proxy；其中docker是用来运行容器的，kubelet主要负责执行master端controllermanager下发的任务；kube-proxy主要用来生成pod网络相关iptables或ipvs规则的；&lt;/p&gt;
&lt;p&gt;　　3、k8s工作过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201212211934810-2047271360.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：k8s工作过程如上图所示，首先用户将请求通过https发送给apiserver，apiserver收到请求后，首先要验证客户端证书，如果通过验证，然后再检查用户请求的资源是否满足对应api请求的语法，满足则就把对应的请求资源以及资源状态信息存放在etcd中；scheduler和controllermanager以及kubelet这三个组件会一直监视着apiserver上的资源变动，一旦发现有合法的请求进来，首先scheduler会根据用户请求的资源，来评判该资源该在那个节点上创建，然后scheduler把对应的调度信息发送给apiserver，然后controllermanager结合scheduler的调度信息，把对应创建资源的方法也发送给apiserver；最后是各节点上的kubelet通过scheduler的调度信息来判断对应资源是否在本地执行，如果是，它就把controllermanager发送给apiserver的创建资源的方法在本地执行，把对应的资源在本地跑起来；后续controllermanager会一直监视着对应的资源是否健康，如果对应资源不健康，它会尝试重启资源，或者重建资源，让对应资源处于我们定义的状态；&lt;/p&gt;
&lt;p&gt;　　二、k8s集群搭建&lt;/p&gt;
&lt;p&gt;　　部署说明&lt;/p&gt;
&lt;p&gt;　　部署k8s集群的方式有两种，一种是在各节点上把对应的组件运行为容器的形式；第二种是将各组件运行为守护进程的方式；对于不同的环境我们部署的方式也有不同，对于测试环境，我们可以使用单master节点，单etcd实例，node节点按需而定；生产环境首先是etcd要高可用，我们要创建etcd高可用集群，一般创建3个或5个或7个节点；其次master也要高可用，高可用master我们需要注意apiserver是无状态的可多实例，前端使用nginx或haproxy做调度即可；对于scheduler和controller这两个组件各自只能有一个活动实例，如果是多个实例，其余的只能是备用；&lt;/p&gt;
&lt;p&gt;　　测试环境部署k8s，将各组件运行为容器&lt;/p&gt;
&lt;p&gt;　　环境说明&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;主机名&lt;/td&gt;
&lt;td&gt;IP地址&lt;/td&gt;
&lt;td&gt;角色&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;master01.k8s.org&lt;/td&gt;
&lt;td&gt;192.168.0.41&lt;/td&gt;
&lt;td&gt;master&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node01.k8s.org&lt;/td&gt;
&lt;td&gt;192.168.0.44&lt;/td&gt;
&lt;td&gt;node01&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node02.k8s.org&lt;/td&gt;
&lt;td&gt;192.168.0.45&lt;/td&gt;
&lt;td&gt;node02&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;node03.k8s.org&lt;/td&gt;
&lt;td&gt;192.168.0.46&lt;/td&gt;
&lt;td&gt;node03&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;






&lt;p&gt;　　各节点主机名解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.0.99 time.test.org time-node
192.168.0.41  master01 master01.k8s.org
192.168.0.42  master02 master02.k8s.org
192.168.0.43  master03 master03.k8s.org
192.168.0.44  node01 node01.k8s.org
192.168.0.45  node02 node02.k8s.org
192.168.0.46  node03 node03.k8s.org
[root@master01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　各节点时间同步&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# grep server /etc/chrony.conf
# Use public servers from the pool.ntp.org project.
server time.test.org iburst
# Serve time even if not synchronized to any NTP server.
[root@master01 ~]# chronyc sources             
210 Number of sources = 1
MS Name/IP address         Stratum Poll Reach LastRx Last sample               
===============================================================================
^~ time.test.org                 3   6   377    56   -6275m[ -6275m] +/-   20ms
[root@master01 ~]# ssh node01 'chronyc sources'
210 Number of sources = 1
MS Name/IP address         Stratum Poll Reach LastRx Last sample               
===============================================================================
^~ time.test.org                 3   6   377     6   -6275m[ -6275m] +/-   20ms
[root@master01 ~]# ssh node02 'chronyc sources' 
210 Number of sources = 1
MS Name/IP address         Stratum Poll Reach LastRx Last sample               
===============================================================================
^~ time.test.org                 3   6   377    41   -6275m[ -6275m] +/-   20ms
[root@master01 ~]# ssh node03 'chronyc sources' 
210 Number of sources = 1
MS Name/IP address         Stratum Poll Reach LastRx Last sample               
===============================================================================
^~ time.test.org                 3   6   377    35   -6275m[ -6275m] +/-   20ms
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：有关时间同步服务器的搭建请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12079927.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12079927.html&lt;/a&gt;；ssh互信请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/11783371.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/11783371.html&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;　　各节点关闭selinux&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat /etc/selinux/config 

# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
#     enforcing - SELinux security policy is enforced.
#     permissive - SELinux prints warnings instead of enforcing.
#     disabled - No SELinux policy is loaded.
SELINUX=disabled
# SELINUXTYPE= can take one of three two values:
#     targeted - Targeted processes are protected,
#     minimum - Modification of targeted policy. Only selected processes are protected. 
#     mls - Multi Level Security protection.
SELINUXTYPE=targeted 


[root@master01 ~]# getenforce 
Disabled
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：将/etc/selinux/config中的SELINUX=enforcing修改成SELINUX=disabled，然后重启主机或者执行setenforce 0；&lt;/p&gt;
&lt;p&gt;　　关闭iptabels服务或firewalld服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# systemctl status firewalld
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
   Active: inactive (dead)
     Docs: man:firewalld(1)
[root@master01 ~]# iptables -nvL
Chain INPUT (policy ACCEPT 650 packets, 59783 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination         

Chain OUTPUT (policy ACCEPT 503 packets, 65293 bytes)
 pkts bytes target     prot opt in     out     source               destination         
[root@master01 ~]# ssh node01 'systemctl status firewalld'
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
   Active: inactive (dead)
     Docs: man:firewalld(1)
[root@master01 ~]# ssh node02 'systemctl status firewalld' 
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
   Active: inactive (dead)
     Docs: man:firewalld(1)
[root@master01 ~]# ssh node03 'systemctl status firewalld' 
● firewalld.service - firewalld - dynamic firewall daemon
   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)
   Active: inactive (dead)
     Docs: man:firewalld(1)
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：将firewalld服务停掉并设置为开机禁用；并确保iptables规则表中没有任何规则；&lt;/p&gt;
&lt;p&gt;　　各节点下载docker仓库配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo
--2020-12-08 14:04:29--  https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 182.140.140.242, 110.188.26.241, 125.64.1.228, ...
Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|182.140.140.242|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 2640 (2.6K) [application/octet-stream]
Saving to: ‘/etc/yum.repos.d/docker-ce.repo’

100%[======================================================================&amp;gt;] 2,640       --.-K/s   in 0s      

2020-12-08 14:04:30 (265 MB/s) - ‘/etc/yum.repos.d/docker-ce.repo’ saved [2640/2640]

[root@master01 ~]# ssh node01 'wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo'
--2020-12-08 14:04:42--  https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 182.140.139.60, 125.64.1.228, 118.123.2.185, ...
Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|182.140.139.60|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 2640 (2.6K) [application/octet-stream]
Saving to: ‘/etc/yum.repos.d/docker-ce.repo’

     0K ..                                                    100%  297M=0s

2020-12-08 14:04:42 (297 MB/s) - ‘/etc/yum.repos.d/docker-ce.repo’ saved [2640/2640]

[root@master01 ~]# ssh node02 'wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo'
--2020-12-08 14:04:38--  https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 182.140.139.59, 118.123.2.183, 182.140.140.238, ...
Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|182.140.139.59|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 2640 (2.6K) [application/octet-stream]
Saving to: ‘/etc/yum.repos.d/docker-ce.repo’

     0K ..                                                    100%  363M=0s

2020-12-08 14:04:38 (363 MB/s) - ‘/etc/yum.repos.d/docker-ce.repo’ saved [2640/2640]

[root@master01 ~]# ssh node03 'wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo'
--2020-12-08 14:04:43--  https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
Resolving mirrors.aliyun.com (mirrors.aliyun.com)... 118.123.2.184, 182.140.140.240, 182.140.139.63, ...
Connecting to mirrors.aliyun.com (mirrors.aliyun.com)|118.123.2.184|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 2640 (2.6K) [application/octet-stream]
Saving to: ‘/etc/yum.repos.d/docker-ce.repo’

     0K ..                                                    100%  218M=0s

2020-12-08 14:04:43 (218 MB/s) - ‘/etc/yum.repos.d/docker-ce.repo’ saved [2640/2640]

[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建kubernetes仓库配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 yum.repos.d]# cat kubernetes.repo 
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
[root@master01 yum.repos.d]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　复制kubernetes仓库配置文件到各node节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 yum.repos.d]# scp kubernetes.repo node01:/etc/yum.repos.d/
kubernetes.repo                                                               100%  276    87.7KB/s   00:00    
[root@master01 yum.repos.d]# scp kubernetes.repo node02:/etc/yum.repos.d/
kubernetes.repo                                                               100%  276    13.6KB/s   00:00    
[root@master01 yum.repos.d]# scp kubernetes.repo node03:/etc/yum.repos.d/
kubernetes.repo                                                               100%  276   104.6KB/s   00:00    
[root@master01 yum.repos.d]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在各节点安装docker-ce，kubectl，kubelet，kubeadm&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
yum install -y docker-ce kubectl kubeadm kubelet
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　编辑docker unitfile文件，加上启动docker后执行iptables -P FORWARD ACCEPT&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201212225025693-275094443.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　复制docker.service到各节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# scp /usr/lib/systemd/system/docker.service node01:/usr/lib/systemd/system/docker.service
docker.service                                                                100% 1764   220.0KB/s   00:00    
[root@master01 ~]# scp /usr/lib/systemd/system/docker.service node02:/usr/lib/systemd/system/docker.service
docker.service                                                                100% 1764   359.1KB/s   00:00    
[root@master01 ~]# scp /usr/lib/systemd/system/docker.service node03:/usr/lib/systemd/system/docker.service
docker.service                                                                100% 1764   792.3KB/s   00:00    
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置docker加速器&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# mkdir /etc/docker
[root@master01 ~]# cd /etc/docker
[root@master01 docker]# cat &amp;gt;&amp;gt; daemon.json &amp;lt;&amp;lt; EOF
&amp;gt; {
&amp;gt; &quot;registry-mirrors&quot;: [&quot;https://cyr1uljt.mirror.aliyuncs.com&quot;]
&amp;gt; }
&amp;gt; EOF
[root@master01 docker]# cat daemon.json 
{
&quot;registry-mirrors&quot;: [&quot;https://cyr1uljt.mirror.aliyuncs.com&quot;]
}
[root@master01 docker]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在各节点上创建/etc/docker目录，并复制master端上daemon.json文件到各节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 docker]# ssh node01 'mkdir /etc/docker'
[root@master01 docker]# ssh node02 'mkdir /etc/docker' 
[root@master01 docker]# ssh node03 'mkdir /etc/docker' 
[root@master01 docker]# scp daemon.json node01:/etc/docker/
daemon.json                                                                   100%   65    30.6KB/s   00:00    
[root@master01 docker]# scp daemon.json node02:/etc/docker/
daemon.json                                                                   100%   65    52.2KB/s   00:00    
[root@master01 docker]# scp daemon.json node03:/etc/docker/
daemon.json                                                                   100%   65    17.8KB/s   00:00    
[root@master01 docker]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　各节点启动docker，并设置为开机启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 docker]# systemctl enable docker --now
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.
[root@master01 docker]# ssh node01 'systemctl enable docker --now'
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.
[root@master01 docker]# ssh node02 'systemctl enable docker --now' 
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.
[root@master01 docker]# ssh node03 'systemctl enable docker --now' 
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.
[root@master01 docker]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证各节点docker是加速器是否应用？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 docker]# docker info |grep aliyun
  https://cyr1uljt.mirror.aliyuncs.com/
[root@master01 docker]# ssh node01 'docker info |grep aliyun'
  https://cyr1uljt.mirror.aliyuncs.com/
[root@master01 docker]# ssh node02 'docker info |grep aliyun' 
  https://cyr1uljt.mirror.aliyuncs.com/
[root@master01 docker]# ssh node03 'docker info |grep aliyun' 
  https://cyr1uljt.mirror.aliyuncs.com/
[root@master01 docker]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在对应节点执行docker info命令能够看到对应的加速器地址，说明加速器应用成功；&lt;/p&gt;
&lt;p&gt;　　验证所有节点iptables FORWARD链默认规则是否是ACCEPT&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 docker]# iptables -nvL|grep FORWARD
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
[root@master01 docker]# ssh node01 'iptables -nvL|grep FORWARD'
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
[root@master01 docker]# ssh node02 'iptables -nvL|grep FORWARD' 
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
[root@master01 docker]# ssh node03 'iptables -nvL|grep FORWARD' 
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
[root@master01 docker]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　添加内核参数配置文件，并复制配置文件到其他节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
[root@master01 ~]# scp /etc/sysctl.d/k8s.conf node01:/etc/sysctl.d/k8s.conf
k8s.conf                                                                      100%   79    25.5KB/s   00:00    
[root@master01 ~]# scp /etc/sysctl.d/k8s.conf node02:/etc/sysctl.d/k8s.conf
k8s.conf                                                                      100%   79    24.8KB/s   00:00    
[root@master01 ~]# scp /etc/sysctl.d/k8s.conf node03:/etc/sysctl.d/k8s.conf
k8s.conf                                                                      100%   79    20.9KB/s   00:00    
[root@master01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　应用内核参数使其生效&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# sysctl -p /etc/sysctl.d/k8s.conf       
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
[root@master01 ~]# ssh node01 'sysctl -p /etc/sysctl.d/k8s.conf'    
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
[root@master01 ~]# ssh node02 'sysctl -p /etc/sysctl.d/k8s.conf' 
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
[root@master01 ~]# ssh node03 'sysctl -p /etc/sysctl.d/k8s.conf' 
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置kubelet，让其忽略swap开启报错&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat /etc/sysconfig/kubelet
KUBELET_EXTRA_ARGS=&quot;--fail-swap-on=false&quot;
[root@master01 ~]# scp /etc/sysconfig/kubelet node01:/etc/sysconfig/kubelet
kubelet                                                                       100%   42    12.2KB/s   00:00    
[root@master01 ~]# scp /etc/sysconfig/kubelet node02:/etc/sysconfig/kubelet
kubelet                                                                       100%   42    16.2KB/s   00:00    
[root@master01 ~]# scp /etc/sysconfig/kubelet node03:/etc/sysconfig/kubelet
kubelet                                                                       100%   42    11.2KB/s   00:00    
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看kubelet版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# rpm -q kubelet 
kubelet-1.20.0-0.x86_64
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　初始化master节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubeadm init --pod-network-cidr=&quot;10.244.0.0/16&quot; \
&amp;gt; --kubernetes-version=&quot;v1.20.0&quot; \
&amp;gt; --image-repository=&quot;registry.aliyuncs.com/google_containers&quot; \
&amp;gt; --ignore-preflight-errors=Swap
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：初始化master需要注意，默认不指定镜像仓库地址它会到k8s.gcr.io这个仓库中下载对应组件的镜像；gcr.io这个地址是google的仓库，在国内一般是无法正常连接；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201212231226408-1493665158.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：一定要看到初始化成功的提示才表示master初始化没有问题；这里还需要将最后的kubeadm join 这条命令记录下来，后续加node节点需要用到这个命令；&lt;/p&gt;
&lt;p&gt;　　在当前用户家目录下创建.kube目录，并复制kubectl配置文件到.kube目录下命名为config&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# mkdir -p $HOME/.kube
[root@master01 ~]# cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：复制配置文件的主要原因是我们要在master端用kubectl命令来管理集群，配置文件中包含证书信息以及对应master的地址，默认执行kubctl命令会在当前用户的家目录查找config配置文件，只有当kubectl验证成功后才可以正常管理集群；如果不是root用户，是其他普通用户，还需要将config文件的属主和属组修改成对应的用户；&lt;/p&gt;
&lt;p&gt;　　安装flannel插件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
The connection to the server raw.githubusercontent.com was refused - did you specify the right host or port?
[root@master01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里提示raw.githubusercontent.com不能访问，解决办法在/etc/hosts文件中加入对应的解析记录&lt;/p&gt;
&lt;p&gt;　　添加raw.githubusercontent.com的解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.0.99 time.test.org time-node
192.168.0.41  master01 master01.k8s.org
192.168.0.42  master02 master02.k8s.org
192.168.0.43  master03 master03.k8s.org
192.168.0.44  node01 node01.k8s.org
192.168.0.45  node02 node02.k8s.org
192.168.0.46  node03 node03.k8s.org
151.101.76.133 raw.githubusercontent.com
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再次执行kubectl apply -f  https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
Unable to connect to the server: read tcp 192.168.0.41:46838-&amp;gt;151.101.76.133:443: read: connection reset by peer
[root@master01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里还是提示我们不能连接；解决办法，用浏览器打开 https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml，将其内容复制出来，然后在当前目录下创建flannel.yml文件&lt;/p&gt;
&lt;p&gt;　　flannel.yml文件内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_1d281cb9-0a38-4e1c-bf71-e94ea2273939&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_1d281cb9-0a38-4e1c-bf71-e94ea2273939&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1d281cb9-0a38-4e1c-bf71-e94ea2273939&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
[root@master01 ~]# &lt;span&gt;cat&lt;/span&gt;&lt;span&gt; flannel.yml
&lt;/span&gt;---&lt;span&gt;
apiVersion: policy&lt;/span&gt;/&lt;span&gt;v1beta1
kind: PodSecurityPolicy
metadata:
  name: psp.flannel.unprivileged
  annotations:
    seccomp.security.alpha.kubernetes.io&lt;/span&gt;/allowedProfileNames: docker/&lt;span&gt;default
    seccomp.security.alpha.kubernetes.io&lt;/span&gt;/defaultProfileName: docker/&lt;span&gt;default
    apparmor.security.beta.kubernetes.io&lt;/span&gt;/allowedProfileNames: runtime/&lt;span&gt;default
    apparmor.security.beta.kubernetes.io&lt;/span&gt;/defaultProfileName: runtime/&lt;span&gt;default
spec:
  privileged: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  volumes:
  &lt;/span&gt;-&lt;span&gt; configMap
  &lt;/span&gt;-&lt;span&gt; secret
  &lt;/span&gt;-&lt;span&gt; emptyDir
  &lt;/span&gt;-&lt;span&gt; hostPath
  allowedHostPaths:
  &lt;/span&gt;- pathPrefix: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/cni/net.d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
  - pathPrefix: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/kube-flannel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
  - pathPrefix: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/run/flannel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  readOnlyRootFilesystem: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  # Users and &lt;/span&gt;&lt;span&gt;groups&lt;/span&gt;&lt;span&gt;
  runAsUser:
    rule: RunAsAny
  supplementalGroups:
    rule: RunAsAny
  fsGroup:
    rule: RunAsAny
  # Privilege Escalation
  allowPrivilegeEscalation: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  defaultAllowPrivilegeEscalation: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  # Capabilities
  allowedCapabilities: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;NET_ADMIN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;NET_RAW&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
  defaultAddCapabilities: []
  requiredDropCapabilities: []
  # Host namespaces
  hostPID: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  hostIPC: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  hostNetwork: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  hostPorts:
  &lt;/span&gt;- min: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    max: &lt;/span&gt;&lt;span&gt;65535&lt;/span&gt;&lt;span&gt;
  # SELinux
  seLinux:
    # SELinux is unused &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; CaaSP
    rule: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RunAsAny&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
---&lt;span&gt;
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io&lt;/span&gt;/&lt;span&gt;v1
metadata:
  name: flannel
rules:
&lt;/span&gt;- apiGroups: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;extensions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;podsecuritypolicies&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
  resourceNames: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;psp.flannel.unprivileged&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;-&lt;span&gt; apiGroups:
  &lt;/span&gt;- &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
  resources:
  &lt;/span&gt;-&lt;span&gt; pods
  verbs:
  &lt;/span&gt;-&lt;span&gt; get
&lt;/span&gt;-&lt;span&gt; apiGroups:
  &lt;/span&gt;- &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
  resources:
  &lt;/span&gt;-&lt;span&gt; nodes
  verbs:
  &lt;/span&gt;-&lt;span&gt; list
  &lt;/span&gt;-&lt;span&gt; watch
&lt;/span&gt;-&lt;span&gt; apiGroups:
  &lt;/span&gt;- &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
  resources:
  &lt;/span&gt;- nodes/&lt;span&gt;status
  verbs:
  &lt;/span&gt;- &lt;span&gt;patch&lt;/span&gt;
---&lt;span&gt;
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io&lt;/span&gt;/&lt;span&gt;v1
metadata:
  name: flannel
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: flannel
subjects:
&lt;/span&gt;-&lt;span&gt; kind: ServiceAccount
  name: flannel
  namespace: kube&lt;/span&gt;-&lt;span&gt;system
&lt;/span&gt;---&lt;span&gt;
apiVersion: v1
kind: ServiceAccount
metadata:
  name: flannel
  namespace: kube&lt;/span&gt;-&lt;span&gt;system
&lt;/span&gt;---&lt;span&gt;
kind: ConfigMap
apiVersion: v1
metadata:
  name: kube&lt;/span&gt;-flannel-&lt;span&gt;cfg
  namespace: kube&lt;/span&gt;-&lt;span&gt;system
  labels:
    tier: node
    app: flannel
data:
  cni&lt;/span&gt;-conf.json: |&lt;span&gt;
    {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cbr0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cniVersion&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.3.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;flannel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hairpinMode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;isDefaultGateway&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
          }
        },
        {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;portmap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;capabilities&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;portMappings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
          }
        }
      ]
    }
  net&lt;/span&gt;-conf.json: |&lt;span&gt;
    {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Network&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10.244.0.0/16&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Backend&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vxlan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    }
&lt;/span&gt;---&lt;span&gt;
apiVersion: apps&lt;/span&gt;/&lt;span&gt;v1
kind: DaemonSet
metadata:
  name: kube&lt;/span&gt;-flannel-&lt;span&gt;ds
  namespace: kube&lt;/span&gt;-&lt;span&gt;system
  labels:
    tier: node
    app: flannel
spec:
  selector:
    matchLabels:
      app: flannel
  template:
    metadata:
      labels:
        tier: node
        app: flannel
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            &lt;/span&gt;-&lt;span&gt; matchExpressions:
              &lt;/span&gt;- key: kubernetes.io/&lt;span&gt;os
                operator: In
                values:
                &lt;/span&gt;-&lt;span&gt; linux
      hostNetwork: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      priorityClassName: system&lt;/span&gt;-node-&lt;span&gt;critical
      tolerations:
      &lt;/span&gt;-&lt;span&gt; operator: Exists
        effect: NoSchedule
      serviceAccountName: flannel
      initContainers:
      &lt;/span&gt;- name: &lt;span&gt;install&lt;/span&gt;-&lt;span&gt;cni
        image: quay.io&lt;/span&gt;/coreos/flannel:v0.&lt;span&gt;13.1&lt;/span&gt;-&lt;span&gt;rc1
        command:
        &lt;/span&gt;- &lt;span&gt;cp&lt;/span&gt;&lt;span&gt;
        args:
        &lt;/span&gt;- -&lt;span&gt;f
        &lt;/span&gt;- /etc/kube-flannel/cni-&lt;span&gt;conf.json
        &lt;/span&gt;- /etc/cni/net.d/&lt;span&gt;10&lt;/span&gt;-&lt;span&gt;flannel.conflist
        volumeMounts:
        &lt;/span&gt;-&lt;span&gt; name: cni
          mountPath: &lt;/span&gt;/etc/cni/&lt;span&gt;net.d
        &lt;/span&gt;- name: flannel-&lt;span&gt;cfg
          mountPath: &lt;/span&gt;/etc/kube-flannel/&lt;span&gt;
      containers:
      &lt;/span&gt;- name: kube-&lt;span&gt;flannel
        image: quay.io&lt;/span&gt;/coreos/flannel:v0.&lt;span&gt;13.1&lt;/span&gt;-&lt;span&gt;rc1
        command:
        &lt;/span&gt;- /opt/bin/&lt;span&gt;flanneld
        args:
        &lt;/span&gt;- --ip-&lt;span&gt;masq
        &lt;/span&gt;- --kube-subnet-&lt;span&gt;mgr
        resources:
          requests:
            cpu: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            memory: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;50Mi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
          limits:
            cpu: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            memory: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;50Mi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        securityContext:
          privileged: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
          capabilities:
            add: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NET_ADMIN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NET_RAW&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;env&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;-&lt;span&gt; name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        &lt;/span&gt;-&lt;span&gt; name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        &lt;/span&gt;-&lt;span&gt; name: run
          mountPath: &lt;/span&gt;/run/&lt;span&gt;flannel
        &lt;/span&gt;- name: flannel-&lt;span&gt;cfg
          mountPath: &lt;/span&gt;/etc/kube-flannel/&lt;span&gt;
      volumes:
      &lt;/span&gt;-&lt;span&gt; name: run
        hostPath:
          path: &lt;/span&gt;/run/&lt;span&gt;flannel
      &lt;/span&gt;-&lt;span&gt; name: cni
        hostPath:
          path: &lt;/span&gt;/etc/cni/&lt;span&gt;net.d
      &lt;/span&gt;- name: flannel-&lt;span&gt;cfg
        configMap:
          name: kube&lt;/span&gt;-flannel-&lt;span&gt;cfg

[root@master01 &lt;/span&gt;~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　使用 flannel.yml文件来安装flannel插件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f flannel.yml 
podsecuritypolicy.policy/psp.flannel.unprivileged created
clusterrole.rbac.authorization.k8s.io/flannel created
clusterrolebinding.rbac.authorization.k8s.io/flannel created
serviceaccount/flannel created
configmap/kube-flannel-cfg created
daemonset.apps/kube-flannel-ds created
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看master端运行的pod情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pods -n kube-system
NAME                                       READY   STATUS     RESTARTS   AGE
coredns-7f89b7bc75-k9gdt                   0/1     Pending    0          30m
coredns-7f89b7bc75-kp855                   0/1     Pending    0          30m
etcd-master01.k8s.org                      1/1     Running    0          30m
kube-apiserver-master01.k8s.org            1/1     Running    0          30m
kube-controller-manager-master01.k8s.org   1/1     Running    0          30m
kube-flannel-ds-zgq92                      0/1     Init:0/1   0          9m45s
kube-proxy-pjv9s                           1/1     Running    0          30m
kube-scheduler-master01.k8s.org            1/1     Running    0          30m
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里可以看到kube-flannel一直在初始化，原因是在flannel.yml资源清单中使用的是quay.io/coreos/flannel:v0.13.1-rc1这个镜像，这个镜像仓库在国内访问速度非常慢，有时候几乎就下载不到对应的镜像；解决办法，翻墙出去把对应镜像打包，然后再导入镜像；&lt;/p&gt;
&lt;p&gt;　　导入 quay.io/coreos/flannel:v0.13.1-rc镜像&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# ll
total 64060
-rw------- 1 root root 65586688 Dec  8 15:16 flannel-v0.13.1-rc1.tar
-rw-r--r-- 1 root root     4822 Dec  8 14:57 flannel.yml
[root@master01 ~]# docker load -i flannel-v0.13.1-rc1.tar 
70351a035194: Loading layer [==================================================&amp;gt;]  45.68MB/45.68MB
cd38981c5610: Loading layer [==================================================&amp;gt;]   5.12kB/5.12kB
dce2fcdf3a87: Loading layer [==================================================&amp;gt;]  9.216kB/9.216kB
be155d1c86b7: Loading layer [==================================================&amp;gt;]   7.68kB/7.68kB
Loaded image: quay.io/coreos/flannel:v0.13.1-rc1
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　复制flannel镜像打包文件到其他节点，并导入镜像&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# scp flannel-v0.13.1-rc1.tar node01:/root/
flannel-v0.13.1-rc1.tar                                                       100%   63MB  62.5MB/s   00:01    
[root@master01 ~]# scp flannel-v0.13.1-rc1.tar node02:/root/
flannel-v0.13.1-rc1.tar                                                       100%   63MB  62.4MB/s   00:01    
[root@master01 ~]# scp flannel-v0.13.1-rc1.tar node03:/root/
flannel-v0.13.1-rc1.tar                                                       100%   63MB  62.5MB/s   00:01    
[root@master01 ~]# ssh node01 'docker load -i /root/flannel-v0.13.1-rc1.tar'
Loaded image: quay.io/coreos/flannel:v0.13.1-rc1
[root@master01 ~]# ssh node02 'docker load -i /root/flannel-v0.13.1-rc1.tar' 
Loaded image: quay.io/coreos/flannel:v0.13.1-rc1
[root@master01 ~]# ssh node03 'docker load -i /root/flannel-v0.13.1-rc1.tar' 
Loaded image: quay.io/coreos/flannel:v0.13.1-rc1
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再次查看pod运行情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pods -n kube-system
NAME                                       READY   STATUS    RESTARTS   AGE
coredns-7f89b7bc75-k9gdt                   1/1     Running   0          39m
coredns-7f89b7bc75-kp855                   1/1     Running   0          39m
etcd-master01.k8s.org                      1/1     Running   0          40m
kube-apiserver-master01.k8s.org            1/1     Running   0          40m
kube-controller-manager-master01.k8s.org   1/1     Running   0          40m
kube-flannel-ds-zgq92                      1/1     Running   0          19m
kube-proxy-pjv9s                           1/1     Running   0          39m
kube-scheduler-master01.k8s.org            1/1     Running   0          40m
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到kube-flannel已经正常running起来了；&lt;/p&gt;
&lt;p&gt;　　查看节点信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get nodes
NAME               STATUS   ROLES                  AGE   VERSION
master01.k8s.org   Ready    control-plane,master   41m   v1.20.0
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到master节点已经处于ready状态，表示master端已经部署好了；&lt;/p&gt;
&lt;p&gt;　　将node01加入到k8s集群作为node节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# kubeadm join 192.168.0.41:6443 --token dz6bs3.ohitv535s1fmcuag \
&amp;gt; --discovery-token-ca-cert-hash sha256:330db1e5abff4d0e62150596f3e989cde40e61bdc73d6477170d786fcc1cfc67 \
&amp;gt; --ignore-preflight-errors=Swap
[preflight] Running pre-flight checks
        [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/
        [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 20.10.0. Latest validated version: 19.03
        [WARNING Service-Kubelet]: kubelet service is not enabled, please run 'systemctl enable kubelet.service'
[preflight] Reading configuration from the cluster...
[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -o yaml'
[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;
[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;
[kubelet-start] Starting the kubelet
[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...

This node has joined the cluster:
* Certificate signing request was sent to apiserver and a response was received.
* The Kubelet was informed of the new secure connection details.

Run 'kubectl get nodes' on the control-plane to see this node join the cluster.

[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：执行相同的命令将其他节点加入到k8s集群，作为node节点；&lt;/p&gt;
&lt;p&gt;　　在master节点上查看集群节点信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get nodes
NAME               STATUS   ROLES                  AGE     VERSION
master01.k8s.org   Ready    control-plane,master   49m     v1.20.0
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 5m53s   v1.20.0
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 30s     v1.20.0
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 25s     v1.20.0
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到master和3个node节点都处于ready状态；&lt;/p&gt;
&lt;p&gt;　　测试：运行一个nginx 控制器，并指定使用nginx:1.14-alpine这个镜像，看看是否可以正常运行？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl create deploy nginx-dep --image=nginx:1.14-alpine
deployment.apps/nginx-dep created
[root@master01 ~]# kubectl get pod
NAME                        READY   STATUS    RESTARTS   AGE
nginx-dep-8967df55d-j8zp7   1/1     Running   0          18s
[root@master01 ~]# kubectl get pod -o wide
NAME                        READY   STATUS    RESTARTS   AGE   IP           NODE             NOMINATED NODE   READINESS GATES
nginx-dep-8967df55d-j8zp7   1/1     Running   0          30s   10.244.2.2   node02.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：访问podip看看对应nginx是否能够被访问到？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# curl 10.244.2.2
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Welcome to nginx!&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;For online documentation and support please refer to
&amp;lt;a href=&quot;http://nginx.org/&quot;&amp;gt;nginx.org&amp;lt;/a&amp;gt;.&amp;lt;br/&amp;gt;
Commercial support is available at
&amp;lt;a href=&quot;http://nginx.com/&quot;&amp;gt;nginx.com&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Thank you for using nginx.&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到访问pod ip能够正常访问到对应nginx pod；到此一个单master节点，3个node节点的k8s集群就搭建好了；&lt;/p&gt;
</description>
<pubDate>Sat, 12 Dec 2020 16:24:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>一、kubernetes简介 1、什么是kubernetes？它是干什么用的？ kubernetes是google公司用go语言开发的一套容器编排系统，简称k8s；它主要用于容器编排；所谓容器编排简单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14126750.html</dc:identifier>
</item>
<item>
<title>面向架构编程 - IvanEye</title>
<link>http://www.cnblogs.com/ivaneye/p/14127388.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ivaneye/p/14127388.html</guid>
<description>&lt;p&gt;在&lt;a class=&quot;pgc-link&quot; href=&quot;https://www.toutiao.com/i6682238250024698376/?group_id=6682238250024698376&quot; target=&quot;_blank&quot; data-content=&quot;mp&quot;&gt;领域设计：聚合与聚合根&lt;/a&gt;一文中，提到了两个导致设计与代码脱节的情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码未反映出软件架构：架构图说的是一回事，代码说的却是另外一回事&lt;/li&gt;
&lt;li&gt;设计的表现力不足：设计没有体现出某些约束，需要阅读代码实现才能清楚具体的内容&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a class=&quot;pgc-link&quot; href=&quot;https://www.toutiao.com/i6682238250024698376/?group_id=6682238250024698376&quot; target=&quot;_blank&quot; data-content=&quot;mp&quot;&gt;领域设计：聚合与聚合根&lt;/a&gt;通过淘宝购物的例子说明了「设计的表现力不足」的问题。本文将通过《敏捷软件开发：原则、模式与实践》中保龄球计分软件的例子来说明「代码未反映出软件架构」的问题。&lt;/p&gt;

&lt;p&gt;在开始之前，我们需要了解需求，这里就是「保龄球的记分规则」：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;保龄球一局比赛由10轮组成，在每轮比赛中，参赛者可以投掷两次来尝试击倒所有的瓶子。&lt;/li&gt;
&lt;li&gt;如果参赛者一次即击倒所有的瓶子，则称为「全中」，并且本轮结束。&lt;/li&gt;
&lt;li&gt;如果参赛者第一次没有击倒所有的瓶子，第二次击倒了所有的瓶子，则称为「补中」。&lt;/li&gt;
&lt;li&gt;如果一轮比赛中，两次投掷都没有击倒所有的瓶子，本轮也宣告结束。&lt;/li&gt;
&lt;li&gt;全中轮记分规则：本轮击倒得到的10分，加上接下来的两次投掷击倒的瓶子数量，再加上前一轮的分数&lt;/li&gt;
&lt;li&gt;补中轮记分规则：本轮击倒得到的10分，加上接下来的一次投掷击倒的瓶子数量，再加上前一轮的分数&lt;/li&gt;
&lt;li&gt;其它轮记分规则：本轮两次击倒的瓶子数量，再加上前一轮的分数&lt;/li&gt;
&lt;li&gt;如果第十轮为全中，那么参赛者可以多投两次，以完成对全中的记分&lt;/li&gt;
&lt;li&gt;相应的，如果第十轮为补中，那么参赛者可以多投一次，以完成对补中的记分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的规则，我们可以得到初步的设计：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一局比赛(Game)有10轮(Frame)&lt;/li&gt;
&lt;li&gt;每轮(Frame)有一到三次投掷(Throw)&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;全中则是一次投掷&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;其它为两次投掷&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;最后一轮如果全中或补中，则是三次投掷&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;也就是说，游戏最多可以投23次&lt;/li&gt;
&lt;li&gt;每轮的记分规则如下：&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;全中轮：本轮10分+后两次投掷得分+前一轮得分&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;补中轮：本轮10分+后一次投掷得分+前一轮得分&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;其它轮：本轮两次投掷得分综合+前一轮得分&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;也就是说，游戏得分即当前轮的得分&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对象初步关系如下：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;https://p1-tt.byteimg.com/origin/pgc-image/06312b2d5f874bb380d18771109fc7ee?from=pc&quot; alt=&quot;面向架构编程&quot; class=&quot;syl-page-img&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;《敏捷》花了一章的内容来讨论这个软件的开发过程。初步设计如上图所示，然后通过结对编程+TDD的方式一步步的进行代码演进（具体推导过程请阅读《敏捷》，这里不再赘述），最终得到的如下代码：&lt;/p&gt;
&lt;pre&gt;
public class Game {
 private int itsCurrentFrame = 0;
 private boolean firstThrowInFrame = true;
 private Scorer itsScorer = new Scorer();
 public int score() {
 return scoreForFrame(itsCurrentFrame);
 }
 public void add(int pins) {
 itsScorer.addThrow(pins);
 adjustCurrentFrame(pins);
 }
 public int scoreForFrame(int theFrame) {
 return itsScorer.scoreForFrame(theFrame);
 }
 private void adjustCurrentFrame(int pins) {
 if (lastBallInFrame(pins)) {
 advanceFrame();
 } else {
 firstThrowInFrame = false;
 }
 }
 private boolean lastBallInFrame(int pins) {
 return strike(pins) || !firstThrowInFrame;
 }
 private boolean strike(int pins) {
 return (firstThrowInFrame &amp;amp;&amp;amp; pins == 10);
 }
 private void advanceFrame() {
 itsCurrentFrame = Math.min(10, itsCurrentFrame + 1);
 }
}

public class Scorer {
 private int ball;
 private int[] itsThrows = new int[21];
 private int itsCurrentThrow = 0;
 public void addThrow(int pins) {
 itsThrows[itsCurrentThrow++] = pins;
 }
 public int scoreForFrame(int theFrame) {
 ball = 0;
 int score = 0;
 for (int currentFrame = 0; currentFrame &amp;lt; theFrame; currentFrame++) {
 if (strike()) {
 score += 10 + nextTwoBallsForStrike();
 ball++;
 } else if (spare()) {
 score += 10 + nextBallForSpare();
 ball += 2;
 } else {
 score += twoBallsInFrame();
 ball += 2;
 }
 }
 return score;
 }
 private int twoBallsInFrame() {
 return itsThrows[ball] + itsThrows[ball + 1];
 }
 private int nextBallForSpare() {
 return itsThrows[ball + 2];
 }
 private int nextTwoBallsForStrike() {
 return itsThrows[ball + 1] + itsThrows[ball + 2];
 }
 private boolean spare() {
 return (itsThrows[ball] + itsThrows[ball + 1]) == 10;
 }
 private boolean strike() {
 return itsThrows[ball] == 10;
 }
}
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;一个Game类表示游戏本身&lt;/li&gt;
&lt;li&gt;一个Scorer类用于计算Game的得分&lt;/li&gt;
&lt;li&gt;初始设计中的Frame和Throw都隐藏到了代码中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从代码本身来看，实现足够简单，变量名、方法名取得都有意义，符合开发原则，有完整的单元测试。但是，代码结构没有体现出业务逻辑。&lt;/p&gt;
&lt;p&gt;上面的代码结构如下：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;https://p1-tt.byteimg.com/origin/pgc-image/6086da09c6e94d99afbf7ac38b0ca24b?from=pc&quot; alt=&quot;面向架构编程&quot; class=&quot;syl-page-img&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;从这个类关系图中，只能看出来有一个游戏（Game）和这个游戏的得分（Scorer）！这是从编程的角度一步步推导出来的代码，在推导的过程中可能是理所当然的，但是过了一段时间后，你再来看这段代码的时候，可能就不记得这段代码是干嘛的了！&lt;/p&gt;
&lt;p&gt;另一方面，当别人来接手这段代码时，你是否是先告诉他业务逻辑，然后让他看代码？但是因为代码结构与设计的脱离，导致了虽然已经理解了业务逻辑、代码结构也很清晰，但是还是需要读了源码才能清楚这段代码具体是干嘛的！这是否是增加了理解的难度？&lt;/p&gt;
&lt;p&gt;原因就是这个结构关系没有体现出业务逻辑！理想情况应该是在开发人员理解业务以后，从代码结构就可以理解具体的实现！&lt;/p&gt;

&lt;p&gt;在保龄球记分逻辑中，是有轮（Frame）和投掷（Throw）这两个概念的，所以在代码中需要保留这两个类！&lt;/p&gt;
&lt;pre&gt;
public class Frame {}
public class Throw {}
&lt;/pre&gt;
&lt;p&gt;一局游戏有十轮，所以在创建Game时就初始化十个Frame。同时，当前Frame的计算，需要前一个Frame的得分，所以除了第一个Frame，其它Frame都持有前一个Frame的引用，同时每个Frame都知道自己是第几局（roundNum）！&lt;/p&gt;
&lt;pre&gt;
public class Game {
 private static final int MAX_ROUND = 10;// 一局有十轮
 private Frame[] frameList = new Frame[MAX_ROUND];
 public Game() {
 for (int i = 0; i &amp;lt; MAX_ROUND; i++) {
 frameList[i] = new Frame(i);
 if (i &amp;gt; 0) {
 frameList[i].setPreFrame(frameList[i - 1]);
 }
 }
 }
}

public class Frame {
 private int roundNum; // 所在局，从0开始
 private Frame preFrame;
 public Frame(int roundNum) {
 this.roundNum = roundNum;
 }
 
 public void setPreFrame(Frame preFrame) {
 this.preFrame = preFrame;
 }
}
&lt;/pre&gt;
&lt;p&gt;每一次投掷都会有击倒数量，所以Throw中需要有字段表示击倒数量，同时因为一次投掷后，数量是不可修改的，所以数量由构造函数传入，只有get方法而没有set方法：&lt;/p&gt;
&lt;pre&gt;
public class Throw {
 private int num; // 击倒数量
 public Throw(int num) {
 this.num = num;
 }
 public int getNum() {
 return num;
 }
}
&lt;/pre&gt;
&lt;p&gt;Frame可以包括1到3次Throw，而按照全中、补中、其它击中的不同，记分方式也有所不同。如果完全按照这个逻辑编写，代码会相对复杂。因为需要根据击倒方式的不同，判断是否要获取后两次的投掷。我们是否可以做一些调整？我们实际上是要计算投掷的得分，那么这个投掷属于哪一轮，是不是就不是那么重要了？也就是说，投掷和记分规则可以调整为下面这样：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每轮(Frame)有一到三次投掷(Throw)&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;全中为一次当前轮投掷+后两次投掷&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;补中为两次当前轮投掷+后一次投掷&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;其它为两次投掷&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;也就是说，游戏最多可以投23次&lt;/li&gt;
&lt;li&gt;每轮的记分，为当前Frame投掷的得分的总和+前一轮的得分&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在Frame分数的计算就统一了！&lt;/p&gt;
&lt;pre&gt;
public class Frame {
 private List&amp;lt;Throw&amp;gt; throwList = new ArrayList&amp;lt;&amp;gt;();
 public int score() {
 int throwScore = throwList.stream().mapToInt(it -&amp;gt; it.getNum()).sum();
 if (preFrame != null) {
 throwScore += preFrame.score();
 }
 return throwScore;
 }
}
&lt;/pre&gt;
&lt;p&gt;最后，就是怎么将一个Throw添加到Frame中，按照上面的设计调整，一次Throw可能既属于当前轮，也属于上一轮甚至上上轮！怎们样来判断呢？根据Frame是全中、还是补中还是其它来判定，所以Frame中需要有方法来判定自身是全中、补中还是其它！&lt;/p&gt;
&lt;pre&gt;
public class Frame {
 private boolean isSpare() { // 是否是补中
 return throwList.size() &amp;gt;= 2
 &amp;amp;&amp;amp; throwList.get(0).getNum() &amp;lt; 10
 &amp;amp;&amp;amp; (throwList.get(0).getNum() + throwList.get(1).getNum() == 10);
 }
 private boolean isStrike() { // 是否是全中
 return throwList.size() &amp;gt;= 1 &amp;amp;&amp;amp; throwList.get(0).getNum() == 10;
 }
}
&lt;/pre&gt;
&lt;p&gt;一次Throw添加到Frame后，还要判断这个Frame是否已经结束，即：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果这个Frame是全中或补中，是否已经包含了三次投掷&lt;/li&gt;
&lt;li&gt;如果这个Frame为普通击倒，是否已经包含了两次投掷&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
public class Frame {
 
 public boolean isFinish() {
 if (throwList.size() == 3) return true;
 if (throwList.size() == 2 &amp;amp;&amp;amp; !isStrike() &amp;amp;&amp;amp; !isSpare()) {
 return true;
 }
 return false;
 }
 
}
&lt;/pre&gt;
&lt;p&gt;同时还要判断，是否进入下一轮：&lt;/p&gt;
&lt;pre&gt;
public class Frame {
 
 public int add(Throw aThrow) {
 this.throwList.add(aThrow);
 if (isStrike() || isSpare() || isFinish()) return Math.min(9, roundNum + 1);
 return roundNum;
 }
 
}
&lt;/pre&gt;
&lt;p&gt;Game就是将Throw添加到当前轮和上一轮及上上轮的逻辑：&lt;/p&gt;
&lt;pre&gt;
public class Game {
 public void add(int pins) {
 Throw aThrow = new Throw(pins);
 add2PreFrame(aThrow);// 根据逻辑判定是否要添加到上一轮，或上上轮
 currentFrameIdx = frameList[currentFrameIdx].add(aThrow); // 添加当前轮后，是否进入下一轮
 }
 private void add2PreFrame(Throw aThrow) {
 if (currentFrameIdx - 1 &amp;gt;= 0 &amp;amp;&amp;amp; !frameList[currentFrameIdx - 1].isFinish()) {
 frameList[currentFrameIdx - 1].add(aThrow);
 }
 if (currentFrameIdx - 2 &amp;gt;= 0 &amp;amp;&amp;amp; !frameList[currentFrameIdx - 2].isFinish()) {
 frameList[currentFrameIdx - 2].add(aThrow);
 }
 }
}
&lt;/pre&gt;
&lt;p&gt;调整后的设计如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一局比赛(Game)有10轮(Frame)&lt;/li&gt;
&lt;li&gt;一次投掷(Throw)得分可能属于一到三轮(Frame)&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;属于当前轮&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;如果前一轮是全中或补中，则此次投掷也属于前一轮&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;如果上上轮属于全中，则此次投掷也属于上上轮&lt;/li&gt;
&lt;li class=&quot;ql-indent-1&quot;&gt;游戏最多可以投掷23次&lt;/li&gt;
&lt;li&gt;每轮的记分，为当前Frame投掷的得分的总和+前一轮的得分&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对应的类结构如下：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;https://p3-tt.byteimg.com/origin/pgc-image/5f4569635a814ec588281e49f8257bda?from=pc&quot; alt=&quot;面向架构编程&quot; class=&quot;syl-page-img&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;此结构与设计相符和，只要理解了业务逻辑，顺着业务就可以梳理出代码结构，即使不看源码，也能猜到代码的逻辑！&lt;/p&gt;
&lt;p&gt;《敏捷》中有效代码行数为71行，上面的有效代码为79行，多了8行代码！但是从理解上来看的话，后者更易于理解！完整代码见下文。&lt;/p&gt;

&lt;pre&gt;
public class Game {
 private static final int MAX_ROUND = 10;// 一局有十轮
 private Frame[] frameList = new Frame[MAX_ROUND];
 private int currentFrameIdx = 0;
 public Game() {
 for (int i = 0; i &amp;lt; MAX_ROUND; i++) {
 frameList[i] = new Frame(i);
 if (i &amp;gt; 0) {
 frameList[i].setPreFrame(frameList[i - 1]);
 }
 }
 }
 public int score() {
 return frameList[currentFrameIdx].score();
 }
 public void add(int pins) {
 Throw aThrow = new Throw(pins);
 add2PreFrame(aThrow);
 currentFrameIdx = frameList[currentFrameIdx].add(aThrow);
 }
 private void add2PreFrame(Throw aThrow) {
 if (currentFrameIdx - 1 &amp;gt;= 0 &amp;amp;&amp;amp; !frameList[currentFrameIdx - 1].isFinish()) {
 frameList[currentFrameIdx - 1].add(aThrow);
 }
 if (currentFrameIdx - 2 &amp;gt;= 0 &amp;amp;&amp;amp; !frameList[currentFrameIdx - 2].isFinish()) {
 frameList[currentFrameIdx - 2].add(aThrow);
 }
 }
 public int scoreForFrame(int theFrame) {
 return frameList[theFrame - 1].score();
 }
}
public class Frame {
 private int roundNum; // 所在局,从0开始
 private Frame preFrame;
 private List&amp;lt;Throw&amp;gt; throwList = new ArrayList&amp;lt;&amp;gt;();
 public Frame(int roundNum) {
 this.roundNum = roundNum;
 }
 public int score() {
 int throwScore = throwList.stream().mapToInt(it -&amp;gt; it.getNum()).sum();
 if (preFrame != null) {
 throwScore += preFrame.score();
 }
 return throwScore;
 }
 public int add(Throw aThrow) {
 this.throwList.add(aThrow);
 if (isStrike() || isSpare() || isFinish()) return Math.min(9, roundNum + 1);
 return roundNum;
 }
 public boolean isFinish() {
 if (throwList.size() == 3) return true;
 if (throwList.size() == 2 &amp;amp;&amp;amp; !isStrike() &amp;amp;&amp;amp; !isSpare()) {
 return true;
 }
 return false;
 }
 private boolean isSpare() {
 return throwList.size() &amp;gt;= 2
 &amp;amp;&amp;amp; throwList.get(0).getNum() &amp;lt; 10
 &amp;amp;&amp;amp; (throwList.get(0).getNum() + throwList.get(1).getNum() == 10);
 }
 private boolean isStrike() {
 return throwList.size() &amp;gt;= 1 &amp;amp;&amp;amp; throwList.get(0).getNum() == 10;
 }
 public void setPreFrame(Frame preFrame) {
 this.preFrame = preFrame;
 }
}
public class Throw {
 private int num; // 击倒数量
 public Throw(int num) {
 this.num = num;
 }
 public int getNum() {
 return num;
 }
}
&lt;/pre&gt;

&lt;p&gt;本文通过《敏捷》中保龄球的例子，来说明了代码不能体现设计的原因及提出一种保证代码和设计相一致的方法。&lt;/p&gt;
&lt;p&gt;设计本身就是一种取舍，没有完全正确的方法，只有适合的方法。从代码本身出发，能够构建出符合编码原则的代码，但是可能和设计本身有出入，这可能会增加后续的理解难度，变相增加了修改代码的难度；反之从设计触发，能构建出和设计相匹配的代码，但是可能代码本身的易读性、代码量、符合编码原则上会有所妥协。&lt;/p&gt;
&lt;p&gt;个人认为，对于业务逻辑不复杂，但是计算逻辑很复杂的代码，以按照代码原则来编写代码为主，以按照业务逻辑编写代码逻辑为辅，以保证代码的简洁明了；而对于业务逻辑复杂，但是计算逻辑不复杂的代码，以按照业务逻辑编写代码为主，以按照代码原则编写代码为辅，以保证代码结构与业务逻辑的直观匹配。&lt;/p&gt;
&lt;p&gt;以上内容仅为个人观点，欢迎探讨！&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;《敏捷软件开发：原则、模式与实践》&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 12 Dec 2020 15:48:00 +0000</pubDate>
<dc:creator>IvanEye</dc:creator>
<og:description>在领域设计：聚合与聚合根一文中，提到了两个导致设计与代码脱节的情况： 代码未反映出软件架构：架构图说的是一回事，代码说的却是另外一回事 设计的表现力不足：设计没有体现出某些约束，需要阅读代码实现才能清</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ivaneye/p/14127388.html</dc:identifier>
</item>
<item>
<title>SpringBoot快速入门（实战篇一） - 泪梦红尘blog</title>
<link>http://www.cnblogs.com/lmhcblog/p/springboot1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lmhcblog/p/springboot1.html</guid>
<description>&lt;p&gt;Spring 诞生时是 Java 企业版（Java Enterprise Edition，JEE，也称 J2EE）的轻量级代替品。无需开发重量级的 Enterprise JavaBean（EJB），Spring 为企业级Java 开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java 对象（Plain Old Java Object，POJO）实现了 EJB 的功能。虽然 Spring 的组件代码是轻量级的，但它的配置却是重量级的。 (IOC容器--控制反转 AOP-面向切面编程)&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;183.02439298561&quot;&gt;

&lt;h2 id=&quot;一springboot简介&quot;&gt;一SpringBoot简介&lt;/h2&gt;
&lt;h3 id=&quot;1spring开发经历的阶段&quot;&gt;1.spring开发经历的阶段&lt;/h3&gt;
&lt;p&gt;Spring 诞生时是 Java 企业版（Java Enterprise Edition，JEE，也称 J2EE）的轻量级代替品。无需开发重量级的 Enterprise JavaBean（EJB），Spring 为企业级Java 开发提供了一种相对简单的方法，通过&lt;mark&gt;依赖注入&lt;/mark&gt;和&lt;mark&gt;面向切面编程&lt;/mark&gt;，用简单的Java 对象（Plain Old Java Object，POJO）实现了 EJB 的功能。虽然 Spring 的组件代码是轻量级的，但它的配置却是重量级的。 (IOC容器--控制反转 AOP-面向切面编程)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一阶段：xml配置：在Spring 1.x时代，使用Spring开发满眼都是xml配置的Bean，随着项目的扩大，我们需要把xml配置文件放到不同的配置文件里，那时需要频繁的在开发的类和配置文件之间进行切换&lt;/li&gt;
&lt;li&gt;第二阶段：注解配置：在Spring 2.x 时代，随着JDK1.5带来的注解支持，Spring提供了声明Bean的注解（例如@Component、@Service），大大减少了配置量。&lt;/li&gt;
&lt;li&gt;第三阶段：java配置管理 ：Annotation的出现是为了简化Spring的XML配置文件，但Annotation不如XML强大，所以无法完全取代XMl文件 。例如：@Configuration、@Import等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所有这些配置都代表了开发时间的损耗。 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，&lt;strong&gt;所以写配置挤占了写应用程序逻辑的时间&lt;/strong&gt;。除此之外，&lt;strong&gt;项目的依赖管理也是件吃力不讨好的事情&lt;/strong&gt;。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot 让这一切成为了过去。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;起步依赖&lt;/strong&gt;--pom：本质是Maven项目对象模型中的标签。它定义其SpringBoot对他库的传递依赖，依赖加在一起即可支持某项功能。最厉害的就是这个，使得SpringBoot具备了构建一切的能力：整合所有牛×框架&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动配置&lt;/strong&gt;--全部的配置文件：基于约定优于配置思想，配置基本都可以走默认值。配置基本都是SpringBoot自动完成&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2-springboot简介&quot;&gt;2. springboot简介&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是：springboot是一项新的框架--不是一项新的语言和新的技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。&lt;/p&gt;
&lt;p&gt;mian Spring Boot 简化了基于Spring的应用开发，只需要&lt;strong&gt;“run”&lt;/strong&gt;就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置），这样我们就可以简单的开始。多数Spring Boot应用只需要&lt;strong&gt;很少&lt;/strong&gt;（额外）的Spring配置。我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，或者采用传统的war部署方式。&lt;/p&gt;
&lt;p&gt;说白了就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。SpringBoot不是对Spring功能的增强，而是提供一种快速使用Spring的开发方式（全新的开发方式）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201212/247edd8a277545a79a821584f89ba6a6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二-springboot快速入门&quot;&gt;二 SpringBoot快速入门&lt;/h2&gt;
&lt;h3 id=&quot;21-springboot的好处&quot;&gt;2.1 springboot的好处&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;简单，快速，方便&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;用springmvc搭建一个springweb项目则需要以下步骤&quot;&gt;用springmvc搭建一个SpringWeb项目则需要以下步骤&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;创建maven工程&lt;/li&gt;
&lt;li&gt;导入相关依赖的jar包&lt;/li&gt;
&lt;li&gt;编写springmvc核心配置文件&lt;/li&gt;
&lt;li&gt;编写web.xml文件&lt;/li&gt;
&lt;li&gt;编写XxxController&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看似不是很麻烦，但是如果说这个项目仅仅做一个很简功能，比如说只是发一个邮件，那么每次都要这么来一遍。&lt;/p&gt;
&lt;p&gt;但是如果用SpringBoot实现呢？&lt;/p&gt;
&lt;p&gt;很简单只需要用Spring initializr方式创建一个springboot工程配置文件，&lt;/p&gt;
&lt;p&gt;使用SpringBoot只需要关注业务逻辑，而不用关注框架！&lt;/p&gt;
&lt;h4 id=&quot;22-spring-initializr方式搭建springboot工程&quot;&gt;2.2 Spring initializr方式搭建SpringBoot工程&lt;/h4&gt;
&lt;p&gt;1.通过idea工具创建工程时，不要选择maven而是要选择spring initializr。然后去勾选相关依赖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201119/3965ea94850d455bb00c42b7ab404762_44368406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201212/65ef10f6336d45659224a1ac63ada5b6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201212/f41f64b8c27b42afa5929a8a9c1fe230.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201212/c56f1df109b542a59c22af24cdcc9657.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编写controller&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class HelloController {

    /**
     * 请求/hello输出hello springboot!
     * @return
     */
    @GetMapping(value = &quot;/hello&quot;)
    public String hello(){
        return &quot;hello springboot! &quot;;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201119/d80c4747eebb4e3896f2fdd97dbe8d43_44368406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问：&lt;a href=&quot;http://locahost:8080/hello&quot; target=&quot;_blank&quot;&gt;http://locahost:8080/hello&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201119/370b18ddcc1d455b9af4eaa8eb4fac3e_44368406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在这个工程中我没有启动tomcat，其实这台电脑就没有装tomcat，但是却可以正常访问localhost:8080，这是SpingBoot以及帮我们集成好的，同时配置文件也是空的！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;三-springboot原理分析&quot;&gt;三 SpringBoot原理分析&lt;/h2&gt;
&lt;h4 id=&quot;1-springboot-起步依赖&quot;&gt;1 SpringBoot-起步依赖&lt;/h4&gt;
&lt;p&gt;我们可以打开pom.xml中的parent,并查看&lt;code&gt;spring-boot-starter-parent&lt;/code&gt;信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201119/86506494b0594f9caaf8cba0bfe250a9_44368406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的&lt;code&gt;spring-boot-dependencies&lt;/code&gt;的pom.xml中可以看出，坐标的版本，依赖管理，插件管理已经预先定义好了。SpringBoot工程继承Spring-boot-starter-parent后，已经锁定了版本等配置。起步依赖的作用是进行依赖传递 。用啥取啥，随用随取即可。我们开发中彻底不用关心：jar包的版本、依赖等问题了，大大降低版本冲突，版本过期，更新一个jar一下就需要升级一个tree的jar包。&lt;/p&gt;
&lt;p&gt;相当于我们之前学习的过程中创建的父工程，在之前创建的父工程中，其中一个功能是用来统一管理jar包。这里的父工程其实作用是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;parent的版本和jar包管理,2.以及坐标引入利用maven的依赖传递的性质,共同实现了起步依赖&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-springboot-自动配置&quot;&gt;2 SpringBoot-自动配置&lt;/h4&gt;
&lt;p&gt;(1)@SpringBootApplication&lt;/p&gt;
&lt;p&gt;该注解是一个组合注解，包括如下注解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/lmhcblog/p/assets%5C1563054785549_44368406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@SpringBootConfiguration：与之前@Configuration注解一样，声明为一个配置类&lt;/li&gt;
&lt;li&gt;@ComponentScan：spring IoC容器的扫描包，默认扫描引导程序下的包以及子包，如果我们写的程序不在该包范围内，可以通过该注解指定。&lt;/li&gt;
&lt;li&gt;@EnableAutoConfiguration：springboot实现自动化配置的核心注解。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(2)@SpringBootConfiguration&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201119/ce8c58378c31499286e914a6e82a9fd2_44368406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过这段我们可以看出，在这个注解上面，又有一个&lt;code&gt;@Configuration&lt;/code&gt;注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了&lt;code&gt;@Configuration&lt;/code&gt;的类，并且读取其中的配置信息。而&lt;code&gt;@SpringBootConfiguration&lt;/code&gt;是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。&lt;/p&gt;
&lt;p&gt;(3)@EnableAutoConfiguration&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;告诉Spring Boot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了&lt;code&gt;spring-boot-starter-web&lt;/code&gt;，而这个启动器中帮我们添加了&lt;code&gt;tomcat&lt;/code&gt;、&lt;code&gt;SpringMVC&lt;/code&gt;的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！&lt;/p&gt;
&lt;p&gt;自动配置：自己一般不用修改配置，默认的配置都给配好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201119/1cc2da7f230847428558381995fc0acd_44368406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四-springboot配置文件使用&quot;&gt;四 SpringBoot配置文件使用&lt;/h2&gt;
&lt;h4 id=&quot;1-applicationproperties&quot;&gt;1 application.properties&lt;/h4&gt;
&lt;p&gt;(1) 语法&lt;/p&gt;
&lt;p&gt;(2)案例&lt;/p&gt;
&lt;p&gt;在resources目录下新建application.properties&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;#tomcat port
server.port=8088
#app context
server.servlet.context-path=/test
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201119/55ffca5f40834669ad2da8c99cd538a2_44368406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;此时运行，tomcat端口发生了变化，每次请求，需要加上=/test。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201120/485dc82436094c92a982ec572c753e4a_44368406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;32-applicationymlapplicationyaml&quot;&gt;3.2 application.yml(application.yaml)&lt;/h4&gt;
&lt;p&gt;(1)语法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;普通数据：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;说明：
key: value（注意：冒号有一个空格）

示例：
name: tom
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对象数据或map&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;#说明：
key:
  key1: value1
  key2: value2
#示例：
user:
  xiaobai:
    name: tom
        age: 23
        addr: beijing
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;集合数据1：存储简单类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;说明：
key:
        value1
        value2
或：
key: value1,value2

示例：
city:
        beijing
        anhui
        jiangxi
        shenzhen
或：
city: [beijing,anhui,jiangxi,shenzhen]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;集合数据2：存储对象类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;说明：
key:
        key1: vlaue1
        key2: value2
        
示例：
student:
        - name: zhangsan
          age: 23
          addr: BJ
        - name: lisi
          age: 25
          addr: SZ
        
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2)案例&lt;/p&gt;
&lt;p&gt;将springboot-demo1中的application.properties换成application.yml，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;server:
  port: 18081
  servlet:
    context-path: /demo
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201119/1969b8f9e45e4f9cac5f0096a2827864_44368406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-配置文件与配置类的属性映射方式&quot;&gt;3 配置文件与配置类的属性映射方式&lt;/h4&gt;
&lt;p&gt;(1)使用注解@Value映射&lt;/p&gt;
&lt;p&gt;@value注解将配置文件的值映射到Spring管理的Bean属性值&lt;/p&gt;
&lt;p&gt;(2)使用注解@ConfigurationProperties映射&lt;/p&gt;
&lt;p&gt;通过注解@ConfigurationProperties(prefix=''配置文件中的key的前缀&quot;)可以将配置文件中的配置自动与实体进行映射。&lt;/p&gt;
&lt;p&gt;使用@ConfigurationProperties @Compment方式必须提供Setter方法，使用@Value注解不需要Setter方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lmhc.blog/attachment/20201119/29d3739a7446483daac3c20d4e359478_44368406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意使用该注解需要引入如下依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-configuration-processor&amp;lt;/artifactId&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Sat, 12 Dec 2020 15:42:00 +0000</pubDate>
<dc:creator>泪梦红尘blog</dc:creator>
<og:description>Spring 诞生时是 Java 企业版（Java Enterprise Edition，JEE，也称 J2EE）的轻量级代替品。无需开发重量级的 Enterprise JavaBean（EJB），S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lmhcblog/p/springboot1.html</dc:identifier>
</item>
<item>
<title>【Tomcat 源码系列】源码构建 Tomcat - 楷哥</title>
<link>http://www.cnblogs.com/zzk0/p/14127315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzk0/p/14127315.html</guid>
<description>&lt;p&gt;这篇博客写于 12 月 12 日，从 github[1] 上 fork 了一份 tomcat 的源代码，clone 到了本地。最近想把 tomcat 的源代码分析一下，寒假的时候有完整的时间就造个轮子。&lt;/p&gt;
&lt;p&gt;看源码，总不能干看，边看边改，验证想法。所以这个系列从构建 tomcat 开始。首先要声明的是，以前没有完整看过一个项目的经历，tomcat 是第一次尝试看的源码。因此，这个系列可能存在描述不正确的问题，希望读者能帮忙指正。最后，感谢您的阅读！&lt;/p&gt;
&lt;p&gt;这篇博客主要内容是，在 Windows 上，使用 Intellj-IDEA 编译运行 Tomcat。&lt;/p&gt;

&lt;p&gt;读源代码，要带着问题去阅读。有一些是自己想的，有一些是 How Tomcat Works[2] 的目录，还有一些来自于别人的博客[3]。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个 Http 请求和响应，是如何转变成 Servlet 的请求和相应的？&lt;/li&gt;
&lt;li&gt;Servlet 是如何抽象 Http 请求的？&lt;/li&gt;
&lt;li&gt;Tomcat 如何管理 tcp 连接？&lt;/li&gt;
&lt;li&gt;Tomcat 如何管理输入输出流？&lt;/li&gt;
&lt;li&gt;Tomcat 的生命周期，如何启动的？如何运行？&lt;/li&gt;
&lt;li&gt;Session 如何管理？&lt;/li&gt;
&lt;li&gt;如何加载类？&lt;/li&gt;
&lt;li&gt;Tomcat 如何管理 servlet 容器，如何连接？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;问题就暂且提出这些。不知道这个 Tomcat 源码阅读系列是否能够完成呢(/▽＼)。不管怎样，先搭个环境，用自己喜欢的 IDE(IntelliJ IDEA) 来阅读、调试源码。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;下载源代码，这里在 github 上下载&lt;/li&gt;
&lt;li&gt;选择正确的 JDK 版本，官方使用的是 JDK 8&lt;/li&gt;
&lt;li&gt;下载 Ant 工具，Tomcat 使用 Ant 来构建&lt;/li&gt;
&lt;li&gt;配置依赖包的下载位置&lt;/li&gt;
&lt;li&gt;使用 Ant 构建&lt;/li&gt;
&lt;li&gt;使用 Ant 创建 IDE 工程，IDE 支持 Intellij-IDEA，NetBean，Eclipse&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;获取源代码，安装对应的 JDK 版本，下面就不解释了。下面主要讲讲如何使用 Ant 工具来开发，在写这篇博客之前，其实我自己也没有想到构建 Tomcat 是很简单的事情。官方还很贴心的考虑到了，开发者可能会使用 IDE 来开发，于是给开发者配置好了环境。使用对应的 Ant 任务就可以有对应 IDE 的工程文件了。下面的步骤，具体可以看官方的&lt;a href=&quot;https://tomcat.apache.org/tomcat-10.0-doc/building.html&quot; target=&quot;_blank&quot;&gt;构建步骤&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;1-安装-ant&quot;&gt;1 安装 Ant&lt;/h2&gt;
&lt;p&gt;直接去&lt;a href=&quot;https://ant.apache.org/bindownload.cgi&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;下载 Ant 的包，然后配置环境变量。&lt;/p&gt;
&lt;p&gt;添加一个新的环境变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;变量名：ANT_HOME
变量值：C:\Program Files\apache-ant-1.9.15
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加如下到 &lt;code&gt;Path&lt;/code&gt; 中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;变量值：%ANT_HOME%\bin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 cmd 当中输入 &lt;code&gt;ant&lt;/code&gt;，如果可以找到命令，那么说明成功了。&lt;/p&gt;
&lt;h2 id=&quot;2-配置下载位置&quot;&gt;2 配置下载位置&lt;/h2&gt;
&lt;p&gt;进入下载好的 Tomcat 目录中，我这里 tomcat 的根目录是 &lt;code&gt;D:\Code\tomcat&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;新建一个文件 &lt;code&gt;build.properties&lt;/code&gt;，复制以下的内容。指定依赖包的保存地址。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# ----- Default Base Path for Dependent Packages -----
# Replace this path with the directory path where dependencies binaries
# should be downloaded
base.path=D:\\Code\\tomcat\\lib
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-使用-ant-构建&quot;&gt;3 使用 Ant 构建&lt;/h2&gt;
&lt;p&gt;输入 &lt;code&gt;ant&lt;/code&gt; 即可，他会先下载构建需要的包，然后构建项目。构建好了如何运行呢？这个请不要着急，往后看会讲的。&lt;/p&gt;
&lt;h2 id=&quot;4-使用-idea-构建&quot;&gt;4 使用 IDEA 构建&lt;/h2&gt;
&lt;p&gt;输入命令 &lt;code&gt;ant ide-intellij&lt;/code&gt; 即可构建 IDEA 的项目。官方还提供了 eclipse 和 netbean。&lt;/p&gt;
&lt;p&gt;接下来，就会下载 IDEA 需要的包，并且会将提供的项目文件复制到 Tomcat 目录下。之后就可以使用 IDEA 来打开了。&lt;/p&gt;
&lt;h2 id=&quot;5-bug&quot;&gt;5 Bug&lt;/h2&gt;
&lt;p&gt;官方的代码里面，&lt;code&gt;build.properties.default&lt;/code&gt; 和 &lt;code&gt;res\ide-support&lt;/code&gt; 下的版本对应不上，于是会出现下面的报错。下面给出两种解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201212231854296-1361161740.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;解决方案一&quot;&gt;解决方案一&lt;/h3&gt;
&lt;p&gt;添加依赖。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;打开 Project Structure&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201212232102407-891801382.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201212232201116-980268535.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;解决方案二&quot;&gt;解决方案二&lt;/h3&gt;
&lt;p&gt;修改 &lt;code&gt;res\ide-support\idea\tomcat.iml&lt;/code&gt; 中对应的版本，然后重新构建就好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201212232335923-656829391.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Tomcat 的运行有两种方式，一种是使用官方的脚本来运行，另一种是使用 &lt;code&gt;org.apache.catalina.startup&lt;/code&gt; 中的 BootStrap 类。&lt;/p&gt;
&lt;h2 id=&quot;方式一&quot;&gt;方式一&lt;/h2&gt;
&lt;p&gt;首先使用 &lt;code&gt;ant&lt;/code&gt; 构建好项目，然后进入 &lt;code&gt;output\build&lt;/code&gt; 文件夹。&lt;/p&gt;
&lt;p&gt;接着修改 &lt;code&gt;conf\logging.properties&lt;/code&gt; 下的编码，不然控制台要输出乱码了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201212232812747-659628906.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后进入，&lt;code&gt;bin\startup.bat&lt;/code&gt; 双击一下就可以运行了。进入 &lt;a href=&quot;http://localhost:8080/&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/&lt;/a&gt; 就可以查看是否运行成功。&lt;/p&gt;
&lt;h2 id=&quot;方式二&quot;&gt;方式二&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;org.apache.catalina.startup&lt;/code&gt; 中的 BootStrap 类。使用 IDEA 来启动这个类。首先要配置好参数，我们把方式一中的命令行参数拷贝到 IDEA 的启动参数里面即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201212233101119-1966861166.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过 IDEA 的控制台输出仍然会有乱码，可以选择使用英文来避免这个问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-Djava.util.logging.config.file=D:\Code\tomcat\output\build\conf\logging.properties
-Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager
-Djdk.tls.ephemeralDHKeySize=2048
-Djava.protocol.handler.pkgs=org.apache.catalina.webresources
-Dcatalina.base=D:\Code\tomcat\output\build
-Dcatalina.home=D:\Code\tomcat\output\build
-Djava.io.tmpdir=D:\Code\tomcat\output\build\temp
-Dfile.encoding=UTF-8
-Duser.language=en
-Duser.region=US
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击启动！so easy。接下来就是一边阅读源码，一边调试看看了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1616773/202012/1616773-20201212233425028-558265568.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;[1] &lt;a href=&quot;https://github.com/apache/tomcat&quot; target=&quot;_blank&quot;&gt;https://github.com/apache/tomcat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] How Tomcat Works 2&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&quot;http://www.iocoder.cn/Tomcat/Tomcat-collection/&quot; target=&quot;_blank&quot;&gt;http://www.iocoder.cn/Tomcat/Tomcat-collection/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] &lt;a href=&quot;https://tomcat.apache.org/tomcat-10.0-doc/building.html&quot; target=&quot;_blank&quot;&gt;https://tomcat.apache.org/tomcat-10.0-doc/building.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 12 Dec 2020 15:39:00 +0000</pubDate>
<dc:creator>楷哥</dc:creator>
<og:description>一，前言 这篇博客写于 12 月 12 日，从 github[1] 上 fork 了一份 tomcat 的源代码，clone 到了本地。最近想把 tomcat 的源代码分析一下，寒假的时候有完整的时间</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzk0/p/14127315.html</dc:identifier>
</item>
<item>
<title>Nginx负载均衡配置 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/nginx_conf.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/nginx_conf.html</guid>
<description>&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;33.5&quot;&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。&lt;/p&gt;
&lt;p&gt;本篇文章主要介绍nginx复杂均衡配置，以及配置过程中遇到的一些问题。负载用的实例以docker为主。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;安装nginx&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;yum -y install nginx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意：若在这一步，遇到错误提示 &lt;code&gt;没有可用软件包 nginx。&lt;/code&gt; ，可以看看文章&lt;a title=&quot;Nginx负载均衡配置 &quot; href=&quot;https://www.cnblogs.com/toutou/p/yum_install_nginx.html&quot; target=&quot;_blank&quot;&gt;《yum install nginx-没有可用软件包 nginx。》&lt;/a&gt;提供了详细的解决办法。&lt;/p&gt;
&lt;p&gt;安装完毕查一下nginx版本号 &lt;code&gt;nginx -v&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;顺便通过 &lt;code&gt;rpm -ql nginx&lt;/code&gt; 查看nginx的安装目录。/etc/nginx主要都是配置文件，/var/log/nginx主要都是nginx相关日志。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/506684/202011/506684-20201127165739934-338724917.png&quot; alt=&quot;Nginx负载均衡配置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图片来源于网络，侵删。&lt;/p&gt;
&lt;p&gt;启动 Nginx ： &lt;code&gt;systemctl start nginx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;若开启了防火墙，可以先关闭防火墙。 &lt;code&gt;systemctl stop firewalld&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置nginx自动启动： &lt;code&gt;systemctl enable nginx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动nginx: &lt;code&gt;systemctl start nginx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关闭nginx： &lt;code&gt;systemctl stop nginx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;重启nginx： &lt;code&gt;systemctl restart nginx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看nginx： &lt;code&gt;systemctl status nginx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看nginx失败原因： &lt;code&gt;systemctl status nginx.service&lt;/code&gt; 或者 &lt;code&gt;journalctl -xe&lt;/code&gt; 。这个很有用，在配置nginx.conf时配错了，启动nginx起不来，可以通过这个命令查看。&lt;/p&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;详解nginx.conf&lt;/h2&gt;
&lt;p&gt;其实我们常说的Nginx负载均衡配置，Nginx负载均衡配置。 一般主要就是配置nginx.conf。&lt;/p&gt;
&lt;p&gt;2.0 nginx.conf默认配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;Nginx负载均衡配置&quot; id=&quot;code_img_closed_82b4eddb-b295-4598-b4bf-85f799e2c05e&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;Nginx负载均衡配置&quot; id=&quot;code_img_opened_82b4eddb-b295-4598-b4bf-85f799e2c05e&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_82b4eddb-b295-4598-b4bf-85f799e2c05e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# For more information on configuration, see:
#   * Official English Documentation: http://nginx.org/en/docs/
#   * Official Russian Documentation: http://nginx.org/ru/docs/

user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.
include /usr/share/nginx/modules/*.conf;

events {
    worker_connections 1024;
}

http {
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    # Load modular configuration files from the /etc/nginx/conf.d directory.
    # See http://nginx.org/en/docs/ngx_core_module.html#include
    # for more information.
    include /etc/nginx/conf.d/*.conf;
    
    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /usr/share/nginx/html;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / {
        }

        error_page 404 /404.html;
        location = /404.html {
        }

        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
        }
    }

# Settings for a TLS enabled server.
#
#    server {
#        listen       443 ssl http2 default_server;
#        listen       [::]:443 ssl http2 default_server;
#        server_name  _;
#        root         /usr/share/nginx/html;
#
#        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;
#        ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;
#        ssl_session_cache shared:SSL:1m;
#        ssl_session_timeout  10m;
#        ssl_ciphers HIGH:!aNULL:!MD5;
#        ssl_prefer_server_ciphers on;
#
#        # Load configuration files for the default server block.
#        include /etc/nginx/default.d/*.conf;
#
#        location / {
#        }
#
#        error_page 404 /404.html;
#        location = /404.html {
#        }
#
#        error_page 500 502 503 504 /50x.html;
#        location = /50x.html {
#        }
#    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2.1 nginx.conf文件目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;...              #全局块

events {         #events块
   ...
}

http      #http块
{
    ...   #http全局块
    server        #server块
    { 
        ...       #server全局块
        location [PATTERN]   #location块
        {
            ...
        }
        location [PATTERN] 
        {
            ...
        }
    }
    server
    {
      ...
    }
    ...     #http全局块
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.2 nginx.conf详解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;######Nginx配置文件nginx.conf中文详解#####

#定义Nginx运行的用户和用户组
user www www;

#nginx进程数，建议设置为等于CPU总核心数。
worker_processes 8;
 
#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]
error_log /usr/local/nginx/logs/error.log info;

#进程pid文件
pid /usr/local/nginx/logs/nginx.pid;

#指定进程可以打开的最大描述符：数目
#工作模式与连接数上限
#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。
#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。
#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。
worker_rlimit_nofile 65535;


events
{
    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型
    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。
    #补充说明：
    #与apache相类，nginx针对不同的操作系统，有不同的事件模型
    #A）标准事件模型
    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll
    #B）高效事件模型
    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。
    #Epoll：使用于Linux内核2.6版本及以后的系统。
    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。
    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。
    use epoll;

    #单个进程最大连接数（最大连接数=连接数*进程数）
    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。
    worker_connections 65535;

    #keepalive超时时间。
    keepalive_timeout 60;

    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。
    #分页大小可以用命令getconf PAGESIZE 取得。
    #[root@web001 ~]# getconf PAGESIZE
    #4096
    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。
    client_header_buffer_size 4k;

    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。
    open_file_cache max=65535 inactive=60s;

    #这个是指多长时间检查一次缓存的有效信息。
    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.
    open_file_cache_valid 80s;

    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。
    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.
    open_file_cache_min_uses 1;
    
    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.
    open_file_cache_errors on;
}
 
 
 
#设定http服务器，利用它的反向代理功能提供负载均衡支持
http
{
    #文件扩展名与文件类型映射表
    include mime.types;

    #默认文件类型
    default_type application/octet-stream;

    #默认编码
    #charset utf-8;

    #服务器名字的hash表大小
    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.
    server_names_hash_bucket_size 128;

    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。
    client_header_buffer_size 32k;

    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。
    large_client_header_buffers 4 64k;

    #设定通过nginx上传文件的大小
    client_max_body_size 8m;

    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。
    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。
    sendfile on;

    #开启目录列表访问，合适下载服务器，默认关闭。
    autoindex on;

    #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用
    tcp_nopush on;
     
    tcp_nodelay on;

    #长连接超时时间，单位是秒
    keepalive_timeout 120;

    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。
    fastcgi_connect_timeout 300;
    fastcgi_send_timeout 300;
    fastcgi_read_timeout 300;
    fastcgi_buffer_size 64k;
    fastcgi_buffers 4 64k;
    fastcgi_busy_buffers_size 128k;
    fastcgi_temp_file_write_size 128k;

    #gzip模块设置
    gzip on; #开启gzip压缩输出
    gzip_min_length 1k;    #最小压缩文件大小
    gzip_buffers 4 16k;    #压缩缓冲区
    gzip_http_version 1.0;    #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）
    gzip_comp_level 2;    #压缩等级
    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。
    gzip_vary on;

    #开启限制IP连接数的时候需要使用
    #limit_zone crawler $binary_remote_addr 10m;



    #负载均衡配置
    upstream jh.w3cschool.cn {
     
        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。
        server 192.168.80.121:80 weight=3;
        server 192.168.80.122:80 weight=2;
        server 192.168.80.123:80 weight=3;

        #nginx的upstream目前支持4种方式的分配
        #1、轮询（默认）
        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。
        #2、weight
        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。
        #例如：
        #upstream bakend {
        #    server 192.168.0.14 weight=10;
        #    server 192.168.0.15 weight=10;
        #}
        #2、ip_hash
        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。
        #例如：
        #upstream bakend {
        #    ip_hash;
        #    server 192.168.0.14:88;
        #    server 192.168.0.15:80;
        #}
        #3、fair（第三方）
        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。
        #upstream backend {
        #    server server1;
        #    server server2;
        #    fair;
        #}
        #4、url_hash（第三方）
        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。
        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法
        #upstream backend {
        #    server squid1:3128;
        #    server squid2:3128;
        #    hash $request_uri;
        #    hash_method crc32;
        #}

        #tips:
        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{
        #    ip_hash;
        #    server 127.0.0.1:9090 down;
        #    server 127.0.0.1:8080 weight=2;
        #    server 127.0.0.1:6060;
        #    server 127.0.0.1:7070 backup;
        #}
        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;

        #每个设备的状态设置为:
        #1.down表示单前的server暂时不参与负载
        #2.weight为weight越大，负载的权重就越大。
        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误
        #4.fail_timeout:max_fails次失败后，暂停的时间。
        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。

        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。
        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug
        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录
        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡
    }
     
     
     
    #虚拟主机的配置
    server
    {
        #监听端口
        listen 80;

        #域名可以有多个，用空格隔开
        server_name www.w3cschool.cn w3cschool.cn;
        index index.html index.htm index.php;
        root /data/www/w3cschool;

        #对******进行负载均衡
        location ~ .*.(php|php5)?$
        {
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
            include fastcgi.conf;
        }
         
        #图片缓存时间设置
        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$
        {
            expires 10d;
        }
         
        #JS和CSS缓存时间设置
        location ~ .*.(js|css)?$
        {
            expires 1h;
        }
         
        #日志格式设定
        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；
        #$remote_user：用来记录客户端用户名称；
        #$time_local： 用来记录访问时间与时区；
        #$request： 用来记录请求的url与http协议；
        #$status： 用来记录请求状态；成功是200，
        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；
        #$http_referer：用来记录从那个页面链接访问过来的；
        #$http_user_agent：记录客户浏览器的相关信息；
        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。
        log_format access '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
        '$status $body_bytes_sent &quot;$http_referer&quot; '
        '&quot;$http_user_agent&quot; $http_x_forwarded_for';
         
        #定义本虚拟主机的访问日志
        access_log  /usr/local/nginx/logs/host.access.log  main;
        access_log  /usr/local/nginx/logs/host.access.404.log  log404;
         
        #对 &quot;/&quot; 启用反向代理
        location / {
            proxy_pass http://127.0.0.1:88;
            proxy_redirect off;
            proxy_set_header X-Real-IP $remote_addr;
             
            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
             
            #以下是一些反向代理的配置，可选。
            proxy_set_header Host $host;

            #允许客户端请求的最大单文件字节数
            client_max_body_size 10m;

            #缓冲区代理缓冲用户端请求的最大字节数，
            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。
            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误
            client_body_buffer_size 128k;

            #表示使nginx阻止HTTP应答代码为400或者更高的应答。
            proxy_intercept_errors on;

            #后端服务器连接的超时时间_发起握手等候响应超时时间
            #nginx跟后端服务器连接超时时间(代理连接超时)
            proxy_connect_timeout 90;

            #后端服务器数据回传时间(代理发送超时)
            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据
            proxy_send_timeout 90;

            #连接成功后，后端服务器响应时间(代理接收超时)
            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）
            proxy_read_timeout 90;

            #设置代理服务器（nginx）保存用户头信息的缓冲区大小
            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小
            proxy_buffer_size 4k;

            #proxy_buffers缓冲区，网页平均在32k以下的设置
            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k
            proxy_buffers 4 32k;

            #高负荷下缓冲大小（proxy_buffers*2）
            proxy_busy_buffers_size 64k;

            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长
            #设定缓存文件夹大小，大于这个值，将从upstream服务器传
            proxy_temp_file_write_size 64k;
        }
         
         
        #设定查看Nginx状态的地址
        location /NginxStatus {
            stub_status on;
            access_log on;
            auth_basic &quot;NginxStatus&quot;;
            auth_basic_user_file confpasswd;
            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。
        }
         
        #本地动静分离反向代理配置
        #所有jsp的页面均交由tomcat或resin处理
        location ~ .(jsp|jspx|do)?$ {
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_pass http://127.0.0.1:8080;
        }
         
        #所有静态文件由nginx直接读取不经过tomcat或resin
        location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|
        pdf|xls|mp3|wma)$
        {
            expires 15d; 
        }
         
        location ~ .*.(js|css)?$
        {
            expires 1h;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;配置nginx.conf&lt;/h2&gt;
&lt;p&gt;3.1 创建springboot工程，添加测试用的接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; toutou
 * @date by 2020/11
 * @des
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Slf4j
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexController {
    @GetMapping(&lt;/span&gt;&quot;/index&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Result index(HttpServletRequest req) {
        String ip &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            InetAddress localHost &lt;/span&gt;=&lt;span&gt; InetAddress.getLocalHost();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (localHost != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; localHost.getHostAddress() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                String[] split &lt;/span&gt;= localHost.getHostAddress().split(&quot;\\.&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (split.length &amp;gt; 1&lt;span&gt;) {
                    ip &lt;/span&gt;= split[split.length - 1&lt;span&gt;];
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ipe) {
            log.warn(&lt;/span&gt;&quot;Caught Exception when get ip&quot;&lt;span&gt;, ipe);
        }

        String message &lt;/span&gt;= String.format(&quot;Server ip:%s; Server Port:%d;Local Port:%d&quot;&lt;span&gt;, ip, req.getServerPort(), req.getLocalPort());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Result.setSuccessResult(message);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不会创建springboot工程的也没有关系，可以看看&lt;a title=&quot;SpringBoot入门教程(一)详解intellij idea搭建SpringBoot&quot; href=&quot;https://www.cnblogs.com/toutou/p/9650939.html&quot; target=&quot;_blank&quot;&gt;SpringBoot入门教程(一)详解intellij idea搭建SpringBoot&lt;/a&gt;，手把手教程。&lt;/p&gt;
&lt;p&gt;3.2 如下图，先创建6个docker springboot实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/506684/202011/506684-20201127170133083-96444643.png&quot; alt=&quot;Nginx负载均衡配置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不会docker部署springboot的话，可以看看&lt;a title=&quot;详解docker部署SpringBoot及如何替换jar包&quot; href=&quot;https://www.cnblogs.com/toutou/p/docker_springboot.html&quot; target=&quot;_blank&quot;&gt;详解docker部署SpringBoot及如何替换jar包&lt;/a&gt;，手把手教程。&lt;/p&gt;
&lt;p&gt;3.3 设置nginx.conf配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.
include /usr/share/nginx/modules/*.conf;

events {
    worker_connections 1024;
}

http {
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    include /etc/nginx/conf.d/*.conf;
    
    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /usr/share/nginx/html;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / {
        }

        error_page 404 /404.html;
        location = /404.html {
        }

        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
        }
    }
    
    upstream hellolearn1 {
        server 127.0.0.1:8301;
        server 127.0.0.1:8302;
        server 127.0.0.1:8303;
    }
    
    server {
        listen       8080;
        server_name  www.toutou.com;

        location / {
            proxy_pass http://hellolearn1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要是在原有的nginx.conf配置文件中追加upstream块和server块。&lt;/p&gt;
&lt;p&gt;客户端host配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ip www.toutou.com
ip www.nginxconfig.com
ip api.nginxconfig.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.4 测试效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/506684/202011/506684-20201127170315996-1341187933.png&quot; alt=&quot;Nginx负载均衡配置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3次请求分别命中了3个docker实例，这是因为上面配置文件upstream块中没有配置nginx负载均衡的分配方式，默认是轮询方式。&lt;/p&gt;
&lt;p&gt;3.5 nginx负载分配方式：&lt;/p&gt;
&lt;p&gt;3.5.1 轮询&lt;/p&gt;
&lt;p&gt;默认方式，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。虽然这种方式简便、成本低廉。但缺点是：可靠性低和负载分配不均衡。适用于图片服务器集群和纯静态页面服务器集群。&lt;/p&gt;
&lt;p&gt;3.5.2 weight(权重分配)&lt;/p&gt;
&lt;p&gt;指定轮询几率，权重越高，在被访问的概率越大，用于后端服务器性能不均的情况。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;upstream hellolearn{ 
    server 127.0.0.1:8001 weight=1; 
    server 127.0.0.1:8002 weight=2; 
    server 127.0.0.1:8003 weight=3;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当Nginx每收到6个请求，会把其中的1个转发给8001，把其中的2个转发给8002，把其中的3个转发给8003。&lt;/p&gt;
&lt;p&gt;3.5.3 ip_hash&lt;/p&gt;
&lt;p&gt;每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;upstream hellolearn{ 
    ip_hash; 
    server 127.0.0.1:8001;
    server 127.0.0.1:8002;
    server 127.0.0.1:8003;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.5.4 fair（第三方）&lt;/p&gt;
&lt;p&gt;按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 nginx-upstream-fair，需要先安装。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;upstream hellolearn{ 
    fair; 
    server 127.0.0.1:8001;
    server 127.0.0.1:8002;
    server 127.0.0.1:8003;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.5.5 url_hash（第三方）&lt;/p&gt;
&lt;p&gt;按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。在upstream中加入hash语句，hash_method是使用的hash算法。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;upstream hellolearn{ 
    server 127.0.0.1:8001;
    server 127.0.0.1:8002;
    server 127.0.0.1:8003;
    hash $request_uri; 
    hash_method crc32; 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;nginx 1.7.2版本后，已经集成了url hash功能，可直接使用，不要安装三方模块。 该信息来自网络，未亲测，感兴趣的朋友可以试试。&lt;/p&gt;
&lt;p&gt;3.6 负载均衡调度中的状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/506684/202011/506684-20201127170935152-1286820953.png&quot; alt=&quot;Nginx负载均衡配置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;upstream hellolearn {
    server 127.0.0.1:8301 down;
    server 127.0.0.1:8302 backup;
    server 127.0.0.1:8303 max_fails=3 fail_timeout=30s;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：若访问nginx提示502的话，可以查看一下日志 &lt;code&gt;less /var/log/nginx/error.log&lt;/code&gt; 。若发现提示Permission denied，输入命令 &lt;code&gt;setsebool -P httpd_can_network_connect 1&lt;/code&gt; 即可解决。&lt;/p&gt;
&lt;h2 id=&quot;_nav_3&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;进阶配置&lt;/h2&gt;
&lt;p&gt;http块中可以有多个upstream块和server块，那么我们就来配置多个upstream块和server块看看什么效果。&lt;/p&gt;
&lt;p&gt;4.1 nginx.conf中追加upstream块和server&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;

include /usr/share/nginx/modules/*.conf;

events {
    worker_connections 1024;
}

http {
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;

    include /etc/nginx/conf.d/*.conf;
    
    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /usr/share/nginx/html;

        # Load configuration files for the default server block.
        include /etc/nginx/default.d/*.conf;

        location / {
        }

        error_page 404 /404.html;
        location = /404.html {
        }

        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
        }
    }
    
    upstream hellolearn1 {
        server 127.0.0.1:8301;
        server 127.0.0.1:8302;
        server 127.0.0.1:8303;
        #server 192.168.118.137:8303;
    }
    
    server {
        listen       8080;
        server_name  www.toutou.com;

        location / {
            proxy_pass http://hellolearn1;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
    
    upstream hellolearn2 {
        server 127.0.0.1:8304;
        server 127.0.0.1:8305;
        server 127.0.0.1:8306;
    }
    
    server {
        listen       8090;
        server_name  www.nginxconfig.com;

        #负载到upstream hellolearn2
        location / {
            proxy_pass http://hellolearn2;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
        
        #匹配以/images/开头的任何查询并停止搜索，表示匹配URL时忽略字母大小写问题
        location ^~ /sayhello/ {
            default_type 'text/plain';
            return 200 &quot;say hello.&quot;;
        }
    }
    
    server {
        listen       8099;
        server_name  ~.*nginxconfig.com;

        #可以匹配所有请求
        location / {
            default_type &quot;text/html;charset=utf-8&quot;;
            return 200 &quot;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;='color:red;'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;我可以匹配所有请求&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;;
        }
        
        #只有当用户请求是/时，才会使用该location下的配置
        location = / {
            default_type &quot;text/html;charset=utf-8&quot;;
            return 404 &quot;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;='color:blue;font-weight: bold;'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;只有根目录才能发现我&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;;
        }
        
        #匹配任何以.red、.blue或者.black结尾的请求。
        location ~* \.(red|blue|black)$ {
            default_type &quot;text/html;charset=utf-8&quot;;
            return 200 &quot;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;red or blue or black&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.2 运行效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/506684/202011/506684-20201130143613030-605898951.png&quot; alt=&quot;Nginx负载均衡配置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在nginx.conf末尾处中追加了一组upstream块和两组server块，其中两组server块共计包含5组location，上图中的5个演示效果，正是对应上末尾追加的5个location块的匹配规则的。&lt;/p&gt;
&lt;p&gt;4.3 server_name的作用&lt;/p&gt;
&lt;p&gt;server name 为虚拟服务器的识别路径。因此不同的域名会通过请求头中的HOST字段，匹配到特定的server块，转发到对应的应用服务器中去。&lt;/p&gt;
&lt;p&gt;server_name与Host的匹配优先级：&lt;/p&gt;
&lt;p&gt;首先选择所有字符串完全匹配的server_name。如：www.toutou.com&lt;/p&gt;
&lt;p&gt;其次选择通配符在前面的server_name。如：*.toutou.com&lt;/p&gt;
&lt;p&gt;其次选择通配符在后面的server_name。如：www.toutou.*&lt;/p&gt;
&lt;p&gt;最后选择使用正在表达式才匹配的server_name。如：~^\.toutou\.com$&lt;/p&gt;
&lt;p&gt;如果上面这些都不匹配&lt;/p&gt;
&lt;p&gt;1、优先选择listen配置项后有default或default_server的&lt;/p&gt;
&lt;p&gt;2、找到匹配listen端口的第一个server块&lt;/p&gt;
&lt;p&gt;4.4 location匹配规则&lt;/p&gt;
&lt;p&gt;location后面的这些 &lt;code&gt;=&lt;/code&gt; 或者 &lt;code&gt;~&lt;/code&gt; 具体是干嘛用的呢，分别介绍一下。&lt;/p&gt;
&lt;p&gt;语法： &lt;code&gt;location [=|~|~*|^~] /uri/ { … }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4.4.1 &lt;code&gt;=&lt;/code&gt; 精确匹配路径，用于不含正则表达式的 uri 前，如果匹配成功，不再进行后续的查找。&lt;/p&gt;
&lt;p&gt;4.4.2 &lt;code&gt;^~&lt;/code&gt; 用于不含正则表达式的 uri； 前，表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找。&lt;/p&gt;
&lt;p&gt;4.4.3 &lt;code&gt;~&lt;/code&gt; 表示用该符号后面的正则去匹配路径，区分大小写。&lt;/p&gt;
&lt;p&gt;4.4.4 &lt;code&gt;~*&lt;/code&gt; 表示用该符号后面的正则去匹配路径，不区分大小写。跟 ~ 优先级都比较低，如有多个location的正则能匹配的话，则使用正则表达式最长的那个。&lt;/p&gt;
&lt;h2 id=&quot;_nav_4&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;博客总结&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Nginx能成为最受欢迎的web服务器之一，功能十分强大，还有很多功能值我们去学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其他参考/学习资料：&lt;/p&gt;
&lt;h2 id=&quot;_nav_5&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a title=&quot;Nginx负载均衡配置&quot; href=&quot;https://github.com/toutouge/javademosecond/tree/master/hellolearn&quot; target=&quot;_blank&quot;&gt;https://github.com/toutouge/javademosecond/tree/master/hellolearn&lt;/a&gt;&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 12 Dec 2020 14:52:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/toutou/p/nginx_conf.html</dc:identifier>
</item>
<item>
<title>自定义Django认证系统的技术方案 - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/14126994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/14126994.html</guid>
<description>&lt;p&gt;Django已经提供了开箱即用的认证系统，但是可能并不满足我们的个性化需求。自定义认证系统需要知道哪些地方可以扩展，哪些地方可以替换。本文就来介绍自定义Django认证系统的相关技术细节。&lt;/p&gt;

&lt;h2 id=&quot;authentication_backends&quot;&gt;AUTHENTICATION_BACKENDS&lt;/h2&gt;
&lt;p&gt;Django默认认证后端为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;['django.contrib.auth.backends.ModelBackend']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在&lt;code&gt;settings.py&lt;/code&gt;中配置AUTHENTICATION_BACKENDS为自定义的认证后端，其本质是Python class，在调用&lt;code&gt;django.contrib.auth.authenticate()&lt;/code&gt;时会进行遍历：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def authenticate(request=None, **credentials):
    &quot;&quot;&quot;
    If the given credentials are valid, return a User object.
    &quot;&quot;&quot;
    for backend, backend_path in _get_backends(return_tuples=True):
        backend_signature = inspect.signature(backend.authenticate)
        try:
            backend_signature.bind(request, **credentials)
        except TypeError:
            # This backend doesn't accept these credentials as arguments. Try the next one.
            continue
        try:
            user = backend.authenticate(request, **credentials)
        except PermissionDenied:
            # This backend says to stop in our tracks - this user should not be allowed in at all.
            break
        if user is None:
            continue
        # Annotate the user object with the path of the backend.
        user.backend = backend_path
        return user

    # The credentials supplied are invalid to all backends, fire signal
    user_login_failed.send(sender=__name__, credentials=_clean_credentials(credentials), request=request)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;列表中的认证后端是有先后顺序的，Django会依次进行认证，只要有后端认证成功，就会结束认证，如果有后端抛出PermissionDenied异常，也会停止认证。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果修改了认证后端，想要用户重新认证，那么需要调用&lt;code&gt;Session.objects.all().delete()&lt;/code&gt;清除session数据，因为session中会缓存已认证过的认证后端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;编写认证后端&quot;&gt;编写认证后端&lt;/h2&gt;
&lt;p&gt;先看看默认认证后端的源码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class ModelBackend(BaseBackend):
    &quot;&quot;&quot;
    Authenticates against settings.AUTH_USER_MODEL.
    &quot;&quot;&quot;

    def authenticate(self, request, username=None, password=None, **kwargs):
        if username is None:
            username = kwargs.get(UserModel.USERNAME_FIELD)
        if username is None or password is None:
            return
        try:
            user = UserModel._default_manager.get_by_natural_key(username)
        except UserModel.DoesNotExist:
            # Run the default password hasher once to reduce the timing
            # difference between an existing and a nonexistent user (#20760).
            UserModel().set_password(password)
        else:
            if user.check_password(password) and self.user_can_authenticate(user):
                return user
            
    ...
    
    def get_user(self, user_id):
        try:
            user = UserModel._default_manager.get(pk=user_id)
        except UserModel.DoesNotExist:
            return None
        return user if self.user_can_authenticate(user) else None

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;ol readability=&quot;8.5&quot;&gt;&lt;li&gt;
&lt;p&gt;继承BaseBackend。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;实现了&lt;code&gt;authenticate()&lt;/code&gt;。（backend也有个authenticate方法，跟&lt;code&gt;django.contrib.auth.authenticate()&lt;/code&gt;不一样哦）&lt;code&gt;authenticate(request=None, **credentials)&lt;/code&gt;方法的第一个入参是&lt;code&gt;request&lt;/code&gt;，可为空，第二个入参是credentials（用户凭证如用户名、密码），示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib.auth.backends import BaseBackend

class MyBackend(BaseBackend):
    def authenticate(self, request, username=None, password=None):
        # Check the username/password and return a user.
        ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用户凭证也可以是token：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib.auth.backends import BaseBackend

class MyBackend(BaseBackend):
    def authenticate(self, request, token=None):
        # Check the token and return a user.
        ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果认证成功就返回User对象，如果认证失败就返回None。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;实现了&lt;code&gt;get_user()&lt;/code&gt;。&lt;code&gt;get_user(user_id)&lt;/code&gt;方法入参是user_id，可以是username/数据库ID等，必须是User的主键，返回值为User对象或者None。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们试着来编写一个认证后端，为了演示效果，我们不用客户端服务器模式，而是在&lt;code&gt;settings.py&lt;/code&gt;文件中增加2个配置，然后用我们自定义的认证后端进行认证，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.conf import settings
from django.contrib.auth.backends import BaseBackend
from django.contrib.auth.hashers import check_password
from django.contrib.auth.models import User

class SettingsBackend(BaseBackend):
    &quot;&quot;&quot;
    认证settings中ADMIN_LOGIN和ADMIN_PASSWORD变量，比如：
    ADMIN_LOGIN = 'admin'
    ADMIN_PASSWORD = 'pbkdf2_sha256$30000$Vo0VlMnkR4Bk$qEvtdyZRWTcOsCnI/oQ7fVOu1XAURIZYoOZ3iq8Dr4M='
    &quot;&quot;&quot;

    def authenticate(self, request, username=None, password=None):
        login_valid = (settings.ADMIN_LOGIN == username)
        pwd_valid = check_password(password, settings.ADMIN_PASSWORD)
        if login_valid and pwd_valid:
            try:
                user = User.objects.get(username=username)
            except User.DoesNotExist:
                # 创建一个新用户
                user = User(username=username)
                user.is_staff = True
                user.is_superuser = True
                user.save()
            return user
        return None

    def get_user(self, user_id):
        try:
            return User.objects.get(pk=user_id)
        except User.DoesNotExist:
            return None
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义认证后端授权&quot;&gt;自定义认证后端授权&lt;/h2&gt;
&lt;p&gt;认证后端可以重写方法&lt;code&gt;get_user_permissions()&lt;/code&gt;, &lt;code&gt;get_group_permissions()&lt;/code&gt;, &lt;code&gt;get_all_permissions()&lt;/code&gt;, &lt;code&gt;has_perm()&lt;/code&gt;, &lt;code&gt;has_module_perms()&lt;/code&gt;, &lt;code&gt;with_perm()&lt;/code&gt;来实现授权。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib.auth.backends import BaseBackend

class MagicAdminBackend(BaseBackend):
    def has_perm(self, user_obj, perm, obj=None):
        # 如果是超管，就会获得所有权限，因为不管perm是什么，都返回True
        return user_obj.username == settings.ADMIN_LOGIN
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以根据业务编写具体的判断逻辑，给不同用户/组授予不同权限。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;user_obj可以是django.contrib.auth.models.AnonymousUser，用来给匿名用户授予某些权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;User有个is_active字段，ModelBackend和RemoteUserBackend不能给is_active=False的用户授权，如果想授权，可以使用AllowAllUsersModelBackend或AllowAllUsersRemoteUserBackend。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;除了增删改查权限，有时我们需要更多的权限，例如，为myapp中的BlogPost创建一个can_publish权限：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法1 meta中配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class BlogPost(models.Model):
    ...
    class Meta:
        permissions = (
            (&quot;can_publish&quot;, &quot;Can Publish Posts&quot;),
        )
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方法2 使用&lt;code&gt;create()&lt;/code&gt;函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from myapp.models import BlogPost
from django.contrib.auth.models import Permission
from django.contrib.contenttypes.models import ContentType

content_type = ContentType.objects.get_for_model(BlogPost)
permission = Permission.objects.create(
    codename='can_publish',
    name='Can Publish Posts',
    content_type=content_type,
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用&lt;code&gt;python manage.py migrate&lt;/code&gt;命令后，就会创建这个新权限，接着就可以在view中编写代码判断用户是否有这个权限来决定能否发表文章。&lt;/p&gt;

&lt;h2 id=&quot;代理模型&quot;&gt;代理模型&lt;/h2&gt;
&lt;p&gt;如果不需要修改表结构，只扩展行为，那么可以使用代理模型。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib.auth.models import User

class MyUser(User):
    class Meta:
        proxy = True

    def do_something(self):
        # ...
        pass
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;onetoonefield&quot;&gt;OneToOneField&lt;/h2&gt;
&lt;p&gt;如果需要扩展字段，那么可以使用OneToOneField。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib.auth.models import User

class Employee(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    department = models.CharField(max_length=100)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样会新增一张表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;CREATE TABLE `user_employee` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `department` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
  `user_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_id` (`user_id`),
  CONSTRAINT `user_employee_user_id_9b2edd10_fk_auth_user_id` FOREIGN KEY (`user_id`) REFERENCES `auth_user` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在代码中使用User也能访问到Employee的属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; u = User.objects.get(username='fsmith')
&amp;gt;&amp;gt;&amp;gt; freds_department = u.employee.department
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;虽然这种方式能实现扩展，但是OneToOneField会增加数据库查询的复杂度，加重数据库处理负担，并不建议采用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;新版Django的推荐做法是，如果不想用默认User模型，那么就把它替换掉。Django除了User模型，还有2个抽象模型AbstractUser和AbstractBaseUser，从源码中可以看到它们的继承关系：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class User(AbstractUser):
    
class AbstractUser(AbstractBaseUser, PermissionsMixin):
    
class AbstractBaseUser(models.Model):
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么不用User模型，还要做2个抽象模型呢？这是因为一般继承有2个用途，一是继承父类的属性和方法，并做出自己的改变或扩展，实现代码重用。但是这种方式会导致子类也包含了父类的实现代码，代码强耦合，所以实践中不会这么做。而是采用第二种方式，把共性的内容抽象出来，只定义属性和方法，不提供具体实现（如java中的接口类），并且只能被继承，不能被实例化。AbstractUser和AbstractBaseUser就是对User的不同程度的抽象，AbstractUser是User的完整实现，可用于扩展User，AbstractBaseUser是高度抽象，可用于完全自定义User。&lt;/p&gt;
&lt;h2 id=&quot;继承abstractuser&quot;&gt;继承AbstractUser&lt;/h2&gt;
&lt;p&gt;除了代理模型和OneToOneField，扩展User的新方式是定义新的MyUser并继承AbstractUser，把User替换掉，再添加额外信息。具体操作步骤我们通过示例来了解：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;替换User最好是创建项目后，首次&lt;code&gt;python manage.py migrate&lt;/code&gt;前，就进行替换，否则数据库的表已经生成，再中途替换，会有各种各样的依赖问题，只能手动解决。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一步，myapp.models中新建MyUser，继承AbstractUser：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib.auth.models import AbstractUser

class MyUser(AbstractUser):
    pass
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步，&lt;code&gt;settings.py&lt;/code&gt;中配置AUTH_USER_MODEL，指定新的用户模型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AUTH_USER_MODEL = 'myapp.MyUser'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步，&lt;code&gt;settings.py&lt;/code&gt;中配置INSTALLED_APPS：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'myapp.apps.MyappConfig'  # 新增
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第四步（可选），如果需要使用Django自带管理后台，那么要在&lt;code&gt;admin.py&lt;/code&gt;中注册：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import MyUser

admin.site.register(MyUser, UserAdmin)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看下数据库中的效果，提交数据迁移：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;python manage.py makemigrations
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行数据迁移：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;python manage.py migrate
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从表能看出来，默认User已经替换为MyUser了：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201212214428531-929873865.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;替换之后，就可以进行扩展了。比如自定义表名：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib.auth.models import AbstractUser

class MyUser(AbstractUser):
 class Meta:
     db_table = &quot;user&quot;
 pass
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;替换User后，就不能直接引用&lt;code&gt;django.contrib.auth.models.User&lt;/code&gt;了，可以使用&lt;code&gt;get_user_model()&lt;/code&gt;函数或者&lt;code&gt;settings.AUTH_USER_MODEL&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;继承abstractbaseuser&quot;&gt;继承AbstractBaseUser&lt;/h2&gt;
&lt;p&gt;继承AbstractUser只能做扩展，如果我们想完全自定义用户模型，那么就需要继承AbstractBaseUser，再重写属性和方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;USERNAME_FIELD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;USERNAME_FIELD是用户模型的唯一标识符，不一定是username，也可以是email、phone等。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;唯一标识符是Django认证后端的要求，如果你实现了自定义认证后端，那么也可以用非唯一标识符作为USERNAME_FIELD。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以参考AbstractUser的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;username = models.CharField(
    _('username'),
    max_length=150,
    unique=True,
    help_text=_('Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.'),
    validators=[username_validator],
    error_messages={
        'unique': _(&quot;A user with that username already exists.&quot;),
    },
)

USERNAME_FIELD = 'username'
    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改为自定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class MyUser(AbstractBaseUser):
    identifier = models.CharField(max_length=40, unique=True)
    ...
    USERNAME_FIELD = 'identifier'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;EMAIL_FIELD&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考AbstractUser的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;email = models.EmailField(_('email address'), blank=True)
EMAIL_FIELD = 'email'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;REQUIRED_FIELDS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;REQUIRED_FIELDS是指必填字段。参考AbstractUser的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;REQUIRED_FIELDS = ['email']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这表示email是必填的，在使用&lt;code&gt;createsuperuser&lt;/code&gt;命令时，会提示必须输入。&lt;/p&gt;
&lt;p&gt;修改为自定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class MyUser(AbstractBaseUser):
    ...
    date_of_birth = models.DateField()
    height = models.FloatField()
    ...
    REQUIRED_FIELDS = ['date_of_birth', 'height']
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不需要再填USERNAME_FIELD和password，因为Django已经默认包含了，只需要填其他字段即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;is_active&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以用来做软删（不删除数据而是把is_active置为False）。参考AbstractUser的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;is_active = models.BooleanField(
        _('active'),
        default=True,
        help_text=_(
            'Designates whether this user should be treated as active. '
            'Unselect this instead of deleting accounts.'
        ),
    )
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;get_full_name()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考AbstractUser的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;    def get_full_name(self):
        &quot;&quot;&quot;
        Return the first_name plus the last_name, with a space in between.
        &quot;&quot;&quot;
        full_name = '%s %s' % (self.first_name, self.last_name)
        return full_name.strip()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;get_short_name()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考AbstractUser的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;    def get_short_name(self):
        &quot;&quot;&quot;Return the short name for the user.&quot;&quot;&quot;
        return self.first_name
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多属性和方法请看源码。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;查看源码的方法：在&lt;code&gt;from django.contrib.auth.models import AbstractBaseUser&lt;/code&gt;代码上，按住&lt;code&gt;CTRL&lt;/code&gt;点击&lt;code&gt;AbstractBaseUser&lt;/code&gt;即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;重写manager&quot;&gt;重写manager&lt;/h2&gt;
&lt;p&gt;如果自定义用户模型改变了username, email, is_staff, is_active, is_superuser, last_login, and date_joined字段，那么可能需要继承BaseUserManager，并重写以下2个方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;create_user(username_field, password=None, **other_fields)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;create_user(username_field, password=None, **other_fields)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib.auth.models import BaseUserManager

class CustomUserManager(BaseUserManager):

    def create_user(self, email, date_of_birth, password=None):
        # create user here
        ...
        
    def create_superuser(self, email, date_of_birth, password=None):
        # create superuser here
        ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;重写权限&quot;&gt;重写权限&lt;/h2&gt;
&lt;p&gt;从AbstractUser的定义可以看到是继承了PermissionsMixin类的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class AbstractUser(AbstractBaseUser, PermissionsMixin):
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以重写权限就是重写PermissionsMixin的属性和方法，如get_user_permissions()、has_perm()等。&lt;/p&gt;
&lt;h2 id=&quot;一个完整示例&quot;&gt;一个完整示例&lt;/h2&gt;
&lt;p&gt;我们把email作为USERNAME_FIELD，并且让date_of_birth必填。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;models.py&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.db import models
from django.contrib.auth.models import (
    BaseUserManager, AbstractBaseUser
)


class MyUserManager(BaseUserManager):
    def create_user(self, email, date_of_birth, password=None):
        &quot;&quot;&quot;
        Creates and saves a User with the given email, date of
        birth and password.
        &quot;&quot;&quot;
        if not email:
            raise ValueError('Users must have an email address')

        user = self.model(
            email=self.normalize_email(email),
            date_of_birth=date_of_birth,
        )

        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, email, date_of_birth, password=None):
        &quot;&quot;&quot;
        Creates and saves a superuser with the given email, date of
        birth and password.
        &quot;&quot;&quot;
        user = self.create_user(
            email,
            password=password,
            date_of_birth=date_of_birth,
        )
        user.is_admin = True
        user.save(using=self._db)
        return user


class MyUser(AbstractBaseUser):
    email = models.EmailField(
        verbose_name='email address',
        max_length=255,
        unique=True,
    )
    date_of_birth = models.DateField()
    is_active = models.BooleanField(default=True)
    is_admin = models.BooleanField(default=False)

    objects = MyUserManager()

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['date_of_birth']

    def __str__(self):
        return self.email

    def has_perm(self, perm, obj=None):
        &quot;Does the user have a specific permission?&quot;
        # Simplest possible answer: Yes, always
        return True

    def has_module_perms(self, app_label):
        &quot;Does the user have permissions to view the app `app_label`?&quot;
        # Simplest possible answer: Yes, always
        return True

    @property
    def is_staff(self):
        &quot;Is the user a member of staff?&quot;
        # Simplest possible answer: All admins are staff
        return self.is_admin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不要忘了在settings.py中修改AUTH_USER_MODEL哦：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;AUTH_USER_MODEL = 'customauth.MyUser'
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;纯技术文太单调，不如来点小吐槽。写了这2篇关于Django认证系统的文章，明白了以前似懂非懂的技术细节。如果平时有需求想自己做个小网站，完全可以用Django来快速实现后端，开箱即用还是有点香。Template和Form不属于前后端分离的技术，在学习时可以选择性跳过。公众号后台回复“加群”,“Python互助讨论群”欢迎你。&lt;/p&gt;
&lt;blockquote readability=&quot;1.025641025641&quot;&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/3.1/topics/auth/customizing/&quot; target=&quot;_blank&quot;&gt;https://docs.djangoproject.com/en/3.1/topics/auth/customizing/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 12 Dec 2020 13:55:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>Django已经提供了开箱即用的认证系统，但是可能并不满足我们的个性化需求。自定义认证系统需要知道哪些地方可以扩展，哪些地方可以替换。本文就来介绍自定义Django认证系统的相关技术细节。 自定义认证</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/14126994.html</dc:identifier>
</item>
<item>
<title>springboot：异步调用@Async - 迷茫中守候</title>
<link>http://www.cnblogs.com/teach/p/14127024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/teach/p/14127024.html</guid>
<description>&lt;p&gt;在后端开发中经常遇到一些耗时或者第三方系统调用的情况，我们知道Java程序一般的执行流程是顺序执行（不考虑多线程并发的情况），但是顺序执行的效率肯定是无法达到我们的预期的，这时就期望可以并行执行，常规的做法是使用多线程或线程池，需要额外编写代码实现。在spring3.0后引入了@Async注解，使用该注解可以达到线程池的执行效果，而且在开发上非常简单。&lt;/p&gt;

&lt;p&gt;springboot是基于spring框架的，在springboot环境下演示@Async注解的使用方式。先看下该注解的定义，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Async {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * A qualifier value for the specified asynchronous operation(s).
     * &amp;lt;p&amp;gt;May be used to determine the target executor to be used when executing this
     * method, matching the qualifier value (or the bean name) of a specific
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executor Executor} or
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.core.task.TaskExecutor TaskExecutor}
     * bean definition.
     * &amp;lt;p&amp;gt;When specified on a class level {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Async} annotation, indicates that the
     * given executor should be used for all methods within the class. Method level use
     * of {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Async#value} always overrides any value set at the class level.
     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 3.1.2
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到该注解只有一个属性，那就是value，从注释上知道value指定的是执行该任务的线程池，也就是说我们可以使用子定义的线程池执行我们的任务，而不是系统默认的。在看该注解上的注解，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是说该注解可以用在方法和类上。标记在类上表示类中的所有方法都以异步方式执行，也就是提交到线程池执行。&lt;/p&gt;

&lt;p&gt;上面简单对@Async注解进行了解释，下面看用法。&lt;/p&gt;
&lt;h2&gt;1、@EnableAsync注解&lt;/h2&gt;
&lt;p&gt;在springboot中要使用@Async注解必须在springboot启动类上使用@EnableAsync注解，开启@Async注解的自动配置，如下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.example.demo.properties.ApplicationPro;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.context.properties.ConfigurationProperties;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.context.properties.EnableConfigurationProperties;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.annotation.EnableAsync;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableConfigurationProperties({ApplicationPro.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;//开启@Async注解的自动配置&lt;/span&gt;
&lt;span&gt;@EnableAsync
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(DemoApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只有在启动类上使用@EnableAsync注解，@Async注解才会生效。&lt;/p&gt;
&lt;h2&gt;2、@Async注解&lt;/h2&gt;
&lt;p&gt;上面使用@EnableAsync注解已经开启了对@Async注解的配置，下面看具体的异步调用类，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.demo.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.example.demo.Student;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.annotation.Async;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.scheduling.annotation.AsyncResult;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Future;

@Service
@Async
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AsyncService {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Future&amp;lt;Student&amp;gt;&lt;span&gt; get(){
        Student stu&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Student(&quot;1&quot;,&quot;3&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;10000l&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; AsyncResult.forValue(stu);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  executeRemote(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;10000l&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先，要使该类让spring管理必须使用@Service注解（或其他注解也可以），然后在类上标记@Async注解，前面说过@Async注解可以在方法或类上使用，在类上使用则表示类中的所有方法均使用异步执行的方式。异步执行类中有两个方法，每个方法为了演示执行的耗时操作均睡眠10s。这两个方法一个是有返回值的，另一个是无返回值的，重点看有返回值的，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Future&amp;lt;Student&amp;gt;&lt;span&gt; get(){
        Student stu&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; Student(&quot;1&quot;,&quot;3&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;10000l&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; AsyncResult.forValue(stu);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么方法的返回值是Future，在@Async注释上有下面这句话，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/985599/202012/985599-20201212212756611-1222108106.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的注解正好可以说明返回Future是没问题，但是我们的方法就是一个普通的方法，要怎么才能返回Future类那，不慌，spring针对@Async注解提供了AsyncResult类，从类名就知道该类就是为了@Async注解准备的，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/985599/202012/985599-20201212213127233-1079635804.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用其中的forValue方法，便可以返回一个带有泛型的Future类了。&lt;/p&gt;
&lt;p&gt;看下测试类，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.demo.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.example.demo.Student;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.example.demo.service.AsyncService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.ResponseBody;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutionException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Future;
@Controller
@RequestMapping(&lt;/span&gt;&quot;async&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerAsyncTest {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AsyncService asyncService;
    @RequestMapping(&lt;/span&gt;&quot;/test&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student get(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start=&lt;span&gt;System.currentTimeMillis();&lt;br/&gt;//调用带有返回值的get方法
        Future&lt;/span&gt;&amp;lt;Student&amp;gt; result=&lt;span&gt;asyncService.get();&lt;br/&gt;//调用无返回值的executeRemote方法
        asyncService.executeRemote();
        
        Student student&lt;/span&gt;=&lt;span&gt;result.get();
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end=&lt;span&gt;System.currentTimeMillis();
        System.out.println(&lt;/span&gt;&quot;执行时间：&quot;+(end-&lt;span&gt;start));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  student;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类就是一个简单的controller，调用了get和executeRemote方法，这两个方法分别会睡眠10s，而且get会有返回值，下面看是否可以拿到get的返回值，并看下调用这两个方法的时间，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/985599/202012/985599-20201212213609480-304473637.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以成功拿到返回值，看执行时间，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
2020-12-12 21:37:43.556  INFO 11780 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 5&lt;span&gt; ms
执行时间：&lt;/span&gt;10006
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行时间是10006ms，也就是10s多，按照上面的分析两个方法分别睡眠了10s，如果同步执行那肯定是20s，把@Async注解去掉看执行时间，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
2020-12-12 21:41:07.840  INFO 11584 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 5&lt;span&gt; ms
执行时间：&lt;/span&gt;20001
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行时间是20001ms，算上两个方法睡眠的时间，和测试类本身的时间，20001ms是没错的。从这里可以看出@Async注解的作用，把每个方法当作任务提交给了线程池，提高了任务执行的时间。&lt;/p&gt;
&lt;p&gt;另外，在获取异步的执行结果使用了下面的方法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Future&amp;lt;Student&amp;gt; result=&lt;span&gt;asyncService.get();
asyncService.executeRemote();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得执行结果&lt;/span&gt;
Student student=result.get();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于在主线程要获得任务的执行结果，使用Future类的get方法获得结果，该结果需要等到任务执行完以后才可以获得。&lt;/p&gt;

&lt;p&gt;本文讲解了异步调用@Async注解的使用，&lt;/p&gt;
&lt;p&gt;1、使用@EnableAsync注解开启对@Async注解的支持；&lt;/p&gt;
&lt;p&gt;2、在类或方法上使用@Async注解；&lt;/p&gt;

&lt;p&gt;有不当之处，欢迎指正，谢谢！&lt;/p&gt;
</description>
<pubDate>Sat, 12 Dec 2020 13:54:00 +0000</pubDate>
<dc:creator>迷茫中守候</dc:creator>
<og:description>在后端开发中经常遇到一些耗时或者第三方系统调用的情况，我们知道Java程序一般的执行流程是顺序执行（不考虑多线程并发的情况），但是顺序执行的效率肯定是无法达到我们的预期的，这时就期望可以并行执行，常规</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/teach/p/14127024.html</dc:identifier>
</item>
<item>
<title>Linux下基于.NET5开发CAX应用 - AnyCAD</title>
<link>http://www.cnblogs.com/anycad/p/develop-cax-application-for-Linux-using-NET5.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anycad/p/develop-cax-application-for-Linux-using-NET5.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;34&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/587154/202012/587154-20201212211635895-567394217.png&quot; class=&quot;desc_img&quot;/&gt;&amp;gt;一文中介绍了如何在.NET5下使用AnyCAD开发应用程序。相比.NET4.x，.NET5一大进步便是可以跨平台，即可以在Linux、Mac也可以使用，实现代码最大程度的复用。本文介绍如何在Linux下基于.NET5来开发三维应用程序。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;98.848370927318&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/anycad/p/anycad-rapid-sdk-for-net5.html&quot; target=&quot;_blank&quot;&gt;&amp;lt;&amp;lt;.NET5下的三维应用程序开发&amp;gt;&amp;gt;&lt;/a&gt;一文中介绍了如何在.NET5下使用AnyCAD开发应用程序。相比.NET4.x，.NET5一大进步便是可以跨平台，即可以在Linux、Mac也可以使用，实现代码最大程度的复用。本文介绍如何在Linux下基于.NET5来开发三维应用程序。&lt;/p&gt;
&lt;h2 id=&quot;1-环境准备&quot;&gt;1. 环境准备&lt;/h2&gt;
&lt;h3 id=&quot;11-下载按照包&quot;&gt;1.1 下载按照包&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;链接: https://pan.baidu.com/s/1bygB0ugyiUYLaS4dY3nW4Q 
提取码: 95q8 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上链接包括.NET5 SDK for Linux和AnyCAD Rapid .NET5 SDK for Linux。&lt;/p&gt;
&lt;h3 id=&quot;12-net5-sdk&quot;&gt;1.2 .NET5 SDK&lt;/h3&gt;
&lt;p&gt;解压dotnet-sdk-5.0.100-linux-x64.tar.gz到 $HOME/dotnet/，即在$HOME/dotnet/目录下可以找到dotnet可执行程序。可执行程序dotnet是编译.NET程序的入口。&lt;/p&gt;
&lt;p&gt;p.s. 这里使用的是免安装方式，你也可以参考微软官方教程安装.NET5 SDK。&lt;/p&gt;
&lt;h3 id=&quot;13-解压anycad-sdk&quot;&gt;1.3 解压AnyCAD SDK&lt;/h3&gt;
&lt;p&gt;解压anycad.rapid.NET.linux.zip 到某一目录，里面包含示例程序和SDK&lt;/p&gt;
&lt;h2 id=&quot;2-编译和运行&quot;&gt;2. 编译和运行&lt;/h2&gt;
&lt;p&gt;SDK里已经准备好了build的shell脚本，在终端运行即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; ./build.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在bin目录即可看到编译好的HiCAD可执行程序。&lt;br/&gt;在终端运行之：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bin/Debug/HiCAD
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到运行界面：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/587154/202012/587154-20201212211635895-567394217.png&quot; alt=&quot;运行界面&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-项目结构&quot;&gt;3. 项目结构&lt;/h2&gt;
&lt;p&gt;项目主要有工程文件和代码文件组成。&lt;/p&gt;
&lt;h3 id=&quot;31-hicadcsproj&quot;&gt;3.1 HiCAD.csproj&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&amp;gt;

 &amp;lt;PropertyGroup&amp;gt;
   &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
   &amp;lt;TargetFramework&amp;gt;net5.0&amp;lt;/TargetFramework&amp;gt;
   &amp;lt;AppendTargetFrameworkToOutputPath&amp;gt;false&amp;lt;/AppendTargetFrameworkToOutputPath&amp;gt;
   &amp;lt;OutputPath&amp;gt;./bin/$(Configuration)&amp;lt;/OutputPath&amp;gt;
 &amp;lt;/PropertyGroup&amp;gt;
 &amp;lt;ItemGroup&amp;gt;
   &amp;lt;Reference Include=&quot;AnyCAD.Foundation.NET5&quot;&amp;gt;
     &amp;lt;HintPath&amp;gt;./bin/$(Configuration)/AnyCAD.Foundation.NET5.dll&amp;lt;/HintPath&amp;gt;
   &amp;lt;/Reference&amp;gt;
 &amp;lt;/ItemGroup&amp;gt;
&amp;lt;/Project&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-programcs&quot;&gt;3.2 Program.cs&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using AnyCAD.Foundation;
using System;

namespace anycad.test
{
   class Program
   {
       static void Main(string[] args)
       {
        //初始化程序
           GlobalInstance.Initialize();
                //创建三维窗口
           WindowCanvas canvas = new WindowCanvas(&quot;AnyCAD .NET5&quot;, true);
           canvas.Initialize(0, 600, 400);
                //创建个盒子
           var box = ShapeBuilder.MakeBox(GP.XOY(), 10,20,30);
           var node = BrepSceneNode.Create(box, null, null, 0.01);
           var scene = canvas.GetContext().GetScene();
           scene.AddNode(node);
           
           // 显示窗口
           canvas.Run();
           
           //释放资源
           canvas.Destroy();
           GlobalInstance.Destroy();

       }
   }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;在Linux下使用.NET5目前比较遗憾的是还不能使用WinForms和WPF。&lt;br/&gt;本文创建的程序比较简单，关于AnyCAD Rapid SDK的更高级用法可以参考&lt;a href=&quot;http://anycad.cn&quot; target=&quot;_blank&quot;&gt;在线文档&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 12 Dec 2020 13:20:00 +0000</pubDate>
<dc:creator>AnyCAD</dc:creator>
<og:description>&amp;lt;&amp;lt;.NET5下的三维应用程序开发&amp;gt;&amp;gt;一文中介绍了如何在.NET5下使用AnyCAD开发应用程序。相比.NET4.x，.NET5一大进步便是可以跨平台，即可以在Linux、Ma</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/anycad/p/develop-cax-application-for-Linux-using-NET5.html</dc:identifier>
</item>
</channel>
</rss>