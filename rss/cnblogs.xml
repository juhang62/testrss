<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Cocos Creator 资源加载流程剖析【六】——场景切换流程 - 深圳-宝爷</title>
<link>http://www.cnblogs.com/ybgame/p/10844766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybgame/p/10844766.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里讨论场景切换的完整流程，从我们调用了loadScene开始切换场景，到场景切换完成背后发生的事情。整个流程可以分为场景加载和场景切换两部分，另外还简单讨论了场景的预加载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2 id=&quot;加载场景的流程&quot;&gt;加载场景的流程&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;loadScene主要做了3件事，通过_getSceneUuid获取要加载场景的信息，对于原生平台的非启动场景执行了cc.LoaderLayer.preload（但查询了所有的代码，并没有发现LoaderLayer的实现，也没有发现任何对cc.runtime赋值的地方），最后&lt;strong&gt;通过_loadSceneByUuid加载场景&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    loadScene: function (sceneName, onLaunched, _onUnloaded) {
        // 同一时间只能有一个场景在加载
        if (this._loadingScene) {
            cc.errorID(1213, sceneName, this._loadingScene);
            return false;
        }
        // 获取场景的信息
        var info = this._getSceneUuid(sceneName);
        if (info) {
            var uuid = info.uuid;
            // 触发一个场景开始加载的事件
            this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
            // 设置当前正在加载的场景
            this._loadingScene = sceneName;
            // 在原生运行时且该场景并非启动场景时，可以进行异步加载。
            if (CC_JSB &amp;amp;&amp;amp; cc.runtime &amp;amp;&amp;amp; uuid !== this._launchSceneUuid) {
                var self = this;
                var groupName = cc.path.basename(info.url) + '_' + info.uuid;
                console.log('==&amp;gt; start preload: ' + groupName);
                var ensureAsync = false;
                // 如果cc.LoaderLayer.preload是异步的，会在preload结束后执行_loadSceneByUuid。否则会在preload结束的下一帧执行_loadSceneByUuid。
                cc.LoaderLayer.preload([groupName], function () {
                    console.log('==&amp;gt; end preload: ' + groupName);
                    if (ensureAsync) {
                        self._loadSceneByUuid(uuid, onLaunched, _onUnloaded);
                    } else {
                        setTimeout(function () {
                            self._loadSceneByUuid(uuid, onLaunched, _onUnloaded);
                        }, 0);
                    }
                });
                ensureAsync = true;
            } else {
                this._loadSceneByUuid(uuid, onLaunched, _onUnloaded);
            }
            return true;
        } else {
            cc.errorID(1214, sceneName);
            return false;
        }
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Creator2.x版本的loadScene则直接多了，执行_getSceneUuid，触发EVENT_BEFORE_SCENE_LOADING事件，再调用_loadSceneByUuid。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    loadScene: function (sceneName, onLaunched, _onUnloaded) {
        if (this._loadingScene) {
            cc.errorID(1208, sceneName, this._loadingScene);
            return false;
        }
        var info = this._getSceneUuid(sceneName);
        if (info) {
            var uuid = info.uuid;
            this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
            this._loadingScene = sceneName;
            this._loadSceneByUuid(uuid, onLaunched, _onUnloaded);
            return true;
        } else {
            cc.errorID(1209, sceneName);
            return false;
        }
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;_loadSceneByUuid方法也很简单，调用了cc.AssetLibrary.loadAsset加载资源，并指定了资源加载结束后的回调，也就是执行runSceneImmediate以及用户传入的onLaunched回调。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;_loadSceneByUuid方法在Creator2.x和Creator1.x中没有区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    _loadSceneByUuid: function (uuid, onLaunched, onUnloaded, dontRunScene) {
        if (CC_EDITOR) {
            if (typeof onLaunched === 'boolean') {
                dontRunScene = onLaunched;
                onLaunched = null;
            }
            if (typeof onUnloaded === 'boolean') {
                dontRunScene = onUnloaded;
                onUnloaded = null;
            }
        }
        console.time('LoadScene ' + uuid);
        cc.AssetLibrary.loadAsset(uuid, function (error, sceneAsset) {
            console.timeEnd('LoadScene ' + uuid);
            var self = cc.director;
            self._loadingScene = '';
            if (error) {
                error = 'Failed to load scene: ' + error;
                cc.error(error);
            } else {
                // runSceneImmediate启动场景
                if (sceneAsset instanceof cc.SceneAsset) {
                    var scene = sceneAsset.scene;
                    scene._id = sceneAsset._uuid;
                    scene._name = sceneAsset._name;
                    if (CC_EDITOR) {
                        if (!dontRunScene) {
                            self.runSceneImmediate(scene, onUnloaded, onLaunched);
                        } else {
                            scene._load();
                            if (onLaunched) {
                                onLaunched(null, scene);
                            }
                        }
                    } else {
                        self.runSceneImmediate(scene, onUnloaded, onLaunched);
                    }
                    return;
                } else {
                    error = 'The asset ' + uuid + ' is not a scene';
                    cc.error(error);
                }
            }
            if (onLaunched) {
                onLaunched(error);
            }
        });
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;loadAsset做的事情也非常简单，就是&lt;strong&gt;调用Loader.load去做真正的加载&lt;/strong&gt;，在加载完成之后将场景所依赖的资源设置给asset.scene.dependAssets，用于场景的释放，另外因为场景并不作为一个可重复使用的资源，所以这里会将场景从Loader中移除。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;loadAsset方法在Creator2.x和Creator1.x中没有区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    loadAsset: function (uuid, callback, options) {
        if (typeof uuid !== 'string') {
            return callInNextTick(callback, new Error('[AssetLibrary] uuid must be string'), null);
        }
        
        var item = {
            uuid: uuid,
            type: 'uuid'
        };
        if (options &amp;amp;&amp;amp; options.existingAsset) {
            item.existingAsset = options.existingAsset;
        }
        Loader.load(item, function (error, asset) {
            if (error || !asset) {
                error = new Error('[AssetLibrary] loading JSON or dependencies failed: ' + (error ? error.message : 'Unknown error'));
            } else {
                if (asset.constructor === cc.SceneAsset) {
                    if (CC_EDITOR &amp;amp;&amp;amp; !asset.scene) {
                        Editor.error('Sorry, the scene data of &quot;%s&quot; is corrupted!', uuid);
                    } else {
                        var key = cc.loader._getReferenceKey(uuid);
                        // 这里其实是递归获取场景这个item的dependKeys数组（去重复）
                        asset.scene.dependAssets = AutoReleaseUtils.getDependsRecursively(key);
                    }
                }
                if (CC_EDITOR || isScene(asset)) {
                    var id = cc.loader._getReferenceKey(uuid);
                    Loader.removeItem(id);
                }
            }
            if (callback) {
                callback(error, asset);
            }
        });
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2 id=&quot;场景运行与切换&quot;&gt;场景运行与切换&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;runSceneImmediate做的事情非常多，大概可以分为以下几个事情（虽然Creator2.x的runSceneImmediate方法写法有些变化，但大体做的事情类似）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新场景的初始化（_load方法)&lt;/li&gt;
&lt;li&gt;将持久节点从旧场景挪到新场景中&lt;/li&gt;
&lt;li&gt;销毁旧场景、自动释放应该释放的资源（旧场景中标记为自动释放且新场景中没有引用到的资源）&lt;/li&gt;
&lt;li&gt;一系列场景切换流程的回调和事件执行
&lt;ul&gt;&lt;li&gt;开始启动场景的回调和事件&lt;/li&gt;
&lt;li&gt;激活并运行新场景&lt;/li&gt;
&lt;li&gt;场景启动完成的回调和事件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    runSceneImmediate: function (scene, onBeforeLoadScene, onLaunched) {
        const console = window.console;    // should mangle
        const INIT_SCENE = CC_DEBUG ? 'InitScene' : 'I';
        const AUTO_RELEASE = CC_DEBUG ? 'AutoRelease' : 'AR';
        const DESTROY = CC_DEBUG ? 'Destroy' : 'D';
        const ATTACH_PERSIST = CC_DEBUG ? 'AttachPersist' : 'AP';
        const ACTIVATE = CC_DEBUG ? 'Activate' : 'A';

        // 场景的初始化，scene._load会调用CCNode的_onBatchCreated
        // 1. PrefabHelper.syncWithPrefab(this); 大多数情况下会跳过
        // 2. _updateDummySgNode将自己的属性同步给sgNode，并确保sgNode是自己的子节点
        // 3. 如果当前节点未激活，则调用ActionManager和EventManager的pauseTarget
        // 4. 遍历子节点调用它们的_onBatchCreated
        if (scene instanceof cc.Scene) {
            console.time(INIT_SCENE);
            scene._load();  // ensure scene initialized
            console.timeEnd(INIT_SCENE);
        }

        // detach persist nodes
        // 将持久节点从旧场景中移除，并暂时保存到persistNodeList中
        var game = cc.game;
        var persistNodeList = Object.keys(game._persistRootNodes).map(function (x) {
            return game._persistRootNodes[x];
        });
        for (let i = 0; i &amp;lt; persistNodeList.length; i++) {
            let node = persistNodeList[i];
            game._ignoreRemovePersistNode = node;
            node.parent = null;
            game._ignoreRemovePersistNode = null;
        }

        var oldScene = this._scene;

        // auto release assets
        // 调用autoRelease进行资源释放，传入旧场景资源和新场景资源进行对比释放
        // 当一个资源【勾选了自动释放且没有被新场景引用到时】就会被释放
        console.time(AUTO_RELEASE);
        var autoReleaseAssets = oldScene &amp;amp;&amp;amp; oldScene.autoReleaseAssets &amp;amp;&amp;amp; oldScene.dependAssets;
        AutoReleaseUtils.autoRelease(autoReleaseAssets, scene.dependAssets, persistNodeList);
        console.timeEnd(AUTO_RELEASE);

        // unload scene
        // 释放旧的场景，销毁所有子节点和组件
        console.time(DESTROY);
        if (cc.isValid(oldScene)) {
            oldScene.destroy();
        }

        this._scene = null;

        // purge destroyed nodes belongs to old scene
        cc.Object._deferredDestroy();
        console.timeEnd(DESTROY);

        // 执行开始加载场景回调并触发对应的事件（其实这里应该是启动场景）
        if (onBeforeLoadScene) {
            onBeforeLoadScene();
        }
        this.emit(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, scene);

        var sgScene = scene;

        // Run an Entity Scene
        if (scene instanceof cc.Scene) {
            this._scene = scene;
            sgScene = scene._sgNode;

            // Re-attach or replace persist nodes
            // 重新添加持久节点到新场景中，如果发现新场景有相同的节点，这里会执行一个替换的操作
            console.time(ATTACH_PERSIST);
            for (let i = 0; i &amp;lt; persistNodeList.length; i++) {
                let node = persistNodeList[i];
                var existNode = scene.getChildByUuid(node.uuid);
                if (existNode) {
                    // scene also contains the persist node, select the old one
                    var index = existNode.getSiblingIndex();
                    existNode._destroyImmediate();
                    scene.insertChild(node, index);
                }
                else {
                    node.parent = scene;
                }
            }
            // 激活新场景
            console.timeEnd(ATTACH_PERSIST);
            console.time(ACTIVATE);
            scene._activate();
            console.timeEnd(ACTIVATE);
        }

        // Run or replace rendering scene
        // 启动或替换场景
        if (!this.getRunningScene()) {
            this.runWithScene(sgScene);
        }
        else {
            this.replaceScene(sgScene);
        }

        // 执行场景启动完成的回调，并触发事件
        if (onLaunched) {
            onLaunched(null, scene);
        }
        this.emit(cc.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;autoRelease传入2个场景的资源，以及持久节点，自动释放掉应该自动释放的资源（下个场景和持久节点引用到的资源不会被释放，标记为自动释放的资源会被释放）&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    autoRelease: function (oldSceneAssets, nextSceneAssets, persistNodes) {
        var releaseSettings = cc.loader._autoReleaseSetting;
        var excludeMap = JS.createMap();

        // collect next scene assets
        // 收集下一个场景所需的资源
        if (nextSceneAssets) {
            for (let i = 0; i &amp;lt; nextSceneAssets.length; i++) {
                excludeMap[nextSceneAssets[i]] = true;
            }
        }

        // collect assets used by persist nodes
        // 收集常驻节点引用的资源
        for (let i = 0; i &amp;lt; persistNodes.length; i++) {
            visitNode(persistNodes[i], excludeMap)
        }

        // remove ununsed scene assets
        // 移除旧场景中不再使用的资源
        if (oldSceneAssets) {
            for (let i = 0; i &amp;lt; oldSceneAssets.length; i++) {
                let key = oldSceneAssets[i];
                if (releaseSettings[key] !== false &amp;amp;&amp;amp; !excludeMap[key]) {
                    cc.loader.release(key);
                }
            }
        }

        // remove auto release assets
        // (releasing asset will change _autoReleaseSetting, so don't use for-in)
        // 释放标记了auto release的资源
        var keys = Object.keys(releaseSettings);
        for (let i = 0; i &amp;lt; keys.length; i++) {
            let key = keys[i];
            if (releaseSettings[key] === true &amp;amp;&amp;amp; !excludeMap[key]) {
                cc.loader.release(key);
            }
        }
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cc.loader.release的实现如下，release并不会去释放它依赖的资源，只是释放这个资源本身。将资源从cc.loader中移除，如果该资源的content是一个cc.Asset，会调用它的release、并release其rawUrls对应的资源。如果是纹理则会调用cc.textureCache.removeTextureForKey进行移除，而声音类型的资源会执行cc.audioEngine.uncache进行释放。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;proto.release = function (asset) {
    if (Array.isArray(asset)) {
        for (let i = 0; i &amp;lt; asset.length; i++) {
            var key = asset[i];
            this.release(key);
        }
    } else if (asset) {
        var id = this._getReferenceKey(asset);
        var item = this.getItem(id);
        if (item) {
            var removed = this.removeItem(id);
            asset = item.content;
            if (asset instanceof cc.Asset) {
                if (CC_JSB &amp;amp;&amp;amp; asset instanceof cc.SpriteFrame &amp;amp;&amp;amp; removed) {
                    // for the &quot;Temporary solution&quot; in deserialize.js
                    asset.release();
                }
                var urls = asset.rawUrls;
                for (let i = 0; i &amp;lt; urls.length; i++) {
                    this.release(urls[i]);
                }
            } else if (asset instanceof cc.Texture2D) {
                cc.textureCache.removeTextureForKey(item.rawUrl || item.url);
            } else if (AUDIO_TYPES.indexOf(item.type) !== -1) {
                cc.audioEngine.uncache(item.rawUrl || item.url);
            }
            if (CC_DEBUG &amp;amp;&amp;amp; removed) {
                this._releasedAssetChecker_DEBUG.setReleased(item, id);
            }
        }
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cc.loader._autoReleaseSetting记录了所有资源是否会自动释放。通过cc.loader.setAutoRelease或setAutoReleaseRecursively可以控制是否自动释放。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;proto.setAutoRelease = function (assetOrUrlOrUuid, autoRelease) {
    var key = this._getReferenceKey(assetOrUrlOrUuid);
    if (key) {
        this._autoReleaseSetting[key] = !!autoRelease;
    }
    else if (CC_DEV) {
        cc.warnID(4902);
    }
};

proto.setAutoReleaseRecursively = function (assetOrUrlOrUuid, autoRelease) {
    autoRelease = !!autoRelease;
    var key = this._getReferenceKey(assetOrUrlOrUuid);
    if (key) {
        this._autoReleaseSetting[key] = autoRelease;

        var depends = AutoReleaseUtils.getDependsRecursively(key);
        for (var i = 0; i &amp;lt; depends.length; i++) {
            var depend = depends[i];
            this._autoReleaseSetting[depend] = autoRelease;
        }
    }
    else if (CC_DEV) {
        cc.warnID(4902);
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;所有loadRes加载进来的资源都会自动执行setAutoReleaseRecursively(uuid, false)，如果我们将某个资源设置为自动释放，然后用loadRes加载了一个依赖了该资源的新资源，之前的自动释放设置会被覆盖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2 id=&quot;预加载场景&quot;&gt;预加载场景&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;preloadScene的实现非常简单，拿到场景信息之后触发EVENT_BEFORE_SCENE_LOADING事件并调用cc.loader.load加载资源。这个流程与切换场景并不冲突，只是让场景资源加载的这个流程提前了而已，预加载的场景就算不是接下来要切换的场景，也不会冲突，但可能造成性能和内存的浪费。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Creator2.x的preloadScene比1.x多了一个onProgress参数，在cc.loader.load的时候传入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    preloadScene: function (sceneName, onLoaded) {
        var info = this._getSceneUuid(sceneName);
        if (info) {
            this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
            cc.loader.load({ uuid: info.uuid, type: 'uuid' }, function (error, asset) {
                if (error) {
                    cc.errorID(1210, sceneName, error.message);
                }
                if (onLoaded) {
                    onLoaded(error, asset);
                }
            });
        } else {
            var error = 'Can not preload the scene &quot;' + sceneName + '&quot; because it is not in the build settings.';
            onLoaded(new Error(error));
            cc.error('preloadScene: ' + error);
        }
    },&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 10 May 2019 07:41:00 +0000</pubDate>
<dc:creator>深圳-宝爷</dc:creator>
<og:description>这里讨论场景切换的完整流程，从我们调用了loadScene开始切换场景，到场景切换完成背后发生的事情。整个流程可以分为场景加载和场景切换两部分，另外还简单讨论了场景的预加载。 加载场景的流程 load</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ybgame/p/10844766.html</dc:identifier>
</item>
<item>
<title>MapReduce Shuffle 和 Spark Shuffle 原理概述 - XIAO的博客</title>
<link>http://www.cnblogs.com/xiaodf/p/10650921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaodf/p/10650921.html</guid>
<description>&lt;h2 id=&quot;shuffle简介&quot;&gt;Shuffle简介&lt;/h2&gt;
&lt;p&gt;Shuffle的本意是洗牌、混洗的意思，把一组有规则的数据尽量打乱成无规则的数据。而在MapReduce中，Shuffle更像是洗牌的逆过程，指的是将map端的无规则输出按指定的规则“打乱”成具有一定规则的数据，以便reduce端接收处理。其在MapReduce中所处的工作阶段是map输出后到reduce接收前，具体可以分为map端和reduce端前后两个部分。&lt;/p&gt;
&lt;p&gt;在shuffle之前，也就是在map阶段，MapReduce会对要处理的数据进行分片（split）操作，为每一个分片分配一个MapTask任务。接下来map会对每一个分片中的每一行数据进行处理得到键值对（key,value）此时得到的键值对又叫做“中间结果”。此后便进入reduce阶段，由此可以看出Shuffle阶段的作用是处理“中间结果”。&lt;/p&gt;
&lt;p&gt;由于Shuffle涉及到了磁盘的读写和网络的传输，因此Shuffle性能的高低直接影响到了整个程序的运行效率。&lt;/p&gt;
&lt;h2 id=&quot;mapreduce-shuffle&quot;&gt;MapReduce Shuffle&lt;/h2&gt;
&lt;p&gt;Hadoop的核心思想是MapReduce，但shuffle又是MapReduce的核心。shuffle的主要工作是从Map结束到Reduce开始之间的过程。shuffle阶段又可以分为Map端的shuffle和Reduce端的shuffle。&lt;/p&gt;
&lt;h3 id=&quot;map端的shuffle&quot;&gt;Map端的shuffle&lt;/h3&gt;
&lt;p&gt;下图是MapReduce Shuffle的官方流程：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201905/852983-20190510150500098-735412163.jpg&quot; width=&quot;90%&quot; height=&quot;90%&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为频繁的磁盘I/O操作会严重的降低效率，因此“中间结果”不会立马写入磁盘，而是优先存储到map节点的“环形内存缓冲区”，在写入的过程中进行分区（partition），也就是对于每个键值对来说，都增加了一个partition属性值，然后连同键值对一起序列化成字节数组写入到缓冲区（缓冲区采用的就是字节数组，默认大小为100M）。&lt;/p&gt;
&lt;p&gt;当写入的数据量达到预先设置的阙值后便会启动溢写出线程将缓冲区中的那部分数据溢出写（spill）到磁盘的临时文件中，并在写入前根据key进行排序（sort）和合并（combine，可选操作）。&lt;/p&gt;
&lt;p&gt;溢出写过程按轮询方式将缓冲区中的内容写到mapreduce.cluster.local.dir属性指定的本地目录中。当整个map任务完成溢出写后，会对磁盘中这个map任务产生的所有临时文件（spill文件）进行归并（merge）操作生成最终的正式输出文件，此时的归并是将所有spill文件中的相同partition合并到一起，并对各个partition中的数据再进行一次排序（sort），生成key和对应的value-list，文件归并时，如果溢写文件数量超过参数min.num.spills.for.combine的值（默认为3）时，可以再次进行合并。&lt;/p&gt;
&lt;p&gt;至此map端的工作已经全部结束，最终生成的文件也会存储在TaskTracker能够访问的位置。每个reduce task不间断的通过RPC从JobTracker那里获取map task是否完成的信息，如果得到的信息是map task已经完成，那么Shuffle的后半段开始启动。&lt;/p&gt;
&lt;h3 id=&quot;reduce端的shuffle&quot;&gt;Reduce端的shuffle&lt;/h3&gt;
&lt;p&gt;当mapreduce任务提交后，reduce task就不断通过RPC从JobTracker那里获取map task是否完成的信息，如果获知某台TaskTracker上的map task执行完成，Shuffle的后半段过程就开始启动。Reduce端的shuffle主要包括三个阶段，copy、merge和reduce。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201905/852983-20190510150603791-1684810657.jpg&quot; width=&quot;90%&quot; height=&quot;90%&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个reduce task负责处理一个分区的文件，以下是reduce task的处理流程：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;reduce task从每个map task的结果文件中拉取对应分区的数据。因为数据在map阶段已经是分好区了，并且会有一个额外的索引文件记录每个分区的起始偏移量。所以reduce task取数的时候直接根据偏移量去拉取数据就ok。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;reduce task从每个map task拉取分区数据的时候会进行再次合并，排序，按照自定义的reducer的逻辑代码去处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;最后就是Reduce过程了，在这个过程中产生了最终的输出结果，并将其写到HDFS上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;为什么要排序&quot;&gt;为什么要排序&lt;/h3&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;key存在combine操作，排序之后相同的key放到一块显然方便做合并操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;reduce task是按key去处理数据的。 如果没有排序那必须从所有数据中把当前相同key的所有value数据拿出来，然后进行reduce逻辑处理。显然每个key到这个逻辑都需要做一次全量数据扫描，影响性能，有了排序很方便的得到一个key对于的value集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;reduce task按key去处理数据时，如果key按顺序排序，那么reduce task就按key顺序去读取，显然当读到的key是文件末尾的key那么就标志数据处理完毕。如果没有排序那还得有其他逻辑来记录哪些key处理完了，哪些key没有处理完。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;虽有千万种理由需要这么做，但是很耗资源，并且像排序其实我们有些业务并不需要排序。&lt;/p&gt;
&lt;h3 id=&quot;为什么要文件合并&quot;&gt;为什么要文件合并&lt;/h3&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;因为内存放不下就会溢写文件，就会发生多次溢写，形成很多小文件，如果不合并，显然会小文件泛滥，集群需要资源开销去管理这些小文件数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;任务去读取文件的数增多，打开的文件句柄数也会增多。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;mapreduce是全局有序。单个文件有序，不代表全局有序，只有把小文件合并一起排序才会全局有序。&lt;/p&gt;
&lt;h2 id=&quot;spark的shuffle&quot;&gt;Spark的Shuffle&lt;/h2&gt;
&lt;p&gt;Spark的Shuffle是在MapReduce Shuffle基础上进行的调优。其实就是对排序、合并逻辑做了一些优化。在Spark中Shuffle write相当于MapReduce 的map，Shuffle read相当于MapReduce 的reduce。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Spark丰富了任务类型，有些任务之间数据流转不需要通过Shuffle，但是有些任务之间还是需要通过Shuffle来传递数据，比如宽依赖的group by key以及各种by key算子。宽依赖之间会划分stage，而Stage之间就是Shuffle，如下图中的stage0，stage1和stage3之间就会产生Shuffle。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201905/852983-20190510150659156-870085203.jpg&quot; width=&quot;90%&quot; height=&quot;90%&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Spark的中，负责shuffle过程的执行、计算和处理的组件主要就是ShuffleManager，也即shuffle管理器。ShuffleManager随着Spark的发展有两种实现的方式，分别为HashShuffleManager和SortShuffleManager，因此spark的Shuffle有Hash Shuffle和Sort Shuffle两种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spark Shuffle发展史&lt;/strong&gt;&lt;br/&gt;Spark 0.8及以前 Hash Based Shuffle&lt;br/&gt;Spark 0.8.1 为Hash Based Shuffle引入File Consolidation机制&lt;br/&gt;Spark 0.9 引入ExternalAppendOnlyMap&lt;br/&gt;Spark 1.1 引入Sort Based Shuffle，但默认仍为Hash Based Shuffle&lt;br/&gt;Spark 1.2 默认的Shuffle方式改为Sort Based Shuffle&lt;br/&gt;Spark 1.4 引入Tungsten-Sort Based Shuffle&lt;br/&gt;Spark 1.6 Tungsten-sort并入Sort Based Shuffle&lt;br/&gt;Spark 2.0 Hash Based Shuffle退出历史舞台&lt;/p&gt;
&lt;p&gt;在Spark的版本的发展，ShuffleManager在不断迭代，变得越来越先进。&lt;br/&gt;在Spark 1.2以前，默认的shuffle计算引擎是HashShuffleManager。该ShuffleManager而HashShuffleManager有着一个非常严重的弊端，就是会产生大量的中间磁盘文件，进而由大量的磁盘IO操作影响了性能。因此在Spark 1.2以后的版本中，默认的ShuffleManager改成了SortShuffleManager。&lt;/p&gt;
&lt;p&gt;SortShuffleManager相较于HashShuffleManager来说，有了一定的改进。主要就在于，每个Task在进行shuffle操作时，虽然也会产生较多的临时磁盘文件，但是最后会将所有的临时文件合并(merge)成一个磁盘文件，因此每个Task就只有一个磁盘文件。在下一个stage的shuffle read task拉取自己的数据时，只要根据索引读取每个磁盘文件中的部分数据即可。&lt;/p&gt;
&lt;h3 id=&quot;hash-shuffle&quot;&gt;Hash Shuffle&lt;/h3&gt;
&lt;p&gt;HashShuffleManager的运行机制主要分成两种，一种是普通运行机制，另一种是合并的运行机制。合并机制主要是通过复用buffer来优化Shuffle过程中产生的小文件的数量。Hash shuffle是不具有排序的Shuffle。&lt;/p&gt;
&lt;h4 id=&quot;普通机制的hash-shuffle&quot;&gt;普通机制的Hash Shuffle&lt;/h4&gt;
&lt;p&gt;最开始使用的Hash Based Shuffle，每个Mapper会根据Reducer的数量创建对应的bucket，bucket的数量是M * R，M是map的数量，R是Reduce的数量。&lt;br/&gt;如下图所示：2个core 4个map task 3 个reduce task，会产生4*3=12个小文件。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201905/852983-20190510151040429-1028493074.jpg&quot; width=&quot;90%&quot; height=&quot;90%&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;优化后的hash-shuffle&quot;&gt;优化后的Hash Shuffle&lt;/h4&gt;
&lt;p&gt;普通机制Hash Shuffle会产生大量的小文件(M * R），对文件系统的压力也很大，也不利于IO的吞吐量，后来做了优化（设置spark.shuffle.consolidateFiles=true开启，默认false），把在同一个core上的多个Mapper输出到同一个文件，这样文件数就变成core * R 个了。&lt;br/&gt;如下图所示：2个core 4个map task 3 个reduce task，会产生2*3=6个小文件。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201905/852983-20190510151107342-948307325.jpg&quot; width=&quot;90%&quot; height=&quot;90%&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hash shuffle合并机制的问题：&lt;br/&gt;如果 Reducer 端的并行任务或者是数据分片过多的话则 Core * Reducer Task 依旧过大，也会产生很多小文件。进而引出了更优化的sort shuffle。&lt;br/&gt;在Spark 1.2以后的版本中，默认的ShuffleManager改成了SortShuffleManager。&lt;/p&gt;
&lt;h3 id=&quot;sort-shuffle&quot;&gt;Sort Shuffle&lt;/h3&gt;
&lt;p&gt;SortShuffleManager的运行机制主要分成两种，一种是普通运行机制，另一种是bypass运行机制。当shuffle read task的数量小于等于spark.shuffle.sort.bypassMergeThreshold参数的值时(默认为200)，就会启用bypass机制。&lt;/p&gt;
&lt;h4 id=&quot;普通机制的sort-shuffle&quot;&gt;普通机制的Sort Shuffle&lt;/h4&gt;
&lt;p&gt;这种机制和mapreduce差不多，在该模式下，数据会先写入一个内存数据结构中，此时根据不同的shuffle算子，可能选用不同的数据结构。如果是reduceByKey这种聚合类的shuffle算子，那么会选用Map数据结构，一边通过Map进行聚合，一边写入内存；如果是join这种普通的shuffle算子，那么会选用Array数据结构，直接写入内存。接着，每写一条数据进入内存数据结构之后，就会判断一下，是否达到了某个临界阈值。如果达到临界阈值的话，那么就会尝试将内存数据结构中的数据溢写到磁盘，然后清空内存数据结构。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201905/852983-20190510151135510-2018946002.jpg&quot; width=&quot;80%&quot; height=&quot;80%&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在溢写到磁盘文件之前，会先根据key对内存数据结构中已有的数据进行排序。排序过后，会分批将数据写入磁盘文件。默认的batch数量是10000条，也就是说，排序好的数据，会以每批1万条数据的形式分批写入磁盘文件。&lt;br/&gt;一个task将所有数据写入内存数据结构的过程中，会发生多次磁盘溢写操作，也会产生多个临时文件。最后会将之前所有的临时磁盘文件都进行合并，由于一个task就只对应一个磁盘文件因此还会单独写一份索引文件，其中标识了下游各个task的数据在文件中的start offset与end offset。&lt;br/&gt;SortShuffleManager由于有一个磁盘文件merge的过程，因此大大减少了文件数量，由于每个task最终只有一个磁盘文件所以文件个数等于上游shuffle write个数。&lt;/p&gt;
&lt;h4 id=&quot;bypass机制的sort-shuffle&quot;&gt;bypass机制的Sort Shuffle&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/852983/201905/852983-20190510151151027-712712994.jpg&quot; width=&quot;90%&quot; height=&quot;90%&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bypass运行机制的触发条件如下：&lt;br/&gt;1)shuffle map task数量小于spark.shuffle.sort.bypassMergeThreshold参数的值，默认值200。&lt;br/&gt;2)不是聚合类的shuffle算子(比如reduceByKey)。&lt;/p&gt;
&lt;p&gt;此时task会为每个reduce端的task都创建一个临时磁盘文件，并将数据按key进行hash然后根据key的hash值，将key写入对应的磁盘文件之中。当然，写入磁盘文件时也是先写入内存缓冲，缓冲写满之后再溢写到磁盘文件的。最后，同样会将所有临时磁盘文件都合并成一个磁盘文件，并创建一个单独的索引文件。&lt;/p&gt;
&lt;p&gt;该过程的磁盘写机制其实跟未经优化的HashShuffleManager是一模一样的，因为都要创建数量惊人的磁盘文件，只是在最后会做一个磁盘文件的合并而已。因此少量的最终磁盘文件，也让该机制相对未经优化的HashShuffleManager来说，shuffle read的性能会更好。&lt;/p&gt;
&lt;p&gt;而该机制与普通SortShuffleManager运行机制的不同在于：&lt;br/&gt;第一，磁盘写机制不同;&lt;br/&gt;第二，不会进行排序。也就是说，启用该机制的最大好处在于，shuffle write过程中，不需要进行数据的排序操作，也就节省掉了这部分的性能开销。&lt;/p&gt;
&lt;h3 id=&quot;spark-shuffle总结&quot;&gt;Spark Shuffle总结&lt;/h3&gt;
&lt;p&gt;Shuffle 过程本质上都是将 Map 端获得的数据使用分区器进行划分，并将数据发送给对应的 Reducer 的过程。&lt;/p&gt;
&lt;p&gt;Shuffle作为处理连接map端和reduce端的枢纽，其shuffle的性能高低直接影响了整个程序的性能和吞吐量。map端的shuffle一般为shuffle的Write阶段，reduce端的shuffle一般为shuffle的read阶段。Hadoop和spark的shuffle在实现上面存在很大的不同，spark的shuffle分为两种实现，分别为HashShuffle和SortShuffle。&lt;/p&gt;
&lt;p&gt;HashShuffle又分为普通机制和合并机制，普通机制因为其会产生M&lt;em&gt;R个数的巨量磁盘小文件而产生大量性能低下的Io操作，从而性能较低，因为其巨量的磁盘小文件还可能导致OOM，HashShuffle的合并机制通过重复利用buffer从而将磁盘小文件的数量降低到Core&lt;/em&gt;R个，但是当Reducer 端的并行任务或者是数据分片过多的时候，依然会产生大量的磁盘小文件。&lt;/p&gt;
&lt;p&gt;SortShuffle也分为普通机制和bypass机制，普通机制在内存数据结构(默认为5M)完成排序，会产生2M个磁盘小文件。而当shuffle map task数量小于spark.shuffle.sort.bypassMergeThreshold参数的值。或者算子不是聚合类的shuffle算子(比如reduceByKey)的时候会触发SortShuffle的bypass机制，SortShuffle的bypass机制不会进行排序，极大的提高了其性能。&lt;/p&gt;
&lt;p&gt;在Spark 1.2以前，默认的shuffle计算引擎是HashShuffleManager，因为HashShuffleManager会产生大量的磁盘小文件而性能低下，在Spark 1.2以后的版本中，默认的ShuffleManager改成了SortShuffleManager。&lt;/p&gt;
&lt;p&gt;SortShuffleManager相较于HashShuffleManager来说，有了一定的改进。主要就在于，每个Task在进行shuffle操作时，虽然也会产生较多的临时磁盘文件，但是最后会将所有的临时文件合并(merge)成一个磁盘文件，因此每个Task就只有一个磁盘文件。在下一个stage的shuffle read task拉取自己的数据时，只要根据索引读取每个磁盘文件中的部分数据即可。&lt;/p&gt;
&lt;h2 id=&quot;spark与mapreduce-shuffle的异同&quot;&gt;Spark与MapReduce Shuffle的异同&lt;/h2&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;从整体功能上看，两者并没有大的差别。 都是将 mapper（Spark 里是 ShuffleMapTask）的输出进行 partition，不同的 partition 送到不同的 reducer（Spark 里 reducer 可能是下一个 stage 里的 ShuffleMapTask，也可能是 ResultTask）。Reducer 以内存作缓冲区，边 shuffle 边 aggregate 数据，等到数据 aggregate 好以后进行 reduce（Spark 里可能是后续的一系列操作）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;从流程的上看，两者差别不小。 Hadoop MapReduce 是 sort-based，进入 combine和 reduce的 records 必须先 sort。这样的好处在于 combine/reduce可以处理大规模的数据，因为其输入数据可以通过外排得到（mapper 对每段数据先做排序，reducer 的 shuffle 对排好序的每段数据做归并）。以前 Spark 默认选择的是 hash-based，通常使用 HashMap 来对 shuffle 来的数据进行合并，不会对数据进行提前排序。如果用户需要经过排序的数据，那么需要自己调用类似 sortByKey的操作。在Spark 1.2之后，sort-based变为默认的Shuffle实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;从流程实现角度来看，两者也有不少差别。 Hadoop MapReduce 将处理流程划分出明显的几个阶段：map, spill, merge, shuffle, sort, reduce等。每个阶段各司其职，可以按照过程式的编程思想来逐一实现每个阶段的功能。在 Spark 中，没有这样功能明确的阶段，只有不同的 stage 和一系列的 transformation，所以 spill, merge, aggregate 等操作需要蕴含在 transformation中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 10 May 2019 07:34:00 +0000</pubDate>
<dc:creator>XIAO的博客</dc:creator>
<og:description>Shuffle简介 Shuffle的本意是洗牌、混洗的意思，把一组有规则的数据尽量打乱成无规则的数据。而在MapReduce中，Shuffle更像是洗牌的逆过程，指的是将map端的无规则输出按指定的规</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaodf/p/10650921.html</dc:identifier>
</item>
<item>
<title>MySQL备份与主备配置 - jxtxzzw</title>
<link>http://www.cnblogs.com/jxtxzzw/p/10844462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jxtxzzw/p/10844462.html</guid>
<description>&lt;p&gt;MYSQL binlog复制主要有三种方式：基于SQL语句的复制(statement-based replication, SBR)，基于行的复制(row-based replication, RBR)，混合模式复制(mixed-based replication, MBR)。对应的，binlog的格式也有三种：STATEMENT，ROW，MIXED。&lt;/p&gt;
&lt;p&gt;① &lt;strong&gt;STATEMENT模式&lt;/strong&gt;（SBR）&lt;/p&gt;
&lt;p&gt;每一条会修改数据的sql语句会记录到binlog中。优点是并不需要记录每一条sql语句和每一行的数据变化，减少了binlog日志量，节约IO，提高性能。缺点是在某些情况下会导致master-slave中的数据不一致(如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题)&lt;/p&gt;
&lt;p&gt;② &lt;strong&gt;ROW模式&lt;/strong&gt;（RBR）&lt;/p&gt;
&lt;p&gt;不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样了。而且不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是alter table的时候会让日志暴涨。&lt;/p&gt;
&lt;p&gt;③ &lt;strong&gt;MIXED模式&lt;/strong&gt;（MBR）&lt;/p&gt;
&lt;p&gt;以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式。&lt;/p&gt;
&lt;h2 id=&quot;mysql-&quot;&gt;MySQL 主备配置&lt;/h2&gt;
&lt;p&gt;在主库上创建用户 repl，并给他权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-mysql&quot;&gt;CREATE USER repl;
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%' IDENTIFIED BY '123456';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1557463740318.png&quot; alt=&quot;1557463740318&quot;/&gt;&lt;br/&gt;检查在主库 my.cnf 中配置 server-id。发现已经配置了。&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1557463809046.png&quot; alt=&quot;1557463809046&quot;/&gt;&lt;br/&gt;然后进配置文件把所有 &lt;code&gt;bind-address=127.0.0.1&lt;/code&gt; 的配置行注释掉。&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1557464115585.png&quot; alt=&quot;1557464115585&quot;/&gt;&lt;br/&gt;在主库执行 &lt;code&gt;show master status;&lt;/code&gt; 记录 binlog 和 pos。&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1557464220695.png&quot; alt=&quot;1557464220695&quot;/&gt;&lt;br/&gt;打开 Ubuntu-Server（从库），修改配置文件（&lt;code&gt;/opt/lampp/etc/my.cnf&lt;/code&gt;）中的 server-id 为 2，重启 MySQL 服务。&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1557464381264.png&quot; alt=&quot;1557464381264&quot;/&gt;&lt;br/&gt;进入数据库，执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-mysql&quot;&gt;change master to master_host='主库IP（这里是192.168.23.129）', master_user='主库用户（这里是repl）', master_password='主库用户密码（这里是123456）', master_log_file=&quot;主库的binlog（这里是mysql-bin.000003）&quot;, master_log_pos=主库的binlog的pos（这里是327）;
start slave;
show slave status\G;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1557464651425.png&quot; alt=&quot;1557464651425&quot;/&gt;&lt;br/&gt;然后在 status 可以看到 slave 的状态是 YES。&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1557466491120.png&quot; alt=&quot;1557466491120&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1557466508070.png&quot; alt=&quot;1557466508070&quot;/&gt;&lt;br/&gt;测试主备。在主库添加一条记录，然后在从库看一下是不是有这条记录。&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1557464970121.png&quot; alt=&quot;1557464970121&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1557464987238.png&quot; alt=&quot;1557464987238&quot;/&gt;&lt;br/&gt;主库成功添加了这条记录。&lt;br/&gt;从库也出现了这条记录。&lt;br/&gt;特别需要指出的是，从库和主库的同步只能是从同步开始设置的那一刻之后的操作才能同步。&lt;br/&gt;举个例子，主库有 100、200、300 这三个用户，从库有 200、300、500 这三个用户：&lt;/p&gt;
</description>
<pubDate>Fri, 10 May 2019 06:57:00 +0000</pubDate>
<dc:creator>jxtxzzw</dc:creator>
<og:description>MySQL备份与主备配置 数据备份类型 全量备份：备份整个数据库 增量备份：备份自上一次备份以来（增量或完全）以来变化的数据 差异备份：备份自上一次完全备份以来变化的数据 全量备份 全量备份的方法有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jxtxzzw/p/10844462.html</dc:identifier>
</item>
<item>
<title>网络应用（1）：抓包获取APP的重要信息 | charles - 广州小程</title>
<link>http://www.cnblogs.com/freeself/p/10844006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeself/p/10844006.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;小白：何为抓包？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小程：就是截获网络上收发的数据包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小白：网络上那么多数据包，怎么知道哪些是有用的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小程：只截获目标app的数据包就缩小了范围，但即便是缩小了范围，也需要进一步分析与排查。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小白：在垃圾堆里找坏人的行动时间与地点吗？这是使徒行者2的桥段啊，你有没有看过？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&quot;抓包看看呗&quot;，这样的话听过不少了吧，不管怎么表达，“抓包”，本质都是分析网络交互时的数据包，以取得想要的信息。&lt;/p&gt;
&lt;p&gt;我们有可能会遇到这样的场景：“对方这个App是怎么实现的？它发送的网络请求有没有带上时间限制？”、“获取这个资源的网络地址是什么，要不要带token？我能够模拟发送吗？” ，等等，而在研究某个APP时，分析网络数据包，往往就是第一个手段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文解决一个问题：通过抓包分析出重要信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抓包的工具有很多，适合在不同的平台上使用。这里只介绍&lt;strong&gt;charles&lt;/strong&gt;的使用。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小白：都有什么样的抓包工具呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小程：比如wireshark、tcpdump、tcpflow、charles、fiddler、sniffer等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小白：为什么只介绍charles，难道其它的不好用吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小白：不是其它的不好用，是我一次只讲一个东西！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;小白：你......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Charles&lt;/strong&gt;，是截取网络数据包的工具。小程这里演示的是mac系统下的charleas使用。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://www.charlesproxy.com&quot; class=&quot;uri&quot;&gt;http://www.charlesproxy.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/%E6%8A%93%E5%8C%85/charles%E5%AE%98%E5%AE%A3.jpg&quot; alt=&quot;charles&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;破解charles&quot;&gt;（1）破解charles&lt;/h4&gt;
&lt;p&gt;用破解的charles.jar，覆盖到程序包内Contents/Java目录即可（比如4.0.1版本）。&lt;/p&gt;
&lt;h4 id=&quot;使用charles&quot;&gt;（2）使用charles&lt;/h4&gt;
&lt;p&gt;charles运行后，就可以看到截获到的数据包。&lt;/p&gt;
&lt;p&gt;charles的视图分“按结构”跟“按顺序（时间先后）”，按顺序时可以筛选。&lt;/p&gt;
&lt;p&gt;两个视图都可以选择特定的url，再选择focus，这样就重点观察这个url的相关请求与响应，不会跳来跳去。&lt;/p&gt;
&lt;p&gt;mac上，抓https包，需要安装ssl证书：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;help-&amp;gt;ssl proxying -&amp;gt;install charles root cer..，
同时要在keychain中信息这个证书（简介-&amp;gt;信任-&amp;gt;ssl设置为始终信任）。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于https包，确定url后，要右击选择&lt;strong&gt;enable ssl proxying&lt;/strong&gt;，才可以做到&lt;strong&gt;解密https包&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可以右键选择&lt;strong&gt;breakpoints&lt;/strong&gt;，这时会监控这个url的相关行为并下断点（可以修改发送请求等），在发送请求时、收到回复时、正在接收response body时，都会触发断点。触发断点后，可以执行“取消（即让其继续执行）”、“中止”、“执行”等操作，比如可以修改请求的值后再执行“execute”。&lt;/p&gt;
&lt;h4 id=&quot;演示获取appstore的app的历史版本&quot;&gt;（3）演示：获取appstore的app的历史版本&lt;/h4&gt;
&lt;p&gt;iphone上使用的一些app，新版本还不如旧版本好使。&lt;/p&gt;
&lt;p&gt;虽然appstore会把很旧的版本的下载链接给隐藏掉，但存货还是在的。&lt;/p&gt;
&lt;p&gt;如果你的itunes不支持appstore了，那你应该安装itunes12.6.3或itunes12.6.5版本，再使用下面的办法，因为这两个版本还能使用appstore，如果都不能下载APP了，那这个演示还怎么进行呢。&lt;/p&gt;
&lt;p&gt;如何通过itunes拿到某个app的所有历史版本的信息，并下载到历史版本呢？&lt;/p&gt;
&lt;p&gt;操作如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;打开charles，再打开itunes并搜索到目标app，再下载这个app，会观察到
https://p23-buy.itunes.apple.com 或 https://buy.itunes.apple.com 
是目标url，focus这个url。

对这个url选择enable ssl proxying，退出charles。

启动charles，删除掉itunes上已下载的目标aap，刷新并重新下载。

这时，在目标url下面的buyProduct页面的contents的response部分，
会显示一个array，是一堆id串，
这个就是不同版本的下载id（用xml text来查看，可拷贝）。

再次删除已下载的app，并对目标url加上breakpoints，再次下载app。

在发送request时会触发断点，选择edit request页面并选择
xml text查看模式，把下载id替换成目标下载id，
之后不断点击execute或取消掉断点再执行。

这时，itunes会下载到目标版本的app，之后可以找到对应的ipa，并同步到手机。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以“微信”为例，大概的步骤是这样的：&lt;/p&gt;
&lt;h5 id=&quot;a下载微信时在charles上focus目标url并激活ssl&quot;&gt;（a）下载微信时，在charles上focus目标url，并激活ssl：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/%E6%8A%93%E5%8C%85/focus%E7%9B%AE%E6%A0%87url.png&quot; alt=&quot;focus目标url&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;b删除已下载的微信启动charles后重新下载微信留意目标url下面的内容&quot;&gt;（b）删除已下载的微信，启动charles后，重新下载微信，留意目标url下面的内容：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/%E6%8A%93%E5%8C%85/%E6%89%BE%E5%88%B0%E7%9B%AE%E6%A0%87id.png&quot; alt=&quot;找到目标id&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;c删除已下载的微信对目标url加上breakpoints再次下载修改请求再execute&quot;&gt;（c）删除已下载的微信，对目标url加上breakpoints，再次下载，修改请求，再execute：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/%E6%8A%93%E5%8C%85/%E5%AF%B9%E7%9B%AE%E6%A0%87url%E4%B8%8B%E6%96%AD%E7%82%B9.png&quot; alt=&quot;对目标url下断点&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/%E6%8A%93%E5%8C%85/%E4%BF%AE%E6%94%B9%E7%9B%AE%E6%A0%87id.png&quot; alt=&quot;修改请求时的目标id&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;d下载到最旧版本的微信&quot;&gt;（d）下载到最旧版本的微信：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/%E6%8A%93%E5%8C%85/%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%80%E6%97%A7%E7%9A%84%E5%BE%AE%E4%BF%A1.png&quot; alt=&quot;下载到最旧的微信&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;演示抓取手机qq音乐歌手详情的信息&quot;&gt;（4）演示：抓取手机qq音乐歌手详情的信息&lt;/h4&gt;
&lt;p&gt;这里演示的是手机上的APP的抓包。操作如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;charles，proxy-&amp;gt;proxy setting，port使用8888，
勾选enalbe transperent http proxying，开启代理。

help-&amp;gt;local ip address，查看charles代理的ip地址。

设置手机，如iphone，wifi信息-&amp;gt;http代理，填写服务器(charles的代理ip)
与端口(8888)。

手机会连接上charles，允许它连接。

对于https协议，手机上需求安装ssl的证书：
在safari上输入http://charlesproxy.com/getssl，跳转安装证书。

锁定目标url，即可拿到数据。
比如，对于iphone上的qq音乐的歌手详情，目标url是
https://u.y.qq.com，focus它，
右键打开ssl proxy，就可以拿到详情信息。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大概的演示是这样的：&lt;/p&gt;
&lt;h5 id=&quot;acharles开启代理&quot;&gt;（a）charles开启代理：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/%E6%8A%93%E5%8C%85/charles%E5%BC%80%E5%90%AF%E5%BC%80%E7%90%86.png&quot; alt=&quot;charles开启代理&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;b手机连上代理后对httpsu.y.qq.com特别处理可以看到歌手信息&quot;&gt;（b）手机连上代理后，对https://u.y.qq.com特别处理，可以看到歌手信息：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/%E6%8A%93%E5%8C%85/qq%E6%AD%8C%E6%89%8B%E4%BF%A1%E6%81%AF.png&quot; alt=&quot;qq歌手信息&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;演示获取抖音短视频的歌曲下载链接&quot;&gt;（5）演示：获取“抖音短视频”的歌曲下载链接&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小白：我知道！这个抖音短视频很好玩的，所有歌曲都只是副歌部分。它的下载链接是可以用的吗？歌曲是否加密了？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小程：可以用，歌曲至少现在是没有加密的。(此话的时间，大概是2018年中)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抖音，这时，大概有50几万首歌曲。&lt;/p&gt;
&lt;p&gt;可以通过搜索接口或者分类歌曲接口，来取得歌曲列表信息。歌曲列表信息是json格式的内容，其中包括这样的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;play_url&quot;: {
    &quot;url_list&quot;: [
        &quot;http://p3.pstatp.com/obj/29c90000eb8b5ca6fff2&quot;
    ], 
    &quot;uri&quot;: &quot;29c90000eb8b5ca6fff2&quot;
}, &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;url_list就是歌曲下载链接（请求时需要带上额外的参数比如cookies等）。除了这个，还可以找到歌手名、歌曲名等。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小白：为什么不详细说说请求链接是什么呀？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小程：因为演示只是为了学习，不应该涉及太多商业的内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;小白：我去！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://free-picture1.oss-cn-shenzhen.aliyuncs.com/%E9%80%BB%E8%BE%91%E9%A2%98/%E9%80%BB25.png&quot; alt=&quot;smile make you pretty&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 May 2019 05:49:00 +0000</pubDate>
<dc:creator>广州小程</dc:creator>
<og:description>小白：何为抓包？ 小程：就是截获网络上收发的数据包。 小白：网络上那么多数据包，怎么知道哪些是有用的？ 小程：只截获目标app的数据包就缩小了范围，但即便是缩小了范围，也需要进一步分析与排查。 小白：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeself/p/10844006.html</dc:identifier>
</item>
<item>
<title>Python3简易接口自动化测试框架设计与实现（上） - 秦无殇</title>
<link>http://www.cnblogs.com/webDepOfQWS/p/10834873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/webDepOfQWS/p/10834873.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;接口开发请参考：&lt;a href=&quot;https://www.cnblogs.com/webDepOfQWS/p/10693152.html&quot; target=&quot;_blank&quot;&gt;使用Django开发简单接口：文章增删改查&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;开发环境&quot;&gt;1、开发环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;操作系统：Ubuntu18&lt;/li&gt;
&lt;li&gt;开发工具：IDEA+PyCharm插件&lt;/li&gt;
&lt;li&gt;Python版本：3.6&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;用到的模块&quot;&gt;2、用到的模块&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;requests：用于发送请求&lt;/li&gt;
&lt;li&gt;xlrd：操作Excel，组织测试用例&lt;/li&gt;
&lt;li&gt;smtplib，email：发送测试报告&lt;/li&gt;
&lt;li&gt;logging：日志追踪&lt;/li&gt;
&lt;li&gt;json：数据格式化&lt;/li&gt;
&lt;li&gt;Django：接口开发&lt;/li&gt;
&lt;li&gt;configparser：读取配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;框架设计&quot;&gt;3、框架设计&lt;/h2&gt;
&lt;h3 id=&quot;流程&quot;&gt;3.1、流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201905/631850-20190510133551390-1300511121.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接口用例是通过Excel来组织的，定义了URL，Request Body等列。执行流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用xlrd工具读取Excel中的信息，拼接成一个个完整的请求。&lt;/li&gt;
&lt;li&gt;接口请求类拿到一个个完整的请求的去执行，这个过程需要记录日志，每一次执行情况都要有迹可循。&lt;/li&gt;
&lt;li&gt;回填测试结果，发送邮件，归档每次的运行结果。更好一点的做法是把历史运行情况做个报表，更直观。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用例通过Excel来组织，不需要编写代码，上手难度小。&lt;/li&gt;
&lt;li&gt;在用例个数不是很多的情况，开发速度快。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用例依赖是痛点。&lt;/li&gt;
&lt;li&gt;只能支持接口自动化用例。&lt;/li&gt;
&lt;li&gt;Excel中用例无法预先检查正确性，只有跑一把才能知道。&lt;/li&gt;
&lt;li&gt;无法很好地管理大量用例，且不支持团队协同作业，个人用来回归测试或上线后的冒烟测试会是一个不错的选择。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过优缺点的对比，可以明显发现这个框架的硬伤其实很多了。所以无论是业界开源的自动化测试框架或企业自研的还没有见过用Excel来组织用例的。值得一提的是个别企业自研的自动化框架非常难用，抑或是把一堆工具简单组合到一起。根本无法提高团队的生产力。不过好的产品也不是一蹴而就的，需要一个持续优化的过程。所以上面用Excel组织用例的框架还是值的玩一玩的，暂且命名为apitest吧。目前比较好的自动化测试框架有unittest，testng，pytest等。&lt;/p&gt;
&lt;h3 id=&quot;项目结构&quot;&gt;3.2、项目结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631850/201905/631850-20190510133648519-1134155465.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;testcase：存放测试用例或请求的json文件。&lt;/li&gt;
&lt;li&gt;config：配置文件。&lt;/li&gt;
&lt;li&gt;report：测试报告和日志文件及其归档。&lt;/li&gt;
&lt;li&gt;untils：工具集，send_request用来发送请求，email_tool用来发送邮件，excel_tool用来读取Excel中的数据，check_result用来校验结果，run_main用例执行入口，log_trace用来追踪日志。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;日志打印&quot;&gt;5、日志打印&lt;/h2&gt;
&lt;p&gt;采用内置logging模块才记录运行日志，设置日志级别。&lt;br/&gt;log_trace.log:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import  logging
filename = &quot;../report/test_case_run.log&quot;
logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s %(levelname)s1 %(filename)s [line:%(lineno)d]  %(message)s',
                    datefmt='%a, %d %b %Y %H:%M:%S',
                    filename=filename,
                    filemode='w')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;接口请求类封装&quot;&gt;6、接口请求类封装&lt;/h2&gt;
&lt;p&gt;安装第三方模块requests&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install requests&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义函数send_request，根据传入的方法类型分别去调用request的get，post，delete，put等方法去发送请求。send_request.py:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import  requests
from untils. log_trace import  *

#发送get请求
def get_request(url,data=None,headers=None):
    res = requests.get(url=url,data=data,headers=headers)
    return res

#发送post请求
def post_request(url,data,headers=None):
    res = requests.post(url=url,data=data,headers=headers)
    return res

#发送delete请求
def del_request(url,data=None,headers=None):
    res = requests.delete(url,data=data)
    return res

#发送put请求
def put_request(url,data,headers=None):
    pass

def send_request(method,url,data=None,headers=None):
    try:
        logging.info(headers)
        if headers:
            if method == &quot;GET&quot;:
                return get_request(url,data,headers=headers)
            if method == &quot;POST&quot;:
                return post_request(url,data=data,headers=headers)
            if method == &quot;DELETE&quot;:
                return  del_request(url,data=data,headers=headers)
            #put使用频率低，暂时不写
            if method == &quot;PUT&quot;:
                return  put_request(url,data=data,headers=headers)
        else:
            logging.info(&quot;Header is null&quot;)
    except Exception as e:
        logging.info(&quot;send request fail:%s&quot;%e)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在untils_test.py中编写代码测试send_request方法，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#coding:utf-8
from untils.send_request import send_request

def test_send_request():
    url=&quot;http://127.0.0.1:9000/articles/&quot;
    headers = {
        &quot;X-Token&quot;:&quot;0a6db4e59c7fff2b2b94a297e2e5632e&quot;
    }
    res = send_request(&quot;GET&quot;,url,headers=headers)
    print(res.json())



if __name__ == &quot;__main__&quot;:
    test_send_request()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/usr/bin/python3.6 /home/stephen/IdeaProjects/apitest/untils/untils_test.py
{'status': 'BS.200', 'all_titles': {'amy1': 'alive', 'modifytest': 'alive', 'addTest': 'alive'}, 'msg': 'query articles sucess.'}

Process finished with exit code 0
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 10 May 2019 05:44:00 +0000</pubDate>
<dc:creator>秦无殇</dc:creator>
<og:description>基于Python3，采用requests，logging，xlrd，email，smtplib等库实现简易接口自动化框架设计与开发。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/webDepOfQWS/p/10834873.html</dc:identifier>
</item>
<item>
<title>Dell服务器安装系统中遇到的坑 - hezzzzzzz</title>
<link>http://www.cnblogs.com/hezhuoheng/p/10843898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hezhuoheng/p/10843898.html</guid>
<description>&lt;p&gt;在本学期开学初期，由于后续实验的需要，老师为我们配置了服务器，该服务器的型号为Dell Power R730。&lt;/p&gt;
&lt;p&gt;由于我也是一个小白，在服务器安装系统的过程中，遇到了一些麻烦，在这里记录下来，希望自己能够在后续的工作中能够避免。&lt;/p&gt;
&lt;p&gt;首先，介绍我的初期工作以及遇到的麻烦；其次我将根据这些麻烦，将我的解决办法记录下来。&lt;/p&gt;
&lt;p&gt;初期工作：&lt;/p&gt;
&lt;p&gt;服务器到手的时候，我还是比较自信的，总觉得这就是一个主机，只是和平时的微型计算机不同，只不过硬件功能强大了许多。&lt;/p&gt;
&lt;p&gt;我的安装步骤很明确，通过网上下载WIN10系统，利用U盘装机大师制作U盘启动盘，完成；（这部分的工作很简单，需要下载两个软件，第一个是WIN10系统软件，第二个是U盘装机大师软件）&lt;/p&gt;
&lt;p&gt;带着我的小U盘开开心心的装系统去了~&lt;/p&gt;
&lt;p&gt;过程比较顺利，按照提示操作即可&lt;/p&gt;
&lt;p&gt;1.在该服务器上，需要操作的就是进入BIOS系统设置启动项的问题，在BIOS Setting中打开找到集成设备，需要打开USB端口，之后需要修改BIOS启动项为UEFI；&lt;/p&gt;
&lt;p&gt;2.接着重新启动，开机时按照提示按F11进入Boot Manager，进入One -shot BIOS menu，找到USB启动项即可进入PE装机界面；（在该过程中，重启后，插入U盘，如未提示有usb接口项，返回上一界面后重新进入即可）&lt;/p&gt;
&lt;p&gt;3.在PE装机过程中，最好利用“驱动装载”进行安装，效果比较好；&lt;/p&gt;
&lt;p&gt;4.安装完成后，重启电脑，修改之前设置过得BIOS设置，重新改为BIOS启动项；（如果不修改回来，系统仍然会默认为接口启动项）&lt;/p&gt;

&lt;p&gt;接下来主要讲一下坑在哪里：首先系统装完后，打开了电脑，WIN10界面，什么都有，就和普通电脑一样，很简单。但是......发现找不到硬盘了！&lt;/p&gt;
&lt;p&gt;我的第一反应应该是驱动的问题，于是百度之，开始查到的结果是什么没有驱动程序，服务器的硬盘需要有RAID驱动程序，系统的原因，应该下载Windows server系统等等......&lt;/p&gt;
&lt;p&gt;我思考后的处理办法是，重新下载系统，下载Windows server 2016，但是在系统下载过程中，由于找不到官网的系统，同时网上找的系统在安装到后半程始终会提示错误，折腾了半天，我又换了思路，下载驱动。&lt;/p&gt;
&lt;p&gt;网上提示的有RAID的驱动，但是我并没有下载，我首先了解了什么是RAID，通过对资料的学习，其实这个就是一个硬盘阵列，是需要自己去配置的，百度之后才知道，原来在系统安装之前，需要对RAID进行配置，就是在开机的时候，按F10即可；&lt;/p&gt;
&lt;p&gt;于是操作了一遍，配置RAID的时候，需要选择RAID5，按照提示就可以了，网上操作的版本基本上是绿底的，我这边显示的是白底，有界面的，这个没有那么多讲究，配置好就行，之后会提示部署OS，这里的话需要的是光盘安装，如果是U盘装系统，配置完RAID后就可以返回我刚才讲的1-4步骤就可以了。、&lt;/p&gt;
&lt;p&gt;重新进入系统，硬盘就显示出来了。&lt;/p&gt;

&lt;p&gt;总结：在服务器系统安装过程中，最好是配合光盘进行安装，最重要的第一步是配置RAID磁盘阵列，如果有光盘，则配合OS部署直接安装；如果是U盘安装，第二步则按照1-4方法即可。服务器系统安装过程持续了2天半，开销花费在45元，分别是买U盘30元，迅雷会员15元0.0，充会员的原因在于，期间不断的更换系统安装，需要下载很多内容，如果不充值，实在是太慢了，有钱能解决一切的问题，那就用钱吧，制作U盘启动盘需要格式化U盘，所以，购买了一个新的U盘~&lt;/p&gt;
&lt;p&gt;说了那么多废话，其实总的来说，给服务器装系统，和普通机器装系统的差别就在于磁盘阵列的配置~~&lt;/p&gt;
</description>
<pubDate>Fri, 10 May 2019 05:25:00 +0000</pubDate>
<dc:creator>hezzzzzzz</dc:creator>
<og:description>在本学期开学初期，由于后续实验的需要，老师为我们配置了服务器，该服务器的型号为Dell Power R730。 由于我也是一个小白，在服务器安装系统的过程中，遇到了一些麻烦，在这里记录下来，希望自己能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hezhuoheng/p/10843898.html</dc:identifier>
</item>
<item>
<title>Docker 私有仓库搭建 - 程序员果果</title>
<link>http://www.cnblogs.com/huanchupkblog/p/10843800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huanchupkblog/p/10843800.html</guid>
<description>&lt;h2 id=&quot;一简介&quot;&gt;一、简介&lt;/h2&gt;
&lt;p&gt;在 Docker 中，当我们执行 docker pull xxx 的时候 ，它实际上是从 registry.hub.docker.com 这个地址去查找，这就是Docker公司为我们提供的公共仓库。在工作中，我们不可能把企业项目push到公有仓库进行管理。所以为了更好的管理镜像，Docker不仅提供了一个中央仓库，同时也允许我们搭建本地私有仓库。这一篇介绍registry、harbor两种私有仓库搭建。&lt;/p&gt;
&lt;h2 id=&quot;二registry-的搭建&quot;&gt;二、registry 的搭建&lt;/h2&gt;
&lt;h3 id=&quot;搭建&quot;&gt;1. 搭建&lt;/h3&gt;
&lt;p&gt;Docker 官方提供了一个搭建私有仓库的镜像 &lt;strong&gt;registry&lt;/strong&gt; ，只需把镜像下载下来，运行容器并暴露5000端口，就可以使用了。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker pull registry:2&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --name myregistry registry:2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Registry服务默认会将上传的镜像保存在容器的/var/lib/registry，我们将主机的/opt/registry目录挂载到该目录，即可实现将镜像保存到主机的/opt/registry目录了。&lt;/p&gt;
&lt;p&gt;浏览器访问http://127.0.0.1:5000/v2，出现下面情况说明registry运行正常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190510124454040-1840171525.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;验证&quot;&gt;2. 验证&lt;/h3&gt;
&lt;p&gt;现在通过push镜像到registry来验证一下。&lt;/p&gt;
&lt;p&gt;查看本地镜像：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ docker images
REPOSITORY                                             TAG                 IMAGE ID            CREATED             SIZE
nginx                                                  latest              568c4670fa80        5 weeks ago         109MB
ubuntu                                                 latest              93fd78260bd1        7 weeks ago         86.2MB
elasticsearch                                          6.5.1               32f93c89076d        7 weeks ago         773MB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要通过docker tag将该镜像标志为要推送到私有仓库：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker tag nginx:latest localhost:5000/nginx:latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 docker push 命令将 nginx 镜像 push到私有仓库中：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker push localhost:5000/nginx:latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问 &lt;a href=&quot;http://127.0.0.1:5000/v2/_catalog&quot; class=&quot;uri&quot;&gt;http://127.0.0.1:5000/v2/_catalog&lt;/a&gt; 查看私有仓库目录，可以看到刚上传的镜像了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190510124508006-1783029974.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载私有仓库的镜像，使用如下命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker pull localhost:5000/镜像名:版本号
例如
docker pull localhost:5000/nginx:latest&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二harbor-的搭建&quot;&gt;二、harbor 的搭建&lt;/h2&gt;
&lt;p&gt;docker 官方提供的私有仓库 registry，用起来虽然简单 ，但在管理的功能上存在不足。 Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，harbor使用的是官方的docker registry(v2命名是distribution)服务去完成。harbor在docker distribution的基础上增加了一些安全、访问控制、管理的功能以满足企业对于镜像仓库的需求。&lt;/p&gt;
&lt;h3 id=&quot;搭建-1&quot;&gt;1.搭建&lt;/h3&gt;
&lt;h4 id=&quot;下载&quot;&gt;下载&lt;/h4&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/goharbor/harbor/releases&quot; class=&quot;uri&quot;&gt;https://github.com/goharbor/harbor/releases&lt;/a&gt; 本文是有 v1.2.2&lt;/p&gt;
&lt;h4 id=&quot;配置&quot;&gt;配置&lt;/h4&gt;
&lt;p&gt;解压下载的安装包 harbor-offline-installer-v1.2.2.tgz&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;tar -xvf harbor-offline-installer-v1.2.2.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改 harbor.cfg&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#hostname 改为本地ip，非 Mac OS系统 可以不指定端口
hostname = 192.168.31.143:9090
#设置secretkey_path 的路径为 当前目录的data下
secretkey_path = ./data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是，非 Mac 用户只需要 修改 harbor.cfg 中的 hostname ，就可以直接通过./install.sh 就可以构建镜像，并把服务启动起来。不需要 secretkey_path 和 下面 docker-compose.yml 的修改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改 docker-compose.yml&lt;/p&gt;
&lt;p&gt;因为harbor使用了很多目录挂载，Mac有很多目录是不允许挂载的，所以如果是Mac用户，需要修改docker-compose.yml 中的挂载目录，修改后的 docker-compose.yml 如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;version: '2'
services:
  log:
    image: vmware/harbor-log:v1.2.2
    container_name: harbor-log 
    restart: always
    volumes:
      - ./log/:/var/log/docker/:z
    ports:
      - 127.0.0.1:1514:514
    networks:
      - harbor
  registry:
    image: vmware/registry:2.6.2-photon
    container_name: registry
    restart: always
    volumes:
      - ./data/registry:/storage:z
      - ./common/config/registry/:/etc/registry/:z
    networks:
      - harbor
    environment:
      - GODEBUG=netdns=cgo
    command:
      [&quot;serve&quot;, &quot;/etc/registry/config.yml&quot;]
    depends_on:
      - log
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;registry&quot;
  mysql:
    image: vmware/harbor-db:v1.2.2
    container_name: harbor-db
    restart: always
    volumes:
      - ./data/database:/var/lib/mysql:z
    networks:
      - harbor
    env_file:
      - ./common/config/db/env
    depends_on:
      - log
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;mysql&quot;
  adminserver:
    image: vmware/harbor-adminserver:v1.2.2
    container_name: harbor-adminserver
    env_file:
      - ./common/config/adminserver/env
    restart: always
    volumes:
      - ./data/config/:/etc/adminserver/config/:z
      - ./data/secretkey:/etc/adminserver/key:z
      - ./data/:/data/:z
    networks:
      - harbor
    depends_on:
      - log
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;adminserver&quot;
  ui:
    image: vmware/harbor-ui:v1.2.2
    container_name: harbor-ui
    env_file:
      - ./common/config/ui/env
    restart: always
    volumes:
      - ./common/config/ui/app.conf:/etc/ui/app.conf:z
      - ./common/config/ui/private_key.pem:/etc/ui/private_key.pem:z
      - ./data/secretkey:/etc/ui/key:z
      - ./data/ca_download/:/etc/ui/ca/:z
      - ./data/psc/:/etc/ui/token/:z
    networks:
      - harbor
    depends_on:
      - log
      - adminserver
      - registry
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;ui&quot;
  jobservice:
    image: vmware/harbor-jobservice:v1.2.2
    container_name: harbor-jobservice
    env_file:
      - ./common/config/jobservice/env
    restart: always
    volumes:
      - ./data/job_logs:/var/log/jobs:z
      - ./common/config/jobservice/app.conf:/etc/jobservice/app.conf:z
      - ./data/secretkey:/etc/jobservice/key:z
    networks:
      - harbor
    depends_on:
      - ui
      - adminserver
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;jobservice&quot;
  proxy:
    image: vmware/nginx-photon:1.11.13
    container_name: nginx
    restart: always
    volumes:
      - ./common/config/nginx:/etc/nginx:z
    networks:
      - harbor
    ports:
      - 9090:80
      - 443:443
      - 4443:4443
    depends_on:
      - mysql
      - registry
      - ui
      - log
    logging:
      driver: &quot;syslog&quot;
      options:  
        syslog-address: &quot;tcp://127.0.0.1:1514&quot;
        tag: &quot;proxy&quot;
networks:
  harbor:
    external: false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过运行 install.sh 构建镜像，并把服务启动起来：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./install.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用&quot;&gt;2. 使用&lt;/h3&gt;
&lt;p&gt;访问 &lt;a href=&quot;http://127.0.0.1:9090/&quot; class=&quot;uri&quot;&gt;http://127.0.0.1:9090/&lt;/a&gt; 如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190510124522460-1493599159.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认 admin 用户的密码为 Harbor12345 ，可以在 harbor.cfg 进行修改。登录后如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190510124534293-1210147109.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中的项目是之前上传的 ，新部署的 Harbor 登录后项目下是空的。&lt;/p&gt;
&lt;p&gt;可以创建项目，创建用户，给项目分配用户等等，操作都很简单 。&lt;/p&gt;
&lt;h3 id=&quot;上传镜像&quot;&gt;3. 上传镜像&lt;/h3&gt;
&lt;p&gt;首先登录私有仓库，可以使用 admin 用户 ，也可以使用我们自己创建的具有上传权限的用户：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker login -u admin -p Harbor12345 127.0.0.1:9090&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要通过docker tag将该镜像标志为要推送到私有仓库，例如：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker tag nginx:latest 127.0.0.1:9090/library/nginx:latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上传镜像：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;docker push 127.0.0.1:9090/library/nginx:latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问 &lt;a href=&quot;http://127.0.0.1:9090/harbor/projects&quot; class=&quot;uri&quot;&gt;http://127.0.0.1:9090/harbor/projects&lt;/a&gt; ，在 library 项目下可以看见刚上传的 nginx镜像了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201905/528977-20190510124545176-1698547303.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎扫码或微信搜索公众号《程序员果果》关注我，关注有惊喜~&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/528977/201903/528977-20190311112108481-2022563516.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 May 2019 04:46:00 +0000</pubDate>
<dc:creator>程序员果果</dc:creator>
<og:description>一、简介 在 Docker 中，当我们执行 docker pull xxx 的时候 ，它实际上是从 registry.hub.docker.com 这个地址去查找，这就是Docker公司为我们提供的公</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huanchupkblog/p/10843800.html</dc:identifier>
</item>
<item>
<title>python接口自动化（三十三）-python自动发邮件总结及实例说明番外篇——下（详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10832048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10832048.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;div readability=&quot;26&quot;&gt;
&lt;p&gt;　　发邮件前我们需要了解的是邮件是怎么一个形式去发送到对方手上的，通俗点来说就是你写好一封信，然后装进信封，写上地址，贴上邮票，然后就近找个邮局，把信仍进去，其他的就不关心了，只是关心时间，而电子邮件不像日常发送邮件的按天算，时间都是按&lt;/p&gt;
&lt;p&gt;秒算的。&lt;/p&gt;
&lt;p&gt;电子邮件的发送流程：&lt;/p&gt;
&lt;p&gt;1、你使用某款电子邮件软件MUA：mail user agent --邮件用户代理，填写完成点击发送&lt;/p&gt;
&lt;p&gt;2、在你点击发送的时候电子邮件软件发出去，到MTA：mail transfer agent--邮件传输代理，即email服务提供商，如网易等&lt;/p&gt;
&lt;p&gt;3、MTA--邮箱传输代理会把邮箱投递到邮件的最终目的地MDA：mail delivery agent---邮箱投递服务&lt;/p&gt;
&lt;p&gt;4、email到达MDA后就会放在某个服务器上，存在数据库里，收件人必须通过MUA从MDA中把邮箱放到自己电脑上&lt;/p&gt;
&lt;p&gt;发件人 -&amp;gt; MUA -&amp;gt; MTA -&amp;gt; MTA -&amp;gt; 若干个MTA -&amp;gt; MDA&amp;lt;-MUA&amp;lt;-收件人&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;python发邮件需要掌握两个模块的用法，smtplib和email，这俩模块是python自带的，只需import即可使用。smtplib模块主要负责发送邮件，email模块主要负责构造邮件。&lt;/p&gt;
&lt;p&gt;smtplib模块主要负责发送邮件：是一个发送邮件的动作，连接邮箱服务器，登录邮箱，发送邮件（有发件人，收信人，邮件内容）。&lt;/p&gt;
&lt;p&gt;email模块主要负责构造邮件：指的是邮箱页面显示的一些构造，如发件人，收件人，主题，正文，附件等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190510090233349-828034619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.smtplib模块&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;smtplib使用较为简单。以下是最基本的语法。&lt;/p&gt;
&lt;p&gt;导入及使用方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import smtplib
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; smtp =&lt;span&gt; smtplib.SMTP() 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; smtp.connect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.163.com,25&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;smtp.login(username, password) 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;smtp.sendmail(sender, receiver, msg.as_string()) 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; smtp.quit()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;smtplib.SMTP()：实例化SMTP()&lt;/p&gt;
&lt;p&gt;connect(host,port):&lt;/p&gt;
&lt;p&gt;host:指定连接的邮箱服务器。常用邮箱的smtp服务器地址如下：&lt;/p&gt;
&lt;p&gt;新浪邮箱：smtp.sina.com,新浪VIP：smtp.vip.sina.com,搜狐邮箱：smtp.sohu.com，126邮箱：smtp.126.com,139邮箱：smtp.139.com,163网易邮箱：smtp.163.com。&lt;/p&gt;
&lt;p&gt;port：指定连接服务器的端口号，默认为25.&lt;/p&gt;
&lt;p&gt;login(user,password):&lt;/p&gt;
&lt;p&gt;user:登录邮箱的用户名。&lt;/p&gt;
&lt;p&gt;password：登录邮箱的密码，像笔者用的是网易邮箱，网易邮箱一般是网页版，需要用到客户端密码，需要在网页版的网易邮箱中设置授权码，该授权码即为客户端密码。&lt;/p&gt;
&lt;p&gt;sendmail(from_addr,to_addrs,msg,...):&lt;/p&gt;
&lt;p&gt;from_addr:邮件发送者地址&lt;/p&gt;
&lt;p&gt;to_addrs:邮件接收者地址。发送邮件，多人时用list，字符串列表['接收地址1','接收地址2','接收地址3',...]或'接收地址'&lt;/p&gt;
&lt;p&gt;msg：发送消息：邮件内容。邮件正文是一个str，一般是msg.as_string():as_string()是将msg(MIMEText对象或者MIMEMultipart对象)变为str。&lt;/p&gt;
&lt;p&gt;quit(): 退出关闭邮箱，用于结束SMTP会话。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2.email模块&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;email模块下有mime包，mime英文全称为“Multipurpose Internet Mail Extensions”，即多用途互联网邮件扩展，是目前互联网电子邮件普遍遵循的邮件技术规范。&lt;/p&gt;
&lt;p&gt;该mime包下常用的有三个模块：&lt;strong&gt;text&lt;/strong&gt;，image，multpart。&lt;/p&gt;
&lt;p&gt;导入方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
from email.mime.multipart import MIMEMultipart    
from email.mime.text import MIMEText    
from email.mime.image import MIMEImage
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造一个邮件对象就是一个&lt;code&gt;Message&lt;/code&gt;对象，如果构造一个&lt;code&gt;MIMEText&lt;/code&gt;对象，就表示一个文本邮件对象，如果构造一个&lt;code&gt;MIMEImage&lt;/code&gt;对象，就表示一个作为附件的图片，要把多个对象组合起来，就用&lt;code&gt;MIMEMultipart&lt;/code&gt;对象，而&lt;code&gt;MIMEBase&lt;/code&gt;可以表示任何对象。它们的继承关系如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;undefined&quot;&gt;Message
+- MIMEBase
   +- MIMEMultipart
   +- MIMENonMultipart
      +- MIMEMessage
      +- MIMEText
      +- MIMEImage&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.1 text说明&lt;/p&gt;
&lt;p&gt;邮件发送程序为了防止有些邮件阅读软件不能显示处理HTML格式的数据，通常都会用两类型分别为&quot;text/plain&quot;和&quot;text/html&quot;&lt;/p&gt;
&lt;p&gt;构造MIMEText对象时，第一个参数是邮件正文，第二个参数是MIME的subtype，最后一定要用utf-8编码保证多语言兼容性。&lt;/p&gt;
&lt;p&gt;2.1.1添加普通文本&lt;/p&gt;
&lt;p&gt;方法很简单，在构造MIMEText对象时，把TEXT字符串传进去，再把第二个参数plain和第三个参数编码传进去即可。plain表示纯文本 ，后面的则是编译，保证多语言兼容 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
text = &quot;Hi!\nHow are you?\nHere is the link you wanted:\nhttps://www.cnblogs.com/du-hong&quot;    
text_plain = MIMEText(text,'plain', 'utf-8')    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看MIMEText属性：&lt;strong&gt;可以观察到MIMEText，MIMEImage和MIMEMultipart的属性都一样。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
print dir(text_plain)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;['__contains__', '__delitem__', '__doc__', '__getitem__', '__init__', '__len__', '__module__', '__setitem__', '__str__', '_charset', '_default_type', '_get_params_preserve', '_headers', '_payload', '_unixfrom', 'add_header', 'as_string', 'attach', 'defects', 'del_param', 'epilogue', 'get', 'get_all', 'get_boundary', 'get_charset', 'get_charsets', 'get_content_charset', 'get_content_maintype', 'get_content_subtype', 'get_content_type', 'get_default_type', 'get_filename', 'get_param', 'get_params', 'get_payload', 'get_unixfrom', 'has_key', 'is_multipart', 'items', 'keys', 'preamble', 'replace_header', 'set_boundary', 'set_charset', 'set_default_type', 'set_param', 'set_payload', 'set_type', 'set_unixfrom', 'values', 'walk']&lt;/p&gt;
&lt;p&gt;2.1.2添加超文本(HTML)&lt;/p&gt;
&lt;p&gt;方法也很简单，在构造MIMEText对象时，把HTML字符串传进去，再把第二个参数由plain变为html就可以了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; html = &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &amp;lt;html&amp;gt;  
&lt;span&gt; 3&lt;/span&gt;   &amp;lt;body&amp;gt;  
&lt;span&gt; 4&lt;/span&gt;     &amp;lt;p&amp;gt; 
&lt;span&gt; 5&lt;/span&gt;        Here &lt;span&gt;is&lt;/span&gt; the &amp;lt;a href=&lt;span&gt;&quot;https://www.cnblogs.com/du-hong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;link&amp;lt;/a&amp;gt;&lt;span&gt; you wanted.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &amp;lt;/p&amp;gt; 
&lt;span&gt; 7&lt;/span&gt;   &amp;lt;/body&amp;gt;  
&lt;span&gt; 8&lt;/span&gt; &amp;lt;/html&amp;gt;  
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;    
&lt;span&gt;10&lt;/span&gt; text_html = MIMEText(html,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.1.3添加附件&lt;/p&gt;
&lt;p&gt;首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
sendfile=open(r'D:\pythontest\text.txt','rb').read()
text_att = MIMEText(sendfile, 'base64', 'utf-8')    
text_att[&quot;Content-Type&quot;] = 'application/octet-stream'    
text_att[&quot;Content-Disposition&quot;] = 'attachment; filename=&quot;显示的名字.txt&quot;'  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.2 image说明&lt;/p&gt;
&lt;p&gt;添加图片：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
sendimagefile=open(r'D:\pythontest\testimage.png','rb').read()
image = MIMEImage(sendimagefile)
image.add_header('Content-ID','&amp;lt;image1&amp;gt;')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看MIMEImage属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
print dir(image)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;['__contains__', '__delitem__', '__doc__', '__getitem__', '__init__', '__len__', '__module__', '__setitem__', '__str__', '_charset', '_default_type', '_get_params_preserve', '_headers', '_payload', '_unixfrom', 'add_header', 'as_string', 'attach', 'defects', 'del_param', 'epilogue', 'get', 'get_all', 'get_boundary', 'get_charset', 'get_charsets', 'get_content_charset', 'get_content_maintype', 'get_content_subtype', 'get_content_type', 'get_default_type', 'get_filename', 'get_param', 'get_params', 'get_payload', 'get_unixfrom', 'has_key', 'is_multipart', 'items', 'keys', 'preamble', 'replace_header', 'set_boundary', 'set_charset', 'set_default_type', 'set_param', 'set_payload', 'set_type', 'set_unixfrom', 'values', 'walk']&lt;/p&gt;
&lt;p&gt;2.3 multpart说明&lt;/p&gt;
&lt;p&gt;常见的multipart类型有三种：multipart/alternative, multipart/related和multipart/mixed。&lt;/p&gt;
&lt;p&gt;邮件类型为&quot;multipart/alternative&quot;的邮件包括纯文本正文（text/plain）和超文本正文（text/html）。&lt;/p&gt;
&lt;p&gt;邮件类型为&quot;multipart/related&quot;的邮件正文中包括图片，声音等内嵌资源。&lt;/p&gt;
&lt;p&gt;邮件类型为&quot;multipart/mixed&quot;的邮件包含附件。向上兼容，如果一个邮件有纯文本正文，超文本正文，内嵌资源，附件，则选择mixed类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
msg = MIMEMultipart('mixed')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们必须把Subject，From，To，Date添加到MIMEText对象或者MIMEMultipart对象中，邮件中才会显示主题，发件人，收件人，时间（若无时间，就默认一般为当前时间，该值一般不设置）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
msg = MIMEMultipart('mixed') 
msg['Subject'] = 'Python email test'
msg['From'] = 'XXX@163.com &amp;lt;XXX@163.com&amp;gt;'
msg['To'] = 'XXX@126.com'
msg['Date']='2019-5-10'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看MIMEMultipart属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
msg = MIMEMultipart('mixed') 
print dir(msg) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;['__contains__', '__delitem__', '__doc__', '__getitem__', '__init__', '__len__', '__module__', '__setitem__', '__str__', '_charset', '_default_type', '_get_params_preserve', '_headers', '_payload', '_unixfrom', 'add_header', 'as_string', 'attach', 'defects', 'del_param', 'epilogue', 'get', 'get_all', 'get_boundary', 'get_charset', 'get_charsets', 'get_content_charset', 'get_content_maintype', 'get_content_subtype', 'get_content_type', 'get_default_type', 'get_filename', 'get_param', 'get_params', 'get_payload', 'get_unixfrom', 'has_key', 'is_multipart', 'items', 'keys', 'preamble', 'replace_header', 'set_boundary', 'set_charset', 'set_default_type', 'set_param', 'set_payload', 'set_type', 'set_unixfrom', 'values', 'walk']&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;msg.add_header(_name,_value,**_params):添加邮件头字段。&lt;/p&gt;
&lt;p&gt;msg.as_string():是将msg(MIMEText对象或者MIMEMultipart对象)变为str,&lt;strong&gt;如果只有一个html超文本正文或者plain普通文本正文的话，一般msg的类型可以是MIMEText；如果是多个的话，就都添加到MIMEMultipart，msg类型就变为MIMEMultipart。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;msg.attach(MIMEText对象或MIMEImage对象):将MIMEText对象或MIMEImage对象添加到MIMEMultipart对象中。MIMEMultipart对象代表邮件本身，MIMEText对象或MIMEImage对象代表邮件正文。&lt;/p&gt;
&lt;p&gt;以上的构造的文本，超文本，附件，图片都何以添加到MIMEMultipart('mixed')中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
msg.attach(text_plain)    
msg.attach(text_html)    
msg.attach(text_att)    
msg.attach(image)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;3.文字，html，图片，附件实现实例&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;3.1实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190510112838820-1608628037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.2运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190510113010537-33392216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.3参考代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #&lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;10&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-&lt;span&gt;宏哥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用邮箱发文字，html，图片，附件实现实例邮件
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; #&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import smtplib
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; email.mime.multipart import MIMEMultipart
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; email.mime.text import MIMEText
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; email.mime.image import MIMEImage
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; email.header import Header
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;# 设置smtplib所需的参数
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;# 下面的发件人，收件人是用于邮件传输的。
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; smtpserver = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.mxhichina.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; username = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;noreply@xxx.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; password = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxxx@@xx3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; sender = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;noreply@xxx.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;# 收件人为一个收件人
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; # receiver=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;XXX@126.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;# 收件人为多个收件人
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; receiver = [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1918991791@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2014816656@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hongge@xxx.cn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; subject = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python email test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; # 通过Header对象编码的文本，包含utf-&lt;span&gt;8编码信息和Base64编码信息。以下中文名测试ok
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; # subject = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;中文标题&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; # subject=Header(subject, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).encode()
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;# 构造邮件对象MIMEMultipart对象
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;# 下面的主题，发件人，收件人，日期是显示在邮件页面上的。
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; msg = MIMEMultipart(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mixed&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; msg[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Subject&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; subject
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; msg[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;From&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京-宏哥&amp;lt;noreply@xxx.cn&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; # msg[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;To&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1918991791@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2014816656@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hongge@xxx.cn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;# 收件人为多个收件人,通过join将列表转换为以;为间隔的字符串
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; msg[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;To&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.join(receiver)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; # msg[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2019-5-10&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;# 构造文字内容
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hi!\nHow are you?\nHere is the link you wanted:\nhttps://www.cnblogs.com/du-hong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; text_plain = MIMEText(text, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;plain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;msg.attach(text_plain)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;# 构造图片链接
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; sendimagefile = open(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\pythontest\testimage.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).read()
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; image =&lt;span&gt; MIMEImage(sendimagefile)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; image.add_header(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-ID&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;image1&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; image[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;attachment; filename=&quot;honggeimage.png&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;msg.attach(image)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;# 构造html
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; # 发送正文中的图片:由于包含未被许可的信息，网易邮箱定义为垃圾邮件，报554 DT:SPM ：&amp;lt;p&amp;gt;&amp;lt;img src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cid:image1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/p&amp;gt;
&lt;span&gt;57&lt;/span&gt; html = &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &amp;lt;html&amp;gt;  
&lt;span&gt;59&lt;/span&gt;   &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;  
&lt;span&gt;60&lt;/span&gt;   &amp;lt;body&amp;gt;  
&lt;span&gt;61&lt;/span&gt;     &amp;lt;p&amp;gt;Hi!&amp;lt;br&amp;gt;  
&lt;span&gt;62&lt;/span&gt;        How are you?&amp;lt;br&amp;gt;  
&lt;span&gt;63&lt;/span&gt;        Here &lt;span&gt;is&lt;/span&gt; the &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/du-hong/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;link 北京-宏哥&amp;lt;/a&amp;gt; you wanted.&amp;lt;br&amp;gt; 
&lt;span&gt;64&lt;/span&gt;     &amp;lt;/p&amp;gt; 
&lt;span&gt;65&lt;/span&gt;   &amp;lt;/body&amp;gt;  
&lt;span&gt;66&lt;/span&gt; &amp;lt;/html&amp;gt;  
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; text_html = MIMEText(html, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; text_html[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;attachment; filename=&quot;texthtml.html&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt; &lt;span&gt;msg.attach(text_html)
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt; &lt;span&gt;# 构造附件
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; sendfile = open(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\pythontest\text.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).read()
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; text_att = MIMEText(sendfile, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;base64&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; text_att[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/octet-stream&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt; &lt;span&gt;# 以下附件可以重命名成aaa.txt
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; # text_att[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;attachment; filename=&quot;aaa.txt&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;78&lt;/span&gt; &lt;span&gt;# 另一种实现方式
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; text_att.add_header(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;attachment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, filename=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hongge.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;# 以下中文测试不ok
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; # text_att[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;attachment; filename=&quot;中文附件.txt&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;msg.attach(text_att)
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; 
&lt;span&gt;84&lt;/span&gt; &lt;span&gt;# 发送邮件
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; smtp =&lt;span&gt; smtplib.SMTP()
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; smtp.connect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.mxhichina.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; # 我们用set_debuglevel(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)就可以打印出和SMTP服务器交互的所有信息。
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; # smtp.set_debuglevel(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt; &lt;span&gt;smtp.login(username, password)
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;smtp.sendmail(sender, receiver, msg.as_string())
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; smtp.quit()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div readability=&quot;21&quot;&gt;
&lt;p&gt;对有些 header 要特别留意，服务器会针对这些 header 做检查&lt;/p&gt;
&lt;p&gt;User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求&lt;/p&gt;
&lt;p&gt;Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。常见的取值有：&lt;/p&gt;
&lt;p&gt;application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用&lt;/p&gt;
&lt;p&gt;application/json ： 在 JSON RPC 调用时使用&lt;/p&gt;
&lt;p&gt;application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用&lt;/p&gt;
&lt;p&gt;在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt; 　　好了，哈哈，到这里把python发邮件的十八辈祖宗都被我们挖出来了，自己都感觉到有点缺德，但是我们学习就是需要这种精神，但是也不要过于钻牛角筋，要适可而止。想必小伙伴们对python发邮件有了更深刻的认识了，以后遇到类似的问题，&lt;/p&gt;
&lt;p&gt;往上套就可以了，但是要注意方式和方法，不要生搬硬套，生搬硬套又会出现问题，要灵活有技巧的套。&lt;/p&gt;
</description>
<pubDate>Fri, 10 May 2019 04:00:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 发邮件前我们需要了解的是邮件是怎么一个形式去发送到对方手上的，通俗点来说就是你写好一封信，然后装进信封，写上地址，贴上邮票，然后就近找个邮局，把信仍进去，其他的就不关心了，只是关心时间，而电子邮</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/du-hong/p/10832048.html</dc:identifier>
</item>
<item>
<title>TCP/IP协议族——高性能Linux服务器编程 - luke_44</title>
<link>http://www.cnblogs.com/luke44/p/10101047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luke44/p/10101047.html</guid>
<description>&lt;p&gt;现在 Internet 使用的主流协议族是 TCP/IP 协议族，它是一个分层、多协议的通信体系。&lt;/p&gt;
&lt;h2 id=&quot;tcpip-协议族体系结构以及主要协议&quot;&gt;TCP/IP 协议族体系结构以及主要协议&lt;/h2&gt;
&lt;p&gt;TCP/IP 协议族是一个四层协议系统，自底面上分别是数据链路层、网络层、传输层和应用层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。&lt;/p&gt;
&lt;h3 id=&quot;数据链路层&quot;&gt;数据链路层&lt;/h3&gt;
&lt;p&gt;数据链路层实现了网卡接口的网络驱动程序，处理数据在物理媒介上的传输。常用的两个协议是 ARP (Address Resoleve Protocol 地址解析协议) 和 RARP (Reverse Address Resoleve Protocol 逆地址解析协议)，它们实现了 IP 地址和机器物理地址之间的相互转换。&lt;/p&gt;
&lt;h3 id=&quot;网络层&quot;&gt;网络层&lt;/h3&gt;
&lt;p&gt;网络层实现数据包的选路和转发。由于通信的主机一般不是直接相连的，而是通过多个中间节点(路由器)连接的，网络层的任务就是选择这些节点，以确定通信路径。网络层的核心协议是 IP (Internet Protocol 因特网协议)。另一个重要的协议是 ICMP (Internet Control Message Protocol 因特网控制报文协议)，是 IP 协议的重要补充，主要用于检测网络连接，ping 程序就是使用的 ICMP 协议。&lt;/p&gt;
&lt;h3 id=&quot;传输层&quot;&gt;传输层&lt;/h3&gt;
&lt;p&gt;传输层为两台主机上的应用程序提供端对端的通信，主要有三个协议：TCP、UDP、SCTP。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP (Transmission Control Protocol 传输控制协议)&lt;/strong&gt; 为应用层提供可靠的、面向连接的和基于流的服务。使用超时重传、数据确认等方式来确保数据包被正确地发送到目的端，使用前必须先建立连接，内核维持一些连接信息，发送端逐个字节地向数据流(没有边界即长度限制)中写入，接收端逐个字节接收，通信结束时双方必须关闭连接以释放这些内核数据。&lt;/p&gt;
&lt;h5 id=&quot;三次握手建立连接与四次挥手断开连接&quot;&gt;三次握手建立连接与四次挥手断开连接&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://lukeatme-1251094467.cos.ap-guangzhou.myqcloud.com/20190508183817.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UDP (User Datagram Protocol 用户数据报协议)&lt;/strong&gt;，与 TCP 相反，提供不可靠、无连接和基于数据报的服务，每个数据报都有一个长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SCTP (Stream Control Transmission Protocol 流控制传输协议)&lt;/strong&gt; 是为传输电话号码而设计的，&lt;/p&gt;
&lt;h3 id=&quot;应用层&quot;&gt;应用层&lt;/h3&gt;
&lt;p&gt;应用层负责处理应用程序的逻辑，在用户空间来实现。数据链路层、网络层、传输层负责处理网络通信，这部分在内核空间中实现，必须稳定又高效。&lt;/p&gt;
&lt;h2 id=&quot;封装&quot;&gt;封装&lt;/h2&gt;
&lt;p&gt;应用程序数据在发送到物理网络上之前，沿着协议栈从上往下依次传递，每层协议都将在上层数据的基础之上加上自己的头部信息，有时包括尾部数据，以实现该层的功能，这个过程就叫做封装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lukeatme-1251094467.cos.ap-guangzhou.myqcloud.com/20190427213425.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分用&quot;&gt;分用&lt;/h2&gt;
&lt;p&gt;当帧到达目的主机时，将沿着协议栈自底向上依次传递，各层依次处理帧中本层负责的头部数据以获取所需的信息，并最终将处理后的帧交给目标程序，这个过程称为分用，是依靠头部信息中的类型字段实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lukeatme-1251094467.cos.ap-guangzhou.myqcloud.com/20190428213422.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;arp-协议工作原理&quot;&gt;arp 协议工作原理&lt;/h2&gt;
&lt;p&gt;ARP 协议能实现任意网络层地址到任意物理地址的转换，主机向自己所在的网络广播一个 ARP 请求包含目标机器的网络地址，此网络上的其他机器都将收到这个请求，但只有被请求的目标机器会回应一个 ARP 应答，其中包含自己的物理地址。&lt;/p&gt;
&lt;h2 id=&quot;dns-工作原理&quot;&gt;dns 工作原理&lt;/h2&gt;
&lt;p&gt;DNS 是一套分布式的域名服务系统，每个 DNS 服务器上存放着大量的机器名和 IP 地址的映射，并且是动态更新的，众多网络客户端程序都是用 DNS 协议来向 DNS 服务器查询目标主机的 IP 地址。&lt;/p&gt;
&lt;h2 id=&quot;socket-和-tcpip-协议族的关系&quot;&gt;Socket 和 TCP/IP 协议族的关系&lt;/h2&gt;
&lt;p&gt;Socket 是一套通用网络编程接口，不但可以访问内核中 TCP/IP 协议栈，而且可以访问其他网络协议栈。&lt;/p&gt;
</description>
<pubDate>Fri, 10 May 2019 03:39:00 +0000</pubDate>
<dc:creator>luke_44</dc:creator>
<og:description>现在 Internet 使用的主流协议族是 TCP/IP 协议族，它是一个分层、多协议的通信体系。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luke44/p/10101047.html</dc:identifier>
</item>
<item>
<title>领域驱动设计最佳实践--代码篇 - 请叫我红领巾!</title>
<link>http://www.cnblogs.com/xxzhuang/p/10843470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xxzhuang/p/10843470.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;做一个租户系统下的权限服务，接管用户的认证和授权，我们取名该服务为&lt;code&gt;oneday-auth-server&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;写在前面&lt;/h3&gt;
&lt;p&gt;​ DDD（领域驱动设计）中涉及到几个概念，实体，值对象，聚合，限定上下文。本篇只涉及实践，概念讲解将放在下一篇，同时上一篇&lt;a href=&quot;https://juejin.im/post/5ca16166e51d456708675612&quot;&gt;为什么我们需要领域驱动设计&lt;/a&gt;作为科普帖，大家可以在看完代码之后再回头理解一下，同时对比一下现有项目，知其然更要知其所以然，你经常遇到了什么问题，为什么DDD能够更好的解决软件负责的问题。&lt;/p&gt;
&lt;h3 id=&quot;需求描述&quot;&gt;需求描述&lt;/h3&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;​ 认证功能即登录功能，登录成功登录态的设定，登录失败的处理方式例如IP锁定，失败超过次数锁定等方式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;​ 授权功能即对认证通过的用户，进行角色和权限授予，同时开启资源保护，未具备访问该资源权限的用户将无法访问。&lt;/p&gt;
&lt;p&gt;本篇将详细介绍如何在DDD的指导下实现第一点功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;领域子域和界限上下文&quot;&gt;领域、子域和界限上下文&lt;/h3&gt;
&lt;p&gt;​ 我们先明白的一点是&lt;strong&gt;领域&lt;/strong&gt;这个词语承载了太多的含义，既可以表示整个业务系统，也可以表示其中的某个核心域或者支撑子域。举个不是很恰当的例子，假设我们原本想要在一个叫账户模块实现了这个功能，同时还有用户信息功能，这个时候，&lt;strong&gt;账户就是一个大的领域，一块的大蛋糕&lt;/strong&gt;，而&lt;code&gt;oneday-auth&lt;/code&gt;则是这块大蛋糕的某一块，用户信息又是另一块，这被分出的一块一块蛋糕，我们称之为由账户领域分成的子域，&lt;strong&gt;权限子域&lt;/strong&gt;和用户信息子域。子域下还可以再接着划分出子域，没有最小的子域，只有最合适的子域。&lt;/p&gt;
&lt;p&gt;​ 你会觉得这个微服务的拆分很像，是的，微服务的拆分是遵循DDD的思想，但是你再仔细思考下，&lt;strong&gt;你是不是只学了一个形式而已？&lt;/strong&gt;可以对比一下下面的了两张图片和你的思路是不是不谋而合。&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/10/16a9fb5aca2bf841?w=511&amp;amp;h=244&amp;amp;f=png&amp;amp;s=9763&quot; alt=&quot;DDD中的划分&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/10/16a9fb5c91410c50?w=490&amp;amp;h=262&amp;amp;f=png&amp;amp;s=10279&quot; alt=&quot;普通微服务的划分&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 本文中我将权限子域再划分出了&lt;strong&gt;认证上下文和授权上下文&lt;/strong&gt;。对于界限上下文，我们把重点放在界限上，摘抄实现领域驱动设计的一段话：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;比如，“顾客”这个术语可能有多种含义。在浏览产品目录的时候，“顾客”表示一种意思；而在下单的时候，“顾客”又表示另一种意思。原因在于：当浏览产品目录时，“顾客”被放在了先前购买情况、忠诚度、可买产品、折扣和物流方式这样的上下文中。而在上下单时，“顾客”的上下文包括名字、产品寄送地址、订单总价和一些付款术语&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​ 我在&lt;code&gt;oneday-auth&lt;/code&gt;中设计了一个类&lt;code&gt;LoginUserE&lt;/code&gt;，用来代表登录用户实体类，包含的信息仅仅跟认证和授权相关，而用户信息子域中，肯定也有一个用户类&lt;code&gt;UserInfo&lt;/code&gt;,但是这里的代表的含义是跟业务系统相关信息，比如说性别，昵称。我相信大多数读者肯定经历过一个类中承担过多功能，试图去创建一个全功能的类，最终导致的结果各位也可想而知，贪一时之方便带来的是不断拆东墙补西墙。&lt;/p&gt;
&lt;p&gt;​ 用户进入认证界限上下文，他在这里只会被认为 一个待认证，而且只具备认证相关的信息，用户进入授权界限上下文，他在这里只会被认为一个认证成功，等待授权或者具备权限的用户。认证上下文和授权上下文我们可以&lt;/p&gt;
&lt;p&gt;​ 于是在代码里，我划分了两个包模块：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;gt; one.day.auth:
    &amp;gt;&amp;gt; authentication ：认证即用户登录，身份识别等功能
    &amp;gt;&amp;gt; authorization ：授权上下文：给予用户身份，角色，权限，并判断用户是否具备访问某个功能的权限等功能&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 看到这里，请读者自己思考一个问题，如果按照原来的做法，你会不会分出两个包，你的大致做法是不是如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; one.day.auth.service
    &amp;gt;&amp;gt; authenticationServiceImpl
    &amp;gt;&amp;gt; authorizationServiceImpl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 如果你看到这里突然有了一种思维的自我斗争，甚至有一种恍然大悟的感觉，那么恭喜你，你已经开始培养了DDD的思维。&lt;/p&gt;
&lt;p&gt;​ 小结：代码目录的不同，就从一开始决定了你的开发思维。传统的MVC分层注定无法真正有效的划分领域，从而实现面向对象开发&lt;/p&gt;
&lt;h3 id=&quot;代码实践&quot;&gt;代码实践&lt;/h3&gt;
&lt;h4 id=&quot;代码分层&quot;&gt;代码分层&lt;/h4&gt;
&lt;p&gt;​ &lt;a href=&quot;https://juejin.im/post/5ca16166e51d456708675612&quot;&gt;为什么我们需要领域驱动设计&lt;/a&gt;提到了两个架构，四层架构和六边形架构（又称端口-适配器）。其中六边形架构是从四层架构进一步发来而来的，是逻辑意义上的，代码的物理分层是做不到所谓六边形的。我们暂时抛开这一切，只关注我们想要的目的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;领域对象要做到只关心业务逻辑，不能出现丝毫技术细节，即不直接依赖任何外部，通过接口去依赖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​ 应用层：非业务相关处理；领域层：业务相关处理；基础设施：持久化，缓存等技术细节实现。代码目录分层如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;gt; one.day.auth.authentication
&amp;gt; &amp;gt; app 应用层
&amp;gt; &amp;gt; client 二方包，这里方便起见放在了同一个Maven项目中
&amp;gt; &amp;gt; domain 领域层
&amp;gt; &amp;gt; &amp;gt; entity 实体包，具备行为，不具备数据状态
&amp;gt; &amp;gt; &amp;gt; port 端口定义，外部依赖统一定义为端口
&amp;gt; &amp;gt; &amp;gt; service 领域服务
&amp;gt; &amp;gt; infrastructure 基础设施层
&amp;gt; &amp;gt; &amp;gt; adapt 适配器，实现领域层定义的端口接口
&amp;gt; &amp;gt; &amp;gt; converter DTO，DO，Entity互相转换的工具类
&amp;gt; &amp;gt; &amp;gt; dataobject 表映射包 不具备行为，具备数据状态
&amp;gt; &amp;gt; &amp;gt; repository 仓储
&amp;gt; &amp;gt; &amp;gt; tunnel 通道&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;功能实现&quot;&gt;功能实现&lt;/h4&gt;
&lt;p&gt;​ 我们来看看登录这一个功能具体是如何实现的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class AuthenticationApp {
   /**
     * 领域层，登录领域服务
     */
    @Autowired
    private LoginService loginService;
    /**
     * 登录
     *
     * @param loginCmd
     */
    public void login(LoginCmd loginCmd) {
        //调用领域层进行登录校验
        String userId = loginService.login(loginCmd);
        //session中存放userId已证明登录
        //由于领域层主要负责登录，或者校验密码，登录成功之后的登录态设定不关心，交由应用层负责
        ProjectUtil.setSession(&quot;userId&quot;, userId);
    }
    public void addLoginUser(AddLoginUserCmd addLoginUserCmd) {
        loginService.addLoginUser(addLoginUserCmd);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 我们可以看到，应用层&lt;code&gt;AuthenticationApp&lt;/code&gt;先调用了领域层的领域服务&lt;code&gt;LoginService&lt;/code&gt;，当该方法没有抛出异常则证明用户校验成功，但是注意的是&lt;code&gt;LoginService&lt;/code&gt;的&lt;strong&gt;核心作用的是校验&lt;/strong&gt;，登录不登录，即登录态的设定并不是他所关心的，并不是他的业务逻辑。领域层只保证用户和密码是正确的，而其他一切东西都是外围，应用层，甚至是上游服务得知校验成功之后再来设定登录态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/1/169d664729211e80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;六边形架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 我们接着看看领域层，领域服务是如何工作的。&lt;/p&gt;
&lt;p&gt;​ 我们先介绍两个类，&lt;code&gt;LoginUserRepositoryPort&lt;/code&gt;和&lt;code&gt;LoginUserConverter&lt;/code&gt;。读者可能会有一个疑惑是，怎么可能会没有技术细节呢，我怎样都需要将数据保存到数据库中，这肯定就涉及到持久化技术，这个时候六边形架构就应运而生了。我们的口号是“领域层不掺杂任何技术细节”，任何的外部依赖，我们都定义成一个端口类，而具体的实现交由各个层的适配器去实现，通过依赖注入实现相应的依赖功能。如何检验这一点，就是要看你的领域层能不能做到&lt;strong&gt;拷贝不走样&lt;/strong&gt;，即如果你单纯复制domain目录到其他的项目中，是否能够正常编译。&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;LoginUserConverter&lt;/code&gt;存在的意义是什么，DTO，Entity，DataObject之间总会互相转换，将这一部分代码统一放到Converter类中。我相信读者的不少项目，各种转换都是很随意的，开心就好：)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class LoginServiceImpl implements LoginService {
    private final LoginUserRepositoryPort loginUserRepositoryPort;
    private final LoginUserConverter loginUserConverter;
    @Autowired
    public LoginServiceImpl(LoginUserRepositoryPort loginUserRepositoryPort, LoginUserConverter loginUserConverter) {
        this.loginUserRepositoryPort = loginUserRepositoryPort;
        this.loginUserConverter = loginUserConverter;
    }
    @Override
    public String login(LoginCmd loginCmd) {
        Optional&amp;lt;LoginUserE&amp;gt; optionalLoginUserE = loginUserRepositoryPort.findByUsername(loginCmd.getUsername());
        optionalLoginUserE.orElseThrow(() -&amp;gt; new BaseException(GlobalEnum.NON_EXIST));
        LoginUserE loginUserE = optionalLoginUserE.get();
        loginUserE.login(loginCmd.getPassword());
        //todo 登录成功，异步通知观察者
        return loginUserE.getUserId();
    }
    @Override
    public void addLoginUser(AddLoginUserCmd addLoginUserCmd) {
        LoginUserE loginUserE = loginUserConverter.convert2Entity(addLoginUserCmd);
        loginUserE.prepareToAdd();
        loginUserRepositoryPort.add(loginUserE);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 领域服务&lt;code&gt;LoginServiceImpl&lt;/code&gt;的第一件事是通过依赖注入获取的&lt;code&gt;LoginUserRepositoryPort&lt;/code&gt;去查询获取登录用户&lt;code&gt;LoginUserE&lt;/code&gt;，如果存在则调用&lt;code&gt;login&lt;/code&gt;方法。我们看看&lt;code&gt;LoginUserE&lt;/code&gt;究竟是什么玩意。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class LoginUserE extends Unique {
    public static final String COMMON_SALT = &quot;commonSalt&quot;;
    /**
     * 登录用户名
     */
    private String username;
    /**
     * 登录密码
     */
    private String password;
    /**
     * 盐
     */
    private String salt;
    /**
     * 加密算法
     */
    private EncryptionAlgorithmV encryptionAlgorithmV;
    /**
     * 业务唯一ID
     */
    private String userId;
    private TenantIdV tenantIdV;
    /**
     * 比较密码
     *
     * @param sendPwd 传入的密码
     * @return true/false
     */
    public boolean login(String sendPwd) {
        //检查available
        //错误次数限制
        //锁号 ip
        return StringUtils.equals(password, encryptionAlgorithmV.getPasswordEncoder().encoder(sendPwd, salt));
    }
    /**
     * 密码加密
     */
    public void encryptPassword() {
        this.setSalt(RandomStringUtils.randomNumeric(8));
        this.setPassword(encryptionAlgorithmV.getPasswordEncoder().encoder(password, salt));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 代码逻辑其实很简单，留着几个扩展功能没有实现，一个是针对登录失败的各种场景操作，第二个是，对不同的租户下的用户系统实现不同的加密器。功能从上帝Service类转移到具备真正意义的实体类上，具备真正的行为，符合类的单一职责标准。&lt;/p&gt;
&lt;p&gt;​ 到这里登录功能讲解就算是结束，但其中我留有一个功能未开发，即&lt;strong&gt;登录成功，异步通知观察者&lt;/strong&gt;，DDD中同时倡导事件驱动开发和最终一致性。这其实也是跟&lt;strong&gt;类的单一职责原则&lt;/strong&gt;有关。在整个登录功能中，&lt;strong&gt;校验&lt;/strong&gt;是第一步，校验成功紧接着是进行&lt;strong&gt;授权&lt;/strong&gt;，两者是上下游关系，核心业务逻辑不应该写在一块，这在传统MVC项目中两者是绝对的耦合在一起。而采用事件驱动可以将两者分离，无论是异步或者同步，简单起见的话可以直接使用guava的EventBus。&lt;/p&gt;
&lt;p&gt;​ 持久化层的设计和特点本篇暂不涉及，不可一步而就，事实上如果你还关心这一点的话则证明你还未能理解DDD。重点是业务逻辑，无技术细节。持久化只是一种存储技术，不要因为用了这一个技术反而被绑架了你的思路。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;​ 业务层执行非业务逻辑，领域层只执行业务逻辑，使用端口-适配器模式隔离外部依赖，检验的标准是拷贝不走样。第一步的界限上下文划分很关键。一开始的划分就决定了你是面向对象还是面向过程。不要被持久化技术绑架了我们的开发思路。我们的口号是“&lt;strong&gt;领域层不掺杂任何技术细节&lt;/strong&gt;”，我们的目标是&lt;strong&gt;真正的面向对象开发&lt;/strong&gt;，我们的理想是&lt;strong&gt;永不加班&lt;/strong&gt;！！！&lt;/p&gt;
&lt;p&gt;​ 源码地址：https://github.com/iamlufy/oneday-auth&lt;/p&gt;
&lt;p&gt;​ 作者：&lt;a href=&quot;https://juejin.im/user/5ca038336fb9a05e790a3638&quot;&gt;plz叫我红领巾&lt;/a&gt;　　　&lt;/p&gt;
&lt;p&gt;​ 出处：&lt;a href=&quot;https://juejin.im/post/5cd3d1a8f265da034c7042c6&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5cd3d1a8f265da034c7042c6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　本博客欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/p&gt;
</description>
<pubDate>Fri, 10 May 2019 03:32:00 +0000</pubDate>
<dc:creator>请叫我红领巾!</dc:creator>
<og:description>做一个租户系统下的权限服务，接管用户的认证和授权，我们取名该服务为 写在前面 ​ DDD（领域驱动设计）中涉及到几个概念，实体，值对象，聚合，限定上下文。本篇只涉及实践，概念讲解将放在下一篇，同时上一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xxzhuang/p/10843470.html</dc:identifier>
</item>
</channel>
</rss>