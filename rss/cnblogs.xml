<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>蓝桥杯2020 E：七段码 - Fool_one</title>
<link>http://www.cnblogs.com/xuwenchao/p/13867362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwenchao/p/13867362.html</guid>
<description>[unable to retrieve full-text content]题解 正规解法是 dfs + 并查集，首先用 dfs 将其所有的情况枚举出来，再用并查集来判断是否在一个连通块上。 许多小伙伴计算的答案为76，主要是判断连通块这方面有问题，倘若不用并查集，直接枚举一条边是否和其余剩下的边相连，是就成立，不是就可以直接退出了，但是有一个问题是例如两个连通块的时候你上</description>
<pubDate>Sat, 24 Oct 2020 00:46:00 +0000</pubDate>
<dc:creator>Fool_one</dc:creator>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fxuwenchao%2Fp%2F13867362.html</dc:identifier>
</item>
<item>
<title>OpenCV开发笔记（七十二）：红胖子8分钟带你使用opencv+dnn+tensorFlow识别物体 - 红胖子(红模仿)</title>
<link>http://www.cnblogs.com/qq21497936/p/13867348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq21497936/p/13867348.html</guid>
<description>&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;  级联分类器的效果并不是很好，准确度相对深度学习较低，本章使用opencv通过tensorflow深度学习，检测已有模型的分类。&lt;/p&gt;
&lt;/div&gt;


&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201021093858993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMjE0OTc5MzY=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201021093902147.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;  可以猜测，1其实是人，18序号类是狗，因为笔者未找到对应的分类具体信息。&lt;/p&gt;
&lt;/div&gt;





&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  opencv3.4.x支持了各种模型。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;支持的模型&lt;/h2&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;h2&gt;操作步骤：tensorflow&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;步骤一：加载模型和配置文件，建立神经网络。&lt;br/&gt;  根据不同的模型，使用cv::dnn::readNetFromXXX系列函数进行读取，opencv3.4.x系列支持的dnn模型（支持模型往上看）。&lt;br/&gt;  举例tensorflow模型如下：&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code&gt;std::string weights = &quot;E:/qtProject/openCVDemo/dnnData/&quot; \
                      &quot;ssd_mobilenet_v1_coco_2017_11_17/frozen_inference_graph.pb&quot;;
std::string prototxt = &quot;E:/qtProject/openCVDemo/dnnData/&quot; \
                      &quot;ssd_mobilenet_v1_coco_2017_11_17.pbtxt&quot;;
cv::dnn::Net net = cv::dnn::readNetFromTensorflow(weights, prototxt);
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;步骤二：将要预测的图片加入到神经网络中&lt;br/&gt;  加入之后，需要识别图片，那么需要把图片输入到神经网络当中去，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code&gt;cv::Mat mat;
cv::Mat blob;
mat = cv::imread(&quot;E:/testFile/14.jpg&quot;);
cv::dnn::blobFromImage(mat, blob);
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;步骤三：分类预测，获取识别的结果&lt;br/&gt;  输入之后，就进行识别，识别是向前预测（分类预测），并且拿到结果。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code&gt;cv::Mat prob = net.forward();
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;  对于预测的结果，存于cv::Mat类型的prob，然后需要统一对prob进行处理，使其成为我们可以使用的数据，代码如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code&gt;cv::Mat detectionMat(prob.size[2], prob.size[3], CV_32F, prob.ptr&amp;lt;float&amp;gt;());
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;  对于从结果prob转换为detectionMat后，其结构如下：&lt;br/&gt;  cv::Mat为多行七列，每一行代表一个检测到的分类，具体列信息如下表：&lt;br/&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/2020102109393180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMjE0OTc5MzY=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;  （注意：具体的使用，请参照“步骤四”）&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;步骤四：对达到置信度的可以通过输出的mat进行分类和框选&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;27&quot;&gt;
&lt;pre&gt;
&lt;code&gt;cv::Mat detectionMat(prob.size[2], prob.size[3], CV_32F, prob.ptr&amp;lt;float&amp;gt;());
// 置信度预制，大于执行度的将其使用rect框出来
float confidenceThreshold = 0.75;
for(int i = 0; i &amp;lt; detectionMat.rows; i++)
{
    float confidence = detectionMat.at&amp;lt;float&amp;gt;(i, 2);
    if (confidence &amp;gt; confidenceThreshold)
    {
        // 高于置信度的，获取其x、y、以及对应的宽度高度，进行框选
        int classId = (detectionMat.at&amp;lt;float&amp;gt;(i, 1));
        int xLeftBottom = static_cast&amp;lt;int&amp;gt;(detectionMat.at&amp;lt;float&amp;gt;(i, 3) * mat.cols);
        int yLeftBottom = static_cast&amp;lt;int&amp;gt;(detectionMat.at&amp;lt;float&amp;gt;(i, 4) * mat.rows);
        int xRightTop = static_cast&amp;lt;int&amp;gt;(detectionMat.at&amp;lt;float&amp;gt;(i, 5) * mat.cols);
        int yRightTop = static_cast&amp;lt;int&amp;gt;(detectionMat.at&amp;lt;float&amp;gt;(i, 6) * mat.rows);
        cv::Rect object((int)xLeftBottom,
                     (int)yLeftBottom,
                     (int)(xRightTop - xLeftBottom),
                     (int)(yRightTop - yLeftBottom));
        cv::rectangle(mat, object, cv::Scalar(0, 255, 0), 2);
        qDebug() &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; __LINE__
                &amp;lt;&amp;lt; classId
                &amp;lt;&amp;lt; confidence &amp;lt;&amp;lt; confidenceThreshold
                &amp;lt;&amp;lt; object.x &amp;lt;&amp;lt; object.y &amp;lt;&amp;lt; object.width &amp;lt;&amp;lt; object.height;
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  读取tensorflow模型与配置文件函数原型&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code&gt;Net readNetFromTensorflow(const String &amp;amp;model,
                         const String &amp;amp;config = String());
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  从文件中读取。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;参数一：用二进制协议描述网络体系结构的.pb文件的路径；&lt;/li&gt;
&lt;li&gt;参数二：包含protobuf格式的文本图形定义的.pbtxt文件的路径。生成的网络对象由文本图构建，使用来自二进制的权重让我们更灵活些；&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code&gt;Net readNetFromTensorflow(const std::vector&amp;lt;uchar&amp;gt;&amp;amp; bufferModel,
                         const std::vector&amp;lt;uchar&amp;gt;&amp;amp; bufferConfig = std::vector&amp;lt;uchar&amp;gt;());
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  从缓存中读取。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;参数一：包含pb文件内容的bufferModel缓冲区；&lt;/li&gt;
&lt;li&gt;参数二：包含pbtxt文件内容的bufferConfig缓冲区；&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code&gt;Net readNetFromTensorflow(const char *bufferModel,
                        size_t lenModel,
                        const char *bufferConfig = NULL,
                        size_t lenConfig = 0);
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;参数一：包含pb文件内容的bufferModel缓冲区；&lt;/li&gt;
&lt;li&gt;参数二：bufferModel缓冲长度；&lt;/li&gt;
&lt;li&gt;参数三：包含pbtxt文件内容的bufferConfig缓冲区；&lt;/li&gt;
&lt;li&gt;参数四：bufferConfig缓冲长度；&lt;br/&gt;  读取图片（需要识别的）函数原型&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;code&gt;Mat blobFromImage(InputArray image,
                  double scalefactor=1.0,
                  const Size&amp;amp; size = Size(),
                  const Scalar&amp;amp; mean = Scalar(),
                  bool swapRB=false,
                  bool crop=false,
                  int ddepth=CV_32F);
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code&gt;void blobFromImage(InputArray image,
                  OutputArray blob,
                  double scalefactor=1.0,
                  const Size&amp;amp; size = Size(),
                  const Scalar&amp;amp; mean = Scalar(),
                  bool swapRB=false,
                  bool crop=false,
                  int ddepth=CV_32F);.
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;code&gt;Mat blobFromImages(InputArrayOfArrays images,
                   double scalefactor=1.0,
                   Size size = Size(),
                   const Scalar&amp;amp; mean = Scalar(),
                   bool swapRB=false, 
                   bool crop=false,
                   int ddepth=CV_32F);
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code&gt;void blobFromImages(InputArrayOfArrays images,
                   OutputArray blob,
                   double scalefactor=1.0,
                   Size size = Size(),
                   const Scalar&amp;amp; mean = Scalar(),
                   bool swapRB=false,
                   bool crop=false,
                   int ddepth=CV_32F);
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  从图像创建区域。可选择从中心调整和裁剪图像。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;参数一：图像输入图像（1、3或4通道）；&lt;/li&gt;
&lt;li&gt;参数二：大小输出图像的空间大小；&lt;/li&gt;
&lt;li&gt;参数三：从通道中减去平均值的平均标量。价值是有意的，如果image有BGR顺序，swapRB为真，则按（mean-R，mean-G，mean-B）顺序排列；&lt;/li&gt;
&lt;li&gt;参数四：图像值的缩放因子乘数；&lt;/li&gt;
&lt;li&gt;参数五：swapRB标志，指示交换第一个和最后一个通道，在三通道图像是必要的；&lt;/li&gt;
&lt;li&gt;参数六：裁剪标志，指示调整大小后是否裁剪图像；&lt;/li&gt;
&lt;li&gt;参数七：输出blob的深度，选择CV_32F或CV_8U；&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;设置神经网络输入函数原型&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code&gt;void cv::dnn::Net::setInput(InputArray blob,
                      const String&amp;amp; name = &quot;&quot;,
                      double scalefactor = 1.0,
                      const Scalar&amp;amp; mean = Scalar());
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  设置网络的新输入值。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;参数一：一个新的blob。应具有CV_32F或CV_8U深度。&lt;/li&gt;
&lt;li&gt;参数二：输入层的名称。&lt;/li&gt;
&lt;li&gt;参数三：可选的标准化刻度。&lt;/li&gt;
&lt;li&gt;参数四：可选的平均减去值。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;深度检测识别（向前预测）函数原型&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code&gt;void cv::dnn::Net::Mat forward(const String&amp;amp; outputName = String());
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;  向前预测，返回指定层的第一个输出的blob，一般是返回最后一层，可使用cv::Net::getLayarNames()获取所有的层名称。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;参数一：outputName需要获取输出的层的名称&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;


&lt;div class=&quot;cl-preview-section&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;code&gt;void OpenCVManager::testTensorflow()
{
    // 训练好的模型以及其模型的后缀名
    // .caffemodel (Caffe, http://caffe.berkeleyvision.org/)
    // .pb (TensorFlow, https://www.tensorflow.org/)
    // .t7 | *.net (Torch, http://torch.ch/)
    // .weights (Darknet, https://pjreddie.com/darknet/)
    // .bin (DLDT, https://software.intel.com/openvino-toolkit)

    // https://github.com/opencv/opencv/wiki/TensorFlow-Object-Detection-API

    std::string weights = &quot;E:/qtProject/openCVDemo/dnnData/&quot; \
                          &quot;ssd_mobilenet_v1_coco_2017_11_17/&quot;frozen_inference_graph.pb&quot;;
    std::string prototxt = &quot;E:/qtProject/openCVDemo/dnnData/&quot; \
                           &quot;ssd_mobilenet_v1_coco_2017_11_17.pbtxt&quot;;
    cv::dnn::Net net = cv::dnn::readNetFromTensorflow(weights, prototxt);

    if(net.empty())
    {
        qDebug() &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt; &quot;net is empty!!!&quot;;
        return;
    }
    cv::Mat mat;
    cv::Mat blob;

    // 获得所有层的名称和索引
    std::vector&amp;lt;cv::String&amp;gt; layerNames = net.getLayerNames();
    int lastLayerId = net.getLayerId(layerNames[layerNames.size() - 1]);
    cv::Ptr&amp;lt;cv::dnn::Layer&amp;gt; lastLayer = net.getLayer(cv::dnn::DictValue(lastLayerId));
    qDebug() &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; __LINE__
             &amp;lt;&amp;lt; QString(lastLayer-&amp;gt;type.c_str())
             &amp;lt;&amp;lt; QString(lastLayer-&amp;gt;getDefaultName().c_str())
             &amp;lt;&amp;lt; QString(layerNames[layerNames.size()-1].c_str());

#if 0
    // 视频里面的识别
    cv::VideoCapture capture;
    if(!capture.open(&quot;E:/testFile/4.avi&quot;))
    {
        qDebug() &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt; &quot;Failed to open videofile!!!&quot;;
        return;
    }
#endif

    while(true)
    {
#if 1
        // 读取图片识别
        mat = cv::imread(&quot;E:/testFile/15.jpg&quot;);
        if(!mat.data)
        {
            qDebug() &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt; &quot;Failed to read image!!!&quot;;
            return;
        }
#else
        // 视频里面的识别
        capture &amp;gt;&amp;gt; mat;
        if(mat.empty())
        {
            cv::waitKey(0);
            break;
        }
#endif

        cv::dnn::blobFromImage(mat, blob);

        net.setInput(blob);
        // 推理预测：可以输入预测的图层名称
//        cv::Mat prob = net.forward(&quot;detection_out&quot;);
        cv::Mat prob = net.forward();

        // 显示识别花费的时间
        std::vector&amp;lt;double&amp;gt; layersTimes;
        double freq = cv::getTickFrequency() / 1000;
        double t = net.getPerfProfile(layersTimes) / freq;
        std::string label = cv::format(&quot;Inference time: %.2f ms&quot;, t);
        cv::putText(mat, label, cv::Point(0, 15), cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 255, 0));

        cv::Mat detectionMat(prob.size[2], prob.size[3], CV_32F, prob.ptr&amp;lt;float&amp;gt;());

        // 置信度预制，大于执行度的将其使用rect框出来
        float confidenceThreshold = 0.75;
        for(int i = 0; i &amp;lt; detectionMat.rows; i++)
        {
            float confidence = detectionMat.at&amp;lt;float&amp;gt;(i, 2);
            if (confidence &amp;gt; confidenceThreshold)
            {
                // 高于置信度的，获取其x、y、以及对应的宽度高度，进行框选
                int classId = (detectionMat.at&amp;lt;float&amp;gt;(i, 1));
                int xLeftBottom = static_cast&amp;lt;int&amp;gt;(detectionMat.at&amp;lt;float&amp;gt;(i, 3) * mat.cols);
                int yLeftBottom = static_cast&amp;lt;int&amp;gt;(detectionMat.at&amp;lt;float&amp;gt;(i, 4) * mat.rows);
                int xRightTop = static_cast&amp;lt;int&amp;gt;(detectionMat.at&amp;lt;float&amp;gt;(i, 5) * mat.cols);
                int yRightTop = static_cast&amp;lt;int&amp;gt;(detectionMat.at&amp;lt;float&amp;gt;(i, 6) * mat.rows);
                cv::Rect object((int)xLeftBottom,
                                (int)yLeftBottom,
                                (int)(xRightTop - xLeftBottom),
                                (int)(yRightTop - yLeftBottom));
                cv::rectangle(mat, object, cv::Scalar(0, 255, 0), 2);
                qDebug() &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; __LINE__
                         &amp;lt;&amp;lt; classId
                         &amp;lt;&amp;lt; confidence &amp;lt;&amp;lt; confidenceThreshold
                         &amp;lt;&amp;lt; object.x &amp;lt;&amp;lt; object.y &amp;lt;&amp;lt; object.width &amp;lt;&amp;lt; object.height;
            }
         }
        cv::imshow(_windowTitle.toStdString(), mat);
        cv::waitKey(0);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  openCVDemo_v1.64.0_基础模板_tensorFlow分类检测.rar。&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;
&lt;h2&gt;入坑一：加载模型时候错误&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;错误&lt;br/&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/2020102109394377.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;原因&lt;br/&gt;  .pb模型文件与.pbtxt文件不对应，版本也有关系。&lt;br/&gt;解决&lt;br/&gt;  更换模型，使用正确的pb与pbtxt对应的文件。&lt;/p&gt;
&lt;/div&gt;


</description>
<pubDate>Sat, 24 Oct 2020 00:44:00 +0000</pubDate>
<dc:creator>红胖子(红模仿)</dc:creator>
<og:description>前言 级联分类器的效果并不是很好，准确度相对深度学习较低，本章使用opencv通过tensorflow深度学习，检测已有模型的分类。 Demo 可以猜测，1其实是人，18序号类是狗，因为笔者未找到对应</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qq21497936/p/13867348.html</dc:identifier>
</item>
<item>
<title>如何使用 Azure Active Directory 认证和 Microsoft Graph 构建 Blazor Web 应用 - 冠军</title>
<link>http://www.cnblogs.com/haogj/p/13807232.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haogj/p/13807232.html</guid>
<description>&lt;p&gt;如果您是一个 .NET 开发者，你很可能听过过 Blazor 是一个最近的热门开发技术。Blazor 是一个使用 .NET Blazor 服务器来构建可交互客户端 Web 界面的框架。就是本文所专注的技术，提供了在 ASP.NET Core 应用中，在服务器端寄宿 Razor 组件的支持。UI 的更新通过 SignalR 连接进行。由于多数的应用都需要某些程度的验证和授权，这里将展示如何使用 Azure AD 实现验证的最佳方式，以及如何从 Microsoft Graph 获取数据。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;196.19356540084&quot;&gt;

&lt;p&gt;英文原文：&lt;a href=&quot;https://developer.microsoft.com/en-us/identity/blogs/how-to-build-a-blazor-web-app-with-azure-active-directory-authentication-and-microsoft-graph/&quot;&gt;https://developer.microsoft.com/en-us/identity/blogs/how-to-build-a-blazor-web-app-with-azure-active-directory-authentication-and-microsoft-graph/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您是一个 .NET 开发者，你很可能听过过 Blazor 是一个最近的热门开发技术。Blazor 是一个使用 .NET Blazor 服务器来构建可交互客户端 Web 界面的框架。就是本文所专注的技术，提供了在 ASP.NET Core 应用中，在服务器端寄宿 Razor 组件的支持。UI 的更新通过 SignalR 连接进行。由于多数的应用都需要某些程度的验证和授权，这里将展示如何使用 Azure AD 实现验证的最佳方式，以及如何从 Microsoft Graph 获取数据。&lt;/p&gt;
&lt;h3 id=&quot;先决条件&quot;&gt;先决条件&lt;/h3&gt;
&lt;p&gt;为了继续下面的演练，您需要最新版本的 &lt;a href=&quot;https://dotnet.microsoft.com/download/dotnet-core/3.1&quot;&gt;NET Core 3.1 SDK&lt;/a&gt;, &lt;a href=&quot;https://visualstudio.microsoft.com/downloads/&quot;&gt;Visual Studio 2019&lt;/a&gt; (可选，但是最好)，并且拥有一个 Azure AD 的租户。如果你不能访问 Azure AD 租户，要么你可以免费注册一个 &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-365/dev-program&quot;&gt;Microsoft 365 Developer program&lt;/a&gt;，或者创建一个免费的 &lt;a href=&quot;https://azure.microsoft.com/free&quot;&gt;Free Azure Trial&lt;/a&gt; 试用账号。&lt;/p&gt;
&lt;h3 id=&quot;blazor-与验证&quot;&gt;Blazor 与验证&lt;/h3&gt;
&lt;p&gt;如果你正在构建 Blazor (服务器端) 应用，那么我们有一些好消息。Visual Studio 和 CLI 模版支持开箱即用的验证支持。打开 Visual Studio，然后创建一个新的 Blazor 应用。我们将它命名为 &quot;BlazorAppWithAuth&quot;，然后按照下面的动画进行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.microsoft.com/en-us/identity/blogs/wp-content/uploads/2020/07/1.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过选择工作或者学校账号验证选项，Visual Studio 将在 Azure AD 上创建适当的应用注册，并为 Blazor 应用配置开箱即用的验证所需的配置和代码。我们可以通过检查 appsettings.json 来确认。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.microsoft.com/en-us/identity/blogs/wp-content/uploads/2020/07/2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且，如果你到 Azure 门户的 Azure AD 注册页签中查看，还可以看到与 Visual Studio 中看到的信息想匹配的应用注册资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.microsoft.com/en-us/identity/blogs/wp-content/uploads/2020/07/3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不需要写一行代码，我们的 Blazor 应用在用户访问任何页面之前，就可以提示用户。我们可以通过运行应用来快速测试该应用。在我们第一次访问该站点的时候，我们将被提示这些应用要求的 (默认) 权限，这里是读取用户的资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.microsoft.com/en-us/identity/blogs/wp-content/uploads/2020/07/4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.microsoft.com/en-us/identity/blogs/wp-content/uploads/2020/07/5.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到了这一步，你可能认为我们的任务已经完成了，实际上，还有许多事情要做。首先，默认的模版使用了老式的，默认 v1 版本的 Azure AD 端点。如果你想知道为什么你应当使用 Microsoft identity platform 并使用 v2 版本的端点，你可以&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/active-directory/develop/&quot;&gt;查看 Microsoft identity platform 文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;使用-microsoftidentityweb-现代化验证&quot;&gt;使用 Microsoft.Identity.Web 现代化验证&lt;/h3&gt;
&lt;p&gt;在 &lt;a href=&quot;https://techcommunity.microsoft.com/t5/azure-active-directory-identity/build-2020-fostering-a-secure-and-trustworthy-app-ecosystem-for/ba-p/1257360&quot;&gt;Build 2020&lt;/a&gt; 中，我们为 ASP.NET Core 3.1 (及后继版本) 宣布了一个新的验证和令牌管理库。新的库对复杂性进行了很棒的大量抽象，支持开发者只需要很少的代码就可以实现验证。而且，新库最大的优势是因为该库构建与 MSAL 之上，你不再需要使用两个单独的库来先进行验证，然后获得一个令牌来访问后端的 API。所以，让我们看一下如何迁移到这个最新的库上。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;注意：Microsoft.Identity.Web 仍然在预览状态，它将很快发布&lt;/p&gt;
&lt;p&gt;注意：现在 1.0 已经发布。发布时间：2020/10/1&lt;/p&gt;
&lt;p&gt;注意：现在 1.1.0 已经发布，发布时间：Tuesday, October 6, 2020 (10/6/2020)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，我们需要下载这个新的 NuGet 包&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Microsoft.Identity.Web - 1.1.0 已经发布&lt;/li&gt;
&lt;li&gt;Microsoft.Identity.Web.UI - 1.1.0 已经发布&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://developer.microsoft.com/en-us/identity/blogs/wp-content/uploads/2020/07/6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.microsoft.com/en-us/identity/blogs/wp-content/uploads/2020/07/7.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，我们需要修改几行代码来清除老的验证代码并切换到新的代码。&lt;/p&gt;
&lt;p&gt;打开 Startup() 并替换代码，下面是原来的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;services.AddAuthentication(AzureADDefaults.AuthenticationScheme)
                .AddAzureAD(options =&amp;gt; Configuration.Bind(&quot;AzureAd&quot;, options));

services.AddControllersWithViews(options =&amp;gt;
            {
                var policy = new AuthorizationPolicyBuilder()
                    .RequireAuthenticatedUser()
                    .Build();
                options.Filters.Add(new AuthorizeFilter(policy));
            });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;替换为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;services.AddMicrosoftWebAppAuthentication(Configuration);
services.AddControllersWithViews(options =&amp;gt;
   {
      var policy = new AuthorizationPolicyBuilder()
                    .RequireAuthenticatedUser()
                    .Build();
      options.Filters.Add(new AuthorizeFilter(policy));
   })
  .AddMicrosoftIdentityUI();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 1.1 SDK 后，应该为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;services.AddMicrosoftIdentityWebAppAuthentication(Configuration)
services.AddControllersWithViews(options =&amp;gt;
{
    var policy = new AuthorizationPolicyBuilder()
                    .RequireAuthenticatedUser()
                    .Build();
    options.Filters.Add(new AuthorizeFilter(policy));
})
    .AddMicrosoftIdentityUI();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，我们需要确保我们的应用可以使用正确的 v2 版本端点来进行登录和登出。打开 LoginDisplay.razor 并进行如下的更新：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;AuthorizeView&amp;gt;
    &amp;lt;Authorized&amp;gt;
        Hello, @context.User.Identity.Name!
        &amp;lt;a href=&quot;MicrosoftIdentity/Account/SignOut&quot;&amp;gt;Log out&amp;lt;/a&amp;gt;
    &amp;lt;/Authorized&amp;gt;
    &amp;lt;NotAuthorized&amp;gt;
        &amp;lt;a href=&quot;MicrosoftIdentity/Account/SignIn&quot;&amp;gt;Log in&amp;lt;/a&amp;gt;
    &amp;lt;/NotAuthorized&amp;gt;
&amp;lt;/AuthorizeView&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你需要注意到，这里并没有特定的用来登录和登出的页面。相反，它们构建在 Microosft.Identity.Web.dll 内部。所以，在我们更新区域到 &quot;MicrosoftIdentity&quot; 的时候，不再需要其它的修改了。&lt;/p&gt;
&lt;p&gt;当我们再次从 Visual Stuido 运行应用的时候，我们从 v2 中获得新的登录体验，例如无口令和多因子验证。最棒的是这些功能被设计为不需要修改任何代码，随着 Azure AD 的管理被配置为使用这些设置，所有的用户可以从更强的安全性中获益。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.microsoft.com/en-us/identity/blogs/wp-content/uploads/2020/07/8.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如你所见，使用很少的代码，我们可以借助于 Microsoft.Identity.Web 库基于 Azure AD 来验证用户。&lt;/p&gt;
&lt;h3 id=&quot;从-microsoft-graph-提取数据&quot;&gt;从 Microsoft Graph 提取数据&lt;/h3&gt;
&lt;p&gt;Microsoft Graph 提供了大量的 API 来支持你基于用户自己的数据构建丰富的沉浸式的应用。在下面的步骤中，我们将拉取用户的电子邮件并将它们显示在应用内。为达到该目标，我们首先需要在 Azure AD 上扩展应用注册的权限，增加访问电子邮件数据的访问，然后我们需要在 Blazore 应用中添加一些代码来提取，并在其中的一个页面上显示数据。&lt;/p&gt;
&lt;h4 id=&quot;azure-ad-门户&quot;&gt;Azure AD 门户&lt;/h4&gt;
&lt;p&gt;找到应用的注册，并进入 API 权限，选择添加新的权限，然后选择 Graph API，在这里，我们希望选择被代理权限，并选择 &quot;Mail Read&quot; 权限。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.microsoft.com/en-us/identity/blogs/wp-content/uploads/2020/07/9.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;我们还需要创建一个用户密钥，因为我们的应用将需要一个验证令牌，和提取数据而不需要任何用户交互的方式。在同一个应用注册中，打开 Certificates 和 Secrets 页签，然后创建新的永不过期的密钥，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.microsoft.com/en-us/identity/blogs/wp-content/uploads/2020/07/10.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确保你复制了密码，因为一旦你从该页面切换出去，你就再也不能访问它了。但是，如果需要的话，你总是可以重新创建它 - 这很简单且免费。&lt;/p&gt;
&lt;p&gt;回到 Blazor 应用中，在 Visual Studio 中，我们首先需要在 appsettings.json 中添加客户密钥。在 AzureAD&lt;/p&gt;
&lt;p&gt;的配置节，我们必须添加如下的行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;“ClientSecret”: “&amp;lt;your secret&amp;gt;”
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Startup.cs 文件中，我们需要更新代码以确保使用正确的权限获取了适当的访问令牌，并将它保存在缓存中，以便我们在后继的应用中使用它访问 Microsoft Graph。我们将添加 HttpClient 到我们的服务管线中，来支持我们随后有效的发出 HTTP 调用到 Microsoft.Graph。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;services.AddMicrosoftIdentityWebAppAuthentication(Configuration)
    .EnableTokenAcquisitionToCallDownstreamApi( new string[] { &quot;User.Read&quot;, &quot;Mail.Read&quot; })
    .AddInMemoryTokenCaches();

services.AddHttpClient();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，我们需要更新在 FetchData.razor 页面中的代码来获取我们的电子邮件数据，来替代默认的天气数据。下面的代码包含了所有我们需要获取电子邮件并显示在页面上的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;@page &quot;/fetchdata&quot;

@inject IHttpClientFactory HttpClientFactory
@inject Microsoft.Identity.Web.ITokenAcquisition TokenAcquisitionService

&amp;lt;h1&amp;gt;Weather forecast&amp;lt;/h1&amp;gt;

&amp;lt;p&amp;gt;This component demonstrates fetching data from a service.&amp;lt;/p&amp;gt;

@if (messages == null)
{
    &amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Loading...&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;
}
else
{
    &amp;lt;h1&amp;gt;Hello @userDisplayName !!!!&amp;lt;/h1&amp;gt;

    &amp;lt;table class=&quot;table&quot;&amp;gt;
        &amp;lt;thead&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;th&amp;gt;Subject&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;Sender&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;Received Time&amp;lt;/th&amp;gt;
            &amp;lt;/tr&amp;gt;
        &amp;lt;/thead&amp;gt;
        &amp;lt;tbody&amp;gt;
            @foreach (var mail in messages)
            {
                &amp;lt;tr&amp;gt;
                    &amp;lt;td&amp;gt;@mail.Subject&amp;lt;/td&amp;gt;
                    &amp;lt;td&amp;gt;@mail.Sender&amp;lt;/td&amp;gt;
                    &amp;lt;td&amp;gt;@mail.ReceivedTime&amp;lt;/td&amp;gt;
                &amp;lt;/tr&amp;gt;
            }
        &amp;lt;/tbody&amp;gt;
    &amp;lt;/table&amp;gt;
}
@code {

    private string userDisplayName;
    private List&amp;lt;MailMessage&amp;gt; messages = new List&amp;lt;MailMessage&amp;gt;();

    private HttpClient _httpClient;

    protected override async Task OnInitializedAsync()
    {
        _httpClient = HttpClientFactory.CreateClient();


        // get a token
        var token = await TokenAcquisitionService.GetAccessTokenForUserAsync(new string[] { &quot;User.Read&quot;, &quot;Mail.Read&quot; });

        // make API call
        _httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(&quot;Bearer&quot;, token);
        var dataRequest = await _httpClient.GetAsync(&quot;https://graph.microsoft.com/beta/me&quot;);

        if (dataRequest.IsSuccessStatusCode)
        {
            var userData = System.Text.Json.JsonDocument.Parse(await dataRequest.Content.ReadAsStreamAsync());
            userDisplayName = userData.RootElement.GetProperty(&quot;displayName&quot;).GetString();
        }


        var mailRequest = await _httpClient.GetAsync(&quot;https://graph.microsoft.com/beta/me/messages?$select=subject,receivedDateTime,sender&amp;amp;$top=10&quot;);


        if (mailRequest.IsSuccessStatusCode)
        {
            var mailData = System.Text.Json.JsonDocument.Parse(await mailRequest.Content.ReadAsStreamAsync());
            var messagesArray = mailData.RootElement.GetProperty(&quot;value&quot;).EnumerateArray();


            foreach (var m in messagesArray)
            {
                var message = new MailMessage();
                message.Subject = m.GetProperty(&quot;subject&quot;).GetString();
                message.Sender = m.GetProperty(&quot;sender&quot;).GetProperty(&quot;emailAddress&quot;).GetProperty(&quot;address&quot;).GetString();
                message.ReceivedTime = m.GetProperty(&quot;receivedDateTime&quot;).GetDateTime();
                messages.Add(message);
            }
        }
    }


    public class MailMessage
    {
        public string Subject;
        public string Sender;
        public DateTime ReceivedTime;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新运行应用，并确保先登出当前的用户，因为当前的令牌没有包含正确的访问权限，并且我们已经修改了一些代码。你将会注意到再次登录的时候，我们的提示增加了新的访问权限，这意味着一切如我们所愿。现在，除了基本的用户资料数据，应该还可以请求访问我们的电子邮件数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.microsoft.com/en-us/identity/blogs/wp-content/uploads/2020/07/11.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在授权之后，我们被导航到了 &quot;Fetch Data&quot; 页面，可以看到一些电子邮件！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developer.microsoft.com/en-us/identity/blogs/wp-content/uploads/2020/07/12-1536x780.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你正确的如上演练，你现在应该可以看到类似上面图示中的你的电子邮件数据了。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;新的 Microsoft.Identity.Web 在简化验证和令牌管理方面做了出色的改进，你现在就应该开始使用它，在开始之前，有些事情值得你关注：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;与普通的支持动态/增加提醒的 Web 应用不同，在 Blazor 中，你需要在一开始为你的应用请求所有需要的权限。失败的话，将会导致 TokenAcruisition 方法不能根据新的权限验证用户。这是 Blazor 机制的一部分，所以在创建应用的时候要记住这一点。&lt;/li&gt;
&lt;li&gt;不是自己处理 Microsoft Graph HTTP 请求，你应该借助于 Microsoft Graph SDK，它简化了与 Microsoft Graph 的交互并提供了所有你需要序列化和反序列的对象。但是，在本示例中，我们仅仅遵循了建议 1，因为我们仅仅发出一个 Microsoft Graph 调用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后，你可以在 GitHub 上找到本示例 Blazor 应用程序的可运行示例的&lt;a href=&quot;https://github.com/jpda/msiddev-blazor-aad-graph&quot;&gt;所有的源代码&lt;/a&gt;，&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 24 Oct 2020 00:41:00 +0000</pubDate>
<dc:creator>冠军</dc:creator>
<og:description>如果您是一个 .NET 开发者，你很可能听过过 Blazor 是一个最近的热门开发技术。Blazor 是一个使用 .NET Blazor 服务器来构建可交互客户端 Web 界面的框架。就是本文所专注的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haogj/p/13807232.html</dc:identifier>
</item>
<item>
<title>解谜：为何用了9-Patch背景图后自带Padding属性？ - 萧文翰</title>
<link>http://www.cnblogs.com/wenhanxiao/p/13867138.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenhanxiao/p/13867138.html</guid>
<description>&lt;p&gt;本次分享的主题源于笔者在实际开发中遇到的问题。&lt;br/&gt;具体现象为：当普通的9-Patch图用作TextView的backGround属性后，整个TextView便有了一定的Padding值。但笔者并没有给定padding属性，甚至在预览视图中，也没有展现出padding效果。但运行起来后，便莫名其妙地有了内边距。&lt;br/&gt;我们先来看布局代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_centerInParent=&quot;true&quot;
    android:layout_gravity=&quot;center&quot;
    android:background=&quot;@mipmap/background&quot;
    android:text=&quot;@string/app_name&quot;
    tools:context=&quot;.MainActivity&quot;&amp;gt;
    
&amp;lt;/TextView&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Android Studio内的界面预览如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1595922/202010/1595922-20201024072418142-1234027528.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;红色边框的图片即背景，是经过9-Patch处理过的.9.png文件。&lt;br/&gt;显然，在预览时是正常没有内边距的，接下来我们运行它。其效果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1595922/202010/1595922-20201024072441776-708763732.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;可以看到，实际运行时，内边距出现了。&lt;br/&gt;经过一番问题排查，发现其根源在于.9.png文件，在Android Studio中打开这个图片，发现它的缩放设定是这样的：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1595922/202010/1595922-20201024072448409-270234661.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，中央深粉色的部分就是自由拉伸的部分。定义它的，则是图片四周的黑色线条。&lt;br/&gt;接着，我们勾选“Show content”，即预览显示内容区，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1595922/202010/1595922-20201024072517077-994661189.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，内容仅显示在中央非空白区域，也就是我们最终看到的运行效果了。&lt;br/&gt;到此，问题的根源找到了，我们怎么解决它呢？很简单，在进行图片拉伸定义时，我们应使用上和左边缘进行划线定义，而右和下边缘则定义了内容可填充的区域。因此，做如下图所示的修改：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1595922/202010/1595922-20201024072530531-866532373.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分别仔细观察上侧和下侧，左侧和右侧边缘，可以看到上侧和下侧并非完全划线，而是定义了拉伸的部分；而下侧和右侧则是完全划线，限定了内容可填充区域。&lt;br/&gt;再次运行，可见内边距已消失。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1595922/202010/1595922-20201024072537961-1055595394.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，还有一种解决办法。即在xml布局文件中，将TextView的padding属性值强制写为0dp，内边距则也会为0。但笔者更推荐使用前一种方法，因为强制为0的方法，在当确实需要有padding值的时候，往往会不太好处理。&lt;br/&gt;好了，以上就是本次分享给大家的开发小技巧，希望能够对你有所帮助。&lt;/p&gt;
</description>
<pubDate>Fri, 23 Oct 2020 23:26:00 +0000</pubDate>
<dc:creator>萧文翰</dc:creator>
<og:description>本次分享的主题源于笔者在实际开发中遇到的问题。 具体现象为：当普通的9-Patch图用作TextView的backGround属性后，整个TextView便有了一定的Padding值。但笔者并没有给定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wenhanxiao/p/13867138.html</dc:identifier>
</item>
<item>
<title>出Bug表-假如诸葛亮是程序员（1024程序员节日献礼） - 南瓜慢说</title>
<link>http://www.cnblogs.com/larrydpk/p/13866987.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/larrydpk/p/13866987.html</guid>
<description>&lt;blockquote readability=&quot;2.9545454545455&quot;&gt;
&lt;p&gt;欢迎访问&lt;a href=&quot;https://www.pkslow.com/&quot;&gt;南瓜慢说 www.pkslow.com&lt;/a&gt;获取更多精彩文章！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;南瓜言：先司创业未半而中道破产，今培训造才，网课套钱，此诚百家争鸣之时也。然优秀骨干组队离职，新招小白乐于摸鱼者，&lt;strong&gt;盖恨先司之压榨，欲报之于后司也&lt;/strong&gt;。&lt;strong&gt;诚宜混水摸鱼，以光先司遗风，恢弘偷懒之气，不宜勤奋加班，积极上进，以塞破产之路也&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发测试，俱为一体。写Bug测Bug，不宜异同。&lt;/strong&gt; 若有认真仔细及为规范者，宜贴代码鄙视孤立。以示老板庸笨之能，不宜偏才，使内外异心也。&lt;/p&gt;
&lt;p&gt;架构、运维锅有之、废亿、懂云等，此皆凉凉，思维混乱，是以先司辞退以送老板。我以为DevOps之事，事无大小，悉以咨之，然后施行，必能分崩离析，加速破产。&lt;/p&gt;
&lt;p&gt;产品锦鲤，夸夸其谈，不懂技术，试用于昔日，先司称之曰愣，是以众议举荐为锅。均以为写Bug之事，悉以咨之，必能使架构混乱，系统崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高耦合，低内聚，此先司所以破产也；高内聚，低耦合，此后司所以兴旺也。&lt;/strong&gt; 在先司时，每与老板论此事，未尝不喜爱欣赏于Bug也。死锁、溢出、超时、重复，此悉标准规范之魂，愿大家写之用之，则现司之破，可计日而待也。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我本屌丝，贴膜于天桥，苟求温饱于盛世，不敢直播当网红。&lt;/strong&gt; HR以为我会编程，亲自摆摊，三骗我于街角之中，咨我以写Bug之事，由是感激，遂进先司以编程。后值没人， &lt;strong&gt;受任于萧条之际，奉命于缩水之间。尔来二十又一Bug矣。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;老板知我粗心，故兴旺委我以重任。受命以来，天天摸鱼，恐完成太多，以伤老板之明。故五月运维，深入生产。今数据已删，机器已死，当遣散开发，开除测试，鞭打产品，辞退财务，带图路演，骗取投资。此我所以报现司而忠老板之职分也。至于做PPT，写演讲稿，则关我屁事也。&lt;/p&gt;
&lt;p&gt;愿老板任我以技术总监之位，不破，则加我薪资，以告先司之灵。若无天使投资，则又关我屁事？老板亦宜自谋，以撇清债务，携款逃跑，深学先司案例。我不胜无赖感激。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现又写Bug，临码归零，不知所删。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;——南瓜慢说&lt;/p&gt;
&lt;p&gt;2020年10月24日&lt;/p&gt;
&lt;p&gt;说明：本文纯属娱乐，作者无任何对孔明先生的不敬。&lt;/p&gt;
&lt;p&gt;图片分享：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202010/946674-20201024003329158-1037622103.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注微信公众号&amp;lt;&lt;strong&gt;南瓜慢说&lt;/strong&gt;&amp;gt;，将持续为你更新...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202010/946674-20201024003336697-1695348079.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多读书，多分享；多写作，多整理。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Oct 2020 16:34:00 +0000</pubDate>
<dc:creator>南瓜慢说</dc:creator>
<og:description>1 前言 欢迎访问南瓜慢说 www.pkslow.com获取更多精彩文章！ 出Bug表 南瓜言：先司创业未半而中道破产，今培训造才，网课套钱，此诚百家争鸣之时也。然优秀骨干组队离职，新招小白乐于摸鱼者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/larrydpk/p/13866987.html</dc:identifier>
</item>
<item>
<title>Docker数据卷 - Pluto_H</title>
<link>http://www.cnblogs.com/CSAH/p/13850060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CSAH/p/13850060.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.容器数据卷简介 &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010746721-613923666.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;一句话：有点类似我们&lt;/span&gt;Redis里面的rdb和aof文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.容器数据卷作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010741969-305110392.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;容器的持久化&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;容器间继承&lt;/span&gt;+共享数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.数据卷使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[1].使用命令方式添加&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1).容器添加&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;语法：&lt;/span&gt;docker run -it -v /宿主机绝对路径目录:/容器内目录      镜像名&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;[root@pluto /]# docker run -it -v /myDataVolume:/dataVolumeContainer centos:6.8&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010734760-1154270164.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2).查看数据卷是否挂载成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;语法：&lt;/span&gt;docker inspect 容器ID&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;[root@pluto /]# &lt;strong&gt;docker ps&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;04bd9add86e3        centos:6.8          &quot;/bin/bash&quot;         4 minutes ago       Up 4 minutes                            angry_payne         &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[root@pluto /]# &lt;strong&gt;docker inspect 04bd9add86e3&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010727370-2016858201.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3).容器和宿主机之间数据共享&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010715392-1313547330.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4).容器停止退出后，主机修改后数据是否同步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010708569-900877076.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(5).仅读&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;语法：&lt;/span&gt;docker run -it -v /宿主机绝对路径目录:/容器内目录:ro 镜像名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010700761-1190400575.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[2].DockerFile添加&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1).在主机创建目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;根目录下新建&lt;/span&gt;mydocker文件夹并进入&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;[root@pluto /]# mkdir /mydocker&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[root@pluto /]# cd mydocker/&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;(2).File构建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语法：VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;出于可移植和分享的考虑，用&lt;/span&gt;-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;可在&lt;/span&gt;Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;[root@pluto mydocker]# pwd&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/mydocker&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[root@pluto mydocker]# vim Dockerfile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;# volume test&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FROM centos&lt;strong&gt;:centos6.8&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;VOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CMD echo &quot;finished,--------success1&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CMD /bin/bash&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;  &lt;span&gt;因为本机系统是&lt;/span&gt;centos6.8，所以如果不指定可能会出现&quot;FATAL: kernel too old&quot;的情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3).build&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  build后生成镜像,获得一个新镜像pluto/centos&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;[root@pluto mydocker]# &lt;strong&gt;docker images&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;centos              6.8                 efa3cf7ee1f9        17 months ago       194.5 MB&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[root@pluto mydocker]# &lt;strong&gt;docker build -f /mydocker/Dockerfile -t pluto/centos .&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010643467-849624741.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4).run容器  &lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;[root@pluto mydocker]# docker run -it pluto/centos&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010628041-734166564.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(5).&lt;span&gt;容器卷目录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;找到&lt;/span&gt;容器内的卷目录地址对应的主机目录地址&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;[root@pluto /]# &lt;strong&gt;docker ps&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS               NAMES&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a7e8f6f016b4        pluto/centos        &quot;/bin/sh -c /bin/bas   46 minutes ago      Up 46 minutes                           modest_morse           &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[root@pluto /]# &lt;strong&gt;docker inspect pluto/centos&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010617074-532709366.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010606582-1331346666.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;如果出现&lt;/span&gt;&quot;cannot open directory&quot;的错误&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;Docker&lt;span&gt;挂载主机目录&lt;/span&gt;&lt;span&gt;Docker&lt;/span&gt;&lt;span&gt;访问出现&lt;/span&gt;&lt;span&gt;cannot open directory .: Permission denied&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决办法：在挂载目录后多加一个&lt;span&gt;--privileged=true&lt;/span&gt;&lt;span&gt;参数即可&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;4.数据卷容器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;命名的容器挂载数据卷，其它容器通过挂载这个&lt;/span&gt;(父容器)实现数据共享，挂载数据卷的容器，称之为&lt;strong&gt;数据卷容器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010551901-1411069234.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010546232-1285515046.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;775&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt; Docker run -it --name mydocker1 pluto/cetos&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1617215/202010/1617215-20201021010533921-1248119380.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Oct 2020 15:46:00 +0000</pubDate>
<dc:creator>Pluto_H</dc:creator>
<og:description>1.容器数据卷简介 一句话：有点类似我们Redis里面的rdb和aof文件 2.容器数据卷作用 容器的持久化 容器间继承+共享数据 3.数据卷使用 [1].使用命令方式添加 (1).容器添加 语法：d</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CSAH/p/13850060.html</dc:identifier>
</item>
<item>
<title>rpc服务在游戏中的简单运用 - 二周目赤</title>
<link>http://www.cnblogs.com/cr1719/p/13866841.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cr1719/p/13866841.html</guid>
<description>&lt;p&gt;我们最开始做的游戏框架，多数都是client—&amp;gt;server—&amp;gt;db的模式，但是随着玩家数量的增加，一个server进程就会扛不住，需要多个进程服务于多个玩家。但是给定了不同进程的玩家，有可能需要交互，这就导致了client与server端的连接，有可能是o(1)，但也可能是o(n)连接，o(n)的扩展性非常差，不容易维护，因此可以剔除了。但是如果只保持o(1)，那必然要引入新的抽象服务，网关也就登场了。下图是一个简单的网关部署架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/649412/202010/649412-20201023231755384-2064300593.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;网关的引入，有哪些改变呢？&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;内外网解耦，在保持客外网客户端不变的情况下，可以通过这个中间层调整内网服务的实现&lt;/li&gt;
&lt;li&gt;规范化，由于请求是网关统一接受和分发的，会直接促使客户端在发送和接受请求时规范化&lt;/li&gt;
&lt;li&gt;安全，由于网关具有收口作用，所有的安全问题都可以在这里解决，保护内网，比如反爬，认证等功能&lt;/li&gt;
&lt;li&gt;限流熔断，在网关上实现限流，避免内网被突发流量压垮&lt;/li&gt;
&lt;li&gt;统一的监控告警平台&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;有了网关后，开始在下游增加业务逻辑，可能我们会把所有的业务都耦合成一个service，比如聊天挂了，派系挂了，场景挂了，都可能会对有戏本身产生影响；基于此，不得不考虑拆分进程，之前的游戏service服务，可能会被拆分为多个服务，但是对于大多数的游戏开发人员来说，基于服务的开发，比基于进程的开发，也难的多，如果不是领导推进，也不会有人愿意把聊天做成一个单独的服务。&lt;/p&gt;
&lt;p&gt;对于游戏来说，服务拆分最最极端的情况，就是一个消息cmd对应了一个service，但是这种情况会导致service越来越多，无法维护的程度，实际上游戏拆分也确实没有必要。不过服务service越来越多，某个service甚至处于内存，cpu瓶颈的状态，应该如何解决呢？这时候rpc的服务治理派上了用场。我们对上面的图示做下改动：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/649412/202010/649412-20201023231906696-609027524.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;game-rpc的引入，解决了哪些问题呢？&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;开发人员不再需要关注内部通信机制，减少项目开发时间，降低成本&lt;/li&gt;
&lt;li&gt;强大的集群容错，负载均衡能力等，保证每次调用都能路由到合适的节点&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;service与service做成了集群，每个service启动后，往zk或nacos注册中心注册自己的url。gateway在启动后，订阅zk注册中心的service列表，依托于rpc本身强大的集群，负载等功能，可以自动实现service的切换。&lt;/p&gt;
&lt;p&gt;在针对rpg等长连接游戏类型时，玩家在场景中的移动都需要同步，广播给周围的玩家，但是rpc是单通道的，不能回传，这应该如何处理呢？&lt;/p&gt;
&lt;p&gt;有借于此，game-rpc增加了全双工的概念，不仅仅是client对service的请求，同时service也可以根据uniqueId，进行主动推送。于是上面的流程图变成了下面这样：&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/649412/202010/649412-20201023232022127-2074551359.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;一切看上去都很完美，似乎没有问题了，然而新的问题随之出现。&lt;/p&gt;
&lt;p&gt;我们知道，优秀的架构体系中，单点问题是不能容忍的，很不幸，我们的gateway，就出现了单点。随着玩家数量的增加，整个服务都会处于不可用的状态。于是网关需要拆成集群的模式，新的架构图显示如下：&lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/649412/202010/649412-20201023232108649-1763794779.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;网关拆分后，gate1和gate2的玩家是两个tcp长连状态的服务，无法交互，这应该怎么办？&lt;/p&gt;
&lt;p&gt;我们参照了现行市面上比较常用的tcp网关做法，消息下行通知的解决方案，目前框架支持了两种方式：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;MQ广播机制，当某台网关服务器收到广播消息后，MQ通知给集群内的所有gate server，每个gate在收到消息后，判断要推送端的消息是否是当前gate所持有的会话，如果在当前服务，则进行推送，否则抛弃&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/649412/202010/649412-20201023232202873-1110818510.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;

&lt;div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;redis session共享，针对MQ的广播机制，如果以后游戏火爆，同时有百万玩家在线，那么gate集群里的机器，可能会达到上百台不等，如果每个消息都需要MQ广播，有可能会导致信号风暴，于是我们调整了最后一种解决方案。玩家在登录网关，认证成功后，把玩家id作为key，当前连接的网关uniqueId作为value，存储到redis集群中。网关随后把消息路由到具体某个service，service从redis集群里获取到需要广播的玩家对应的gate服务，service通过rpc消息下行，直接推送到具体的gate，再由gate转发到client&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/649412/202010/649412-20201023232301188-557456053.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;

&lt;p&gt;说明：这种架构，更适用于全区全服类型的游戏。目前我们已经有多款线上游戏使用。&lt;br/&gt;更多交流，也欢迎您关注我的微信公众号：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/649412/202010/649412-20201023232836689-274631775.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img alt=&quot;&quot; data-media-type=&quot;image&quot; data-attr-org-src-id=&quot;9FBE5C88BE024D7CA6A9F152711D1982&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 23 Oct 2020 15:30:00 +0000</pubDate>
<dc:creator>二周目赤</dc:creator>
<og:description>我们最开始做的游戏框架，多数都是client—&amp;gt;server—&amp;gt;db的模式，但是随着玩家数量的增加，一个server进程就会扛不住，需要多个进程服务于多个玩家。但是给定了不同进程的玩家，有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cr1719/p/13866841.html</dc:identifier>
</item>
<item>
<title>Redis 入门与 ASP.NET Core 缓存 - 痴者工良</title>
<link>http://www.cnblogs.com/whuanle/p/13843208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whuanle/p/13843208.html</guid>
<description>&lt;p&gt;如果你还没有 redis 集群，可以参考笔者的另一篇文章：&lt;a href=&quot;https://www.cnblogs.com/whuanle/p/13837153.html&quot;&gt;搭建分布式 Redis Cluster 集群与 Redis 入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文将使用 &lt;a href=&quot;https://stackexchange.github.io/StackExchange.Redis/&quot;&gt;StackExchange.Redis&lt;/a&gt; 库来连接和操作 Redis 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StackExchange.Redis&lt;/code&gt; 的使用，本文只是参照文档，换种方式表示，如果英文基础好，建议阅读文档：&lt;a href=&quot;https://stackexchange.github.io/StackExchange.Redis/Basics&quot;&gt;https://stackexchange.github.io/StackExchange.Redis/Basics&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文内容介绍 &lt;code&gt;StackExchange.Redis&lt;/code&gt; 的使用基础，然后介绍 ASP.NET Core 中的缓存、如何使用 Redis。&lt;/p&gt;
&lt;h2 id=&quot;基础&quot;&gt;基础&lt;/h2&gt;
&lt;h3 id=&quot;redis-库&quot;&gt;Redis 库&lt;/h3&gt;
&lt;p&gt;C# 下 Redis-Client 开源的库很多，有 BeetleX.Redis、csredis、Nhiredis、redis-sharp、redisboost、Rediska、ServiceStack.Redis、Sider、StackExchange.Redis、TeamDev Redis Client。&lt;/p&gt;
&lt;p&gt;这里我们使用 StackExchange.Redis，另外 csredis 现在叶老板(Freesql作者)贡献了大量维护，并且叶老板新开了一个叫 FreeRedis 的框架，目前正在开发中，有兴趣可以参与开发或提出建议。&lt;/p&gt;
&lt;h3 id=&quot;连接-redis&quot;&gt;连接 Redis&lt;/h3&gt;
&lt;p&gt;创建一个 .NET Core 项目，Nuget 库添加引用 &lt;a href=&quot;https://stackexchange.github.io/StackExchange.Redis/&quot;&gt;StackExchange.Redis&lt;/a&gt; ，使用最新版本。&lt;/p&gt;
&lt;p&gt;Redis 默认端口为 6379，如果要连接本地 Redis 服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(&quot;localhost&quot;);
ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(&quot;localhost:6379&quot;);
// ”{ip}:{port}“
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用 redis 集群，则使用 &lt;code&gt;,&lt;/code&gt; 分隔地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(&quot;server1:port1,server2:port2,server3:port3&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能要注意区分集群模式，多 redis 实例的地址，适合主从模式的集群或者 redis culster 集群，哨兵模式笔者还没有测试过。&lt;/p&gt;
&lt;h3 id=&quot;能用-redis-干啥&quot;&gt;能用 redis 干啥&lt;/h3&gt;
&lt;p&gt;redis 具有很多应用场景，一般使用到的场景有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;存储数据(当数据库使用)&lt;/li&gt;
&lt;li&gt;利用 pub/sub 做消息队列&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来将介绍这两种场景的使用方法。&lt;/p&gt;
&lt;h3 id=&quot;redis-数据库存储&quot;&gt;Redis 数据库存储&lt;/h3&gt;
&lt;p&gt;访问 redis 数据库：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;IDatabase db = redis.GetDatabase();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Redis 默认有 16 个数据库，可以 &lt;code&gt;GetDatabase(int db )&lt;/code&gt; 获取指定的数据库。&lt;/p&gt;
&lt;p&gt;使用了 redis cluster 集群的 redis 节点，只有一个数据库，不能自由选择。这里我们只需要使用 &lt;code&gt;redis.GetDatabase()&lt;/code&gt; 即可 。&lt;/p&gt;
&lt;p&gt;Redis 使用比较简单的，大多时候，只要有相应的应用场景，我们查询文档很快就可以掌握，所以这里只介绍字符串的使用。&lt;/p&gt;
&lt;h4 id=&quot;字符串&quot;&gt;字符串&lt;/h4&gt;
&lt;p&gt;redis 的字符串参考：&lt;a href=&quot;https://www.cnblogs.com/whuanle/p/13837153.html#%E5%AD%97%E7%AC%A6%E4%B8%B2string&quot;&gt;https://www.cnblogs.com/whuanle/p/13837153.html#字符串string&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IDatabase 中包含 string 类型的数据操作，其 API 使用 &lt;code&gt;String&lt;/code&gt; 开头，辨识度高。&lt;/p&gt;
&lt;p&gt;设置一个字符串数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;            db.StringSet(&quot;A&quot;, &quot;这是一条字符串数据的值&quot;);
            var value = db.StringGet(&quot;A&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果字符串使用 byte[] (二进制)存储，也可以设置值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;            byte[] str=... ...
            db.StringSet(&quot;A&quot;, str;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Redis 里面，还有其它很多类型，这里我们只介绍字符串，因为 API 其实就那么些，用到的时候再学也可以的。先学字符串的使用，其它就是触类旁通了。&lt;/p&gt;
&lt;h3 id=&quot;订阅发布&quot;&gt;订阅发布&lt;/h3&gt;
&lt;p&gt;订阅某个 Topic，当其改变状态时，订阅者可以收到通知，做分布式消息队列也行。类似 MQTT 协议这样。&lt;/p&gt;
&lt;p&gt;获取订阅器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;ISubscriber sub = redis.GetSubscriber();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;选择订阅的 Topic，并设置回调函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;sub.Subscribe(&quot;Message&quot;, (channel, message) =&amp;gt; {
    Console.WriteLine((string)message);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当某一方订阅了 &lt;code&gt;Message&lt;/code&gt; ，在另一个地方，有别的客户端(也可以是自己)推送 Topic ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;sub.Publish(&quot;Message&quot;,&quot;你有一条新的消息，请注意查收&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Topic 推送后，订阅方可以收到推送的消息。&lt;/p&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;            ISubscriber sub = redis.GetSubscriber();

            sub.Subscribe(&quot;Message&quot;, (channel, message) =&amp;gt; {
                Console.WriteLine((string)message);
            });

            Thread.Sleep(1000);

            sub.Publish(&quot;Message&quot;,&quot;你有一条新的消息，请注意查收&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;channel ：Topic 的名称，即上面的 Message。&lt;/p&gt;
&lt;p&gt;message：推送的消息内容。&lt;/p&gt;
&lt;h3 id=&quot;redisvalue&quot;&gt;RedisValue&lt;/h3&gt;
&lt;p&gt;使用 API 设置值的时候，都会有这个参数。因为 Redis 中的值只能是 “字符串”，因此 C# 中也要遵守这种规则，但是 C# 是强类型语言，而且有那么多值类型，只使用 string ，编写代码时会有诸多不便。&lt;/p&gt;
&lt;p&gt;因此，就创建了 RedisValue 这个类型，里面有大量的隐式转换重载，所以我们可以使用 C# 的简单类型存储数据以及获取数据，避免手工转换。&lt;/p&gt;
&lt;p&gt;当然这个说法不是很准确，使用 RedisValue 主要考虑转换方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1315495/202010/1315495-20201019212458231-1406173484.png&quot; alt=&quot;RedisValue隐式转换&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;入门的知识就介绍到这里，更多的 Redis 知识可以查看官方文档。下面开始介绍 AS.NET Core 使用分布式缓存。&lt;/p&gt;
&lt;h2 id=&quot;aspnet-core-缓存与分布式缓存&quot;&gt;ASP.NET Core 缓存与分布式缓存&lt;/h2&gt;
&lt;p&gt;ASP.NET Core 里面有很多定义的标准接口，例如日志、缓存等，这些接口为开发者设置了统一的定义和功能，上层服务不需要变更代码就能切换类库，底层使用哪种库对上层没有影响。&lt;/p&gt;
&lt;p&gt;ASP.NET Core 中的缓存，可以使用多种方式完成，例如 Redis，内存，关系型数据库，文件缓存等。而且根据拓展性，可以分为本机缓存，分布式缓存。&lt;/p&gt;
&lt;p&gt;本机缓存常见的是内存缓存，内存缓存可以存储任何对象。 分布式缓存最常见的是 Redis，分布式缓存接口仅限 &lt;code&gt;byte[]&lt;/code&gt;(指参数，继续看到后面的小节就明白了) 。 内存缓存和分布式缓存都使用键值对来存储缓存项。&lt;/p&gt;
&lt;h3 id=&quot;内存中的缓存&quot;&gt;内存中的缓存&lt;/h3&gt;
&lt;h4 id=&quot;aspnet-core-的内存缓存&quot;&gt;ASP.NET Core 的内存缓存&lt;/h4&gt;
&lt;p&gt;ASP.NET Core 内存缓存是指一般是单机(本机)使用的，一般这种内存缓存框架是 &lt;code&gt;System.Runtime&lt;/code&gt; 或 Microsoft 包提供的，因为不需要考虑分布式或者复杂的结构，所以一般不需要第三方库。这里的内存缓存并不只是指数据在内存中，所以需要区分 Redis 这类专业的缓存框架。且这里缓存只是作为提高性能而用。&lt;/p&gt;
&lt;p&gt;这种缓存主要有两种功能比较丰富的实现 System.Runtime.Caching &lt;code&gt;和&lt;/code&gt;MemoryCache`。&lt;/p&gt;
&lt;h4 id=&quot;在内存中缓存、存储数据&quot;&gt;在内存中缓存、存储数据&lt;/h4&gt;
&lt;p&gt;在 ASP.NET Core 的内存缓存之外，我们来讨论一下，编写代码时，自己设置的内存缓存是否合理。&lt;/p&gt;
&lt;p&gt;我们都知道，&lt;strong&gt;使用内存缓存是为了提高代码性能而用的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里笔者个人认为可以从两个层次来对这种缓存归类讨论。&lt;/p&gt;
&lt;p&gt;第一种，对于要多次使用、而每次使用都需要计算、源数据相同则结果相同的，可以使用内存缓存。例如反射就比较消耗时间(速度慢)，可以使用内存缓存起来，下次直接取得信息而不需要重新计算。&lt;/p&gt;
&lt;p&gt;下面笔者说一下理由。&lt;/p&gt;
&lt;p&gt;内存缓存用在反射缓存这类缓存上，缓存的数据源是可确定的、可计算总量的，而且这部分内存不需要频繁增加或者减少，不仅提高了性能，对 GC 来说也可以一定程度上减少回收压力，更重要的是开发者可以降低缓存的复杂程度。&lt;/p&gt;
&lt;p&gt;这种缓存主要为了避免重复计算，或者重复导入(例如加载程序集、从文件加载数据)等。如果数据最近出现过，而且后面一段时间不会变化，使用内存来缓存也很实在，例如 MVC 的视图、每15分钟刷新一次的排行榜等。&lt;/p&gt;
&lt;p&gt;第二种是使用内存存储数据，很多人单纯是因为内存存储数据特别快，把内存当作数据库来玩，因此&lt;strong&gt;很容易导致内存泄露&lt;/strong&gt;。最常见的就是使用静态字典、静态列表等，然后编写方法增删查改数据，这一类在压力测试下或者请求量大一些、变动比较频繁的时候，内存堆积特别厉害。&lt;/p&gt;
&lt;p&gt;需要频繁变化或需要实时变化的数据，存储在内存中确实速度非常快，如何确定数据失效、去除无用数据等需要有很深的考虑。&lt;/p&gt;
&lt;p&gt;另外，在内存中如使用字典大量存储数据，数据量很多的情况下，每次索引数据的时间都会变长，如果使用了 Linq 或者 for 或者 foreach 等检索数据，也很容易出现耗时长的时间复杂度。这种情况下，你是相信自己的代码，还是相信 Mysql、SqlServer 等数据库？ Hash 算法和红黑树都了解了嘛？&lt;/p&gt;
&lt;p&gt;如果实在有需求需要使用内存缓存数据，并且可能动态增加或移除数据的话，可以使用 WeakReference 弱引用，即在引用对象的同时仍然允许 GC 回收该对象。缺点是数据可能丢失，不适合需要持久化的数据。&lt;/p&gt;
&lt;p&gt;但无论情况，我们可以确定：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存都是副本&lt;/li&gt;
&lt;li&gt;缓存丢失不影响程序的使用&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;缓存不能无限增长&lt;/li&gt;
&lt;li&gt;缓存避免复杂结构&lt;/li&gt;
&lt;li&gt;... ...&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;imemorycache&quot;&gt;IMemoryCache&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;IMemoryCache&lt;/code&gt; 提供的接口太少了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        ICacheEntry CreateEntry(object key);
        void Remove(object key);
        bool TryGetValue(object key, out object value);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;适合单一的键值缓存。&lt;/p&gt;
&lt;p&gt;此接口在 &lt;code&gt;Microsoft.Extensions.Caching.Memory&lt;/code&gt; 中有实现，例如 MemoryCache 。适合 ASP.NET Core 中使用。&lt;/p&gt;
&lt;h4 id=&quot;memorycache&quot;&gt;MemoryCache&lt;/h4&gt;
&lt;p&gt;这里的 MemoryCache 并不是指 IMemoryCache 的实现，而是指 &lt;code&gt;System.Runtime.Caching.MemoryCache&lt;/code&gt;，需要安装 Nuget 包。&lt;/p&gt;
&lt;p&gt;可以实现对实例对象的缓存，请查看查看官方文档：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.caching.memorycache?view=dotnet-plat-ext-3.1&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.caching.memorycache?view=dotnet-plat-ext-3.1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外内存缓存还有一个分布式内存缓存，但不是真正的分布式，信息可以参考：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/distributed?view=aspnetcore-3.1#distributed-memory-cache&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/distributed?view=aspnetcore-3.1#distributed-memory-cache&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;分布式缓存&quot;&gt;分布式缓存&lt;/h3&gt;
&lt;p&gt;ASP.NET Core 分布式缓存，则使用了 &lt;strong&gt;IDistributedCache&lt;/strong&gt; 这个统一的接口。如果你在 Nuget 搜索 &lt;strong&gt;IDistributedCache&lt;/strong&gt; ，会发现相关的库非常多。&lt;/p&gt;
&lt;p&gt;分布式缓存的使用，除了最常见的 Redis，SQLServer 也行，只要实现了 &lt;strong&gt;IDistributedCache&lt;/strong&gt; 就ok。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1315495/202010/1315495-20201022214446474-1758912220.png&quot; alt=&quot;IDistributedCache&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;idistributedcache&quot;&gt;IDistributedCache&lt;/h4&gt;
&lt;p&gt;IDistributedCache 接口提供的方法实在太少了，有四个异步方法四个同步方法，这里只介绍异步方法。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;GetAsync(String, CancellationToken)&lt;/td&gt;
&lt;td&gt;获取一个键的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;RefreshAsync(String, CancellationToken)&lt;/td&gt;
&lt;td&gt;基于缓存中某个值的键刷新该值，并重置其可调到期超时（如果有）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;RemoveAsync(String, CancellationToken)&lt;/td&gt;
&lt;td&gt;删除一个键&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;SetAsync(String, Byte[], DistributedCacheEntryOptions, CancellationToken)&lt;/td&gt;
&lt;td&gt;设置一个键的值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;局限还是很大的，只能使用字符串。估计大家可能没怎么使用？&lt;/p&gt;
&lt;p&gt;ASP.NET Core 官方支持的分布式缓存，目前主要有 NCache、Redis、SqlServer。本节只讨论 Redis。&lt;/p&gt;
&lt;h4 id=&quot;redis-缓存&quot;&gt;Redis 缓存&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://stackexchange.github.io/StackExchange.Redis/&quot;&gt;StackExchange.Redis&lt;/a&gt; 是 ASP.NET Core 官方推荐的 Redis 框架，并且官方对其做了封装，可以到 Nuget 搜索 &lt;code&gt;Microsoft.Extensions.Caching.StackExchangeRedis&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;RedisCache 继承了 IDistributedCache 接口。&lt;/p&gt;
&lt;p&gt;Startup.ConfigureServices 中配置服务注册：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;            services.AddStackExchangeRedisCache(options =&amp;gt;
            {
                options.Configuration = &quot;ip:端口,ip1:端口,ip2:端口&quot;;  // redis 集群或单机
                options.InstanceName = &quot;mvc&quot;;                                           // 实例 名称
            });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依赖注入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        private readonly IDistributedCache _cache;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        public async Task&amp;lt;string&amp;gt; Test(string key,string value)
        {
            await _cache.SetStringAsync(key, value);
            return await _cache.GetStringAsync(key);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置缓存时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;            var options = new DistributedCacheEntryOptions()
            .SetSlidingExpiration(TimeSpan.FromSeconds(20));
            await _cache.SetStringAsync(key, value, options);
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 23 Oct 2020 14:46:00 +0000</pubDate>
<dc:creator>痴者工良</dc:creator>
<og:description>如果你还没有 redis 集群，可以参考笔者的另一篇文章：搭建分布式 Redis Cluster 集群与 Redis 入门 本文将使用 StackExchange.Redis 库来连接和操作 Redi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whuanle/p/13843208.html</dc:identifier>
</item>
<item>
<title>基础算法之快慢指针 - 龙城飞将军</title>
<link>http://www.cnblogs.com/jason0529/p/13866630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jason0529/p/13866630.html</guid>
<description>&lt;p&gt;快慢指针即使用一快一慢两个指针，对链表进行遍历。利用两个指针的速度差，如2倍速-用于求中间指针或循环链表；恒定n个差值，用于寻找倒数第n个指针。&lt;/p&gt;
&lt;h2 id=&quot;1-环形链表&quot;&gt;1. 环形链表&lt;/h2&gt;
&lt;p&gt;如果快指针到达NULL，说明链表以NULL结尾，不存在环。如果快指针追上慢指针，则表示有环。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    ListNode slow = head;
    ListNode fast = head.next;
    while (slow != fast) {
        if (fast == null || fast.next == null) {
            return false;
        }
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2-找中间值&quot;&gt;2. 找中间值&lt;/h2&gt;
&lt;p&gt;我们把一个链表看成一个跑道，假设a的速度是b的两倍，那么当a跑完全程后，b刚好跑一半，以此来达到找到中间节点的目的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;publicListNode endOfFirstHalf(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    while (fast.next != null &amp;amp;&amp;amp; fast.next.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-删除倒数第n个节点&quot;&gt;3. 删除倒数第N个节点&lt;/h2&gt;
&lt;p&gt;快指针先走n步，慢指针开始和快指针同步移动到next，当快指针到达链表尾部时，慢指针刚好移动到倒数第n-1个节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Java&quot;&gt;public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode fast = head;
    ListNode slow = head;
    //慢指针比快指针慢N步,那么快指针指向末尾的null时,慢指针刚好指向要删除结点的前驱结点
    while (fast.next != null) {
        fast = fast.next;
        if (n == 0) {
            slow = slow.next;
        } else {
            n--;
        }
    }
    if (n != 0) { //没追上,说明删除的是头指针
        return head.next;
    } else {
        slow.next = slow.next.next;
    }
    return head;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;快慢指针在链表类的迭代中，时间复杂度是O(n)的量级，是一种能有效控制时间复杂的算法。&lt;/p&gt;
</description>
<pubDate>Fri, 23 Oct 2020 14:38:00 +0000</pubDate>
<dc:creator>龙城飞将军</dc:creator>
<og:description>快慢指针即使用一快一慢两个指针，对链表进行遍历。利用两个指针的速度差，如2倍速-用于求中间指针或循环链表；恒定n个差值，用于寻找倒数第n个指针。 1. 环形链表 如果快指针到达NULL，说明链表以NU</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jason0529/p/13866630.html</dc:identifier>
</item>
<item>
<title>在PostgreSQL中CREATE STATISTICS - 黑洞中的奇点</title>
<link>http://www.cnblogs.com/kelvin19840813/p/13866571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kelvin19840813/p/13866571.html</guid>
<description>&lt;p&gt;&lt;span&gt;如果你用Postgres做了一些性能调优，你可能用过EXPLAIN。EXPLAIN向你展示了PostgreSQL计划器为所提供的语句生成的执行计划，它显示了语句所引用的表如何被扫描（使用顺序扫描、索引扫描等）。它显示了语句所引用的表将如何被扫描（使用顺序扫描，索引扫描等），以及如果使用多个表，将使用什么连接算法。但是，Postgres是如何提出这些计划的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;决定使用哪种计划的一个非常重要的输入是计划员收集的统计数据。这些统计数据让计划员能够估计在执行计划的某一部分后会返回多少行，然后影响将使用的扫描或连接算法的种类。它们主要是通过运行ANALYZE或VACUUM（以及一些DDL命令，如CREATE INDEX）来收集/更新的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些统计数据被规划者存储在pg_class和pg_statistics中。Pg_class基本上存储了每个表和索引的总条目数，以及它们占用的磁盘块数。Pg_statistic存储的是每一列的统计数据，比如该列有多少%的值是空的，最常见的值是什么，直方图界限等。在下面的表格中，你可以看到Postgres为col1收集到的统计数据的例子。下面的查询输出显示，planner（正确）估计表中col1列有1000个不同的值，还对最常见的值、频率等进行了其他估计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请注意，我们已经查询了pg_stats（一个持有更可读的列统计版本的视图）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; tbl (                                                                        
    col1 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,                                                                             
    col2 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;                                                                              
);                                                                                        

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; tbl &lt;span&gt;SELECT&lt;/span&gt; i&lt;span&gt;/&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;, i&lt;span&gt;/&lt;/span&gt;&lt;span&gt;100000&lt;/span&gt;                                                  
&lt;span&gt;FROM&lt;/span&gt; generate_series (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10000000&lt;/span&gt;&lt;span&gt;) s(i);                                                   

ANALYZE tbl;                                     

&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; pg_stats &lt;span&gt;where&lt;/span&gt; tablename &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tbl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; attname &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;col1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; RECORD 1 &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--------+---------------------------------------------------------------------------------&lt;/span&gt;
schemaname             &lt;span&gt;|&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;
tablename              &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; tbl
attname                &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; col1
inherited              &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; f
null_frac              &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
avg_width              &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
n_distinct             &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
most_common_vals       &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; {&lt;span&gt;318&lt;/span&gt;,&lt;span&gt;564&lt;/span&gt;,&lt;span&gt;596&lt;/span&gt;&lt;span&gt;,...}
most_common_freqs      &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; {&lt;span&gt;0.00173333&lt;/span&gt;,&lt;span&gt;0.0017&lt;/span&gt;,&lt;span&gt;0.00166667&lt;/span&gt;,&lt;span&gt;0.00156667&lt;/span&gt;&lt;span&gt;,...}
histogram_bounds       &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; {&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;,&lt;span&gt;39&lt;/span&gt;&lt;span&gt;,...}
correlation            &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
most_common_elems      &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; 
most_common_elem_freqs &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; 
elem_count_histogram   &lt;/span&gt;&lt;span&gt;|&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当单列统计不够用的时候&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这些单列统计有助于planner估计条件的选择性（这就是planner用来估计索引扫描将选择多少行的原因）。当在查询中提供了多个条件时，planner会假设这些列（或where子句条件）是相互独立的。当列之间相互关联或相互依赖时，这就不成立了，这将导致规划者低估或高估这些条件所返回的行数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我们来看几个例子。为了使计划简单易读，我们通过设置max_parallel_workers_per_gather为0来关闭每个查询的并行性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;EXPLAIN ANALYZE &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; tbl &lt;span&gt;where&lt;/span&gt; col1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;                            
                                                QUERY &lt;/span&gt;&lt;span&gt;PLAN&lt;/span&gt;                                                 
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------------------------------------------------------------------------------------------------------&lt;/span&gt;
 Seq Scan &lt;span&gt;on&lt;/span&gt; tbl  (cost&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt;..&lt;span&gt;169247.80&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;9584&lt;/span&gt; width&lt;span&gt;=&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;) (actual time&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0.641&lt;/span&gt;..&lt;span&gt;622.851&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt; loops&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
   Filter: (col1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
   Rows Removed &lt;/span&gt;&lt;span&gt;by&lt;/span&gt; Filter: &lt;span&gt;9990000&lt;/span&gt;&lt;span&gt;
 Planning time: &lt;/span&gt;&lt;span&gt;0.051&lt;/span&gt;&lt;span&gt; ms
 Execution time: &lt;/span&gt;&lt;span&gt;623.185&lt;/span&gt;&lt;span&gt; ms
(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; rows)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;正如你在这里看到的，planner估计col1的值为1的行数为9584，而查询返回的实际行数为10000。所以，非常准确。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，当你在第1列和第2列上都包含过滤器时，会发生什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;EXPLAIN ANALYZE &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; tbl &lt;span&gt;where&lt;/span&gt; col1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; col2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;                            
                                                QUERY &lt;/span&gt;&lt;span&gt;PLAN&lt;/span&gt;                                                
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--------------------------------------------------------------------------------------------------------&lt;/span&gt;
 Seq Scan &lt;span&gt;on&lt;/span&gt; tbl  (cost&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt;..&lt;span&gt;194248.69&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; width&lt;span&gt;=&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;) (actual time&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0.640&lt;/span&gt;..&lt;span&gt;630.130&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt; loops&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
   Filter: ((col1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;AND&lt;/span&gt; (col2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
   Rows Removed &lt;/span&gt;&lt;span&gt;by&lt;/span&gt; Filter: &lt;span&gt;9990000&lt;/span&gt;&lt;span&gt;
 Planning time: &lt;/span&gt;&lt;span&gt;0.072&lt;/span&gt;&lt;span&gt; ms
 Execution time: &lt;/span&gt;&lt;span&gt;630.467&lt;/span&gt;&lt;span&gt; ms
(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; rows)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;planner的估算已经偏离了100倍! 让我们试着了解一下为什么会出现这种情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一列的选择性大约是0.001（1/1000），第二列的选择性是0.01（1/100）。为了计算被这2个 &quot;独立 &quot;条件过滤的行数，planner将它们的选择性相乘。所以，我们得到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择性 = 0. 001 * 0. 01 = 0. 00001.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当这个乘以我们在表中的行数即10000000时，我们得到100。这就是planner估计的100的由来。但是，这几列不是独立的，我们怎么告诉planner呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在PostgreSQL中CREATE STATISTICS&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在Postgres 10之前，并没有一个简单的方法来告诉计划员收集统计数据，从而捕捉到列之间的这种关系。但是，在Postgres 10中，有一个新的功能正是为了解决这个问题而建立的。CREATE STATISTICS可以用来创建扩展的统计对象，它可以告诉服务器收集关于这些有趣的相关列的额外统计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;功能依赖性统计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;回到我们之前的估算问题，问题是col2的值其实不过是col 1 / 10。在数据库术语中，我们会说col2在功能上依赖于col1。这意味着col1的值足以决定col2的值，不存在两行col1的值相同而col2的值不同的情况。因此，col2上的第2个过滤器实际上并没有删除任何行！但是，planner捕捉到了足够的统计数据。但是，规划者捕捉到了足够的统计数据来知道这一点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们创建一个统计对象来捕获关于这些列的功能依赖统计，并运行ANALYZE。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;STATISTICS&lt;/span&gt; s1 (dependencies) &lt;span&gt;on&lt;/span&gt; col1, col2 &lt;span&gt;from&lt;/span&gt;&lt;span&gt; tbl; 
ANALYZE tbl;

让我们看看planner现在拿出了什么。

EXPLAIN ANALYZE &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; tbl &lt;span&gt;where&lt;/span&gt; col1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; col2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;                            
                                                QUERY &lt;/span&gt;&lt;span&gt;PLAN&lt;/span&gt;                                                 
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------------------------------------------------------------------------------------------------------&lt;/span&gt;
 Seq Scan &lt;span&gt;on&lt;/span&gt; tbl  (cost&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt;..&lt;span&gt;194247.76&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;9584&lt;/span&gt; width&lt;span&gt;=&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;) (actual time&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0.638&lt;/span&gt;..&lt;span&gt;629.741&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt; loops&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
   Filter: ((col1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;AND&lt;/span&gt; (col2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
   Rows Removed &lt;/span&gt;&lt;span&gt;by&lt;/span&gt; Filter: &lt;span&gt;9990000&lt;/span&gt;&lt;span&gt;
 Planning time: &lt;/span&gt;&lt;span&gt;0.115&lt;/span&gt;&lt;span&gt; ms
 Execution time: &lt;/span&gt;&lt;span&gt;630.076&lt;/span&gt;&lt;span&gt; ms
(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; rows)

好多了! 我们来看看是什么帮助planner做出了这个决定。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;SELECT stxname, stxkeys, stxdependencies&lt;/span&gt;&lt;br/&gt;&lt;span&gt;FROM pg_statistic_ext&lt;/span&gt;&lt;br/&gt;&lt;span&gt;WHERE stxname = 's1';&lt;/span&gt;&lt;br/&gt;&lt;span&gt;stxname | stxkeys | stxdependencies&lt;/span&gt;&lt;br/&gt;&lt;span&gt;---------+---------+----------------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;s1 | 1 2 | {&quot;1 =&amp;gt; 2&quot;: 1.000000}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(1 row)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从这一点来看，我们可以看到Postgres意识到col1完全决定了col2，因此有一个系数为1来捕捉这些信息。现在，所有对这两列进行过滤的查询都会有更好的估计。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;差异化统计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;功能依赖性是你可以捕获列之间的一种关系。另一种你可以捕捉的统计是一组列的不同值的数量。我们在前面提到过，planner捕捉到的是每一列的独特值数的统计，但是当组合多于一列时，这些统计又经常出错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么时候有不好的独特统计会伤害到我呢？让我们来看一个例子。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;EXPLAIN ANALYZE &lt;span&gt;SELECT&lt;/span&gt; col1,col2,&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; tbl &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; col1, col2;                   
                                                         QUERY &lt;/span&gt;&lt;span&gt;PLAN&lt;/span&gt;                                                          
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------------------------------------------------------------------------------------------------------------------------&lt;/span&gt;
 GroupAggregate  (cost&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1990523.20&lt;/span&gt;..&lt;span&gt;2091523.04&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;100000&lt;/span&gt; width&lt;span&gt;=&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;) (actual time&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2697.246&lt;/span&gt;..&lt;span&gt;4470.789&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1001&lt;/span&gt; loops&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
   &lt;/span&gt;&lt;span&gt;Group&lt;/span&gt; &lt;span&gt;Key&lt;/span&gt;&lt;span&gt;: col1, col2
   &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;  Sort  (cost&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1990523.20&lt;/span&gt;..&lt;span&gt;2015523.16&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;9999984&lt;/span&gt; width&lt;span&gt;=&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;) (actual time&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2695.498&lt;/span&gt;..&lt;span&gt;3440.880&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10000000&lt;/span&gt; loops&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
         Sort &lt;/span&gt;&lt;span&gt;Key&lt;/span&gt;&lt;span&gt;: col1, col2
         Sort Method: external sort  &lt;/span&gt;&lt;span&gt;Disk&lt;/span&gt;&lt;span&gt;: 176128kB
         &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;  Seq Scan &lt;span&gt;on&lt;/span&gt; tbl  (cost&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt;..&lt;span&gt;144247.84&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;9999984&lt;/span&gt; width&lt;span&gt;=&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;) (actual time&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0.008&lt;/span&gt;..&lt;span&gt;665.689&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10000000&lt;/span&gt; loops&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
 Planning time: &lt;/span&gt;&lt;span&gt;0.072&lt;/span&gt;&lt;span&gt; ms
 Execution time: &lt;/span&gt;&lt;span&gt;4494.583&lt;/span&gt; ms&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;聚合行时，Postgres会选择做哈希聚合或分组聚合。如果它能在内存中装下哈希表，它就选择哈希聚合，否则它选择将所有的行进行排序，然后根据col1，col2进行分组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，planner估计组的数量（等于col1，col2的不同值的数量）将是100000。它看到它没有足够的work_mem来存储这个哈希表在内存中。所以，它使用基于磁盘的排序来运行查询。然而，在计划的实际部分可以看到，实际行数只有1001。而也许，我们有足够的内存将它们装入内存，并进行哈希聚合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们让计划员抓取n_distinct统计，重新运行查询，就知道了。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;STATISTICS&lt;/span&gt; s2 (ndistinct) &lt;span&gt;on&lt;/span&gt; col1, col2 &lt;span&gt;from&lt;/span&gt;&lt;span&gt; tbl;                                  
ANALYZE tbl;

EXPLAIN ANALYZE &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; col1,col2,&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; tbl &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; col1, col2;                   
                                                      QUERY &lt;/span&gt;&lt;span&gt;PLAN&lt;/span&gt;                                                       
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---------------------------------------------------------------------------------------------------------------------&lt;/span&gt;
 HashAggregate  (cost&lt;span&gt;=&lt;/span&gt;&lt;span&gt;219247.63&lt;/span&gt;..&lt;span&gt;219257.63&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt; width&lt;span&gt;=&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;) (actual time&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2431.767&lt;/span&gt;..&lt;span&gt;2431.928&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1001&lt;/span&gt; loops&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
   &lt;/span&gt;&lt;span&gt;Group&lt;/span&gt; &lt;span&gt;Key&lt;/span&gt;&lt;span&gt;: col1, col2
   &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;  Seq Scan &lt;span&gt;on&lt;/span&gt; tbl  (cost&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt;..&lt;span&gt;144247.79&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;9999979&lt;/span&gt; width&lt;span&gt;=&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;) (actual time&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0.008&lt;/span&gt;..&lt;span&gt;643.488&lt;/span&gt; rows&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10000000&lt;/span&gt; loops&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
 Planning time: &lt;/span&gt;&lt;span&gt;0.129&lt;/span&gt;&lt;span&gt; ms
 Execution time: &lt;/span&gt;&lt;span&gt;2432.010&lt;/span&gt;&lt;span&gt; ms
(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; rows)

你可以看到，现在的估计值更加准确了（即1000），查询速度也快了2倍左右。我们可以通过运行下面的查询，看看planner学到了什么。

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; stxkeys &lt;span&gt;AS&lt;/span&gt; k, stxndistinct &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; nd                                                   
  &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; pg_statistic_ext                                                                   
  &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; stxname &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
  k  &lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;       nd       
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;---+----------------&lt;/span&gt;
 &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; {&quot;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&quot;: &lt;span&gt;1000&lt;/span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;现实的影响&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在实际的生产模式中，你总会有某些列，它们之间有依赖关系或关系，而数据库并不知道。我们在云端的Citus开源和Citus客户中看到的一些例子是。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有月、季、年的列，因为你想在报表中显示所有分组的统计数据。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;地理层次结构之间的关系。例如，拥有国家、州和城市列，并通过它们进行过滤/分组。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这里的例子在数据集中只有10M行，我们已经看到，在有相关列的情况下，使用CREATE统计可以显著改善计划，也显示出性能的提高。我们有用户存储了数十亿行的数据，糟糕的计划会带来巨大的影响。在我们的例子中，当计划员选择了一个糟糕的计划时，我们不得不对10M行进行基于磁盘的排序，想象一下，如果有几十亿行的数据，会有多糟糕。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 23 Oct 2020 14:24:00 +0000</pubDate>
<dc:creator>黑洞中的奇点</dc:creator>
<og:description>如果你用Postgres做了一些性能调优，你可能用过EXPLAIN。EXPLAIN向你展示了PostgreSQL计划器为所提供的语句生成的执行计划，它显示了语句所引用的表如何被扫描（使用顺序扫描、索引</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kelvin19840813/p/13866571.html</dc:identifier>
</item>
</channel>
</rss>