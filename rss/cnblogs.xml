<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>可以Postman，也可以cURL.进来领略下cURL的独门绝技 - 未读代码</title>
<link>http://www.cnblogs.com/niumoo/p/13041473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/13041473.html</guid>
<description>&lt;blockquote readability=&quot;4.8066298342541&quot;&gt;
&lt;p&gt;文章已经收录在 &lt;a href=&quot;https://github.com/niumoo/JavaNotes&quot;&gt;Github.com/niumoo/JavaNotes&lt;/a&gt; ，更有 Java 程序员所需要掌握的核心知识，欢迎Star和指教。&lt;br/&gt;欢迎关注我的&lt;a href=&quot;https://github.com/niumoo/JavaNotes#%E5%85%AC%E4%BC%97%E5%8F%B7&quot;&gt;公众号&lt;/a&gt;，文章每周更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/curl-logo.svg&quot; alt=&quot;curl logo&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://curl.haxx.se/&quot;&gt;&lt;strong&gt;cURL&lt;/strong&gt;&lt;/a&gt; 是一个开源免费项目，主要是命令行工具 &lt;strong&gt;cURL&lt;/strong&gt; 和 libcurl，&lt;strong&gt;cURL&lt;/strong&gt; 可以处理任何网络传输协议，但是不涉及任何具体的&lt;strong&gt;数据处理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cURL&lt;/strong&gt; 支持的通信协议非常丰富，如 DICT，FILE，FTP，FTPS，GOPHER，HTTP，HTTPS，IMAP，IMAPS，LDAP，LDAPS，MQTT，POP3，POP3S，RTMP， RTMPS，RTSP，SCP，SFTP，SMB，SMBS，SMTP，SMTPS，TELNET 以及 TFTP。查看 cURL 源代码可以访问官方 &lt;a href=&quot;https://github.com/curl/curl&quot;&gt;Github&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果安装 &lt;strong&gt;cURL&lt;/strong&gt; 呢？&lt;/p&gt;
&lt;p&gt;ubuntu / Debian.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo apt install curl
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CentOS / Fedora.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo yum install curl
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Windows.&lt;/p&gt;
&lt;p&gt;如果你已经安装了 Git，那么 Git Bash 自带 &lt;strong&gt;cURL&lt;/strong&gt; . 如果作为开发者你 git 都没有，那么只能官方&lt;a href=&quot;https://curl.haxx.se/download.html&quot;&gt;手动下载&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;1-请求源码&quot;&gt;1. 请求源码&lt;/h3&gt;
&lt;p&gt;直接 curl 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl http://wttr.in/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面请求的示例网址是一个天气网站，很有意思，会根据你的请求 ip 信息返回你所在位置的天气情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200530175034329.png&quot; alt=&quot;curl wttr.in&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写这篇文字时我所在的上海正在下雨，窗外飘雨无休无止。&lt;/p&gt;
&lt;h3 id=&quot;2-文件下载&quot;&gt;2. 文件下载&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;-o&lt;/code&gt; 保存文件，类似于 wget 命令，比如下载 README 文本保存为 readme.txt 文件。如果你需要自定义文件名，可以使用 &lt;code&gt;-O&lt;/code&gt;自定使用 url 中的文件名。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl -o readme.txt https://mirrors.nju.edu.cn/kali/README
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   159  100   159    0     0   1939      0 --:--:-- --:--:-- --:--:--  1939
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载文件会显示下载状态，如数据量大小、传输速度、剩余时间等。可以使用 &lt;code&gt;-s&lt;/code&gt; 参数禁用进度表。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl -o readme.txt https://mirrors.nju.edu.cn/kali/README
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   159  100   159    0     0   1939      0 --:--:-- --:--:-- --:--:--  1939
$ 
$ curl -o readme.txt https://mirrors.nju.edu.cn/kali/README -s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用 &lt;code&gt;--process-bar&lt;/code&gt; 参数让进度表显示为进度条。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl -o readme.txt https://mirrors.nju.edu.cn/kali/README --progress-bar
########################################################################################## 100.0%
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;cURL&lt;/strong&gt; 作为强大的代名词，断点续传自然手到擒来，使用 &lt;code&gt;-C -&lt;/code&gt; 参数即可。下面是断点续传下载 ubuntu20.04 镜像的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl -O https://mirrors.nju.edu.cn/ubuntu-releases/20.04/ubuntu-20.04-desktop-amd64.iso --progress-bar
##                                                                                               1.7%
^C
$ curl -C - -O https://mirrors.nju.edu.cn/ubuntu-releases/20.04/ubuntu-20.04-desktop-amd64.iso --progress-bar
###                                                                                              2.4%
^C
$ curl -C - -O https://mirrors.nju.edu.cn/ubuntu-releases/20.04/ubuntu-20.04-desktop-amd64.iso --progress-bar
###                                                                                               2.7%
^C
$ 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么？下载时不想占用太多网速？使用 &lt;code&gt;--limit-rate&lt;/code&gt; 限个速吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl -C - -O https://mirrors.nju.edu.cn/ubuntu-releases/20.04/ubuntu-20.04-desktop-amd64.iso --limit-rate 100k
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么？你又要从 FTP 服务器下载文件了？不慌。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl -u user:password -O ftp://ftp_server/path/to/file/
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;-i&lt;/code&gt; 参数显示 Response Headers 信息。使用 &lt;code&gt;-I&lt;/code&gt; 可以只显示 Response Headers 信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl -I http://wttr.in
HTTP/1.1 200 OK
Server: nginx/1.10.3
Date: Sat, 30 May 2020 09:57:03 GMT
Content-Type: text/plain; charset=utf-8
Content-Length: 8678
Connection: keep-alive
Access-Control-Allow-Origin: *
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4-请求方式getpost&quot;&gt;4. 请求方式(GET/POST/...)&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;-X&lt;/code&gt; 轻松更改请求方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl -X GET http://wttr.in
$ curl -X POST http://wttr.in
$ curl -X PUT http://wttr.in
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5-请求参数&quot;&gt;5. 请求参数&lt;/h3&gt;
&lt;p&gt;以传入参数 &lt;code&gt;name&lt;/code&gt; 值为 &lt;code&gt;未读代码&lt;/code&gt; 为例。&lt;/p&gt;
&lt;p&gt;Get 方式参数直接url拼接参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl -X GET http://wttr.in?name=未读代码
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Post 方式使用 &lt;code&gt;--data&lt;/code&gt; 设置参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl -X POST --data &quot;name=未读代码&quot; http://wttr.in
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求时也可以自定义 &lt;strong&gt;header&lt;/strong&gt; 参数，使用 &lt;code&gt;--harder&lt;/code&gt; 添加。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl --header &quot;Content-Type:application/json&quot; http://wttr.in
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;6-文件上传&quot;&gt;6. 文件上传&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;cURL&lt;/strong&gt; 的强大远不止此，表单提交，上传文件内容也不在话下，只需要使用 &lt;code&gt;-F&lt;/code&gt; 或者 &lt;code&gt;-D&lt;/code&gt;参数，&lt;code&gt;-F&lt;/code&gt; 会自动加上请求头 &lt;code&gt;Content-Type: multipart/form-data&lt;/code&gt; ，而 &lt;code&gt;-D&lt;/code&gt; 则是 &lt;code&gt;Content-Type : application/x-www-form-urlencoded&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;比如上传一个 protrait.jpg 图片。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl -F profile=@portrait.jpg https://example.com/upload
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提交一个具有 name 和 age 参数的 form 表单。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl -F name=Darcy -F age=18 https://example.com/upload
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数对应的内容也可以从文件中读取。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl -F &quot;content=&amp;lt;达西的身世.txt&quot; https://example.com/upload
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上传时同时指定内容类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl -F &quot;content=&amp;lt;达西的身世.txt;type=text/html&quot; https://example.com/upload
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上传文件的和其他参数一起。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;curl -F 'file=@&quot;localfile&quot;;filename=&quot;nameinpost&quot;' example.com/upload
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;7-网址通配&quot;&gt;7. 网址通配&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;cURL&lt;/strong&gt; 可以实现多个网址的匹配，你可以使用 &lt;code&gt;{}&lt;/code&gt; 结合逗号分割来标识使用 url 中的某一段，也可以使用 &lt;code&gt;[]&lt;/code&gt; 来表示范围参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 请求 www.baidu.com 和  pan.baidu.com 和 fanyi.baidu.com
$ curl http://{www,pan,fanyi}.baidu.com
# 虚构网址1-10开头的baidu.com，然后请求
$ curl http://[1-10].baidu.com
# 虚构网址a-z开头的baidu.com，然后请求
$ curl http://[a-z].baidu.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式有时候还是很有用处的，比如说你发现了某个网站的 url 规律。&lt;/p&gt;
&lt;h3 id=&quot;8-使用-cookie&quot;&gt;8. 使用 cookie&lt;/h3&gt;
&lt;p&gt;请求时使用 &lt;code&gt;-c&lt;/code&gt; 参数存储响应的 cookie，使用 &lt;code&gt;-b&lt;/code&gt; 可以在请求时带上指定 cookie.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ curl -c wdbyte_cookies http://www.wdbyte.com
$ curl -b wdbyte_cookes http://www.wdbyte.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;以上就是 &lt;strong&gt;cURL&lt;/strong&gt; 的常见用法了，最后告诉你一个小技巧，Chrome、Firefox 等浏览器可以直接拷贝请求为 cURL 语句。保存之后下次请求测试非常方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets/2020/image-20200531151839505.png&quot; alt=&quot;Chrome 复制 cURL 请求&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://curl.haxx.se/docs/manpage.html&quot;&gt;https://curl.haxx.se/docs/manpage.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;最后的话&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.2348178137652&quot;&gt;
&lt;p&gt;文章已经收录在 &lt;a href=&quot;https://github.com/niumoo/JavaNotes&quot;&gt;Github.com/niumoo/JavaNotes&lt;/a&gt; ，欢迎Star和指教。更有一线大厂面试点，Java程序员需要掌握的核心知识等文章，也整理了很多我的文字，欢迎 &lt;strong&gt;Star&lt;/strong&gt; 和完善，希望我们一起变得优秀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章有帮助可以点个「&lt;strong&gt;赞&lt;/strong&gt;」或「&lt;strong&gt;分享&lt;/strong&gt;」，都是支持，我都喜欢！&lt;br/&gt;文章每周持续更新，要实时关注我更新的文章以及分享的干货，可以关注「 &lt;strong&gt;未读代码&lt;/strong&gt; 」公众号或者&lt;a href=&quot;https://www.wdbyte.com/&quot;&gt;我的博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets@439f6a5f6bd130e2aec56f3527656d6edb487b91/webinfo/weixin-public.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Jun 2020 00:59:00 +0000</pubDate>
<dc:creator>未读代码</dc:creator>
<og:description>文章已经收录在 Github.com/niumoo/JavaNotes ，更有 Java 程序员所需要掌握的核心知识，欢迎Star和指教。 欢迎关注我的公众号，文章每周更新。 cURL 是一个开源免费</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niumoo/p/13041473.html</dc:identifier>
</item>
<item>
<title>白天写代码，晚上摆地摊！9年前摆地摊学会了这些道理... - Java中文社群</title>
<link>http://www.cnblogs.com/vipstone/p/13041450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipstone/p/13041450.html</guid>
<description>&lt;p&gt;两会期间李克强总理说了一番话，温暖了无数个像我一样的底层人民，他说：一味追求整洁，不让开小店，是懒政，政府必须要提高规划、管理的能力，决不能光图省事，一禁了之，保留地摊经济，给底层人们一点温暖！&lt;/p&gt;
&lt;p&gt;之后随着李克强总理在山东烟台走访并点赞“地摊经济”，让“地摊经济”这一词迅速升温，成为广大人民群众热议的话题。&lt;/p&gt;
&lt;h2 id=&quot;地摊故事&quot;&gt;地摊故事&lt;/h2&gt;
&lt;p&gt;而这一事件让我联想起了九年前，那个曾经摆地摊的日子。&lt;/p&gt;
&lt;p&gt;故事发生在 2011 年的春天，那一年对于西安人民来说是重要的一年，因为那一年世园会（世界园艺博览会）要在西安举行，这是续奥运会之后发生在中国大地上的另一件大事，因此搞得我们所有人都很激动，尤其是对于西安人民来说，更是一件光荣而又值得炫耀的事，注意这里的“炫耀”不是贬义词。&lt;/p&gt;
&lt;p&gt;近水楼台先得月，这一年是我做开发的第 2 年（我是 2009 年底开始参加工作的，因此可以说是参加工作的第 2 年），因为闲来无事，那时候还没有 996，而在西安这种近一线城市来说，工作还算安逸，基本不怎么加班，于是就想要不要倒腾点世园会的吉祥物卖卖，就是类似于下图的布娃娃：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/172074/202006/172074-20200604084934030-1586094784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何进货？&quot;&gt;如何进货？&lt;/h2&gt;
&lt;p&gt;因为是搞 IT 的因此比较熟悉网络，所以我刚开始的进货渠道就是通过 58 同城，第一批大概进了 30 个，自己买了一个很大的袋子装着在小寨天桥上卖，至于为什么去小寨？原因有两个，第一人流量比较大，第二高校比较多，长安大学、美术学院、音乐学院都在。&lt;/p&gt;
&lt;p&gt;与其说高校多，其实不如说美女多，因为美院和音乐学院各个都是标准的美女。哈哈，一不小心就暴露了，食色性也，人之常情，咱不能反人性活着是不是？方正不管怎么说，这地儿，我是待定了！&lt;/p&gt;
&lt;h2 id=&quot;盈利几何？&quot;&gt;盈利几何？&lt;/h2&gt;
&lt;p&gt;我记得第一次进货一个世园会娃娃大概是 7 块钱的样子，出去卖要价 20，大部分娃娃都是 15、18 卖的，当然有砍价比较狠的大姐，13 元、15 元也卖，所以那时候一天晚上只要能卖出去 10 个，我也能收入个 80-100 元。而这个收入对于当时工资只有 2000 元的我来说，也算一笔“巨资”了。&lt;/p&gt;
&lt;h2 id=&quot;如何克服紧张？&quot;&gt;如何克服紧张？&lt;/h2&gt;
&lt;p&gt;说实话任何人第一次做任何事，结果一定很糟糕，尤其是对于我这样一个从农村走出来的孩子来说更是如此，我高中毕业之前去的最远的地方就是我们的小县城，就连高中也是在我们的小镇上上的，因此“摆地摊”这件事对我来说更是困难至极。&lt;/p&gt;
&lt;p&gt;但山人自有妙计，我可以结伴同行呀，于是我拉了当时和我关系最好的同事志康一起去，他的年纪比我大五岁，很正直很老实的一个人，只是稍微有点懒，并且他每次都会极力否认。这就好比卖瓜的人怎么能说自己的瓜不甜呢？所以我们也就呵呵了之了。&lt;/p&gt;
&lt;p&gt;然而不得不说的是，这招非常有用。我当时的信心大概是建立在，他那种比我还笨拙 N 倍的销售和沟通能力的基础上的，而能力这个事情你是知道的，一定习得就大概率不会忘记，就好像我们学会的驾驶技术，无论是骑自行车还是开汽车，学会了就不会忘记了。建立信心这事也是一样，自从志康间接的给我建立之后，我基本就可以一个人独自战斗了，后面一段时间，我“叫不动”他时，我都是孤身一人去卖，而且卖的还很好，只是有时收入不那么稳定而已。&lt;/p&gt;
&lt;p&gt;我记得卖的最好的一天，我大概挣了 300 多块钱，这对于我当时来说就是 3 天的工资啊，而且卖货还不影响自己上班赚钱，因此这件事让我着实的高兴了几天。&lt;/p&gt;
&lt;h2 id=&quot;业务的不断扩大&quot;&gt;业务的不断“扩大”&lt;/h2&gt;
&lt;p&gt;有了卖布娃娃挣钱的经验，于是我就想多做点品类以此来增加收入，因为当时买布娃娃的人也越来越多了，竞争多了之后生意自然也就没有以前好了。于是我就绞尽脑汁想了想应该卖点什么好。&lt;/p&gt;
&lt;p&gt;我当时的思考是，第一，要卖实用，最好是大家经常用的东西；第二，不需要太麻烦，比如卖衣服什么的，因为要考虑尺码的问题，摆地摊又不方便试，因此它不符合我的选择标志；第三，要易宝存，不能放一段时间就过时了或者过期了，这样就会增加我的投入成本；第四，不卖男孩子用的东西，倒不是性别歧视，而是因为绝大数的男孩子都碍于“面子”，一般不会买“地摊货”。&lt;/p&gt;
&lt;p&gt;因此思量想去我决定去卖腰带，它符合我上面的四个标准，并且进价还比较低。为了迎合小寨年轻化的特征，于是我进了一批比较时尚的彩色腰带，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/172074/202006/172074-20200604084955010-292022656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而且这种塑料腰带还散发着淡淡的香味，我猜想应该会受到年轻女孩的喜爱，于是我就开心的进了很多条腰带。&lt;/p&gt;
&lt;p&gt;但事与愿违，不知道是因为自己的长相问题，还是因为这种稍微隐私一点的东西（因为大多时间腰带是不会暴露在外面的，尤其是女孩），所以效果很差，销量很低，之后的生意便一落千丈，这样成为了放弃摆地摊的主要原因。&lt;/p&gt;
&lt;h2 id=&quot;摆摊最苦恼的事&quot;&gt;摆摊最苦恼的事&lt;/h2&gt;
&lt;p&gt;在人流量大的地方摆地摊，有他的优势，也有他的劣势，他的劣势就是城管看的特别严，每天晚上我都要被城管追十几次，非常考验一个人的体力，所以那时候我特别讨厌城管，但是又苦于没有办法，真实委屈的一批。反而现在城管的素质要比以前好很多了，这要归功于互联网和摄像技术的快速普及，以及广大网民不辞辛苦的“教育”，是你们推动了城管的素质稳步提高。&lt;/p&gt;
&lt;h2 id=&quot;摆摊给我的收获&quot;&gt;摆摊给我的收获&lt;/h2&gt;
&lt;p&gt;摆地摊“挣钱”并不是我做这件事的第一动机，我做这件事的第一动力是体验生活和挑战自我，如果用这两点来衡量的话，收获也算是差强人意，从刚开始不敢抬头看人到最后的大声吆喝，这都是看得见的进步，而摆地摊让我明白了很多事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一，生活不易，被城管追着更不易，有一份写代码的差事就应该好好珍惜；&lt;/li&gt;
&lt;li&gt;第二，熟悉了生意的整个流程，从进货到销售，我在文章中说了，刚开始进货是在 58，后面就慢慢拓展到了线下，包括西安康复路和轻工市场已经被我跑了个遍；&lt;/li&gt;
&lt;li&gt;第三，只有稀缺才能卖得好，才能保证销量和利润；&lt;/li&gt;
&lt;li&gt;第四，你以为的不一定是对的，要想验证自己的想法就要先做起来；&lt;/li&gt;
&lt;li&gt;第五，任何你不熟悉的事情，随着重复做的次数增加，一定会越做越好；&lt;/li&gt;
&lt;li&gt;第六，和人打交道太难了，还是写代码比较简单。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;于是，我变开始了幸福的 coding 人生，一直到现在，转眼 9 年已逝。&lt;/p&gt;
&lt;h2 id=&quot;未完待续&quot;&gt;未完待续&lt;/h2&gt;
&lt;p&gt;生活总要尝试不同的风景，人生总要尝试不同的体验。就好比旅游，不就是从一个自己待烦的地方去另一个别人待烦的地方吗？&lt;/p&gt;
&lt;p&gt;特别喜欢林清玄的一句话：&lt;strong&gt;人生需要准备的，不是昂贵的茶，而是喝茶的心情&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;愿我们都能心中梦想付出行动，即使失败，也要勇敢尝试。&lt;/p&gt;
&lt;h3 id=&quot;最后的话&quot;&gt;最后的话&lt;/h3&gt;
&lt;p&gt;原创不易，明人不说暗话，我需要一个你的「&lt;strong&gt;赞&lt;/strong&gt;」，为自己加油。&lt;/p&gt;
</description>
<pubDate>Thu, 04 Jun 2020 00:50:00 +0000</pubDate>
<dc:creator>Java中文社群</dc:creator>
<og:description>两会期间李克强总理说了一番话，温暖了无数个像我一样的底层人民，他说：一味追求整洁，不让开小店，是懒政，政府必须要提高规划、管理的能力，决不能光图省事，一禁了之，保留地摊经济，给底层人们一点温暖！ 之后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vipstone/p/13041450.html</dc:identifier>
</item>
<item>
<title>我终于搞清了啥是 HTTPS 了 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/13041439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/13041439.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/technique-sharing/20200530/http-vs-https.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;最近上海连续下了一周雨，温度一夜之间回到解放前，穿夏装的我被冻得瑟瑟发抖，躲在家里哪也不想去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/technique-sharing/20200530/sesefadou.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在家百无聊赖的刷着网页，看到公众号后台的留言，有同学问我 HTTP 和 HTTPS 有啥区别？&lt;/p&gt;
&lt;p&gt;这还用问，当然是 HTTPS 要比 HTTP 更加的安全啊，没看到后面带着个 S 呢么，带着 S 就这么 NB 。&lt;/p&gt;
&lt;p&gt;然后同学的下一个问题把我问懵逼了，为啥带 S 的更安全呢？能详细的讲讲么。&lt;/p&gt;
&lt;p&gt;我跟你讲嗷，不是我吹，我这么多年。。。。。。&lt;/p&gt;
&lt;p&gt;就没见过你这么刨根究底的同学，老问这种我也不是很清楚的问题。&lt;/p&gt;
&lt;p&gt;虽然这个问题问的我老脸一红，但是我有一种不要脸的精神 「我不会，但是我可以学」 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/technique-sharing/20200530/liaobuqi.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;http&quot;&gt;HTTP&lt;/h2&gt;
&lt;p&gt;首先先来了解下 HTTP ：&lt;/p&gt;
&lt;p&gt;HTTP 协议全称为：Hyper Text Transfer Protocol ，翻译过来就是超文本传输协议，请不要质疑这个翻译，我专门用百度翻译翻了一下。&lt;/p&gt;
&lt;p&gt;TCP/IP 四层模型应该都知道的，有数据链路层，网络层，传输层和应用层：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/technique-sharing/20200530/tcpip.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而 HTTP 协议就是位于 TCP/IP 四层模型的应用层上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/technique-sharing/20200530/tcpip_1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里很多人都会混淆 TCP 和 HTTP ，实际上 HTTP 是基于 TCP 连接基础上的。&lt;/p&gt;
&lt;p&gt;简单的说， TCP 就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。而 HTTP 是用来收发数据，即实际应用上来的。&lt;/p&gt;
&lt;p&gt;HTTP 协议通过请求和响应在客户端和服务端之间收发数据，进行通信：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/technique-sharing/20200530/request-response.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;https&quot;&gt;HTTPS&lt;/h2&gt;
&lt;p&gt;HTTP 协议看起来好像没啥问题，唯一的问题就是不够安全，因为 HTTP 协议的传输方式完全是由明文传输的，不做任何加密，这就让一些不怀好意的人有了可乘之机。&lt;/p&gt;
&lt;p&gt;这种传输方式诱发了一种经典的攻击方式：中间人攻击。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/technique-sharing/20200530/zhongjianrengongji_1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这种情况，最简单的我们可以使用加密方案，比如使用 AES 加密，服务端和客户端先约定一个随机生成的密钥 key ，后续的通信中，所有的信息都使用这个密钥进行 AES 加密：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/technique-sharing/20200530/zhongjianrengongji_2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样虽然后面的通信过程安全了，但是我们在第一发送 AES 密钥的时候还是存在被中间人拦截的风险，一旦中间人拦截到我们的密钥，可用对密钥进行更换或者直接解密请求内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/technique-sharing/20200530/zhongjianrengongji_3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时我们可以使用不对称加密，来专门对密钥的传输做一次额外的保护。&lt;/p&gt;
&lt;p&gt;不对称加密会有两个密钥，一个是公钥，一个是私钥。明文可以使用公钥加密私钥解密，也可以使用私钥加密公钥解密。&lt;/p&gt;
&lt;p&gt;现在比较通用的非对称加密算法有 RSA 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/technique-sharing/20200530/zhongjianrengongji_4.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里的同学一定在奇怪，既然都使用了不对称加密，为啥只对 AES 的密钥做不对称加密，好像有多此一举，完全可以对后续所有的通信信息全都使用不对称加密。&lt;/p&gt;
&lt;p&gt;因为不对称加密相比较对称加密性能上存在明显的劣势，可能你觉得在一个请求中多消耗几 ms 或者几 ns 无所谓，但是请求到达服务端是要进行解密，每个请求都多消耗几 ms 累计起来还是非常可观的。&lt;/p&gt;
&lt;p&gt;上面这个方案看起来已经很安全了，中间人即使拦截到我们的公钥，由于不知道我们的私钥貌似也没办法解密。&lt;/p&gt;
&lt;p&gt;实际上中间人完全不需要解密我们的信息，他可以生成一对新的公私钥发送给客户端进行攻击，后续客户端的通信中间人使用自己创造的私钥进行解密，然后通过服务端生成的公钥进行加密返回给服务端：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/technique-sharing/20200530/zhongjianrengongji_5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ca-证书&quot;&gt;CA 证书&lt;/h2&gt;
&lt;p&gt;上面的问题我们仅通过客户端和服务端已经没办法了，这时候需要引入新的第三方机构，一个颁发 CA 证书的机构。&lt;/p&gt;
&lt;p&gt;常见的第三方 CA 机构有：Symantec（赛门铁克），Comodo（科莫多），GeoTrust（环度网信），GoDaddy，Thawte，daoRapidSSL 等等。&lt;/p&gt;
&lt;p&gt;在中间人攻击中，我们遇到的问题不是加密算法不够神奇，不是密钥方式不够严谨，而是我们没有办法向我们的客户端表明我们给他的公钥是我们的，是不是很像我没办法证明我是我的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/technique-sharing/20200530/qingzhengming.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以第三方机构应运而生，第三方机构只做一件事情，将服务端的公钥刻上了我们的名字（CA 证书），客户端接收到公钥之后，只需要来第三方机构这里查询，就能知道这个公钥是不是真的服务器，然后再将自己生成的 AES 密钥使用 CA 证书中解密得到的公钥进行加密后发送给服务端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/technique-sharing/20200530/zhongjianrengongji_6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后服务端使用私钥解密得到 AES 密钥，就可以愉快的和客户端进行通信了。&lt;/p&gt;
&lt;p&gt;最后的最后，CA 机构验证不是每次都要去 CA 机构查询。这样做太傻了而且太耗时，尤其是很多 CA 机构的服务都在海外，这样一来一去消耗的时间太多了。&lt;/p&gt;
&lt;p&gt;CA 机构高明的地方就在于，我们去找它注册公钥，它会使用另一个来注册的公司的私钥对我们的公钥加密，得到一个我们的公钥的指纹（全球唯一），然后将这家公司的公钥信息（其实也是证书）和我们的公钥以及我们公钥的指纹打包成一个证书。&lt;/p&gt;
&lt;p&gt;当我们使用 HTTPS 将证书下发给客户端校验时，客户端（比如浏览器）从证书中看到了上级证书的信息，恰巧这个证书就在浏览器（或者本机）中，已经被验证过是合法的，浏览器只要使用这个证书中的公钥将我们的公钥指纹进行解密，然后比对我们的公钥信息就知道我们也是的合法的。因为假证书中的公钥签名不可能被合法的上级证书中公钥解密 。&lt;/p&gt;
&lt;p&gt;这段稍微有点绕，慢慢看多看几次就理解了。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/691b8ba3a70f&quot;&gt;https://www.jianshu.com/p/691b8ba3a70f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010144805/article/details/80803059&quot;&gt;https://blog.csdn.net/u010144805/article/details/80803059&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/caofengtao1314/article/details/87912078&quot;&gt;https://blog.csdn.net/caofengtao1314/article/details/87912078&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Jun 2020 00:45:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>引言 最近上海连续下了一周雨，温度一夜之间回到解放前，穿夏装的我被冻得瑟瑟发抖，躲在家里哪也不想去。 在家百无聊赖的刷着网页，看到公众号后台的留言，有同学问我 HTTP 和 HTTPS 有啥区别？ 这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/13041439.html</dc:identifier>
</item>
<item>
<title>C#中的TemplateMethod模式 - 伤之哀霜</title>
<link>http://www.cnblogs.com/deatharthas/p/13041420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deatharthas/p/13041420.html</guid>
<description>&lt;h2 id=&quot;一个真实的故事&quot;&gt;一个真实的故事&lt;/h2&gt;
&lt;p&gt;大学的时候就开过一门课程，讲设计模式，可是大学生没什么编程实践经验，在大学里面听设计模式的感觉，就像听天书。听着都有道理，可是完全领会不到其中的奥妙，大抵原因就在于没有走过弯路，没有吃过设计不当的亏。古人云，“操千曲而后晓声，观千剑而后识器”，诚不欺我。&lt;br/&gt; &lt;br/&gt;博主在之前的某个项目中，设计出了一些工具类，像属性窗口，错误提示窗口，还有一个窗口管理类管理它们，当时我实现工具保存时候的代码是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    class WindowManager
    {
        private List&amp;lt;ITool&amp;gt; _Tools = new List&amp;lt;ITool&amp;gt;();        

        public void AddTool(ITool tool)
        {
            _Tools.Add(tool);
        }

        public void SaveAllTools()
        {
            foreach(var tool in _Tools)
            {
                tool.Save();
            }
        }
    }

    interface ITool
    {
        bool BeforeSave();
        void Save();
        void AfterSave();
    }

    class PropertyWindow : ITool
    {
        public bool BeforeSave()
        {
            //do something specific here
            return true;
        }

        public void Save()
        {
            if (BeforeSave())
            {
                //do save
                AfterSave();
            }
        }

        public void AfterSave()
        {

        }
    }

    class ErrorLis : ITool
    {
        public bool BeforeSave()
        {
            //do something specific here
            return true;
        }

        public void Save()
        {
            if (BeforeSave())
            {
                //do save
                AfterSave();
            }
        }

        public void AfterSave()
        {

        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当时博主对这段代码还挺满意，完全没有看出这儿有什么问题，觉得这简直写的太OO了，有类，有接口，有针对接口编程，至于新加的工具类，也不会影响原来的代码，简直太符合开闭原则了。老铁，没毛病！&lt;br/&gt; &lt;br/&gt;好日子就这么继续下去，每当需要新添加一个工具，我就新加一个类，在类里面实现Save的逻辑，直到有一天，添加了一个ResourceControl&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    class ResourceControl : ITool
    {
        public bool BeforeSave()
        {
            //do something specific here
            return true;
        }

        public void Save()
        {
            if (!BeforeSave())
            {
                //do save
                AfterSave();
            }
        }

        public void AfterSave()
        {

        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;br/&gt;在它的save里面，我把if(BeforeSave())写成了if(!BeforeSave())。。。&lt;br/&gt;于是，我又额外花了一些时间来找到这个问题，修改它并在下次添加新类的时候战战兢兢提醒自己不要犯这种低级的错误。那么，我们有没有好的办法来解决这个问题呢？&lt;/p&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;问题分析&lt;/h2&gt;
&lt;p&gt;其实就算每次添加新类的时候我们都能仔细的小心避免维护相同的逻辑，这段代码的设计也还是有可以改进的地方，比如，BeforeSave和AfterSave在这里作为接口ITool的一部分而公开，意味着客户代码可以自由的调用BeforeSave和AfterSave，然而这很可能并不是代码作者的本意，毕竟，不调用Save而单独调用BeforeSave和AfterSave有什么意义呢？让客户能够看到更多不必要的方法，增加了客户错误使用接口的可能性，不是么？&lt;br/&gt; &lt;br/&gt;综上所述，我们需要解决的问题如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象出Save, BeforeSave和AfterSave的逻辑关系，在一个地方固定下来，确保新增加的类所实现的这三个方法，都能自动具有这种逻辑关系。&lt;/li&gt;
&lt;li&gt;对客户代码隐藏不必要的接口。&lt;br/&gt; &lt;br/&gt;这种场景下面，我们需要用到设计模式中的TemplateMethod（模版方法）模式。&lt;br/&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;templatemethod模式&quot;&gt;TemplateMethod模式&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://en.wikipedia.org/wiki/Template_method_pattern&quot;&gt;WIKI&lt;/a&gt;上面，TemplateMethod模式的定义如下，&lt;br/&gt;&lt;strong&gt;In software engineering, the template method pattern is a behavioral design pattern that defines the program skeleton of an algorithm in an operation, deferring some steps to subclasses. It lets one redefine certain steps of an algorithm without changing the algorithm's structure.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大概意思就是，模版方法模式是一种行为类设计模式，允许软件在更高的层次定义程序骨架，但是可以在子类推迟实现某些步骤。&lt;br/&gt; &lt;br/&gt;类图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/699616/202006/699616-20200604083836133-1109648576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这完全符合我们的需求，让我们试着修改我们的代码。&lt;br/&gt; &lt;/p&gt;
&lt;h2 id=&quot;使用templatemethod重新实现的代码&quot;&gt;使用TemplateMethod重新实现的代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    class WindowManager
    {
        private List&amp;lt;AbstractTool&amp;gt; _Tools = new List&amp;lt;AbstractTool&amp;gt;();        

        public void AddTool(AbstractTool tool)
        {
            _Tools.Add(tool);
        }

        public void SaveAllTools()
        {
            foreach(var tool in _Tools)
            {
                tool.Save();
            }
        }
    }

    abstract class AbstractTool
    {
        protected abstract bool BeforeSave();
        protected abstract void DoSave();
        protected abstract void AfterSave();
        public void Save()
        {
            if(!BeforeSave())
            {
                DoSave();
                AfterSave();
            }

        }        
    }

    class PropertyWindow : AbstractTool
    {
        protected override bool BeforeSave()
        {
            //do something specific here
            return true;
        }

        protected override void DoSave()
        {
            
        }

        protected override void AfterSave()
        {

        }
    }

    class ErrorLis : AbstractTool
    {
        protected override bool BeforeSave()
        {
            //do something specific here
            return true;
        }

        protected override void DoSave()
        {

        }

        protected override void AfterSave()
        {

        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面我们可以看到，我们用一个抽象类AbstractTool代替之前的ITool接口，抽象类和接口的一个区别就是，抽象类可以在其中嵌入某些逻辑，所以我们在Save这个公共的非虚方法中，完全实现了我们的BeforeSave和AfterSave逻辑，仅仅留下了BeforeSave,AfterSave和DoSave给子类覆盖。这样我们得到的好处是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象类只公开了一个Save方法，所以客户代码不用担心会调用其他错误的方法。&lt;/li&gt;
&lt;li&gt;抽象类完全固定了Save逻辑，先调用BeforeSave检查，之后执行DoSave进行具体的Save事项，最后进行AfterSave行为。子类只需要重新依据子类的需求覆盖这三个虚方法即可。新添加的工具类，只要覆盖这三个虚方法，至于虚方法之间的逻辑，抽象类已经固定，不用担心。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;“纸上得来终觉浅，绝知此事要躬行”，祖宗的话，不会错的，如果没有一定的编程实践和总结，是没有办法领悟设计模式的，博主也是通过之前那个例子才领悟到TemplateMethod模式的妙用。希望大家多多编程，早日领悟。&lt;/p&gt;
</description>
<pubDate>Thu, 04 Jun 2020 00:40:00 +0000</pubDate>
<dc:creator>伤之哀霜</dc:creator>
<og:description>一个真实的故事 大学的时候就开过一门课程，讲设计模式，可是大学生没什么编程实践经验，在大学里面听设计模式的感觉，就像听天书。听着都有道理，可是完全领会不到其中的奥妙，大抵原因就在于没有走过弯路，没有吃</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/deatharthas/p/13041420.html</dc:identifier>
</item>
<item>
<title>字符串太占内存了，我想了各种奇思淫巧对它进行压缩 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/13041367.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/13041367.html</guid>
<description>&lt;h2 id=&quot;一：背景&quot;&gt;一：背景&lt;/h2&gt;
&lt;h3 id=&quot;1-讲故事&quot;&gt;1. 讲故事&lt;/h3&gt;
&lt;p&gt;在我们的一个全内存项目中，需要将一家大品牌店铺小千万的trade灌入到内存中，大家知道trade中一般会有&lt;code&gt;订单来源&lt;/code&gt;,&lt;code&gt;省市区&lt;/code&gt; ，当把这些字段灌进去后，你会发现他们特别侵蚀内存，因为都是字符串类型，不知道大家对内存侵蚀性是不是很清楚，我就问一个问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Answer: 一个空字符串占用多大内存？ 你知道吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思考之后，下面我们就一起验证下，使用windbg去托管堆一查究竟，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        static void Main(string[] args)
        {
            string s = string.Empty;

            Console.ReadLine();
        }

0:000&amp;gt; !clrstack -l
OS Thread Id: 0x308c (0)
        Child SP               IP Call Site
ConsoleApp6.Program.Main(System.String[]) [C:\dream\Csharp\ConsoleApp1\ConsoleApp6\Program.cs @ 19]
    LOCALS:
        0x00000087391febd8 = 0x000002605da91420
0:000&amp;gt; !DumpObj /d 000002605da91420
Name:        System.String
String:      
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ff9eb2b85a0  4000281        8         System.Int32  1 instance                0 m_stringLength
00007ff9eb2b6838  4000282        c          System.Char  1 instance                0 m_firstChar
00007ff9eb2b59c0  4000286       d8        System.String  0   shared           static Empty
                                 &amp;gt;&amp;gt; Domain:Value  000002605beb2230:NotInit  &amp;lt;&amp;lt;
0:000&amp;gt; !objsize 000002605da91420
sizeof(000002605da91420) = 32 (0x20) bytes (System.String)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200604083117617-641123850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中你可以看到，仅仅一个空字符串就要占用 32byte，如果500w个空字符串就是： &lt;code&gt;32byte x 500w = 152M&lt;/code&gt;，是不是不算不知道，一算吓一跳。。。 这还仅仅是一个什么都没有的空字符串哦。&lt;/p&gt;
&lt;h3 id=&quot;2-回归到trade&quot;&gt;2. 回归到Trade&lt;/h3&gt;
&lt;p&gt;问题也已经摆出来了，接下来回归到Trade中，为了方便演示，先模拟以文件的形式从数据库读取20w的trade。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;    class Program
    {
        static void Main(string[] args)
        {
            var trades = Enumerable.Range(0, 20 * 10000).Select(m =&amp;gt; new Trade()
            {
                TradeID = m,
                TradeFrom = File.ReadLines(Environment.CurrentDirectory + &quot;//orderfrom.txt&quot;)
                                 .ElementAt(m % 4)
            }).ToList();

            GC.Collect();  //方便测试，把临时变量清掉
            Console.WriteLine(&quot;执行成功&quot;);
            Console.ReadLine();
        }
    }

    class Trade
    {
        public int TradeID { get; set; }
        public string TradeFrom { get; set; }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200604083117813-2090465052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后用windbg去跑一下托管堆，再量一下trades的大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !dumpheap -stat
Statistics:
              MT    Count    TotalSize Class Name
00007ff9eb2b59c0   200200      7010246 System.String

0:000&amp;gt; !objsize 0x000001a5860629a8
sizeof(000001a5860629a8) = 16097216 (0xf59fc0) bytes (System.Collections.Generic.List`1[[ConsoleApp6.Trade, ConsoleApp6]])

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面输出中可以看到托管堆有&lt;code&gt;200200 = 20w(程序分配)+ 200(系统分配)&lt;/code&gt;个，然后再看size： &lt;code&gt;16097216/1024/1024= 15.35M&lt;/code&gt;，这就是展示的所有原始情况。&lt;/p&gt;
&lt;h2 id=&quot;二：压缩技巧分析&quot;&gt;二：压缩技巧分析&lt;/h2&gt;
&lt;h3 id=&quot;1-使用字典化处理&quot;&gt;1. 使用字典化处理&lt;/h3&gt;
&lt;p&gt;其实在托管堆上有20w个字符串，但你仔细观察一下会发现其实就是4种状态的重复显示，要么一淘，要么淘宝。。。这就给了我优化机会，何不在获取数据的时候构建好&lt;code&gt;OrderFrom&lt;/code&gt;的字典，然后在trade中附增一个TradeFromID记录字典中的映射值，因为特征值少，用byte就可以了，有了这个思想，可以把代码修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
    class Program
    {
        public static Dictionary&amp;lt;int, string&amp;gt; orderfromDict = new Dictionary&amp;lt;int, string&amp;gt;();

        static void Main(string[] args)
        {
            var trades = Enumerable.Range(0, 20 * 10000).Select(m =&amp;gt;
            {
                var tradefrom = File.ReadLines(Environment.CurrentDirectory + &quot;//orderfrom.txt&quot;)
                                 .ElementAt(m % 4);

                var kv = orderfromDict.FirstOrDefault(k =&amp;gt; k.Value == tradefrom);

                if (kv.Key == 0)
                {
                    orderfromDict.Add(orderfromDict.Count + 1, tradefrom);
                }

                var trade = new Trade() { TradeID = m, TradeFromID = (byte)kv.Key };

                return trade;

            }).ToList();

            GC.Collect();  //方便测试，把临时变量清掉

            Console.WriteLine(&quot;执行成功&quot;);

            Console.ReadLine();
        }
    }

    class Trade
    {
        public int TradeID { get; set; }

        public byte TradeFromID { get; set; }

        public string TradeFrom
        {
            get
            {
                return Program.orderfromDict[TradeFromID];
            }
        }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码还是很简单的，接下来用windbg看一下空间到底压缩了多少?&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;0:000&amp;gt; !dumpheap -stat
Statistics:
              MT    Count    TotalSize Class Name
00007ff9eb2b59c0      204        10386 System.String

0:000&amp;gt; !clrstack -l
OS Thread Id: 0x2ce4 (0)
        Child SP               IP Call Site
ConsoleApp6.Program.Main(System.String[]) [C:\dream\Csharp\ConsoleApp1\ConsoleApp6\Program.cs @ 42]
    LOCALS:
        0x0000006f4d9ff078 = 0x0000016fdcf82ab8

0000006f4d9ff288 00007ff9ecd96c93 [GCFrame: 0000006f4d9ff288] 
0:000&amp;gt; !objsize 0x0000016fdcf82ab8
sizeof(0000016fdcf82ab8) = 6897216 (0x693e40) bytes (System.Collections.Generic.List`1[[ConsoleApp6.Trade, ConsoleApp6]])

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的输出中可以看到，托管堆上string现在是：&lt;code&gt;204 = 4（程序分配） + 200（系统分配）&lt;/code&gt;个，这4个就是字典中的4个哦，空间的话：&lt;code&gt;6897216 /1024/1024= 6.57M&lt;/code&gt;，对应之前的 &lt;code&gt;15.35M&lt;/code&gt;优化了将近60%。&lt;/p&gt;
&lt;p&gt;虽然优化了60%，但这种优化是破坏性的优化，需要修改我的Trade结构，同时还要定义个Dictionary，而且还有不小幅度的修改业务逻辑，&lt;span&gt;大家都知道线上的代码是能不改则不改，不改肯定没错，改出问题肯定是你兜着走&lt;/span&gt;，是吧，那问题就来了，如何最小化的修改而且还能压缩空间，有这样两全其美的事情吗？？？&lt;/p&gt;
&lt;h3 id=&quot;2-利用字符串驻留池&quot;&gt;2. 利用字符串驻留池&lt;/h3&gt;
&lt;p&gt;貌似一说出来，大家都如梦初醒，驻留池的出现就是为了解决这个问题，CLR会在内部维护了一个我刚才定义的字典机制，重复的字符串就不需要在堆上再次分配，直接存它的引用地址即可，如果你不清楚驻留池，建议看一下我这篇： &lt;a href=&quot;https://www.cnblogs.com/huangxincheng/p/12799736.html&quot;&gt;https://www.cnblogs.com/huangxincheng/p/12799736.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来只需要在tradefrom 字段包一层 &lt;code&gt;string.Intern&lt;/code&gt; 即可，改动不要太小，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        static void Main(string[] args)
        {
            var trades = Enumerable.Range(0, 20 * 10000).Select(m =&amp;gt; new Trade()
            {
                TradeID = m,
                TradeFrom = string.Intern(File.ReadLines(Environment.CurrentDirectory + &quot;//orderfrom.txt&quot;)
                                 .ElementAt(m % 4)),   //包一层 string.Intern
            }).ToList();

            GC.Collect();  //方便测试，把临时变量清掉
            Console.WriteLine(&quot;执行成功&quot;);
            Console.ReadLine();
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后用windbg抓一下托管堆。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !dumpheap -stat 
Statistics:
              MT    Count    TotalSize Class Name
00007ff9eb2b59c0      204        10386 System.String

0:000&amp;gt; !clrstack -l
OS Thread Id: 0x13f0 (0)
        Child SP               IP Call Site

ConsoleApp6.Program.Main(System.String[]) [C:\dream\Csharp\ConsoleApp1\ConsoleApp6\Program.cs @ 27]
    LOCALS:
        0x0000005e4d3ff0a8 = 0x000001f8a15129a8

0000005e4d3ff2b8 00007ff9ecd96c93 [GCFrame: 0000005e4d3ff2b8] 
0:000&amp;gt; !objsize 0x000001f8a15129a8
sizeof(000001f8a15129a8) = 8497368 (0x81a8d8) bytes (System.Collections.Generic.List`1[[ConsoleApp6.Trade, ConsoleApp6]])

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察后发现，当用了驻留池之后空间为： &lt;code&gt;8497368 /1024/1024 =8.1M&lt;/code&gt;，你可能有疑问，为什么和字典化相比内存要大24%呢？ 仔细观察你会发现，当用驻留池后，&lt;code&gt;List&amp;lt;Trade&amp;gt;&lt;/code&gt; 中的TradeFrom存的是string在堆中的内存地址，在x64机器上要占用8个字节，而字典化方式内存堆上&lt;code&gt;Trade&lt;/code&gt;是不分配&lt;code&gt;TradeFrom&lt;/code&gt;，而是用了一个byte来替代，总体来说相当于一个trade省了&lt;code&gt;7byte&lt;/code&gt;的空间，然后用windbg看一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !da -length 1 -details 000001f8b16f9b68
Name:        ConsoleApp6.Trade[]
Size:        2097176(0x200018) bytes
Array:       Rank 1, Number of elements 262144, Type CLASS

    Fields:
                      MT    Field   Offset                 Type VT     Attr            Value Name
        00007ff9eb2b85a0  4000001       10             System.Int32      1     instance                    0     &amp;lt;TradeID&amp;gt;k__BackingField
        00007ff9eb2b59c0  4000002        8            System.String      0     instance     000001f8a1516030     &amp;lt;TradeFrom&amp;gt;k__BackingField

0:000&amp;gt; !DumpObj /d 000001f8a1516030
Name:        System.String
String:      WAP

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到, &lt;code&gt;000001f8a1516030&lt;/code&gt; 就是 堆上 &lt;code&gt;string=Wap&lt;/code&gt;的引用地址，这个地址占用了8byte空间。&lt;/p&gt;
&lt;p&gt;再回头dump一下使用字典化方式的Trade,可以看到它是没有 &lt;code&gt;&amp;lt;TradeFrom&amp;gt;k__BackingField&lt;/code&gt; 字段的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !da -length 1 -details 000001ed52759ac0
Name:        ConsoleApp6.Trade[]
Size:        262168(0x40018) bytes
Array:       Rank 1, Number of elements 32768, Type CLASS
    Fields:
                      MT    Field   Offset                 Type VT     Attr            Value Name
        00007ff9eb2b85a0  4000002        8             System.Int32      1     instance                    0     &amp;lt;TradeID&amp;gt;k__BackingField
        00007ff9eb2b7d20  4000003        c              System.Byte      1     instance                    0     &amp;lt;TradeFromID&amp;gt;k__BackingField


&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三：总结&quot;&gt;三：总结&lt;/h2&gt;
&lt;p&gt;大家可以根据自己的情况使用，使用驻留池方式是改变最小的，简单粗暴，自己构建字典化虽然最省内存，但需要修正业务逻辑，这个风险自担哦。。。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;如您有更多问题与我互动，扫描下方进来吧&quot;&gt;如您有更多问题与我互动，扫描下方进来吧~&lt;/h3&gt;
&lt;hr/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202005/214741-20200522143723695-575216767.png&quot; width=&quot;600&quot; height=&quot;200&quot; alt=&quot;图片名称&quot; align=&quot;center&quot;/&gt;</description>
<pubDate>Thu, 04 Jun 2020 00:31:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>一：背景 1. 讲故事 在我们的一个全内存项目中，需要将一家大品牌店铺小千万的trade灌入到内存中，大家知道trade中一般会有订单来源,省市区 ，当把这些字段灌进去后，你会发现他们特别侵蚀内存，因</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangxincheng/p/13041367.html</dc:identifier>
</item>
<item>
<title>系统梳理一下锁 - 编程一生</title>
<link>http://www.cnblogs.com/xiexj/p/13040614.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/13040614.html</guid>
<description>&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有人对Java主流锁做了下面全面的梳理。梳理的确实挺好的。但是我看到这张图，第一个感觉是：记不住。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202006/1112728-20200603224841457-951653485.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;因为分了太多类，彼此之间没有什么联系。做PPT可以。如果聊天或者面试，不用纸笔的情况下，就不太好描述了。也不利于对原理和应用的理解。&lt;/p&gt;
&lt;p&gt;基于上述的考虑，我就自己系统的梳理一下锁，希望可以有助于大家理解和记忆，以至于最后在工作中得到很好的应用。&lt;/p&gt;
&lt;p&gt;先说线程锁再说分布式锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;线程锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;这里说的线程锁是Java线程锁，从原理上各个语言应该都比较相似。有很多维度的划分方式，我比较建议的是从大面上分为乐观锁和悲观锁。&lt;/p&gt;
&lt;p&gt;乐观锁主要是自旋+CAS的方式，比如JCU(java.util.concurrent包)的原子类。 &lt;/p&gt;
&lt;p&gt;悲观锁主要用synchronized关键字的隐式锁和基于AQS的显示锁。&lt;/p&gt;
&lt;p&gt;上面三段总结如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibTlshiaPq7iclBHs52Vfp924CtEic9Dkibia1S0lKKTyldJvZNKiaP0zCI2r3iard7lPsAv7PcI1stdneUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202006/1112728-20200603224941757-1803802586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;悲观锁的实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1&amp;gt;synchronized关键字&lt;/p&gt;
&lt;p&gt;随着java版本升级，synchronized关键字虽然是用C++写的，但是原理和JCU包的ReentrantLock很相似。synchronized关键字有4种锁状态：无锁、偏向锁、轻量级锁、重量级锁。无锁类似于ReentrantLock的交替执行，没有并发，就不涉及锁；偏向锁类似于ReentrantLock的可重入的概念，使得已经获取到锁的线程可以多次获取锁；轻量级锁解决的问题是尽量避免线程切换，使用的方法也和ReentrantLock相似，是自旋+CAS的方式；重量级锁依赖于管程monitor来实现，和ReentrantLock一样都涉及用户态和内核态切换。&lt;/p&gt;
&lt;p&gt;根据这个我们再来补充一下Java线程锁的思维导图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202006/1112728-20200603225037756-1683488808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2&amp;gt;基于基于AQS的显示锁&lt;/p&gt;
&lt;p&gt;基于AQS的显示锁我之前看过一些源码。这里面比较经典的是ReentrantLock。这是可重入锁，就是同一个线程可以反复进入加锁的线程。如果想实现不可重入锁也很简单。把可重入锁对当前线程做特殊处理的部分去掉就好了。&lt;/p&gt;
&lt;p&gt;其他JCU下locks包里的锁比如读写锁就是将锁细化成了读锁和写锁。读锁是共享锁的实现，写锁是排他锁的实现。&lt;/p&gt;
&lt;p&gt;ReentrantLock可以使用公平锁和非公平锁两种方式，公平锁和非公平锁各自继承了AQS。区别只是非公平锁在需要加锁时先直接尝试是否可以获取锁成功，而公平锁是先看自己是否需要排队。&lt;/p&gt;
&lt;p&gt;下面以ReentrantLock的公平锁为例来简单聊一下AQS的源码。AQS核心是实现了CLH队列。&lt;/p&gt;
&lt;p&gt;AQS有head、tail、持有锁的线程、状态4个主要的成员变量。&lt;/p&gt;
&lt;p&gt;利用head!=tail就是说AQS是否未被初始化来判断是否交替执行，交替执行则不用加锁；如果需要加锁则判断是否就是当前拥有锁的线程，是的话，将进入次数+1；如果不是则判断是否需要初始化AQS，需要的话先初始化一个dummy header，再将自己加入队尾，如果是队列里dummy header的指针指向的节点，则它为先自旋判断是否可以获取锁；如果不是dummy header指针指向的节点，则使用park让出cpu。当dummy header的指针指向的节点获取到锁之后，会将head指向自己，同时将自己这个Node节点的当前线程设置为空，将自己设置为dummy header，同时将原来dummy header的指针都设置为null，使得原dummy header成为一个没有引用的节点，便于垃圾回收。&lt;/p&gt;
&lt;p&gt;根据这个我们再来补充一下Java线程锁的思维导图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202006/1112728-20200603225152393-1263554368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分布式锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不管是线程锁还是分布式锁，都实现了tryLock、lock、unlock三个方法。&lt;/p&gt;
&lt;p&gt;tryLock的语义是非阻塞锁，尝试获取锁，成功返回true，不成功返回false；主流lock语义是阻塞锁。实现一般基于tryLock来做自旋，不成功的时候也会有像ReentrantLock一样的阻塞操作。&lt;/p&gt;
&lt;p&gt;常见的分布式锁实现以及数据库锁的实现详见之前写的文章：《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485279&amp;amp;idx=1&amp;amp;sn=49ce5a8c586979388a1828686a6cbd21&amp;amp;chksm=fafdedf1cd8a64e7d95b948cd60135db1618e71c3307d405e9b3c27c5fddedeaf1b1b5f00c4b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;MySQL常见6个考题在实际工作中的运用&lt;/a&gt;》这里就不再赘述了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本篇文章在介绍知识点是次要的，主要是展示了总结思考的思路，希望能对读者朋友们的思考问题方法上有所帮助，仅做参考。&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jun 2020 23:52:00 +0000</pubDate>
<dc:creator>编程一生</dc:creator>
<og:description>背景 有人对Java主流锁做了下面全面的梳理。梳理的确实挺好的。但是我看到这张图，第一个感觉是：记不住。 因为分了太多类，彼此之间没有什么联系。做PPT可以。如果聊天或者面试，不用纸笔的情况下，就不太</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiexj/p/13040614.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Ribbon 客户端负载均衡 - 泥瓦匠BYSocket</title>
<link>http://www.cnblogs.com/Alandre/p/13041113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Alandre/p/13041113.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/509099/202006/509099-20200604010634636-1920325569.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等，内置可插拔、可定制的负载均衡组件。下面是用到的一些负载均衡策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简单轮询负载均衡&lt;/li&gt;
&lt;li&gt;加权轮询负载均衡&lt;/li&gt;
&lt;li&gt;区域感知轮询负载均衡&lt;/li&gt;
&lt;li&gt;随机负载均衡&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;先写一个类模拟一个IP列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class IpMap
{
    // 待路由的Ip列表，Key代表Ip，Value代表该Ip的权重
    public static HashMap&amp;lt;String, Integer&amp;gt; serverWeightMap = 
            new HashMap&amp;lt;String, Integer&amp;gt;();
    
    static
    {
        serverWeightMap.put(&quot;192.168.1.100&quot;, 1);
        serverWeightMap.put(&quot;192.168.1.101&quot;, 1);
        // 权重为4
        serverWeightMap.put(&quot;192.168.1.102&quot;, 4);
        serverWeightMap.put(&quot;192.168.1.103&quot;, 1);
        serverWeightMap.put(&quot;192.168.1.104&quot;, 1);
        // 权重为3
        serverWeightMap.put(&quot;192.168.1.105&quot;, 3);
        serverWeightMap.put(&quot;192.168.1.106&quot;, 1);
        // 权重为2
        serverWeightMap.put(&quot;192.168.1.107&quot;, 2);
        serverWeightMap.put(&quot;192.168.1.108&quot;, 1);
        serverWeightMap.put(&quot;192.168.1.109&quot;, 1);
        serverWeightMap.put(&quot;192.168.1.110&quot;, 1);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;区域感知负载均衡&quot;&gt;区域感知负载均衡&lt;/h3&gt;
&lt;p&gt;在选择服务器时，该负载均衡器会采取如下步骤：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;区域感知负载均衡器内置电路跳闸逻辑，可被配置基于区域同源关系（Zone Affinity，也就是更倾向于选择发出调用的服务所在的托管区域内，这样可用降低延迟，节省成本）选择目标服务实例。它监控每个区域中运行的实例的运维行为，而且能够实时快速丢弃一整个区域。在面对整个区域的故障时，这帮我们提升了弹性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、负载均衡器会检查、计算所有可用区域的状态。如果某个区域中平均每个服务器的活跃请求已经达到配置的阈值，该区域将从活跃服务器列表中排除。如果多于一个区域已经到达阈值，平均每服务器拥有最多活跃请求的区域将被排除。&lt;br/&gt;2、最差的区域被排除后，从剩下的区域中，将按照服务器实例数的概率抽样法选择一个区域。&lt;br/&gt;3、从选定区域中，将会根据给定负载均衡策略规则返回一个服务器。&lt;/p&gt;
&lt;h3 id=&quot;简单轮询算法&quot;&gt;简单轮询算法&lt;/h3&gt;
&lt;p&gt;将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。代码实现大致如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RoundRobin
{
    private static Integer pos = 0;
    
    public static String getServer()
    {
        // 重建一个Map，避免服务器的上下线导致的并发问题
        Map&amp;lt;String, Integer&amp;gt; serverMap = 
                new HashMap&amp;lt;String, Integer&amp;gt;();
        serverMap.putAll(IpMap.serverWeightMap);
        
        // 取得Ip地址List
        Set&amp;lt;String&amp;gt; keySet = serverMap.keySet();
        ArrayList&amp;lt;String&amp;gt; keyList = new ArrayList&amp;lt;String&amp;gt;();
        keyList.addAll(keySet);
        
        String server = null;
        synchronized (pos)
        {
            if (pos &amp;gt; keySet.size())
                pos = 0;
            server = keyList.get(pos);
            pos ++;
        }
        
        return server;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;优点：试图做到请求转移的绝对均衡。&lt;/li&gt;
&lt;li&gt;缺点：为了做到请求转移的绝对均衡，必须付出相当大的代价，因为为了保证pos变量修改的互斥性，需要引入重量级的悲观锁synchronized，这将会导致该段轮询代码的并发吞吐量发生明显的下降。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;加权轮询算法&quot;&gt;加权轮询算法&lt;/h3&gt;
&lt;p&gt;不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。代码大致如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class WeightRoundRobin
{
    private static Integer pos;
    
    public static String getServer()
    {
        // 重建一个Map，避免服务器的上下线导致的并发问题
        Map&amp;lt;String, Integer&amp;gt; serverMap = 
                new HashMap&amp;lt;String, Integer&amp;gt;();
        serverMap.putAll(IpMap.serverWeightMap);
        
        // 取得Ip地址List
        Set&amp;lt;String&amp;gt; keySet = serverMap.keySet();
        Iterator&amp;lt;String&amp;gt; iterator = keySet.iterator();
        
        List&amp;lt;String&amp;gt; serverList = new ArrayList&amp;lt;String&amp;gt;();
        while (iterator.hasNext())
        {
            String server = iterator.next();
            int weight = serverMap.get(server);
            for (int i = 0; i &amp;lt; weight; i++)
                serverList.add(server);
        }
        
        String server = null;
        synchronized (pos)
        {
            if (pos &amp;gt; keySet.size())
                pos = 0;
            server = serverList.get(pos);
            pos ++;
        }
        
        return server;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;随机负载均衡&quot;&gt;随机负载均衡&lt;/h3&gt;
&lt;p&gt;通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。大致代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Random
{
    public static String getServer()
    {
        // 重建一个Map，避免服务器的上下线导致的并发问题
        Map&amp;lt;String, Integer&amp;gt; serverMap = 
                new HashMap&amp;lt;String, Integer&amp;gt;();
        serverMap.putAll(IpMap.serverWeightMap);
        
        // 取得Ip地址List
        Set&amp;lt;String&amp;gt; keySet = serverMap.keySet();
        ArrayList&amp;lt;String&amp;gt; keyList = new ArrayList&amp;lt;String&amp;gt;();
        keyList.addAll(keySet);
        
        java.util.Random random = new java.util.Random();
        int randomPos = random.nextInt(keyList.size());
        
        return keyList.get(randomPos);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;文末福利&quot;&gt;文末福利&lt;/h2&gt;
&lt;p&gt;Java 资料大全 链接:&lt;a href=&quot;https://pan.baidu.com/s/1pUCCPstPnlGDCljtBVUsXQ&quot;&gt;https://pan.baidu.com/s/1pUCCPstPnlGDCljtBVUsXQ&lt;/a&gt; 密码:b2xc&lt;br/&gt;更多资料： 2020 年 精选阿里 Java、架构、微服务精选资料等，加 v ❤ ：qwerdd111&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;转载，请保留原文地址，谢谢 ~&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 03 Jun 2020 17:07:00 +0000</pubDate>
<dc:creator>泥瓦匠BYSocket</dc:creator>
<og:description>Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等，内置可插拔、可定制的负载均衡组件。下面是用到的一些负载均衡策略： 简单轮询负载均衡 加权轮询负载均衡 区域感知轮询负载均</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Alandre/p/13041113.html</dc:identifier>
</item>
<item>
<title>容器技术之Dockerfile（二） - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13040273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13040273.html</guid>
<description>&lt;p&gt;　　前文我们聊到了什么是dockerfile,它的主要作用以及dockerfile的一些基本指令的使用方法，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13019411.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13019411.html&lt;/a&gt;；今天我们在来聊一聊dockerfile余下指令的用法和作用；&lt;/p&gt;
&lt;p&gt;　　1、RUN：该指令用于docker build 过程中运行的程序，可以是任何命令；语法格式RUN &amp;lt;command&amp;gt; 或RUN [&quot;&amp;lt;executable&amp;gt;&quot;, &quot;&amp;lt;param1&amp;gt;&quot;, &quot;&amp;lt;param2&amp;gt;&quot;]；第一种格式中，&amp;lt;command&amp;gt;通常是一个shell命令，且以“/bin/sh -c”来运行它，这意味着此进程在容器中的PID不为1，不能接收Unix信号，因此，当使用docker stop &amp;lt;container&amp;gt;命令停止容器时，此进程接收不到SIGTERM信号； 第二种语法格式中的参数是一个JSON格式的数组，其中&amp;lt;executable&amp;gt;为要运行的命令，后面的&amp;lt;paramN&amp;gt;为传递给命令的选项或参数；然而，此种格式指定的命令不会以“/bin/sh -c”来发起，因此常见的shell操作如变量替换以及通配符(?,*等)替换将不会进行；不过，如果要运行的命令依赖于此shell特性的话，可以将其替换为 RUN [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;&amp;lt;executable&amp;gt;&quot;, &quot;&amp;lt;param1&amp;gt;&quot;]这样的格式；注意：json数组中，要使用双引号；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# cat Dockerfile 
FROM centos:7 

MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;

LABEL version=&quot;1.0&quot;

LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;

ARG web_home

COPY html ${web_home:-&quot;/data/htdoc/&quot;}

VOLUME ${web_home:-&quot;/data/htdoc/&quot;}

EXPOSE 80/tcp 443/tcp

RUN mkdir -p /aaa/bbb/t{1..4}



[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上Dockerfile中，用RUN指令运行了mkdir命令，这种运行命令的方式在就可以利用shell的特性，如上大括号展开功能；&lt;/p&gt;
&lt;p&gt;　　验证：build 该dockerfile后，运行该镜像为容器，看看容器内部是否创建了/aaa/bbb/t1 t2 t3 t4?&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
busybox             latest              1c35c4412082        16 hours ago        1.22MB
centos              7                   b5b4d78bc90c        4 weeks ago         203MB
[root@node1 test]# docker build . -t myimg:v1
Sending build context to Docker daemon   1.05MB
Step 1/9 : FROM centos:7
 ---&amp;gt; b5b4d78bc90c
Step 2/9 : MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;
 ---&amp;gt; Running in 64c792ce6750
Removing intermediate container 64c792ce6750
 ---&amp;gt; 604899ef29f9
Step 3/9 : LABEL version=&quot;1.0&quot;
 ---&amp;gt; Running in 6a3f9b4a9058
Removing intermediate container 6a3f9b4a9058
 ---&amp;gt; d9edea71fa22
Step 4/9 : LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;
 ---&amp;gt; Running in b191ab5e19f9
Removing intermediate container b191ab5e19f9
 ---&amp;gt; ee027bbdc04b
Step 5/9 : ARG web_home
 ---&amp;gt; Running in a4c86febf616
Removing intermediate container a4c86febf616
 ---&amp;gt; 5b25bb7421dd
Step 6/9 : COPY html ${web_home:-&quot;/data/htdoc/&quot;}
 ---&amp;gt; 7c7a667149fa
Step 7/9 : VOLUME ${web_home:-&quot;/data/htdoc/&quot;}
 ---&amp;gt; Running in f9ec02d8f736
Removing intermediate container f9ec02d8f736
 ---&amp;gt; 86c7226f6b21
Step 8/9 : EXPOSE 80/tcp 443/tcp
 ---&amp;gt; Running in ad82d389ac25
Removing intermediate container ad82d389ac25
 ---&amp;gt; 28dadea40aff
Step 9/9 : RUN mkdir -p /aaa/bbb/t{1..4}
 ---&amp;gt; Running in 1013a212d3f2
Removing intermediate container 1013a212d3f2
 ---&amp;gt; 7f109a34a4a5
Successfully built 7f109a34a4a5
Successfully tagged myimg:v1
[root@node1 test]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
myimg               v1                  7f109a34a4a5        4 seconds ago       203MB
busybox             latest              1c35c4412082        16 hours ago        1.22MB
centos              7                   b5b4d78bc90c        4 weeks ago         203MB
[root@node1 test]# docker run --name test --rm -it myimg:v1 /bin/bash
[root@fc89ca934ed5 /]# ls /
aaa                bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
anaconda-post.log  data  etc  lib   media  opt  root  sbin  sys  usr
[root@fc89ca934ed5 /]# ls /aaa/
bbb
[root@fc89ca934ed5 /]# ls /aaa/bbb/
t1  t2  t3  t4
[root@fc89ca934ed5 /]# exit
exit
[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：底层基础镜像的shell如果不支持大括号展开，那么我们基于这种镜像做出来的镜像运行以上命令也就不支持shell的大括号展开功能；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# cat Dockerfile
FROM centos:7

MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;

LABEL version=&quot;1.0&quot;

LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;

ARG web_home

COPY html ${web_home:-&quot;/data/htdoc/&quot;}

VOLUME ${web_home:-&quot;/data/htdoc/&quot;}

EXPOSE 80/tcp 443/tcp

RUN mkdir -p /aaa/bbb/t{1..4}

RUN [&quot;mkdir&quot;,&quot;-p&quot;,&quot;/ccc/ddd/f{1..4}&quot;]

[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以json数组格式的方式去运行命令，它默认是不支持shell的任何特性，这意味着运行该命令时，不是基于shell子进程的方式在执行命令，通常是内核直接执行了；所以上面的命令它会把大括号处理成字符，而不会展开；&lt;/p&gt;
&lt;p&gt;　　验证：build成镜像运行成容器，看看是否把大括号处理成字符了？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# docker build . -t myimg:v1.1
Sending build context to Docker daemon   1.05MB
Step 1/10 : FROM centos:7
 ---&amp;gt; b5b4d78bc90c
Step 2/10 : MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; 604899ef29f9
Step 3/10 : LABEL version=&quot;1.0&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; d9edea71fa22
Step 4/10 : LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; ee027bbdc04b
Step 5/10 : ARG web_home
 ---&amp;gt; Using cache
 ---&amp;gt; 5b25bb7421dd
Step 6/10 : COPY html ${web_home:-&quot;/data/htdoc/&quot;}
 ---&amp;gt; Using cache
 ---&amp;gt; 7c7a667149fa
Step 7/10 : VOLUME ${web_home:-&quot;/data/htdoc/&quot;}
 ---&amp;gt; Using cache
 ---&amp;gt; 86c7226f6b21
Step 8/10 : EXPOSE 80/tcp 443/tcp
 ---&amp;gt; Using cache
 ---&amp;gt; 28dadea40aff
Step 9/10 : RUN mkdir -p /aaa/bbb/t{1..4}
 ---&amp;gt; Using cache
 ---&amp;gt; 7f109a34a4a5
Step 10/10 : RUN [&quot;mkdir&quot;,&quot;-p&quot;,&quot;/ccc/ddd/f{1..4}&quot;]
 ---&amp;gt; Running in 9da1e6bab59f
Removing intermediate container 9da1e6bab59f
 ---&amp;gt; ae463ec8cbd9
Successfully built ae463ec8cbd9
Successfully tagged myimg:v1.1
[root@node1 test]# docker run --name test --rm -it myimg:v1.1 /bin/bash
[root@02ec6e404100 /]# ls /
aaa                bin  data  etc   lib    media  opt   root  sbin  sys  usr
anaconda-post.log  ccc  dev   home  lib64  mnt    proc  run   srv   tmp  var
[root@02ec6e404100 /]# ls /ccc/ddd/
f{1..4}
[root@02ec6e404100 /]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到在/ccc/ddd/目录下并没有把大括号展开，而是直接把它当成了字符处理了；如果我们想要用json数组这种方式运行命令，又想让使用shell特性，我们可以使用&quot;/bin/sh -c&quot;来明确声明后面的命令用shell子进程的方式运行；如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# cat Dockerfile
FROM centos:7

MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;

LABEL version=&quot;1.0&quot;

LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;

ARG web_home

COPY html ${web_home:-&quot;/data/htdoc/&quot;}

VOLUME ${web_home:-&quot;/data/htdoc/&quot;}

EXPOSE 80/tcp 443/tcp

RUN mkdir -p /aaa/bbb/t{1..4}

RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;mkdir -p /ccc/ddd/f{1..4}&quot;]

[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上运行命令的方式就明确声明使用shell子进程的方式运行命令；这里需要注意一点的是，如果使用json数组的方式运行命令，后面真正执行的命令要一个整体当作参数传给&quot;/bin/bash&quot;&lt;/p&gt;
&lt;p&gt;　　验证：看看是否会把大括号展开？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# docker build . -t myimg:v1.2
Sending build context to Docker daemon   1.05MB
Step 1/10 : FROM centos:7
 ---&amp;gt; b5b4d78bc90c
Step 2/10 : MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; 604899ef29f9
Step 3/10 : LABEL version=&quot;1.0&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; d9edea71fa22
Step 4/10 : LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; ee027bbdc04b
Step 5/10 : ARG web_home
 ---&amp;gt; Using cache
 ---&amp;gt; 5b25bb7421dd
Step 6/10 : COPY html ${web_home:-&quot;/data/htdoc/&quot;}
 ---&amp;gt; Using cache
 ---&amp;gt; 7c7a667149fa
Step 7/10 : VOLUME ${web_home:-&quot;/data/htdoc/&quot;}
 ---&amp;gt; Using cache
 ---&amp;gt; 86c7226f6b21
Step 8/10 : EXPOSE 80/tcp 443/tcp
 ---&amp;gt; Using cache
 ---&amp;gt; 28dadea40aff
Step 9/10 : RUN mkdir -p /aaa/bbb/t{1..4}
 ---&amp;gt; Using cache
 ---&amp;gt; 7f109a34a4a5
Step 10/10 : RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;mkdir -p /ccc/ddd/f{1..4}&quot;]
 ---&amp;gt; Running in a5785a139e1f
Removing intermediate container a5785a139e1f
 ---&amp;gt; 30a5f5594104
Successfully built 30a5f5594104
Successfully tagged myimg:v1.2
[root@node1 test]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
myimg               v1.2                30a5f5594104        5 seconds ago       203MB
myimg               v1.1                ae463ec8cbd9        9 minutes ago       203MB
myimg               v1                  7f109a34a4a5        21 minutes ago      203MB
busybox             latest              1c35c4412082        16 hours ago        1.22MB
centos              7                   b5b4d78bc90c        4 weeks ago         203MB
[root@node1 test]# docker run --name test --rm -it myimg:v1.2 /bin/bash
[root@549f875aa4de /]# ls /
aaa                bin  data  etc   lib    media  opt   root  sbin  sys  usr
anaconda-post.log  ccc  dev   home  lib64  mnt    proc  run   srv   tmp  var
[root@549f875aa4de /]# ls /ccc/ddd/
f1  f2  f3  f4
[root@549f875aa4de /]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到用&quot;/bin/bash -c&quot; 是可以明确声明后面的命令用shell子进程的方式运行，这样一来就可以在后面的命令使用shell特性的语法；&lt;/p&gt;
&lt;p&gt;　　2、CMD：该指令类似于RUN指令，CMD指令也可用于运行任何命令或应用程序，不过，二者的运行时间点不同； RUN指令运行于映像文件构建过程中，而CMD指令运行于基于Dockerfile构建出的新映像文件启动一个容器时； CMD指令的首要目的在于为启动的容器指定默认要运行的程序，且其运行结束后，容器也将终止；不过，CMD指定的命令其可以被docker run的命令行选项所覆盖；在Dockerfile中可以存在多个CMD指令，但仅最后一个会生效；语法格式 CMD &amp;lt;command&amp;gt; 或 CMD [“&amp;lt;executable&amp;gt;”, “&amp;lt;param1&amp;gt;”, “&amp;lt;param2&amp;gt;”] 或 CMD [&quot;&amp;lt;param1&amp;gt;&quot;,&quot;&amp;lt;param2&amp;gt;&quot;]；前两种语法格式的意义同RUN，第三种则用于为ENTRYPOINT指令提供默认参数；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# cat Dockerfile
FROM busybox:latest

MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;

LABEL version=&quot;1.0&quot;

LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;

ARG web_home

COPY html ${web_home:-&quot;/data/htdoc/&quot;}

VOLUME ${web_home:-&quot;/data/htdoc/&quot;}

EXPOSE 80/tcp 443/tcp

CMD httpd -f -h /data/htdoc/
[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：docker容器内部运行的程序必须运行为前台；CMD是指定容器运行时要运行的命令；通常该命令或程序是以前台方式运行；如果不是前台运行，我们的容器就会存在一启动就退出的情况；以上命令就表示前台运行httpd程序 并指定httpd 的工作目录为${web_home}变量所指定的目录；&lt;/p&gt;
&lt;p&gt;　　验证：build后看看启动为容器是否提供80访问服务？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
myimg               v1.2                30a5f5594104        23 minutes ago      203MB
myimg               v1.1                ae463ec8cbd9        32 minutes ago      203MB
myimg               v1                  7f109a34a4a5        44 minutes ago      203MB
busybox             latest              1c35c4412082        16 hours ago        1.22MB
centos              7                   b5b4d78bc90c        4 weeks ago         203MB
[root@node1 test]# docker build . -t myimg:v1.3
Sending build context to Docker daemon   1.05MB
Step 1/9 : FROM busybox:latest
 ---&amp;gt; 1c35c4412082
Step 2/9 : MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;
 ---&amp;gt; Running in deb5e54eef87
Removing intermediate container deb5e54eef87
 ---&amp;gt; baf170e0c586
Step 3/9 : LABEL version=&quot;1.0&quot;
 ---&amp;gt; Running in 433669185e0d
Removing intermediate container 433669185e0d
 ---&amp;gt; d96fb4ae3d58
Step 4/9 : LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;
 ---&amp;gt; Running in b5da74e27c69
Removing intermediate container b5da74e27c69
 ---&amp;gt; 62372d19daf3
Step 5/9 : ARG web_home
 ---&amp;gt; Running in 3f65a67bb15a
Removing intermediate container 3f65a67bb15a
 ---&amp;gt; 1ce797c7cde0
Step 6/9 : COPY html ${web_home:-&quot;/data/htdoc/&quot;}
 ---&amp;gt; 15848dea21b9
Step 7/9 : VOLUME ${web_home:-&quot;/data/htdoc/&quot;}
 ---&amp;gt; Running in 868f4c10e00f
Removing intermediate container 868f4c10e00f
 ---&amp;gt; f3ec40d1cb5e
Step 8/9 : EXPOSE 80/tcp 443/tcp
 ---&amp;gt; Running in 7f72c2612e92
Removing intermediate container 7f72c2612e92
 ---&amp;gt; 5ccfc6d604cc
Step 9/9 : CMD httpd -f -h /data/htdoc/
 ---&amp;gt; Running in 95a4fd578821
Removing intermediate container 95a4fd578821
 ---&amp;gt; 2e296b4f4500
Successfully built 2e296b4f4500
Successfully tagged myimg:v1.3
[root@node1 test]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
myimg               v1.3                2e296b4f4500        3 seconds ago       1.22MB
myimg               v1.2                30a5f5594104        23 minutes ago      203MB
myimg               v1.1                ae463ec8cbd9        33 minutes ago      203MB
myimg               v1                  7f109a34a4a5        44 minutes ago      203MB
busybox             latest              1c35c4412082        16 hours ago        1.22MB
centos              7                   b5b4d78bc90c        4 weeks ago         203MB
[root@node1 test]# docker run --name b1 -d myimg:v1.3
c3514f782cffd8140aa7c612293029f4d0302e8d697887dfc2696eea44a31700
[root@node1 test]# docker ps 
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
c3514f782cff        myimg:v1.3          &quot;/bin/sh -c 'httpd -…&quot;   4 seconds ago       Up 3 seconds        80/tcp, 443/tcp     b1
[root@node1 test]# curl http://172.17.0.2/test1.html
this is test1 html
[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到httpd是可以正常提供服务的；从上面的信息我们也可以了解到运行容器后，它默认是把我们写的命令当作shell子命令的方式在运行；&lt;/p&gt;
&lt;p&gt;　　示例：以json数组方式运行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# cat Dockerfile 
FROM busybox:latest

MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;

LABEL version=&quot;1.0&quot;

LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;

ARG web_home

COPY html ${web_home:-&quot;/data/htdoc/&quot;}

VOLUME ${web_home:-&quot;/data/htdoc/&quot;}

EXPOSE 80/tcp 443/tcp

CMD [&quot;httpd&quot;,&quot;-f&quot;,&quot;-h&quot;,&quot;/data/htdoc/&quot;]

[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：用json数组格式运行命令，需要把后面的每个选项当作参数传给httpd；&lt;/p&gt;
&lt;p&gt;　　验证：运行容器看看容器是否退出，是否能够正常提供httpd服务？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
myimg               v1.3                2e296b4f4500        24 minutes ago      1.22MB
myimg               v1.2                30a5f5594104        47 minutes ago      203MB
myimg               v1.1                ae463ec8cbd9        57 minutes ago      203MB
myimg               v1                  7f109a34a4a5        About an hour ago   203MB
busybox             latest              1c35c4412082        17 hours ago        1.22MB
centos              7                   b5b4d78bc90c        4 weeks ago         203MB
[root@node1 test]# docker build . -t myimg:v1.4
Sending build context to Docker daemon   1.05MB
Step 1/9 : FROM busybox:latest
 ---&amp;gt; 1c35c4412082
Step 2/9 : MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; baf170e0c586
Step 3/9 : LABEL version=&quot;1.0&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; d96fb4ae3d58
Step 4/9 : LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; 62372d19daf3
Step 5/9 : ARG web_home
 ---&amp;gt; Using cache
 ---&amp;gt; 1ce797c7cde0
Step 6/9 : COPY html ${web_home:-&quot;/data/htdoc/&quot;}
 ---&amp;gt; Using cache
 ---&amp;gt; 15848dea21b9
Step 7/9 : VOLUME ${web_home:-&quot;/data/htdoc/&quot;}
 ---&amp;gt; Using cache
 ---&amp;gt; f3ec40d1cb5e
Step 8/9 : EXPOSE 80/tcp 443/tcp
 ---&amp;gt; Using cache
 ---&amp;gt; 5ccfc6d604cc
Step 9/9 : CMD [&quot;httpd&quot;,&quot;-f&quot;,&quot;-h&quot;,&quot;/data/htdoc/&quot;]
 ---&amp;gt; Running in 5bebdabfe2b7
Removing intermediate container 5bebdabfe2b7
 ---&amp;gt; 58e3b4c40ae7
Successfully built 58e3b4c40ae7
Successfully tagged myimg:v1.4
[root@node1 test]# docker run --name b1 -d myimg:v1.4
a32a05033a6dcb735363906bfcd2b84cfb290ca1b60c17d3ac2f81cdeceee705
[root@node1 test]# docker ps 
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
a32a05033a6d        myimg:v1.4          &quot;httpd -f -h /data/h…&quot;   6 seconds ago       Up 5 seconds        80/tcp, 443/tcp     b1
[root@node1 test]# curl http://172.17.0.2/test1.html
this is test1 html
[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到httpd服务可以正常提供访问，说明我们用json数组方式运行命令是正确的；总结一点，用CMD或RUN指令运行命令时，如果直接在CMD或RUN指令后面接命令，这种方式通常会被解释为启动一个shell子进程运行命令，RUN指令表现形式就是后面的命令可以使用shell特性的语法格式的命令，比如大括号展开等等；而CMD指令表现形式就是启动为容器后，它默认会把我们指定运行的命令当作参数传给“/bin/sh”来运行；CMD或RUN指令加中括号的形式就表示使用json数组格式方式运行命令；这种方式运行命令在CMD中表现形式是我们运行的命令的选项都要当作参数传给该命令；RUN指令表现形式是不能使用shell特性的命令；如果非要使用shell特性的命令格式，我们需要把我们的命令当作参数传给“/bin/sh”,当然前提是我们的基础镜像shell支持shell特性的语法；&lt;/p&gt;
&lt;p&gt;　　3、ENTRYPOINT：该指令类似CMD指令的功能，用于为容器指定默认运行程序，从而使得容器像是一个单独的可执行程序；与CMD不同的是，由ENTRYPOINT启动的程序不会被docker run命令行指定的参数所覆盖，而且，这些命令行参数会被当作参数传递给ENTRYPOINT指定的程序（不过，docker run命令的--entrypoint选项的参数可覆盖ENTRYPOINT指令指定的程序）；语法格式 ENTRYPOINT &amp;lt;command&amp;gt;或 ENTRYPOINT [&quot;&amp;lt;executable&amp;gt;&quot;, &quot;&amp;lt;param1&amp;gt;&quot;, &quot;&amp;lt;param2&amp;gt;&quot;]；docker run命令传入的命令参数会覆盖CMD指令的内容并且附加到ENTRYPOINT命令最后做为其参数使用；Dockerfile文件中也可以存在多个ENTRYPOINT指令，但仅有最后一个会生效；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# cat Dockerfile
FROM busybox:latest

MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;

LABEL version=&quot;1.0&quot;

LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;

ARG web_home

COPY html ${web_home:-&quot;/data/htdoc/&quot;}

VOLUME ${web_home:-&quot;/data/htdoc/&quot;}

EXPOSE 80/tcp 443/tcp

ENTRYPOINT httpd -f -h /data/htdoc/
[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上dockerfile中用ENTRYPOINT 来指定容器默认运行程序，它和CMD不同的是，CMD指定运行的命令，我们可以使用docker run 命令加要运行的的命令替代容器里默认运行的命令，而ENTRYPOINT指定的命令我们是不可随便替换的，如果要替换必须要使用--entrypoint选项来指定；&lt;/p&gt;
&lt;p&gt;　　验证：build成镜像，我们启动为容器直接运行/bin/sh 看看是否可行？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
myimg               v1.4                58e3b4c40ae7        23 minutes ago      1.22MB
myimg               v1.3                2e296b4f4500        47 minutes ago      1.22MB
myimg               v1.2                30a5f5594104        About an hour ago   203MB
myimg               v1.1                ae463ec8cbd9        About an hour ago   203MB
myimg               v1                  7f109a34a4a5        2 hours ago         203MB
busybox             latest              1c35c4412082        17 hours ago        1.22MB
centos              7                   b5b4d78bc90c        4 weeks ago         203MB
[root@node1 test]# docker build . -t myimg:v1.5
Sending build context to Docker daemon   1.05MB
Step 1/9 : FROM busybox:latest
 ---&amp;gt; 1c35c4412082
Step 2/9 : MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; baf170e0c586
Step 3/9 : LABEL version=&quot;1.0&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; d96fb4ae3d58
Step 4/9 : LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; 62372d19daf3
Step 5/9 : ARG web_home
 ---&amp;gt; Using cache
 ---&amp;gt; 1ce797c7cde0
Step 6/9 : COPY html ${web_home:-&quot;/data/htdoc/&quot;}
 ---&amp;gt; Using cache
 ---&amp;gt; 15848dea21b9
Step 7/9 : VOLUME ${web_home:-&quot;/data/htdoc/&quot;}
 ---&amp;gt; Using cache
 ---&amp;gt; f3ec40d1cb5e
Step 8/9 : EXPOSE 80/tcp 443/tcp
 ---&amp;gt; Using cache
 ---&amp;gt; 5ccfc6d604cc
Step 9/9 : ENTRYPOINT httpd -f -h /data/htdoc/
 ---&amp;gt; Running in de274d68686c
Removing intermediate container de274d68686c
 ---&amp;gt; 5825c2ec655f
Successfully built 5825c2ec655f
Successfully tagged myimg:v1.5
[root@node1 test]# docker run --name b1 --rm -it myimg:v1.5 /bin/sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：运行以上命令后，不会给我们一个shell终端，也不报错；但是我们直接访问httpd服务是可以正常访问的；这意味我们用docker run 命令是不能替换我们用entrypoint指定指定的命令的；&lt;/p&gt;
&lt;p&gt;　　测试：用--entrypoint 选项来看看是否能够覆盖ENTRYPOINT指定所指定的命令程序？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
myimg               v1.5                5825c2ec655f        12 minutes ago      1.22MB
myimg               v1.4                58e3b4c40ae7        35 minutes ago      1.22MB
myimg               v1.3                2e296b4f4500        About an hour ago   1.22MB
myimg               v1.2                30a5f5594104        About an hour ago   203MB
myimg               v1.1                ae463ec8cbd9        2 hours ago         203MB
myimg               v1                  7f109a34a4a5        2 hours ago         203MB
busybox             latest              1c35c4412082        17 hours ago        1.22MB
centos              7                   b5b4d78bc90c        4 weeks ago         203MB
[root@node1 test]# docker run --name b1 --rm -it --entrypoint &quot;/bin/sh&quot; myimg:v1.5
/ # ls
bin   data  dev   etc   home  proc  root  sys   tmp   usr   var
/ # ps
PID   USER     TIME  COMMAND
    1 root      0:00 /bin/sh
    7 root      0:00 ps
/ # 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到使用docker run 必须要加--entrypoint 选项才可以覆盖ENTRYPOINT指令指定的命令；&lt;/p&gt;
&lt;p&gt;　　示例：使用json数组格式来指定命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# cat Dockerfile 
FROM busybox:latest

MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;

LABEL version=&quot;1.0&quot;

LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;

ARG web_home

COPY html ${web_home:-&quot;/data/htdoc/&quot;}

VOLUME ${web_home:-&quot;/data/htdoc/&quot;}

EXPOSE 80/tcp 443/tcp

ENTRYPOINT [&quot;httpd&quot;,&quot;-f&quot;,&quot;-h&quot;,&quot;/data/htdoc/&quot;]

[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：使用json数组格式来指定命令时，都需要将后面的选项和参数当作该命令的参数传进去；&lt;/p&gt;
&lt;p&gt;　　测试：使用docker run 直接加命令 看看是否能够覆盖ENTRYPOINT指令指定的命令？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200603225200367-1803984367.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们直接使用命令是无法覆盖ENTRYPOINT指令说指定的命令；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# cat Dockerfile 
FROM centos:7

MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;

LABEL version=&quot;1.0&quot;

LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;

RUN yum install -y httpd

EXPOSE 80/tcp 

ENTRYPOINT [&quot;/usr/sbin/httpd&quot;,&quot;-DFOREGROUND&quot;]

[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试：用docker run 命令覆盖ENTRYPOINT指定的默认命令，看看是否可行？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# docker build . -t myimg:v1.7
Sending build context to Docker daemon  1.051MB
Step 1/7 : FROM centos:7
 ---&amp;gt; b5b4d78bc90c
Step 2/7 : MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; 604899ef29f9
Step 3/7 : LABEL version=&quot;1.0&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; d9edea71fa22
Step 4/7 : LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; ee027bbdc04b
Step 5/7 : RUN yum install -y httpd
 ---&amp;gt; Running in 164240645e39
Loaded plugins: fastestmirror, ovl
Determining fastest mirrors
 * base: mirrors.aliyun.com
 * extras: mirrors.aliyun.com
 * updates: mirrors.aliyun.com
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package httpd.x86_64 0:2.4.6-93.el7.centos will be installed
--&amp;gt; Processing Dependency: httpd-tools = 2.4.6-93.el7.centos for package: httpd-2.4.6-93.el7.centos.x86_64
--&amp;gt; Processing Dependency: system-logos &amp;gt;= 7.92.1-1 for package: httpd-2.4.6-93.el7.centos.x86_64
--&amp;gt; Processing Dependency: /etc/mime.types for package: httpd-2.4.6-93.el7.centos.x86_64
--&amp;gt; Processing Dependency: libaprutil-1.so.0()(64bit) for package: httpd-2.4.6-93.el7.centos.x86_64
--&amp;gt; Processing Dependency: libapr-1.so.0()(64bit) for package: httpd-2.4.6-93.el7.centos.x86_64
--&amp;gt; Running transaction check
---&amp;gt; Package apr.x86_64 0:1.4.8-5.el7 will be installed
---&amp;gt; Package apr-util.x86_64 0:1.5.2-6.el7 will be installed
---&amp;gt; Package centos-logos.noarch 0:70.0.6-3.el7.centos will be installed
---&amp;gt; Package httpd-tools.x86_64 0:2.4.6-93.el7.centos will be installed
---&amp;gt; Package mailcap.noarch 0:2.1.41-2.el7 will be installed
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

================================================================================
 Package             Arch          Version                    Repository   Size
================================================================================
Installing:
 httpd               x86_64        2.4.6-93.el7.centos        base        2.7 M
Installing for dependencies:
 apr                 x86_64        1.4.8-5.el7                base        103 k
 apr-util            x86_64        1.5.2-6.el7                base         92 k
 centos-logos        noarch        70.0.6-3.el7.centos        base         21 M
 httpd-tools         x86_64        2.4.6-93.el7.centos        base         92 k
 mailcap             noarch        2.1.41-2.el7               base         31 k

Transaction Summary
================================================================================
Install  1 Package (+5 Dependent packages)

Total download size: 24 M
Installed size: 32 M
Downloading packages:
warning: /var/cache/yum/x86_64/7/base/packages/apr-util-1.5.2-6.el7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY
Public key for apr-util-1.5.2-6.el7.x86_64.rpm is not installed
--------------------------------------------------------------------------------
Total                                              7.8 MB/s |  24 MB  00:03     
Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
Importing GPG key 0xF4A80EB5:
 Userid     : &quot;CentOS-7 Key (CentOS 7 Official Signing Key) &amp;lt;security@centos.org&amp;gt;&quot;
 Fingerprint: 6341 ab27 53d7 8a78 a7c2 7bb1 24c6 a8a7 f4a8 0eb5
 Package    : centos-release-7-8.2003.0.el7.centos.x86_64 (@CentOS)
 From       : /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Installing : apr-1.4.8-5.el7.x86_64                                       1/6 
  Installing : apr-util-1.5.2-6.el7.x86_64                                  2/6 
  Installing : httpd-tools-2.4.6-93.el7.centos.x86_64                       3/6 
  Installing : centos-logos-70.0.6-3.el7.centos.noarch                      4/6 
  Installing : mailcap-2.1.41-2.el7.noarch                                  5/6 
  Installing : httpd-2.4.6-93.el7.centos.x86_64                             6/6 
  Verifying  : mailcap-2.1.41-2.el7.noarch                                  1/6 
  Verifying  : apr-util-1.5.2-6.el7.x86_64                                  2/6 
  Verifying  : httpd-2.4.6-93.el7.centos.x86_64                             3/6 
  Verifying  : apr-1.4.8-5.el7.x86_64                                       4/6 
  Verifying  : httpd-tools-2.4.6-93.el7.centos.x86_64                       5/6 
  Verifying  : centos-logos-70.0.6-3.el7.centos.noarch                      6/6 

Installed:
  httpd.x86_64 0:2.4.6-93.el7.centos                                            

Dependency Installed:
  apr.x86_64 0:1.4.8-5.el7                                                      
  apr-util.x86_64 0:1.5.2-6.el7                                                 
  centos-logos.noarch 0:70.0.6-3.el7.centos                                     
  httpd-tools.x86_64 0:2.4.6-93.el7.centos                                      
  mailcap.noarch 0:2.1.41-2.el7                                                 

Complete!
Removing intermediate container 164240645e39
 ---&amp;gt; 63db91f4fe6a
Step 6/7 : EXPOSE 80/tcp
 ---&amp;gt; Running in 6585da71fc3b
Removing intermediate container 6585da71fc3b
 ---&amp;gt; eb671cf67f52
Step 7/7 : ENTRYPOINT [&quot;/usr/sbin/httpd&quot;,&quot;-DFOREGROUND&quot;]
 ---&amp;gt; Running in f6e7297025af
Removing intermediate container f6e7297025af
 ---&amp;gt; bac03b20761a
Successfully built bac03b20761a
Successfully tagged myimg:v1.7
[root@node1 test]# docker run --name m1 --rm -it myimg:v1.7 /bin/sh
Usage: /usr/sbin/httpd [-D name] [-d directory] [-f file]
                       [-C &quot;directive&quot;] [-c &quot;directive&quot;]
                       [-k start|restart|graceful|graceful-stop|stop]
                       [-v] [-V] [-h] [-l] [-L] [-t] [-T] [-S] [-X]
Options:
  -D name            : define a name for use in &amp;lt;IfDefine name&amp;gt; directives
  -d directory       : specify an alternate initial ServerRoot
  -f file            : specify an alternate ServerConfigFile
  -C &quot;directive&quot;     : process directive before reading config files
  -c &quot;directive&quot;     : process directive after reading config files
  -e level           : show startup errors of level (see LogLevel)
  -E file            : log startup errors to file
  -v                 : show version number
  -V                 : show compile settings
  -h                 : list available command line options (this page)
  -l                 : list compiled in modules
  -L                 : list available configuration directives
  -t -D DUMP_VHOSTS  : show parsed vhost settings
  -t -D DUMP_RUN_CFG : show parsed run settings
  -S                 : a synonym for -t -D DUMP_VHOSTS -D DUMP_RUN_CFG
  -t -D DUMP_MODULES : show all loaded modules 
  -M                 : a synonym for -t -D DUMP_MODULES
  -t                 : run syntax check for config files
  -T                 : start without DocumentRoot(s) check
  -X                 : debug mode (only one worker, do not detach)
[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到我们用docker run指定命令去覆盖ENTRYPOINT指令指定的命令，它给我们打印了httpd命令的用法，这说明我们后面传递的/bin/sh 当作参数传递给ENTRYPOINT说指定的命令；这里还需要说一下，上面的示例用docker run 去覆盖ENTRYPOINT指令指定的命令，没有报错的原因应该是busybox里的httpd程序支持传递/bin/sh当作参数；&lt;/p&gt;
&lt;p&gt;　　示例：CMD指令同ENTRYPOINT一起使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# cat Dockerfile 
FROM centos:7

MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;

LABEL version=&quot;1.0&quot;

LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;

RUN yum install -y httpd

ADD entrypoint.sh /bin/

EXPOSE 80/tcp 

CMD [&quot;/usr/sbin/httpd&quot;,&quot;-DFOREGROUND&quot;]

ENTRYPOINT [&quot;/bin/entrypoint.sh&quot;]

[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上dockerfile使用了CMD和ENTRYPOINT指令来指定容器默认运行程序；此时CMD所指定的命令默认会以参数的形式传给ENTRYPOINT指令所指定的命令；而上面ENTRYPOINT指定指定的是一个脚本，也就说上面dockerfile最终运行的命令是/bin/entrypoint.sh /usr/sbin/httpd -DFOREGROUND；这里的脚本就相当于中间层，通过脚本设定一些参数，然后把CMD指定的命令当作参数传给脚本，最终脚本运行起来；&lt;/p&gt;
&lt;p&gt;　　entrypoint脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# ll
total 1032
-rw-r--r-- 1 root root     307 Jun  3 11:28 Dockerfile
-rwxr-xr-x 1 root root     300 Jun  3 11:22 entrypoint.sh
drwxr-xr-x 2 root root      42 May 31 01:51 html
-rw-r--r-- 1 root root 1043748 May 26 11:07 nginx-1.19.0.tar.gz
-rw-r--r-- 1 root root      22 May 31 01:52 test.html
[root@node1 test]# cat entrypoint.sh 
#!/bin/bash

doc_root=${DOC_ROOT:-/var/www/html}
cat &amp;gt; /etc/httpd/conf.d/myweb.conf &amp;lt;&amp;lt;EOF
        &amp;lt;virtualhost *:80&amp;gt;
                servername &quot;localhost&quot;
                documentroot &quot;${doc_root}&quot;
                &amp;lt;directory &quot;${doc_root}&quot;&amp;gt;
                        options none
                        allowoverride none
                        require  all granted
                &amp;lt;/directory&amp;gt;
        &amp;lt;/virtualhost&amp;gt;
EOF

exec &quot;$@&quot;
[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这个脚本很简单就是在/etc/httpd/conf.d/生成一个myweb.conf的配置文件，然后最后引用脚本的参数运行；exec &quot;$@&quot; 表示把脚本的所有参数独立运行成一个守护进程；默认不使用exec就表示以shell子进程的方式运行，exec就表示运行为单独的守护进程，不再是shell子进程的方式；&lt;/p&gt;
&lt;p&gt;　　测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# docker build . -t httpd:v1
Sending build context to Docker daemon  1.051MB
Step 1/9 : FROM centos:7
 ---&amp;gt; b5b4d78bc90c
Step 2/9 : MAINTAINER &quot;qiuhom &amp;lt;qiuhom@linux-1874.com&amp;gt;&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; 604899ef29f9
Step 3/9 : LABEL version=&quot;1.0&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; d9edea71fa22
Step 4/9 : LABEL description=&quot;this is test file \ that label-values can span multiple lines.&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; ee027bbdc04b
Step 5/9 : RUN yum install -y httpd
 ---&amp;gt; Using cache
 ---&amp;gt; 63db91f4fe6a
Step 6/9 : ADD entrypoint.sh /bin/
 ---&amp;gt; 49d1270c3aa3
Step 7/9 : EXPOSE 80/tcp
 ---&amp;gt; Running in 3dacf6acf23b
Removing intermediate container 3dacf6acf23b
 ---&amp;gt; edced77af5b5
Step 8/9 : CMD [&quot;/usr/sbin/httpd&quot;,&quot;-DFOREGROUND&quot;]
 ---&amp;gt; Running in 23bb32def296
Removing intermediate container 23bb32def296
 ---&amp;gt; 169a5e164ba5
Step 9/9 : ENTRYPOINT [&quot;/bin/entrypoint.sh&quot;]
 ---&amp;gt; Running in f3bf0c267c7b
Removing intermediate container f3bf0c267c7b
 ---&amp;gt; 0801db092665
Successfully built 0801db092665
Successfully tagged httpd:v1
[root@node1 test]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
httpd               v1                  0801db092665        35 seconds ago      307MB
myimg               v1.7                bac03b20761a        12 minutes ago      307MB
myimg               v1.6                5370df4238eb        2 hours ago         1.22MB
myimg               v1.5                5825c2ec655f        2 hours ago         1.22MB
myimg               v1.4                58e3b4c40ae7        2 hours ago         1.22MB
myimg               v1.3                2e296b4f4500        3 hours ago         1.22MB
myimg               v1.2                30a5f5594104        3 hours ago         203MB
myimg               v1.1                ae463ec8cbd9        3 hours ago         203MB
myimg               v1                  7f109a34a4a5        3 hours ago         203MB
busybox             latest              1c35c4412082        19 hours ago        1.22MB
centos              7                   b5b4d78bc90c        4 weeks ago         203MB
[root@node1 test]# docker run --name h1 -d httpd:v1
cee14b04912822c33e7deeee361e1ce0c20d7daf6c0666bff319bf3f1bc69bdc
[root@node1 test]# docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
cee14b049128        httpd:v1            &quot;/bin/entrypoint.sh …&quot;   9 seconds ago       Up 9 seconds        80/tcp              h1
[root@node1 test]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到我们build成镜像后，直接运行为容器，容器正常；我们进入容器内部看看它到底运行的说明命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 test]# docker exec -it h1 /bin/bash
[root@cee14b049128 /]# ls /etc/httpd/conf.d/myweb.conf 
/etc/httpd/conf.d/myweb.conf
[root@cee14b049128 /]# cat /etc/httpd/conf.d/myweb.conf
        &amp;lt;virtualhost *:80&amp;gt;
                servername &quot;localhost&quot;
                documentroot &quot;/var/www/html&quot;
                &amp;lt;directory &quot;/var/www/html&quot;&amp;gt;
                        options none
                        allowoverride none
                        require  all granted
                &amp;lt;/directory&amp;gt;
        &amp;lt;/virtualhost&amp;gt;
[root@cee14b049128 /]# ps aux
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  0.0  0.1 224080  5016 ?        Ss   16:26   0:00 /usr/sbin/httpd -D
apache        7  0.0  0.0 224212  2960 ?        S    16:26   0:00 /usr/sbin/httpd -D
apache        8  0.0  0.0 224212  2960 ?        S    16:26   0:00 /usr/sbin/httpd -D
apache        9  0.0  0.0 224212  2960 ?        S    16:26   0:00 /usr/sbin/httpd -D
apache       10  0.0  0.0 224212  2960 ?        S    16:26   0:00 /usr/sbin/httpd -D
apache       11  0.0  0.0 224212  2960 ?        S    16:26   0:00 /usr/sbin/httpd -D
root         12  0.0  0.0  11828  1932 pts/0    Ss   16:35   0:00 /bin/bash
root         27  0.0  0.0  51756  1720 pts/0    R+   16:36   0:00 ps aux
[root@cee14b049128 /]# httpd -t -D DUMP_VHOSTS
AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
VirtualHost configuration:
*:80                   localhost (/etc/httpd/conf.d/myweb.conf:1)
[root@cee14b049128 /]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到容器内部运行的就是/usr/sbin/httpd -DFOREGROUND这个命令；其实这个命令不是CMD直接运行的命令，而是通过脚本获取参数而来的；我们通过脚本添加的配置文件都在对应的位置，并且也都生效了；总结一点，通常CMD和ENTRYPOINT应用在通过entrypoint脚本做中间层向容器内运行的程序提供配置文件的场景，通常这些应用程序不是云原生的；&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jun 2020 16:32:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊到了什么是dockerfile,它的主要作用以及dockerfile的一些基本指令的使用方法，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/13019</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13040273.html</dc:identifier>
</item>
<item>
<title>一篇文章带你快速弄清楚什么是终端 - Coding十日谈</title>
<link>http://www.cnblogs.com/jfzhu/p/13040942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jfzhu/p/13040942.html</guid>
<description>&lt;p&gt;&lt;strong&gt;Linux的使用者可能每天都会接触到 Bash、Shell、控制台、终端。它们之间有什么不同吗？本文为你快速解释这些概念以及它们的区别。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;什么是终端&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;首先我们来弄清楚什么是终端（terminal）。按照百度百科的解释是：“&lt;em&gt;经由通信设施向计算机输入程序和数据或接&lt;/em&gt;&lt;em&gt;收计算机&lt;/em&gt;&lt;em&gt;输出处理结果的设备。&lt;/em&gt;” 听起来似乎有点晦涩，其实用台式PC机来举例就很容易理解了。一台台式机是由主机（机箱）和很多外围设备组成的。主机里边包括主板、CPU、内存、硬盘、和其他芯片等等。外围设备包括显示器、鼠标、键盘、耳机、麦克风、和摄像头等等。这些外围设备就被称为终端，负责向主机输入数据的就叫输入终端，比如鼠标、键盘、麦克风、摄像头，负责接收主机输出数据的设备就被称作输出终端，比如显示器、耳机。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202006/442200-20200603235800908-300339928.png&quot; alt=&quot;&quot; width=&quot;435&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以有两个概念我们这里就清楚了：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;计算机 = 主机 + 终端&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;终端 = 输入终端 + 输出终端&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;终端的类型&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;终端，除了可以分为输入终端与输出终端外，还可以按照与主机的距离可以本地终端和远程终端，或者按照与主机的连接方式分成物理终端和虚拟终端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202006/442200-20200603235838767-729572065.png&quot; alt=&quot;&quot; width=&quot;694&quot; height=&quot;402&quot;/&gt;&lt;/p&gt;

&lt;p&gt;举个例子，比如我们在杭州的某个机房里有一台服务器，用VGA线接了一台显示器，用USB连接了键盘，那么这台显示器和这个键盘就是服务器的本地终端。假如我们在隔壁机房用串口线又接了一个显示器和键盘，那它们就可以称为远程终端。不管是在本地机房还是隔壁机房，因为这几个终端和服务器都是通过物理设备直接连接的，所以它们都被称为物理终端。物理终端在 Linux中被标识为 tty。它是teletype的缩写，因为在计算机早期的时候，Ken Thompson 和 Dennis Ritchie用电传打印机作为他们  Unix 服务器的终端（参考&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12895692.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《Linux，Unix，GNU 到底有什么样的渊源？》&lt;/a&gt;），所以这个名字就这样被沿用了下来。&lt;/p&gt;

&lt;p&gt;假如我们在上海的家里通过 ssh 远程登陆杭州的服务器，那么我们在家中用的设备就是服务器的远程终端，也是一个虚拟终端（因为没有与服务器在本地用物理设备连接）。虚拟终端在 Linux 中用 pts （pseudo termial slave）来标识。用 who 命令可以查看当前登陆系统的用户，以及他们所使用的终端类型。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202006/442200-20200603235944136-1942276655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;什么是控制台&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;控制台（console）与终端现在已经几乎表示同一个意思了，但是在计算机发展的早期它们还是有本质区别的。最初，大型计算机（可能有几间屋子那么大）只有一个终端，被称为”控制台“，而它真的是一个控制台，就像下面这张图这样，有很多的仪表和开关，技术人员就是通过它来对计算机发出指令。那个时候计算机虽然很大，但每次只能有一个人来操作，并且一次也只能运行一个程序。后来Ken Thompson 和 Dennis Ritchie发明了Unix，于是操作系统可以同时运行多个程序，并且支持多个用户同时登陆。这样一来，仅有一个控制台就显得不够了。因为控制台又很贵，所以 Ken Thompson 和 Dennis Ritchie就用了相对便宜的电传打字机作为新增加的终端连接到他们的计算机上。虽然一台计算机可以连接很多个终端，但这里边只能有一个控制台，并且控制台的权限要远大于其他的终端，比如当系统发生启动错误时，只有控制台会显示错误消息，而其他终端不会；或者当系统进入单用户登陆模式时，只有通过控制台才能进行登陆，而通过其他终端没有办法登陆。所以如果用一句话来总结控制台与终端的区别，可以说控制台是计算机最早的以及权限最大的一个终端。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202006/442200-20200604000001570-1955588974.jpg&quot; alt=&quot;&quot; width=&quot;755&quot; height=&quot;425&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;什么是 Shell 和 Bash&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;终端和主机虽然连接起来了，但是计算机还是需要一个程序才能明白我们输入的命令，这个程序就是 Shell。我们的命令就是通过终端输入到 Shell 里，再由 Shell 转换成计算机明白的指令，然后计算机才能运行。&lt;/p&gt;
&lt;p&gt; Shell 有很多种，我们最常用的是 Bash，另外还有Csh, Ksh, Zsh等等。对于Bash，Linux的用户应该每天都在使用，这里就不再展开介绍了。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;最后&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;控制台、终端、Shell、Bash 这些名词经常被大家混淆，虽然今天在很多场合它们经常被替换使用，大家也都明白，不过希望通过本文大家可以弄清楚它们之间的区别和联系。&lt;/p&gt;


&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/13029026.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《一篇文章看清楚 Linux 的职业发展方向》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12992830.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《2020年你最需要掌握的11种编程语言》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12992996.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《微软：悬赏10万美金破解 Linux 系统》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12986863.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《安卓到底是不是Linux》&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12978109.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《在 Linux 系统中如何管理 systemd 服务》&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12961694.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《Linux的运行级别与目标》&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12945358.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《软链接 vs. 硬链接》&lt;/a&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202006/442200-20200604000233326-328355230.jpg&quot; alt=&quot;&quot; width=&quot;195&quot; height=&quot;195&quot;/&gt;&lt;/p&gt;
&lt;p&gt;扫码关注公众号获取知识干货、增加面试经验、了解程序人生&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jun 2020 16:04:00 +0000</pubDate>
<dc:creator>Coding十日谈</dc:creator>
<og:description>Linux的使用者可能每天都会接触到 Bash、Shell、控制台、终端。它们之间有什么不同吗？本文为你快速解释这些概念以及它们的区别。 什么是终端 首先我们来弄清楚什么是终端（terminal）。按</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jfzhu/p/13040942.html</dc:identifier>
</item>
<item>
<title>Web 三维组态的仿真运用案例：民航飞机的数据监控 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/13040787.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/13040787.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200601182955783-1263410578.gif&quot; class=&quot;desc_img&quot;/&gt; 在飞机航行的过程中，客舱里座位上方的荧屏上，除了播放电视剧和广告之外，还会时不时的切换到一个飞机航行的监控系统。这个监控系统的主要目的是，让乘客可以了解到飞机在航行过程中的整体状况、距离目的地的航线进程以及一些有可能出现的突发事件。飞机航行的监控系统在一定程度上，可以使乘客在旅途过程中得到准确的信息源，最重要的是可以使乘客在旅途中得到安心。在保障乘客获取到实际信息源的同时，飞机航行的监控系统也能将采集到的数据及时的反馈给航务人员，而且将数据记录保存下来，在飞机过站或航后供航务和机务人员使用和监测维护。介于 2D 组态和 3D 组态上，Hightopo（以下简称 HT ）的 HT for Web 产品上的有着丰富的组态化可供选择，本文将介绍如何运用 HT 丰富的 2/3D 组态搭建出一个飞机航行的监控系统的解决方案。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;76.692070762913&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在飞机航行的过程中，客舱里座位上方的荧屏上，除了播放电视剧和广告之外，还会时不时的切换到一个飞机航行的监控系统。这个监控系统的主要目的是，让乘客可以了解到飞机在航行过程中的整体状况、距离目的地的航线进程以及一些有可能出现的突发事件。飞机航行的监控系统在一定程度上，可以使乘客在旅途过程中得到准确的信息源，最重要的是可以使乘客在旅途中得到安心。在保障乘客获取到实际信息源的同时，飞机航行的监控系统也能将采集到的数据及时的反馈给航务人员，而且将数据记录保存下来，在飞机过站或航后供航务和机务人员使用和监测维护。介于 2D 组态和 3D 组态上，&lt;strong&gt;Hightopo&lt;/strong&gt;（以下简称 HT ）的 &lt;strong&gt;HT for Web&lt;/strong&gt; 产品上的有着丰富的组态化可供选择，本文将介绍如何运用 HT 丰富的 &lt;strong&gt;2/3D 组态&lt;/strong&gt;搭建出一个飞机航行的监控系统的解决方案。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200601182955783-1263410578.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;


&lt;div readability=&quot;14.5&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;系统分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;26.5&quot;&gt;
&lt;div class=&quot;lemma-summary&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;飞机航行监控是一种测量、跟踪飞机性能变化趋势的简单而实用方法。在日常航班飞行中，用机载仪表记录飞机巡航时的有关参数，并将其与原有性能进行比较。监控的主要参数有:飞行单位时间消耗的燃油量、飞机的巡航飞行速度和消耗单位燃油量飞机飞过的水平距离。它们分别表示发动机、飞机及飞机发动机的综合性能。它们分别表示发动机、飞机及飞机发动机的综合性能。性能监控的结果，既可为飞机维修提供可能的故障信息，又为制定飞行计划提供可靠的性能依据。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;目前，先进的喷气运输机都已安装飞行状态监控系统，它记录下有关参数值,并存储在数据管理装置中，这些数据可以发送到或在飞机着陆后送到地面站，用专用计算机程序进行计算和修正，使性能监控数据采集、发送、计箅分析工作自动化，节省了人力，提高了精确度。&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;飞行数据记录器&lt;/strong&gt;：自从飞行数据记录器 FDR（Flight Data Recorder）“俗称黑匣子”诞生以来，其提供的详实准确的飞行数据为事故调查、机务维护保障、安全运营监控提供了重要依据，成为航空安全运营的重要管理手段。&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200601171449221-233023130.png&quot; alt=&quot;&quot; width=&quot;386&quot; height=&quot;250&quot;/&gt;&lt;/div&gt;
&lt;p&gt;2、&lt;strong&gt;ACMS&lt;/strong&gt;（Aireraft Condition Monitoring System）的系统概述：ACMS 系统是飞机上安装的先进机载数据采集和处理系统，它能以实时方式收集数据，对发动机状态和飞行性能进行监控以及进行特殊的工程调查。由飞机通信寻址与报告系统（ACARS）通过地空数据链发送到地面接收站，最后传送到航空公司的终端，也可通过快速存取记录器（QAR）将数据记录保存下来，在飞机过站或航后供航务和机务人员使用。&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200601180251351-998251098.png&quot; alt=&quot;&quot; width=&quot;906&quot; height=&quot;567&quot;/&gt;&lt;/div&gt;
&lt;p&gt;而 HT 实现的业务功能可以通过ACMS 系统采集到的数据，对接到显示终端去展示，通过实时监测的数据准确地显示出来，起到对飞机状态的监控功能并即时反馈信息数据的变化。&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200601184148738-1220264258.gif&quot; alt=&quot;&quot; width=&quot;905&quot; height=&quot;420&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;实现过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;云中穿行效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;22&quot;&gt;
&lt;p&gt;为了达到飞机云中穿行的效果，最开始我遇到的问题是飞机飞行的层次感，也就通常所说的透视效果，这里我采用的是云通道和云背景以不同的速度流动，制造一种飞行的透视效果。&lt;/p&gt;

&lt;p&gt;云我采用的是贴图的方式呈现的，但是仅仅是贴图会遮挡天空和飞机，非常影响飞机飞行的观感，所以我开启了相应图元的 &lt;strong&gt;transparent&lt;/strong&gt; 和 &lt;strong&gt;opacity&lt;/strong&gt;，云背景和云通道设置不同的透明度，不仅增加了层次感，还会让人产生云朵从眼前飘过的错觉。&lt;/p&gt;

&lt;p&gt;云通道采用的是 &lt;strong&gt;ht.Polyline&lt;/strong&gt; 类型，通道缩放拉大了 Y 轴的比例，使云通道有更大的纵向空间，设置 &lt;strong&gt;reverse.flip&lt;/strong&gt; 背拷贝使云通道内部也显示出贴图，仿佛让飞机置身于云海中穿梭；云背景采用 &lt;strong&gt;ht.Node&lt;/strong&gt; 类型，只设置一个面显示充当云背景。&lt;/p&gt;

&lt;p&gt;整体的云流动效果采用 &lt;strong&gt;offset&lt;/strong&gt; 偏移实现，改变相应图元或相应图元面的贴图偏移量来达到飞机云中穿行的效果， 代码如下：&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;var i = 1&lt;span data-mce-=&quot;&quot;&gt;,
    p = 0&lt;span data-mce-=&quot;&quot;&gt;;
setInterval(() =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    i -= 0.1; p += 0.005&lt;span data-mce-=&quot;&quot;&gt;;
    clouds.s('shape3d.uv.offset', [i, 0&lt;span data-mce-=&quot;&quot;&gt;]);
    cloudBackground.s('all.uv.offset', [p, 0&lt;span data-mce-=&quot;&quot;&gt;]);
}, 100);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;升降颠簸效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然达到了飞机云中穿行的效果，但是如果飞机只是直直的飞行，那也会降低飞行的实感，相信坐过飞机的朋友肯定都遇到过因气流产生的颠簸，也经常感受到飞机飞行途中的爬升和下降，这其实是因为飞机的航线并不是一直固定在一个高度上，有时会爬升有时会下降，所以我就用 &lt;strong&gt;ht-animation.js&lt;/strong&gt; HT 动画扩展插件去实现飞机颠簸效果，代码如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;24.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
dm.enableAnimation(20&lt;span data-mce-=&quot;&quot;&gt;);
plane.setAnimation({
    back1: {
        from: 0&lt;span data-mce-=&quot;&quot;&gt;,
        to: 160&lt;span data-mce-=&quot;&quot;&gt;,
        easing: 'Cubic.easeInOut'&lt;span data-mce-=&quot;&quot;&gt;,
        duration: 8000&lt;span data-mce-=&quot;&quot;&gt;,
        next: &quot;up1&quot;&lt;span data-mce-=&quot;&quot;&gt;,
        onUpdate: &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; (value) {
            value =&lt;span data-mce-=&quot;&quot;&gt; parseInt(value);
            &lt;span data-mce-=&quot;&quot;&gt;var p3 = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.p3();
            &lt;span data-mce-=&quot;&quot;&gt;this.p3(value, p3[1], p3[2&lt;span data-mce-=&quot;&quot;&gt;]);
        }
    },
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt;...省略相似
    start: [&quot;back1&quot;&lt;span data-mce-=&quot;&quot;&gt;]
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;球扇形视角限制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;飞行效果完善之后，这时我就遇到了一个比较棘手的问题，因为实际上虽然看着飞机是在云海中穿梭，但是仅仅是在通道中飞行，背景其实也只是平面贴图，所以当视角到达某种程度的时候就会有强烈的违和感和不真实感，就需要一个视角限制，使视角的调整刚刚好在一个范围内。&lt;/p&gt;

&lt;p&gt;视角限制的话一般是限制 g3d 的 &lt;strong&gt;eye&lt;/strong&gt; 和 &lt;strong&gt;center&lt;/strong&gt;，不太了解的朋友可以去看 hightopo 官网中的 3d 手册，里面有详细的说明，这里我就不再赘述了；因为视角范围的关系，所以我决定固定 &lt;strong&gt;center&lt;/strong&gt; 的位置，代码如下：&lt;/p&gt;
&lt;div readability=&quot;25&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
g3d.addPropertyChangeListener(e =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 固定中心点
    &lt;span data-mce-=&quot;&quot;&gt;if (e.property === 'center'&lt;span data-mce-=&quot;&quot;&gt;) {
        e.newValue[0] = center[0&lt;span data-mce-=&quot;&quot;&gt;];
        e.newValue[1] = center[1&lt;span data-mce-=&quot;&quot;&gt;];
        e.newValue[2] = center[2&lt;span data-mce-=&quot;&quot;&gt;];
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再把 &lt;strong&gt;eye&lt;/strong&gt; 限制在某一个范围内就大功告成了，然而这里却并不是那么简单，最开始我把 &lt;strong&gt;eye&lt;/strong&gt; 限制在一个立方体的空间内，但交互效果很不理想，考虑到 g3d 默认交互中，鼠标拖拽平移视角变换时，实际上 &lt;strong&gt;eye&lt;/strong&gt; 是在一个以 &lt;strong&gt;center&lt;/strong&gt; 为球心的球面上运动的，所以我决定从这个球中挖出来一块作为 &lt;strong&gt;eye&lt;/strong&gt; 的限制空间，也就是球扇形，不太理解的朋友可以参考这个图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200601143929088-1450824432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;球扇形视角限制，一共需要三个参数，分别是中心参考轴、中心轴和外边所成角度、所在球限制半径，其中中心参考轴可根据初始 &lt;strong&gt;eye&lt;/strong&gt; 和 &lt;strong&gt;center&lt;/strong&gt; 的连接延长线确定，所在球限制半径又分最大限制和最小限制，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; limitEye(g3d, eye, center, options) {
    &lt;span data-mce-=&quot;&quot;&gt;var limitMaxL   =&lt;span data-mce-=&quot;&quot;&gt; options.limitMaxL,
        limitMinL   =&lt;span data-mce-=&quot;&quot;&gt; options.limitMinL,
        limitA      =&lt;span data-mce-=&quot;&quot;&gt; options.limitA;

    g3d.addPropertyChangeListener(e =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 固定中心点
        &lt;span data-mce-=&quot;&quot;&gt;if (e.property === 'center'&lt;span data-mce-=&quot;&quot;&gt;) {
            e.newValue[0] = center[0&lt;span data-mce-=&quot;&quot;&gt;];
            e.newValue[1] = center[1&lt;span data-mce-=&quot;&quot;&gt;];
            e.newValue[2] = center[2&lt;span data-mce-=&quot;&quot;&gt;];
        }
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 限制视角
        &lt;span data-mce-=&quot;&quot;&gt;if (e.property === 'eye'&lt;span data-mce-=&quot;&quot;&gt;) {
            &lt;span data-mce-=&quot;&quot;&gt;var newEyeV = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.Math.Vector3(e.newValue),
                centerV = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.Math.Vector3(center),
                refEyeV = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.Math.Vector3(eye),
                refVector =&lt;span data-mce-=&quot;&quot;&gt; refEyeV.clone().sub(centerV),
                newVector =&lt;span data-mce-=&quot;&quot;&gt; newEyeV.clone().sub(centerV);

            &lt;span data-mce-=&quot;&quot;&gt;if (centerV.distanceTo(newEyeV) &amp;gt;&lt;span data-mce-=&quot;&quot;&gt; limitMaxL) {
                newVector.setLength(limitMaxL);
                e.newValue[0] =&lt;span data-mce-=&quot;&quot;&gt; newVector.x;
                e.newValue[1] =&lt;span data-mce-=&quot;&quot;&gt; newVector.y;
                e.newValue[2] =&lt;span data-mce-=&quot;&quot;&gt; newVector.z;
            }
            &lt;span data-mce-=&quot;&quot;&gt;if (centerV.distanceTo(newEyeV) &amp;lt;&lt;span data-mce-=&quot;&quot;&gt; limitMinL) {
                newVector.setLength(limitMinL);
                e.newValue[0] =&lt;span data-mce-=&quot;&quot;&gt; newVector.x;
                e.newValue[1] =&lt;span data-mce-=&quot;&quot;&gt; newVector.y;
                e.newValue[2] =&lt;span data-mce-=&quot;&quot;&gt; newVector.z;
            }
            &lt;span data-mce-=&quot;&quot;&gt;if (newVector.angleTo(refVector) &amp;gt;&lt;span data-mce-=&quot;&quot;&gt; limitA) {
                &lt;span data-mce-=&quot;&quot;&gt;var oldLength =&lt;span data-mce-=&quot;&quot;&gt; newVector.length(),
                    oldAngle  =&lt;span data-mce-=&quot;&quot;&gt; newVector.angleTo(refVector),
                    refLength = oldLength *&lt;span data-mce-=&quot;&quot;&gt; Math.cos(oldAngle),
                    vertVector,
                    realVector,
                    realEye;

                refVector.setLength(refLength);

                newEyeV =&lt;span data-mce-=&quot;&quot;&gt; newVector.clone().add(centerV);
                refEyeV =&lt;span data-mce-=&quot;&quot;&gt; refVector.clone().add(centerV);
                vertVector =&lt;span data-mce-=&quot;&quot;&gt; newEyeV.clone().sub(refEyeV);
                vertLength = refLength *&lt;span data-mce-=&quot;&quot;&gt; Math.tan(limitA);

                vertVector.setLength(vertLength);

                realVector =&lt;span data-mce-=&quot;&quot;&gt; vertVector.clone().add(refEyeV).sub(centerV);

                realVector.setLength(oldLength);

                realEye =&lt;span data-mce-=&quot;&quot;&gt; realVector.clone().add(centerV);

                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 防止移动角度大于 180 度，视角反转
                &lt;span data-mce-=&quot;&quot;&gt;if (oldAngle &amp;gt; Math.PI / 2&lt;span data-mce-=&quot;&quot;&gt;) {
                    realEye.negate();
                }

                e.newValue[0] =&lt;span data-mce-=&quot;&quot;&gt; realEye.x;
                e.newValue[1] =&lt;span data-mce-=&quot;&quot;&gt; realEye.y;
                e.newValue[2] =&lt;span data-mce-=&quot;&quot;&gt; realEye.z;
            }  
        }
    })
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200601183102524-1298482796.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;飞机监控系统&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当然作为监控系统，自然要有监控了，增加右下角的小地图，并提供三种模式，分别是聚焦飞机，聚焦飞行轨迹和聚焦地图，并根据飞机的飞行方向控制飞行轨迹的流动效果，其中聚焦飞机会跟随飞机移动进行 &lt;strong&gt;fitData&lt;/strong&gt;，使飞机一直处于小地图的中心，代码如下：&lt;/p&gt;
&lt;div readability=&quot;29.583990837363&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;var fitFlowP = &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; (e) {
    &lt;span data-mce-=&quot;&quot;&gt;if (e.property === 'position' &amp;amp;&amp;amp; e.data ===&lt;span data-mce-=&quot;&quot;&gt; plane) {
        mapGV.fitData(plane, &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;);
    }
};
buttonP.s({
    'interactive': &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
    'onClick': &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; (event, data, view, point, width, height) {
        map.a('fitDataTag', 'plane2D'&lt;span data-mce-=&quot;&quot;&gt;);
        mapGV.fitData(plane, &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;);
        mapDM.md(fitFlowP);
    }
});
buttonL.s({
    'interactive': &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
    'onClick': &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; (event, data, view, point, width, height) {
        mapDM.umd(fitFlowP);
        map.a('fitDataTag', 'flyLine'&lt;span data-mce-=&quot;&quot;&gt;);
        mapGV.fitData(flyLine, &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;);
    }
});
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; ...省略&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200601144713039-576054234.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;增加鼠标移到飞机相应位置进行名称的提示、双击后显示飞机相应位置的信息面板并将视角聚焦到面板上、点击飞机任意地方切换回飞机飞行模式等效果。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200601183219595-796992428.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;左侧增加监控面板替代上面提到的双击相应位置这步操作直接聚焦到相应位置的信息面板上，这里按钮开启了交互并添加了相应的交互逻辑，代码如下：&lt;/p&gt;
&lt;div readability=&quot;26.425852366766&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;button_JC.s({
    'interactive': &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
    'onClick': &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; (event, data, view, point, width, height) {
        event.preventDefault();
        let g3d =&lt;span data-mce-=&quot;&quot;&gt; G.g3d,
            g3dDM =&lt;span data-mce-=&quot;&quot;&gt; G.g3d.dm();
        g3d.fireInteractorEvent({
            kind: 'doubleClickData'&lt;span data-mce-=&quot;&quot;&gt;,
            data: g3dDM.getDataByTag(data.getTag())
        })
    }
});
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt;...省略&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200601183322505-1953993980.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;天空渲染效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;既然是监控系统肯定是 24 小时无差别的监控，这就涉及到一个问题，我总不可能半夜的时候飞机也从瓦蓝瓦蓝的天空上飞过，这就很欠缺真实性了，所以要有一个天空从亮到暗再从暗到亮的过程，这个过程我暂定到 06:00-06:30 和19:00-19:30 这两个时间段。&lt;/p&gt;

&lt;p&gt;天空采用的是 &lt;strong&gt;shape3d : 'sphere'&lt;/strong&gt; 球形，包裹整个场景，然后使用 &lt;strong&gt;reverse.flip&lt;/strong&gt; 背拷贝 和 &lt;strong&gt;blend&lt;/strong&gt; 染色，之后天空就可以渲染成我想要的颜色，如果按照时间改变天空明暗只要改变染色值就可以了。&lt;/p&gt;

&lt;p&gt;但是由于白天和晚上光照情况的不同，云反射光的强度也不同，就导致了白天和晚上云的差异，所以也要调整云道和云背景的贴图的 &lt;strong&gt;opacity&lt;/strong&gt; 透明度，晚间更为透明度，代码如下：&lt;/p&gt;
&lt;div readability=&quot;17.81875658588&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;if ((hour &amp;gt; 6 &amp;amp;&amp;amp; hour &amp;lt; 19) || (hour == 6 &amp;amp;&amp;amp; minutes &amp;gt;= 30&lt;span data-mce-=&quot;&quot;&gt;)) {
    timePane &amp;amp;&amp;amp;&lt;span data-mce-=&quot;&quot;&gt; timePane.a({
        'morning.visible': &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;,
        'day.visible': &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
        'dusk.visible': &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;,
        'night.visible': &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;,
        'day.opacity': 1&lt;span data-mce-=&quot;&quot;&gt;
    })
    skyBox.s({
        &quot;shape3d.blend&quot;: 'rgb(127, 200, 240)'&lt;span data-mce-=&quot;&quot;&gt;,
    })
    cloudBackground.s({
        &quot;back.opacity&quot;: 0.7&lt;span data-mce-=&quot;&quot;&gt;,
    })
    clouds.s({
        &quot;shape3d.opacity&quot;: 0.7&lt;span data-mce-=&quot;&quot;&gt;,
    })
} &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if ((hour &amp;lt; 6 || hour &amp;gt; 19) || (hour == 19 &amp;amp;&amp;amp; minutes &amp;gt;= 30&lt;span data-mce-=&quot;&quot;&gt;)) {
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt;...省略
} &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (hour == 6 &amp;amp;&amp;amp; minutes &amp;lt; 15&lt;span data-mce-=&quot;&quot;&gt; ) {
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt;...省略
} &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (hour == 6 &amp;amp;&amp;amp; minutes &amp;gt;= 15 &amp;amp;&amp;amp; minutes &amp;lt; 30&lt;span data-mce-=&quot;&quot;&gt;) {
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt;...省略
} &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (hour == 19 &amp;amp;&amp;amp; minutes &amp;lt; 15&lt;span data-mce-=&quot;&quot;&gt;) {
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt;...省略
} &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (hour == 19 &amp;amp;&amp;amp; minutes &amp;gt;= 15 &amp;amp;&amp;amp; minutes &amp;lt; 30&lt;span data-mce-=&quot;&quot;&gt;) {
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt;...省略
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200601183717988-503747901.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我还增加了对右上角时间面板时间状态图标的支持，并增加了图标切换时的渐隐渐显效果，同时给时间面板状态图标位置增加了点击切换到下一时间状态的功能。&lt;/p&gt;

&lt;p&gt;为了演示效果我增加了时间倍速按钮，下图是 500 倍时间流速下的变化情况：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200601145630357-1703055878.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;6.5166666666667&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5213675213675&quot;&gt;身处大数据时代的我们，在网络科技发展越来越快的环境下，迎来了 5G 的新征程和工业4.0的新变革，在信息数据采集传输和数据可视化系统的融合下，可以发掘出许多行业管控可视化系统的解决方案。而 HT 长久以来一直致力于多样化行业系统可视化的搭建，涉猎的技术行业所累积的经验，通过自主创新研发的技术产品，已经打造出许多行业上具有代表性意义的可视化管控系统，例如同样有关于飞机的监控可视化系统：&lt;a href=&quot;https://www.cnblogs.com/htdaydayup/p/12262550.html&quot; target=&quot;_blank&quot;&gt;无人机 3D 可视化系统&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202006/1496396-20200601185137243-2111613258.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 03 Jun 2020 15:49:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 在飞机航行的过程中，客舱里座位上方的荧屏上，除了播放电视剧和广告之外，还会时不时的切换到一个飞机航行的监控系统。这个监控系统的主要目的是，让乘客可以了解到飞机在航行过程中的整体状况、距离目的地的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/13040787.html</dc:identifier>
</item>
</channel>
</rss>