<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>有没有异常处理翻车过的，绩效还被打了C - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/13728074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/13728074.html</guid>
<description>&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;絮叨&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;因为程序异常处理问题，就在前几天龙叔的服务挂了几秒钟。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1giwzsilzk9j31rs0u041t.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;完了，马上季度末打绩效，竟然在这里翻车了，心如刀绞啊。&lt;/p&gt;
&lt;p&gt;虽然没有影响到用户体验，但是&lt;strong&gt;找到问题并解决掉问题&lt;/strong&gt;是工程师日常追求之一。&lt;/p&gt;
&lt;p&gt;作为一个&lt;strong&gt;优秀&lt;/strong&gt;的工程师，应该还得加几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;弄清问题本质&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;总结问题原因&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;举一反三，防止出现类似错误&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;异常处理，对于每个开发者来说一点不陌生。&lt;/p&gt;
&lt;p&gt;有人这样描述，“一个开发者90%的时间都是在处理程序异常”。&lt;/p&gt;
&lt;p&gt;这样说也不算是什么过错，毕竟正常的逻辑总是轻松容易的写完，异常处理往往会占据开发者大多数时间。&lt;/p&gt;
&lt;p&gt;既然这么占据我们的开发时间，何不主动花点时间去&lt;strong&gt;了解他&lt;/strong&gt;，&lt;strong&gt;熟悉他&lt;/strong&gt;，切莫让他成为了最熟悉的陌生人。&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;文章大纲&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1giwzyx0ap2j30tq0giq3x.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;异常分类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在Java中，异常分为受检查的异常，与运行时异常。两者都在异常类层次结构中。下面的图展示了Java异常类的继承关系。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gix4ti7zguj319c0u0dlc.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;不难看出所有的异常都继承自一个共同的父类&lt;strong&gt;Throwable&lt;/strong&gt;，而Throwable有两个重要的子类：Exception（异常）和Error（错误）。&lt;/p&gt;
&lt;h4 id=&quot;herror&quot;&gt;&lt;span&gt;Error（错误）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;工程师最怕的就是Error，看到error和fail头都大了三圈，感觉Error总是和我过不去。&lt;/p&gt;
&lt;img src=&quot;https://www.52doutu.cn/static/temp/pic/ff8b9b0ea6e6d8e079e24ca5cf8d300f.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;Error是指Java 运行时系统的内部错误和资源耗尽错误。&lt;/p&gt;
&lt;p&gt;应用程序&lt;strong&gt;不应该&lt;/strong&gt;抛出这种类型的对象。&lt;/p&gt;
&lt;p&gt;如果出现了这样的内部错误， 除了通告给用户，并尽力使程序安全地终止之外， 再也无能为力了。一般这种情况很少出现。&lt;/p&gt;
&lt;p&gt;这种错误会导致你的程序日常运行着，突然某天就夭折了。&lt;/p&gt;
&lt;h4 id=&quot;hexception&quot;&gt;&lt;span&gt;Exception（异常）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。&lt;/p&gt;
&lt;p&gt;异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。&lt;/p&gt;
&lt;p&gt;Java通过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的&lt;strong&gt;错误条件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当条件生成时，错误将引发异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常和错误的区别：异常能被程序本身处理，错误是无法处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;异常主要分为&lt;strong&gt;运行期异常&lt;/strong&gt;和&lt;strong&gt;非运行期异常&lt;/strong&gt;（编译异常）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行期异常&lt;/strong&gt;很好理解，就是程序跑着跑着因为触发某个条件，导致异常发生了。比如越界了，NullPointerException等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译期异常&lt;/strong&gt;，就是程序编译时抛出的异常，比如访问的文件不存在。这类异常很好避免，编译不会通过，不解决掉，程序就没法运行起来。&lt;/p&gt;
&lt;p&gt;当然有人也把异常分为&lt;strong&gt;可查异常&lt;/strong&gt;和&lt;strong&gt;不可查异常&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可查异常&lt;/strong&gt; 也称之为编译器要求必须处理的异常，一般编译器都会检查他，出现这类异常要么用捕获他，要么抛出他，总之必须处理他。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不可查异常&lt;/strong&gt; 编译器没法检查的，必须靠程序员去主动检查，然后处理掉他。&lt;/p&gt;
&lt;p&gt;分类的方法不是很重要，怎样分取决于你处于某种情况下，最终都是要明白这些异常，并处理它。&lt;/p&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;异常处理机制&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;上面基本都明白了java异常是什么，以及有哪些异常，下面我们就来聊聊用什么样的机制去处理这些异常。&lt;/p&gt;
&lt;p&gt;八字方针 &lt;strong&gt;抛出异常，捕捉异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;throw 语句用于&lt;strong&gt;拋出&lt;/strong&gt;异常，throws 语句用于声明可能会出现的异常。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt;  Integer &lt;span class=&quot;hljs-title&quot;&gt;division&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (y == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArithmeticException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;抛出算术异常&quot;&lt;/span&gt;); &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x / y;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;throws抛出异常的规则：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1) 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。&lt;/p&gt;
&lt;p&gt;2）必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误&lt;/p&gt;
&lt;p&gt;3)仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。&lt;/p&gt;
&lt;p&gt;4）调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。&lt;/p&gt;
&lt;p&gt;java采用try-catch-finally语句来对异常进行&lt;strong&gt;捕获&lt;/strong&gt;并处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;{&lt;br/&gt;}&lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception e){&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;{&lt;br/&gt;}&lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception e){&lt;br/&gt;}&lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这语法大家应该在熟悉不过了，算了，龙叔还是啰嗦一遍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;try语句块&lt;/strong&gt;：该语句块中是程序正常情况下应该要完成的功能，而这些代码中可能会产生异常，其后面的catch语句块就是用来捕获并处理这些异常的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;catch语句块&lt;/strong&gt;：该语句块用来捕获并处理try语句块中产生的异常。&lt;/p&gt;
&lt;p&gt;每个catch语句块声明其能处理的一种特定类型的异常，catch后面的括号中就是该特定类型的异常。&lt;/p&gt;
&lt;p&gt;在Java7以前，每个catch语句块只能捕获一种异常，从Java7开始就支持一个catch捕获多种异常，多个异常之间用&lt;code&gt;|&lt;/code&gt;隔开。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(Exception1 | Exception2 |... | Exception_n e1){&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;finally块&lt;/strong&gt;：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。&lt;/p&gt;
&lt;p&gt;在以下4种特殊情况下，finally块不会被执行：&lt;/p&gt;
&lt;p&gt;1）在finally语句块中发生了异常。&lt;br/&gt;2）在前面的代码中用了System.exit()退出程序。&lt;br/&gt;3）程序所在的线程死亡。&lt;br/&gt;4）关闭CPU。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;try、catch、finally语句块的执行顺序:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1gix7gqud61j30vz0u0q94.jpg&quot; alt=&quot;java异常处理执行顺序&quot; title=&quot;java异常处理执行顺序&quot;/&gt;java异常处理执行顺序
&lt;p&gt;到这里大家基本明白了异常怎么来的，怎么处理的，接下来说一个常见的&lt;strong&gt;异常屏蔽问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一般情况下都是try中进行捕捉可能出现的异常，catch对异常进行处理，finally中进行一些资源关闭工作。&lt;/p&gt;
&lt;p&gt;正常情况倒也没啥说的，但咋就怕异常情况啊。&lt;/p&gt;
&lt;img src=&quot;https://i01piccdn.sogoucdn.com/5ee4b20de89884b5&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(Exception1 | Exception2 |... | Exception_n e1){&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt;{&lt;br/&gt;in.close();&lt;br/&gt;out.close();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是日常都这么写，看起来蛮正常的。&lt;/p&gt;
&lt;p&gt;如果我们的finally语句块中也抛出异常，会怎么办？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Integer &lt;span class=&quot;hljs-title&quot;&gt;division&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x/y;&lt;br/&gt;}&lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (ArithmeticException e){&lt;br/&gt;System.out.println(e.getMessage());&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArithmeticException(&lt;span class=&quot;hljs-string&quot;&gt;&quot;算术异常&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;释放资源&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Exception(&lt;span class=&quot;hljs-string&quot;&gt;&quot;释放资源异常&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如这段代码，本意是想抛出&lt;strong&gt;算术运算异常&lt;/strong&gt; ，结果抛出了&lt;strong&gt;释放资源异常&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于异常信息的丢失，异常屏蔽可能会导致某些bug变得极其难以发现，会让你加班加到心态崩溃的。&lt;/p&gt;
&lt;p&gt;这就是&lt;strong&gt;屏蔽异常&lt;/strong&gt;，如何解决这种屏蔽异常？&lt;/p&gt;
&lt;p&gt;有人看了上面的代码，又发现了另一个问题。try中有return语句，finally语句还会不会执行？&lt;/p&gt;
&lt;p&gt;这个问题很好，答案是&lt;strong&gt;会执行，并且在方法返回调用者前执行&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;h-4&quot;&gt;&lt;span&gt;解决屏蔽异常问题&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;Java 1.7中新增的try-with-resource语法糖来很好的解决这种因为关闭资源引起的异常屏蔽问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testExcep&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;BufferedInputStream in = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;BufferedOutputStream out = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;in = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BufferedInputStream(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; FileInputStream(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;hljs-string&quot;&gt;&quot;in.txt&quot;&lt;/span&gt;)));&lt;br/&gt;out = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BufferedOutputStream(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; FileOutputStream(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;hljs-string&quot;&gt;&quot;out.txt&quot;&lt;/span&gt;)));&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (in != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;in.close();&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (out != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;out.close();&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了释放资源，我们不得不这样写。但当我们熟悉try-with-resource语法，我们可以这样写。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; (BufferedInputStream in = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BufferedInputStream(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; FileInputStream(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;hljs-string&quot;&gt;&quot;in.txt&quot;&lt;/span&gt;)));&lt;br/&gt;BufferedOutputStream out = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BufferedOutputStream(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; FileOutputStream(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;hljs-string&quot;&gt;&quot;out.txt&quot;&lt;/span&gt;)))) {&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在try子句中能创建一个资源对象，当程序的执行完try-catch之后，运行环境自动关闭资源。&lt;/p&gt;
&lt;p&gt;代码写起来简洁，也会解决掉&lt;strong&gt;屏蔽异常问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然也要注意，在使用try-with-resource的过程中，一定需要了解资源的&lt;code&gt;close&lt;/code&gt;方法内部的实现逻辑。否则还是可能会导致资源泄露。&lt;/p&gt;
&lt;p&gt;怎么样，是不是很简单呢？学会了我们一起去装逼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/bmiddle/ceeb653ejw1fbhv5w6d2lj204304kdfs.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;h-5&quot;&gt;&lt;span&gt;常见异常问题&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;算术异常类：ArithmeticExecption&lt;/p&gt;
&lt;p&gt;空指针异常类：NullPointerException&lt;/p&gt;
&lt;p&gt;类型强制转换异常：ClassCastException&lt;/p&gt;
&lt;p&gt;数组负下标异常：NegativeArrayException&lt;/p&gt;
&lt;p&gt;数组下标越界异常：ArrayIndexOutOfBoundsException&lt;/p&gt;
&lt;p&gt;文件已结束异常：EOFException&lt;/p&gt;
&lt;p&gt;文件未找到异常：FileNotFoundException&lt;/p&gt;
&lt;p&gt;字符串转换为数字异常：NumberFormatException&lt;/p&gt;
&lt;p&gt;操作数据库异常：SQLException&lt;/p&gt;
&lt;p&gt;输入输出异常：IOException&lt;/p&gt;
&lt;p&gt;方法未找到异常：NoSuchMethodException&lt;/p&gt;
&lt;p&gt;这些都是非常常见的异常，当然还有一些其他异常，大家要在日常工作中及时总结，写到你的&lt;strong&gt;小本本&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;今天的内容就到这里了，有帮助记得&lt;strong&gt;点个赞&lt;/strong&gt;👍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://files.cnblogs.com/files/Qian123/rabbit.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我是龙叔，我们下期见✌️。&lt;/p&gt;
</description>
<pubDate>Fri, 25 Sep 2020 00:40:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>絮叨 因为程序异常处理问题，就在前几天龙叔的服务挂了几秒钟。 完了，马上季度末打绩效，竟然在这里翻车了，心如刀绞啊。 虽然没有影响到用户体验，但是找到问题并解决掉问题是工程师日常追求之一。 作为一个优</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/13728074.html</dc:identifier>
</item>
<item>
<title>在市值破万亿美元的公司工作，是一种怎样的体验？ - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13728050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13728050.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;这里是《齐姐聊大厂》系列的第 7 篇&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;（前 6 篇见文末）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;每周五早上 8 点，与你唠唠大厂的那些事。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小齐说：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;8 月 19 日，苹果公司股价飙升至 468 美元，总市值首次超过 2 万亿美元。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然疫情影响了苹果的线下零售，但是第三季度营业额高达 596.9 亿美元，远高于市场对它的预期。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一代苹果发布会，我看过不下于五遍。一方面是惊叹于当之无愧的革命性产品，改变了世界的产品，也改变了几十亿人的生活方式；另一方面是被乔帮主的魅力所折服，毕竟我是听过十遍乔帮主在斯坦福大学演讲的人。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们只谈产品和技术，并不代表任何其他立场。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天有幸请到博士大佬 littlelab，分享他在苹果公司工作的体验，让我们一起来感受下吧～&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;离开苹果有一段时间了，感觉还是很怀念那段工作经历，如果不是不同的职业道路选择，我想自己应该还在那个组，只是现在写这篇文章的是别人，而读者是我。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是毕业后的第一份工作，对于一个刚从火坑专业中挣扎出来的 PhD 来说，拿到一份优厚的薪水，已经感激涕零。虽然到了湾区后，听到其它公司的薪酬大开眼界，但是想想自己顺利的入职经历，依然有种对公司的感动。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日子一天天过去，头半年很有意思，虽然辛苦，但是学到很多东西。因为每天都在接触新事物，每天都在认识新人，所以很喜欢上班。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组里中国人很多，大家中午一起吃饭。我老板特别能讲，有段时间最喜欢听他在午饭的时候吹牛，一吹能吹一个小时。然后大家再回去，打杯咖啡， 在自己的小隔间里忙碌起来。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gj2i9xst8gj31900u0x6t.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过了一年的时间，渐渐开始关心自己的职业发展，开始想到 3 年后的自己，想到 5 年后的自己，也开始关心起周围人的履历。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;苹果能人太多，很多 manager 都是某个领域的大牛或者小牛，有的还有几本书。不少领军人物已经到了白发苍苍的年纪，被苹果从其它公司挖过来。有的过来当一方大员开疆拓土，有的过来组建团队管理下属，也有过来养老的，写写 spec，但依然像尊神一样让人仰止。&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Spec: specifications，对产品或者协议的指标规定，一般在设计新的协议时会出现，往往由一些领域里有影响力的公司牵头，组织专家制定。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的小 manager 来苹果五年多了，从业也十多年了，之前还收获了很多奖项，小到 DesignCon 的 best paper，大到其它公司发给他的终身成就奖，大大小小都摆在办公室里。因为从小来美国，英文说的和美国人没区别，project meeting 上经常舌战群雄。&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;DesignCon 是电路板和电磁仿真领域的工业界的重要会议，很多公司会上去发布新的技术。能够拿到 best paper 这个奖项的很少。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过他也等五年才升上 manager。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他的上司大 manager 更是著作加身，不知道他在苹果工作多久了，到他那个级别，已经需要把一些精力放到政治斗争上了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;五年是个不短的时间，然而五年不是向上升迁的决定条件，只是必要条件而已。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组里的人每个都兢兢业业，做技术报告比 PhD 的答辩论文还仔细。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也有不少五年多还是 IC 的，不是技术不行，有可能是语言吧，也有可能是年龄太轻，当然更重要的是因为没有那么多职位。&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;IC: Individual Contributor，不管人的职位都叫 IC，和 manager 相对。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我就这样安心的工作，也许工作个十几年，我也能学到顶尖技术，虽然可能还是个 IC。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;苹果我长期还是看好的，虽然大家诟病它表现出来的创新力，但那只是冰山一角。但我也能看到未来自己日复一日的生活，正如每天和我一起吃饭的 senior engineer 一样，平静和充实。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里，绝大部分人的职业声誉都将从此被抹去，因为你不能给外面做报告，不能发表论文，不能积攒自己在业界的影响力。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在苹果可能很多人都认识你，出了苹果也许一个人都不认识你。那时的我就像湾区千千万万的中年工程师一样，默默的为公司贡献着自己的青春和潜力。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而年轻人就是这样不知足，想折腾。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前后组里走了好几个年轻的 IC，我也是其中之一。大家去了不同的公司，不同的行业，不同的国家。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个人都有自己独特的追求，但若问我们离职有什么共同的原因，我想不为待遇，只为一颗对得起青春的躁动的心吧。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gj2i9hatezj31400u0k6r.jpg&quot; alt=&quot;&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小齐说：非常感谢 littlelab 的分享，因为苹果对保密非常看重，所以虽然已经离职了，博士也不便多说，还希望大家理解。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实身边能加入苹果的还是很少的，原因之一是苹果的面试难度不亚于谷歌，之二是苹果基本不招应届生，更多偏向于有工作经验的或者博士。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文已收录至我的 Github 上：&lt;code&gt;https://github.com/xiaoqi6666/NYCSDE&lt;/code&gt;，这个 Github 汇总了我所有的文章和资料，之后也会一直更新和维护。点击阅读原文即可直达，&lt;strong&gt;还希望大家帮忙点个 &lt;code&gt;Star&lt;/code&gt;&lt;/strong&gt;，你们的支持和认可，就是我创作的最大动力！&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后呢，附上周一&lt;a href=&quot;https://mp.weixin.qq.com/s/FkJj7X0uNG1pbsZL0Wjhkg&quot;&gt;线程池&lt;/a&gt;这篇文章文末的送书中奖名单：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;二三&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;jonyare&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;冯煜&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;😪&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;🦋&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恭喜以上 5 位同学啦～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有中奖的同学也不要灰心，每个月都会有至少一次的送书活动，积极互动混脸熟都会有的。感谢大家的支持，我们下期见！&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gj2ipltusej30u00u07ki.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;往期《齐姐聊大厂》文章&lt;/strong&gt;：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每周五早上 8 点，公众号首发。&lt;/p&gt;
</description>
<pubDate>Fri, 25 Sep 2020 00:30:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>这里是《齐姐聊大厂》系列的第 7 篇 （前 6 篇见文末） 每周五早上 8 点，与你唠唠大厂的那些事。 小齐说： 8 月 19 日，苹果公司股价飙升至 468 美元，总市值首次超过 2 万亿美元。 虽</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13728050.html</dc:identifier>
</item>
<item>
<title>Combine 框架，从0到1  —— 5.Combine 提供的发布者(Publishers) - Ficow</title>
<link>http://www.cnblogs.com/ficow/p/13728001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ficow/p/13728001.html</guid>
<description>
&lt;p&gt;本文首发于 &lt;a href=&quot;https://ficowshen.com&quot;&gt;Ficow Shen's Blog&lt;/a&gt;，原文地址： &lt;a href=&quot;https://blog.ficowshen.com/page/post/21&quot;&gt;Combine 框架，从0到1 —— 5.Combine 提供的发布者(Publishers)&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;内容概览&quot;&gt;内容概览&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;Just&lt;/li&gt;
&lt;li&gt;Future&lt;/li&gt;
&lt;li&gt;Deferred&lt;/li&gt;
&lt;li&gt;Empty&lt;/li&gt;
&lt;li&gt;Publishers.Sequence&lt;/li&gt;
&lt;li&gt;Fail&lt;/li&gt;
&lt;li&gt;Record&lt;/li&gt;
&lt;li&gt;Share&lt;/li&gt;
&lt;li&gt;Multicast&lt;/li&gt;
&lt;li&gt;ObservableObject&lt;/li&gt;
&lt;li&gt;@Published&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;正所谓，工欲善其事，必先利其器。在开始使用 &lt;code&gt;Combine&lt;/code&gt; 进行响应式编程之前，建议您先了解 &lt;code&gt;Combine&lt;/code&gt; 为您提供的各种发布者(Publishers)、操作符(Operators)、订阅者(Subscribers)。合理地选择符合需求的 &lt;code&gt;Combine&lt;/code&gt; 发布者，可以大幅度地提升您的开发效率！&lt;/p&gt;
&lt;p&gt;这些都是 &lt;code&gt;Combine&lt;/code&gt; 为我们提供的发布者：&lt;br/&gt;&lt;code&gt;Just&lt;/code&gt;，&lt;code&gt;Future&lt;/code&gt;，&lt;code&gt;Deferred&lt;/code&gt;，&lt;code&gt;Empty&lt;/code&gt;，&lt;code&gt;Publishers.Sequence&lt;/code&gt;，&lt;code&gt;Fail&lt;/code&gt;，&lt;code&gt;Record&lt;/code&gt;，&lt;code&gt;Share&lt;/code&gt;，&lt;code&gt;Multicast&lt;/code&gt;，&lt;code&gt;ObservableObject&lt;/code&gt;，&lt;code&gt;@Published&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来的几分钟，让我们把它们各个击破！&lt;/p&gt;

&lt;p&gt;请注意，后续内容中出现的 &lt;code&gt;cancellables&lt;/code&gt; 全部由这个类的实例提供 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;final class CombinePublishersDemo {

    private var cancellables = Set&amp;lt;AnyCancellable&amp;gt;()

}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;示例代码 Github 仓库：&lt;a href=&quot;https://github.com/FicowShen/Ficow-Combine-SwiftUI/blob/master/CombineDemo/CombineDemo/CombinePublishersDemo.swift&quot;&gt;CombinePublishersDemo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;just&quot;&gt;Just&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/just&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Just&lt;/code&gt; 向每个订阅者只发送单个值，然后结束。它的失败类型为 &lt;code&gt;Never&lt;/code&gt;，也就是不能失败。 示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;func just() {
        Just(1) // 直接发送1
            .sink { value in
                // 输出：just() 1
                print(#function, value)
            }
            .store(in: &amp;amp;cancellables)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;just() 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Just&lt;/code&gt; 常被用在错误处理中，在捕获异常后发送备用值。 示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;func just2() {
        // 使用 Fail 发送失败
        Fail(error: NSError(domain: &quot;&quot;, code: 0, userInfo: nil))
            .catch { _ in
                // 捕获错误，返回 Just(3)
                return Just(3)
            }
            .sink { value in
                // 输出：just2() 3
                print(#function, value)
            }
            .store(in: &amp;amp;cancellables)
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;just2() 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;future&quot;&gt;Future&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/future&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 使用一个闭包来进行初始化，最终这个闭包将执行传入的一个闭包参数(promise)来发送&lt;strong&gt;单个值&lt;/strong&gt;或者&lt;strong&gt;失败&lt;/strong&gt;。请不要使用 &lt;code&gt;Future&lt;/code&gt; 发送多个值。&lt;code&gt;PassthroughSubject&lt;/code&gt;, &lt;code&gt;CurrentValueSubject&lt;/code&gt; 或者 &lt;code&gt;Deferred&lt;/code&gt; 会是更好的选择。&lt;/p&gt;
&lt;p&gt;请注意，&lt;code&gt;Future&lt;/code&gt; 不会等待订阅者发送需求，它会&lt;strong&gt;在被创建时就立刻异步执行&lt;/strong&gt;这个初始化时传入的闭包！如果你需要等待订阅者发送需求时才执行这个闭包，请使用 &lt;code&gt;Deferred&lt;/code&gt;。如果你需要重复执行这个闭包，也请使用 &lt;code&gt;Deferred&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;func future() {
        Future&amp;lt;Int, Never&amp;gt; { promise in
                        // 延时1秒
            DispatchQueue.global().asyncAfter(deadline: .now() + 1) {
                promise(.success(2))
            }
        }
        .sink { value in
            // 输出：future() 2
            print(#function, value)
        }
        .store(in: &amp;amp;cancellables)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;future() 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;更常见的用法是将 &lt;code&gt;Future&lt;/code&gt; 作为一个任务函数的返回值，让具体任务的执行代码与订阅代码分离：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;private func bigTask() -&amp;gt; Future&amp;lt;Int, Error&amp;gt; {
        return Future() { promise in
            // 模拟耗时操作
            sleep(1)
            guard Bool.random() else {
                promise(.failure(NSError(domain: &quot;com.ficowshen.blog&quot;, code: -1, userInfo: [NSLocalizedDescriptionKey: &quot;task failed&quot;])))
                return
            }
            promise(.success(3))
        }
    }

func future2() {
        bigTask()
            .subscribe(on: DispatchQueue.global())
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { completion in
                switch completion {
                case .finished:
                    // 输出：future2() finished
                    print(#function, &quot;finished&quot;)
                case .failure(let error):
                    // 输出：future2() Error Domain=com.ficowshen.blog Code=-1 &quot;task failed&quot; UserInfo={NSLocalizedDescription=task failed}
                    print(#function, error)
                }
            }, receiveValue: { value in
                // 输出：future2() 3
                print(#function, value)
            })
            .store(in: &amp;amp;cancellables)
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容由 &lt;code&gt;Bool.random()&lt;/code&gt; 决定，可能是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;future2() Error Domain=com.ficowshen.blog Code=-1 &quot;task failed&quot; UserInfo={NSLocalizedDescription=task failed}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也可能是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;future2() 3&lt;br/&gt;future2() finished&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;deferred&quot;&gt;Deferred&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/deferred&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Deferred&lt;/code&gt; 使用一个生成发布者的闭包来完成初始化，这个闭包会在订阅者执行订阅操作时才执行。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;func deferred() {
        let deferredPublisher = Deferred&amp;lt;AnyPublisher&amp;lt;Bool, Error&amp;gt;&amp;gt; {
            // 在订阅之后才会执行
            print(Date(), &quot;Future inside Deferred created&quot;)
            return Future&amp;lt;Bool, Error&amp;gt; { promise in
                promise(.success(true))
            }.eraseToAnyPublisher()
        }.eraseToAnyPublisher()

        print(Date(), &quot;Deferred created&quot;)

        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            // 延迟1秒后进行订阅
            deferredPublisher
                .sink(receiveCompletion: { completion in
                    print(Date(), &quot;Deferred receiveCompletion:&quot;, completion)
                }, receiveValue: { value in
                    print(Date(), &quot;Deferred receiveValue:&quot;, value)
                })
                .store(in: &amp;amp;self.cancellables)
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上面的函数，输出内容如下(请注意观察输出的时间，延时1秒)：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;2020-09-08 23:44:35 +0000 Deferred created&lt;br/&gt;2020-09-08 23:44:36 +0000 Future inside Deferred created&lt;br/&gt;2020-09-08 23:44:36 +0000 Deferred receiveValue: true&lt;br/&gt;2020-09-08 23:44:36 +0000 Deferred receiveCompletion: finished&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;empty&quot;&gt;Empty&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/empty&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Empty&lt;/code&gt; 是一个从不发布任何值的发布者，可以选择立即完成(&lt;code&gt;Empty()&lt;/code&gt; 或者 &lt;code&gt;Empty(completeImmediately: true)&lt;/code&gt;)。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以使用 &lt;code&gt;Empty(completeImmediately: false)&lt;/code&gt; 创建一个&lt;strong&gt;从不&lt;/strong&gt;发布者（一个从不发送值，也从不完成或失败的发布者）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Empty&lt;/code&gt; 常用于错误处理。当错误发生时，如果你不想发送错误，可以用 &lt;code&gt;Empty&lt;/code&gt; 来发送完成。&lt;/p&gt;

&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;func empty() {
        Empty&amp;lt;Never, Error&amp;gt;() // 或者 Empty&amp;lt;Never, Error&amp;gt;(completeImmediately: true)
            .sink(receiveCompletion: { completion in
                // 输出：empty() finished
                print(#function, completion)
            }, receiveValue: { _ in

            })
            .store(in: &amp;amp;self.cancellables)
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;empty() finished&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/publishers/sequence&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Publishers.Sequence&lt;/code&gt; 是发送一个元素序列的发布者，元素发送完毕时会自动发送完成。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;func sequence() {
        [1, 2, 3].publisher
            .sink(receiveCompletion: { completion in
                // 输出：sequence() finished
                print(#function, completion)
            }, receiveValue: { value in
                // 输出：sequence() 1
                // 输出：sequence() 2
                // 输出：sequence() 3
                print(#function, value)
            })
            .store(in: &amp;amp;self.cancellables)
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;sequence() 1&lt;br/&gt;sequence() 2&lt;br/&gt;sequence() 3&lt;br/&gt;sequence() finished&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;fail&quot;&gt;Fail&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/fail&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Fail&lt;/code&gt; 是一个以指定的错误终止序列的发布者。通常用于返回错误，比如：在校验参数缺失或错误等场景中，返回一个 &lt;code&gt;Fail&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;func fail() {
        Fail&amp;lt;Never, NSError&amp;gt;(error: NSError(domain: &quot;&quot;, code: 0, userInfo: nil))
            .sink(receiveCompletion: { completion in
                // 输出：fail() failure(Error Domain= Code=0 &quot;(null)&quot;)
                print(#function, completion)
            }, receiveValue: { _ in

            })
            .store(in: &amp;amp;cancellables)
    }
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;record&quot;&gt;Record&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/record&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Record&lt;/code&gt; 发布者允许录制一系列的输入和一个完成，录制之后再发送给每一个订阅者。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;func record() {
        Record&amp;lt;Int, Never&amp;gt; { record in
            record.receive(1)
            record.receive(2)
            record.receive(3)
            record.receive(completion: .finished)
        }
        .sink(receiveCompletion: { completion in
            // 输出：record() finished
            print(#function, completion)
        }, receiveValue: { value in
            // 输出：record() 1
            // 输出：record() 2
            // 输出：record() 3
            print(#function, value)
        })
        .store(in: &amp;amp;cancellables)
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;record() 1&lt;br/&gt;record() 2&lt;br/&gt;record() 3&lt;br/&gt;record() finished&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;share&quot;&gt;Share&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/publishers/share&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Share&lt;/code&gt; 发布者可以和多个订阅者共享上游发布者的输出。请注意，它和其他&lt;code&gt;值类型&lt;/code&gt;的发布者不一样，这是一个&lt;code&gt;引用类型&lt;/code&gt;的发布者！&lt;/p&gt;
&lt;p&gt;当您需要使用引用语义的发布者时，可以考虑使用这个类型。&lt;/p&gt;
&lt;p&gt;为了更好地理解 &lt;code&gt;Share&lt;/code&gt; 的意义和用途, 让我们先来观察没有 &lt;code&gt;Share&lt;/code&gt; 会出现什么问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;func withoutShare() {
        let deferred = Deferred&amp;lt;Future&amp;lt;Int, Never&amp;gt;&amp;gt; {
            print(&quot;creating Future&quot;)
            return Future&amp;lt;Int, Never&amp;gt; { promise in
                print(&quot;promise(.success(1))&quot;)
                promise(.success(1))
            }
        }
        
        deferred
            .print(&quot;1_&quot;)
            .sink(receiveCompletion: { completion in
                print(&quot;receiveCompletion1&quot;, completion)
            }, receiveValue: { value in
                print(&quot;receiveValue1&quot;, value)
            })
            .store(in: &amp;amp;cancellables)
        
        deferred
            .print(&quot;2_&quot;)
            .sink(receiveCompletion: { completion in
                print(&quot;receiveCompletion2&quot;, completion)
            }, receiveValue: { value in
                print(&quot;receiveValue2&quot;, value)
            })
            .store(in: &amp;amp;cancellables)
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;creating Future&lt;br/&gt;promise(.success(1))&lt;br/&gt;1_: receive subscription: (Future)&lt;br/&gt;1_: request unlimited&lt;br/&gt;1_: receive value: (1)&lt;br/&gt;receiveValue1 1&lt;br/&gt;1_: receive finished&lt;br/&gt;receiveCompletion1 finished&lt;br/&gt;creating Future&lt;br/&gt;promise(.success(1))&lt;br/&gt;2_: receive subscription: (Future)&lt;br/&gt;2_: request unlimited&lt;br/&gt;2_: receive value: (1)&lt;br/&gt;receiveValue2 1&lt;br/&gt;2_: receive finished&lt;br/&gt;receiveCompletion2 finished&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过观察输出内容，我们可以发现 Deferred 和 Future 部分的代码&lt;code&gt;执行了两次&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;接下来，我们使用 &lt;code&gt;Share&lt;/code&gt; 来尝试解决这个问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;func withShare() {
        let deferred = Deferred&amp;lt;Future&amp;lt;Int, Never&amp;gt;&amp;gt; {
            print(&quot;creating Future&quot;)
            return Future&amp;lt;Int, Never&amp;gt; { promise in
                print(&quot;promise(.success(1))&quot;)
                promise(.success(1))
            }
        }
        
        let sharedPublisher = deferred
            .print(&quot;0_&quot;)
            .share()
        
        sharedPublisher
            .print(&quot;1_&quot;)
            .sink(receiveCompletion: { completion in
                print(&quot;receiveCompletion1&quot;, completion)
            }, receiveValue: { value in
                print(&quot;receiveValue1&quot;, value)
            })
            .store(in: &amp;amp;cancellables)
        
        sharedPublisher
            .print(&quot;2_&quot;)
            .sink(receiveCompletion: { completion in
                print(&quot;receiveCompletion2&quot;, completion)
            }, receiveValue: { value in
                print(&quot;receiveValue2&quot;, value)
            })
            .store(in: &amp;amp;cancellables)
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1_: receive subscription: (Multicast)&lt;br/&gt;1_: request unlimited&lt;br/&gt;creating Future&lt;br/&gt;promise(.success(1))&lt;br/&gt;0_: receive subscription: (Future)&lt;br/&gt;0_: request unlimited&lt;br/&gt;0_: receive value: (1)&lt;br/&gt;1_: receive value: (1)&lt;br/&gt;receiveValue1 1&lt;br/&gt;0_: receive finished&lt;br/&gt;1_: receive finished&lt;br/&gt;receiveCompletion1 finished&lt;br/&gt;2_: receive subscription: (Multicast)&lt;br/&gt;2_: request unlimited&lt;br/&gt;2_: receive finished&lt;br/&gt;receiveCompletion2 finished&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;咦，Deferred 和 Future 部分执行了两次的问题解决了，但是&lt;code&gt;出现了另一个问题&lt;/code&gt;！第二个订阅者没有收到值，只收到了完成！！？？&lt;/p&gt;
&lt;p&gt;而且，仔细观察输出的内容，&lt;code&gt;Multicast&lt;/code&gt; 十分引人注目！&lt;/p&gt;
&lt;p&gt;原来，根据官方文档的解释，&lt;code&gt;Share&lt;/code&gt; 其实是 &lt;code&gt;Multicast&lt;/code&gt; 发布者和 &lt;code&gt;PassthroughSubject&lt;/code&gt; 发布者的结合，而且它会隐式调用 &lt;code&gt;autoconnect()&lt;/code&gt;。&lt;br/&gt;也就是说，在订阅操作发生后，&lt;code&gt;Share&lt;/code&gt; 就会开始发送内容。这样也就导致了后续的订阅者无法收到之前就已经发布的值。&lt;/p&gt;
&lt;p&gt;怎么解决这个问题？&lt;/p&gt;
&lt;p&gt;回顾 &lt;a href=&quot;https://blog.ficowshen.com/page/post/13&quot;&gt;Combine 框架，从0到1 —— 2.通过 ConnectablePublisher 控制何时发布&lt;/a&gt; 的内容，我们可以通过自行调用 &lt;code&gt;connect()&lt;/code&gt; 来解决这个问题。&lt;/p&gt;
&lt;p&gt;这是调整后的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;func withShareAndConnectable() {
        let deferred = Deferred&amp;lt;Future&amp;lt;Int, Never&amp;gt;&amp;gt; {
            print(&quot;creating Future&quot;)
            return Future&amp;lt;Int, Never&amp;gt; { promise in
                print(&quot;promise(.success(1))&quot;)
                promise(.success(1))
            }
        }
        
        let sharedPublisher = deferred
            .print(&quot;0_&quot;)
            .share()
            .makeConnectable() // 自行决定发布者何时开始发送订阅元素给订阅者
        
        sharedPublisher
            .print(&quot;1_&quot;)
            .sink(receiveCompletion: { completion in
                print(&quot;receiveCompletion1&quot;, completion)
            }, receiveValue: { value in
                print(&quot;receiveValue1&quot;, value)
            })
            .store(in: &amp;amp;cancellables)
        
        sharedPublisher
            .print(&quot;2_&quot;)
            .sink(receiveCompletion: { completion in
                print(&quot;receiveCompletion2&quot;, completion)
            }, receiveValue: { value in
                print(&quot;receiveValue2&quot;, value)
            })
            .store(in: &amp;amp;cancellables)
        
        sharedPublisher
            .connect() // 让发布者开始发送内容
            .store(in: &amp;amp;cancellables)
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只需要在 &lt;code&gt;share()&lt;/code&gt; 之后调用 &lt;code&gt;makeConnectable()&lt;/code&gt;，我们即可夺回控制权！在所有订阅者准备就绪之后，通过调用 &lt;code&gt;connect()&lt;/code&gt; 让发布者开始发送内容。&lt;/p&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1_: receive subscription: (Multicast)&lt;br/&gt;1_: request unlimited&lt;br/&gt;2_: receive subscription: (Multicast)&lt;br/&gt;2_: request unlimited&lt;br/&gt;creating Future&lt;br/&gt;promise(.success(1))&lt;br/&gt;0_: receive subscription: (Future)&lt;br/&gt;0_: request unlimited&lt;br/&gt;0_: receive value: (1)&lt;br/&gt;1_: receive value: (1)&lt;br/&gt;receiveValue1 1&lt;br/&gt;2_: receive value: (1)&lt;br/&gt;receiveValue2 1&lt;br/&gt;0_: receive finished&lt;br/&gt;1_: receive finished&lt;br/&gt;receiveCompletion1 finished&lt;br/&gt;2_: receive finished&lt;br/&gt;receiveCompletion2 finished&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，Deferred 和 Future 部分的代码只执行一次，两个订阅者也都收到了值和完成。&lt;/p&gt;
&lt;p&gt;除此之外，我们也可以使用 &lt;code&gt;Multicast&lt;/code&gt; 解决这个问题。&lt;/p&gt;

&lt;h2 id=&quot;multicast&quot;&gt;Multicast&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/publishers/multicast&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Multicast&lt;/code&gt; 发布者使用一个 &lt;code&gt;Subject&lt;/code&gt; 向多个订阅者发送元素。和 &lt;code&gt;Share&lt;/code&gt; 一样，这也是一个引用类型的发布者。在使用多个订阅者进行订阅时，它们可以有效地保证上游发布者不重复执行繁重的耗时操作。&lt;/p&gt;
&lt;p&gt;而且 &lt;code&gt;Multicast&lt;/code&gt; 是一个 &lt;code&gt;ConnectablePublisher&lt;/code&gt;，所以我们需要在订阅者准备就绪之后去手动调用 &lt;code&gt;connect()&lt;/code&gt; 方法，然后订阅者才能收到上游发布者发送的元素。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;func multicast() {
        let multicastSubject = PassthroughSubject&amp;lt;Int, Never&amp;gt;()
        let deferred = Deferred&amp;lt;Future&amp;lt;Int, Never&amp;gt;&amp;gt; {
            print(&quot;creating Future&quot;)
            return Future&amp;lt;Int, Never&amp;gt; { promise in
                print(&quot;promise(.success(1))&quot;)
                promise(.success(1))
            }
        }

        let sharedPublisher = deferred
            .print(&quot;0_&quot;)
            .multicast(subject: multicastSubject)
            
        sharedPublisher
            .print(&quot;1_&quot;)
            .sink(receiveCompletion: { completion in
                print(&quot;receiveCompletion1&quot;, completion)
            }, receiveValue: { value in
                print(&quot;receiveValue1&quot;, value)
            })
            .store(in: &amp;amp;cancellables)
        
        sharedPublisher
            .print(&quot;2_&quot;)
            .sink(receiveCompletion: { completion in
                print(&quot;receiveCompletion2&quot;, completion)
            }, receiveValue: { value in
                print(&quot;receiveValue2&quot;, value)
            })
            .store(in: &amp;amp;cancellables)
        
        sharedPublisher
            .connect()
            .store(in: &amp;amp;cancellables)
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1_: receive subscription: (Multicast)&lt;br/&gt;1_: request unlimited&lt;br/&gt;2_: receive subscription: (Multicast)&lt;br/&gt;2_: request unlimited&lt;br/&gt;creating Future&lt;br/&gt;promise(.success(1))&lt;br/&gt;0_: receive subscription: (Future)&lt;br/&gt;0_: request unlimited&lt;br/&gt;0_: receive value: (1)&lt;br/&gt;1_: receive value: (1)&lt;br/&gt;receiveValue1 1&lt;br/&gt;2_: receive value: (1)&lt;br/&gt;receiveValue2 1&lt;br/&gt;0_: receive finished&lt;br/&gt;1_: receive finished&lt;br/&gt;receiveCompletion1 finished&lt;br/&gt;2_: receive finished&lt;br/&gt;receiveCompletion2 finished&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;observableobject&quot;&gt;ObservableObject&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/observableobject&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ObservableObject&lt;/code&gt; 是具有发布者的一种对象，该对象在更改对象之前发出变动元素。常用在 &lt;code&gt;SwiftUI&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;遵循 &lt;code&gt;ObservableObject&lt;/code&gt; 协议的对象会自动生成一个 &lt;code&gt;objectWillChange&lt;/code&gt; 发布者，这个发布者会在这个对象的 &lt;code&gt;@Published&lt;/code&gt; 属性发生变动时发送 &lt;code&gt;变动之前的旧值&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;来自官网文档的示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;class Contact: ObservableObject {
    @Published var name: String
    @Published var age: Int


    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }


    func haveBirthday() -&amp;gt; Int {
        age += 1
        return age
    }
}


let john = Contact(name: &quot;John Appleseed&quot;, age: 24)
john.objectWillChange
    .sink { _ in
        print(&quot;\(john.age) will change&quot;)
        }
        .store(in: &amp;amp;cancellables)

print(john.haveBirthday())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;24 will change&lt;br/&gt;25&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;published&quot;&gt;@Published&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/combine/published&quot;&gt;官网文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@Published&lt;/code&gt; 是一个属性包装器(&lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/Properties.html#ID617&quot;&gt;@propertyWrapper&lt;/a&gt;)，它可以为任何属性添加一个 &lt;code&gt;Combine&lt;/code&gt; 发布者。常用在 &lt;code&gt;SwiftUI&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;请注意，&lt;code&gt;@Published&lt;/code&gt; 发布的是属性观察器 &lt;code&gt;willSet&lt;/code&gt; 中接收到的新值，但是这个属性当前的值还是旧值！观察下面的例子，可以帮助您理解这个重点。&lt;/p&gt;
&lt;p&gt;来自官网文档的示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-swift&quot;&gt;class Weather {
    @Published var temperature: Double
    init(temperature: Double) {
        self.temperature = temperature
    }
}

func published() {
        let weather = Weather(temperature: 20)
        weather
            .$temperature // 请注意这里的 $ 符号，通过 $ 操作符来访问发布者
            .sink() { value in
                print(&quot;Temperature before: \(weather.temperature)&quot;) // 属性中的值尚未改变
                print(&quot;Temperature now: \(value)&quot;) // 发布者发布的是新值
            }
            .store(in: &amp;amp;cancellables)
        weather.temperature = 25 // 请注意这里没有 $ 符号，访问的是被属性包装器包装起来的值
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出内容：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Temperature before: 20.0&lt;br/&gt;Temperature now: 20.0&lt;br/&gt;Temperature before: 20.0&lt;br/&gt;Temperature now: 25.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当 &lt;code&gt;sink&lt;/code&gt; 中收到新值 25.0 时，&lt;code&gt;weather.temperature&lt;/code&gt; 的值依然为 20.0。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;感谢 &lt;code&gt;Combine&lt;/code&gt; 为我们提供了这些发布者：&lt;br/&gt;Just，Future，Deferred，Empty，Publishers.Sequence，Fail，Record，Share，Multicast，ObservableObject，@Published&lt;/p&gt;
&lt;p&gt;虽然看起来有很多不同的发布者，而且使用起来也有颇多的注意事项，但是这些发布者无疑是大幅度地提升了我们进行响应式编程的效率。&lt;/p&gt;
&lt;p&gt;如果将 Combine 与 SwiftUI 结合在一起，我们就可以充分地享受声明式编程带来的易读、便利、高效以及优雅。&lt;br/&gt;不过，这就需要我们充分掌握 Combine 和 SwiftUI 中的基础知识和重难点。否则，一定会有很多坑在等着我们~&lt;/p&gt;
&lt;p&gt;最后，除了这些普通的 Publishers，Combine 还为我们提供了特殊的发布者 —— Subjects。&lt;/p&gt;
&lt;p&gt;请阅读：&lt;a href=&quot;https://blog.ficowshen.com/page/post/22&quot;&gt;Combine 框架，从0到1 —— 5.Combine 中的 Subjects&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考内容：&lt;br/&gt;&lt;a href=&quot;https://heckj.github.io/swiftui-notes/&quot;&gt;Using Combine&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://medium.com/jllnmercier/combine-share-and-multicast-dcd75fa7d9d6&quot;&gt;Combine — share() and multicast()&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 24 Sep 2020 23:45:00 +0000</pubDate>
<dc:creator>Ficow</dc:creator>
<og:description>本文首发于 Ficow Shen&amp;amp;#39;s Blog，原文地址： Combine 框架，从0到1 —— 5.Combine 提供的发布者(Publishers)。 内容概览 前言 Just</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ficow/p/13728001.html</dc:identifier>
</item>
<item>
<title>谷歌发布Flutter Alpha：支持Windows - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13727982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13727982.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072943149-635306570.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.5945945945946&quot;&gt;
&lt;p&gt;&lt;strong&gt;老孟导读&lt;/strong&gt;：Windows来了，Mac、Linux、Web还远吗？&lt;/p&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;https://medium.com/flutter/announcing-flutter-windows-alpha-33982cd0f433&quot;&gt;https://medium.com/flutter/announcing-flutter-windows-alpha-33982cd0f433&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们的使命是为开发人员提供一个开源，高生产率的框架，以便在任何平台上构建漂亮的本机应用程序。到目前为止，我们已经为Android和iOS提供了正式版本（stable releases），仅Google Play商店就提供了8个稳定版本和100,000多个应用。我们将继续扩大关注范围，包括Web，macOS和Linux等其他平台。今天，我们很高兴地宣布Flutter的另一个目标，即Flutter对Windows的Alpha版本的支持。&lt;/p&gt;
&lt;p&gt;Windows仍然是台式机和笔记本电脑设备的流行选择，Microsoft报告了超过&lt;a href=&quot;https://blogs.windows.com/windowsexperience/2020/03/16/windows-10-powering-the-world-with-1-billion-monthly-active-devices/&quot;&gt;十亿台运行Windows 10的活动设备&lt;/a&gt;。我们自己的统计数据显示，所有Flutter开发人员中有超过一半使用Windows，因此，它自然Flutter是的目标。本地桌面支持为Flutter开辟了许多激动人心的可能性，包括改进的开发人员工具，减少了新用户的负担，当然，应用程序可以通过单个代码库访问用户可能拥有的任何设备。&lt;/p&gt;

&lt;p&gt;如我们的&lt;a href=&quot;https://flutter.dev/docs/resources/architectural-overview&quot;&gt;架构概述中所述&lt;/a&gt;Flutter是一种跨平台的UI工具包，旨在允许在iOS和Android等操作系统之间重复使用代码，同时还允许应用程序直接与基础平台服务交互。目的是使开发人员能够交付在不同平台上感觉自然的高性能应用程序，在存在尽可能多的代码的同时，拥抱它们存在的差异。Flutter的核心是引擎，它支持所有Flutter应用程序所必需的。每当需要绘制新框架时，引擎负责对合成场景进行栅格化。它提供Flutter核心API的低级实现，包括图形，文本布局，文件和网络I / O，可访问性支持，插件体系结构以及Dart运行时和编译工具链。&lt;/p&gt;
&lt;p&gt;我们添加到Flutter的每个新平台都会通过新服务扩展核心框架，使其能够在该平台上发光。我们从使用Material Design以及基于触摸的，以移动设备为中心的用户界面开始在Android和iOS上开始，该界面旨在在两个移动平台上都达到像素完美。通过Web，Windows，macOS和Linux添加对台式机外形的支持，带来了一整套全新的服务，其中包括对输入侧的键盘，鼠标，鼠标滚轮和控制器的强大支持，以及在这些方面适应甚至工作得最好的小部件。 Web和桌面应用程序随附的更大的屏幕尺寸。&lt;/p&gt;
&lt;p&gt;此外，每个新平台不仅会影响Flutter框架和引擎，还会影响很多其他方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;工具链更新：&lt;/strong&gt;向CLI和IDE工具添加新目标（在本例中为Windows）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shell：&lt;/strong&gt;支持通过&lt;code&gt;WM_*&lt;/code&gt;消息处理Windows的输入和通过&lt;a href=&quot;https://opensource.google/projects/angle&quot;&gt;ANGLE的&lt;/a&gt;输出，使用&lt;a href=&quot;https://skia.org/&quot;&gt;斯基亚（Skia）&lt;/a&gt;以本机速度渲染到底层DirectX表面&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Runner：&lt;/strong&gt;每个项目都会获得针对受支持目标的Shell应用程序。对于Windows，这是一个Win32 / C ++程序，可加载Flutter代码并在运行时执行它。如果需要，可以在此处向应用程序添加本机代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插件：&lt;/strong&gt;插件是Dart代码和该插件支持的每个平台的本机代码的混合。需要为在Windows上Flutter应用程序中编译的每个插件添加该本地代码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此Alpha版本提供了坚实的基础，我们将在未来几个月中稳定该基础。借助对Windows 7及更高版本的支持，我们希望这可以为喜欢冒险的开发人员提供一些入门知识。&lt;/p&gt;

&lt;p&gt;要查看Flutter对Windows的支持，您可能想尝试一些我们创建的示例应用程序，这些应用程序在Windows上使用我们新增的支持可以很好地运行。第一个是Flokk应用程序，它是与&lt;a href=&quot;http://gskinner.com/&quot;&gt;gskinner.com&lt;/a&gt;的设计师和开发人员&lt;a href=&quot;http://gskinner.com/&quot;&gt;共同创建的&lt;/a&gt;。目的是通过创建创新的，精美的Flutter桌面应用程序来证明Flutter已准备好用于桌面。Flokk是一款可与您的真实Google Contacts数据配合使用并在GitHub和Twitter上显示联系人活动的应用程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072943692-1575130156.png&quot; alt=&quot;图片发布&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您想在Windows机器上使用Flokk应用程序，则可以&lt;a href=&quot;https://github.com/gskinnerTeam/Flokk/releases&quot;&gt;在GitHub上下载最新版本&lt;/a&gt;。如果您想了解gskinner如何构建此应用程序，请参阅其出色的博客文章：&lt;a href=&quot;https://blog.gskinner.com/archives/2020/09/flokk---how-we-built-a-desktop-app-using-flutter.html&quot;&gt;Flokk-我们如何使用Flutter构建桌面应用程序&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;此外，Flutter Gallery应用程序（我们用于Flutter的所有事物的展示应用程序）最近已完全重写，以增加对台式机尺寸的支持。这使我们能够检查它是否可以在&lt;a href=&quot;https://gallery.flutter.dev/&quot;&gt;Web&lt;/a&gt;以及Windows，macOS和Linux上正常运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072945500-2146664698.png&quot; alt=&quot;图片发布&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;库中的许多研究都展示了在使用Flutter设计自己的Windows应用程序时建议使用的不同应用程序风格的想法。当您找到自己喜欢的东西时，&lt;a href=&quot;https://github.com/flutter/gallery&quot;&gt;该代码可在GitHub上找到&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;根据&lt;a href=&quot;https://flutter.dev/docs/get-started/install/windows&quot;&gt;Windows安装说明&lt;/a&gt;开始安装Flutter SDK 。要定位Windows桌面，首先需要&lt;a href=&quot;https://flutter.dev/desktop#additional-windows-requirements&quot;&gt;安装Desktop docs中描述的工具&lt;/a&gt;。默认情况下，Flutter假定您正在构建生产软件，并且未配置为开发Windows应用程序。但是，可以从命令行轻松解决：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ flutter channel dev
$ flutter upgrade
$ flutter config --enable-windows-desktop
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一条命令将Flutter设置为使用实验质量的“ dev”通道（而不是默认的“ stable”通道）。这样，您就可以使用仍在Alpha中的平台支持，例如Windows。第二条命令下拉该通道上的最新位。第三个命令可在您的PC上进行Windows应用开发。&lt;/p&gt;
&lt;p&gt;设置好之后，每次使用&lt;a href=&quot;https://flutter.dev/docs/get-started/editor?tab=androidstudio&quot;&gt;Android Studio&lt;/a&gt;或&lt;a href=&quot;https://flutter.dev/docs/get-started/editor?tab=vscode&quot;&gt;Visual Studio Code&lt;/a&gt;的扩展支持，或者从命令行创建新的Flutter应用程序时，它都会创建一个Windows子文件夹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072946582-311534757.png&quot; alt=&quot;图片发布&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您感到好奇，请在Windows上运行默认应用程序，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072946860-59959155.png&quot; alt=&quot;图片发布&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，一旦创建了应用程序，构建该应用程序将创建一个发布模式的本机EXE文件以及必要的支持DLL。到那时，如果您想尝试在任何Windows 10计算机上运行新的Windows应用程序，即使没有安装Flutter的计算机，也可以按照&lt;a href=&quot;https://flutter.dev/desktop#distribution&quot;&gt;以下步骤压缩必要的文件&lt;/a&gt;并运行。&lt;/p&gt;

&lt;p&gt;即使我们刚刚发布Alpha版，Flutter社区也已经在为Windows插件进行开发。这里有一些：&lt;/p&gt;
&lt;p&gt;使用这些插件的好处是它们中的大多数还支持其他Flutter平台，这使您可以将应用定位到Android，iOS，Web等以及Windows。此外，虽然&lt;a href=&quot;http://pub.dev/&quot;&gt;pub.dev&lt;/a&gt;（Dart和Flutter的软件包管理器）上&lt;a href=&quot;http://pub.dev/&quot;&gt;约有&lt;/a&gt;三分之一的可用软件包是具有特定于平台的代码的插件，但大多数不是。例如，&lt;a href=&quot;https://pub.dev/flutter/favorites&quot;&gt;许多最高质量和最常用的软件包&lt;/a&gt;是Flutter Favorite程序的一部分，并且大多数都在Windows上运行。如果要查看在Windows上运行的软件包的完整列表，可以&lt;a href=&quot;https://pub.dev/flutter/packages?platform=windows&quot;&gt;在pub.dev上运行此查询&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果您想为Windows构建自己的插件，则可以。进入开发人员通道并为计算机启用Windows后，可以使用以下命令开始：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ flutter create --template plugin --platforms Windows hello_plugin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;届时，您将能够在插件项目中将Flutter代码添加到&lt;code&gt;lib&lt;/code&gt;子文件夹中，并将Windows代码添加到&lt;code&gt;windows&lt;/code&gt;子文件夹中。您将使用&lt;a href=&quot;https://flutter.dev/docs/development/platform-integration/platform-channels&quot;&gt;Platform Channels&lt;/a&gt;在两个堆栈之间进行通信，这实际上是Dart和C ++代码之间传递的消息。有关此示例的精心制作，&lt;a href=&quot;https://github.com/flutter/plugins/tree/master/packages/url_launcher/url_launcher_windows&quot;&gt;请参见url_launcher实现&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但是，平台通道并不是与Windows互操作的唯一选择。如果愿意，可以使用&lt;a href=&quot;https://flutter.dev/docs/development/platform-integration/c-interop&quot;&gt;Dart FFI（外部功能接口）&lt;/a&gt;加载库并调用C样式的API，例如Win32 API。与使用平台通道的url_launcher不同，path_provider插件是使用FFI实现的，如您在&lt;a href=&quot;https://github.com/flutter/plugins/tree/master/packages/path_provider/path_provider_windows&quot;&gt;GitHub repo中&lt;/a&gt;所见。FFI无需在Dart和C ++之间来回切换，而是允许您编写代码以直接导入所需的API。例如，以下是用于调用MessageBox API的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef MessageBoxNative = Int32 Function(
  IntPtr hWnd, 
  Pointer&amp;lt;Utf16&amp;gt; lpText, 
  Pointer&amp;lt;Utf16&amp;gt; lpCaption,
  Int32 uType
);

typedef MessageBoxDart = int Function(
  int hWnd, 
  Pointer&amp;lt;Utf16&amp;gt; lpText, 
  Pointer&amp;lt;Utf16&amp;gt; lpCaption, 
  int uType
);

final user32 = DynamicLibrary.open('user32.dll');

final win32MessageBox =
  user32.lookupFunction&amp;lt;MessageBoxNative, MessageBoxDart&amp;gt;('MessageBoxW');

void showMessageBox(String message, String caption) =&amp;gt;
  win32MessageBox(
    0, // No owner window
    Utf16.toUtf16(message), // Message
    Utf16.toUtf16(caption), // Window title
    0 // OK button only
  );

...

// call just like any other Dart function
showMessageBox('Test Message', 'Window Caption');
view rawmbox.dart hosted with ❤ by GitHub
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此代码不会产生在平台通道之类的两个线程之间进行转换的开销。FFI包括对许多不同种类的API的支持，包括Win32，WinRT和COM。但是，在运行并包装整个基于C的Windows API之前，请检查&lt;a href=&quot;https://pub.dev/packages/win32&quot;&gt;win32插件&lt;/a&gt;，该&lt;a href=&quot;https://pub.dev/packages/win32&quot;&gt;插件&lt;/a&gt;已经可以很好地做到这一点。实际上，&lt;a href=&quot;https://pub.dev/packages/path_provider&quot;&gt;path_provider&lt;/a&gt;插件本身是使用win32插件实现的。有关win32插件如何开发以及如何工作的详细信息，请查看博客文章&lt;a href=&quot;https://medium.com/@timsneath/windows-fun-with-dart-ffi-687c4619e78d&quot;&gt;Dart FFI的Windows乐趣&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;无论您在Flutter for Windows之旅中的任何地方，都应确保&lt;a href=&quot;http://flutter.dev/desktop&quot;&gt;阅读flutter.dev上的桌面文档&lt;/a&gt;，其中包括最新详细信息。另外，您将需要&lt;a href=&quot;https://codelabs.developers.google.com/codelabs/flutter-github-graphql-client&quot;&gt;熟悉&lt;/a&gt; Flutter代码&lt;a href=&quot;https://codelabs.developers.google.com/codelabs/flutter-github-graphql-client&quot;&gt;实验室，以编写Windows，macOS和Windows桌面目标应用程序&lt;/a&gt;，其中包括用于真实场景的代码，例如使用OAuth进行身份验证，访问GitHub API和使用GraphQL。或者，对于在Windows上运行的Flutter桌面代码的另一个很好的例子，&lt;a href=&quot;https://github.com/flutter/samples/tree/master/experimental/desktop_photo_search&quot;&gt;请查看照片搜索示例&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072947181-746823625.png&quot; alt=&quot;图片发布&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它使用标准的Windows文件打开对话框，树视图小部件，拆分器小部件，并将结果与真实世界的REST API集成在一起。&lt;/p&gt;
&lt;p&gt;对于其他有用的面向桌面的小部件，我们建议&lt;a href=&quot;https://github.com/google/flutter-desktop-embedding/tree/master/plugins/menubar&quot;&gt;使用菜单栏插件&lt;/a&gt;，&lt;a href=&quot;https://api.flutter.dev/flutter/material/NavigationRail-class.html&quot;&gt;NavigationRail小部件&lt;/a&gt;和&lt;a href=&quot;https://api.flutter.dev/flutter/material/DataTable-class.html&quot;&gt;DataTable小部件&lt;/a&gt;。您可能还对&lt;a href=&quot;https://api.flutter.dev/flutter/widgets/InteractiveViewer-class.html&quot;&gt;InteractiveViewer小部件&lt;/a&gt;感兴趣，&lt;a href=&quot;https://api.flutter.dev/flutter/widgets/InteractiveViewer-class.html&quot;&gt;该小部件&lt;/a&gt;具有完整的桌面支持，可通过鼠标手势来平移和缩放子小部件。&lt;/p&gt;
&lt;p&gt;可以探索的另一组有用的小部件是&lt;a href=&quot;https://pub.dev/publishers/syncfusion.com/packages&quot;&gt;SyncFusion&lt;/a&gt;中的&lt;a href=&quot;https://pub.dev/publishers/syncfusion.com/packages&quot;&gt;那些&lt;/a&gt;，它们已经在Windows开发社区中广为人知。它们提供了广泛的企业质量小部件，用于创建图表，仪表，数据网格等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072947407-299923460.png&quot; alt=&quot;图片发布&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072947584-38276463.png&quot; alt=&quot;图片发布&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些小部件具有社区和企业许可证，因此您可以找到最适合您的项目的工具。&lt;/p&gt;

&lt;p&gt;除了Windows（通常是Flutter桌面）的软件包和插件外，Flutter开发人员还一直在开发针对Windows的出色应用，例如&lt;a href=&quot;https://www.invoiceninja.com/&quot;&gt;Invoice Ninja的&lt;/a&gt;实验性构建：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072948394-1047457239.png&quot; alt=&quot;图片发布&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Invoice Ninja是一家依靠Flutter带来收入的发票公司。他们的目标是今天生产中的Android和iOS，并具有&lt;a href=&quot;https://demo.invoiceninja.com/&quot;&gt;基于Web的演示&lt;/a&gt;供您尝试，但也期待提供桌面版本。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;“在过去的Ninja中，我们一直在努力仅支持Web和移动设备，一次只能维护三个单独的代码库。借助Flutter，以及最近的Flutter Desktop，我们已经能够使用单个代码库为每个主要平台构建应用程序。我们不仅可以从根本上获得应用程序的免费桌面版本，而且还拥有所有应用程序中最好的性能！”&lt;/p&gt;
&lt;p&gt;—Invoice Ninja 联合创始人Hillel Coren&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果您对实现可在移动和台式机上运行的现实世界中可产生收入的Flutter应用感兴趣，&lt;a href=&quot;https://github.com/invoiceninja/flutter-client&quot;&gt;则可在GitHub上找到源代码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://drone-detection-system.com/&quot;&gt;Aartos&lt;/a&gt;是另一家制造出色产品的公司，其中包括带有&lt;a href=&quot;https://drone-detection-system.com/aartos-dds/product-overview/&quot;&gt;Flutter编写的具有多平台客户端&lt;/a&gt;的实时无人机检测系统。这是在移动客户端旁边运行的Windows客户端的早期版本：&lt;/p&gt;
&lt;p&gt;视频地址：&lt;a href=&quot;https://youtu.be/mGvPCT7Vc2Y&quot;&gt;https://youtu.be/mGvPCT7Vc2Y&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这两个针对iOS和Windows的版本共享完全相同的代码库。&lt;/p&gt;
&lt;p&gt;如果您是经验丰富的Flutter开发人员，并且发现自己在Flutter的不同版本之间进行切换；例如，一个版本用于交付生产型移动应用程序，另一个版本用于测试Windows alpha，那么您可能会喜欢Flutter版本管理器，该版本管理器现在带有&lt;a href=&quot;https://github.com/leoafarias/fvm/releases&quot;&gt;Windows GUI，您可以下载该版本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;视频地址：&lt;a href=&quot;https://youtu.be/_WA71wSt2ww&quot;&gt;https://youtu.be/_WA71wSt2ww&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该工具是开源的，因此您可以&lt;a href=&quot;https://github.com/leoafarias/fvm&quot;&gt;亲自&lt;/a&gt;了解Leo如何使其看起来如此出色。&lt;/p&gt;

&lt;p&gt;现在，我们已经发布了Alpha版，我们的注意力转移到完成功能集和稳定产品的发布上。作为一个开源项目，您可以&lt;a href=&quot;https://github.com/flutter/flutter/projects/55&quot;&gt;在GitHub网站上&lt;/a&gt;关注我们的&lt;a href=&quot;https://github.com/flutter/flutter/projects/55&quot;&gt;beta测试进展&lt;/a&gt;，尚需完成的其他工作包括可访问性，全球化和本地化，增强的键盘和文本处理，对命令行参数的支持等等。&lt;/p&gt;
&lt;p&gt;除了支持经典的Win32 API外，我们还在试验&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/get-started/universal-application-platform-guide&quot;&gt;基于UWP的Flutter shell版本，该版本&lt;/a&gt;使Flutter可以访问更广泛的基于Windows的设备，包括Xbox。作为该实验的一部分，本周我们&lt;a href=&quot;https://www.microsoft.com/en-us/p/flutter-gallery/9pdwctdfc7qq&quot;&gt;向Windows应用商店&lt;/a&gt;发布了基于UWP的&lt;a href=&quot;https://www.microsoft.com/en-us/p/flutter-gallery/9pdwctdfc7qq&quot;&gt;Flutter Gallery&lt;/a&gt;版本。&lt;/p&gt;
&lt;p&gt;以下屏幕快照显示了在Xbox上运行的基于UWP的Flutter Gallery：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072951493-912158846.png&quot; alt=&quot;图片发布&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是在&lt;a href=&quot;https://docs.microsoft.com/en-us/dual-screen/windows/get-dev-tools&quot;&gt;Windows 10X模拟器&lt;/a&gt;上运行的双屏Windows设备上运行的同一应用&lt;a href=&quot;https://docs.microsoft.com/en-us/dual-screen/windows/get-dev-tools&quot;&gt;程序&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072952552-273404413.png&quot; alt=&quot;图片发布&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072953225-2110737047.png&quot; alt=&quot;图片发布&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/flutter/flutter/issues/14967#issuecomment-697108439&quot;&gt;您可以在GitHub上了解有关Flutter for UWP的进度的更多信息&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在此版本中，我们将Flutter的功能引入Windows，它具有声明式，可组合的，反应式的框架，可提高开发人员的工作效率，并具有适应性的Material规范实现，因此您还可以使应用外观和感觉达到您希望的方式作为Flutter的全套开发和调试工具。完成后，您的应用程序将编译为本机64位代码，您可以将其打包并带到其他Windows计算机上，就像其他任何本机应用程序一样。最后，您可以使用相同的代码库来创建针对Android，iOS，Web，macOS和Linux的应用程序。&lt;/p&gt;
&lt;p&gt;如果您想开始使用Flutter构建Windows应用程序，我们希望&lt;a href=&quot;https://github.com/flutter/flutter/issues&quot;&gt;收到您的反馈&lt;/a&gt;！如果您希望利用Windows的专业知识来&lt;a href=&quot;https://flutter.dev/docs/development/packages-and-plugins/developing-packages#plugin&quot;&gt;构建流行插件的Windows实现&lt;/a&gt;，或者为Flutter构建一些以Windows为中心的工具（也许是一个CLI，它可以从&lt;code&gt;flutter build windows&lt;/code&gt;命令的输出中创建MSIX ……），那也欢迎您！&lt;/p&gt;
&lt;p&gt;有了Flutter对Windows的新支持，您将要构建什么？&lt;/p&gt;
&lt;p&gt;版权声明：本文为原创，依据 &lt;a href=&quot;https://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;CC BY-SA 4.0&lt;/a&gt; 许可证进行授权，转载请附上出处链接及本声明。&lt;/p&gt;
&lt;p&gt;`&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;h2 id=&quot;交流-2&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客（330个控件用法+实战入门系列文章）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072953616-1483172599.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200925072953767-1239933772.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Thu, 24 Sep 2020 23:30:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：Windows来了，Mac、Linux、Web还远吗？ 本文翻译自https://medium.com/flutter/announcing-flutter-windows-alpha-33</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13727982.html</dc:identifier>
</item>
<item>
<title>Android动画系列之帧动画和补间动画 - 躬行之</title>
<link>http://www.cnblogs.com/jzmanu/p/13727497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jzmanu/p/13727497.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原文首发于微信公众号：jzman-blog，欢迎关注交流！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Android 提供三种动画：帧动画、补间动画和属性动画，本篇文章介绍帧动画以及补间动画的使用，属性动画的使用将在后面的文章中分享，那就来复习一下这两种动画的使用吧。&lt;/p&gt;
&lt;h4 id=&quot;frameanimation&quot;&gt;FrameAnimation&lt;/h4&gt;
&lt;p&gt;FrameAnimation 即逐帧动画，通俗来说就是按照图片动作顺序依次播放来形成动画，创建 FrameAnimation 可用 xml 定义也可直接使用代码创建。&lt;/p&gt;
&lt;h5 id=&quot;xml创建帧动画&quot;&gt;xml创建帧动画&lt;/h5&gt;
&lt;p&gt;在 res/drawable 文件夹下创建一个 drawable 文件，使用 animation-list 标签，具体内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;!--FrameAnimator--&amp;gt;
&amp;lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:oneshot=&quot;false&quot;&amp;gt;
    &amp;lt;item
        android:drawable=&quot;@drawable/zzlx1&quot;
        android:duration=&quot;100&quot; /&amp;gt;
    &amp;lt;item
        android:drawable=&quot;@drawable/zzlx2&quot;
        android:duration=&quot;100&quot; /&amp;gt;
    &amp;lt;item
        android:drawable=&quot;@drawable/zzlx3&quot;
        android:duration=&quot;100&quot; /&amp;gt;
    &amp;lt;!--...--&amp;gt;
&amp;lt;/animation-list&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性 oneshot 为 true 表示动画只能播放一次，false 表示动画循环播放，drawable 是当前动作对应的图片，duration 是其持续时间，duration 长度影响动画播放的快慢，然后在 Activity 中使用获取该 drawable 文件对应的 AnimationDrawable，然后使用 AnimationDrawable 对象来控制动画的状态，参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//获取Frame动画文件对应的AnimationDrawable
mAnimationDrawable = (AnimationDrawable) getResources().getDrawable(R.drawable.frame_animator);
//设置AnimationDrawable为图片的背景
imageView.setBackground(mAnimationDrawable);

//开启动画
mAnimationDrawable.start();
//停止动画
mAnimationDrawable.stop();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;代码创建帧动画&quot;&gt;代码创建帧动画&lt;/h5&gt;
&lt;p&gt;使用代码创建帧动画就是创建 AnimationDrawable 对象，然后在 AnimationDrawable 中添加对应的 Frame 即可，代码参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//代码创建Frame动画
mAnimationDrawable = new AnimationDrawable();
//设置动画循环播放，true为动画只播放一次
mAnimationDrawable.setOneShot(false);
mAnimationDrawable.addFrame(getResources().getDrawable(R.drawable.zzlx1),100);
mAnimationDrawable.addFrame(getResources().getDrawable(R.drawable.zzlx2),100);
mAnimationDrawable.addFrame(getResources().getDrawable(R.drawable.zzlx3),100);
//...
imageView.setBackground(mAnimationDrawable);

//开启动画
mAnimationDrawable.start();
//停止动画
mAnimationDrawable.stop();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FrameAnimation 效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/19/16d4521bc9fcd6e8?w=302&amp;amp;h=411&amp;amp;f=gif&amp;amp;s=112561&quot; alt=&quot;帧动画&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;tweenanimation&quot;&gt;TweenAnimation&lt;/h4&gt;
&lt;p&gt;TweenAnimation 即常说的补间动画，主要有以下几种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;位移动画(Translation)&lt;/li&gt;
&lt;li&gt;缩放动画(Scale)&lt;/li&gt;
&lt;li&gt;旋转动画(Rotate)&lt;/li&gt;
&lt;li&gt;透明度动画(Alpha)&lt;/li&gt;
&lt;li&gt;组合动画&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上述动画都有自己特有的一下属性，下面来看一看这些动画通用的一些属性，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--设置动画持续时间--&amp;gt;
android:duration=&quot;1200&quot;
&amp;lt;!--动画开始的延时--&amp;gt;
android:startOffset =&quot;1000&quot;
&amp;lt;!--动画播放完是否回到动画开始的位置，默认true，如果fillBefore设置为false,动画不会停留在结束位置，不知道是不是bug--&amp;gt;
android:fillBefore = &quot;true&quot;
&amp;lt;!--动画播放完之后是否回到动画结束的位置，默认false,如果fillAfter设置为true,动画则会停留在结束位置--&amp;gt;
android:fillAfter = &quot;false&quot;
&amp;lt;!--设置fill...属性是否启用，对fillAfter无效--&amp;gt;
android:fillEnabled= &quot;true&quot;
&amp;lt;!--设置动画重复模式,restart为重新播放，reverse为倒序回放，和repeatCount搭配使用--&amp;gt;
android:repeatMode = &quot;restart&quot;
&amp;lt;!--设置动画重复次数--&amp;gt;
android:repeatCount = &quot;0&quot;
&amp;lt;!--设置动画插值器，这里的插值器是动画开始速度较慢，后面加速--&amp;gt;
android:interpolator = &quot;@android:anim/accelerate_interpolator&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在代码中进行对应动画实现，这些属性也有对应的属性设置，直接设置即可。&lt;/p&gt;
&lt;h5 id=&quot;位移动画translate&quot;&gt;位移动画(Translate)&lt;/h5&gt;
&lt;p&gt;位移动画对 View 进行水平方向或垂直方向位置的平移，可指定起始位置和结束位置，可使用 xml 定义位移动画也可以使用代码创建位移动画，位移动画对应的 Animation 的子类是 TranslateAnimation。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;xml定义位移动画&lt;/strong&gt;：在 res/anim 下创建一个xml文件 translation_anim.xml，在该文件中定义位移动画如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;1200&quot;
    android:startOffset =&quot;0&quot;
    android:fillBefore = &quot;true&quot;
    android:fillAfter = &quot;false&quot;
    android:fillEnabled= &quot;false&quot;
    android:repeatMode = &quot;reverse&quot;
    android:repeatCount = &quot;5&quot;
    android:interpolator = &quot;@android:anim/accelerate_interpolator&quot;

    android:fromXDelta=&quot;0&quot;
    android:fromYDelta=&quot;0&quot;
    android:toXDelta=&quot;100&quot;
    android:toYDelta=&quot;100&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述 xml 文件定义了一个位移动画文件，其中位移动画自有的属性含义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--水平方向动画开始的位置--&amp;gt;
android:fromXDelta=&quot;0&quot;
&amp;lt;!--垂直方向动画开始的位置--&amp;gt;
android:fromYDelta=&quot;0&quot;
&amp;lt;!--水平方向动画结束的位置--&amp;gt;
android:toXDelta=&quot;100&quot;
&amp;lt;!--垂直方向动画结束的位置--&amp;gt;
android:toYDelta=&quot;100&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 Activity 中获取该 xml 文件对应的 TranslateAnimation，将其设置到想要设置位移动画的 View 上即可，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void translation(){
    //获取在anim下定义的动画文件
    TranslateAnimation translateAnimation = (TranslateAnimation) AnimationUtils.loadAnimation(this, R.anim.translation_anim);、
    //设置并开启动画
    ivImage.startAnimation(translateAnimation);    
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码中创建位移动画&lt;/strong&gt;：代码创建位移动画使用 Animation 的子类 TranslateAnimation,使用时直接创建 TranslateAnimation 对象即可，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//代码创建位移动画
private void translation(){
    //表示相对View自身原点(View左上角)像素偏移量
    TranslateAnimation translateAnimation = new TranslateAnimation(0,100,0,100);
    //设置动画持续时间
    translateAnimation.setDuration(1200);
    //设置动画重复模式
    translateAnimation.setRepeatMode(Animation.REVERSE);
    //设置动画重复次数
    translateAnimation.setRepeatCount(3);
    translateAnimation.setFillAfter(true);
    //设置动画插值器
    translateAnimation.setInterpolator(this,android.R.anim.accelerate_interpolator);
//        translateAnimation.setInterpolator(new AccelerateInterpolator());
    //...
    ivImage.startAnimation(translateAnimation);    
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面参数中使用的时像素的偏移量，API 还提供了针对 View 自身一个父 View 的百分比的设置方式，下面这种创建 TranslateAnimation 对象的方式和上面实现的效果是一样的。具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * ABSOLUTE:表示相对View自身原点(View左上角)像素偏移量
 *          此时和TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)一样
 * RELATIVE_TO_SELF:表示相对View自身的百分比，如0.5f表示View自身大小的50%，1.0f表示View自身大小
 * RELATIVE_TO_PARENT:表示相对父View的百分比，如0.5f表示View自身大小的50%，1.0f表示View自身大小
 */
TranslateAnimation translateAnimation = new TranslateAnimation(
        Animation.RELATIVE_TO_SELF,0,Animation.RELATIVE_TO_SELF,0.46f,
        Animation.RELATIVE_TO_SELF,0,Animation.RELATIVE_TO_SELF,0.46f);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用时可根据需要选择合适的构造方式创建 TranslateAnimation，测试效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/19/16d4521bc9ddd89a?w=354&amp;amp;h=616&amp;amp;f=gif&amp;amp;s=101002&quot; alt=&quot;位移动画&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;缩放动画scale&quot;&gt;缩放动画(Scale)&lt;/h5&gt;
&lt;p&gt;缩放动画对 View 就是对视图进行一定程度的放大和缩小，可使用 xml 定义位移动画也可以使用代码创建位移动画，缩放动画对应的 Animation 的子类是 ScaleAnimation。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;xml定义缩放动画&lt;/strong&gt;：在 res/anim 下创建一个 xml 文件 scale_anim.xml，在里面定义缩放动画，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;1200&quot;
    android:startOffset =&quot;0&quot;
    android:fillBefore = &quot;true&quot;
    android:fillAfter = &quot;false&quot;
    android:fillEnabled= &quot;false&quot;
    android:repeatMode = &quot;reverse&quot;
    android:repeatCount = &quot;3&quot;
    android:interpolator = &quot;@android:anim/accelerate_interpolator&quot;

    android:fromXScale=&quot;1&quot;
    android:fromYScale=&quot;1&quot;
    android:toXScale=&quot;3&quot;
    android:toYScale=&quot;3&quot;
    android:pivotX=&quot;50%&quot;
    android:pivotY=&quot;50%&quot;&amp;gt;
&amp;lt;/scale&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述 xml 文件定义了一个缩放动画文件，其中缩放动画自有的属性含义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--设置水平方向上的起始缩放倍数--&amp;gt;
android:fromXScale=&quot;1&quot;
&amp;lt;!--设置垂直方向上的起始缩放倍数--&amp;gt;
android:fromYScale=&quot;1&quot;
&amp;lt;!--设置水平方向上的结束缩放倍数--&amp;gt;
android:toXScale=&quot;3&quot;
&amp;lt;!--设置垂直方向上的结束缩放倍数--&amp;gt;
android:toYScale=&quot;3&quot;
&amp;lt;!--设置缩放中心水平方向上的坐标--&amp;gt;
android:pivotX=&quot;50%&quot;
&amp;lt;!--设置缩放中心垂直方向上的坐标--&amp;gt;
android:pivotY=&quot;50%&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 pivotX 和 pivotY 有三种设置方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数字：如50表示缩放中心相较 View 原点偏移 50px&lt;/li&gt;
&lt;li&gt;百分比：如 50% 表示缩放中心相较 View 原点偏移 View 自身大小的 50%&lt;/li&gt;
&lt;li&gt;百分比p：如 50%p 表示缩放中心相较 View 原点偏移父 View 自身大小的 50%&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后在 Activity 中获取该 xml 文件对应的 ScaleAnimation，将其设置到想要设置位移动画的 View 上即可，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void scale(){
    ScaleAnimation scaleAnimation = (ScaleAnimation) AnimationUtils.loadAnimation(this,R.anim.scale_anim);
    ivImage.startAnimation(scaleAnimation);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码创建缩放动画&lt;/strong&gt;：代码创建缩放动画使用 Animation 的子类 ScaleAnimation,使用时直接创建 ScaleAnimation 对象即可，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//代码创建缩放动画
private void scale(){
    ScaleAnimation scaleAnimation = new ScaleAnimation(1,3,1,3,
            Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
    scaleAnimation.setRepeatMode(Animation.REVERSE);
    scaleAnimation.setDuration(500);
    scaleAnimation.setRepeatCount(5);
    scaleAnimation.setInterpolator(this,android.R.anim.accelerate_decelerate_interpolator);
//        translateAnimation.setInterpolator(new AccelerateInterpolator());
    //...
    ivImage.startAnimation(scaleAnimation);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于参数中的 pivotXType 和 pivotYType 和在上文中已经提到过，这里就不在赘述，测试效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/19/16d4521bcf690a18?w=354&amp;amp;h=610&amp;amp;f=gif&amp;amp;s=135760&quot; alt=&quot;缩放动画&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;旋转动画rotate&quot;&gt;旋转动画(Rotate)&lt;/h5&gt;
&lt;p&gt;旋转动画对 View 就是对视图角度进行旋转，可使用 xml 定义旋转动画也可以使用代码创建旋转动画，旋转动画对应的 Animation 的子类是 RotateAnimation。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;xml定义旋转动画&lt;/strong&gt;：在 res/anim 下创建一个 xml 文件 rotate_anim.xml，在里面定义缩放动画，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;1200&quot;
    android:startOffset =&quot;0&quot;
    android:fillBefore = &quot;true&quot;
    android:fillAfter = &quot;false&quot;
    android:fillEnabled= &quot;false&quot;
    android:repeatMode = &quot;reverse&quot;
    android:repeatCount = &quot;5&quot;
    android:interpolator = &quot;@android:anim/accelerate_interpolator&quot;

    android:fromDegrees=&quot;0&quot;
    android:toDegrees=&quot;100&quot;
    android:pivotY=&quot;50%&quot;
    android:pivotX=&quot;50%&quot;&amp;gt;
&amp;lt;/rotate&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述 xml 文件定义了一个旋转动画文件，其中缩放动画自有的属性含义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--设置动画开始时的角度，正数表示顺时针,负数表示逆时针--&amp;gt;
android:fromDegrees=&quot;0&quot;
&amp;lt;!--设置动画结束时的角度，正数表示顺时针,负数表示逆时针--&amp;gt;
android:toDegrees=&quot;100&quot;
&amp;lt;!--设置水平方向旋转中心点的坐标--&amp;gt;
android:pivotY=&quot;50%&quot;
&amp;lt;!--设置垂直方向旋转中心点的坐标--&amp;gt;
android:pivotX=&quot;50%&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 pivotX 和 pivotY 有三种设置方式在上文中已经说明。然后在 Activity 中获取该 xml 文件对应的 RotateAnimation，将其设置到想要设置旋转动画的 View 上即可，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void rotate(){
    RotateAnimation rotateAnimation = (RotateAnimation) AnimationUtils.loadAnimation(this,R.anim.rotate_anim);
    ivImage.startAnimation(rotateAnimation);   
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码创建旋转动画&lt;/strong&gt;：代码创建旋转动画使用 Animation 的子类 RotateAnimation,使用时直接创建 RotateAnimation 对象即可，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//代码创建旋转动画
private void rotate(){
    RotateAnimation rotateAnimation = new RotateAnimation(0,100,
            Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);
    rotateAnimation.setRepeatMode(Animation.REVERSE);
    rotateAnimation.setDuration(1200);
    rotateAnimation.setRepeatCount(3);
    rotateAnimation.setInterpolator(this,android.R.anim.accelerate_decelerate_interpolator);
//        translateAnimation.setInterpolator(new AccelerateInterpolator());
    //...
    ivImage.startAnimation(rotateAnimation);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/19/16d4521bcf46ce1e?w=352&amp;amp;h=612&amp;amp;f=gif&amp;amp;s=119143&quot; alt=&quot;旋转动画&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;透明度动画alpha&quot;&gt;透明度动画(Alpha)&lt;/h5&gt;
&lt;p&gt;透明度动画就是修改 View 的透明度，可使用 xml 定义透明度动画也可以使用代码创建透明度动画，透明度动画对应的 Animation 的子类是 AlphaAnimation。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;xml定义透明度动画&lt;/strong&gt;：在 res/anim 下创建一个 xml 文件 alpha_anim.xml，在里面定义缩放动画，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;3000&quot;
    android:startOffset =&quot;0&quot;
    android:fillBefore = &quot;true&quot;
    android:fillAfter = &quot;true&quot;
    android:fillEnabled= &quot;false&quot;
    android:repeatMode = &quot;restart&quot;
    android:repeatCount = &quot;0&quot;
    android:interpolator = &quot;@android:anim/accelerate_interpolator&quot;

    android:fromAlpha=&quot;1&quot;
    android:toAlpha=&quot;0&quot;&amp;gt;
&amp;lt;/alpha&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述 xml 文件定义了一个透明度动画文件，其中透明度动画自有的属性含义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--设置动画的开始透明度，0表示透明，1表示不透明--&amp;gt;
android:fromAlpha=&quot;1&quot;
&amp;lt;!--设置动画的结束透明度，0表示透明，1表示不透明--&amp;gt;
android:toAlpha=&quot;0&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 Activity 中获取该 xml 文件对应的 AlphaAnimation，将其设置到想要设置旋转动画的 View 上即可，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void alpha(){
    AlphaAnimation alphaAnimation = (AlphaAnimation) AnimationUtils.loadAnimation(this,R.anim.alpha_anim);
    ivImage.startAnimation(alphaAnimation); 
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码创建透明度动画&lt;/strong&gt;：代码创建透明度动画使用 Animation 的子类 AlphaAnimation,使用时直接创建 AlphaAnimation 对象即可，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//代码创建透明度动画
private void alpha(){
    AlphaAnimation alphaAnimation = new AlphaAnimation(1.0f,0.0f);
    alphaAnimation.setRepeatMode(Animation.RESTART);
    alphaAnimation.setDuration(1500);
    alphaAnimation.setRepeatCount(3);
//        alphaAnimation.setInterpolator(this,android.R.anim.accelerate_decelerate_interpolator);
//        translateAnimation.setInterpolator(new AccelerateInterpolator());
    //...
    ivImage.startAnimation(alphaAnimation);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;透明度动画测试效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/19/16d4521bcf7d97f1?w=351&amp;amp;h=611&amp;amp;f=gif&amp;amp;s=91205&quot; alt=&quot;透明度动画&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此为止，位移、缩放、旋转、透明度动画的内容介绍完了，除了单独使用这些动画，还可以组合这些动画实现更复杂的动画，&lt;/p&gt;
&lt;h5 id=&quot;组合动画&quot;&gt;组合动画&lt;/h5&gt;
&lt;p&gt;组合动画使用 AnimationSet 来实现，可使用 xml 定义组合动画也可以使用代码创建组合动画，透明度动画对应的 Animation 的子类是 AnimationSet。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;xml定义组合动画&lt;/strong&gt;：在 res/anim 下创建一个 xml 文件 combine_anim.xml，在里面定义组合动画，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;1200&quot;&amp;gt;

    &amp;lt;!--透明度动画--&amp;gt;
    &amp;lt;alpha
        android:repeatMode=&quot;reverse&quot;
        android:repeatCount=&quot;10&quot;
        android:fromAlpha=&quot;1&quot;
        android:toAlpha=&quot;0.5&quot; /&amp;gt;

    &amp;lt;!--旋转动画--&amp;gt;
    &amp;lt;rotate
        android:repeatMode=&quot;reverse&quot;
        android:repeatCount=&quot;10&quot;
        android:fromDegrees=&quot;0&quot;
        android:pivotX=&quot;50%&quot;
        android:pivotY=&quot;50%&quot;
        android:toDegrees=&quot;360&quot; /&amp;gt;

    &amp;lt;!--缩放动画--&amp;gt;
    &amp;lt;scale
        android:repeatMode=&quot;reverse&quot;
        android:repeatCount=&quot;10&quot;
        android:fromXScale=&quot;1&quot;
        android:fromYScale=&quot;1&quot;
        android:pivotX=&quot;50%&quot;
        android:pivotY=&quot;50%&quot;
        android:toXScale=&quot;3&quot;
        android:toYScale=&quot;3&quot; /&amp;gt;
&amp;lt;/set&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 Activity 中获取该 xml 文件对应的 AnimationSet，将其设置到想要设置旋转动画的 View 上即可，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void combine(){
    AnimationSet animationSet = (AnimationSet) AnimationUtils.loadAnimation(this,R.anim.combine_anim);
    ivImage.startAnimation(animationSet);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码创建组合动画&lt;/strong&gt;：代码创建组合动画使用 Animation 的子类 AnimationSet,使用时直接创建 AnimationSet 对象，将要组合的动画按序添加到 AnimationSet 中，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//代码创建组合动画
private void combine(){
    AnimationSet animationSet = new AnimationSet(true);
    AlphaAnimation alphaAnimation = new AlphaAnimation(1.0f,0.3f);
    alphaAnimation.setRepeatMode(Animation.REVERSE);
    alphaAnimation.setRepeatCount(3);
    RotateAnimation rotateAnimation = new RotateAnimation(0,360,
            Animation.RELATIVE_TO_SELF,0.5f,
            Animation.RELATIVE_TO_SELF,0.5f);
    rotateAnimation.setRepeatMode(Animation.REVERSE);
    rotateAnimation.setRepeatCount(3);
    ScaleAnimation scaleAnimation = new ScaleAnimation(1,3,1,3,
            Animation.RELATIVE_TO_SELF,0.5f,
            Animation.RELATIVE_TO_SELF,0.5f);
    scaleAnimation.setRepeatMode(Animation.REVERSE);
    scaleAnimation.setRepeatCount(3);

    animationSet.addAnimation(alphaAnimation);
    animationSet.addAnimation(rotateAnimation);
    animationSet.addAnimation(scaleAnimation);

    animationSet.setDuration(1200);
    //AnimationSet不支持动画重复播放，如果想要组合动画重复播放可设置每个动画重复播放即可
//        animationSet.setRepeatMode(Animation.REVERSE);
//        animationSet.setRepeatCount(10);

    ivImage.startAnimation(animationSet);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组合动画测试效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/19/16d4521bcf5dd814?w=353&amp;amp;h=615&amp;amp;f=gif&amp;amp;s=166200&quot; alt=&quot;组合动画&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;这篇文章总结了 Android 开发中帧动画(FrameAnimation)和补间动画(TweenAnimation)的使用，下一篇将会介绍属性动画(ObjectAnimator )。&lt;/p&gt;
&lt;p&gt;可以关注公众号：零点小筑（jzman-blog），一起交流学习。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/9/19/16d452488860376d?w=600&amp;amp;h=472&amp;amp;f=jpeg&amp;amp;s=21120&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Sep 2020 16:10:00 +0000</pubDate>
<dc:creator>躬行之</dc:creator>
<og:description>原文首发于微信公众号：jzman-blog，欢迎关注交流！ Android 提供三种动画：帧动画、补间动画和属性动画，本篇文章介绍帧动画以及补间动画的使用，属性动画的使用将在后面的文章中分享，那就来复</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jzmanu/p/13727497.html</dc:identifier>
</item>
<item>
<title>从CPU缓存看缓存的套路 - mghio</title>
<link>http://www.cnblogs.com/mghio/p/13727341.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mghio/p/13727341.html</guid>
<description>&lt;h4 id=&quot;一、前言&quot;&gt;一、前言&lt;/h4&gt;
&lt;p&gt;不同存储技术的访问时间差异很大，从 &lt;code&gt;计算机层次结构&lt;/code&gt; 可知，通常情况下，从高层往底层走，存储设备变得更慢、更便宜同时体积也会更大，&lt;code&gt;CPU&lt;/code&gt; 和内存之间的速度存在着巨大的差异，此时就会想到计算机科学界中一句著名的话：&lt;code&gt;计算机科学的任何一个问题，都可以通过增加一个中间层来解决。&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;二、引入缓存层&quot;&gt;二、引入缓存层&lt;/h4&gt;
&lt;p&gt;为了解决速度不匹配问题，可以通过引入一个缓存中间层来解决问题，但是也会引入一些新的问题。现代计算机系统中，从硬件到操作系统、再到一些应用程序，绝大部分的设计都用到了著名的&lt;strong&gt;局部性原理&lt;/strong&gt;，局部性通常有如下两种不同的形式：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;时间局部性：在一个具有良好的时间局部性的程序当中，被引用过一次的内存位置，在将来一个不久的时间内很可能会被再次引用到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;空间局部性：在一个具有良好的空间局部性的程序当中，一个内存位置被引用了一次，那么在不久的时间内很可能会引用附近的位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有上面这个&lt;code&gt;局部性&lt;/code&gt;原理为理论指导，为了解决二者速度不匹配问题就可以在 &lt;code&gt;CPU&lt;/code&gt; 和内存之间加一个缓存层，于是就有了如下的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/08/16/B9RQlyUMg18HxOT.jpg&quot; alt=&quot;Xnip2020-08-16_22-51-12.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;三、何时更新缓存&quot;&gt;三、何时更新缓存&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;CPU&lt;/code&gt; 中引入缓存中间层后，虽然可以解决和内存速度不一致的问题，但是同时也面临着一个问题：&lt;strong&gt;当 CPU 更新了其缓存中的数据之后，要什么时候去写入到内存中呢？&lt;/strong&gt;，比较容易想到的一个解决方案就是，&lt;code&gt;CPU&lt;/code&gt; 更新了缓存的数据之后就立即更新到内存中，也就是说当 &lt;code&gt;CPU&lt;/code&gt; 更新了缓存的数据之后就会从上到下更新，直到内存为止，英文称之为&lt;code&gt;write through&lt;/code&gt;，这种方式的优点是比较简单，但是缺点也很明显，由于每次都需要访问内存，所以速度会比较慢。还有一种方法就是，当 &lt;code&gt;CPU&lt;/code&gt; 更新了缓存之后并不马上更新到内存中去，在&lt;code&gt;适当的时候&lt;/code&gt;再执行写入内存的操作，因为有很多的缓存只是存储一些中间结果，没必要每次都更新到内存中去，英文称之为&lt;code&gt;write back&lt;/code&gt;，这种方式的优点是 &lt;code&gt;CPU&lt;/code&gt; 执行更新的效率比较高，缺点就是实现起来会比较复杂。&lt;/p&gt;
&lt;p&gt;上面说的&lt;code&gt;在适当的时候写入内存&lt;/code&gt;，如果是单核 &lt;code&gt;CPU&lt;/code&gt; 的话，可以在缓存要被新进入的数据取代时，才更新内存，但是在多核 &lt;code&gt;CPU&lt;/code&gt; 的情况下就比较复杂了，由于 &lt;code&gt;CPU&lt;/code&gt; 的运算速度超越了 1 级缓存的数据 &lt;code&gt;I\O&lt;/code&gt; 能力，&lt;code&gt;CPU&lt;/code&gt; 厂商又引入了多级的缓存结构，比如常见的 L1、L2、L3 三级缓存结构，L1 和 L2 为 &lt;code&gt;CPU&lt;/code&gt; 核心独有，L3 为 &lt;code&gt;CPU&lt;/code&gt; 共享缓存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/08/16/zlioMu1W8naRJH2.jpg&quot; alt=&quot;Xnip2020-08-16_23-39-28.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果现在分别有两个线程运行在两个不同的核 &lt;code&gt;Core 1&lt;/code&gt; 和 &lt;code&gt;Core 2&lt;/code&gt; 上，内存中 &lt;code&gt;i&lt;/code&gt; 的值为 1，这两个分别运行在两个不同核上的线程要对 &lt;code&gt;i&lt;/code&gt; 进行加 1 操作，如果不加一些限制，两个核心同时从内存中读取 &lt;code&gt;i&lt;/code&gt; 的值，然后进行加 1 操作后再分别写入内存中，可能会出现相互覆盖的情况，解决的方法相信大家都能想得到，第一种是只要有一个核心修改了缓存的数据之后，就立即把内存和其它核心更新。第二种是当一个核心修改了缓存的数据之后，就把其它同样复制了该数据的 &lt;code&gt;CPU&lt;/code&gt; 核心失效掉这些数据，等到合适的时机再更新，通常是下一次读取该缓存的时候发现已经无效，才从内存中加载最新的值。&lt;/p&gt;
&lt;h4 id=&quot;四、缓存一致性协议&quot;&gt;四、缓存一致性协议&lt;/h4&gt;
&lt;p&gt;不难看出第一种需要频繁访问内存更新数据，执行效率比较低，而第二种会把更新数据推迟到最后一刻才会更新，读取内存，效率高（类似于&lt;code&gt;懒加载&lt;/code&gt;）。 &lt;strong&gt;缓存一致性协议(MESI)&lt;/strong&gt; 就是使用第二种方案，该协议主要是保证缓存内部数据的一致，不让系统数据混乱。&lt;code&gt;MESI&lt;/code&gt; 是指 4 种状态的首字母。每个缓存存储数据单元（Cache line）有 4 种不同的状态，用 2 个 bit 表示，状态和对应的描述如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;监听任务&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;strong&gt;M&lt;/strong&gt; 修改 (Modified)&lt;/td&gt;
&lt;td&gt;该 Cache line 有效，数据被修改了，和内存中的数据不一致，数据只存在于本 Cache 中&lt;/td&gt;
&lt;td&gt;Cache line 必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成 S（共享）状态之前被延迟执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;&lt;strong&gt;E&lt;/strong&gt; 独享、互斥 (Exclusive)&lt;/td&gt;
&lt;td&gt;该 Cache line 有效，数据和内存中的数据一致，数据只存在于本 Cache 中&lt;/td&gt;
&lt;td&gt;Cache line 必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成 S（共享）状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;S&lt;/strong&gt; 共享 (Shared)&lt;/td&gt;
&lt;td&gt;该 Cache line 有效，数据和内存中的数据一致，数据存在于很多 Cache 中&lt;/td&gt;
&lt;td&gt;Cache line 必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该 Cache line 变成无效&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;I&lt;/strong&gt; 无效 (Invalid)&lt;/td&gt;
&lt;td&gt;该 Cache line 无效&lt;/td&gt;
&lt;td&gt;无监听任务&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下面看看基于&lt;code&gt;缓存一致性协议&lt;/code&gt;是如何进行读取和写入操作的， 假设现在有一个双核的 &lt;code&gt;CPU&lt;/code&gt;，为了描述方便，简化一下只看其逻辑结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/08/17/8Zi1SKb4nAdEtgo.jpg&quot; alt=&quot;Xnip2020-08-17_08-44-37.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单核读取步骤&lt;/strong&gt;：&lt;code&gt;Core 0&lt;/code&gt; 发出一条从内存中读取 a 的指令，从内存通过 &lt;code&gt;BUS&lt;/code&gt; 读取 a 到 &lt;code&gt;Core 0&lt;/code&gt; 的缓存中，因为此时数据只在 &lt;code&gt;Core 0&lt;/code&gt; 的缓存中，所以将 &lt;code&gt;Cache line&lt;/code&gt; 修改为 &lt;strong&gt;E&lt;/strong&gt; 状态（独享），该过程用示意图表示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/17/dnmKYQ.jpg&quot; alt=&quot;dnmKYQ.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双核读取步骤&lt;/strong&gt;：首先 &lt;code&gt;Core 0&lt;/code&gt; 发出一条从内存中读取 a 的指令，从内存通过 &lt;code&gt;BUS&lt;/code&gt; 读取 a 到 &lt;code&gt;Core 0&lt;/code&gt; 的缓存中，然后将 &lt;code&gt;Cache line&lt;/code&gt; 置为 &lt;strong&gt;E&lt;/strong&gt; 状态，此时 &lt;code&gt;Core 1&lt;/code&gt; 发出一条指令，也是要从内存中读取 a，当 &lt;code&gt;Core 1&lt;/code&gt; 试图从内存读取 a 的时候， &lt;code&gt;Core 0&lt;/code&gt; 检测到了发生地址冲突（其它缓存读主存中该缓存行的操作），然后 &lt;code&gt;Core 0&lt;/code&gt; 对相关数据做出响应，a 存储于这两个核心 &lt;code&gt;Core 0&lt;/code&gt; 和 &lt;code&gt;Core 1&lt;/code&gt; 的缓存行中，然后设置其状态为 &lt;strong&gt;S&lt;/strong&gt; 状态（共享），该过程示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://imgchr.com/i/dnQsoV&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/17/dnQsoV.jpg&quot; alt=&quot;dnQsoV.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设此时 &lt;code&gt;Core 0&lt;/code&gt; 核心需要对 &lt;code&gt;a&lt;/code&gt; 进行修改了，首先 &lt;code&gt;Core 0&lt;/code&gt; 会将其缓存的 &lt;code&gt;a&lt;/code&gt; 设置为 &lt;strong&gt;M&lt;/strong&gt;（修改）状态，然后通知其它缓存了 &lt;code&gt;a&lt;/code&gt; 的其它核 &lt;code&gt;CPU&lt;/code&gt;（比如这里的 &lt;code&gt;Core 1&lt;/code&gt;）将内部缓存的 &lt;code&gt;a&lt;/code&gt; 的状态置为 &lt;strong&gt;I&lt;/strong&gt;（无效）状态，最后才对 &lt;code&gt;a&lt;/code&gt; 进行赋值操作。该过程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/17/dnQxeI.jpg&quot; alt=&quot;dnQxeI.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;细心的朋友们可能已经注意到了，上图中内存中 &lt;code&gt;a&lt;/code&gt; 的值（值为 &lt;code&gt;1&lt;/code&gt;）并不等于 &lt;code&gt;Core 0&lt;/code&gt; 核心中缓存的最新值（值为 &lt;code&gt;2&lt;/code&gt;），那么要什么时候才会把该值更新到内存中去呢？就是当 &lt;code&gt;Core 1&lt;/code&gt; 需要读取 &lt;code&gt;a&lt;/code&gt; 的值的时候，此时会通知 &lt;code&gt;Core 0&lt;/code&gt; 将 &lt;code&gt;a&lt;/code&gt; 的修改后的最新值同步到内存（&lt;code&gt;Memory&lt;/code&gt;）中去，在这个同步的过程中 &lt;code&gt;Core 0&lt;/code&gt; 中缓存的 &lt;code&gt;a&lt;/code&gt; 的状态会置为 &lt;strong&gt;E&lt;/strong&gt;（独享）状态，同步完成后将 &lt;code&gt;Core 0&lt;/code&gt; 和 &lt;code&gt;Core 1&lt;/code&gt; 中缓存的 &lt;code&gt;a&lt;/code&gt; 置为 &lt;strong&gt;S&lt;/strong&gt;（共享）状态，示意图描述该过程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/17/dn8HHA.jpg&quot; alt=&quot;dn8HHA.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，变量 &lt;code&gt;a&lt;/code&gt; 在 &lt;code&gt;CPU&lt;/code&gt; 的两个核 &lt;code&gt;Core 0&lt;/code&gt; 和 &lt;code&gt;Core 1&lt;/code&gt; 中回到了 &lt;strong&gt;S&lt;/strong&gt;（共享）状态了，以上只是简单的描述了一下大概的过程，实际上这些都是在 &lt;code&gt;CPU&lt;/code&gt; 的硬件层面上去保证的，而且操作比较复杂。&lt;/p&gt;
&lt;h4 id=&quot;五、总结&quot;&gt;五、总结&lt;/h4&gt;
&lt;p&gt;现在很多一些实现缓存功能的应用程序都是基于这些思想设计的，缓存把数据库中的数据进行缓存到速度更快的内存中，可以加快我们应用程序的响应速度，比如我们使用常见的 &lt;code&gt;Redis&lt;/code&gt; 数据库可能是采用下面这些策略：① 首先应用程序从缓存中查询数据，如果有就直接使用该数据进行相应操作后返回，如果没有则查询数据库，更新缓存并且返回。② 当我们需要更新数据时，先更新数据库，然后再让缓存失效，这样下次就会先查询数据库再回填到缓存中去，可以发现，实际上底层的一些思想都是相通的，不同的只是对于特定的场景可能需要增加一些额外的约束。基础知识才是技术这颗大树的根，我们先把根栽好了，剩下的那些枝和叶都是比较容易得到的东西了。&lt;/p&gt;
</description>
<pubDate>Thu, 24 Sep 2020 15:26:00 +0000</pubDate>
<dc:creator>mghio</dc:creator>
<og:description>一、前言 不同存储技术的访问时间差异很大，从 计算机层次结构 可知，通常情况下，从高层往底层走，存储设备变得更慢、更便宜同时体积也会更大，CPU 和内存之间的速度存在着巨大的差异，此时就会想到计算机科</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mghio/p/13727341.html</dc:identifier>
</item>
<item>
<title>Java创建多线程的四种方式 - 孤独患者的病态</title>
<link>http://www.cnblogs.com/gdhzdbh/p/13722034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gdhzdbh/p/13722034.html</guid>
<description>&lt;p&gt;在进行讲解线程的创建方式之前，首先了解下什么是进程，什么是线程，进程与线程之间的关系等&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是进程？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实当一个程序进入内存运行时，就是一个进程，进程是处于运行中的程序，并且具有一定的独立功能，进程是系统进行资源分配和调度的一个独立单位，具有独立性，动态性，并发性，这里的独立性指的是在系统中独立存在，有独立资源，有独立地址空间，没有进程允许，不会跟别的进程交互；动态性指的是进程在系统中有生命周期以及各种不同的状态，这也是跟程序的区别，进程加入了时间的概念；并发性指的是进程间可以在单处理器上并发执行，独立互不影响&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;那什么是线程呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;多线程其实就是扩展了多进程的概念，使一个进程可以同时并发处理多个任务，可以看成是轻量级的进程；线程是进程的组成部分，一个进程可以有多个线程，线程可以有自己的堆栈，程序计数器，局部变量，但是没有系统资源，线程是必须有一个父进程的，他与父进程的其他线程是共享全部资源，线程的调度与管理是由父进程负责为完成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单来说就是，操作系统可以同时执行多个任务，每个任务就是进程，进程可以同时执行多个任务，每个任务就是线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何创建多线程？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;创建多线程的方式可以概括为四种：&lt;/p&gt;
&lt;p&gt;1，继承Thread类，重写run()方法&lt;/p&gt;
&lt;p&gt;2，实现Runnable接口，重写run()方法&lt;/p&gt;
&lt;p&gt;3，实现Callable接口， 重写call()方法，借助Future执行&lt;/p&gt;
&lt;p&gt;4，借助Executor框架使用线程池创建线程&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;具体线程创建方式如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一：继承Thread类创建线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
class MyThead extends  Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot;: 继承Thread线程啦&quot;);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用线层的start（）方法启动线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 new MyThead().start();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1430507/202009/1430507-20200924002140066-1777193339.png&quot; alt=&quot;&quot; width=&quot;334&quot; height=&quot;42&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 注：Thread其实也是实现了Runnable接口&lt;/p&gt;
&lt;p&gt;二：实现Runnable接口创建线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
class MyRunnable implements  Runnable {
    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot;: 实现Runnable线程啦&quot;);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  借助Thread类调用线层的start()方法启动线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
new Thread(new MyRunnable()) .start();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　执行结果如下：　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1430507/202009/1430507-20200924002747210-672909585.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;45&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;三：使用Callable和Future接口创建线程&lt;/p&gt;
&lt;p&gt;Java5开始提供Callable接口，提供call方法作为线程的执行体，可以看成是Runnable接口的增强版本，增强点在于call()方法可以有返回值，并且可以抛出异常，由于Callable是新增的接口，不能作为Thread的target使用，所以Java5里提供了Future接口，该接口实现了Runnable，Future的实现类FutureTask类用来包装Callable对象，那么该怎么调用并获取返回值呢？下面用代码进行展示用法：&lt;/p&gt;
&lt;p&gt;创建Callable对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
class MyCallable  implements Callable&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; {

    public Map&amp;lt;String, String&amp;gt; call() throws Exception {
        HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;String, String&amp;gt;();
        map.put(&quot;returnCode&quot;, &quot;000000&quot;);
        map.put(&quot;messgae&quot;, Thread.currentThread().getName() + &quot;：Callable创建线程成功&quot;);
        return map;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　启动线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static void main(String[] args) {
        FutureTask&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;  future = new FutureTask(new MyCallable());
        new Thread(future).start();
        try {
            /**
             * get()返回Callable任务里的call()返回值
             * get方法是一个阻塞方法，对于task内置了一些任务状态，当任务状态为新建0或者初始化完成的时候1的时候会阻塞
             * 需要根据设置的时间阻塞，没有设置时会一直进行阻塞，一直到有结果返回
             */
            Map&amp;lt;String, String&amp;gt; resultMap = future.get();
            System.out.println(resultMap);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1430507/202009/1430507-20200924231847647-78420681.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;36&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;四：借助Executor框架使用线程池创建线程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; Executors提供了一系列工厂方法用于创先线程池，创建的线程池都实现了ExecutorService接口，下面为常用的线程池：&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;创建固定数目线程的线程池，&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;操作一个共享的无边界队列&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;，当所有线程都处于活动状态时，额外的任务被提交它们将在队列中等待，直到线程可用。当有线程池挂掉会重新创建一个新的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;创建一个可缓存的线程池，可以创建的范围是0-&lt;strong&gt;Integer.MAX_VALUE,当有可用线程时直接使用，当没有时创建新的线程并添加到缓存中，提供使用，这种类型的线程池，适合&lt;/strong&gt;&lt;strong&gt;执行许多短期的异步任务的程序，是在执行方法之前创建线程，60秒内未使用的线程会被终止并删除缓存，&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;wiz_cm_1600852276911_102&quot; class=&quot;wiz-code-container&quot; data-mode=&quot;SQL&quot; data-theme=&quot;default&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;());
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;创建一个单线程化的Executor，只会有一个线程池，当这个线程池挂掉会自动创建一个新的&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;wiz_cm_1600852320736_6800&quot; class=&quot;wiz-code-container&quot; data-mode=&quot;SQL&quot; data-theme=&quot;default&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()));
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div id=&quot;wiz_cm_1600852431719_1665&quot; class=&quot;wiz-code-container&quot; data-mode=&quot;SQL&quot; data-theme=&quot;default&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
 }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;一般来说，CachedTheadPool在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选，只有当这种方式会引发问题时（比如需要大量长时间面向连接的线程时），才需要考虑用FixedThreadPool&lt;/p&gt;

&lt;p&gt;下面提供一个固定大小的线程池的使用案例：&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    public static void main(String[] args) {
        try {
            ExecutorService threadPool = Executors.newFixedThreadPool(10);
            for (int i = 0; i &amp;lt;15; i++) {&lt;br/&gt;　　　　　　　　　 //主要通过submit方法执行调用，可以接收Runnable，Callable
                Future&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; future = threadPool.submit(new MyCallable());
                Map&amp;lt;String, String&amp;gt; resultMap = future.get();
                System.out.println(resultMap);
            }
            threadPool.shutdown();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1430507/202009/1430507-20200924231744436-840269540.png&quot; alt=&quot;&quot; width=&quot;601&quot; height=&quot;380&quot; loading=&quot;lazy&quot;/&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;下一篇再介绍相关线程的其他知识，欢迎讨论，一起学习&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 24 Sep 2020 15:24:00 +0000</pubDate>
<dc:creator>孤独患者的病态</dc:creator>
<og:description>在进行讲解线程的创建方式之前，首先了解下什么是进程，什么是线程，进程与线程之间的关系等 什么是进程？ 其实当一个程序进入内存运行时，就是一个进程，进程是处于运行中的程序，并且具有一定的独立功能，进程是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gdhzdbh/p/13722034.html</dc:identifier>
</item>
<item>
<title>Spring系列之aAOP  AOP是什么？+xml方式实现aop+注解方式实现aop - 一只胡说八道的猴子</title>
<link>http://www.cnblogs.com/pjhaymy/p/13727263.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pjhaymy/p/13727263.html</guid>
<description>&lt;h2 id=&quot;spring系列之aop-aop是什么？xml方式实现aop注解方式实现aop&quot;&gt;Spring系列之aop aop是什么？+xml方式实现aop+注解方式实现aop&lt;/h2&gt;
&lt;h2 id=&quot;什么是aop？&quot;&gt;什么是AOP？&lt;/h2&gt;
&lt;p&gt;AOP为Aspect Oriented Programming 的缩写，意识为面向切面的编程，是通过&lt;strong&gt;预编译&lt;/strong&gt;和&lt;strong&gt;运行期动态代理&lt;/strong&gt;实现程序功能的统一维护的一种技术&lt;br/&gt;AOP是OOP（Object Oriented Programmin 面向对象编程）的延续，是软件开发中的一个热点，也是框架中的一个重要内容，是函数式编程的一种衍生范型，利用AOP可以对业务逻辑的各个部分进行隔离，也使业务逻辑各部分的耦合性降低，提高程序的可重用性，同时提高了开发的效率&lt;br/&gt;&lt;strong&gt;我先来讲讲什么是切面&lt;/strong&gt;&lt;br/&gt;把一块蛋糕切成两块，这个切口就是切面，；炒饭的时候，锅和锅铲就是切面；web层级设计中，web层-&amp;gt;网关层-&amp;gt;服务层-&amp;gt;数据层，每一层之间也是一个切面。编程中，对与对象之间，方法与方法之间，模块与模块之间都是一个个切面。&lt;/p&gt;
&lt;h2 id=&quot;我们使用一个银行管理系统来说说为什么要使用面向切面编程。&quot;&gt;我们使用一个银行管理系统来说说为什么要使用面向切面编程。&lt;/h2&gt;
&lt;p&gt;如图银行的取款业务和查询余额业务有交叉的业务逻辑（所谓交叉业务逻辑是与主业务无关的代码，比如安全检查，事务，日志等等），这里指的是验证用户的业务。这会导致代码纠缠，交叉业务逻辑与主业务逻辑混合在一起，这会导致业务逻辑的混合不清，这时候就要用到AOP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200923113241684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用AOP可以帮助我们简化代码，我们在写代码的时候可不写这个验证用户的业务，可以在另一个地方写好验证用户的代码，然后告诉Spring那几个地方需要这些代码，让Spring加过去即可，如果有多个控制流的话，会大大的减少时间，而AOP不会把代码加入到源文件中但是他会正确的影响最后的机器代码&lt;/p&gt;
&lt;p&gt;上面那个 验证用户 的方框，我们可以把它当成一块板子，在这块板子上插入一些控制流程，这块板子就可以当成是 AOP 中的一个切面。所以 AOP 的本质是在一系列的纵向的控制流程中，把那些相同的子流程提取成一个横向的面，把纵向流程画成一条直线，而 AOP 相当于把相同的地方连起来了（这幅图是真的形象，好好体会一下应该不难），这个验证用户的子流程 就成了一条直线，也可以理解成一个切面，这里只插了三个流程，如果其他流程也需要这个子流程，也可以插到其他地方去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200923135920272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;aop的优势与作用&quot;&gt;AOP的优势与作用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：在不修改源码的情况下对方法进行增强&lt;br/&gt;&lt;strong&gt;优势&lt;/strong&gt;：提高代码的可复用性，提高开发效率，便于维护&lt;/p&gt;
&lt;h2 id=&quot;aop的底层实现&quot;&gt;AOP的底层实现&lt;/h2&gt;
&lt;p&gt;AOP的底层是通过Spring动态代理技术实现的，在运行期间通过动态代理，获取代理对象，代理方法执行时增强功能介入，在去调用目标对象的方法，从而完成功能增强。&lt;/p&gt;
&lt;h2 id=&quot;aop的动态代理技术&quot;&gt;AOP的动态代理技术&lt;/h2&gt;
&lt;h2 id=&quot;jdk代理&quot;&gt;jdk代理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;jdk代理&lt;/strong&gt;：基于接口的动态代理技术&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200923140838826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cglib代理&lt;/strong&gt;：基于父类的动态代理技术&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200923140851425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;我们来逐一讲解这两个代理方式的差别&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;jdk代理&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;demo内容&lt;/strong&gt;：user类实现一个userImp接口，对user类进行动态代理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;user类代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;package com.pjh.user;
public interface user {
    public void save();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;userImp代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;package com.pjh.user.Imp;
import com.pjh.user.user;
public class userImp implements user {
    public void save() {
        System.out.println(&quot;save run....&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;对save方法进行增强&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里使用两种方式&lt;br/&gt;&lt;strong&gt;方式一匿名内部类：即InvocationHandler直接使用匿名内部类的方式来创建&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;package com.pjh.test;
import com.pjh.user.Imp.userImp;
import com.pjh.user.user;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
public class main {
    public static void main(String[] args) {
      //创建目标对象
        final userImp userImp=new userImp();
      //调用proxy类的静态方法来创建代理对象
      //Proxy.newProxyInstance（类加载器，获取目标对象的接口，实现动态代理接口）
       user userproxy = (user)Proxy.newProxyInstance(userImp.class.getClassLoader(),userImp.getClass().getInterfaces(), new InvocationHandler() {
       //invoke（代理类，被代理的方法，参数）
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(&quot;前置增强代码&quot;);
                      //当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用
                Object invoke = method.invoke(userImp);
                System.out.println(&quot;后置增强代码&quot;);
                return invoke;
            }
        });
       userproxy.save();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;br/&gt;成功对方法进行了增强&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200923154609563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;strong&gt;方法二使用一个类继承自InvocationHandler来实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编写InvocationHandler实现类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;package com.pjh.proxy;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
public class InvocationHandlerImp implements InvocationHandler {
    //所有类均继承自object类
    private Object object;
    //写一个带参构造的方法，来引入目标对象

    public InvocationHandlerImp(Object object) {
        this.object = object;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;增强前&quot;);
        Object invoke = method.invoke(object, args);
        System.out.println(&quot;执行后的方法&quot;);
        return invoke;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;编写测试类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;package com.pjh.test;
import com.pjh.proxy.InvocationHandlerImp;
import com.pjh.user.Imp.userImp;
import com.pjh.user.user;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
public class Test {
    public static void main(String[] args) {
        //创建目标对象，即代理的真实对象
        userImp person = new userImp();
        //获取处理器实现类InvocationHandlerImp
        InvocationHandlerImp invocationHandlerImp = new InvocationHandlerImp(person);
        //获取代理对象
       user o = (user)Proxy.newProxyInstance(userImp.class.getClassLoader(),
               person.getClass().getInterfaces(),
                invocationHandlerImp);
       //调用方法
       o.save();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200923160118619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200923160910193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;放这张表情包的目的是想提醒大家休息一下想必大家都看了很久的电脑了，可以开窗看看外面，休息休息&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;cglib的动态代理&quot;&gt;Cglib的动态代理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这里就简单的讲一下流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;这里仅仅是一个类没有实现任何接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;package com.pjh.user;
public class person {
    public void save(){
        System.out.println(&quot;save&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;主函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;package com.pjh.test;
import com.pjh.user.person;
import org.springframework.cglib.proxy.Enhancer;
import org.springframework.cglib.proxy.MethodInterceptor;
import org.springframework.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;
public class test2 {
    public static void main(String[] args) {
        //设置目标对象
        final person one = new person();
        //创建增强器
        Enhancer enhancer = new Enhancer();
        //设置父类
        enhancer.setSuperclass(person.class);
        //设置回调
        enhancer.setCallback(new MethodInterceptor() {
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                System.out.println(&quot;前置增强代码&quot;);
                Object invoke = method.invoke(one, objects);
                System.out.println(&quot;后置增强&quot;);
                return invoke;
            }
        });
        //获取代理对象
        person oneproxy = (person)enhancer.create();
        //调用增强后的方法
        oneproxy.save();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;aop相关概念&quot;&gt;AOP相关概念&lt;/h2&gt;
&lt;p&gt;String 的AOP实现底层就是对上面的动态代理进行了封装，封装后我们只需要对关注的部分进行代码进行编写，并通过配置的方式完成对指定目标的方法增强&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AOP的部分术语&lt;/strong&gt;&lt;br/&gt;Target（目标对象）：代理的目标对象&lt;br/&gt;Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类&lt;br/&gt;Joinpoint（连接点）：所谓连接点指那些被拦截到的点，在spring中这些点指的是方法，因为spring是只支持方法类型的连接点&lt;br/&gt;Pointcut（切入点）：所谓切入点是指我们要对哪些Joinpoint进行拦截的定义，&lt;strong&gt;即被增强的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Jointpoint不一定是Pointcut但是Pointcut一定是Joinpoint&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200923200012320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Advice（通知/增强）：拦截到jointpoint之后要做的事情就是通知，&lt;strong&gt;封装增强业务逻辑的方法&lt;/strong&gt;&lt;br/&gt;Aspect（切面）:是切入点和通知的结合&lt;br/&gt;Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程，spring采用动态织入代理，而Aspect采用编译织入和类装载期织入，&lt;strong&gt;切点与通知结合的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AOP的实现内容&lt;/strong&gt;&lt;br/&gt;Spring框架监控切入点方法的执行，只要检测到切入点被执行，就会使用代理机制，创建代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AOP底层使用什么代理机制&lt;/strong&gt;&lt;br/&gt;在spring中，框架会根据是否实现了接口来选择使用那种动态代理方式&lt;/p&gt;
&lt;h2 id=&quot;基于xml的aop开发&quot;&gt;基于XML的AOP开发&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;快速入门&lt;/strong&gt;&lt;br/&gt;1.导入AOP的相关配置坐标&lt;br/&gt;2.创建目标接口和目标类（内有切入点）&lt;br/&gt;3.创建切面类（内部有增强方法）&lt;br/&gt;4.将目标类和切面类的对象创建权交给spring&lt;br/&gt;5.在applicationContext.xml中配置织入关系&lt;br/&gt;6.测试代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.导入AOP的相关坐标&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.0.2.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.0.3.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.8.13&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;创建接口与实现类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;package com.pjh.user;

public interface userInterface {
    public void save();
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实现类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;package com.pjh.user;

public class user implements userInterface{
    public void save() {
        System.out.println(&quot;save run...&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;创建切面类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;package com.pjh.enhance;
public class enhance {
    public  void enhance(){
        System.out.println(&quot;这是增强代码！！！！&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;将目标类和切面类的对象创建权交给spring&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;&amp;lt;bean id=&quot;daoImp&quot; class=&quot;com.pjh.dao.Imp.daoImp&quot;/&amp;gt;
    &amp;lt;bean id=&quot;aspect&quot; class=&quot;com.pjh.aspect.aspect&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;引入命名空间与约束路径&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置切点表达式和前置增强之间的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;切点表达式的配置语法&lt;/strong&gt;&lt;br/&gt;excution（【修饰符】返回值类型 包名.类名.方法名（参数））&lt;br/&gt;&lt;strong&gt;通知的配置语法&lt;/strong&gt;&lt;br/&gt;&amp;lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式&quot;&amp;gt;&amp;lt;/aop:通知类型&amp;gt;&lt;/p&gt;
&lt;p&gt;这里先写个简单的格式后面再给大家深入讲&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;aop:config &amp;gt;
       &amp;lt;!--要切入的类--&amp;gt;
       &amp;lt;aop:aspect ref=&quot;enhance&quot;&amp;gt;
           &amp;lt;!--切入后的增强方法--&amp;gt;
           &amp;lt;!--这是一个前置增强--&amp;gt;
           &amp;lt;!--method切入后的增强方法--&amp;gt;
           &amp;lt;!--pointcut对什么类方法执行的时候进行增强--&amp;gt;
           &amp;lt;aop:before
                   method=&quot;enhance&quot; pointcut=&quot;execution(public void com.pjh.user.user.save())&quot;&amp;gt;&amp;lt;/aop:before&amp;gt;
       &amp;lt;/aop:aspect&amp;gt;
   &amp;lt;/aop:config&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import com.pjh.user.userInterface;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)
public class test {
    /*如果是继承自接口的一定要使用接口进行定义否则会报错*/
@Autowired
private userInterface user;
    @Test
    public  void test1(){
         user.save();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200924210148151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;**&lt;/p&gt;
&lt;h2 id=&quot;切点表达式的花样写法&quot;&gt;切点表达式的花样写法&lt;/h2&gt;
&lt;p&gt;**&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200924210719985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;strong&gt;表达式语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;excution（【修饰符】 返回值类型 包名.类名.方法名（参数））&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值的修饰符可省略&lt;br/&gt;返回值的类名，包名，方法名可以使用&lt;/strong&gt;“ * ”&lt;strong&gt;星号代表任意&lt;br/&gt;包名与类名之间的一个点&lt;/strong&gt;&quot; . &quot;&lt;strong&gt;代表当前包下的所有类，两个点&lt;/strong&gt;“ .. ”&lt;strong&gt;代表当前包及其子包下的所有类&lt;br/&gt;参数列表可以使用两个点 &lt;strong&gt;&quot; . . &quot;&lt;/strong&gt; 表示任意个数，任意类型的参数列表&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//user类下的save方法增强
execution(public void com.pjh.one.user.save())
//对user类下的所有放回值为void的方法进行增强
execution(public void com.pjh.one.user.*(..))
//one包下所有类的所有方法进行增强
execution(* com.pjh.*.*.*(..))
//one包包括其子包下所有类的所有方法进行增强
execution(*  com.pjh..*.*.*(..))
//任何包任何类任何方法
execution(*  *.*..*.*. * (..))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;切点表达式的抽取&lt;/strong&gt;&lt;br/&gt;当多个增强切点表达式相同时，可以将切点表达式进行抽取。在增强中使用pointcut-ref属性替代pointcut属性来引用切点表达式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;aop:config &amp;gt;
       &amp;lt;aop:aspect ref=&quot;enhance&quot;&amp;gt;
           &amp;lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(public void com.pjh.user.user.save())&quot;/&amp;gt;
           &amp;lt;aop:before
                   method=&quot;enhance&quot; pointcut-ref=&quot;myPointcut&quot;&amp;gt;&amp;lt;/aop:before&amp;gt;
       &amp;lt;/aop:aspect&amp;gt;
   &amp;lt;/aop:config&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;**&lt;/p&gt;
&lt;h2 id=&quot;通知的类型&quot;&gt;通知的类型&lt;/h2&gt;
&lt;p&gt;**&lt;br/&gt;通知的配置语法&lt;br/&gt;&amp;lt;aop：通知的类型 method=“切面中的方法名” pointcut=“切点表达式”/&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200924214648197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;简单的小总结&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;&amp;lt;aop:config &amp;gt;
       &amp;lt;aop:aspect ref=&quot;切入类的名称&amp;gt;
           &amp;lt;aop:before
                   method=&quot;切入方法的名称e&quot; pointcut=&quot;切点表达式&quot;&amp;gt;&amp;lt;/aop:before&amp;gt;
       &amp;lt;/aop:aspect&amp;gt;
   &amp;lt;/aop:config&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通知的类型&lt;/strong&gt;：前置通知、后置通知、环绕通知、异常抛出通知、最终通知&lt;br/&gt;&lt;strong&gt;切点表达式的写法&lt;/strong&gt;：&lt;br/&gt;excution（【修饰符】返回值类型 包名.类名.方法名（参数））&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面我们再来讲讲更加简单的方法，即使用注解的方式&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;基于注解的aop开发&quot;&gt;基于注解的AOP开发&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注解aop的开发步骤&lt;/strong&gt;&lt;br/&gt;1.使用@Aspect标注切面类&lt;br/&gt;2.使用@通知注解标注通知方法&lt;br/&gt;3.在配置文件中配置aop自动代理&amp;lt;aop：aspectj-autoproxy&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200924220906464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;标注为一个切面类@Aspect&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Aspect
public class enhance {
  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用注解来抽取切点表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Pointcut(”注解表达式“)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/&lt;em&gt;切点表达式方法的抽取，抽取方法是在切点内定义方法，&lt;br/&gt;在方法内使用 @Pointcut注解切点表达式，然后在增强注解中进行引用&lt;/em&gt;/&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @Pointcut(&quot;execution(public void com.pjh.user.user.save())&quot;)
    public void mypoint(){}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;以上就是spring的aop的概念及其使用方法，我会不断的学习，也会不断更新我的学习文章，主要有java和数据结构两个方面，有想要一起学习的伙伴可以私信或则关注我，共勉&quot;&gt;以上就是Spring的AOP的概念及其使用方法，我会不断的学习，也会不断更新我的学习文章，主要有java和数据结构两个方面，有想要一起学习的伙伴可以私信或则关注我，共勉&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200924230300944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BqaDg4,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Sep 2020 15:04:00 +0000</pubDate>
<dc:creator>一只胡说八道的猴子</dc:creator>
<og:description>Spring系列之aop aop是什么？+xml方式实现aop+注解方式实现aop 什么是AOP？ AOP为Aspect Oriented Programming 的缩写，意识为面向切面的编程，是通过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pjhaymy/p/13727263.html</dc:identifier>
</item>
<item>
<title>gRPC-go 入门（1）：Hello World - 红鸡菌</title>
<link>http://www.cnblogs.com/hongjijun/p/13724738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongjijun/p/13724738.html</guid>
<description>&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;在这篇文章中，主要是跟你介绍一下&lt;code&gt;gRPC&lt;/code&gt;这个东西。&lt;/p&gt;
&lt;p&gt;然后，我会创建一个简单的练习项目，作为&lt;code&gt;gRPC&lt;/code&gt;的Hello World项目。&lt;/p&gt;
&lt;p&gt;在这个项目中，只有很简单的一个RPC函数，用于说明&lt;code&gt;gRPC&lt;/code&gt;的工作方式。&lt;/p&gt;
&lt;p&gt;此外，我也会跟你分享一下我初次接触&lt;code&gt;gRPC&lt;/code&gt;所遇到的一些坑，主要是在&lt;code&gt;protocol buffer&lt;/code&gt;的&lt;code&gt;proto-gen-go&lt;/code&gt;插件上面。&lt;/p&gt;
&lt;h2 id=&quot;1-简单介绍&quot;&gt;1. 简单介绍&lt;/h2&gt;
&lt;p&gt;在这一节的内容中，我将简单的跟你介绍一下&lt;code&gt;gRPC&lt;/code&gt;这个东西。&lt;br/&gt;&lt;code&gt;RPC&lt;/code&gt;的全称是&lt;code&gt;Remote Procedure Call&lt;/code&gt;，远程过程调用。这是一种协议，是用来屏蔽分布式计算中的各种调用细节，使得你可以像是本地调用一样直接调用一个远程的函数。&lt;br/&gt;而&lt;code&gt;gRPC&lt;/code&gt;又是什么呢？用官方的话来说：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;A high-performance, open-source universal RPC framework&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;gRPC&lt;/code&gt;是一个高性能的、开源的通用的RPC框架。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;gRPC&lt;/code&gt;中，我们称调用方为&lt;code&gt;client&lt;/code&gt;，被调用方为&lt;code&gt;server&lt;/code&gt;。&lt;br/&gt;跟其他的&lt;code&gt;RPC&lt;/code&gt;框架一样，&lt;code&gt;gRPC&lt;/code&gt;也是基于”服务定义“的思想。简单的来讲，就是我们通过某种方式来描述一个服务，这种描述方式是语言无关的。在这个”服务定义“的过程中，我们描述了我们提供的服务服务名是什么，有哪些方法可以被调用，这些方法有什么样的入参，有什么样的回参。&lt;/p&gt;
&lt;p&gt;也就是说，在定义好了这些服务、这些方法之后，&lt;code&gt;gRPC&lt;/code&gt;会屏蔽底层的细节，&lt;code&gt;client&lt;/code&gt;只需要直接调用定义好的方法，就能拿到预期的返回结果。对于&lt;code&gt;server&lt;/code&gt;端来说，还需要实现我们定义的方法。同样的，&lt;code&gt;gRPC&lt;/code&gt;也会帮我们屏蔽底层的细节，我们只需要实现所定义的方法的具体逻辑即可。&lt;/p&gt;
&lt;p&gt;你可以发现，在上面的描述过程中，所谓的”服务定义“，就跟定义接口的语义是很接近的。我更愿意理解为这是一种”约定“，双方约定好接口，然后&lt;code&gt;server&lt;/code&gt;实现这个接口，&lt;code&gt;client&lt;/code&gt;调用这个接口的代理对象。至于其他的细节，交给&lt;code&gt;gRPC&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此外，&lt;code&gt;gRPC&lt;/code&gt;还是语言无关的。你可以用C++作为服务端，使用Golang、Java等作为客户端。为了实现这一点，我们在”定义服务“和在编码和解码的过程中，应该是做到&lt;strong&gt;语言无关的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面放一张官网上面的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998080/202009/1998080-20200924161632078-309009747.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，&lt;code&gt;gRPC&lt;/code&gt;使用了&lt;code&gt;Protocol Buffers&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在这里我不会展开来讲&lt;code&gt;Protocol Buffers&lt;/code&gt;这个东西，你可以把他当成一个代码生成工具以及序列化工具。这个工具可以把我们定义的方法，转换成特定语言的代码。比如你定义了一种类型的参数，他会帮你转换成&lt;code&gt;Golang&lt;/code&gt;中的&lt;code&gt;struct 结构体&lt;/code&gt;，你定义的方法，他会帮你转换成&lt;code&gt;func 函数&lt;/code&gt;。此外，在发送请求和接受响应的时候，这个工具还会完成对应的编码和解码工作，将你即将发送的数据编码成&lt;code&gt;gRPC&lt;/code&gt;能够传输的形式，又或者将即将接收到的数据解码为编程语言能够理解的数据格式。&lt;/p&gt;
&lt;p&gt;对&lt;code&gt;gRPC&lt;/code&gt;的简单介绍就到这里，下面的内容我们直接开始实践。&lt;/p&gt;
&lt;h2 id=&quot;2-环境配置&quot;&gt;2. 环境配置&lt;/h2&gt;
&lt;p&gt;在这一节中，可能很多内容会不那么的适用。&lt;/p&gt;
&lt;p&gt;但是限于篇幅，我没有列举所有的安装方式。如果在安装的过程中你遇到了问题，可以在网上搜索解决，也可以在文章末尾找到我的联系方式，我们一起研究。&lt;/p&gt;
&lt;h3 id=&quot;21-grpc&quot;&gt;2.1 gRPC&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;go get google.golang.org/grpc
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一步安装的是&lt;code&gt;gRPC&lt;/code&gt;的核心库，但是这一步是需要（特别的上网方式）的。所以如果在安装过程中出错了，你可以科学一波，也可以找一找其他的安装方法。&lt;/p&gt;
&lt;h3 id=&quot;22-protocol-buffers&quot;&gt;2.2 protocol buffers&lt;/h3&gt;
&lt;p&gt;在Mac OS中，直接用brew安装。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;brew info protobuf
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;23-protoc-gen-go&quot;&gt;2.3 protoc-gen-go&lt;/h3&gt;
&lt;p&gt;上一步安装的是protocol编译器。而上文中我们提到了可以生成各种不同语言的代码。因此，除了这个编译器，我们还需要配合各个语言的代码生成工具。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;Golang&lt;/code&gt;来说，称为&lt;code&gt;protoc-gen-go&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不过在这儿有个小小的坑，&lt;code&gt;github.com/golang/protobuf/protoc-gen-go&lt;/code&gt;和&lt;code&gt;google.golang.org/protobuf/cmd/protoc-gen-go&lt;/code&gt;是不同的。&lt;/p&gt;
&lt;p&gt;区别在于前者是旧版本，后者是google接管后的新版本，他们之间的API是不同的，也就是说用于生成的命令，以及生成的文件都是不一样的。&lt;/p&gt;
&lt;p&gt;因为目前的&lt;code&gt;gRPC-go&lt;/code&gt;源码中的example用的是后者的生成方式，为了与时俱进，本文也采取最新的方式。&lt;/p&gt;
&lt;p&gt;你需要安装两个库：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;go install google.golang.org/protobuf/cmd/protoc-gen-go
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为这些文件在安装&lt;code&gt;grpc&lt;/code&gt;的时候，已经下载下来了，因此使用&lt;code&gt;install&lt;/code&gt;命令就可以了，而不需要使用&lt;code&gt;get&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;然后你看你的$GOPATH路径，应该有标1和2的两个文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998080/202009/1998080-20200924161817553-1294594791.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，所有的准备工作已经完成。&lt;/p&gt;
&lt;h2 id=&quot;3-proto文件创建&quot;&gt;3. proto文件创建&lt;/h2&gt;
&lt;p&gt;在开始开发之前，先说说我们的目标。&lt;/p&gt;
&lt;p&gt;在这个&lt;code&gt;grpc-practice&lt;/code&gt;项目中，我希望实现一个功能，客户端可以发送消息给服务端，服务端收到消息后，返回响应给客户端。&lt;/p&gt;
&lt;p&gt;正如前面所说的，在开发&lt;code&gt;server&lt;/code&gt;与&lt;code&gt;client&lt;/code&gt;之前，我们需要先定义服务。&lt;/p&gt;
&lt;p&gt;因此，在这一节的内容中，我将向你介绍proto文件的编写。&lt;/p&gt;
&lt;h3 id=&quot;31-项目结构&quot;&gt;3.1 项目结构&lt;/h3&gt;
&lt;p&gt;在这之前，先让我们看看整个项目的初始结构。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998080/202009/1998080-20200924161834930-1252892090.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;server&lt;/code&gt;和&lt;code&gt;client&lt;/code&gt;我们先不管，在这一节内容中我们先编写`*.proto'文件。&lt;/p&gt;
&lt;p&gt;在proto文件夹中创建&lt;code&gt;message.proto&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;在文件的第一行，我们写上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;syntax = &quot;proto3&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是在说明我们使用的是&lt;code&gt;proto3&lt;/code&gt;语法。&lt;/p&gt;
&lt;p&gt;然后我们应该写上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;option go_package = &quot;.;message&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这部分的内容是关于最后生成的go文件是处在哪个目录哪个包中，&lt;code&gt;.&lt;/code&gt;代表在当前目录生成，&lt;code&gt;message&lt;/code&gt;代表了生成的&lt;code&gt;go文件&lt;/code&gt;的包名是&lt;code&gt;message&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后我们需要定义一个服务，在这个服务中需要有一个方法，这个方法可以接受客户端的参数，再返回服务端的响应。&lt;/p&gt;
&lt;p&gt;那么我们可以这么写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service MessageSender {
  rpc Send(MessageRequest) returns (MessageResponse) {}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实很容易可以看出，我们定义了一个service，称为&lt;code&gt;MessageSender&lt;/code&gt;，这个服务中有一个rpc方法，名为&lt;code&gt;Send&lt;/code&gt;。这个方法会发送一个&lt;code&gt;MessageRequest&lt;/code&gt;，然后返回一个&lt;code&gt;MessageResponse&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;让我们在看看具体的&lt;code&gt;MessageRequest&lt;/code&gt;和&lt;code&gt;MessageResponse&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message MessageResponse {
  string responseSomething = 1;
}

message MessageRequest {
  string saySomething = 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;message&lt;/code&gt;关键字，其实你可以理解为&lt;code&gt;Golang&lt;/code&gt;中的结构体。这里比较特别的是变量后面的“赋值”。注意，这里并不是赋值，而是在定义这个变量在这个message中的位置。更具体的内容我应该会在源码分析部分讲到。&lt;/p&gt;
&lt;p&gt;在编写完上面的内容后，在&lt;code&gt;/grpc-practice/src/helloworld/proto&lt;/code&gt;目录下执行如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protoc --go_out=. message.proto
protoc --go-grpc_out=. message.proto
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两条命令会生成如下的两个文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998080/202009/1998080-20200924161855325-187405311.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这两个文件中，包含了我们定义方法的go语言实现，也包含了我们定义的请求与相应的go语言实现。&lt;/p&gt;
&lt;p&gt;简单来讲，就是&lt;code&gt;protoc-gen-go&lt;/code&gt;已经把你定义的语言无关的&lt;code&gt;message.proto&lt;/code&gt;转换为了go语言的代码，以便&lt;code&gt;server&lt;/code&gt;和&lt;code&gt;client&lt;/code&gt;直接使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意，到了这一部分你可能会有一些疑惑。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在网上的一些教程中，有这样的生成方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protoc --go_out=plugins=grpc:. helloworld.proto
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种生成方式，使用的就是&lt;code&gt;github&lt;/code&gt;版本的&lt;code&gt;protoc-gen-go&lt;/code&gt;，而目前这个项目已经由Google接管了。&lt;/p&gt;
&lt;p&gt;并且，如果使用这种生成方式的话，并不会生成上图中的&lt;code&gt;xxx_grpc.pb.go&lt;/code&gt;与&lt;code&gt;xxx.pb.go&lt;/code&gt;两个文件，只会生成&lt;code&gt;xxx.pb.go&lt;/code&gt;这种文件。&lt;/p&gt;
&lt;p&gt;此外，你也可能遇到这种错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protoc-gen-go-grpc: program not found or is not executable
Please specify a program using absolute path or make sure the program is available in your PATH system variable
--go-grpc_out: protoc-gen-go-grpc: Plugin failed with status code 1.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为你没有安装&lt;code&gt;protoc-gen-go-grpc&lt;/code&gt;这个插件，这个问题在本文中应该不会出现。&lt;/p&gt;
&lt;p&gt;你还可能会遇到这种问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--go_out: protoc-gen-go: plugins are not supported; use 'protoc --go-grpc_out=...' to generate gRPC
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为你安装的是更新版本的&lt;code&gt;protoc-gen-go&lt;/code&gt;，但是你却用了旧版本的生成命令。&lt;/p&gt;
&lt;p&gt;但是这两种方法都是可以完成目标的，只不过&lt;code&gt;api&lt;/code&gt;不太一样。本文是基于Google版本的&lt;code&gt;protoc&lt;/code&gt;-gen-go进行示范。&lt;/p&gt;
&lt;p&gt;至于其他更详细的资料，你可以在这里看到：&lt;a href=&quot;https://github.com/protocolbuffers/protobuf-go/releases/tag/v1.20.0#v1.20-generated-code&quot;&gt;https://github.com/protocolbuffers/protobuf-go/releases/tag/v1.20.0#v1.20-generated-code&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-服务端&quot;&gt;4. 服务端&lt;/h2&gt;
&lt;h3 id=&quot;41-注册&quot;&gt;4.1 注册&lt;/h3&gt;
&lt;p&gt;我们在server目录下面创建一个&lt;code&gt;server.go&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;在main函数中加入如下的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;srv := grpc.NewServer()
message.RegisterMessageSenderService(srv, &amp;amp;message.MessageSenderService{})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很容易可以看出，我们在这一部分创建了一个Server，然后注册了我们的Service。&lt;/p&gt;
&lt;p&gt;在注册函数的第二个参数中，我们传进去了一个&lt;code&gt;MessageSenderService&lt;/code&gt;实例。&lt;/p&gt;
&lt;p&gt;来看看这个实例有什么样的结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type MessageSenderService struct {
        Send func(context.Context, *MessageRequest) (*MessageResponse, error)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，这个实例里面有一个方法，这个方法就是我们定义的send方法。也就是说，这一部分是需要我们在&lt;code&gt;Server&lt;/code&gt;端实现这个send方法的。&lt;/p&gt;
&lt;p&gt;因此我们创建这么一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func handleSendMessage(ctx context.Context, req *message.MessageRequest) (*message.MessageResponse, error) {
        log.Println(&quot;receive message:&quot;, req.GetSaySomething())
        resp := &amp;amp;message.MessageResponse{}
        resp.ResponseSomething = &quot;roger that!&quot;
        return resp, nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，“实现定义的方法”，并不是说我们需要创建一个同名的方法，而是说我们需要创建一个有相同函数签名的方法。也就是说，需要有相同的入参，出参。&lt;/p&gt;
&lt;p&gt;然后我们将这个方法写进注册函数中，变成了这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;message.RegisterMessageSenderService(srv, &amp;amp;message.MessageSenderService{
                Send: handleSendMessage,
        })
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们已经成功的在&lt;code&gt;server&lt;/code&gt;端实现了我们声明的方法了。&lt;/p&gt;
&lt;h3 id=&quot;42-监听&quot;&gt;4.2 监听&lt;/h3&gt;
&lt;p&gt;其实这个过程跟golang的web服务器是很像的，也是创建Handler，然后对端口进行监听。&lt;/p&gt;
&lt;p&gt;那么到了这一步也一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;listener, err := net.Listen(&quot;tcp&quot;, &quot;:12345&quot;)
if err != nil {
        log.Fatalf(&quot;failed to listen: %v&quot;, err)
}

err = srv.Serve(listener)
if err != nil {
        log.Fatalf(&quot;failed to serve: %v&quot;, err)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;监听&lt;code&gt;12345&lt;/code&gt;端口的TCP连接，然后启动服务器。&lt;/p&gt;
&lt;p&gt;至此，服务端开发完毕。&lt;/p&gt;
&lt;h2 id=&quot;5-客户端&quot;&gt;5. 客户端&lt;/h2&gt;
&lt;p&gt;在客户端中，我们应该先与&lt;code&gt;server&lt;/code&gt;端建立连接，然后才能够调用各种方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;conn, err := grpc.Dial(&quot;127.0.0.1:12345&quot;, grpc.WithInsecure(), grpc.WithBlock())
if err != nil {
        log.Fatalf(&quot;did not connect: %v&quot;, err)
}
defer conn.Close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码，就是跟本地的&lt;code&gt;12345&lt;/code&gt;端口建立连接。&lt;/p&gt;
&lt;p&gt;然后，按照定义，我们调用&lt;code&gt;server&lt;/code&gt;端的方法，应该要像调用本地方法一样方便。&lt;/p&gt;
&lt;p&gt;那么，我们这么做：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;client := message.NewMessageSenderClient(conn)
resp, err := client.Send(context.Background(), &amp;amp;message.MessageRequest{SaySomething: &quot;hello world!&quot;})
if err != nil {
   log.Fatalf(&quot;could not greet: %v&quot;, err)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很容易可以理解，我们在本地创建了一个client，然后直接调用我们之前定义好的Send方法，就可以实现我们需要的逻辑了。&lt;/p&gt;
&lt;p&gt;简单的来讲，我们在&lt;code&gt;*.proto&lt;/code&gt;文件中定义了方法，然后在&lt;code&gt;server&lt;/code&gt;端实现定义的rpc方法的具体逻辑，在client端调用这个方法。&lt;/p&gt;
&lt;p&gt;对于其他的部分，由&lt;code&gt;proto buffer&lt;/code&gt;负责对&lt;code&gt;Golang&lt;/code&gt;中存储的数据结构与&lt;code&gt;rpc&lt;/code&gt;传输中的数据进行转换，&lt;code&gt;grpc&lt;/code&gt;负责封装所有的逻辑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;server&lt;/code&gt;端和&lt;code&gt;client&lt;/code&gt;端都跑起来，你会看到这样的画面：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998080/202009/1998080-20200924162448389-804698371.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998080/202009/1998080-20200924162500188-1337762987.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，成功Hello了个World。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;首先，谢谢你能看到这里！&lt;/p&gt;
&lt;p&gt;在这篇文章中，主要是跟你介绍一下hello world的写法，以及在say hello的过程中可能遇到的一些坑。&lt;/p&gt;
&lt;p&gt;我认为最大的坑是在于&lt;code&gt;protoc-gen-go&lt;/code&gt;这个插件这里，因为两种语法让我迷惑了很久。&lt;/p&gt;
&lt;p&gt;如果在这期间，你还有一些问题没有解决，欢迎留言，或者直接公众号找到我，我们一起研究。&lt;/p&gt;
&lt;p&gt;如果在文章中有哪些错误，还请不吝指教，谢谢！&lt;/p&gt;
&lt;p&gt;最后，再次感谢你能看到这里！&lt;/p&gt;
&lt;p&gt;按照惯例，甩个公众号在这，不管有没有问题，都欢迎来找我玩~&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998080/202009/1998080-20200924162007452-1782731082.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Sep 2020 13:08:00 +0000</pubDate>
<dc:creator>红鸡菌</dc:creator>
<og:description>摘要 在这篇文章中，主要是跟你介绍一下gRPC这个东西。 然后，我会创建一个简单的练习项目，作为gRPC的Hello World项目。 在这个项目中，只有很简单的一个RPC函数，用于说明gRPC的工作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hongjijun/p/13724738.html</dc:identifier>
</item>
<item>
<title>linux 上部署  YApi  可视化接口管理平台 - 街尾有条狗</title>
<link>http://www.cnblogs.com/xiaoyong1219/p/13726406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyong1219/p/13726406.html</guid>
<description>&lt;h2 id=&quot;linux-上部署--yapi--可视化接口管理平台：&quot;&gt;linux 上部署 YApi 可视化接口管理平台：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://yapi.demo.qunar.com/&quot;&gt;YApi 是一个高效、易用、功能强大的可视化接口管理平台&lt;/a&gt;，官方地址 : &lt;a href=&quot;http://yapi.demo.qunar.com/&quot;&gt;http://yapi.demo.qunar.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;环境要求&quot;&gt;环境要求&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;nodejs（7.6+)： 本次安装版本：v12.16.1&lt;/li&gt;
&lt;li&gt;mongodb（2.6+）：&lt;/li&gt;
&lt;li&gt;git：&lt;br/&gt;先上效果图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414094702743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ3OTQ5NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;具体步骤：&quot;&gt;具体步骤：&lt;/h3&gt;
&lt;h4 id=&quot;1、安装nodejs&quot;&gt;1、安装node.js&lt;/h4&gt;
&lt;h5 id=&quot;11官网下载：httpsnodejsorgendownload&quot;&gt;1.1官网下载：&lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;https://nodejs.org/en/download/&lt;/a&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414093725905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ3OTQ5NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/h5&gt;
&lt;h5 id=&quot;12-上传服务器并解压&quot;&gt;1.2 上传服务器并解压&lt;/h5&gt;
&lt;p&gt;创建目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mkdir /home/tools/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解压：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;tar -xvf  /home/tools/node-v12.16.1-linux-x64.tar.xz
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重命名解压文件夹名:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mv node-v12.16.1-linux-x64.tar.xz nodejs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解压成功之后即是可以运行的二进制文件，只需要为node和npm建立两个软连接，使之可以全局运行即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;//前面地址为实际地址
ln -s /home/tools/nodejs/bin/node /usr/local/bin/node
ln -s /home/tools/nodejs/bin/npm /usr/local/bin/npm
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以后在任意路径下都可以执行node 和 npm两个命令了，但是由于一些原因，npm在中国的下载速度并不是很理想，我们可以安装淘宝提供的cnpm来代替其功能，执行以下命令即可全局安装cnpm。之后可以直接使用cnpm代替npm，命令格式是一样的。官方网址 ： &lt;a href=&quot;https://npm.taobao.org/&quot;&gt;https://npm.taobao.org/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此nodejs安装完毕，可以输入以下命令查看node和npm的版本信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;node -v

npm -v
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414092137880.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2、安装mongodb&quot;&gt;2、安装MongoDB&lt;/h4&gt;
&lt;h5 id=&quot;21官网下载地址：httpsfastdlmongodborglinuxmongodb-linux-x86_64-4013tgz&quot;&gt;2.1官网下载地址：&lt;a href=&quot;https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.13.tgz&quot;&gt;https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.13.tgz&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&quot;22解压压缩包：&quot;&gt;2.2解压压缩包：&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;tar -xvf mongodb-linux-x86_64-4.0.13.tgz
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;23重命名解压后的文件夹：&quot;&gt;2.3重命名解压后的文件夹：&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mv mongodb-linux-x86_64-4.0.13 mongodb
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;24配置系统环境变量，将mongod路径添加到系统路径中，方便随处执行mongod命令：&quot;&gt;2.4配置系统环境变量，将mongod路径添加到系统路径中，方便随处执行mongod命令：&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;vim /etc/profile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;键盘按下“i”进入编辑模式即可。在文件的最后加上：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#mongodb 20200404
export PATH=$PATH:/home/tools/mongodb/bin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后按下“Esc”，输入“:wq”保存退出vi编辑模式，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;source /etc/profile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使系统环境变量立即生效。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414092417289.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;25创建mongodb数据存放文件夹和日志记录文件夹，为后面的配置文件使用：&quot;&gt;2.5创建MongoDB数据存放文件夹和日志记录文件夹，为后面的配置文件使用：&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mkdir -p /home/tools/mongodb/data

mkdir -p /home/tools/mongodb/logs
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;26-创建mongodb运行时使用的配置文件：&quot;&gt;2.6 创建MongoDB运行时使用的配置文件：&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;vim /home/tools/mongodb/bin/mongod.cfg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再输入以下配置内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;dbpath = /home/tools/mongodb/data #数据文件存放目录
logpath = /home/tools/mongodb/logs/mongod.log #日志文件存放目录
port = 27017 #端口
fork = true #以守护程序的方式启用，即在后台运行
#auth=true #需要认证。如果放开注释，就必须创建MongoDB的账号，使用账号与密码才可远程访问，第一次安装建议注释
bind_ip=0.0.0.0 #允许远程访问，或者直接注释，127.0.0.1是只允许本地访问

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;esc退出 ，输入&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;:wq
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存退出vim编辑模式即可。注意：注释符号#和数据之间必须是一个空格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414092510298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ3OTQ5NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;27启动mongodb服务：&quot;&gt;2.7启动MongoDB服务：&lt;/h5&gt;
&lt;p&gt;进入bin目录下，加载配置文件方式启动：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cd /home/tools/mongodb/bin

./mongod -f mongod.cfg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414092537677.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看端口映射检查是否启动成功：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;netstat -nltp|grep mongod 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414092552898.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;netstat -nltp|grep 27017
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414092605739.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ps -ef | grep mongo 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020041409261671.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;top 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414092627285.png&quot; alt=&quot;]&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;28-关闭mongodb服务&quot;&gt;2.8 关闭MongoDB服务&lt;/h5&gt;
&lt;h6 id=&quot;281-mongod命令关闭&quot;&gt;2.8.1 mongod命令关闭&lt;/h6&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;./mongod -f mongod.cfg  --shutdown
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意要加上配置文件路径参数，和启动时一致，否则会找默认目录，导致报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414092708103.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样能干净的关闭 MongoDB 服务,会释放内存中MongoDB占用的内存，推荐使用。&lt;/p&gt;
&lt;h6 id=&quot;282-kill进程&quot;&gt;2.8.2 kill进程&lt;/h6&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ps -ef | grep mongo

kill -9 xxx(pid)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有时可能会出现错误关不掉时就可使用这种强制方式，但注意这种方式可能并不会马上释放内存中MongoDB占用的内存，且如果这时候有数据往MongoDB新增可能会导致数据丢失。&lt;/p&gt;
&lt;h4 id=&quot;3安装git&quot;&gt;3.安装Git&lt;/h4&gt;
&lt;h5 id=&quot;31-从github上下载最新的源码编译后安装&quot;&gt;3.1 从GitHub上下载最新的源码编译后安装&lt;/h5&gt;
&lt;p&gt;进入git在GitHub上发布版本页面&lt;a href=&quot;https://github.com/git/git/releases&quot;&gt;https://github.com/git/git/releases&lt;/a&gt;，这个页面我们可以找到所有git已发布的版本。这里我们选择最新版的&lt;code&gt;tar.gz&lt;/code&gt;包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414092735830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ3OTQ5NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;&quot;/&gt;
&lt;h5 id=&quot;32-上传并解压&quot;&gt;3.2 上传并解压&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;tar -xvf git-2.26.0.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解压后重命名解压后的文件夹&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mv git-2.26.0 git_source
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;33-编译源码&quot;&gt;3.3 编译源码&lt;/h5&gt;
&lt;p&gt;进入到解压后的文件夹进行源码编译，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cd git_source
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过在此之前需要安装编译所需要的依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/202004140928057.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ3OTQ5NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;耐心等待安装完成，中途出现提示的时候输入&lt;code&gt;y&lt;/code&gt;并按回车:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414092820368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ3OTQ5NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，依赖安装完成。&lt;/p&gt;
&lt;h5 id=&quot;34-编译git源码&quot;&gt;3.4 编译git源码&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;make prefix=/home/tools/git all
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;35-安装git-至-hometoolsgit-路径&quot;&gt;3.5 安装git 至 /home/tools/git 路径&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;make prefix=/home/tools/git install
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;36-配置环境变量&quot;&gt;3.6 配置环境变量&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;vi /etc/profile 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在底部加上&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;export PATH=$PATH:/home/tools/git/bin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;( 输入 :wq! 保存修改)&lt;/p&gt;
&lt;p&gt;刷新环境变量&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;source /etc/profile
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;37--查看git是否安装完成&quot;&gt;3.7 查看Git是否安装完成&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;git --version
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，从github上下载最新的源码编译后安装git完成。&lt;/p&gt;
&lt;h4 id=&quot;4-部署yapi&quot;&gt;4 部署yapi&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;第一步:安装&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;npm install -g yapi-cli --registry https://registry.npm.taobao.org
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步:配置yapi&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ln -s /home/tools/node/bin/yapi /usr/bin/yapi
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步:启动配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果不进行第二步,配置,可能会找不到yapi&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;yapi server
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开链接 &lt;a href=&quot;http://127.0.0.1:9090&quot;&gt;http://127.0.0.1:9090&lt;/a&gt; 进行初始化配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414093015830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQ3OTQ5NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020041409303375.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;备注：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414093049215.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;初始化时候mangodb数据库初始化失败，解决方法：&lt;/p&gt;
&lt;p&gt;修改文件 &lt;code&gt;/home/tools/yapi/my-yapi/vendors/server/utils/db.js&lt;/code&gt; 在原来的22行位置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let options = {useNewUrlParser: true, useCreateIndex: true}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加&lt;code&gt;useUnifiedTopology: true&lt;/code&gt;选项，删除mongo里面的数据库，和init.lock文件，然后执行&lt;code&gt;npm run install-server&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步:启动服务器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;node /home/tools/yapi/my-yapi/vendors/server/app.js
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开链接 &lt;a href=&quot;http://127.0.0.1:3000&quot;&gt;http://127.0.0.1:3000&lt;/a&gt; 进行访问即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部署问题&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;使用Xshell启动服务,当关闭Xshell,服务也随之关闭&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用pm2部署&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步:安装pm2&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt; npm install -g pm2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步:配置连接pm2&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;ln -s /home/tools/node/bin/pm2 /usr/bin/pm2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步:在项目添加配置文件my-yapi_processes.json&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;my-yapi_processes.json文件可自定义&lt;/p&gt;
&lt;p&gt;添加如下内容:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;apps&quot; : [{
    &quot;name&quot; : &quot;my-yapi&quot;,
    &quot;script&quot;: &quot;/home/tools/yapi-my-yapi/vendors/server/app.js&quot;,
    &quot;cwd&quot;: &quot;./&quot;,
    &quot;watch&quot;:[
        &quot;server&quot;,
        &quot;static&quot;,
        &quot;test&quot;,
        &quot;exts&quot;,
        &quot;common&quot;
    ]
    }]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;启动服务：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pm2 start /home/tools/yapi/my-yapi/vendors/my-yapi_process.json 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414093109984.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关闭服务：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pm2 stop /home/tools/yapi/my-yapi/vendors/my-yapi_process.json 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414093237190.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 24 Sep 2020 12:26:00 +0000</pubDate>
<dc:creator>街尾有条狗</dc:creator>
<og:description>linux 上部署 YApi 可视化接口管理平台</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoyong1219/p/13726406.html</dc:identifier>
</item>
</channel>
</rss>