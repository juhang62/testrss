<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>num14---享元模式 - 独行侠的守望</title>
<link>http://www.cnblogs.com/dxxdsw/p/12324748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dxxdsw/p/12324748.html</guid>
<description>&lt;div id=&quot;header&quot; readability=&quot;4.2&quot;&gt;
&lt;div id=&quot;blogTitle&quot;&gt;&lt;a id=&quot;lnkBlogLogo&quot; href=&quot;https://www.cnblogs.com/dxxdsw/&quot;&gt;&lt;img id=&quot;blogLogo&quot; src=&quot;https://www.cnblogs.com/skins/custom/images/logo.gif&quot; alt=&quot;返回主页&quot;/&gt;&lt;/a&gt; 

&lt;h2&gt;走更远的路，看更美的景，遇更爱的人！ 欢迎访问: http://www.yuanhuiying.com&lt;/h2&gt;
&lt;/div&gt;
&lt;div id=&quot;navigator&quot; readability=&quot;3.5411764705882&quot;&gt;
&lt;p&gt;&lt;span id=&quot;stats_post_count&quot;&gt;随笔 - 71 &lt;/span&gt; &lt;span id=&quot;stats_article_count&quot;&gt;文章 - 0 &lt;/span&gt; &lt;span id=&quot;stats-comment_count&quot;&gt;评论 - 0&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1028424/202002/1028424-20200218080604971-783011888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1028424/202002/1028424-20200218081109522-1887849039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1028424/202002/1028424-20200218081113424-252025033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1028424/202002/1028424-20200218081243680-564896980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 案例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1028424/202002/1028424-20200218081315450-1278769783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;



&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;

&lt;p&gt;Copyright © 2020 独行侠的守望&lt;br/&gt;&lt;span id=&quot;poweredby&quot;&gt;Powered by .NET Core on Linux&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Feb 2020 00:41:00 +0000</pubDate>
<dc:creator>独行侠的守望</dc:creator>
<og:description>案例：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dxxdsw/p/12324748.html</dc:identifier>
</item>
<item>
<title>Python应用——多变量的灵活处理 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12324719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12324719.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;，原创不易，求个关注&lt;/p&gt;

&lt;p&gt;我们都知道Python是一个非常灵活的语言，以至于如果它不是你的第一门语言，你会发现它总能给你各种各样的惊喜，让你忍不住惊叹：woc，还有这种操作。尤其我在系统地学习Python之前是Java后端出身，所以每一阶段几乎都会让我觉得打开了新世界的大门。今天就和大家介绍一个最基础，非常好用，但是很多人不知道的操作。&lt;/p&gt;

&lt;h2 id=&quot;解压变量&quot;&gt;解压变量&lt;/h2&gt;

&lt;p&gt;我们都知道，Python允许进行多个变量的赋值操作，比如著名的交换两个元素，如果是在C++或者Java语言当中，如果不通过函数实现，必须要引入第三个变量，比如：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# swap a, b
c = a
a = b
b = c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们要交换a和b必须要引入c，这是因为当我们赋值b给a的时候，a原本的值会丢失，所以我们必须要先”缓存“下来。但是由于Python支持多变量赋值的操作，所以大可不必引入其他变量就可以完成，所以交换两个元素在Python当中只有一行就可以搞定：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;a, b = b, a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Python的解释器会直接计算后边的值然后覆盖左边，赋值是同时进行的，所以不需要引入其他变量，而且看起来也非常geek。&lt;/p&gt;
&lt;p&gt;除此之外，Python还支持tuple和list的解压。&lt;/p&gt;
&lt;p&gt;举个例子，假设我们有一个二元数组：[1, 2]，我们希望用两个变量分别获取它的第0位和第一位，我们当然可以写成这样：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;l = [1, 2]
a, b = l[0], l[1]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实并不用这么麻烦，因为当Python检测到等号左边是多个变量，右边是list或者是tuple之后，会自动执行list和tuple的解压，将它依次赋值给对应的元素，所以上面的代码可以简化成：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;l = [1, 2]
a, b = l&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那如果l是一个二维数组，我们希望遍历它呢？同样可以在循环当中使用：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;l = [[1, 2], [3, 4], [5, 6]]
for i, j in l:
    print(i, j)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即使是在变量的组合当中也可以生效：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;a, b, c = 1, 3, (4, 5)
print(c)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们执行这段代码，屏幕上会输出什么呢？是会报错吗？还是会解压(4, 5)这个tuple然后将4赋值给c呢？&lt;/p&gt;
&lt;p&gt;都不对，输出的结果是(4, 5)，也就是说Python发现变量数量对不上之后，会自动将tuple当做一个整体进行赋值。不但如此，即使是下面这种情况，Python也能自动识别：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;a, b, (c, d), e = 1, 3, (4, 5), 7
print(c, d)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的赋值当中，既有tuple又有普通元素，并且我们的变量也组合成了tuple，这时Python同样会识别出(4, 5)应该赋值给(c, d)这个整体，也就是说4和5分别赋值给c和d。&lt;/p&gt;

&lt;h2 id=&quot;缺省元素&quot;&gt;缺省元素&lt;/h2&gt;

&lt;p&gt;在有的时候，我们在获取元素的时候，源数据当中有我们不需要的字段。虽然Python自动解压非常方便，但是我们还是要为我们不需要的数据设置变量。在一些情况下这会导致内存的浪费，并且这也不符合我们编程的规范，即所有变量都应该派上用场。为了解决这个问题，Python提供缺省元素的方法。我们可以使用_来代表一个缺省值，_对应的数据不会被存储下来，只是为了方便我们”凑齐“元素。&lt;/p&gt;
&lt;p&gt;举个例子，还用上面的例子举例，假设源数据的格式是这样：1, 3, (4, 5), 7，但是我们只需要中间的元组，我们就可以这样去接收：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;_, _, (c, d), _ = 1, 3, (4, 5), 7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再比如，当我们遍历dict的时候，有可能我们并不关注dict的key，只希望获得它的value，这个时候也可以使用缺省符号：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;a = {}
for _, v in a.items():
    print(v)&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;压缩变量&quot;&gt;压缩变量&lt;/h2&gt;

&lt;p&gt;既然变量可以解压，那么自然也可以压缩。想象一个场景，比如有一批衡量工厂零件的数据，这个数据当中除了零件的尺寸之外还包含了零件的名称，生产日期和工厂名称等等其他的属性。假设我们当下希望解析这份数据，并且将零件的尺寸用数组存储，这个时候应该怎么办呢？&lt;/p&gt;
&lt;p&gt;比如，零件的数据的规格长这样：wheel, factory1, 3, 4, 5, 6, 2020-02-02&lt;/p&gt;
&lt;p&gt;Python同样针对这个问题提供了解决方法，就是变量压缩符*，针对上面那个问题，我们可以写成：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;data = ['wheel', 'factory1', 3, 4, 5, 6, '2020-02-02']
name, factory, *inch, date = data
print(inch)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们打印出来的inch是[3, 4, 5, 6]，也就是说通过使用&lt;em&gt;，我们成功地将中间表示零件尺寸的数据赋值进了一个数组当中。这个操作非常重要，因为有可能不同零件尺寸的数量是不同的，如果我们自己写解析的话就很难处理这个问题。而使用Python当中的&lt;/em&gt; 操作符，我们可以很好地解决这个问题。&lt;/p&gt;

&lt;h2 id=&quot;联合使用&quot;&gt;联合使用&lt;/h2&gt;

&lt;p&gt;到这里，我们介绍了缺省符号的用法，介绍了压缩符号的用法，问题来了，我们能不能将这两个符号组合使用，获取数据当中任意个缺省值呢？&lt;/p&gt;
&lt;p&gt;当然是可以的，还是刚才的问题，假设我们现在不关心零件的尺寸，想要过滤掉它们，我们只要对上面的代码稍作改动即可：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;data = ['wheel', 'factory1', 3, 4, 5, 6, '2020-02-02']
name, factory, *_, date = data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如此我们就过滤掉了中间若干个尺寸信息，仅仅保留了头尾其他的信息。&lt;/p&gt;

&lt;h2 id=&quot;其他用途&quot;&gt;其他用途&lt;/h2&gt;

&lt;p&gt;到这里还没结束，不知道大家在看到 * 这个操作符号的时候有没有什么联想，如果稍稍了解过Python的话，应该会想起Python当中，如果我们想让一个函数接收任何参数的话，我们可以写成：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def func(*args, **kw):
    pass&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;其中args其实代表一个数组，kw代表一个dict，这些我们都是知道的。但是前面的 * 和 ** 呢，又代表什么呢？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;代表解压数组，*&lt;/em&gt;自然就代表解压dict。我们来看个例子：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;a = [1, 3, 5]
print(a)
print(*a)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;请问print(a)和print(&lt;em&gt;a)有什么区别？如果你试一下就会发现，直接打印a，出来的结果是[1, 3, 5]，如果你打印&lt;/em&gt; a，得到的结果是1, 3, 5。也就是说前者是将a当成一个数组输出，是一个变量，后者则是将a解压了，当成了3个变量输出。那么同样的道理，*&lt;em&gt;kw，也是将作为dict的kw解压，以key: value的形式展开。不过如果你直接调用 *&lt;/em&gt;kw会得到一个报错，这个操作只能在函数传递参数的时候使用。&lt;/p&gt;
&lt;p&gt;所以到这里，我们就明白了，*args和*&lt;em&gt;kw为什么能够代表所有参数了。因为前者代表了直接传递的必选参数，后者呢，代表提供了默认值的默认参数。这也是为什么Python限定了默认参数必须放在必选参数后面的原因，一方面是为了消除歧义，另一方面也是为了能够用*args, *&lt;/em&gt;kw来统一表示。&lt;/p&gt;
&lt;p&gt;今天的内容虽然简单，但是在实际代码当中经常用到，用得好的话可以大大简化我们coding的难度以及代码的美观程度，因此如果对Python感兴趣的同学，非常推荐一学。&lt;/p&gt;
&lt;p&gt;今天的文章就是这些，如果觉得有所收获，请&lt;strong&gt;顺手扫码点个关注&lt;/strong&gt;吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/18/170559cd7935e251?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参考资料&lt;br/&gt;Python cookbook 第三版&lt;/p&gt;
&lt;p&gt;维基百科&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 18 Feb 2020 00:07:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 我们都知道Python是一个非常灵活的语言，以至于如果它不是你的第一门语言，你会发现它总能给你各种各样的惊喜，让你忍不住惊叹：woc，还</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12324719.html</dc:identifier>
</item>
<item>
<title>我的一个配置redux（实现一个自增功能）之旅 - GGbondMan</title>
<link>http://www.cnblogs.com/GGbondLearn/p/12312676.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GGbondLearn/p/12312676.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt; ： 今天呢，就配置一下redux，redux的重要性呢，就叭叭叭一大堆，什么也没有带着配置一次来的重要，因为许多涉及到的属性和方法，用法是活的，但格式是需要记忆的。&lt;/p&gt;
&lt;p&gt;过程中不要嫌我唠叨，有的地方为了便于理解和记忆，反而会绕一下，配置redux的确比较麻烦，用到我们平时不常用的方法，我们不熟悉他们，所以会使用过程需要记忆。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）首先呢，安装redux环境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个稳定版的redux和一个redux绑定库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; npm install redux --&lt;span&gt;save
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; npm install react-redux --save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;本行代码纯属友情赠送，看到了就是赚到了，一个redux开发者工具&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install redux-devtools --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是在这里用滴：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200216162509680-924817956.png&quot; alt=&quot;&quot; width=&quot;772&quot; height=&quot;127&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们检查package，已经完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200216161842940-1927822557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt; &lt;span&gt;&lt;strong&gt;（2）现在呢，感受这3个重要的概念action，reducer以及store。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Action 作用：&lt;/h2&gt;
&lt;p&gt;1、用Action来分辨具体的执行动作。比如我是要添加一个项目还是删除一个项目。&lt;/p&gt;
&lt;p&gt;2、操作数据首先得有数据。比如添加数据得有数据，删除数据得有ID。action就是存这些数据的地方。&lt;/p&gt;
&lt;p&gt;3、不带其他数据，仅仅启示已有数据需要如何调整，或者需要主动获取哪些数据。如果我要删除掉全部数据，只要告知这件事即可&lt;/p&gt;

&lt;h2&gt;Reducer的作用：&lt;/h2&gt;
&lt;p&gt;官方描述：Action 只是描述了有事情发生了这一事实，并没有指明应用如何更新 state。这是 reducer 要做的事情。&lt;/p&gt;
&lt;p&gt;这么说吧，Action就像一个指挥者，告诉我们应该做哪些事，比如我要删除，reducer就会给我们提供‘资源（就是上面说的数据）’，真正的体力劳动者是reducer。&lt;/p&gt;
&lt;p&gt;也就是说，action里面的每一种描述，比如新增啦，删除一个，删除全部啦，reducer都有一个对应的函数来处理数据。之后返回给你一个新的state&lt;/p&gt;
&lt;p&gt; reducer 只是一个模式匹配的东西，真正处理数据的函数，是额外在别的地方写的，在 reducer 中调用罢了。&lt;/p&gt;
&lt;p&gt; ※：reducer：缩减 （我们用来写方法的）因为 action 对象各种各样，每种对应某个 case ，但最后都汇总到 state 对象中，从多到一，这是一个减少( reduce )的过程，所以完成这个过程的函数叫 reducer。&lt;/p&gt;

&lt;h2 id=&quot;store&quot;&gt;Store:&lt;/h2&gt;
&lt;p&gt;前面两个，我们知道使用 action 来描述“发生了什么”，和使用 reducers 来根据 action 更新 state 的用法。&lt;/p&gt;
&lt;p&gt;Store 就是把它们联系到一起的对象。Store 有以下职责：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;维持应用的 state；&lt;/li&gt;
&lt;li&gt;提供 &lt;strong&gt;getState()&lt;/strong&gt; 方法获取 state；&lt;/li&gt;
&lt;li&gt;提供 &lt;strong&gt;dispatch(action)&lt;/strong&gt; 方法更新 state；&lt;/li&gt;
&lt;li&gt;通过 &lt;strong&gt;subscribe(listener)&lt;/strong&gt; 注册监听器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）接下来创建actions文件夹，再新建一个reducers文件夹，并创建各自的index.js。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;创建文件夹不截图了。。。index先空着，等下补充。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（4）我们需要将actions和reducers关联起来（截图对比代码，菜鸟请注意&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;未修改的src的index.js：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200216165208590-1439404061.png&quot; alt=&quot;&quot; width=&quot;798&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 现在呢，从react-redux库里，调出Provider方法，从redux里拿出creatStore方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import { Provider } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import { creatStore } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;React-Redux&lt;/strong&gt;提供了两个接口&lt;strong&gt;Provider&lt;/strong&gt;、&lt;strong&gt;connect&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Provider 是一个React组件，它的作用是保存store给子组件中的connect使用。&lt;/p&gt;
&lt;p&gt;connect  会把State和dispatch转换成props传递给子组件。我的理解是，因为所有的数据都集中在了 store中，Provider从那里把store的数据拿了过来。给它的好朋友 connect，connect是联系，连接的意思嘛，所以它将好朋友provider的数据拿了过来，让它供那些子组件使用。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import rootReducer &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./reducers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将reducers文件引入（如果是引入文件，默认引入的是index.js）。&lt;/p&gt;

&lt;p&gt;我们创建一个仓库store：我们用创建库方法来以存放应用中所有的 state。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; store = createStore(rootReducer)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用Provider包裹App模块，然后作为Hello模块抛出，在根节点中渲染&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; store =&lt;span&gt; createStore(rootReducer)

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Hello extends Component {
    render() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;Provider store={ store }&amp;gt;
                &amp;lt;div&amp;gt;
                    &amp;lt;App/&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/Provider&amp;gt;&lt;span&gt;
        )
    }
}


ReactDOM.render(&lt;/span&gt;&amp;lt;Hello /&amp;gt;, document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后的代码是这个样子的（运行之后包Component报错的，注意看图片上的第一个蓝框）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200217204814998-1928683842.png&quot; alt=&quot;&quot; width=&quot;801&quot; height=&quot;455&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这段代码的作用，总体上来说应该这样表述：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我创建了一个&lt;strong&gt;Hello&lt;/strong&gt;模块来给大家展示redux,创建Hello模块将App标签包裹，但是,我们用Provider组件将return出来的东西包裹，connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。这样，App的所有子组件就默认都可以拿到state了。同时，我们直接渲染到root根节点的App也就改成了Hello。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（5）接下来配置reducers的index.js&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在这个index里，我们要做的，就是将里面所有的小的reducers整合起来，然后抛出。我这里假设用page01和page02来分开管理小的reducers，当然，你不嫌麻烦可以把所有的功能都写在主文件里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200217160802134-300767792.png&quot; alt=&quot;&quot; width=&quot;792&quot; height=&quot;428&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 我的page1和2里都没有写方法，等下再进行功能的编写。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（6）配置actions里面的index.js&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在这个index，我们要做的呢，是将所有的方法抛出，也是两个空的，额，等下就写。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200217162202192-879338767.png&quot; alt=&quot;&quot; width=&quot;801&quot; height=&quot;433&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（7）运行调试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这次运行呢，就是看看我的组件能不能正常加载。。。因为你没仔细看我的index.js里的第一个蓝框，就有可能报这个错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200217205529386-1021520079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他错误请自己逐渐调试，因为我的已经正常运行。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（8）既然搭建了redux，然后我们要实现一个方法，点击自增。。。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（笑喷了自己，这个方法是演示方法中，最常用也是最low的demo，自己认为。。。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200217230124508-775830431.png&quot; alt=&quot;&quot; width=&quot;797&quot; height=&quot;466&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 注释给的很详细了&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（9）配置reducer的counter1&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200218003919276-954496394.png&quot; alt=&quot;&quot; width=&quot;702&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 我们把方法反出去，这里是把自增的方法反出去了&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（10）主组件的一些个操作（两张图并一张）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200218004652645-1964091524.png&quot; alt=&quot;&quot; width=&quot;991&quot; height=&quot;542&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200218005034756-1617008922.png&quot; alt=&quot;&quot; width=&quot;989&quot; height=&quot;540&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 注释已经很清楚了&lt;/p&gt;
&lt;p&gt;mapStateToProps 是一个函数(函数名可以自定义)，它的作用就像它的名字那样，建立一个从（外部的）state对象到（UI组件的）props对象的映射关系。由此你就可以推测，mapDispathToProps的意思和这个是差不多的，分发方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（11）此时的页面效果：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200218005813346-1177772547.png&quot; alt=&quot;&quot; width=&quot;233&quot; height=&quot;82&quot;/&gt;&lt;/p&gt;




&lt;p&gt; 我点击的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1895951/202002/1895951-20200218005736501-1697115496.png&quot; alt=&quot;&quot; width=&quot;315&quot; height=&quot;64&quot;/&gt;&lt;/p&gt;


&lt;p&gt;恭喜自己，功能实现了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（12）代码给你们（index的）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; import React, { Component } from 'react'
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; import './App.css'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; import { connect } from &quot;react-redux&quot; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从react-redux里拿到connect方法&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; import { counterCreator } from &quot;./actions&quot;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;暴露counterCreator这个方法&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class App extends Component {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  constructor(props){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    super(props)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.state=&lt;span&gt;{}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   handleClick=()=&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.numAdd()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  render() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       &amp;lt;div className='Box'&amp;gt;
&lt;span&gt;21&lt;/span&gt;         &amp;lt;h3&amp;gt;{&lt;span&gt;this&lt;/span&gt;.props.$$num}&amp;lt;/h3&amp;gt;
&lt;span&gt;22&lt;/span&gt;         &amp;lt;button onClick={&lt;span&gt;this&lt;/span&gt;.handleClick}&amp;gt;点击自增&amp;lt;/button&amp;gt;
&lt;span&gt;23&lt;/span&gt;       &amp;lt;/div&amp;gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    )
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; const mapStateToProps = (state) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;  console.log(state)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     $$num : state.page01.num &lt;span&gt;//&lt;/span&gt;&lt;span&gt;$$只是一个标识，建议加&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dispatch 分发方法&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; const mapDispathToProps = (dispatch) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     numAdd : () =&amp;gt;&lt;span&gt; dispatch(counterCreator.numAdd())
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;  } 
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;connect 高阶组件、高阶函数  传入一个组件=&amp;gt;返回一个新的组件&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; connect(
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;  mapStateToProps,
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;  mapDispathToProps
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; )(App)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;感悟：暂时凭自己的知识储备是配置不了的，希望自己一直进步，学不会的时候，千万别停下来，戒骄戒躁，加油！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 17 Feb 2020 17:07:00 +0000</pubDate>
<dc:creator>GGbondMan</dc:creator>
<og:description>前言 ： 今天呢，就配置一下redux，redux的重要性呢，就叭叭叭一大堆，什么也没有带着配置一次来的重要，因为许多涉及到的属性和方法，用法是活的，但格式是需要记忆的。 过程中不要嫌我唠叨，有的地方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/GGbondLearn/p/12312676.html</dc:identifier>
</item>
<item>
<title>【WPF学习】第四十四章 图画 - Peter.Luo</title>
<link>http://www.cnblogs.com/Peter-Luo/p/12324359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Peter-Luo/p/12324359.html</guid>
<description>&lt;p&gt;　　通过上一章的学习，Geometry抽象类表示形状或路径。Drawing抽象类扮演了互补的角色，它表示2D图画(Drawing)——换句话说，它包含了显示矢量图像或位图需要的所有信息。&lt;/p&gt;
&lt;p&gt;　　尽管有几类画图类，但只有GeometryDrawing类能使用已经学习过的几何图形。它增加了决定如何绘制图形的画笔和填充细节。可将GeometryDrawing对象视为矢量插图中的形状。例如，可将标准的窗口元文件格式(.wmf)转换成准备插入用户界面的GeometryDrawing对象的集合。&lt;/p&gt;
&lt;p&gt;　　分析一个简单的示例有帮助的。前面已经看到了如何定义表示三角形的PathGeometry对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PathGeometry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PathFigure &lt;/span&gt;&lt;span&gt;IsClosed&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt; StartPoint&lt;/span&gt;&lt;span&gt;=&quot;0,100&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LineSegment &lt;/span&gt;&lt;span&gt;Point&lt;/span&gt;&lt;span&gt;=&quot;100,100&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LineSegment &lt;/span&gt;&lt;span&gt;Point&lt;/span&gt;&lt;span&gt;=&quot;100,50&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PathFigure&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PathGeometry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可使用PathGeometry对象创建GeometryDrawing对象，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing  &lt;/span&gt;&lt;span&gt;Brush&lt;/span&gt;&lt;span&gt;=&quot;Yellow&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing.Pen&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Pen &lt;/span&gt;&lt;span&gt;Brush&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt;&lt;span&gt; Thickness&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Pen&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;GeometryDrawing.Pen&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing.Geometry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PathGeometry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PathFigure &lt;/span&gt;&lt;span&gt;IsClosed&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt; StartPoint&lt;/span&gt;&lt;span&gt;=&quot;10,100&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LineSegment &lt;/span&gt;&lt;span&gt;Point&lt;/span&gt;&lt;span&gt;=&quot;100,100&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LineSegment &lt;/span&gt;&lt;span&gt;Point&lt;/span&gt;&lt;span&gt;=&quot;100,50&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PathFigure&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PathGeometry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;GeometryDrawing.Geometry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;GeometryDrawing&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在，PathGeometry对象定义了形状（三角形）。GeometryDrawing对象定义了形状的外观（具有蓝色边界的黄色三角形）。PathGeometry对象和GeometryDrawing对象都不是元素，所以不能直接使用这两个对象中的任何一个为窗口添加自己绘制的内容，而需要使用另一个支持图画的类。&lt;/p&gt;
&lt;p&gt;　　GeometryDrawing类不是WPF总唯一的图画类（尽管当使用2D矢量图形时，该类是最相关的一个类）。实际上，Drawing类用于表示所有类型的2D图形，并且还有一个小组类继承自该类。下表列出了所有这些类。&lt;/p&gt;
&lt;p&gt;表 图画类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202002/263728-20200217210659730-336575719.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 一、显示图画&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　因为继承自Drawing的类不是元素，所以不能将它们放置到用户界面中。为了显示图画，需要使用下表列出的三个类中的一个。&lt;/p&gt;
&lt;p&gt;表 用于显示图画的类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202002/263728-20200217211116972-1103782135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　所有这些类中都存在通用主题。非常简单，它们提供了使用更少系统资源显示2D内容的方法。&lt;/p&gt;
&lt;p&gt;　　例如，假如希望使用矢量图像为按钮创建图表。最简单的方法（也是占用资源最多的方法）是在按钮中放置Canvas控件，并在Canvas控件中放置一系列继承自Shape类的元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Canvas &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Polyline &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Polyline &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Rectangle &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Ellipse &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Polygon &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Canvas&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在已经知道，如果是使用这种方法，每个元素都是完全独立的，具有自己的内存区域和事件处理程序等。一个更好的减少元素数量的方法是Path元素。因为每个路径具有单独的笔画和填充，所以仍需要大量Path对象，不过这还是能够在一定程度上减少元素数量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Canvas &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Path &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Path &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        ...
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Canvas&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一旦开始使用Path元素，就将独立形状变换为不同的几何图形。可从路径中提取几何图形、笔画以及填充信息并将它们转换成图画，从而再增加一个抽象层。然后可在DrawingGroup对象中将这些图画融合在一起，并将DrawingGroup对象放置到DrawingImage对象中，DrawingImage对象又可被放入到Image元素中。下面是这一过程创建的新标记：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image.Source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DrawingImage&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DrawingImage.Drawing&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DrawingGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        ...
                    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DrawingGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DrawingImage.Drawing&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DrawingImage&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Image.Source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Image&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一次意义重大的改变。该例并没有简化标记，只是用GeometryDrawing对象代替了每个Path对象。然而，由于减少了元素的数量，因此降低了所需的开销。在前面的示例中创建了包含在按钮中的Canvas控件，并为每个路径添加了单独的元素。但该例只需要一个嵌套的元素：位于按钮中的Image元素。付出的代价是不能再为每个不同的路径处理事件（例如，不能探测鼠标在图画中独立区域的单击操作）。但在用于按钮的静态图像中，未必需要使用这种功能。&lt;/p&gt;
&lt;p&gt;　　尽管使用DrawingImage对象已经节省了大量资源，但仍可进一步提高效率，借助于Drawing删除另一个元素。&lt;/p&gt;
&lt;p&gt;　　基本思想是在DrawingBrush对象中的封装DrawingImage对象，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button.Background&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DrawingBrush&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DrawingBrush.Drawing&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DrawingGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DrawingGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DrawingBrush.Drawing&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DrawingBrush&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button.Background&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　DrawingBrush方法和前面介绍的DrawingImage方法不完全相同。因为Image元素改变其内容的默认方式是不同的。Image.Stretch属性的默认值是Uniform，该设置会为了适应可用空间而放大或缩小图像。DrawingBrush.Stretch属性的默认值是Fill，该设置可能会扭曲图像。&lt;/p&gt;
&lt;p&gt;　　当改变DrawingBrush的Stretch属性时，为明确扭曲填充区域中图画的位置和尺寸，也可能希望调整Viewport设置。例如，下面的标记缩放由图画画刷使用的图画，以占用填充区域的90%：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DrawinBrush &lt;/span&gt;&lt;span&gt;Stretch&lt;/span&gt;&lt;span&gt;=&quot;Fill&quot;&lt;/span&gt;&lt;span&gt; Viewport&lt;/span&gt;&lt;span&gt;=&quot;0,0 0.9,0.9&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于按钮示例这是非常有用的。因为可为按钮周围的边框留出一定的空间。因为DrawingBrush并非元素，所以不能使用WPF布局过程。这意味着和Image元素不同，DrawingBrush中的内容放置不会考虑Button.Paddin属性值。&lt;/p&gt;
&lt;p&gt;　　使用DrawingBrush方式的一个古怪问题是，将鼠标移到按钮上时内容会消失，并且会使用一个新画刷绘制按钮表面。但当使用Image方式时，图片就不受影响。为了解决这个问题，需要为按钮创建自定义按钮控件模板，该模板使用不同的方式绘制按钮的背景。&lt;/p&gt;
&lt;p&gt;　　无论是在DrawingImage本身中使用图形，还是使用DrawingBrush封装图形，都应当考虑使用资源分解标记。基本思想是作为不同资源定义每个DrawingImage或DrawingBrush对象，从而当需要时就可以引用定义的对象。如果希望在多个元素或窗口中显示相同的内容，这是特别好的思想，因为只需要重用资源，而不必复制整块标记。如下面的示例所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9fb286a5-ded7-4116-8d68-9d311664ddf0')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_9fb286a5-ded7-4116-8d68-9d311664ddf0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9fb286a5-ded7-4116-8d68-9d311664ddf0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9fb286a5-ded7-4116-8d68-9d311664ddf0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9fb286a5-ded7-4116-8d68-9d311664ddf0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Window &lt;/span&gt;&lt;span&gt;x:Class&lt;/span&gt;&lt;span&gt;=&quot;Drawing.Drawings&quot;&lt;/span&gt;&lt;span&gt;
        xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&lt;/span&gt;&lt;span&gt;
        xmlns:x&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&lt;/span&gt;&lt;span&gt;
        Title&lt;/span&gt;&lt;span&gt;=&quot;Drawings&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;300&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Window.Resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing &lt;/span&gt;&lt;span&gt;x:Key&lt;/span&gt;&lt;span&gt;=&quot;Drawing&quot;&lt;/span&gt;&lt;span&gt; Brush&lt;/span&gt;&lt;span&gt;=&quot;Yellow&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing.Pen&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Pen &lt;/span&gt;&lt;span&gt;Brush&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt;&lt;span&gt; Thickness&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Pen&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;GeometryDrawing.Pen&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;GeometryDrawing.Geometry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PathGeometry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PathFigure &lt;/span&gt;&lt;span&gt;IsClosed&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt; StartPoint&lt;/span&gt;&lt;span&gt;=&quot;10,100&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LineSegment &lt;/span&gt;&lt;span&gt;Point&lt;/span&gt;&lt;span&gt;=&quot;100,100&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LineSegment &lt;/span&gt;&lt;span&gt;Point&lt;/span&gt;&lt;span&gt;=&quot;100,50&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PathFigure&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PathGeometry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;GeometryDrawing.Geometry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;GeometryDrawing&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Window.Resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel &lt;/span&gt;&lt;span&gt;Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image.Source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DrawingImage &lt;/span&gt;&lt;span&gt;Drawing&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{StaticResource Drawing}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DrawingImage&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Image.Source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Image&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button.Background&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DrawingBrush &lt;/span&gt;&lt;span&gt;Stretch&lt;/span&gt;&lt;span&gt;=&quot;Uniform&quot;&lt;/span&gt;&lt;span&gt; Viewport&lt;/span&gt;&lt;span&gt;=&quot;0,0 0.9,1&quot;&lt;/span&gt;&lt;span&gt; Drawing&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{StaticResource Drawing}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DrawingBrush&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button.Background&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Window&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Drawings&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202002/263728-20200217231014595-903247316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 二、导出插图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　尽管所有这些示例都内联地声明他们的图画，但更常用的方法是将该内容的某些部分放到资源字典中，从而可在整个应用程序中重用（并非一个地方进行修改）。由用户来确定如何将这些标记分割到资源中，但两种常用的方法是，存储一个充满DrawingImage对象的字典，或存储一个保存DrawingBrush对象的字典。此外，也可以分离出Geometry对象，并将它们存储为独立的资源。如上面的示例所示。&lt;/p&gt;
&lt;p&gt;　　当然，很少有开发人员会手动编写大量图形。反而， 他们将使用专门的设计工具导出所需的XAML内容。大多数设计工具目前还不支持XAML导出功能，不过有许多插件和转换工具可以弥补这一缺陷。下面是几个例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　&lt;a href=&quot;http://www.mikeswanson.com/XAMLExport/&quot;&gt;http://www.mikeswanson.com/XAMLExport/&lt;/a&gt;上有一个用于Adobe Illustrator工具的免费XAML插件&lt;/li&gt;
&lt;li&gt;　　&lt;a href=&quot;http://www.mikeswanson.com/swf2xaml/&quot;&gt;http://www.mikeswanson.com/swf2xaml/&lt;/a&gt;上有一个用于Adobe Flash文件的免费XAML转换工具。&lt;/li&gt;
&lt;li&gt;　　Expression Design是Microsoft公司的插入和图形设计程序，内置了XAML导出功能。该程序能够读取各种矢量图形文件格式，包括.wmf(Windows元文件格式)文件，还可以导入已经存在的插图并将其导出为XAML格式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　然而，即使使用其中某个工具，前面学习的有关图形和图画的知识依然十分重要，主要原因如下几点：&lt;/p&gt;
&lt;p&gt;　　首先，许多程序允许选择是希望作为Canvas控件中的独立元素的组合导出图画，还是希望作为DrawingBrush或DrawingImage资源的集合导出图画。通常，第一种选择是默认选择，因为它保留了许多特性。然而，如果使用大量图画，并且图画很复杂，或者只是希望为了尽可能减少内存需求而使用静态图形，如按钮图形，使用DrawingBrush或DrawingImage资源更好的多。而且，这些格式和用户界面的其他部分是相互独立的，所以在以后很容易更新它们。&lt;/p&gt;
&lt;p&gt;　　之所以说理解2D图形基础知识是很重要的，另一个原因是这样可以更容易地控制它们。例如，可通过以下方式替换标准的2D图形：修改用于绘制各种形状的画刷、为单个几何图形应用变化、改变不透明度或者变换整个形状层（通过DrawingGroup对象）。更富有戏剧性的是，可添加、删除和替换单个几何图形。&lt;/p&gt;

</description>
<pubDate>Mon, 17 Feb 2020 15:29:00 +0000</pubDate>
<dc:creator>Peter.Luo</dc:creator>
<og:description>通过上一章的学习，Geometry抽象类表示形状或路径。Drawing抽象类扮演了互补的角色，它表示2D图画(Drawing)——换句话说，它包含了显示矢量图像或位图需要的所有信息。 尽管有几类画图类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Peter-Luo/p/12324359.html</dc:identifier>
</item>
<item>
<title>OpenCV3入门（八）图像边缘检测 - 啊哈彭</title>
<link>http://www.cnblogs.com/pingwen/p/12324348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pingwen/p/12324348.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、边缘检测基础&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;图像的边缘是图像的基本特征，边缘点是灰度阶跃变化的像素点，即灰度值的导数较大或极大的地方，边缘检测是图像识别的第一步。用图像的一阶微分和二阶微分来增强图像的灰度跳变，而边缘也就是灰度变化的地方。因此，这些传统的一阶微分算子如Robert、Sobel、prewitt等，以及二阶微分算子Laplacian等等本质上都是可以用于检测边缘的。这些算子都可以称为边缘检测算子。&lt;/p&gt;
&lt;p&gt;边缘检测可以大幅度的减少数据量，剔除那些不相关的信息，保留图像重要的结构属性，一般的边缘检测的步骤有：&lt;/p&gt;
&lt;p&gt;1）滤波&lt;/p&gt;
&lt;p&gt;边缘检测主要基于图像的一阶和二阶微分，但是导数、微分对噪声很敏感，梯度计算容易受噪声影响，因此需要用滤波来抑制噪声。&lt;/p&gt;
&lt;p&gt;2）增强&lt;/p&gt;
&lt;p&gt;为了检测边界，需要确定邻域中灰度变化，增强边缘的基础是确定图像各点邻域强度的变化值，利用锐化突出了灰度变化的区域。&lt;/p&gt;
&lt;p&gt;3）检测&lt;/p&gt;
&lt;p&gt;经过增强的图像，邻域中很多点的梯度值比较大，但是并不是所有点都是边缘点，需要采用某种方法来取舍，一般使用阈值来划分图像各点。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、边缘检测算子&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;2.1&lt;/strong&gt;&lt;strong&gt;一阶微分算子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）原理&lt;/p&gt;
&lt;p&gt;图像的边缘就是图像灰度发生快速变化的地方。对于f(t)，其导数f'(t)反映了每一处的变化趋势，在变化最快的位置其导数最大，sobel算子的思路就是模拟求一阶导数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200217231757049-670583614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;其中：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200217231824852-1063701024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;梯度的方向就是函数f(x,y)最大变化率的方向。梯度的幅值作为最大变化率大小的度量，值为：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200217231859334-671913507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;离散的二维函数f(i,j)，可以用有限差分作为梯度的一个近似值。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200217231910814-1273262622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;为了简化计算，可以用绝对值来近似。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;|▽f(i,j)|= |f(i+1,j)-f(i,j)| +|f(i,j+1)-f(i,j)|&lt;/p&gt;
&lt;p&gt;2）Sobel算子&lt;/p&gt;
&lt;p&gt;Sobel算子是离散微分算子（discrete differentiation operator），用来计算图像灰度的近似梯度，梯度越大越有可能是边缘，Sobel集合了高斯平滑和微分求导，又被称为一阶微分算子、求导算子，在水平和垂直两个方向上求导，得到的是图像在X方法与Y方向梯度图像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/743748/202002/743748-20200217231943091-772966921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
CV_EXPORTS_W &lt;span&gt;void&lt;/span&gt; Sobel( InputArray src, OutputArray dst, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ddepth,
                         &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dx, &lt;span&gt;int&lt;/span&gt; dy, &lt;span&gt;int&lt;/span&gt; ksize = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
                         &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; scale = &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;double&lt;/span&gt; delta = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                         &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; borderType = BORDER_DEFAULT );
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
img = imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\WORK\\5.OpenCV\\LeanOpenCV\\pic_src\\pic7.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, IMREAD_GRAYSCALE);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;X方向梯度  &lt;/span&gt;
Sobel(img, imgX, CV_8U, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, BORDER_DEFAULT);
convertScaleAbs(imgX, imgX);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X方向Sobel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, imgX);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y方向梯度  &lt;/span&gt;
Sobel(img, imgY, CV_8U, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, BORDER_DEFAULT);
convertScaleAbs(imgY, imgY);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y方向Sobel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, imgY);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并梯度(近似)  &lt;/span&gt;
addWeighted(imgX, &lt;span&gt;0.5&lt;/span&gt;, imgY, &lt;span&gt;0.5&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, img2);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;整体方向Sobel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, img2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;输出结果为：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200217232049394-234960446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2&lt;/strong&gt;&lt;strong&gt;二阶微分算子&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1）原理&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;二维函数f(x,y)在二阶微分（拉普拉斯算子）的定义为：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200217232125131-24791015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200217232129337-236562584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;将上式相加后就得到拉普拉斯算子：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200217232158891-2104825790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;对应的滤波模板如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200217232230093-1306887709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;考虑到求绝对值计算梯度，正负系数图形的响应一样，上面的模板也可以表示为：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200217232312069-1425501279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;上面的模板具有对称性，所以求一次滤波就可以，不需要像一阶微分那样计算2次。&lt;/p&gt;
&lt;p&gt;2）应用&lt;/p&gt;
&lt;p&gt;拉普拉斯算子是二阶微分算子，对噪声敏感，Laplace算子对孤立象素的响应要比对边缘或线的响应要更强烈，因此只适用于无噪声图象。存在噪声情况下，使用Laplacian算子检测边缘之前需要先进行低通滤波。高斯-拉普拉斯算子，又称LoG算子，就是为了补充这种缺陷被创立的，它先进行高斯低通滤波，然后再进行拉普拉斯二阶微分锐化。&lt;/p&gt;
&lt;p&gt;示例如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
img = imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\WORK\\5.OpenCV\\LeanOpenCV\\pic_src\\pic7.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, IMREAD_GRAYSCALE);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img);
GaussianBlur(img, img2, Size(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;高斯图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img2);
Laplacian(img2, img3, CV_8U, &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Laplacian图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, img3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;输出结果为：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200217232404594-1307565740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3 Canny&lt;/strong&gt;&lt;strong&gt;算子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）原理&lt;/p&gt;
&lt;p&gt;在图像边缘检测中，抑制噪声和边缘精准定位是无法同时满足的，一些边缘检测算法通过平滑滤波去除噪声的同时，也增加了边缘检测的不确定性，而提高边缘检测算子对边缘的敏感性的同时，也提高了对噪声的敏感性。Canny算子力图在抗噪声干扰和精准定位之间寻求最佳折中方案。&lt;/p&gt;
&lt;p&gt;Canny算法主要有4个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用高斯滤波器来平滑图像；&lt;/li&gt;
&lt;li&gt;用一介偏导的有限差分来计算梯度的幅值和方向；&lt;/li&gt;
&lt;li&gt;对梯度进行非极大值抑制，保留极大值，抑制其他值；&lt;/li&gt;
&lt;li&gt;用双阈值算法检测和连接边缘。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;left&quot;&gt;2）应用&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;函数原型为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
CV_EXPORTS_W &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Canny( InputArray image, OutputArray edges,
                         &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; threshold1, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; threshold2,
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; apertureSize = &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;bool&lt;/span&gt; L2gradient = &lt;span&gt;false&lt;/span&gt; );
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;示例如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
img = imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\WORK\\5.OpenCV\\LeanOpenCV\\pic_src\\pic7.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, IMREAD_GRAYSCALE);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img);
Canny(img, img2, &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;canny&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, img2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出效果如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200217232530792-104129936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt;&lt;span&gt;修改阈值之后，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Canny(img, img2, 45, &lt;span&gt;90, 3);&lt;/span&gt;&lt;/span&gt;&lt;span&gt;效果如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200217232552534-1852831540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;、参考文献&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;、《&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenCV3&lt;/span&gt; &lt;span&gt;编程入门》，电子工业出版社，毛星雨著&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;、《学习&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;OpenCV&lt;/span&gt;&lt;span&gt;》，清华大学出版社，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Gary Bradski&lt;/span&gt;&lt;span&gt;，&lt;/span&gt; &lt;span lang=&quot;EN-US&quot;&gt;Adrian kaehler&lt;/span&gt;&lt;span&gt;著&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Sobel&lt;/span&gt;&lt;span&gt;边缘检测&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/yibeimingyue/p/10878514.html&quot;&gt;https://www.cnblogs.com/yibeimingyue/p/10878514.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;&lt;span&gt;、学习笔记&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;-canny&lt;/span&gt;&lt;span&gt;边缘检测&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/mmmmc/p/10524640.html&quot;&gt;https://www.cnblgs.com/mmmmc/p/10524640.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;2.9382716049383&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;个人博客，转载请注明。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/pingwen/p/12324348.html&quot;&gt;https://www.cnblogs.com/pingwen/p/12324348.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 17 Feb 2020 15:29:00 +0000</pubDate>
<dc:creator>啊哈彭</dc:creator>
<og:description>OpenCV3入门（八）图像边缘检测</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pingwen/p/12324348.html</dc:identifier>
</item>
<item>
<title>连载《一个程序猿的生命周期》-《发展篇》- 32.疫情中复工，跌宕起伏的2019，发展元年的2020 - 一个程序猿的生命周期</title>
<link>http://www.cnblogs.com/blog470130547/p/12323968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blog470130547/p/12323968.html</guid>
<description>&lt;p&gt;&lt;span&gt;       始料未及的长假，在悲喜交织中度过，奋斗一年的休整、安心的陪伴家人、实时关注的疫情。&lt;strong&gt;当自己真正成为生活的支点，慢慢的意识到这种状态不能够持久、也不能再持续下去了&lt;/strong&gt;。但是，当我们想复工的时候却是困难重重，乡亲不让出去、交通出不去、住处进不去，在想尽办法的时候，有公司却宣布倒闭了、裁员了，就发生在身边的事。从春节假期回家乡到复工，可以拍部电影《步步囧途记》。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.3892988929889&quot;&gt;
&lt;div readability=&quot;9.8523985239852&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/691334/202002/691334-20200217220039249-361103709.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;

&lt;p&gt;&lt;span&gt;       2019年让我想起来10年前的2009年，针对那一年写了一篇文章《&lt;a href=&quot;https://www.cnblogs.com/blog470130547/p/4524910.html&quot;&gt;本命年，在项目中忍受病魔&lt;/a&gt;》。2019年初，在深冬，为项目奔波于南方和北方，不小心受凉的导致腰的老毛病犯了，坐不下去又站不起来的感觉，拉着左脚很难受，直到现在还没有全部恢复正常状态。这就是2019年开始的身体状态，同时又面临全年的四大任务：生二胎、老大上小学、发布自己的产品和公司项目的推进。每一件事都需要亲自参与，又面临困难。&lt;strong&gt;1.生二胎&lt;/strong&gt;肯定需要陪伴在身边，还得应付客户发来的信息，同时处于半上班状态，偶尔去一下公司，喜出望外的是降临了一位小公主。&lt;strong&gt;2.老大上小学&lt;/strong&gt;，最让人操心了，房产不在划片内、户口也不在划片内，那也得努力去办。&lt;strong&gt;3.继绿色农业“创业”失败后&lt;/strong&gt;，又干起了软件行业的老本行，2018年组建了4个人的团队，开发了将近1年的时间，目标是发布自己的产品，产品规划、网站规划、市场宣传等等，都要提前做足工作；2019年5月底正式发布1.0版本，下半年确实有销售额，这给予团队很大的鼓舞；我时常对团队人员说：&lt;strong&gt;作为技术人员没有像样产品，怎么在江湖中和别人PK呢&lt;/strong&gt;；这部分内容，我会单独写文章进行介绍，不在此赘述了。&lt;strong&gt;4.关于公司项目推进前前后后的事&lt;/strong&gt;，包括自己的思考，已经在前面的文章介绍了，并没有发到网站上，可以到公众号（&lt;strong&gt;iterlifetime&lt;/strong&gt;）查看；对于我，这个项目成功的地方是在项目初期最困难的时候打开了局面；这个项目失败的地方是由于积累的不足，项目后期换团队执行，但是从效果来看，还不如我们一开始的框架结构，当然也有交流过程中的问题；这个项目窝火的地方是，管理机制、协调能力、判断失真、商务力度不够等等；这个项目好的地方是最终验收了。年终自己的团体一起吃饭的时候，我说最让我焦虑的事就是产品发布，有三个原因：&lt;strong&gt;1.奋斗了将近1年，肯定要有成果；2.对于我们的将来会多一条路选择；3.有成果、有路了，就要有回报&lt;/strong&gt;。当然，回报的事主要是我的义务和责任。对于家庭和公司项目，都是顺其自然的事，前者是平平安安就好，后者是多方面因素、力所不能及。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       有了产品之后，我们把2020年定为了发展的元年，也可以算是一个程序猿的生命周期的新起点。&lt;strong&gt;受疫情的影响，大部分人都持悲观的态度，但是我持乐观态度，用王毅外长的话：新冠肺炎疫情受控后，中国将浴火重生&lt;/strong&gt;。不管从哪方面都会有质的改变，没有客观条件的影响，始终无法达到质变的过程。&lt;strong&gt;就像公司开发平台或产品，没有用户各种怼，领导始终认为两三个人就可以搞定了&lt;/strong&gt;。&lt;strong&gt;从相反角度思考，在形势大好的时候，人与人之间的能力相差30%，可能看不出来有多大的差别；但是形势不好的时候，就能看出来谁在发光、谁在裸泳&lt;/strong&gt;。我们也有明显的不足，缺少市场能力，尽力补足这个短板，组建了合作模式的销售团队，尽管效果可能不是太好，但是总比没有要强很多。总体而言，我们要做好四方面的工作：一是继续开发，二是找市场，做项目，三是卖产品，四是找靠山。尽管人少事多，我相信不能够大成功、肯定可以小成功。想想起初13个人的团队，都能GM成功的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       从2019年过度到2020年，给我的感觉像是一部车在平稳行驶的过程中突然抛锚了，我们在想办法如何尽力重新启动它，必定是在挑战中看到更多的机遇。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;hr/&gt;&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div readability=&quot;6.241134751773&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个程序猿的生命周期 微信平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;口   号：职业交流，职业规划；面对现实，用心去交流、感悟。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号：iterlifetime&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;百木-ITer职业交流奋斗 群：141588103&lt;/strong&gt;   &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二维码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/691334/201606/691334-20160618075950167-974887453.jpg&quot; alt=&quot;&quot; width=&quot;120&quot; height=&quot;120&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 17 Feb 2020 14:05:00 +0000</pubDate>
<dc:creator>一个程序猿的生命周期</dc:creator>
<og:description>始料未及的长假，在悲喜交织中度过，奋斗一年的休整、安心的陪伴家人、实时关注的疫情。当自己真正成为生活的支点，慢慢的意识到这种状态不能够持久、也不能再持续下去了。但是，当我们想复工的时候却是困难重重，乡</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/blog470130547/p/12323968.html</dc:identifier>
</item>
<item>
<title>shellcode 反汇编，模拟运行以及调试方法 - potatso</title>
<link>http://www.cnblogs.com/potatsoSec/p/12323899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/potatsoSec/p/12323899.html</guid>
<description>&lt;h3 id=&quot;onlinedisassembler&quot;&gt;onlinedisassembler&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://onlinedisassembler.com&quot; class=&quot;uri&quot;&gt;https://onlinedisassembler.com&lt;/a&gt; 在线反汇编工具，类似于lda。功能比较单一。&lt;br/&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;any.run-等平台在线分析&quot;&gt;Any.run 等平台在线分析&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;将shellcode保存为文件&lt;/li&gt;
&lt;li&gt;通过如下脚本，转换shellcode为char数组&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;import binascii
filename = &quot;C:\\Users\\liang\\Desktop\\工作相关\\样本\\rdpscan\\rdpscan\\ssleay32.dll&quot;
#filename = &quot;C:\\Users\\liang\\Desktop\\payload&quot;

shellcode = &quot;{&quot;
ctr = 1
maxlen = 15

for b in open(filename, &quot;rb&quot;).read():
    shellcode += &quot;0x&quot; + str(binascii.hexlify(b.to_bytes(length=1, byteorder='big')))[2:4] + &quot;,&quot;
    if ctr == maxlen:
        shellcode += &quot;\n&quot;
        ctr = 0
    ctr += 1
shellcode = shellcode[:-1] + &quot;}&quot;
print(shellcode)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;将结果复制到char shellcode处，并 通过如下vs程序加载shellcode&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;#include &amp;lt;windows.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#pragma comment(linker, &quot;/section:.data,RWE&quot;)  

unsigned  char shellcode[] = 复制到这里

typedef void(__stdcall* CODE) ();

int main()
{

    PVOID p = NULL;
    if ((p = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)) == NULL)
        MessageBoxA(NULL, &quot;申请内存失败&quot;, &quot;提醒&quot;, MB_OK);
    if (!(memcpy(p, shellcode, sizeof(shellcode))))
        MessageBoxA(NULL, &quot;写内存失败&quot;, &quot;提醒&quot;, MB_OK);

    CODE code = (CODE)p;

    code();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设置c运行库的静态编译，如图设置，将运行库设置为多线程/MT&lt;br/&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B2%5D.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;点击生成解决方案，将生成的exe上传至Any.run去分析&lt;br/&gt;如图，即可通过在线分析平台去分析shellcode。简单快捷&lt;br/&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B3%5D.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;槽点主要有如下几方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一定要选择静态编译c运行库，因为Any.run 的运行库可能会不全。以防万一&lt;/li&gt;
&lt;li&gt;shellcode不可以是\xFF 这类形式，必须是0xFF。因为前者属于字符串，后者属于数组。待分析的shellcode较大，超过65535字节后，vs在编译时会报错 &lt;code&gt;fatal error C1091: compiler limit: string exceeds 65535 bytes in length&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;scdbg&quot;&gt;scdbg&lt;/h3&gt;
&lt;p&gt;windows shellcode运行模拟器，模拟运行shellcode&lt;br/&gt;对于简单的shellcode 推荐使用此方法，模拟运行找到c2地址&lt;/p&gt;
&lt;p&gt;使用文章以及介绍&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://isc.sans.edu/forums/diary/Analyzing+Encoded+Shellcode+with+scdbg/24134&quot; class=&quot;uri&quot;&gt;https://isc.sans.edu/forums/diary/Analyzing+Encoded+Shellcode+with+scdbg/24134&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;支持debug shellcode&lt;/li&gt;
&lt;li&gt;dum内存&lt;/li&gt;
&lt;li&gt;重定向tcp请求到其他机器，但是不支持urlopen等函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;功能较为单一，模拟运行不是很全。有时候可能执行不到某些流程。并且没有实现部分dll的导出函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;图片&lt;br/&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B4%5D.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载链接&lt;br/&gt;&lt;a href=&quot;http://sandsprite.com/CodeStuff/scdbg.zip&quot; class=&quot;uri&quot;&gt;http://sandsprite.com/CodeStuff/scdbg.zip&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;miasm&quot;&gt;miasm&lt;/h3&gt;
&lt;p&gt;miasm是一个python llvm写的逆向工程框架。&lt;/p&gt;
&lt;p&gt;但是官方中提供了很多例子，我们可以直接利用官方提供的脚本去完成很多任务&lt;/p&gt;
&lt;p&gt;miasm不仅仅支持pe文件，还支持elf等，支持x86，arm，mips等架构&lt;/p&gt;
&lt;p&gt;miasm功能不仅仅局限于这些，还有很多好玩的功能，例如自动化脱壳等。参考&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://miasm.re/blog/index.html&quot; class=&quot;uri&quot;&gt;https://miasm.re/blog/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/cea-sec/miasm/&quot; class=&quot;uri&quot;&gt;https://github.com/cea-sec/miasm/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;miasm-反编译shellcode&quot;&gt;miasm 反编译shellcode&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B6%5D.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用graphviz 加载got文件，获得如下&lt;br/&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B5%5D.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B7%5D.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同理 arm的选择arm，mips选择mips处理器类型&lt;/p&gt;
&lt;p&gt;如果不像使用官方自带，可以自己写&lt;/p&gt;
&lt;h4 id=&quot;沙箱中运行shellcode&quot;&gt;沙箱中运行shellcode&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B8%5D.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;记录每步运行的各种寄存器的值&lt;/p&gt;
&lt;h4 id=&quot;沙箱中运行可执行系统文件&quot;&gt;沙箱中运行可执行系统文件&lt;/h4&gt;
&lt;p&gt;在知道系统架构的情况下 可以选择相应系统架构的sandbox，运行shellcode，从而获得更多信息&lt;br/&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B9%5D.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以支持自写dll，方便hook，如图，但是我没写&lt;br/&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B10%5D.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;支持的系统架构如下&lt;br/&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B11%5D.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;其他功能&quot;&gt;其他功能&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;添加断点&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;    # A breakpoint callback takes the jitter as first parameterdef dump(jitter):
        # Dump data ad address run_addr with a length of len(data)
        new_data = jitter.vm.get_mem(run_addr, len(data))
        # Save to disk
        open('/tmp/dump.bin', 'wb').write(new_data)
        # Stop execution
        return False

    # Register a callback to the breakpointmyjit.add_breakpoint(0x4000004b, dump)...myjit.cpu.EAX = 0x40000000myjit.init_run(run_addr)myjit.continue_run()
    &lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;hook沙箱中系统函数和peb等和数据结构&lt;br/&gt;例如hook urlmon_URLDownloadToCacheFileW&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;
    def urlmon_URLDownloadToCacheFileW(jitter):
        ret_ad, args = jitter.func_args_stdcall([&quot;lpunkcaller&quot;,
                                                 &quot;szurl&quot;,
                                                 &quot;szfilename&quot;,
                                                 &quot;ccfilename&quot;,
                                                 &quot;reserved&quot;,
                                                 &quot;pbsc&quot;])
        url = jitter.get_str_unic(args.szurl)
        print &quot;URL:&quot;, url
        jitter.set_str_unic(args.szfilename, &quot;toto&quot;)
        jitter.func_ret_stdcall(ret_ad, 0)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;注意 有时候程序调用沙箱没有实现的api，则需要通过上述该方法自己实现一个&lt;br/&gt;sandbox 默认只实现了以下几个dll的导出函数 ntdll.dll&quot;, &quot;kernel32.dll&quot;, &quot;user32.dll&quot;,&lt;br/&gt;&quot;ole32.dll&quot;, &quot;urlmon.dll&quot;,&lt;br/&gt;&quot;ws2_32.dll&quot;, 'advapi32.dll', &quot;psapi.dll&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;读写并修改系统可执行文件&lt;br/&gt;例如pe文件的修改，添加.text区段，修改pe文件结构等。当然，也支持elf，mach-o文件的修改等&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;import sys
from elfesteem import pe_init

# Get the shellcode
data = open(sys.argv[1]).read()
# Generate a PE
pe = pe_init.PE(wsize=32)
# Add a &quot;.text&quot; section containing the shellcode to the PE
s_text = pe.SHList.add_section(name=&quot;.text&quot;, addr=0x1000, data=data)
# Set the entrypoint to the shellcode's address
pe.Opthdr.AddressOfEntryPoint = s_text.addr
# Write the PE to &quot;sc_pe.py&quot;
open('sc_pe.exe', 'w').write(str(pe))&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;思维扩展&quot;&gt;思维扩展&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;sandbox加载一个pe文件&lt;/li&gt;
&lt;li&gt;在pe文件中申请一段内存，存放shellcode&lt;/li&gt;
&lt;li&gt;修改eip到shellcode处&lt;/li&gt;
&lt;li&gt;运行&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好处，可以结合pe文件自动分析，分析处该shellcode的具体行为&lt;br/&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B12%5D.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;od加载shellcode&quot;&gt;OD加载shellcode&lt;/h3&gt;
&lt;h4 id=&quot;方法一&quot;&gt;方法一&lt;/h4&gt;
&lt;p&gt;需要安装Olly Advanced 插件&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;随便load一个应用程序&lt;/li&gt;
&lt;li&gt;Alt+m 打开内存页面，添加内存，如图&lt;br/&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B13%5D.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;将shellcode复制进去&lt;/li&gt;
&lt;li&gt;设置新的eip&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;方法二&quot;&gt;方法二&lt;/h4&gt;
&lt;p&gt;该方法灵活应用&lt;br/&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B14%5D.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图我们可以看出，加载shellcode的方式有以下几个步骤&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;调用virtualloc申请内存，属性为可写可执行。用来存放shellcode&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;调用createprocess 执行shellcode&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意，并不是一定通过createprocess去执行shellcode。也可以通过内联汇编jmp，setThreadContext等方式去执行shellcode。理论上，只要可以修改eip，就可以执行shellcode&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;od中输入命令 &lt;code&gt;bp createprocess&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;等运行shellcode的时候，od会自动停在createprocess处，也就是shellcode开始执行的位置。如图&lt;br/&gt;&lt;img src=&quot;https://potatso-1253210846.cos.ap-beijing.myqcloud.com//imgImage%20%5B15%5D.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Feb 2020 13:51:00 +0000</pubDate>
<dc:creator>potatso</dc:creator>
<og:description>shellcode 反汇编，模拟运行以及调试方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/potatsoSec/p/12323899.html</dc:identifier>
</item>
<item>
<title>量子计算机编程(一)——QPU编程 - 夏天喵</title>
<link>http://www.cnblogs.com/zmzzzz/p/12323743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zmzzzz/p/12323743.html</guid>
<description>&lt;p&gt;今天要给大家介绍的是这本书《Programming Quantum Computers —— Essential Algorithms and Code Samples》，主要讲如何在量子计算机上编程，又示例的代码可以跑 &lt;a href=&quot;https://oreilly-qc.github.io./&quot; class=&quot;uri&quot;&gt;https://oreilly-qc.github.io./&lt;/a&gt; ，这本书的理解方向是纯粹计算机的，连矩阵都很少涉及，一个量子计算机就像是协处理器一样，很像我们现在的GPU。&lt;/p&gt;
&lt;p&gt;这本书一共分为三个部分，我也将分成三篇文章来写，这是第一部分QPU的编程。&lt;/p&gt;
&lt;h3 id=&quot;单量子比特&quot;&gt;单量子比特&lt;/h3&gt;
&lt;p&gt;这本书中对于量子的表达方式如下circle notation：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217211706598-276169305.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217211801003-198200820.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;蓝色圈的面积就是这个量子态测量后是这个状态的概率，中间的蓝色短线代表他们的相位，因为全局相位也观察不出来，所以一般&lt;span class=&quot;math inline&quot;&gt;\(|0\rangle\)&lt;/span&gt;就是朝上的。对于一个量子比特来说，重要的也就这两个，magnitude和relative phase（可能因为重要的是概率大小，所以他其实没有提amplitude其实是一个复数）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217211846977-1396478040.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个态实际上是等价的。&lt;/p&gt;
&lt;p&gt;电路图呢，一般长这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217211922116-1829431679.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个电路图对应的代码如下：（这个例子都可以在上面那个网站上跑起来）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;qc.reset(1);         // allocate one qubit
qc.write(0);         // write the value zero
qc.had();            // place it into superposition of 0 and 1
var result = qc.read();  // read the result as a digital bit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一步就是申请一个qubit，就像你要给变量分配空间一样。&lt;/p&gt;
&lt;p&gt;第二步写0，其实写0很容易，你可以直接测量，要么0，要么1，如果结果是1的话，再做一个not操作就好；当然，你要是嫌麻烦，对于一个qubit，长时间的静置他，他也会变成0，毕竟还是基态比较稳定。&lt;/p&gt;
&lt;p&gt;第三步就是进行一个H门的操作&lt;/p&gt;
&lt;p&gt;第四步读，其实就是测量了&lt;/p&gt;
&lt;h4 id=&quot;常见的作用于单量子比特操作的表达方式&quot;&gt;常见的作用于单量子比特操作的表达方式：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217211947797-1496615007.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217212002193-1678806872.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中值得一提的是PHASE相位操作，phase操作只作用在 &lt;span class=&quot;math inline&quot;&gt;\(|1\rangle\)&lt;/span&gt; 上，因为他的效果是改变相对相位，如果大家都改变就没有什么用了。可能有同学听说过绕X轴旋转和绕Y轴旋转，这些都是针对Bloch球的表达方式，与这里的circle notation的方式不要弄混了。&lt;/p&gt;
&lt;p&gt;一个操作也可能是其他几个操作的组合，比如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217212027942-2141364674.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们可以把not变成H+180°旋转+H，那么我们也可以把中间的180°旋转变成两个90°的旋转，中间再加上两个H，因为&lt;span class=&quot;math inline&quot;&gt;\(HH=I\)&lt;/span&gt;，他们可以相互抵消，这样我们还可以得到RNOT：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217212055794-1370329558.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;COPY：&lt;/strong&gt;这是一个需要注意的操作，因为量子程序里没有复制，这也保障了量子传输的信息不会被窃听， 因为你要窃听，你就需要去读，一读就是测量，而量子比特一测量就是坍缩。由于量子不能复制，所以，上述所有操作都是在原有的那个比特上操作的，所以操作就会被发现。&lt;/p&gt;
&lt;p&gt;一个简单例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217212127242-926340580.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这里例子来说， &lt;span class=&quot;math inline&quot;&gt;\(A_1\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(A_2\)&lt;/span&gt; 是对qubit Hadmard门操作后测量得到的随机值，因为这个是真随机，所以就不会被窃听者提前知道或者预估，那么当我传输这个被我用红色圈出来的比特的时候，spy并不知道这个比特是否执行了H门和not操作，那他就只能猜了，25%的概率，图里面所示就是他猜有执行了，然后他再按照他的猜测如法炮制一个qubit继续传递，当B收了这个bit后，B也随机一个数据&lt;span class=&quot;math inline&quot;&gt;\(B_2\)&lt;/span&gt;，看是否执行H门，然后测量。这个时候消息也都收到了，测量也都测量好了，那么把 &lt;span class=&quot;math inline&quot;&gt;\(A_2\)&lt;/span&gt;的信息发过来也和窃听没有关系了，如果 &lt;span class=&quot;math inline&quot;&gt;\(B_2\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(A_2\)&lt;/span&gt; 的结果一样，那么测量结果应该一样，如果不一样，那么一定被窃听了。&lt;/p&gt;
&lt;p&gt;这样的成功概率有多少呢？ &lt;span class=&quot;math inline&quot;&gt;\(B_2\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(A_2\)&lt;/span&gt; 一样的概率0.5，在这种情况下spy被发现的概率0.25。看起来不是很高，但是如果我们有一百个比特先检测一下这条线路，不被发现的概率将会降到百万分之一。&lt;/p&gt;
&lt;p&gt;现在来看一下代码：&lt;a href=&quot;https://oreilly-qc.github.io/?p=2-4&quot; class=&quot;uri&quot;&gt;https://oreilly-qc.github.io/?p=2-4&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;q#&quot;&gt;
&lt;code&gt;qc.reset(3);//申请三个qubit
qc.discard();
var a = qint.new(1, 'alice'); //给其中一个变量命名为a,但是画出来的电路图中显示alice
var fiber = qint.new(1, 'fiber');
var b = qint.new(1, 'bob');

function random_bit(q) {//对一个初始化为0的比特，进行H操作，然后测量，测量结果是随机的
    q.write(0);
    q.had();
    return q.read();
}

// Generate two random bits
qc.label('get two random bits');
var send_had = random_bit(a);//得到是否执行H门的随机值
var send_value = random_bit(a);//得到是否not的随机值
qc.label('');

// Prepare Alice's qubit
a.write(0);//a重新赋值为0，所以前面取随机值的操作也可以在a上进行
qc.label('set value');
qc.nop();
if (send_value)
    a.not();
qc.nop();
qc.label('');
qc.nop();
qc.label('apply had');
qc.nop();
if (send_had)
    a.had();
qc.nop();
qc.label('');

// Send the qubit!
fiber.exchange(a);

// Activate the spy
var spy_is_present = true;
if (spy_is_present)
{
    var spy_had = 1;
    qc.nop();
    qc.label('spy');
    if (spy_had)
        fiber.had();
    stolen_data = fiber.read();
    fiber.write(0);
    if (stolen_data)
        fiber.not();
    if (spy_had)
        fiber.had();
    qc.label('');
    qc.nop();
}

// Receive the qubit!
var recv_had = random_bit(b);
fiber.exchange(b);
qc.label('apply had');
qc.nop();
if (recv_had)
    b.had();
qc.nop();
qc.label('');
qc.nop();
qc.label('read value');
qc.nop();
recv_val = b.read();
qc.nop();
qc.label('');
qc.nop();

// Now Alice emails Bob to tell
// him her had setting and value.
// If the had setting matches and the
// value does not, there's a spy!
if (send_had == recv_had)
    if (send_value != recv_val)
        qc.print('Caught a spy!\n');&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多量子比特&quot;&gt;多量子比特&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217212212545-975201346.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多量子比特的表示方法和单量子比特没有什么区别，下面的数字就是把他们从01的二进制换算成了我们熟悉的十进制。0x是十六进制的表示方法，最上面的是地位，正好可以not操作表示了出来，0就是000，1就是001，2就是010……以此类推&lt;/p&gt;
&lt;p&gt;真要说和单量子比特的区别，那主要是两方面，一个是纠缠；另一个就是受控操作。&lt;/p&gt;
&lt;h4 id=&quot;纠缠&quot;&gt;纠缠&lt;/h4&gt;
&lt;p&gt;纠缠好说，两个纠缠的量子比特就是其中一个的测量结果会影响另一个。&lt;/p&gt;
&lt;p&gt;具体呢，可以看一下我的这篇文章&lt;a href=&quot;https://www.cnblogs.com/zmzzzz/p/11063756.html&quot;&gt;量子纠缠1——量子比特、Bell态、EPR佯谬&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;受控操作&quot;&gt;受控操作&lt;/h4&gt;
&lt;p&gt;受控操作就是说有两类比特，一个是用来控制的，另一个是被控制的。&lt;/p&gt;
&lt;p&gt;比如大家耳熟能详的CNOT，当控制比特是1的时候，就翻转被控制的比特，如果控制比特是0的时候，那就不做操作。还有CCNOT门，又叫做toffli门，有两个控制比特，只有当他们都为1的时候才翻转。&lt;/p&gt;
&lt;p&gt;现在要介绍一个前面没有提过的CPHASE受控相位门，和CNOT相似，同样是当控制比特为1的时候才进行，但是正如前面我们提过，PHASE操作只操作在1上，也就是说，如果这个操作被执行其实只有一种情况，那就是&lt;span class=&quot;math inline&quot;&gt;\(|11\rangle\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;在前面我们表示过一个旋转180°的相位操作可以表示成一个 H+NOT+H &lt;strong&gt;figure 2-14&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么现在受控相位操作拥有了三种表示方法：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217212247257-784173801.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当控制比特为0的时候，CNOT就不会发生，两个H又正好抵消了。&lt;/p&gt;
&lt;h4 id=&quot;phase-kickback&quot;&gt;phase kickback&lt;/h4&gt;
&lt;p&gt;在这之所以说这么多的受控相位操作是因为这里面有个一很有趣的小技巧 &lt;strong&gt;QPU Trick: Phase Kickback&lt;/strong&gt; 来看下面这个电路图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217212310095-1324753452.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个电路图很容易理解，一种理解方式就是把register 1当作控制比特，register 2 当作受控比特，两个H门使得register 1变成了等可能的四种情况 &lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}|00\rangle+\frac{1}{2}|01\rangle+\frac{1}{2}|10\rangle+\frac{1}{2}|11\rangle\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;现在来看看结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217212335611-129809605.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为register 2并不是叠加态，所以没有相对相位，而绝对相位又测不出来，所以他可以说是没有变的，改变了的，反而是register 1 ， &lt;span class=&quot;math inline&quot;&gt;\(|3\rangle\)&lt;/span&gt; 转了135°是因为两个都为1，45°和90°都转了。作为一个受控操作，控制比特反而变了，而受控比特没有改变。&lt;/p&gt;
&lt;h4 id=&quot;swap&quot;&gt;swap&lt;/h4&gt;
&lt;p&gt;受控操作当然也能连在一起，得到一些有用的结果，比如三个CNOT操作，他就可以交换两条线路。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217212409497-650524052.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个的证明是一件很容易的事情，你可以取一个任意态推一边，专门把这个提出来说一遍是因为这个还能做一件有趣的事情，那就是验证两个比特是否相等。我们需要用到的是CSWAP，即当控制比特为1时才交换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654058/202002/1654058-20200217212450771-1743969164.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们的output比特经过H门后，他就变成了等概率的 &lt;span class=&quot;math inline&quot;&gt;\(|0\rangle\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(|1\rangle\)&lt;/span&gt; 经过一个CSWAP，为1情况下的input1和input2就会交换，也就是说他们原来x概率的ab就变成了x概率的ba了，这样的问题出在哪？&lt;/p&gt;
&lt;p&gt;如果概率还是原来的分布，那么在经过一个H门output等待率的 &lt;span class=&quot;math inline&quot;&gt;\(|0\rangle\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(|1\rangle\)&lt;/span&gt; 又会化简成 &lt;span class=&quot;math inline&quot;&gt;\(|0\rangle\)&lt;/span&gt; ，各种各样的 &lt;span class=&quot;math inline&quot;&gt;\(|1\rangle\)&lt;/span&gt; 的概率会相互抵消掉，那么在经历一个NOT操作就一定会得到１。&lt;/p&gt;
&lt;p&gt;那，如果这两个数据不一样，就一定得不到１吗？不一定，只是他有概率不是１，而一旦有概率不是１，那只要多检测几次就一定能检测出来，就像上面那个窃听一样，明明只有四分之一的概率，但仅需要一百次，测不出来的可能性就降到了百万分之一。&lt;/p&gt;
&lt;p&gt;当然，代码在这里https://oreilly-qc.github.io/?p=3-4，这也是这本书的特色了。&lt;/p&gt;
&lt;p&gt;受控操作当然不止这些，但是很多受控操作都可以分解成CNOT加上一些相位操作，我们可以自己构造自己需要的操作。&lt;/p&gt;
&lt;h4 id=&quot;远距离操控随机&quot;&gt;远距离操控随机&lt;/h4&gt;
&lt;p&gt;这里的远距离操控不是指我能扣确定他是什么，如果我能确定，那就不是随机了，而是说，我把两个比特弄成纠缠，当我一个测出来是0的时候，另一个以x%的概率得到0，至于我测出来是不是0看天意，对面测出来是不是0，也看天意，其中唯一能确定的，就只有这个x了。&lt;/p&gt;
&lt;p&gt;这个例子是书上例子3-6 &lt;a href=&quot;https://oreilly-qc.github.io/?p=3-6&quot; class=&quot;uri&quot;&gt;https://oreilly-qc.github.io/?p=3-6&lt;/a&gt; 方法很简单，就是我H门操作后，我旋转45°的角度，这样再来一个H门，因为相位变了，符号对不上，所以回不去了，就有了关联。&lt;/p&gt;
&lt;p&gt;更强大的一点的应用是——量子隐形传态，&lt;a href=&quot;https://www.cnblogs.com/zmzzzz/p/11087037.html&quot;&gt;量子隐形传态 Quantum Teleportation&lt;/a&gt; 提过了，就不在累述。&lt;/p&gt;
</description>
<pubDate>Mon, 17 Feb 2020 13:28:00 +0000</pubDate>
<dc:creator>夏天喵</dc:creator>
<og:description>今天要给大家介绍的是这本书《Programming Quantum Computers —— Essential Algorithms and Code Samples》，主要讲如何在量子计算机上编程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zmzzzz/p/12323743.html</dc:identifier>
</item>
<item>
<title>如何快速融入团队并成为团队核心（七） - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/12323489.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/12323489.html</guid>
<description>&lt;p&gt;今天继续讨论一下如何提高自己的工作效率，讨论完个人精力分配，接着讨论开会的问题。开会确实是影响个人效率的关键问题，我曾经分析过，一家中小型互联网公司的中层管理者，几乎每周有八分之一到六分之一的时间是在开会中度过。&lt;/p&gt;
&lt;p&gt;中国人是如此的热衷于开会，大事开大会，小事开小会，似乎没什么是开会不能解决的问题。如果说“有人的地方就有江湖”，那么大概还有一个类似的说法可以说成“有人的地方就有会议”。&lt;/p&gt;
&lt;p&gt;开会大概本身是为了提高效率，却最终变成了一种低效的行为，这背后究竟发生了什么呢。&lt;/p&gt;

&lt;p&gt;我还记得曾经在一家公司工作时，那家公司老板特别喜欢做下面这件事：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;每次选在上午10点多左右，以讨论需求和产品远期发展规划为由，拉上一群相关或不相关的人员，然后大家一起在会议室中，对着空气发表对未来的规划，老板开始抽他的芙蓉王，听大家互相扯淡。&lt;br/&gt;闲时老板还允许你自己泡一杯咖啡或一杯茶，总之就是空谈；然后就这么闲聊到下午两点，然后老板一拍大腿，呀，不小小心又开了这么久的会了，走，一起吃饭去。&lt;br/&gt;然后大家聚个餐，到下午四点。然后这个会算是正式结束了么？并没有，晚上11点，老板再给几个相关人员打电话，一起聚集到他位于湘江边两百平大宅附近的一个茶馆中，继续讨论白天的话题，一壶红茶不加七八次水，几乎也难得消停，就这么开到凌晨三四点，然后散会。（第二天早上得准点9点上班。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的同事称其为“神仙会”。“一壶茶一包烟，快乐似神仙”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202002/191302-20200217203523664-110770284.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，等闲的人大概是没有资格参加这些会的，能够有幸参会并能把全场通关的往往都是中层或高层管理者，毕竟开会其实也是企业文化的一部分，如果你连这点开会都不能接受，又如何能接受公司的价值观和企业文化呢。。&lt;/p&gt;
&lt;p&gt;当然，每次叫我开会，我都会选择听前15分钟，因为，有时候如果一个事情连15分钟都不能说明白，说明这个会的价值已经不太存在了，要么是双方根本不在同一个频道上，要么就是有一方根本没用心的准备与会议相关的话题。当然，有许多相对来说年长的管理者信奉会议就是企业管理的核心，总是想尽一切办法拉更多的人来开会，而且动不动就头脑风暴，这样的效率到底是高还是不高呢，大家其实内心都很清楚。&lt;/p&gt;

&lt;p&gt;必须承认，有时选择开会是团队内部进行澄清事实、发现问题的非常关键的方法，有时候确实也如同第四篇说的，甚至可以称为是不同团队间进行团队建设的一种形式，不过显然在互联网时代的今天，层出不穷的各种会议往往让从业人员深受其害。&lt;/p&gt;
&lt;p&gt;例如基于敏捷项目管理的产品研发流程中，也规定了“站立会议”，“计划会”，“评审会”，“反思会”，其中站立会议说的是不超过十五分钟，要求每个人用三个问题将自己做的事情讲清楚“我做完了什么”，“遇到了什么”，“计划今天做什么问题”，但是实际操作过程中，也难免会陷入文山会海的谜团中。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202002/191302-20200217203531586-554797727.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，某某某作为后端工程师，同时参与了3个产品的研发，如果每个产品需要开一个站立会议，那么意味着保守得准备一小时的开会时间。问题是，如何确保一个会能够在十五分钟开完，其次，究竟有几个人能够用短短几句话讲清楚自己的需求？&lt;/p&gt;
&lt;p&gt;于是有的会，原本应该是任务会的，结果开成了头脑风暴会，一群人针对某个议题讨论半天，看起来最后也形成了结论，但是这样的结论却是以消耗了四五个人两三个小时的工时为代价，如果不是通过这样开会的形式，难道就无法形成一个可用的结果么。&lt;/p&gt;
&lt;p&gt;有事没事就头脑风暴，似乎也成为互联网开发者们经常吐槽的话题。仿佛如果一群人如果不通过开头脑风暴的形式，似乎就无法收集到足够多的创意一般。当然，大概是因为平时大家手头上的工作本身也做不完，但是作为领导呢，总担心大家会闲着，所以想着法子让大家过得更加充实。通过开会的形式，让大家先把手头上的工作先暂时放一下，我们先切换到一个新的副本=》会议室。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202002/191302-20200217203540687-1957178054.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后针对性一个或许与当前工作无关的话题讨论一下，以便把大家脑海中的创造性思维彻底的掏空（毕竟互联网公司已经不需要创意了，要的是如何快速的借鉴（copy to our company））。&lt;/p&gt;
&lt;p&gt;当然，开会也使得我们能够放空一下~但是这样的放空最终牺牲了下班后的时间，从这一点上看开会大概约等于996，如果哪一天开了四次会，那大概这一天的白天全部荒废了。然后就花费了大量精力做的许多事情，都是在用自己的苦劳证明自己在为公司抛头颅洒热血般的拼命而已。&lt;/p&gt;

&lt;p&gt;所以在团队中如果要提高自己的工作效率，就得想办法思考如何提高团队会议效率的方法，也许这些方法无法在短期内实现自己劳动生产力的提高，但是会逐渐的形成我们自己的微习惯，并进而逐渐改变我们做事的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202002/191302-20200217203551014-1118694903.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些方法或许可以包括以下这些策略：&lt;/p&gt;
&lt;p&gt;1、灵活的运用罗伯特议事规则：这是一个来源于大洋彼岸的开会规则，甚至于联合国或美国国会开会都是用这套规则，美国国会参议院和众议院都是大几百号议员开会，每天讨论的都是世界性大事，我想我们的开会复杂度应该不会比这个高了吧。在这套规则中，包括大概动议、复议、陈述议题、辩论、表决等许多个步骤，制定了一系列规则，例如未经动议不可讨论，主持人不能偏袒动议、强调发言完整等。（当然，大概许多人都会认为自己公司还没有复杂到需要动用罗伯特议事规则来开会的情况，但是谁知道呢。开会的时候大部分情况下的纠结，还不是不同观点持有者从自己的专业角度出发，认为某些问题值得做，不值得做，该怎么做，结果与其他人意见相左而引发的矛盾纠纷呢。。）&lt;/p&gt;
&lt;p&gt;2、不要盲目的开头脑风暴会，尽可能的先用头脑风暴调查。先针对需要讨论的产品需求提出调查，让相关方针对问题进行思考，形成一个大概的方向后，再通过会议的形式进行交流讨论，从而使得问题的思考时间尽可能的前置，避免了参会者在会议的前十五分钟还不清楚这个会是干什么的尴尬情况。&lt;/p&gt;
&lt;p&gt;3、能不开会就别开会、要开也得站着开。&lt;/p&gt;
&lt;p&gt;4、每次开会先选择一个主持人，这个主持人配备一个秒表，超时立马让有关人员结束他的表述。如果一个人连五分钟都无法把自己的问题讲清楚。。那这个人还是很厉害的，他有做老板的潜质。&lt;/p&gt;
&lt;p&gt;真爱生命，远离低效的会议，我们将逐渐积累属于自己的小成功。&lt;/p&gt;
</description>
<pubDate>Mon, 17 Feb 2020 12:36:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>一、引言 今天继续讨论一下如何提高自己的工作效率，讨论完个人精力分配，接着讨论开会的问题。开会确实是影响个人效率的关键问题，我曾经分析过，一家中小型互联网公司的中层管理者，几乎每周有八分之一到六分之一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/12323489.html</dc:identifier>
</item>
<item>
<title>【Java并发工具类】ReadWriteLock - sakuraxx</title>
<link>http://www.cnblogs.com/myworld7/p/12323467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myworld7/p/12323467.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前面介绍过&lt;code&gt;ReentrantLock&lt;/code&gt;，它实现的是一种标准的互斥锁：每次最多只有一个线程能持有ReentrantLock。这是一种强硬的加锁规则，在某些场景下会限制并发性导致不必要的抑制性能。互斥是一种保守的加锁策略，虽然可以避免“写/写”冲突和“写/读”冲突，但是同样也避免了“读/读”冲突。&lt;/p&gt;
&lt;p&gt;在读多写少的情况下，如果能够放宽加锁需求，允许多个执行读操作的线程同时访问数据结构，那么将提升程序的性能。只要每个线程都能确保读到最新的数据，并且在读取数据时不会有其他的线程修改数据，那么就不会发生问题。在这种情况下，就可以使用&lt;strong&gt;读写锁&lt;/strong&gt;：&lt;span&gt;一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Java中读写锁的实现是&lt;code&gt;ReadWriteLock&lt;/code&gt;。下面我们先介绍什么是读写锁，然后利用读写锁快速实现一个缓存，最后我们再来介绍读写锁的升级与降级。&lt;/p&gt;
&lt;h2 id=&quot;什么是读写锁&quot;&gt;什么是读写锁&lt;/h2&gt;
&lt;p&gt;读写锁是一种性能优化措施，在读多写少场景下，能实现更高的并发性。读写锁的实现需要遵循以下三项基本原则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;允许多个线程同时读共享变量；&lt;/li&gt;
&lt;li&gt;只允许一个线程写共享变量；&lt;/li&gt;
&lt;li&gt;如果一个线程正在执行写操作，此时禁止读线程读共享便利。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;读写锁与互斥锁的一个重要区别就是：&lt;strong&gt;读写锁允许多个线程同时读共享变量&lt;/strong&gt;，而互斥锁是不允许的。读写锁的写操作时互斥的。&lt;/p&gt;
&lt;p&gt;下面是&lt;code&gt;ReadWriteLock&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ReadWriteLock{
    Lock readLock();
    Lock writeLock();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，暴露了两个Lock对象，一个用于读操作，一个用于写操作。要读取由ReadWriteLock保护的数据，必须首先获得&lt;strong&gt;读取锁&lt;/strong&gt;，当需要修改由ReadWriteLock保护的数据时，必须首先获得&lt;strong&gt;写入锁&lt;/strong&gt;。尽管这两个锁看上去是彼此独立的，但读取锁和写入锁只是读写锁对象的不同视图。&lt;/p&gt;
&lt;p&gt;与Lock一样，ReadWriteLock可以采用多种不同的实现方式，这些方式在性能、调度保证、获取优先性、公平性以及加锁语义等方面可能有些不同。读取锁与写入锁之间的交互方式也可以采用多种方式实现。&lt;/p&gt;
&lt;p&gt;ReadWriteLock中有一些可选实现包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;释放优先&lt;/strong&gt;：当一个写入操作释放写入锁时，并且队列中同时存在读线程和写线程，那么应该优先选择读线程，写线程，还是最先发出请求的线程？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读线程插队&lt;/strong&gt;：如果锁是由读线程持有，但有写线程正在等待，那么新到达的读线程能否立即获得访问权，还是应该在写线程后面等待？如果允许读线程插队到写线程之前，那么将提高并发性，但却可能造成写线程发生饥饿问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重入性&lt;/strong&gt;：读取锁和写入锁是否是可重入的？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;降级&lt;/strong&gt;：如果一个线程持有写入锁，那么它能否在不释放该锁的情况下获得读取锁？这可能会使得写入锁被“降级”为读取锁，同时不允许其他写线程修改被保护的资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;升级&lt;/strong&gt;：读取锁能否优先于其他正在等待的读线程和写线程而升级为一个写入锁？在大多数的读-写锁实现中并不支持升级，因为如果没有显式的升级操作，那么很容易造成死锁。（如果两个读线程试图同时升级为读写锁，那么二者都不会释放读取锁。）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;reentrantreadwritelock&quot;&gt;ReentrantReadWriteLock&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;是ReadWriteLock的一个实现，它为读取锁和写入锁都提供了可重入的加锁语义。与ReentrantLock相似，ReentrantReadWriteLock在构造时也可以选择是一个非公平的锁（默认）还是一个公平的锁。&lt;/p&gt;
&lt;p&gt;在公平的锁中，等待时间最长的线程将优先获得锁。如果这个线程是由读线程持有，而另一个线程请求写入锁，那么其他读线程都不能获得读取锁，直到写线程使用完并且释放了写入锁。&lt;/p&gt;
&lt;p&gt;在非公平的锁中，线程获得访问许可的顺序是不确定的。写线程降级为读线程是可以的，但从读线程升级为写线程则是不可以的（容易导致死锁）。&lt;/p&gt;
&lt;h2 id=&quot;实现一个快速缓存&quot;&gt;实现一个快速缓存&lt;/h2&gt;
&lt;p&gt;下面使用ReentrantReadWriteLock来实现一个通用的缓存工具类。&lt;/p&gt;
&lt;p&gt;实现一个&lt;code&gt;Cache&amp;lt;K,V&amp;gt;&lt;/code&gt;类，类型参数K代表缓存中key类型，V代表缓存里的value类型。我们将缓存数据存储在Cache类中的HashMap中，但是&lt;strong&gt;HashMap不是线程安全的，所以我们使用读写锁来保证其线程安全&lt;/strong&gt;。&lt;br/&gt;Cache工具类提供了两个方法，读缓存方法&lt;code&gt;get()&lt;/code&gt;和写缓存方法&lt;code&gt;put()&lt;/code&gt;。读缓存需要用到读取锁，读取锁的使用方法同Lock使用方式一致，都需要使用&lt;code&gt;try{}finally{}&lt;/code&gt;编程范式。写缓存需要用到写入锁，写入锁和读取锁使用类似。&lt;/p&gt;
&lt;p&gt;代码参考如下：（代码来自参考[1]）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Cache&amp;lt;K,V&amp;gt; {
    final Map&amp;lt;K, V&amp;gt; m = new HashMap&amp;lt;&amp;gt;();
    final ReadWriteLock rwl = new ReentrantReadWriteLock();
    final Lock r = rwl.readLock(); // 读取锁
    final Lock w = rwl.writeLock(); // 写入锁
    
    // 读缓存
    V get(K key) {
        r.lock(); // 获取读取锁
        try { 
            return m.get(key); 
        }finally { 
            r.unlock();  // 释放读取锁
        }
    }
    
    // 写缓存
    V put(K key, V value) {
        w.lock(); // 获取写入锁
        try { 
            return m.put(key, v); 
        }finally { 
            w.unlock(); // 释放写入锁 
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;缓存数据的初始化&quot;&gt;缓存数据的初始化&lt;/h3&gt;
&lt;p&gt;使用缓存首先要解决&lt;strong&gt;缓存数据的初始化&lt;/strong&gt;问题。缓存数据初始化，可以采用&lt;strong&gt;一次性加载&lt;/strong&gt;的方式，也可以使用&lt;strong&gt;按需加载&lt;/strong&gt;的方式。&lt;/p&gt;
&lt;p&gt;如果源头数据的数据量不大，就可以采用一次性加载的方式，这种方式也最简单。只需要在应用启动的时候把源头数据查询出来，依次调用类似上面代码的&lt;code&gt;put()&lt;/code&gt;方式就可以了。可参考下图（图来自参考[1]）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/202002/1099419-20200217202913894-823705132.png&quot; alt=&quot;image-20200217192615172&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果源头数据量非常大，那么就需要按需加载，按需加载也叫做&lt;strong&gt;懒加载&lt;/strong&gt;。指的是只有当应用查询缓存，并且数据不在缓存里的时候，才触发加载源头相关数据进行缓存的操作。可参考下图（图来自参考[1]）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1099419/202002/1099419-20200217202938184-97687838.png&quot; alt=&quot;image-20200217192844702&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实现缓存的按需加载&quot;&gt;实现缓存的按需加载&lt;/h3&gt;
&lt;p&gt;下面代码实现了按需加载的功能（代码来自参考[1]）。&lt;br/&gt;这里假设缓存的源头时数据库。如果缓存中没有缓存目标对象，那么就需要从数据库中加载，然后写入缓存，写缓存是需要获取写入锁。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Cache&amp;lt;K,V&amp;gt; {
    final Map&amp;lt;K, V&amp;gt; m = new HashMap&amp;lt;&amp;gt;();
    final ReadWriteLock rwl = new ReentrantReadWriteLock();
    final Lock r = rwl.readLock(); // 读取锁
    final Lock w = rwl.writeLock(); // 写入锁

    V get(K key) {
        V v = null;
        //读缓存
        r.lock();    // 获取读取锁     
        try {
             v = m.get(key);
         } finally{
             r.unlock();     // 释放读取锁
         }
        //缓存中存在目标对象，返回
        if(v != null) {   
            return v;
        }  
        //缓存中不存在目标对象，查询数据库并写入缓存
        w.lock();         // 获取写入锁 ①
        try {
            //再次验证 其他线程可能已经查询过数据库
            v = m.get(key); 
            if(v == null){  
            //查询数据库
                v=省略代码无数
                m.put(key, v);
            }
         } finally{
             w.unlock(); //释放写入锁
         }
        return v; 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当缓存中不存在目标对象时，需要查询数据库，在上述代码中，我们在执行真正的查库之前，又查看了缓存中是否已经存在目标对象，这样做的好处是可以&lt;strong&gt;避免重复查询&lt;/strong&gt;提升效率。我们举例说明这样做的益处。&lt;/p&gt;
&lt;p&gt;在高并发的场景下，有可能会有多线程竞争写锁。假设缓存是空的，没有缓存任何东西，如果此时有三个线程 T1、T2 和 T3 同时调用&lt;code&gt;get()&lt;/code&gt;方法，并且参数 &lt;code&gt;key&lt;/code&gt;也是相同的。那么它们会同时执行到代码①处，但此时只有一个线程能够获得写锁。&lt;br/&gt;假设是线程 T1，线程 T1 获取写锁之后查询数据库并更新缓存，最终释放写锁。&lt;br/&gt;此时线程 T2 和 T3 会再有一个线程能够获取写锁，假设是 T2，如果不采用再次验证的方式，此时 T2 会再次查询数据库。T2 释放写锁之后，T3 也会再次查询一次数据库。&lt;br/&gt;而实际上线程 T1 已经把缓存的值设置好了，T2、T3 完全没有必要再次查询数据库。&lt;/p&gt;
&lt;h2 id=&quot;读写锁的升级与降级&quot;&gt;读写锁的升级与降级&lt;/h2&gt;
&lt;p&gt;上面读取锁的获取释放与写入锁的读取和释放是没有嵌套的。如果我们改一改代码，将再次验证并更新缓存的逻辑换个位置放置：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//读缓存
r.lock(); // 获取读取锁      
try {
    v = m.get(key); 
    if (v == null) {
        w.lock(); // 获取写入锁
        try {
            //再次验证并更新缓存
            //省略详细代码
         } finally{
            w.unlock(); // 释放写入锁
         }
    }
} finally{
  r.unlock(); // 释放读取锁
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码，在获取读取锁后，又试图获取写入锁，即我们前面介绍的&lt;strong&gt;锁的升级&lt;/strong&gt;。但是，ReadWriteLock是不支持这种升级，在代码中，读取锁还没有释放，又尝试获取写入锁，将导致相关线程被阻塞（读取锁和写入锁只是读写锁对象的不同视图），永远没有机会被唤醒。&lt;/p&gt;
&lt;p&gt;虽然锁的升级不被允许，但是锁的降级却是被允许的。（下例代码来自参考[1]）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class CachedData {
    Object data;
    volatile boolean cacheValid;
    final ReadWriteLock rwl = new ReentrantReadWriteLock();
    final Lock r = rwl.readLock(); // 读取锁
    final Lock w = rwl.writeLock(); //写入锁
  
    void processCachedData() {
        // 获取读取锁
        r.lock();
        if (!cacheValid) {
            r.unlock(); // 释放读取锁，因为不允许读取锁的升级
            w.lock(); // 获取写入锁
            try {
                // 再次检查状态  
                if (!cacheValid) {
                    data = ...
                    cacheValid = true;
                }
                // 释放写入锁前，降级为读取锁 降级是可以的
                r.lock();
            } finally {
                w.unlock(); // 释放写入锁
            }
        }
        // 此处仍然持有读取锁，要记得释放读取锁
        try {
            use(data);
        } finally {
            r.unlock();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;读写锁的读取锁和写入锁都实现了&lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt;接口，所以除了支持&lt;code&gt;lock()&lt;/code&gt;方法外，&lt;code&gt;tryLock()&lt;/code&gt;，&lt;code&gt;lockInterruptibly()&lt;/code&gt;等方法也都是支持的。但是需要注意，&lt;strong&gt;只有写入锁支持条件变量&lt;/strong&gt;，读取是不支持条件变量的，读取锁调用&lt;code&gt;newCondition()&lt;/code&gt;会泡池&lt;code&gt;UnsupporteOperationException&lt;/code&gt;异常。&lt;/p&gt;
&lt;p&gt;我们实现的简单缓存是没有解决缓存数据与源头数据同步的，即保持与源头数据的一致性。解决这个问题的一个简单方案是&lt;strong&gt;超时机制&lt;/strong&gt;：当缓存的数据超过时效后，这条数据在缓存中就失效了；访问缓存中失效的数据，会触发缓存重新从源头把数据加载进缓存。也可以在源头数据发生变化时，快速反馈给缓存。&lt;/p&gt;
&lt;p&gt;虽说读写锁在读多写少场景下性能优于互斥锁（独占锁），但是在其他情况下，性能可能要略差于互斥锁，因为读写锁的复杂性更高。所以，我们要根据场景来具体考虑使用哪一种同步方案。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;[1]极客时间专栏王宝令《Java并发编程实战》&lt;br/&gt;[2]Brian Goetz.Tim Peierls. et al.Java并发编程实战[M].北京:机械工业出版社,2016&lt;/p&gt;
</description>
<pubDate>Mon, 17 Feb 2020 12:32:00 +0000</pubDate>
<dc:creator>sakuraxx</dc:creator>
<og:description>前言 前面介绍过 ，它实现的是一种标准的互斥锁：每次最多只有一个线程能持有ReentrantLock。这是一种强硬的加锁规则，在某些场景下会限制并发性导致不必要的抑制性能。互斥是一种保守的加锁策略，虽</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myworld7/p/12323467.html</dc:identifier>
</item>
</channel>
</rss>