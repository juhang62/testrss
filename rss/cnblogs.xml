<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python专题——五分钟带你了解map、reduce和filter - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12508455.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12508455.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;，原创不易，求个关注&lt;/p&gt;

&lt;section id=&quot;nice&quot; data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; readability=&quot;11&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天是&lt;strong&gt;Python专题第6篇&lt;/strong&gt;文章，给大家介绍的是Python当中三个非常神奇的方法：map、reduce和filter。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道大家看到map和reduce的时候有没有什么感觉，如果看过之前我们大数据系列介绍MapReduce文章的同学，想必有些印象。这个MapReduce不是一个分布式的计算方法么，怎么又变成Python中的方法了？其实原因很简单，因为Python是一门很年轻的语言，它在发展的过程当中&lt;strong&gt;吸收了很多其他领域的精华&lt;/strong&gt;，MapReduce就是其中之一。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对之前文章感兴趣的同学可以点击下方的链接，回顾一下之前MapReduce的内容。&lt;/p&gt;
&lt;/section&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMTM5OTM2NA==&amp;amp;mid=2247483739&amp;amp;idx=1&amp;amp;sn=2111080662444c8e4f7bf10448e6d734&amp;amp;chksm=f9dafc70cead7566d54126ed9d78069f313132e3c094946303f6c820e39a49c3bb794dce3921&amp;amp;scene=21#wechat_redirect&quot;&gt;大数据基石——Hadoop与MapReduce&lt;/a&gt;&lt;/p&gt;
&lt;section readability=&quot;36&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;map&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;map除了地图之外，另一个英文本意是映射。在C++和Java一些语言当中，将map进一步引申成了存储key和value映射结构的容器。Python对这点做了区分，KV结构的容器命名成了dict，即字典，而map则回到了它的本意，也就是&lt;strong&gt;映射&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，在数学领域，映射也是函数的定义。一个自变量通过某种映射，对应到一个因变量。同样，在Python当中，map操作本质也是函数，不过它作用的范围不再是单个变量，而是一个序列。换句话说，通过map我们可以省去循环操作，可以自动将一个容器当中的元素套用一个函数。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/17/170e5e0e296db291?w=764&amp;amp;h=421&amp;amp;f=png&amp;amp;s=43801&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个简单的例子，比如我们有一个坐标，我们希望知道它距离原点的距离。这个问题很简单，我们写一个计算距离的函数就可以解决：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;dis&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(point)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; math.sqrt(point[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]**&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + point[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]**&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如果我有多个点需要计算距离，在map出现之前，我们只能用循环来解决问题：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;points = [[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]]&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; point &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; points:&lt;br/&gt;print(dis(point))&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是有了map之后， 我们可以省去循环的操作，整个代码简化成了一行：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;map(dis, points)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是要注意，我们调用完map之后得到的结果不是一个list而是一个迭代器。我们直接将map返回的内容print出来，可以得到这样一个结果：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;print(map(dis, points))&lt;br/&gt;&amp;lt;map object at &lt;span class=&quot;hljs-number&quot;&gt;0x107aad1d0&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个类的标准输出，其实它返回的不是最后的结果，而是一个迭代器。我们在之前的文章当中已经介绍过了迭代器和生成器的相关概念，这里不多做赘述了，遗忘的同学可以点击下方链接回顾一下之前的内容：&lt;/p&gt;
&lt;/section&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMTM5OTM2NA==&amp;amp;mid=2247484777&amp;amp;idx=1&amp;amp;sn=236b215aff90bf4cccb56b8385eece18&amp;amp;chksm=f9daf842cead7154ad10951904789ff549611e86df4fefae71653c7c96be627bee447dfc7f89&amp;amp;scene=21#wechat_redirect&quot;&gt;Python——五分钟带你弄懂迭代器与生成器&lt;/a&gt;&lt;/p&gt;
&lt;section readability=&quot;161&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们想要获得完整的内容也很容易，我们只需要将它&lt;strong&gt;转化成list类型&lt;/strong&gt;即可：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;print(list(map(dis, points)))&lt;br/&gt;[&lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4.47213595499958&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3.605551275463989&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上过程还可以进一步简化，还记得我们之前介绍过的&lt;strong&gt;匿名函数&lt;/strong&gt;吗？由于dis函数在我们的程序当中只会在map中用到，我们完全没有必要单独创建一个函数，我们可以直接传入一个匿名函数搞定运算：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;map(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; x: math.sqrt(x[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]**&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; + x[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] ** &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;), points)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单总结一下，map操作其实&lt;strong&gt;执行的是一个映射&lt;/strong&gt;。它可以自动地将一个序列当中的内容通过制定的函数映射成另一个序列，从而避免显式地使用循环来调用，在很多场景下可以大大地简化代码的编写，可以很方便地将一个序列整体转变成另一个结果。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;reduce&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比于map，reduce的操作稍稍难理解一点点。它也是规定一个映射，不过不是将一个元素映射成一个结果。而是将&lt;strong&gt;两个元素归并成一个结果&lt;/strong&gt;。并且它并不是调用一次，而是依次调用，直到最后只剩下一个结果为止。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说我们有一个数组[a, b, c, d]和一个函数f，我们计算reduce(f, [a, b, c, d])其实就等价于f(f(f(a, b), c), d)。和map不同的是，reduce最后得到一个结果，而不是一个迭代器或者是list。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们光说有些抽象，不妨来看一个例子，就看最简单的一个例子：reduce函数接收两个数，返回两个数的和。那么显然，我们依次调用reduce，得到的就是原数组的和。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; reduce&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(a, b)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; a + b&lt;/p&gt;&lt;p&gt;print(reduce(f, [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]))&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终得到的结果当然是10，同样，我们也可以将reduce中的方法定义成匿名函数，一样不影响最终的结果。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;print(reduce(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; x, y: x + y, [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]))&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MapReduce&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然我们map和reduce都有了，显然我们可以将它们&lt;strong&gt;串联起来使用&lt;/strong&gt;，也就是分布式系统当中MapReduce的做法。虽然如果不手动使用线程池的话，Python并不会起多个线程来加速运算，但是至少可以简化我们实现的代码。我们还是举经典的wordCount的例子，也就是&lt;strong&gt;文本计算词频&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;套用map和reduce的功能，整个流程非常清晰，我们只需要在map阶段对文本进行分词，在reduce阶段对分词之后的结果进行汇总即可。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听着好像非常容易，但是你实际去上手是写不出来的。原因也很简单，因为hadoop当中的Map和Reduce中间还有一层shuffle的操作，&lt;strong&gt;会自动地将key值相同的结果放到同一个reducer当中&lt;/strong&gt;。在这个问题当中，key自然就是我们的word，由于相同的word被放到同一个reducer当中，我们只需要累加就行了。但是如果我们自己编写mapreduce的话，由于缺少了中间数据重排的步骤，所以导致不能实现。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要解决也简单，我们可以人为增加一个map阶段代替hadoop当中的重排。相当于做了一个MapMapReduce，我们来看代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;11.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;17&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Counter, defaultdict&lt;p&gt;texts = [&lt;span class=&quot;hljs-string&quot;&gt;'apple bear peach grape'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'grape orange pear'&lt;/span&gt;]&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mp1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(text)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;ret = []&lt;br/&gt;words = text.split(&lt;span class=&quot;hljs-string&quot;&gt;' '&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; word &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; words:&lt;br/&gt;ret.append((word, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ret&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mp2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(arr)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;d = defaultdict(int)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k, v &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arr:&lt;br/&gt;d[k] += v&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; d&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;rd&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(x, y)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;x.update(y)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x&lt;/p&gt;&lt;p&gt;print(reduce(rd, map(mp2, map(mp1, texts))))&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如果我们不用多次MapReduce呢？也不是没有办法，需要取点巧，方法也简单只要使用之前我们讲解过的Counter类，就可以完美解决这个问题。我们来看代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; Counter&lt;p&gt;texts = [&lt;span class=&quot;hljs-string&quot;&gt;'apple bear peach grape'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'grape orange pear'&lt;/span&gt;]&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;mp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(text)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;words = text.split(&lt;span class=&quot;hljs-string&quot;&gt;' '&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Counter(words)&lt;/p&gt;&lt;p&gt;print(reduce(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; x, y: x + y, map(mp, texts)))&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们使用了Counter，所以我们在map阶段返回的结果就已经是词频的dict了，而在reduce阶段我们只需要将它们全部累加起来就OK了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们来看下&lt;strong&gt;filter&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;filter&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;filter的英文是过滤，所以它的使用就很明显了。它的用法和map有些类似，我们编写一个函数来判断元素是否合法。通过调用filter，会自动将这个函数应用到容器当中所有的元素上，最后只会&lt;strong&gt;保留运行结果是True的元素，而过滤掉那些是False的元素&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，假设我们想要保留list当中的奇数而过滤掉偶数，我们当然可以直接操作，比如：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;2&quot;&gt;arr = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;]&lt;p&gt;[i &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; arr &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i % &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; ]&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而使用filter会非常方便：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;list(filter(&lt;span class=&quot;hljs-keyword&quot;&gt;lambda&lt;/span&gt; x: x % &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, arr))&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个例子当中可能看不出便捷，但是有的时候判断的条件可能非常复杂，我们判断的逻辑不能简单地在list定义当中表达出来，这个时候使用filter则会容易得多。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后， 我们再看一个类似的用法。在itertools当中有一个方法叫做 &lt;strong&gt;compress&lt;/strong&gt;，通过compress我们可以实现根据一个序列的条件过滤另一个序列。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个简单的例子，假设，我们有两个数组：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;student = [&lt;span class=&quot;hljs-string&quot;&gt;'xiaoming'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'xiaohong'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'xiaoli'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'emily'&lt;/span&gt;]&lt;br/&gt;scores = [&lt;span class=&quot;hljs-number&quot;&gt;60&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;70&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们想要获取所有考试及格的同学的list，如果用常规做法基本上免不了使用循环，但是使用compress可以很方便地通过一行代码实现：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;9&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; itemtools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; compress&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;pass&lt;/span&gt; = [i &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; scores]&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;print(&lt;span class=&quot;hljs-keyword&quot;&gt;pass&lt;/span&gt;)&lt;br/&gt;[&lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;False&lt;/span&gt;]&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;list(compress(student, &lt;span class=&quot;hljs-keyword&quot;&gt;pass&lt;/span&gt;))&lt;br/&gt;[&lt;span class=&quot;hljs-string&quot;&gt;'xiaohong'&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'xiaoli'&lt;/span&gt;]&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是filter和compress返回的都是一个迭代器，我们要获取它们的值，需要&lt;strong&gt;手动转换成list&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在日常的开发当中不使用这三样神器同样可以工作，但是用上它们之后，会提升很多代码的可读性，节省很多无用的代码。尤其是在面试的时候，很有可能就会给面试官留下不一样的印象，也许结果也会不同。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章就是这些，如果觉得有所收获，请顺手点个&lt;strong&gt;关注或者转发&lt;/strong&gt;吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
&lt;/section&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/17/170e5e2cecdeb557?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Mar 2020 00:29:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是Python专题第6篇文章，给大家介绍的是Python当中三个非常神奇的方法：map、reduce和filter。 不知道大家看到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12508455.html</dc:identifier>
</item>
<item>
<title>Java Grammar（三）：修饰符 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/12508451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/12508451.html</guid>
<description>&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;修饰符是用于限定类型以及类型成员申明的一种符号，从修饰对象上可以分为类修饰符，方法修饰符，变量修饰符；从功能上可以划分为访问控制修饰符和非访问修饰符。访问修饰符控制访问权限，不同的访问修饰符有不同的权限范围，而非访问修饰符则是提供一些特有功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-12-130958.png&quot; alt=&quot;image-20190812210957757&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们从功能的角度分别讲解修饰符&lt;/p&gt;
&lt;h3 id=&quot;访问修饰符&quot;&gt;访问修饰符&lt;/h3&gt;
&lt;p&gt;访问修饰符有四种：&lt;code&gt;public&lt;/code&gt;,&lt;code&gt;private&lt;/code&gt;,&lt;code&gt;protected&lt;/code&gt;,&lt;code&gt;default&lt;/code&gt;。这里需要注意，我们这里的&lt;code&gt;default&lt;/code&gt;和非访问修饰符中的&lt;code&gt;default&lt;/code&gt;可不是一个东西！&lt;/p&gt;
&lt;p&gt;这里的&lt;code&gt;default&lt;/code&gt;指的是默认，&lt;strong&gt;什么也不写&lt;/strong&gt;，在同一包内可见，不使用任何修饰符。使用对象：&lt;strong&gt;类、接口、变量、方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;private&lt;/code&gt;指的是在仅仅在类内可见，所以也就很好理解，&lt;code&gt;private&lt;/code&gt;只能修饰&lt;strong&gt;方法，变量&lt;/strong&gt;，而不能修饰类和接口（毕竟你只能类内访问，你修饰类谁能看得到呢？），修饰方法的时候，一般用于我们在重构代码的时候提取公用代码为&lt;strong&gt;内部实现方法&lt;/strong&gt;，修饰变量的情景相比我们就经常见到了，由于Java的&lt;strong&gt;封装&lt;/strong&gt;特性，我们在定义一个类的时候，经常会把该类的属性定义为&lt;code&gt;private&lt;/code&gt;，通过&lt;code&gt;get&lt;/code&gt;or&lt;code&gt;set&lt;/code&gt;方法来访问这些变量。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;public&lt;/code&gt;在我们日常中使用的比较多，我们经常会把类声明为&lt;code&gt;public&lt;/code&gt;，声明成&lt;code&gt;public&lt;/code&gt;的&lt;strong&gt;类，接口，变量，方法&lt;/strong&gt;可以被任何类访问，这里需要注意一个java文件中只能包含一个&lt;code&gt;public&lt;/code&gt;的类，而且&lt;code&gt;main&lt;/code&gt;方法必须用&lt;code&gt;public&lt;/code&gt;修饰，否则无法被Java的解释器识别。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt;我们在日常的开发中使用不多，只能声明在&lt;strong&gt;变量，方法，内部类&lt;/strong&gt;上，它主要的作用就是用来&lt;strong&gt;保护子类&lt;/strong&gt;的。它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种&lt;strong&gt;继承&lt;/strong&gt;的东西。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基类的 &lt;code&gt;protected&lt;/code&gt; 成员是包内可见的，并且&lt;strong&gt;对子类可见&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;若子类与基类不在同一包中，那么在子类中，子类实例&lt;strong&gt;可以访问&lt;/strong&gt;其从&lt;strong&gt;基类继承而来&lt;/strong&gt;的&lt;code&gt;protected&lt;/code&gt;方法，而&lt;strong&gt;不能访问基类实例&lt;/strong&gt;的&lt;code&gt;protected&lt;/code&gt;方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-12-141038.png&quot; alt=&quot;image-20190812221038073&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⬆ 大概就是上图酱紫，凑合着看，画图功力贼差：）&lt;/p&gt;
&lt;h3 id=&quot;非访问修饰符&quot;&gt;非访问修饰符&lt;/h3&gt;
&lt;h4 id=&quot;default&quot;&gt;default&lt;/h4&gt;
&lt;p&gt;这里的&lt;code&gt;default&lt;/code&gt;是jdk 8中的新特性，指的是接口方法的默认实现，在JDK 8 之前接口的方法是不能有实现的，而JDK 8 后&lt;code&gt;default&lt;/code&gt;修饰的方法可以在接口中进行默认的实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Test {
  default void hello(){
    System.out.println(&quot;Hello&quot;);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就像酱紫~&lt;/p&gt;
&lt;h4 id=&quot;static&quot;&gt;static&lt;/h4&gt;
&lt;p&gt;static是面试的一个&lt;strong&gt;热点&lt;/strong&gt;，static的意思是静态，可用于修饰变量和方法，切记一点，static是属于&lt;strong&gt;类&lt;/strong&gt;的，而非是属于对象的，static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过&lt;strong&gt;类名&lt;/strong&gt;去进行访问。&lt;br/&gt;而static关键字的基本作用就是：方便在没有创建对象的情况下来进行调用（方法/变量）。&lt;br/&gt;这里需要注意，由于static修饰的方法和变量是属于类的，不需要依靠对象才能使用，所以他不能访问非static修饰的方法和变量，因为这些变量和方法是必须依托于对象才能访问！但是&lt;strong&gt;非static的方法可以访问static的方法或变量&lt;/strong&gt;，因为当你创建对象的时候，类必定已经加载，所以可以访问的到。&lt;/p&gt;
&lt;p&gt;这里需要注意一点：static不可修饰局部变量&lt;/p&gt;
&lt;h4 id=&quot;final&quot;&gt;final&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;final&lt;/code&gt;关键字我们在日常中也会经常用到，通常用的最多的场景就是搭配&lt;code&gt;static&lt;/code&gt;一起来使用去定义我们系统的常量：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static final String AUTHOR = &quot;viyoung&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了修饰变量，还可以用于修饰类和方法，被final修饰的类无法被继承，&lt;strong&gt;被final修饰的方法可以被继承，但是无法进行修改&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;abstract&quot;&gt;abstract&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;abstract&lt;/code&gt;可以作用在类和方法上，当作用在类上时，说明这个类是一个抽象类，需要去继承扩展，无法直接实例化一个对象，当作用在方法上的时候，说明这个方法需要扩展，被&lt;code&gt;abstract&lt;/code&gt;修饰的方法以分号结尾，没有实现，而且无法被&lt;code&gt;final&lt;/code&gt;和&lt;code&gt;static&lt;/code&gt;修饰（一个需要被继承且没有实现的方法为毛要用这俩修饰，不是自己打自己脸吗😂）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract void test();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抽象类和抽象方法有以下关系：&lt;strong&gt;包括抽象方法的一定是抽象类，不包括抽象方法的却不一定是非抽象类。&lt;/strong&gt;🤔&lt;/p&gt;
&lt;h4 id=&quot;synchronized&quot;&gt;synchronized&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;对于了解过并发编程的同学来说比较熟悉，它可以作用于普通方法，static方法和代码块上，用于加锁，放置多个线程同时访问一个方法/类。这里只是简单的介绍，会在后面的并发编程中详细讲解。&lt;/p&gt;
&lt;h4 id=&quot;volatile&quot;&gt;volatile&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 修饰的成员变量具有&lt;strong&gt;可见性&lt;/strong&gt;，&lt;strong&gt;可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。&lt;/strong&gt;也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许&lt;strong&gt;线程内部缓存和重排序&lt;/strong&gt;，即直接修改内存。&lt;/p&gt;
&lt;p&gt;这里也只是简单的介绍，会在后面的并发编程中详细讲解。&lt;/p&gt;
&lt;h4 id=&quot;transient&quot;&gt;transient&lt;/h4&gt;
&lt;p&gt;用&lt;strong&gt;transient&lt;/strong&gt;关键字标记的成员变量不参与序列化过程，Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private transient String name = &quot;viyoung&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;公众号&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-15-qrcode_for_gh_a65beceb0947_258.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Mar 2020 00:27:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>简介 修饰符是用于限定类型以及类型成员申明的一种符号，从修饰对象上可以分为类修饰符，方法修饰符，变量修饰符；从功能上可以划分为访问控制修饰符和非访问修饰符。访问修饰符控制访问权限，不同的访问修饰符有不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/12508451.html</dc:identifier>
</item>
<item>
<title>为啥计算机网络需要分层？难道是多此一举 - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/12508429.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/12508429.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;多点头发，少点代码&lt;/p&gt;
&lt;p&gt;我是龙叔，一个分享互联网技术和心路历程的大叔&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文已经收录至我的GitHub,欢迎大家踊跃star 和 issues。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/midou-tech/articles&quot;&gt;https://github.com/midou-tech/articles&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近很忙，写技术文章还是很花费时间的。但是，就在前几天出了一篇TCP粘包问题的文章 (&lt;a href=&quot;https://mp.weixin.qq.com/s/5oDim8z_xJhMKhHR9w-V3A&quot;&gt;TCP粘包，难道说这是一个伪命题？？？&lt;/a&gt;)，反映不错。本来计划计算机网络文章慢慢的出，现在看来必须的加快速度了。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTly1gcuvxf0ka2j30ee0u0n2b.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;龙叔在学习网络的时候有这样几个疑惑:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;为什么需要抽象出五层模型出来？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;难道不是直接在网线(光纤传输)中传输数据就好了么？大不了到了&lt;strong&gt;端点&lt;/strong&gt;用的是WIFI传输(无线信号)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两个问题真的很困惑我，不知道大家有没有这样的疑惑？如果有的话，龙叔将为你答疑解惑。如果有其他的疑惑欢迎加我微信沟通 (公众号回复【龙叔】即可获得龙叔的联系方式)。&lt;/p&gt;
&lt;p&gt;在回答问题之前我先带你领略下使用最为广泛的五层模型，分别是哪五层？各层解决了什么问题？&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;五层模型是哪五层？&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTly1gch6vnkhldj30zu0mm0z6.jpg&quot; alt=&quot;网络模型&quot; title=&quot;网络模型&quot;/&gt;网络模型
&lt;p&gt;左边是OSI的七层模型，这模型很牛逼。但是现在基本是存在教科书的啦，学习网络的同学都是知道有这个模型，实际情况使用很少的。&lt;/p&gt;
&lt;p&gt;右边是TCP/IP五层分层模型。分别是物理层(硬件)、数据链路层(网卡层)、网络层(互联网层)、传输层、应用层。在日常工作中接触最多的是上两层，偶尔会去触碰网络层。数据链路层和物理层不是我们工作范围。当然如果是一些专门的网络安全部门，网管(不是网吧的网管)等岗位，下面几层就是非常熟悉的。&lt;/p&gt;
&lt;p&gt;五层模型还是很清楚明了的，每层用到的重要协议都表示在图中，还表示了操作系统的内核工作范围和用户工作范围。&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;各层解决了什么问题？&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h-2&quot;&gt;&lt;span&gt;应用层：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;应用层是网络体系架构中的最高层。这意味着什么？想想就知道，最高层就是要和人交互的层次嘛。&lt;/p&gt;
&lt;p&gt;应用层是计算机网络与用户交互的&lt;strong&gt;接口&lt;/strong&gt;或者&lt;strong&gt;界面&lt;/strong&gt;，&lt;strong&gt;直接&lt;/strong&gt;向用户提供服务。&lt;/p&gt;
&lt;p&gt;提供哪些服务呢？&lt;/p&gt;
&lt;p&gt;这个…，就非常多了，比如Web服务、E-mail服务、DNS服务、DHCP服务、FTP服务等等。&lt;/p&gt;
&lt;p&gt;所以很明了，应用层解决的问题就是&lt;strong&gt;如何为用户提供服务，以及提供高效、可靠、满意的服务&lt;/strong&gt;。如何解决这些问题也就是我们这些攻城狮存在的必要了，根据不同的业务场景用不同的方法解决这些问题。例如使用多线程、协程，高并发的web框架，使用epoll处理模式，分布式处理等等技术来解决提供高效、可靠、满意的服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结下&lt;/strong&gt;，应用层是为用户提供服务接口或者界面，同时要解决服务的高效、可靠、满意。&lt;/p&gt;
&lt;h4 id=&quot;h-3&quot;&gt;&lt;span&gt;传输层&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;负责&lt;strong&gt;端到端&lt;/strong&gt;的通信，是面向网络通信的低三层和面向信息处理的高三层之间的中间一层，起到&lt;strong&gt;桥梁作用&lt;/strong&gt;。很明显了，传输层解决的问题就是端到端的传输问题。&lt;/p&gt;
&lt;p&gt;看到这句话肯定很多人有疑问，先别说，继续看(我知道有人会说，网络层不是已经把数据转发到对应的主机了么，为何还要传输层？)。&lt;/p&gt;
&lt;p&gt;位于两台网络主机间的真正数据通信主体不是这两台主机，而是两台主机中的各种网络&lt;strong&gt;应用进程&lt;/strong&gt;，也就是应用程序。一台主机上有很多应用程序，很多应用程序都在进行网络通信，这时候就必须使用到传输层的知识去解决了。&lt;/p&gt;
&lt;p&gt;怎样完成端到端的传输呢？&lt;/p&gt;
&lt;p&gt;分为两个步骤：一是虚拟传输连接的建立（此处仍仅针对面向连接的传输层协议），二是源端用户数据沿着传输连接传送到目的端。&lt;/p&gt;
&lt;p&gt;在整个数据传输过程中，传输层服务需要完成以下8个方面的基本功能：传输层寻址、传输连接建立、数据传输、传输连接释放、流量控制、拥塞控制、多路复用和解复用、崩溃恢复。&lt;/p&gt;
&lt;p&gt;这里面每个功能都能细说一篇文章，这里就不一一展开了，后面会出系列的文章，所以&lt;strong&gt;点关注，不迷路。&lt;/strong&gt;每个功能都是面试的考点，所以我后面一定会&lt;strong&gt;快速&lt;/strong&gt;更新出来的。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTly1gcust8kzogg30b40b47wh.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;总结下&lt;/strong&gt;，传输层主要是为了解决端到端(这里的端到端指的是进程到进程)的通信，起到网络通信桥梁作用。&lt;/p&gt;
&lt;h3 id=&quot;h-4&quot;&gt;&lt;span&gt;网络层&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;网络层也被称为中转层，是网络体系结构中非常重要的一层，在技术上又是非常复杂的一层，因为它既要解决不同网络的节点间通信的路由和协议识别问题，又要通过路由选择策略解决网络拥塞问题，尽可能提高网络通信的可靠性。&lt;/p&gt;
&lt;p&gt;网络层解决的主要问题是，从A主机把数据运送到B主机是走高速呢、飞机呢、还是火车呢或者是多种混合的方案呢。一句话就是，网络层关注的是如何将分组从源端沿着网络路径传送到目的端(这个端指的是主机不是应用程序)。&lt;/p&gt;
&lt;p&gt;为了实现这个目标，网络层必须知道通信子网的拓扑结构，并且在拓扑结构中选择适当的路径。同时网络层还必须谨慎地选择路由路径，以避免发生某些通信线路和路由器负载过重，而其他线路和路由器空闲的情形。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结下&lt;/strong&gt;，网络层主要是为了解决不同网络之间数据传输和转发问题。&lt;/p&gt;
&lt;h3 id=&quot;h-5&quot;&gt;&lt;span&gt;数据链路层&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;物理层中也有许多规程或协议，但它们是用来构建物理传输线路、建立物理意义的网络通信，不是用来&lt;strong&gt;控制&lt;/strong&gt;数据传输的。&lt;/p&gt;
&lt;p&gt;设计数据链路层的主要解决的问题就是在原始的、有差错的物理传输线路的基础上，采取差错检测、差错控制与流量控制等方法，将有差错的物理线路改进成逻辑上无差错的数据链路，以便向它的上一层(网络层)提供高质量的服务。一句话总结就是 &lt;strong&gt;控制数据传输。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结下&lt;/strong&gt;，数据链路层是为了解决数据传输的控制作用。&lt;/p&gt;
&lt;h4 id=&quot;h-6&quot;&gt;&lt;span&gt;物理层&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;物理层位于各计算机网络体系结构的最底层，主要负责在物理介质上为数据链路层提供&lt;strong&gt;原始比特流&lt;/strong&gt;传输的&lt;strong&gt;物理链接&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;物理层解决的问题就是&lt;strong&gt;数据传输&lt;/strong&gt;。上面的所有层都是封装数据和管理，物理层是传输数据的唯一出口，所有数据到达物理层都会变成二进制的载波信号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结下&lt;/strong&gt;，物理层就是真正传输数据。&lt;/p&gt;
&lt;h3 id=&quot;h-7&quot;&gt;&lt;span&gt;为什么不是直接在物理线路中进行通信就行了？而是搞出这么多层网络模型呢？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我觉得在学习计算机网络时能思考这个问题的都是非常🐂🍺的人，比如龙叔我😆。&lt;/p&gt;
&lt;p&gt;物理层是物理线路的抽象，物理层解决的主要问题传输就是数据传输，也是网络通信中唯一的数据传输出口。其实物理层就相当于日常交通网络中的各种道路，如公路、铁路和航线，它们是我们出门旅行必须要依靠的基础设施。&lt;/p&gt;
&lt;p&gt;但是物理层不是针对具体的传输介质、设备和通信协议的，因为它们可以有许多种选择（如传输介质中就可以有同轴电缆、双绞线和光纤等），只要能实现物理层的某种功能就行了。不同的传输介质和设备选择，必须要有对应的通信协议支持，而且这也决定了不同的选择有不同的物理层性能。&lt;/p&gt;
&lt;p&gt;就像路有好多种一样，如有泥巴路、沙子路、水泥路、柏油马路、普通铁路、高速铁路等，这些不同的路可以承载的重量和速率都不一样。&lt;/p&gt;
&lt;p&gt;传输介质不同，各种传输介质传输速率不同；所有人都在进行传输，怎么管理这些人；高铁、航线不可能通到家门口；就算到了家门口怎么把这些数据完整交付给家中的某个人呢；&lt;/p&gt;
&lt;p&gt;所以就必须抽象出这些层来解决这些问题。物理层专门做数据传输(好比基础交通设施)、数据链路层制定传输规则(好比交通规则)、网络层把各个交通线路连接起来(就好比各个交通枢纽站)、传输层是端到端的符数据通信(好比把快递小哥把包裹移交到你的手里)、应用层负责提供服务(好比包裹到你手里了，你在享受包裹里面的礼物)。&lt;/p&gt;
&lt;p&gt;是不是有些明白为啥需要抽象出多层了，是的。&lt;/p&gt;
&lt;p&gt;想想都知道要是光有物理层那网络通信没法玩了，数据都是二进制，透明传输，数据还有可能乱序，丢数据，数据被篡改等等问题。&lt;/p&gt;
&lt;h3 id=&quot;h-8&quot;&gt;&lt;span&gt;计算机网络通信过程图&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/00831rSTly1gcuvnrs22ij314o0je4ap.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;本文讲清楚了文章开头的几个疑惑，至于各层中详细的功能和面试常考的点，篇幅有限，我和大家一起期待下一篇文章。关注我，精彩内容不错过，微信搜索 &lt;strong&gt;龙跃十二&lt;/strong&gt; 即可关注。&lt;/p&gt;
&lt;p&gt;觉得本篇文章对你有帮助，非常感谢你能帮我&lt;strong&gt;点个赞&lt;/strong&gt;，你的小小鼓励会成为我创作的动力。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Mar 2020 00:18:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>计算机网络是面试必备，龙叔认为学习计算机最重要的几门课包括，操作系统，计算机网络，数据结构与算法。 最近龙叔带领大家学习计算机网络。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/12508429.html</dc:identifier>
</item>
<item>
<title>从千万级数据查询来聊一聊索引结构和数据库原理 - 码大叔</title>
<link>http://www.cnblogs.com/madashu/p/12508416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/madashu/p/12508416.html</guid>
<description>&lt;p&gt;在日常工作中我们不可避免地会遇到慢SQL问题，比如笔者在之前的公司时会定期收到DBA彪哥发来的Oracle AWR报告，并特别提示我某条sql近阶段执行明显很慢，可能要优化一下等。对于这样的问题通常大家的第一反应就是看看sql是不是写的不合理啊诸如：&lt;em&gt;“避免使用in和not in，否则可能会导致全表扫描”“ 避免在where子句中对字段进行函数操作”&lt;/em&gt;等等，还有一种常见的反应就是这个表有没有加索引？绝大部分情况下，加了个索引基本上就搞定了。&lt;/p&gt;
&lt;p&gt;既然题目是《从千万级数据查询来聊一聊索引结构和数据库原理》，首先就来构造一个千万级的表直观感受下。我们创建了一张user表，然后插入了1000万条数据，查询一下：&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi01N2NhMmM2MGFjMDcyMjkzLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;用了近30秒的时间，这还是单表查询，关联查询明显会更让人无法忍受。接下来，我们只是对id增加一个索引，再来验证一把：&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi0yNzYxMzAxZGQxNGNkNTgxLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;从30s到0.02s，提升了足足1500倍。&lt;/strong&gt;为什么加了索引之后，速度嗖地一下子就上去了呢？我们从&lt;strong&gt;【索引数据结构】、【Mysql原理】&lt;/strong&gt;两个方面入手。&lt;/p&gt;

&lt;p&gt;我们先来看下 MySQL官方对索引的定义：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;索引（Index）是帮助MySQL高效获取数据的数据结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里面有2个关键词：&lt;strong&gt;高效查找、数据结构&lt;/strong&gt;。对于数据库来说，查询是我们最主要的使用功能，查询速度肯定是越快越好。最基本的查找是顺序查找，更高效的查找我们很自然会想到二叉树、红黑树、Hash表、BTree等等。&lt;/p&gt;
&lt;h2 id=&quot;二叉树&quot;&gt;1.1 二叉树&lt;/h2&gt;
&lt;p&gt;这个大家很熟悉了，他有一个很重要的特点： 左边节点的键值小于根的键值，右边节点的键值大于根的键值。比如图1，它确实能明显提高我们的搜索性能。但如果用来作为数据库的索引，明显存在很大的缺陷，但对于图2这种递增的id，存储后索引近似于变成了单边的链表，肯定是不合适的。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi02NDY5NWJkMzJmZDBiYjFhLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi0wMWM1NDczOWNiNjQ3NThmLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;红黑树&quot;&gt;1.2 红黑树&lt;/h2&gt;
&lt;p&gt;也称之为平衡二叉树。在JDK1.8后，HashMap对底层的链表也优化成了红黑树（后续文章我们可以讲讲Hashmap1.8之后的调整）。平衡二叉树的结构使树的结构较好，明显提高查找运算的速度。但是缺陷也同样很明显，插入和删除运算变得复杂化，从而降低了他们的运算速度。对大数据量的支撑很不好，当数据量很大时，树的高度太高，如果查找的数据是叶子节点，依然会超级慢。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi00ZGIzYzIzNzFlYWFjMjVkLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;btree&quot;&gt;1.3 BTree&lt;/h2&gt;
&lt;p&gt;B-Tree是为磁盘等外存储设备设计的一种平衡查找树。系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取到内存中。在Mysql存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。Mysql存储引擎中默认每个页的大小为16KB，查看方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; show variables like 'innodb_page_size';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi01OGZkNmNhNjkzMzVmYWQ3LnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;我们也可以将它修改为4K、8K、16K。系统一个磁盘块的存储空间往往没有16K，因此Mysql每次申请磁盘空间时都会将若干地址连续磁盘块来达到页的大小16KB。Mysql在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1lYjc0NmMyMzY2ODVkZWMwLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;如上图所示，一棵B树包含有键值、存储子节点的指针信息、及除主键外的数据。相对于普通的树BTree将横向节点的容量变大，从而存储更多的索引。&lt;/p&gt;
&lt;h2 id=&quot;btree-1&quot;&gt;1.4 B+Tree&lt;/h2&gt;
&lt;p&gt;在B-Tree的基础上大牛们又研究出了许多变种，其中最常见的是B+Tree，MySQL就普遍使用B+Tree实现其索引结构。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1iOWJhMWRmZGJhMDNhYTgzLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;与B-Tree相比，B+Tree做了以下一些改进：&lt;br/&gt;1、非叶子节点，只存储键值信息，这样极大增加了存放索引的数据量。&lt;br/&gt;2、 所有叶子节点之间都有一个链指针。对于区间查询时，不需要再从根节点开始，可直接定位到数据。&lt;br/&gt;3、 数据记录都存放在叶子节点中。根据二叉树的特点，这个是顺序访问指针，提升了区间访问的性能。&lt;br/&gt;通过这样的设计，一张千万级的表最多只需要3次磁盘交互就可以找出数据。&lt;/p&gt;

&lt;p&gt;这一部分我们选举几个日常面试过程中或者使用过程中比较常见的问题通过问答的形式来进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;数据库引擎myisam和innodb有什么区别&quot;&gt;2.1、数据库引擎MyISAM和InnoDB有什么区别&lt;/h3&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li&gt;&lt;strong&gt;MyISAM：&lt;/strong&gt;&lt;br/&gt;在Mysql8之前，默认引擎是MyISAM，其目标是快速读取。&lt;br/&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;br/&gt;1、读取非常快，如果频繁插入和更新的话，因为涉及到数据全表锁，效率并不高&lt;br/&gt;2、保存了数据库行数，执行count时，不需要扫描全表；&lt;br/&gt;3、不支持数据库事务；&lt;br/&gt;4、不支持行级锁和外键；&lt;br/&gt;5、不支持故障恢复。&lt;br/&gt;6、支持全文检索FullText，压缩索引。&lt;br/&gt;&lt;strong&gt;建议使用场景：&lt;/strong&gt;&lt;br/&gt;1、做很多count计算的，（如果count计算后面有where还是会全表扫描）&lt;br/&gt;2、插入和更新较少，查询比较频繁的&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;InnoDB：&lt;/strong&gt;&lt;br/&gt;在Mysql8里，默认存储引擎改成了InnoDB。&lt;br/&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;br/&gt;1、支持事务处理、ACID事务特性&lt;br/&gt;2、实现了SQL标准的四种隔离级别&lt;br/&gt;3、支持行级锁和外键约束&lt;br/&gt;4、可以利用事务日志进行数据恢复&lt;br/&gt;5、不支持FullText类型的索引，没有保存数据库行数，计算count(*)需要全局扫描&lt;br/&gt;6、支持自动增加列属性auto_increment&lt;br/&gt;7、最后也是非常重要的一点：InnerDB是为了处理大量数据时的最大性能设计，其CPU效率可能是其他基于磁盘的关系型数据库所不能匹敌的。&lt;br/&gt;&lt;strong&gt;建议使用场景&lt;/strong&gt;&lt;br/&gt;1、可靠性高或者必须要求事务处理&lt;br/&gt;2、表更新和查询相当的频繁，并且表锁定的机会比较大的情况下，指定InnerDB存储引擎。&lt;/p&gt;
&lt;h3 id=&quot;表和数据等在mysql中是如何存储的&quot;&gt;2.2 表和数据等在Mysql中是如何存储的&lt;/h3&gt;
&lt;p&gt;我们新建一个数据库mds_demo，里面有两张表：order_info,user&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi00YzA4OTA5MDRiMzlkMTNkLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;我们找到mysql存放数据的data目录，存在一个mds_demo的文件夹，同时我们也找到了order_info和user的文件。&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1jNzNjOTgwZjRlMGUwNjdmLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;为什么两张表产生了不同的文件呢？原因很简单，因为创建这两张表时使用了不同的引擎&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi0wZmFkYjY5Yjg2MTIzZGFhLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1iOWQyMDk5Y2Q3ZTQzOGViLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;MyISAM引擎在创建表的时候，会创建三个文件&lt;br/&gt;&lt;strong&gt;.MYD文件：&lt;/strong&gt;存放表里的数据&lt;br/&gt;&lt;strong&gt;.MYI文件：&lt;/strong&gt;存放索引数据&lt;br/&gt;&lt;strong&gt;.sdi文件：&lt;/strong&gt; Serialized Dictionary Information的缩写。在Mysql5里没有sdi文件，但会有一个FRM文件，用户存放表结构信息。在MySQL8.0中重新设计了数据字典，改为sdi。&lt;br/&gt;MyISAM的索引和数据是分开的，并且索引是有压缩的，所以存储文件就会小很多，MyISAM应对错误码导致的数据恢复的速度很快。&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;InnerDB引擎在创建表的时候，只有1个文件.ibd，即存放了索引又存放了文件，参见B+Tree。所以它也被称之为聚集索引，即叶子节点包含完整的索引和数据，对应的MyISAM为非聚集索引。&lt;br/&gt;&lt;strong&gt;补充说明一下：存储引擎是针对表的，而不是针对数据库，同一个库的不同的表可以使用不同的引擎。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么innodb必须要有主键并且推荐使用整型的自增主键&quot;&gt;2.3 为什么InnoDB必须要有主键，并且推荐使用整型的自增主键？&lt;/h3&gt;
&lt;p&gt;通过上面的讲解这个问题其实已经很清楚了，为了满足MySQL的索引数据结构B+树的特性，必须要有索引作为主键，可以有效提高查询效率。有的童鞋可能会说我创建表的时候可以没有主键啊，这个其实和Oracle的rownum一样，如果不指定主键，InnoDB会从插入的数据中找出不重复的一列作为主键索引，如果没找到不重复的一列，InnoDB会在后台增加一列rowId做为主键索引。所以不如我们自己创建一个主键。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将索引的数据类型是设置为整型，一来占有的磁盘空间或内存空间更少，另一方面整型相对于字符串比较更快速，而字符串需要先转换为ASCII码然后再一个个进行比较的。&lt;/p&gt;
&lt;p&gt;参见B+树的图它本质上是多路多叉树，如果主键索引不是自增的，那么后续插入的索引就会引起B+树的其他节点的分裂和重新平衡，影响数据插入的效率，如果是自增主键，只用在尾节点做增加就可以。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后特别强调一点：不管当前是否有性能要求或者数据量多大，千万不要使用UUID作为索引。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;为什么mysql存储引擎中默认每个页的大小为16kb&quot;&gt;2.4 为什么Mysql存储引擎中默认每个页的大小为16KB？&lt;/h3&gt;
&lt;p&gt;假设我们一行数据大小为1K，那么一页就能存16条数据，包含指针+数据+索引。假设一行数据大小为1K，那么一页（1个叶子节点）就能存16条数据；对于非叶子节点，假设ID为bigint类型那么长度为8B，指针大小在Innodb源码中为6B，一共就是14B，那么一页里就可以存储16K/14=1170个(主键+指针)，这样一颗高度为3的B+树能存储的数据为：1170&lt;em&gt;1170&lt;/em&gt;16=2千万级别。所以我们前面1000万的数据只有0.02s。&lt;/p&gt;
&lt;h3 id=&quot;hash算法的使用场景&quot;&gt;2.5 HASH算法的使用场景&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi01MTU4ZTUzOGUwZDE0MmEyLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hash算法是一种散列算法，就是计算出某个字段的hash，然后存放在对应的地址中，查找数据时只需要1次定位而不像BTree那样从根节点找到叶子节点经过多次IO操作，所以查询效率非常地高。但同样也有很多的弊端，讲一下最重要的两条。&lt;br/&gt;1、很明显hash只支持=、IN等查询，而不支持范围查询&lt;br/&gt;2、 Hash 索引在任何时候都不能避免表扫描。&lt;/p&gt;
&lt;p&gt;所以使用时务必注意。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图片：&lt;/strong&gt;&lt;br/&gt;本文中的部分图片来源于网络，版本归原作者所有。&lt;br/&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/vianzhang/p/7922426.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/vianzhang/p/7922426.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot; class=&quot;uri&quot;&gt;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://tech.meituan.com/2014/06/30/mysql-index.html&quot; class=&quot;uri&quot;&gt;https://tech.meituan.com/2014/06/30/mysql-index.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.ucloud.cn/yun/110762.html&quot; class=&quot;uri&quot;&gt;https://www.ucloud.cn/yun/110762.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/BST.html&quot; class=&quot;uri&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/BST.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;向图片作者及内容参考的作者表示感谢！&lt;/p&gt;
&lt;p&gt;感谢各位大佬关注公众号“码大叔”，我们一起交流学习！&lt;br/&gt;&lt;strong&gt;微信公众号：码大叔&lt;/strong&gt; 十年戎“码”，老“叔”开花&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xOTU4NzAzMi1iYThiNGRmMDkzMDgyZjdhLnBuZw?x-oss-process=image/format,png&quot; width=&quot;200&quot; height=&quot;200&quot; div=&quot;&quot; align=&quot;left&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Mar 2020 00:10:00 +0000</pubDate>
<dc:creator>码大叔</dc:creator>
<og:description>在日常工作中我们不可避免地会遇到慢SQL问题，比如笔者在之前的公司时会定期收到DBA彪哥发来的Oracle AWR报告，并特别提示我某条sql近阶段执行明显很慢，可能要优化一下等。对于这样的问题通常大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/madashu/p/12508416.html</dc:identifier>
</item>
<item>
<title>超强图文｜并发编程【等待/通知机制】就是这个feel～ - 日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/12508397.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/12508397.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074941613-1489223916.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;你有一个思想，我有一个思想，我们交换后，一个人就有两个思想&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;If you can NOT explain it simply, you do NOT understand it well enough&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;现陆续将Demo代码和技术文章整理在一起 &lt;a href=&quot;https://github.com/FraserYu/learnings&quot;&gt;Github实践精选&lt;/a&gt; ，方便大家阅读查看，本文同样收录在此，觉得不错，还请Star&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074943050-752187530.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;并发编程为什么会有等待通知机制&quot;&gt;并发编程为什么会有等待通知机制&lt;/h2&gt;
&lt;p&gt;上一篇文章说明了 &lt;a href=&quot;https://dayarch.top/p/java-concurrency-dead-lock.html&quot;&gt;Java并发死锁解决思路&lt;/a&gt; ， 解决死锁的思路之一就是 &lt;code&gt;破坏请求和保持条件&lt;/code&gt;, 所有柜员都要通过&lt;strong&gt;唯一&lt;/strong&gt;的账本管理员一次性拿到所有转账业务需要的账本，就像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074943496-1802163601.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没有等待/通知机制之前，所有柜员都通过死循环的方式不断向账本管理员申请所有账本，程序的体现就是这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;while(!accountBookManager.getAllRequiredAccountBook(this, target)) 
；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如账本管理员是年轻小伙，腿脚利落（即执行 getAllRequiredAccountBook方法耗时短），并且多个柜员转账的业务冲突量不大，这个方案简单粗暴且有效，柜员只需要尝试几次就可以成功（即通过少量的循环可以实现）&lt;/p&gt;
&lt;p&gt;过了好多年，年轻的账本管理员变成了年迈的老人，行动迟缓（即执行 getAllRequiredAccountBook 耗时长），同时，多个柜员转账的业务冲突量也变大，之前几十次循环能做到的，现在可能就要申请成千上百，甚至上万次才能完成一次转账&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074944062-1756663620.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人工无限申请浪费口舌， 程序无限申请浪费CPU。聪明的人就想到了 &lt;code&gt;等待/通知&lt;/code&gt; 机制&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;等待通知机制&quot;&gt;等待/通知机制&lt;/h2&gt;
&lt;p&gt;无限循环实在太浪费CPU，而理想情况应该是这样：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;柜员A如果拿不到所有账本，就傲娇的不再继续问了（线程阻塞自己 wait）&lt;/li&gt;
&lt;li&gt;柜员B归还了柜员A需要的账本之后就主动通知柜员A账本可用（通知等待的线程 notify/notifyAll）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;做到这样，就能避免循环等待消耗CPU的问题了&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;现实中有太多场景都在应用等待/通知机制。欢迎观临红浪漫，比如去XX办证，去医院就医/体检。&lt;/p&gt;
&lt;p&gt;下面请自行脑补一下去医院就医或体检的画面, 整体流程类似这样：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;挂号成功，到诊室门口排号候诊&lt;/td&gt;
&lt;td&gt;排号的患者（线程）尝试获取【互斥锁】&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;大夫叫到自己，进入诊室就诊&lt;/td&gt;
&lt;td&gt;自己【获取到互斥锁】&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;大夫简单询问，要求做检查（患者缺乏报告不能诊断病因）&lt;/td&gt;
&lt;td&gt;进行【条件判断】，线程要求的条件【没满足】&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;自己出去做检查&lt;/td&gt;
&lt;td&gt;线程【主动释放】持有的互斥锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;大夫叫下一位患者&lt;/td&gt;
&lt;td&gt;另一位患者（线程）获取到互斥锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;自己拿到检测报告&lt;/td&gt;
&lt;td&gt;线程【曾经】要求的条件得到满足（实则【被通知】）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;再次在诊室门口排号候诊&lt;/td&gt;
&lt;td&gt;再次尝试获取互斥锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在【程序解释】一列，我将关键字（排队、锁、等待、释放....）已经用 &lt;code&gt;【】&lt;/code&gt; 框了起来。Java 语言中，其内置的关键字 &lt;code&gt;synchronized&lt;/code&gt; 和 方法&lt;code&gt;wait()，notify()/notifyAll()&lt;/code&gt; 就能实现上面提到的等待/通知机制，我们将这几个关键字实现流程现形象化的表示一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074945404-535856850.png&quot; alt=&quot;等待队列图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这可不是一个简单的图，下面还要围绕这个图做很多文章，不过这里我必须要插播几个面试基础知识点了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个锁对应一个【入口等待队列】，不同锁的入口等待队列没任何关系，说白了他们就不存在竞争关系。你想呀，不同患者进入眼科和耳鼻喉科看大夫一点冲突都没有&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait(), notify()/notifyAll()&lt;/code&gt; 要在 synchronized 内部被使用，并且，如果锁的对象是this，就要 &lt;code&gt;this.wait()，this.notify()/this.notifyAll()&lt;/code&gt; , 否则JVM就会抛出 &lt;code&gt;java.lang.IllegalMonitorStateException&lt;/code&gt; 的。你想呀，等待/通知机制就是从【竞争】环境逐渐衍生出来的策略，不在锁竞争内部使用或等待/通知错了对象， 自然是不符合常理的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074945949-1712471555.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了上面知识的铺垫，要想将无限循环策略改为等待通知策略，你还需要问自己四个问题：&lt;/p&gt;
&lt;h3 id=&quot;灵魂-4-问&quot;&gt;灵魂 4 问&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074946769-76129469.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们拿钱庄账本管理员的例子依依做以上回答：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074948385-92719355.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们优化钱庄转账的程序：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AccountBookManager {

    List&amp;lt;Object&amp;gt; accounts = new ArrayList&amp;lt;&amp;gt;(2);

    synchronized boolean getAllRequiredAccountBook( Object from, Object to){
        if(accounts.contains(from) || accounts.contains(to)){
            try{
        this.wait();
      }catch(Exception e){
        
      }
        } else{
            accounts.add(from);
            accounts.add(to);

            return true;
        }
    }
    // 归还资源
    synchronized void releaseObtainedAccountBook(Object from, Object to){
        accounts.remove(from);
        accounts.remove(to);
    notify();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就这样【看】 【似】 【完】 【美】的解决了，其实上面的程序有两个大坑：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074949224-1618165261.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;坑一&quot;&gt;坑一&lt;/h3&gt;
&lt;p&gt;在上面 &lt;code&gt;this.wait()&lt;/code&gt; 处，使用了 if 条件判断，会出现天大的麻烦，来看下图（从下往上看）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074951563-2061970825.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;notify 唤醒的那一刻，线程&lt;strong&gt;【曾经/曾经/曾经】&lt;/strong&gt;要求的条件得到了满足，从这一刻开始，到去条件等队列中唤醒线程，再到再次尝试获取锁是&lt;code&gt;有时间差&lt;/code&gt;的，当再次获取到锁时，线程曾经要求的条件是&lt;strong&gt;不一定&lt;/strong&gt;满足，所以需要&lt;strong&gt;重新&lt;/strong&gt;进行条件判断，所以需要将 &lt;code&gt;if&lt;/code&gt; 判断改成 &lt;code&gt;while&lt;/code&gt; 判断&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized boolean getAllRequiredAccountBook( Object from, Object to){
        while(accounts.contains(from) || accounts.contains(to)){
            try{
        this.wait();
      }catch(Exception e){
        
      }
        } else{
            accounts.add(from);
            accounts.add(to);

            return true;
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;一个线程可以从挂起状态变为可运行状态（也就是被唤醒），即使线程没有被其他线程调用&lt;code&gt;notify()/notifyAll()&lt;/code&gt; 方法进行通知，或被中断，或者等待超时，这就是所谓的【&lt;strong&gt;虚假唤醒&lt;/strong&gt;】。虽然虚假唤醒很少发生，但要防患于未然，&lt;strong&gt;做法就是不停的去测试该线程被唤醒条件是否满足&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;——摘自《Java并发编程之美》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;有同学可能还会产生疑问，为什么while就可以？&lt;/p&gt;
&lt;p&gt;因为被唤醒的线程再次获取到锁之后是&lt;strong&gt;从原来的 wait 之后开始执行的&lt;/strong&gt;，wait在循环里面，所以会再次进入循环条件重新进行条件判断。&lt;/p&gt;
&lt;p&gt;如果不理解这个道理就记住一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;从哪里跌倒就从哪里爬起来；在哪里wait，就从wait那里继续向后执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，这也就成了使用wait()的标准范式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074955525-1860723322.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于坑二，是线程归还所使用的账户之后使用 notify 而不是 notifyAll 进行通知，由于坑很大，需要一些知识铺垫来说明&lt;/p&gt;
&lt;h2 id=&quot;为什么说尽量使用-notifyall&quot;&gt;为什么说尽量使用 notifyAll&lt;/h2&gt;
&lt;p&gt;notify() 和 notifyAll() 到底啥区别？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;notify()&lt;/code&gt; 函数&lt;/p&gt;
&lt;h3 id=&quot;section&quot;/&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;随机唤醒一个：&lt;/strong&gt;一个线程调用共享对象的 notify() 方法，会唤醒&lt;strong&gt;一个&lt;/strong&gt;在该共享变量上调用 wait() 方法后被挂起的线程，一个共享变量上可能有多个线程在等待，具体唤醒那一个，是&lt;strong&gt;随机的&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;notifyAll()&lt;/code&gt; 函数&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;唤醒所有：&lt;/strong&gt; 与notify() 不同，notifyAll() 会唤醒在该共享变量上由于调用wait() 方法而被挂起的&lt;strong&gt;所有线程&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看个非常简单的程序例子吧&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例程序一&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
public class NotifyTest {

    private static volatile Object resourceA = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread threadA = new Thread(() -&amp;gt; {
                synchronized (resourceA){
                    log.info(&quot;threadA get resourceA lock&quot;);

                    try{
                        log.info(&quot;threadA begins to wait&quot;);
                        resourceA.wait();
                        log.info(&quot;threadA ends wait&quot;);
                    }catch (InterruptedException e){
                        log.error(e.getMessage());
                    }
                }
        });

        Thread threadB = new Thread(() -&amp;gt; {
            synchronized (resourceA){
                log.info(&quot;threadB get resourceA lock&quot;);

                try{
                    log.info(&quot;threadB begins to wait&quot;);
                    resourceA.wait();
                    log.info(&quot;threadB ends wait&quot;);
                }catch (InterruptedException e){
                    log.error(e.getMessage());
                }
            }
        });

        Thread threadC = new Thread(() -&amp;gt; {
            synchronized (resourceA){
                log.info(&quot;threadC begin to notify&quot;);
                resourceA.notify();
            }
        });

        threadA.start();
        threadB.start();

        Thread.sleep(1000);

        threadC.start();

        threadA.join();
        threadB.join();
        threadC.join();

        log.info(&quot;main thread over now&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074955931-1466817565.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序中我们使用notify()随机通知resourceA的等待队列的一个线程，threadA被唤醒，threadB却没有打印出 &lt;code&gt;threadB ends wait&lt;/code&gt; 这句话，遗憾的死掉了&lt;/p&gt;
&lt;p&gt;将 notify() 换成 notifyAll() 的结果想必你已经知道了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074956433-1521696370.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 notifyAll() 确实不会遗落等待队列中的线程，但也产生了比较强烈的竞争，如果notify() 设计的本身就是 bug，那么这个函数应该早就从 JDK 中移除了，它随机通知一个线程的形式必定是有用武之地的&lt;/p&gt;
&lt;h2 id=&quot;什么时候可以使用-notify&quot;&gt;什么时候可以使用 notify()&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074957042-1751734403.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;notify() 的典型的应用就是线程池（按照上面的三个条件你自问自答验证一下是这样吗？）&lt;/p&gt;
&lt;p&gt;这里我们拿一个 JUC 下的类来看看 notify() 的用处&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Tips:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;notify()&lt;/code&gt; 等同于 &lt;code&gt;signal()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait()&lt;/code&gt; 等同于 &lt;code&gt;await()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;在IDE中，打开 &lt;code&gt;ArrayBlockingQueue.java&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074957534-870655607.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有的入队 public 方法&lt;code&gt;offer()/put()&lt;/code&gt; 内部都调用了 private 的 &lt;code&gt;enqueue()&lt;/code&gt; 方法&lt;/p&gt;
&lt;p&gt;所有的出队 public 方法&lt;code&gt;poll()/take()&lt;/code&gt; 内部都调用了 private 的 &lt;code&gt;dequeue()&lt;/code&gt; 方法&lt;/p&gt;
&lt;p&gt;将这个模型进行精简就是下面这个样子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SimpleBlockingQueue&amp;lt;T&amp;gt; {

    final Lock lock = new ReentrantLock();
    // 条件变量：队列不满
    final Condition notFull = lock.newCondition();
    // 条件变量：队列不空
    final Condition notEmpty = lock.newCondition();

    // 入队
    void enq(T x) {
        lock.lock();
        try {
            while (队列已满){
                // 等待队列不满
                notFull.await();
            }
            // 省略入队操作...
            //入队后,通知可出队
            notEmpty.signal();
        }finally {
            lock.unlock();
        }
    }
    // 出队
    void deq(){
        lock.lock();
        try {
            while (队列已空){
                // 等待队列不空
                notEmpty.await();
            }
            // 省略出队操作...
            //出队后，通知可入队
            notFull.signal();
        }finally {
            lock.unlock();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果满足上面这三个条件，notify() 的使用就恰到好处；我们用使用 &lt;code&gt;notify()&lt;/code&gt;的条件进行验证&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074958135-1599406566.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有的同学看到这里可能会稍稍有一些疑惑，&lt;code&gt;await()/signal()&lt;/code&gt; 和 &lt;code&gt;wait()/notify()&lt;/code&gt; 组合的玩法看着不太一样呢，你疑惑的没有错&lt;/p&gt;
&lt;p&gt;因为 Java 内置的监视器锁模型是 MESA 模型的精简版&lt;/p&gt;
&lt;h2 id=&quot;mesa模型&quot;&gt;MESA模型&lt;/h2&gt;
&lt;p&gt;MESA 监视器模型中说，每一个条件变量都对应一个条件等待队列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317074959876-1725435394.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应到上面程序：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;队列已满是前提条件，条件变量A就是notFull，也就是notFull.await; notFull.signal&lt;/li&gt;
&lt;li&gt;队列已空是前提条件，条件变量B就是notEmpty，也就是notEmpty.await; notEmpty.signal/sign&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;即便notFull.signalAll, 也和await在notEmpty 条件变量队列的线程没半毛钱关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而Java内置监视器模型就只会有一个【隐形的】条件变量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是synchronized修饰的普通方法，条件变量就是 this&lt;/li&gt;
&lt;li&gt;如果是synchronized修饰的静态方法，条件变量就是类&lt;/li&gt;
&lt;li&gt;如果是synchronized块，条件变量就是块中的内容了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说完了这些，你有没有恍然大悟的感觉呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317075000473-748734604.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;如果业务冲突不大，循环等待是一种简单粗暴且有效的方式；但是当业务冲突大之后，通知/等待机制是必不可少的使用策略&lt;/p&gt;
&lt;p&gt;通过这篇文章，相信你已经可以通过灵魂4问，知道如何将循环等待改善成通知/等待模型了；另外也知道如何正确的使用通知/等待机制了&lt;/p&gt;
&lt;h2 id=&quot;灵魂追问&quot;&gt;灵魂追问&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;钱庄转账的业务，条件都是判断账户是否被支配，都是执行相同的转账业务，为什么就不可以用notify() 而只能用notifyAll() 呢&lt;/li&gt;
&lt;li&gt;ResourceA的例子，为什么使用notify通知，程序没有打印出 &lt;code&gt;main thread over now&lt;/code&gt;， 而使用notifyAll() 却打印出来了呢？&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;感谢前辈们总结的精华，自己所写的并发系列好多都参考了以下资料&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java 并发编程实战&lt;/li&gt;
&lt;li&gt;Java 并发编程之美&lt;/li&gt;
&lt;li&gt;码出高效&lt;/li&gt;
&lt;li&gt;Java 并发编程的艺术&lt;/li&gt;
&lt;li&gt;https://www.geeksforgeeks.org/difference-notify-notifyall-java/&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;下面的文章，就需要聊聊【线程的生命周期】了，只有熟知线程的生命周期，你才能更好的编写并发程序。&lt;/p&gt;
&lt;p&gt;我这面也在逐步总结常见的并发面试问题（总结ing......）答案整理好后会通知大家，请持续关注&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317075001786-621501056.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时，这里也整理了一点 Java 硬核资料，有需要的就公众号回复【资料】/【666】吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1583165/202003/1583165-20200317075002530-1560120420.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Mon, 16 Mar 2020 23:50:00 +0000</pubDate>
<dc:creator>日拱一兵</dc:creator>
<og:description>你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it well enough</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/12508397.html</dc:identifier>
</item>
<item>
<title>ReentrantLock源码探究 - 纳兰小依</title>
<link>http://www.cnblogs.com/NaLanZiYi-LinEr/p/12508195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NaLanZiYi-LinEr/p/12508195.html</guid>
<description>&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;是一种可重入锁，可重入是说同一个线程可以多次获取同一个锁，内部会有相应的字段记录重入次数，它同时也是一把互斥锁，意味着同时只有一个线程能获取到可重入锁。&lt;/p&gt;
&lt;h2 id=&quot;构造函数&quot;&gt;1.构造函数&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;    public ReentrantLock() {
        sync = new NonfairSync();
    }

    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;提供了两个构造函数，构造函数只是用来初始化&lt;code&gt;sync&lt;/code&gt;字段，可以看到，默认情况下&lt;code&gt;ReentrantLock&lt;/code&gt;使用的是非公平锁，当然，也可以使用带有布尔参数的构造函数来选择使用公平锁。公平锁和非公平锁的实现依赖于两个内部类：&lt;code&gt;FairSync&lt;/code&gt;和&lt;code&gt;NonfairSync&lt;/code&gt;，接下来认识一下这两个类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //非公平锁
    static final class NonfairSync extends Sync {
        private static final long serialVersionUID = 7316153563782823691L;

        /**
         * Performs lock.  Try immediate barge, backing up to normal
         * acquire on failure.
         */
        final void lock() {
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
                acquire(1);
        }

        protected final boolean tryAcquire(int acquires) {
            return nonfairTryAcquire(acquires);
        }
    }

    static final class FairSync extends Sync {
        private static final long serialVersionUID = -3000897897090466540L;

        final void lock() {
            acquire(1);
        }

        /**
         * Fair version of tryAcquire.  Don't grant access unless
         * recursive call or no waiters or is first.
         */
        protected final boolean tryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
            if (c == 0) {
                if (!hasQueuedPredecessors() &amp;amp;&amp;amp;
                    compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc &amp;lt; 0)
                    throw new Error(&quot;Maximum lock count exceeded&quot;);
                setState(nextc);
                return true;
            }
            return false;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个内部类的代码都很短，并且都继承了另一个内部类&lt;code&gt;Sync&lt;/code&gt;。这里先不急着介绍&lt;code&gt;Sync&lt;/code&gt;类，因为这个类本身也并不复杂，后续在需要用到其中的方法时顺带讲解，目前只需要知道这个类继承了&lt;code&gt;AbstractQueuedSynchronizer(AQS)&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2 id=&quot;常用方法&quot;&gt;2.常用方法&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;    public void lock() {
        sync.lock();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;lock&lt;/code&gt;方法提供了加锁的功能，公平锁和非公平锁的加锁操作是不一样的，先来看看非公平锁的细节，接着再讲解公平锁。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非公平锁加锁逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    final void lock() {
        //使用CAS操作，尝试将state字段从0修改为1，如果成功修改该字段，则表示获取了互斥锁
        //如果获取互斥锁失败，转入acquier()方法逻辑
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }
    
    //设置获得了互斥锁的线程
    protected final void setExclusiveOwnerThread(Thread thread) {
        exclusiveOwnerThread = thread;
    }

    public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;amp;&amp;amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于非公平锁来讲，使用&lt;code&gt;lock()&lt;/code&gt;方法一上来就尝试获取互斥锁，获取成功就将&lt;code&gt;exclusiveOwnerThread&lt;/code&gt;指向自己，代表当前是自己持有锁，否则就执行&lt;code&gt;acquire()&lt;/code&gt;方法的逻辑，下面对&lt;code&gt;acquire()&lt;/code&gt;方法的逻辑进行逐个分析。&lt;br/&gt;首先是&lt;code&gt;tryAcquire()&lt;/code&gt;方法，非公平锁重写了该方法，并在内部调用&lt;code&gt;Sync&lt;/code&gt;类的&lt;code&gt;nonfairTryAcquire()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //从上面的逻辑来看，这里的acquires=1
    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }

    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        //c==0，说明当前处于未加锁状态，锁没有被其他线程获取
        if (c == 0) {
            //在锁没有被其他线程占有的情况下，非公平锁再次尝试获取锁，获取成功则将exclusiveOwnerThread指向自己
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        //执行到这里说明锁已经被占有，如果是被自己占有，将state字段加1，记录重入次数
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            //当nextc达到int类型最大值时会溢出，因此可重入次数的最大值就是int类型的最大值
            if (nextc &amp;lt; 0) // overflow
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        //执行到这里说明：1）锁未被占有的情况下，抢锁失败，说明当前有其他线程抢到了锁；2）锁已经被其他线程占有
        //即只要当前线程没有获取到锁，就返回false
        return false;
    }
    
    //获取state字段，该字段定义在AQS中
    protected final int getState() {
        return state;
    }
    //设置state字段
    protected final void setState(int newState) {
        state = newState;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前线程没有在&lt;code&gt;tryAcquire()&lt;/code&gt;方法中获取到锁时，会先执行&lt;code&gt;addWaiter(Node.EXCLUSIVE)&lt;/code&gt;方法，其中参数&lt;code&gt;Node.EXCLUSIVE&lt;/code&gt;是一个常量，其定义是&lt;code&gt;static final Node EXCLUSIVE = null&lt;/code&gt;，作用是标记锁的属性是互斥锁。&lt;code&gt;addWaiter()&lt;/code&gt;方法的作用是将当前线程包装成一个&lt;code&gt;Node&lt;/code&gt;节点，放入等待队列的队尾，该方法在介绍&lt;code&gt;CountDownLatch&lt;/code&gt;类时详细讲解过，有兴趣的朋友可以参考&lt;a href=&quot;https://www.cnblogs.com/NaLanZiYi-LinEr/p/12391903.html&quot;&gt;ConcurrentHashMap源码探究（JDK 1.8）&lt;/a&gt;，本文不再赘述。&lt;br/&gt;将当前线程加入等待队列之后，会接着执行&lt;code&gt;acquireQueued()&lt;/code&gt;方法，其源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            //自旋
            for (;;) {
                //获取当前节点的前一个节点
                final Node p = node.predecessor();
                //如果前一个节点是头节点，说明当前节点排在队首，非公平锁会则再次通过tryAcquire方法获取锁
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    //将自己设置为头节点
                    setHead(node);
                    //前一个头结点没用了，会被垃圾回收掉
                    p.next = null; // help GC
                    failed = false;
                    //正常结束，返回false，注意该字段可能会在下面的条件语句中被改变
                    return interrupted;
                }
                //如果前一个节点不是头节点，或者当前线程获取锁失败，会执行到这里
                //shouldParkAfterFailedAcquire()方法只有在p的状态是SIGNAL时才返回false，此时parkAndCheckInterrupt()方法才有机会执行
                //注意外层的自旋，for循环体会一直重试，因此只要执行到这里，总会有机会将p设置成SIGNAL状态从而将当前线程挂起
                //另外，如果parkAndCheckInterrupt()返回true，说明当前线程设置了中断状态，会将interrupted设置为true，代码接着自旋，会在上一个条件语句中返回true
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            //如果在自旋中线程被中断或者发送异常，failed字段的值将会为true，这里会处理这种情况，放弃让当前线程获取锁，并抛出中断异常
            if (failed)
                cancelAcquire(node);
        }
    }
    //方法逻辑是：只有在前置节点的状态是SIGNAL时才返回true，其他情况都返回false
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            return true;
        //删除当前节点之前连续状态是CANCELLED的节点
        if (ws &amp;gt; 0) {
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &amp;gt; 0);
            pred.next = node;
        } else {
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
    //线程在这里阻塞，并在被唤醒后检查中断状态
    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }
    
    //
    private void cancelAcquire(Node node) {
        // Ignore if node doesn't exist
        if (node == null)
            return;

        node.thread = null;

        // Skip cancelled predecessors
        Node pred = node.prev;
        while (pred.waitStatus &amp;gt; 0)
            node.prev = pred = pred.prev;

        Node predNext = pred.next;

        node.waitStatus = Node.CANCELLED;

        // If we are the tail, remove ourselves.
        if (node == tail &amp;amp;&amp;amp; compareAndSetTail(node, pred)) {
            compareAndSetNext(pred, predNext, null);
        } else {
            // If successor needs signal, try to set pred's next-link
            // so it will get one. Otherwise wake it up to propagate.
            int ws;
            if (pred != head &amp;amp;&amp;amp;
                ((ws = pred.waitStatus) == Node.SIGNAL ||
                 (ws &amp;lt;= 0 &amp;amp;&amp;amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;amp;&amp;amp;
                pred.thread != null) {
                Node next = node.next;
                if (next != null &amp;amp;&amp;amp; next.waitStatus &amp;lt;= 0)
                    compareAndSetNext(pred, predNext, next);
            } else {
                //唤醒后一个节点
                unparkSuccessor(node);
            }

            node.next = node; // help GC
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;acquireQueued()&lt;/code&gt;要么会抛出中断异常，要么正常结束返回&lt;code&gt;false&lt;/code&gt;，只有在线程被唤醒后设置了中断状态才会返回&lt;code&gt;true&lt;/code&gt;。对比可以发现，&lt;code&gt;acquireQueued()&lt;/code&gt;方法的逻辑与&lt;code&gt;CountDownLatch&lt;/code&gt;中的&lt;code&gt;doAcquireSharedInterruptibly()&lt;/code&gt;十分类似，许多方法在&lt;code&gt;CountDownLatch&lt;/code&gt;这篇博客中讲到过，本文不再对这些方法进行赘述。&lt;br/&gt;介绍完了&lt;code&gt;acquire()&lt;/code&gt;方法，回过头来看看方法逻辑：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;amp;&amp;amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在&lt;code&gt;tryAcquire()&lt;/code&gt;方法中没有获取锁，那么将当前线程加入到等待队列队尾，查看节点的前一个节点是否是头结点，是的话当前线程可以继续向下执行，否则就会阻塞挂起。当&lt;code&gt;acquireQueued&lt;/code&gt;返回true时，说明线程设置了中断状态，就调用&lt;code&gt;selfInterrupt()&lt;/code&gt;中断该线程，其他情况&lt;code&gt;selfInterrupt()&lt;/code&gt;方法没机会执行。&lt;br/&gt;到这里非公平锁的加锁流程已经介绍完了，由于代码逻辑比较长，且看源码的过程中会在好几个类中来回切换，思路很容易断，阅读代码的时候要注意。（有必要补个流程图）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;公平锁加锁逻辑&lt;br/&gt;接下来看看公平锁的加锁逻辑：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    final void lock() {
        acquire(1);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与非公平锁相比，公平锁没有一上来就抢锁的逻辑，这也是公平性的体现。两种锁的&lt;code&gt;acquire()&lt;/code&gt;方法的框架相同，但是实现细节不同，来看看公平锁的&lt;code&gt;tryAcquire()&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        //c=0表示当前没有其他线程持有锁
        if (c == 0) {
            //下面的代码与非公平锁相比，多了hasQueuedPredecessors()方法的处理逻辑，公平锁只有在前面没有其他线程排队的情况下才会尝试获取锁
            if (!hasQueuedPredecessors() &amp;amp;&amp;amp;
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        //如果当前线程已经占有公平锁，则记录重入次数
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &amp;lt; 0)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        //只要当前线程没有获取到锁，就返回false
        return false;
    }

    public final boolean hasQueuedPredecessors() {
        // The correctness of this depends on head being initialized
        // before tail and on head.next being accurate if the current
        // thread is first in queue.
        Node t = tail; // Read fields in reverse initialization order
        Node h = head;
        Node s;
        //h != t表示等待队列中有其他节点
        //h.next == null可能会有点费解，按理说h!=t之后，h后面肯定会有节点才对，这种情况其实已经见过，在上文介绍acquireQueued()方法时说过，
        //被唤醒的第一个等待节点会将自己设置为头结点，如果这个节点是队列中的唯一节点的话，它的下一个节点就是null
        //至于s.thread != Thread.currentThread()这个条件暂时可以忽略，因为公平锁执行到hasQueuedPredecessors方法时根本还没有入队，
        //这也意味着，只要队列中有其他节点在等候，公平锁就要求其他线程排队等待
        return h != t &amp;amp;&amp;amp;
            ((s = h.next) == null || s.thread != Thread.currentThread());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;lockInterruptibly&lt;/code&gt;&lt;br/&gt;从名字可以看出，&lt;code&gt;lockInterruptibly&lt;/code&gt;可以响应中断，来看看该方法的实现：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    public final void acquireInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        //先尝试获取锁，获取失败才执行后面的逻辑
        if (!tryAcquire(arg))
            doAcquireInterruptibly(arg);
    }

    private void doAcquireInterruptibly(int arg)
        throws InterruptedException {
        final Node node = addWaiter(Node.EXCLUSIVE);
        boolean failed = true;
        try {
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;lockInterruptibly()&lt;/code&gt;方法几乎与&lt;code&gt;acquire()&lt;/code&gt;方法完全一样，唯一的区别是&lt;code&gt;acquire()&lt;/code&gt;方法中，&lt;code&gt;parkAndCheckInterrupt&lt;/code&gt;因为线程设置了中断状态而返回&lt;code&gt;true&lt;/code&gt;时，只是简单设置了一下&lt;code&gt;interrupted&lt;/code&gt;字段的值，而&lt;code&gt;lockInterruptibly()&lt;/code&gt;则是直接抛出异常。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;unlock&lt;/code&gt;方法&lt;br/&gt;介绍完加锁的逻辑，接下来看看解锁的逻辑：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public void unlock() {
        sync.release(1);
    }

    public final boolean release(int arg) {
        //如果成功释放了锁，则执行下面的代码块
        if (tryRelease(arg)) {
            Node h = head;
            //如果头节点不为null，请求节点状态不是初始状态，就释放头结点后第一个有效节点
            //问题：这里为什么需要判断头结点的状态呢？？？
            if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
    
    //
    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;
        //线程没有持有锁的情况下，不允许释放锁，否则会抛异常
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        //可重入性的判断，如果释放了一次锁，使得c=0，就指针释放锁，做法是将记录锁的字段exclusiveOwnerThread重新指向null
        //注意，只有最后一次释放可重入锁，才会返回true
        if (c == 0) {
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }

    //唤醒node节点的下一个有效节点，这里的有效指的是状态不是CANCELLED状态的节点
    private void unparkSuccessor(Node node) {

        int ws = node.waitStatus;
        if (ws &amp;lt; 0)
            compareAndSetWaitStatus(node, ws, 0);

        Node s = node.next;
        if (s == null || s.waitStatus &amp;gt; 0) {
            s = null;
            for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
                if (t.waitStatus &amp;lt;= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;newCondition()&lt;/code&gt;&lt;br/&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;可以实现绑定多个等待条件，这个功能是在&lt;code&gt;newCondition()&lt;/code&gt;方法中实现的，每次调用&lt;code&gt;newCondition()&lt;/code&gt;方法时，都会产生一个新的&lt;code&gt;ConditionObject&lt;/code&gt;对象，这是&lt;code&gt;AQS&lt;/code&gt;中的一个内部类，代码很长，这里就不详细讨论了。来简单看看该方法的源码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public Condition newCondition() {
        return sync.newCondition();
    }
    final ConditionObject newCondition() {
        return new ConditionObject();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;3.总结&lt;/h2&gt;
&lt;p&gt;在多线程环境中，&lt;code&gt;ReentrantLock&lt;/code&gt;的非公平锁要比公平锁拥有更高的性能，因为非公平锁避免了线程挂起产生的上下文切换的开销，但是公平锁能够避免线程饥饿问题，因此各有各的使用场景。从源码来看，&lt;code&gt;J.U.C&lt;/code&gt;包下的很多类都依赖&lt;code&gt;AQS&lt;/code&gt;类，因此非常有必要搞懂&lt;code&gt;AQS&lt;/code&gt;。提到&lt;code&gt;ReentrantLock&lt;/code&gt;，总免不了与&lt;code&gt;synchronized&lt;/code&gt;进行对比。&lt;code&gt;synchronized&lt;/code&gt;也是可重入的，并且在&lt;code&gt;JDK 1.6&lt;/code&gt;以后，&lt;code&gt;synchronized&lt;/code&gt;的性能已经得到了很大的提升，因此选择使用&lt;code&gt;ReentrantLock&lt;/code&gt;一般是考虑使用它的三个优势：可中断、可实现公平锁、可绑定多个条件，这些优势是&lt;code&gt;synchronized&lt;/code&gt;不具备的。&lt;/p&gt;
</description>
<pubDate>Mon, 16 Mar 2020 16:37:00 +0000</pubDate>
<dc:creator>纳兰小依</dc:creator>
<og:description>`ReentrantLock`是一种可重入锁，可重入是说同一个线程可以多次获取同一个锁，内部会有相应的字段记录重入次数，它同时也是一把互斥锁，意味着同时只有一个线程能获取到可重入锁。 1.构造函数 提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/NaLanZiYi-LinEr/p/12508195.html</dc:identifier>
</item>
<item>
<title>数据挖掘入门系列教程（四点五）之Apriori算法 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/12508171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/12508171.html</guid>
<description>&lt;h2 id=&quot;数据挖掘入门系列教程四点五之apriori算法&quot;&gt;数据挖掘入门系列教程（四点五）之Apriori算法&lt;/h2&gt;
&lt;p&gt;Apriori（先验）算法&lt;strong&gt;关联规则&lt;/strong&gt;学习的经典算法之一，用来寻找出数据集中频繁出现的数据集合。如果看过以前的博客，是不是想到了这个跟&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12419410.html&quot;&gt;数据挖掘入门系列教程（一）之亲和性分析&lt;/a&gt;这篇博客很相似？Yes，的确很相似，只不过在这篇博客中，我们会更加深入的分析如何寻找可靠有效的亲和性。并在下一篇博客中使用Apriori算法去分析电影中的亲和性。这篇主要是介绍Apriori算法的流程。&lt;/p&gt;
&lt;h3 id=&quot;频繁项集数据的评判标准&quot;&gt;频繁（项集）数据的评判标准&lt;/h3&gt;
&lt;p&gt;这个在&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12419410.html&quot;&gt;数据挖掘入门系列教程（一）之亲和性分析&lt;/a&gt;这篇博客曾经提过，但在这里再重新详细的说一下。&lt;/p&gt;
&lt;p&gt;何如判断一个数据是否是频繁？按照我们的想法，肯定是数据在数据集中出现次数的越多，则代表着这个数据出现的越频繁。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;值得注意的是：在这里的数据可以是一个数据，也可以是多个数据 （项集）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下面这张图为例子，这张图每一列代表商品是否被购买（1代表被购买，0代表否），每一行代表一次交易记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200317002411273-1930426013.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常用的评估标准由&lt;strong&gt;支持度&lt;/strong&gt;、&lt;strong&gt;置信度&lt;/strong&gt;、和&lt;strong&gt;提升度&lt;/strong&gt;三个：&lt;/p&gt;
&lt;h4 id=&quot;支持度support&quot;&gt;支持度（support）:&lt;/h4&gt;
&lt;p&gt;支持度就是数据在数据集中出现的次数（也可以是次数占总数据集的比重），或者说其在数据集中出现的概率：&lt;/p&gt;
&lt;p&gt;下面的公式以所占比例来说明：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} &amp;amp; 如果是一个数据X，则其支持度为：\\ &amp;amp; support(X) = P(X) = \frac{num(X)}{num(ALL)} \\ &amp;amp; 如果数据是一个数据项集（X,Y）,则支持度为：\\ &amp;amp; support(X,Y) = P(X,Y) = \frac{num(XY)}{num(ALL)}\\ &amp;amp; 如果数据是一个数据项集（X,Y,Z）,则支持度为：\\ &amp;amp; support(X,Y,Z) = P(X,Y,Z) = \frac{num(XYZ)}{num(ALL)}\\ &amp;amp; (X,Y,Z代表的是X,Y,Z同时出现的次数) \end{split} \]&lt;/span&gt;&lt;br/&gt;以上面的交易为例：&lt;/p&gt;
&lt;p&gt;我们来求 &lt;em&gt;（黄油，苹果）&lt;/em&gt; 的支持度：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（黄油，苹果）&lt;/em&gt; 在第&lt;code&gt;0，2，3&lt;/code&gt;中通过出现了，一共是5条数据，因此&lt;span class=&quot;math inline&quot;&gt;\(support(黄油,苹果) = \frac{3}{5} = 0.6\)&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一般来说，支持度高的不一定数据频繁，但是数据频繁的一定支持度高&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;置信度confidence&quot;&gt;置信度（confidence）：&lt;/h4&gt;
&lt;p&gt;置信度代表的规则应验的准确性，也就是一个数据出现后，另外一个数据出现的概率，也就是条件概率。(以购买为例，就是已经购买Y的条件下，购买X的概率)公式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} &amp;amp; 设分析的数据是X,Y，则X对Y的置信度为：\\ &amp;amp; confidence(X \Leftarrow Y) = P(X|Y) = \frac{P(XY)}{P(Y)} \\ &amp;amp; 设分析的数据是X,Y,Z，则X对Y和Z的置信度为：\\ &amp;amp; confidence(X \Leftarrow YZ) = P(X|YZ) = \frac{P(XYZ)}{P(YZ)} \\ \end{split} \]&lt;/span&gt;&lt;br/&gt;还是以 &lt;em&gt;（黄油，苹果）&lt;/em&gt; 为例子，计算黄油对苹果的置信度：&lt;span class=&quot;math inline&quot;&gt;\(confidence(黄油\Leftarrow苹果) = \frac{3}{4} = 0.75\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;但是置信度有一个缺点，那就是它可能会扭曲关联的重要性。因为它只反应了Y的受欢迎的程度。如果X的受欢迎程度也很高的话，那么confidence也会很大。下面是数据挖掘蒋少华老师的一段为什么我们需要使用&lt;code&gt;提升度&lt;/code&gt;的话：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200317002411614-1461438452.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;提升度lift&quot;&gt;提升度（Lift）：&lt;/h4&gt;
&lt;p&gt;提升度表示在含有Y的条件下，同时含有X的概率，同时考虑到X的概率，公式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \begin{aligned} Lift(X \Leftarrow Y) &amp;amp;= \frac{support(X,Y)}{support(X) \times support(Y)} \ \ &amp;amp;= \frac{P(X,Y)}{P(X) \times P(Y)}\\ &amp;amp; = \frac{P(X|Y)}{P(X)}\\ &amp;amp; = \frac{confidenc(X\Leftarrow Y)}{P(X)} \end{aligned} \end{equation} \]&lt;/span&gt;&lt;br/&gt;在提升度中，如果&lt;span class=&quot;math inline&quot;&gt;\(Lift(X \Leftarrow Y) = 1\)&lt;/span&gt;则表示X，Y之间相互独立，没有关联（因为&lt;span class=&quot;math inline&quot;&gt;\(P(X|Y) = P(X)\)&lt;/span&gt;），如果&lt;span class=&quot;math inline&quot;&gt;\(Lift(X \Leftarrow Y) &amp;gt; 1\)&lt;/span&gt;则表示&lt;span class=&quot;math inline&quot;&gt;\(X \Leftarrow Y\)&lt;/span&gt;则表示&lt;span class=&quot;math inline&quot;&gt;\(X \Leftarrow Y\)&lt;/span&gt;是有效的强关联（在购买Y的情况下很可能购买X）；如果&lt;span class=&quot;math inline&quot;&gt;\(Lift(X \Leftarrow Y) &amp;lt; 1\)&lt;/span&gt;则表示&lt;span class=&quot;math inline&quot;&gt;\(X \Leftarrow Y\)&lt;/span&gt;则表示&lt;span class=&quot;math inline&quot;&gt;\(X \Leftarrow Y\)&lt;/span&gt;是无效的强关联。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;一般来说，我们如何判断一个数据集中数据的频繁程度时使用提升度来做的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;apriori-算法流程&quot;&gt;Apriori 算法流程&lt;/h3&gt;
&lt;p&gt;说完评判标准，接下来我们说一下算法的流程（来自参考1）。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Apriori算法的目标是找到最大的K项频繁集。这里有两层意思，首先，我们要找到符合支持度标准（置信度or提升度）的频繁集。但是这样的频繁集可能有很多。第二层意思就是我们要找到最大个数的频繁集。比如我们找到符合支持度的频繁集AB和ABE，那么我们会抛弃AB，只保留ABE，因为AB是2项频繁集，而ABE是3项频繁集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;算法的流程图如下（图来自《Python数据挖掘入门与实践》）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200317002412011-1567431600.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是一个具体的例子来介绍（图源不知道来自哪里，很多博客都在用），这个例子是以support作为评判标准，在图中&lt;span class=&quot;math inline&quot;&gt;\(C_n\)&lt;/span&gt;代表的是&lt;strong&gt;备选项集&lt;/strong&gt;，L代表的是被剪掉后的选项集，&lt;span class=&quot;math inline&quot;&gt;\(Min\ support = 50\%\)&lt;/span&gt;代表的是最小符合标准的支持度（大于它则表示频繁）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202003/1439869-20200317002412441-1985965728.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个例子的图像还是满生动的，很容易看的懂。下面就简单的解释一下：&lt;/p&gt;
&lt;p&gt;首先我们有数据集D，然后生成数据项&lt;span class=&quot;math inline&quot;&gt;\(K =1\)&lt;/span&gt;的备选项集&lt;span class=&quot;math inline&quot;&gt;\(C_1\)&lt;/span&gt;，然后去除&lt;span class=&quot;math inline&quot;&gt;\(support_n &amp;lt; Min\ support\)&lt;/span&gt;的数据项，得到&lt;span class=&quot;math inline&quot;&gt;\(L_1\)&lt;/span&gt;，然后又生成数据项&lt;span class=&quot;math inline&quot;&gt;\(K =2\)&lt;/span&gt;的备选项集&lt;span class=&quot;math inline&quot;&gt;\(C_2\)&lt;/span&gt;，然后又去除&lt;span class=&quot;math inline&quot;&gt;\(support_n &amp;lt; Min\ support\)&lt;/span&gt;的数据项。进行递归，直到无法发现新的频繁项。&lt;/p&gt;
&lt;h3 id=&quot;结尾&quot;&gt;结尾&lt;/h3&gt;
&lt;p&gt;总的来说，Apriori算法不是很难，算法的流程也很简单，而它的核心在于如何构建一个有效的评判标准，support？confidence？Lift？or others？但是它也有一些缺点：每次递归都需要产生大量的备选项集，如果数据集很大的话，怎么办？重复的扫描数据集……&lt;/p&gt;
&lt;p&gt;在下一篇博客中，我将介绍如何使用Apriori算法对电影的数据集进行分析，然后找出之间的相关关系。&lt;/p&gt;
&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/pinard/p/6293298.html&quot;&gt;Apriori算法原理总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kdnuggets.com/2016/04/association-rules-apriori-algorithm-tutorial.html&quot;&gt;Association Rules and the Apriori Algorithm: A Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《Python数据挖掘入门与实践》&lt;/li&gt;
&lt;li&gt;数据挖掘蒋少华老师&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
</description>
<pubDate>Mon, 16 Mar 2020 16:25:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>[TOC] 数据挖掘入门系列教程（四点五）之Apriori算法 Apriori（先验）算法 关联规则 学习的经典算法之一，用来寻找出数据集中频繁出现的数据集合。如果看过以前的博客，是不是想到了这个跟</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/12508171.html</dc:identifier>
</item>
<item>
<title>Redis集群搭建及选举原理 - 白露非霜</title>
<link>http://www.cnblogs.com/nijunyang/p/12508098.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nijunyang/p/12508098.html</guid>
<description>&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;redis集群简述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;哨兵模式中如果主从中&lt;/span&gt;master宕机了，是通过哨兵来选举出新的master，在这个选举切换主从的过程，整个redis服务是不可用的。而且哨兵模式中只有一个主节点对外提供服务，因此没法支持更高的并发。而且当个主节点的内存设置也不宜过大。否则会导致持久化文件过大，影响数据恢复或主从同步的效率。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;redis集群是由&lt;span&gt;一系列的&lt;/span&gt;&lt;span&gt;主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。&lt;/span&gt;Redis集群不需要 sentinel哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点&lt;span&gt;，客户端通过&lt;/span&gt;CRC16算法对key进行hash&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;得到一个值，来判断该&lt;/span&gt;key存储在哪个主从服务上面，因此就算是某一个主从整个宕机，redis集群也是部分可用的。方便&lt;span&gt;水平扩展，&lt;/span&gt;&lt;span&gt;可以根据业务规模可以随时加减配置。&lt;/span&gt;&lt;span&gt;据官方文档称可以线性扩展到上万个节点&lt;/span&gt;(&lt;span&gt;但是&lt;/span&gt;&lt;span&gt;官方推荐不超过&lt;/span&gt;1000个节点)。redis集群的性能和高可用性均优于哨兵模式&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1216484/202003/1216484-20200316235106740-2080813472.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Redis&lt;span&gt;集群搭建&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;1.&lt;span&gt;修改&lt;/span&gt;&lt;span&gt;redis.conf&lt;/span&gt;&lt;span&gt;配置文件&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;daemonize yes                    &lt;span&gt;后台启动   &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;cluster-enabled yes                &lt;span&gt;开启集群模式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;cluster-config-file nodes-6379.conf   &lt;span&gt;集群配置信息存放文件名&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;cluster-node-timeout 5000          &lt;span&gt;节点离线时间限制，到达此值时发起某个主从重新选举&lt;/span&gt;master&lt;/li&gt;
&lt;li&gt;protected-mode no                &lt;span&gt;关闭保护模式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;requirepass xxx                   &lt;span&gt;设置本机密码&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;masterauth xxx                    &lt;span&gt;设置访问别的机器的密码&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;justify&quot;&gt;2.&lt;span&gt;注意关闭服务器的防火墙，否则可能造成节点之间无法通信，无法搭建集群&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;使用修改好的配置文件启动&lt;/span&gt;redis&lt;span&gt;服务，我这里使用三个一主一从来搭建。因此先将&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;服务使用指定的配置文件&lt;/span&gt;&lt;span&gt;redis-master.conf&lt;/span&gt;&lt;span&gt;启动起来：&lt;/span&gt;&lt;span&gt;src/redis-server redis-master.conf&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;3.搭建集群服务&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;为了保险起见最好先检查下每台机器的&lt;/span&gt;redis&lt;span&gt;服务是否正常启动了&lt;/span&gt;&lt;span&gt;ps -ef|grep redis&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看见&lt;/span&gt;redis&lt;span&gt;服务进程后面有个&lt;/span&gt;&lt;span&gt;cluster&lt;/span&gt;&lt;span&gt;的标志，普通启动的&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;服务是没有这个标志的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1216484/202003/1216484-20200316235308264-673561116.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;justify&quot;&gt;5.0&lt;span&gt;版本可以直接使用&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;语言客户端提供的指令去构建集群：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;src/redis-cli -a xxx --cluster create --cluster-replicas 1 192.168.0.67:6379 192.168.0.68:6379 192.168.0.69:6379 192.168.0.70:6379 192.168.0.71:6379 192.168.0.72:6379&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;-a  &lt;span&gt;配置的密码&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;--cluster create  &lt;span&gt;表示集群创建&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;--cluster-replicas   &lt;span&gt;表示每个&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;几个&lt;/span&gt;&lt;span&gt;slave&lt;/span&gt;&lt;span&gt;，上面一共&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;节点，因此会构建三个一主一从。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行命令之前，如果你的&lt;/span&gt;redis&lt;span&gt;环境以前搭建过主从或者哨兵之类的，数据不干净可能会报错，最好将持久化文件删掉，然后&lt;/span&gt;&lt;span&gt;flushdb&lt;/span&gt;&lt;span&gt;，将以前脏数据清理掉，否则可能出现如下错误：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1216484/202003/1216484-20200316235503575-413362401.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; &lt;span&gt;正常执行会返回一个集群分配计划，我们按照它的计划即可：&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1216484/202003/1216484-20200316235517636-2138690956.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; &lt;span&gt;然后节点之间就开始通信构建集群，最后会看见&lt;/span&gt;16384&lt;span&gt;个&lt;/span&gt;&lt;span&gt;slots&lt;/span&gt;&lt;span&gt;分配完毕，可以看见构建计划中有三个&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;，每个&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;都是有指定槽位的。意思就是存入的&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;经过&lt;/span&gt;&lt;span&gt;crc16 hash&lt;/span&gt;&lt;span&gt;算法之后得到的值，在哪个范围内，就存储到那个&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;主从上面去，这就是&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;的分片集群模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1216484/202003/1216484-20200316235539913-1962110171.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 至此集群搭建完毕&lt;/p&gt;
&lt;p&gt;4.集群操作&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;以集群方式连接&lt;/span&gt;redis&lt;span&gt;客户端通过&lt;/span&gt;&lt;span&gt;cluster info&lt;/span&gt;&lt;span&gt;查看集群信息，通过&lt;/span&gt;&lt;span&gt;cluster nodes&lt;/span&gt;&lt;span&gt;查看节点信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;src/redis-cli -a 密码 -c   &lt;span&gt;集群方式连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1216484/202003/1216484-20200316235613686-1914558506.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;我们设置&lt;/span&gt;set abc 123&lt;span&gt;一个值 会看见客户点会计算&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;7638&lt;/span&gt;&lt;span&gt;， 然后重定向到对应的主从的&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;上面去写数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1216484/202003/1216484-20200316235732899-1800885311.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;现在我看下&lt;/span&gt;java&lt;span&gt;客户端的&lt;/span&gt;&lt;span&gt;jedis&lt;/span&gt;&lt;span&gt;里面的&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;值计算&lt;/span&gt;&lt;span&gt;redis.clients.util.JedisClusterCRC16#getSlot(java.lang.String)&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1216484/202003/1216484-20200316235750429-831342948.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;最后计算结果就会落到&lt;/span&gt;0-16383&lt;span&gt;之间去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当&lt;/span&gt; Redis Cluster &lt;span&gt;的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户 端要查找某个&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; &lt;span&gt;时，可以直接定位到目标节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需 要纠正机制来实现槽位信息的校验调整。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;集中式集群和分片式集群&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;Redis&lt;span&gt;节点之间使用的是&lt;/span&gt;&lt;span&gt;gossip&lt;/span&gt;&lt;span&gt;协议进行通信，每个节点之间都会互相通信。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;gossip&lt;span&gt;协议包含多种消息，包括&lt;/span&gt;&lt;span&gt;ping&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;pong&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;meet&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;fail&lt;/span&gt;&lt;span&gt;等等。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;ping&lt;span&gt;：每个节点都会频繁给其他节点发送&lt;/span&gt;&lt;span&gt;ping&lt;/span&gt;&lt;span&gt;，其中包含自己的状态还有自己维护的集群元数据，互相通过&lt;/span&gt;&lt;span&gt;ping&lt;/span&gt;&lt;span&gt;交换元数据；&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;pong: &lt;span&gt;返回&lt;/span&gt;&lt;span&gt;ping&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;meet&lt;/span&gt;&lt;span&gt;，包含自己的状态和其他信息，也可以用于信息广播和更新；&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;fail: &lt;span&gt;某个节点判断另一个节点&lt;/span&gt;&lt;span&gt;fail&lt;/span&gt;&lt;span&gt;之后，就发送&lt;/span&gt;&lt;span&gt;fail&lt;/span&gt;&lt;span&gt;给其他节点，通知其他节点，指定的节点宕机了。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;meet&lt;span&gt;：某个节点发送&lt;/span&gt;&lt;span&gt;meet&lt;/span&gt;&lt;span&gt;给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信，不需要发送形成网络的所需的所有&lt;/span&gt;&lt;span&gt;CLUSTER MEET&lt;/span&gt;&lt;span&gt;命令。发送&lt;/span&gt;&lt;span&gt;CLUSTER MEET&lt;/span&gt;&lt;span&gt;消息以便每个节点能够达到其他每个节点只需通 过一条已知的节点链就够了。由于在心跳包中会交换&lt;/span&gt;&lt;span&gt;gossip&lt;/span&gt;&lt;span&gt;信息，将会创建节点间缺失的链接。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;gossip&lt;span&gt;协议的优点在于元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新， 有一定的延时，降低了压力；缺点在于元数据更新有延时可能导致集群的一些操作会有一些滞后。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;就是自己提供服务的端口号&lt;/span&gt;+10000&lt;span&gt;，比如&lt;/span&gt;&lt;span&gt;6379&lt;/span&gt;&lt;span&gt;，那么用于节点间通信 的就是&lt;/span&gt;&lt;span&gt;16379&lt;/span&gt;&lt;span&gt;端口。 每个节点每隔一段时间都会往另外几个节点发送&lt;/span&gt;&lt;span&gt;ping&lt;/span&gt;&lt;span&gt;消息，同时其他几点接收到&lt;/span&gt;&lt;span&gt;ping&lt;/span&gt;&lt;span&gt;消息之后返回&lt;/span&gt;&lt;span&gt;pong&lt;/span&gt;&lt;span&gt;消息。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;还有就是集中式的，比如&lt;/span&gt;ZK&lt;span&gt;集群&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;集中式的有点在于数据的更新和读取，时效性非常好，一旦元数据出现变更立即就会更新到集中式（&lt;/span&gt;master&lt;span&gt;）的存储中，其他节点读取的 时候立即就可以立即感知到；不足在于所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储压力。&lt;/span&gt;&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;&lt;span&gt;Redis&lt;span&gt;集群选举机制&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当&lt;/span&gt;slave发现自己的master变为FAIL状态时，便尝试&lt;span&gt;发起选举&lt;/span&gt;&lt;span&gt;，以期成为新的&lt;/span&gt;master。由于挂掉的master可能会有&lt;span&gt;多个&lt;/span&gt;slave，从而存在多个slave竞争成为master节点的过程， 其过程如下：&lt;/p&gt;

&lt;p&gt;1.slave发现自己的master变为FAIL&lt;/p&gt;

&lt;p&gt;2.将自己记录的集群currentEpoch（选举轮次标记）加1，并广播信息给集群中其他节点&lt;/p&gt;

&lt;p&gt;3.其他节点收到该信息，只有master响应，判断请求者的合法性，并发送结果&lt;/p&gt;

&lt;p&gt;4.尝试选举的slave收集master返回的结果，收到&lt;span&gt;超过半数&lt;/span&gt;master的统一&lt;span&gt;后变成新&lt;/span&gt;Master&lt;/p&gt;

&lt;p&gt;5.广播Pong消息通知其他集群节点。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果这次选举不成功，比如三个小的主从&lt;/span&gt;A,B,C组成的集群，A的master挂了，A的两个小弟发起选举，结果B的master投给A的小弟A1，C的master投给了A的小弟A2，这样就会发起第二次选举，选举轮次标记+1继续上面的流程。事实上从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票。 同时下面公式里面的随机数，也可以有效避免slave同时发起选举，导致的平票情况。&lt;/p&gt;

&lt;p&gt;•延迟计算公式：&lt;/p&gt;

&lt;p&gt;DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms&lt;/p&gt;

&lt;p&gt;•SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。&lt;/p&gt;



&lt;p&gt;&lt;span&gt;前面说到这种分片的集群模式的集群可以部分提供服务，&lt;/span&gt;&lt;span&gt;当&lt;/span&gt;redis.conf的配置cluster-require-full-coverage为no时，&lt;span&gt;表示当一个小主从整体挂掉的时候集群也可以用，也是说&lt;/span&gt;0-16383个槽位中，落在该主从对应的slots上面的key是用不了的，但是如果key落在其他的范围是仍然可用的。&lt;/p&gt;





&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Mon, 16 Mar 2020 16:03:00 +0000</pubDate>
<dc:creator>白露非霜</dc:creator>
<og:description>redis集群简述 哨兵模式中如果主从中master宕机了，是通过哨兵来选举出新的master，在这个选举切换主从的过程，整个redis服务是不可用的。而且哨兵模式中只有一个主节点对外提供服务，因此没</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nijunyang/p/12508098.html</dc:identifier>
</item>
<item>
<title>计算机网络 - 数据链路层 - 农夫三拳有点疼~</title>
<link>http://www.cnblogs.com/songjilong/p/12508056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songjilong/p/12508056.html</guid>
<description>&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;
&lt;h3 id=&quot;数据发送模型&quot;&gt;数据发送模型：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200312172149.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据链路层的信道类型&quot;&gt;数据链路层的信道类型：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;点对点信道：这种信道使用一对一的点对点通信方式。&lt;/li&gt;
&lt;li&gt;广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;链路和数据链路&quot;&gt;链路和数据链路：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;链路（link）:是一条点到点的物理线路段，中间没有任何其他的点，&lt;strong&gt;一条链路只是一条通路的一个组成部分&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;数据链路(data link)：除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。
&lt;ul&gt;&lt;li&gt;现最常用的方法是使用适配器(即网卡)来实现这些协议的硬件和&lt;br/&gt;软件。&lt;/li&gt;
&lt;li&gt;一般的适配器都包括了数据链路层和物理层这两层的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;帧&quot;&gt;帧：&lt;/h3&gt;
&lt;p&gt;数据链路层传送的是帧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200312173214.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据链路层就像一个数字管道&quot;&gt;数据链路层就像一个数字管道&lt;/h3&gt;
&lt;p&gt;常常在两个对等的数据链路层之间画出一个数字管道，而在这条数字管道上传输的数据单位是帧。&lt;/p&gt;
&lt;h2 id=&quot;要解决的三个基本问题&quot;&gt;要解决的三个基本问题&lt;/h2&gt;
&lt;h3 id=&quot;封装成帧&quot;&gt;封装成帧&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧，用以确定帧的界限。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首部和尾部的一个重要作用就是进行帧定界。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果发送端发送时出现故障，接收端没收到完整的头和尾，就会将帧丢掉&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200312173853.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;透明传输&quot;&gt;透明传输&lt;/h3&gt;
&lt;p&gt;若传输的数据是ASCI I码中“可打印字符(共95个)”集时，一切正常。&lt;br/&gt;若传输的数据不是仅由“可打印字符”组成时，就会出问题，如下图&lt;br/&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200312174904.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;strong&gt;字节填充法&lt;/strong&gt;解决透明传输的问题：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个字符“ESC” (其十六进制编码是1B)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果转义字符也出现数据当中，那么应在转义字符前插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200312175652.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;差错控制&quot;&gt;差错控制&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;传输过程中可能会产生&lt;strong&gt;比特差错&lt;/strong&gt;:1可能会变成0而0也可能变成1。&lt;/li&gt;
&lt;li&gt;在一段时间内，传输错误的比特占所传输比特总数的比率称为 &lt;strong&gt;误码率&lt;/strong&gt; BER (Bit Error Rate) 。&lt;/li&gt;
&lt;li&gt;误码率与信噪比有很大的关系。&lt;/li&gt;
&lt;li&gt;为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以使用 &lt;strong&gt;循环冗余检测&lt;/strong&gt; &lt;strong&gt;CRC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200312181331.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仅用循环冗余检验CRC差错检测技术只能做到&lt;strong&gt;无差错接受&lt;/strong&gt;(accept)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“无差错接受” 是指：“凡是接受的帧( 即不包括丢弃的帧)，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。也就是说:“凡是接收端数据链路层接受的帧都没有传输差错”(有差错的帧就丢弃而不接受)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要做到 “可靠传输” (即发送 什么就收到什么)就必须再加上确认和重传机制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;考虑:帧重复、帧丢失、帧乱序的情况&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以说 “CRC是一种无比特差错，而不是无传输差错的检测机制”&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OSI/RM模型的观点:数据链路层要做成无传输差错的，但这种理念目前不被接受!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;ppp协议&quot;&gt;PPP协议&lt;/h2&gt;
&lt;p&gt;现在全世界使用的最多的数据链路层协议就是 &lt;strong&gt;点对点协议&lt;/strong&gt; 即 &lt;strong&gt;PPP协议(Pointer to Pointer Protocol)&lt;/strong&gt;，用户使用拨号电话线接入因特网时，一般都是使用PPP协议。&lt;/p&gt;
&lt;h2 id=&quot;ppp协议的使用场合&quot;&gt;PPP协议的使用场合&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200313213420.png&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;简单——这是首要的要求&lt;/td&gt;
&lt;td&gt;纠错&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;封装成帧&lt;/td&gt;
&lt;td&gt;流量控制&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;透明性&lt;/td&gt;
&lt;td&gt;序号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;多种类型链路&lt;/td&gt;
&lt;td&gt;多点线路&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;差错检测&lt;/td&gt;
&lt;td&gt;半双工或单工链路&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;检测连接状态&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;最大传送单元&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;网络层地址协商&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;数据压缩协商&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;ppp协议的组成&quot;&gt;PPP协议的组成&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据链路层协议可以用于异步串行或同步串行介质。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;它使用LCP (链路控制协议)建立并维护数据链路连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;网络控制协议(NCP)允许在点到点连接上使用多种网络层协议，如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200313215356.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;ppp协议帧格式&quot;&gt;PPP协议帧格式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200313223120.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;字节填充&quot;&gt;字节填充&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;问题:信息字段中出现了标志字段的值，可能会被误认为是“标志位”怎么办?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将信息字段中出现的每个0x7E字节转变成为2字节序列(0x7D，0x5E)。&lt;/li&gt;
&lt;li&gt;若信息字段中出现一个0x7D的字节，则将其转变成为2字节序列(0x7D，0x5D)。&lt;/li&gt;
&lt;li&gt;若信息字段中出现ASCII 码的控制字符(即数值小于0x20的字符)，则在该字符前面要加入一个0x7D字节，同时将该字符的编码加以改变。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200313223504.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;零比特填充&quot;&gt;零比特填充&lt;/h2&gt;
&lt;p&gt;PPP 协议用在 SONET/SDH 链路时，使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。&lt;br/&gt;在发送端，只要发现有 &lt;strong&gt;5 个连续 1&lt;/strong&gt;，则立即&lt;strong&gt;填入一个0&lt;/strong&gt;。&lt;br/&gt;接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 &lt;strong&gt;5 个连续 1 后的一个 0 删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200313223650.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ppp协议工作状态&quot;&gt;PPP协议工作状态&lt;/h2&gt;
&lt;p&gt;当用户拨号接入ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。&lt;br/&gt;PC机向路由器发送一系列的LCP分组(封装成多个PPP帧)。&lt;br/&gt;这些分组及其响应选择一些PPP参数，和进行网络层配置，NCP给新接入的PC机分配一个临时的IP地址，使PC机成为因特网上的一个主机。&lt;br/&gt;通信完毕时，NCP 释放网络层连接，收回原来分配出去的IP地址。接着，LCP释放数据链路层连接。最后释放的是物理层的连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200314221850.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;局域网的拓扑&quot;&gt;局域网的拓扑&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200315113905.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;局域网的特点与优点&quot;&gt;局域网的特点与优点&lt;/h2&gt;
&lt;p&gt;局域网最主要的特点是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网络为一个单位所拥有，且地理范围和站点数目均有限。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;局域网具有如下的一些主要优点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。&lt;/li&gt;
&lt;li&gt;便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。&lt;/li&gt;
&lt;li&gt;提高了系统的可靠性、可用性和生存性。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;共享通信媒体&quot;&gt;共享通信媒体&lt;/h2&gt;
&lt;h3 id=&quot;静态划分信道&quot;&gt;静态划分信道&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;频分复用&lt;/li&gt;
&lt;li&gt;时分复用&lt;/li&gt;
&lt;li&gt;波分复用&lt;/li&gt;
&lt;li&gt;码分复用&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;动态媒体接入控制多点接入&quot;&gt;动态媒体接入控制（多点接入）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;随机接入(主要被以太网采用! )&lt;/li&gt;
&lt;li&gt;受控接入，如多点线路探询(polling)，或轮询。(目前已不被采用)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;认识以太网&quot;&gt;认识以太网&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;最初的以太网是将许多计算机都连接到一根总线上。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。但是不安全，有可能被非目标计算机抓包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200315115342.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总线上的每一个工作的计算机都能检测到B发送的数据信号。&lt;br/&gt;由于只有计算机D的地址与数据帧首部写入的地址一致，因此只有D才接收这个数据帧。&lt;br/&gt;其他所有的计算机(A,C和E)都检测到不是发送给它们的数据帧,因此就丢弃这个数据帧而不能够收下来。&lt;br/&gt;具广播特性的总线上实现了一对一的通信。&lt;/p&gt;
&lt;h2 id=&quot;载波监听多点接入碰撞检测-csmacd协议&quot;&gt;载波监听多点接入/碰撞检测 （CSMA/CD）协议&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;CSMA/CD表示Carrier Sense Multiple Access with Collision Detection。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;载波监听多点接入&quot;&gt;载波监听多点接入&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;“多点接入”&lt;/strong&gt;表示许多计算机以多点接入的方式连接在一根总线上。&lt;br/&gt;&lt;strong&gt;“载波监听”&lt;/strong&gt;是指每一个站在发送数据之前先要检测一下总线 上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生&lt;br/&gt;碰撞。“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。&lt;/p&gt;
&lt;h3 id=&quot;碰撞检测&quot;&gt;碰撞检测&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316141740.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“碰撞检测” 就是计算机边发送数据边检测信道上的信号电压大小&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)&lt;/li&gt;
&lt;li&gt;当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了&lt;strong&gt;碰撞&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为&lt;strong&gt;“冲突检测”&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;检测到碰撞后：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;争用期&quot;&gt;争用期&lt;/h3&gt;
&lt;p&gt;最先发送数据帧的站，在发送数据帧后至多经过时间&lt;strong&gt;2τ&lt;/strong&gt; ( 两倍的端到端的往返时延)就可知道发送的数据帧是否遭受了碰撞。&lt;strong&gt;经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;以太网的争用期&quot;&gt;以太网的争用期&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;以太网的端到端往返时延2τ称为争用期，或碰撞窗口。通常，取51.2 μs为争用期的长度。&lt;/li&gt;
&lt;li&gt;对于10 Mb/s以太网，在争用期内可发送512 bit, 即64字节。&lt;/li&gt;
&lt;li&gt;以太网在发送数据时，若前64字节未发生冲突，则后续的数据就不会发生冲突。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;最短有效帧长&quot;&gt;最短有效帧长&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;如果发生冲突，就一定是在发送的前&lt;strong&gt;64字节之内&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于64字节。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以太网&lt;/strong&gt;规定了&lt;strong&gt;最短有效帧长为64字节&lt;/strong&gt;，凡长度小于64字节的帧都是由于冲突而异常中止的无效帧。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;二进制指数类型退避算法&quot;&gt;二进制指数类型退避算法&lt;/h3&gt;
&lt;p&gt;发生碰撞的站在停止发送数据后，要推迟(退避) 一个随机时间才能再发送数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确定基本退避时间，一般是取为争用期2τ。&lt;/li&gt;
&lt;li&gt;定义参数k，k = Min[重传次数， 10]&lt;/li&gt;
&lt;li&gt;从整数集合[0，1，...，(2^k -1)]中随机地取出一个数，记为 г 。&lt;br/&gt;重传所需的时延就是r倍的基本退避时间。当重传达16次仍不能成功时即丢弃该帧，并向高层报告。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;以太网的两个标准&quot;&gt;以太网的两个标准&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;DIX Ethernet V2 是世界上第一个局域网产品(以太网)的规约&lt;/li&gt;
&lt;li&gt;IEEE 的802.3标准。
&lt;ul&gt;&lt;li&gt;DIX Ethernet V2标准与IEEE 的802. 3标准只有很小的差别，因此可以将802. 3局域网简称为&lt;strong&gt;“以太网”&lt;/strong&gt;。严格说来，“以太网” 应当是指符合DIX Ethernet V2标准的局域网。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;以太网与数据链路层的两个子层&quot;&gt;以太网与数据链路层的两个子层&lt;/h2&gt;
&lt;p&gt;为了使数据链路层能更好地适应多种局域网标准，802委员会就将局域网的数据链路层拆成两个子层:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;逻辑链路控制LLC (Logical Link Control)子层&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;媒体接入控制MAC (Medium Access Control)子层。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与接入到传输媒体有关的内容都放在MAC子层，而LLC子层则与传输媒体无关，不管采用何种协议的局域网对LLC子层来说都是透明的。&lt;/p&gt;
&lt;p&gt;由于TCP/IP体系经常使用的局域网是DIX Ethernet V2而不是802.3标准中的几种局域网，因此现在802委员会制定的逻辑链路控制子层LLC (即802. 2标准)的作用已经不大了。很多厂商生产的适配器上就仅装有&lt;strong&gt;MAC协议&lt;/strong&gt;而没有LLC 协议。&lt;/p&gt;
&lt;h2 id=&quot;星型拓扑&quot;&gt;星型拓扑&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。不用电缆而使用无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收。&lt;br/&gt;这种以太网采用&lt;strong&gt;星形拓扑&lt;/strong&gt;，在星形的中心则增加了一种可靠性非常高的设备,&lt;br/&gt;叫做&lt;strong&gt;集线器(hub)&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316143941.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;集线器的一些特点&quot;&gt;集线器的一些特点：&lt;/h3&gt;
&lt;p&gt;集线器是使用电子器件来模拟实际电缆线的工作，&lt;strong&gt;因此整个系统仍然像一个传统的以太网那样运行&lt;/strong&gt;。集线器使用了大规模集成电路芯片，因此这样的硬件设备的可靠性已大大提高了。&lt;/p&gt;
&lt;p&gt;使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是&lt;strong&gt;CSMA/CD协议&lt;/strong&gt;，并共享逻辑上的总线。&lt;/p&gt;
&lt;p&gt;集线器很像一个多接口的转发器，&lt;strong&gt;工作在物理层&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316144454.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;以太网的信道利用率&quot;&gt;以太网的信道利用率&lt;/h2&gt;
&lt;p&gt;以太网的信道被占用的情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;争用期长度为2τ,即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。&lt;/li&gt;
&lt;li&gt;帧长为L (bit)， 数据发送速率为C (b/s)，因而帧的发送时间为L/C = T₀ (s)&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲(即再经过时间τ使 得信道上无信号在传播)时为止，是发送一帧所需的平均时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316145321.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;以太网的信道利用率参数a&quot;&gt;以太网的信道利用率：参数a&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;要提高以太网的信道利用率，就必须减小 τ 与 T₀ 之比。在以太网中定义了参数a，它是以太网单程端到端时延τ与帧的发送时间 T₀ 之比: $$a = \frac τ {T₀}$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;a- &amp;gt;0表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;a越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;以太网的信道利用率最大值&quot;&gt;以太网的信道利用率：最大值&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;对以太网参数的要求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信道利用率的最大值&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在理想化的情况下，以太网上的各站发送数据都不会产生碰撞(这显然&lt;br/&gt;已经不是CSMA/CD， 而是需要使用一种特殊的调度方法)，即总线一旦&lt;br/&gt;空闲就有某一个站立即发送数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;发送一帧占用线路的时间是 T₀+ t，而帧本身的发送时间是 T₀，于是&lt;br/&gt;我们可计算出理想情况下的极限信道利用率$S_{max}$为:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316150948.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mac层的硬件地址mac地址&quot;&gt;MAC层的硬件地址（MAC地址）&lt;/h2&gt;
&lt;p&gt;在局域网中，&lt;strong&gt;硬件地址&lt;/strong&gt;又称为&lt;strong&gt;物理地址&lt;/strong&gt;，或 &lt;strong&gt;MAC地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;802 标准所说的 “地址” 严格地讲应当是每一个站的 “&lt;strong&gt;名字&lt;/strong&gt;” 或 &lt;strong&gt;标识符&lt;/strong&gt;。但鉴于大家都早已习惯了将这种48位的“名字”称为“地址”，所以本文也采用这种习惯用法，尽管这种说法并不太严格。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IEEE的注册管理机构RA负责向厂家分配地址字段的前三个字节(即高位24位)。&lt;/li&gt;
&lt;li&gt;地址字段中的后三个字节(即低位24位)由厂家自行指派，称为&lt;strong&gt;扩展标识符&lt;/strong&gt;，必须保证生产出的适配器没有重复地址。&lt;/li&gt;
&lt;li&gt;一个地址块可以生成2²⁴个不同的地址。这种&lt;strong&gt;48位&lt;/strong&gt;地址称为MAC- 48，它的通用名称是EUI-48。&lt;/li&gt;
&lt;li&gt;“MAC地址” 实际上就是适配器地址或适配器标识符EUI-48。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在同一个交换机上的计算机MAC地址不可相同，否则会产生网络故障，MAC地址可以手动修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;适配器检查-mac-地址&quot;&gt;适配器检查 MAC 地址&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;适配器从网络上每收到一个MAC帧就首先用硬件检查MAC帧中的MAC地址&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是发往本站的帧则收下，然后再进行其他的处理。&lt;/li&gt;
&lt;li&gt;否则就将此帧丢弃，不再进行其他的处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;“发往本站的帧”包括以下三种帧:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单播(unicast)帧(一对一 )&lt;/li&gt;
&lt;li&gt;广播(broadcast)帧(一对全体)&lt;/li&gt;
&lt;li&gt;多播(multicast)帧(一对多)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mac-帧格式&quot;&gt;MAC 帧格式&lt;/h2&gt;
&lt;p&gt;常用的以太网MAC帧格式有两种标准：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;DIX Ethernet V2 标准&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IEEE 的 802.3 标准&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最常用的MAC帧是&lt;strong&gt;以太网V2&lt;/strong&gt;的格式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316153643.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;无效的-mac-帧&quot;&gt;无效的 MAC 帧&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;帧的长度不是整数个字节;&lt;/li&gt;
&lt;li&gt;用收到的帧检验序列FCS 查出有差错;&lt;/li&gt;
&lt;li&gt;数据字段的长度不在 46 ~ 1500 字节之间。&lt;/li&gt;
&lt;li&gt;有效的MAC帧长度为 64 ~ 1518 字节之间。&lt;/li&gt;
&lt;li&gt;对于检查出的无效MAC帧就简单地丢弃。以太网不负责重传丢弃的帧。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;帧间最小间隔&quot;&gt;帧间最小间隔&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;帧间最小间隔为9.6 μs,相当于96 bit的发送时间。&lt;/li&gt;
&lt;li&gt;一个站在检测到总线开始空闲后，还要等待9.6 μs才能再次发送数据。&lt;/li&gt;
&lt;li&gt;这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;在物理层考虑扩展&quot;&gt;在物理层考虑扩展&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;主机使用光纤和一对光纤调制解调器连接到集线器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316215523.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用一个集线器连接多个集线器（数量不宜超过30台计算机，连接越多，效率越低）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316220050.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在数据链路层考虑扩展&quot;&gt;在数据链路层考虑扩展&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在数据链路层扩展局域网是使用&lt;strong&gt;网桥&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;网桥工作在数据链路层，它根据&lt;strong&gt;MAC帧的目的地址&lt;/strong&gt;对收到的帧进行转发。&lt;/li&gt;
&lt;li&gt;网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是&lt;strong&gt;先检查&lt;/strong&gt;此帧的目的MAC地址，然后&lt;strong&gt;再确定&lt;/strong&gt;将该帧转发到哪一个接口。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;网桥的内部结构&quot;&gt;网桥的内部结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/songjilong/p/assets/image-20200316220739181.png&quot; alt=&quot;image-20200316220739181&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用网桥扩展以太网&quot;&gt;使用网桥扩展以太网&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316221141.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;网桥扩展以太网的优缺点&quot;&gt;网桥扩展以太网的优缺点&lt;/h3&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;过滤通信量。&lt;/li&gt;
&lt;li&gt;扩大了物理范围。&lt;/li&gt;
&lt;li&gt;提高了可靠性。&lt;/li&gt;
&lt;li&gt;可互连不同物理层、不同MAC子层和不同速率(如10 Mb/s和100Mb/s以太网)的局域网。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;存储转发增加了时延。&lt;/li&gt;
&lt;li&gt;在MAC子层并没有流量控制功能。&lt;/li&gt;
&lt;li&gt;具有不同MAC子层的网段桥接在一起时时延更大。&lt;/li&gt;
&lt;li&gt;网桥只适合于&lt;strong&gt;用户数不太多&lt;/strong&gt;(不超过几百个)和&lt;strong&gt;通信量不太大&lt;/strong&gt;的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;透明网桥&quot;&gt;透明网桥&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;目前使用得最多的网桥是&lt;strong&gt;透明网桥&lt;/strong&gt;(transparent br idge)。&lt;/li&gt;
&lt;li&gt;“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，&lt;strong&gt;因为网桥对各站来说是看不见的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;透明网桥是一种&lt;strong&gt;即插即用设备&lt;/strong&gt;，其标准是IEEE 802.1D&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316222743.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;网桥的自学习算法&quot;&gt;网桥的自学习算法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;若从 A 发出的帧从接口 x 进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到 A 。&lt;/li&gt;
&lt;li&gt;网桥每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。&lt;/li&gt;
&lt;li&gt;在建立转发表时是把帧首部中的源地址写在 “地址” 这一栏的下面。&lt;/li&gt;
&lt;li&gt;在转发帧时，则是根据收到的帧首部中的目的地址来转发的。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;用交换机扩展以太网&quot;&gt;用交换机扩展以太网&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316224129.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;虚拟局域网&quot;&gt;虚拟局域网&lt;/h2&gt;
&lt;h3 id=&quot;lan和vlan&quot;&gt;LAN和VLAN&lt;/h3&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;交换机的使用使得VLAN的创建成为可能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;虛拟局域网VLAN是由一些局域网网段构成的与物理位置无关的逻辑组。
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;这些网段具有某些共同的需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;每一个VLAN的帧都有-个明确的标识符，指明发送这个帧的工作站是属于哪一个VLAN。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316230316.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316231731.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316232359.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;虚拟局域网枕格式&quot;&gt;虚拟局域网枕格式&lt;/h3&gt;
&lt;p&gt;虚拟局域网协议允许在以太网的帧格式中插入一个4字节的标识符，称为VLAN 标记(tag)，用来指明发送该帧的工作站属于哪一个虚拟局域网。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/songjilong/FigureBed/raw/master/img/20200316232731.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;base-t&quot;&gt;100BASE-T&lt;/h2&gt;
&lt;p&gt;速率达到或超过&lt;strong&gt;100 Mb/s&lt;/strong&gt;的以太网称为&lt;strong&gt;高速以太网&lt;/strong&gt;。&lt;br/&gt;在双绞线上传送100 Mb/s基带信号的星型拓扑以太网，仍使用IEEE 802. 3的CSMA/CD协议。100BASE T以太网又称为&lt;strong&gt;快速以太网&lt;/strong&gt;(Fast Ethernet) 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可在全双工方式下工作而无冲突发生。因此，不使用CSMA/CD 协议。MAC帧格式仍然是802.3标准规定的。&lt;/li&gt;
&lt;li&gt;保持最短帧长不变，但将一个网段的最大电缆长度减小到100 m。帧间时间间隔从原来的9.6 μs改为现在的0. 96 μs。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;吉比特以太网&quot;&gt;吉比特以太网&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;允许在1 Gb/s 下全双工和半双工两种方式工作。&lt;/li&gt;
&lt;li&gt;使用802. 3协议规定的帧格式。&lt;/li&gt;
&lt;li&gt;在半双工方式下使用CSMA/CD协议(全双工方式不需要使用CSMA/CD协议)&lt;/li&gt;
&lt;li&gt;与10BASE-T和100BASE- T技术向后兼容。&lt;/li&gt;
&lt;li&gt;当吉比特以太网工作在全双工方式时(即通信双方可同时进行发送和接收数据)，不使用载波延伸和分组突发。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 16 Mar 2020 15:53:00 +0000</pubDate>
<dc:creator>农夫三拳有点疼~</dc:creator>
<og:description>数据链路层概述 基本概念 数据发送模型： 数据链路层的信道类型： 点对点信道：这种信道使用一对一的点对点通信方式。 广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/songjilong/p/12508056.html</dc:identifier>
</item>
<item>
<title>什么是梯度下降 - Yabea</title>
<link>http://www.cnblogs.com/ybjourney/p/12508027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybjourney/p/12508027.html</guid>
<description>&lt;p&gt;梯度下降（Gradient Descent GD）简单来说就是一种寻找目标函数最小化的方法，它利用梯度信息，通过不断迭代调整参数来寻找合适的目标值。 本文将介绍它的原理和实现。&lt;/p&gt;
&lt;h2 id=&quot;什么是梯度&quot;&gt;什么是梯度？&lt;/h2&gt;
&lt;p&gt;关于梯度的引入，可以分为四个概念：导数 -》偏导数 -》方向导数 -》 梯度。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AF%BC%E6%95%B0&quot;&gt;导数&lt;/a&gt;：当函数定义域和取值都在实数域中的时候，导数可以表示函数曲线上的切线斜率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/771535/202003/771535-20200316234252025-1819658123.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%81%8F%E5%AF%BC%E6%95%B0&quot;&gt;偏导数&lt;/a&gt;：偏导其实就是多元函数一个多变量的函数的偏导数是它关于其中一个变量的导数，而保持其他变量恒定。因为曲面上的每一点都有无穷多条切线，描述这种函数的导数相当困难。偏导数就是选择其中一条切线，并求出它的斜率 。几何意义是表示固定面上一点的切线斜率。&lt;/p&gt;
&lt;p&gt;多元函数降维时候的变化，比如二元函数固定y，只让x单独变化，从而看成是关于x的一元函数的变化来研究。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=f_%7Bx%7D+%28x%2Cy%29&quot; alt=&quot;[公式]&quot;/&gt;指的是函数在y方向不变，函数值沿着x轴方向的变化率&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=f_%7By%7D+%28x%2Cy%29&quot; alt=&quot;[公式]&quot;/&gt;指的是函数在x方向不变，函数值沿着y轴方向的变化率&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/771535/202003/771535-20200316234325721-943066119.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是偏导数有一个缺点，就是只能表示多元函数沿坐标轴方向的变化率，但是很多时候要考虑多元函数沿任意方向的变化率，于是就有了方向导数。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0&quot;&gt;方向导数&lt;/a&gt;：某个方向的导数，本质就是函数在A点上无数个切线的斜率的定义，每个切线都代表一个方向，每个方向都是有方向导数的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/771535/202003/771535-20200316234341520-501306843.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;梯度&lt;/strong&gt;：梯度是一个矢量，在其方向上的方向导数最大，也就是函数在该点处沿着梯度的方向变化最快，变化率最大。&lt;/p&gt;
&lt;p&gt;那么在机器学习中逐步逼近、迭代求解最优化时，经常会使用到梯度，沿着梯度向量的方向是函数增加的最快，更容易找到函数的最大值，反过来，沿着梯度向量相反的地方，梯度减少的最快，更容易找到最小值。&lt;/p&gt;
&lt;h2 id=&quot;什么是梯度下降&quot;&gt;什么是梯度下降&lt;/h2&gt;
&lt;p&gt;举个常见的例子：你站在山上某处，想要尽快下山，于是决定走一步算一步，也就是每走到一个位置时，求解当前位置的梯度，沿着梯度的负方向，也就是当前最陡峭的位置向下走，这样一直走下去，很可能走不到山脚，而是某个局部的山峰最低处。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;c:/Users/Dell/AppData/Local/Temp/1584274080296.png&quot; alt=&quot;1584274080296&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/771535/202003/771535-20200316234407961-1175170079.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上，我们可以总结一下：梯度下降法就是沿着梯度下降的方向求解极小值，沿着梯度上升的方向可以求得最大值，这种方法叫梯度上升。&lt;/p&gt;
&lt;p&gt;从上图可以看到：受到起始点和目标函数特性的影响，梯度下降不一定找到的是全局最优解，可能只是局部最优解，那么什么时候能找到全局最优解呢？这个与损失函数有关，当损失函数是凸函数的话，可以找到全局最优。&lt;/p&gt;
&lt;h3 id=&quot;一些重要概念&quot;&gt;一些重要概念&lt;/h3&gt;
&lt;p&gt;根据上述梯度下降的求解原理，我们需要了解如下几个梯度下降相关的重要概念：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步长&lt;/strong&gt;（Learning rate）：每一步梯度下降时向目标方向前行的长度,用上面下山的例子，步长就是在当前这一步所在位置沿着最陡峭最易下山的位置走的那一步的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设函数&lt;/strong&gt;（hypothesis function） &lt;strong&gt;：&lt;/strong&gt;在监督学习中，为了拟合输入样本，而使用的假设函数，常用h()表示，对于线性回归模型，假设函数就是函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Y = W_0 + W_1X1 + W_2X2 + ... + W_nX_n \]&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;损失函数&lt;/strong&gt;（loss function）： 常用J()表示，为了评估模型的好坏，通常用损失函数来度量拟合的程度。损失函数最小化，意味着拟合程度最好，对应的模型参数即为最优参数。每个机器学习模型都有一个损失函数，学习的目的就是将损失函数最小化，&lt;/p&gt;
&lt;h3 id=&quot;算法详解&quot;&gt;算法详解&lt;/h3&gt;
&lt;p&gt;梯度下降的具体算法实现过程是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;确定模型的假设函数和损失函数&lt;/li&gt;
&lt;li&gt;相关参数的初始化，包括：参数、算法终止距离和步长&lt;/li&gt;
&lt;li&gt;确定当前位置损失函数的梯度&lt;/li&gt;
&lt;li&gt;用步长乘以梯度，得到当前位置下降的距离&lt;/li&gt;
&lt;li&gt;确定是否所有参数梯度下降的距离都小于算法终止距离，如果小于则算法终止，否则进行下一步&lt;/li&gt;
&lt;li&gt;更新所有参数，更新完毕转到步骤1&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;面临的问题&quot;&gt;面临的问题&lt;/h3&gt;
&lt;p&gt;梯度下降会遇到所有最优化问题中常见的两个问题：局部最小值和鞍点。&lt;/p&gt;
&lt;h4 id=&quot;局部最小值&quot;&gt;局部最小值&lt;/h4&gt;
&lt;p&gt;这是梯度下降法最常遇到的一个问题，当一个函数存在多个局部最小值，很可能梯度下降法只是找到其中的一个局部最小值而停止。&lt;/p&gt;
&lt;p&gt;怎么避免呢？&lt;/p&gt;
&lt;p&gt;下山的例子中，我们看到初始值不同，获得的最小值可能不同，所以规避局部最小值最简单的方法可以多次用不同的初始值执行算法，选择损失函数最小的初始值。&lt;/p&gt;
&lt;h4 id=&quot;鞍点&quot;&gt;鞍点&lt;/h4&gt;
&lt;p&gt;鞍点是最优化问题中常遇到的一个现象，鞍点的数学含义是：目标函数在此点的梯度为0，但从该点出发的一个方向存在函数极大值点，而另一个方向是函数的极小值点。典型的鞍点函数是典型的鞍点是函数 f(x)=x^3 中的(0,0)，函数 z=x^2-y^2 的 多个鞍点 (0,0,0)，(1,1,0)，(2,2,0)) 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/771535/202003/771535-20200316234632760-1721690823.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在高度非凸空间中，存在大量的鞍点，这使得梯度下降法有时会失灵，虽然不是极小值，但是看起来确是收敛的。&lt;/p&gt;
&lt;h3 id=&quot;调优&quot;&gt;调优&lt;/h3&gt;
&lt;p&gt;从算法的执行步骤来看，需要调优的地方包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;步长：不同的场景中步长的选择需要实验和权衡，步长越长，迭代越快，有可能错过最优解，步长太小，迭代速度太慢，很长时间算法都不能结束。所以算法的步长需要多次运行后才能得到一个较为优的值。&lt;/li&gt;
&lt;li&gt;初始值：初始值不同，最终得到的最小值有可能不同，可能获得的只是局部最小值；当然如果损失函数是凸函数则一定是最优解。需要多次用不同初始值运行算法，选择损失函数最小化的初值。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;常见的梯度下降法&quot;&gt;常见的梯度下降法&lt;/h2&gt;
&lt;h3 id=&quot;批量梯度下降batch-gradient-descent-bgd&quot;&gt;批量梯度下降（Batch Gradient Descent BGD）&lt;/h3&gt;
&lt;p&gt;上面所介绍的算法其实就是批量梯度下降。需要首先计算所有数据上的损失值，然后再进行梯度下降，具体的操作步骤是：遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数，都要把数据集里的所有样本计算一遍，计算量大，计算速度慢，不支持在线学习。&lt;/p&gt;
&lt;h3 id=&quot;随机梯度下降stochastic-gradient-descent-sgd&quot;&gt;随机梯度下降（Stochastic Gradient Descent SGD）&lt;/h3&gt;
&lt;p&gt;不使用全量的样本来计算梯度，而使用单一样本来近似估计梯度，可以极大地减少计算量，提高计算效率。具体的操作步骤是：每次从训练集中随机选择一个样本，计算其对应的损失和梯度，进行参数更新，反复迭代。&lt;/p&gt;
&lt;p&gt;这种方式在数据规模比较大时可以减少计算复杂度，从概率意义上来说的单个样本的梯度是对整个数据集合梯度的无偏估计，但是它存在着一定的不确定性，因此收敛速率比批梯度下降得更慢。&lt;/p&gt;
&lt;h3 id=&quot;小批量梯度下降mini-batch-gradient-descent&quot;&gt;小批量梯度下降（Mini-batch Gradient Descent）&lt;/h3&gt;
&lt;p&gt;为了克服上面两种方法的缺点，采用的一种折中手段：将数据分为若干批次，按批次更新参数，每一批次中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性，另一方面，因为批的样本数比整个数据集少了很多，计算量也不是很大。&lt;/p&gt;
&lt;p&gt;每次使用多个样本来估计梯度，这样可以减少不确定性，提高收敛速率，其中每次迭代选取的样本数量称为批大小（batch size）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/305638940/answer/606831354&quot;&gt;什么是梯度下降法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24913912&quot;&gt;为什么梯度反方向是函数值局部下降最快的方向？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/pinard/p/5970503.html&quot;&gt;梯度下降小结&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Mar 2020 15:45:00 +0000</pubDate>
<dc:creator>Yabea</dc:creator>
<og:description>本文较为详细的介绍了什么是梯度下降法。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ybjourney/p/12508027.html</dc:identifier>
</item>
</channel>
</rss>