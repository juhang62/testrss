<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>「译」Blazor VS React React / Angular / Vue.js - SpringLeee</title>
<link>http://www.cnblogs.com/myshowtime/p/14249750.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myshowtime/p/14249750.html</guid>
<description>&lt;blockquote readability=&quot;2.4201680672269&quot;&gt;
&lt;p&gt;原文作者: Christian Findlay&lt;br/&gt;原文链接： &lt;a href=&quot;https://christianfindlay.com/2020/06/04/blazor-vs-react-angular-vue-js/&quot; title=&quot;https://christianfindlay.com/2020/06/04/blazor-vs-react-angular-vue-js/&quot; target=&quot;_blank&quot;&gt;https://christianfindlay.com/2020/06/04/blazor-vs-react-angular-vue-js/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Blazor是一项新的Microsoft技术，允许开发人员使用C＃为浏览器编写代, 本文将Blazor与其他三个常见SPA框架进行了比较：React，Angular和Vue.js, JavaScript是当前基于浏览器的单页应用程序（SPA）最受欢迎的语言，因为直到最近，它还是在浏览器中运行的唯一语言。这些框架可以从JavaScript或TypeScript进行编译或转换。本文询问开发人员是否需要依赖与JavaScript，以及我们是否可以开始使用C＃构建SPA应用程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/screen-shot-2020-06-04-at-8.39.07-pm.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是blazor？&quot;&gt;什么是Blazor？&lt;/h3&gt;
&lt;p&gt;Blazor是用于Web和移动设备的基于.NET开发的SPA框架，并且是ASP.NET Core Web框架的一部分，Blazor使用现有的和大家熟悉的HTML文档对象模型（DOM）以及CSS样式来呈现和处理UI组件，但是，Blazor使用了C#来替代JavaScript进行处理，因此开发人员可以跨平台共享代码，Blazor使用Razor脚本声明HTML，这是.NET开发人员熟悉的脚本，Razor通过维护一种简单的语法来使开发人员接近HTML，并且允许数据绑定，循环和变量定义。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210107_070312.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序运行在.NET运行时上面，有服务器端和客户端两种模式，对于服务器端，HTML DOM呈现在服务器上，然后通过Signal-R 发送到浏览器，进行数据渲染, 对于客户端，Mono在浏览器内部的WebAssembly上运行，WASM 无需服务器端渲染或其他浏览器插件即可充分发挥.NET的强大功能。&lt;/p&gt;
&lt;p&gt;Blazor 允许开发人员在桌面应用和移动应用中使用，Electron允许开发人员使用HTML和CSS构建桌面应用程序，Electron.Net是一种弥合差距并允许与Blazor一起使用的技术，微软已为本机移动应用程序建立了实验性绑定，这可能表明Blazor应用程序将在iOS和Android等平台上运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210107_071829.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;blazor-功能特性&quot;&gt;Blazor 功能特性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用C＃代替JavaScript和TypeScript构建 Web UI&lt;/li&gt;
&lt;li&gt;构建渐进式Web应用程序（PWA）&lt;/li&gt;
&lt;li&gt;创建和使用用C＃编写的可重用组件&lt;/li&gt;
&lt;li&gt;在服务器端模式提供全面的调试支持，在客户端模式进行一些限制的调试&lt;/li&gt;
&lt;li&gt;与HTML DOM的数据绑定（有限的双向绑定）&lt;/li&gt;
&lt;li&gt;使用C＃在客户端和服务器之间共享代码&lt;/li&gt;
&lt;li&gt;可在所有现代网络浏览器（包括移动浏览器）中使用&lt;/li&gt;
&lt;li&gt;Blazor代码具有与JavaScript相同的安全沙箱&lt;/li&gt;
&lt;li&gt;使用JavaScript操作调用JavaScript框架和库&lt;/li&gt;
&lt;li&gt;开源&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;什么是webassembly？&quot;&gt;什么是WebAssembly？&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;是基于堆栈的虚拟机的二进制指令格式, Wasm被设计为可移植目标，用于编译高级语言（如C / C ++ / Rust），从而可以在Web上为客户端和服务器应用程序进行部署。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本质上，它允许为Web浏览器编译代码。过去，诸如Adobe Flash或Microsoft Silverlight之类的技术通过强制用户安装插件来实现，现在不再需要这些，并且.NET运行时现在可以在WebAssembly上运行。&lt;/p&gt;
&lt;h3 id=&quot;什么是react？&quot;&gt;什么是React？&lt;/h3&gt;
&lt;p&gt;React是Facebook开源的一个JavaScript的UI框架，React并未尝试向开发人员提供构建现代Web应用程序所需的所有工具，相反，它专注于UI的主要方面，并允许开发人员方便的使用这些组件，这听起来也没啥，但事实并非如此，JavaScript UI库发展了这么多年，但React作为1号UI库，吸引了大量追随者，简单说，React主要是一个JavaScript库，但是可以轻松地与TypeScript一起使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210107_081604.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;react-功能特性&quot;&gt;React 功能特性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用JavaScript或TypeScript构建Web UI&lt;/li&gt;
&lt;li&gt;构建渐进式Web应用程序（PWA）&lt;/li&gt;
&lt;li&gt;可在所有现代网络浏览器（包括移动浏览器）中使用&lt;/li&gt;
&lt;li&gt;大型的社区支持&lt;/li&gt;
&lt;li&gt;开源&lt;/li&gt;
&lt;li&gt;像VS Code这样的IDE中的全面调试支持&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;blazor-vs-react&quot;&gt;Blazor VS React&lt;/h3&gt;
&lt;p&gt;JavaScript对于C＃开发人员而言具有难的学习曲线，并且不是静态类型的语言。许多团队负责人会遇到雇用后端和前端开发人员的问题。很难找到同时擅长JavaScript和C＃的开发人员。如果Blazor是首选技术，则后端C＃开发人员会掌握有关Blazor前端开发的知识。后端开发人员可以轻松切换角色来修复前端的错误，也可以熟练地构建前端应用程序。&lt;/p&gt;
&lt;p&gt;Blazor尚未像React那样成熟，但是Microsoft会在该框架上建立基础，然后在SPA领域流行，客户端调试是缺少的主要功能，后边应该会支持。如果您的企业现在需要可用于生产的SPA并具有JavaScript专业知识，那么React将比Blazor更好的选择，但是，如果团队由C＃开发人员组成并且SPA有发展的空间，请考虑使用Blazor。在这种情况下，Blazor有很大的机会随着时间的推移产生更多可维护的代码。&lt;/p&gt;
&lt;p&gt;尽管对于静态类型的语言通常是否更好还存在一些争论，但是许多开发人员会说静态类型的语言对于大型项目而言更好。与JavaScript相比，C＃可能成为更可取的选择。&lt;/p&gt;
&lt;h3 id=&quot;什么是angular&quot;&gt;什么是Angular?&lt;/h3&gt;
&lt;p&gt;Angular是由Google团队编写和维护的，一套基于TypeScript并且流行的Web和移动SPA框架。它与Angular不同的是，它是一个完整的框架。TypeScript是一种静态类型化语言，例如C＃，并且可以转换为JavaScript。TypeScript和C＃相似，因为Microsoft在维护它。Angular的更高版本也以类似于Blazor的方式支持服务器端渲染。模板语法与razor语法类，并且具有数据绑定的HTML DOM UI组件。&lt;/p&gt;
&lt;p&gt;Web开发人员更熟悉Angular，因为它利用了现有的JavaScript框架，并且具有JavaScript背景。它拥有一个充满活力的成熟的社区。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210107_082356.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;angular-功能特性&quot;&gt;Angular 功能特性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用TypeScript构建Web UI&lt;/li&gt;
&lt;li&gt;构建渐进式Web应用程序（PWA）&lt;/li&gt;
&lt;li&gt;使用HTML DOM进行双向数据绑定&lt;/li&gt;
&lt;li&gt;可在所有现代网络浏览器（包括移动浏览器）中使用&lt;/li&gt;
&lt;li&gt;大型的社区&lt;/li&gt;
&lt;li&gt;开源&lt;/li&gt;
&lt;li&gt;像VS Code这样的IDE中的全面调试支持&lt;/li&gt;
&lt;li&gt;完整的内置API，可完成常见的应用程序任务&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;blazor-vs-angular&quot;&gt;Blazor VS Angular&lt;/h3&gt;
&lt;p&gt;Angular也是一个成熟的框架，拥有庞大的社区，而Blazor则在不断发展。但是，Angular包含TypeScript范例，对于C＃开发人员而言，它比JavaScript更自然地适应。Angular比React更全面，并且将自己宣传为框架而不是UI库。Angular不仅仅是UI组件。它鼓励开发人员开箱即用地使用组件，因此代码变得更加统一。&lt;/p&gt;
&lt;h3 id=&quot;什么是vuejs&quot;&gt;什么是Vue.js?&lt;/h3&gt;
&lt;p&gt;Vue与Angular具有相似的背景，开发人员使用JavaScript构建应用。它位于React和Angular之间，因为它在UI库和框架之间扩展。它是一个更精致的框架，但仍然是React和Angular的竞争对手。与React一样，开发人员可以使用TypeScript，但更多是 JavaScript。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/clipboard_20210107_081816.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;vuejs-功能特性&quot;&gt;Vue.js 功能特性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用JavaScript或TypeScript构建Web UI&lt;/li&gt;
&lt;li&gt;构建渐进式Web应用程序（PWA）&lt;/li&gt;
&lt;li&gt;使用HTML DOM进行双向数据绑定&lt;/li&gt;
&lt;li&gt;可在所有现代网络浏览器（包括移动浏览器）中使用&lt;/li&gt;
&lt;li&gt;中型的社区&lt;/li&gt;
&lt;li&gt;开源&lt;/li&gt;
&lt;li&gt;像VS Code这样的IDE中的全面调试支持&lt;/li&gt;
&lt;li&gt;用于日常应用程序任务的全套内置API&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;blazor-vs-vuejs&quot;&gt;Blazor VS Vue.js&lt;/h3&gt;
&lt;p&gt;Angular和React的许多比较点也适用于Vue.js。对于不仅仅需要UI库但又不需要完整的Angular框架的开发人员来说，Vus.js可能是一个折衷的折衷方案。Angular和Vue.js之间一些比较倾向于表明Vue.js在性能方面确实做到合理。因此，对于目前需要开发SPA的团队来说，Vue.js可能是另一个不错的选择，但是再次强调，将Blazor与C＃结合使用对于具有C＃背景的团队可能会产生更好的结果。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;现在，C＃开发人员在构建UI时有很多选择。Blazor将熟悉的HTML DOM带入C＃，并为Web开发人员提供了使用C＃的能力。它具有构建桌面和移动应用程序的潜力，并在Microsoft开发社区中具有吸引力。在评估下一个SPA的技术时，你可以考虑使用 Blazor!&lt;/p&gt;
&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;欢迎扫码关注我们的公众号，专注国外优秀博客的翻译和开源项目分享，也可以添加QQ群 897216102&lt;/p&gt;
&lt;img src=&quot;https://blog-1259586045.cos.ap-shanghai.myqcloud.com/wechat-logo2.png&quot;/&gt;</description>
<pubDate>Thu, 07 Jan 2021 23:49:00 +0000</pubDate>
<dc:creator>SpringLeee</dc:creator>
<og:description>原文作者: Christian Findlay 原文链接： https://christianfindlay.com/2020/06/04/blazor-vs-react-angular-vue-js</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myshowtime/p/14249750.html</dc:identifier>
</item>
<item>
<title>Pytest测试框架（五）：pytest + allure生成测试报告 - 测试开发小记</title>
<link>http://www.cnblogs.com/hiyong/p/14163298.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hiyong/p/14163298.html</guid>
<description>&lt;p&gt;Allure 是一款轻量级、支持多语言的开源自动化测试报告生成框架，由Java语言开发，可以集成到 Jenkins。 pytest 测试框架支持Allure 报告生成。&lt;/p&gt;
&lt;p&gt;pytest也可以生成junit格式的xml报告和HTML报告，命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pytest test_demo.py --junitxml=report.xml
pytest test_demo.py --html=report.html #需要安装插件：pip install pytest-html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Allure 报告更加灵活美观，本文介绍如何使用pytest 生成 allure测试报告&lt;/p&gt;

&lt;h2 id=&quot;安装allure&quot;&gt;安装allure&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;allure包下载：&lt;a href=&quot;https://github.com/allure-framework/allure2/releases&quot; target=&quot;_blank&quot;&gt;https://github.com/allure-framework/allure2/releases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;解压 -&amp;gt; 进入bin目录 -&amp;gt; 运行allure.bat,&lt;/li&gt;
&lt;li&gt;把bin目录加入PATH环境变量&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220131659099-260909699.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;allure官网 : &lt;a href=&quot;http://allure.qatools.ru/&quot; target=&quot;_blank&quot;&gt;http://allure.qatools.ru/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;allure文档 : &lt;a href=&quot;https://docs.qameta.io/allure/#&quot; target=&quot;_blank&quot;&gt;https://docs.qameta.io/allure/#&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装-allure-pytest插件&quot;&gt;安装 allure-pytest插件&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;pip install allure-pytest
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;运行&quot;&gt;运行&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pytest [测试文件] -s -q --alluredir=./result #--alluredir用于指定存储测试结果的路径)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查看测试报告&quot;&gt;查看测试报告&lt;/h2&gt;
&lt;p&gt;方式一：直接打开默认浏览器展示报告&lt;/p&gt;
&lt;p&gt;&lt;code&gt;allure serve ./result/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方式二：从结果生成报告&lt;/p&gt;
&lt;p&gt;实例代码：&lt;a href=&quot;https://docs.qameta.io/allure/#_pytest&quot; target=&quot;_blank&quot;&gt;https://docs.qameta.io/allure/#_pytest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;test_allure.py：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import pytest

def test_success():
    &quot;&quot;&quot;this test succeeds&quot;&quot;&quot;
    assert True

def test_failure():
    &quot;&quot;&quot;this test fails&quot;&quot;&quot;
    assert False

def test_skip():
    &quot;&quot;&quot;this test is skipped&quot;&quot;&quot;
    pytest.skip('for a reason!')

def test_broken():
    raise Exception('oops')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方法1&quot;&gt;方法1&lt;/h3&gt;
&lt;p&gt;执行测试用例:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pytest test_allure.py --alluredir=./result/1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220131821093-470055224.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开报告:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt; allure serve ./result/1
Generating report to temp directory...
Report successfully generated to C:\Users\10287\AppData\Local\Temp\6968593833275403330\allure-report
Starting web server...
2020-10-25 20:59:42.368:INFO::main: Logging initialized @4873ms to org.eclipse.jetty.util.log.StdErrLog
Server started at &amp;lt;http://169.254.57.162:60084/&amp;gt;. Press &amp;lt;Ctrl+C&amp;gt; to exit

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220131814169-1734476365.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;方法2&quot;&gt;方法2&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;allure generate ./result/1 -o ./report/1/ --clean
allure open -h 127.0.0.1 -p 8883 ./report/1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器访问地址 &lt;a href=&quot;http://127.0.0.1:8883/&quot; target=&quot;_blank&quot;&gt;http://127.0.0.1:8883/&lt;/a&gt; ，会显示跟上图一样的报告。&lt;/p&gt;

&lt;p&gt;可以在报告中添加用例描述信息，比如测试功能，子功能或场景，测试步骤以及测试附加信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@allure.feature(‘功能名称’)：相当于 testsuite&lt;/li&gt;
&lt;li&gt;@allure.story(’子功能名称‘)：对应这个功能或者模块下的不同场景，相当于 testcase&lt;/li&gt;
&lt;li&gt;@allure.step('步骤')：测试过程中的每个步骤，放在具体逻辑方法中
&lt;ul&gt;&lt;li&gt;allure.step('步骤') 只能以装饰器的形式放在类或者方法上面&lt;/li&gt;
&lt;li&gt;with allure.step：可以放在测试用例方法里面&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;@allure.attach('具体文本信息')
&lt;ul&gt;&lt;li&gt;附加信息：数据，文本，图片，视频，网页&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试用例 test_feature_story_step.py：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import pytest
import allure

@allure.feature(&quot;登录&quot;)
class TestLogin():
    @allure.story(&quot;登录成功&quot;)
    def test_login_success(self):
        print(&quot;登录成功&quot;)
        pass

    @allure.story(&quot;密码错误&quot;)
    def test_login_failure(self):
        with allure.step(&quot;输入用户名&quot;):
            print(&quot;输入用户名&quot;)
        with allure.step(&quot;输入密码&quot;):
            print(&quot;输入密码&quot;)
        print(&quot;点击登录&quot;)
        with allure.step(&quot;登录失败&quot;):
            assert '1' == 1
            print(&quot;登录失败&quot;)
        pass

    @allure.story(&quot;用户名密码错误&quot;)
    def test_login_failure_a(self):
        print(&quot;用户名或者密码错误，登录失败&quot;)
        pass


@allure.feature(&quot;注册&quot;)
class TestRegister():
    @allure.story(&quot;注册成功&quot;)
    def test_register_success(self):
        print(&quot;测试用例：注册成功&quot;)
        pass

    @allure.story(&quot;注册失败&quot;)
    def test_register_failure(self):
        with allure.step(&quot;输入用户名&quot;):
            print(&quot;输入用户名&quot;)
        with allure.step(&quot;输入密码&quot;):
            print(&quot;输入密码&quot;)
        with allure.step(&quot;再次输入密码&quot;):
            print(&quot;再次输入密码&quot;)
        print(&quot;点击注册&quot;)
        with allure.step(&quot;注册失败&quot;):
            assert 1 + 1 == 2
            print(&quot;注册失败&quot;)
        pass
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用例执行、生成报告&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pytest test_feature_story.py --alluredir=./result/2 
allure generate ./result/2 -o ./report/2/ --clean
allure open -h 127.0.0.1 -p 8883 ./report/2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;报告：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220131838423-674335411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以在测试报告中添加链接、bug地址、测试用例地址。&lt;/p&gt;
&lt;p&gt;关联bug需要在用例执行时添加参数：&lt;/p&gt;
&lt;p&gt;test_allure_link_issue.py：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import allure

@allure.link(&quot;http://www.baidu.com&quot;, name=&quot;baidu link&quot;)
def test_with_link():
    pass

@allure.issue(&quot;140&quot;,&quot;this is a issue&quot;)
def test_with_issue_link():
    pass

TEST_CASE_LINK = 'https://github.com'
@allure.testcase(TEST_CASE_LINK, 'Test case title')
def test_with_testcase_link():
    pass
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用例执行:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pytest test_allure_link_issue.py --allure-link-pattern=issue:http://www.bugfree.com/issue/{} --alluredir=./result/3
allure serve ./result/3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;报告：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220131849888-304686173.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 &lt;code&gt;this is a issue&lt;/code&gt;，页面会跳转到bug页面：&lt;a href=&quot;http://www.bugfree.com/issue/140&quot; target=&quot;_blank&quot;&gt;http://www.bugfree.com/issue/140&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;有时候在上线前，由于时间关系，我们只需要把重要模块测试一遍，在这样的场景下我们怎么实现呢？主要有三种方法：&lt;/p&gt;
&lt;ol readability=&quot;3.1823248407643&quot;&gt;&lt;li readability=&quot;1.4519230769231&quot;&gt;
&lt;p&gt;可以使用pytest.mark来标记用例，&lt;a href=&quot;https://hiyong.gitee.io/posts/install-pytest-and-run-test/&quot; target=&quot;_blank&quot;&gt;Pytest测试框架（一）：pytest安装及用例执行&lt;/a&gt; 介绍了这种方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;@pytest.mark.webtest # 添加标签 
@pytest.mark.sec 
pytest -m &quot;webtest and not sec&quot;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;通过 allure.feature, allure.story来实现&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pytest test_feature_story_step.py --allure-features &quot;登录&quot; //只运行登录模块
pytest test_feature_story_step.py --allure-stories &quot;登录成功&quot; //只运行登录成功子模块      
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过 allure.severity按重要性级别来标记，有5种级别：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;test_allure_severity.py：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import allure
import pytest

def test_with_no_severity_label():
    pass

@allure.severity(allure.severity_level.TRIVIAL)
def test_with_trivial_severity():
    pass

@allure.severity(allure.severity_level.NORMAL)
def test_with_normal_severity():
    pass

@allure.severity(allure.severity_level.NORMAL)
class TestclassWithNormalSeverity(object):
    def test_inside_the_normalseverity_test_class(self):
        pass

    @allure.severity(allure.severity_level.CRITICAL)
    def test_inside_the_normal_severity_test_class_with_overriding_critical_severity(self):
        pass
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用例执行:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pytest test_allure_severity.py --alluredir=./result/4 --allure-severities normal,critical
allure serve ./result/4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220131936761-222408340.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以在报告中附加文本、图片以及html网页，用来补充测试步骤或测试结果，比如错误截图或者关键步骤的截图。&lt;/p&gt;
&lt;p&gt;test_allure_attach.py：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import allure
import pytest

def test_attach_text():
    allure.attach(&quot;纯文本&quot;, attachment_type=allure.attachment_type.TEXT)

def test_attach_html():
    allure.attach(&quot;&amp;lt;body&amp;gt;这是一段htmlbody块&amp;lt;/body&amp;gt;&quot;, &quot;html页面&quot;, attachment_type=allure.attachment_type.HTML)

def test_attach_photo():
    allure.attach.file(&quot;test.jpg&quot;, name=&quot;图片&quot;, attachment_tye=allure.attachment_type.JPG)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用例执行:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pytest test_allure_attach.py --alluredir=./result/5
allure serve ./result/5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220131943345-786906987.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;测试步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开百度&lt;/li&gt;
&lt;li&gt;搜索关键词&lt;/li&gt;
&lt;li&gt;搜索结果截图，保存到报告中&lt;/li&gt;
&lt;li&gt;退出浏览器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;test_allure_baidu.py：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import allure
import pytest
from selenium import webdriver
import time

@allure.testcase(&quot;http://www.github.com&quot;)
@allure.feature(&quot;百度搜索&quot;)
@pytest.mark.parametrize('test_data1', ['allure', 'pytest', 'unittest'])
def test_steps_demo(test_data1):
    with allure.step(&quot;打开百度网页&quot;):
        driver = webdriver.Chrome(&quot;D:/testing_tools/chromedriver85/chromedriver.exe&quot;)
        driver.get(&quot;http://www.baidu.com&quot;)

    with allure.step(&quot;搜索关键词&quot;):
        driver.find_element_by_id(&quot;kw&quot;).send_keys(test_data1)
        time.sleep(2)
        driver.find_element_by_id(&quot;su&quot;).click()
        time.sleep(2)

    with allure.step(&quot;保存图片&quot;):
        driver.save_screenshot(&quot;./result/b.png&quot;)
        allure.attach.file(&quot;./result/b.png&quot;, attachment_type=allure.attachment_type.PNG)
        allure.attach('&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;首页&amp;lt;/body&amp;gt;', 'Attach with HTML type', allure.attachment_type.HTML)

    with allure.step(&quot;退出浏览器&quot;):
        driver.quit()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用例执行:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pytest test_allure_baidu.py --alluredir=./result/6
allure serve ./result/6
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220131955267-1021465726.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;center&gt;&lt;strong&gt;--THE END--&lt;/strong&gt;&lt;/center&gt;
&lt;blockquote readability=&quot;5.6583333333333&quot;&gt;
&lt;p&gt;&lt;strong&gt;文章标题：Pytest测试框架（五）：pytest + allure生成测试报告&lt;br/&gt;本文作者：hiyo&lt;br/&gt;本文链接：&lt;a href=&quot;https://www.cnblogs.com/hiyong/p/14163298.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hiyong/p/14163298.html&lt;/a&gt;&lt;br/&gt;欢迎关注公众号:「测试开发小记」及时接收最新技术文章！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 07 Jan 2021 23:07:00 +0000</pubDate>
<dc:creator>测试开发小记</dc:creator>
<og:description>Allure 是一款轻量级、支持多语言的开源自动化测试报告生成框架，由Java语言开发，可以集成到 Jenkins。 pytest 测试框架支持Allure 报告生成。 pytest也可以生成juni</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hiyong/p/14163298.html</dc:identifier>
</item>
<item>
<title>SpringCloud 源码系列（6）—— 声明式服务调用 Feign - bojiangzhou</title>
<link>http://www.cnblogs.com/chiangchou/p/feign.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chiangchou/p/feign.html</guid>
<description>&lt;p&gt;介绍了 Feign 基础使用、配置，从源码的角度分析了 @FeignClient 接口如何生成动态代理并注入到容器中使用，以及 Feign 如何与 Ribbon 结合进行负载均衡请求。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;607.87789708548&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chiangchou/p/eureka-1.html&quot; target=&quot;_blank&quot;&gt;SpringCloud 源码系列（1）—— 注册中心 Eureka（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chiangchou/p/eureka-2.html&quot; target=&quot;_blank&quot;&gt;SpringCloud 源码系列（2）—— 注册中心 Eureka（中）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chiangchou/p/eureka-3.html&quot; target=&quot;_blank&quot;&gt;SpringCloud 源码系列（3）—— 注册中心 Eureka（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chiangchou/p/ribbon-1.html&quot; target=&quot;_blank&quot;&gt;SpringCloud 源码系列（4）—— 负载均衡 Ribbon（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chiangchou/p/ribbon-2.html&quot; target=&quot;_blank&quot;&gt;SpringCloud 源码系列（5）—— 负载均衡 Ribbon（下）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chiangchou/p/feign.html&quot; target=&quot;_blank&quot;&gt;SpringCloud 源码系列（6）—— 声明式服务调用 Feign&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;一、Feign 基础入门&lt;/h2&gt;
&lt;h3&gt;1、Feign 概述&lt;/h3&gt;
&lt;p&gt;在使用 Spring Cloud 开发微服务应用时，各个服务提供者都是以HTTP接口的形式对外提供服务，因此在服务消费者调用服务提供者时，底层通过 HTTP Client 的方式访问。我们可以使用JDK原生的 URLConnection、Apache的HTTP Client、OkHttp、Spring 的 RestTemplate 去实现服务间的调用。但是最方便、最优雅的方式是通过 Spring Cloud OpenFeign 进行服务间的调用。&lt;/p&gt;
&lt;p&gt;Feign 是一个声明式的 Web Service 客户端，它的目的就是让Web Service调用更加简单。Spring Cloud 对 Feign 进行了增强，使 Feign 支持 Spring MVC 的注解，并整合了 Ribbon、Hystrix 等。Feign还提供了HTTP请求的模板，通过编写简单的接口和注解，就可以定义好HTTP请求的参数、格式、地址等信息。Feign 会完全代理HTTP的请求，在使用过程中我们只需要依赖注入Bean，然后调用对应的方法传递参数即可。Feign 的首要目标是将 Java HTTP 客户端的书写过程变得简单。&lt;/p&gt;
&lt;p&gt;Feign 的一些主要特性如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可插拔的注解支持，包括Feign注解和JAX-RS注解。&lt;/li&gt;
&lt;li&gt;支持可插拔的HTTP编码器和解码器。&lt;/li&gt;
&lt;li&gt;支持 Hystrix 和它的Fallback。支持Ribbon的负载均衡。&lt;/li&gt;
&lt;li&gt;支持HTTP请求和响应的压缩。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;GitHub地址：&lt;/p&gt;
&lt;h3&gt;2、DEMO示例&lt;/h3&gt;
&lt;p&gt;还是使用前面研究 Eureka 和 Ribbon 时的 demo-producer、demo-consumer 服务来做测试。&lt;/p&gt;
&lt;p&gt;① 首先，需要引入 openfeign 的依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-openfeign&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;spring-cloud-starter-openfeign 会帮我们引入如下依赖，包含了 OpenFeign 的核心组件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201230114656923-1227530682.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 在 demo-consumer 服务中，增加一个 Feign 客户端接口，来调用 demo-producer 的接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @FeignClient(value = &quot;demo-producer&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ProducerFeignClient {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     @GetMapping(&quot;/v1/user/{id}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     ResponseEntity&amp;lt;User&amp;gt; getUserById(@PathVariable Long id, @RequestParam(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) String name);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     @PostMapping(&quot;/v1/user&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ResponseEntity&amp;lt;User&amp;gt;&lt;span&gt; createUser(@RequestBody User user);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 在启动类加上 @EnableFeignClients 注解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@EnableFeignClients
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerApplication {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;....       &lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ 在接口中注入 ProducerFeignClient 就可以使用 Feign 客户端接口来调用远程服务了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FeignController {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger =&lt;span&gt; LoggerFactory.getLogger(getClass());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ProducerFeignClient producerFeignClient;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     @GetMapping(&quot;/v1/user/query&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ResponseEntity&amp;lt;User&amp;gt;&lt;span&gt; queryUser() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         ResponseEntity&amp;lt;User&amp;gt; result = producerFeignClient.getUserById(1L, &quot;tom&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         User user =&lt;span&gt; result.getBody();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         logger.info(&quot;query user: {}&quot;&lt;span&gt;, user);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResponseEntity.ok(user);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     @GetMapping(&quot;/v1/user/create&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ResponseEntity&amp;lt;User&amp;gt;&lt;span&gt; createUser() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         ResponseEntity&amp;lt;User&amp;gt; result = producerFeignClient.createUser(&lt;span&gt;new&lt;/span&gt; User(10L, &quot;Jerry&quot;, 20&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         User user =&lt;span&gt; result.getBody();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         logger.info(&quot;create user: {}&quot;&lt;span&gt;, user);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResponseEntity.ok(user);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑤ 在 demo-producer 服务增加 UserController 接口供消费者调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger =&lt;span&gt; LoggerFactory.getLogger(getClass());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     @PostMapping(&quot;/v1/user/{id}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ResponseEntity&amp;lt;User&amp;gt;&lt;span&gt; queryUser(@PathVariable Long id, @RequestParam String name) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         logger.info(&quot;query params: id :{}, name:{}&quot;&lt;span&gt;, id, name);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; ResponseEntity.ok(&lt;span&gt;new&lt;/span&gt; User(id, name, 10&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     @PostMapping(&quot;/v1/user/{id}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ResponseEntity&amp;lt;User&amp;gt;&lt;span&gt; createUser(@RequestBody User user) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         logger.info(&quot;create params: {}&quot;&lt;span&gt;, user);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResponseEntity.ok(user);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑥ 测试&lt;/p&gt;
&lt;p&gt;先把把注册中心启起来，然后 demo-producer 启两个实例，再启动 demo-consumer，调用 demo-consumer 的接口测试，会发现，ProducerFeignClient 的调用会轮询到 demo-consumer 的两个实例上。&lt;/p&gt;
&lt;p&gt;通过简单的测试可以发现，Feign 使得 Java HTTP 客户端的书写过程变得非常简单，就像开发接口一样。另外，Feign底层一定整合了 Ribbon，@FeignClient 指定了服务名称，请求最终一定是通过 Ribbon 的 ILoadBalancer 组件进行负载均衡的。&lt;/p&gt;
&lt;h3&gt;3、FeignClient 注解&lt;/h3&gt;
&lt;p&gt;通过前面的DEMO可以发现，使用 Feign 最核心的应该就是 @EnableFeignClients 和 @FeignClient 这两个注解，@FeignClient 加在客户端接口类上，@EnableFeignClients 加在启动类上，就是用来扫描加了 @FeignClient 接口的类。我们研究源码就从这两个入口开始。&lt;/p&gt;
&lt;p&gt;要知道接口是不能直接注入和调用的，那么一定是 @EnableFeignClients 扫描到 @FeignClient 注解的接口后，基于这个接口生成了动态代理对象，并注入到 Spring IOC 容器中，才可以被注入使用。最终呢，一定会通过 Ribbon 负载均衡获取一个 Server，然后重构 URI，再发起最终的HTTP调用。&lt;/p&gt;
&lt;p&gt;① @EnableFeignClients 注解&lt;/p&gt;
&lt;p&gt;首先看 @EnableFeignClients 的类注释，注释就已经说明了，这个注解就是用来扫描 @FeignClient 注解的接口的，那么核心的逻辑应该就是在 @Import 导入的类 FeignClientsRegistrar 中的。&lt;/p&gt;
&lt;p&gt;EnableFeignClients 的主要属性有如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;value、basePackages： 配置扫描 @FeignClient 的包路径&lt;/li&gt;
&lt;li&gt;clients：直接指定扫描的 @FeignClient 接口&lt;/li&gt;
&lt;li&gt;defaultConfiguration：配置 Feign 客户端全局默认配置类，从注释可以得知，默认的全局配置类是 FeignClientsConfiguration&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.cloud.openfeign;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Scans for interfaces that declare they are feign clients (via
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.cloud.openfeign.FeignClient} &amp;lt;code&amp;gt;@FeignClient&amp;lt;/code&amp;gt;).
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * Configures component scanning directives for use with
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * &amp;lt;code&amp;gt;@Configuration&amp;lt;/code&amp;gt; classes.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;@Target(ElementType.TYPE)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; @Import(FeignClientsRegistrar.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; EnableFeignClients {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定扫描 @FeignClient 包所在目录&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     String[] value() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定扫描 @FeignClient 包所在目录&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     String[] basePackages() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定标记接口来扫描包&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     Class&amp;lt;?&amp;gt;[] basePackageClasses() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Feign 客户端全局默认配置类&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * A custom &amp;lt;code&amp;gt;@Configuration&amp;lt;/code&amp;gt; for all feign clients. Can contain override
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * &amp;lt;code&amp;gt;@Bean&amp;lt;/code&amp;gt; definition for the pieces that make up the client, for instance
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; feign.codec.Decoder}, {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; feign.codec.Encoder}, {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; feign.Contract}.
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; FeignClientsConfiguration for the defaults
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; list of default configurations
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     Class&amp;lt;?&amp;gt;[] defaultConfiguration() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接指定 @FeignClient 注解的类，这时就会禁用类路径扫描&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     Class&amp;lt;?&amp;gt;[] clients() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② @FeignClient 注解&lt;/p&gt;
&lt;p&gt;首先看 FeignClient 的类注释，注释说明 @&lt;span&gt;FeignClient&lt;/span&gt; 注解就是声明一个 REST 客户端接口，而且会创建一个可以注入的组件，应该就是动态代理的bean。而且如果Ribbon可用，然后就可以用Ribbon做负载均衡，这个负载均衡可以用 @RibbonClient 定制配置类，名称一样就行。&lt;/p&gt;
&lt;p&gt;FeignClient 注解被 @Target(ElementType.TYPE) 修饰，表示 FeignClient 注解的作用目标在接口上。@Retention(RetentionPolicy.RUNTIME) 注解表明该注解会在 Class 字节码文件中存在，在运行时可以通过反射获取到。&lt;/p&gt;
&lt;p&gt;@FeignClient 注解用于创建声明式 API 接口，该接口是 RESTful 风格的。Feign 被设计成插拔式的，可以注入其他组件和 Feign 一起使用。最典型的是如果 Ribbon 可用，Feign 会和Ribbon 相结合进行负载均衡。&lt;/p&gt;
&lt;p&gt;FeignClient 主要有如下属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;name：指定 FeignClient 的名称，如果项目使用了 Ribbon，name 属性会作为微服务的名称，用于服务发现。&lt;/li&gt;
&lt;li&gt;url：url 一般用于调试，可以手动指定 @FeignClient 调用的地址。&lt;/li&gt;
&lt;li&gt;decode404：当发生404错误时，如果该字段为true，会调用 decoder 进行解码，否则抛出 FeignException。&lt;/li&gt;
&lt;li&gt;configuration：FeignClient 配置类，可以自定义Feign的Encoder、Decoder、LogLevel、Contracto&lt;/li&gt;
&lt;li&gt;fallback：定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback 指定的类必须实现 @FeignClient 标记的接口。&lt;/li&gt;
&lt;li&gt;fallbackFactory：工厂类，用于生成 fallback 类实例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码。&lt;/li&gt;
&lt;li&gt;path：定义当前 FeignClient 的统一前缀。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.cloud.openfeign;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Annotation for interfaces declaring that a REST client with that interface should be
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * created (e.g. for autowiring into another component). If ribbon is available it will be
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * used to load balance the backend requests, and the load balancer can be configured
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * using a &amp;lt;code&amp;gt;@RibbonClient&amp;lt;/code&amp;gt; with the same name (i.e. value) as the feign client.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@Target(ElementType.TYPE)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;@Inherited
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; FeignClient {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定服务名称&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     @AliasFor(&quot;name&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     String value() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定服务名称，已过期&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Deprecated
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     String serviceId() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; FeignClient 接口生成的动态代理的bean名称&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     String contextId() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定服务名称&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     @AliasFor(&quot;value&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     String name() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; @Qualifier 标记&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     String qualifier() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不使用Ribbon负载均衡，就需要使用url返回一个绝对地址&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     String url() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 404 默认抛出 FeignExceptions 异常，设置为true则替换为404异常&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; decode404() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Feign客户端配置类，可以定制 Decoder、Encoder、Contract&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;     * A custom configuration class for the feign client. Can contain override
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;     * &amp;lt;code&amp;gt;@Bean&amp;lt;/code&amp;gt; definition for the pieces that make up the client, for instance
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; feign.codec.Decoder}, {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; feign.codec.Encoder}, {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; feign.Contract}.
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; FeignClientsConfiguration for the defaults
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; list of configurations for feign client
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     Class&amp;lt;?&amp;gt;[] configuration() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; FeignClient 接口的回调类，必须实现客户端接口，并注册为一个bean对象。
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求失败或降级时就会进入回调方法中&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;     * Fallback class for the specified Feign client interface. The fallback class must
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;     * implement the interface annotated by this annotation and be a valid spring bean.
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; fallback class for the specified Feign client interface
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;     Class&amp;lt;?&amp;gt; fallback() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调类创建工厂&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;     Class&amp;lt;?&amp;gt; fallbackFactory() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; URL前缀&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;     String path() &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义为 primary bean&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; primary() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、FeignClient 核心组件&lt;/h3&gt;
&lt;p&gt;从上面已经得知，FeignClient 的默认配置类为 FeignClientsConfiguration，这个类在 spring-cloud-openfeign-core 的 jar 包下，并且每个 FeignClient 都可以定义各自的配置类。&lt;/p&gt;
&lt;p&gt;打开这个类，可以发现这个类注入了很多 Feign 相关的配置 Bean，包括 Retryer、FeignLoggerFactory、Decoder、Encoder、Contract 等，这些类在没有 Bean 被注入的情况下，会自动注入默认配置的 Bean。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_41af569b-5878-4ef7-b502-7fb791f8a611&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_41af569b-5878-4ef7-b502-7fb791f8a611&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_41af569b-5878-4ef7-b502-7fb791f8a611&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.cloud.openfeign;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FeignClientsConfiguration {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; ObjectFactory&amp;lt;HttpMessageConverters&amp;gt;&lt;span&gt; messageConverters;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     @Autowired(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;AnnotatedParameterProcessor&amp;gt; parameterProcessors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     @Autowired(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;FeignFormatterRegistrar&amp;gt; feignFormatterRegistrars = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     @Autowired(required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Logger logger;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Decoder feignDecoder() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; OptionalDecoder(&lt;span&gt;new&lt;/span&gt; ResponseEntityDecoder(&lt;span&gt;new&lt;/span&gt; SpringDecoder(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageConverters)));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     @ConditionalOnMissingClass(&quot;org.springframework.data.domain.Pageable&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Encoder feignEncoder(ObjectProvider&amp;lt;AbstractFormWriter&amp;gt;&lt;span&gt; formWriterProvider) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; springEncoder(formWriterProvider);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     @ConditionalOnClass(name = &quot;org.springframework.data.domain.Pageable&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Encoder feignEncoderPageable(
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             ObjectProvider&amp;lt;AbstractFormWriter&amp;gt;&lt;span&gt; formWriterProvider) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; encoder;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Contract feignContract(ConversionService feignConversionService) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SpringMvcContract(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.parameterProcessors, feignConversionService);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Retryer feignRetryer() {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Retryer.NEVER_RETRY;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     @Scope(&quot;prototype&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Feign.Builder feignBuilder(Retryer retryer) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Feign.builder().retryer(retryer);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     @ConditionalOnMissingBean(FeignLoggerFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; FeignLoggerFactory feignLoggerFactory() {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DefaultFeignLoggerFactory(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.logger);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     
&lt;span&gt;61&lt;/span&gt;     @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     @ConditionalOnClass({ HystrixCommand.&lt;span&gt;class&lt;/span&gt;, HystrixFeign.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HystrixFeignConfiguration {
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         @Scope(&quot;prototype&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;        @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         @ConditionalOnProperty(name = &quot;feign.hystrix.enabled&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Feign.Builder feignHystrixBuilder() {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; HystrixFeign.builder();
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这些其实就是 Feign 的核心组件了，对应的默认实现类如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201230145648465-460410046.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想自定义这些配置，可增加一个配置类，然后配置到 @FeignClient 的 configuration 上。&lt;/p&gt;
&lt;p&gt;① 先定义一个配置类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProducerFeignConfiguration {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Retryer feignRetryer() {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Retryer.Default();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 配置到 @FeignClient 中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @FeignClient(value = &quot;demo-producer&quot;, configuration = ProducerFeignConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ProducerFeignClient {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5、Feign 属性文件配置&lt;/h3&gt;
&lt;p&gt;① 全局配置&lt;/p&gt;
&lt;p&gt;前面已经了解到，@EnableFeignClients 的 defaultConfiguration 可以配置全局的默认配置bean对象。也可以使用 application.yml 文件来配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;feign:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  client:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;      # 默认全局配置
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;       &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         connectTimeout: 1000
&lt;span&gt;7&lt;/span&gt;         readTimeout: 1000
&lt;span&gt;8&lt;/span&gt;         loggerLevel: basic
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 指定客户端配置&lt;/p&gt;
&lt;p&gt;@FeignClient 的 configuration 可以配置客户端特定的配置类，也可以使用 application.yml 配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;feign:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  client:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      # 指定客户端名称
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       demo-&lt;span&gt;producer:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        # 连接超时时间
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         connectTimeout: 5000
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        # 读取超时时间
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         readTimeout: 5000
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        # Feign日志级别
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        loggerLevel: full
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        # Feign的错误解码器
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        errorDecoder: com.example.simpleErrorDecoder
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        # 配置拦截器
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        requestInterceptors:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;           -&lt;span&gt; com.example.FooRequestInterceptor
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;           -&lt;span&gt; com.example.BarRequestInterceptor
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        # 404是否解码
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         decode404: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        #Feign的编码器
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        encoder: com.example.simpleEncoder
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        #Feign的解码器
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        decoder: com.example.simpleDecoder
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        #Feign的Contract配置
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         contract: com.example.simpleContract
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，如果通过Java代码的方式配置过 Feign，然后又通过属性文件的方式配置 Feign，属性文件中Feign的配置会覆盖Java代码的配置。但是可以配置 feign.client.default-to-properties=false 来改变Feign配置生效的优先级。&lt;/p&gt;
&lt;p&gt;③ 开启压缩配置&lt;/p&gt;
&lt;p&gt;Spring Cloud Feign支持对请求和响应进行GZIP压缩，以提高通信效率。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;feign:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  compression:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    request:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      # 配置请求GZIP压缩
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       enabled: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;      # 配置压缩支持的 MIME TYPE
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       mime-types: text/xml,application/xml,application/&lt;span&gt;json
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;      # 配置压缩数据大小的下限
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       min-request-size: 2048
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    response:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;      # 配置响应GZIP压缩
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       enabled: &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6、FeignClient 开启日志&lt;/h3&gt;
&lt;p&gt;Feign 为每一个 FeignClient 都提供了一-个 feign.Logger 实例，可以在配置中开启日志。但是生产环境一般不要开启日志，因为接口调用可能会产生大量日志，一般在开发环境调试开启即可。&lt;/p&gt;
&lt;p&gt;① 通过配置文件开启日志&lt;/p&gt;
&lt;p&gt;首先设置客户端的 loggerLevel，然后配置 logging.level 日志级别为 debug。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;feign:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  client:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       demo-&lt;span&gt;producer:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        # Feign日志级别
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        loggerLevel: full
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;logging:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  level:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    # 设置日志输出级别
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     com.lyyzoo.sunny.register.feign: debug
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后调用 FeignClient 就可以看到接口调用日志了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 2020-12-30 15:33:02.459 DEBUG 2720 --- [nio-8020-exec-6] c.l.s.r.feign.ProducerFeignClient        : [ProducerFeignClient#getUserById] ---&amp;gt; GET http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;demo-producer/v1/user/1?name=tom HTTP/1.1&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 2020-12-30 15:33:02.459 DEBUG 2720 --- [nio-8020-exec-6] c.l.s.r.feign.ProducerFeignClient        : [ProducerFeignClient#getUserById] ---&amp;gt; END HTTP (0-&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; body)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 2020-12-30 15:33:02.462 DEBUG 2720 --- [nio-8020-exec-6] c.l.s.r.feign.ProducerFeignClient        : [ProducerFeignClient#getUserById] &amp;lt;--- HTTP/1.1 200&lt;span&gt; (3ms)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 2020-12-30 15:33:02.463 DEBUG 2720 --- [nio-8020-exec-6] c.l.s.r.feign.ProducerFeignClient        : [ProducerFeignClient#getUserById] connection: keep-&lt;span&gt;alive
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 2020-12-30 15:33:02.463 DEBUG 2720 --- [nio-8020-exec-6] c.l.s.r.feign.ProducerFeignClient        : [ProducerFeignClient#getUserById] content-type: application/&lt;span&gt;json
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 2020-12-30 15:33:02.463 DEBUG 2720 --- [nio-8020-exec-6] c.l.s.r.feign.ProducerFeignClient        : [ProducerFeignClient#getUserById] date: Wed, 30 Dec 2020 07:33:02&lt;span&gt; GMT
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 2020-12-30 15:33:02.463 DEBUG 2720 --- [nio-8020-exec-6] c.l.s.r.feign.ProducerFeignClient        : [ProducerFeignClient#getUserById] keep-alive: timeout=60
&lt;span&gt; 8&lt;/span&gt; 2020-12-30 15:33:02.463 DEBUG 2720 --- [nio-8020-exec-6] c.l.s.r.feign.ProducerFeignClient        : [ProducerFeignClient#getUserById] transfer-&lt;span&gt;encoding: chunked
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 2020-12-30 15:33:02.463 DEBUG 2720 --- [nio-8020-exec-6&lt;span&gt;] c.l.s.r.feign.ProducerFeignClient        : [ProducerFeignClient#getUserById] 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 2020-12-30 15:33:02.463 DEBUG 2720 --- [nio-8020-exec-6] c.l.s.r.feign.ProducerFeignClient        : [ProducerFeignClient#getUserById] {&quot;id&quot;:1,&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:10&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 2020-12-30 15:33:02.463 DEBUG 2720 --- [nio-8020-exec-6] c.l.s.r.feign.ProducerFeignClient        : [ProducerFeignClient#getUserById] &amp;lt;--- END HTTP (30-&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; body)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 2020-12-30 15:33:02.463  INFO 2720 --- [nio-8020-exec-6] c.l.s.r.controller.FeignController       : query user: User{id=1, name='tom', age=10}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 通过Java代码开启日志&lt;/p&gt;
&lt;p&gt;首先还是需要设置日志输出级别：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;logging:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  level:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    # 设置日志输出级别
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     com.lyyzoo.sunny.register.feign: debug
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后配置一个 feign.Logger.Level 对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Bean
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; feign.Logger.Level loggerLevel() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Logger.Level.FULL;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ Logger.Level&lt;/p&gt;
&lt;p&gt;Logger.Level 的具体级别如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Level {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不打印任何日志&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    NONE,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只打印请求的方法和URL，以及响应状态码和执行时间&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    BASIC,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在BASIC的基础上，打印请求头和响应头信息&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    HEADERS,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录所有请求与相应的明细，包含请求头、请求体、元数据&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    FULL
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二、扫描 @FeignClient 注解接口&lt;/h2&gt;
&lt;p&gt;Feign 是一个伪 Java HTTP 客户端，Feign 不做任何的请求处理，它只是简化API调用的开发，开发人员只需定义客户端接口，按照 springmvc 的风格开发声明式接口。然后在使用过程中我们只需要依赖注入Bean，然后调用对应的方法传递参数即可。&lt;/p&gt;
&lt;p&gt;这里就有个问题，我们开发的是一个接口，然后使用 @FeignClient 注解标注，那又是如何能够注入这个接口的Bean对象的呢？其实很容易就能想到，一定是生成了接口的动态代理并注入到Spring容器中了，才能依赖注入这个客户端接口。这节就来看看 feign 是如何生成动态代理对象的。&lt;/p&gt;
&lt;h3&gt;1、FeignClient 动态注册组件 FeignClientsRegistrar&lt;/h3&gt;
&lt;p&gt;再看下 @EnableFeignClients  注解，它使用 @Import 导入了 FeignClientsRegistrar，FeignClient 注册者。从名字就可以看出，FeignClientsRegistrar 就是完成 FeignClient 注册的核心组件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@Target(ElementType.TYPE)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@Documented
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; FeignClient 注册处理类&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; @Import(FeignClientsRegistrar.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; EnableFeignClients {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FeignClientsRegistrar 实现了 ImportBeanDefinitionRegistrar, ResourceLoaderAware, EnvironmentAware 三个接口。&lt;/p&gt;
&lt;p&gt;ResourceLoaderAware 是为了注入资源加载器 ResourceLoader，EnvironmentAware 是为了注入当前环境组件 Environment，ImportBeanDefinitionRegistrar 是 Spring 动态注册 bean 的接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FeignClientsRegistrar &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ImportBeanDefinitionRegistrar, ResourceLoaderAware, EnvironmentAware {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; patterned after Spring Integration IntegrationComponentScanRegistrar
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; and RibbonClientsConfigurationRegistgrar
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 资源加载器&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ResourceLoader resourceLoader;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前环境组件&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Environment environment;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ImportBeanDefinitionRegistrar 主要包含一个接口 registerBeanDefinitions，就是用来动态注册 BeanDefinition 的。平时我们一般就使用 @Service、@Component、@Bean 等注解向 Spring 容器注册对象，我们也可以实现 ImportBeanDefinitionRegistrar 接口来动态注册 BeanDefinition。&lt;/p&gt;
&lt;p&gt;所有实现了 ImportBeanDefinitionRegistrar  接口的类的都会被 ConfigurationClassPostProcessor 处理，ConfigurationClassPostProcessor 实现了 BeanFactoryPostProcessor 接口，所以 ImportBeanDefinitionRegistrar 中动态注册的bean是优先于依赖它的bean初始化的，也能被aop、validator等机制处理。ImportBeanDefinitionRegistrar 实现类写好之后，还要使用 @Import 注解导入实现类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ImportBeanDefinitionRegistrar {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * Register bean definitions as necessary based on the given annotation metadata of
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * the importing {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Configuration} class.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;Note that {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; BeanDefinitionRegistryPostProcessor} types may &amp;lt;em&amp;gt;not&amp;lt;/em&amp;gt; be
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * registered here, due to lifecycle constraints related to {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; @Configuration}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * class processing.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;The default implementation is empty.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; importingClassMetadata annotation metadata of the importing class
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; registry current bean definition registry
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BeanDefinition 又是什么呢？从注释可以了解到，BeanDefinition 就是用来描述 bean 实例的，BeanDefinition 包含了实例的属性值、构造函数参数等。其实就是通过这个 BeanDefinition 来获取实例对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 &lt;span&gt;/**
&lt;span&gt; 2 &lt;span&gt; * A BeanDefinition describes a bean instance, which has property values,
&lt;span&gt; 3 &lt;span&gt; * constructor argument values, and further information supplied by
&lt;span&gt; 4 &lt;span&gt; * concrete implementations.
&lt;span&gt; 5 &lt;span&gt; *
&lt;span&gt; 6 &lt;span&gt; * &amp;lt;p&amp;gt;This is just a minimal interface: The main intention is to allow a
&lt;span&gt; 7 &lt;span&gt; * {&lt;span&gt;@link&lt;span&gt; BeanFactoryPostProcessor} to introspect and modify property values
&lt;span&gt; 8 &lt;span&gt; * and other bean metadata.
&lt;span&gt; 9  &lt;span&gt;*/
&lt;span&gt;10 &lt;span&gt;public &lt;span&gt;interface BeanDefinition &lt;span&gt;extends&lt;span&gt; AttributeAccessor, BeanMetadataElement { 
&lt;span&gt;11 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FeignClientsRegistrar 实现的 registerBeanDefinitions 方法中，主要有两步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注册FeignClient默认配置对象，就是根据 @EnableFeignClients 的 defaultConfiguration 配置类注入默认配置，这个一般就是全局配置。&lt;/li&gt;
&lt;li&gt;之后就是扫描 @FeignClient 注解的接口，封装成 BeanDefinition，然后用 BeanDefinitionRegistry 来注册。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，FeignClientsRegistrar 就是扫描 @FeignClient 注解的接口，并注册 FeignClient 的核心组件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据注解元数据注册bean定义&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册 FeignClient 默认配置类，根据 @EnableFeignClients 的 defaultConfiguration 注入默认配置&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    registerDefaultConfiguration(metadata, registry);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扫描 FeignClient 接口，注册 FeignClient&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    registerFeignClients(metadata, registry);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、扫描 @FeignClient 注解接口&lt;/h3&gt;
&lt;p&gt;接着看 registerFeignClients 方法，这个方法主要就是完成扫描 @FeignClient 注解的接口并完成 FeignClient 注册的工作。&lt;/p&gt;
&lt;p&gt;主要的流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先得到一个类路径扫描器 ClassPathScanningCandidateComponentProvider，就是用这个组件来扫描包路径获取到 @FeignClient 注解的接口。&lt;/li&gt;
&lt;li&gt;如果 @EnableFeignClients 没有配置 clients 属性，扫描的包路径就是 @EnableFeignClients 配置的 value、basePackages、basePackageClasses 配置的包路径。并且根据注解过滤器来筛选有 @FeignClient 注解的接口。&lt;/li&gt;
&lt;li&gt;如果 @EnableFeignClients 配置了 clients 属性，就只扫描 clients 配置的接口类。&lt;/li&gt;
&lt;li&gt;之后就遍历扫描包路径，获取到 @FeignClient 注解的接口。可以看到 @FeignClient 注解的类型必须是一个接口，否则断言会抛出异常。&lt;/li&gt;
&lt;li&gt;最后两步就是注册配置类和注册 FeignClient了，配置类就是 @FeignClient 的 configuration 属性配置的客户端配置类，这个配置类将覆盖 @EnableFeignClients 配置的全局配置类。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; **
&lt;span&gt; 2&lt;/span&gt;  *&lt;span&gt; 注册 FeignClient
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  *
&lt;span&gt; 4&lt;/span&gt;  *&lt;span&gt; @param metadata @EnableFeignClients 注解的元数据
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  *&lt;span&gt; @param registry BeanDefinition 注册器
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  */
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerFeignClients(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ClassPath 扫描器&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     ClassPathScanningCandidateComponentProvider scanner =&lt;span&gt; getScanner();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     scanner.setResourceLoader(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourceLoader);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     Set&amp;lt;String&amp;gt;&lt;span&gt; basePackages;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; @EnableFeignClients 注解的属性&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     Map&amp;lt;String, Object&amp;gt; attrs = metadata.getAnnotationAttributes(EnableFeignClients.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注解类型过滤器，过滤 @FeignClient 注解的接口&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     AnnotationTypeFilter annotationTypeFilter = &lt;span&gt;new&lt;/span&gt; AnnotationTypeFilter(FeignClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt;[] clients = attrs == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt; : (Class&amp;lt;?&amp;gt;[]) attrs.get(&quot;clients&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 @EnableFeignClients 没有配置 clients，就取 value、basePackages、basePackageClasses 基础包&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (clients == &lt;span&gt;null&lt;/span&gt; || clients.length == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; @FeignClient 注解过滤器&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        scanner.addIncludeFilter(annotationTypeFilter);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         basePackages =&lt;span&gt; getBasePackages(metadata);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 @EnableFeignClients 中配置了 clients&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Set&amp;lt;String&amp;gt; clientClasses = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         basePackages = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; clazz : clients) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基础包取配置的 client 类所在的包&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            basePackages.add(ClassUtils.getPackageName(clazz));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据名称过滤&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            clientClasses.add(clazz.getCanonicalName());
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类过滤器&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         AbstractClassTestingTypeFilter filter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AbstractClassTestingTypeFilter() {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; match(ClassMetadata metadata) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 String cleaned = metadata.getClassName().replaceAll(&quot;\\$&quot;, &quot;.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据名称过滤&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; clientClasses.contains(cleaned);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须类名在 clientClasses 中且类上有 @FeignClient 注解&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         scanner.addIncludeFilter(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扫描基础包&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String basePackage : basePackages) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         Set&amp;lt;BeanDefinition&amp;gt; candidateComponents =&lt;span&gt; scanner.findCandidateComponents(basePackage);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (BeanDefinition candidateComponent : candidateComponents) {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (candidateComponent &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AnnotatedBeanDefinition) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; verify annotated class is an interface&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;                 AnnotatedBeanDefinition beanDefinition =&lt;span&gt; (AnnotatedBeanDefinition) candidateComponent;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 AnnotationMetadata annotationMetadata =&lt;span&gt; beanDefinition.getMetadata();
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; @FeignClient 注解的类型必须是一个接口&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                Assert.isTrue(annotationMetadata.isInterface(),
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                         &quot;@FeignClient can only be specified on an interface&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; @FeignClient 注解的属性&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;                 Map&amp;lt;String, Object&amp;gt; attributes =&lt;span&gt; annotationMetadata
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                         .getAnnotationAttributes(FeignClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getCanonicalName());
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Feign 客户端名称，就是服务名&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;                 String name =&lt;span&gt; getClientName(attributes);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注解客户端配置类&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;                 registerClientConfiguration(registry, name, attributes.get(&quot;configuration&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册 FeignClient&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;                registerFeignClient(registry, annotationMetadata, attributes);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看下 getBasePackages 方法，可以看出，要扫描的包路径包含 @EnableFeignClients 配置的 value、basePackages、basePackageClasses 类所在的包，这里是取的多个配置的并集。&lt;/p&gt;
&lt;p&gt;还有个需要注意的是，从最后一步可以看出，如果配置了 value、basePackages、basePackageClasses 时，就不会扫描 @EnableFeignClients 所在的包路径了，如果要扫描，需配置到 value 等属性中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt; getBasePackages(AnnotationMetadata importingClassMetadata) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Map&amp;lt;String, Object&amp;gt; attributes =&lt;span&gt; importingClassMetadata
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             .getAnnotationAttributes(EnableFeignClients.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getCanonicalName());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     Set&amp;lt;String&amp;gt; basePackages = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先取 value&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (String pkg : (String[]) attributes.get(&quot;value&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.hasText(pkg)) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            basePackages.add(pkg);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再取 basePackages&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (String pkg : (String[]) attributes.get(&quot;basePackages&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.hasText(pkg)) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            basePackages.add(pkg);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再从 basePackageClasses 的 Class 获取包&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt; clazz : (Class[]) attributes.get(&quot;basePackageClasses&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        basePackages.add(ClassUtils.getPackageName(clazz));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只有当没有配置 value、basePackages、basePackageClasses 时，才会扫描 @EnableFeignClients 所在的包路径&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (basePackages.isEmpty()) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        basePackages.add(ClassUtils.getPackageName(importingClassMetadata.getClassName()));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; basePackages;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、@FeignClient 接口构造 BeanDefinition 并注册&lt;/h3&gt;
&lt;p&gt;registerFeignClients 中扫描了包路径下的 @FeignCient 注解的接口，然后调用了 registerFeignClient 注册 FeignClient 接口的 BeanDefinition。&lt;/p&gt;
&lt;p&gt;主要的流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先创建了 BeanDefinitionBuilder，要构建的类型是 FeignClientFactoryBean，从名字可以看出就是创建 FeignClient 代理对象的工厂类。FeignClientFactoryBean 就是生成 FeignClient 接口动态代理的核心组件。&lt;/li&gt;
&lt;li&gt;接着就是将 @FeignClient 注解的属性设置到 definition 中，它这里还设置了回调类 fallback 和回调工厂 fallbackFactory，但是有没有用呢？这个后面再分析。&lt;/li&gt;
&lt;li&gt;然后是 bean 的名称，默认为 服务名称 + &quot;FeignClient&quot;，例如 &quot;demo-consumerFeignClient&quot;；如果设置了 qualifier 属性，名称就是 qualifier 设置的值。&lt;/li&gt;
&lt;li&gt;之后用 BeanDefinitionBuilder 获取 BeanDefinition，并设置了对象类型为 FeignClient 接口的全限定名。&lt;/li&gt;
&lt;li&gt;最后，将 BeanDefinition 等信息封装到 BeanDefinitionHolder，然后调用 BeanDefinitionReaderUtils.registerBeanDefinition 将 BeanDefinition 注册到Spring IoC 容器中。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerFeignClient(BeanDefinitionRegistry registry,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         AnnotationMetadata annotationMetadata, Map&amp;lt;String, Object&amp;gt;&lt;span&gt; attributes) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     String className =&lt;span&gt; annotationMetadata.getClassName();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; FeignClientFactoryBean 就是用来生成 FeignClient 接口代理类的核心组件&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     BeanDefinitionBuilder definition =&lt;span&gt; BeanDefinitionBuilder
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             .genericBeanDefinition(FeignClientFactoryBean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    validate(attributes);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从 @FeignClient 中得到的属性，并设置到 BeanDefinitionBuilder&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     definition.addPropertyValue(&quot;url&quot;&lt;span&gt;, getUrl(attributes));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     definition.addPropertyValue(&quot;path&quot;&lt;span&gt;, getPath(attributes));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     String name =&lt;span&gt; getName(attributes);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     definition.addPropertyValue(&quot;name&quot;&lt;span&gt;, name);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     String contextId =&lt;span&gt; getContextId(attributes);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     definition.addPropertyValue(&quot;contextId&quot;&lt;span&gt;, contextId);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     definition.addPropertyValue(&quot;type&quot;&lt;span&gt;, className);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     definition.addPropertyValue(&quot;decode404&quot;, attributes.get(&quot;decode404&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     definition.addPropertyValue(&quot;fallback&quot;, attributes.get(&quot;fallback&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     definition.addPropertyValue(&quot;fallbackFactory&quot;, attributes.get(&quot;fallbackFactory&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bean 的别名，demo-consumerFeignClient&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     String alias = contextId + &quot;FeignClient&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     AbstractBeanDefinition beanDefinition =&lt;span&gt; definition.getBeanDefinition();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bean 的类型，就是 FeignClient 接口&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    beanDefinition.setAttribute(FactoryBean.OBJECT_TYPE_ATTRIBUTE, className);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; has a default, won't be null&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; primary = (Boolean) attributes.get(&quot;primary&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    beanDefinition.setPrimary(primary);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义的别名标识&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     String qualifier =&lt;span&gt; getQualifier(attributes);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.hasText(qualifier)) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         alias =&lt;span&gt; qualifier;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将信息都封装到 BeanDefinitionHolder&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     BeanDefinitionHolder holder = &lt;span&gt;new&lt;/span&gt; BeanDefinitionHolder(beanDefinition, className, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[] { alias });
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册bean&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、一张图总结 @FeignClient 接口扫描流程&lt;/h3&gt;
&lt;p&gt;下面用一张图来总结下 @FeignClient 接口是如何被扫描并注册到容器中的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先我们在代码中开发了 FeignClient 客户端调用接口，并用 @FeignClient 注解，注意 @FeignClient 只能加到接口上面。&lt;/li&gt;
&lt;li&gt;之后我们需要在启动类或配置类中加一个 @EnableFeignClients 注解来启用 FeignClien。@EnableFeignClients 其实就是导入了 FeignClient 注册器 FeignClientsRegistrar。&lt;/li&gt;
&lt;li&gt;FeignClientsRegistrar 实现了 ImportBeanDefinitionRegistrar 接口，在 registerBeanDefinitions 实现中，主要有两步：
&lt;ul&gt;&lt;li&gt;注册全局配置配置类，就是 @EnableFeignClients 中指定的 defaultConfiguration&lt;/li&gt;
&lt;li&gt;接着就是扫描注册 FeignClient&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;注册客户端时，先用 ClassPathScanningCandidateComponentProvider 扫描器扫描出配置的包下的 @FeignClient 注解的接口&lt;/li&gt;
&lt;li&gt;扫描到 @FeignClient 接口后，先注册客户端特定的配置，就是 @FeignClient 配置的 configuration。&lt;/li&gt;
&lt;li&gt;接着注册客户端：
&lt;ul&gt;&lt;li&gt;先构建一个 BeanDefinitionBuilder，要创建的 BeanDefinition 类型是 FeignClientFactoryBean。&lt;/li&gt;
&lt;li&gt;然后就是将 @FeignClient 中的配置设置到 BeanDefinitionBuilder，其实就是设置给 FeignClientFactoryBean。&lt;/li&gt;
&lt;li&gt;之后解析出 FeignClient 的别名，默认是 服务名+“FeignClient”。&lt;/li&gt;
&lt;li&gt;再用 BeanDefinitionBuilder 构建出 BeanDefinition，并将相关信息封装到 BeanDefinitionHolder 中。&lt;/li&gt;
&lt;li&gt;最后使用 BeanDefinitionReaderUtils 完成 BeanDefinition 的注册。&lt;/li&gt;
&lt;li&gt;将 BeanDefinition 注入容器后，就会调用 FeignClientFactoryBean 的 getObject 方法来创建动态代理。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202101/856154-20210106011204116-790529580.png&quot; width=&quot;1600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、构建 @FeignClient 接口动态代理&lt;/h2&gt;
&lt;h3&gt;1、构造 FeignClient 的动态代理组件 FeignClientFactoryBean&lt;/h3&gt;
&lt;p&gt;FeignClientFactoryBean 这个组件就是生成 FeignClient 接口动态代理的组件。&lt;/p&gt;
&lt;p&gt;FeignClientFactoryBean 实现了 FactoryBean 接口，当一个Bean实现了 FactoryBean 接口后，Spring 会先实例化这个工厂，然后调用 getObject() 创建真正的Bean。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FeignClientFactoryBean &lt;span&gt;implements&lt;/span&gt; FactoryBean&amp;lt;Object&amp;gt;&lt;span&gt;, InitializingBean, ApplicationContextAware {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FeignClientFactoryBean 实现了 getObject 方法，它又调用了 getTarget 方法，getTarget 最后就创建了 FeignClient 接口的动态代理对象。&lt;/p&gt;
&lt;p&gt;创建动态代理对象的主要流程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先获取了 Feign 上下文 FeignContext，FeignContext 跟 Ribbon 中 SpringClientFactory 是类似的，可以获取到每个服务的上下文。因为每个服务都有自己的配置、Encoder、Decoder 组件等，所以可以从 FeignContext 中获取到当前服务的组件。&lt;/li&gt;
&lt;li&gt;然后从 FeignContext 中得到了 Feign.Builder，这个 Feign.Builder 就是最终用来创建动态代理对象的构造器。&lt;/li&gt;
&lt;li&gt;@FeignClient 如果没有配置 url，就会通过服务名称构造带服务名的url地址，跟 RestTemplate 类似，最终肯定就是走负载均衡的请求；如果配置了 url，就是直接调用这个地址。&lt;/li&gt;
&lt;li&gt;都会从 FeignContext 中获取一个 Client，如果配置了 url，就是获取 client 里的代理对象，并设置到 builder 中；否则就直接将 Client 设置到 builder。也就是说根据 url 判断是否使用负载均衡的 Client。&lt;/li&gt;
&lt;li&gt;最终都会调用 Targeter 的 target 方法来构造动态代理对象，target 传入的参数包括当前的 FeignClientFactoryBean 对象、Feign.Builder、FeignContext，以及封装的 HardCodedTarget 对象。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 FeignClient 代理对象的入口&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Object getObject() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getTarget();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * 创建一个 FeignClient 接口的代理对象，T 就是 @FeignClient 注解的接口类型
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt; the target type of the Feign client
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; a {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Feign} client created with the specified data and the context information
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T getTarget() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Feign 上下文&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     FeignContext context = applicationContext.getBean(FeignContext.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Feign 构造器&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     Feign.Builder builder =&lt;span&gt; feign(context);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有直接配置 url，就走负载均衡请求&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;StringUtils.hasText(url)) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!name.startsWith(&quot;http&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             url = &quot;http://&quot; +&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             url =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 带服务名的地址 =&amp;gt; &lt;/span&gt;&lt;span&gt;http://demo-consumer&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         url +=&lt;span&gt; cleanPath();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回的类型肯定是具备负载均衡能力的；HardCodedTarget =&amp;gt; 硬编码的 Target&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (T) loadBalance(builder, context, &lt;span&gt;new&lt;/span&gt; HardCodedTarget&amp;lt;&amp;gt;&lt;span&gt;(type, name, url));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果配置了 url，就直接请求 url 地址&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (StringUtils.hasText(url) &amp;amp;&amp;amp; !url.startsWith(&quot;http&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         url = &quot;http://&quot; +&lt;span&gt; url;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     String url = &lt;span&gt;this&lt;/span&gt;.url +&lt;span&gt; cleanPath();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Client =&amp;gt; Feign 发起 HTTP 调用的核心组件&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     Client client = getOptional(context, Client.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (client != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (client &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; LoadBalancerFeignClient) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到的是代理对象，就是原生的 Client.Default&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;             client =&lt;span&gt; ((LoadBalancerFeignClient) client).getDelegate();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (client &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; FeignBlockingLoadBalancerClient) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到的是代理对象，就是原生的 Client.Default&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;             client =&lt;span&gt; ((FeignBlockingLoadBalancerClient) client).getDelegate();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        builder.client(client);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     Targeter targeter = get(context, Targeter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; targeter 创建动态代理对象&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (T) targeter.target(&lt;span&gt;this&lt;/span&gt;, builder, context, &lt;span&gt;new&lt;/span&gt; HardCodedTarget&amp;lt;&amp;gt;&lt;span&gt;(type, name, url));
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt; T loadBalance(Feign.Builder builder, FeignContext context, HardCodedTarget&amp;lt;T&amp;gt;&lt;span&gt; target) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 Client&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     Client client = getOptional(context, Client.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (client != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        builder.client(client);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Targeter =&amp;gt; HystrixTargeter&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         Targeter targeter = get(context, Targeter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; targeter 创建动态代理对象&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; targeter.target(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, builder, context, target);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &quot;No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、Feign 动态代理构造器 &lt;span&gt;Feign.Builder&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;feign() 方法返回了 Feign.Builder，它也是从 FeignContext 中获取的，这个方法最重要的是设置了 Logger、Encoder、Decoder、Contract，并读取配置文件中 feign.client.* 相关的配置。FeignClientsConfiguration 中配置了这几个接口的默认实现类，我们也可以自定义这几个实现类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Feign.Builder feign(FeignContext context) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     FeignLoggerFactory loggerFactory = get(context, FeignLoggerFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Logger logger =&lt;span&gt; loggerFactory.create(type);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们可以定制 Logger、Encoder、Decoder、Contract&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     Feign.Builder builder = get(context, Feign.Builder.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; required values&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            .logger(logger)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             .encoder(get(context, Encoder.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             .decoder(get(context, Decoder.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             .contract(get(context, Contract.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; @formatter:on
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取配置文件中 feign.client.* 的配置来配置 Feign&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    configureFeign(context, builder);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Feign.Builder 的默认实现是什么呢？从 FeignClientsConfiguration 中可以知道，默认情况下就是 Feign.Builder，如果启用了 feign.hystrix.enabled，那默认实现就是 HystrixFeign.Builder。&lt;/p&gt;
&lt;p&gt;那 Feign.Builder 和 HystrixFeign.Build 有什么区别呢？对比下不难发现，主要区别就是创建动态代理的实现类 InvocationHandler 是不同的，在启用 hystrix 的情况下，会涉及到熔断、降级等，HystrixFeign.Build 也会设置 @FeignClient 配置的 fallback、fallbackFactory 降级配置类。这块等后面分析 hystrix 源码时再来看。现在只需要知道，feign 没有启用 hystrix，@FeignClient 配置的 fallback、fallbackFactory 降级回调是不生效的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FeignClientsConfiguration {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Retryer feignRetryer() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从不重试&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Retryer.NEVER_RETRY;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     @Scope(&quot;prototype&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Feign.Builder feignBuilder(Retryer retryer) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认为 Feign.Builder&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Feign.builder().retryer(retryer);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     @ConditionalOnClass({ HystrixCommand.&lt;span&gt;class&lt;/span&gt;, HystrixFeign.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HystrixFeignConfiguration {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入了 hystrix 并且，feign.hystrix.enabled = true&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         @Scope(&quot;prototype&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         @ConditionalOnProperty(name = &quot;feign.hystrix.enabled&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Feign.Builder feignHystrixBuilder() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; feign 启用 hystrix 后，Feign.Builder 就是 HystrixFeign.Builder&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; HystrixFeign.builder();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;configureFeign 就是配置 Feign.Builder 的，从这个方法可以了解到，feign 配置生效的优先级。&lt;/p&gt;
&lt;p&gt;Feign 有三块配置，一个是可以通过 Configuration 的方式配置，然后设置到 @FeignClient 的 configuration 参数；然后是全局的 feign.client.default 默认配置，以及服务特定的配置 feign.client.&amp;lt;clientName&amp;gt;。&lt;/p&gt;
&lt;p&gt;从 configureFeign 方法可以看出，默认情况下，优先级最低的是代码配置，其次是默认配置，最高优先级的是服务特定的配置。&lt;/p&gt;
&lt;p&gt;如果想使代码配置优先级高于文件中的配置，可以设置 feign.client.defalut-to-properties=false 来改变 Feign 配置生效的优先级。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configureFeign(FeignContext context, Feign.Builder builder) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置文件中 feign.client.* 客户端配置&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     FeignClientProperties properties = applicationContext.getBean(FeignClientProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     FeignClientConfigurer feignClientConfigurer = getOptional(context, FeignClientConfigurer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    setInheritParentContext(feignClientConfigurer.inheritParentConfiguration());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (properties != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; inheritParentContext) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; defaultToProperties：优先使用配置文件中的配置&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (properties.isDefaultToProperties()) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最低优先级：使用代码中的 Configuration 配置&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            configureUsingConfiguration(context, builder);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 次优先级：使用 feign.client.default 默认配置&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 高优先级：使用 feign.client.&amp;lt;clientName&amp;gt; 定义的配置&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            configureUsingProperties(properties.getConfig().get(contextId), builder);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 优先使用Java代码的配置&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            configureUsingProperties(properties.getConfig().get(properties.getDefaultConfig()), builder);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            configureUsingProperties(properties.getConfig().get(contextId), builder);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            configureUsingConfiguration(context, builder);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        configureUsingConfiguration(context, builder);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、Feign 网络调用组件 Client&lt;/h3&gt;
&lt;p&gt;Client 是 feign-core 中的组件，它只有一个接口 execute，这个接口就是调用 Request 的 url，然后将返回接口封装到 Response 中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Client {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;   * Executes a request against its {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Request#url() url} and returns a response.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;   *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;   * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request safe to replay.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;   * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; options options to apply to this request.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; connected response, {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Response.Body} is absent or unread.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;   * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException on a network error connecting to {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Request#url()}.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   Response execute(Request request, Options options) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Client 有如下的一些实现类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202101/856154-20210104225439699-1003257001.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Client 的自动化配置类是 FeignRibbonClientAutoConfiguration，FeignRibbonClientAutoConfiguration 导入了 HttpClient、OkHttp 以及默认的 Feign 负载均衡配置类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @ConditionalOnClass({ ILoadBalancer.&lt;span&gt;class&lt;/span&gt;, Feign.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @ConditionalOnProperty(value = &quot;spring.cloud.loadbalancer.ribbon.enabled&quot;, matchIfMissing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; @AutoConfigureBefore(FeignAutoConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; @EnableConfigurationProperties({ FeignHttpClientProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; @Import({ HttpClientFeignLoadBalancedConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         OkHttpFeignLoadBalancedConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         DefaultFeignLoadBalancedConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; })
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FeignRibbonClientAutoConfiguration {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;① 启用 apache httpclient&lt;/p&gt;
&lt;p&gt;从 HttpClientFeignLoadBalancedConfiguration 的配置可以看出，要启用 apache httpclient，需设置 feign.httpclient.enabled=true（默认为 true），并且需要加入了 feign-httpclient 的依赖（ApacheHttpClient）&lt;/p&gt;
&lt;p&gt;启用 apache httpclient 后，LoadBalancerFeignClient 的代理对象就是 feign-httpclient 中的 ApacheHttpClient。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @ConditionalOnClass(ApacheHttpClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; @ConditionalOnProperty(value = &quot;feign.httpclient.enabled&quot;, matchIfMissing = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; @Import(HttpClientFeignConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpClientFeignLoadBalancedConfiguration {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     @ConditionalOnMissingBean(Client.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            SpringClientFactory clientFactory, HttpClient httpClient) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         ApacheHttpClient delegate = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApacheHttpClient(httpClient);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 启用 okhttp&lt;/p&gt;
&lt;p&gt;从 OkHttpFeignLoadBalancedConfiguration  的配置可以看出，要启用 okhttp，需设置 feign.okhttp.enabled=true，且需要引入 feign-okhttp 的依赖（OkHttpClient）。&lt;/p&gt;
&lt;p&gt;启用 okhttp 后，LoadBalancerFeignClient 的代理对象就是 feign-okhttp 的 OkHttpClient。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @ConditionalOnClass(OkHttpClient.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; @ConditionalOnProperty(&quot;feign.okhttp.enabled&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; @Import(OkHttpFeignConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OkHttpFeignLoadBalancedConfiguration {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     @ConditionalOnMissingBean(Client.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            SpringClientFactory clientFactory, okhttp3.OkHttpClient okHttpClient) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         OkHttpClient delegate = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OkHttpClient(okHttpClient);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 默认配置&lt;/p&gt;
&lt;p&gt;没有引入 feign-httpclient 或者 feign-okhttp，就会走默认的 DefaultFeignLoadBalancedConfiguration。而默认的代理对象 Client.Default 其实就是使用 HttpURLConnection 发起 HTTP 调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultFeignLoadBalancedConfiguration {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            SpringClientFactory clientFactory) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LoadBalancerFeignClient(&lt;span&gt;new&lt;/span&gt; Client.Default(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;), cachingFactory,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                clientFactory);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，三个配置类创建的 Client 对象都是 LoadBalancerFeignClient，也就是支持负载均衡的请求。只是代理类不同，也就是最终发起 HTTP 调用的组件是不同的，默认配置下的代理类是 Client.Default，底层就是 HttpURLConnection。&lt;/p&gt;
&lt;p&gt;这块其实跟分析 Ribbon 源码时，RestTemplate 的负载均衡是类似的。&lt;/p&gt;
&lt;h3&gt;4、动态代理目标器 Targeter&lt;/h3&gt;
&lt;p&gt;Targeter 接口只有一个接口方法，就是通过 target 方法获取动态代理对象。Targeter 有 DefaultTargeter、HystrixTargeter 两个实现类，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Targeter {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &amp;lt;T&amp;gt;&lt;span&gt; T target(FeignClientFactoryBean factory, Feign.Builder feign,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             FeignContext context, Target.HardCodedTarget&amp;lt;T&amp;gt;&lt;span&gt; target);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 FeignAutoConfiguration 配置类中可看到，只要引入了 HystrixFeign，Targeter 的默认实现就是 HystrixTargeter。&lt;/p&gt;
&lt;p&gt;HystrixTargeter 一看就是用来整合 feign 和 hystrix 的，使 feign 调用可以实现熔断、限流、降级。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FeignAutoConfiguration {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     @ConditionalOnClass(name = &quot;feign.hystrix.HystrixFeign&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HystrixFeignTargeterConfiguration {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Targeter feignTargeter() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HystrixTargeter();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     @Configuration(proxyBeanMethods = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     @ConditionalOnMissingClass(&quot;feign.hystrix.HystrixFeign&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultFeignTargeterConfiguration {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        @Bean
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        @ConditionalOnMissingBean
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Targeter feignTargeter() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultTargeter();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到 HystrixTargeter 和 DefaultTargeter 的区别就在于 HystrixTargeter  会向 Feign.Builder 设置降级回调处理类，这样 feign 调用触发熔断、降级时，就可以进入回调类处理。&lt;/p&gt;
&lt;p&gt;它们本质上最终来说都是调用 Feign.Builder 的 target 方法创建动态代理对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HystrixTargeter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Targeter {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T target(FeignClientFactoryBean factory, Feign.Builder feign,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                         FeignContext context, Target.HardCodedTarget&amp;lt;T&amp;gt;&lt;span&gt; target) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(feign &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; feign.hystrix.HystrixFeign.Builder)) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 非 HystrixFeign.Builder 类型，就直接调用 target 方法&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; feign.target(target);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Feign 启用了 hystrix 后，就会向 HystrixFeign.Builder 设置回调类或回调工厂&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         feign.hystrix.HystrixFeign.Builder builder =&lt;span&gt; (feign.hystrix.HystrixFeign.Builder) feign;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         String name = StringUtils.isEmpty(factory.getContextId()) ?&lt;span&gt; factory.getName() : factory.getContextId();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         SetterFactory setterFactory = getOptional(name, context, SetterFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (setterFactory != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            builder.setterFactory(setterFactory);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Class&amp;lt;?&amp;gt; fallback =&lt;span&gt; factory.getFallback();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置回调类&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (fallback != &lt;span&gt;void&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetWithFallback(name, context, target, builder, fallback);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置回调工厂类&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         Class&amp;lt;?&amp;gt; fallbackFactory =&lt;span&gt; factory.getFallbackFactory();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (fallbackFactory != &lt;span&gt;void&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetWithFallbackFactory(name, context, target, builder, fallbackFactory);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; feign.target(target);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultTargeter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Targeter {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T target(FeignClientFactoryBean factory, Feign.Builder feign,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             FeignContext context, Target.HardCodedTarget&amp;lt;T&amp;gt;&lt;span&gt; target) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; feign.target(target);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5、Feign.Builder 创建动态代理&lt;/h3&gt;
&lt;p&gt;前面已经分析出，Feign.Builder 的默认实现就是 Feign.Builder，HystrixTargeter 中调用了 Feign.Builder 的 target 方法来创建动态代理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;target 方法中首先调用 build() 方法构建出 Feign，然后调用 Feign 的 newInstance 创建动态代理对象。&lt;/li&gt;
&lt;li&gt;build() 方法中首先读取配置的 Client、Retryer、Logger、Contract、Encoder、Decoder 等对象。&lt;/li&gt;
&lt;li&gt;然后获取了 InvocationHandlerFactory，默认就是 InvocationHandlerFactory.Default，这是 feign 提供的一个工厂类来创建代理对象 InvocationHandler。&lt;/li&gt;
&lt;li&gt;接着创建了接口方法处理器工厂 SynchronousMethodHandler.Factor，它就是用来将接口方法封装成一个方法执行器 MethodHandler，默认实现类是 SynchronousMethodHandler。&lt;/li&gt;
&lt;li&gt;还创建了 springmvc 注解处理器 ParseHandlersByName，可想而知，这就是用来处理接口中的 springmvc 注解的，将 REST 接口解析生成 MethodHandler。&lt;/li&gt;
&lt;li&gt;最后创建了 Feign 对象，实现类是 ReflectiveFeign，之后就是使用 ReflectiveFeign 来创建动态代理对象了。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T target(Target&amp;lt;T&amp;gt;&lt;span&gt; target) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; build().newInstance(target);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构建 Feign&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Feign build() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Feign Http调用客户端，默认为 Client.Default&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     Client client = Capability.enrich(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.client, capabilities);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重试器，默认是重不重试&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     Retryer retryer = Capability.enrich(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.retryer, capabilities);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Feign 请求拦截器，可以对 Feign 请求模板RequestTemplate做一些定制化处理&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     List&amp;lt;RequestInterceptor&amp;gt; requestInterceptors = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestInterceptors.stream()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       .map(ri -&amp;gt;&lt;span&gt; Capability.enrich(ri, capabilities))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;      .collect(Collectors.toList());
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 日志组件，默认为 Slf4jLogger      &lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     Logger logger = Capability.enrich(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.logger, capabilities);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接口协议组件，默认为 SpringMvcContract&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     Contract contract = Capability.enrich(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.contract, capabilities);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置类&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     Options options = Capability.enrich(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.options, capabilities);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编码器&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     Encoder encoder = Capability.enrich(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.encoder, capabilities);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解码器&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     Decoder decoder = Capability.enrich(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.decoder, capabilities);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 InvocationHandler 的工厂类&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     InvocationHandlerFactory invocationHandlerFactory =
&lt;span&gt;27&lt;/span&gt;       Capability.enrich(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.invocationHandlerFactory, capabilities);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     QueryMapEncoder queryMapEncoder = Capability.enrich(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.queryMapEncoder, capabilities);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接口方法处理器工厂&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     SynchronousMethodHandler.Factory synchronousMethodHandlerFactory =
&lt;span&gt;31&lt;/span&gt;       &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SynchronousMethodHandler.Factory(client, retryer, requestInterceptors, logger,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;          logLevel, decode404, closeAfterDecode, propagationPolicy, forceDecoding);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析 springmvc 注解          &lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     ParseHandlersByName handlersByName =
&lt;span&gt;35&lt;/span&gt;       &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ParseHandlersByName(contract, options, encoder, decoder, queryMapEncoder,
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;          errorDecoder, synchronousMethodHandlerFactory);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ReflectiveFeign          &lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReflectiveFeign(handlersByName, invocationHandlerFactory, queryMapEncoder);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;InvocationHandlerFactory 包含一个 create 接口方法，默认实现是 InvocationHandlerFactory.Default，返回的 InvocationHandler 类型是 ReflectiveFeign.FeignInvocationHandler。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; feign;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; InvocationHandlerFactory {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建动态代理&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   InvocationHandler create(Target target, Map&amp;lt;Method, MethodHandler&amp;gt;&lt;span&gt; dispatch);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法处理器&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MethodHandler {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     Object invoke(Object[] argv) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Default &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandlerFactory {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; InvocationHandler create(Target target, Map&amp;lt;Method, MethodHandler&amp;gt;&lt;span&gt; dispatch) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReflectiveFeign.FeignInvocationHandler(target, dispatch);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着看 ReflectiveFeign 的 newInstance() 方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;newInstance 的参数 target 就是前面封装的 Target.HardCodedTarget，它封装了客户端的类型、url 等属性。&lt;/li&gt;
&lt;li&gt;首先是使用 ParseHandlersByName 将 FeignClient 接口中的接口转换成 MethodHandler，实际类型就是 SynchronousMethodHandler，这个细节就不在看了。&lt;/li&gt;
&lt;li&gt;然后用 InvocationHandlerFactory 创建 InvocationHandler 代理对象，也就是 ReflectiveFeign.FeignInvocationHandler，调用动态代理对象的方法，最终都会进入到这个执行处理器里面。&lt;/li&gt;
&lt;li&gt;最后，终于看到创建动态代理的地方了，使用 Proxy 创建了 FeignClient 的动态代理对象，这个动态代理的类型就是 @FeignClient 注解的接口的类型。最后被注入到 IoC 容器后，就可以在代码中注入自己编写的 FeignClient 客户端组件了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最终就是通过 Proxy 创建一个实现了 FeignClient 接口的动态代理，然后所有接口方法的调用都会被 FeignInvocationHandler 拦截处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T newInstance(Target&amp;lt;T&amp;gt;&lt;span&gt; target) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 ParseHandlersByName 将 FeignClient 接口中的接口转换成 MethodHandler，springmvc 注解由 Contract 组件处理
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MethodHandler =&amp;gt; SynchronousMethodHandler&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     Map&amp;lt;String, MethodHandler&amp;gt; nameToHandler =&lt;span&gt; targetToHandlersByName.apply(target);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     Map&amp;lt;Method, MethodHandler&amp;gt; methodToHandler = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;Method, MethodHandler&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     List&amp;lt;DefaultMethodHandler&amp;gt; defaultMethodHandlers = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;DefaultMethodHandler&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转换成 Method - MethodHandler 映射&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : target.type().getMethods()) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (method.getDeclaringClass() == Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Util.isDefault(method)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         DefaultMethodHandler handler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultMethodHandler(method);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        defaultMethodHandlers.add(handler);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        methodToHandler.put(method, handler);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用 SynchronousMethodHandler.Factory 创建 SynchronousMethodHandler&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     InvocationHandler handler =&lt;span&gt; factory.create(target, methodToHandler);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用 Proxy 创建动态代理，动态代理对象就是 SynchronousMethodHandler&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     T proxy =&lt;span&gt; (T) Proxy.newProxyInstance(target.type().getClassLoader(),
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt;[] {target.type()}, handler);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;      defaultMethodHandler.bindTo(proxy);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202101/856154-20210105011820212-2087567440.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6、一张图总结 FeignClient 生成动态代理的流程&lt;/h3&gt;
&lt;p&gt;下面用一张图来总结下生成 FeignClient 动态代理的流程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先 @EnableFeignClients 导入的注册器 FeignClientsRegistrar 会扫描 @FeignClient 注解的接口，并生成 FeingClientFactoryBean 的 BeanDefinition 注册到容器中。最后会调用 FeingClientFactoryBean 的 getObject 方法来获取接口的动态代理对象。&lt;/li&gt;
&lt;li&gt;进入  FeingClientFactoryBean 的 getObject 方法，首先获取了 FeignContext，它其实就是每个客户端的容器，类似于一个 Map 结构，缓存了客户端与容器间的关系，后续大部分组件都是从 FeignContext 中获取。&lt;/li&gt;
&lt;li&gt;从 FeignContext 中获取 Feign 构造器 Feign.Builder，并配置 Feign.Builder，配置来源有多个地方，优先级最高的是 application.yml 中的配置生效；也可以配置 feign.client.default-to-properties=false 设置Java代码配置为高优先级。&lt;/li&gt;
&lt;li&gt;接下来就要根据 @FeignClient 是否配置了 url 决定是否走负载均衡的请求，其实就是设置的 Client 不一样：
&lt;ul&gt;&lt;li&gt;如果配置了 url，表示一个具体的地址，就使用将 LoadBalancerFeignClient 的 delegate 作为 Client 设置给 Feign.Builder。&lt;/li&gt;
&lt;li&gt;如果没有配置 url，表示通过服务名请求，就将 LoadBalancerFeignClient 作为 Client 设置给 Feign.Builder。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;再从 FeignContext 中获取 Targeter，调用它的 target 方法来获取动态代理。&lt;/li&gt;
&lt;li&gt;在 target 方法中，先调用 Feign.Builder 的 build() 方法构建了 ReflectiveFeign：
&lt;ul&gt;&lt;li&gt;先是获取代理对象工厂 InvocationHandlerFactory，用于创建 InvocationHandler&lt;/li&gt;
&lt;li&gt;然后用各个组件，构造了方法处理器工厂 SynchronousMethodHandler.Factory，接着创建了方法解析器 ParseHandlersByName&lt;/li&gt;
&lt;li&gt;最后基于 InvocationHandlerFactory 和 ParseHandlersByName 构造了 ReflectiveFeign&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最后调用  ReflectiveFeign 的 newInstance 方法反射创建接口的动态代理：
&lt;ul&gt;&lt;li&gt;先用方法解析器 ParseHandlersByName 解析接口，将接口解析成 SynchronousMethodHandler&lt;/li&gt;
&lt;li&gt;接着使用 InvocationHandlerFactory 创建了代理对象 InvocationHandler（ReflectiveFeign.FeignInvocationHandler）&lt;/li&gt;
&lt;li&gt;最终用 Proxy 创建动态代理对象，对象的类型就是接口的类型，代理对象就是 ReflectiveFeign.FeignInvocationHandler。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202101/856154-20210106094654389-468942137.png&quot; width=&quot;1600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、FeignClient 结合Ribbon进行负载均衡请求&lt;/h2&gt;
&lt;p&gt;上一节已经分析出，最终在 Feign.Builder 的 build 方法构建了 ReflectiveFeign，然后利用 ReflectiveFeign 的 newInstance 方法创建了动态代理。这个动态代理的代理对象是 ReflectiveFeign.FeignInvocationHandler。最终来说肯定就会利用 Client 进行负载均衡的请求。这节就来看看 Feign 如果利用动态代理发起HTTP请求的。&lt;/p&gt;
&lt;h3&gt;1、FeignClient 动态代理请求&lt;/h3&gt;
&lt;p&gt;使用 FeignClient 接口时，注入的其实是动态代理对象，调用接口方法时就会进入执行器 ReflectiveFeign.FeignInvocationHandler，从 FeignInvocationHandler 的 invoke 方法可以看出，就是根据 method 获取要执行的方法处理器 MethodHandler，然后执行方法。MethodHandler 的实际类型就是 SynchronousMethodHandler。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FeignInvocationHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Target target;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;Method, MethodHandler&amp;gt;&lt;span&gt; dispatch;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     FeignInvocationHandler(Target target, Map&amp;lt;Method, MethodHandler&amp;gt;&lt;span&gt; dispatch) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.target = checkNotNull(target, &quot;target&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.dispatch = checkNotNull(dispatch, &quot;dispatch for %s&quot;&lt;span&gt;, target);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据 method 获取 MethodHandler，然后执行方法&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dispatch.get(method).invoke(args);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着看 SynchronousMethodHandler 的 invoke 方法，核心逻辑就两步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先根据请求参数构建请求模板 RequestTemplate，就是处理 URI 模板、参数，比如替换掉 uri 中的占位符、拼接参数等。&lt;/li&gt;
&lt;li&gt;然后调用了 executeAndDecode 执行请求，并将相应结果解码返回。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Object invoke(Object[] argv) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构建请求模板，例如有 url 参数，请求参数之类的&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     RequestTemplate template =&lt;span&gt; buildTemplateFromArgs.create(argv);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     Options options =&lt;span&gt; findOptions(argv);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     Retryer retryer = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.retryer.clone();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行并解码&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; executeAndDecode(template, options);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RetryableException e) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重试，默认是从不重试&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;          retryer.continueOrPropagate(e);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RetryableException th) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;           Throwable cause =&lt;span&gt; th.getCause();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt; (propagationPolicy == UNWRAP &amp;amp;&amp;amp; cause != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; cause;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;           } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; th;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (logLevel !=&lt;span&gt; Logger.Level.NONE) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;          logger.logRetry(metadata.configKey(), logLevel);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，经过处理后，URI 上的占位符就被参数替换了，并且拼接了请求参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202101/856154-20210105115509429-1632668488.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202101/856154-20210105115652066-1351103323.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、执行请求 executeAndDecode&lt;/h3&gt;
&lt;p&gt;接着看 executeAndDecode，主要有三步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先调用 targetRequest 方法，主要就是遍历 RequestInterceptor 对请求模板 RequestTemplate 定制化，然后调用 HardCodedTarget 的 target 方法将 RequestTemplate 转换成 Request 请求对象，Request 封装了请求地址、请求头、body 等信息。&lt;/li&gt;
&lt;li&gt;然后使用客户端 client 来执行请求，就是 LoadBalancerFeignClient，这里就进入了负载均衡请求了。&lt;/li&gt;
&lt;li&gt;最后用解码器 decoder 来解析响应结果，将结果转换成接口的返回类型。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Object executeAndDecode(RequestTemplate template, Options options) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理RequestTemplate，得到请求对象 Request&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     Request request =&lt;span&gt; targetRequest(template);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    Response response;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 client 执行请求，client =&amp;gt; LoadBalancerFeignClient&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;       response =&lt;span&gt; client.execute(request, options);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构建响应 Response&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;       response =&lt;span&gt; response.toBuilder()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;          .request(request)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;          .requestTemplate(template)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;          .build();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (decoder != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用解码器解码，将返回数据转换成接口的返回类型&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; decoder.decode(response, metadata.returnType());
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 应用拦截器处理 RequestTemplate，最后使用 target 从 RequestTemplate 中得到 Request &lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;Request targetRequest(RequestTemplate template) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (RequestInterceptor interceptor : requestInterceptors) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;      interceptor.apply(template);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; target =&amp;gt; HardCodedTarget&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; target.apply(template);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HardCodedTarget 是硬编码写死的，我们没有办法定制化，看下它的 apply 方法，主要就是处理 RequestTemplate 模板的地址，生成完成的请求地址。最后返回 Request 请求对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Request apply(RequestTemplate input) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (input.url().indexOf(&quot;http&quot;) != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; url() =&amp;gt; &lt;/span&gt;&lt;span&gt;http://demo-producer&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; input.target 处理请求模板&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    input.target(url());
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; input.request();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到经过 HardCodedTarget 的 apply 方法之后，就拼接上了 url 前缀了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202101/856154-20210105130200456-757214419.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202101/856154-20210105130234018-2006377441.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、LoadBalancerFeignClient 负载均衡&lt;/h3&gt;
&lt;p&gt;LoadBalancerFeignClient 是 Feign 实现负载均衡核心的组件，是 Feign 网络请求组件 Client 的默认实现，LoadBalancerFeignClient 最后是使用 FeignLoadBalancer 来进行负载均衡的请求。&lt;/p&gt;
&lt;p&gt;看 LoadBalancerFeignClient 的 execute 方法，从这里到后面执行负载均衡请求，其实跟分析 Ribbon 源码中 RestTemplate 的负载均衡请求都是类似的了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以看到也是先将请求封装到 ClientRequest，实现类是 FeignLoadBalancer.RibbonRequest。注意 RibbonRequest 第一个参数 Client 就是设置的 LoadBalancerFeignClient 的代理对象，启用 apache httpclient 时，就是 ApacheHttpClient。&lt;/li&gt;
&lt;li&gt;然后获取客户端配置，也就是说 Ribbon 的客户端配置对 Feign 通用生效。&lt;/li&gt;
&lt;li&gt;最后获取了负载均衡器 FeignLoadBalancer，然后执行负载均衡请求。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Response execute(Request request, Request.Options options) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         URI asUri =&lt;span&gt; URI.create(request.url());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 客户端名称：demo-producer&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         String clientName =&lt;span&gt; asUri.getHost();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         URI uriWithoutHost =&lt;span&gt; cleanUrl(request.url(), clientName);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 封装 ClientRequest =&amp;gt; FeignLoadBalancer.RibbonRequest&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         FeignLoadBalancer.RibbonRequest ribbonRequest = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FeignLoadBalancer.RibbonRequest(
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.delegate, request, uriWithoutHost);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 客户端负载均衡配置 ribbon.demo-producer.*&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         IClientConfig requestConfig =&lt;span&gt; getClientConfig(options, clientName);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; lbClient =&amp;gt; 负载均衡器 FeignLoadBalancer，执行负载均衡请求&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; lbClient(clientName)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                .executeWithLoadBalancer(ribbonRequest, requestConfig).toResponse();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClientException e) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; FeignLoadBalancer lbClient(String clientName) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lbClientFactory.create(clientName);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入 executeWithLoadBalancer 方法，这就跟 Ribbon 源码中分析的是一样的了，最终就验证了 Feign 基于 Ribbon 来做负载均衡请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; T executeWithLoadBalancer(&lt;span&gt;final&lt;/span&gt; S request, &lt;span&gt;final&lt;/span&gt; IClientConfig requestConfig) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClientException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 负载均衡器执行命令&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     LoadBalancerCommand&amp;lt;T&amp;gt; command =&lt;span&gt; buildLoadBalancerCommand(request, requestConfig);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; command.submit(
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; ServerOperation&amp;lt;T&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; Observable&amp;lt;T&amp;gt;&lt;span&gt; call(Server server) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用Server的信息重构URI地址&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                     URI finalUri =&lt;span&gt; reconstructURIWithServer(server, request.getUri());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     S requestForServer =&lt;span&gt; (S) request.replaceUri(finalUri);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际调用 LoadBalancerFeignClient 的 execute 方法&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; Observable.just(AbstractLoadBalancerAwareClient.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.execute(requestForServer, requestConfig));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    } 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Observable.error(e);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            .toBlocking()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            .single();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重构URI后，实际是调用 FeignLoadBalancer 的 execute 方法来执行最终的HTTP调用的。看下 FeignLoadBalancer 的 execute 方法，最终来说，就是使用代理的HTTP客户端来执行请求。&lt;/p&gt;
&lt;p&gt;默认情况下，就是 Client.Default，用 HttpURLConnection 执行HTTP请求；启用了 httpclient 后，就是 ApacheHttpClient；启用了 okhttp，就是 OkHttpClient。&lt;/p&gt;
&lt;p&gt;这里有一点需要注意的是，FeignClient 虽然可以配置超时时间，但进入 FeignLoadBalancer 的 execute 方法后，可以看到会用 Ribbon 的超时时间覆盖 Feign 配置的超时时间，最终以 Ribbon 的超时时间为准。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; RibbonResponse execute(RibbonRequest request, IClientConfig configOverride) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    Request.Options options;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (configOverride != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用 Ribbon 的超时时间覆盖了feign配置的超时时间&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         RibbonProperties override =&lt;span&gt; RibbonProperties.from(configOverride);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         options = &lt;span&gt;new&lt;/span&gt; Request.Options(override.connectTimeout(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.connectTimeout),
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 override.readTimeout(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.readTimeout));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         options = &lt;span&gt;new&lt;/span&gt; Request.Options(&lt;span&gt;this&lt;/span&gt;.connectTimeout, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.readTimeout);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; request.client() HTTP客户端对象&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     Response response =&lt;span&gt; request.client().execute(request.toRequest(), options);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonResponse(request.getUri(), response);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、一张图总结 Feign 负载均衡请求&lt;/h3&gt;
&lt;p&gt;关于Ribbon的源码分析请看前面 Ribbon 相关的两篇文章，Ribbon 如何从 eureka 注册中心获取 Server 就不再分析了。&lt;/p&gt;
&lt;p&gt;下面这张图总结了 Feign 负载均衡请求的流程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先服务启动的时候会扫描解析 @FeignClient 注解的接口，并生成代理类注入到容器中。我们注入 @FeignClient 接口时其实就是注入的这个代理类。&lt;/li&gt;
&lt;li&gt;调用接口方法时，会被代理对象拦截，进入 ReflectiveFeign.FeignInvocationHandler 的 invoke 方法执行请求。&lt;/li&gt;
&lt;li&gt;FeignInvocationHandler 会根据调用的接口方法获取已经构建好的方法处理器 SynchronousMethodHandler，然后调用它的 invoke 方法执行请求。&lt;/li&gt;
&lt;li&gt;在 SynchronousMethodHandler 的 invoke 方法中，会先根据请求参数构建请求模板 RequestTemplate，这个时候会处理参数中的占位符、拼接请求参数、处理body中的参数等等。&lt;/li&gt;
&lt;li&gt;然后将 RequestTemplate 转成 Request，在转换的过程中：
&lt;ul&gt;&lt;li&gt;先是用 RequestInterceptor 处理请求模板，因此我们可以自定义拦截器来定制化 RequestTemplate。&lt;/li&gt;
&lt;li&gt;之后用 Target（HardCodedTarget）处理请求地址，拼接上服务名前缀。&lt;/li&gt;
&lt;li&gt;最后调用 RequestTemplate 的 request 方法获取到 Request 对象。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;得到 Request 后，就调用 LoadBalancerFeignClient 的 execute 方法来执行请求并得到请求结果 Response：
&lt;ul&gt;&lt;li&gt;先构造 ClientRequest，并获取到负载均衡器 FeignLoadBalancer，然后就执行负载均衡请求。&lt;/li&gt;
&lt;li&gt;负载均衡请求最终进入到 AbstractLoadBalancerAwareClient，executeWithLoadBalancer 方法中，会先构建一个 LoadBalancerCommand，然后提交一个 ServerOperation。&lt;/li&gt;
&lt;li&gt;LoadBalancerCommand 会通过 LoadBalancerContext 根据服务名获取一个 Server。&lt;/li&gt;
&lt;li&gt;在 ServerOperation 中根据 Server 的信息重构URI，将服务名替换为具体的IP地址，之后就可以发起真正的HTTP调用了。&lt;/li&gt;
&lt;li&gt;HTTP调用时，底层使用的组件默认是 HttpURLConnection；启用了okhttp，就是 okhttp 的 OkHttpClient；启用了 httpclient，就是 apache 的 HttpClient。&lt;/li&gt;
&lt;li&gt;最红用 HTTP 客户端组件执行请求，得到响应结果 Response。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;得到 Response 后，就使用解码器 Decoder 解析响应结果，返回接口方法定义的返回类型。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202101/856154-20210106112218871-1104418095.png&quot; width=&quot;1600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;负载均衡获取Server的核心组件是 LoadBalancerClient，具体的源码分析可以参考 Ribbon 源码分析的两篇文章。LoadBalancerClient 负载均衡的原理可以看下面这张图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202101/856154-20210106110148140-122742083.png&quot; width=&quot;1600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 07 Jan 2021 17:42:00 +0000</pubDate>
<dc:creator>bojiangzhou</dc:creator>
<og:description>介绍了 Feign 基础使用、配置，从源码的角度分析了 @FeignClient 接口如何生成动态代理并注入到容器中使用，以及 Feign 如何与 Ribbon 结合进行负载均衡请求。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chiangchou/p/feign.html</dc:identifier>
</item>
<item>
<title>asp.net core 5.0 中的 JsonConsole - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/14249607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/14249607.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;asp.net core 5.0 中日志新增了 &lt;code&gt;JsonConsole&lt;/code&gt;，还是输出日志到 &lt;code&gt;Console&lt;/code&gt;，但是会应用 &lt;code&gt;Json&lt;/code&gt; 格式的一个 &lt;code&gt;Formatter&lt;/code&gt; 把日志格式化成 json 再输出到控制台&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;p&gt;一起来看一个示例，以我的一个小项目为例子来演示，默认的 console 日志格式是多行的，不够结构化，想要进行加工的话就会比较麻烦，不能很方便的进行加工和扩展，而 JSON 则是一种相对来说比较结构化的数据，相对来说进行扩展就比较方便了。&lt;/p&gt;
&lt;p&gt;来看一下默认日志输出效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202101/489462-20210108002931135-1338649441.png&quot; alt=&quot;default console log&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，一条日志默认是两行，第一行是日志级别和日志对应的 &lt;code&gt;CategoryName&lt;/code&gt; 和 &lt;code&gt;EventId&lt;/code&gt;，第二行是日志的具体内容&lt;/p&gt;
&lt;p&gt;接着我们来使用一下 &lt;code&gt;JsonConsole&lt;/code&gt;，配置方式如下，可以在 &lt;code&gt;Program.cs&lt;/code&gt; 调用（推荐）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202101/489462-20210108002930915-1071128316.png&quot; alt=&quot;json console configure&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看输出的日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202101/489462-20210108002930523-1038130687.png&quot; alt=&quot;json console log&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到现在的日志已经是 JSON 了，每一条日志都是一个 JSON&lt;/p&gt;
&lt;h2 id=&quot;implement&quot;&gt;Implement&lt;/h2&gt;
&lt;p&gt;它的实现在于一个 &lt;code&gt;JsonConsoleFormatter&lt;/code&gt;，是基于 &lt;code&gt;System.Text.Json&lt;/code&gt; 来实现的 &lt;code&gt;Json&lt;/code&gt; 格式化，&lt;/p&gt;
&lt;p&gt;我们也可以实现自己的 &lt;code&gt;ConsoleFormatter&lt;/code&gt; 来自定义 &lt;code&gt;Console&lt;/code&gt; 的日志格式，详细实现可以参考：&lt;a href=&quot;https://github.com/dotnet/runtime/blob/v5.0.0/src/libraries/Microsoft.Extensions.Logging.Console/src/JsonConsoleFormatter.cs&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/runtime/blob/v5.0.0/src/libraries/Microsoft.Extensions.Logging.Console/src/JsonConsoleFormatter.cs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;扩展方法实现&lt;a href=&quot;https://github.com/dotnet/runtime/blob/v5.0.0/src/libraries/Microsoft.Extensions.Logging.Console/src/ConsoleLoggerExtensions.cs&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/runtime/blob/v5.0.0/src/libraries/Microsoft.Extensions.Logging.Console/src/ConsoleLoggerExtensions.cs&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AddJsonConsole&lt;/code&gt; 扩展实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202101/489462-20210108002930269-1476416183.png&quot; alt=&quot;AddJsonConsole&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AddConsoleWithFormatter&lt;/code&gt; 实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202101/489462-20210108002930020-876847222.png&quot; alt=&quot;AddConsoleWithFormatter&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AddConsole&lt;/code&gt; 实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202101/489462-20210108002929559-1975011032.png&quot; alt=&quot;AddConsole&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;在之前的版本，如果想要把日志格式化成 JSON 输出到控制台，需要使用第三方的日志框架把日志序列化成 JSON，有了 &lt;code&gt;JsonConsoleFormatter&lt;/code&gt; 之后我们就可以很方便的将日志格式化成 JSON 输出到控制台了。&lt;/p&gt;
&lt;p&gt;日志输出为 JSON 之后，想要对日志进行扩展和补充就会很容易，我们的应用目前使用的 .netcore 3.1，使用的是 nlog 把日志格式化成 JSON 输出到控制台，再通过 Fluentd 收集 es，收集的同时会把应用所在的 k8s 环境信息如containerName, podName,clusterName 等也 Patch 到日志信息中&lt;/p&gt;
&lt;p&gt;示例使用了默认的配置，我们也可以通过带 action 的重载扩展方法自定义 Json 格式化的配置&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Thu, 07 Jan 2021 16:31:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>asp.net core 5 中的 JsonConsole</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/14249607.html</dc:identifier>
</item>
<item>
<title>容器编排系统K8s之Pod Affinity - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14243312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14243312.html</guid>
<description>&lt;p&gt;　　前文我们了解了k8s上的NetworkPolicy资源的使用和工作逻辑，回顾请参考：&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/14227660.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/14227660.html&lt;/a&gt;；今天我们来聊一聊Pod调度策略相关话题；&lt;/p&gt;
&lt;p&gt;　　在k8s上有一个非常重要的组件kube-scheduler，它主要作用是监听apiserver上的pod资源中的nodename字段是否为空，如果该字段为空就表示对应pod还没有被调度，此时kube-scheduler就会从k8s众多节点中，根据pod资源的定义相关属性，从众多节点中挑选一个最佳运行pod的节点，并把对应主机名称填充到对应pod的nodename字段，然后把pod定义资源存回apiserver；此时apiserver就会根据pod资源上的nodename字段中的主机名，通知对应节点上的kubelet组件来读取对应pod资源定义，kubelet从apiserver读取对应pod资源定义清单，根据资源清单中定义的属性，调用本地docker把对应pod运行起来；然后把pod状态反馈给apiserver，由apiserver把对应pod的状态信息存回etcd中；整个过程，kube-scheduler主要作用是调度pod，并把调度信息反馈给apiserver，那么问题来了，kube-scheduler它是怎么评判众多节点哪个节点最适合运行对应pod的呢？&lt;/p&gt;
&lt;p&gt;　　在k8s上调度器的工作逻辑是根据调度算法来实现对应pod的调度的；不同的调度算法，调度结果也有所不同，其评判的标准也有所不同，当调度器发现apiserver上有未被调度的pod时，它会把k8s上所有节点信息，挨个套进对应的预选策略函数中进行筛选，把不符合运行pod的节点淘汰掉，我们把这个过程叫做调度器的预选阶段（Predicate）；剩下符合运行pod的节点会进入下一个阶段优选（Priority），所谓优选是在这些符合运行pod的节点中根据各个优选函数的评分，最后把每个节点通过各个优选函数评分加起来，选择一个最高分，这个最高分对应的节点就是调度器最后调度结果，如果最高分有多个节点，此时调度器会从最高分相同的几个节点随机挑选一个节点当作最后运行pod的节点；我们把这个这个过程叫做pod选定过程（select）;简单讲调度器的调度过程会通过三个阶段，第一阶段是预选阶段，此阶段主要是筛选不符合运行pod节点，并将这些节点淘汰掉；第二阶段是优选，此阶段是通过各个优选函数对节点评分，筛选出得分最高的节点；第三阶段是节点选定，此阶段是从多个高分节点中随机挑选一个作为最终运行pod的节点；大概过程如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202101/1503305-20210106212101360-1673206793.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：预选过程是一票否决机制，只要其中一个预选函数不通过，对应节点则直接被淘汰；剩下通过预选的节点会进入优选阶段，此阶段每个节点会通过对应的优选函数来对各个节点评分，并计算每个节点的总分；最后调度器会根据每个节点的最后总分来挑选一个最高分的节点，作为最终调度结果；如果最高分有多个节点，此时调度器会从对应节点集合中随机挑选一个作为最后调度结果，并把最后调度结果反馈给apiserver；&lt;/p&gt;
&lt;p&gt;　　影响调度的因素&lt;/p&gt;
&lt;p&gt;　　NodeName：nodename是最直接影响pod调度的方式，我们知道调度器评判pod是否被调度，就是根据nodename字段是否为空来进行判断，如果对应pod资源清单中，用户明确定义了nodename字段，则表示不使用调度器调度，此时调度器也不会调度此类pod资源，原因是对应nodename非空，调度器认为该pod是已经调度过了；这种方式是用户手动将pod绑定至某个节点的方式；&lt;/p&gt;
&lt;p&gt;　　NodeSelector：nodeselector相比nodename，这种方式要宽松一些，它也是影响调度器调度的一个重要因素，我们在定义pod资源时，如果指定了nodeselector，就表示只有符合对应node标签选择器定义的标签的node才能运行对应pod；如果没有节点满足节点选择器，对应pod就只能处于pending状态；&lt;/p&gt;
&lt;p&gt;　　Node Affinity：node affinity是用来定义pod对节点的亲和性，所谓pod对节点的亲和性是指，pod更愿意或更不愿意运行在那些节点；这种方式相比前面的nodename和nodeselector在调度逻辑上要精细一些；&lt;/p&gt;
&lt;p&gt;　　Pod Affinity：pod affinity是用来定义pod与pod间的亲和性，所谓pod与pod的亲和性是指，pod更愿意和那个或那些pod在一起；与之相反的也有pod更不愿意和那个或那些pod在一起，这种我们叫做pod anti affinity，即pod与pod间的反亲和性；所谓在一起是指和对应pod在同一个位置，这个位置可以是按主机名划分，也可以按照区域划分，这样一来我们要定义pod和pod在一起或不在一起，定义位置就显得尤为重要，也是评判对应pod能够运行在哪里标准；&lt;/p&gt;
&lt;p&gt;　　taint和tolerations：taint是节点上的污点，tolerations是对应pod对节点上的污点的容忍度，即pod能够容忍节点的污点，那么对应pod就能够运行在对应节点，反之Pod就不能运行在对应节点；这种方式是结合节点的污点，以及pod对节点污点的容忍度来调度的；&lt;/p&gt;
&lt;p&gt; 　　示例：使用nodename调度策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat pod-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  nodeName: node01.k8s.org
  containers:
  - name: nginx
    image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    ports:
    - name: http
      containerPort: 80
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：nodename可以直接指定对应pod运行在那个节点上，无需默认调度器调度；以上资源表示把nginx-pod运行在node01.k8s.org这个节点上；&lt;/p&gt;
&lt;p&gt;　　应用清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f pod-demo.yaml
pod/nginx-pod created
[root@master01 ~]# kubectl get pods -o wide
NAME        READY   STATUS    RESTARTS   AGE   IP            NODE             NOMINATED NODE   READINESS GATES
nginx-pod   1/1     Running   0          10s   10.244.1.28   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod一定运行在我们手动指定的节点上；&lt;/p&gt;
&lt;p&gt;　　示例：使用nodeselector调度策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat pod-demo-nodeselector.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-nodeselector
spec:
  nodeSelector:
    disktype: ssd
  containers:
  - name: nginx
    image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    ports:
    - name: http
      containerPort: 80
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：nodeselector使用来定义对对应node的标签进行匹配，如果对应节点有此对应标签，则对应pod就能被调度到对应节点运行，反之则不能被调度到对应节点运行；如果所有节点都不满足，此时pod会处于pending状态，直到有对应节点拥有对应标签时，pod才会被调度到对应节点运行；&lt;/p&gt;
&lt;p&gt;　　应用清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f pod-demo-nodeselector.yaml
pod/nginx-pod-nodeselector created
[root@master01 ~]# kubectl get pods -o wide
NAME                     READY   STATUS    RESTARTS   AGE     IP            NODE             NOMINATED NODE   READINESS GATES
nginx-pod                1/1     Running   0          9m38s   10.244.1.28   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeselector   0/1     Pending   0          16s     &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod的状态一直处于pending状态，其原因是对应k8s节点没有一个节点满足对应节点选择器标签；&lt;/p&gt;
&lt;p&gt;　　验证：给node02打上对应标签，看看对应pod是否会被调度到node02上呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;84&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get nodes --show-labels
NAME               STATUS   ROLES                  AGE   VERSION   LABELS
master01.k8s.org   Ready    control-plane,master   29d   v1.20.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=master01.k8s.org,kubernetes.io/os=linux,node-role.kubernetes.io/control-plane=,node-role.kubernetes.io/master=
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0   app=nginx-1.14-alpine,beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=node01.k8s.org,kubernetes.io/os=linux
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=node02.k8s.org,kubernetes.io/os=linux
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=node03.k8s.org,kubernetes.io/os=linux
node04.k8s.org     Ready    &amp;lt;none&amp;gt;                 19d   v1.20.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=node04.k8s.org,kubernetes.io/os=linux
[root@master01 ~]# kubectl label node node02.k8s.org disktype=ssd
node/node02.k8s.org labeled
[root@master01 ~]# kubectl get nodes --show-labels               
NAME               STATUS   ROLES                  AGE   VERSION   LABELS
master01.k8s.org   Ready    control-plane,master   29d   v1.20.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=master01.k8s.org,kubernetes.io/os=linux,node-role.kubernetes.io/control-plane=,node-role.kubernetes.io/master=
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0   app=nginx-1.14-alpine,beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=node01.k8s.org,kubernetes.io/os=linux
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,disktype=ssd,kubernetes.io/arch=amd64,kubernetes.io/hostname=node02.k8s.org,kubernetes.io/os=linux
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=node03.k8s.org,kubernetes.io/os=linux
node04.k8s.org     Ready    &amp;lt;none&amp;gt;                 19d   v1.20.0   beta.kubernetes.io/arch=amd64,beta.kubernetes.io/os=linux,kubernetes.io/arch=amd64,kubernetes.io/hostname=node04.k8s.org,kubernetes.io/os=linux
[root@master01 ~]# kubectl get pods -o wide
NAME                     READY   STATUS    RESTARTS   AGE     IP            NODE             NOMINATED NODE   READINESS GATES
nginx-pod                1/1     Running   0          12m     10.244.1.28   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeselector   1/1     Running   0          3m26s   10.244.2.18   node02.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到给node02节点打上disktype=ssd标签以后，对应pod就被调度在node02上运行；&lt;/p&gt;
&lt;p&gt;　　示例：使用affinity中的nodeaffinity调度策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat pod-demo-affinity-nodeaffinity.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-nodeaffinity
spec:
  containers:
  - name: nginx
    image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    ports:
    - name: http
      containerPort: 80
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: foo
            operator: Exists
            values: []
        - matchExpressions:
          - key: disktype
            operator: Exists
            values: []
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 10
          preference:
            matchExpressions:
            - key: foo
              operator: Exists
              values: []
        - weight: 2
          preference:
            matchExpressions:
            - key: disktype
              operator: Exists
              values: []
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：对于nodeaffinity来说，它有两种限制，一种是硬限制，用requiredDuringSchedulingIgnoredDuringExecution字段来定义，该字段为一个对象，其里面只有nodeSelectorTerms一个字段可以定义，该字段为一个列表对象，可以使用matchExpressions字段来定义匹配对应节点标签的表达式（其中对应表达式中可以使用的操作符有In、NotIn、Exists、DoesNotExists、Lt、Gt；Lt和Gt用于字符串比较，Exists和DoesNotExists用来判断对应标签key是否存在，In和NotIn用来判断对应标签的值是否在某个集合中），也可以使用matchFields字段来定义对应匹配节点字段；所谓硬限制是指必须满足对应定义的节点标签选择表达式或节点字段选择器，对应pod才能够被调度在对应节点上运行，否则对应pod不能被调度到节点上运行，如果没有满足对应的节点标签表达式或节点字段选择器，则对应pod会一直被挂起；第二种是软限制，用preferredDuringSchedulingIgnoredDuringExecution字段定义，该字段为一个列表对象，里面可以用weight来定义对应软限制的权重，该权重会被调度器在最后计算node得分时加入到对应节点总分中；preference字段是用来定义对应软限制匹配条件；即满足对应软限制的节点在调度时会被调度器把对应权重加入对应节点总分；对于软限制来说，只有当硬限制匹配有多个node时，对应软限制才会生效；即软限制是在硬限制的基础上做的第二次限制，它表示在硬限制匹配多个node，优先使用软限制中匹配的node，如果软限制中给定的权重和匹配条件不能让多个node决胜出最高分，即使用默认调度调度机制，从多个最高分node中随机挑选一个node作为最后调度结果；如果在软限制中给定权重和对应匹配条件能够决胜出对应node最高分，则对应node就为最后调度结果；简单讲软限制和硬限制一起使用，软限制是辅助硬限制对node进行挑选；如果只是单纯的使用软限制，则优先把pod调度到权重较高对应条件匹配的节点上；如果权重一样，则调度器会根据默认规则从最后得分中挑选一个最高分，作为最后调度结果；以上示例表示运行pod的硬限制必须是对应节点上满足有key为foo的节点标签或者key为disktype的节点标签；如果对应硬限制没有匹配到任何节点，则对应pod不做任何调度，即处于pending状态，如果对应硬限制都匹配，则在软限制中匹配key为foo的节点将在总分中加上10，对key为disktype的节点总分加2分；即软限制中，pod更倾向key为foo的节点标签的node上；这里需要注意的是nodeAffinity没有node anti Affinity，要想实现反亲和性可以使用NotIn或者DoesNotExists操作符来匹配对应条件；&lt;/p&gt;
&lt;p&gt;　　应用资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get nodes -L foo,disktype     
NAME               STATUS   ROLES                  AGE   VERSION   FOO   DISKTYPE
master01.k8s.org   Ready    control-plane,master   29d   v1.20.0         
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         ssd
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node04.k8s.org     Ready    &amp;lt;none&amp;gt;                 19d   v1.20.0         
[root@master01 ~]# kubectl apply -f pod-demo-affinity-nodeaffinity.yaml
pod/nginx-pod-nodeaffinity created
[root@master01 ~]# kubectl get pods -o wide
NAME                     READY   STATUS    RESTARTS   AGE    IP            NODE             NOMINATED NODE   READINESS GATES
nginx-pod                1/1     Running   0          122m   10.244.1.28   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeaffinity   1/1     Running   0          7s     10.244.2.22   node02.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeselector   1/1     Running   0          113m   10.244.2.18   node02.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到应用清单以后对应pod被调度到node02上运行了，之所以调度到node02是因为对应节点上有key为disktype的节点标签，该条件满足对应运行pod的硬限制；&lt;/p&gt;
&lt;p&gt;　　验证：删除pod和对应node02上的key为disktype的节点标签，再次应用资源清单，看看对应pod怎么调度？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl delete -f pod-demo-affinity-nodeaffinity.yaml
pod &quot;nginx-pod-nodeaffinity&quot; deleted
[root@master01 ~]# kubectl label node node02.k8s.org disktype-
node/node02.k8s.org labeled
[root@master01 ~]# kubectl get pods 
NAME                     READY   STATUS    RESTARTS   AGE
nginx-pod                1/1     Running   0          127m
nginx-pod-nodeselector   1/1     Running   0          118m
[root@master01 ~]# kubectl get node -L foo,disktype
NAME               STATUS   ROLES                  AGE   VERSION   FOO   DISKTYPE
master01.k8s.org   Ready    control-plane,master   29d   v1.20.0         
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node04.k8s.org     Ready    &amp;lt;none&amp;gt;                 19d   v1.20.0         
[root@master01 ~]# kubectl apply -f pod-demo-affinity-nodeaffinity.yaml
pod/nginx-pod-nodeaffinity created
[root@master01 ~]# kubectl get pods -o wide
NAME                     READY   STATUS    RESTARTS   AGE    IP            NODE             NOMINATED NODE   READINESS GATES
nginx-pod                1/1     Running   0          128m   10.244.1.28   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeaffinity   0/1     Pending   0          9s     &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeselector   1/1     Running   0          118m   10.244.2.18   node02.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到删除原有pod和node2上面的标签后，再次应用资源清单，pod就一直处于pending状态；其原因是对应k8s节点没有满足对应pod运行时的硬限制；所以对应pod无法进行调度；&lt;/p&gt;
&lt;p&gt;　　验证：删除pod，分别给node01和node03打上key为foo和key为disktype的节点标签，看看然后再次应用清单，看看对应pod会这么调度？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl delete -f pod-demo-affinity-nodeaffinity.yaml
pod &quot;nginx-pod-nodeaffinity&quot; deleted
[root@master01 ~]# kubectl label node node01.k8s.org foo=bar
node/node01.k8s.org labeled
[root@master01 ~]# kubectl label node node03.k8s.org disktype=ssd
node/node03.k8s.org labeled
[root@master01 ~]# kubectl get nodes -L foo,disktype
NAME               STATUS   ROLES                  AGE   VERSION   FOO   DISKTYPE
master01.k8s.org   Ready    control-plane,master   29d   v1.20.0         
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0   bar   
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         ssd
node04.k8s.org     Ready    &amp;lt;none&amp;gt;                 19d   v1.20.0         
[root@master01 ~]# kubectl apply -f pod-demo-affinity-nodeaffinity.yaml
pod/nginx-pod-nodeaffinity created
[root@master01 ~]# kubectl get pods -o wide
NAME                     READY   STATUS    RESTARTS   AGE    IP            NODE             NOMINATED NODE   READINESS GATES
nginx-pod                1/1     Running   0          132m   10.244.1.28   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeaffinity   1/1     Running   0          5s     10.244.1.29   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeselector   1/1     Running   0          123m   10.244.2.18   node02.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到当硬限制中的条件被多个node匹配时，优先调度对应软限制条件匹配权重较大的节点上，即硬限制不能正常抉择出调度节点，则软限制中对应权重大的匹配条件有限被调度；&lt;/p&gt;
&lt;p&gt;　　验证：删除node01上的节点标签，看看对应pod是否会被移除，或被调度其他节点？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get nodes -L foo,disktype
NAME               STATUS   ROLES                  AGE   VERSION   FOO   DISKTYPE
master01.k8s.org   Ready    control-plane,master   29d   v1.20.0         
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0   bar   
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         ssd
node04.k8s.org     Ready    &amp;lt;none&amp;gt;                 19d   v1.20.0         
[root@master01 ~]# kubectl label node node01.k8s.org foo-
node/node01.k8s.org labeled
[root@master01 ~]# kubectl get nodes -L foo,disktype     
NAME               STATUS   ROLES                  AGE   VERSION   FOO   DISKTYPE
master01.k8s.org   Ready    control-plane,master   29d   v1.20.0         
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         ssd
node04.k8s.org     Ready    &amp;lt;none&amp;gt;                 19d   v1.20.0         
[root@master01 ~]# kubectl get pods -o wide
NAME                     READY   STATUS    RESTARTS   AGE    IP            NODE             NOMINATED NODE   READINESS GATES
nginx-pod                1/1     Running   0          145m   10.244.1.28   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeaffinity   1/1     Running   0          12m    10.244.1.29   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeselector   1/1     Running   0          135m   10.244.2.18   node02.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到当pod正常运行以后，即便后来对应节点不满足对应pod运行的硬限制，对应pod也不会被移除或调度到其他节点，说明节点亲和性是在调度时发生作用，一旦调度完成，即便后来节点不满足pod运行节点亲和性，对应pod也不会被移除或再次调度；简单讲nodeaffinity对pod调度既成事实无法做二次调度；&lt;/p&gt;
&lt;p&gt;　　node Affinity规则生效方式&lt;/p&gt;
&lt;p&gt;　　1、nodeAffinity和nodeSelector一起使用时，两者间关系取“与”关系，即两者条件必须同时满足，对应节点才满足调度运行或不运行对应pod；&lt;/p&gt;
&lt;p&gt;　　示例：使用nodeaffinity和nodeselector定义pod调度策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat pod-demo-affinity-nodesector.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-nodeaffinity-nodeselector
spec:
  containers:
  - name: nginx
    image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    ports:
    - name: http
      containerPort: 80
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: foo
            operator: Exists
            values: []
  nodeSelector:
    disktype: ssd
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上清单表示对应pod倾向运行在节点上有节点标签key为foo的节点并且对应节点上还有disktype=ssd节点标签&lt;/p&gt;
&lt;p&gt;　　应用清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get nodes -L foo,disktype    
NAME               STATUS   ROLES                  AGE   VERSION   FOO   DISKTYPE
master01.k8s.org   Ready    control-plane,master   29d   v1.20.0         
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         ssd
node04.k8s.org     Ready    &amp;lt;none&amp;gt;                 19d   v1.20.0         
[root@master01 ~]# kubectl apply -f pod-demo-affinity-nodesector.yaml
pod/nginx-pod-nodeaffinity-nodeselector created
[root@master01 ~]# kubectl get pods -o wide
NAME                                  READY   STATUS    RESTARTS   AGE    IP            NODE             NOMINATED NODE   READINESS GATES
nginx-pod                             1/1     Running   0          168m   10.244.1.28   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeaffinity                1/1     Running   0          35m    10.244.1.29   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeaffinity-nodeselector   0/1     Pending   0          7s     &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeselector                1/1     Running   0          159m   10.244.2.18   node02.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod被创建以后，一直处于pengding状态，原因是没有节点满足同时有节点标签key为foo并且disktype=ssd的节点，所以对应pod就无法正常被调度，只好挂起；&lt;/p&gt;
&lt;p&gt;　　2、多个nodeaffinity同时指定多个nodeSelectorTerms时，相互之间取“或”关系；即使用多个matchExpressions列表分别指定对应的匹配条件；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat pod-demo-affinity2.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-nodeaffinity2
spec:
  containers:
  - name: nginx
    image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    ports:
    - name: http
      containerPort: 80
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: foo
            operator: Exists
            values: []
        - matchExpressions:
          - key: disktype
            operator: Exists
            values: []
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上示例表示运行pod节点倾向对应节点上有节点标签key为foo或key为disktype的节点；&lt;/p&gt;
&lt;p&gt;　　应用清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get nodes -L foo,disktype
NAME               STATUS   ROLES                  AGE   VERSION   FOO   DISKTYPE
master01.k8s.org   Ready    control-plane,master   29d   v1.20.0         
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         ssd
node04.k8s.org     Ready    &amp;lt;none&amp;gt;                 19d   v1.20.0         
[root@master01 ~]# kubectl apply -f pod-demo-affinity2.yaml
pod/nginx-pod-nodeaffinity2 created
[root@master01 ~]# kubectl get pods -o wide
NAME                                  READY   STATUS    RESTARTS   AGE    IP            NODE             NOMINATED NODE   READINESS GATES
nginx-pod                             1/1     Running   0          179m   10.244.1.28   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeaffinity                1/1     Running   0          46m    10.244.1.29   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeaffinity-nodeselector   0/1     Pending   0          10m    &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeaffinity2               1/1     Running   0          6s     10.244.3.21   node03.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeselector                1/1     Running   0          169m   10.244.2.18   node02.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod被调度node03上运行了，之所以能在node03运行是因为对应node03满足节点标签key为foo或key为disktype条件；&lt;/p&gt;
&lt;p&gt;　　3、同一个matchExpressions，多个条件取“与”关系；即使用多个key列表分别指定对应的匹配条件；&lt;/p&gt;
&lt;p&gt;　　示例：在一个matchExpressions下指定多个条件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat pod-demo-affinity3.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-nodeaffinity3
spec:
  containers:
  - name: nginx
    image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    ports:
    - name: http
      containerPort: 80
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: foo
            operator: Exists
            values: []
          - key: disktype
            operator: Exists
            values: []
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：上述清单表示pod倾向运行在节点标签key为foo和节点标签key为disktype的节点上；&lt;/p&gt;
&lt;p&gt;　　应用清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get nodes -L foo,disktype                 
NAME               STATUS   ROLES                  AGE   VERSION   FOO   DISKTYPE
master01.k8s.org   Ready    control-plane,master   29d   v1.20.0         
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 29d   v1.20.0         ssd
node04.k8s.org     Ready    &amp;lt;none&amp;gt;                 19d   v1.20.0         
[root@master01 ~]# kubectl apply -f pod-demo-affinity3.yaml
pod/nginx-pod-nodeaffinity3 created
[root@master01 ~]# kubectl get pods -o wide
NAME                                  READY   STATUS    RESTARTS   AGE     IP            NODE             NOMINATED NODE   READINESS GATES
nginx-pod                             1/1     Running   0          3h8m    10.244.1.28   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeaffinity                1/1     Running   0          56m     10.244.1.29   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeaffinity-nodeselector   0/1     Pending   0          20m     &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeaffinity2               1/1     Running   0          9m38s   10.244.3.21   node03.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeaffinity3               0/1     Pending   0          7s      &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
nginx-pod-nodeselector                1/1     Running   0          179m    10.244.2.18   node02.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod创建以后，一直处于pengding状态；原因是没有符合节点标签同时满足key为foo和key为disktyp的节点；&lt;/p&gt;
&lt;p&gt; 　　pod affinity 的工作逻辑和使用方式同node affinity类似，pod affinity也有硬限制和软限制，其逻辑和nodeaffinity一样，即定义了硬亲和，软亲和规则就是辅助硬亲和规则挑选对应pod运行节点；如果硬亲和不满足条件，对应pod只能挂起；如果只是使用软亲和规则，则对应pod会优先运行在匹配软亲和规则中权重较大的节点上，如果软亲和规则也没有节点满足，则使用默认调度规则从中挑选一个得分最高的节点运行pod；&lt;/p&gt;
&lt;p&gt;　　示例：使用Affinity中的PodAffinity中的硬限制调度策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat require-podaffinity.yaml
apiVersion: v1
kind: Pod
metadata:
  name: with-pod-affinity-1
spec:
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - {key: app, operator: In, values: [&quot;nginx&quot;]}
        topologyKey: kubernetes.io/hostname
  containers:
  - name: myapp
    image: ikubernetes/myapp:v1
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：上述清单是podaffinity中的硬限制使用方式，其中定义podaffinity需要在spec.affinity字段中使用podAffinity字段来定义；requiredDuringSchedulingIgnoredDuringExecution字段是定义对应podAffinity的硬限制所使用的字段，该字段为一个列表对象，其中labelSelector用来定义和对应pod在一起pod的标签选择器；topologyKey字段是用来定义对应在一起的位置以那个什么来划分，该位置可以是对应节点上的一个节点标签key；上述清单表示运行myapp这个pod的硬限制条件是必须满足对应对应节点上必须运行的有一个pod，这个pod上有一个app=nginx的标签；即标签为app=nginx的pod运行在那个节点，对应myapp就运行在那个节点；如果没有对应pod存在，则该pod也会处于pending状态；&lt;/p&gt;
&lt;p&gt;　　应用清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pods -L app -o wide
NAME        READY   STATUS    RESTARTS   AGE     IP            NODE             NOMINATED NODE   READINESS GATES   APP
nginx-pod   1/1     Running   0          8m25s   10.244.4.25   node04.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            nginx
[root@master01 ~]# kubectl apply -f require-podaffinity.yaml
pod/with-pod-affinity-1 created
[root@master01 ~]# kubectl get pods -L app -o wide          
NAME                  READY   STATUS    RESTARTS   AGE     IP            NODE             NOMINATED NODE   READINESS GATES   APP
nginx-pod             1/1     Running   0          8m43s   10.244.4.25   node04.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            nginx
with-pod-affinity-1   1/1     Running   0          6s      10.244.4.26   node04.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod运行在node04上了，其原因对应节点上有一个app=nginx标签的pod存在，满足对应podAffinity中的硬限制；&lt;/p&gt;
&lt;p&gt;　　验证：删除上述两个pod，然后再次应用清单，看看对应pod是否能够正常运行？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl delete all --all
pod &quot;nginx-pod&quot; deleted
pod &quot;with-pod-affinity-1&quot; deleted
service &quot;kubernetes&quot; deleted
[root@master01 ~]# kubectl apply -f require-podaffinity.yaml
pod/with-pod-affinity-1 created
[root@master01 ~]# kubectl get pods -o wide
NAME                  READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED NODE   READINESS GATES
with-pod-affinity-1   0/1     Pending   0          8s    &amp;lt;none&amp;gt;   &amp;lt;none&amp;gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod处于pending状态，其原因是没有一个节点上运行的有app=nginx pod标签，不满足podAffinity中的硬限制；&lt;/p&gt;
&lt;p&gt;　　示例：使用Affinity中的PodAffinity中的软限制调度策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat prefernece-podaffinity.yaml
apiVersion: v1
kind: Pod
metadata:
  name: with-pod-affinity-2
spec:
  affinity:
    podAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 80
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - {key: app, operator: In, values: [&quot;db&quot;]}
          topologyKey: rack
      - weight: 20
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - {key: app, operator: In, values: [&quot;db&quot;]}
          topologyKey: zone
  containers:
  - name: myapp
    image: ikubernetes/myapp:v1
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：podAffinity中的软限制需要用preferredDuringSchedulingIgnoredDuringExecution字段定义；其中weight用来定义对应软限制条件的权重，即满足对应软限制的node，最后得分会加上这个权重；上述清单表示以节点标签key=rack来划分位置，如果对应节点上运行的有对应pod标签为app=db的pod,则对应节点总分加80；如果以节点标签key=zone来划分位置，如果对应节点上运行的有pod标签为app=db的pod，对应节点总分加20；如果没有满足的节点，则使用默认调度规则进行调度；&lt;/p&gt;
&lt;p&gt;　　应用清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get node -L rack,zone                
NAME               STATUS   ROLES                  AGE   VERSION   RACK   ZONE
master01.k8s.org   Ready    control-plane,master   30d   v1.20.0          
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 30d   v1.20.0          
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 30d   v1.20.0          
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 30d   v1.20.0          
node04.k8s.org     Ready    &amp;lt;none&amp;gt;                 20d   v1.20.0          
[root@master01 ~]# kubectl get pods -o wide -L app              
NAME                  READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED NODE   READINESS GATES   APP
with-pod-affinity-1   0/1     Pending   0          22m   &amp;lt;none&amp;gt;   &amp;lt;none&amp;gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            
[root@master01 ~]# kubectl apply -f prefernece-podaffinity.yaml 
pod/with-pod-affinity-2 created
[root@master01 ~]# kubectl get pods -o wide -L app             
NAME                  READY   STATUS    RESTARTS   AGE   IP            NODE             NOMINATED NODE   READINESS GATES   APP
with-pod-affinity-1   0/1     Pending   0          22m   &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            
with-pod-affinity-2   1/1     Running   0          6s    10.244.4.28   node04.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod正常运行起来，并调度到node04上；从上面的示例来看，对应pod的运行并没有走软限制条件进行调度，而是走默认调度法则；其原因是对应节点没有满足对应软限制中的条件；&lt;/p&gt;
&lt;p&gt;　　验证：删除pod，在node01上打上rack节点标签，在node03上打上zone节点标签，再次运行pod，看看对应pod会怎么调度？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl delete -f prefernece-podaffinity.yaml
pod &quot;with-pod-affinity-2&quot; deleted
[root@master01 ~]# kubectl label node node01.k8s.org rack=group1
node/node01.k8s.org labeled
[root@master01 ~]# kubectl label node node03.k8s.org zone=group2
node/node03.k8s.org labeled
[root@master01 ~]# kubectl get node -L rack,zone
NAME               STATUS   ROLES                  AGE   VERSION   RACK     ZONE
master01.k8s.org   Ready    control-plane,master   30d   v1.20.0            
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 30d   v1.20.0   group1   
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 30d   v1.20.0            
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 30d   v1.20.0            group2
node04.k8s.org     Ready    &amp;lt;none&amp;gt;                 20d   v1.20.0            
[root@master01 ~]# kubectl apply -f prefernece-podaffinity.yaml
pod/with-pod-affinity-2 created
[root@master01 ~]# kubectl get pods -o wide
NAME                  READY   STATUS    RESTARTS   AGE   IP            NODE             NOMINATED NODE   READINESS GATES
with-pod-affinity-1   0/1     Pending   0          27m   &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
with-pod-affinity-2   1/1     Running   0          9s    10.244.4.29   node04.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod还是被调度到node04上运行，说明节点上的位置标签不影响其调度结果；&lt;/p&gt;
&lt;p&gt;　　验证：删除pod，在node01和node03上分别创建一个标签为app=db的pod，然后再次应用清单，看看对应pod会这么调度？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f prefernece-podaffinity.yaml
pod/with-pod-affinity-2 created
[root@master01 ~]# kubectl get pods -o wide
NAME                  READY   STATUS    RESTARTS   AGE   IP            NODE             NOMINATED NODE   READINESS GATES
with-pod-affinity-1   0/1     Pending   0          27m   &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
with-pod-affinity-2   1/1     Running   0          9s    10.244.4.29   node04.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
[root@master01 ~]# kubectl delete -f prefernece-podaffinity.yaml
pod &quot;with-pod-affinity-2&quot; deleted
[root@master01 ~]# cat pod-demo.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: redis-pod1
  labels:
    app: db
spec:
  nodeSelector:
    rack: group1
  containers:
  - name: redis
    image: redis:4-alpine
    imagePullPolicy: IfNotPresent
    ports:
    - name: redis
      containerPort: 6379
---
apiVersion: v1
kind: Pod
metadata:
  name: redis-pod2
  labels:
    app: db
spec:
  nodeSelector:
    zone: group2
  containers:
  - name: redis
    image: redis:4-alpine
    imagePullPolicy: IfNotPresent
    ports:
    - name: redis
      containerPort: 6379
[root@master01 ~]# kubectl apply -f pod-demo.yaml
pod/redis-pod1 created
pod/redis-pod2 created
[root@master01 ~]# kubectl get pods -L app -o wide
NAME                  READY   STATUS    RESTARTS   AGE   IP            NODE             NOMINATED NODE   READINESS GATES   APP
redis-pod1            1/1     Running   0          34s   10.244.1.35   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
redis-pod2            1/1     Running   0          34s   10.244.3.24   node03.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
with-pod-affinity-1   0/1     Pending   0          34m   &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            
[root@master01 ~]# kubectl apply -f prefernece-podaffinity.yaml
pod/with-pod-affinity-2 created
[root@master01 ~]# kubectl get pods -L app -o wide             
NAME                  READY   STATUS    RESTARTS   AGE   IP            NODE             NOMINATED NODE   READINESS GATES   APP
redis-pod1            1/1     Running   0          52s   10.244.1.35   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
redis-pod2            1/1     Running   0          52s   10.244.3.24   node03.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
with-pod-affinity-1   0/1     Pending   0          35m   &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            
with-pod-affinity-2   1/1     Running   0          9s    10.244.1.36   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod运行在node01上，其原因是对应node01上有一个pod标签为app=db的pod运行，满足对应软限制条件，并且对应节点上有key为rack的节点标签；即满足对应权重为80的条件，所以对应pod更倾向运行在node01上；&lt;/p&gt;
&lt;p&gt;　　示例：使用Affinity中的PodAffinity中的硬限制和软限制调度策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat require-preference-podaffinity.yaml
apiVersion: v1
kind: Pod
metadata:
  name: with-pod-affinity-3
spec:
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - {key: app, operator: In, values: [&quot;db&quot;]}
        topologyKey: kubernetes.io/hostname
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 80
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - {key: app, operator: In, values: [&quot;db&quot;]}
          topologyKey: rack
      - weight: 20
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - {key: app, operator: In, values: [&quot;db&quot;]}
          topologyKey: zone
  containers:
  - name: myapp
    image: ikubernetes/myapp:v1
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：上述清单表示对应pod必须运行在对应节点上运行的有标签为app=db的pod，如果没有节点满足，则对应pod只能挂起；如果满足的节点有多个，则对应满足软限制中的要求；如果满足硬限制的同时也满足对应节点上有key为rack的节点标签，则对应节点总分加80，如果对应节点有key为zone的节点标签，则对应节点总分加20；&lt;/p&gt;
&lt;p&gt;　　应用清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pods -o wide -L app
NAME                  READY   STATUS    RESTARTS   AGE   IP            NODE             NOMINATED NODE   READINESS GATES   APP
redis-pod1            1/1     Running   0          13m   10.244.1.35   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
redis-pod2            1/1     Running   0          13m   10.244.3.24   node03.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
with-pod-affinity-1   0/1     Pending   0          48m   &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            
with-pod-affinity-2   1/1     Running   0          13m   10.244.1.36   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            
[root@master01 ~]# kubectl apply -f require-preference-podaffinity.yaml
pod/with-pod-affinity-3 created
[root@master01 ~]# kubectl get pods -o wide -L app                     
NAME                  READY   STATUS    RESTARTS   AGE   IP            NODE             NOMINATED NODE   READINESS GATES   APP
redis-pod1            1/1     Running   0          14m   10.244.1.35   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
redis-pod2            1/1     Running   0          14m   10.244.3.24   node03.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
with-pod-affinity-1   0/1     Pending   0          48m   &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            
with-pod-affinity-2   1/1     Running   0          13m   10.244.1.36   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            
with-pod-affinity-3   1/1     Running   0          6s    10.244.1.37   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod被调度到node01上运行，其原因是对应节点满足硬限制条件的同时也满足对应权重最大的软限制条件；&lt;/p&gt;
&lt;p&gt;　　验证：删除上述pod，重新应用清单看看对应pod是否还会正常运行？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl delete all --all
pod &quot;redis-pod1&quot; deleted
pod &quot;redis-pod2&quot; deleted
pod &quot;with-pod-affinity-1&quot; deleted
pod &quot;with-pod-affinity-2&quot; deleted
pod &quot;with-pod-affinity-3&quot; deleted
service &quot;kubernetes&quot; deleted
[root@master01 ~]# kubectl apply -f require-preference-podaffinity.yaml
pod/with-pod-affinity-3 created
[root@master01 ~]# kubectl get pods -o wide
NAME                  READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED NODE   READINESS GATES
with-pod-affinity-3   0/1     Pending   0          5s    &amp;lt;none&amp;gt;   &amp;lt;none&amp;gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod创建出来处于pending状态，其原因是没有任何节点满足对应pod调度的硬限制；所以对应pod没法调度，只能被挂起；&lt;/p&gt;
&lt;p&gt;　　示例：使用Affinity中的podAntiAffinity调度策略&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat require-preference-podantiaffinity.yaml
apiVersion: v1
kind: Pod
metadata:
  name: with-pod-affinity-4
spec:
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - {key: app, operator: In, values: [&quot;db&quot;]}
        topologyKey: kubernetes.io/hostname
      preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 80
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - {key: app, operator: In, values: [&quot;db&quot;]}
          topologyKey: rack
      - weight: 20
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - {key: app, operator: In, values: [&quot;db&quot;]}
          topologyKey: zone
  containers:
  - name: myapp
    image: ikubernetes/myapp:v1
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：podantiaffinity的使用和podaffinity的使用方式一样，只是其对应的逻辑相反，podantiaffinity是定义满足条件的节点不运行对应pod，podaffinity是满足条件运行pod；上述清单表示对应pod一定不能运行在有标签为app=db的pod运行的节点，并且对应节点上如果有key为rack和key为zone的节点标签，这类节点也不运行；即只能运行在上述三个条件都满足的节点上；如果所有节点都满足上述三个条件，则对应pod只能挂；如果单单使用软限制，则pod会勉强运行在对应节点得分较低的节点上运行；&lt;/p&gt;
&lt;p&gt;　　应用清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl get pods -o wide
NAME                  READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED NODE   READINESS GATES
with-pod-affinity-3   0/1     Pending   0          22m   &amp;lt;none&amp;gt;   &amp;lt;none&amp;gt;   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# kubectl apply -f require-preference-podantiaffinity.yaml
pod/with-pod-affinity-4 created
[root@master01 ~]# kubectl get pods -o wide
NAME                  READY   STATUS    RESTARTS   AGE   IP            NODE             NOMINATED NODE   READINESS GATES
with-pod-affinity-3   0/1     Pending   0          22m   &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
with-pod-affinity-4   1/1     Running   0          6s    10.244.4.30   node04.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
[root@master01 ~]# kubectl get node -L rack,zone
NAME               STATUS   ROLES                  AGE   VERSION   RACK     ZONE
master01.k8s.org   Ready    control-plane,master   30d   v1.20.0            
node01.k8s.org     Ready    &amp;lt;none&amp;gt;                 30d   v1.20.0   group1   
node02.k8s.org     Ready    &amp;lt;none&amp;gt;                 30d   v1.20.0            
node03.k8s.org     Ready    &amp;lt;none&amp;gt;                 30d   v1.20.0            group2
node04.k8s.org     Ready    &amp;lt;none&amp;gt;                 20d   v1.20.0            
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod被调度到node04上运行；其原因是node04上没有上述三个条件；当然node02也是符合运行对应pod的节点；&lt;/p&gt;
&lt;p&gt;　　验证：删除上述pod，在四个节点上各自运行一个app=db标签的pod，再次应用清单，看看对用pod怎么调度？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl delete all --all
pod &quot;with-pod-affinity-3&quot; deleted
pod &quot;with-pod-affinity-4&quot; deleted
service &quot;kubernetes&quot; deleted
[root@master01 ~]# cat pod-demo.yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: redis-ds
  labels:
    app: db
spec:
  selector:
    matchLabels:
      app: db
  template:
    metadata:
      labels:
        app: db
    spec:
      containers:
      - name: redis
        image: redis:4-alpine
        ports:
        - name: redis
          containerPort: 6379
[root@master01 ~]# kubectl apply -f pod-demo.yaml
daemonset.apps/redis-ds created
[root@master01 ~]# kubectl get pods -L app -o wide
NAME             READY   STATUS    RESTARTS   AGE   IP            NODE             NOMINATED NODE   READINESS GATES   APP
redis-ds-4bnmv   1/1     Running   0          44s   10.244.2.26   node02.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
redis-ds-c2h77   1/1     Running   0          44s   10.244.1.38   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
redis-ds-mbxcd   1/1     Running   0          44s   10.244.4.32   node04.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
redis-ds-r2kxv   1/1     Running   0          44s   10.244.3.25   node03.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
[root@master01 ~]# kubectl apply -f require-preference-podantiaffinity.yaml
pod/with-pod-affinity-5 created
[root@master01 ~]# kubectl get pods -o wide -L app
NAME                  READY   STATUS    RESTARTS   AGE     IP            NODE             NOMINATED NODE   READINESS GATES   APP
redis-ds-4bnmv        1/1     Running   0          2m29s   10.244.2.26   node02.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
redis-ds-c2h77        1/1     Running   0          2m29s   10.244.1.38   node01.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
redis-ds-mbxcd        1/1     Running   0          2m29s   10.244.4.32   node04.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
redis-ds-r2kxv        1/1     Running   0          2m29s   10.244.3.25   node03.k8s.org   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            db
with-pod-affinity-5   0/1     Pending   0          9s      &amp;lt;none&amp;gt;        &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;            
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应pod没有节点可以运行，处于pending状态，其原因对应节点都满足排斥运行对应pod的硬限制；&lt;/p&gt;
&lt;p&gt;　　通过上述验证过程可以总结，不管是pod与节点的亲和性还是pod与pod的亲和性，只要在调度策略中定义了硬亲和，对应pod一定会运行在满足硬亲和条件的节点上，如果没有节点满足硬亲和条件，则对应pod挂起；如果只是定义了软亲和，则对应pod会优先运行在匹配权重较大软限制条件的节点上，如果没有节点满足软限制，对应调度就走默认调度策略，找得分最高的节点运行；对于反亲和性也是同样的逻辑；不同的是反亲和满足对应硬限制或软限制，对应pod不会运行在对应节点上；这里还需要注意一点，使用pod与pod的亲和调度策略，如果节点较多，其规则不应该设置的过于精细，颗粒度应该适当即可，过度精细会导致pod在调度时，筛选节点消耗更多的资源，导致整个集群性能下降；建议在大规模集群中使用node affinity；&lt;/p&gt;
</description>
<pubDate>Thu, 07 Jan 2021 15:46:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们了解了k8s上的NetworkPolicy资源的使用和工作逻辑，回顾请参考：https://www.cnblogs.com/qiuhom-1874/p/14227660.html；今天我们来聊</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14243312.html</dc:identifier>
</item>
<item>
<title>前端模块化 - 两只小蚂蚁</title>
<link>http://www.cnblogs.com/full-stack-engineer/p/14249312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/full-stack-engineer/p/14249312.html</guid>
<description>&lt;p&gt;在JS没有模块化标准的时代，如果存在以下依赖关系：&lt;/p&gt;
&lt;p&gt;main.js -&amp;gt; b.js -&amp;gt; a.js&lt;/p&gt;
&lt;p&gt;那么我们必须把js文件的顺序按照模块的依赖关系顺序放到页面中(简单的举例，不考虑循环依赖等复杂情况)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- NoModule.html --&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;icon&quot; href=&quot;data:image/ico;base64,aWNv&quot;&amp;gt;
    &amp;lt;script src=&quot;./a.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;./b.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;./main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要提前加载好所有的依赖。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//main.js
(function(){
    moduleB.logb();
})()
//b.js
var moduleB = (function () {
    function logb() {
        moduleA.loga();
        console.log(&quot;logb&quot;);
    }
    return { logb: logb }
})()
//a.js
var moduleA = (function () {
    function loga() {
        console.log(&quot;loga&quot;);
    }
    
    return { loga: loga }
})()
//输出结果
//loga
//logb
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式相当简单粗暴啊，当然造成的问题也很多：依赖关系无法显式维护，全局命名空间污染冲突等等&lt;/p&gt;

&lt;p&gt;首先：AMD是一种规范，全称Asynchronous Module Definition 异步模块定义&lt;/p&gt;
&lt;p&gt;其次：RequireJS(2.3.6)是AMD的一个实现，我们可以使用RequireJS来实际看看这种规范到底怎么回事&lt;/p&gt;
&lt;p&gt;依赖关系：main.js -&amp;gt; b.js -&amp;gt; a.js&lt;/p&gt;
&lt;p&gt;我们来看看js文件的在页面中的结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- AMD.html --&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;icon&quot; href=&quot;data:image/ico;base64,aWNv&quot;&amp;gt;
    &amp;lt;script src=&quot;./require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;./main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是各个文件的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//main.js
console.log(&quot;load main.js&quot;);
require(['./b.js'], function (b) {
    console.log(&quot;call b.logb()&quot;);
    b.logb();    
    return {};
})
console.log(&quot;end main.js&quot;);
//b.js
define(['./a.js'], function (a) {
    console.log(&quot;load b.js&quot;);

    function sleep(d) {
        for (var t = Date.now(); Date.now() - t &amp;lt;= d;);
    }    

    function logb() {
        a.loga();
        //注意，这里暂停了5秒
        var startTime = new Date().getMinutes() + &quot;:&quot; + new Date().getSeconds();
        console.log(startTime);
        sleep(5000);
        var endTime = new Date().getMinutes() + &quot;:&quot; + new Date().getSeconds();
        console.log(endTime);
        console.log(&quot;logb&quot;);
    }

    return {
        logb: logb
    };
})
//a.js
define([], function () {
    console.log(&quot;load a.js&quot;)
    function loga() {
        console.log(&quot;loga&quot;);
    }

    return {
        loga: loga
    };
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面可以看出来，我们初始页面并不需要引入依赖的模块js文件。Chrome中打开AMD.html，我们可以观察到网络时序图如下，可以明显的发现b.js和a.js是在main.js之后被请求的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1323548/202101/1323548-20210107232727912-1802829151.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时再看看我们的页面，发现多了2个script标签把b.js和a.js给引入进来了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- AMD.html --&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;icon&quot; href=&quot;data:image/ico;base64,aWNv&quot;&amp;gt;
    &amp;lt;script src=&quot;./require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;./main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; async=&quot;&quot; data-requirecontext=&quot;_&quot; data-requiremodule=&quot;b.js&quot;
        src=&quot;b.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; async=&quot;&quot; data-requirecontext=&quot;_&quot; data-requiremodule=&quot;a.js&quot;
        src=&quot;a.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是RequireJS帮我们做的事情了，根据我们指定的依赖，在代码&lt;strong&gt;运行时&lt;/strong&gt;动态的将依赖的模块js文件加载到运行环境中。&lt;/p&gt;
&lt;p&gt;我们再来看看输出:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1323548/202101/1323548-20210107232747925-219436689.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以很明显的发现，&lt;strong&gt;依赖模块的加载没有阻塞后面代码的执行，并且模块会在使用前加载好&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而且模块加载是异步的。&lt;/p&gt;

&lt;p&gt;首先：CMD是一种规范，全称Common Module Definition 通用模块定义&lt;/p&gt;
&lt;p&gt;其次：Sea.js(3.0.0)是CMD的一个实现，我们可以使用Sea.js来实际看看这种规范到底怎么回事&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- CMD.html --&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;icon&quot; href=&quot;data:image/ico;base64,aWNv&quot;&amp;gt;
    &amp;lt;script src=&quot;./sea.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
        seajs.use(&quot;./main.js&quot;);
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//main.js
console.log(&quot;load main.js&quot;);
define(function (require, exports, module) {  
    console.log(&quot;call b.logb()&quot;);
    var b = require('./b.js');    
    b.logb();    
});
console.log(&quot;end main.js&quot;);

//b.js
console.log(&quot;load b.js&quot;);
define(function (require, exports, module) {
    function sleep(d) {
        for (var t = Date.now(); Date.now() - t &amp;lt;= d;);
    }

    function logb() {
        var a = require('./a.js');
        a.loga();
        //注意，这里暂停了5秒
        var startTime = new Date().getMinutes() + &quot;:&quot; + new Date().getSeconds();
        console.log(startTime);
        sleep(5000);
        var endTime = new Date().getMinutes() + &quot;:&quot; + new Date().getSeconds();
        console.log(endTime);
        console.log(&quot;logb&quot;);
    }

    exports.logb = logb;
})

//a.js
console.log(&quot;load a.js&quot;);
define(function (require, exports, module) { 
    function loga() {
        console.log(&quot;loga&quot;);
    }
    exports.loga = loga;
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，sea.js会帮我们把需要的依赖模块动态的加载进来，这里就不截图了。&lt;/p&gt;
&lt;p&gt;同样的，我们先看输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1323548/202101/1323548-20210107232809447-1180446159.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有没有发现，&lt;strong&gt;虽然写法上依赖就近，但实际上依赖的模块还是被前置加载了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最新版本中模块加载也是异步的了。&lt;/p&gt;

&lt;p&gt;NodeJS运行环境下的模块规范&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//main.js
console.log(&quot;load main.js&quot;);

const a = require('./a.js');
const b = require('./b.js');
a.loga();
b.logb();

console.log(&quot;end main.js&quot;);

//a.js
console.log(&quot;load a.js&quot;);
function loga() {
    console.log(&quot;loga&quot;);
}

module.exports.loga = loga;

//b.js
console.log(&quot;load b.js&quot;);

function sleep(d) {
    for (var t = Date.now(); Date.now() - t &amp;lt;= d;);
}    

function logb() {    
    //注意，这里暂停了5秒
    var startTime = new Date().getMinutes() + &quot;:&quot; + new Date().getSeconds();
    console.log(startTime);
    sleep(5000);
    var endTime = new Date().getMinutes() + &quot;:&quot; + new Date().getSeconds();
    console.log(endTime);
    console.log(&quot;logb&quot;);
}

exports.logb = logb;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不同于最新的requireJS和sea.js，CommonJS在node环境中是同步IO，会阻塞后面的代码执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1323548/202101/1323548-20210107232824080-1609681860.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ES6也有自己的模块化方案，现在我们即使不使用AMD或者CMD的js实现库，也能在浏览器中直接使用模块化的方案了。浏览器的支持率可以参考： &lt;a href=&quot;https://caniuse.com/?search=import&quot; target=&quot;_blank&quot;&gt;https://caniuse.com/?search=import&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- ES6.html --&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;icon&quot; href=&quot;data:image/ico;base64,aWNv&quot;&amp;gt; 
    &amp;lt;script type=&quot;module&quot; src=&quot;./main.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;!-- &amp;lt;script src=&quot;./main2.js&quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;ES6.html&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ES6支持二种方式的模块使用，第一种是在script上使用type=module&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//main.js
console.log(&quot;load main.js&quot;);

import { loga } from './a.js';
import logb from './b.js';
loga();
logb();

console.log(&quot;end main.js&quot;);

//a.js
console.log(&quot;load a.js&quot;);

export function loga() {
    console.log(&quot;loga&quot;);
}

//b.js
console.log(&quot;load b.js&quot;);

function sleep(d) {
    for (var t = Date.now(); Date.now() - t &amp;lt;= d;);
}

function logb() {
    //注意，这里暂停了5秒
    var startTime = new Date().getMinutes() + &quot;:&quot; + new Date().getSeconds();
    console.log(startTime);
    sleep(5000);
    var endTime = new Date().getMinutes() + &quot;:&quot; + new Date().getSeconds();
    console.log(endTime);
    console.log(&quot;logb&quot;);
}

export default { logb };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1323548/202101/1323548-20210107232843673-1327521722.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现依赖模块还是会被提前加载，再看看第二种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- ES6.html --&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;link rel=&quot;icon&quot; href=&quot;data:image/ico;base64,aWNv&quot;&amp;gt; 
    &amp;lt;!-- &amp;lt;script type=&quot;module&quot; src=&quot;./main.js&quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;
    &amp;lt;script src=&quot;./main2.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;ES6.html&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;console.log(&quot;load main.js&quot;);
import('./a.js').then(a =&amp;gt; {
    a.loga();
})
import('./b.js').then(b =&amp;gt; {
    console.log(b.default());    
})
console.log(&quot;end main.js&quot;);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1323548/202101/1323548-20210107232854529-2057522100.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，模块是异步加载进来的。&lt;/p&gt;

&lt;p&gt;可能有人有疑问，我们在Webpack中好像既可以使用require和module.exports的CommonJS语法，也可以使用export和import的ES6语法。那Webpack又是怎么处理的？&lt;/p&gt;
&lt;p&gt;而且，前面列出的几个模块化方案中基本都是一个js文件作为一个模块，但是好像Webpack没有输出那么多的文件啊？&lt;/p&gt;
&lt;p&gt;其实Webpack有自己的模块化实现，兼容了这二种标准，而且还有一个编译的过程将多文件bundle到一起。详细的可以参考：&lt;a href=&quot;https://segmentfault.com/a/1190000010349749&quot; target=&quot;_blank&quot;&gt;https://segmentfault.com/a/1190000010349749&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其核心还是模块化设计的几个要点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模块加载&lt;/li&gt;
&lt;li&gt;模块隔离&lt;/li&gt;
&lt;li&gt;模块缓存控制&lt;/li&gt;
&lt;li&gt;模块依赖维护&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实从个人观点来看，前端的模块化经历了:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;野蛮发展阶段：每个团队和公司有自己的方案，好苦逼&lt;/li&gt;
&lt;li&gt;到AMD/CMD阶段：行业领头人推广，大家围观&lt;/li&gt;
&lt;li&gt;再到原生ES6支持阶段：建立浏览器标准，大家围观&lt;/li&gt;
&lt;li&gt;和编译支持阶段：在前端越来越复杂，引入预编译模式，大家膜拜&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这么几个以上的阶段后，现阶段基本比较稳定在预编译模式，结合预编译工具的其他功能和带来的便利，前端模块化不再是一个主要关注的技术点。取而代之的是更加关注：代码分割、按需加载、Tree Shaking、模块合并、模块缓存等等问题。&lt;/p&gt;
</description>
<pubDate>Thu, 07 Jan 2021 15:31:00 +0000</pubDate>
<dc:creator>两只小蚂蚁</dc:creator>
<og:description>1. 没有模块化的时代 在JS没有模块化标准的时代，如果存在以下依赖关系： main.js → b.js → a.js 那么我们必须把js文件的顺序按照模块的依赖关系顺序放到页面中(简单的举例，不考虑</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/full-stack-engineer/p/14249312.html</dc:identifier>
</item>
<item>
<title>.NET 云原生架构师训练营（模块二 基础巩固 MongoDB API重构）--学习笔记 - MingsonZheng</title>
<link>http://www.cnblogs.com/MingsonZheng/p/14249227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MingsonZheng/p/14249227.html</guid>
<description>&lt;ul&gt;&lt;li&gt;Lighter.Domain&lt;/li&gt;
&lt;li&gt;Lighter.Application.Contract&lt;/li&gt;
&lt;li&gt;Lighter.Application&lt;/li&gt;
&lt;li&gt;LighterApi&lt;/li&gt;
&lt;li&gt;Lighter.Application.Tests&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;lighterdomain&quot;&gt;Lighter.Domain&lt;/h2&gt;
&lt;p&gt;将数据实体转移到 Lighter.Domain 层&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1412316/202101/1412316-20210107225655307-1183300869.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;lighterapplicationcontract&quot;&gt;Lighter.Application.Contract&lt;/h2&gt;
&lt;p&gt;将业务从controller 抽取到 Lighter.Application 层，并为业务建立抽象接口 Lighter.Application.Contract层&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1412316/202101/1412316-20210107225705473-1873465949.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IQuestionService&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace Lighter.Application.Contracts
{
    public interface IQuestionService
    {
        Task&amp;lt;Question&amp;gt; GetAsync(string id, CancellationToken cancellationToken);
        Task&amp;lt;QuestionAnswerReponse&amp;gt; GetWithAnswerAsync(string id, CancellationToken cancellationToken);
        Task&amp;lt;List&amp;lt;Question&amp;gt;&amp;gt; GetListAsync(List&amp;lt;string&amp;gt; tags, CancellationToken cancellationToken, string sort = &quot;createdAt&quot;, int skip = 0, int limit = 10);
        Task&amp;lt;Question&amp;gt; CreateAsync(Question question, CancellationToken cancellationToken);
        Task UpdateAsync(string id, QuestionUpdateRequest request, CancellationToken cancellationToken);
        Task&amp;lt;Answer&amp;gt; AnswerAsync(string id, AnswerRequest request, CancellationToken cancellationToken);
        Task CommentAsync(string id, CommentRequest request, CancellationToken cancellationToken);
        Task UpAsync(string id, CancellationToken cancellationToken);
        Task DownAsync(string id, CancellationToken cancellationToken);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;lighterapplication&quot;&gt;Lighter.Application&lt;/h2&gt;
&lt;p&gt;实现业务接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1412316/202101/1412316-20210107225716605-639664147.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;QuestionService&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace Lighter.Application
{
    public class QuestionService : IQuestionService
    {
        private readonly IMongoCollection&amp;lt;Question&amp;gt; _questionCollection;
        private readonly IMongoCollection&amp;lt;Vote&amp;gt; _voteCollection;
        private readonly IMongoCollection&amp;lt;Answer&amp;gt; _answerCollection;

        public QuestionService(IMongoClient mongoClient)
        {
            var database = mongoClient.GetDatabase(&quot;lighter&quot;);

            _questionCollection = database.GetCollection&amp;lt;Question&amp;gt;(&quot;questions&quot;);
            _voteCollection = database.GetCollection&amp;lt;Vote&amp;gt;(&quot;votes&quot;);
            _answerCollection = database.GetCollection&amp;lt;Answer&amp;gt;(&quot;answers&quot;);
        }


        public async Task&amp;lt;Question&amp;gt; GetAsync(string id, CancellationToken cancellationToken)
        {
            // linq 查询
            var question = await _questionCollection.AsQueryable()
                .FirstOrDefaultAsync(q =&amp;gt; q.Id == id, cancellationToken: cancellationToken);

            //// mongo 查询表达式
            ////var filter = Builders&amp;lt;Question&amp;gt;.Filter.Eq(q =&amp;gt; q.Id, id);

            //// 构造空查询条件的表达式
            //var filter = string.IsNullOrEmpty(id)
            //    ? Builders&amp;lt;Question&amp;gt;.Filter.Empty
            //    : Builders&amp;lt;Question&amp;gt;.Filter.Eq(q =&amp;gt; q.Id, id);

            //// 多段拼接 filter
            //var filter2 = Builders&amp;lt;Question&amp;gt;.Filter.And(filter, Builders&amp;lt;Question&amp;gt;.Filter.Eq(q =&amp;gt; q.TenantId, &quot;001&quot;));
            //await _questionCollection.Find(filter).FirstOrDefaultAsync(cancellationToken);

            return question;
        }

        public async Task&amp;lt;List&amp;lt;Question&amp;gt;&amp;gt; GetListAsync(List&amp;lt;string&amp;gt; tags, CancellationToken cancellationToken, string sort = &quot;createdAt&quot;, int skip = 0, int limit = 10)
        {
            //// linq 查询
            //await _questionCollection.AsQueryable().Where(q =&amp;gt; q.ViewCount &amp;gt; 10)
            //    .ToListAsync(cancellationToken: cancellationToken);

            var filter = Builders&amp;lt;Question&amp;gt;.Filter.Empty;

            if (tags != null &amp;amp;&amp;amp; tags.Any())
            {
                filter = Builders&amp;lt;Question&amp;gt;.Filter.AnyIn(q =&amp;gt; q.Tags, tags);
            }

            var sortDefinition = Builders&amp;lt;Question&amp;gt;.Sort.Descending(new StringFieldDefinition&amp;lt;Question&amp;gt;(sort));

            var result = await _questionCollection
                .Find(filter)
                .Sort(sortDefinition)
                .Skip(skip)
                .Limit(limit)
                .ToListAsync(cancellationToken: cancellationToken);

            return result;
        }

        public async Task&amp;lt;QuestionAnswerReponse&amp;gt; GetWithAnswerAsync(string id, CancellationToken cancellationToken)
        {
            // linq 查询
            var query = from question in _questionCollection.AsQueryable()
                where question.Id == id
                join a in _answerCollection.AsQueryable() on question.Id equals a.QuestionId into answers
                select new { question, answers };

            var result = await query.FirstOrDefaultAsync(cancellationToken);

            //// mongo 查询表达式
            //var result = await _questionCollection.Aggregate()
            //    .Match(q =&amp;gt; q.Id == id)
            //    .Lookup&amp;lt;Answer, QuestionAnswerReponse&amp;gt;(
            //        foreignCollectionName: &quot;answers&quot;,
            //        localField: &quot;answers&quot;,
            //        foreignField: &quot;questionId&quot;,
            //        @as: &quot;AnswerList&quot;)
            //    .FirstOrDefaultAsync(cancellationToken: cancellationToken);

            return new QuestionAnswerReponse {AnswerList = result.answers};
        }

        public async Task&amp;lt;Answer&amp;gt; AnswerAsync(string id, AnswerRequest request, CancellationToken cancellationToken)
        {
            var answer = new Answer { QuestionId = id, Content = request.Content, Id = Guid.NewGuid().ToString() };
            _answerCollection.InsertOneAsync(answer, cancellationToken);

            var filter = Builders&amp;lt;Question&amp;gt;.Filter.Eq(q =&amp;gt; q.Id, id);
            var update = Builders&amp;lt;Question&amp;gt;.Update.Push(q =&amp;gt; q.Answers, answer.Id);

            await _questionCollection.UpdateOneAsync(filter, update, null, cancellationToken);

            return answer;
        }

        public async Task CommentAsync(string id, CommentRequest request, CancellationToken cancellationToken)
        {
            var filter = Builders&amp;lt;Question&amp;gt;.Filter.Eq(q =&amp;gt; q.Id, id);
            var update = Builders&amp;lt;Question&amp;gt;.Update.Push(q =&amp;gt; q.Comments,
                new Comment { Content = request.Content, CreatedAt = DateTime.Now });

            await _questionCollection.UpdateOneAsync(filter, update, null, cancellationToken);
        }

        public async Task&amp;lt;Question&amp;gt; CreateAsync(Question question, CancellationToken cancellationToken)
        {
            question.Id = Guid.NewGuid().ToString();
            await _questionCollection.InsertOneAsync(question, new InsertOneOptions { BypassDocumentValidation = false },
                cancellationToken);
            return question;
        }

        public async Task DownAsync(string id, CancellationToken cancellationToken)
        {
            var vote = new Vote
            {
                Id = Guid.NewGuid().ToString(),
                SourceType = ConstVoteSourceType.Question,
                SourceId = id,
                Direction = EnumVoteDirection.Down
            };

            await _voteCollection.InsertOneAsync(vote, cancellationToken);

            var filter = Builders&amp;lt;Question&amp;gt;.Filter.Eq(q =&amp;gt; q.Id, id);
            var update = Builders&amp;lt;Question&amp;gt;.Update.Inc(q =&amp;gt; q.VoteCount, -1).AddToSet(q =&amp;gt; q.VoteDowns, vote.Id);
            await _questionCollection.UpdateOneAsync(filter, update);
        }


        public async Task UpAsync(string id, CancellationToken cancellationToken)
        {
            var vote = new Vote
            {
                Id = Guid.NewGuid().ToString(),
                SourceType = ConstVoteSourceType.Question,
                SourceId = id,
                Direction = EnumVoteDirection.Up
            };

            await _voteCollection.InsertOneAsync(vote, cancellationToken);

            var filter = Builders&amp;lt;Question&amp;gt;.Filter.Eq(q =&amp;gt; q.Id, id);
            var update = Builders&amp;lt;Question&amp;gt;.Update.Inc(q =&amp;gt; q.VoteCount, 1).AddToSet(q =&amp;gt; q.VoteUps, vote.Id);
            await _questionCollection.UpdateOneAsync(filter, update);
        }

        public async Task UpdateAsync(string id, QuestionUpdateRequest request, CancellationToken cancellationToken)
        {
            var filter = Builders&amp;lt;Question&amp;gt;.Filter.Eq(q =&amp;gt; q.Id, id);

            //var update = Builders&amp;lt;Question&amp;gt;.Update
            //    .Set(q =&amp;gt; q.Title, request.Title)
            //    .Set(q =&amp;gt; q.Content, request.Content)
            //    .Set(q =&amp;gt; q.Tags, request.Tags)
            //    .Push(q =&amp;gt; q.Comments, new Comment {Content = request.Summary, CreatedAt = DateTime.Now});

            var updateFieldList = new List&amp;lt;UpdateDefinition&amp;lt;Question&amp;gt;&amp;gt;();

            if (!string.IsNullOrWhiteSpace(request.Title))
                updateFieldList.Add(Builders&amp;lt;Question&amp;gt;.Update.Set(q =&amp;gt; q.Title, request.Title));

            if (!string.IsNullOrWhiteSpace(request.Content))
                updateFieldList.Add(Builders&amp;lt;Question&amp;gt;.Update.Set(q =&amp;gt; q.Content, request.Content));

            if (request.Tags != null &amp;amp;&amp;amp; request.Tags.Any())
                updateFieldList.Add(Builders&amp;lt;Question&amp;gt;.Update.Set(q =&amp;gt; q.Tags, request.Tags));

            updateFieldList.Add(Builders&amp;lt;Question&amp;gt;.Update.Push(q =&amp;gt; q.Comments,
                new Comment { Content = request.Summary, CreatedAt = DateTime.Now }));

            var update = Builders&amp;lt;Question&amp;gt;.Update.Combine(updateFieldList);

            await _questionCollection.UpdateOneAsync(filter, update, cancellationToken: cancellationToken);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;lighterapi&quot;&gt;LighterApi&lt;/h2&gt;
&lt;p&gt;注册服务&lt;/p&gt;
&lt;p&gt;Startup&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddScoped&amp;lt;IQuestionService, QuestionService&amp;gt;()
        .AddScoped&amp;lt;IAnswerService, AnswerService&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用服务&lt;/p&gt;
&lt;p&gt;QuestionController&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace LighterApi.Controller
{
    [ApiController]
    [Route(&quot;api/[controller]&quot;)]
    public class QuestionController : ControllerBase
    {
        private readonly IQuestionService _questionService;

        public QuestionController(IQuestionService questionService)
        {
            _questionService = questionService;
        }

        [HttpGet]
        [Route(&quot;{id}&quot;)]
        public async Task&amp;lt;ActionResult&amp;lt;Question&amp;gt;&amp;gt; GetAsync(string id, CancellationToken cancellationToken)
        {
            var question = await _questionService.GetAsync(id, cancellationToken);

            if (question == null)
                return NotFound();

            return Ok(question);
        }

        [HttpGet]
        [Route(&quot;{id}/answers&quot;)]
        public async Task&amp;lt;ActionResult&amp;gt; GetWithAnswerAsync(string id, CancellationToken cancellationToken)
        {
            var result = await _questionService.GetWithAnswerAsync(id, cancellationToken);

            if (result == null)
                return NotFound();

            return Ok(result);
        }

        [HttpGet]
        public async Task&amp;lt;ActionResult&amp;lt;List&amp;lt;Question&amp;gt;&amp;gt;&amp;gt; GetListAsync([FromQuery] List&amp;lt;string&amp;gt; tags,
            CancellationToken cancellationToken, [FromQuery] string sort = &quot;createdAt&quot;, [FromQuery] int skip = 0,
            [FromQuery] int limit = 10)
        {
            var result = await _questionService.GetListAsync(tags, cancellationToken, sort, skip, limit);
            return Ok(result);
        }

        [HttpPost]
        public async Task&amp;lt;ActionResult&amp;lt;Question&amp;gt;&amp;gt; CreateAsync([FromBody] Question question, CancellationToken cancellationToken)
        {
            question = await _questionService.CreateAsync(question, cancellationToken);
            return StatusCode((int) HttpStatusCode.Created, question);
        }

        [HttpPatch]
        [Route(&quot;{id}&quot;)]
        public async Task&amp;lt;ActionResult&amp;gt; UpdateAsync([FromRoute] string id, [FromBody] QuestionUpdateRequest request, CancellationToken cancellationToken)
        {
            if (string.IsNullOrEmpty(request.Summary))
                throw new ArgumentNullException(nameof(request.Summary));

            await _questionService.UpdateAsync(id, request, cancellationToken);
            return Ok();
        }

        [HttpPost]
        [Route(&quot;{id}/answer&quot;)]
        public async Task&amp;lt;ActionResult&amp;lt;Answer&amp;gt;&amp;gt; AnswerAsync([FromRoute] string id, [FromBody] AnswerRequest request, CancellationToken cancellationToken)
        {
            var answer = await _questionService.AnswerAsync(id, request, cancellationToken);
            return Ok(answer);
        }

        [HttpPost]
        [Route(&quot;{id}/comment&quot;)]
        public async Task&amp;lt;ActionResult&amp;gt; CommentAsync([FromRoute] string id, [FromBody] CommentRequest request, CancellationToken cancellationToken)
        {
            await _questionService.CommentAsync(id, request, cancellationToken);
            return Ok();
        }

        [HttpPost]
        [Route(&quot;{id}/up&quot;)]
        public async Task&amp;lt;ActionResult&amp;gt; UpAsync([FromBody] string id, CancellationToken cancellationToken)
        {
            await _questionService.UpAsync(id, cancellationToken);
            return Ok();
        }

        [HttpPost]
        [Route(&quot;{id}/down&quot;)]
        public async Task&amp;lt;ActionResult&amp;gt; DownAsync([FromBody] string id, CancellationToken cancellationToken)
        {
            await _questionService.DownAsync(id, cancellationToken);
            return Ok();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;lighterapplicationtests&quot;&gt;Lighter.Application.Tests&lt;/h2&gt;
&lt;p&gt;建立单元测试项目，测试Lihgter.Application（需要使用到xunit、Mongo2go）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1412316/202101/1412316-20210107225734335-1962481585.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Mongo2go：内存级别引擎&lt;/p&gt;
&lt;h3 id=&quot;访问-mongo-内存数据库&quot;&gt;访问 Mongo 内存数据库&lt;/h3&gt;
&lt;p&gt;SharedFixture&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace Lighter.Application.Tests
{
    public class SharedFixture:IAsyncLifetime
    {
        private MongoDbRunner _runner;
        public MongoClient Client { get; private set; }
        public IMongoDatabase Database { get; private set; }

        public async Task InitializeAsync()
        {
            _runner = MongoDbRunner.Start();
            Client = new MongoClient(_runner.ConnectionString);
            Database = Client.GetDatabase(&quot;db&quot;);

            //var hostBuilder = Program.CreateWebHostBuilder(new string[0]);
            //var host = hostBuilder.Build();
            //ServiceProvider = host.Services;
        }

        public Task DisposeAsync()
        {
            _runner?.Dispose();
            _runner = null;
            return Task.CompletedTask;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;questionservicetests&quot;&gt;QuestionServiceTests&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;namespace Lighter.Application.Tests
{

    [Collection(nameof(SharedFixture))]
    public class QuestionServiceTests
    {
        private readonly SharedFixture _fixture;

        private readonly QuestionService _questionService;
        public QuestionServiceTests(SharedFixture fixture)
        {
            _fixture = fixture;
            _questionService = new QuestionService(_fixture.Client);
        }

        private async Task&amp;lt;Question&amp;gt; CreateOrGetOneQuestionWithNoAnswerAsync()
        {
            var collection = _fixture.Database.GetCollection&amp;lt;Question&amp;gt;(&quot;question&quot;);
            var filter = Builders&amp;lt;Question&amp;gt;.Filter.Size(q =&amp;gt; q.Answers, 0);
            var question = await collection.Find(filter).FirstOrDefaultAsync();

            if (question != null)
                return question;

            question = new Question { Title = &quot;问题一&quot; };
            return await _questionService.CreateAsync(question, CancellationToken.None);
        }

        private async Task&amp;lt;QuestionAnswerReponse&amp;gt; CreateOrGetOneQuestionWithAnswerAsync()
        {
            var collection = _fixture.Database.GetCollection&amp;lt;Question&amp;gt;(&quot;question&quot;);
            var filter = Builders&amp;lt;Question&amp;gt;.Filter.SizeGt(q =&amp;gt; q.Answers, 0);
            var question = await collection.Find(filter).FirstOrDefaultAsync();

            if (question != null)
                return await _questionService.GetWithAnswerAsync(question.Id, CancellationToken.None);

            // 不存在则创建一个没有回答的问题，再添加一个答案
            question = await CreateOrGetOneQuestionWithNoAnswerAsync();
            var answer = new AnswerRequest { Content = &quot;问题一的回答一&quot; };
            await _questionService.AnswerAsync(question.Id, answer, CancellationToken.None);

            return await _questionService.GetWithAnswerAsync(question.Id, CancellationToken.None);
        }


        [Fact]
        public async Task GetAsync_WrongId_ShoudReturnNull()
        {
            var result = await _questionService.GetAsync(&quot;empty&quot;, CancellationToken.None);
            result.Should().BeNull();
        }

        [Fact]
        public async Task CreateAsync_Right_ShouldBeOk()
        {
            var question = await CreateOrGetOneQuestionWithNoAnswerAsync();
            question.Should().NotBeNull();

            var result = await _questionService.GetAsync(question.Id, CancellationToken.None);
            question.Title.Should().Be(result.Title);
        }

        [Fact]
        public async Task AnswerAsync_Right_ShouldBeOk()
        {
            var question = await CreateOrGetOneQuestionWithNoAnswerAsync();
            question.Should().NotBeNull();

            var answer = new AnswerRequest { Content = &quot;问题一的回答一&quot; };
            await _questionService.AnswerAsync(question.Id, answer, CancellationToken.None);

            var questionWithAnswer = await _questionService.GetWithAnswerAsync(question.Id, CancellationToken.None);

            questionWithAnswer.Should().NotBeNull();
            questionWithAnswer.AnswerList.Should().NotBeEmpty();
            questionWithAnswer.AnswerList.First().Content.Should().Be(answer.Content);
        }

        [Fact]
        public async Task UpAsync_Right_ShouldBeOk()
        {
            var before = await CreateOrGetOneQuestionWithNoAnswerAsync();
            await _questionService.UpAsync(before.Id, CancellationToken.None);

            var after = await _questionService.GetAsync(before.Id, CancellationToken.None);
            after.Should().NotBeNull();
            after.VoteCount.Should().Be(before.VoteCount+1);
            after.VoteUps.Count.Should().Be(1);
        }

        [Fact]
        public async Task DownAsync_Right_ShouldBeOk()
        {
            var before = await CreateOrGetOneQuestionWithNoAnswerAsync();
            await _questionService.DownAsync(before.Id, CancellationToken.None);

            var after = await _questionService.GetAsync(before.Id, CancellationToken.None);
            after.Should().NotBeNull();
            after.VoteCount.Should().Be(before.VoteCount-1);
            after.VoteDowns.Count.Should().Be(1);
        }


        public async Task UpdateAsync_WithNoSummary_ShoudThrowException()
        {
            var before = await CreateOrGetOneQuestionWithNoAnswerAsync();
            var updateRequest = new QuestionUpdateRequest { Title = before.Title + &quot;-updated&quot; };
            await _questionService.UpdateAsync(before.Id, updateRequest, CancellationToken.None);

            var after = await _questionService.GetAsync(before.Id, CancellationToken.None);
            after.Should().NotBeNull();
            after.Title.Should().Be(updateRequest.Title);
        }


        [Fact]
        public async Task UpdateAsync_Right_ShoudBeOk()
        {
            var before = await CreateOrGetOneQuestionWithNoAnswerAsync();
            var updateRequest = new QuestionUpdateRequest { Title = before.Title + &quot;-updated&quot;, Summary =&quot;summary&quot; };
            await _questionService.UpdateAsync(before.Id, updateRequest , CancellationToken.None);

            var after = await _questionService.GetAsync(before.Id, CancellationToken.None);
            after.Should().NotBeNull();
            after.Title.Should().Be(updateRequest.Title);
        }


        [Fact]
        public async Task UpdateAsync_Right_CommentsShouldAppend()
        {
            var before = await CreateOrGetOneQuestionWithNoAnswerAsync();
            var updateRequest = new QuestionUpdateRequest { Title = before.Title + &quot;-updated&quot;, Summary = &quot;summary&quot; };
            await _questionService.UpdateAsync(before.Id, updateRequest, CancellationToken.None);

            var after = await _questionService.GetAsync(before.Id, CancellationToken.None);
            after.Comments.Should().NotBeEmpty();
            after.Comments.Count.Should().Be(before.Comments.Count+1);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行单元测试&quot;&gt;运行单元测试&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1412316/202101/1412316-20210107225749866-527092009.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;github源码链接：&quot;&gt;GitHub源码链接：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MINGSON666/Personal-Learning-Library/tree/main/ArchitectTrainingCamp&quot; target=&quot;_blank&quot;&gt;https://github.com/MINGSON666/Personal-Learning-Library/tree/main/ArchitectTrainingCamp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
&lt;p&gt;欢迎转载、使用、重新发布，但务必保留文章署名 郑子铭 （包含链接： &lt;a href=&quot;http://www.cnblogs.com/MingsonZheng/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/MingsonZheng/&lt;/a&gt; ），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。&lt;/p&gt;
&lt;p&gt;如有任何疑问，请与我联系 (MingsonZheng@outlook.com) 。&lt;/p&gt;
</description>
<pubDate>Thu, 07 Jan 2021 14:58:00 +0000</pubDate>
<dc:creator>MingsonZheng</dc:creator>
<og:description>2.5.8 MongoDB -- API重构 Lighter.Domain Lighter.Application.Contract Lighter.Application LighterApi Li</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MingsonZheng/p/14249227.html</dc:identifier>
</item>
<item>
<title>俯瞰Dubbo全局，阅读源码前必须掌握这些！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/14249186.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/14249186.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;在上一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg4MjU0OTM1OA==&amp;amp;mid=2247489794&amp;amp;idx=1&amp;amp;sn=aa9efb732ac7fe3d2bc927c1491cae57&amp;amp;chksm=cf55ae03f82227157bb69cb487df2081b5b623d173b1df603be66347692acec56d455da6aae1&amp;amp;token=959714600&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;冰河开始对Dubbo下手了！&lt;/a&gt;》一文中，我们重点介绍了为何要学习Dubbo，而且还是要深入理解Dubbo的原理和核心源码。既然是要写深度解析Dubbo源码的系列专题，我们首先要做的就是搭建一套Dubbo的源码环境，正所谓“工欲善其事，必先利其器”。但是，为了更好的理解Dubbo，我将本文重点分成三个部分：&lt;strong&gt;Dubbo中的核心角色、搭建Dubbo源码环境、Dubbo核心模块说明、运行Dubbo的示例程序&lt;/strong&gt; 四个部分。说干就干，上重点。&lt;/p&gt;
&lt;p&gt;注：本系列专题，我是基于Dubbo 2.7.8版本进行源码分析的。&lt;/p&gt;
&lt;p&gt;文章已收录到：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sunshinelyz/technology-binghe&quot; target=&quot;_blank&quot;&gt;https://github.com/sunshinelyz/technology-binghe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/binghe001/technology-binghe&quot; target=&quot;_blank&quot;&gt;https://gitee.com/binghe001/technology-binghe&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;dubbo中的核心角色&quot;&gt;Dubbo中的核心角色&lt;/h2&gt;
&lt;p&gt;为了更好的说明Dubbo中的核心角色，这里，我就直接引用一张Dubbo的依赖关系图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000341681.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：图片来自Dubbo官网。&lt;/p&gt;
&lt;p&gt;从Dubbo的依赖关系图中，我们可以看出，Dubbo主要由四部分构成：&lt;strong&gt;Registry、Provider、Consumer和Monitor&lt;/strong&gt; 。接下来，我们就分别对这四部分进行简单的介绍。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Registry，注册中心&lt;/strong&gt;。在Dubbo中，注册中心负责服务的注册与发现，主要就是针对服务地址的注册与查找。值得一提的是，在Dubbo中，Provider和Consumer只有在服务启动的时候与注册中心进行交互。之后，注册中心通过长连接的形式来感知Provider的存在，如果Provider宕机或不可用，注册中心就会立即推送相关的事件来告知Consumer。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Provider，服务的提供者&lt;/strong&gt;。Provider在启动的时候，会向注册中心注册自己的相关服务，主要是通过将自身的服务地址和相关的配置信息封装成URL添加到Zookeeper等服务中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consumer，服务的消费者&lt;/strong&gt;。Consumer在启动的时候，会向注册中心订阅其关注的服务。主要是向Zookeeper等服务中获取Provider注册的URL，并且在Zookeeper等服务中添加相应的监听器。获取到Provider注册的URL之后，Consumer就会通过负载均衡算法从获取的多个Provider中选择一个，并与其建立连接，发起RPC调用。如果Zookeeper等服务中注册的Provider发生了变更，Consumer就会通过在注册中心中添加的监听器来获取最新的Provider信息。而且Consumer会缓存Provider的信息，如果Consumer与Provider一旦建立起连接，即使注册中心宕机或不可用，也不会影响Consumer和Provider之间的交互。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Monitor：监控中心&lt;/strong&gt;。主要用来统计Dubbo服务的调用次数和调用的时间。在Dubbo的核心架构中，监控中心不是必需的，监控中心宕机或不可用不会影响Dubbo的整体服务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了，对于Dubbo的核心角色我们就介绍到这儿，更多的信息，小伙伴们可以参见Dubbo的官方文档。&lt;/p&gt;
&lt;h2 id=&quot;搭建dubbo源码环境&quot;&gt;搭建Dubbo源码环境&lt;/h2&gt;
&lt;p&gt;我们可以使用如下命令将github的源码下载的本地。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;git clone https://github.com/apache/dubbo.git
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，将Dubbo的源码切换到2.7.8&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;git checkout -b dubbo-2.7.8 dubbo-2.7.8
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Maven进行编译&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mvn clean install -Dmaven.test.skip=true 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换成IDEA项目，这里我使用的是IDEA分析Dubbo源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mvn idea:idea
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们就可以将Dubbo源码导入到IDEA了。&lt;/p&gt;
&lt;p&gt;说了这么多，其中还有一种方式就是通过浏览器直接下载Dubbo 2.7.8的源码到本地。&lt;/p&gt;
&lt;p&gt;在浏览器中打开链接：&lt;a href=&quot;https://github.com/apache/dubbo/releases/tag/dubbo-2.7.8&quot; target=&quot;_blank&quot;&gt;https://github.com/apache/dubbo/releases/tag/dubbo-2.7.8&lt;/a&gt; 下载Dubbo源码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000405979.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里下载zip压缩包和tar.gz压缩包均可，下载到本地后解压，将其导入到IDEA中即可。&lt;/p&gt;
&lt;p&gt;导入完成后，我们看到的项目结构如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000416460.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们就对Dubbo源码中的核心模块进行简单的介绍。&lt;/p&gt;
&lt;h2 id=&quot;dubbo核心模块说明&quot;&gt;Dubbo核心模块说明&lt;/h2&gt;
&lt;h3 id=&quot;dubbo-common模块&quot;&gt;dubbo-common模块&lt;/h3&gt;
&lt;p&gt;Dubbo的公共模块，提供了Dubbo SPI的实现、时间轮的实现、动态编译等通用的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021010600043335.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dubbo-remoting模块&quot;&gt;dubbo-remoting模块&lt;/h3&gt;
&lt;p&gt;Dubbo的远程通信模块，其中，dubbo-remoting-api是对整个模块的核心抽象，其他子模块基于其他开源框架对dubbo-remoting-api进行实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000444721.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dubbo-rpc模块&quot;&gt;dubbo-rpc模块&lt;/h3&gt;
&lt;p&gt;Dubbo的RPC模块，依赖dubbo-remoting模块。其中，dubbo-remoting-api是整个dubbo-rpc模块的核心抽象，其他模块是对dubbo-remoting-api的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000454829.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dubbo-registry模块&quot;&gt;dubbo-registry模块&lt;/h3&gt;
&lt;p&gt;Dubbo中与注册中心交互的模块。其中dubbo-registry-api是整个dubbo-registry的核心抽象，其他模块是对dubbo-registry-api的具体实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000504899.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dubbo-config模块&quot;&gt;dubbo-config模块&lt;/h3&gt;
&lt;p&gt;Dubbo中解析对外暴露的配置的模块。其中，dubbo-config-api 子模块负责处理以API 方式使用Dubbo时的相关配置，dubbo-config-spring 子模块负责处理与 Spring 集成使用时的相关配置方式。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000518227.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dubbo-metadata模块&quot;&gt;dubbo-metadata模块&lt;/h3&gt;
&lt;p&gt;Dubbo中的元数据模块。其中，dubbo-metadata-api是对整个dubbo-metadata的抽象，其他模块是对dubbo-metadata-api的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000529756.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dubbo-configcenter模块&quot;&gt;dubbo-configcenter模块&lt;/h3&gt;
&lt;p&gt;Dubbo的配置中心模块，其中，提供了多种服务发现的方式并接入了多种服务发现组件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000541797.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dubbo-monitor模块&quot;&gt;dubbo-monitor模块&lt;/h3&gt;
&lt;p&gt;Dubbo 的监控模块，主要用于统计服务调用次数、调用时间以及实现调用链跟踪的服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000556834.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;dubbo-cluster模块&quot;&gt;dubbo-cluster模块&lt;/h3&gt;
&lt;p&gt;Dubbo的集群管理模块，主要提供负载均衡、容错、路由等功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000608556.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;运行dubbo示例程序&quot;&gt;运行Dubbo示例程序&lt;/h2&gt;
&lt;p&gt;在Dubbo源码中，有一个示例程序模块dubbo-demo，在运行dubbo-demo模块中的示例前，我们先在本地启动一个Zookeeper作为注册中心。&lt;/p&gt;
&lt;p&gt;注：小伙伴们可以自行到Apache官网下载Zookeeper。&lt;/p&gt;
&lt;h3 id=&quot;dubbo示例程序结构&quot;&gt;Dubbo示例程序结构&lt;/h3&gt;
&lt;p&gt;Dubbo提供的示例程序的总体结构如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000645262.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来看看dubbo-demo下有哪些模块。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;dubbo-demo-interface：Dubbo示例定义的业务接口。&lt;/li&gt;
&lt;li&gt;dubbo-demo-xml：提供了基于Spring XML的使用示例。&lt;/li&gt;
&lt;li&gt;dubbo-demo-annotation：提供了基于Spring注解方式的使用示例。&lt;/li&gt;
&lt;li&gt;dubbo-demo-api：提供了以API方式使用Dubbo的示例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，dubbo-demo-xml、dubbo-demo-annotation和dubbo-demo-api模块都是依赖dubbo-demo-interface模块的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下来，我们就对dubbo-demo-interface模块和dubbo-demo-annotation模块的核心代码进行简单的介绍，并运行相关的示例程序。小伙伴们可自行分析和运行dubbo-demo-xml和dubbo-demo-api中的示例程序并运行相关的代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）dubbo-demo-interface：定义了业务接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000703176.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，DemoService接口的核心代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.apache.dubbo.demo;
import java.util.concurrent.CompletableFuture;
public interface DemoService {
    //同步调用
    String sayHello(String name);
    //异步调用
    default CompletableFuture&amp;lt;String&amp;gt; sayHelloAsync(String name) {
        return CompletableFuture.completedFuture(sayHello(name));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）dubbo-demo-annotation：提供了基于Spring注解的示例程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Provider代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先来看dubbo-demo-annotation-provider模块，也就是服务的提供者。其DemoServiceImpl的代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@DubboService
public class DemoServiceImpl implements DemoService {
    private static final Logger logger = LoggerFactory.getLogger(DemoServiceImpl.class);

    @Override
    public String sayHello(String name) {
        logger.info(&quot;Hello &quot; + name + &quot;, request from consumer: &quot; + RpcContext.getContext().getRemoteAddress());
        return &quot;Hello &quot; + name + &quot;, response from provider: &quot; + RpcContext.getContext().getLocalAddress();
    }

    @Override
    public CompletableFuture&amp;lt;String&amp;gt; sayHelloAsync(String name) {
        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Application类的代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Application {
    public static void main(String[] args) throws Exception {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ProviderConfiguration.class);
        context.start();
        System.in.read();
    }

    @Configuration
    @EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.demo.provider&quot;)
    @PropertySource(&quot;classpath:/spring/dubbo-provider.properties&quot;)
    static class ProviderConfiguration {
        @Bean
        public RegistryConfig registryConfig() {
            RegistryConfig registryConfig = new RegistryConfig();
            registryConfig.setAddress(&quot;zookeeper://127.0.0.1:2181&quot;);
            return registryConfig;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Consumer代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们来看看dubbo-demo-annotation-consumer模块的代码，也就是服务消费者的示例代码。其中，DemoServiceComponent类的代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component(&quot;demoServiceComponent&quot;)
public class DemoServiceComponent implements DemoService {
    @DubboReference
    private DemoService demoService;

    @Override
    public String sayHello(String name) {
        return demoService.sayHello(name);
    }
    @Override
    public CompletableFuture&amp;lt;String&amp;gt; sayHelloAsync(String name) {
        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Application类的代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Application {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConsumerConfiguration.class);
        context.start();
        DemoService service = context.getBean(&quot;demoServiceComponent&quot;, DemoServiceComponent.class);
        String hello = service.sayHello(&quot;world&quot;);
        System.out.println(&quot;result :&quot; + hello);
    }

    @Configuration
    @EnableDubbo(scanBasePackages = &quot;org.apache.dubbo.demo.consumer.comp&quot;)
    @PropertySource(&quot;classpath:/spring/dubbo-consumer.properties&quot;)
    @ComponentScan(value = {&quot;org.apache.dubbo.demo.consumer.comp&quot;})
    static class ConsumerConfiguration {

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行dubbo示例程序-1&quot;&gt;运行Dubbo示例程序&lt;/h3&gt;
&lt;p&gt;我们先在本地启动Zookeeper，然后分别运行dubbo-demo-annotation-provider模块的Application类和dubbo-demo-annotation-consumer模块的Application类。&lt;/p&gt;
&lt;p&gt;此时在IDEA的控制台会输出如下信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;result :Hello world, response from provider: 192.168.0.5:20880
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210106000719302.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;dubbo总结&quot;&gt;Dubbo总结&lt;/h2&gt;
&lt;p&gt;到这里，我们介绍了Dubbo中的核心角色，如何搭建Dubbo源码环境，对Dubbo源码中的核心模块进行了简单的说明，并简单的分析了Dubbo的示例程序并运行了示例程序。其中，在介绍和运行示例程序时，我们重点介绍了dubbo-demo-annotation示例模块，小伙伴们可自行分析和运行其他示例模块。在后续的文章中分析源码时，我们也主要是通过debug Dubbo的示例程序的方式进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好了，今天就到这儿吧，我是冰河，大家有啥问题可以在下方留言，也可以加我微信：sun_shine_lyz，一起交流技术，一起进阶，一起牛逼~~&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Jan 2021 14:49:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 在上一篇《冰河开始对Dubbo下手了！》一文中，我们重点介绍了为何要学习Dubbo，而且还是要深入理解Dubbo的原理和核心源码。既然是要写深度解析Dubbo源码的系列专题，我们首先要做的就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/14249186.html</dc:identifier>
</item>
<item>
<title>《深入理解Java虚拟机》  Java对象的生命周期 - 一只喜鹊</title>
<link>http://www.cnblogs.com/chenscript/p/14166160.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenscript/p/14166160.html</guid>
<description>&lt;p&gt;初始化什么时候被触发？    类 主动使用到的时候&lt;/p&gt;
&lt;p&gt;              1 创建类的实例，也就是new&lt;/p&gt;
&lt;p&gt;              2 访问某个类或者接口的静态变量，给该静态变量赋值&lt;/p&gt;
&lt;p&gt;              3 调用类的静态方法&lt;/p&gt;
&lt;p&gt;              4.反射 （class.forname(&quot;...&quot;))&lt;/p&gt;
&lt;p&gt;              5.初始化某个类的子类，则其父类也会被初始化&lt;/p&gt;
&lt;p&gt;              6.java 虚拟机启动时被标明为启动类的类（如springboot启动类）&lt;/p&gt;
</description>
<pubDate>Thu, 07 Jan 2021 14:31:00 +0000</pubDate>
<dc:creator>一只喜鹊</dc:creator>
<og:description>Java虚拟机运行时数据区 方法区:存储 类信息、常量、静态变量、即使编译器编译后的代码等数据，也有别名叫做非堆。 方法区其中有包含有 运行时常量池，用于存放编译期生成的各种字面量和符号引用。其中，可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenscript/p/14166160.html</dc:identifier>
</item>
<item>
<title>编写 Dockerfile 生成自定义镜像  - Cocowool</title>
<link>http://www.cnblogs.com/cocowool/p/make-your-own-image.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cocowool/p/make-your-own-image.html</guid>
<description>&lt;p&gt;一般情况下我们可以从公共渠道诸如 &lt;a href=&quot;https://hub.docker.com&quot; target=&quot;_blank&quot;&gt;DockerHub&lt;/a&gt; 获取镜像上获取镜像，但是在实际生产过程中，往往需要定制化的镜像，例如修改一些配置文件，增加一些特殊的命令或软件等需求，这时就需要通过编写 Dockerfile 来生成自定义的镜像文件。&lt;/p&gt;
&lt;h2 id=&quot;dockerfile介绍&quot;&gt;Dockerfile介绍&lt;/h2&gt;
&lt;p&gt;Dockerfile 是一个文本格式的配置文件，通过编写 Dockerfile 脚本来定义自己需要的镜像。Dockerfile 文件由一行行命令语句组成，文件中的注释信息以 # 开头。编辑好 Dcokerfile 文件之后，我们可以通过 &lt;code&gt;docker build -t .&lt;/code&gt; 命令生成自己定义的镜像文件。&lt;/p&gt;
&lt;h2 id=&quot;dockerfile基本结构&quot;&gt;Dockerfile基本结构&lt;/h2&gt;
&lt;p&gt;我们看一下 &lt;a href=&quot;https://github.com/alpinelinux/docker-alpine/blob/f3d17bcb7b1fa51cf9b011403cd58e00fbbcd000/x86_64/Dockerfile&quot; target=&quot;_blank&quot;&gt;alpine&lt;/a&gt; 的 Dockerfile 文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;FROM scratch
ADD alpine-minirootfs-20201218-x86_64.tar.gz /
CMD [&quot;/bin/sh&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Dockerfile 文件主要由三部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FROM 属于配置指令部分，表明基于的镜像名称。&lt;code&gt;scratch&lt;/code&gt; 指从空白开始。&lt;/li&gt;
&lt;li&gt;ADD 属于操作指令部分，表示向镜像内加入内容。&lt;/li&gt;
&lt;li&gt;CMD 也属于操作指令部分，一般做为最后一行，表示运行容器时的操作命令。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;指令说明&quot;&gt;指令说明&lt;/h2&gt;
&lt;p&gt;Dockerfile 中指令的一般格式为 &lt;code&gt;INSTRUCTION arguments&lt;/code&gt; ，指令分两种 配置指令 和 操作指令，具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置指令
&lt;ul&gt;&lt;li&gt;ARG : 定义创建镜像过程中使用的变量，格式为 &lt;code&gt;ARG &amp;lt;name&amp;gt;[=&amp;lt;default value&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;FROM : 指定所创建镜像的基础镜像。格式为 &lt;code&gt;FROM &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LABEL : 为生成的镜像添加元数据标签信息，辅助过滤特定镜像。格式为 &lt;code&gt;LABEL &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;EXPOSE : 声明镜像内服务监听的端口。格式为 &lt;code&gt;EXPOSE &amp;lt;port&amp;gt;[/&amp;lt;protocol&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ENV : 指定环境变量，该变量在容器中存在，也可在容器启动时覆盖。格式为 &lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ENTRYPOINT : 指定镜像的默认入口命令，做为容器启动时的根命令执行。格式为 &lt;code&gt;ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt; 或者 &lt;code&gt;ENTRYPOINT command param1 param2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;VOLUME : 创建一个数据卷挂载点。格式为 &lt;code&gt;VOLUME [&quot;/data&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;USER : 指定容器运行时的用户名或UID，后续的RUN指令也使用该用户身份。格式为 &lt;code&gt;USER daemon&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;WORKDIR : 配置RUN\CMD\ENTRYPOINT等指令的工作目录，推荐使用绝对路径。格式为：&lt;code&gt;WORKDIR /path/to/workdir&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ONBUILD : 指定当基于所生成镜像创建子镜像时，自动执行的操作指令。&lt;/li&gt;
&lt;li&gt;STOPSIGNAL : 指定容器接收退出的信号值。格式为: &lt;code&gt;STOPSIGNAL signal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;HEALTHCHECK : 配置容器健康检查命令，自 Docker 1.12 开始支持。格式为: &lt;code&gt;HEALTHCHECK [OPTIONS] CMD command&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;SHELL : 指定默认的shell类型。格式为: &lt;code&gt;SHELL [&quot;executable&quot;, &quot;parameters&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;操作指令
&lt;ul&gt;&lt;li&gt;RUN : 运行指定命令。格式为: &lt;code&gt;RUN &amp;lt;command&amp;gt;&lt;/code&gt; 或 &lt;code&gt;RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt; 当命令较长时，可以用 \ 来换行。&lt;/li&gt;
&lt;li&gt;CMD : 指定容器启动时默认执行的命令，每个Dockerfile只能有一条CMD命令。格式有三种，分别为：&lt;code&gt;CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt; 或 &lt;code&gt;CMD command param1 param2&lt;/code&gt; 或 &lt;code&gt;CMD [&quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ADD : 添加内容到镜像中，将SRC内容复制到DEST中。格式为: &lt;code&gt;ADD &amp;lt;src&amp;gt; &amp;lt;dest&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;COPY : 复制内容到镜像中。格式为 : &lt;code&gt;COPY &amp;lt;src&amp;gt; &amp;lt;dest&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;创建镜像&quot;&gt;创建镜像&lt;/h2&gt;
&lt;p&gt;创建镜像的命令格式为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ docker build [OPTIONS] PATH | URL | -
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;docker build 命令读取指定路径下的 Dockerfile 文件，并将该路径下的所有数据作为上下文发送给 Docker 服务端。服务端完成 Dockerfile 格式校验后，按顺序执行指令命令，遇到ADD、COPY和RUN指令会生成新一层的镜像文件。镜像创建成功后，返回镜像ID。&lt;/p&gt;
&lt;p&gt;docker build 还有很多选项，最常用的是通过 &lt;code&gt;-t&lt;/code&gt; 增加标签。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ docker build -t test:0.1 .
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 Dockerfile 所在的文件夹文件过多时，为避免向服务端上传上下文过大，可以通过 .dockerignore 文件来让 Docker 忽略无关的文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ cat .dockerignore
*xls
*docx
README.md
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实战案例&quot;&gt;实战案例&lt;/h2&gt;
&lt;p&gt;总的来说，通过编写 Dockerfile 生成自定义镜像的过程不复杂，但是能生成高效的镜像还需要不断的尝试和联系，一般来说用于生产的镜像都尽量保证用途单一，减少镜像的层数，选择合适的基础镜像减小镜像文件大小，形成自己的版本号和标签管理规则，这样能提高自己生成镜像的质量。&lt;/p&gt;
&lt;p&gt;下面就以一个简单定义 python 基础镜像的例子，基础的 python 镜像缺少很多包例如爬虫常用的 requests ，自己定义一个包含 requests 包的镜像，编写的 Dockerfile 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dockerfile&quot;&gt;FROM python:3.6

RUN pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple requests  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行镜像的创建命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ docker build -t python-requests-3.6:0.1 .
$ docker images
REPOSITORY                                      TAG                 IMAGE ID            CREATED             SIZE
python-requests-3.6                             0.1                 3c2bb72b2066        2 minutes ago       884MB
python                                          3.6                 85146760634c        7 weeks ago         874MB
$ docker run --rm -it -v &quot;$PWD&quot;:/usr/src -w /usr/src python-requests-3.6:0.1 python3
Python 3.6.12 (default, Nov 18 2020, 14:46:32) 
[GCC 8.3.0] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import requests
&amp;gt;&amp;gt;&amp;gt; response = requests.get(&quot;http://baidu.com&quot;)
&amp;gt;&amp;gt;&amp;gt; print(response.text)
&amp;lt;html&amp;gt;
&amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到镜像内的 python 环境已经支持 requests 包了。利用这种方式，我们不用在本地维护开发环境，特别是多个版本的开发环境，通过 Docker 生成不同版本的镜像能够快速的实现多版本的开发环境，大家可以参考 &lt;a href=&quot;http://edulinks.cn/2020/11/12/20201111-build-java-devlopment-env-with-docker/&quot; target=&quot;_blank&quot;&gt;利用 Docker 构建一个简单的 java 开发编译环境&lt;/a&gt; 。自己定义的各种镜像，可以上传到 DockerHub，更换电脑后仅需要安装 Docker，之前的各种开发环境就回来了。&lt;/p&gt;
&lt;p&gt;对于 Docker 有进一步兴趣的，可以参考我的其他文章：&lt;/p&gt;
&lt;p&gt;最后说点杂事，2021年刚开始没几天，年前立下的雄心壮志马上被各种无计划的事打乱了，感觉总是被打断，感觉总是时间不够用，原来以为是自己能力不够用，最近在云+社区上读了一个时间管理系列文章，才发现原来是自己坚持不够，给了自己点信心，2021刚开始还要继续加油才是，附上这个系列文章的链接，感兴趣的朋友可以读一读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/39469/202101/39469-20210107222052637-1277557094.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Jan 2021 14:21:00 +0000</pubDate>
<dc:creator>Cocowool</dc:creator>
<og:description>一般情况下我们可以从公共渠道诸如 DockerHub 获取镜像上获取镜像，但是在实际生产过程中，往往需要定制化的镜像，例如修改一些配置文件，增加一些特殊的命令或软件等需求，这时就需要通过编写 Dock</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cocowool/p/make-your-own-image.html</dc:identifier>
</item>
</channel>
</rss>