<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Linux中的System V信号量 - Ephemerally</title>
<link>http://www.cnblogs.com/ephemerally/p/14199863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ephemerally/p/14199863.html</guid>
<description>&lt;p&gt;在进程同步，并发运行时，保证按序地访问共享资源是十分重要的。因此引入了临界区的概念，一次只能有一个线程进入临界区完成他的指令。而信号量(semaphore)的作用，类似于一个交通信号灯，它负责进程协作，因此信号量又称为信号灯。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;99.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在进程同步，并发运行时，保证按序地访问共享资源是十分重要的。因此引入了临界区的概念，一次只能有一个线程进入临界区完成他的指令。而信号量(semaphore)的作用，类似于一个交通信号灯，它负责进程协作，因此信号量又称为信号灯。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Linux系统中，它提供两种信号量：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;内核信号量&lt;/strong&gt;，由内核控制路径使用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;用户态进程使用的信号量&lt;/strong&gt;，这种信号量有两种接口，&lt;code&gt;POSIX&lt;/code&gt;信号量和&lt;code&gt;SYSTEM V&lt;/code&gt;信号量。&lt;/p&gt;
&lt;p&gt;信号量的本质是一个计数器。一个较为常见的用法，是为每个资源都会分配一个信号量。记信号量为S，除了初始化之外，有两个标准原子操作：&lt;code&gt;wait()&lt;/code&gt;和&lt;code&gt;signal()&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;system-v信号量接口&quot;&gt;System V信号量接口&lt;/h2&gt;
&lt;ul readability=&quot;21&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;semget&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个新信号量或取得一个已有信号量&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int semget(key_t key, int num_sems, int sem_flags);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;key&lt;/code&gt;是一个整数值（唯一非零），可以理解成是信号量的标识符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;num_sems&lt;/code&gt;指定了需要的信号量数目，通常为1。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sem_flags&lt;/code&gt;是一组标志，当创建一个新的信号量时，设定权限与值&lt;code&gt;IPC_CREAT&lt;/code&gt;做按位或操作。设置了&lt;code&gt;IPC_CREAT&lt;/code&gt;标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而&lt;code&gt;IPC_CREAT | IPC_EXCL&lt;/code&gt;则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。&lt;/p&gt;
&lt;p&gt;函数成功返回一个相应信号标识符（非零），失败返回&lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;semctl&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接控制信号量信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int semctl(int sem_id, int sem_num, int command, ...);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个参数是操作信号在信号集中的编号，第一个信号的编号是&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第三个参数&lt;code&gt;command&lt;/code&gt;通常是下面两个值中的其中一个：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SETVAL&lt;/code&gt;：用来把信号量初始化为一个已知的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IPC_RMID&lt;/code&gt;：用于删除一个已经无需继续使用的信号量标识符。&lt;/p&gt;
&lt;p&gt;如果有第四个参数，它通常是一个&lt;code&gt;union semum&lt;/code&gt;结构，定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;union semun
{
    int val;
    struct semid_ds *buf;
    unsigned short *arry;
};
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;semop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;改变信号量的值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int semop(int sem_id, struct sembuf *sem_opa, size_t num_sem_ops);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sem_id&lt;/code&gt;是由&lt;code&gt;semget&lt;/code&gt;返回的信号量标识符，&lt;code&gt;sembuf&lt;/code&gt;结构的定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct sembuf{
    short sem_num;//除非使用一组信号量，否则为0
    short sem_op;//信号量在一次操作中需要改变的数据，-1即P（等待）操作，+1即V（发送信号）操作。
    short sem_flg;//通常为SEM_UNDO,使操作系统跟踪信号，并在进程没有释放该信号量而终止时，操作系统释放信号量
};
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;进程同步实例&quot;&gt;进程同步实例&lt;/h2&gt;
&lt;h5 id=&quot;无信号量实例&quot;&gt;无信号量实例&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
 
int main()
{
        pid_t pid;
        pid = fork();
        srand(pid); 
        if(pid &amp;gt; 0) // parent process
        {
                char a = 'A'; // char to print
                for(int i = 0; i &amp;lt; 10; ++i)
                {
                        printf(&quot;%c&quot;, a);
                        fflush(stdout); // flush stdout buffer
                        sleep(1);

                        printf(&quot;%c&quot;, a);
                        fflush(stdout); 
                        sleep(1);
                }
        }
        else // child process
        {
                char b = 'B'; 
                for(int i = 0; i &amp;lt; 10; ++i)
                {
                        printf(&quot;%c&quot;, b);
                        fflush(stdout); 
                        sleep(1);

                        printf(&quot;%c&quot;, b);
                        fflush(stdout); 
                        sleep(1);
                }
        }
        printf(&quot;\n%d - finished\n&quot;, getpid());
        sleep(3);
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1897130/202012/1897130-20201228082302994-1255375557.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;有信号量实例&quot;&gt;有信号量实例&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/ipc.h&amp;gt;
#include &amp;lt;sys/sem.h&amp;gt;

#define SEMKEY 0x00002222 // set a key for semaphore

union semun // union for semaphore
{
        int val;
        struct semid_ds *buf;
        unsigned short  *array;
};

struct sembuf p = { 0, -1, SEM_UNDO};
struct sembuf v = { 0, +1, SEM_UNDO};

int main()
{
        int sem_id = semget(SEMKEY, 1, 0666 | IPC_CREAT); // get semaphore  
        
        union semun sem_union;
        sem_union.val = 1;
        if(semctl(sem_id, 0, SETVAL, sem_union) &amp;lt; 0)
        {
                perror(&quot;semctl error&quot;);
                return -1;
        }
        int pid;
        pid = fork();
        srand(pid); 
        if(pid &amp;gt; 0) // parent process
        {
                char a = 'A'; // char to print
                for(int i = 0; i &amp;lt; 10; ++i)
                {
                        if(semop(sem_id, &amp;amp;p, 1) &amp;lt; 0) // P operation
                        {
                                perror(&quot;semop p error&quot;);
                                return -1;
                        }
                        printf(&quot;%c&quot;, a);
                        fflush(stdout); // flush stdout buffer
                        sleep(1);

                        printf(&quot;%c&quot;, a);
                        fflush(stdout); 
                        if(semop(sem_id, &amp;amp;v, 1) &amp;lt; 0) // V operation
                        {
                                perror(&quot;semop v error&quot;);
                                return -1;
                        }
                        sleep(1);
                }
        }
        else // child process
        {
                char b = 'B'; // char to print
                for(int i = 0; i &amp;lt; 10; ++i)
                {
                        if(semop(sem_id, &amp;amp;p, 1) &amp;lt; 0) // P operation
                        {
                                perror(&quot;semop p error&quot;);
                                return -1;
                        }
                        printf(&quot;%c&quot;, b);
                        fflush(stdout); // flush stdout buffer
                        sleep(1);

                        printf(&quot;%c&quot;, b);
                        fflush(stdout); 
                        if(semop(sem_id, &amp;amp;v, 1) &amp;lt; 0) // V operation
                        {
                                perror(&quot;semop v error&quot;);
                                return -1;
                        }
                        sleep(1);
                }
        }
        printf(&quot;\n%d - finished\n&quot;, getpid());
        sleep(3);
        if (pid &amp;gt; 0)
        {
                system(&quot;ipcrm -S 0x00002222&quot;);
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1897130/202012/1897130-20201228082319831-1707094879.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为设定信号量的关系，一个线程在临界区内一定会执行两次&lt;code&gt;print()&lt;/code&gt;操作，所以A或B一定成对出现。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 28 Dec 2020 00:23:00 +0000</pubDate>
<dc:creator>Ephemerally</dc:creator>
<og:description>在进程同步，并发运行时，保证按序地访问共享资源是十分重要的。因此引入了临界区的概念，一次只能有一个线程进入临界区完成他的指令。而信号量(semaphore)的作用，类似于一个交通信号灯，它负责进程协作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ephemerally/p/14199863.html</dc:identifier>
</item>
<item>
<title>在.NET Core 中收集数据的几种方式 - SpringLeee</title>
<link>http://www.cnblogs.com/myshowtime/p/14199844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myshowtime/p/14199844.html</guid>
<description>&lt;p&gt;APM是一种应用性能监控工具，可以帮助理解系统行为, 用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题, 通过汇聚业务系统各处理环节的实时数据，分析业务系统各事务处理的交易路径和处理时间，实现对应用的全链路性能监测。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://i.loli.net/2020/12/25/WQHE4nAlZNUftaC.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://i.loli.net/2020/12/25/WQHE4nAlZNUftaC.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;组成结构&quot;&gt;组成结构&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;探针(Agent)：负责在客户端程序运行时搜索服务调用链路信息，发送给收集器&lt;/li&gt;
&lt;li&gt;收集器(Collector)：负责将数据格式化，保存到存储器&lt;/li&gt;
&lt;li&gt;存储器(Storage)：保存程序数据&lt;/li&gt;
&lt;li&gt;UI界面(Dashboard)：多维度展示数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文会主要针对 探针 （Agent)， 分享下在.NET 程序中收集程序数据的几种方式，如果需要自研 APM 系统或者收集数据来进行系统分析，希望能可以给大家一些帮助，以下几种方式，大家可以针对自己的场景去选择，我们的目的只是收集数据。&lt;/p&gt;
&lt;h3 id=&quot;手动埋点&quot;&gt;手动埋点&lt;/h3&gt;
&lt;p&gt;手动埋点比较简单，我们需要在一些操作前后可以手动包裹我们的埋点代码，比如 Http，RPC，DB, MQ 等调用，非常灵活，可以在任意的地方添加我们的埋点信息，然后汇总数据，按批发送，缺点是对程序的侵入性较高，不太优雅。&lt;/p&gt;
&lt;h3 id=&quot;middleware-中间件--过滤器-filter&quot;&gt;Middleware 中间件 &amp;amp; 过滤器 Filter&lt;/h3&gt;
&lt;p&gt;得益于 .NET Core 优秀的框架设计, 它具有一个极具扩展性的请求处理管道，我们可以通过这个管道的定制来满足各种场景下的HTTP处理需求。ASP. NET Core应用的很多特性，比如路由、认证、会话、缓存等，也同时定制消息处理管道来实现的，所以我们需要编写自定义的拦截中间件 InterceptMiddleware，获取到请求上下文 HttpContext, 来拦截所有的Http请求收集数据，注意这里中间件的位置要放到 UseEndpoints() 的上面，同样可以借助 过滤器 AcitonFilter，来完成同样的效果, 但是这种方式可获取的信息有限，只能拦截到 Http 请求的一些信息&lt;/p&gt;
&lt;h3 id=&quot;diagnosticsource&quot;&gt;DiagnosticSource&lt;/h3&gt;
&lt;p&gt;实现：&lt;br/&gt;SkyApm-dotnet &lt;a href=&quot;https://github.com/SkyAPM/SkyAPM-dotnet&quot; title=&quot;https://github.com/SkyAPM/SkyAPM-dotnet&quot; target=&quot;_blank&quot;&gt;https://github.com/SkyAPM/SkyAPM-dotnet&lt;/a&gt;&lt;br/&gt;HttpReports APM &lt;a href=&quot;https://github.com/dotnetcore/HttpReports&quot; title=&quot;https://github.com/dotnetcore/HttpReports&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnetcore/HttpReports&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;诊断 DiagnosticSource 我们不经常用，可能都有点陌生，但是它的功能是非常强大的，它本身是一个基于发布订阅模式的工作模式，我们可以异步的去收集信息，比如 中间件的进入和退出，HttpClient 调用的开始和结束，并且有很多第三方的库都支持了 DiagnosticSource,这也是微软目前推荐的方式，在改动极少代码的情况下，采集到丰富的运行数据。&lt;/p&gt;
&lt;h3 id=&quot;引用-aop&quot;&gt;引用 AOP&lt;/h3&gt;
&lt;p&gt;额，面向切面编程，这个需要在我们的 .NET 程序中引用 AOP 框架，如果是内部系统的话，我觉的还是可以接受的，常见的框架 AspectCore, Castle.Core, 通过 AOP 的特性，我们可以拦截需要获取数据的方法，如果你在项目中，普遍使用依赖注入的话，可以达到方法级别的监控，获取到的信息非常可观，另外需要注意的是，获取的信息越详细，数据量也越大，是全量采集数据还是抽样采集也是要考虑的点&lt;/p&gt;
&lt;h3 id=&quot;etwevent-tracing-for-windows&quot;&gt;ETW(Event Tracing for Windows)&lt;/h3&gt;
&lt;p&gt;ETW是Event Tracing for Windows的简称，它是Windows提供的原生的事件跟踪日志系统。由于采用内核（Kernel）层面的缓冲和日志记录机制，所以ETW提供了一种非常高效的事件跟踪日志解决方案。&lt;br/&gt;这个库我还没怎么用过，生而为人，我很抱歉 〒▽〒&lt;/p&gt;
&lt;h3 id=&quot;monocecil&quot;&gt;Mono.Cecil&lt;/h3&gt;
&lt;p&gt;Mono.Cecil：一个可加载并浏览现有程序集并进行动态修改并保存的.NET框架， Mono Cecil十分强大，可以静态注入程序集（注入后生成新的dll程序集）和动态注入程序集（注入后不改变目标程序集，只在运行时改变程序集行为，腾讯开源的Unity热更解决方案xLua有一个非常吸引人的特性就是Hotfix，其原理是使用Mono.Cecil库对进行C#层编译出来的dll程序集进行IL代码注入。&lt;/p&gt;
&lt;h3 id=&quot;clr-profiling-api&quot;&gt;CLR Profiling API&lt;/h3&gt;
&lt;p&gt;实现&lt;br/&gt;听云APM（商业）OneAPM （商业）Datadog （商业）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/yirutang/clr-profiling-api&quot; title=&quot;https://docs.microsoft.com/en-us/archive/blogs/yirutang/clr-profiling-api&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/archive/blogs/yirutang/clr-profiling-api&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个真的是一个很棒的方案，你可以看到，很多的 商业APM 系统，都采用了这种方式，因为它是一种无侵入的收集方式，CLR Profiling (分析) API 是CLR中最酷的东西之一， 分析 API 提供 CLR 中发生的各种事件和操作的相关信息， 你可以使用此信息来监视进程的内部工作情况，也可分析 .NET 应用程序的性能&lt;/p&gt;
&lt;p&gt;支持的功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CLR 启动和关闭事件。&lt;/li&gt;
&lt;li&gt;应用程序域创建和关闭事件。&lt;/li&gt;
&lt;li&gt;程序集加载和卸载事件。&lt;/li&gt;
&lt;li&gt;模块加载和卸载事件。&lt;/li&gt;
&lt;li&gt;COM vtable 创建和析构事件。&lt;/li&gt;
&lt;li&gt;实时 (JIT) 编译和代码间距调整事件。&lt;/li&gt;
&lt;li&gt;类加载和卸载事件。&lt;/li&gt;
&lt;li&gt;线程创建和析构事件。&lt;/li&gt;
&lt;li&gt;函数入口和退出事件。&lt;/li&gt;
&lt;li&gt;异常。&lt;/li&gt;
&lt;li&gt;托管和非托管代码执行之间的转换。&lt;/li&gt;
&lt;li&gt;不同运行时上下文之间的转换。&lt;/li&gt;
&lt;li&gt;有关运行时挂起的信息。&lt;/li&gt;
&lt;li&gt;有关运行时内存堆和垃圾回收活动的信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这可能要求你掌握 C++ 和 C#, 另外需要注意的是，Profiler 是一个非托管的 DLL 库，会在应用运行时被加载到 CLR 中并与应用处于同一进程空间下，所以 Profiler DLL 实质上是不受托管代码的访问控制的，还有，Profiler DLL 作为 CLR 的一个插件，其运行错误可能会引起 CLR 本身的崩溃，所以你必须要知道这些风险，并且足够小心，最后祝你好运&lt;/p&gt;
&lt;h3 id=&quot;另外&quot;&gt;另外&lt;/h3&gt;
&lt;p&gt;HttpReports 是针对.Net Core 开发的APM系统， 基于MIT开源协议，针对于微服务场景，感兴趣的同学可以点个 Star 支持下，谢谢, 我们&lt;/p&gt;
&lt;p&gt;Github：&lt;a href=&quot;https://github.com/dotnetcore/HttpReports&quot; title=&quot;https://github.com/dotnetcore/HttpReports&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnetcore/HttpReports&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 28 Dec 2020 00:04:00 +0000</pubDate>
<dc:creator>SpringLeee</dc:creator>
<og:description>APM是一种应用性能监控工具，可以帮助理解系统行为, 用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题, 通过汇聚业务系统各处理环节的实时数据，分析业务系统各事务处理的交易路径和处理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/myshowtime/p/14199844.html</dc:identifier>
</item>
<item>
<title>GitLab Runner部署(kubernetes环境) - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14199837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14199837.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;关于gitlab-ci&quot;&gt;关于GitLab CI&lt;/h3&gt;
&lt;p&gt;如下图所示，开发者将代码提交到GitLab后，可以触发CI脚本在GitLab Runner上执行，通过编写CI脚本我们可以完成很多使用的功能：编译、构建、生成docker镜像、推送到私有仓库等：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074821543-1542376554.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;本次实战内容&quot;&gt;本次实战内容&lt;/h3&gt;
&lt;p&gt;今天咱们会一起完成以下操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;部署minio，pipeline脚本中的cache功能由minio来实现；&lt;/li&gt;
&lt;li&gt;配置和部署GitLab Runner；&lt;/li&gt;
&lt;li&gt;编写和运行pipeline脚本；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;环境和版本信息&quot;&gt;环境和版本信息&lt;/h3&gt;
&lt;p&gt;本次实战涉及到多个服务，下面给出它们的版本信息供您参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;GitLab：Community Edition 13.0.6&lt;/li&gt;
&lt;li&gt;GilLab Runner：13.1.0&lt;/li&gt;
&lt;li&gt;kubernetes：1.15.3&lt;/li&gt;
&lt;li&gt;Harbor：1.1.3&lt;/li&gt;
&lt;li&gt;Minio：2020-06-18T02:23:35Z&lt;/li&gt;
&lt;li&gt;Helm：2.16.1&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;需要提前准备好的服务&quot;&gt;需要提前准备好的服务&lt;/h3&gt;
&lt;p&gt;以下服务需要您在实战前提前准备好：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;部署好GitLab，参考&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/106973743&quot; target=&quot;_blank&quot;&gt;《群晖DS218+部署GitLab》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;部署好Harbor，参考&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/106962214&quot; target=&quot;_blank&quot;&gt;《群晖DS218+部署Harbor(1.10.3)》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;部署好Helm，参考&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/103667500&quot; target=&quot;_blank&quot;&gt;《部署和体验Helm(2.16.1版本)》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;准备完毕后开始实战；&lt;/p&gt;
&lt;h3 id=&quot;部署minio&quot;&gt;部署minio&lt;/h3&gt;
&lt;p&gt;minio作为一个独立的服务部署，我将用docker部署在服务器：&lt;span&gt;192.168.50.43&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在宿主机准备两个目录，分别存储minio的配置和文件，执行以下命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mkdir -p /var/services/homes/zq2599/minio/gitlab_runner \
&amp;amp;&amp;amp; chmod -R 777 /var/services/homes/zq2599/minio/gitlab_runner \
&amp;amp;&amp;amp; mkdir -p /var/services/homes/zq2599/minio/config \
&amp;amp;&amp;amp; chmod -R 777 /var/services/homes/zq2599/minio/config
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;执行docker命令创建minio服务，指定服务端口是9000，并且指定了access key(最短三位)和secret key(最短八位)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;sudo docker run -p 9000:9000 --name minio \
-d --restart=always \
-e &quot;MINIO_ACCESS_KEY=access&quot; \
-e &quot;MINIO_SECRET_KEY=secret123456&quot; \
-v /var/services/homes/zq2599/minio/gitlab_runner:/gitlab_runner \
-v /var/services/homes/zq2599/minio/config:/root/.minio \
minio/minio server /gitlab_runner
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;浏览器访问，输入access key和secret key后登录成功：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074821999-320273437.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如下图，点击红框中的图标，创建一个bucket，名为&lt;span&gt;runner&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074822463-1941463695.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;至此，minio已备好，接下来在kubernetes环境部署GitLab Runner；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;gitlab-runner的类型&quot;&gt;GitLab Runner的类型&lt;/h3&gt;
&lt;p&gt;从使用者的维度来看，GitLab Runner的类型分为&lt;span&gt;shared&lt;/span&gt;和&lt;span&gt;specific&lt;/span&gt;两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果您想创建的GitLab Runner给所有GitLab仓库使用，就要创建&lt;span&gt;shared&lt;/span&gt;类型；&lt;/li&gt;
&lt;li&gt;如果您的GitLab Runner只用于给某个固定的Gitlab仓库，就要创建&lt;span&gt;specific&lt;/span&gt;类型；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;今天的实战，我们创建的是&lt;span&gt;specific&lt;/span&gt;类型，即先有GitLab代码仓库，然后创建该仓库专用的runner，所以请您提前准备好GitLab仓库；&lt;/p&gt;
&lt;h3 id=&quot;准备gitlab配置信息specific&quot;&gt;准备GitLab配置信息(specific)&lt;/h3&gt;
&lt;p&gt;在部署GitLab Runner之前，要准备两个关键的配置信息，以便GitLab Runner启动后可以顺利连接上GitLab：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;浏览器访问GitLab，打开用来做CI的代码仓库，点击Settings -&amp;gt; CI/CD -&amp;gt; Runners -&amp;gt; Expand：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074823613-574287167.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如下图，红框1中是&lt;span&gt;gitlab url&lt;/span&gt;，红框2中是&lt;span&gt;registration token&lt;/span&gt;，记好这两个参数，稍后会用到：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074824610-729688755.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;准备gitlab配置信息shared&quot;&gt;准备GitLab配置信息(shared)&lt;/h3&gt;
&lt;p&gt;本次实战不会创建shared类型的runner，如果您要创建该类型runner，只需按照以下方法准备信息即可，创建出来的runner就是所有仓库都能使用的了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;以管理员身份登录GitLab；&lt;/li&gt;
&lt;li&gt;按照下图红框的顺序取得&lt;span&gt;gitlab url&lt;/span&gt;和&lt;span&gt;registration token&lt;/span&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074825169-1359310068.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;部署ritlab-runner&quot;&gt;部署RitLab Runner&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;请确保当前可以通过&lt;span&gt;kubectl&lt;/span&gt;命令在kubernetes进行常规操作；&lt;/li&gt;
&lt;li&gt;创建名为&lt;span&gt;gitlab-runner&lt;/span&gt;的namespace：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;kubectl create namespace gitlab-runner
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;创建一个secret，把minio的access key和secret key存进去，在后面配置cache的时候会用到：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;kubectl create secret generic s3access \
--from-literal=accesskey=&quot;access&quot; \
--from-literal=secretkey=&quot;secret123456&quot; -n gitlab-runner
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;用helm部署GitLab Runner之前，先把chart的仓库添加到helm的仓库列表中：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;helm repo add gitlab https://charts.gitlab.io
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;下载GitLab Runner的chart：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;helm fetch gitlab/gitlab-runner
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;当前目录会多出一个文件gitlab-runner-0.18.0.tgz，解压：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;tar -zxvf gitlab-runner-0.18.0.tgz
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;解压后是名为gitlab-runner的文件夹，内容如下图所示，接下来要修改里面的三个文件：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074826107-497647324.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;8. 打开values.yaml，里面有四处需要修改：&lt;br/&gt;9. 第一处，找到已被注释掉的&lt;span&gt;gitlabUrl&lt;/span&gt;参数位置，添加gitlabUrl的配置，其值就是前面在GitLab网页取得的&lt;span&gt;gitlab url&lt;/span&gt;参数，如下图红框：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074827190-429488847.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;10. 第二处，找到已被注释掉的&lt;span&gt;runnerRegistrationToken&lt;/span&gt;参数位置，添加&lt;span&gt;runnerRegistrationToken&lt;/span&gt;的配置，其值就是前面在GitLab网页取得的&lt;span&gt;registration token&lt;/span&gt;参数，如下图红框：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074828313-408134749.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;11. 找到&lt;span&gt;rbac&lt;/span&gt;的配置，将&lt;span&gt;create&lt;/span&gt;和&lt;span&gt;clusterWideAccess&lt;/span&gt;的值都改成&lt;span&gt;true&lt;/span&gt;(创建RBAC、创建容器gitlab-bastion用于管理job的容器)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074829149-914489747.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;12. 设置此GitLab Runner的&lt;span&gt;tag&lt;/span&gt;为&lt;span&gt;k8s&lt;/span&gt;，在pipeline脚本中可以通过指定tag为&lt;span&gt;k8s&lt;/span&gt;，这样pipeline就会在这个Gitlab Runner上允许：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074829613-1391978094.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;13. 找到&lt;span&gt;cache&lt;/span&gt;的配置，在修改之前，cache的配置如下图，可见值为空内容的大括号，其余信息全部被注释了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074830323-1823996373.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;14. 修改后的&lt;span&gt;cache&lt;/span&gt;配置如下图，红框1中原先的大括号已去掉，红框2中的是去掉了注释符号，内容不变，红框3中填写的是&lt;span&gt;minio&lt;/span&gt;的访问地址，红框4中的是去掉了注释符号，内容不变：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074831635-1897936208.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;15. 上图红框4中的&lt;span&gt;s3CacheInsecure&lt;/span&gt;参数等于&lt;span&gt;false&lt;/span&gt;表示对minio的请求为http(如果是true就是https)，但实际证明，&lt;span&gt;当前版本的chart中该配置是无效的&lt;/span&gt;，等到运行时还是会以https协议访问，解决此问题的方法是修改templates目录下的&lt;span&gt;_cache.tpl&lt;/span&gt;文件，打开此文件，找到下图红框中的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074833453-676800604.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;16. 将上图红框中的内容替换成下面红框中的样子，即删除原先的&lt;span&gt;if判断和对应的end&lt;/span&gt;这两行，直接给&lt;span&gt;CACHE_S3_INSECURE&lt;/span&gt;赋值：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074834177-331474133.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;17. 接下来要修改的是&lt;span&gt;templates/configmap.yaml&lt;/span&gt;文件，在这里面将宿主机的docker的sock映射给runner executor，这样job中的docker命令就会发到宿主机的docker daemon上，由宿主机来执行，打开&lt;span&gt;templates/configmap.yaml&lt;/span&gt;，找到下图位置，我们要在红框1和红框2之间添加一段内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074834782-1016678353.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;18. 要在上图红框1和红框2之间添加的内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cat &amp;gt;&amp;gt;/home/gitlab-runner/.gitlab-runner/config.toml &amp;lt;&amp;lt;EOF
            [[runners.kubernetes.volumes.host_path]]
              name = &quot;docker&quot;
              mount_path = &quot;/var/run/docker.sock&quot;
              read_only = true
              host_path = &quot;/var/run/docker.sock&quot;
    EOF
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;19&quot;&gt;&lt;li&gt;添加上述内容后，整体效果如下，红框中就是新增内容：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074835431-1221200917.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;20. 修改完毕，回到&lt;span&gt;values.yam&lt;/span&gt;所在目录，执行以下命令即可创建GitLab Runner：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;helm install \
--name-template gitlab-runner \
-f values.yaml . \
--namespace gitlab-runner
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;21&quot;&gt;&lt;li&gt;检查pod是否正常：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074835952-1025836180.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;22. 看pod日志也并未发现异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074836646-646488516.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;23. 回到GitLab的runner页面，可见新增一个runner：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074837518-1733400497.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;至此，整个GitLab CI环境已部署完毕，接下来简单的验证环境是否OK；&lt;/p&gt;
&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在GitLab仓库中，增加名为&lt;span&gt;.gitlab-ci.yml&lt;/span&gt;的文件，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;# 设置执行镜像
image: busybox:latest

# 整个pipeline有两个stage
stages:
- build
- test

# 定义全局缓存，缓存的key来自分支信息，缓存位置是vendor文件夹
cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
  - vendor/

before_script:
  - echo &quot;Before script section&quot;

after_script:
  - echo &quot;After script section&quot;

build1:
  stage: build
    tags:
  - k8s
  script:
    - echo &quot;将内容写入缓存&quot;
    - echo &quot;build&quot; &amp;gt; vendor/hello.txt

test1:
  stage: test
  script:
    - echo &quot;从缓存读取内容&quot;
    - cat vendor/hello.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;提交上述脚本到GitLab，如下图，可见pipeline会被触发，状态为pending是因为正在等待runner创建executor pod：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074838277-232718094.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 稍后就会执行成功，点开看结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074839018-2131369377.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 点开&lt;span&gt;build1&lt;/span&gt;的图标，可见此job的输出信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074840259-509607195.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;5. 点开&lt;span&gt;test1&lt;/span&gt;的图标，可见对应的控制台输出，上一个job写入的数据被成功读取：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201228074841543-142837460.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，GitLab Runner已经成功在kubernetes环境部署和运行，接下来的文章，我们会一起实战将SpringBoot应用构建成docker镜像并推送到Harbor；&lt;/p&gt;
&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 27 Dec 2020 23:49:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14199837.html</dc:identifier>
</item>
<item>
<title>6. 抹平差异，统一类型转换服务ConversionService - YourBatman</title>
<link>http://www.cnblogs.com/yourbatman/p/14199830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yourbatman/p/14199830.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201220074003122.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.2222222222222&quot;&gt;
&lt;p&gt;分享、成长，拒绝浅藏辄止。关注公众号【&lt;strong&gt;BAT的乌托邦&lt;/strong&gt;】，回复关键字&lt;code&gt;专栏&lt;/code&gt;有Spring技术栈、中间件等小而美的&lt;strong&gt;原创专栏&lt;/strong&gt;供以免费学习。本文已被 &lt;a href=&quot;https://www.yourbatman.cn&quot; target=&quot;_blank&quot;&gt;https://www.yourbatman.cn&lt;/a&gt; 收录。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你好，我是YourBatman。&lt;/p&gt;
&lt;p&gt;通过前两篇文章的介绍已经非常熟悉Spirng 3.0全新一代的类型转换机制了，它提供的三种类型转换器(Converter、ConverterFactory、GenericConverter)，分别可处理1:1、1:N、N:N的类型转换。按照Spring的设计习惯，必有一个注册中心来统一管理，负责它们的注册、删除等，它就是&lt;code&gt;ConverterRegistry&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;对于&lt;code&gt;ConverterRegistry&lt;/code&gt;在文首多说一句：我翻阅了很多博客文章介绍它时几乎无一例外的提到有&lt;strong&gt;查找&lt;/strong&gt;的功能，但实际上是&lt;strong&gt;没有的&lt;/strong&gt;。Spring设计此API接口并没有暴露其查找功能，选择把最为复杂的查找匹配逻辑私有化，目的是让开发者使可无需关心，细节之处充分体现了Spring团队API设计的卓越能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，内建的绝大多数转换器访问权限都是default/private，那么如何使用它们，以及屏蔽各种转换器的&lt;strong&gt;差异化&lt;/strong&gt;呢？为此，Spring提供了一个&lt;strong&gt;统一类型转换服务&lt;/strong&gt;，它就是&lt;code&gt;ConversionService&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;版本约定&quot;&gt;版本约定&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Spring Framework：5.3.1&lt;/li&gt;
&lt;li&gt;Spring Boot：2.4.0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201224070630350.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ConverterRegistry和ConversionService的关系密不可分，前者为后者提供转换器管理支撑，后者面向使用者提供服务。本文涉及到的接口/类有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ConverterRegistry&lt;/code&gt;：转换器注册中心。负责转换器的注册、删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConversionService&lt;/code&gt;：&lt;strong&gt;统一的&lt;/strong&gt;类型转换服务。属于面向开发者使用的门面接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConfigurableConversionService&lt;/code&gt;：上两个接口的组合接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GenericConversionService&lt;/code&gt;：上个接口的实现，实现了注册管理、转换服务的几乎&lt;strong&gt;所有功能&lt;/strong&gt;，是个实现类而非抽象类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DefaultConversionService&lt;/code&gt;：继承自&lt;code&gt;GenericConversionService&lt;/code&gt;，在其基础上注册了一批默认转换器（Spring内建），从而具备基础转换能力，能解决日常绝大部分场景&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201219220041102.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;converterregistry&quot;&gt;ConverterRegistry&lt;/h2&gt;
&lt;p&gt;Spring 3.0引入的转换器注册中心，用于管理新一套的转换器们。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface ConverterRegistry {
        
        void addConverter(Converter&amp;lt;?, ?&amp;gt; converter);
        &amp;lt;S, T&amp;gt; void addConverter(Class&amp;lt;S&amp;gt; sourceType, Class&amp;lt;T&amp;gt; targetType, Converter&amp;lt;? super S, ? extends T&amp;gt; converter);
        void addConverter(GenericConverter converter);
        void addConverterFactory(ConverterFactory&amp;lt;?, ?&amp;gt; factory);
        
        // 唯一移除方法：按照转换pair对来移除
        void removeConvertible(Class&amp;lt;?&amp;gt; sourceType, Class&amp;lt;?&amp;gt; targetType);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的继承树如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201220155358172.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ConverterRegistry有子接口FormatterRegistry，它属于格式化器的范畴，故不放在本文讨论。但&lt;strong&gt;仍旧属于本系列专题&lt;/strong&gt;内容，会在接下来的几篇内容里介入，敬请关注。&lt;/p&gt;
&lt;h2 id=&quot;conversionservice&quot;&gt;ConversionService&lt;/h2&gt;
&lt;p&gt;面向使用者的统一类型转换服务。换句话说：站在使用层面，你只需要知道&lt;code&gt;ConversionService&lt;/code&gt;接口API的使用方式即可，并不需要关心其内部实现机制，可谓对使用者非常友好。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface ConversionService {
        
        boolean canConvert(Class&amp;lt;?&amp;gt; sourceType, Class&amp;lt;?&amp;gt; targetType);
        boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);
        
        &amp;lt;T&amp;gt; T convert(Object source, Class&amp;lt;T&amp;gt; targetType);
        Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的继承树如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201220155730772.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到ConversionService和ConverterRegistry的继承树殊途同归，都直接指向了&lt;code&gt;ConfigurableConversionService&lt;/code&gt;这个分支，下面就对它进行介绍。&lt;/p&gt;
&lt;h3 id=&quot;configurableconversionservice&quot;&gt;ConfigurableConversionService&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ConversionService&lt;/code&gt;和&lt;code&gt;ConverterRegistry&lt;/code&gt;的组合接口，自己并未新增任何接口方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface ConfigurableConversionService extends ConversionService, ConverterRegistry {

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的继承树可参考上图。接下来就来到此接口的直接实现类GenericConversionService。&lt;/p&gt;
&lt;h3 id=&quot;genericconversionservice&quot;&gt;GenericConversionService&lt;/h3&gt;
&lt;p&gt;对&lt;code&gt;ConfigurableConversionService&lt;/code&gt;接口提供了完整实现的实现类。换句话说：ConversionService和ConverterRegistry接口的功能均通过此类得到了实现，所以它是本文重点。&lt;/p&gt;
&lt;p&gt;该类很有些值得学习的地方，可以细品，在我们自己设计程序时加以借鉴。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class GenericConversionService implements ConfigurableConversionService {

        private final Converters converters = new Converters();
        private final Map&amp;lt;ConverterCacheKey, GenericConverter&amp;gt; converterCache = new ConcurrentReferenceHashMap&amp;lt;ConverterCacheKey, GenericConverter&amp;gt;(64);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它用两个成员变量来&lt;strong&gt;管理&lt;/strong&gt;转换器们，其中converterCache是缓存用于加速查找，因此更为重要的便是Converters喽。&lt;/p&gt;
&lt;p&gt;Converters是&lt;code&gt;GenericConversionService&lt;/code&gt;的内部类，用于管理（添加、删除、查找）转换器们。也就说对&lt;code&gt;ConverterRegistry&lt;/code&gt;接口的实现最终是委托给它去完成的，它是整个&lt;strong&gt;转换服务&lt;/strong&gt;正常work的内核，下面我们对它展开详细叙述。&lt;/p&gt;
&lt;h4 id=&quot;1、内部类converters&quot;&gt;1、内部类Converters&lt;/h4&gt;
&lt;p&gt;它管理&lt;strong&gt;所有&lt;/strong&gt;转换器，包括添加、删除、查找。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GenericConversionService：

        // 内部类
        private static class Converters {
                private final Set&amp;lt;GenericConverter&amp;gt; globalConverters = new LinkedHashSet&amp;lt;GenericConverter&amp;gt;();
                private final Map&amp;lt;ConvertiblePair, ConvertersForPair&amp;gt; converters = new LinkedHashMap&amp;lt;ConvertiblePair, ConvertersForPair&amp;gt;(36);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;说明：这里使用的集合/Map均为&lt;code&gt;LinkedHashXXX&lt;/code&gt;，都是有序的（存入顺序和遍历取出顺序保持一致）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用这两个集合/Map存储着注册进来的转换器们，他们的作用分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;globalConverters&lt;/code&gt;：存取&lt;strong&gt;通用的&lt;/strong&gt;转换器，并不限定转换类型，一般用于兜底&lt;/li&gt;
&lt;li&gt;&lt;code&gt;converters&lt;/code&gt;：指定了类型对，对应的转换器&lt;strong&gt;们&lt;/strong&gt;的映射关系。
&lt;ul&gt;&lt;li&gt;ConvertiblePair：表示一对，包含sourceType和targetType&lt;/li&gt;
&lt;li&gt;ConvertersForPair：这一对对应的转换器&lt;strong&gt;们&lt;/strong&gt;（因为能处理一对的可能存在多个转换器），内部使用一个双端队列Deque来存储，保证顺序
&lt;ul&gt;&lt;li&gt;小细节：Spring 5之前使用LinkedList，之后使用Deque（实际为ArrayDeque）存储&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final class ConvertiblePair {
        private final Class&amp;lt;?&amp;gt; sourceType;
        private final Class&amp;lt;?&amp;gt; targetType;
}
private static class ConvertersForPair {
        private final Deque&amp;lt;GenericConverter&amp;gt; converters = new ArrayDeque&amp;lt;&amp;gt;(1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;添加add&quot;&gt;添加add&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void add(GenericConverter converter) {
        Set&amp;lt;ConvertiblePair&amp;gt; convertibleTypes = converter.getConvertibleTypes();
        if (convertibleTypes == null) {
                ... // 放进globalConverters里
        } else {
                ... // 放进converters里（若支持多组pair就放多个key）
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在此之前需要了解个前提：对于三种转换器&lt;code&gt;Converter、ConverterFactory、GenericConverter&lt;/code&gt;在添加到Converters之前都&lt;strong&gt;统一&lt;/strong&gt;被适配为了&lt;code&gt;GenericConverter&lt;/code&gt;，这样做的目的是方便统一管理。对应的两个适配器是ConverterAdapter和ConverterFactoryAdapter，它俩都是ConditionalGenericConverter的内部类。&lt;/p&gt;
&lt;p&gt;添加的逻辑被我用伪代码简化后其实非常简单，无非就是一个非此即彼的关系而已：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若转换器没有指定处理的类型对，就放进全局转换器列表里，用于兜底&lt;/li&gt;
&lt;li&gt;若转换器有指定处理的类型对（可能还是多个），就放进converters里，后面查找时使用&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;删除remove&quot;&gt;删除remove&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void remove(Class&amp;lt;?&amp;gt; sourceType, Class&amp;lt;?&amp;gt; targetType) {
        this.converters.remove(new ConvertiblePair(sourceType, targetType));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;移除逻辑非常非常的简单，这得益于添加时候做了&lt;strong&gt;统一适配的抽象&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;查找find&quot;&gt;查找find&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Nullable
public GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType) {
        // 找到该类型的类层次接口（父类 + 接口），注意：结果是有序列表
        List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; sourceCandidates = getClassHierarchy(sourceType.getType());
        List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; targetCandidates = getClassHierarchy(targetType.getType());

        // 双重遍历
        for (Class&amp;lt;?&amp;gt; sourceCandidate : sourceCandidates) {
                for (Class&amp;lt;?&amp;gt; targetCandidate : targetCandidates) {
                        ConvertiblePair convertiblePair = new ConvertiblePair(sourceCandidate, targetCandidate);
                        ... // 从converters、globalConverters里匹配到一个合适转换器后立马返回
                }
        }
        return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找逻辑也并不复杂，有两个关键点需要关注：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;getClassHierarchy(class)&lt;/code&gt;：获取该类型的类层次（父类 + 接口），注意：结果List是有序的List
&lt;ul&gt;&lt;li&gt;也就是说转换器支持的类型若是父类/接口，那么也能够处理器子类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;根据convertiblePair匹配转换器：优先匹配专用的converters，然后才是globalConverters。若都没匹配上返回null&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;2、管理转换器converterregistry&quot;&gt;2、管理转换器(ConverterRegistry)&lt;/h4&gt;
&lt;p&gt;了解了&lt;code&gt;Converters&lt;/code&gt;之后再来看&lt;code&gt;GenericConversionService&lt;/code&gt;是如何管理转换器，就如鱼得水，一目了然了。&lt;/p&gt;
&lt;h5 id=&quot;添加&quot;&gt;添加&lt;/h5&gt;
&lt;p&gt;为了&lt;strong&gt;方便&lt;/strong&gt;使用者调用，ConverterRegistry接口提供了三个添加方法，这里一一给与实现。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;说明：暴露给调用者使用的API接口使用起来应尽量的方便，重载多个是个有效途径。内部做适配、归口即可，用户至上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void addConverter(Converter&amp;lt;?, ?&amp;gt; converter) {
        // 获取泛型类型 -&amp;gt; 转为ConvertiblePair
        ResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);
        ... 
        // converter适配为GenericConverter添加
        addConverter(new ConverterAdapter(converter, typeInfo[0], typeInfo[1]));
}

@Override
public &amp;lt;S, T&amp;gt; void addConverter(Class&amp;lt;S&amp;gt; sourceType, Class&amp;lt;T&amp;gt; targetType, Converter&amp;lt;? super S, ? extends T&amp;gt; converter) {
        addConverter(new ConverterAdapter(converter, ResolvableType.forClass(sourceType), ResolvableType.forClass(targetType)));
}

@Override
public void addConverter(GenericConverter converter) {
        this.converters.add(converter);
        invalidateCache();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前两个方法都会调用到第三个方法上，每调用一次&lt;code&gt;addConverter()&lt;/code&gt;方法都会清空缓存，也就是&lt;code&gt;converterCache.clear()&lt;/code&gt;。所以动态添加转换器对性能是&lt;strong&gt;有损&lt;/strong&gt;的，因此使用时候需稍加注意一些。&lt;/p&gt;
&lt;h5 id=&quot;查找&quot;&gt;查找&lt;/h5&gt;
&lt;p&gt;ConverterRegistry接口并未直接提供查找方法，而只是在实现类内部做了实现。提供一个钩子方法用于查找给定sourceType/targetType对的转换器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Nullable
protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {
        ConverterCacheKey key = new ConverterCacheKey(sourceType, targetType);
        
        // 1、查缓存
        GenericConverter converter = this.converterCache.get(key);
        if (converter != null) {
                ... // 返回结果
        }

        // 2、去converters里查找
        converter = this.converters.find(sourceType, targetType);
        if (converter == null) {
                // 若还没有匹配的，就返回默认结果
                // 默认结果是NoOpConverter -&amp;gt; 什么都不做
                converter = getDefaultConverter(sourceType, targetType);
        }

        ... // 把结果装进缓存converterCache里
        return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了对Converters查找逻辑的分析，这个步骤就很简单了。绘制成图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201220065638293.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3、转换功能conversionservice&quot;&gt;3、转换功能(ConversionService)&lt;/h4&gt;
&lt;p&gt;上半部分介绍完&lt;code&gt;GenericConversionService&lt;/code&gt;对转换器管理部分的实现（对ConverterRegistry接口的实现），接下来就看看它是如何实现转换功能的（对ConversionService接口的实现）。&lt;/p&gt;
&lt;h5 id=&quot;判断&quot;&gt;判断&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public boolean canConvert(@Nullable Class&amp;lt;?&amp;gt; sourceType, Class&amp;lt;?&amp;gt; targetType) {
        return canConvert((sourceType != null ? TypeDescriptor.valueOf(sourceType) : null), TypeDescriptor.valueOf(targetType));
}

@Override
public boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {
        if (sourceType == null) {
                return true;
        }
        
        // 查找/匹配对应的转换器
        GenericConverter converter = getConverter(sourceType, targetType);
        return (converter != null);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;能否执行转换判断的唯一标准：&lt;strong&gt;能否匹配到可用于转换的转换器&lt;/strong&gt;。而这个查找匹配逻辑，稍稍抬头往上就能看到。&lt;/p&gt;
&lt;h5 id=&quot;转换&quot;&gt;转换&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
@SuppressWarnings(&quot;unchecked&quot;)
@Nullable
public &amp;lt;T&amp;gt; T convert(@Nullable Object source, Class&amp;lt;T&amp;gt; targetType) {
        return (T) convert(source, TypeDescriptor.forObject(source), TypeDescriptor.valueOf(targetType));
}

@Override
@Nullable
public Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {
        if (sourceType == null) {
                return handleResult(null, targetType, convertNullSource(null, targetType));
        }
        // 校验：source必须是sourceType的实例
        if (source != null &amp;amp;&amp;amp; !sourceType.getObjectType().isInstance(source)) {
                throw new IllegalArgumentException(&quot;Source to convert from must be an instance of [&quot; + sourceType + &quot;]; instead it was a [&quot; + source.getClass().getName() + &quot;]&quot;);
        }

        // ============拿到转换器，执行转换============
        GenericConverter converter = getConverter(sourceType, targetType);
        if (converter != null) {
                Object result = ConversionUtils.invokeConverter(converter, source, sourceType, targetType);
                return handleResult(sourceType, targetType, result);
        }
        // 若没进行canConvert的判断直接调动，可能出现此种状况：一般抛出ConverterNotFoundException异常
        return handleConverterNotFound(source, sourceType, targetType);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，执行转换的逻辑很简单，非常好理解的两个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;查找匹配到一个合适的转换器（查找匹配的逻辑同上）&lt;/li&gt;
&lt;li&gt;拿到此转换器执行转换&lt;code&gt;converter.convert(...)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;说明：其余代码均为一些判断、校验、容错，并非核心，本文给与适当忽略。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;GenericConversionService实现了转换器管理、转换服务的&lt;strong&gt;所有功能&lt;/strong&gt;，是可以直接面向开发者使用的。但是开发者使用时可能并不知道需要注册哪些转换器来保证程序正常运转，Spring并不能要求开发者知晓其内建实现。基于此，Spring在3.1又提供了一个默认实现DefaultConversionService，它对使用者更友好。&lt;/p&gt;
&lt;h3 id=&quot;defaultconversionservice&quot;&gt;DefaultConversionService&lt;/h3&gt;
&lt;p&gt;Spirng容器默认使用的转换服务实现，继承自&lt;code&gt;GenericConversionService&lt;/code&gt;，在其基础行只做了&lt;strong&gt;一件事&lt;/strong&gt;：构造时添加内建的默认转换器&lt;strong&gt;们&lt;/strong&gt;。从而天然具备有了基本的类型转换能力，适用于不同的环境。如：xml解析、@Value解析、http协议参数自动转换等等。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小细节：它并非Spring 3.0就有，而是Spring 3.1新推出的API&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// @since 3.1
public class DefaultConversionService extends GenericConversionService {
        
        // 唯一构造器
        public DefaultConversionService() {
                addDefaultConverters(this);
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本类核心代码就这一个构造器，构造器内就这一句代码：&lt;code&gt;addDefaultConverters(this)&lt;/code&gt;。接下来需要关注Spring默认情况下给我们“安装”了哪些转换器呢？也就是了解下&lt;code&gt;addDefaultConverters(this)&lt;/code&gt;这个静态方法&lt;/p&gt;
&lt;h4 id=&quot;默认注册的转换器们&quot;&gt;默认注册的转换器们&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// public的静态方法，注意是public的访问权限
public static void addDefaultConverters(ConverterRegistry converterRegistry) {
        addScalarConverters(converterRegistry);
        addCollectionConverters(converterRegistry);

        converterRegistry.addConverter(new ByteBufferConverter((ConversionService) converterRegistry));
        converterRegistry.addConverter(new StringToTimeZoneConverter());
        converterRegistry.addConverter(new ZoneIdToTimeZoneConverter());
        converterRegistry.addConverter(new ZonedDateTimeToCalendarConverter());

        converterRegistry.addConverter(new ObjectToObjectConverter());
        converterRegistry.addConverter(new IdToEntityConverter((ConversionService) converterRegistry));
        converterRegistry.addConverter(new FallbackObjectToStringConverter());
        converterRegistry.addConverter(new ObjectToOptionalConverter((ConversionService) converterRegistry));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该静态方法用于注册全局的、&lt;strong&gt;默认的&lt;/strong&gt;转换器们，从而让Spring有了基础的转换能力，进而完成绝大部分转换工作。为了方便记忆这个注册流程，我把它绘制成图供以你保存：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201219110117341.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特别强调：转换器的注册顺序非常重要，这决定了通用转换器的匹配结果（谁在前，优先匹配谁，first win）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对这幅图，你可能还会有如下疑问：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JSR310转换器只看到TimeZone、ZoneId等转换，怎么没看见更为常用的LocalDate、LocalDateTime等这些类型转换呢？难道Spring默认是不支持的？
&lt;ol&gt;&lt;li&gt;答：&lt;strong&gt;当然不是&lt;/strong&gt;。 这么常见的场景Spring怎能会不支持呢？不过与其说这是类型转换，倒不如说是&lt;strong&gt;格式化&lt;/strong&gt;更合适。所以放在该系列后几篇关于格式化章节中再做讲述&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;一般的Converter都见名之意，但StreamConverter有何作用呢？什么场景下会生效
&lt;ol&gt;&lt;li&gt;答：上文已讲述&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;对于兜底的转换器，有何含义？这种极具通用性的转换器作用为何
&lt;ol&gt;&lt;li&gt;答：上文已讲述&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后，需要特别强调的是：它是一个静态方法，并且还是public的访问权限，且不仅仅只有本类调用。实际上，&lt;code&gt;DefaultConversionService&lt;/code&gt;仅仅只做了这一件事，所以任何地方只要调用了该静态方法都能达到前者&lt;strong&gt;相同的效果&lt;/strong&gt;，使用上可谓给与了较大的灵活性。比如Spring Boot环境下不是使用&lt;code&gt;DefaultConversionService&lt;/code&gt;而是&lt;code&gt;ApplicationConversionService&lt;/code&gt;，后者是对FormattingConversionService扩展，这个话题放在后面详解。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Spring Boot在web环境默认向容易注册了一个WebConversionService，因此你有需要可直接@Autowired使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;conversionservicefactorybean&quot;&gt;ConversionServiceFactoryBean&lt;/h2&gt;
&lt;p&gt;顾名思义，它是用于产生&lt;code&gt;ConversionService&lt;/code&gt;类型转换服务的工厂Bean，为了方便和Spring容器整合而使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ConversionServiceFactoryBean implements FactoryBean&amp;lt;ConversionService&amp;gt;, InitializingBean {

        @Nullable
        private Set&amp;lt;?&amp;gt; converters;
        @Nullable
        private GenericConversionService conversionService;

        public void setConverters(Set&amp;lt;?&amp;gt; converters) {
                this.converters = converters;
        }
        @Override
        public void afterPropertiesSet() {
                // 使用的是默认实现哦
                this.conversionService = new DefaultConversionService();
                ConversionServiceFactory.registerConverters(this.converters, this.conversionService);
        }
        
        @Override
        @Nullable
        public ConversionService getObject() {
                return this.conversionService;
        }
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只有两个信息量需要关注：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用的是DefaultConversionService，因此那一大串的内建转换器们都会被添加进来的&lt;/li&gt;
&lt;li&gt;自定义转换器可以通过&lt;code&gt;setConverters()&lt;/code&gt;方法添加进来
&lt;ol&gt;&lt;li&gt;值得注意的是方法入参是&lt;code&gt;Set&amp;lt;?&amp;gt;&lt;/code&gt;并没有明确泛型类型，因此那三种转换器(1:1/1:N/N:N)你是都可以添加.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通读本文过后，相信能够给与你这个感觉：曾经望而却步的Spring类型转换服务&lt;code&gt;ConversionService&lt;/code&gt;，其实也不过如此嘛。通篇我用了多个简单字眼来说明，因为&lt;strong&gt;拆开之后&lt;/strong&gt;，无一高复杂度知识点。&lt;/p&gt;
&lt;p&gt;迎难而上是积攒涨薪底气和勇气的途径，况且某些知识点其实并不难，所以我觉得从性价比角度来看这类内容是非常划算的，你pick到了麽？&lt;/p&gt;
&lt;p&gt;正所谓类型转换和格式化属于两组近义词，在Spring体系中也经常交织在一起使用，有种傻傻分不清楚之感。从下篇文章起进入到本系列关于Formatter格式化器知识的梳理，什么日期格式化、@DateTimeFormat、@NumberFormat都将帮你捋清楚喽，有兴趣者可保持持续关注。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;推荐阅读&quot;&gt;✔✔✔推荐阅读✔✔✔&lt;/h3&gt;
&lt;p&gt;【Spring类型转换】系列：&lt;/p&gt;
&lt;p&gt;【Jackson】系列：&lt;/p&gt;
&lt;p&gt;【数据校验Bean Validation】系列：&lt;/p&gt;
&lt;p&gt;【新特性】系列：&lt;/p&gt;
&lt;p&gt;【程序人生】系列：&lt;/p&gt;
&lt;p&gt;还有诸如【Spring配置类】【Spring-static】【Spring数据绑定】【Spring Cloud Netflix】【Feign】【Ribbon】【Hystrix】...更多原创专栏，关注&lt;code&gt;BAT的乌托邦&lt;/code&gt;回复&lt;code&gt;专栏&lt;/code&gt;二字即可全部获取，也可加我&lt;code&gt;fsx1056342982&lt;/code&gt;，交个朋友。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;有些&lt;strong&gt;已完结&lt;/strong&gt;，有些&lt;strong&gt;连载中&lt;/strong&gt;。我是A哥(YourBatman)，咱们下期见&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 27 Dec 2020 23:37:00 +0000</pubDate>
<dc:creator>YourBatman</dc:creator>
<og:description>框架设计复杂度，暴露给使用者的话你就输了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yourbatman/p/14199830.html</dc:identifier>
</item>
<item>
<title>浅谈三种求最小生成树的方法 - liuchanglc</title>
<link>http://www.cnblogs.com/liuchanglc/p/14199819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuchanglc/p/14199819.html</guid>
<description>&lt;p&gt;本篇文章的定义均来自与&lt;a href=&quot;https://oi-wiki.org/graph/mst/&quot; target=&quot;_blank&quot;&gt;oi-wiki&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;我们定义无向连通图的 最小生成树 &lt;span class=&quot;math inline&quot;&gt;\(（Minimum\ Spanning\ Tree,MST）\)&lt;/span&gt;为边权和最小的生成树。&lt;/p&gt;
&lt;p&gt;注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。&lt;/p&gt;
&lt;h2 id=&quot;算法&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(Prim\)&lt;/span&gt;算法&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(Prim\)&lt;/span&gt; 算法是一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加点&lt;/p&gt;
&lt;p&gt;具体来说，每次要选择距离最小的一个结点，以及用新的边更新其他结点的距离&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cmath&amp;gt;
#define rg register
inline int read(){
        rg int x=0,fh=1;
        rg char ch=getchar();
        while(ch&amp;lt;'0' || ch&amp;gt;'9'){
                if(ch=='-') fh=-1;
                ch=getchar();
        }
        while(ch&amp;gt;='0' &amp;amp;&amp;amp; ch&amp;lt;='9'){
                x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+(ch^48);
                ch=getchar();
        }
        return x*fh;
}
const int maxn=5e3+5;
int mp[maxn][maxn],dis[maxn],n,m;
bool vis[maxn];
void prim(){
        dis[1]=0;
        for(rg int i=1;i&amp;lt;n;i++){
                rg int x=0;
                for(rg int j=1;j&amp;lt;=n;j++){
                        if(!vis[j] &amp;amp;&amp;amp; (x==0 || dis[j]&amp;lt;dis[x])) x=j;
                }
                vis[x]=1;
                for(rg int j=1;j&amp;lt;=n;j++){
                        if(!vis[j]) dis[j]=std::min(dis[j],mp[j][x]);
                }
        }
}
int main(){
        memset(mp,0x3f,sizeof(mp));
        memset(dis,0x3f,sizeof(dis));
        n=read(),m=read();
        rg int aa,bb,cc;
        for(rg int i=1;i&amp;lt;=m;i++){
                aa=read(),bb=read(),cc=read();
                mp[aa][bb]=mp[bb][aa]=std::min(mp[aa][bb],cc);
        }
        prim();
        rg int ans=0;
        for(rg int i=1;i&amp;lt;=n;i++){
                ans+=dis[i];
        }
        printf(&quot;%d\n&quot;,ans);
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;kruskal-算法&quot;&gt;Kruskal 算法&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(Kruskal\)&lt;/span&gt; 算法是另一种常见并且好写的最小生成树算法，由 &lt;span class=&quot;math inline&quot;&gt;\(Kruskal\)&lt;/span&gt; 发明&lt;/p&gt;
&lt;p&gt;该算法的基本思想是从小到大加入边，是个贪心算法&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class=&quot;math inline&quot;&gt;\(O(mlogn)\)&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn=600000;
struct asd{
    int from,to,val;
}b[maxn];
int tot=1,head[maxn];
void ad(int aa,int bb,int cc){
    b[tot].from=aa;
    b[tot].to=bb;
    b[tot].val=cc;
    tot++;
}
bool cmp(asd aa,asd bb){
    return aa.val&amp;lt;bb.val;
}
int fa[maxn];
int zhao(int xx){
    if(xx==fa[xx]) return xx;
    return fa[xx]=zhao(fa[xx]);
}
void bing(int xx,int yy){
    fa[zhao(xx)]=zhao(yy);
}
int shu(int xxx){
    sort(b+1,b+tot,cmp);
    int ans=0,cnt=0;
    for(int i=1;i&amp;lt;tot;i++){
        int xx=b[i].from,yy=b[i].to;
        if(zhao(xx)!=zhao(yy)){
            bing(xx,yy);
            ans+=b[i].val;
            if(++cnt==xxx) return ans;
        }
    }
    return -1;
}
int main(){
    for(int i=0;i&amp;lt;maxn;i++) fa[i]=i;
    int n,m;
    scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
    for(int i=1;i&amp;lt;=m;i++){
        int aa,bb,cc;
        scanf(&quot;%d%d%d&quot;,&amp;amp;aa,&amp;amp;bb,&amp;amp;cc);
        ad(aa,bb,cc);
    }
    int ans=shu(n-1);
    if(ans==-1) printf(&quot;orz\n&quot;);
    else printf(&quot;%d\n&quot;,ans);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;算法-1&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\(Boruvka\)&lt;/span&gt; 算法&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(Boruvka\)&lt;/span&gt; 其实是一种多路增广的 &lt;span class=&quot;math inline&quot;&gt;\(Prim\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(Boruvka\)&lt;/span&gt; 算法每一次的增广，会对现在的每一个连通块都找一遍的最短边，最后每个连通块择优，将这些边全部连上&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class=&quot;math inline&quot;&gt;\(O(mlogn)\)&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#define rg register
inline int read(){
        rg int x=0,fh=1;
        rg char ch=getchar();
        while(ch&amp;lt;'0' || ch&amp;gt;'9'){
                if(ch=='-') fh=-1;
                ch=getchar();
        }
        while(ch&amp;gt;='0' &amp;amp;&amp;amp; ch&amp;lt;='9'){
                x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+(ch^48);
                ch=getchar();
        }
        return x*fh;
}
const int maxn=1e6+5;
struct asd{
        int zb,yb,val;
}b[maxn];
int n,m,fa[maxn],cnt,sum,bes[maxn];
int zhao(rg int xx){
        if(xx==fa[xx]) return xx;
        return fa[xx]=zhao(fa[xx]);
}
bool vis[maxn];
bool pd(rg int aa,rg int bb){
        if(bb==0) return 1;
        if(b[aa].val!=b[bb].val) return b[aa].val&amp;lt;b[bb].val;
        return aa&amp;lt;bb;
}
int main(){
        n=read(),m=read();
        for(rg int i=1;i&amp;lt;=m;i++){
                b[i].zb=read(),b[i].yb=read(),b[i].val=read();
        }
        for(rg int i=1;i&amp;lt;=n;i++) fa[i]=i;
        rg bool jud=1;
        rg int aa,bb;
        while(jud){
                jud=0;
                memset(bes,0,sizeof(bes));
                for(rg int i=1;i&amp;lt;=m;i++){
                        if(vis[i]) continue;
                        aa=zhao(b[i].zb),bb=zhao(b[i].yb);
                        if(aa==bb) continue;
                        if(pd(i,bes[aa])) bes[aa]=i;
                        if(pd(i,bes[bb])) bes[bb]=i;
                }
                for(rg int i=1;i&amp;lt;=n;i++){
                        if(bes[i]!=0 &amp;amp;&amp;amp; vis[bes[i]]==0){
                                jud=1;
                                cnt++;
                                sum+=b[bes[i]].val;
                                vis[bes[i]]=1;
                                fa[zhao(b[bes[i]].zb)]=zhao(b[bes[i]].yb);
                        }
                }
        }
        if(cnt!=n-1) printf(&quot;orz\n&quot;);
        else printf(&quot;%d\n&quot;,sum);
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 27 Dec 2020 22:19:00 +0000</pubDate>
<dc:creator>liuchanglc</dc:creator>
<og:description>浅谈三种求最小生成树的方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuchanglc/p/14199819.html</dc:identifier>
</item>
<item>
<title>高性能MySQL学习总结一 - Tom-shushu</title>
<link>http://www.cnblogs.com/Tom-shushu/p/14199731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tom-shushu/p/14199731.html</guid>
<description>&lt;h4&gt;&lt;span&gt;一、MySQL逻辑架构&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1398504/202012/1398504-20201227224651124-1243228138.png&quot; alt=&quot;&quot; width=&quot;564&quot; height=&quot;477&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　第一层的服务不是MySQL独有的，大多数是基于网络的客户端/服务端的工具，如连接处理、授权认证、安全等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第二层就是MySQL的核心功能，包括查询解析、分析、优化、缓存以及所有的内置函数，所有的跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第三层包含了存储引擎，主要负责MySQL中数据的存储和提取。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1.连接管理与安全&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　每个客户端连接都会服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行，服务器会缓存线程，所以不需要对每个连接新建或者销毁一个线程（可以复用缓存中的线程）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当客户端连接到MySQL时服务器需要对其进行认证，如果认证成功，服务器会继续验证该客户是否有执行某个待定查询的权限。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;2.优化与执行&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;MySQL会解析查询，并且创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询SQL、决定表的读取顺序，以及选择合适的索引等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于一个SELECT查询语句来说：在解析查询之前，服务器会先检查查询缓存，如果能够在其中找到对应的查询，服务器会直接返回结果，不需要再执行查询解析、优化和执行整个过程。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;二、并发控制&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;1.读写锁&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　比如有一张表，多个线程对这张表进行操作，加入刚好有一个线程在对一条数据更改，另一个线程也对其进行读取操作，那么进行读操作的这个线程可能读到的数据是不正确的，怎么解决这个问题呢？这时就用到了并发控制，主要是通过两种锁来控制的：读锁（共享锁）、写锁（排他锁）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　读锁是共享的，或者说是相互不阻塞的，即对个线程读取同一个资源，互不干扰；写锁是排他的，也就是说只要有一个线程对其进行写操作，那么其他的读和写线程将都会被阻塞。只有这样才能保证才能保证在给定的时间内只有一个线程在写操作，并防止其他线程读取正在写入的数据。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;2.锁粒度&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　最理想的情况是：需要写入哪个对象就锁定哪个对象。尽量只锁定需要修改的部分数据，而不是所有的数据。在任何时候，在给定的资源上，锁定的数据越少，系统的并发程度越高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是还有一个问题，加锁也会消耗资源，锁的各种操作：获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销，如果花费大量的时间来管理锁，而不是存取数据，那么系统的性能将会受到影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所谓的锁策略，就是在锁的开销和数据的完全性之间寻求平衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　表锁是MySQL中最基本的锁策略，并且是开销最小的策略（意味着并发程度低），但是表锁的缺点是在执行插入、删除、更改的操作时会使其他的用户线程阻塞。（注意：读锁之间是互不影响的）。另外写锁比读锁的优先级更高。写锁可以插到读锁中，但是读锁却不能插到写锁中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　行级锁：可以最大程度的支持并发处理（但是同时也带来了更大的锁开销）最典型的就是InnoDB存储引擎，行级锁只在存储引擎层实现。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;三、事务&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　最重要的事务终于到啦，事务即ACID（原子性、一致性、隔离性、持久性），在开始讲这四个特性之前我们先举一个最经典的例子：某账户存了1000元，现在用户A要往里面存200元、用户B要往出来取200元。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　原子性：一个事务必须被视为不可分割的最小工作单元，整个事务的所有操作要么全部提交完成，要么全部失败回滚，对于一个事务来说不可能执行其中的一部分。那上面例子来说：A要从账户取200需要执行以下四步操作：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; START &lt;span&gt;TRANSACTION&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;金额&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;FROM&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;账户表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;WHERE&lt;/span&gt;   &lt;span&gt;user_id&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1221221&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;账户表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;SET&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;金额&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;=&lt;/span&gt;  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;金额&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;200&lt;/span&gt;  &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;user_id&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1221221&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;COMMIT&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　解释：1.开启事务 ，2.查询账户有没有200元 ，3.扣除金额  ， 4.提交事务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　原子性就是指这四步完整执行不可再分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;一致性：&lt;/strong&gt;数据库从一个一致性的状态转换为另一个一致性的状态。就上面那个例子：如果在第三步执行完系统崩溃，账户中的金额还是1000元，因为一个事务没有执行完，在最终提交前是不会保存到数据库中的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;隔离性：&lt;/strong&gt;通常来讲一个事务在最终提交前，对其他事务是不可见的。就之前例子来说，第三步执行完，在没提交之前B账户来看到的金额仍然是1000元。是不可见的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;持久性：&lt;/strong&gt;事务一旦提交其所做的修改就会永远的被保存到数据库中，即使系统崩溃也不会丢失。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一个实现了事务的数据库相比于没有实现事务的数据库它需要更强的CPU处理能力、更大的内存、更多的磁盘空间。对于有些不需要事务的查询类应用选择一个非事务型的存储引擎可以获得更高的性能。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;1.隔离级别&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一共有四种隔离级别先简单做个介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;A.READ  UNCOMMIT（读未提交）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在这个隔离级别中，事务的修改，即使没有提交，对其他的事务也是可见的。事务可以读到未提交的数据，这些数据也被称为脏读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;B.READ  COMMIT（读已提交）（不可重复读）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　大多数数据库系统的默认隔离级别都是读已提交，但是MySQL不是，MySQL的默认隔离级别是可重复读。简单说就是一个事务开始时只能 “看见” 已经提交的事务所做的修改，换句话说，一个事务从开始到提交这个过程中所做的所有修改对其他事务是不可见的。这个级别对于两次执行相同情况的查询，可能会得到不同的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;C.REPEATABLE  READ（可重复读）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该级别保证了在同一个事务中多次读取同样的记录结果是一致的，但是它无法解决幻读的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;D.SERIALIZABLE（可串行化）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　是最高的隔离级别。它通过强制事务串行化执行，避免了所有问题，他会在读取的每一行记录上面都加锁，所以可能导致大量的超时与锁等待的问题，并发低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;讲几个概念：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.脏读：A用户把钱取出没有提交，B用户读取到修改了的金额为800，过一会A因为异常事务回滚，B再次读取发现值变为1000，两次不一样，第一次读到的是脏数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.不可以重复读：B读到数据为1000后，A修改数据为800并且提交，B再次读取为800，两次数据不一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.幻读：与不可重复读类似：B读到一个表里有10条记录，A插了一条并提交，B再次读为11条，感觉发生幻觉一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;不同隔离级别引发的问题：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1398504/202012/1398504-20201228001945239-1135679776.png&quot; alt=&quot;&quot; width=&quot;852&quot; height=&quot;306&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt; &lt;span&gt;2.死锁&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;多个事务在同一资源上相互占有，并且请求锁定对方占用的资源，从而导致恶性循环的现象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;数据库系统实现了各种死锁检测和死锁超时机制。InnoDB目前处理死锁的方法是：将持有最少行排它锁的事务进行回滚。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;3.事务日志&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;事务日志可以提高事务的效率，使用事务日志时：存储引擎在修改表数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，不用每次将修改的数据本身持久到硬盘。事务日志采用追加的方式，写日志的操作是磁盘上的一小块区域内的顺序I/O.事务日志持久后，内存中被修改的数据将在后台慢慢刷回到磁盘。所以一共需要两次磁盘I/O:一次写日志磁盘I/O,一次刷回磁盘I/O.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4.MySQL中的事务&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1.自动提交：MySQL默认采用自动提交的方式。比如每个查询就是一个事务执行完自动提交。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2.非事务型存储引擎如：MyISAM无回滚功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;四、多版本并发控制MVCC&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　可以认为MVCC是行级锁的一个变种，它在很多情况下避免了加锁，MVCC的实现是通过保存数据在某个时间的快照来实现的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的，这两个列一个保存了行的创建时间，一个保存了行的删除时间，存储的不是真正时间而是系统的版本号。每个新事物开始系统版本号自动递增。事物开始时刻的版本号作为事物的版本号，用来和查询到的每行记录版本号进行比较。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　MVCC只在可重复读和读已提交两个隔离级别下工作，其他两个级别都和MVCC不兼容。因为读未提交总是读取最新的数据行，不符合当前事物版本的数据行。可串行化会对所有行加锁。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　我的理解其实MVCC就跟CAS是一个原理，就是一个比较并交换的过程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 27 Dec 2020 16:50:00 +0000</pubDate>
<dc:creator>Tom-shushu</dc:creator>
<og:description>一、MySQL逻辑架构 第一层的服务不是MySQL独有的，大多数是基于网络的客户端/服务端的工具，如连接处理、授权认证、安全等等。 第二层就是MySQL的核心功能，包括查询解析、分析、优化、缓存以及所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tom-shushu/p/14199731.html</dc:identifier>
</item>
<item>
<title>【Tomcat】手写迷你版Tomcat - 邓晓晖</title>
<link>http://www.cnblogs.com/isdxh/p/14199711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/isdxh/p/14199711.html</guid>
<description>&lt;h2 id=&quot;源码地址&quot;&gt;源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CoderXiaohui/mini-tomcat&quot; target=&quot;_blank&quot;&gt;https://github.com/CoderXiaohui/mini-tomcat&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一，分析&quot;&gt;一，分析&lt;/h2&gt;
&lt;h3 id=&quot;mini版tomcat需要实现的功能&quot;&gt;Mini版Tomcat需要实现的功能&lt;/h3&gt;
&lt;p&gt;作为一个服务器软件提供服务（通过浏览器客户端发送Http请求，它可以接收到请求进行处理，处理之后的结果返回浏览器客户端）。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提供服务，接收请求（socket通信）&lt;/li&gt;
&lt;li&gt;请求信息封装成Request对象，封装响应信息Response对象&lt;/li&gt;
&lt;li&gt;客户端请求资源，资源分为静态资源（html）和动态资源（servlet）&lt;/li&gt;
&lt;li&gt;资源返回给客户端浏览器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;*&lt;strong&gt;Tomcat的入口就是一个main函数&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二，开发准备工作&quot;&gt;二，开发——准备工作&lt;/h2&gt;
&lt;h3 id=&quot;21-新建maven工程&quot;&gt;2.1 新建Maven工程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201227160427940.png&quot; alt=&quot;image-20201227160427940&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201227161023307.png&quot; alt=&quot;image-20201227161023307&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-定义编译级别&quot;&gt;2.2 定义编译级别&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;com.dxh&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;MiniCat&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;source&amp;gt;11&amp;lt;/source&amp;gt;
                    &amp;lt;target&amp;gt;11&amp;lt;/target&amp;gt;
                    &amp;lt;encoding&amp;gt;utf-8&amp;lt;/encoding&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;23-新建主类编写启动入口和端口&quot;&gt;2.3 新建主类编写启动入口和端口&lt;/h3&gt;
&lt;p&gt;这里我们把socket监听的端口号定义在主类中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package server;

/**
 * Minicat的主类
 */
public class Bootstrap {
    /**
     * 定义Socket监听的端口号
     */
    private int port = 8080;

    public int getPort() {
        return port;
    }

    public void setPort(int port) {
        this.port = port;
    }

    /**
     * Minicat的启动入口
     * @param args
     */
    public static void main(String[] args) {
        
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三，开发10版本&quot;&gt;三，开发——1.0版本&lt;/h2&gt;
&lt;p&gt;循序渐进，一点一点的完善，1.0版本我们需要的需求是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;浏览器请求http://localhost:8080，返回一个固定的字符串到页面“Hello Minicat”&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;31-编写start方法以及遇到的问题&quot;&gt;3.1 编写start方法以及遇到的问题&lt;/h3&gt;
&lt;p&gt;start方法主要就是监听上面配置的端口，然后得到其输出流，最后写出。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * MiniCat启动需要初始化展开的一些操作
 */
public void start() throws IOException {
    /*
       完成Minicat 1.0版本
       需求：浏览器请求http://localhost:8080，返回一个固定的字符串到页面“Hello Minicat！”
     */
    ServerSocket serverSocket = new ServerSocket(port);
    System.out.println(&quot;========&amp;gt;&amp;gt;Minicat start on port：&quot;+port);

    while(true){
        Socket socket = serverSocket.accept();
        //有了socket，接收到请求,获取输出流
        OutputStream outputStream = socket.getOutputStream();
        outputStream.write(&quot;Hello Minicat！&quot;.getBytes());
        socket.close();
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;完整的代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
/**
 * Minicat的主类
 */
public class Bootstrap {
    /**
     * 定义Socket监听的端口号
     */
    private int port = 8080;

    public int getPort() {
        return port;
    }

    public void setPort(int port) {
        this.port = port;
    }

    /**
     * Minicat的启动入口
     * @param args
     */
    public static void main(String[] args) {
        Bootstrap bootstrap = new Bootstrap();
        try {
            //启动Minicat
            bootstrap.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * MiniCat启动需要初始化展开的一些操作
     */
    public void start() throws IOException {
        ServerSocket serverSocket = new ServerSocket(port);
        System.out.println(&quot;========&amp;gt;&amp;gt;Minicat start on port：&quot;+port);

        while(true){
            Socket socket = serverSocket.accept();
            //有了socket，接收到请求,获取输出流
            OutputStream outputStream = socket.getOutputStream();
            outputStream.write(&quot;Hello Minicat！&quot;.getBytes());
            socket.close();
        }
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;此时，如果启动项目，从浏览器中输入http://localhost:8080/，能够正常接收到请求吗？&lt;/p&gt;
&lt;p&gt;不能！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;问题分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动项目，从浏览器中输入http://localhost:8080/，可看到返回结果如下图：&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201227165334660.png&quot; alt=&quot;image-20201227165334660&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为Http协议是一个应用层协议，其规定了请求头、请求体、响应同样，如果没有这些东西的话浏览器无法正常显示&lt;/strong&gt;。代码中直接把”Hello Minicat！“直接输出了，&lt;/p&gt;
&lt;h3 id=&quot;32-解决问题，修改代码：&quot;&gt;3.2 解决问题，修改代码：&lt;/h3&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;新建一个工具类，主要提供响应头信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package server;

/**
 * http协议工具类，主要提供响应头信息，这里我们只提供200和404的情况
 */
public class HttpProtocolUtil {

    /**
     *  为响应码200提供请求头信息
     */
    public static String getHttpHeader200(long contentLength){
        return &quot;HTTP/1.1 200 OK \n&quot; +
                &quot;Content-Type: text/html \n&quot; +
                &quot;Content-Length: &quot;+contentLength +&quot;\n&quot;+
                &quot;\r\n&quot;;
    }


    /**
     *  为响应码404提供请求头信息(也包含了数据内容)
     */
    public static String getHttpHeader404(){
        String str404=&quot;&amp;lt;h1&amp;gt;404 not found&amp;lt;/h1&amp;gt;&quot;;
        return &quot;HTTP/1.1 404 NOT Found \n&quot; +
                &quot;Content-Type: text/html \n&quot; +
                &quot;Content-Length: &quot;+str404.getBytes().length +&quot;\n&quot;+
                &quot;\r\n&quot; + str404;
    }

}

&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;修改start方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public void start() throws IOException {

        ServerSocket serverSocket = new ServerSocket(port);
        System.out.println(&quot;========&amp;gt;&amp;gt;Minicat start on port：&quot;+port);

        while(true){
            Socket socket = serverSocket.accept();
           
            OutputStream outputStream = socket.getOutputStream();
            String data = &quot;Hello Minicat!&quot;;
            String responseText = HttpProtocolUtil.getHttpHeader200(data.getBytes().length)+data;
            outputStream.write(responseText.getBytes());
            socket.close();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问~&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201227172649749.png&quot; alt=&quot;image-20201227172649749&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;成功。&lt;/p&gt;
&lt;h2 id=&quot;四，开发20版本&quot;&gt;四，开发——2.0版本&lt;/h2&gt;
&lt;p&gt;需求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;封装Request和Response对象&lt;/li&gt;
&lt;li&gt;返回html静态资源文件&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;41-封装前准备&quot;&gt;4.1 封装前准备&lt;/h3&gt;
&lt;p&gt;新建一个类，Bootstrap2 （为了方便与1.0版本做对比）。获得输入流，并打印出来看看。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package server;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * Minicat的主类
 */
public class Bootstrap2 {
    /**
     * 定义Socket监听的端口号
     */
    private int port = 8080;

    public int getPort() {
        return port;
    }

    public void setPort(int port) {
        this.port = port;
    }

    /**
     * Minicat的启动入口
     * @param args
     */
    public static void main(String[] args) {
        Bootstrap2 bootstrap = new Bootstrap2();
        try {
            //启动Minicat
            bootstrap.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * MiniCat启动需要初始化展开的一些操作
     */
    public void start() throws IOException {
        ServerSocket serverSocket = new ServerSocket(port);
        System.out.println(&quot;========&amp;gt;&amp;gt;Minicat start on port：&quot;+port);

        while (true){
            Socket socket = serverSocket.accept();
            InputStream inputStream = socket.getInputStream();
            //从输入流中获取请求信息
            int count = 0 ;
            while (count==0){
                count = inputStream.available();
            }
            byte[] bytes = new byte[count];
            inputStream.read(bytes);
            System.out.println(&quot;请求信息=====&amp;gt;&amp;gt;&quot;+new String(bytes));
            socket.close();
        }

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印出来的信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201227191058136.png&quot; alt=&quot;image-20201227191058136&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们需要得到的是 请求方式（GET） 和 url （/） ，接下来封装Request的时候也是只封装这两个属性&lt;/p&gt;
&lt;h3 id=&quot;42封装request、response对象&quot;&gt;4.2封装Request、Response对象&lt;/h3&gt;
&lt;h4 id=&quot;421-封装request&quot;&gt;4.2.1 封装Request&lt;/h4&gt;
&lt;p&gt;只封装两个参数——method和url&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;新建Request类&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;该类有三个属性（&lt;code&gt;String method&lt;/code&gt;、&lt;code&gt;String url&lt;/code&gt;、&lt;code&gt;InputStream inputStream&lt;/code&gt;）&lt;br/&gt;method和url都是从input流中解析出来的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GET SET方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;编写有参构造&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 构造器 输入流传入
 */
public Request(InputStream inputStream) throws IOException {
    this.inputStream = inputStream;
    //从输入流中获取请求信息
    int count = 0 ;
    while (count==0){
        count = inputStream.available();
    }
    byte[] bytes = new byte[count];
    inputStream.read(bytes);
    String inputsStr = new String(bytes);
    //获取第一行数据
    String firstLineStr = inputsStr.split(&quot;\\n&quot;)[0];  //GET / HTTP/1.1
    String[] strings = firstLineStr.split(&quot; &quot;);
    //把解析出来的数据赋值
    this.method=strings[0];
    this.url= strings[1];

    System.out.println(&quot;method=====&amp;gt;&amp;gt;&quot;+method);
    System.out.println(&quot;url=====&amp;gt;&amp;gt;&quot;+url);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无参构造&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;完整的Request.java&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package server;

import java.io.IOException;
import java.io.InputStream;

/**
 * 把我们用到的请求信息，封装成Response对象 （根据inputSteam输入流封装）
 */
public class Request {
    /**
     * 请求方式 例如：GET/POST
     */
    private String method;

    /**
     * / ， /index.html
     */
    private String url;

    /**
     * 其他的属性都是通过inputStream解析出来的。
     */
    private InputStream inputStream;

    /**
     * 构造器 输入流传入
     */
    public Request(InputStream inputStream) throws IOException {
        this.inputStream = inputStream;
        //从输入流中获取请求信息
        int count = 0 ;
        while (count==0){
            count = inputStream.available();
        }
        byte[] bytes = new byte[count];
        inputStream.read(bytes);
        String inputsStr = new String(bytes);
        //获取第一行数据
        String firstLineStr = inputsStr.split(&quot;\\n&quot;)[0];  //GET / HTTP/1.1
        String[] strings = firstLineStr.split(&quot; &quot;);
        this.method=strings[0];
        this.url= strings[1];

        System.out.println(&quot;method=====&amp;gt;&amp;gt;&quot;+method);
        System.out.println(&quot;url=====&amp;gt;&amp;gt;&quot;+url);
    }

    public Request() {
    }

    public String getMethod() {
        return method;
    }

    public void setMethod(String method) {
        this.method = method;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }
a
    public InputStream getInputStream() {
        return inputStream;
    }

    public void setInputStream(InputStream inputStream) {
        this.inputStream = inputStream;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;422-封装response&quot;&gt;4.2.2 封装Response&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package server;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;

/**
 * 封装Response对象，需要依赖于OutputStream
 *
 */
public class Response{
    private OutputStream outputStream;

    public Response(OutputStream outputStream) {
        this.outputStream = outputStream;
    }

    public Response() {
    }

    /**
     * @param path 指的就是 Request中的url ，随后要根据url来获取到静态资源的绝对路径，进一步根据绝对路径读取该静态资源文件，最终通过输出流输出
     */
    public void outputHtml(String path) throws IOException {
        //获取静态资源的绝对路径
        String absoluteResourcePath = StaticResourceUtil.getAbsolutePath(path);

        //输出静态资源文件
        File file = new File(absoluteResourcePath);
        if (file.exists() &amp;amp;&amp;amp; file.isFile()){
            //读取静态资源文件，输出静态资源
            StaticResourceUtil.outputStaticResource(new FileInputStream(file),outputStream);
        }else{
            //输出404
            output(HttpProtocolUtil.getHttpHeader404());
        }
    }

    //使用输出流输出指定字符串
    public void output(String context) throws IOException {
        outputStream.write(context.getBytes());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.0版本只考虑输出静态资源文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们来分析一下&lt;code&gt;outputHtml(String path)&lt;/code&gt;这个方法&lt;/p&gt;
&lt;p&gt;首先，path就指 Request中的url，我们要用这个url找到该资源的绝对路径：&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;根据path，获取静态资源的绝对路径&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static String getAbsolutePath(String path){
    String absolutePath = StaticResourceUtil.class.getResource(&quot;/&quot;).getPath();
    return absolutePath.replaceAll(&quot;\\\\&quot;,&quot;/&quot;)+path;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;判断静态资源是否存在&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;不存在&lt;/strong&gt;：输出404&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;存在&lt;/strong&gt;：读取静态资源文件，输出静态资源&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void outputStaticResource(InputStream inputStream, OutputStream outputStream) throws IOException {
        int count = 0 ;
        while (count==0){
            count=inputStream.available();
        }
        //静态资源长度
        int resourceSize = count;
        //输出Http请求头 , 然后再输出具体的内容
        outputStream.write(HttpProtocolUtil.getHttpHeader200(resourceSize).getBytes());

        //读取内容输出
        long written = 0;   //已经读取的内容长度
        int byteSize = 1024; //计划每次缓冲的长度
        byte[] bytes = new byte[byteSize];

        while (written&amp;lt;resourceSize){
            if (written+byteSize &amp;gt;resourceSize){    //剩余未读取大小不足一个1024长度，那就按照真实长度处理
                byteSize= (int)(resourceSize-written);  //剩余的文件内容长度
                bytes=new byte[byteSize];
            }
            inputStream.read(bytes);
            outputStream.write(bytes);
            outputStream.flush();

            written+=byteSize;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;把上述的第一步和第三步的方法封装到一个类中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package server;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class StaticResourceUtil {

    /**
     * 获取静态资源方法的绝对路径
     */
    public static String getAbsolutePath(String path){
        String absolutePath = StaticResourceUtil.class.getResource(&quot;/&quot;).getPath();
        return absolutePath.replaceAll(&quot;\\\\&quot;,&quot;/&quot;)+path;
    }


    /**
     * 读取静态资源文件输入流，通过输出流输出
     */
    public static void outputStaticResource(InputStream inputStream, OutputStream outputStream) throws IOException {
        int count = 0 ;
        while (count==0){
            count=inputStream.available();
        }
        //静态资源长度
        int resourceSize = count;
        //输出Http请求头 , 然后再输出具体的内容
        outputStream.write(HttpProtocolUtil.getHttpHeader200(resourceSize).getBytes());

        //读取内容输出
        long written = 0;   //已经读取的内容长度
        int byteSize = 1024; //计划每次缓冲的长度
        byte[] bytes = new byte[byteSize];

        while (written&amp;lt;resourceSize){
            if (written+byteSize &amp;gt;resourceSize){    //剩余未读取大小不足一个1024长度，那就按照真实长度处理
                byteSize= (int)(resourceSize-written);  //剩余的文件内容长度
                bytes=new byte[byteSize];
            }
            inputStream.read(bytes);
            outputStream.write(bytes);
            outputStream.flush();

            written+=byteSize;
        }
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试：&quot;&gt;测试：&lt;/h3&gt;
&lt;ol readability=&quot;3.8377693282636&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;修改&lt;strong&gt;Bootstrap2.java&lt;/strong&gt;中的&lt;code&gt;start()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void start() throws IOException {
        ServerSocket serverSocket = new ServerSocket(port);
        System.out.println(&quot;========&amp;gt;&amp;gt;Minicat start on port：&quot;+port);

        while (true){
            Socket socket = serverSocket.accept();
            InputStream inputStream = socket.getInputStream();
            //封装Resuest对象和Response对象
            Request request = new Request(inputStream);
            Response response = new Response(socket.getOutputStream());
            response.outputHtml(request.getUrl());
            socket.close();
       }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在项目的resources文件夹新建&lt;code&gt;index.html&lt;/code&gt;文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Static resource &amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
Hello ~ Static resource
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行main方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.36&quot;&gt;
&lt;p&gt;浏览器输入：&lt;a href=&quot;http://localhost:8080/index.html&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/index.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果展现：&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201227205755188.png&quot; alt=&quot;image-20201227205755188&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;五，开发30版本&quot;&gt;五，开发——3.0版本&lt;/h2&gt;
&lt;p&gt;3.0版本就要定义Servlet了，大致分为以下几步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义servlet规范&lt;/li&gt;
&lt;li&gt;编写Servlet&lt;/li&gt;
&lt;li&gt;加载解析Servlet配置&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;51-定义servlet规范&quot;&gt;5.1 定义servlet规范&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Servlet {
    void init() throws Exception;
    void destroy() throws Exception;
    void service(Request request,Response response) throws Exception;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义一个抽象类，实现Servlet，并且增加两个抽象方法&lt;code&gt;doGet&lt;/code&gt; , &lt;code&gt;doPost&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class HttpServlet implements Servlet{

    public abstract void doGet(Request request,Response response);
    public abstract void doPost(Request request,Response response);


    @Override
    public void init() throws Exception {

    }

    @Override
    public void destroy() throws Exception {

    }

    @Override
    public void service(Request request, Response response) throws Exception {
        if (&quot;GET&quot;.equals(request.getMethod())){
            doGet(request, response);
        }else{
            doPost(request, response);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;52-编写servlet继承httpservlet&quot;&gt;5.2 编写Servlet继承HttpServlet&lt;/h3&gt;
&lt;p&gt;新建&lt;code&gt;DxhServlet.java&lt;/code&gt;，并继承&lt;code&gt;HttpServlet&lt;/code&gt;重写doGet和doPost方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package server;

import java.io.IOException;

public class DxhServlet extends HttpServlet{
    @Override
    public void doGet(Request request, Response response) {
        String content=&quot;&amp;lt;h1&amp;gt;DxhServlet get&amp;lt;/h1&amp;gt;&quot;;
        try {
            response.output(HttpProtocolUtil.getHttpHeader200(content.getBytes().length)+content);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void doPost(Request request, Response response) {
        String content=&quot;&amp;lt;h1&amp;gt;DxhServlet post&amp;lt;/h1&amp;gt;&quot;;
        try {
            response.output(HttpProtocolUtil.getHttpHeader200(content.getBytes().length)+content);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void init() throws Exception {
        super.init();
    }

    @Override
    public void destroy() throws Exception {
        super.destroy();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来要把&lt;code&gt;DxhServlet&lt;/code&gt;配置到一个配置文件中，当MiniCat启动时，加载进去。&lt;/p&gt;
&lt;h3 id=&quot;53-加载解析servlet配置&quot;&gt;5.3 加载解析Servlet配置&lt;/h3&gt;
&lt;h4 id=&quot;531-配置文件&quot;&gt;5.3.1 配置文件&lt;/h4&gt;
&lt;p&gt;在&lt;strong&gt;resources&lt;/strong&gt;目录下，新建&lt;code&gt;web.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;web-app&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;dxh&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;server.DxhServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;/servlet&amp;gt;

    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;dxh&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/dxh&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;标准的配置Servlet的标签。&lt;code&gt;servlet-class&lt;/code&gt;改成自己写的Servlet全限定类名，&lt;code&gt;url-pattern&lt;/code&gt;为&lt;code&gt;/dxh&lt;/code&gt;，一会请求http://localhost:8080/dxh，来访问这个servlet&lt;/p&gt;
&lt;h4 id=&quot;532-解析配置文件&quot;&gt;5.3.2 解析配置文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;复制一份Bootstrap2.java，命名为Bootstrap3.java&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;加载解析相关的配置 ，web.xml&lt;br/&gt;引入dom4j和jaxen的jar包&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;dom4j&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;dom4j&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.6.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;jaxen&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jaxen&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.1.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;在&lt;code&gt;Bootstrap3.java&lt;/code&gt;中增加一个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//用于下面存储url-pattern以及其对应的servlet-class的实例化对象
private Map&amp;lt;String,HttpServlet&amp;gt; servletMap = new HashMap&amp;lt;&amp;gt;();

private void loadServlet(){
    InputStream resourceAsStream = this.getClass().getClassLoader().getResourceAsStream(&quot;web.xml&quot;);
    SAXReader saxReader = new SAXReader();
    try {
        Document document = saxReader.read(resourceAsStream);
        //根元素
        Element rootElement = document.getRootElement();
        /**
         * 1, 找到所有的servlet标签，找到servlet-name和servlet-class
         * 2, 根据servlet-name找到&amp;lt;servlet-mapping&amp;gt;中与其匹配的&amp;lt;url-pattern&amp;gt;
         */
        List&amp;lt;Element&amp;gt; selectNodes = rootElement.selectNodes(&quot;//servlet&quot;);
        for (int i = 0; i &amp;lt; selectNodes.size(); i++) {
            Element element = selectNodes.get(i);
            /**
             * 1, 找到所有的servlet标签，找到servlet-name和servlet-class
             */
            //&amp;lt;servlet-name&amp;gt;dxh&amp;lt;/servlet-name&amp;gt;
            Element servletNameElement =(Element)element.selectSingleNode(&quot;servlet-name&quot;);
            String servletName = servletNameElement.getStringValue();
            //&amp;lt;servlet-class&amp;gt;server.DxhServlet&amp;lt;/servlet-class&amp;gt;
            Element servletClassElement =(Element)element.selectSingleNode(&quot;servlet-class&quot;);
            String servletClass = servletClassElement.getStringValue();
            /**
             * 2, 根据servlet-name找到&amp;lt;servlet-mapping&amp;gt;中与其匹配的&amp;lt;url-pattern&amp;gt;
             */
            //Xpath表达式：从/web-app/servlet-mapping下查询，查询出servlet-name=servletName的元素
            Element servletMapping =(Element)rootElement.selectSingleNode(&quot;/web-app/servlet-mapping[servlet-name='&quot; + servletName + &quot;']'&quot;);
            // /dxh
            String urlPattern = servletMapping.selectSingleNode(&quot;url-pattern&quot;).getStringValue();
            servletMap.put(urlPattern,(HttpServlet) Class.forName(servletClass).newInstance());
        }
    } catch (DocumentException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InstantiationException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的意思就是读取web.xml转换成Document，然后遍历根元素内中的&lt;strong&gt;servlet&lt;/strong&gt;标签（servlet是可以配置多个的），通过XPath表达式获得&lt;code&gt;servlet-name&lt;/code&gt;、&lt;code&gt;servlet-class&lt;/code&gt;，以及与其对应的&lt;code&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/code&gt;标签下的&lt;code&gt;url-pattern&lt;/code&gt;，然后存在Map中。注意，这里Map的&lt;strong&gt;Key是url-pattern&lt;/strong&gt;，&lt;strong&gt;Value是servlet-class的实例化对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;54-接收请求，处理请求改造&quot;&gt;5.4 接收请求，处理请求改造&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201227230820862.png&quot; alt=&quot;image-20201227230820862&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201227231617987.png&quot; alt=&quot;image-20201227231617987&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里进行了判断，判断&lt;code&gt;servletMap&lt;/code&gt;中是否存在url所对应的value，如果没有，当作静态资源访问，如果有，取出并调用service方法，在HttpServlet的service方法中已经做了根据request判断具体调用的是doGet还是doPost方法。&lt;/p&gt;
&lt;h3 id=&quot;测试：-1&quot;&gt;测试：&lt;/h3&gt;
&lt;p&gt;在浏览器中输入：&lt;br/&gt;&lt;a href=&quot;http://localhost:8080/index.html%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/index.html，可以访问静态资源&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201227231858786.png&quot; alt=&quot;image-20201227231858786&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入：&lt;a href=&quot;http://localhost:8080/dxh&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/dxh&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201227231925246.png&quot; alt=&quot;image-20201227231925246&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以访问【5.2中编写的Servlet】动态资源~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;到此位置，一个简单的Tomcat Demo已经完成。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;六，优化多线程改造（不使用线程池）&quot;&gt;六，优化——多线程改造（不使用线程池）&lt;/h2&gt;
&lt;h3 id=&quot;61-问题分析&quot;&gt;6.1 问题分析&lt;/h3&gt;
&lt;p&gt;在现有的代码中，接收请求这部分它是一个IO模型——BIO，阻塞IO。&lt;/p&gt;
&lt;p&gt;它存在一个问题，当一个请求还未处理完成时，再次访问，会出现阻塞的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以在&lt;code&gt;DxhServlet&lt;/code&gt;的&lt;code&gt;doGet&lt;/code&gt;方法中加入&lt;code&gt;Thread.sleep(10000);&lt;/code&gt;然后访问&lt;code&gt;http://localhost:8080/dxh&lt;/code&gt;和&lt;code&gt;http://localhost:8080/index.html&lt;/code&gt;做个测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么我们可以使用多线程对其进行改造。&lt;br/&gt;&lt;img src=&quot;https://typora-files.oss-cn-beijing.aliyuncs.com/file/image-20201227233057004.png&quot; alt=&quot;image-20201227233057004&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把上述代码放到一个新的线程中处理。&lt;/p&gt;
&lt;h3 id=&quot;62-复制bootstrap3&quot;&gt;6.2 复制Bootstrap3&lt;/h3&gt;
&lt;p&gt;复制Bootstrap3，命名为Bootstrap4。把start()方法中上图的部分（包括&lt;code&gt;socket.close()&lt;/code&gt;）&lt;strong&gt;剪切&lt;/strong&gt;到下面的&lt;strong&gt;线程处理类的run方法&lt;/strong&gt;中：&lt;/p&gt;
&lt;h3 id=&quot;63-定义一个线程处理类&quot;&gt;6.3 定义一个线程处理类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package server;

import java.io.InputStream;
import java.net.Socket;
import java.util.Map;

/**
 * 线程处理类
 */
public class RequestProcessor extends Thread{
    private  Socket socket;
    private Map&amp;lt;String,HttpServlet&amp;gt; servletMap;

    public RequestProcessor(Socket socket, Map&amp;lt;String, HttpServlet&amp;gt; servletMap) {
        this.socket = socket;
        this.servletMap = servletMap;
    }

    @Override
    public void run() {
        try{
            InputStream inputStream = socket.getInputStream();
            //封装Resuest对象和Response对象
            Request request = new Request(inputStream);
            Response response = new Response(socket.getOutputStream());
            String url = request.getUrl();
            //静态资源处理
            if (servletMap.get(url)==null){
                response.outputHtml(request.getUrl());
            }else{
                //动态资源处理
                HttpServlet httpServlet = servletMap.get(url);
                httpServlet.service(request,response);
            }
            socket.close();
        }catch (Exception e){

        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;64-修改bootstrap4的start方法&quot;&gt;6.4 修改Bootstrap4的start()方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void start() throws Exception {
    //加载解析相关的配置 ，web.xml，把配置的servlet存入servletMap中
    loadServlet();

    ServerSocket serverSocket = new ServerSocket(port);
    System.out.println(&quot;========&amp;gt;&amp;gt;Minicat start on port：&quot;+port);
    /**
     * 可以请求动态资源
     */
    while (true){
        Socket socket = serverSocket.accept();
        //使用多线程处理
        RequestProcessor requestProcessor = new RequestProcessor(socket,servletMap);
        requestProcessor.start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次做6.1章节的测试， OK 没有问题了。&lt;/p&gt;
&lt;h2 id=&quot;七，优化多线程改造（使用线程池）&quot;&gt;七，优化——多线程改造（使用线程池）&lt;/h2&gt;
&lt;p&gt;这一步，我们使用线程池进行改造。&lt;/p&gt;
&lt;p&gt;复制Bootstrap4，命名为Bootstrap5。&lt;/p&gt;
&lt;p&gt;修改start()方法。线程池的使用不再赘述。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void start() throws Exception {
    //加载解析相关的配置 ，web.xml，把配置的servlet存入servletMap中
    loadServlet();

    /**
     * 定义线程池
     */
    //基本大小
    int corePoolSize = 10;
    //最大
    int maxPoolSize = 50;
    //如果线程空闲的话，超过多久进行销毁
    long keepAliveTime = 100L;
    //上面keepAliveTime的单位
    TimeUnit unit = TimeUnit.SECONDS;
    //请求队列
    BlockingQueue&amp;lt;Runnable&amp;gt; workerQueue = new ArrayBlockingQueue&amp;lt;&amp;gt;(50);
    //线程工厂，使用默认的即可
    ThreadFactory threadFactory = Executors.defaultThreadFactory();
    //拒绝策略，如果任务太多处理不过来了，如何拒绝
    RejectedExecutionHandler handler = new ThreadPoolExecutor.AbortPolicy();
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(corePoolSize
            ,maxPoolSize
            ,keepAliveTime
            ,unit
            ,workerQueue
            ,threadFactory
            ,handler);

    ServerSocket serverSocket = new ServerSocket(port);
    System.out.println(&quot;========&amp;gt;&amp;gt;Minicat start on port(多线程)：&quot;+port);
    /**
     * 可以请求动态资源
     */
    while (true){
        Socket socket = serverSocket.accept();
        RequestProcessor requestProcessor = new RequestProcessor(socket,servletMap);
        threadPoolExecutor.execute(requestProcessor);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK ，再次测试，成功~&lt;/p&gt;
&lt;p&gt;MINI版Tomcat到此完成。&lt;/p&gt;
&lt;h2 id=&quot;八，总结&quot;&gt;八，总结&lt;/h2&gt;
&lt;p&gt;总结一下编写一个MINI版本的Tomcat都需要做些什么：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义一个入口类，需要监听的端口号和入口方法——main方法&lt;/li&gt;
&lt;li&gt;定义servlet规范（接口），并实现它——HttpServlet&lt;/li&gt;
&lt;li&gt;编写http协议工具类，主要提供响应头信息&lt;/li&gt;
&lt;li&gt;在main方法中调用start()方法用于启动初始化和请求进来时的操作&lt;/li&gt;
&lt;li&gt;加载解析配置文件（web.xml）&lt;/li&gt;
&lt;li&gt;当请求进来时，解析inputStream，并封装为Request和Response对象。&lt;/li&gt;
&lt;li&gt;判断请求资源的方式（动态资源还是静态资源）&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 27 Dec 2020 16:36:00 +0000</pubDate>
<dc:creator>邓晓晖</dc:creator>
<og:description>源码地址 https://github.com/CoderXiaohui/mini-tomcat 一，分析 Mini版Tomcat需要实现的功能 作为一个服务器软件提供服务（通过浏览器客户端发送Htt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/isdxh/p/14199711.html</dc:identifier>
</item>
<item>
<title>小团队产品研发管理V0.0.1 - 叶鹏</title>
<link>http://www.cnblogs.com/jqbird/p/14199692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jqbird/p/14199692.html</guid>
<description>&lt;h2 id=&quot;序言&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;之前做研发的时候非常鄙视管理，觉得管理的那些人就知道搞政治，后来做了开发主管，以及到部门经理之后，管的人多了发现管理真是门大学问，真的应该每个人都要学习一些基本管理知识，特别是刚入社会的打工人。&lt;/p&gt;
&lt;p&gt;具体的管理理论就不在这篇文章里多说了，这篇文章的目的是针对最近的新组建的团队做了一些最最基本的管理规范，由于我本人又核心负责产品的管理工作，所以习惯性把管理规范也当做产品来做，当前版本就叫v0.0.1吧，之所以起了个这么小的版本号，是因为这个管理规范只有最基础的框架，在后续的管理过程中会持续迭代，补充里面的细节。&lt;/p&gt;
&lt;h2 id=&quot;1会议管理&quot;&gt;1.会议管理&lt;/h2&gt;
&lt;h3 id=&quot;月度会议&quot;&gt;月度会议&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;会议时间：最后一周，一般30~31号&lt;/li&gt;
&lt;li&gt;会议内容：上个月工作情况总结，下个月计划确认&lt;/li&gt;
&lt;li&gt;会议材料：下个月规划内容清单&lt;/li&gt;
&lt;li&gt;会议产出：下个月详细计划&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;每周例会&quot;&gt;每周例会&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;时间：星期一上午 9点半&lt;/li&gt;
&lt;li&gt;会议内容：上周的产出总结，本周计划&lt;/li&gt;
&lt;li&gt;会议材料：本周计划，上周产出物&lt;/li&gt;
&lt;li&gt;会议产出：到日和人的任务分解&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2产品管理&quot;&gt;2.产品管理&lt;/h2&gt;
&lt;h3 id=&quot;产品需求流程管理&quot;&gt;产品需求流程管理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/94489/202012/94489-20201227230248849-1443534288.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;产品版本管理&quot;&gt;产品版本管理&lt;/h3&gt;
&lt;h4 id=&quot;版本的目标&quot;&gt;版本的目标&lt;/h4&gt;
&lt;p&gt;每个版本需要有明确的目标，这个目标不是来自产品经理的单方面猜想，而是需要结合市场部门的需求制定当前产品的版本所满足的市场目标，在版本管理时候不仅目标要明确，范围也要明确，只有确定了需求的目标和范围产品和研发人员才知道大概版本是什么计划时间点发布。&lt;/p&gt;
&lt;h4 id=&quot;产品版本规范&quot;&gt;产品版本规范&lt;/h4&gt;
&lt;h5 id=&quot;版本号管理&quot;&gt;版本号管理&lt;/h5&gt;
&lt;p&gt;标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -&amp;gt; 1.10.0 -&amp;gt; 1.11.0&lt;/p&gt;
&lt;p&gt;版本格式：主版本号.次版本号.修订号，版本号递增规则如下：&lt;br/&gt;主版本号：大的版本升级，已经不兼容当前版本了（包括样式、底层功能等），&lt;br/&gt;次版本号：当你做了向下兼容的功能性新增，例如新增了一个模块，&lt;br/&gt;修订号：当你做了向下兼容的问题修正，一些小的问题改善，bug修正。&lt;br/&gt;先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。&lt;/p&gt;
&lt;h2 id=&quot;2技术管理&quot;&gt;2.技术管理&lt;/h2&gt;
&lt;h3 id=&quot;技术选型&quot;&gt;技术选型&lt;/h3&gt;
&lt;p&gt;小公司小团队一个合格的CTO需要做好技术选型其实并不难，很多难不是难在技术上面，而是难在脸面上，技术选型一定不是追求技术的时尚程度，也不是技术的性能，而是目前公司人力资源是否擅长的，招聘人力成本上，因为很多小公司很难活到技术架构需要微服务，分布式这样的普适性面试都会问的问题要求。&lt;/p&gt;
&lt;p&gt;案例：一开始的技术选型，我们就是最普通的java，springboot框架+一个mysql，前端vue &amp;amp; element ui， redis？微服务？高可用？这些都没有，因为系统在很长一段时间内每天的访问量不超过1000人，技术的前期就是如何最小的成本把业务跑起来，后面再持续迭代优化，需要什么再加什么。&lt;/p&gt;
&lt;h2 id=&quot;参考引用&quot;&gt;参考引用&lt;/h2&gt;
&lt;h3 id=&quot;关于作者&quot;&gt;关于作者&lt;/h3&gt;
&lt;p&gt;作为曾经的程序员，现在的产品经理，有时候狠起来自己给自己提需求的，曾经作为程序员我是快乐的，现在作为产品经理我也是快乐的，偶尔撸撸代码陶冶情操，不忘初心，通过技术和产品不去改变世界，只是表达点什么，微信公众号 &lt;code&gt;产品经理与狗&lt;/code&gt;，主要写一些产品、技术、管理等文章，欢迎关注。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/94489/202012/94489-20201228002057682-1840514130.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 27 Dec 2020 16:22:00 +0000</pubDate>
<dc:creator>叶鹏</dc:creator>
<og:description>序言 之前做研发的时候非常鄙视管理，觉得管理的那些人就知道搞政治，后来做了开发主管，以及到部门经理之后，管的人多了发现管理真是门大学问，真的应该每个人都要学习一些基本管理知识，特别是刚入社会的打工人。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jqbird/p/14199692.html</dc:identifier>
</item>
<item>
<title>公路项目建设可视化进度管理 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/14156109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/14156109.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202010/1496396-20201029171057187-937642774.gif&quot; class=&quot;desc_img&quot;/&gt;本文以福厦漳高铁为例，HT for Web 基于三维数字信息技术搭建出的一个高速铁路工程展示平台，为项目在策划、实施等各个阶段提供工程信息，实现工程信息互通，达到彻底消除信息孤岛的目的，确保了工程建设的高效性、准确性，达到项目增值最大化的目的。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;85.818826368985&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;20.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;福厦漳高铁是福建省继温福铁路之后建成的第二条快速铁路，也是中国中长期铁路网规划中&quot;四纵四横&quot;快速客运通道的&quot;一纵&quot;--东南沿海客运专线(杭深客运专线)的重要组成部分。福厦漳铁路北起福州南站，途经莆田、泉州至厦门和漳州。全线共设7座车站，全长297公里，是福建省首条设计时速350公里的快速铁路站，投资估算总额约505亿元。2017年9月动工，计划2022年建成通车。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2020年12月，国新办发布《中国交通的可持续发展》白皮书。从“走得了”到“走得好”，中国正在从交通大国向交通强国迈进。 &lt;/p&gt;

&lt;p&gt;新基建项目的开展将聚焦于城市轨道交通和城际高速铁路，新一代智能化高速铁路系统将广泛运用云计算、大数据、物联网、移动互联、北斗导航、GIS 和 BIM 等新技术。我国已成为高铁运营里程最长的国家，但勘察设计、建设、运营管理所依赖的媒介还主要以二维图为主。将管理手段由二维提升为三维，并在三维环境下实现多源异构海量数据的综合展示与分析，将在大规模的高速铁路勘察设计、建设管理与运营维护中发挥巨大的支持与推动作用。铁路作为交通建设枢纽连接着城市间的距离，对人们的生活、出行便捷有着非常重要的意义。&lt;/p&gt;

&lt;p&gt;本文以福厦漳高铁为例，&lt;strong&gt;HT for Web&lt;/strong&gt; 基于三维数字信息技术搭建出的一个高速铁路工程展示平台，为项目在策划、实施等各个阶段提供工程信息，实现工程信息互通，达到彻底消除信息孤岛的目的，确保了工程建设的高效性、准确性，达到项目增值最大化的目的。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;界面简介及效果预览&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;载入动画：界面由远及近展示了完整的福建铁路线路图；90°旋转的科技环大大地提升了渲染效果；随着画面的加载完毕，我们也可以清楚的看到福建省内的各条铁路，以及在每条线路上的各个站点一目了然。&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202010/1496396-20201029171057187-937642774.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt; 两侧为2D面板，左边是具有标注功能的按钮，下方输入框中可展示标注目标的地理位置信息。右侧为福厦漳高铁信息及沿线各个站点的在建信息。&lt;/p&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;系统分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;在高铁建设中，采用数字信息化技术就是将施工全周期的所有信息建设可参化数字模型，同时施工方案模拟优化、施工管理过程系统协调统一等一系列功能，改善在传统项目管理过程无法实现的这些弊端，是各参见单位、参建者均能高效地协同沟通，为高速铁路实现“高标准、高质量、高效率、零误差”的目标，提供了新的数字化管理模式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、完成进度展示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在展示平台上，我们应用 HT for Web 的数据化建模模拟呈现了福厦漳高铁施工线路图，通过平台可以直观的了解到高铁当前的完成进度。&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202011/1496396-20201120154447970-1035378073.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2、施工点位标注功能&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;界面左上角的起点、隧道、终点、桥梁和路线五个施工目标按钮可以灵活使用，工程人员可以根据需求将工程点目标摆放在施工点位上。&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202011/1496396-20201120154529881-1720026557.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;10&quot;&gt;&lt;strong&gt;&lt;strong&gt;3、&lt;/strong&gt;工程点的经纬度查询功能&lt;/strong&gt;
&lt;p&gt;工程人员可以通过点击地图上的工程点来获取相应的名称、编号和经纬度信息；同样的，在输入框中输入精确的经纬度信息也可以在地图中找到相应的工程点。这个功能省去了复杂的换算工作，并且极大的提高了工程人员的工作效率，同时也给施工人员明确的施工目标，确保施工目标的准确度与提高施工质量。&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202011/1496396-20201120154607399-209498222.gif&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4、每个站点建设情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在界面右上角，我们可以清晰地看到福厦漳高铁的全线长度、设计时速、站点数以及每个站点的建设情况。我们可以看到，3D可视化改变了传统依靠二维图纸和报表为主的管理模式。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202010/1496396-20201029171212787-810064369.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;23.700217627856&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;实现价值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;29&quot;&gt;
&lt;p&gt;围绕人员、机械、物料、方法、环境等现场施工的关键要素，在高铁建设过程中应用3D可视化技术，不仅能够提升工程施工现场作业工作效率，并且可以实时监控工程进度。该项目拓宽了可视化模型的应用空间及应用价值：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.工程项目信息管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过BIM、GIS技术、云计算、大数据、物联网、移动应用和智能应用等先进技术的综合应用，让施工现场感知更透彻、互通互联更全面、智能化更深入，大大提升现场作业人员的工作效率。&lt;/p&gt;
&lt;p&gt;而 HT 的轻量化方式在与传统的 GIS 和 BIM 技术上有了全新的改变：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HT的轻量化、低成本，使企业不再需要购置笨重昂贵的 GIS 和 BIM 软件；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;起点低、效果好，传统 Web 开发人员即可上手，借力 HT 强大的 3D 渲染效果既可制作出高仿真道路场景&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;跨平台性，任何桌面和移动终端都可以打开，方便现场运维人员直接手机进行现场查看、编辑和管理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2.施工过程管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;便于施工管理人员更加准确地掌握构件设计和施工过程信息，做好过程控制工作，消除差错漏洞。实现精细化管理，最终达到减少施工成本、保障施工安全、保护环境等目的，实现保质保量完成施工任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、施工成本管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有助于实现施工现场“人、机、料、法、环”、各关键要素实时、全面、智能的监控和管理，有效支持了现场作业人员、项目管理者各层协同和管理工作，提高施工质量、安全、成本和进度的管理水平，减少浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、安全质量管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过3D可视化技术的应用，及时发现安全隐患，规范质量检查、检测行为，保障工程质量，实现质量溯源和劳务实名制管理，有效支撑主管部门对工程现场的质量、安全、进度、人员的监管。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;高速铁路建设是我国基础建设的标杆，备受社会各界的关注。要求在施工过程进行精细化管理是必然趋势。如今，高铁工程不再是过去仅能依靠数据与推测反映工况，基于铁路沿线高精度、海量、多源异构的地质地理信息和工程信息，集成信息技术与铁路专业技术，以三维可视化的形式，能够对高速铁路建设、运营全寿命周期的不同阶段提供综合仿真技术服务，最终实现“智慧高铁”的建设目标。&lt;/p&gt;



&lt;/div&gt;

&lt;/div&gt;</description>
<pubDate>Sun, 27 Dec 2020 15:57:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 福厦漳高铁是福建省继温福铁路之后建成的第二条快速铁路，也是中国中长期铁路网规划中&amp;quot;四纵四横&amp;quot;快速客运通道的&amp;quot;一纵&amp;quot;--东南沿海客运专线(杭深客运专线)的重</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/14156109.html</dc:identifier>
</item>
<item>
<title>火车售票软件系统的设计方案 - 刺猬绅士</title>
<link>http://www.cnblogs.com/csy379/p/14194691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csy379/p/14194691.html</guid>
<description>&lt;p&gt;一、项目介绍&lt;/p&gt;
&lt;p&gt;　　项目是模仿实现12306的部分功能，主要是售票系统的实现。这个系统的面向两类人，一是用户，二是系统管理员，其中系统设计主体部分是车次车票等信息的存储方式以及用户与系统的交互对后台数据的影响。车次信息与车票信息以一种什么样的形式相互关联尤其重要，用户做出自己的行为后（购买车票，查看车票订单信息，退票，改签等）怎么影响着后台数据是本次博客讨论的重点。&lt;/p&gt;
&lt;p&gt;二、系统架构&lt;/p&gt;
&lt;p&gt;　　本系统的设计架构是MVC架构，即Model-View-Controller（模型-视图-控制器），其中Model代表一个存储数据的对象及数据模型；View代表模型包含的数据的表达方式，一般表达为可视化的界面接口；Controller作用于模型和视图之上，控制数据流向模型对象，并在数据变化时更新视图。控制器可以使视图和模型分离开解耦合。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/2171721/202012/2171721-20201226214146757-443283363.png&quot; alt=&quot;&quot; width=&quot;395&quot; height=&quot;180&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在本项目中，Model保存一些数据模型，如用户的信息，用户的订单信息，系统中的车次信息，车次的对应车票信息，系统中的总的订单信息等等；控Controller则处理用户做出行为后后端数据信息的变更，还有前端数据信息可视化的变更；View则是软解界面的可视化，主要是面向用户设计的UI。可以看到这种架构的一个显著的好处就是前后端分离，数据模型和视图的关联是要通过控制器来进行，模型只要关心怎么让别人取值，怎么根据控制器的信息修改内部状态，不用关系它的数据怎么展现出来；视图也不用受限于数据模型，而且同一个数据模型可以对应多个视图，比如说用户的历史订单信息里会显示所有的订单，而当前订单信息里只显示当前生效的车票信息的等等。&lt;/p&gt;

&lt;p&gt;三、接口API&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr&gt;&lt;td&gt;接口名称&lt;/td&gt;
&lt;td&gt;接口功能&lt;/td&gt;
&lt;td&gt;传入参数&lt;/td&gt;
&lt;td&gt;返回信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;用户注册&lt;/td&gt;
&lt;td&gt; 为新用户注册一个账号&lt;/td&gt;
&lt;td&gt; 用户名，密码&lt;/td&gt;
&lt;td&gt; 注册成功或者失败的信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;用户登录&lt;/td&gt;
&lt;td&gt; 使已有账号的用户登录系统&lt;/td&gt;
&lt;td&gt;账号，密码，验证码 &lt;/td&gt;
&lt;td&gt;登录是否成功 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;用户个人信息&lt;/td&gt;
&lt;td&gt; 用户查看个人信息&lt;/td&gt;
&lt;td&gt; 无&lt;/td&gt;
&lt;td&gt;用户个人信息的数据结构指针&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;修改个人信息&lt;/td&gt;
&lt;td&gt; 修改个人信息　　　　　　　&lt;/td&gt;
&lt;td&gt;修改字段， 修改信息&lt;/td&gt;
&lt;td&gt;修改是否成功 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;查看订单&lt;/td&gt;
&lt;td&gt; 用户查看自己的订票信息　　&lt;/td&gt;
&lt;td&gt;无 &lt;/td&gt;
&lt;td&gt;用户订单信息数据结构指针&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;查看车次信息&lt;/td&gt;
&lt;td&gt; 查看车次信息&lt;/td&gt;
&lt;td&gt; 出发站，终点站&lt;/td&gt;
&lt;td&gt; 车次信息数据结构指针&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;查看车票信息&lt;/td&gt;
&lt;td&gt; 查看车票的相关信息　&lt;/td&gt;
&lt;td&gt;车次信息数据结构指针&lt;/td&gt;
&lt;td&gt;车票信息数据结构指针 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;订车票&lt;/td&gt;
&lt;td&gt; 用户购买车票&lt;/td&gt;
&lt;td&gt;车票信息数据结构 &lt;/td&gt;
&lt;td&gt;购买是否成功的信息 &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;退票&lt;/td&gt;
&lt;td&gt; 用户退票&lt;/td&gt;
&lt;td&gt;订单信息数据结构指针 &lt;/td&gt;
&lt;td&gt; 是否退票成功&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;改签&lt;/td&gt;
&lt;td&gt; 用户改签&lt;/td&gt;
&lt;td&gt;订单信息数据结构指针&lt;/td&gt;
&lt;td&gt; 是否改签成功&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;三、软件系统概念原型的不同视图&lt;/p&gt;
&lt;p&gt;1. 分解视图&lt;/p&gt;
&lt;p&gt;　　分解是构建软件架构模型的关键步骤，分解视图也是描述软件架构模型的关键视图，一般分解视图呈现为较为明晰的分解结构（breakdown structure）特点。分解视图用软件模块勾划出系统结构，往往会通过不同抽象层级的软件模块形成层次化的结构。&lt;/p&gt;
&lt;p&gt;                                            &lt;img src=&quot;https://img2020.cnblogs.com/blog/2171721/202012/2171721-20201227143707910-310239064.png&quot; alt=&quot;&quot; width=&quot;580&quot; height=&quot;330&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 2. 执行视图&lt;/p&gt;
&lt;p&gt;　　执行视图展示了系统运行时的时序结构特点，比如流程图、时序图等。执行视图中的每一个执行实体，一般称为组件（Component），都是不同于其他组件的执行实体。如果有相同或相似的执行实体那么就把它们合并成一个。执行实体可以最终分解到软件的基本元素和软件的基本结构，因而与软件代码具有比较直接的映射关系。在设计与实现过程中，我们一般将执行视图转换为伪代码之后，再进一步转换为实现代码。&lt;/p&gt;
&lt;p&gt;                                            &lt;img src=&quot;https://img2020.cnblogs.com/blog/2171721/202012/2171721-20201227160333289-1605013709.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 3. 工作分配视图&lt;/p&gt;
&lt;p&gt;　　工作分配视图将系统分解成可独立完成的工作任务，以便分配给各项目团队和成员。工作分配视图有利于跟踪不同项目团队和成员的工作任务的进度，也有利于在个项目团队和成员之间合理地分配和调整项目资源，甚至在项目计划阶段工作分配视图对于进度规划、项目评估和经费预算都能起到有益的作用。&lt;/p&gt;
&lt;p&gt;                                                &lt;img src=&quot;https://img2020.cnblogs.com/blog/2171721/202012/2171721-20201227165750533-683742649.png&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;293&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 四、数据库设计&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;
&lt;p&gt;用户id&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;
&lt;p&gt;名字&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;
&lt;p&gt;身份证&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;
&lt;p&gt;密码&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;
&lt;p&gt;手机号&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;车次id&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;出发站&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;终点站&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;出发时间&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;到达时间&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;82&quot;&gt;
&lt;p&gt;车票id&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;82&quot;&gt;
&lt;p&gt;车次id&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;82&quot;&gt;
&lt;p&gt;价格&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;82&quot;&gt;
&lt;p&gt;剩余数量&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;82&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;82&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;82&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;82&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;121&quot;&gt;
&lt;p&gt;订单号&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;121&quot;&gt;
&lt;p&gt;用户id&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;121&quot;&gt;
&lt;p&gt;车票id&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;117&quot;&gt;
&lt;p&gt;订票时间&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;121&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;121&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;121&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;117&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;五、源代码的目录文件结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
|---&lt;span&gt;src
   &lt;/span&gt;|---&lt;span&gt;main
        &lt;/span&gt;|---&lt;span&gt;model 数据库中的数据模型
        &lt;/span&gt;|---&lt;span&gt;service 业务逻辑
        &lt;/span&gt;|---&lt;span&gt;util 主要用于处理对车票的操作
        &lt;/span&gt;|---&lt;span&gt;view 视图
        &lt;/span&gt;|---&lt;span&gt;resources 配置文件
   &lt;/span&gt;|---&lt;span&gt;test 测试文件
        &lt;/span&gt;|---&lt;span&gt;java
        &lt;/span&gt;|---resources
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;六、项目概念原型的核心工作机制&lt;/p&gt;
&lt;p&gt;用户可以不登陆进入系统，也可以注册后登录系统，不登录就不显示个人信息。&lt;/p&gt;
&lt;p&gt;可以在主页面根据首末地点查询车票，或者点击车次汇总信息查看车站对用车次。&lt;/p&gt;
&lt;p&gt;用户可以在查询车票后购买车票，然后可以在个人的订单信息中查看或者退票改签。&lt;/p&gt;
&lt;p&gt;用户可以添加乘客，可以帮同行的人买车票。&lt;/p&gt;
</description>
<pubDate>Sun, 27 Dec 2020 15:48:00 +0000</pubDate>
<dc:creator>刺猬绅士</dc:creator>
<og:description>一、项目介绍 项目是模仿实现12306的部分功能，主要是售票系统的实现。这个系统的面向两类人，一是用户，二是系统管理员，其中系统设计主体部分是车次车票等信息的存储方式以及用户与系统的交互对后台数据的影</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/csy379/p/14194691.html</dc:identifier>
</item>
</channel>
</rss>