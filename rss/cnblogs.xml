<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>高等数学——求解不定积分经典换元法 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12579150.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12579150.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;，原创不易，求个关注&lt;/p&gt;
&lt;p&gt;今天是&lt;strong&gt;高等数学专题的第九篇&lt;/strong&gt;文章，我们继续来看不定积分。&lt;/p&gt;
&lt;p&gt;在上篇文章当中我们回顾了不定积分的定义以及简单的性质，我们&lt;strong&gt;可以简单地认为不定积分就是求导微分的逆操作&lt;/strong&gt;。我们要做的是根据现有的导函数，逆推出求导之前的原函数。&lt;/p&gt;
&lt;p&gt;除了基本定义之外，我们还介绍了一些简单的性质和常用积分的积分表。但是显然根据已有的性质对于许多复杂的函数来说求解积分仍然非常困难，所以本篇文章的重点是继续介绍不定积分的运算性质，从而简化我们一些复杂函数的计算过程。甚至是完成一些原本不能完成的计算。今天介绍的是最常用的&lt;strong&gt;换元积分法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;换元法是数学当中经常用到的方法，无论是求导计算还是一些复杂函数的运算，我们经常会使用换元法来降低问题的难度。同样，在不定积分的求解当中，我们一样可以使用换元法来进行。通常换元法分成两类，为什么会有两类？这两类有什么不同？这些问题可以先放一放，等看完文章就清楚了。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;第一类换元法&quot;&gt;第一类换元法&lt;/h2&gt;
&lt;p&gt;第一类换元法比较容易理解，其实是&lt;strong&gt;链式求导法则的逆运算&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如，我们有函数&lt;span class=&quot;math inline&quot;&gt;\(F'(u) = f(u)\)&lt;/span&gt;，显然函数F(u)是f(u)的原函数，所以：&lt;span class=&quot;math inline&quot;&gt;\(\int f(u)du = F(u) + C\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果u是中间变量，并且&lt;span class=&quot;math inline&quot;&gt;\(u= \phi(x)\)&lt;/span&gt;，我们对&lt;span class=&quot;math inline&quot;&gt;\(F(u)\)&lt;/span&gt;求导，根据复合函数的链式求导法则，可以得到：&lt;/p&gt;
&lt;p&gt;\[d[F(u)]=d[F(\phi(x)]=f[\phi(x)]\phi'(x)dx \]&lt;/p&gt;
&lt;p&gt;我们把上面这个式子用积分反过来，就可以得到&lt;strong&gt;不定积分的换元公式&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;\[\int f[\phi(x)]\phi'(x)dx = F[\phi(x)] + C = [\int f(u)du]_{u=\phi(x)} \]&lt;/p&gt;
&lt;p&gt;我们通过简单的推导获得了公式，那么这个公式怎么用呢？初看起来总有些难以下手的感觉，这是正常的，我们需要继续来化简。&lt;/p&gt;
&lt;p&gt;假设我们要求&lt;span class=&quot;math inline&quot;&gt;\(\int g(x)dx\)&lt;/span&gt;，直接求解比较麻烦，如果我们可以把g(x)想办法转化为&lt;span class=&quot;math inline&quot;&gt;\(f[\phi(x)]\phi'(x)\)&lt;/span&gt;的形式，那么我们就可以套用公式得到：&lt;/p&gt;
&lt;p&gt;\[\int g(x)dx = \int f[\phi(x)]\phi'(x) dx = [\int f(u)du]_{u=\phi(x)} \]&lt;/p&gt;
&lt;p&gt;这个时候函数g(x)的积分就转化成了函数f(u)的积分，如果能求到f(u)的原函数，那么我们也就得到了g(x)的原函数。一般来说经过了换元化简之后得到的函数f(u)都会比原函数g(x)简单得多，这也是换元法的意义。&lt;/p&gt;
&lt;p&gt;光说不练假把式，我们来看一个例子：&lt;/p&gt;
&lt;p&gt;\[\int \frac{1}{3 + 2x}dx \]&lt;/p&gt;
&lt;p&gt;由于分母上的x有一个系数，导致我们不能直接使用积分公式。这个时候就需要换元，不难想到，我们可以用&lt;strong&gt;u = 3 + 2x&lt;/strong&gt;。由于我们要凑出f(u)du，我们发现u对x的导数为2，所以我们可以将原式变形：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \int \frac{1}{3 + 2x}dx &amp;amp;= \int \frac{1}{2}\cdot \frac{1}{3+2x} d(3 + 2x) \\ &amp;amp;= \int \frac{1}{2} \cdot \frac{1}{u} du = \frac{1}{2} \ln|u| + C \\ &amp;amp;= \frac{1}{2} \ln|3 + 2x| + C \end{aligned} \]&lt;/p&gt;
&lt;p&gt;通过上面这个例子，我们可以发现，其实换元法的精髓很简单，&lt;strong&gt;我们在换元之后，需要凑一下f(u)du&lt;/strong&gt;。当我们凑到了之后，就可以把u当成变量套积分公式了。&lt;/p&gt;
&lt;p&gt;我们再来看一个复杂一些的例子：&lt;/p&gt;
&lt;p&gt;\[\int \cos^2xdx \]&lt;/p&gt;
&lt;p&gt;在这个例子当中，我们要计算的函数比较复杂，&lt;strong&gt;既包含三角函数，又有平方操作&lt;/strong&gt;。简单粗暴直接搞肯定是不行的，我们需要先把&lt;span class=&quot;math inline&quot;&gt;\(cos^2x\)&lt;/span&gt;看成是&lt;span class=&quot;math inline&quot;&gt;\(\cos x \cdot \cos x\)&lt;/span&gt;，这样我们就可以套用积化和差公式，得到：&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}(1 + \cos 2x)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到这里就简单很多了：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \int \cos^2x dx = \int \frac{1}{2}(1 + \cos 2x) dx \end{aligned} \]&lt;/p&gt;
&lt;p&gt;我们&lt;strong&gt;令u = 2x&lt;/strong&gt;，上式可以变形为：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \int \cos^2x dx &amp;amp;= \frac{1}{2} (\frac{1}{2} \int du + \int \frac{1}{2}\cos u du) \\ &amp;amp;= \frac{1}{2} \int dx + \frac{1}{4} \int \cos u du \\ &amp;amp;= \frac{x}{2} + \frac{\sin 2x}{4} + C \end{aligned} \]&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;第二类换元法&quot;&gt;第二类换元法&lt;/h2&gt;
&lt;p&gt;熟悉了第一类换元法之后，我们来看第二类换元法。&lt;/p&gt;
&lt;p&gt;在第一类换元法当中我们用一个新的变量来代替了一个相对比较复杂的函数，比如我们用u代替了2x或者是2x+3等函数，简化了后续的运算。而第二类换元法的思路刚好相反，我们&lt;strong&gt;将原本单一的变量转化成一个复杂的表达式&lt;/strong&gt;。比如我们用三角函数或者是极坐标来表示原本的x，这种做法在高中的数学题当中经常常见，尤其是解析几何的问题。我们经常建立极坐标，用极坐标公式来换元简化计算。&lt;/p&gt;
&lt;p&gt;也就是说第二种换元法刚好和第一类换元法的逻辑相反，我们是将x转化成&lt;span class=&quot;math inline&quot;&gt;\(\phi(t)\)&lt;/span&gt;。所以换元公式为：&lt;/p&gt;
&lt;p&gt;\[\int f(x)dx = \int f[\phi(t)]\phi'(t)dt \]&lt;/p&gt;
&lt;p&gt;但是这么做是有前提的，f(x)既然可积说明积分一定存在，但是右边换元之后的式子却并不一定。所以我们需要保证&lt;span class=&quot;math inline&quot;&gt;\(\int f[\phi(t)]\phi'(t)\)&lt;/span&gt;的原函数存在。其次，在我们换元计算结束之后，我们需要用&lt;span class=&quot;math inline&quot;&gt;\(x = \phi(t)\)&lt;/span&gt;的函数的反函数&lt;span class=&quot;math inline&quot;&gt;\(t = \phi^{-1}(x)\)&lt;/span&gt;代入回去。但是要保证反函数存在并且可导的，我们可以简单认为原函数&lt;span class=&quot;math inline&quot;&gt;\(x = \phi(t)\)&lt;/span&gt;在某个区间上是单调可导的，并且&lt;span class=&quot;math inline&quot;&gt;\(\phi'(t) \neq 0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们根据上面的定义写出换元公式：&lt;/p&gt;
&lt;p&gt;\[\int f(x) dx = [\int f[\phi(t)]\phi'(t)dt]_{t = \phi^{-1}(x)} \]&lt;/p&gt;
&lt;p&gt;我们同样可以使用&lt;strong&gt;链式求导法则&lt;/strong&gt;来证明，我们假设&lt;span class=&quot;math inline&quot;&gt;\(f[\phi(t)]\phi'(t)\)&lt;/span&gt;的原函数是&lt;span class=&quot;math inline&quot;&gt;\(\Phi(t)\)&lt;/span&gt;，所以&lt;span class=&quot;math inline&quot;&gt;\(\Phi(t)=\Phi[\phi^{-1}(x)]=F(x)\)&lt;/span&gt;，我们对&lt;span class=&quot;math inline&quot;&gt;\(F(x)\)&lt;/span&gt;求导，可以得到：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} F'(x) &amp;amp;= \frac{d\Phi}{dt}\cdot \frac{dt}{dx} = f[\phi(t)]\phi'(t)\cdot \frac{1}{\phi'(t)} \\ &amp;amp;= f[\phi(t)] = f(x) \end{aligned} \]&lt;/p&gt;
&lt;p&gt;我们同样来看一个例子：&lt;span class=&quot;math inline&quot;&gt;\(\int \sqrt{a^2 - x^2}dx\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个例子当中又有平方根，又有平方项，看起来非常麻烦，这个时候我们就需要进行换元。因为&lt;span class=&quot;math inline&quot;&gt;\(\sin^2 t + \cos^2t = 1\)&lt;/span&gt;，所以我们可以令&lt;span class=&quot;math inline&quot;&gt;\(x = a\sin t\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(t \in (-\frac{\pi}{2}, \frac{\pi}{2})\)&lt;/span&gt;。我们代入原式，可以得到：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \int \sqrt{a^2 - x^2}dx = \int a\cos t \cdot a\cos t dt = a^2 \int cos^2 tdt \end{aligned} \]&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\int cos^2 tdt\)&lt;/span&gt; 其实就是我们上面讲的第二个例子，我们之前计算得到过答案：&lt;span class=&quot;math inline&quot;&gt;\(\int \cos^2x dx = \frac{x}{2} + \frac{\sin 2x}{4} + C\)&lt;/span&gt;，我们代入原式，可以得到：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \int \sqrt{a^2 - x^2}dx &amp;amp;= a^2(\frac{t}{2} + \frac{\sin 2t}{4}) + C \\ &amp;amp;= \frac{a^2}{2}t + \frac{a^2}{2}\sin t \cos t + C \end{aligned} \]&lt;/p&gt;
&lt;p&gt;由于&lt;span class=&quot;math inline&quot;&gt;\(x = a\sin t, -\frac{\pi}{2} &amp;lt; t &amp;lt; \frac{\pi}{2}\)&lt;/span&gt;，所以&lt;span class=&quot;math inline&quot;&gt;\(t = \arcsin \frac{x}{a}\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(\sin t = \frac{x}{a}\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(\cos t = \sqrt{1 - \sin^2t} = \sqrt{1 - (\frac{x}{a})^2} = \frac{\sqrt{a^2 - x^2}}{a}\)&lt;/span&gt;，我们将这些带入上式可以得到最终结果：&lt;/p&gt;
&lt;p&gt;\[\int \sqrt{a^2 - x^2}dx = \frac{a^2}{2}\arcsin \frac{x}{a} + \frac{1}{2}x \sqrt{a^2 - x^2} + C \]&lt;/p&gt;
&lt;p&gt;到这里，两个换元方法就介绍完了，虽然看起来简单，但是我们结合之前介绍的常用积分公式，&lt;strong&gt;还可以衍生出许多种不同的用法&lt;/strong&gt;。但是想要把这些用法全部吃透需要我们对积分公式以及换元应用都非常熟悉才行，这些并不是一两篇文章就能做到的，必须要做大量的练习，我想考研的同学应该有非常深刻的体会。&lt;/p&gt;
&lt;p&gt;今天的文章就是这些，如果觉得有所收获，请顺手点个&lt;strong&gt;关注或者转发&lt;/strong&gt;吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/27/1711969327d6cb40?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Mar 2020 00:40:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是 高等数学专题的第九篇 文章，我们继续来看不定积分。 在上篇文章当中我们回顾了不定积分的定义以及简单的性质，我们 可以简单地认为不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12579150.html</dc:identifier>
</item>
<item>
<title>您知道SASS吗？ - 葡萄城技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/12579122.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/12579122.html</guid>
<description>&lt;blockquote readability=&quot;7.4849785407725&quot;&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://www.grapecity.com.cn/&quot; target=&quot;_blank&quot;&gt;葡萄城官网&lt;/a&gt;，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。&lt;/p&gt;
&lt;p&gt;原文出处：https://blog.bitsrc.io/4-reasons-to-use-sass-in-your-frontend-project-bce88631c602&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202003/139239-20200327082142739-1413548340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;ij&quot;&gt;SASS是一种预处理器及样式表语言，由它们自己的&lt;a href=&quot;https://sass-lang.com/install&quot;&gt;工具&lt;/a&gt;或模块捆绑器(如webpack)编译成CSS。它有几个可以用来使CSS整洁和可重用的功能，例如变量，嵌套规则，mixin，函数等。&lt;/p&gt;
&lt;p class=&quot;hr&quot;&gt;虽然如此，但以上的解释应该不足以向你说清楚SASS是什么，所以下面我将用一些内容来为你解释SASS是什么？它能做什么？&lt;/p&gt;

&lt;p class=&quot;ij&quot;&gt;Sass通过在其中嵌套CSS类或选择器并在后台生成CSS使其成为可能。特别是当您遵循&lt;a href=&quot;http://getbem.com/introduction/&quot; target=&quot;_blank&quot;&gt;BEM体系架构&lt;/a&gt; 时特别有用，因为Sass与它的体系结构非常兼容，因此他们在文档中经常提到它。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;它是一种更优雅、更酷的UI设计方式。使用Sass构建CSS也更加容易。如果你是一名网页设计师或经验丰富的前端网页开发人员，你可能会非常喜欢它，因为使用它会让你的工作效率直线上升。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;Sass还使CSS代码更整洁，因为Sass会自动为您对CSS代码进行分组，并且也同样包含了代码嵌套。&lt;br/&gt;以下这两个功能将帮助您更好地构建CSS：&lt;/p&gt;
&lt;h2&gt;您可以使用＆符号连接CSS选择器&lt;/h2&gt;
&lt;p class=&quot;ij&quot;&gt;如果您使用的是BEM体系结构，请使用纯CSS进行编码：&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202003/139239-20200327082213177-1671914547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;hr&quot; align=&quot;center&quot;&gt;&lt;span&gt;遵循BEM（Block Element Modifier）架构的CSS代码&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;ij&quot;&gt;您可能已经注意到&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;.button&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;这个类名&lt;/strong&gt;，多次输入名为&lt;span lang=&quot;EN-US&quot;&gt;button的类名，可能会造成额外的精力浪费，而不是专注于&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;.button&lt;/span&gt;&lt;/strong&gt;有效地对类进行分组和样式设置。我发现做这件事既麻烦又乏味，特别是当我需要在重复命名&lt;span lang=&quot;EN-US&quot;&gt;CSS类或写选择器的时候。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hr&quot;&gt;现在如果你用&lt;span lang=&quot;EN-US&quot;&gt;sass来做这件事，它看起来是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202003/139239-20200327082243922-1514071278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;hr&quot;&gt;上面的示例展示了SASS如何通过使用（&lt;strong&gt;＆&lt;/strong&gt;）将CSS选择器串联在（&lt;strong&gt;{}&lt;/strong&gt;）中来嵌套几个选择器。如果您使用的是BEM体系结构，那么您就节省了一些需要重复输入CSS类和选择器来遵循该体系结构时间，因为SASS在后台已经帮您生成了完整的CSS了。&lt;/p&gt;
&lt;p class=&quot;hr&quot;&gt;比较SASS和CSS这两种语法，它们的代码如下所示：&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202003/139239-20200327082336242-1278327540.png&quot; alt=&quot;&quot; width=&quot;1708&quot; height=&quot;666&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;strong&gt;左：&lt;/strong&gt; SASS  &lt;strong&gt;右：&lt;/strong&gt;从SASS编译出的CSS&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt; &lt;/p&gt;
&lt;h2&gt;您可以使用&lt;span lang=&quot;EN-US&quot;&gt;SASS对父子选择器进行分组&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;hr&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Sass的另一个优点是，它还可以帮助您通过几行代码将选择器&lt;span lang=&quot;EN-US&quot;&gt;/类中的父子关系分组，就像您进行选择器连接的方式一样，只是添加了一个与号&lt;span lang=&quot;EN-US&quot;&gt;(&amp;amp;)，您只需多加几个括号就能完成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hr&quot;&gt;在纯&lt;span lang=&quot;EN-US&quot;&gt;CSS中，父子关系如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hr&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202003/139239-20200327082416220-441789641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;hr&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Sass是这样处理的：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hr&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202003/139239-20200327082425043-1871079674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p align=&quot;left&quot;&gt;并排比较，您可以看到这两者有很大区别：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202003/139239-20200327082459079-1213826657.png&quot; alt=&quot;&quot; width=&quot;1506&quot; height=&quot;967&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;就像选择符连接一样，使用Sass通过将CSS父子关系分组到括号中，自动为您生成CSS的嵌套父子关系。而且显然写出的代码更清爽、简洁。&lt;/p&gt;

&lt;p class=&quot;hr&quot;&gt;曾经我对使用Sass持怀疑态度，因为我认为学习CSS的一个子集简直是浪费时间，更不用说我过去经常忽略CSS中引入的最新特性，比如Flexbox。但是，当我第一次尝试学习Sass时，我发现我的开发效率提高了，我在开发/设计我的组件时变得毫不费力！ 我“遇到”它的时间还是太晚了。&lt;br/&gt;对选择器分组并创建嵌套选择器时简直轻而易举，因为Sass自动的帮我们完成了大量的工作。我可以毫不夸张的说我比使用纯CSS设置样式快了2倍。总体的感觉就是“真香”。&lt;/p&gt;

&lt;p class=&quot;ij&quot;&gt;您不仅可以轻松地用更少的代码嵌套CSS选择器，而且可以重用一些代码片段来解决整个UI中的某些CSS问题。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;Mixins可以帮助您做到这一点。这样，您可以避免在HTML元素中过多使用非语义的类。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;举个例子，您在将UI居中对齐时遇到了问题，而且您不想在每个CSS选择器中都写一遍一模一样的代码。在这种情况下，您可以使用Mixins来解决问题。&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;下面通过一个示例来展示它的用法吧&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202003/139239-20200327082538290-532989149.png&quot; alt=&quot;&quot; width=&quot;1827&quot; height=&quot;412&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;在左侧，我们有&lt;span lang=&quot;EN-US&quot;&gt;mixin absCenter，使用&lt;span lang=&quot;EN-US&quot;&gt;@include将它包含在&lt;code&gt;&lt;span lang=&quot;EN-US&quot;&gt;.sidebar&lt;/span&gt;&lt;/code&gt;选择器中。生成的&lt;span lang=&quot;EN-US&quot;&gt;CSS中就会自动包括&lt;span lang=&quot;EN-US&quot;&gt;mixin的代码段了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;SASS会立即把&lt;span lang=&quot;EN-US&quot;&gt;mixin标识的部分识别为可重用的代码，并将其注入到声明需要引用它们的选择器&lt;span lang=&quot;EN-US&quot;&gt;/类中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;ij&quot;&gt;您不仅可以通过使用&lt;span lang=&quot;EN-US&quot;&gt;Mixin重用代码，还可以为复杂的计算定义自己的函数！函数使您可以灵活地执行以下操作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ij&quot;&gt;如果您有一些复杂的&lt;span lang=&quot;EN-US&quot;&gt;CSS，您可能想要自动化并减少冗余，您可以利用自定义函数的强大功能来实现这一点。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hr&quot;&gt;让我们继续为您演示一下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/139239/202003/139239-20200327082611674-1489715769.png&quot; alt=&quot;&quot; width=&quot;945&quot; height=&quot;378&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;ij&quot;&gt;作为相对资深的前端开发者，我觉得如果您还没有用过Sass，那么建议您快用起来，因为它可能是您工作流程中的重要补充。如果您希望开始学习，可以通过该&lt;a href=&quot;https://sass-lang.com/documentation&quot;&gt;文档&lt;/a&gt;来开始学习。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Mar 2020 00:27:00 +0000</pubDate>
<dc:creator>葡萄城技术团队</dc:creator>
<og:description>转载请注明出处：葡萄城官网，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。 原文出处：https://blog.bitsrc.io/4-reasons-to-use-sass-in-y</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/powertoolsteam/p/12579122.html</dc:identifier>
</item>
<item>
<title>Dapper操作MySQL数据库获取JSON数据中文乱码 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/12574943.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/12574943.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在项目中利用Dapper将JSON数据存储到MySQL数据库，结果发现JSON数据中的中文乱码，特此记录，希望对存储JSON的童鞋能有所帮助，文中若有错误之处，还望批评指正。&lt;/p&gt;
&lt;h2&gt;Dapper获取JSON数据乱码（MySQL）&lt;/h2&gt;
&lt;p&gt;为了引出最终问题出在什么地方，我们重头开始进行讲解，首先我们给出如下测试实体以及在数据库中的表，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Data { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/589642/202003/589642-20200326160851569-964243657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了数据操作方便，我们通过包【Dapper.SimpleCRUD】来操作，插入数据和查询数据如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
    SimpleCRUD.SetDialect(SimpleCRUD.Dialect.MySQL);
    DefaultTypeMap.MatchNamesWithUnderscores &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; conn = &lt;span&gt;new&lt;/span&gt; MySqlConnection(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;.....;charset=utf8mb4;SslMode=none;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id = conn.Insert(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test()
        {
            Data &lt;/span&gt;= JsonConvert.SerializeObject(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;
            {
                name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;汪鹏&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            })
         });

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = conn.Get&amp;lt;Test&amp;gt;&lt;span&gt;(id);
    }

    Console.ReadKey();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/589642/202003/589642-20200326180009258-1001269887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202003/589642-20200326180124876-166359910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上一切正常，接下来我们将存储JSON数据的列类型修改为json，然后再来进行如上操作，结果会发现获取数据中文将乱码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/589642/202003/589642-20200326161708047-691400114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/589642/202003/589642-20200326161947024-521058092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚开始我猜想难道用的包【Dapper.SimpleCRUD】在映射时出了问题，于是我用Dapper进行如下查询，依然会出现如上中文乱码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; result = conn.QueryFirstOrDefault&amp;lt;Test&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from Test where Id = @id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new &lt;/span&gt;&lt;span&gt;{ id });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 所以由上基本可以得出结论：&lt;span&gt;针对MySQL中的类型json，若json数据中存在中文，则利用Dapper查询时将出现乱码。&lt;span&gt;那么如何解决这个问题呢？&lt;/span&gt;&lt;/span&gt;于是乎，在添加数据时，我将中文进行URL编码，再查询时进行解码即可，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; id = conn.Insert(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test()
{
    Data &lt;/span&gt;= JsonConvert.SerializeObject(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;
    {
        name &lt;/span&gt;= HttpUtility.UrlEncode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;汪鹏&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    })
 });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/589642/202003/589642-20200326162935262-1344614679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，上述解决方案以实际项目业务而去解决，我们项目需要获取到JSON数据中的中文然后通过URL传输，免去请求接口再去获取所存储的名称。到此我们了解了Dapper针对json数据类型将导致查询中文乱码的问题，但是其根本原因是什么呢？上述连接MySQL的驱动，是使用Oracle官方所提供的驱动且为最新版本，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/589642/202003/589642-20200326163847550-659854727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道通过EF Core操作MySQL数据库，若是利用官方包有一堆问题存在，所以大多都是采用的包【Pomelo.EntityFrameworkCore.MySql】，因为里面包含【MySqlConnector】，换句话说也就存在MySQL的驱动连接，所以这里我们尝试利用该包替换上述【MySql.Data】包，结果发现中文不再乱码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/589642/202003/589642-20200326164828982-1960397521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;综上所述，我们需要注意的是&lt;span&gt;若利用官方驱动包【MySql.Data】，当配置MySQL中的列类型为json时，若json数据中存在中文，则利用Dapper查询时将会出现中文乱码，需要进行转换&lt;/span&gt;，上述在数据库连接字符串中我们设置为utf8mb4，所以理论上应该和编码没有任何关系。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Mar 2020 23:47:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 在项目中利用Dapper将JSON数据存储到MySQL数据库，结果发现JSON数据中的中文乱码，特此记录，希望对存储JSON的童鞋能有所帮助，文中若有错误之处，还望批评指正。 Dapper获取J</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/12574943.html</dc:identifier>
</item>
<item>
<title>「 Offer收割机之JVM」：生存还是毁灭 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/12578999.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/12578999.html</guid>
<description>&lt;p&gt;这两天，广州的天气又开始热了起来，又到了小动物交配的季节，啊呸，又到了一个收割 offer 的季节。年底将至，又到了面试的高峰期，JVM 作为Java 程序员面试绕不过的一道坎儿，它又来了，你准备好了吗？&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/27/17119032d24fd3cb?w=160&amp;amp;h=117&amp;amp;f=png&amp;amp;s=18266&quot; alt=&quot;image-20191217224245333&quot;/&gt;&lt;h3 id=&quot;说说引用&quot;&gt;说说引用&lt;/h3&gt;
&lt;p&gt;面试官 A：小伙几，上篇我们说到了 JVM 收集的两种算法 —— 引用记数法和可达性分析算法，你对这两种算法的理解很清晰，那么这两种算法有一个很重要的点，就是『引用』，其实无论是引用记数法和可达性分析算法都离不开引用，那么你来谈谈引用吧。&lt;/p&gt;
&lt;p&gt;我： 这个啊，简单，引用（reference）就是一块内存存储着另一块内存地址（自信脸&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/27/17119032d27a747a?w=690&amp;amp;h=684&amp;amp;f=png&amp;amp;s=339039&quot; alt=&quot;image-20191217224354112&quot;/&gt;&lt;p&gt;面试官 A：说的倒也没错，但是过于片面，那么你能不能详细讲一下引用呢？&lt;/p&gt;
&lt;p&gt;我：上白板，我直接上图吧（熟练的拿起马克笔&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/27/17119032d33bab73?w=992&amp;amp;h=632&amp;amp;f=png&amp;amp;s=134939&quot; alt=&quot;image-20191217221519190&quot;/&gt;&lt;p&gt;面试官 A：那么你能不能详细的说一下这四种引用是在什么情况下出现的呢，它们分别代表了什么意义？&lt;/p&gt;
&lt;p&gt;我：先说说强引用吧，我们日常中最常见到的就是强引用（拿起桌上的白板，开始手写代码，就像这样的，就属于强引用，它有多强呢，就是只要强引用存在，GC 永远不会对它下手，嗯，你可以理解为就是范闲，皇上的私生子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String s = &quot;vi的技术博客&quot;;
s = &quot;技不可失&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;面试官 A：你也看庆余年啊，话说你看过原著没，结局是什么给我剧透剧透呗。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/27/17119032d893a23a?w=198&amp;amp;h=191&amp;amp;f=png&amp;amp;s=39913&quot; alt=&quot;image-20191217224333697&quot;/&gt;&lt;p&gt;我：咳咳，老哥这样不太好吧，这是我的微信：cm_950825，有什么咱们私聊好吧，不要砸我 offer 收割机的招牌，别人还以为我是靠裙带关系来着（小声BB&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/27/17119032d8cbf642?w=442&amp;amp;h=490&amp;amp;f=png&amp;amp;s=147209&quot; alt=&quot;image-20191217224424434&quot;/&gt;&lt;p&gt;面试官 A：那你来说一下软引用吧。&lt;/p&gt;
&lt;p&gt;我：我们还是接着来聊庆余年吧，开个玩笑啦，我来一起把软引用和弱引用一起说吧，它们都是用来描述一些非必需的对象，但是弱引用比起软引用来说，更加的弱，怎么说呢，还是看图吧（挥斥方遒的感觉&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/27/17119032d8e3303c?w=1076&amp;amp;h=1094&amp;amp;f=png&amp;amp;s=88601&quot; alt=&quot;image-20191217223216406&quot;/&gt;&lt;p&gt;软引用关联的对象，在系统发生 OOM之前，会把这些对象列入到回收范围之中进行二次回收，如果这次回收仍然没有足够的内存，才会发生 OOM，它是长这样儿式儿的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Object o = new Object();
SoftReference&amp;lt;Object&amp;gt; soft = new SoftReference&amp;lt;Object&amp;gt;(o);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而弱引用就是个弟弟，只要有 GC，必被回收，这个弟弟是这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Object o = new Object();
WeakReference&amp;lt;Object&amp;gt; weak = new WeakReference&amp;lt;Object&amp;gt;(o);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而它们的有一个普遍的应用场景：软引用和弱引用的一个特点是它何时被回收是不可确定的, 因为这是由GC运行的不确定性所确定的. 所以, 一般用它们是有价值被&lt;strong&gt;缓存&lt;/strong&gt;, 而且很容易被&lt;strong&gt;重新被构建&lt;/strong&gt;, 且&lt;strong&gt;很消耗内存&lt;/strong&gt;的对象.&lt;/p&gt;
&lt;p&gt;更深的东西我没有再去研究了。。&lt;/p&gt;
&lt;p&gt;面试官 A：整挺好，那你来说说最后的这个虚引用吧。&lt;/p&gt;
&lt;p&gt;我：虚引用啊，这玩意儿你可以理解为没有这个东西，它的唯一作用就是能在这个对象被 GC 的时候收到一个系统通知。&lt;/p&gt;
&lt;p&gt;面试官 A：是这样啊，那行吧，我手机没油了，咱们下次接着聊&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/27/171190333d8ee579?w=300&amp;amp;h=300&amp;amp;f=png&amp;amp;s=105936&quot; alt=&quot;image-20191217225131166&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面试官上集手机忽然没油了，不知道去哪加了一波油，又回来准备继续和我大战三百回合，尿遁用的如此熟练，一看就不是第一次干这个事情，不是个简单角色啊，我需要提高警惕了。&lt;/p&gt;
&lt;h3 id=&quot;继续面试&quot;&gt;继续面试&lt;/h3&gt;
&lt;p&gt;面试官 A ：刚刚我的手机没油了，去加了点油（挑眉&lt;/p&gt;
&lt;p&gt;我：理解理解，那咱们继续吧？&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/27/171190333d7e8e0e?w=618&amp;amp;h=608&amp;amp;f=jpeg&amp;amp;s=24020&quot;/&gt;&lt;p&gt;面试官 A：刚刚我们说到关于引用的一些知识，那么现在有一个问题，我们最开始说到了『可达性分析法』是我们目前正在使用的一个判定方法，那么是否没有连接到 GC Root 的对象都是被要被 GC 回收的呢？&lt;/p&gt;
&lt;p&gt;我：话其实也不能这么说（捏衣角），其实还是有挽回的余地的，大道五十，天衍四九。自然会有一丝生机，生机就在于 &lt;code&gt;finalize()&lt;/code&gt; 这个神奇的方法中，如果虚拟机发现对象没有连接到 GC Root 上，这个对象就会被打上一个&lt;strong&gt;待回收&lt;/strong&gt;的标签，如果对它不管不顾，它就会抛弃掉，但是如果对它进行一些操作，比如说重写&lt;code&gt;finalize()&lt;/code&gt;方法，在里面对它重新进行引用，就可以对这个对象进行最后的救赎。&lt;/p&gt;
&lt;p&gt;面试官 A：既然说到了&lt;code&gt;finalize()&lt;/code&gt;，你来说说你对这个方法的理解吧~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/27/171190334169a32f?w=198&amp;amp;h=184&amp;amp;f=png&amp;amp;s=45514&quot; alt=&quot;image-20191225222102367&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我：&lt;code&gt;finalize()&lt;/code&gt;是&lt;code&gt;Object&lt;/code&gt;类中的&lt;code&gt;protected&lt;/code&gt;方法，我们通常在子类中继承去完成资源清理的工作，GC 在进行回收的时候回去调用这个方法，但是我们通常不会用这个方法去进行GC，而是去释放一些连接资源或者 IO流。&lt;/p&gt;
&lt;p&gt;面试官 A：那么我们为什么通常不会用这个方法去完成 GC 呢？&lt;/p&gt;
&lt;p&gt;我：原因啊。。这个我得好好想想，是这样的，&lt;code&gt;finalize()&lt;/code&gt;实际上并不能保证资源被回收，因为对象的&lt;code&gt;finalize()&lt;/code&gt;方法中可以去做一些操作，使对象重新&lt;strong&gt;活过来&lt;/strong&gt;，这个我刚刚也说过了，而且，由于&lt;code&gt;finalize()&lt;/code&gt;方法只会被执行一次，会影响我们的判断，而且它的运行效率非常低，所以我们一般不会用&lt;code&gt;finalize()&lt;/code&gt;方法去回收对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/27/17119033423faf0b?w=160&amp;amp;h=160&amp;amp;f=png&amp;amp;s=32868&quot; alt=&quot;image-20191225225009918&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面试官 A：OK，虽然有些粗略，但是大概说了出来，最后一个问题，你来梳理一下判定一个对象是否为垃圾的流程图吧。&lt;/p&gt;
&lt;p&gt;我：好嘞~&lt;/p&gt;
&lt;ol readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先，新建一个对象，这个时候对象是处于&lt;strong&gt;存活&lt;/strong&gt;状态的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当对象变成 GC Roots 不可达的时候，GC 会去判断是否覆盖了&lt;code&gt;finalize()&lt;/code&gt;方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果没有覆盖，直接进行回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果覆盖了，再去判断对象是否执行过&lt;code&gt;finalize()&lt;/code&gt;方法，如果已经执行过，那么也会进行回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果&lt;strong&gt;覆盖且没有执行&lt;/strong&gt;过&lt;code&gt;finalize()&lt;/code&gt;方法，会将这个对象放到一个叫做 F-Queue 的队列中去。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;稍后由一个 JVM 自动建立的、低优先级的 Finalizer 线程去执行&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这里需要注意：这里的执行并不意味着真的会执行完毕，只是告知虚拟机会触发这个方法，并不保证可以运行完毕。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行完毕之后，如果对象仍然没有被重新引用（拯救），那么就会被回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果被重新引用的话，就会被「复活」了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/27/17119033420da107?w=1276&amp;amp;h=1176&amp;amp;f=png&amp;amp;s=110900&quot; alt=&quot;image-20191226062931613&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;面试官 A：可以，讲述的还算清楚，我这边考虑一下，你先回去等通知吧&lt;/p&gt;
&lt;p&gt;我：好的，老哥再见~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/27/17119033433e3219?w=208&amp;amp;h=156&amp;amp;f=png&amp;amp;s=20519&quot; alt=&quot;image-20191225230939206&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;公众号&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/25/171105a719ac8d08?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=28640&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Mar 2020 22:46:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>这两天，广州的天气又开始热了起来，又到了小动物交配的季节，啊呸，又到了一个收割 offer 的季节。年底将至，又到了面试的高峰期，JVM 作为Java 程序员面试绕不过的一道坎儿，它又来了，你准备好了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/12578999.html</dc:identifier>
</item>
<item>
<title>Python线性数据结构 - Singvis</title>
<link>http://www.cnblogs.com/singvis/p/12578929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/singvis/p/12578929.html</guid>
<description>&lt;p&gt;总结：顺序表对于查找与修改效率最高，增加和删除效率低。链接表则相反。&lt;/p&gt;&lt;p&gt;&lt;em&gt;说明：&lt;/em&gt; 列表是由若干元素对象组成，且是&lt;code&gt;有序可变&lt;/code&gt;的线性数据结构，使用中括号&lt;code&gt;[ ]&lt;/code&gt;表示。&lt;/p&gt;&lt;div id=&quot;&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = []  # 空列表方式1
#或者
lst = list()  # 空列表方式2
print(type(lst),lst)

# 输入结果如下：
&amp;lt;class 'list'&amp;gt; []
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;25&quot;&gt;
&lt;p&gt;索引&lt;/p&gt;
&lt;p&gt;&lt;em&gt;说明：&lt;/em&gt; 使用正索引(从左至右)、负索引(从右至左)访问元素，时间复杂度为&lt;code&gt;O(1)&lt;/code&gt;，效率极高的使用方式。&lt;/p&gt;
&lt;p&gt;按照给定区间获取到数据，叫做切片。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正索引：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从左至右，从0开始索引，区间为[0，长度-1]，左包右不包。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
print(lst[0])  # 获取第一个元素
print(lst[1:2])  # 获取第二个元素,左包右不包，切片
print(lst[2:])  # 获取第三个元素到最后一个元素，切片
print(lst[:])  # 获取所有元素，切片

# 输出结果如下：
a
['c']
['c', 'd']
['a', 'b', 'c', 'd']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;负索引：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从右至左，从-1开始索引，区间为[-长度，-1]&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
print(lst[-1])
print(lst[-2:])

# 输出结果如下：
d
['c', 'd']
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;33&quot;&gt;
&lt;p&gt;查询&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;index( )方法：&lt;/strong&gt;&lt;code&gt;L.index(value, [start, [stop]]) -&amp;gt; integer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回的是索引id，要迭代列表，时间复杂度为O(n)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
print(lst.index('a',0,4))  # 获取区间[0,4]的元素'a'的索引id

# 输出结果如下：
0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备注：如果查询不到元素，则抛出&lt;code&gt;ValueError&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;count( ) 方法：&lt;/strong&gt;L.count(value) -&amp;gt; integer&lt;/p&gt;
&lt;p&gt;返回的是元素出现的次数，要迭代列表，时间复杂度为O(n)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','a','b']
print(lst.count('a'))

# 输出结果如下：
2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;len( ) 方法：&lt;/strong&gt;返回的是列表元素的个数，时间复杂度为O(1)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
print(len(lst))

# 输出结果如下：
4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;所谓的O(n) 是指随着数据的规模越来越大，效率下降，而O(1)则相反，不会随着数据规模大而影响效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;修改&lt;/p&gt;
&lt;p&gt;列表是有序可变，所以能够对列表中的元素进行修改。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
lst[0] = 'A'
print(lst)

# 输出结果如下：
['A', 'b', 'c', 'd']
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;85&quot;&gt;
&lt;p&gt;增加&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;append( ) 方法：&lt;/strong&gt;&lt;code&gt;L.append(object) -&amp;gt; None&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;尾部追加元素，就地修改，返回None。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
lst.append('e')
print(lst)

# 输出结果如下：
['a', 'b', 'c', 'd', 'e']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;insert( )方法：&lt;/strong&gt;&lt;code&gt;L.insert(index, object) -&amp;gt; None&lt;/code&gt; ,&lt;/p&gt;
&lt;p&gt;在指定索引位置插入元素对象，返回None。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
lst.insert(0,'A')  # 在索引0位置插入'A',原有的元素全部往后移，增加了复杂度
print(lst)

# 输出结果如下：
['A', 'a', 'b', 'c', 'd']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;extend( )方法：&lt;/strong&gt; &lt;code&gt;L.extend(iterable) -&amp;gt; None&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以增加多个元素，将可迭代对象的元素追加进去，返回None。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
lst.extend([1,2,3])
print(lst)

# 输出结果如下：
['a', 'b', 'c', 'd', 1, 2, 3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以将列表通过 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;*&lt;/code&gt; ，拼接成新的列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst1 = ['a','b','c','d']
lst2 = ['e','f','g']
print(lst1 + lst2)
print(lst1 * 2)  # 将列表里面的元素各复制2份

# 输出结果如下：
['a', 'b', 'c', 'd', 'e', 'f', 'g']
['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里还有一个特别要注意情况如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst1 = [[1]] * 3  # 结果：[[1], [1], [1]]
print(lst1)
lst1[0][0] = 10  # 结果：[[10], [1], [1]]，是这样嘛？？
print(lst1)

# 输出结果如下：
[[1], [1], [1]]
[[10], [10], [10]]  # 为什么结果会是这个？请往下看列表复制章节，找答案！
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;29&quot;&gt;
&lt;p&gt;删除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;remove()方法：&lt;/strong&gt;&lt;code&gt;L.remove(value) -&amp;gt; None&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从左至右遍历查找，找到就删除该元素，返回None，找不到则抛出&lt;code&gt;ValueError&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
lst.remove('d')
print(lst)

# 输出结果如下：
['a', 'b', 'c']  # 元素'd'已经被删除
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;pop() 方法：&lt;/strong&gt;&lt;code&gt;L.pop([index]) -&amp;gt; item&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;缺省删除尾部元素，可指定索引删除元素，索引越界抛出&lt;code&gt;IndexError&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
lst.pop()
print(lst)

# 输出结果如下：
['a', 'b', 'c']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;clear() 方法：&lt;/strong&gt;&lt;code&gt;L.clear() -&amp;gt; None&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;清空列表所有元素，慎用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
lst.clear()
print(lst)

# 输出结果如下：
[]  # 空列表了
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;反转&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reverse( ) 方法：&lt;/strong&gt;&lt;code&gt;L.reverse()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将列表中的元素反转，返回None。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
lst.reverse()
print(lst)

# 输出结果如下：
['d', 'c', 'b', 'a']
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;排序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sort() 方法：&lt;/strong&gt;&lt;code&gt;L.sort(key=None, reverse=False) -&amp;gt; None&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对列表元素进行排序，缺省为升序，reverse=True为降序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
lst.sort(reverse=True)
print(lst)

# 输出结果如下：
['d', 'c', 'b', 'a']
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;in成员操作&lt;/p&gt;
&lt;p&gt;判断成员是否在列表里面，有则返回True、无则返回False。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst = ['a','b','c','d']
print('a' in lst)
print('e' in lst)

# 输出结果如下：
True
False
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;67&quot;&gt;
&lt;p&gt;列表复制&lt;/p&gt;
&lt;p&gt;&lt;em&gt;说明：&lt;/em&gt; 列表复制指的是列表元素的复制，可分为浅copy和深copy两种。列表元素对象如列表、元组、字典、类、实例这些归为引用类型(指向内存地址)，而数字、字符串先归为简单类型，好让大家理解。&lt;/p&gt;
&lt;p&gt;示例一：这是属于拷贝嘛？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst1 = [1,[2,3],4]
lst2 = lst1
print(id(lst1),id(lst2),lst1 == lst2, lst2)  # id() 查看内存地址

# 输出结果如下：
1593751168840 1593751168840 True [1, [2, 3], 4]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202003/1813756-20200327015955515-2061973522.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然不是属于任何copy，说白了都是指向同一个内存地址。&lt;/p&gt;
&lt;p&gt;示例二：浅拷贝copy&lt;/p&gt;
&lt;p&gt;&lt;em&gt;说明：&lt;/em&gt; 浅拷贝对于&lt;code&gt;引用类型&lt;/code&gt;对象是不会copy的，地址指向仍是一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202003/1813756-20200327015955662-1212355254.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;lst1 = [1,[2,3],4]
lst2 = lst1.copy()
print(id(lst1),id(lst2),lst1 == lst2, lst2)
print('=' * 30)
lst1[1][0] = 200  # 修改列表的引用类型，所有列表都会改变
print(lst1, lst2)

# 输出结果如下：
1922175854408 1922175854344 True [1, [2, 3], 4]
==============================
[1, [200, 3], 4] [1, [200, 3], 4]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例三：深拷贝deepcopy&lt;/p&gt;
&lt;p&gt;&lt;em&gt;说明：&lt;/em&gt; 深拷贝对于&lt;code&gt;引用类型&lt;/code&gt;对象也会copy成另外一份，地址指向不一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202003/1813756-20200327015956132-679335448.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import copy

lst1 = [1,[2,3],4]
lst2 = copy.deepcopy(lst1)
print(id(lst1),id(lst2),lst1 == lst2, lst2)
print('=' * 30)  
lst1[1][0] = 200  # 修改列表的引用类型，不会影响其他列表
print(lst1, lst2)

# 输出结果如下：
2378580158344 2378580158280 True [1, [2, 3], 4]
==============================
[1, [200, 3], 4] [1, [2, 3], 4]
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/div&gt;&lt;p&gt;&lt;em&gt;说明：&lt;/em&gt; 元组是由若干元素对象组成，且是&lt;code&gt;有序不可变&lt;/code&gt;的数据结构，使用小括号&lt;code&gt;( )&lt;/code&gt;表示。&lt;/p&gt;&lt;p&gt;&lt;em&gt;说明：&lt;/em&gt; 字符串是由若干字符组成，且是&lt;code&gt;有序不可变&lt;/code&gt;的数据结构，使用引号表示。&lt;/p&gt;&lt;div id=&quot;&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;初始化&lt;br/&gt;多种花样，使用单引号、双引号、三引号等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;name = 'tom'
age = 18
str1 = 'abc'  # 单引号字符串
str2 = &quot;abc&quot;  # 双引号字符串
str3 = &quot;&quot;&quot;I'm python&quot;&quot;&quot;  # 三引号字符串
str4 = r&quot;c:\windows\note&quot;  # r前缀，没有转义(转义字符不生效)
str5 = f'{name} is {age} age.'  # f前缀，字符串格式化，v3.6支持
print(type(str1), str1)
print(type(str2), str2)
print(type(str3), str3)
print(type(str4), str4)
print(type(str5), str5)

# 输出结果如下：
&amp;lt;class 'str'&amp;gt; abc
&amp;lt;class 'str'&amp;gt; abc
&amp;lt;class 'str'&amp;gt; I'm python
&amp;lt;class 'str'&amp;gt; c:\windows\note
&amp;lt;class 'str'&amp;gt; tom is 18 age.
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;索引&lt;/p&gt;
&lt;p&gt;同列表一样，不再过多举例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str = &quot;abcdefg&quot;
print(str[0])
print(str[-1])

# 输出结果如下：
a
g
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;连接&lt;/p&gt;
&lt;p&gt;通过加号 &lt;code&gt;+&lt;/code&gt; 将多个字符串连接起来，返回一个新的字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str1 = &quot;abcd&quot;
str2 = &quot;efg&quot;
print(str1 + str2)

# 输出结果如下：
abcdefg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;join( ) 方法：&lt;/strong&gt;&lt;code&gt;S.join(iterable) -&amp;gt; str&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;s表示分隔符字符串，iterable为可迭代对象&lt;strong&gt;字符串&lt;/strong&gt;，结果返回字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str = &quot;abcdefg&quot;
print('-&amp;gt;'.join(str))

# 输出结果如下：
a-&amp;gt;b-&amp;gt;c-&amp;gt;d-&amp;gt;e-&amp;gt;f-&amp;gt;g
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;23&quot;&gt;
&lt;p&gt;字符查找&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;find( ) 方法：&lt;/strong&gt;&lt;code&gt;S.find(sub[, start[, end]]) -&amp;gt; int&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从左至右查找子串sub，也可指定区间，找到返回正索引，找不到则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str = &quot;abcdefg&quot;
print(str.find('a',0,7))
print(str.find('A'))

# 输出结果如下：
0
-1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;rfind( ) 方法：&lt;/strong&gt;&lt;code&gt;S.rfind(sub[, start[, end]]) -&amp;gt; int&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从右至左查找子串sub，也可指定区间，找到返回正索引，找不到则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str = &quot;abcdefg&quot;
print(str.rfind('a'))
print(str.rfind('A'))

# 输出结果如下：
0
-1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有&lt;code&gt;index()&lt;/code&gt;和&lt;code&gt;find()&lt;/code&gt; 类似，不过找不到会抛异常，不建议使用。&lt;/p&gt;
&lt;p&gt;像&lt;code&gt;s.count()&lt;/code&gt; 还可以统计字符出现的次数。&lt;/p&gt;
&lt;p&gt;像&lt;code&gt;len(s)&lt;/code&gt; 还可以统计字符串的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;54&quot;&gt;
&lt;p&gt;分割&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;split( ) 方法：&lt;/strong&gt;&lt;code&gt;S.split(sep=None, maxsplit=-1) -&amp;gt; list of strings&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;sep表示分隔符，缺省为空白字符串，maxsplit=-1表示遍历整个字符串，最后返回列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str = &quot;a,b,c,d,e,f,g&quot;
print(str.split(sep=','))

# 输出结果如下：
['a', 'b', 'c', 'd', 'e', 'f', 'g']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;rsplit( ) 方法与上面不同就是，从右至左遍历。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;splitlines() 方法：&lt;/strong&gt; &lt;code&gt;S.splitlines([keepends]) -&amp;gt; list of strings&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按行来切割字符串，keepends表示是否保留行分隔符，最后返回列表。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str = &quot;a\nb\nc\r\nd&quot;
print(str.splitlines())
print(str.splitlines(keepends=True))

# 输出结果如下：
['a', 'b', 'c', 'd']
['a\n', 'b\n', 'c\r\n', 'd']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;partition() 方法&lt;/strong&gt; ： &lt;code&gt;S.partition(sep) -&amp;gt; (head, sep, tail)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从左至右查询分隔符，遇到就分割成头、分隔符、尾的三元组，返回的是一个元组tuple。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str = &quot;a*b*c*d&quot;
print(str.partition('*'))
# 输出结果如下：
('a', '*', 'b*c*d')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;rpartition() 方法&lt;/strong&gt; ：&lt;code&gt;S.rpartition(sep) -&amp;gt; (head, sep, tail)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;与上方法不同，就是从右至左，不过这个比较常用，可以获取后缀部分信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str1 = &quot;http://www.python.org:8843&quot;
str2 = str1.rpartition(':')
port = str2[-1]
print(port)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;替换&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;replace() 方法：&lt;/strong&gt;&lt;code&gt;S.replace(old, new[, count]) -&amp;gt; str&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;遍历整个字符串，找到全部替换，count表示替换次数，缺省替换全部，最后返回一个&lt;code&gt;新的字符串&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str = &quot;www.python.org&quot;
print(str.replace('w','m'))  # 返回的是一个新的字符串
print(str)  # 字符串不可变，保持原样

# 输出结果如下：
mmm.python.org
www.python.org
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;移除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;strip() 方法：&lt;/strong&gt;&lt;code&gt;S.strip([chars]) -&amp;gt; str&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在字符串两端移除指定的&lt;code&gt;字符集chars&lt;/code&gt; , 缺省移除空白字符。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str = &quot; * www.python.org  *&quot;
print(str.strip(&quot;* &quot;))  # 去掉字符串首尾带有星号'*' 和 空白' '

# 输出结果如下：
www.python.org
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有&lt;code&gt;lstrip()&lt;/code&gt; 和 &lt;code&gt;rstrip&lt;/code&gt; 分别是移除字符串左边和右边字符集。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;29&quot;&gt;
&lt;p&gt;首尾判断&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;startswith() 方法：&lt;/strong&gt;&lt;code&gt;S.startswith(prefix[, start[, end]]) -&amp;gt; bool&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;缺省判断字符串开头是否有指定的字符prefix,也可指定区间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str = &quot;www.python.org&quot;
print(str.startswith('www',0,14))
print(str.startswith('p',0,14))
# 输出结果如下：
True
False
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;endswith() 方法：&lt;/strong&gt;&lt;code&gt;S.endswith(suffix[, start[, end]]) -&amp;gt; bool&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;缺省判断字符串结尾是否有指定的字符suffix,也可指定区间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str = &quot;www.python.org&quot;
print(str.startswith('www',0,14))
print(str.startswith('p',0,14))
# 输出结果如下：
True
False
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str = &quot;www.python.org&quot;
print(str.endswith('g',11,14))
# 输出结果如下：
True
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;22&quot;&gt;
&lt;p&gt;格式化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c风格格式化：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202003/1813756-20200327015956287-69473167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;格式字符串：使用%s(对应值为字符串)，%d(对应值为数字)等等，还可以在中间插入修饰符%03d。&lt;/p&gt;
&lt;p&gt;被格式的值：只能是一个对象，可以是元组或是字典。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;name = &quot;Tom&quot;
age = 18
print(&quot;%s is %d age.&quot; % (name,age))
# 输出结果如下：
Tom is 18 age.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;format格式化：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202003/1813756-20200327015956468-593040060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;格式字符串：使用花括号{ }, 花括号里面可以使用修饰符。&lt;/p&gt;
&lt;p&gt;被格式的值：*args为可变位置参数，**kwargs为可变关键字参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 位置传参
print(&quot;IP={} PORT={}&quot;.format('8.8.8.8',53))  # 位置传参
print(&quot;{Server}: IP={1} PORT={0}&quot;.format(53, '8.8.8.8', Server='DNS Server'))  # 位置和关键字传参传参

# 输出结果如下：
IP=8.8.8.8 PORT=53
DNS Server: IP=8.8.8.8 PORT=53
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 浮点数
print(&quot;{}&quot;.format(0.123456789))
print(&quot;{:f}&quot;.format(0.123456789))    #  小数点默认为6位
print(&quot;{:.2f}&quot;.format(0.123456789))  # 取小数点后两位
print(&quot;{:15}&quot;.format(0.123456789))   # 宽度为15，右对齐

# 输出结果如下：
0.123456789
0.123457     # 为什么是这个值？大于5要进位
0.12
    0.123456789  # 左边有4个空格
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;其他常用函数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;str = &quot;DianDiJiShu&quot;
print(str.upper())  # 字母全部转化为大写
print(str.lower())  # 字母全部转化为小写

# 输出结果如下：
DIANDIJISHU
diandijishu
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/div&gt;&lt;p&gt;在计算机的世界里，机器是以&lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 组成的，也叫二进制(字节)来通信的，这套编码我们叫做&lt;code&gt;ASCII&lt;/code&gt;编码。&lt;/p&gt;&lt;p&gt;所以机器通信的语言就叫做机器语言。然而我们人类想要跟机器通信，那么需要怎么做呢？&lt;/p&gt;&lt;p&gt;至今现代编码的发展史过程大概是这样的：ASCII(1字节) -&amp;gt; unicode(2~4字节) -&amp;gt; utf-8(1&lt;sub&gt;6字节)，utf8是多字节编码，一般使用1&lt;/sub&gt;3字节，特殊使用4字节(一般中文使用3字节)，向下兼容ASCII编码。&lt;/p&gt;&lt;p&gt;所以，机器上的进制就是字节，1字节等于8位，例如：十进制2，用2进制和16进制表示：&lt;/p&gt;&lt;p&gt;今天就到这了，下一回合咱再接着唠嗑 &lt;code&gt;set (集合)&lt;/code&gt; 和 &lt;code&gt;dict (字典)&lt;/code&gt; ，敬请耐心等待。&lt;/p&gt;&lt;p&gt;如果喜欢的我的文章，欢迎关注我的公众号：点滴技术，扫码关注，不定期分享&lt;/p&gt;</description>
<pubDate>Thu, 26 Mar 2020 18:00:00 +0000</pubDate>
<dc:creator>Singvis</dc:creator>
<og:description>python线性数据结构 [TOC] 1 线性数据结构 本章要介绍的线性结构：list、tuple、string、bytes、bytearray。 线性表：是一种抽象的数学概念，是一组元素的序列的抽象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/singvis/p/12578929.html</dc:identifier>
</item>
<item>
<title>如何优雅地中止线程？ - 武培轩</title>
<link>http://www.cnblogs.com/wupeixuan/p/12578851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wupeixuan/p/12578851.html</guid>
<description>&lt;p&gt;本文来学习如何学习优雅地中止线程？通过 &lt;a href=&quot;https://www.tianheyu.top/archives/java-thread-life-cycle&quot;&gt;Java 线程的生老病死&lt;/a&gt;的学习，我相信大家对线程的运行以及线程的状态有一定了解了，那么我们现在来学习中止线程：&lt;/p&gt;
&lt;h2 id=&quot;错误的线程中止---stop&quot;&gt;错误的线程中止 - stop&lt;/h2&gt;
&lt;p&gt;首先来讲解一个错误的方式来中止线程 — &lt;code&gt;stop&lt;/code&gt;：中止线程，并且清除监控器锁的信息，但是可能导致线程安全问题，JDK 不建议使用，类似的方法还有 destory，由于 JDK 从未实现该方法，在这里就不介绍了。&lt;/p&gt;
&lt;p&gt;接下来通过一段程序来讲解为什么 &lt;code&gt;stop&lt;/code&gt; 会导致线程安全问题？&lt;/p&gt;
&lt;p&gt;首先定义一个线程类 &lt;code&gt;StopThread&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StopThread extends Thread {
    private int i = 0;
    private int j = 0;

    @Override
    public void run() {
        synchronized (this) {
            // 增加同步锁，确保线程安全
            ++i;
            try {
                // 休眠10秒,模拟耗时操作
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            ++j;
        }
    }

    /**
     * 打印 i 和 j
     */
    public void print() {
        System.out.println(&quot;i=&quot; + i + &quot; j=&quot; + j);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个线程做的事情就是在同步代码块中对 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 这两个变量进行自增操作，但是在这个执行过程中会进行 10 秒的睡眠，如果在这个过程中，如果用 &lt;code&gt;stop&lt;/code&gt; 方法将线程中止的话，会导致 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 数据不正确，也可以说程序设计上的线程安全问题，因为主线程影响到了创建的 &lt;code&gt;StopThread&lt;/code&gt; 线程的数据不正确性，理想的正确输出结果应该是要么全部添加成功，要么都失败，因为我们添加锁的目的就是保证操作原子性或者说想让这两个变量在操作的时候不受其他线程干扰。&lt;/p&gt;
&lt;p&gt;下面编写 &lt;code&gt;StopThreadDemo&lt;/code&gt; 类，来使用 &lt;code&gt;stop&lt;/code&gt; 方法做个错误示范：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class StopThreadDemo {
    public static void main(String[] args) throws InterruptedException {
        StopThread thread = new StopThread();
        thread.start();
        // 休眠 1 秒，确保 i 变量自增成功
        Thread.sleep(1000);
        // 暂停线程
        thread.stop(); // 错误的终止
        while (thread.isAlive()) {
            // 确保线程已经终止
        } // 输出结果
        thread.print();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;StopThreadDemo&lt;/code&gt; 类中，创建并启动了 &lt;code&gt;StopThread&lt;/code&gt; 线程，这个线程就是下执行变量 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 的自增操作，但是这个自增操作是用同步关键字包裹的同步代码块，这样做是为了让两个变量的自增操作实现&lt;strong&gt;原子性&lt;/strong&gt;，不会受到其他线程的干扰，确保线程的安全。&lt;/p&gt;
&lt;p&gt;但是在线程休眠的 10 秒内，通过 &lt;code&gt;stop&lt;/code&gt; 方法把线程中止掉，会发现输出结果为 &lt;code&gt;i=1 j=0&lt;/code&gt;，也就是代码的前半段 i 自增实现，但是后半段 j 的自增失败，会使线程中的数据出现不一致性，从而同步代码块的保证的原子性的目标没有达成，破坏了线程安全。&lt;/p&gt;
&lt;h2 id=&quot;正确的线程中止---interrupt&quot;&gt;正确的线程中止 - interrupt&lt;/h2&gt;
&lt;p&gt;在介绍了错误的中止方式后，让我们来学习正确的线程中止 - &lt;code&gt;interrupt&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;如果目标线程在调用 &lt;code&gt;Object class&lt;/code&gt; 的 &lt;code&gt;wait() 、wait(long) 或 wait(long,int) 方法、join()、join(long,int) 或 sleep(long,int)&lt;/code&gt; 方法时阻塞，那么 &lt;code&gt;interrupt&lt;/code&gt; 会生效，该线程的中断状态将被清除，抛出 &lt;code&gt;InterruptedException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;如果目标线程是被 IO 或者 NIO 中的 Channel 所阻塞，同样 IO 操作会被中断返回特殊异常值，达到中止线程的目的。&lt;/p&gt;
&lt;p&gt;如果以上条件都不满足，则会设置此线程的中断状态。&lt;/p&gt;
&lt;p&gt;接下来将 &lt;code&gt;StopThreadDemo&lt;/code&gt; 中的 &lt;code&gt;stop&lt;/code&gt; 改为 &lt;code&gt;interrupt&lt;/code&gt; 来看下运行结果是什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.InterruptedException: sleep interrupted
        at java.lang.Thread.sleep(Native Method)
        at com.wupx.thread.StopThread.run(StopThread.java:18)
i=1 j=1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现两个变量的自增可以正常执行，保证了执行的数据一致性，&lt;code&gt;interrupt&lt;/code&gt; 不会强制中止，将线程直接中断，而是抛出异常通知我们，开发者就可以控制收到异常后的执行逻辑，让整个程序处于线程安全的状态，这是目前 JDK 版本中推荐的 &lt;code&gt;interrupt&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;除了 &lt;code&gt;interrupt&lt;/code&gt; 的正确方法外，还可以通过标志位的形式来中止线程：&lt;/p&gt;
&lt;h2 id=&quot;正确的线程中止---标志位&quot;&gt;正确的线程中止 - 标志位&lt;/h2&gt;
&lt;p&gt;如果代码程序逻辑中是循环执行的业务，可以在程序的执行中线程代码中增加一个标志位，比如下面代码中在 &lt;code&gt;while&lt;/code&gt; 循环中去执行这个程序，通过 &lt;code&gt;flag&lt;/code&gt; 去控制程序是否继续执行，如果在外部线程将 &lt;code&gt;flag&lt;/code&gt; 修改为 &lt;code&gt;false&lt;/code&gt;，那么创建的子线程代码中会收到这个数据的变化，通过这个变量的形式，通知到另一个线程，从而达到控制线程中止的效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class FlagThreadDemo {
    public volatile static boolean flag = true;

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -&amp;gt; {
            try {
                while (flag) { // 判断是否运行
                    System.out.println(&quot;运行中&quot;);
                    Thread.sleep(1000L);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        // 3 秒之后，将状态标志改为 false，代表不继续运行
        Thread.sleep(3000L);
        flag = false;
        System.out.println(&quot;程序运行结束&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过运行代码，得到的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;运行中
运行中
运行中
程序运行结束
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式受限于线程中所执行的业务逻辑，如果程序中是有可以用来做标志位的条件的话可以用这种方式来做，也是一种正确的线程中止方式。&lt;/p&gt;

&lt;p&gt;本文主要讲解了线程中止的三种方式：&lt;code&gt;stop&lt;/code&gt;、&lt;code&gt;interrupt&lt;/code&gt; 以及标志位，大家学会了吗，欢迎留言讨论。&lt;/p&gt;
&lt;p&gt;源代码可以在公众号【&lt;strong&gt;武培轩&lt;/strong&gt;】中回复【&lt;strong&gt;并发&lt;/strong&gt;】获取。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Mar 2020 17:26:00 +0000</pubDate>
<dc:creator>武培轩</dc:creator>
<og:description>我就用 stop 中止线程不行吗？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wupeixuan/p/12578851.html</dc:identifier>
</item>
<item>
<title>《前端之路》- TypeScript (四) class 中各类属性、方法，抽象类、多态 - SmallW</title>
<link>http://www.cnblogs.com/erbingbing/p/12578749.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erbingbing/p/12578749.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在这一章中介绍的 class 类，希望同学们可以在上一章节中 复习下构造函数、原型、原型链等基础知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、typescript-中的类&quot;&gt;一、TypeScript 中的类&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1、先来举个例子：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-typescript&quot;&gt;class Persons {
  name: any;
  age: number | undefined;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  getName(): void {
    console.log(`${this.name}今年已经${this.age}岁了`);
  }
}

let p11 = new Persons(&quot;za&quot;, 123);
console.log(p11.getName()); // za今年已经123岁了
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;转换成 ES5 的代码后：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var Persons = /** @class */ (function() {
  function Persons(name, age) {
    this.name = name;
    this.age = age;
  }
  Persons.prototype.getName = function() {
    console.log(
      this.name + &quot;\u4ECA\u5E74\u5DF2\u7ECF&quot; + this.age + &quot;\u5C81\u4E86&quot;
    );
  };
  return Persons;
})();
var p11 = new Persons(&quot;za&quot;, 123);
console.log(p11.getName()); //  za今年已经123岁了
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;2、这里和我们使用 Es6 中的 class 有一些差别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// javascript 中 class 的定义
class An {
  constructor(name) {
    this.name = name;
  }
  getName() {
    console.log(this.name);
  }
}
var a = new An(&quot;zz&quot;);
a.getName(); // zz
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;3、差异在于，我们需要去定义 constructor 构造函数中传入的数据参数的类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;二、typescript-中类的继承&quot;&gt;二、TypeScript 中类的继承&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-typescript&quot;&gt;class Animal {
  name: string | undefined;
  food: string;
  constructor(name: string, food: string) {
    this.name = name;
    this.food = food;
  }
  eat() {
    console.log(`${this.name}吃${this.food}`);
  }
}

class Cat extends Animal {
  constructor(name: string, food: string) {
    super(name, food);
  }
  jump() {
    console.log(`${this.name}正在跳`);
  }
}

let xiaohhua = new Cat(&quot;xiaohua&quot;, &quot;猫粮&quot;);
console.log(xiaohhua.eat()); // xiaohua吃猫粮
console.log(xiaohhua.jump()); // xiaohua正在跳
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里和 ES6 中的 class 继承内容基本上没什么出入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三、typescript-中公共，私有与受保护的修饰符&quot;&gt;三、TypeScript 中公共，私有与受保护的修饰符&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里的修饰符是对类中对 属性和方法的类型的定义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;3-1、属性的-public&quot;&gt;3-1、属性的 public&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不定义的类心的话，默认就是 public 类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-typescript&quot;&gt;class Animals {
  public name: string | undefined;
  constructor(name: string) {
    this.name = name;
  }
  eat() {
    console.log(`${this.name}哇`);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;转换成 es5 代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;&quot;use strict&quot;;
var Animals = /** @class */ (function() {
  function Animals(name) {
    this.name = name;
  }
  Animals.prototype.eat = function() {
    console.log(this.name + &quot;\u54C7&quot;);
  };
  return Animals;
})();
// 和没定义之前一样
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-2、属性的-private&quot;&gt;3-2、属性的 private&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当成员被标记成 private 时，它就不能在声明它的类的外部访问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-typescript&quot;&gt;class Animal2 {
  private name: string | undefined;
  constructor(name: string) {
    this.name = name;
  }
  eat() {
    console.log(`${this.name}哇`);
  }
}

var a = new Animal2(&quot;private&quot;);
a.name = &quot;123&quot;; // 报错，name 属性只能在 Animal2 内部使用
new Animal2(&quot;private&quot;).name = &quot;432&quot;; // 报错： 属性“name”为私有属性，只能在类“Animal2”中访问。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-3、属性的-protected&quot;&gt;3-3、属性的 protected&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当成员被标记成 protected 时，它就不能在声明它的类的外部访问，但是该类的子类可以访问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-typescript&quot;&gt;class Person2 {
  protected name: string;
  constructor(name: string) {
    this.name = name;
  }
}

class exPerson extends Person2 {
  public age: number;
  constructor(age: number, name: string) {
    super(name);
    this.age = age;
    this.name = name;
  }
  public getInfo() {
    console.log(`${this.name}哈哈哈哈${this.age}`);
  }
}

let ps = new exPerson(123, &quot;za&quot;); // 派生类可以继承 protected 属性，但是

ps.name = &quot;zz&quot;; // 报错 外部无法直接访问
console.log(ps); // { name: 'za', age: 123 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;构造函数也能够被 设置成 protected 属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-typescript&quot;&gt;class Person22 {
  protected name: string;
  protected constructor(name: string) {
    this.name = name;
  }
}

class exPerson2 extends Person2 {
  public age: number;
  constructor(age: number, name: string) {
    super(name);
    this.age = age;
    this.name = name;
  }
  public getInfo() {
    console.log(`${this.name}哈哈哈哈${this.age}`);
  }
}

let exp = new exPerson2(21, &quot;exp-name&quot;);
let per22 = new Person22(&quot;zs&quot;); // 报错 类“Person22”的构造函数是受保护的，仅可在类声明中访问
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-4、readonly-修饰符&quot;&gt;3-4、readonly 修饰符&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-typescript&quot;&gt;class octPers {
  readonly name: string;
  readonly age: number = 8;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

let ns = new octPers(&quot;zz&quot;, 123);
console.log(&quot;---1&quot;, ns);
ns.age = 456; // 报错 Cannot assign to 'age' because it is a read-only property.
console.log(&quot;---2&quot;, ns); // 这里会执行什么内容呢？
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四、typescript-中-静态方法&quot;&gt;四、TypeScript 中 静态方法&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里所谓的静态方法，其实就是将方法直接定义在了 构造函数对象上，只有构造函数本身才能去使用它，任何其他都无法使用（包括它的 派生类）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-typescript&quot;&gt;class staticPerson {
  public name: string;
  public age: number = 8;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  static getName1() {
    console.log(&quot;---static-getName---&quot;, this);
  }
  protected getName(): void {
    console.log(&quot;---protected-getName---&quot;, this);
  }
}

let ress = new staticPerson(&quot;zzs&quot;, 123);
console.log(&quot;---instancing getName&quot;, staticPerson.getName1()); // 属性“getName”受保护，只能在类“staticPerson”及其子类中访问。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五、typescript-中-继承与多态&quot;&gt;五、TypeScript 中 继承与多态&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里面其实更多的是 JS 的继承与多态，我们以 ES5 和 ES6 分别对继承和多态进行对比&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;5-1-es5-中是如何实现-继承的？&quot;&gt;5-1 ES5 中是如何实现 继承的？&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里我们想想继承，到底是继承什么？如何继承？为什么要继承？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;5-1-1-通过类式继承&quot;&gt;5-1-1 通过类式继承&lt;/h5&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;类的方式，其核心在于将 子类的 prototype 指向了 父类的实例，这样的话，子类的实例的 &lt;code&gt;__proto__&lt;/code&gt; 指向子类的 &lt;code&gt;prototype&lt;/code&gt;, 然而 子类的 &lt;code&gt;prototype&lt;/code&gt; 被赋予了 父类的实例。我们制作一个简单的图，来说明一下这里如何实现的继承。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/675289/202003/675289-20200326231020779-112372204.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var SuperClass = function(name) {
        var id = 1;
        this.name = name;
        this.work = function() {
                console.log(this.name + 'in SuperClass');
        };
};
SuperClass.prototype.getSuperName = function() {
        return this.name;
};

var SubClass = function() {
        this.getSubName = function() {
                console.log('this is subname');
        };
};

SubClass.prototype = new SuperClass('superClass');
var sub = new SubClass();

// 这样有缺点么？ 当然有，下面我们来通过例子来说明一下
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这种继承的方式的缺点、&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var SuperClass = function(name) {
        var id = 1;
        this.name = name;
        this.todo = [1, 2, 3, 4];
        this.work = function() {
                console.log(this.name + 'in SuperClass');
        };
};
SuperClass.prototype.getSuperName = function() {
        return this.name;
};

var SubClass = function() {
        this.getSubName = function() {
                console.log('this is subname');
        };
};

SubClass.prototype = new SuperClass('superClass');
var sub = new SubClass();
sub.todo.push('subClass name');
var sub2 = new SubClass();
console.log(sub2.todo); // [ 1, 2, 3, 4, 'subClass name']
// 这里是缺陷一，父类属性会被实例子类修改、污染

console.log(sub.name); //superClass
console.log(sub2.name); //superClass

// 子类的实例只能有一个name，这很显然也是不够灵活的，这里就是缺陷二
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里因为子类实例对象1，对于父类共有属性进行了修改，导致子类实例对象2 的对应属性受到了污染。那有没有什么办法可以避免这种污染呢？当然是有的，后面我们会介绍到的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;5-1-2-通过构造函数继承&quot;&gt;5-1-2 通过构造函数继承&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// 声明父类
function Animal(color) {
        this.name = 'animal';
        this.type = ['pig', 'cat'];
        this.color = color;
}

// 添加原型方法
Animal.prototype.eat = function(food) {
        console.log(food);
};

// 声明子类
function Dog() {
        Animal.apply(this, arguments);
        // 这一步的操作就是改变 Animal 方法的上下文，然后让 Dog 也具备了 父类构造函数内的属性和方法
}

var dog1 = new Dog('blue'); // dog1.color -&amp;gt; blue
var dog2 = new Dog('red'); // dog2.color -&amp;gt; red

dog1.type.push('haha');
console.log(dog2.type); // [ 'pig', 'cat' ]
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我没看到 dog1 修改了继承自父类的属性 type ，但是 dog2 的 type 属性并为被影响到。原因就是我们实例化的时候，创建的实例对象的指针指向的位置是不同的，所以对应的 &lt;code&gt;__proto__&lt;/code&gt; 指向的是 不同的子类构造函数的 &lt;code&gt;prototype&lt;/code&gt;。可能会比较绕口，但是本质就是 new 操作生成了2个不同的对象，各自有各自的原型属性，互不干扰。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;但是上面也有一个缺陷就是，子类没办法继承到父类原型上的方法和属性&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那聪明的前端开发者们，就想到了 集合前2者的优势，进行了 组合式继承。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;5-1-3-组合式继承&quot;&gt;5-1-3 组合式继承&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// 声明父类
function Animal(color) {
        this.name = 'animal';
        this.type = ['pig', 'cat'];
        this.color = color;
}

// 添加原型方法
Animal.prototype.eat = function(food) {
        console.log(food);
};

// 声明子类
function Dog() {
        Animal.apply(this, arguments);
        // 这一步的操作就是改变 Animal 方法的上下文，然后让 Dog 也具备了
        // 父类构造函数内的属性和方法
}
Dog.prototype = new Animal('Animal Color');

var dog1 = new Dog();
console.log((dog1.color = 'dog1.name'));
var dog2 = new Dog();

console.log(dog2.color); // undefined

这里为什么 dog2.color 是 undefined 而不是 'dog1.name' 呢？
因为，我们子类的构造函数，已经继承了 父类的构造函数内部的属性和方法，然后，在实例我们 子类的时候，子类的实例对象就会有先从本身的对象中去寻找 color 属性。
当找到对应属性的时候，无论是否有值，都会优先返回 实例化对象本身的属性，而不再需要从原型链中查找对应属性。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;5-2-es6-中是如何实现-继承的？&quot;&gt;5-2 ES6 中是如何实现 继承的？&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里我们想想继承，到底是继承什么？如何继承？为什么要继承？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;5-2-1-es6-的继承方式&quot;&gt;5-2-1 ES6 的继承方式&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;class Animal {
        constructor(name) {
                this.name = name;
        }
        eat(food) {
                console.log(`${this.name}吃${food}`);
        }
}

class Dog extends Animal {
        constructor(name) {
                super(name);
                this.name = name;
        }
        run() {
                console.log('小狗泡泡跑');
        }
}

let dog1 = new Dog('小狗');
let dog2 = new Dog('小花');
console.log(dog1.name); // 小狗
console.log(dog2.name); // 小花

dog1.__proto__ === Dog.prototype        // true
Dog.__proto__ === Animal                        // true

这里 Dog 的 __proto__ 指向的是 Animal 这个类

因为 Animal 这个类中的 constructor 就是原来的构造函数， 其中剩下的方法、属性都是 prototype 上的公共方法与属性。是可以被子类继承
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;六、总结&quot;&gt;六、总结&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里全篇文章又总结了下 JS 中继承的原理以及一些我们平时可能忽略的问题，这里就相当于在 学习 ts 之前，带着大家再一起复习一下。好了，本篇文章就先到这里了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;2.5252525252525&quot;&gt;
&lt;p&gt;GitHub 地址：（欢迎 star 、欢迎推荐 : )&lt;br/&gt;&lt;a href=&quot;https://github.com/erbing/blog/blob/master/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%B7%AF%20-%20TypeScript/TypeScript%20(%E5%9B%9B)%20class%20%E4%B8%AD%E7%A7%81%E6%9C%89%E3%80%81%E5%85%B1%E6%9C%89%E3%80%81%E8%A2%AB%E4%BF%9D%E6%8A%A4%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95.md&quot;&gt;《前端之路》 - TypeScript（四）class 篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 26 Mar 2020 16:40:00 +0000</pubDate>
<dc:creator>SmallW</dc:creator>
<og:description>[TOC] 在这一章中介绍的 class 类，希望同学们可以在上一章节中 复习下构造函数、原型、原型链等基础知识 一、TypeScript 中的类 1、先来举个例子： typescript class</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/erbingbing/p/12578749.html</dc:identifier>
</item>
<item>
<title>[C++]HelloWorld背后的故事！总结一下在我们运行exe可执行文件前究竟发生了什么！ - 海之恋SF</title>
<link>http://www.cnblogs.com/seafever/p/12577337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/seafever/p/12577337.html</guid>
<description>&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;code&gt;姓名&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;HelloWorld&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;性别&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;.cpp&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;住址&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;D:\&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;身份证号(SHA1)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;25106D2879A9EA300BB264F8155A71D7C44DA2E8&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/seafever/p/12577337.html#step1&quot;&gt;编写源文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/seafever/p/12577337.html#step2&quot;&gt;预编译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/seafever/p/12577337.html#step3&quot;&gt;编译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/seafever/p/12577337.html#step4&quot;&gt;汇编&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/seafever/p/12577337.html#step5&quot;&gt;链接&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;step1&quot;&gt;一、编写源文件&lt;/h2&gt;
&lt;p&gt;  源代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

int main()
{
        cout &amp;lt;&amp;lt; &quot;Hello World!&quot; &amp;lt;&amp;lt; endl;
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;step2&quot;&gt;二、预编译&lt;/h2&gt;
&lt;p&gt;  预编译输入命令&lt;code&gt;g++ -o HelloWorld.i -E HelloWorld.cpp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  该命令表示编译环节的第一步，也就是预编译！当然，这一步也可以被称为“编译预处理”！而这个 HelloWorld.i 即是预编译过后的文件！&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;主要行为&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1.&lt;/td&gt;
&lt;td&gt;展开所有的宏定义，消除“#define”&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;2.&lt;/td&gt;
&lt;td&gt;处理所有的预编译指令，比如#if、#ifdef等&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;3.&lt;/td&gt;
&lt;td&gt;处理#include预编译指令，将包含文件插入到该预编译的位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;4.&lt;/td&gt;
&lt;td&gt;删除所有的注释“/**/”、&quot;//&quot;等&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;5.&lt;/td&gt;
&lt;td&gt;添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及错误提醒&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;6.&lt;/td&gt;
&lt;td&gt;保留所有的#program编译指令，原因是编译器要使用它们&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;值得注意：这一步不会做出任何安全性和合法性的检查！&lt;/p&gt;
&lt;h2 id=&quot;step3&quot;&gt;三、编译&lt;/h2&gt;
&lt;p&gt;  编译请输入命令&lt;code&gt;g++ -o HelloWorld.s -S HelloWorld.i&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  该命令表示编译过程，也就是生成相应的汇编文件 HelloWorld.s 。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;主要行为&lt;/th&gt;
&lt;th&gt;具体描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;词法分析&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将源代码文件的字符序列划分为一系列的记号，一般词法分析产生的记号有：标识符、关键字、数字、字符串、特殊符号（加号、等号）；在识别记号的同时也将标识符放好符号表、将数字、字符放入到文字表等；有一个lex程序可以实现词法扫描，会按照之前定义好的词法规则将输入的字符串分割成记号，所以编译器不需要独立的词法扫描器&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;语法分析&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;语法分析器将对产生的记号进行语法分析，产生语法树----就是以表达式尾节点的树，一步步判断如何执行表达式操作;如果存在括号不匹配或者表达式错误，编译器就会报告语法分析阶段的错误；相同的存在一个yacc程序可以根据用户输入的语法规则生成语法树；&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;语义分析&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;由语法阶段完成分析的并没有赋予表达式或者其他实际的意义，比如乘法、加法、减法，必须经过语义阶段才能赋予其真正的意义；&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;代码优化&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将代码进行优化处理&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;符号汇总&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;汇总所有符号&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;补充说明：其中语义分析又可以分为“静态语义分析”和“动态语义分析”两种。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;语义分析&lt;/th&gt;
&lt;th&gt;简单说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;静态语义分析&lt;/td&gt;
&lt;td&gt;通常在编译器就可以确定的语义，主要包括“声明”、“类型的匹配”以及“类型的转换”&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;动态语义分析&lt;/td&gt;
&lt;td&gt;只能在运行期才能确定的语义&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;step4&quot;&gt;四、汇编&lt;/h2&gt;
&lt;p&gt;  汇编请输入命令&lt;code&gt;g++ -o HelloWorld.o -C HelloWorld.s&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  该命令表示对 HelloWorld.s 文件进行汇编处理，生成对应的可重定位的二进制文件 HelloWorld.o ，也就是我们所熟知的机器语言对应的文件。&lt;/p&gt;
&lt;h2 id=&quot;step5&quot;&gt;五、链接&lt;/h2&gt;
&lt;p&gt;  链接请输入命令&lt;code&gt;g++ HelloWorld.cpp -o HelloWorld.exe&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  通过调用链接器ld来链接程序运行需要的一大堆目标文件，以及所依赖的其它库文件，最后生成可执行文件.， 链接的主要内容是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确地衔接。&lt;/p&gt;
&lt;p&gt;需要指出：链接分为“静态链接”和“动态链接”。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;链接类型&lt;/th&gt;
&lt;th&gt;具体说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;静态链接&lt;/td&gt;
&lt;td&gt;指在编译阶段直接把静态库加入到可执行文件中去，这样可执行文件会比较大&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;动态链接&lt;/td&gt;
&lt;td&gt;指链接阶段仅仅只加入一些描述信息，而程序执行时再从系统中把相应动态库加载到内存中去&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;需要补充：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;库文件类型&lt;/th&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;静态库文件&lt;/td&gt;
&lt;td&gt;是一个二进制文件,存放的功能函数实现,在文件编译时要访问文件,编译之后静态库文件可以删除&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;动态库文件&lt;/td&gt;
&lt;td&gt;是一个二进制文件,存放的功能函数实现,在文件执行时要访问文件,编译时不需要动态库文件&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;额外说明：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作系统&lt;/th&gt;
&lt;th&gt;动态库文件后缀名&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;.so&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;window&lt;/td&gt;
&lt;td&gt;.dll&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;相册&quot;&gt;相册&lt;/h2&gt;
&lt;h3 id=&quot;预编译后的文件helloworldi&quot;&gt;预编译后的文件&lt;code&gt;HelloWorld.i&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1933465/202003/1933465-20200326233046009-341731622.png&quot; alt=&quot;HelloWorld.i&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  可以看到，代码量惊人的大！足足有两万多行！可想这个HelloWorld也不简单啊！&lt;/p&gt;
&lt;h3 id=&quot;编译后的文件helloworlds&quot;&gt;编译后的文件&lt;code&gt;HelloWorld.s&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1933465/202003/1933465-20200326231033711-943397115.png&quot; alt=&quot;HelloWorld.s&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  很明显看出，此时代码精简了很多!&lt;/p&gt;
&lt;h3 id=&quot;汇编后的文件helloworldo&quot;&gt;汇编后的文件&lt;code&gt;HelloWorld.o&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1933465/202003/1933465-20200326232731627-515310459.png&quot; alt=&quot;HelloWorld.o&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  可以看出，记事本已经显示乱码了！&lt;/p&gt;
&lt;h2 id=&quot;帮忙的朋友&quot;&gt;帮忙的朋友&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;工具&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;负责过程&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;编辑器&lt;/td&gt;
&lt;td&gt;编写代码的一些窗口&lt;/td&gt;
&lt;td&gt;编写源代码&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;编译器&lt;/td&gt;
&lt;td&gt;检查用户代码的一些语法错误，将其编译成汇编代码&lt;/td&gt;
&lt;td&gt;预编译、编译&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;汇编器&lt;/td&gt;
&lt;td&gt;将编译出来的汇编文件编译成一定功能的目标代码&lt;/td&gt;
&lt;td&gt;汇编&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;连接器&lt;/td&gt;
&lt;td&gt;将目标代码连接成可执行文件&lt;/td&gt;
&lt;td&gt;链接&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;原文作者：Seaver（海之恋SF）&lt;br/&gt;如要转载，请务必注明出处！&lt;br/&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/seafever/p/12577337.html&quot;&gt;https://www.cnblogs.com/seafever/p/12577337.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Mar 2020 16:05:00 +0000</pubDate>
<dc:creator>海之恋SF</dc:creator>
<og:description>人物介绍 | | HelloWorld | |: |: | | | .cpp | | | D:\ | | | 25106D2879A9EA300BB264F8155A71D7C44DA2E8 | 故事</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/seafever/p/12577337.html</dc:identifier>
</item>
<item>
<title>IdentityServer4源码解析_1_项目结构 - holdengong</title>
<link>http://www.cnblogs.com/holdengong/p/12578558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/holdengong/p/12578558.html</guid>
<description>&lt;p&gt;Security源码解析系列介绍了微软提供的各种认证架构，其中OAuth2.0，OpenIdConnect属于远程认证架构，所谓远程认证，是指token的颁发是由另外的站点实现的。&lt;/p&gt;
&lt;p&gt;IdentityServer4是基于OpenIdConnect协议的认证中心框架，能够帮助我们搭建中心化的认证服务。&lt;/p&gt;
&lt;p&gt;可以将OpenIdConnect协议立即理解成需求文档，idsv4基于需求提供了一系列的api。&lt;/p&gt;
&lt;p&gt;对于idsv还不太了解的可以看下面的资料，本系列主要学习梳理idsv的源码，结合协议加深理解。&lt;/p&gt;
&lt;p&gt;晓晨姐姐系列文章&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/stulzq/p/8119928.html&quot;&gt;https://www.cnblogs.com/stulzq/p/8119928.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方文档&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://identityserver4.readthedocs.io/en/latest/&quot;&gt;https://identityserver4.readthedocs.io/en/latest/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;项目地址如下&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4&quot;&gt;https://github.com/IdentityServer/IdentityServer4&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;克隆到本地，项目结构如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://fs.31huiyi.com/da6e1cbb-4dfd-4eed-a3cc-ff629a404c63.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;核心项目是IdentityServer4，其余的都是与微软框架集成、以及处理持久化的项目。&lt;br/&gt;项目结构如图。Endpoints文件夹就是接口文件，我们先看下依赖注入、中间件的代码，然后看下每个接口。&lt;br/&gt;&lt;img src=&quot;https://fs.31huiyi.com/44183a92-cb3e-45f5-8100-a4cd7101e2dd.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static IIdentityServerBuilder AddIdentityServer(this IServiceCollection services)
{
    var builder = services.AddIdentityServerBuilder();

    builder
        .AddRequiredPlatformServices()
        .AddCookieAuthentication()
        .AddCoreServices()
        .AddDefaultEndpoints()
        .AddPluggableServices()
        .AddValidators()
        .AddResponseGenerators()
        .AddDefaultSecretParsers()
        .AddDefaultSecretValidators();

    // provide default in-memory implementation, not suitable for most production scenarios
    builder.AddInMemoryPersistedGrants();

    return builder;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;AddRequiredPlatformServices - 注入平台服务
&lt;ul&gt;&lt;li&gt;IHttpContextAccessor：HttpContext访问器&lt;/li&gt;
&lt;li&gt;IdentityServerOptions：配置类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; public static IIdentityServerBuilder AddRequiredPlatformServices(this IIdentityServerBuilder builder)
{
    builder.Services.TryAddSingleton&amp;lt;IHttpContextAccessor, HttpContextAccessor&amp;gt;();            
    builder.Services.AddOptions();
    builder.Services.AddSingleton(
        resolver =&amp;gt; resolver.GetRequiredService&amp;lt;IOptions&amp;lt;IdentityServerOptions&amp;gt;&amp;gt;().Value);
    builder.Services.AddHttpClient();

    return builder;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;AddCookieAuthentication - 注入cookie服务
&lt;ul&gt;&lt;li&gt;注入名称为idsrv的cookie认证架构&lt;/li&gt;
&lt;li&gt;注入IAuthenticationService的实现IdentityServerAuthenticationService&lt;/li&gt;
&lt;li&gt;注入IAuthenticationHandlerProvider的实现FederatedSignoutAuthenticationHandlerProvider&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static IIdentityServerBuilder AddCookieAuthentication(this IIdentityServerBuilder builder)
{
    builder.Services.AddAuthentication(IdentityServerConstants.DefaultCookieAuthenticationScheme)
        .AddCookie(IdentityServerConstants.DefaultCookieAuthenticationScheme)
        .AddCookie(IdentityServerConstants.ExternalCookieAuthenticationScheme);

    builder.Services.AddSingleton&amp;lt;IConfigureOptions&amp;lt;CookieAuthenticationOptions&amp;gt;, ConfigureInternalCookieOptions&amp;gt;();
    builder.Services.AddSingleton&amp;lt;IPostConfigureOptions&amp;lt;CookieAuthenticationOptions&amp;gt;, PostConfigureInternalCookieOptions&amp;gt;();
    builder.Services.AddTransientDecorator&amp;lt;IAuthenticationService, IdentityServerAuthenticationService&amp;gt;();
    builder.Services.AddTransientDecorator&amp;lt;IAuthenticationHandlerProvider, FederatedSignoutAuthenticationHandlerProvider&amp;gt;();

    return builder;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;AddCoreServices - 注入核心服务&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// Adds the core services.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;builder&quot;&amp;gt;The builder.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public static IIdentityServerBuilder AddCoreServices(this IIdentityServerBuilder builder)
{
    builder.Services.AddTransient&amp;lt;SecretParser&amp;gt;();
    builder.Services.AddTransient&amp;lt;SecretValidator&amp;gt;();
    builder.Services.AddTransient&amp;lt;ScopeValidator&amp;gt;();
    builder.Services.AddTransient&amp;lt;ExtensionGrantValidator&amp;gt;();
    builder.Services.AddTransient&amp;lt;BearerTokenUsageValidator&amp;gt;();
    builder.Services.AddTransient&amp;lt;JwtRequestValidator&amp;gt;();

    // todo: remove in 3.0
#pragma warning disable CS0618 // Type or member is obsolete
    builder.Services.AddTransient&amp;lt;BackChannelHttpClient&amp;gt;();
#pragma warning restore CS0618 // Type or member is obsolete

    builder.Services.AddTransient&amp;lt;ReturnUrlParser&amp;gt;();
    builder.Services.AddTransient&amp;lt;IdentityServerTools&amp;gt;();

    builder.Services.AddTransient&amp;lt;IReturnUrlParser, OidcReturnUrlParser&amp;gt;();
    builder.Services.AddScoped&amp;lt;IUserSession, DefaultUserSession&amp;gt;();
    builder.Services.AddTransient(typeof(MessageCookie&amp;lt;&amp;gt;));

    builder.Services.AddCors();
    builder.Services.AddTransientDecorator&amp;lt;ICorsPolicyProvider, CorsPolicyProvider&amp;gt;();

    return builder;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;AddDefaultEndpoints - 注入接口
&lt;ul&gt;&lt;li&gt;AuthorizeCallbackEndpoint：认证回调接口&lt;/li&gt;
&lt;li&gt;AuthorizeEndpoint：认证接口&lt;/li&gt;
&lt;li&gt;CheckSessionEndpoint：检查会话接口&lt;/li&gt;
&lt;li&gt;DeviceAuthorizationEndpoint：设备认证接口&lt;/li&gt;
&lt;li&gt;DiscoveryEndpoint：元数据键接口&lt;/li&gt;
&lt;li&gt;DiscoveryEndpoint：元数据接口&lt;/li&gt;
&lt;li&gt;EndSessionCallbackEndpoint：结束会话回调接口&lt;/li&gt;
&lt;li&gt;EndSessionEndpoint：结束会话接口&lt;/li&gt;
&lt;li&gt;IntrospectionEndpoint：查询令牌信息接口&lt;/li&gt;
&lt;li&gt;TokenRevocationEndpoint：撤销令牌接口&lt;/li&gt;
&lt;li&gt;TokenEndpoint：发放令牌接口&lt;/li&gt;
&lt;li&gt;UserInfoEndpoint：查询用户信息接口&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; public static IIdentityServerBuilder AddDefaultEndpoints(this IIdentityServerBuilder builder)
{
    builder.Services.AddTransient&amp;lt;IEndpointRouter, EndpointRouter&amp;gt;();

    builder.AddEndpoint&amp;lt;AuthorizeCallbackEndpoint&amp;gt;(EndpointNames.Authorize, ProtocolRoutePaths.AuthorizeCallback.EnsureLeadingSlash());
    builder.AddEndpoint&amp;lt;AuthorizeEndpoint&amp;gt;(EndpointNames.Authorize, ProtocolRoutePaths.Authorize.EnsureLeadingSlash());
    builder.AddEndpoint&amp;lt;CheckSessionEndpoint&amp;gt;(EndpointNames.CheckSession, ProtocolRoutePaths.CheckSession.EnsureLeadingSlash());
    builder.AddEndpoint&amp;lt;DeviceAuthorizationEndpoint&amp;gt;(EndpointNames.DeviceAuthorization, ProtocolRoutePaths.DeviceAuthorization.EnsureLeadingSlash());
    builder.AddEndpoint&amp;lt;DiscoveryKeyEndpoint&amp;gt;(EndpointNames.Discovery, ProtocolRoutePaths.DiscoveryWebKeys.EnsureLeadingSlash());
    builder.AddEndpoint&amp;lt;DiscoveryEndpoint&amp;gt;(EndpointNames.Discovery, ProtocolRoutePaths.DiscoveryConfiguration.EnsureLeadingSlash());
    builder.AddEndpoint&amp;lt;EndSessionCallbackEndpoint&amp;gt;(EndpointNames.EndSession, ProtocolRoutePaths.EndSessionCallback.EnsureLeadingSlash());
    builder.AddEndpoint&amp;lt;EndSessionEndpoint&amp;gt;(EndpointNames.EndSession, ProtocolRoutePaths.EndSession.EnsureLeadingSlash());
    builder.AddEndpoint&amp;lt;IntrospectionEndpoint&amp;gt;(EndpointNames.Introspection, ProtocolRoutePaths.Introspection.EnsureLeadingSlash());
    builder.AddEndpoint&amp;lt;TokenRevocationEndpoint&amp;gt;(EndpointNames.Revocation, ProtocolRoutePaths.Revocation.EnsureLeadingSlash());
    builder.AddEndpoint&amp;lt;TokenEndpoint&amp;gt;(EndpointNames.Token, ProtocolRoutePaths.Token.EnsureLeadingSlash());
    builder.AddEndpoint&amp;lt;UserInfoEndpoint&amp;gt;(EndpointNames.UserInfo, ProtocolRoutePaths.UserInfo.EnsureLeadingSlash());

    return builder;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;AddPluggableServices - 注入可插拔服务&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static IIdentityServerBuilder AddPluggableServices(this IIdentityServerBuilder builder)
{
    builder.Services.TryAddTransient&amp;lt;IPersistedGrantService, DefaultPersistedGrantService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IKeyMaterialService, DefaultKeyMaterialService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;ITokenService, DefaultTokenService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;ITokenCreationService, DefaultTokenCreationService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IClaimsService, DefaultClaimsService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IRefreshTokenService, DefaultRefreshTokenService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IDeviceFlowCodeService, DefaultDeviceFlowCodeService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IConsentService, DefaultConsentService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;ICorsPolicyService, DefaultCorsPolicyService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IProfileService, DefaultProfileService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IConsentMessageStore, ConsentMessageStore&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IMessageStore&amp;lt;LogoutMessage&amp;gt;, ProtectedDataMessageStore&amp;lt;LogoutMessage&amp;gt;&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IMessageStore&amp;lt;EndSession&amp;gt;, ProtectedDataMessageStore&amp;lt;EndSession&amp;gt;&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IMessageStore&amp;lt;ErrorMessage&amp;gt;, ProtectedDataMessageStore&amp;lt;ErrorMessage&amp;gt;&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IIdentityServerInteractionService, DefaultIdentityServerInteractionService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IDeviceFlowInteractionService, DefaultDeviceFlowInteractionService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IAuthorizationCodeStore, DefaultAuthorizationCodeStore&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IRefreshTokenStore, DefaultRefreshTokenStore&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IReferenceTokenStore, DefaultReferenceTokenStore&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IUserConsentStore, DefaultUserConsentStore&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IHandleGenerationService, DefaultHandleGenerationService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IPersistentGrantSerializer, PersistentGrantSerializer&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IEventService, DefaultEventService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IEventSink, DefaultEventSink&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IUserCodeService, DefaultUserCodeService&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IUserCodeGenerator, NumericUserCodeGenerator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IBackChannelLogoutService, DefaultBackChannelLogoutService&amp;gt;();

    builder.AddJwtRequestUriHttpClient();
    builder.AddBackChannelLogoutHttpClient();
    //builder.Services.AddHttpClient&amp;lt;BackChannelLogoutHttpClient&amp;gt;();
    //builder.Services.AddHttpClient&amp;lt;JwtRequestUriHttpClient&amp;gt;();

    builder.Services.AddTransient&amp;lt;IClientSecretValidator, ClientSecretValidator&amp;gt;();
    builder.Services.AddTransient&amp;lt;IApiSecretValidator, ApiSecretValidator&amp;gt;();

    builder.Services.TryAddTransient&amp;lt;IDeviceFlowThrottlingService, DistributedDeviceFlowThrottlingService&amp;gt;();
    builder.Services.AddDistributedMemoryCache();

    return builder;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;AddValidators - 注入校验类&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static IIdentityServerBuilder AddValidators(this IIdentityServerBuilder builder)
{
    // core
    builder.Services.TryAddTransient&amp;lt;IEndSessionRequestValidator, EndSessionRequestValidator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;ITokenRevocationRequestValidator, TokenRevocationRequestValidator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IAuthorizeRequestValidator, AuthorizeRequestValidator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;ITokenRequestValidator, TokenRequestValidator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IRedirectUriValidator, StrictRedirectUriValidator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;ITokenValidator, TokenValidator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IIntrospectionRequestValidator, IntrospectionRequestValidator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IResourceOwnerPasswordValidator, NotSupportedResourceOwnerPasswordValidator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;ICustomTokenRequestValidator, DefaultCustomTokenRequestValidator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IUserInfoRequestValidator, UserInfoRequestValidator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IClientConfigurationValidator, DefaultClientConfigurationValidator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IDeviceAuthorizationRequestValidator, DeviceAuthorizationRequestValidator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IDeviceCodeValidator, DeviceCodeValidator&amp;gt;();

    // optional
    builder.Services.TryAddTransient&amp;lt;ICustomTokenValidator, DefaultCustomTokenValidator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;ICustomAuthorizeRequestValidator, DefaultCustomAuthorizeRequestValidator&amp;gt;();
    
    return builder;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;AddResponseGenerators - 注入响应生成类&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static IIdentityServerBuilder AddResponseGenerators(this IIdentityServerBuilder builder)
{
    builder.Services.TryAddTransient&amp;lt;ITokenResponseGenerator, TokenResponseGenerator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IUserInfoResponseGenerator, UserInfoResponseGenerator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IIntrospectionResponseGenerator, IntrospectionResponseGenerator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IAuthorizeInteractionResponseGenerator, AuthorizeInteractionResponseGenerator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IAuthorizeResponseGenerator, AuthorizeResponseGenerator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IDiscoveryResponseGenerator, DiscoveryResponseGenerator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;ITokenRevocationResponseGenerator, TokenRevocationResponseGenerator&amp;gt;();
    builder.Services.TryAddTransient&amp;lt;IDeviceAuthorizationResponseGenerator, DeviceAuthorizationResponseGenerator&amp;gt;();

    return builder;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;AddDefaultSecretParsers &amp;amp; AddDefaultSecretValidators&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// Adds the default secret parsers.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;builder&quot;&amp;gt;The builder.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public static IIdentityServerBuilder AddDefaultSecretParsers(this IIdentityServerBuilder builder)
{
    builder.Services.AddTransient&amp;lt;ISecretParser, BasicAuthenticationSecretParser&amp;gt;();
    builder.Services.AddTransient&amp;lt;ISecretParser, PostBodySecretParser&amp;gt;();

    return builder;
}

/// &amp;lt;summary&amp;gt;
/// Adds the default secret validators.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;builder&quot;&amp;gt;The builder.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public static IIdentityServerBuilder AddDefaultSecretValidators(this IIdentityServerBuilder builder)
{
    builder.Services.AddTransient&amp;lt;ISecretValidator, HashedSharedSecretValidator&amp;gt;();

    return builder;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt; /// &amp;lt;summary&amp;gt;
/// The IdentityServerOptions class is the top level container for all configuration settings of IdentityServer.
/// &amp;lt;/summary&amp;gt;
public class IdentityServerOptions
{
    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the unique name of this server instance, e.g. https://myissuer.com.
    /// If not set, the issuer name is inferred from the request
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;value&amp;gt;
    /// Unique name of this server instance, e.g. https://myissuer.com
    /// &amp;lt;/value&amp;gt;
    public string IssuerUri { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the origin of this server instance, e.g. https://myorigin.com.
    /// If not set, the origin name is inferred from the request
    /// Note: Do not set a URL or include a path.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;value&amp;gt;
    /// Origin of this server instance, e.g. https://myorigin.com
    /// &amp;lt;/value&amp;gt;
    public string PublicOrigin { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the value for the JWT typ header for access tokens.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;value&amp;gt;
    /// The JWT typ value.
    /// &amp;lt;/value&amp;gt;
    public string AccessTokenJwtType { get; set; } = &quot;at+jwt&quot;;

    /// &amp;lt;summary&amp;gt;
    /// Emits an aud claim with the format issuer/resources. That's needed for some older access token validation plumbing. Defaults to false.
    /// &amp;lt;/summary&amp;gt;
    public bool EmitLegacyResourceAudienceClaim { get; set; } = false;

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the endpoint configuration.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;value&amp;gt;
    /// The endpoints configuration.
    /// &amp;lt;/value&amp;gt;
    public EndpointsOptions Endpoints { get; set; } = new EndpointsOptions();

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the discovery endpoint configuration.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;value&amp;gt;
    /// The discovery endpoint configuration.
    /// &amp;lt;/value&amp;gt;
    public DiscoveryOptions Discovery { get; set; } = new DiscoveryOptions();

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the authentication options.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;value&amp;gt;
    /// The authentication options.
    /// &amp;lt;/value&amp;gt;
    public AuthenticationOptions Authentication { get; set; } = new AuthenticationOptions();

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the events options.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;value&amp;gt;
    /// The events options.
    /// &amp;lt;/value&amp;gt;
    public EventsOptions Events { get; set; } = new EventsOptions();

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the max input length restrictions.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;value&amp;gt;
    /// The length restrictions.
    /// &amp;lt;/value&amp;gt;
    public InputLengthRestrictions InputLengthRestrictions { get; set; } = new InputLengthRestrictions();

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the options for the user interaction.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;value&amp;gt;
    /// The user interaction options.
    /// &amp;lt;/value&amp;gt;
    public UserInteractionOptions UserInteraction { get; set; } = new UserInteractionOptions();

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the caching options.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;value&amp;gt;
    /// The caching options.
    /// &amp;lt;/value&amp;gt;
    public CachingOptions Caching { get; set; } = new CachingOptions();

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the cors options.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;value&amp;gt;
    /// The cors options.
    /// &amp;lt;/value&amp;gt;
    public CorsOptions Cors { get; set; } = new CorsOptions();

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the Content Security Policy options.
    /// &amp;lt;/summary&amp;gt;
    public CspOptions Csp { get; set; } = new CspOptions();

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the validation options.
    /// &amp;lt;/summary&amp;gt;
    public ValidationOptions Validation { get; set; } = new ValidationOptions();

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the device flow options.
    /// &amp;lt;/summary&amp;gt;
    public DeviceFlowOptions DeviceFlow { get; set; } = new DeviceFlowOptions();

    /// &amp;lt;summary&amp;gt;
    /// Gets or sets the mutual TLS options.
    /// &amp;lt;/summary&amp;gt;
    public MutualTlsOptions MutualTls { get; set; } = new MutualTlsOptions();
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;执行校验&lt;/li&gt;
&lt;li&gt;BaseUrlMiddleware中间件：设置BaseUrl&lt;/li&gt;
&lt;li&gt;配置CORS跨域：CorsPolicyProvider根据client信息生成动态策略&lt;/li&gt;
&lt;li&gt;IdentityServerMiddlewareOptions默认调用了UseAuthentication，所以如果使用IdentityServer不用重复注册Authentication中间件&lt;/li&gt;
&lt;li&gt;使用MutualTlsTokenEndpointMiddleware中间件：要求客户端、服务端都使用https，默认不开启&lt;/li&gt;
&lt;li&gt;使用IdentityServerMiddleware中间件：IEndpointRouter根据请求寻找匹配的IEndpointHandler，如果找到的话则由EndPointHandler处理请求。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static IApplicationBuilder UseIdentityServer(this IApplicationBuilder app, IdentityServerMiddlewareOptions options = null)
{
    app.Validate();

    app.UseMiddleware&amp;lt;BaseUrlMiddleware&amp;gt;();

    app.ConfigureCors();

    // it seems ok if we have UseAuthentication more than once in the pipeline --
    // this will just re-run the various callback handlers and the default authN 
    // handler, which just re-assigns the user on the context. claims transformation
    // will run twice, since that's not cached (whereas the authN handler result is)
    // related: https://github.com/aspnet/Security/issues/1399
    if (options == null) options = new IdentityServerMiddlewareOptions();
    options.AuthenticationMiddleware(app);

    app.UseMiddleware&amp;lt;MutualTlsTokenEndpointMiddleware&amp;gt;();
    app.UseMiddleware&amp;lt;IdentityServerMiddleware&amp;gt;();

    return app;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;idsv的代码量还是比较大的，注入了大量的类。但是代码风格比较规范，脉络还是很清晰的。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Mar 2020 15:57:00 +0000</pubDate>
<dc:creator>holdengong</dc:creator>
<og:description>目录 &amp;quot;identityserver4源码解析_1_项目结构&amp;quot; &amp;quot;identityserver4源码解析_2_元数据接口&amp;quot; &amp;quot;identityserv</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/holdengong/p/12578558.html</dc:identifier>
</item>
<item>
<title>IntegerCache缓存占用堆、栈、常量池的问题，自动拆装箱的基本概念，Integer==int时的问题说明 - Dearzh</title>
<link>http://www.cnblogs.com/zh94/p/12578417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zh94/p/12578417.html</guid>
<description>&lt;p&gt;一文说清楚IntegerCache的缓存堆栈常量池的问题，以及Java中拆箱和装箱的基本概念，AND 使用Integer和int进行==比较时的问题注意事项，清楚但忘记的同学快来补一补；&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;127.35001657275&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zh94&quot;&gt;原创声明：作者：Arnold.zhao 博客园地址：https://www.cnblogs.com/zh94&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;自动装箱&quot;&gt;自动装箱&lt;/h2&gt;
&lt;p&gt;在JDK5以后，我们可以直接使用Integer num = 2；来进行值的定义，但是你有没有考虑过？Integer是一个对象呀，为什么我可以不实例化对象，就直接来进行Value的定义呢？&lt;/p&gt;
&lt;p&gt;一般情况下我们在定义一个对象的时候，顶多赋值为一个null 即空值；&lt;br/&gt;比如：Person pserson = null；但是肯定不可以Person person =2；这样操作吧，&lt;br/&gt;那为什么Integer，Float，Double，等基本数据类型的包装类是可以直接定义值的呢？&lt;/p&gt;
&lt;p&gt;究其原因无非是编译器在编译代码的时候，重新进行了一次实例化的操作而已啦：&lt;br/&gt;比如当我们使用Integer num = 2 的时候，在JVM运行前的编译阶段，此时该Integer num = 2 将会被编译为&lt;br/&gt;Integer num = new Integer(2); 那么此时编译后的这样一个语法 new Integer(2) 则是符合JDK运行时的规则的，而这种操作就是所谓的装箱操作；&lt;/p&gt;
&lt;p&gt;注意：（不要拿Integer和int类型来进行对比，int，float，这些是JDK自定义的关键字，&lt;br/&gt;本身在编译的时候就会被特殊处理，而Integer，Float，Double等则是标准的对象，对象的实现本身就是要有new 的操作才是合理；&lt;br/&gt;所以对于这些基本类型的包装类在进行 Integer num = 2的赋值时，则的确是必须要有一个装箱的操作将其变成对象实例化的方式这样也才是一个标准的过程；）&lt;/p&gt;
&lt;h2 id=&quot;自动拆箱&quot;&gt;自动拆箱&lt;/h2&gt;
&lt;p&gt;那么当你了解了对应的装箱操作后，再来了解一下对应拆箱的操作：&lt;/p&gt;
&lt;p&gt;当我们把一个原本的Integer num1 = 2; 来转换为 int num1 = 2的时候实际上就是一个拆箱的操作，及把包装类型转换为基本数据类型时便是所谓的拆箱操作；&lt;br/&gt;一般当我们进行对比的时候，编译器便会优先把包装类进行自动拆箱：如Integer num1 = 2 和 int num2 = 2；当我们进行对比时&lt;br/&gt;if(num1 == num2) 那么此时编译器便会自动的将包装类的num1自动拆箱为int类型进行对比等操作；&lt;/p&gt;
&lt;h2 id=&quot;装箱及拆箱时的真正步骤&quot;&gt;装箱及拆箱时的真正步骤&lt;/h2&gt;
&lt;p&gt;上述已经说过了自动装箱时，实际上是把 Integer num =2 编译时变更为了 Integer num = new Integer(2)；&lt;br/&gt;但实际上JDK真的就只是这么简单的进行了一下new的操作吗？当然不是，在自动装箱的过程中实际上是调用的Integer的valueOf(int i)的方法，来进行的装箱的操作；&lt;br/&gt;我们来看一下这个方法的具体实现：我会直接在下述源码中加注释，直接看注释即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static Integer valueOf(int i) {
            //在调用valueOf进行自动装箱时，会先进行一次所传入值的判断，当i的值大于等于IntegerCache.low 以及 小于等于IntegerCache.high时，则直接从已有的IntegerCache.cache中取出当前元素return即可；
            if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high){
                            return IntegerCache.cache[i + (-IntegerCache.low)];
            }
            //否则则直接new Integer(i) 实例化一个新的Integer对象并return出去；
            return new Integer(i);
    }
    //此时我们再看一下上述的IntegerCache到底是做的什么操作，如下类：（注意：此处IntegerCache是 private 内部静态类，所以我们定义的外部类是无法直接使用的，此处看源码即可）
    
    private static class IntegerCache {
            //定义一个low最低值 及 -128；
            static final int low = -128;
            //定义一个最大值（最大值的初始化详情看static代码块）
            static final int high;
            //定义一个Integer数组，数组中存储的都是 new Integer()的数据；（数组的初始化详情看static代码块）
            static final Integer cache[];
    
            static {
                //此处定义一个默认的值为127；
                int h = 127;
                //sun.misc.VM.getSavedProperty() 表示从JVM参数中去读取这个&quot;java.lang.Integer.IntegerCache.high&quot;的配置，并赋值给integerCacheHighPropValue变量
                String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);
                //当从JVM中所取出来的这个java.lang.Integer.IntegerCache.high值不为空时
                if (integerCacheHighPropValue != null) {
                    try {
                        //此处将JVM所读取出的integerCacheHighPropValue值进行parseInt的转换并赋值给 int i;
                        int i = parseInt(integerCacheHighPropValue);
                        //Math.max()方法含义是，当i值大于等于127时，则输出i值，否则则输出 127；并赋值给 i；
                        i = Math.max(i, 127);
                        //Math.min()则表示，当 i值 小于等于 Integer.MAX_VALUE时，则输出 i，否则输出 Integer.MAX_VALUE，并赋值给 h
                        //此处使用：Integer.MAX_VALUE - (-low) -1 的原因是由于是从负数开始的，避免Integer最大值溢出，所以这样写的，此处可以先不考虑
                        h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                    } catch( NumberFormatException nfe) {
                        // If the property cannot be parsed into an int, ignore it.
                    }
                }
                //最后把所得到的最终结果 h 赋值给我们亲爱的 high 属性；
                high = h;
    
                //以下赋值当前cache数组的最大长度；
                cache = new Integer[(high - low) + 1];
                int j = low;
                //然后进行cache数组的初始化循环；
                for(int k = 0; k &amp;lt; cache.length; k++)
                    //注意：此处new Integer(j++);是先实例化的j，也就是负数-128，所以也才会有上述的Integer.MAX_VALUE - (-low) -1)的操作，因为数组中存储的是 -128 到 high 的所有实例化数据对象；
                    cache[k] = new Integer(j++);
    
                // range [-128, 127] must be interned (JLS7 5.1.7)
                assert IntegerCache.high &amp;gt;= 127;
            }
    
            private IntegerCache() {}
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;朋友们，由上述的代码我们便可以知道，自动装箱时：&lt;/p&gt;
&lt;p&gt;1、high的值如果未通过JVM参数定义时则默认是127，当通过JVM参数进行定义后，则使用所定义的high值，前提是不超出(Integer.MAX_VALUE - (-low) -1)的长度即可，如果超出这个长度则默认便是：Integer.MAX_VALUE - (-low) -1；&lt;/p&gt;
&lt;p&gt;2、默认情况下会存储一个 -128 到 high的 Integer cache[]数组，并且已经实例化了所有 -128 到high的Integer对象数据；&lt;/p&gt;
&lt;p&gt;3、当使用valueOf(int i)来自动装箱时，会先判断一下当前所需装箱的值是否(大于等于IntegerCache.low &amp;amp;&amp;amp; 小于等于IntegerCache.high) 如果是，则直接从当前已经全局初始化好的cache数组中返回即可，如果不是则重新 new Integer();&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而当Integer对象在自动拆箱时则是调用的Integer的intValue()方法，方法代码如下：可以看出是直接把最初的int类型的value值直接返回了出去，并且此时返回的只是基本数据类型！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private final int value;

    public int intValue() {
        return value;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;所以，朋友们，让我们带着上述的答案，来看下我们常在开发代码时碰到的一些问题：（请接着向下看哦，因为最后还会再涉及到一些JVM的说明哦）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zh94&quot;&gt;原创声明：作者：Arnold.zhao 博客园地址：https://www.cnblogs.com/zh94&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt; public static void main(String[] args) {
        Integer num1 = 2000;
        int num2 = 2000;
        //会将Integer自动拆箱为int比较，此处为true；因为拆箱后便是 int于int比较，不涉及到内存比较的问题；
        System.out.println(num1 == num2);
        Integer num3 = new Integer(2000);
        Integer num4 = new Integer(2000);
        //此处为false，因为 num3 是实例化的一个新对象对应的是一个新的内存地址，而num4也是新的内存地址；
        System.out.println(num3 == num4);
        Integer num5 = 100;
        Integer num6 = 100;
        //返回为true，因为Integer num5 =100的定义方式，会被自动调用valueOf()进行装箱；而valueOf()装箱时是一个IntegerCache.high的判断的，只要在这个区间，则直接return的是数组中的元素
        //而num5 =100 及返回的是数组中下标为100的对象，而num6返回的也是数组中下标为 100的对象，所以两个对象是相同的对象，此时进行 == 比较时，内存地址相同，所以为true
        System.out.println(num5 == num6);
        Integer num7 = new Integer(100);
        Integer num8 = 100;
        //结果为false；为什么呢？因为num7并不是自动装箱的结果，而是自己实例化了一个新的对象，那么此时便是堆里面新的内存地址，而num8尽管是自动装箱，但返回的对象与num7的对象也不是一个内存地址哦；
        System.out.println(num7 == num8);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zh94&quot;&gt;原创声明：作者：Arnold.zhao 博客园地址：https://www.cnblogs.com/zh94&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;1、由于我们在使用Integer和int进行&lt;mark&gt;比较时，存在着自动拆箱于装箱的操作，所以在代码中进行Integer的对比时尽可能的使用 .equals()来进行对比；&lt;br/&gt;比如我们定义如下一个方法：那么我们此时是无法知晓num1 和num2的值是否是直接new出来的？还是自动装箱定义出来的？就算两个值都是自动装箱定义出来的，那么num1 和num2的值是否超出了默认的-128到127的cache数组缓存呢？如果超出了那么还是new 的Integer()，此时我们进行 == 对比时，无疑是风险最大的，所以最好的还是 .equals()进行对比；除非是拿一个Integer和一个int基本类型进行对比可以使用&lt;/mark&gt;，因为此时无论Integer是新new实例化的还是自动装箱的，在对比时都会被自动拆箱为 int基本数据类型进行对比；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public void test(Integer num1,Integer num2){
        //TODO
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;2、合理的在项目上线后，使用-XX:AutoBoxCacheMax=20000 参数来定义自动装箱时的默认最大high值，可以很好的避免基本数据类型包装类被频繁堆内创建的问题；什么个意思呢，一般情况下我们在项目开发过程中，会大量使用Integer num = 23;等等的代码，并且我们在操作数据库的时候，一般返回的Entity实体类里面也会定义一大堆的Integer类型的属性，而上述也提到过了，每次Integer的使用实际上都会被自动装箱，对于超出-128和127的值,则会被创建新的堆对象；所以如果我们有很多的大于127的数据值，那么每次都需要在堆中创建临时对象岂不是一个很可惜的操作吗，如果我们在项目启动时设置-XX:AutoBoxCacheMax=20000，那么对于我们常用的Integer为2W以下的数字，则直接从IntegerCache 数组中直接取就行了，完全就没必要再创建临时的堆对象了嘛；这样对于整个JVM的GC回收来说，多多少少也是一些易处呀，避免了大量的重复的Integer对象的创建占用和回收的问题呢；不是嘛&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;3、之前在本人还是初初初级，初出茅庐程序猿的时候，就经常听到有的人说，JVM中关于-128到127的cache缓存是存在常量池里面的，有的人说当你在定义int类型时实际上是存储在栈里面的，搞的我也是很尴尬呀；很难抉择，&lt;br/&gt;&lt;strong&gt;那么现在呢，就给出一个最终的本人总结后的答案，如下：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首先我们看了上述自动装箱的源码以后，可以知道，初始化的缓存数据是定义在静态属性中的：static final Integer cache[]; 所以，答案是：我们自动装箱的cache数组缓存的确是定义在常量池中的；每次我们自动装箱时的数组判断，的确是从常量池中拿的数据，&lt;br/&gt;废话，因为是 static final 类型的呀，所以当然是常量池中存储的cache数组啦&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;但是：关于int类型中定义的变量实际上是存储于栈空间的，这个也是没错的，因为关于JVM栈中有一个定义是：针对局部变量中的基本类型的字面量则是存储在线程栈中的；（栈是线程的一个数据结构），&lt;br/&gt;所以对于我们在方法中定义的局部变量：int a = 3 时，则的确是存储在线程栈中的；而我们在方法中定义局部变量 Integer a=300时，这个肯定是在堆或者常量池中啦（看是否自动装箱后使用常量池中cache）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;而对于我们在类中定义的成员属性来说，比如：static int a =3;此时则是在常量池中（无外乎什么类型因为他是静态的，所以常量池）而类的成员属性 int a=3（则是在堆中，无外乎什么属性，普通变量所对应的对象内存都是堆中）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description>
<pubDate>Thu, 26 Mar 2020 15:32:00 +0000</pubDate>
<dc:creator>Dearzh</dc:creator>
<og:description>一文说清楚IntegerCache的缓存堆栈常量池的问题，以及Java中拆箱和装箱的基本概念，AND 使用Integer和int进行==比较时的问题注意事项，清楚但忘记的同学快来补一补；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zh94/p/12578417.html</dc:identifier>
</item>
</channel>
</rss>