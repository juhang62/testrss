<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Git小白到老鸟的进阶之路 - 计算机视觉life</title>
<link>http://www.cnblogs.com/CV-life/p/10897673.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CV-life/p/10897673.html</guid>
<description>&lt;p&gt;点“计算机视觉life”关注，置顶更快接收消息！&lt;/p&gt;
&lt;p&gt;小白：师兄，师兄，上次你教我的操作，我傻乎乎的执行了一遍，可是那个Git究竟是什么那？&lt;/p&gt;
&lt;p&gt;师兄：小白莫慌，Git就是一种版本控制，小白，你平时写论文，是不是也按日期保存成许多的版本那。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2019/04/21/5cbc59a432d38.png&quot; alt=&quot;1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小白：对呀，对呀。&lt;/p&gt;
&lt;p&gt;师兄：那开发项目的时候，每个人开发的部分都不一样，需要记录多个版本，这个就是我们伟大的Git做得。&lt;/p&gt;
&lt;p&gt;小白：师兄，师兄，那Git岂不是每个开发人员必备的技能了，我要学！我要学！&lt;/p&gt;
&lt;p&gt;师兄：那小白紧跟师兄道路，带你走进Git版本控制。&lt;/p&gt;
&lt;h5 id=&quot;step1-git安装&quot;&gt;Step1 : Git安装&lt;/h5&gt;
&lt;p&gt;师兄： 小白，Git的安装上一节可已经交给你了，这次就要考验你的水平了，不过我提供了安装地址给你哦。&lt;/p&gt;
&lt;p&gt;​ MAC下载地址：&lt;a href=&quot;https://git-scm.com/download/mac&quot; class=&quot;uri&quot;&gt;https://git-scm.com/download/mac&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​ Windows下载地址：&lt;a href=&quot;https://git-scm.com/download/win&quot; class=&quot;uri&quot;&gt;https://git-scm.com/download/win&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​ Linux下载地址：&lt;a href=&quot;https://git-scm.com/download/linux&quot; class=&quot;uri&quot;&gt;https://git-scm.com/download/linux&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;step-2-git配置&quot;&gt;Step 2: Git配置&lt;/h5&gt;
&lt;p&gt;师兄： 小白，刚才说了，版本控制是记录每个人开发部分的信息，那使用Git前得配置好个人的信息，让我们知道是谁在提交信息吧。​&lt;/p&gt;
&lt;pre class=&quot;g&quot;&gt;
&lt;code&gt;  git config --global user.name  'your_name'
  git config --global user.email 'your_email'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 git config --global 是对当前用户所有仓库有效&lt;/p&gt;
&lt;p&gt;​ git config --local 是对当前仓库有效&lt;/p&gt;
&lt;p&gt;​ git config --system 是对本系统的所有用户&lt;/p&gt;
&lt;p&gt;小白： 师兄，师兄，那如果我配置好了需要查看自己有没有配置好那&lt;/p&gt;
&lt;p&gt;师兄： 教你查看对当前用户所有仓库的配置，其他两种你可以举一反三吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  git config --list  --global&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;step-3-git命令&quot;&gt;Step 3: Git命令&lt;/h5&gt;
&lt;p&gt;师兄： 小白，你看下面这张图，workspace是工作区，index是暂存区，repository是本地仓库区，我们是在工作区添加修改文件被暂存区管理后提交到本地仓库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/21/5cbc5b08eed27.png&quot; alt=&quot;9.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;师兄： 小白接下来师兄给你介绍几个命令，你只需要记住即可。&lt;/p&gt;
&lt;p&gt;（1）在当前工作区新建一个Git仓库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git  init&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/21/5cbc5b2844392.png&quot; alt=&quot;2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）将当前文件添加到暂存区&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git add [file1]  [file2]       &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/21/5cbc5b53558df.png&quot; alt=&quot;3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;师兄：小白，你看这里先试用vim在当前工作区创建了一个README.md文件，然后使用git status查看了当前工作区的状态，README.md文件还没有被Git管理，当使用git add提交后，文件已经被Git管理。&lt;/p&gt;
&lt;p&gt;（3）提交暂存区当仓库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git commit -m [message]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/21/5cbc5b6499958.png&quot; alt=&quot;4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）信息查看&lt;/p&gt;
&lt;p&gt;师兄：小白这里我要教你两个查看信息的命令 git status和 git log，git status 就是不管你做了什么变更都可以通过它来查看。git log是你当前分支提交到仓库的历史版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/21/5cbc5cb23660d.png&quot; alt=&quot;10.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;师兄：小白你看这里，通过vim重新修改了README.md，又进行了重新提交到仓库，通过git log就可以显示出两次提交的历史版本，如果你需要查看每次提交的具体内容，还可以通过git show 哈希值查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/21/5cbc5b649b0ae.png&quot; alt=&quot;5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;师兄：小白小白，这里告诉你一个特别有用的工具gitk，可以通过图形化界面查看历史提交信息。&lt;/p&gt;
&lt;p&gt;（5）回撤操作&lt;/p&gt;
&lt;p&gt;小白：师兄，师兄，如果我不小心提交错的版本到仓库了怎么办？&lt;/p&gt;
&lt;p&gt;师兄：小白，别着急这里教你怎么回撤错误的提交。&lt;/p&gt;
&lt;p&gt;从仓库回撤最近的一次提交到暂存区&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git reset HEAD~1 --soft&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/21/5cbc5b64ab076.png&quot; alt=&quot;6.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回撤暂存区的内容到工作区&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git  reset HEAD &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/21/5cbc5b64a7973.png&quot; alt=&quot;7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;放弃前面的两次回退操作，回到变更之前，可以使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git  reset  哈希值  --hard &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个哈希值找到前面git log 打印的第二次提交打印的哈希值 回退即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/04/21/5cbc5b64a9407.png&quot; alt=&quot;8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;师兄：好了，小白，这次就给你说到这里，想要学习更多的Git操作，慢慢跟着师兄混吧。&lt;/p&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/QpE7Mud1USNtY3GpKaWscQ&quot;&gt;师兄带你轻松入门GitHub&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/nc75Q72MCFQxTZWEBuiqIA&quot;&gt;实用技能 | GitHub 寻宝指南&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/wzwXBfTZqodNY8FO2mHUHQ&quot;&gt;如何从零开始系统化学习视觉SLAM？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/0czzSBXsVOdmGnBR6nyWIA&quot;&gt;零基础小白，如何入门计算机视觉？&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 22:47:00 +0000</pubDate>
<dc:creator>计算机视觉life</dc:creator>
<og:description>点“计算机视觉life”关注，置顶更快接收消息！ 小白：师兄，师兄，上次你教我的操作，我傻乎乎的执行了一遍，可是那个Git究竟是什么那？ 师兄：小白莫慌，Git就是一种版本控制，小白，你平时写论文，是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CV-life/p/10897673.html</dc:identifier>
</item>
<item>
<title>Android 布局渲染流程与卡顿优化 - CurtisWgh</title>
<link>http://www.cnblogs.com/upwgh/p/10897576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upwgh/p/10897576.html</guid>
<description>&lt;h3 id=&quot;Android布局渲染流程与卡顿优化-文章内容概要&quot;&gt;文章内容概要&lt;/h3&gt;
&lt;h4 id=&quot;Android布局渲染流程与卡顿优化-一、手机界面UI渲染显示流程&quot;&gt;一、手机界面UI渲染显示流程&lt;/h4&gt;
&lt;h4 id=&quot;Android布局渲染流程与卡顿优化-二、16ms原则&quot;&gt;二、16ms原则&lt;/h4&gt;
&lt;h4 id=&quot;Android布局渲染流程与卡顿优化-三、造成卡顿的原因&quot;&gt;三、造成卡顿的原因&lt;/h4&gt;
&lt;h4 id=&quot;Android布局渲染流程与卡顿优化-四、过度绘制介绍、检测工具、如何避免造成过度绘制造成的卡顿&quot;&gt;四、过度绘制介绍、检测工具、如何避免造成过度绘制造成的卡顿&lt;/h4&gt;
&lt;h4 id=&quot;Android布局渲染流程与卡顿优化-一.手机界面UI渲染显示流程&quot;&gt;一.手机界面UI渲染显示流程&lt;/h4&gt;
&lt;p&gt;大家都知道CPU（中央处理器）主要负责数学和逻辑运算，在很早前，CPU还负责图像的显示操作，但是这样会大大的降低CPU的运算性能，所以GPU应运而生，GPU主要负责图像的渲染与显示，至此，CPU只需要给GPU发出指令，GPU再将我们写好的页面栅格化渲染显示出来，以一个button为例!&lt;/p&gt;
&lt;p&gt;&amp;lt;Button&amp;gt;属性设置【Width = “100dp”；Height = “100dp”】--&amp;gt;通过LayoutInflater将xml映射成对象加载到内存--&amp;gt;检测&amp;lt;Button&amp;gt;包含的属性信息--&amp;gt;CPU经过计算--&amp;gt;将&amp;lt;Button&amp;gt;处理为多维向量图形→CPU将图形交给GPU→GPU进行图形绘制（栅格化：&lt;span&gt;将图片等矢量资源,转化为一格格像素点的像素图,显示到屏幕上）（哪个位置是什么颜色的像素点，最终将图形铺满。&lt;span&gt;注：手机屏幕由无数个像素点堆积而成）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;总结来说就是CPU将UI对象计算成成多维图形（多边形、纹理），再通过OPENGL进行处理，处理完之后再交给GPU进行栅格化渲染并交给显示器进行显示。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img class=&quot;confluence-embedded-image&quot; src=&quot;https://wiki.kaiyuan.net/download/attachments/31548307/20170318131012037.png?version=1&amp;amp;modificationDate=1558265534000&amp;amp;api=v2&quot; alt=&quot;&quot; height=&quot;250&quot; data-image-src=&quot;/download/attachments/31548307/20170318131012037.png?version=1&amp;amp;modificationDate=1558265534000&amp;amp;api=v2&quot; data-unresolved-comment-count=&quot;0&quot; data-linked-resource-id=&quot;31548306&quot; data-linked-resource-version=&quot;1&quot; data-linked-resource-type=&quot;attachment&quot; data-linked-resource-default-alias=&quot;20170318131012037.png&quot; data-base-url=&quot;https://wiki.kaiyuan.net&quot; data-linked-resource-content-type=&quot;image/png&quot; data-linked-resource-container-id=&quot;31548307&quot; data-linked-resource-container-version=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;Android布局渲染流程与卡顿优化-二.16ms原则&quot;&gt;二.16ms原则&lt;/h4&gt;
&lt;p&gt;由于人眼的特殊构造，对于60fps以下的帧率画面，会给人一种卡顿的现象，所以就出现了16ms原则（1000ms/60fps = 16ms），即要保证页面16ms刷新一次。&lt;/p&gt;
&lt;p&gt;Android系统每隔16ms发出vsync信号，触发对UI进行渲染，1s内大约刷新屏幕60次，显示60帧的数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;fps：画面每秒钟传输的帧率，帧率越高，画面越流程，反之越卡顿&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;Android布局渲染流程与卡顿优化-三.造成卡顿的原因&quot;&gt;&lt;span&gt; 三.造成卡顿的原因&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;上面我们讲到了16ms原则，那么16ms原则对我们的UI产生了什么样的影响呢？&lt;/p&gt;
&lt;p&gt;因为16ms原则，我们显示器将页面显示出来分两种情况：&lt;/p&gt;
&lt;p&gt;1.上述步骤在16ms内完成，true→显示器直接显示。&lt;/p&gt;
&lt;p&gt;2.上述步骤在16ms内没有完成（可能由于CPU计算的时间过长或者由于GPU的渲染时间过长，最终导致整个流程下来超过了16ms），false--&amp;gt;垂直同步等待下一帧完成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释一下垂直同步机制：比如说第一帧在16ms内渲染完成，并且显示出来了，第二帧在上述的处理流程中超过了16ms，在16ms内没有完成，那么，屏幕就不会显示第二帧的数据，依旧只显示第一帧的数据，接下来处理第三帧，第三帧的数据在16ms内处理完了上述的流程，那么结果就是屏幕会将第二帧的数据和第三帧的数据一起显示出来（如果在某一处出现了丢帧的情况，大概率会影响到后面的绘制也会出现丢帧的情况），如果计算器cpu的计算能力和gpu的渲染能力很差，就会出现我们说的UI卡顿的现象。（用LOL举一个例子，比如我们1-10帧都没有在16ms内完成（打团中，UI过于复杂），第11帧在16ms内完成（打完团，回家泡泉水），这时候就会把1-11帧的数据都显示出来，这时候给人的感觉就是花里胡哨的闪现出一堆技能）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;看了上面的解释，是不是有一种明朗的感觉了，总的来说就是帧率过低，垂直同步机制的限制下，我们前面几帧的画面渲染不出来，直到某一帧我们的帧率正常了，这时候就会把前面的几帧一起渲染出来，这样就造成了我们所说的视觉上卡顿的现象了。&lt;/p&gt;
&lt;h4 id=&quot;Android布局渲染流程与卡顿优化-四.过度绘制介绍、检测工具、如何避免造成过度绘制造成的卡顿&quot;&gt;四.过度绘制介绍、检测工具、如何避免造成过度绘制造成的卡顿&lt;/h4&gt;
&lt;p&gt;既然我们知道了造成卡顿的原因了，那么，我们应该去如何检测和避免呢?这里就要介绍一下过度绘制了！&lt;/p&gt;
&lt;h5 id=&quot;Android布局渲染流程与卡顿优化-1.什么是过度绘制&quot;&gt;1.什么是过度绘制&lt;/h5&gt;
&lt;p&gt;前面我们说到了手机屏幕是由无数个像素点堆积而成的，一个像素点被我们重复多次的渲染，就是过度绘制&lt;/p&gt;
&lt;h5 id=&quot;Android布局渲染流程与卡顿优化-2.过度绘制检测工具&quot;&gt;2.过度绘制检测工具&lt;/h5&gt;
&lt;p&gt;开发者选项--&amp;gt;调试gpu过度绘制--&amp;gt;显示过度绘制区域&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img class=&quot;confluence-embedded-image&quot; src=&quot;https://wiki.kaiyuan.net/download/attachments/31548307/%E8%BF%87%E5%BA%A6%E7%BB%98%E5%88%B6%E9%A2%9C%E8%89%B2%E5%9B%BE%E8%B0%B1.png?version=1&amp;amp;modificationDate=1558265534000&amp;amp;api=v2&quot; alt=&quot;&quot; height=&quot;250&quot; data-image-src=&quot;/download/attachments/31548307/%E8%BF%87%E5%BA%A6%E7%BB%98%E5%88%B6%E9%A2%9C%E8%89%B2%E5%9B%BE%E8%B0%B1.png?version=1&amp;amp;modificationDate=1558265534000&amp;amp;api=v2&quot; data-unresolved-comment-count=&quot;0&quot; data-linked-resource-id=&quot;31548300&quot; data-linked-resource-version=&quot;1&quot; data-linked-resource-type=&quot;attachment&quot; data-linked-resource-default-alias=&quot;过度绘制颜色图谱.png&quot; data-base-url=&quot;https://wiki.kaiyuan.net&quot; data-linked-resource-content-type=&quot;image/png&quot; data-linked-resource-container-id=&quot;31548307&quot; data-linked-resource-container-version=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;原色&lt;/em&gt;&lt;/strong&gt; – &lt;em&gt;没有被过度绘制&lt;/em&gt; – 这部分的像素点只在屏幕上绘制了一次。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;蓝色&lt;/em&gt;&lt;/strong&gt; – &lt;em&gt;1次过度绘制&lt;/em&gt;– 这部分的像素点只在屏幕上绘制了两次。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;绿色&lt;/em&gt;&lt;/strong&gt; – &lt;em&gt;2次过度绘制&lt;/em&gt; – 这部分的像素点只在屏幕上绘制了三次。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;粉色&lt;/em&gt;&lt;/strong&gt; – &lt;em&gt;3次过度绘制&lt;/em&gt; – 这部分的像素点只在屏幕上绘制了四次。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;红色&lt;/em&gt;&lt;/strong&gt; – &lt;em&gt;4次过度绘制&lt;/em&gt; – 这部分的像素点只在屏幕上绘制了五次。&lt;/p&gt;
&lt;p&gt;我们的目标是尽量减少红色，看到更多的蓝色！！！&lt;/p&gt;
&lt;p&gt;以轻易贷为例：&lt;/p&gt;
&lt;div&gt;&lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;&lt;img class=&quot;confluence-embedded-image&quot; src=&quot;https://wiki.kaiyuan.net/download/attachments/31548307/%E8%BD%BB%E6%98%93%E8%B4%B7%E8%BF%87%E5%BA%A6%E7%BB%98%E5%88%B6%E5%9B%BE.png?version=1&amp;amp;modificationDate=1558265534000&amp;amp;api=v2&quot; alt=&quot;&quot; height=&quot;250&quot; data-image-src=&quot;/download/attachments/31548307/%E8%BD%BB%E6%98%93%E8%B4%B7%E8%BF%87%E5%BA%A6%E7%BB%98%E5%88%B6%E5%9B%BE.png?version=1&amp;amp;modificationDate=1558265534000&amp;amp;api=v2&quot; data-unresolved-comment-count=&quot;0&quot; data-linked-resource-id=&quot;31548304&quot; data-linked-resource-version=&quot;1&quot; data-linked-resource-type=&quot;attachment&quot; data-linked-resource-default-alias=&quot;轻易贷过度绘制图.png&quot; data-base-url=&quot;https://wiki.kaiyuan.net&quot; data-linked-resource-content-type=&quot;image/png&quot; data-linked-resource-container-id=&quot;31548307&quot; data-linked-resource-container-version=&quot;1&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h5 id=&quot;Android布局渲染流程与卡顿优化-3.如何避免过度绘制&quot;&gt;3.如何避免过度绘制&lt;/h5&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;1)避免UI层级嵌套的过深&lt;/p&gt;
&lt;p&gt;2)减少不必要的背景设置（根节点背景是否可以不要、系统主题背景是否可以不要等等）&lt;/p&gt;
&lt;p&gt;3)使用merge标签减少布局嵌套层次&lt;/p&gt;
&lt;p&gt;4)使用ConstraintLayout替代常见嵌套布局，减少布局层次&lt;/p&gt;
&lt;p&gt;5)在自定义view的时候，使用Canvas的clipRect和clipPath方法限制View的绘制区域（覆盖区域不需要绘制）&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 20 May 2019 16:48:00 +0000</pubDate>
<dc:creator>CurtisWgh</dc:creator>
<og:description>一、手机界面UI渲染显示流程 二、16ms原则 三、造成卡顿的原因 四、过度绘制介绍、检测工具、如何避免造成过度绘制造成的卡顿</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/upwgh/p/10897576.html</dc:identifier>
</item>
<item>
<title>MySQL（12）---纪录一次left join一对多关系而引起的BUG - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10897315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10897315.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;&lt;code&gt;BUG背景&lt;/code&gt; 我们有一个&lt;strong&gt;订单表&lt;/strong&gt; 和 一个 &lt;strong&gt;物流表&lt;/strong&gt; 它们通过 &lt;strong&gt;订单ID&lt;/strong&gt; 进行一对一的关系绑定。但是由于物流表在保存订单信息的时候没有做判断该订单是否已经有物流信息，&lt;br/&gt;这就变成同一个订单id在物流表中存在多条数据，也就变成了本来订单表只有100条纪录，而left join 物流表后，所查询的订单数据远远大于100条。&lt;br/&gt;&lt;code&gt;总结&lt;/code&gt; 趁着上面这个问题，自己来复习下&lt;code&gt;join语句&lt;/code&gt; 和 &lt;code&gt;distinct&lt;/code&gt;关键字，同时说明如何解决就算关联是一对多，但我还是想只显示100条订单数据的方法。&lt;/p&gt;
&lt;h2 id=&quot;一理论&quot;&gt;&lt;span&gt;一、理论&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;先再讲下关联表查询的几种表达式，网上找了一张图，通过这张图就能理解所有关联查询的含义。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190520233002027-1421406253.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;left join(左联接)&lt;/code&gt; 返回包括&lt;code&gt;左表&lt;/code&gt;中的所有记录和右表中联结字段相等的记录 。&lt;br/&gt;&lt;code&gt;right join(右联接)&lt;/code&gt; 返回包括&lt;code&gt;右表&lt;/code&gt;中的所有记录和左表中联结字段相等的记录。&lt;br/&gt;&lt;code&gt;inner join(等值连接)&lt;/code&gt; 只返回两个表中联结字段相等的行。&lt;/p&gt;

&lt;h2 id=&quot;二left-join一对一和一对多&quot;&gt;&lt;span&gt;二、left join一对一和一对多&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;一对一关联表查询&quot;&gt;1、一对一关联表查询&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;业务逻辑1&lt;/code&gt; 有两张表，一张商品表、一张商品订单表回显订单列表的时候需要订单表关联商品表，如下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）商品表&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;DROP TABLE IF EXISTS `t_product`;
CREATE TABLE `t_product` (
  `product_id` char(32) NOT NULL DEFAULT '' COMMENT '主键ID',
  `pro_name` varchar(64) DEFAULT NULL COMMENT '商品名称',
  `cash` double(10,2) DEFAULT '0.00' COMMENT '商品价格',
  `pro_code` varchar(32) DEFAULT NULL COMMENT '商品编号',
  PRIMARY KEY (`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='商品表';

INSERT INTO `t_product` (`product_id`, `pro_name`, `cash`, `pro_code`)
VALUES
    ('1','小米',888.00,'001'),
    ('2','华为',1888.00,'002');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2) 订单表&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;DROP TABLE IF EXISTS `t_order`;
CREATE TABLE `t_order` (
  `order_id` char(32) NOT NULL DEFAULT '' COMMENT '主键ID',
  `product_id` char(32) DEFAULT NULL COMMENT '商品ID',
  `sale_amount` double(16,2) DEFAULT '0.00' COMMENT '订单金额',
  `order_number` varchar(40) DEFAULT NULL COMMENT '订单编码',
  `status` int(2) DEFAULT '1' COMMENT '订单状态 0订单无效1兑换功成2、已发货',
  PRIMARY KEY (`order_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='订单表';

INSERT INTO `t_order` (`order_id`, `product_id`, `sale_amount`, `order_number`, `status`)
VALUES
    ('1','1',888.00,'001001',1),
    ('2','2',1888.00,'001002',1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3) 关联查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里需要展示订单列表，订单列表中当然需要展示商品信息。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select o.`order_id`,o.`sale_amount`,p.`pro_name` from t_order o left join t_product p on o.`product_id`=p.`product_id`;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190520233436222-275585350.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两张表不可能是一对多的关系，因为左表关联右表的主键ID,所有右表不可能出现多条纪录。&lt;/p&gt;
&lt;h4 id=&quot;left-join有一对多关联查询&quot;&gt;2、left join有一对多关联查询&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;业务逻辑2&lt;/code&gt; 这里是逻辑也是有两张表，一张订单表、一张物流表。订单表和上面一样，数据也一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;物流表&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;DROP TABLE IF EXISTS `t_logistics`;
CREATE TABLE `t_logistics` (
  `logistics_id` char(32) NOT NULL DEFAULT '' COMMENT '主键ID',
  `order_id` char(32) DEFAULT NULL COMMENT '订单ID',
  `logistics_company_name` varchar(32) DEFAULT NULL COMMENT '物流公司名称',
  `courier_number` varchar(32) DEFAULT NULL COMMENT '快递单号',
  PRIMARY KEY (`logistics_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='物流信息表';

INSERT INTO `t_logistics` (`logistics_id`, `order_id`, `logistics_company_name`, `courier_number`)
VALUES
    ('1','1','顺丰','001'),
    ('2','1','顺丰','002');
    ('3','2','中通','003');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; 这张表数据是有问题的，因为不可能一个订单同时有两条物流信息，但是你不能完全排除这条表里存在两条相同订单编号，因为左表绑定的不是右表的主键ID,这可能就是保留物流信息的时候没有判断该订单已经保存物流信息，而引起的数据重复问题。&lt;/p&gt;
&lt;p&gt;那么这个时候问题来了。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select o.`order_id`,o.`sale_amount`,l.`logistics_company_name` from t_order o left join t_logistics l on o.`order_id`=l.`order_id`;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190520233538236-1538203737.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现，订单列表已经有三条纪录，但按照常理应该展示两条。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; 所以从这里我们可以得知，如果你在left join 时，需要显示的数据的左表数据不能重复时，那么就需要 on 后面的表它们的对应关系是一对一的关系。显然这里对于order_id为1所对应的物流表信息是一对多的关系。&lt;/p&gt;

&lt;h2 id=&quot;三如何解决一对多的问题&quot;&gt;&lt;span&gt;三、如何解决一对多的问题&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;一对多并不一定是问题，主要还是看表与表之间的关系。比如：&lt;br/&gt;A表是用户表，B表是订单表。自然也就想到了一个用户可能多次下单。我们假设B表中的用户id在A表中匹配到50个用户id，但是这50个用户id总订单数是500个。这就是合理的一对多关系。&lt;/p&gt;
&lt;p&gt;那么如果你业务逻辑肯定显示一对一的关系，而表关系确实一对多的关系，就像上面的订单表和物流表一样。怎么解决，这里有两种解决方案。&lt;/p&gt;
&lt;h4 id=&quot;group-by&quot;&gt;1、group by&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;关键点&lt;/code&gt; &lt;strong&gt;把一对多的问题转化成聚合查询&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select o.`order_id`,o.`sale_amount`,l.`logistics_company_name` from t_order o left join t_logistics l on o.`order_id`=l.`order_id` group by o.`order_id`;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190520233615861-399275300.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;distinct&quot;&gt;2、distinct&lt;/h4&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select distinct o.`order_id`,o.`sale_amount`,l.`logistics_company_name` from t_order o left join t_logistics l on o.`order_id`=l.`order_id`;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190520233625319-1013509584.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它所得的的结果和上面是一样的。&lt;/p&gt;
&lt;h4 id=&quot;group-by-和-distinct-比较&quot;&gt;3、group by 和 distinct 比较&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1）、不同&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;distinct需要将col列中的全部内容都存储在一个内存中，可以理解为一个&lt;code&gt;hash结构，key为col的值&lt;/code&gt;，最后计算hash结构中有多少个key即可得到结果。很明显，需要将所有不同的值都存起来。内存消耗可能较大。&lt;/li&gt;
&lt;li&gt;而group by的方式是先将&lt;code&gt;col排序&lt;/code&gt;。而数据库中的group一般使用sort的方法，即数据库会先对col进行排序。而排序的基本理论是，时间复杂为nlogn，空间为1。然后只要单纯的计数就可以了。优点是空间复杂度小，缺点是要进行一次排序，执行时间会较长。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）、使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;离散&lt;/td&gt;
&lt;td&gt;group&lt;/td&gt;
&lt;td&gt;distinct空间占用较大，在时间复杂度允许的情况下，group 可以发挥空间复杂度优势&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;集中&lt;/td&gt;
&lt;td&gt;distinct&lt;/td&gt;
&lt;td&gt;distinct空间占用较小，可以发挥时间复杂度优势&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;3）、两个极端&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据列的所有数据都一样，即去重计数的结果为1时，用distinct最佳。&lt;/li&gt;
&lt;li&gt;如果数据列唯一，没有相同数值，用group 最好。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四distinct&quot;&gt;&lt;span&gt;四、distinct&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;作用于单列&quot;&gt;1、作用于单列&lt;/h4&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select distinct name from A   #name去重&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;作用于多列&quot;&gt;2、作用于多列&lt;/h4&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select distinct name, age from A  #根据name和age两个字段来去重的&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;count统计&quot;&gt;3、COUNT统计&lt;/h4&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select count(distinct name) from A;   #表中name去重后的数目&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;： count是不能统计多个字段的，下面的SQL在SQL Server和Access中都无法运行。&lt;/p&gt;
&lt;p&gt;若想使用多个字段，请使用嵌套查询，如下：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select count(*) from (select distinct name, age from A) AS B;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;distinct必须放在开头&quot;&gt;4、distinct必须放在开头&lt;/h4&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select age, distinct name from A;   #会提示错误，因为distinct必须放在开头&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;补充&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1、能用&lt;code&gt;inner join&lt;/code&gt; 尽量用inner join。&lt;br/&gt;2、重复数据可能是表结构一对多造成的，这种情况往往是有意义的，比如订单和订单商品明细，算总价的时候，是需要sum多个明细的。&lt;br/&gt;3、如果一对多的多确实没有意义，那就可以考虑用group by 或者 distinct。&lt;br/&gt;4、具体结构问题具体分析。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/left%20join/10085390?fr=aladdin&quot;&gt;1、left join百度百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/db050b8914b2&quot;&gt;2、left join的用法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/leonlee/p/6042461.html&quot;&gt;3、SQL中distinct的用法&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（少将15）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 20 May 2019 15:49:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>MySQL（11） 纪录一次left join一对多关系而引起的bug 我们有一个 订单表 和 一个 物流表 它们通过 订单ID 进行一对一的关系绑定。但是由于物流表在保存订单信息的时候没有做判断该订</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10897315.html</dc:identifier>
</item>
<item>
<title>数据可视化-svg入门基础（二） - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/10897321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/10897321.html</guid>
<description>&lt;p&gt;接上一篇：&lt;span&gt;&lt;a href=&quot;https://www.mwcxs.top/page/607.html&quot; target=&quot;_blank&quot;&gt;数据可视化-svg入门基础（一）&lt;/a&gt;，基础一主要是介绍了svg概念，元素样式设置等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;svg是（scalable vector graphic）伸缩矢量图像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）图形元素&lt;/p&gt;
&lt;p&gt;（2）文字元素&lt;/p&gt;
&lt;p&gt;（3）特殊元素&lt;/p&gt;
&lt;p&gt;（4）滤镜元素&lt;/p&gt;
&lt;p&gt;（5）渐变元素&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、图形元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、矩形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;矩形使用&amp;lt;rect&amp;gt;&amp;lt;/rect&amp;gt;标签来进行绘制。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25c8naDpir8Ms5L6nlrC39cU99.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rect &lt;span class=&quot;hljs-attr&quot;&gt;x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;rx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;5&quot; &lt;span class=&quot;hljs-attr&quot;&gt;ry=&lt;span class=&quot;hljs-string&quot;&gt;&quot;5&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;yellow&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rect&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;（1）x：左上角x的坐标，距离左边的距离，相当于margin-left；&lt;/p&gt;
&lt;p&gt;（2）y：左上角y的坐标，距离顶部的距离，相当于margin-top；&lt;/p&gt;
&lt;p&gt;（3）width：矩形的宽度；&lt;/p&gt;
&lt;p&gt;（4）height：矩形的高度；&lt;/p&gt;
&lt;p&gt;（5）rx：圆角矩形，x轴方向的半径；&lt;/p&gt;
&lt;p&gt;（6）ry：圆角矩形，y轴方向的半径&lt;/p&gt;
&lt;p&gt;（7）fill：填充颜色&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、圆形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;圆形使用&amp;lt;circle&amp;gt;&amp;lt;/circle&amp;gt;标签来进行绘制。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25-FITb75rgq5nmIFUCdYVrL6Q.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;circle &lt;span class=&quot;hljs-attr&quot;&gt;cx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;50&quot; &lt;span class=&quot;hljs-attr&quot;&gt;cy=&lt;span class=&quot;hljs-string&quot;&gt;&quot;50&quot; &lt;span class=&quot;hljs-attr&quot;&gt;r=&lt;span class=&quot;hljs-string&quot;&gt;&quot;40&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;yellow&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;circle&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;（1）cx：圆形的x坐标；&lt;/p&gt;
&lt;p&gt;（2）cy：圆心的y做标；&lt;/p&gt;
&lt;p&gt;（3）r：半径&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、椭圆形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;椭圆形使用标签&amp;lt;ellipse&amp;gt;&amp;lt;/ellipse&amp;gt;标签进行绘制，与圆形的绘制方法类似。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/251TUxWTpnEsgFSneTPDWWk577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;ellipse &lt;span class=&quot;hljs-attr&quot;&gt;cx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;50&quot; &lt;span class=&quot;hljs-attr&quot;&gt;cy=&lt;span class=&quot;hljs-string&quot;&gt;&quot;50&quot; &lt;span class=&quot;hljs-attr&quot;&gt;rx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;40&quot; &lt;span class=&quot;hljs-attr&quot;&gt;ry=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;yellow&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;ellipse&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;cx：圆心的x坐标；&lt;/p&gt;
&lt;p&gt;cy：圆心的y坐标；&lt;/p&gt;
&lt;p&gt;rx：水平方向上的半径；&lt;/p&gt;
&lt;p&gt;ry：垂直方向上的半径&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、线段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线段使用&amp;lt;line&amp;gt;&amp;lt;/line&amp;gt;标签进行绘制。&lt;/p&gt;
&lt;p&gt;实例代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;line &lt;span class=&quot;hljs-attr&quot;&gt;x1=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y1=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;x2=&lt;span class=&quot;hljs-string&quot;&gt;&quot;90&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y2=&lt;span class=&quot;hljs-string&quot;&gt;&quot;90&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;yellow&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;line&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;x1：起点的x坐标；&lt;/p&gt;
&lt;p&gt;y1：起点的y坐标；&lt;/p&gt;
&lt;p&gt;x2：终点的x坐标；&lt;/p&gt;
&lt;p&gt;y2：终点的y坐标&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、折线和多边形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;折线和多边形的绘制方法类似，都是&lt;strong&gt;用points属性设置各个点的坐标&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;折线使用标签&amp;lt;polyline&amp;gt;&amp;lt;/polyline&amp;gt;进行绘制，而多边形使用标签&amp;lt;polygon&amp;gt;&amp;lt;/polygon&amp;gt;进行绘制，且多边形会将起点和终点连接起来，折线不会。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25BNqvOW1MP-3H_7S3S2avqUS_.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;ponits：设置各个点的坐标，各组坐标之间使用空格分隔，x坐标和y坐标之间使用逗号分开。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路径使用标签&amp;lt;path&amp;gt;&amp;lt;/path&amp;gt;进行绘制，使用d属性控制路径的类型和绘制。路径的功能最多，前面的所有图形都可以使用路径进行绘制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;d属性值&lt;/strong&gt;的书写有两种，使用逗号分隔坐标，如：d=&quot;M10, 10&quot;，也可以使用空格的形式，如：d=&quot;M 10 10&quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：大写字母：表示坐标系中使用绝对坐标，小写字母：使用相对坐标（相对当前画笔所在的点）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.1移动类参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;M：moveto，将画笔移动到指定坐标，如：d=&quot;M10,10&quot;，表示将画笔移动到坐标(10,10)的位置。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25BK3EhVKiWd4YzJJGU9Quj_zR.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
    &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;path &lt;span class=&quot;hljs-attr&quot;&gt;d=&lt;span class=&quot;hljs-string&quot;&gt;&quot;M 10 10 L 180 180&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#fb3&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke-width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;4&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;transparent&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;path&amp;gt;
   &amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6.2绘制直线类参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;L：lineto，绘制直线到指定坐标，如：d=&quot;M 10 10 L 80 80&quot;，表示绘制一条起点坐标为(10,10)，终点坐标为(80,80)的直线。&lt;/p&gt;
&lt;p&gt;H：horizontal  lineto，绘制水平直线到指定坐标，如：d=&quot;M 10 10 H 100&quot;，表示是绘制一条起点坐标为(10,10)，终点坐标为(100,10)的直线，注意：H只需要设置一个值，如果设置了多个值，则最后取最后一个值。&lt;/p&gt;
&lt;p&gt;V：vertical，绘制垂直直线到指定坐标，如：d=&quot;M 10 10 V 100&quot;，表示绘制一条起点坐标(10,10)，终点坐标为(10,100)的直线，注意：V只需要设置一个值，如果是多个值，则取最后一个值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.3绘制曲线类参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C：curveto，绘制三次方贝塞尔曲线到终点坐标，中间经过两个控制点控制曲线的弧度，所以需要制定三个坐标来实现绘制曲线，如：d=&quot;M10,10 C40,5 40,140 100,100&quot;&lt;/p&gt;
&lt;p&gt;S：shorthand/smooth curveto，绘制平滑三次方贝塞尔曲线到终点坐标，与上一条三次方贝塞尔曲线相连，第一个控制点为上一条曲线第二个控制点的对称点，所以还需制定一个控制点坐标和终点坐标。如：d=&quot;M10,10 C40,5 40,140 100,100 S140,180 160,160&quot;，如果不与贝塞尔曲线相连，即：&lt;code&gt;d=&quot;M10,10 S140,180 160,160&quot;&lt;/code&gt;，则绘制的图线接近于二次贝塞尔曲线&lt;/p&gt;
&lt;p&gt;Q：quadratic Bezier curveto，绘制二次贝塞尔曲线到终点坐标，中间经过一个控制点控制曲线的弧度，如：&lt;code&gt;d=&quot;M10,10 Q40,140 100,100&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;T：shorthand/smooth quadratic Bezier curveto，绘制平湖二次贝塞尔曲线到终点坐标，与上一条二次贝塞尔曲线相连，控制点为上一条曲线控制点的对称点，所以还需指定一个终点坐标，如：&lt;code&gt;d=&quot;M10,10 Q40,140 100,100 T160,160&quot;&lt;/code&gt;，如果不与贝塞尔曲线相连，即：&lt;code&gt;d=&quot;M10,10 T160,160&quot;&lt;/code&gt;，则绘制的图线是一条直线。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/255OVGtyxAMErS5_K9x58h8MeR.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;/&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6.4绘制弧线类参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：el liptical arc，绘制椭圆曲线到指定坐标，需设置的参数有：&lt;/p&gt;
&lt;p&gt;（1）rx，ry：x轴方向半径，y轴方向半径；&lt;/p&gt;
&lt;p&gt;（2）x-axis-rotation：x轴与水平顺时针方向夹角；&lt;/p&gt;
&lt;p&gt;（3）large-arc-flag：角度弧线大小(1：大，0：小)；&lt;/p&gt;
&lt;p&gt;（4）sweep-flag：绘制方向(1：顺时针，0：逆时针)；&lt;/p&gt;
&lt;p&gt;（5）x y：终点坐标&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/2531Bh_qezmbbyvfpl7naL_1yd.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;500&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;500&quot;&amp;gt;
    &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;path &lt;span class=&quot;hljs-attr&quot;&gt;d=&lt;span class=&quot;hljs-string&quot;&gt;&quot;M50,50 A60 30 0 1,0 150,50 Z&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#fb3&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke-width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;4px&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;transparent&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;path&amp;gt;
  &amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析：起点坐标(50,50)，终点坐标(150,50)，角度为0，角度弧线大小large-arc-flag为1，选择大弧度，根据分析，即选择红色的弧线，又绘制方向sweep-flag为0，为逆时针，即从起点沿着逆时针方向绘制到终点，所以是红色虎先位于下方。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25Zgms5XiFsD46jdWS8OtvqyG7.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：当 (起点与终点之间的直线距离／2) &amp;gt; (椭圆的水平半径) 时，角度为0的情况下，此时椭圆会等比放大，到相等为止。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.5闭合类参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Z：closepath，绘制直线将终点与起点连接&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再次提醒：大写字母：表示坐标系中使用绝对坐标，小写字母：使用相对坐标（相对当前画笔所在的点）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、文字元素&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在svg中使用&amp;lt;text&amp;gt;&amp;lt;/text&amp;gt;标签绘制文字。&lt;/p&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;x：文字的x坐标；&lt;/p&gt;
&lt;p&gt;y：文字的y坐标；&lt;/p&gt;
&lt;p&gt;dx：相对于当前位置x方向的距离；&lt;/p&gt;
&lt;p&gt;dy：相对于当前位置的y方向的距离；&lt;/p&gt;
&lt;p&gt;textLength：文字的显示长度；&lt;/p&gt;
&lt;p&gt;rotate：旋转角度，也可以使用transform=&quot;rotate(30)&quot;&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25sFxc5Pc9GhxEFUPR2pvVLbW9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;text &lt;span class=&quot;hljs-attr&quot;&gt;x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;dx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;dy=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;textLength=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;rotate=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot;&amp;gt;示例文字&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;text&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2、文本路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果要实现文字沿着路径进行排列，可使用&amp;lt;textPath&amp;gt;&amp;lt;/textPath&amp;gt;标签来实现。需要提前定义好路径path，并指定id，textPath使用xlink:href定义文字要匹配的路径。&lt;/p&gt;
&lt;p&gt;示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25gt-dM_wTfbAYOTzxIlZ5BSIf.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;600&quot; height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;600&quot;&amp;gt;
        &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;path &lt;span class=&quot;hljs-attr&quot;&gt;id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;textPath1&quot; &lt;span class=&quot;hljs-attr&quot;&gt;d=&lt;span class=&quot;hljs-string&quot;&gt;&quot;M100,100 C140,50 140,240 200,200 S240,280 360,360&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#fb3&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke-width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;4px&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;transparent&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;path&amp;gt;
        &amp;lt;text x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; dx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;-10&quot; dy=&lt;span class=&quot;hljs-string&quot;&gt;&quot;-10&quot; rotate=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot;&amp;gt;
          &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;textPath &lt;span class=&quot;hljs-attr&quot;&gt;xlink:href=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#textPath1&quot; &lt;span class=&quot;hljs-attr&quot;&gt;textLength=&lt;span class=&quot;hljs-string&quot;&gt;&quot;300&quot;&amp;gt;
            很扭曲的测试示例文字
          &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;textPath&amp;gt;
        &amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/text&amp;gt;
      &amp;lt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、特殊元素&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、克隆元素use&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;use&lt;/code&gt;标签用来克隆其他元素，克隆后的元素不能修改样式。 示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25dzTXQNGnSga8L1S3BKst5GOS.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rect &lt;span class=&quot;hljs-attr&quot;&gt;id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;rect1&quot;
        &lt;span class=&quot;hljs-attr&quot;&gt;x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot;
        &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#5588aa&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke-width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;5&quot;
        &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;transparent&quot;
  &amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rect&amp;gt;
  &amp;lt;use x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot; y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot; xlink:href=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#rect1&quot;&amp;gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;use&amp;gt;
  &amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;x：相对被克隆元素x轴偏移量；&lt;/p&gt;
&lt;p&gt;y：相对被克隆元素y轴偏移量；&lt;/p&gt;
&lt;p&gt;xlink:href：指向被克隆元素的ID&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、模板元素symbol&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;symbol&lt;/code&gt;标签用定义模版，需要结合&lt;code&gt;use&lt;/code&gt;标签使用，模版在未被使用之前，不会展示在页面上。模版内部可包含多个元素&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;symbol &lt;span class=&quot;hljs-attr&quot;&gt;id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;template1&quot;&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rect &lt;span class=&quot;hljs-attr&quot;&gt;x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot;
          &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#5588aa&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke-width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;5&quot;
          &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;transparent&quot;
    &amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rect&amp;gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;symbol&amp;gt;
  &amp;lt;use x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot; y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot; xlink:href=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#template1&quot;&amp;gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;use&amp;gt;
  &amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3、组元素g&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;group&lt;/code&gt;的简写，用来创建分组，&lt;strong&gt;组内所有的元素都会继承&lt;code&gt;g&lt;/code&gt;的属性，可以嵌套使用&lt;/strong&gt;，也可以和&lt;code&gt;use&lt;/code&gt;标签结合使用。另外可使用transform属性定义控制整个组的位置。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;g &lt;span class=&quot;hljs-attr&quot;&gt;stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;#5588aa&quot; &lt;span class=&quot;hljs-attr&quot;&gt;stroke-width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;5&quot; &lt;span class=&quot;hljs-attr&quot;&gt;fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;transparent&quot;&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rect &lt;span class=&quot;hljs-attr&quot;&gt;x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;10&quot; &lt;span class=&quot;hljs-attr&quot;&gt;width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rect&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rect &lt;span class=&quot;hljs-attr&quot;&gt;x=&lt;span class=&quot;hljs-string&quot;&gt;&quot;120&quot; &lt;span class=&quot;hljs-attr&quot;&gt;y=&lt;span class=&quot;hljs-string&quot;&gt;&quot;120&quot; &lt;span class=&quot;hljs-attr&quot;&gt;width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rect&amp;gt;
  &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;g&amp;gt;
&amp;lt;&lt;span class=&quot;hljs-regexp&quot;&gt;/svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;g&lt;/code&gt;标签内部的两个矩形，都会继承&lt;code&gt;g&lt;/code&gt;标签的样式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、clipPath裁剪元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lipPath&lt;/code&gt;元素主要用来剪裁元素，&lt;code&gt;clipPath&lt;/code&gt;元素定义范围外的内容将不会被展示。另外要注意写在&lt;code&gt;&amp;lt;clipPath&amp;gt;&amp;lt;/clipPath&amp;gt;&lt;/code&gt;标签内部的元素不会被显示，clipPath标签需要放在defs标签内。其他元素在引用clipPath元素时，需要使用&lt;code&gt;clip-path=&quot;url(#ID)&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;javascript hljs&quot;&gt;&amp;lt;svg height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot; width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&amp;gt;
    &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;defs&amp;gt;
      &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;clipPath &lt;span class=&quot;hljs-attr&quot;&gt;id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;clip&quot;&amp;gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;rect &lt;span class=&quot;hljs-attr&quot;&gt;width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot; &lt;span class=&quot;hljs-attr&quot;&gt;height=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;rect&amp;gt;
      &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;clipPath&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;defs&amp;gt;
    &amp;lt;circle cx=&lt;span class=&quot;hljs-string&quot;&gt;&quot;90&quot; cy=&lt;span class=&quot;hljs-string&quot;&gt;&quot;90&quot; r=&lt;span class=&quot;hljs-string&quot;&gt;&quot;90&quot; clip-path=&lt;span class=&quot;hljs-string&quot;&gt;&quot;url(#clip)&quot; stroke=&lt;span class=&quot;hljs-string&quot;&gt;&quot;none&quot; fill=&lt;span class=&quot;hljs-string&quot;&gt;&quot;yellow&quot; /&amp;gt;
  &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;svg&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25rps4ldeJhPPawOFN3z3BmSMZ.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/257E0NtUaDFefMyJRg5jgWSIpH.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 20 May 2019 15:33:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>接上一篇：数据可视化-svg入门基础（一），基础一主要是介绍了svg概念，元素样式设置等。 svg是（scalable vector graphic）伸缩矢量图像。 一、目录 （1）图形元素 （2）文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/10897321.html</dc:identifier>
</item>
<item>
<title>使用Try.NET创建可交互.NET文档 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10894497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10894497.html</guid>
<description>&lt;blockquote readability=&quot;2.5357142857143&quot;&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/creating-interactive-net-documentation/&quot;&gt;Create Interactive .NET Documentation with Try .NET&lt;/a&gt;&lt;br/&gt;原文作者：Maria&lt;br/&gt;译文地址：&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/10894497.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lwqlun/p/10894497.html&lt;/a&gt;&lt;br/&gt;译者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当我们编写开发人员使用的文档时，我们需要捕捉他们的兴趣，并引导他们尽快走上成功的道路。开发人员生态系统一直在为社区提供可交互的文档，用户可以一个地方阅读文档，运行代码并进行编辑。&lt;/p&gt;
&lt;p&gt;在过去的2年里，.NET语言团队一直在不断发展Try .NET, 以支持在线和离线的交互式文档。&lt;/p&gt;

&lt;p&gt;Try .NET是一个基于.NET Core的交互式文档生成器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230645016-1266379729.png&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2017年9月，Try .NET第一次在&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/intro-to-csharp/&quot;&gt;docs.microsoft.com&lt;/a&gt;中使用，开发人员可以使用Azure Container实例运行代码。然而在过去的5个月内，我们改用Blazor和Web Assembly作为代码执行客户端。&lt;/p&gt;
&lt;p&gt;你可以自己访问如下&lt;a href=&quot;https://docs.microsoft.com/dotnet/csharp/tutorials/intro-to-csharp/hello-world?tutorial-step=5&quot;&gt;链接&lt;/a&gt;, 并打开开发者工具。在控制台标签页中，你可以看到如下信息&lt;code&gt;WASM:Initialized&lt;/code&gt;, 切换到网络标签页，你将看到所有在客户端执行的DLL。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230736840-1047370574.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;控制台标签页： &lt;code&gt;*WASM Initialized*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230744627-197226262.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网络标签页： DLLs&lt;/p&gt;

&lt;p&gt;对我们而言，离线版和在线版一样的重要。针对离线体验，对我们而言，创建一种可以融入内容作者工作流程的体验是非常重要的。&lt;/p&gt;
&lt;p&gt;在我们的调查结果中，我们注意到内容开发人员(content developers)在创建开发人员文档时，经常使用2种说明方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个用户可以下载并运行的实例。&lt;/li&gt;
&lt;li&gt;一些Markdown文件，其中包含一系列说明，以及从代码库复制黏贴的的代码片段。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Try .NET提供了全局工具dotnet try, 以方便.NET开发人员创建可交互的Markdown文件。&lt;/p&gt;
&lt;p&gt;为了使你的Markdown文件具有交互性，你需要安装.NET Core的SDK, 全局工具dotnet try, 以及Visual Studio / VS Code。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230754830-708974414.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;扩展markdown&quot;&gt;扩展Markdown&lt;/h2&gt;
&lt;p&gt;在Markown文件中，你会使用隔离代码块来突出显示代码段。在代码块的前后，你会使用```来包裹它们。你可以添加可选的语言标识符，启用针对代码段的语法突出显示。&lt;/p&gt;
&lt;p&gt;例：C#的代码块&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;​``` cs 
var name =&quot;Rain&quot;;
Console.WriteLine($&quot;Hello {name.ToUpper()}!&quot;);
​```&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Try .NET, 我们可以扩展隔离代码块，给它添加一些额外的参数。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;​``` cs --region methods --source-file .\myapp\Program.cs --project .\myapp\myapp.csproj 
var name =&quot;Rain&quot;;
Console.WriteLine($&quot;Hello {name.ToUpper()}!&quot;);
​```&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们使用了3个参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;--region&lt;/code&gt;参数 - 指定一个C#的分块(region)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--source-file&lt;/code&gt;参数 - 指定程序文件的目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--project&lt;/code&gt;参数 - 指定项目文件和引用的系统程序集&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，以上示例中，我们做的事情是，当你运行Try .NET的解析你的Markdown文件的时候，程序会去尝试引用&lt;code&gt;Program.cs&lt;/code&gt;文件中名为&lt;code&gt;methods&lt;/code&gt;的分块代码。&lt;/p&gt;
&lt;h2 id=&quot;使用regions&quot;&gt;使用&lt;code&gt;#regions&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在Markdown中，我们扩展了代码块，提供了&lt;code&gt;--region&lt;/code&gt;参数，用它可以指定C#代码中的分块(region)。&lt;br/&gt;所以，你的&lt;code&gt;Program.cs&lt;/code&gt;文件看起来可能是这样的。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;
 
namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            #region methods
            var name =&quot;Rain&quot;
            Console.WriteLine($&quot;Hello{name.ToUpper()}!&quot;);  
            #endregion
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dotnet-try-verify&quot;&gt;&lt;code&gt;dotnet try verify&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;dotnet try verify&lt;/code&gt;是一个文档编译器。使用这个命令，你可以确保每个代码块都能正常工作，并且和项目代码保持一致。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dotnet try verify&lt;/code&gt;命令的目的是为了验证你的文档按照你期望的样子工作。&lt;/p&gt;
&lt;p&gt;通过使用&lt;code&gt;dotnet try verify&lt;/code&gt;命令，你可以检测Markdown文件并编译错误。例如，如果我将之前代码中移除一个分号，并且将&lt;code&gt;methods&lt;/code&gt;代码分块改名为&lt;code&gt;method&lt;/code&gt;。现在如果运行编译器，会出现以下错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230807292-2140650136.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dotnet try&lt;/code&gt;现在已经可以使用了。这是一个&lt;code&gt;dotnet try&lt;/code&gt;全局工具的早期预览版，你可以从我们的&lt;a href=&quot;https://github.com/dotnet/try&quot;&gt;仓储&lt;/a&gt;克隆代码。&lt;/p&gt;
&lt;h2 id=&quot;入门&quot;&gt;入门&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;克隆代码仓储&lt;/li&gt;
&lt;li&gt;签出Samples分支&lt;/li&gt;
&lt;li&gt;安装.NET Core 2.1或3.0预览版&lt;/li&gt;
&lt;li&gt;打开控制台窗口&lt;/li&gt;
&lt;li&gt;安装Try .NET全局工具&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;dotnet tool install --global dotnet-try --version 1.0.19264.11&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新&lt;code&gt;dotnet try&lt;/code&gt;也很简单，只需要运行如下命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet tool update -g dotnet-try&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定位到当前仓储的&lt;code&gt;Samples&lt;/code&gt;目录，输入&lt;code&gt;dotnet try&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230821702-604534020.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浏览器会自动打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201905/65831-20190520230834097-1152273812.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在Try.NET已经在Github上开源了！由于我们仍处于早期开发阶段，所以目前我们无法接受任何功能的Pull Request, 但我们打算在未来这么做。请随时在我们的Issue列表中提交Bug报告。 如果你有任何功能建议，请在我们的Issue列表中使用社区建议的标签提交。&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 15:14:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文地址： 'Create Interactive .NET Documentation with Try .NET' 原文作者：Maria 译文地址： 译者：Lamond Lu 背景 当我们编写开发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10894497.html</dc:identifier>
</item>
<item>
<title>F#周报2019年第20期 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10896597.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10896597.html</guid>
<description>[unable to retrieve full-text content]新闻 &quot;2019年理事会活动&quot; &quot;&quot;实用的F 挑战&quot;意见截止日期接近，不要忘记提交博客文章或者其它作品&quot; &quot;接口中的默认实现&quot; &quot;.NET Core 3.0里的性能增强&quot; &quot;使用Try .NET创建交互性.NET文档&quot; &quot;新的Azure搜索文档包含F 示例&quot; &quot;eiriktsarpalis/dotn</description>
<pubDate>Mon, 20 May 2019 15:14:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>新闻 '2019年理事会活动' ''实用的F 挑战'意见截止日期接近，不要忘记提交博客文章或者其它作品' '接口中的默认实现' '.NET Core 3.0里的性能增强' '使用Try .NET创建交</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10896597.html</dc:identifier>
</item>
<item>
<title>打通电商多模式支持的“任督二脉” - 程序猿攻城狮</title>
<link>http://www.cnblogs.com/syjkfind/p/10897012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/syjkfind/p/10897012.html</guid>
<description>&lt;p&gt;你听说过任督二脉吗？像这样~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/448899/201905/448899-20190520220527179-450856610.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咳咳~今天不讲武功，讲电商平台设计的功夫~&lt;/p&gt;

&lt;p&gt;当今的电商可不仅仅是B2C商城，接下来还会有O2O，往后可能还会有商超、奥莱、二手交易。。。且称之为业务模式~而每个业务模式下还会有预售、竞拍、拼团等不同组合的子模式。&lt;/p&gt;
&lt;p&gt;可是我商城的商品列表页不想展示O2O的商品啊，商品列表的数据希望按一定规则相互隔离。其他模块，有的出于操作习惯的考虑不隔离，有的出于用户行为的考虑需要隔离。&lt;/p&gt;
&lt;p&gt;各模块数据隔离需求如下&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;3&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;列表页&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;商详页&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;商品组&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;优惠券&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;活动&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;订单&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;...&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;原商城&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;暂时不隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;暂时不隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;O2O&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;暂时不隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;暂时不隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;隔离&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;各模块流程差异&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;3&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;新建商品&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;列表页&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;购物车&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;订单&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;...&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;原商城&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;店铺创建，门店设置库存&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;基于item建es文档&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;跨门店&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;状态流转走快递&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;O2O&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;门店创建（沿用原模型但弱化店铺的概念）&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;基于item建es文档&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;单个门店&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;状态流转走配送&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;于是我们就会面临不同的改造的场景。&lt;/p&gt;
&lt;h2&gt;场景1，新建商品就是新建商品啊！！！&lt;/h2&gt;
&lt;p&gt;例如商品的新建保存，是基础服务，已经具备通用存储模型。为了支持新模式我还得改服务接口、发布二方包？咱可不可以这样？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;商品服务&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Integer bizMode =&lt;span&gt; BizModeContext.getBizMode();
itemDO.setBizMode(bizMode);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
itemDAO.save(itemDO);
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;场景2，下单就是下单啊！！！&lt;/h2&gt;
&lt;p&gt;例如创建订单，虽然商品维度、订单类型、优惠方式有很多，但我修改一下B2C下单的字段计算，还要引发O2O模式的回归测试？咱可不可以这样？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/448899/201905/448899-20190520221344079-1849689801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;甚至这样~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现类路由&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@BizModeService( bizMode=BizMode.B2C, srvClz=OrderTradeService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MallOrderTradeServiceImpl &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractOrderTradeService { }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用时&lt;/span&gt;
Integer bizMode =&lt;span&gt; BizModeContext.getBizMode();
OrderTradeService srv &lt;/span&gt;= BizModeRouter.routeBean(bizMode, OrderTradeService.&lt;span&gt;class&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;眼尖的小哥哥可能已经发现，要是能再搭配个热加载的bean容器，都可以做成插件了！emmm...那是远景~&lt;/p&gt;


&lt;p&gt;首先要舌尖抵住上颚，再来三个深呼吸~然后拿起一本《Thinking In Java》或《Core Java》假装在修炼。。。等等。。。什么是任督二脉？&lt;/p&gt;
&lt;p&gt;Java老司机都知道，我们通常会把ApplicationContext比作Spring的任督二脉，它贯穿始终，管理着bean的生命周期和传递。&lt;/p&gt;
&lt;p&gt;所以电商平台的任督二脉就是BizModeContext啦！它的经脉图大概长这样~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/syjkfind/p/10897012.html&quot; target=&quot;_blank&quot;&gt;文章出处&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/448899/201905/448899-20190520221709549-1638679454.png&quot; alt=&quot;&quot; width=&quot;829&quot; height=&quot;452&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们通过下面一二三四，入口处打标、dubbo服务间传递、RocketMQ传递、本机线程池内传递，一步一步打通整个标的透传。&lt;/p&gt;
&lt;h2&gt;步骤1-打标&lt;/h2&gt;
&lt;p&gt;aop按包路径切面+注解覆盖，满足你不同的定制需求~于是，在用户点击页面操作的那一刻，每个接口都被打上了“模式标”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注解打标&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ControllerConfig {
        @Aspect
        @Component
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CxcAdvice &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BizModeControllerAspect {
                 @Override
                 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getBizMode() {
                         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 300&lt;span&gt;;
                 }
                 @Override
                 @Pointcut(&lt;/span&gt;&quot;execution(* com.mall.web.controller..*(..))&quot;&lt;span&gt;)
                 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pointcut() {
                 }
        }
}
 
@Slf4j
@RestController
@MarkBizMode(bizMode &lt;/span&gt;= 200&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AdminOldController2 {
        @RequestMapping(&lt;/span&gt;&quot;/admin_anno_byclass&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String annoByClass() {
                 log.info(&lt;/span&gt;&quot;annoByClass got bizmode: &quot; +&lt;span&gt; BizModeContext.getBizMode());
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;this is &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass().toString();
        }
        @RequestMapping(&lt;/span&gt;&quot;/admin_anno_bymethod&quot;&lt;span&gt;)
        @MarkBizMode(bizMode &lt;/span&gt;= 100&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String annoByMethod() {
                 log.info(&lt;/span&gt;&quot;annoByMethod got bizmode: &quot; +&lt;span&gt; BizModeContext.getBizMode());
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;this is &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass().toString();
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;步骤2-dubbo服务传递&lt;/h2&gt;
&lt;p&gt;借助dubbo自带的Filter和RpcContext可以轻松实现。那是因为dubbo的设计中已经充分考虑了。&lt;/p&gt;
&lt;h3&gt;Filter的使用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;filter&lt;/strong&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@Activate(group =&lt;span&gt; Constants.CONSUMER)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BizModeDubboConsumerFilter &lt;span&gt;implements&lt;/span&gt; Filter { }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;filter配置扫描发现： /src/main/resources/META-INF/dubbo/com.alibaba.dubbo.rpc.Filter&lt;/p&gt;
&lt;p&gt;filter的装配原理： List&amp;lt;Filter&amp;gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);&lt;/p&gt;
&lt;p&gt;dubbo的SPI扩展机制就不具体展开啦~&lt;/p&gt;
&lt;h3&gt;RpcContext的生命周期&lt;/h3&gt;
&lt;p&gt;RpcContext -&amp;gt; RpcInvocation ---服务调用--- RpcInvocation -&amp;gt; RpcContext&lt;/p&gt;
&lt;p&gt;业务扩展的调用：RpcContext.getContext().setAttachment(&quot;bizMode&quot;, (bizMode.toString()));&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RpcContext.java&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个线程隔离的上下文实例&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; InternalThreadLocal&amp;lt;RpcContext&amp;gt; LOCAL = &lt;span&gt;new&lt;/span&gt; InternalThreadLocal&amp;lt;RpcContext&amp;gt;&lt;span&gt;() {
        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; RpcContext initialValue() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RpcContext();
        }
    };
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RpcContext getContext() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; LOCAL.get();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;dubbo对attachment的传递：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本机（当前线程）的保存：RpcContext&lt;/li&gt;
&lt;li&gt;远程调用的保存和传递：RpcInvocation&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;将RpcContext存入RpcInvocation：AbstractInvoker&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractInvoker&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt; Invoker&amp;lt;T&amp;gt;&lt;span&gt; {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Result invoke(Invocation inv) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RpcException {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节选。。。&lt;/span&gt;
        Map&amp;lt;String, String&amp;gt; context =&lt;span&gt; RpcContext.getContext().getAttachments();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
          invocation.addAttachmentsIfAbsent(context);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)){
          invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());
        }
        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节选。。。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return ...&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; Result doInvoke(Invocation invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;序列化与反序列化：DubboCodec （此处不展开）&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;从RpcInvocation取出，存入提供方的RpcContext：ContextFilter&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
@Activate(group = Constants.PROVIDER, order = -10000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ContextFilter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Filter {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Result invoke(Invoker&amp;lt;?&amp;gt; invoker, Invocation invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RpcException {
        Map&lt;/span&gt;&amp;lt;String, String&amp;gt; attachments =&lt;span&gt; invocation.getAttachments();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节选。。。&lt;/span&gt;
&lt;span&gt;                RpcContext.getContext().getAttachments().putAll(attachments);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节选。。。&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            RpcResult result &lt;/span&gt;=&lt;span&gt; (RpcResult) invoker.invoke(invocation);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pass attachments to result&lt;/span&gt;
&lt;span&gt;            result.addAttachments(RpcContext.getServerContext().getAttachments());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            RpcContext.removeContext();
            RpcContext.getServerContext().clearAttachments();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;步骤3-RocketMQ传递&lt;/h2&gt;
&lt;p&gt;RocketMQ设计时也预留了扩展打标的能力，只需要把模式标存入属性字段，就能跟随MQ把标传递到消费方。&lt;/p&gt;
&lt;h3&gt;消息体数据结构&lt;/h3&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;3&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;16.5&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;org.apache.rocketmq.common.message.Message&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;14&quot;&gt;
&lt;p&gt;private String topic;&lt;br/&gt;private int flag;&lt;br/&gt;private Map&amp;lt;String, String&amp;gt; properties;&lt;br/&gt;private byte[] body;&lt;/p&gt;

&lt;p&gt;//填入属性，仅包可见&lt;br/&gt;void putProperty(final String name, final String value);&lt;/p&gt;
&lt;p&gt;//填入自定义属性，与其他属性共享map，但对key过滤保留字&lt;br/&gt;public void putUserProperty(final String name, final String value);&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;org.apache.rocketmq.common.message.MessageExt&lt;/p&gt;
&lt;p&gt;是Message的子类&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt; private int queueId;&lt;/p&gt;
&lt;p&gt;private int storeSize;&lt;/p&gt;
&lt;p&gt;private long queueOffset;&lt;br/&gt;private int sysFlag;&lt;br/&gt;private long bornTimestamp;&lt;br/&gt;private SocketAddress bornHost;&lt;/p&gt;
&lt;p&gt;private long storeTimestamp;&lt;br/&gt;private SocketAddress storeHost;&lt;br/&gt;private String msgId;&lt;br/&gt;private long commitLogOffset;&lt;br/&gt;private int bodyCRC;&lt;br/&gt;private int reconsumeTimes;&lt;/p&gt;
&lt;p&gt;private long preparedTransactionOffset;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;因此，可以在消息体的 Map&amp;lt;String, String&amp;gt; properties 属性上附加打标信息。&lt;/p&gt;

&lt;h3&gt;发消息的扩展钩子&lt;/h3&gt;
&lt;p&gt;org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl.registerSendMessageHook(SendMessageHook)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/448899/201905/448899-20190520222335898-565093332.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;收消息的扩展钩子&lt;/h3&gt;
&lt;p&gt;org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl.registerConsumeMessageHook(ConsumeMessageHook)&lt;/p&gt;
&lt;p&gt;但由于收消息是一批一批收的，收到的是消息列表 List&amp;lt;MessageExt&amp;gt;，默认配置下只有一个元素，但允许配置多个，因此不能在这个钩子上做扩展。&lt;/p&gt;
&lt;p&gt;因此，对starter做改造，在单个消息消费的位置增加了类似的hook扩展点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ConsumerHook&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ConsumeOneMessageAdvice {
    String hookName();
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; consumeMessageBefore(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; MessageExt msg);
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; consumeMessageAfter(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; MessageExt msg);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;步骤4-线程池子线程传递&lt;/h2&gt;
&lt;p&gt;BizModeContext的原理是用ThreadLocal存储线程范围的上下文，可是实际场景中，总会有些异步和并发的问题，需要使用到线程池。那么问题来了。&lt;/p&gt;
&lt;h3&gt;父线程context如何传递给子线程&lt;/h3&gt;
&lt;p&gt;jdk自带InheritableThreadLocal类解决了父子线程传递的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Thread.init()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Thread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(ThreadGroup g, Runnable target, String name,
                      &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; stackSize, AccessControlContext acc,
                      &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; inheritThreadLocals) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节选。。。&lt;/span&gt;
        Thread parent =&lt;span&gt; currentThread();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (inheritThreadLocals &amp;amp;&amp;amp; parent.inheritableThreadLocals != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.inheritableThreadLocals =&lt;span&gt;
                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节选。。。&lt;/span&gt;
&lt;span&gt;    }
}
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子线程创建时会把父线程的ThreadLocalMap复制到子线程中&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadLocal&amp;lt;T&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ThreadLocalMap(ThreadLocalMap parentMap) {
            Entry[] parentTable &lt;/span&gt;=&lt;span&gt; parentMap.table;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; parentTable.length;
            setThreshold(len);
            table &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[len];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; len; j++&lt;span&gt;) {
                Entry e &lt;/span&gt;=&lt;span&gt; parentTable[j];
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
                    ThreadLocal&lt;/span&gt;&amp;lt;Object&amp;gt; key = (ThreadLocal&amp;lt;Object&amp;gt;&lt;span&gt;) e.get();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        Object value &lt;/span&gt;=&lt;span&gt; key.childValue(e.value);
                        Entry c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry(key, value);
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h = key.threadLocalHashCode &amp;amp; (len - 1&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (table[h] != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                            h &lt;/span&gt;=&lt;span&gt; nextIndex(h, len);
                        table[h] &lt;/span&gt;=&lt;span&gt; c;
                        size&lt;/span&gt;++&lt;span&gt;;
                    }
                }
            }
        }
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;线程池中子线程复用时怎样维护context&lt;/h3&gt;
&lt;p&gt;但如果使用了线程池，子线程运行完并不会销毁，被另一个父线程复用时不会重新初始化。&lt;/p&gt;
&lt;p&gt;这时候我们需要借助一个开源框架 TransmittableThreadLocal  &lt;a href=&quot;https://github.com/alibaba/transmittable-thread-local&quot;&gt;https://github.com/alibaba/transmittable-thread-local&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/448899/201905/448899-20190520222601054-1765333315.png&quot; alt=&quot;&quot; width=&quot;754&quot; height=&quot;563&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图片来自官网）&lt;/p&gt;
&lt;p&gt;在获取子线程时重新读取父线程的上下文，子线程run()执行结束时清理子线程的上下文。&lt;/p&gt;

&lt;p&gt;打通模式标的透传后，能怎么使用呢？大家可以尽情发挥下想象力~何时何地只需要 BizModeContext.getBizMode()&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;日志MDC打标：可以统一给日志记录加入模式标。&lt;/li&gt;
&lt;li&gt;sql自动追加查询条件：通过mybatis插件扩展或甚至是数据源代理，可以给sql自动追加隔离标条件（虽然具体业务中并不那么好用）。&lt;/li&gt;
&lt;li&gt;全链路监控或压测：是的，如果打标的不是bizMode，而是traceId或影子标，就可以通过这个“任督二脉”透传整个系统！&lt;/li&gt;
&lt;li&gt;新模式插件化接入：各业务板块逐渐模块化后，可以通过给扩展点开发实现类的形式接入新模式。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;远景-多模式插件化部署&lt;/h2&gt;
&lt;p&gt;我们期望，未来新的业务模式接入，就像安装插件一样无痛无感知。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/448899/201905/448899-20190520222710563-846874075.png&quot; alt=&quot;&quot; width=&quot;520&quot; height=&quot;275&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新模式接入，只需要增加部署新的bizmodeX节点，其他业务不需要回归测试。&lt;/p&gt;
&lt;p&gt;某个业务，例如bizmode100，部署重启时，其他业务不受影响。&lt;/p&gt;
&lt;p&gt;这还需要一步一步来，目前我们先实现了“任督二脉”的打通，后面的故事，敬请期待哦~&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 14:30:00 +0000</pubDate>
<dc:creator>程序猿攻城狮</dc:creator>
<og:description>你听说过任督二脉吗？像这样~ 咳咳~今天不讲武功，讲电商平台设计的功夫~ 背景 当今的电商可不仅仅是B2C商城，接下来还会有O2O，往后可能还会有商超、奥莱、二手交易。。。且称之为业务模式~而每个业务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/syjkfind/p/10897012.html</dc:identifier>
</item>
<item>
<title>学习RadonDB源码（二） - wingsless</title>
<link>http://www.cnblogs.com/wingsless/p/10896517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wingsless/p/10896517.html</guid>
<description>&lt;h2 id=&quot;为我新的一天没有放弃而喝彩&quot;&gt;1. 为我新的一天没有放弃而喝彩&lt;/h2&gt;
&lt;p&gt;学习是一件很容易放弃的事情，因为就算是不学，我也能在现在的岗位上发光发热。可是人不就是一个热爱折腾的种群吗？&lt;/p&gt;
&lt;p&gt;今天没有放弃不代表明天没有放弃，也许放弃的可能性大于坚持的可能性，不管怎样，坚持一天算一天。&lt;/p&gt;
&lt;p&gt;RadonDB面对着TiDB，OceanBase等等数据库的竞争，都是分布式数据库，为什么要首先学习RadonDB呢？毕竟这是一款真的基于MySQL而不是兼容MySQL的产品，通过学习RadonDB，也许有一天我能在其源码上做出点什么贡献也未可知，我起码对MySQL的熟悉程度更高。&lt;/p&gt;
&lt;h2 id=&quot;继续昨天的话题&quot;&gt;2. 继续昨天的话题&lt;/h2&gt;
&lt;p&gt;昨天我写到了程序的主入口，注意其最重要的一句：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;    // Proxy.
    proxy := proxy.NewProxy(log, flagConf, build.Tag, conf)
    proxy.Start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一切都是从这里开始的，为什么这么说呢？&lt;/p&gt;
&lt;p&gt;这一启动，就好像启动了一个mysqld一样，可以正常的接收mysql客户端的连接请求。&lt;/p&gt;
&lt;p&gt;根据昨天讲述的，proxy的启动实际上是执行了Accept方法，而Accept则是以服务形式启动起来，并且监听了几个端口的。&lt;/p&gt;
&lt;p&gt;那我们再来看看Accept方法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Accept runs an accept loop until the listener is closed.
func (l *Listener) Accept() {
    runtime.GOMAXPROCS(runtime.NumCPU())
    for {
        conn, err := l.listener.Accept()
        if err != nil {
            // Close() was probably called.
            return
        }
        ID := l.connectionID
        l.connectionID++
        go l.handle(conn, ID, l.serverVersion)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码逻辑上看，只要没有执行Close，就会一直循环监听下去，监听的就是一个一个的网络连接请求。&lt;/p&gt;
&lt;p&gt;我猜测这里的连接就好像是我们在MySQL中执行“show processlist”的时候，显示的信息，每来一个连接，就会给它分配一个ID，并启动一个监听器的handler goroutine，可以理解为启动了一个线程，这个线程专门负责该连接。&lt;/p&gt;
&lt;p&gt;到这里我们就可以肯定，RadonDB也是一个单进程多线程的架构，和MySQL并无二致。&lt;/p&gt;
&lt;p&gt;现在就可以分析分析handler方法到底做了什么。这个方法很长很长，我实在是不能一行一行的粘贴过来，只是捡一些有代表性的讲讲。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// handle is called in a go routine for each client connection.
func (l *Listener) handle(conn net.Conn, ID uint32, serverVersion string) {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先映入眼帘的一定是注释，良好的代码一定拥有良好的注释。注释告诉我们，这个handler方法是处理每个客户端连接的。&lt;/p&gt;
&lt;p&gt;客户端连接嘛，每个DBA都知道，连接上来就是为了执行SQL的命令的，有一般的DDL，DML还有些指令性命令。&lt;/p&gt;
&lt;p&gt;那么我推断代码里一定有一个switch分支用于对每种命令进行处理：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;for {
        if data, err = session.packets.Next(); err != nil {
            return
        }

        // Update the session last query time for session idle.
        session.updateLastQueryTime(time.Now())
        switch data[0] {
        // COM_QUIT
        case sqldb.COM_QUIT:
            return
            // COM_INIT_DB
        case sqldb.COM_INIT_DB:
            db := l.parserComInitDB(data)
            if err = l.handler.ComInitDB(session, db); err != nil {
                if werr := session.writeErrFromError(err); werr != nil {
                    return
                }
            } else {
                session.SetSchema(db)
                if err = session.packets.WriteOK(0, 0, session.greeting.Status(), 0); err != nil {
                    return
                }
            }
            // COM_PING
        case sqldb.COM_PING:
            if err = session.packets.WriteOK(0, 0, session.greeting.Status(), 0); err != nil {
                return
            }
            // COM_QUERY
        case sqldb.COM_QUERY:
            query := l.parserComQuery(data)
            if err = l.handler.ComQuery(session, query, nil, func(qr *sqltypes.Result) error {
                return session.writeTextRows(qr)
            }); err != nil {
                log.Error(&quot;server.handle.query.from.session[%v].error:%+v.query[%s]&quot;, ID, err, query)
                if werr := session.writeErrFromError(err); werr != nil {
                    return
                }
            }
//省略其他&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还真的是有，逻辑也不复杂，其实刚才的代码里没有展现出session的概念，先讲讲session在回过头来讲刚才的代码：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;session := newSession(log, ID, l.serverVersion, conn)
//省略一些session的检查等操作

l.handler.SessionInc(session)
defer l.handler.SessionDec(session)

// Reset packet sequence ID.
session.packets.ResetSeq()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;核心思想就是新建了一个session，之后，才有了刚才的操作，要从session中拿出用户操作来，放在一个叫做data的切片中，然后判断切片中具体的操作类型。&lt;/p&gt;
&lt;p&gt;到这里应该很多人都会知道，RadonDB到底做了一个什么样的入口了，其实就是做了一个自己的MySQL服务，监听特定的端口，接收用户的操作。&lt;/p&gt;
&lt;p&gt;这里所有的代码都可以参考以下这个github项目：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xelabs/go-mysqlstack&quot;&gt;go-mysqlstack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者也是RadonDB的作者之一。这个go-mysqlstack的目的也很简单，就是实现一个mysqld：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2921521-47734bfccb6a1cd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;简介&quot;/&gt;&lt;/p&gt;
&lt;p&gt;官方给的示例，就是启动了一个服务端：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2921521-32d9f659e2dd904b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于交付的客户来说，其实就是在用MySQL，只不过端口有变，服务的启动方式和配置方式不太一样，但是写代码还是用jdbc-driver，对于开发者来说没有任何变化。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;3. 小结&lt;/h2&gt;
&lt;p&gt;Go语言真有意思，利用已经成熟的项目来学习Go语言，我觉得比一点一点看书来的快一些。&lt;/p&gt;
&lt;p&gt;当然了，学会了写之后就要思考，思考这门语言，真的做到Thinking in Go。&lt;/p&gt;
&lt;p&gt;真是学而不思则罔。&lt;/p&gt;
</description>
<pubDate>Mon, 20 May 2019 13:16:00 +0000</pubDate>
<dc:creator>wingsless</dc:creator>
<og:description>1. 为我新的一天没有放弃而喝彩 学习是一件很容易放弃的事情，因为就算是不学，我也能在现在的岗位上发光发热。可是人不就是一个热爱折腾的种群吗？ 今天没有放弃不代表明天没有放弃，也许放弃的可能性大于坚持</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wingsless/p/10896517.html</dc:identifier>
</item>
<item>
<title>深入探究Java中equals()和==的区别是什么 - 炭烧生蚝</title>
<link>http://www.cnblogs.com/tanshaoshenghao/p/10896512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoshenghao/p/10896512.html</guid>
<description>
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&quot;==&quot;相等判断符用于比较基本数据类型和引用类型数据. 当比较基本数据类型的时候比较的是数值, 当比较引用类型数据时比较的是引用(指针).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;判断基本类型是否相等.&quot;&gt;&quot;==&quot;判断基本类型是否相等.&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;首先基本数据类型指的是Java中的八大数据类型: byte, short, int, long, float, double, char, boolean&lt;/li&gt;
&lt;li&gt;这八大基本数据类型有个共同的特点是它们在内存中是有具体值的, 比如说一个int类型的数据&quot;2&quot;, 它在8位数据总线的机器上(假设的)保存形式为&lt;code&gt;0000 0010&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;当使用&quot;==&quot;比较两个基本数据类型的时候, 就是比较它们各自在内存中的值.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;判断引用类型数据是否相等&quot;&gt;&quot;==&quot;判断引用类型数据是否相等&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;引用数据类型在字面上也是很好理解的, 就是一个引用, 它会指向一个具体的对象.&lt;/li&gt;
&lt;li&gt;比如说&lt;code&gt;Student stu = new Student();&lt;/code&gt;, 这里的&lt;code&gt;stu&lt;/code&gt;就是一个引用, 它指向的是当前&lt;code&gt;new&lt;/code&gt;出来的&lt;code&gt;Student&lt;/code&gt;对象. 当我们想要操作这个&lt;code&gt;Student&lt;/code&gt;对象时, 只需要操作引用即可, 比如说&lt;code&gt;int age = stu.getAge();&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;所以用&quot;==&quot;判断两个引用数据类型是否相等的时候, &lt;strong&gt;实际上是在判断两个引用是否指向同一个对象&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;看下面的示例&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    String s1 = &quot;hello&quot;;    //s1指向常量池中的&quot;hello&quot;字符串
    String s2 = &quot;hello&quot;;    //s2也指向常量池中的&quot;hello&quot;字符串
    System.out.println(s1 == s2);   //true

    String s3 = new String(&quot;hello&quot;);   //s3指向的是堆内存中的字符串对象 
    System.out.println(s1 == s3);   //false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;从上面的例子可以看到, 由于引用&quot;s1&quot;和&quot;s2&quot;指向的都是常量池中的&quot;hello&quot;字符串, 所以返回true.&lt;/li&gt;
&lt;li&gt;而&quot;s3&quot;指向的是新创建字符串对象, 因为只要动用了&lt;code&gt;new&lt;/code&gt;关键字, 就会在堆内存创建一个新的对象,&lt;/li&gt;
&lt;li&gt;也就是说s1和s3指向的是不同的字符串对象, 所以返回false.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;equals()和&lt;code&gt;==&lt;/code&gt;有着本质的区别, &lt;code&gt;==&lt;/code&gt;可以看作是对操作系统比较数据手段的封装, 而equals()则是每个对象自带的比较方法.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;equals()和&lt;code&gt;==&lt;/code&gt;的本质区别更通俗的说法是, &lt;code&gt;==&lt;/code&gt;的比较规则是定死的, 如上面所述; 而equals()的比较规则是不固定的, 可以由用户自己定义.&lt;/li&gt;
&lt;li&gt;看下面的例子:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    String s1 = &quot;hello&quot;;
    String s3 = new String(&quot;hello&quot;);    
    System.out.println(s1.equals(s3));  //true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在用&lt;code&gt;==&lt;/code&gt;比较的时候, 上面s1和s3比较出的结果为false. 而当用equals比较的时候, 得出的结果为true.&lt;/li&gt;
&lt;li&gt;想知道原因我们还得看源码, 下面是String类的equals()源码.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean equals(Object anObject) {
    if (this == anObject) { //先比较两个字符串的引用是否相等(是否指向同一个对象), 是直接返回true
        return true;
    }
    if (anObject instanceof String) {   //两个引用不等还会继续比较
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;  //字符串类是用字符数组实现的, 先要拿到两个字符串的字符数组
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {  //然后对两个数组逐个字符地进行比较
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;从上面的源码可以看到, 当调用String类型的equals()方法时, 首先会判断两个字符串的引用是否相等, 也就是说两个字符串引用是否指向同一个对象, 是则返回true.&lt;/li&gt;
&lt;li&gt;如果不是指向同一个对象, 则把两个字符串中的字符挨个进行比较. 由于s1和s3字符串都是&quot;hello&quot;, 是可以匹配成功的, 所以最终返回true.&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;&lt;li&gt;通过上面的讲解相信你已经知道&lt;code&gt;==&lt;/code&gt;和equals()的区别, 一个的比较规则是定死的, 一个是可以由编程人员自己定义的.&lt;/li&gt;
&lt;li&gt;可是为什么会有equals()方法, 而且还可以被自由定制呢?&lt;/li&gt;
&lt;li&gt;这个问题要落到Java语言的核心--面向对象思想了. Java不同于面向过程的C语言, Java是一款面向对象的高级语言. 如果只是面向过程, 直接操作内存上存储的数据的话, 用&lt;code&gt;==&lt;/code&gt;所定义的规则来判断两个数据是否相等已经足够了.&lt;/li&gt;
&lt;li&gt;而Java中处处是对象, 我们经常要面对的问题是这两个对象是否相等, 而不是这两串二进制数是否相等, 仅有&quot;==&quot;是完全不够用的.&lt;/li&gt;
&lt;li&gt;考虑到编程人员会使用Java创建各种满足它们业务需求的对象, &lt;strong&gt;系统无法提前知道两个对象在什么条件下算相等, Java干脆把判断对象是否相等的权力交给编程人员&lt;/strong&gt;.&lt;br/&gt; &lt;/li&gt;
&lt;li&gt;具体的措施是: 所有的类都必须继承Object类, 而Object类中写有equals()方法. 编程人员可以通过重写equals()方法实现自己的比较策略, 也可以不重写, 使用Object类的equals()比较策略.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//Object类中的equals()方法源码
public boolean equals(Object obj) {
    return (this == obj);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;从Object类的equals()源码可以看到, 如果编程人员没有显示地重写equals()方法, 则该类对象默认通过引用数据类型进行比较, 也就是说比较两个引用是否指向同一个对象.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;补充: 关于基本数据类型包装类的比较&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;由于Java中万物皆对象, 就连基本数据类型也有其对应的包装对象, 那么它们对应的比较策略是什么呢?&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    int a = 3;
    Integer b = new Integer(3);
    System.out.println(b.equals(a));    //true, 自动装箱
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;从上面的代码可以看到尽管两个引用不同, 但是输出的结果仍为true, 证明Integer包装类重写了equals()方法.&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//Integer类中的equals方法
public boolean equals(Object obj) {
    if (obj instanceof Integer) {
        return value == ((Integer)obj).intValue();
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;从源码看到, 基本类型包装类在重写的equals方法中, 比较的还是基本数据类型的值.&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;最后欢迎关注我的&lt;strong&gt;免费&lt;/strong&gt;知识星球, 我会在星球中持续更新系统的Java后端面试题分析, 将会囊括Java基础知识到主流框架原理. 还会分享关于编程的趣味漫画.&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/tanshaoshenghao/1426602/o_%e6%98%9f%e7%90%832.png&quot;/&gt;</description>
<pubDate>Mon, 20 May 2019 13:15:00 +0000</pubDate>
<dc:creator>炭烧生蚝</dc:creator>
<og:description>[toc] 相等判断符'=='介绍   '=='相等判断符用于比较基本数据类型和引用类型数据. 当比较基本数据类型的时候比较的是数值, 当比较引用类型数据时比较的是引用(指针).  </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoshenghao/p/10896512.html</dc:identifier>
</item>
<item>
<title>Maven虐我千百遍，我待Maven如初恋 - 二叉树的博客</title>
<link>http://www.cnblogs.com/luao/p/10896403.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luao/p/10896403.html</guid>
<description>&lt;div readability=&quot;10&quot;&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;在如今的互联网项目开发当中，特别是Java领域，可以说Maven随处可见。Maven的&lt;strong&gt;仓库管理、依赖管理、继承和聚合&lt;/strong&gt;等特性为项目的构建提供了一整套完善的解决方案，可以说如果你搞不懂Maven，那么一个多模块的项目足以让你头疼，依赖冲突就会让你不知所措，甚至搞不清楚项目是如何运行起来的，专题的目的就是：彻底搞定Maven！&lt;/p&gt;
&lt;h2&gt;Thinking in Maven&lt;/h2&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;回想一下，当你新到一家公司，安装完JDK后就会安装配置Maven（MAVEN_HOME、path），很大可能性你需要修改settings.xml文件，比如你会修改本地仓库地址路径，比如你很可能会copy一段配置到你的settings.xml中（很可能就是私服的一些配置）。接下来，你会到IDEA或者Eclipse中进行Maven插件配置，然后你就可以在工程中的pom.xml里面开始添加&amp;lt;dependency&amp;gt;标签来管理jar包，在Maven规范的目录结构下进行编写代码，最后你会通过插件的方式来进行测试、打包（jar or war）、部署、运行。&lt;/p&gt;
&lt;br/&gt;上面描述了我们对Maven的一些使用方式，下面我们进行一些思考：&lt;/div&gt;
&lt;div readability=&quot;6.4509547274407&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201905/1613061-20190520202223505-191266934.jpg&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;447&quot;/&gt;&lt;p&gt;Maven仓库配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &amp;lt;!-- localRepository
   | The path to the local repository maven will use to store artifacts.
   |
   | Default: ${user.home}/.m2/repository
  &amp;lt;localRepository&amp;gt;/path/to/local/repo&amp;lt;/localRepository&amp;gt;
  --&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;你要jar包，不可能每次都要联网去下载吧，多费劲，所以本地仓库就是相当于加了一层jar包缓存，先到这里来查。如果这里查不到，那么就去私服上找，如果私服也找不到，那么去中央仓库去找，找到jar后，会把jar的信息同步到私服和本地仓库中。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;私服&lt;/strong&gt;，就是公司内部局域网的一台服务器而已，你想一下，当你的工程Project-A依赖别人的Project-B的接口，怎么做呢？没有Maven的时候，当然是copy Project-B jar到你的本地lib中引入，那么Maven的方式，很显然需要其他人把Project-B deploy到私服仓库中供你使用。&lt;strong&gt;因为私服中存储了本公司的内部专用的jar！不仅如此，私服还充当了中央仓库的镜像，说白了就是一个代理！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中央仓库&lt;/strong&gt;：该仓库存储了互联网上的jar，由Maven团队来维护，地址是：http://repo1.maven.org/maven2/。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;h2&gt;Q2：关于&amp;lt;dependency&amp;gt;的使用&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;坐标配置&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div readability=&quot;6.4399962321025&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;1.12.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;依赖管理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201905/1613061-20190520204135849-1041769128.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;11.995469522241&quot;&gt;
&lt;div readability=&quot;19.11231884058&quot;&gt;
&lt;p&gt;其实这个标签揭示了jar的查找坐标：&lt;strong&gt;groupId、artifactId、version&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一般而言，我们可以到私服上输入artifactId进行搜索，或者到&lt;a href=&quot;https://link.jianshu.com?t=http://search.maven.org/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://search.maven.org/&lt;/a&gt;、&lt;a href=&quot;https://link.jianshu.com?t=http://mvnrepository.com/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://mvnrepository.com/&lt;/a&gt;上进行查找确定坐标。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;version分为开发版本（&lt;em&gt;Snapshot&lt;/em&gt;）和发布版本（&lt;em&gt;Release&lt;/em&gt;），那么为什么要分呢？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在实际开发中，我们经常遇到这样的场景，比如A服务依赖于B服务，A和B同时开发，B在开发中发现了BUG，修改后，将版本由1.0升级为2.0，那么A必须也跟着在POM.XML中进行版本升级。过了几天后，B又发现了问题，进行修改后升级版本发布，然后通知A进行升级...可以说这是开发过程中的版本不稳定导致了这样的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Maven，已经替我们想好了解决方案，就是使用Snapshot版本，在开发过程中B发布的版本标志为Snapshot版本，A进行依赖的时候选择Snapshot版本，那么每次B发布的时候，会在私服仓库中，形成带有时间戳的Snapshot版本，而A构建的时候会自动下载B最新时间戳的Snapshot版本！&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Q3：既然Maven进行了依赖管理，为什么还会出现依赖冲突？处理依赖冲突的手段是？&lt;/h2&gt;
&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201905/1613061-20190520135522336-1609101566.png&quot; alt=&quot;&quot; width=&quot;466&quot; height=&quot;198&quot;/&gt;&lt;div readability=&quot;11&quot;&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;首先来说，&lt;strong&gt;对于Maven而言，同一个groupId同一个artifactId下，只能使用一个version！&lt;/strong&gt;根据上图的依赖顺序，将使用1.2版本的jar。&lt;/p&gt;
&lt;p&gt;现在，我们可以思考下了，比如工程中需要引入A、B，而A依赖1.0版本的C，B依赖2.0版本的C，那么问题来了，C使用的版本将由引入A、B的顺序而定？这显然不靠谱！如果A的依赖写在B的依赖后面，将意味着最后引入的是1.0版本的C，很可能在运行阶段出现类（&lt;strong&gt;ClassNotFoundException&lt;/strong&gt;）、方法（&lt;strong&gt;NoSuchMethodError&lt;/strong&gt;）找不到的错误（因为B使用的是高版本的C）！&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;这里其实涉及到了2个概念：依赖传递（transitive）、Maven的最近依赖策略。&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;依赖传递：如果A依赖B，B依赖C，那么引入A，意味着B和C都会被引入。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Maven的最近依赖策略：如果一个项目依赖相同的groupId、artifactId的多个版本，那么在依赖树（mvn dependency:tree）中离项目最近的那个版本将会被使用。（从这里可以看出Maven是不是有点小问题呢？能不能选择高版本的进行依赖么？据了解，Gradle就是version+策略）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;现在，我们可以想想如何处理依赖冲突呢？&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;想法1：要使用哪个版本，我们是清楚的，那么能不能不管如何依赖传递，都可以进行版本锁定呢？&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;使用&amp;lt;dependencyManagement&amp;gt;  [这种主要用于子模块的版本一致性中]&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;想法2：在依赖传递中，能不能去掉我们不想依赖的？&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;使用&amp;lt;exclusions&amp;gt; [在实际中我们可以在IDEA中直接利用插件帮助我们生成]&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;想法3：既然是最近依赖策略，那么我们就直接使用显式依赖指定版本，那不就是最靠近项目的么？&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;使用&amp;lt;dependency&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;h2&gt;&lt;strong&gt;Q4：引入依赖的最佳实践，提前发现问题&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在工程中，我们避免不了需要加一些依赖，也许加了依赖后运行时才发现存在依赖冲突在去解决，似乎有点晚！那么能不能提前发现问题呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我们新加入一个依赖的话，那么先通过mvn dependency:tree命令形成依赖树，看看我们新加入的依赖，是否存在传递依赖，传递依赖中是否和依赖树中的版本存在冲突，如果存在多个版本冲突，利用上文的方式进行解决！&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Q5：Maven规范化目录结构&lt;/h2&gt;
&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201905/1613061-20190520135602101-1305787265.png&quot; alt=&quot;&quot;/&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;这里需要注意2点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;第一：src/main下内容最终会打包到Jar/War中，而src/test下是测试内容，并不会打包进去。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二：src/main/resources中的资源文件会COPY至目标目录，这是Maven的默认生命周期中的一个规定动作。（想一想，hibernate/mybatis的映射XML需要放入resources下，而不能在放在其他地方了）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;br/&gt;&lt;h2&gt;Q6：Maven的生命周期&lt;/h2&gt;
&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1613061/201905/1613061-20190520205730100-1563668191.png&quot; alt=&quot;&quot; width=&quot;175&quot; height=&quot;283&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;12.5&quot;&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;我们只需要注意一点：&lt;strong&gt;执行后面的命令时，前面的命令自动得到执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;实际上，我们最常用的就是这么几个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;clean：有问题，多清理！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;package：打成Jar or War包，会自动进行clean+compile&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;install：将本地工程Jar上传到本地仓库&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deploy：上传到私服&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;h2&gt;Q7：关于scope依赖范围&lt;/h2&gt;
&lt;/div&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;p&gt;既然，Maven的生命周期存在编译、测试、运行这些过程，那么显然有些依赖只用于测试，比如&lt;strong&gt;junit&lt;/strong&gt;；有些依赖编译用不到，只有运行的时候才能用到，比如&lt;strong&gt;mysql的驱动包&lt;/strong&gt;在编译期就用不到（&lt;strong&gt;编译期用的是JDBC接口&lt;/strong&gt;），而是在运行时用到的；还有些依赖，编译期要用到，而运行期不需要提供，因为有些容器已经提供了，比如&lt;strong&gt;servlet-api&lt;/strong&gt;在tomcat中已经提供了，我们只需要的是编译期提供而已。&lt;/p&gt;
&lt;p&gt;总结来说：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;compile：默认的scope，运行期有效，需要打入包中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;provided：编译期有效，运行期不需要提供，不会打入包中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;runtime：编译不需要，在运行期有效，需要导入包中。（接口与实现分离）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;test：测试需要，不会打入包中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;system：非本地仓库引入、存在系统的某个路径下的jar。（一般不使用）&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 20 May 2019 13:01:00 +0000</pubDate>
<dc:creator>二叉树的博客</dc:creator>
<og:description>前言 在如今的互联网项目开发当中，特别是Java领域，可以说Maven随处可见。Maven的仓库管理、依赖管理、继承和聚合等特性为项目的构建提供了一整套完善的解决方案，可以说如果你搞不懂Maven，那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luao/p/10896403.html</dc:identifier>
</item>
</channel>
</rss>